00:00:08 <desrt> well.. that's no problem
00:00:15 <desrt> haskell has non-determinism built-in
00:00:18 <Cale> hehe
00:00:26 <desrt> list monad, dude.  check it out.
00:00:50 <Cale> A startlingly unpopular remark.
00:00:53 <desrt> i'm not really sure how the compiler does it, but i guess that's why i didn't write the compiler.
00:01:08 <Cale> desrt: there's no magic there
00:01:22 <Cale> return x = [x]; x >>= f = concat (map f x)
00:01:26 <desrt> i know.  the simons are just smarter than me.
00:01:38 <desrt> hmmmm
00:01:40 <Cale> that's all there is to the list monad
00:01:46 <desrt> my SAT algorithm seems to be running slowly
00:01:52 <desrt> i wonder what's wrong
00:01:55 <Cale> hehe
00:02:01 <moconnor> How do I declare a function at the hugs command line and then call it?  Like 'let f x = x+1' in ghci, then I can call f willy nilly.  I seem to be missing something obvious, and I don't see what I want in the user's manual.
00:02:12 <Cale> moconnor: you don't
00:02:14 <moconnor> oh
00:02:16 <xerox> moconnor: add "in f .." to the let
00:02:32 <desrt> xerox; he wants to call it in future commandlines
00:02:42 <xerox> desrt: pretend you live in the future
00:02:52 <moconnor> plan ahead!
00:02:58 <desrt> i'm too busy pretending that P = NP
00:03:03 <Cale> moconnor: even with ghci, it's generally way easier to just stash everything in a file, and use :r to reload it
00:03:30 <moconnor> That's what I've been doing, I got this notion in my head that hugs was friendlier.
00:03:41 <desrt> wait a minute
00:03:44 <xerox> i usually :type them out until they please the type checker, then `let' them.
00:03:51 <Cale> desrt: perhaps you can construct a monad which will tell you the amount of time it would take on a nondeterministic computer, to make the illusion better :)
00:03:53 <desrt> those maps return lists of lists
00:04:02 <desrt> and if you keep concatting those lists, the lists will become long
00:04:10 * desrt files a bug
00:04:14 <Cale> but it's lazy :)
00:04:42 <desrt> Cale; i'm fairly certain that's not possible
00:04:50 <desrt> Cale; without actually doing the computation, that is.
00:04:53 <Cale> So one thing that you do get is relatively fast access to the initial elements of the list.
00:04:58 <desrt> since the time is the time of the longest branch
00:05:08 <desrt> and it's probably not possible to find that out in advance
00:05:13 <Cale> At least, if there aren't tons of failures, and the solution is non-unique
00:05:34 <desrt> good for NP
00:05:37 <desrt> not so good for co-NP
00:05:38 <Cale> So you do get the ability to, say, have the greedy algorithm result by simply taking the head of the list.
00:05:49 <desrt> well, actually.  good for both, i guess
00:05:49 <xerox> > head $ drop 1000000 ([1..] >>= \x -> [1..] >>= \y -> [1..] >>= \z -> return (x,y,z))
00:05:52 <lambdabot>  Exception: stack overflow
00:05:57 <Cale> hehe
00:06:03 <Cale> woops :)
00:06:05 <xerox> hehe
00:06:16 <desrt> consider SAT, though
00:06:36 <ski> xerox : diagonalization would be nice, there ..
00:06:38 <desrt> unless you're a moron, the accepting trace of your turing machine is unambiguous
00:06:55 <desrt> and very likely to be burried in the meat
00:07:10 <desrt> :(
00:08:00 <xerox> ski: what do you mean?
00:08:23 <Cale> It's possible to design a list-like monad in which choices are labelled, and which returns certificates along with computed values.
00:08:28 <ski> > take 10 $ ([1..] >>= \x -> [1..] >>= \y -> [1..] >>= \z -> return (x,y,z))
00:08:30 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1,...
00:09:02 <desrt> Cale; i found out yesterday that there exist polysize certificates for primality that can be verified in polytime
00:09:40 <Cale> Testing primality is in polynomial time.
00:09:48 <desrt> it is not.
00:10:02 <desrt> we have only probabalistic algorithms
00:10:07 <desrt> *i
00:10:35 <Cale> http://primes.utm.edu/prove/prove4_3.html
00:10:37 <lambdabot> Title: Primality Proving 4.3: A polynomial-time algorithm
00:11:03 <desrt> oo.  new result.
00:11:07 <desrt> well.  newish :)
00:11:21 <Cale> http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf
00:11:25 <lambdabot> http://tinyurl.com/y3n2kn
00:11:46 <xerox> ?keal
00:11:47 <lambdabot> antiparsimony were 100% correct...
00:11:51 <xerox> ?keal
00:11:51 <lambdabot> where can i find opensource schematics of Linus Torvalds' x86 clone?
00:12:32 <Cale> hahaha
00:12:35 <Cale> @keal
00:12:36 <lambdabot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
00:13:34 <Cale> the Legendre/Jacobi symbol has the most unfortunate notation in all of mathematics.
00:13:57 <desrt> this is a sweet result, cale
00:14:05 <Cale> It is :)
00:14:09 <desrt> someone should tell wikipedia about it :p
00:14:12 <Cale> haha
00:14:21 <desrt> it's all on about these certificates that can be checked in polytime
00:14:36 <desrt> i have a good certificate.  it's called the empty string and you just check the prime itself. :p
00:14:46 <sieni> is ghc still supported on mac os x 10.3 when using macports?
00:15:09 <Cale> Well, if a problem is in NP, you can construct a polynomial-space certificate which can be checked in polynomial time.
00:15:21 <desrt> right.
00:15:30 <desrt> i'm saying let that certificate be ""
00:15:35 <Cale> right
00:15:41 <desrt> and you can "check" it in polytime :)
00:15:47 <Cale> O(0) space certificate :)
00:15:54 <desrt> quite.
00:16:06 <desrt> so primality is certainly in NP :)
00:20:07 <desrt> In 1983, Adleman, Pomerance and Rumely presented a deterministic algorithm for PRIMES (often referred to as the Cyclotomic method) that runs in time bounded by k(lg n)^(c*(lg lg lg n))
00:20:11 <desrt> ow.
00:20:17 <desrt> to the power of log log log n
00:20:25 <desrt> it's so close that it hurts :p
00:21:25 <Cale> hehehe
00:24:13 <therp> good morning
00:25:12 <protoscript> gentlemen
00:25:59 <desrt> hmm
00:26:09 <desrt> O(n^10.5)
00:26:19 <desrt> that's disgustingly large
00:26:47 <desrt> or ^6 by other tricks.  hmm.
00:27:42 <desrt> now just one more thing to consider.  what bounds the prime factorisation of a number?
00:27:56 <desrt> i'd guess it's linear with some constant factor
00:28:24 <desrt> since in general a product is approximately the size of the things that went into it
00:28:35 <desrt> in any case, certainly a polynomial
00:28:49 <Cale> http://cr.yp.to/papers/aks.pdf -- this paper describes how to speed up the AKS algorithm, lowering the constant factor by over 2,000,000
00:29:07 <Cale> er, by a factor of 2000000, rather
00:29:13 <desrt> now.  we can verify primality in polytime
00:29:47 <desrt> which means that given a number and a proported prime factorisation we can accept or reject
00:30:28 <desrt> reformulate factorisation as a decision problem -- does n have factors in the range (a, b)
00:30:39 <desrt> ((and you can binary search to find the actual factors))
00:31:11 <desrt> now we have a polytime verifier for this decision problem.  given n and its prime factorisation, verify the factorisation and return true/false if a prime factor lies in the range
00:31:43 <desrt> but also have a polytime verifier for the complement of the decision problem.  do the verification but return true only if no factor lies in the range
00:32:17 <desrt> so factorisation is also co-np
00:33:08 <desrt> hmmm
00:33:38 <desrt> so unless PH colapses to the 1st level i'm gonna go ahead and assume that factorisation is NOT np-complete
00:35:13 <dons> hmm. we have either and maybe, but why don't we have one for listss?
00:35:15 <desrt> although pspace being contained in NP would be pretty awesome :)
00:35:23 <dons> ?type maybe
00:35:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:35:33 <desrt> dons; you mean map?
00:35:35 <dons> ?type either
00:35:36 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
00:35:48 <astrolabe> How could you do binary search?  Wouldn't you need to know whether a factor was greater or less than some bound?
00:36:13 <dons> I suppose i mean b -> ([a] -> b) -> [a] -> b
00:36:22 <desrt> astrolabe; just use (0,n) as your range?
00:36:27 <dons> for wrapping head
00:36:33 <dons> which looks like a fold :)
00:36:39 <dons> ?hoogle b -> ([a] -> b) -> [a] -> b
00:36:40 <lambdabot> No matches, try a more general search
00:36:45 <dons> silly hoogle
00:36:50 <Cale> dons: foldr
00:37:05 <desrt> if you want to find some number, ask for (0,n/2) then search (0,n/2) or (n/2,n) accordingly
00:37:15 <Cale> foldr is to lists what either is to Either and maybe is to Maybe
00:37:41 <dons> so oleg raises the issue that fromJust/head errors are fairly easy to avoid
00:37:48 <astrolabe> then the first step would be deciding whether you factor was in (0, floor(n/2)) or [floor(n/2),n).  How could you do that?
00:37:50 <Cale> well, yes they are
00:37:55 <Cale> use case instead
00:37:58 <dons> the problem I see is that it is mostly beginners who make head/fromJust errors, and they don't know the techniques
00:38:03 <dons> so how do we encourage them?
00:38:07 <dons> deprecate fromJust ?
00:38:12 <dons> (that would be possible)
00:38:15 <dons> and what about head?
00:38:33 <Cale> those are hard functions to get rid of
00:38:45 <astrolabe> I don't think you should depricate fromJust, and definitely not head
00:38:53 <dons> yeah, so short of the well known techniques, how can we have beginners do this stuff safely?
00:39:04 <Cale> teach them well?
00:39:09 <xerox> #HaskellPrelude
00:39:14 <astrolabe> But mention in tutorials and books and here that they should be used with caution.
00:39:29 <desrt> astrolabe; uhm.  you just keep searching until you get to a constantly-sized field of numbers to check
00:39:32 <desrt> astrolabe; like, say, 1.
00:39:38 <desrt> astrolabe; then check them and return the prime
00:40:07 <astrolabe> Isn't that an exhaustive search?
00:40:14 * astrolabe as to go to work now :(
00:40:19 <desrt> no.  it's a binary search.  logtime
00:40:22 <astrolabe> *has
00:40:37 <desrt> which means that your search, effectively, is bounded by the number of digits in the number
00:40:40 <desrt> ie: linear
00:40:48 <desrt> *number of steps in your search
00:40:52 <astrolabe> It's binary if you know which half to look in at each stage.  Do you?
00:41:04 <desrt> you do know.  you have a decider.
00:41:32 <desrt> it's the same thing as, for example, finding the largest clique given a k-clique decider
00:42:14 <desrt> and similar to finding a satisfying assignment given a SAT decider
00:42:19 <astrolabe> Where does this decider come from?
00:42:25 <Cale> magic
00:42:27 <desrt> ^^
00:42:44 <desrt> i proved that the decision problem described above is in co-NP
00:43:23 <Cale> You base your argument on the assumption of its existence. There are whole areas which assume that you have a TM halting-oracle and then try to determine what you still can't know.
00:43:34 <astrolabe> ah, thanks
00:43:38 * astrolabe goes
00:44:21 <Cale> but in this case it's slightly less academic, since we really don't know if such a decider exists or not
00:44:36 <desrt> well
00:44:39 <desrt> a decider definitely exists
00:44:55 <desrt> and the language is definitely contained in both NP and co-NP
00:44:56 <Cale> one that does it in polynomial time, say
00:45:04 <desrt> (probably _not_ in P)
00:45:14 * robreim keeps misreading astrolabe as astrobabe and imaging astroboy having a hot sister
00:45:26 <Cale> haha
00:45:41 <desrt> i'm just claiming that turing the decision problem into the problem of actually finding a factor doesn't increase the complexity
00:46:18 <desrt> although i have to admit that it does feel like i'm on slightly shaky ground
00:46:39 <Excedrin> dons: could the compiler convert head/fromJust to a case expression, then use ndm's Catch to issue a warning if it can fail?
00:46:51 <desrt> since a universal(here, universal is the opposite of existential) turing machine with a co-NP oracle is definitely capable of deciding languages outside of co-NP
00:47:02 <Cale> Excedrin: this is (sort of) like what dons is doing.
00:47:20 <desrt> even a normal turing machine with co-NP oracle is capable of deciding languages outside of co-NP
00:47:35 <desrt> eg: it can decide NP languages too
00:47:49 <desrt> maybe i get some love by the fact that factor is in both NP and co-NP
00:47:52 <desrt> maybe i need to sleep :)
00:48:59 <dons> Cale: except we're assuming Catch will spot it statically
00:49:03 <Cale> Complexity theory is interesting. I really should read up on it some more. There is a ridiculous number of unpopular complexity classes.
00:49:11 <dons> Excedrin: fromJust is a case anyway, a case whose default branch is 'error'
00:49:20 <dons> so yeah, Catch should be able to do it ....
00:49:23 <dons> ndm?
00:50:31 <dons> i'm kind of tempted now to add a {-# DEPRECATED fromJust #-} submission to the libraries@
00:50:52 <dons> if we're not adding fromLeft, we should be able to remove .. in time .. fromJust
00:54:07 <Cale> yeah, it is sort of evil
00:54:39 <dons> hehe 'if you look a lot of what C# 3 adds to the language is to make dealing with the static typing easier and thus is in or not needed by Python'
00:54:57 * dons hunts around for clue stick
01:00:09 <Cale> dons: hahaha, who said that?
01:04:03 <dons> oh, some python blogger http://programming.reddit.com/goto?id=qxjj
01:04:12 <dons> " Why Python doesn't need something like the LINQ Project"
01:04:23 <dons> or, why I have no idea what monad comprehensions are or do..
01:04:57 <dons> i like that static typing is 'in or not needed'. Choose one!
01:06:24 <dons> ah good, spj sez ESC-Haskell should help, and Catch.
01:09:44 <ValarQ> dons: does that mean that if static typing is useful it is implemented in python now?
01:13:07 <Cale> dons: actually, python does have list comprehensions already
01:13:24 <Cale> dons: and LINQ isn't providing general monad comprehensions
01:13:41 <Cale> It looks much much closer to list comprehensions to me.
01:14:11 <lambdabot> Title: Coder Who Says Py: Why Python doesn't need something like the LINQ Project
01:15:02 <Cale> Or perhaps something like Traversable functors rather than monads.
01:16:03 <Cale> er, Foldable
01:16:25 <dons> oh, its not?
01:16:35 <dons> ?bot
01:16:45 <dons> where's the bot eh?
01:17:02 <lambdabot> :)
01:17:05 <Cale> http://msdn.microsoft.com/data/ref/linq/default.aspx?pull=/library/en-us/dndotnet/html/linqprojectovw.asp -- scroll to the bottom and they have a list of "Standard Query Operators in a Nutshell"
01:17:09 <lambdabot> Title: The LINQ Project The LINQ Project, http://tinyurl.com/qql9k
01:17:17 <Cale> it's just half the standard Haskell list library
01:17:27 <dons> ah ok
01:17:56 <Cale> mind you, I think there's some polymorphism with IEnumerable
01:18:29 <Cale> but it doesn't look like anything which can't be achieved by just projecting things down to the list monad first.
01:19:11 <Cale> also, there's a bit more syntax than list comprehensions provide -- like orderby
01:19:42 <Cale> but it doesn't really give you anything insanely time-saving
01:20:01 <Cale> (I suppose it does if you're writing programs in C# :)
01:22:13 <Cale> They also apparently have some SQL database integration, which is different of course :)
01:28:57 * kaol hides from dons
01:29:39 <dons> :)
01:36:08 <Cale> hm?
01:38:18 <dons> i found kaol's secret blog with my rss powers
01:40:42 <Cale> http://kaol.livejournal.com/ or more secret than that?
01:40:44 <lambdabot> Title: kaol&#39;s Journal
01:40:49 <dons> http://kaol.livejournal.com/23530.html yep
01:40:51 <lambdabot> Title: kaol: !BSP
01:41:05 <dons> just mentions the word 'haskell' somewere :)
01:42:27 <pejo> Is it usually a design error when one wishes to keep some state from the State monad and throw away the rest of it?
01:42:54 <Cale> pejo: I don't think so.
01:43:01 <Cale> That's what execState is for
01:43:32 <Cale> though it should maybe make you think a bit about why that should be the state component and not the value component
01:46:06 <pejo> Cale, oh. I want the value too, just want to throw away most of the state.
01:49:03 <Cale> oh, most of the state -- I suppose that's fine. Is most of it needed during the algorithm?
01:53:24 <pejo> Yeah, but most is internal stuff to the algorithm.
01:57:24 <pejo> Thanks, have to grab lunch now though.
02:57:58 <dons> ?yow!
02:58:00 <lambdabot> All of a sudden, I want to THROW OVER my promising ACTING CAREER, grow
02:58:00 <lambdabot> a LONG BLACK BEARD and wear a BASEBALL HAT!! ...  Although I don't know
02:58:00 <lambdabot> WHY!!
02:58:06 <dons> ?users
02:58:08 <lambdabot> Maximum users seen in #haskell: 265, currently: 255 (96.2%), active: 7 (2.7%)
02:58:28 <dons> > fix $ \f -> 1 : 1 : zipWith (+) f (tail f) -- lambdas for all!
02:58:30 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:02:37 <roconnor> @pl fix $ \f -> 1 : 1 : zipWith (+) f (tail f)
03:02:38 <lambdabot> fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
03:02:54 <roconnor> > fix ((1 :) . (1 :) . ap (zipWith (+)) tail) -- lambdas for none!
03:02:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:03:05 <Binkley> @quote
03:03:06 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
03:03:13 <profmakx> lambdas vor C#
03:03:46 <profmakx> i can remember some guy praising the benefits of those delegates in C# on some conference
03:03:52 <profmakx> icks
03:03:55 <profmakx> *for
03:04:22 <Binkley> lambdas for some, miniature American flags for others
03:04:31 <roconnor> Binkley: horray!
03:04:44 <fasta> What do you think of http://web.comlab.ox.ac.uk/oucl/work/geraint.jones/morehaste.html ?
03:04:50 <lambdabot> Title: Research Highlights - More Haste Less Speed, http://tinyurl.com/y8gr3h
03:04:51 <profmakx> I`d like to see a "Haskell rules" flag for Homer Simpson
03:05:32 <fasta> Apparently it was published, but the thesis seems completely false.
03:05:42 <Binkley> fasta, why do you think it's false?
03:05:55 <fasta> This demonstrates that lazy evaluation is strictly more efficient - in asymptotic terms - than eager evaluation, and that there is no general complexity-preserving translation of lazy programs into an eager functional language.
03:06:03 <fasta> This quote for example.
03:06:12 <roconnor> fasta: http://r6.livejournal.com/26564.html
03:06:15 <lambdabot> Title: r6: More Haste, Less Speed
03:06:27 <Binkley> seems ok so far
03:07:12 <fasta> You can emulate lazy evaluation in a strict language, so I miss the point.
03:07:23 <fasta> The emulation has constant time overhead.
03:08:08 <fasta> => I think it's pointless to produce a paper about that subject.
03:08:26 <Binkley> fasta, i agree that you can emulate lazy evaluation in a strict language
03:08:28 <roconnor> fasta: why does the emultation have a constant time overhead?
03:08:32 <Binkley> however, are you sure the emulation has constant time overhead?
03:11:13 <fasta> Binkley: Somehow the program in the functional language gets translated to a physical process. That physical process clearly can "mutate".
03:12:06 <fasta> Binkley: using delay and force in Scheme should also do the trick.
03:12:12 <Binkley> fasta: that's not a proof
03:12:52 <roconnor> fasta: Scheme isn't under consideration.  They are considering a pure strict functional language as I understand.
03:13:37 <roconnor> (such as the pure strict subset of scheme)
03:13:43 <fasta> roconnor: ok, good point.
03:14:26 <fasta> roconnor: only delay and force can be easiliy implemented without delay and force.
03:14:44 <fasta> Hmm, never mind
03:14:45 <fik_> roconnor, where can i read about the pure strict funtional subset of Scheme?
03:15:35 <roconnor> fik_: I don't know
03:16:25 <fasta> Ok, well, still it's a rather pointless thing to reseach:"Look, when we downsize a language and place artificial restrictions on it some programs go slower".
03:16:35 <fasta> research*
03:17:52 <Binkley> fasta: starting with understanding theoretical problems is the only way to put more practical problems on a formal basis
03:18:04 <guerra> im looking for a free system monitor to run under windows, just wanna monitor my ram use and such things! anyone knows one?
03:18:32 <Binkley> guerra: Process Explorer
03:18:47 <guerra> Binkley: cool, will download it
03:20:31 <fasta> Binkley: I don't think proving something about something that assumes that one can't mutate anything is quite useless, especially when you are comparing with lazyness (which only can be implemented with another lazy language or with an impure one efficiently).
03:21:00 <fasta> s/'t/
03:21:15 <fasta> s/'nt/
03:22:00 <Binkley> well, the editor of the JFP didn't think it was useless, so maybe it's worth thinking about why
03:23:03 <fasta> I suppose that proving that you can't implement lazyness efficiently in a pure strict language is a nice result, though.
03:24:05 <psykotic> how is cost measured?
03:24:20 <psykotic> if it's number of beta reductions in the usual operational semantics, then the result seems almost trivial to me.
03:24:53 <fasta> psykotic: Probably the number of operations a Turing machine would do.
03:25:22 <psykotic> a turing machine? i sure hope not :)
03:25:56 <psykotic> oh, you did say it was asymptotic complexity. is that so?
03:26:03 <fasta> right
03:27:32 <psykotic> oh, bird and de moer are involved.
03:27:41 <psykotic> then there must be something interesting.
03:49:43 <roconnor> fasta: There are maybe good reasons for working in a pure langauge, but not as many reasons for working in a lazy langauge.
03:49:48 <roconnor> er
03:49:56 <roconnor> fasta: There are many good reasons for working in a pure langauge, but not as many reasons for working in a lazy langauge.
03:50:35 <roconnor> so this article gives a good reason why you want to work with a lazy language if you are going to work in a pure langauge.
03:51:11 <roconnor> ... and I'm talking to no one
03:51:34 * Binkley is no one
03:52:06 <roconnor> Binkley: I don't need to convince you
03:52:10 <Binkley> heh
03:52:23 <Binkley> in practice, though, there aren't any pure strict languages anyway :-)
03:53:15 <roconnor> Yep.  If one wants to go swimming with sharks, or program in a non-pure langauge, I suppose that is one's choice
03:53:16 <Philippa> yeah, although the idea's been floated enough times as a quick and cheap way to get pure languages working for people who need predictable time and space analysis
03:53:43 <psykotic> plotkin's lambda_v is just chopped liver, huh? :)
03:53:53 <roconnor> psykotic: yep
03:57:00 <Philippa> wrong value of "working"
03:58:17 <guerra> guys, if i will create a function that will return either a [int] or a Strig i do this: jogadaHuman :: [Int] -> Int -> Int -> (Either [Int] String) - isnt it?
03:58:39 <roconnor> guerra: looks good to me
03:58:40 <Binkley> sure, you can do that
03:58:45 <psykotic> Philippa, it's essentially core scheme minus set!
03:58:52 <psykotic> (or eq?)
03:59:44 <Philippa> yeah. But if you want a "real-world" implementation you still get it by sticking to a subset of an existing language without having that enforced for you
04:00:33 <guerra> roconnor: Binkley and when i will create the function i do Left (my  [Int] return)  and Right (My String)
04:00:55 <Binkley> guerra: right
04:01:49 <roconnor> guerra: out of curiosity, is the String an error condition?
04:01:56 <guerra> Binkley: ok, i did all that, but when i make a call to the function in which i defined that, i get some weird errors
04:02:00 <guerra> roconnor: yes
04:02:28 <roconnor> guerra: by convention a string for an error is placed on the left.
04:02:43 <roconnor> so Either String [Int] would be more appropriate.
04:02:59 <guerra> roconnor: hummm
04:03:15 <roconnor> (because (Either String) is a monad)
04:05:01 <pejo2> Binkley, there's more or less active work ongoing for the pure strict languages. But who needs a compiler anyways? :-)
04:05:37 <dons> the pure strict languages are Clean and Haskell with !'s  ;)
04:05:41 <pejo2> (I assumed "in practice" = exists a compiler).
04:06:38 <guerra> ooh now i understand the error, since im calling it and  normally expect a [Int], it gives me and error saying that couldnt match Either String [Int]
04:07:31 <Philippa> guerra: the convention's because if it's not an error, it must be Right :-)
04:07:37 <dons> heh
04:08:17 <guerra> Philippa: haha ^^
04:08:44 <roconnor> guerra: this is a common situtation in where monadic programming is helpful.
04:09:07 <robreim> Ouch... sounds like a tsunami just hit Japan.
04:09:21 <robreim> Breaking news on the tv... can't find any info about it and can't understand the tv :(
04:09:21 <dons> hmm?
04:09:47 <dons> url?
04:09:50 <SamB_XP_> oh no!
04:09:59 <robreim> I can't find any info on the 'net. It's on the TV...
04:10:08 <roconnor> http://news.google.ca/news?ned=jp&topic=w
04:10:10 <lambdabot> Title: Google ニュース 日本版 - 国際
04:10:16 <robreim> Hearing a lot of "hachi ji" so it sounds like it hit around 20:00 UTC+9
04:10:48 <dons> hmm 10 minutes ago?
04:10:50 <SamB_XP> hmm. I guess lambdabot doesn't understand shift JIS?
04:10:51 <dons> or 1.10
04:11:03 <dons> ?localtime kfish
04:11:38 <dblhelix> the warning that was issues earlier today talked of 12.10 GMT
04:11:45 <robreim> 1 hr ago
04:11:47 <dblhelix> /s/issues/issued
04:12:14 <gds> http://news.bbc.co.uk/1/hi/world/asia-pacific/6150538.stm
04:12:17 <lambdabot> Title: BBC NEWS | World | Asia-Pacific | Tsunami warning issued for Japan, http://tinyurl.com/y3dupw
04:12:18 <robreim> dblhelix: that's now
04:12:22 <dons> ah ok. big earthquate and a warning
04:13:17 <dons> hmm "could hit Hokkaido and Honshu islands after 1210 GMT."
04:13:30 * dons looks at watch, 12.11 ..
04:13:36 <gds> Article's timed at 12:01
04:13:39 <robreim> Yeah, north and east coast: that's what's being shown on the news
04:13:41 <gds> So, they had 10 mins warning.
04:14:52 <gds> unless someone knows that the warning was issued earlier?
04:15:12 <dons> ?users #haskell.jp
04:15:14 <lambdabot> Maximum users seen in #haskell.jp: 5, currently: 2 (40.0%), active: 1 (50.0%)
04:15:25 * robreim backhands the daily yomiuri for still not having a news article about the tsunami even though it's on news sites outside Japan
04:15:44 <dons> irc wins again
04:15:47 <robreim> Japanese bureaucracy striking again no doubt
04:18:09 <therp> I wonder if the number of lives that could be saved when the economical loss from false alarms would be invested in life preserving measure (better health care, better prevention) is actually greated than the number of lifes from a real tsunami weighted by the ratio of false/true alarms.
04:19:01 <therp> sometimes I feel pretty unhuman. but I think that's just my major in economics.
04:19:20 <robreim> I think alarms are about the best "prevention" we currently have against tsunamis.
04:19:44 <robreim> There's not a lot we can currently do other than build attempted barricades and send alerts if we suspect one's about to hit
04:20:05 <therp> robreim: this is pretty expensive prevention if it's a false alarm. I don't want to be in these places in japan now. panic must be normal
04:20:49 <robreim> From what I've heard, people in Japan don't panic that much - it's just routine to be in the middle of a natural disaster.
04:21:15 <robreim> I'm not sure what you'd suggest as an alternative for preventing loss of human life though; unless you consider the human life less costly than the false alarms...
04:22:05 <dons> google has 23 articles now
04:22:11 <dons> http://news.google.com/news?hl=en&ned=us&ie=UTF-8&ncl=http://www.iht.com/articles/ap/2006/11/15/business/AS_GEN_Japan_Tsunami.php
04:22:15 <lambdabot> Title: - Google News, http://tinyurl.com/thtch
04:22:16 <therp> I'm suggesting that money could be spent elsewhere when the false/true positive ratio is too low.
04:22:43 <dons> only about warnings though.
04:22:47 <dons> audreyt_: hey
04:22:56 <dons> yeh
04:24:27 <robreim> therp: I think generally, with something like tsunamis and other disasters causing widespread loss of life, it's better to have false positive warnings than false negatives
04:27:33 <Itkovian> robreim: I agree
04:27:42 <robreim> Also prevention is better than cure. I know of no prevention against loss of human life to tsunamis and other large natural disasters other than simply issuing warnings. The only other place the money could be spent relating to them is cleaning up the inevitable mess. Hopefully warnings reduce that amount of mess so economically as well as ethically it's simply more practical to stick with warnings until we can control the planet.
04:27:57 <Itkovian> They just showed live images from Japanese TV on Balgian news ...
04:28:24 <dons> wow. we heard it hear first. i'm still not seeing anything on .au late news
04:28:28 <guerra> roconnor: now u said that i see i should change it all to monads
04:28:43 <robreim> really? I still haven't seen any live images even here in Japan... Just images of lots of water, not any waves or anything...
04:28:47 <dons> Itkovian but is it just warnings, or the actual wave?
04:28:52 <robreim> Itkovian: you sure it's not file footage?
04:28:55 <Itkovian> warnings
04:28:59 <arjanb> alarms tend to be ignored after only a few false positives..
04:28:59 <robreim> oh ok
04:29:43 <dons> live news in .au now
04:29:44 <Itkovian> They said it was a live feed, so I'm quite certain it's true. Usually Belgian (national) tv news is pretty objective and accurate.
04:29:49 <therp> robreim: that may not be true. it depends on the ratio. it's not like false alarms are for free, they cost real money, real wealth, that could be used to save more lifes. so it's not neccessarily a wise decision to issue them when they are not above a certain probablity.
04:29:56 <dons> water. no reports of damage yet.
04:30:08 <Itkovian> Can;t they see it on satellite images if it's actually true or not?
04:30:19 <dons> if only google maps was live...
04:30:19 <Itkovian> I'm sure ships at sea can confirm/deny as well
04:30:26 <SamB_XP> dons: hah
04:30:41 <psnl> dcoutts: can I give you a mac address here, or would you like an email?
04:31:48 <robreim> therp: afaik tsunamis can only be detected after the earthquake has already hit. They then project the wave size from the measured intensity of the Earthquake. I don't suspect there's terribly many false positives; it's not a long-term projection like some meteorological warnings.
04:32:27 <roconnor> guerra: monads are good for propagating error messages.
04:32:30 <Philippa> depends. Repeated evacuations have financial impact and that can cause loss of life as well
04:32:38 <therp> robreim: I would suggest we discuss false positive in a few hours :)
04:32:40 <Philippa> there's a ratio above which it's better to just take the disasters
04:32:41 <robreim> Also, this particular tsunami warning is showing up as pretty well half of Japan's coast being affected. At very least the "red" regions would get some tsunami...
04:32:46 <dons> google has all 74 news articlesnow
04:32:52 <robreim> therp: fair enough :)
04:34:20 <robreim> Philippa: It'd have to be a pretty poor evacuation strategy to cause significant loss of life I imagine :)
04:34:31 <therp> robreim: but on the generall issue of the inefficiency of some life-preserving measures (ban of genetic modified food for instance) I can recommend Bjorn Lomborg's "The skeptical environmentalist" http://www.lomborg.com/books.htm - sometimes it's a bit lengthly when as he presents a lot of data, but at the end it's a good read
04:34:34 <lambdabot> Title: Bjorn Lomborg
04:34:59 <Philippa> robreim: try living in poverty sometime, then say that
04:35:13 <Philippa> not everyone can afford both to evacuate and deal with the next disaster life throws at them
04:35:22 <robreim> therp: well, bans on genetic food and warnings of natural disasters seem like totally different beasts. It's not like you're legally required to do anything in the event of a natural disaster warning :P
04:35:31 <robreim> So there's a lot less politics involved
04:35:47 <therp> robreim: I would argue both have costs attached to them
04:36:18 <therp> but, well I gotta go, let's rediscuss false warning when I'm back :)
04:37:13 <Tobsan> iGarv
04:37:55 <Lemmih> Tobsan: iGarv?
04:38:22 <robreim> Philippa: In that case it's not the evacuation strategy that's killing them: it's their poverty / inability to protect themselves against the natural disaster. Whether they repeatedly evacuate or stay and get crushed by the natural disaster either way, their poverty is what's put them in a situation to not be able to handle the disaster, not the warnings.
04:38:59 <Tobsan> Lemmih: nvm, it's short for "i'm laughing" in swedish
04:39:29 <robreim> At least the warnings give people the opportunity to attempt to protect themselves.
04:40:27 <Philippa> but they still have to make the same decision each time. And as the number of warnings go up, the number of people who'll be in poverty if they respond to each one does too
04:40:32 <earthy> 'persons are smart. people are stupid'
04:41:04 <dons> I support lennart's proposal to add 'missile launching functions' to haskell
04:41:18 <Philippa> dons: where?
04:41:29 <dons> just landed on haskell-cafe
04:41:32 <robreim> Philippa: Who's making them respond? It's just a warning. If the person feels they can't afford or can't be bothered to respond to each one, they can simply risk staying.
04:41:42 <Philippa> robreim: a sufficiently high level of false positives effectively takes that away again
04:42:23 <robreim> Philippa: all the more reason to stick with a warning system and refine it to be more accurate.
04:42:34 <Philippa> the word you're looking for is "strawman"
04:42:46 <Philippa> I never claimed otherwise
04:42:47 <dozer> could someone post an example of using record syntax in a pattern match? something is going wrong when I try to do it
04:45:27 <robreim> Philippa: If your claim is not that tsunami warning systems may potentially be more costly than they're worth, then I'm not sure what you are arguing.
04:45:48 <Elifant> I've written very small language interpreter using haskell&parsec, now I need to introduce nested scopes. Thus I need some structure (call it Scope) which behaves like a Map, but search variables in the parent Scope, and also track changes of parent Scope. How can I do that?
04:45:56 <Philippa> robreim: now look for the gap between that statement and the one you're actually attacking
04:46:08 <robreim> Philippa: ok, what was I attacking?
04:46:19 <SamB> @type let st { runState = f } = return 1 in f
04:46:22 <lambdabot> Parse error in pattern
04:46:38 <SamB> @type let { runState = f } = return 1 in f
04:46:40 <lambdabot> parse error on input `='
04:46:45 <Philippa> add "therefore we shouldn't use them"
04:46:48 <SamB> hmm.
04:46:55 * SamB forgets how you do it :-(
04:47:14 <SamB> I guess you need to specify a constructor...
04:47:22 <SamB> @type let State { runState = f } = return 1 in f
04:47:25 <lambdabot> forall a s. (Num a) => s -> (a, s)
04:47:50 <SamB> dozer: there
04:47:54 <SamB> record pattern match
04:48:31 <dons> Elifant: perhaps look at the recent lisp interpreter written in haskell/
04:48:32 <robreim> Philippa: on the contrary. I'm arguing that using the warnings has an additional return of hopefully improving the warnings' accuracy with experience and research. That offsets it's cost and is consequently entirely applicable to your argument.
04:49:02 <Elifant> dons, does lisp have mutable variables?
04:49:04 <Philippa> no, it's not. It would be if I were arguing about the actual performance of current systems, but I'm not
04:49:16 <robreim> You may ignore the "all the more reason to stick with" part if it helps
04:51:17 <robreim> you're arguing about the cost to return ratio of the tsunami warnings. My point was that use + expertise leading to better warning systems and consequently more lives saved long term is an additional return to consider.
04:51:55 <dons> Elifant: you just want to implement lexical scoping?
04:52:09 <Philippa> I'm arguing about potentials, again. You directly said that false positives're preferable to the alternative, I'm saying that's not necessarily always the case. You're trying to pursue an overly-concrete argument against a general point.
04:52:17 <dons> why not copy the heap/Map, add the local bindings, and evaluate the expresion in the inner scope
04:52:28 <dons> throwing away the bindings at the end of the block
04:52:30 <Elifant> yes, but language is imperative, thus variables may change
04:52:41 <dons> but you're using a Map aren't you?
04:52:47 <dons> so you can replace values?
04:52:54 <dons> ?type Data.Map.insert
04:52:57 <lambdabot> forall a k. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
04:53:07 <Philippa> Elifant: is it the variables that change, or the storage they refer to?
04:53:39 <Elifant> variable
04:53:39 <Elifant> do you suggests copying variables back to parent scope after procedure call?
04:53:44 <Philippa> most sensible high-level languages take the latter approach these days, the former's only really applicable in languages where variables have LIFO lifetimes
04:54:11 <Philippa> otherwise variable lifetime != storage lifetime
04:54:49 <dons> Elifant: you're writing an interpreter in haskell, yes/
04:54:51 <dons> ?
04:55:00 <Elifant> dons, yes
04:55:04 <dons> in which case, a Map would be fine, whether your variables are mutable or not.
04:55:38 <lennart> dons: except for the scope problem being annoying with a Map
04:56:11 <lennart> you need to remove the variables in the inner scope as you leave it and make sure shadoed variables in the outr scope come back
04:56:13 <dons> yeah, handling it manually might get a bit annoying
04:56:13 <robreim> Philippa: Well, my statement was with relation to a concrete example. I said "with tsunamis and other disasters causing widespread loss of life". If you weren't speaking in such concrete terms, perhaps you were beating the straw man?
04:56:30 <Elifant> hm... now I implement global scope only, so I'll try to implement local scopes using Map and will return with more concrete questions :)
04:56:47 <Philippa> robreim: that's not particularly concrete though, there are many instances of it
04:56:58 <lennart> So i think a Map for variable-to-location mapping, and then another Map for the locations would make it easier
04:57:12 <dons> ah maybe
04:57:25 <robreim> Philippa: well, perhaps if you give an example of a natural disaster which supports your case I might be inclined to agree with you, for that case. But for the ones I have in mind, I think what I said was entirely appropriate.
04:57:37 <Elifant> intermediate Map : variable_name -> location_id ?
04:57:51 <Philippa> robreim: it's not a matter of specific disasters, it's a matter of how often the false positives occur
04:57:57 <lennart> Yes, and you never mutate anything in that map
04:58:20 <lennart> you just mutate in the location_id -> value map
04:58:33 <Elifant> ok, manually implemented pointers :)
04:58:36 <robreim> Philippa: well in that case, I'm not arguing with you since I'm quite aware that false positives can be costly "in general"
04:58:37 <Philippa> I think the odds of there never throughout human history having been a case where they occurred so regularly that nobody paid attention when the real thing hit until it was too late are approximately nil
04:58:50 <lennart> The two maps are usually called environment and store
04:59:20 <lennart> Standard trick in denotational semantics.
04:59:43 <Elifant> ok, many keywords, let's time to google. thanks
05:00:07 <dcoutts> psnl, here is fine
05:00:45 <robreim> Philippa: I can't disagree with that. Though I'd just say it's a good reason to research ways to decrease false positives (and I know that's nothing to do with what you're arguing)
05:00:54 <Philippa> yeah, I agree entirely
05:01:45 <robreim> Nothing better than having a half hour debate with something to finaly conclude you never disagreed to begin with. :)
05:02:00 <psykotic> lennart, btw how do DS's usually deal with "allocating" something in the store? does a distinguished location in the store keep the next location from which to allocate something?
05:02:00 <Binkley> somehow I find a lot of my debates end up like that
05:02:07 * psykotic can't recall.
05:02:51 <lennart> psykotic: You usually have an operation like 'new' for the store.  So the store keeps track of the next free location.
05:03:54 <psykotic> right. so if sigma : Z -> Values you might do... new : Store -> (Location, Store) where new(s) = (s(0), s[0 <- s(0) + 1]).
05:04:20 <psykotic> although that requires a Location to be a Value. but that's a technicality, i guess it's not essential.
05:08:56 <lennart> psykotic: Just treat the Store as an abstract type which is represented by an (unbounded) array and an index.
05:09:20 <lennart> psykotic: and yes, new has that type.
05:09:41 <lennart> And you can hide all the gory stuff in a monad if you want :)
05:13:04 <dons> ?users
05:13:04 <lambdabot> Maximum users seen in #haskell: 265, currently: 252 (95.1%), active: 29 (11.5%)
05:15:11 <lennart> 29 active, huh?  where are you?
05:15:13 <lennart> ;)
05:15:33 <earthy> somewhere 'round here.
05:16:50 <psykotic> most everyone here is just part of don's botnet
05:17:06 <lennart> We are all just bots.
05:17:14 <desrt> beep.
05:17:15 <psykotic> he even fakes conservation sometimes to make it look lively to new visitors
05:17:22 <psykotic> conversation, too! :)
05:17:34 <lennart> New bot visitors, you mean?
05:17:52 <psykotic> of course, of course
05:17:58 <norpan> indeed
05:19:15 <psykotic> okay, here they come. everyone act person-like, okay?
05:19:24 <lennart> k
05:19:30 <desrt> beep.
05:19:43 * kaol is written in fortran
05:19:53 <desrt> kaol; condolences.
05:20:01 <kaol> yeah. I know. It sucks.
05:21:33 * xerox runs in the type system
05:22:57 * earthy runs dependently
05:23:33 * psykotic is a lowly shell script.
05:23:36 <Pegazus> is this valid?: (1,2,3) == (,,) 1 2 3
05:23:42 <xerox> ?type (,,)
05:23:45 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
05:23:48 <xerox> Yes.
05:23:52 <ski> @check (1,2,3) == (,,) 1 2 3
05:23:54 <lambdabot>  OK, passed 500 tests.
05:24:19 <earthy> psykotic: sh, ksh or tcsh? :)
05:24:19 <Pegazus> but isn't that "similar" to (==) (1,2,3) (,,) 1 2 3?
05:24:27 <earthy> no
05:24:29 <xerox> no
05:24:32 <Pegazus> why not?
05:24:36 <ski> > (==) (1,2,3) ((,,) 1 2 3)
05:24:37 <flux__> shouldn't 0-parameter functions be tested only once?
05:24:39 <lambdabot>  True
05:24:45 <earthy> because the second argument is (,,) which is a function
05:24:46 <flux__> or was that only a feature of that quickcheck-spinoff
05:25:08 <Pegazus> i know, but i don't understand why (1,2,3) == (,,) 1 2 3 works then... :p
05:25:20 <xerox> because == has lower precedence
05:25:28 <Pegazus> k thanks!
05:25:30 <ski> '(1,2,3) == (,,) 1 2 3' means '(1,2,3) == ((,,) 1 2 3)'
05:25:34 <earthy> lower precedence than function application ;)
05:25:41 <xerox> yeah. try :info (==)
05:26:00 <Pegazus> i thought it was all left associative...
05:26:08 <Pegazus> :info (==)
05:26:13 <xerox> ..in ghci.
05:26:21 <Pegazus> ah...
05:26:34 <xerox> we had @info but somebody found that too verbose.
05:26:50 <xerox> as well as @moo (:
05:26:55 <psykotic> @beep
05:26:56 <lambdabot> Maybe you meant: help seen
05:27:01 <lennart> @foo
05:27:02 <lambdabot> Maybe you meant: faq ft todo yow
05:27:27 <lennart> @yow
05:27:28 <lambdabot> Yow!  Am I in Milwaukee?
05:27:31 <psykotic> does that use edit-distance? pretty low threshold :)
05:28:02 <lennart> @quote
05:28:04 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
05:28:36 <lennart> @quote
05:28:38 <lambdabot> mwc says: I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers
05:28:41 <xerox> examples of @moo: http://tunes.org/~nef/logs/haskell/05.05.03
05:28:47 <ski> @ghc
05:28:48 <lambdabot>  Occurs check: cannot construct the infinite type
05:28:56 <ski> @ghc
05:28:58 <lambdabot>  No parameters for class
05:29:44 <xerox> ?quote
05:29:46 <lambdabot> SeanRussell says: [On the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
05:29:47 <lambdabot> Haskell.
05:33:05 <robreim> where do quickcheck properties for the base libraries go?
05:33:51 <Igloo> There aren't really any yet. Perhaps in a base-tests package?
05:34:20 <yax1> hi all
05:34:37 <robreim> oh ok
05:34:40 <Igloo> Or just somewhere in base, ready for when cabal lets us do something useful with them
05:35:01 <psykotic> has someone written something ala smalltalk's findBy for haskell?
05:35:28 <yax1> i'm learning about literate programming with haskell - i am turning .lhs files into pdfs, but they look rather dull
05:35:38 <Igloo> Or you could put them in GHC's testsuite. We don't really have a good story ATM
05:35:55 <robreim> *nods*
05:35:56 <yax1> does anyone have pointers for getting prettier output?  for example putting boxes around the code
05:36:14 <robreim> Ok, well should I set a good example by including a new Tests directory with my patch for the base libraries?
05:36:43 <gds> yaxu: Do you use LaTeX ?
05:37:14 <yaxu> gds: yes, i'm using lhs2tex
05:37:28 <yaxu> in particular, lhs2TeX --poly Parse.lhs > Parse.tex && pdflatex Parse.tex
05:37:47 <Igloo> robreim: The GHC testsuite is probably best for now so they actually get run, but it doesn't currently have any QC tests in I don't think
05:37:55 * Igloo doesn't really know what is best
05:38:18 <Igloo> Oh, actually, that's a lie, it does have a few QC tests
05:38:31 <Igloo> robreim: Yeah, the testsuite is probably best for now
05:38:39 <robreim> Igloo: hm, ok..
05:39:09 <yaxu> the documentation for lhs2TeX is pretty, but my output is dull
05:39:19 <robreim> I feel uncomfortable putting it somewhere that it doesn't seem it belongs. I might just include any quickcheck properties separate from the patch then.
05:40:08 <Igloo> robreim: I've remembered there are QC tests for bytestring, for example, in the testsuite, though
05:40:33 <Igloo> But long-term I really think it should be part of the base package, with cabal knowing how to run them
05:40:38 <yaxu> how can I make http://doc.gold.ac.uk/~ma503am/hs20061115/Parse.lhs give prettier output than http://doc.gold.ac.uk/~ma503am/hs20061115/Parse.pdf ?
05:40:43 <lambdabot> http://tinyurl.com/ymm7wk
05:41:18 <Carneus> hi, i'd like to call haskell code from c
05:41:21 <yaxu> i'm guessing this is a LaTeX problem rather than a lhs2TeX problem
05:41:22 <Igloo> yaxu: lhs2tex is the canonical tool, I think
05:41:26 <Carneus> what'd be the easiest way to do this?
05:41:30 <robreim> Igloo: I agree. It seems to me it would be better to start including the checks with the package they belong to... Putting them all in GHC's test suite seems like it's just going to create more clutter to clean up later on.
05:41:33 <Igloo> If you're using that then no idea
05:42:47 <yaxu> ok thanks Igloo, i'll try digging some more
05:44:14 <gds> yaxu: Chapter 4 of the pdf manual for lhs2tex seems to talk about code prettifying...
05:44:25 <gds> http://www.informatik.uni-bonn.de/~loeh/lhs2tex/Guide2-1.11.pdf
05:44:29 <lambdabot> http://tinyurl.com/wswok
05:45:06 <yaxu> gds: the code itself looks good, but doesn't sit well with the rest of the text
05:45:17 <yaxu> however i think the tips here are what I want - http://www.haskell.org/haskellwiki/Literate_programming
05:45:20 <lambdabot> Title: Literate programming - HaskellWiki, http://tinyurl.com/y5klfa
05:45:28 <yaxu> in particular the listings stuff
05:48:17 <gds> cool :)
05:48:41 <Daveman> Hi xerox :)
05:50:25 <xerox> Hiya Daveman.
06:00:56 <LoganCapaldo> How smart is lambdabot's urllery I wonder... http://tinyurl.com/wswok
06:01:31 <LoganCapaldo> well that answers that question
06:03:20 <wolverian> hm. lhs2tex on ubuntu gives me latex with undefined control sequences (\mathindent, \column, etc)
06:05:51 <earthy> do you have polytable installed?
06:08:13 <gds> http://news.bbc.co.uk/1/hi/world/asia-pacific/6150538.stm
06:08:16 <lambdabot> Title: BBC NEWS | World | Asia-Pacific | Small tsunami hits northern Japan, http://tinyurl.com/y3dupw
06:08:30 <gds> (for those who were following the story earlier)
06:08:55 <gds> small = 40cm
06:10:07 <LoganCapaldo> 40cm tall? wide? How does one measure tsunamis?
06:10:25 <gds> tall, I think.
06:10:28 <LoganCapaldo> Is less than a meter danagerous?
06:10:35 <LoganCapaldo> Maybe I should jsut read the article
06:10:49 <gds> :)
06:12:02 <boliver> LoganCapaldo: for surf it may be :), you may have to swim back by yourself
06:14:01 <therp> robreim: I'm not sure, but I would say that's a false warning considering the threat of a 40cm wave :)
06:25:31 <eviltwin_b> it's still worth a warning:  even 40cm of water, at tsunami speeds, can knock someone off their feet and sweep them into the ocean when it retreats
06:26:23 <rdivacky> what do I haev to import to get "getBounds" ?
06:26:46 <ski> @hoogle getBounds
06:26:47 <lambdabot> No matches found
06:26:56 <ski> dunno
06:27:07 <rdivacky> http://haskell.org/HOpenGL/newAPI/base/Data-Array-MArray.html#v%3AgetBounds
06:27:12 <lambdabot> http://tinyurl.com/y2qbt3
06:27:41 <ski> Data.Array.MArray
06:27:51 <rdivacky> I import it
06:46:58 <dcoutts> psnl, ping
07:04:42 <christine> hi, i am looking for help to solve some problems i have for homework...
07:04:51 <pitecus> ?hoogle Char -> Word8
07:05:03 <lambdabot> No matches, try a more general search
07:08:10 <dylan> I so wish I could write this in haskell :-/
07:08:30 <slamicek> hello people
07:08:56 <slamicek> im wondering if there is a lib that can do text formating, or could help me with text formating ?
07:14:21 <slamicek> is there a function in haskell that can do the same as strcpy in C ?
07:15:23 <vegai> slamicek: you probably don't need it
07:15:33 <vegai> what are you trying to do?
07:16:55 <slamicek> well what i want to do is to replace for example every word : "my" with word "you" in a string
07:17:53 <slamicek> so if i have an input "My house and my car" , the output would be "you house you car"
07:17:53 <sjanssen> > unwords . map (\s -> if s == "my" then "you" else s) . words $ "my baloney has a first name"
07:17:57 <lambdabot>  "you baloney has a first name"
07:18:42 <sjanssen> you do realize that will generate grammatically incorrect sentences, yeah?
07:18:45 <slamicek> unwords is some kind of a default func ?
07:18:53 <sjanssen> slamicek: yeah
07:18:57 <slamicek> yeah but it doesnt matter
07:19:10 <sjanssen> @type unwords -- splice a list of words into a space separated string
07:19:11 <lambdabot> [String] -> String
07:19:19 <sjanssen> @type words -- split a string into words
07:19:21 <lambdabot> String -> [String]
07:19:36 <slamicek> thanx man gonna try it
07:20:08 <LoganCapaldo> what about join like perl? Does haskell have it too? I only ask cause I wrote it the other day
07:20:28 <earthy> logancapaldo: you mean  concat . intersperse  ?
07:20:32 <sjanssen> LoganCapaldo: what does join do?
07:20:44 <earthy> > concat . intersperse ", " $ ["a","b","c"]
07:20:46 <lambdabot>  "a, b, c"
07:20:50 <LoganCapaldo> String -> [String] -> String
07:20:54 <LoganCapaldo> what earthy said
07:21:02 <LoganCapaldo> thats interesting
07:21:08 <LoganCapaldo> it does it on the list
07:21:29 <sjanssen> yeah, a function called "intercalate" (yes, stupid name, I know) was recently added to the standard libraries
07:21:33 <ski> christine : did you have a question ?
07:21:50 <sjanssen> you probably won't see it in any releases for a while though
07:22:20 <LoganCapaldo> well concat . intersperse works for me
07:22:29 <christine> yes...
07:22:30 <LoganCapaldo> definitely shorter than what I wrote
07:23:03 <earthy> the haskell standard prelude is ... a treasure trove. ;)
07:23:29 <earthy> but it does require breaking your mind and reassembling the pieces to unlock the trove
07:24:01 <cjeris> > (concat .) . intersperse ", " $ "abc"
07:24:02 <lambdabot>  Couldn't match `a1 -> [[a]]' against `[a2]'
07:24:17 <cjeris> > (concat .) . intersperse ", "  "abc"
07:24:19 <lambdabot>    Expecting a function type, but found `[a]'
07:24:22 <lambdabot>    Expected type: a2 -> a1...
07:24:29 * cjeris still doesn't get (.) . (.)
07:24:30 <ski> (earthy : somewhat like the army ?)
07:24:36 <christine>  iwant to create a function that counts how many times a list appears in another list...
07:24:36 <Binkley> cjeris: yeah, I know the feeling
07:24:50 <earthy> ski: almost entirely but not quite unlike it, yes. :)
07:25:02 <ski> (concat .) . intersperse
07:25:07 <ski> ((.) concat) . intersperse
07:25:15 <ski> (.) ((.) concat) intersperse
07:25:24 <ski> ((.) . (.)) concat intersperse
07:25:25 <cjeris> > ((concat .) . intersperse) ", " "abc"
07:25:26 <lambdabot>  Couldn't match `[Char]' against `Char'
07:25:43 <cjeris> oh, half the problem is that i'm stupid.
07:25:43 <earthy> pointless :)
07:25:53 <cjeris> > ((concat .) . intersperse) ", " ["a", "b", "c"]
07:25:55 <lambdabot>  "a, b, c"
07:26:22 <christine> something like f:: [char]->[char]->int
07:26:27 <sjanssen> christine: are you talking a substring search?
07:27:06 <sjanssen> > length . filter (isPrefixOf "baloney") . tails $ "my baloney has a first name"
07:27:07 <ski> christine : or is the second list a list of lists ?
07:27:08 <lambdabot>  1
07:27:10 <christine> sort of...
07:27:35 <cjeris> ski: i see the derivation, i just haven't gotten pointless programming to sink into my brain yet. :)
07:27:36 <slamicek> hey people
07:27:42 <LoganCapaldo> er, I don't seem to have intersperse
07:27:47 <slamicek> whatz wrong with this? : changeWords  instring inword chword =  unwords . map (\s -> if s == inword then chword else s) . words $ instring
07:27:51 <sjanssen> LoganCapaldo: import Data.List
07:27:56 <slamicek> i get an error
07:27:58 <LoganCapaldo> Thanks
07:28:06 <LoganCapaldo> (I tried System.List ;) )
07:28:11 <slamicek> Syntax error in input (unexpected `-')
07:28:34 <sjanssen> slamicek: your error isn't in that line
07:29:09 <sjanssen> > let changeWords  instring inword chword =  unwords . map (\s -> if s == inword then chword else s) . words $ instring in changeWord "my" "you" "my stuff"
07:29:11 <lambdabot>  Not in scope: `changeWord'
07:29:12 <slamicek> well but i aint have nothing else
07:29:37 <slamicek> changeWords :: string - > string - > string -> string
07:29:49 <slamicek> is this one  ok ?
07:29:53 <ski> christine : how can you break up the problem into smaller instances of itself (and maybe some new kind of problem which would have to be solved, too) ?
07:29:55 <sjanssen> slamicek: capital S
07:30:01 <christine> nonono... example INPUT ['a','b','a'] ['a','b','a','b','a','a','a','b','a'] OUTPUT 3
07:30:06 <sjanssen> slamicek: no space between "-" and ">"
07:30:12 <slamicek> thanx :)
07:30:21 <ski> christine : ok
07:30:37 <sjanssen> christine: the example I wrote above will work for you
07:31:15 <slamicek> grgr i still got the same error
07:31:42 <earthy> christine: why not 2, in that example?
07:31:48 <sjanssen> > length . filter (isPrefixOf ['a', 'b', 'a']) . tails $ ['a','b','a','b','a','a','a','b','a']
07:31:52 <lambdabot>  3
07:32:09 <sjanssen> slamicek: did you see that you did the "- >" thing twice?
07:33:15 <christine> we have not been tought IsPrefixOf...
07:33:53 <slamicek> well im so so blind
07:33:57 <slamicek> thanx man
07:34:13 <earthy> let isPrefixOf [] xs = True; isPrefixOf (x:xs) [] = False; isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
07:34:14 <ski> (sjanssen : but maybe she wants to use a solution that she has built herself ..)
07:34:39 <earthy> christine: now you have been taught isPrefixOf. :)
07:36:53 <pitecus> Is there any reason why there is no instance of ByteString for Functor and Foldable?
07:37:17 <sjanssen> pitecus: ByteString isn't polymorphic, so you can't write the instance
07:37:35 <yaxu> i'm still having problems formatting my code nicely with lhs2Tex, would anyone here have experience mixing lhs2TeX with the LaTeX listings package?
07:37:58 <pitecus> aha
07:38:05 <christine> thanks. but how do i use boolean to count the times a list appears in another list???
07:38:43 <sjanssen> christine: by counting the number of times the boolean condition is true
07:39:15 <earthy> yaxu: you want to do what?
07:39:28 * earthy has never used lhs2TeX together with the LaTeX listings package
07:39:37 <christine> example???
07:39:38 <earthy> nor needed it
07:39:47 <ski> if blah then 1 + ... else ...
07:40:12 <ski> (e.g. combined with recursion)
07:40:25 <earthy> lhs2TeX tends to Just Do What I Want
07:41:10 <yaxu> earthy: i'd like my code listings to appear in a box
07:41:28 <christine> i am :-(((
07:41:51 <ski> sorry ?
07:41:51 <yaxu> the code doesn't look distinct from the documentation here: http://doc.gold.ac.uk/~ma503am/hs20061115/Parse.pdf
07:41:55 <lambdabot> http://tinyurl.com/tpnxr
07:42:10 <earthy> yaxu: you want something like
07:42:23 <earthy> \begin{figure} \begin{code} code \end{code} \end{figure} ?
07:42:26 <mwc> I wish I was online when dcoutts was told about the email flood
07:42:26 <yaxu> exchange .pdf for .lhs for the source
07:42:49 <earthy> ah, you're doing bird style code
07:43:00 <earthy> that explains a bit :)
07:43:48 <christine> i do not understant it. we know there are no counters in haskell...
07:44:03 <earthy> christine: do you understand filter?
07:44:05 <earthy> @type filter
07:44:07 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:44:14 <ski> christine : do you know how to e.g. compute the length of a list ?  or the sum of a list of numbers ?
07:44:15 <yaxu> earthy: i can convert it, but the literate emacs mode doesn't seem to like the LaTeX formatting so much
07:44:28 <yaxu> literate haskell emacs mode, rather
07:44:52 <christine> e.g.?
07:45:24 <sjanssen> christine: roughly means "for example"
07:46:06 <earthy> does http://www.cs.ubc.ca/~cdutchyn/downloads/mmm-haskell.el help?
07:46:09 <lambdabot> http://tinyurl.com/ymu955
07:46:15 <ski> (in case you don't know "e.g." is latin abbreviation for "exempli gratia" and means "for example" in english)
07:46:18 <christine> as far as i can remember, yes...
07:46:39 <sjanssen> let's walk through writing 'length'
07:46:48 <sjanssen> what is the length of an emtpy list?
07:46:48 <slamicek> could somebody please explain how doest PrettyPrint works, or where could i find it source code ?
07:47:23 <sjanssen> @source Text.PrettyPrint
07:47:24 <lambdabot> http://darcs.haskell.org/packagesbase/Text/PrettyPrint.hs
07:47:37 <sjanssen> @docs Text.PrettyPrint
07:47:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint.html
07:47:41 <yaxu> earthy: i'll try that, thanks.  however if I use \begin{figure} \begin{code} code \end{code} \end{figure} the listing appears at the bottom of the page
07:47:42 <dcoutts_> mwc, I don't think anyone told me. I noticed quite quickly :-)
07:47:43 <slamicek> thanx
07:48:03 <yaxu> i guess i'll look for a good example to work from
07:48:12 <ski> christine : well ?
07:48:13 <christine> length is given to us.
07:48:19 <ski> ok
07:48:22 <matley> why are monads named so?
07:48:28 <ski> but have you seen how it can be defined from scratch ?
07:48:29 <slamicek> nah that darcs link doesnt work
07:48:42 <christine> no.
07:48:46 <earthy> yaxu: yeah, in this example you might rather want \fbox{\begin{code} \end{code}
07:48:48 <earthy> }
07:48:54 <sjanssen> slamicek: it's missing a slash between packages and base
07:49:12 <slamicek> thanx :)
07:49:21 <sjanssen> slamicek: it's quite likely that I broke that, actually :(
07:49:28 <dcoutts_> psnl, I'm giving the IT folk MAC addresses now...
07:49:41 <ski> (matley : someone in category theory thought it was fun to borrow the name from philosophy (Leibniz, in this case) .. and the 'monad' concept in programming is an instance of the category theory concept)
07:49:41 <earthy> yaxu: but that doesn't work well unles you surround the \begin{code} \end{code} with something like a parbox or somesuch, IIRC
07:50:04 <slamicek> hehe did u look at that source code ? :)
07:50:16 <LoganCapaldo> Can someone explain why this is the type of (1,2)?
07:50:20 <LoganCapaldo> @type (1,2)
07:50:22 <lambdabot> forall a b. (Num a, Num b) => (a, b)
07:50:36 <LoganCapaldo> Shouldn't it just be (Int, Int)?
07:50:48 <earthy> logancapaldo: no. numbers in haskell are overloaded
07:50:49 <sjanssen> slamicek: I guess you want to look at Text.PrettyPrint.HughesPJ, then
07:50:51 <eviltwin_b> in the absence of other information it uses the most general type
07:50:56 <kpreid> @type 1
07:50:57 <slamicek> well yeah
07:50:58 <lambdabot> forall t. (Num t) => t
07:51:02 <LoganCapaldo> ok but
07:51:03 <psnl> dcoutts_: around?
07:51:10 <slamicek> i want to take a look at the functions it uses
07:51:15 <LoganCapaldo> Should it maybe be a little more specific?
07:51:15 <earthy> logancapaldo: so that every numeric datatype can be directly filled from numeric denotations
07:51:18 <ski> christine : ok .. are you supposed to solve the excercise by using explicit recursion, or by using some other functions, and in that case, which functions are allowed ?
07:51:22 <dcoutts_> psnl, yep, do you have your ethernet MAC address ?
07:51:28 <earthy> @type (1,2::Int)
07:51:29 <psnl> yes
07:51:30 <lambdabot> forall a. (Num a) => (a, Int)
07:51:32 <kpreid> LoganCapaldo: why would it be more specific?
07:51:45 <LoganCapaldo> They're overloaded but 1 is not a Float, but a float is a Num right?
07:51:49 <dcoutts_> psnl, if you tell me now I can get it to the IT folks right away
07:51:53 <christine> recursion.
07:51:58 <psnl> dcoutts_: just lookingt it up
07:52:01 <kpreid> LoganCapaldo: it's potentially a fluat
07:52:01 <earthy> logancapaldo: there is an instance of Num for float, yes
07:52:13 <kpreid> LoganCapaldo: it's even potentially complex
07:52:14 <LoganCapaldo> How can 1 potentially be a float?
07:52:18 <ski> christine : so, then surely you must have seen some examples of recursion, yes ?
07:52:20 <kpreid> > 1 / 2
07:52:23 <lambdabot>  0.5
07:52:27 <yaxu> it's a bit frustrating in that the lhs2TeX manual has beautiful layout but doesn't say how to get that layout
07:52:37 <earthy> so if you were to use 1 in a context where you need a Float, the compiler knows to treat it as a Float
07:52:42 <LoganCapaldo> but 1 still isn't a float in that expression 1/ 2
07:52:44 <LoganCapaldo> is
07:52:45 <christine> like fibonacci...
07:52:46 <eviltwin_b> the numeric literal "1" can be pretty much any simple numeric type, so haskell lets you determine its type by how it's used
07:52:48 <xerox> ?type (/)
07:52:50 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:52:54 <earthy> (by using fromInteger, IIRC)
07:52:55 <eviltwin_b> this only applies to numeric literals
07:52:58 <kpreid> LoganCapaldo: yes, it is
07:53:07 <earthy> or fromNumeral or somesuch
07:53:08 <christine> no clues on char types...
07:53:16 <LoganCapaldo> Ok
07:53:17 * ski notes it's pretty noisy rn
07:53:26 <LoganCapaldo> I can sort of se it for things like 1 / 2
07:53:30 <LoganCapaldo> or even 1
07:53:36 <ski> christine : do you know how to recurse on lists ?
07:53:39 <eviltwin_b> other laguages require you to say 1.0 or etc. to specify you want a float, but haskell is smarter than that
07:54:06 <LoganCapaldo> but (1, 2), you _know_ that its int int, you're not gonna directly add a tuple or anything, you have to pull the one out
07:54:13 <psnl> dcoutts_: 00-02-3f-14-8b-f3
07:54:14 <christine> using (h:t) only.
07:54:20 <dcoutts_> ta
07:54:25 <psnl> thanks
07:54:32 <LoganCapaldo> I'm probably just dumb :)
07:54:38 <dcoutts_> psnl, that's wired ethernet right? not wireless?
07:54:42 <psnl> wired
07:54:45 <dcoutts_> ok
07:54:59 * psnl is low tech
07:55:08 <dcoutts_> so is the comlab
07:55:12 <Binkley> dcoutts_: if I sent you my MAC address tonight would that be too late? (don't have my laptop with me right now)
07:55:16 <dcoutts_> there's no wirelss anyway :-)
07:55:16 <LoganCapaldo> Ok I figured out the question I really wanted to ask
07:55:32 <dcoutts_> Binkley, not too late
07:55:33 <ski> christine : yes .. in the case when you have a list of *char*, you can still use that .. 'c' will become a character, and you can use '==' to compare characters
07:55:36 <Binkley> ok, cool
07:55:36 <eviltwin_b> no, I don't necesarily know it
07:55:45 <LoganCapaldo> Yes it's Num a, Num b but why doesn't it infer the most specifc type possible instead of the most general type?
07:55:53 <eviltwin_b> it looks like it could well be, but there's no guarantee until I see how it's used or I explicitly type it
07:55:56 <dcoutts_> Binkley, paste it right now and I'll add it to me printout in pen :-)
07:56:16 <eviltwin_b> because then you'd have to explicitly cast it to use it as e.g. a float
07:56:28 <Binkley> dcoutts_: oh, i was just saying I wouldn't be able to get it for a couple of hours, because I don't have my laptop with me right now
07:56:43 <ski> (christine : or shorter .. you can always use the pattern '(h:t)' for any list, regardless of what the elements are .. 'h' will be the first element of this list, and 't' will be the list of all the rest of the elements)
07:56:49 <dcoutts_> Binkley, ok, we might be able to do it in the morning when you arrive
07:56:51 <eviltwin_b> type inference is a good thing, why spike it by forcing types unnecessarily?
07:56:56 <dcoutts_> Binkley, what time are you arriving ?
07:57:39 <LoganCapaldo> eviltwin_b: because I'm used to +. vs. + or something? :)
07:57:46 <Binkley> dcoutts_: I'm leaving Cambridge at 8:30, you probably know better than I how long it takes
07:57:53 <eviltwin_b> like I said, haskell is smarter than that :)
07:57:53 <Binkley> (getting a ride with SimonM)
07:58:03 <dcoutts_> Binkley, ah ok
07:58:45 <eviltwin_b> purists (like my colleagues in the building next door) think it's horrible, of course :)
07:58:53 <kosmikus> yaxu: the manual is open source :)
07:59:37 <yaxu> kosmikus: yes but that source is quite complex...  i guess i can't avoid learning LaTeX properly
07:59:46 <chessguy> 'morning
08:00:22 <kosmikus> yaxu: just tell me what you want to know, and I'll try to answer if I can
08:03:07 <Philippa_> eviltwin_b: what kind of purist?
08:03:17 <yaxu> kosmikus: i'm trying to turn a .lhs file into a pdf with the code parts in nicely offset boxes
08:04:35 <kosmikus> yaxu: that should be relatively easy; you have to say %include polycode.fmt in the beginning of your document, and then state \framedhs somewhere before \begin{document}
08:05:31 <eviltwin_b> Philippa_: CMU SCS is into PL theory, and likes SMLNJ a lot.  as type theory purists they like everything to be explicitly and strictly typed, so they're allergic to type classes and ither conveniences :)
08:05:34 <psnl> Binkley: if you are at MSR, do you know if Barry Jay is coming?
08:05:49 <yaxu> kosmikus: ah, i read about this but don't have polycode.fmt on my system
08:06:07 <Philippa_> eviltwin_b: it should be only the inference they have a problem with, still
08:06:08 <Binkley> psnl: I don't know
08:06:19 <yaxu> kosmikus: i will try upgrading to the latest lhs2tex
08:06:49 <eviltwin_b> nah, being purists everything has to be explicitly typed
08:07:33 <ski> eviltwin_b : but ML pioneered type-inference in programming languages, no ?
08:07:37 <eviltwin_b> it's Just Wrong from their standpoint to have "1" be any numeric type, or "+" to handle any numeric type, etc.
08:08:02 <ski> (though that of which you speak now is overloading ..)
08:08:07 <beelsebob> @hoogle Eq a => [a] -> [a] -> [a]
08:08:10 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
08:08:11 <lambdabot> List.intersect :: Eq a => [a] -> [a] -> [a]
08:08:11 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
08:08:13 <eviltwin_b> it did, but that doesn't stop purists
08:08:37 <eviltwin_b> and type inference from their standpoint is "don't rely on it, you should always explicitly type everything to be Certain"
08:09:05 <ski> eviltwin_b : even all locally bound variables ?
08:09:06 <Philippa_> they're not purists, they're stuckists
08:09:21 <ski> (or worse : all sub-expressions)
08:09:22 <kosmikus> yaxu: which lhs2TeX version do you use?
08:09:31 <eviltwin_b> not sure how far they go into that
08:09:44 <eviltwin_b> it might be more correct to call them strict typing fundamentalists
08:09:51 <Philippa_> + *should* handle any numeric type unless you mean otherwise
08:09:55 <eviltwin_b> CS types are funny that way
08:10:11 <yaxu> kosmikus: i was on 1.9 that came with ubuntu, now i'm trying 1.11
08:10:12 <beelsebob> > map (5,) [1,2,3]
08:10:14 <lambdabot>  Parse error
08:10:27 <beelsebob> map (5 (,)) [1,2,3]
08:10:37 <beelsebob> > map (5 (,)) [1,2,3]
08:10:37 <Philippa_> of course, if they disagree you can ask if they consider ML's module system dangerously powerful
08:10:41 <lambdabot>     add an instance declaration for (Num ((a1 -> b1 -> (a1, b1)) -> a -> b))
08:11:01 <xerox> > map (flip (,) 5) [1..3]
08:11:03 <lambdabot>  [(1,5),(2,5),(3,5)]
08:11:08 <eviltwin_b> the theory purists also hate OCaml, as another reference point
08:11:13 <xerox> > map (id &&& const 5) [1..3]
08:11:15 <lambdabot>  [(1,5),(2,5),(3,5)]
08:11:39 <beelsebob> thanks xerox
08:11:46 <xerox> you're welcome
08:11:47 <glguy> > map (ap (,) (const 5)) [1..3]
08:11:52 <lambdabot>  [(1,5),(2,5),(3,5)]
08:12:01 <kosmikus> yaxu: yes, you should upgrade
08:12:07 <Philippa_> FWIW, my view is "explicitly type everything you care about to be certain"
08:12:19 <Philippa_> but that turns out to be surprisingly little work if you know what you're doing
08:12:26 <yaxu> kosmikus: ok that works now, but still no nice box, even with the example shown in the manual
08:12:45 <eviltwin_b> I explicitly type my functions, and anything otherwise that absolutely needs it.  don't bother explicitly typing every constant
08:13:43 <yaxu> ah well, must run, thanks for the help
08:14:20 <glguy> > zip [1..3] [5,5..]
08:14:22 <lambdabot>  [(1,5),(2,5),(3,5)]
08:15:32 <psnl> Binkley: edwinb and I were wondering if he would gut us over a go board
08:16:14 <Binkley> psnl: that sounds messy
08:16:22 <Philippa_> eviltwin_b: I rarely bother with my functions until I think someone else needs to see the code. But I'm fairly intensely aware of what's inferred from where
08:16:41 <psnl> Binkley: oh, it normally is
08:17:09 * eviltwin_b is still new enough to haskell that he prefers to be forced to think through the types and then let the compiler catch him in any idiocy
08:17:10 <beelsebob> don't worry psnl you or him could gut me over a go board instead
08:17:33 <Philippa_> yeah. It's not H98 but I'd rather do that with eg pattern annotations
08:17:42 <sylvan> I've done some thinking about WHY Haskell programs tend to "just work". It seems like the popular story involves strong typing, but languages like C# have fairly strong typing as well, and I certainly don't feel that those langauges "just work" once they're through the compiler... I think I've figured it out and written it down here http://haskell.org/haskellwiki/WhyHaskellJustWorks feel free to comment/extend/change
08:17:48 <lambdabot> Title: WhyHaskellJustWorks - HaskellWiki, http://tinyurl.com/yarkxe
08:18:10 <psnl> beelsebob: cool
08:18:24 <chessguy> sounds like an interesting article, sylvan. thanks
08:18:52 <sylvan> chessguy: Of course I may be completely wrong. Does anyone know if there is any research about this?
08:19:05 <chessguy> by mistakes has only 1 s before the t :)
08:19:16 <chessguy> or was that intentional?
08:20:00 <sylvan> ah... right
08:21:26 <ndm> sylvan: wiki pages should be "Why Haskell just works" - spaces and a more normal casing
08:22:25 <ndm> sylvan: also:
08:22:28 <ndm> @spell misstakes
08:22:30 <lambdabot> mistakes mistake's miss takes miss-takes misstates
08:22:58 <sylvan> Okay, I've modified some spelling errors
08:23:16 <sylvan> ndm, but it's a title, titles in English have capitalized words
08:23:37 <chessguy> an interesting idea. i think part of it too is that, by nature, FP is highly recursive, reducing the amount of code, and assuming that the smaller cases "just work"
08:24:22 <Philippa_> it's somewhat satisfying that the last time I'd had a major bang-head-against-wall bug it'd been one that'd done the same to early researchers as well :-)
08:24:44 <sylvan> chessguy, I've always "felt" that there simply isn't much room for errors to sneak in since "everything" is type checked but I couldn't quite articulate why this wasn't true for imperative languages...
08:24:49 <Syzygy-> ndm: I just fixed all the misstakes :)
08:24:57 * Syzygy- created a wiki account while he was at it...
08:25:16 <eviltwin_b> for onething, it's easier to construct "domain specific types" that help catch logic errors
08:26:02 <Philippa_> yeah, some of the stuff I use the type system for just wouldn't be tractable without inference
08:26:12 <Philippa_> most of the time I just want it to yell if I mess up
08:26:55 <eviltwin_b> (this is less an issue with imperative languages than with the current crop of imperiative languages
08:27:00 <LoganCapaldo> Philippa_: Are you the Philippa that's on LtU?
08:27:03 <Philippa_> yeah
08:27:13 <Syzygy-> The swedes are invading, eh?
08:27:18 <Philippa_> and the one who wrote those articles on TMR too, before you ask
08:27:23 <LoganCapaldo> I read your comments with great interest
08:27:26 <LoganCapaldo> TMR?
08:27:30 <Philippa_> The Monad.Reader
08:27:33 <LoganCapaldo> Ah
08:27:48 <LoganCapaldo> well thanks you have helped educate me whether you knew it or not ;)
08:28:04 <Philippa_> mmm. Hopefully in programming languages? :-)
08:28:28 <LoganCapaldo> I thought so?
08:28:50 <Philippa_> Good :-)
08:29:48 <Philippa_> I generally try to make comments that're educational to those who've not seen the idea before rather than just "this is wrong...", so it's good to know it works
08:32:58 <glguy> ?fptools Data.List
08:32:59 <lambdabot> http://darcs.haskell.org/packagesbase/Data/List.hs
08:33:18 <glguy> hm.. that link is broken
08:33:51 <glguy> packagesbase should be packages/base
08:33:51 <sjanssen> glguy: yeah, missing a slash after packages
08:33:56 <sjanssen> I already sent the patch
08:35:59 <pejo> Syz, what swedes were invading, and where?
08:37:47 <sylvan> I've invaded the UK, for one thing...
08:53:07 <araujo> morning
08:55:25 * dylan wishes HDirect was maintained.
08:55:43 <dylan> or that there was some other way of using activeX objects from haskell
09:31:17 <tibbe> I had a really good question I wanted to ask you guy
09:31:24 <tibbe> but I forgot it on my way home :(
09:32:04 <agocorona> did someono of you tried System.Eval.Haskell ?
09:32:37 <xerox> > 2+2
09:32:41 <lambdabot>  4
09:32:41 <xerox> yes!
09:34:25 <agocorona> i just want to know: if I can do this:  let a=3 in eval "a*a"
09:35:08 <agocorona> that is: if either the compiled code access to the current context variables or not
09:35:40 <xerox> nope
09:35:49 <agocorona> shit
09:36:19 <xerox> let a = 3 in eval (concat [show a, "*", show a]) works though
09:36:31 <ski> no cross-stage persistance with System.Eval.Haskell ..
09:36:32 <xerox> (even though I think eval has got a more complex type)
09:36:43 <xerox> ski!
09:36:53 <ski> yes ?
09:37:03 <agocorona> if your example works, then the answer is yes, must be
09:37:49 <agocorona> ops, yes, I understand
09:38:05 <agocorona> the string includes the value of a
09:38:27 <qwr> maybe eval "\a -> a * a" $ 3
09:38:55 <agocorona> I have to operate with very large numbers, so I assume that to include the values in the string is too slow
09:39:29 <xerox> agocorona: ah.
09:39:42 <agocorona> qwr, that is quite more interesting
09:39:43 <xerox> agocorona: what other functions does the module provide?
09:39:56 <agocorona> qwe thats quite more interesting
09:39:59 <xerox> hmmm
09:40:01 <xerox> i'm not sure.
09:40:07 <xerox> ?docs System.Eval.Haskell
09:40:08 <lambdabot> System.Eval.Haskell not available
09:40:09 <xerox> no luck
09:40:13 * psnl ponders the map of oxford
09:40:24 <resiak> psnl: any particular reason?
09:40:29 <psnl> so many ways to get lost, so little time
09:40:35 <psnl> resiak: going there tomorrow
09:40:45 <resiak> psnl: bah, it's not that bad :)
09:41:10 <psnl> resiak: does it look nice?
09:41:29 <agocorona> xerox: I use very large numbers and the eval should perform bit ANDs and ORs
09:41:39 * psnl has only seen photos
09:41:50 <agocorona> it is part of a search engine
09:41:55 <xerox> psnl: going to meet duncan?
09:42:08 <resiak> psnl: I like it.  Bit grimey, though.  Also, too many students.</hypocrite>
09:42:23 <xerox> resiak: oxford is awesome :)
09:43:05 <resiak> xerox: visually, or as a place?  I guess I'm just quite used to how it looks.  :-)
09:43:14 <Binkley> universities would be great if they didn't have so many students
09:43:16 <kpreid> agocorona: why do you need eval? where are the expressions coming from?
09:43:24 <psnl> xerox: fun in the afternoon
09:43:31 <xerox> resiak: both!
09:46:14 <agocorona> kpreid the expressions come from the user he can select arbitrary boolean conditions for the matching criteria.  The program transform the words into similar boolean operations with largue Integers.
09:46:52 <kpreid> agocorona: you might want to think about building functions instead of source
09:48:14 <kpreid> e.g. convertBinaryOp [a,"and",b] = \input -> a input .&. b input
09:48:44 <kpreid> or rather, convert "and" = (.&.)
09:49:36 <agocorona> but this is difficult. consider the operator precedence, the pharentesis etc
09:49:57 <tibbe> can't you hack together a parser?
09:50:37 <kpreid> Parsec, for example, has a module for parsing with precedence
09:51:17 <tibbe> what are you parsing? google like search expressions?
09:51:27 <agocorona> yes
09:51:44 <tibbe> how many operators?
09:51:50 <kpreid> in the end, it'll be much better to write a parser than borrow haskell's
09:53:16 <agocorona> just ANDs ORs NOTs
09:53:58 <agocorona> I just want haskell to do it for me
09:54:11 <agocorona> I used to do so in Lisp
09:54:32 <Grey-z> Hi I'm new to haskell and wanted to know what's the easiest way to store a graph in haskell
09:54:47 <psnl> isn't there a library for it?
09:55:26 <psnl> Grey-z: http://www.haskell.org/hoogle/?q=graph <- any of those look good?
09:55:29 <lambdabot> Title: graph - Hoogle
09:56:03 <Grey-z> I googled for it and obviously this wasn't the right way
09:56:21 <Grey-z> thanks for hoogleing, I'll look into that
09:56:35 <agocorona> additionally, using eval, i have cute things like 2+2=4
09:58:58 <nominolo> hm, is there a way to type a continuation in Haskell?
09:59:28 <agocorona> But I will try both Parsec and Eval
09:59:45 <agocorona> Thanks you all
09:59:58 <nominolo> or better: ML-style type systems
10:01:22 <nominolo> the following term doesn't type-check: type Program = State -> Program -> (a,State,Program)
10:01:59 <nominolo> any suggestions?
10:02:57 <nominolo> (I guess I want a monad .. but I can't figure out what kind of :-/ )
10:03:22 <Binkley> nominolo: newtype Program a = P (State -> Program -> (a, State, Program))
10:04:08 <Binkley> you can't define a recursive type with a type synonym
10:04:16 <ski> nominolo : for continuations you can e.g. use module 'Control.Monad.Cont'
10:04:37 <xerox> Binkley: error, Program a?
10:04:38 <ski> nominolo : what do you mean by "ML-style type systems" ?
10:05:57 <nominolo> ski: well, haskell's type system. well, without type classes then (I think)
10:06:10 <Binkley> xerox: right, sorry
10:06:21 <Binkley> newtype Program a = P (State -> Program a -> (a, State, Program a))
10:07:01 <ski> nominolo : you want to use haskell without using type classes ?
10:07:34 <nominolo> ski: no, but my problem has nothing to do with type classes.  i just wanted to generalize my problem ;)
10:07:34 <xerox> Binkley: why isn't that State (Program,a) ?
10:08:41 <Binkley> xerox: well, ask nominolo that :-)
10:09:00 <Binkley> the point is, use newtype instead of type, and name your type parameter
10:09:46 <nominolo> well, in fact it is: newtype Program = State -> Program -> [(Action, State, Program)]
10:10:20 <Binkley> nominolo: you'll need a type constructor on the RHS
10:10:21 <ski> is that supposed to be recursive ?
10:10:39 <tibbe> don't you want a state monad?
10:11:12 <nominolo> i don't know. let me explain my idea behind that
10:11:24 <ski> StateT (MyState,Program) [] Action
10:13:17 <nominolo> the idea is: a program is function that takes a state and a continuation and returns an action and a new state after executing one step and the program that represents the rest of the computation
10:13:26 <nominolo> ie. it's a single-step relation
10:14:02 <nominolo> and i have a possible fork operation, so it may be more than one continuation program
10:14:19 <nominolo> so, it's pretty recursive, isn't it?
10:15:33 <nominolo> but maybe i have to switch representing a program as a lazy list
10:15:49 <nominolo> +to
10:17:45 <nominolo> but don't bother solving this for me, it's kind of an exercise, so i have to solve it myself. i was just wondering if this is typable
10:20:00 <LordBrain> I'm studying  Network.Socket
10:20:08 <LordBrain> and sockets in general
10:20:44 <LordBrain> I tried to translate a simple daytime server written in C to haskell using Network.Socket... but it's not behaving as i expect
10:21:24 <LordBrain> I'll post both programs if anyone is willing to take a look for me
10:21:39 <Binkley> lordbrain: sure.
10:21:40 <Binkley> @paste
10:21:41 <lambdabot> http://paste.lisp.org/new/haskell
10:25:15 <lisppaste2> LordBrain pasted "daytimetcpsrv.c  works fine" at http://paste.lisp.org/display/29955
10:25:40 <lisppaste2> LordBrain pasted "dayserv.lhs" at http://paste.lisp.org/display/29956
10:26:24 <LordBrain> there are remarks in the haskell which tell what happens when i run it.
10:27:04 <fik> ueba banana split
10:27:16 <glguy> ?type sequence . repeat
10:27:40 <Binkley> LordBrain: what happens if you try telnetting to port 13?
10:27:56 <glguy> ?version
10:28:19 <LordBrain> Binkley: connection refused... I didnt use telnet, but nc(netcat) same difference...
10:28:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
10:28:36 <Binkley> and are you running the program as root?
10:28:37 <LordBrain> nc to port 13 basicly is all a daytime client is...
10:28:42 <Binkley> (the server program, that is)
10:28:42 <lambdabot> lambdabot 4p263, GHC 6.5 (OpenBSD i386)
10:28:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:29:10 <LordBrain> Binkley: i've ran it as root and as user, both times the behavour is the same which is not really correct either
10:30:02 <LordBrain> the c program uses wrappers on the calls, that's why the functions are capitalized, but the wrappers just basicly check for errors
10:31:01 <Binkley> and is it possible that something else is already listening on port 13?
10:31:07 <Binkley> I guess not, since you said the C program works
10:31:14 <LordBrain> yeah, the c program works fine
10:31:22 <eviltwin_b> hm, I avoided that issue by making my daemon live under inetd :)
10:31:26 <LordBrain> the haskell seems to hang on accept
10:32:09 <Binkley> LordBrain: did you check if strace gives any clues?
10:32:54 <LordBrain> no Binkley
10:33:34 <Binkley> that could help you figure out which system call is hanging, or whether the connection is actually being refused
10:33:45 <LordBrain> i did a little searching to try and find the C source within GHC's sources, but I'm not really clear yet where that its either.
10:34:41 <LordBrain> how would i use strace?
10:35:53 <Binkley> LordBrain: just run "strace foo"
10:35:57 <Binkley> if foo is your executable
10:36:04 <Excedrin> strace -o program.strace program args
10:36:23 <eventualbuddha> if i have a list A = [(1, [2, 3]), (2, [4])] and a list B = [3, 4], how would i filter A such that none of its tuples' first element is in B ?
10:37:10 <Excedrin> eventualbuddha: maybe use List.nubBy
10:38:15 <eventualbuddha> Excedrin: what does that do?
10:38:41 <LordBrain> 	accept(3, 0xb7dbf078, [16])             = -1 EAGAIN (Resource temporarily unavailable)
10:39:01 <LordBrain> that's running as root... not sure why it would be unavailable
10:40:12 <Binkley> http://unixhelp.ed.ac.uk/CGI/man-cgi?recv+2
10:40:17 <lambdabot> Title: UNIX man pages : recv (2)
10:40:21 <Binkley> sounds like that implies no one is trying to connect to the socket
10:40:35 <Excedrin> LordBrain: is it a O_NONBLOCK socket?
10:40:45 <Binkley> but do you see any errors after your call to bindSocket?
10:40:58 <Binkley> (you could print out a message when you call it so you can look for them)
10:41:29 <glguy> http://www.haskell.org/hawiki/HaskellNewbie_2fTcpIpAndNetworking
10:41:32 <lambdabot> Title: HaskellNewbie/TcpIpAndNetworking - The Haskell Wiki, http://tinyurl.com/yyy6fg
10:41:37 <glguy> this uses acceptConnection
10:41:45 <glguy> and bindSocket sock (SockAddrInet (fromIntegral (1080)) iNADDR_ANY)
10:41:59 <glguy> oops
10:42:07 <glguy> acceptConnection is a wrapper for accept
10:42:10 <glguy> nvm
10:43:07 <pitecus> is there something cheaper than string concatenation for constructing formatted output?
10:43:14 <glguy> ?index bracket
10:43:15 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
10:43:33 <Binkley> @hoogle printf
10:43:34 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
10:43:35 <lambdabot> Text.Printf :: module
10:43:35 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
10:43:36 <Binkley> ;-)
10:43:43 <lisppaste2> LordBrain pasted "dayserv.strace" at http://paste.lisp.org/display/29959
10:43:44 <pitecus> ok
10:44:01 <glguy> LordBrain: mine started working when I used fromIntegral instead of PortNum
10:44:10 <LordBrain> oh?
10:44:41 <LordBrain> in the bindSocket call?
10:44:47 <glguy> LordBrain: yeah
10:45:02 <LordBrain> glguy: Isn't that a type error?
10:45:17 <pitecus> Also it says this in the docs: The shows functions return a function that prepends the output String to an existing String. This allows constant-time concatenation of results using function composition.
10:45:38 <pitecus> Does it mean that its somehow possible to concatenate strings in constant time???
10:46:07 <glguy> LordBrain: is what a type error?
10:46:16 <Binkley> LordBrain: well, it looks like your call to bind isn't failing, at least...
10:46:43 <Excedrin> > filter (\(x,y) -> x `notElem` b) a where a = [(1, [2, 3]), (2, [4]), (3, [1])] b = [3,4]
10:46:45 <lambdabot>  Parse error
10:46:58 <Excedrin> > filter (\(x,y) -> x `notElem` b) a where a = [(1, [2, 3]), (2, [4]), (3, [1])]; b = [3,4]
10:47:01 <psnl> pitecus: somehow I doubt it
10:47:05 <LordBrain> glguy: you used >       bindSocket listenSocket (SockAddrInet (fromIntegral 13) iNADDR_ANY) ?
10:47:09 <lambdabot>  Parse error
10:47:24 <glguy> LordBrain: right
10:47:34 <psnl> pitecus: actually, it might well be doable in haskell, two ++ two strings in constant time
10:47:36 <pitecus> me too, but the wording in this sentence seem to imply that
10:47:37 <LordBrain> hmmm
10:47:53 <pitecus> how, psnl ?
10:48:17 <LordBrain> ok, it's not a type error because fromIntegral makes the conversion from Int or whatever 13 would have been to what is needed which in this case is PortNumber... but then why doesn't PortNum work?
10:48:58 <LordBrain> i'll try your change glguy
10:49:49 <LordBrain> you're right glguy, that does it
10:50:13 <LordBrain> Any theories on why (PortNum 13) is wrong?
10:51:46 <Lemmih> LordBrain: Works for me.
10:51:52 <LordBrain> was it connecting to the wrong port? did it think 13 was a hexidecimal number?
10:52:06 <LordBrain> Lemmih: it works for you with PortNum 13?
10:52:24 <LordBrain> Lemmih: and not (fromIntegral 13)
10:52:27 <Lemmih> Ah, sorry. Didn't see the whole conversation.
10:52:36 <int-e> LordBrain: portNumberToInt (PortNum po) = fromIntegral (ntohs po)
10:52:47 <int-e> LordBrain: you can guess the other direction :)
10:53:45 <Excedrin> PortNum takes a GHC.Word.Word16
10:53:55 <Excedrin> (on ghc at least)
10:54:28 <LordBrain> ok, i dont know sockets well enough probably yet, but you got me in the right direction, thanks int-e, glguy, and Binkley
10:54:46 <int-e> It takes a Word16 in network byte order. The Word16 isn't the problem, the byte order is. (Oh, and its constructor is not meant to be exported - there's a todo comment about this there)
10:55:20 <LordBrain> ooooh
10:55:43 <LordBrain> so i should really pretty much never use PortNumber
10:56:07 <Excedrin> where are the hton/ntoh functions?
10:57:13 <int-e> No, you should use fromIntegral and toIntegral to create PortNumber. It's "PortNum" that's not meant to be exported.
10:57:29 <LordBrain> yes PortNum is what i meant to say, thankyou
10:57:31 <int-e> I shouild've written 'data constructor'
10:57:51 <LordBrain> welll i understood actually
10:58:04 <int-e> And then you don't need the hton and ntoh functions I think.
10:58:15 <int-e> @index hton
10:58:18 <lambdabot> bzzt
10:58:20 <LordBrain> I think this should be put in the documentation
10:58:23 <int-e> @index htons
10:58:25 <lambdabot> bzzt
10:59:01 <LordBrain> so it shows up in the haddock generated docs i mean
11:00:48 * eventualbuddha pasted http://pastie.textmate.org/22890
11:01:05 <eventualbuddha> there must be a better way to do that 竍｡ any suggestions?
11:01:51 <Excedrin> what is lambdabot's yhjulwwiefzojcbxybbruweejw command for?
11:02:02 <int-e> LordBrain: I'll be deferential and say that someone should submit a patch ;)
11:02:07 <Binkley> @yhjulwwiefzojcbxybbruweejw
11:02:08 <lambdabot> "\""
11:02:36 <astrolabe> @type (\\)
11:02:38 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
11:03:08 <astrolabe> > [1..10] \\ [6..15]
11:03:11 <lambdabot>  [1,2,3,4,5]
11:03:15 <astrolabe> ah ha
11:03:30 <astrolabe> aha even
11:03:40 <eventualbuddha> anyone want to take a shot at making that code more haskell-like?
11:04:28 <foxy> @hoogle Fractional a => Integer -> a
11:04:30 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
11:04:47 <foxy> @instances Fractional
11:04:49 <lambdabot> Double, Float
11:05:26 <astrolabe> calling variables things like ll,kk,tt and dd is a bit crytic
11:05:31 <astrolabe> *cryptic
11:06:23 <Binkley> yeah, I was going to say it would be easier to understand what your code does if the variable names were better :-)
11:07:46 <eventualbuddha> well, you could just replace them with the trailing comment
11:08:51 <astrolabe> It is difficult to follow without more comments.  Type signatures would help too.
11:09:32 <astrolabe> (sorry to be critical)
11:10:36 * eventualbuddha pasted http://pastie.textmate.org/22893
11:10:45 <astrolabe> I think you don't need parentheses round snd b (in either case)
11:10:49 <foxy> @hoogle Double -> Integer
11:10:51 <lambdabot> No matches, try a more general search
11:11:03 <glguy> ?type asks
11:11:04 <lambdabot> forall a (m :: * -> *) r. (MonadReader r m) => (r -> a) -> m a
11:11:16 <eventualbuddha> astrolabe: no, please be critical. i'm a total haskell newb
11:11:18 <foxy> @hoogle Num a :: Double -> a
11:11:19 <lambdabot> hoogle: Hoogle.Parser.readType: ([Num,a,::,Double,->,a],BItem ::)
11:11:20 <lambdabot>  
11:12:02 <foxy> @hoogle Num a => Double -> a
11:12:04 <lambdabot> No matches, try a more general search
11:12:22 <foxy> @hoogle fromFrac
11:12:23 <lambdabot> No matches found
11:12:39 <foxy> > toInteger 3.4
11:12:40 <lambdabot>  Add a type signature
11:12:52 <astrolabe> @pl \b -> not  (null (snd b))
11:12:53 <lambdabot> not . null . snd
11:13:00 <foxy> > (toInteger 3.4 :: Double)
11:13:01 <lambdabot>  Couldn't match `Double' against `Integer'
11:13:44 <eventualbuddha> astrolabe: i had a typesig for leaves, but when i made it use \\ it complained about Eq, and i couldn't figure out how to add it so that it'd work
11:14:18 <astrolabe> eventualbuddha: you could ask an interpreter what type it thinks your function is
11:14:27 <eventualbuddha> astrolabe: this is what i had: leaves :: [(a, [a])] -> [a]
11:14:38 <Binkley> eventualbuddha: why isn't treeMinusLeaves defined in terms of leafs?
11:15:15 <astrolabe> Also, it might be better to use a labelled data type for your pairs
11:15:29 <astrolabe> You have to trade off clarity vs effort
11:15:29 <Excedrin> you could use map (\(a,b) -> (a, b \\ leafs)) tree instead of fst and snd
11:15:48 <eventualbuddha> Binkley: well it is, with keepers as a cached intermediate step
11:16:30 <Binkley> ah, didn't see that
11:16:57 <astrolabe> This kind of thing is often clearer with list comprehensions I think.
11:17:02 <glguy> ?docs Control.Exception
11:17:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
11:17:05 <Binkley> well, you can rewrite the definition of treeMinusLeaves as:
11:17:28 <Binkley> (let's see if this works...)
11:17:30 <Binkley> @pl filter (\b -> (snd b) /= []) keepers
11:17:32 <lambdabot> filter (([] /=) . snd) keepers
11:17:32 <eventualbuddha> astrolabe: yeah, i had that at one point
11:17:48 <Binkley> or even better, filter (not . null . snd) keepers
11:18:20 <astrolabe> Binkley: I said that!   ;)
11:18:45 <Binkley> astrolabe: sorry, I should obviously be reading IRC more carefully rather than also rebuilding ghc at the same time :-)
11:19:09 <astrolabe> oooh.  good luck
11:19:10 <eventualbuddha> haha, thanks guys
11:19:15 * eventualbuddha pasted http://pastie.textmate.org/22895
11:19:26 <eventualbuddha> updated 竍｡
11:19:59 <Binkley> eventualbuddha: you can also avoid traversing keepers twice
11:20:55 <eventualbuddha> Binkley: how so?
11:21:20 <Binkley> by writing something like...
11:22:01 <astrolabe> you could try   Eq a => [(a,[a])] -> [a]   as the signature
11:22:33 <eventualbuddha> astrolabe: worked
11:22:42 <astrolabe> hooray!
11:22:43 <Binkley> (treeMinusLeaves, dependencies) = foldl (\ (tml, deps) (a,b) -> (if (not (null b)) then (tml, b:deps) else (a:tml, deps))) [] keepers
11:22:57 <Binkley> I don't guarantee that that's right, but you get the idea
11:23:51 <astrolabe> Depends if you want clarity or efficency
11:24:03 <Binkley> well, I think that the fold version is pretty clear
11:24:10 <Binkley> modulo variable names
11:24:25 <eventualbuddha> at this point i'll take clarity, as i don't expect this will operate over anything with more than 20 elements
11:25:02 <Binkley> the inelegant thing about is that you're defining treeMinusLeaves as a subset of keepers, then defining dependencies in terms of treeMinusLeaves's complement
11:25:04 <eventualbuddha> i'm basically writing it in haskell to try to make my ruby version more succinct
11:25:05 <astrolabe> eventualbuddha: could you explain what it means?
11:25:13 <Binkley> not just that you're walking over the list twice
11:25:32 <eventualbuddha> Binkley: yeah, i know it
11:25:38 <eventualbuddha> let me try yours...
11:26:07 <Excedrin> the commented type signature will work with -fglasgow-exts
11:26:40 <astrolabe> I prefer mine anyway
11:26:46 <eventualbuddha> astrolabe: it takes a list of dependencies and figures out the right order to "do" them in, whatever that means. i'll show an example
11:27:10 <Excedrin> astrolabe: ya, yours is better
11:27:14 <astrolabe> eventualbuddha: you could use partition
11:27:19 <astrolabe> @type partition
11:27:21 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:27:32 <eventualbuddha> astrolabe: yeah, that's what i would have used in ruby
11:28:32 <vincenz> eventualbuddha: eventualbuddha ?
11:28:40 <Binkley> I think partition has the wrong type
11:28:45 <vincenz> Not reallly
11:28:46 <Binkley> unless you want to apply fst and snd afterward
11:28:47 <astrolabe> Ah, so each pair in tree is a node and a list of nodes 1 edge away from it?
11:28:49 <Binkley> which I still think is nicer
11:28:55 <vincenz> Binkley: what type should it be then?
11:28:59 <vincenz> you want filter?
11:29:03 <Binkley> I mean, partition has the wrong type for this problem
11:29:12 <vincenz> oh, right, what is it you're attempting to do?
11:29:20 <Binkley> see above :-)
11:30:02 <vincenz> too much text
11:30:21 <astrolabe> vincenz: http://pastie.textmate.org/22895
11:30:25 <lambdabot> Title: #22895 - Pastie
11:30:29 * vincenz thanks astrolabe 
11:30:54 <astrolabe> I don't understand what it's doing , but I think partition would be useful
11:30:57 <Binkley> the question is how to compute treeMinusLeaves and dependencies in one pass
11:30:57 * eventualbuddha pasted http://pastie.textmate.org/22902
11:31:18 <Binkley> partition isn't quite right because the result you want has type ([a], [[a]]) (I think?)
11:31:19 <vincenz> wow
11:31:24 <Binkley> not ([a], [a])
11:31:25 <vincenz> talk about an inefficient structure!!
11:31:29 <eventualbuddha> just look at the example, not the partition stuff
11:31:53 <Binkley> now you could say, (tm, deps) = partition {- blah blah blah -} keepers
11:31:54 <vincenz> Tree a = Tree a (Forest a)
11:31:54 <astrolabe> (someName,treeMinusLeaves) = partition (null.snd) keepers
11:32:02 <Binkley> treeMinusLeaves = map snd tm
11:32:05 <vincenz> Tree a = Tree a (Forest a) | Leaf a
11:32:12 <vincenz> Forest a = [Tree a]
11:32:13 <Binkley> dependencies = map fst deps
11:32:24 <glguy> Ahh, the joys of correcting the spelling mistakes of those that correct spelling mistakes...
11:32:28 <vincenz> look concat (map snd tree) \\ (map fst treE) is seriously inefficient
11:33:01 <astrolabe> Shouldn't that be 'Ah'?  ;)
11:33:05 <Binkley> well, yeah. that could be...
11:33:12 <Binkley> concatMap (\ (a, b) -> [a,b])
11:33:22 <eventualbuddha> vincenz: i'm looking more for an "elegant" solution than an "efficient" solution, though i know that mine is neither
11:33:24 <Binkley> or rather
11:33:29 <vincenz> eventualbuddha: it's not elegant either
11:33:30 <Binkley> never mind, it's not that at all.
11:33:34 <vincenz> eventualbuddha: an elegant solution would use a proper data type
11:33:48 <eventualbuddha> vincenz: i know, i just said mine wasn't elegant ;)
11:34:11 <vincenz> data Tree a = Leaf a | Branch a (Forest a)
11:34:15 <vincenz> type Forest a = [Tree a]
11:34:32 <vincenz> leaves (Leaf a) = [a]
11:34:44 <vincenz> leaves (Branch a l) = map leaves l
11:34:49 <vincenz> leaves (Branch a l) = concatMap leaves l
11:35:56 <eventualbuddha> vincenz: okay, and how about the dependency part?
11:36:02 <vincenz> ok
11:36:05 <vincenz> let me do this thing completely
11:36:16 <vincenz> suffice to say, with your encoding of a tree, it's hard to tell what you are doing
11:36:37 <glguy> vincenz: your Tree definition does not all for an empty tree, was that intentional?
11:37:13 <vincenz> let me do it
11:37:16 <kzm_> @seen
11:37:17 <vincenz> glguy: no caus e the toplevel is a forest
11:37:18 <lambdabot> Lately, I have seen arjanb, astrolabe, binkley, br1, br1_, dcoutts_, erg0t, eventualbuddha, eviltwin_b, excedrin, glguy, kzm_, tizoc, ulph and vincenz.
11:37:31 <vincenz> glguy: and otherwise I would have also complained about it
11:37:37 <glguy> kk
11:37:40 <vincenz> eventualbuddha: you have one root or many roots at the top?
11:37:41 <eventualbuddha> vincenz: i know. i'm used to ruby where most object you deal with are arrays, hashes, etc
11:37:50 <eventualbuddha> vincenz: many, see the example
11:38:00 <eventualbuddha> http://pastie.textmate.org/22902
11:38:04 <lambdabot> Title: #22902 - Pastie
11:38:13 <vincenz> that says nothing
11:38:16 <vincenz> cause with your encoding
11:38:17 <vincenz> it's hard to tell
11:38:18 <vincenz> what is leave
11:38:21 <vincenz> what is the top
11:39:37 * eventualbuddha pasted http://pastie.textmate.org/22905
11:39:40 <vincenz> eventualbuddha: I take it, that although your system allows DGs, you only allow pure trees?
11:39:44 <eventualbuddha> there, how's that? 竍｡
11:39:52 <vincenz> ah
11:39:55 <vincenz> so it's DAGs
11:39:56 <vincenz> not trees
11:39:58 * vincenz mutters
11:40:09 <vincenz> yay for proper naming
11:40:19 <glguy> vincenz: OK, so if the top level is Forest, then there should not need to be a Leaf constructor
11:40:28 <vincenz> glguy: point taken
11:40:38 <vincenz> but the issue is rather moot, since he wants DAGs and not pure trees
11:41:06 <glguy> vincenz: I'm not even aware for what the actual question is ... I just saw that data definition and it felt wrong
11:41:16 <glguy> but I wasn't sure from the start *why*
11:41:23 <vincenz> glguy: by default I use a different one
11:41:49 <vincenz> eventualbuddha: so you don't want a tree, you want a DAG
11:42:04 <glguy> Isn't there a Data.Graph or something to that effect already?
11:42:05 <vincenz> cause some elements are shared
11:42:08 <vincenz> exactlly
11:42:12 <eventualbuddha> vincenz: i want anything that can encode the information i'm trying to capture: a list of elements and their immediate dependencies
11:42:16 <vincenz> and they even have a function that does that
11:42:21 <vincenz> eventualbuddha: look at Data.Graph
11:42:27 <vincenz> it's badly docced, but it has it all
11:43:16 <kzm_> re recent lists traffic - are we really talking about deprecating 'head', 'fromJust', etc?
11:43:44 <vincenz> and leaf is a bad naming, that's what led me to believe trees at first.  End nodes or something
11:44:10 <vincenz> in fact, I did this very thing once
11:44:12 <vincenz> let me get the code
11:44:14 <eventualbuddha> vincenz: terminalNode is a bit longer than leaf ;)
11:44:22 <vincenz> eventualbuddha: yeah and look how confused it got me
11:44:25 <eventualbuddha> but yeah, point taken
11:44:36 <vincenz> but I have the code to do this
11:44:42 <vincenz> I once needed to do module-dep-anal
11:44:57 <ralf`> I'm working on building a rubics cube.  See: http://www.haskell.org/haskellwiki/RubicsCube
11:44:59 <lambdabot> Title: RubicsCube - HaskellWiki
11:45:01 <glguy> kzm_ link?
11:45:13 <kzm_> glguy, mail :-)
11:45:19 <Binkley> never abbreviate "analysis"
11:45:22 <glguy> a Rubik's Cube?
11:46:54 <Binkley> kzm: given what Simon said, I doubt there's any chance it'll happen
11:47:08 <glguy> haskell or haskell-cafe?
11:47:22 <eventualbuddha> vincenz: this is really just an excuse for me to get to know haskell a little better. the final implementation of this is going to be in ruby, and i was hoping that doing it in haskell would clarify my thinking about the problem
11:48:16 <kzm_> glguy: thread is named 'debugging partial functions by the rules'
11:48:30 <glguy> sweet, found it
11:48:31 <glguy> tahnks
11:49:41 <kzm_> Binkley, true.  My feeble attempt at humour apparently failed, but I have a hard time accepting a request for better error messages leading to replacing 'head' with a similar function with an additional string argument.
11:50:01 <ralf`> glguy: Did you loook at the code for the rubics cube?
11:50:09 <ralf`> It's not working right now.
11:50:10 <kzm_> I mean, we all know how conscientously programmers document their code already, right?
11:50:11 <kzm_> :-)
11:50:26 <glguy> ralf`: no I didn't, I just wondered why you were using a 'c' in the name
11:50:36 <ralf`> well..
11:50:45 <Binkley> kzm: well, I thought your attempt at humor was funny :-)
11:50:46 <vincenz> done
11:50:52 <vincenz> > G.vertices
11:50:53 <lambdabot>  Not in scope: `G.vertices'
11:50:58 <vincenz> depOrder forest = map G.flattenSCC . G.stronglyConnComp . map (\(a,l) -> (a,a,l)) $ forest
11:51:02 <vincenz> that's ALL you need
11:51:07 <kzm_> @karma+ Binkley
11:51:08 <lambdabot> Binkley's karma raised to 2.
11:51:14 <vincenz> G = Data.Graph
11:51:15 <Binkley> though I thought Lennart's post that you were respond to was also funny
11:51:22 <Binkley> now let's all hold hands and sing kumbaya :-)
11:51:38 <vincenz> actually
11:51:42 <vincenz> depOrder forest = concat . map G.flattenSCC . G.stronglyConnComp . map (\(a,l) -> (a,a,l)) $ forest
11:51:45 <vincenz> there you go :)
11:51:50 <glguy> would you too quit patting each other's backs? (-;
11:51:57 <glguy> two*
11:52:12 <kzm_> glguy, well - *somebody* has to do it.
11:52:17 <vincenz> eventualbuddha: gimme some input to test
11:52:52 <eventualbuddha> vincenz: http://pastie.textmate.org/22905, give me a sec to come up with a more elaborate one...
11:52:54 <lambdabot> Title: #22905 - Pastie
11:53:27 <kzm_> I'm not exactly sure whether lennart was serious - first I thought so, but the consequence is of course to prohibit IO at all...
11:53:31 <vincenz> seems I screwed something up
11:54:07 <Binkley> I don't think lennart was serious about adding missile launching functions to haskell, no :-)
11:54:39 <vincenz> ok works :)
11:54:43 <vincenz> @paste
11:54:43 <lambdabot> http://paste.lisp.org/new/haskell
11:54:53 <lisppaste2> vincenz pasted "evilbuddha" at http://paste.lisp.org/display/29968
11:55:04 <vincenz> note that you need all elements at hte toplevel
11:55:10 <vincenz> but you can easily prepass your data
11:55:47 <vincenz> output is: ["users","categories","tags","events"]
11:56:24 <astrolabe> Has anyone suggested the tip from the ghc pages to use a stack trace to locate an error from head etc?
11:57:08 <Binkley> astrolabe: it's been discussed, but that information isn't always useful
11:57:16 <Lajexander> vincenz: what is that?
11:57:24 <vincenz> Lajexander: answer to eventualbuddha's question
11:57:37 <vincenz> it prints the data in order, satisfying dependencies
11:58:00 <eventualbuddha> vincenz: yep, that works
11:58:33 * vincenz preens 
11:58:57 <vincenz> note the concat at the end
11:59:05 <vincenz> cause G.flattenSCC
11:59:07 <vincenz> returns [[a]]
11:59:10 <vincenz> which means that if you ahve cycles
11:59:14 <vincenz> you'll lists with more than one leement
11:59:24 <vincenz> I assume you do not, but you could easily check it
11:59:36 <vincenz> or $ map ((>1) . length)
12:00:13 * glguy wants missile launching functions
12:00:15 <vincenz> vincenz++
12:00:37 <eventualbuddha> vincenz: wow, pretty short
12:00:38 <eventualbuddha> nice
12:00:41 <glguy> (>1) . length ... ewww
12:00:41 <tibbe> vincenz++ = vincen?
12:00:43 <astrolabe> I guess missile launching would have to be in IO
12:00:52 <Binkley> ?remember astrolabe I guess missile launching would have to be in IO
12:01:01 <tibbe> unsafePerformMissileLaunch
12:01:06 <Binkley> unsafePerformIO $ (launchMissiles ...)
12:01:17 <glguy> liftM2 (&&) (not.null) (not.null.tail)
12:01:18 <astrolabe> heh
12:01:19 <glguy> hooray
12:01:21 * vincenz is karmawhoring
12:01:34 <Philippa_> tibbe: that's what happens when you launch the missiles straight up and down again. You can *try* to catch the resulting exception...
12:01:45 <vincenz> that was a hint eventualbuddha
12:01:50 <tibbe> Philippa_: touche ;)
12:01:57 <_llll_> also /away
12:01:58 <eventualbuddha> lol
12:02:03 <astrolabe> @karma+ vincenz
12:02:03 <lambdabot> vincenz's karma raised to 13.
12:02:12 <eventualbuddha> thanks vincenz
12:02:23 <eventualbuddha> @karma+ vincenz
12:02:23 <vincenz> \o/
12:02:24 <lambdabot> vincenz's karma raised to 14.
12:02:30 <Binkley> of course, the problem is that you might end up launching the missiles in the wrong order
12:02:40 <vincenz> Binkley: you have sequence_ for that
12:02:43 <Binkley> heh
12:02:58 <vincenz> unless you do something like map unsafePerformIO [listofmissiles]
12:03:03 <Philippa_> yeah, you might get hit by the other lot's retaliation before you get yours up in the air. It'd be MADness!
12:03:08 <Binkley> the real question is, when we will be able to launch missiles in the type system?
12:03:30 <cjeris> instance (TicTacToe a) => (GlobalThermonuclearWar a) where ...
12:04:48 <glguy> if the library maintainers get particularly worred about head, tail, fromJust, etc
12:04:56 <glguy> they could just rename them to: unsafeHead
12:05:00 <glguy> unsafeTail... etc
12:05:05 <vincenz> ack
12:05:14 * vincenz thikns he might have a worm crawling up the inside of his leg
12:05:29 <glguy> since in the same way that unsafePerformIO can be proven safe, so can head and tail
12:05:33 <Binkley> 0_o
12:05:42 <vincenz> well -something-!
12:05:42 <Philippa_> I don't think it's actually appropriate
12:05:54 <Philippa_> unsafePerformIO potentially bends reality, at least as far as the language's semantics're concerned
12:05:57 <vincenz> when I flex my leg downwards, I have this little bulge at the front left of my calf
12:06:01 <Philippa_> head just has the potential to yield _|_
12:06:02 <Binkley> yeah, exactly
12:06:11 <Philippa_> plus who wants to get unsafeHead?
12:06:13 <Binkley> let's also require you to use unsafeFix and disallow explicit recursion
12:06:18 <agcorona> but The whole launch missile computation can be purely functional if the missiles can return, land smootly, be refueled and put in the ramp again. Provided that all of this can be done atomically
12:06:20 <vincenz> Philippa_: yeah, giving unsafeHead is dangerous
12:06:21 <Binkley> ?remember Philippa plus who wants to get unsafeHead?
12:06:36 <Binkley> Philippa: not if you're doing it in literate Haskell
12:06:37 <Binkley> because, you know
12:06:40 <Binkley> the LaTeX makes it safe
12:06:59 * cjeris looks for a grenade
12:07:04 <liyang> *thwap*
12:07:07 <astrolabe> Philippa: I wondered how long that would take :)
12:07:27 <vincenz> @remember Binkley in response to [Philippa] plus who wants to get unsafeHead? [Binkley] Philippa: not if you're doing it in literate Haskell. because, you know, the LaTeX makes it safe
12:09:08 <psnl> Philippa_: I have been sitting on that joke for so long... its been made worse by uni doing a sexual awareness week
12:09:43 <dolio> Some people at your university weren't aware of sex?
12:10:05 <Binkley> ?remember dolio [psnl] its been made worse by uni doing a sexual awareness week [dolio] Some people at your university weren't aware of sex?
12:10:31 <psnl> dolio: heh
12:13:37 <psnl> dolio: the idea is to remind us of the risks of STIs. it means staring at these medical photos of herpes victims while on the bog.
12:13:57 <vincenz> sexualyl transmitted INJURIES???
12:13:59 <vincenz> ouch
12:14:01 <Binkley> infections
12:14:02 <Binkley> ;-)
12:14:11 <Binkley> it's supposed to get rid of the stigma associated with "STD"
12:14:17 <Binkley> by stigmatizing a different acronym instead
12:14:19 <Binkley> (I guess)
12:14:22 <psnl> Binkley: ah, right
12:14:24 <vincenz> ah ok
12:14:29 <Philippa_> I think the distinction's partly one about symptoms
12:14:31 <dolio> Hmm. That seems more like a high school activity.
12:14:31 <psnl> Binkley: its been puzzling me all week
12:14:32 <vincenz> I thought the kinkiness of this channel had just gone way up
12:14:39 <Philippa_> you can catch stuff off someone who's asymptomatic
12:14:49 <kzm_> I like the 'social' euphemism.
12:15:08 <vincenz> Philippa_: only if you allow your body to become assymptotic with his
12:15:14 <Binkley> nice typo
12:15:22 <vincenz> it's a typo?
12:15:25 <Binkley> heh.
12:15:29 <vincenz> asymptotic then
12:15:31 * vincenz coughs
12:15:57 <Binkley> ?remember vincenz [Philippa] you can catch stuff off someone who's asymptomatic [vincenz] Philippa: only if you allow your body to become assymptotic with his [Binkley] nice typo [vincenz] it's a typo?
12:16:05 <cjeris> Elderly mathematician's accident-preventing plastic undergarment: an assymptote.
12:16:10 <dylan> I really worried my friend, once.
12:16:13 <Binkley> "putting the ass back in asymptotic" should really be a motto for something
12:16:34 <vincenz> english is my 4th language
12:17:02 <dylan> I had just started dating my (first, current, and only) girlfriend, and my friend, being 10 years older, wanted to make sure I was being 'safe'.
12:17:18 <Cale> http://ask.slashdot.org/comments.pl?sid=206640&cid=16857942 -- what do you want to bet nobody mods this up? :)
12:17:19 <dylan> so he asked me, on the ride to a LUG meeting, if I knew what STDs were.
12:17:21 <lambdabot> Title: What Math Courses Should We Teach CS Students?, http://tinyurl.com/y97oo7
12:17:29 <autokratoras> is there  anyone here who is by any chance willing to help me solve 2 haskell problems?
12:17:40 <Cale> autokratoras: everyone here :)
12:17:40 <psnl> edwinb: when you become a lecturer, I dare you to have that as the subtitle to a complexity course
12:17:47 <dylan> I said "Yes, of course." "You sure?" "Yes, standards. RFCs, ISO and such."
12:17:48 <vincenz> autokratoras: sure, give us your homework and we'll email it straight to your teacher :)
12:17:53 <Cale> hehe
12:18:01 <cjeris> Compilers prof said on Monday: "Theorem: H-M type inference takes at least a factor of O(lg programlength) longer in a purely functional language, because unification requires assignment in order to be fast." I asked him for a reference, and he said that the obvious implementation (use a balanced tree for a store) gives this O(lg n) factor, but he couldn't find a reference for the lower bound.  Anybody know one, or a proof that it's false?
12:18:12 <autokratoras> well
12:18:25 <edwinb> psnl: if I ever become a lecturer and have to give a complexity course, I'll quit ;)
12:18:26 <Binkley> dylan: I probably shouldn't go into what I automatically assume LUG stands for until I think about it
12:18:26 <Philippa_> cjeris: what value of "purely functional"?
12:18:29 <Cale> cjeris: probably not in a lazy functional language
12:18:29 <autokratoras> i was hoping someone could come prive and explain some things also
12:18:30 <vincenz> autokratoras: was just kidding, but just pose your question, don't ask if you can ask :)
12:18:30 <Philippa_> does Haskell count?
12:18:32 <edwinb> (what subtitle did you mean anyway?)
12:18:36 <dylan> Binkley> Linux User Group. :P
12:18:45 <cjeris> Philippa_, Cale: he didn't say.
12:18:48 <vincenz> binkley linux user group, now drop the word linux
12:18:49 <Cale> cjeris: there are ways to make log n factors disappear in lazy languages
12:18:57 <dolio> Cale: If you wanted to get modded up, you should have just complained about how math is never used in "real world programming."
12:19:02 <psnl> edwinb: "putting the ass back in asymptotic"
12:19:08 <Cale> autokratoras: just ask the question publically, and you'll get lots of responses
12:19:09 <Binkley> dylan: I know, but there's another expansion that I always think of first
12:19:11 <edwinb> heh
12:19:20 <dylan> Binkley> Heh.
12:19:25 <vincenz> Cale: yeah, O(lg people) amount :)
12:19:50 <dylan> of course, the real punch line is, i wasn't making a joke. The first thing associated with STD is standards, secondly the other thing. :P
12:19:55 <Binkley> heh
12:20:07 <vincenz> cjeris: Tel lhim that if he's concerned about efficiency, the O-measure is a bullshit one
12:20:07 <autokratoras> ok
12:20:11 <autokratoras> i ll try
12:20:34 <cjeris> We're not going into detail about the type inference algorithm, so I'm on my own if I want to puzzle it out.  Are you saying that things like balanced trees can wind up with O(1) amortized access time in lazy languages?
12:20:39 <Philippa_> if Haskell doesn't count "because monads are a hack", Clean should do
12:20:50 <Binkley> cjeris: who's your prof?
12:20:58 <cjeris> Binkley: Greg Morrisett, Harvard
12:21:13 <vincenz> cjeris: No tree can be O(1).  Besides that, the problem is that O-measures are meaningless on modern day computers
12:21:15 <dylan> everything's a hack. the world's a hack.
12:21:42 <Cale> cjeris: http://web.comlab.ox.ac.uk/oucl/work/geraint.jones/morehaste.html
12:21:44 <lambdabot> Title: Research Highlights - More Haste Less Speed, http://tinyurl.com/y8gr3h
12:21:46 <psnl> cjeris: do you know anything about Y0 ?
12:21:46 <dylan> even clothing is a hack.
12:21:51 <therp> vincenz: how should the O-measure depend on the underlaying computer technology?
12:22:15 <autokratoras> i need to enter 2 [char] lists and then try and count how many times does the first one appear in the second one
12:22:22 <autokratoras> does that make any sense?
12:22:27 <vincenz> therp: it shouldn't, but why don't we make an A-measure that measures how many letters the program has to find out its complexity
12:22:29 <cjeris> Cale: hmm, that might be exactly what he was referring to.  i'll take a look.  tahnks!
12:22:33 <cjeris> s/ah/ha/
12:22:39 <vincenz> therp: My point is that the o-measure is meaningless
12:22:52 <psnl> autokratoras: yes
12:22:57 <Cale> autokratoras: sure. Have a look at isPrefixOf, tails, filter, and length :)
12:23:07 <Binkley> cjeris: well, I wouldn't have thought that Greg would say anything that blatantly false, so maybe it's not false. seems false to me though :-)
12:23:19 <Cale> autokratoras: those are functions which you can put together into a solution for your problem
12:23:29 <cjeris> psnl: no... I'm a staff member taking classes on the side, I haven't talked with him about any of his research.
12:23:34 <Cale> autokratoras: is it a homework assignment?
12:23:53 <Cale> autokratoras: I helped someone else with the exact same problem just the other day
12:24:07 <eventualbuddha> vincenz: fyi, it worked on my more complicated test
12:24:13 <eventualbuddha> 23 items
12:24:14 <vincenz> eventualbuddha: of course ;)
12:24:22 <autokratoras> its a for tomorrow
12:24:22 <vincenz> eventualbuddha: it'll lwork on a test of 10000 items too
12:24:30 <autokratoras> *homework
12:24:30 <vincenz> autokratoras: So you should have started earlier
12:24:36 <autokratoras> yeah :P
12:24:45 <vincenz> This channel is not an excuse for lazyness
12:24:46 <vovik> is there a way to make a where clause apply to more than one preceding line?
12:24:50 <vincenz> as much as we preach lazy languages
12:24:53 <psnl> autokratoras: has the prof rambled on lots about lists being an element and the rest of the list?
12:24:57 <dylan> I wonder if I could come up with a solution with a runtime longer than a week.
12:24:58 <tibbe> oh, lecture time!
12:24:59 <therp> vincenz: well, you didn't answer why you think so. As far as I understand O(..) it is a purely abstract measure, not concerned with something that exists outside the mind
12:25:06 <Cale> vovik: where clauses scope over guards, if that helps
12:25:16 <cjeris> Binkley: Greg didn't say whether he was talking about eager or lazy or both, and the paper Cale just referred me to is specifically about impure-eager vs pure-eager.
12:25:30 <autokratoras> psnl i lost u there
12:25:34 <vincenz> therp: Yeah, but it is completely meaningless.  It makes so many assumptions that are not true nowadays that you wonder what the hell it is good for
12:25:34 <vovik> cale: ya i know, but i want it to scope over a few lines that aren't guard
12:25:35 <Cale> cjeris: no
12:25:46 <Cale> cjeris: It's pure-lazy vs. pure-eager
12:25:46 <Binkley> cjeris: even so, you can do the same thing in the IO monad
12:25:50 <Binkley> unless that's considered "a hack"
12:25:51 <vincenz> therp: Hence my comment about an A-measure, another compleltely meaningless measure
12:26:07 <Philippa_> or in ST
12:26:13 <Cale> vovik: you can of course, lift it up to the top level
12:26:29 <vovik> cale: lift it from the top level?
12:26:32 <Philippa_> and I'm fairly sure that (albeit without the same efficiency) ST can now be implemented in System FC without any additional outside support
12:26:42 <Cale> vovik: i.e. not have it inside a where
12:26:48 <psnl> autokratoras: in haskell, a list is etheir the empty list [], or an element and the rest of the list (x:xs)
12:26:52 <cjeris> Cale: sorry -- the other one you just referred me to :D  the one behind the link on the word "showed" on that page.
12:27:06 <Cale> cjeris: ah
12:27:07 <therp> vincenz: I haven't thought of it in relation to a lazy language, but for sure its valid for most imperative languages. unless you argue imperative languages are meaningless and obsolete (you might earn agreement here :))
12:27:18 <vincenz> therp: Erm, I'm not arguing languags here
12:27:27 <autokratoras> yes true
12:27:42 <autokratoras> but how do i check for char elementes 3 of them?
12:27:50 <therp> vincenz: what assumptions do you have in mind that might not hold?
12:27:57 <vincenz> therp: I'm arguing that originally it was thought as a measure of complexity to know how long something might take.  But given that nowadays accesses to on and off chip memory can take orders in magnitude difference.  The measure is completely pointless and arbitrary
12:28:11 <Cale> autokratoras: First, you want a way to check if one string is a prefix of another
12:28:23 <Cale> autokratoras: so what must be true?
12:28:29 <Cale> [] is a prefix of any string
12:28:40 <Cale> (x:xs) is not a prefix of []
12:29:07 <Cale> (x:xs) is a prefix of (y:ys) if x is equal to y, and xs is a prefix of ys
12:29:21 <Binkley> why do I suspect that autokratoras and christine go to the same school?
12:29:26 <cjeris> Binkley: Actually that's something I wondered about.  I wrote a code generator in a monadic style in SML a few weeks ago.  How do you learn to see, in general, where a lazily evaluated program has a speed-up over the same program eagerly evaluated?
12:29:32 <autokratoras> possible
12:29:41 <autokratoras> christine sounds like a greek name
12:29:45 <vovik> cale: ok i  just tried that, but is there  a way to avoid using semicolons ?
12:30:04 <Cale> vovik: semicolons are never needed in Haskell code
12:30:17 <autokratoras> is there by any chance anyone greek in here?
