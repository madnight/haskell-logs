00:00:14 <Botty> looks like they badly combined or edited a sentence a bit too much.
00:01:26 <xnito> let plusOne = proc a -> returnA -< (a+1) in plusOne 3
00:01:45 <xnito> >let plusOne = proc a -> returnA -< (a+1) in plusOne 3
00:02:30 <dons> leading space after the > !
00:02:39 <dons> > "good"
00:02:40 <lambdabot>  "good"
00:02:45 <dons> >"ignored" :)
00:03:02 <xnito> > let plusOne = proc a -> returnA -< (a+1) in plusOne 3
00:03:03 <lambdabot>  Parse error
00:03:09 <dons> -< ?
00:03:10 <xnito> :(
00:03:15 <xerox> Arrow sugar.
00:03:18 <dons> ah yes.
00:03:25 <dons> i could expose those. hmm..
00:03:27 <dons> good idea!
00:03:36 <xerox> dons, did you see my #tell about HList?
00:03:51 <dons> oh, they are expose (arrows), just not the extra syntax
00:04:01 <dons> yeah, same issue. don't want to expose a huge lib i don't understand :)
00:04:12 <dons> holes, holes, trusted computing base, blah blah, proof, blah ..
00:05:36 <xerox> yeah.
00:06:09 * xerox writes HList out on post-its and covers dons' place with them
00:11:38 <astrolabe> @where paste
00:11:38 <lambdabot> http://paste.lisp.org/new/haskell
00:12:16 <lisppaste2> astrolabe pasted "matrix code" at http://paste.lisp.org/display/29780
00:12:27 <int-e> btw, puzzle solution (DeBruijn module bugs) http://paste.lisp.org/display/29779 (I already sent a patch to lennart)
00:12:32 <astrolabe> How can I make this kind of code faster?
00:12:44 <xnito> does lisp have any major advantages over haskell?
00:13:49 <astrolabe> I believe lispers go on about macros.  I couldn't say how much of an advantage they are.
00:14:07 <astrolabe> I suspect there are better debuggers for lisp
00:14:25 <int-e> astrolabe: don't use pairs as indices (I don't know if this has improved but the last time I used them their performance was abysmal), use unboxed arrays, work in the ST monad to create them. In my attempt that resulted in very ugly code though.
00:15:14 <Botty> lisp programs are basically the same as the main data type, allowing easy program modification/mutation/generation
00:15:43 <astrolabe> int-e: thanks a lot!
00:16:24 <dons> use unsafeRead/unsafeWrite into unboxed arrays
00:16:28 <dons> and crank up -o
00:16:29 <dons> -O
00:16:36 <xerox> Hiya astrolabe!
00:17:12 <astrolabe> dons: thanks!  I was hoping you'd see :)
00:17:23 <Elifant> are questions about parsec ok here, or is it separate channel for them anywere?
00:17:23 <astrolabe> xerox: Wotcha
00:17:39 <xerox> I was writing a Matrix module some days ago, but I was trying to get the type system to enforce things like sum only for square matrices, embedding the dimensions in the type.
00:17:47 <dons> astrolabe: here's some more info, http://www.cse.unsw.edu.au/~dons/tmp/spj.txt
00:17:58 <dons> Elifant: parsec is very welcome here
00:18:09 <astrolabe> dons thanks
00:18:26 <Elifant> I use Parsec.Expr to parse expressions, but I need "assign" operation. How can I force it's left side to be variable name only, not expression?
00:20:11 <xerox> It was not a very successful attempt, but I don't remember why.
00:21:15 <astrolabe> xerox: more ambitious than my code
00:21:57 <xerox> astrolabe: I was trying to understand some liner algebra ... :)
00:21:59 <xnito> I get an error Syntax error in input (unexpected `->') for let plusOne = proc a -> returnA -< (a+1) in plusOne 3
00:22:00 <xnito>  
00:22:14 * Botty wonders why sum would only apply to square mats
00:22:51 <dons> is it proc a = ?
00:22:51 <xerox> xnito: use ghc(i) -farrows
00:22:55 <dons> ah yes
00:23:08 <Botty> i suppose sum is a bit different than (+)... its a fold of (+)
00:23:36 <xerox> Botty: errr! same-dimensional matrices.
00:23:36 <mwc> still, you should be able to sum equal rectangular matrices
00:23:48 <xerox> Botty: the square constraint was needed for the inverse.
00:23:56 <Botty> ok, there you go
00:23:58 <xerox> See! I still lack... grumble.
00:24:04 <Botty> even then, inverse can fail
00:24:07 <astrolabe> lack?
00:24:10 <Botty> but its much less likely
00:24:13 <xerox> ...understanding!
00:24:40 <Botty> (if you got the type system to handle the squareness)
00:24:41 <astrolabe> You must have understood it if you wrote the code.  I suspect that was carelessness.
00:25:19 <mwc> =Why do you need inversion to find the sum?
00:25:34 <xerox> astrolabe: no implementations of the functions yet :(
00:26:09 <Botty> maybe he meant quotient ;P
00:26:38 <mwc> Why do you need quotient to find the sum? The vector-space gods are getting angry!
00:27:10 <Botty> lol
00:27:11 <astrolabe> tell them to get conjugated
00:27:13 <xerox> I think there is some misunderstanding going on...
00:27:21 * LOkadin comes down from the heavens and devectorizes things
00:27:36 <LOkadin> .o'onaisai
00:27:47 <Botty> you mean scalarize?
00:27:54 <xerox> astrolabe: how do you create your matrices?
00:28:18 <xerox> .oO( Mat . fromList ? )
00:28:33 <astrolabe> xerox: mostly yeah
00:41:54 <pzpz> any method exist for quickCheck to bail after running a specific test case for more than an alotted time?
00:43:51 <dons> I think it has a 10 sec timeout
00:44:02 <dons> but that is tunabe with the config options
00:44:06 <dons> tunable.
00:45:35 <pzpz> i'll peek at the code
00:45:45 <pzpz> didn't find anything in the manual
00:46:37 <dons> in Test.QuickCheck.Batch,
00:46:38 <dons>          watcher <- forkIO (Exception.catch
00:46:39 <dons>                   (do threadDelay (len * 1000 * 1000)
00:46:59 <dons> ?docs Test.QuickCheck.Batch
00:47:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck-Batch.html
00:52:20 <guerra> in gtk2hs can i use a textview passing it as parameter for a function so it can write there?
00:53:15 * xerox growls at banks
01:01:29 <robreim> guerra: I haven't used textview but given it's an ordinary widget I don't see why it can't be passed around to functions. I expect likewise with the textbuffer model it uses.
01:01:55 <guerra> robreim: what about a simple label?
01:02:57 <robreim> Widgets are just data. You should be able to just pass them around.
01:03:45 <guerra> robreim: cool thanks
01:04:00 <robreim> no problem. bbl
01:08:15 <pzpz> ah, QuickCheck.batch terminates when it finds an incompatible set of parameters :(
01:09:48 <dons> you can write custom check functions, feel free to adapt the forkIO timeout from .Batch to your own mycheck
01:16:35 <xnito> does anyone know how i can add type checking to this http://rafb.net/paste/results/RN2J1x80.html ?
01:17:40 <dons> add type checking?
01:17:55 <dblhelix> xnito: add a type signature, you mean?
01:18:12 <dons> like;
01:18:12 <dons> myrank :: Integer
01:18:12 <dons> myrank = rank (4,'h')
01:18:14 <dons> ?
01:18:16 <dblhelix> myrank :: [Integer]
01:18:23 <dblhelix> eh.. .Integer, I mean
01:18:24 <dons> no ;)
01:18:35 <dblhelix> :)
01:18:41 <dons> xnito: you wanted the type inferred?
01:18:45 <xnito> so that i have to say at least " :: Card " to use the function rank
01:18:46 * dblhelix needs more coffee, obviously
01:18:53 <xnito> i want the opposite
01:18:53 <dons> ah ok
01:19:28 <dons> how about defining a new type:
01:19:29 <dons> newtype Card = Card (Integer,Char)
01:19:29 <dons> rank :: Card -> Integer
01:19:29 <dons> rank (Card card) = fst card
01:19:29 <dons> myrank :: Integer
01:19:32 <dons> myrank = rank $ Card (4,'h')
01:19:45 <dons> so you can't slip a tuple in there, without explicitly creating a Card
01:20:10 <dons> (what are you trying to do -- its not clear yet/)
01:21:39 <xnito> So do I have to use a constructor?
01:22:15 <dons> what is your goal here? what constraints do you want?
01:22:52 <xnito> I want the function rank to only work on the type card
01:23:07 <dons> but its a constant.
01:23:12 <dons> ah sorry.
01:23:14 <dons> yes, it already does.
01:23:21 <dons> rank :: Card -> Integer
01:23:22 <dons> rank (Card card) = fst card
01:23:28 <dons> you can only pass it something of type Card
01:24:04 <xnito> do i have to use a constructor to enforce that?
01:24:11 <xnito> not being inferred
01:24:30 <dons> well, you could keep the type synonym, in which case things of type (Integer,Char) would work
01:24:43 <dons> and avoid the constructor
01:25:37 <dons> but your original example, with the type annotatoin, was enough, rank :: Card -> Integer
01:26:02 <dons> that will allow only types synonymous with (Integer,Char) to pass to rank
01:26:31 <xnito> yes but thats still not strongly enough typed
01:27:22 <dons> ok, so you need to create a distinct, new type. as shown. and then you need the constructor Card to build values of type Card
01:27:36 <dons> the compiler will prevent statically anything else being passed to rank
01:27:44 <xnito> ok
01:27:52 <dons> so you want to distinguish statically (Integer,Char) values from Card values?
01:27:59 <xnito> yup
01:28:05 <dons> ok. so you use data or newtype then
01:28:23 <xnito> i know, ive been warped by the idea of data hiding
01:28:37 <dons> i.e.
01:28:41 <dons> data Card = Card Integer Char
01:28:41 <dons> rank :: Card -> Integer
01:28:41 <dons> rank (Card n _) = n
01:28:41 <dons> myrank = rank (Card 4 'h')
01:29:04 <dons> yeah, you can hide more things if you move Card into another module, hide its constructor, and then export only a custom constructor you write
01:29:11 <xnito> constructor mean more typing :(
01:29:14 <dons> or *even* wrap the values in an existential type
01:29:27 <dons> so only operations in the Card class would be allowed on Card values
01:29:46 <dons> it all depends what kind of errors   you want to prevent statically
01:31:02 <xnito> are there namespaces in haskell
01:32:23 <dons> you can control the value and type namespace with modules, so yes.
01:32:56 <dons> and e.g. there are separate namespaces for types and values
01:33:30 <dons> hence data Card = Card Int works, defining a type 'Card', and a constructor functoin 'Card'
01:33:31 <robreim> dons: can you suggest somewhere that explains existential types?
01:33:46 <dons> i think the new wikibook has a good explanatoin, as does the ghc user's guide.
01:33:48 <dons> let me see...
01:34:03 <robreim> oh, and while I'm here, any word on hsplugins?
01:34:19 <dons> this week. priority++
01:34:29 <robreim> cool :)
01:35:03 <dcoutts> mwc, heh, there'll be more of that when I start using the new code generator
01:35:20 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
01:35:23 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
01:35:36 <dons> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
01:35:38 <lambdabot> http://tinyurl.com/f9umb
01:35:45 <dons> morning dcoutts
01:35:50 <dcoutts> hia
01:36:11 <robreim> great, thanks
01:36:36 <dons> ?where+ wikibook http://en.wikibooks.org/wiki/Haskell
01:36:37 <lambdabot> Done.
01:36:37 <robreim> hi dcoutts. How's the gtk2hs release going?
01:37:06 <dcoutts> robreim, ok so far, we're looking at a few weeks I think.
01:37:12 <xnito> when working with modules, do I have to use seperate files and import them
01:37:23 <xnito> or is there an infile notation
01:37:31 <xnito> similar to name spaces
01:37:43 <robreim> dcoutts: anything you need extra hands for?
01:38:00 <dons> xnito: if you want to hide things in separate modules, they need separate files, yep
01:38:01 <dcoutts> robreim, mm, I sure I can find something :-)
01:38:33 <dons> dcoutts: did you get the HaC07 mail?
01:38:37 <dcoutts> dons, yep
01:38:40 * dons wonders if he set up the mailing list correctly.
01:38:41 <dons> ah good
01:39:25 <robreim> dcoutts: ok. Just message me if you come up with something then :)
01:39:42 <xnito> grr
01:40:10 <dons> xnito: what things in the namespace are you trying to control?
01:40:21 <xnito> functions
01:40:42 <dons> note you can also define functoins locally with where or let, and they'll have lexical scope
01:40:53 <xnito> yea yea
01:40:55 <xnito> i know
01:41:03 <dons> ok. just trying to help :)
01:41:20 <xnito> but I know you always run out of room on the page due to indenting
01:41:37 <dcoutts> robreim, how much do you want? :-)  One nice mini-project would be to update the cairo bindings to the latest version of cairo.
01:41:49 <dons> oh? usually the code shouldn't be very deeply nested..
01:41:53 <dons> do you have an example?
01:41:55 <dons> ?paste
01:41:55 <lambdabot> http://paste.lisp.org/new/haskell
01:42:02 <dcoutts> robreim, there's some pretty useful new stuff like properly working ps, pdf, svg backends.
01:43:02 <robreim> dcoutts: I could probably look at something like that. I haven't done much FFI stuff in haskell yet so that seems like a pretty straightforward way to get used to it.
01:43:41 <dcoutts> robreim, the cairo binding is a very nice example of a FFI binding. It's well done (thanks to xerox).
01:43:51 <dcoutts> robreim, so a good place to learn
01:45:08 <robreim> ok, great. I'll grab the latest sources and have a look.
01:46:01 <robreim> also; I don't suppose you know of any way to "scale" widgets do you? I'm toying at making a gtk version of fruit and couldn't figure out how to translate that feature from fruit to gtk...
01:48:25 <dcoutts> robreim, gtk widgets automagically scale if you give them more space
01:48:42 <dcoutts> robreim, there are a couple packing parameters to control that behaviour
01:48:51 <dcoutts> see the Box widget
01:49:11 <robreim> I suppose I could try it that way... ok, thanks.
01:49:21 <Botty> gtk has ps, pdf, and svg backends?
01:49:58 <Botty> oh, cairo
01:50:17 <Botty> I've actually used the pdf, svg and png (well imagesurface) backends of cairo
01:50:30 <dcoutts> Botty, aye, how did you find it?
01:50:43 <dcoutts> robreim, otherwise you can manually set the size of widgets.
01:51:30 <Botty> the backends? very nice.  Allowed adding some nice features that would take quite alot of effort to otherwise implement
01:51:33 <dcoutts> robreim, though to be honnest I think the layout problem is a solved one. The unsolved ones are how to manage state and dynamic behaviour in GUIs.
01:51:54 <dcoutts> Botty, like printing
01:52:00 <Botty> yep
01:52:39 <robreim> *nods* I hear that
01:53:17 * dcoutts has to go
01:53:40 <roconnor> Damn policits.
01:53:54 <roconnor> Damn politics
01:54:14 <roconnor> Reaching consensus on names of standard library functions is difficult.
01:55:33 <xnito> what is the difference between type and newtype?
01:55:55 <robreim> Heh. I'm impressed and a bit amused by how much discussion on the libraries list is devoted to naming functions
01:56:01 <LOkadin> .o'onaisai sa .o'onaisaizo'o
01:56:01 <roconnor> newtype creates a ``branded'' type
01:56:27 <xnito> as apposed to ?
01:56:36 <robreim> coi lokadin. wrong channel
01:56:42 <roconnor> the newtype cannot be substituted for the original type, and it loses all its type classes.
01:57:04 <LOkadin> roconnor: right channel .ui it was in reference to last little outburst I had .u'isai
01:57:34 <robreim> xnito: newtype is more like a data declaration only more optimised
01:57:37 <therp> xnito: newtype creates a new type in the type system. you can add different  and conflicting instance declarations for let's say Integer. with type you only get a synonym, the latter is like search/replace, no semantic difference
01:57:55 <roconnor> robreim: I suppose it is important to build consenus.  But what we need to do (and are doing) is move to a system where concensus isn't needed for names.
01:57:55 <LOkadin> bah I have to wake up soon
01:58:06 <LOkadin> mibaziSIPna.ico'o
01:58:31 <therp> type your passwords elsewhere :)
01:58:32 <roconnor> Instead we can have several different choices of packages.
01:58:54 <LOkadin> lol it means i'm going to be a sleeper shortly and goodbye
01:59:05 <LOkadin> .ui.u'i
01:59:12 <therp> in what kind of language?
01:59:13 <LOkadin> happily amused
01:59:17 <LOkadin> LOJban
01:59:29 <LOkadin> .ui.u'i= happily amuzed
01:59:48 <LOkadin> eventually I want to translate it into Haskell
01:59:59 <LOkadin> now I'm working on translating to Prolog however
02:00:10 <LOkadin> anyways co'o
02:00:12 <therp> ah cool
02:00:22 <robreim> roconnor: http://programming.reddit.com/info/o9np/comments <-- I made some suggestions about formal consensus. That problem could be solved by formalising some community goals.
02:00:26 <lambdabot> Title: Consensus for Free Software Projects (reddit.com), http://tinyurl.com/y6rmqu
02:00:35 <therp> just hit the wikipedia page about that. I recently read about the sapir-whorf hypothesis, but I forgot where...and why.. hmm
02:00:48 <LOkadin> hmmm
02:01:05 <robreim> ie if the function name proposed can't be adequately shown to conflict with the community's goals, discussion is unwarranted
02:01:49 <LOkadin> .ua
02:02:08 <LOkadin> .ua.uesai if that's what I think you mean, that's amazing
02:02:57 <therp> ah! yes I remember, it was in the o'reily mind performance hacks book
02:03:07 <therp> the author talks about some speedtyping language.
02:03:32 <robreim> Heh. When I first heard of the sapir-whorf hypothesis someone else mentioned it to me again within an hour in a completely unrelated setting. It was pretty surreal..
02:04:06 <LOkadin> LOJban? well no it's actually an conlang based on predicate logic, that aims to be unambiguous
02:04:44 <therp> maybe LOJban names would be appropriate for function names..
02:05:06 <robreim> Geez, I can't believe how many lojbanists seem to come to #haskell... what's the relation?
02:05:07 <LOkadin> robreim: .ua(discovery) that's amazing for such a thing to happen.
02:05:24 <LOkadin> it's the BANli man
02:05:26 <LOkadin> it's the future
02:05:48 <LOkadin> all the super l337 people do Haskell and Lojban
02:06:03 <LOkadin> well not l337
02:06:11 <wolverian> lojban takes all the pai^Wfun out of learning a language!
02:06:12 <LOkadin> BANli people
02:06:16 <roconnor> can we use Lojban to document our haskell code?
02:06:33 <wolverian> LOkadin, what's the relationship with prolog? I didn't know lojban is so formal.
02:06:58 <LOkadin> it's based on predicate logic
02:07:14 <robreim> heheh. If good natural language generators can be written, lojban would be an excellent documentation language since it's readily parsable by computers. It'd be easy to translate documentation to any language with a supported generator
02:07:30 <LOkadin> it has SUMti which are arguments, and SELbri which are functions, and you can have nested things just like with prolog
02:07:50 <LOkadin> robreim: certainly
02:08:12 <LOkadin> say for instance the word FANva
02:08:22 <robreim> wolverian: it's built on the idea of relations rather than nouns and verbs so it resembles prolog in that sense
02:08:23 <therp> robreim: that's nice idea :)
02:08:41 <therp> +a
02:08:56 <LOkadin> has 5 SUMti placements, so the prolog implementation could be fanva(_,_,_,_,_) to demonstrate this fact
02:09:16 <robreim> If I ever stumble accross a decent natural language generator I'll probably convert to writing everything in lojban :P
02:09:43 <therp> babelfish here we come!
02:10:10 <LOkadin> and a lojban statement like FANvazoVALsifuzoi.gy.word.gy. would translate as fanva(_,zo('valsi),_,_,zoi(gy,word))
02:10:13 <robreim> I imagine generating natural language is a much easier task than parsing it anyway...
02:10:38 <LOkadin> parsing is very easy
02:10:43 <LOkadin> i made a parser in haskell
02:10:48 <LOkadin> syntactically unambiguous
02:11:07 <robreim> LOkadin: parsing natural languages is certainly not easy :P
02:11:15 <LOkadin>  FANvazoVALsifuzoi.gy.word.gy. can be written as fanva so valsi zoi .gy. word .gy.
02:11:22 <LOkadin> s/so/zo
02:11:37 <LOkadin> robreim: .ie(agreement)
02:11:55 <LOkadin> that's why LOJban is so good.
02:12:37 <LOkadin> once we have a programming language in LOJban we can have an interperter, of the LOJban language, so your computer could talk to you in the same language you are talking to it.
02:12:39 <roconnor> why is repeatM next to useless?
02:13:33 <LOkadin> repeatM as in repeat monad?
02:13:49 <LOkadin> @hoogle repeatM
02:13:50 <lambdabot> No matches found
02:14:07 <LOkadin> @google repeatM
02:14:09 <lambdabot> http://www.haskell.org/pipermail/libraries/2002-August/000649.html
02:14:09 <lambdabot> Title: Adding repeatM / repeatM_ to Control.Monad
02:14:14 <roconnor> repeatM = sequence . repeat
02:14:37 <robreim> roconnor: probably because, unless each step is performed lazily, the list it outputs will be infinite and never returned
02:14:40 <dolio> Well, depends, I guess. Essentially you're trying to ask for the result of an infinite number of computations.
02:14:53 <dolio> Certainly doesnt' work in IO.
02:15:22 <roconnor> there are other monads other than the IO monad.
02:15:30 <LOkadin> micaDJUnoledoNABmi
02:15:46 <dolio> [] doesn't work either. Stack overflow.
02:15:54 <LOkadin> peVALsiLISte
02:16:27 <dolio> sequence is strict, I think.
02:16:29 <roconnor> Is Lokadin doing a live translation, or just talking to themself
02:17:12 <roconnor> dolio: that strikes me as unlikely...
02:17:29 <dolio> sequence (m:ms) = do { x <- m ; xs <- sequence ms ; return (x:xs) }
02:17:33 <LOkadin> i was replying but in lojban, i said, i now know your problem with "word lists" refering to vocabulary, or "standard function names"
02:17:52 <LOkadin> as in i recognie
02:17:54 <LOkadin> ze
02:17:59 <LOkadin> what you were talking about earlier
02:19:05 <LOkadin> robreim: i believe you pasted the link with Consensus for Free Software Projects
02:19:08 <robreim> LOkadin: most people in here don't understand lojban. Until it's more widely used, it'd probably just irritate people to keep speaking in it.
02:19:21 <LOkadin> kk
02:19:30 <LOkadin> i understand
02:19:41 <robreim> yeah, I pasted it
02:19:43 <roconnor> isn't there a haskell lojban channel?
02:19:58 <robreim> haha, maybe one should be started :)
02:19:59 <roconnor> what is the ISO two (or three) letter name for the language?
02:20:43 <roconnor> there are sweedish and spanish haskell channels right?
02:20:44 <guerra> dcoutts man, gtk2hs is so so so much easier to deal than wxhaskell ^^ many thanks for helping yesterday, things are flowing now :D
02:20:54 <robreim> roconnor: and japanese
02:21:17 <roconnor> A lojban channel wouldn't be unreasonable.
02:21:33 <LOkadin> there are many people mutual to both channels
02:21:52 <dolio> ?let r = fix ([1]:)
02:21:53 <lambdabot> Defined.
02:21:57 <dolio> > take 5 L.r
02:21:59 <lambdabot>  [[1],[1],[1],[1],[1]]
02:22:09 <dolio> > take 5 (sequence L.r)
02:22:11 <lambdabot>  Exception: stack overflow
02:22:22 <roconnor> hmmm
02:23:04 <roconnor> dolio: I bet it works for the reader monad.
02:23:10 <robreim> hmm.. apparently the iso639 identifier for lojban is jbo (no 2 letter one)
02:23:23 <roconnor> so, #haskell.jbo
02:23:44 <robreim> Yeah. Join #haskell.jbo if you want to talk haskell in Lojban (geez, how specialised is that?!)
02:24:26 <LOkadin> .ui
02:24:29 <LOkadin> oops
02:24:42 <robreim> ?join #haskell.jbo
02:24:43 <lambdabot> Not enough privileges
02:24:45 * roconnor doesn't speak Lojban
02:24:49 <robreim> oh well
02:25:38 <dolio> Ah, so it does.
02:26:18 <roconnor> dolio: yay, not completely useless!
02:26:31 <dons> roconnor: heh
02:26:33 <LOkadin> not to worry, no one really knows how to speak lojban
02:26:36 <LOkadin> .u'i
02:26:38 <roconnor> I'm supripsed it doesn't work with the list monad.  You got me there.
02:26:40 <LOkadin> (amusement)
02:26:44 <dons> ?join #haskell.jbo
02:26:48 <dons> ?users #haskell.jbo
02:26:49 <lambdabot> Maximum users seen in #haskell.jbo: 1, currently: 0 (0.0%), active: 0 (NaN%)
02:27:13 <roconnor> lambdabot is by herself?
02:27:20 <dons> ?users #haskell.jbo
02:27:20 <lambdabot> Maximum users seen in #haskell.jbo: 1, currently: 0 (0.0%), active: 0 (NaN%)
02:27:32 <dolio> I don't know. How useful is it to get the result of an infinite number of reader computations? I'm trying to decide.
02:27:49 <roconnor> dolio: not really infinite, arbitrarily hight.
02:28:00 <roconnor> as many as you need
02:28:04 <tgies> hey roconnor :D
02:28:09 <tgies> fancy seeing you here.
02:28:16 <psnl> morning
02:29:57 <dolio> Yes, well, I am aware of that. Infinite lists are also not infinite in practice, either, but it's shorter to say than "as many as you need."
02:30:07 <roconnor> tgies: hey. ... I'm still hoping for a new codex to be published.
02:30:14 <tgies> :D
02:30:16 <roconnor> dolio: :)
02:30:55 <roconnor> dolio: it strikes me as plausabily useful. ... although I'm not exactly advocating adding it to the standard library
02:31:07 <roconnor> It is the only thing that would ever take the name repeatM.
02:31:40 <dolio> State(T) is probably a better use case, assuming it works there.
02:33:02 <roconnor> dolio: yeah ... I'm not so sure it will work.
02:33:44 <dolio> Seems to work equally well.
02:34:48 <dolio> That will actually thread the state and get you interesting results.
02:35:05 <dolio> ?let repeatM m = sequence (repeat m)
02:35:06 <lambdabot> Defined.
02:35:19 <dolio> > runState (do { x <- L.repeatM (modify (+1) >> get) ; return x }) 1
02:35:21 <lambdabot>  ([2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
02:35:41 <dons> ok so repeatM may be useful :)
02:35:42 <roconnor> dolio: but there is no err final state ...
02:35:43 <dons> good.
02:35:44 <roconnor> wow
02:36:21 <dons> ?users
02:36:21 <lambdabot> Maximum users seen in #haskell: 265, currently: 245 (92.5%), active: 32 (13.1%)
02:36:46 <dolio> As opposed to reader, where "runReader (repeatM ...)" is the same as "repeat (runReader ...)"
02:37:32 <dolio> > snd $ runState (do { x <- L.repeatM (modify (+1) >> get) ; return x }) 1
02:37:36 <lambdabot> Terminated
02:37:41 <dolio> :)
02:38:42 <tgies> Noob question: how would I get a list of lists of natural numbers which add up to n? I know I could do this in, like, one list comprehension...
02:40:10 <therp> [(n,m) | n <- [0..x], m <- [0..x], n+m == x] assuming x to be the target number.
02:40:15 <tgies> such that for 4 the list would be [[4], [3, 1], [2, 1, 1], [1, 1, 1, 1]]
02:40:17 <therp> quite inefficient though
02:40:24 <robreim> dons: any idea why lambdabot won't join #haskell.jbo?
02:40:30 <therp> oh, I assumed only two numbers...
02:40:39 <tgies> yeah :/ that's where my problem is
02:40:51 <dons> hmm
02:40:54 <tgies> I worked out how to do it with pairs, but that's not quite what I'd like to do
02:40:55 <dolio> That'll require recursion.
02:41:02 <tgies> figured
02:41:24 <dons> ?join #haskell.jbo
02:41:46 <dons> not sure why it won't join. very strange
02:42:26 <LOkadin> dons: hmmm you were there shortly
02:42:49 <dons> yeah. but why lambdabot won't join i don't know
02:43:07 <LOkadin> hmmm, maybe it's the '.'?
02:43:24 <dons> oh, maybe it's on a server that doesn't know about the new channel yet?
02:43:37 <LOkadin> .ie.io could be
02:43:38 <dons> i'll look into it later
02:43:48 <tgies> doubt that; services sync is basically immediate
02:43:58 <dons> very strange
02:44:08 <tgies> I had the same idea as LOkadin myself
02:44:12 <dons> ?join #haskell-testing
02:44:28 <dons> oh, it doesn't seem to be joining any new channels
02:44:33 <dons> ?bot
02:44:34 <lambdabot> :)
02:44:46 <dons> i wonder if there's a limit on the number of simulataneous chans?
02:44:52 <dons> ?seen lambdabot
02:44:53 <lambdabot> Yes, I'm here. I'm in #oasis, #ScannedInAvian, #perl6, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell_ru, #haskell.se, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.
02:44:53 <lambdabot> fi, #haskell.es, #haskell.de, #haskell-overflow, #haskell-blah and #haskell
02:45:09 <dolio> > let f 0 = [[]] ; f n = [ x:xs | x <- [1..n], xs <- f (n-x) ] in f 4
02:45:11 <lambdabot>  [[1,1,1,1],[1,1,2],[1,2,1],[1,3],[2,1,1],[2,2],[3,1],[4]]
02:45:13 <roconnor> dolio: I'm going to follow up that thread with your observations about the potential usefulness of repeatM
02:45:22 <dolio> That has duplicates if order doesn't matter.
02:45:24 <Pupeno> dons: there's on freenode.
02:45:29 <LOkadin> co'o.imibaziSIPna i'm going to sleep bye
02:45:29 <dons> ther eis?
02:45:40 <dons> roconnor: you mean to the libraries@ thread?
02:45:47 <Pupeno> dons: look at lisppaste, there are various clones of it because it can't join so many channels.
02:45:48 <roconnor> yes
02:45:50 <dons> roconnor: if so, please do. a good use for repeatM would be welcome
02:45:59 <dons> i'd movtivate me to resubmit a patch for repeatM*
02:46:05 <dons> Pupeno: ah!
02:46:08 <dons> that's probably it then
02:46:28 <Pupeno> dons: /whois lisppaste, /whois lisppaste2, /whois lisppaste3.... I think I've seen lisppaste4 somewhere.
02:46:28 <roconnor> dons: dolio's  runState (do { x <- L.repeatM (modify (+1) >> get) ; return x }) 1 isn't exactly useful, but I think it shows potential
02:46:34 <tgies> dolio: I need to not have duplicates, but I'm sure I can work out how to get rid of those myself. Thanks!
02:46:38 <dons> roconnor: yep
02:46:50 <dolio> tgies: Yeah, shouldn't be too hard, I think.
02:47:30 <Pupeno> Does haskell.org ofer darcs repos to Haskell projects ?
02:47:49 <tgies> I guess I basically just need to sort all the lists and then remove duplicates, right, Dolio? I can manage that
02:48:10 <dolio> Well, there is a better way to do it than that.
02:48:22 <tgies> not surprised
02:48:30 <dons> Pupeno: yep.
02:48:41 <dons> or you can use sourceforge et al
02:49:10 <dolio> The better way is somewhat more complicated, actually.
02:49:26 <tgies> again, not surprised
02:49:37 <tgies> I imagine I can somehow forego the sorting step, no?
02:49:44 <dolio> You want to separate both the number you're trying to add to, and the maximum number you can use.
02:49:51 <tgies> of course there's probably a way to just not generate the duplicates in the first place
02:50:10 <tgies> yeah that's actually the way I first tried to solve this problem
02:50:24 <tgies> but I couldn't quite figure the whole thing out
02:50:36 <tgies> I've been learning Haskell 98 for... half an hour, now
02:50:41 <tgies> :D
02:53:14 <Pupeno> dons: but sourceforge doesn't offer darcs.
02:53:21 <dons> right :/
02:53:26 <dons> does berlios or one of the others?
02:53:41 <dons> i think one of them out there does
02:56:03 <guerra> if i create an event in glade (like opening a dialog when clicking in a menu toolbar option) how do i activate it in my program?
02:56:29 <Pupeno> Where should I go to have a project hosted at haskell.org ?
02:56:34 <Pupeno> I mean, the darcs repo.
02:57:20 <dolio> > let g n k | n < 0 = [] | n == 0 = [[]] | otherwise = [ x:xs | x <- [1..k], xs <- g (n-x) x ] ; f n = g n n in f 4
02:57:23 <lambdabot>  [[1,1,1,1],[2,1,1],[2,2],[3,1],[4]]
02:57:26 <dolio> There we are.
02:57:38 <tgies> oh.
02:57:46 <tgies> awesome; that actually even makes sense
02:57:48 <tgies> thanks a lot
02:58:05 <dolio> No problem.
02:58:46 <robreim> guerra: you mean in the signals part of glade? If I understand correctly, that's only used to automatically generate C code and isn't used by libglade
02:59:09 <guerra> robreim: oooh ok doesnt work with gtk2hs then
02:59:51 <robreim> guerra: nah. The glade maintainers generally advise not to use automatic code generation and instead just use libglade, so much of that functionality is pretty useless.
03:00:29 <guerra> robreim: got it
03:00:33 * robreim thinks it would be nice if glade could be compiled and installed without all that unused functionality to simplify things a bit
03:01:50 <guerra> robreim: thanks
03:02:38 <robreim> no problem
03:04:49 <robreim> hmm... personally I prefer "forever" over "repeatM_". I hope forever gets in. But I care too little to add to the noise abouti t.
03:04:54 <ms_> if I have an op such as (+), which of foldl or foldr should be faster?
03:05:36 <ms_> eg, summing a list of Doubles
03:05:45 <dons> foldl' or sum :)
03:05:48 <robreim> ms_: foldr is lazy evaluation friendly. foldl can be made tail-recursive by combining it with strict evaluation. Generally, stick with foldr
03:05:49 <dons> > sum [1..10]
03:05:51 <lambdabot>  55
03:05:55 <robreim> (I think that's right anyway)
03:06:07 <dons> > foldl' (+) 0 [1..10]
03:06:08 <lambdabot>  55
03:06:46 <guerra> robreim: i have a imageMenuItem generated with glade and i wanted it do open a dialog when pressed, i made the code onActivateItem start $ do widgetShowAll startGame where start is the menuItem and startGame the windows to be shown. It doesnt work though, any idea of what am i doing wrong? im cast the menu item with castToMenuItem
03:07:00 <lispy> > foldl1' (+) [1..10]
03:07:01 <lambdabot>  55
03:07:01 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
03:07:33 <ms_> mmm. ok, ta.
03:07:50 <robreim> guerra: what's the error?
03:07:54 <tgies> k bed.
03:08:13 <guerra> robreim: no erro, just doesnt show the window when i click
03:10:06 <robreim> oh ok. hmm. Let me think about it a bit.
03:10:45 <robreim> I think you want the handler to create the startGame as well as show it. But I would have thought it would work the first time you clicked the button at least...
03:11:31 <guerra> robreim: found out something, when i use onselect it works, but it opens the dialog when i highlight it and i want to click
03:11:33 <ms_> in the profiler output, what does the tick column mean?
03:11:34 <robreim> Anyway, the way I usually do it is define a function which creates the window, sets it up and shows it, then I call that from my handlers. I haven't tried it your way before but my way seems to work (I'm fairly new myself)
03:12:10 <robreim> Oh! Try onActivateLeaf
03:12:17 <guerra> humm
03:12:19 <guerra> lemme see
03:13:03 <guerra> robreim: yay, worked :D thanks
03:13:10 <robreim> great :)
03:19:49 <guerra> robreim: another problem appeared, when i close the windows that we just fixed (pclose pressin x i mean) it vanishes normally, but if i press the buttom so it can appear again it comes blank. I cant figure teh reason, could u plz explain if u know?
03:20:36 <robreim> guerra: Ah! Yes, that's what I was expecting would happen when you described it before. Wooh! I must be understanding it :)
03:20:44 <robreim> What's happening is you're creating your window
03:20:53 <robreim> outside the handler
03:21:22 <guerra> humm
03:21:33 <robreim> When you activate the handler, all it does is show that activated window. You then kill the window. But when you activate the handler again it tries to show the window which was created outside the handler.
03:21:46 <robreim> Basically, you want to create the window AND show it all within the handler.
03:22:14 <ms_> right, the profiler is saying that the following method is taking 38% of time and is the biggest hog
03:22:15 <guerra> robreim:  and how do i create it inside the handler?
03:22:15 <ms_> findDisplacement (Pt ax ay az) (Pt bx by bz) =
03:22:15 <ms_>     sqrt ((ax - bx)^2 + (ay - by)^2 + (az - bz)^2)
03:22:23 <ms_> how can I make that go faster?!
03:22:50 <robreim> sorry, I hope I didn't ramble too confusingly. Create another function of type IO () which creates the window and shows it and call that from the handler.
03:23:24 <robreim> Or just use a do block if you feel it's a small enough task.
03:24:30 <Binkley> ms_: are you compiling your code with optimization on?
03:24:43 <ms_> ghc --make -O2 -fglasgow-exts -fexcess-precision -optc-O3 -optc-ffast-math -no-recomp -optc-mfpmath=sse
03:24:49 <Binkley> Ok
03:24:52 <guerra> robreim:  u mean that i should create that window inside the program instead of using glades? or should i just creeate it inside the main window in glades?
03:24:55 <Binkley> as far as I know, there's not too much else you can do
03:25:08 <ms_> oh joy.
03:25:18 * resiak pokes dcoutts with spoons.
03:25:20 <Binkley> someone else can disprove me if necessary :-)
03:26:16 <ms_> ;)
03:27:06 <robreim> No, continue to use glade, but the step which defines your startGame variable (probably a call to xmlGetWidget) needs to be within the handler.
03:27:40 <dons> ms_: hehe that's a few flags you got there
03:27:48 <ms_> the more the merrier!
03:27:53 <guerra> robreim:  ok, sry if im being noobish, but what would be the handler?
03:27:53 <Binkley> ms_: actually, I'm curious about something. can you recompile the file containing that function with -dshow-passes -dppr-debug -dverbose-core2core and paste the results?
03:27:55 <Binkley> @paste
03:27:55 <dons> ?wiki Performance
03:27:56 <lambdabot> http://paste.lisp.org/new/haskell
03:27:56 <lambdabot> http://www.haskell.org/haskellwiki/Performance
03:27:57 <robreim> That's what's creating your startGame "object". If you create it outside the handler, when you destroy the object the handler can't access it anymore. So the handler needs to create a new object each time it's called.
03:28:02 <dons> has the details on speeding it up
03:28:12 <dons> ms_: the main trick is to check the values are being unboxed properly
03:28:25 <Binkley> yeah, that's what I was thinking
03:28:25 <dons> (possibly adding strict fields to your Pt type)
03:28:35 <guerra> robreim: i understood that part of the recreating ^^ :D at least hehe
03:28:37 <ms_> dons: I've been reading that...
03:28:49 <dons> ms_: also, you might need to manually unbox. not sure. can't tell till we see what the core output looks like
03:29:01 <ms_> Binkley: ok, will recompile
03:29:09 <robreim> guerra: don't be sorry, my failure to explain adequately. onActivateLeaf <object> <handler>
03:29:13 <Binkley> I'm wondering whether ghc thinks that that function has too many arguments to worker/wrapper split
03:29:21 <robreim> Your handler is what you put at <handler>
03:30:37 <ms_> ok, I presume you just want the output for that avgVectors function?
03:30:44 <Binkley> ms_: yeah. for starters, at least
03:30:48 <ms_> cos I've got lots of output here...!
03:30:58 <robreim> So something like "do { startGame <- xmlGetWidget ... ; showWidgetAll startGame }"
03:31:00 <guerra> robreim:  lemme try here
03:31:02 <Binkley> yeah, -dverbose-core2core will do that :-)
03:31:21 <ms_> @paste
03:31:21 <lambdabot> http://paste.lisp.org/new/haskell
03:32:27 <dons> -ddump-simpl is the best way to get the output though
03:33:00 <ms_> err, that function becomes HUGE!
03:33:06 <dons> so its inlined?
03:33:15 <dons> or is it still top level?
03:33:19 <dons> where's the src! :)
03:33:24 <ms_> hang on!
03:34:35 <ms_> oh, whoops, I was looking at the wrong function...
03:35:02 <dons> ghc -O ... -ddump-simpl | less -- is useful
03:35:13 <lisppaste2> ms pasted "findDisplacement with verbose core stuff" at http://paste.lisp.org/display/29790
03:35:19 <ms_> finally!
03:35:34 <Binkley> ms_: which pass was that from?
03:35:42 <Binkley> (the passes get printed out with ======= surrounding their names)
03:36:05 <ms_> oh, um let me look
03:36:15 * ms_ remembers to *save* the compiler output next time...
03:36:25 <Binkley> hehe
03:36:26 <guerra> robreim: would u mind to see my code and tell me? i think i didnt get =/
03:36:37 <Binkley> redirecting it to a file is useful, then you can look at the output as many times as necessary
03:36:43 <dons> ok, so none of the args are being unboxed?
03:36:45 <dons> Double
03:36:47 <ms_> indeed
03:36:49 <dons> no Double#
03:36:53 <dons> ok, you have ghc 6.6?
03:36:56 <ms_> yes
03:36:59 <Binkley> yeah, none of the args are being unboxed and the function isn't being worker/wrapped split
03:37:06 <Binkley> but if this is the desugarer output, that would explain why :-)
03:37:13 <dons> or anyway, start by adding strict fields to the Pt data type
03:37:20 <robreim> guerra: sure. can you use the paste?
03:37:22 <robreim> @paste
03:37:23 <lambdabot> http://paste.lisp.org/new/haskell
03:37:28 <dons> data Pt = Pt !Double ... or what have you
03:37:33 <dons> should help a lot
03:37:35 <ms_> right, that was in desugar
03:37:46 <Binkley> yeah, look at what comes after the CorePrep phase
03:37:48 <Binkley> and paste that
03:37:49 <lisppaste2> guerra pasted "problems with handler" at http://paste.lisp.org/display/29791
03:38:13 <dons> ms_: this is useful, perhaps: http://shootout.alioth.debian.org/gp4/benchmark.php?test=pidigits&lang=ghc&id=0
03:38:17 <lisppaste2> ms pasted "after coreprep" at http://paste.lisp.org/display/29792
03:38:18 <lambdabot> Title: pidigits Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ..., http://tinyurl.com/y8x65s
03:38:55 <ms_> Binkley: was that what you were after?
03:39:06 <Binkley> ms_: yeah, that's exactly what I was after
03:39:14 <Binkley> it looks like GHC is doing the right thing -- it *is* unboxing all the arguments
03:39:24 <Binkley> the only problem might be if the wrapper doesn't get inlined
03:39:31 <dons> oh, we didn't see the -ddump-simpl output?
03:39:36 <ms_> no
03:39:38 <ms_> hang on!
03:39:41 <Binkley> actually...
03:40:00 <dons> might be worth manually unboxing
03:40:07 <dons> you can precisely control the core then
03:40:14 <Binkley> I think I see the problem
03:40:21 <Binkley> GHC doesn't yet do the unboxing recursively
03:40:25 <guerra> robreim: http://paste.lisp.org/display/29791
03:40:28 <Binkley> that is, your Points get unboxed, but the Doubles inside them don't
03:40:32 <ms_> ok
03:40:32 <Binkley> which is one thing I'm working on right now :-)
03:40:44 <ms_> well what are you waiting for?! ;)
03:40:45 <Binkley> in the meantime, you're probably best off manually unboxing, like dons said
03:40:46 <Binkley> heh
03:40:47 <dons> hmm. strict fields on the Pt data type should help
03:40:50 <ms_> ok
03:40:59 <ms_> data Point = Pt { x :: Double, y :: Double, z :: Double }
03:41:15 <ms_> becomes data Point = Pt { ! x :: Double, ! y :: Double, ! z :: Double }
03:41:17 <ms_> ?
03:41:34 <ms_> how does strictness work on records? Or shouldn't I use records?
03:41:54 <dons> not quite, x :: !Doube
03:42:03 <ms_> ahh, yes
03:42:03 <ventonegro> hi
03:42:04 <dons> but no need for records here?
03:42:08 <Binkley> well, ideally you'd want the x, y and z to be Double#
03:42:20 <Binkley> not sure if you can have an unboxed value as a record field, though
03:42:21 <lisppaste2> robreim annotated #29791 with "Guerra: Try this" at http://paste.lisp.org/display/29791#1
03:42:27 <Binkley> you may need to use an unboxed tuple instead of a record
03:42:28 <ventonegro> if i have a large data structure built incrementally, i'm screwed, right?
03:42:51 <ventonegro> because everytime i append something to it haskell will build a new copy
03:43:00 <robreim> guerra: does that clarify what I mean?
03:43:14 <ms_> ok, so with Double# I get: Matthew.hs:18:53: Not in scope: type constructor or class `Double#'
03:43:14 <Binkley> see http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html for the scoop
03:43:17 <lambdabot> Title: 7.2. Unboxed types and primitive operations, http://tinyurl.com/y59rbr
03:43:18 <dons> I'd just go with the following, which gives us much better code:
03:43:20 <ms_> ah, thanks
03:43:24 <dons> ie.. we get this;     GHC.Prim.sqrtDouble# (GHC.Prim.+## (GHC.Prim.+## x_aSO y_aSR) y1_XTK)
03:43:28 <Binkley> ms_: import GHC.Exts and compile with -fglasgow-exts
03:43:35 <dons> from:
03:43:36 <dons> data Pt  = Pt !Double !Double !Double
03:43:36 <dons> findDisplacement (Pt ax ay az) (Pt bx by bz) =
03:43:36 <Binkley> (I guess you're already doing the latter)
03:43:36 <dons>     sqrt ((ax - bx)^2 + (ay - by)^2 + (az - bz)^2)
03:43:39 <ventonegro> maybe not the right time
03:43:51 <dons> with: ghc-6.5 -c -ddump-simpl -O2 -funbox-strict-fields A.hs
03:43:59 <dons> ventonegro: not necessarily
03:44:07 <dons> depends on the structure. if its a lazy structure you'll be fine
03:44:10 <dons> i.e. a Map or a list
03:44:19 <dons> since you're just hooking in new ptrs
03:44:24 <ms_> ok, so no record type and strict values in Pt. Cool, gimme 5 mins and I'll let you know
03:44:29 <guerra> robreim: yes th handler is the current do (or something like that)
03:44:34 <dons> not sure if the records matter though
03:45:21 <ventonegro> dons, it's a triangle mesh :-)
03:46:01 <robreim> guerra: Yeah. It's the command you're passing to onActivateLeaf to be called whenever a leaf activation event occurs. It "handles" that event.
03:46:47 <dons> ventonegro: it really depends on how you define the structure
03:47:04 <ventonegro> dons, ok, i guess i need to read more
03:47:10 <ventonegro> dons, thanks for the help
03:47:19 <dons> incremental stuff often works very well with laziness, and is more efficient than a strict type (like an unboxed array, which would require copying)
03:47:39 <dons> the copying is more to do with avoiding mutable updates
03:47:41 <dons> not laziness.
03:47:49 <dons> you can of course mutate the structure if you want
03:47:56 <dons> (if its more natural/efficient that way)
03:48:33 <ventonegro> dons, so, i can build it and then only when i need to visit the faces it'll be really built, right?
03:49:02 <guerra> robreim: the second time i tried to open it said tehre was no newgame at the glade file
03:49:39 <ms_> right, what ghc output would you like to see now?
03:49:52 <ms_> simpl or verbose?
03:49:59 <dcoutts_> @arr!
03:50:00 <lambdabot> I want me grog!
03:50:10 <dons> ventonegro: if you define it the right way, yeah
03:50:12 <Binkley> ms_: simpl should be ok
03:50:13 <dons> keep it lazy
03:50:19 * dcoutts_ keeps is lazy
03:50:22 <dcoutts_> is/it
03:50:23 <dons> ms_: -ddump-simpl
03:50:32 <dons> (the final result of simplification)
03:50:53 <lisppaste2> ms_ pasted "simpl after strict data type" at http://paste.lisp.org/display/29793
03:50:57 <ventonegro> dons, but lazy list constructions use recorrent relationships, i think it's not the mesh's case
03:51:24 <Binkley> ms_: can you also look for the definition of $wfindDisplacement and paste that?
03:51:36 <robreim> guerra: how do you mean second time? You mean the second time you clicked on the menu item or you're calling xmlGetWidget on "newGame" in two places?
03:51:48 <guerra> second time i clicked
03:51:58 <guerra> robreim: after i close it
03:52:09 <lisppaste2> ms_ pasted "wfindDisplacement" at http://paste.lisp.org/display/29794
03:52:12 <robreim> oh ok. Hmm.
03:53:01 <Binkley> hmm. those Doubles still aren't getting unboxed
03:54:22 <Binkley> the next thing I would try is to define the Pt type as an unboxed tuple of Double#s instead, unless dons can think of something else to look at
03:54:28 <dcoutts_> guerra, are you trying to make a new instance of the window ?
03:54:59 <dcoutts_> guerra, if so you just need to load the xml file again (in fact it is cached so this will be quick)
03:55:48 <dcoutts_> guerra, it only makes each object once when you do xmlNew. After that, xmlGetWidget always gets the same set of widgets.
03:55:54 * ms_ reads up on unboxed types
03:56:21 <dcoutts_> unboxed types are cool, especially when you don't have to write stuff with them directly
03:56:56 <dcoutts_> it's a great intermediate language for expressing compiler transforms
03:56:58 <guerra> dcoutts u mean the main window or the window that closes the program?  plz check the paste http://paste.lisp.org/display/29791#1 the code is now like the anotation
03:58:05 <dcoutts_> guerra, the point is that you've not actually changed anything by swapping startGame for xmlGetWidget _ _ "newGame"
03:58:44 <dcoutts_> guerra, do you mean widgetShowAll btw ?
03:59:13 * ms_ watches the errors fly by having made his pointers unboxed
03:59:15 <dcoutts_> guerra, I'm not sure I know what the problem you're facing is.
04:00:13 <guerra> dcoutts i just want to make the window appear normally everytime i click the menoItm, it works for only once.
04:00:22 <robreim> guerra: in that handler, you need another xmlGetWidget call to reload your glade file each time the handler is called.
04:00:23 <Binkley> heh
04:00:28 <SamB_XP> ms_: hmm?
04:00:36 <SamB_XP> what did you *do*?
04:01:07 <ms_> right, so now that I have data Point = Pt Double# Double# Double#
04:01:09 <dcoutts_> guerra, are you destroying the window when you close it? If so then you can't show it again without loading the thing again.
04:01:16 <ms_> how do I create a Point at 0 0 20?
04:01:22 <robreim> guerra: actually, I usually put each window in its own glade file and write specialised functions for creating and showing windows. Would that be suitable for what you're trying to do?
04:01:24 <ms_> I used to be able to write Pt 0 0 20
04:01:26 <dcoutts_> guerra, so you probably want to just hide it rather than let it be destroyed.
04:01:42 <Binkley> Pt 0# 0# 20#, I think?
04:01:45 <ms_> that doesn't work now, nor does Pt 0# 0# 20# nor Pt 0.0# 0.0# 20.0#
04:01:47 <ms_> nope
04:01:48 <guerra> dcoutts could be
04:01:56 <ms_> it thinks they're ints
04:01:57 <Binkley> ah, you tried that already...
04:02:19 <ms_> fraid so
04:02:20 <guerra> robreim: think so, but how do i reload my glade file?
04:02:30 <SamB_XP> ms_: don't do that
04:02:31 <ms_> I also tried 0.0#::Double#
04:02:33 <dcoutts_> guerra, onDelete startGame (\_ -> widgetHide startGame >> return True)
04:02:33 <SamB_XP> do instead
04:02:51 <robreim> dcoutts_: xmlNew loads all the objects in the xml file as well as just reading the xml file? I would have thought xmlGetWidget would do the object creation...
04:03:00 <SamB_XP> something with {-# UNPACK #-} and data Point = Pt !Double !Double !Double
04:03:01 <dcoutts_> guerra, that prevents the window being destroyed when the user closes it, and it hides it instead.
04:03:23 <robreim> guerra: the xmlNew call is what loads the glade file
04:03:50 <ms_> SamB_XP, have you seen the @pastes ?
04:03:53 <dcoutts_> robreim, no, xmlNew does the creation. So xmlGetWidget then just retreives the objects. So if you call it several times with the same name then you get several references to the same widget.
04:04:03 <ms_> I've tried making them strict
04:04:03 <SamB_XP> nope
04:04:09 <Binkley> ah. yeah, that sounds like a good idea. didn't know there was an UNPACK pragma :-)
04:04:29 <dcoutts_> aye, UNPACK is very useful
04:04:34 <Binkley> although it looks like it shouldn't be necessary if you're compiling with -funbox-strict-fields...
04:04:49 <robreim> oh ok. Well that explains it.
04:04:51 <SamB_XP> Binkley: I was assuming you might not want to
04:05:00 <dcoutts_> Binkley, I think that's a sledgehammer. I'd always use UNPACK.
04:05:00 * ms_ adds -funbox-strict-fields to his makefile
04:05:12 * ms_ thinks again
04:05:15 <SamB_XP> yeah, what dcoutts says ;-)
04:05:18 <dcoutts_> UNPACK is great as it gives control over the data layout without making you use unboxed types.
04:05:21 <SamB_XP> hammer, anyway
04:05:39 <Binkley> well, let's see what core that generates, at least
04:05:41 <ms_> make you minds up! So, the data type is just strict - not unboxed?
04:05:48 <dcoutts_> sometimes you don't want to unpack things into their constructors
04:05:51 <SamB_XP> ooh, lisppaste's paren matching works on curlies too?
04:05:52 <ms_> then I use the UNPACK pragma?
04:05:57 <Binkley> ms_: yeah, try that for now
04:05:59 <ms_> ok
04:06:04 <SamB_XP> and squares...
04:06:11 <dcoutts_> you can get sharing if you don't unpack for example, it depends on the example
04:06:50 <dcoutts_> for example, unpack small things, like ints, pointers, don't unpack large records.
04:07:19 <guerra> dcoutts robreim it works now,  hope i can use it right for what i want next! thanks :D
04:07:35 <dcoutts_> guerra, great
04:07:45 <ms_> dcoutts_: sure, ok
04:07:47 <robreim> guerra: excellent! And with that I'm off to do the dishes :)
04:07:56 <dcoutts_> ms_, it's basically the difference between pass by value (ie copying) and pass by reference
04:07:58 <guerra> robreim:  :D
04:08:07 <TSC> Is there a function in the prelude that does this: \x y -> (x,y)   ?
04:08:18 <dcoutts_> for large things it's often a win to pass by reference, for small things copying is quicker and simpler.
04:08:19 <Binkley> TSC: yes, (,)
04:08:20 <SamB_XP> yes, (,)
04:08:26 <SamB_XP> heh
04:08:28 <TSC> Ah!
04:08:41 <dcoutts_> @pl \x y -> (x,y)
04:08:42 <lambdabot> (,)
04:08:49 <SamB_XP> @hoogle a -> b -> (a, b)
04:08:50 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
04:08:51 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
04:08:52 <dcoutts_> TSC, @pl will tell you :-)
04:08:59 <dcoutts_> TSC, or djinn
04:09:03 <TSC> Thanks
04:09:07 <ms_> right, it compiles...
04:09:09 <SamB_XP> hmm, apparantly hoogle doesn't know how to find names that aren't in modules...
04:09:13 <dcoutts_> @djinn a -> b -> (a,b)
04:09:14 <lambdabot> f a b = (a, b)
04:09:54 <dcoutts_> dons, we need ndm's DrHaskell as well as @pl
04:10:13 <dcoutts_> to do automagic refactoring / improvement
04:10:37 <dcoutts_> somewhat like @pl does, but not necessarily going full out for point free
04:11:08 <lisppaste2> ms_ pasted "simpl: findDisplacement with strict Point and unpack goodness" at http://paste.lisp.org/display/29796
04:11:21 <ms_> that looks unpacked to me!
04:12:03 <SamB_XP> ms_: indeed ;-)
04:12:07 <ms_> horay!
04:12:21 <ms_> right, back to the profiler then...
04:12:42 <ms_> thanks for all your help, and I'll be back shortly!
04:13:38 <SamB_XP> hmm...
04:13:50 <SamB_XP> what is with that DmdType...
04:14:11 <Binkley> SamB_XP: the demand on an unboxed value is always L
04:14:26 <ms_> um
04:14:43 <ms_> the profiler now says that that function is taking even more time than before
04:14:49 <ms_> findDisplacement               Matthew               43.4   39.2    268 455307264
04:14:50 <Binkley> ms_: yeah, that's a problem with the profiler...
04:15:00 <Binkley> ms_: cost-centre annotations interfere with unboxing and worker/wrapper optimizations
04:15:09 <dcoutts_> profiler isn't very helpful for low level unboxing work
04:15:12 <ms_> oh happy happy joy joy
04:15:24 <Binkley> -ticky-ticky would help, but it's not currently working
04:15:25 <dcoutts_> looking at the core code and doing micro benchmarks is better
04:15:31 <Binkley> I've fixed it but not checked in my changes yte
04:16:11 <Binkley> in the meantime you can use wallclock time to get a rough guess, if your code runs long enough
04:16:25 <ms_> right. so will the profiler just over report for that method but the rest stays ok, or are all the results invalid?
04:16:48 <Binkley> ms_: because of the cost-centre annotations, your functions aren't going to get worker/wrapper split
04:16:56 <Binkley> so, it's basically as if you're profiling unoptimized code
04:17:44 <ms_> ahh, ok
04:18:06 <ms_> so I can still proceed to identify the next worst offender and work on that?
04:18:45 <Binkley> well, I suggest using the profiler to figure out a list of possible offenders, then look at the core for each one when you compile with profiling off
04:19:26 <ms_> ok thanks, will do
04:19:51 <roconnor> @type sequence_
04:19:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:20:08 <SamB> yeah, that sucks for me too...
04:21:29 * SamB wishes the optimizer could just forget about (or *maybe* float out) cost centers when they get in the way of unboxing...
04:22:27 <Binkley> yeah, that would be nice
04:22:37 <Binkley> I don't know if there's a good reason why it doesn't do that
04:23:15 <SamB> maybe it is hard
04:23:23 <Binkley> could be
04:28:44 <fabiim> doit2 :: (Enum Char) => Char
04:28:50 <fabiim> what's wrong with this?
04:29:18 <roconnor> (Enum a) puts a constraint on a type variable a.
04:29:26 <roconnor> but Char is a type, not a type variable.
04:29:29 <Binkley> fabiim: what are you trying to do?
04:29:36 <Binkley> that type signature is equivalent to Char, for one thing
04:29:40 <Binkley> (like roconnor said)
04:30:45 <fabiim> [foo (foo2!!n) a | n <- [0..9], a<-["A".."Z"]]
04:31:32 <Binkley> what are the types of foo and foo2?
04:33:00 <fabiim> foo :: String -> String -> String  ( it call another function , will you need that type too?)
04:33:22 <Binkley> well, then it sounds like the body of doit2 doesn't have type Char
04:33:24 * SamB wonders if Demand is actually a lattice
04:33:29 <Binkley> SamB: yes, it is
04:33:45 <fabiim> foo2 :: String
04:34:15 <fabiim> Binkley:  doesn't have type Char ?
04:34:33 <fabiim> ohh ! yes
04:34:33 <Binkley> fabiim: you just wrote that doit2's body is  [foo (foo2!!n) a | n <- [0..9], a<-["A".."Z"]] - what's the type of that expression?
04:35:20 <fabiim> [[char]]
04:35:31 <Binkley> right
04:35:35 <Binkley> or [String], equivalently
04:36:12 <fabiim> so , i can i solve the Enum problem ?
04:36:44 <fabiim> ups , how can i solve...
04:36:46 <fabiim> ?
04:36:48 <Binkley> fabiim: you don't need that type constraint at all
04:36:58 <Binkley> like you just said, the correct type signature is doit2 :: [String]
04:38:45 <lisppaste2> fabiim pasted "enum problem " at http://paste.lisp.org/display/29799
04:39:21 <fabiim> do you mind to give a look at that ?
04:40:06 <lispy> > ['A' .. 'Z']
04:40:08 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
04:40:16 <lispy> > ["A" .. "Z"]
04:40:17 <lambdabot>  add an instance declaration for (Enum [Char])
04:40:17 <lambdabot>   In an arithmetic sequence...
04:40:43 <Binkley> the compiler error message means that String isn't an instance of Enum
04:40:53 <lispy> > map (:[]) ['A' .. 'Z']
04:40:54 <lambdabot>  ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S"...
04:41:02 <Binkley> you're trying to generate a list of strings from "A" to "Z" but there's no built-in way to do that
04:41:31 <lispy> fabiim: maybe one of the things i just typed gives you an idea :)
04:41:32 <Binkley> it works if you use Chars instead, because you can enumerate Chars (like lispy showed how to do there)
04:41:47 <SamB> Binkley: any particular reason there is no Lattice class for it, or that the code doesn't seem to mention this fact?
04:42:07 <Binkley> SamB: I didn't know there was a Lattice class at all :-)
04:42:43 <SamB> @google "springschool95.pdf"
04:42:43 <fabiim> lispy , yeah solved my whole problem , thanks =)  . Binkley : thanks too.
04:42:45 <lambdabot> http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf
04:43:01 <SamB> on page 17
04:43:48 <Binkley> SamB: well, Demand is kind of a funny lattice. rather than a meet or join function, we have a "both" function, which doesn't work quite the same way
04:43:48 <SamB> I must admit the data constructors did sorta give the impression that it might be, though...
04:44:02 <SamB> oh, so it is only a semilattice?
04:44:09 <SamB> or what?
04:44:18 * SamB doesn't know what a semilattice is yet, though
04:44:55 <Binkley> heh
04:45:00 <Binkley> well, I had to look up what a semilattice is too :-)
04:45:13 <Binkley> I haven't worked out all the theory for this yet, though it's possible that Simon or someone else who's worked on this has
04:45:21 <SamB> also, are "lub" and "both" not meet and join?
04:45:44 <Binkley> SamB: not exactly. *looks for the paper that explains this (which isn't published yet)*
04:45:55 <SamB> oh, joy, unpublished
04:46:00 <fabiim> is there any null character? one wich when i do this a:[] returns [] ?
04:46:11 <SamB> fabiim: nope
04:46:16 <SamB> that would make no sense
04:46:25 <SamB> (:) is a data constructor...
04:47:03 <lispy> ?type (:)
04:47:05 <lambdabot> forall a. a -> [a] -> [a]
04:47:19 <Binkley> SamB: well, my job here is to help get it to the point where it can be published :-)
04:47:21 <flux__> maybe something that would convert Just 'a':Just 'b':None:[] into 'ab' would suffice, if you really need that
04:47:24 <Binkley> lub is, I think, join
04:47:27 <flux__> ("ab", even)
04:47:31 <Binkley> both is neither meet nor join, though
04:48:22 <SamB> oh
04:48:48 <fabiim> but doesn't ascii have a null character?
04:49:25 <earthy> fabiim: yes, but it's not a zero for the (:) constructor.
04:49:42 <Binkley> fabiim: the (:) constructor is polymorphic, so there's no reason for it to have special code for handling characters
04:49:50 <Binkley> strings are just lists of characters
04:49:57 <Binkley> so list code can't depend on anything that's specific about characters
04:50:33 <lispy> > '\0' : []
04:50:35 <lambdabot>  "\NUL"
04:51:19 <fabiim> ok , that make sense .
04:51:28 <lispy> > [] : "blah"
04:51:30 <lambdabot>  Couldn't match `[a]' against `Char'
04:51:35 <lispy> > [] : ["blah"]
04:51:36 <lambdabot>  ["","blah"]
04:52:30 <lispy> > [] ++ "blah"
04:52:31 <lambdabot>  "blah"
04:52:46 <lispy> > '\0' ++ []
04:52:53 <lambdabot>  Couldn't match `[a]' against `Char'
04:53:06 <lispy> fabiim: not sure if those examples help much :)
04:53:54 <fabiim> yes they did , i think my new problem is also solved
04:54:25 <lispy> ah, cool :)
05:01:27 * SamB would have expected the error function to be more demanding...
05:02:04 <SamB> oh, but I guess its argument isn't evaluated until the exception is caught
05:02:09 <SamB> anyway, I gotta go to school
05:03:05 <Binkley> SamB: the error function has the most demanding possible demand, in fact
05:03:15 <SamB> oh
05:03:15 <Binkley> since it's completely safe to evaluate its argument as much as you want
05:03:21 <Binkley> since error diverges anyway
05:03:29 <SamB> ah
05:03:31 <SamB> but
05:03:47 <SamB> hmm
05:03:51 <SamB> now I'm confused.
05:03:54 <SamB> anyway, bye!
05:03:54 <Binkley> heh
05:03:56 <Binkley> later
05:05:05 <guerra> dcoutts had a new problem here, thsi is weird, like i had set the star window to appear when i press start in menu i made the about window appear when i press the about in menu, but when i open teh gui and press the help menu  or the file one, it already shows the about dialog......any idea?
05:05:38 <dcoutts_> guerra, set it not to show automatically in glade
05:05:54 <dblhelix> does any of the new wxhaskell maintainers hang out in this channel?
05:06:00 <dcoutts_> guerra, it's a property in glade of the window, if it'll start off hidden or visible.
05:06:16 <dcoutts_> dblhelix, if so, I don't know who they are.
05:06:48 <dblhelix> dcoutts: i was hoping they were, and that then they'd know themselves ;)
05:06:56 <dcoutts_> heh :-)
05:07:19 <dcoutts_> I'd have thought that I'd have spotted them
05:07:52 * dblhelix has a fp course starting in February and has to decide between gtk2hs ;) and wxhaskell
05:08:12 <dcoutts_> dblhelix, well I am running a fp course right now using gtk2hs
05:08:24 <dcoutts_> we're doing stuff with 3D graphics
05:08:30 * earthy grins
05:08:38 <dcoutts_> I've got a gui with an embeded opengl widget
05:08:49 * earthy will mention in passing that the course dblhelix has to run is supported on machines running windows.
05:09:00 <guerra> dcoutts yep! it worked!
05:09:02 <dblhelix> dcoutts_: we won't be doing 3d, that's for sure
05:09:27 <dcoutts_> dblhelix, what are you planning on ?
05:09:52 <dcoutts_> dblhelix, btw, there will be a new gtk2hs release with a windows installer by the time you want to start that course
05:11:38 <dblhelix> dcoutts_: just a simple gui app with some standard widgets: buttons, treeviews, menus etc., nothing fancy
05:12:04 <dcoutts_> aye, are you making the students write the gui code ?
05:12:57 <dblhelix> dcoutts_: i think i will provide them with a working gui app and let them extend it
05:13:10 <dcoutts_> right
05:13:17 <dcoutts_> sounds fun
05:13:57 <dcoutts_> my practical is a first intro to Haskell, so we don't make them write the gui code, it's just pure recursive list functions that produce some stuff the we visualise with a gui
05:14:31 <dcoutts_> it starts in 45 min so I should go :-)
05:14:55 <dblhelix> dcoutts_: possible issues are: availability of the gui toolkit on our lab machines (has to be resolved for, say, Jan 1st), availability of the toolkit at the machines at the students' home, and docs
05:15:09 <dblhelix> /s/home/homes
05:26:06 <malebria> Hello there.
05:26:19 <malebria> @paste
05:26:20 <lambdabot> http://paste.lisp.org/new/haskell
05:27:47 <lisppaste2> malebria pasted "Problem with 'a' type" at http://paste.lisp.org/display/29804
05:28:48 <malebria> I'm having a problem in defining the type of a constant inside a function...
05:33:52 <dozer> malebria: post an example?
05:34:45 <robreim> dozer: they did
05:35:19 <dozer> hehe -              yh
05:35:27 <dozer> oops - cat on keyboard error
05:38:00 <malebria> dozer: any idea?
05:38:11 <dozer> if you split the line "a,  b :: [a]" into "a' :: [a]" and "b' :: [a]" does the problem go away?
05:38:46 <malebria> dozer: no.
05:38:54 <malebria> The problem is with the list type.
05:39:27 <dozer> should it not be of type ([a], [a])?
05:39:45 <guerra> how do i convert a String to an Int?
05:40:17 <dozer> so just drop tha type-sig entirely
05:40:39 <robreim> guerra: read :: String -> Int;
05:41:04 <guerra> robreim: can i read an Int at once from an entry?
05:42:35 <robreim> guerra: you can attempt to read an Int from any String.
05:42:52 <guerra> robreim:  ok
05:42:55 <guerra> robreim:  ty
05:43:07 <malebria> dozer: I've done this already to continue, but I would like to annotate that type.
05:43:17 <dozer> @hoogle String -> Int
05:43:18 <lambdabot> No matches, try a more general search
05:43:19 <robreim> use reads if it's possible the string isn't an Int and you want to catch the error.
05:43:41 <dozer> try: (a, b) :: ([a], [a])
05:48:29 <malebria> Urban/Utils/Haskell.hs:90:2: Type signature given for an expression
05:48:39 <malebria> It's not possible to declare types like this.
05:49:15 <dozer> probably for good reason, thinking about it :)
05:51:07 <dozer> ah, hang on, the function you've written has no way of knowing that the a in [a] has any relationship to the a in the splitAtDiv_ signature above
05:51:22 <dons> ?users
05:51:23 <lambdabot> Maximum users seen in #haskell: 265, currently: 238 (89.8%), active: 42 (17.6%)
05:51:58 <dozer> you need to 'recapture' a for your third splitAtDiv_ version if you wish to use it
05:52:48 <dozer> splitAtDiv_ (list :: [a]) (limit : limits) = ...
05:52:57 <dozer> try that?
05:53:14 <dons> using pattern type annotations might need -fglasgow-exts
05:53:26 <dons> > (\(x :: Int) -> x) 2 -- it isn't h98
05:53:26 <lambdabot>  Parse error in pattern
05:53:41 <dozer> k, but it's the solution to his problem I think?
05:55:06 <roconnor> robreim: I didn't see any of your reddit comments about building consensus
05:55:30 <robreim> roconnor: no, I wrote the article. Old nickname.
05:55:41 <robreim> It seemed to be pretty unpopular on reddit :(
05:55:51 <malebria> dozer: hum...
05:55:54 <malebria> I'll try it.
05:56:35 <robreim> dozer: doesn't the "splitAtDiv_ :: [a] -> [Int] -> [[a]]" type signature already declare the type of list to be [a] ?
05:56:38 <roconnor> robreim: I'm reading through the guide
05:56:52 <robreim> roconnor: cool. Feedback would be appreciated :)
05:56:56 <guerra> robreim: whats does an  IO (ConnectId b) means?
05:57:12 <dozer> don't think so robreim - the type sig and the function code are treated seperately
05:57:21 <dozer> all types in the two are unified, not matched directly
05:57:43 <robreim> guerra: it means it performs an IO action which returns an object of type "ConnectId b". I haven't found a use for that object yet so I usually ignore it. You probably can too.
05:58:06 <malebria> It worked...
05:58:10 <dozer> hehe
05:58:12 <malebria> But it's not a very pretty code.
05:58:44 <dozer> so, the a in the sig and the a in the impl are different 'a's but the compiler unifies them and shows that they can match the same stuff, so it gets through
05:58:47 <robreim> dozer: oh I think I understand. Thanks, I didn't know that.
05:59:12 <guerra> robreim: got it
05:59:30 <malebria> Isn't there no prettier way?
05:59:36 <dozer> woot! only 9 months into haskell, and I answered a question right!
05:59:58 <dozer> not that I'm aware of, although see previous comment
06:01:03 <robreim> malebria: leaving out the type signature in that where clause would probably be the pretty way :)
06:02:12 <malebria> robreim: I like to annotate the types of all variables I define.
06:02:13 <robreim> Though you're right. Surely there's a way to give the type signature...
06:02:48 <malebria> robreim: and do you know how?
06:03:21 <robreim> I wish I did. I'm pretty baffled by your problem :( (I'm a newer user than even dozer :P )
06:04:07 <guerra> robreim: the problem is that i made a onClicked buttom and asked it to call a function that print somethin on the screen, the compiler says it got IO() isntead of IO  ConnectId Buttom
06:04:41 <malebria> guerra: is it gtk2hs?
06:05:01 <guerra> yes
06:06:41 <malebria> guerra: isn't it because you're calling it in a IO () function?
06:06:48 <malebria> guerra: maybe in the last statement of a do expression?
06:06:58 <robreim> guerra: was IO () the expected type and IO ConnectId Button the inferred? Perhaps you used it somewhere where a IO () type was expected, like at the end of a function which returns IO ()?
06:10:17 <guerra> malebria: yes i am
06:10:27 <guerra> robreim: thats the case
06:10:30 <robreim> guerra: chuck a return () on the end then
06:11:13 <robreim> guerra: do you understand what's happening there?
06:11:26 <roconnor> robreim: yay anarchism
06:11:48 <guerra> robreim: no
06:11:56 <robreim> roconnor: anarchism? where? :)
06:12:09 <roconnor> robreim: on your lj interests
06:13:13 <robreim> Oh. Heh. Yeah, I'm a pretty dedicated anarchist. Great, now we've got to start an IRC channel for lojban-speaking, haskell-coding anarchists. Narrow it don even more ;)
06:14:51 <vegai> robreim: dozens would join it...
06:15:16 <robreim> guerra: you probably need to familiarise yourself a little with monads then. Basically your do expression has a return value equal to the return value of the final expression. If your last expression isn't the return value you want, you need to return an appropriate value explicitly using return.
06:16:00 <robreim> vegai: heh :)
06:16:07 <robreim> ok, sleep time for me. 'night all!
06:16:31 <guerra> robreim: humm think i got it
06:18:51 <roconnor> @localtime robreim
06:18:54 <lambdabot> Local time for robreim is Mon Nov 13 23:18:31
06:24:05 <spiffy> oo GPL java today
06:24:07 <spiffy> exciting
06:25:20 <psykotic> > fix $ (1+) . map (1:)
06:25:21 <lambdabot>  add an instance declaration for (Num [[a]])
06:25:37 <psykotic> > fix $ (1:) . map (1:)
06:25:38 <lambdabot>  add an instance declaration for (Num [a])
06:25:40 <psykotic> > fix $ (1:) . map (1+)
06:25:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:27:35 <psykotic> fixed point combinators in a lazy language are too much fun
06:28:03 <roconnor> psykotic: you will love circular programming
06:28:14 <psykotic> roconnor, i already do :)
06:28:34 <roconnor> oh
06:28:39 <roconnor> then you will love MonadFix
06:29:21 <roconnor> > fix . (0:) . map succ
06:29:22 <lambdabot>  Couldn't match `a -> a' against `[a1]'
06:29:36 <psykotic> fix $ (0:) . map succ
06:29:51 <roconnor> ah right
06:30:00 <roconnor> > fix $ (0:) . map succ
06:30:34 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:30:53 <roconnor> > fix $ (minbound:) . map succ
06:30:57 <lambdabot>  Not in scope: `minbound'
06:31:01 <roconnor> > fix $ (minBound:) . map succ
06:31:02 <lambdabot>  Add a type signature
06:31:03 <psykotic> @type minBound
06:31:05 <lambdabot> forall a. (Bounded a) => a
06:31:16 <roconnor> > fix $ (minBound:) . map succ :: [Int]
06:31:20 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
06:31:27 <roconnor> > fix $ (minBound:) . map succ :: [Word]
06:31:29 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:31:56 <dolio> > fix $ (maxBound:) . map succ :: [Int]
06:31:58 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
06:32:10 <psykotic> it's probably easier to think of fixed points in this setting via the usual tarski construction rather than something like Y.
06:32:23 <dolio> > fix $ (maxBound:) . (1+) :: [Int]
06:32:25 <lambdabot>  add an instance declaration for (Num [Int])
06:32:32 <psykotic> ... which is to iterate a function, starting with the argument undefined.
06:32:33 <dolio> > fix $ (maxBound:) . map (1+) :: [Int]
06:32:35 <lambdabot>  [2147483647,-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-214...
06:32:55 <roconnor> psykotic: Tarski did that?  I always think of Scott domains.
06:33:28 <psykotic> i don't know if tarski proved it, but it's the tarski fixed-point theorem. you're right that it takes place for continuous functions on scott domains.
06:44:18 <psykotic> > let f = (1:) . map (1+) in iterate f undefined
06:44:20 <lambdabot>  Undefined
06:44:24 <psykotic> > let f = (1:) . map (1+) in iterate f undefined !! 1
06:44:26 <lambdabot>  Undefined
06:44:28 <psykotic> > let f = (1:) . map (1+) in iterate f undefined !! 100
06:44:29 <lambdabot>  Undefined
06:44:31 <psykotic> > let f = (1:) . map (1+) in iterate f undefined !! 1000
06:44:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:44:35 <psykotic> there we go
06:44:43 <psykotic> that's basically the tarski fixed-point construction.
06:45:08 <psykotic> you just have to make sure that lambdabot doesn't force the evaluation of the end :)
06:56:47 <psykotic> > let fix' f = iterate f undefined !! 1000 in (fix' $ \f n -> if n == 0 then 1 else n * (f $ n - 1)) 10
06:56:49 <lambdabot>  3628800
06:57:25 <psykotic> > let fix' f = iterate f undefined !! 1000 in (fix' $ \f n -> if n == 0 then 1 else n * (f $ n - 1)) 999
06:57:26 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
06:57:30 <psykotic> > let fix' f = iterate f undefined !! 1000 in (fix' $ \f n -> if n == 0 then 1 else n * (f $ n - 1)) 1000
06:57:31 <lambdabot>  Undefined
07:06:05 <monkey___> hello can anyone here help me with some exersises in Haskell?
07:07:10 <yaarg> anyone know if there's a nice trac thing for darcs? (not trac on darcs either)
07:07:24 <Lemmih> monkey___: State your problem and we will see.
07:08:50 <monkey___> well the first one:we insert a list of integers and we want the program to rerurn the list that will be made if we delete every integer that is between two bigger integers of the list
07:09:41 <Lemmih> monkey___: Is it homework?
07:09:45 <monkey___> that is to say :[1,3,4,2,5,6,7,3,5,] to [1,3,4,5,6,7,
07:10:23 <monkey___> actually it is but I dont have anything to help me neither book nor notes
07:10:57 <Lemmih> monkey___: How about reading a tutorial?
07:11:43 <monkey___> I did try but I dont understand all that I need to solve it
07:12:10 <dozer> monkey__ - break it down into special cases
07:12:20 <dozer> what should your function do for an empty list?
07:12:28 <monkey___> [] to []
07:12:35 <dozer> and a single-item list?
07:12:53 <monkey___> [1] to [1]
07:13:00 <dozer> and a 2 item list?
07:13:12 <monkey___> [1,2] to [1,2]
07:13:40 <dozer> that's one case
07:13:45 <spiffy> can you ask ghc why its expecting a certain type?
07:14:09 <monkey___> ghc?
07:14:44 <spiffy> sorry monkey___, that was more just directed to the room rather than anyone in particular
07:15:06 <monkey___> ok
07:15:19 <spiffy> unless you have an answer =)
07:15:23 <Lemmih> spiffy: I don't think so. You can ask the channel, though.
07:15:38 <psnl> monkey___: break your problem down into little bits
07:16:29 * psnl offers all purpose advice
07:16:39 <kosmikus> spiffy: no, not really. you can try to improve the error message by placing type annotations in your program, or help locate the source by temporarily replacing parts of your program with "undefined"
07:16:45 * dozer accepts all purpose advice and uses it for all purposes
07:17:47 <monkey___> yep but how??I need to compare integers in threesums
07:17:47 <psnl> dozer: remember not to apply it to people
07:18:30 <johnnowak> monkey___: you should give How to Design Programs a look -- it is very good at teaching you a step-by-step method for approaching these sort of problems
07:18:34 <dozer> "don't know how an engine works? take it to bits, put it back together" vs "don't know how a cat works? take it to bits and get a broken cat"
07:18:39 <psnl> monkey___: am I right in thinking that 1,1,45,3,5,65,1,1 would map to 1,1,45,65,1,1 ?
07:19:15 <dozer> although in my case taking an engine to bits would also result in a terminally broken engine
07:20:37 <monkey___> psnl thats it
07:20:55 <spiffy> card : (shuffle' deck')  --Assuming all those have proper bindings, this just generates a list right?
07:21:10 <johnnowak> monkey___: consider using foldr along with max and min to get the largest and smallest values, then just assemble a list from min to max
07:21:52 <monkey___> exclude :: [Int]->[Int]
07:21:53 <monkey___> exclude [] = []
07:21:55 <monkey___> exclude (h:t)
07:21:56 <monkey___>   | (head(h:t) > head(tail(h:t))) && (head(tail(h:t)) < head(tail(tail(h:t)))) =
07:21:58 <monkey___> delete ())
07:21:59 <monkey___>   | otherwise = h: exclude t
07:22:01 <monkey___>               is this going somewhere?
07:22:11 <vincenz> what's with all the parens
07:22:13 <monkey___> I didnt finish the delete yet but all the rest?
07:22:21 <vincenz> @paste
07:22:22 <lambdabot> http://paste.lisp.org/new/haskell
07:22:37 <psnl> monkey___: more functions!
07:22:45 <resiak> monkey___: One general piece of information:  head(h:t) -> h by definition of head
07:22:53 <resiak> (similarly, tail (h:t) -> t)
07:23:12 <johnnowak> monkey___: does this do what you want? ... foo xs = [foldr min 0 xs .. foldr max 0 xs]
07:23:23 <johnnowak> Prelude> foo [1, 6, 4, 2, 12, 3]
07:23:23 <johnnowak> [0,1,2,3,4,5,6,7,8,9,10,11,12]
07:24:13 <monkey___> nop
07:24:21 <johnnowak> hm. well then. :)
07:24:34 <johnnowak> off to work
07:25:23 <dino-> > Data.List.sort [1, 6, 4, 2, 12, 3]
07:25:24 <lambdabot>  [1,2,3,4,6,12]
07:26:30 <vincenz> > sort [1,6,4,2,12,3]
07:26:32 <lambdabot>  [1,2,3,4,6,12]
07:26:45 <monkey___> its not a list sort
07:27:09 <dino-> :(
07:27:25 <vincenz> btw
07:27:29 <vincenz> what you wrote makes no sense
07:27:32 <dino-> Apologies, I just stepped in here without paying attention to what came before.
07:27:33 <vincenz> if you do
07:27:36 <vincenz> exclude (h:t)
07:27:39 <vincenz> no need to use had and tail
07:27:41 <int-e> > sort [[2,3], [1,4], [3,1], [0,5]]
07:27:42 <vincenz> you alreaady matched em
07:27:43 <lambdabot>  [[0,5],[1,4],[2,3],[3,1]]
07:27:50 <vincenz> h is the head, t is the tail
07:28:38 <vincenz> and that will fail
07:28:42 <vincenz> if your list has exactly 1 element
07:29:04 <vincenz> monkey___: what should happen with a one element list
07:29:27 <monkey___> [1] -> [1]
07:29:51 <vincenz> and with more than two elements?
07:29:58 <vincenz> so you got the empty list correct
07:29:59 <vincenz> that's
07:30:01 <vincenz> exclude [] = []
07:30:05 <monkey___> yep
07:30:09 <vincenz> and now write the case for a single element
07:30:13 <vincenz> that should be simple too
07:30:16 <vincenz> looks almost the same
07:31:07 <monkey___> yes I need to do sth for list with more than 2 intrgers
07:31:23 <vincenz> well write the 1 element case too
07:31:27 <vincenz> it's a separate special case
07:31:47 <monkey___> [1,3,4,2,5,6,7,3,5] -> [1,3,4,5,6,7,5]
07:31:47 <vincenz> exclude [e] = [e]
07:31:58 <vincenz> so
07:32:02 <vincenz> exclude [] = []
07:32:04 <vincenz> exclude [e] = [e]
07:32:12 <vincenz> exclude (a:b:t) = ... do something with the first two elements a nd b
07:33:17 <monkey___> I need to compare and b with the third element
07:33:27 <vincenz> so what happens with a two element list?
07:33:28 <spiffy> Hmmm. I can honestly say I have no idea where the complier is getting its types from for this expression
07:33:37 <spiffy> not my code ;-)
07:33:41 <spiffy> thats for sure
07:33:53 <monkey___> vincenz,it returns the same list
07:34:16 <monkey___> then I need to compare b with the third and the fourth element
07:34:21 <monkey___> and so on
07:34:29 <vincenz> nonono
07:34:30 <vincenz> you mistake me
07:34:42 <vincenz> empty list -> empty list
07:34:45 <vincenz> [e] -> [e]
07:34:47 <vincenz> [a,b] -> ??
07:34:54 <monkey___> [a,b]
07:35:22 <spiffy> The last statement in a 'do' construct must be an expression
07:35:23 <spiffy> return (card : (shuffle' deck'));
07:35:23 <vincenz> ok
07:35:27 <vincenz> so you have three special cases
07:35:31 <spiffy> isnt that an expression?
07:35:31 <vincenz> exclude [a,b] = [a,b]
07:36:57 <monkey___> [1,3,4,2,5,6,7,3,5] -> [1,3,4,5,6,7,5]  how can I make it work in a case like this for example?
07:37:26 <dino-> spiffy: Ok, so shuffle must be evaluating to a list. card is being consed to the front of that, and the whole thing is being placed in some monad?
07:37:39 <spiffy> yup
07:37:41 <vincenz> monkey___: you need to define your algorith recursively
07:37:46 <vincenz> monkey___: I a still not sure what the hell it does
07:38:30 <monkey___> compare 1,3,4  do nothing,compare 3,4,2 do nothing,compare 4,2,5 erase 2(smallest of three) and so on
07:38:55 <vincenz> is it recursive?
07:38:56 <vincenz> I mean
07:38:58 <vincenz> what if you have
07:39:07 <vincenz> [1,2,4,2,3,5]
07:39:13 <vincenz> -> [1,2,4,3,5]
07:39:14 <vincenz> or
07:39:18 <vincenz> -> [1,2,4,5]
07:39:19 <dino-> monkey___: Ah, maybe you need to pattern match (a:b:c:xs)
07:39:24 <vincenz> dino-: easy now
07:39:26 <spiffy> dino-: so what im doing seems right to me
07:39:34 <monkey___> [1,2,4,5]
07:40:03 <vincenz> so going back, you know the special cases for
07:40:08 <vincenz> [], [e], [a,b]
07:40:15 <vincenz> these are separate definitions
07:40:19 <vincenz> the last case, as dino- pointed out would be
07:40:21 <monkey___> yes
07:40:25 <vincenz> exclude (a:b:c:t) = do something
07:40:48 <vincenz> exclude (a:b:c:t) = if a > b && b < c then ... else ...
07:41:54 <monkey___> ..then delete b
07:41:57 <vincenz> no
07:42:00 <vincenz> you don't delete
07:42:07 <vincenz> you return a list without it
07:42:09 <vincenz> simple example
07:42:14 <vincenz> exclude (a:b:c:t) = a:c:t
07:42:19 <vincenz> that returns a list without b
07:42:28 <vincenz> of course, this is not exactly what you want
07:43:19 <vincenz> so as you said
07:43:23 <vincenz> if b is smaller, then continue without be
07:43:26 <sjanssen> @karma+ bringert -- documenting Control.Parallel.Strategies
07:43:27 <lambdabot> bringert's karma raised to 16.
07:44:13 <vincenz> exclude (a:b:c:t) = if a > b && b < c then (..do something with a:c:t) else (..continue with 2nd, 3rd and remainder)
07:44:30 <vincenz> monkey___: have you ever looked at recursion?
07:45:14 <dino-> spiffy: So, what's happening? You put that return... at the end of your do block and it barfs?
07:45:14 <monkey___> yes if you mean like fibonacci
07:45:25 <spiffy> dino-: yup
07:45:30 <monkey___> but not in lists and not in haskell
07:45:42 <dino-> spiffy: I wonder if it does not care for the ;
07:46:33 <vincenz> monkey___: I will give you the else clause
07:46:46 <vincenz> exclude (a:b:c:t) = if a > b && b < c then (..do something with a:c:t) else a:exclude(b:c:t)
07:47:07 <vincenz> the else clause says: return a list with as head "a" and the remainder, whatever comes out from doing exclude on the rst
07:47:57 <spiffy> still nothing
07:48:01 <vincenz> monkey___: is that obvious?
07:48:17 <monkey___> yes it is
07:48:20 <vincenz> ok
07:48:28 <vincenz> so now what remains is the "then" clause
07:48:33 <vincenz> it's pretty much fully filled in
07:49:08 <spiffy> shuffle' deck | length deck == 1 = do return []
07:49:12 <spiffy> compiles fine
07:50:06 <vincenz> @paste
07:50:06 <lambdabot> http://paste.lisp.org/new/haskell
07:50:11 <Igloo> You'd be better off writing that as   shuffle' [_] = return []   as length is O(n) but that pattern match is O(1)
07:50:20 <vincenz> monkey___: ?
07:50:32 <monkey___> yep ,Im thinking
07:50:45 <Igloo> Is writing an isSingleton function that does such a pattern match if you'd prefer to use a guard there
07:52:50 <spiffy> Well, that code was ripped out of somewhere else. Good point about length being O(n) vs pattern matching
07:53:01 <spiffy> i think i do the same thing a few other places
07:53:26 <Lemmih> spiffy: Is the code online?
07:53:56 <monkey___> do I have to use delete? I think sth like then exclude (a:c:t) : exclude (a:c:t)  ???
07:54:01 <vincenz> no
07:54:06 <vincenz> that would make a list
07:54:19 <spiffy> hmmm how do you pattern match a one element list? [a]?
07:54:19 <vincenz> with as head a list
07:54:22 <vincenz> and as tail what exclude returns
07:54:26 <vincenz> spiffy: yep
07:54:35 <vincenz> spiffy: or (a:[])
07:54:40 <vincenz> [a] is sugar for that really
07:54:52 <Lemmih> spiffy: Yes, or as Igloo said, [_].
07:55:08 <lisppaste2> vincenz pasted "monkey__'s solution" at http://paste.lisp.org/display/29825
07:55:15 <spiffy> so deck@[_] would be good too?
07:55:23 <vincenz> spiffy: might need a () around that, not sure
07:55:32 <vincenz> deck@([_])
07:57:43 <spiffy> ?paste
07:57:43 <lambdabot> http://paste.lisp.org/new/haskell
07:59:09 <Lemmih> vincenz: Is it wise to post the (homework) solution for a student who apparently haven't grasped pattern matching or recursion?
07:59:10 <lisppaste2> spiffy pasted "Point of no return?" at http://paste.lisp.org/display/29826
07:59:16 <monkey___> vincenz thanks a lot it worked!! I hope it will be a map for the rest of my exersises!!
07:59:33 <monkey___> :)
07:59:51 <wolverian> http://www.jmlg.org/guides/how_to_proof_a_theorem.htm great advice!
07:59:55 <lambdabot> Title: Prove a Theorem, http://tinyurl.com/yha63b
08:01:29 <spiffy> anyone on the problem(s) with that code?
08:01:31 <vincenz> Lemmih: Well if you have walked him through it
08:01:33 <Binkley> hee, that site is *full* of good advice
08:01:46 <vincenz> Lemmih: point taken
08:01:54 <vincenz> Binkley: :D
08:01:57 <vincenz> I love 2
08:02:39 <Binkley> "how to get a paper rejected" - "use microsoft word"
08:02:40 <vincenz> There's something similar I once read on how to be a good research
08:02:51 <wolverian> read the other links in the sidebar too
08:02:55 <wolverian> s/links/sections/
08:02:58 <vincenz> Binkley: Is it even possible to use word? Given the templates most conferences give?
08:02:59 <Binkley> david patterson's "how to be a bad researcher" talk, you mean?
08:03:04 <wolverian> (I somehow initially missed them.)
08:03:06 <Binkley> vincenz: I'm sure if you're dedicated enough, you can
08:03:08 <vincenz> Binkley: yeah that one
08:03:20 <Binkley> yeah, I've heard that talk in person. it's pretty good :-)
08:03:28 <vincenz> Binkley: heh, I even have problem with latex's schizoness, I don't want to imagine word
08:03:36 <Binkley> srsly
08:03:37 <vincenz> Like when you use \vspace*{-xcm}
08:03:41 <pkhuong> vincenz: depends on the conference. Social sciences seem to like word.
08:03:46 <Binkley> negative vspace is my secret lover
08:03:54 <nick8325> spiffy: not a layout problem, is it?
08:03:54 <araujo> morning
08:03:56 <vincenz> Binkley: that and reducing all references to at most two lines :P
08:04:01 <Binkley> heh
08:04:18 <Binkley> the *real* thing I learned from my advisor when I wrote my undergrad thesis was stupid latex tricks to make things take up less space
08:04:25 <vincenz> X et al. "Memory Opt. for Emb. Sys."
08:04:29 <Binkley> haha
08:04:36 <Binkley> and of course never use people's first names when you cite them
08:04:40 <vincenz> DAC'07
08:04:44 <monkey___> vincenz I m sorry do be an annoyance but can you give me an email so I can contact you?Are you always on #haskell?
08:04:57 <vincenz> monkey___: I tend to be on here often, but I am certain many can help
08:05:16 <vincenz> Binkley: no, nor the second author
08:05:29 <Binkley> vincenz: yeah. makes you want to change your last name to Aaronson :-)
08:05:30 <monkey___> ok thanx a lot bye
08:05:32 <vincenz> K. Chevalier et al would b  how I'd cite you
08:05:39 <vincenz> Binkley: erm, no?
08:05:47 <vincenz> Binkley: we don't place authors in alphabetical order
08:05:51 <Binkley> in fact, the way that I discovered that I was cited somewhere that I didn't know about was googling my name in that form
08:06:06 <Binkley> I google myself all the time but it took me a while to think to google for firstinitial+lastname
08:06:06 <vincenz> oh, for me it's easier, my name is rather rare, but I haven't been cited yet
08:06:15 <Binkley> well, the hilarious thing is the paper they cited isn't published
08:06:18 <vincenz> as soon as I do -"le petit poucet"
08:06:18 <Binkley> not even as a tech report
08:06:27 <Binkley> and it's a crappy class paper that i would prefer never see the light of day
08:07:00 <vincenz> Binkley: so you people write authors alphabetically?
08:07:01 <Binkley> moreover, the only person who still has a copy of the paper isn't responding to email :-D
08:07:21 <Binkley> vincenz: I've usually seen it that way. I haven't written a paper yet, except the questionable one I was just talking about, so I have no experience in the matter
08:07:26 <vincenz> ah
08:07:30 <vincenz> Well here it is
08:07:39 <vincenz> first author : guy that does the most work/ writes the pape
08:07:39 <Binkley> I just get the impression that most CS papers use alphabetical author listing
08:07:50 <vincenz> second, ... : people that collaborated
08:07:51 <Binkley> or else that the first author is the faculty member with the grant
08:07:52 <vincenz> last: advisor
08:07:54 <Binkley> and grad students come last
08:08:01 <vincenz> oh here grad students come first
08:08:01 <Binkley> heh, i've heard it said as the other way around
08:08:08 <vincenz> basically we work based on amount of work put in
08:08:25 <Binkley> at Berkeley they use the "amount of money put in" metric, I guess :-)
08:08:29 <vincenz> :
08:08:30 <vincenz> :D
08:08:45 <vincenz> Binkley: phd student?
08:08:53 <Binkley> vincenz: I was. right now I'm not in school
08:09:00 <Binkley> but hoping to start a PhD again next fall
08:09:07 <vincenz> Oh, right
08:09:17 <vincenz> I heard you lived in england (you had lunch with flippa)
08:09:20 <Binkley> yeah
08:09:24 <Binkley> well, a little more than lunch
08:09:32 <Binkley> I'm in England for another six weeks
08:09:32 <vincenz> tmi?
08:09:40 <Binkley> yeah, maybe this should go to #haskell-blah :-)
08:09:44 * earthy thought exactly the same that vincenz did. ;)
08:09:53 <earthy> a 'hacking session'? :)
08:09:57 <Binkley> or #sex-lives-of-haskellers
08:10:01 <vincenz> LOL
08:10:06 <Binkley> I guess that channel wouldn't be very busy in general
08:10:09 <vincenz> yeap, I was right on the call about tmi
08:10:16 <vincenz> you can join #oasis
08:10:24 <Binkley> #oasis?
08:10:34 <vincenz> it's the #non-programming-language-specific-programming-language-discussion-channel
08:10:38 <Binkley> heh
08:10:45 <Binkley> that's a lot of hyphens#
08:10:59 <vincenz> yeah, hence #oasis
08:11:06 <vincenz> it sort of grew
08:11:21 <vincenz> originally it waas our icfp-contest channel, but then all icfp contestants joined that channel
08:11:25 <Binkley> heh
08:11:26 <vincenz> and since then people have remained
08:11:35 <glguy> hmm, seems like most people in #oasis are in #haskell (-:
08:11:42 <vincenz> Yeah
08:11:44 <pkhuong> glguy: it used not to be so.
08:11:52 <vincenz> no, pkhuong is an emigrant
08:12:02 <glguy> see, you are in #oasis and I didn't even know you were in #haskell! :)
08:12:18 <vincenz> Binkley: what topic do you research in
08:12:30 <Binkley> vincenz: right now I'm hacking GHC's strictness analyzer
08:12:37 <vincenz> Binkley: ah neat
08:12:46 <vincenz> Binkley: is there some good documentation on ghc?
08:12:54 <Binkley> vincenz: heh, is that a serious question?
08:12:57 <vincenz> erm, yes
08:13:11 <Binkley> http://hackage.haskell.org/trac/ghc/wiki/Commentary if you want docs on internals
08:13:14 <Binkley> very incomplete, though
08:13:15 <lambdabot> Title: Commentary - GHC - Trac, http://tinyurl.com/ocuyo
08:13:19 * vincenz nods
08:13:20 <Binkley> I assume you already know where the manual is :-)
08:13:22 <vincenz> see at some point
08:13:29 <vincenz> I felt like implementing class aliases that someone suggested
08:13:34 <vincenz> but that's a very deep change
08:13:39 <vincenz> (cause it would require changes at all levels)
08:13:54 <Binkley> well, the best documentation is to post on the mailing list and wait for replies from one or more simons :-)
08:13:57 <vincenz> it'd probably be easy, but you need to change stuff at many places
08:13:58 <Binkley> or, I guess these days, ask here
08:14:05 <Binkley> but back in MY day we didn't have the IRC channel
08:14:10 <Binkley> (when dinosaurs roamed the earth, etc.)
08:14:11 <vincenz> Binkley: how old are you?
08:14:13 <Binkley> 25
08:14:19 <vincenz> erm
08:14:21 <vincenz> you'er younger than me
08:14:23 <Binkley> heh
08:14:34 <Binkley> well, I've been working on haskell stuff for six years now. which is a little disturbing
08:14:56 <earthy> why?
08:14:57 <vincenz> Binkley: other parts of this conversation mentioned earlier could be labelled more disturbing in this context
08:15:04 <Binkley> hrm
08:15:07 <vincenz> :P
08:15:27 <earthy> haskell is fun. it's been around since the early 1990's at least. why is doing it since 2000 disturbing?
08:15:31 <Binkley> I'd think it would only disturbing if I was more than 8 years younger
08:15:38 <vincenz> Binkley: I was teasing
08:15:46 <Binkley> earthy: well, it's not disturbing in and of itself. it's just alarming for me to think about how long I've been working on this stuff :-)
08:16:05 <spiffy> heh im at just over a month :-)
08:16:12 <Binkley> and how few papers I've published
08:16:19 <vincenz> papers are fluff
08:16:21 <Binkley> heh
08:16:25 <Binkley> tell that to a tenure committee
08:16:30 <vincenz> point taken
08:16:35 <vincenz> though I wouldn't mind not having to publish papers
08:16:36 <Binkley> not that that's my problem yet
08:16:43 <Philippa> Binkley: bet you dinner sometime that you get a paper published before me? :-)
08:16:46 <vincenz> I'll probably switch to a more implementational job post phd
08:16:53 <saccade> papers are a lot easier than going around and convincing people of things in person one by one
08:16:54 <Binkley> Philippa: that's a really easy bet for me :-)
08:17:03 <vincenz> Binkley: oh, another good reason to join, Philippa is there too
08:17:07 <Binkley> heh
08:17:15 <saccade> if you have something you want to tell people, they can be pretty useful
08:17:36 <Binkley> Philippa: given that I'm kind of expected to publish a paper at the end of my internship, and all, and I assume you don't have plans to publish something in the *immediate* future? :-)
08:17:52 <Philippa> right, free dinner for me :-)
08:18:01 <Binkley> wait, I didn't understand the bet :P
08:18:02 <Philippa> but I'd happily make the same bet about the one afterwards
08:18:04 <vincenz> Binkley: I guess you're like me and focus too much on the implementational details and then are unable to write a paper
08:18:09 <Binkley> vincenz: exactly
08:18:15 <vincenz> yeah I know the feeling :/
08:18:23 <Binkley> I'm too preoccupied with actually having working code :P
08:18:25 * saccade winces in recognition
08:18:26 <vincenz> hence me wanting to switch to something more implementational post phd
08:18:32 <vincenz> I wouldn't mind going to MSR actually
08:18:34 <Binkley> eh, well, industry is overrated
08:18:42 <vincenz> well not industry of course
08:18:44 <Binkley> I'd happily come back to MSR after I finished my PhD if they offered me a job, though
08:18:46 <vincenz> still in a research context
08:18:57 <Binkley> it's a pretty sweet deal
08:19:04 <Binkley> and I mean literally sweet. free chocolate.
08:19:09 <vincenz> I'm afraid they wouldn't take me tho, my context is different
08:19:22 <Binkley> Eh, well, worry about finishing grad school first, then think about it :-)
08:19:28 <vincenz> true :)
08:19:39 <Binkley> and for me, it's "worry about getting *into* grad school first"
08:19:48 <vincenz> but I want to shift more towards FPLs and compilers than I am currently situated
08:19:51 <vincenz> post phd
08:19:54 <pejo> Binkley, any way to quantify the improvement of the strictness analysis?
08:19:55 <Binkley> where are you situated now?
08:20:07 <vincenz> design automation
08:20:09 <Binkley> pejo: sure, look at time/allocation numbers for benchmark programs and see what the percentage improvement is
08:20:16 <roconnor> does YCR2JS support big integers?
08:20:19 <vincenz> optimization of multimedia software for embedded software
08:20:20 <Binkley> pejo: probably there are more precise things you could do if you thought about it. I haven't yet.
08:20:25 <vincenz> but platform independently
08:20:26 <Binkley> vincenz: ah. I used to work for an EDA company
08:20:28 <Binkley> it sucked :P
08:20:32 <Binkley> but that was the company's fault
08:20:38 <vincenz> which one?
08:20:41 <Binkley> averant
08:20:46 <dino-> spiffy: Yeah, I bet it is layout. When I reshaped it so all those lines under the do are clearly right of the do, it got past that error.
08:20:51 <pejo> Binkley, heh. Ok, rephrase: do you have these numbers handy, or too soon yet?
08:20:52 <vincenz> notice that I'm not working on hardware
08:20:59 <vincenz> Binkley: but join #oasis a bit too OT here
08:21:00 <Binkley> pejo: too soon to tell, yeah
08:31:05 <ventonegro> @where hsql
08:31:06 <lambdabot> http://htoolkit.sourceforge.net
08:31:34 <ventonegro> what's the other db lib?
08:31:53 <oj> hi
08:31:57 <oj> helo
08:32:40 <beelsebob> @hoogle pow
08:32:41 <lambdabot> No matches found
08:32:49 <beelsebob> @hoogle Double -> Double -> Double
08:32:49 <lambdabot> No matches, try a more general search
08:32:59 <beelsebob> @hoogle Num a => a -> a -> a
08:33:01 <lambdabot> Prelude.(*) :: Num a => a -> a -> a
08:33:01 <lambdabot> Prelude.(+) :: Num a => a -> a -> a
08:33:01 <lambdabot> Prelude.(-) :: Num a => a -> a -> a
08:33:29 <ventonegro> @where hdbc
08:33:29 <lambdabot> http://quux.org/devel/hdbc
08:34:01 <beelsebob> gyah... is there no version of (^) that can deal with floating point powers?
08:34:08 <ventonegro> **
08:34:35 <beelsebob> thanks
08:34:49 <ventonegro> beelsebob, np
08:45:18 <dino-> >type (**)
08:45:26 <vincenz> @type (**)
08:45:27 <lambdabot> forall a. (Floating a) => a -> a -> a
08:47:23 <dino-> Huh, I did not know that both (^) and (**) existed.
08:47:52 <vincenz> @type (^)
08:47:54 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:48:01 <vincenz> ah
08:48:05 <vincenz> (^) = exact
08:49:36 <roconnor> @type (^^)
08:49:38 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
08:49:50 <roconnor> there are three
09:10:54 <hyrax42> ?fptools Data.List
09:10:54 <lambdabot> http://darcs.haskell.org/packagesbase/Data/List.hs
09:11:41 <hyrax42> ?fptools Control.Monad
09:11:42 <lambdabot> http://darcs.haskell.org/packagesbase/Control/Monad.hs
09:11:48 <hyrax42> ?seen dons
09:11:48 <lambdabot> dons is in #haskell-overflow, #haskell and #ghc. I last heard dons speak 3h 18m 22s ago.
09:12:58 <hyrax42> ?source Control.Monad
09:12:59 <lambdabot> http://darcs.haskell.org/packagesbase/Control/Monad.hs
09:13:26 <hyrax42> ?tell dons there's a bug with fptools/source in lambdabot; missing '/' in url
09:13:26 <lambdabot> Consider it noted.
09:31:32 <therp> wow, minion pro looks much better for my papers than my old fetish font computer modern
09:31:57 <integral> heretic!
09:32:16 <Binkley> mmm font fetishes
09:32:24 <therp> and minion pro comes with acrobat reader. I never thought that I would find this proprietary thing useful for anything than blocking my cpu
09:33:19 <integral> ouch, individual fonts are expensive
09:33:24 <therp> and the MinionPro package for latex is just great.
09:34:13 <therp> integral: definately, 200$ for Minion Pro is no bargain. but when it's bunded with acroread, I don't think this purchase is necessary (unless you need all the companion fonts)
09:34:34 <integral> the data files may be bundled, but a licence?
09:34:54 <liyang> license schmicense
09:35:28 <therp> I don't think you are allowed to embed them in pdfs.
09:35:46 <integral> ah.
09:37:22 <therp> not doing that makes your PDFs adobe reader only but.. men they look so much better! I know, it's heretic :)
09:38:36 <glguy> Is there any noticable difference between (StateT a [b]) and ListT b (State a) ?
09:39:01 <glguy> in effect, not necessarily in what needs to be lifted
09:39:26 <mnislaih> glguy certainly there is
09:39:37 <mnislaih> in the type of the final result
09:39:48 <glguy> ok
09:39:54 <glguy> one returns a list of resutls
09:39:56 <mnislaih> do you want a list of possible final states, or there is a single final state ?
09:40:16 <glguy> right right, I don't know why I was thinking of that
09:40:24 <mnislaih> and it will be make a difference for backtracking too
09:41:47 <glguy> in the StateT version, the changes to state are "local" right?
09:42:11 <glguy> and in the ListT version a single state is wound through all of the branches
09:42:20 <cjeris> therp: minion pro is pretty, but papers were clearly intended to be written in CMConcrete + Euler math fonts :)
09:43:36 <therp> cjeris: what's CMConrete? nothing useful on google
09:44:16 <mnislaih> glguy: that sounds right but I'm a bit confused too :)
09:44:32 <cjeris> therp: sorry, that's not the real name... the variants of CM used in Concrete Mathematics.  ccr10 etc.  \usepackage{beton}, \usepackage{euler}
09:46:12 <cjeris> the only problem with ccr is that it doesn't have a bold variant, so the default is to use cmbx; I think that's ugly so I follow a suggestion found on the web some huge long time ago and substitute cmssdc
09:48:22 <psicho> hello all
09:48:36 <psicho> im back again cuz i realy cant make it :(((
09:49:07 <therp> cjeris: hm, agreed, the font doesn't look bad, but isn't wasting too much space? compared to Minion my 10 pages paper got a whole page longer.
09:51:14 <psicho> could somebody please please help me out with this little code: http://pastebin.com/823413  , i need to change it so could generate a mass discount for products in the bill
09:56:02 <cjeris> therp: ccr is sparser than some other fonts, yes.  i rather like that trait.
09:58:08 <psicho> is there a tool that can convert my C code to haskell code ? :)
10:00:33 <yaarg> oh this wicked cognitive thing
10:00:36 <yaarg> called "teh brain"
10:00:49 <osfameron> ooo!  I need one of those!
10:01:12 <Binkley> psicho: I think I answered that question last week, with "GHC" :-)
10:01:19 <Binkley> oh wait
10:01:22 <Binkley> you mean the other way around
10:01:23 <Binkley> NM
10:01:32 <psicho> well i wasnt here a week ago
10:01:45 <Binkley> no, I misread your question and thought you meant converting Haskell to C
10:01:49 <SyntaxNinja> I don't think C code would make for very pretty Haskell code.
10:01:59 <liyang> psicho: ask more specific questions; this is evidently coursework that you should already have been given enough information to do.
10:02:08 <Binkley> SyntaxNinja: sounds like a challenge to me :-)
10:02:09 <xerox> there is Language.C, then you need "some" transformations... :)
10:02:20 <psicho> i dont care about how pretty it would be
10:02:21 <SyntaxNinja> xerox: heh
10:02:33 <xerox> hiya SyntaxNinja
10:02:41 <SyntaxNinja> psicho: then why bother?
10:02:44 <SyntaxNinja> how's it going, xerox
10:03:32 <bringert> psicho: there is no tool, but you could write one. you can make pretty direct translations including pointer arithmetic etc
10:03:49 <xerox> SyntaxNinja: we're going to have the first exams ever the day after tomorrow and the next two days, so, at the university, people go crazy all around and ask for advices, do exercise, make my head explode
10:03:53 <Binkley> just use the hell out of unsafeCoerce # and unsafePerformIO
10:03:54 <bringert> it won't be good Haskell code, but GHC would compile it.
10:03:54 <xerox> ...but it's alright :)
10:04:01 <Binkley> that should make for a pretty good C-to-Haskell translator :-)
10:04:16 <psicho> SyntaxNinja because its realy looks like i have no other options , i have to modifi this code: http://pastebin.com/823413 so it would be able to generate a mass discount for the products on the bill, but because im totaly lame with haskell i cant do it :(
10:04:18 <SyntaxNinja> xerox: sounds like fun :)
10:04:55 <Binkley> psicho: the reason we're not answering is because this sounds like a homework problem
10:05:18 <SyntaxNinja> Binkley: are you kidding? that's production-quality haskell ;)
10:05:23 <liyang> psicho: who's your lecturer and why are they doing such a terrible job?
10:05:23 <SyntaxNinja> all haskell is less than 100 lines.
10:05:28 <xerox> SyntaxNinja: mathematicians are crazy. today one 2nd-year guy I just met runs towards me, takes my pen, writes down in the middle of my notebook (on which I was working on): "8211^7089" and tells me "what are the last three digits of the expansion of that power?"
10:05:45 <Binkley> lol
10:05:49 <merus> mathematicians are only as crazy as we want to be :P
10:05:51 <bringert> psicho: so you want to write the C code and translate to Haskell, because you know C but not Haskell? Or is there some hugs existing C program that you need to run?
10:05:55 <SyntaxNinja> xerox: heh. did you tell him "hang on! let me program my palm pilot in Haskell!"
10:05:58 <psicho> Binkley: you are 110% right, but the problem is they did not teach us how to code with haskell
10:06:06 <bringert> why does it have to be in Haskell then?
10:06:09 <Binkley> psicho: complain to your instructor(s) then
10:06:21 <vincenz> psicho: what about this: code it in a functional form
10:06:25 <vincenz> and we'll help with syntax
10:06:25 <SyntaxNinja> psicho: there's no such tool, and if there were, your instructor would never accept its output.
10:06:25 <xerox> SyntaxNinja: i'm going to need one of those :)  ...or try to get into _their_ game!
10:06:59 <SyntaxNinja> xerox: nah, programming is better than math
10:07:17 <bringert> psicho: how would you write a C function to handle a Haskell list?
10:07:28 <bringert> say map
10:07:35 <psicho> bringert : it would be a piece of cake to code this stuff in C , but its hell on earth for me to code it in Haskell
10:07:40 <xerox> SyntaxNinja: some people good at math there are amusing...
10:07:54 <bringert> psicho: what class is this for?
10:07:55 <osfameron> presumably you could compile haskell to a C backend?
10:08:08 <bringert> psicho: what's the actual task that you are given?
10:08:15 <Binkley> osfameron: that's what GHC does; that doesn't tell you how to compile C to Haskell, though
10:08:51 <bringert> psicho: why not just learn Haskell, it's not that hard. Escpecially not for the simple kinds of problems that this seems to be about.
10:09:00 <liyang> psicho: the question is this -- do you want to learn Haskell, or just find a way to cheat your way past your examiners?
10:09:14 <liyang> We can help with the former.
10:09:16 <psicho> bringert: to modifie this code: http://pastebin.com/823413 ,so it would be able to genereate a mass discount for products on the bill
10:09:52 <xerox> SyntaxNinja: i'm not sure, it feels quite different to solve math or to compute something, i like both.
10:09:53 <SyntaxNinja> psicho: bringert is totally right. it's time to buckle down and learn Haskell. it will take you less time than trying to find some lame solution that your teacher won't accept.  If you are truly good at C (as just about everyone in here also is) then we can help you learn to map your understanding of C to Haskell.
10:10:12 <bringert> psicho: the intention is clearly that you should code it in Haskell then. This implies that you are either supposed to already know Haskell, or to learn it.
10:10:17 <psicho> well dont get me wrong, i WANT to learn haskell but i think its imposible to do it within a day, because i have to make this mod till wednesday
10:10:37 <SyntaxNinja> xerox: to me, computer science isn't about computing things, it's about communication.  communicating with your computer, with outside systems, with your coworkers, with the ongoing discussion on the internet.
10:10:43 <SyntaxNinja> psicho: it's totally doable.
10:10:44 <bringert> psicho: is it a short deadline, or did you start too late?
10:10:52 <Lemmih> bringert: Hiya, I'm having trouble with Hope. Got a few minutes?
10:11:00 <Binkley> psicho, an IRC channel is no substitute for having started the assignment on time. Probably everybody here has been a student who procrastinated until the last minute sometimes, but when that happens, you have to suck it up and not get people on IRC to do it for you
10:11:00 <psicho> short deadline
10:11:10 <liyang> started too late. psicho was making the same request a few days ago I seem to remember.
10:11:19 <bringert> Lemmih: sure
10:11:28 <psicho> liyang lol it was yeasterday
10:11:28 <SyntaxNinja> Lemmih: never lose hope!
10:11:34 <SyntaxNinja> (once you get it to compile ;)
10:11:51 <xerox> SyntaxNinja: oh, and mathematics is _full_ of women... concentration was hard the first weeks. cough.
10:12:04 <vincenz> @where yaht
10:12:05 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
10:12:05 <liyang> psicho: you can most certainly learn enough Haskell to do that assignment in a few hours, if you're as good as you claim in C.
10:12:05 <bringert> psicho: so you are saying that your teacher gave you two days to do an assignment in a language you didn't know?
10:12:08 <yaarg> psicho: just take a step back and take the time to read up on haskell
10:12:14 <vincenz> yaht is great
10:12:15 <vincenz> @where yaht
10:12:16 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
10:12:17 <Binkley> mathematics... is full of women...
10:12:19 <Binkley> where is this? :-)
10:12:27 <SyntaxNinja> xerox: sounds great, and terrible.
10:12:27 <xerox> Turin :)
10:12:35 <xerox> (Where Peano studied!)
10:12:35 <yaarg> there's plenty (free) documentation readily available on the internets
10:12:37 <psicho> lol im a lame coder :)
10:12:38 <Lemmih> bringert: I'm using postgresql via hdbc. The installation went fine but the end result is not what I expected.
10:12:43 <Binkley> Huh, I should apply to grad school at Turin ;-)
10:12:44 <Lemmih> bringert: http://blog.catenova.org/
10:12:46 <fabiim> psicho: http://www.haskell.org/~pairwise/intro/section1.html
10:12:49 <lambdabot> Title: Haskell for C Programmers, http://tinyurl.com/8lasw
10:12:50 <psicho> im too stupid for this kind of coding
10:12:59 <merus> Mathematics is totally full of women.
10:12:59 <vincenz> psicho: pity isn't going to get you a solution, however
10:13:13 <bringert> psicho: so, tell me why you deserve to pass the assignment then?
10:13:15 <merus> There's probably only six men in my program, and like thirty women.
10:13:28 <SyntaxNinja> merus: modern dance?
10:13:34 * SyntaxNinja loves modern dance.
10:13:35 <xerox> haha
10:13:37 <merus> SyntaxNinja: Mathematics.
10:13:43 <bringert> Lemmih: is the problem that you can't log in?
10:13:44 <xerox> we can't leave all the mathematics to the women!
10:13:48 <Lemmih> bringert: I tried to create a user but the database is still completely empty (every table is empty).
10:13:50 <merus> True, they're mostly math education... >_>;;
10:13:54 <SyntaxNinja> I always wanted to have a party with the modern dance department and the computer science department. I thought it would be so funny.
10:13:57 <Binkley> ?remember xerox we can't leave all the mathematics to the women!
10:13:57 <merus> but still!
10:13:57 <Lemmih> bringert: Yeah.
10:14:17 <psicho> bringert cuz my school fucking suxs ass ,they teach us shit ,and want from us everything
10:14:34 <psicho> its like working for free lol
10:14:35 <SyntaxNinja> xerox: nor can we leave the women to mathematics.
10:14:38 <Botje> less swearing please :(
10:14:44 <xerox> SyntaxNinja: AH.
10:14:47 <yaarg> omg i'm so offended
10:14:50 <Binkley> lock up your daughters, mathematics is on the prowl!
10:15:04 <bringert> Lemmih: I think lispy had something similar. Is this running on a 64-bit machine by any chance?
10:15:07 <Botje> Binkley: we need reasons for that now?!
10:15:11 <Binkley> heh
10:15:21 <pkhuong> psicho: i tend to think you're projecting re sucking ass.
10:15:25 <SyntaxNinja> math is dangerous
10:15:30 <yaarg> math is <3
10:15:38 <Botje> MATH IS WHAT BOMBED NAGASAKI
10:15:42 <Binkley> MATH KILLED MY DOG
10:15:44 <arcatan> math is delicious!
10:15:53 * SyntaxNinja hides
10:16:02 <Botje> math kills more people than cola ever did.
10:16:04 <psicho> anyway is there a standard func that will count how many times i have for example "1" in a list ?
10:16:06 * xerox hides behind SyntaxNinja 
10:16:08 * merus <3 math
10:16:09 <roconnor> I need a google math search
10:16:16 <bringert> Lemmih: is there anything in the sessions table?
10:16:23 <xerox> roconnor: planetmath?
10:16:30 <Binkley> wikipedia?
10:16:30 <roconnor> F(a+b) -> F(a)*F(b)
10:16:34 * Binkley hides
10:16:35 <Botje> psicho: length $ filter (==1) list ?
10:16:36 <roconnor> there must be a name for this
10:16:38 <Lemmih> bringert: No, nothing.
10:16:54 <xerox> roconnor: as in, there must be a google subdomain for that.
10:17:05 <liyang> psicho: don't think so, but you could take everything out of that list that's not 1, and count how long the remaining list is.
10:17:09 <bringert> Lemmih: is it a 64-bit machine?
10:17:11 <Binkley> math.google.com gets nothing
10:17:13 <yaarg> site:wikipedia.org then
10:17:15 <liyang> psicho: like what Botje wrote. :)
10:17:15 <yaarg> :D
10:17:23 <roconnor> as in I want to search for the expression F (a+b) -> F(a)*F(b)
10:17:23 * liyang waves at yaarg 
10:17:24 <psicho> oh my god
10:17:35 <roconnor> but maybe people use x and y instead of a and b
10:17:39 <Lemmih> bringert: I don't think so. It's an SMP box, though.
10:17:39 <arcatan> roconnor: like hoogle but for math
10:17:42 * yaarg returns the gesture and tips his hat
10:17:48 <roconnor> or they use latex instead of ->
10:18:17 <psicho> ok i want to ask one final question
10:18:18 <xerox> ..and where do you want to search for that expression?
10:18:19 <liyang> psicho: That's one way to do it. Not necessarily the most efficient way; one can quite easily do better.
10:18:23 <roconnor> is there a catagory theory irc channel?
10:18:33 <xerox> #math, ##logic
10:18:35 <bringert> Lemmih: strange, nothing in the server logs?
10:18:46 <roconnor> dare I try #math?
10:19:09 <yaarg> hey #math is a good channel...
10:19:15 <roconnor> ok
10:19:27 <Lemmih> bringert: The error log is clean.
10:19:35 <xerox> both are very nice channels, we recently revived ##logic
10:19:36 <bringert> Lemmih: did you get the "add a user" thing the first time you went there?
10:19:38 <yaarg> lots of knowledgeble types in there
10:19:43 <xerox> (we as in, some #haskell-ers.)
10:19:58 <psicho> i have this code http://pastebin.com/823413 it was writen by my teacher ,we tested it in the school and it was working 100% ,basicaly it produced i nice formated bill, but now i compiled it at home and it produce some mishmash, anytips why ?
10:20:24 <Lemmih> bringert: Yes. And it re-appears when I restart the server.
10:20:25 <Binkley> psicho, did you use the same compiler at home and at school?
10:20:56 <psicho> WinHugs ,not sure about the version
10:21:03 <psicho> maybe i have a little bit newer
10:21:19 <bringert> Lemmih: ok, that's seriously weird. You get that when there are 0 users in the DB. So it seems to think that there are users until you restart. Ah!
10:21:27 <sjanssen> I don't see any code that should be different across compilers
10:21:29 <bringert> it could be a transaction thing
10:21:30 <Binkley> you used WinHugs both at home and at school?
10:21:36 <Binkley> sjanssen: no, but just trying to narrow things down...
10:21:39 <bringert> maybe the transaction is never commited?
10:21:46 <bringert> and when you restart it rolls back?
10:21:48 <Lemmih> bringert: Ah, that could be it.
10:21:57 <Lemmih> bringert: I'll check it out.
10:22:17 <psicho> yeah we have used WinHugs in school, too
10:22:26 <bringert> Lemminh: try wrapping a 'transaction' call inside dbConnect or something
10:22:38 <Binkley> what kind of output do you get when you run it at home?
10:22:52 <sjanssen> psicho: there might be a problem with those special characters in codeIndex
10:23:01 <bringert> Lemmih: I've never seriously used HaskellDB + HDBC on PostgreSQL
10:23:15 <psicho> hm
10:23:36 <psicho> suxs ass
10:23:42 <sjanssen> psicho: does it work correctly if you change those to regular alphabetic chars?
10:24:12 <psicho> gonna try
10:24:37 <psicho> no
10:25:48 <psicho> how could i change anything if it doesnt even work corectly :(
10:26:40 <psicho> it looks like it takes "\n" az a string not as a new line char
10:27:39 <Philippa> yes
10:27:42 <Philippa> and that's what it is
10:27:44 <Philippa> '\n' is the char
10:27:58 <Philippa> "\n" is '\n':[]
10:28:04 <Philippa> not the same value
10:28:31 <psicho> lol , and it was writen by a teacher
10:29:07 <liyang> '\n' and "\n" have the same distinction as in C...
10:29:17 <psicho> well i know
10:29:24 <Philippa> a teacher who couldn't be arsed to even typecheck their own code? Nice
10:29:32 <liyang> Philippa: it happens. :-/
10:29:43 <Philippa> yeah, I know
10:37:17 <dino-> ?paste
10:37:18 <lambdabot> http://paste.lisp.org/new/haskell
10:38:02 <lisppaste2> dino- pasted "join for tree" at http://paste.lisp.org/display/29836
10:38:50 <dino-> I was having trouble getting what the idea of join (as in with concat for lists) would mean for the tree type in _Monads as containers_
10:39:07 <dino-> Can someone look at that code in the paste?
10:39:51 <dino-> Bah, indenting got screwed.
10:41:17 <psicho> if i have 2 databases how could i comaper them ?
10:42:06 <lisppaste2> dino- annotated #29836 with "cleaned up formatting" at http://paste.lisp.org/display/29836#1
10:42:32 <roconnor> dino-: join for trees, should take a (Tree (Tree a)) and turn all the (Leaf tree) into tree.
10:43:17 <psicho> because i have created a database for the discount and basicaly what i need to do is to chcek how many times one product is on the bill and after that look up in the discountdatabe how big discount it will get, but i have no idea how to do it :((
10:43:19 <dino-> Then, I think yay, my join: join :: Tree (Tree a) -> Tree a
10:43:28 <Lemmih> bringert: Yeah, committing really helped (: I'm surprised this didn't bite you before.
10:43:29 <roconnor> yes
10:43:40 <roconnor> dino-: yes, so join (Leaf x) = x
10:44:05 <dino-> roconnor: mm, that one doesn't work.
10:44:08 <dino-> :(
10:44:18 <Lemmih> bringert: I still have problems logging in.
10:44:25 <roconnor> dino-: in what way does it not work?
10:45:11 <dino-> My code looks like: join (Leaf (Leaf a)) = Leaf a
10:45:40 <roconnor> dino-: yes, that is an instance of join (Leaf x) = x
10:45:50 <roconnor> for x = (Leaf a)
10:46:20 <dino-> Ok, I tried join (Leaf 1)
10:46:40 <dino-> The contained data has to be the same type (Tree a), or we have mismatch with the containers.
10:46:44 <dino-> I get it.
10:46:58 <Cale> hello
10:47:11 <Cale> cool, someone is doing my exercise :)
10:47:28 <dino-> Cale: It's been very helpful.
10:47:50 <Cale> I thought it might :)
10:48:32 <dino-> Cale: One thing, in your example instance of list, you have type declarations for return and (>>=) included in the instance..
10:48:48 <Cale> yeah, I know :)
10:48:50 <dino-> Not being very clear on the instancing syntax, I tried to put those in my own.
10:49:04 <Cale> You're not actually allowed to have them, which is a bit of a shame.
10:49:10 <dino-> And was puzzled by the error messages for a while.
10:49:14 <Cale> I should perhaps comment them out.
10:51:00 <dino-> roconnor: Thank you
10:51:23 <dino-> Cale: And thanks for the document. It's helping in the ongoing struggle to get this stuff.
10:52:59 <dylan> lispy> you around?
10:54:02 <Cale> dino-: You're quite welcome -- let me know if you have any questions.
10:55:07 <Lemmih> bringert: Poke me when you get around.
10:55:09 <bringert> Lemmih: different DBs and drivers use transactions differently. I guess noone has used your particular combination.
10:55:17 <bringert> Lemmih: Now you show up in the DB anyway?
10:55:41 <bringert> Lemmih: Do you get a session with the userid set in the sessions table?
10:55:52 <bringert> is that the same as you get in your cookie?
10:56:14 <dino-> I think actually my implemention could be borken if someone tried a join (Leaf (Branch ...))  :/
10:56:27 <bringert> Lemmih: are there duplicate session IDs in the sessions table? (this is a 64/32-bit symptom)
10:57:06 <dino-> Interesting that I got no incomplete pattern error.
10:58:21 <roconnor> dino-: try -Wall
10:58:29 <roconnor> incomplete patterns are not an error
10:58:42 <dino-> warnings, ah
10:59:39 <dino-> time for a meeting
11:03:11 <psicho> i hate haskell
11:03:24 <xerox> he hates you
11:03:53 <psicho> yeah thats right
11:04:00 <xerox> can we help?
11:04:28 * mwc summons the wraith of Haskell Curry
11:06:01 <psicho> xeorx: if u could tell me how could i comapare to databases
11:06:30 <xerox> you don't compare to databases at all
11:07:31 <bringert> :-)
11:07:39 <scodil> dcoutts: you there?
11:07:50 <bringert> psicho: could you be more specific?
11:08:00 <dcoutts_> scodil, aye
11:08:32 <mwc> psicho, the major problem with trying to troll in this channel is that a) the folks here are too helpful and b) too nice.
11:08:41 <scodil> how much work, do you reckon, to bind another glib-based library using the tools you've got for gtk2hs? specifically, the lib gts
11:09:08 <dcoutts_> scodil, what is gts ?
11:09:16 <scodil> gnu triangulated surfaces library
11:09:20 <scodil> 3d meshes
11:09:22 <dcoutts_> scodil, it's certainly worth a go, it should be easier than starting from scratch
11:09:34 <dcoutts_> you may need to tweak the code generator for best results
11:10:05 <scodil> i don't think it relies too much on glib, mostly lots of gslists and the object model for polymorphic functions
11:10:32 <ventonegro> scodil, sorry for jumping in like this
11:10:35 <scodil> thing is, i haven't used glib much, so i don't have a sense of what goes into it
11:10:39 <ventonegro> scodil, r u using haskell for 3d meshes?
11:10:48 <scodil> i'd like to, sure
11:11:06 <ventonegro> scodil, hmm. me too
11:11:29 <ventonegro> i was asking the other day about problems with large datasets
11:11:54 <scodil> do you store your meshes as haskell data types? or do you interface with c?
11:12:08 <ventonegro> scodil, i'm still thinking about the problem :-)
11:12:24 <scodil> hah. yeah i've been thinking about it ever since i learned haskell
11:12:27 <ventonegro> i have not started coding yet
11:12:35 <scodil> pure haskell meshes seem like a lost cause
11:12:42 <psicho> well here u can see http://pastebin.com/823481 the 2 databases each have the same barcodes so i have to compare the barcode from the codeIndex database with the barcode in the discountdatabase and if one product is n-times on the bill produce the discount by looking it up from the discountdatabase
11:12:44 <scodil> or at least, a monumental effort
11:12:48 <ventonegro> scodil, my motivation is adaptive mesh generation
11:12:59 <scodil> gts has really nice LOD functions
11:13:04 <scodil> progressive meshes and such
11:13:16 <ventonegro> i've seen the screenshots
11:13:38 <scodil> the data structure is not very effecient, lots of linked lists, but that should be it easy to interface with haskell
11:13:57 <scodil> i haven't used it much, but people I've talked to have said you don't notice the extra memory burden
11:14:18 <ventonegro> hmm... even with 100k vertices?
11:14:31 <ventonegro> that's what i've been asking myself
11:14:57 <scodil> well I don't know about that. the docs mention some out-of-core simplification functions, but its light on details
11:15:00 <ventonegro> addVertex :: Mesh -> Vertex -> Mesh
11:15:14 <ventonegro> that's gonna create a whole mesh just to add a vertex
11:15:58 <scodil> yeah its a miserable situation. plus think about the internals of that function. you have to resort all sorts of hackery to traverse the old mesh and build the new mesh
11:16:25 <scodil> i think its better to leave it to c
11:16:32 <ventonegro> shame :-(
11:16:42 <scodil> but you can make a really nice interface
11:16:58 <scodil> have you ever read the guibas and stolfi quad-edge paper?
11:17:05 <mnislaih> dcoutts_: I will fail to make it to Fun on Thursday; I just told you by mail too
11:17:14 <ventonegro> scodil, nope
11:17:21 <dcoutts_> mnislaih, ah ok :-(
11:17:27 <ventonegro> i was planning on using half-edges
11:18:29 <dcoutts_> scodil, if it only uses gslits then there's not much advantage to using the gtk2hs code generator, the big advantage is if you're using something that uses the GObject model.
11:18:34 <scodil> yeah its similar to that. anyway, in that paper they use the metaphor of a bug walking around the mesh, where you tell the bug what to do with onext and sym and things like that. it ends up looking like logo, ordering the turtle/bug to walk around in an imperitive way. would make a perfect monad
11:18:53 <dcoutts_> scodil, and/or if it uses gtk-doc, because the code generator can produce haddock documentation from gtk-doc markup.
11:19:06 <ventonegro> @type Data-Graph-Inductive-Graph.insNodes
11:19:07 <lambdabot> Couldn't find qualified module.
11:19:14 <ventonegro> @type Data.Graph.Inductive.Graph.insNodes
11:19:15 <lambdabot> forall b a (gr :: * -> * -> *). (Data.Graph.Inductive.Graph.DynGraph gr) => [Data.Graph.Inductive.Graph.LNode a] -> gr a b -> gr a b
11:19:30 <ventonegro> scodil, this function manages to add nodes to a graph
11:19:31 <EvilRanter> hm
11:19:32 <lambdabot> EvilRanter: You have 1 new message. '/msg lambdabot @messages' to read it.
11:19:43 <ventonegro> maybe we could investigate it further
11:19:46 <scodil> dcoutts_: yeah i'm pretty sure it uses gtk-doc.  look at this and see.. looks the same to me http://gts.sourceforge.net/reference/book1.html
11:19:48 <lambdabot> http://tinyurl.com/sdste
11:19:52 <EvilRanter> @messages
11:19:52 <lambdabot> kpreid said 1d 10m 5s ago: (\x y -> guard x >> y) :: MonadPlus m => Bool -> m a -> m a
11:20:21 <dcoutts_> @seen malcolm
11:20:21 <lambdabot> I saw malcolm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 10d 1h 32m 29s ago, and .
11:20:32 * kpreid is here
11:20:36 <EvilRanter> ta, kpreid. i'm not sure why that works, but it seems to.
11:20:57 <kpreid> EvilRanter: guard b = if b then return () else mzero
11:21:18 <EvilRanter> > mzero >> return undefined
11:21:18 <lambdabot>  add an instance declaration for (Show (m a))
11:21:19 <kpreid> EvilRanter: then >> y takes care of specifying the result for the non-mzero case
11:21:27 <scodil> ventonegro: I've checked out that library before and I can't really penetrate it
11:21:36 <kpreid> > mzero >> return "hi"
11:21:36 <scodil> might be overkill
11:21:37 <lambdabot>  add an instance declaration for (Show (m [Char]))
11:21:45 <kpreid> > mzero >> return "hi" :: [String]
11:21:46 <ventonegro> scodil, not to use the library
11:21:47 <lambdabot>  []
11:21:50 <dcoutts_> scodil, yes, that looks like it could benefit from using the gtk2hs code generator
11:22:00 <dcoutts_> scodil, I'll be happy to accept patches too :-)
11:22:03 <ventonegro> scodil, just to see how they manage to mutate a graph without using lots of memory
11:22:07 <scodil> oh just for inspiration. yeah I see your point
11:22:19 <dcoutts_> scodil, (if you need to make improvements to the code gen I mean)
11:22:24 <EvilRanter> > ["lo"] >> return "hi" :: [String]
11:22:25 <lambdabot>  ["hi"]
11:22:42 <dcoutts_> scodil, in fact I've just been overhauling the code to make it easier to understand.
11:22:44 <scodil> dcoutts_: hah it will probably take me weeks to figure out how to use it
11:22:46 <kpreid> > ["lo", "med"] >> return "hi" :: [String]
11:22:47 <lambdabot>  ["hi","hi"]
11:22:58 <EvilRanter> hehe, great minds etc
11:23:02 <EvilRanter> kpreid++
11:23:25 <dcoutts_> scodil, you're in luck. I was just blogging about it the other day:
11:23:26 <dcoutts_> http://haskell.org/gtk2hs/archives/2006/11/12/the-gtk2hs-code-generator/
11:23:29 <lambdabot> Title: Gtk2Hs  Blog Archive  The Gtk2Hs code generator, http://tinyurl.com/yecckl
11:24:23 <dcoutts_> scodil, perhaps you using it will inspire me to write part 2 of that story about how it works now that I've restructured it
11:25:05 <scodil> dcoutts_: I just read that
11:25:33 <dcoutts_> ah right, did it inspire or terrify you ? :-)
11:26:10 <scodil> which was your intent?
11:27:26 <scodil> I'm still a little green when it comes to glib an the gobject model, so most of it was vague. Like when you say that you work on the gobject-level instead of the c-level, I don't know what that means concretely
11:28:50 <scodil> i can imagine, being familiar with oop and other concrete object models, but I'm missing the details. like what data is actually associcated with each item/node in the model
11:28:51 <dcoutts_> scodil, so GObject is basically python or java style object model implemented in C
11:29:06 <dcoutts_> it's got classes and instances
11:29:13 <dcoutts_> methods and attributes
11:29:15 <scodil> but no notion of data hiding, right?
11:29:23 <dcoutts_> yes, some data is private
11:29:45 <scodil> but is that part of the object model? like is there such thing as a virtual protected method?
11:29:50 <scodil> or whatever its called
11:29:50 <dcoutts_> and it does OOP style inheritance and polymorphism
11:30:03 <dcoutts_> there are virtual methods yes
11:30:42 <dcoutts_> scodil, now using that in C is obviously a PITA
11:30:54 <dcoutts_> because C doesn't have the abstraction features etc
11:30:59 <SyntaxNinja> w0w java is GPL now.
11:31:01 <scodil> yeah thats why i never used/learned it
11:31:03 <dcoutts_> but we can model it all in Haskell pretty well
11:31:06 <SyntaxNinja> I wish they had done that like 5 years ago when I cared.
11:31:12 <dcoutts_> scodil, aye, don't use it from C :-)
11:31:39 <dcoutts_> SyntaxNinja, it should help against the encroachment of C#
11:32:04 <dcoutts_> scodil, so we use types and type classes to model the GObject classes
11:32:32 <scodil> right yeah I've started using gtk2hs and I've gotten a feel for the object model
11:32:44 <SyntaxNinja> dcoutts_: yeah
11:32:49 <dcoutts_> scodil, right, so yeah, it'd be much like that
11:33:08 <dcoutts_> scodil, and then you can wrap it from there to make the api however you like
11:33:40 <dcoutts_> scodil, I don't expect that inheritance is that important for gts stuff, it's probably more as just a way of them organising the api
11:34:01 <dcoutts_> so while in gtk2hs we expose the object model and inheritance etc, you might not need to
11:34:53 <araujo> scodil, gtk2hs reminds me of Smalltalk pretty much.
11:35:13 <dcoutts_> I assume that's a good thing :-)
11:35:23 <Grey-z> hi
11:35:33 <araujo> dcoutts_, Of course :-)
11:35:39 <Grey-z> got some noobish questions :$
11:35:48 <araujo> I think that's something good for GUI programming.
11:36:17 <scodil> yeah thats what thing that kind of bugs me about gts. they use a full-blown object model when its not really appropriate. like, every vertex has a pointer to the class object, as if you're going to have a heterogenous mesh of differently-typed vertices. kind of overkill, especially considering all the memory involved
11:36:32 <araujo> Of course, you get all the magic of Haskell with it.
11:36:44 <dcoutts_> scodil, aye, it does sounds a little over-engineered
11:36:49 <Grey-z> I have a server program Server.hs and two player programs that should communicate through server
11:36:56 <scodil> but its a good solid library, and if you were crazy about effeciency, well... i won't say it
11:37:02 <dcoutts_> heh heh
11:37:04 <Grey-z> I compiled the server but can't run the program
11:37:10 <Grey-z> game is quoridor
11:37:11 <tibbe> anyone use either emacs or textmate on mac os x to write haskell?
11:37:22 <Grey-z> <interactive>:1:5: Not in scope: data constructor `Dummy2'
11:37:25 <xerox> tibbe: yes?
11:37:33 <tibbe> xerox: which one?
11:37:37 <xerox> both
11:37:43 <Excedrin> is there any interest in wxHaskell anymore? I ask because I prefer wxWidgets to Gtk
11:37:43 <Grey-z> and Dummy2 is one of the player
11:37:45 <tibbe> how's font rendering?
11:37:45 <dcoutts_> scodil, well get the gtk2hs code from darcs and give the code gen a spin. it's in tools/apiGen. The makefile is a little rusty but should work with a little poking.
11:37:55 <tibbe> I'm planning to get a mac
11:38:08 <xerox> tibbe: what do you want to know exactly? it's like where ever else in os x.
11:38:13 <tibbe> and I've finally got decent fonts in emacs on linux
11:38:18 <pzpz> tibbe: try emacs w/ xft support? :)
11:38:28 <scodil> dcoutts_: is the current version in the repo stable? can install it in my main ghc?
11:38:37 <dcoutts_> scodil, poke me if you run into problems and do feel free to send in patches. I'm not claiming the code is a work of art, it's a fairly gritty problem converting C apis and docs in to Haskell :-)
11:38:38 <tibbe> xerox: I wanna know if emacs looks like old ugly fonts emacs or nice subpixelrendered emacs
11:38:53 <dcoutts_> scodil, yep current gtk2hs darcs version should be just fine with ghc 6.6
11:39:06 <xerox> tibbe: it is antialiased, every f**king thing is antialiased on this os.
11:39:19 <tibbe> xerox: ok
11:39:22 <scodil> ok i'll let you know how it goes. I probably won't get to it for a while. busy with other stuff at the moment. maybe in a week or two
11:39:23 <dcoutts_> scodil, and you can do parallel installs of course so you don't need to remove the old version.
11:39:23 <xerox> (which is getting to my nerves)
11:39:29 <Grey-z> so, anyone...  what means: "Not in scope: data constructor" and how to make it work
11:39:43 <dcoutts_> scodil, btw, you don't need to build gtk2hs to use the code gen.
11:39:54 <tibbe> xerox: you need a 300dpi display
11:40:22 <xerox> tibbe: how to see my dpis?
11:40:31 <dcoutts_> Igloo, btw, nice logo ;-)
11:40:32 <scodil> dcoutts_: ok. I was just asking because I'm in the process of reinstalling ghc and I was about to install 0.9.10, but I'll install the darcs version instead
11:40:46 <dcoutts_> ok
11:40:48 * dcoutts_ -> home
11:40:59 <xerox> bye dcoutts_ :)
11:41:03 <tibbe> xerox: measure your screen ;)
11:41:12 <tibbe> xerox: probably around 100 dpi
11:41:43 <xerox> does that mean that a square inch on my monitor contains 10 pixel per side?
11:41:50 <xerox> pixels, even
11:42:38 <eviltwin_b> 100dpi = 100x100 pixels
11:42:53 <xerox> that's better (:
11:43:04 <tibbe> yeah
11:43:19 <tibbe> that macbook I'm getting is:
11:43:58 <tibbe> > sqrt (1280^2 * 800^2) / 13.3
11:44:00 <lambdabot>  76992.48120300751
11:44:06 <xerox> pricey? :P
11:44:06 <tibbe> um, that's not right
11:44:12 <tibbe> > sqrt (1280^2 + 800^2) / 13.3
11:44:14 <lambdabot>  113.49150234053057
11:44:17 <tibbe> :p
11:44:21 <tibbe> 113 DPI
11:44:24 <xerox> what is 13.3 ?
11:44:33 <tibbe> screen in inches
11:44:37 <liyang> supposed diagonal size
11:44:52 <tibbe> liyang: thinks that's actual for lcds
11:45:00 <Grey-z> you're breaking my heart. no help.
11:45:01 <xerox> > sqrt (1680^2 + 1050^2) / 20
11:45:01 <psicho> can somebody please explain me what does this bc in this code realy do > lookUpBill ((barCode,name,price):xs) bc   ,thanx
11:45:02 <lambdabot>  99.05680188659434
11:45:05 <xerox> yuck!
11:45:06 <Excedrin> 13.3 is probably the diagonal measurement
11:45:07 <tibbe> CRTs are usually 1 inch smaller than stated
11:45:29 <liyang> psicho: bc in that bit is the second parameter to lookUpBill...
11:46:04 <liyang> so you might look at the definition of lookUpBill to see what it's supposed to be.
11:46:06 <Excedrin> Grey-z: it means the data constructor you're referring to isn't in scope or doesn't exist, what's the line of code that causes that error?
11:46:14 <tibbe> read that john hughes started a startup :)
11:46:44 <xerox> tibbe: if I use greyscale, it's really a pleasure to watch, but with color, it's eye-spinning
11:46:57 <pzpz> > sqrt (1400^2 + 1050^2) / 14.1
11:46:59 <lambdabot>  124.11347517730496
11:47:03 <tibbe> xerox: the antialiasing?
11:47:11 <xerox> yep
11:47:14 <tibbe> pzpz: gratz ;)
11:47:15 <pzpz> hee, not sure of my diagonal :(
11:47:27 <pzpz> wait, that is diagonal
11:47:28 <tibbe> subpixel rendering is better than normal antialiasing though
11:47:29 <pzpz> i'm an idiot.
11:47:34 <xerox> because it is done with crazy colors around black things too.
11:47:44 <pzpz> subpixel rendering isn't antialiasing, right?
11:47:46 <xerox> if you zoom in you see the madness
11:47:48 <pzpz> hence your ability to do both
11:47:48 <tibbe> pzpz: 14.1 sounds like a normal one, that's what I have
11:47:54 <pzpz> tibbe: ibm?
11:47:58 <tibbe> yes
11:48:04 <pzpz> tibbe: why go from ibm-> apple? :)
11:48:22 <pzpz> pzpz: i can't see how anyone can use a laptop without the nipple
11:48:26 <tibbe> I think it should be possible to use subpixel rendering without the bluriness although I have never seen it done
11:48:37 <pzpz> tibbe: use hintint?
11:48:40 <pzpz> hinting
11:48:43 <tibbe> pzpz: nice hardware + google will buy me one
11:49:07 <tibbe> pzpz: well yes, subpixelrendering should help hinting also
11:49:49 <tibbe> it in essence makes the precision at which you can place pixels 3x in the horizontal direction of the screen
11:50:38 <tibbe> pzpz: I'm a bit tired of linux I want just works + linux based, mac os x is almost that
11:50:50 <tibbe> and it looks good which makes me happy :)
11:51:33 <tibbe> someone really has to say something now or it'll look like I'm having a discussion with myself
11:51:47 <Binkley> I don't think that's true.
11:52:01 <Philippa> not at all
11:52:07 * eviltwin_b has a mini and an ibook specifically for that reason, fwiw
11:54:31 * tibbe wonders if 1280 x 800 is enough to have to emacs buffers next to each other
11:54:56 <pejo> pzpz, I don't know much about IBM, but I'm very happy with my Mac. Same goes for my friends who has macs.
11:55:32 <tibbe> I have to wait until next year though, I want a new toy now :(
11:55:34 <araujo> yay!
11:55:38 <eviltwin_b> 1280x1024 is just barely too short for the usual font sizes he uses
11:55:42 * araujo throws sugar lambdas at everyone
11:55:48 <pejo> tibbe, I can easily squeeze in two next to eachother, plus that bar thing which I keep on the side to not occupy vertical space on my screen.
11:56:12 <tibbe> the bar at the bottom?
11:56:23 <mgoetze> it's called the "dock" :)
11:56:29 <pejo> tibbe, well, I keep it on the side to fit my xterms. :-)
11:56:32 <mgoetze> and yes, having the dock at the bottom is really crazy
11:56:37 <tibbe> mgoetze: don't get all technical on me!
11:57:10 <mgoetze> you can also configure it to only show on the screen if you move your mouse to the edge
11:57:13 <tibbe> can't you maximise over the dock? although that would perhaps defeat the purpose of having one...
11:58:17 <pejo> Only thing I miss is focus-follows-mouse, outside of X11. And there's software who accomplishes that, I think.
11:58:46 <mgoetze> well, the problem with focus-follows mouse is the global menu bar...
11:58:47 <eviltwin_b> maximize avoids the dock normally.  I keep my dock minimally sized, suppose one could autohide it instead
11:58:56 <guerra> can i make a call to a function with a call to another function as argument?
11:59:12 <shapr> guerra: yes?
11:59:13 <Excedrin> guerra: sure
11:59:22 <mgoetze> System Preferences -> Dock -> Automatically hide and show the Dock ;)
11:59:43 <guerra> Excedrin: shapr was just checkin thanks
11:59:57 <mgoetze> be sure to turn off magnification and change the position while you're at it
12:00:07 <pejo> mgoetze, we lost him. :/
12:00:55 <guerra> Excedrin: i just need to put all needed parentesis so it doesnt mess with args isnt it?
12:01:06 <tibbe> my X just crashed on me :(
12:02:26 <Excedrin> guerra: the '$' operator is useful for that: f (g x) = f $ g x
12:02:36 <shapr> salut kowey
12:02:44 <guerra> Excedrin: will try that ^^ thanks
12:03:09 <kowey> he[jy] shapr and #haskell
12:03:35 <kowey> say, can anyone recommend a good mailing list for people to send darcs patches for yaht?
12:04:32 <Lemmih> kowey: How about mailing the author?
12:04:49 <fabiim> can someone show me a infinitive  List of the alphabet ? ( brute-force)?
12:04:57 <Grey-z> seems that row path <- canonicalizePath x
12:04:58 <kowey> Lemmih: i suspect Hal (a) isn't using darcs (b) is too busy to look after yaht
12:05:04 <kowey> so for now all patches go to me
12:05:08 <Grey-z> was the problem
12:05:19 <kowey> and I might not be qualified enough to review them myself
12:05:21 <fabiim> i've been trying to do that with list comprehension  since morning , and i don't get it .
12:06:41 <kowey> hmm... maybe i could just put them on the wikibook and then push them in only if they stick for some time
12:07:04 <Grey-z> is there any restrictions with canonicalizePath and two hard drives or windows
12:08:21 <guerra> Excedrin: weird, im making calls to functions the way i said inside a do, at the end i make a recursive call to the function in which the do is. is that right?
12:12:46 <Grey-z> apparently windows expects .exe extentsion also
12:15:12 <Excedrin> guerra: some kind of loop? you could probably paste the code to http://rafb.net/ if you wanted someone to take a look
12:15:37 <guerra> Excedrin: actually not a loop
12:16:23 <guerra> Excedrin: the last function i call in a line is taking what is at teh nbext line as parameters
12:16:31 <guerra> Excedrin: that inside the do
12:29:22 <scodil> dcoutts_: ping
12:29:25 <ihope> @hoogle [a] -> a -> [a]
12:29:27 <lambdabot> List.intersperse :: a -> [a] -> [a]
12:29:27 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
12:29:27 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
12:29:32 <ihope> Oh, pah.
12:30:46 <scodil> is Data.FiniteMap included with ghc-6.6?
12:31:16 <ValarQ> scodil: no
12:35:58 <arjanoosting> @seen Igloo
12:35:58 <lambdabot> Igloo is in #darcs, #haskell and #ghc. I last heard Igloo speak 4h 45m 13s ago.
12:36:32 <Igloo> Hello
12:37:37 <arjanoosting> Igloo: on which architectures does ghci work?
12:37:44 <Igloo> arjanoosting: x86/amd64 currently
12:38:10 <therp> oh there is a restriction on ghci? hmm didn't know that..
12:39:42 <arjanoosting> Igloo: what do you recommend for 397058 then?
12:42:55 <dcoutts> scodil, aye?
12:42:57 <Igloo> arjanoosting: I'd ignore it, personally
12:52:49 <equanimity> > foldr (*) 1 [1..10]
12:52:50 <lambdabot>  3628800
12:53:01 <xerox> ?type product
12:53:02 <lambdabot> forall a. (Num a) => [a] -> a
12:54:02 <equanimity> > product [1..10]
12:54:04 <lambdabot>  3628800
12:54:23 * equanimity is happy
12:55:54 <scodil> dcoutts: nm I got it. for some reason your c2hs was looking for Data.FiniteMap.
12:56:00 <lisppaste2> metaperl pasted "how to write this without recursion? HELP NEEDED" at http://paste.lisp.org/display/29844
12:56:42 <dcoutts> scodil, erm, are you using the latest darcs version or 0.9.10?
12:56:50 <scodil> i thought I was using the darcs version
12:57:04 <dcoutts> scodil, 0.9.10 doesn't work with 6.6, partly because of the Data.FiniteMap issue
12:57:18 <dcoutts> (but mostly because of package changes in ghc 6.6)
12:57:33 <scodil> how do I tell what version I installed
12:57:47 <scodil> I had a couple of source trees lying around and I just used the one that worked
12:57:52 <dcoutts> scodil, look in configure.ac, AC_INIT
12:58:20 <dcoutts> scodil, the latest darcs version definately does not use Data.FiniteMap, it uses Data.Map
12:58:50 <scodil> 0.9.10.2, in ghc-pkg?
13:00:22 <dcoutts> scodil, aye, that's reasonably recent, perhaps not the latest
13:01:18 <lisppaste2> xerox annotated #29844 with "nonrecursive" at http://paste.lisp.org/display/29844#1
13:01:27 <xerox> metaperl -^
13:01:40 <metaperl> xerox: nice, thanks
13:01:53 * xerox bows
13:02:46 <fabiim> can someone help solve this problem -> [a:[] | a<-['A'..'Z']] ++ [a:b:[] | a<-['A'..'Z'],b<-['A'..'Z']] ..   I Need a way of keep doing this , like the next element of the function should be [a:b:c:[] | a<-['A'..'Z'],b<-['A'..'Z'],c<-['A'..'Z'] ... i can't see how!
13:03:21 <roconnor> why is a:[] so popular all of a sudden?  What's wrong with [a]?
13:03:22 <sjanssen> fabiim: are you aware that a:[] is the same as [a]
13:03:22 <fabiim> some miraculous  high order function to the rescue please...
13:03:31 <xerox> ?type (transpose .) . replicate -- fabiim
13:03:32 <lambdabot> forall a. Int -> [a] -> [[a]]
13:03:34 <sjanssen> and a:b:[] is [a, b]
13:03:38 <fabiim> sjanssen: yes
13:04:00 <scodil> probably some combination of fold and ++
13:04:19 <xerox> > ((transpose .) . replicate) 2 ['A'..'C']
13:04:20 <lambdabot>  ["AA","BB","CC"]
13:04:41 <xerox> uhm.
13:04:43 <scodil> does (length [1..n]) run in O(n) or O(1) ?
13:04:50 <fabiim> xerox:  i need AA , AB , AC ...
13:04:55 <xerox> alright
13:04:57 <sjanssen> scodil: O(n)
13:04:59 <Excedrin> > take 2 $ repeat ['a'..'c']
13:05:01 <lambdabot>  ["abc","abc"]
13:05:22 <xerox> > ((sequence .) . replicate) 2 ['A'..'C']
13:05:22 <scodil> weak
13:05:23 <lambdabot>  ["AA","AB","AC","BA","BB","BC","CA","CB","CC"]
13:05:24 <metaperl> Excedrin:  take 2 tylenol and call you in the morning?
13:05:36 * xerox runs around in circles
13:05:42 <Excedrin> tylenol is deprecated
13:05:51 <sjanssen> heh
13:05:52 <metaperl> yes Excedrin cleerly r00lz :)
13:06:00 <xerox> alright, fabiim?
13:06:08 <xerox> hiya Daveman
13:06:26 <fabiim> xerox: I guess it's alrright , when i grow up I will be like you lol
13:06:53 * xerox hugs fabiim, though he doesn't consider himself "grown up"...
13:07:08 <Adamant> you don't appreciate strong typing until you've dealt with something like PHP
13:07:54 <xerox> fabiim: how old are you? (:
13:09:24 <fabiim> xerox : 20 lol
13:09:45 <xerox> ok, you have one year to catch me :P
13:09:59 <xerox> oh no, I'll be one year old as well! yuck.
13:10:23 <pkhuong> xerox: take the relativity train!
13:10:24 <dcoutts> xerox, if you'll be one year old next year does that make you zero now ?
13:10:49 <xerox> dcoutts, i'm bootstrapping
13:11:00 <dcoutts> hah hah hah
13:11:22 <fabiim> lol , but my :) has vanish  i can't use sequence in my work , it uses monads . I haven't learn that yet ... I guess I could learn that ...
13:11:28 <fabiim> i'm confuse now ...
13:12:33 <Cale> well, you can, if you want, compute a definition for sequence just in the case of lists
13:13:15 <cjeris> why understanding monads should be easier than understanding recursion: to understand recursion you must first understand recursion, but to understand monads you should only have to describe each step of the transition from the world where you do not understand monads to the world where you do.
13:13:23 <cjeris> somehow it doesn't work this way though.
13:14:22 <fabiim> Cale:  i'll have to learn  monads and definitions for that right?
13:14:37 <Cale> fabiim: well, just in the case of lists.
13:14:44 <Cale> return x = [x]
13:14:54 <Cale> x >>= f = concat (map f x)
13:16:14 <Cale> and sequence [] = return []; sequence (x:xs) = x >>= \v -> sequence xs >>= \vs -> return (v:vs)
13:16:53 <Cale> So you can substitute the definitions of return and >>= and simplify
13:17:14 <Cale> but what is your original problem? Computing an arbitrary Cartesian product?
13:17:34 <Cale> right, yes it is
13:18:12 <fabiim> yes
13:18:29 <Cale> Well, actually, you're already familiar with list comprehensions
13:18:53 <Cale> so it should be no problem to write it recursively :)
13:18:54 <fabiim> i am doing a brute force attack to a viginiere  cipher  , so i have to have a infinite list of possible key's
13:19:17 <Cale> sequence [] = [[]] -- as a base case
13:19:39 <Cale> now, if we want to compute sequence (x:xs), what will it be in terms of sequence xs ?
13:19:40 * xerox eagerly awaits
13:19:44 <fabiim> yes , it has been a problem , since 12:00 today , i don't see how i can do this the simple way
13:20:38 <Pupeno> Is Bulat here ? does he ever come here ?
13:20:39 <fabiim> Cale : what do you mean ? ( my english  is bad)
13:20:50 <Cale> That is, if we know how to construct all possible strings by picking one element from each of the lists in xs, and we call that (sequence xs)
13:21:17 <Cale> then how do we build up from that to sequence (x:xs) ?
13:22:30 <Cale> Every element of that will start with an element of x, right?
13:22:41 <fabiim> x:head xs
13:22:46 <Cale> hmm...
13:23:13 <Cale> well, head x : head (sequence xs) will be the first string.
13:23:22 <fabiim> head x : head xs
13:23:29 <Cale> that's a type error though
13:23:39 <Cale> er
13:23:45 <Cale> well, no
13:24:08 <Cale> It's just not what we want
13:24:11 <fabiim> i don't get the head (sequence xs) , and we are talking of a List of Strings right?
13:24:30 <Cale> okay, we're going to pass sequence a list of lists
13:24:35 <SamB> @type \xs -> head (sequence xs)
13:24:37 <lambdabot> forall a. [[a]] -> [a]
13:24:47 <Cale> it's going to pick one item from each of the lists to form a new sequence in all possible ways
13:25:00 <Cale> and hand us a list of all the sequences it gets
13:25:09 <SamB> > head (sequence ["hello", "world"])
13:25:11 <lambdabot>  "hw"
13:25:12 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
13:25:14 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
13:26:48 <Cale> now, suppose we have sequence [[4,5],[6,7,8]], and we know already that's [[4,6],[4,7],[4,8],[5,6],[5,7],[5,8]]
13:27:09 <Cale> we're going to call that sequence xs
13:27:17 <Cale> and x = [1,2,3]
13:27:19 <syntaxfree> http://www.defmacro.org/ramblings/lisp-in-haskell.html
13:27:21 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell, http://tinyurl.com/yyr8sf
13:27:27 <syntaxfree> that made the del.icio.us frontpage.
13:27:35 <Cale> Then how do we get sequence (x:xs)?
13:27:42 <Cale> we pick an element of x
13:27:49 <syntaxfree> which might be the widest exposition Haskell has had since it came up in /. in the Pugs announcement.
13:27:50 <Cale> and then we pick an element of sequence xs
13:27:59 <Cale> and then we stick them together, right?
13:28:25 <fabiim> right
13:28:32 <tibbe> syntaxfree: I like the buzz I'm seing
13:28:49 <syntaxfree> I'm not seeing nearly enough buzz.
13:28:50 <fabiim> how ?
13:28:51 <Cale> fabiim: so how do we write that as a list comprehension?
13:29:09 <syntaxfree> Safe for programming.reddit.com, Haskell very rarely comes up in non-Haskell media.
13:30:35 <Cale> remember, avoid popularity at all costs :)
13:30:52 <tibbe> syntaxfree: well there could be more, need a killer app
13:30:53 <Cale> hehe
13:31:11 <tibbe> Cale: :D
13:31:13 <syntaxfree> Linq is supposed to be the monadic programming killer app.
13:31:18 <fabiim>  [  x:head b    | x <- [1,2,3] , b <- xs  ]  how do i get the 4?
13:31:22 <syntaxfree> But then again, it's'already Not Haskell.
13:31:31 <Cale> fabiim: nope
13:31:32 <syntaxfree> It also has the one feature we don't: monadic comprehensions.
13:31:34 <tibbe> syntaxfree: I was thinking of something like unix
13:31:46 <Cale> fabiim: here's a hint, you need to use sequence xs to get sequence (x:xs)
13:31:57 <Cale> I don't see a sequence xs in that
13:32:49 <xerox> Cale: I'm not sure I'm fully satisfied by that explanation :)
13:32:50 <syntaxfree> Pugs is close to being a killer app in the classical sense.
13:33:05 <Cale> xerox: It's not an explanation
13:33:09 <syntaxfree> Someone went and made a Perl interpreter before the Perl guys even had one.
13:33:11 <Cale> It's a hint :)
13:33:16 <syntaxfree> I wonder if they used Parsec.
13:33:28 <syntaxfree> Now that I'm beginning to grok Parsec, I'm baffled by its power.
13:33:41 <xerox> Cale: I probably just don't understand sequence as well
13:33:57 <fabiim> if i do sequence xs , i will have something [4,4] , [4,7 ] ... right?
13:33:57 <scodil> anyone know of any haskell image bindings? image magick maybe? or just libpng/libjpeg/libtiff?
13:34:22 <Cale> > sequence [[4,5],[6,7,8]]
13:34:23 <lambdabot>  [[4,6],[4,7],[4,8],[5,6],[5,7],[5,8]]
13:34:51 <Cale> so we assume that we can handle sequence xs when we build sequence (x:xs)
13:34:54 <tibbe> syntaxfree: well, a killer app that someone can make money from, like unix, or ruby on rails or something
13:35:10 <newbcoder> how do I check if my distro's package of hugs includes soegraphics ?
13:35:23 <tibbe> or at least useful for someone outside the developer crowd, only if indirectly
13:35:26 <syntaxfree> tibbe: there's even an embedded DSL that evaluates arbitrary financial contracts.
13:35:34 <syntaxfree> tibbe: and laziness is crucial for that.
13:35:35 <tibbe> :)
13:35:54 <tibbe> if I know what was needed I would build it instead of babbling here ;)
13:36:59 <fabiim>  [  x:sequence xs    | x <- [1,2,3] , b <- xs  ]  that way i will have an x in all sequences of xs
13:37:03 <fabiim> hope so...
13:37:03 <fabiim> lol
13:37:07 <syntaxfree> I mean, there's already one.
13:37:12 <syntaxfree> @google peyton-jones contracts
13:37:14 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/financial-contracts/contracts-icfp.htm
13:37:15 <lambdabot> Title: Simon Peyton Jones: papers
13:37:57 <tibbe> I mean I would like to see the killer app that makes as much buzz as RoR
13:37:58 <tibbe> or something
13:38:30 <Cale> fabiim: that's not quite right, but you almost have the idea
13:38:38 <Cale> fabiim: that's a type error though
13:38:53 <fabiim> yeah but will work for Char right?
13:39:08 <Cale> no
13:39:08 <syntaxfree> LINQ is fully backed by Microsoft and will be included in the next VB.
13:39:19 <tibbe> :)
13:39:22 <syntaxfree> I mean, VB is gonna have monads (and monad comprehensions).
13:39:32 <tibbe> I think lots of nice things are creeping into mainstream languages
13:39:44 <SamB> hahaha
13:39:48 <Cale> fabiim: remember that the part before the | is an element of the list you're returning, and the things after the | say what you're choosing the parts from
13:39:51 <tibbe> heh, go figure
13:39:57 <SamB> VB with monad comprehensions is a funny idea...
13:40:00 <Cale> fabiim: should I just give you the solution?
13:40:03 <astrolabe> So, why hasn't haskell taken over the world?  Why are there so few famous programs?
13:40:38 <Cale> astrolabe: By most people's standards, it's only been practical for large programs for a few years now.
13:41:01 <fabiim> wait...
13:41:03 <SamB> also consider the ratio of famous to non-famous programs written in other languages...
13:41:07 <Cale> That practicality involves monads, and it takes at least 20 or 30 years for new programming techniques to catch on.
13:41:11 <syntaxfree> astrolabe: that's partially discussed in the "History of Haskell" and "Confessions of an used programming language salesman" papers.
13:41:12 <tibbe> as far as I'm concerned it doesn't have to take over the world, I just need to find a use for haskell that'll allow me to take over the world xD
13:41:22 <sieni> monads are cool as fuck
13:41:27 <syntaxfree> tibbe: monadic parsers, for one.
13:41:38 <syntaxfree> Parsec is a tool of great power.
13:41:48 <tibbe> absolutely
13:41:50 <astrolabe> I think it's too difficult for too many people.
13:41:57 <astrolabe> (haskell)
13:42:05 <tibbe> now I need some other use that implementing programming languages parsers with it ;)
13:42:06 <Cale> It's not really that difficult if you're starting from scratch
13:42:14 <syntaxfree> I think there's an entire business of DSLs and EDSLs waiting to boom.
13:42:21 <Cale> After all, it's taught as a first programming language in many universities.
13:42:34 <satan> hello all
13:42:34 <astrolabe> Cale: I find that difficult to believe
13:42:39 <Cale> I've taught monads to 11 year old kids.
13:42:43 <SamB> I thought you were supposed to write your own EDSLs?
13:42:53 <fabiim> Cale:  give me the solution lol
13:42:53 <syntaxfree> SamB: unless you're not a developer.
13:42:55 <astrolabe> Cale: intellegence is more important than age.
13:42:56 <Cale> astrolabe: believe it. All across Europe and Australia :)
13:42:56 <sieni> astrolabe: try to learn c++ properly and then tell us that haskell is difficult :-)
13:42:58 <SamB> oh
13:43:07 <Cale> fabiim: okay :)
13:43:13 <tibbe> satan: hi
13:43:23 <syntaxfree> Statisticians and econometricians, for instance, use DSLs because point-and-click software is never flexible enough.
13:43:25 <Cale> sequence (x:xs) = [v:vs | v <- x, vs <- sequence xs]
13:43:38 <astrolabe> sieni: True, but the people I'm talking about don't learn C++ properly.
13:43:46 <syntaxfree> I feel that there's a wide range of real-world activities that are never quite captured in point-and-click interfaces.
13:44:20 <Cale> astrolabe: I'd even say that it's easier to get to a point in learning Haskell where you can solve problems much easier than you can do so with C/C++
13:44:40 <fabiim> Cale , i'll try to understand lol :) thanks
13:44:46 <Cale> GHCi gives you a simple user interface to your programs without even knowing anything about IO.
13:45:04 <satan> how would i prove that xs ++ [] = xs, without induction, considering that [] is a monad and obeys the monad law: concat . concat ? concat . map concat
13:45:13 <Cale> It's not the greatest UI, but for many things, it suffices.
13:45:25 <astrolabe> Cale: So, do you think there are big apps on the way?
13:45:32 <satan> i guess i could rewrite xs ++ [] as concat xs [], but then what?...
13:45:33 <Cale> astrolabe: eventually
13:45:50 <syntaxfree> astrolabe: Pugs and Darcs don't count?
13:45:51 <Cale> astrolabe: I don't really care if there are, so long as I get to use Haskell myself :)
13:46:12 <tibbe> I had an idea about doing web apps/web services without the shuffle your db into objects and then into some more objects and then render them
13:46:28 <syntaxfree> tibbe: aka WebFunctions?
13:46:33 <Cale> Of course, I'd like there to be enough Haskell programmers to keep the pool of really high-quality libraries growing
13:46:43 <Cale> I don't really care about the number of poor libraries.
13:46:46 <astrolabe> syntaxfree: sure they count, but they (and GHC?) are the major haskell programs.  Why aren't there more? and more famous?
13:46:48 <syntaxfree> @google haskell webfunctions
13:46:51 <lambdabot> http://www.cs.uu.nl/wiki/WebFunctions
13:46:52 <lambdabot> Title: Home page of the <nowiki>WebFunctions</wiki> Project
13:47:03 <syntaxfree> Pugs is quite famous these days.
13:47:12 <Cale> astrolabe: because less than 1% of programmers know Haskell.
13:47:20 <syntaxfree> One thing that might  push Haskell further is Linspire.
13:47:36 <astrolabe> Cale: right.
13:47:44 <syntaxfree> Linux kiddies learning Haskell to hack on derived distros. Now there's something.
13:48:14 <astrolabe> I think once someone has made the effort to learn haskell, they are likely to stick with it.
13:48:20 <tibbe> syntaxfree: I dunno, sometimes I just that I'm writing alot of shuffling around code
13:48:30 <tibbe> can't really express it well
13:49:18 <syntaxfree> the "robot" model of programming is too ingrained on the typical coder.
13:49:18 <fabiim> Cale:  what are those vs?
13:49:25 <tibbe> transformation from data storage -> representation should be easier
13:49:32 <Cale> vs will be a sequence on the rest of the lists
13:49:32 <roconnor> @type \f a -> a >> f a
13:49:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> m b) -> m a -> m b
13:49:55 <roconnor> @type fix (\f a -> a >> f a)
13:49:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:50:07 <roconnor> omg
13:50:21 <roconnor> @type >>
13:50:22 <Cale> fabiim: What that says is that to pick an element of sequence (x:xs), you pick an element from x and you cons it onto an element from sequence xs
13:50:23 <lambdabot> parse error on input `>>'
13:50:26 <roconnor> @type (>>)
13:50:27 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
13:50:54 <tibbe> anyway, I'm going to watch a movie now
13:51:08 <Cale> fabiim: let's do it by hand
13:51:15 <Cale> so...
13:51:30 <Cale> We want to compute sequence [[1,2,3],[4,5]], say.
13:51:44 <fabiim> ok
13:51:47 <Cale> that's sequence ([1,2,3] : [4,5] : [])
13:51:59 <fabiim> right
13:52:11 <Cale> = [v : vs | v <- [1,2,3], vs <- sequence ([4,5] : [])]
13:52:23 <Cale> so, let's compute sequence [4,5] : []
13:52:30 <Cale> that's
13:52:39 <Cale> er
13:52:46 <Cale> sequence ([4,5] : []) rather
13:52:47 <scodil> anyone know of any good, simple examples of using the ffi? the haskell report addendum doesn't make for a good tutorial
13:52:51 <Cale> the parens are important :)
13:53:10 <Cale> sequence ([4,5] : []) = [v : vs | v <- [4,5], vs <- sequence []]
13:53:20 <Cale> oh, but we know what sequence [] is
13:53:21 <astrolabe> scodil: I haven't read it yet, but maybe 'tackling the awkward squad'
13:53:23 <Cale> it's [[]]
13:53:34 <Cale> and so there's only one choice for vs here
13:53:37 <Cale> just []
13:54:05 <Cale> sequence ([4,5] : []) = [v : vs | v <- [4,5], vs <- sequence []] = [v : [] | v <- [4,5]]
13:54:18 <Cale> = [[4],[5]]
13:54:24 <Cale> follow that?
13:54:39 <glguy> With all of the changes to C# in 3.0, I wonder if mutable variables will be requried to exist inside of a unwise { } block in c# 4.0 :-D
13:54:57 <fabiim> yes
13:55:01 <dylan> heh
13:55:16 <Cale> So now we can go back up to  sequence ([1,2,3] : [4,5] : []) = [v : vs | v <- [1,2,3], vs <- sequence ([4,5] : [])]
13:55:28 <Cale> = [v : vs | v <- [1,2,3], vs <- [[4],[5]]]
13:55:56 <fabiim> but i get an error when i try to do that ...
13:56:03 <Cale> > [v : vs | v <- [1,2,3], vs <- [[4],[5]]]
13:56:05 <lambdabot>  [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
13:56:10 <Cale> really?
13:56:19 <roconnor> @type foldr (>>)
13:56:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> [m a] -> m b
13:56:36 <fabiim> non-exhaustive patterns...
13:56:51 <Cale> did you give the first equation for sequence?
13:56:54 <Cale> sequence [] = [[]]
13:56:59 <Cale> that's very important
13:57:03 <fabiim> oh off-course !
13:57:05 <fabiim> lol
13:57:36 <fabiim> (i meant , i didn't give the first equation)
13:57:48 <Cale> yeah
13:57:59 <blue> hello everyone can anyone please help me out with a problem??I try to write a program that does this: [5,3,8,2,1] -> [6,5,11,6,6]
13:58:34 <fabiim> ok , i will try some values , until i truly understand that .  thanks a lot
13:58:35 <Cale> blue: uh, how are you calculating that?
13:58:39 * edwardk waves hello.
13:58:48 <blue> that is to say it adds i to element i..I've tried a lot but till now I've only managed to add 1 to all elements
13:58:53 <Cale> fabiim: cool -- remember that you can just calculate things by substitution like in math
13:58:56 * metaperl waves to edwardk 
13:58:59 <Cale> blue: ah
13:59:09 <Cale> zipWith (+) [1..]
13:59:10 <SamB> > let f [5,3,8,2,1] = [6,5,11,6,6] in f [5,3,8,2,1] -- that answers the original question ;-P
13:59:11 <lambdabot>  [6,5,11,6,6]
13:59:23 <fabiim> Cale:  what do you mean?
13:59:27 <Cale> > zipWith (+) [1..] [5,3,8,2,1]
13:59:28 <lambdabot>  [6,5,11,6,6]
13:59:33 <metaperl> Does anyone think that Webfunctions should return XML? HTML is a display language... I cant imagine business-level HTML with all the bells and whistlesbeing generated manually in Haskell/WebFunctions
14:00:14 <SamB> why not SGML?
14:00:19 <Cale> fabiim: I mean that if you want to evaluate a function applied to its parameters, you can always just check which declaration matches and substitute the RHS of the = sign with the parameters replaced
14:00:44 <Cale> fabiim: and that's all you have to worry about, and it doesn't really matter what order you do things in, as long as they get done :)
14:00:50 <metaperl> SamB: I dont know... but you see my point? hmm, i guess you could write HTML to HTML transforms
14:01:05 <SamB> but it would seem a silly restriction
14:01:08 <fabiim> ok =)
14:01:22 <metaperl> SamB: what would seem a silly restriction?
14:01:34 <SamB> anyway, I was kidding about the SGML (how could you tell from the tree anyway?)
14:01:50 <edwardk> samb: every xml document isn't a valid sgml document, xml allows underscores and : in names, unicode characters, ends processing instructions differently, allows bigger documents, etc.
14:01:50 <Cale> blue: would you like a more comprehensive answer than that, or is that cool? :)
14:02:04 <Excedrin> what's the typical way to resolve ambiguous references to names that are defined in the local file as well as the Prelude?
14:02:08 <edwardk> samb: and the number of folks who really know the extra sgml stuff are dwindling fast ;)
14:02:09 <SamB> edwardk: um, hold up! they extended SGML to include all those things afaik.
14:02:24 <sjanssen> > let head = () in Prelude.head [1]
14:02:25 <lambdabot>  1
14:02:26 <edwardk> hrmm, i must be a little behind the times then
14:02:29 <SamB> probably a result of the specs being too expensive
14:02:40 <SamB> the part about SGML folks dwindling in numbers
14:02:41 <sjanssen> Excedrin: or you can import Prelude hiding (head)
14:03:01 <Excedrin> thanks, hiding is what I needed
14:03:19 <yax1> > sort "hello world"
14:03:20 <blue> it adds 1 to the first element,2 to the second and so on...
14:03:21 <lambdabot>  " dehllloorw"
14:03:49 <edwardk> the other thing is at last check xml element declarations follow a slightly different syntax as well so sgml dtd and xml dtds are rather different
14:04:40 <blue> cale:what answer?I know I need to do it recursively but I dont know how..
14:04:51 <Cale> blue: zipWith (+) [1..]
14:05:06 <blue> ??
14:05:08 <Cale> If you don't know about zipWith, that's maybe not so helpful :)
14:05:18 <Cale> > zipWith (+) [1..] [5,3,8,2,1]
14:05:20 <lambdabot>  [6,5,11,6,6]
14:05:22 <blue> what is zipwith?
14:05:50 <roconnor> @type zipWith
14:05:51 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
14:05:53 <Cale> zipWith f [x1,x2,x3,...] [y1,y2,y3,...] = [f x1 y1, f x2 y2, ...]
14:06:00 <yax1> > length $ filter (== 'o') "hello world"
14:06:02 <lambdabot>  2
14:06:13 <yax1> is that a silly way of counting?
14:06:28 <Cale> and if one of the lists ends, then the length of the resulting list is the shorter of the two lengths
14:06:45 <Cale> specifically,
14:06:52 <Cale> zipWith f [] ys = []
14:06:56 <Cale> zipWith f xs [] = []
14:06:56 <sjanssen> yax1: that is the standard way
14:07:13 <Cale> zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
14:07:34 <yax1> sjanssen: ah, thanks :)
14:08:13 <edwardk> Cale, you might derive a chuckle from this. so i've been playing with other operators to overload, and the desire to overload function application for the string and array cases in my toy language kept coming up. well, there is a unicode character for 'function-application' &2061; that gets classified by unicode as general punctuation, and hence by my language as infix so it strikes me that if define "f a" to me the application of the infix function appl
14:08:37 <edwardk> s/to me/to mean/
14:08:47 <Cale> edwardk: and it means something different from space?
14:08:51 <scodil> is Ptr () kind of the same as a void*?  How do you represent an opaque c-pointer in haskell?
14:09:08 <shapr> tibbe: HAppS has a similar philosophy, that shuffling data from application to database is an unnecessary step.
14:09:40 <tibbe> shapr: :) I'll look into it, I've been talking about it for way too long, I blame my thesis
14:09:41 <metaperl> shapr: who is this "tibbe" you are talking to?
14:09:42 <Philippa> nonono, you need that for durability. It's the other way round that's bad
14:09:43 <metaperl> oh
14:09:51 <edwardk> cale: well, what i mean is that the basic rule of the language would be that the only kind of 'function is infix application. so "f a" would be read as "f &#2061; a" after desugaring.
14:09:59 <SamB> U+0020 SPACE
14:10:01 <roconnor> scodil: Hmm, I think that is right.  () is analogous to C's void.
14:10:20 <tibbe> metaperl: :p
14:10:21 <Cale> scodil: yeah, though usually you have a better idea, so it's a good idea to make a simple newtype declaration like: newtype MyThing = MyThing (Ptr MyThing)
14:10:22 <edwardk> samb: i am aware. i did say after desugaring for my toy language. its very different than space =)
14:10:25 <metaperl> :)
14:10:25 <Philippa> I don't know that I'd translate void * to Ptr () though. And you can't cast it.
14:10:48 <SamB> edwardk: oh, that was just the space from your example...
14:10:57 <SamB> the one before you mentioned desugaring
14:11:05 <Cale> edwardk: haha
14:11:11 <sjanssen> @hoogle Ptr a -> Ptr b
14:11:45 <edwardk> cale: then you can define terrible things like let &#2061;  = : in 1 2 3 4 5 []
14:11:48 <Cale> blue: but if you'd like, we can do it another way
14:11:55 <edwardk> er with appropriate ()'s
14:12:12 <sjanssen> Philippa: there is Foreign.Ptr.CastPtr
14:12:19 <blue> sure
14:12:22 <sjanssen> s/Cast/cast
14:12:23 <edwardk> er let (&#2061;) = (:) in 1 2 3 4 5 []
14:13:23 <edwardk> anyways, tickled my funny bone, and it actually gives a very clean desugaring into infix-only operators
14:13:39 * edwardk returns to puttering
14:14:05 <Cale> note that every element of the list gotten by just sticking x onto the result of f applied to xs is one less than what we'd want f (x:xs) to be
14:14:16 <metaperl> what function counts the number of occurences of an item in a list?
14:14:18 <Cale> blue: does that make sense?
14:14:56 <metaperl> length $ grep (\x -> x == sought)
14:15:14 <metaperl> numOccurences sought = length $ grep (\x -> x == sought)
14:15:25 <sjanssen> metaperl: length (filter (== item) list)
14:15:32 <metaperl> sjanssen: sweet
14:15:44 <metaperl> @type filter
14:15:46 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:15:47 <Cale> So suppose we're computing f [10,20,30,40,50]. We have that f [20,30,40,50] = [21,32,43,54], so if we just stick the 10 on the front, we'll have [10,21,32,43,54] -- every element is 1 less than what we want.
14:16:01 <blue> we add (length of original list - length of tail of current list
14:16:24 <Cale> well, yes, but it's this special case of adding a single element which is important
14:16:44 <Cale> because when we go to define f recursively, we'll want to write a case for f [] and f (x:xs)
14:16:56 <Cale> and we'll want to write f (x:xs) in terms of f xs
14:17:37 <Cale> and what I'm saying is that x : f xs is *almost* right. Every element is one less than it ought to be. So how do we add 1 to all the elements?
14:18:19 <Cale> Do you know about map?
14:18:26 <blue> no
14:18:30 <Cale> oh, okay
14:18:43 <Cale> map is a function which applies a function to all the elements of a list
14:18:55 <Cale> > map (+1) [10,21,32,43,54]
14:18:56 <Pseudonym> G'day everyone.
14:18:57 <lambdabot>  [11,22,33,44,55]
14:19:09 <lisppaste2> metaperl pasted "Indentation problem... not sure how to indent "where" clause" at http://paste.lisp.org/display/29848
14:19:15 <Pseudonym> Sorry for the off-topicness, but any poor starving students living in Melbourne who would like a bit of extra money, meet me in #haskell-blah.
14:19:19 <metaperl> could someone help with that indent issue?
14:19:22 <Cale> how about list comprehensions?
14:19:28 <Cale> have you seen those?
14:19:39 <Cale> Or are we really starting from scratch?
14:19:48 <blue> I dont think so but what is it exactly?
14:20:01 <Philippa> Pseudonym: they definitely need to know Haskell?
14:20:02 <Cale> > [x + 1 | x <- [1,2,3,4,5]]
14:20:04 <lambdabot>  [2,3,4,5,6]
14:20:08 <Philippa> only there's another chan I could ask in...
14:20:15 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
14:20:16 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
14:20:39 <Pseudonym> Nope.
14:20:39 <Cale> > [(x,y) | x <- [1,2,3], y <- [1,2,3], x < y]
14:20:41 <lambdabot>  [(1,2),(1,3),(2,3)]
14:20:58 <Pseudonym> Victoria has an election coming up in next that two weeks, and we're short of polling officials.
14:21:03 <Philippa> ah
14:21:07 <blue> such as f list = [x|x<-list,mod x 2 ==0] ?
14:21:11 <Cale> yeah
14:21:24 <Cale> > [x | x <- [1..10], even x]
14:21:25 <lambdabot>  [2,4,6,8,10]
14:21:32 <Pseudonym> One day of work, $270+.
14:21:32 <blue> well I know now :)
14:21:36 <Cale> okay
14:21:43 <Cale> so
14:22:01 <Pseudonym> But we need people who aren't completely stupid.  That's why I'm asking here. :-)
14:22:04 <Cale> we could use a list comprehension to add 1 to each element of x : f xs
14:22:43 <Cale> So we get,  f (x:xs) = [y + 1 | y <- x : f xs]
14:22:58 <roconnor> @spell separate
14:22:59 <lambdabot> separate
14:23:52 <Cale> blue: see how that works?
14:24:02 <Cale> another way...
14:24:08 <Cale> If you know about zip
14:24:18 <Cale> zip [] ys = []
14:24:22 <Cale> zip xs [] = []
14:24:23 <lisppaste2> metaperl annotated #29848 with "a more logical function.. but still indent issues" at http://paste.lisp.org/display/29848#1
14:24:25 <blue> i dont... :(
14:24:33 <Cale> zip (x:xs) (y:ys) = (x,y) : zip xs ys
14:24:37 <Cale> that's the definition of zip
14:24:40 <Excedrin> metaperl: there's a missing paren
14:24:52 <Cale> > zip [1,2,3,4] [3,8,1,12,14]
14:24:54 <lambdabot>  [(1,3),(2,8),(3,1),(4,12)]
14:24:58 <metaperl> Excedrin: oh thanks
14:25:05 <Cale> see what that's doing?
14:25:29 <Cale> it's pairing up the elements of the two lists
14:25:38 <Cale> and the 14 gets chopped off
14:25:40 <blue> yeah
14:25:47 <Cale> because the first list wasn't long enough
14:25:48 <Cale> now
14:25:50 <Cale> > [1..]
14:25:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:26:03 <Cale> that's a short name for the list of positive integers
14:26:13 <Spark> > [..1]
14:26:14 <lambdabot>  Parse error
14:26:15 <Spark> aw
14:26:20 <lisppaste2> metaperl annotated #29848 with "infinite type error" at http://paste.lisp.org/display/29848#2
14:26:21 <Cale> we can zip it up with any given list to pair up the elements with their indices
14:26:32 <Cale> > zip [1..] [6,2,7,2,8,0,2,102,23,56]
14:26:34 <lambdabot>  [(1,6),(2,2),(3,7),(4,2),(5,8),(6,0),(7,2),(8,102),(9,23),(10,56)]
14:26:43 <metaperl> I'm going home... dont answer me now
14:27:03 <Cale> but that's not quite enough, we want to add those, so let's use a list comprehension...
14:27:14 <Spark> > map (\x=>-x) [1..]
14:27:15 <lambdabot>  Parse error
14:27:22 <Cale> f xs = [x + y | (x,y) <- zip [1..] xs]
14:27:23 <pitecus> When should I use liftM and when fmap?
14:27:48 <Cale> pitecus: they're basically the same, only liftM is specifically only for monads, and fmap for general functors
14:27:59 <Spark> > map (\x=>~x) [1..]
14:28:00 <lambdabot>  Parse error
14:28:07 <Spark> help!
14:28:16 <Cale> > map (\x -> -x) [1..]
14:28:17 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
14:28:26 <Cale> > map negate [1..]
14:28:28 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
14:28:29 <Spark> ah => is to do with types
14:28:32 <Cale> right
14:28:52 <Pseudonym> You can interpret it as an implication, or as an arrow ->
14:28:56 <Cale> blue: do you understand that list comprehension with zip?
14:28:58 <pitecus> Cale, so it doesn't matter much?
14:29:07 <kaol> > [-1, -2..]
14:29:09 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
14:29:15 <Cale> pitecus: not much, but it does affect the constraints that appear in your type signatures.
14:29:29 <Spark> > [0, 42, ..]
14:29:29 <lambdabot>  Parse error
14:29:31 <pitecus> ok
14:29:37 <Cale> > [0,42..]
14:29:38 <Spark> > [0, 42..]
14:29:39 <lambdabot>  [0,42,84,126,168,210,252,294,336,378,420,462,504,546,588,630,672,714,756,798...
14:29:40 <lambdabot>  [0,42,84,126,168,210,252,294,336,378,420,462,504,546,588,630,672,714,756,798...
14:29:41 <lisppaste2> Excedrin annotated #29848 with "fixed max usage" at http://paste.lisp.org/display/29848#3
14:29:52 <Cale> brb
14:30:01 <blue> f (x:xs) = [y + a | y <- x : f xs]
14:30:47 <Spark> > foldl (\x\(a,b) -> x+a+b) (zip [1..] [6,2,7,2,8,0,2,102,23,56]) 0
14:30:47 <lambdabot>  Parse error
14:30:48 <blue> where a =length(x:xs) - length(xs)?
14:31:54 <blue> I mean that a is sth that changes,but I dont want to change the length of the original list.Is it the length (x:xs) or it's changing too?
14:31:56 <Spark> > let (x,y) = (42,13) in x + y
14:31:58 <lambdabot>  55
14:32:03 <lisppaste2> Excedrin annotated #29848 with "more general / correct" at http://paste.lisp.org/display/29848#4
14:32:12 <Spark> > foldl (\x\y -> let (a,b) = y in x+a+b) (zip [1..] [6,2,7,2,8,0,2,102,23,56]) 0
14:32:13 <lambdabot>  Parse error
14:32:38 <yax1> Hm, I'm getting this from GHCI:
14:32:40 <yax1> GHC stack-space overflow: current limit is 8388608 bytes.
14:32:40 <yax1> Use the `-K<size>' option to increase it.
14:32:49 <yax1> but GHCI doesn't have a -K option
14:33:02 <Spark> erm i would have thought it would size the stack dynamically?
14:33:12 <Spark> if recursion is the emphasis, surely thats a necessity
14:33:20 <yax1> hm
14:35:11 <yaxu> well i guess there's something badly wrong with my code in any case
14:36:57 <yaxu> never mind, it works for a bit anyway :)
14:37:55 <Cale> yaxu: you're perhaps ignoring the part of the message which includes the letters +RTS ?
14:38:13 <Cale> maybe not... I don't know whether it's that specific in all cases
14:38:15 <Cale> anyway
14:38:34 <Cale> ./myprogram +RTS -K<size> -RTS <parameters>
14:39:21 <Cale> Stack overflows usually are an indication that you're accumulating some value and it's not being evaluated until very very late.
14:39:35 <Cale> > foldl (+) 0 [1..10000000]
14:39:39 <lambdabot> Terminated
14:39:42 <Cale> > foldl (+) 0 [1..1000000]
14:39:44 <lambdabot>  Exception: stack overflow
14:39:48 <Cale> there we go
14:40:45 <Cale> so what happened here is that it built up a computation which looks like ((...((0 + 1) + 2) + ... ) + 999999) + 1000000
14:41:11 <Cale> since that value may never be needed, it doesn't do any of the work of adding
14:41:15 <blue>  f xs = [x + y | (x,y) <- zip [1..] xs] Cale: what is this doing??
14:41:23 <Cale> blue: sure
14:41:38 <Cale> For each pair (x,y) in zip [1..] xs
14:41:58 <Cale>   add x and y and put it in the result list
14:42:07 <Cale> is a sort of imperativization of that :)
14:42:24 <Cale> now, what is (zip [1..] xs) doing?
14:42:34 <fnord123> hey cuties. I'm looking for some sweet haskell resources on constraint programming.
14:42:46 <fnord123> might lambdabot know where some are?
14:42:48 <Cale> It pairs up the first element of xs with 1, the second with 2, and so on
14:43:21 <scodil> why do I get multiple defintion link errors when I do ghc --make MyHaskellFile.hs MyCFile.c ?
14:43:50 <Cale> > zip [1..] [5,1,6,2,7]
14:43:51 <lambdabot>  [(1,5),(2,1),(3,6),(4,2),(5,7)]
14:43:56 <Cale> like that
14:44:01 <Cale> blue: does that make sense?
14:44:18 <fnord123> lambdabot: constraint programming
14:44:18 <yaxu> thanks Cale
14:44:25 <RemiTurk> hi everyone
14:44:31 <fnord123> lambdabot: help
14:44:43 <Cale> fnord123: Well, you can use the list monad to get some of that
14:45:07 <Cale> fnord123: There are languages (mercury comes to mind) which are extensions of Haskell specifically for constraint programming
14:45:17 <yaxu> Cale: that was the full error message, I'm using ghci rather than ghc if that makes a difference
14:45:32 <Cale> yaxu: ah, okay
14:45:34 <Spark> so laziness and recursion both punish the stack
14:45:39 <Spark> so why is the stack statically sized?
14:45:50 <Cale> It's not, but by default there's a maximum
14:45:50 <blue> yes but I dont want pairs I woant to add 1,2,..
14:45:54 <fnord123> I read quite a lot of references to Haskell being 'good' for constraint programming. So I figure I'll dust my skillz off.... I'll look up mercury
14:46:00 <Spark> ah right
14:46:04 <Spark> can you turn the maximum off completely then
14:46:06 <Cale> to prevent stack overflows from killing your machine
14:46:08 <yaxu> Cale: the debugging pointers are helpful, thanks
14:46:10 <Cale> I think so
14:46:26 <Cale> fnord123: Well, it is decent as it is
14:46:30 <yaxu> at this point i'd rather turn them off rather than debug
14:46:33 <Cale> fnord123: (even without extensions)
14:47:02 <yaxu> i have another haskell performance again tomorrow and only another hour or so to practise...
14:47:24 <yaarg> @type \xs -> head (sequence xs)
14:47:25 <lambdabot> forall a. [[a]] -> [a]
14:47:29 <Cale> fnord123: You might have a look at the list monad in particular, since it does a lot of this conversion of breadth-first algorithms into depth-first that you get in a constraint language.
14:47:56 <fnord123> ok
14:48:15 <Cale> fnord123: http://haskell.org/haskellwiki/Sudoku -- the first Sudoku solver here uses a custom monad
14:48:16 <fnord123> I think my search space for what I'm doing is too big for depth first. /me strokes his chin
14:48:17 <lambdabot> Title: Sudoku - HaskellWiki
14:48:34 <sdf> hello,does anyone know how to use a [Char]?
14:48:44 <Cale> sdf: 'use'?
14:49:00 <sdf> How can I find how many times the first list of [Char] appears in the second list?
14:49:26 <dcoutts> Cale, have you read in the latest issue of JFP, Prof Bird has a nice little Sudoku solver.
14:49:29 <sdf> e.g. : 1st list: ['a','b','a'],2nd list ['a','b','a','b','a','a','a','b','a'] and the program will have to return 3?
14:49:55 <Cale> dcoutts: Yeah, I saw that briefly
14:49:58 <dcoutts> Cale, it's developed out of a exercise he set for our first year students :-)
14:50:02 <Cale> dcoutts: I haven't read through it though
14:50:08 <dcoutts> me neither
14:50:16 <dcoutts> just saw it and laughed
14:50:35 <Cale> sdf: well, that would be the number of times that "aba" is a prefix of one of the tails of "ababaaaba", right?
14:50:55 <Cale> There's a function isPrefixOf in the list library (Data.List)
14:51:09 <dcoutts> cunning strategy though, getting JFP papers out of tutorial problems that you set
14:51:18 <Cale> also useful is the tails function from the same library
14:51:24 <Cale> > tails "ababaaaba"
14:51:26 <lambdabot>  ["ababaaaba","babaaaba","abaaaba","baaaba","aaaba","aaba","aba","ba","a",""]
14:51:29 <dcoutts> I should write up the practical I set as an 'educational perl' for JFP
14:51:35 <cjeris> > sonic "ababaaaba"
14:51:36 <dcoutts> maybe, when I have more time :-)
14:51:36 <lambdabot>  Not in scope: `sonic'
14:51:44 <cjeris> Cale: damn, i had some hope for a second.
14:51:47 <Cale> > filter (isPrefixOf "aba") (tails "ababaaaba")
14:51:48 <lambdabot>  ["ababaaaba","abaaaba","aba"]
14:52:07 <SimonRC> ?help tell
14:52:07 <Cale> this filters the list of tails for just those which start with "aba"
14:52:07 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
14:52:13 <SimonRC> heh
14:52:14 <SimonRC> handy
14:52:15 <Cale> > length (filter (isPrefixOf "aba") (tails "ababaaaba"))
14:52:16 <lambdabot>  3
14:52:20 <SamB> hmm, do they have internal tests for parts of GHC?
14:52:24 <Cale> and that computes the length
14:52:40 <Cale> don't worry about extra work being done, it's lazy
14:52:55 <Cale> it'll only do exactly as much work as is needed to compute that 3
14:54:39 <Cale> sdf: is that comprehensible, or too high-brow? Would you rather we try to implement this recursively at a low-level?
14:55:26 <sdf> that is to say: length (filter (isPrefixOf "x") (tails "y")) where x,y lists?
14:55:44 <tibbe> without the ""
14:55:45 <Cale> yeah, only "x" is the string of length 1, so delete the "'s
14:55:52 <tibbe> strings are lists
14:55:57 <fnord123> thanks for the link, Cale.
14:56:10 <RemiTurk> Cale: can I ask you two nasty MonadRandom questions?
14:56:20 <Cale> RemiTurk: sure
14:56:37 <nominolo> does any one have an idea how to get drift to compile?
14:56:49 <scodil> if you name a haskell function the same thing as a c function, will the names clash?
14:57:08 <scodil> like import foreign ccall "string.h strcmp" strcmp :: ...
14:57:14 <Cale> if it's "where are getRandoms and getRandomRs", that's just an oversight, and I really should update the wiki :)
14:57:31 <chessguy> 'evening
14:58:00 <nominolo> hm, nevermind
14:58:16 <RemiTurk> thanks. to start with, thanks for posting it. It was rather useful in a recent university project for me. then, it is currently under the "CaleGibbard/BSDLicense" (copied from the hawiki). Would you mind changing the copyright to the "simple permissive license"?
14:58:20 <dibblego> guten morgen
14:58:24 <RemiTurk> goeden morgen
14:58:41 <blue>  cale:zip makes pairs only?
14:58:53 <Cale> blue: yeah
14:58:56 <dibblego> what's the difference between filter and takeWhile?
14:59:08 <RemiTurk> Cale: (I have a rather large copyright-blurp in my code right now, and have to worry about more than 1 license right now ;))
14:59:16 <Cale> dibblego: takeWhile stops when it reaches the first element which fails the predicate
14:59:33 <Cale> RemiTurk: oh, what's the license of your code?
14:59:36 <dibblego> ah right, so I kept getting the same output because my list was sorted :)
15:00:32 <blue> Cale:is there sth like zip that doesnt make pairs but a simple new list?
15:00:33 <bringert> Lemmih: any luck with Hope?
15:00:53 <Cale> blue: there's zipWith, which instead of pairing, applies a given function
15:01:06 <Cale> (to the pairs which would have been generated)
15:01:11 <Cale> for example...
15:01:23 <Cale> > zipWith (+) [1,2,3] [20,30,40]
15:01:24 <lambdabot>  [21,32,43]
15:01:57 <Cale> > (+) 1 20
15:01:58 <blue> we do it in prelude?
15:01:58 <lambdabot>  21
15:02:04 <Cale> It's in the Prelude, yeah
15:02:11 <blue> Can I do it without zip things?
15:02:18 <RemiTurk> Cale: It's slightly undetermined so far: We (I and a friend) started with the (genetic algorithm) project a few years ago as a bachelor graduation project, continued it last semester for another course and are planning to submit it for publication in a few months. licensing isn't something we have thought all that much about so far ;) My few actual changes/additions to MonadRandom will definitely go to the wiki anyway)
15:02:31 <blue> I want to make a .hs file
15:02:41 * dcoutts is pleased with the density of features he just packed into 25 lines of code
15:02:47 <Cale> yeah, I just removed the BSD notice, which you can take to mean that it's available under the wiki license
15:02:52 <fnord123> what does it mean to have a Typename (defined with newtype) followed by a $ do ?
15:02:54 <RemiTurk> Cale: My second question _is_ about the few changes/additions ;)
15:03:07 <Cale> Though the wiki license is almost the same as the BSD one
15:03:20 <blue> I mean with a recursion or sth...?
15:03:23 <Cale> fnord123: you're probably looking at a data constructor
15:03:34 <Cale> fnord123: f $ x = f x, but $ has really low precedence
15:03:52 <Cale> blue: sure
15:03:54 <Lemmih> bringert: No change.
15:04:01 <Cale> we could do it from absolute scratch
15:04:06 <RemiTurk> Cale: thanks, that'll means my code will get a bit shorter again ;)
15:04:10 <bringert> Lemmih: did you try logging the html?
15:04:15 <bringert> *phone*
15:04:36 <Cale> let's define a helper function g, so that g n xs will add n to the first element of xs, n+1 to the second, and so on.
15:04:49 <Cale> so g n [] = []
15:05:05 <Cale> g n (x:xs) = ... : ...
15:05:21 <Cale> well, the head of the list that's returned will be n + x, right?
15:05:27 <Cale> so we'll fill that in
15:05:31 <nominolo> is there a common haskell module (or package) named "Doc" ?
15:05:32 <Cale> g n (x:xs) = (n+x) : ...
15:05:40 <dcoutts> nominolo, no
15:05:59 <blue> wahts n?
15:06:11 <Cale> a parameter, which we're going to set to 1 in the end
15:06:13 <nominolo> hm, then i wonder where jhc wants to have it from
15:06:25 <Cale> (but it needs to change during the recursion)
15:06:36 <Cale> f xs = g 1 xs
15:06:41 <Cale> is what we're going to write in the end
15:06:50 <nominolo> ah, found it .
15:07:17 <Cale> does that make sense? So we're actually generalising a bit, saying that we can start indexing with any number we please
15:07:40 <Cale> This is necessary, because as we work our way down the list, we're going to want to start off the recursive case with a higher index
15:07:49 <blue> g n (x:xs) = (n+x) : g xs
15:07:51 <RemiTurk> the other question(s): Is there any reason you didn't add an instance MonadRandom IO ? (I'll add it in a minute if you're not complaining ;)) And what about a MonadRandomSplittable class? (Which was rather important for my parallel genetic algorithm project, although I still have to read/understand "Don't trust parallel monte carlo")
15:08:03 <Cale> almost, but you forgot the new value for n
15:08:52 <Cale> RemiTurk: When I wrote it, I had a very specific purpose in mind. I didn't add the auto-lifting instances because in applications of the transformer, I like to provide all my own instances anyway.
15:09:04 <emu> @type flip id
15:09:05 <lambdabot> forall b c. b -> (b -> c) -> c
15:09:14 <blue> that is where n etc?
15:09:26 <emu> @type id
15:09:27 <Cale> blue:   g n (x:xs) = (n+x) : g <something> xs
15:09:27 <lambdabot> forall a. a -> a
15:09:37 <Cale> g has two parameters
15:09:51 <Cale> If you'd like, I can give it away :)
15:10:27 <blue> one more sho 4 me :)
15:10:31 <blue> *shot
15:12:07 <blue> sth =length(xs)
15:12:07 <blue> ?
15:12:15 <Cale> RemiTurk: really, the only part of the license I care about is the disclaimer of warranty :)
15:12:24 <Cale> blue: nope
15:12:27 <Cale> it's just n+1
15:12:37 <Cale> g n (x:xs) = (n+x) : g (n+1) xs
15:12:43 <blue> :O
15:12:49 <Cale> because that means that n+1 will be added to the first element of xs
15:12:57 <Cale> let's try it
15:13:06 <Cale> g 1 [10,20,30]
15:13:21 <Cale> = (1 + 10) : g (1 + 1) [20, 30]
15:13:29 <Cale> = 11 : g 2 [20, 30]
15:13:44 <yaxu> oops, ghci coredumped that time
15:14:00 <Cale> = 11 : (2 + 20) : g (2 + 1) [30]
15:14:08 <Cale> = 11 : 22 : g 3 [30]
15:14:12 <RemiTurk> Cale: darn, no suing for me then I'm afraid ;)
15:14:34 <Cale> = 11 : 22 : (3 + 30) : g (3 + 1) []
15:14:45 <Cale> = 11 : 22 : 33 : []
15:14:54 <Cale> = [11, 22, 33]
15:15:00 <Cale> see how that works?
15:15:04 <dons> ?users
15:15:04 <lambdabot> Maximum users seen in #haskell: 265, currently: 261 (98.5%), active: 61 (23.4%)
15:15:10 <dons> oh wow. 61 active.
15:15:10 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:15:17 <dons> just need 5 more people :)
15:15:29 <blue> :) now it seems clear
15:15:43 <blue> but when I get down to write sth its all chinese to me
15:15:45 <fnord123> apart from the gentle intro to haskell, are there any useful tutorials i may not have come across?
15:15:58 <Cale> blue: Writing things by direct recursion is tricky and confusing though -- you really do want to write things in terms of the larger building blocks in the library whenever you can, but those take time to learn, and there are arbitrarily many of them :)
15:16:05 <SyntaxNinja> @where yaht
15:16:06 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
15:16:18 <SyntaxNinja> fnord123: Yet Another Haskell Tutorial (above)
15:16:37 <dons> fnord123: almost certainly. check haskell.org under the 'Books and tutorials' link
15:16:37 <Cale> but the most important ones are probably  map, foldr, filter, and zip/zipWith
15:18:32 <fnord123> dons, I've been there and bookmarked the useful ones (one). last I checked, many only have snippets and not full examples so you can't cut and paste into a text editor to try it out.
15:18:37 <fnord123> which sucks. a lot.
15:19:14 <blue> what a haskell!!I wish it was just like pascal but its not :(
15:19:48 <dibblego> I am glad your wish cannot be granted
15:20:02 * RemiTurk heartily agrees with that
15:22:26 <fnord123> SyntaxNinja: that tutorial is very good looking. And in PDF so I can search it for literal strings (whereas online tutorials broken up by chapter dont afford me the pleasure)
15:23:35 <kowey> ?where+ yaht http://darcs.haskell.org/yaht/yaht.pdf
15:23:36 <lambdabot> Done.
15:23:46 <SyntaxNinja> blue: fortunately, Pascal exists for your hacking pleasure ;)
15:24:07 <SyntaxNinja> fnord123: people seem to like that tutorial.
15:26:25 <RemiTurk> dons: there goes the record...
15:26:58 <Cale> blue: it is a bit of a mindbending experience at first, but once you're used to being able to write things in terms of higher-order functions, and write your own, it will seem irritating to go back to loops.
15:28:45 <RemiTurk> blue: for me at least, that's especially true about things like map/filter/zip. I still ocasionally have to think about the order of the arguments of foldr/foldl. But I always have to think about my loops ;)
15:29:44 <blue> cale:yeah its mindtrap! :) I have a loooooooot to learn
15:29:46 <Cale> foldl is a lot trickier for me than foldr -- the way I think about foldr f z is that it's replacing each (:) with f and [] with z
15:30:24 <Excedrin> Cale: are monads the same (after getting used to them, it's irritating to go back to a language without)?
15:30:32 <Cale> Excedrin: yes
15:31:13 <mwc> I would say monads are so powerful haskell deserves to be called a Monad Orientated Language in the same way we hype up object-orientated languages for a comparitively less earth-shattering feature
15:31:21 <Philippa> irritating would be an understatement
15:31:33 <RemiTurk> Cale: I agree that foldr is conceptually easier. But I still try to write something like foldr (flip (:)) once a year ;)
15:31:41 <Philippa> if you care about correctness I think distressing is more accurate
15:31:52 <RemiTurk> Warm Fuzzy Thing Oriented Language?
15:31:54 <Excedrin> I've coded enough SML that I feel comfortable with higher order functions, and it annoys me when I code in Python and have to use for loops to deal with lists; but I'm not used to Monads yet
15:32:11 <Philippa> I'm tempted to suggest Semantically-Oriented Language
15:32:23 <Philippa> not least for the snarky suggestion that unlike other languages it's about what you /mean/
15:32:56 <Philippa> (but see what everyone calls the computational view of monads, etc etc)
15:33:21 <Botty> heh, a language that does what you mean not what you say
15:33:31 <Pseudonym> Isn't that Perl?
15:33:44 <Cale> Excedrin: monad transformers in particular make it so easy to construct domain specific languages quickly that it definitely changes the way that you think about problems
15:33:46 <Excedrin> that's Perl
15:34:03 <Pseudonym> Perl does what you mean even if you didn't quite mean it.
15:34:28 <Philippa> yeah. Phrases not to use around perl include "Fuck me gently with a chainsaw"...
15:34:32 <Cale> and there are things you can do like writing algorithms where the input comes in a generic monad, and which monad you choose will change the whole control flow of the algorithm, while maintaining correctness on some level
15:34:34 <Philippa> ...or maybe that's C
15:34:46 <Pseudonym> C doesn't understand phrases like that.
15:34:50 <glguy> Cale: I don't think that it is so obvious to the Haskell-learner that it is easy to create a DSL
15:35:05 <Cale> glguy: right
15:35:13 <Cale> glguy: I really have to write a tutorial about this
15:35:17 <Philippa> yeah, you have to've seen an example
15:35:31 <glguy> Cale: your Sudoku solver is a simple example, right?
15:35:33 <Cale> I wrote my Sudoku solver for exactly that reason
15:35:35 <Cale> yeah
15:36:18 <glguy> I think that the problem with the Sudoku solver is that a DSL seems a little bit too powerful in this cse
15:36:31 <glguy> what are you going to do besides: Load, Solve, Print?
15:36:32 <Cale> well, I spent no time at all working on the actual algorithm
15:36:33 <fnord123> when was ghc 6.4.2 released?
15:36:36 <Philippa> parsing isn't a good example if you want to use transformers
15:36:46 <Cale> If I wasn't so lazy, I'd write a better algorithm in the same DSL
15:36:51 <Philippa> which is a shame, it's beautiful for general implementation
15:36:53 <Cale> and get correctness guarantees for free
15:37:18 <yaxu> fnord123: 19 April 2006
15:37:21 <fnord123> oh ok
15:37:49 <fnord123> i just ran ports install to pick up whatever is the latest and was suprised to see I didn't have it
15:37:58 <Cale> glguy: well, the solve part could be much much more complicated
15:38:08 <Cale> glguy: and there's stuff in the language I set up to provide for that
15:38:17 <yaxu> fnord123: 6.6 is the latest
15:38:25 <glguy> Cale: I see
15:38:50 <geneticp> I just finised a  indexer & search module (80 lines of code). Haskell is greath
15:39:08 <geneticp> great
15:42:39 <sdf> Cale: i did this:
15:42:39 <sdf> f :: [Char] -> [Char] -> [Int]
15:43:09 <sdf> f [] [] = 0
15:43:09 <sdf> f x y = length (filter (isPrefixOf x)(tails y))
15:43:14 <Cale> sdf: not [Char] -> [Char] -> Int ?
15:45:20 <Daveman> Hi Xerox  :)
15:45:26 <dibblego> ?where hs-plugins
15:45:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
15:46:47 <geneticp> ?where GhcBinary
15:46:48 <lambdabot> I know nothing about ghcbinary.
15:47:18 <dons> gee, you turn your head on reddit for a couple of hours and it fills up with swill
15:47:21 <dons> ?users
15:47:22 <lambdabot> Maximum users seen in #haskell: 265, currently: 247 (93.2%), active: 55 (22.3%)
15:47:24 <dons> ah wel
15:48:10 <dons> hehe "Why is it unsafe to ask two values of different types if they're equal? Any decent language should allow you to compare objects of different types." -- doesn't quite get what 'types' are for
15:49:22 * RemiTurk learns new words on #haskell every day (swill this time)
15:49:29 <TSC> Couldn't you allow that, and make it always false for different types?
15:49:34 <TSC> (But then it's pointless)
15:49:53 <glguy> what's the point of asking a question you always know the answer to?
15:50:03 <glguy> does 'a' == [8] ?
15:50:13 <glguy> *nope* "but does it now?" *nope*
15:50:17 <glguy> ok, how about this time?
15:50:21 <dons> there lies the road to endless implicit casting bugs
15:50:40 <pitecus> ?pl unwrap . unwrap . fmap (fmap getHeadWordCat . getHeadSister)
15:50:41 <lambdabot> unwrap . unwrap . fmap (fmap getHeadWordCat . getHeadSister)
15:50:49 <glguy> if 'a' == [8] then x else y  -- is better written as: y
15:51:30 <RemiTurk> if you really want something like that you may want to take a look at Data.Typeable I think
15:54:35 <dibblego> dons, I just tried to do the "cleanest ever" build of lambdabot, but: http://rafb.net/paste/results/HXfLur25.html
15:55:57 <dons> looks like you built ShowQ.hs with a different ghc to the one used to build the rest of the bot?
15:56:30 <dibblego> I don't even know what ShowQ.hs is
15:56:50 <dibblego> but I have done a upgrade from ghc 6.4.1 to 6.4.2, which is when I started having problems
15:57:54 <sdf> cale: Int yep thats it but the same error appears
15:58:05 <dons> try a clean 'get', and build with ghc 6.4.2. i.e. cd /tmp ; darcs get /my/old/lambdabot ; ...
15:58:09 <pitecus> ?hoogle (a -> Maybe b) -> (Maybe a -> Maybe b)
15:58:10 <lambdabot> No matches, try a more general search
15:58:14 <dons> or you could try to ./Setup.hs clean
15:58:24 <dons> ?djinn (a -> Maybe b) -> (Maybe a -> Maybe b)
15:58:25 <lambdabot> f a b =
15:58:26 <lambdabot>   case b of
15:58:26 <lambdabot>   Nothing -> Nothing
15:58:26 <lambdabot>   Just c -> a c
15:58:28 <dons> interesting!
15:58:37 <dons> djinn++
15:58:49 <dibblego> I did a Setup.hs clean in the lambdabot directory if that's what you mean, but I'll try again
15:58:55 <pitecus> that was cool
15:58:57 <yaxu> aaaaaaaaaaaaaaaaa,mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmktrfg2gthujy8i
15:59:02 <pitecus> what is this djinn thing?
15:59:10 <dons> ?help djinn
15:59:10 <lambdabot> djinn <type>.
15:59:11 <lambdabot> Generates Haskell code from a type.
15:59:11 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
15:59:16 <pitecus> wow
15:59:22 <pitecus> :-)
15:59:25 <dons> ?djinn a -> a
15:59:26 <lambdabot> f a = a
15:59:31 <dons> ?. pl djinn a -> a
15:59:31 <lambdabot> f = id
15:59:33 <sjanssen> @type (=<<) -- looks familiar
15:59:36 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
15:59:48 <dons> mmm. nicely spotted
16:00:08 <dons> ?type (=<<) :: (a -> Maybe b) -> (Maybe a -> Maybe b)
16:00:10 <lambdabot> (a -> Maybe b) -> (Maybe a -> Maybe b) :: forall a b. (a -> Maybe b) -> Maybe a -> Maybe b
16:00:32 <yaxu> sorry, kitten attack
16:00:35 <dons> sjanssen++ sharp eyes
16:00:51 <dons> yaxu: heh. i guess that, or else your supercollider was running in reverse, and sending bytes back to you
16:01:08 <dons> morning ralf`
16:01:10 <yaxu> heh
16:01:11 <dons> ready for another round?
16:01:17 <ralf`> dons.  Mornin.
16:01:28 <ralf`> *sigh*
16:01:34 <ralf`> I still can't ping localhost.
16:01:44 <ralf`> I guess that doesn't have to do with haskell.
16:01:57 <ralf`> Maybe I'll make a blog to post my code today.
16:02:01 <ralf`> That has to do with haskell.
16:02:53 <dons> ok. good.
16:03:00 <dibblego> why does lambdabot fail to build: http://rafb.net/paste/results/zUAH2l19.html
16:03:30 <dons> mmm:
16:03:32 <dons> "At this point, it is possible to convert a Haskell program into
16:03:32 <dons> Javascript and create a XHTML page for viewing in a Web browser."
16:03:46 <dons> http://haskell.org/haskellwiki/Yhc/Javascript
16:03:48 <lambdabot> Title: Yhc/Javascript - HaskellWiki
16:03:52 <fnord123> whoa, optimizing constraints programs is a dark art
16:03:58 <sjanssen> dons: yes, that is exciting
16:04:06 <dons> dibblego: you didn't run ./configure ?
16:04:11 <dons> dibblego: ./configure executable?
16:04:32 <sjanssen> now we just need Yhc to support all of Haskell
16:04:38 <dibblego> gah I did but I missed the error Setup.hs: Error: file is not executable: "./configure"
16:04:46 <dons> sjanssen: right!
16:04:53 <sdf> Cale:what does tails does and whats the problem?It says its undefined variable..
16:05:32 <sjanssen> is there a checklist somewhere?  Maybe some low hanging fruit that I could attempt?
16:05:49 <fnord123> ive got a subset sum problem churning away on a set of 40 and it's taking hella long
16:06:08 <newbcoder> fnord123, I heard there's this magical language called C; it's pretty good at certain problems
16:06:19 <newbcoder> it's kinda hard to use; but supposedly whe nit works; it's relaly really fast
16:06:41 <dons> http://programming.reddit.com/info/qrph/details
16:06:44 <lambdabot> Title: Compiling Haskell to JavaScript (reddit.com), http://tinyurl.com/ua6bn
16:06:49 <dons> (our daily news item)
16:07:21 <fnord123> http://paste.lisp.org/display/29853
16:07:31 <guerra__> @paste
16:07:32 <lambdabot> http://paste.lisp.org/new/haskell
16:07:58 <sjanssen> fnord123: y'know, you don't have to indent everything after the module Main where
16:08:17 <fnord123> ok
16:08:39 <dons> and if its Main, you don't need 'module Main where' at all :)
16:09:02 <fnord123> some languages demand the module to be the same name as the file; ghc whined when I had it as such; couldn't find Main module, so I made the module "Main"
16:09:31 <fnord123> it's evolved code; in the literal biology sense of killing what didn't work and keeping what did
16:12:34 <dons> http://paste.lisp.org/display/29853#1
16:13:28 <ralf`> I'm looking for suggestions of blog spots.  Also, does anyone know an easy way to open links in erc?
16:13:54 <lisppaste2> guerra pasted "arguments error" at http://paste.lisp.org/display/29854
16:13:58 * SamB doesn't think "module" declarations should be alone in that property...
16:14:11 <guerra__> i have this piece of code (http://paste.lisp.org/display/29854)where i make calls to functions passing as argument calls to otehr fucntios. At the call (labelSetText painel $ geraStrings $ jogadaPC nim $ listXor nim) the compiler says im passin teh following line (nimGame painel lineInput decInput joga 1 $ jogadaPC nim $ listXor nim)  as parameter also what could that be?
16:14:13 <dons> ralf`: so you don't have a local server to run, you're looking for free online hosting?
16:15:33 <dibblego> > "I'm back"
16:15:34 <lambdabot>  "I'm back"
16:15:55 <dons> yay
16:15:59 <dibblego> not yet
16:16:06 <dibblego> lambdabot2 didn't respond
16:16:24 <dibblego> > "I'm back"
16:16:25 <lambdabot>  "I'm back"
16:16:53 <SamB> fine grained classes are a PITA to write instances for...
16:17:04 <lambdabot2> Terminated
16:17:10 <dibblego> I give up
16:17:13 <dibblego> lambdabot 1 dibblego 0
16:17:24 <eviltwin_b> guerra__: $ is not a comma.  if you want to pass multiple function invocations as parameters, you need to use parentheses
16:17:51 <fnord123> dont, non standard pattern guards. -fglasgow-exts to suppress. is this a new feature to go into the language spec/
16:17:59 <eviltwin_b> a $ b $ c d parses as a (b (c d))
16:18:02 <fnord123> s/dont/dons/
16:19:02 <ralf`> dons: I have a blog at syntaxthug.syntaxpolice.org/mathsciencetour, but it is quite elementary and has no code posted.
16:19:41 <sjanssen> @type foldr (const . Just) Nothing
16:19:42 <lambdabot> forall a. [a] -> Maybe a
16:19:46 <ralf`> I suppose I could just blog there, but then I would need to find some blogging software or else write the code myself to generate html.
16:19:51 <dons> fnord123: pattern guards are quite old (about 8 years or so)
16:19:52 <dcoutts> dons, you should ask sun if they'll sponsor your innovative research (check the buzzwords) by lending you a T1000 box: http://www.sun.com/tryandbuy/prm/perf/index.jsp
16:19:55 <lambdabot> Title: Sun Open Performance Contest, http://tinyurl.com/txb44
16:20:03 <dons> hmm!
16:20:17 <sjanssen> @pl subsets n xs = foldr (const . Just) Nothing (ss n xs)
16:20:18 <lambdabot> subsets = (foldr (const . Just) Nothing .) . ss
16:20:22 <guerra__> eviltwin_b: i did with parenthesis before, same error, i thik my $s are correc
16:20:32 <fnord123> dons, as I'm learning, I'm wondering if this is something I should be picking up in my style. I'm not being sarky, I'm genuinely curious.
16:20:34 <dcoutts> dons, they seem to be in the mood, all you need is to give them some free advertising.
16:21:02 <dcoutts> dons, of course that goes both ways, they'll publicise your research by linking it from sun.com
16:21:33 <dons> fnord123: I added it since I use pattern guards all the time. so it was a hint that you could use them to make the code smaller
16:21:45 <dons> dcoutts: very interesting. i'll forward it on to rl
16:21:54 <fnord123> dons, ok
16:22:03 <dons> since we're looking to buy a big sparc machine after the amd64 anyway
16:22:07 <dons> big == really big
16:22:13 <dcoutts> cool :-)
16:22:30 <dcoutts> dons, they're doing try before you buy on the T1000 and T2000
16:22:34 <Adamant> T1 chips?
16:22:39 <dcoutts> yep
16:22:54 <dcoutts> but they're probably not the really big that you're thinking about
16:22:54 <Adamant> exxxcellent </Mr. Burns Voice>
16:22:59 <dcoutts> :-)
16:23:28 <dcoutts> dons, so what is really big here? >40 cpus SMP ?
16:23:59 <dcoutts> it is exclusively SMP right? we're not talking about clusters
16:24:08 <Igloo> I remember when "big computer" meant it filled a room. Well, I don't, but that's not the point.
16:24:10 <ihope_> @docs
16:24:10 <dons> yeah, something > 32 cpus, I think
16:24:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:24:14 <guerra__> hail dcoutts ^^
16:24:17 <fnord123> I thought the T series didn't do parallelism very well
16:24:17 * Igloo has forgotten what the point was, though
16:24:32 <dons> not a cluster. we have a commodity cluster already
16:24:40 <dcoutts> right
16:24:41 <fnord123> they multi thread nicely amongst their own cores, but not when you have a server with xyz of them
16:24:54 <jgrimes> is there a page on the wiki dedicated to making sure your programs are ready for multicore auto-scaling?
16:25:02 <dcoutts> fnord123, I'm not quite sure what you mean
16:25:05 <dcoutts> guerra__, huh?
16:25:08 <jgrimes> or multiproc, whatever. :)
16:25:10 * fnord123 works on big computers that fill rooms still
16:25:35 <sjanssen> jgrimes: I don't think so.  There isn't any auto-magic parallelism yet, anyway
16:25:42 <guerra__> dcoutts nothing, just wanted to say that thanks to u i evoluted a lot in my stuff with haskell and gui :D
16:25:52 <dcoutts> oh, cool.
16:26:07 <fnord123> dcoutts: I seem to remember reading that the T1000 chips are great for multiple processes by themselves; but not when they're put together. i.e. they don't scale to big iron
16:26:11 * dcoutts likes the use of the word "evoluted"
16:26:19 <dcoutts> it should be a new biz buzzword
16:26:29 <dibblego> Evoluted Programming with Haskell
16:26:49 <dcoutts> fnord123, you mean having an SMP machine with lots of T1 style chips.
16:27:05 <fnord123> I wouldn't mind a little red book of the yaht called "Revolutionary Programming with Haskell"
16:27:33 <fnord123> dcoutts: yes
16:27:35 <jgrimes> sjanssen, hm, ok.
16:27:54 <guerra__> haha
16:27:56 <guerra__> ^^
16:28:04 <dcoutts> fnord123, interesting, I wonder if that's inherent in the design or just with the current implementation.
16:28:21 <dcoutts> it seems a very sensible way to go
16:28:30 <sjanssen> jgrimes: in GHC today, you have to annotate your code with par (like seq, but trickier) to tell the compiler to spin the computation off in another thread
16:28:34 <robreim> guerra__:  you can show your appreciation by giving him more karma :)
16:28:38 <fnord123> I think it was a current implementation thing. something to do with caches not syncing with shared main memory properly
16:28:47 <dcoutts> ah right
16:29:03 <guerra__> robreim: how is that?
16:29:12 <fnord123> my memory on this is dodgy. in fact, it might even be a link I got from /.
16:29:16 <fnord123> :(
16:29:19 <dcoutts> heh
16:29:24 <robreim> You say <nick>++  I think
16:29:25 <jgrimes> @type par
16:29:27 <lambdabot> Not in scope: `par'
16:29:29 <robreim> @karma dcoutts
16:29:29 <lambdabot> dcoutts has a karma of 29
16:29:39 * dcoutts grins
16:30:06 <guerra__> @karma dcoutts
16:30:07 <lambdabot> dcoutts has a karma of 29
16:30:12 <guerra__> haha cool
16:30:18 <guerra__> i need to learn these things :P
16:30:32 <dcoutts> guerra__, have you met @pl and @hoogle yet ?
16:30:37 <robreim> guerra__: that just shows how much karma he has. The ++ command will give him more.
16:30:37 <fnord123> fnord123++
16:30:47 <robreim> dcoutts++ (for the excellent work on gtk2hs ;)
16:30:49 <fnord123> @karma fnord123
16:30:49 <lambdabot> You have a karma of 0
16:30:50 <robreim> @karma dcoutts
16:30:51 <lambdabot> dcoutts has a karma of 30
16:31:03 <jgrimes> sjanssen, ok, thanks.
16:31:08 * dcoutts is clearly a karma whore
16:31:22 <fnord123> dcoutts: any relation to the private bank?
16:31:28 <robreim> @karma robreim
16:31:28 <lambdabot> You have a karma of 0
16:31:29 <guerra__> dcoutts++ (for being patient with newbies) hahaha
16:31:34 <dcoutts> fnord123, sadly not :-(
16:31:39 <robreim> heh, I've lost all my karma from changing nicks :P
16:31:41 <jgrimes> ok, I'm slightly confused by this... "a par b is exactly equivalent semantically to b."
16:31:46 <dcoutts> fnord123, not related to Money Coutts
16:31:57 <guerra__> dcoutts no didnt meet
16:32:18 <dcoutts> jgrimes, yes, because the parallelism doesn't affect the resulting value
16:32:23 <guerra__> dcoutts nor with all these actions things
16:32:38 <jgrimes> dcoutts, oh, right.
16:32:42 <dcoutts> jgrimes, the evaluation strategy is still non-strict so it's not changing semantics
16:33:13 <SyntaxNinja> ralf`: hi
16:33:28 <sjanssen> jgrimes: writing "a `par` b" declares to the compiler that it may be advantageous to evaluate a concurrently with b
16:34:03 <jgrimes> but it doesn't necessarily mean it is going to compute "a", like dcoutts said, since it is still non-strict semantics
16:34:12 <jgrimes> right?
16:34:15 <sjanssen> right
16:34:21 <jgrimes> ok
16:34:23 <jgrimes> cool.
16:35:28 <fnord123> one more DotA before bed.
16:35:30 * RemiTurk thinks he'll get some sleep before adding MonadRandomSplittable to the wiki (I'm liable to post grabage right now I'm afraid)
16:35:31 <sjanssen> I usually end up writing something like: "let x = stuff; y = junk; x `par` y `seq` x `seq` combine x y"
16:35:34 <fnord123> byebyes. thanks for the tips and help!
16:35:39 <fnord123> dons++ dcoutts++
16:35:47 <fnord123> SyntaxNinja++
16:36:13 <ralf`> SyntaxNinja: Hi.
16:36:23 <ralf`> *++
16:36:59 <jgrimes> sjanssen,  I'll have to look up combine :)
16:37:12 * ralf` thinks that plants are the best computers.
16:37:19 <RemiTurk> powerplants?
16:37:25 <sjanssen> jgrimes: I made I typo, I meant to write "baz" instead of "combine"
16:37:37 <jgrimes> oh ok
16:37:39 <jgrimes> :)
16:37:44 <jgrimes> I saw that combine was TH
16:37:51 <SyntaxNinja> ralf`: I sent you a private message, can you see it?
16:37:54 <jgrimes> and was wondering how that might apply.
16:38:12 <ralf`> I think that moving from heirarchical filesystems to tagged files will be a good early step towards a completely functional operating system.
16:38:15 <ralf`> Isaac, I can't.
16:38:27 <ralf`> I'm using erc, and I haven't figured out how to do that yet.
16:38:59 <RemiTurk> good night
16:38:59 <ralf`> I just typed "/nickserv identify".  Maybe now I can see it.
16:39:04 <ralf`> RemiTurk: night.
16:39:23 * guerra__ feels hungry
16:39:43 <ralf`> guerra__: Are you the one that's writing nim in portuguese?
16:39:44 <guerra__> :p
16:39:53 <guerra__> ralf`: yes
16:40:01 <SyntaxNinja> ralf`: you're ben, right?
16:40:07 <ralf`> That's pretty interesting.
16:40:14 <SyntaxNinja> ralf`: /join #talktoralf
16:40:15 <ralf`> SyntaxNinja: I'm ralf benjamin.
16:41:05 <Igloo> Is ralf` Ralf-from-ICFP-et-al?
16:41:08 <guerra__> ralf`: have u made it before? im making for my programming language classes
16:41:55 <ralf`> guerra__: No.  I've played nim, and I've programmed haskell, but never explicitly at the same time.  I also speak some portuguese.
16:42:16 <ralf`> guerra__: By the way, I was never able to find a good online English/Portuguese dictionary.
16:42:27 <guerra__> ralf`: cool - entenderia se eu falasse palavres? hehehehe
16:43:17 <dons> hmm. we have #haskell.es, we need #haskell.pt !
16:43:28 <dons> ?users #haskell.es
16:43:29 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 6 (46.2%), active: 4 (66.7%)
16:43:56 <dcoutts> dons, the pdf they sent us looks fine to me (except that they moved the graphs page by one)
16:44:17 <lisppaste2> guerra annotated #29854 with "the error i get" at http://paste.lisp.org/display/29854#1
16:44:34 <guerra__> thats my paste and the error i get
16:44:44 <guerra__> have been stuck on this
16:45:14 <dons> dcoutts: yeah. looks fine to me too
16:45:32 <dons> p50-64 I see
16:45:39 <dcoutts> yep
16:45:50 <dcoutts> is that in any way significant ?
16:46:05 <Igloo> You can probably work out when your talk is likely to be from it
16:46:14 <dcoutts> Igloo, we're up second
16:46:18 <dons> :)
16:46:19 <dcoutts> Igloo, after the invited talk
16:46:22 <dcoutts> woo!
16:46:31 <dons> which means we get to relax for 2 days!
16:46:32 <Igloo> Oh, I thought they tended to be in talk order
16:46:44 <dcoutts> dons, hah hah, yeah, brilliant
16:47:05 <dons> i always hate having my talk late or last, since you worry about it for the entire conference
16:47:11 <dcoutts> dons, and or quiz the erlang people about bit stuff and (de)serialisation
16:47:21 <dons> yeah
16:47:30 <dons> prepare some tricky questions before hand ;)
16:47:30 <Igloo> Who's going to do the talking?
16:47:40 <dcoutts> dons, oh and there's a fusion talk at POPL we should go to
16:47:43 <guerra__> how do i find out about @pl and @hoogle?
16:47:45 <dons> ah good
16:47:51 <dcoutts> Igloo, we've not decided yet :-)
16:48:01 <Igloo> heh, fair enough
16:48:12 <dons> yeah, I don't mind either way. we've both given talks on the topic enough now
16:48:29 <dons> dcoutts: oh, did you want to make any feedbcak on hac07/
16:48:29 <Pupeno> ?users #haskell.es
16:48:30 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 6 (46.2%), active: 4 (66.7%)
16:48:49 <dcoutts> dons, yes at some point. But right now I'm hacking on the gtk2hs code gen :-)
16:49:01 <dons> Igloo: were people concerned that 2 days is too much?
16:49:12 <dcoutts> 2 days doesn't seem too much to me
16:49:20 <dcoutts> seems a bit short :-)
16:49:21 <dons> no. ok. i see what Igloo wrote.
16:49:22 <Igloo> dons: I'm more worried it will be too short to achieve much, personally  :-)
16:49:27 <dons> yeah :)
16:49:37 <dcoutts> guerra__, @hoogle is a name and type based haskell api search
16:49:53 <dons> if 2 days works fine, we can push it out for the next one
16:49:54 <dcoutts> @hoogle getch
16:49:55 <lambdabot> Prelude.getChar :: IO Char
16:49:55 <lambdabot> Control.Concurrent.Chan.getChanContents :: Chan a -> IO [a]
16:49:55 <lambdabot> IO.hGetChar :: Handle -> IO Char
16:50:06 <sjanssen> hac07?
16:50:14 <dcoutts> @hoogle [a] -> [a]
16:50:15 <lambdabot> Prelude.cycle :: [a] -> [a]
16:50:15 <lambdabot> Prelude.init :: [a] -> [a]
16:50:15 <lambdabot> Prelude.reverse :: [a] -> [a]
16:50:21 <dcoutts> guerra__, see ?
16:50:28 <guerra__> dcoutts coooooooool
16:51:19 <dons> I like the logos Igloo, thanks!
16:51:22 <dcoutts> guerra__, and @pl is a code refactoring tool, it converts expressions into 'point free' style, which some people consider superior. Sometimes the result is unreadable however, so take it with a pinch of salt.
16:51:27 <Igloo> dons: Another option would be to go for 3 days, but possibly decide to abandon the last day if we've had enough, but that relies on people being interested in sightseeing around Oxford or something in its place
16:51:35 <dcoutts> Igloo, heh, yeah I like the lambda on the oxford skyline
16:51:57 <dons> Igloo: yeah, I think maybe 3 days is a good idea.
16:52:01 <guerra__> dcoutts i see ^^
16:52:11 <dcoutts> @pl \f -> map (\x -> f x) xs
16:52:12 <lambdabot> flip map xs
16:52:13 <dons> with people able to wander off on day 3 if needed
16:52:26 <Igloo> I think people within the UK will be able to return early at no extra cost anyway
16:52:59 * Igloo passes the logo praise on to my logo assistant
16:53:07 <dcoutts> :-)
16:53:22 <guerra__> @hoogle [a] -> a -> [a]
16:53:23 <lambdabot> List.intersperse :: a -> [a] -> [a]
16:53:24 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
16:53:24 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
16:53:39 <guerra__> love this ^^
16:53:40 <Igloo> Which is your favourite?
16:53:42 <robreim> guerra__: still having trouble with that IO (ConnectId Button) thing?
16:53:54 <dcoutts> Igloo, I'm less convinced by the hack part of the logo, but I love the lambda skyline silhouette
16:53:57 <guerra__> robreim: nope, fixed it yesterday
16:54:08 <robreim> cool
16:54:13 <Igloo> dcoutts: With or without test? And which font?
16:54:24 <guerra__> robreim: thanks, now the problem is other http://paste.lisp.org/display/29854#1
16:54:29 <robreim> I just saw your paste from 5 minutes ago and thought you were still having problems with it.
16:54:36 <Igloo> dcoutts: And what change would you make? Just remove the axe?
16:54:43 <robreim> Oh. That's the same problem, guerra__
16:55:03 <dcoutts> Igloo, yep, I'd go for the skyline one without the axe.
16:55:04 <guerra__> robreim: the same i was having before?
16:55:09 * Igloo thought it would be nice to have some part consistent between this and future Hackathons, but I also have no artistic taste or skill
16:55:31 <dcoutts> Igloo, for the text I might just overlay "Hackathon 2007" or something
16:55:46 <robreim> See how you've got the two do blocks with one of them saying onClicked? That one's returning onClicked's return value. If you want it to return (), put a return () after it in that do block.
16:56:10 <robreim> Yeah, it's the same problem as before.
16:56:24 * Igloo prods dons for opinions
16:57:02 <guerra> robreim: humm
16:57:03 <dcoutts> dons, I'll have to check if we have an upper limit on numbers.
16:57:06 <dons> hmm. I was thinking of something vaguely like a hammer and lambda.
16:57:16 <dons> dcoutts: yes, good idea.
16:57:33 <dons> Igloo: i do like the idea of a common element for this and future hackathons
16:57:42 <dons> since we may be able to pull one off every 6 months..
16:57:57 <dons> given POPL/ICFP as a natural organising structure
16:58:19 <Igloo> Except they are 2/3 and 1/2 the time in the US respectively, aren't they?
16:58:37 <dons> not sure about popl, but 1/2, yes, for ICFP
16:58:40 <dcoutts> dons, if we have lots of people then certain admin staff might get concerned with whos who etc, door access etc.
16:58:55 <dons> right. i'm thinking we dont' want more than hmm.. 20?
16:58:57 <dcoutts> dons, so we'd probably need registration
16:59:04 <dons> that's fine , yes.
16:59:21 <guerra> robreim: think i understood :P
16:59:59 <Igloo> I don't think that's a problem, it's fire regs for the room that will become a problem first I suspect
17:00:00 <dons> Igloo: is the background image of oxford available somewhere, in case I want to have a hack on it ?
17:00:05 <robreim> guerra: tell it to me in your own words :)
17:00:12 <dons> right, so we need to know how big the room is
17:00:20 <dons> and what kind of facilities? desks/ chairs? tables?
17:00:26 <guerra> robreim: lemme think lol
17:00:33 <Igloo> dons: It's the low res (inline) image from http://en.wikipedia.org/wiki/Image:Oxford_Skyline_Panorama_from_St_Mary%27s_Church_-_Oct_2006.jpg
17:00:35 <lambdabot> http://tinyurl.com/y4fwbh
17:00:42 <dons> cheers
17:00:47 <dcoutts> dons, I'll check about in the lab tomorrow, I might be able to get an academic member of staff to sponsor the event which would make things easier with the admin staff.
17:00:58 <dons> ah ok. yes.
17:01:02 <dons> that would be good
17:01:26 <dcoutts> I'm not sure how the lab would react to a mere grad student inviting 20 people to a 2 day conference :-)
17:01:34 <dons> heh
17:01:38 <guerra> robreim: the erro is in the nested dos?
17:02:04 <Igloo> dons: http://urchin.earth.li/~ian/banner_logo.xcf is the image with the lambda/axe in one layer (with a mask to get it behind the buildings in the foreground) and that image in another
17:02:23 <dcoutts> dons, but for example Jeremy Gibbons is hosting twice that many this Thursday
17:02:32 <dcoutts> for the fun in the afternoon thing
17:02:34 <robreim> guerra: not quite. For that last guard (the who == 1 && not (listaZerada nim) one), what do you expect it will return by reading it?
17:03:08 <dons> dcoutts: ah right. good.
17:04:25 <guerra> robreim: it goes to recursive calls, but at the end should give me IO()
17:05:10 <ralf`> guerra: pode falar palavrinhos.
17:05:37 <robreim> guerra: ok, what's the last expression in that guard?
17:06:30 <guerra> ralf`: huahua were u searching for the meanings? not palavrinhos, but plavres, thats a big word in literal translation, palavroes are slams
17:07:03 <guerra> robreim: a call to the same function
17:07:42 <ralf`> Igloo: I was at icfp.
17:07:44 <robreim> guerra: you mean that "nimGame" expression at the end of the nested do block? No, that's the final expression for that do block, but not for tho whole guard. Have another look.
17:08:44 <ralf`> guerra: Where's your latest code for nim?
17:08:47 <guerra> robreim: ya i have none
17:09:01 <guerra> ralf`: still not ready
17:10:20 <guerra> robreim: i mean, not expressions for the do before onclicked
17:10:26 <robreim> guerra: That nested do block has a return type of IO (), it's true. But it's returned to onClicked, not returned as the final expression of that guard. So, given that knowledge, what do you think is the final expression for the guard? (hint, it's the final expression of the outer do block)
17:11:09 <robreim> guerra: yes! So where's that guard's output type coming from?
17:11:18 <guerra> robreim: i see and since im not returnin an io for the for that guard gives me errors
17:11:25 <guerra> robreim: got it
17:11:33 <guerra> robreim: hah thanks :D
17:11:38 <guerra> robreim++
17:11:54 <robreim> heheh, close, but still not it actually :) It's returning what onClicked returns.
17:11:56 <Pupeno> HAppS doesn't work with HaXmL
17:12:02 <robreim> What's the type of onClicked?
17:12:20 <robreim> Have a look at your error message and compare it to the type of onClicked
17:13:11 <guerra> yes, that connect thing
17:14:23 <robreim> Yes. So since your onClicked expression is the final expression for that guard, the whole guard's output type expression is onClicked's output type, ie IO (ConnectId Button). But nimGame is supposed to have a type of IO ()
17:14:37 <robreim> So how do you make it have a type of IO () when you've called an onClicked?
17:15:06 <guerra> return ()
17:15:23 <robreim> guerra: you've got it :)
17:15:40 <guerra> robreim: nice explanation ^^
17:16:19 <robreim> guerra: ok, want to try to explain it again in your own words?
17:16:40 <guerra> robreim:  yes, gimme 2 minutes
17:21:15 <guerra> robreim: the problem was the following: i had a do with a onClicked event on it, this onclicked event was the las expression and was returning something different from what was expected (IO() expected infered IO connect thingy
17:21:44 <dons> Cale: since you originally suggested >=>, what's your opinion on just using >>> and <<< via an additional Control.Arrow import?
17:22:00 <dons> I'm trying to understand why that wouldn't be enough
17:22:07 <Cale> dons: I didn't initially suggest that
17:22:13 <dons> (barring maybe a reexport from Control.Monad?)
17:22:25 <dons> Cale: oh, I thought you made the original suggestion to add Kleisli combinators?
17:22:28 <dons> a few weeks ago?
17:22:29 <SamB> dons: you can't make Monads all instances of Arrows...
17:22:34 <SamB> er. of Arrow...
17:22:36 <Cale> Oh, I thought you were talking about the name
17:22:43 <dons> nope. the functionality :)
17:22:58 <Cale> I was saying that Kleisli composition should be available from the Prelude or Control.Monad
17:23:11 <Cale> the name I originally suggested was @@
17:23:12 <SamB> you need to wrap it with a Kleisli to use >>>
17:23:22 <Cale> but <<< is fine
17:23:24 <dons> SamB: hmm? instance Monad m => Arrow (Kleisli m) ... looks ok to me
17:23:41 <SamB> @hoogle Kleisli
17:23:41 <robreim> guerra: yep! Cool. Also, it may help you to understand return. What that does is it takes a value, wraps it up in the monad it's being called from and returns it.
17:23:44 <SamB> dons: it works
17:23:48 <robreim> @type return
17:23:51 <robreim> ?type return
17:24:03 <dons> Cale: but do we need to add the functions at all?
17:24:07 <Cale> dons: that involves wrapping the monadic values in Kleisli
17:24:08 <SamB> @where hoogle
17:24:21 <dons> so it would be an issue for new monads?
17:24:23 <guerra> robreim: cool
17:24:28 <robreim> where for art thou lambdabot?
17:24:39 <dons> ?bot
17:24:40 <Cale> So you need to write  Kleisli f >>> Kleisli g
17:24:46 <dons> you do?
17:24:50 <SamB> yeah! duh!
17:24:58 <dons> main :: IO ()
17:24:58 <dons> main = (x >>> y) 7
17:24:58 <dons> x :: Integer -> IO ()
17:24:58 <dons> x = printf "%d\n"
17:24:58 <dons> y :: b -> IO ()
17:25:00 <dons> y = const (print "done")
17:25:22 <SamB> dons: what happened to lambdabot, anyway?
17:25:27 <dons> looking...
17:25:29 <robreim> guerra: so return "foo" would have a return type of "m String" where m is a monad. If you were to put that in a IO monad you'd get a IO String. In a state monad you'd get State String.
17:25:37 <robreim> So your return () gives you a type of IO ()
17:26:08 <guerra> robreim: i see ^^
17:26:53 <dons> can someone hack up a useful use of >>> that does require Kleisli wrappers to work?
17:27:11 <SamB> dons: what is that?
17:27:14 <dons> or, why don't I need to above?
17:27:23 <SamB> how should *I* know!
17:27:31 <SamB> well, without lambdabot
17:28:30 <dons> doesn't the Monad instances for Arrow/Kleisli do the wrapping?
17:29:50 <robreim> ?type return
17:29:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
17:30:42 <guerra> robreim: cool man, with that my nim game is mostly finished
17:31:27 <robreim> good good
17:32:12 <guerra> robreim: not a state of teh art, but enough for its porpouses :P
17:32:31 <coffeemug> hey guys
17:32:33 <dons> hey
17:32:40 <coffeemug> hey dons
17:32:41 <coffeemug> how goes it
17:33:05 <coffeemug> I discovered a fromMaybe today (and the likes)
17:33:09 <dons> hehe
17:33:12 <coffeemug> man, I wish I knew about these before
17:33:14 <dons> ?type fromMaybe
17:33:15 <lambdabot> forall a. a -> Maybe a -> a
17:33:27 <coffeemug> this is golden
17:33:31 <dons> ?djinn a -> Maybe a -> a
17:33:32 <lambdabot> f a b =
17:33:32 <lambdabot>   case b of
17:33:32 <lambdabot>   Nothing -> a
17:33:32 <lambdabot>   Just c -> c
17:33:34 <dons> cool
17:33:43 <coffeemug> I was making small functions like that
17:33:48 <dons> ah right
17:33:59 <coffeemug> and wondering why the hell didn't anyone bother to put this in the standard libs
17:34:02 <coffeemug> turns out they did :)
17:34:05 <dons> hehe
17:34:18 <coffeemug> hey, I have a cabal question
17:34:26 <dons> these are the usual cata/ana/hylomorphisms on data types. they could be generated for free just about
17:34:35 <coffeemug> when I use data files I specify them to cabal
17:34:45 <coffeemug> and it generetas Paths_pkgname that I can import
17:35:05 <coffeemug> so when I do this everything builds and installs great
17:35:18 <coffeemug> but I can't use ghci anymore because it can't find Paths_pkgname module
17:35:30 <coffeemug> is there a good way to solve this?
17:35:41 <robreim> ?type maybe
17:35:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:35:54 <dons> hmm. not sure. need a cabal expert. haskell-cafe@haskell.org perhaps?
17:35:58 <dons> someone might have had this issue
17:36:21 <dylan> thank the gods for stealing wifi from the neighbors... otherwise, this weekend would've been entirely offline
17:37:24 <coffeemug> :)
17:37:36 <coffeemug> yeah, being offline is unbearable
17:37:40 <coffeemug> lol
17:37:49 <dylan> for an entire weekend, hell yes.
17:37:51 <coffeemug> dons: can I specify a path to ghci somehow?
17:37:57 <dylan> the cable company cmae to disconnect someone's connection, and disconnected ours. grrr.
17:38:58 <dylan> dons> well, I just have to work on colors, and my slang binding will be feature-complete. I suppose I should look into tying it with some ppr thingy?
17:39:35 <dons> coffeemug: you can always write a local ./ghci wrapper script that passes the correct path to ghci, yeah
17:39:52 <dons> for lambdabot I have a ./ghci containing:
17:39:53 <dons> ghci -Wall -Werror -fglasgow-exts -I. -pgmF ./BotPP -F -fno-warn-incomplete-patterns -fno-warn-missin
17:39:56 <dons> g-methods -fno-warn-orphans -DGHCi -hidir $Odir -odir $Odir $*
17:39:59 <SamB> dylan: can't they just snip the wires at the box?
17:40:07 <SamB> or better, open the box and extract them?
17:40:09 <dons> dylan: hmm great!
17:40:13 <dylan> SamB> they did it at the telephone poll!
17:40:25 <SamB> ... telephone pole?
17:40:35 <dylan> well, power line pole.
17:40:51 <dylan> the local vernacular dubs those "telephone poles'
17:40:52 <coffeemug> dons: I'm just wondering if you can "add" a directory where it would look for modules
17:40:58 <coffeemug> aside from the current dir
17:41:01 <pzpz> anyone pro with graphviz?
17:41:10 <SamB> dylan: sure, some ofthem are telephone poles...
17:41:25 <dons> coffeemug: you can.
17:41:29 <dylan> SamB> even metal ones that contain high voltage lines are telephone poles.
17:41:29 <dons> with -I
17:41:39 <robreim> Can someone knowledgable about haskell's type system explain to me what's wrong with "http://paste.lisp.org/display/29804" (someone else's bug but I'm dying to understand it)
17:41:41 <dibblego> ?type (&)
17:41:43 <lambdabot> Not in scope: `&'
17:41:46 <dibblego> ?type (&&)
17:41:47 <dons> look for 'include ' or 'search' paths in the user's guide
17:41:47 <lambdabot> Bool -> Bool -> Bool
17:41:56 <dons> ?hoogle( .&.)
17:41:57 <lambdabot> Maybe you meant: hoogle hoogle+
17:41:59 <dons> ?hoogle (.&.)
17:42:01 <lambdabot> Did you mean: (.&.)
17:42:01 <lambdabot> Prelude.undefined :: a
17:42:01 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:42:10 <dylan> pzpz> what's the question? I use graphviz frequently, though I'm no pro...
17:42:10 <dons> yes silly hoogle
17:42:13 <SamB> actaully I guess technically the ones in front of *my* house are too, since I think that is where our phone lines go....
17:42:37 <coffeemug> dons: thanks
17:42:45 <SamB> but it is hard to think of them that way when our phone company is actually a cable company...
17:43:23 <SamB> but if they did something wrong, I could always go assault their storefront...
17:43:52 <pzpz> dylan: would there be any method for preventing the graph from looping? IE, a->b, b->c, c->a ; i'd like a to be a "leaf" node
17:43:56 <pzpz> without having to rename a
17:44:20 <dylan> Isn't that by definition a loop?
17:44:34 <SamB> have you seen Data.Graph.Inductive?
17:44:40 <SamB> I dunno if that helps much or not...
17:45:06 <SamB> oh oh oh.
17:45:14 <SamB> graphviz ;-)
17:45:16 * SamB thinks
17:45:23 <pzpz> Well, I don't want it to loop. I want two instances of a
17:45:30 <SamB> I think you want dot
17:45:33 <SamB> oh !
17:45:35 <pzpz> i'm using dot :)
17:45:48 <SamB> you need to use different actual names
17:45:52 <SamB> I think
17:45:52 <pzpz> like, is there a way to declare a seperate node that has a dupilcate name?
17:46:00 <SamB> with identical labels
17:46:31 <coffeemug> dons: thanks for your help
17:46:34 <pzpz> yah -- that's the dirty method. i was hoping there was some sort of dot flag that did this for me :)
17:46:34 <coffeemug> back to coding :)
17:49:16 <SamB> pzpz: you are supposed to write programs to generate your .dot files for you
17:49:53 <pzpz> of course
17:50:14 <pzpz> however, i'm doing a tedious homework assignment that is esentially a conversion from a graph to a tree
17:50:46 <pzpz> and rather than using a minimal set of nodes  and edges to convey a simple method, there's 12 nodes and like 60 edges.
17:50:54 <pzpz> <3 education.
17:51:17 <pzpz> (and the graph is located on paper)
17:51:41 <SamB> oh, why don't you just convert the graph to a Haskell datastructure?
17:52:10 <pzpz> probably could have, but i'm unfamiliar with that at the moment :)  Which module are the graphs in?
17:52:25 <SamB> oh, I meant like a Tree
17:52:57 <SamB> maybe by way of a Map
17:53:23 <pzpz> a map would work easily
17:53:30 <Eidolos> I'm trying to convert a decimal number to a hexadecimal one. I'm still very shakey with Haskell's syntax.. any suggestions?
17:53:56 <SamB> and then you'd just label all the nodes with unique Ints...
17:54:17 <SamB> syntax helps not with converting to hex
17:54:20 <SamB> @hoogle hex
17:54:21 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
17:54:21 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
17:54:21 <lambdabot> Numeric.readHex :: Integral a => ReadS a
17:54:26 <SamB> hmm
17:54:29 <SamB> @hoogle showHex
17:54:30 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
17:54:45 <SamB> > Numeric.showHex 16 ""
17:54:47 <lambdabot>  "10"
17:54:55 <Eidolos> Cool.
17:55:41 <pzpz> Eidolos: http://paste.lisp.org/display/29860
17:56:03 <pzpz> probably not the best method, but i'm learning too and that's something i wrote a week or so ago :)
17:56:11 <SamB> ShowS just means String -> String, and you string them together to show several things, if you were wondering about the extra "" argument
17:56:11 <Eidolos> :)
17:56:13 <pzpz> sytanx is goofy
17:56:20 <pzpz> err, the indenting in that paste
17:57:34 <dibblego> does GHC perform better with case statements over pattern matching?
17:58:00 <Adamant> I think it's all translated into case statements
17:58:18 <Adamant> at least that is what YAHT claims
17:58:19 <sjanssen> dibblego: they're the same
17:58:31 <eviltwin_b> also what the report claims IIRC
17:58:39 <sjanssen> case statements *are* pattern matching
17:59:54 <dibblego> thanks, that's what I thought
18:01:23 <dons> all your code is either case, let, values or application
18:02:22 <dibblego> values meaning literals/constant functions?
18:02:47 <guerra> @hoogle a -> [a]
18:02:47 <dons> values, yep.
18:02:48 <lambdabot> Prelude.repeat :: a -> [a]
18:02:49 <lambdabot> List.intersperse :: a -> [a] -> [a]
18:02:49 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
18:02:54 <dibblego> ta
18:02:55 <SamB> f "foo" = "hi!"; f "bar" = "bye!" --> f x = case x of "foo" -> "hi!", "bar" -> "bye!" (modulo source locations in error messages)
18:03:03 <dons> functions are values
18:03:14 <dons> >  let x = putChar in case x of x -> x
18:03:16 <lambdabot>  <Char -> IO ()>
18:03:28 <dons> a value :)
18:04:08 <ihope_> > let x = putChar in case x of y -> y
18:04:10 <lambdabot>  <Char -> IO ()>
18:04:26 <ihope_> > let x = putChar in case x of y -> x
18:04:28 <lambdabot>  <Char -> IO ()>
18:04:29 <dons> >  let x = putChar in case x of x -> (\x y -> x) x -- let, case, app, value. all there is
18:04:30 <lambdabot>  Add a type signature
18:04:39 <Eidolos> Thanks for your help with the hex question, SamB and pzpz.
18:04:45 <ihope_> Hey, you used a lambda. No fair.
18:04:51 <dons> >  let x = putChar in case x of x ->(flip const) x -- let, case, app, value. all there is
18:04:52 <lambdabot>  Add a type signature
18:04:53 <Eidolos> (I ended up using Numeric.showHex)
18:04:55 <dons> boo
18:05:02 <dons> ?pl \x y -> x
18:05:03 <lambdabot> const
18:05:21 <dons> >  let x = putChar in case x of x -> const x () -- let, case, app, value. all there is
18:05:22 <dibblego> looking at the GHC source, scanl has been written with a case, but it looks like it can be easily done with pattern matching
18:05:23 <lambdabot>  <Char -> IO ()>
18:05:24 <pzpz> Eidolos: thought you were looking for ways to implement hex conversion :)
18:05:35 <dibblego> it seems an arbitrary choice is made
18:05:38 <dons> dibblego: but pattern matching is just sugar for case
18:05:41 <Eidolos> I'd rather not reinvent wheels. :)
18:05:45 <dons> so it can be simpler to just write the case
18:05:59 <dibblego> sure, but why pick one over the other?
18:06:05 <dibblego> just toss a coin?
18:06:11 <guerra> @hoogle String -> [String]
18:06:12 <lambdabot> Prelude.lines :: String -> [String]
18:06:13 <lambdabot> Prelude.words :: String -> [String]
18:06:13 <lambdabot> Text.Regex.splitRegex :: Regex -> String -> [String]
18:06:29 <dons> yeah. depends on what you're trying to achieve
18:06:44 <dibblego> oh wait, I see the benefit
18:07:09 <dibblego> case allows you to do a little more in a little less code - sometimes
18:07:12 <dons> scanl f q ls            =  q : (case ls of
18:07:13 <dons>                                 []   -> []
18:07:13 <dons>                                 x:xs -> scanl f (f q x) xs)
18:07:15 <Eidolos> Wow, Hogle looks pretty awesome.
18:07:18 <Eidolos> er, Hoogle
18:07:20 <dons> scanl1 f (x:xs)     =  scanl f x xs
18:07:20 <dons> scanl1 _ []     =  []
18:07:52 <dons> n.b.
18:07:52 <dons> scanr _ q0 []           =  [q0]
18:07:53 <dons> scanr f q0 (x:xs)       =  f x q : qs
18:07:53 <dons>                            where qs@(q:_) = scanr f q0 xs
18:08:07 <dons> haskell is like free form beat poetry sometimes
18:08:09 <dibblego> yeah so for scanl, you don't have to repeat the q :
18:11:02 <hyrax42> dons di dyou get my message?
18:11:17 <hyrax42> if I'd ever looked at lambdabot code I'm sure I could have just sent a patch
18:11:25 <dons> ah yes.
18:11:28 <hyrax42> sorry :(
18:11:37 <hyrax42> simple as it was...
18:12:02 <Philippa> case often makes more sense in the middle of a do statement
18:12:53 <Adamant> Haskell is kind of vaguely like a CAS
18:12:59 <spiffy> did my last few messages come through?
18:13:01 <Adamant> syntax-wise
18:13:55 <dons> spiffy: hmm no?
18:14:12 <spiffy> alright
18:14:21 <spiffy> wasnt sure when my connection dropped
18:14:27 <dibblego> > let scanl' _ q [] = q; scanl' f q (x:xs) = q : (scanl' f (f q x) xs) in scanl' (+) [7,8,9]
18:14:28 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
18:14:28 <lambdabot>    Expected...
18:15:45 <dibblego> what have I broken? looks the same as the case method from GHC
18:16:44 <spiffy> ?paste
18:16:45 <lambdabot> http://paste.lisp.org/new/haskell
18:17:02 <sjanssen> > let scanl' _ q [] = [q]; scanl' f q (x:xs) = q : (scanl' f (f q x) xs) in scanl' (+) [7,8,9]
18:17:02 <lambdabot>  add an instance declaration for (Num [a])
18:17:12 <guerra> @hoogle Int -> String
18:17:14 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
18:18:06 <dibblego> ah thanks, I should have seen that
18:18:10 <sjanssen> > let scanl' _ q [] = [q]; scanl' f q (x:xs) = q : (scanl' f (f q x) xs) in scanl' (+) 0 [7,8,9]
18:18:11 <lambdabot>  [0,7,15,24]
18:18:16 <syntaxfree> 12:06 AM  Eidolos: Wow, Hogle looks pretty awesome.
18:18:22 <syntaxfree> s/Hoogle/Haskell ;)
18:18:39 <Eidolos> hehe
18:19:30 <satan> given a definition of return for a monad, how would i go about defining a join for that type?
18:19:48 <guerra> @hoogle Int -> Char
18:19:49 <lambdabot> Char.chr :: Int -> Char
18:19:49 <lambdabot> Char.intToDigit :: Int -> Char
18:19:49 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
18:21:06 <syntaxfree> @hoogle Char -> Int
18:21:07 <lambdabot> Char.digitToInt :: Char -> Int
18:21:08 <lambdabot> Char.ord :: Char -> Int
18:21:52 <lisppaste2> spiffy pasted "Too far down the rabbit hole." at http://paste.lisp.org/display/29862
18:22:23 <sjanssen> satan: you need more than just return
18:22:59 <satan> sjanssen: well, the monad is defined, and i have to define a join
18:23:49 <spiffy> if someone would look at that for me it would be greatly appreciated
18:23:56 <spiffy> looking at you dons :D
18:24:14 <dons> busy... sorry
18:24:24 <sjanssen> spiffy: dies?
18:24:35 <lisppaste2> spiffy annotated #29862 with "oops. forget the error" at http://paste.lisp.org/display/29862#1
18:24:42 <dylan> spiffy> I bet it is the type declaration
18:24:46 <dylan> err, type signature
18:24:55 <spiffy> sorry, forgot to include the actual error
18:24:57 <sjanssen> satan: join is defined with >>= and return.  Would you like me to blurt out the answer, or are you trying to figure it out yourself
18:25:11 <spiffy> "The last statement in a 'do' construct must be an expression"
18:25:31 <satan> sjanssen: well, i'm trying to, yes, but im not sure i know what join even does
18:25:36 * SamB thinks it would be really neat if you could do this
18:25:47 <SamB> @. djinn type join
18:25:48 <lambdabot> Cannot parse command
18:26:17 <sjanssen> satan: do you know the type?  join :: (Monad m) => m (m a) -> m a
18:26:28 <sjanssen> that is actually a library function somewhere, defined for all monads
18:26:32 <spiffy> dylan: Dont believe so
18:26:43 <satan> sjanssen: so it strips away one of the monads? like taking away a pointer or some such
18:26:47 <SamB> @hoogle join
18:26:48 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
18:26:48 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
18:26:48 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
18:27:03 <dylan> spiffy> what is the type of shuffle'?
18:27:24 <sjanssen> satan: depends on the monad.  for the list monad, it's concat, a flattening operation
18:27:33 <spiffy> dylan: To be honest, I dont even know.
18:27:42 <dylan> spiffy> solve this, and you will know.
18:27:44 <satan> sjanssen: ah i see
18:27:50 <sjanssen> spiffy: line 46 is "return $ card : (shuffle' deck')"
18:27:57 <spiffy> yup
18:28:10 <spiffy> wait
18:28:13 <spiffy> hmmm
18:28:17 <dylan> a light goes on. :)
18:28:23 <spiffy> a flicker
18:28:37 <spiffy> State Deck?
18:28:50 <dylan> yes.
18:28:54 <dylan> and what is the type of card?
18:28:57 <sjanssen> satan: for the IO monad it takes an action that yields an action (IO (IO a)), executes it, then executes the action that is yielded
18:28:58 <spiffy> Card
18:29:13 <spiffy> so i need another return...?
18:29:29 <dylan> No, you need to extract the value from shuffle' with <-
18:29:50 <spiffy> So that takes it from State Deck to Deck
18:30:08 <satan> sjanssen: alright, so this is a monad defined on Pair, where return a = Pair a a
18:30:27 <dylan> you also should fix the indentation
18:30:37 <sjanssen> spiffy: the "last statement must be an expression" error doesn't mesh with the code you've got there.  Are you sure that it's the right error?
18:30:44 <spiffy> yea its fine in my editor, got messed up in the copy
18:30:55 <sjanssen> dylan might be on to something, some screwy indentation perhaps
18:30:58 * eviltwin_b compiled and reproduced it
18:31:53 <sjanssen> satan: fill in the blank "join (Pair (Pair x) (Pair y) = BLANK; join :: Pair (Pair a) -> Pair a"
18:32:15 <sjanssen> satan: there aren't many possible choices that will still typecheck ;)
18:32:19 <spiffy> ok
18:32:27 <sjanssen> oh sorry, missed a paren there
18:32:28 <spiffy> it seems to be the indentation
18:32:33 <spiffy> fixed that
18:32:37 <spiffy> a new one pops up
18:32:38 <spiffy> :)
18:33:03 <dylan> yeah
18:33:10 <satan> sjanssen: hmm ok
18:33:23 <dylan> btw, you should put this before the definition of shuffle':
18:33:25 <dylan> shuffle' :: Deck -> State Deck
18:33:32 <spiffy> :e
18:33:34 <spiffy> opps
18:33:35 <spiffy> :D
18:33:38 <dylan> If that is indeed the proper type of the function.
18:33:38 <eviltwin_b> you still need to reinvoke shuffle'  with a <- expression, not directly in the return, I think
18:33:51 <spiffy> that seems more correct
18:34:00 <sjanssen> dylan: you haven't applied enough type variables to State there
18:34:07 <satan> sjanssen: won't it be Pair x y ?
18:34:24 <sjanssen> satan: I'd reckon so
18:34:49 <dylan> sjanssen> indeed. But it's leading toward the right answer.
18:34:55 <guerra> gnight to all ^^
18:35:08 <spiffy> ha just got the Kind error
18:35:10 <satan> sjanssen: so you said that join is defined with >>= and return, how does that apply here?
18:35:13 <spiffy> right on cue
18:35:29 <sjanssen> @type \mm -> mm >>= return
18:35:30 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
18:36:02 <sjanssen> spiffy: what is your defn. of bind?
18:36:19 <spiffy> I didnt define bind?
18:36:36 <sjanssen> spiffy: oh sorry, I meant satan
18:36:43 <spiffy> not a problem
18:37:04 <satan> sjanssen: lemme pastebin it
18:38:19 <spiffy> so, I thought that my type signature may need to take into account what im getting/putting.
18:38:33 <sjanssen> spiffy: exactly!
18:38:35 <satan> sjanssen: here http://d.pastebin.com/823816
18:38:39 <spiffy> which led me to Deck -> State StdGen Deck
18:40:35 <chessguy> @seen cale
18:40:36 <lambdabot> cale is in #oasis, #ghc and #haskell. I don't know when cale last spoke.
18:40:46 <chessguy> @uptime
18:40:46 <lambdabot> uptime: 1h 12m 52s, longest uptime: 7d 1h 24m 44s
18:41:03 <sjanssen> satan: actually, I'm not so sure that Pair is a Monad
18:41:13 <satan> sjanssen: no?
18:41:32 <dylan> spiffy> what is the type of deal?
18:41:36 <lisppaste2> Progress? annotated #29862 with "spiffy" at http://paste.lisp.org/display/29862#2
18:41:53 <spiffy> d'oh
18:41:55 <sjanssen> satan: have you checked whether the monad laws hold?
18:42:07 <spiffy> deal :: Deck -> Int -> (Card, Deck)
18:42:17 <satan> sjanssen: no, not yet
18:42:22 <dylan> spiffy> so, it isn't in the state monad
18:42:31 <dylan> spiffy> thus you don't need to unwrap it with <-
18:42:44 * spiffy didnt really get the whole <- thing
18:42:56 <spiffy> so thats for unwrapping. good to know
18:42:59 <spiffy> oo
18:43:01 <spiffy> its bind
18:43:05 <spiffy> that makes sense
18:43:08 * eviltwin_b still trips over that a lot too :)
18:43:32 <eviltwin_b> in fact, what helped a lot was looking at the translation to bind operations
18:43:38 <spiffy> so a let statement then?
18:44:07 <dylan> yes
18:44:56 <lisppaste2> dylan annotated #29862 with "shuffle'" at http://paste.lisp.org/display/29862#3
18:45:21 <spiffy> ah no "in"
18:45:36 <dylan> now you get: Kind error: `State Deck' is not applied to enough type arguments
18:46:47 <dylan> @hoogle randomR
18:46:48 <lambdabot> Random.randomR :: (Random a, RandomGen b) => (a, a) -> b -> (a, b)
18:46:49 <lambdabot> System.Random.randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
18:46:49 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
18:47:22 <spiffy> hmm
18:47:27 <dibblego> what keyword do I look up for the @ syntax as in "where qs@(q:_) = scanr1 f xs" ?
18:48:35 <spiffy> so i need to include the type of the generator being saved in the state?
18:48:58 <dons> @ ?
18:49:13 <dibblego> I searched for @ in YAHT
18:49:20 <dibblego> but want is the word I google for?
18:49:23 <dibblego> *what
18:49:38 <eviltwin_b> "as"?
18:49:54 <dons> check the keyword search in hoogle
18:50:02 <dibblego> ?hoogle @
18:50:03 <lambdabot> Test.HUnit.Base.(
18:50:03 <lambdabot> Test.HUnit.Base.(
18:50:03 <lambdabot> Test.HUnit.Base.(
18:51:18 <spiffy> does <-randomR change my overall type signature?
18:51:25 <spiffy> I assumed that was a black box kina deal
18:51:33 <dylan> spiffy> is randomR in the state monad?
18:51:50 <dibblego> what keyword search in hoogle?
18:51:55 <dibblego> don't I need the keyword?
18:51:59 <dons> ?hoogle @
18:52:00 <lambdabot> Test.HUnit.Base.(
18:52:00 <lambdabot> Test.HUnit.Base.(
18:52:00 <lambdabot> Test.HUnit.Base.(
18:52:13 <dons> not that :/
18:52:29 <dino-> sjanssen & satan: I was going through the _Monads as containers_ yesterday and today, similar stuff. Part of the discussion is making fmap and join for you datatype first and working to bind from that direction.
18:52:39 <dino-> s/you/your/
18:52:44 <dons> here, http://www.haskell.org/haskellwiki/Keywords#.40
18:52:48 <lambdabot> Title: Keywords - HaskellWiki, http://tinyurl.com/y3s4yb
18:53:01 <dibblego> that's it, as-patterns, thanks :)
18:53:22 <dino-> http://www.haskell.org/haskellwiki/Monads_as_containers
18:53:25 <lambdabot> Title: Monads as containers - HaskellWiki, http://tinyurl.com/yylt9j
18:54:17 <dons> those who didn't see it earlier, http://programming.reddit.com/goto?id=qrph
18:54:20 <lambdabot> Title: [Haskell] ANN YCR2JS, a Yhc Core to Javascript Converter
18:54:32 <satan> dino-: ok cool, i'll check it out, thanks
18:55:32 <spiffy> so is my <-randomR is making my "container" non-homogenious?
18:55:32 <dino-> satan: No no, thank you. I'm now embroiled in trying to write fmap and join for your Pair datatype.
18:55:44 <spiffy> or did i just miss the point entirely :)
18:56:26 <satan> dino-: haha ok, i'd like to see them when they're done, i'm new to all this
18:56:43 <dino-> spiffy: I'm not sure, but some of that seems to be carrying state. Like randoms and randomRs.
18:57:32 <spiffy> does bind as defined for State the monad automagically update the state? or is that just done through methods like get and put
18:59:48 <lisppaste2> dylan annotated #29862 with "hmm?" at http://paste.lisp.org/display/29862#4
19:00:18 <dylan> spiffy> randomR doesn't know anything about the state monad, I think
19:00:19 <sjanssen> @check let bind (x, y) f = (fst $ f x, snd $ f y) in (\m f g -> ((m `bind` f) `bind` g) == (m `bind` (\x -> f x `bind` g))) :: (Int, Int) -> (Int -> (Integer, Integer)) -> (Integer -> (Char, Char)) -> Bool
19:00:21 <lambdabot>  OK, passed 500 tests.
19:00:49 <spiffy> dylan: so it doesnt need <-
19:00:55 <dylan> spiffy> yep. :)
19:01:22 <spiffy> and it all comes togeather. <- is just needed to get stuff out of other State's
19:01:25 <dylan> (btw, I've been figuring this out with you, I've never used randomR or State before.)
19:01:51 <spiffy> well, thanks a ton
19:01:58 <dylan> My pleasure.
19:02:30 <spiffy> If i may make a general observation. Haskell (the language) may not be the most newbie friendly. But Haskell (The community) is truly top notch
19:02:55 <dons> cool :)
19:03:07 <dons> we try to make the language friendly too. any suggestions are welcome
19:03:38 <spiffy> Nothing really jumps out. It all makes sense, after it makes sense
19:03:44 <dylan> 'return' should be wrap, then. ;)
19:03:55 <dons> heh
19:04:26 * robreim thinks haskell is plenty newbie friendly. But it's paradigm shift makes it non-newbie unfriendly :)
19:04:38 <spiffy> bingo
19:04:41 <dylan> okay, it's definitely late. I just got a vision of describing monads using monkeys wearing pants.
19:04:42 <robreim> if we're talking about newbies to programming in general
19:05:00 <dons> if we all started programming in haskell, java would be considered insane
19:05:03 <spiffy> I think I have an infitie loop somewhere
19:05:05 <emu> do tell, we need another monad tutorial
19:05:19 <dylan> I started programming with perl, and I consider java to be insane.
19:05:26 <dons> "Argh, mutable state *everywhere*. This isn't very newbie friendly. What?? More keywords? Argh"
19:05:29 <robreim> I started programming in haskell in university. Only got to use it for one semester so I pretty well forgot about it. But the next semester was java and it sure did seem insane.
19:05:34 <sjanssen> dons: Java would have the same status as brainfuck, I reckon
19:05:39 <dons> heh
19:05:54 * eviltwin_b considers java insane and he started with C :)
19:06:03 <dino-> dylan: What's sad is I now have a job writing Perl for a living. But it's for a team who's so OOP obsessed, it's like we're writing Java in Perl syntax.
19:06:04 <robreim> then again, our introductory course never touched on monads...
19:06:16 <protoscript> i am a ruby / javascript / C# :-/ / python / php :-/ programmer
19:06:23 <protoscript> and I want to learn a functional language
19:06:26 <robreim> (back from the days of gofer... not even sure it had monads back then?)
19:06:33 <protoscript> and ocaml looks ridiculous, so haskell seems to be the right choice
19:06:35 <spiffy> monads are easily the weirdest thing ive ever come across in programming. In a good way
19:06:50 <dylan> dino-> I am an IT department, in charge of creating a system that uses perl, autocad's autolisp, and lotus notes lotus script. XD
19:06:55 <robreim> spiffy: I take it you haven't used continuations yet? :P
19:07:08 <Thomas2> I thought continuations formed a monad?
19:07:09 <dons> protoscript: interesting. welcome!
19:07:12 <spiffy> didnt have a big problem with continuations
19:07:15 <Thomas2> In fact, I thought that was pretty much what IO was.
19:07:39 <spiffy> but, I didnt do much coding with them. Just an "o, thats neat" kina thing
19:07:42 <dons> continuations are a particular monad, yeah
19:07:44 <robreim> Oh ok... I consider continuations much wackier than monads...
19:07:56 <dons> ?hoogle Control.Monad.Cont
19:07:56 <lambdabot> No matches, try a more general search
19:08:02 <spiffy> for some reason, monads now remind me of macros. :-/
19:08:04 <dons> ?hoogle Cont
19:08:04 <lambdabot> Control.Monad.Cont :: module
19:08:05 <lambdabot> Control.Monad.Cont.Cont :: ((a -> r) -> r) -> Cont r a
19:08:05 <lambdabot> Control.Monad.Cont.Cont :: newtype Cont r a
19:08:19 <dibblego> ?hoogle [a] -> a
19:08:19 <dylan> hmm, I need a blog.
19:08:20 <lambdabot> Prelude.head :: [a] -> a
19:08:20 <lambdabot> Prelude.last :: [a] -> a
19:08:20 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
19:08:24 <dons> dylan: yes please.
19:08:26 <dibblego> dylan, I got one!
19:08:35 <dylan> anyone know a good blog that is just writes static files?
19:08:46 <dons> blosxom?
19:08:49 <dons> that's what i use.
19:08:50 <dylan> dons> please shut up and just write my insane comments to a blog?
19:08:57 <dylan> ;)
19:08:59 <dino-> dylan: Ah, sounds like you get to do FP in your job.
19:09:12 <dons> it'd be a 1 day task to rewrite blosxom in haskell too...
19:09:18 <dibblego> dylan, I use WordPress and keep the files under revision control using mumble(subversion)
19:09:30 <dons> i use blosxom + darcs, fwiw
19:09:34 <dylan> I refuse to use things written in PHP
19:09:52 <dylan> so, perhaps blosxom.
19:09:53 <protoscript> so... if i want to write a simple web-app with db access as a test, what is the framework / library I need to use
19:10:30 <dons> happs would be a good choice, but there's a few others. check haskell.org under 'libraries and applicaitons'
19:10:37 <spiffy> hmmm index too large...
19:10:50 <dylan> spiffy> genericIndex, genericLength?
19:10:50 <spiffy> wait
19:11:09 <spiffy> d'oh
19:11:11 <protoscript> thanks dons
19:11:20 <spiffy> of course length will give too big an index
19:11:40 <protoscript> i'll probably just go for happs. i don't want to go crazy trying to figure out which library is best
19:11:53 <spiffy> It works. O beatiful day it works!
19:12:15 <dons> yeah, protoscript, very reasonable choice
19:12:38 <dylan> hmm, nanoblogger, a blog engine written in bash
19:12:43 <dylan> that sounds fascinating.
19:15:18 <dons> Issue 49 of the Haskell weekly news is online, http://sequence.complete.org/hwn/20061114
19:15:27 <dibblego> scanr f q0 (x:xs)       =  f x q : qs where qs@(q:_) = scanr f q0 xs -- what's the point of that as-pattern when q is never used?
19:15:45 <protoscript> I hope my next question makes sense.
19:15:48 <spiffy> does mkStdGen return the same prng on every run? when passed the same Int
19:16:53 <protoscript> One can move from say, BASIC, to coding a web app in ruby without changing there coding style at all. They won't be writing idiomatic code, but they can get away with writing working code without thinking too much of the differences.
19:17:01 <dibblego> scanr f q0 (x:xs)       =  f x q : scanr f q0 xs -- isn't that equivalent?
19:17:24 <emu> basic? na
19:17:35 <protoscript> If I move from mostly imperative, mutable state language to haskell, and just dive right in to writing a simple app, will it force me to learn the "haskell way" since it is soo different?
19:17:55 <dons> not necessarily, its not that far from ruby or pythong
19:18:06 <dons> and i've even seen C guys continue to use free/malloc in their haskell...
19:18:10 <dibblego> it will force you to look deeply into yourself and question the authenticity of your subscription to the legitimacy of imperative
19:18:13 <protoscript> haha
19:18:20 <dons> you'll do best if you forget about how to code and start from scratch though
19:18:22 <dons> ?where yaht
19:18:22 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:18:26 <dons> is a good place to start
19:18:27 <dibblego> and if you decide to change your subscription, then it will be by choice, not force
19:18:38 <dons> or maybe try solving some of the ruby quiz problems in haskell?
19:18:42 <emu> whats up with that guy who forked yaht
19:18:44 <protoscript> ok so i guess i'll have to follow a tutorial then
19:18:51 <protoscript> thanks for yaht
19:18:52 <dons> here, http://haskell.org/haskellwiki/Haskell_Quiz
19:18:53 <lambdabot> Title: Haskell Quiz - HaskellWiki
19:18:56 <dons> (if you know ruby already)
19:18:56 <protoscript> coool thanks
19:18:58 <protoscript> yes
19:19:17 <dons> and you can quit writing 'end' to close layout-based code blocks forever!
19:19:18 <dons>  :)
19:19:41 <protoscript> awesome ;-)
19:19:47 <dolio> That alone gives us a length advantage. :)
19:20:08 <emu> though, you should learn how to use rectangular block editing operations
19:20:11 <dons> someone should really submit an optional -fno-end patch to the ruby interpreter, to handle layout sensibly
19:20:15 <dons> i bet people would love it
19:20:19 <emu> if you are going to use indentation sensitive syntax
19:20:41 <dons> emu, good piont.
19:20:49 <dons> i use block-based vim commands a lot, because of that
19:20:53 <emu> C-v
19:20:54 <protoscript> rubyists complain about its effect on web apps and sharing code, but they could just be fronting due to an anti-python attitude
19:20:56 <dolio> Ruby programs also eat extra lines because function signatures typically go on their own line.
19:20:57 <dons> we could probably have a suite of block-based support in the editor
19:21:08 <emu> and C-x r in emacs
19:21:22 <protoscript> that's my other problem
19:21:27 <dons> there's no type inference in ruby?
19:21:28 <protoscript> i'm primarily a windows guy
19:21:32 <dolio> "def foo(a, b, c)\n body \n end" instead of "foo a b c = body"
19:21:38 <dons> WinHugs or GHC would be good choices then
19:21:41 <protoscript> ruby is dynamically typed
19:21:52 <protoscript> and i don't know emacs or vim
19:21:53 <emu> emacs and vim run everywhere
19:22:00 <jcreigh> dons: do you use vim to edit Haskell?
19:22:04 <dons> sure, but that's just a special case of static typing where everything is wrapped in Dynamic
19:22:13 <kowey> protoscript: maybe try cream - it's vim made easy
19:22:15 <protoscript> but i guess now is as good a time as any to learn
19:22:15 <dons> > [toDyn (), toDyn 'x', toDyn "foo"]
19:22:16 <lambdabot>  [<<()>>,<<Char>>,<<[Char]>>]
19:22:19 * spiffy codes in metapad, which isnt far off from notepad
19:22:24 <emu> they are the power tools of editors
19:22:25 <dons> jcreigh: yes.
19:22:46 <spiffy> in windows
19:23:04 <protoscript> thanks kowey, maybe i';l give it a try
19:23:06 <spiffy> *nix, emacs for lisp, trying out haskell-mode in emacs for haskell
19:23:18 <protoscript> wrapped in "Dynamic"?
19:23:59 <dons> protoscript: you can add dynamic typing to any statically typed language, by flattening all static types to a single universal type, Dynamic, and then doing the type inspectoin/check at runtime
19:24:12 <Turks> Hello
19:24:19 <protoscript> ah that makes sense. i was thinking about that wrt to C#
19:24:20 <dons> (but you can't add static typing to a dynamically typed language without rewriting the compiler)
19:24:56 <emu> dons: that's not strictly true, because introducing new dynamic types can't be done with that model
19:25:02 <dons> so you could write haskell with dynamic dispatch all over, it would just suck :) since all the errors would be caught later, if at all, only if that code path is executed
19:25:08 <dons> so you'd be forced to start writing unit tests
19:25:15 <Turks> sounds fun
19:25:15 <dons> which would attempt to approximate the static type check anyway
19:25:31 <dons> emu: why not? you can create new TypeReps at runtime
19:25:51 <dons> (you might be right, but I'd need more code)
19:26:19 <emu> dons: because old code would have to be recompiled
19:26:32 <dons> I think I'll release a type system for say, ruby, and call it "Automatic, complete unit testing: RTunit"
19:26:48 <dons> and it would just be a static type checker, that sold itself as a coverage/unit test machine :)
19:27:04 <dons> "tests all code paths, even those that won't ever be executed!"
19:27:25 <protoscript> hehe
19:27:45 <emu> if it won't be executed, then ruby programmers won't care if it fails
19:27:58 <emu> that is one of the features.. of dynamic typing
19:28:02 <protoscript> The dynamic typing tdd enthusiasts would claim that you need to write unit tests anyways, to check your functionality, and those will automatically cover the typing issues
19:28:05 <Turks> just curious, is it possible for haskell code to be compiled into a .exe file?
19:28:08 <dons> "Automatically works out what possible values a code fragment can have -- we call this concept a value's "type"
19:28:11 <emu> Turks: yep
19:28:20 <dons> Turks: of course. :)
19:28:37 <protoscript> whoa "monomorphically typed"
19:28:42 <dons> yes, unit testing is good, automated unit testing is better. QuickCheck + static typing is best :)
19:28:44 <protoscript> haskells going to be fun
19:28:45 <Turks> heh, possible in GHCi im assuming?
19:28:53 <emu> i find functional languages tend to really sync with static type systems simply because you deal with such heavily nested concepts
19:28:55 <dons> ghc -o foo.exe foo.hs
19:28:57 <jcreigh> dons: hmm...I was going to ask if you'd run into a certian bug in vim, but it goes away if I "vim -u NONE foo.hs" (ie, skip loading .vimrc). So now I get to hunt it down...
19:29:02 <emu> but imperative languages don't need it so much
19:30:29 <SamB_XP> emu: you mean, because you aren't trying to do so much, you don't need so much help?
19:31:15 <emu> sorta
19:31:41 <protoscript> hehe
19:31:42 <emu> the formality itself introduces the need for checking
19:32:35 <SamB_XP> I thought the point of typechecking was so that it could pick the correct typeclass instances ;-P
19:33:12 <Turks> Hrm
19:33:13 <emu> psychological needanyhow
19:34:28 <emu> i dunno; in CL I feel less need for static typing because I can just plop my function into the running program and give it a whirl
19:34:39 <Turks> Dons: that command line or HS code?
19:34:50 <emu> i kinda wish i could do that more effectively in ghci
19:34:51 <dibblego> I am struggling to rewrite scanr f q0 (x:xs)       =  f x q : qs where qs@(q:_) = scanr f q0 xs without the as-pattern, how is it done?
19:35:06 <emu> ghci permits that sort of development to a point, but then it really fails in the presence of errors
19:35:16 <dons> Turks: ghc, given a .hs file, will produce an .exe on windows by default
19:35:32 <dons> dibblego: a two-stage case?
19:35:35 <Turks> Hrm, doesnt seem to be doing that..
19:35:37 <emu> for example, :load on a file with errors will drop you out of the module completely.  oops? how am i supposed to query ghci when i don't have the older version of my code loaded?
19:35:42 <dibblego> dons, does it need to be two stage?
19:35:46 <Excedrin> how can I check for errors from Prelude.read?
19:35:56 <JFT> Hello, I'm trying to build lambdabot locally but when I do configure it complain Setup.hs: cannot satisfy plugins>=1.0 does anybody knows how/where to get this "plugins" package? Thanks
19:36:00 <dons> ?type reads
19:36:00 <dibblego> dons, I have confused myself I think with the as-pattern and failed to rewrite it
19:36:01 <lisppaste2> spiffy annotated #29862 with "Just to show I learned something ;-)" at http://paste.lisp.org/display/29862#5
19:36:02 <lambdabot> forall a. (Read a) => ReadS a
19:36:05 <dibblego> and therefore, understand it
19:36:51 <dibblego> can't it just be rewritten with pattern matching?
19:37:24 <dons> look up the translation for as-patterns in the h98 report
19:37:29 <dons> you'll see how they can be desugared
19:37:37 <dibblego> mk
19:38:36 <Turks> dons: eather im blind, windows is retarded, or its not working properly
19:38:51 <spiffy> Well, Im off to sleep, Thanks again
19:38:57 <protoscript> turks: probably #2
19:38:59 <dons> do you get an error message? I find it hard to debug english prose
19:39:06 <Turks> Nope
19:39:09 <Turks> just no foo.exe
19:39:19 <dons> does your .hs file contain the 'main' function?
19:39:54 <dons> does the code run in ghci? i.e.:   ghci Foo.hs .. then type "main" at the prompt
19:40:06 <Turks> Yea
19:40:14 <Turks> im running it on my local irc network right now
19:40:24 <dons> so you can run:   runhaskell Foo.hs too?
19:40:35 <Turks> hrm
19:41:03 <Turks> heh
19:41:30 <Turks> in which? the code or command line?
19:42:08 <emu> shell
19:44:56 <dons> for those not around earlier, http://programming.reddit.com/info/qrph/comments
19:45:00 <lambdabot> Title: Compiling Haskell to JavaScript (reddit.com), http://tinyurl.com/ycexf6
19:45:04 <dibblego> case e of { xs@(x:rest) -> if x==0 then rest else xs } is equivalent to let { xs = e } in case xs of { (x:rest) -> if x==0 then rest else xs } -- then where is the 'e' in scanr f q0 (x:xs) =  f x q : qs where qs@(q:_) = scanr f q0 xs ?
19:45:12 <dons> should really play around with this javascript embedding a bit
19:45:14 <dons> hmm
19:47:53 <Turks> hrm
19:48:32 * Turks whacks GHCi
19:50:51 <Turks> Hrm, there wouldnt be a haskell2c converter would there?
19:51:07 <dibblego> yes
19:51:25 <Turks> May i have a link or must i use the dreaded google?
19:52:01 <dibblego> http://www.haskell.org/ghc/
19:52:02 <lambdabot> Title: The Glasgow Haskell Compiler
19:52:14 <SamB_XP> dibblego: that ain't real C!
19:52:20 <SamB_XP> try JHC instead!
19:52:24 <SamB_XP> that generates real C!
19:52:30 <dibblego> wtf is real C?
19:52:56 <SamB_XP> well, not hijacking the stack is a starting point
19:53:02 <Turks> Lol
19:53:09 <dibblego> the way I read it is scanr f q0 (x:xs) =  f x q : qs where qs@(q:_) = scanr f q0 xs and scanr' f q (x:xs) =  f x q : scanr' f q xs are equivalent but that clearly isn't the case
19:53:25 <dibblego> lots of staring has changed nothing
19:53:27 <dons> SamB_XP: don't be a wuss. hijacking the stack is the first step to fun!
19:54:01 <SamB_XP> dons: yes, but once you do that, your code doesn't really count as C anymore
19:54:40 <Turks> lol...
19:55:09 <sjanssen> I hijacked the stack once
19:55:13 <emu> hijack the stack and take this compiler to Fun-land!
19:56:21 <TSC> Argh, I can't get Haddock to use the Prelude documentation; are there any hoops I have to jump through?
19:56:46 <dons> ?remember emu hijack the stack and take this compiler to Fun-land!
19:57:06 <dibblego> scanr f q0 (x:xs) =  f x q : qs where qs@(q:_) means that qs is (q:_) and since (q:_) = scanr f q0 xs, then qs = scanr f q0 xs, therefore, scanr f q0 (x:xs) =  f x q : qs where qs@(q:_) means scanr f q0 (x:xs) =  f x q : scanr f q0 xs
19:57:12 <dons> TSC, hmm, to point to the prelude defs?
19:57:21 <dons> if you work it out, leC tme know :)
19:57:40 <TSC> Yes, I want it to use the base.haddock I've already got
19:57:53 * Turks is annoyed at chainsaw
20:02:16 <Turks> Meh, guess ill just stick with running .hs scripts :\
20:02:57 <dons> Turks: if you can't solve it, ask on haskell-cafe@haskell.org
20:03:05 <dons> we have lots of windows users who should be able to offer advice
20:03:16 <dons> (ndm is here, but he's not awake for a few hours yet)
20:03:18 <Turks> heh, im an idiot...brb, going to try something
20:04:13 <Turks> heh
20:04:18 <dons> ?temp
20:04:18 <lambdabot> Maybe you meant: help tell time
20:04:21 <dons> no no
20:04:29 <Turks> runhaskell works but closes imidiately
20:04:44 <Turks> pfft, i cant spell worth a shit
20:04:55 <dons> is it possible that the libraries are isntalled in a weird place, and not being found?
20:05:05 <Turks> D:\ghc
20:05:08 <dons> hard to tell without any error messages
20:05:21 <Turks> thats just it, i dont get any error messages
20:05:31 * dons just read   D:\   as some weird smiley with a hat
20:05:43 <Turks> i can run the .hs code just fine in GHCi
20:05:54 <dons> is ghc in your path?
20:05:56 <Turks> it just wont output the file to a exe
20:05:58 <Turks> yeah
20:06:07 <dons> what's the output of:   ghc -v4 Foo.hs  ?
20:06:18 <Turks> D:\ghc\ghc-6.4.2\bin\ghci.exe -o foo.exe  foo.hs
20:06:25 <dons> for a Foo.hs containing: main = print "hello"
20:06:35 <dons> ghci.exe  ??
20:06:39 <dons> you mean:  ghc.exe ?
20:06:48 <Turks> :P
20:07:21 <dons> can you try the above command, and show me the output?
20:07:28 <Turks> lmao, "I R RETARD" falls into place
20:07:32 <dino-> Oh man, those backwards path separators make me begin to get a headache. :D
20:07:40 <dons> Turks: so it works now?
20:07:58 <dons> dino-: its like trying to read while looking in a mirror, no?:)
20:08:08 <Turks> i saw a foo.exe for a split second then it disapeared
20:08:11 <Turks> :\
20:08:16 <Turks> foo.o = foo.exe?
20:08:24 <dons> nope. that's the object file
20:08:28 <dons> what command are you typing?
20:08:35 <Turks> D:\ghc\ghc-6.4.2\bin\ghc.exe -o foo.exe  foo.hs
20:08:35 <dino-> dons: heh, and at the same time having nagging feeling of needing to double-escape those characters.
20:08:54 <dons> can you try: D:\ghc\ghc-6.4.2\bin\ghc.exe -v4 --make foo.hs
20:09:13 <Turks> aye
20:09:23 <Turks> :D
20:09:26 <Turks> ^^
20:09:50 <Turks> heh, i do feel like an idiot though....this couldve been solved quickly using the right exe :P
20:10:47 * Turks now tries to remember how to input a user's variable and use it to connect to different IRC servers
20:11:35 <dons> getArgs ?
20:12:45 <Turks> eh, i forgot the lines that let you type a variable into the program, and then it uses it someplace else in the code...
20:12:51 * Turks checks wiki
20:13:15 <dons> you've seen : http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:13:18 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
20:13:21 <Turks> Yep
20:13:32 <Turks> i build a tiny little bot using that as a shell
20:14:19 <Turks> doesnt do much more then quit, voice/devoice, op/deop, kick, or /global though
20:15:49 <Turks> and ban...
20:21:07 <skew> so, why is there no instance Monoid a => Monoid (Reader r a)?
20:23:29 <Turks> hrm, would haskell be a good way to script ghetto IRC services?
20:23:42 <SamB_XP> what is ghetto IRC?
20:24:10 <Turks> services
20:24:13 <Turks> chanserv, nickserv, etc
20:24:19 <LoganCapaldo> Is there a FAQ? Specifically one that deals with hello world type programs, and why I don't know how to make it flush what I putStr so I can do this lame prompt properly?
20:24:32 <Turks> o.0
20:26:42 <Turks> hahaha, im surprized my batch file worked to compile XD
20:26:57 <skew> LoganCapaldo: I can't find one.
20:27:08 <skew> you want to look at System.IO.hSetBuffering
20:27:21 <LoganCapaldo> ah
20:27:40 <LoganCapaldo> I tired using interact but I wasn't sure how to use it properly
20:27:43 <skew> or maybe hFlush
20:27:49 <LoganCapaldo> thanks
20:30:38 <Turks> but yeah, would it be a good idea to script ghetto IRC Services in haskell?
20:33:00 <skew> LoganCapaldo: you need to play with buffering in most languages, right?
20:33:41 <LoganCapaldo> yep, just don't know where to look for Haskell yet :)
20:33:50 <skew> looks like we need to write up a FAQ
20:34:01 <LoganCapaldo> plus theres that scary Monad word to contend with :)
20:36:43 <skew> anybody here know how to write Greasemonkey scripts?
20:38:44 <SamB> LoganCapaldo: would you prefer to call them Monsters?
20:39:21 * dylan is adding a blog to his site in order to write the monads-as-monkeys-with-pants.
20:39:28 <dylan> *tutorial
20:40:22 <pkhuong> skew: I have written one. Why?
20:40:58 <sjanssen> dons: do I need to do anything to get that fasta entry in the shootout?
20:41:33 <dolio> Monkeys with pants?
20:41:53 <dylan> yes. I don't want to spoil the insane idea I have in my head right.
20:41:59 <Pseudonym> Monkeys are indeed warm and fuzzy.
20:42:18 <dylan> hmm, but the original thought that went through my mind:
20:43:06 * sjanssen plans to write `Monads as Cute Metaphors'
20:43:13 <dylan> "<- means ``Take something out of the monkey's pants''... return means ``put something in the monkey's pants''... "
20:43:40 <skew> pkhuong: never mind, I think I found enough docs to do it myself
20:43:48 <dylan> and there's something floating in my head that lets me use monkeys with pants to unify monads-as-containers and monads-as-computation.
20:43:54 <sjanssen> dylan: be careful, that monkey may bite
20:44:08 <dylan> sjanssen> yes! Sometimes you can't take things out of the monkey's pants.
20:44:17 <sjanssen> if I were a monkey, I would not take kindly to wearing pants
20:44:32 <skew> dylan: a monkey'ss pants hold things, but messing with the monkey's pants might also rouse it to violence?
20:44:36 <Turks> Damn
20:44:43 <dylan> skew> sort of, yes.
20:44:45 <Turks> how long do channels here stay registered?
20:44:52 <sjanssen> moreso if somebody started using them as some sort of computation metaphor
20:45:43 <skew> should comonads be fuzzy warm things?
20:45:56 <dino-> sjanssen: A way way while back tonight, you said that join can be built using bind and return. I read in Cale's monad container thing that 'join is equivalent to binding a container with the identity map' Are these things the same?
20:46:42 <Taral> ?seen roconnor
20:46:43 <lambdabot> I saw roconnor leaving #haskell-blah and #haskell 5h 5m 28s ago, and .
20:46:49 <Taral> :<
20:46:54 <dolio> ?pl (>>= id)
20:46:55 <sjanssen> @type \m -> m >>= id
20:46:56 <lambdabot> join
20:46:56 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
20:47:15 <Turks> Lol, does the lambdabot have a database script?
20:47:20 <sjanssen> @type \m -> m >>= return
20:47:21 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
20:47:28 <dylan> "Now, some monkeys are so dirty you can't retreive things you put in their pants. Example: Io."
20:47:35 <Turks> haha
20:47:44 <sjanssen> dino-: looks like you don't even need return
20:49:06 <skew> haha, haddock docs must use fancy javascript to sort the menus
20:49:32 <dylan> wow, bad lag.
20:50:02 <lisppaste2> skew pasted "fuzzy.user.hs" at http://paste.lisp.org/display/29871
20:50:16 <skew> oops, that should be fuzzy.user.js
20:51:00 <dino-> sj
20:51:04 <dino-> sjanssen: Ok, thanks.
20:53:00 <skew> LoganCapaldo: don't worry about monads, just grab that greasemonkey script, and go read "All About Warm Fuzzy Things" http://www.nomaware.com/monads/html/ or something
20:53:05 <lambdabot> Title: All About Monads
20:53:17 <skew> lambdabot lies!
20:53:24 <Turks> horray for my compile.bat :D
20:53:26 <skew> oh, wait, didn't catch the titles...
20:54:33 <dolio> If monads are warm fuzzy things, aren't comonads the dual of warm and fuzzy?
20:54:41 <Turks> haha
20:54:45 <dolio> Not also warm and fuzzy?
20:55:19 <dolio> Cofuzzy.
20:55:53 <skew> warm and scaly?
20:56:14 <dolio> Cool and scaly?
20:56:21 <dolio> Comonads as alligators?
20:56:25 <dolio> In a pond?
20:56:30 <skew> dual, not necessarily "inverse"
20:57:03 <skew> a line and plane are dual in a vector space, so I'm thinking hairs <-> scales
20:57:07 <SyntaxNinja> Lemmih: alive?
20:57:13 <dylan> hot furry things?
20:57:19 <dolio> Ah, I see.
20:57:46 <Turks> i see stupid people...
20:57:52 <Turks> in my server...
21:02:38 <skew> anybody else try my warm fuzzy colored glasses?
21:03:30 <Turks> you made warm fuzzy glasses?
21:03:33 <skew> LoganCapaldo: I also like sigfpe's "You Could Have Invented Warm Fuzzy Things! (And Maybe You Already Have.)"
21:03:46 <skew> http://paste.lisp.org/display/29871
21:04:21 <Pseudonym> Comonads are cowarm and cofuzzy.
21:04:59 <Korollary> Is there a direct correspondence between aspect oriented programming and monads?
21:05:09 <Pseudonym> No.
21:05:32 <emu> monads: unlikely to become the next tech buzzword
21:05:52 <SyntaxNinja> monads 2.0!
21:06:00 <Korollary> dynamic monads!
21:06:33 <Turks> Hmm
21:06:43 <emu> visual monadstudio.net
21:06:45 <skew> dolio: monkeys, like monads, are warm and fuzzy
21:07:06 <Turks> what would be the line to echo a set version string when someone says "version"
21:07:38 <skew> oh, that was dylan talking about monkeys.
21:08:25 <Adamant> does it then follow that monads throw poop at unsuspecting bystandards?
21:08:34 <Adamant> *bystanders
21:08:47 <Korollary> those bystanders should be suspecting
21:09:08 <jcreigh> Adamant: You mean like ECMA or ISO? :)
21:09:34 <Adamant> both, damn their eyes! and ANSI too!
21:09:37 <Adamant> ;)
21:09:57 <eviltwin_b> dynamic webmonads for business logic 2007? (...bingo!)
21:10:14 <LoganCapaldo> I'm pretty sure I "get" warm fuzzy things :)
21:10:36 <LoganCapaldo> I was just stirrin' up trouble
21:12:21 <Pseudonym> I use the coweb.
21:16:39 <dino-> Ok, I don't get something about this.. join xss = xss >>= id
21:17:02 <dino-> How is id here a :: (Monad m) => a -> m b  ?
21:17:36 <pkhuong> ?type join
21:17:37 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
21:18:49 <dino-> I mean, writing your own join in terms of bind and id
21:19:28 <pkhuong> dino-: your >>= unwraps the monad once.
21:19:54 <dino-> Ok. But isn't id :: a -> a
21:19:57 <pkhuong> yes.
21:20:24 <dino-> So, if (>>=) :: (Monad a) => m a -> (a -> m b) -> m b
21:20:40 <dino-> >>= unwraps the m a, we have a going to id..
21:20:54 <equanimity> > foldr max 0 [abs (a!!i - a!!j) | i <- [0 .. length a - 1], j <- [0 .. length a - 1]] where a = [3,7,1,9,4]
21:20:54 <lambdabot>  Parse error
21:20:55 <dino-> Then id doesn't eval to (only) a
21:20:56 <pkhuong> yes, but join is `m (m a) -> m a'
21:21:24 <pkhuong> so alpha-convert a bit, and you can have id's a = join's (m a)
21:21:36 <dino-> Ok, so in the above bind, the "m a" part is really "m (m a)"
21:21:40 <dino-> getting unwrapped once
21:21:43 <equanimity> Hmmm. Hugs liked it :-(
21:21:44 <pkhuong> yes.
21:21:47 <dino-> The m a is going to id
21:22:36 <dino-> Or, you could say the a is itself still wrapped.
21:22:45 <dino-> ok, I get it now.
21:22:47 <dino-> Thank you.
21:23:00 <pkhuong> my pleasure :)
21:23:28 <Turks> Hrm, how is the Quote.hs in lambdabot configured?
21:26:04 <LoganCapaldo> I have new and exciting questions to ask!!!
21:26:40 <LoganCapaldo> Like why does ghc spew forth linking errors when I try and use Parsec
21:26:57 <skew> did you try with --make?
21:27:17 <LoganCapaldo> ah
21:27:26 <LoganCapaldo> I see I did not read this web page carefully enough
21:27:35 <skew> otherwise you might need to pass -package flags and track dependencies manually and so on
21:28:03 <LoganCapaldo> thanks
21:30:05 <dons> sjanssen: re. fasta, i should test it here, then we pass it over to musasabi to commit
21:30:09 <dons> i'll do that today
21:30:13 <dons> and we can ask musasabi in the morning
21:30:30 <skew> hi dons, no hs-plugins yet?
21:30:47 <dons> this week. maybe tomorrow...
21:30:56 <dons> yeah, should have time tomorrow
21:31:14 <dons> remind me in the morning :)
21:31:39 <skew> is this morning?
21:31:55 <dons> in um 15 hours or so
21:33:00 <skew> oh, ok
21:33:13 <LoganCapaldo> yes or no question: data a = A b c is the same as type a = A of b * c ?
21:33:47 <skew> Hmm, in california that's noon
21:33:57 <skew> I thought there were a few more hours between
21:34:11 <dons> A b c is isomophic to b * c, yeah
21:34:18 <LoganCapaldo> K thanks
21:34:20 <skew> very close, at least
21:34:44 <skew> of course, types in Haskell are lazy by default, and types in ML strict
21:34:52 <dons> data a :*: b = a :*: b -- valid ;)
21:35:23 <LoganCapaldo> I think you just exploded my brain
21:35:28 <LoganCapaldo> lazy types
21:35:29 <skew> also, constructors act pretty much just like normal functions, curried and everything
21:35:36 <LoganCapaldo> *boggles*
21:35:44 <dons> LoganCapaldo: just means that bottom is an inhabitant of every type
21:35:54 <dons> > fst (1, undefined)
21:35:55 <lambdabot>  1
21:36:03 <dons> > undefined -- diverges
21:36:04 <lambdabot>  Add a type signature
21:36:10 <dons> > undefined :: () -- diverges
21:36:11 <lambdabot>  Undefined
21:36:57 <skew> hey, has anyone extracted a monad from
21:37:06 <dons> so a strict product type in ML is equivalent to a * b in Haskell, except that you can also stick bottom in a * b in Haskell.
21:37:17 <skew> from Inform? I'm looking over that adventure game example that came up recently
21:37:22 <dons> !a * !b in Haskell would be isomorphic (fully) to a * b in ML, I think
21:38:19 <LoganCapaldo> This is what I get for trying to make sure I understood some bit of syntax <g>
21:38:35 <skew> oh, also type names must be in upper case
21:38:37 <dons> data A a b = A a b is a product type, as you suspected :)
21:38:58 <dons> which is parameterised by two types, a and b
21:39:03 <dons> so you could have A Int Bool
21:39:15 <dons> (just like ML)
21:41:13 <LoganCapaldo> Thanks guys
21:41:24 <LoganCapaldo> You've given me even more to ponder
21:42:30 <dons> should be a fairly easy transition, if you know ML
21:42:42 <dons> Haskell is a bit like MLs lazy child
21:44:05 <LoganCapaldo> I don't _really_ know ML
21:44:11 <LoganCapaldo> I just pretend to ;)
21:44:55 <pkhuong> dons: while caml is ML's redheaded stepchild?
21:44:59 <LoganCapaldo> I keep making abortive attempts to learn OCaml
21:45:14 <LoganCapaldo> but all the cool kids seem to play with Haskell
21:45:16 <dons> pkhuong: heh
21:45:36 <eviltwin_b> OCaml is big around here.  I get looked at funny for preferring Haskell
21:45:50 <dons> eviltwin_b: where's that? INRIA? ;)
21:46:10 <eviltwin_b> (of course, the OCaml kids get looked at funny by the old guard, who are strictly SMLNJ types)
21:46:25 <LoganCapaldo> Hey look at that
21:46:43 <pkhuong> wow, CMU <3 CaML?
21:46:45 <LoganCapaldo> this guy just composed (.) a constructor with another function
21:46:56 <LoganCapaldo> You guys werne't kidding before
21:46:57 <dons> I suppose its a bit like that at CMU. the SML guys, some ocaml guys, and a few haskellers
21:47:19 <dons> ?type let f = (.) . (.) in f
21:47:20 <eviltwin_b> I don't know of anyone else around here who does Haskell
21:47:21 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:47:43 <eviltwin_b> SCS is solidly ML; over in Andrew they like Scheme
21:48:21 <eviltwin_b> but I'm in ECE (and pretty much the only one in ECE who cares, aside from the SCS/ECE hybrids) so I can do my own thing :)
21:48:57 <dons> eviltwin_b: there's at least one other cmu guy here
21:49:06 <dons> and i've seen bob on the mailing list asking about how to build ghc on the mac...
21:49:12 <Adamant> Andrew?
21:49:17 <eviltwin_b> ...just as long as I don'tmake my coworkers try to comprehend it :)
21:49:35 <eviltwin_b> the primary/general computing environment at CMU
21:49:41 <Adamant> ah.
21:50:02 <eviltwin_b> ECE and SCS are unusual (within CMU) in having their own infrastructure instead of basing off Andrew
21:50:10 <Adamant> I'd take SML or O'Caml over Java any day.
21:50:23 <eviltwin_b> no argument there
21:51:18 <Adamant> when I start getting into non-language-specific courses, I am going to try and see how much stuff I can turn in that's not in Java
21:52:16 <skew> bonus karma if executable submissions get "you just turned in pseudocode" complaints!
21:52:21 <Turks> gah
21:52:26 * eviltwin_b did that back when.  the prof still hasn't forgiven him
21:53:31 <Turks> ./Config.hs:19:0: parse error (possibly incorrect indentation) <--- wtf
21:53:38 <Turks> there is no line 19
21:53:51 <Adamant> skew, I always go for the karma. ;)
21:54:06 <skew> unclosed parens?
21:54:16 * Turks shrugs
21:54:23 <pkhuong> too bad all the interesting courses are given by clueful profs ;)
21:54:46 <Turks> im building a bot off of the Lambdabot design: config.hs
21:55:01 <Turks> But, it keeps giving me this parse error..
21:56:41 <dibblego> post your Config.hs
21:56:46 <dibblego> @paste
21:56:47 <lambdabot> http://paste.lisp.org/new/haskell
21:57:02 <dibblego> or revert it and start again
21:57:23 <Turks> im merging it with the main script
21:59:34 <Turks> Pffft!
21:59:56 <Turks> Maybe ill just stick with my old one...
22:01:19 <Turks> are there any examples on the wiki on !tell systems?
22:06:50 <LoganCapaldo> So, whats wrong with this expression: parseNumber = ((many1 digit >>= read) >>= Number) ? (Number is, as you might guess a constructor)
22:07:45 <skew> read and Number probably, unless you're defining your own monad
22:08:01 <LoganCapaldo> definitely not doing that ;)
22:08:36 <skew> ?type (>>=)
22:08:38 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
22:08:52 <skew> read and Number don't return parsers.
22:08:58 <skew> ?type return
22:08:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
22:09:03 <skew> maybe that can help
22:09:10 <LoganCapaldo> yeah
22:09:27 <LoganCapaldo> but I think I put the return in the wrong place..
22:09:30 <LoganCapaldo> hmmm
22:09:37 * LoganCapaldo cogitates
22:10:47 <LoganCapaldo> victory!
22:10:54 <LoganCapaldo> I feel like its shortenable
22:11:03 <LoganCapaldo> but the exercise was to use >>=
22:11:24 <skew> many1 digit >>= return . Number . read?
22:11:30 <LoganCapaldo> Yeah
22:11:39 <skew> that's about as good as it gets
22:11:39 <LoganCapaldo> except I did return . twie
22:11:42 <LoganCapaldo> *twice
22:11:51 <LoganCapaldo> so yes yours is shorter
22:11:52 <skew> maybe fmap (Number . read) (many1 digit)
22:12:03 <LoganCapaldo> ah but then theres no >>= :)
22:12:20 * araujo thinks he can start using his own Haskell editor as the replacement for gedit
22:21:15 <dibblego> http://www.quviq.com/ QuickCheck for Erlang?
22:21:17 <lambdabot> Title: This page is under construction
22:29:12 <Turks> hrm, is there syntax for user input?
22:42:11 <skew> Turks: hm?
22:42:38 <Turks> like for instance, in BASIC "input "blah" ; A$
22:42:56 <Turks> input "blah" ; A$*
22:43:04 <skew> you can read from stdin
22:43:35 <repiret_> so i've been working through the "Yet Another Haskell Tutorial", and arising out of exercise 5.2 in there, I wrote some code kinda like this
22:43:45 <skew> input msg = do putStrLn msg; hFlush stdin; getLine
22:43:47 <repiret_> make_me_smaller filename = do
22:43:47 <repiret_> 	let work h = do
22:43:47 <repiret_> 		line <- getLine
22:43:47 <repiret_> 		if line /= "."
22:43:48 <repiret_> 			then do
22:43:48 <repiret_> 				hPutStrLn h line
22:43:49 <repiret_> 				work h
22:43:51 <repiret_> 			else return ()
22:43:53 <repiret_> 	bracket (openFile filename WriteMode) hClose work
22:44:07 <skew> ?where paste
22:44:08 <lambdabot> http://paste.lisp.org/new/haskell
22:44:26 <Turks> lol
22:44:52 <lisppaste2> repiret pasted "ugly code" at http://paste.lisp.org/display/29876
22:45:07 <skew> I see your code indented with inverted-color Is
22:45:25 <Turks> "ugly code" lol
22:45:25 <desrt> new assignment posted today.  "Starting from scratch, create an IMPS theory of Peano arithmetic called peano1 with the constants 0, S, +, and * and the following axioms..."
22:45:28 <repiret_> oh cool.  ya, thats a much better way of doing it.
22:45:29 <desrt> is it wrong to be excited?
22:45:42 <skew> IMPS?
22:45:58 <skew> internet mersenne prime search?
22:46:50 <repiret_> so anyway, it seems like that code ought to be a lot shorter.  so I was hoping someone could suggest a shorter way.
22:48:12 <LoganCapaldo> filter?
22:48:19 <Turks> heh, so skew, if i wanted to send a user inputed msg to a irc server it would be something like this 	s = do putStrLn msg; hFlush stdin; getLine .... post :: -> Net () ... post ::write "PRIVMSG" (chan ++ " :" ++ s) ?
22:48:32 <Turks> ... meaning new lines
22:48:52 <skew> not quite
22:48:57 <repiret_> or even takeWhile, but I'm not sure how to use it  here, what with the IO monad and such
22:48:59 <skew> s is in IO
22:48:59 <Turks> lol
22:49:11 <skew> so you can't just add strings to it
22:49:25 <skew> Turks: have you looked at dons' tutorial?
22:49:42 <skew> repiret_: for one thing, getLine reads from stdin
22:49:52 <Turks> perhaps this...  post :: s = do putStrLn msg; hFlush stdin; getLine write "PRIVMSG" (chan ++ ":" ++ s)....?
22:49:54 <skew> it's hGetLine handle to read from a file
22:50:02 <Turks> heh
22:50:13 <Turks> cant blame a guy for trying ;)
22:50:38 <Turks> no, i havent read his tutorial....link?
22:50:44 <repiret_> skew: yes.  the code does exactly what i want it to, it just seems like it shouldn't need to be so long.
22:51:04 <skew> oh, you do want to replace the contents of the file with stuff from stdin?
22:51:13 <LoganCapaldo> imaginary syntax: [ hPutStrLn outfile x | x <- hGetLine infile, x /= "." ]
22:51:16 <repiret_> right.
22:51:21 <LoganCapaldo> I wish I could do that
22:51:27 <LoganCapaldo> le sigh
22:51:43 <Turks> heh
22:51:54 <Turks> i still cant get my blasted BRC to work..
22:51:56 <skew> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
22:52:00 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
22:52:29 <Turks> Oh, thats dons' tutorial? yeah, i read over that
22:54:01 <repiret_> LoganCapaldo: That exactly the sort of elegance I'm after, but I'm guessing from the deafening silence that i'm out of luck.
22:54:27 <LoganCapaldo> theres always cat infile | grep -v "." > outfile
22:54:33 <LoganCapaldo> That's pretty elegant
22:54:55 <LoganCapaldo> actually
22:55:02 <LoganCapaldo> thats a useless use of cat
22:55:13 <LoganCapaldo> grep -v "." infile > outfile will do you
22:55:27 <skew> not quite, it stops early
22:55:34 <LoganCapaldo> Oh does it?
22:55:37 <LoganCapaldo> I didn't realize
22:56:06 <repiret_> at any rate, I was hoping for a shorter way to do it in haskell.
22:56:26 <LoganCapaldo> There must be some kind of filterM thingamabob or something
22:56:31 <skew> Control.Monad.when would help a bit
22:56:42 <lispy> dons: did you port hs-plugins to 6.6 yet?
22:56:42 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
22:56:43 <lispy> ?version
22:56:44 <lambdabot> lambdabot 4p263, GHC 6.5 (OpenBSD i386)
22:56:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:56:50 <repiret_> I'll look into that.  brb.
22:56:51 <lispy> hmm...doesn't look like it
22:57:10 <lispy> ?seen jgrimes
22:57:11 <lambdabot> jgrimes is in #oasis, #haskell-overflow, #haskell-blah and #haskell. I don't know when jgrimes last spoke.
22:57:30 <LoganCapaldo> ?seen lambdabot
22:57:30 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell_ru, #haskell.se, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.
22:57:31 <lambdabot> fi, #haskell.es, #haskell.de, #haskell-overflow, #haskell-blah and #haskell
22:57:40 <lispy> ?tell jgrimes it will, and the public repository has your patches now
22:57:41 <lambdabot> Consider it noted.
22:57:41 <LoganCapaldo> woah
22:58:07 <lispy> ?vixen are you just popular?
22:58:08 <lambdabot> yes, i am
23:00:13 <lispy> mmm....fios
23:00:32 <skew> repiret_: if that's all you want a program to do, you could use something like getContents
23:01:10 <Turks> Hrm
23:01:18 <Turks> FiOS...interesting..
23:01:21 <lispy> do c <- getContents; return (lines c) -- yay, all the lines in a file, lazily!
23:01:28 <lispy> er not a file but stdin
23:01:36 <LoganCapaldo> oooo
23:01:52 <Turks> verison offers FiOS?
23:02:02 <LoganCapaldo> lispy: can you then use filter / map etc on the lines?
23:02:06 <lispy> Turks: yes, in fact, they are the only one in my state that seems to offer it
23:02:13 <lispy> LoganCapaldo: ya
23:02:16 <Turks> :o
23:02:28 <Turks> i wonder if its available here...
23:02:33 <lispy> lambdabot: the trick here is that getContents is magical and does it's job lazily...
23:02:42 <Turks> :O fuck
23:02:54 <lispy> why did i tell that to lambdabot
23:02:58 <lispy> LoganCapaldo: ^^^
23:03:15 <Turks> heh, is there a way to hack into a router whos password isnt known?
23:03:43 <LoganCapaldo> lambdabot wanted to know too :)
23:03:47 <lispy> Turks: it's off topic, but if you have physical access most of them let you reset the hardware
23:04:00 <Turks> damnit
23:04:04 <lisppaste2> skew annotated #29876 with "one shot" at http://paste.lisp.org/display/29876#1
23:04:11 <Turks> so much for s&d on ports
23:04:14 <Excedrin> physical = console
23:04:19 <Turks> specially for IRCd
23:04:25 * Turks kicks his routers
23:05:34 <LoganCapaldo> so to answer repiret_'s question you could do something like takeWhile (\s -> s /= ".") lines $ getContents $ handle
23:05:58 <skew> (/= ".")
23:06:12 <LoganCapaldo> ;)
23:06:17 <Turks> :>
23:06:57 <Turks> heh
23:07:15 <Turks> i dont think it would be wise to run IRCd on 56k dial up :>
23:07:33 <lispy> ?pl \s -> s /= "."
23:07:34 <lambdabot> ("." /=)
23:07:41 <LoganCapaldo> Turks: If all your customers are on 2400 baud
23:08:05 <Turks> ..lol
23:08:06 <LoganCapaldo> lambdabot: Thank you. yes /= is commutitive :)
23:08:26 <Turks> Well its worth a shot ;)
23:08:55 <lispy> ?scheck \s -> ("." /= s) == ("." /= (s::String))
23:08:56 <lambdabot>  add an instance declaration for (Serial Char)
23:08:56 <lambdabot>   In the definition of `klk...
23:09:01 <lispy> ?check \s -> ("." /= s) == ("." /= (s::String))
23:09:03 <lambdabot>  OK, passed 500 tests.
23:09:08 <lispy> must be true
23:09:09 <Turks> o.0
23:09:12 <LoganCapaldo> heh
23:09:28 <LoganCapaldo> But what if the 501 test failed?
23:09:32 <Turks> lol
23:10:00 <merus> Mathematics to the rescue!
23:10:10 <lispy> LoganCapaldo: then you probably wrote it in C? ;)
23:11:34 * merus frowns at the random number generator.
23:11:57 <lispy> ?check > 10
23:11:58 <lambdabot>  Parse error
23:12:02 <lispy> ?check (> 10)
23:12:02 <lambdabot>  Add a type signature
23:12:11 <lispy> ?check \x -> ((x::Int)> 10)
23:12:12 <lambdabot>  Falsifiable, after 0 tests: -1
23:12:16 <lispy> ?check \x -> ((x::Int) < 10)
23:12:17 <lambdabot>  Falsifiable, after 27 tests: 12
23:12:23 <lispy> oh nice
23:12:27 <lispy> much better than it used to be
23:12:30 <lispy> ?check \x -> ((x::Int) < 100)
23:12:32 <lambdabot>  Falsifiable, after 273 tests: 124
23:12:39 <lispy> ?check \x -> ((x::Int) < 1000)
23:12:41 <lambdabot>  OK, passed 500 tests.
23:12:45 <lispy> ah there we go
23:12:53 <lispy> so all haskell ints are less than 1000
23:13:06 <lispy> we have done an emperical study with 500 datapoints
23:13:10 * LoganCapaldo laughs
23:13:13 <dons> :)
23:13:24 <lispy> most studies only use 20-30 subjects
23:13:31 <lispy> using 500 is just good science!
23:13:45 <lispy> dons: no emoticons until hs-plugins is ready :)
23:14:07 <LoganCapaldo> ?check \x -> ((x::Int) < 1000) and 1001 < 1000
23:14:08 <lambdabot>    The function `((x :: Int) < 1000)' is applied to two arguments,     but ...
23:14:19 <dons> lispy: argh ok!
23:14:39 <LoganCapaldo> ?check \x -> (((x::Int) < 1000) and 1001 < 1000)
23:14:40 <lambdabot>    The function `((x :: Int) < 1000)' is applied to two arguments,     but ...
23:14:50 <lispy> you want && not and
23:15:00 <LoganCapaldo> ?check (\x -> ((x::Int) < 1000) && 1001 < 1000)
23:15:01 <lambdabot>  Falsifiable, after 0 tests: 1
23:15:15 <lispy> ?check \x -> (((x::Int) < 1000) && 1001 < 1000)
23:15:16 <lambdabot>  Falsifiable, after 0 tests: 2
23:15:36 <lispy> heh, why did that take two tests
23:15:45 <lispy> oh i misread
23:15:58 <lispy> ?scheck False
23:16:00 <lambdabot>   Failed test no. 1. Test values follow.:
23:16:06 <lispy> ?scheck True
23:16:08 <lambdabot>  Completed 1 test(s) without failure.
23:16:23 <LoganCapaldo> ?1 + 1
23:16:24 <lambdabot> Maybe you meant: . v
23:16:34 <lispy> scheck is cooler, but it doesn't support as many types apparently
23:16:38 <LoganCapaldo> ?v 1 + 1
23:16:38 <Turks> lal-99-102.Reshall.Berkeley.EDU <-- o.0
23:16:38 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
23:16:48 * LoganCapaldo blinks
23:16:51 <lispy> ?v
23:16:52 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
23:16:55 <lispy> you want
23:16:57 <lispy> > 1 + 1
23:16:58 <lambdabot>  2
23:17:06 <Turks> :o
23:17:09 <LoganCapaldo> > show "Aha"
23:17:10 <lambdabot>  "\"Aha\""
23:17:10 <skew> > fix show
23:17:12 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
23:17:14 <Turks> ll
23:17:16 <Turks> ol
23:17:19 <Turks> lol
23:17:20 <lispy> v is basically, take n (fix show 0
23:17:27 <lispy> > take 20 (fix show)
23:17:29 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
23:17:34 <Turks> > show Jaja
23:17:35 <lambdabot>  Not in scope: data constructor `Jaja'
23:17:37 <Turks> lol
23:17:39 <repiret_> skew, lispy, Logan: The problem with getContents is that it closes the file when its done.
23:17:50 <dons> the new version of smallcheck has instances for more types
23:17:53 <dons> i should update
23:17:58 <repiret_> i had actually first written it in terms of getContents, and then ran into that problem
23:18:01 <Turks> > show "Jaja"
23:18:02 <lambdabot>  "\"Jaja\""
23:18:06 <Turks> Lol
23:18:07 <lispy> repiret_: getContents runs on stdin, get i think you're right about hGetContents
23:18:26 <skew> if you want you could define some control structures to help
23:18:29 <repiret_> getContents closes stdin even
23:18:36 <lispy> repiret_: ah
23:18:53 <threeq> @paste
23:18:53 <lambdabot> http://paste.lisp.org/new/haskell
23:18:56 <lispy> then i bet getContents = hGetContents stdin
23:19:52 <lispy> i will admit, getContents is nice for simple things but it seems to break when you're doing serious stuff
23:20:11 <dons> yeah hmm. i keep meanign to add strict IO to System.IO
23:20:12 <lispy> the fact that you have to evaluate the spine of the list it returns is just annoying
23:20:32 <lispy> it actually makes it unsafe in many places
23:20:53 * lispy proposes unsafeGetContents and unsafeHGetContents
23:21:12 <dons> how about getContents'
23:21:18 <LoganCapaldo> putitbackinthesafeGetContents ;)
23:21:20 <lispy> for a strict version? sure
23:21:25 <Turks> lol
23:21:38 <lispy> dons: that would match foldl'
23:21:54 <dons> ?type Data.ByteString.getContents -- or this
23:21:55 <lambdabot> IO Data.ByteString.Base.ByteString
23:22:03 <lispy> it's a little late to have prime mean strict, but in CL destructive functions end in * (usually)
23:22:08 <LoganCapaldo> foldl' enforces strictness?
23:22:13 <lispy> LoganCapaldo: yes
23:22:21 <lispy> LoganCapaldo: so does foldl1'
23:22:22 <LoganCapaldo> and how does it do that?
23:22:31 <LoganCapaldo> is there some secret incantation?
23:22:33 <lispy> probably an seq
23:22:39 <lispy> ?type seq
23:22:40 <lambdabot> forall b a. a -> b -> b
23:22:43 <skew> there is a sequet incatation.
23:22:48 <lispy> > undefined `seq` 1
23:22:49 <lambdabot>  Undefined
23:22:58 <lispy> skew: heh
23:23:04 <sieni> lispy: what?
23:23:17 <sieni> lispy: I haven't heard about such CL convention
23:23:18 <lispy> ?remember skew [on the subject of strictness] there is a sequet incatation.
23:23:28 <skew> incatation?
23:23:29 <LoganCapaldo> > [ x | x <- [1,2...] ] `seq` 3
23:23:30 <lambdabot>  Parse error
23:23:37 <skew> that was not intentional
23:24:02 <lispy> sieni: that's what i was taught
23:24:08 <sieni> lispy: I know that in scheme, ! is used to indicate that some destruction is taking place
23:24:11 <LoganCapaldo> > [ x | x <- [1,2...] ] `seq` [3]
23:24:12 <lambdabot>  Parse error
23:24:17 <lispy> sieni: let me see if i can find a function in CL which is destructive
23:24:17 <LoganCapaldo> :(
23:24:19 <sieni> lispy: could you give some examples
23:24:19 <threeq> > [ x | x <- [1,2..] ] `seq` 3
23:24:21 <lambdabot>  3
23:24:28 <LoganCapaldo> too many dots
23:24:30 <LoganCapaldo> aha
23:24:30 <dons> hey threeq, how's code?
23:24:35 <LoganCapaldo> now I'm confused
23:24:43 <LoganCapaldo> why didn't lambdabot explode?
23:24:44 <Turks> Good night folks ;)
23:24:55 <threeq> dons: hmm?
23:25:10 <dons> lokadin: seq gives you whnf on the list, i.e. (x:xs)
23:25:30 <dons> > length [1..] `seq` 3 -- deep seq
23:25:34 <lambdabot> Terminated
23:25:34 <robreim> dons' IRC bot tutorial contains join . intersperse. It needs to be updated to use intercalate :P
23:25:37 <LOkadin> what's seq and whnf?
23:25:43 <dons> robreim: oh right!
23:25:46 <sieni> lispy: like `nconc' is the destructive version of `append'
23:25:49 <dons> whnf == weak head normal form
23:25:58 <dons> seq == evaluate first argument to whnf
23:26:08 <dons> then return the second argument
23:26:22 <Turks> heh, hey dons, in that bot tutorial, is there another page for a irc client tutorial?
23:26:29 <dons> there could be...
23:26:31 <lispy> sieni: yeah, maybe it was just a convention i had forced on me in college, because now that i'm looking i don't see an example which is already in the language
23:26:32 <dons> if someone wrote it
23:26:33 <LoganCapaldo> so wait
23:26:42 <LoganCapaldo> I rescued it by throwing that 2 in there?
23:26:46 <Turks> ...lol
23:26:57 <sieni> lispy: http://www.cliki.net/Naming%20conventions
23:26:59 <lambdabot> Title: CLiki : Naming conventions
23:27:01 <sieni> lispy: ok.
23:27:09 <LoganCapaldo> (1:2:xs), is that what happened?
23:27:39 <sieni> it seems to say that n is often prepended to indicate a destructive operation
23:27:54 <lispy> sieni: i'd buy thta
23:28:12 <lispy> i tried not to use anything destructive in lisp
23:28:23 <lispy> i found right way that it made debugging at least 6x harder!
23:28:40 <LoganCapaldo> lispy: Would you say you were more CONStructive?
23:28:42 <lisppaste2> threeq pasted "shootout sum-file" at http://paste.lisp.org/display/29878
23:28:43 <LoganCapaldo> ;)
23:28:53 <lispy> LoganCapaldo: :)
23:28:59 <dons> > [1,2..] `seq` 3
23:29:01 <lambdabot>  3
23:29:18 <dons> just evaluated the list to (1:xs) form, the outermost constructor
23:29:26 <LoganCapaldo> > [1..] `seq` 3
23:29:27 <lambdabot>  3
23:29:34 <dons> > (1 : [2..]) `seq` 3
23:29:35 <lambdabot>  3
23:29:44 * LoganCapaldo is lacking in understanding today
23:29:48 <Korollary> dons: (1:xs) or just (:) _ _ ?
23:29:50 <dons> however, if you try to take the length, that will force the entire spine of the list
23:30:01 <dons> Korollary: right, (:) x xs
23:30:16 <threeq> does anyone have any suggestions for this shootout entry? http://paste.lisp.org/display/29878
23:30:25 <lispy> do we have a tutorial that explains how the graph reduction is done?  i think that would be really helpful for newbies here
23:30:27 <dons> (1 : undefined) `seq` 3
23:30:28 <skew> I think ord is fromEnum, for Char
23:30:34 <dons> > (1 : undefined) `seq` 3
23:30:36 <lambdabot>  3
23:30:46 <dons> > (undefined : undefined) `seq` 3
23:30:47 <lambdabot>  3
23:30:49 <lispy> in fact, maybe we could have lambdabot step through the graph
23:30:55 <encryptio> > () `seq` 3
23:30:56 <dons> Korollary++ -- good idea
23:30:57 <lambdabot>  3
23:31:06 <skew> ?pl nextDigit num char = num * 10 + ord char - ord '0'
23:31:07 <dons> lispy: yeah, with hat we could probably do that'
23:31:07 <lambdabot> nextDigit = flip flip (ord '0') . ((-) .) . (. ord) . (+) . (10 *)
23:31:23 <threeq> skew: haha
23:31:34 <dons> LoganCapaldo: so consider the difference between these:
23:31:38 <dons> > undefined `seq` 3
23:31:40 <lambdabot>  Undefined
23:31:47 <dons> > (:) undefined undefined `seq` 3
23:31:48 <lambdabot>  3
23:31:53 <skew> ?pl \x y -> f x + g y
23:31:55 <lambdabot> (. g) . (+) . f
23:32:02 <skew> ?pl \x y -> f y + g x
23:32:03 <lambdabot> (. f) . (+) . g
23:32:04 <LoganCapaldo> dons: Yeah I think I got it
23:32:07 <dons> the first argument to `seq` is evaluated to the outermost constructor, i.e. weak head normal form
23:32:08 <lispy> ?type (:) undefined undefined
23:32:10 <lambdabot> forall a. [a]
23:32:15 <dons> so, if its `undefined', you get bottom
23:32:22 <dons> but if its wrapped in a (:) constructor, you get that
23:32:43 <dons> so it effectively evaluates as little as possible :)
23:32:52 <LoganCapaldo> yep
23:33:14 <lispy> i like to think that it "peeks" at it, if it doesn't look like undefined at a glance it goes on
23:33:26 <LoganCapaldo> heh
23:34:11 <lispy> how many distinct ways can you force evaluation in haskell?
23:34:27 <lispy> 1) case, 2) seq, 3) ??
23:34:31 <dons> case and seq. hmm.
23:34:37 <dons> pseq , par :)
23:34:55 <dons> and you can *delay* evaluation further with let
23:35:00 <lispy> are pseq and par built on seq though?
23:35:20 <dons> not sure.
23:35:24 <LoganCapaldo> Oh wow
23:35:25 <lispy> dons: you have an example with the let?
23:35:34 <LoganCapaldo> I just realized you need seq to be special
23:35:48 <dons> > let x = 1+2 in 7
23:35:49 <lambdabot>  7
23:36:04 <LoganCapaldo> since you can't write it yourself, at least I can't think of a way
23:36:06 <dons> it explicitly allocates a thunk for the unevaluated 1+2
23:36:13 <dons> LoganCapaldo: exactly!
23:36:25 <dons> you can't write it in the language. but its ever so useful
23:36:28 <lispy> LoganCapaldo: if you knew the data constructor of the first argument you could do it
23:37:02 <lispy> so i wonder, if we added a reflection mechanism to haskell to get the data constructor, could we then implement seq?
23:37:27 <lispy> LoganCapaldo: you could do something similar with a type class also, as long as each type you want to use seq on makes itself an instance
23:38:07 <Turks> damn, why cant this be more like basic ;)
23:38:13 <lispy> instance Seq [] where seq (_:_) b = b
23:38:28 <Korollary> I dont think you can implement seq from others
23:38:29 <lispy> instance Seq Foo where seq (Foo _) b = b
23:38:39 <Turks> Foooo!
23:39:41 <Turks> heh, does uptime work with lambdabot?
23:39:51 <Korollary> ?uptime
23:39:52 * lispy has learned a lot of neat ideas from chatting in #haskell
23:39:52 <LoganCapaldo> > uptime
23:39:52 <lambdabot> uptime: 6h 11m 59s, longest uptime: 7d 1h 24m 44s
23:39:53 <lambdabot>  Not in scope: `uptime'
23:40:06 <lispy> LoganCapaldo: ">" is short of ?run
23:40:10 <Turks> Lol
23:40:16 <encryptio> where might i find lambdabot's source?
23:40:17 <lispy> ?run 1 + 1
23:40:18 <lambdabot>  2
23:40:23 <lispy> ?version
23:40:24 <lambdabot> lambdabot 4p263, GHC 6.5 (OpenBSD i386)
23:40:24 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:40:25 <Korollary> @where lambdabot
23:40:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:40:29 <Turks> lol
23:40:37 <encryptio> coo. thanks.
23:40:45 <LoganCapaldo> > takeWhile (< 5) [1,2..]
23:40:46 <lambdabot>  [1,2,3,4]
23:40:47 <Korollary> ?vixen Can you pay my bills?
23:40:48 <lambdabot> why don't you guess?
23:40:50 <LoganCapaldo> :)
23:40:53 <lispy> encryptio: dons is happy to accept patches :)
23:41:04 <Turks> heh, has there ever been a case where the one of the bots has been up for years?
23:41:14 <LoganCapaldo> ?help
23:41:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:41:18 <Turks> or months, weeks, etc
23:41:23 <LoganCapaldo> ?list
23:41:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:41:35 <lispy> Turks: i don't think freenode is stable enough :)
23:41:40 <Turks> lol
23:41:50 <Turks> more stable then my server :P
23:41:51 <dons> i've had lambdabot up for 6 weeks on slashnet
23:42:02 <LoganCapaldo> ?dice
23:42:02 <encryptio> i've had bots on whatnet go for months
23:42:03 <lambdabot> unexpected end of input: expecting number
23:42:04 <lispy> what is slashnet?
23:42:04 <Turks> then again, my server isnt public :P
23:42:06 <dons> but here on freenode i reboot it weekly anyway, since we patch and add features so oftren
23:42:10 <lispy> ?dice 1d5
23:42:10 <Turks> ?dice 6
23:42:11 <lambdabot> 1d5 => 3
23:42:11 <LoganCapaldo> ?dice 3 6
23:42:11 <lambdabot> 6 => 6
23:42:11 <lambdabot> 3 6 => 36
23:42:20 <Turks> lol
23:42:22 <dons> basically its limited by stability of the network
23:42:38 <dons> lispy: oh, some other irc network
23:42:47 * lispy gasps
23:42:57 <LoganCapaldo> ?dice 4d6 drop the lowest, do it 8 times and then pick feats for my character too
23:42:58 <lambdabot> unexpected "d": expecting digit, "+" or end
23:43:01 <Turks> acually, ive got my bot connected via localhost...but i doubt you are able to connect via that ;)
23:43:03 <lispy> i thought there was only oftc, freenode and efnet
23:43:21 <dons> ?version
23:43:22 <lambdabot> lambdabot 4p263, GHC 6.5 (OpenBSD i386)
23:43:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:43:27 <dons> encryptio: ^^
23:43:33 <dons> ?uptime
23:43:34 <lambdabot> uptime: 6h 15m 40s, longest uptime: 7d 1h 24m 44s
23:43:46 <dons> see, it basically gets reset each Tuesday :) hence 7 days
23:44:00 <lispy> <SiR> uptime: 7d 23h 20m 14s, longest uptime: 23d 7h 2m 57s
23:44:04 <LoganCapaldo>  lambdabot You are going to die (temporarily) in seven days
23:44:12 <Turks> 23:43:38  <CSBot>	 hi #Haskal :)
23:44:12 <lispy> my bot is getting behind on patches :)
23:44:25 <Turks> :P
23:44:35 <dons> i've another bot next door, 18:43  dons> ?uptime
23:44:35 <dons> 18:43  lambdabot> uptime: 11d 6h 14m 33s, longest uptime: 11d 6h 14m 33s
23:45:07 <Turks> wth?
23:45:07 <dons> the max i've seen is 44 days so far
23:45:16 <dons> but i suppose there are some really stable small networks around?
23:45:27 <Turks> hehe, run your own =]
23:45:29 <dons> a bot on that could run for quite a while, i'd imagine
23:46:02 * dons >>> home
23:46:04 <Turks> Anyway, i updated my bot's code...sooo..off to beddy bye land for me :P
23:47:03 <encryptio> my bot has 47 days on whatnet... has updating without restarting... it's Perl though *gasp*
23:47:07 <lispy> oh wow, my server has been up 5.8 months
23:47:27 <lispy> lambdabot doesn't have to reboot to get patches, i don't think
23:47:32 <lispy> unless they affect the core
23:47:44 <Turks> lispy: which server :P ?
23:48:15 <lispy> Turks: it's just a shell server i do some haskell stuff on
23:48:51 <Turks> Hehe
23:48:58 <Turks> IRCd version?
23:50:01 <lispy> no irc
23:50:45 <Turks> ?
23:55:54 <merus> How would I go about turning something of type [IO Int] into IO [Int]?  I can map return onto the [IO Int] thing and get [Int], but I'm not sure how to get to IO [Int] from there.
23:56:18 <merus> I sense there's a more direct way, but I suck at monad.
23:58:29 <astrolabe> @type sequence
23:58:31 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
23:58:41 <merus> danke.
23:58:59 <astrolabe> bitter :)
23:59:11 <merus> I hope you're not bitter with my noob question :O
23:59:26 * merus rimshots.
23:59:51 <therp> merus: with that it would be, do a <- head "[IO Int]-thing"; return [a];
