00:00:34 <edwardk> skew: still can't find the post. http://www.haskell.org/mailman/listinfo/libraries ?
00:00:38 <lambdabot> Title: Libraries Info Page, http://tinyurl.com/y75aoh
00:00:56 <skew> http://www.haskell.org/pipermail/libraries/2006-November/006228.html ?
00:00:59 <lambdabot> Title: Proposal discussion summary: Adding on, http://tinyurl.com/y8waaj
00:01:46 <edwardk> ah
00:02:39 <edwardk> similar to http://comonad.com/reader/2006/generalizing-dot/
00:02:42 <lambdabot> Title: The Comonad.Reader Â» Generalizing (.), http://tinyurl.com/trnfz
00:06:50 <Smokey`> dons / Cale: Do you guys think you might be able to point me in the right direction, in relation to articles/papers on optimizing haskell code... (i know that's a pretty generic question, but I'm not too sure what I'm talking about :P)
00:07:06 <Cale> read dons' paper on it :)
00:07:16 <Smokey`> name, or linky? :P
00:07:25 <edwardk> now if only the other half of that puzzle was typable in haskell, if i could then use "foo" as a function from naturals to characters, then: toUpper . "foo" becomes "FOO"  and toUpper . "foo" . [2,1] becomes "OF", etc.
00:07:42 <Cale> http://www.cse.unsw.edu.au/~dons/fps.html -- It's linked from here
00:07:43 <lambdabot> Title: Data.ByteString
00:07:47 <Smokey`> Just got basic ray tracer stuff working (intersections, very simple shading... nothing special), and with with ghc 6.6, with -O2, it's still about 15.4 times slower :P
00:07:52 <Smokey`> thanks Cale
00:07:52 <Cale> you might also be interested in the other stuff about that library
00:08:06 <edwardk> and you can nicely show that . associates properly in the above case
00:08:19 <Smokey`> (err, 15.4 times slower than my C++ equivilent, doing the same thing)
00:08:30 <Cale> Smokey`: that's about optimising stream-processing code, and string IO, mostly
00:08:39 <Cale> Smokey`: Have you profiled it?
00:09:11 <Smokey`> Cale: hmm, I should probably learn how to profile haskell binaries :P  (though presumably it wouldn't be much diff to anything else)
00:09:24 <Cale> GHC has a decent profiler
00:09:40 <skew> Smokey`: the GHC user's guide has a second on optimizing
00:09:43 <Cale> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/profiling.html
00:09:46 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/qtwbd
00:10:22 <Smokey`> Cale: thanks again :)
00:10:43 <skew> also http://www.haskell.org/haskellwiki/Performance/GHC
00:10:46 <lambdabot> Title: Performance/GHC - HaskellWiki, http://tinyurl.com/yduwfl
00:10:51 <Smokey`> skew: thanks :)
00:27:23 <Excedrin> aha, I finally got it
00:27:52 * skew ponders the absurd juxtaposition of Haskell and Java solutions to this bowling scoring problem
00:32:15 <dolio> That article is totally ridiculous.
00:34:34 <Sara|Univ> how do you register for the irc?
00:34:45 <Sara|Univ> authserv@services.freenode.net doesn't work :)
00:34:54 <skew> msg NickServ?
00:35:08 <ibid> Sara|Univ: nickserv
00:35:14 <Sara|Univ> -NickServ- Unknown command [AUTH]
00:35:20 <Sara|Univ> oh wait a sec
00:35:24 <ibid> Sara|Univ: /mag nickserv help
00:38:05 <skew> dolio: anything in particular?
00:38:52 <Sara|Univ> hm
00:40:07 <dolio> I don't know. I'd consider being able to solve problems by recursion a pretty basic skill for computer programming, whatever language you're using.
00:40:18 <dolio> Provided you have something like functions at all.
00:40:30 <dolio> Or have done high school math.
00:40:44 <skew> certainly by induction
00:41:41 <skew> but I don't think that part is too bad - the problem isn't solved by structural induction, it actually needs a counter
00:41:49 <emu> being able to construct general or partial recursive functions is handy
00:42:16 <skew> I just think the contrast between the Java and Haskell code is hilarious
00:42:23 <Cale> which article?
00:42:26 <dolio> And the Java version of the haskell algorithm is, of course, hilarious. :)
00:42:29 <skew> the size of the test code too
00:42:52 <skew> and HUnit isn't even that polished, as far as combinator libraries go
00:43:37 <skew> Cale: recent things from www.xprogramming.com
00:45:11 <dolio> I'm not certain a first pass solution to the problem with loops would have caught the bug either.
00:45:37 <dolio> Since you could easily try to just sum up the scores appropriately without trying to keep track of the number of frames you've seen.
00:46:46 <dolio> Either way you need to figure out that looking only at the end of the list is ambiguous.
00:47:16 <skew> I'm wondering if there are any nice algebraic properties
00:47:26 <skew> or perhaps some inductive family of valid sequences of rolls
00:48:06 <dolio> The ambiguous cases aren't attractive, either.
00:48:33 <dolio> So it's easy to overlook them.
00:48:51 <skew> that's why QuickCheck is nice, if you can think of properties
00:49:08 <dolio> Yeah.
00:53:33 <skew> have you seen the functional pearl about Sudoku?
00:54:11 <dolio> Not sure.
00:54:51 <skew> "Functional Pearls: A program to solve Sudoku"
00:55:03 <skew> I saw Bird present it at ICFP, don't know where you can download it
00:55:45 <dolio> Google has a hit, but the link seems to be 0 bytes.
00:58:44 <dolio> Ah, I see why. Cambridge Journals wants $20 for it.
00:59:05 <skew> unfortunate
00:59:28 <skew> it was a particularly elegant derivation
00:59:40 <skew> started with enumerating all possible boards
00:59:54 <skew> and filtering the results
01:00:16 <skew> then a little equational reasoning and cleverness mixed in the pruning, for a sufficiently efficient solution
01:00:54 <skew> also, there were some nice self-inverse transformations from lists of the puzzle rows into lists of row/column/square contents
01:05:21 <Smokey`> is it at all possible to force evaluation of something (kind of, side track lazy evaluation of a specific varaible)?
01:06:03 <dolio> Oh yeah, there's some mention of it on the haskell wiki sudoku page.
01:06:43 <skew> Smokey`: sure, if you want to optimize and you have some idea where it might help
01:07:04 <dolio> Although it's, evidently, Graham Hutton solving it like Bird.
01:07:04 <Smokey`> skew: and how do I force evaluation of said variable?
01:07:11 <skew> seq or bang patterns (if you're running 6.6)
01:07:18 <Smokey`> thanks :)
01:07:51 <skew> with some practice you can tell from the Core whether GHC already decided something is strict
01:14:06 <ademan> i'm starting to get interested in functional programming but i still don't quite get it (see: don't get it at all) anyone have links to some functional programming explanation that changed their life or something like that?
01:14:20 <skew> I played with Unlambda for a bit
01:15:23 <dolio> I don't know if there's any one thing you can read that will suddenly make you get it.
01:15:45 <Smokey`> hehe, hey ademan :)   start with http://www.haskell.org/haskellwiki/Learning_Haskell  has a whole list of places to start.
01:15:48 <lambdabot> Title: Learning Haskell - HaskellWiki, http://tinyurl.com/gg7z2
01:15:51 <dolio> At least, there isn't in my experience.
01:16:42 <skew> Figuring out church encodings and stuff in a pure lambda calculus helped me figure out how you can compute at all
01:16:53 <Smokey`> ademan: from my experience, alot of those tutorials take rather different approaches in teaching haskell (and assume a whole variety of different backgrounds), so if one tutorial doesn't seem like it's getting far, try another :)
01:18:23 <Smokey`> on a side note, I tend to prefer www.haskell.org/tutorial/ but I had a bit of background in haskell before I started from these tutorials (done a little bit at uni)
01:19:22 <dolio> skew: You might find this interesting: http://cs.nott.ac.uk/~gmh/sudoku.lhs
01:19:27 <ademan> alright thanks, i'm actually off to bed for the night, but i'm gonna bookmark those pages (along with the wikipedia page)
01:19:40 <skew> just a minute
01:19:48 <skew> http://www.madore.org/~david/programs/unlambda/
01:19:52 <lambdabot> Title: The Unlambda Programming Language, http://tinyurl.com/ezy8x
01:19:54 <dolio> The code for "Sudoku ... à la Bird"
01:21:03 <therp> skew: thank you for discussion the faststring interning problem recently. your suggestion was totally correct about the linker environment, and I already though of that, but my idea of how linking is done was wrong, and therefore I concluded the wrong results from the tests I made.
01:24:55 <skew> how did it work? I just heard dons has similar problems making hs-plugins
01:28:08 <therp> skew: well, it's interned in the wrong interning table by faststring. fixing it either means recreating all faststring in the data structure returned to a different linker environment, or better shift the actual generation of FastStrings in the environment they should be finally used. instead of return a data structure X, one could for instance return a function () -> X that generates the data structure,  this could be called in t
01:28:08 <therp> he right environment and viola working fast strings
01:28:41 <skew> oh, it's using some unsafePerformIO?
01:29:00 <therp> yes, in the IORef for the interning table
01:29:12 <skew> :(
01:30:07 <therp> well, it's ok and can be easily fixed with the trick of returning "data structure generating function" instead of the data structure. GHC is clever when it comes to relinking functions into a different linker environnment, that's actually quite cool
01:32:21 <therp> just for reference: at least I think it can be fixed that way, I have refactored my code differently
01:34:39 <lispy> ?pl \f g -> join . (liftM f . g)
01:34:40 <lambdabot> ((join .) .) . (.) . fmap
01:35:16 <lispy> ?type \f g -> join . (liftM f . g)
01:35:18 <lambdabot> forall a (m :: * -> *) a1 a11. (Monad m) => (a1 -> m a) -> (a11 -> m a1) -> a11 -> m a
01:35:20 <lispy> :t ap
01:35:26 <lispy> ?type ap
01:35:27 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
01:35:55 <lispy> those are very similar
01:37:21 <lispy> ?type liftM2 (.)
01:37:23 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
01:37:40 <dolio> (b -> r -> a) -> (c -> r -> b) -> (c -> r -> a)
01:37:45 <lispy> actulaly, think liftM2 (.) is closer than apis
01:38:02 <lispy> ?pl liftM2 (.)
01:38:03 <lambdabot> liftM2 (.)
01:38:29 <lispy> i'm surprised that join . (liftM f . g) doesn't have a name
01:39:08 <dolio> Hmm...
01:39:28 <lispy> ?type join . (liftM f . g) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
01:39:30 <lambdabot> Not in scope: `f'
01:39:30 <lambdabot>  
01:39:30 <lambdabot> <interactive>:1:18: Not in scope: `g'
01:39:40 <lispy> ?type \f g -> join . (liftM f . g) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
01:39:42 <lambdabot>   Inferred type is less polymorphic than expected
01:39:42 <lambdabot>    Quantified type variable `c' is mentioned in the environment:
01:39:56 <lispy> that should type check...
01:40:23 <dolio> ?type (>>>)
01:40:24 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
01:40:51 <dolio> (>>>) for Kleisli arrows?
01:42:03 <lispy> ?type (\f g -> join . (liftM f . g)) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
01:42:05 <lambdabot>   Couldn't match the rigid variable `a' against the rigid variable `c'
01:42:06 <lambdabot>    `a' is bound by the polymorphic type `forall (m :: * -> *) a b c.
01:42:22 <lispy> i'm not sure why that fails
01:42:22 <dolio> ?type runKleisli
01:42:24 <lambdabot> forall b (m :: * -> *) a. Kleisli m a b -> a -> m b
01:42:30 <lispy> ?type (\f g -> join . (liftM f . g))
01:42:32 <lambdabot> forall a (m :: * -> *) a1 a11. (Monad m) => (a1 -> m a) -> (a11 -> m a1) -> a11 -> m a
01:43:06 <lispy> oh hmm...
01:43:10 <lispy> maybe because i have a typo
01:43:18 <lispy> ?type (\f g -> join . (liftM g . f))
01:43:20 <lambdabot> forall a (m :: * -> *) a1 a11. (Monad m) => (a11 -> m a1) -> (a1 -> m a) -> a11 -> m a
01:43:37 <lispy> ?type (\f g -> join . (liftM g . f)) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
01:43:39 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> (a -> m c) :: forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:43:42 <lispy> there we go
01:43:49 <lispy> ?pl (\f g -> join . (liftM g . f))
01:43:50 <lambdabot> ((join .) .) . flip ((.) . fmap)
01:44:14 <lispy> ?hoogle Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
01:44:15 <lambdabot> No matches, try a more general search
01:44:22 <lispy> ?hoogle (a -> m b) -> (b -> m c) -> (a -> m c)
01:44:24 <lambdabot> No matches, try a more general search
01:44:32 <dolio> ?type (\f g -> runKleisli ((Kleisli f) >>> (Kleisli g)))
01:44:34 <lambdabot> forall a (m :: * -> *) a1 b. (Arrow (Kleisli m)) => (a -> m a1) -> (a1 -> m b) -> a -> m b
01:44:43 <lispy> nice
01:44:52 <lispy> i have no idea what Kleisli is
01:45:13 <dolio> a -> m b for a monad m.
01:47:02 <lispy> > (\f g -> join . (liftM g . f)) (return . Just . (+1)) (return . Just . (+2)) 3
01:47:03 <lambdabot>  add an instance declaration for (Show (m (Maybe (Maybe a))))
01:47:22 <lispy> > (\f g -> join . (liftM g . f)) (Just . (+1)) (Just . (+2)) 3
01:47:24 <lambdabot>  Just 6
01:48:18 <dolio> Unfortunately newtype wrapping is needed.
01:48:44 <dolio> Otheriwise you could just write (Just . (+1)) >>> (Just . (+2)) $ 3, or something like that.
01:51:20 <dolio> ?type runKleisli . arr
01:51:22 <lambdabot> forall (m :: * -> *) b c. (Arrow (Kleisli m)) => (b -> c) -> b -> m c
01:51:51 <dolio> > ((arr (+1)) >>> (arr (+2))) 3 :: Maybe Int
01:51:52 <lambdabot>  add an instance declaration for (Num (Maybe Int))
01:52:21 <dolio> > runKleisli ((arr (+1)) >>> (arr (+2))) 3 :: Maybe Int
01:52:23 <lambdabot>  Just 6
01:52:49 <dolio> > runKleisli ((arr (+1)) >>> (arr (+2))) 3 :: [Int]
01:52:51 <lambdabot>  [6]
01:53:46 <lispy> ?type lookup
01:53:49 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
01:54:26 <gene9> ?type runKleisli
01:54:28 <lambdabot> forall b (m :: * -> *) a. Kleisli m a b -> a -> m b
01:54:31 <gene9> ?type Kleisli
01:54:33 <lambdabot> forall b a (m :: * -> *). (a -> m b) -> Kleisli m a b
01:55:02 <lispy> > (\f g -> join . (liftM g . f)) (flip lookup [(1,1), (2,2), (3,3)]) (Just . (+1)) 3
01:55:04 <lambdabot>  Just 4
01:55:21 <joelr1> good morning
01:55:26 <lispy> joelr1: morning
01:55:34 <lispy> or bedtime for me :)
01:55:37 <joelr1> anybody trading options or futures?
01:56:01 <lispy> trading futures sounds like a job for the list monad...
01:56:13 <lispy> ;)
01:56:23 <joelr1> :)
01:57:20 <lispy> > (\f g -> join . (liftM g . f)) (flip lookup [(1,1), (2,2), (3,3)]) return 3
01:57:22 <lambdabot>  Just 3
01:58:40 <roconnor> joelr1: I lost big trading on the republicans holding the senate.  good thing it was only fake money.
01:59:18 <joelr1> roconnor: :D
02:05:17 <Syzygy-> roconnor: Not so good with the bet then...
02:07:13 <roconnor> Syzygy-: I appear to be anti-correlated.
02:08:13 <Syzygy-> Hehe
02:08:36 <Syzygy-> If that actually holds up more solidly, I may have a few bets to suggest to you in the future... ;)
02:19:22 <musasabi_> Is there a reason FastMutInt is not packaged?
02:50:05 <dcoutts> musasabi, perhaps because it's evil? :-)
02:50:38 <mwc> oooh, what's evil?
02:50:43 * mwc likes evil
02:51:35 <dcoutts> mwc, FastMutInt
02:52:08 <dcoutts> mwc, which I suppose is somewhat like a IORef Int#
02:52:41 <dcoutts> (though of course there's no such thing as an IORef Int#)
02:56:07 <dibblego> I just figured out a way to properly emulate Maybe in Java
02:57:14 <Binkley> in the sense that you can use objects to emulate any sum-of-products type? :-)
02:57:50 <dibblego> in the sense that the compiler will fail if you attempt to get a from Maybe a if it is Nothing
02:58:44 <boliver> dibblego: is your solution based on the visitor pattern?
02:58:46 <Binkley> really? that's a pretty good compiler
02:58:46 <dibblego> I had a discussion with someone from APLAS on the bus to the city and on the way he mentioned a solution that I had already tried and (I thought) exhausted and I came away thinking nothing of it - but I decided to reason it all out in my head again and I found a solution - and I just implemented it
02:58:55 <dibblego> boliver, no, it is not continuation passing
02:59:12 <dibblego> it is possible to do by exploiting the fact that you cannot sub-type a class with only private constructors *unless* the type declaration is nested within its super-type
02:59:46 <dibblego> I walked 3 kms from central bus station to the city and I found a solution about half way in my head - so I implemented it and it worked
03:01:14 <dibblego> dons, you about? Simon mentioned that you compiled Haskell to Java for your thesis
03:05:10 <dibblego> I realise it might not mean much to a haskeller, but it at least closes the gap from Java to Haskell so it makes it easier to wean people off - which is an objective of mine
03:05:23 <musasabi> dcoutts: no more evil than an IORef.
03:06:03 <dcoutts> I think it's more evil because of the going for high perf
03:06:15 <dcoutts> for that it should just be using a parameter to a recursive function
03:06:27 <musasabi> of course I could just use MutableByteArray in the code, but I think that is even more evil.
03:06:48 <musasabi> dcoutts: want to use it in a ReaderT IO setting.
03:06:50 <dcoutts> eg I've only seen it used in the current Binary module, and it's not necessary there.
03:07:00 <dcoutts> musasabi, you've already got a monad, use it.
03:08:00 <musasabi> dcoutts: tuning it for performance (old dirty code is beating it).
03:08:34 <dcoutts> monad transformers are not known for their blistering speed
03:08:59 <dcoutts> but if you unpack the StateT (ReaderT IO) it should be better
03:09:25 <musasabi> currently it is StateT IO, and want to move to ReaderT IO.
03:09:59 <dcoutts> you'll get a better improvement from just unfolding the StateT IO
03:10:10 <dcoutts> ie write the monad directly
03:10:20 <musasabi> point.
03:10:22 <dcoutts> though using the transformer as guidance
03:11:03 <dcoutts> musasabi, for performance stuff, I'd use the transformers as the spec / prototype, but implement it directly for the real thing.
03:11:27 <dcoutts> MTL needs a cunning system for doing that automatically
03:11:46 <dcoutts> it's a data refinement
03:17:13 <gene9> ?type mapM_
03:17:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
03:19:08 <musasabi> fun. writing the monad messed up the rules and I got 1.5 sec -> 14 secs running time :-)
03:23:00 <matthew-_> what words of advice would anyone give on making haskell run really fast?
03:23:17 <matthew-_> e.g. if one was writing games in haskell
03:23:32 <matthew-_> are there certain styles of programming that would be more beneficial than others?
03:23:48 <psnl> matthew-_: learn about the profiler?
03:24:07 <matthew-_> ah, ok. makes sense...
03:32:07 <musasabi> matthew-_: write modular code that is easy to refactor - so that changing things later is easy.
03:53:26 <dons> matthew-_: I think:
03:53:30 <dons> ?wiki Performance
03:53:33 <lambdabot> http://www.haskell.org/haskellwiki/Performance
03:54:05 <dons> the profiler is the best tool for getting feedback on improving code.
03:58:08 <matthew-_> cool, thanks for your help, I'll do some reading
04:00:42 <dons> ask advice here  too, if profiling is puzzling. speeding up code is one of the favourite games of this channel. :)
04:07:50 <bringert> SPECIALIZE INLINE rocks
04:08:58 <dcoutts> where is Data.Trie eh? eh?
04:09:06 <dcoutts> we need it in the standard libs
04:09:24 * dcoutts thinks Map String a is too slow
04:10:03 <dcoutts> especially for strings with common prefixes
04:11:46 <musasabi> "Map String a" is not too slow - and there is always "Map ByteString a"
04:12:14 <dcoutts> ok, 'Map [String] a' then
04:12:32 <dcoutts> I could split these names on their components
04:16:38 <dcoutts> musasabi, did I recall someone adding a ByteString feature to HaXml ?
04:17:08 <dons> dcoutts: hmm. yes. we could steal kzm's Tried
04:17:10 <dons> /d//
04:17:27 <dons> sounds like a task for LambdaHack 07, Oxford January
04:17:32 <dcoutts> aye, get it tidied, reviewed and included inbase ?
04:17:35 <dcoutts> ok
04:18:01 <dons> :) yeah, a Trie would be good. lovely purely functional structure
04:19:02 <musasabi> dcoutts: haven't heard about it.
04:19:23 <dcoutts> ok, maybe my mis-remembering
04:19:32 * dcoutts finds xml parsing far too slow
04:19:52 <therp> lambdahack? google asks "Did you mean: lumberjack?"
04:20:00 <dcoutts> hah hah hah
04:20:32 <dcoutts> "I'm a lambdahack and I'm ok, I work all night and sleep all day..."
04:23:23 <dons> heh
04:23:35 <dons> therp: we're planning a hackathon in january
04:23:59 <therp> oh neat :) anything with haskell in it or something particular?
04:26:41 <vegai> dons: where?
04:28:16 <dons> haskell libraries, tools , ports. hack fest!
04:28:19 <dons> more details next week.
04:28:32 <vegai> dons: is it a physical event?
04:28:36 <dcoutts> yes
04:28:36 <dons> ye.
04:29:31 <dcoutts> people who can't get there in person can participate virtually
04:35:11 <resiak> I should really get good enough with the Haskell to get involved in this. :)
04:45:07 <int-e> . o O ( don't = fix shouldn't )
04:50:20 <dons> int-e: heh
04:51:15 <dons> int-e: but you still need to define shouldn't
04:51:32 <dons> ?let shouldn't = undefined
04:51:34 <lambdabot> Defined.
04:51:55 <dons> ?let this = ()
04:51:57 <lambdabot> Defined.
04:52:19 <dons> > L.shouldn't $ do L.this
04:52:21 <lambdabot>  Couldn't match `t t1' against `()'
04:52:29 <dons> ?let this = return ()
04:52:31 <lambdabot> <local>:6:0:     Multiple declarations of `L.this'     Declared at: <local>:5...
04:52:31 <dons> > L.shouldn't $ do L.this
04:52:33 <lambdabot>  Couldn't match `t t1' against `()'
04:52:37 <dons> yeah yeah
05:05:03 <Pupeno> Any particular recomendation on documents about understanding monads (there are too many already, we should start a directory with voting and cometing... hehehe). Basically I understand the Monad concept of a container of something important but not centric to the operations (like IO or State) but when I read the implementations of >>=, return, etc in YAHT I just can't really understand them.
05:09:54 <Thomas2> Pupeno: I think the problem is that monads are so general. All a monad has to do is respect the rules.
05:10:00 * Thomas2 tries to remember what the other rules are
05:10:19 <Thomas2> the one about return is simple, it just says that return x >>= y = y x
05:14:23 <therp> yesterday I attended the presentations of the best diploma thesis of my faculity, and one guy was presenting a Haskell log message classifier. Then one of the professors in the audience asked why he chose Haskell as implementation language. His answer was "Elegance"
05:15:02 <Botje> "it sucks 10% less than competing brands"
05:23:47 <Pupeno> Thomas2: I kind of agree there, still I'd like to read it from another perspective to be able to understand it.
05:24:31 <robreim> Ix{Int}.index: Index (327680) out of range ((0,25))  <-- Is this related to hs-plugins' .hi file incompatibility with ghc 6.6?
05:25:27 <SamB_XP> ">>=" just means "do this thing, pass any results to this function, and then do what the function returns"
05:27:04 * SamB_XP wonders if there should be a warning about trying to make a typeclass for delimited continuations
05:27:15 <Thomas2> Pupeno: to me, those axioms characterise a linear sequence of operations. in particular the associativity-like property is like associativity in sequential composition apart from the issue of where variables are available
05:31:30 <Thomas2> the return properties are weaker, they kinda just say what return does
05:33:14 <SamB> remind me which law QuickCheck breaks?
05:33:50 <Syzygy-> Which law?
05:34:02 <SamB> one of the monad laws
05:34:52 <Syzygy-> Ah.
05:35:41 <SamB> probably (m >>= f) >>= g == m >>= (\x -> f x >>= g)
05:38:50 <dons> therp: nice quote.
05:38:59 <dons> robreim: yes. exactly that.
05:39:12 <dons> robreim: hs-plugins can only be used with the 6.4 series of ghc at this point
05:39:15 <dons> i'm working on it though
05:39:19 <robreim> ok, thanks.
05:39:25 <robreim> Any way I can help?
05:39:27 <dons> robreim: what are you using hs-plugins for, btw?
05:39:43 <dons> probably not. i know exactly what needs fixing. just need some spare time.
05:40:30 <robreim> I'm writing a program for work and using hs-plugins to add optional modules.
05:40:35 <SamB> of course, QuickCheck doesn't *badly* break whatever law(s) it breaks...
05:40:43 <robreim> ok, fair enough.
05:40:55 <SamB> it is, after all, a test data generation "Monad"
05:41:00 <dons> robreim: for work? ok. nice. shouldn't be too long before 6.6 and hs-plugins is sorted out
05:41:15 <dons> let priority' = succ priority
05:41:35 <robreim> Great, thanks :)
05:42:01 <dons> you get paid to write haskell?
05:42:04 <robreim> Oh, while I've got you - does hs-plugins work ok on windows?
05:42:05 <SamB> > fix succ
05:42:06 <lambdabot>  Add a type signature
05:42:18 * dons waves in the direction of the Industry page on haskell.org, if so
05:42:23 <dons> robreim: yep.
05:42:24 <dons> it does work.
05:42:41 <robreim> Not yet - I work for a co-operative I started last year and recently made the switch from haskell after my coworkers complained of lisp's syntax.
05:42:55 <robreim> s/from haskell/to haskell/
05:42:59 <dons> nice
05:43:00 <robreim> excellent, thanks
05:43:02 <SamB> heh
05:43:16 * SamB wonders why he didn't notice that robreim said that backwards
05:43:31 <dons> and you get a type system as a bonus :) and lots of other goodies
05:43:49 <trrkkkkkk> Probably because your brain inferred what he said instead of reading it all.
05:43:58 <dons> trrkkkkkk: heh
05:44:06 <SamB> yeah, yeah, I know, I know
05:44:15 <dons> concept inference, eh?
05:44:19 <dons> a useful property
05:44:19 <trrkkkkkk> I didn't notice it either.
05:44:26 <SamB> well, more like skimming I think
05:44:37 <dons> the industry page is here, http://haskell.org/haskellwiki/Haskell_in_industry
05:44:41 <lambdabot> Title: Haskell in industry - HaskellWiki, http://tinyurl.com/ylh86r
05:44:42 <SamB> type inference doesn't just skim over trivial to fix type errors
05:44:45 <dons> but we need to collect more info
05:45:02 <dons> since a lot of people are using haskell commericially, not just the big guys on that page
05:45:06 <robreim> Great, thanks
06:02:34 <ihope_> It be Haskell.
06:02:44 <vegai> Verily.
06:04:18 * Syzygy- wonders how long it'll take before we have a haskell compiler which is an at least human-equivalent AI...
06:04:35 <Syzygy-> AI revolution appears as a side effect of the hunt for the Ultimate Type Checker...
06:04:54 <ihope_> Ultimate Type Checker?
06:05:11 <ihope_> Aren't the current type inference algorithms good enough?
06:05:28 <Syzygy-> They are definitely impressively good, but obviously they aren't yet AI... :P
06:05:31 <SamB> Syzygy-: with premature optimization and all?
06:05:35 <Syzygy-> SamB: YEah?
06:06:03 <Syzygy-> "The programmer cannot possibly have wanted that to happen. Let's rewrite the code to something interesting instead...."
06:06:22 <ihope_> Hmm...
06:06:28 <trrkkkkkk> Now with even better artificial bug creation!
06:06:31 <Syzygy-> Hmmm. If things go that direction, then inspiration from Intercal and introduction of "politeness to the compiler" might end up being necessary to avoid weird side-effects.
06:06:52 <ihope_> invert :: (a -> [b]) -> b -> [a]
06:06:55 <ihope_> Implement that.
06:06:55 <ropine> "You seem to be very upset, Dave.  Why don't you take a stress pil and relax?"
06:06:56 <SamB> yes, it will be quite nice when our medical machines play videogames instead of regulating fluids or whatever...
06:06:56 <Syzygy-> > f :: Int -> Int -> IO Int -> IO () please?
06:06:57 <lambdabot>  Parse error
06:07:06 <trrkkkkkk> Oh just go the full Star Trek and have it take over the holodeck.
06:07:10 <Syzygy-> Hrm. Oops.
06:07:17 <Syzygy-> Didn't -really- mean for lambdabot to pick it up.
06:07:22 <SamB> heh
06:07:33 <ihope_> > f :: Int -> Int -> IO Int -> IO () please
06:07:34 <lambdabot>  Not in scope: `f'
06:09:05 <trrkkkkkk> Programs losing their jobs because they've become addicted to WoW?
06:09:35 <trrkkkkkk> What sort of unemployment benefits do they get?
06:09:39 <int-e> That's advanced AI.
06:10:53 <SamB> I don't think programs can achieve sentience
06:11:24 <ihope_> SamB: once we figure out the Theory of Everything, can't we just simulate people?
06:11:30 <ihope_> That'd be fun.
06:11:38 <SamB> well, see, I think only data can achieve sentience
06:11:39 <ropine> WoW gold-farmers in China losing their jobs because AIs are doing better at racking up points?
06:11:49 <therp> yeah I know. those lazy programs. most of time my X server just sleeps!
06:12:29 <ihope_> Only data?
06:12:29 <SamB> or I suppose, really, program + data
06:12:47 <dylan> only self-modifying data?
06:13:33 <SamB> it would have to be able to alter itself in order to gain experience
06:18:20 <dylan> I bet an ultimate AI wouldn't need / want type checking.
06:18:35 <SamB> sure it would!
06:18:49 <dylan> If it could prove to itself that the program was correct?
06:19:13 <SamB> why would it bother to do that when it could just write a typechecker?
06:19:28 <dylan> why would it bother writing a type checker if it was a type checker?
06:19:46 <SamB> how would it be intelligent if it was a type checker?
06:20:11 <dylan> because it'd have a part of its "briain" dedicated to such things.
06:20:18 <dylan> *brain.
06:20:51 <SamB> ... you don't think it would have written many of the things it stored there?
06:21:23 <trrkkkkkk> Humans create all sorts of bad ad-hoc type systems.
06:21:33 <dylan> well, the type-checking would be as second-nature to the UAI as walking is to a human, perhaps/
06:21:49 <dylan> *?
06:22:10 <dylan> Or perhap a better example is depth perception.
06:23:56 <dylan> of course, it's debatable that an UAI would program at all like a human being.
06:24:38 <chessguy> hmm, what's UAI?
06:25:02 <dylan> Ultimate AI
06:25:27 <chessguy> AI that programs itself?
06:25:47 <dylan> AI that well surpasses human intelligence.
06:26:28 <vegai> I think it's debatable also whether humans can create such a thing
06:26:50 <dylan> Oh, we probably can't, but things we create or things we become possibly could.
06:26:53 <chessguy> hmm
06:27:18 <vegai> Hmm... I think that a thing that could create an UAI would have to be at UAI
06:27:24 <vegai> at=>an
06:27:33 <trrkkkkkk> Seems inevitable.
06:28:11 <dylan> I'd rather the "things we become" road, anyway. But I'm biased towards organic / carbon-based systems. :)
06:28:33 <trrkkkkkk> Why?
06:29:35 <dylan> because of self-organizing properties, and the chaotic elegance of it all. :)
06:30:23 <trrkkkkkk> I was talking about why you would need some higher intelligence to create a higher intelligence.
06:30:29 <dylan> Ah
06:30:33 <trrkkkkkk> Human intelligence emerged out of a sea of stupid.
06:31:42 <ms_> so, I think I'm getting very confused about modules, classes and instances. I have a class which defines a function 'labelBF :: Tree a -> Tree Integer' and I want to have multiple instances of this class and then compare their results and performance etc
06:31:50 <ms_> but I think I'm still trapped in an OO mindset
06:31:50 <dylan> perhaps a perfect, ultimate AI is not possible because it'd need total knowledge of itself?
06:32:31 <dylan> ms_: what's the type class declaration?
06:32:42 <ms_> class BFRL a where
06:32:42 <ms_>     labelBF :: Tree a -> Tree Integer
06:33:32 <ms_> and then I have a couple of instances, but I can't work out how to refer to each instance explicitly...
06:33:33 <trrkkkkkk> I don't think 'perfect' is a necessary goal since it doesn't make any intuitive sense to me and just encourages tractability problems
06:34:01 <ms_> so I can only assume I'm confused.
06:34:17 <chessguy> anybody read any of this stuff about ...what do they call it, the anamoly or something
06:34:20 <dylan> Ah, you need specify the type
06:34:30 <dylan> ms_: e.g. there's maxBound and minBound:
06:34:33 <dylan> ?type maxBound
06:34:39 <lambdabot> forall a. (Bounded a) => a
06:34:58 <dylan> and there's instance Bounded Int somewhere.
06:35:01 <dylan> thus:
06:35:05 <dylan> > maxBound :: Int
06:35:09 <lambdabot>  2147483647
06:35:12 <dylan> or
06:35:16 <dylan> > maxBound :: Char
06:35:18 <lambdabot>  '\1114111'
06:35:33 <chessguy> i can't think of the name, but the idea is that eventually we'll hit the point where we've learned so much that we'll be able to learn faster, and hit a feedback loop of sorts
06:35:41 <chessguy> and ditto for AI
06:35:50 <ms_> ahh, ok, that's starting to make some sense. cheers dylan.
06:36:01 <roconnor> chessguy: singularity
06:36:01 <dylan> so, if you had an instance for BFRL String, you would need:
06:36:19 <chessguy> yes
06:36:28 <dylan> labelBF "foo" -- should assume BFRL String.
06:37:08 <chessguy> there's a lot of psycho-mumbo-jumbo about it, but i think the idea is interesting
06:37:24 <ms_> oh, no, that's not quite what I need.
06:37:37 <dylan> ms_: err, wait.
06:37:46 <ms_> both instances are BFRL Integer
06:37:52 <ms_> in different modules
06:37:57 <dylan> oh
06:38:11 <dylan> instances don't work that way, I think.
06:38:28 <ms_> no, that's what I'm thinking too...
06:38:42 <dylan> there can be only one instance of a given type per type class.
06:38:50 <ms_> oh sod it, I don't need to use classes at all - there are much simpler ways to do this...
06:39:04 <ms_> yeah. thanks for your help.
06:39:12 <dylan> ms_: type classes == overloading functions based on type.
06:39:50 <ms_> mmm. yup.
06:40:03 <dylan> hmm, lag to freenode
06:40:37 <ms_> if you do qualified imports, can you but the module name in a variable and use the variable ?
06:40:58 <dylan> No, modules arn't first class.
06:41:42 <ms_> okey dokey
06:44:52 <SamB> ms_: you can use "as", though
06:45:26 <SamB> like: import qualified Data.Map as M
06:46:01 <ms_> SamB: yeah, I really needed them as first class but it doesn't matter really, I can do redirection so it's all fine
06:46:10 <ihope_> ms_: yes, you seem to be thinking instances of classes are values.
06:46:17 <SamB> ms_: you could use records instead
06:46:26 <ihope_> Classes in Haskell are a lot like interfaces in OO.
06:46:48 <ms_> ihope_: yeah, 4 years of Java and I have issues detaching from instance == value stuff
06:46:55 <ihope_> And so your instances in Haskell are sort of like classes in OO.
06:47:11 <ms_> yes, *classes* in OO, not instances!
06:47:26 <ihope_> "X is an instance of Y" in Haskell is the same as "X implements Y" in Java, I think.
06:47:32 <ihope_> Mostly the same, anyway.
06:48:33 <thetallguy> ?seen igloo
06:48:34 <lambdabot> igloo is in #darcs, #ghc and #haskell. I last heard igloo speak 21h 20m 54s ago.
06:50:25 <vincenz> help, my mouth is thawing!
06:51:05 <Igloo> thetallguy: >
06:51:09 <Igloo> ? even
06:52:31 <thetallguy> Hey.
06:52:59 <thetallguy> The ghc6 package in sid has two hidden modules: ghc-6.6 and HaXml
06:53:13 <thetallguy> the former I understand.  Why the latter?
06:53:38 <Igloo> It doesn't come with HaXml at all
06:53:55 <thetallguy> Yes, I'm sorry
06:53:59 <thetallguy> it's in a separate package
06:54:15 <thetallguy> libghc6-haxml-dev
06:54:43 <thetallguy> Ah, I see you're not the maintainer
06:54:52 <thetallguy> That's what I get for waking up at 6.
06:55:09 <Igloo> heh
06:55:14 <thetallguy> Arjan Oosting <arjan@debian.org>
06:55:23 <vincenz> Anyone know anything good against intense stress/
06:55:29 <thetallguy> Do you know of any reason why it *should* be hidden?
06:55:43 <Igloo> That's arjanoosting in here
06:56:02 <thetallguy> ?seen arjanoosting
06:56:03 <lambdabot> arjanoosting is in #haskell. I don't know when arjanoosting last spoke.
06:56:06 <thetallguy> Great name.
06:57:46 <thetallguy> What controls whether a module is hidden or not?
06:58:10 * Igloo can't see why it should get hidden
06:58:32 <vegai> vincenz: quitting job. Stopping caffeine intake. Excercise
06:58:49 <vincenz> vegai: I'm more talking about the INTENSE stress that is due to the knowledge that soon you might be in excruciating pain
06:58:50 <thetallguy> Hmm...  hat is hidden as well, according to ghc-pkg
06:59:13 <vegai> vincenz: auch. Pot?
06:59:16 <vincenz> my mouth is thawing and they just drilled a hole the size of the grand canyon into the baside of my tooth
07:01:41 <Igloo> thetallguy: Ah, looks like a lack of "exposed: True"
07:01:57 <Igloo> thetallguy: In /usr/lib/ghc-6.6/package.conflets/HaXml.package.conf
07:06:39 <shapr> yow!
07:06:49 <Igloo> Looks like it doesn't build just build as a cabal package for some reason, so I'm not going to dig deeper
07:07:45 <fabiand> hey - can someone tell me how i can convert some realfrac to an integer?
07:08:08 <sjanssen> @type ceiling
07:08:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:08:11 <sjanssen> @type floor
07:08:13 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:08:22 <norpan> @type round
07:08:24 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:08:40 <sjanssen> @type truncate
07:08:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:08:43 <fabiand> @type truncate
07:08:45 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:08:58 <norpan> lots of options :)
07:09:02 <sjanssen> @type fst . properFraction
07:09:04 <fabiand> oh okay, so it expects some realfrac ..
07:09:04 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:10:04 <fabiand> well, all i want to do, is something like foo a = truncate sqrt a
07:10:27 <sjanssen> @type \a -> truncate (sqrt a)
07:10:29 <lambdabot> forall a b. (RealFrac a, Integral b, Floating a) => a -> b
07:11:40 <fabiand> with: foo :: Integer -> Integer
07:12:31 <sjanssen> @type truncate . sqrt . fromInteger
07:12:33 <lambdabot> forall b. (Integral b) => Integer -> b
07:14:48 <fabiand> sjanssen, thank you btw, but i don't really know how to deal with this informations :)
07:15:19 <sjanssen> okay
07:15:35 <sjanssen> lambdabot says that function :: (Integral b) => Integer -> b
07:16:10 <sjanssen> that means the function takes an Integer, and can return any Integral value (which includes Integer)
07:17:04 <fabiand> hmm okay
07:17:54 <sjanssen> so you just write "foo = truncate . sqrt . fromInteger" in your program, and now you can use the foo function
07:18:13 <fabiand> what is the meaning of the dot?
07:18:21 <sjanssen> that is equivalent to "foo x = truncate (sqrt (fromInteger x))"
07:18:25 <sjanssen> function composition
07:18:31 <fabiand> ah! great! ta :)
07:19:31 <fabiand> and fromInteger means that the integere part of the integral shall be used?
07:20:01 <sjanssen> fromInteger convert from an Integer to some other number
07:20:11 <fabiand> hmm okay
07:20:20 <sjanssen> it converts to a Double in this case, because we can sqrt a Double
07:21:18 <fabiand> but doesn't sqrt uses Floats?
07:21:27 <sjanssen> it could
07:21:37 <sjanssen> but Haskell will default to a Double here
07:22:05 <sjanssen> you probably want a Double anyway -- they have larger precision
07:22:42 <fabiand> yep ...
07:23:32 <fabiand> the problem for me was the fromInteger part - i just over looked the fact that sqrt requires a float .. and no int ..
07:24:38 <fabiand> ah .. now that i know all the facts, a nicer solution is, to use Float -> Integer onsted of Int > Int
07:24:40 <fabiand> :)
07:25:20 <fabiand> well, thank you sjanssen, in the end :)
07:30:40 <thetallguy> igloo: Thanks Ian, I sent Arjan an email.
07:38:17 <thetallguy> Igloo:  I just caught the lines where you found the bug.  I didn't include that in the email.
07:38:21 <thetallguy> Fixing that now
08:12:07 <cdfh> Does anyone here use Haskell mode with Emacs?
08:12:50 <ropine> I do
08:12:58 <cdfh> :-)
08:13:07 <cdfh> do you know why it wraps long lines, and joins them with "//"?
08:13:17 <cdfh> (and how to prevent it from doing that)
08:14:30 <ropine> you mean it puts / in the very last column before wrapping the line?
08:14:48 <ropine> that's not actually part of the text, that's just emacs's way of showing the line is wrapped
08:15:03 <cdfh> no, sorry - it puts "//" at the start of the new line
08:15:28 <ropine> it doesn't do that with me
08:15:31 <cdfh> (it's certainly part of the text, unfortunately)
08:15:40 <cdfh> bah, okay - thanks :_)
08:15:43 <cdfh> how annoying
08:21:07 <PupenoR> cdfh: that seems like a C/C++ comment, like Emacs is detecting the wrong language, a comment and it's continuing in the next line. Very weird.
08:21:23 <PupenoR> Anyway... no particularly recomended Monad tutorial/document ?
08:22:20 <sjanssen> @google nomaware monad
08:22:22 <lambdabot> http://www.nomaware.com/monads/
08:22:23 <lambdabot> Title: Nomaware | Monads
08:22:55 <dcoutts_> sjanssen, where was that module you had with a prototype of more generic stream fusion?
08:23:08 * dcoutts_ wants to compare with his version
08:23:37 <sjanssen> http://darcs.haskell.org/~sjanssen/streamfusion/Data/Fusion/Stream.hs
08:23:40 <lambdabot> http://tinyurl.com/y8ahsx
08:24:54 <sjanssen> did you go the type class route?
08:27:45 <PupenoR> sjanssen: thanks. That seems like what I want.
08:31:01 <cdfh> PupenoR: indeed - but even if it was detecting C, why would it insert comments to break up lines?
08:31:07 <cdfh> it's very odd (and annoying) :-)
08:32:16 <cjeris> cdfh: do you have auto-fill-mode turned on?  (the modeline will be (Haskell Fill))
08:33:00 <cdfh> cjeris++ :-)
08:33:13 * cdfh now wonders why auto-fill-mode turns on when haskell-mode does
08:33:23 <cdfh> i certainly haven't told it to - bah, also odd
08:33:52 <cjeris> cdfh: look at the value of haskell-mode-hook, it may be set to turn on auto-fill
08:34:17 <cjeris> meeting &
08:37:34 <therp> Where are the formal semantics for pattern matching against lists and tuples? Am I blind, or are they missing? http://haskell.org/onlinereport/exps.html#case-semantics
08:37:37 <lambdabot> Title: The Haskell 98 Report: Expressions, http://tinyurl.com/y9yonm
08:37:52 <cdfh> cjeris: ah, yes - found the hook - dunno how it got there
08:37:54 <cdfh> anyway, thanks :-)
08:37:58 <therp> I mean they are quite obvious but nonetheless..
08:39:55 <cdfh> therp: you mean foo (a,b,c) = ... ?
08:40:03 <therp> correct
08:40:04 <scodil> so I wrote an array-transforming function that I hoped to use on any kind of array, and ghci tells me that its type is something like (IArray a e, IArray a1 e, IArray a2 e, Ix i) => a i e -> a i e2, which is strange because a1 doesn't appear in the signature. So when I try to use it, ghc complains that it can't deduce IArray a1 e from the context.
08:40:28 <scodil> oops the signature is a i e -> a2 i e
08:41:20 <ms_> um, I'm trying to define an instance of Arbitrary
08:41:25 <ms_> (from QuickCheck)
08:41:33 <ms_> and I'm trying to define it on my Tree
08:41:43 <ms_> and my Tree is "data Tree a = ..."
08:41:58 <ms_> but I can't write "instance Arbitrary (Tree a) where..."
08:42:06 <ms_> agh, -a +Int
08:42:10 <ms_> for some reason
08:42:17 <ms_> any ideas?
08:42:29 <int-e> try  instance (Arbitrary a) => Arbitrary (Tree a) where ...
08:43:21 <ms_> no, same error
08:43:27 <ms_>     Illegal instance declaration for `Arbitrary (Tree Int)'
08:43:47 <ms_> (on "instance (Arbitrary a) => Arbitrary (Tree Int)"
08:44:10 <ms_> oh, but it works on the (Tree a) version
08:44:14 <ms_> gah...
08:44:15 <glguy> ?doc readP
08:44:16 <lambdabot> readP not available
08:44:39 <glguy> (found it anyway)
08:47:42 <scodil> can you use ghci to query the type of an expression thats not at the top-level? like in a let-in block?
08:48:41 * Syzygy- looks at books to possibly order via my advisor... How annoyed and disappointed will I be with the various Haskell books that float around?
08:48:45 <mnislaih> dcoutts: what is the morning plan for Fun? I'd like to join :)
08:49:09 <dcoutts_> mnislaih, turn up, we're talking about whatever people want to talk about
08:49:33 <dcoutts_> in particular, JaffaCake, Igloo and I will be discussing Cabal configurations
08:49:57 <mnislaih> ok, that's a long ongoing discussion aint it ?
08:50:07 <dcoutts_> somewhat, we want a conclusion
08:50:19 <mnislaih> at least It'll be fun to meet you all, and I don't have anything better to do
08:50:37 <mnislaih> so I will go and maybr try to steer the discussion to debugging in ghci :)
08:50:44 <dcoutts_> heh :-) ok
08:51:31 <dcoutts_> mnislaih, so, send me an email and I'll add you to the list
08:51:53 <dcoutts_> and your wired ethernet MAC address if you want network access
08:52:53 <Igloo> dcoutts_: JaffaCake seems to have read up on the discusion and given his opinion already
08:53:05 <dcoutts_> Igloo, yes I saw.
08:53:42 <mnislaih> dcoutts_: done. do you know of any university place reasonably priced to stay the night ?
08:54:15 <dcoutts_> erm, not anything from the uni, there's the YHA.
08:55:29 <mnislaih> ah, that will be ok
09:00:12 <dcoutts_> Igloo, heh, try running ghci in libraries/base/Data/Array/
09:00:19 <dcoutts_> it tries to load the IO.hi in that dir
09:00:59 <dcoutts_> sjanssen, yeah, I was thinking about using a class
09:01:04 <scodil> why is my array function asking me to provide instance declarations for both IArray a and MArray a... no array type is an instance of both is it? or does ghc know to convert Arrays to IOArrays, etc ?
09:01:16 <Igloo> dcoutts_: :-)
09:01:27 <sjanssen> dcoutts_: I think a class would be better
09:01:43 <dcoutts_> scodil, perhaps you're mixing your IArray/MArray functions
09:01:43 <sjanssen> it will reduce boilerplate code by a ton
09:02:01 <dcoutts_> sjanssen, aye, a StreamableSequence class with stream & unstream
09:02:25 <scodil> no i'm not mixing them. and it seems to have compiled just fine.
09:02:34 <dcoutts_> sjanssen, I'm playing with that now, and making instances for [] and Array
09:04:41 <scodil> its like the type system wants to see an instance of 'MArray a' but no MArray methods are ever used on a-type variable. can that happen?
09:06:27 <Cale> scodil: did you paste the code somewhere?
09:06:50 <scodil> its kind of long... let me clean it up a bit first
09:07:26 <scodil> ?paste
09:07:27 <lambdabot> http://paste.lisp.org/new/haskell
09:07:55 <scodil> paste server is messed up
09:08:03 <scodil> is there somewhere else I can paste?
09:09:17 <Cale> oh, wow
09:09:36 <Cale> I suppose you could use http://rafb.net/paste/
09:10:04 <osfameron> scheme in 48 hours is not a good tutorial if you don't already know haskell
09:10:24 <osfameron> are there any good haskell tutorials?
09:10:28 <Cale> er, seems back online
09:10:30 <osfameron> I should have taken the school of expression with me
09:10:39 <Cale> (http://paste.lisp.org/new/haskell that is)
09:10:42 <ventonegro> but, if you already know... ?
09:11:08 <Cale> osfameron: I like "Yet Another Haskell Tutorial"
09:11:27 <lisppaste2> scodil pasted "IArray / MArray instances for the same array type " at http://paste.lisp.org/display/29570
09:11:43 <scodil> look at the decl for invertMatrix
09:11:46 <osfameron> Cale: well, I think it's badly written and poorly explained.  But the exercises are good
09:12:33 <malebria> Hello there.
09:12:39 <Cale> hello
09:12:56 <osfameron> the scheme tutorial one has "Write parseNumber in do notation!" which is crazy as it implies that you already know enough about types, function composition and monads to slot the bits in the right places
09:12:59 <malebria> I'm trying to write a very simple instance of Show, which is:
09:13:19 <malebria> instance Show GError where show (GError _ _ message) = message
09:13:34 <malebria> I'm getting the error message:
09:13:45 <malebria> Warning: orphan instances: instance GHC.Show.Show System.Glib.GError.GError = $fShowGError
09:13:52 <malebria> Sorry, warning message.
09:14:06 <malebria> What's an orphan instance?
09:14:20 <scodil> ah ok it finally complained when I tried to use it. no instance for MArray Array (Int,Int) Double
09:15:38 <Cale> malebria: http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/separate-compilation.html#orphan-modules -- I think this explains it
09:15:41 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/y9ycg9
09:16:11 <malebria> Cale: thanks.
09:16:17 <Cale> This option causes a warning to be emitted whenever the module contains an "orphan" instance declaration or rewrite rule. An instance declartion is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module.
09:16:31 <Cale> (that's from the -fwarn-orphans flag)
09:18:29 <shapr> osfameron: YAHT is open source now, feel free to fix it :-)
09:18:34 <malebria> Cale: but is it something bad, to declare an orphan instance?
09:19:09 <Cale> malebria: It only affects separate compilation
09:20:24 <malebria> Cale: I think I'll write a function showGError, instead of writing an instance. You think it's more elegant, or less?
09:21:30 <Cale> malebria: I'd probably just ignore the warning, or turn off -fwarn-orphan, or move the instance into the module where the type or class is defined.
09:21:56 <malebria> Cale: ok, thanks.
09:22:58 <malebria> I'm using gtk2hs in a program that draws an figure in a DrawingArea, and there's a zoom SpinButton. When I spin it very fast, it crashes with the message:
09:23:03 <malebria> urban: gtk2hs_closure_marshal: uncaught exception
09:23:19 <osfameron> shapr: yeah... if and when I manage to learn some haskell that's an option...
09:23:19 <dcoutts_> malebria, try catching the exception yourself
09:23:29 <osfameron> shapr: ta
09:23:30 <malebria> dcoutts_: I'm trying.
09:23:31 <malebria> =D
09:23:41 <malebria> dcoutts_: is it an GError?
09:23:47 <dcoutts_> malebria, ie you're raising an exception in the signal handler
09:23:51 <dcoutts_> malebria, it could be
09:24:26 <malebria> dcoutts_: I'm trying to catch with catch and with catchGError
09:24:58 <dcoutts_> @type Control.Exception.catch
09:25:00 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
09:25:59 <dcoutts_> malebria, Control.Exception.catch can catch all exception, so try that
09:29:08 <malebria> dcoutts_: It's not catching...
09:29:19 <malebria> import Prelude hiding (catch)
09:29:19 <malebria> import Control.Exception
09:29:25 <malebria> main =  catch window print
09:29:34 <malebria> window is where the program is run.
09:29:40 <dcoutts_> malebria, you need to catch in the signal handler
09:29:55 <dcoutts_> the signal handler must not return an exception
09:30:06 <malebria> I'm cacthing in the whole program.
09:30:13 <dcoutts_> that's not the same
09:30:17 <malebria> hum...
09:30:28 <malebria> I'm catching after onXXX functions too.
09:30:40 <dcoutts_> inside the onXXX ?
09:30:50 <malebria>     onValueSpinned      zoom             $ treat  $
09:30:51 <malebria>         redraw draw draw_window zoom
09:30:57 <malebria> This treat function is:
09:31:19 <malebria> treat_ fun            parameter = catch (catchSql (fun parameter) $ error . show)  treat_execution
09:31:32 <malebria> treat is a marshall for treat_
09:31:37 <malebria> They're the same.
09:31:50 <malebria> I tried catching an GError also.
09:31:55 <malebria> But nothing was returned.
09:32:09 <dcoutts_> malebria, remember that if the value you return contains an excaption, then you need to force that inside the exception handler
09:32:31 <malebria> dcoutts_: force what?
09:32:44 <dcoutts_> malebria, for example 'catch (return undefined) (...)' doesn't catch anything
09:33:05 <greyz> hi everybody
09:33:11 <malebria> dcoutts_: Yes, but this doens't crash the program also.
09:33:14 <dcoutts_> malebria, because the action raises no exception, it's just the value returned contains an exception.
09:33:45 <dcoutts_> malebria, but in the signal hadler case the value gets forced because it's marshaled and returned to C land.
09:33:51 <malebria> dcoutts_: Why is it different to catch the whole program instead of especific parts? Isn't the exception trown up?
09:34:05 <greyz> i have a list and a predicate and i need a tuple of two lists where in one list elements match the predicate and in the other they doesn't
09:34:17 <dcoutts_> malebria, Haskell exceptions cannot be propagated through C land.
09:34:37 <malebria> dcoutts_: hum...
09:35:05 <malebria> dcoutts_: but how can I force inside the exception handler?
09:35:22 <dcoutts_> evaluate the result
09:36:01 <malebria> dcoutts_: I don't know how to do it...
09:36:13 <malebria> dcoutts_: I can think just with print..
09:36:15 <dcoutts_> @hoogle evaluate
09:36:16 <lambdabot> Control.Exception.evaluate :: a -> IO a
09:36:17 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
09:36:29 <greyz> for example splitBy (>5) [7,2,3,5,9,7,4] ==>  ([7,9,7],[2,3,5,4])
09:36:32 <dcoutts_> hmm, but for onValueSpinned the result is ()
09:36:32 <malebria> dcoutts_: thanks.
09:36:50 <malebria> dcoutts_: yes...
09:36:59 <dcoutts_> so presumably you're doing return () ?
09:37:02 <greyz> should be simple enough but I don't have a clue at the moment
09:37:07 <dcoutts_> (or something equivelent)
09:37:14 <malebria> dcoutts_: something equivalent.
09:37:54 <malebria> dcoutts_: the function is a do expression, and the last function in the do expression is mapM_
09:38:05 <dcoutts_> malebria, I don't follow your exception handler
09:38:11 <dcoutts_> can you paste it
09:38:13 <dcoutts_> @paste
09:38:14 <lambdabot> http://paste.lisp.org/new/haskell
09:38:44 <greyz> seems I'm not getting help here today :(
09:39:09 <shapr> greyz: Must be an off day...
09:40:30 <lisppaste2> marcot pasted "uncaught exception" at http://paste.lisp.org/display/29572
09:40:32 <shapr> greyz: Do you know how to do any of the parts of the question you asked?
09:41:19 <greyz> First i thought to use dropWhile and takeWhile
09:41:49 <malebria> dcoutts_: I think these are all the functions involved, if you miss something tell me.
09:41:59 <shapr> greyz: But those work on sequentiall matching, wouldn't it make more sense to use something that works on each item?
09:42:10 <dylan> perhaps span?
09:42:34 <dylan> @hoogle (a -> Bool) -> [a] -> ([a], [a])
09:42:35 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
09:42:36 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
09:42:36 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
09:43:12 <shapr> greyz: As dylan just pointed out, describing your problem in terms of a type signature can be one way to search for a solution.
09:43:26 <greyz> splitBy :: (a -> Bool) -> [a] -> ([a],[a])
09:43:33 <dylan> partition is the function you want.
09:43:54 <dcoutts_> malebria, you're re-raising the exception.
09:43:56 <dylan> > partition (>5) [1..10]
09:43:58 <lambdabot>  ([6,7,8,9,10],[1,2,3,4,5])
09:44:09 <dcoutts_> treat    fun =   treat_ (const fun) undefined
09:44:32 <dcoutts_> malebria, your action in the case of failure is 'undefined' ie to raise an exception again.
09:45:13 <shapr> greyz: Is there a function that selects only the elements from a list that match a certain predicate?
09:45:21 <araujo> hello
09:45:34 <shapr> hola araujo
09:45:50 <greyz> no I havent found one
09:45:55 <araujo> Â¡hola shapr!
09:46:18 <malebria> dcoutts_: no, undefined is ignored by the treat_ function.
09:46:24 <greyz> I would use dylan's idea but that needs List package
09:46:31 <malebria> dcoutts_: because it's used with const
09:46:31 <shapr> greyz: What do you think would be the type signature of such a function if it existed?
09:46:48 <dcoutts_> malebria, what is treat_execution ?
09:47:08 <dcoutts_> malebria, yes, ok I see.
09:47:14 <dylan> greyz: why is using the List module a problem?
09:47:34 <malebria> dcoutts_: it creates an window and show the exception.
09:47:59 <greyz> I have to find it first
09:48:32 <greyz> haskell is great but I'm dumb at it
09:48:47 <lisppaste2> marcot annotated #29572 with "treat_execution" at http://paste.lisp.org/display/29572#1
09:48:59 <dylan> List is standard. I'd recommend reading http://cvs.haskell.org/Hugs/pages/libraries/base/Data-List.html
09:49:02 <lambdabot> http://tinyurl.com/yy3u67
09:49:29 <shapr> greyz: You may also want to read the source for the Prelude module, it includes many bits of code that you'll end up using in every Haskell program you write.
09:50:06 <greyz> havent read the source but I'm familiar with most of the functions
09:50:27 <dylan> the source is very concise.
09:50:43 <shapr> It's worth reading, I promise.
09:50:48 <dylan> it's the first thing I read about haskell, except for the definition of a quick sort.
09:52:52 <malebria> dcoutts_: I think the problem is in treat_execution.
09:53:06 <dcoutts_> malebria, oh ?
09:53:09 <greyz> ok thanks a lot dylan your suggestion helped
09:53:29 <buinic> Umm, do you guys have any website where I can upload a small code snippet?
09:53:34 <shapr> @paste
09:53:34 <Binkley> @paste
09:53:35 <lambdabot> http://paste.lisp.org/new/haskell
09:53:35 <lambdabot> http://paste.lisp.org/new/haskell
09:53:38 <shapr> paste spam!
09:53:40 <buinic> thank you
09:53:41 <Binkley> hehe
09:53:45 * shapr throws a can of spam at Binkley
09:53:49 <scodil> what do you do if you have a polymorphic function of type a -> a and internally it uses two other polymorhpic functions a -> b and c -> a, and the compiler starts complaing about not being able to match b with c.
09:54:00 <malebria> dcoutts_: let me just see something here.
09:54:05 <Binkley> scodil, i think i need a little more context for that
09:54:37 <dylan> what is type c?
09:54:51 <scodil> my function is Array -> Array, but i use unsafePerformIO and unsafeFreeze in the function, and it complains about not being able to match the result type of unsafeFreeze with my outter array type
09:54:58 <lisppaste2> buinic pasted "Permute" at http://paste.lisp.org/display/29574
09:55:24 <dcoutts_> malebria, I was just trying to think i there's anything better we can do when a signal handler raises an uncaught exception. Perhaps we should try to throw it to the parent thread.
09:55:25 <dylan> :type unsafeFreeze
09:55:32 <dylan> ?type unsafeFreeze
09:55:33 <lambdabot> Not in scope: `unsafeFreeze'
09:55:51 <dcoutts_> dylan, @hoogle is your friend
09:56:00 <scodil> ?type Data.Array.MArray.unsafeFreeze
09:56:01 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.IArray b e, Data.Array.Base.MArray a e m, Ix i) => a i e -> m (b i e)
09:56:05 <scodil> the b
09:56:09 <scodil> its complaining about the b
09:56:12 <dylan> dcoutts_: indeed, did it in private query after that.
09:56:53 <buinic> I could use some help with this, in the code I just pasted (http://paste.lisp.org/display/29574), in line 7 isnt x a string instead of a character?
09:57:00 <malebria> dcoutts_: it's strange, cause some time ago it was catching the sql exceptions, or haskell exceptions, like from head..
09:57:28 <malebria> dcoutts_: I think the problem can be in return nothing
09:57:36 <malebria> in treat_execution
09:57:56 <dcoutts_> you didn't show me that code
09:58:32 <dcoutts_> buinic, no, it's a Char
09:58:35 <malebria> dcoutts_: yes, I pasted it.
09:58:57 <malebria> 15:48 < lisppaste2> marcot annotated #29572 with "treat_execution" at http://paste.lisp.org/display/29572#1
09:59:01 <buinic> dcoutts, yes its working as a char but may I ask why? I thought that by doing x <- str it'd "assign" the string to x
09:59:09 <malebria> I thought you've seen it.
09:59:22 <cjeris> buinic: because you used the 'do' notation, the line x <- str is not doing what you expect.  do you know monads yet?
09:59:38 <buinic> No sir, I'm still beginning.
09:59:40 <dylan> buinic: it's like a list comprehension, if that helps: [ x * 2 | x <- [1..10] ]
09:59:49 <dcoutts_> malebria, return undefined
09:59:53 <buinic> dylan, thanks, that way I get it
10:00:09 <dcoutts_> malebria, so that's the problem.
10:00:13 <malebria> dcoutts_: but why does it trow an gtk2hs exception?
10:00:23 <malebria> urban: gtk2hs_closure_marshal: uncaught exception
10:03:19 <malebria> I gotta go now..
10:03:21 <Syzygy-> > [x*2 | x <- [1..10]]
10:03:23 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
10:03:29 <Syzygy-> > [x*2 | x <- Just 3]
10:03:31 <lambdabot>  Couldn't match `Maybe a' against `[a1]'
10:03:34 <Syzygy-> Doh.
10:03:34 <malebria> I'll try to remove this return undefined...
10:03:42 <malebria> dcoutts_: thanks.
10:03:50 <Syzygy-> > do x <- Just 3; x
10:03:51 <lambdabot>  add an instance declaration for (Num (Maybe b))
10:04:01 <dylan> Syzygy-: no monad comprehensions. :(
10:04:04 <Syzygy-> > do x <- Just 3; show x
10:04:06 <lambdabot>  Couldn't match `Maybe' against `[]'
10:04:09 <Syzygy-> Doh.
10:04:15 <dcoutts_> malebria, does that fix it, not returning undefined?
10:04:16 <Syzygy-> So <- doesn't work for generic monads...
10:04:28 <malebria> dcoutts_: I don't know what I can return instead of undefined.
10:04:29 <dylan> it does...
10:04:34 <malebria> It's a IO a function
10:04:35 <Syzygy-> do Just 3; Nothing; Just 5
10:04:39 <Syzygy-> > do Just 3; Nothing; Just 5
10:04:41 <lambdabot>  Nothing
10:04:50 <Syzygy-> > do Just 3; Just 5
10:04:52 <lambdabot>  Just 5
10:04:53 <malebria> dcoutts_: I'll try later and tell you.
10:04:55 <Syzygy-> Aha!
10:05:02 <malebria> Good afternoon.
10:05:03 <malebria> =D
10:05:03 * Syzygy- feels as if he understands something...
10:05:05 <dcoutts_> malebria, I tested just here and indeed returning undefined from a onClicked handler does case the uncaught exception problem.
10:05:31 <dcoutts_> malebria, you're right that it's a little odd that we are strictly evaluating the value of type ()
10:05:49 <dylan> @let bork b = do s <- b; return ("bork " ++ s)
10:05:51 <dcoutts_> @type Control.Exception.catch
10:05:51 <lambdabot> Defined.
10:05:52 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
10:06:02 <dcoutts_> malebria, can't you just return () ?
10:06:05 <dylan> > L.bork (Just "foo")
10:06:07 <lambdabot>  Just "bork foo"
10:06:15 <dylan> > L.bork Nothing
10:06:17 <lambdabot>  Nothing
10:06:17 <malebria> dcoutts_: I use the same function for not IO () functions.
10:06:43 <dcoutts_> malebria, then pass in an extra result
10:06:43 <malebria> dcoutts_: really gotta go, I'll try something latter.
10:06:59 <malebria> dcoutts_: hum... it's really a good alternative.
10:07:07 <malebria> Bye, folks.
10:07:08 <dylan> Syzygy-: <- works fine for non-list monads.
10:07:17 <malebria> dcoutts_: thanks a lot.
10:07:42 <dcoutts_> mm, yeah that stuff is a bit confusing
10:11:12 <Syzygy-> dylan: But not for Maybe?
10:11:28 <Syzygy-> Ah. Now I see.
10:11:36 <Syzygy-> > L.bork (Just 3)
10:11:37 <lambdabot>  add an instance declaration for (Num [Char])
10:11:41 <Syzygy-> Ah.
10:11:57 <Syzygy-> Ahhh.... Now I think I realize what I' did wrong...
10:12:14 <scodil> whats a rigid variable
10:17:34 <scodil> what do you do if you have a polymorphic function, and declare some helper functions in a let-in block, and the typechecker wants you to provide signatures for those helpers, but they're also polymorphic on the same type as the outter function
10:17:45 <Binkley> scodil: first, you cry
10:18:16 <vincenz> then you call 1-800-GET_DONS
10:18:44 <Binkley> then you look at this:
10:18:44 <Binkley> check out 'complexity theory', it's all there.
10:18:50 <Binkley> oops, sorry, wrong paste buffer
10:18:53 <Binkley> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
10:18:56 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
10:21:00 <emu> say, when people use parsec or something to parse something into an abstract syntax tree data type, do they typically create some kind of class with instances for each type which overload a `parse' kind of function and invoke the various combinators based on the current type?
10:21:23 <emu> i was just creating lots of little functions named appropriately
10:22:04 <cjeris> @remember vincenz then you call 1-800-GET_DONS
10:25:02 <scodil> so you have to use forall to bring the type variable into scope over the whole function. how do use a forall and class qualifiers at the same time? like (Ord s) => (forall s . ...)
10:25:39 <Binkley> scodil, I think you would need to say (forall s . (Ord s) => ...), but I'm not sure.
10:26:42 <Taral> I think #haskell' is dead.
10:28:27 <emu> Binkley: lol, pasting the trolls posts?
10:30:17 <scodil> how do you get two rigid variables to match? I've annotated everything that's not bolted down and it always complains that it can't match IOArray (Int,Int) s against IOArray (Int,Int) s1, both s and s1 are rigid variables. what does it mean 'rigid' ?
10:34:03 <scodil> oh shit it works.
10:36:00 <Binkley> emu: yeah, there are some really quote-worthy things there :-)
10:36:30 <scodil> whats the deal with -fallow-undecidable-instances ?
10:36:54 <Binkley> it allows undecidable instances
10:38:05 <scodil> i'm not going to dignify that with sarcasm
10:38:06 <PupenoR> Is there something like Erlang's OTP for Haskell ?
10:38:21 <Botje> PupenoR: you mean something that makes builds fail?
10:38:21 <scodil> whats an undeciable instance
10:38:52 <PupenoR> Botje: builds fail ? what do you mean ?
10:38:56 <edwardk> scodil: basically the type checker relies on the fact that the stuff on the left of the => is 'smaller' than the stuff on the right to guarantee that you will eventually stop chaining.
10:39:41 <scodil> smaller in the sense of...
10:39:44 <edwardk> undecidable instances relaxes this restriction and makes it so that in theory type checking might take forever, instead it replaces it with a fixed cap of how far it will look
10:39:53 <edwardk> number of bound variables or something as I recall.
10:40:46 <edwardk> basically to do anything that needs to have any notion of type class recursion you need it.
10:41:34 <phas> hi, i'm trying to figure how to use mutable arrays
10:41:39 <dcoutts_> aaarg, generically building unboxed arrays in the ST monad is impossible
10:41:47 <dcoutts_> phas, yeah, me too :-)
10:41:53 <phas> oh
10:41:56 <phas> d'uh
10:42:01 <PupenoR> What I mean is that I like the Erlang threading model (light thread, processes actually, no shared memory, only messages) and I like building applications with OTP (lots of threads each with a particular task forming a tree of supervisors and workers) but I'd like to use Haskell (I learned to love static typing and a good compiler).
10:42:54 <phas> dcoutts_ i need to do an interpreter for Von Nemann machine and i need a mutable array for the ram :|
10:43:12 <phas> dcoutts_ but i can't find any example or doc on how to use them
10:43:17 <dcoutts_> phas, try IOUArray or STUArray
10:43:21 <scodil> phas ... how much ram
10:43:41 <edwardk> phas: you have to perform all of your operations in an IO or ST monad, are you comfortable with those?
10:44:23 <Taral> My brain hurts, and it's all Cale's fault.
10:44:29 <phas> -scodil- uuh i can't remember exactly, i think that are 9999 cells of 8 or 16 bits
10:44:31 <edwardk> taral?
10:44:42 <Taral> (.) === map
10:44:49 <phas> -edwardk- i used IO, of course. Never used ST
10:44:51 <edwardk> taral blame me for that one sorry =)
10:44:55 <Taral> oh?
10:45:09 <Taral> I mean, it makes plenty of sense, in a bizarre way...
10:45:14 <edwardk> yeah it was based on a discussion over on logic, from how i wanted to reimplement (.) in my toy language
10:45:17 <Taral> writing a <- Just . f instead of a <- fmap Just f
10:45:20 <dolio> ?type \f g -> (g =<<) . f
10:45:22 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a1 -> m a) -> (a -> m b) -> a1 -> m b
10:45:43 <edwardk> http://comonad.com/reader/ top post
10:45:51 <lambdabot> Title: The Comonad.Reader
10:46:27 <scodil> phas: IOArrays are pretty straighforward. make an array with newArray (0,9999) 0, then read it with readArray (addr) and write with writeArray (addr) (value)
10:46:28 <edwardk> i've been going through pretty much prelude function by prelude function and trying to find a generic version of them that fits.
10:47:07 <edwardk> er ##logic (forgot hashes)
10:47:30 <Taral> edwardk: I like that idea.
10:47:33 <Taral> I'm a minimalist at heart.
10:48:00 <edwardk> taral: i found a reference to more or less the same idea in Richard Bird's paper from 1990. he used * the same way
10:48:05 <phas> -scodil- these aren't functions for work on "normal" arrays?
10:48:06 <Taral> *?
10:48:10 <Taral> * as in (.)?
10:48:36 <edwardk> well, he used * for map (not fmap)
10:48:42 <scodil> phas: no, those work on any mutable array, like IOArray or STArray.  if performance isn't super critical to you, you might also want to check out DiffArray
10:48:47 <edwardk> f * [1,2,3] = [f 1,f 2,f 3]
10:48:55 <scodil> you can use it like a "normal" array but its a bit faster
10:49:07 <scodil> which might be more up your alley if your writing an interpreter
10:49:13 <scodil> cause then it can be pure
10:49:33 <edwardk> i'm just baking in more of the standard monads, etc into my prelude equivalent so it made more sense to me.
10:50:42 <Taral> Heh.
10:50:47 <dolio> ?pl \f g -> (g =<<) . f
10:50:48 <lambdabot> flip ((.) . (=<<))
10:50:49 <Taral> Did you see the timeout thread/
10:50:50 <Taral> ?
10:51:19 <Taral> edwardk: Did you make Monad a subclass of Functor finally?
10:52:12 <edwardk> taral: well, for my toy lang yes, but there is a technical issue with it for Haskell.
10:52:16 <Taral> Yeah, yeah.
10:52:20 <Taral> Always technical issues with Haskell.
10:52:26 <Taral> Time for a revolution! :D
10:52:28 <edwardk> heh
10:52:44 <astrolabe> edwardk: what is the issue?
10:52:47 <sjanssen> edwardk: technical issue?
10:54:47 <edwardk> sjanssen: the issue was the way fmap = liftM usually, as I recall from the mailing list, no sensible way to give default values to the functions from the superclass.
10:55:16 <sjanssen> yeah
10:55:46 <sjanssen> I think that people that complain about writing the Functor boilerplate are whiners
10:55:54 <astrolabe> I don't understand
10:56:00 <edwardk> =)
10:56:03 <phas> -scodil- could you please make an example with IOArray?
10:56:22 <edwardk> well, add the language feature so that its not an issue and there is no boilerplate =P =)
10:57:51 <dolio> ?pl \f g -> (>>= g) . f
10:57:52 <lambdabot> flip ((.) . (=<<))
10:58:05 <dcoutts_> sjanssen, this looks nice:
10:58:06 <dcoutts_> List.map :: (StreamableSequence seq1, StreamableSequence seq) =>
10:58:06 <dcoutts_>             (a -> b) -> seq1 a -> seq b
10:58:21 <sjanssen> dcoutts_: it does
10:58:24 <dcoutts_> so we can change the sequence type :-)
10:58:41 <sjanssen> you might want to lift the contained value into the class though
10:58:50 <sjanssen> with a fundep or some such
10:58:57 <dcoutts_> yes I have a version like that
10:59:02 <dcoutts_> but I don't need it yet
10:59:17 <dcoutts_> especially since I can't do UArray that way :-(
10:59:38 <dcoutts_> at least not generically, I have to make instances and duplicate the code for every type :-(
10:59:49 <dcoutts_> ie for Int, Bool, etc etc
11:00:18 <dcoutts_> it can't be done generically because there's nowhere to put the class constraint
11:00:42 <sjanssen> you can't write "instance (Array a e) => StreamableSequence (a i e) e"?
11:01:00 <dcoutts_> for Array it's fine, for UArray ...
11:01:27 <dcoutts_> because the class constraint would need to mention the ST 's' parameter
11:01:53 <dcoutts_> but that's disappeared once we runST
11:02:43 <sjanssen> oh, you use runSTArray or some such to write out the stream?
11:02:50 <dcoutts_> yes
11:03:38 <sjanssen> this is the second time in 24 hours that problem has been mentioned in #haskell
11:04:27 <dcoutts_> I remember discovering it a couple years ago
11:04:32 <dcoutts_> and it wasn't new then
11:05:02 <dcoutts_> anyway
11:05:07 * dcoutts_ -> home
11:07:08 <LPhas> hey, wellcome back!
11:07:28 <glguy> Where do I sign up for all of this "free beer" I keep hearing about?
11:07:32 <sjanssen> @yow
11:07:41 <Binkley> there's some in the kitchen here at MSR
11:07:47 <LPhas> cool
11:07:51 <LPhas> mmh beer
11:07:57 <sjanssen> "beer as in free"
11:08:17 <sjanssen> those drunken researchers
11:08:45 <lambdabot> Yow!  Now we can become alcoholics!
11:09:08 <scodil> if you've got an array function from IArray -> IArray, but internally it uses MArray, do you have to give an undefined MArray paramter to the function, to fix the MArray type? or is there another way to automatically deduce the MArray type for a corresponding Array type?
11:09:41 <LPhas> you can't get drunk with beer
11:10:15 <dolio> That's untrue.
11:10:49 <PupenoR> lambdabot now speaks without being spoken to ?
11:11:26 <sjanssen> PupenoR: lambdabot's ops can make it speak
11:11:47 <PupenoR> oh! :(
11:11:58 <int-e> PupenoR: the last thing it said here was just a very slow response
11:11:59 <LPhas> in Koln i drunk 7 liters of beer in three ours without getting drunk
11:12:25 <PupenoR> LPhas: then you used the wrong personal pronoun in the previous statment.
11:12:36 <LPhas> ok. ok
11:12:39 <chessguy> @hoogle groupBy
11:12:41 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
11:12:46 <LPhas> i'm not so good with english
11:12:51 <scodil> fundeps only work for classes, yes? you can't use them for polymorphic functions?
11:13:00 <sjanssen> scodil: right
11:13:12 <PupenoR> LPhas: it was a joke as in "I can't get..." instead of "you can't get..."
11:14:15 <scodil> so if you wanted to write a polymorphic function of one type variable, and internally it used other types that were determined uniquely by the one polymorphic type, you'd have to write a one-member-class and make every concrete form on the function an instance of that class.. no?
11:14:20 <dolio> You weren't drinking O'Douls, were you?
11:14:32 <vincenz> or american beer
11:14:40 <chessguy> > groupBy (\x y -> x `mod` 2 == y `mod` 2) [1..10]
11:14:42 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
11:15:01 <chessguy> hmm, now that's unexpected
11:15:06 <vincenz> not really
11:15:22 <vincenz> > groupBy (==) [1,2,1,1,2,2]
11:15:23 <dolio> > group "Mississippi"
11:15:23 <chessguy> why didn't it group odd numbers together and even numbers together?
11:15:24 <lambdabot>  [[1],[2],[1,1],[2,2]]
11:15:25 <lambdabot>  ["M","i","ss","i","ss","i","pp","i"]
11:15:35 <chessguy> ohh, they have to be next to each other
11:15:38 <dolio> It only groups consecutive matches.
11:15:57 <chessguy> ok, that's actually a good thing for me
11:16:01 <sjanssen> > groupBy (\x y -> x `mod` 2 /= y `mod` 2) [1..10] -- more interesting, perhaps
11:16:03 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
11:16:16 <sjanssen> dolio: not exactly
11:16:24 <int-e> > group . sort $ [1,2,1,1,2,2]
11:16:25 <chessguy> hmm. a greedy algorithm of sorts
11:16:26 <lambdabot>  [[1,1,1],[2,2,2]]
11:16:27 <vincenz> sjanssen: that ones is messedy
11:16:54 <dolio> Ah, does it only go by the first in the sequence?
11:17:00 <vincenz> yep
11:17:00 <sjanssen> yes
11:17:08 <int-e> > map (head &&& length) . group . sort $ [1,2,1,1,2,2,2,3]
11:17:10 <lambdabot>  [(1,3),(2,4),(3,1)]
11:18:21 <vincenz> > map (head &&& length) . group . sort $ "int-e"
11:18:21 <Syzygy-> > let cmp = \x y -> compare (x `mod` 2) (y `mod` 2) in (groupBy (\x y -> x `mod` 2 == y `mod` 2)) . (sortBy cmp) $ [1..10]
11:18:23 <lambdabot>  [('-',1),('e',1),('i',1),('n',1),('t',1)]
11:18:24 <lambdabot>  [[2,4,6,8,10],[1,3,5,7,9]]
11:18:50 <Syzygy-> > map (head &&& length) . group . sort $ Syzygy-
11:18:52 <lambdabot>  Parse error
11:18:58 <Syzygy-> > map (head &&& length) . group . sort $ "Syzygy-"
11:19:00 <lambdabot>  [('-',1),('S',1),('g',1),('y',3),('z',1)]
11:19:24 <Syzygy-> @type (head &&& length)
11:19:26 <lambdabot> forall a. [a] -> (a, Int)
11:19:27 <Syzygy-> @type (&&&)
11:19:29 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:19:41 <Syzygy-> Say what?
11:19:49 <chessguy> lol
11:20:03 <chessguy> that's gotta be one of the ugliest type signatures i've ever seen
11:20:13 <Syzygy-> What the flying whatever does it even mean?
11:20:24 <Taral> Syzygy-: instance Arrow (->)
11:20:31 <fourbissime> hi there. noob question of the day : i've got a field in a data type which is "Maybe MyEnum", meaning it can be Nothing or one value of my enumeration. then i want to do a test on it, like "if myfield == Nothing then ... else ...". but it doesn't work.
11:20:40 <sjanssen> chessguy: the explicit kinds and quantification make it especially bad
11:20:56 <int-e> Syzygy-: I think it's nicer to put it as  (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
11:21:00 <vincenz> fourbissime: if isNothing
11:21:03 <Taral> @type (\f g -> f &&& g) :: a -> (b, c)
11:21:04 <lambdabot>   The lambda expression `\ f g -> ...' has two argumentss,
11:21:05 <lambdabot>   but its type `a -> (b, c)' has only one
11:21:10 <fourbissime> vincenz: thanks
11:21:12 <Botje> fourbissime: case myfield of Nothing -> ...
11:21:12 <int-e> Syzygy-: and the case we're interested it uses -> for ~>
11:21:12 <sjanssen> fourbissime: usually, you'd use a case expression for that
11:21:15 <Taral> @type (\f g -> f &&& g) :: f -> g -> (b, c)
11:21:17 <Syzygy-> int-e: Ooooooh, yeah. That's more legible.
11:21:17 <lambdabot>   Couldn't match the rigid variable `f' against `a b1 c1'
11:21:18 <lambdabot>    `f' is bound by the polymorphic type `forall f g b c. f -> g -> (b, c)'
11:21:18 <vincenz> > isNothing Nothing
11:21:20 <lambdabot>  True
11:21:32 <Taral> @type (\f g -> f &&& g) :: (x->y) -> (z->a) -> (b, c)
11:21:34 <lambdabot>   Couldn't match the rigid variable `z' against the rigid variable `x'
11:21:34 <lambdabot>    `z' is bound by the polymorphic type `forall x y z a b c.
11:21:35 <Syzygy-> > isNothing Just 3
11:21:36 <lambdabot>    The function `isNothing' is applied to two arguments,
11:21:37 <lambdabot>   but its type `...
11:21:37 <cjeris> &&& == arrow-zip ?
11:21:37 <Taral> ah, durr.
11:21:42 <vincenz> @type f Taral = Taral
11:21:43 <Syzygy-> > isNothing (Just 3)
11:21:44 <lambdabot> parse error on input `='
11:21:45 <lambdabot>  False
11:22:03 <Taral> I want my partial type signatures!
11:22:05 <astrolabe> fourbissime: also you need 'if myfield myObj =='
11:22:28 <Syzygy-> So, to write it out in text, &&& takes one f:a -> b and one g:a -> c, and forms (f x, g x)
11:22:33 <Syzygy-> right?
11:22:35 <vincenz> yes
11:22:45 <vincenz> for functions
11:23:07 <Syzygy-> And for other kinds of arrows, it returns the correspondent semantics for those arrows.
11:23:13 <vincenz> yeps
11:23:17 <vincenz> unless they're badly implemented
11:24:34 <Syzygy-> *poof* Gone.
11:24:54 <Syzygy-> int-e++ Thanks for helping me understand
11:25:01 <Syzygy-> vincenz++ Thanks for helping me understand.
11:40:40 <dylan> wow, Slang is sure inconsistent with integer types.
11:41:47 <vincenz> as badly as java?
11:42:05 <dylan> well, it's a C library.
11:42:48 <dylan> there's SLtt_set_color(int object, char *, char *, char *) which defines a fg and bg color for objects numbered int.
11:43:24 <dylan> to use that color, you'd use: SLsmg_set_color(SL_Color_type)
11:43:48 <dylan> SL_Color_Type is a Word8, but it's same value as the int passed to SLtt_set_color!
11:44:06 <dylan> so, really, SLtt_set_color's first argument should be the SL_Color_Type...
11:45:08 <dylan> it's still nicer than ncurses' ColorPair stuff, but jeeze.
11:46:40 <dylan> @hoogle CString
11:46:41 <lambdabot> Foreign.C.String.CString :: type CString
11:46:41 <lambdabot> Foreign.C.String.CStringLen :: type CStringLen
11:46:41 <lambdabot> Foreign.C.String.newCString :: String -> IO CString
11:48:14 <dylan> I decided to do a two-layer binding for Slang... Basically, expose the C interface under various Slang.SL* modules, and  then write something haskellish on top
11:49:03 <dylan> this is sort of required as I've never actually used Slang, outside of my this binding I'm writing...
11:49:34 <siloe> ventonegro
11:49:58 <shapr> shazbot
11:50:08 <dylan> nanu-nanu.
11:50:21 * shapr grins
11:52:07 <dylan> Woot! colors work!
11:53:05 <dylan> it's a lot easier calling C functions from haskell than it is from C. :-)
11:53:24 <siloe> ventonegro
11:55:23 <PupenoR> hehe.
11:56:03 <dylan> ventilaÃ§Ã£o.
11:56:17 <shapr> siloe: Hi, are you learning Haskell?
11:59:01 <pitecus> Is there some consise idiom for updating fields in nested records?
11:59:13 <chessguy> > 6 / 3
11:59:15 <lambdabot>  2.0
11:59:25 <chessguy> > 6 `div` 3
11:59:27 <lambdabot>  2
11:59:32 <PupenoR> > 6 / 0
11:59:33 <shapr> pitecus: I tend to make an emptyFoo and then do emptyFoo { field = value }
11:59:34 <lambdabot>  Infinity
11:59:56 <PupenoR> Does Haskell98 include support for imaginary numbers ?
11:59:58 <chessguy> i hate the math operators in haskell
12:00:11 <teufel> 2 ^ (1/2)
12:00:18 <int-e> > 2 ** (1/2)
12:00:20 <shapr> PupenoR: Yeah, they're called Complex
12:00:20 <lambdabot>  1.4142135623730951
12:00:26 <glguy> > (1 :+ 1)
12:00:26 <teufel> thx
12:00:27 <lambdabot>  1.0 :+ 1.0
12:00:29 <pitecus> shapr what do you do when you want to update a field in a record nested a couple of levels deep in other records?
12:00:30 <PupenoR> > sqrt -1
12:00:31 <lambdabot>  add an instance declaration for (Num (a -> a))
12:00:42 <Binkley> > sqrt (-1)
12:00:42 <PupenoR> > sqrt -1 :: Complex
12:00:43 <teufel> -1 ** (1/2)
12:00:43 <lambdabot>  NaN
12:00:44 <lambdabot>    `Complex' is not applied to enough type arguments
12:00:44 <lambdabot>   Expected kind `?',...
12:00:52 <Binkley> heh
12:00:52 <PupenoR> > sqrt -1 :: Complex Int
12:00:54 <lambdabot>  Couldn't match `Complex Int' against `a -> a'
12:01:02 <Binkley> sqrt ((-1)::Complex Int)
12:01:10 <Binkley> > sqrt ((-1)::Complex Int)
12:01:12 <lambdabot>  add an instance declaration for (RealFloat Int)
12:01:12 <lambdabot>   In the definition of `k...
12:01:22 <Binkley> > sqrt ((-1)::Complex Float)
12:01:24 <lambdabot>  -0.0 :+ 1.0
12:01:32 <teufel> Ah, nice
12:01:45 <PupenoR> > 1 :+ 5
12:01:46 <lambdabot>  1.0 :+ 5.0
12:01:57 <PupenoR> > :+ 5
12:01:58 <lambdabot>  Parse error
12:02:09 <pitecus> I mean for retrieving you can just compose the accessor functions
12:02:20 <shapr> I haven't had that problem before.
12:02:27 <pitecus> But for updating I end up with really verbose code
12:04:26 <shapr> Maybe a monad to automate passing records?
12:04:54 <pitecus> Hm
12:04:56 <Heffalump> Binkley: any joy with your darcs problems?
12:05:03 <chessguy> hmm, ok. i need to sort a list, first by the binary weight of the number, then (if tied) by the value in increasing order. i wrote a weight function
12:05:17 <chessguy> @hoogle sort
12:05:18 <lambdabot> List.sort :: Ord a => [a] -> [a]
12:05:18 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
12:05:18 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
12:05:47 <chessguy> @kind Ordering
12:05:48 <lambdabot> *
12:05:58 <chessguy> oh, that's helpful
12:06:13 <Heffalump> @type Data.Ord.comparing
12:06:15 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:06:33 <chessguy> hmm
12:06:40 <Heffalump> @type (\weight -> List.sortBy (Data.Ord.comparing weight))
12:06:42 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
12:07:11 <Binkley> Heffalump: yes, Igloo's message solved the problem
12:07:20 <Binkley> I needed to pull in the changes from the HEAD in the original branch
12:07:28 <Binkley> then I could pull in the patch from that branch into my second branch
12:07:54 <Heffalump> ah, cool
12:07:55 <chessguy> what's a->a1 mean?
12:08:05 <Heffalump> it's like (a -> b)
12:08:08 <Heffalump> just a different name
12:08:13 <chessguy> oh ok
12:08:19 <SamB> it means the compiler isn't very good at coming up with type variable names, thats all
12:08:22 <chessguy> so what kind of function do i want to put there?
12:08:43 <Heffalump> Binkley: clearly some of his GHC time needs to be allocated to work on darcs :-)
12:08:53 <Heffalump> chessguy: your weight function
12:08:59 <Heffalump> or does that just do the binary weight bit?
12:09:14 <Heffalump> if so, then put (\a -> (weight a, a))
12:09:16 <chessguy> yes, i have a function that calculates the binary weight
12:09:40 <Binkley> Heffalump: well, take that up with MSR :-)
12:10:51 <chessguy> (\weight -> List.sortBy (Data.Ord.comparing weight)) (\a -> (weight a, a)) [3,4,5,6,7]
12:10:59 <chessguy> > (\weight -> List.sortBy (Data.Ord.comparing weight)) (\a -> (weight a, a)) [3,4,5,6,7]
12:11:01 <lambdabot>  Not in scope: `weight'
12:11:07 <chessguy> oh, whoops
12:11:12 <chessguy> is that what i want though?
12:11:45 * SamB thinks ircds ought to word-wrap instead of pedantically following the RFC and truncating
12:11:59 <SamB> hmm, wrong channel..
12:12:52 <chessguy> @hoogle comparing
12:12:53 <lambdabot> No matches found
12:13:47 <Heffalump> > let weight a = a in List.sortBy (Data.Ord.comparing (\a -> (weight a, a))) [4,5,3,2,6]
12:13:48 <lambdabot>  Not in scope: `Data.Ord.comparing'
12:14:11 <chessguy> ghc can't find Data.Ord either
12:14:13 <Heffalump> well, something like that, without the let
12:14:26 <Heffalump> oh. It was someone else who mentioned a day or two ago that it exists.
12:14:30 <Heffalump> I usually just write it:
12:14:38 <Heffalump> comparing f x y = compare (f x) (f y)
12:15:45 <vincenz> Heffalump: or
12:15:50 <vincenz> with
12:15:55 <sjanssen> comparing is in GHC 6.6
12:16:01 <vincenz> g `with` f = \x y -> g (f x) (f y)
12:16:02 <Heffalump> ah, right
12:16:43 <vincenz> :)
12:16:53 <vincenz> compare `with` length
12:16:54 <SamB> is that flip on?
12:17:20 <chessguy> cool, it works now, thanks
12:22:43 <chessguy> > let list = [1,2,3]; getPairs list = zip list list in getPairs list
12:22:45 <lambdabot>  [(1,1),(2,2),(3,3)]
12:23:10 <vincenz> @join ##logic
12:29:21 <Igloo> Heffalump: Solve conflictors satisfactorily and I'll spend time on darcs  :-)
12:29:59 <chessguy> umm, silly question. is there an operator such that x `op` y gives (x, y) ?
12:30:00 <edwardk> vincenz hrmm, no go apparently
12:30:26 <SamB> you can't use it infix, but try (,)
12:30:34 <SamB> > (,) 1 2
12:30:36 <lambdabot>  (1,2)
12:30:53 <edwardk> > let op = (,) in 1 `op` 2
12:30:55 <lambdabot>  (1,2)
12:30:57 <edwardk> =)
12:30:59 <chessguy> > map ((,) 1) [1..5]
12:31:01 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5)]
12:31:21 <chessguy> ok, that works
12:32:37 <int-e> @type uncurry id
12:32:38 <lambdabot> forall b c. (b -> c, b) -> c
12:33:12 <int-e> @type curry id
12:33:14 <lambdabot> forall a b. a -> b -> (a, b)
12:34:51 <vincenz> @join #oasis
12:35:06 <vincenz> I lost control
12:37:50 <lispy> > 1 , 2
12:37:51 <lambdabot>  Parse error
12:37:54 <dylan> hmm, can hsc2hs generate accessors for extern variables?
12:39:28 <kpreid> > let (&) = (,) in 1 & 2
12:39:29 <lambdabot>  (1,2)
12:39:36 <kpreid> chessguy: you can always do that
12:39:55 <chessguy> i got it, but thanks
12:41:42 <PupenoR> > 1 `(,)` 2
12:41:43 <lambdabot>  Parse error
12:43:49 <wilx> > 1 (,) 2
12:43:50 <lambdabot>     add an instance declaration for (Num ((a -> b -> (a, b)) -> t -> a1))
12:43:51 <lambdabot> ...
12:44:03 <wilx> > 1 , 2
12:44:04 <lambdabot>  Parse error
12:44:18 <wilx> Hmm...
12:44:41 <SamB> > (1, 2)
12:44:43 <lambdabot>  (1,2)
12:45:11 <SamB> tuples *DO* have special syntax
12:46:10 <lispy> blasphemy!
12:46:37 <lispy> > zipWith (,) [1..5] [5..10]
12:46:39 <lambdabot>  [(1,5),(2,6),(3,7),(4,8),(5,9)]
12:46:48 <SamB> that *IS* special syntax
12:47:04 <SamB> > .,.
12:47:05 <lambdabot>  Parse error
12:47:07 <dolio> Oh, lispy:
12:47:11 <SamB> > 1 .,. 1
12:47:12 <lambdabot>  Parse error
12:47:18 <dolio> ?type \f g -> (g =<<) . f
12:47:19 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a1 -> m a) -> (a -> m b) -> a1 -> m b
12:47:27 <dolio> That might be nicer looking.
12:47:28 <SamB> see, the comma isn't even an operator character
12:47:46 <lispy> dolio: i know =<< was hiding in there, but i didn't think to try that
12:48:26 <lispy> dolio: pretty cool though
12:48:27 <dolio> Yeah. I thought about it while I was falling asleep, since it was bugging me.
12:48:46 <chessguy> > 1 ==\ 2
12:48:47 <lambdabot>  Not in scope: `==\'
12:48:56 <chessguy> > 1 ==/ 2
12:48:57 <lambdabot>  Not in scope: `==/'
12:49:00 <lispy> /=
12:49:04 <lispy> you want /=
12:49:06 <chessguy> darnit, why can i never remember that
12:49:07 <lispy> > 1 /= 2
12:49:07 <dolio> It's just too bad you can't just do >>>.
12:49:09 <lambdabot>  True
12:49:41 <lispy> chessguy: yeah, i often type =/ by mistake
12:50:20 <chessguy> i should just define `ne` and use that
12:54:17 <monochrom> ne
12:54:35 <dons> ?users
12:54:36 <lambdabot> Maximum users seen in #haskell: 265, currently: 242 (91.3%), active: 37 (15.3%)
12:54:42 <dons> ?uptime
12:54:43 <lambdabot> uptime: 2d 20h 51m 31s, longest uptime: 6d 23h 44m 3s
12:59:00 <chessguy> how does it define active?
12:59:11 <dons> spoke in the last 4 hours
13:00:42 <chessguy> ah
13:03:01 <dolio> @remember qwe1234 never heard of malbolge before, but i'd think that writing a simple source-to-source translator from some sort of minimal vm assembly to malbolge shouldn't be too difficult.
13:03:35 <Binkley> haha
13:03:39 <profmakx> how was that
13:03:48 <Binkley> @quote qwe1234
13:03:49 <lambdabot>  never heard of malbolge before, but i'd think that writing a simple source-to-source translator from some sort of minimal vm assembly to malbolge shouldn't be too difficult.
13:03:49 <profmakx> the first malbolge program was found by a computer program
13:04:02 <dons> he's an annoying troll on programming.reddit.com
13:04:04 <profmakx> doing some search in the space of possible malbolge programs?
13:04:20 <Binkley> @quote qwe1234
13:04:21 <lambdabot>  check out 'complexity theory', it's all there.
13:04:27 <dolio> That was part of his argument that he can write expressive code in any language.
13:04:27 <profmakx> trolling seems to become some kind of sport
13:04:35 <sjanssen> nice, who added these?
13:04:38 <dolio> By writing code in another, more expressive language, and compiling to the other language.
13:04:40 <dons> http://programming.reddit.com/info/pylx/comments?opt_cstyle=nested
13:04:41 <sjanssen> @quote qwe1234
13:04:43 <lambdabot> Title: Ask Reddit: Why is OCaml faster than Haskell? (reddit.com), http://tinyurl.com/yysxms
13:04:44 <lambdabot>  i can write clean and 'expressive' code (quickly) in any language and paradigm, thank you very much.
13:05:22 <dolio> Because expressiveness doesn't exist, because it's not a mathematically defined concept, in his opinion.
13:05:44 <dons> i'm not sure that he's not a bot
13:06:06 <sjanssen> you can get an RSS feed for qwe1234's comments, somebody ought to write a lambdabot plugin to yank them
13:06:36 <dons> heh
13:06:45 <dons> that's a fun idea actually
13:07:01 <kpreid> hey dons, have you had a chance to look at my @unpl? :)
13:07:01 <dolio> I don't know. Most aren't worth saving. :)
13:07:02 <sjanssen> the RSS feed has the full text of the comments and everything
13:07:10 <xerox> yeah, take the noise and pump it into the chat directly!
13:07:14 <dolio> He's really prolific.
13:07:15 <edwardk> kpreid: ah beat me to it =)
13:07:41 <dons> kpreid: its unlikely i will till sunday. i've got to help organise a conference that's happening at the moment, so its a bit hard to do anything else
13:07:53 <kpreid> dons: noted. thanks for the info.
13:09:42 <dons> i guess we could have a distributed vote bot
13:09:56 <dons> that automatically puts -5 votes on anything qwe1234 says
13:10:03 <dons> making his comments disappear
13:10:52 <sjanssen> @remember qwe1234 so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
13:10:58 <dons> heh
13:11:28 <dons> only trolls ever say:
13:11:29 <dons> 	
13:11:29 <dons> -2 points 1 day ago by qwe1234
13:11:29 <dons> lol but i am a troll
13:11:29 <dons> it's a sustainable economy of trolling
13:11:57 <ndm> dons: my supervisor asked me about being 30% faster than GHC, after seeing it on HWN
13:12:02 <dons> heh :)
13:12:24 <dons> ndm, glad to help with the student<->supervisor communication
13:12:33 <dons> we could also use sky writing for your progress reports
13:13:00 <dons> or , perhaps, have a streaker run across the pitch during the ashes series, with your results written on their back?
13:13:01 <ndm> dons: up til that point my supervisor didn't know anything of my blog - he only ever reads haskell@haskell.org so I am careful what i post there, but don't worry on -cafe
13:13:20 <ndm> dons: is that an offer?
13:13:22 <dolio> I just don't get people like that. Spending hours a day posting comments I know are stupid to a social bookmark site?
13:13:45 <dons> ndm: heh
13:14:15 <dons> dolio: there are misanthropes and malfunctioning people in the 6 billion out there
13:14:17 <jgrimes> dolio, I don't understand it either.
13:14:35 <Excedrin> I don't think he's admitting to being a troll
13:15:20 <Excedrin> he's genuinely stupid and arrogant
13:15:47 <profmakx> haskell++
13:16:08 <ndm> @karma haskell
13:16:09 <lambdabot> haskell has a karma of 10
13:16:36 <dolio> You think he's genuine? I don't think that's physically possible. :)
13:16:59 <sjanssen> haskell++
13:17:53 <dolio> Perhaps I'm too much of an optimist, though. :)
13:18:21 <ndm> there are plenty of stupid people in teh world
13:18:43 <ndm> and plenty of people who think i work in pascal, despite my best efforts to explain
13:18:57 <dolio> I suppose stupidity and arrogance do frequently go together.
13:18:57 <Botty> lol
13:19:05 <sjanssen> ndm: ha
13:19:38 <sjanssen> perhaps you should stutter?  huh-huh-huh-haskell
13:19:55 <dcoutts> I liked the one about the author of "Why Functional Programming Matters", "qwe1234> the author doesn't know what 'functional programming' is, and what it is used for."
13:20:11 <lisppaste2> metaperl pasted "I'm trying to calculate how many elements of a list are equal, but it is not working... HELP NEEDED PLEASE" at http://paste.lisp.org/display/29584
13:20:21 <cjeris> when i mentioned haskell to my boss she thought i was referring to something named Houston Area Spooler Control Language
13:20:27 <dolio> Yeah, well, I can't figure out what his definition of functional programming is.
13:20:34 <dolio> I think it might be "works well".
13:20:51 <dcoutts> dolio, could be, or perhaps he's confusing it with fictional programming
13:21:23 <metaperl> The reason I am back with haskell is I spent one day trying to grok UML...
13:21:29 <ndm> metaperl: homework or not?
13:21:41 <dolio> Although I've seen him make comments about I/O being formally modeled as operations on infinite lists, so it's hard to tell.
13:21:48 <profmakx> hm
13:21:50 <metaperl> ndm: not homework.. http://www.metaperl.com -- I am far beyond the student stage :)
13:21:52 <Excedrin> dolio: I've noticed a common trend across "inciteful" pl related posters; they frequently claim that software should be more like math
13:21:52 <lambdabot> Title: metaperl.com - premier perl consulting
13:21:53 <ndm> metaperl: and the exact spec, ideally with an examplke or two
13:21:56 <profmakx> At some point people should stop feeding the troll: qwe1234. Remember that trolls live on your energy, like other kinds of parasites.
13:21:59 <profmakx> dons++
13:21:59 <profmakx> ^^
13:22:00 <ndm> metaperl: yeah, thats what i though, but best to check :)
13:22:16 <metaperl> oh, the simple question is: how can I get the cartesian cross product of a list
13:22:17 <dons> :)
13:22:36 <ndm> > sequence "abc"
13:22:37 <lambdabot>  Couldn't match `m a' against `Char'
13:22:40 <LPhas> UML is throwing away years of studyes on computational formalisms for random drawings
13:22:47 <metaperl> lol
13:22:47 <ndm> :t sequence
13:22:57 <ndm> @type sequence
13:22:59 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:23:22 <lucca> metaperl: crayons help
13:23:33 <metaperl> lol
13:23:49 <Botty> oh, that is something I thought of the other day - couldn't IO actions be a list returned by the main function, and lazily got by the runner?  I'm ignoring input at the moment, but it could probably be worked in.
13:23:57 <sjanssen> > [(x, y) | x <- [1..3], y <- [1..3]]
13:23:59 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:24:05 <ndm> why not: length list - length (nub list)
13:24:07 <dcoutts> LPhas, yeah, one of my tutors says about UML, "what is the semantics?"
13:24:09 <ndm> in some combination
13:24:31 <ndm> i.e. length (nub list) is the number of elements that are't duplicated
13:24:33 <LPhas> dcoutts: i want my software engineering professor death
13:24:41 <LPhas> dcouts: she also wants me death
13:24:43 <ndm> length (list \\ nub list) is those that are not duplicate
13:24:48 <dolio> Botty: that's similar to how Haskell's IO interface used to work, as I understand it.
13:24:54 <sjanssen> Botty: I believe Haskell used such a system before monads
13:24:55 <ndm> LPhas: she wants you?
13:25:00 <dcoutts> ndm, it can be done in O(n log n) time if you don't use nub
13:25:10 <Botty> oh, ok, cool
13:25:14 <ndm> dcoutts, nub -> snub and you probably get that back
13:25:20 <LPhas> ndm: yeah, it's like a war
13:25:38 <dcoutts> ndm, heh, we need 'snub' in the standard lib :-)
13:25:43 <LPhas> after some posts on the course forum
13:25:53 <ndm> dcoutts, YES!
13:25:57 <LPhas> she came in class saying "WHO is $mysurname"
13:26:01 <metaperl> I'm sorry, but the type signature of sequence is not helping me out and neither is google... any examples? I just want a list of 2-tuples given a list, where the 2-tuples represent the cartesian cross prodcut
13:26:08 <LPhas> but i wasn't there
13:26:49 <ndm> metaperl: i have that operator in my library, just figuring out how i did it...
13:26:49 <sjanssen> @let snub x = ("My snd is stupid", x)
13:26:51 <lambdabot> Defined.
13:26:51 <dcoutts> ndm, and snubBy, so we can say: snubBy (ignoring x), or snubBy (being late)
13:26:59 <dolio> > sequence [[1, 2, 3], [4, 5, 6]]
13:27:01 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
13:27:25 <lispy> > (\xs ys -> [(x,y) | x <- xs, y <- ys]) [1..3] [4..6]
13:27:27 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:27:39 <dcoutts> snub = map head . group . sort  right?
13:27:42 <xerox> sjanssen: looks like those tshirts, but cooler, \x -> ("I'm with stupid -> ",x)
13:27:54 <ndm> allPairs :: [a] -> [(a,a)]
13:27:55 <ndm> allPairs [] = []
13:27:57 <ndm> allPairs (x:xs) = map ((,) x) xs ++ allPairs xs
13:28:01 <metaperl> lispy: that is sweet. and thanks dolio and ndm
13:28:06 <ndm> metaperl: i have that in my library
13:28:12 <metaperl> what library?
13:28:19 <ndm> dcoutts, yes
13:28:22 <ndm> metaperl: my internal library
13:28:28 <xerox> ndm: what?
13:28:30 <metaperl> oh.
13:28:40 <dcoutts> metaperl, the library in ndm's head :-)
13:28:45 <ndm> xerox: that i use for developing Catch
13:28:52 <metaperl> what is Catch?
13:28:52 <dolio> > (head &&& head . tail) $ sequence [[1, 2, 3], [4, 5, 6]]
13:28:54 <lambdabot>  ([1,4],[1,5])
13:29:01 <ndm> http://www.cs.york.ac.uk/fp/darcs/catch/src/General/General.hs
13:29:03 <dolio> > map (head &&& head . tail) $ sequence [[1, 2, 3], [4, 5, 6]]
13:29:03 <ndm> @where Catch
13:29:07 <lambdabot> http://tinyurl.com/yk8om5
13:29:08 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:29:09 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
13:29:16 <metaperl> php?
13:29:23 <metaperl> you dropped down to writing in PHP?
13:29:24 <ndm> metaperl: something that proves the absence of pattern match errors in a Haskell program (i.e. you don't head an empty list)
13:29:35 <xerox> ndm: and it does work?
13:29:41 <ndm> metaperl: its whats on the Uni servers, i only use it for the include stuff top and bottom
13:29:48 <metaperl> i see
13:29:54 <ndm> xerox: yes and no, read my paper on the Catch page
13:30:07 <ndm> xerox: it works a lot better now, am hoping to release soon
13:30:28 <xerox> ah, last time I saw the code, it was like really just the skeleton
13:30:55 <ndm> xerox: its now more broken than working, i need to put it back together again
13:31:10 <ndm> xerox: its certainly not worth getting the code yet, but i want to release the transformation pass next week
13:31:17 <lisppaste2> metaperl annotated #29584 with "sequence barfs up everything" at http://paste.lisp.org/display/29584#1
13:31:20 <ndm> dcoutts, interleave for the standard library
13:31:25 <lispy> > product [[1..3], [4..6]]
13:31:26 <lambdabot>  add an instance declaration for (Num [a])
13:31:27 <lambdabot>   In the definition of `spd': s...
13:31:27 <xerox> okay!
13:31:31 <metaperl> my test call to sequence() did not work nearly as well...
13:32:17 <Botty> ?type sequence
13:32:19 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:32:23 <ndm> metaperl: did you seem my allPairs code? that should let you do what you want
13:32:48 <metaperl> ndm: oh no, hold on. let me go check
13:32:48 <EvilRanter> what're we doing with sequence()? I've lost the thread of this convo
13:32:52 <Botty> I don't really know what sequence does, but looks like the members of the list need to be wrapped by a monad
13:32:55 <metaperl> I'm trying to learn though
13:32:57 <lispy> what is sequence()?
13:33:03 <lispy> > sequence ()
13:33:04 <lambdabot>  Couldn't match `[m a]' against `()'
13:33:09 <metaperl> @type sequence
13:33:11 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:33:23 <lispy> sequence() looks like a type error to me
13:33:32 <EvilRanter> > sequence []
13:33:33 <lambdabot>  add an instance declaration for (Show (m [a]))
13:33:35 <monochrom> typo to me
13:33:39 <metaperl> oh I was just using the parentheses to denote a function
13:33:54 <monochrom> hahahaha  C is poisonous
13:34:10 <EvilRanter> oh, i know what's going on
13:34:12 <dolio> [1, 2, 4] isn't a list of lists.
13:34:26 <EvilRanter> sequence takes a list of monads, in this case a list of lists
13:34:27 <EvilRanter> righT?
13:34:35 <dolio> sequence on [[a]] finds the cartesian product of the lists contained within the given list.
13:34:37 <lispy> right
13:34:40 <EvilRanter> *not monads, things typed to a monad
13:34:41 <metaperl> EvilRanter: thanks
13:35:10 <EvilRanter> > sequence [[1,2]]
13:35:11 <lambdabot>  [[1],[2]]
13:35:18 <EvilRanter> > sequence [[1,2],[3,4]]
13:35:20 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
13:35:57 <therp> what is a good format to consume darcs documentation? I hesitate a bit to print the 110 pages darcs manual
13:36:21 <lispy> therp: i would maybe go with the ps or pdf
13:36:36 <lispy> therp: but it seems mostly i find it by googling and read it on the web
13:36:43 <therp> lispy: I'm not such a fan of on screen reading.. at least not that much
13:36:47 * therp want epaper! :)
13:37:09 <ndm> no one seems to be flaming System.FilePath :(
13:37:15 <lispy> therp: i bet you won't need much of the manual unless you're trying to graps patch theory, in which case i can recommend better papers
13:37:33 <sjanssen> @check (\xs -> sequence [xs, xs] == [[x, y] | x <- xs, y <- xs]) :: [Int] -> Boo
13:37:35 <lambdabot>  Not in scope: type constructor or class `Boo'
13:37:46 <therp> lispy: I think so too
13:37:48 <sjanssen> @check (\xs -> sequence [xs, xs] == [[x, y] | x <- xs, y <- xs]) :: [Int] -> Bool
13:37:50 <monochrom> You can print on paper.
13:37:51 <lambdabot>  OK, passed 500 tests.
13:38:14 <metaperl> I just realized that a cross-product is not what I need.. it gives me (a,b) and (b,a) when I just need (a,b)
13:38:30 <emu> @pl f >>= return . g
13:38:30 <lambdabot> g `fmap` f
13:38:38 <monochrom> You can take a picture of the screen showing the paper.  Then view it on the LCD of the digicam.
13:38:46 <lispy> > (\xs ys -> [(x,y) | x <- xs, y <- ys]) [1..3] [4..6]
13:38:48 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:38:51 <newsham> is there a int -> int -> int   function for powers?
13:38:59 <ndm> metaperl: define what you want, and i'm sure you can do it with length and nub
13:39:01 <lispy> metaperl: like that right?
13:39:06 <sjanssen> newsham: (^) will work
13:39:21 <ndm> metaperl: if you have "abcccaa" should that give you 6 ?
13:39:24 <EvilRanter> metaperl, you need combinations?
13:39:24 <sjanssen> > (2 :: Int) ^ (8 :: Int) :: Int
13:39:26 <lambdabot>  256
13:39:40 <newsham> ?pl \c -> read [c]
13:39:41 <lambdabot> read . return
13:39:42 <metaperl> I'm just trying to calculate how many elements of a list are equal
13:40:03 <ndm> metaperl: i.e. how many elements in the list have no additional member?
13:40:16 <ndm> (or the inverse of)
13:40:24 <lispy> what if you did this the stupid way
13:40:34 <lispy> and counted the occurances
13:40:47 <EvilRanter> metaperl, as in, the number of entries with the most common value?
13:40:49 <metaperl> ndm: the phrase "additional member" confuses me
13:41:00 <EvilRanter> metaperl, or the number of entries equal to any other value?
13:41:03 <Botty> probably need to better define the problem better - the number of values which have multiple instances, or the number of instances that are equal to others
13:41:15 <metaperl> EvilRanter:  howManyEqual [ 1,2,3] == 0 ... howManyEqual [11 , 22, 11] = 1
13:41:15 <newsham> > let sod n = sum $ map (read . return) $ show n in sod $ sod $ sod $ 5555 ^ 5555
13:41:18 <lambdabot>  5
13:41:21 <EvilRanter> (for "other value", read "other entry")
13:41:24 <newsham> is there a cleaner way to write that?
13:41:33 <EvilRanter> metaperl, er, the number of values with more than one entry?
13:41:41 <sjanssen> metaperl: what about [11, 22, 11, 11]?
13:41:50 <metaperl> EvilRanter:  that would return 3
13:41:54 <metaperl> i mean sjanssen
13:42:09 <EvilRanter> but [1,2,1] gives 1?
13:42:17 <ndm> let x = "abcccca" in length x - length ((nub x ++ nub x) \\ x)
13:42:23 <ndm> > let x = "abcccca" in length x - length ((nub x ++ nub x) \\ x)
13:42:25 <lambdabot>  6
13:42:31 <dcoutts> sum . map length . filter ((>1).length) . group . sort
13:42:34 <ndm> > let x = [11,22,11,11] in length x - length ((nub x ++ nub x) \\ x)
13:42:36 <lambdabot>  3
13:42:42 <metaperl> EvilRanter: good point [1,2,1] returns 2
13:42:53 <newsham> ?pl \n -> sum $ map (read . return) $ show n
13:42:54 <lambdabot> sum . map (read . return) . show
13:43:02 <ndm> (i prefer dcoutts version though)
13:43:16 <EvilRanter> metaperl, what about [1,1,2,2]?
13:43:35 <metaperl> hmm good question
13:43:38 <sjanssen> > sum . map (pred . length) . group . sort $ [1, 2, 1, 1]
13:43:39 <lambdabot>  2
13:43:49 <metaperl> I think Botty hit the crucial nerve
13:44:27 <ndm> metaperl: dcoutts solved it stone dead
13:45:00 <dcoutts> or if you define it differently then it's: length . filter ((>1).length) . group . sort
13:45:21 <dcoutts> ie if you're counting the number of groups rather than the size of the groups
13:45:41 <EvilRanter> or maybe length . concat . filter ((>1).length) . group . sort
13:45:43 <newsham> > let sod = sum . map (read . return) . show in sod . sod . sod $ 5555 ^ 5555
13:45:46 <lambdabot>  5
13:45:50 <metaperl> beautiful. thanks
13:45:59 <metaperl> now to bash my head against the wall to understand it
13:46:17 <sjanssen> all of these solutions calculate the length of the list twice
13:46:34 <metaperl> I think fromEnum is what I want for my approach. I want to convert True to 1 and False to 0
13:46:41 <dcoutts> sum . filter (>1) . map length . group . sort
13:47:18 <dcoutts> > sum . filter (>1) . map length . group . sort $ [1, 2, 1, 1]
13:47:20 <lambdabot>  3
13:48:07 <dcoutts> now, how much of this fuses ? :-)
13:48:16 <metaperl> fuses?
13:48:19 <dcoutts> group can stream
13:48:26 <sjanssen> sort doesn't fuse
13:48:36 <dcoutts> so it's just the sort that doesn't fuse, on the incomming side
13:48:44 <dcoutts> it could fuse on the producing side
13:48:53 <ndm> dcoutts length doesn't fuse (unless you use Yhc -O)
13:48:55 <dcoutts> depending on the sorting algorithm
13:49:09 <ndm> sort is a producer for Yhc -O as well
13:49:20 <sjanssen> ndm: length fuses in GHC
13:49:31 <SamB> it does?
13:49:33 <sjanssen> yes
13:49:34 <ndm> sjanssen: really? i thought they had an open bug on that
13:49:38 <dcoutts> sjanssen, no it doesn't
13:49:41 <sjanssen> which is likely morally incorrect
13:49:42 <SamB> since when?
13:49:43 <dcoutts> not if it's defined with foldl
13:49:50 <SamB> it isn't incorrect in any way
13:49:54 <SamB> why would it be incorrect?
13:49:55 <dcoutts> foldl doesn't fuse under build/foldr
13:50:07 <SamB> oh, well, there is that
13:50:11 <sjanssen> ndm: the bug is that they use a foldr to fuse length, which causes stack overflows on occasion
13:50:12 <monochrom> I recommend manual fuse.
13:50:12 <SamB> which is LAME LAME LAME
13:50:24 <ndm> sjanssen: yes, hence they removed the fusion rules for length
13:50:25 <SamB> sjanssen: doesn't that cause overflows anyway?
13:50:25 <dcoutts> I recommend stream fusion
13:50:39 <monochrom> foldr (+) 0 . foldr somethingelse  is just as much a crime.
13:50:40 <ndm> Yhc -O has much better fusion that GHC - more general
13:50:40 <SamB> dcoutts: have you a wiki page?
13:50:50 <dcoutts> SamB, we've got a paper.
13:50:55 <SamB> oh darn
13:51:00 <SamB> a *paper*
13:51:03 <sjanssen> ndm: ah, that's a newish change
13:51:14 <SamB> @where stream fusion
13:51:15 <lambdabot> I know nothing about stream.
13:51:19 <SamB> @google "stream fusion"
13:51:21 <ndm> SamB, its quite readable - i recommend it
13:51:22 <lambdabot> http://citeseer.ist.psu.edu/poh04noiserobust.html
13:51:27 <dcoutts> SamB, it's in the FPS paper
13:51:58 <SamB> no, I didn't want a crypto paper, google!
13:52:28 <sjanssen> @google rewriting haskell strings
13:52:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
13:52:30 <lambdabot> Title: Rewriting Haskell Strings
13:53:11 <EvilRanter> samB, sjanssen, i suggest fighting with google directly...
13:57:25 <dcoutts> ndm, doesn't it depend on the sorting algorithm if it can be fused sensibly ?
13:57:49 <ndm> dcoutts, give a sorting algorithm and i'll tell you :)
13:58:14 <dcoutts> merge sort, quick sort, heap sort
13:58:16 <metaperl> which GHC what do I import to sort a list?
13:58:24 <dcoutts> metaperl, List
13:58:29 <metaperl> thanks
13:58:36 <dcoutts> though actually I guess all those would be plausible
13:59:08 <ndm> dcoutts, yeah, looking through them i think i can certainly fuse merge on both producer and consumer
13:59:19 <ndm> although only partially on consumer, not fully
13:59:21 <dcoutts> the difficulty with the merge and quick sort is that only the top level recursion is fusable
13:59:30 <sjanssen>  I have a hard time believing that merge sort is truly fusible
13:59:50 <monochrom> Me too.
13:59:56 <ndm> partially solveable
14:00:06 <monochrom> Why this obsession to fuse?
14:00:08 <sjanssen> doesn't merge sort require O(n) auxiliary storage?
14:00:15 <ndm> monochrom: to beat GHC :)
14:00:19 <Heffalump> monochrom: to avoid paying the laziness penalty
14:00:21 <pkhuong> sjanssen: you could do it in-place.
14:00:27 <dcoutts> monochrom, to beat C
14:00:52 <monochrom> Even C needs aux storage for merge sort.
14:00:53 <dcoutts> sjanssen, needing extra storage doesn't prevent fusion, it might make it easier actually.
14:00:54 <SamB> anyway, merging only partly is good if you get a proportional savings...
14:01:19 <SamB> I mean, when the only alternative is not merging
14:01:22 <lisppaste2> metaperl annotated #29584 with "I sorted my data to compute howManyEqual" at http://paste.lisp.org/display/29584#2
14:01:29 <SamB> er.
14:01:30 <ndm> take this program: http://www.cs.york.ac.uk/fp/darcs/catch/src/Nofib/Exp3_8.hs
14:01:32 <SamB> s/merge/fuse/
14:01:37 <lambdabot> http://tinyurl.com/y43zz4
14:01:45 <sjanssen> dcoutts: I don't follow.  In what form is this extra storage if it isn't a list?
14:01:56 <Heffalump> so is yhc reliable enough to actually use for real work?
14:01:57 <ndm> even though its doubly recursive, fusion gives you about 5% speed up
14:01:57 <dcoutts> sjanssen, a heap
14:02:01 <ndm> Heffalump: no :)
14:02:26 <dcoutts> sjanssen, for example a heap sort should be fusible as a consumer and producer
14:03:00 <dcoutts> building the heap takes O(n) and is a simple traversal over the list
14:03:09 <sjanssen> yeah, I'll buy that
14:03:10 <SamB> it needs newtypes
14:03:12 <Heffalump> but the intervening heap will take up space
14:03:17 <dcoutts> Heffalump, sure
14:03:21 <SamB> and, well, proper monads would be nice too
14:04:01 <dcoutts> then pulling the result list out lazily is also a stream-like thing, it costs O(log n) per element
14:04:20 <Heffalump> given an arbitrary function [a] -> b, is there a good procedure for telling how well it streams?
14:04:26 <dcoutts> so it could be done as sortS :: Ord a => Stream a -> Stream a
14:04:41 <dcoutts> Heffalump, or b -> [a]
14:04:53 <ndm> dcoutts, what are the chances of automatically replacing lists with streams?
14:05:04 <dcoutts> ndm, not sure yet
14:05:27 <dcoutts> Heffalump, the intuition is if it consumes or builds lists in a simple linear fashion
14:05:32 <Heffalump> I know the intuition
14:05:50 <Heffalump> Ideally I'd like a tool to tell me.
14:06:03 <dcoutts> formally then, you probably want to look at the category stuff, algebras & co-algebras
14:06:04 <Binkley> man, you people were talking about fusion when I wasn't here
14:06:06 <Binkley> :-(
14:06:18 <Heffalump> you should watch IRC more obsessively
14:06:23 <dcoutts> heh heh
14:06:35 <Heffalump> you can't possibly have anything more interesting to do with your life
14:06:41 <Binkley> yeah, totally not
14:08:24 <metaperl> fusion - a style of jazz music
14:09:08 <SamB> so, was that a serious suggestion to try to use streams to fuse list functions?
14:10:26 <dcoutts> SamB, yes.
14:10:40 <dcoutts> SamB, we're working on it.
14:11:14 <ndm> dcoutts, what is your phd on?
14:11:28 <dcoutts> ndm, I've switched to work on this stuff
14:11:38 <ndm> dcoutts, ah, what was it before?
14:11:45 <dcoutts> partial evaluation
14:12:41 <ndm> ah, which interestly my phd has turned to focus more on :)
14:12:48 <dcoutts> :-)
14:13:03 <dcoutts> we can talk about it next Thursday :-)
14:13:06 <EvilRanter> @hoogle win32
14:13:07 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
14:13:07 <lambdabot> System.Win32.File.win32_WriteFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
14:13:25 <EvilRanter> that doesn't help... anyone point me to the Win32 module documentation?
14:14:00 <SamB> @doc
14:14:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:14:07 <SamB> EvilRanter: go there!
14:14:10 <dcoutts> ndm, you're trying to do it automatically right ?
14:14:16 <SamB> the column on the right lists package names
14:15:03 <ndm> dcoutts, of course - everything automatic
14:15:21 <ndm> dcoutts, i want users to take existing unannotated source code and have it go faster, and never crash by proof
14:15:30 <dcoutts> ndm, aye, I was trying to do it semi-automatically, to give the programmer more control.
14:15:39 <ndm> yeah, the programmer doesn't get any say with me
14:15:59 <dcoutts> ndm, ie to get PE in cases where it's crucial and makes a big difference, rather than in the bonus optimisation cases
14:16:12 <SamB> not even to say "don't mess with this part! you'll only be confused!"?
14:16:38 <ndm> dcoutts, i am also trying to do firstification at the same time - and some really weird partial evaluations that a normal PE wouldn't, but mine does
14:16:58 <SamB> "firstification"?
14:17:01 <dcoutts> ndm, we should chat about it next week, with a whiteboard
14:17:07 <ndm> dcoutts, cool :)
14:17:14 <ndm> SamB, a program lacking any higher order functions
14:17:16 <dcoutts> SamB, eliminating higher order stuff
14:17:26 <SamB> oh, *that*
14:17:33 <dcoutts> ndm, yeah, I was also trying to do higher order pe directly.
14:17:38 <SamB> it would be clearer if it mentioned "order"
14:18:07 <ndm> dcoutts, i start with a higher order language (full haskell), but my partial evaluation is only first order
14:18:13 <dcoutts> right
14:18:26 <ndm> however, it is complete, because i have a firstifier, which guarantees all HO functions are gone
14:18:44 <SamB> which is how he beats GHC
14:18:47 <dcoutts> how much expansion does that entail ?
14:18:52 <SamB> expansion?
14:18:54 <dcoutts> ie code duplication ?
14:18:56 <ndm> dcoutts, the firstification or the PE
14:18:57 <SamB> what expansion?
14:19:04 <dcoutts> ndm, the firstification
14:19:12 <SamB> notice how this lets you drop all the library stuff you don't use?
14:19:17 <ndm> SamB, beats GHC on 2 out of 2 tests is a better way to say it - its hardly beating GHC by a long way
14:19:27 <SamB> ndm: well. still.
14:19:35 <ndm> dcoutts, very little - one extra function, but it does lead to quite a high runtime cost
14:19:42 <dcoutts> ndm, oh ?
14:19:45 <EvilRanter> SamB, that link doesn't really help, here. HGL is being not-found...
14:19:54 <SamB> EvilRanter: oh?
14:20:06 <EvilRanter> ...and I'm still looking for Win32, which winhugs claims to have in the docs
14:20:06 <ndm> SamB, i can do that using whole program analysis, and a different dictionary transformation step to remove lots of code - but removing code doesn't help speed that much
14:20:15 <ndm> EvilRanter: WinHugs or MinHugs?
14:20:22 <SamB> dictionary?
14:20:26 <SamB> what dictionary?
14:20:26 <EvilRanter> WinHugs
14:20:29 <ndm> dcoutts, yes, i'll just defunctionalise something and paste the result somewhere
14:20:40 <SamB> ndm: dictionaries are evil
14:20:46 <SamB> you should use types instead
14:20:46 <ndm> List> :l System.Win32
14:20:48 <ndm> ERROR file:{Hugs}\packages\Win32\System\Win32\Time.hs - Error while importing DLL "C:\Program Files\WinHugs\packages\Win32\System\Win32\Time.dll"
14:20:57 <SamB> ;-P
14:20:59 <ndm> SamB, i do, which gives a big reduction in code size quite quickly
14:21:28 <SamB> do you SUPERSPECIALIZE?
14:22:32 <ndm> @paste
14:22:33 <lambdabot> http://paste.lisp.org/new/haskell
14:22:38 <ndm> SamB, even more than that
14:22:49 <SamB> how can it be more than that?
14:22:53 <EvilRanter> nm, there's no Win32 module floating around inside the hugs folder, either
14:23:03 <SamB> I mean, if you superspecialized every function...
14:23:08 <ndm> SamB, i just do :)
14:23:12 <norpan> specialize(specialize,specialize)
14:23:49 <lisppaste2> ndm pasted "Defunctionalisation for Primes (part of it only)" at http://paste.lisp.org/display/29585
14:23:57 <ndm> dcoutts ^^^
14:24:11 * dcoutts looks
14:24:26 <SamB> incidentally, SUPERSPECIALIZE means "make a version of this function for every type it could be used on. additionally, make the general version dispatch on type and call the specialized ones."
14:24:29 <newsham> defunctional programming
14:24:54 <ndm> SamB, i do the first one, but because of the way my thing i structured the second will never occur anyway
14:25:09 <ndm> SamB, and not just on dictionaries or classes, on everything
14:25:12 <SamB> well, yeah.
14:25:53 <SamB> so do you do a points-to analysis?
14:27:55 <dcoutts> ndm, so we get a whopping big data decl, and then we end up switching on that all the time
14:28:06 <ndm> SamB, are you asking how i implement Jhc :) - those concepts are't in my thing
14:28:10 <ndm> dcoutts, yes, pretty much
14:28:44 <dcoutts> ndm, so the cost is in the big case right?
14:29:26 <SamB> ndm: do you specialize based on what alternatives can't occur?
14:29:35 <ndm> SamB, yes
14:29:39 <ndm> dcoutts, yes
14:29:56 <ndm> dcoutts, but by the end i've remove @ap, so the cost has disappeared
14:30:00 * SamB wonders how that works with no points-to
14:30:20 <dcoutts> ndm, ok, so that's the interesting bit
14:30:40 <ndm> dcoutts, i guess - but hte defunc stuff makes PE easier, which gives better results, which removes the functions properly
14:30:51 <ndm> its all a nice cycle :)
14:31:11 * SamB thinks Yhc ought to use a name representation more like the kind GHC uses...
14:31:13 <dcoutts> ok :-)
14:31:31 <ndm> SamB, just add Z's between every letter, you'll be happy :)
14:31:34 <SamB> GHC hangs all kinds of info on the names
14:31:36 <dcoutts> ndm, got your version of ack n m  :-) ?
14:31:41 <SamB> in the internal representation
14:31:50 <dcoutts> course that's only first order
14:32:03 <ndm> yeah, would be almost identical to the normal one
14:32:11 <ndm> to get speed ups there i'd need to use my NDM machine
14:32:20 <ndm> a first order version of the STG machine with tagging
14:33:36 <psnl> ndm: does NDM stand for anything wrt to the machine, or are you just stroking your ego?
14:33:38 <SamB> what do the letters stand for?
14:33:39 <ndm> SamB, what info do you want on the anames?
14:33:55 <ndm> psnl: nothing as yet, NDM is only a preliminary name
14:34:21 <psnl> I suppose there are worse things to stroke
14:34:27 <SamB> ndm: oh, I was just thinking it might be easier to get them to output sensibly that way...
14:34:33 <ndm> I guess STF machine - superspineless, tagful, first-order machine
14:34:57 <SamB> also, I imagine people would respect them more ;-)
14:35:37 <ndm> SamB, not sure what you mean?
14:35:41 <SamB> well...
14:36:35 <SamB> take ghc's Var type...
14:37:40 <ndm> i think @0 is a great name for the 0th argument to a function
14:37:51 <SamB> it has a few different constructors, actually
14:37:53 <ndm> much better than arbitrary names which have no relation to anything, are harder to manipulate
14:38:03 <Binkley> ?remember ndm  i think @0 is a great name for the 0th argument to a function
14:38:21 <SamB> ndm: perhaps so
14:38:43 <ndm> SamB, it also makes a unique name monad much easier - [maximum existing .. ]
14:39:26 <SamB> but, I still think it is nice for variables the user actually wrote to have their real names...
14:39:32 <psnl> SimonRC: is there a ghc build on vega that I don't know about?
14:39:57 <SamB> also, it is handy not to have to look everything about a name up in an environment
14:40:18 <SamB> I suppose Yhc would have no use for a type field
14:40:26 <ndm> SamB, there is no information in an environment.... - and the user variables got trashed ages ago
14:40:46 <ndm> plus the optimisations tend to trample over argument names pretty strongly
14:40:55 <Pupeno> sjanssen: can you please tell me again the name of that document about monads ? (I left the URL at work).
14:41:31 <chessguy> @where monads
14:41:32 <lambdabot> http://www.nomaware.com/monads/html/index.html
14:41:38 <chessguy> that one maybe?
14:41:46 <chessguy> @where monads_as_containers
14:41:47 <lambdabot> I know nothing about monads_as_containers.
14:41:59 <ski> @wiki MonadsAsContainers
14:42:00 <lambdabot> http://www.haskell.org/haskellwiki/MonadsAsContainers
14:42:24 <ski> hm, maybe hawiki ..
14:42:36 <ski> yes
14:42:41 <Cale> http://www.haskell.org/haskellwiki/Monads_as_containers
14:42:42 <ndm> http://www.haskell.org/haskellwiki/Monads_as_Containers
14:42:45 <lambdabot> Title: Monads as containers - HaskellWiki, http://tinyurl.com/yylt9j
14:42:45 <ski> s/haskellwiki/hawiki/
14:42:49 <lambdabot> Title: Monads as containers - HaskellWiki, http://tinyurl.com/llgo9
14:42:50 <ski> ah :)
14:42:54 <chessguy> lol
14:42:55 <dons> ndm, have you looked at DrScheme's gui much?
14:43:06 <dons> seems like something we'd want to aim at for WinHugs et al.
14:43:07 <ndm> dons: not at all
14:43:13 <ndm> @google drscheme gui
14:43:15 <lambdabot> http://www.cs.utah.edu/plt/mailarch/plt-scheme-2001/msg00901.html
14:43:16 <lambdabot> Title: Re: DrScheme GUI translators
14:43:17 * dons sitting in APLAS watching DrScheme talk
14:43:25 <dons> really nice interface
14:43:42 <dons> ?google DrScheme
14:43:47 <lambdabot> http://www.plt-scheme.org/software/drscheme/
14:43:47 <lambdabot> Title: DrScheme
14:43:57 <ndm> any screenshots?
14:44:02 <dons> any schemeres around can comment on the joy of DrScheme?
14:44:19 <EvilRanter> I can't remember being impressed. I didn't use it that much, tho
14:44:26 <Cale> dons: It seems like a really nice environment. I wish we had something similar for Haskell.
14:44:34 <dons> i'm looking at the Nov06 DrScheme.
14:44:47 <dons> seems like what we should be trying to do with a ghci/editor integration
14:44:50 <Cale> yeah
14:45:01 <Cale> It's exactly what we should be doing :)
14:45:04 <dons> yeah
14:45:24 <ndm> i think thats more what the hide people are trying
14:45:28 <Cale> Also, I really like how it has learning versions of the language.
14:45:32 <ndm> WinHugs takes a less hands on approach
14:45:50 <dons> is there a nice Helium gui?
14:45:53 <dons> earthy: ?
14:46:07 <ndm> that is very cool though
14:46:14 <ndm> just shows how crap debuggers are in haskell really...
14:46:37 <dons> well we have hpc no. that'll help some.
14:46:39 <newsham> http://www.plt-scheme.org/software/drscheme/tour/tour-Z-H-5.html
14:46:42 <lambdabot> Title: A Brief Tour of DrScheme, http://tinyurl.com/9htgs
14:46:48 <dons> the problem is that we never have bugs bad enough to justify the effort
14:46:52 <ndm> dons: its not really a debugger
14:46:52 <Binkley> heh
14:46:52 <mjl69> > :t 1
14:46:54 <lambdabot>  Parse error
14:46:55 <Binkley> i'd beg to differ
14:46:58 <ndm> dons: thats not true!
14:46:59 <mjl69> o
14:47:10 <Cale> It really seems as if a little bifurcation of Haskell in order to provide simpler definitions for people who are just starting, and better polymorphism for those who have been using the language a while might be a good idea.
14:47:16 <psnl> ndm: well, I'll see what I can do about that (even though I'm working on a tracer)
14:47:20 <dons> disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
14:47:23 <Binkley> the only reason why i've never seriously used a haskell debugger is that i could never get one to install under the version of GHC I was using :-)
14:47:24 <Binkley> heh
14:47:26 <ndm> psnl: debugger == tracer for Haskell
14:47:38 <ndm> dons: runtime debugging, not static debugging
14:48:00 <ndm> psnl: (i realise the hat people all hat it being called a debugger, but i think of it as a debugger - i don't want a tracer, i want t adebugger!)
14:48:05 <psnl> debuggers are a very nice teaching tool
14:48:06 <Binkley> right -- with no typechecker, we'd have lots of runtime bugs to debug
14:48:08 <EvilRanter> mjl69,
14:48:08 <EvilRanter> @t 1
14:48:09 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
14:48:14 <EvilRanter> er
14:48:19 <EvilRanter> ?t 1
14:48:21 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
14:48:23 <dons>  i know there's a need for a debugger. i'm pondering why we don't have one . i think its because the typechecker + QuickCheck catches enough that we don't get much pressure to make one
14:48:27 <EvilRanter> ?type 1
14:48:29 <lambdabot> forall t. (Num t) => t
14:48:32 <EvilRanter> there we go.
14:48:36 <Cale> dons: I agree
14:48:37 <ndm> hmm, do head [] in a massive program and you find out why debugging in haskell sucks!
14:48:41 <mjl69> thanks :)
14:48:43 <newsham> so dont write a "debugger" write a "program stepper for tutorials"?
14:48:44 <Binkley> ndm: exactly.
14:48:56 <ndm> (unless you use yhi-stack, in which case it prints a stack trace, but only i have a copy of yhi-stack here ;) )
14:49:01 <Binkley> in fact I'm trying to track down such a bug at this very moment
14:49:02 <dons> or ghc -prof -xc
14:49:10 <Binkley> and don't want to build ghc for profiling :P
14:49:11 <psnl> ndm: I do too; and the project is "improving a haskell debugger" ;-)
14:49:15 <dons> Binkley: you look at the top of the call stack in a profiling dump
14:49:17 <Cale> Well, don't do that! The head and tail functions really are evil. :)
14:49:24 <dons> yeah :)
14:49:25 <ndm> psnl: yhi-stack is separate from hat
14:49:32 <Binkley> yeah, but I don't want to wait half an hour while I build ghc with profiling on :-)
14:49:40 <psnl> ndm: sorry, being slow
14:49:42 <dons> anywy, hacking on hat would be a good job for LambdaHack 07..
14:49:52 <ndm> dons: agreed!
14:49:55 <psnl> dons: when is that?
14:50:07 <dons> early Jan. details next week
14:50:16 <jgrimes> where is that?
14:50:19 <Cale> Use case unless you're really really sure that your list is nonempty. (i.e. it's locally-obvious that it has an element)
14:50:23 <ndm> (what hat needs is hackers and users, researchers have done all they can)
14:50:25 <dons> it will be at oxford
14:50:30 <psnl> dons: yey!
14:50:31 <dons> ndm. right.
14:50:40 <Binkley> Cale: there are other errors like this that come up, though
14:50:45 <Binkley> right now I'm getting an array out-of-bounds error
14:50:49 <Binkley> and that's Not Supposed To Happen!
14:50:57 <dons> oh, Subject: darcs patch: syntax patch for lambda-match
14:50:58 <ndm> Cale: and what if you're pretty sure, or were when you wrote your program, or have no way of dealing with a [] list at that point
14:51:10 <astrolabe> dons good idea
14:51:18 <astrolabe> I have enough bugs for everyone
14:51:22 <Cale> If you don't know what to do with it, use Maybe :)
14:51:35 <psnl> Binkley: I got a segfault yesterday ;-)
14:51:36 <dons> if big software i'd seriously consider wrapping head with an assert-ing head
14:51:37 <Cale> Which will force your caller to decide what to do with it
14:51:50 <dons> myhead assert xs
14:51:54 <Binkley> psnl: yeah, I've been hacking the RTS. I know segfaults :-)
14:51:55 <Cale> But yes, I agree it would be nicer if those errors gave more detail.
14:51:55 <ndm> Cale: then you wrap your entire program in a maybe, call fromJust from main, and replace all pattern match failures with fromJust :)
14:52:19 <ndm> dons: i have headNote which does that, and lookupNote etc. for loads of others
14:52:24 <SamB> wouldn't it make more sense to use MonadError and just still pattern match fail?
14:52:28 <ndm> and safeTail, where [] -> []
14:52:39 <astrolabe> cale: are you saying using a case statement is better than using head?
14:52:41 <Cale> SamB: depends, perhaps
14:52:49 <dons> ndm, maybe we should bundle the code up and release it?
14:52:54 <ndm> wouldn't it make more sense to use a proof tool to check the absence of pattern match errors
14:52:59 <Cale> astrolabe: yeah, unless you are absolutely sure that your list has an element
14:53:03 <SamB> it beats trying to figure out who is returning Nothing and when
14:53:03 <shapr> Does anyone know how docs.googl.com does collaboration?
14:53:19 <shapr> I'd like to do that same thing with emacs, ya see... and have #haskell-hack 06
14:53:20 <ndm> dons: if you want, its easy enough - just nameNote functions and the odd nameSafe function
14:53:51 <Cale> For instance, it's okay to use tail in something like  fibs = 0 : 1 : zipWith (+) fibs (tail fibs), because it's locally obvious that fibs indeed has an element.
14:53:52 <astrolabe> cale: absolutely sure in the sense that 'as long as you haven't messed something up' or in the sense that you have a proof?
14:54:15 <Cale> I'd say in the sense that you don't have to go looking very far in your code to prove that it does.
14:54:27 * psnl waits for edwinb to lean in
14:54:30 <ndm> Cale: its locally obvious when you write it, but may change, and is not statically enforced
14:54:58 <astrolabe> Could you say more about why case is better please
14:54:58 <Cale> ndm: I mean, it's not locally obvious if your function is being passed an arbitrary list, and you apply xs
14:55:01 <ndm> (assuming your hand crafted proof was ever correct, its easy to screw these things up)
14:55:09 <Cale> because you have to know about all the calling sites then
14:55:15 <ndm> Cale: yes
14:55:17 <dons> scheme seems to have lots of weird keywords that do almost the same thing :/
14:55:24 <ndm> Cale: and a static checker can do that
14:55:28 <dons> field/define?
14:55:29 <Cale> *apply tail to xs*
14:55:30 <ndm> dons: are they not defined in scheme macros?
14:55:45 <dons> oh, they could be (?)
14:55:49 <EvilRanter> I went off scheme, because the fundemental keywords of the language had stupid names
14:56:01 <ndm> dons: i think scheme core is pretty minimal, if not almost non-existant
14:56:06 <dons> yeah
14:56:06 <EvilRanter> define? LAMBDA?!
14:56:13 <Binkley> ?remember EvilRanter I went off scheme, because the fundemental keywords of the language had stupid names
14:56:20 <dons> this is scheme+OO though
14:56:28 <EvilRanter> seriously, "lambda"?
14:56:29 <monochrom> Oh?  Such as "syntax-rules"?  And your philosophy says that syntax doesn't rule?  XD
14:56:33 <Cale> So I'm just saying, don't pass an arbitrary list to head or tail, only one which is being constructed explicitly by the function and obviously has an element without knowing the incoming parameters.
14:56:40 <Binkley> uh, yeah! who would use stupid terms like "lambda"?!
14:56:41 <EvilRanter> "\" forevarr!
14:57:10 <monochrom> I agree with Cale on that.
14:57:14 <EvilRanter> Binkley, there's nothing wrong with _saying_ "lambda", but if you're gonna use a language feature a lot, it should have a very short name
14:57:17 <EvilRanter> IMO
14:57:24 <Cale> Yeah, typing 'lambda' all the time is a bit annoying.
14:57:27 <scodil> its worse in lua. lambda = function
14:57:33 <pkhuong> M-/
14:57:43 <monochrom> "x" is a better choice than "lambda".  "x" is short.
14:57:44 <dons> fun x = x ?
14:57:56 <dons> but i think we should have gone with: \x . x
14:58:00 <dons> the -> is too verbose!
14:58:02 <astrolabe> for example isn't 'head xs' just equivalent to case xs of [] -> error "..."; (y:ys) -> ys}?
14:58:03 <EvilRanter> and the equivalent to (define x) is just "x ="
14:58:17 <monochrom> Syntax Rules!
14:58:21 <EvilRanter> (in haskell)
14:58:23 <dcoutts> dons, is there a unicode '.' to go with unicode lambda ?
14:58:32 <Binkley> EvilRanter: Yes, but you should be programming in a point-free style anyway, so... oh, never mind, I'm slipping into qwe1234 mode
14:58:34 <EvilRanter> there's "middle dot" etc
14:58:39 <dons> oh, a propper 'o'?
14:58:55 <monochrom> Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
14:59:00 <EvilRanter> Binkley, what does points-fee-ness have to do with anything?
14:59:05 <dons> heh
14:59:10 <dons> "qwe1234 mode"
14:59:11 <dcoutts> dons, there compose but I mean a . for \x. x
14:59:12 <Binkley> lol
14:59:19 <dons> dcoutts: hmm!
14:59:24 <EvilRanter> you still need (define) in scheme, and "=" in haskell
14:59:30 <EvilRanter> @qwe1234
14:59:31 <lambdabot> Unknown command, try @list
14:59:34 <EvilRanter> feh
14:59:43 <Binkley> monochrom, is that original?
14:59:45 <Cale> astrolabe: it is, and that's the problem with it.
14:59:49 <monochrom> The third is original.
14:59:50 <dons> ?quote qwe1234
14:59:50 <Binkley> @quote qwe1234
14:59:51 <lambdabot>  oh come on, what do 'functional languages' have to do with lambda calculus?
14:59:51 <lambdabot>  all you happened to have demonstrated is that you suck at writing assembly code.
14:59:59 <Binkley> monochrom: yeah, I kknew the first two weren't original :-)
15:00:02 <astrolabe> cale: ah, I think I'm beginning to see
15:00:16 <dons> we should sell anti-reddit tshirts with qwe1234 quotes on them
15:00:24 <monochrom> There is a unicode character corresponding to LaTeX's \cdot.  It is suitable to go with lambda.
15:00:30 <Binkley> haha
15:00:32 <shapr> Did he really say that?
15:00:34 <Binkley> I would buy those shirts
15:00:36 <Binkley> shapr: yes
15:00:51 <shapr> amazing
15:00:54 <Cale> astrolabe:  if you really don't know what to do with the case of an empty list, your function should probably be returning a Maybe, or some kind of value capable of recording the error, so that the caller has a chance to decide what happens
15:00:55 <Binkley> yep
15:01:02 <shapr> Is that part of the whole ocaml > haskell thread?
15:01:12 <astrolabe> I'm giving a talk about haskell at my work on Monday.
15:01:13 <Binkley> shapr: part of that particular cluster-you-know-what, yes
15:01:19 <astrolabe> Cale thanks
15:01:19 <shapr> I keep meaning to figure out my password on reddit, but it won't talk to me :-(
15:01:29 <Binkley> shapr: just as well.
15:01:48 <monochrom> Figure out qwe1234's password instead, while you're at it.
15:01:52 <Binkley> ha
15:02:01 <Binkley> yeah, but what would you do with qwe1234's password?
15:02:04 <astrolabe> But I'm going to have to admit to them that in my experience debugging haskell is difficult (for the few bugs that get through the type checker).
15:02:08 <Binkley> post even MORE ridiculous comments to make him look dumb?
15:02:10 <Binkley> that's impossible
15:02:12 <dons> Binkley: deete all his comments?
15:02:21 <Cale> "never heard of malbolge before, but i'd think that writing a simple source-to-source translator from some sort of minimal vm assembly to malbolge shouldn't be too difficult." -- qwe1234
15:02:22 <dons> astrolabe: nice.
15:02:23 <Binkley> heh
15:02:23 <ndm> astrolabe: agreed, but hat would solve it
15:02:23 <astrolabe> And that haskell debuggers don't seem to be useful at the moment.
15:02:23 <pkhuong> BTW, if anybody's in the montreal area, the Montreal Scheme/Lisp UG is pretty much language agnostic.
15:02:46 <dons> astrolabe: though we have them. see hat.
15:02:52 <monochrom> Debugging Haskell is difficult.  But debugging is such a 20th-century idea anyway.
15:03:03 <dons> but i'd emphasie that static typing and quickCheck catch almost all the bugs you care about.
15:03:07 <astrolabe> dons: I've spent a long time getting hat to compile my code.
15:03:12 <dons> we just don't have the need that , say, C has for a debugger
15:03:28 <scodil> oh thats bs
15:03:34 <ndm> dons, we do have the need, we just don't have the tool!
15:03:37 <astrolabe> And then only hat-observe seems to work under windows, which is what we use at work.
15:03:42 <Cale> There should be a checkbox in the user options in reddit "Ignore all qwe1234 messages."
15:04:12 <dons> ndm. ok ok. but its not like C.
15:04:18 <psnl> I really should go back to coding on hat rather than watching you guys argue if its needed ;-)
15:04:18 <scodil> it would be better if errors were thrown with their line-numbers and offending values, but there's always need for a debugger.
15:04:24 * dylan hasn't ever used a debugger in any language.
15:04:27 <dons> its not a critical replacement for a type system.
15:04:29 <dcoutts> mm, we can use â¨â© for monad comprehensions
15:04:37 <astrolabe> dons: I agree we have the need.  A lot of the purpose of a debugger isn't to do with the language, if your application is complicated enough, it will do suprising things even without bugs that you will need to trace the code to understand.
15:04:47 <dons> yep
15:04:53 <dons> bring on hcp/hat/...
15:04:57 <astrolabe> psnl:   please do!
15:05:05 <ndm> dons: i wrote C without a debugger, its a bit harder than haskell
15:05:10 <ndm> psnl: you still a student this summer?
15:05:12 <dons> :)
15:05:25 * ndm thinks paying psnl though SoC for Hat work would be a good investment
15:05:29 <Binkley> C has an excellent debugger
15:05:29 <emu> hmm my first extensive parsec grammar/program processes a 3MB file in about 8 seconds. not too shabby.
15:05:31 <Binkley> it's called "printf"
15:05:44 <psnl> ndm: no and I was gainfully employed last summer ;-(
15:05:48 <ndm> Binkley: the C i was writing didn't have printf (server side, remote machine)
15:05:49 <psnl> Binkley: zap!
15:05:56 <qz> "printf" is an excellent debugger until you are spoiled by VS-kind of debugger
15:06:01 <emu> Parsec is just using the normal lazy IO right?
15:06:03 <shapr> This thread is truly amazing.
15:06:04 <dons> qz, yeah :)
15:06:11 <dons> shapr: the reddit one?
15:06:13 <ndm> psnl: you might be able to still get a soc just after your degree finishes
15:06:21 <dons> i'm not sure its not a mind-virus though
15:06:22 <shapr> yeah
15:06:42 <qz> same here. visual assist IS a mind virus though
15:06:45 <shapr> It reminds me of similar threads on LtU
15:06:56 <psnl> ndm: I'm kinda looking for employment or a phd place
15:07:01 <shapr> "I'm right." "No, and here's why." [silence as that part of the thread is ignored by the original poster]
15:07:05 <Binkley> shapr: does LtU have anyone as crazy as qwe1234?
15:07:10 <Binkley> I haven't noticed anyone that bad
15:07:18 <shapr> Had several actually.
15:07:24 <shapr> But they got banned.
15:07:32 <monochrom> Haha nice!
15:07:34 <dons> reddit should ban qwe1234. it damages the channel
15:07:35 <Binkley> heh
15:07:50 <shapr> And there are several others who seem totally unable to understand the arguments against their points against FP.
15:07:51 <dons> make me less inclined to post, and have bad feelings about threads.
15:07:55 <ndm> psnl: you thought about York for a PhD?
15:07:57 <Binkley> does reddit ban people? I never read the site at all before this week
15:08:05 <dons> they ban spammers
15:08:08 <ndm> psnl: if its a phd, you can still soc
15:08:46 <Binkley> qwe1234 isn't trying to sell anything, though
15:09:03 <pkhuong> Binkley: I think they give my submission an automatic -1 :)
15:09:09 <shapr> feces
15:09:16 <shapr> and he's giving it away for free.
15:09:18 <Binkley> heh
15:09:19 <astrolabe> does someone have a link to the thread please?
15:09:30 <psnl> ndm: wrt york, yeah
15:09:34 <Binkley> astrolabe: http://programming.reddit.com/info/pylx/comments
15:09:37 <lambdabot> Title: Ask Reddit: Why is OCaml faster than Haskell? (reddit.com), http://tinyurl.com/y4qv6c
15:09:38 <astrolabe> thanks
15:09:54 <Binkley> it's... special.
15:10:09 <Binkley> haha, this one is excellent -- http://programming.reddit.com/info/pylx/comments/cq9oz
15:10:12 <lambdabot> Title: Ask Reddit: Why is OCaml faster than Haskell? (reddit.com), http://tinyurl.com/y45kvj
15:10:15 <ndm> psnl: in Hat? you should probably start making initial inquiries to Colin and Malcolm before christmas
15:10:23 <Binkley> nothing else really needs said anymore
15:10:36 * EvilRanter notices he apparently installed MinHugs, not WinHugs
15:10:43 * EvilRanter feels like a minor tool
15:11:04 <shapr> I have SinHugs, where everything is mutable.
15:11:11 <Philippa_> ah well, you're only one semitone from a major tool
15:11:24 <kpreid> shapr: ha
15:12:07 <monochrom> You need Absolution.
15:13:12 <shapr> Cale: I like your sledgehammer quote.
15:13:15 <psnl> ndm: I think you are right about hat needing coders, rather than more research. I keep thinking about dependent type, IO and distributed systems as a area to focus in
15:13:39 <Cale> shapr: hehe :)
15:13:49 <ndm> psnl: i think you can still do a good phd on hat, just focus on implementation and find some way to tack in some research
15:14:12 <Binkley> "focus on implementation and find some way to tack in some research" -- heh, I like that advice.
15:14:15 <EvilRanter> is it safe to install winhugs on top of minhugs?
15:14:47 <EvilRanter> 'cos the minhugs install's broken
15:14:51 <EvilRanter> *uninstall
15:14:59 <ndm> EvilRanter: yes, it is safe
15:15:08 <shapr> Wow, -30 points on a comment.
15:15:19 <Binkley> haha
15:15:44 <shapr> Man, this is like reading a transcript from the Roman gladiator games.
15:15:52 <shapr> Except qwe1234 just won't die....
15:16:26 <Binkley> heh, yes. I'm wondering how plausible it would be to write a bot that responds to comments in the style of qwe1234
15:17:02 <Binkley> like, you just need to grep for some key phrases and say "X is TEH SUCK" or "what does X have to do with Y?" and throw in a few "lawls"
15:17:17 <psnl> dons: wrt to the reddit thread, have people tried eager evaluation?
15:17:20 <shapr> His approach is completely standard. He can't argue the actual point, so he tries to find any small flaw that will stretch out the irritation.
15:17:21 <pkhuong> Binkley: long enough markov chains should do it.
15:17:29 <Binkley> pkhuong: yeah, that would probably work
15:17:47 <Binkley> psnl: I think I remember Simon PJ writing somewhere recently that it didn't work that well in practice
15:18:10 <shapr> Binkley: Whenever the bot thinks it's losing, it demands a mathematical description of expressiveness.
15:18:13 <dons> psnl: some of us have. it made ghc too complex though, so wasn't adopted
15:18:26 <psnl> Binkley: didn't he say that about laziness as well?
15:18:29 <psnl> dons: ta
15:18:31 <pkhuong> Binkley: I remember SPJ saying that if he remade haskell, it'd be strict by default.
15:18:34 <shapr> I'd like to try eager eval again though.
15:18:43 <Binkley> shapr: and then it says it can figure out what X is without writing it down formally
15:18:47 <Binkley> pkhuong: yes, I remember that too
15:18:57 <shapr> yup
15:19:01 <Binkley> though in the History of Haskell paper, they mention that a virtue of laziness is that it forces purity
15:19:03 <Cale> I would disagree with him :)
15:19:39 <Cale> Laziness is really extremely nice, and I think highly underappreciated.
15:19:43 <dons> pkhuong: really? he's famously said that 'laziness keeps us honest'
15:19:45 <SimonRC> psnl: on vega: investigate ~haskell
15:19:48 <dons> in the 'hair shirt' talk
15:20:05 <Binkley> dons: yes, but I seem to recall that in the same talk he said laziness isn't that important in and of itself
15:20:11 <Lemmih> shapr: Are you using hope with postgresql?
15:20:22 <psnl> SimonRC: I assume thats Paul's stuff?
15:20:23 <SamB> Binkley: how else are we going to be kept honest?
15:20:29 <SimonRC> psnl: dunno
15:20:32 <SamB> armed guards?
15:20:33 <shapr> I agree, I believe that laziness is much more powerful than we in the Haskell community are aware of...
15:20:37 <dons> as long as the strictness analyser is smart enough, and we hvae tools for conveniently add it (bang patterns, for example)
15:20:37 <Binkley> SamB: whips and chains? dunno
15:20:38 <shapr> Lemmih: yup
15:20:40 <dons> then we should be fine.
15:20:46 <shapr> SamB: That's for 6.8
15:20:55 <SamB> shapr: not that kind of guard, silly
15:21:12 <pkhuong> dons: an undefined evaluation order would keep you even more honest ;)
15:21:12 <shapr> They're going to look <-| and they'll throw an exception and then eat all of your memory if you break that condition.
15:21:20 <shapr> See the sword on the left?
15:21:21 <newsham> my laziness is overvalued.
15:21:30 <psnl> SimonRC: I'll ask about it tomorrow. ghc 6.6 would be nice
15:21:34 * shapr wonders if he's had too much sugar and not enough real food today...
15:21:36 <Cale> Yeah, there are points at which strictness is really important, and it's important that in those cases, strictness is easy to add, but lazy-by-default really gives rise to an entirely new style of programming which I think many people miss.
15:21:37 <SimonRC> psnl: well...
15:21:45 <Binkley> shapr: well, in my case, there's no wondering about it
15:21:49 <SamB> shapr: that won't keep us from trying to lie to, swindle, and cheat the compiler!
15:22:02 <shapr> Binkley: You want armed guards in 6.8?
15:22:20 <shapr> oh, you mean the food part..
15:22:26 <Binkley> shapr: hmm, I can think of more fun ways to enforce discipline. but maybe this is a discussion for #haskell-blah
15:22:30 <Binkley> heh, but yeah, i meant the food part
15:22:35 <Cale> haha, armed guards
15:22:36 <shapr> yipes
15:22:43 <SamB> shapr: just how many sugar lambdas have you eaten?
15:22:50 <psnl> SimonRC: actually, the whole dir is fucked
15:23:01 <dons> oh, interesting. I was talking to one of the Clean developers about why they do so well on the shootout...
15:23:01 <shapr> I just finished eating a pound of marshmallows, and I don't think I ate any food.
15:23:05 <monochrom> Thanks to lazy evaluation, Haskell has not needed a macro system for a long time.
15:23:18 <dons> and he said, "oh, we have packed arrays of bytes for strings"
15:23:31 <dons> but "haskell is faster for most other things, such as higher order functions"
15:23:45 <dons> so hmm ... yay for ByteString! only 15 years late.
15:23:50 <SamB> heh
15:23:54 <ndm> PackedString?
15:23:57 <ndm> its way old!
15:24:02 <dons> PackedString is *slow* though
15:24:07 <SamB> yeah
15:24:09 <dons> worse than [Char]
15:24:10 <SamB> pure Haskell and all
15:24:20 <ndm> performance is such an old concern
15:24:28 <dons> ndm, heh
15:24:36 <dons> ?remember ndm performance is such an old concern
15:24:39 <SamB> how long until GHC uses ByteString internally (at least sometimes?)
15:24:50 <dcoutts> SamB, what do you mean exactly ?
15:24:50 <dons> a long time?
15:24:52 <Binkley> performance is SOOOO 1998
15:24:55 <SimonRC> if performance was that important, people would be using perl, python, or the JVM
15:25:03 <SamB> well, if PackedString is so slow
15:25:09 <psnl> ndm: yeah, though its nice to have some
15:25:12 <SamB> shouldn't they use ByteString when available?
15:25:21 <dons> anyway, the point was: Clean is fast, there's no reason Haskell won't be as fast with enough packed strings
15:25:29 <dons> (for io-based micro-bechmarks)
15:25:44 <dons> this was the Clean hackers opinion, which is good to know
15:25:45 <dcoutts> SamB, you mean replacing the PackedString library? that's not too hard. It'll get done.
15:25:58 <ndm> Yhc intends to do that as well
15:26:18 <SamB> isn't Yhc using Strings?
15:26:23 <SamB> oh, no.
15:26:27 <SamB> those wierd backwards things.
15:26:37 <ndm> SamB, indeed...
15:26:42 <ndm> makes it much harder to change
15:28:17 <psnl> ndm: hat-observe. would hoogle style search be useful?
15:28:55 <ndm> psnl: what do you mean?
15:29:32 <newsham> > let sod = sum . map (read . return) . show in let tsod n = if n < 10 then n else tsod (sod n) in map (tsod . (\x -> x * x * x)) [1..100]
15:29:33 <lambdabot>  [1,8,9,1,8,9,1,8,9,1,8,9,1,8,9,1,8,9,1,8,9,1,8,9,1,8,9,1,8,9,1,8,9,1,8,9,1,8...
15:29:36 <newsham> weird!
15:29:59 * SamB wishes for a more eager :type command
15:30:16 <psnl> rather than just searching for "foo" being able to search for foo "hello" for every time foo is called with hello. hoogle style search isn't the correct term, pattern matching search might be it
15:30:18 <SamB> is there such a thing as speculative typechecking?
15:30:29 <SamB> or inference?
15:30:42 <SimonRC> How much laziness does GHC actually use, and how does this depend on the -O option?
15:30:46 <ndm> psnl: yes, definately!
15:31:08 <dons> SimonRC: you might get more out of the strictness analyser with -O
15:31:19 <SamB> SimonRC: wouldn't be using perl, python, or the JVM, you mean?
15:31:27 <newsham> > let sod = sum . map (read . return) . show in let tsod n = if n < 10 then n else tsod (sod n) in map (tsod . (^ 6) [1..100]
15:31:28 <lambdabot>  Parse error
15:31:30 <dons> but you need laziness wherever it can't be inferred that a value is always evaluated, and never bottom
15:31:33 <Binkley> IIRC, the strictness analyzer doesn't run at all unless you use -O
15:31:34 <newsham> > let sod = sum . map (read . return) . show in let tsod n = if n < 10 then n else tsod (sod n) in map (tsod . (^ 6)) [1..100]
15:31:36 <lambdabot>  [1,1,9,1,1,9,1,1,9,1,1,9,1,1,9,1,1,9,1,1,9,1,1,9,1,1,9,1,1,9,1,1,9,1,1,9,1,1...
15:31:45 <Lemmih> shapr: I have no idea what I'm doing wrong: http://blog.catenova.org/
15:31:49 <psnl> SamB: not in the back of ATTPL
15:31:52 <SimonRC> e.g., will a foldl containing nested maps, filters, and zips just evaluate to some nested loops?
15:32:12 <Binkley> SimonRC: that's more deforestation than strictness analysis
15:32:16 <Binkley> though they're related
15:32:22 <SimonRC> erm, ok
15:32:35 <SimonRC> so, will deforestaion do that for me?
15:32:44 <psnl> SimonRC: why are you asking?
15:32:44 <Binkley> it should, if you're using library functions like map/filter
15:32:47 <Binkley> not necessarily zip
15:32:52 <SamB> e.g. I might like my fundeps resolved as far as possible
15:32:53 <Binkley> GHC does some limited shortcut deforestation
15:33:01 <Binkley> but it relies on functions being defined in a restricted form
15:33:08 <SimonRC> ah
15:33:21 <Binkley> you can write your own functions using foldr/build too, of course.
15:33:24 <Lemmih> shapr: You're not using hdbc, are you?
15:33:25 <ski> > let foo [] = ($ []); foo (a:as) = (a :) . foo as . (a :); in foo [1,2,3] id
15:33:26 <lambdabot>  Couldn't match `[a] -> b' against `[a1]'
15:35:12 <ski> > let foo [] = ($ []); foo (a:as) = (a :) . foo as . (. (a :)); in foo [1,2,3] id
15:35:14 <lambdabot>  [1,2,3,1,2,3]
15:35:20 <ski> > let foo [] = ($ []); foo (a:as) = (a :) . foo as . ((a :) .); in foo [1,2,3] id
15:35:22 <lambdabot>  [1,2,3,3,2,1]
15:35:23 <psnl> assuming I use _ for "don't care" and _|_ for "didn't terminate", what could I use for "never evaluated"?
15:35:32 <osfameron> Hi, I'm having problem with the exercise: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/parser.html 3.3 ex 1
15:35:38 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/yzphh2
15:35:43 <osfameron> I have absolutely no idea how you are supposed to go about solving it
15:36:18 <osfameron> I think the approach of demonstrating cool stuff is nice, but I probably need to get the basics first, right?
15:36:19 <EvilRanter> psnl, if it's never evaluated, shurely you don't care?
15:36:32 <ski> > let foo [] = ($ []); foo (a:as) = foo as . \k -> (a :) . k . (a :); in foo [1,2,3] id
15:36:33 <lambdabot>  [3,2,1,1,2,3]
15:36:55 <psnl> EvilRanter: but I could not care about a result that has been evaled
15:37:12 <Cale> osfameron: yeah, that's the problem with that tutorial
15:37:40 <EvilRanter> psnl, as in, you $! it or something?
15:37:51 <osfameron> Cale: heh :-) I was wondering if it would make sense to skip and carry on, or if that's very much a sign to just give up now
15:37:56 <Cale> osfameron: has liftM been defined for you?
15:38:18 <Cale> liftM f x = do { v <- x; return (f v) }
15:38:27 <osfameron> Cale: kindof.  It turns the function into one which works on the value contained within a monad
15:38:47 <osfameron> ah, ok
15:38:48 <Cale> yeah -- the result of the computation, if you'd like
15:39:09 <monochrom> There is a formula relating liftM with >>=.
15:39:12 <EvilRanter> is it possible to download http://haskell.org/ghc/docs/latest/html/libraries/ (in other formats or not)
15:39:15 <lambdabot> http://tinyurl.com/hxrk7
15:39:19 <ski> parseNumber = do liftM (Number . read) $ many1 digit
15:39:29 <monochrom> hahahaha ski
15:39:40 * ski has written such many times
15:39:42 <osfameron> I think I tried that among other things :-)
15:39:45 <psnl> EvilRanter: I'm thinking about syntax for examining the results of computations
15:40:16 <ski> liftM ab ma = return . ab =<< ma
15:40:36 <osfameron> what's "ab" and "ma" ?
15:40:40 <EvilRanter> psnl, AFAIK, there's nothing standard. mebbe say "define {NA} to be an expression we don't care about the result of" or something?
15:40:56 <ski> liftM :: Monad m => (a -> b) -> (m a -> m b)
15:40:59 <ski> ab :: a -> b
15:41:02 <ski> ma :: m a
15:41:04 <edwardk> arrow from a -> b and monad of a
15:41:33 <ski> s/monad/monadic action/
15:41:34 <dylan> psnl: ()?
15:41:45 <Cale> I'd probably have just used f and x :)
15:42:04 <Cale> liftM f x = x >>= return . f
15:42:10 <monochrom> ab is the muscle in your ab. ma is your ma.
15:42:22 <osfameron> hmm, I just tried the "obvious" do transformation and it worked this time
15:42:25 <ski> liftM f x = x >>= f >.> return
15:42:26 <ski>   where
15:42:33 <ski>   (>.>) = flip (.)
15:42:53 <osfameron> oh, it's because I was trying to include the liftM rather than realising that the liftM was converted into a do
15:42:55 <psnl> dylan: that might do
15:43:12 <dolio> ?type >>>
15:43:14 <lambdabot> parse error on input `>>>'
15:43:18 <dolio> ?type (>>>)
15:43:20 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
15:43:26 <dylan> Ugghhh
15:43:44 <dylan> Slang's low-level getkey function does something naughty to signals.
15:43:50 <dolio> ?type ((>>>) :: (b -> c) -> (c -> d) -> (b -> d))
15:43:52 <lambdabot> forall b c d. (b -> c) -> (c -> d) -> b -> d
15:44:00 <Cale> osfameron: at some point, I *really* am going to write a proper tutorial, I promise :)
15:44:09 <ski> liftM f ma = `(f ,ma)  -- hypothetical
15:44:13 <monochrom> mee too
15:44:39 <scodil> if you have a mutable data structure, like an IOArray or HashTable, and you get a list of its elements with toList or getElems, that list is necessarily written out to memory in its entirety, right? because something might mutate the array/table before the list is read? right?
15:45:25 <Cale> There's no Haskell tutorial which I'm completely happy with. Too many of them try to hide typeclasses from you for too long, and the treatments of IO are usually either too late or way too early, and often there's a lot of confusion about what data declarations mean.
15:46:01 <osfameron> yay!
15:46:04 <osfameron> thanks Cale, ski
15:46:28 <osfameron> I've now managed to transform an expression I don't understand into another 2 similar expressions that I don't understand, and which I haven't tested to see if they work
15:46:36 <osfameron> but at least they compile.  So I'm calling this progress.
15:46:40 <Cale> hehe
15:46:41 <psnl> scodil: if it helps, I'm a wimp, and don't use things like IORefs since I can't even imagine how they work
15:46:49 <ski> Cale : 'a lot of confusion about what data declarations mean' example of what you mean ?
15:46:55 <Cale> osfameron: Have you seen my quick intro to IO in Haskell?
15:46:56 <Heffalump> psnl: you've never used an imperative language?
15:47:01 <SimonRC> Hmm, Google isn't being too helpful on this, so I am asking here:  Has any work been done on the possibility that threads communicating using channels are Arrows, or that threads that compute for some time then return an answer are Monads?
15:47:26 <dcoutts> scodil, that's right.
15:47:30 <osfameron> Cale: yeah, the best thing I've seen so far is School of Expression on printed tree, but I've not got anything I'm happy with electronically.
15:47:37 <osfameron> Cale: url?
15:47:44 <Cale> ski: Well, particularly in YAHT, I think the examples and exercises provided have confused a lot of people. We get people asking about the Quad exercise regularly.
15:48:08 <psnl> Heffalump: ok, that should have been "I can't imagine how they work with the rest of haskell"
15:48:17 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
15:48:20 <lambdabot> Title: Introduction to IO - HaskellWiki, http://tinyurl.com/ft8nk
15:48:39 <osfameron> I love in YAHT the sentence "Now obviously the first thing you want to do is to remove the IO" when it hasn't even been explained what the problem is, and you're not thinking that at all...
15:48:44 <Heffalump> psnl: ah :-)
15:48:45 <ski> psnl : you can think of them as integer indices, that refer into a state that is passer around, under the monad
15:48:47 <Cale> there's a quick introduction to how IO works in Haskell -- IO is possibly the worst example of a monad :)
15:49:23 <SamB> does anyone have any "units" or "dimensional analysis" code laying around I could borrow?
15:49:26 <ski> psnl : you can easily make a monad that supports allocating new cells, but only of a fixed type
15:49:40 <Cale> There's also my Monads as Containers article. I was sort of hoping that someone would write a Monads as Computations article in a similar spirit, but I imagine I'll have to write it myself :)
15:49:54 <psnl> ski: thanks
15:50:05 <ski> psnl : do you see what i mean =
15:50:08 <SimonRC> psnl: they are like first-class mutable variables.  They solve the occasional (e.g. Python) problem where a function mutates an existing global rather than creating a local of the same name, or vice-versa.
15:50:09 <ski> s/=/?/
15:50:47 <Heffalump> psnl: do you understand the concept of a state monad?
15:50:55 <psnl> Heffalump: yes
15:51:07 <psnl> ski: yes
15:51:09 <scodil> is there a function (a,(b,c)) -> (a,b,c) ?
15:51:25 <SamB> scodil: what for?
15:51:33 <scodil> isn't it obvious?
15:51:41 <SamB> no
15:51:41 <Heffalump> psnl: ok, then just thinking of an IORef as a pointer, and the IO monad as a state monad passing around the entirety of memory, is fairly simple, surely
15:51:45 <scodil> in this case, zipping and mapping and whatnot
15:51:49 <SamB> I have no idea what you'd want with an (a,b,c)
15:51:52 <Cale> scodil: \(a,(b,c)) -> (a,b,c)
15:52:10 <ski> (psnl : so the 'IORef's actually themselves don't contain any data .. only in conjunction with the current state can you get at the data .. also this explains why "pointer equality" of 'IORef's aren't problematic)
15:52:35 <ski> @djinn (a,(b,c)) -> (a,b,c)
15:52:35 <lambdabot> f (a, (b, c)) = (a, b, c)
15:52:46 <psnl> Heffalump: yeah
15:53:07 <psnl> Heffalump: I'm switching the C coding bit of my brain back on
15:53:40 <EvilRanter> @pl \x -> uncurry ((,,) x)
15:53:41 <lambdabot> uncurry . (,,)
15:53:50 <EvilRanter> scodil, there you go
15:54:00 <ski> readIORef (IORef n) = IO (\state -> (state ! n,state))
15:54:04 <ski> (very roughly)
15:55:06 <scodil> thanks,  but thats almost as long as what cale said, and so much more confusing to look at
15:55:47 <ski> @type uncurry . (,,)
15:55:48 <lambdabot> forall a b a1. a1 -> (a, b) -> (a1, a, b)
16:03:01 <psnl> dang, hat-observe already has that feature
16:08:55 <SamB> @hoogle assert
16:08:57 <lambdabot> Control.Exception.assert :: Bool -> a -> a
16:08:57 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
16:08:57 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
16:17:08 <mast> I'm trying to install Hashell (http://www.haskell.org/hashell/) on a system where I don't have administer access. I've installed Cabal-1.1.6.1 but the old 1.0 is still there and I tried to hide it: package.conf: harp-0.2, haskell-src-exts-0.2, altdata-0.9.10, hi-0.9.10, plugins-0.9.10, (Cabal-1.0), Cabal-1.1.6.1. I run 'runhaskell Setup.hs configure' and get a lot of Error: module 'Distribution.Simple.LocalBuildInfo' is ex
16:17:10 <lambdabot> Title: Hashell :: Home Page
16:17:34 <mast> are there any solutions to this? if I can't unregister the 1.0 one
16:17:39 <dons> hmm. Maybe LocalBuildInfo is not in Cabal anymore?
16:17:55 <dons> could you try Cabal 1.14.x ?
16:18:34 <mast> yes
16:18:37 <mast> will try
16:20:05 <mast> dons: do you mean 1.1.4?
16:22:53 <EvilRanter> > curry (curry (,,))
16:22:54 <lambdabot>  Add a type signature
16:22:58 <EvilRanter> @type curry (curry (,,))
16:23:00 <lambdabot> forall a b b1 b2 c. a -> b -> b1 -> b2 -> c -> (((a, b), b1), b2, c)
16:23:05 <EvilRanter> hm
16:23:20 <EvilRanter> @type uncurry (uncurry (,,))
16:23:22 <lambdabot> forall a b b1. ((a, b), b1) -> (a, b, b1)
16:23:58 <dons> mast: yeah
16:25:48 <ptolomy> Anyone know why only one of the Shootout haskell implementations is GHC6.6?
16:26:26 <dolio> Because 6.6 isn't current on gentoo yet?
16:27:14 <dolio> packages.gentoo.org doesn't even list it as available yet, it seems.
16:27:20 <Itkovian> any people here familiar with profilers? and papers talking about them?
16:27:22 <dolio> Even hard masked.
16:27:35 <Itkovian> not necessarily haskell related
16:27:49 <dons> ptolomy: oh, one of them's been updated to 6.6!?
16:27:49 <ptolomy> So one is a custom build or wrong, I guess.
16:27:50 <dons> url please!
16:28:02 <dolio> Doesn't one run debian?
16:28:09 <dons> there's a debian and a gentoo box
16:28:16 <ptolomy> http://shootout.alioth.debian.org/sandbox/haskell.php
16:28:16 <dons> ?shootout
16:28:18 <ptolomy> sandbox.
16:28:19 <lambdabot> Title: Haskell GHC benchmarks | Debian : AMD&#8482; Sempron&#8482; The Sandbox, http://tinyurl.com/yf9hdp
16:28:19 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:28:29 <dons> oh, sandbox. ok
16:28:37 <EvilRanter> @pf \f (a, b, c) -> f a b c
16:28:38 <lambdabot> Maybe you meant: bf pl
16:28:43 <EvilRanter> @pl \f (a, b, c) -> f a b c
16:28:44 <lambdabot> (line 1, column 9):
16:28:44 <lambdabot> unexpected ","
16:28:44 <lambdabot> expecting letter or digit, operator or ")"
16:28:44 <lambdabot> ambiguous use of a non associative operator
16:29:24 <EvilRanter> er
16:29:33 <dons> ok well!
16:29:41 <kpreid> EvilRanter: @pl doesn't understand anything but 2-tuples
16:29:42 <dons> if 6.6 is on the machine, we should start hacking!
16:29:45 <EvilRanter> meh
16:30:15 <dons> ptolomy: since there's bytestrings to be had!
16:30:50 <ptolomy> Woo!
16:31:05 <dylan> dons: sooo... even low-level getkey functions do something naughty with signals...
16:31:13 <dons> oh hmm
16:31:15 <ptolomy> I suspect regex-dna will clean up nice.
16:31:19 <dons> yep
16:31:31 <dons> now, let me find the shootout page
16:31:35 <EvilRanter> @pl \f (x, y) -> f x y
16:31:36 <edwardk> oh whoa, we get to use bytestrings for shootout stuff now? =)
16:31:37 <lambdabot> (`ap` snd) . (. fst)
16:31:42 <dolio> How about Fasta? That one's kind of embarassing. :)
16:31:49 <EvilRanter> um.
16:31:50 <ptolomy> edwardk:  Sorta. It is on one of the sandbox machines.
16:32:17 <dons> http://www.haskell.org/haskellwiki/Great_language_shootout
16:32:20 <lambdabot> Title: Great language shootout - HaskellWiki, http://tinyurl.com/tgujz
16:32:35 <dons> dolio: yeah, so fasta, knuc, regex-dna should all kick butt now
16:32:45 <dons> so get hacking guys!
16:32:51 <dons> time your program against the currently submitted one
16:33:01 <dons> if its faster, add it to the wiki
16:33:05 <dolio> Ah, that's good. 16 times slower and 5xx times more memory use than Ocaml is kind of bad. :)
16:33:15 <edwardk> heh
16:33:18 <dons> its an artifact of using the wrong data type for strings
16:34:37 <sethk> dons, I lot your url about haskell commercial uses
16:34:53 <sethk> dons, I've been kind of backed up, and I wrote myself a note to contribute to it, but I left the url out of the note.  :)
16:35:14 <dons> ah good.
16:35:22 <dons> please add anything you feel is relevant
16:36:18 <dons> ptolomy, dolio: i've mailed Isaac, the maintainer of the gentoo shootout box, to see if we should start submitting 6.6 code yet.
16:36:34 <sjanssen> dons: have any of the shootout benchmarks already been written for ByteString?
16:37:07 <dolio> The state of the art should be on the wiki, right?
16:37:12 <dylan> dons: it seems that all functions that can be interupted by a signal which is haskell code need to have 'safe' rather than 'unsafe' in their foreign import...
16:37:47 <ski> EvilRanter : cool
16:38:00 <EvilRanter> er?
16:38:07 <ski> @type uncurry . uncurry $ (,,)
16:38:09 <lambdabot> forall b a b1. ((a, b1), b) -> (a, b1, b)
16:38:18 <ski> hadn't thought of that
16:40:00 <sjanssen> @. pl djinn ((a, b1), b) -> (a, b1, b)
16:40:00 <lambdabot> f = uncurry (uncurry (,,))
16:43:16 <sjanssen> what is the deal with the "alternative program" for fasta?  http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=all
16:43:20 <lambdabot> Title: fasta benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language Sh ..., http://tinyurl.com/r4kxg
16:43:52 <mast> dons: it says Error: module xxsdfag is exposed by package Cabal-1.0 and package Cabal-1.1.4 (about 20 different modules) it seems a bit unhappy because there are two Cabal registered (even though the 1.0 one is hidden)
16:44:11 <mast> perhaps i'll have to install it on my own computer anyway.. where i can unregister the old cabal for good
16:45:04 <dons> yeah maybe. you won't be able to hide 1.0 if you don't have root access, (I think)
16:45:18 <dons> or you may have to specify cabal-1.1.4 explicitly
16:45:26 <dons> sjanssen: alternatives are ones that are interesting but illegal
16:45:34 <sjanssen> I see
16:45:46 <dons> sjanssen: also, we have 1 or 2 that have been ported to bytestring (sum-file, I think)
16:45:57 <dons> *and* we don't have to worry about line length now
16:46:05 <dons> so we should go for elegance (and bang patterns for strictness)
16:46:13 <sjanssen> I'm going to try fasta
16:46:17 <dons> great!
16:46:37 <mast> dons: yes, it is possible to specify 1.1.4? or will i have to specify that in every module that uses cabal?
16:46:37 * dcoutts thinks we can automatically ByteString'ise ordinary IO followed by string code
16:46:48 <dcoutts> with clever definitions and fusion
16:47:59 <dcoutts> for example, we should be able to do the example from the into to our PADL paper
16:48:14 <dons> yes
16:48:54 <dcoutts> basically, change Syetem.IO.hGetContents into fmap unpack ByteString.hGetContents
16:48:54 <dons> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019427.html
16:48:56 <lambdabot> Title: [Haskell-cafe] Great language shootout: reloaded, http://tinyurl.com/yyvqh4
16:49:04 <dons> dcoutts: hmm!
16:49:27 <dcoutts> then fuse the ordinary list consuming functions with the ByteString.unpack
16:49:42 <dons> yep
16:49:44 <dcoutts> for the example: fold . map . filter, that'd do the whole thing
16:50:50 <mast> i give up, but thanks anyway. good night
16:57:40 <edwardk> @paste
16:57:41 <lambdabot> http://paste.lisp.org/new/haskell
16:59:12 <ptolomy> dang, using regex for replacing stuff isn't as easy as I'd hoped.
16:59:54 <dons> make sure you're using the fast bytestring-based regex, too.
17:00:09 <dons> we can talk to TuringTest about this, since he wrote the code, he knows which is fastest
17:00:30 <Botty> woohoo
17:00:31 <Botty> *Main> englishNumber 1000000000000000000000000000000000000000000000544
17:00:31 <Botty> "one octillion, five hundred and fourty four"
17:01:10 * SamB implemented the min/max method with an MPTC with fundeps
17:01:26 <SamB> hmm...
17:01:34 <SamB> oh, no, can't do that...
17:02:19 * SamB was wondering if he could move the unit stuff outside of the MinMax constructor, but realised that MinMax isn't a Num instance...
17:02:31 <lisppaste2> edwardk pasted "for dons" at http://paste.lisp.org/display/29589
17:02:37 <Botty> ptolomy - yeah, regex is generally misused.  Applied to problems too big for it
17:03:17 <dons> edwardk: ok. harmless
17:03:24 <dons> edwardk: fixed in darcs
17:03:29 <dons> use the darcs version :)
17:03:34 <edwardk> downloading that now
17:03:38 <edwardk> just went for the quick fix =)
17:05:15 <edwardk> botty: when the only tool you have is a hammer...
17:06:06 <Botty> yeah, thats why you've gotta learn to use another tool, or make your own tool
17:06:42 <mauke> don't use a tool; be the tool!
17:07:18 <edwardk> or is it that by just using the tool, you are the tool? =-)
17:07:46 <Botty> yes, I think its by using the tool you're a tool
17:08:05 <monochrom> "If you're not part of the hammer, you're part of the nail."
17:08:05 <Igloo> dons: If you're doing a 6.6 pass over the shootout stuff, it would be great if you could highlight any cases where you have to write unboxed code, use the IO constructor etc rather than GHC generating the best code itself
17:08:24 <dons> yep.
17:08:28 <monochrom> "Don't be a fool.  Be a tool."
17:08:30 <dons> I want to avoid that entirely this time around
17:08:44 <dons> Igloo: so I'll document anything that goes wrong
17:09:10 <Igloo> dons: How does sandbox differ, BTW?
17:09:12 <dons> mmm... DPH anyone: "CUDA-enabled GPUs offer dedicated features for computing, including the Parallel Data Cache, which allows 128, 1.35GHz processor cores in newest generation NVIDIA GPUs to cooperate with each other while performing intricate computations."
17:09:20 <dons> Igloo: I think its a separate machine?
17:09:45 <dons> i've mailed isaacg about it
17:10:12 <Igloo> Cool
17:10:57 <Igloo> Hmm, we have 854 times gcc's memory usage on fasta.
17:11:01 * Igloo smells a memory leak
17:11:34 <dons> sjanssen: so you're rewriting fasta to :: ByteString
17:11:36 <dons> ?
17:11:51 <sjanssen> yeah
17:12:08 <dons> good. i wonder if we can exploit any smp rts games with chameneos et al
17:12:39 <Botty> *Main> americanNumber (10^100)
17:12:39 <Botty> "ten duotrigintillion"
17:13:03 <Botty> *Main> europeanNumber (10^100)
17:13:03 <Botty> "ten sexdecilliard"
17:13:28 <dcoutts> dons, are there smp benchmarks in the shootout ?
17:13:32 <sjanssen> dons: is there a darcs repo with all the shootout entries?
17:13:42 <dons> dcoutts: there's 2 or 3 concurrency benchmarks
17:13:51 <dcoutts> dons, I mean parallelism
17:13:54 <dons> which might be a win on even a single hyperthreaded box with 2 OS threads.
17:13:56 <dons> no. there isn't
17:14:07 <dcoutts> we should try and persuade them to add some :-)
17:14:14 <dons> someone said its because "no mainstream languages support paralleism well enough"
17:14:17 <dons> hmmm!
17:14:26 <dons> I could submit something like the DPH parallel matrix product test
17:14:33 <dons> or the parallel Barnes-Hut
17:14:46 <dcoutts> watch the poor C coders use pthreads
17:14:54 <dons> crash and burn, you mean?
17:14:55 <mauke> $ perl -wle 'print "1", "0" x 100' | ausschreib
17:14:55 <mauke> zehn sexdezilliarden
17:15:12 <Botty> hah cool
17:15:21 <dcoutts> dons, you can point out that Java is mainstream and it supports threads, which is enough for parallelism right? :-)
17:15:26 <dons> sjanssen: be sure to check the ocaml, clean and sml entries too
17:15:33 <dons> dcoutts: mm. yes.
17:15:48 <dons> i think they'd be quite open to a proper parallelism test
17:16:28 <Botty> I'm really worried about the fact that euro and american numbers vary so much. 10 billion and up is different between the two
17:16:53 <Botty> technically bill gates is a milliardaire
17:17:21 <zptao> no, he isn't
17:17:42 <SamB> how about we just say "damn rich"
17:18:05 <zptao> hes given over $30 billion dollars to charity
17:18:13 <zptao> that equals about 14 billion euros or so
17:18:38 <dons> zptao: how's the haskell hacking coming along?
17:18:41 <dons> you've got ghc installed yet?
17:18:42 <Igloo> dons: Can you explain the "-- we have to match the imperative version instead of using the Haskell idiom" comment in http://shootout.alioth.debian.org/sandbox/benchmark.php?test=fasta&lang=ghc&id=0 ?
17:18:45 <lambdabot> Title: fasta Haskell GHC program | Debian : AMD&#8482; Sempron&#8482; The Sandbox, http://tinyurl.com/smcyh
17:18:46 <Botty> right, and according to the document I've got, according to european standard an american billion is a milliard
17:18:52 <zptao> dons: yes, and haskell doesn't seem very interesting
17:19:04 * Igloo can't find a spec that requires it
17:19:05 <dons> why are you hanging out here then?
17:19:06 <SamB> see, we should use SI units for money
17:19:14 <zptao> just watching
17:19:17 <Botty> SamB - yeah, should use SI unites for everything
17:19:42 <dons> Igloo: mm. it might be obsolete
17:20:47 <Igloo> dons: I also can't find much of a spec at all. Is this it? http://shootout.alioth.debian.org/sandbox/benchmark.php?test=fasta&lang=all#about
17:20:48 <dons> > fix ((0:) . scanl (+) 1) -- a challenge, zptao. write this in your favourite language
17:20:50 <lambdabot> Title: fasta benchmark | Debian : AMD&#8482; Sempron&#8482; The Sandbox, http://tinyurl.com/yes5gg
17:20:50 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:21:16 <dons> Igloo: at the bottom of, http://shootout.alioth.debian.org/sandbox/benchmark.php?test=fasta&lang=all
17:21:18 <lambdabot> Title: fasta benchmark | Debian : AMD&#8482; Sempron&#8482; The Sandbox, http://tinyurl.com/yes5gg
17:21:20 <zptao> dons: don't know what that does
17:21:20 <dons> so yes.
17:21:33 <dons> generates an infinite fibonacci series
17:21:38 <Igloo> OK; it doesn't seem very self-contained, that's all  :-)
17:21:48 <dons> Igloo: yeah.
17:21:54 <zptao> ah yes dons, i was directed to those benchmarks earlier
17:22:05 <zptao> dons: it falls to the bottom of the pile on almost all the other tests
17:22:20 <dons> zptao: that's not true. please check more accurately.
17:22:44 <zptao> show me otherwise
17:24:27 <Igloo> dons: Do we know what inputs they use?
17:24:36 <dons> Igloo: yeah, the 5M fasta file, iirc
17:24:49 <dons> it should specify it on the page showing how the haskell entry was compiled
17:24:56 <dons> let me see if i can find an input file for you..
17:25:13 <zptao> only languages i've seen it beat is lua and Erlang
17:25:15 <zptao> still looking
17:25:20 <sjanssen> ruh roh
17:25:25 <dons> zptao: http://shootout.alioth.debian.org/sandbox/benchmark.php?test=all&lang=all
17:25:28 <lambdabot> http://tinyurl.com/ycoslq
17:25:34 <Igloo> dons: The input is just a number, isn't it?
17:25:37 <dons> zptao: note february's results: http://www.cse.unsw.edu.au/~dons/data/haskell_1.html
17:25:39 <lambdabot> Title: Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/y9754m
17:25:43 <dons> Igloo: ah yes. maybe.
17:25:44 <pkhuong> dons: remember what you said wrt trolls?
17:25:48 <dons> fasta generates the big data files
17:25:51 <dons> pkhuong: yes. ok :|
17:25:55 <zptao> did pretty well against perl
17:26:24 <sjanssen> Data.ByteString.Char8 exports the wrong cycle in GHC 6.6
17:27:07 <dons> sjanssen: hmm? I thought we got that fixed.
17:27:54 <Igloo> Ah, n is given at the top
17:30:01 <dons> yep
17:31:01 <sjanssen> dons: maybe I've got something wrong?  What does ghci tell you the type of Data.ByteString.Lazy.Char8.cycle is?
17:31:40 <Igloo> [a] -> [a] here
17:31:52 <dons> hmm Data.ByteString.Lazy.Char8.cycle :: [a] -> [a]
17:32:08 <dons> Prelude> :t Data.ByteString.Lazy.cycle
17:32:08 <dons> Data.ByteString.Lazy.cycle :: Data.ByteString.Lazy.ByteString -> Data.ByteString.Lazy.ByteString
17:32:21 <dons> yep, so looks like a wrong export. *I thought we'd fixed that* grr
17:32:45 <dons> nope. its indeed the wrong export.
17:32:47 * dons patches fps
17:32:59 <hyrax42> does that need to go to 6.6 as well?
17:33:04 <dons> it would do
17:33:11 <dons> (I guess)
17:33:34 <hyrax42> is anyone working on shootout entries with fps now?
17:33:45 <Igloo> dons: If bytestring isn't bundled with 6.8, would that mean you'd have to revert all the benchmark stuff, BTW?
17:33:48 <sjanssen> hyrax42: I'm hacking on fasta
17:33:56 <hyrax42> what's the other slow one?
17:34:07 * ptolomy started on regex-dna, but has to go home and sucks so someone else should give it a go.
17:34:16 <SamB> Igloo: surely someone could rig up a "deluxe bundle"!
17:34:29 <hyrax42> ?where shootout
17:34:30 <lambdabot> http://shootout.alioth.debian.org/
17:35:02 <dons> Igloo: we'd need it installed
17:35:23 <Igloo> dons: But do you know if they'd be willing to do that?
17:37:10 <dons> Igloo: I don't know. Hopefully they'd at least install the extralibs
17:37:19 <dons> we're moving bytestring out of base now?
17:38:15 <Igloo> No particular plan to, but it would make sense if there's no reason for it to be there
17:38:38 <Igloo> It would mean you could fix incorrect exports asynchronously, for example  :-)
17:39:14 --- mode: ChanServ set +o dons
17:39:24 --- mode: dons set +b *!*i=topaz@*.dsl.pltn13.pacbell.net
17:39:25 --- kick: zptao was kicked by dons (trollin on #haskell and #perl6)
17:39:27 --- mode: ChanServ set -o dons
17:39:54 <dons> i checked the logs. zero non-troll contributions here and perl6 :| in fact, extremly inflammatory
17:40:04 <dons> why do people do this :(
17:40:18 <psnl> oh, I just thought you were trying to earch bastard points
17:40:22 <psnl> dons: free fun
17:40:37 <EvilRanter> damn griefers
17:40:41 <edwardk> @seen dcoutts
17:40:42 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 25m 21s ago.
17:41:01 <edwardk> @paste
17:41:02 <lambdabot> http://paste.lisp.org/new/haskell
17:41:31 <lisppaste2> edwardk pasted "c2hs build issue" at http://paste.lisp.org/display/29590
17:41:44 <hyrax42> wait a sec
17:41:50 <dons> total contribution then: 06.05.23:22:56:42 <squiggly> bye prudes  :(
17:41:51 <hyrax42> was there previously no regex library?
17:41:59 <dons> yeah, Text.Regex *slow*
17:42:09 <dons> so we ported the lexer combinator lib
17:42:11 <dons> and use that
17:42:18 <hyrax42> so it was *faster* for regex-dna to implement its own?
17:42:19 <hyrax42> wow
17:42:21 <dons> then Chris went and wrote the whole new Text.Regex.*
17:42:29 <dons> based on what we did for regex-dna
17:43:47 <hyrax42> so the current library is pure haskell?
17:44:10 <dons> yeah
17:44:17 <dons> though there's ffi backends
17:44:22 <dons> i.e. Posix, and PCRE, iirc
17:44:29 <hyrax42> hm
17:44:46 <hyrax42> performance-wise how do they compare?
17:44:47 <ademan> is there no GNU haskell compiler?
17:44:54 <SamB> hahahah
17:44:54 <dons> gnu-licensed?
17:45:10 <dons> there's severa free haskell compilers, I recommend GHC
17:45:19 <dons> ademan: http://haskell.org has al the details
17:45:21 <dolio> GNU isn't hip enough to make a haskell compiler. :)
17:45:23 <lambdabot> Title: Haskell - HaskellWiki
17:46:53 <dons> sjanssen: so you worked around cycle by importing the .Lazy one?
17:47:11 <sjanssen> dons: yeah
17:47:24 <dons> (basically i'd exposed both the Prelude and .lazy cycle)
17:47:31 <dons> when i should have hidden the prelude one
17:48:43 <Igloo> dons: Hmm? If you expose both and export it then you should get a compile-time error
17:48:57 <dons> my fault, didnt' expose .Lazy.cycle
17:49:27 <dons> and QuickCheck doesn't handle infinite structures well, so there was no .Lazy.cycle == .Lazy.Char8.cycle property :|
17:49:55 <dons> Prelude> :t Data.ByteString.Lazy.Char8.cycle
17:49:55 <dons> Data.ByteString.Lazy.Char8.cycle :: Data.ByteString.Lazy.ByteString
17:49:55 <dons>                                     -> Data.ByteString.Lazy.ByteString
17:49:56 <Igloo> Can't you have take n of both sides?
17:49:57 <dons> fixified
17:50:03 <dons> Igloo: you'd have to do that, yes.
17:51:05 <hyrax42> it seems to me regex-dna wouldn't benefit too much from fps?
17:51:24 <hyrax42> unless the fps IO is a lot quicker, which it may well be
17:51:37 <dons> it is, and the regexes are way faster
17:51:42 <hyrax42> but to use regex you need to go to [Char] anyway?
17:51:46 <dons> regexes based on zero-copying bytestrings.
17:51:49 <hyrax42> oh there are regexes on bytestrings?
17:51:50 <dons> hyrax42: why?
17:52:00 <hyrax42> ?hoogle match
17:52:01 <lambdabot> Language.Haskell.TH.match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
17:52:02 <dons> there are regexes on bytestrings, Text.Regex.Posix.ByteString, iirc
17:52:02 <lambdabot> Data.Graph.Inductive.Graph.match :: Graph gr => Node -> gr a b -> Decomp gr a b
17:52:02 <lambdabot> Language.Haskell.TH.Match :: Pat -> Body -> [Dec] -> Match
17:52:13 <hyrax42> dons: I did not know that
17:52:16 <dons> hoogle doesn't know about 6.6 libs yet.
17:52:28 <hyrax42> ?karma hoogle
17:52:29 <lambdabot> hoogle has a karma of 2
17:53:49 <moconnor> Why is fix in Control.Monad?
17:53:59 <moconnor> IOW, what does it have to do with Monads?
17:54:31 <dons> ?type mfix
17:54:34 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
17:54:46 <dons> i guess it was added when mfix and MonadFix went in
17:55:01 <dons> so might be in slightly the wrong place (like how Monad (-> a) was in the wrong place)
17:55:04 <dons> hysterical reasons
17:55:33 <moconnor> oh, ok.  That's simple enough :)
17:55:47 * monochrom screams hysterically
17:56:36 <hyrax42> ?hoogle interact
17:56:37 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
17:56:38 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
17:56:38 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
17:56:47 <hyrax42> ?docs prelude
17:56:48 <lambdabot> prelude not available
17:56:54 <hyrax42> ?docs Prelude
17:56:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:56:59 <psnl> hyrax42: whats the problem?
17:57:12 <hyrax42> just want to read description of it
17:57:44 <hyrax42> so roughly
17:57:53 <LPhas> ?hoogle runProcess
17:57:54 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
17:58:00 <psnl> it lazily reads from stdin, processes it, and writes the result out to stdout
17:58:07 <hyrax42> interact f = getContents >>= liftM f >>= putStr
17:58:19 <hyrax42> ?
17:58:20 <LPhas> ?hoogle runCommand
17:58:21 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
17:58:27 <Igloo> @index iterate'
17:58:27 <lambdabot> bzzt
17:58:31 <monochrom> Yeah.
17:58:34 <dons> dcoutts: did you see a patch from ross or malcolm re. data.bytestring and portability in the last few days?
17:58:35 <LPhas> ?hoogle wait
17:58:36 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
17:58:36 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
17:58:36 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
17:58:46 <dons> i can't seem to find it on the cvs-all list
18:00:50 <dons> hey dibblego
18:01:03 * dons thinks nobody@wireless-031.wireless.cse.unsw.EDU.AU is an interesting address
18:01:04 <dibblego> g'day
18:01:16 <dibblego> :)
18:01:29 <dons> i can even ping it!
18:01:33 <dibblego> lol
18:01:49 * dons dares to try ssh... nobody@wireless-031.wireless.cse.unsw.edu.au's password:
18:01:53 <dons> doh
18:02:09 <lambdabot>  @karma- dons
18:02:12 <dibblego> yeah I'm running ssh at TCP/22
18:02:17 <monochrom> try "nobody" for the password
18:02:36 <dons> Permission denied, please try again. :)
18:02:55 <dons> does that show up in your logs, dibblego ?
18:03:12 <dibblego> I don't think I am logging SSH connections
18:05:26 <hyrax42> well I guess it's time to install 6.6
18:05:32 <hyrax42> yay for overnight compiles
18:05:42 <dibblego> sshd_config reckons I am logging but I see nothing in /var/log/syslog
18:06:12 * hyrax42 wishes haddock could link to definition in source
18:06:21 <dons> dibblego: /var/log/messages ?
18:06:28 <hyrax42> though that would be complicated in face of ifdefs
18:06:40 <dibblego> dons, nup
18:08:57 <EvilRanter> I've got a data Foo = Foo { ... }, but then, when I say bar = Foo {...}, I get Undefined data constructor "Foo". ideads?
18:11:28 <kpreid> Are those in separate modules, and if so, are you exporting the constructor as well as the type?
18:12:03 <EvilRanter> they're in seperate modules
18:12:10 <EvilRanter> how do you export two things with the same name?
18:12:20 <EvilRanter> (other than missing out the export list)
18:12:25 <kpreid> Types' constructors are exported as Foo(Foo) or Foo(..)
18:13:18 <EvilRanter> thanks, that solved it
18:13:28 <EvilRanter> kpreid ++
18:13:33 <psnl> karma
18:18:54 <dons> kpreid++
18:19:24 <dibblego> #haskell and ##java are such a contrast
18:19:35 <chessguy_away> not as much as #haskell and ##java
18:19:37 <dons> ah, reminds me to find you that paper , dibblego
18:19:37 <LPhas> ?hoogle sleep
18:19:38 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
18:19:42 <chessguy_away> err, #haskell and ##c++
18:19:42 <LPhas> uhm
18:19:50 <dibblego> dons, cheers mate, I'd be very interested
18:20:09 <kpreid> ?index threadDelay
18:20:10 <lambdabot> GHC.Conc, Control.Concurrent
18:20:12 <kpreid> LPhas:
18:20:21 <LPhas> ?
18:20:34 <kpreid> that's probably what you want
18:21:11 <LPhas> kpreid : let's see
18:21:52 <dons> dibblego: there's a little here http://cgi.cse.unsw.edu.au/~cs3161/06s1/lectures/Week08/DataStructures_online.pdf
18:21:54 <lambdabot> http://tinyurl.com/y24en4
18:21:58 <dibblego> thanks mate
18:22:03 <ademan> i can't say i've totally got my head around functional programming yet, and i realize that some things are harder than others in imperative vs functional programming.  But is there anything you CAN'T do in functional programming that you can in imperative? (i mean things like, creating a GUI (pretending the libraries exist) )
18:22:08 <Igloo> Hmm, is there a pleasant way to do    let (x, y) = splitAt bigNumber as; print $ foo xs; print $ bar ys   without leaking memory?
18:22:28 <dons> how big is 'as' ?
18:22:30 <dons> what type?
18:22:36 <Igloo> infinite
18:22:54 <Igloo> The problem is that y holds on to the first bigNumber elements of as while foo is running
18:23:03 <dons> hmm
18:23:08 <kpreid> will ~(x,y) help?
18:23:14 <kpreid> er, oh
18:23:27 <Igloo> It's already a lazy binding
18:23:46 <LPhas> kpreid: mmh i need to stop the "main" process for some seconds, threadDelay doesn't seems to work
18:23:55 <kpreid> how about ys `seq` xs?
18:24:12 <kpreid> getting the head of ys should be sufficient?
18:24:22 <Igloo> That would instantly use bigNumber memory
18:24:32 <kpreid> hm
18:24:36 <kpreid> ah
18:24:44 * dons noticed his machine suddnely went wacky, and then realised, "oh, rewrite rules and linking" 213M  123M sleep    biowai   0:58 29.64% ghc-6.4.2
18:24:53 <kpreid> I think you need to replace splitAt
18:25:32 <LPhas> oh, MICROseconds
18:25:39 <Igloo> Oh, forcing no sharing hasn't helped. I wonder if the internals have been CAFed
18:26:10 <Igloo> No, they can't have been
18:27:52 <monochrom> hehehe yeah I also got the time units of threadDelay wrong for a while
18:36:50 <lennart> good evening
18:37:23 <EvilRanter> mornin'
18:37:56 <dons> hey lennart
18:38:35 <complaisant> hi
18:38:46 <dons> hello, complaisant
18:38:49 <dons> welcome
18:38:51 <complaisant> im having problems in installing happy.. :|
18:38:53 <complaisant> tnks
18:38:57 <complaisant> happy is not happy today
18:38:59 <complaisant> :P
18:39:01 <dons> heh
18:39:07 <dons> maybe you need 'frown'?
18:39:12 <dons> :)
18:39:30 <monochrom> make frown
18:39:52 <dons> ?where frown
18:39:53 <lambdabot> I know nothing about frown.
18:39:54 <complaisant> whats frown?
18:39:55 <dons> oh.
18:40:07 <dons> complaisant: oh, just a little joke. its another parser generator, like happy
18:40:14 <dons> so, what's your unhappy happy trouble?
18:40:15 <dons> ?paste
18:40:16 <lambdabot> http://paste.lisp.org/new/haskell
18:40:19 <complaisant> LALR.lhs:626:34: Not in scope: `bounds'
18:40:20 <dons> you can paste any errors ^^
18:40:25 <dons> ah ok
18:40:29 <dons> that's fixed in happy's darcs repo
18:40:39 <dons> (there's also a tarball up with the fix, I think)
18:40:41 <Igloo> There's an RC tarball too
18:40:55 <Igloo> http://haskell.org/happy/happy-1.16rc2.tar.gz
18:41:04 <dons> Igloo is too fast for me
18:41:16 <complaisant> \o/ :D
18:41:41 <dibblego> dons, that paper implies the following emulation of Maybe in Java: interface Maybe<T>{T get();} // returns null for Nothing
18:41:53 <dons> the lecture slides?
18:41:56 <dibblego> dons, I consider this solution deficient such that it is not even worth using
18:42:09 <dibblego> yes
18:42:09 <dons> yeah, let me see if i can track down the real paper, then.
18:44:29 <dibblego> in Java, you cannot sub-type a class that has only private constructors* - since all types must invoke their super-type's constructor *except for nested types - this results in the ability of creating a type with a finite (in this case 2) number of sub-types
18:44:46 <dons> actually, googling "'sum types' in java" turns up a few more hits
18:44:50 <dibblego> ok
18:45:02 <dons> http://tinyurl.com/yau5q8
18:45:05 <lambdabot> Title: "sum types" in java - Google Search
18:45:24 * dylan curses at SLang_getkey
18:45:29 <dons> heh
18:45:50 <dylan> if I run ltrace, it works fine.
18:46:09 <dylan> so I can't find what the heck SLang_getkey is doing to require sending to SIGINTs.
18:46:22 <dylan> and if I never call that function it works fine!
18:46:48 <complaisant> where do i install the file.. ? sry about the lemme question.. loL! i was installing happy with darwinport in my mac osx.. so i dont really know where it installs stuff..
18:47:50 <dibblego> dons, I found paper that says the solution is to use ML :)
18:47:54 <dons> heh
18:47:58 <dons> that's a good solution!
18:48:28 <dibblego> I'm quite convinced that there is no solution and that the one I have found is it
18:48:35 <dibblego> as in a best case scenario
18:48:45 <dons> heh. ok. you could ask for advice on haskell-cafe@haskell.org
18:48:51 <dons> sounds like a nice type puzzle for people to play
18:48:52 <dibblego> ok thanks
18:49:16 <dibblego> I might finish the article first, so that I have an answer to propose :) it took me a *long* time to figure out
18:49:24 <dibblego> hope it takes everyone else just as long
18:50:09 <Smokey`> hmm, shouldn't "let !pixels = (renderScene resolution (RRT 8 8) camera scene)" evaluate renderScene immediately?
18:50:18 <dibblego> and in fact, I have a trivia question on my website that most people get wrong - and you would have to know the right answer to it to even begin considering it as a potential solution
18:50:31 <dons> would be good to compare against the other solutions you've seen , pointing out where they fail
18:50:54 <dibblego> http://jqa.tmorris.net/GetQAndA.action?qids=17 most people answer true to that
18:50:58 <lambdabot> Title: Java Questions and Answers - private Constructors, http://tinyurl.com/uyekf
18:51:00 <dons> Smokey`: it'll evaluate pixels before evaluating renderScene..
18:51:04 <dibblego> yeah I will - sounds like an article on its own though
18:51:14 <dons> but then, Smokey` pixels isn't used in that code?
18:51:26 <dibblego> I will go through the usual steps of reasoning that everyone typically goes through - then highlight the deficiency in each
18:51:36 <Smokey`> dons: no, I just want to force the evaluation of renderScene, for profiling purposes. (without using the data)
18:52:37 <dons> ah, sorry, my mistake
18:52:44 <dons> i thought i was looking at a function defn, not a let binding
18:52:53 <Igloo> Things that should not affect time and memory use #264: map id
18:53:03 <dons> Igloo: heh
18:53:11 <dons> we don't have a rewrite rule for that though...
18:53:23 <dons> so it would be up to the inlining, I guess
18:53:30 * dons inspects the core ..
18:54:09 <Igloo> dons: OK, a small constant factor I'd accept, but it shouldn't make the difference between a leak and no leak
18:54:33 <dons> so your map is going to turn into a build/foldr almost straight away
18:55:04 <dons> yep, and in fact, ghc won't remove map id
18:55:15 <dons> it'll get written back to : map id at the end
18:58:12 <dibblego> hey dons is there a taxi rank on campus? I have to leave at 1700 sharp - at the end of the last talk - and I can't see any on the UNSW maps
18:59:07 <carp> greetings from across the room...
18:59:26 <dons> there's no taxi rank, but you can generally get taxis from high street or anzac parade
18:59:30 <dibblego> ok ta
18:59:34 <dons> just down from the high street bus stop
18:59:43 <dibblego> excellent thanks
18:59:50 <Pseudonym> Taxi operators assume that uni students are too poor to afford taxis.
19:00:25 <dino-> >filterM (const [True,False]) "abc"
19:00:37 <dino-> > filterM (const [True,False]) "abc"
19:00:40 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
19:00:57 <dino-> I saw this here yesterday. I've been puzzling over it for a while tonight but can't understand how it does that.
19:01:33 <gzl> woah, weird.
19:01:34 <dons> list monad
19:01:36 <monochrom> How is filterM defined?
19:01:43 <dons> ?type filterM
19:01:45 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
19:01:52 <dino-> Looking at the filterM source, I see: flg <- p x
19:01:57 <SamB> @. djinn type filterM
19:01:59 <lambdabot> Cannot parse command
19:02:00 <dons> filterM _ []     =  return []
19:02:00 <dons> filterM p (x:xs) =  do
19:02:00 <dons>    flg <- p x
19:02:00 <dons>    ys  <- filterM p xs
19:02:01 <dons>    return (if flg then x:ys else ys)
19:02:03 <dino-> Where the p is the (const [True,False])
19:02:11 <SamB> @help djin
19:02:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:02:15 <SamB> @help djinn
19:02:16 <lambdabot> djinn <type>.
19:02:16 <lambdabot> Generates Haskell code from a type.
19:02:17 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
19:02:21 <SamB> hmm.
19:02:24 <dons> SamB: no way djinn was ever going to work out a monadic function
19:02:30 <SamB> dons: true, true.
19:02:37 <dino-> Ok, so the Bool value here is [True,False], how is it possible for the if statement to eval that as true or false?
19:02:39 <SamB> though it wouldn't really be hard.
19:02:41 <SamB> would it?
19:02:57 <monochrom> [True,False] :: m Bool
19:02:59 <SamB> it would just have to treat it like a GADT or something.
19:03:41 <EvilRanter> how would one read lines from stdin into a list until you hit the first empty line?
19:03:48 <dino-> Inside this do bloc, the m (in this case list) is being removed from the True,False ?
19:03:59 <dino-> :/  confusing
19:04:00 <EvilRanter> I've got something similar to "until ((not . null . head) <<=) (getLine :) []"
19:04:04 <EvilRanter> (but that doesn't work)
19:04:21 <monochrom> do { x <- [True,False] ;  g x }  == g True ++ g False
19:04:38 <SamB> @undo do { x <- [True,False] ;  g x }
19:04:39 <lambdabot> [True, False] >>= \ x -> g x
19:06:12 <dons> good idea SamB
19:06:14 <dibblego> is there an XML parser that is approxiately ByteString -> SomeTreeType ?
19:06:26 <dons> haxml, I think
19:06:30 <dons> has bytestring support now
19:06:55 <dons> we need an @inline
19:06:56 <dibblego> right, I was just thinking of the function from "list of stuff" to a "tree of stuff like XML"
19:06:59 <SamB> dons: well, I couldn't help but be reminded of audreyt's AST Monad -- that was audreyt's, wasn't it?
19:07:04 <dons> which takes an expression, and inlines all the monad bind definitions
19:07:06 <dibblego> @inline to do memoisation?
19:07:07 <lambdabot> Unknown command, try @list
19:07:12 <dibblego> oh
19:07:16 <dons> SamB: AST?
19:07:34 <dino-> Ah, that explains kind of a lot, that the g applied to the list is really g applied to each element.
19:08:36 <monochrom> Yes.
19:08:49 <SamB> i.e. data ASTMonad where Return :: a -> ASTMonad a; (:>>=) :: ASTMonad a -> (a -> ASTMonad b) -> ASTMonad b; --etc.
19:09:18 <SamB> dons: see, it just builds an AST
19:09:24 <SamB> instead of running anything
19:09:45 <Botty> hmm, is there a haskell implementation designed to have particular nice/elegant implementation of haskell?
19:09:46 <monochrom> [ if flg then x:ys else ys | flg <- [True,False], ys <- filterM ... xs ]
19:10:02 <skew> Botty: EHC, maybe
19:10:49 <skew> the plan is to write a really elegant implementation, I don't know how far along it is
19:11:34 <dino-> So, the if is a function, it's performing the test on each element of that [Bool] ?
19:11:51 <Botty> skew - sweet, thanks
19:11:55 <monochrom> the if is the usual if-then-else
19:12:08 <monochrom> Sometimes flg is True.  Sometimes flg is False.
19:13:03 <SamB> is that what the E stands for?
19:13:06 <SamB> Elegant?
19:13:09 <skew> Essential?
19:13:16 <Botty> http://www.cs.uu.nl/wiki/Ehc/WebHome#Download
19:13:16 <monochrom> Edible
19:13:19 <SamB> dons: do you get it?
19:13:20 <lambdabot> Title: Ehc / Web Home
19:13:21 <Botty> a bunch of things
19:14:51 <dons> Essential Haskell Compiler, iirc
19:15:07 <Pseudonym> Existential
19:15:26 <Pseudonym> Rather than follow the language spec, it's free to define its own reality.
19:16:39 <revision17> Are there any really stable and complete linear algeba libraries for haskell (and which run on windows without a hitch)?
19:16:41 <monochrom> filterM (const [True,False]) "c" = [ if flg then 'c':ys else ys | flg <- [True,False], ys <- [] ] = ['c':[], []] = ["c", ""]
19:16:58 <revision17> the ones I saw were lacking in features or didn't want to build
19:17:12 <revision17> or were abandoned years ago
19:17:23 <Botty> hmm, I don't see how there could be a hitch with linear algebra on windows..
19:17:27 <dino-> Ok, thank you.
19:17:37 <monochrom> filterM (const [True,False]) "bc" = [ if flg then 'b':ys else ys | flg <- [True,False], ys <- ["c",""] ] = ["bc","b","c",""]
19:17:45 <monochrom> And so on.
19:18:31 <monochrom> List comprehension and List monad coincide.  Very beautiful.
19:18:49 <revision17> Botty: I know the windows thing isn't a big issue with this.  But if it uses some C/Fortran library that isn't already built for me, I'd rather not have to do it myself
19:19:11 <skew> revision17: what are you trying to do?
19:19:17 <Botty> oh, good point
19:19:23 <dons> monochrom: well, list comps are just monad comprehensions for the list monad :)
19:19:31 <monochrom> Yes.
19:19:33 <dons> we just happen to only have comprehensions over just that one monad atm.
19:19:38 <dons> which is a bug!
19:19:52 <SamB_XP> well, someone was authorized to regeneralize them
19:19:56 <revision17> skew: matrix arithmetic, back/forward substitution, matrix factorizations, etc, all that good stuff
19:20:00 <SamB_XP> as an *optional* feature
19:20:09 <skew> revision17: I'm not sure there are any really fast libraries
19:20:10 <revision17> I like haskell more than matlab, so I'm trying to find a lib to use it instead
19:20:15 <SamB_XP> hopefully *not* implied by -fglasgow-exts
19:20:17 <revision17> Speed is not an issue
19:20:25 <sjanssen> @pl (\s -> Just (chooseBase bf (normalize s), nextSeed s))
19:20:26 <lambdabot> Just . ap ((,) . chooseBase bf . normalize) nextSeed
19:20:28 <revision17> (unless it's ungodly slow)
19:20:28 <SamB_XP> hmm, I've brought up a strange graph in Media Player Classic...
19:20:49 <skew> revision17: mostly things you type in by hand? or bigger data sets?
19:20:49 <pkhuong> revision17: how about incorrect?
19:21:05 <revision17> skew: yea, just stuff I type in by hand
19:21:07 <pkhuong> I hear it's easy to get things wrong w/ badly conditioned matrices.
19:22:01 <revision17> pkhuong: it has to be accurate within a reasonable amount.  A matrix lib which utilizes a CAS for it's operations would be most ideal
19:22:01 <skew> I know Frederik Eaton has been working on his library fairly recently
19:22:11 <revision17> but not required
19:23:46 <skew> I guess GHC is all tied together
19:24:40 <EvilRanter> @paste
19:24:41 <lambdabot> http://paste.lisp.org/new/haskell
19:24:52 <skew> A little program that just dumps dependency information is only 200k smaller that GHC itself
19:25:15 <lisppaste2> EvilRanter pasted "is there an easier way to do this?" at http://paste.lisp.org/display/29593
19:25:51 <sjanssen> @hoogle eof
19:25:52 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
19:25:53 <lambdabot> Text.Read.EOF :: Lexeme
19:25:53 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
19:26:03 <sjanssen> @hoogle iseof
19:26:04 <lambdabot> IO.isEOF :: IO Bool
19:26:04 <lambdabot> IO.isEOFError :: IOError -> Bool
19:26:04 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
19:26:05 <EvilRanter> it's not EOF, it's reading to a blank line
19:26:14 <sjanssen> ah
19:26:56 <dolio> fmap lines getContents ?
19:27:14 <skew> Can you get dot to draw very high-degree nodes with the children staggered, rather than making them microscopic to fit them in a horizontal line?
19:27:37 <dolio> Or fmap (takeWhile (not . null) . lines) getContents
19:28:04 <EvilRanter> I want to read the other lines later, so the first wouldn't work... would the second not read in the lines after the "\n\n"?
19:28:36 <dolio> I'm not really sure.
19:28:38 <skew> you want to read them in strictly? HTTP header?
19:29:01 <EvilRanter> no, I want to get a bunch of lines into this list, then get some more lines to somewhere else
19:29:10 <EvilRanter> I explicitly _don't_ want to read strictly
19:29:19 <EvilRanter> 'cos that'd devour the rest of input
19:29:19 <skew> well, your code is reading them strictly
19:29:30 <skew> I mean lines up to the blank line
19:29:49 <skew> you want to read up to the blank line before returning?
19:29:55 <EvilRanter> i mean, I don't want to (id $! getContents)
19:29:58 <EvilRanter> or anything
19:30:10 <EvilRanter> but yes, I want to read up to the blank line, then return
19:30:36 <EvilRanter> @type fmap
19:30:38 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
19:30:43 <dibblego> how does one effectively find a function definition in the GHC source? I looked for foldr in base/List.hs GHC/List.hs to no avail - where is it?
19:30:59 <EvilRanter> dibblego, try the prelude?
19:31:02 <skew> dibblego: I've been using grep -R
19:31:11 <EvilRanter> or that
19:31:23 <sjanssen> grepping for things that are in the first column tends to be effective
19:31:26 <dibblego> skew, yeah, but I could do that, though some of the source is gzipped
19:31:29 <dibblego> EvilRanter, I will
19:31:36 <Pseudonym> Is there a ctags for Haskell?
19:31:39 <SamB_XP> zgrep!
19:31:41 <sjanssen> you can also get hasktags to generate a TAGS file
19:31:45 <Pseudonym> Thanks!
19:31:46 <skew> there's a tags target in the GHC makefile
19:31:48 <SamB_XP> "make tags", maybe
19:31:51 <dibblego> I do not see it in Prelude.hs
19:31:59 <skew> but it doesn't seem to find everything
19:32:02 <SamB_XP> try GHC.Base
19:32:05 <skew> dibblego: are you looking in the library sources?
19:32:11 <dibblego> skew, yes
19:32:12 <sjanssen> Pseudonym: there's also a patch to exuberant ctags that is much nicer
19:32:23 <skew> I think :info in ghci will usually tell you the original module
19:32:43 <dibblego> ah thanks!
19:32:51 <skew> doesn't seem to list the package, though
19:33:19 <SamB_XP> skew: I think we knew what package foldr was in, thanks ;-)
19:33:29 <Pseudonym> Once you've worked it out, write a lambdabot plugin.
19:34:39 <EvilRanter> @pl \(x:xs) -> (x,xs)
19:34:40 <lambdabot> liftM2 (,) head tail
19:34:46 <EvilRanter> hm
19:35:47 <EvilRanter> > splitAt 1 "asdf"
19:35:49 <lambdabot>  ("a","sdf")
19:35:53 <EvilRanter> hm
19:36:01 <SamB_XP> @pl splitAt 1 "asdf"
19:36:02 <lambdabot> splitAt 1 "asdf"
19:36:48 <EvilRanter> is there no standard fn for (x:xs)->(x,xs)?
19:37:27 <monochrom> No.
19:37:49 <monochrom> > head &&& shoulder "ab"
19:37:50 <lambdabot>  Not in scope: `shoulder'
19:37:54 <sjanssen> @pl \xs -> (head xs, tail xs)
19:37:55 <monochrom> > head &&& tail "ab"
19:37:55 <lambdabot> liftM2 (,) head tail
19:37:56 <lambdabot>  Couldn't match `(->) [a]' against `[]'
19:38:01 <EvilRanter> &&&?
19:38:16 <monochrom> > (head &&& tail) "ab"
19:38:17 <lambdabot>  ('a',"b")
19:38:32 <EvilRanter> @hoogle &&&
19:38:33 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
19:39:02 <EvilRanter> oookay. it's nice an' all, but I think i'll leave arrows well alone
19:39:15 <monochrom> Think of it as (b->c) -> (b->c') -> (b -> (c,c'))
19:39:28 <EvilRanter> yes, that figures. sounds reminiscent of join
19:39:43 <monochrom> Pretend "a b c" means "b->c".  Actually it's very close to the truth.
19:39:44 <EvilRanter> (in a manner of speaking)
19:39:53 <Pseudonym> ?hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
19:39:54 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:40:12 <Pseudonym> That's the last place you'd look for that.
19:40:18 <monochrom> "Arrow" simply means generalize -> to some other things, such as impure functions.
19:40:33 <EvilRanter> right...
19:40:56 <EvilRanter> so there's, fehrinstance, an instance Arrow (a -> b)
19:41:00 <EvilRanter> ?
19:41:06 <monochrom> Yes
19:41:07 <Pseudonym> Arrow (->)
19:41:10 <Pseudonym> But yes.
19:41:23 <Pseudonym> You can think of (a -> b) as ((->) a b)
19:41:27 <EvilRanter> of course, the higher order type...
19:41:30 <Pseudonym> Taking the operator section of arrow.
19:41:36 <dons> dibblego: foldr is fundamental, so its in GHC.Base
19:41:45 <dons> (its needed to define a fusable map)
19:41:53 <EvilRanter> fusable?
19:41:57 <dons> yeah
19:42:01 <Pseudonym> Shortcut deforestation.
19:42:01 <araujo> hello around here
19:42:10 <dons> map f . map g ==> map (f . g ) via rewrite rules
19:42:17 <Pseudonym> And foldr/bind too.
19:42:21 <EvilRanter> de...forest...ation... ooookay
19:42:23 <dons> foldr/build, yeah
19:42:26 <Pseudonym> Yeah.
19:42:40 <dons> "map"       [~1] forall f xs.   map f xs        = build (\c n -> foldr (mapFB c f) n xs)
19:42:43 <dons> "mapList"   [1]  forall f.  foldr (mapFB (:) f) []  = map f
19:42:45 <dons> "mapFB"     forall c f g.   mapFB (mapFB c f) g = mapFB c (f.g)
19:42:47 <Pseudonym> Right.
19:43:01 <EvilRanter> my brain has retreated under a rock and gone into hiding
19:43:08 <sjanssen> > foldr (+) 0 $ map (*2) $ filter odd [1..1000] -- in this example, GHC won't make any list cells
19:43:10 <lambdabot>  500000
19:43:24 <dons> sjanssen: how's fasta going?
19:43:27 <EvilRanter> @type join
19:43:29 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
19:43:32 <Pseudonym> EvilRanter: "deforestation" is the process of removing trees.
19:43:44 <sjanssen> EvilRanter: when you have a pipeline of list functions, sometimes the compiler can remove those intermediate lists
19:43:45 <EvilRanter> heh. nice. i think i know what it means, too
19:43:46 <dons> (I found it would take 2-3 hours or more to get a faster version, last time I worked on the shootout)
19:44:05 <EvilRanter> (well, i was close :P)
19:44:17 <sjanssen> dons: right now I'm wishing that there was a Data.ByteString.Lazy.unfoldrN
19:44:45 <sjanssen> because in one case it's nice to use take n . cycle
19:45:17 <skew> hey, I threw together a dependency-graphing program with the GHC api
19:45:22 <sjanssen> and output would be chunked
19:45:24 <skew> any idea where I should put it?
19:45:30 <sjanssen> with lazy that is
19:45:31 <dons> oh, compiling ghc is probably going to be bad for my battery life, right?
19:45:45 <dons> ok.
19:46:02 <dons> Igloo: btw, i have patches for cycle, and the Maybe a instances failing in the testsuite
19:46:02 <sjanssen> I need unfoldrN to get a random seed out at the end
19:46:06 <dons> i'll push them after a build.
19:46:13 <dons> sjanssen: hmm. interesting
19:46:24 <dons> so you're completely rewriting the solution? good!
19:46:48 <sjanssen> not quite, but close
19:47:06 <Igloo> dons: OK, thanks
19:48:20 <sjanssen> the reason the submitted solution sucks is that in generates a list with all the random numbers in it, then uses splitAt to supply sections of numbers to each output case
19:48:30 <dons> ah right
19:48:37 <dons> nasty
19:48:44 <sjanssen> so it absolutely eats memory
19:48:49 <dons> yup
19:49:04 <dons> musasabi: are you still able to commit to the shootout cvs?
19:49:29 <sjanssen> there's a fast entry on the wiki, but it looks like ass because it uses pokes and hButBuf
19:49:50 <sjanssen> so I'm hopeful that I can write a version that is as fast as the wiki one, but as pretty as the submitted one
19:50:43 <dons> yes. this is what we should aim for in "shootout reloaded" :)
19:50:53 <dons> since we know the fast-and-dirty methods well enough now
19:51:45 <dons> hmm. Binoids, eh?
19:52:16 <dons> ah, Cale's machine is dead. so no Cale?
19:52:29 <lisppaste2> skew annotated #29593 with "with ListT" at http://paste.lisp.org/display/29593#1
19:54:19 <edwardk> does anyone know if c2hs has some weird problem building under 6.6 or something?
19:55:05 <dons> hmm. the fasta entry seems to have reintroduced a space leak
19:55:16 <dons> i wonder if list fusion broke or something?
19:55:25 <dons> fasta used not to be so bad
19:55:38 <lisppaste2> skew annotated #29593 with "simple" at http://paste.lisp.org/display/29593#2
19:55:51 <dons> unless an entry was disqualified?
19:56:19 <dons> since i'm almost certain I wrote a fast-and-nasty version
19:56:32 <dons> ah, indeed!
19:56:45 <dons> :/
19:56:53 <Igloo> dons: I'm fairly sure the momery is the sharing problem I mentioned earlier
19:57:02 <dons> 2.0   Haskell GHC #3          3.69            2,208         1390
19:57:08 <dons> yeah
19:57:14 <dylan> it works!
19:57:25 <dons> but we shouldn't be using the current entry, since that's the original entry
19:57:29 <dons> we have much better solutoins since then
19:57:29 <alex777> I am a haskell beginner, just wanted to put that out there
19:57:35 <dylan> dear lord! I spent all day trying to make it respond to SIGINT!!
19:57:44 <dons> so why was this disqualified, http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=ghc&id=3 ?
19:57:45 <edwardk> welcome to the channel alex777
19:57:47 <lambdabot> Title: fasta Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ..., http://tinyurl.com/y2726u
19:57:49 <alex777> I am trying to divide 2 Ints and I can't
19:57:53 <dons> ah, "Preconverting to Int is a really interesting approach - we're looking for the vanilla
19:57:57 <dons> approach."
19:58:02 <mauke> alex777: a `div` b
19:58:08 <edwardk> > 9 `div` 4
19:58:10 <lambdabot>  2
19:58:16 <alex777> but I want the result to be Double
19:58:28 <alex777> I did div and it gives me Int as result
19:58:34 <dons> sjanssen: so you're looking at the fast-but-marginally-wrong version?
19:58:38 <alex777> so 5 `div` 2 is 2
19:58:40 <mauke> > fromIntegral 9 / fromIntegral 4
19:58:42 <lambdabot>  2.25
19:58:56 <edwardk> > fromIntegral 9 / 4 -- bah mauke beat me =)
19:58:58 <lambdabot>  2.25
19:59:11 <alex777> let me try that
19:59:13 <edwardk> @type (/)
19:59:15 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:59:17 <edwardk> @type div
19:59:19 <lambdabot> forall a. (Integral a) => a -> a -> a
19:59:32 <dons> one issue is to never point out slightly dodgy things you do in the shootout
19:59:32 <alex777> does lambdabot evalute haskell ?
19:59:33 <sjanssen> dons: the one under "Current best entry" at http://www.haskell.org/haskellwiki/Shootout/Fasta
19:59:36 <lambdabot> Title: Shootout/Fasta - HaskellWiki, http://tinyurl.com/vznau
19:59:38 <edwardk> yeah
19:59:43 <alex777> sweet :)
19:59:45 <dons> since anything in a comment is seized on by the enemies to disqualify an entry
19:59:51 <sjanssen> dons: which is different than the disqualified one, I think
19:59:54 <dylan> How would I pass NULL as a FunPtr in haskell?
20:00:05 <skew> I suppose adding special purpose fusion rules to GHC is dodgy?
20:00:05 <dibblego> let foldr' _ x [] = x; foldr' f x (y:ys) = y `f` (foldr' f x ys) -- is that right?
20:00:09 <edwardk> dons: which you just immortablized on a publicly logged channel =)
20:00:12 <dons> ?hoogle nullPtr
20:00:13 <lambdabot> Foreign.Ptr.nullPtr :: Ptr a
20:00:14 <edwardk> er immortalized
20:00:23 <dons> edwardk: that's fine.
20:00:31 <dons> skew: to your libraries, that's fine.
20:00:37 <dons> as long as theyre provably correct...
20:00:39 <dylan> there's a nullFunPtr, I see.
20:00:40 <mauke> dylan: nullFunPtr
20:01:08 <Botty> add special purpose commands in the compiler for each of the shootout problems....
20:01:09 <dons> sjanssen: ah, "Current best entry (Haskell GHC #3)
20:01:10 <dons> "
20:01:12 <dylan> is it possible to get a FunPtr from a haskell function?
20:01:17 <dons> looks like the one that was disqualified
20:01:27 <alex777> I suck at this :/
20:01:30 <dons> dylan: yeah
20:01:35 <dons> ?hoogle FunPtr
20:01:36 <lambdabot> Foreign.Ptr.FunPtr :: data FunPtr a
20:01:36 <lambdabot> GHC.Exts.FunPtr :: Addr# -> FunPtr a
20:01:36 <lambdabot> Foreign.Ptr.castFunPtr :: FunPtr a -> FunPtr b
20:01:43 <alex777> is 1 line of code paste ok ?
20:01:48 <dons> yep
20:01:52 <dons> more stuff goes here:
20:01:54 <dons> ?paste
20:01:55 <lambdabot> http://paste.lisp.org/new/haskell
20:01:58 <alex777> mean xs = sum [ fromIntegral x / fromIntegral length(xs) | x <- xs ]
20:02:03 <Pseudonym> Anything under the McQuarry limit is usually fine.
20:02:04 <mauke> dylan: AFAIK yes
20:02:09 <Botty> I do 3 line pastes at a max
20:02:13 <mauke> you need to declare a foreign wrapper for it
20:02:15 <Pseudonym> ?google McQuarry limit
20:02:17 <dylan> dons: woot, good. to catch control-c, with slang it's nesecary to use SLang_set_signal_abort.
20:02:19 <lambdabot> http://en.wikipedia.org/wiki/Alt.fan.warlord
20:02:20 <alex777> what's wrong with that ?
20:02:21 <sjanssen> dons: ah, so it is
20:02:24 <mauke> alex777: parens
20:02:29 <dons> > let mean xs = sum [ fromIntegral x / fromIntegral (length xs) | x <- xs ] in mean [1..100]
20:02:31 <lambdabot>  50.5
20:02:33 <mauke> alex777: (length xs), not length xs
20:02:39 <alex777> oh
20:02:41 <dylan> dons: the benefit being it'll work on MSDOS too. Does haskell even work there? No, right? But still!
20:03:01 <alex777> sucess ! :)
20:03:03 <Pseudonym> Gofer runs just fine under MS DOS.
20:03:10 <Botty> > let mean xs = sum [ fromIntegral x / fromIntegral $ length xs | x <- xs ] in mean [1..100]
20:03:11 <lambdabot>  add an instance declaration for (Fractional (Int -> b))
20:03:11 <dons> Gofer++
20:03:11 <lambdabot>   In the definiti...
20:03:16 <Botty> arg
20:03:27 <dylan> Gofer?
20:03:31 <mauke> pwnd by $
20:03:33 <dons> > let mean xs = sum [ fromIntegral x / genericLength xs | x <- xs ] in mean [1..100]
20:03:35 <lambdabot>  50.5
20:03:44 <dons> ?pl \x -> fromIntegral x / genericLength xs
20:03:45 <lambdabot> (/ genericLength xs) . fromIntegral
20:04:02 <dons> > let mean xs = sum . map ((/ genericLength xs) . fromIntegral) in mean [1..100]
20:04:04 <lambdabot>  Add a type signature
20:04:08 <alex777> genericLength ?
20:04:14 <mauke> > let mean xs = sum xs / fromIntegral (length xs) in mean [1..100]
20:04:16 <lambdabot>  50.5
20:04:17 <dons> ?type genericLength
20:04:19 <Botty> I must say, haskell's precedence stuff is disappointing
20:04:20 <lambdabot> forall i b. (Num i) => [b] -> i
20:04:39 <alex777> ?type length
20:04:41 <lambdabot> forall a. [a] -> Int
20:04:48 <dons> > let mean xs = sum xs / genericLength xs in mean [1..100]
20:04:50 <lambdabot>  50.5
20:04:52 <Botty> alex777 - doesn't really matter, alot of the time here you'll ask about something and people will mess around until they get the best solution
20:04:55 <mauke> > let mean = liftM2 (/) sum (fromIntegral . length) in mean [1..100]
20:04:57 <lambdabot>  50.5
20:04:59 <dons> ?pl \xs -> sum xs / genericLength xs
20:04:59 <lambdabot> liftM2 (/) sum genericLength
20:05:07 <mauke> huhu
20:05:12 <dons> > let mean = liftM2 (/) sum genericLength in mean [1..1000]
20:05:14 <lambdabot>  500.5
20:05:23 <alex777> well since I'm new to haskell, if it works, I'm happy :)
20:05:25 <Botty> alex777 - best meaning most elegant/small/idiomatic
20:05:35 <alex777> since I just took on haskell today
20:05:45 <dons> alex777++ great!
20:05:48 <Botty> heh, yep, the clear solution is probably best, especially if you're just learning
20:05:58 <dons> > let mean xs = sum xs / genericLength xs in mean [1..100] -- is good
20:06:00 <lambdabot>  50.5
20:06:01 <Botty> yeah, you're doing very well if you're at list comprehensions :)
20:06:23 <alex777> actually I find lists great :)
20:06:39 <mauke> @type scanl
20:06:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
20:06:47 <Botty> yeah, they're pretty sweet
20:07:10 <mauke> ok, so scanl is just a leaking fold
20:07:24 <alex777> I see how   mean xs = sum xs / genericLength xs
20:07:25 <dons> heh, yeah
20:07:26 <alex777> is better
20:08:07 <alex777> I just did it using the sigma notation from math 1/n (from n to i) n
20:08:27 <alex777> strike that, ends in i not n
20:09:02 <dons> cool. its nice you can just translate
20:09:21 <mauke> understanding sigma notation is much easier if you know what a for loop is :-)
20:09:37 <alex777> it actually makes more sense in haskell then the other langs I use
20:09:45 <Botty> sigma = summation right?
20:09:49 <alex777> yea
20:09:52 <Botty> ok
20:09:56 <alex777> 1/n (from n to i) x
20:09:59 <alex777> that is it
20:10:09 <dons> sigma = flip map -- ;)
20:10:24 <dons> s/for/
20:10:30 <Botty> ?type flip
20:10:32 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
20:10:37 <dons> ?type flip map
20:10:39 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
20:10:44 <dons> ?let for = flip map
20:10:46 <lambdabot> Defined.
20:10:57 <alex777> time to take on a median function, I'll ask for help if I need it :)
20:11:03 <dons> > L.for [1..10] $ \x -> show x
20:11:05 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
20:11:17 <merus> That's cute.
20:11:20 <alex777> what does $ do ?
20:11:28 <alex777> I haven't seen it in the stuff I read
20:11:30 <lennart> ?type flip flip flip
20:11:32 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
20:11:32 <dons> > L.for [1..10] (\x -> show x) -- parens
20:11:34 <edwardk> $ is like a set of patens starting at the $ running to the end
20:11:35 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
20:11:38 <edwardk> er parens
20:11:39 <SamB> alex777: it doesn't do *anything*
20:11:45 <edwardk> @type ($)
20:11:47 <lambdabot> forall b a. (a -> b) -> a -> b
20:11:49 <dons> SamB: not helpful :)
20:11:51 <Botty> it's syntax sugar
20:11:52 <SamB> well, besides change the parsing ;-)
20:12:09 <Botty> I didn't like it at first, but it grew on me
20:12:18 <mauke> alex777: f $ g $ x = f (g x)
20:12:19 <edwardk> its like a very low precedence function application, keeps you out of lots of parens
20:12:29 <SamB> I'm leaning towards thinking they associate wrong, though
20:12:34 <alex777> I see
20:12:37 <skew> dons: do you think there's a point to making something like ByteString.Lazy from a catenable dequeue?
20:12:46 <dons> its haskells solution to avoiding scheme/lisp finger nail clippings of DEATH
20:12:52 <SamB> skew: that would, um, not be lazy?
20:12:56 <edwardk> heh
20:12:57 <dons> skew: hmm
20:13:02 <merus> dons: well said.
20:13:21 <dons> :)
20:13:23 <mauke> dons: http://mauke.ath.cx/stuff/lisp/add-x.lisp http://mauke.ath.cx/stuff/lisp/implinest.lisp
20:13:49 <lennart> catenable de-queues tend to have a rather high constant factor
20:14:19 <dons> mauke: nice!
20:14:22 <SamB> lennart: don't they also tend not to make very good lazy streams at all?
20:14:50 <dons> all those lambda/funcalls look like compiled Haskell core :)
20:14:59 <lennart> SamB: now that's something i will leave unsaid.  i don't know
20:15:00 <dons> that's not usual coding style, is it, mauke ?
20:15:32 <mauke> it was translated from perl: http://mauke.ath.cx/stuff/perl/add.pl
20:15:34 * SamB doesn't understand mapS
20:15:57 <mauke> it adds two integers using bitwise ops and a loop
20:16:01 <dons> SamB: oh! there's a paper.
20:16:06 <SamB> yeah.
20:16:10 <dons> i think i'd like the data Stream a = ... type on a tshirt
20:16:25 <SamB> but the paper doesn't seem to explain mapS
20:16:28 <mauke> except the loop is done with recursion, the whole thing is curried/lambdified, then converted to CPS
20:16:34 <dons> SamB: what's hard about it?
20:16:49 <Botty> dons - what's the diff between a stream and a list?
20:16:56 <skew> SamB: the idea isn't so much to make them lazy, as to get concatenation and stuff without much copying
20:16:58 <SamB> oh, I think I get it now
20:17:26 <dons> Botty: oh, streams aren't anything to do with lists. SamB is just confusing everyone
20:17:38 <sjanssen> dons: I've got a version that's about 50% slower than the cheating one
20:17:46 <dons> sjanssen: ok. good.
20:17:50 <skew> cheating?
20:17:51 <SamB> dons: in general a list is rather like a stream
20:17:51 <dons> i bet we can do better... :)
20:17:54 <Botty> lol.  seems to me like streams would be the same thing
20:17:59 <SamB> I mean, like a general stream
20:18:15 <skew> Botty: sometimes, streams are defined without the base case
20:18:19 <SamB> this paper about using streams for fusion, though, defines a very particular kind
20:18:39 <SamB> which is quite different from a list
20:18:42 <dons> I think maybe people are confusing the data Stream that samB is talking about , with some notion of lazy streams ..
20:18:48 <Botty> hmm
20:18:57 <dons> its an overloaded phrase.
20:19:01 <Botty> yes
20:19:04 <SamB> yes, I'm sorry for talking about too many things at the same time
20:19:07 <SamB> ;-)
20:20:06 <dons> don't confuse people, SamB. clarity is everything. :)
20:20:10 <SamB> but, I persist in believing that you can't use catenable dequeues to implement lazy bytestreams... I mean bytestrings...
20:20:24 <dons> i'm not sure. i don't know if anyone knows yet.
20:20:33 <dons> got a data type to show me?
20:20:45 <SamB> I was under the impression that those things were supposed to be somewhat *balanced*
20:20:49 <dons> (you can persist in believing things, but that's not very CS... )
20:20:51 <alex777> ?type grab
20:20:53 <lambdabot> Not in scope: `grab'
20:21:04 <dons> grab?
20:21:13 <alex777> what's the function to get a specific lists index ?
20:21:30 <Pseudonym> ?free fst
20:21:32 <lambdabot> ( f ($fst x) = $fst y   &&   g ($snd x) = $snd y ) => f (fst x) = fst y
20:21:34 <dons> ?hoogle [a] -> Int -> a
20:21:35 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
20:21:44 <Pseudonym> Grrr.  dons, please update freetheorem.
20:21:48 <dons> > "haskell" !! 2
20:21:49 <lambdabot>  's'
20:21:51 <SamB> dons: you aren't supposed to have it look just like a list (if you were to diagram it), are you?
20:21:51 <dons> Pseudonym: ah yes. ok.
20:21:53 * dons updates
20:21:56 <alex777> ah ok
20:22:06 <alex777> I remember reading that now heh
20:22:12 <SamB> dons: don't all of those things have shorter paths to both ends than to the middle?
20:23:26 <sjanssen> SamB: it doesn't matter much what a data type looks like inside for Stream fusion
20:23:47 <SamB> sjanssen: no. but. what if you were to read from a file?
20:23:54 <SamB> say /dev/zero
20:24:02 <edwardk> anyone else get  Network/Socket.hsc:283:15: parse error on input `CALLCONV' when trying to build the network package?
20:24:24 <sjanssen> in something like "goodConsumer . goodProducer :: Deque", the representation in between the functions will have nothing to do with a Deque
20:24:33 <alex777> xs !! (length xs) / 2
20:24:45 <alex777> for non-even lengths
20:24:57 <sjanssen> SamB: then the deque will be fully evaluated already, so you can really fuse it
20:25:05 <dons> Pseudonym: ok. updated. it will propogate on the next lambdabot restart, on Tuesday
20:25:06 <sjanssen> s/can/can't
20:25:11 <Pseudonym> Cool, thanks.
20:25:19 <alex777> for xs = [1,3,5] would that return 3 ?
20:25:22 <SamB> sjanssen: what if I loaded my program in GHCi?
20:25:25 <SamB> then what?
20:25:41 <Pseudonym> ?free fst
20:25:42 <lambdabot> ( f ($fst x) = $fst y   &&   g ($snd x) = $snd y ) => f (fst x) = fst y
20:25:45 <SamB> iirc, GHCi doesn't do -O...
20:25:48 <mauke> > let xs = [1,2,3] in xs !! length xs `div` 2
20:25:51 <lambdabot>  Exception: Prelude.(!!): index too large
20:25:52 <Pseudonym> Now reads: f . fst = fst . $map_Pair f g
20:25:53 <skew> SamB: I meant like ByteString.Lazy as in combining ByteString chunks with another structure to get nice properties, not specifically in being lazy
20:25:55 <Pseudonym> Which is very nice.
20:25:56 <sjanssen> SamB: it's also important to note that there aren't any fusion systems right now that fuse across IO
20:25:57 <mauke> > let xs = [1,2,3] in xs !! (length xs `div` 2)
20:25:58 <dons> SamB: you're making no sense :)
20:25:59 <lambdabot>  2
20:26:05 <EvilRanter> alex777, (/) is for floats, (!!) only works for Integrals
20:26:17 <Pseudonym> Though it reads better as:
20:26:17 <EvilRanter> you want what mauke said
20:26:21 <Pseudonym> f . fst = fst . f >< g
20:26:29 <SamB> dons: well, if I were to try to readFile some infinitely long file into a deque, it *would not work*
20:26:31 <alex777> I see
20:26:32 <Botty> ? [1,2,3] !! 1
20:26:33 <EvilRanter> > let xs = [1,2,3] in xs !! (length xs `div` 2)
20:26:35 <lambdabot>  2
20:26:40 <SamB> period
20:26:42 <skew> SamB: I'm not so sure about that
20:26:53 <skew> the Dequeue structure keeps both ends handy
20:27:02 <SamB> skew: that is the entire problem
20:27:08 <sjanssen> it does depend on the dequeue
20:27:12 <SamB> an infinitely long file doesn't *have* two ends
20:27:16 <skew> but it hasn't necessarily evaluated the tail
20:27:41 <SamB> how can it be handy if it is infinitely far away?
20:27:55 <sjanssen> but, if we limit ourselves to Data.Sequence, I agree with SamB
20:27:58 <skew> in the same way you can work with fst (1, tail [1..])
20:28:06 <skew> er, fst (1, last [1..])
20:28:18 <SamB> okay, I may not be right, but I'd like to see you prove me wrong
20:28:27 <SamB> and then I'd like to see your Os
20:28:51 <Pseudonym> ?remember SamB and then I'd like to see your Os
20:29:22 <sjanssen> SamB: it is hard to imagine a data structure that is both lazy and has O(1) head/last
20:29:31 <sjanssen> but I don't see what this has to do with fusion
20:29:37 <SamB> nothing
20:29:52 <skew> sjanssen: amortized analysis makes that a bit more interesting
20:29:58 <dons> yay, i see a bikeshed!
20:30:00 <SamB> except that fusion could hide the problem
20:30:07 <SamB> dons: a bikeshed?
20:30:17 <Pseudonym> ?google bikeshed argument
20:30:20 * dons hunts for lunch
20:30:20 <SamB> what kind of bike does it contain?
20:30:23 <lambdabot> http://www.unixguide.net/freebsd/faq/16.19.shtml
20:30:23 <lambdabot> Title: Why should I care what color the bikeshed is?
20:30:32 <dons> ?google bikeshed.org
20:30:36 <lambdabot> http://www.bikeshed.org.uk/
20:30:46 <dons> maybe its bikeshed.com
20:30:48 <skew> beacuse if you have an infinite list you have an infinite number of operations to amortize over, even if it happens you can get at parts of the structure already thanks to laziness
20:30:53 <dons> http://bikeshed.com
20:30:55 <lambdabot> Title: Why Should I Care What Color the Bikeshed Is?
20:31:01 <Pseudonym> Same thing.
20:31:04 <dons> yup
20:31:12 <dons> better url though ;)
20:31:21 <Pupeno> Hello.
20:31:23 <Pseudonym> But I found it first.
20:31:35 <skew> anyway, I meant defining a strictish type like ByteString, but supporting things like ++ without copying
20:31:39 <Pseudonym> But yes, your page's bike shed is a better colour.  I concede.
20:31:42 <skew> http://www.sgi.com/tech/stl/Rope.html
20:31:55 <SamB> skew: it doesn't work like that, I don't think...
20:32:11 <sjanssen> skew: it's C++, I think we can be quite certain it's entirely strict ;)
20:32:19 <SamB> I'm pretty sure you are only allowed to include things you have already done in amortized costs
20:32:26 <Pseudonym> sjanssen: Not necessarily.
20:32:38 <Pupeno> Is there any numeric fuction that works on a precise type, Int, Float, any... but not on a class like Num ? (it is for a conference)
20:32:59 <Pseudonym> The STL, remember, is based on iterators.
20:33:03 <skew> SamB: like constructing the infinite list
20:33:13 <Pseudonym> Which, in some sense, model lazy streams.
20:33:22 <sjanssen> Pupeno: there are a handful of functions that specifically mention Int
20:33:26 <sjanssen> @type (!!)
20:33:28 <lambdabot> forall a. [a] -> Int -> a
20:33:28 <Pseudonym> Indeed, the lazy list is the Haskell equivalent of the C++ forward iterator.
20:33:29 <sjanssen> @type drop
20:33:30 <SamB> okay, so basically you want a semi-strict Rope
20:33:31 <lambdabot> forall a. Int -> [a] -> [a]
20:33:47 <skew> SamB: I'll look through Okasaki in a little bit
20:34:02 <SamB> I'll agree that that might be useful, now that we agree you aren't talking about replacing .Lazy ;-)
20:34:04 <sjanssen> I think a rope is best if it is entirely strict
20:34:14 <skew> I'm just about to mail some touched-up code back to the ruby quiz guy
20:34:20 <SamB> sjanssen: mmm, okasaki might not agree
20:34:21 <Pupeno> sjanssen: I need something not involving lists, something only numbers... something very basic... I just can't find it.
20:34:34 <Pseudonym> The rope data structure does go to some trouble to defer rebalancing, so that's kinda lazy.
20:34:41 <SamB> I think you should concede that okasaki knows more about amortized costs than you do
20:34:51 <sjanssen> Pupeno: can't think of any.  It's quite possible there aren't any
20:34:54 <Pseudonym> The original paper (Jon Bentley, IIRC) is on citeseer or something.
20:35:04 <Pupeno> It seems so.
20:35:11 <skew> SamB: I learned everything I know about amortized analysis from reading Okasaki's stuff
20:35:21 <Pseudonym> What about the shift operators?
20:35:24 <SamB> skew: I was talking to sjanssen ;-)
20:35:29 <Pseudonym> Bit shifting.
20:35:32 <Pseudonym> What do they work on?
20:35:36 <SamB> Pseudonym: what about them?
20:35:53 <sjanssen> SamB: it is quite possible I am talking out of my ass
20:35:55 <sjanssen> it happens
20:36:04 <monochrom> typeclass Bits :)
20:36:07 <skew> what were you saying?
20:36:08 <Pseudonym> Right.
20:36:26 <Pseudonym> ?type scaleFloat
20:36:28 <lambdabot> forall a. (RealFloat a) => Int -> a -> a
20:36:39 <Pseudonym> That doesn't really count, I guess.
20:36:42 <Pseudonym> ?type +#
20:36:43 <lambdabot> parse error on input `+#'
20:36:47 <Pseudonym> ?type (+#)
20:36:49 <lambdabot> Not in scope: `+#'
20:36:52 <SamB> well, you might *think* strictness was the way to go, but some of okasaki's datastructures have a vital dependance on some particular laziness ;-)
20:37:13 <Pseudonym> ?hoogle Int# -> Int# -> Int#
20:37:14 <lambdabot> Hoogle Error: Parse Error: Unexpected character '> -> Int> '
20:37:16 <SamB> anyway, I'll point out that all the leaves would most likely be already be evaluated
20:37:31 <skew> in general it seems like laziness is pretty essential for persistent amortized structures
20:37:40 <SamB> I'd probably want to make them be so
20:38:03 <SamB> but, the branches might not be
20:38:12 <monochrom> If you don't want persistence, go strict and mutable.
20:38:20 <skew> or at least some sort of mutation under the covers, to stop people from picking one particular version and operation that's "unlucky", and repeating it
20:38:31 <monochrom> If you want persistence, need immutable and lazy.
20:38:53 <SamB> well, sometimes persistance is just easier, though.
20:39:11 <SamB> I mean, from a usability and composability standpoint.
20:39:25 <monochrom> That is precisely why I prefer Haskell.
20:39:33 <SamB> that way, it will just work, no nasty mess to clean up if you forget something.
20:39:45 <alex777> mean [ xs !! (length xs `div` 2 - 1 ) , xs !! (length xs `div` 2) ]
20:39:45 <skew> monochrom: actually there are some funky general purpose persistence transformations that use mutable data internally
20:39:47 <Pseudonym> Except a memory leak.
20:40:00 <monochrom> Haskell is persistent by default.  :)
20:40:03 <SamB> Pseudonym: eh. not that kind of something.
20:40:19 <skew> but I think laziness might be a bit easier to handle in parallel implementations
20:40:24 <SamB> also, no need to go and copy everything out of sheer paranoia
20:40:30 <monochrom> In a mutable language you *will* forgot to make a crucial copy.
20:40:38 <Pseudonym> skew: It might be easier to handle, but it's not easier to implement.
20:40:43 <SamB> monochrom: exactly
20:40:43 <monochrom> (You will also make unneeded copies.)
20:40:48 <SamB> yes!
20:40:54 <Pseudonym> You can end up in odd situations where different threads need to evaluate the same thunk.
20:40:55 <SamB> exactly what I'm saying ;-)
20:41:00 <monochrom> Wrong and inefficient, who wants that?
20:41:11 <SamB> Pseudonym: it should not make a difference.
20:41:23 <SamB> now, I'm not saying this is true... *YET*.
20:41:24 <skew> Pseudonym: from reading the GHC-SMP paper, it sounds like they got a lot of help from referential transparency
20:41:31 <Pseudonym> As Peter van Roy said: Concurrency, global state, robustness.  Pick any two.
20:41:38 <skew> because it's okay to duplicate evaluation, and doesn't really matter what version wins
20:41:55 <SamB> I think unsafeInterleaveIO messes things up, though, possibly...
20:42:12 <skew> as I recall, those unsafe things just grab a lock
20:42:18 <Pseudonym> Ah, OK.
20:42:29 <SamB> skew: I wasn't clear on whether they had actually implemented that yet...
20:42:31 <Pseudonym> The problem is, though, that you might duplicate a lot of work in general.
20:42:35 <SamB> I was talking to one of those.
20:42:38 <SamB> er. them.
20:42:48 <skew> oh
20:42:51 <SamB> Those people who are mostly named Simon, you know.
20:42:59 <skew> If you've got an SMP box you could try it out
20:43:00 <Pseudonym> Yes.
20:43:01 <Pseudonym> The Simons.
20:43:04 <alex777> Undefined variable "genericLength"
20:43:07 <alex777> heh
20:43:11 <Pseudonym> I have no SMP box.
20:43:15 <mauke> import Data.List
20:43:18 <Pseudonym> Well, not one that I trust.
20:43:22 <SamB> Lemmih has one.
20:43:35 * Pseudonym hacks root on Lemmih's box
20:43:37 <skew> how long until Ian has to change his name to Simon?
20:43:45 <alex777> mauke shouldn't that be in Prelude ?
20:43:48 <SamB> what do you need root for?
20:43:52 <mauke> alex777: no, why?
20:43:55 <Pseudonym> No reason.
20:44:01 <alex777> I don't know
20:44:04 <SamB> Pseudonym: wouldn't it be easier to hack samb@catenova.org?
20:44:47 <SamB> okay, I need sleep
20:45:00 <SamB> I should have gone almost an hour ago...
20:45:05 <Pseudonym> Night.
20:45:11 <Pseudonym> ?localtime SamB
20:45:13 <lambdabot> Local time for SamB is Thu Nov  9 23:45:07
20:45:32 <SamB> I have to get up at 6:00 AM
20:52:20 <alex777> xs !! (length xs `div` 2 - 1 ) + xs !! (length xs `div` 2)
20:52:32 <alex777> trying to add those up and get their mean
20:53:11 <alex777> I was going to use my mean function but that doesn't work :/
20:53:13 <alex777> ?paste
20:53:14 <lambdabot> http://paste.lisp.org/new/haskell
20:53:24 <complaisant> hoogle is the best invention ever
20:53:31 <complaisant> \o/
20:53:44 <Pseudonym> True, you can't find a function with sliced bread.
20:54:21 <lisppaste2> alex777 pasted "median" at http://paste.lisp.org/display/29597
20:55:04 <monochrom> yeah hoogle is good
20:55:56 <alex777> I get an ERROR - Unresolved overloading
20:59:11 <Pupeno> Is there some way to run ghci inside emacs without a .hs file ?
20:59:35 <monochrom> Yes pupeno
20:59:39 <Korollary> M-x shell, then run ghci ?
20:59:50 <Pupeno> monochrom: how ?
21:00:11 <emu> M-x run-haskell works for me
21:00:42 <Pupeno> Korollary: that's not the same.
21:01:25 <Pupeno> emu: here it says [no match].
21:02:35 <emu> what about M-x switch-to-haskell
21:03:41 <emu> run-haskell is defined in haskell-mode/haskell-site-file.el, which is what you should be loading from your .emacs
21:03:50 <emu> it defines all the autoloads
21:04:12 <Pupeno> mmhh...
21:04:35 <monochrom> alex777: too hard to explain the reason.  Easier to just not use mean.
21:05:09 <alex777> how can I sum them and divide by 2 then ?
21:05:29 <monochrom> (x+y)/2
21:05:51 <alex777> I think I tried that and I got an error, let me see
21:06:18 <monochrom> (fromIntegral x + fromIntegral y) / 2
21:06:42 <monochrom> This also means you need fromIntegral for the odd case.
21:06:48 <Pupeno> Gentoo takes care of loading haskell-mode by default and on .emacs I have a lot of definitions for a bareable indenter.
21:07:15 <alex777> that worked
21:07:34 <skew> SamB: are you still around?
21:07:55 <alex777> thanks monochrom
21:07:57 <emu> why would you write mean with list comprehension
21:08:12 <alex777> because I'm new to haskell
21:09:31 <emu> > \l -> (fromIntegral (sum l)) / (fromIntegral (length l)) $ [1..10]
21:09:32 <lambdabot>  add an instance declaration for (Fractional ([a] -> b))
21:10:00 <emu> > (\l -> (fromIntegral (sum l)) / (fromIntegral (length l))) [1..10]
21:10:02 <lambdabot>  5.5
21:10:32 <emu> or better yet, do it with a fold ;)
21:10:48 <alex777> heh
21:10:55 <alex777> I don't know what a fold is
21:11:02 <skew> it might be good to do them both together
21:11:20 <skew> if you're reading values from a file, or something
21:11:34 <emu> @type foldl
21:11:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:11:39 <alex777> I'm not reading from a file
21:11:53 <skew> like foldl' (\(sum,len) a -> (sum+a, len+a)) (0,0)
21:12:01 <skew> except stricter
21:12:11 <emu> len+1
21:12:21 <skew> right
21:12:35 <emu> and compose uncurry (/) with that or somethin
21:12:51 <monochrom> > foldl' (\(sum,len) a -> (sum+a, len+a)) (0,0) [3,1,4,2,5,9]
21:12:53 <emu> @type uncurry (/)
21:12:53 <lambdabot>  (24,24)
21:12:54 <lambdabot> forall b. (Fractional b) => (b, b) -> b
21:13:09 <monochrom> Darn!  Forgot to fix the typo!
21:13:26 <skew> > uncurry (/) . foldl' (\(sum,len) a -> (sum+a, len+1)) (0,0) $ [3,1,4,2,5,9]
21:13:28 <lambdabot>  4.0
21:13:39 <monochrom> thanks
21:14:00 <emu> @pl \(s,l) a -> (s+a,l+1)
21:14:01 <lambdabot> uncurry ((. (1 +)) . flip . ((,) .) . (+))
21:14:12 <Pseudonym> Worst one-liner to compute pi EVER.
21:14:26 <merus> awww :(
21:14:42 <skew> what? pi = [3,1,4,1,5,9, ...
21:14:53 <emu> i had a pretty bad one the other day
21:14:54 <Pseudonym> Yeah/
21:16:21 <emu> > sum [ (-1)^k * 1 / (2*k+1) | k <- [1..100] ]
21:16:23 <lambdabot>  Add a type signature
21:16:35 <emu> > sum [ (-1)^k * 1 / (2*(fromIntegral k)+1) | k <- [1..100] ]
21:16:36 <lambdabot>  -0.21212664973225237
21:17:05 <emu> > 4 * (sum [ (-1)^k * 1 / (2*(fromIntegral k)+1) | k <- [0..100] ])
21:17:06 <lambdabot>  3.1514934010709914
21:17:21 <emu> > 4 * (sum [ (-1)^k * 1 / (2*(fromIntegral k)+1) | k <- [0..10000] ])
21:17:23 <lambdabot>  3.1416926435905346
21:17:32 <emu> it converges rather slowly :/
21:17:47 <Pseudonym> > iterate (\x -> x + sin x) 3.0
21:17:48 <lambdabot>  [3.0,3.1411200080598674,3.1415926535721956,3.141592653589793,3.1415926535897...
21:17:58 <Pseudonym> That converges rather quickly.
21:18:13 <emu> trig is cheating!
21:19:19 <monochrom> > fix (\x -> 4 * arctan 1)
21:19:20 <lambdabot>  Not in scope: `arctan'
21:19:27 <monochrom> > fix (\x -> 4 * atan 1)
21:19:29 <lambdabot>  3.141592653589793
21:20:06 <monochrom> Oh, trig is cheating. Nevermind.
21:20:15 <monochrom> "trig or cheat"?
21:51:12 <dons> this is lovely:
21:51:13 <dons> Haskell is very easy to refactor. You pull out some functions, the
21:51:13 <dons> code shrinks, you see more subtle patterns, you pull out more functions.
21:51:13 <dons> Eventually you start noticing and reifying patterns between those
21:51:13 <dons> functions, like a star off the main sequence burning the products
21:51:15 <dons> of the last round of fusion, until finally the "degeneracy pressure"
21:51:18 <dons> or fixed boilerplate of introducing and calling a new abstraction
21:51:20 <dons> stops the collapse.
21:51:37 <dons> ...
21:51:38 <dons> I wonder, what's the programming equivalent of a black hole?
21:52:23 <Botty> unless of course you start going point-less at which point a refactor is a rewrite :)
21:52:32 <dons> heh
21:52:41 <dons> until we have @unpl
21:56:45 <monochrom> You have uneliminatable boilerplate code of introducing and calling abstractions.
21:57:02 <monochrom> Then you put it into a module and call it a "new library".
21:57:30 <monochrom> Then you just go "import NewLibraryModule(f); main = f".  That is your black hole.
21:58:09 <monochrom> Fundamental software-engineering research reveals that a new library sucks in code from everyone and emit Karma radiation in return.
22:02:45 <dons> :)
22:02:55 <monochrom> A library has only two physical parameters (all other properties can be deduced from these two numbers): mass (in LOC) and agile-momentum.
22:03:04 <dons> hehe
22:03:23 <dolio> Heh.
22:03:32 <monochrom> The simplest libraries has agile-momentum 0, i.e., non-evolving.  It has only one version number.  It is simplest but also most boring.
22:04:04 <monochrom> A library with agile-momentum>0 is called an evolving library.  It has very intricate dynamics.
22:04:38 <monochrom> Gosh if I don't win a Nobel prize for this, then at least the Turing Award.
22:06:15 <dons> heh
22:06:41 * Pseudonym nominates monochrom for an Ignoble
22:08:53 <monochrom> The theory of General Relativity predicts this.  As a developer is sucked into a library, and a user stays stationary at a safe distance away, they do not experience the same time line.  The developer's version number is higher than the user's version number.
22:08:53 <skew> dons: I'm glad you like it :)
22:09:40 <monochrom> There are many more correspondences than you would like to hear. :)
22:11:48 <dons> skew++
22:12:05 <dons> oh hmm there's a "the Royal Society for the Prevention of Accidents" ?
22:12:33 <skew> does lambdabot actually watch postincrements?
22:12:46 <dons> yes
22:12:54 <skew> and should we really encourage mutation with such nice sugar?
22:13:02 <dons> :)
22:13:14 <dons> its not mutation, we're in the Karma monad
22:13:16 <dons> all is good
22:13:23 <monochrom> Oh but I must add this last one.  The last one!  Promise!  The event horizon that divides the user from the code is called the "interface boundary".  Some users accidentally cross the interface boundary and start reading and changing the code; they become developers and there is no return.
22:13:55 <dons> (++) s = do m <- get ; case lookup m s of Nothing -> put (insert m s 1) ; put (...
22:14:53 <monochrom> I know too much physics.  I should get out more.
22:15:39 <Pseudonym> That explains why the known laws of physics break down inside the code.
22:15:56 <monochrom> haha you're goo
22:15:59 <monochrom> d
22:16:06 <skew> monochrom: maybe a nice trip around the Landscape?
22:16:24 <Pseudonym> Code is a singularity that nothing can escape from.
22:16:28 <Pseudonym> Especially not information.
22:20:08 <skew> I think Okasaki's catenable lists might still work with infinite structures
22:23:56 <robreim> What does ghc use for its windows .msi files?
22:26:12 <robreim> as in, how are the .msi files created
22:29:13 <dons> now here's an interesting kernel message....
22:29:15 <dons> "Nov 10 16:45:28 paprika /bsd: Data modified on freelist: word 4 of object 0xd0f44d00 size 0x100 previ
22:29:18 <dons> ous type devbuf (0xdeadbeee != 0xdeadbeef)"
22:29:46 <monochrom> bee and beef are very different!
22:30:30 <dons> huh, very old code. same error msg is used in free and netbsd too
22:31:45 <dons> maybe its time i updated my kernel
22:37:46 <skew> dons: have you worked on hs-plugins for 6.6?
22:38:01 <dons> not yet. try me again on sunday
22:38:11 <dons> busy with a conference all week
22:38:27 <skew> fun. which?
22:39:00 <dons> aplas06, http://www.kb.ecei.tohoku.ac.jp/aplas2006/
22:39:01 <lambdabot> Title: APLAS 2006
22:44:34 <skew> I think I might have enjoy working out the details of how types and plugin-loaded get along as a live system evolves
22:44:55 <dons> mm. its a tricky problem
22:44:59 <dons> i think there's a phd in it :)
22:46:32 <skew> it seems like it should work out, if you fix an interface type, and have some way to get the main threads of an application to migrate into new code
22:47:34 <skew> maybe more fun with dependent types, like mu T = <promises to satisfy some interface stuff> & <promises only to upgrade to things of type T>
22:49:59 <skew> Fun, I think with types like that you should be able to use a lemma <stuff> <-> <other stuff> to bootstrap to a system that requires <other stuff>, and has no trace of the first request
22:50:09 <Botty> In other languages I've had systems which watch plugin source files, and when modified, recompile and replugin
22:50:11 <skew> no trace of the first contract, rather
22:50:26 <skew> Botty: Hinotify could probably help with that
22:50:51 <skew> except it just doesn't seem right to mutate libraries out from under running code, at least for Haskell
22:50:57 <dons> hs-plugins watches and recompiles
22:51:04 <dons> it'd be nicer with hinotify
22:51:04 <Botty> coolio
22:51:23 <skew> the Erlang system sounds pretty reasonable
22:51:31 <dons> skew, wel, changing functions is 'right'. changing types/adding variants, not so
22:51:34 <dons> expression problem
22:51:51 <dons> yeah, erlang is super smart
22:51:57 <skew> ah, probably want extensible variants for taht
22:52:18 <Botty> then again a plugin shouldn't really be a full thing with types,,, maybe internal types, but I don't see how the outside system could rely on them
22:52:43 <skew> I think the Erlang system is based on something like identifying (when you write up the patch config) which modules a thread can be looping in and which it can't
22:53:33 <skew> then for just the "home modules" you need to write some state-upgrade function, then the system waits until threads are at home, and send a special message "hey, you're being upgraded"
22:54:58 <skew> Heh, we'd need that RSA at the type level Oleg has mentioned to properly type a server that promises to only accept patches that maintain it's interface contract, unless asked by people holding the right keys.
22:55:05 <Botty> yeah, my current To-Learn list is Lisp, Erlang, Smalltalk
22:56:21 <skew> sounds a little light on the types, have you seen Epigram?
22:57:04 <Botty> nope
22:57:21 <Botty> Yeah, actually I need to learn alot more about type systems...
22:58:37 <skew> It's still a toy, but an interesting one
22:58:57 <Botty> ooh, latex language eh, neat
22:59:14 <skew> is it?
22:59:31 <Botty> according to the wikipedia article you can use latex or ascii
22:59:45 <skew> hmm
23:00:07 <Botty> cool because you can compile your latex to pdf and have a pile of equations :)
23:00:15 <skew> I've heard talk of building a GUI front-end with TeX-quality typesetting, but nothing else
23:00:44 <skew> and my local DNS is pretty flaky now, so I can't follow up on things so well
23:00:57 <Botty> ah. http://en.wikipedia.org/wiki/Epigram_programming_language
23:01:00 <lambdabot> http://tinyurl.com/yygzeu
23:01:21 <skew> that sounds quite plausible, though. The epigram papers have some pretty formatting in them
23:01:51 <skew> Epigram is good for playing with the Curry-Howard isomorphism
23:03:12 <skew> experiencing what "programs are proofs" really means, and what's good about Turing-incomplete (sub)languages
23:04:17 <Botty> sounds interesting
23:04:47 <skew> Not exactly a real language yet - the libraries are pretty sparse. For example, you have to roll your own integers :)
23:07:29 <skew> on the other hand, once you've done that it's almost as easy to define a type of even or prime numbers.
23:08:37 <Botty> and expand on and on until you can successfully write the worlds slowest raytracer
23:26:26 * monochrom defines the type of integers satisfying the Fermat equation.
23:47:12 <dons> interesting insight into how not to write 'Practical Haskell' :) http://blog.merjis.com/2006/11/08/practical-ocaml/
23:47:18 <lambdabot> Title: Merjis blog Â» Blog Archive Â» Practical OCaml, http://tinyurl.com/sfza9
23:47:58 <dolio> Not poorly?
23:48:06 <dons> right.
23:48:10 <dolio> :)
23:48:42 <dolio> I must say, I'm a fan of Joe Celko's SQL for Smarties.
23:48:53 <dolio> It's riddled with errors, but the attitude is nice.
23:49:05 <dolio> Someone should write a haskell book like that (sans the errors).
23:51:07 <Botty> One with community review (perhaps limited, if the writer is greedy :) )
23:51:36 <dolio> Any book with examples where the author has an example database of "playboys" where he pairs himself in relationships with lots of female teen idols is fine in my book.
23:53:24 <Botty> Â£13/hour is a snip above minimum wage? wow
23:55:10 <dons> I think we need 2 or 3 such books
23:55:19 <dons> you could write a whole book just called "Monads"
23:55:23 <dons> it'd be a classic
23:55:35 <merus> Monads rock
23:55:38 <dons> :)
23:56:33 <dolio> I like Why's (Poignant) Guide to Ruby, as well, but I don't know if you could actually learn the language from it.
23:57:11 <dons> ndm, nice QuickCheck article
23:57:13 <Botty> me too, dolio, though it gets a bit rediculous
