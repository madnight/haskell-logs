00:02:04 <shapr> Yeah, I like ERC. I was a beta tester during the 2.0 development.
00:02:39 <dmead> kewl
00:02:43 <pzpz> shapr: is it mature?
00:04:17 <shapr> Yup, maybe too much even.
00:13:11 <kzm> What is a 'variant'?  (Going through the Links paper)
00:13:43 <kzm> "A variant is written Fi(ei) and its type is written [|F1:A1,...|]
00:13:44 <dblhelix> kzm: a labeled disjoint sum
00:14:07 <kzm> eh.
00:15:20 <dblhelix> kzm: Bool is an example of a simple variant
00:15:44 <dblhelix> it's type [| False : () , True : () |]
00:16:07 <dblhelix> with False() and True()
00:16:16 <kzm> Just a 'sum type' algebraic data type?
00:16:25 <dblhelix> kzm: exactly
00:17:06 <han1> if i want to draw figure and save it as vector graph like .ps, what kind of package shoudl I use?
00:17:07 <dblhelix> kzm: with named contructors instead of in1 ... inn
00:17:35 <dblhelix> /s/contructors/constructors
00:17:37 <kzm> so [| F1:A1, ... Fn:An |] would translate to (data F =) F1 A1 | F2 A2 | ... | Fn An in Haskell?
00:17:49 <dblhelix> kzm: yes
00:17:55 <pzpz> han1: you asking for something like dia/graphviz?
00:18:04 <kzm> Thanks.  That wasn't so hard :-)
00:18:20 <han1> not really like that, like tcl/tk
00:18:42 <kzm> (Found some references to Cardelli when I googled, I guess that means there are some big holes in my basic education)
00:19:22 <pzpz> i'm liking erd.
00:19:25 <kzm> han1, gd? R? inkscape?  (probably not, but..)
00:19:42 <han1> i mean use haskell to program
00:19:52 <pzpz> hello world?
00:22:39 <shapr> hello
00:22:43 * shapr is about to sleep
00:22:52 <pzpz> this works :)
00:23:55 <sieni> shapr: already?
00:25:12 <shapr> sieni: It's 2am! g'nite!
00:25:26 <pzpz> nite.
00:26:32 * lispy waves, "hi!"
00:33:16 <sieni> shapr: oh :-)
00:35:44 * Botty wishes there was a haskell graphing calculator
00:36:15 <Botty> it really would be a perfect language for a calculator... with some modifications to permit real maths symbols
00:36:53 <lispy> Botty: you just need utf16 operators :)
00:37:38 <Botty> yep
00:37:43 <Botty> and a decent calc :)
00:37:55 <Botty> probably haskell is the wrong language, but something functional is all i want
00:38:54 <pzpz> port ghci to that ti processor? :)
00:39:20 <Botty> ahwell, probably too difficult to spend real effort on (for AP Calc test/ amc)
00:39:28 <pzpz> i think there's a gcc target for the ti89/92 processor
00:39:34 <Botty> ooh cool
00:39:51 <pzpz> but i don't think it's reasonable :)
00:40:15 <Botty> yeah, pretty restricted environment to compile and run haskell in
00:40:30 <thyko> mmm ... i think huskell.org is using mod_throttle ...
00:40:37 <Botty> would probably be best off with hugs anyway
00:41:30 <Excedrin> yhc
00:41:54 <pzpz> what exactly is the : operator called?
00:42:07 <mbishop> would be easier to just write a ti emulator in haskell :)
00:42:13 <Botty> not really gonna do it though, calcs have horrible text entry :) I suppose if i was insane i could design a text editor
00:42:25 <Botty> pzpz: cons, usually i think
00:42:32 <Botty> list construction
00:42:43 <pzpz> yah, i 'spose that'll do.
00:43:30 <pzpz> you could just implement a lot of macros for commonly used functions.
00:44:13 <pzpz> since x,y,t are easy to access, map could be "xyt", filter, "yyt"
00:44:30 <pzpz> at least your code would be completely unreadable to anyone but yourself
00:44:50 <Botty> heh, nah, my attraction to haskell is actually writing the shtuff, my own functions etc
00:45:05 <Botty> especially for the amc test.  with a bit of recursion that thing is elementary
00:45:28 <pzpz> just provide code and the link to a interpreter :)
00:46:28 <Botty> hmm, maybe a pda disguised as a calculator :)
00:47:03 <pzpz> do they have calculators with bluetooth/802.11 yet?
00:47:17 <pzpz> that could make for some splendid cheating.
00:49:48 <Botty> heh
00:50:17 <Botty> I don't want to <cheat>, just use better tools, which i happen to know how to use
00:50:36 <pzpz> i'm pretty sure programmable calculators are "cheating"
00:50:51 <pzpz> i don't thnk i've ever been allowed to use my 89 on any exam
00:51:09 <Botty> heh
00:51:23 <Botty> well, all the allowed ones are programmable as well, here
00:51:44 <Botty> I don't think they make real strict specifications as to brand on the AP Calculus test though
00:51:44 <pzpz> evne though you just want to implement your own solutions, there's nothing from stopping people from getting their hands on pre-implemented algorithms :)
00:52:05 <Botty> hah, the language is so weak though, you can barely do a thing
00:52:39 <pzpz> i don't understand why they'd allow a calculator that can do calculus on the ap calc exam :)
00:53:00 <Botty> only thing i've seen like that in widespread use was a quadratic formula program.  Oh, and I made a factoring program (because i sucked at it).  Took ages to punch in
00:53:13 <Botty> heh, yeah
00:53:28 <Botty> there's a calculator portion and non-calculator portion
00:53:38 <pzpz> ahh, gotit
00:54:58 <Botty> even a forth calculator would be pretty cool :)
00:56:08 <pzpz> Alsoly should be a word.
00:56:26 <pzpz> I'll start by adding it to my dictionary.
00:57:21 <pejo> pzpz, a calculator is mostly useful for verification of answers, just giving the answer doesn't usually go very well.
00:58:00 <Botty> well, symbolic differentiation wouldn't be too hard if it had a functional language :)
00:58:13 <Botty> (obviously implemented beforehand)
00:58:20 <pzpz> pejo: of course. but someone can easily memorize an approach to a problem, use it to calculate the steps, and then write it down
00:58:25 <Botty> even have it show the steps ;)
00:59:21 <pzpz> I think most math tests aim to test your ability to perform some method, not just memorize steps.
00:59:53 <Botty> usually the same thing... Though this test will be fun because it'll hit on some more theoretical concepts
01:02:54 <Botty> not that I'm condoning cheating or anything... just after learning haskell i've realized how crappily designed my calc is (TI-83).  (I knew it before, just not the extent)
01:03:26 <mbishop> at least get an 89 :P
01:04:18 <Cale> I gave my calculator away to my sister around when I entered university :)
01:04:36 <Cale> and I've never owned a calculator costing more than around $20.
01:05:01 <astrolabe> I'd quite like an RPN calculator
01:05:04 <Botty> heh, maybe.  I've got my eye on those ones with qwerty boards, though I know they aren't allowed on the amc (I don't really care about the test, but it pisses me off that I never get past the first stage)
01:06:16 <Botty> Cale - yeah, its funny how people don't realize that real mathematicians don't need calculators, or deal much with numbers at all
01:07:05 <flux__> cale,  you must've missed so much.. so many games!
01:08:19 <Botty> well, i suppose there's the number theory people... or something
01:10:18 <Cale> The hardest thing which I had to calculate on any exam was the floor of a Minkowski bound, which was something like (4/pi)^2 5!/(5^5) sqrt(D), and I can't recall what D was, I think maybe 11 or so.
01:11:00 <Cale> But you don't need really good approximations there
01:11:48 <Cale> (that was in algebraic number theory)
01:12:18 <Cale> A huge percent of the time, there was essentially nothing one could do with a calculator though.
01:12:43 <Botty> i do arithmetic on my calculator
01:14:12 <flux__> do the current calculators provide bluetooth?
01:14:21 <kzm> Did it occur to anybody else that in the age of search engines, 'links' is a really, really poor choice of name?
01:14:28 <flux__> :-)
01:14:42 <flux__> not really
01:14:47 <Cale> kzm: what?
01:14:48 <flux__> first hit for the web-browser
01:14:51 <flux__> if you mean that
01:15:17 <kzm> flux__, now find the web programming language (as mentioned on HWN).
01:15:25 <flux__> kzm, ooh..
01:15:55 <flux__> well, tough luck :)
01:16:04 <kzm> if you know one of the authors, it works pretty well.
01:16:07 <Cale> oh, I thought you were talking about hypertext links, so I suppose I've fallen prey to the same problem as the search engines
01:16:28 <kzm> Just goes to show you :-)
01:16:46 <kzm> But the system looks sehr cool.
01:17:15 <Cale> "Stuff" is a really awful band name to search for, but they were from the 70's so they can be pretty much excused, I think.
01:18:15 <Cale> actually, that's a practical way to make piracy really difficult
01:21:38 <thyko> whats the best introductory Huskell tut?
01:21:49 <Cale> thyko: I like YAHT
01:21:53 <Cale> @where YAHT
01:21:54 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
01:22:07 <thyko> Tet Another Huskell Tutorial?
01:22:12 <Cale> yeah Yet
01:22:28 <thyko> thanks yall
01:22:32 <Cale> It's not perfect, but it's a reasonable place to start
01:22:48 <Cale> also, read the "Haskell in 5 easy steps" to get set up
01:23:01 <Cale> http://haskell.org/haskellwiki/Haskell_in_5_steps
01:23:04 <lambdabot> Title: Haskell in 5 steps - HaskellWiki, http://tinyurl.com/gdrmd
01:24:18 <thyko> just read tha, whept my apetite for huskell
01:24:26 <thyko> i mean, Haskell
01:24:42 <araujo> morning
01:24:43 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
01:24:45 <pejo> Cale, you went through three years of math and physics and didn't need a calc once?
01:28:05 <araujo> dons, oh, they are already translated
01:29:10 * araujo will definitely write a script to automate this
01:32:38 * ibid is reminded of an exam question i have occasionally posed to my students:
01:33:21 <ibid> which is the correct spelling of the name of the programming language discussed on this course: 1) haskel 2) haskell 3) hascel 4) hascell 5) ascot 6) ascott
01:33:41 <ibid> i probably should add 7) huskel 8) huskell next time :)
01:34:27 <ibid> (mind, only worth one point of 24, and i generally clue the students in on the question beforehand so that everybody gets it right)
01:35:09 <ibid> of 25, actually: 4x6 + 1
01:38:06 <pzpz> ibid: every time I mention Haskell at school, someone is like "huh,Pascal?"
01:40:46 <ibid> the most common misspelling i see is "haskel"
01:40:51 <ibid> pzpz: hah :)
01:41:30 <flux__> ibid, would it be too much to ask the student to actually write down the name?-)
01:42:04 <ibid> flux__: that's another option, though i am having fun with all the alternatives ;)
01:42:26 <ibid> flux__: the only point of the question and the clue-in is to make sure people learn at least the name
01:42:34 <kzm> Quick writeup for Links: http://en.wikipedia.org/wiki/Links_%28programming_language%29
01:42:36 <lambdabot> http://tinyurl.com/yjyd42
01:42:51 <kzm> Feel free to hack :-)
01:43:30 <ibid> (ascot is actually how someone transcribed haskell in their interview of me for some free software social research)
01:46:18 <pzpz> ibid: heh, you could also be mean and add Curry and Lambda to the list to further confuse people that are good at memorizing keywords :)
01:51:37 <earthy> Ascot is the horse race track, right? :)
01:51:41 <earthy> seems fitting enough. :)
01:53:25 <ibid> no, just a mistranscription
01:54:41 <Cale> pejo: 4 years, pure mathematics degree
01:55:35 <Cale> pejo: I took a couple of physics courses, but generally the questions are computationally simple enough that a little calculus can give you approximations when you need them, but largely, they want symbolic solutions, so it's not that important there either.
01:56:46 <Cale> pejo: but essentially, in pure mathematics courses, you don't need a calculator -- they're usually forbidden anyway, and when they're allowed, they're almost always completely useless.
01:57:09 <ibid> calculators were almost always allowed and useless when i was studying math
01:57:39 <Cale> yeah
01:57:56 <Cale> It wouldn't really matter whether they were allowed or not :)
01:58:30 <ibid> i got a quite a shock when i took a computer networks exam and i needed a calculator for it (didn't have a working one anymore)
01:59:18 <psykotic> cale: your calculator doesn't know how to do spectral sequence calculations? :)
01:59:25 <Cale> psykotic: heh
02:00:08 <Cale> Yeah, most of the things which are even remotely computational which you do in a pure math degree are completely foreign to the world of handheld calculators
02:00:29 <Cale> I wouldn't mind having a handheld device with, say, GAP in it.
02:00:54 <Cale> (not that it would be insanely useful, maybe handy for checking work on a group theory exam)
02:01:33 <Cale> (or potentially in anything which uses group theory)
02:02:06 <Cale> There have been times where I've run into "spot the polynomial factorisation in multiple variables" type problems, which are annoying.
02:02:33 <Cale> But I don't think most calculators do those either.
02:02:50 <psykotic> how about "spot the right term order" in the case of grobner basis calculations? i had one of those on my algebra exam
02:04:08 <Cale> I don't think my rings prof was cruel enough to make us compute any Gr√∂bner bases, though we did cover them in class. Perhaps there was a proof regarding them.
02:05:05 <psykotic> there was just one on this exam and it actually not cruel but rather a hand-out to the poor CS students for whom the course was mandatory :)
02:05:27 <Cale> Oh, a calculator to compute ideal class groups (or hell, class numbers) would be nice.
02:06:15 <Cale> Those are among the most annoying things to have to calculate ever.
02:07:12 <thyko> mmm .. 'Monads' ... they just replaced the 'G' with an 'M'
02:07:16 <psykotic> is there a fool-proof algorithm for that?
02:07:52 <Cale> psykotic: I don't really know. Probably not.
02:08:09 <psykotic> cale: btw have you ever fooled around with macaulay 2?
02:10:37 <Cale> psykotic: We had one small example on our exam but there was a really good bound on the class number, and it was over very quickly. On the assignment, it was somewhat less trivial, and a group of 3 of us basically worked on the assignment for a few days and still stayed up all night on the last day fighting through tons of algebra and divisibility relations to compute things regarding ideal class groups
02:11:47 <Cale> We asked the prof why he put those questions on the assignment, and he basically replied that he wanted to give some idea of how hard things could be.
02:11:55 <psykotic> nice
02:12:27 <Cale> I haven't played around with it, but I remember looking at it and thinking that it was interesting.
02:13:57 <Cale> I recall things in that course regularly breaking down into cases mod 4 and then usually one of those cases would break down further mod 8
02:14:41 <psykotic> meaning you had to investigate 0, 1, 2, 3, etc?
02:14:56 <Cale> yeah
02:15:00 <psykotic> ouch
02:15:04 * araujo off to univ
02:15:12 <Cale> well, 1 and 3 usually being the nontrivial ones
02:15:27 <psykotic> you have some of that with nasty group theory calculations involving sylow's or hall's theorems
02:16:48 <Cale> and then if something is congruent to 1 mod 4, then it's 1 or 5 mod 8, and if it's 3 mod 4, then it's 3 or 7 mod 8
02:17:11 <Cale> and you'd end up treating all of those separately, and it would work out differently in subtle ways
02:18:17 <Cale> It was actually rather surprising that it all worked out when you got it, but I struggled to take much away from the proofs we did on the assignments
02:18:37 <Cale> (other than 'algebraic number theory is brutal')
02:26:08 <dons> ?users
02:26:08 <lambdabot> Maximum users seen in #haskell: 276, currently: 244 (88.4%), active: 29 (11.9%)
02:26:17 <tibbe> @seen Cale
02:26:17 <lambdabot> Cale is in #scheme, #oasis, #haskell and #ghc. I last heard Cale speak 7m 39s ago.
02:26:29 <Cale> hi
02:28:18 <tibbe> Cale, hey, I think I have a good formal description now, do you think you could give it 5 min if I latex it and mail it to you after lunch? I would really appreciate it, I need for a small part of my thesis and it's due in three weeks.
02:28:31 <Cale> okay
02:29:03 <Cale> yeah, what we discussed I think sounds like a decent framework, given what you mentioned about the problem
02:29:07 <tibbe> hmm, let me mathbin it
02:29:23 <Cale> I'm going to sleep soon though
02:29:40 <tibbe> I basically replaced A* and R* (ie add and remove for whole strings) with A* which is active after a whole string
02:29:43 <thyko> aha!, no infinite loops in Haskell! :D
02:29:59 <tibbe> Cale, oh, I throw something together and you can say if it looks sane ;)
02:30:13 <dons> thyko: you've installed ghc yet?
02:30:42 <dons> i'd start with some of the tutorials on haskell.org, and perhaps try to solve some of the ruby quiz problems in haskell
02:31:02 <Cale> thyko: you can get infinite loops, it's just that the runtime will catch the easy ones
02:31:20 <psykotic> cale: you main thunk re-entry?
02:31:23 <psykotic> *mean
02:31:36 <Cale> psykotic: yeah, the whole black-holing process :)
02:31:37 <dons> > let f = f in f :: ()
02:31:39 <lambdabot>  Exception: <<loop>>
02:32:03 <psykotic> dons: yeah that's what i meant. fortunately damn easy to support in the STG :)
02:32:19 <thyko> dons: yeah, trying out some ghc --make -o x x.hs ...
02:32:21 <dons> yep
02:32:33 <dons> thyko: ok. good. you've written some code then?
02:32:57 <dons> thyko: here's some puzzles if you're looking for code to write: http://www.haskell.org/haskellwiki/Haskell_Quiz
02:32:59 <thyko> just hello world
02:32:59 <lambdabot> Title: Haskell Quiz - HaskellWiki, http://tinyurl.com/y6afxw
02:33:08 <thyko> dons: thanks
02:33:13 * thyko checks that out
02:37:34 <pzpz> oh, how sweet.
02:38:18 <Cale> I've been thinking that we should also collect up more trivial homework-like Haskell problems somewhere.
02:38:30 <dons> yes
02:38:34 <dons> proper introductory puzzles
02:38:46 <dons> split a list on 'n'..
02:38:55 <dons> print a number in binary..
02:39:13 <kosmikus> write the identity function
02:39:14 <Cale> yeah, little things like that -- maybe half the prelude :)
02:39:15 <norpan> bus time table
02:39:19 <norpan> :)
02:39:22 <dons> kosmikus: :)
02:39:38 <kosmikus> you'd be surprised how difficult that is :)
02:39:50 <Cale> id x = id
02:39:53 <Cale> oops!
02:39:59 <dons> "write your own prelude" sounds like a pretty good challenge
02:40:13 <dons> you'd have to work out flip,const, id, map, foldr, ...
02:40:35 <Cale> It's possible to do those for the most part from the types alone
02:41:00 <Cale> (which of course, makes them excellent puzzles :)
02:41:08 <dons> we could provide QuickChecks that told them if they go ttheir implementation right
02:41:33 <Cale> When teaching Haskell to my friend, I gave the monad instances for Maybe, List, and Reader as exercises.
02:41:34 <dons> Cale: shh.. we won't speak of @djinn ;)
02:41:45 <Cale> She solved them all :)
02:41:49 <thyko> no 'destructive updates', hmmm ...
02:42:11 <dons> worry not, thyko. it only makes your code simpler
02:42:49 <Cale> and when you really feel like you need them, there's a very nice formalism for getting things like that under control
02:43:03 <tibbe> Cale, http://www.mathbin.net/1873
02:43:17 <norpan> just provide quickchekc properties and sample input/output and don't reveal the function names
02:43:25 <dons> norpan: ah trikcy!
02:44:03 <Cale> tibbe: missed a Sigma
02:44:15 <tibbe> Cale, yes, latex didn't want to obey me
02:44:23 <tibbe> Cale, pretend it's there
02:44:23 <dons> so we were playing around with a lambdabot Show instance for functoins, that prints some of the domain of the function
02:44:32 <tibbe> Cale, should be Sigma star
02:44:37 <Cale> tibbe: right
02:44:49 <tibbe> Cale, looks reasonable?
02:45:15 <dons> norpan: like this:
02:45:16 <dons> *M> show not
02:45:18 <dons> "False -> True, True -> False"
02:45:19 <kosmikus> dons: only the domain?
02:45:27 <tibbe> Cale, delta* should be a delta with a roof but I couldn't write that (ie delta for whole strings)
02:45:29 <kosmikus> ah, I see
02:45:30 <dons> not only :)
02:45:38 <Cale> tibbe: almost -- you have to subtract tau- from A(delta*(q,w),w), not from the set of adds
02:45:54 <tibbe> Cale, ah yes, of course!
02:46:10 <kosmikus> dons: sounds good
02:46:13 <tibbe> Cale, so I should do a union with adds and A* and then substract right?
02:46:25 <dons> *M> take 50 $ show Char.ord
02:46:26 <dons> "'\\NUL' -> 0, '\\SOH' -> 1, '\\STX' -> 2, '\\ETX' -> 3"
02:46:47 <Cale> tibbe: depends on which order those two things happen in
02:47:08 <Cale> actually, if you say they're disjoint, then those operations commute
02:47:11 <Cale> so it doesn't matter
02:47:17 <tibbe> Cale, you're right, stops first then starts (A* \ stops) union starts
02:47:23 <tibbe> ok
02:47:52 <tibbe> Cale, alright, I really have to run now, thanks alot, if you have some more comments please write them here and I'll check them when I get back
02:48:03 <Cale> tibbe: okay, cool
02:48:08 <Cale> I plan to sleep :)
02:48:10 <tibbe> Cale, they're not disjoint since I'll restart some timers
02:48:16 <tibbe> Cale, gnight then! :)
02:48:19 * tibbe runs!
02:48:19 <Cale> tibbe: at the same step?
02:48:24 <tibbe> yes
02:48:29 <Cale> ah, okay
02:48:30 <tibbe> kinda
02:48:38 <tibbe> same step yes
02:48:40 <Cale> so yeah, you probably want removal first, and then addition
02:48:44 <tibbe> for loop transition
02:48:46 <tibbe> yes
02:49:45 <norpan> dons: looks nice
02:50:39 <dons> code's here if people want to play around with it: http://www.cse.unsw.edu.au/~dons/tmp/A.hs
02:50:45 <dons> might make a good plugin for lambdabot
02:51:20 <dons> if you can pick a representative selection from the type's inhabitants (i.e. not all of Char for ord)
02:52:39 * dons -> dinner
03:00:11 <norpan> dons: perhaps connect to arbitrary in some way
03:00:48 <norpan> bah, printf
03:01:06 <norpan> i especially dislike printf "%s -> %s, " (show x) (show y) ++ ppr xs
03:01:09 <norpan> mixing idioms
03:08:10 <dons> yeah, we should have a default case for printf that calls show, i've thought
03:08:23 <wy> >let bot=bot in bot
03:08:43 <dons> so have a few overlapping instances, and a instance Show a => PrintfArg a where ... to backup
03:08:57 <dons> > let bot=bot in bot :: ()
03:08:59 <lambdabot>  Exception: <<loop>>
03:09:17 <wy> Why can't my new ghc detect loops?
03:09:47 <dons> not sure. i noticed some ghc's do, some don't. i guess the rts is being tweaked a bit
03:09:51 <dons> could even be a bug?
03:10:12 <wy> I guess there is some switch
03:11:29 <Cale> It could also be something which is affected by optimisation
03:12:50 <JohnMeacham> ninjas. ninjas everywhere. they brought their own guitars.
03:13:03 <mux> morning all
03:14:11 <wy> *** Exception: stack overflow
03:16:37 <wy> Will ones=1:ones cause loops?
03:16:59 <JohnMeacham> wy: only if you try to follow it to the end.
03:17:05 <wy> > ones=1:ones
03:17:06 <lambdabot>  Parse error
03:17:21 <wy> > let ones=1:ones in ones
03:17:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:18:08 <wy> > are you alive?
03:18:08 <lambdabot>  Parse error
03:18:23 <wy> Oh... why
03:20:53 <malcolm_> dons: still waiting/unsure about my patches for fps?
03:26:52 <gds> > let ones = 1:ones in last ones
03:26:56 <lambdabot> Terminated
03:28:28 <wy> gds: why?
03:29:10 <wy> I still haven't figured out how to turn on loop detection in my ghc
03:30:32 <ms_> ok. is there some crazy reason why if a::Double, a^(2::Int) goes slowly, but a*a goes really really fast?
03:31:00 <ms_> the ^ is still there after simplification, switching to * is approx a doubling in performance
03:37:23 <pejo> Can I extract ordinary diff's from a darcs repository easily?
03:37:32 <wy> @kind int
03:37:34 <lambdabot> Not in scope: type variable `int'
03:38:59 <wy> let bot=bot in bot:[]
03:39:26 <Philippa> ms_: a^2 is always going to be slower than a*a unless it's directly optimised to it. How big's the gap?
03:40:27 <ms_> Philippa: um, well it was being used heavily in a findDisplacement method which was find the distance between two vector-points - standard pythagorous
03:40:43 <ms_> profiling showed that method was taking about 30% of the time
03:40:54 <ms_> switching to a*a reduced it to 0.8%
03:43:02 <int-e> @type (^)
03:43:04 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
03:44:07 <Lemmih> wy: Loop detection is always on. It can't be turned off.
03:44:10 <int-e> oh, ^ gets specialized ...
03:44:21 <int-e> that prevents inlining, doesn't it?
03:44:33 <wy> Lemmih: But why can't my ghci detect it?
03:44:54 <int-e> at least I remember such a side-effect.
03:44:55 <Lemmih> wy: Because it's not looping (apparently).
03:45:22 <wy> Lemmih: But this lambdabot can detect it
03:46:29 <Lemmih> wy: Lambdabot is compiling the code.
03:47:24 <wy> Lemmih: How can I do that too?
03:48:15 <Lemmih> wy: Why do you want to? You shouldn't depend on <<loop>> in any way.
03:48:52 <wy> Lemmih: but it's cool and I want to try it
03:50:19 <Lemmih> wy: ghc --make
03:50:40 <int-e> does ghc do constant folding? is there a list of primops that work with it?
03:50:51 <kzm> > let x = x in x
03:50:53 <lambdabot>  Add a type signature
03:51:04 <kzm> > let x = x in x :: ()
03:51:06 <lambdabot>  Exception: <<loop>>
03:55:06 <dons> malcolm_: sorry, they'll go in. just been busy
03:55:17 <dons> tthanks for reminding me.
03:55:46 <malcolm_> dons: I'll keeping pinging you until I see the patches turn up in my nhc98 repo nightly builds :-)
03:57:32 <wy> Lemmih: Thank you! Now I'm wondering how can I put some loops in to the code... It seems hard to fit the loops into main..
03:57:54 <dons> malcolm_: ok good!
03:58:43 <malcolm_> dons: ping :-)
03:58:48 <malcolm_> dons: ping :-)
03:58:59 <malcolm_> dons: etc ....
04:05:07 <wy> Is the case conditions simultaneous?
04:05:27 <dcoutts> wy, no, theu are checked in order
04:05:34 <dcoutts> theu/they
04:05:35 <Lemmih> dcoutts: Hi.
04:05:39 <dcoutts> hia Lemmih
04:06:31 <Lemmih> dcoutts: Any news on housing at hac07?
04:06:33 <wy> But why does this happen? http://paste.lisp.org/display/30867
04:07:29 <dcoutts> Lemmih, sorry, not yet, I've been v. busy. I'll go via a couple places on the way into the lab...
04:07:53 <dons> malcolm_: :) ok ok!
04:08:48 <Lemmih> wy: Why don't you derive Ord for Color?
04:09:30 <Lemmih> wy: 'case (a,b) of (x,_) -> y' is the same as 'case a of x -> y', btw.
04:09:32 <rc-1> is haskell a good language to write a 2d turn based game in?
04:09:42 <rc-1> know AI would be cake but worried about GUI
04:09:56 <JohnMeacham> haskell is a great language.
04:10:10 <Lemmih> I second that.
04:10:27 <rc-1> me phear monads :(
04:10:42 <wy> Lemmih: I just want to try defining compare. But you see it seems the case statements are not matched in order
04:11:01 <dcoutts> rc-1, I'd use Gtk2Hs with Cairo for the 2D graphics.
04:11:28 <rc-1> ah good i already know how to use GTK thanks
04:11:53 <Lemmih> wy: Are you familiar with '_'?
04:12:16 <wy> Lemmih: I see the problem. It's match that way.
04:12:16 <dcoutts> rc-1, oh good, you should find Gtk+ and Cairo are even easier to use in Haskell :-)
04:12:36 * dcoutts -> out
04:12:45 <rc-1> yeah the ruby bindings were a bit buggy/slow
04:13:01 <ibid> is there a copy of the STM video somewhere that's watchable on non-intel hardware?
04:14:06 <flux__> ibid, where's the intel-hw-watchable version?-)
04:15:31 <ibid> flux__: the regular place; you do need w32codecs if under linux
04:16:01 <flux__> the regular place for STM videos being..
04:16:13 <flux__> ah, lambda-the-ultimate :-)
04:16:46 <ibid> i thought you were just sarcastic and knew where it is :)
04:17:06 <flux__> hm, I wonder if I really have w32codecs.. because I've been able to watch the videos from msdn earlier, yet locate w32c finds nothing
04:17:47 <flux__> yes, apparently I do have
04:17:58 <flux__> so no luck for you, they probably really do require them ;)_
04:20:14 <ibid> yes, i know they do
04:20:24 <ibid> i was wondering if someone had reencoded it
04:23:03 * Lemmih wonders if his mencoder-fu is powerful enough.
04:25:25 <Lemmih> ibid: I can put up an AVI if you can wait a while.
04:25:52 <ibid> ok
04:26:32 <Xavier_> Hello sirs, sorry for the intrusion but I'm starting learning Haskell, and I'm having some issues with the (.) operator: I just don't understand how it works (or why it doesn't work).
04:27:24 <Xavier_> For example the type of "snd.fst" is ((a,b), b1) -> b, and yet applying "snd.fst" to ((1,2),3) yields a type inference error
04:27:56 <Xavier_> isn't "snd.fst a" just supposed to perform something like "snd(fst(a))"?
04:28:44 <ibid> why do you assume we are all sirs?
04:28:56 * psnl likes his knighthood
04:28:58 <ibid> no intrusion, that's what this channel is for :)
04:29:16 <Xavier_> Well I don't but I've got no idea how to say otherwise (not native english speaker)
04:29:24 <Xavier_> How would you have said it?
04:29:51 <ibid> Xavier_: the gender-neutral formal greeting is "sir or madam", but this is an informal forum, so just use "hi all", if anything
04:30:08 <ibid> or hello
04:30:11 <ibid> or something :)
04:30:28 <ibid> but assuming an all-male audience is not very nice and happens to be false here
04:30:30 <Xavier_> ibid > I don't know, "hi all" sounds somewhat impolite for what's pretty much my first time on the channel
04:30:44 <ibid> Xavier_: we're an informal bunch, we don't mind
04:30:57 <Xavier_> I do
04:31:06 <Syzygy-> Yo dude!
04:31:12 <ibid> > (snd.fst) ((1,2),3)
04:31:14 <lambdabot>  2
04:31:19 <ibid> Xavier_: that works here
04:31:20 <Xavier_> (thanks for the gender-neutral version by the way)
04:31:22 <Syzygy-> And dudettes, and dudes, and what nots.
04:31:39 <Xavier_> <ibid> > (snd.fst) ((1,2),3)
04:31:51 <ibid> Xavier_: you probably forgot the parentheses around snd.fst
04:31:54 <twanvl> snd.fst ((1,2),3) == snd . (fst (1,2),3)
04:32:01 <dons> Xavier_: yeah, you're just missing the parentheses
04:32:13 <dons> > snd (fst ((1,2),3))
04:32:15 <lambdabot>  2
04:32:16 <Xavier_> Ok so basically I was really applying snd. to (fst ((1,2),3)) due to function application precedence being higher than operator precedence?
04:32:24 <ibid> Xavier_: yes
04:32:28 <psnl> yeah
04:32:29 <dons> > (snd . fst) ((1,2),3)
04:32:30 <lambdabot>  2
04:32:33 * Xavier_ bangs head in the wall
04:32:42 <dons> > snd . fst  $ ((1,2),3)
04:32:43 <lambdabot>  2
04:32:51 <dons> f $  x = f x -- btw
04:33:16 <Xavier_> dons > yeah I know about the "$"
04:33:49 <psnl> Xavier_: there are two things to keep in mind: in a fp language, function application is normally top, since it how the whole language works. also, for C coders rule about putting brackets around anything where the order isn't clear works well.
04:33:51 <dons> great!
04:34:26 <Xavier_> psnl > ok, that's noted
04:34:29 <psykotic> $ is one of those tricks that's unreasonably useful
04:34:40 <psnl> yeah, use $ all the time
04:34:41 <dons> hehe
04:34:44 <psykotic> if you told someone about it they'd say "so what?" :)
04:34:56 <dons> psykotic: yeah. good point. like 'id' too
04:35:09 <dons> or even flip
04:35:11 <dons> and const
04:35:14 <Xavier_> well thanks to ibid, dons and the mighty lambdabot for easily solving my stupid problem
04:35:14 <psykotic> The Unreasonable Effectiveness of $
04:35:26 <ibid> Xavier_: another formal greeting is "ladies and gentlemen" :)
04:35:40 <ibid> Xavier_: of course, that refers to nobles, but who isn't nowadays ;)
04:35:45 <Xavier_> (and no you don't have to point out that lambdabot is a bot, i'm not *that* stupid)
04:36:04 <Xavier_> ibid > ooh I had completely forgotten about that one, it'd have been perfect
04:36:10 <Xavier_> anyway thanks everyone
04:36:11 * psnl once submitted a haskell assignment that use just funct $ map somehting $ filter a bit $ map $ yafunct $ .... $ input
04:36:17 <dons> lambdabot is mighty though, you're very correct there, Xa	
04:37:10 <psnl> the lords and ladies Temporal, Spiritual and Lambdabot .
04:37:47 <psykotic> Domo Arigoto, Lambda Roboto
04:37:47 <Xavier_> psnl > doesn't "$" get in the way of the lazy evaluation? (don't assume that I have any understanding about the semantics of lazy vs eager evaluation)
04:37:53 <psykotic> Arigato, even
04:38:05 <dons> Xavier_: nope.
04:38:19 <dons> > map (^2) $ [1..]
04:38:20 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
04:38:30 <psykotic> Xavier: it's exactly equivalent to "the empty string operator" except with difference precedence.
04:38:31 * Xavier_ feels stupid again
04:38:48 <dons> Xavier_: all good questions. don't worry :)
04:38:52 <Xavier_> dons > thanks for doing what I should've done in the first place -_-
04:41:52 <psnl> Xavier_: the trick to thinking about lazy eval is to work backwards from your IO. so print ("ssss"++"sss") is an action, so it needs its input to be evalutated, so you have to evalute the ++, so you have to have the two "sss".
04:42:55 <Xavier_> psnl > mmm ok, evaluating from the goal instead of evaluating from the means
04:43:28 <Maddas> psykotic: except for type inference :)
04:43:31 <Xavier_> which means that if some means are not necessary to reach the goal, they're not evaluated
04:43:38 <psnl> Xavier_: yeah
04:44:09 <Xavier_> In a word, the goals really have to justify the means, or the means are discarded. Nifty
04:44:31 <psnl> Xavier_: Isn't it cool?
04:44:39 <Xavier_> psnl > way cool
04:45:04 <Xavier_> Maddas > but the type inference is performed at compile time right? Isn't lazy evaluation more of a runtime semantic?
04:45:45 <Maddas> Indeed, I was talking about an aspect different from lazy evaluation.
04:46:13 <Xavier_> Oh damn I missed the fact that you were replying to psykotic, not psnl
04:47:06 <ibid> Xavier_: if you want to really understand lazy evaluation, find out what graph reduction is and do it by hand for some small terms
04:47:58 <Xavier_> ibid > noted, I'll do that
04:49:05 <ibid> Xavier_: in my opinion, graph reduction is the abstract semantics of what lazy evaluation is. of course, actual implementations optimize it quite a bit, but still preserving the observable semantics of it (mostly)
04:49:15 <expwiz> Hello. Is there any libraries for capturing audio signal from a mic and processing it in haskell?
04:49:28 <psykotic> graph reduction is only needed if you want to reason about space complexity
04:49:39 <psykotic> i.e. lazy evaluation rather than non-strictness as such
04:49:49 <ibid> as i said, lZ
04:49:55 <ibid> lazy evaluation :)
04:50:06 <psykotic> but the laziness doesn't affect the semantics
04:50:18 <ibid> psykotic: it does the space and time semantics
04:50:19 <psykotic> (except for things like unsafePerformIO)
04:50:25 <psykotic> those aren't semantics :)
04:50:33 <ibid> psykotic: yes they are :)
04:50:50 <psykotic> you can choose to call them whatever you want
04:51:36 <ibid> psykotic: for example, many haskell idioms (like tying the knot) became useless if the underlying semantics is not lazy eval
04:51:48 <ibid> psykotic: it's an operational semantics :)
04:51:50 <psykotic> obviously they are important in practice but as far as understanding the result of evaluating a program it is irrelevant. that is what i understand by semantics, e.g. denotational.
04:52:41 <ibid> psykotic: yes, if you only care about the normal form, then lazy evaluation is just an implementation technique, but in practice a lot of haskell idioms assume the operational model of laziness
04:53:35 <psykotic> sure
04:55:19 <ibid> Xavier_: here you see another feature of the channel: ask a simple question, and in a few minutes you get to read arcane discussion of details that don't matter for the original question :)
04:55:28 <ibid> (of course, that's one thing i love about this channel)
04:55:35 <pzpz> what exactly does it mean by GAST generating "common border values"
04:59:46 <dons> mm "Defining Cg, HLSL style vectors in Haskell" seems like an interesting questoin on the mailing list
05:04:51 <mux> dons!
05:16:10 <dons> mux!
05:16:16 * dons is about to head to bed
05:16:46 <mauke> what does Quantified type variable `a' escapes mean?
05:17:10 <dons> you've got foralls in the wrong place?
05:17:33 <mauke> but only in ghc-4.2, it seems
05:17:35 <dons> ?google  what does Quantified type variable `a' escapes mean
05:17:39 <lambdabot> http://www.cs.chalmers.se/~augustss/hbc/decls.html
05:17:39 <lambdabot> Title: Declarations and Bindings
05:17:42 <dons> heh
05:18:57 <mauke> my code: http://rafb.net/paste/results/2nACJg52.html
05:19:08 <mauke> (this works in ghc-6.6)
05:21:08 <dons> something that only works due to the impredicativity patches? perhaps check the user's guide for 6.6 in the 'type systems' section
05:21:42 <mauke> I hope it tells me how to make this work in 6.4 :-)
05:22:10 <dons> do you need the forall there?
05:22:51 <mauke> yes, because I want to apply f to both inet and inet6 stuff
05:26:52 <mux> dons: don't go to bed just right now :-)
05:26:59 <mux> dons: pm okay?
05:27:29 <dons> quick!
05:28:16 <dons> you know about email, right? :)
05:28:39 <pzpz> spam killed email.
05:28:54 <dons> procmail killed spam
05:29:08 <pzpz> only thing left then is procmail :(
05:29:13 <dons> and won the heart of the pure and chaste MUA
05:29:21 <mux> heh
05:29:30 <mux> I have to admit I didn't think about email :-)
05:29:43 <underzsof> VISIT : WWW.UNDERZSOFT.COM THE No1 WAREZ INSTANT DOWNLOADZ SITE THANKS
05:29:56 --- mode: ChanServ set +o dons
05:29:59 --- mode: dons set +b *!*n=cvdsfg@*.adsl.forthnet.gr
05:29:59 --- kick: underzsof was kicked by dons (dons)
05:30:02 <dons> got ya!
05:30:06 <pzpz> i told you, spam!
05:30:14 --- mode: ChanServ set -o dons
05:30:58 * kpreid finds his mail not dead, thanks to good filtering
05:32:51 <mauke> hah, fixed: http://rafb.net/paste/results/tE5zyC12.html
05:33:28 <dons> hehe
05:33:47 <dons> take that type system! bif pow zapp!
05:34:09 <mauke> yay for castPtr
05:35:14 <opqdonut> ?pl \x -> x{ foo = bar }
05:35:14 <lambdabot> (line 1, column 8):
05:35:15 <lambdabot> unexpected "{"
05:35:15 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
05:35:18 <opqdonut> ?pl \x -> x { foo = bar }
05:35:18 <lambdabot> (line 1, column 9):
05:35:19 <lambdabot> unexpected "{"
05:35:19 <lambdabot> expecting variable, "(", operator or end of input
05:35:23 <opqdonut> hrm
05:35:26 <mux> is there anyway to get back the -N option passed to a ghc 6.6 haskell program, for the number of threads?
05:35:27 <dons> custom parser, unlikely to handle record syntax
05:35:34 <opqdonut> dons: okay
05:35:51 <dons> it needs to be ported to import language.Haskell
05:36:09 <dons> mux, don't know of one. has come up a few times though .. we should ask!
05:36:22 <dons> you could always set an env var GHC_THREADS=8
05:36:26 <mux> ok
05:36:30 <mux> I'll dig in the GHC docs
05:37:08 <dons> (I had this problem in pqc too. we need a good solution)
05:37:32 <dons> someone was writing a script to work out the best value of 'N' for each machine, too
05:38:10 <mux> that's very hard to tell
05:38:20 <mux> it also depends on what the program is doing
05:38:33 <mauke> haha, it works!
05:38:40 <dons> I suppose usually you want -N to be around the same as the number of cores...
05:38:45 <mauke> (well, write and _exit do, at least)
05:38:50 <dons> of course, you might want more haskell threads
05:38:56 <dons> but you'll probably not want more os threads
05:39:01 <norpan> i think double the number of cores
05:39:29 <mux> you might also want some unlimited number of OS threads if you know the OS is using M:N threading
05:39:32 <dons> it all really depends on the amount of io/computation is going on
05:39:45 <mux> it's really a tough question and I don't think there's a good universal answer
05:39:58 <dons> but yeah, some way to pass the -N arg to the rts into the program would be good
05:40:08 <dons> since pqc does: ./pqc n +RTS -N n
05:40:12 <dons> which is less than ideal
05:40:39 <dons> mux, wouldn't we want to have the haskell rts do the M:N matching?
05:40:49 <dons> or we'd end up with H:M:N
05:41:38 <dons> i'd be worried about running an unlimited number of haskell threads on an unlimited number of os threads mapping them down to N real threads
05:42:08 <dons> bed! night all.
05:42:14 <mux> gn dons :)
05:43:26 <mux> I think I'll put my code in the "concurrency demos" section, which is empty for now
05:54:18 <mux> http://haskell.org/haskellwiki/Concurrency_demos
05:54:21 <lambdabot> Title: Concurrency demos - HaskellWiki, http://tinyurl.com/yyh7xe
05:54:22 <mux> comments appreciated
05:55:18 <dons> mux, I'm thinking perhps put that on its own page, since there'll be many concurrency demos in the future. perhaps http://haskell.org/haskellwiki/Concurrency/Zeta
05:55:20 <lambdabot> Title: Concurrency/Zeta - HaskellWiki, http://tinyurl.com/yyogo6
05:55:37 <dons> and then the Concurrency page itself can be a list of concurrency demos
05:55:45 <dons> (there's already one on STM that should be on the list, for exapmle)
05:55:56 <mux> oki, I'll change that right now :-)
05:57:16 <dons> mux, you might put in some benchmarks showing how to run it, and the speedup due to -N / proper smp
05:57:34 <mux> btw, this shows a bug in the haskell coloring code, the (**) operator is badly parsed
05:57:38 <dons> also, module Main where is uneeded
05:57:46 <mux> ok
05:57:48 <mux> and ok :)
05:58:06 <dons> also, the type wraps for zetaRange
05:58:12 <dons> you could get that all on one line
05:58:26 * mux nods
05:58:34 <dons> though the constraints are quite big. maybe some type synonyms
05:58:42 <dons> (Floating (Complex a), RealFloat a, Integral b) => . eh?
05:58:52 <mux> weird
05:59:01 <mux> this is GHCi generated type constraints :D
05:59:11 <dons> i'd put this on one line:
05:59:12 <dons> cut (x,y) n =
05:59:13 <dons>   (x, x + mine - 1) : cut' (x + mine) size (y - mine)
05:59:16 * mux nods
05:59:37 <mux> done
05:59:50 <dons> and line up your <- in the do bocks
05:59:51 <dons> blocks
06:00:07 <dons> looks good. well done
06:00:21 <mux> I'll add comments to the source code, benchmarks
06:00:24 <mux> and move it to its own page
06:00:31 <mux> mm, I don't get your last comment about the do blocks?
06:01:07 <dons> the <- should really line up in:
06:01:08 <dons>   (t, n, s) <- getParams
06:01:08 <dons>   childs <- zipWithM thread (repeat s) (cut (1, n) t)
06:01:09 <dons>   results <- mapM takeMVar childs
06:01:29 <dons> also, since you're just inferring the most general types, you could leave off the type decls altogether
06:01:38 <dons> since zetaRange :: (Floating (Complex a), RealFloat a, Integral b) => Complex a -> (b, b) -> Complex a
06:01:41 <dons> doesn't tell me much :)
06:02:01 <mux> yeah, it's just that GHC then emits a warning with -Wall :-P
06:02:17 <dons> (or constrain the types to something more efficient?
06:02:48 <mux> I have removed the type decl for now
06:02:51 <mux> and have aligned the <-
06:03:20 <dons> i'd leave off the all type decls
06:03:24 <mux> ok
06:03:31 <dons> i.e. main :: IO (), getParams :: IO (Int, Int, Complex Double) (maybe)
06:03:33 <mux> I'll also align the '=' in the cut' definition
06:03:43 <dons> getParams could be a where clause of main
06:03:44 <mux> cut :: (Integral a) => (a, a) -> a -> [(a, a)]
06:03:47 <mux> I like this one though :)
06:04:36 <mux> how does it look like now?
06:06:03 * mux aligns more things
06:06:21 <dons> nice. night!
06:06:42 <dons> when you're done, be sure to drop a url to haskell-cafe@
06:06:50 <mux> sure
06:06:54 <mux> enjoy your sleep :)
06:08:57 <mux> I'd be glad if anyone in here could improve the cut function
06:09:31 <mux> it's rather dumb as of now, dividing the work between the N threads, and adding the modulo to the first thread only
06:10:07 <bringert> dons: latest HWN PDF posted. Thanks!
06:17:48 <expwiz> Anyone have any idea how to record sound from a mic in haskell?
06:18:32 <mwc> expwiz, I imagine you could write an FFI interface to whatever C api your OS uses. If you use a unix, just start reading from /dev/dsp
06:19:18 <expwiz> mwc: ok
06:22:20 <expwiz> Is it alot of work writing an FFI interface?
06:22:49 <earthy> no
06:23:57 <expwiz> ok
06:24:01 <mwc> Something like c2hs can do most of the work for you
06:24:08 <earthy> it's mainly a bunch of declarations like foreign import ccall "DSL_userProperties_FindProperty"          primUserProperti
06:24:11 <earthy> esFindProperty      :: UserPropertiesObject a -> CString -> IO Int
06:24:23 <earthy> (sorry for the lousy wrapping)
06:25:38 <expwiz> ok thanks
06:26:40 <mwc> hehehehe
06:26:42 <mwc> dd if=/usr/lib/ghc-6.6/ghc-6.6 of=/dev/dsp
06:26:47 <mwc> sounds like modem tones :)
06:26:57 * earthy laughs
06:27:03 <earthy> 'don't do that then'. :)
06:27:12 <mwc> I'm thinking we should file a bug report
06:27:50 <mwc> and require ghc to produce executables that sound like famous classical pieces
06:28:02 * mwc votes for Wagner's Ride of the Valkyries
06:30:05 <mwc> There are strange passages that are almost musical
06:30:10 <mux> I vote for pink floyd :-)
06:30:11 * ValarQ votes for Beethoven's Piano Sonata No. 14
06:30:28 <mwc> it's like those periodic sequences in the decimal expansion of pi or something
06:30:30 <mux> or Tchaikovsky's opening 1812
06:32:26 <mwc> There's this strange section that sounds like a bass and a guitar solo from a metal track
06:32:49 <mwc> I could see myself listening to this if it was set to techno :)
06:34:55 <eviltwin_b> hm, that should only require a custom ELF linker script :>
06:35:04 <mwc> dd if=/usr/bin/g++ of=/dev/dsp doesn't sound nearly as good. I think this proves the superiority of Haksell
06:37:27 <earthy> eviltwin_b: assuming, ofcourse, that you can divvy up the blocks so they don't distort the sound too much
06:37:58 <LoganCapaldo> audio/machine code polyglot! woot
06:52:37 <metaperl> Does anyone have an idea of how to program with Ranged sets? An example would be nice
07:20:05 <earthy> hm. transpose is slightly more powerful than I thought. ;)
07:23:35 <mux> my wiki skills are severely limited
07:23:43 <mux> how would I create a new page in the haskell wiki?
07:25:38 <Lemmih> mux: Enter the url and edit the page?
07:26:27 <mux> d'oh. thanks :-)
07:45:31 <CosmicRay> I'm reading up on QuickCheck.  Was there supposed to be some way to specify QuickCheck tests in comments in code?
07:50:04 <CosmicRay> It seems that some people are giving test properties in comments.  does quickcheck find them?
08:02:39 <shapr> CosmicRay: Never heard of that. I just use the boring stuff where I specify a property.
08:02:46 <psykotic> @check (\xs ys -> (transpose [xs, ys]) == (map (\(x,y) -> [x,y]) $ zip xs ys)) :: [Int] -> [Int] -> Bool
08:02:47 <lambdabot>  Falsifiable, after 3 tests: [-1,0,-1], [-3,3,-4,-1]
08:05:26 <shapr> mmm, ice cream for breakfast
08:05:33 <psykotic> breakfast of champions!
08:05:54 <vincenz> breakfast of champion freezebrains
08:06:28 <LPhas> installing lambdabot
08:06:28 <LPhas> Building lambdabot-4.0...
08:06:29 <LPhas> scripts/BotPP.hs:21:17:
08:06:29 <LPhas>     Could not find module `Data.ByteString.Char8':
08:06:29 <LPhas>       it was found in multiple packages: fps-0.8 base
08:06:33 <LPhas> mmh
08:06:37 <vincenz> 6.^?
08:06:39 <vincenz> 6.6?
08:06:42 <LPhas> 6.6
08:06:50 <LPhas> i tried to unregister fps
08:06:52 <vincenz> Yeah might wanna dump fps-0.8
08:07:09 <LPhas> ghc-pkg unregister fps-0.8 ?
08:07:15 <LPhas> tried before, doesn't work
08:07:20 <vincenz> sudo?
08:07:40 <LPhas> no, but it was unregistered, mmh, let's try
08:08:01 <LPhas> osx is a little large on permissions
08:08:28 <LPhas> Setup.hs: cannot satisfy dependency fps>=0.7
08:08:29 <LPhas> geh
08:09:07 <psykotic> has anyone played around with the new test case shrinking in quickcheck 2?
08:09:26 <LPhas> ?seen dons
08:09:27 <lambdabot> dons is in #haskell.hac07, #ghc, #haskell-overflow, #haskell and #Haskell. I last heard dons speak 1h 35m 1s ago.
08:10:28 <Igloo> He's sleeping
08:10:39 <LPhas> I see
08:10:43 <Igloo> What are you trying to build? Just removing that build-dep should work
08:11:12 <LPhas> yeah i'm lurking on .cabal files
08:12:10 <LPhas> but there are 2 lambdabot.cabal files
08:12:19 <LPhas> one lambdabot.cabal
08:12:27 <LPhas> and one lambdabot.cabal.ghc-6,6
08:12:36 <shapr> psykotic: I played with shrinking some months ago with a preview version. Did you have questions about it?
08:12:38 <LPhas> maybe this one is supposed to take care of this
08:13:52 <LPhas> in fact lambdabot.cabal.ghc-6.6 doesn't contain fps as dependency
08:14:06 <LPhas> anyone knows how to say to Cabal to use this instead of the other?
08:14:43 <Igloo> cp lambdabot.cabal.ghc-6,6 lambdabot.cabal   :-)
08:15:01 <LPhas> ok :P i was wondering about a less "manual" solution :P
08:15:12 <ms_> recompile cabal?
08:15:52 <LPhas> well, cp worked :)
08:18:15 <vincenz> hiya zarvok
08:18:54 <zarvok> hey vincenz
08:19:31 <vincenz> whats new
08:19:58 <zarvok> not too much.  swamped by work and grad school apps
08:20:52 <zarvok> and with you?
08:21:00 <LPhas> uhm i think that installing Haskell programs need more user friendlyness
08:21:29 <vincenz> same
08:21:30 <LPhas> cabal-install was a very cool project!
08:22:09 <LPhas> i tried a develop version from xerox when he was in SoC
08:22:14 <LPhas> very, very, very cool
08:33:56 <emu> erm, when a program spits out "<<loop>>" what does that mean? ghc is solving the halting problem?
08:34:17 <zarvok> sometimes it can detect looping programs, but not in every case, so it's not a solution for the halting problem
08:34:27 <emu> yea =)
08:34:31 <emu> interesting
08:38:49 <ibid> emu: you get that message when you have a situation like f = e where e evaluates to f
08:39:03 <ibid> for example:
08:39:08 <ibid> > let x = x in x
08:39:09 <lambdabot>  Add a type signature
08:39:17 <ibid> > let x = x :: Int in x
08:39:19 <lambdabot>  Exception: <<loop>>
08:39:43 <ibid> emu: in any situation where the evaluation of an expression demands the evaluation of the same expression
08:41:01 <ibid> (due to laziness, this does not happen if the recursive mention of the variable is inside a (non-strict) constructor call
08:41:04 <ibid> (
08:41:05 <ibid> )
08:41:06 <norpan> since you have finite memory, it's not impossible to solve the halting problem, just hard
08:41:06 <ibid> )
08:41:12 <ibid> hah
08:41:22 <ibid> yes but this has nothing to do with solving the halting problem
08:41:28 <norpan> of course not
08:41:41 <norpan> well, it solves it for a small subset of programs .)
08:41:53 <ibid> hoh
08:42:04 <emu> yes
08:42:22 <emu> basically what I'm doing is this: constructing a tree from a list of elements which indirectly reference each other
08:42:48 <emu> i'm doing it with a recursive definition, ie. the subtasks of a node are (map findNodeRecursively names)
08:42:57 <ibid> emu: you're forgetting a constructor somewhere
08:43:05 <ibid> can't help better without seeing the code
08:43:20 <emu> i'm also adding in the parent links, which is causing the loop. i can see why, though
08:43:38 <ibid> it shouldn't
08:43:45 <ibid> you have a bug somewhere
08:43:53 <ibid> and it's not the concept of uplinks
08:46:17 <emu> yea gonna think about this some more
09:07:44 <shapr> shazam!
09:08:21 <araujo> wowo ya!
09:23:17 <Lemmih> Heh, running HAppS on House would be neat.
09:23:44 <Taral> You know, I didn't much like HAppS... way complicated. :(
09:25:30 <LPhas> HAppS on House O_o
09:26:03 <Lemmih> You get a lot of things for free (like ACID behavior) which can be hard to hack on your own.
09:26:04 <vegai> Taral: unfortunately, the guys who know about it enough are too busy to write extensive docs, it seems.
09:26:22 <Taral> Well, that's a shame. I won't use it if I can't understand it.
09:26:59 <Taral> Last time I checked, it looks like someone had only read half the SEDA paper and then tried to implement it, too.
09:27:51 <wchogg> Is anyone still actively working on House?
09:29:21 <LPhas> it's an insane project
09:29:45 <LPhas> very cool on the paper
09:29:53 <LPhas> especially the part on P-Logic
09:30:01 <LPhas> for demonstrate proprieties of the OS
09:30:17 <wchogg> Yeah, I know.  I'm actually working on something related to it for a graduate OS class.
09:30:43 <LPhas> but nowadays you can't seriusly think to write an OS
09:31:51 <wchogg> Well, maybe not a commercially viable OS but I think there's still some value to specially designed operating systems for high security situations.
09:32:28 <LPhas> well, yes i think that is true
09:32:38 <LPhas> but we are talking of the Haskell World
09:32:51 <LPhas> where all begins something and no-one ends nothing
09:33:13 <Maddas> Which is any different from the rest of the software world?
09:33:15 <Maddas> ;-)
09:33:18 <LPhas> nothing eheh
09:33:27 <LPhas> well, there's a differnce, maddas
09:33:32 <LPhas> being haskell so cool
09:33:52 <wchogg> But yeah, my group has been taking House as a base and looking at including capabilities as a protection mechanism.
09:34:10 <LPhas> started programs are already usable enough to make you think "whoa if someone finished it!"
09:35:03 * edwardk waves hello.
09:36:08 <LPhas> by the way, House is surely fascinating
09:37:01 <wchogg> I haven't been able to find any source code for the actual OSker kernel that's supposed to be the next step beyond the toy kernels they construct in the paper.
09:37:26 <psnl> @seen ndm
09:37:28 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 20h 19m 18s ago, and .
09:38:36 <LPhas> mmh for the little that i lurked House code i found it undocumented not well commented
09:39:06 <LPhas> if you want to build an OS i think that you need to gather as much support as you can
09:39:46 <LPhas> these aren't anymore Torvalds times where you can send a mail saying "i want to build a kernel"
09:44:43 <Taral> @seen JohnMeacham
09:44:44 <lambdabot> JohnMeacham is in #haskell. I last heard JohnMeacham speak 5h 34m 36s ago.
09:44:45 <Taral> @seen JohnMeacham-
09:44:46 <lambdabot> I haven't seen JohnMeacham-.
09:44:50 <Taral> @seen JohnMeacham_
09:44:51 <lambdabot> JohnMeacham_ is in #haskell and #Haskell. I don't know when JohnMeacham_ last spoke.
09:45:00 <Taral> #haskell and #Haskell?
09:45:03 <Taral> is there a difference?
09:45:18 <LPhas> for Colloquy seems not
09:45:27 <edwardk> taral: its based on the name they typed in when they joined the channel
09:45:34 <LPhas> oh
09:45:36 <Taral> bizarre
09:45:46 <Taral> map toLower, anyone?
09:45:46 <chessguy> so how is he in both then?
09:45:47 <kosmikus> and how can you be in both?
09:45:56 <edwardk> hrmm
09:46:08 <chessguy> @seen chessguy
09:46:08 <edwardk> that would be a bug =)
09:46:09 <lambdabot> You are in #scheme and #haskell. I last heard you speak just now.
09:46:19 <vincenz> chessguy should be in #oasis
09:46:26 <edwardk> @seen edwardk
09:46:27 <lambdabot> You are in #haskell. I last heard you speak just now.
09:46:30 <edwardk> hrmm
09:46:34 <chessguy> i should?
09:46:44 <edwardk> doesn't take it in mixcase any more
09:55:59 <eviltwin_b> mixed case was causing it do some rather bizarre things
09:56:16 <eviltwin_b> (of which there are a few leftovers)
09:57:57 <vincenz> @see me
09:57:57 <lambdabot> I haven't seen me.
09:58:01 <vincenz> @seen you
09:58:02 <lambdabot> I haven't seen you.
09:58:19 <vincenz> @seen enlightenment
09:58:19 <lambdabot> I haven't seen enlightenment.
09:59:48 <SimonRC> What's the word on Nat as a builtin type in Haskell'?
10:00:17 <SimonRC> I'd be nice to be able to say "length [1..] == 5" and get False rather than _|_.
10:00:50 <Igloo> It doesn't need to be built-in. Just define it and use genericLength
10:01:58 <chessguy> @type foldr
10:02:00 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
10:02:53 <chessguy> > foldr (\x y (+ (y - x))) 0 [1..5]
10:02:54 <lambdabot>  Parse error in pattern
10:03:22 <chessguy> @type (\x y (+ (y - x)))
10:03:23 <lambdabot> parse error on input `)'
10:04:45 <chessguy> hmm, how do i use folder to take [1,2,3,4,5] and return (1-0)+(2-1)+(3-2)+(4-3)+(5-4)
10:04:53 <chessguy> *foldr
10:05:26 <vincenz> difficultly
10:05:54 <chessguy> guess i should just write a function to do it
10:06:20 <Binkley> @where "fold diagrams"
10:06:20 <lambdabot> diagrams" http://cale.yi.org/index.php/Fold_Diagrams
10:06:43 <Binkley> chessguy: look at that, then figure out what you would substitute in for "f"
10:07:24 <chessguy> cool, looks interesting
10:08:03 <chessguy> is that a picture of Cale?
10:08:47 <Binkley> i assume so
10:10:05 <chessguy> i may have to use one of those other ones
10:10:12 <chessguy> or just write the darn function myself
10:10:18 <Binkley> it's not hard
10:10:35 <blsecres> is there a proper way to detect undefined values in a Data.Array?  _|_ hasn't become part of the standard yet has it?
10:10:40 <Binkley> well, the way you've stated the problem, you may want to use map instead
10:11:15 <vincenz> Binkley: it's rather ugly to do, you need to use two different values from 2 different iterations, not to mention flip a functio
10:11:41 <blsecres> > Data.Array.array (1,3) [(1,1), (3,3)] ! 2 == _|_
10:11:41 <lambdabot>  Parse error
10:11:43 <vincenz> I know :)
10:12:00 <Binkley> vincenz: well, i can write it as (sum . map ((-) 1)), but maybe he really meant something more general?
10:12:15 <vincenz> vegai: yeah and then zipWith (=) l (tail l)
10:12:23 <vincenz> Binkley: no you missed his point
10:12:35 <vincenz> Binkley: it's always getting the difference between ax-1 and ax
10:12:52 <SimonRC> chessguy: how about "sum $ zipWith (-) nums (0:nums) where nums = [1..5]"
10:13:07 <Binkley> so what he really meant was taking [a,b,c,d] and returning (b-a) + (c-b) + (d-c)?
10:13:12 <SimonRC> I think
10:13:19 <vincenz> > let foo l = sum $ zipWith (-) l (0:l) in foo [1..5]
10:13:20 <lambdabot>  5
10:13:39 <vincenz> @check \l -> let foo l = sum $ zipWith (-) l (0:l) in foo l == last l
10:13:39 <lambdabot>  Add a type signature
10:13:44 <SimonRC> depending in where the 0 came from,...
10:13:47 <vincenz> @check \l :: [Int] -> let foo l = sum $ zipWith (-) l (0:l) in foo l == last l
10:13:47 <lambdabot>  Parse error
10:13:54 <vincenz> @check \(l :: [Int]) -> let foo l = sum $ zipWith (-) l (0:l) in foo l == last l
10:13:55 <lambdabot>  Parse error in pattern
10:13:58 <SimonRC> maybe he wants "sum $ zipWith (-) nums (tail nums) where nums = [0..5]"
10:14:15 <vincenz> @check \l -> let foo l = sum $ zipWith (-) l ((0::IntegeR):l) in foo l == last l
10:14:16 <lambdabot>  Not in scope: type constructor or class `IntegeR'
10:14:19 <vincenz> @check \l -> let foo l = sum $ zipWith (-) l ((0::Integer):l) in foo l == last l
10:14:20 <lambdabot>  Exception: Prelude.last: empty list
10:14:27 <psnl> SimonRC: um, maybe he wants a pony. its a weird question, since I'm sure there is a better way to do the maths
10:14:33 <vincenz> @check \l -> (not . null?) l ==> let foo l = sum $ zipWith (-) l ((0::Integer):l) in foo l == last l
10:14:33 <lambdabot>  Not in scope: `?'
10:14:37 <vincenz> @check \l -> (not . null) l ==> let foo l = sum $ zipWith (-) l ((0::Integer):l) in foo l == last l
10:14:38 <lambdabot>  OK, passed 500 tests.
10:14:52 <Binkley> @hoogle pony
10:14:53 <lambdabot> No matches found
10:14:56 <Binkley> :..-(
10:15:02 <vincenz> @google pony
10:15:05 <lambdabot> http://www.pony.org/
10:15:19 <chessguy> SimonRC, i always want to start at 0
10:15:19 <psnl> Binkley: you are stuck down in Cambridge, right?
10:15:30 <Binkley> psnl: why "stuck"?
10:15:48 <psnl> s/stuck/working/
10:15:55 <Binkley> heh
10:15:56 <Binkley> yes
10:16:04 <Binkley> I hardly see it as being stuck, though :-)
10:16:05 <chessguy> what i really meant was taking [a,b,c,d] and returning (a-0) + (b-a) + (c-b)
10:16:14 <chessguy> + (d-c)
10:16:24 <psnl> dont they still say "I want $foo, and a pony" for wierd or hard requests?
10:16:47 <Binkley> psnl: I haven't heard anyone here say that, but I've heard it lots from people in the US
10:17:17 <Binkley> as in, http://sc.tri-bit.com/images/2/23/pony.jpg
10:17:31 <chessguy> haha
10:17:34 <chessguy> that's a good one
10:21:46 <CosmicRay> so what does everyone think is a good new name for MissingH?  I'm thinking "Haskell Utility Library"
10:21:53 <SimonRC> chessguy: ah, waitamo, I didn;t thi9nk about mathematical optimisations...
10:22:42 <psnl> SimonRC: get rid of the brakets
10:22:47 <SimonRC> chessguy: obviously, (a-0) + (b-a) + (c-b) + (d-c) is equal to (a+d)
10:22:53 <SimonRC> psnl: so I see.
10:22:55 <SimonRC> D'oh
10:23:04 <psnl> SimonRC: are you next door?
10:23:15 <SimonRC> VMCR
10:23:47 <psnl> cool, I need to use the printer, so I'll come down and fwap you
10:23:59 <shapr> CosmicRay: I think you should break up the pieces and stick them into the standard libs.
10:24:42 <chessguy> whoah
10:25:02 <chessguy> i hadn't thought about that
10:25:07 <CosmicRay> shapr: I will be breaking it up into pieces, but not everything will go into the standard libs
10:25:18 <chessguy> isn't it just d?
10:25:18 <CosmicRay> shapr: for instance, ConfigParser probably won't.
10:25:19 <blsecres> there'd be some resistance, i.e. the split/join arguments on the mailing lists
10:25:31 <CosmicRay> and MissingH itself will still exist for the list/string things that won't go into the standard libs
10:25:42 <CosmicRay> though I'll try to get as much as possible into them.
10:25:49 <shapr> spiffy
10:26:34 <shapr> You could call it "Cosmic Rays of Enlightenment" that's so unacademic you'd probably end up with every non-formally educated Haskellers using it immediately =)
10:27:51 <shapr> vegai, Taral: Please tell me what parts of HAppS need more docs!
10:28:03 <Taral> um, it's been a while
10:28:16 <Taral> let me fetch the source again and see
10:28:25 <shapr> spiffy
10:28:29 <eviltwin_b> hm, how'd the web page go? :>
10:28:39 <shapr> eviltwin_b: You mean the ones I was working on yesterday?
10:29:20 <Taral> Ah, yes.
10:29:37 <vegai> hands-on guide to a small, complete application would probably be nice.
10:29:53 <vegai> is a forum application too big?
10:30:00 <Taral> how do I write my own protocol handler?
10:30:09 <eviltwin_b> there was jokingh last night that you'd run off to cons up a page for happs llc
10:30:23 <shapr> Taral: I don't know, but I'll look into it and get back to you with what I find out.
10:30:32 <Taral> I mean..
10:30:35 <shapr> eviltwin_b: Actually, I was working on that page.
10:30:37 <Taral> handler :: Conf -> [ServerPart (EvParPure st)] -> Handler st
10:30:37 <Taral> handler conf ss = SyncH $ return (work, listen conf)
10:30:37 <Taral>     where work ef = evParM (\evh ev -> ef (fmap return evh) ev) $ compileServerP
10:30:37 <Taral> arts ss
10:30:38 <eviltwin_b> heh
10:30:39 <Taral> is not readable.
10:31:39 <shapr> Well, the ServerPart code is nifty but not well documented :-)
10:31:53 <Taral> Yeah, but have you looked at the definition of Handler?
10:32:14 <Taral> Like I said, it looks like someone read half the SEDA paper and tried to implement it.
10:32:53 <shapr> I think musasabi wrote that code, I don't yet know all of the HAppS codebase. But I'm learning!
10:33:09 <Taral> have fun :P
10:33:14 <Taral> I gave up trying to learn it.
10:33:35 <shapr> vegai: Did you see the wiki I wrote for HAppS?
10:33:48 <MarcWeber> Hi. I've some problems downloading repos using darcs: (libcurl: couldn't resolve host). curl itself doesn't have any problems. Do you know whats going on here?
10:36:04 <MarcWeber> darcs is using a foreign function get_curl which I couldn't find in curl source.
10:36:56 <psnl> MarcWeber: is get_curl being fed a IP or a address?
10:37:08 <Taral> MarcWeber: Check the darcs source for it.
10:37:15 <psnl> grep
10:37:34 <Taral> ok, I'm going to go play a game
10:39:04 <shapr> Aw, I thought it was a Haskell game!
10:39:29 <vegai> shapr: I'm checking it out.
10:41:06 <vegai> shapr: looks pretty sweet. Now, the guide part would create that step-by-step
10:41:17 <LPhas> bwhawhawha
10:41:36 <LPhas> i was talking to a friend of mine of the first year of CS
10:41:48 <LPhas> "do you still fighting with C?"
10:41:50 <LPhas> "yeah"
10:42:02 <LPhas> "did you begin to see pointers?"
10:42:14 <LPhas> *$FRIENDOFMINE disconnected
10:42:23 <shapr> vegai: Did you see xslt.hs in the same repo?
10:43:09 <vegai> C pointers are like parentheses in lisp: at the time of satori, they disappear
10:43:47 <LPhas> vegai: satori?
10:44:01 <vegai> shapr: Yes. What's that, a book database?
10:44:05 <vegai> LPhas: enlightenment
10:44:23 <LPhas> vegai: sorry, i still don't understand you :(
10:44:39 <vegai> they stop being a problem
10:44:48 <LPhas> vegai: ah ok ehehe
10:45:22 <LPhas> vegai: i don't know why but i was thinking about elightement DM
10:45:27 <LPhas> :P
10:45:43 <MarcWeber> psnl: I don't know darcs is using foreign import ccall "hscurl.h get_curl" get_curl :: CString -> CString -> CString -> CString -> CInt -> IO CInt  so get_curl should be also defined in get_curl.h which I can't find. Will have to look for it
10:45:50 <shapr> vegai: 1. change_state 2. xslt 3. wiki Those are the steps
10:45:57 <shapr> I'll write it all out explicitly.
10:46:05 * MarcWeber will be back in 7min
10:46:17 <psnl> MarcWeber: does it build?
10:46:28 <psnl> MarcWeber: libcurl in the linker path?
10:47:33 <vegai> shapr: please :)
10:47:59 <CosmicRay> oo, where is this hscurl.h from?
10:48:05 <CosmicRay> I am calling /usr/bin/curl manually in hpodder
10:55:20 <edwardk> @seen dons
10:55:20 <lambdabot> dons is in #haskell.hac07, #ghc, #haskell-overflow, #haskell and #Haskell. I last heard dons speak 4h 20m 49s ago.
10:55:55 <vegai> Hmm, I may have found a strategic mistake in my trying to read other peoples' Haskell code
10:56:13 <eviltwin_b> ?
10:56:26 <shapr> vegai: oh?
10:56:45 <vegai> In other languages, it seems that there's no need to really deeply think about single pieces of code
10:56:55 <shapr> I realize how many levels of Haskell there are above me when I read code that others have written.
10:57:06 <shapr> vegai: Yes!
10:57:10 <shapr> That happens to me!
10:57:18 <vegai> i.e. it works better when I try to 'join the flow' of the code
10:57:41 <vegai> but in Haskell, it seems I need to actually speak out loud what each line means
10:58:29 <shapr> To me it seems that small pieces of Haskell code can totally change the way the all the code works.
10:58:47 <vegai> data WikiState = WikiState (M.Map String String) deriving (Read,Show)
10:59:14 <lispy> i find that some languages, like C#/VB.NET, require me to think deeply about lines of code.  Those property accessors may actualy be hinding arbitrary side effects
10:59:33 <shapr> vegai: questions about that line of code?
10:59:38 <shapr> lispy: That's just scary
11:00:11 <vegai> shapr: as an example..
11:01:10 <vegai> I'm hoping to see huge improvements in my Haskell-reading abilities now, of course.
11:02:15 <vegai> but I also have a fear that the 'flowing' style of read just fits me better
11:02:43 <vegai> no, not fear. Anyway.
11:03:18 <shapr> Do you understand the wiki code?
11:05:12 <shapr> Or have any questions at all about it?
11:18:40 <james_w> Hi, all, I just started writing http://paste.debian.net/17475 and I wondered what the nicest way to handle it syntax wise was.
11:19:52 <james_w> As you can see I need to compare parts of the types, but in one of the guards I need to do an operation on the whole object (to get it in to the first case). Is the best way to just use the constructor to just put the bits back together again?
11:20:26 <vincenz> james_w: remove the outer ()
11:20:40 <vegai> shapr: I probably have plenty. To start, where is the 'singleton' function defined?
11:21:06 <LPhas> ?seen dcoutts
11:21:07 <lambdabot> dcoutts is in #haskell.hac07, #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 7h 8m 16s ago.
11:21:29 <james_w> vincenz: thanks, I hadn't tried to actually compile this yet. Does that affect my question at all?
11:21:43 <vincenz> no, sorry
11:21:49 <vincenz> was too lazy to read the entire q
11:21:52 <vincenz> but what you want is very simple
11:21:54 <vincenz> let me demonstrate
11:22:01 <vincenz> you know the (x:xs) pattern right?
11:22:02 <james_w> I'm sure it is.
11:22:08 <james_w> Yes.
11:22:25 <vincenz> > let foo l@(x:xs) = l ++ xs in foo [1..4]
11:22:26 <lambdabot>  [1,2,3,4,2,3,4]
11:22:30 <vincenz> you use @
11:22:37 <vincenz> variable@pattern
11:22:57 <james_w> perfect, thanks.
11:27:13 <vegai> shapr: ach. Nevermind that. It seems it's too late for this, perhaps tomorrow :)
11:28:31 <metaperl> Paul Johnson, the author Ranged Sets, is not here, right?
11:29:39 <metaperl> and no one has any idea when this module might be used. So I will email him
11:33:22 <alexj__> taral: I am actually working on cleaning up the handler stuff right now.
11:33:51 <alexj__> i agree it is a bit obscure.
11:34:23 <alexj__> but I am curious what was in the SEDA paper that you think is missing here?
11:35:50 <mauke> is haskell.org down?
11:37:11 <shapr> @index singleton
11:37:11 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set
11:37:42 <shapr> vegai: singleton is part of Data.Map.Map, it creates a Map with one key value pair.
11:37:43 <nominolo> is it a bug or a feature when I use Alex with the "monad" (default) wrapper and it doesn't compile because "Not in scope `alexEOF' " ?
11:44:23 <vincenz> nominolo: yes
11:44:26 <vincenz> a feature
11:44:33 <vincenz> "monad" requires you to define your own monad
11:46:46 <nominolo> hm, the doc is .. well, improvable ..
11:46:58 <nominolo> but thx
11:47:39 <monochrom> <3
11:47:40 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
11:47:49 <vincenz> >3
11:48:13 <monochrom> X X X
11:48:14 <dmead> >:)
11:55:46 <tibbe> good evening #haskell
11:56:46 <vincenz> monochrom: follow the advice of lambdabot!
11:57:20 <monochrom> I'd love to, but something discomforts me.
11:57:28 <shapr> salut tibbe
11:57:29 <vincenz> write!
11:57:35 <monochrom> You know, the problem with blogs is...
11:57:41 <vincenz> ?
11:57:47 <vincenz> exposure?
11:58:03 <tibbe> shapr: salut! :)
11:58:19 <monochrom> If I have 100 blogging friends, and I respond to all of them, I end up creating 113 blogging accounts.
11:58:25 <vincenz> no you don't
11:58:26 <vincenz> anonymous
11:58:26 <shapr> ?seen SyntaxNinja
11:58:33 <lambdabot> I saw SyntaxNinja leaving #haskell 20h 19m 27s ago, and .
11:58:49 <vincenz> monochrom: it supports anonymouse comments
11:58:52 <mauke> ?vixen is haskell.org down?
11:59:06 <lambdabot> Ooh, functional programmers are so hot!
11:59:10 <monochrom> These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
11:59:33 * vincenz tsks
11:59:45 <monochrom> OK, anonymity is cool.
12:00:12 <monochrom> one night stand > creating accounts  XD
12:00:40 <Binkley> monochrom: the solution is OpenID
12:00:45 <Binkley> I mean, the solution to your blogging problem
12:00:50 <Binkley> I don't have a solution to your prostitute problem
12:01:04 <Excedrin> blogs should disallow comments, let reddit/digg or whatever handle comments
12:01:23 <vincenz> digg/reddit is a) temporary, b) not immediately visible to those reading something
12:01:29 <Binkley> yeah, I really want qwe1234 trolling my blog too
12:01:42 <Excedrin> well, that's solvable too
12:02:26 <monochrom> I be damned!  I actually have an account on Blogger.com already?!!
12:02:36 <Excedrin> I've been meaning to write a greasemonkey script that lets you ignore users (perhaps auto-downvote too)
12:03:09 <monochrom> OH hahahaha I be damned!  It's using my Google Groups account.
12:03:18 <vincenz> yes blogger is tied to google accout
12:03:21 <vincenz> \o/ Google
12:03:33 <monochrom> OK I <3 vincenz.
12:04:27 <monochrom> Gosh these prostitutes are certainly unionizing to better serve the customers!
12:06:27 <monochrom> "We are now federated so that anyone you visit knows your personalized condom preference!"
12:06:43 <tibbe> Excedrin: I agree with the disallow comments, publishing is so cheap now that if you have something important to say put it on your own damn blog! mail works just fine for feedback/corrections
12:09:19 <tibbe> the guy behind haxe looks productive
12:11:32 <shapr> beschmi's shim looks really cool, has anyone tried it?
12:12:21 <palomer> don't the new changes in the typesystem let Map be part of a typeclass?
12:12:27 <palomer> man i'm losing my english
12:12:32 * palomer kicks korean in the buns
12:12:52 <shapr> What typesystem changes?
12:13:11 <palomer> typeclass annotations in the Constructors
12:13:49 <shapr> Can you point to some code that demonstrates that? Or something that describes it more?
12:14:03 <palomer> okay!
12:14:08 <palomer> as soon as the idea becomes clear in my head
12:14:50 <MarcWeber> psnl: No I can't build darcs at the moment because I'm lacking Text.Html which hasn't been installed with my base package from gentoo portage.
12:15:06 <palomer> functions like lookup and member should be part of a typeclass
12:15:16 <palomer> which both Map k and List k implement
12:15:38 <palomer> don't you guys agree?
12:16:25 <shapr> I prefer to have them be part of the module.
12:16:41 <shapr> Then I could use Set.lookup and Map.lookup separately.
12:17:00 * shapr thinks
12:17:12 <palomer> you could use them separately even if they were part of a typeclass
12:17:24 <shapr> Yeah, I see what you mean.
12:17:29 <shapr> The problem would be defining the typeclass.
12:17:38 <palomer> how so?
12:18:01 <shapr> Have you seen Conor and Ross's Data.Traversable ?
12:18:33 <palomer> Map k implements Traversable
12:19:06 <palomer> seems like a fancy Functor
12:19:12 <shapr> Or Conor's Applicative?
12:20:17 <palomer> nope
12:21:11 <shapr> There was a long thread on the libraries list about a typeclass similar to that.
12:21:32 <shapr> I think it ended up with several separate typeclasses.
12:22:02 <shapr> Maybe this was about Okasaki's general purpose composable datatypes?
12:22:06 <shapr> I think it was...
12:22:08 * CosmicRay releases hpodder 0.99.0 with sweet multithreaded downloading happiness
12:23:52 <shapr> palomer: I remember that different flavors of datatypes had different operations, some would naturally have lookup and member (Map), but others would have member and not lookup (Set), so it ended up being cut into a bunch of different typeclasses, and people said it would likely be easier to just export the functions from the modules.
12:24:16 <shapr> What's the name of Okasaki's datatype libraries that Pseudonym is/was maintaining?
12:24:54 <wchogg> Edison?
12:24:56 <shapr> yes!
12:24:59 <shapr> thanks!
12:25:01 <CosmicRay> oh, and missingh 0.16.3 with generalized tools supporting apt-like progress meters
12:25:06 <palomer> aok, which typeclass has lookup?
12:26:17 <shapr> I don't remember, but that should give you enough keywords to find the discussion.
12:30:06 <palomer> I remember Cale saying that both Map and List's lookup had different typeclass constraints
12:30:15 <palomer> so they couldn't be part of the same typeclass
12:30:59 <swiert> hiya shapr.
12:31:09 <palomer> however, the revamped typesystem lets you put the typeclass constraints in the constructors (I think)
12:31:29 <palomer> I'll have to ask Cale about that
12:31:40 <mbishop> Cale: way to troll reddit :P
12:32:25 <monochrom> Cale is trolling reddit?!
12:32:46 <monochrom> Like "Everyone should get a math degree before attempting programming"? :)
12:33:15 <Binkley> link plz
12:34:13 <wchogg> Has anyone digested the Lightweight Static Capabilities paper?
12:34:42 <jeroeng> monochrom: Would that be something you'd agree on?
12:34:54 <monochrom> I'd agree it's trolling. XD
12:35:16 <jeroeng> I suppose so :)
12:35:55 <tibbe> wchogg: I'm going to read it tomorrow if I have the time
12:36:07 <tibbe> monochrom: link!
12:36:14 <tibbe> wchogg: you read it?
12:36:19 <monochrom> I made it up.
12:36:24 <tibbe> aha
12:36:35 <wchogg> tibbe:  Yes, and I'm having a bit of trouble grokking it.
12:36:43 <tibbe> wchogg: ok
12:38:47 <mbishop> Binkley: http://programming.reddit.com/info/so4y/comments
12:38:50 <lambdabot> Title: Does type inference have to suck? (reddit.com), http://tinyurl.com/yxncfl
12:39:25 <Binkley> which one is Cale?
12:39:36 <Binkley> and I agree with the comment on the blog post that said "do technical complaints have to suck?"
12:39:37 <mbishop> well the source article is
12:40:11 <Binkley> well, commenting on an article linked from reddit isn't "trolling reddit" :-)
12:40:13 <mbishop> well, comments of the source article :P
12:40:40 <Binkley> and I agree with the hell out of Cale's comment, too.
12:40:40 <mbishop> well read the replies on reddit, sure seem to be about Cale :P
12:40:44 <tibbe> wchogg: I need to print it before I read it, this stuff is hard enough without reading on a screen
12:40:52 <Binkley> GHC's error messages have improved by leaps and bounds over the past six years
12:41:11 <Binkley> though I'd be happy to believe that ML's error messages still suck.
12:44:01 <dmead> yes
12:44:03 <dmead> they do
12:44:59 <tibbe> I've been thinking that it might be a good idea to have ghc do what javac does on error, print the expression and underline it with ^^^^^^^^^^^^^
12:46:39 <mahogny> well. I would love if ghc did a better job. but with the automatic type inference and the lack of things you actually can err on syntactically, it's hard to improve
12:47:51 <dmead> tibbe: yea i like that carrots on errors thing too
12:47:59 <shapr> hoi swiert
12:48:16 <vincenz> tibbe: that doesn't work well
12:48:22 <vincenz> unification is nonlocal
12:48:29 <shapr> What about type error slicing?
12:48:44 <tibbe> vincenz: so there's one of two expressions that has the wrong type
12:48:49 <tibbe> so highlight both
12:49:17 <tibbe> if two cannot be unified print them both with source loc and highlight
12:50:25 <tibbe> vincenz: or what is the problem, could you give an example?
12:52:29 <mahogny> tibbe, the whole thing has to match or it is all at fault :)
12:53:05 <tibbe> mahogny: I'm still not sure what you mean
12:53:10 <shapr> tibbe, vincenz: This is a good way to do it --> http://www.macs.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/slicing.cgi
12:53:18 <lambdabot> Title: A Type Error Slicer for MiniML, http://tinyurl.com/y2g6wf
12:53:19 <tibbe> at some point during the unification two type variables doesn't match right?
12:56:11 <tibbe> shapr: I find it a bit confusing with boxes that highlights spaces between functions/operators
12:57:23 <tibbe> shapr: I actually found reading that more difficult that the Expected/Inferred ghc gives me
12:57:48 <shapr> I look at my code and typecheck it visually. When I get type errors it means I missed something.
12:58:53 <shapr> So this sort of display would work well for me.
13:01:46 <monochrom> I don't have time to implement all these things I and everyone want.
13:02:00 <monochrom> (Translation: I wouldn't get paid for it. :) )
13:09:57 <trez> how to convert Int -> Double?
13:10:35 <Saizan> fromInt
13:10:59 <Saizan> > fromInt 1 :: Double
13:11:00 <lambdabot>  Not in scope: `fromInt'
13:11:07 <Saizan> > fromIntegral 1 :: Double
13:11:08 <lambdabot>  1.0
13:11:35 <trez> ah
13:11:40 <trez> thank you
13:11:43 <Saizan> np
13:16:02 <tibbe> ?type fromInteger
13:16:04 <lambdabot> forall a. (Num a) => Integer -> a
13:16:07 <tibbe> ?type fromIntegral
13:16:08 <lambdabot> forall b a. (Num b, Integral a) => a -> b
13:16:28 <tibbe> hmm
13:19:11 <monochrom> It works for a wide range of types.
13:19:16 <tibbe> ?type foldl
13:19:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:19:34 <monochrom> For example if you want int to complex, it is still fromIntegral
13:20:32 <tibbe> ?hoogle (a,b,c) -> a
13:20:33 <lambdabot> No matches, try a more general search
13:20:48 <monochrom> That one you have to hand-write.
13:20:53 <tibbe> ok
13:21:06 <tibbe> I'll keep it as a lambda then
13:23:05 <pejo> tibbe, where type errors are detected depends on a bunch of stuff, I think Heerens thesis contains a good (not very long) overview of different approaches and their pros and cons.
13:23:24 <tibbe> pejo: ok
13:23:56 <tibbe> pejo but for just that one case where you get one Expected and one Inferred line plus row and colums I think the columns could be highlighted
13:25:06 <tibbe> it says right on the haxml website that there's a SAX light parser in there but I can't find it...
13:25:44 <tibbe> Text.XML.HaXml.Parse looks like an DOM parser to me...
13:26:31 <dha> Question: Are questions welcome here? :-)
13:26:34 <tibbe> oh wait, I think I found it
13:26:41 <tibbe> dha: that's a question ;)
13:26:42 <tibbe> yes
13:26:59 <dha> tibbe - yes, I knew that. :-)
13:27:16 <tibbe> so you wanted retroactive permission to ask that?
13:27:55 <dha> it's more like, either it would be a joke or you'd have kicked me. I figured I couldn't go *that* far wrong. :-)
13:28:01 <CosmicRay> heh
13:28:14 <dha> ok. so I'm trying to learn haskell. (go me!). I'm reading Thompsons Craft of Functional Programming.
13:28:30 <tibbe> dha: ok :)
13:28:55 <dha> And I"m getting stuck at chapter 3. I'm trying to use fromInt(), but hugs is spitting at me about that function and I can't figure out why.
13:29:10 <CosmicRay> @hoogle fromInt
13:29:11 <psnl> what is it saying?
13:29:11 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
13:29:11 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
13:29:12 <dha> unless hugs has changed sufficiently since the 2nd ed to no longer work with it.
13:29:27 <CosmicRay> what's the code snippet you're looking at?
13:29:42 <dha> Hugs> :load ex3
13:29:42 <dha> ERROR "ex3.hs":53 - Undefined variable "fromInt"
13:29:42 <CosmicRay> btw, since haskell doesn't use parens for function calls, the () is not used to designate functions in Haskell
13:29:54 <dha> ex3 has a function that uses fromInt
13:29:56 <CosmicRay> I mean, can you paste that source code somewhere?
13:29:57 <neonse> use fromIntegral, fromInt has been removed
13:30:00 <CosmicRay> @paste
13:30:01 <lambdabot> http://paste.lisp.org/new/haskell
13:30:01 <dha> CR -  so noted.
13:30:08 <w-ber> A little help would be appreciated with a parse error. Pasting...
13:30:10 <lisppaste2> w-ber pasted "A parse error I don't understand" at http://paste.lisp.org/display/30899
13:30:17 <dha> ok, a second...
13:30:52 <gour> CosmicRay: missingh lib can be used to eg. call haskell from python?
13:30:59 <CosmicRay> w-ber: you need to set it up more like:  let iAcc' = if foo then iAcc + 1
13:31:18 <CosmicRay> gour: MissingPy is my python library, and it so far is used only to call python from haskell
13:31:32 <w-ber> CosmicRay: Okay, I didn't know I can use if-then in an expression like that.
13:31:39 <CosmicRay> gour: mainly because calling haskell from python messed with my head, and I didn't have any need for it anyway.
13:31:43 <lisppaste2> dha pasted "fromInt" at http://paste.lisp.org/display/30901
13:31:48 <CosmicRay> w-ber: everything is an expression in haskel
13:31:55 <CosmicRay> so yup, that's the way to do it.
13:31:57 <w-ber> CosmicRay: I know, but it hasn't sinked in yet. :)
13:32:10 <dha> at least I assume that's the problem area as fromInt isn't anywhere else
13:32:16 <CosmicRay> dha: ok, it looks like it's just a simple case of fromInt being renamed I guess
13:32:26 <CosmicRay> w-ber: I understand
13:32:28 <gour> CosmicRay: ahh, i'm thinking about pida ide http://pida.berlios.de which is written in python and ability to write plugins in haskell?
13:32:29 <monochrom> w-ber: factor out "iAcc' = "
13:32:29 <lambdabot> Title: Home - PIDA
13:32:35 <dha> that makes sense. how would I find what it's renamed to?
13:33:01 <monochrom> It is easiest to think of haskell's if-then-else as C's ?:
13:33:13 <CosmicRay> gour: you probably want something more like hsplugins then, if I remember correctly.  I don't know if MissingPy will help you out all that much.  Maybe it could give you a good starting point though.
13:33:21 <CosmicRay> I'd be happy to have patches to add calling Haskell from Python to it
13:33:23 <w-ber> Another complaint is that who the heck named read and show? :)
13:33:27 <CosmicRay> monochrom: yes
13:33:38 <CosmicRay> err, nm, I read that as "is it" instead of "it is"
13:33:53 <monochrom> Haha the ?: at the end tripped you!
13:34:07 <CosmicRay> yes it did
13:34:12 <lisppaste2> neonse annotated #30901 with "works" at http://paste.lisp.org/display/30901#1
13:34:44 <CosmicRay> funny how the mind works.  my brain must have seen it as a sentence ending in a ?, but then as I read the sentence, I understood that the ?: was there for C
13:34:55 <dha> aha. thanks.
13:35:01 <gour> CosmicRay: then, one can use C as the common denominator?
13:35:02 <tibbe> anyone have experience with haxml?
13:35:09 <neonse> they changed the hugs library
13:35:11 <CosmicRay> gour: heh
13:35:18 <dha> but is there some general mechanism for finding something like that? I see this as a potential recurring issue.
13:35:24 <CosmicRay> dha: the original type signature would still work with the new one
13:35:34 <CosmicRay> dha: honestly I have never heard of this happening before.  let me google.
13:35:47 <CosmicRay> dha: are you using the 2nd ed of the book?
13:35:56 <lisppaste2> w-ber annotated #30899 with "Solution by CosmicRay & monochrom" at http://paste.lisp.org/display/30899#1
13:36:57 <dha> CR - yep
13:37:06 <dha> brb
13:37:17 <tibbe> why does xmlParse assume I want to parse a file? that makes no sense
13:37:19 <neonse> I don't think this is widespread, I only know of fromInt
13:37:52 <w-ber> How fast is supposed array access to be in Data.Array? Is it really O(1)?
13:38:43 <monochrom> Yes.
13:39:10 <lisppaste2> tibbe annotated #30899 with "How about this?" at http://paste.lisp.org/display/30899#2
13:39:38 <mbishop> aren't most arrays that store their length as the first byte or two typically O(1)?
13:39:53 <monochrom> Yes.
13:39:58 <tibbe> that was officially stupid, I should have read the first paste
13:40:00 <dha> b
13:40:02 <tibbe> sorry
13:40:10 <monochrom> | is cool
13:40:37 <tibbe> but it was like that in the original xD
13:41:09 <monochrom> Now I challenge you to provide an ArrowChoice version!
13:41:15 <tibbe> :)
13:41:25 <tibbe> i need to sort out my xml problems
13:41:29 <tibbe> libraries....
13:41:33 <w-ber> Profiling data says my program is spending 40% of its time on accessing an array. I'm trying to figure out how to speed that part up, but since it's already O(1)...
13:41:56 <w-ber> Changing the array to the unboxed version has little to no effect.
13:42:05 <w-ber> Well, unsurprisingly, I think.
13:42:08 <monochrom> If you do not use the // operator to make new arrays.
13:42:33 <w-ber> Not in that part.
13:42:43 <Cale> What type of array?
13:42:48 <w-ber> values = filter (/= 0) $ map (g!) cells
13:42:52 <monochrom> Perhaps 40% is ok.
13:42:54 <Cale> Just a UArray?
13:42:59 <tibbe> but ffs, the whole of haxml assumes i want to parse files, I don't!
13:43:12 <tibbe> that's a so artificial limitation
13:43:13 <w-ber> Array, indexes are (Int, Int) and data Int.
13:44:11 <LoganCapaldo> @hoogle (a -> b -> (b, c)) -> [a] -> [c]
13:44:12 <lambdabot> No matches, try a more general search
13:44:19 <lispy> tibbe: iirc, there is an interface that works with non-files
13:44:39 <tibbe> lispy: which one? I looked through the modules without finding anything
13:44:46 <LoganCapaldo> @hoogle ((a,b) -> (c,b)) -> [a] -> [c]
13:44:47 <w-ber> monochrom: The C++ version I wrote of the same algorithm performs in around 30 ms on the same data while the Haskell version takes 1.5 seconds. I've been tinkering with the latter for a day. (The first (obvious, trivial) version took 80 seconds, so this is already an order of magnitude better. :)
13:44:47 <lambdabot> No matches, try a more general search
13:44:58 <lispy> ?hoogle readXml
13:44:59 <lambdabot> No matches found
13:45:16 <LoganCapaldo> @hoogle mapFold
13:45:16 <lambdabot> No matches found
13:45:22 <LoganCapaldo> @hoogle foldMap
13:45:23 <lambdabot> No matches found
13:45:30 <LoganCapaldo> @hoogle mapWith
13:45:31 <lambdabot> Data.IntMap.mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
13:45:31 <lambdabot> Data.Map.mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
13:45:34 <lispy> tibbe: i'll go look and get back to you in a minute or two
13:45:36 <tibbe> lispy: I think there is one function that expects the filename and its content and you can abuse that by providing something else than the file's content
13:45:41 <tibbe> still, it's stupid
13:45:41 <LoganCapaldo> I fail
13:45:43 <dha> ok. back to the book for me now. Thanks for the help. I'm sure you'll see me again. :-)
13:45:50 <monochrom> That hurts. But one needs to consider a larger context.
13:45:53 <tibbe> lispy: thanks
13:46:17 <LoganCapaldo> Is there a map-like function that threads a second paremeter thru?
13:46:35 <Cale> @type mapAccumR
13:46:36 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:46:39 <Cale> @type mapAccumL
13:46:41 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:46:48 <LoganCapaldo> Cale: Thanks
13:46:48 <CosmicRay> LoganCapaldo: are you thinking perhaps also of foldl or foldr
13:47:05 <LoganCapaldo> CosmicRay: Thank you, but I'm pretty sure I am not :)
13:47:24 <lispy> tibbe: well, if it takes the file name but doesn't open a file then it's that way because that's the interface that parsec provides (for better error messages)
13:48:03 <monochrom> tibbe: xmlParse does not read from a file.
13:48:10 <tibbe> lispy: I guess I'll abuse that then
13:48:25 <lispy> tibbe: xmlParse' :: String -> String -> Either String Document
13:48:38 <lispy> tibbe: yeah, just pass in "" for the file name
13:48:45 <tibbe> lispy: ok
13:49:17 <tibbe> lispy: is it lazy so it'll be more like a stream parser?
13:49:19 <monochrom> lispy, tibbe: same for xmlParse
13:50:45 <lispy> tibbe: i don't think  it's lazy
13:50:54 <lispy> tibbe: but only because lazy parsers are very hard to make
13:51:03 <tibbe> lispy: ok
13:51:04 <monochrom> Parsec is emphatically not lazy.
13:51:14 <lispy> monochrom: but do they use parsec?
13:51:33 <LoganCapaldo> Cale: Perfect! thanks again
13:51:45 <monochrom> Text.ParserCombinators.HuttonMeijerWallace is a predecessor of Parsec.
13:51:52 <Cale> LoganCapaldo: no problem
13:52:34 <tibbe> naming a module after the authors must break every guideline for module naming there is :)
13:53:01 <lispy> heh, true
13:54:06 <w-ber> tibbe: Unless the module implements an algorithm named after people. Think RSA.
13:54:15 <tibbe> w-ber: yes
13:54:25 <tibbe> HMW
13:54:32 <tibbe> kinda hard to pronounce
13:54:45 <lispy> and HM is confusable with type inference :)
13:54:52 <tibbe> :)
13:55:35 <w-ber> How low-level can you get with Haskell? Could you write an operating system?
13:55:46 <lispy> w-ber: it's been done actually
13:55:56 <mbishop> hmm
13:55:58 <w-ber> Why doesn't that surprise me? :)
13:56:04 <mbishop> !hoogle
13:56:09 <mbishop> how do you use that crap again
13:56:15 <Cale> @hoogle
13:56:15 <lambdabot> HOOGLE - Haskell API Search
13:56:16 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
13:56:16 <lambdabot>  
13:56:21 <mbishop> @hoogle house
13:56:22 <lambdabot> No matches found
13:56:26 <mbishop> bleh
13:56:27 <Cale> @where house
13:56:27 <monochrom> Like @hoogle a->b
13:56:27 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
13:56:35 <mbishop> ahh
13:56:37 <Cale> hoogle is for searching for functions
13:56:58 <mbishop> right, forgot heh
13:59:27 <tibbe> what's the emacs key-comb to jump to next error?
14:00:26 <w-ber> House begs the question "is there something that hasn't been done in Haskell?". :)
14:00:56 <mbishop> I can't run haskell on my (soon to arrive) hp jornada 720 :[
14:01:12 <mbishop> oh and I can't run haskell on my nintendo ds lite :)
14:01:47 <lispy> iirc, it runs on a zarus though
14:02:13 <mbishop> lispy: what architecture is the zaurus?
14:02:15 <tibbe> @hoogle fromEither
14:02:16 <lambdabot> No matches found
14:02:26 <lispy> yhc and jhc are your best bets if you are serious about running haskell programs on those sorts of devices
14:02:27 <tibbe> @hoogle right
14:02:28 <lambdabot> Control.Arrow.right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
14:02:28 <lambdabot> Prelude.Right :: b -> Either a b
14:02:28 <lambdabot> Distribution.InstalledPackageInfo.copyright :: InstalledPackageInfo -> String
14:02:36 <lispy> mbishop: no clue, but i would guess something based on arm :)
14:02:49 <tibbe> i found a use for fromEither
14:02:52 <mbishop> well the hp jornada 720 uses a strongarm
14:03:19 <lispy> mbishop: well, then, it may be easier than you thought :)
14:03:20 <mbishop> but as far as I know, there isn't a haskell compiler for strongarm
14:03:21 * mbishop shrugs
14:03:41 <lispy> going from arm -> strongarm is probably pretty easy, i would imagine
14:03:58 <lispy> i think the reason jhc works is because it compiles to ansi C
14:04:42 * mbishop holds his nose
14:09:58 <_matthew-> zaurus is strongarm
14:10:49 <_matthew-> I thought nintendo stuff was ppc?
14:11:03 <cjeris> DS is ARM9.
14:11:18 <tibbe> can you using deriving on a data type that has already been declared, they didn't derive show on some data type and i need it for debugging
14:11:36 <lispy> tibbe: sadly no
14:11:42 <tibbe> :(
14:11:59 <tibbe> unpacking xml is no fun, billions of nested constructors even for the simplest xml
14:12:10 <_matthew-> cjeris: ahh, interesting. tnx
14:12:21 <cjeris> s/unpacking xml/xml/ -- xml: reinventing the s-expression, badly, 35 years late.
14:12:22 <lispy> tibbe: you might be able to accomplish this with TH, but if you have the source, that's going to be the easiest i think
14:12:25 <w-ber> Text.Regex seems a bit awkward when you're used to Perl...
14:12:38 <_matthew-> how expensive are IORef's to write?
14:12:55 <lispy> tibbe: i agree, i sent in a patch to make haxml automatically generate constructor functions
14:13:06 <lispy> tibbe: iirc, it's been applied in the dev branch of haxml
14:13:51 <resiak> speaking of s-exps...  anyone know of a prewritten parser for them?  I'm sure it would take about 10 lines with parsec but...
14:15:14 <Excedrin> there's this: http://www.defmacro.org/ramblings/lisp-in-haskell.html
14:15:18 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell, http://tinyurl.com/yyr8sf
14:15:26 <resiak> Hrm, yeah.  I could use that.
14:16:09 <lisppaste2> metaperl pasted "I thought my accumulator would've come out reversed..." at http://paste.lisp.org/display/30904
14:19:43 <Excedrin> metaperl: the fst of splitAt' is reversed, but why would xs be reversed?
14:20:00 <metaperl> the fst? fst refers to tuples...
14:21:01 <Excedrin> splitAt' returns a tuple
14:21:29 <metaperl> Excedrin - yes
14:21:32 <metaperl> @type fst
14:21:34 <lambdabot> forall a b. (a, b) -> a
14:21:37 <metaperl> sorry i got disconn'ed
14:22:07 <metaperl> the expression x:acc should be reversing the input list as it builds the accumulator
14:23:09 <metaperl> [1,2,3] would be 1:acc then 2:1:acc then 3:2:1:acc
14:23:50 <tibbe> I want the whole expression to be Nothing if one element of a list is Nothing
14:23:51 <metaperl> well, i'm shutting down... I will chat when I get home
14:24:08 <tibbe> @hoogle [Maybe a] -> Maybe [a]
14:24:09 <lambdabot> No matches, try a more general search
14:24:29 <SamB> > sequence [Just 1, Just 2, Nothing]
14:24:31 <lambdabot>  Nothing
14:24:40 <SamB> > sequence [Just 1, Just 2, Just 3]
14:24:42 <lambdabot>  Just [1,2,3]
14:25:01 <SamB> tibbe: I guess you want sequence
14:25:11 <tibbe> :)
14:25:17 <tibbe> ?type sequence
14:25:18 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
14:25:31 <tibbe> hoogle should have figured that out ;)
14:25:42 <SamB> well, this is only, what, hoogle 3?
14:25:54 <SamB> also I hear the web interface is less strict
14:26:01 <SamB> @where hoogle
14:26:02 <lambdabot> http://www.haskell.org/hoogle
14:29:38 <monochrom> I want Nothing from Haskell!
14:30:10 * SamB wonders how to replace the list monad with a monad that runs things in parallel...
14:30:34 <LoganCapaldo> map . forkIO ? <g>
14:30:44 <SamB> no no...
14:30:48 <SamB> > map . forkIO
14:30:49 <lambdabot>  Not in scope: `forkIO'
14:31:04 <SamB> @type map . Control.Concurrent.forkIO
14:31:06 <lambdabot>   Couldn't match `a -> b' against `IO GHC.Conc.ThreadId'
14:31:06 <lambdabot>    Expected type: IO () -> a -> b
14:31:34 <LoganCapaldo> good thing I was joking :)
14:32:26 <SamB> anyway, am thinking that mplus would need to to do something with forkIO or `par`
14:33:04 <monochrom> Step 1. Create a class MonadList to capture all the list methods you need.
14:33:11 <tibbe> yech, ugly ugly code!
14:33:31 <SamB> monochrom: I don't believe I need anything but MonadPlus
14:33:35 <monochrom> Step 2. Rewrite your code so that [a] becomes MonadList m => m a
14:33:48 <monochrom> Oh!  Right, but you still need step 2.
14:34:07 <monochrom> Correction.  Step 2.  Rewrite your code so that [a] becomes MonadPlus m => m a
14:34:09 <SamB> I would obviously need to alter my calling code to use the new monad, but that would be short work...
14:34:21 <SamB> oh, well, I'd also need to alter my type synonym
14:34:25 <monochrom> Step 3.  Implement instance MonadPlus Parallel where ...
14:34:48 <SamB> it is of course step 3 that I'm wondering about...
14:34:52 <monochrom> Step 4.  In the calling code, ask for Parallel a instead of [a].
14:35:24 <monochrom> Looks like newtype Parallel a = IO a  :)
14:35:30 <monochrom> or even IO [a]
14:36:14 <SamB> what would mplus look like?
14:36:35 <monochrom> some forkIO business, followed by ++ for list.
14:37:23 <SamB> @type par
14:37:25 <lambdabot> Not in scope: `par'
14:37:32 <SamB> @type Control.Concurrent.par
14:37:34 <lambdabot> Not in scope: `Control.Concurrent.par'
14:37:38 <SamB> @hoogle par
14:37:39 <lambdabot> Control.Parallel.par :: a -> b -> b
14:37:39 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
14:37:39 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
14:37:46 <monochrom> Yeah I miss par, GpH, etc.
14:37:53 <SamB> "I miss"?
14:38:10 <monochrom> Those projects have been sleeping since GHC 4.x.
14:38:11 <SamB> I thought par was here and/or back?
14:39:45 <dobblego> if I have a function f :: a -> (b -> c), is there some way to redefine the b -> c as it would exist in a state monad?
14:39:59 <SamB> x `par` y = unsafePerformIO (do forkIO (touch x); return y) -- or some such
14:41:05 <monochrom> OK, if it's available, that will work.
14:41:32 <SamB> on the other hand, maybe I ought to try using some sort of arrays for my state values before worrying about CPU utilization...
14:46:27 <tibbe> @pl \x -> "\"" ++ x ++ "\""
14:46:27 <lambdabot> ('"' :) . (++ "\"")
14:46:39 <tibbe> oh, that's readable!
14:47:21 <monochrom> Yeah, append a quote, then prepend a quote.
14:47:48 <dons> morning
14:48:14 <kfish> moin dons
14:49:13 <Cpudan80> Hey - can you guys tell me what's wrong with this statement block (4 lines)
14:49:21 <Cpudan80> simplify (Add x y)
14:49:22 <Cpudan80>         | (simplify x) == (Num 0) = (simplify y)
14:49:24 <Cpudan80>         | (simplify y) == (Num 0) = (simplify x)
14:49:26 <Cpudan80>         | otherwise = (Add (simplify x) (simplify y))
14:50:08 <Pseudonym> I can see a couple of things.
14:50:13 <Pseudonym> But does it not work?
14:50:18 <Cpudan80> no
14:50:25 <monochrom> What is "Num"?
14:50:42 <Cpudan80> I should tell you that at the top...
14:50:44 <Cpudan80> we have
14:50:48 <Cpudan80> data Expr = Num Int
14:50:55 <Cpudan80> and some other things...
14:51:08 <monochrom> does "Num 0 == Num 0" work?
14:51:14 <dons> this is exactly the kind of disruption i've been talking about: "Multi-core may be bad for Java" .. when bloggers start saying that, you know its a good sign for those langs already there for the multicore boundary event. :)
14:51:43 <dons> (this guy http://www.devwebsphere.com/devwebsphere/2006/11/multicore_may_b.html)
14:51:45 <lambdabot> Title: /dev/websphere: Multi-core may be bad for Java, http://tinyurl.com/yl67y4
14:51:52 <Cpudan80> Pseudonym: like what?
14:52:31 <Pseudonym> Like you're evaluating simplify x and simplify y multiple times.
14:52:44 * monochrom throws up his hands.
14:53:26 <lisppaste2> Excedrin annotated #30904 with "improved splitAt'" at http://paste.lisp.org/display/30904#1
14:53:35 <Cpudan80> Pseudonym: so it should be like
14:53:37 <Pseudonym> Secondly, you're using equality testing when pattern matching would be MUCH more efficient.
14:53:52 <Cpudan80> simplify (Add x y)
14:53:53 <Cpudan80>         | (simplify x) == (Num 0) = (simplify y)
14:53:55 <Cpudan80> err soryr
14:54:02 <Cpudan80> simplify (Add x y)
14:54:04 <Cpudan80>         | (simplify x) == (Num 0)
14:54:08 <tibbe> if you have a pattern match failure in a guard will it try the next one?
14:54:10 <Excedrin> metaperl: http://paste.lisp.org/display/30904#1
14:54:18 <monochrom> Yes it will
14:54:23 <tibbe> ok
14:54:35 <monochrom> err I don't know.
14:54:44 <Pseudonym> Cpudan, here's how I usually express algorithms like this.
14:54:50 <Pseudonym> First off:
14:55:01 <Pseudonym> applySimplifierExpr :: (Expr -> Expr) -> (Expr -> Expr)
14:55:15 <Pseudonym> applySimplifierExpr s (Add x y) = Add (s x) (s y)
14:55:22 <Pseudonym> {- ... etc ... -}
14:55:33 <Pseudonym> Do you see what that does?
14:55:51 <Cpudan80> what does the little s mean?
14:55:55 <Cpudan80> the name?
14:56:00 <Pseudonym> Look at the type of applySimplifierExpr.
14:56:16 <Cpudan80> hmmm
14:56:18 <Cpudan80> ok
14:56:22 <Pseudonym> Right?
14:56:34 <Pseudonym> It might help to think of it this way:
14:56:38 <Pseudonym> type Simplifier = Expr -> Expr
14:56:44 <Pseudonym> A simplifier maps an Expr to an Expr.
14:56:45 <Pseudonym> Then:
14:56:52 <Pseudonym> applySimplifierExpr :: Simplifier -> Simplifier
14:57:02 <Pseudonym> It takes a Simplifier and applies it one level "down".
14:57:33 <Pseudonym> You with me?
14:59:26 <Cpudan80> Pseudonym: Ok - I fixed it -- but I have a diff question now
14:59:37 <Pseudonym> OK.
14:59:42 <Cpudan80> Let's say I want to assign the output of the function to some variable
14:59:44 <Cpudan80> ex
14:59:52 <Cpudan80> simplify (Add x y) = Add (simplify x) (simplify y)
15:00:03 <Cpudan80> Assign to something...
15:00:06 <Cpudan80> then simplify that...
15:00:12 <Cpudan80> is that possible?
15:00:19 <Pseudonym> What do you mean "assign to something"?
15:00:32 <Cpudan80> like uhh in Java or something
15:00:42 <Cpudan80> x = myFunction(var1, var2)
15:00:55 <Pseudonym> Errr...
15:01:00 <Pseudonym> nope, don't follow.
15:01:17 <Cpudan80> lol - ok -- it basically works as is
15:01:27 <Cpudan80> but I need to simplify what is returned by that line once more
15:01:43 <Cpudan80> That make more sense?
15:01:45 <Pseudonym> So you want to apply the simplifier multiple times?
15:01:56 <Cpudan80> basically
15:01:58 <Pseudonym> OK.
15:02:06 <Pseudonym> Let me finish my presentation for a moment. :-)
15:02:10 <Cpudan80> simplify (Add x y) = simplify(Add (simplify x) (simplify y)) goes infinite
15:02:18 <Pseudonym> When you have applySimplifierExpr, then you cal do this:
15:02:23 <Pseudonym> simplify :: Expr -> Expr
15:02:39 <Cpudan80> err ok - got that already :/
15:02:41 <Pseudonym> simplify = simplify' . applySimplifierExpr simplify
15:02:45 * edwardk waves hello.
15:02:49 <Pseudonym> Where simplify' does the peephole stuff:
15:02:54 <edwardk> @seen dons
15:02:54 <lambdabot> dons is in #haskell.hac07, #ghc, #haskell-overflow, #haskell and #Haskell. I last heard dons speak 11m 10s ago.
15:02:56 <Pseudonym> simplify' (Add (Num 0) y) = y
15:03:02 <Pseudonym> simplify' e = e   -- base case
15:03:09 <lisppaste2> Excedrin annotated #30904 with "add missing pattern" at http://paste.lisp.org/display/30904#2
15:03:10 <Pseudonym> OK, once you've got THAT...
15:03:20 <Pseudonym> Then what you actually want is to simplify to fixpoint.
15:03:22 <Cpudan80> Pseudonym: Yep - all that ok...
15:03:34 <edwardk> dons, got bored and slapped together a cheesy plugin for lambdabot that adds a bunch of gnu talk filters if you want it.
15:03:42 <Pseudonym> Try this:
15:04:01 <Pseudonym> iterateUntilFixpoint :: (Eq a) => (a -> a) -> (a -> a)
15:04:07 <dons> edwardk: cool
15:04:10 <Pseudonym> iterateUntilFixpoint s t = findFixpoint (iterate s t)
15:04:12 <Pseudonym>   where
15:04:21 <Pseudonym>     findFixpoint (x1:xs@(x2:_))
15:04:26 <Pseudonym>       | x1 == x2 = x2
15:04:33 <Pseudonym>       | otherwise = findFixpoint xs
15:04:37 <Pseudonym> And you're done.
15:04:45 <Pseudonym> You can just call: iterateUntilFixpoint simplify expr
15:04:45 <edwardk> dons: /msg bottom @list filter to play with it if you want. submit via patch?
15:05:04 <Cpudan80> Pseudonym: ok - thanks
15:05:07 <Cpudan80> I think I get that
15:05:12 <Pseudonym> The reason why I went through all this is that thinking higher-order really helps here.
15:05:35 <Pseudonym> So it's worth going through the basics and thinking of that in a higher-order way too.
15:05:45 <Cpudan80> right
15:05:49 <Pseudonym> Maybe iterateUntilFixpoint should be somewhere in the standard library.
15:20:45 <dons> did people see http://scienceblogs.com/goodmath/2006/11/simple_functions_in_haskell_1.php
15:20:47 <lambdabot> http://tinyurl.com/y3n8jz
15:21:01 <Pseudonym> Not yet, but it's on my RSS feed.
15:21:32 <dons> fibs and fact, arriving at the zipWith implementation
15:22:07 <mux> dons: saw my private messages?
15:26:28 <shapr> dons: I'm beginning to think that incremental/distributed GC is important for good multicore performance.
15:26:35 <astrolabe> is there a way to interrupt ghci without killing it?
15:26:36 <shapr> edwardk: hiya!
15:26:42 <shapr> astrolabe: C-c
15:26:43 <edwardk> shapr: how goes?
15:26:51 <astrolabe> shapr: thanks
15:26:53 <edwardk> shapr: or you just need better region inference =)
15:26:54 <shapr> edwardk: Life is good, the code is flowing.
15:26:58 <dons> shapr: right. parallel GC is important
15:27:08 <dons> shapr: see SimonM says we'l have par GC by 6.8
15:27:20 <astrolabe> shapr: doesn't work
15:27:27 <astrolabe> Is it because I have windows?
15:27:46 <shapr> astrolabe: Not sure, it's always worked for me. But I've never used GHC(i) on Windows.
15:28:12 <shapr> For that matter, I've used windows less than a total of 24 hours in the last seven years.
15:28:43 * astrolabe goes green
15:29:23 <edwardk> shapr: i use windows as a glorified terminal server for my linux box, does that count? =)
15:29:50 <shapr> I dunno, why not use linux in that case?
15:30:02 <edwardk> better games =)
15:30:16 <shapr> I used to agree with you...
15:30:24 <dobblego> shapr, does HAppS LLC have a website?
15:30:31 <shapr> Yeah, happs.org
15:30:39 <dons> Cale: do you know if Mark Chu-Carroll has dropped by here yet?
15:30:51 <shapr> Yeah, he's been here.
15:31:01 <dons> ah good. what nick does he use?
15:31:01 <dobblego> shapr, do you do consulting by yourself with HAppS?
15:31:17 <shapr> dobblego: by myself?
15:31:17 <Cale> dons: I don't know
15:31:25 <dobblego> shapr, how many people does it employ?
15:31:38 <dons> it would be good if he did, we could sort out the foldl/r/' stuff beforehand.
15:31:42 <shapr> dons: He hasn't been here in months, I think he's the same Mark C. Carrol who works for Aetion.
15:31:56 <dons> oh? interesting.
15:32:06 <dons> really?
15:32:13 <dons> he may be a haskell expert already then...
15:32:26 <shapr> I'm pretty sure he got started with Haskell by working with SyntaxNinja.
15:32:38 <dons> mmm!
15:32:48 <dons> yeah ok. good
15:32:57 * dons sits back and waits for more blogs
15:33:06 <shapr> btw, I think they're hiring...
15:34:24 <shapr> dobblego: I don't know how many people work for HAppS LLC. I think that I'm the only Haskeller who is contracting for HAppS right now, but I know of at least two others who have contracted for HAppS in the past.
15:35:12 <dobblego> why does it say that "HAppS is a Haskell library for..." on happs.org if it actually a LLC?
15:35:59 <Botty> either my libs are out of date, or these docs are wrong: http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Char.html  I've got no isSymbol function
15:36:01 <lambdabot> http://tinyurl.com/yjho56
15:36:08 <Pseudonym> Woah, HAppS is hiring?!
15:36:10 <shapr> Probably because the guy behind HAppS is half tech and half business, so he set up a company for HAppS. But the end goal of HAppS is to support a bunch of spiffy webapp ideas that this guy has.
15:36:13 <dons> ?docs Data.Char
15:36:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
15:36:19 <Pseudonym> Where does one apply?
15:36:24 <shapr> Pseudonym: That too, but Aetion is the one I was talking about.
15:36:30 <dons> Pseudonym: ask alexj?
15:36:31 <Pseudonym> Right.
15:36:45 <shapr> Yeah, send a resume to me or alexj.
15:36:47 <Botty> dons - ah, i guess i should stop using google for finding stuff
15:36:57 <dons> uh hu :)
15:36:57 <Botty> those docs have isSymbol as well though
15:37:10 <dons> what hugs do you have?
15:37:35 <dons> mmm.
15:37:36 <dons> Hugs.Base> :l Data.Char
15:37:36 <dons> Data.Char> :t isSymbol
15:37:37 <Botty> ghci 6.4.1 ;P
15:37:37 <dons> ERROR - Undefined variable "isSymbol"
15:37:40 <Botty> yeah
15:38:10 <dons> ghci:
15:38:11 <dons> Prelude Data.Char> :t isSymbol
15:38:11 <dons> isSymbol :: Char -> Bool
15:38:11 <dons> Prelude Data.Char> isSymbol 'x'
15:38:11 <dons> False
15:38:15 <Botty> i take it it's not often used
15:38:52 <dons> yes, i can confirm it is missing in hugs' Data.Char
15:38:58 <dons> it might be in the newest hugs though
15:40:07 <Botty> Prelude> :module Data.Char
15:40:07 <Botty> Prelude Data.Char> :t isSymbol
15:40:07 <Botty> <interactive>:1:0: Not in scope: `isSymbol'
15:40:42 <Botty> my ghc is a version or two old though (crappy ubuntu packagers)
15:40:50 <dons> ok. looks like its only in 6.6
15:40:52 <dons> weird
15:41:00 <dons> its not in my 6.4.2
15:47:54 <shapr> dons: Does par GC imply it'll be incremental as well?
15:51:06 <dons> i'm not sure what the plans are in that directly, I suspect so (?)
15:52:29 <SamB> it doesn't imply that
15:53:05 <SamB> that would be nice, but it could just mean having GC utilize multiple CPUs
15:53:21 <SamB> and not mean that you could run GC and code interleaved or even at the same time
15:53:44 <han1> I use the gtk2hs to draw a figure, anybody know how to save it as .ps file?
15:54:31 <SamB> I think they said they wanted to look into incremental/concurrent GC too, though
15:55:49 <dons> yeah. there's been talk
15:56:06 <dons> just ensuring all threads don't have to stop of GC is the most important goal
15:56:32 * vincenz tags dons
15:56:51 <SamB> well, even if they do, it would be nice if the GC could go 2 or 4 times as fast
15:58:43 <dons> Pseudonym: did the markup break in your recent post?     | m - n
15:58:54 <dons> recursiveProduct m n
15:58:54 <dons>     | m - n
15:58:54 <dons>     | otherwise = recursiveProduct m mid
15:58:54 <dons>                 * recursiveProduct (mid+1) n
15:58:55 <dons>     where mid = (m + n) `div` 2
15:59:13 <Pseudonym> Whoops.
15:59:18 <Pseudonym> dons: | m - n > 5 = product [m..n]
15:59:23 <Pseudonym> Killed by HTML entity markup.
15:59:53 <dons> ah yes
16:01:02 <Pseudonym> Fixed.
16:01:27 <dons> I find it interesting that joelr is bugging the erlang community too now...
16:02:23 <wchogg> What do you mean by bugging?
16:02:49 <palomer> hmm
16:02:54 <fons> hi all
16:02:58 <palomer> I wonder if there's a haskell library for dealing with euc-japan
16:03:11 <dons> " Joel Reymont argues that there's no need for an Erlang-based web framework because Rails exists.", http://blog.lostlake.org/index.php?/archives/22-Why-Erlang-and-Erlyweb-are-worth-considering.html
16:03:13 <lambdabot> Title: Why Erlang (and Erlyweb) are worth considering - David Pollak's Blog, http://tinyurl.com/y9wn25
16:03:57 <Botty> dons - Megahal is implemented pretty crudely.  I'm pretty sure I can do something similar in haskell which is faster in 1/10th the code
16:04:38 <Pseudonym> Oh, $DEITY.
16:04:39 <dons> hehe one comment I agree with on joelr's blog "Joel changes his opinion very quickly. If I recall the correct order of technologies, it was: lisp, erlang, haskell, ocaml, obj-c, ruby, rails ... Sometimes I wonder on the depth and mastery he reaches before he starts spouting about the pitfalls and why he has moved on."
16:04:49 <Pseudonym> Nobody has yet written anything high-performance in Rails.
16:04:50 <Botty> crudely, as in typedef struct { BYTE4 size; STRING *entry; BYTE2 *index; } DICTIONARY;
16:05:16 <dons> Botty: cool.
16:06:25 <shapr> dons: He got pretty deep into Haskell in a small amount of time.
16:06:26 <Pseudonym> The strength of Erlang is that it's a middleware framework in itself.
16:06:50 <Pseudonym> Erlang does in the language what Rails does in libraries.
16:08:40 <palomer> what package do you guys recommend for doing regexp
16:08:49 <fik> @logs
16:08:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:09:11 <dons> shapr: yeah, but gave up due to these horrible pickler combinators. everyone told him to use NewBinary, he wrote his own serialiser instead, it was terribly complicated, and too slow. why not just use NewBinary, I don't know..
16:09:38 <dons> palomer: Text.Regex. in the regex-compat and regex-pcre libs
16:09:47 <palomer> which libs should I choose?
16:09:49 <palomer> WHICH?
16:09:56 <shapr> Speaking of which, has anyone tried the BitSyntax from imperialviolet.org?
16:09:57 <dons> regex-compat comes with ghc 6.6. use that.
16:10:05 <wchogg> dons:  I think it's very seductive to search for the perfect language technology and jump around a lot.
16:10:14 <dons> wchogg: yeah, true.
16:10:17 <dons> its like candy every day
16:10:20 <palomer> k
16:13:03 <palomer> any tutorials anywhere?
16:13:37 * eviltwin_b has learned lots of languages, but isnot seeking perfection
16:13:49 * shapr is just looking for more toys
16:13:59 <eviltwin_b> languages are tools, I like having a nice big toolbox
16:14:20 * eviltwin_b will let someone else worry about big tools, on the other hand :>
16:14:27 <wchogg> I just like learning math, and haskell segues nicely into that.
16:14:29 <Excedrin> Megahal is the markov chain sentence generator thing?
16:14:36 <dons> palomer: there's an api. regex aren't that hard...
16:14:42 <palomer> I can't find any documentation on regexs!
16:14:44 <dons> ?docs Tex.Regex
16:14:45 <lambdabot> Tex.Regex not available
16:14:48 <dons> ?docs Text.Regex
16:14:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
16:14:53 <dons> check the docs...
16:15:08 <sjanssen> @keal
16:15:09 <dons> ?google regex-compat haskell
16:15:09 <lambdabot> i think it because mathematics damage you cpu
16:15:13 <lambdabot> http://blog.gmane.org/gmane.comp.lang.haskell.libraries/page=8
16:15:13 <lambdabot> Title: gmane.comp.lang.haskell.libraries
16:15:15 <dons> how hard did you look, palomer ?
16:15:20 <palomer> google
16:15:21 <palomer> hoogle
16:15:24 <palomer> ghc webpage
16:15:38 <palomer> then my back started to hurt
16:15:44 <palomer> time for some cobra pushups
16:15:50 <palomer> btw, what syntax do they use?
16:16:00 <dons> palomer: read the docs
16:16:05 <vraj> @docs hsql
16:16:06 <lambdabot> hsql not available
16:16:28 <vraj> @docs hdbc
16:16:29 <lambdabot> hdbc not available
16:16:49 <dons> ?where hsql
16:16:49 <lambdabot> http://htoolkit.sourceforge.net
16:17:01 <dons> ?where hdbc
16:17:01 <lambdabot> http://quux.org/devel/hdbc
16:17:26 <vraj> dons: Thanks
16:17:53 <lisppaste2> metaperl pasted "not sure why my splitAt does not reverse the list before the split" at http://paste.lisp.org/display/30907
16:19:00 <Excedrin> this BitSyntax looks pretty nice, but it's missing floats, doubles, signed ints etc
16:20:45 <palomer> „Öì„ÖêÍ∑∏„Öì
16:20:49 <palomer> hrmph
16:21:02 <palomer> ÌùòÌîÑ
16:21:23 <palomer> I wonder how to retrieve the substrings matched by subexpressions
16:21:33 <dons> you're dumping binary to the console now?
16:21:40 <metaperl> ah it does reverse it
16:21:55 <palomer> dons, nope
16:21:57 <palomer> dons, it's korean!
16:22:23 <palomer> the first was gibberish because I forgot to switch to us
16:22:23 <dons> 11:14  palomer> 1111
16:22:32 <palomer> the second is hrmph in korean (roughly)
16:22:34 <wolverian> heh, http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Main.html is funny.
16:22:37 <lambdabot> http://tinyurl.com/y9j6bq
16:22:46 <dons> the regex lib lets you get sublists. read carefully.
16:22:49 <dons> less talk, more code!
16:24:37 <palomer> yes! more code!
16:25:11 <monochrom> more RTFM
16:25:24 <palomer> the docs say nothing about the regexp syntax needed to retrieve substrings
16:25:38 <Botty> palomer - just loop up any old regex tut on the net
16:25:41 <monochrom> Oh right the docs aren't good.
16:26:05 <Botty> its not a haskell specific thing you know.  If Haskellers designed it, it'd be much better anyway
16:26:10 <palomer> the regexp tutorials that tell you how to retrieve substrings are written for perl
16:26:24 <Botty> oh, that sort of thing
16:26:54 <palomer> it seems that every programming language has its own syntax
16:26:58 <monochrom> matchRegex returns Maybe [String].  That list has the substrings you want.
16:27:01 <dons> man regex
16:27:20 <monochrom> "Returns: Just strs if the match succeeded (and strs is the list of subexpression matches), or Nothing otherwise."
16:27:26 <palomer> those are unix regexs!
16:27:36 <palomer> monochrom, right, but what's the syntax to choose which blocks to keep?
16:27:37 <monochrom> So, I rest my case.
16:27:41 <dons> what do you think Text.Regex is bound to...
16:27:43 <palomer> you rest nothing!
16:28:05 <palomer> I thought Text.Regex was all about POSIX
16:28:07 <monochrom> Ah.  "\(blahblah\)" or "(blahblah)", I forgot which one.
16:28:16 <monochrom> Yes it's POSIX.
16:28:20 <dons> palomer: go write some code. please
16:28:33 <palomer> monochrom, thx
16:28:49 <monochrom> "The syntax of regular expressions is otherwise that of egrep (i.e. POSIX "extended" regular expressions)."
16:28:51 <palomer> now that I know _how_ to write the code
16:28:53 <palomer> I can write it
16:29:07 * palomer finds it pretty silly to write code when you don't know what you're going to write
16:29:08 <monochrom> That's also from the docs.  Now I rest my case.  RTFMD.
16:29:33 <palomer> D?
16:29:37 <monochrom> Dude.
16:29:45 <palomer> had a bad day?
16:30:02 <palomer> you guys need to chill out
16:30:05 <monochrom> Well everyday is a bad day.
16:30:23 <monochrom> everyday some teenager shows a RTFM problem.
16:30:27 <monochrom> that's very bad.
16:30:33 <monochrom> by 1980 standards.
16:31:21 <dons> I just don't understand how you can have hung out here since 2003, and yet not know how to find the docs for Text.Regex.
16:32:01 <monochrom> The Text.Regex doc doesn't say what POSIX regexs look like, I'll grant you that.
16:32:42 <monochrom> But it does say it's POSIX.  One could go fork a thread to read POSIX regexs.  It even says egrep so you could man egrep.
16:33:16 <monochrom> Have you ever wondered how I got to know "(blah)"?
16:33:36 <monochrom> In Chinese we have this saying: "who ask me, me ask whom?"
16:33:37 <palomer> dons, there are many mysteries in the universe
16:33:51 <monochrom> I think it's full of wisdom.
16:34:01 <palomer> china is full of wisdom
16:34:06 <palomer> and cheap chinese food
16:34:20 <monochrom> I.e., if I can find a source, why can't you?
16:34:58 * edwardk waves hello.
16:35:01 <palomer> I found the source
16:35:19 <palomer> since you gave it to me
16:35:40 * Korollary flashes a gang sign at edwardk 
16:36:01 <monochrom> Yeah wonder who gave it to me?
16:36:15 <fik> gopher://gopher.quux.org/ is a very good archive
16:36:23 <palomer> I don't know
16:36:37 <monochrom> Food for thought for you, then.
16:36:38 <palomer> we both found the source, through different means
16:36:58 <palomer> frankly, I rather eat some ice cream right now
16:37:08 <Botty> some means use your own time, others waste others' time
16:37:12 * edwardk looks back at Korollary with the blank stare of one who grew up in the suburbs ;)
16:37:19 <dons> palomer, stay on #haskell-blah then.
16:37:39 * pzpz casts magic missle.
16:38:03 <palomer> why would I stay on haskell-blah to ask about haskell regular expressions?
16:38:14 <palomer> dons, I'll have to ask you to be more polite with me or to stop speaking to me at all
16:38:56 <dons> after almost 4 years, if you can't follow polite convention and *do your own research*, i wonder if there's any hope
16:39:40 <monochrom> I think I'm still vulnerable to the provocative tactic once in a while.
16:40:03 * palomer wishes his chat program's ignore command would work
16:40:08 --- mode: ChanServ set +o dons
16:40:12 --- mode: dons set +b *!*n=palomer@*.dsl.bell.ca
16:40:12 --- kick: palomer was kicked by dons (sick of this)
16:40:14 --- mode: ChanServ set -o dons
16:40:23 <dons> he can stay in #haskell-blah and do his own research
16:40:55 <pzpz> heh. the proper solution would be to ignore unreasonable questions.
16:41:12 <pzpz> feeding trolls only makes them grow.
16:41:16 <Botty> then he'll just ask them again, in more annoiying ways
16:41:18 <dons> he's already been banned previously for distracting off topic trolling
16:41:26 <dons> and after 4 years, i don't see any hope for rehab
16:41:31 <Botty> "Why won't anyone answer my question? is it too hard?" etc
16:41:32 <pzpz> :(
16:41:40 <robreim> If I want to compile my executable for profiling, do I also need to obtain every library I use such as base, networking etc and compile them for profiling also?
16:41:44 <pzpz> didn't realize that.
16:41:45 <robreim> Uh, for GHC
16:41:46 <monochrom> Retrospectively it hurts me that some people manipulates us by saying "why does haskell suck for ___" instead of "how to ___ in haskell".
16:41:48 <dons> robreim: yep
16:41:55 <robreim> d'oh. Thonks.
16:41:57 <dons> monochrom: agreed.
16:42:07 <dons> robreim: ghc should come with prof libs in most distros though
16:42:15 <robreim> s/Thonks/Thanks/
16:42:27 <monochrom> Of course, in situ, we're just thinking "no no no we want to show you Haskell is cool!"
16:42:34 <Botty> monochrom - I do that, but not to get help, rather to provoke a discussion on language design ;p
16:43:12 <monochrom> I just wish I could write a plugin for my irc client to detect and warn the use of the tactic.
16:43:20 <robreim> Hmm.. My Network.HTTP isn't for Debian. Maybe I installed my own sometime and forgot about it. Ok, thanks.
16:43:25 <pzpz> Botty: heh, half the time I ask something, the channel turns into a lambdabot spam. It's enjoyable :)
16:43:34 <dons> heh
16:43:48 <Botty> monochrom - sounds like a promising lambdabot extension!
16:45:39 <robreim> speaking of plugins... any news on hs-plugins for ghc6.6?
16:45:49 <dons> yeah, Lemmih's almost got it done, I hear
16:46:05 <robreim> Oh sweet :)
16:46:50 <Igloo> Did it turn out to be harder than expected, or did you just not have time?
16:46:52 <robreim> absense makes the heart grow fonder. I don't know how to live without hs-plugins anymore. I've been crying myself to sleep the past few weeks.
16:47:32 <dons> i've not had time yet
16:47:43 <Igloo> *nod*  :-(
16:47:44 <dons> robreim: I'm so sorry!
16:48:02 <dons> Lemmih: how's the port going?
16:49:31 <robreim> Don't apologise! The last thing I'd want is for you to feel guilty about anything to do with hs-plugins. Feel proud it's capable of making a grown man cry, not guilty :)
16:50:11 <dons> :}
16:50:23 <wchogg> robreim:  So what have you been doing with hs-plugins that it's been so sorely missed?
16:50:57 <robreim> Just writing an extensible price grabber utility for work.
16:51:20 <vincenz> glguy: woah, you're emertens?
16:51:22 <robreim> And a consensus plugin for lambdabot, also for work
16:51:38 <glguy> vincenz: yeah...
16:51:48 <vincenz> I remember you being on here with that nick :)
16:52:21 <glguy> How did you connect the two?
16:52:29 <dons> robreim: oh! you've got money riding on this?
16:52:44 <robreim> glguy: glguy (n=emertens@unaffiliated/glguy) has joined #haskell
16:52:45 <glguy> specifically just now :)
16:53:18 <dons> robreim: ok. if you're using haskell at work now I feel mightily obliged to get something into darcs quick
16:53:34 <robreim> dons: Yeah. I figured out a work around the other day which allows me to continue developing though.
16:54:02 <dons> ok good
16:54:11 <Korollary> let
16:54:33 <Korollary> let's all lie about our usage of haskell at work so that dons can crank a better web browser in a few days.
16:54:34 <vincenz> glguy: your join message
16:54:40 <vincenz> glguy: and get your ass to the proper channel
16:54:41 <robreim> So I'm not feeling as antsy as I was, but I'd still be very pleased to see hs-plugins out.
16:55:11 <dons> ok. priority++
16:55:18 <robreim> If the software makes lots of money, I'll talk to my colleagues about donating some to GHC, gtk2hs and hs-plugins.
16:55:22 <Igloo> It would be great to have it back working in Debian for etch too
16:55:22 <robreim> (big "if")
16:55:31 <vincenz> meta-if
16:56:40 <glguy_> My wireless got screwed up... I never heard how you recognized me as emertens just now, vincenz
16:56:43 <dons> after reading " Multi-core may be bad for Java  " i'm inclined to write "Haskell welcomes our new multicore overlords!"
16:56:43 <dobblego> robreim, what is a price grabber utility?
16:56:52 <vincenz> glguy_ [n=emertens@unaffiliated/glguy] has joined #haskell
16:56:58 <glguy_> AH
16:57:00 <glguy_> yeah, that
16:57:01 <vincenz> :D
16:57:02 <glguy_> that would ggive it away
16:57:06 <vincenz> sorta
16:57:10 <vincenz> unless you were really obtuse
16:57:41 <vincenz> well less obtuse than 180, or you'd be a straight shooter
16:57:46 <robreim> dobblego: ah it's just a little program which grabs prices for stuff like computer hardware from a bunch of suppliers and shows them in the one place ordered by price so people can find the cheapest price from their suppliers.
16:57:54 <dobblego> ah right
17:00:15 <Excedrin> how does it use hs-plugins?
17:01:28 <wy> How can I represent newline in a string?
17:01:30 <robreim> it uses hs-plugins so it can be extended to use any price source there's a plugin for.
17:01:35 <dobblego> > "\n"
17:01:37 <lambdabot>  "\n"
17:02:00 <wy> but it seems print "\n" doesn't print a newline. It prints "\n"
17:02:06 <robreim> Don't steal the idea though :P (it'll be sold open-source anyway so there's little need to)
17:02:36 <Excedrin> I wasn't planning on it, just curious how people are using hs-plugins
17:02:43 <Botty> robreim - there's a few sites like that anyway
17:03:19 <Botty> PriceGrabber.com comes to mind :)
17:03:28 <robreim> Botty: yeah. But they tend not to be extensible and certainly tend not to be open-source, and are often web-sites which I consider a little inconveniant.
17:03:55 <Botty> ah, ok, cool
17:04:02 <glguy> wy: print = putStrLn . show
17:04:09 <glguy> wy: so you want: putStrLn "\n"
17:06:10 <glguy> dons: I fixed my reddit comment
17:06:45 <glguy> My excuse is that I've got a fever today and I haven't been thinking clearly for most of the day
17:06:47 <wy> glguy: Thanks
17:06:54 <glguy> (most of that was from sleeping most of the day)
17:06:56 <wy> >putStr "\n"
17:07:09 <glguy> lambdabot won't do IO for you
17:07:17 <wy> I see.
17:07:29 <Botty> > putStr "\n"
17:07:31 <lambdabot>  <IO ()>
17:07:46 <Botty> it will tell you the type of the IO now, though :)
17:07:50 <wy> I'm trying Peyton Jones's book. Any ideas about getting the Miranda code of the book?
17:12:55 <glguy> Did anyone here read through the reddit comments on "Why Haskell?"
17:13:00 <Korollary> yes
17:13:18 <glguy> There are quite a few *essays* there
17:13:33 <Botty> yeah, i left one
17:16:17 <jdev> > ['!',' '..]
17:16:19 <lambdabot>  "! \US\RS\GS\FS\ESC\SUB\EM\CAN\ETB\SYN\NAK\DC4\DC3\DC2\DC1\DLE\SI\SO\r\f\v\n...
17:16:19 <dons> glguy: i deleted mine :)
17:16:34 <dons> ?users
17:16:34 <lambdabot> Maximum users seen in #haskell: 276, currently: 250 (90.6%), active: 41 (16.4%)
17:16:45 <dons> glguy: yeah :) good stuff eh?
17:16:55 <glguy> Not too bad
17:17:22 <glguy> I think that the pages that were written about "Why is maybe a monad" surprising
17:18:17 <dons> i've sent two complaints now to reddit about the markdown bug
17:18:24 <dons> the same one reported by tmoertel 6 months ago...
17:18:33 <dons> where do x <- foo breaks
17:18:35 <glguy> yeah... I've rewritten examples to use =<< instead of >>= for that reason
17:18:41 <dons> good idea
17:18:50 <glguy> err
17:18:54 <glguy> flip that
17:19:11 <dons> i know what you mean :)
17:20:48 <shapr> btw, @pl doesn't handle constructor unpacking in ?pl get >>= \(WikiState pages) -> (sresult 200 . listPage . keys) pages
17:21:36 <glguy> how would it be able to access the value inside WikiState?
17:21:36 <Excedrin> where does Haskell fit in this? http://en.wikipedia.org/wiki/Multiparadigm_programming_language
17:21:36 <dons> mmm. Igloo could we parallelism mergesort with par in some Data.Parallel.{List,Map,..} library
17:21:39 <lambdabot> http://tinyurl.com/ta9l3
17:21:41 * dons wants edison for smp machines
17:21:45 <shapr> I'd like to factor that into (sresult 200 . listPage . keys) =<< get but I can't figure out how to work constructor unpacking into that. Is there a way?
17:21:58 <shapr> dons: Oh that would rock!
17:22:14 <glguy> shapr: f =<< gets pages
17:22:29 <glguy> do you use record labels?
17:22:34 <Igloo> dons: Is doint that many pars really going to be a win?
17:22:43 <shapr> No, but I could refactor my type to be a record.
17:22:46 <dons> I guess it might on a big core machine?
17:22:52 <dons> just planning for the future
17:22:58 <Igloo> I guess for large lists it might be
17:22:59 <glguy> shapr: I thought that if you don't use records, that you have to use pattern match...
17:23:05 <Igloo> I'd want to see some numbers, though
17:23:12 <dons> anyway, we can wait for Data.Array.Parallel with the ndp library out soon
17:23:14 <dons> then think about lists
17:23:22 <Pseudonym> Excedrin: dataflow, functional, imperative, object-oriented
17:23:28 <Pseudonym> Generic
17:23:39 <Pseudonym> That's five at least.
17:23:41 <dons> declarative
17:23:58 <Pseudonym> "Functional" is a subset of declarative.
17:24:00 <dons> (thinking of list monad backtracking here)
17:24:05 <shapr> glguy: Thanks for the suggestions, I think that'll work.
17:24:15 <Excedrin> ya, I don't think they make a distinction between declarative and functional
17:24:21 <Pseudonym> Logic languages are declarative languages that aren't functional.
17:24:28 <Pseudonym> (For the most part.)
17:25:00 <dons> Igloo: it might be easier to write Data.ByteString.Parallel first
17:25:05 <dons> on top of ndp arrays
17:25:11 <Pseudonym> Haskell doesn't quite make it as a concurrent language, any more than C++ is, even though they both have good libraries which do the job.
17:25:27 <dons> even with an smp rts, you think?
17:25:39 <Cale> Haha, on the "Why Haskell Matters" reddit discussion, I love how nested the conversation has become
17:25:43 <Pseudonym> Yeah, even then.
17:25:49 <dons> surely `par` and ndp arrays get us somewhere close? what's missing?
17:25:59 <shapr> Cale: What's the url for that?
17:26:05 <Cale> 17 levels deep :)
17:26:08 <Cale> http://programming.reddit.com/info/hz31/comments
17:26:15 <lambdabot> Title: Why Haskell Matters (reddit.com), http://tinyurl.com/yzfzqq
17:26:25 <dons> they should have parens for the nesting :)
17:26:26 <Cale> (It's mostly back and forth between two people)
17:26:27 <glguy> http://programming.reddit.com/info/sijx/comments -- grew down
17:26:30 <lambdabot> Title: Why Haskell? (reddit.com), http://tinyurl.com/ynauv9
17:26:41 <lisppaste2> beschmi pasted "unsafePerformIO in C bindings" at http://paste.lisp.org/display/30916
17:26:42 <dons> i'm surprised no one replied to the state monad interpreter
17:26:54 <dons> after the guy asked about threading heap around an erlang interpreter being awkward
17:27:01 <beschmi> is this use of unsafePerformIO safe?
17:27:14 <Cale> dons: noone replied to what?
17:27:17 <Pseudonym> Basically, to be a concurrent language, Haskell needs language support.
17:27:17 <dons> beschmi: that's the appropriate question to ask :) thanks!
17:27:23 <Pseudonym> `par` is very close.
17:27:25 <glguy> grauenwolf seems to go on and off providing helpful comments
17:27:33 <dons> beschmi: looks ook
17:27:33 * glguy hasn't read the ocmments yet
17:27:53 <dons> beschmi: since mp_cmp  is presumably referentially transparent/
17:28:03 <Cale> Pseudonym: Have you seen the parallel arrays stuff?
17:28:27 <Pseudonym> A while ago, yes.
17:28:35 <Cale> http://www.cse.unsw.edu.au/~chak/papers/CLPKM06.html
17:28:37 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/yyj2ur
17:28:49 <Pseudonym> Look, there's nothign wrong with library-based concurrency.
17:29:08 <dons> :)
17:29:18 <dons> Pseudonym: would pH be a concurrent language?
17:29:20 <Pseudonym> One of the strengths of a language is the ability to adopt, via a library, styles of programming that the language doesn't do natively.
17:29:24 <Pseudonym> dons: Maybe.
17:29:30 <Pseudonym> haven't looked closely enough.
17:29:49 <Pseudonym> Hell, even C++ allows embedded SQL as an offboard paradigm.
17:30:12 <_debrac> Hello everyone
17:30:15 <_debrac> Got a question
17:30:18 <_debrac> I get an error
17:30:23 <beschmi> i'm not sure, can two different ForeignPtrs be equal
17:30:27 <_debrac> Does not match type a->b->c
17:30:30 <Pseudonym> G'day.
17:30:32 <dons> though `par` and `pseq` being a builtin, would that count as language support?
17:30:40 <_debrac> Can someone ehhh give some info on that?
17:30:41 <Cale> _debrac: sure, paste the code...
17:30:41 <_debrac> Thanks
17:30:45 <Cale> lisppaste2: url
17:30:45 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
17:30:48 <dons> beschmi: you've looked at the Data.ByteString source?
17:30:59 <_debrac> Cale: Give me a minute
17:31:01 <_debrac> Its a lot of code
17:31:10 <dons> beschmi: http://www.cse.unsw.edu.au/~dons/code/fps/Data/ByteString.hs
17:31:11 <lambdabot> http://tinyurl.com/y2l385
17:31:26 <dons> grep for 'compareBytes'
17:31:44 <beschmi> thanks, i'm taking a look right now
17:31:51 <Cale> _debrac: make sure that you've given the functions in question the right number of parameters
17:32:31 <Pseudonym> And _debrac, please paste the WHOLE error message.
17:33:53 <dons> beschmi: are you writing a userland binding to libgmp?
17:34:02 <dons> or some other lib?
17:34:39 <beschmi> it's libtommath, i don't want to patch libgmp to use other symbol names
17:34:45 <glguy> why do people care if the Zune does or does not become more popular than the iPod? Who has an interest in one succeeding beside for Apple and Microsoft?
17:35:18 <dons> Pseudonym: so you going to implement these guys, http://www.luschny.de/math/factorial/FastFactorialFunctions.htm
17:35:20 <lambdabot> Title: Fast Factorial Functions, http://tinyurl.com/wqvrk
17:35:23 <beschmi> there are some functions i need in libgmp without a binding in GHC
17:35:27 <dons> beschmi: right that's what I was wondering
17:35:47 <dons> what's libtommath provide?
17:36:30 <beschmi> but GMP+haskell code was still faster than ltm for my use case (g^m mod n) for large m and n
17:36:40 <dons> ok.
17:37:05 <dons> would the ltm binding be generally useful? should it be cabalised, now you've done the hard work?
17:37:21 <glguy> Ugh, the fast factorial functions guy doesn't know not to use blue on red or red on blue =/
17:37:25 <glguy> my eyes...
17:39:10 <beschmi> i'm planning to release it when it's completed. there are some other number theoretic functions in there that are missing in GHC+gmp
17:39:44 <beschmi> but i have to add these functions first and clean up the code a bit
17:40:06 <Pseudonym> dons: Nope.
17:40:19 <Pseudonym> I've found that most of the fast factorial functions are fairly useless.
17:40:41 <Pseudonym> Two algorithms seem to do the trick.  One is the Legendre factorisation.  The other is sensible binary product.
17:40:59 <Pseudonym> And yeah, I've implemented most of them over the years.
17:41:51 <wy> I think this is the time to raise the question of loop detection again. I compiled a ghc 5.7. But it still doesn't detect loops for me. Anyone knows if there is a switch to turn this feature one?
17:41:55 <Pseudonym> Though I need to improve my prime sieve.
17:42:00 <wy> on/one
17:42:38 <Pseudonym> The SplitRecursive algorithm can be made much faster if you're clever.
17:42:40 <dons> wy, it may be that since the rts changed a bit when switcing to ghc 6.6, the blackholing stopped worked, or isn't used
17:42:48 <dons> wy, i know of no switch to turn it on
17:43:13 <dons> wy, so what I suggest is that you write to glasgow-haskell-users@haskell.org, and ask about it, why you need it , and so on.
17:43:20 <Pseudonym> The fastest version I made was to multiply numbers together until it overflowed an I#.
17:43:25 <dons> show that the code does work in early 6.5 series (and older), but not in 6.6
17:43:29 <Pseudonym> But that's GHC-specific.
17:43:31 <sorear> just checked
17:43:40 <Pseudonym> Incidentally, do you want a parallelisable factorial, dons?
17:43:45 <sorear> let x = x in x consumes infinite cpu
17:43:48 <dons> might be fun, Pseudonym
17:43:55 <sorear> blackholes would catch that
17:44:00 <Pseudonym> Well, you're doing the parallelism.  What do I do/
17:44:01 <Pseudonym> ?
17:44:07 <dons> > let x = x in x :: ()
17:44:09 <lambdabot>  Exception: <<loop>>
17:44:37 <sorear> (I'm 6.6, debian build)
17:45:14 <dons> seems to work for some loops, consider:
17:45:14 <glguy> my 6.6 PPC build doesn't detect the <<loop>> either
17:45:21 <dons> main = print $ let x = x in x :: ()
17:45:30 <dons> compiled with : $ ghc-6.6 A.hs
17:45:36 <dons> $ ./a.out
17:45:36 <dons> a.out: <<loop>>
17:45:40 <dons> sorear: can you check that?
17:46:13 <sorear> print $ (let x = x in x) hangs GHCi
17:46:20 <dons> does it work in ghc though?
17:46:31 <beschmi> dons: it hangs ghci, but ghc detects it for me
17:46:31 <dons> ghci might be different.. its a bytecode interpreter
17:46:35 <glguy> ghci hangs for me, but the compiledversion works
17:46:38 <dons> beschmi: ok. so ghci is special then
17:47:01 <sorear> ghc works for me
17:47:05 <dons> sorear, wy, so maybe ask on glasgow-haskell-users@ about blackhole detection in ghci .. but i wouldn't hold your breath
17:47:12 <dons> what's the use case?
17:47:14 <wy> dons: It works in ghc-6.7! I see. It only works in compiled code.
17:47:20 <dons> good
17:48:18 <wy> lispy: Was it you who pointed me to Peyton Jone's book "Implementing Functional Language: a tutorial"?
17:48:23 <sorear> # I've put RIO online ( http://members.cox.net/stefano
17:48:32 <dons> sorear++
17:48:37 <sorear> ack comments don't work :)
17:48:38 <dons> sorear: is it cablised?
17:48:43 <sorear> yes
17:48:47 <dons> great
17:48:54 <glguy> sorear: 404
17:48:57 <sorear> http://members.cox.net/stefanor/RIO-0.1.tar.gz
17:49:02 <lambdabot> http://tinyurl.com/y6kog5
17:49:25 <sorear> (I refered someone to IFPL, dunno if it was wy)
17:49:38 <sorear> supercombinators, i believe the subject was
17:49:52 <dons> sorear: do you have haddock docs for the lib?
17:50:01 <dons> (will help people work out how to use it)
17:50:01 <sorear> no :(
17:50:08 <wy> sorear: So it's you!
17:50:09 <dons> can you generate them and post them?
17:50:14 <Korollary> lol @ dons and Cale at Good Math Bad Math
17:50:17 <dons> sorear: runhaskell Setup.hs haddock
17:50:29 <Cale> Korollary: hm?
17:50:51 <dons> Korollary: sometimes i feel like this channel is an army of flying lambda monkeys ready to correct any wrong done to the good name of pure haskell
17:50:54 <dons> :)
17:50:58 <wy> sorear: Have you got the code of the book. I downloaded the "source code" and realized that's only TeX source for the book.
17:51:16 <Korollary> dons: hah
17:51:17 <SamB_XP> wy: and you are sure it doesn't come with programs?
17:51:31 <Botty> wy - could be literate haskell
17:51:31 <SamB_XP> of course, they would probably be in miranda
17:51:37 <SamB_XP> or something
17:51:46 <Botty> oh, miranda... literate miranda?
17:51:48 <Cale> _debrac: have you had any luck, is there any more information you could give me about the error?
17:52:09 <wy> SamB_XP: except some core programs. But the compilers are not there
17:52:39 <wy> Miranda is so much like Haskell
17:52:50 <Cale> wy: there's a good reason for that :)
17:53:09 <dons> wy, except it ain't free
17:53:30 <Cale> Haskell started out like the free version of Miranda
17:53:30 <sorear> (erm, just checked, Impl of FPL != Imp FL : a tutorial, sorry)
17:53:36 <wy> Cale: Are they inherited ? You mean Miranda is not free. I see it's trademarked
17:54:09 <dons> Haskell is decended from Miranda
17:54:19 <dons> I'm pretty sure Miranda dev has stagnated since the early 90s (?)
17:54:20 <Pseudonym> Actually, Haskell is the consolidation of a bunch of free Miranda-like languages.
17:54:31 <dons> all of them, except Clean (grumble grumble)
17:54:33 <Pseudonym> Miracula, Gofer, Orwell etc.
17:54:38 <glguy> isn't O(n!) basically O(n^n)?
17:54:47 <sorear> close
17:54:53 <dons> Pseudonym: Miracula?
17:55:07 <sorear> it's called Stirling's approximation
17:55:17 <glguy> I was just wondering if: O(log(n!)) might as well be O(n log n)
17:55:30 <sorear> that is the normal form of SA
17:55:37 <wy> sorear: They are by the same author. And ":a tutorial" is more practical as he says in the preface
17:55:43 <sorear> log(n!) ~= n*log(n)
17:55:52 <glguy> just checking
17:56:16 <Botty> yeah, O orders are pretty fiddly/aproximatey anyway, so it shouldn't matter
17:56:55 <_debrac> Hey
17:56:59 <_debrac> How do you do a list of lists?
17:57:02 <sorear> anyway O(n!) is bad, no exactness neccessary :)
17:57:04 <sorear> [[a]]
17:57:17 <_debrac> [[Int]]?
17:57:21 <Botty> an O(n^3) algo can be way faster than an O(1) algo for reasonable values of n
17:57:32 <sorear> the type of lists of lists of int, yes
17:57:33 <monochrom> such as n=1? :)
17:57:39 <dons> Pseudonym: "NSW to roll out free WiFi service" ...!
17:57:42 <Botty> heh
17:57:48 <sorear> n=0
17:58:34 <glguy> > take 4 $ iterate (join (^)) 2
17:58:36 <Botty> I mean, like the first algorithm's runtime is 1ms * n^3, whereas the constant time one takes 100s
17:58:36 <lambdabot>  [2,4,256,3231700607131100730071487668866995196044410266971548403213034542752...
17:58:37 <Pseudonym> dons: Woo!
17:58:51 <Korollary> the whole idea behind the O notation is possibly unreasonably large n
17:59:12 <monochrom> No.
17:59:27 <Botty> I don't like it when people choose algorithms based on it though
17:59:27 <Pseudonym> Yes.  The point behind the O notation is: If you can do N work on your computer, and you buy a computer that's twice as fast, how much more work can you do?
17:59:47 <Cale> glguy: yes
17:59:53 <glguy> ??
17:59:55 <Pseudonym> Or: If your program can handle N items in a given time, how long will it take to handle 2N items?
17:59:58 <Pseudonym> Questions like that.
18:00:17 <Botty> basically, it tells you how the algorithm scales
18:00:20 <Korollary> You know where n0 is. Maybe today your n is not larger than n0. Tomorrow it may be.
18:00:44 <Cale> log(n!) = log (product [1..n]) = sum (map log [1..n]) < sum (replicate n (log n)) = n * log n
18:00:45 * glguy has a pretty big n
18:00:56 <glguy> Cale: ah, cool
18:01:13 <sorear> 1*2*3*4 < 4*4*4*4
18:01:21 <sorear> the inequality is trivial
18:01:32 <sorear> haddock gives wierd errors
18:01:40 <sorear> s/ie/ei/
18:01:47 <Pseudonym> sorear: Doesn't matter, though.  O(1e-10 n^2) > O(1e+10n)
18:01:47 <Cale> log(1) + log(2) + log(3) + log(4) < 4*log(4)
18:02:15 <glguy> and O is the upper bound
18:02:17 <monochrom> I want to do real number arithmetic in the type language!
18:02:40 <sorear> Easy.
18:02:40 <Pseudonym> O(log n!) < O(n log n)
18:02:47 <Pseudonym> But for practical n, there's not a lot in it.
18:03:04 <Pseudonym> Actually, I believe there's notation that log n! = n lg* n or soemthing.
18:03:08 <sorear> Compile your real number package into CL, then use a type cl interp.
18:03:19 <sorear> Translating may be harder :)
18:03:58 <Korollary> Common Lisp is wrong. We need Esoteric Lisp.
18:04:06 <sorear> Combinatory Logic
18:04:46 <sorear> anyone know what this means:
18:04:47 <sorear> Preprocessing library RIO-0.1...
18:04:47 <sorear> Running Haddock for RIO-0.1...
18:04:47 <sorear> Warning: System.IO.RIO.Core: the following names could not be resolved:
18:04:47 <sorear>     wrapIO IO Monad
18:04:47 <sorear> Warning: System.IO.RIO.Handle: the following names could not be resolved:
18:04:48 <sorear>     rhFileSize rhIsEOF rhSetBuffering rhGetBuffering rhGetPosn rhIsOpen rhSeek rhFlush rhWaitForInput rhReady rhGetChar rhGetLine rhLookAhead rhGetContents rhPutChar rhPutStr rhPutStrLn rhPrint rhIsClosed rhIsReadable rhIsWritable rhIsSeekable Char Handle IO HandlePosn FilePath
18:04:52 <sorear> Warning: System.IO.RIO.Ref: the following names could not be resolved:
18:04:54 <sorear>     modifyRIORef IORef
18:04:56 <sorear> Warning: System.IO.RIO.Core: could not find link destinations for:
18:04:58 <sorear>     System.IO.RIO.Core.All
18:05:00 <sorear> Warning: cannot use package base-2.0:
18:05:02 <sorear>    HTML directory /usr/share/ghc-6.6/html/libraries/base does not exist.
18:05:37 <eviltwin_b> this suggests your install is broken
18:05:54 * sorear suddenly remembers the web :(
18:06:02 <monochrom> Is it imperative that your docs link to the ghc lib docs?
18:10:01 <dons> sorear: that looks ok to me
18:10:09 <dons> (I think)
18:10:43 * sorear notices the word 'Warning:' :(
18:10:57 <sorear> yes I have .html-files
18:11:03 <dons> its not as scary as it sounds
18:11:28 <dons> Igloo, we really should hush haddock, it worries too many users
18:12:07 <sorear> I use -Werror with C , I'm too used to reading warning as "I think you mean XYZ"
18:12:21 <sorear> (but of course cc1 is always wrong)
18:12:29 <dons> in this case, it just means it does have cross ref html entities for the base libs, I think
18:12:35 <dons> but that's ok
18:13:10 <sorear> (Yes! the output works)
18:13:31 <sorear> should I just recursive-put it on the site?
18:13:49 <sorear> BTW, I'd like to hear any comment people have on the idea
18:14:18 <Igloo> dons: Once haddock uses the GHC API perhaps we can tell it not to warn for thing not in the current package
18:14:19 <sorear> almost every idea I've had is obscure but unoriginal (or intractible)
18:15:27 <newsham> so I dont understand how I'm supposed to use the session functions from HAppS.
18:15:43 <newsham> my dispatch code executes in the event monad:  Ev MyState Request Result
18:15:57 <newsham> newsession looks like:  newSession :: Seconds -> a -> EvSession a SessionKey
18:16:07 <newsham> type EvSession a r = forall ev. Ev (State a) ev r
18:16:34 <newsham> so how could I possibly call from my dispatch code?
18:18:22 <dons> sorear: yep, cp *.html public_html/rio/ or whatever
18:19:24 * sorear is trying to find ftp's recursive put command
18:19:59 <dons> mput ?
18:20:04 <dons> you don't have scp?
18:20:10 <sorear> nope
18:20:53 * sorear gives up
18:20:56 <newsham> windows?  putty has an scp util
18:21:09 <newsham> (also sftp)
18:21:26 <sorear> No, I use Debian (linux), it's my ISP that doesn't have sshd
18:21:46 <sorear> I even use scp on the house-network
18:22:10 <SamB_XP> rsync ftw!
18:22:27 <SamB_XP> it also supports access via ssh
18:22:27 <eviltwin_b> recursive put isn't supported by all ftp clients
18:22:33 <glguy> Your ISP doesn't have sshd? what does that mean
18:22:36 <newsham> tar -czf - foo |nc 1.2.3.4 3333
18:22:49 <sorear> Secure shell daemon
18:22:57 <Korollary> the idiot isp probably only allows web uploads or ftp.
18:23:23 <sorear> yess , this same isp changed their webmail to make it lynx-incompatible
18:23:24 <glguy> sorear: No, i know what ssh is, but why would your internet service provider have anything to do with that
18:23:36 <sorear> It's there hosting
18:23:38 <TSC> To transfer files
18:23:43 <sorear> s/there/their/
18:23:50 <glguy> ah, your *web host* doesn't provide sshd?
18:24:00 <glguy> makes sense
18:24:00 <dons> sorear: you could upload the haddocks to the haskell wiki I uppose
18:24:17 <sorear> correct
18:24:20 <sorear> http://members.cox.net/stefanor/RIO-0.1-haddock/
18:24:23 <lambdabot> http://tinyurl.com/ylqpvx
18:25:02 <sorear> (that correct was for glguy)
18:25:04 <dons> ok good
18:25:20 <slack> can anyone tell me is you can make .exe or .app (OS X) out of .hs files?
18:25:23 <dons> sorear: now we need a tutorial on how to use it
18:25:29 <dons> slack: ghc --make A.hs
18:25:31 <slack> I am thinking of doing a project in haskell
18:25:54 <sorear> The README.LONG is pretty much a tutorial / advertisement
18:26:05 <sorear> I hope it leans toward the former
18:26:15 <dons> slack: you got ghc installed?
18:26:28 <slack> dons: Yup 6.6
18:26:38 <slack> is this the dons of Yi?
18:26:45 <dons> powerpc or x86?
18:26:45 <dons> sl	yep
18:26:51 <slack> x86
18:26:52 <dons> slack: yep
18:27:03 <dons> ok. you've seen http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
18:27:06 <slack> i am trying Yi but get an error when making
18:27:06 <lambdabot> Title: X86OSXGhc - GHC - Trac, http://tinyurl.com/fnmrx
18:27:27 <slack> dons: Yi/Buffer.hs:30:0:
18:27:27 <slack>     Bad interface file: Yi/Undo.hi-boot
18:27:28 <slack>         magic number mismatch: old/corrupt interface file?
18:27:28 <slack> make: *** [Yi/Buffer.o] Error 1
18:27:58 <dons> you using the darcs version of yi?
18:28:06 <slack> dons: no stable
18:28:14 <slack> dons d.0
18:28:18 <dons> try the darcs version, its been updated to 6.6
18:28:18 <slack> dons: 1.0
18:28:23 <robreim> How can I tell if a library has been compiled with profiling? Should any special files be present?
18:28:52 <dons> robreim: the library will be installed with libHSbase_p.a style suffix
18:29:03 <robreim> great, thanks
18:29:16 <dmead> bonk
18:29:16 <_paul> Hi there, can anybody tell me why this doesn't work? zip :: [Int] -> [Int] -> [(Int, Int)]
18:29:16 <_paul>            zip = [(x,y) | x <- a | y <- b]
18:29:30 <dmead> zip is a stanard function
18:29:33 <dmead> :)
18:29:43 <dmead> haskell has a zip already
18:29:45 <dmead> =S
18:29:52 <_paul> I know, but I'd like to get this working anyway
18:29:54 <sorear> I think what you just typed was cartesian product
18:29:55 <Lemmih> _paul: Does it work with -fglasgow-exts?
18:29:57 <dons> _paul: you need -fglasgow-exts
18:30:01 <Korollary> _paul: what's a & b ?
18:30:17 <dons> yeah, where are a and b bound?
18:30:20 <glguy> parallel list comprehensions aren't enabled by default
18:30:42 <dmead> darcs configurations are portable yes?
18:30:50 <dcoutts> dons, btw, have you booked a room for PADL yet ?
18:31:13 <dons> Prelude> :set -fglasgow-exts
18:31:14 <dons> Prelude> let pzipWith f xs ys = [ f x y | x <- xs | y <- ys ]
18:31:14 <dons> Prelude> :t pzipWith
18:31:14 <dons> pzipWith :: forall t1 t t2. (t1 -> t -> t2) -> [t1] -> [t] -> [t2]
18:31:14 <dons> Prelude> pzipWith (,) [1..10] "haskell"
18:31:16 <dons> [(1,'h'),(2,'a'),(3,'s'),(4,'k'),(5,'e'),(6,'l'),(7,'l')]
18:31:21 <dons> dcoutts: no. need to do it in the next few days...
18:31:38 <dons> dcoutts: have you?
18:31:44 <dcoutts> dons, there are at least three of us from the progtools group going to PADL/PEPM/POPL and we're booking tomorrow and considering the possibility of sharing rooms
18:31:55 <dons> ah ok.
18:31:57 <dons> yeah, i'd be interested
18:31:59 <dcoutts> dons, did we want to attend POPL too ?
18:32:08 <dons> i'm going to
18:32:12 <dons> and DAMP
18:32:26 * dcoutts looks for the list of talks
18:32:34 <dons> rl is talking about ndp/dph
18:32:56 <dcoutts> ah right
18:33:08 <dcoutts> I should probably learn more about that :-)
18:33:34 <dons> he's giving a talk to our group next week on specConstr and ghc's optimiser
18:33:35 <dmead> dons: are darcs repositories portable?
18:33:37 <dons> i'll try to get slides online
18:33:41 <dons> dmead: yeah?
18:33:53 <dmead> i'm asking
18:33:58 <dons> if you darcs get, certainly :)
18:34:00 <dmead> cause my webserver doesn't have darcs
18:34:13 <dons> ah , so an scp might work then
18:34:18 <dons> or unison/rsync
18:34:25 <sorear> darcs' says a selling-point is that a plain server will do
18:34:29 <dmead> ahh
18:34:30 <dmead> awesome
18:34:34 <slack> dons: does haskell have a gui framework for creating buttons, etc?
18:34:34 <dcoutts> "A Very Modal Model of a Modern, Major, General Type System"
18:34:40 <dons> slack: gtk2hs
18:34:43 <dons> ?where gtk2hs
18:34:44 <lambdabot> http://haskell.org/gtk2hs/
18:34:47 <_paul> Is there a way to do something like that without the glasgow extensions?
18:34:56 <dons> _paul: use zip?
18:35:06 <dons> recursion?
18:35:16 <sorear> do what?
18:35:30 <dons> _paul:
18:35:31 <dons> zip (a:as) (b:bs) = (a,b) : zip as bs
18:35:31 <dons> zip _      _      = []
18:35:32 <dons> ;)
18:35:43 <sorear> (Yes, since haskell is turing complete, but i doubt that's useful)
18:36:29 <dons> parallel list comprehensions are cute, but may not make it into Haskell' I suspect
18:36:40 <dons> unless someone started advocating them
18:37:18 <sorear> list comprehensions period have not stayed in my haskell short term memory
18:38:22 <dons> JohnMeacham: there's probably a few ways to panic the compiler with unboxed tuples, I suspect. good work!
18:38:26 <_paul> Thanks dons, that does the trick
18:38:47 <slack> dons: I get the following with Yi Devel from Darcs
18:38:49 <slack> Jason-T-Slacks-MacBook-Pro:~/yi slack$ ./Setup.hs configure
18:38:49 <slack> Configuring yi-0.2...
18:38:49 <slack> configure: /Developer/Applications/ghc-6.6/bin/i386-apple-darwin/ghc-pkg
18:38:50 <slack> configure: Dependency base-any: using base-2.0
18:38:50 <slack> Setup.hs: cannot satisfy dependency fps-any
18:38:50 <dcoutts> dons, so would you be interested in cutting costs by sharing with one of the progtools folk? So you want me to ask Oege about booking for you too?
18:38:56 <dons> slack: you need fps
18:38:57 <dons> ?where fps
18:39:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
18:39:42 <dons> dcoutts: that'd be great! yes, I have to book something, and then have the school refund me afterwards. so splitting a room with you guys would be good
18:39:52 <dons> do you have the dates?
18:40:13 <dcoutts> dons, well it's PADL then DAwhtever then POPL
18:40:28 <dons> right, heading straight from Oxford after Hac?
18:40:37 <dcoutts> dons, give or take a day, yes
18:40:48 <dons> ok. yes. that sounds good.
18:41:00 <dcoutts> dons, 14-15 for PADL, 16th for DAMP and 17-19 for POPL
18:41:20 <greentea> Hi all.
18:41:20 <dons> ok. good.
18:41:32 <dons> hey greentea . back for another round of lambda hacking?
18:41:38 <dons> did you get your arrows sorted yesterday?
18:41:46 <dons> dcoutts: just CC me the details.
18:41:49 <greentea> Heh, and yes they did, thanks. :-)
18:41:52 <dons> great
18:41:53 <dcoutts> dons, ok
18:42:05 <dons> dcoutts++ thanks for thinking of this!
18:42:33 <dcoutts> dons, I just got the email about group booking, I didn't think of anything :-)
18:45:22 <slack> dons: I am thinking about writing a gui framewor for haskell for a university project, any advice?
18:47:21 <dcoutts> slack, base it on top of an existing mid-level framework like Gtk2Hs.
18:47:32 <dcoutts> then you'll get results much quicker
18:47:56 <dcoutts> and get to concentrate on getting the right api etc rather than fiddling with low level implementation stuff
18:47:56 <_paul> dons, about that code.. if I wanted to modify it so that it would pair the first element of list a to the last element of list b, what would I have to do? e.g. the equivalent of zip [1..5] (reverse [1..5])
18:48:26 <slack> dcoutts thanks for the advice
18:48:43 <dmead> slack: you can write a gui for my theorem prover =p
18:48:47 <_debrac> OK
18:48:47 <slack> I want to aim for a nice clean API like Qt by Trolltech
18:48:50 <_debrac> Got a syntax error
18:48:54 <_debrac> Please check (1 line)
18:49:04 <slack> dmead, oh really!
18:49:22 <dmead> slack: yea if you want to
18:49:47 <dons> slack: you could write a binding to Qt
18:49:55 <dons> that would be a good project
18:50:08 <_debrac> It's coming
18:50:14 <_debrac>  (s!!0)!!n == 0 = sud (n+1) (oku n (s!!sol) | sol <- [0..(length s)])
18:50:18 <slack> bindings for Qt would be interesting
18:50:32 <_debrac> Please check that (parse error)
18:50:37 <dmead> yea you could use dcoutt's gtk bindings as a model
18:50:44 <Cale> _debrac: you're defining == ?
18:50:51 <Cale> !! isn't a data constructor
18:50:56 <_debrac> Cale: No...
18:50:58 <dmead> what the ell is !
18:50:59 <dmead> =/
18:51:09 <_debrac> Isn't !! like ahh a[0]?
18:51:10 <sorear> !! is list indexing
18:51:13 <slack> dmead: what is your therom?
18:51:19 <_debrac> sorear: Yeah...
18:51:27 <Cale> _debrac: what are you intending to define here?
18:51:30 <_debrac> s is a list of lists
18:51:34 <dmead> my theorem prover?
18:51:43 <dmead> it just proves logic statements
18:51:48 <slack> yeah sorry bad typing today
18:51:49 <_debrac> Cale: All we are doing is trying to get s[x]
18:51:58 <Cale> s !! x
18:52:06 <_debrac> Cale: S is 2-d array
18:52:08 <_debrac> so
18:52:13 <_debrac> s[0][x]
18:52:20 <Cale> > ["Hello", "There", "World"] !! 1
18:52:22 <lambdabot>  "There"
18:52:26 <Cale> > ["Hello", "There", "World"] !! 1 !! 3
18:52:26 <dmead> hold on i'm making a darcs repository
18:52:28 <lambdabot>  'r'
18:52:53 <_debrac> ummmmmmm
18:52:56 <_debrac> Ok......
18:53:03 <_debrac> But it's a list of lists?
18:53:05 <Cale> Is the very left side of that line part of a guard?
18:53:06 <Cale> yeah
18:53:15 <Cale> A string is a list of characters
18:53:23 <_debrac> yeah
18:53:29 <Cale> So a list of strings is a list of lists of characters
18:53:33 <_debrac> yes - gaurd
18:53:40 <_debrac> guard*
18:53:51 <_debrac> But no grevious error?
18:54:04 <ptolomy> Wowzers. The haskell implementation of Levenschtein on wikipedia is impressively inefficient.
18:54:07 <Cale> okay, the next problem I see is that you have (oku n (s!!sol) | sol <- [0..(length s)])
18:54:11 <glguy> what you pasted is nonsensical, Cale is trying to figure out what you are doing
18:54:27 <_debrac> Cale: ok...
18:54:28 <_debrac> so...?
18:54:32 <Cale> The | and <- are not in a list comprehension there, so that's not valid
18:54:40 <Cale> perhaps you want...
18:54:45 <Cale> [oku n (s!!sol) | sol <- [0..(length s)]]
18:54:55 <dmead> ! is so ugly
18:55:08 <glguy> or [oku n x | x <- s]
18:55:14 <_debrac> Cale: But that returns another list? a list of list of lists?
18:55:14 <Cale> yes
18:55:21 <eviltwin_b> arguably that's the idea... ! is not haskell-think :>
18:55:21 <_debrac> Should we do outermost ()s?
18:55:41 <Cale> ( ... | ... <- ...) is not valid syntax
18:55:50 <robreim> dcoutts: Are you aware of any way to get gtk2hs' installer to work with ghc6.4.2 or newer?
18:55:56 <_debrac> Cale: But that would return a list of lists of lists?
18:56:06 <dcoutts> robreim, you mean on windows?
18:56:09 <Cale> I don't know the type of oku, so I have no idea
18:56:12 <robreim> Yeah, sorry :)
18:56:19 <_debrac> Cale: We really need to concantenate all the lists we are getting back
18:56:26 <dcoutts> robreim, http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10.exe
18:56:28 <lambdabot> http://tinyurl.com/y9cc2s
18:56:40 <dcoutts> robreim, that's a build for ghc-6.4.2 and gtk+-2.8.x
18:56:42 <_debrac> Cale: oku is oku :: Int->[Int]->[[Int]]
18:56:45 <Cale> concatMap (oku n) s ?
18:57:00 <_debrac> Cale: no... can't use that...
18:57:01 <robreim> loverly. I'll try it out
18:57:04 <dcoutts> robreim, the next gtk2hs release will be for ghc-6.4.2 and ghc-6.6
18:57:15 <Cale> or concat (map (oku n) s)
18:57:15 <Excedrin> > flip ((head .) . drop) [1..10] 5
18:57:17 <lambdabot>  6
18:57:24 <dcoutts> well the win32 installer anyway, it builds from source with anything
18:57:28 <Cale> or concat [oku n x | x <- s]
18:57:32 <dcoutts> even a pointed stick
18:57:33 <Excedrin> pl is fun to play with
18:57:38 <robreim> Great, thanks :)
18:57:46 <_debrac> Cale: ok - I will have to fix this a little more
18:57:49 <_debrac> thanks for the tips
18:57:56 <robreim> I tried building from source but I can't seem to execute shells using wine (I'm using wine)
18:58:30 <_debrac> Cale: I am doing like a for each item in list thing?
18:58:41 <_debrac> Is there a better way to do for each?
18:58:53 <Cale> map is essentially 'for each'
18:59:01 <dons> ptolomy: put up a better version then.
18:59:11 <_debrac> Cale: Is map pre-defined?
18:59:12 * dons notes that a lot of haskell on wikipedia is weird/ugly/slow :/
18:59:15 <sorear> yes
18:59:15 <Cale> yes
18:59:16 <ptolomy> dons: Tried.
18:59:17 <_debrac> :/
18:59:23 <Cale> > map (replicate 5) [1,2,3]
18:59:25 <lambdabot>  [[1,1,1,1,1],[2,2,2,2,2],[3,3,3,3,3]]
18:59:31 <Cale> > concatMap (replicate 5) [1,2,3]
18:59:32 <dons> ptolomy, i've got one lying around, the one used in lambdabot
18:59:33 <lambdabot>  [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3]
18:59:44 <Pseudonym> A lot of the shootout code is also weird and ugly, though admittedly not slow.
18:59:47 <ptolomy> dons: As of now, I seem to lack the skillz to make a haskellish-yet-efficient version.
19:00:05 <Cale> > map (\x -> [x,x+1]) [1,2,3]
19:00:07 <lambdabot>  [[1,2],[2,3],[3,4]]
19:00:07 * ptolomy peeks at lambdabot's innards.
19:00:16 <dons> ptolomy: grep for leven in http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Util.hs
19:00:16 <Cale> > map (\x -> x + 1) [1,2,3]
19:00:17 <lambdabot> http://tinyurl.com/w8yvx
19:00:18 <lambdabot>  [2,3,4]
19:00:39 <lambdabot> Oi! Stop that! Look at your own innards!
19:00:49 <sorear> > map (^2) [1..]
19:00:51 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
19:01:14 <dons> ?yoow <- levenshtein in action
19:01:15 <lambdabot> What GOOD is a CARDBOARD suitcase ANYWAY?
19:02:09 <Cale> > map (2^) [1..]
19:02:10 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
19:02:22 <robreim> Hmm... it still says "your gtk2hs or GHC is messed up" when I try installing.
19:03:03 <sorear> > map ((read . reverse . show) :: Int -> Int) [1,3..]
19:03:05 <lambdabot>  [1,3,5,7,9,11,31,51,71,91,12,32,52,72,92,13,33,53,73,93,14,34,54,74,94,15,35...
19:03:05 <robreim> dcoutts: any idea what could be causing that?
19:03:16 <Pseudonym> > scanl (+) 1 [3,5..]
19:03:19 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
19:03:30 <glguy> where is the Levenschtein algorithm on wikipedia?
19:03:31 <dcoutts> robreim, let me check...
19:03:33 <Pseudonym> > scanl (*) 1 [2,2..]
19:03:34 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:03:46 <Pseudonym> Slightly more efficient.
19:03:47 <glguy> nevermind, found it
19:03:50 <sorear> Wikip spells it Levenstein distance
19:04:01 <glguy> http://en.wikipedia.org/wiki/Levenshtein_distance
19:04:03 <lambdabot> http://tinyurl.com/4ryzf
19:04:21 <dcoutts> robreim, is that all it says ?
19:04:26 <Pseudonym> > iterate (*2) 1
19:04:27 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:04:31 <robreim> dcoutts: it could be wine related, so if you're not familiar with the problem then it's probably not something you can reproduce.
19:04:52 <dcoutts> robreim, wine!? I thought you were using windows
19:05:22 <dcoutts> robreim, if you're using linux the just build it properly
19:05:27 <dcoutts> the/then
19:05:29 <robreim> dcoutts: first it says "GHC does not appear to be installed correctly, try reinstalling GHC version 6.2.2 or 6.4.2". It then continues regardless and says "Your installation of GHC or Gtk+ is messed up!"
19:05:53 <robreim> dcoutts: I'm trying to build applications for windows without actually having windows :)
19:06:21 <robreim> dcoutts: Mostly it's worked well, but I can't get installations or builds of gtk2hs to work for some reason.
19:06:34 <dcoutts> robreim, you're totally on your own with that. I've no idea about using wine. GHC actually installs under wine?
19:06:49 <dcoutts> robreim, make sure ghc.exe is on your windows path
19:06:54 <robreim> dcoutts: That's fine, I was just wondering if these problems were anything you were familiar with.
19:06:57 <sorear> could you use just use mingw32 as the compiler ? (does GHC genereate portable code?)
19:07:04 <robreim> Yah, it installs well.
19:07:22 <sorear> Debian has a unix-hosted windows-targeted gcc in the main repository
19:07:38 <robreim> ghc is in the windows path. I've got both ghc 6.4.2 and ghc 6.6 installed and have verified the path is pointing to the correct one.
19:07:56 <glguy> from the wikipedia article on levenshtein distance: "A simple, yet efficient recursive implementation is possible in Haskell, provided that the compiler uses automatic memoization (which is not guaranteed):"
19:08:15 <sorear> GHC doesn't
19:08:16 <robreim> sorear: where's that?
19:08:20 <glguy> when does  a haskell compiler ever do automatic memoization
19:08:22 <jcreigh> does *any* Haskell compiler provide automatic memoization?
19:08:35 <glguy> on function calls
19:08:43 <glguy> and not just top level whatchamacallits
19:08:48 <robreim> sorear: never mind, sorry I misread you as saying ghc.
19:09:42 <ptolomy> I love the ole "assuming an advanced enough compiler.." trick.
19:09:52 <dcoutts> robreim, use /LOG=output.log and check run the installer again
19:09:59 <dcoutts> and then check the logs
19:10:00 <monochrom> Yeah I don't harp that.
19:10:03 <dcoutts> er log
19:10:03 <glguy> this would be easy to memoize though
19:10:05 <Cale> Well, it's pretty trivial to rewrite that algorithm such that memoisation is applied.
19:10:27 <glguy> right
19:10:33 <Cale> Because all you need to do is construct an array of results, and index into that array rather than making the recursive call.
19:10:33 <sorear> In 'stretching the storage manager' SPJ implements a memoy combinator
19:10:39 <dmead> whatchamacallits
19:10:42 <glguy> I just mean using the tabulate + dp functions that are so easy to find
19:10:43 <dmead> is that a scientific term?
19:10:44 <dmead> =p
19:11:04 <sorear> tabulate : common usage
19:11:09 <monochrom> "Assuming an advanced compiler, your bubble sort code will be replaced by quicksort with smart pivoting."
19:11:13 <dcoutts> robreim, according to the isntaller code, you get that error if it find ghc.exe but when it calls ghc --print-libdir it ends up with ""
19:11:24 <Cale> monochrom: well, that's completely different
19:11:47 <robreim> dcoutts: great, thanks. That gives me somewhere to start from :) dcoutts++
19:11:56 <sorear> "Assuming a smart compiler, your code will be e-mailed to India where a gifted teenager will rewrite it in bugfree asseembly language"
19:12:01 <Cale> however, if your code says 'sort' and leaves it up to the compiler how to sort, then it's reasonable to assume that it will use a reasonable sorting algorithm
19:12:32 <monochrom> I like sorear's more.
19:12:37 <glguy> the last time I actually saw code out of india, the only control structure it used was if then else
19:12:53 <wchogg> sorear:  can the compiler make static guarentees about which gifted teenager or how gifted he will be?
19:12:56 <glguy> loops were the result of cut and paste
19:12:59 <monochrom> They are not showing you their secret recipes of course!
19:13:26 <monochrom> Their loops are in their code generators!
19:14:14 <monochrom> The code generators create seemingly-dumb unrollings, plus stochastic spacing and naming so you think they're manually entered.
19:14:36 <glguy> I'd be impressed with that if the result was code that actually worked well
19:14:46 <monochrom> Oh, darn!
19:14:47 <wchogg> They even make errors with a distribution similar to a bored and low paid human.
19:14:59 * monochrom goes back to debug India.
19:16:31 <dcoutts> robreim, actually, it looks to me like it's failing when it tries to find the ghc version.
19:16:51 <dcoutts> robreim, (which is not quite the same error as finding that it's the wrong version)
19:17:08 <ptolomy> I used to write haskell in a place called "The Monadnock Building". That was fun.
19:17:34 <SamB_XP> monochrom: but my bubble sort code is essential to the proper functioning of my code!
19:17:44 <dcoutts> robreim, if I were you, I'd just build it on linux and then get it working on windows when you've got access to a windows box. Do you know if Gtk+ works ok in wine? Have you tried the gtk-demo prog?
19:17:45 <SamB_XP> a quicksort just won't do the job
19:17:58 <wchogg> Sorry Sam, the compiler knows best.
19:18:12 <monochrom> Like your shooting game will become too fast?
19:18:20 <SamB> um, no.
19:18:26 <sorear> I'm really clever and I fused my side-effectful update with the sort by adding the impure code to the comparison!!!
19:18:42 <SamB> actually I'm trying to get it to create blackknot solutions
19:18:50 <sorear> s/^/"/; s/$/"/
19:19:08 <monochrom> haha that's krad!
19:19:16 <Pseudonym> "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
19:19:25 <SamB> Pseudonym: no, that would be too slow
19:19:36 <robreim> dcoutts: No, I haven't checked gtk yet actually... but I'll probably end up doing as you suggest.
19:19:41 <SamB> you know the typechecker has performance issues
19:20:11 <monochrom> But you'll also compile the typechecker by the advanced compiler.
19:20:34 <_debrac> I need to output something
19:20:37 <_debrac> to debug it
19:20:40 <_debrac> How do I do that?
19:20:45 <_debrac> Its not a predefined type
19:20:52 <monochrom> @remember Pseudonym "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
19:21:04 <Cale> _debrac: add 'deriving (Show)' to your data declaration
19:21:16 <vincenz> monochrom: is no the time to mention that c++ templates are turing complete?
19:21:19 <_debrac> Cale: I don't have access to the data declaration
19:21:20 <vincenz> s/no/now
19:21:31 <_debrac> Cale: Dont ask
19:21:32 <monochrom> that's old story.
19:21:33 <Cale> _debrac: ah, then you'll need to write one yourself
19:21:39 <vincenz> _debrac: instance Show TheDataType where..
19:21:40 <Cale> instance Show MyType where
19:21:47 <Cale>    show x = ...
19:21:48 * vincenz beeps Cale 
19:21:50 <wy> Is there a function to do substitution in lists?
19:21:59 <Cale> vincenz: hm?
19:21:59 <monochrom> We're now into the business of Pi_2 etc.
19:22:09 <vincenz> Pi_2?
19:22:10 <_debrac> Ok - how about a debugger
19:22:12 <_debrac> In Hugs?
19:22:16 <_debrac> I hate hugs
19:22:19 <robreim> Is "Inno Setup" (what gtk2hs uses?) a pretty typical way to distribute haskell programs for windows or are there other suggestions?
19:22:22 <_debrac> But -- it's the only option
19:22:28 <Cale> _debrac: you add this into your file
19:22:44 <_debrac> Cale: ok...
19:22:44 <dcoutts> robreim, talk to ndm about packaging for windows.
19:22:50 <Cale> It shouldn't matter which interpreter/compiler you use
19:22:55 <robreim> dcoutts: ok, thanks.
19:22:56 <monochrom> Pi_n = Problems that need asking the nonhalting-problem oracle n times to solve.
19:23:01 <_debrac> Cale: ok...
19:23:14 <dcoutts> robreim, I think only Gtk2Hs uses InnoSetup. GHC uses a custom msi builder. Other things just use .zip files.
19:23:25 <Cale> If you want to print intermediate data structures as they're evaluated, look into Hugs.Observe (I think it's called that)
19:23:26 <monochrom> And Sigma_n = Problems that need asking the halting-problem oracle n times to solve.
19:23:27 <SamB_XP> monochrom: the what oracle?
19:23:34 <vincenz> What about Pi_(Pi_n)
19:23:42 <monochrom> Pi_n is not a number.
19:23:44 <dcoutts> robreim, if you know about windows, help with packaging on that platform would be of great benefit.
19:23:48 <_debrac> Cale: ok... I'll look for it
19:23:55 <vincenz> monochrom: so you think
19:23:59 <SamB_XP> what is a "nonhalting-problem" oracle?
19:24:01 <Cale> http://cvs.haskell.org/Hugs/pages/users_guide/observe.html
19:24:04 <lambdabot> http://tinyurl.com/yywdm3
19:24:07 <dobblego> ?check (\a::Int -> a + 1 - 1 == a)
19:24:08 <lambdabot>  Parse error
19:24:12 <dobblego> how do I correct that?
19:24:21 <robreim> dcoutts: I'd love to be able to help - but I use wine not windows, so what works for me might not work for others :)
19:24:23 <sorear> deriving (Show) for foo
19:24:28 <dobblego> ?check (\a -> a::Int + 1 - 1 == a)
19:24:29 <lambdabot>  Parse error
19:24:33 <sorear> highly experimental GHC extention
19:24:39 <Botty> wy - like sub :: Eq a => [a] -> [a] -> [a] -> [a] or sub a -> a -> [a] -> [a]?
19:24:41 <monochrom> The halting problem asks: does it halt?  The nonhalting problem asks: does it not halt?  The latter is harder than the former.
19:24:42 <jdev> ?ty (\(a::Int) -> a + 1)
19:24:44 <lambdabot> Int -> Int
19:24:46 <dobblego> ah thanks
19:25:04 <wy>  sub a -> a -> [a] -> [a]
19:25:06 <dobblego> ?check (\(a::Int) -> a + 1 - 1 == a)
19:25:07 <lambdabot>  Parse error in pattern
19:25:10 <Botty> ah, good
19:25:16 <vincenz> ?check (\a -> (a::Int) + 1 - 1 == a)
19:25:17 <dcoutts> robreim, aye, true. I've got limited access to one win2k3 box via rdesktop.
19:25:18 <lambdabot>  OK, passed 500 tests.
19:25:25 <dobblego> yay thanks
19:25:38 <vincenz> ?check (\a -> (a::Float) + 1 - 1 == a)
19:25:39 <lambdabot>  Falsifiable, after 20 tests: 0.3333333
19:25:55 <vincenz> \o/
19:25:57 <dobblego> nice
19:26:08 <sorear> even LB knows that! wow!
19:26:28 <SamB_XP> monochrom: so I can't just say not . halting-oracle?
19:26:32 <jdev> I'm not surprised in the least, but: Nice.
19:26:40 <wy> Botty: Do you know if there is a library function doing that?
19:26:50 <robreim> dcoutts: That sounds almost as annoying as trying to develop using wine :(
19:26:59 <Botty> wy - there's not, but writing your own should be easy
19:27:09 <dcoutts> robreim, aye, it is rather annoying.
19:27:13 <Botty> I can write it if you like
19:27:30 <jdev> Is the halting oracle one of those theory things that indicates "no" by not halting?
19:27:39 <sorear> yes
19:27:39 <wy> Botty: Yes. I'm just wondering. I only write utillities if there isn't one in the standard library
19:27:45 <dcoutts> robreim, I can't even run .msi installers because I don't have sufficient permissions to do so.
19:27:48 <_debrac> Cale: I need to return a null
19:27:49 <monochrom> You can. But here is another fun factoid.  The halting problem is semi-decidable.  The nonhalting problem is not even semi-decidable.
19:27:52 <Botty> subs m w = map (\x -> if m == x then w else x)
19:27:53 <_debrac> Err just nothing
19:27:56 <Botty> something like that
19:27:59 <SamB_XP> monochrom: ah.
19:28:07 <_debrac> If I return [] -- will that tack a list onto it?
19:28:07 <SamB_XP> what does that mean?
19:28:09 <_debrac> or is that nothing?
19:28:10 <Cale> _debrac: Perhaps you need the Maybe type?
19:28:15 <sorear> erm, isn't the nonhalting problem co-semi-decidable?
19:28:22 <robreim> Ouch. That sounds on-par with wine on the annoyance scale.
19:28:24 <SamB_XP> can't I decide that "no, this thing certainly doesn't not halt?"
19:28:26 <sorear> ?type (return [])
19:28:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a]
19:28:37 <SamB_XP> sometimes?
19:28:48 <sorear> explicitly kinded forall? yow.
19:28:51 <SamB_XP> I mean, take "return ()" for instance...
19:28:51 <Excedrin> maybe
19:29:04 <Cale> _debrac: If a function returns a value of type t sometimes, it always returns a value of type t
19:29:11 <glguy> ?yow
19:29:12 <lambdabot> I'm young ... I'm HEALTHY ... I can HIKE THRU CAPT GROGAN'S LUMBAR
19:29:12 <lambdabot> REGIONS!
19:29:32 <monochrom> A method of solving a semi-decidable problem with the lambda calculus is this.  Does X halt?  Well try running it.  If the answer is yes, you will know eventually.
19:29:44 <danly> monochrom, define "semi-decidable"? That's an interesting term
19:29:45 <monochrom> This method is not available for the nonhalting problem.
19:29:49 <dmead> someone try this?
19:29:51 <Cale> _debrac: So in order to introduce failure, you usually need to move to a larger type which represents it explicitly -- if you're already returning a list of values, returning an empty list is one option though.
19:29:51 <dmead> darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/
19:30:16 <SamB_XP> monochrom: well, you would eventually learn if the answer was "no"
19:30:24 <Cale> _debrac: The type constructor which handles this in Haskell is called Maybe, and it's defined as  data Maybe a = Nothing | Just a
19:30:42 <sorear> the set of halting programs is recursively enumerable
19:30:59 <SamB_XP> o rly!
19:31:02 <sorear> of course all haskell types have a built-in error value _|_
19:31:14 <Cale> > let safeHead [] = Nothing; safeHead (x:xs) = Just x in safeHead []
19:31:15 <lambdabot>  Add a type signature
19:31:28 <Cale> > let safeHead [] = Nothing; safeHead (x:xs) = Just x in safeHead ([] :: [Int])
19:31:30 <lambdabot>  Nothing
19:31:35 <Cale> > let safeHead [] = Nothing; safeHead (x:xs) = Just x in safeHead ([3,5,6] :: [Int])
19:31:36 <SamB_XP> I didn't know the set of type-correct programs was RE!
19:31:37 <lambdabot>  Just 3
19:31:40 <jdev> ?ty maybe
19:31:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:31:44 <sorear> mapM (\tm -> forkIO (run tm >> print tm) [turing machines]
19:31:57 <sorear> that'll print all halting programs
19:32:07 <sorear> (it will also be amazingly slow)
19:32:22 <_debrac> OK
19:32:28 <_debrac> Coming down to the last few things here
19:32:35 <_debrac> Can I remove empty lists easily?
19:32:44 <sorear> filter (not . null) ???
19:32:45 <Cale> what do you mean by "remove"?
19:32:54 <_debrac> Cale: throw them away
19:33:05 <Cale> yeah, filter (not . null) will remove empty lists from a list of lists.
19:33:06 <_debrac> Garbage them
19:33:07 <monochrom> Here is a method to enumerate halting problems.  for i:=0 to oo; for j:=0 to oo; if program #i halts after j steps, output program #i.
19:33:19 <_debrac> Cale: Can you give an example?
19:33:26 <monochrom> A similar method is not available for nonhalting problems.
19:33:30 <sorear> monochrom : you need to permute the loops
19:33:40 <Cale> > filter (not . null) [[], [1,2,3], [], [], [4,5], [], [6]]
19:33:41 <sorear> but nonhalting is co-RE
19:33:41 <SamB_XP> monochrom: don't you have the foralls backwards?
19:33:42 <lambdabot>  [[1,2,3],[4,5],[6]]
19:33:50 <monochrom> OH DARN!  I have to trampoline it!
19:34:07 <_debrac> Cale: Thanks man
19:34:10 <jdev> > let safeHead = ((foldr mplus mzero) :: [a] -> Maybe a) in map safeHead [[],[1,2,3]]
19:34:11 <lambdabot>  a -> Maybe a -> Maybe a
19:34:12 <lambdabot>    Inferred type: m a1 -> m a1 -> m a1
19:34:12 <Cale> no problem
19:34:24 <SamB_XP> WTH is co-RE
19:35:04 <sorear> http://en.wikipedia.org/wiki/Co-RE
19:35:06 <monochrom> I'm too lazy to fix my algorithm.
19:35:18 <jdev> Oh, right.
19:35:27 <jdev> > let safeHead = ((foldr mplus mzero . map return) :: [a] -> Maybe a) in map safeHead [[],[1,2,3]]
19:35:29 <lambdabot>  [Nothing,Just 1]
19:36:02 <sorear> ?hoogle MonadPlus m => [m a] -> m a
19:36:03 <lambdabot> Prelude.head :: [a] -> a
19:36:03 <lambdabot> Prelude.last :: [a] -> a
19:36:03 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
19:36:39 <wy> Botty: I wrote it. The type should be subst :: Eq a => a->a->[a]->[a]
19:37:04 <Botty> right. cool
19:37:12 <Botty> you just did a map, right?
19:37:32 <Botty> I almost wrote a recursive func.  I've got in a bad habit of writing them unecessarily
19:37:59 <wy> Unfortunitely I wrote it recursively
19:37:59 <jdev> > let safeHead = ((foldr mplus mzero . map return) :: [a] -> Maybe a) in safeHead [1..]
19:38:01 <lambdabot>  Just 1
19:38:10 <wy> I'll try map
19:38:20 <_debrac> Cale: Works now - thanks
19:40:17 <dmead> can someone try this? darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/
19:40:19 <sorear> > let safeHead x = (do (k:_) <- x ; return k) :: [a] -> Maybe a in safeHead [1..]
19:40:21 <lambdabot>       (do
19:40:21 <lambdabot>        (k : _) <- x
19:40:21 <lambdabot>        return k) ::
19:40:21 <lambdabot>      ...
19:40:32 <wy> >let subst x y s = [ if (x==ss) then y else ss | ss <- s ] in subst 1 2 [1,2,3,4]
19:40:42 <sorear> > let safeHead x = ((do { (k:_) <- x ; return k } ) :: [a] -> Maybe a) in safeHead [1..]
19:40:43 <lambdabot>       (do
19:40:44 <lambdabot>        (k : _) <- x
19:40:44 <lambdabot>        return k) ::
19:40:44 <lambdabot>      ...
19:40:56 <sorear> > let safeHead x = (do (k:_) <- return x ; return k) :: [a] -> Maybe a in safeHead [1..]
19:40:57 <lambdabot>       (do
19:40:57 <lambdabot>        (k : _) <- return x
19:40:57 <lambdabot>        return k) ::
19:40:57 <lambdabot>   ...
19:41:32 <Botty> > let subst2 a b = map (\x -> if x == a then b else x)
19:41:33 <lambdabot>  Parse error
19:43:07 <wy> Botty: That's nice!
19:43:26 <Korollary> dmead: It's not working for me.
19:43:30 <Botty> yes, yes it is :)
19:43:44 <wy> Botty: I forgot that I can do a etta-reduction ;-)
19:44:14 <falconair> does any one have an example of traversing a tree structure in a list comprehension...assuming its possible?
19:44:22 <dmead> Korollary: you on windows?
19:44:24 <jdev> And this is happy fun Haskell-land, where we're free from the bonds of the value restriction.
19:44:28 <Korollary> dmead: No, linux.
19:44:30 <dmead> hmm
19:45:07 <dmead> this ?
19:45:07 <dmead> darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/
19:45:32 <dmead> Korollary: ^
19:46:16 <Korollary> Nope
19:46:20 <dmead> :s
19:46:25 <dmead> what happens?
19:46:28 <Cale> falconair: list comprehensions build lists... I'm not completely sure about what you're getting at -- certainly, it's possible to write functions which expose various traversals of trees as lists.
19:46:54 <dons> falconair: Tree's are in functor, so you can *map* on them
19:46:59 <dons> if we had monad comprehensions...
19:47:01 <dons> instance Functor Tree where
19:47:03 <dons>   fmap f (Node x ts) = Node (f x) (map (fmap f) ts)
19:47:09 <dmead> dons: can you try my repository?
19:47:25 <sorear> data Node a = Ascend | Descent | Data a
19:47:31 <sorear> data Tree a = [Node a]
19:47:31 <dons> $ darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/
19:47:31 <dons> Copying patch 1 of 1... done!
19:47:31 <dons> Applying patch 1 of 1... done.
19:47:31 <dons> Finished getting.
19:47:42 <dmead> cool cool
19:47:46 <sorear> nice and flat...
19:47:56 <dons> instance Traversable Tree where
19:47:57 <dons>   traverse f (Node x ts) = Node <$> f x <*> traverse (traverse f) ts
19:48:53 <dobblego> ?hoogle Int -> [a] -> Bool
19:48:55 <lambdabot> No matches, try a more general search
19:48:59 <falconair> Cale,dons , i have to admit, i'm actually using python's list comprehension to traverse a class hierarchy and populate a nested list...there isn't a lot of python literature on complex list comprehension, i figured haskell people are more likely to know ;)
19:49:22 <falconair> ...populate a nested list WITH CLASS NAMES ...
19:49:31 <dons> falconair: python doesn't have monad comprehensions, so I don't think it'll fly
19:49:35 <dons> Cale: right?
19:49:39 <sorear> how do I get this prover to act cool?
19:49:41 <jdev> ?pl \x y -> x < length y
19:49:41 <lambdabot> (. length) . (<)
19:49:55 <dons> ?type (. length) . (<)
19:49:55 <Cale> dons: I'm not sure that's what's being attempted here
19:49:56 <lambdabot> forall a. Int -> [a] -> Bool
19:49:56 <sorear> python doesn't have (endorsed) monads
19:50:01 <dons> ?let dot2 = (.) . (.)
19:50:03 <lambdabot> Defined.
19:50:15 <dons> ?type length `dot2` (<)
19:50:16 <lambdabot> Not in scope: `dot2'
19:50:23 <dons> ?type length `L.dot2` (<)
19:50:23 <dobblego> > let hasLength 0 [] = True; hasLength 0 _ = False; hasLength n (x:xs) = hasLength (n - 1) xs in hasLength 7 [1..]
19:50:24 <lambdabot> Couldn't find qualified module.
19:50:25 <lambdabot>  False
19:50:35 <jdev> ?. ty pl \x y -> x < length y
19:50:36 <lambdabot> compose module failed: IRCRaised Parse error: "ty"
19:50:44 <dons> > length `L.dot2` (<)
19:50:45 <lambdabot>  Couldn't match `[a]' against `Bool'
19:51:38 <newsham> ?type liftM . Just
19:51:41 <lambdabot>   Couldn't match `a1 -> r' against `Maybe a'
19:51:41 <lambdabot>    Expected type: a -> a1 -> r
19:52:12 <Cale> falconair: python has dynamic typing, so I suppose you could do something like the equivalent of  traverse x = x : [traverse y | y <- children x] -- that'll never fly in Haskell, but you get what I mean, I hope.
19:52:42 <newsham> ?pl \a -> do { x <- a; return (Just a) }
19:52:43 <lambdabot> (line 1, column 10):
19:52:43 <lambdabot> unexpected "{"
19:52:43 <lambdabot> expecting variable, "(", operator or end of input
19:52:53 <falconair> yeah, i'll try that and dig around a bit more, thanks Cale, dons
19:52:56 <Cale> falconair: Caveat: I don't *really* know what you're trying to do :)
19:53:57 <jdev> ?ty let tr x c = x : [tr y c | y <- c x] in tr
19:53:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
19:54:00 <lambdabot>    Expected type: a
19:54:09 <newsham> ?pl (\a -> do { x <- a; return (Just a) })
19:54:10 <lambdabot> (line 1, column 11):
19:54:10 <lambdabot> unexpected "{"
19:54:10 <lambdabot> expecting variable, "(", operator or ")"
19:54:14 <jdev> Oh, right.
19:54:41 <newsham> ?pl \a -> do { x <- a; return (Just x) }
19:54:42 <lambdabot> (line 1, column 10):
19:54:42 <lambdabot> unexpected "{"
19:54:42 <lambdabot> expecting variable, "(", operator or end of input
19:54:57 <eviltwin_b> newsham: pl can't understand do, you have to express it in terms of >>=
19:55:03 <newsham> ?pl \a -> a >>= (\x -> return (Just x))
19:55:04 <lambdabot> (Just `fmap`)
19:56:17 <sjanssen> @. pl undo \a -> do { x <- a; return (Just x) }
19:56:17 <lambdabot> (Just `fmap`)
19:56:43 <sjanssen> newsham: you can use @undo to transform do notation to bind
19:56:52 <newsham> thanks.
19:57:37 <sjanssen> @redo \a -> a >>= (\x -> return (Just x)) -- and @redo to go back
19:57:37 <lambdabot> \ a -> do { b <- a; (\ x -> return (Just x)) b}
19:58:45 <sjanssen> @redo \a -> a >>= \x -> return (Just x) -- can't see through the parens
19:58:45 <lambdabot> \ a -> do { x <- a; return (Just x)}
19:59:12 <eviltwin_b> hm, "@." --- shoulda known
20:00:38 <sjanssen> eviltwin_b: of _course_ a Haskell bot would support composition ;)
20:04:06 <eviltwin_b> hence "shoulda known" :)
20:04:08 <sorear> dmead : member is uncurry elem
20:04:36 <scsibug> could someone take a look at the following code, and give me some pointers on haskell coding style?  I'm feeling something icky about this case statement.
20:04:41 <lisppaste2> scsibug pasted "guessing game" at http://paste.lisp.org/display/30919
20:05:34 <sorear> hmm: case (signum (g - answer)) of 1 -> ...
20:05:55 <Cale> let g = read gs
20:06:14 <Cale> case compare g answer of
20:06:17 <Cale>   LT ->
20:06:20 <Cale>   GT ->
20:06:23 <Cale>   EQ ->
20:06:26 <sorear> D'OH :(
20:06:39 <scsibug> ah, thanks...that is what I wanted :)
20:06:45 <sorear> Use IORef and modifyIORef, get rid of the lifting
20:07:05 <Cale> you could... This is actually sort of nice :)
20:07:34 <scsibug> I haven't looked at IORef, I'll have to dig into that
20:07:59 <Cale> of course, for this particular case, you could use explicit parameter passing
20:08:31 <scsibug> it's actually meant to demonstrate the use of StateT
20:08:35 <Cale> right
20:09:42 <scsibug> sigfpe's blog had a great tutorial on StateT, using completely meaningless examples (test1, test2, go1, go2...)
20:09:51 <scsibug> so I wanted something a bit easier to grasp
20:10:42 <Cale> A rather nice thing to demonstrate using State/T is relabelling every node of a leaf-labelled tree with numbers from 0 up to n, which is a pain to do directly compared with using State
20:11:04 <Cale> (that is, Tree a -> Tree Integer)
20:11:31 <dons> scsibug: here's a State monad for you http://www.cse.unsw.edu.au/~dons/tmp/Eval2.hs
20:11:33 <Cale> every leaf, I should say
20:12:23 <dons> scsibug: and some ReaderT/StateT: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:12:25 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
20:12:43 <scsibug> dons: thanks... I've been through the IRC bot tutorial, that was great
20:12:51 <Cale> dons: that would be better written using Reader
20:13:09 <Cale> (because you could get lexical scoping for free)
20:13:44 <dons> Cale: ah, the state interpreter?
20:13:50 <Cale> yeah
20:14:16 <dons> hadn't thought of that. using local?
20:14:24 <Cale> yeah
20:14:31 <dons> good idea.
20:14:38 <dons> i should polish it up into a tut
20:14:59 <dons> seems like its not widely known out side of haskell, just how easy it is to write interpreters...
20:15:10 <timthelion> hey, I know this may be a stupid question, but how do I get a haskel interpreter for gentoo, is there really not one in portage?
20:15:20 <dons> timthelion: ghc/ghci right?
20:15:24 <dons> just grab that
20:15:32 <timthelion> ok
20:15:46 <dons> timthelion: check http://haskell.org for more info, but hugs and ghc should both be in portage
20:15:47 <lambdabot> Title: Haskell - HaskellWiki
20:15:52 <Cale> lisppaste2: url
20:15:52 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:16:09 <lisppaste2> Cale pasted "readerised" at http://paste.lisp.org/display/30920
20:16:10 <timthelion> dons: thanks
20:16:24 <timthelion> dons: I was lokking for 'haskel"
20:16:39 <dons> nice Cale
20:16:44 <eviltwin_b> ...no, it's not Hebrew...
20:17:07 <dons> ?undo do v1 <- eval e1 ; v2 <- eval e2 ; return (v1 + v2)
20:17:08 <lambdabot> eval e1 >>= \ v1 -> eval e2 >>= \ v2 -> return (v1 + v2)
20:17:13 <dons> ?. pl undo do v1 <- eval e1 ; v2 <- eval e2 ; return (v1 + v2)
20:17:13 <lambdabot> (`fmap` eval e2) . (+) =<< eval e1
20:17:21 <dons> mm
20:17:54 <dons> i'd like something like: f eval e1 e2 `flip fmap` (+)
20:18:00 <dons> Cale: got me some syntax for that?
20:18:16 <dons> oh, we could multi thread the interpreter for mega fun
20:19:14 <Cale> eval (Plus e1 e2) = liftM2 (+) (eval e1) (eval e2)
20:19:48 <gogi> hello #haskell
20:20:00 <dons> ah of course. @pl should really spot that
20:20:04 <dons> hey gogi
20:20:16 <gogi> I'm coming from the world of perl
20:20:18 <gogi> it's shocking
20:20:18 <Cale> @pl \e1 e2 -> liftM2 (+) (eval e1) (eval e2)
20:20:19 <lambdabot> (. eval) . liftM2 (+) . eval
20:20:27 <Korollary> ?vixen What are the chances that Anaheim ties the game?
20:20:27 <lambdabot> yes
20:20:37 <sieni> lambdabot: <3
20:20:44 <dons> Cale: now, how about automatically forkIO the two branches to liftM2.
20:20:47 <Cale> Hello gogi, welcome to #Haskell :)
20:21:08 <Cale> dons: forkM2 ? :)
20:21:20 <gogi> I've been porting my perl code
20:21:26 <gogi> and it's been going good
20:21:32 <Cale> cool
20:21:38 <Korollary> what does it do?
20:21:44 <gogi> except when I try to transfer regexps like "(?:ff)(gg)"
20:22:04 <gogi> kor: parses, for now
20:22:16 <SamB_XP> dons, Cale: are you trying to implement that Parallel monad for me?
20:22:20 <dons> Cale: we should have monad ParIO
20:22:46 <Botty> gogi - have you seen parsec? it's pretty nice
20:22:51 <Cale> dons: there's a paper which describes a monad transformer for concurrency -- if only it interacted with the RTS.
20:22:56 <dons> yeah
20:23:06 <dons> so porting that to run on the actual rts ...
20:23:12 <dmead> rts?
20:23:13 <Cale> gogi: Could you remind me what ?: means?
20:23:14 <dmead> like starcraft?
20:23:16 <dmead> =p
20:23:18 <gogi> user error (Text.Regex.Posix.String died: (ReturnCode 13,"Invalid preceding regular expression"))
20:23:19 <Cale> dmead: runtime system
20:23:32 <dmead> =(
20:23:43 <gogi> Botty: parsec? will that involve a large rewrite?
20:23:43 <SamB_XP> x ? y : z is like if x then y else z
20:23:47 <eviltwin_b> they're posix regular expressions, not perl-compatible regular expressions
20:23:58 <SamB_XP> oh.
20:24:02 <gogi> eviltwin_b: emacs has them too!
20:24:04 * Cale is used to regular expressions only having concatenation, union, and kleene star.
20:24:13 <gogi> passive groups are really important
20:24:18 <Botty> gogi - well, if you want to.  It's basically a really nice parser lib for haskell.  Combinatorial parsing
20:24:32 <Korollary> Cale: let's get started on the misnomer that is RE in some libraries, eh?
20:24:36 <Cale> SamB_XP: I mean in that regular expression
20:24:52 <gogi> what if you have a lot of groups in your regexp, most of them without importance, how are you supposed to deal with the result?
20:24:52 <dons> there's a 3rd part Text.Regex.PCRE around..
20:25:00 <Cale> Korollary: yeah -- they really should not be called regular expressions if they define non-regular languages :)
20:25:08 <SamB_XP> gogi: they aren't emacs-compatible regular-expressions either
20:25:13 <timthelion> does ghc have a mode in which I can do command line(like typing python strait)
20:25:34 <lispy> timthelion: ghci?
20:25:35 <sorear> Haskell does not, in general, like to interpret strings
20:25:39 <dons> timthelion: $ ghc -e 'print "hello"'
20:25:39 <dons> "hello"
20:25:40 <Cale> timthelion: ghci allows you to evaluate expressions only
20:25:51 <sorear> instead your parses are data types
20:25:52 <dmead> it does?
20:25:53 <Botty> gogi- oh, i misinterpreted what you said.  I thought you meant your program only parses things at the moment ;P
20:26:00 <dmead> o0
20:26:07 <Cale> Okay, and execute IO actions which might result from those :)
20:26:11 <sorear> s/parses/parsers/
20:26:17 <dons> timthelion: like that?
20:26:27 <Korollary> Isnt there a ghci session guide wiki page?
20:26:32 <dons> yeah
20:26:42 <Cale> timthelion: in general though, the way to program is to put your program in a file and keep your editor open alongside ghci
20:26:44 <timthelion> dons: like that
20:26:47 <dons> $ echo 'print "hello"' | ghci
20:26:47 <dons> "hello"
20:27:05 <Cale> timthelion: when you save your file, just type :r in ghci and it'll reload
20:27:23 <Korollary> Hah. Colorado scores.
20:28:06 <timthelion> Cale: how do I save?
20:28:07 <dobblego> who cares about Korollado?
20:28:17 <Cale> timthelion: in your editor?
20:28:27 <Cale> timthelion: that depends on what editor you're using
20:28:30 <timthelion> Cale: ok
20:28:32 <timthelion> Cale: emacs
20:28:37 <Cale> C-x C-s
20:28:46 <timthelion> Cale: ;)
20:28:52 <Korollary> dobblego: I don't care about Colorado. I guess I don't like Calgary, though.
20:29:11 <Cale> there's nothing to save from ghci, because ghci is essentially stateless
20:29:22 <Cale> (it lets you make local bindings with let, but that's about it)
20:29:27 <dobblego> I've spent a total of one day in Colorado (Denver) - mised my flight home (LA -> Sydney)
20:29:47 <SamB_XP> M-x turn-on-haskell-ghci
20:29:55 <SamB_XP> C-c C-l
20:30:07 * shapr yodels
20:30:08 <SamB_XP> <fix errors>
20:30:12 <SamB_XP> C-c C-r
20:30:24 <SamB_XP> <rinse. repeat.>
20:30:46 <gogi> setup: cannot satisfy dependency fps>=0.7 <--when I try to install http://darcs.haskell.org/packages/regex-pcre/
20:30:48 <lambdabot> Title: Index of /packages/regex-pcre
20:30:59 <shapr> hej augustss, hur l√§get?
20:31:22 <mbishop> SamB_XP: nice
20:31:23 <augustss> bara bra, tack. sj√§lv d√•?
20:31:28 * mbishop learned something new
20:31:28 <eviltwin_b> gogi: on ghc 6.6 comment out that dependency, fps is in the base.  if 6.4, install fps
20:31:30 <TSC> SamB_XP: Is there any difference between using C-c C-r and C-c C-l for reloading the file?
20:31:33 <dons> gogi: install fps
20:31:35 <dons> ?where fps
20:31:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:31:45 <dons> gogi: which ghc are you using?
20:31:50 <shapr> augustss: bra bra
20:32:06 <gogi> eviltwin_b: how do I comment that out?
20:32:10 <SamB_XP> TSC: C-c C-r will try to load the same file again, C-c C-l will try to load the file you are editing
20:32:12 <dons> gogi: you using ghc 6.6?
20:32:16 <shapr> Funktionell programmering √§r s√• gott...
20:32:25 <SamB_XP> not much difference unless you are getting errors in other files
20:32:26 <dons> gogi: if so, remove the 'fps' from the depends: line in the .caba lfile
20:32:58 <eviltwin_b> ==dons, on 6.6 only edit the filenamed (something).cabal
20:33:02 <kpreid> Cale: but that's all the state you need!
20:33:32 <Cale> kpreid: it's more than you need, really :)
20:33:41 <SamB_XP> also, they go away when you type :r anyway
20:33:44 <kpreid> Cale: (to do something nontrivial and potentially-interesting-to-save in ghci)
20:34:10 <SamB_XP> kpreid: if you've done something like that, you can copy + paste into a "do"
20:34:51 <augustss> shapd: so do you have an FP job now?
20:35:08 <augustss> shapr, I mean :)
20:35:47 <shapr> augustss: Jo, jag √§r en √§kta funktionellfolk!
20:35:52 <gogi> http://paste.lisp.org/display/30921 <--now it's giving me these errors!
20:35:59 <kpreid> SamB_XP: sure. I'm just pointlessly disagreeing with "essentially stateless"
20:36:02 <shapr> I'm getting paid to work on HAppS. It's really fun.
20:36:06 <augustss> shapr: very nice!
20:36:15 <SamB_XP> kpreid: it isn't much state if it goes away when you type :r!
20:36:23 <shapr> I'm thrilled :-)
20:36:35 <kpreid> :def reload-preserving-state = ...
20:36:41 <shapr> I wish I understood more of the HAppS codebase though...
20:36:48 <dons> gogi: do you have the relevant pcre header files? does it describe these C deps in the README?
20:37:05 <Pseudonym> How does HAppS make money?
20:37:20 * kpreid `modifyIORef` sleep
20:38:37 <gogi> dons: doesn't seem to be a README
20:38:49 <shapr> Pseudonym: That's not its goal. The goal is to make a web framework that can be used to easily and reliably build webapps that do make money.
20:39:05 <dons> gogi, can you get by with posix regular expressions and list functions?
20:39:19 <shapr> alexj has a bunch of ideas about removing unnecessary complexity from webapps. He talked about it at AngloHaskell, and I was converted.
20:39:23 <dons> heavy use of regexes is not very common in haskell, due to the flexibility of the existing list libraryes (partially)
20:39:31 <ralf`> hi shapr.  hi dons
20:39:37 <dons> gogi: otherwise, double check that regex-pcre hasn't been updated to 6.6 yet
20:39:38 <shapr> hi ralf`
20:39:49 <dons> gogi: and that you have the right pcre header files
20:40:18 <dons> gogi: and if that fails, mail haskell-cafe@haskell.org, with the full error log, and what ghc version (and so on), and the author should be able to tell you what's going on
20:40:30 <dons> gogi: also, is there a ./configure script?
20:40:36 <robreim> out of curiousity, how does HAppS solve the problems continuation-based frameworks attempt to solve with continuations?
20:40:38 <dons> is it executable? did it run on the configure phase ?
20:40:54 <gogi> dons: what I'm missing is so called passive grouping, or non-binding grouping, where the substrings matched aren't stored
20:41:11 <gogi> ./setup build
20:41:19 <gogi> that's where it failed
20:41:41 <dons> gogi, did you run ./setup configure?
20:41:51 <dons> and is there a configure.ac or configure script?
20:42:03 <gogi> that was done
20:42:07 <dons> gogi: since its failing due to missing symbols imported from pcre.h (or someething)
20:42:40 <shapr> robreim: I don't know.. I'll get back to you on that :-)
20:43:09 <SamB_XP> shapr: I thought you said it didn't!
20:43:14 <gogi> http://paste.lisp.org/display/30922 <--result of configure
20:43:49 <dons> gogi: can you paste the contents of the .cabal file?
20:44:00 <dons> and check what headers the .hsc file that fails is importing?
20:44:56 <robreim> shapr: ok, cool :)
20:45:13 <gogi> http://paste.lisp.org/display/30923
20:45:19 <gogi> dons: how do I check that?
20:45:33 <dons> look in the file that's failing
20:45:36 <augustss> it's interesting how unpopular regexes are with haskell people
20:45:50 <SamB_XP> well, we'd prefer to write parsers
20:45:51 <augustss> i hardly ever use them myself in haskell
20:46:00 <augustss> yep, that's what i do
20:46:01 <SamB_XP> sometimes regexes are useful for writing parsers, though
20:46:05 <dons> gogi: so do you have the lib pcre installed?
20:46:06 <SamB_XP> (that is, in lexers)
20:46:16 <dons> gogi: and in what dir?
20:46:21 <dons> since it looks like hsc2hs can't find it
20:46:31 <gogi> dons: I put it in /src and then did "make"
20:46:43 <dons> gogi: pcre, the C library, you have it?
20:47:07 <gogi> http://darcs.haskell.org/packages/regex-pcre/Text/Regex/PCRE/ <--I have this
20:47:28 <eviltwin_b> you need to install the pcre package, that cabal file appears to expect it from darwinports
20:47:34 <lambdabot> Title: Index of /packages/regex-pcre/Text/Regex/PCRE, http://tinyurl.com/yxafom
20:47:43 <eviltwin_b> (the C library and header file, which the Haskell code is an interface for)
20:47:50 <gogi> ahh, got it
20:47:52 <gogi> installing now
20:48:27 <SamB_XP> I doubt the cabal file cares whether you get it with darwin ports, apt, or an MSI installer...
20:48:45 <eviltwin_b> well, it adds /opt/local/include to the compiler path, which suggests dports :)
20:48:47 <SamB_XP> just so long as it works...
20:49:40 <dons> gogi/palomer, so you going to play nice?
20:50:31 <gogi> :P
20:50:33 <gogi> caught!
20:50:35 <gogi> yeah, sure
20:50:52 <gogi> did you figure it out as soon as I came on?
20:51:12 <dons> just wanted to see what you're going to do... i.e. ask newbie questoins and be a pain
20:51:23 <dobblego> * gogi (n=palomer@toxic.magnesium.net) has joined #haskell
20:51:34 <newsham> can I have a "where" clause thats shared across several definitions?  like (f 0 = 1; f 1 = x; f 2 = x; where x = } ?
20:51:35 <dobblego> I just evaluated n :)
20:51:50 <gogi> yeah, I couldn't mask my host, would have felt too dishonest
20:51:57 <sorear> where only applies to definitions
20:52:23 <gogi> mind unbanning me? ircing through ssh is a pain
20:52:49 <augustss> oh, have you been banned?  interesting :)
20:52:54 <dons> do some more RTFMing first. after 4 years here you can sort out your own cabal problems
20:53:12 <gogi> eh? I never encountered cabal before
20:53:25 <dons> that's what I mean.
20:53:36 <augustss> it's about time then
20:53:38 <augustss> :)
20:54:21 <gogi> it would have taken me days to figure it out (heck, I probably would have given up and done it in ruby)
20:54:47 <lispy> cabal doesn't take days to figure out, esp. with the new tutorials on starting haskell programs
20:55:20 <lispy> newsham: not sure what you mean
20:55:26 <augustss> for me cabal always seems to just work.  maybe i'm lucky
20:55:32 <lispy> newsham: Oh, i think i see, well no
20:55:46 <newsham> so just use a case statement then i guess...
20:55:50 <lispy> newsham: but, you could use pattern guards to get a similar effect
20:56:00 <lispy> case could work too
20:56:30 <sorear> I figured out enough cabal in a couple hours yesterday...
20:56:45 <robreim> cabal's sexy
20:56:50 <sorear> (atleast if it did break nobody tried it/told me)
20:57:22 <robreim> wow, palomer's been here 4 years? I guess I can kinda understand the frustration now...
20:57:39 <dons> :/
20:58:02 <augustss> heh
20:58:04 <eviltwin_b> some people are clue-resistant
20:58:14 <augustss> palomer, the eternal newbie
20:58:38 <dons> yeah, he could have written cabal twice in since then
20:58:41 <dons> sigh
20:58:53 <jcreigh> people are weird
20:59:43 <robreim> That must put his age at at least 20... I'm a bit baffled by the @palomer quotes now.
21:00:08 <Botty> robreim - why 20?
21:00:35 <robreim> Well, unless he started haskell in his early / mid teens...
21:00:40 <pzpz> lol. every time i look over, you guys are bickering with palomer
21:00:42 <Botty> which I am
21:00:47 <Botty> ;)
21:01:05 <dobblego> @undo do x <- f1 y <- f2 f x y
21:01:06 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 14}) "Parse error"
21:01:13 <dobblego> @undo do x <- f1; y <- f2; f x y
21:01:14 <lambdabot> f1 >>= \ x -> f2 >>= \ y -> f x y
21:01:51 <dons> ?. pl undo do x <- f1; y <- f2; f x y
21:01:51 <lambdabot> (f2 >>=) . f =<< f1
21:01:53 <robreim> Well, ok, "must" was the wrong word I guess. I was playing the odds at figuring most people first encounter haskell later than mid-teens :)
21:01:54 <dons> heh
21:02:14 <dons> f2 >>= . f =<< f1 -- nice idiom ;)
21:02:15 <Botty> probably a reasonable assumption :)
21:02:58 <sorear> I started at 15
21:03:07 <robreim> dons: it looks pretty, but pretty obfuscated! :)
21:03:15 <dons> :)
21:03:40 <dobblego> ?type (>>=)
21:03:41 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
21:03:52 <Botty> yeah, it's got mirror-symmetry
21:03:56 <Botty> nearly
21:04:08 <dons> ?type \f -> (readFile "x" >>=) . f =<< readFile "y"
21:04:10 <lambdabot> forall b. (String -> String -> IO b) -> IO b
21:04:12 <sorear> And what is >>='s fixity?
21:04:33 <dons> ?type \f -> (readFile "x" >>=) . return . zip =<< readFile "y"
21:04:35 <lambdabot>   Couldn't match `IO b' against `[b1] -> [(a, b1)]'
21:04:35 <lambdabot>    Expected type: [a] -> String -> IO b
21:04:39 <robreim> Yeah, I guess with the internet, people are more likely to discover haskell earlier these days. Back when I was 15 there was no such thing as internet. Nor computers. And we had to shovel 50km of snow just to be able to drive to the nearest abacus.
21:04:49 <Botty> lol
21:04:51 <Korollary> >>= is infixl 1
21:04:51 <dons> ?type \f -> (readFile "x" >>=) . (return . zip) =<< readFile "y"
21:04:53 <lambdabot>   Couldn't match `IO b' against `[b1] -> [(a, b1)]'
21:04:53 <lambdabot>    Expected type: [a] -> String -> IO b
21:04:56 <dons> bah
21:05:11 <augustss> robreim: but did you have to eat poison?
21:05:11 <dobblego> ?type <<=
21:05:13 <lambdabot> parse error on input `<<='
21:05:17 <dobblego> ?type (<<=)
21:05:19 <lambdabot> Not in scope: `<<='
21:05:27 <dobblego> ?type (=<<)
21:05:29 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
21:05:53 <robreim> augustss: sure. No glass for dessert if you don't drink up all your poison.
21:06:35 <Botty> yeah, I've messed around with making my own pet programming languages for years, but finally decided to really design one, which solves all the things that annoys me in current ones.  I figured I'd have to stretch my programming language imagination a bit, so I learned haskell (which I like a lot now, though I'm still thinking about my lang...)
21:06:37 <jdev> When I was 15, I learned Pascal.  It was faster than HyperCard.  (-:
21:06:41 <dons> ?pl  \a b f -> (b >>=) . f =<< a
21:06:41 <lambdabot> flip (flip . ((=<<) .) . (.) . (>>=))
21:07:09 <lispy> Botty: there is no good programming language, it's just that haskell is the least annoying :)
21:07:11 <Botty> I probably would have checked it out 2 years ago if smerdy wasn't such an arse
21:07:21 <Botty> heh, yeah
21:07:23 <lispy> actually, a paraphrasing of someone elses much better quote
21:07:36 <robreim> Botty: yeah, I used to consider doing that when I was using common lisp. Then I discovered haskell, realised I know even less than I thought I did and decided to give up and leave language design to the professionals.
21:07:36 <Botty> It's certainly true.
21:07:37 <timthelion> hey, how do I go about learning haskel?
21:07:47 <augustss> Botty: you should make your own.  just to see how hard it is to deign a good one :)
21:07:56 <Botty> hehe probably
21:08:38 <sorear> I've described haskell as 'Lisp done right'
21:08:41 <Botty> timthelion - probably the best way is to read tutorials/a book for a few days and then try to do something with it
21:08:49 <Botty> sorear - I dunno about that....
21:08:59 <Botty> apples and oranges
21:09:14 <timthelion> Botty: is it worth the effort for a lispite?
21:09:25 <Botty> certainly
21:09:26 <robreim> sorear: my initial trepidation with haskell was "it doesn't have lisp macros. How can anyone do anything without lisp macros?". I haven't felt the urge to use lisp macros since.
21:09:43 <Korollary> robreim: You should talk to other lispers.
21:10:23 <robreim> Korollary: I try to avoid it. They tend to be jerks as a rule :)
21:10:24 <Botty> robreim - yeah, i've realized that type systems are very difficult
21:10:30 <Botty> (on the experts thing)
21:10:46 <Botty> especially when your type system is trying to do things never done before :)
21:11:47 <augustss> Botty: never done before?  and what would that be?
21:12:06 <Botty> well, it probably has been done, in research langs and such
21:12:28 <robreim> timthelion: which lisp is your background?
21:14:05 <dons> i do like this for some weird reason:
21:14:06 <dons> combine :: (Monad m) => m a -> (a -> b -> m c) -> m b -> m c
21:14:06 <dons> combine a f b = (b >>=) . f =<< a
21:14:47 <augustss> yes, it has a certain beauty.  but not perfect
21:14:57 <Botty> my idea is to have dependant types, and constraints on function parameters.  The resultant type for functions would be in terms of the input types.  This rather complicates the function's type, however most of the time the stuff could be inferred - constraints would be propogated.  Problems with this i'm trying to figure out is that once you have branching, stuff gets a bit wonky
21:15:35 <dons> ?pl \a b -> return (zip  a b)
21:15:35 <wchogg> Has anyone here ever hacked out a mud client before?  I thought it might be a fun little project, but I'm trying to find a launching point.
21:15:35 <lambdabot> (return .) . zip
21:15:46 <dons> ah  return `dot2` zip
21:15:57 <dons> wchogg: you could start with the irc bots, or ginsu?
21:16:16 <wolverian> dons, oh. now suddenly dots make sense. heh, thanks.
21:16:20 <Lemmih> Greetings, alexj___.
21:16:21 <robreim> timthelion: If your background is scheme, from haskell you'll learn the advantage of static-typing done right, the wonders of type-classes, lazy-evaluation and monads. The latter two you can get a small intro to from libraries, but not as nice as in haskell. If your background is common-lisp, you'll additionally learn how to program functionally properly (CL makes functional programming awkward and rare thanks to its dual namespace IMHO).
21:16:56 <Botty> what's cool about this system, is it can act like haskell's hindley miller stuff, or procedural static, or even dynamic
21:17:11 <augustss> Botty: typw inference with depedent types is tricky (impossible in general, of course).  but it would be interesting
21:17:18 <Botty> right
21:17:44 <Botty> the kernel version will have no inference
21:17:45 <dmead> there isn't a haskell implementation written on top of the jvm is there?
21:18:19 <timthelion> robreim: my background is elisp ;)
21:18:37 <timthelion> robreim: I am already lost :)
21:18:57 <sorear> I tried scheme.
21:19:04 <Botty> augustss - i've heard Hindley Miller stuff is difficult to implement well (good error messages).  This is like that x2, so I probably won't actually do it
21:19:35 <robreim> timthelion: haha. Way to ruin my assumptions :) IIRC, elisp has a single namespace (never used it much), so what I said for scheme probably applies equally to elisp.
21:19:41 <sorear> HM is easy to impl., if you can debug "This program is type incorect. Please try again."
21:19:43 <jcreigh> timthelion: if you're not lost in Haskell, you're not trying.
21:19:45 <augustss> Botty: yeah, good error messages are difficult when there are few type signatures
21:19:59 <Botty> ah.
21:20:15 <sorear> Fortunately, even GHC gives better messages than *that*.
21:20:43 <newsham> tonight's question:  http://www.thenewsh.com/~newsham/x/quest.txt
21:20:50 <augustss> Botty: so once you decide to have dependent types it easily leads to other decisions you have to make.  like what kind of type equality you want, structural or nominal
21:21:55 <Botty> well, hopefully most of the time you won't even mess with the fancy types.  Just when it helps.  Even then there will probably be sugar for it.  For example, when parameters don't match any versions, they are illegal parameters (except of course when these are generated by the function itself, then we have a problem - i'm not gonna deal with recursive constraints i don't think)
21:23:21 <Botty> hmm, is that like where a Matrix which is defined as a list of lists can be equal to a list of lists?
21:23:29 <augustss> Botty: why dependent types?  to be able to type more programs or to express specifications?
21:23:46 <jdev> ?ty \f a b c = f `flip` a `flip` b `flip` c
21:23:48 <lambdabot> parse error on input `='
21:23:53 <jdev> ?ty \f a b c -> f `flip` a `flip` b `flip` c
21:23:55 <lambdabot> forall b b1 a b2 c. (a -> b -> b1 -> b2 -> c) -> b -> b1 -> b2 -> a -> c
21:24:21 <Botty> augustss - prevent stuff like 'head []' compile time
21:24:22 <augustss> Botty: Haskell uses nominal type equality, except for the ones introduced by 'type'
21:24:30 <jdev> That's for newsham's question, or at least a quick glance through it that might have missed something.
21:24:56 <newsham> hmm.. so (flip f) `ap` ...
21:25:12 <dons> ok, an actual useful program written with `combine': http://www.cse.unsw.edu.au/~dons/tmp/CatN.hs :)
21:25:43 <Botty> I also think that a more expressive type system could lead to impressive optimizations
21:25:55 <augustss> Botty: yes, in principle
21:26:21 <augustss> but it's not been done yet :)
21:27:07 <Botty> yeah, everyone working with them seems to be obsessed with doing things with church numerals ;)
21:27:30 <augustss> I wasn't :)
21:27:48 <sjanssen> @type com f name = name >>= (\x s -> f)
21:27:50 <lambdabot> parse error on input `='
21:27:57 <dons> :)
21:28:29 <Botty> augustss - ooh, you've done stuff with em?
21:28:45 <timthelion> is it possible to be too sane for haskell? it is setting off my ambiguity alarms
21:28:45 <sjanssen> @type \f name -> name >>= (\x s -> f s x)
21:28:47 <lambdabot> forall a b t. (Monad ((->) t)) => (t -> a -> b) -> (t -> a) -> t -> b
21:28:55 <newsham> (liftM flip f) `ap` extr name   ?
21:29:12 <augustss> Sure, full blown dependent types in Cayenne, and a (much) milder version in Bluespec
21:29:38 <sjanssen> @type \f name -> name >>= (\x -> return (\s -> f s x))
21:29:39 <lambdabot> forall a (m :: * -> *) t t1. (Monad m) => (t1 -> a -> t) -> m a -> m (t1 -> t)
21:29:45 <Botty> wow, I think I saw the page on that
21:30:11 <Botty> well, my idea really isn't mature yet, had it about 4 days ago :)
21:30:25 <newsham> sjan: is that for me or someone else.. i'm having trouble following and thinkign at the same time
21:30:38 <Botty> (includes alot of stuff I haven't really talked about - i know dependant types aren't new)
21:31:03 <dons> sjanssen: if you have a better formulation, http://www.haskell.org/haskellwiki/Pointfree/Combine
21:31:06 <lambdabot> Title: Pointfree/Combine - HaskellWiki, http://tinyurl.com/yx255r
21:31:30 <Botty> perhaps the type system won't be too bad if i just start off with no inferencing
21:32:00 <sjanssen> newsham: yeah, I'm trying out your problem
21:32:11 <augustss> Botty: that's much easier
21:32:15 --- mode: ChanServ set +b *!*@*.magnesium.net
21:32:29 <sjanssen> @type \f name -> do f' <- f; name' <- name; return (\s -> f' s name') -- newsham, I think this is it
21:32:30 <lambdabot> forall (m :: * -> *) t t1 a. (Monad m) => m (t1 -> a -> t) -> m a -> m (t1 -> t)
21:32:40 <augustss> Botty: www.dependent-types.org
21:32:51 <sjanssen> @. pl undo \f name -> do f' <- f; name' <- name; return (\s -> f' s name')
21:32:52 <lambdabot> liftM2 flip
21:32:52 <Botty> actually, that's an issue i don't look forward to dealing with.  Lets say the language becomes popular, and multiple compilers are implemented, with different amounts of inference (or, different versions of my compiler).  Code won't work between them
21:33:16 <augustss> yep
21:33:51 <lispy> "implementation defined" is the ugliest phrase that can appear in a language spec. :)
21:34:00 <Botty> heh, yeah
21:34:03 <lispy> and take a look at the C spec some time
21:34:08 <eviltwin_b> not that that's a new problem, as anyone who's had to port between MSVC++ and C++ knows :>
21:34:14 <augustss> Botty: I had similar thoughts about Cayenne, since it has undecidable type checking.  So you have to give up at some point that is implementation dependent.
21:34:47 <augustss> Botty: but don't worry, it won't become popular ;)
21:34:54 <Botty> lol, I know
21:35:01 <dons> hehe
21:35:04 <augustss> the world isn't quite ready
21:35:20 <lispy> i have a theory that a PL takes 12-15 years to gain real popularity
21:35:28 <dmead> what about java?
21:35:34 <augustss> look at GADTs, took almost 15 years before they got "mainstream"
21:35:34 <lispy> same
21:35:35 <dons> works for ruby, python and haskell I guess
21:35:47 <dmead> i'd say it takes that long for a Pl to come into it's prime
21:36:10 <newsham> hmm.. it seems like it should be    f % name = liftM flip `ap` extr name
21:36:11 <dmead> whether or not it's actually popular, depends on the language
21:36:13 <dons> and erlang
21:36:22 <newsham> err.. liftM fliip f `ap` extr name
21:36:25 <Botty> well, it could, it'll have an onion of languages....  Scary Kernel -> Not so scary functional -> haskellish -> rubyish
21:36:27 <newsham> but thats not quite working for me
21:36:49 <sjanssen> newsham: I believe my solution is correct
21:37:13 <augustss> Botty: but you need a sound kernel
21:37:22 <Botty> yeah, that's what i'm worrying about now :)
21:37:50 <augustss> and once you go for dependent types, that can be hairy
21:38:14 <augustss> if types are going to be useful you'll have to be convinced the type system is sound
21:38:21 <Botty> and it probably wouldn't be an onion of langs, really more like a tree of languages that get more domain specific as they go
21:39:07 <Botty> well, seems to me dependant typing is a more sound system
21:39:29 <augustss> well, the soundness proof is more difficult
21:39:48 <Botty> ah, well, I've always disliked proofs ;)
21:40:07 <augustss> but without a proof, what will the types tell you?
21:40:31 <Botty> how to structure memory, what constraints are upon the types
21:40:36 <sorear> The program is the proof!
21:40:40 <Botty> s/types/values
21:40:45 <augustss> it doesn't have to be a formal proof, but you need to be convinced that when the types tell you something they are not lying
21:41:14 <Botty> hmm, not sure i can see a situation where they could.
21:41:19 <augustss> otherwise you'll have to have runtime checks.  or segfaults
21:41:25 <Botty> yeah
21:41:39 <Botty> basically, the kernel will need to be very well tested
21:41:51 <augustss> testing is not the way here
21:41:56 <sorear> And then you're back were we are now.
21:42:07 <jcreigh> hmm...I want to write a parser to parse simple expression (eg, "2 * (3 + 7)"), maybe with some variables. Should I just use parsec? if so, is there a canonical tutorial?
21:42:09 <sorear> Linux crashes occasionally.
21:42:10 <Botty> I suppose proving that the spec's requirements are achieveable might be a good thing ;p
21:42:38 <lispy> jcreigh: i think the parsec manual has that example
21:42:39 <Botty> jcreigh - I came up with a cool way to parse arithmetic the other day.
21:42:52 <jcreigh> Botty: oh?
21:43:27 <Botty> parsec is fine, comes with an infix parser for the very task, however: http://www.haskell.org/haskellwiki/Haskell_Quiz/Bytecode_Compiler/Solution_Michael_Sloan
21:43:30 <lambdabot> Title: Haskell Quiz/Bytecode Compiler/Solution Michael Sloan - HaskellWiki, http://tinyurl.com/tt9ra
21:46:25 <Botty> not as clean as i'd like it to be, but its ok.  My main gripe is that I had to include a "C" constructor in my token data type so that I could intermingle tokens and original text.
21:47:49 <emu> if i'm folding with a fairly large piece of data, could i possibly benefit space-wise if i use strict folding?
21:47:53 <emu> like foldl'
21:48:04 <dons> or foldr, yes.
21:48:06 <sjanssen> emu: definitely
21:48:17 <emu> cause i'm thrashing the GC badly atm
21:51:13 <dons> i.e. consider:
21:51:20 <dons> > foldl (+) 1 [1..10^6]
21:51:22 <lambdabot>  Exception: stack overflow
21:51:24 <dons> > foldl' (+) 1 [1..10^6]
21:51:27 <lambdabot>  500000500001
21:51:31 <dobblego> ?hoogle (Set -> Bool) -> Set -> a
21:51:33 <lambdabot> No matches, try a more general search
21:51:53 <sorear> ?hoogle (a->Bool)->Set a->a
21:51:54 <lambdabot> No matches, try a more general search
21:51:59 <sorear> ?hoogle (a->Bool)->Set a->Set a
21:52:01 <lambdabot> Data.Set.filter :: Ord a => (a -> Bool) -> Set a -> Set a
21:52:02 <emu> > foldr (+) 1 [1..10^6]
21:52:03 <dons> sorear: spaces
21:52:04 <lambdabot>  Exception: stack overflow
21:52:06 <dons> oh, maybe not
21:52:07 <emu> > foldr' (+) 1 [1..10^6]
21:52:08 <Botty> augustss - I don't like class declerations (and instances), so my plot is that you may have additional overloads of a function, as long as the types don't overlap previous declerations (when they do overlap, it has to be a continuous series of pattern match/guard versions)
21:52:08 <lambdabot>  Not in scope: `foldr''
21:52:12 <dobblego> ah thanks
21:53:06 <sorear> let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 1000000
21:53:22 <Botty> though technically that's sugar for one function and a case of... so basically I want to allow multiple meanings for a function, based on the type, and spread throughout modules (and can be imported together and not fight)
21:54:01 <sorear> That is feasible in haskell, but we don't like it
21:54:13 <sorear> It breaks parametricity
21:54:15 <timthelion> hey, what is the target use of haskell, what do people use it for?
21:54:22 <emu> cool shit
21:54:26 <sorear> Teasing lispers.
21:54:51 <emu> being lazy
21:54:52 <timthelion> it hurts to look at,
21:55:06 <timthelion> I don't understand it and it is scary
21:55:06 <Botty> heh, says a lisper, lol
21:55:37 <Botty> yeah, at first it is insane
21:55:48 <dons> timthelion: visit haskell.org and look at the tuts and applications page
21:55:51 <Botty> but in a few days it'll be near natural
21:55:53 <timthelion> is it one of those languages (like perl) where half the art is in the obfiscation?
21:56:08 <dons> timthelion: i guess you know pugs/perl6 is written in haskell?
21:56:18 <timthelion> I do
21:56:21 <sorear> timthelion: Not yet.
21:56:21 <dons> timthelion: no not really. we just play that game in here, since the bot supports it :)
21:56:23 <jcreigh> timthelion: don't sweat it. The only way to get smarter is by thinking hard.
21:56:28 <dons> ?pl \f g x y -> f (g x) y
21:56:29 <lambdabot> (.)
21:56:32 <emu> lol
21:56:33 <sjanssen> timthelion: quite the contrary, I'd say.  Haskellers tend to be quite picky about writing elegant code
21:56:40 <emu> not quite the intention
21:56:46 <sorear> Although memorizing math books doesn't hurt :)
21:56:49 <dons> emu: heh
21:56:58 <dons> ?pl \f g x y -> f (g x) (f g y)
21:56:59 <lambdabot> ap =<< ((flip . ((.) .)) .) . (.)
21:57:02 <dons> that'll do :)
21:57:10 <Botty> sorear - bah, memorizing is overrated
21:57:21 <sjanssen> dons: nice
21:57:26 <Botty> and does hurt, wastes time you could be *-really* thinking
21:57:35 <timthelion> sorear: I can't ever memorise my multiplication tables -''-
21:57:38 <sjanssen> practically hynotizing
21:57:47 <dons> we need a @pl that _only_ uses (.) and flip
21:58:00 <emu> unhaskell?
21:58:03 <jcreigh> dons: is that possible?
21:58:04 <dons> yeah
21:58:07 <dons> not sure...
21:58:20 <sorear> you can do it with const and ap
21:58:22 <dons> I guess for a decent core, yeah
21:58:40 <sorear> ap :: (a -> (b -> c)) -> (a -> b) -> (a -> c)
21:58:46 <sorear> that is, K and S
21:58:49 <dons> and if we rename fmap as (.), like Cale wants
21:58:54 <Botty> yeah, I don't know multiplication or addition very well. most of the time i get to stuff through tricks.  Like 6*7 = 3*7*2 = 21*2 = 42
21:59:00 <dobblego> ?hoogle Set -> Bool
21:59:01 <lambdabot> No matches, try a more general search
21:59:06 <dobblego> ?hoogle Set a -> Bool
21:59:07 <lambdabot> Data.Set.isEmptySet :: Set a -> Bool
21:59:07 <lambdabot> Data.Set.null :: Set a -> Bool
21:59:07 <lambdabot> Data.Set.valid :: Ord a => Set a -> Bool
21:59:23 <jcreigh> Botty: it's the answer!
21:59:29 <Cale> dons: :)
21:59:42 <dmead> hey guys
21:59:44 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/provergui.png
21:59:46 <lambdabot> http://tinyurl.com/u639o
21:59:49 <dmead> dig my haskell + java sexyness
22:00:02 <Botty> jcreigh - yeah, cool innit?
22:00:12 <dons> dmead: nice!
22:00:15 <eviltwin_b> sounds more like evilness
22:00:21 <dmead> haha
22:00:25 <eviltwin_b> haskell *plus* java? :>
22:00:27 <dmead> thanks dons
22:00:47 <dmead> Botty: are you intolerant of interlanguage development?
22:00:48 <dmead> =p
22:01:13 <Botty> uhhh, no?
22:01:36 <Botty> interlanguage marraige, now that's just not cool
22:02:21 <sjanssen> dmead: how does the interaction work?  Java executes the Haskell program via the shell?
22:02:48 <merus> Haskell + Java?  I feel sick.
22:03:28 <dmead> yea
22:03:43 <dmead> the jvm provides an api for working with memory pipes
22:03:57 <sjanssen> probably wouldn't be too hard to write the GUI in Haskell too
22:04:01 <dmead> yea
22:04:06 <timthelion> hey I don't get Branch                  :: Tree a -> Tree a -> Tree a so the function takes Tree a and ...
22:04:15 <dmead> i'll give that a shot later, but Gtk isn't as nice as swing or swt
22:04:30 <timthelion> dmead: swing is evil
22:04:35 <emu> is there a strict fold on maps? =)
22:04:54 <dmead> nah
22:04:55 <dmead> it's easy
22:05:06 <sjanssen> timthelion: it takes two Tree a and produces a new Tree a
22:05:09 <timthelion> dmead: no, it doesn't run correctly on anything
22:05:18 <timthelion> sjanssen: ok, thankyou
22:05:19 <dmead> o0
22:05:23 <sorear> dmead: member == uncurry elem, removeitem == uncurry delete
22:05:34 <eviltwin_b> "write once, debug everywhere"
22:05:49 <timthelion> dmead: it does not work on the tiled wms
22:06:21 <timthelion> dmead: nor does it render correctly on windows in many cases
22:06:22 <dmead> sorear: yea yea, i'll change it later =p
22:06:33 <dmead> i've never seen swing screw up
22:06:38 <dmead> when it wasn't my fault
22:06:56 <timthelion> dmead: then all the swing apps I have used, have been screwd
22:07:10 <sjanssen> emu: strictmap f xs = foldr seq () xs' `seq` xs' where xs' = map f xs -- like this? ;)
22:07:38 <emu> er, on Data.Map=)
22:07:57 <dmead> sjanssen: here
22:07:58 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/provergui1.png
22:08:00 <lambdabot> http://tinyurl.com/yeya68
22:08:04 <dmead> you can see the rest of the line there
22:08:10 <dmead> proverApp is my ghc compiled prover
22:08:16 <dmead> and it's sitting in /bin
22:08:28 <sjanssen> @type \f l -> foldr (\x xs -> (:xs) $! f x) [] l
22:08:29 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
22:08:39 <dmead> timthelion: maybe it's a vid card issue
22:09:02 <emu> ok to make sure i'm understanding foldl' semantics, it just forces evaluation of each step, not of any subexpressions necessarily?
22:10:02 <sjanssen> emu: it uses seq after each step
22:10:21 <timthelion> dmead: that's why everything else works:)
22:10:29 <dmead> =p
22:10:44 <dons> foldl' f a []     = a
22:10:44 <dons> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:11:08 <timthelion> dmead: I spent far too much time using netbeans and failing to deploy to ever be able to forgive sun...
22:11:16 <Botty> would paremetricity be helped along if you could write type constraints and rules for all instances?
22:11:21 <dons> maybe that should be f a x in a' `pseq` ...
22:11:34 <dmead> never used netbeans
22:11:38 <dmead> just eclipse
22:11:54 <jcreigh> kinda funny: in #ruby-lang: 22:46  * palomer is switching from haskell
22:12:04 <timthelion> so are any haskelers emacsers?
22:12:10 <dmead> most are tim
22:12:21 <sjanssen> dons: do you understand the difference between pseq and seq?  I sure don't ;)
22:12:21 <dmead> palomer is a traiter
22:12:42 <timthelion> dmead: he had a problem in regex that he was unable to solve.
22:12:56 <timthelion> dmead: came to #emacs to tell us about it :)
22:12:59 <dmead> who needs regex when you've got parsec?
22:13:16 <timthelion> dmead: if most are emacsers than why don't they write in elisp?
22:13:18 <dons> sjanssen: maybe `par` is nicer :)
22:13:18 <sjanssen> palomer confuses me.  I remember him asking questions about complicated monad transformers stacks months ago.  Then, just last week, he was asking about the `take' function.
22:13:18 <dons> par :: a -> b -> b
22:13:18 <dons> par  x y = case (par# x) of { _ -> lazy y }
22:13:43 <timthelion> sjanssen: maybe he is self taught?
22:13:51 <dons> and today pretending to be a perl->haskel newbie
22:14:06 <dons> and supposedly doing a masters or something related to type checking
22:14:08 <dobblego> I have seen people like that on IRC before
22:14:16 <brad__> please be nice to us perl->haskell newbies
22:14:22 <brad__> as this one has a question
22:14:24 <dons> oh, we like them!
22:14:27 * greentea seconds brad__'s request. :-)
22:14:33 <sjanssen> timthelion: I'm sure, no tutorial jumps around like that ;)
22:14:35 <emu> we like to have them, for dinner!
22:14:42 <dons> no no :) yay for pugs!
22:14:50 <dons> sjanssen: heh
22:15:00 <eviltwin_b> real ones are fine.  palomer is a troll, not a newbie
22:15:01 <brad__> okay, lets say i have a function f :: Int -> IO String
22:15:07 <dons> yep
22:15:09 <timthelion> sjanssen: maybe he learned by playing with ghci
22:15:13 <brad__> and f 0 = return("boo")
22:15:25 <dons> f 0 = return "boo" -- better
22:15:31 <brad__> now i want f n to recurse with (n-1)
22:15:39 <brad__> but if i type
22:15:40 <dons> ok
22:15:52 <brad__> f n = return (f (n-1))
22:15:55 <dons> f n = do x <- f (n-1) ; return x ?
22:15:55 <brad__> now i am in trouble
22:15:56 <sjanssen> brad__: I'm pretty sure you don't want return there
22:16:03 <dmead> return is not return as you know it brad
22:16:06 <dmead> return is a monad
22:16:07 <dons> are you really doing IO though?
22:16:12 <timthelion> hmm, I don't understand ghci I did hi :: Char -> Char and it said not in scope 'hi'
22:16:16 <jdev> return doesn't mean what it does in "normal" languages.
22:16:22 <dons> > let f 0 = "boo" f n = f (n-1) in f 100
22:16:22 <lambdabot>  Parse error
22:16:22 <brad__> well i am trying to add redirect support to Network.HTTP
22:16:29 <dobblego> return is the unit operation of a monad afaik
22:16:38 <sjanssen> timthelion: ghci is expressions only, you can't type in declarations
22:16:40 * greentea wonders how many people get caught by "return" not doing what it does in most other PLs.
22:16:50 <dons> brad__: anyway, remember the do notation
22:16:52 <mbishop> timthelion: gotta use let at the "top level"
22:16:52 * eviltwin_b didn't
22:16:54 <timthelion> sjanssen: then it is useless :(
22:16:57 <dmead> maybe return needs a different name
22:17:00 <dmead> it's confusing
22:17:02 <eviltwin_b> but then I knew what I was getting into :>
22:17:08 <dons> f 0 = someIO ; f n = do v <- f (n-1) ; ... ; return v
22:17:13 <sjanssen> so ghci would interpret that as "hi has ... type", but hi isn't in scope
22:17:36 <greentea> dmead: returnM?
22:17:39 <dons> greentea: yeah. I think it happens. but then this is haskell, so they should expect surprises ;)
22:17:40 <sjanssen> timthelion: ghci is useful.  You don't actually want to type whole programs into an interpreter, do you?
22:17:45 <eviltwin_b> reboxM?
22:17:49 <Botty> yeah, I find interactive interpreters more frustrating than useful
22:17:50 <dmead> greentea: yea, that would be good
22:17:51 <greentea> dons: Heh. :-)
22:17:51 <dons> brad__: ok, sorted?
22:18:11 <mbishop> Botty: I don't find it true for lisp, but all other languages, usually are
22:18:18 <brad__> i think i am sorted
22:18:21 <dons> brad__: you're basically asking about how to do recursion in monadic functions?
22:18:28 <brad__> yes dons. exactly
22:18:33 <emu> i'm pretty happy with ghci
22:18:38 <dmead> ghci is slow =/
22:18:39 <arcatan> I quite like to try my functions in hugs/ghci before using them anywhere
22:18:41 <eviltwin_b> haskell yiknah milomed umeoseh :>
22:18:43 <emu> but i'm used to interacting with lisp, so it's in my blood
22:18:45 <timthelion>  let{hi :: Char -> Char ; hi 'c' = 'o' ; print hi 'c'} gives me a parse error :(
22:18:51 <emu> oh other than the crashes
22:18:54 <brad__> yes, recursion in monadic functions - is it allowed?
22:18:56 <emu> and yea, it's a bit sluggish
22:19:11 <eviltwin_b> it's allowed but you need to do some special things
22:19:12 <Botty> in ghci I'd just like to be able to type funcs and data types and have them become defined in the env
22:19:26 <dons> ?paste
22:19:27 <lambdabot> http://paste.lisp.org/new/haskell
22:19:28 <dobblego> I find in implementing an algorithm that I have passed two Maps and so I am just backtracking; what is a more typical way?
22:19:40 <eviltwin_b> basically any time you inv0oke a monadic function inside a monad you need to use <- to grab its value
22:19:42 <dons> brad__: of course. here's a demo:
22:19:43 <timthelion> why doesn't what I gave it work?
22:19:48 <sjanssen> timhelion: because you have the syntax wrong.  You want let ... in print hi 'c' (which is still wrong, because print takes on argument)
22:19:53 <emu> ya ghci is a bit weird.  it's in a different context than a file toplevel.
22:19:56 <sjanssen> s/on/one
22:20:01 <brad__> yes eviltwin, starting to see that
22:20:15 <dobblego> two Maps that are Map a [a]
22:20:15 <Botty> emu - which is dumb and counterintuitive
22:20:22 <timthelion> sjanssen: can you re-write my code in such a way that it works?
22:20:25 <emu> also he wants: print (hi 'c')
22:20:28 <lisppaste2> dons pasted "recursion in a monad" at http://paste.lisp.org/display/30926
22:20:39 <dons> brad__: ^^
22:20:41 <mbishop> I'm sure it wouldn't be hard to make ghci be a "real" top level, right?
22:20:44 <eviltwin_b> it makes more sense once you start playing with what haskell turns the <- stuff into
22:20:57 <emu> Botty: well Haskell differentiates between expressions and declarations
22:20:59 <eviltwin_b> and understand what it's actually doing
22:21:05 <emu> Botty: this is fundamentally different from Lisp
22:21:08 <Botty> true
22:21:08 <sjanssen> let hi :: Char -> Char ; hi 'c' = 'o' in print (hi 'c') -- there you go timthelion
22:21:19 <brad__> thanks dons!
22:21:23 <brad__> i will look that over
22:21:28 <dons> ?undo do v  <- getLine ; vs <- f (n-1) ; return (v:vs)
22:21:28 <lambdabot> getLine >>= \ v -> f (n - 1) >>= \ vs -> return (v : vs)
22:21:33 <dons> ?pl getLine >>= \ v -> f (n - 1) >>= \ vs -> return (v : vs)
22:21:33 <lambdabot> (`fmap` f (n - 1)) . (:) =<< getLine
22:21:36 <dons> heh
22:21:37 <timthelion> sjanssen: oo, thanks
22:21:43 <dmn> hi
22:21:58 <eviltwin_b> brad__: a monad is a box.  inside a monadic declaration (do ...) you need to use <- to unbox a monad, and "return" re-boxes a valu to pass it back to the world outside the monad
22:22:02 <Botty> thing is, expression syntax parsed by the decleration thingamabob will fail.  declerations parsed by the expressions thingamabob will fail. you should be able to have both, in other words
22:22:14 <sjanssen> timthelion: you can skip the print statement here as well.  ghci automatically prints the result of a computation, if possible
22:22:18 <brad__> thanks dons and eviltwin, as always this channel is very helpful
22:22:44 <eviltwin_b> s/unbox a monad/unbox a value hidden inside a monad/
22:22:49 <newsham> sweet.. I have session management in happs...
22:22:54 <dons> newsham: great
22:22:59 <dons> newsham: going to write a happs tut?
22:23:01 <timthelion> sjanssen: removing in and tail fails
22:23:02 <dons> i'd love to see an intro
22:23:12 <newsham> there's an intro up on the site.. it needs updating though.
22:23:22 <newsham> i'll probably feed shapr with some examples so he can update
22:23:27 <arcatan> what's $!?
22:23:32 <timthelion> sjanssen: ah
22:23:35 <timthelion> sjanssen: got it
22:23:36 <Korollary> @index ($!)
22:23:37 <dons> greentea: so you learning haskell at uni, or freelance?
22:23:38 <lambdabot> Prelude
22:23:39 <sjanssen> timthelion: the `in' is crucial, it makes the let form an expression
22:23:44 <greentea> dons: Freelance.
22:23:47 <dons> cool!
22:23:49 <newsham> dons: http://happs.org/HAppS/doc/tutorial.html
22:23:51 <lambdabot> Title: HAppS Tutorial
22:24:22 <dons> arcatan: its a $ that behaves like seq
22:24:50 <dons> newsham: yeah, but a stronger motiavting tut with screenshots... :)
22:24:51 <brad__> by the way, dons, i had an approach like you coded (BIG THANKS!) myself, but i was concerned that "under the hood", spawning a copy of the function was somehow less efficient than pure recursion - i presume this was an incorrect assumption?
22:25:00 <dons> "How to set up a .... in HAppS" for example
22:25:10 <greentea> dons: i actually have health issues which mean it's difficult for me to go out to work, so i keep myself occupied through things like learning Haskell. :-)
22:25:22 <newsham> i'm building a framework for my own app..  i'm hoping its useful enough to be reusable for other peoples' apps.
22:25:26 <dons> brad__: spawning a copy? i.e. fork? or you just mean a function call?
22:25:29 <newsham> also its all free-time code, so I can freely share
22:25:48 <brad__> just a function call
22:25:52 <dons> greentea: ok. well I think you can safely set aside at least 4 years to explore haskell :)
22:25:57 <greentea> *laugh*
22:25:59 <dons> i have
22:26:09 <dons> brad__: function calls are cheap, so that's fine
22:26:35 <greentea> Yes, i've been doing programming for many years now, but i've learnt more about CS in a couple of months' study of Haskell than in all those previous years. :-)
22:26:35 <brad__> cool, thanks for helping me dons and preparing that example, i will look it over and learn it
22:26:53 <dmead> brad__: i think your talking about tail recursion?
22:26:54 <Botty> yeah, can't be afraid of them - it is functional programming after all ;)
22:27:19 <brad__> yes dmead i guess you are right - this is tail recursion, isn't it?
22:27:38 <dmead> is what
22:27:43 <dmead> tail recursive
22:27:44 <dmead> ?
22:27:55 <dmead> (link me)
22:28:06 <dons> yeah, what's that article "Everything your CS Professor failed to tell you about CS", including recursion, higher order functions, side effects, monads, ...
22:28:17 <brad__> sorry dmead, i was referring to a hypothetical problem, which dons illustrated here: http://paste.lisp.org/display/30926
22:28:18 <dons> *types*
22:30:10 <lisppaste2> dons annotated #30926 with "Or make it tail recursive" at http://paste.lisp.org/display/30926#1
22:30:17 <dons> brad__: you can also ponder ^^
22:30:43 <dmead> ahh
22:30:52 <dons> which makes the transation to a tight loop more obvious, perhaps
22:31:12 <mbishop> dunno if any of you have seen this, but I found this site a while back, pretty neat, http://plnews.org/
22:31:30 <mbishop> always have the latest haskell newletter, as well as any other news about any language you could want :P
22:32:03 <Botty> ooh cool
22:32:31 <brad__> thanks dons for the notes
22:32:43 <Botty> some of the langs sound pretty horrific though "2e is an experimental language built around a C-style conditional operator ("? :") and an iterative conditional operator"
22:32:53 <mbishop> heh
22:33:04 <mbishop> one of those "because you can" languages I suppose
22:33:21 <Botty> i guess.  "because it happens to be turing complete"
22:33:30 <Botty> ;p
22:35:00 <brad__> thanks everyone and take care
22:37:02 <lisppaste2> dons annotated #30926 with "more than one way ..." at http://paste.lisp.org/display/30926#2
22:42:23 <dons> just to summarise that little query for all time, http://haskell.org/haskellwiki/Recursion_in_a_monad
22:42:25 <lambdabot> Title: Recursion in a monad - HaskellWiki, http://tinyurl.com/suk6k
22:48:32 <emu> is there a good tool to try and pick out where some strictness might help space usage
22:48:44 <emu> besides the profiler?
22:49:29 <lispy> emu: what do you mean exactyl
22:49:38 <lispy> emu: you want to look at the code and predict?
22:49:44 <emu> actually, according to the profiler, the Parsec lexer is causing 1GB of allocation
22:49:51 <lispy> hmm..
22:50:00 <lispy> do you use a lot of backtracking?
22:50:21 <emu> yes. but this is strange, because it was running just fine before w/the same parser
22:50:36 <lispy> emu: there is a -ddump<something> that will give you the results of strictness analysis, would that help?
22:50:39 <dmn> hm
22:50:47 <dons> yeah some -dump thingies might help
22:50:51 <dons> and -ddump-simpl
22:51:02 <dons> but the profiler is the best option, of course
22:51:10 <dons> (followed by haskell-cafe@haskell.org)
22:51:13 <emu> i added some intermediate stages after parsing and now it's thrashing. and this is after i bumped -H to 128m
22:51:16 <lispy> emu: nothing changed? not even your test cause?
22:51:18 <lispy> case*
22:51:38 <lispy> emu: OS? ghc version?
22:51:38 <dmn> does this grammar make sense ? http://terror.org.pl/~d/src/g.txt . and how can i make implication right-associative, because the way it is described now, it's left-assoc..
22:51:39 <dons> any chance you could use the bytestring parsec?
22:51:47 <emu> is there one? i'd love to
22:51:56 <ptolomy> there's a bytestring parsec?
22:51:58 <lispy> the bytestring parsec isn't always good
22:52:06 <dons> yeah, depends on the use case
22:52:08 <lispy> it's good when you need a lot of backtracking
22:52:11 <emu> i tried to um, bytestring my parsec manually, not to good efefct
22:52:20 <ptolomy> that combines two of my favorite libraries.
22:52:28 <lispy> it handles things internaly different than parsec so that you don't need try
22:52:28 <emu> lispy: ah linux / 6.6.  yes, same test case...
22:52:29 <ptolomy> it's like ice cream-cake.
22:52:35 <dons> ?where bytestringparser
22:52:35 <lambdabot> http://hackage.haskell.org/~paolo/darcs/ByteStringParser
22:52:51 <dons> but probably there's a simple space leak in there somewhere, emu
22:53:14 <emu> lispy: basically it's parsing the data into an AST and then munging it back and forth between two representations while changing things
22:53:17 <dons> any chance your grammar could be dumped into happy instead?
22:53:20 <dmn> anyone ? it's just 7 lines of text to comment on ;]
22:53:49 <dons> dmn, looks ok.
22:53:57 <dons> why don't you code it up and see?
22:54:02 <emu> i *think* that the problem must be some space leak in there, because i've been using and tweaking this parser on this file for a while and it ran fast typically
22:54:10 <dons> yeah
22:54:24 <dmn> dons i know => should be right-assoc and don't know how to make it..
22:54:59 <lispy> emu: hmm...and according to the profile it's in your parsec lexer you said?
22:55:29 <emu> well, 50% of allocation is.
22:55:34 <lispy> interesting
22:55:41 <lispy> which combinators do you use in the lexer?
22:55:41 <emu> but still, it was doing ok before. this could be very fast alloc in the first generation
22:55:59 <lispy> iirc, spaces causes a lot of allocation but it gets GC'd right away too
22:56:04 <emu> why would tacking on further stages cause the parser to have fits?
22:56:15 <lispy> i don't know actually
22:56:26 <ptolomy> Is beshackled a word?
22:56:43 <emu> whitespace, parens, identifier, reserved, natural, integer, float, stringLiteral
22:56:48 <lispy> emu: to be honest, i'm skeptical that it's really in your parser, but if the profile says that, it's hard to argue
22:57:59 <lispy> emu: can you do an experiment where you make your datastructures strict?
22:58:18 <emu> i'm skeptical because when i remove all but 1 stage, the problem goes away
22:58:37 <emu> yea though, i'm not familiar with doing this
22:58:50 <lispy> emu: you just add bangs to the fields
22:58:54 <emu> and there's another issue: one of the major data structures is very very circularly linked
22:58:58 <lispy> data Foo a = Foo !a
22:59:06 <emu> now i suppose i could make the AST types all strict
22:59:12 <dons> yeah
22:59:24 <emu> but the other stages are heavily dependent on recursive lazy definitions
23:01:24 <calvins> can anybody tell me why hugs and ghci don't behave the same with default settings? http://haskell.org/haskellwiki/Simple_unix_tools loads fine in ghci, but hugs complains "Unresolved top-level overloading". I know how to fix this kind of thing via type declarations, but i'm curious why ghci doesn't have a problem but hugs does.
23:01:26 <lambdabot> Title: Simple unix tools - HaskellWiki, http://tinyurl.com/hekpb
23:01:56 <calvins> thanks lambdabot ;)
23:02:18 <dons> calvins: ah interesting. let me see..
23:02:29 <emu> what would i be looking for in -ddump-simpl
23:02:55 <calvins> hugs says:
23:02:56 <calvins> ERROR "UnixTools.hs":17 - Unresolved top-level overloading
23:02:56 <calvins> *** Binding             : showln
23:02:56 <calvins> *** Outstanding context : Show b
23:03:43 <dons> calvins: could be a bug in hugs, add this line:
23:03:44 <dons> showln :: Int -> [Char]
23:03:44 <dons> showln  = (++ "\n") . show
23:04:14 <calvins> yeah, that does it
23:04:17 <dons> I'll query hugs-bugs@ about it
23:04:40 <emu> snug as a hugs bug in a rug?
23:05:01 <calvins> i've noticed a few other times too when hugs was a little pickier than ghci. I thought maybe they implemented slightly different versions by default or something....
23:05:31 <dons> it seems that some constraints that ghci works out aren't found in hugs
23:05:37 <dons> (i.e. that we're showing an Int)
23:06:13 <calvins> yeah, i figured it was something like that.
23:06:34 <calvins> by the way, dons, thanks for your articles! they are very interesting for haskell newbs like me...
23:06:48 <dons> calvins: great :)
23:07:00 <dons> i'm reporting this as a hugs bug
23:07:11 <dons> since this doesn't work:
23:07:12 <dons> showln  = (++ "\n") . show
23:07:12 <dons> main    = interact (showln . length)
23:11:36 <newsham> ?seen shapr
23:11:36 <lambdabot> shapr is in #haskell-blah, #scannedinavian, #haskell and #ScannedInAvian. I last heard shapr speak 2h 25m 8s ago.
23:11:46 <newsham> know shapr's email addr?
23:13:08 <dmead> dons: whats the . do?
23:13:28 <emu> compose
23:13:29 <newsham> (f . g) x = f (g x)
23:13:33 <dmead> ah
23:13:53 <newsham> so  \x -> showln (length x)
23:19:43 <dons> calvins: bug reported, http://hackage.haskell.org/trac/hugs/ticket/50
23:19:46 <lambdabot> Title: #50 (Disparity between GHCi and Hugs: Outstanding context : Show b) - Hugs - Tra ..., http://tinyurl.com/yf4gco
23:19:55 <dons> calvins++ thanks for spotting this
23:20:35 <calvins> dons: great, thanks for filing the bug. i'll watch it for curiousity to see which is correct...
23:20:37 <emu> this nick++ stuff is shiesty.  it's causing side-effects in the bot's state.  where is the monad?
23:21:01 <dons> yeah, the LB monad. so its actually pure (the Karma state is just a State)
23:21:18 <dons> type KarmaState = M.Map String Integer
23:21:18 <dons> type Karma m a = ModuleT KarmaState m a
23:21:18 <dons> instance Module KarmaModule KarmaState where
23:21:49 <emu> ModuleT?
23:21:59 <dons> yeah, first class modules with private state in lambdabot
23:22:08 <emu> first class modules, yow
23:22:10 <dons> that can be lifted over IO and IRC
23:22:30 <dons> well, modules-as-values+dictionaries
23:24:00 <emu> heh. i have to give it 512m to run nicely on a 64-bit machine vs 256m on a 32-bit.  word size !
23:24:15 <dons> space leak man :)
23:24:19 <emu> yea i know
23:24:30 <emu> i've foldl'd all over the place!
23:24:35 <dons> ah...
23:25:19 <emu> ok, so there's this one fold where it updates the current state of the program (big) and turned it into a foldl'.  if I remove the fold entirely, it runs great (start state is output, still pretty big)
23:25:46 <emu> even strict, where it should be taking the entire state, transforming it, and then never accessing the old state again, hmm
23:25:55 <emu> it still thrashes
23:27:20 <dons> seq the state?
23:27:36 <emu> well shouldn't foldl' be doing that?
23:30:24 <emu> well i guess i'll poke at it with tools like Hat tomorrow
23:31:25 <dons> hey, cool, jmuk's blogging about parsers on sequence, http://sequence.complete.org/node/231
23:33:29 <Botty> ?type seq
23:33:31 <lambdabot> forall b a. a -> b -> b
23:45:03 <dons> hehe funny, check the ending: "Haskell is
23:45:04 <dons> great I agree. [emotion-4] You can do a lot of things in very few lines of code. You
23:45:07 <dons> don't write any code without carefully thinking what are you doing. You can make
23:45:10 <dons> great use of¬† lazy evaluation and lambda expressions. It can be compiled and
23:45:12 <dons> integrated with code from other languages. You can make GUI applications or use open
23:45:15 <dons> gl. It's cool stuff but it's not my programming language of choice"
23:46:59 <Korollary> Thats acceptable.
23:47:53 <dons> Indeed.
23:48:05 <lispy> heh
23:48:13 <lispy> "I love it, it does everything i need, but i don't use it"
23:48:18 <lispy> is that kinda the gist?
23:49:23 <lispy> dons: is this a reddit quote?
23:50:07 <dmead> yo lispy
23:50:12 <lispy> dmead: heya
23:50:19 <dmead> check this out
23:50:19 <lispy> dmead: how's code?
23:50:20 <dmead> http://programming.reddit.com/info/svdb/comments
23:50:23 <lambdabot> Title: sexy java and haskell interaction (reddit.com), http://tinyurl.com/wkgs8
23:50:23 <dmead> good!
23:50:34 <dmead> parsec is in use in that screenshot
23:50:38 * lispy reboots firefox
23:51:21 * lispy doesn't like it when his webbrowser consistently uses 2/3 of the cpu time
23:51:24 <dmead> =/
23:51:29 <dmead> yea thats not good
23:51:44 <dmead> konqueror is much faster, unfortunatly
23:51:59 <goltrpoat> ok so.  f: (R^n x R^n) -> R^n.  most functions we care about are polymorphic in n, but the n qualifies the tyvar.  i'm fairly sure we can't do this nicely in haskell, but how does one formalize it in general?
23:53:05 <dmead> lispy: in that screenshot, proverApp is my compiled prover
23:53:06 <dons> lispy: on a blog, http://channel9.msdn.com/ShowPost.aspx?PostID=261386#261386
23:53:09 <lambdabot> Title: Haskell - A valuable language, http://tinyurl.com/ybnt8w
23:53:29 <goltrpoat> in other words, are dependent types required here, or can it be done through some sort of type trickery
23:53:30 <dmead> lispy: and it's getting passed a string which is read by parsec
23:53:35 <lispy> dmead: i'll have to use a different browser
23:53:40 <lispy> neat
23:53:45 <dons> comment by "bart7simpson7" .. what's happening to the haskell world? :)
23:53:48 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/provergui1.png
23:53:50 <lambdabot> http://tinyurl.com/yeya68
23:55:07 <lispy> dmead: neat-o, is that ffi+jni?
23:55:25 <dmead> lispy: nope, just regular memory pipes
23:55:39 <dmead> lispy: java provides an api for it
23:55:53 <lispy> ah
23:55:58 <kfish> rock
23:56:07 * kfish just got HSP.Clientside set up
23:56:07 <dmead> Runtime.GetRuntime.exe
23:56:17 <dmead> (..)
23:56:27 <dmead> is like a pipe call in C
23:56:28 <dmead> i think
23:57:09 <dons> kfish: cool. any good?
23:57:35 <kfish> dons: totally awesome, from what i can tell
23:57:56 <kfish> ie. writing ajax stuff with hsp.clientside has the same kind of advantages that gtk2hs has over normal gtk
23:58:06 <lispy> dmead: ah, i get it, that picture actually shows the invoking code
23:58:11 <dmead> yes
23:58:27 <kfish> dons: ie. being able to use partial application as the event callbacks etc.
23:58:34 <dons> mmm. nice.
23:58:35 <lispy> the appin = ... line shows something i hate in java :)
23:58:44 <dmead> yeaaa
23:58:50 <dmead> that is kinda messy, but useful i think
23:58:50 <dons> needs more promotion, hsp.clientside, it's a bit underappreciated
23:59:02 <dmead> the thread also locks until theres something in the buffer
23:59:11 <dmead> i need to wrap that actionlistener in a thread
23:59:19 <dmead> err
23:59:24 <dmead> seperate thread
23:59:26 <dmead> etc
23:59:33 <kfish> dons: it was a bit tedious to install, requiring lots of random darcs repos and subprojects
