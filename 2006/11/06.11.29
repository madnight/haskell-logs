00:00:03 <lispy> dmead: if, in the future, you need tighter ingreation between java and a real PL, i recommend scala
00:00:13 <dmead> scala?
00:00:15 <lispy> dmead: scala isn't as cool as haskell, but it's sexier than java
00:00:16 <kfish> dons: which could probably all be pulled straight up into HSP upstream
00:00:25 <lispy> dmead: and it's binary compatible with java
00:00:28 <goltrpoat> java needs to disappear.
00:00:36 <dmead> ah
00:00:37 <dmead> well
00:00:44 <dmead> i'm not a java freak or anything
00:00:54 <dmead> i just thing the gui system is pretty easy
00:00:55 <dmead> and rapid
00:01:01 <lispy> ah
00:01:05 <lispy> i hate swing :)
00:01:19 <dmead> the look or the code?
00:01:23 <dmead> or both
00:01:25 <lispy> yeah
00:01:36 <dmead> hmm
00:01:41 <dmead> i'm gonna give swt a try sometime
00:01:47 <lispy> dmead: http://gallery.codersbase.com/main.php?g2_view=core.ShowItem&g2_itemId=511
00:01:49 <lambdabot> Title: metroscope2, http://tinyurl.com/y5vafa
00:01:58 <lispy> dmead: that was my last attempt with swing to do some gui work
00:02:10 <lispy> dmead: the slider widget is custom from scratch
00:02:16 <dmead> ahh
00:02:17 <dmead> cool
00:02:20 <lispy> dmead: i'm glad swing allowed me to create it, but it was kind of a pain
00:02:23 <dons> kfish: yeah.
00:02:25 <lispy> and i hate layout issues
00:02:29 <dons> too many deps eh?
00:02:40 <dmead> yea, getting the layout the way you want it really sucks
00:02:45 <lispy> dmead: the slider was cool because you could add and remove thumbs from it dynamically
00:02:46 <dons> (I found similar issues  hope)
00:02:55 <lispy> dmead: have you watch the grid bag video?
00:02:57 <dmead> i didn't know you can tell swing to assume the win32 look
00:03:04 <dmead> grid bag video?
00:03:04 <dmead> no
00:03:25 <kfish> dons: HSPClientside requires a different darcs repo of HSP (includes some patches that haven't gone upstream yet)
00:03:38 <dons> oh
00:03:45 <lispy> dmead: http://madbean.com/anim/totallygridbag/
00:03:46 <kfish> dons: and between the hsp and hsp.clientside repos there's 5 separate cabal projects
00:03:47 <lambdabot> Title: madbean » Totally Gridbag
00:04:06 <kfish> dons; plus that all relies on haskell-src-exts
00:04:17 <dmead> strongbad
00:04:17 <dmead> ah ah
00:05:06 <kfish> dons: it all compiles sweetly, so no problems there, but if it's not merged up it'll bitrot
00:05:24 <dmead> ahha
00:05:24 <dons> yeah. bug the authors!
00:05:25 <dmead> this is funny
00:05:31 <dons> @seen nibro
00:05:31 <lambdabot> I haven't seen nibro.
00:06:00 <kfish> dons: yeah, i was thinking of sending them fanmail first, because it's pretty cool stuff
00:06:08 <dmead> yea what the shit is with the fields collapsing to nothing
00:06:20 <dmead> wait
00:06:24 <dmead> i just realized something
00:06:26 <dmead> wait for it..
00:06:27 <dmead> wait..
00:06:30 <dmead> oh!
00:06:31 <dmead> java sucks
00:06:33 <dmead> i get it now
00:06:35 <dmead> !
00:07:05 <lispy> heh
00:07:20 <lispy> i need to show that to the next non-computer person who asks what i do at work :)
00:07:35 <lispy> sadly i don't think they'll fully getit
00:09:45 <goltrpoat> ive more or less run out of responses to the what i do at work question
00:10:14 <goltrpoat> i just stare at them, these days.  and mumble something about monitors.  sometimes, i offer people a sandwich.
00:10:36 <Maddas> haha, I love the 'offering people a sandwich' part.
00:10:48 <Maddas> I'm sure that settles all the questions.
00:11:06 <lispy> i could use a sandwich
00:12:05 <dmead> hahaha
00:13:06 <Korollary> They'll think you make sandwiches for a living.
00:13:24 <lispy> at least they'll understand
00:13:24 <Korollary> Just pretend you're a gynocologist
00:14:37 <Botty> problem with that is, then they come to you with their problems... there...
00:15:08 <Korollary> They won't.
00:15:26 <Korollary> If you're really worried, tell them you're a dentist. Nobody goes to a dentist.
00:15:37 <goltrpoat> the other issue with that is that while distributing sandwiches without a license is not a crime in most countries, practicing medicine without a lincense generally is.
00:15:45 <metaperl> If anyone is bored/interested, I would appreciate some help comparing the Python function decorator mechanism <http://www.ddj.com/184406073> with The Haskell Way... my blog post (in-progress) is here: http://sequence.complete.org/node/232
00:15:50 <goltrpoat> and, let's face it.  sandwiches are less stressful.
00:16:06 <dmead> yea sandwiches own
00:16:20 <Korollary> goltrpoat: you're not going to practice any of it.
00:17:31 <goltrpoat> my hopes, shattered.  my aspirations, gone.  how could you, korollary.
00:17:54 <goltrpoat> i had a whole sandwich recipe prepared.
00:18:06 <Korollary> I can take the sandwich, and keep your secret.
00:18:13 <goltrpoat> ok.
00:18:20 <goltrpoat> i'll have my people call your people.
00:18:23 <goltrpoat> we'll do lunch.
00:18:29 <dmead> power lunch
00:19:33 <Korollary> I don't do lunch. Anybody who's anybody doesn't wake up before 4pm, darling.
00:19:48 <dmead> haha
00:20:15 <goltrpoat> that's what i've been trying to tell everyone.
00:20:26 <goltrpoat> no one listens.  as a result, i have to get up at 10:30am tomorrow.
00:20:35 <dmead> i have to get up at 9 =/
00:20:42 <dmead> and take a bus for an hour surrounded by morons
00:20:44 <dmead> =/
00:20:47 <_matthew-> it's 8:14am here!
00:20:56 * _matthew- wonders what channel he's on...
00:21:11 <dmead> your on haskell =S
00:21:28 <dmead> k
00:21:34 <dmead> it's dans bed time
00:21:39 <dmead> night night
00:21:48 <Korollary> night
00:21:52 <goltrpoat> adios
00:23:17 <Excedrin> @fortune
00:23:18 <lambdabot> Gur jbeq "fcvar" vf, bs pbhefr, na nantenz bs "cravf".  Guvf vf gehr va
00:23:18 <lambdabot> nyzbfg svsgl creprag bs gur ynathntrf bs gur Tnynkl, naq znal crbcyr
00:23:18 <lambdabot> unir nggrzcgrq gb rkcynva jul.  Hfhnyyl gurfr rkcynangvbaf trg obttrq
00:23:18 <lambdabot> qbja va fvyyl chaf nobhg "fgnaqvat rerpg".
00:24:15 <Korollary> what the thunk?
00:25:34 <lispy> rot13 fortune?
00:26:08 <lispy> The word "spine" is, of course, an anagram of "penis".
00:27:22 <int-e> ... This is true in almost fifty percent of the languages of the Galaxy, and many people have attempted to explain why.  Usually these explanations get bogged down in silly puns about "standing erect".
00:28:24 <metaperl> @type sequence_
00:28:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
00:29:04 <lispy> > sequence (map return [1..10])
00:29:05 <lambdabot>  add an instance declaration for (Show (m [a]))
00:31:05 <goltrpoat> odd
00:31:17 <goltrpoat> > join $ sequence (map return [1..10])
00:31:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
00:32:08 <lispy> ?type join . sequence . map return
00:32:09 <lambdabot> forall a. [a] -> [a]
00:32:13 <lispy> nice
00:34:26 <int-e> > let r13 c | d < 13 = chr (e+13) | d < 26 = chr (e-13) | otherwise = c where e = ord c; d = (e-65) .&. 223 in map r13 "Guvf vf gehr va nyzbfg svsgl creprag bs gur ynathntrf bs gur Tnynkl."
00:34:28 <lambdabot>  "This is true in almost fifty percent of the languages of the Galaxy."
00:36:00 <norpan> bah, mod
00:36:04 <Maddas> ?type .&.
00:36:06 <lambdabot> parse error on input `.&.'
00:36:15 <Maddas> ?type (.&.)
00:36:16 <lambdabot> forall a. (Bits a) => a -> a -> a
00:38:31 <Excedrin> is there a more efficient/standard way to express this: countIf p = length . filter p
00:39:42 <Excedrin> countIf p (x:xs) = countIf p xs + if p x then 1 else 0 -- (and [] case) is simple enough, but I'm usually surprised by the things people here come up with
00:40:04 <int-e> I'd expect  length . filter p   to be fast. it's certainly the most natural way to write it.
00:41:07 <int-e> countIf p (x:xs) = countIf p xs + if p x then 1 else 0  is almost certainly worse.
00:41:09 <Excedrin> won't it iterate thru the list twice?
00:41:58 <int-e> I'd expect the compiler to be smart enough to avoid that. It certainly should be.
00:43:56 <Excedrin> I tried using a p that uses Debug.Trace to check but it's only printing a trace message once
00:46:08 <int-e> what exactly did your p do?  if it's defined as  p = trace "foo" (some expression)  then the trace would be evaluated at most once
00:46:39 <int-e> so you'd also see the message at most once.
00:48:11 <Botty> I think the length and filter one would probably optimize to yours, so might as well use the idiomatic approach
00:48:27 <goltrpoat> this seems like the prototypical deforestation case, no?
00:48:31 <thyko> why does >read "3" give an error?
00:48:37 <goltrpoat> (filter p) produces a list, length consumes one
00:48:57 <Excedrin> int-e: ok, that makes sense now. I added a parameter so that it prints multiple messages as I originally expected
00:49:16 <Botty> (filter p) processes a list at least
00:49:19 <lispy> is "length . filter p" a good fusion pair?
00:49:32 <thyko> any ideas?
00:49:41 <lispy> oh, i see goltrpoat just suggested that
00:49:48 <goltrpoat> we can write both as folds, right
00:50:04 <Excedrin> thyko: what type are you expecting?
00:50:14 <Excedrin> > (read "3" :: Int)
00:50:16 <lambdabot>  3
00:50:26 <metaperl> @type range
00:50:28 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
00:50:33 <Excedrin> uh, parens are not necessary there
00:50:42 <metaperl> @type replicate
00:50:44 <lambdabot> forall a. Int -> a -> [a]
00:50:55 <metaperl> replicate 4 "hell"
00:50:56 <thyko> aah, i have to specify the type its to be converted to
00:51:00 <thyko> thanks
00:51:04 <metaperl> > replicate 4 "hello"
00:51:06 <lambdabot>  ["hello","hello","hello","hello"]
00:52:10 <goltrpoat> > tail $ (concat . replicate 4) " hello"
00:52:12 <lambdabot>  "hello hello hello hello"
00:52:14 <goltrpoat> whee
00:54:03 <int-e> lispy: hmm. http://hackage.haskell.org/trac/ghc/ticket/876 ... length is not a good consumer.
00:54:06 <lambdabot> Title: #876 (Length is not a good consumer) - GHC - Trac, http://tinyurl.com/ym9e5l
00:54:30 <lispy> interesting
00:54:36 <lispy> bad length!
00:54:55 <goltrpoat> int-e:  yikes.
00:55:32 <Botty> :O
00:55:34 <int-e> anyway, I'd still write  length . filter p  unless I'm sure it's a bottleneck.
00:55:55 <goltrpoat> was the ticket closed?  spj's last comment is from september 28
00:56:13 <int-e> 'milestone changed from 6.6.1 to 6.8'
00:56:18 <lispy> i would try the example in the ticket to see if you have a bad consumer
00:56:20 <goltrpoat> oh, missed that
00:57:00 <metaperl> int-e - cant you drop the p
00:57:08 <Excedrin> I guess I need to swap the operands to + to make my explicit recursion version tail recursive
00:57:08 <metaperl> countIf = length . filter
00:57:15 <int-e> metaperl: no
00:57:22 <int-e> @type length . filter
00:57:23 <goltrpoat> well, ghci is seriously disliking that.
00:57:23 <lambdabot>   Expecting a function type, but found `b'
00:57:24 <lambdabot>    Expected type: (a1 -> Bool) -> [a]
00:57:33 <int-e> @type \p -> length . filter p
00:57:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
00:57:53 <metaperl> hmm
00:57:55 <goltrpoat> (in 6.5 anyway)
00:57:56 <metaperl> oh
00:58:04 <metaperl> because filte takes 2 args
00:58:13 <metaperl> @pl length . filter p
00:58:13 <lambdabot> length . filter p
00:58:24 <metaperl> length . (filter p)
00:58:25 <int-e> Excedrin: you need an accumulator. and make sure it's strict.
00:58:28 <goltrpoat> @pl \p -> length . filter p
00:58:29 <lambdabot> (length .) . filter
00:58:43 <int-e> I dislike sections of (.).
00:58:47 <wolverian> dot2 :)
00:58:50 <goltrpoat> aye.
00:59:18 <metaperl> (length .) . filter confuses me. just thought I'd mention that
00:59:29 <goltrpoat> agreed
01:00:40 <dons> i think it confuses everyone
01:00:47 <dons> but its length `dot2` filter :)
01:00:54 <metaperl> @type dot2
01:00:56 <lambdabot> Not in scope: `dot2'
01:01:02 <wolverian> > let dot2 = (.).(.); foo = length `dot2` filter in foo (<5) [1..10]
01:01:04 <lambdabot>  4
01:01:30 <goltrpoat> oh, nuts.  that does make it a lot more readable.
01:01:43 <int-e> @type ap (const ap) const (ap (const ap) const length) filter
01:01:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
01:01:55 <int-e> dot-free.
01:02:04 <metaperl> @type (.)
01:02:05 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
01:02:07 <dons> heh
01:02:20 <dons> ?type (.).(.)
01:02:22 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:02:31 <dons> just a way to soak up 2 args
01:02:34 <Cale> The (f .) . g thing is a little strange until you get used to it.
01:02:54 <dons> i.e. (.).(.) length filter p "foo"
01:03:12 <metaperl> it looks like an emoticon
01:03:22 <dons> I'm almost at the point of sitting down and working out a (.).(.) ... set
01:03:26 <dons> and sticking them in lambdabot..
01:03:33 <Cale> I think that maybe one application of it in an expression is okay, but with lots of sections, it gets hard.
01:03:38 <dons> dot = (.) ; dot2 = (.).(.) ; ...
01:04:05 <int-e> eye = (.); eyes = (.).(.); manyeyes = (.).(.).(.) ?
01:04:56 <Botty> by using that kind of stuff in real code you guys are living up to the myth that haskellers write obfuscated code
01:05:02 * int-e eyes length filter p "foo" suspiciously.
01:05:04 <dons> cyclop = (.) ; human =(.). (.); thirdeye = (.).(.).(.) ; spider = (.).(.).(.).(.).(.)
01:05:12 <dons> int-e: heh
01:05:35 <dons> I think haskellers wrote clean code until we had @pl
01:05:35 <metaperl> tie that with the Monster monad and you are off and running
01:05:36 <Botty> or rather, try to write obfuscated code
01:05:38 <dons> it ruined us all!
01:05:41 <Botty> heh, yeah
01:05:47 <int-e> let frog = human in ...
01:05:51 <Botty> it's cool, and all, but seriously annoiying
01:05:52 <Botty> ;p
01:06:29 <goltrpoat> > ((.).(.).(.)) (*2) (\a b c -> (a+b)*c) 1 2 3
01:06:30 <lambdabot>  18
01:06:34 <goltrpoat> ok, that's just wrong.
01:06:43 <wolverian> Botty, I think dot2 is pretty clear, though. it's just the (.).(.) that needs to be hidden. :)
01:06:43 <int-e> foldl' isn't a good consumer either it seems. it's not even defined in GHC.List.
01:06:50 <dons> goltrpoat: now you're getting it!
01:06:57 <goltrpoat> hehe
01:07:25 <dons> dot2 seems to appear daily
01:07:27 <goltrpoat> im going to start randomly sprinkling that throughout my code
01:07:46 <Botty> wolverian - maybe, problem is you can't nicely infix it like .
01:07:47 <Botje> goltrpoat: how does that work? you only provide two functions :(
01:07:57 <Botje> the lambda counts as a third, sure but ..
01:08:01 <dons> ?type ((.).(.).(.))
01:08:02 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
01:08:03 <goltrpoat> ?type (.).(.).(.)
01:08:04 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
01:08:05 <goltrpoat> doh.
01:08:31 <norpan> hey, those are actually useful
01:09:36 <Excedrin> ok, the length . filter version is empirically faster
01:10:09 <Botty> I mean, ok, yes you can write it all nice and pointfree, but I classify that as abuse rather than use
01:11:09 <Botty> like you can abuse c++ pointers and increment/decrement operators, or the macro system
01:11:53 <merus> abuse is just a use we haven't found a justifiable purpose for yet.
01:12:18 <Excedrin> ... or the template system, or casts or RTTI or inheritance
01:12:19 <goltrpoat> > foldr (\e es -> if (e == 'l') then e:es else es) [] "hello world"
01:12:20 <lambdabot>  "lll"
01:12:23 <dons> Botty: but at least its well understood. its not so much a hack, its just lambda calculus
01:12:25 * Botty 's functional langs won't even have currying
01:12:42 <Botty> excedrin - sure, i wasn't making an exhaustive list of c++'s frequently abused ;)
01:12:43 <dons> the type makes it pretty clear:
01:12:47 <dons> oh, I wonder:
01:12:51 <dons> ?djinn (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
01:12:52 <lambdabot> f a b c d e = a (b c d e)
01:12:59 <dons> there we go!
01:13:10 <Botje> @pl (\e es -> if (e == 'l') then e:es else es)
01:13:10 <dons> if @djinn can derive it, its not a hack :)
01:13:11 <lambdabot> join . ap ((.) . if' . ('l' ==)) (:)
01:13:20 <Botje> argh! that looks awful :)
01:13:21 <dons> ?. pl djinn (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
01:13:21 <lambdabot> f = (.) . (.) . (.)
01:13:30 * Botty sees no .s in djinn's thingamabob
01:13:46 <mauke> excuse me wtf r u doin
01:13:51 <merus> Indeed.
01:13:52 <Botty> Just because its not a hack doesn't mean you can't abuse it
01:13:58 <dons> sure.
01:14:16 <Botje> is there anyplace on the wiki I can read more about (.).(.) ?
01:14:24 <dons> ?wiki Pointfree
01:14:24 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
01:14:34 <dons> but its pretty much only ever used in this channel
01:14:40 <dons> :) its the only place i've seen it, anyway
01:14:48 <goltrpoat> and that's more or less where it should stay
01:14:53 <goltrpoat> :)
01:14:57 <dons> unless we hvae dot, dot2, dot3 ....
01:15:33 <Botty> few, that's good
01:15:37 <Botty> *phew
01:16:16 <Botty> I'll use it, just when it makes the code clearer, which is rare
01:16:33 <dons> you'll probably never need to use it :)
01:16:59 <Botty> yes, but it does sometimes make code nicer.  most of the time much much worse
01:17:06 <dons> @unpl (.) . (.) . (.) -- would be worse though
01:17:06 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 15}: Unterminated end-of-line comment
01:17:11 <dons> @unpl (.) . (.) . (.)
01:17:11 <lambdabot> (\ l b c f i -> l (b c f i))
01:17:14 <dons> ah no!
01:17:20 <dons> but see, that's why its never used
01:17:24 <goltrpoat> lawrdy.
01:17:27 <dons> since the lambda is clearer
01:17:33 <Botty> yep
01:19:11 <Botje> i've been thinking of elegant ways of solving http://www.cs.caltech.edu/courses/cs11/material/haskell/lab5/lab5.html (i'm not following that class, not even in the same continent)
01:19:14 <lambdabot> Title: CS 11: haskell track: assignment 5, http://tinyurl.com/ycnxv5
01:20:06 <Botje> you have to jump pegs over other pegs, and there's a max of 14 jumps
01:20:39 <Botje> so I was thinking to just "list >>= tryJumps 14" times
01:20:44 <Botje> so I was thinking to just "list >>= tryJumps" 14 times
01:20:45 <Botje> even :)
01:20:56 <Botje> but i'm sure there's a better way involving fix somehow?
01:21:49 <Excedrin> what's the runtime arg to get GC info?
01:21:55 <goltrpoat> "in fact, the final peg will always be in position 12" -- what?
01:22:05 <Botje> goltrpoat: apparently :)
01:22:10 <goltrpoat> if it can end up in 12, then it can also end up in 3 and 4 by symmetry
01:22:12 <goltrpoat> er
01:22:15 <goltrpoat> 3 and 5 i mean
01:23:21 <goltrpoat> or am i missing something
01:23:39 <Botje> if I find an elegant way of computing them i'll gladly find out for you :)
01:24:36 * Botty adds more problems with pointfree to the wiki
01:26:00 <goltrpoat> botje:  is there something in particular you're stuck on?  i mean.. you need a board representation, you need to come up with a list of possible moves, and you need a means of performing each move
01:26:30 <goltrpoat> for each move in the list of moves, produce a new board by performing the move.  if a single peg is left, we're done.  otherwise, rinse lather repeat.
01:27:05 <dons> Botty: remember that noone really recommends you write in (.).(.) style :) its just a fun joke we play in channel
01:27:18 <Botty> good, i misunderstood that earlier :)
01:27:18 <goltrpoat> this terminates, since each move is irreversible (removes a peg from the board)
01:27:22 <Syzygy-> dons: Really?
01:27:44 <xerox> Syzygy-: lies!
01:27:52 <xerox> G'day.
01:27:59 <Excedrin> aw shucks, I assumed that I should run all of my code thru pl
01:29:22 <dons> that's what the IOHCC was for, but now we have @pl the iOHCC seems kind of easy :)
01:29:27 <xerox> We fight the racial disgrace of functions with formal arguments.
01:29:34 * Botty idly wonders if anyone has tried a graphical representation of haskell shtuff
01:30:05 <lispy> Botty: i heard about it for lambda calc. evaluation
01:30:12 <lispy> Botty: some sort of circles
01:30:14 <Excedrin> there's at least those fold* diagrams, and the drawings of various monads
01:30:16 <Botty> cool
01:30:19 <Botty> yeah
01:30:19 <lispy> Botty: i wish i knew what it was called
01:30:32 <lispy> also, you could visualize the graph reduction
01:30:43 <Excedrin> http://cale.yi.org/index.php/Fold_Diagrams
01:30:45 <lambdabot> Title: Fold Diagrams - CaleWiki
01:30:52 <lispy> cale wiki?
01:31:28 <Botty> I was thinking more along the lines of "this box is a function, you can connect lines to its inputs, and connect lines from its output(s?!?!?) to other functions, or even make a big box around other boxes and give it a name!"
01:31:54 <Excedrin> http://sigfpe.blogspot.com/2006/10/monads-field-guide.html
01:31:57 <lambdabot> Title: A Neighborhood of Infinity: Monads, a Field Guide, http://tinyurl.com/vcnas
01:34:49 <Excedrin> Botty: that would be neat, something like Subtext, but that produces Haskell...
01:35:15 <Botty> yeah
01:35:20 <dons> Botty: hehe
01:35:31 <dons> isn't that 2d you're describing?
01:35:34 <Botty> yep
01:35:34 <goltrpoat> electronics guys have had that for ages, not sure why it never caught on in the fp world
01:36:17 <Botty> I think the line and box functions would have some crazy pl representations, perhaps even always
01:36:18 <Excedrin> wasn't the CASE stuff related in some way?
01:37:08 <Botty> come to think of it, 2d boxes could be the ideal representation for haskell
01:38:00 <Botty> I already had this all planned out for my language, of course, but might give it a shot on haskell
01:38:27 <Botty> ooh, could even have something like syntax macros, only graphical!
01:38:52 <Botty> like associate an svg with some new graphical idiom
01:40:19 <Botty> and who needs boxes, give special symbols to the prelude functions
01:40:27 <dons> ?unpl ((f .) .) . g
01:40:27 <lambdabot> (\ e j m -> f (g e j m))
01:40:39 <dons> kpreid++ unpl is pretty good!
01:40:52 <dons> ?pl \x -> x+x+x
01:40:53 <lambdabot> (+) =<< join (+)
01:40:58 <dons> ?unpl (+) =<< join (+)
01:40:58 <lambdabot> (((+) >>= \ a -> a) >>= (+))
01:41:04 <dons> yeah, the monads are too hard
01:41:19 <Botty> ?. unpl pl f (g x y z) y
01:41:20 <lambdabot> f (g x y z) y
01:41:31 <goltrpoat> @pl \f g x -> f x (g x)
01:41:32 <lambdabot> ap
01:41:38 <goltrpoat> well who woulda thunk.
01:41:42 * goltrpoat slaps self
01:41:48 <Botty> ?unpl ap
01:41:49 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
01:41:58 <Botty> uhhh ;p
01:42:00 <mauke> ah, I get it
01:42:26 <goltrpoat> there's something vaguely profound about that.
01:44:13 <wolverian> mauke, you get what? :)
01:44:32 <mauke> x >>= y is liftM2 y x id, and join x is id >>= x
01:44:50 <mauke> i.e. liftM2 x id id
01:45:30 <Excedrin> what's ap otherwise?
01:47:55 <Botje> goltrpoat: I know. but I was wondering if there's a better way to generate the final boards than just repeat (boards >>= tryMove) 14 times
01:48:19 <mauke> .oO( replicate 14 (boards >>= tryMove) )
01:48:39 <mgsloan> new nick for me - http://www.urbandictionary.com/define.php?term=botty
01:48:41 <mgsloan> :O
01:48:42 <lambdabot> Title: Urban Dictionary: botty, http://tinyurl.com/y8vbwl
01:50:02 <Botje> mauke: i'm assuming that doesn't work very much, da?
01:50:20 <mauke> it's probably not what you meant
01:50:35 <mgsloan> no tis not
01:50:39 <Botje> I thought so.
01:50:50 <mauke> take 14 $ iterate (>>= tryMove) boards
01:50:50 <Botje> still, I could be wrong, i'm still a monad virgin :P
01:52:23 <wolverian> agh, Reader is abusing my mind.
01:52:32 <yuten> hello ~~
01:53:08 <yuten> if i have a variable s="123" which type is String, can i convert it to Int
01:53:48 <mux> > read "123"
01:53:49 <lambdabot>  Add a type signature
01:53:51 <mux> > read "123" :: Int
01:53:53 <lambdabot>  123
01:55:34 <yuten> thanks a lot~
02:01:45 <mux> yuten: it is most of the time unnecessary to specify a type signature since it can be infered from the rest of the code
02:01:54 <mux> we can't avoid it when using lambdabot though :)
02:01:58 <mux> since there is no context
02:02:47 <mgsloan> :type read
02:02:51 <mgsloan> ?type read
02:02:52 <lambdabot> forall a. (Read a) => String -> a
02:02:58 <mgsloan> oh. crazy
02:03:52 <dons> the type just means it dispatches to the parser for objects of that type
02:04:00 <dons> kinda neat, imo :)
02:04:47 <mgsloan> yeah, seriously neat
02:05:02 <mgsloan> I didn't know haskell could take the inferred type and apply it to the return of a function
02:05:09 <mgsloan> or i mean expected type
02:05:31 <dons> > let s = ["123", "'f'", "()" ] in (read (s !! 0) :: Int, read (s !! 1) :: Char, read (s !! 2) :: ())
02:05:33 <lambdabot>  (123,'f',())
02:05:36 <mux> > take (read "2") "abcdef"
02:05:38 <lambdabot>  "ab"
02:05:46 <mux> here I don't specify a type signature
02:05:51 <mux> since take is supposed to take an Int
02:06:16 <dons> ?type read
02:06:17 <lambdabot> forall a. (Read a) => String -> a
02:06:52 <Botje> aha.
02:07:01 * mux notes his last sentence was a bit confusing due to the repetition of "take" :-)
02:07:02 <Botje> replicateM performsan action n times! :)
02:07:08 <dons> is really: ReadParser -> String -> Int, once you put an :: Int annotation down
02:07:08 <mux> yep
02:07:23 <mux> > replicateM 3 (putChar "a")
02:07:24 <lambdabot>  Couldn't match `Char' against `[Char]'
02:07:29 <mux> > replicateM 3 (putChar 'a')
02:07:31 <lambdabot>  <IO [()]>
02:07:40 <mux> not the best example :-)
02:08:36 <mgsloan> > let foo = read . show
02:08:37 <lambdabot>  Parse error
02:08:38 <goltrpoat> > replicateM 5 "a"
02:08:39 <lambdabot>  ["aaaaa"]
02:09:01 <mux> this doesn't outline the monadic nature of replicateM though
02:09:48 <goltrpoat> > replicateM 5 (Just 10)
02:09:49 <lambdabot>  Just [10,10,10,10,10]
02:09:50 <goltrpoat> better? :)
02:09:59 <mux> heh, yeah :)
02:14:07 <mgs> hmm, owned by someone else
02:14:16 <mgsloan> not surprising, since its freenode
02:19:51 <psykotic> @check (\n m -> (sequence $ replicate n m) == replicateM n m) :: Int -> Maybe Int -> Bool
02:19:52 <lambdabot>  OK, passed 500 tests.
02:21:59 <mux> @check (reverse . reverse == id) :: String -> Bool
02:22:01 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: String ...
02:22:40 <mux> @check (\s -> (reverse . reverse) s == s) :: String -> Bool
02:22:41 <lambdabot>  OK, passed 500 tests.
02:25:33 <mgsloan> @check (\s -> (lines . unlines) s == s) :: String -> Bool
02:25:34 <lambdabot>  Couldn't match `String' against `Char'
02:26:03 <mgsloan> @check (\s -> (unlines . lines) s == s) :: String -> Bool
02:26:05 <lambdabot>  Falsifiable, after 2 tests: "\339534\370027"
02:26:13 <mgsloan> shame, on the prelude
02:26:31 * mgsloan has brought this one up before...
02:27:15 <goltrpoat> the first one would be..
02:27:24 <goltrpoat> @check (\s -> (lines . unlines) s == s) :: [String] -> Bool
02:27:28 <lambdabot>  OK, passed 500 tests.
02:27:33 <mgsloan> yeah
02:27:36 <mgsloan> well, that one works
02:27:40 <mgsloan> but the reverse doesn't
02:28:06 <mgsloan> because unlines sticks an unnecessary "\n" at the end
02:28:12 <goltrpoat> ah
02:28:54 <mgsloan> > lines "foo\n"
02:28:55 <lambdabot>  ["foo"]
02:29:06 <mgsloan> > lines "foo\n\n\n"
02:29:08 <lambdabot>  ["foo","",""]
02:29:18 <psykotic> > words "hello   world"
02:29:20 <lambdabot>  ["hello","world"]
02:29:41 <mgsloan> > words "hello   world"
02:29:43 <lambdabot>  ["hello","world"]
02:30:02 <psykotic> @check (\s -> (words . unwords) s == s) :: [String] -> Bool
02:30:03 <mgsloan> hmm, lines/words/etc should just be left out of the prelude
02:30:03 <lambdabot>  Falsifiable, after 2 tests: ["\210035\687497\901028","\196539\549419\497234"...
02:30:45 <psykotic> @check (\s -> (unwords . words) s == s) :: String -> Bool
02:30:47 <lambdabot>  OK, passed 500 tests.
02:31:14 <goltrpoat> > words "hello world\n"
02:31:16 <lambdabot>  ["hello","world"]
02:31:36 <goltrpoat> > words "hello\n world"
02:31:38 <lambdabot>  ["hello","world"]
02:31:41 <goltrpoat> that seems broken.
02:31:44 <psykotic> no
02:31:47 <psykotic> it splits based on runs of whitespace
02:32:05 * psykotic thinks that's the Right Thing To Do.
02:32:12 <mgsloan> yeah, probably
02:32:33 <mgsloan> much better would be to define a Data.List.split and move these in as well
02:33:01 <mgsloan> (into Data.List.split).  But it is the prelude, which is pretty immutable
02:34:09 <goltrpoat> it's just that words/unwords and lines/unlines sound like inverses of each other.
02:35:04 <psykotic> goltrpoat, unwords is a left inverse of words and similar for lines/unlines. in practice this is the useful way to go, imo.
02:36:13 <psykotic> even if they aren't right inverses i think it is still a nice naming scheme.
02:37:26 <psykotic> @check (\ss -> (intersperse " " ss) == (unwords ss)) :: [String] -> Bool
02:37:27 <lambdabot>  Couldn't match `[Char]' against `Char'
02:38:16 <psykotic> @check (\ss -> (join $ intersperse " " ss) == (unwords ss)) :: [String] -> Bool
02:38:21 <lambdabot>  OK, passed 500 tests.
02:38:35 <goltrpoat> something like wordsWith :: String -> String -> [String] and a corresponding unwordsWith would make more sense, imo.  then the fact that words . unwords /= id is made explicit
02:39:01 <goltrpoat> er.  i guess unwordsWith makes no sense.  nevermind
02:39:10 <mgsloan> I think i remember making my own unlines which satisfied (unlines . lines) == id
02:39:25 <rc-1> why doesnt scheme use lazy eval? seems the intuitive way of doing functional programming
02:39:37 <goltrpoat> mgsloan:  you can't, the whole point is that lines is lossy
02:39:39 <goltrpoat> hehe
02:39:45 <psykotic> rc-1, side effects is the #1 reason.
02:39:47 <mgsloan> > let ul = L.intersperse '\n'
02:39:48 <lambdabot>  Parse error
02:40:08 <mgsloan> i keep messing up lets, i think i forgot the bots let syntax
02:40:17 <mgsloan> @let ul = L.intersperse '\n'
02:40:18 <lambdabot> <local>:10:5: Not in scope: `L.intersperse'
02:40:21 <goltrpoat> mgs:  let <expr> in <expr>
02:40:23 <rc-1> ohhh now i see, side effects are dumb in functional too though!
02:40:28 <mgsloan> oh yeah i forogt
02:40:37 <psykotic> goltrpoat, he means the persistent lets i think
02:40:41 <psykotic> @let hw = "Hello world"
02:40:42 <lambdabot> Defined.
02:40:51 <psykotic> > L.hw ++ L.hw
02:40:53 <lambdabot>  "Hello worldHello world"
02:40:54 <retybok> can someone point me to a tutorial about basic IO in haskell?
02:40:55 <goltrpoat> oh, didn't know there was a persistent let
02:40:59 <mgsloan> @let ul = Data.List.intersperse '\n' in
02:41:00 <lambdabot>  Parse error
02:41:09 <psykotic> @let ul = Data.List.Intersperse '\n'
02:41:10 <mgsloan> @let ul = Data.List.intersperse '\n'
02:41:10 <lambdabot> <local>:11:5: Not in scope: data constructor `Data.List.Intersperse'
02:41:12 <lambdabot> Defined.
02:41:14 <mgsloan> heh
02:41:33 <psykotic> spam, bam, thank you ma'am
02:41:39 <rc-1> http://www.willamette.edu/~fruehr/haskell/evolution.html lol :)
02:41:41 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
02:42:05 <mgsloan> ?quickcheck (\x -> (ul . lines) x == x) :: String -> Bool
02:42:06 <lambdabot> Unknown command, try @list
02:42:23 <mgsloan> ?check (\x -> (ul . lines) x == x) :: String -> Bool
02:42:24 <lambdabot>  Not in scope: `ul'
02:42:30 <mgsloan> christ
02:42:46 <psykotic> L.ul :)
02:42:54 <mgsloan> ?check (\x -> (L.ul . lines) x == x) :: String -> Bool
02:42:55 <lambdabot>  Couldn't match `Char' against `String'
02:43:04 <psykotic> you can use private message with lamdabot, btw
02:43:06 <goltrpoat> [String] :)
02:43:08 <psykotic> nudge nudge
02:43:13 <mgsloan> lol
02:43:42 <mgsloan> should it be [String]? hmm
02:43:53 <mgsloan> > ul "123\n234"
02:43:54 <lambdabot>  Not in scope: `ul'
02:44:14 <mgsloan> > L.ul ["123", "abc"]
02:44:15 <lambdabot>  Couldn't match `Char' against `[Char]'
02:44:17 <mgsloan> sorry, its late
02:44:51 <mgsloan> @let ul = concat . Data.List.intersperse '\n'
02:44:52 <lambdabot> <local>:12:0:     Multiple declarations of `L.ul'     Declared at: <local>:11...
02:45:03 <mgsloan> @reset
02:45:04 <lambdabot> Unknown command, try @list
02:45:19 <psykotic> mgsloan, seriously, considering using privmsg for this
02:45:19 <mgsloan> @let uli = concat . Data.List.intersperse '\n'
02:45:20 <lambdabot> Couldn't match `[a]' against `Char'
02:45:47 <mgsloan> ok, i give up then, i did it in the past.  had an unlines . lines == id
02:46:17 <mgsloan> I do probably have the highest percentage of lambdabot errors...
02:47:13 <mgsloan> @let uli xs = concat $ Data.List.intersperse '\n' xs -- no one is talking anyway
02:47:14 <lambdabot> Couldn't match `[a]' against `Char'
02:47:50 <mgsloan> @let uli xs = concat $ Data.List.intersperse "\n" xs
02:47:51 <lambdabot> Defined.
02:48:04 <goltrpoat> > intersperse '_' "hello world"
02:48:05 <lambdabot>  "h_e_l_l_o_ _w_o_r_l_d"
02:48:19 <mgsloan> ?check (\x -> (uli . lines) x == x)
02:48:20 <lambdabot>  Not in scope: `uli'
02:48:21 <goltrpoat> oh you did switch to "\n", nevermind
02:48:45 <mgsloan> ?check (\x -> (L.uli . lines) x == x) :: String -> Bool
02:48:47 <lambdabot>  OK, passed 500 tests.
02:48:50 <mgsloan> see!
02:49:19 <mgsloan> you can have a bloody reversible lines.... either that or check isn't checking the right thing
02:49:36 <mgsloan> that's actually more likely now that i've seen the example test cases
02:50:10 <goltrpoat> sorry, i was thinking of words
02:50:26 <JohnMeacham> Hello.
02:50:50 <PhilippaZ> 'lo John
02:51:06 <mgsloan> > (L.uli . lines) "123\n\nabc\n\n\nfoobar\n\n\n\n"
02:51:08 <lambdabot>  "123\n\nabc\n\n\nfoobar\n\n\n"
02:51:25 <mgsloan> agg, ok, proven wrong
02:51:34 <mgsloan> quickcheck bug
02:51:38 <mgsloan> sorta kinda
02:52:08 <psykotic> with 500 tests there isn't much coverage of something as special case as that
02:52:32 <mgsloan> yeah, figured it was smart enough to throw some newlines and special chars in a string though
02:52:36 <dons> see what scheck says
02:52:42 <dons> ?scheck (\x -> (L.uli . lines) x == x) :: String -> Bool
02:52:44 <lambdabot>   Completed 1957 test(s) without failure.
02:52:47 <dons> heh
02:52:54 <psykotic> is there also a @czech?
02:52:55 <psykotic> :)
02:53:01 <dons> great name!
02:53:04 <nornagon> heh.
02:53:13 <psykotic> czech it out!
02:53:50 <nornagon> winner of the 2008 olympics 100m sprint -- quickczech.
02:55:01 <JohnMeacham> Anyone have a nice Binary library that works via mmap? the biggest time sink in jhc right now is reading in the libraries from the disk. I'd like to fix this.
02:55:05 <mgsloan> seriously though, its pretty unreasonable for quickcheck to test through the whole unicode range, randomly
02:55:41 <mgsloan> should significantly weight ascii, and the special sections
02:56:47 <psykotic> i'm assuming there's already some sort of weighing, or you wouldn't get any kind of useful coverage with only 500 tests
02:57:14 <JohnMeacham> sweet. the standard libraries are now only 14megs rather than 28. looks like my new simplifications are paying off.
02:57:29 <PhilippaZ> heh
02:57:34 <mgsloan> well, that's what I'm saying - there's not useful covereage.  I'd like to see what it tries
02:57:48 <psykotic> yo don, have you played with the test shrinking happiness in quickcheck 2?
02:58:18 <psykotic> mgsloan, it's useful enough to catch a lot of things that it statistically shouldn't catch if it covered the unicode range uniformly.
02:58:25 <pejo> JohnMeacham, you're trying to optimize for size when compiling Haskell?
02:58:30 <dons> JohnMeacham: should be pretty easy to add an mmap layer under newbinary, or take musasabi's new bytestring/binary lib, and put mmap underneath
02:58:35 <dons> psykotic: no. is it good?
02:58:52 <psykotic> dons, i was going to try to get quickcheck 2 working tonight, so i don't know yet. but i'm intrigued.
02:59:11 <dons> ask bringert about it
02:59:18 <JohnMeacham> dons: yeah, that is what I am thinking. is there a comprehensive list of all the binary libraries out there somewhere? I know there are a bunch floating around.
02:59:50 <dons> ?wiki Binary_Io
02:59:51 <lambdabot> http://www.haskell.org/haskellwiki/Binary_Io
02:59:53 <dons> but its not comprehensive
03:00:07 <dons> (the new binary+bytestring stuff isn't there)
03:00:18 <dons> need to ask musasabi about that
03:00:26 <JohnMeacham> pejo: well, jhc optimizes for size as a side effect of its runtime less nature. I am talking about the size of the intermediate libraries, which balooned recently due to various issues.
03:00:53 <dons> there's also FastString in ghc
03:01:05 <dons> you could mmap into that (but its basically a ByteString, afaik)
03:01:08 <mgsloan> from the quickcheck source it looks like there's no weighting
03:01:38 <dons> you could addd it though, mgsloan
03:01:46 <dons> just tweak the Char instance for Arbitrary
03:01:53 <mgsloan> (btw, I'm botty)
03:01:57 <mgsloan> yeah
03:02:03 <dons> i know :) mgsloan is better :)
03:02:17 <mgsloan> definitely.  didn't know botty had real meaning..
03:02:29 <PhilippaZ> ...heh
03:02:33 <JohnMeacham> I'll see how good I can get things by making them more lazy and rearranging them a bit first.
03:04:58 <JohnMeacham> hmm.. looks like NewBinary is roughly equivalant to what I am using now.
03:13:01 <mgsloan> dons - i could add it, but It's 3AM, and I haven't learned haskell random numbers yet
03:13:39 <nornagon> random numbers were the first thing i tried to do in haskell >.>
03:13:47 <mgsloan> nornagon - lol
03:13:53 <araujo> morning
03:13:54 <nornagon> I haven't come back to it since :D
03:13:57 <nornagon> (but i plan to)
03:14:25 <dons> ?docs System.Random
03:14:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
03:16:40 <dmn> hello again
03:20:13 <Xavier_> Hi all
03:20:25 <Xavier_> (did I do it well Ibid? ;) )
03:21:26 <psykotic> no, no, it's all wrong. the correct formal greeting is, "sup my bitches".
03:21:38 <psykotic> according to palomer anyway.
03:21:58 <dons> Xavier_: welcome back Sir!
03:23:53 <Philippa> psykotic: too bad he doesn't take after DP in a couple of other regards, huh?
03:24:00 <Xavier_> psychotic > damned, failed again!
03:24:20 <Xavier_> I'll try to do it right tomorrow, so please don't ban me ok?
03:37:06 <thyko> i am reeeealy liking this lang
03:37:23 <thyko> totally different programming lang to me
03:37:44 <thyko> one day and counting ...
03:39:57 <ulfdoz> Hey, theoreticians: I have two concrete undirected graphs, and I shall find isomorphism: The necessary conditions, that they have the same number of nodes and all nodes have the same degree (3 in this case) hold. Now I have done the assumption: If both have a hamilton-cycle, the cycles are isomorph. I found those hamilton-cycles and constructed the isomorphism. It seems to work for this special case (bipartite graph with 8 nodes and degree 3 ...
03:40:03 <ulfdoz> ... for each node). Do I miss something obvious?
03:42:02 <retybok> can someone point me to a tutorial about basic IO in haskell?
03:43:09 <ms_> @where InsideIO
03:43:10 <lambdabot> I know nothing about insideio.
03:43:12 <ms_> @where Inside IO
03:43:12 <lambdabot> I know nothing about inside.
03:43:18 <ms_> grr, that's the article you want
03:43:23 <dons> thyko: cool. you're back for another round
03:43:35 <dons> retybok: visit http://haskell.org and click on the 'tutorials' link
03:43:36 <retybok> ?
03:43:37 <ms_> http://haskell.org/haskellwiki/IO_inside
03:43:37 <lambdabot> Title: Haskell - HaskellWiki
03:43:38 <lambdabot> Title: IO inside - HaskellWiki
03:43:44 <dons> ?where yaht
03:43:45 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
03:43:48 <dons> is also recommended
03:44:05 <retybok> dons: i read a good part of yaht
03:44:11 <dons> cool
03:44:20 <retybok> dons: but i need some concrete examples
03:44:32 <retybok> so I can do some real programs
03:44:49 <retybok> thank you all
03:44:52 <dons> "IO inside" is good.
03:45:13 <dons> there's hundreds of examples on haskell.org too (big programs, little programs, all sorts)
03:45:31 <dons> you could try solving the ruby quiz puzzles:
03:45:35 <dons> http://haskell.org/haskellwiki/Haskell_Quiz
03:45:36 <lambdabot> Title: Haskell Quiz - HaskellWiki
03:46:30 <retybok> dons: do they have answers?
03:46:57 <retybok> i've been trying to do these problems: http://www.spoj.pl/
03:47:00 <dons> people put up answers on the above link as they complete them
03:47:01 <lambdabot> Title: Sphere Online Judge (SPOJ)
03:47:04 <retybok> but it's still too hard for me
03:47:08 <dons> ah good, there's been a few people here working on that too
03:47:14 <dons> glguy for one
03:47:52 <dons> also http://mathschallenge.net/index.php?section=project
03:47:55 <lambdabot> Title: mathschallenge.net, http://tinyurl.com/c34tf
03:48:24 <dons> Cale, we really need to set up some newbie challenge problems (with IO)
03:48:40 <dons> i.e. rediscover the prelude, like we talked about
03:49:16 <retybok> that would be great, I think that's something missing in the haskell tutorials
03:49:24 <kosmikus> sounds like a really good idea
03:49:33 <retybok> anyway, thanks a lot, I have some material now :)
03:52:07 <dons> kosmikus: so something like a series of puzzles that involve working out Prelude functions, learning the basic data structures, into IO, onto monads and exploring the core libs. mmm.
03:55:44 <dons> ?users
03:55:44 <lambdabot> Maximum users seen in #haskell: 276, currently: 259 (93.8%), active: 36 (13.9%)
03:57:42 <dons> the secret russian haskell cabal strikes again: http://palm-mute.livejournal.com/2953.html
03:57:43 <lambdabot> Title: palm_mute: Цитата
03:57:56 <dons> i particularly like: ", -, monad tutorial :)"
04:00:08 <dons> more secret russian lambda hackers: http://photos1.blogger.com/blogger2/4419/3608/1600/061108_011148.0.jpg
04:00:10 <lambdabot> http://tinyurl.com/ydqkln
04:00:58 <arcatan> secret russian haskell scene
04:01:06 <dons> totally
04:02:27 <Axioplase> Hi !
04:05:01 <dons> hi Axioplase
04:05:26 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
04:05:27 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:05:45 <Axioplase> I have a problem instanciating Show for polymorphic lists : rafb.net/paste/results/qLLq2S97.html
04:05:51 <dons> ADEpt: found your blog!  http://users.livejournal.com/_adept_/ :)
04:06:07 <dons> ADEpt: so is there a secret russian haskell scene?
04:07:59 <dons> Axioplase: you'll need a show constraint on the elements of the list
04:08:21 <Axioplase> dons: hum... how would that be written ?
04:08:38 <dons> so like this:
04:08:39 <dons> *Main> Cons 'x' Nil
04:08:40 <dons> 'x':[]
04:08:41 <dons> from:
04:08:47 <dons> instance Show a => Show (Li a) where
04:08:47 <dons>   show Nil        = "[]"
04:08:49 <dons>   show (Cons a l) = show a ++":"++ show l
04:08:50 <dons> (easy :)
04:09:24 <dons> so, if you can show the element type, then you can show a Li of that type
04:09:49 <Axioplase> You mean, as long as I don't effectively create such a list, the typing would fail ?
04:10:12 <dons> nono. you need: instance Show a => Show (Li a) where
04:10:18 <Axioplase> haa
04:10:25 <Axioplase> Didn't see that
04:10:34 <dons> which means: if I have Show a, then I also have Show (li a)  :)
04:10:52 <Axioplase> indeed
04:10:54 <Axioplase> thanks !
04:15:02 <w-ber> Another day in the Haskell land: I want to measure how long it takes to execute a function (in an IO monad, specifically the main function). Which module or function should I look at and are there any caveats I should know about?
04:15:09 <w-ber> I'm statisfied with a granularity of 1 ms.
04:15:44 <dons> ?hoogle CPUTime
04:15:45 <lambdabot> CPUTime :: module
04:15:45 <lambdabot> CPUTime.cpuTimePrecision :: Integer
04:15:45 <lambdabot> CPUTime.getCPUTime :: IO Integer
04:16:03 <w-ber> Is that a standard module?
04:16:11 <dons> yep
04:16:21 <w-ber> Great, thanks.
04:16:26 <dons> import System.CPUTime
04:16:31 <dons> ?docs System.CPUTime
04:16:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-CPUTime.html
04:16:46 <dons> related is threadDelay and some things in Control.Concurrent
04:17:12 <w-ber> This is a sequential program (at least for now :).
04:17:21 <dons> you might also be interested in timing *out* computations, http://haskell.org/haskellwiki/Timing_out_computations
04:17:23 <lambdabot> Title: Timing out computations - HaskellWiki, http://tinyurl.com/ybwtnx
04:18:02 <w-ber> I might be later on, but for now I'm measuring the difference between two or three algorithms.
04:18:13 <w-ber> Or actually implementations of.
04:19:02 <SamB_XP> what are out computations?
04:19:40 <goltrpoat> cool, i just made ghci crash.
04:19:59 <goltrpoat> with unsafePerformIO (getCPUTime >>= \x -> let f = product [1..10000000000000] in (getCPUTime >>= \t -> return (f, t)))
04:20:04 <w-ber> SamB_XP: I don't know about out computations, but "timing out" computations means that you abort a computation after a given time if it hasn't finished.
04:20:09 <goltrpoat> makes sense, i guess.  that's a big number.
04:20:13 <SamB_XP> ah, yeah
04:20:20 <SamB_XP> I figured that out about when I hit enter
04:20:28 <w-ber> Parse error. :)
04:20:30 <SamB_XP> the *emphasis* was a bit confusing
04:21:49 <SamB> hmm, this program has been running for a long time...
04:22:04 <goltrpoat> i guess a) that's supposed to be t-x, and b) that doesn't exactly time it, in the strict, pardon the pun, sense of the word.
04:22:21 * SamB wonders if maybe finding *the* shortest blacknot solution is a bit over ambitious... 
04:23:13 <dons> w-ber: here, i had some code lying around: http://www.cse.unsw.edu.au/~dons/tmp/A.hs
04:24:57 <w-ber> dons: Thanks, although I had figured that out already. :)
04:25:37 <dons> good :)
04:26:21 <dons> it's been asked a few times, so now its on the wiki: http://haskell.org/haskellwiki/Timing_computations
04:26:24 <lambdabot> Title: Timing computations - HaskellWiki, http://tinyurl.com/ymkyaz
04:26:25 <dons> goltrpoat: hmm!
04:27:14 <w-ber> My number one irritation with Haskell to date is how show and read are named. I mean, now that I know what their names are, it's not an issue, but it was actually easier to write my own String to Int parsing function than to find read.
04:27:54 <dons> ?hoogle String -> a
04:27:55 <lambdabot> Prelude.error :: String -> a
04:27:55 <lambdabot> Debug.Trace.trace :: String -> a -> a
04:27:55 <lambdabot> Prelude.fail :: Monad m => String -> m a
04:28:00 <dons> ?hoogle+
04:28:01 <lambdabot> Prelude.read :: Read a => String -> a
04:28:01 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
04:28:01 <lambdabot> Control.Monad.Error.strMsg :: Error a => String -> a
04:28:04 <dons> close.
04:28:14 <dons> w-ber: ah well. now you know to ask here instead :) or use hoogle
04:28:44 <w-ber> Or someone could rename them to toString and fromString. :)
04:28:52 <dons> urgh :)
04:28:54 <thyko> hoogle?
04:29:09 <dons> ?hoogle a -> b -> [a] -> [b]
04:29:10 <lambdabot> No matches, try a more general search
04:29:21 <dons> ?hoogle (a -> b) -> [a] -> [b]
04:29:22 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
04:29:22 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
04:29:22 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
04:29:23 <thyko> nice
04:29:25 <dons> ?where hoogle
04:29:25 <lambdabot> http://www.haskell.org/hoogle
04:29:37 <ADEpt> dons: indeed, and it's not that small - recent haskell book (in russian!) is already pre-ordered in amount of 200 copies :)
04:29:48 <dons> oh cool!
04:29:55 <thyko> no kidding
04:30:19 <Syzygy-> @tell ibid Good Math Bad math at http://scienceblogs.com/goodmath has started running haskell posts. May be worth poking the author about inclusion in the planet.
04:30:20 <lambdabot> Consider it noted.
04:30:35 <dons> ADEpt: can you add details here please! http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
04:30:37 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
04:30:58 <goltrpoat> hoogle seems to have some issues btw..  compare http://haskell.org/hoogle/?q=Data.List to http://haskell.org/hoogle/?q=List
04:31:00 <lambdabot> Title: Data.List - Hoogle
04:31:10 <ADEpt> dons: as soon as it's out of printing house so i'll know ISBN and exact title
04:31:23 <goltrpoat> and http://haskell.org/hoogle/?q=%28%2B%29 to http://haskell.org/hoogle/?q=%2B
04:31:24 <lambdabot> Title: (+) - Hoogle
04:31:26 <dons> so we've got .jp x2 , .pt, .en, .es, and .ru books. good good
04:31:36 <dons> ADEpt: great. thanks
04:31:46 <dons> ADEpt: might be worth dropping a note to haskell@haskell.org too
04:32:09 <ADEpt> dons: i'll pinch author (darcus.livejournal.com)
04:32:26 <dons> thanks.
04:32:45 <dons> ADEpt: we should try to get more .ru guys into #haskell.ru
04:32:48 <dons> (and here!)
04:33:04 <dons> get them into the community.
04:33:21 <ADEpt> dons: sorry, wrong ref to author. It's http://users.livejournal.com/_darkus_/291851.html
04:33:23 <lambdabot> Title: _darkus_: Книга «Функциональное программирован ..., http://tinyurl.com/ylb35v
04:33:49 <dons> ah nice
04:34:14 <ADEpt> dons: they are already here :) (alar/nealar, and couple of other guys whose nick i cant remember offhand)
04:34:52 <dons> oh good :) and publicise #haskell.ru if you like
04:35:19 <ADEpt> dons: there is also haskell@conference.jabber.ru, which has a huuuge community of russian-speaking users (4 of them, to be exact), who migrated there from deteriorating haskell.ru :)
04:35:37 <dons> from the irc channel to jabber?
04:35:50 <ADEpt> dons: yep
04:36:10 <dons> ADEpt: oh, I didn't know that. perhaps there should be some details here: http://haskell.org/haskellwiki/IRC_channel#Related_channels
04:36:12 <lambdabot> Title: IRC channel - HaskellWiki, http://tinyurl.com/y34q33
04:36:15 <ADEpt> dons: last time I checked, I was the single person on haskell.ru
04:36:17 <dons> if people aren't using #haskell.ru
04:37:00 <dons> yeah, looks like lambdabot is the only one there now
04:37:03 <malcolm_> ping dons about fps patches again
04:37:12 <ADEpt> dons: will try to amend that, too. Recenty my "hobby time" had shrunk considerably (baby born), but it'll get back on track in a month or several years :)
04:38:05 <dons> oh wow. congratulations ADEpt
04:38:08 <dons> malcolm_: ack.
04:38:13 <ADEpt> dons: thnx
04:38:34 <psnl> ADEpt: congrats
04:42:25 <ADEpt> psnl: thnx
04:56:43 <rdivacky> hi.. what is the best way to sum an IOUArray?
04:57:21 <psnl> does it have a fold?
04:57:24 <skew> "best"?
04:57:48 <rdivacky> psnl: I dont think so
04:57:59 <dons> yeah, a fold.  write a fold over it. (maybe using unsafeRead)
04:58:27 <rdivacky> uh.. I somehow cannot imagine how to fold an IOUArray
04:58:54 <dons> its just a loop :)
04:58:56 <Axioplase> How can I define an infix operator ? isn't it   a (foo) b = blabla ?
04:59:31 <Igloo> x .+. y = whatever
04:59:38 <Igloo> Or (.+.) x y = whatever
04:59:44 <skew> how about  fmap sum (getElems arr)?
05:00:03 <rdivacky> I am unfamiliar with fmap
05:00:32 <dons> here's roughly the code:
05:00:33 <dons> foldl f v arr = go v 0
05:00:33 <dons>     where go !z !n | n == size_of_arr = return z
05:00:33 <dons>                    | otherwise        = do c <- unsafeRead arr n
05:00:33 <dons>                                            go (f z c) (n+1)
05:00:46 <rdivacky> I'd better use the fmap
05:00:49 <rdivacky> it looks better
05:00:54 <skew> fmap f action = do x <- action; return (f x)
05:01:09 <dons> is there an fmap for IOUArray?
05:01:16 <dons> > foldl' (+) 0 [1..10]
05:01:17 <lambdabot>  55
05:01:19 <rdivacky> dons: it compiles
05:01:23 <skew> IOUArray lives in IO, right?
05:01:30 <dons> and you'd have: foldl (+) 0 arr
05:01:34 <dons> using the above foldl
05:01:35 <skew> that's fmap for the monad around the result of getElems
05:01:43 <skew> not the array structure itself
05:02:02 <dons> ah yes.
05:02:18 <dons> rdivacky: so if the fmap works, use that. if its too slow, consider the above foldl
05:02:19 <rdivacky> ok.. thnx
05:02:31 <rdivacky> well.. this is just an school thing.. I dont worry about performance
05:03:53 <skew> getElems is not listed as a good producer, so you probably don't get all the nice list fusion
05:04:22 <dons> rdivacky: is perf isn't an issue, why're you using an IOUArray? ;)
05:04:29 <rdivacky> dons: I need mutable arrays
05:04:32 <skew> hey, dons is awake.
05:04:39 <dons> so not a Data.IntMap?
05:04:40 <rdivacky> and IOUArray seemed easy
05:04:48 <skew> why do you need mutable arrays?
05:04:57 <rdivacky> this is implementation of a neural network
05:05:02 <rdivacky> I need to update weights etc.
05:05:11 <rdivacky> seems natural to do it using mutable arrays
05:05:12 <dons> ok. maybe. Data.IntMap might still be cleaner
05:05:18 <dons> ?docs Data.IntMap
05:05:18 <ms_> list of IORefs ?
05:05:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
05:05:28 <dons> anyway, whatever works for you
05:05:37 <rdivacky> sure
05:05:37 <robreim> Out of curiousity, is this still the way cross-compilation happens with GHC? http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg08696.html
05:05:39 <lambdabot> Title: RE: Cross-Compiling with GHC?, http://tinyurl.com/ybml89
05:05:44 <dons> (I'd have tried Data.IntMap first, then if that wasn't working fast enough, try mutable arrays)
05:05:55 <rdivacky> the main point of using haskell is to obfuscate the program so it seems "difficult" so I get high score :)
05:06:01 <skew> or, maybe something under Data.Graph.Inductive?
05:06:02 <rdivacky> i really dont care about quality of the code
05:06:11 <dons> robreim: check the porting guide.
05:06:27 <robreim> Ah, good point. I'll go have a look for it.
05:06:39 <dons> its in the user's guide
05:06:45 <robreim> tah
05:07:03 <dons> rdivacky: to obfuscate? :} weird.
05:07:11 <dons> you could always run the result through @pl  then ;)
05:07:43 <rdivacky> dons: the prof doesnt speak haskell
05:07:46 <dons> ?. pl undo \f v arr n -> do c <- unsafeRead arr n; go (f z c) (n+1)
05:07:46 <lambdabot> const . flip (ap . ((>>=) .) . unsafeRead) . (. (1 +)) . flip . (go .) . ($ z)
05:07:58 <rdivacky> its a common trick here :)
05:08:02 <dons> oh heh
05:08:25 <dons> and you get more points for obfuscation?
05:08:28 <rdivacky> if I coded that in hebrew it would be even better, but hebrew doesn compile ;(
05:09:05 * dons wonders if newbies ever submit their haskell 1A assignments via @pl, just to show off...
05:09:07 <rdivacky> dons: the network is bloody simple so I would get low score if it was in C or something.. this way it looks like a big project
05:09:27 <dons> ok. just watch out you don't end up writing much less code...
05:09:39 <skew> I guess we'll refrain from giving you the one-liner then...
05:09:54 <ms_> doh! I was just gonna come up with the list comprehension... ;)
05:10:04 <resiak> dons: I used @pl during my FP course, actually
05:10:19 <dons> yeah? for good or for evil?
05:10:24 <resiak> dons: but I was only checking that my pointless version was actually the same as the pointy version having derived it myself.
05:10:38 <skew> rdivacky: what exactly are you updating? maybe some of the maps in Data.Graph.Inductive.Graph would be useful
05:11:17 <rdivacky> skew: the project is almost done (-debuging now)
05:11:22 <rdivacky> I am not going to rewrite that
05:11:25 <rdivacky> but thnx for the pointer
05:11:36 <skew> what are you doing to the neural networks?
05:11:49 <rdivacky> its simple hopfield network
05:11:57 <rdivacky> autoassociative network
05:12:09 <rdivacky> you give it a picture.. it learns.. then you damage the picture and it still recognizes that
05:12:27 <resiak> Hrm, what is the opposite of pointless/point-free?  It can't actually be pointy...
05:12:39 <dons> pointful?
05:12:46 <resiak> I guess so.
05:12:49 <dons> ?unpl const . flip (ap . ((>>=) .) . unsafeRead) . (. (1 +)) . flip . (go .) . ($ z)
05:12:50 <lambdabot> (\ o _ d ->
05:12:50 <lambdabot>   (\ ar -> (>>=) (unsafeRead d ar)) >>=
05:12:50 <lambdabot>    \ aj ->
05:12:50 <lambdabot>     (\ au j -> go ((o $ z) j) (1 + au)) >>= \ ai -> return (aj ai))
05:12:51 <rdivacky> hehe.. and it actually works ;)
05:12:53 <rdivacky> at first attempt
05:12:54 <dons> ppoints for all
05:13:00 <mux> the opposite of point-free is readable ;-)
05:13:06 <resiak> point-expensive
05:13:13 <dons> rdivacky: great
05:13:48 <rdivacky> dons: you dont want to see the code :)
05:14:11 <skew> for speed, maybe Data.Array.Parallel.Unlifed.Parallel.sumUP from ndp work is the way to go
05:16:42 <rdivacky> one more question.. when doing "case bah of" thing... is there anything like "default" in C?
05:16:51 <mux> ?where pqc
05:16:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/pqc.html
05:16:57 <mux> rdivacky: _
05:17:12 <rdivacky> thnx
05:17:15 <dons> skew: yeah
05:17:24 <rdivacky> hm.. gives me parse error
05:17:41 <mux> rdivacky: paste the code somewhere maybe?
05:17:59 <dons> > case 3 of 1 -> "yes" ; 3 -> "no" ; _ -> "maybe"
05:18:00 <lambdabot>  "no"
05:18:01 <skew> rdivacky: _ is just another pattern, but it matches anything
05:18:05 <rdivacky> ah.. missing "of" :(
05:18:29 <dons> > case 3 of 1 -> "yes" ; 3 -> "no" ; _default -> "maybe"
05:18:30 <lambdabot>  "no"
05:20:31 <w-ber> Hmm. Maybe I ought to consider memoization.
05:21:24 <w-ber> Not sure if it will help any, but I have a function that is used to repeatedly look up values from an array and check them out.
05:21:35 <w-ber> Often they have not changed. :)
05:21:47 <ibid> rdivacky: any pattern that matches anything (variable or _) will act as default if it is the last choice
05:21:47 <lambdabot> ibid: You have 1 new message. '/msg lambdabot @messages' to read it.
05:21:51 <ibid> hah
05:22:37 <ibid> Syzygy-: feel free :)
05:28:58 <w-ber> Any native speakers of English here? How exactly does one pronounce monad? I would say mon as in money and ad as in advertisement, but are there other ways?
05:29:31 <w-ber> Stress on mon.
05:29:40 <dons> or mo-nad
05:29:51 <Philippa> I mostly hear "moan-ad"
05:29:57 <Philippa> or moa-nad
05:29:58 <Itkovian> the same as gonad but with an m
05:30:16 <dons> Itkovian always wanted to offer that advice
05:30:17 <Itkovian> gōnad
05:30:30 <Itkovian> according to the macosx dict (oxford dictionary iirc)
05:31:21 <Itkovian> dons: Exactly! I've been staring at my screen for hours at end just to see if somebody would ask this.
05:31:39 <Philippa> it's easier to just work it into a pun instead
05:31:58 <w-ber> Don't be so case-sensitive, dylan. :)
05:32:28 <dylan> w-ber: I blame the script.
05:32:42 <thyko> :D
05:32:54 <dylan> it's not suppsed to confuse freenode and $private_ircnet
05:33:02 <Itkovian> of course, given Philippa her comment history on #-blah, the 'moan' was kind of expected too
05:33:06 <w-ber> Hmm, monad has been derived from the Greek word monos.
05:33:27 <Itkovian> w-ber: then it would be moh-nad?
05:33:55 <w-ber> http://www.dict.org/bin/Dict?Form=Dict2&Database=*&Query=Monad
05:33:58 <lambdabot> Title: dict.org- Monad, http://tinyurl.com/y9ddr9
05:34:04 <thyko> monad
05:34:34 <thyko> moan-ad, pliiz \:-/
05:35:08 <opqdonut> mow-ned
05:35:10 <w-ber> Well, I say some other words funnily, too, so I'll just add monad to that bunch.
05:35:32 <w-ber> Lawnmonad.
05:39:43 <w-ber> ?hoogle sql
05:39:43 <lambdabot> No matches found
05:39:54 <thyko> ?match
05:39:55 <lambdabot> Unknown command, try @list
05:39:57 <w-ber> Any modules to interact with SQL databases yet?
05:40:08 <thyko> ?thatch?
05:40:09 <lambdabot> Unknown command, try @list
05:41:18 <thyko> say, whats the Haskel compiler written in?
05:41:23 <thyko> ?compiler
05:41:23 <lambdabot> Unknown command, try @list
05:41:36 <alar> question about layout
05:41:50 <alar> can I state f x y = let on one line
05:41:55 <ms_> w-ber: haskelldb
05:42:03 <alar> and what's after let on the next?
05:42:13 <w-ber> http://darcs.complete.org/hdbc/doc/Database-HDBC.html
05:42:13 <ms_> w-ber: and associated stuff - hsql and hdbc
05:42:15 <lambdabot> http://tinyurl.com/rrers
05:42:49 <w-ber> Okay, the only reason now that I want to use Perl is Perl regular expressions.
05:42:51 <ms_> w-ber: haskelldb's quite good - really takes good advantage of the type checker. and no need to write sql either
05:44:02 <dons> ?version
05:44:02 <lambdabot> lambdabot 4p282, GHC 6.5 (OpenBSD i386)
05:44:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:44:17 <liyang> thyko: Haskell
05:44:23 <dons> thyko: most haskell compilers are written in Haskell
05:44:25 <Cale> w-ber: what do you think of parsec?
05:44:37 <w-ber> Cale: I know nothing about it; only seen the name.
05:44:54 <dons> thyko: as are a few others, http://haskell.org/haskellwiki/Libraries_and_tools/Compilers_and_interpreters
05:44:56 <lambdabot> Title: Libraries and tools/Compilers and interpreters - HaskellWiki, http://tinyurl.com/ye98mq
05:45:05 <Cale> w-ber: http://www.cs.uu.nl/~daan/parsec.html
05:45:23 <dons> there's also a regex-pcre binding now
05:45:35 <dons> if you really really need regexes (but people tend to use parsec instead)
05:45:43 <mux> mmm
05:45:45 <w-ber> Will check Parsec out, then.
05:45:50 <mux> I'm getting a "thread blocked indefinitely" error
05:45:59 <w-ber> I'm just used to think in regexps. :)
05:46:00 <dons> mux, MVars deadlocked?
05:46:09 <mux> dons: no more mvars, I'm using a chan now
05:46:09 <Cale> I'd almost always favour parsec over regexps.
05:46:26 <mux> dons: let me add this new method to the wiki
05:46:28 <dons> threads blocked on an empty Chan?
05:46:53 <Cale> Simply because it's easier to implement more complex grammars, and you have more control over how the result of parsing gets built.
05:47:22 <w-ber> Cale: What if I want to grep lines from a text file?
05:47:24 <dons> parser combinators are more fun than regexes anyway : you can writes parsers in them!
05:47:41 <dons> w-ber: then regexes are better :)
05:47:46 <dons> ?type filter
05:47:47 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:47:47 <dons> perhaps ;)
05:48:17 <Cale> It's reasonable to parse each line with a parser and see if it parses or not.
05:48:27 <Cale> (and yeah, use filter)
05:48:52 <Cale> If it's just a simple substring match, I probably wouldn't use parsec at that point
05:48:53 <mux> dons: http://www.haskell.org/haskellwiki/Concurrency_demos/Zeta#Using_a_Chan_instead_of_MVars
05:48:56 <lambdabot> Title: Concurrency demos/Zeta - HaskellWiki, http://tinyurl.com/to7qz
05:49:12 <Cale> I'd write something like isSubstringOf x y = any (isPrefixOf x) (tails y)
05:49:18 <Cale> and then filter the list using that
05:49:22 <Cale> (the list of lines)
05:49:41 <w-ber> Well, I can always think of alternative ways to replace regexps with, but there are some tasks where they are invaluable.
05:49:47 <mux> dons: with code shamelessly stolen from pqc ;-)
05:49:54 <mux> only slightly modified
05:50:25 <w-ber> Cale: Besides, Perl regexps are cool. :)
05:50:30 <mux> dons: oh, don't bother, found the problem
05:50:35 <mux> variable name confusion
05:50:48 <mux> let's see if it works now
05:50:56 <mux> yay it does :-)
05:51:01 <Cale> The only places where I really would prefer them is if I had a lot of small but separate and really distinct matchings to perform, because regexps are certainly less typing in those cases.
05:51:06 <mux> "i >= n" --> "i >= t"
05:51:10 <opqdonut> but for example syntax hilighting should be done with a real parser and not regexps
05:51:22 <opqdonut> single regexps work fine but multiple, no way
05:51:25 <dons> or lexer combinators/lexer
05:51:43 <dons> (which is often what parsec is used as)
05:51:45 <mux> dons: ok, it works now, comments appreciated
05:51:53 <w-ber> The idea of whipping up a grammar where you could simply use a regexp feels a tad complicated. :)
05:51:53 <mux> I'm going to benchmark it on my smp box
05:52:24 <opqdonut> w-ber: yes, but using a regexp where a grammar is needed is just stupid
05:52:30 <Cale> Usually though, you have either a lot of similar tasks (in which case, the fact that you can build parsers parametrically and dynamically with parsec is really good), or you have a large complex task, in which case, being able to write that as something which at least somewhat resembles a grammar is useful for maintainability.
05:52:32 <w-ber> opqdonut: I agree.
05:52:32 <opqdonut> e.g syntax coloring and url parsing
05:52:34 <dons> w-ber: sure. that's why you can use Text.Regex if you need it. but they tend to be few and far between in haskell for some reason
05:52:51 <w-ber> I'd rather not use any module labelled "Experimental". :)
05:52:53 <opqdonut> Cale: exactly
05:53:08 <dons> shrug. cautious community
05:53:15 <opqdonut> regex are nice for hacks and one-off things (like grepping)
05:53:24 <Cale> One thing which is really cool is the ability to build parsers from configuration data.
05:53:37 <w-ber> http://w-ber.ormgas.com/code/tagextract.pl
05:53:47 <w-ber> I wrote that once, but I don't understand anymore why it works.
05:53:57 <opqdonut> :)
05:54:04 <w-ber> Still, it looks cool. :)
05:54:10 <dons> heh
05:54:16 <dons> its the pointfree syntax of the perl world
05:54:23 <Cale> I used this in a program I wrote for my dad to parse musical chords (like "C# major seventh, flatted fifth")
05:54:29 <dons> where the parser is encoded as a string ... so not even any types in there
05:54:44 <Cale> The terms it knew about were totally configurable
05:55:03 <yuten> hi
05:55:09 <dons> that's a nice trick, Cale
05:55:13 <dons> ?users
05:55:13 <lambdabot> Maximum users seen in #haskell: 276, currently: 266 (96.4%), active: 40 (15.0%)
05:55:16 <wolverian> w-ber, aagh! use an xml parser! ;)
05:55:18 <dons> mm. geting there.
05:55:27 <w-ber> wolverian: Hey, I've never used that code anywhere. :)
05:55:29 <dons> hey yuten
05:55:35 <dons> how's the haskell at chalmers getting on?
05:55:36 <wolverian> w-ber, phew. :)
05:55:37 <yuten> how should i implement the while, if the statement is all monad
05:55:38 <mux> sucks :-(
05:55:43 <yuten> like IO
05:55:50 <dons> yuten: a while loop you mean?
05:55:55 <opqdonut> wolverian: xml? vade retro, satanus!
05:55:58 <mux> dons: it's not scaling better, running with 2 threads instead of 1 on my smp box makes it slower
05:56:05 <mux> damnit
05:56:07 <dons> yuten: also, we have a swedish channel, #haskell.se
05:56:14 <Cale> does anyone know if there's an extension for firefox to tell it "just treat this as text and load it in the browser"?
05:56:15 <dons> mux, you using +RTS -N2
05:56:18 <mux> yes
05:56:31 <Cale> (when it would otherwise want to download something)
05:56:37 <mux> ./zeta +RTS -N2 -RTS 2 100000 '2 :+ 0'
05:56:41 <dons> is the computation done by the threads long running enough?
05:56:42 <Cale> I always have this problem with haskell and other code
05:56:46 <yuten> dons: i am just a student who study in Sweden ~
05:56:57 <dons> yuten: yep I guess that :)
05:57:00 <dons> welcome!
05:57:10 <mux> dons: I'm thinking maybe I shouldn't use writeList2Chan
05:57:11 <dons> yuten: so you want to write a 'while' loop in some monadic code?
05:57:18 <dons> mux: hmm. perhaps
05:57:23 <yuten> dons: so, i don't unstand Swedish
05:57:27 <dons> ah right
05:57:29 <mux> dons: I suspect the threads are only writing the whole lists at once
05:57:29 <yuten> dons: yes~
05:57:43 <dons> yuten: mapM_ perhaps?
05:57:58 * mux nods
05:57:59 <dons> or write your own loop
05:58:06 <Cale> mapM_ may not cut it
05:58:10 <dons> mux, ok. you want it to be as lazy as possible
05:58:11 <Cale> We can write a while loop
05:58:30 <dons> while p a = when (not p) $ a >> while p a
05:58:33 <mux>       mapM_ (writeChan chan . Just) (zetaRange s range)
05:58:35 <mux> trying with that
05:58:37 <oT|Song> hey is anyone available to help a haskell beginner? :-)
05:58:55 <Cale> dons: ack! p won't change
05:59:02 <dons> hehe :)
05:59:15 <Cale> oT|Song: lots :)
05:59:50 <dons> yuten: so the idea is to write a loop that checks the condition
06:00:22 <Cale> whileM p a = do b <- p; if b then a >> whileM p a else return ()
06:00:51 <Cale> note that 'a' must do something which might affect the return value of 'p'
06:00:53 <mux> dons: ah. now it is very slightly better when I use two threads rather than once :-)
06:00:57 <dons> ok good
06:01:05 <Cale> If you want, we could also do something like this:
06:01:19 <mux> and a lot worse if I use 3 threads
06:01:21 <mux> cool!
06:01:26 <mux> finally, consistent results :-)
06:01:44 <Cale> whileM a = do (v,b) <- a; if b then whileM a else return v
06:02:04 <Cale> @type let whileM a = do (v,b) <- a; if b then whileM a else return v in whileM
06:02:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (a, Bool) -> m a
06:02:46 <Cale> So it takes an action which returns a value and a boolean flag, and repeatedly runs it until the flag is false, at which point it returns the value
06:03:01 <kolmodin> yuten: see #7 and #8 at http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/exercises.html
06:03:05 <lambdabot> Title: Advanced Functional Programming -- Exercises, http://tinyurl.com/ykqe65
06:03:13 <Cale> You could also do something with a condition on the return value...
06:03:23 <mux> dons: ok, I have updated the wiki's code. It would be cool if you could run some benchmarks on your multicore box
06:03:44 <Cale> whileM p a = do v <- a; if p v then whileM p a else return v
06:04:15 <Cale> yuten: So there's really a lot of options as to what sort of control structure you'd like to use :)
06:04:22 <oT|Song> Cale: are u free to help with some very basic haskell? :P
06:04:25 <ndm> anyone have a copy of safari to hand?
06:04:27 <w-ber> Is forall a GHC extension?
06:04:33 <Cale> w-ber: yeah
06:04:42 <ndm> w-ber: yes
06:04:48 <yuten> thanks all, i will look them, and i will think about it
06:04:55 <Cale> oT|Song: definitely, just ask your questions in the channel, and I, and most of the people here would be happy to help
06:04:59 <ndm> (some help testing the Yhc Javascript backend on safari would be appreciated, should only take a few seconds)
06:05:00 <liyang> oT|Song: just ask here. Most people here can help. :)
06:05:04 <oT|Song> ok cool
06:05:38 <Cale> w-ber: basically, it's just something which is implicit in Haskell 98, but there are some nice things about making it explicit sometimes, and GHC defaults to it. (It's not in H98 at all)
06:05:42 <oT|Song> well the question is, ive just started haskell, and the notes i have are very bad :P looked at a lot of tutorials online but cant find much... just wondering how i can compare 2 elements in a list
06:05:50 <Cale> okay
06:05:55 <Cale> compare as in < ?
06:05:56 <dons> visit http://haskell.org for tuts and docs
06:05:57 <lambdabot> Title: Haskell - HaskellWiki
06:06:14 <Cale> One of my favourite tutorials to recommend is YAHT
06:06:18 <Cale> @where yaht
06:06:19 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
06:06:32 <Cale> oT|Song: but could you describe your problem a little more?
06:06:46 <oT|Song> well whether they are equal or not
06:07:05 <Cale> okay, and you know that the list has two elements, or ...
06:07:30 <Cale> > let f [x,y] = x == y in f [2,3]
06:07:33 <lambdabot>  False
06:07:36 <Cale> > let f [x,y] = x == y in f [2,2]
06:07:37 <lambdabot>  True
06:07:59 <oT|Song> well its a list of random elements, and i gotta find out the length of the longest flat segment
06:08:06 <Cale> okay
06:08:22 <Cale> so if you're doing this recursively
06:08:25 <oT|Song> if i was doing it in java id use loops but
06:08:29 <oT|Song> i dunno how to do it in haskell at all :p
06:08:34 <Cale> then you'll want to compare things that are next to each other
06:08:45 <oT|Song> yep
06:08:52 <Cale> and so setting the base cases aside for a moment, you'll be looking at:
06:09:10 <Cale> flats (x:y:xs) | x == y = ...
06:09:19 <Cale>                | x /= y = ...
06:09:25 <w-ber> The manual of Happy has a real gem: "Like yacc, we include %% here, for no real reason."
06:09:31 <dons> > foldl1 (<) [1..10]
06:09:32 <lambdabot>  add an instance declaration for (Num Bool)
06:09:32 <lambdabot>   In an arithmetic sequence: [...
06:09:35 <Cale> (or you can use 'otherwise')
06:09:37 <oT|Song> i see
06:09:44 <dons> > foldl (<) True [1..10]
06:09:45 <lambdabot>  add an instance declaration for (Num Bool)
06:09:45 <lambdabot>   In an arithmetic sequence: [...
06:09:49 * dons goes to bed
06:10:13 <oT|Song> would i need to use tail at all?
06:10:19 <Cale> > maximum . map length . groups $ [1,1,2,2,2,2,3,1,2,3,2,2,4,4,4,4,4,4,1,2,1]
06:10:20 <lambdabot>  Not in scope: `groups'
06:10:25 <Cale> > maximum . map length . group $ [1,1,2,2,2,2,3,1,2,3,2,2,4,4,4,4,4,4,1,2,1]
06:10:26 <lambdabot>  6
06:10:54 <Cale> there's the really quick way to write that function, but you probably don't want to abuse the libraries at this point :)
06:11:04 <Cale> oT|Song: I think you can just pattern match
06:11:16 <Cale> you may need a helper function
06:11:24 <liyang> oT|Song: having matched a list on (x:t), you won't need to call tail anymore as you already have it (bound to the name t)
06:11:30 <mux> dons: nite
06:11:57 <Cale> which takes an extra parameter or two carrying along the longest string of equals so far, and the number of equal elements found in the current chain
06:12:06 <oT|Song> ah
06:12:53 <rdivacky> (1,2,3) is called "triple" ?
06:13:01 <Cale> rdivacky: yep
06:13:04 <Cale> a cleaner way to do it though would be to break it into two or three subproblems
06:13:06 <rdivacky> thnx
06:13:23 <Cale> one: break the list into groups
06:13:37 <Cale> where each group consists of elements that are all equal
06:13:44 <Cale> > group [1,1,2,2,2,2,3,1,2,3,2,2,4,4,4,4,4,4,1,2,1]
06:13:45 <lambdabot>  [[1,1],[2,2,2,2],[3],[1],[2],[3],[2,2],[4,4,4,4,4,4],[1],[2],[1]]
06:13:48 <Cale> like that
06:13:57 <oT|Song> i see
06:14:00 <Cale> two: compute the lengths of those groups
06:14:07 <Cale> three: compute the maximum of those
06:14:19 <oT|Song> so i should make a method to group equal elements ?
06:14:42 <roconnor> Are lambdas in italics or not?
06:15:10 <Cale> oT|Song: yeah :)
06:15:52 <oT|Song> ill give it a go, but since i only started today i dont think ill be able to :P
06:16:24 <Cale> well, let's give it a shot...
06:16:32 <Cale> first of all, the empty case :)
06:16:41 <Cale> group [] = ...
06:16:49 <Cale> well, there's nothing to group, right?
06:16:55 <oT|Song> ye
06:16:58 <oT|Song> ive got so far
06:17:02 <oT|Song> llfs [] = 0
06:17:30 <Cale> well, our grouping function is going to take a list, and return a list of lists
06:18:18 <oT|Song> ya
06:18:22 <Cale> so we probably want to return the empty list of lists there -- there are no groups of equal elements in the empty list
06:18:26 <Cale> group [] = []
06:18:30 <oT|Song> alrite
06:18:42 <oT|Song> how should i define the method
06:18:48 <Cale> this is a start :)
06:18:49 <oT|Song> like for llfs
06:18:50 <oT|Song> ive got
06:18:50 <oT|Song> llfs :: [Integer] -> Integer
06:18:58 <oT|Song> not sure what that means exactly but its in my notes :P
06:18:58 <Cale> oh, a type signature
06:18:59 <mux> is it possible to conditionally define a function depending on its existence in some module?
06:19:10 <mux> like, if I want to define forM_ for GHC < 6.6
06:19:26 <Cale> mux: no, but maybe you can use the C preprocessor for that
06:19:33 <Cale> oT|Song: okay
06:19:46 <Cale> group :: [Integer] -> [[Integer]]
06:19:59 <Cale> oT|Song: or if you want to get a little more sophisticated:
06:20:08 <Cale> group :: (Eq a) => [a] -> [[a]]
06:20:11 <w-ber> Cale: Okay, I have to agree after reading about Parsec's interface: I don't need regexps. :)
06:20:20 <Cale> w-ber: :)
06:21:37 <Cale> oT|Song: if you haven't run into that "(Eq a) => " bit before, what that means is "If a is a type for which we can compare values for equality..."
06:22:25 <Cale> but actually, we can leave the type signature off altogether, and the compiler will figure it out
06:22:59 <Cale> once you get used to them, it's a good idea to add them to your functions though, because they can help catch bugs, and also help improve the error messages when the compiler can't compile your file
06:23:14 <Cale> oT|Song: still with me?
06:23:24 <mux> Cale: does ghc --make run the C preprocessor by default or is there some option I can pass, or do I need to do it by hand in my Makefile?
06:23:48 <Cale> mux: I believe it's -cpp
06:23:56 <Cale> yes
06:24:18 <mux> thanks
06:24:27 <Cale> and snoop around in the documentation for GHC, I think there are some variables it sets which tell you the version
06:24:37 <mux> I expect GHC_VERSION :)
06:24:45 <Cale> probably :)
06:26:53 <w-ber> Cale: ParsecExpr is just "wow!".
06:27:22 <Cale> :)
06:27:50 <w-ber> I never knew what I really wanted to have was Parsec. :)
06:28:20 <Cale> and ParsecExpr is really more of an example of what you can do with Parsec rather than just part of the library
06:28:21 <mux> too bad Parsec.Language is kinda limited
06:28:45 <w-ber> I'll see if I can rewrite some of my Perl code in Haskell and if I can, how it will turn out.
06:29:22 <Cale> one thing which you want to be careful of is left-recursion, it's still an issue, but usually chainl is exactly what you want.
06:30:11 <w-ber> Yes, so the documentation says.
06:30:13 <Cale> that is, if the first thing a parser does is call itself with no changes in parameters or anything, you're in an infinite loop :)
06:31:13 <Cale> but yeah, mostly, it's fairly nice -- there's also the thing you have to be careful about lookahead, but 'try' helps there, and so does writing a separate tokenising stage if it really becomes an issue
06:32:00 <Cale> most of the time though, you don't really need to make the stages really separate in any way but logical code separation, and you just use the smaller parsers to build larger ones
06:32:42 <w-ber> Learning Haskell and the available modules might hurt my studies, though. :) Seems like every document spans at least two new ones to read.
06:32:50 <mux> Cale: I'd be happy to hear your comments on http://www.haskell.org/haskellwiki/Concurrency_demos/Zeta
06:32:53 <lambdabot> Title: Concurrency demos/Zeta - HaskellWiki, http://tinyurl.com/to7qz
06:33:11 <oT|Song> sorry Cale had to go afk, landlord came over :P
06:33:17 <Cale> There are also neat libraries like ReadP and Parsek (with a k) which eliminate the whole issue with <|> being asymmetric and readahead, and eliminate 'try', at the cost of a little efficiency.
06:33:23 <Cale> oT|Song: ah
06:33:43 <Cale> mux: cool :)
06:34:11 <mux> Cale: would you say my haskell code "is not too shabby"?
06:34:15 <oT|Song> i have no idea what (Eq a) => [a] -> [[a]] is so ill just use [Integer] -> [[Integer]]
06:34:18 * mux likes to reuse the ICFP terms :-)
06:34:29 <Cale> oT|Song: okay :)
06:34:38 <Cale> oT|Song: I explained it a little there
06:34:46 <Cale> Have you seen type variables before?
06:34:51 <oT|Song> nope
06:34:56 <Cale> mux: yeah, it looks pretty decent
06:35:02 <Cale> oT|Song: Well, okay
06:35:03 <mux> cool, thanks
06:35:09 <oT|Song> is it a lot easier to use (Eq a) => [a] -> [[a]]
06:35:25 <oT|Song> is it more efficient than using [Integer] -> [[Integer]]
06:35:27 <Cale> oT|Song: well, that means that you don't have to use the group function with lists of integers
06:35:31 <Cale> you can use it with anything
06:35:35 <mux> I think I passed the "haskell uber-noob" step
06:35:36 <Cale> the efficiency doesn't change
06:35:44 <mux> I'm now a "haskell beginner"
06:35:46 <mux> :-P
06:35:46 <oT|Song> i see
06:35:53 <roconnor> zarvok: hi
06:36:04 <Cale> well, you'll be able to use it with any type where you can compare the elements of that type for equality
06:36:12 <oT|Song> ah
06:36:21 <Cale> That's what the (Eq a) => means
06:36:22 <oT|Song> well, does the code change depending on which 1 of the 2 that i use?
06:36:26 <Cale> nope
06:36:28 <oT|Song> ok
06:36:39 <Cale> in fact, if you leave the type signature off, the compiler will infer the general one
06:36:46 <oT|Song> i c
06:37:03 <mux> yeah but it spouts warnings!
06:37:07 <mux> I'm obsessed with warnings
06:37:41 <oT|Song> so now back to the old problem of comparing elements and grouping them! :P
06:37:44 <Cale> (well, at least, usually, there are some complicated rules about defaulting and the monomorphism restriction and crap, but they're language spec wart issues you can ignore until it becomes a problem :)
06:37:48 * DebolazX slaps mux with a battlefish
06:38:13 <Cale> So okay
06:38:24 <Cale> We've decided  group [] = []
06:38:24 <vincenz> Cale: what's ParsecExpr
06:38:33 <oT|Song> ya
06:38:38 <Cale> vincenz: it's a module for building expression parsers automatically
06:38:56 <Cale> oT|Song: lists of length one are also easy to handle, and we'll do them separately
06:39:04 <w-ber> mux: So don't use -Wall. :P
06:39:09 <dons> mux, oh, btw, you probably should have forkIO (putMVar mvar $! zetaRange s range)
06:39:19 <mux> dons: as said in the talk page?
06:39:19 <dons> its almost always what you want
06:39:21 <oT|Song> alrite
06:39:23 <Cale> they just have one group, and it's the original list
06:39:24 <w-ber> dons is sleep-IRCing?
06:39:26 <dons> mux, right
06:39:26 <Cale> group [x] = [[x]]
06:39:31 <mux> dons: ok, I'll change this
06:39:34 * dons `finally` sleep
06:39:37 <mux> good nite :)
06:39:45 <dons> ?type Control.Exception.finally
06:39:51 <lambdabot> forall a b. IO a -> IO b -> IO a
06:40:15 <dons> ?type \dons sleep -> dons `Control.Exception.finally` sleep
06:40:17 <lambdabot> forall a b. IO a -> IO b -> IO a
06:40:24 <dons> ok. all's well. night!
06:40:31 <mux> dons: you know, that might totally explain why the MVar code wasn't being able to utilize extra CPUs
06:40:50 <Cale> oT|Song: let me think about how I want to present this -- there's the direct recursion route, and the route where we write one more intermediate function and it's a little clearer :)
06:41:00 <oT|Song> ok :)
06:41:01 <Cale> maybe you can decide :)
06:41:10 <oT|Song> i always get confused with recursion
06:41:16 <Cale> so one function which would be really handy
06:41:20 <oT|Song> yep
06:41:39 <Cale> is called span in Haskell -- basically, it takes a list and a condition
06:41:51 <Cale> and it hands you a pair of lists
06:42:12 <Cale> the first list is a bunch of elements which satisfy the condition, up until the first one which didn't
06:42:17 <Cale> the second is the rest
06:42:40 <oT|Song> alrite
06:42:45 <oT|Song> where can i look this up?
06:42:50 <oT|Song> like an API or something
06:42:55 <Cale> Well, it's in the Data.List library
06:42:58 <Cale> but we'll write it
06:43:03 <mux> dons: looks like putMVar could actually use bang patterns
06:43:10 <mux> or we could have putMVar!
06:43:14 <vincenz> mux: he left
06:43:19 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html -- this one :)
06:43:20 <mux> are '!' signs allowed in identifiers?
06:43:22 <lambdabot> http://tinyurl.com/wfo7q
06:43:28 <mux> vincenz: yeah but sometimes he's just lying :-D
06:43:37 <vincenz> mux: we shouldn't tempt him
06:43:40 <mux> heh.
06:43:44 <oT|Song> ye just found it :)
06:43:45 <Cale> so for example...
06:43:47 <vincenz> The man needs sleep
06:43:58 <Cale> > span (== 1) [1,1,1,2,3,1,2,1,4]
06:44:03 <lambdabot>  ([1,1,1],[2,3,1,2,1,4])
06:44:15 <vincenz> Ever get the impression that Oleg already did all the research you had planned to do?
06:44:33 <Cale> so...
06:44:35 <oT|Song> but how do i know the condition
06:44:41 <oT|Song> (==1)
06:44:42 <vincenz> Cale++
06:44:58 <oT|Song> do i just take like the first element as the condition
06:44:58 <Cale> oT|Song: well, we're going to know the first element of the nonempty list
06:45:02 <oT|Song> ya
06:45:43 <Cale> group (x:xs) = let (ys,zs) = span (==x) xs in ...
06:46:09 <Cale> that'll be the general tactic to start off with
06:46:20 <Cale> we chop up the rest of the list based on the first element
06:46:41 <oT|Song> alrite
06:46:45 <Cale> let's write span
06:46:45 <oT|Song> whats let (ys,zs) do?
06:47:11 <Cale> oh,   let <declarations> in <expression>
06:47:27 <Cale> lets you declare local definitions
06:47:41 <oT|Song> ah ok
06:47:49 <Cale> so we're defining (ys, zs) as the result of evaluating span (== x) xs
06:48:06 <Cale> and that'll pattern match and make ys and zs available in the 'in' part
06:48:21 <Cale> (and in fact, in the rest of the 'let' part, if there was any more to it)
06:48:25 <oT|Song> ok
06:48:39 <Cale> if you've seen 'where', this is exactly the same
06:48:43 <oT|Song> this seems like a complicated way of doing it :P
06:49:08 <Cale> well, I'm breaking things up into subproblems until I get to the primitives which I'd really use in Haskell programming
06:49:16 <oT|Song> i c
06:49:27 <oT|Song> well im just wondering, if it would be easier to use some kind of loop
06:49:28 <Cale> these things are actually in the library, so I figure it's best to get to know them as soon as possible
06:50:02 <Cale> really, if I was confronted with your original problem, I'd write  longestGroup = maximum . map length . group
06:50:24 <mux> the haskell colouring code in the wiki needs massive fixing
06:50:36 <oT|Song> youd just write that line of code and itd be done? :P
06:50:39 <Cale> yeah
06:51:06 <Cale> or possibly  longestGroup = foldr max 0 . map length . group, if I wanted it to work with empty lists.
06:51:25 <oT|Song> i see
06:51:33 <Cale> (or I might make that a foldl' if I really cared about efficiency)
06:51:36 <oT|Song> well im guessing i should probably write a longer bit of code
06:51:40 <Cale> okay
06:51:49 <oT|Song> but is there a way of using loops
06:51:54 <Cale> so what I'm trying to take you through is how to build up that way of thinking about it
06:51:56 <oT|Song> and storing the longest flat segment so far
06:51:57 <oT|Song> ok
06:52:09 <Cale> so if we had functions which did those things
06:52:12 <Cale> then we'd be done
06:52:28 <Cale> but we don't, so eventually, we're going to have to resort to recursion
06:52:38 <oT|Song> i c
06:52:42 <Cale> but hopefully the recursion will be some really easy thing
06:52:51 <Cale> and I think span is probably simple enough to write :)
06:52:58 <oT|Song> :)
06:54:00 <Cale> span p [] is the first case
06:54:09 <Cale> in that case, we just return ([], [])
06:54:21 <Cale> span p [] = ([], [])
06:54:32 <Cale> because there are no elements to distribute to either part
06:54:39 <oT|Song> right
06:54:41 <Cale> now, the interesting case...
06:54:49 <Cale> span p (x:xs)
06:55:07 <Cale> do you know about guard syntax, or would you be more comfortable with if/then/else?
06:55:12 <oT|Song> if then else
06:55:14 <Cale> okay
06:55:20 <oT|Song> ive never even heard of guard syntax :P
06:55:28 <Cale> that's the syntax with |
06:55:36 <Cale> we'd write
06:55:37 <oT|Song> oh
06:55:48 <Cale> span p (x:xs)
06:55:51 <oT|Song> guard syntax is ok
06:55:59 <Cale>    | p x = ...
06:56:06 <Cale>    | otherwise = ...
06:56:31 <oT|Song> so whats the | p x bit mean
06:56:33 <Cale> because we want to do something different depending on whether p is true with the first element or not
06:56:38 <oT|Song> ah
06:56:53 <Cale> that means apply p to x and because it's a guard, it's going to evaluate to True or False
06:57:04 <Cale> p is a function, remember
06:57:09 <oT|Song> yep
06:57:35 <Cale> so if p x is true
06:57:46 <Cale> we want to add x to the first list
06:58:03 <Cale> for now, I'll just write:
06:58:14 <Cale>    | p x = (x:ys, zs)
06:58:27 <Cale> we'll figure out what ys and zs really are later
06:58:41 <oT|Song> alrite
06:58:58 <Cale>    otherwise, what do we return?
06:59:23 <Cale> suppose we call  span p (x:xs), and p isn't even true for x, what do we want that to be?
06:59:47 <oT|Song> hmm
06:59:52 <oT|Song> would we start a new list
06:59:54 <oT|Song> well
06:59:57 <oT|Song> add a list to the list
07:00:06 <Cale> remember we're returning a pair of lists
07:00:34 <Cale> the first is supposed to be the first elements of the list which p returns True for, up until the first failure
07:00:40 <Cale> and the second is the rest of the lis
07:00:41 <Cale> t
07:00:55 <oT|Song> well
07:01:05 <oT|Song> im not quite sure how (x:ys, zs) works
07:01:11 <oT|Song> does it just add x to the first list?
07:01:24 <Cale> well, we still need to define ys and zs
07:01:34 <oT|Song> :(
07:01:40 <Cale> perhaps I should reveal the thinking behind this in another way :)
07:01:42 <Cale> okay
07:01:53 <Cale> suppose we're working out span p (x:xs)
07:02:06 <Cale> and our friend comes along and hands us the solution to span p xs
07:02:18 <Cale> and let's call the solution (ys,zs)
07:02:28 <Cale> then what would we return?
07:02:51 <oT|Song> (ys, zs) ?
07:03:08 <Cale> well, we want to add x into the first list, right?
07:03:14 <oT|Song> oh
07:03:24 <oT|Song> ye i guess
07:03:44 <Cale> so we can do the delegation to our friend in the where clause
07:03:48 <Cale> and write:
07:03:56 <Cale>   where (ys, zs) = span p xs
07:04:15 <Cale> and then that solution will be available to us :)
07:04:19 <oT|Song> ah
07:04:22 <oT|Song> whats the where clause about
07:04:26 <oT|Song> since its not in my notes at all :S
07:04:30 <Cale> well, it's just like let
07:04:35 <Cale> we could also use let
07:04:58 <Cale> the difference is that a single 'where' scopes over multiple guards, and it also comes afterward
07:05:09 <oT|Song> oh
07:05:13 <Cale> so we could write it like this:
07:05:33 <Cale>   | p x = let (ys, zs) = span p xs in (x : ys, zs)
07:05:55 <Cale> or we could leave the definition of (ys, zs) until the end
07:05:57 <mux> so, am I right in thinking tht the difference between let and where is that let allows you to reference variables that are out of the scope of what you're defining?
07:06:19 <Cale> hmm? where is translated into let
07:06:35 <Cale> but it happens outside the scope of any guards
07:06:40 <oT|Song> this is looking even more complicated every second :(
07:06:40 <mux> hmmm
07:06:48 <Cale> okay
07:06:50 <Cale> sorry :)
07:06:58 <Cale> this isn't supposed to be so bad
07:07:09 <Cale> let's just quickly put the solution down and I'll explain it
07:07:14 <mux> man, I would have loved to have Cale as a haskell teahcer
07:07:17 <Cale> span p [] = ([], [])
07:07:23 <Cale> span p (x:xs)
07:07:32 <Cale>   | p x = (x:ys, zs)
07:07:43 <Cale>   | otherwise = ([], x:xs)
07:07:55 <Cale>  where (ys, zs) = span p xs
07:08:12 <Cale> okay
07:08:16 <Cale> so what that says:
07:08:17 <oT|Song> ya
07:08:22 <Cale> if p x is true
07:08:36 <Cale> the result is (x:ys, zs)
07:08:52 <Cale> where (ys,zs) was the solution to the smaller problem: span p xs
07:09:19 <Cale> otherwise, the result is a pair with the empty list and the whole list
07:09:25 <Cale> because nothing matched
07:09:32 <oT|Song> yep
07:09:46 <Cale> So I hope that makes it all clear :)
07:09:53 <oT|Song> a little bit :P
07:10:01 <oT|Song> just got no idea how to link this with the rest of what i have
07:10:06 <Cale> okay
07:10:17 <Cale> so now, remember we were writing group
07:10:30 <alexj__> @seen shapr
07:10:30 <lambdabot> I saw shapr leaving #haskell-blah, #scannedinavian, #haskell and #ScannedInAvian 7h 31m 46s ago, and .
07:10:35 <Cale> this gives us a really easy way to pull off the first group
07:10:55 <Cale> and it hands us the rest of the list, which we'll need because we want to continue with finding the rest of the groups
07:11:04 <oT|Song> ye
07:11:11 <Cale> so we have:
07:11:16 <Cale> group [] = []
07:12:12 <Cale> group (x:xs) = (x:firstGroup) : group rest
07:13:02 <Cale> where firstGroup is the rest of the things which match x, and rest is the rest of the list, and we're going to group that up
07:13:09 <oT|Song> i c
07:13:13 <Cale> so:
07:13:26 <Cale>   where (firstGroup, rest) = span (==x) xs
07:13:49 <Cale> This is basically always the way that we think about things
07:14:01 <oT|Song> :|
07:14:06 <Cale> How do I break this problem down into a smaller problem which is the same type?
07:14:16 <Cale> I want a list of all the groups
07:14:49 <Cale> If I could get hold of the first group somehow, and the rest of the list, then I'd just have to get the rest of the groups
07:14:58 <oT|Song> ya
07:15:22 <oT|Song> to be fair, all this grouping stuff seems way above my level
07:15:25 <Cale> okay
07:15:39 <oT|Song> although ive got no idea how to do it how i want to, with loops
07:15:42 <Cale> okay
07:15:53 <Cale> so maybe writing it as a sort of loop would actually be helpful
07:16:06 <oT|Song> it would be a lot easier for me to understand :)
07:16:15 <Cale> okay
07:16:31 <Cale> so then we only need to work with numbers, and there's only one list to worry about breaking down :)
07:16:41 <Cale> okay
07:16:45 <oT|Song> yup :)
07:17:08 <Cale> so what you do in these cases, is realise that you want to keep track of the longest chain so far and the length of the chain that you're on
07:17:28 <Cale> and write a new function with a couple extra parameters which hold those values
07:17:28 <oT|Song> ya
07:17:31 <Cale> so
07:18:04 <Cale> longestChain' best current xs
07:18:17 <Cale> will be the general shape
07:18:34 <oT|Song> whats the longestChain' bit about
07:18:37 <oT|Song> the '
07:18:46 <ndm> @seen dcoutts
07:18:46 <lambdabot> dcoutts is in #haskell.hac07, #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 11h 51m 20s ago.
07:18:50 <Cale> well, we're really trying to write longestChain
07:19:07 <Cale> the ' is an indicator that this is not quite that function, but closely related :)
07:19:13 <oT|Song> oh
07:19:22 <oT|Song> is it not possible to have like
07:19:22 <Cale> (it's just a naming convention)
07:19:36 <oT|Song> a parameter that just stores it so u can keep adding 1 to that parameter
07:19:49 <Cale> well, that's what we're setting up
07:19:53 <oT|Song> i see
07:20:06 <Cale> Everything in Haskell is a constant
07:20:51 <w-ber> Well, not inside a monad...
07:20:56 <Cale> (at least until you reach a certain level of sophistication, and then you learn about monads and all that, and even then, it's just a simulation)
07:21:09 <oT|Song> :|
07:21:35 <Cale> Functions in Haskell are real mathematical functions
07:21:56 <Cale> If f 5 = 20, then it'll always be 20
07:22:01 <vegai> afternoon
07:22:13 <oT|Song> alrite
07:22:29 <Cale> This actually makes things easier to reason about once you're used to programming with it
07:22:37 <Cale> because you only have to debug things once :)
07:22:49 <oT|Song> cool
07:22:57 <w-ber> The bad thing is that you don't want to use languages with implicit state after using Haskell for a while, so beware! :)
07:23:22 <vincenz> "< Cale> Everything in Haskell is a constant" => For instance Cale is a constant
07:23:40 <w-ber> @type Cale
07:23:42 <lambdabot> Not in scope: data constructor `Cale'
07:23:47 <Philippa> Cale is a constructor, no?
07:23:48 <Cale> right, you can't store a new value in x just like you can't decide to store a new value in Cale :)
07:24:10 <Cale> I won't have it :)
07:24:12 <Cale> hehe
07:24:25 <Cale> So what do you do when you have a parameter which varies?
07:24:31 <sjanssen> writeIORef Cale undefined
07:24:35 <Cale> Well, you make it a parameter to a function
07:25:05 <Cale> and then that function might be called with different values
07:25:18 <Cale> or it might even call itself in a loop with different values for that parameter
07:25:39 <Cale> does that make some sense?
07:25:43 <oT|Song> lol
07:25:45 <oT|Song> completely lost me there
07:25:48 <Cale> okay
07:26:27 <Philippa> f 1 = 42 always, but f 2 might be something else
07:26:34 <Philippa> that make sense?
07:26:34 <Cale> Let's start off with something simple, let's compute the length of a list with this tactic. You actually don't have to do it this way, there's a better way, but this will get the idea across, and then we can do your more complicated example.
07:26:49 <oT|Song> isnt there a command
07:26:54 <oT|Song> just length
07:26:57 <Cale> yes
07:26:58 <oT|Song> that returns the length of a list
07:27:02 <Cale> right
07:27:04 <vincenz> Cale: you love teaching don't you?
07:27:07 <Cale> I do :)
07:27:11 <vincenz> Cale++
07:27:12 * yaarg was just thinking that :)
07:27:16 <yaarg> Cale++
07:27:22 <Cale> But length is an easy function to write, and so it makes a good example
07:27:44 <cjay> Cale++ won't work, he is immutable!
07:27:54 <vincenz> cale is monadic
07:28:02 <cjay> oh, ok :)
07:28:09 <oT|Song> :@
07:28:20 <w-ber> Actually, we are all inside a monad.
07:28:26 <Cale> How would you do it in an imperative language? One way would be to set a variable to 0, and loop over the list incrementing that variable until you reached the end
07:28:27 <w-ber> The World, you see.
07:28:36 <oT|Song> yup
07:28:38 <Cale> So we're going to translate that directly into Haskell
07:28:58 <Cale> length xs = length' 0 xs
07:29:12 <Cale> length' will take an extra parameter which is the length so far
07:29:18 <Cale> length will initialise it with 0
07:29:46 <Cale> now, length' is going to call itself over and over and update that
07:30:00 <Cale> but with shorter and shorter lists, until it reaches the end
07:30:11 <Cale> and that will be our loop
07:30:16 <oT|Song> i c
07:30:19 <Cale> length' n [] = n
07:30:28 <Cale> if there are no more elements, we'll return the final count
07:30:44 <Cale> length' n (x:xs) = length' (n+1) xs
07:30:56 <Cale> this is the interesting bit
07:31:13 <w-ber> You could simply call it recursion, Cale. :)
07:31:25 <LoganCapaldo> tail recursion!
07:31:33 <w-ber> With an accumulator.
07:31:37 <Cale> right
07:31:43 <Cale> That's what this is called :)
07:31:50 <vincenz> We should start a
07:31:54 <vincenz> #learn_from_Cale channel
07:31:56 <Philippa> w-ber: that assumes the person you're describing it to doesn't need... well, a description
07:32:14 <w-ber> Philippa: True.
07:32:20 <Cale> oT|Song: is it clear how that's working, or does it need more explanation?
07:32:23 <Cale> let's run it
07:32:28 <Cale> length [1,2,3]
07:32:33 <Cale> = length' 0 [1,2,3]
07:32:43 <oT|Song> im just reading it over and over
07:32:47 <oT|Song> seeing if i can understand it
07:32:52 <Cale> = length' (0+1) [2,3]
07:32:59 <Cale> = length' (0+1+1) [3]
07:33:06 <Cale> = length' (0+1+1+1) []
07:33:11 <Cale> = (0+1+1+1)
07:33:13 <Cale> = 3
07:33:20 <w-ber> Cale++
07:34:05 <Cale> and because I'm lazy, I didn't even do the addition until I really found out I had to there :)
07:34:08 <w-ber> (As an aside, why do we use an increment operator from C in a Haskell channel?)
07:34:23 <mux> habits :)
07:34:46 <Philippa> because we know what it means and the haskell version'd be a PITA
07:34:55 <moonlite> w-ber: what we really should do is let Cale be the State of #haskell
07:34:59 <oT|Song> well Cale, thx for all the help but i really gotta take a break :P
07:35:04 <vincenz> Philippa: you mean like:
07:35:05 <Itkovian> perhaps we should pre-increment
07:35:07 <Itkovian> ++Cale
07:35:09 <moonlite> so we could type modify (+1) instead
07:35:13 <Philippa> vincenz: not legal atm
07:35:15 <Cale> oT|Song: okay, try to understand that first :)
07:35:18 <mux> type #haskell = Reader Cale
07:35:18 <vincenz> modify Philippa (=1)
07:35:20 <oT|Song> ill read up on tutorials online later and see if i can learn anything else
07:35:22 <Cale> oT|Song: and I think it will help lots
07:35:23 <oT|Song> i may well be back :)
07:35:24 <oT|Song> ok
07:35:34 <Cale> oT|Song: make sure you do :)
07:35:34 <vincenz> Philippa: huh?
07:35:46 <Cale> oT|Song: (come back)
07:35:50 <oT|Song> ok :)
07:35:51 <mux> @karma+ Cale
07:35:52 <Philippa> sorry, got you mixed up with a following line
07:35:52 <lambdabot> Cale's karma raised to 30.
07:36:04 <Philippa> ++Cale wouldn't be legal haskell
07:36:12 <vincenz> sure it would
07:36:16 <vincenz> it's a slice
07:36:26 <Philippa> and thus can't have the right meaning
07:36:28 <mux> (++) Cale
07:36:42 <eviltwin_b> a slice of a constructor?
07:36:59 <Cale> apparently, I'm a list now
07:37:16 <mux> you're polymorphic
07:37:22 <mux> does it hurt?
07:37:26 <w-ber> I thought we agreed that Cale is a monad.
07:37:31 <vincenz> list is a monad
07:37:33 <Cale> We'll have to start instructing students that lists have three constructors, Nil, Cons, and Cale
07:37:39 <moonlite> :D
07:37:42 <w-ber> Haha.
07:40:49 <w-ber> Hm, so do you think oT|Song got what he wanted in the end?
07:42:55 <yaarg> -!- oT|Song [n=rtm01@host-87-75-166-63.bulldogdsl.com] has joined #java
07:43:05 * yaarg jokes
07:46:45 <Cale> w-ber: I don't know, but he seems not all that familiar with recursion, breaking some of my usual initial assumptions about programmers who are deciding to start in on Haskell. I'm thinking if he figures out that example, that might be enough.
07:47:56 <w-ber> Enough for...?
07:48:11 <Cale> enough for him to be able to solve his original problem
07:48:23 <w-ber> Not being familiar with recursion is very common among programmers, but I can't say if that applies to people who want to learn Haskell.
07:48:49 <Philippa> a large proportion of learners've either come from another FPL or had some exposure at uni
07:48:59 <eviltwin_b> usually people don't try to *start* with haskell...
07:49:25 <w-ber> They should, really. Unlearning redundant concepts is the hardest task in learning Harkell.
07:49:27 <w-ber> *Haskell
07:50:16 <w-ber> Philippa: Well, I've been imperative for the whole time I have programmed, although I knew "things" about functional programming well before I began reading Haskell tutorials.
07:50:38 <w-ber> I've dabbled with Lisp in the past, but almost all my FP knowledge has been theoretical.
07:50:48 <Philippa> that counts as "some exposure" still
07:50:55 <w-ber> True, it does.
07:51:42 <norpan> first you unlearn stuff then you have to relearn them again to understand why your haskell program is so slow :)
07:51:44 <yaarg> doesn't everyone come across a recursive solution to towers of hanoi at /some/ point
07:51:51 <yaarg> ?-)
07:51:52 <lambdabot> Maybe you meant: . bf ft id pl v wn
07:52:06 <norpan> lambdabot: i'm sure that's what he meant
07:53:53 <w-ber> Recursion isn't natural in the sense that imperative programs are "intuitive": In an imperative program, you have a list of things that need to be done in order, and you can repeat some or several things in a row. Recursion in an imperative program (in the intuitive sense) is abnormal.
07:54:13 <Philippa> w-ber: I'm not convinced
07:54:26 <w-ber> I'm not either, but that's an explanation. :)
07:54:48 <Philippa> seems to me that's an artefact of older imperative languages that were rather more influenced by the hardware
07:54:52 <yaarg> people are just lazy to think about what's going on with recursion
07:55:28 <w-ber> I don't think you can attribute it to laziness in the general case.
07:55:52 <yaarg> well the above statement is routed in experienced
07:56:09 <norpan> some things are best understood imperatively, and som things are best understood recursively
07:56:11 <yaarg> i've watched people not be bothered to work out how a recursive program executes in their head
07:56:19 * yaarg shrugs
07:56:33 <w-ber> I've watched people struggle with recursion but not getting it.
07:56:38 <Cale> and it's true, most of the time, you really *don't* want to think about general recursion, even (and perhaps especially) in Haskell.
07:56:47 <w-ber> Even though they were shown examples of how recursion works.
07:57:00 <norpan> you certainly don't want to think about the exact evaluation order sometimes
07:57:22 <yaarg> i think that's necessary to gain an intuitive understanding
07:57:23 <Cale> But you do need to get at least enough in that you can put together your basic tools.
07:58:20 <yaarg> also it's helpful to show the magic is the same as induction
07:58:25 <Cale> and of course, there are times when it's just pretty-well unavoidable
07:58:47 <Cale> yeah, induction and recursion are like two dual processes working together :)
07:59:39 <w-ber> I can still remember the time when I couldn't fathom why inductive proofs were proof of anything. :)
07:59:51 <w-ber> I was not alone, mind you.
08:00:46 <yaarg> i think that's because it's a topic that's often presented too informally at first
08:01:02 <yaarg> "we then procede..."
08:01:05 <yaarg> etc
08:05:59 <vegai> http://www.codinghorror.com/blog/archives/000734.html
08:06:45 <lambdabot> Title: Coding Horror: This Is What Happens When You Let Developers Create UI, http://tinyurl.com/y6bajp
08:08:52 <w-ber> Reminds me of some articles over at http://thedailywtf.com.
08:09:19 <kpreid> vegai: looks like a direct conversion of the command line options
08:10:27 * yaarg guesses that's the vista thing from joelonsoftware
08:10:42 <yaarg> oh no
08:10:48 <cjay> wget has far more options
08:11:27 <yaarg> i don't know if that interface is even /so/ bad
08:12:56 <w-ber> I've seen worse, but I don't want to talk about them. :)
08:21:14 <paolino> I'd like to use haskell for a  simulation of a body made of cells, ineherently stateful.Is "one thread each cell"  an acceptable choice ?
08:22:56 <ibid> it's not a smart choice probably
08:22:59 <ibid> but it's possible
08:23:38 <Syzygy-> ibid: Did you get my poke about good math/bad math?
08:23:44 <ibid> (note that discrete simulations are the original application area of OO and fit best the OO math)
08:23:49 <ibid> Syzygy-: as i said above, feel free
08:23:55 <paolino> not smart as haskell threads are not light ?
08:24:06 <Heffalump> I thought they were pretty cheap
08:24:10 <Heffalump> how many would you be having?
08:24:11 <Cale> Haskell threads are fairly light
08:24:18 <ibid> paolino: not smart as it's the naive threadization. haskell threads tend to be cheap, though
08:24:21 <Cale> There are limitations of course :)
08:24:33 <ibid> s/OO math/OO style/
08:25:59 <rc-1> currently learning haskell, and want to help my gf learn to program too, is it a good first language?
08:26:12 <norpan> yes
08:26:16 <yaarg> sure and it's what we use here
08:26:29 <Philippa> yes, though it's definitely a /different/ first language
08:26:49 <w-ber> At least it's better as a first language than BASIC or C.
08:26:54 <Philippa> I've shown bits and pieces to one of my exes, keep meaning to teach some to my housemate (who's very much a beginner coder atm)
08:26:57 <rc-1> would probably be better, she wont be tainted by c like me :)
08:28:26 <paolino> ibid, you think I can have a simpler code with that choice , or it's me I can't escape the OO paradigm for stateful simulations (if  there are  any stateless) ?
08:28:29 <yaarg> or i could put it this way - you're more likely to seduce her with haskell!
08:28:29 <yaarg> :D
08:29:19 <ibid> paolino: OO is the natural fit for discrete simulation. i'd say you'd be smart to model the problem object-orientedly, even if you implement it using haskell
08:29:30 <mux> the good thing with C as a first language as I see it, is that it makes people intimely aware of how the underlying machine works
08:29:39 <ibid> paolino: of course, what many people think OO is is not actually what it is :)
08:29:41 <w-ber> mux: The same could be said of assembler.
08:29:56 <Philippa> intimate awareness is for when you're old enough to handle it
08:30:00 <yaarg> let electronic engineers worry about the low level stuff
08:30:00 <mux> w-ber: except that assembler would be limiting tht knowledge to one particular architecture
08:30:07 <w-ber> mux: In fact, assembler as first language would at least teach everyone what pointers are. :)
08:30:29 <mux> and some assembler languages are very very specific :)
08:30:38 <Philippa> besides, the underlying machine exposes rather more about the stack
08:30:43 <mux> note that I'm not saying haskell is a bad first language
08:30:57 <mux> but when it comes to optimization, people having C basics know where to dig
08:31:10 <w-ber> mux: True.
08:31:21 <dylan> I learned as a fourth language or so, and never felt the need to use it for anything.
08:31:27 <w-ber> We'd better conclude that it's good to know both C and Haskell, and bad to know only one.
08:31:28 <dylan> *learned C as.
08:31:31 <mux> I have often wondered what kind of a programmer I would be if I had started with haskell
08:31:42 <mux> (instead of Locomotive Basic 1.0 on Amstrad CPC464!)
08:31:56 <yaarg> people with a solid understanding of data structures should know where to look too
08:31:57 <w-ber> Hey, I started with Microsoft Basic and Commodore 128. :)
08:31:57 <Philippa> mux: not necessarily as much as you might think though
08:32:01 <Philippa> yaarg: right
08:32:19 * mux ^5's w-ber 
08:32:19 <Philippa> even C doesn't actually expose caching to you, anyway
08:32:21 <VerbalDK> I programmed my first CPU using dip-switch like devices
08:32:36 <w-ber> Respect.
08:32:38 <paolino> ibid, I can't imagine how to track the state of each cell, their born and death , their life speed and the intercommunication.I'd like some hints, if you don't mind.
08:33:05 <mux> anywyas, I think that to be good in one specific language, you need to know about other languages, possibly unrelated
08:33:10 <Philippa> what do you mean by "track"?
08:33:17 <VerbalDK> w-ber it doesnt make me any better than any other programmer :)
08:33:23 <mux> I wasn't a very good C coder until I learnt OO programming
08:33:28 <ibid> paolino: the choices are a state monad, the ST monad (STRefs) or the IO monad (IORefs)
08:33:36 <mux> and once I knew OO, I was able to significantly design my code better
08:33:39 <dmead> i started with C++
08:33:40 <w-ber> VerbalDK: No, but it gives you the right to be known "old school". :)
08:33:42 <dmead> =o
08:33:57 <VerbalDK> yeh - but i want to be hip and happening xD
08:34:05 <Philippa> A lot of the lessons in OO programming're available more clearly in FP though
08:34:15 <mux> OO taught me how to better abstract my C libraries
08:34:43 <Oejet> VerbalDK: Yay, another Dane!  We are quite a few now, I think.
08:34:46 <mux> maybe I could have leartn this through haskell yeah, I'm not denying that, I can't know, it's too late :-)
08:35:09 <VerbalDK> Oejet - kanon der :)
08:36:07 <paolino> eh , haskell teaches me java o_O
08:36:14 <mux> my sister has expressed the desire of learning programming and I was actually wondering what to teach her first
08:36:23 <VerbalDK> basic
08:36:28 <paolino> python
08:36:29 <mux> that's one possibility
08:36:41 <w-ber> Doesn't nobody say Haskell?
08:36:49 <Oejet> Could someone please whip up a lambdabot plugin, which lists the top countries represented in #haskell?
08:36:50 <VerbalDK> ehm - haskall
08:36:57 <w-ber> mux: Please avoid BASIC like the plague.
08:37:01 <mux> haskell seems very counter-intuitive to me at times, but I'm ready to accept this is because I started with imperative programming
08:37:07 <psnl> Oejet: how would you get the infomation?
08:37:10 <yaarg> heh if my sister said that i'd tell her to go read then ;)
08:37:31 <Philippa> haskell's good if you mostly want to do sums and transformations and stuff first and're happy to move on to stuff with an actual UI later
08:37:33 <mux> now I'm not sure haskell would be very interesting for what my sister is going to want to do with it
08:37:36 <Philippa> it's less good if you want nice UI fast
08:37:37 <mux> w-ber: I really don't
08:37:40 <liyang> Cobol.
08:37:40 <w-ber> mux: It would be far easier to explain imperative languages ("everything is inside a monad") to someone who knows only Haskell than to explain Haskell to someone who knows only imperative programing.
08:37:55 <Philippa> to put it another way: can you do much of what you're interested in purely, or are you inherantly after lots of IO?
08:38:02 <mux> this whole Knuth saying that people having started with BASIC are definitely doomed is just wrong :-)
08:38:04 <Philippa> w-ber: seconded
08:38:07 <mux> he was probably kidding about it anyways
08:38:11 <mux> see, I started with BASIC :-P
08:38:20 <ibid> mux: that's not knuth
08:38:22 <w-ber> mux: I think that was Dijkstra. :)
08:38:27 <ibid> mux: that's dijkstra
08:38:29 <mux> oh, sorry.
08:38:45 <mux> poor dijkstra :-(
08:39:12 <mux> there was one IRC channel with the topic "semaphores now 50% cheaper" the day of his death
08:39:17 <w-ber> He had some elitist opinions about programming languages.
08:39:19 <mux> I can't remember which, heh
08:40:09 <paolino> ibid, so a pair of those monads can represent a cell ?
08:40:14 <mux> w-ber: now, it may be much easier for someone that has started with haskell to grasp imperative programming rather than the opposite, but this is not telling anything about the learning curve
08:40:19 <VerbalDK> basic makes for spaghetti programming
08:40:27 <mux> I wonder how much time it would take for someone starting with haskell to be able to do things
08:40:29 <ibid> paolino: uh, no
08:40:35 <mux> as opposed to someone starting in pascal, or basic, or whatever
08:40:41 <ibid> paolino: those monads are how you represent program state
08:40:45 <w-ber> mux: Now you can try. :)
08:40:52 * mux nods :-)
08:40:55 <Philippa> mux: define "things"
08:40:59 <w-ber> mux: Besides, how does one compare? People are individuals.
08:41:03 <Philippa> like I said, if you're interested in pure stuff it's fast
08:41:59 <mux> I can't see any practical usage of programming for my sister, for now at least :)
08:42:16 <mux> the practical usage would be more to have her learn how's a computer working
08:42:34 * mux scratches head
08:42:41 <Saizan> so C?
08:42:42 <w-ber> Why would it be useful to teach newbies how to manage memory allocations manually when the language implementation can do it for them? This rules out C and mostly C++.
08:42:49 <mux> Saizan: I'm tempted to think that yeah
08:42:52 <dylan> i get people interested in programming by making them realize that they can make the computer do whatever they want, within reason.
08:42:55 <yaarg> well that's kinda my point
08:42:56 <w-ber> They can do so later, after they have grasped the more important programming concepts.
08:43:13 <yaarg> if she was really interested she's probably investigate herself
08:43:16 <Saizan> mux: but she will run away in fear :D
08:43:17 <Philippa> mux: does the actual hardware matter so much?
08:43:39 <Philippa> though teaching both Haskell and a macro assembler has a certain appeal
08:43:49 <mux> Philippa: not in the specifics, but being able to differentiate between the main parts of a computer is
08:43:52 <w-ber> dylan: I used to do that, but most people I know were severely discouraged after they learned how hard it is to accomplish anything big (big as in even a GUI calculator).
08:43:57 <yaarg> which is why i'm always suspicious of people that ask me to teach them how to program.. 'cause it's going to take effort on their part
08:44:16 <dylan> w-ber: I first convert them to using mostly curses-based applications or web-based ones.
08:44:16 <Philippa> in fact, I remember getting into an argument in another chan because I'd advocated a course doing haskell+a cleanish asm side-by-side as an intro
08:44:17 <mux> Philippa: that helps a *lot* when people need to troubleshoot problems
08:44:22 <wchogg> Philippa:  I do like the idea of learning the abstract mathematical side and the machine instruction side concurrently.  That would make a very neat course.
08:44:41 <Philippa> wchogg: I'd intended to cover some basic compilation pretty fast, too
08:44:53 <w-ber> Philippa: Sounds very good.
08:44:55 <Philippa> compiling arithmetic expressions isn't /that/ hard
08:44:59 <mux> sounds interesting
08:45:06 <wchogg> Philippa:  Indeed, I was just going to say that it might make a nice precursor to a compilers course.
08:45:10 <Philippa> lots of looking at multiple points on the abstraction stack at once
08:45:36 <Philippa> yep. Given just long enough, a simple "sane untyped C" compiler might be the end product of the first course
08:45:55 <Philippa> don't bother with a concrete syntax that isn't derived yet, or have the parser supplied...
08:46:31 <Philippa> important disclaimer: I am *not* a lecturer!#
08:47:03 <wchogg> Pity.  I think you'd put together a nice intro to CS with all that.
08:47:24 <yaarg> meh cs students shouldn't see a computer until third year at least
08:47:26 <yaarg> :D
08:47:49 <Philippa> yaarg: then how do you expect the abstraction stack to really make sense?
08:48:02 <Philippa> it's no good unless you can demonstrate what happens to a running program when you yank the power
08:48:06 <wchogg> There are plenty of universities who believe you shouldn't see anything other than Java until you're a third year.
08:48:13 <Philippa> (missile launch may be OTT)
08:48:25 <w-ber> yaarg: Seconded.
08:48:50 <yaarg> Philippa: lego?
08:49:00 <mux> C# !
08:49:04 <Oejet> yaarg: What about software engineering students?
08:49:28 <Saizan> (in my first year we had to write a basic matrix calculator in asm..)
08:49:29 <wchogg> Oejet:  Do some universities actually make that distinction?
08:49:52 <yaarg> Oejet: they can learn politics and go to lots of art classes
08:49:56 <yaarg> (to draw UML)
08:50:05 <Oejet> wchogg: My (technical) university does.
08:51:10 <rc-1> my classes ONLY use java, except one for programming languages
08:51:11 <yaarg> yeah plenty places make such a distinction
08:51:14 <Oejet> yaarg: Yeah, it's incredible how powerful it is to be able to automatically generate code from you UML diagrams.
08:52:06 <dylan> at work, I'm required to have some diagrams for my boss..
08:52:15 <dylan> so I generate them from code.
08:52:59 <wchogg> dylan:  Do you then brag about how well you're able to implement from the diagrams to your code?
08:53:00 <jajs> my university used visual basic to introduce imperative programming during the second half of the first year...
08:53:07 <yaarg> (the above comments are tongue and cheek and should be considered as such)
08:53:23 <dylan> wchogg: no, but I do use that time to goof off and write for-fun haskell stuff. :)
08:53:29 <yaarg> tongue in check even
08:54:20 <dylan> "Okay, here's the diagrams. They're not terribly useful... I'll go write code now."
08:54:41 <dylan> by not using a definitive article, it's not really a lie. I am writing code, just not the code that they assume. XD
08:55:49 <wchogg> Hah.
08:56:25 <dylan> I also do extra work on fridays and forget to commit it, so I can commit it on monday and have the first half of the day to get back into the mood.
08:56:46 * yaarg grins
08:57:04 <w-ber> Over at the University of Turku, they encourage using Java, and the first and second year courses are exclusively in Java. Thankfully, they teach concepts, not Java.
08:57:42 <w-ber> Given a liberal supervisor, you can use other languages, too, but "OO languages" are favored (such as C++ and Java).
08:57:56 <w-ber> I'll see what happens if I wanted to write a course work in Haskell. :)
08:57:57 <dylan> What about smalltalk?
08:58:13 <w-ber> They used to use Eiffel in 1990s, which is a bit surprising.
08:58:52 <dylan> I dread taking CS courses... it's probably why I've only done general-ed stuff so far.
08:59:24 <w-ber> Most CS courses aren't about the *science* but about the craft or practice...
08:59:31 <dylan> I think the language of choice here is .NET... all the local unis are in microsoft's pants.
08:59:38 <w-ber> Scary.
09:00:03 <dylan> yeah. I think I might switch major to math/language rather than CS/math.
09:00:49 <vegai> fortunately, the impact universities have is limited
09:00:55 <dylan> which would probably be more difficult. I don't exactly like math, I just get a sick sense of satisfaction in understanding it.
09:01:29 <wchogg> Stupid question:  if I were interested in the mathematical structure of communication in a server/client model, in what subject would I want to start looking?
09:01:52 <psnl> wchogg: pi-calucus
09:02:11 <wchogg> Thanks, much appreciated.
09:02:21 <liyang> dylan: thankfully, there are university courses that teach the /science/ of computing.
09:02:40 <Philippa> yeah, though UoN's doesn't do as much as it could
09:02:54 <liyang> Philippa: I never said UoN. :p
09:03:06 <dylan> liyang: True. I'm not really worried about being taught, though. I like learning on my own. I just want the paper and the ability to become a professor or somesuch.
09:03:34 <liyang> dylan: stick to maths, do an CompSci MSc then carry on from there. :)
09:03:36 <yaarg> CS is too fluffy a subject in general
09:04:00 <Heffalump> some of the shit people teach under the guise of CS is fluffy
09:04:01 <yaarg> professors want to make you theooretical but then the real-world wants you to be useful
09:04:31 <dylan> pssh, real world. who needs it.
09:04:40 * earthy likes eating
09:04:45 <yaarg> ?!
09:04:45 <lambdabot> Maybe you meant: . v
09:04:50 * yaarg likes eating
09:04:51 <earthy> that's somewhat real-worldish. ;)
09:04:53 <Philippa> rather, the "real-world" doesn't see how theory is useful and insists you spend all your time on what it's doing right now
09:05:11 <yaarg> :)
09:05:14 <wchogg> dylan:  Except that the real world is where you get real interesting problems.  It's nice to apply theory to practical things if you have the luxury.
09:05:25 <dylan> I don't mind the split. I write broken things for money and beautiful things for fun.
09:05:26 <agocorona> hi
09:05:55 <yaarg> that and CS is too broad IMHO (but that's another story...)
09:06:13 <earthy> oh, and mathematicians tend to be really bad at the stuff that theoretical computer scientists are really good at
09:06:40 <agocorona> someone also had problems like me  with ghc 6.6 programming with sockets in windows?
09:06:45 <yaarg> only the theoretical computer scientists of today were/are mathematicians?
09:06:57 <yaarg> 8-)
09:07:21 <earthy> well, a good grounding in maths helps, ofcourse ;)
09:08:28 <beelsebob> @hoogle Eq a => [a] -> [a] -> [[a]]
09:08:29 <lambdabot> No matches, try a more general search
09:08:30 <psnl> agocorona: you need some sort of init stuff
09:08:32 <beelsebob> bah
09:08:34 <earthy> but the theoretical computer scientists of today ar logic are usually logicians
09:08:41 <beelsebob> @hoogle Eq a => a -> [a] -> [[a]]
09:08:45 <lambdabot> No matches, try a more general search
09:08:46 <beelsebob> bah
09:08:50 <beelsebob> @hoogle split
09:08:51 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
09:08:51 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
09:08:51 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
09:08:57 <w-ber> > map (4 <) [1,3,5,7]
09:08:58 <lambdabot>  [False,False,True,True]
09:09:03 <beelsebob> @hoogle splitOn
09:09:04 <lambdabot> No matches found
09:09:05 <earthy> and logicians don't really count as mathematicians, in the eyes of most mathematicians ;)
09:09:07 <beelsebob> @hoogle splitAt
09:09:08 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
09:09:08 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
09:09:08 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
09:09:16 <beelsebob> :(
09:09:29 <earthy> what do you want to achieve, beelsebob?
09:09:36 <w-ber> > filter (4 <) [1,3,5,7]
09:09:38 <lambdabot>  [5,7]
09:09:55 <wchogg> earthy:  Well I've seen mathematicians treat category theorists as being fluffy philosophers.
09:10:07 <Heffalump> or as computer scientists, in the eyes of most computer scientists :-)
09:10:44 <beelsebob> earthy: I want to be able to do something like splitOn "::" "jam::ham::spam" to return ["jam","ham","spam"]
09:11:36 <w-ber> The reason why there is much fluff in computer science is that the term computer science is used in very different meanings.
09:11:41 <LPhas> studying Bioinformatics i discovered that Turing was smarter than God
09:11:50 <norpan> beelsebob: yes, that sounds like a good novice haskell task to try to implement
09:11:53 <w-ber> For some, it means the science of computing (which has nothing to do with computers), for some it means the science of computers, etc.
09:12:10 <wchogg> w-ber:  I tend to think of CS as being about as broad a term as engineering.
09:12:25 <w-ber> Some of those who think of themselves as computer scientists are bound to deride the rest who are not like them. :)
09:12:42 <wchogg> That's just academics in general though.
09:13:17 <beelsebob> > let splitOn x y = splitOn' x y []; splitOn' x [] a = [a]; splitOn' x (y:ys) a = if x == y then (reverse a):splitOn' x ys else splitOn' x ys (y:a) in splitOn ':' "jam:ham:spam"
09:13:18 <lambdabot>    Expecting a function type, but found `[a]'
09:13:18 <lambdabot>    Expected type: [[a]]
09:13:18 <lambdabot>  ...
09:13:21 <beelsebob> fail
09:14:20 <beelsebob> > let splitOn x y = splitOn' x y []; splitOn' x [] a = [a]; splitOn' x (y:ys) a = if x == y then (reverse a):(splitOn' x ys []) else splitOn' x ys (y:a) in splitOn ':' "jam:ham:spam"
09:14:21 <lambdabot>  ["jam","ham","maps"]
09:14:26 <beelsebob> oops
09:14:31 <beelsebob> > let splitOn x y = splitOn' x y []; splitOn' x [] a = [reverse a]; splitOn' x (y:ys) a = if x == y then (reverse a):(splitOn' x ys []) else splitOn' x ys (y:a) in splitOn ':' "jam:ham:spam"
09:14:33 <lambdabot>  ["jam","ham","spam"]
09:14:35 <beelsebob> better
09:14:42 <beelsebob> but yes... should be a prelude function
09:14:47 <earthy> why?
09:14:54 <beelsebob> because it's *so* commonly used
09:15:00 <norpan> i'd rather reduce the prelude
09:15:07 <psnl> why?
09:15:12 <norpan> should be in a list processing libarary perhaps
09:15:16 <beelsebob> indeed
09:15:22 <beelsebob> yes, not the prelude
09:15:23 <yaarg> my current annoyance is
09:15:27 <beelsebob> it should be in Data.List
09:15:35 <yaarg> people who say they are computer scientists when they have a degree in computer science
09:15:41 <yaarg> simply, not true
09:15:50 <beelsebob> yaarg: that's a failing of the degree process, not of them
09:15:56 <yaarg> no
09:16:07 <Philippa> no, someone with a physics degree isn't necessarily a physicist either
09:16:12 <earthy> this might be useful in Data.List
09:16:12 <earthy> but usually if you['re doing stuff like this you're parsing anyway
09:16:15 <yaarg> if you have a degree in math you're not a mathematician either in my mind
09:16:16 <beelsebob> the degree process does not make computer scientists, it makes software engineers
09:16:19 <yaarg> Philippa: precisely
09:16:44 <norpan> beelsebob: unfortunately, it doesn't either :)
09:16:45 * Heffalump thinks CS degrees are no use at all in making software engineers
09:16:47 <earthy> (damn this internet connection)
09:16:59 <norpan> the degree process makes degrees
09:17:01 <beelsebob> nornagon: okay... more precicely it makes bad software engineers
09:17:10 <Heffalump> good software engineering is a result either of common sense, or of experience
09:17:10 <yaarg> no no you're missing my point
09:17:13 <yaarg> take any degree
09:17:13 <beelsebob> it most certainly doesn't make people capable of computer science
09:17:17 <yaarg> it doesn't make you...that
09:17:24 * beelsebob must go
09:17:43 <norpan> in particular, a cs degree doesn't make you a good programmer
09:17:55 <Philippa> Heffalump: I think a certain amount of it is... well, not necessarily directly formalisable, but there're formalisable tools at least
09:18:08 <Philippa> being able to pinpoint what qualities made a system good's important
09:18:23 <yaarg> computer scientist to me says somebody that is "actively researching computer science"
09:18:38 <Heffalump> oh, so they stop being computer scientists when they go to bed?
09:18:52 <yaarg> don't be silly :P
09:19:06 <w-ber> Or take a wee.
09:19:15 <wchogg> Or watch crap on YouTube.
09:19:20 <Philippa> you mean you don't carry on thinking about CS on the loo?
09:19:21 <yaarg> you can read books in the toilet
09:19:51 <w-ber> Philippa: Actually, I have had some great solutions to problems at the toilet.
09:20:30 <Philippa> w-ber: you're not the only one
09:20:41 <yaarg> you're taking my interpretation of actively too literally
09:20:50 <w-ber> Yes, because it's fun to poke at you. :)
09:20:53 <Philippa> yaarg: you may be taking Heffalump too seriously :-)
09:21:09 <w-ber> yaarg: So is it computer science to study how people use computers?
09:21:18 <wchogg> I thought that was ergonomics?
09:21:39 <yaarg> grr
09:21:42 <w-ber> yaarg: Or how computers affect different types of work, such as manual labor?
09:21:46 <yaarg> w-ber: well depends
09:21:50 <yaarg> oh no
09:21:53 <yaarg> that social computing rubbish
09:21:54 <yaarg> pah
09:21:55 * Heffalump can never be taken too seriously
09:21:59 <w-ber> Both can be studied scientifically and they have the word "computer" in the problem definition. :)
09:22:11 <Philippa> Heffalump: indeed, so we don't :-p
09:22:18 <Heffalump> :-p
09:22:21 * yaarg knows people doing PhDs in "social computer science" 
09:22:26 <w-ber> Ick.
09:22:33 <wchogg> Is it some kind of anthropology?
09:22:35 <yaarg> need less to say i have no respect for them :-)
09:22:46 <Philippa> it sounds slightly misnamed, but that's all. There's value in that kind of thing
09:22:50 <w-ber> It's not even a coherent term.
09:23:00 <w-ber> Philippa: What the heck does it mean?
09:23:02 <Philippa> it sounds like it'd be more accurately dubbed "social computing studies"
09:23:11 <Philippa> in line with a pile of other "foo studies" subjects
09:23:37 <w-ber> What is social computing? Counting things together with other people?
09:23:50 <yaarg> i have no idea what it means since i've never had the inclination to poke them about it
09:23:51 <agocorona> hehhe
09:23:58 <yaarg> for fear of being bored to death
09:24:08 <Philippa> w-ber: presumably it's things like "ooh, look at all the things people can do with the net!" and "ohshit, Big Brother just started playing with databases"
09:24:18 <w-ber> Philippa: That's hardly computing.
09:24:44 <w-ber> Computers are not social animals, by the way. :)
09:24:48 <Philippa> I disagree, it's much computing as carried out within a social context. It's the effects thereof that're studied though
09:24:50 <wchogg> Philippa:  Oh I'm sure there's some absolutely fun things you can do with ad-hoc tribal cultures that form on online games.
09:25:25 <Philippa> wchogg: not just those. The net's a really big deal if you're as weird as I am, and not so much for online-only relationships...
09:25:29 <agocorona> social computing is something related with the computer divide other estatist-aimed buzzconcepts
09:25:31 <w-ber> Philippa: Well, you sure have a different definition for computing than I do.
09:25:51 <Philippa> w-ber: is or is not running a database an example of computing?...
09:26:07 <w-ber> Philippa: It is, but people using those or discussing uses for a database is not.
09:26:24 <Philippa> right, see my comment about the field of study being the results of the computing...
09:27:18 <w-ber> "Results of computing" is a tad broad term, too. Anything from Bob hitting Alice with a fishing pole to baking bread can be the result of a computation.
09:27:35 <w-ber> Actually, the motive or the reason of the action.
09:28:15 <Philippa> you're catching on. I suspect pre-hardware-computation effects'd be considered worth studying as well...
09:28:35 <w-ber> Sure. However, this is a topic I am not even slightly interested in. :)
09:29:18 <dylan> Philippa: a day without net access is like a day missing a limb, eh? :)
09:29:25 <wchogg> I think it's kinda fun.  People and their interactions tend to be amazingly weird and complex.
09:29:31 <dylan> (unless one is camping in the great out-doors, in which case it is tolerable)
09:29:48 <Philippa> dylan: I didn't say that :-)
09:30:03 <Philippa> OTOH, two of my three current partners I wouldn't have met without the internet...
09:30:17 <Philippa> (questions about "two of three" to -blah, folks)
09:30:30 * dylan shrugs.
09:31:02 <dylan> I wouldn't have met my one-of-one without the net. And even when in the same room, I feel more intimate talking with text to her. :)]
09:31:53 <w-ber> I hope you're doing the real thing and not cybersex...
09:32:01 <dylan> That isn't talking. :P
09:32:19 * earthy feels like he's back in 1999
09:32:30 <dylan> and the expenditure of speech is the least of concerns given the *other* expenditure of energy. :)
09:32:30 <Philippa> yeah?
09:32:31 <earthy> people discussing the net as though it wasn't part of normal life
09:32:53 <Philippa> *nod* - which is pretty much the point, really. Except a lot of my normal life'd disappear again without
09:33:03 <dylan> it is part of normal life.
09:33:03 <earthy> mine wouldn't
09:33:12 <w-ber> I used to read four books a month before I had a 10 Mbps net access.
09:33:21 <w-ber> Now I read books only seldom, which is a shame.
09:33:23 <dylan> I recently went a weekend without the net being up.
09:33:29 <Philippa> yeah, a lot depends on where the people you spend in-person time with are
09:34:11 <earthy> it'd change
09:34:16 <dylan> it was horrible. 90% of my (and my better half's) friends are online-only, or at least primarily.
09:35:04 <Philippa> yeah. Most of my good friends're dotted about the country, so I'd be spending a lot more time alone
09:35:08 <dmead> so your saying the internet is the downfall of western civilization?
09:35:12 <norpan> i realized that yesterday, so now i've invited a lot of friends to my flat
09:35:19 <wchogg> Pretty much all my friends live within walking distance of me.  Without cell phones, then we'd have problems.
09:35:49 <dylan> locally, I knew 3-6 people that are true friends.
09:35:54 <norpan> if you can walk 10 km that's true for most of mine too :)
09:36:04 <dylan> at least one of them, my only means communication is IRC
09:36:22 <dylan> no cell phone, no land line. :)
09:36:45 <w-ber> A hermit?
09:36:49 <earthy> nah you wouldn't.
09:36:55 <dylan> Not really, he's just not very wealthy. :P
09:37:12 <wchogg> norpan:  10km is a bit much, but I consider about 4-5 to still be walking distance.
09:37:14 <w-ber> You can buy a cellphone for $50 these days...
09:37:24 <earthy> less, second hand
09:37:39 <dylan> he has no job, he's a full time student.
09:37:47 <emu> w-ber: i too have not read much in the last 5 years compared to the previous
09:38:19 <norpan> i bike about 10 km each day
09:38:21 <norpan> to and from work
09:38:22 <dylan> personally, I hate talking on the phone anyway
09:38:24 <w-ber> I don't know about where you live, but I pay 69 eurocents a month plus 6 eurocents a minute. My last phone bill was 25 euros and covered five months. :)
09:38:36 <yaarg> lol
09:38:55 <dylan> w-ber: the US, where we are raped by the cellphone companies.
09:39:02 <norpan> 69 cents a month? without a minimum limit per year or something?
09:39:05 <yaarg> 30 line rental for three months alone here
09:39:19 <dylan> hmm, I'm wrong.
09:39:25 <dylan> william has a landline
09:39:27 <w-ber> norpan: What kind of a limit?
09:39:30 <dylan> just not a cell phone.
09:39:48 <norpan> minimum total calling or something, as with cashcards expiring on minimum billing amount
09:39:59 <w-ber> Nope. Finland has had some very heavy competition in recent years.
09:40:08 <w-ber> Coincidentally, 99% of the population has a cell phone.
09:40:28 <w-ber> Could be 100%, though I doubt.
09:40:34 <earthy> I think we have plans for EUR 1.95 a month
09:40:36 <earthy> with free minutes
09:40:37 <norpan> the cheapest i found in sweden still makes you reload with 300 SEK each year
09:40:53 <Saizan> w-ber where do you live?
09:40:55 <yaarg> w-ber: nokias i suppose?
09:40:56 <yaarg> :D
09:40:58 <norpan> which is 32 euros
09:41:00 <w-ber> Saizan: Turku, Finland.
09:41:14 <w-ber> yaarg: Actually, quite a few have Samsung and Sony Ericsson. :)
09:41:22 <yaarg> traitors!
09:41:45 <earthy> something like 100 free minutes a month or somesuch
09:41:45 <norpan> 6 cents a minutes is normal rate though
09:41:54 <w-ber> Buying Nokia is a matter of luck: either you get a device that never breaks (smash it to the floor or drop in a lake, it will work), or the device falls apart after three months.
09:42:36 <w-ber> norpan: I'm not entirely sure what my current rates are. It's cheap enough, and I rarely make long calls anyway. :)
09:42:49 <dylan> my old nokia survived a trip through the washing machine.
09:43:12 <w-ber> My mother has had his Nokia repaired three times, and it's less than six months old.
09:43:19 <w-ber> She gradually grew tired and bought a Samsung.
09:43:35 <w-ber> *her
09:52:21 <vegai> unless things change, I'm also not going to buy a Nokia any time soon
09:54:39 * ibid had a ericsson and then a siemens for years and bought a nokia again after several years
09:55:37 <w-ber> Old Siemens phones have no value in Finland anymore and you can't even get them repaired. No-one knows if you can get parts for them or not.
09:56:41 <vegai> Nokia's low-end models are very good, though. I just don't need those right now..
09:56:46 <yaarg> some may argue that new siemens phones have no value
09:56:54 <yaarg> :)
09:58:01 <w-ber> I think I'll buy Motorola C115. It's as basic as it can be. I have no use for cameras or MP3 players, not even talking about playing games or running Java applets.
10:01:19 <Saizan> mmh i'm writing a very basic lisp interpreter for fun, have you an hint on how to manage macros?
10:02:33 <Philippa> Saizan: depends how you want them to behave, no? Which lisp do you want to emulate?
10:02:50 <Saizan> err common lisp
10:03:25 <Saizan> basically macros are code that writes code no?
10:03:56 <w-ber> Lisp macros are code that modify the abstract syntax tree, right?
10:04:08 <dmead> huh?
10:04:21 <dmead> lisp macros are just self generating code
10:04:21 <w-ber> Never used much Lisp.
10:04:39 <dmead> but macros like that are useless in a statically typed language like haskell
10:04:50 <wchogg> w-ber:  Well, what said is right.  It's just that in lisp the ast is the same as the code.
10:05:06 <w-ber> Ah, right, that's how it went.
10:08:23 <emu> the abstract syntax tree of lisp (at least, the initial one) is represented as lisp lists, symbols, numbers, etc
10:08:31 <emu> macros are functions which transform lisp data
10:09:40 <emu> when you implement a lisp interpreter, especially common lisp, and you have a form to evaluate, you examine the first symbol of the form to see if it is a macro, special, or function name
10:10:59 <Ugarte> What do you mean, the AST is the same as the code?
10:11:06 <Ugarte> They're always equivalent.
10:11:30 <Ugarte> Er, that's directed at wchogg.
10:11:45 <emu> the AST of common lisp is very closely mapped to the concrete syntax
10:11:54 <Ugarte> Ok.
10:12:03 <emu> however there's two levels of syntax
10:12:18 <ibid> the lisp concrete syntax started out as abstract syntax written down on paper
10:12:24 <emu> there is the surface syntax that the reader implements, turning ( ) into lists and parsing literals
10:12:36 <ibid> they planned to write a real concrete syntax but got lazy and didn't :)
10:12:44 <Ugarte> So there aren't many different syntactic representations that are semantically different?
10:12:47 <Ugarte> I mean, I know what you're saying.
10:12:56 <Ugarte> I've heard that story ibid just shared before, as well.
10:13:00 <Ugarte> But what's the import of this?
10:13:04 <Philippa> it's all cons cells, more or less
10:13:05 <emu> not much to today's lisp
10:13:17 <emu> m-expressions never caught on
10:13:24 <Ugarte> Er, not semantically different.
10:13:28 <Ugarte> Semantically identical.
10:13:30 <emu> in fact, i don't think they were ever implemented in a program
10:13:31 * Ugarte is crazy
10:13:41 <Philippa> there're a few
10:13:48 <Philippa> (1 2 3 4) is sugar...
10:13:52 <Ugarte> I was asking, "This means there aren't many different syntactic representations that are semantically identical?"
10:13:55 <Philippa> anyway, I gotta go do stuff
10:13:56 <emu> dylan came up with their own
10:14:17 <ibid> blah, i should give a 45 minute lecture on free software development tomorrow morning
10:14:21 <ibid> in abut 12 hours
10:14:29 <Ugarte> To whom?
10:14:55 <ibid> to undergrad students in the second-year intro to software engineering course
10:15:18 <Saizan> [190345] <emu> when you implement a lisp interpreter, especially common lisp, and you have a form to evaluate, you examine the first symbol of the form to see if it is a macro, special, or function name<-- i was going to treat macros as user-defined specials
10:15:50 <emu> well, the difference is that something has to be at the core
10:15:57 <emu> that is, specials
10:16:39 <Saizan> well off course
10:19:24 <mwc> What's a special?
10:19:38 <emu> a form which is treated specially by the evaluator
10:19:52 <emu> also referring to the special operator which is the first symbol of the form
10:19:52 <mwc> I was thinking it was sort of like a pragma
10:19:59 <umike> hi! anyone using text editors with synax highlight for haskell dev except emacs and ecplipse ?
10:20:03 <w-ber> A friend told me that he can implement closures in C++ if he wants to. The syntax he showed me gave me a headache.
10:20:09 <Ugarte> umike: Vim works.
10:20:11 <emu> umike: emacs, vim have highlighting
10:20:19 <w-ber> Yes, ViM is excellent.
10:20:38 <ibid> w-ber: there is a proposal for closures and lambdas being considered for C++0x
10:20:40 <emu> w-ber: well, you need to be able to handle indefinite extent storage really
10:20:49 <mwc> w-ber, they're coming in more native form... (<>  x y -> foo(x,y,c))
10:20:53 <emu> are they planning on making GC required?
10:21:03 <mwc> No, the closures take their data by copy
10:21:06 <w-ber> emu: Not in C++09, I think.
10:21:06 <ibid> emu: no
10:21:16 <ibid> w-ber: yes, in C++0x
10:21:19 <emu> C++ always does everything stupidly
10:21:28 <wilx> I certainly hope they will never make GC mandatory.
10:21:32 <emu> someone needs to smack bjarne
10:21:33 <pejo> w-ber, I think Oleg had a poster for closures, lambda abstractions and stuff in C++ on ICFP'98.
10:21:35 <w-ber> Well, he had used classes and objects and what C++ people call functors.
10:22:07 <dmead> ehh
10:22:09 <mwc> it's basically a special form for automatically generating function objects... there's special support for taking referneces to local data, but you must ensure that it exists at the time the functor is called
10:22:12 <araujo> hola
10:22:15 <w-ber> Won't C++09 have yet new reference type called right reference or something? So you'd have pointers, references, and the new references.
10:22:15 <dmead> bjarne keeps with generality
10:22:15 * araujo back from univ.
10:22:17 <dmead> which is cool
10:22:25 <dmead> yea
10:22:28 <pejo> wilx, but gc is great! :P
10:22:31 <dmead> r-ref and i-ref
10:22:46 <mwc> GC is required for some language paradigms. You can do a lot in C++ without GC
10:22:46 <dmead> i don't know the difference and i made 3k doing C++ last summer
10:22:48 <emu> obfuscation and generality are different things
10:23:04 <mwc> a language like Haskell would be totally impossible without GC.
10:23:07 <w-ber> Template metaprogramming...
10:23:13 <dmead> o sure
10:23:28 <pejo> mwc, I like gc, really.
10:23:30 <Maddas> w-ber: don't forget smart pointers (:
10:23:36 <w-ber> *shudder*
10:23:51 <wilx> Nah, GC is not predictable thus not so great.
10:23:52 <dmead> auto+ptr
10:23:54 <dmead> _
10:23:54 <w-ber> To think that at one time I wanted to do everything in C++.
10:23:59 <emu> wilx: get a GC that is
10:24:15 <Maddas> w-ber: to think that many people never get past that :-)
10:24:17 <pejo> wilx, then you designed your gc wrong.
10:24:24 <w-ber> Can you do hard real-time programs in Haskell?
10:24:30 <pejo> wilx, if you need a predictable one, that is.
10:24:35 * Heffalump dislikes GC too
10:24:38 <emu> C programmers are so terribly concerned with "speed" so they use things like strlen() which is O(n) and hold onto malloc/free() even though they are unpredictable in performance
10:24:49 <emu> such superstition
10:25:03 <dmead> my advisor told me that some government contracts require AI be done in C
10:25:10 <dmead> which is just =(
10:25:11 <w-ber> Lovely.
10:25:33 <Maddas> emu: Except if you get to actual high-performance code :-)
10:25:50 <pejo> Heffalump, boggle, do you dislike all automatic memory management?
10:25:59 <emu> C standard library malloc/free are not suitable if you are terribly concerned about that
10:25:59 <mwc> Haskell doesn't allow you to consider data which is invalid or destroyed. You can't destroy data, GC is a requirement (or something like regional allocation, I think some dialects of SML did away with a lot of runtime GC)
10:26:23 <mwc> emu, you allocate a pile of memory and allocate by pointer-post-increment
10:26:28 <Maddas> emu: yes, and people tend to not use malloc/free for that.
10:26:34 <emu> yes, you need to implement your own memory management
10:26:36 <Maddas> (Instead roll their own)
10:26:39 <Maddas> Yup
10:26:41 <emu> mwc: oh, and that'
10:26:45 <emu> s precisely what generation gc does
10:26:52 <emu> generational* gc
10:27:17 <Heffalump> pejo: pretty much
10:27:25 <Heffalump> I see it as a necessary evil
10:27:32 <w-ber> GC has a bad name because many GC implementations are bad.
10:27:35 <pejo> Heffalump, because it is "unpredictable"?
10:27:47 <mwc> Heffalump, regional memory management can eliminate a ton of runtime GC
10:27:48 <wilx> Well, all, I think :)
10:27:55 <mwc> no idea how it would interact with a lazy language
10:27:57 <wilx> ..are bad.
10:28:02 <Heffalump> yes, and because leaks are difficult to debug
10:28:03 <emu> instead of treating GC like just another tool to be considered and even replaced
10:28:04 <mwc> GHC is awesome
10:28:07 <mwc> at GC
10:28:15 <mwc> I have numerical simulations running in 9 MB
10:28:29 <w-ber> I decided that I have done enough manual memory management to last a lifetime.
10:28:37 <mwc> I'd be hard pressed to do that in C++. Granted, I was using STUArray which don't occur too often for most haskellers
10:28:47 <pejo> Heffalump, leaks coming from using a lazy language?
10:28:55 <mwc> w-ber, I hardly notice memory management in my C++ apps, using boost's smart/shared pointers and the like
10:28:56 <Heffalump> or a strict one (e.g. Java)
10:29:23 <w-ber> mwc: Well, I've never used Boost. :) Not going to, either, if I can bend Haskell to do everything I need to.
10:29:43 <Heffalump> however, since the alternative is segfaults caused by too-early-frees, I view it as a necessary evil rather than something we should do without
10:30:04 <emu> GC is superior to manual memory management
10:30:11 <emu> i don't see it as an "evil" in any way
10:30:13 <Heffalump> that's a very general statement
10:30:23 <mwc> w-ber, indeed, you really can. I did an entire mod-sim course in Haskell. Next semester, I'll be doing a finite element course with it
10:30:34 <w-ber> Isn't there research how even a naive GC is better than most manual memory allocation and deallocation?
10:30:58 <mwc> Well, given that memory allocation tends to be bursty, you could design a good manual solution
10:31:03 <emu> generational copying GCs are very quick for allocation, de-allocation, and can compact objects for better cache utilization
10:31:17 <mwc> emu, right, but the fact is they do have a cost
10:31:24 <emu> manual memory management has a cost
10:31:28 <emu> and most people ignore it
10:31:31 <mwc> and if your program works with a large fixed memory set, you don't need that
10:31:40 <Heffalump> it's easier to control the cost
10:31:46 <emu> that's what you think
10:31:46 <w-ber> Manual memory management has a mental cost while GC has a cost in execution speed.
10:31:49 <mwc> emu, it has a cost, but you can customize it to work as best as possible
10:32:03 <mwc> w-ber, no, new/delete and malloc/free are SLOW
10:32:09 <emu> malloc and free have to sort through the list of free spaces and coalesce/chop out pieces
10:32:10 <Heffalump> for example, at work we use a region-based allocator - allocate memory in large chunks, throw it all away at once when a particular phase ends
10:32:13 <emu> that's not cheap
10:32:18 <emu> in fact, it's much slower than gc
10:32:24 <Heffalump> not very hard to avoid freeing things too early, and very cheap to allocate new things
10:32:30 <Heffalump> and doesn't leak much
10:32:32 <w-ber> mwc: Then why all the fuss about GC performance?
10:32:42 <emu> Heffalump: that's almost like a copying GC
10:32:50 <Heffalump> except it never wastes time copying..
10:32:52 <emu> except that it can't handle indefinite extent
10:32:57 <mwc> w-ber, it matters in some domains. I wouldn't want a 747 to go into a garbage collection cycle just as it's landing
10:33:04 <emu> Heffalump: you don't know what a copying GC does?
10:33:19 <vegai> Hmm, do you think that malloc/free are used that much in a typical C program?
10:33:23 <w-ber> mwc: True that, but you wouldn't want to use such a GC in that domain.
10:33:24 <Heffalump> well, I thought I knew..
10:33:31 <w-ber> mwc: There are other kinds...
10:33:32 <Maddas> Heffalump: ^_-
10:33:36 <emu> if you have no live objects in the space, then it just throws it away
10:33:49 <vegai> besides, C has a GC. It's called the stack :-P
10:33:53 <Heffalump> yeah, but it might run at a time when there are live objects in the space..
10:33:59 <mwc> My point is that with a language like C++, garbage collection would be a pain in the ass. With haskell, it's a joy to work with
10:34:00 <emu> then control it
10:34:02 <pejo> mwc, if you write real time systems with gc you better hope your gc is incremental, or can handle a full cycle of gc.
10:34:12 <Heffalump> how does that differ from manual memory management?
10:34:12 <emu> use the right tools for the job
10:34:13 <w-ber> The easiest solution is to create RAM that is infinite in size. That'll stop the bickering.
10:34:22 <emu> because you don't munge pointers
10:34:23 <Heffalump> we do use the right tools for the job!
10:34:25 <mwc> the two languages have VASTLY different mindsets, and guess what, one is hostile to GC and one embraces it
10:34:31 <Excedrin> http://www.hpl.hp.com/personal/Hans_Boehm/gc/myths.ps
10:34:33 <lambdabot> http://tinyurl.com/stuyg
10:34:39 <mwc> pejo, or you allocate all your data structures before you enter a critical phase
10:34:45 <Excedrin> gc myths, including gc is slow(er than malloc free) etc
10:34:46 <Heffalump> Excedrin: isn't that the one that says mark-and-sweep is the same cost as refcounting?
10:34:47 <mwc> then you only operate on a fixed set
10:34:47 <w-ber> pejo: Can you write real-time systems with Haskell?
10:35:14 * mwc retreats from flame war
10:35:30 <w-ber> mwc: Hey, this saves some central heating costs.
10:35:33 <emu> there is no general solution for memory management, manual or automatic.  GCs *should* be interchangeable like libraries, choose the one that suits your problem.
10:35:48 <pejo> w-ber, Cale will bite me now, but lazy evaluation is rather hard to reason about, both wrt time and space usage.
10:36:16 <pejo> emu, definitely. One can always write a mutator that beats the crap out of a given gc.
10:36:54 <Excedrin> Heffalump: not sure, it's just slides.. I'll glance thru it and see if there's anything about it
10:37:06 <Heffalump> Excedrin: never mind, I scanned it myself
10:37:13 <emu> the only point i'm trying to make is that manual memory management is not a panacea
10:37:25 <mwc> emu, nobody was arguing that
10:37:29 <mwc> on the other hand, neither is GC
10:37:46 <Heffalump> [18:24] <emu> GC is superior to manual memory management
10:37:49 <Excedrin> Allocation Myth 2: Malloc is inherently slow. :)
10:37:50 <Heffalump> that's what I was taking issue with.
10:38:14 <emu> for the same reasons that high level languages are superior to low level ones
10:38:23 <w-ber> It's superior to manual memory management when the one doing the management is not competitive or does not know enough.
10:39:09 <Excedrin> does GC always free everything before the program exits?
10:39:14 <Maddas> emu: They are not 'superior', low level languages are designed for a particular purpose: low-level programming.
10:39:36 <w-ber> Originally, low-level languages was all there is.
10:39:39 <emu> by low-level i mean in-expressive
10:39:43 <emu> non-expressive
10:39:52 <psnl> @help
10:39:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:39:59 <psnl> @list
10:40:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:40:15 <w-ber> @help list
10:40:15 <lambdabot> list [module|command]
10:40:16 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:41:11 <Maddas>   
10:42:24 <emu> w-ber: GC can do more than any manual memory management, because it operates "on the outside" so to speak, whereas the programmer can only work from within the language
10:43:17 <Maddas> Didn't you get it the wrong way round?
10:43:39 <Maddas> Manual memory management can do more, since the programmer knows more about the program than the writer of a GC
10:43:56 <Maddas> The question is how much work it is reasonable to invest
10:44:13 <Excedrin> GC can be written in the language in question, it doesn't have to be part of the RTS
10:44:24 <w-ber> emu: Also true.
10:44:29 <emu> it has to know about the RTS and the implementation
10:44:43 <emu> and you can always get a GC which does handle your problem better, ideally
10:44:56 <emu> which is why every GC implementation offers ways to tune it
10:45:14 <Excedrin> what if I want my program to do a bunch of mallocs and no frees?
10:45:35 <Excedrin> leak on purpose, let the OS reclaim memory, avoid paging stuff back in at exit, etc etc
10:45:40 <w-ber> The programming language D is good in this respect, because you can manually turn the GC off if you want to.
10:45:45 <emu> you mean, turn off GC?
10:45:55 <emu> or make newspace really large?
10:46:25 <Excedrin> no, I'm talking about typical usage of malloc in lots of the unix utilities... no gc involved
10:46:45 <emu> i've had applications where i disable global GC and leave scavenging because if an object doesn't die right away, it'll stick around til the end
10:48:58 <emu> i can get that behavior, with it implemented by the compiler vendor, and have the overhead be only 1-2%
10:49:13 <Excedrin> in a specific language?
10:49:19 <emu> (this was allegro CL)
10:49:38 <Excedrin> isn't disabling the GC part of the CL spec?
10:49:42 <emu> no
10:49:56 <emu> CL leaves memory management to the implementation
10:50:34 <Excedrin> well, I'm pretty sure that SBCL supports it... I recall it's typically used before making a core
10:50:53 <emu> sure. every implementation of CL has a GC, that i know of.  no infinite RAM machines yet.
10:51:07 <emu> (but CL is ready for them when they do exist!)
10:51:36 <newsham> ?time shapr
10:51:47 <newsham> ?seen shapr
10:51:48 <Excedrin> talking about GC, is there a command line option for GHC compiled Haskell code to spit out stats on GC usage?
10:51:48 <lambdabot> I saw shapr leaving #haskell-blah, #scannedinavian, #haskell and #ScannedInAvian 11h 13m 10s ago, and .
10:51:57 <emu> yes, +RTS -tstderr -RTS
10:52:05 <emu> stderr can be replaced by a filename
10:52:10 <Excedrin> thanks
10:53:08 <greg_lundien> haskell sucks
10:53:27 <emu> so they started teaching haskell at UT?
10:53:40 <astrolabe> is that a troll?
10:53:43 <Excedrin> ghc: 281097948 bytes, 537 GCs, 159988/159988 avg/max bytes residency
10:53:56 <Excedrin> a troll would have stuck around for the response
10:54:00 <w-ber> +RTS -s -RTS gives some statistics, too.
10:54:32 <astrolabe> oh, I missed that.  I wonder how long he'd been in.
10:55:49 <emu> Excedrin: +RTS -? for the full list of things you can tweak
10:59:56 <Igel> hi there
11:00:19 <Igel> is there a way to parse an html document into Text.Html.Html?
11:00:57 <Igel> i didn't find anything in the documentation as it is nothing more than the function signatures, yet :(
11:01:06 <vincenz> I wonder what motivated that person to walk in here, say haskell sucks, and then leave
11:01:13 <vincenz> Some people do things for the strangest reasons
11:01:23 <yaarg> :)
11:01:27 <Excedrin> vincenz: frustration?
11:01:30 <yaarg> possibly an assignment
11:01:33 <emu> i'm sure that it had to do with some homework
11:01:36 <vincenz> yaarg: strange assigmnet
11:01:42 <Excedrin> what's a nice language that runs on .NET?
11:01:47 <vincenz> Excedrin: f#
11:01:56 <Igel> vincenz, i guess its no troll, as he didn't wait for the reaction
11:02:30 * yaarg shrugs
11:05:02 <Igel> anyone^^?
11:06:29 <emu> Igel: i really don't know. if i was going to parse something in (x)html i'd probably look at haxml
11:07:15 <Igel> emu: that's not part of ghc-6.4, is it?
11:07:24 <emu> i don't think so
11:07:29 <adi> hi
11:09:04 <adi> I have a haskell code .. and there I declared 'while' 'minus' 'plus' etc
11:09:12 <adi> I don;t know how to declare 'for' :|
11:09:15 <adi> can anyone help ?
11:09:31 <dmead> for...?
11:09:39 <dmead> paste it
11:09:42 <dmead> @paste
11:09:48 <dmead> ?paste
11:09:51 <adi> :)
11:09:54 <dmead> where is that thing...
11:09:59 <adi> http://tzintzi.info/haskell.hs
11:10:05 <Igel> paste.lisp.org?
11:10:05 <adi> I have the code here
11:11:17 <lambdabot> http://paste.lisp.org/new/haskell
11:11:19 <lambdabot> http://paste.lisp.org/new/haskell
11:11:44 <dmead> mm
11:11:50 <dmead> can you translate the header into english?
11:12:34 <adi> the code is taken from 'DSL Implementation using staging and monads' by Tim Sheared, Zine-el-abidine Benaisa, Emir Pasalic
11:12:34 <adi> -- Pacific Software Research Center, Oregon Graduate Institute
11:12:38 <adi> I guess
11:13:06 <adi> and I declared some funtions like 'while' there, but I can't figure out how to do the same with 'for'
11:13:29 <dmead> i dont think you'd want to use while and for in haskell
11:13:39 <psnl> anyone know how to hold state in lambdabot?
11:13:52 <adi> why not ?
11:15:32 <Igel> recursion's all you need ;)
11:15:50 <dmead> beecause iteration is usually not good in a functional language
11:16:15 <adi> :|
11:16:41 <dmead> why do you need iteration?
11:16:59 <adi> the teacher told us to try to do 'for'
11:17:11 <Excedrin> > @let a = 1
11:17:12 <lambdabot>  Parse error
11:17:18 <dmead> weird
11:17:20 <Excedrin> @let a = 1
11:17:20 <lisppaste2> Tzintzi pasted "while" at http://paste.lisp.org/display/30949
11:17:21 <lambdabot> <local>:13:0:     Multiple declarations of `L.a'     Declared at: <local>:8:0...
11:17:29 <w-ber> > let a = 1
11:17:29 <lambdabot>  Parse error
11:17:31 <Excedrin> @let foo = 1
11:17:33 <lambdabot> Defined.
11:17:36 <adi> http://paste.lisp.org/display/30949
11:17:41 <Excedrin> > L.foo
11:17:43 <lambdabot>  1
11:17:44 <metaperl> Cale - ping... dons - ping?
11:17:46 <adi> this is for 'while'
11:18:04 <w-ber> How do I count with and print arbitrary precision reals?
11:18:16 <adi> I'd like to do the equivalent for 'for'
11:18:20 <Igel> adi: is it a parser?
11:18:25 <adi> yeah
11:18:38 <metaperl> w-ber - I understand external libs to haskell are needed for that
11:18:45 <w-ber> Right.
11:19:44 <metaperl> w-ber - what do you mean count with?
11:20:10 <Igel> adi: then for is just like while
11:20:11 <Excedrin> how do you get literal < in markdown?
11:20:20 <Igel> only you have 3 expressions
11:20:54 <Igel> for (init; condition; count) { expression }
11:21:32 <w-ber> metaperl: No roundings. :) I know that's a bit hard to do if you use irrational or transfinite numbers, though.
11:21:47 <adi> could you annotate it ? I'd understand better if I see it done
11:21:57 <metaperl> w-ber why are trying to count with floats?
11:22:45 <Igel> the thing is, i don't know your data structures and functions well enough to write working code
11:23:11 <adi> I gave out the entire code
11:23:18 <adi> http://tzintzi.info/haskell.hs
11:24:07 <Igel> and i don't feel like reading it all ;) - i'm also not able to understand the comments
11:24:10 <Excedrin> oh, reddit is just broken wrt < -> &lt;.. markdown isn't supposed to translate stuff in code blocks apparently
11:46:59 <astrolabe> What is a good way to implement sum for large lists?
11:47:38 <dolio> What do you mean good?
11:47:46 <dolio> Doesn't overflow the stack?
11:47:50 <astrolabe> yeah
11:48:06 <dolio> foldl' (+) 0
11:48:18 <astrolabe> ooh
11:48:25 <dolio> sum overflowing is kind of a bug, though, I think.
11:48:26 <astrolabe> @hoogle foldl'
11:48:27 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
11:48:49 <astrolabe> dolio: why do you say that?
11:49:49 <Excedrin> sum in ghc shouldn't overflow the stack, it's defined in a tail recursive way
11:50:10 <flux__> isn't tail recursion poison in haskell?-)
11:50:31 <Excedrin> the report_prelude version is not tail recursive
11:50:32 <astrolabe> It does overflow the stack
11:50:40 <dolio> I thought the consensus was that sum overflowing was a defect in whatever optimizer.
11:50:45 <astrolabe> but I think it is a different point to tail recursion.
11:51:08 <dolio> The problem is that tail recursion isn't optimized for strictness unless you do it specifically, or use foldl'.
11:51:09 <astrolabe> (it overflows in ghc, even for compiled code)
11:51:48 <dolio> Because a non-strict-accumulator like foldl will just build a nested structure of thunks that is just as bad as being non-tail recursive.
11:52:00 <flux__> I wonder if eager haskell has had any advances, or is it a dead project
11:52:09 <Excedrin> ah, ok I still forget about strictness
11:52:11 <flux__> (it attempts to do things eagerly, while maintaining lazy semantics)
11:52:45 <pejo> flux, by Ennals, Peyton Jones, and possibly others?
11:53:04 <flux__> sorry, I don't remember ;)
11:53:44 <Excedrin> maybe the prelude should use sum' xs $! a+x instead of sum' xs (a+x)
11:54:02 <dolio> Anyhow, I've heard that sum, length, etc. are not defined tail recursively, but it should be possible to optimize them not to blow up. I might be mistaken, though.
11:54:29 <astrolabe> Thanks
11:54:37 <dolio> ?index sum
11:54:38 <lambdabot> Data.List, Prelude
11:54:43 <dolio> ?fptools Data.List
11:54:44 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
11:55:08 <Excedrin> dolio: it depends if USE_REPORT_PRELUDE is defined or not
11:55:20 <Excedrin> the report versions are not tail recursive
11:55:22 <dolio> Ah.
11:55:32 <dolio> Oh yeah, I see.
11:56:18 <Excedrin> I'm not sure if there's a good reason for the optimized sum to be lazy though
11:56:20 <dolio> Actually, according to the link above...
11:56:21 <flux__> pejo, I'm referring to http://www.csg.csail.mit.edu/pubs/haskell.html
11:56:26 <lambdabot> Title: Computation Structures Group, http://tinyurl.com/y3ze3y
11:56:29 <flux__> (maybe, dunno if there are others)
11:56:42 <dolio> if USE_REPORT_PRELUDE, sum = foldl (+) 0
11:56:51 <dolio> Which blows up because foldl isn't strict enough.
11:57:21 <dolio> And otherwise it uses a custom written accumulator, which doesn't look any better.
11:57:59 <vincenz> > foldl' (+) 0 [1..100000]
11:58:01 <lambdabot>  5000050000
11:58:04 <pejo> flux, ah, Maessen.
11:58:08 <dolio> But the + is inlined.
11:58:19 <Excedrin> > sum [1..100000]
11:58:21 <lambdabot>  5000050000
11:58:29 <vincenz> > foldl' (+) 0 [1..10000000]
11:58:33 <lambdabot> Terminated
11:58:37 <vincenz> > foldl' (+) 0 [1..1000000]
11:58:39 <lambdabot>  500000500000
11:58:45 <vincenz> > sum [1..1000000]
11:58:47 <lambdabot>  500000500000
11:58:58 <astrolabe> hmmm
11:59:13 <sjanssen> dolio: in Haskell, you can blow up the stack even when you use tail recursion
11:59:23 <astrolabe> that breaks on my ghc at work
11:59:39 <sjanssen> astrolabe: lambdabot compiles with -O, that's likely the difference
11:59:55 <dolio> I don't see why sum, length, etc. should be lazy in the accumulator. There's no way that the result will take more space than the next of thunks, is there?
11:59:57 <astrolabe> I tried with -O2
12:00:21 <sjanssen> dolio: they shouldn't be lazy
12:00:25 <dolio> And there's no way to get a partial result.
12:01:02 <sjanssen> astrolabe: you tried "sum [1..x]", and compiled with -O, and you got a stack overflow?
12:01:07 <dolio> sjanssen: Right, but they are, no?
12:01:14 <dolio> Currently.
12:01:45 <sjanssen> dolio: not explicitly.  I think GHC's optimizer does the right thing with -O, though
12:02:09 <astrolabe> sjanssen it was -O2 I think, and maximum rather than sum.  Also I may be misremembering
12:02:17 <astrolabe> I'll try it now
12:03:07 <dolio> Ah, yeah, I guess it works in 6.6 now.
12:03:21 <dolio> It was broken in 6.4, wasn't it?
12:03:28 <dolio> Hence it not working with lambdabot?
12:03:57 <sjanssen> dolio: not to my knowledge
12:04:13 <dolio> It used to be possible to get lambdabot to overflow the stack with such things.
12:04:26 <dolio> > sum [1..2000000]
12:04:30 <lambdabot>  2000001000000
12:04:33 <sjanssen> lambdabot didn't always get -O when compiling
12:04:36 <dolio> > sum [1..3000000]
12:04:40 <lambdabot>  4500001500000
12:04:43 <dolio> Ah, I see.
12:04:52 <sjanssen> that was changed a month or two ago
12:05:20 <sjanssen> astrolabe: both maximum [1..] and sum [1..] run in constant memory over here
12:05:32 <sjanssen> with -O2
12:05:37 <dylan> > sum [1..]
12:05:41 <lambdabot> Terminated
12:06:55 <sjanssen> dolio: having said all this, I tend to agree that sum should use explicit strictness -- foldl' probably
12:07:31 <Excedrin> there must be a reason why it's lazy, no?
12:08:00 <sjanssen> I don't see any good reason
12:08:50 <dolio> foldl doesn't get strictified, it seems.
12:09:05 <astrolabe> sjanssen: same here.  Thanks all.
12:09:45 <sjanssen> dolio: with -O, GHC often adds strictness to foldl
12:09:51 <sjanssen> the strictness analyzer is pretty smart
12:10:19 <sjanssen> but I'd rather see explicit strictness, just in case you use a compiler that isn't as nice as GHC
12:11:14 * dolio sends his computer into swapping with foldl (+) 0 [1..10000000]
12:18:33 <dmead> >foldl (+) 0 [1..10000000]
12:18:39 <dmead> >:)
12:18:53 <lispy> need a spac
12:18:53 <dolio> That probably won't make it under the 3 second limit.
12:18:58 <dmead> > foldl (+) 0 [1..10000000]
12:19:02 <lambdabot> Terminated
12:19:05 <dmead> ah ah
12:19:09 <dmead> > foldl (+) 0 [1..10]
12:19:10 <lambdabot>  55
12:19:12 <dmead> hmm
12:19:16 <dmead> > foldl (+) 0 [1..100]
12:19:17 <lambdabot>  5050
12:19:20 <dmead> > foldl (+) 0 [1..1000]
12:19:22 <lambdabot>  500500
12:19:23 <lispy> > foldl' (+) 0 [1..10000000]
12:19:24 <dmead> > foldl (+) 0 [1..10000]
12:19:27 <lambdabot> Terminated
12:19:28 <lambdabot>  50005000
12:19:32 <dmead> > foldl (+) 0 [1..100000]
12:19:33 <lambdabot>  5000050000
12:19:37 <dmead> > foldl (+) 0 [1..1000000]
12:19:39 <lambdabot>  Exception: stack overflow
12:19:42 <dmead> oof
12:19:43 <dmead> > foldl (+) 0 [1..1000000]
12:19:44 <lispy> oh hm...with numbers the prime probably doesn't help?
12:19:45 <lambdabot>  Exception: stack overflow
12:19:48 <dmead> bam
12:20:01 <lispy> > foldl' (+) 0 [1..1000000]
12:20:03 <lambdabot>  500000500000
12:20:06 <lispy> ah, it does help
12:20:14 <dmead> i posted my java frontend to ##java and reddit
12:20:19 <dmead> they said it was evil
12:20:20 <lispy> nice
12:20:24 <dmead> and a sick fetish
12:20:24 <dmead> lol
12:24:05 <Excedrin> the java part spawns the haskell part?
12:26:12 <eviltwin_b> toldja so :>
12:26:57 <newsham> adam and sophy
12:27:02 <newsham> oopz
12:27:13 <newsham> bad mouse
12:27:33 <dmead> http://programming.reddit.com/info/svdb/comments
12:27:35 <dmead> yea
12:27:36 <lambdabot> Title: sexy java and haskell interaction (reddit.com), http://tinyurl.com/wkgs8
12:33:23 <emu> dmead: did you say you have a java program which communicates back and forth with a haskell program?
12:33:46 <dmead> yes
12:33:52 <dmead> well
12:33:55 <dmead> it's one way really
12:33:57 <emu> what are you using to do this
12:34:06 <dmead> the java api
12:34:12 <emu> ffi?
12:34:17 <emu> jni or whatever
12:34:22 <dmead> nah
12:34:23 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/provergui1.png
12:34:25 <lambdabot> http://tinyurl.com/yeya68
12:34:28 <dmead> look at the ss
12:34:38 <dmead> you can see the relavant code in the java window
12:35:09 <emu> oh just running a subprocess
12:35:12 <dmead> proverApp is my haskell binary
12:35:12 <dmead> yea
12:35:34 <dmead> i don't really see that as being too different from an JNI/FFI call
12:35:35 <emu> i've been pondering a means to get some long-running interaction going
12:35:50 <dmead> well
12:35:57 <emu> besides sockets =)
12:35:59 <dmead> the output stream blocks the java thread there
12:36:11 <dmead> until the called app returns something
12:36:42 <vincenz> noice
12:37:28 <w-ber> http://ps3.shimpinomori.net/index_en.html
12:37:52 <dmead> o0
12:38:06 <dmead> emu: check out memory pipes
12:39:46 <emu> er, what's that?
12:40:40 <chessguy> anybody seen/done any monte carlo stuff in haskell?
12:43:27 <dmead> emu: in unix you can open pipes inside a machine to transfer around bits of data
12:43:42 <dmead> like a network socket, but its all inside ram
12:43:58 <emu> you mean unix sockets
12:44:08 <emu> yea sure, still is networking
12:44:17 <emu> or fifos
12:44:21 <dmead> right
12:44:22 <dmead> oh
12:44:23 <dmead> hmm
12:44:26 <emu> anyhow, i already have the code to do tcp sockets
12:45:23 <beschmi> the advantage of unix domain sockets is that you can specify file permissions
12:45:26 <emu> i was just wondering if anyone had come up with a more transparent mechanism
12:45:34 <dmead> http://www.linux.com/guides/lpg/node11.shtml
12:45:36 <lambdabot> Title: Linux.com - 6.2.2 Creating Pipes in C
12:45:44 <dmead> not sockets
12:45:45 <dmead> pipes
12:46:04 <emu> yea yea named fifos
12:46:10 <dmead> oh
12:46:11 <dmead> =p
12:46:27 <emu> i still have to do all the work of transfering data structures across an octet stream
12:46:37 <emu> no big deal
12:46:54 <dmead> i just parse text output :)
12:48:00 <emu> or maybe loading a haskell library into the java program
12:56:17 <eviltwin_b> mrf
12:56:41 <eviltwin_b> Data.FiniteMap
13:02:00 <dmead> emu: using the jni?
13:02:49 <emu> i suppose
13:09:06 <dmead> i think i saw examples of haskell being called easily from C a while back
13:18:32 <emu> do people still use the | a `seq` b `seq` False = undefined trick for  making a function strict, or is the better way now?
13:21:40 <mauke> emu: http://haskell.org/ghc/docs/latest/html/users_guide/sec-bang-patterns.html
13:21:42 <lambdabot> Title: 7.8. Bang patterns, http://tinyurl.com/y97x8f
13:29:13 * SamB doesn't much like the Show instance for IntSets in 6.6...
13:31:15 <kosmikus> I'm planning to release the HCAR tomorrow (finally). I know it's been a long time since the deadline. Is there anyone around who would like to make some last-minute changes or updates?
13:31:51 <metaperl> what does HCAR mean?
13:31:55 <metaperl> @seen dons
13:31:56 <lambdabot> dons is in #haskell.hac07, #ghc, #haskell-overflow, #haskell and #Haskell. I last heard dons speak 6h 51m 42s ago.
13:32:09 <ibid> kosmikus: just to verify that you have the planet entry :)
13:32:25 <metaperl> @seen Cale
13:32:26 <lambdabot> Cale is in #scheme, #oasis, #haskell and #ghc. I last heard Cale speak 5h 8m 12s ago.
13:32:51 <kosmikus> ibid: I have the planet entry :)
13:33:09 <shanky_> @seen shoffsta
13:33:09 <lambdabot> shoffsta is in #haskell. I don't know when shoffsta last spoke.
13:33:12 <kosmikus> @where hcar
13:33:12 <lambdabot> http://www.haskell.org/communities/
13:33:16 <kosmikus> metaperl: ^^
13:33:22 <ibid> kosmikus: good :)
13:33:39 * metaperl browses
13:37:22 <SamB> hmm.
13:37:40 * ibid tries to create slides
13:37:40 <newsham> hi
13:37:49 <SamB> apparantly the reason that my solver was taking so long is that I was having it try things in the wrong order.
13:37:58 <SamB> well, actually, it wasn't the wrong order before...
13:38:27 <ibid> isn't that the usual reason why provers go wrong :)
13:39:05 <SamB> hmm.
13:39:15 <SamB> something is wrong. oh, maybe I didn't paste right.
13:39:41 <SamB> ah, yeah, missed a line...
14:00:43 <lisppaste2> metaperl pasted "No instance for (Eq a) -- help needed" at http://paste.lisp.org/display/30959
14:01:06 <emu> if i do a binding like (!a, !b) = partition ... does that mean both a and b are fully evaluated before proceeding with the rest of the function?
14:02:48 <kolmodin> metaperl: to use the Eq class you have to change the type of sublist to "sublist :: Eq a => [a] -> [a] -> Bool"
14:03:02 <metaperl> I'm sorry for pasting that whole file
14:03:07 <kolmodin> type/signature
14:03:09 <kolmodin> np
14:03:14 <metaperl> oh thank you kolmodin
14:03:28 <metaperl> thanks for reading to the bottom kolmodin ... i was being absent-minded
14:03:56 <kolmodin> if you get that again and wonder whats wrong, comment out the type and load it into ghci and type ":t sublist"
14:04:01 <kolmodin> it will tell you the type
14:04:20 <metaperl> got it
14:08:29 <metaperl> @hoogle tails
14:08:30 <lambdabot> List.tails :: [a] -> [[a]]
14:08:30 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
14:13:46 <metaperl> this hoogle thing is beautiful
14:13:47 <metaperl> http://haskell.org/hoogle/?q=%5Ba%5D+-%3E+%28a+-%3E+Bool%29+-%3E+%5Ba%5D
14:13:50 <lambdabot> Title: [a] -> (a -> Bool) -> [a] - Hoogle, http://tinyurl.com/tuh4o
14:13:58 <metaperl> pretty colors. robust output
14:14:01 <metaperl> highly useful
14:15:52 <newsham> [a] -> Hoogle
14:15:55 <emu> huh, this foldl' stuff doesn't seem to be acting strict
14:16:38 <blsecres> is there a method to access a system arp table?
14:17:22 <newsham> blsecres: i'd guess no (but would be glad to be wrong :)  good news though is that if you dont care about portability, you can probably read it from /proc easily
14:17:24 <emu> metaperl: you can get a command line version, also attach it to emacs
14:17:39 <metaperl> ah.
14:17:47 <newsham> like /proc/net/arp on linux
14:17:51 <metaperl> i'll stick with the bling bling version :)
14:18:06 <newsham> if you want portability, please write FFI bindings for libdnet :)
14:18:12 <metaperl> though I am a religious XEmacs user
14:19:16 <emu> so if you had some expression: "foldl' f state0 $ take n list" and as you increased n from 0..10 the space usage (and gc thrashing) jumped exponentially (at values 1..6 it's not bad, then it starts to jump up), would you say that means the function f is holding onto some reference to older data?
14:21:15 <sjanssen> emu: probably
14:21:41 <blsecres> newsham: thanks, it's not linux...oh well
14:26:01 <metaperl> sweet waters and light laughter until next
14:58:10 <mgsloan> I do believe my version of split has run amok:
14:58:16 <mgsloan> split ((|-(not . isAlpha)) ||| (|+(`elem`"{}")))
14:58:19 <mgsloan> ehehe
14:59:44 <Botje> mgsloan: shoot it in the back! while it's not looking!
15:00:17 <mgsloan> actually that has to be split ( (|+(`elem`"{}")) ||| (|-(not . isAlpha)) ). It will discard anything but alphas, yet split with {} and keep them
15:00:44 <mgsloan> Botje - heh, probably should
15:02:26 <mgsloan> split ( keep (`elem`"{}") ||| delete (not . isAlpha) )
15:02:34 <mgsloan> this is probably better
15:04:05 <shapr> @yow !
15:04:05 <lambdabot> HAIR TONICS, please!!
15:04:18 <shapr> Samedi: Baron Samedi?
15:04:19 <monochrom> 1 < 0
15:04:51 <mgsloan> what's sad is my split doesn't even handle multichar split toks.  I can see why it'd be hard to instate a standard one
15:05:12 <dons> moin!
15:05:15 <monochrom> Are |- and |+ operators you created?
15:05:18 <dons> ?users
15:05:18 <lambdabot> Maximum users seen in #haskell: 276, currently: 261 (94.6%), active: 37 (14.2%)
15:06:41 <monochrom> Hee hee hee,  I should go revise my Haskell proof checker to use the A |- p syntax!
15:06:43 <mgsloan> monochrom: yep, realized it looks alot better to change to 'delete' and 'keep' though
15:07:56 <dons> mmm "Lisp Without Parentheses Project"
15:08:27 <monochrom> How to resolve precedence problems without parentheses?
15:08:49 <dons> use $ and infixr n settings?
15:09:02 <dons> infixl/infixr/infix 0-9
15:09:07 <mgsloan> yeah, for that i did infixr
15:09:14 <mgsloan> the ||| operator I'm keeping
15:10:21 <mgsloan> unless there is a better operator name for something that combines split terms
15:10:40 <SyntaxNinja> dons: what's the web page for the upcoming hackathon?
15:13:22 <dons> ?wiki Hac_2007
15:13:22 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007
15:13:38 <SyntaxNinja> thanks
15:14:00 <dons> SyntaxNinja: I like the new carrot/stick concept. I think it will be highly motivating. good idea
15:14:28 <emu> dons: you mentioned someone wrote a fps lexer for Parsec? is that available?
15:14:34 <dons> ?where bytestringparser
15:14:35 <lambdabot> http://hackage.haskell.org/~paolo/darcs/ByteStringParser
15:15:20 <SyntaxNinja> dons: which one?
15:15:28 <SyntaxNinja> dons: thank (blame) malcolm_ :)
15:16:23 <dons> SyntaxNinja: sticks are good
15:16:30 <dons> at least I know they are for me :)
15:16:51 <dons> malcolm++
15:16:54 <SyntaxNinja> dons: what's brown & sticky?
15:17:08 <dons> dare I ask what?
15:17:13 <SyntaxNinja> a stick!
15:17:19 <dons> oh, of course!
15:17:19 <SyntaxNinja> What do you call a boomerang that doesn't come back?
15:17:26 <dons> mmm broken?
15:17:29 <SyntaxNinja> a stick!
15:17:36 <dons> ah that's true!!
15:17:53 <calvins> dons: fyi: that bug you filled was updated (http://hackage.haskell.org/trac/hugs/ticket/50). Seems ghc is correct and hugs doesn't fully comply with haskell98.
15:17:56 <lambdabot> Title: #50 (Hugs's implementation of defaulting does not conform to Haskell 98) - Hugs  ..., http://tinyurl.com/y8pqgs
15:18:11 <dons> calvins: ah very interesting
15:18:55 <robreim> How do you people manage to reach these hackathons? Do your employers / universities sponsor you or something?
15:19:31 <dons> robreim: well, its in the UK, so UK hackers can afford it, its also just before the big POPL conference, so people can (well I can) get funding to fly there
15:20:04 <dons> the idea is to hold these next to either POPL or ICFP, where people will already have uni/work funding to get to the location
15:20:16 <SyntaxNinja> robreim: ie slip 'em in under the radar ;)
15:20:23 <dons> (rather than say, like OpenBSD, where you fly to calgary on your own money -- much harder)
15:20:28 <SyntaxNinja> robreim: or in my case, my employer sponsored the whole thing (the ghc hackathon)
15:20:30 <robreim> ahh I get it :)
15:20:35 <Syzygy-> SyntaxNinja: Neat!!
15:20:52 <SyntaxNinja> well, actually, PSU sponsored too
15:21:02 <robreim> wow, nice. You get paid to hack haskell, SyntaxNinja?
15:21:06 * SyntaxNinja slaps own hand
15:21:20 <dons> SyntaxNinja: I'm still thinking about the SoC contest too, btw. I suspect I'll have something sorted by January .. I don't see any reason to rush it out before then?
15:21:20 <SyntaxNinja> robreim: yep.  we have quite a number of haskell hackers
15:21:29 <robreim> wait, two groups are sponsoring you? So you get to pocket one sponsorship?
15:21:33 <SyntaxNinja> I'm actually sitting in a room w/ Manuel, Iavor, and David Roundy talking about patch logic :)
15:21:46 <dons> SyntaxNinja: right now?
15:21:57 <SyntaxNinja> robreim: Galois and PSU jointly sponsored the hackathon itself (hosting, handouts, etc.)
15:22:01 <SyntaxNinja> dons: yeah
15:22:14 <dons> oh, nice.
15:22:18 <robreim> Ah I see
15:22:44 <SyntaxNinja> dons: OK.  I was thinking maybe we could use the $ to pay a sysadmin or something.
15:22:47 <dons> mmm. we need to clean up darcs code, its being used to mock haskell now ... http://superzealot.blogspot.com/2006/11/go-haskell.html
15:22:49 <lambdabot> Title: Super Zealot: Go Haskell!, http://tinyurl.com/yar95k
15:23:18 <dons> SyntaxNinja: mm. ok. I don't see the necessity though. is there a lot of admin we need done?
15:23:21 <Binkley> dons: yes, I tried looking at the darcs sources the other day and the first line I looked at used *both* head and fromJust
15:23:26 <dons> (maybe there will be once we've got hackage up..)
15:23:26 <Binkley> :......-(
15:23:42 <dons> yeah. its a bit unhaskelly unfortunately
15:24:02 <Binkley> heh, "Clean as a heroin addicted prostitute in Brooklyn."
15:24:07 <dons> SyntaxNinja: another idea is to sponsor students to a future hackathon
15:24:10 <SyntaxNinja> dons: heh
15:24:31 <SyntaxNinja> dons: yeah, idono.
15:24:51 <dons> i'm still pretty excited about the contest though. and seems like not a lot of work
15:26:17 <dons> ?users
15:26:17 <lambdabot> Maximum users seen in #haskell: 276, currently: 258 (93.5%), active: 36 (14.0%)
15:26:29 <sjanssen> contest?
15:26:55 <dons> sjanssen: just planning what to do with the soc funding :)
15:28:35 <dons> sjanssen: so is school over for the year yet? do you still have exams to go?
15:28:57 <sjanssen> dons: still got a couple weeks
15:29:27 <dons> studying hard?
15:30:13 <vincenz> remind me how to get args in haskell?
15:30:19 <dons> ?hoogle args
15:30:19 <lambdabot> Distribution.Simple.Args :: type Args
15:30:20 <lambdabot> System.getArgs :: IO [String]
15:30:20 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
15:30:26 <dons> item #2
15:30:33 <vincenz> thx
15:30:39 <dons> ?hoogle how to get args in haskell?
15:30:40 <lambdabot> Did you mean: How To Get Args In Haskell?
15:30:40 <lambdabot> Prelude.undefined :: a
15:30:40 <lambdabot> Test.QuickCheck.Batch.bottom :: a
15:30:42 <dons> hehe
15:30:47 <dons> we should bug ndm about that
15:30:51 <dons> ?google how to get args in haskell?
15:30:53 <lambdabot> http://www.defmacro.org/ramblings/lisp-in-haskell.html
15:30:53 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell
15:30:53 <sjanssen> dons: not too hard yet.  Exams are the week of Dec. 11, so I've got a bit before crunch time
15:30:58 <dons> cool
15:31:06 <Pseudonym> Maybe we need something like Ask Jeeves.
15:31:37 <Pseudonym> "Ask Crichton".
15:31:44 <dons> mmm
15:32:26 <Pseudonym> Actually, Lurch from The Addams Family might be a more appropriate fictional butler.
15:33:12 <sjanssen> hmm, this code may cause me to write my very first darcs patch
15:33:24 * mgsloan thought it was like Kriten, if you're talking about red dwarf
15:33:34 <mgsloan> Kriton... hmm
15:33:37 <Pseudonym> You illiterate programmer-types, you.
15:33:38 <dons> sjanssen: would be a good idea...
15:33:45 <Pseudonym> It's spelled "Kryten"!
15:33:47 <psnl> dons: how do you store state in a lambdabot plugin?
15:33:49 <Pseudonym> Don't you know ANYTHING?
15:33:53 <dons> SyntaxNinja: you'll have to tell D Roundy about that code...
15:33:56 <mgsloan> ohh yeah
15:34:03 <mgsloan> that does look right :P
15:34:12 <dons> psnl: the state argument to the Module instance for the plugin defines a custom private state type
15:34:21 <robreim> regarding icfp 2006; There was some pretty wacky languages that "won". Am I correct that the only reason those languages won was because the tasks required contestants to program in those languages a little (eg D and asm) and the contestants thought it'd be funny to declare them their language of choice, not because they were the primary languages?
15:34:25 <dons> look in the, say, @where or @karma plugin
15:34:34 <dons> robreim: right
15:34:38 <psnl> dons: which, when the plugin is called, is passed back in?
15:34:44 <mgsloan> and no, I don't know much.  whenever I use a fold I look up the particular version to see the order of the parameters
15:34:50 <dons> psnl: its available, yes.
15:34:57 <robreim> bummar. Though amusing it really puts a taint on the ICPF scores.
15:34:57 <Pseudonym> I think it's more correct that some languages are better for weird competitions than others.
15:35:07 <vincenz> grr
15:35:10 <vincenz> --make -main-is
15:35:11 <Pseudonym> The ICFP contest encourages fast-and-loose RAD.
15:35:12 <SamB_XP> robreim: well, given the name of the team that got first place...
15:35:13 <dons> robreim: http://sequence.complete.org/hwn/20060927 for the full story
15:35:14 <vincenz> it's confusing the number of dashes
15:35:24 <psnl> dons: thanks, I'll go back to writing a plugin soon
15:35:55 <Pseudonym> OK, this doesn't surprise me.  Kryten is, indeed, named after Crichton from the J.M. Barrie play.
15:37:38 * shapr boings!
15:37:47 <profmakx> boioioioing
15:38:04 <sjanssen> why does darcs_use_names_like_so ?  namesLikeThisAreMoreTypical
15:38:07 <SyntaxNinja> dons: we'll see... he looks like he's having fun, wouldn't want to spoil his day ;)
15:38:14 <dons> hehe
15:38:27 <SyntaxNinja> I'm not forwarding random questions to david right now :P
15:38:33 <dons> sjanssen: written when David was learning haskell?
15:38:35 <zarvok> robreim: the icfp team who picked ASM actually hand coded their UM in asm
15:38:45 <dons> hey zarvok
15:38:45 <zarvok> and the D team used D
15:38:48 <zarvok> hey dons
15:39:06 <dons> zarvok: the ICFP contest article was the most popular HWN edition this year, I think
15:39:23 <zarvok> dons: cool
15:42:07 <vincenz> @hoogle prefix
15:42:08 <lambdabot> Distribution.Simple.Configure.prefix :: LocalBuildInfo -> FilePath
15:42:08 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
15:42:08 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
15:42:28 <mgsloan> Is there a literal syntax for Data.Map s?
15:42:39 <vincenz> > True
15:42:40 <lambdabot>  True
15:43:18 <sjanssen> mgsloan: nope
15:43:35 <dons> > M.fromList [('x',1),('y',2)] :: M.Map Char Int
15:43:36 <lambdabot>  {'x':=1,'y':=2}
15:43:43 <dons> > show $ M.fromList [('x',1),('y',2)] :: M.Map Char Int
15:43:44 <lambdabot>  Couldn't match `Data.Map.Map Char Int' against `String'
15:43:44 <sjanssen> but "Data.Map.fromList [(key1, elem1), ..]" isn't so bad
15:43:49 <dcoutts_> @seen ndm
15:43:50 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 7h 46m 18s ago, and .
15:43:52 <dons> > show (M.fromList [('x',1),('y',2)] :: M.Map Char Int)
15:43:54 <lambdabot>  "{'x':=1,'y':=2}"
15:43:58 <mgsloan> sjanssen - alright
15:44:09 <mgsloan> thanks
15:44:13 <dons> > read "{'x':=1,'y':=2}" :: M.Map Char Int -- not going to work, is it?
15:44:13 <lambdabot>  add an instance declaration for (Read (Data.Map.Map Char Int))
15:44:14 <lambdabot>   In the e...
15:44:17 <dons> no.
15:44:17 <sjanssen> I think that show instance is different in GHC 6.6
15:44:53 <dons> "fromList [('x',1),('y',2)]"
15:44:55 <dons> quite so
15:45:19 <dons> huh and the read works:
15:45:20 <mgsloan> ?type id
15:45:20 <dons> Prelude Data.Map> read "fromList [('x',1),('y',2)]" :: Map Char Int
15:45:21 <dons> fromList [('x',1),('y',2)]
15:45:22 <lambdabot> forall a. a -> a
15:45:25 <mgsloan> good
15:45:31 * mgsloan was worried it'd do some monad carp
15:45:48 <lisppaste2> dibblego pasted "what am I screwing up in bind?" at http://paste.lisp.org/display/30964
15:46:09 <mgsloan> at least that show doesn't decieve you into thinking there's a literal syntax for maps :)
15:48:43 <sjanssen> dibblego: do you want to see the answer?
15:48:51 <vincenz> @where bytestring
15:48:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:48:57 <dibblego> sjanssen, yes please, I've tried pretty hard
15:53:01 <dibblego> I don't see where the problem is
15:54:47 <lisppaste2> sjanssen annotated #30964 with "solution" at http://paste.lisp.org/display/30964#1
15:55:27 <sjanssen> dibblego: I think using the record complicates things.  Also "a" is a really bad name for a record selector ;)
15:56:06 <dibblego> I could use a tuple, but I much prefer a data type
15:56:33 <sjanssen> why?  State seems almost too trivial to name
15:59:25 <dibblego> because I'm a pedantic bastard
15:59:59 <lisppaste2> sjanssen annotated #30964 with "typical definition" at http://paste.lisp.org/display/30964#2
16:00:26 <Excedrin> name the fields fst and snd
16:01:02 <sjanssen> fst, snd ... sounds familiar
16:01:12 <lispy> dibblego: "a" is a bad record name because the records names have module scope :(
16:01:20 <dibblego> yes I know
16:01:34 <lispy> in fact, most record names are bad because of htath
16:01:40 <robreim> You don't need to name the fields at all - pattern matching would probably be more clear in that case
16:02:05 <lispy> for a while i was doing, foo'Bar for the bar field of the foo record
16:02:29 <lispy> it's tedious to keep typing it though
16:03:23 * eviltwin_b thinks that sounds like an ancent Perl programmer at work :>
16:03:41 <jdev> Perl got it from Ada.
16:04:24 <Binkley> and Ada got it from Agnes
16:04:26 * eviltwin_b is just glad Perl ditched it
16:04:34 <lispy> eviltwin_b: i sound like a perl programmer?
16:04:42 * lispy shudders
16:05:03 <eviltwin_b> ' used to be the package separator (modern perl uses ::, like C++/Java/etc.)
16:05:23 <lispy> i see...
16:05:32 <lispy> i'm not smart enough to program in perl
16:05:40 <robreim> Religion is such an amusing thing to watch. I imagine if someone accused someone in #perl of sounding like a haskell programmer they'd shudder too.
16:06:05 <lispy> robreim: i could see that
16:06:13 <eviltwin_b> no, they'd just assume he was a perl6 dev :>
16:06:14 <JKnecht> seems doubtfull with perl6 being haskell based
16:06:33 <dibblego> go and try it
16:06:36 <sjanssen> lispy: judging from Larry Wall's comments on Haskell, I think the average Perl-er would find that statement funny
16:06:42 <sjanssen> coming from a #haskell regular
16:07:42 <robreim> ooh, wall quotes on haskell? Got any links? If there's one great thing about Perl, it's Larry and his jokes :)
16:07:52 <dons> check the HWN
16:07:53 <vincenz> grrr
16:07:54 <dons> ?where hwn
16:07:55 <sjanssen> robreim: oh, there are tons
16:07:55 <lambdabot> http://sequence.complete.org/
16:08:02 <lispy> mm...dons beat me to it
16:08:04 <rahikkala> It seems that I have a function which produces a tiny amount of data (eight lists of lists of two ints in this case), and which is called with the same arguments every single time during a program run... but if I understand ghc's profiling output correctly 25% or more of the cycles for this program are spent in that function
16:08:06 <dons> robreim: grep for 'Larry' and 'TimToady'
16:08:27 <dons> rahikkala: can you paste the code?
16:08:28 <dons> ?paste
16:08:28 <lambdabot> http://paste.lisp.org/new/haskell
16:08:35 <sjanssen> @quote TimToady
16:08:36 <lambdabot>  learning Haskell itself is easy--I've done it several times already
16:08:36 <JKnecht> also seems silly for wage labor slaves to cop attitudes about the tools they use in one and the same ultimate social relation
16:09:20 <lispy> JKnecht: what you just said is beyond my comprehension
16:09:50 <Binkley> heh
16:10:10 <Binkley> we can handle category theory on this channel, but not social theory
16:10:14 <sjanssen> rahikkala: if you're expecting GHC to cache the results of evaluating that function, it might not be happening
16:10:38 <Binkley> ranihkkala: keep in mind that when you run with cost-centre profiling on, a lot of optimizations get disabled
16:10:41 <Binkley> so it's a little misleading
16:10:46 * JKnecht wonders if there's a haskell topoi package.
16:10:55 <lisppaste2> rahikkala pasted "memoize it already!" at http://paste.lisp.org/display/30965
16:10:58 <sjanssen> JKnecht, topoi?
16:11:32 <JKnecht> sjanssen: categorical treatement of logic/model theory.
16:11:55 <sjanssen> rahikkala: which call do you want to memoize?
16:12:06 <rahikkala> sjanssen: all_raw_moves
16:12:25 <robreim> This one surprises me: "Larry Wall: Take Lisp, you know it's the most beautiful language in the world -- at least up until Haskell came along." I thought he was also on record for commenting how ugly lisp is...
16:12:35 <Binkley> maybe that was sarcastic
16:12:53 <newsham> robreim: dont do drugs, kids.
16:14:33 <sjanssen> rahikkala: as it stands, all_raw_moves will be evaluated once each call of all_moves_on_tile.  Is this sufficient?
16:16:12 <rahikkala> sjanssen: Well, it sure would be cool if there was a way to get it evaluated once and just use that one value for all the later calls, since, well, it would make things faster :)
16:16:33 <Pseudonym> http://www.artima.com/weblogs/viewpost.jsp?thread=186200
16:16:35 <lambdabot> Title: Typing like a Functional Programmer, http://tinyurl.com/y8qv42
16:17:14 <Pseudonym> Nothing we don't know, but it might be worth pointing a newbie to.
16:17:42 <robreim> Heh... for a second I thought that title implied functional programmers use special keys or keymaps when they type or something.
16:17:51 * lispy too
16:17:53 * Pseudonym laughs
16:17:56 * TSC too
16:17:58 <Pseudonym> Like the space cadet keyboard.
16:18:08 <Pseudonym> ?google dec space cadet keyboard
16:18:12 <lambdabot> http://www.ctrl-c.liu.se/~ingvar/jargon/s.html
16:18:12 <lambdabot> Title: = S =
16:18:23 <dons> nice Pseudonym
16:18:24 <lisppaste2> sjanssen annotated #30965 with "poor mans memo table" at http://paste.lisp.org/display/30965#1
16:18:47 <newsham> how does lambdabot type?
16:18:50 <vincenz> > group [1,2,1]
16:18:51 <hyrax42> even though I knew what currying was beforehand, it took an "aha" to get partial application
16:18:52 <lambdabot>  [[1],[2],[1]]
16:18:53 <newsham> ?type (:)
16:18:55 <lambdabot> forall a. a -> [a] -> [a]
16:19:03 <dcoutts_> oh, gtk+ 2.10.x is now stable on Gentoo, time to test Gtk2Hs with it
16:19:04 <lambdabot> newsham: Quite quickly.
16:19:07 <vincenz> anyone know a nice way to group items in a list?
16:19:11 <Pseudonym> http://world.std.com/~jdostale/kbd/SpaceCadet.html
16:19:16 <lambdabot> Title: Space Cadet keyboard, http://tinyurl.com/jdjtr
16:19:16 <vincenz> and get the number of each
16:19:25 <vincenz> basically
16:19:31 <vincenz> > map length . group . sort
16:19:32 <lambdabot>  Add a type signature
16:19:33 <vincenz> but then efficientyl
16:19:44 <hyrax42> partial application can pbscure types of things a bit though
16:19:46 <dcoutts_> Anyone here like SVG? Want to update the cairo SVG bindings to use librsvg rather than libsvg-cairo ? :-)
16:19:50 * rahikkala tries it
16:20:03 <hyrax42> with experience I suppose you get a decent in-built type inferencer
16:20:08 <newsham> i wish it was easy to do partial application in python :(
16:20:10 <hyrax42> providing you know enough of the functions in use
16:20:20 <hyrax42> newsham: isn't there some module or something
16:20:23 <hyrax42> in 2.5
16:20:25 <dons> Pseudonym: the comments are hilarious though
16:20:29 <dons> Pseudonym: http://www.artima.com/forums/flat.jsp?forum=106&thread=186200
16:20:31 <newsham> yes.  but its cumbersome.
16:20:31 <lambdabot> Title: Weblogs Forum - Typing like a Functional Programmer, http://tinyurl.com/yadrba
16:20:37 <sjanssen> rahikkala: Haskell always hangs on to top level data structures, so the trick here is to store the data in a list, and then use list indexing to lookup the result
16:20:50 * dons watches imperative hackers thrash wildly with a new concept
16:21:12 * jdev reads old HWNs
16:21:17 <dibblego> why is partial application only specific to imperative languages?
16:21:20 <rahikkala> sjanssen: Cool, and many thanks :)
16:21:22 <jdev> For the quotes sections.
16:21:23 <newsham> def partial(f, arg0) : return lambda *args, **kw : f(arg0, *args, **kw)
16:21:37 <dons> dibblego: specific?
16:22:11 <Pseudonym> Who'e going to point out that it should be called "Schoenfinkeling"?
16:22:13 <dibblego> well, it seems that "imperative programmers can learn this new concept called partial application", but I don't see how it is related to imperative languages - only coincidentally
16:22:28 <sjanssen> "o.k., now I'm really confused. This function has STATE. It is an Object, not a Function. I thought the big advantage of FP was no states, no threading issues, etc. I guess I'm missing something fundamental about FP." -- confusion over currying
16:22:36 <vincenz> @type foldl'
16:22:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:22:42 <dibblego> it might be "languages for which the GoF book was designed for" perhaps
16:22:53 <newsham> dibble: partial application (and other functional techniques) are still useful in "imperative" langauges.
16:22:54 <lispy> that Morgan guy is scary
16:23:00 <dibblego> newsham, that's my point
16:23:13 <lispy> o.k., now I'm really confused. This function has STATE. It is an Object, not a Function. I thought the big advantage of FP was no states, no threading issues, etc. I guess I'm missing something fundamental about FP.
16:23:21 <newsham> ok, then i agre with your point :)
16:23:30 <TSC> Those comments are scary
16:23:50 <dibblego> sjanssen, who/what/where said that?
16:23:59 <dibblego> oh, never mind
16:24:24 <vincenz> @type Data.Map.alter
16:24:25 <lambdabot> Not in scope: `Data.Map.alter'
16:24:57 <newsham> >>> def partial(f, arg0) : return lambda *args, **kw : f(arg0, *args, **kw)
16:24:58 <newsham> >>> partial(int.__add__, 5)(3)
16:24:59 <newsham> 8
16:25:03 <newsham> not exactly elegant
16:25:29 <lispy> not elegant at all
16:25:32 <Pseudonym> I don't use functional languages for my work and am by no means an expert in them but what I have learned about them from reading and from using languages that support functional approaches (Scala, Python) has helped my greatly in my designs. I find more and more that I use functional approaches in Java designs, especially by simulating function passing with interfaces.
16:25:37 <Pseudonym> There's a smart lad.
16:26:17 <dibblego> not if he is using the Sun VM - he will run into problems
16:26:34 <dons> "To clarify, in FP, do you (almost) always need the = sign. That is, nothing returns "void", and you better save what it returns or it's gone."
16:26:53 <dons> this thread highlights why software sucks
16:26:59 <dibblego> he will run into p -> ¬p
16:27:00 <sjanssen> dons: ha!
16:27:20 <Pseudonym> It also highlights tht there is hope.
16:27:30 <dibblego> dons, we were all born ignorant and will die so
16:27:36 <Pseudonym> I think that software sucks mostly because of management, bur partly because of programmer ignorance.
16:27:42 <dibblego> I'm on Pseudonym's/the optimist's side
16:27:43 <Pseudonym> And we can do something about the latter.
16:28:13 <dons> " Map Reduce doesn't work in FP unless A) you have the entire list or can generate it from functions; or B) you break the functional paradigm in order to fetch values as they come in from an external source. So using Map/Reduce to promote functional programming isn't on the level IMO."
16:28:33 <dibblego> Pseudonym, really, the "ignorant programmer" can do something about it - thankfully, most of them (including ourselves) would like to
16:28:36 <dons> this was funny "ha ha" , now its just scary
16:28:47 <newsham> not funny "ho ho" now?
16:28:49 <dibblego> dons, is that from a guy called "Zwitzerloot"?
16:29:00 <dons> nope.
16:29:00 <eviltwin_b> sounds like a /.-style comment
16:29:15 <dibblego> there is a guy who hangs out in ##java that says things like that
16:29:20 <newsham> you should reply saying "functional languages cant have any side effects, so they're useless!"
16:29:22 <Pseudonym> Map/Reduce is a classic example of how your non-functional programming can benefit from learning functional programming.
16:29:38 <dons> ok its scary "The benefits of functional programming come not from referential transparency but lack of state dependencies between functions. Referential transparency gets in the way."
16:29:40 <newsham> "whats the point of a program that cant affect the real world!"
16:29:46 <dons> hehe
16:29:55 <pzpz> wassaaap
16:30:23 <dons> oh, wait till you guys get to the sectoin on "acrifice techniques that imperative programming offers"
16:30:27 <dons> tecniques such as....
16:30:39 <dibblego> "My software worked on Tuesday, but today I have no idea what it will do - I can only take a good guess" -- (referential transparnecy "got in my way")
16:30:41 <dons> - generic programming, - using constructors/destructors to allocate and deallocate resources ,  using function objects
16:30:44 <dons> ...
16:30:55 <newsham> what url is this?  i could use some chuckles
16:31:18 <Pseudonym> With Haskell, when my program stops working, I'm 99% sure it's the modification I just made.
16:31:22 <SamB> what are "function objects"?
16:31:28 <sjanssen> how about using _actual functions_ ?
16:31:30 <dons> oh man "> you think that FP does not support generic programming?" --> "It does through dynamic typing"
16:31:31 <newsham> fobjects
16:31:38 <Pseudonym> Oh man indeed.
16:31:39 <dibblego> dons, that's pretty funny :)
16:31:41 <SamB> heh
16:31:47 <sjanssen> SamB: objects with a .apply() method.  They're pretty ugly
16:31:48 <newsham> url me?
16:31:49 <Pseudonym> SamB: A function object is a function which acts like a function/closure.
16:32:01 <dibblego> someone should blog how silly it all is, then reddit it and we will all vote it up
16:32:01 <Pseudonym> C++, for example, supports operator().
16:32:29 <newsham> why not throw down a gauntlet.  ask them what cant be done in fp, then show them 5 lines of code that do it?
16:32:38 <dons> oh, igouy is on that thread (shootout guru)
16:32:51 <dons> newsham: http://www.artima.com/forums/flat.jsp?forum=106&thread=186200&start=0&msRange=15
16:32:54 <lambdabot> Title: Weblogs Forum - Typing like a Functional Programmer, http://tinyurl.com/y2zdoe
16:32:57 <sjanssen> it's amazing how quickly Haskell has infiltrated reddit
16:33:04 <dons> hhe
16:33:06 <vincenz> what's the public method of Read?
16:33:10 <vincenz> apparently not read
16:33:11 <dons> read
16:33:14 <vincenz> no
16:33:16 <vincenz> can't define read
16:33:17 <dons> public method?
16:33:18 <sjanssen> dons: when did you start posting things on reddit?  a month ago?
16:33:24 <dons> sjanssen: yep
16:33:24 <dons> now
16:33:29 <dons> its self sustaining...
16:33:32 <sjanssen> vincenz: type :info Read from a ghci prompt
16:33:32 <emu> ``
16:33:32 <emu> Functional programming contains many useful and valuable constructs (like currying that Chris kindly enough explained) but it also contains an irritating feature called 'referential transparency'.
16:33:36 <emu> ''
16:33:38 <dons> (i posted 31 articles in about 50 days)
16:33:40 <hyrax42> reddit is fickle
16:33:45 <hyrax42> language-wise
16:34:32 <dons> ah, I finally see the date: "Jul, 2003"
16:34:38 <dons> oh no.
16:34:44 <dons> scary Nov 29, 2006
16:34:50 <dons> this conversation is taking place _today_ ?
16:34:55 <dons> in the 21st century
16:35:00 <hyrax42> which conversation
16:35:05 <dons> this crazy thread
16:35:11 <emu> http://warp9point99.blogspot.com/2006/11/sincere-comment-on-functional.html
16:35:12 <hyrax42> of currying
16:35:13 <lambdabot> Title: warp 9.99!: A sincere comment on functional programming, http://tinyurl.com/yhc4w6
16:35:16 <emu> 28 nov
16:35:21 <dons> emu: yeah, that's a funny one
16:37:44 <vincenz> @type foldl'
16:37:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:38:58 * dibblego proposes "A sincere and importantly, well informed, comment on functional programming"
16:39:07 <greentea> Hi all.
16:39:36 <newsham> whyfp.html
16:39:39 <dons> hey greentea
16:39:42 <emu> `` The halting problem proves that no algorithm can be proven correct. ''
16:39:50 <dons> heh
16:39:54 <dibblego> wtf?
16:40:01 <eviltwin_b> definitely /.-level material
16:40:06 <emu> it was getting dull for a bit but then he sprung that
16:40:24 <dons> that sounds almost like Keal
16:40:41 <dons> if only it was "I prove halting problem correct, and no algorithm is broken on FPU"
16:40:45 <mux> mmm, can I use bang patterns in let clauses with GHC 6.6?
16:40:49 <newsham> emu: where's that quote?
16:40:56 <dibblego> a correct algorithm proves that the halting problem does not exist! what do I win!?
16:40:57 <emu> ^ sincere comment
16:40:57 <dons> mux, think so yeah
16:41:22 <dons> mux: Prelude> :set -fbang-patterns
16:41:22 <dons> Prelude> let !(Just x) = Nothing
16:41:24 <dons> *** Exception: <interactive>:1:4-22: Non-exhaustive patterns in pattern binding
16:41:34 <dons> Prelude> let (Just x) = Nothing
16:41:35 <dons> Prelude>
16:42:32 <vincenz> Prelude> DIE!
16:43:16 <mux> cool
16:45:32 <mux> yay for instant 50% perf win
16:46:14 <dons> using ! patterns?
16:46:22 <mux> yes :)
16:46:30 <dons> yay for giving the strictness analyser more to chew on
16:46:37 <dons> mux, so I wonder if we need strict MVars..
16:46:40 <Pseudonym> Mmmm... strictness...
16:46:44 <dons>  i was ponder this the other day
16:46:56 <mux> putMVar' ?
16:47:10 <dons> yeah, that might be enough
16:47:17 <dons> and modifyMVar'
16:47:18 <emu> i put a lot of ! in my code in various likely places, but no luck :/
16:48:38 <mux> the downside being, the function we 're supposed to use 90% of the time is the one looking "alternate"
16:48:43 <Pseudonym> "And some very easy to use patterns which are the foundations of many projects, like the model-view-controller pattern, require highly complex pieces of software like the Zipper or Arrows in order to achieve similar functionality in FP, which can only be written by mathematicians or people who are highly trained in pure FP."
16:48:43 <mux> if you see what I'm seeing
16:48:54 <Pseudonym> That's an interesting comment.
16:49:02 <mux> cause as far as I've understood, we nearly always want to use struct evaluation with mvars
16:49:19 <Pseudonym> First off, nobody is arguing that there isn't a good, standard model for modern GUIs in a language like Haskell.
16:49:20 <robreim> Strange, I've broken my gtk2hs program up into MVC using modules.
16:49:38 <Pseudonym> Secondly, who says that MVC is easy to use?
16:49:48 <Pseudonym> You only say that because you've been using it for so long.
16:49:56 <mux> dons: see what I mean?
16:50:11 <sjanssen> dons: did you catch the comment at the end of the "A sincere comment on functional programming" blog?
16:50:24 <Pseudonym> Arrows require being a mathematician?  MVC requires being an engineer!
16:50:30 <Pseudonym> Talk about high barrier to entry!
16:50:30 <dcoutts_> robreim, btw, what gui are you implementing ?
16:50:33 <dons> sjanssen: oh no? there wasn't a comment last time i looked
16:50:49 <EvilRanter> bleugh... MVC. I like the idea in principle, but i've never got the hang of it
16:50:56 <robreim> dcoutts_: ah, it's juts a little program for work. I'll provide you with screenshots once it's pretty enough :)
16:51:00 <dons> mux, one case would be Chans though i.e. MVar [a]
16:51:01 <dolio> Ooo, "How to Rewrite Standard Recursion through a State Stack & Iteration"
16:51:04 <dolio> Sounds like fun.
16:51:05 <sjanssen> dons: well, the comment is by "Super Zealot", the same guy that posted the ugly darcs code
16:51:07 <dcoutts_> robreim, cool :-)
16:51:15 <dons> oh interesting... let me see...
16:51:46 <dons> sjanssen: hmm. bizarre
16:51:50 <dons> someone's got an agenda
16:52:40 <dons> good thing they can't spell or construct coherent sentences
16:53:07 <jdev> "Super Zealot" seemed like a deliberate troll to me, so I didn't take it seriously.
16:53:19 <dons> yeah
16:53:40 <sjanssen> he does have a point though, that code is _ugly_
16:53:48 <dons> sure is.
16:54:13 <Pseudonym> So is some of the GHC code.
16:54:41 <Pseudonym> You can write Fortran in any language, especially if you're learning.
16:55:03 <Excedrin> this sincere comment on fp is hillarious
16:55:44 <Excedrin> I guess "this is a sincere comment" is the new "you are about to encounter comedy gold"
16:55:54 <eviltwin_b> ...but you can only write COBOL in COBOL
16:55:57 <dons> dcoutts_: any news on the hotel booking?
16:56:11 <dcoutts_> dons, I'm doing it tomorrow morning
16:56:13 <mgsloan> readFile "Brain" >>= return . parseBrain >>= return . show
16:56:14 <Pseudonym> Not true.  You can write COBOL in Java.
16:56:21 <dons> why don't FP people write "sincere comments on imperative programming" ?
16:56:32 <Pseudonym> I do like the closing comment, though.
16:56:34 <mgsloan> do notation way of writing this? also, how do I show an IO string in ghci...
16:56:35 <dons> we could post chunks of C++ all day long for laughs
16:56:38 <greentea> Could someone please point me to the URL of this "sincere comment"?
16:56:41 <dcoutts_> dons, we'd be accused of being somethingist
16:56:43 <mattam> the guy wants ocaml, no need for that
16:56:46 <dons> ?redo readFile "Brain" >>= return . parseBrain >>= return . show
16:56:46 <lambdabot> do { a <- do { a <- readFile "Brain"; return a} . parseBrain; return a} . show
16:56:47 <Pseudonym> Current functional languages are better than current imperative languages, because current imperative languages suck.
16:56:57 <Pseudonym> There's something in that.
16:57:05 <mgsloan> yep
16:57:10 <Pseudonym> It would be interesting to see a Hindley-Milner imperative language.
16:57:22 <dons> greentea: http://warp9point99.blogspot.com/2006/11/sincere-comment-on-functional.html
16:57:25 <lambdabot> Title: warp 9.99!: A sincere comment on functional programming, http://tinyurl.com/yhc4w6
16:57:33 <mattam> isn't ocaml one ?
16:57:33 <greentea> dons: Fanks. :-)
16:57:33 <sjanssen> ?. redo unpl readFile "Brain" >>= ((return . parseBrain) >>= (return . show))
16:57:34 <lambdabot> (do { a <- (readFile "Brain"); (do { f <- (\ c -> return (parseBrain c)); return (show f)}) a})
16:57:37 <dolio> That's coming with C# 3.0, no?
16:57:46 <Pseudonym> One of the reasons why Haskell doesn't suck as much as many other languages is that Haskell NEVER compromises on theoretical purity.
16:57:51 <eviltwin_b> not even Java lets you achieve SUBTRACT 1 FROM SOME-INSANELY-STUPID-VARIABLE-NAME
16:57:57 <eviltwin_b> much less those data declarations...
16:57:59 <Pseudonym> If you can't do something purely, we wait until someone finds a way.
16:58:10 <Pseudonym> That's why Haskell doesn't have a standard GUI library.
16:58:13 <EvilRanter> ADD 1 TO COBOL GIVING COBOL
16:58:21 <EvilRanter> (OO cobol? :P)
16:58:26 <mgsloan> dunno about that Pseudonym - theoretical /= user friendly
16:58:28 <eviltwin_b> IBM did that already
16:58:42 <mux> dons: I'm seeing very spooky stuff with the strictness analyzer I think
16:58:42 <eviltwin_b> (be afraid, be very afraid)
16:58:55 <Pseudonym> mgsloan: While that's true, Haskell hasn't really compromised on that, either.
16:59:04 <Pseudonym> That's why, for example, we have do-notation.
16:59:15 <dcoutts_> dons, heh, my favourite quote from that "Not true. The halting problem proves that no algorithm can be proven correct."
16:59:19 <Pseudonym> Really, the only problem is that Haskell's base syntax was optimised for what Haskell could do at the time.
16:59:25 <mgsloan> IO, random numbers, etc all compromized as far as user friendly
16:59:35 <Pseudonym> So the syntax of some of the add-ons are a little inelegant.
16:59:48 <Pseudonym> But Haskell concentrates on semantics, anyway.
17:00:32 <mgsloan> point is, I don't think biasing towards purity absolutely is the best way to go.  a compromise heavily leaning towards purity is good :)
17:00:52 <mgsloan> ah, yeah, its good to have the semantics pure
17:00:55 <dons> mgsloan: luckily now we have pretty much everything in place to solve it all via libraries
17:00:55 <dolio> Where does this guy get his "claims" from?
17:01:05 <dons> i.e. we could have much nicer randoms with a new library
17:01:22 <Excedrin> mgsloan: that sounds like Scheme or SML (or Ocaml)
17:01:28 <mux> dons: without ! patterns the program runs are fairly constants, ~ 3.3s-3.4s total, but with strictness it can do from 1.8s to as long as 7.2s !
17:01:36 <dons> mux, interesting!
17:01:39 <mgsloan> Excedrin: yeah, probably is, basically
17:01:49 <dons> mux, almsot glasgow-haskell-users@ worthy ...
17:01:50 <dcoutts_> "I have not commented on pattern matching, closures, currying and high order functions because I find those valuable in code"
17:01:51 * dcoutts_ rolls on the floor laughing
17:01:59 <dons> hehe
17:02:02 <mgsloan> hehe
17:02:20 <sjanssen> mux: I've had that problem before, you're probably forcing something with ! that isn't always needed
17:02:23 <dons> this is just crazy isn't it:
17:02:25 <dons> FP allows systems like air traffic control systems to be automatically tested.
17:02:25 <dons> Comment:
17:02:25 <dons> Not true. The halting problem proves that no algorithm can be proven correct.
17:02:38 <mgsloan> wat?!?
17:02:45 <dcoutts_> yeah, lovely
17:02:50 <Pseudonym> Air traffic control systems aren't supposed to terminate.
17:02:55 <Excedrin> For example, I can do the following thing in C/C++:
17:02:55 <Excedrin> memset(0, 0, 0xFFFFFFFF);
17:02:58 <mgsloan> someone misunderstood the halting problem...
17:03:00 <SamB> Pseudonym: steps are!
17:03:04 <SamB> or the systems freeze
17:03:05 <dons> dcoutts_: can you call John Hughes and tell him QuickCheck is breaking all the rules!
17:03:06 <Excedrin> which can easily bring down the computer, even destroy the hard disk
17:03:07 <Excedrin> and certainly destroy valuable data...
17:03:09 <dcoutts_> mind you much of the stuff the guy is responding too is junk too
17:03:09 <Pseudonym> Well, yes.
17:03:15 <dcoutts_> dons, heh
17:03:34 <mux> sjanssen: if you care to take a look at the code: http://haskell.org/haskellwiki/Concurrency_demos/Zeta (the version with Chan)
17:03:37 <lambdabot> Title: Concurrency demos/Zeta - HaskellWiki, http://tinyurl.com/y6e7wc
17:04:03 <mux> sjanssen: I add bang patterns for the last two parameters of wait, that are accumulators
17:04:04 <greentea> Hm, this article has a distinct smell of straw to it . . . .
17:04:05 <rc-1> are you pseudonym on the markcc's blog?
17:04:16 <Pseudonym> rc-1: Yup.
17:04:18 <dons> rc-1: Pseudonym is Pseudonym .
17:04:22 <eviltwin_b> <dilbert> I smell hay. </dilbert>
17:04:23 <SamB> what is a decent MonadPlus
17:04:26 <dons> greentea: heh
17:04:31 * Pseudonym has been Pseudonym for close to 20 years
17:04:48 <dons> greentea: there's quite a few more enlightening blog articles listed in the weekly news, if you read that
17:04:51 <rc-1> ah cool :) no wonder you know so much about this sort of thing!
17:04:52 <dons> ?where hwn
17:04:52 <lambdabot> http://sequence.complete.org/
17:05:03 <robreim> Did anyone else find this amusing? "debugging in FP is easier because functions do not depend on external state. If we had an imperative language that did not allow modification of state other than that of its argument, debugging would be just as easy." Uh... wouldn't that just be a functional language?
17:05:05 <mux> damn, 2am
17:05:11 <Pseudonym> rc-1: Why, because I have a self-referential nick?
17:05:21 <Pseudonym> That's not knowledgable, it's just geeky.
17:05:23 <dcoutts_> robreim, actually, no.
17:05:32 * mux heads to bed &
17:05:34 <dolio> robreim: He does stuff like that in several places.
17:05:42 <Pseudonym> Night mux.
17:05:42 <rc-1> (because you have been using comps for 20+ years)
17:05:49 <Excedrin> Modern programming languages like Visual Basic...
17:05:50 <rc-1> have a blog?
17:06:02 <dolio> Like when he says that imperative languages could be lazily evaluated if all the functions were referentially transparent.
17:06:02 <dcoutts_> robreim, it would be possible and interesting to have an imperative language with pure functions, where those functions can mutate local but not external variables.
17:06:04 <greentea> dons: i do at least scan through HWN . . . .
17:06:12 <Pseudonym> rc-1: Yeah.  Well, 20 years ago it was a 32k micro, but yes.
17:06:16 <Excedrin> ... and Perl...
17:06:22 <SamB> dolio: you mean like in Haskell?
17:06:27 <Pseudonym> There wasn't a functional language port for it.
17:06:34 <dons> its good (I think) that at least we're causing some cognitive dissonance over in the imperative community
17:06:41 <SamB> dcoutts: fish?
17:06:42 <robreim> Ah, I misread it. Jokes on me! :)
17:07:02 <dcoutts_> so you could have an imperative language that is split into pure and mutable bits. Procedures that can mutate stuff (ie -> IO a) and functions that cannot (ie -> a)
17:07:26 <dcoutts_> SamB, never heard of it
17:08:03 <SamB> Functional Imperative Shell, I think it is called
17:08:04 <dons> greentea: how's the jabber client going (that was it, right?)
17:08:09 <dons> greentea: got it in darcs?
17:08:20 <SamB> it lets you mutate arrays but is still pure...
17:08:24 <robreim> What the guy is describing sounds very much like what semi-functional languages encourage (and use as their claim to functional paradigm-ness)
17:08:37 <rc-1> just read his post on haskell and it seems much better conceptually to me than scheme is (no side effects, lazy eval, strong typing)
17:08:52 <rc-1> so cool you can have infinite lists :)
17:09:09 <greentea> dons: It's not been going at all . . . . various things have meant i've been struggling to get to it over the last couple of days. :-(
17:09:23 <Pseudonym> rc-1: I kind of have a blog.  I say "kind of" because the design isn't finished yet.
17:09:28 <Pseudonym> And nobody knows about it except me.
17:12:24 <dons> greentea: well, if you want advice, hints, be sure to ask
17:12:47 <greentea> dons: Thanks, i will. :-)
17:12:50 <dons> greentea: you've seen the 'How to write a haskell project' page?
17:12:56 <greentea> *nod*
17:13:00 <dons> great
17:13:10 <chessguy> @go how to write a haskell project
17:13:12 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:13:12 <lambdabot> Title: How to write a Haskell program - HaskellWiki
17:13:22 <dons> chessguy: nice trick!
17:13:33 <chessguy> trick?
17:13:48 <dons> i've not seen the spelling completion used like that. its a good mnemonic
17:14:01 <dons> @google how to write a haskell project
17:14:03 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:14:03 <lambdabot> Title: How to write a Haskell program - HaskellWiki
17:14:10 <chessguy> oh
17:15:18 <chessguy> that's a nice article
17:15:32 <chessguy> who wrote that?
17:16:02 <dons> lispy, ross p and me
17:16:20 <dons> chessguy: if you walk through it, and anything doesn't make sense, please say
17:16:28 <dons> (or if anything doesn't work)
17:16:56 <mgsloan> ?hoogle IO String -> IO ()
17:16:58 <lambdabot> No matches, try a more general search
17:17:00 <chessguy> oh i don't have any interesting enough code to make use of it yet
17:17:09 <dons> mgsloan: putStr ?
17:17:39 <dons> ?type putStr
17:17:41 <lambdabot> String -> IO ()
17:17:42 <dons> ?type print
17:17:44 <lambdabot> forall a. (Show a) => a -> IO ()
17:17:45 <mgsloan> Expected type: String
17:17:45 <mgsloan> Inferred type: IO [Char]
17:17:48 <dons> oh, IO String eh?
17:18:20 <EvilRanter> ?type (>>())
17:18:20 <monochrom> <3
17:18:21 <lambdabot>   Couldn't match `m b' against `()'
17:18:21 <lambdabot>    Expected type: m b
17:18:31 <EvilRanter> ?type (>>return())
17:18:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
17:18:41 <monochrom> (<3) is the Haskell love operator :)
17:19:01 <jdev> @. hoogle type (<3)
17:19:02 <mgsloan> EvilRanter - cool, but I don't want to throw away my string, I want to write it out
17:19:03 <lambdabot> Char.isLatin1 :: a -> Bool
17:19:04 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
17:19:04 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
17:20:00 <EvilRanter> mgsloan, you need to have it, er, I'd say "fall out of" a do{} or your main function, then
17:20:16 <mgsloan> hmm
17:20:33 <EvilRanter> ie main = putStr "whatever"; or do { ...; putStr "egad!"; ... }
17:20:33 <dons> jdev: nice idea
17:21:15 <EvilRanter> or, if you're working at the console, force evaluation of the putStr
17:21:37 <EvilRanter> actually, in general, i think it's just forcing it to be evaluated. but you do that with do{}s.
17:21:39 <mgsloan> yeah, I'm just messing with ghci
17:21:42 <monochrom> You can't buy me love by character tests or quickchecks!
17:22:16 <dons> not even isBottom?
17:22:38 <monochrom> Hmm what does isBottom do?  Is it some kind of halting test?
17:23:35 <dons> yeah
17:23:51 <dons> you know, since haskell solves the halting problem ;)
17:24:08 <dons> isBottom a = unsafePerformIO (do
17:24:08 <dons>     a' <- try (Exception.evaluate a)
17:24:08 <dons>     case a' of
17:24:08 <dons>        Left _ -> return True
17:24:09 <dons>        Right _ -> return False)
17:24:18 <dons> (it's just catching the 'Undefined' exception
17:24:28 <dons> or any exceptoin, in fact
17:24:31 <monochrom> Ah, that's useful enough.
17:25:13 <EvilRanter> so (isBottom a) implies (a == _|_), but not the other way around
17:25:26 <Pseudonym> GDMC == very nice
17:25:32 <chessguy> hey anybody seen/done any monte carlo stuff in haskell?
17:25:32 <Pseudonym> Much nicer than PPM.
17:25:42 <Pseudonym> chessguy: I've written quite a bit.  Anything in particular?
17:25:43 <monochrom> I wonder if it is safe to have a pure functional try-catch.
17:25:45 <EvilRanter> (for some _|_, (isBottom _|_ == _|_)...)
17:26:01 <vincenz> EvilRanter: that's called an oracle
17:26:11 <chessguy> Pseudonym, i'm looking to do a monte carlo simulation of a queuing situation
17:26:29 <Pseudonym> Right.  Have you read up on the Metropolis-Hastings algorithm?
17:26:30 <EvilRanter> vincenz, it looks like dons' defn fits what i just said
17:26:40 <chessguy> hmm, don't think so
17:26:40 <vincenz> EvilRanter: well in general _|_ == infinite computation
17:26:46 <vincenz> EvilRanter: he doesnt' catch those _|_
17:26:47 <Pseudonym> The wikipedia entry is quite good.
17:26:54 <chessguy> ok
17:27:05 <EvilRanter> o? i was under the impression it was any expression that didn't return
17:27:19 <EvilRanter> either by infinite computation, throwing an exception, following a continuation...
17:27:31 <EvilRanter> or whatever.
17:27:51 <chessguy> ok, well i'm just looking to do a pretty simple simulation
17:28:15 <SamB> EvilRanter: that is correct
17:28:30 <SamB> except Haskell doesn't have continuations like that
17:28:37 <mgsloan> IO is wierd... just to have a little bit of it, it propogates throughout your program :(
17:28:41 <Pseudonym> The nice thing about Metropolis-Hastings, is it lets you spend most of the computation on the states of the system which contribute more.
17:28:56 <EvilRanter> altho "doesn't return" being non-equivalent to "infinite calculation" is a tad counter-intuitive ;]
17:29:00 <SamB> Pseudonym: are you talking about global illumination?
17:29:12 <chessguy> Pseudonym, is all your code pretty general-purpose, or do you have any specific to queuing theory problems?
17:29:16 <Pseudonym> SamB: I'm talking about any intractable process which  you want to sample.
17:29:17 <EvilRanter> SamB, k... **goes to look up haskell continuations**
17:29:31 <Pseudonym> chessguy: It's all pretty special-purpose, and not queueing theory.
17:29:42 <scriber> i'm a cs student new to haskell(hugs) and have 2 simple problems that are driving me crazy!! could anyone help?
17:29:52 <chessguy> oh, ok
17:29:54 <Pseudonym> Global illumination is one application, sure.
17:30:07 <chessguy> out of curiosity, what are you working on?
17:30:13 <Pseudonym> Actually, GI is particularly nice because it samples Feynman diagrams.
17:30:25 <Pseudonym> Oh, I'm working on some cryptanalysis stuff.
17:30:29 <Pseudonym> Classical cryptanalysis.
17:30:30 <chessguy> scriber, your best bet in here is to just ask your questions
17:30:38 <Pseudonym> Again, it's an intractable problem.
17:30:51 <chessguy> aren't those the best kind? :)
17:30:52 <Pseudonym> In fact, right now, I'm building a GDMC model of English.
17:30:55 <SamB> I don't think GI is intractible
17:31:11 <SamB> because you don't really need to get it 100%, after all ;-)
17:31:15 <Pseudonym> SamB: Chasing every real physical photon is close to intractable.
17:31:25 <scriber> "Define a function isitprime that takes a pos Int value n and returns True if n is a prime number, false if it's not"
17:31:32 <mgsloan> ok, how would i force the execution of ( (Monad.liftM $ writeBrain) $ readBrain "Brain" ) in ghci?
17:31:42 <Pseudonym> You NEED to avoid wasting time on things that don't contribute to the image.
17:31:47 <SamB> yeah ;-)
17:31:52 <dons> chessguy: yeah, i've done some monte carlo simulation
17:32:01 <dons> and there's a monte carlo ray tracer on the wiki
17:32:06 <vincenz> dons: do you know how to make pseudocode in lateX?
17:32:08 <SamB> the thing is, nobody wants you to solve the intractible problem -- they just want pretty pictures ;-)
17:32:14 <dons> vincenz: use haskell mode?
17:32:17 <chessguy> oh that's right, i do remember seeing something about that
17:32:30 * mgsloan has done radiosity before
17:32:41 <chessguy> @go monte carlo ray tracer
17:32:43 <lambdabot> http://www.cs.rutgers.edu/~decarlo/readings/mcrt-sg03c.pdf
17:32:50 <chessguy> @go monte carlo ray tracer haskell
17:32:51 <lambdabot> http://www.cse.unsw.edu.au/~cgray/banky/
17:32:51 <lambdabot> Title: Banky - The Monte Carlo Ray Tracer in Haskell
17:32:59 <chessguy> that's more like it :)
17:33:02 <Pseudonym> http://andrew.bromage.org/test3.png <- This illustrates the problems of sampling incorrectly.
17:33:05 <vincenz> dons: erm, not using haskell..
17:33:05 <SamB> I have become frustrated with POV-Ray's pathetic attempt
17:33:08 <Pseudonym> (Yes, renderer written in Haskell.)
17:33:20 <Pseudonym> @google metropolis light transport
17:33:22 <lambdabot> http://graphics.stanford.edu/papers/metro/
17:33:22 <lambdabot> Title: Metropolis Light Transport
17:33:24 <scriber> anyone? :)
17:33:31 <SamB> scriber: oh, yeah, right
17:33:33 <SamB> @paste
17:33:34 <lambdabot> http://paste.lisp.org/new/haskell
17:34:12 <dons> vincenz: I don't understand the question
17:34:14 <jdev> Pseudonym: Yow.  That's pretty incorrect.
17:34:35 <dons> scriber: yes?
17:34:46 <dons> scriber: you want to write a primality test?
17:35:12 <dons> > let f n = n % 2 in f 2 -- a small hint
17:35:13 <lambdabot>  1%1
17:35:28 <dons> > let f n = n `mod` 2 in f 2 -- a better one
17:35:29 <lambdabot>  0
17:35:36 <Pseudonym> jdev: The interesting thing is _why_ it's incorrect.
17:35:38 <lisppaste2> scriber pasted "help" at http://paste.lisp.org/display/30970
17:35:41 <Pseudonym> The "hot spots" in particular.
17:35:42 <dons> > let f n = n `mod` 2 == 0 in f 2
17:35:43 <lambdabot>  True
17:35:57 <vincenz> dons: nm then
17:36:01 <chessguy> dons, do you have any general monte carlo code?
17:36:04 <dons> scriber: you'll need to write some code first...
17:36:08 <dons> chessguy: nope
17:36:15 <dons> scriber: we can help if you get stuck
17:36:25 <chessguy> what did you use when you did your monte carlo stuff?
17:36:27 <SamB> oh, hehe
17:36:30 <dons> scriber: if you're learning haskell from scratch, visit http://haskell.org
17:36:32 <lambdabot> Title: Haskell - HaskellWiki
17:36:41 <scriber> thank you
17:36:43 <Pseudonym> @google haskell homeworkhelp
17:36:44 <dons> chessguy: we just wrote the simulator in haskell, and used System.Random
17:36:46 <lambdabot> http://www.haskell.org/humor/homework.html
17:36:46 <lambdabot> Title: Humor - HaskellWiki
17:36:50 <Pseudonym> Errr...
17:36:52 <dons> Pseudonym: heh
17:36:56 <dons> that's one option ;)
17:37:01 <EvilRanter> ?type (%)
17:37:02 <chessguy> ?hoogle System.Random
17:37:02 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
17:37:03 <lambdabot> No matches, try a more general search
17:37:16 <dons> ?docs System.Random
17:37:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
17:38:07 <Pseudonym> http://haskell.org/haskellwiki/HomeworkHelp
17:38:08 <lambdabot> Title: Homework help - HaskellWiki
17:38:08 <Pseudonym> That's it.
17:38:09 <chessguy> oh, i've never quite "gotten" random numbers in haskell
17:38:47 <SamB> well, there really is no such thing as a random number
17:38:56 <SamB> Pseudonym: how do those white spots get there?
17:39:20 <dons> chessguy: they're just a supply of randoms in a monad, or else in IO
17:39:23 <dons> nothing to magic
17:39:44 <Pseudonym> SamB: Think about variance reduction.
17:39:52 <chessguy> well, i've probably never truly "gotten" monads either
17:39:52 <Pseudonym> You're sampling an interval.
17:39:55 <Pseudonym> Sorry, an integral.
17:40:05 * mgsloan magics dons
17:40:10 <SamB> right.
17:40:27 <Pseudonym> So you integrate f(x) from x=a to x=b.
17:40:31 <dons> ?type do g <- newStdGen;  return $ randoms g
17:40:32 <lambdabot> forall a. (Random a) => IO [a]
17:40:32 <Pseudonym> That's nice, but it's high-variance.
17:40:46 <shapr> Pseudonym: You're reading Achilleas' comments on LtU?
17:40:48 <SamB> hmm?
17:40:50 <dons> chessguy: there you go , an infinite list of randoms to play with
17:40:51 <wy> I got a problem when compiling ghc with -enable-objectio and --enable-dotnet. It said "make[2]: cl: Command not found". What's cl?
17:40:56 <Pseudonym> shapr: Nope.
17:41:05 <Pseudonym> So you sample using a PDE which approximates f(x).
17:41:33 <Pseudonym> So you sample the integral f(x) / p(x) where p is the PDE.
17:41:34 <agocorona> do make sense to have an Web service that generates aleatory numbers by hiring 100 monkies in a jail plenty of keyboards?
17:41:38 <Pseudonym> And you draw x from the PDE p.
17:41:41 <shapr> Pseudonym: What about the model-view-controller comment?
17:41:41 <Pseudonym> With me, SamB?
17:41:52 <SamB> no
17:42:03 <Pseudonym> Ah.
17:42:05 <SamB> I need more classes
17:42:08 <SamB> I think
17:42:09 <Pseudonym> Apparently. :-)
17:42:14 <SamB> but I'm not sure which ones
17:42:22 <SamB> and I bet they aren't offered at my school either
17:42:28 <Pseudonym> shapr: Which story is this?
17:42:59 <shapr> Pseudonym: Where'd you find that quote? That must be something that Achilleas said on LtU
17:43:04 <Pseudonym> No.
17:43:14 <Pseudonym> It was from... uh... one of the links posted earlier.
17:43:19 <shapr> Which link?
17:43:32 <Pseudonym> Can't remember.
17:43:35 <Pseudonym> Sorry. :-)
17:43:56 <chessguy> dons, hmmm. ghci doesn't like that
17:44:00 <chessguy> or i'm using it wrong
17:44:12 <Pseudonym> SamB: OK, let's start with the basics.
17:44:24 <Pseudonym> We're trying to integrate f(x) from x=a to x=b.
17:44:30 <shapr> Pseudonym: http://warp9point99.blogspot.com/2006/11/sincere-comment-on-functional.html - About Me Name:Achilleas Margaritis
17:44:32 <lambdabot> Title: warp 9.99!: A sincere comment on functional programming, http://tinyurl.com/yhc4w6
17:44:39 <Pseudonym> That's the one.
17:44:41 <wy> What does "cl" mean in haskell?
17:44:42 <SamB> well I can understand that, but I don't see how that is anything like this image
17:44:42 <Pseudonym> No wonder!
17:44:56 <Pseudonym> SamB: Ah.  Well.  Each pixel is actually an integral.
17:44:58 <Pseudonym> Conceptually.
17:45:08 <SamB> Pseudonym: yes, but, from x=a to x=b?
17:45:12 <dons> chessguy: Prelude System.Random> newStdGen >>= return . take 10 . randoms
17:45:13 <dons> [-108980834,84125263,-1525155621,786585555,808935572,2075676924,32827511,-1743242065,442290259,-106991717]
17:45:19 <Pseudonym> Rendering is the process of converting a continuous signal (the image) into a discrete signal (the raster grid).
17:45:20 <shapr> Pseudonym: Achilleas asked for MVC in Haskell on LtU, and several solutions were suggested to him. But he was unable to understand those solutions as far as I can tell.
17:45:27 <Pseudonym> shapr: Right.
17:45:38 <Pseudonym> SamB: In fact it's a multi-dimensional integral in general.
17:45:44 <SamB> hmm.
17:45:52 <SamB> afk for a bit, hold on
17:45:59 <Pseudonym> Converting a continuous signal into a discrete signal is sampling.
17:46:01 <Deformative> Can haskell do anything C can do,  also does it need a wrapper to work with c libs, and last,  does it need a vm or re or is it compiled to native?
17:46:06 * Pseudonym waits
17:46:35 <shapr> Deformative: yes
17:46:46 <dons> Deformative: visit haskell.org, all your questions will be answered there
17:46:48 * shapr hugs Igloo 
17:47:02 <mgsloan> Derormative - yes; yes; compiled
17:47:14 <shapr> Deformative: http://haskell.org/complex/
17:47:15 <lambdabot> Title: The Lambda Complex
17:47:24 <Deformative> And the wrapper would need to be written in C,  correct?
17:47:27 <emu> re?
17:47:30 <emu> wrapper?
17:47:31 <shapr> Deformative: No
17:47:33 <Pseudonym> Deformative: Maybe.
17:47:39 <Pseudonym> Usually not.
17:47:45 <Pseudonym> If the library is well-written.
17:47:46 <mgsloan> not usually, sometimes, if the C is really crazy
17:47:52 <Pseudonym> Yeah.
17:47:55 <Deformative> Hmm,  interesting.
17:48:04 <shapr> Deformative: http://www.haskell.org/hawiki/FfiTutorial
17:48:05 <lambdabot> Title: FfiTutorial - The Haskell Wiki
17:48:08 <Pseudonym> I can't imagine writing an API for linux device drivers in Haskell FFI.
17:48:12 <Pseudonym> That would be seriously crazy.
17:48:33 <chessguy> dons, so i just have:
17:48:33 <chessguy> module Interesting
17:48:33 <chessguy> where
17:48:33 <chessguy> import System.Random
17:48:34 <chessguy> myRands = newStdGen >>= return . take 10 . randoms
17:49:21 <shapr> Aiee, Achilleas is hurting me!
17:49:28 <shapr> "While it is true that referential transparency (i.e. no assignment) allows better unit testing, the mechanism that allows this quality is not referential transparency itself, but the lack of dependencies of a function from the outside world."
17:49:35 <Deformative> Oh,  I forgot to ask if haskell has a garbage collector.
17:49:39 <Deformative> After that i am done.
17:49:48 <shapr> Deformative: Yes, it does have a garbage collector.
17:49:57 <shapr> Deformative: But you left out the really good questions!
17:49:57 <Deformative> Alright,  thankyou.  =]
17:49:59 * shapr boings
17:50:08 <Deformative> What would that be?
17:50:14 <shapr> the GOOD questions are stuff like, why the heck would anyone use lazy evaluation instead of strict evaluation?
17:50:20 <emu> c'mon now, nothing like reducing an interesting topic to 3 words
17:50:26 <SamB> hmm, I'm not afk but I have to pee... decisions decisions...
17:50:57 <shapr> Deformative: Other good questions are, how does Haskell get better type safety than Java with less keyboard use than Java?
17:51:00 <chessguy> @paste
17:51:01 <lambdabot> http://paste.lisp.org/new/haskell
17:51:04 <Pseudonym> SamB: You need to be AFK to pee unless your computer is set up in an odd location.
17:51:08 <Pseudonym> Or you just don't care, I guess.
17:51:32 <Pseudonym> shapr: These are questions that come with time.
17:51:42 <Pseudonym> And let's face it, you can answer them by actually using the language.
17:51:42 <Deformative> Oh,  that is a good question shapr,  but I try to keep my questions to a minimum because I feel people get irritated when someone asks too many questions.
17:51:52 <Pseudonym> Deformative: Not if they're good questions!
17:51:55 <shapr> Deformative: And there's always "given a list of turing complete languages, why should I use one over the other?"
17:52:01 <shapr> Deformative: Not here on #haskell!
17:52:01 <Pseudonym> And you've asked some pretty good questions.
17:52:09 <dons> Deformative: why so many beginner questions, after all this time? :) http://www.cse.unsw.edu.au/~dons/tmp/def.txt
17:52:19 <dons> (not that we mind too much..)
17:52:29 <lisppaste2> chessguy pasted "mouthful of an error" at http://paste.lisp.org/display/30972
17:53:03 <shapr> Philippa: Have you seen Achilleas' blog entry that summarizes everything he's ever learned on LtU?
17:53:10 <Deformative> Whoa,  that was a long time ago dons.
17:53:25 <Pseudonym> chessguy: The problem that cryptanalysis have with monte carlo methods is that you need a measure of "fitness".
17:53:26 <Deformative> Yeah,  I kinda gave up because of school,  but I have time again.
17:53:33 <Pseudonym> i.e. how close to English some piece of text is.
17:53:35 <SamB> Pseudonym: oh, well, anyway, I know what sampling is...
17:53:36 <sjanssen> chessguy: add an explicit type signature, like ghc tells you
17:53:40 <Pseudonym> SamB: Right.
17:53:51 <Pseudonym> So basically, you're integrating the scene with a filter kernel.
17:53:52 <dons> Deformative: cool. this time for sure eh?
17:54:04 <SamB> yeah, okay.
17:54:11 <Deformative> Not sure.
17:54:11 <Pseudonym> Convolving, I guess.
17:54:16 <SamB> of course...
17:54:18 <Pseudonym> Right!  So that's where the integral comes in.
17:54:21 <Deformative> Maybe dons,  heh.
17:54:28 <Pseudonym> Now pretend we've got a 1D problem to make things simpler.
17:54:33 <SamB> ah ;-)
17:54:34 <Pseudonym> Integrate f(x) from x=a to x=b.
17:54:43 <sjanssen> chessguy: congratulations, you've hit the monomorphism restriction for the very first time!
17:54:44 <SamB> that was the missing link ;-)
17:54:48 <Pseudonym> Right. :_0
17:54:51 <Pseudonym> :-)
17:55:17 <chessguy> just adding myRands :: [Int] doesn't work
17:55:21 <Pseudonym> Now.  You could pick N random points in the range [a,b] and compute the sum of f(x_i) * (b-a) / N.
17:55:27 <SamB> yeah
17:55:31 <sjanssen> chessguy: IO [Int]
17:55:40 <Pseudonym> You do that, you get high variance.
17:55:41 <SamB> but that would be a very silly way to go...
17:55:41 <chessguy> bleah
17:55:48 <chessguy> but i just want [Int]
17:56:04 <Pseudonym> http://andrew.bromage.org/test1.png <- Example of high variance.
17:56:10 <sjanssen> chessguy: can't do it, newStdGen is in the IO monad
17:56:14 <Pseudonym> All that sparkling is variance personified.
17:56:40 <Pseudonym> OK.
17:56:48 <SamB> that one actually looks okay, if a little grainy
17:56:52 <SamB> it reminds me of charcoal
17:56:59 <chessguy> so how do i actually get random numbers out of it?
17:57:03 <Pseudonym> So what you ideally want is a probability density function p which approximates f.
17:57:22 <Pseudonym> And which you can actually use to generate values of x.
17:57:35 <SamB> okay, I don't get that part.
17:57:39 <Pseudonym> OK.
17:57:45 <Pseudonym> Let's suppose your filter kernel is a Gaussian.
17:57:55 <SamB> I don't remember what those are...
17:58:09 <SamB> I have not studied this in much depth ;-)
17:58:13 <Pseudonym> You're actually computing the integral of I(x) * G(x), where  I is the "sample" and G is the filter kernel.
17:58:20 <Pseudonym> Sorry, I is the signal.
17:58:26 <SamB> yeah
17:58:27 <eviltwin_b> chessguy:  it has to stay in the IO monad.  but ultimately the whole program is in the IO monad so that's not *really* a problem
17:58:44 <SamB> though...
17:58:59 <chessguy> ...
17:59:03 <Pseudonym> Now instead of uniformly sampling [a,b], if you can produce values of x which naturally follow the probability density function G, then you can reduce the variance.
17:59:04 <SamB> Is that really what the integral is of?
17:59:12 <SamB> I seem to remember another variable!
17:59:12 <Pseudonym> SamB: Yup.
17:59:17 <chessguy> so if i'm going to use random numbers, i have to have a main do...
17:59:25 <chessguy> main = do...
17:59:32 <Pseudonym> Well, yes, there is another variable.
17:59:33 <eviltwin_b> you do anyway; main :: IO ()
17:59:51 <Pseudonym> Think of it this way:
17:59:55 <chessguy> well, i frequently don't explicitly bother doing that
18:00:17 <Pseudonym> Sample(x') = the integral of f(x) from x = x'-dx to x = x+dx
18:00:22 <chessguy> but in this case i have to?
18:00:25 <Pseudonym> Here, x' is the other variable.
18:00:25 <eviltwin_b> you don't need to be explicit; that's predefined
18:00:36 <Pseudonym> SamB: Got it?
18:00:40 <eviltwin_b> no, my point is that "main" is (whether you say so or not) expected to return IO ()
18:00:49 <Pseudonym> There are other ways to think of it, but we're looking at a specific pixel value here.
18:01:03 <chessguy> ok, well you still haven't answered my question of how i can actually use random numbers out of that
18:01:05 <eviltwin_b> so it's in the IO monad regardless.
18:01:06 <SamB> well, according to mathworld...
18:01:08 <sjanssen> chessguy: you can also use the mkStdGen function -- your random numbers will just be the same across each run
18:01:21 <eviltwin_b> you were correct when you said you needed to do main = do ...
18:01:42 <eviltwin_b> my point is that you need that anyway because main is in the IO monad
18:01:53 <Pseudonym> The key thing here is that you're evaluating one pixel.
18:02:06 <Pseudonym> That is, you're evaluating the convolved function at one point.
18:02:07 <eviltwin_b> (well, you could do a single operation in IO which returns IO (), or use >>= instead of do...)
18:02:09 <Pseudonym> Which is a single integral.
18:02:31 <sjanssen> eviltwin_b: I think chessguy runs his programs from ghci, bypassing the whole main thing
18:02:34 <SamB> f * g = \int f(\tau)g(t-\tau) d\tau
18:02:39 <Pseudonym> SamB: Want to take this ti #haskell-blah?
18:02:46 <Pseudonym> Since this isn't Haskell-specific?
18:02:56 <SamB> okay...
18:03:18 <eviltwin_b> *shrug*
18:03:22 <SamB> gah, stupid x-chat trying to interpret ? as part of channel name
18:03:49 <eviltwin_b> you do need to extract the values within a monad, although once extarcted you can operat on hem non-monadically
18:04:03 <shapr> Why would a parallel algorithm have to lock the garbage collector?
18:04:24 <emu> hahah
18:04:33 <emu> cause that guy is clueless ;)
18:04:42 <chessguy> grrr, i just wish i could get this concept of a monad
18:04:52 <chessguy> and random numbers
18:04:54 <chessguy> and IO
18:04:59 <shapr> emu: I'm trying to write a point by point response to his post.
18:05:11 <sjanssen> shapr: because of the halting problem.  Same reason why you can't prove any algorithm correct ;)
18:05:15 <shapr> Maybe I should just paste the post into Haskell Wiki and fill in the parts as I go along.
18:05:17 <emu> shapr: why bother, he's a troll
18:05:30 <eviltwin_b> don't worry about it too much, just think of it as a box.  you use do {} to work inside of the box.
18:05:35 <shapr> emu: I do think he's really trying to understand, and just not doing a very good job.
18:05:40 <vincenz> Anyone know how to escape a [ in latex?
18:05:41 <Pseudonym> In Erlang, each thread gets its own heap.
18:05:48 <Pseudonym> They get garbage collected separately.
18:05:49 <shapr> Pseudonym: yeah, exactly.
18:06:00 <emu> vincenz: if all else fails, \verb+[+
18:06:17 <eviltwin_b> do { rs <- myRands; {- operate on rs -} }
18:06:26 <wy> it seems i missed something
18:06:30 <shapr> Pseudonym: ok if I quote that?
18:06:35 <Pseudonym> Go for it.
18:06:42 <Pseudonym> You don't have to credit it either.
18:07:02 <wy> OK. I'll ask again. What does "cl" in Haskell mean. I got an error "cl" not found when I tried to compile ghc
18:07:11 <EvilRanter> vincenz, \lbrack?
18:07:11 <emu> wy: are you sure it's not .NET related?
18:07:13 <eviltwin_b> hm, re [, should only be special in certain circumstances and \relax should work to "hide" it
18:07:17 <shapr> wy: I've never heard of such a thing, what are you doing?
18:07:20 <emu> vincenz: is this math mode?
18:07:21 <shapr> @index cl
18:07:21 <lambdabot> bzzt
18:07:33 <eviltwin_b> isn't cl a C compiler?
18:07:47 <wy> emu: I've got --enable-objectio and --enable-dotnet
18:07:49 <emu> maybe it's microsoft's secret Common Lisp
18:07:51 <eviltwin_b> (in context of the original error message, in particular)
18:08:03 <vincenz> emu: normal mode
18:08:06 <emu> you know, the one they used to implement the .NET GC
18:08:21 <emu> vincenz: i may be rusty, why doesn't [ stand for itself?
18:08:28 <wy> emu: Microsoft has common lisp?
18:08:38 <wy> OK. I'll get it removed from the option
18:08:41 <jdev> \snazzylatexthingy[23]{stuff} ?
18:08:50 <EvilRanter> microshoft?
18:08:56 <EvilRanter> (shorry :P)
18:09:32 <eviltwin_b> @go cl compiler windows
18:09:33 <lambdabot> http://msdn2.microsoft.com/en-us/library/9s7c9wdw.aspx
18:09:38 <chessguy> eviltwin_b, so...i need to be in that "box" to do anything with those random numbers?
18:10:05 <eviltwin_b> to initially extract them, yes.  once inside the box you can use pure functions on them, as long as the result comes back into the box
18:10:14 <emu> http://blogs.msdn.com/patrick_dussud/archive/2006/11/21/how-it-all-started-aka-the-birth-of-the-clr.aspx
18:10:16 <lambdabot> http://tinyurl.com/uzazs
18:10:36 <eviltwin_b> do { rs <- myRands; return $ somePureFunction rs }
18:11:01 <eviltwin_b> (think of "return" as closing the box back up, where "do" opens it)
18:11:25 <EvilRanter> i thought return was putting things in the box
18:11:57 <EvilRanter> and <- was getting into the box with the things so you can do stuff with them
18:12:37 <shapr> "can two IO Monads run in parallel over the same data?" ... I'm aghast...
18:13:03 <eviltwin_b> that's anoher way of looking at it, sure
18:13:03 <chessguy> main = do { rs <- myRands; return $ length rs}
18:13:07 <chessguy> this doesn't work
18:13:27 <eviltwin_b> not for main, since main is an IO () but you're returning IO [Int]
18:13:44 <eviltwin_b> use a different name, "main" is special
18:13:49 <chessguy> i can do main = do { rs <- myRands; putStrLn $ length rs}
18:13:50 <hyrax42> I thought ghc 6.6 could have Main :: Show a => IO a
18:13:58 <eviltwin_b> because putStrLn returns IO ()
18:14:12 <hyrax42> or I remember dons blogging something to that effect
18:14:16 <emu> putStrLn . show
18:14:17 <eviltwin_b> (that's also why you don't need to use return)
18:14:45 <chessguy> ok, so now i have foo = do { rs <- myRands; return $ length rs}
18:14:53 <hyrax42> ?hoogle Show a => a -> IO ()
18:14:54 <lambdabot> Prelude.print :: Show a => a -> IO ()
18:14:54 <lambdabot> IO.hPrint :: Show a => Handle -> a -> IO ()
18:14:54 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
18:15:04 <chessguy> but now just doing foo doesn't do anything
18:15:46 <newsham> argh, i just found out all the functional programs I've been writing dont have side effects!
18:15:49 <eviltwin_b> sure, you have an IO value coming back.  you need to use an IO operation to go inside of it (like that putStrLn)
18:16:11 <eviltwin_b> e.g. main = putStrLn foo
18:16:52 <eviltwin_b> (or in ghci, just "putStrLn foo")
18:17:29 <chessguy> for foo = do { rs <- myRands; return $ length rs} ?
18:17:41 <Excedrin> shapr: what's the "two IO Monads" quote from?
18:17:41 <eviltwin_b> yes
18:17:46 <dons> hyrax42: yeah, seems like a recent ghc extension. for example:
18:17:46 <dons> main = return "hello, world!"
18:17:48 <dons> :)
18:17:58 <shapr> Excedrin: Achilleas' new blog that decries FP
18:18:04 <shapr> Excedrin: http://warp9point99.blogspot.com/
18:18:04 <dons> or similarly:
18:18:05 <lambdabot> Title: warp 9.99!
18:18:06 <dons> $ runhaskell A.hs
18:18:06 <chessguy> putStrLn foo doesn't work
18:18:07 <dons> [1,2,3,4]
18:18:17 <dons> I quite like this feature, in fact. We should find out what the story is behind it
18:18:20 <Excedrin> is that the 99.9 degrees one?
18:18:30 <Excedrin> right, it's hillarious
18:18:37 <dons> this is valid these days:
18:18:38 <dons> main :: IO [Integer]
18:18:38 <dons> main = return [1,2,3,4]
18:18:42 <dons> which rocks
18:18:43 <shapr> Excedrin: It's truly amazing...
18:18:48 <chessguy>     Couldn't match `String' against `IO Int'
18:18:49 <chessguy>       Expected type: String
18:18:49 <chessguy>       Inferred type: IO Int
18:18:49 <chessguy>     In the first argument of `putStrLn', namely `foo'
18:18:49 <chessguy>     In the definition of `it': it = putStrLn foo
18:18:52 <shapr> "Of course parellism works when the selected strategy is 'divide and conquer'...but that is hardly an advantage purely derived from functional programming languages only. In fact, Google's MapReduce algorithm is done in C++!!!"
18:18:56 <sjanssen> dons: does it print () ?
18:19:01 <dons> no
18:19:04 <dons> so that's a special case
18:19:08 * shapr bangs his head
18:19:18 <dons> ie. its all in show, except if its ()
18:19:28 <newsham> dons: what does that do?  printStrLn main?
18:19:30 <dons> now i'm not sure if this is an undocumented feature, or a bug even
18:19:32 <dons> but its very nice
18:19:44 <dons> newsham: print , I think
18:19:46 <sjanssen> newsham: main >>= print
18:19:51 <dons> $ runhaskell A.hs
18:19:51 <dons> "hello, world!"
18:19:56 <dons> is a print on String
18:20:09 <dons> its so nice it could almost be standardised...
18:20:15 <dons> since its certainly more useful than IO ()
18:20:22 <dons> (and makes for nice oneliners)
18:20:25 <Excedrin> I like the idea of using a wiki (or any sort of collaborative document editing) to rebuke it, but it has so much funny stuff that treating it seriously sort of reduces the humor
18:20:49 <newsham> now they need   when (__name__ == "__main__") $ main >>= print
18:20:55 <hyrax42> "Not true. The halting problem proves that no algorithm can be proven correct."
18:20:59 <hyrax42> wha
18:21:06 <sjanssen> dons: that is a bit funny, no output when the program is actually compiled
18:21:26 <hyrax42> somebody has their quantifiers screwed up
18:21:37 <dons> sjanssen: oh...
18:21:41 <newsham> /topic #haskell-blah <hyrax42> somebody has their quantifiers screwed up
18:21:43 <dons> so its a ghci thing happening then
18:21:48 <dons> i.e. that default printing stuff
18:22:01 <dons> then maybe simonm et al don't know about
18:22:11 * eviltwin_b was being dumb
18:22:24 <Excedrin> why doesn't "runhaskell -" work? (for one-liners, I guess echo foo|ghci is fine)
18:22:53 <sjanssen> Excedrin: how about runghc?
18:23:08 <sjanssen> dons: seems possible/likely
18:23:13 <hyrax42> newsham: ?
18:23:14 <Excedrin> my runhaskell is runghc
18:23:27 <eviltwin_b> hm, actually if I type foo at the prompt in ghci I get 10 back
18:23:30 <newsham> imperatives are advocating open use of side effects.  I wonder if they're also for open use of control flow.
18:23:40 <newsham> why should control flow have to be reducible?
18:23:48 <jdev> So that's, what, the third or fourth person so far here to run into the line about the halting problem and explode?
18:23:59 <dons> hehe
18:24:01 <sjanssen> jdev: at least
18:24:03 <newsham> some imperative languages support arbitrary control flow
18:24:12 <dons> newsham: I encourage our competitors to make open use of side effects
18:24:21 <sjanssen> jdev: we can't be sure though, counting is an algorithm
18:24:28 <dons> then we'll send them all multicore machines, and take over their customers
18:24:33 <newsham> when you say "our competitors" you're not speaking commercially are you?
18:24:43 <dons> its a brilliant strategy, imo. :)
18:24:53 <newsham> are you in commerce now?
18:24:54 <dcoutts_> dons, so when were we starting that Haskell consultancy company? ;-)
18:25:14 <dons> hah, maybe we should
18:25:25 <dons> specialising in high-perf, high assurance, multicore software
18:25:30 <dcoutts_> If I wasn't so busy, I would
18:25:34 <sjanssen> you'd need a snappy name
18:25:44 <greentea> jdev: Has anyone actually posted any comment about the problem with that halting problem claim?
18:25:47 <newsham> task 1 -- make voting machines with provable properties and open source and auditing.
18:25:51 <newsham> hop to it.
18:25:58 <dcoutts_> and there's lots of other people here who would too, if they had enough time
18:26:03 <newsham> (also paper trail please :)
18:26:19 <shankys> actually, myself and a few friends are doing a Haskell startup
18:26:27 <dons> newsham: mmm. i.e. no mutating the logs...
18:26:34 <dons> keep copies of every transaction...
18:26:45 <newsham> task 2 - write small agile web framework that apps can be implemented quickly in, reimplement competitor's apps and sell to them or out manoever them.
18:26:46 <lisppaste2> allbery_b pasted "ghci seems to like it..." at http://paste.lisp.org/display/30976
18:26:51 <shapr> Man, this guy is too silly for words.
18:27:03 <dibblego> is there a function to return a list that is a maximum length of two given lists?
18:27:05 <dons> is there a paper in: transparent, accountable online voting: using immutable state and software transactions...
18:27:10 <newsham> bonus points for provable security properties
18:27:13 <eviltwin_b> hm, should have used my freenode /nick :)
18:27:40 <dons> > \xs ys -> max (length xs) (length ys) $ [1..10] "haskell"
18:27:41 <lambdabot>  Couldn't match `a -> b' against `Int'
18:27:51 <newsham> i think security would be a good niche for pushing haskell projects.
18:27:55 <dons> > (\xs ys -> max (length xs) (length ys)) [1..10] "haskell"
18:27:56 <lambdabot>  10
18:28:04 <dibblego> > \xs ys -> max (length xs) (length ys) $ [1..10] "haskell" in [1..10] [1..]
18:28:05 <lambdabot>  Parse error
18:28:07 <dons> newsham: that's the Galois brand
18:28:14 <newsham> *nod*
18:28:15 <dons> and it works for them (Aetion too, iirc)
18:28:16 <dibblego> er
18:28:18 <newsham> security is a huge space
18:28:22 <dibblego> > \xs ys -> max (length xs) (length ys) $ [1..10] [1..]
18:28:24 <lambdabot>  Couldn't match `a -> b' against `Int'
18:28:28 <shapr> "Imperative programming does not allow lazy evaluation. FP allows lazy evaluation because functions only depend on their arguments." ... wow
18:28:35 <dibblego> > \xs ys -> max (length xs) (length ys) [1..10] [1..]
18:28:36 <lambdabot>  Couldn't match `t -> t1 -> t2' against `Int'
18:28:45 <shapr> I'm speechless.
18:28:46 <dons> shapr: its scary. you should need a license to be able to post to blogs ...
18:28:50 <newsham> shapr: want a python generator?  how about a C coroutine?
18:29:01 <shapr> newsham: I was thinking about "if"
18:29:01 <dons> ie. a CAPTCHA that involves getting some basic expression to type check
18:29:10 <newsham> short circuit evaluation?
18:29:12 <Excedrin> how about if
18:29:13 <shapr> Without laziness both branches of "if" would always be executed.
18:29:32 <newsham> see, you're thinking too holistically
18:29:33 <monochrom> I am writing a thesis on lazy execution in imperative programming.
18:29:41 <Deformative> Does haskell use the same data types as C?
18:29:43 <newsham> in imperative programming "if" is a language built-in
18:29:53 <dibblego> > (\xs ys -> max (length xs) (length ys)) [1..10] [1..]
18:29:56 <newsham> we dont discuss the property of builtins
18:29:57 <lambdabot> Terminated
18:30:08 <dons> Deformative: that's a weird question...
18:30:10 <SamB> newsham: it is builtin here too...
18:30:20 <dons> Deformative: check http://haskell.org and then start reading YAHT:
18:30:21 <lambdabot> Title: Haskell - HaskellWiki
18:30:22 <dons> ?where yaht
18:30:22 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
18:30:24 <eviltwin_b> er, chessguy?  still there?
18:30:36 <dons> dcoutts_: spj sez "Now SpecConstr should work just fine on Booleans."
18:30:36 <SamB> newsham: it just so happens that it acts just like a function
18:30:47 <monochrom> My thesis also says that predicting time and memory requirements of lazy programs (imperative in my thesis, but it can as well be 1st-order functional) is not that hard.
18:30:49 <newsham> you're thinking too holistically :)
18:30:50 <dons> dcoutts_: "Bools never got in the way; but SpecConstr was stupid.  Forget those Eithers!"
18:30:53 * mgsloan thinks that the point is that imperative if acts in a lazy fashion
18:30:55 <Deformative> Thanks dons.
18:31:05 <monochrom> In particular you don't need a whole-program analysis.
18:31:11 <dibblego> max doesn't return type [a]
18:31:28 <dons> dibblego: its a 5 char tweak to that code, come on.. you can do it!
18:31:41 <dibblego> yeah I know, I'm just making sure
18:32:30 <shapr> monochrom: Sounds interesting, tell me more!
18:33:11 <emu> you could write if test then (\_ -> ...) else (\_ -> ...)
18:33:15 <emu> like smalltalk!
18:34:26 <monochrom> So, how much time does "xs := repeat True" take?  Some people say you have to look at the whole program.  But the only information you need is: how much of that list is used.
18:34:28 <shapr> "Lazy evaluation allows for better code optimization, because the compiler can 'rearrange execution of pieces of code' or arrange the code in such a way that reduces errors." wtf? reduces errors?? He has a new wtf in every paragraph.
18:34:32 <EvilRanter> that looks like trying to do laziness in a non-lazy language, emu
18:34:44 <shapr> monochrom: yup
18:34:52 <emu> EvilRanter: precisely
18:34:54 <dons> ÷/win 23
18:35:00 <SamB> you mean like...
18:35:08 <SamB> > const 1 (error "foo")
18:35:09 <lambdabot>  1
18:35:11 <monochrom> In an imperative setting, I can introduce a ghost variable to tell me how much is used.
18:35:24 <EvilRanter> if you were gonna do that, you'd really need a new syntax for thunks.
18:35:30 <mgsloan> shapr - it's almost like he used a markov chain to generate his post(s?)
18:35:35 <emu> EvilRanter: yep... like [ ... ]
18:35:36 <monochrom> (My supervisor already introduces ghost variables for the passage of time anyway.)
18:35:53 <newsham> that would be a nice slogan "a new WTF in every paragraph"
18:35:53 <EvilRanter> (\_-> ... ) is hideously noisy... emu, is  [...] what smalltalk does, then?
18:36:06 <mgsloan> run an order 3 or 4 on a few haskell articles and you'd get something like that
18:36:10 <emu> EvilRanter: yea
18:36:28 <dibblego> Title: Slashdot - A new WTF in every paragraph!
18:36:36 * SamB tries to figure out what kind of thing \_-> is
18:36:38 <emu> and [ x | x + 1 ] for parameters, or something
18:36:38 <hyrax42> shapr: do these wtfs actually come from the article he links?
18:36:49 <hyrax42> I mean I don't think those arguments are even made there ?
18:36:58 <shapr> hyrax42: did he link to an article? where?
18:37:02 <emu> SamB: looks like a drunken arrow
18:37:07 <EvilRanter> what're we discussing, anyway?
18:37:14 <hyrax42> http://www.defmacro.org/ramblings/fp.html
18:37:15 <lambdabot> Title: defmacro - Functional Programming For The Rest of Us
18:37:24 <hyrax42> he links it before starting to "disect" that article
18:37:36 <monochrom> In the (imperative) program "xs := repeat True; P", P writes into the usage variable to declare how much of xs is used.  The preceding program "xs := repeat True" reads from that and declare it uses that much time.
18:37:57 <shapr> hyrax42: Where in the post does he link to that?
18:38:06 <emu> under "Benefits"
18:38:11 <monochrom> In other words, information in data variables (such as xs) flows forward as usual, but information in usage variables flows backwards!
18:38:24 <SamB> monochrom: of course1
18:38:32 <wy> I see there is a ghc extra libs package. Are they to be compiled with ghc together ?
18:38:32 <SamB> it could hardly flow forwards!
18:38:37 <monochrom> This is very easy to achieve if programs are relations.  Relational composition takes cares of that automatically.
18:38:45 <hyrax42> shapr: search for
18:38:46 <hyrax42> Read this please! There is no point in duplicating information...
18:39:02 <dibblego> speaking of dumb statements, seen in #java (another network), 1 minute ago: Karjala_-33> hashtables obliterate Binary Search Trees efficiency wise
18:39:16 <shapr> oh I see
18:39:21 <hyrax42> he is not making stuff up entirely, he is refuting this other post
18:39:22 <eviltwin_b> wy: you're supposed to unpack it into the source tree before building, IIRC
18:39:35 <monochrom> Phil Wadler did a similar thing, but more complicatedly because some unnecessary lattice/domain theory is involved.
18:39:35 <hyrax42> which is a bit rambly to be fair, but I don't think that those arguments are necessarily made in it
18:39:37 <wy> eviltwin_b: I see. Thanks
18:39:41 <dons> we need #haskell-stupidblogposts
18:39:46 <shapr> truly
18:39:46 <dons> for all the traffic they generate :)
18:40:01 <hyrax42> I just searched all uses of word "compiler" and that wtf on rearranging to reduce errors you cited seems not to be asserted
18:40:09 * eviltwin_b thinks life is too short to worry about slashdot mentality
18:40:17 * EvilRanter is trying to convince a fellow haskeller of the wonders of the Maybe monad.
18:40:20 <dibblego> or stupidblogposts.com
18:40:40 <dibblego> EvilRanter, ask him/her if he/she has ever used the 'throws' keyword in Java
18:40:53 <monochrom> OTOH this idea is kind of alien and new in the imperative formal method community, since they have not thought of flowing backwards very much.
18:41:07 <EvilRanter> dibblego, i think he's run away. said he had work to do.
18:41:26 <monochrom> But of course, it is not that alien to the static analysis community.  They have been doing backward dataflow analyses.
18:41:30 <dibblego> you scared him!
18:41:47 <EvilRanter> yes. yes, I did.
18:42:08 <SamB> I think the [] monad is easier to sell
18:42:10 <EvilRanter> he seemed to not really understand the non-monadic use of Maybe, actually...
18:43:27 <monochrom> A difference from mine is that the dataflow analyses are safe approximations, whereas I don't restrict it to safe finite-time approximations - I'm doing this in a framework of proving programs correct with no concession to automation desires.
18:43:39 <wy> It seems ghc compiled excutables are not depend on libraries specific for haskell ?
18:43:54 <dibblego> EvilRanter, tell him he uses a poor man's version each time he types "throws" -- it really isn't hard
18:44:01 <SamB> wy: not yet, no
18:44:01 <shapr> This same guy who wrote that blog post also said on LtU "I would analyse my view, but I do not think you are willing to listen, and since LtU is not the place for this kind of discussion (there is no other site where this discussion can be done though), I will not proceed."
18:44:20 <shapr> So, should I reply to that post and say "here's his analysis." ?
18:44:38 <monochrom> Moreover I will have to prove that what I do with these usage variables is sound, i.e., whatever you prove using this method, there is some operational semantics agreeing with it.
18:44:40 <shapr> Does he realize he'll be thoroughly castigated?
18:45:31 <wy> SamB: Why do you use "yet"? Will they do it in the future?
18:45:37 <dcoutts> dons, oh, great.
18:45:54 <newsham> arguing on the internet is like winning the special olympics.
18:46:00 <shapr> newsham: argh
18:46:01 <newsham> even if you win, you're still a retard
18:46:23 <dons> dcoutts: yeah, looks like that should solve a few things
18:46:31 <dcoutts> aye
18:46:31 <dons> dcoutts: so you picked TLDI or DAMP?
18:46:38 * dons attempts to register
18:46:42 <dcoutts> TLDI?
18:46:54 <dcoutts> dons, I was planning just on PADL & POPL
18:47:05 <dcoutts> though I'd quite like to sneak into Roman's talk
18:47:09 <dons> both "Types in Language Design and Implementation (TLDI)" and " Declarative Aspects of Multicore Programming (DAMP)" are on the same day. bad timing
18:47:24 <dons> (i.e. Manuel's at TLDI, Roman's at DAMP, on the same day urg)
18:47:35 <dons> dcoutts: ah fair enough
18:47:53 * dcoutts checks the TLDI programme
18:47:57 <dons> dcoutts: so you think i'll be able to tag on to your group booking?
18:48:03 <dcoutts> dons, I think so
18:48:07 <SamB> wy: there are plans for it, yes
18:48:26 <dons> that'd make things a lot easier. and it should be fairly simple for me to just pay at the hotel, but to be booked in with you
18:48:34 <SamB> wy: it is better than waiting forever for stuff to link and having bloated executables
18:48:35 <dons> tldi, http://www.cs.berkeley.edu/%7Enecula/tldi07/program.html
18:48:37 <lambdabot> Title: Untitled Document, http://tinyurl.com/yx5rbs
18:50:08 <dcoutts> dons, yes.
18:50:15 <vincenz> dons: presenting?
18:50:22 * dcoutts can't find the DAMP programme
18:50:23 <wy> SamB: that's good. Hope the library won't be big
18:50:32 <dons> dcoutts: yeah, i've seen it. let me try to find it...
18:50:36 <dons> (i think it went to the ml lsit)
18:50:48 <dcoutts> dons, what ml?
18:51:13 <dons> hmm. maybe TYPES?
18:51:36 <newsham> Most imperative languages have a goto keyword, used in various places (for example, the Linux kernel), and there is no revelation behind it.
18:51:39 <newsham> heehee
18:51:44 <newsham> poor dijkstra
18:51:47 <newsham> poor dead dijkstra
18:52:20 <shapr> I'll be dead one day too.
18:52:31 <newsham> yes, but you'll never be dijkstra :(
18:52:35 <newsham> rip
18:52:40 <shapr> I'm okay with that.
18:53:15 <vincenz> shapr: who is this guy that hsould be castigateed?
18:53:15 <dons> dcoutts: hmm. maybe i imagined it
18:53:17 <vincenz> dons: presenting?
18:53:38 <dons> vincenz: at PADL, dcoutts is giving the bytestring fusion talk
18:53:44 <dons> dcoutts: right? :)
18:53:53 <dcoutts> dons, I am? When did we decide that? :-)
18:53:53 <vincenz> ah
18:53:54 <shapr> vincenz: Achilleas
18:54:11 <vincenz> dons: so you're allowed to go nonetheless? (financially speaking)
18:54:16 <vincenz> shapr: link?
18:54:27 <dons> dcoutts: I figure since you're doing the PhD topic on it, you better get started practicing talking about it.
18:54:34 <shapr> vincenz: http://warp9point99.blogspot.com/2006/11/sincere-comment-on-functional.html
18:54:36 <lambdabot> Title: warp 9.99!: A sincere comment on functional programming, http://tinyurl.com/yhc4w6
18:54:51 <shapr> vincenz: His post is a response to http://www.defmacro.org/ramblings/fp.html
18:54:52 <lambdabot> Title: defmacro - Functional Programming For The Rest of Us
18:54:54 <dons> dcoutts: unless you would prefer me to
18:55:23 <dcoutts> dons, oh I see. Mind you we've both given talks on it before. No I really don't mind either way. I guess we should decide eventually though we should write the slides together.
18:55:31 <dons> yes
18:55:52 <dons> we can combine the 2 different fusion talks i've given with yours
18:56:11 <emu> fusing them?
18:56:24 <jmob> hooray for ghc 6.6 working on intel macs
18:56:58 <monochrom> hahahaha fusing the fusion talks
18:57:08 <dons> vincenz: got to use up the last of my travel funding somehow
18:57:31 <vincenz> dons: ah,you get fixed funding for that
18:57:34 <vincenz> shapr: it's not that bad really
18:57:44 <shapr> vincenz: Read the whole thing
18:57:55 <newsham> so bugs in imperative languages are due to... no... tail-call optimizations.
18:57:57 <newsham> I can see that.
18:58:01 <newsham> all those blown stacks
18:58:16 <vincenz> shapr: diagonally
18:58:20 <sjanssen> {-# RULES dons . dcoutts = leanMeanFusingMachine #-}
18:58:31 <dcoutts> hah hah hah
18:59:37 <dons> mmm. the 16 core lambdabot server is on its way.. yay!
18:59:48 <newsham> there are Just 1 types of people, Nothing and those who understand monads.
18:59:51 <shapr> w00
18:59:55 <shapr> newsham: haha
19:00:06 <dons> so what seemed like a crazy idea last year -- forking a thread for every reqeust -- suddenly turns out to scale onto 16 cores very nicely...
19:00:23 <dons> newsham: heh
19:00:31 <dons> ?remember newsham there are Just 1 types of people, Nothing and those who understand monads
19:00:53 <EvilRanter> is it more normal to say do{...;let x = foo;...} or do{...;x <- return foo;...}?
19:01:02 <sjanssen> EvilRanter: let
19:01:06 <EvilRanter> I've only ever seen the second, but the first must be there for a reason...
19:01:41 <vincenz> shapr: So?
19:02:05 <vincenz> shapr: Any saliently bad parts?
19:02:06 <dons> There is Maybe a type of person: those who fail with Nothing, or those who Just return True
19:02:08 <dcoutts> dons, so how does lambdabot update shared state? eg people's karma if two @user++ commands come in simultaniously? I presume you just use MVars for the shared state ?
19:02:09 <vincenz> Cause it seems reasonalbe
19:02:19 <dons> dcoutts: right
19:02:24 <dons> so per-module locks
19:02:30 <newsham> evil: i use lets often in do blocks.  i dunno how normal that is.
19:02:33 <dons> but it could use STM with only a little tweaking
19:02:42 <vincenz> There is Either a type of person: Those that take the Right path and return, and those that take the Left path and fail
19:03:01 <dons> would be nice to sit down and sort out a proper smp + stm model for lambdabots state
19:03:08 <hyrax42> vincenz: "The halting problem proves that no algorithm can be proven correct."
19:03:10 <dcoutts> dons, I don't know the lambdabot design much, so the state is inside each module record?
19:03:11 <sjanssen> vincenz: the part about algorithm correctness and the haulting program is pretty dumb
19:03:12 <shapr> vincenz: It all starts when he says that it's not referential transparency that gives the benefits that FP talk about, but instead the property of code not being dependent on anything but its inputs.
19:03:19 <hyrax42> I would consider that saliently bad
19:03:20 <dons> so when #haskell has 3000 users, and it runs on 80  cores, it runs non stop
19:03:24 <vincenz> shapr: that is a reasonably valid point
19:03:34 <dons> dcoutts: yeah, there's a global Map, with per-module private state
19:03:37 <monochrom> My only complaint with warp 9.99 is there are too many !'s :)
19:03:40 <vincenz> hyrax42: that's rather strongly put, yes
19:03:44 <vincenz> sjanssen: idem
19:03:55 <newsham> perhaps what he meant to say is that the undecidability means that the compiler isnt going to prove the correctness of your program?
19:04:00 <dons> sjanssen: it could be qwe1234 amost ...
19:04:17 <hyrax42> newsham: I think he meant something like that
19:04:32 <shapr> I think he just doesn't understand what he's talking about whatsoever.
19:04:37 <hyrax42> but saying what he did just really takes away a lot of credibility that could be given to him
19:04:38 <newsham> thats why i only program in Regular languages.
19:04:44 <newsham> no undeciable properties!
19:04:49 <hyrax42> haha
19:04:53 <hyrax42> sweetness
19:05:03 <dcoutts> shapr, he is confused,but I think he's trying to make a valid point, that you can have a referentially transparent imperative language (or code in a referentially transparent style in a normal imperative language).
19:05:18 <dons> my cat falls asleep to My Bloody Valentine, so cute.
19:05:30 <newsham> my reading of his entire rant is -- you can use similar techniques in imperative languages to manage side effects to make programming easier
19:05:39 <dcoutts> shapr, eg the point about functions having local mutable state aka runST
19:05:44 <newsham> and if you program sufficiently similar to a functional style, well, you get the benefits
19:05:48 <newsham> so program functionally in C.
19:05:49 <newsham> :)
19:05:55 <vincenz> shapr: the context is about optimizations, and as such he is right, ref-transparency and clean dataflow programs in imperative languages can be optimized about equally
19:06:06 <lispy> programming functionally in C is like programming OO in C
19:06:19 <lispy> it's possible, but the language will get in your way
19:06:38 <newsham> x = malloc(sizeof *x); x->meth1 = _x_meth1; x->meth2 = _x_meth2; return x
19:06:42 <dcoutts> vincenz, just that the compiler can't take advantage of it much, because most things are not pure. Though note that gcc has a pure attribute which you can tag functions with.
19:06:53 <hyrax42> lispy: programming in C is possible, but the language will get in your way
19:07:07 <newsham> one big difference -- to program OO in C you have to do a lot more.  to program FP in C you have to do a lot less.
19:07:13 <newsham> i think its easier to do more than to do less :)
19:07:20 <EvilRanter> hyrax42++
19:07:23 <newsham> unless you're an aesetic or into that kinda stuff
19:07:42 <dcoutts> thunks and HOFs in C are pretty painful though
19:08:01 <dcoutts> which is why Gtk+ is so much easier in Haskell than C :-)
19:08:08 <newsham> not sure what an HOF is.  gcc has nifty things like address-of-label.
19:08:13 <shapr> dcoutts: Sure, but this guy has been calling "bullshit" on FP for years on LtU and then not understanding the responses to his objections.
19:08:26 <greentea> newsham: "higher order function"
19:08:30 <dcoutts> newsham, Higer Order Function, aka map, or onButton
19:08:31 <newsham> gtk+ in python vs. gtk+ in C is night and day..
19:08:48 <dcoutts> shapr, ah, I see
19:08:50 <newsham> dcouts: ahh..  hmm.. not sure.  writing HOF's is pretty easy, no?  just the extra work to call them.
19:09:12 <EvilRanter> there's not even any extra work, IIRC
19:09:15 <lispy> i have a map example in C, let me conjure it
19:09:20 <dcoutts> newsham, yes, I guess it's the calling them that takes all the effort
19:09:37 <vincenz> shapr: Just because he's a troll does not mean that all his points are invalid
19:09:40 <emu> istr people telling me about the wonderful property of "referential transparency" which C supported by copying everything "call-by-value"
19:09:40 <EvilRanter> "aFunction foo = bar; eek = foo(ack)"
19:09:45 <lispy> http://codersbase.com/index.php/Lists
19:09:55 <EvilRanter> the ugliness is the types
19:10:01 <dcoutts> since you've got to do explict closure-conversion (passing all free vars in a struct via a void* parameter)
19:10:11 <EvilRanter> "(int (*) (int, int))"...
19:10:27 <lispy> EvilRanter: but that's why they invented typedef
19:10:31 <EvilRanter> true.
19:10:41 <EvilRanter> or, should i say, (char)1
19:10:49 <EvilRanter> ;]
19:10:55 <dcoutts> whenever you do a HOF in C, to make it useful you need to have an extra 'void* user' parameter.
19:10:56 <shoffsta> @seen shanky
19:10:56 <lambdabot> I haven't seen shanky.
19:11:02 <shoffsta> @seen shanky_
19:11:03 <lambdabot> I saw shanky_ leaving #haskell 2h 29m 2s ago, and .
19:11:05 <newsham> C types not so bad.
19:11:20 <shapr> vincenz: Sure, but he's been putting up the same points for years. I answered them then, and he didn't understand my answers, and so assumes that my answers are wrong.
19:11:58 <newsham> I know I'm in the minority, but I still like C.  :)
19:12:05 <dcoutts> I like C too
19:12:25 <newsham> i just wouldnt want to write anything larger than 4 days in it.
19:12:38 <dibblego> you can write 4 days in C?
19:12:41 <dcoutts> I pretty much only use Haskell, C and Bash (and a bit of Makefile stuff).
19:12:51 <dibblego> gimme 4! and make sure they are Saturdays or Sundays!
19:13:05 <newsham> i've written 4 days in C over a weekend before
19:13:10 <lispy> newsham: i think is important, but yeah, i don't _want_ to write important things in it because i know it's more work to get it correct
19:13:20 <dibblego> then you could have infinite weekends!
19:13:24 <dcoutts> newsham, 4 day weekend eh? lucky you :-)
19:13:37 <newsham> no, it was the normal type, it just seemed really long
19:13:41 <dcoutts> hah
19:13:50 <newsham> (but i did have a 4day weekend last week..   gobble gobble)
19:15:35 * dcoutts wonders if newsham is referring to the turkey or the consumption thereof
19:15:53 <newsham> we americans did our thanskgiving duties last week
19:16:00 <newsham> which included a turkey and its consumption
19:16:21 <dcoutts> I always miss out on the turkey being a veggie
19:16:26 * mgsloan had cornish game hens instead
19:16:28 <newsham> tofurkey?
19:16:42 * eviltwin_b had a duckling instead
19:16:54 <newsham> i had a cornish hen last year and a duck the year before :)
19:17:00 <lispy> dcoutts: i had really nice vegan pumpkin pie :)
19:17:06 <mgsloan> they didn't even have a turkey at the original thanksgiving...
19:17:14 <eviltwin_b> a pair of cornish hens was last year
19:17:25 <eviltwin_b> dog, on the other hand... :)
19:17:28 <dcoutts> lispy, sounds nice, that and pecan pie is the other traditional thanksgiving one
19:17:29 <mgsloan> heh nice
19:17:32 <lispy> mgsloan: yeah, i was looking forward to giving out smallpox blankets but i couldn't find any native americans :(
19:17:33 <newsham> the first thanksgiving they were probably sucking on indian arrows and bark.
19:17:42 <mgsloan> lispy - lol
19:18:07 * lispy has something like 1/32 native american
19:18:23 <lispy> maybe more, but the 1/32 is all we can prove
19:18:50 <newsham> undeciable.. cant be proven.
19:19:39 <eviltwin_b> bottom? :)
19:19:50 <robreim> I experienced my first thanksgiving on Friday with the local american gaijin.
19:21:12 <dmead> bonk
19:21:24 <monochrom> bang
19:21:39 <monochrom> Bat Man! Bat Man! Bat Man!
19:22:12 <monochrom> tata dada lala dada
19:23:10 <lispy> monochrom: can you explain that chinese saying you told to palomer?
19:23:54 <robreim> dcoutts: I'm trying to compile gtk2hs with profiling. I've run "./configure --with-hcflags="-prof -auto"" and make but I'm getting "Failed to load interface for `System.Glib.UTFString': Perhaps you haven't installed the profiling libraries for package glib-0.9.10.2?" Any ideas?
19:24:06 <dcoutts> robreim, it's not easy to do
19:24:33 <dcoutts> robreim, I've not been able to make it work yet using automake
19:24:35 <monochrom> You can ask me, but whom am I going to ask?  It is a statement about information source.  There ought to be a First Cause.
19:24:50 <robreim> oh ok. Bummar.
19:24:51 <dcoutts> robreim, mind you I was trying to make it build both normal and profiling, just profiling might be easier
19:24:53 * shapr emails a long response to Achilleas
19:25:02 <robreim> I'm getting some infinite loop somewhere so I was hoping for some profiling.
19:25:43 <dcoutts> robreim, one strategy might be to pass flags to make it use .hi file extension even for profiling versions and then rename them to .p_hi before installing
19:25:50 <lispy> monochrom: ah, it makes more sense this time, when i read it in the log i didn't really get it...
19:25:56 <monochrom> There are two usages.  The most common usage is to express: I don't know, why do you think I know more than you?
19:26:07 <dcoutts> robreim, the basic thing is that the Makefiles expect the extension to be .hi
19:26:14 <monochrom> Yeah last time I just wrote "you ask me, I ask whom?"
19:26:47 <dcoutts> robreim, feel free to hack the Makefile.am and mk/config.mk of course, if you have any luck then darcs send in patches.
19:26:52 <monochrom> The second usage is mine.  I use it to express: if I can find out, why can't you?
19:27:05 <lispy> right
19:27:08 <lispy> cool
19:27:15 <monochrom> Of course the two are contrapositions of each other.
19:27:22 <dcoutts> robreim, btw, did you have any luck with wine?
19:27:25 <robreim> dcoutts: ok, thanks. I'll see if I can progress without fixing it. Hopefully somewhere along the way the bug will sort itself out :)
19:27:37 <SamB> monochrom: well, who *were* you going to ask?
19:28:02 <monochrom> I ask the library.
19:28:18 <monochrom> Kids these days should go to the library more.
19:28:26 <robreim> not yet, no. Checked gtk is working and it seems to be (other than fonts by the look of it). Still no luck with gtk2hs. I'm going to leave that one for now too.
19:28:39 <dcoutts> right'o
19:28:52 <robreim> Fix bugs only when absolutely necessary: taking lessons from lazy evaluation in bug fixing.
19:29:09 <monochrom> Instead of sitting in front of computers reading blogs talking about blogs thinking blogs have information.
19:29:18 <SamB> doesn't the librarian tell you to be quiet?
19:29:27 <monochrom> YOU CAN'T LEARN HASKELL FROM BLOGS.
19:29:35 <dons> monochrom: I agree :)
19:29:46 <dons> its like trying to learn math from blogs
19:29:49 <dcoutts> robreim, heh, yeah. Well if you get stricter then we always appreciate the patches :-)
19:29:54 * robreim is starting to wonder if it'd be easier just to somehow setup ghc to cross-compile to windows then just use wine for running compiled code.
19:30:00 <SamB> well, I think learning math from blogs is even harder
19:30:06 <lispy> and apparently you can't learn haskell from leeching from Cale
19:30:12 <monochrom> Yeah that's another benefit of the library.  The patron has to shut up and learn from books.
19:30:20 <dmead> you guys ever tried using scons with haskell?
19:30:29 <SamB> dmead: Yhc is built with scons
19:30:33 <lispy> dmead: doesn't ndm use that
19:30:38 <dmead> ;o
19:30:42 <Cale> lispy: you can't? :)
19:30:42 <lispy> i guess it was a pain to setup though
19:30:52 <dons> dmead: why would you though?
19:30:54 <wy> I got another error when compiling GHC 6.6: /usr/bin/ld: cannot find -loleaut32
19:30:55 <lispy> Cale: well, if palomer is proof then no
19:31:08 <SamB> wy: are you on windows?
19:31:09 <dmead> i think it'd be better for the language to use more mainstream tools
19:31:17 <dmead> or even automake
19:31:18 <wy> SamB: No. I'm on linux
19:31:20 <monochrom> Haha leeching from Cale is great!
19:31:21 <lispy> Cale: i've learned things from you, but maybe i wasn't "leeching" :)
19:31:26 <SamB> wy: that is very odd then
19:31:31 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/
19:31:36 <SamB> it shouldn't try to link with that on linux!
19:31:38 <dmead> i uploaded the java source for my prover frontend
19:31:46 <SamB> that is a windows library!
19:31:52 <eviltwin_b> um.  why is a linuxbuild looking for the windows OLE automation library?
19:31:57 <wy> SamB: Uh... I turned dotnet on before. But it should be switched off with another configure right?
19:32:03 <eviltwin_b> (aka ActiveX)
19:32:12 <SamB> wy: you must not have been thorough enough
19:32:27 <eviltwin_b> dotnet won't work on linux, unless possibly there's a way to cross it with mono
19:32:33 <SamB> and someone needs to be punished for allowing that to be turned on in linux
19:32:44 <wy> SamB: Oh. I won't do a make clean! It already took so much time to compile
19:33:06 <eviltwin_b> heh
19:33:16 <SamB> wy: at least make sure you reconfigured thoroughly
19:33:25 <eviltwin_b> you may not have a choice at this point, if it's looking for activex libs it may be looking for other windows stuff too
19:33:32 <wy> SamB: How to do it?
19:33:38 <SamB> I don't know
19:33:58 <SamB> well, I mean, I guess you use ./configure with vengence
19:35:05 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/provergui1.png
19:35:06 <dmead> :>
19:35:07 <lambdabot> http://tinyurl.com/yeya68
19:37:43 * eviltwin_b picked up oil lamps for the channukiah yesterday, he's ready for the holidays :>
19:37:52 <eviltwin_b> mix
19:38:18 <eviltwin_b> not used to this many tabs open :>
19:39:57 <wy> SamB: I see. DotNetSupport is "NO" in config.mk
19:42:24 <wy> Actually the error is in /home/wy/haskell/packages/ghc-6.6/libraries/Cabal/cabal-setup
19:46:11 <wy> What's objectio ?
19:52:48 <Excedrin> wy: it's a functional GUI library from Clean
19:53:23 <wy> Excedrin: Is it good or bad?
19:54:00 <Excedrin> I like it, but 1) the results look ugly, 2) it's Clean only, 3) it's not very portable afaik
19:55:28 <wy> Excedrin: ugly is really a problem
19:59:24 <wy> Excedrin: I visited clean's site. The gui looks not too bad.
20:00:21 <Excedrin> it's probably worth trying some of the demo programs (the IDE and scrabble game in particular)
20:00:33 <Excedrin> obviously "ugly" is a matter of opinion
20:00:42 <newsham> http://www.thenewsh.com/~newsham/HAppS-StateExample.tgz
20:00:46 <lambdabot> http://tinyurl.com/y6xhmq
20:04:01 <jmob> GHC takes quite a long time to compile.
20:04:14 <dmead> quite
20:04:25 <newsham> 4.5hrs for me last time I tried, and my bin didnt work :(
20:04:28 <wy> jmob: yes...
20:04:41 <mgsloan> ([""]++[""]++) ["foo"]
20:04:50 <mgsloan> > ([""]++[""]++) ["foo"]
20:04:51 <lambdabot>    The operator `++' [infixr 5] of a section
20:04:51 <lambdabot>     must have lower preced...
20:05:08 <wy> More, if you misconfigured it, you will have to start from scratch
20:05:15 <mgsloan> > (["",""]++) ["foo"]
20:05:17 <lambdabot>  ["","","foo"]
20:05:39 <jmob> wy: I'm hoping DarwinPorts has configured it correctly for me
20:05:57 <wy> jmob: What's DarwinPorts?
20:06:03 <sjanssen> 4.5 hours seems long
20:06:24 <lispy> wy: it's like having gentoo on a mac
20:06:28 <jmob> wy: a "build from source" package system for mac
20:06:42 <sjanssen> lispy: a crappy version of Gentoo, but yes
20:06:54 <jmob> lispy: :( ports is from BSD, not Gentoo
20:07:03 <Excedrin> Gentoo is based on ports
20:07:10 <lispy> sjanssen: as a debian user i might tease that 'crappy version of gentoo" is redundant :)
20:07:15 <wy> jmbr: So you are using mac?
20:07:26 * dmead uses gentoo
20:07:34 <dmead> >:O
20:07:40 <eviltwin_b> darwinports is a lousy implementation of ports, though.  (Tcl.  furrfu)
20:07:44 <jmob> Excedrin: -very- loosely based, an in they both compile from source
20:07:57 <dmead> brb
20:08:19 <lispy> sjanssen: if for no other reason than to keep some rivalry :)
20:08:25 <sieni> sjanssen: I think both fink and macports suck, mostly because of packages being broken way too often
20:08:45 <jmob> wy: I'm using an Intel MacBook Pro, which GHC didn't support until 6.6, so I'm happy that it now works.
20:08:47 <sjanssen> sieni: yes, this happens to me all the time :/
20:09:38 <sieni> But I think the problem is more likely with their relatively low number of developers compared e.g. to debian
20:10:08 <sieni> I don't even remember when I've seen package breakages with debian the last time
20:10:15 <Excedrin> jmob: afaik, the Gentoo guy switched to FreeBSD, liked ports, then wrote Portage. So it's designed after ports rather directly..
20:10:20 <sieni> (debian testing)
20:10:20 <jmob> sjanssen: you would think osx macs are a fairly consistent platform to compile stuff on, so it -should- be easy to make sure build recipes are robust.
20:10:40 <johnnowak> I've only had broken packages with macports once, and it was for something huge (X11 and friends).
20:10:44 <newsham> i would love any feedback on happs code.
20:11:07 <jmob> sjanssen: so maybe all it takes for it to be better is a proper build farm
20:11:25 <sieni> johnnowak: well, I could not compile gnucash from macports
20:11:40 <johnnowak> i've solved that problem by not having any money.
20:11:46 <newsham> what is gnucash?  money tracking?
20:11:59 <Excedrin> like quicken... except gpl
20:12:02 <jmob> Excedrin: yeah, I'm aware, the "Gentoo guy" is from my hometown
20:12:06 <sieni> newsham: accounting software
20:12:09 <johnnowak> it's cash that you can copy and give to others, provided that they're willing to do the same
20:12:12 <newsham> how does it compare to MS money and quicken?  does it integrate with e-banking?
20:12:15 <jdev> And a canonical example of dependency hell, last I heard.
20:12:37 <johnnowak> jdev: well, it is gnu software.
20:12:52 <sieni> newsham: I don't know, since I haven't been using any of them. I would have wanted to try gnucash.
20:13:13 <jmob> Excedrin: ..not that being from my home town would imply that I know everything about ones work on open source projects.
20:13:17 <Excedrin> jmob: wow, so you could go buy him a bud lite or something
20:13:20 <sieni> newsham: and gnucash is scriptable in scheme \o/
20:13:30 <newsham> guile?
20:13:35 <sieni> yea
20:13:40 <newsham> how fsf
20:14:07 <newsham> my awk files are scriptable in sh ;-)
20:14:10 <sieni> Gnucash only supports double entry accounting (good thing).
20:14:20 <sieni> http://www.gnucash.org/
20:14:23 <lambdabot> Title: Open Source Accounting Software | GnuCash
20:16:32 * jdev is reminded of that weird office suite that uses SIOD
20:16:43 <jmob> Excedrin: yeah, I'd ask him why he thought writing portage in a bastard mix of shell and python was a good idea.
20:17:32 <wy> jmob: I've considered getting a MacBook. But finally I get a Thinkpad instead, just for compatibility.
20:17:54 <jmob> wy: compatibility to what?
20:18:17 <wy> jmob: compatibility with such softwares.
20:18:18 <dons> wy: yeah, i quite like the thinkpads
20:18:22 <newsham> laptops piss me off.  they come preloaded with so much stupid 'value add' crap that crashes often, has questionable security, doesnt do anything useful.
20:18:47 <dons> i've done my entire phd on an x31, very reliable
20:18:53 <Excedrin> compatibility with games! (2 button mouse am i rite?)
20:18:56 <johnnowak> newsham: isn't that pre-installed copies of Windows and friends pissing you off? surely you get the same things on desktops too.
20:19:05 <newsham> my thinkpad has 3 button mouse
20:19:07 <wy> newsham: But they are small and you can carry it with you. Doing programming in bed, etc
20:19:24 <newsham> johnn: yah, true.  just always seems like more on a laptop.
20:19:25 * lispy is programming in bed on his ibook
20:19:29 <jmob> Excedrin: why would you even play a game with a touch pad? :)
20:19:43 <johnnowak> wy: you could've gotten a macbook and put windows on it, no? :)
20:19:51 <newsham> thinkpad has touch pad and nipple
20:19:51 <Excedrin> my thinkpad has a 2 button trackpad and a 3 button thinkpoint
20:20:21 <johnnowak> newsham: they're nice hardware, yes.
20:20:30 <wy> johnnowak: some software such as photoshop is really cool. Wish linux had it
20:20:47 <newsham> linux has gimp
20:20:50 <johnnowak> wy: not sure what that has to do with getting a thinkpad over a macbook though.
20:21:43 <newsham> photoshop runs in wine, according to winehq.org
20:22:36 <wy> johnnowak: Hmmm... because I don't want to look around for information on how to install a linux on Macbook, etc. I really doesn't make much difference using a mac and a thinkpad if you are used to linux except the configuration
20:23:11 <newsham> http://appdb.winehq.org/appimage.php?iId=1190
20:23:24 <johnnowak> wy: ah -- you meant compatibility with linux. :)
20:23:44 <newsham> err, sorry, i meant:  http://appdb.winehq.org/appimage.php?iId=88
20:25:06 <wy> johnnowak: If I only use Windows in the past, there won't be hesitation buying a mac
20:26:14 <wy> I was just afriad of something won't compile in linux on a mac
20:27:54 <newsham> you can always vmware a linux if you have to
20:28:10 <newsham> w/ all these virtual machines its not as important as it used to be
20:28:45 <johnnowak> wy: would be odd if it didn't compile, them being intel machines and all.
20:30:48 <lispy> i would check on the wifi and suspend/resume support for linux on the laptop you want to buy
20:31:02 <lispy> those tend to be big ones that linux isn't the best with
20:32:39 <Excedrin> it's pretty good on thinkpads, but it does depend on the model
20:33:07 <wy> Actually I just got my T60 this afternoon.
20:33:20 <dons> oh T60 eh? got linux on it yet?
20:33:25 <Excedrin> anyway, it's very easy to check because of http://thinkwiki.org/
20:33:27 <dons> what kind of chip?
20:33:42 * dons is pondering a new X** thinkpad next year
20:33:57 <johnnowak> Excedrin: any resources for *bsd on thinkpads?
20:34:07 <dons> ?google openbsd on the thinkpad x31
20:34:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/x31.html
20:34:08 <lambdabot> Title: OpenBSD on a ThinkPad X31
20:34:25 <dons> johnnowak: its the prefered laptop for openbsd hackers -- i.e. support is really good (everything just works)
20:34:37 <dons> at least for the x4* series
20:34:59 <johnnowak> dons: good to know!
20:35:42 <johnnowak> alas, i'd need something with 3D acceleration.
20:35:47 <wy> dons: Right now :-)
20:36:00 <dons> wy, great.
20:36:10 <dons> johnnowak: ah right. for games or some such?
20:36:27 <dons> or general purpose GPU programming? ;)
20:36:34 <wy> dons: I was just curious what's in the service partition. I got rid of it all together
20:36:47 <dons> yeah, I think its just the suspend to disk stuff
20:36:48 <johnnowak> dons: nah, using opengl for data visualization... primarily directed graphs in 3D space at the moment (not that I have much to show for it yet)
20:36:52 <dons> i've wiped mine too, wy
20:37:05 <eviltwin_b> system recover stuff that ssumes you run windows
20:37:06 <wy> dons: So there won't be any problem ;-)
20:37:06 <dons> johnnowak: oh cool
20:37:28 <eviltwin_b> and install a bunch of windows programs to do the magic backups etc. the recovery tookls know how to read
20:37:32 <dons> yeah, since you won't have to reboot it anyway, who needs to suspend to disk :)
20:37:36 <johnnowak> dons: i also use opengl for artistic purposes, so i'd really miss hardware accelerattion
20:38:13 <eviltwin_b> no, this isn't suspend to disk, this is stuff to write system recovery disks, do a special imagebackup to cd/dvd, etc.
20:38:35 <eviltwin_b> at least if it's the same thing as was on the t30/t40
20:40:04 <conal> I'm using wxhaskell on cygwin and getting this message:  Loading package wxcore-0.10.1 ... can't load .so/.DLL for: wxc-msw2.4.2-0.10.1 (addDLL: unknown error).  That dll is in c:/cygwin/usr/local/lib, and I have LD_LIBRARY_PATH set to that directory.  Any ideas?
20:40:37 * Pseudonym sighs
20:40:41 <wy> Is there a comparison about the speed of the functional languages with conventional ones?
20:40:45 <Pseudonym> Bitten by the lack of Ord (IORef a) again.
20:40:52 <Pseudonym> wy: Speed of what?
20:40:53 <lispy> conal: i think, you need that directory in PATH instead of LD_LIBRARY_PATH
20:40:59 <Excedrin> conal: is that directory in your PATH? I don't think Cygwin uses LD_LIBRARY_PATH..
20:41:07 <Excedrin> efb
20:41:11 <conal> oh!  i'll try that.
20:41:23 <sorear> it's pretty simple - closer to machine == faster code, slower programmers.
20:41:31 <Pseudonym> Languages don't have "speeds".  Specific programs built using specific implementations on specific hardware have speeds.
20:41:31 <lispy> windows has some rather...fun...rules for finding dlls
20:41:34 <Pseudonym> As do programmers.
20:41:35 <sorear> all current machines are imperative, so...
20:41:39 <wy> Pseudonym: speed of the compiled code
20:41:56 <lispy> wy: check the great programming language shootout
20:42:06 <Pseudonym> wy: Only take it with a grain of salt.
20:42:08 <emu> woo hoo, thanks Pseudonym
20:42:10 <lispy> ?google great programming language shootout haskell
20:42:13 <lambdabot> http://dada.perl.it/shootout/
20:42:13 <lambdabot> Title: The Great Win32 Computer Language Shootout
20:42:17 <sorear> Haskell also has a very good FFI
20:42:21 <lispy> that's not the right url!
20:42:28 <Pseudonym> emu: Thanks for waht?
20:42:33 <johnnowak> sorear: closer to machine also often means slower, buggier code.
20:42:36 <seth_> win32?  never
20:42:42 <emu> Pseudonym: 'languages dont have "speeds"'
20:42:45 <Pseudonym> Closer to the machine means less maintainable code.
20:42:53 <conal> lispy, Excedrin: sure enough. that was it.  thanks!!
20:42:56 <Pseudonym> Which means less scope for fixing a performance problem when it's found.
20:43:03 <lispy> conal: ah nice
20:43:09 <lispy> conal: how are things these days?
20:43:13 <emu> better performance through better algorithms!
20:43:18 <lispy> conal: are you back into research at this point?
20:43:22 <Pseudonym> Yay, nice and speedy now.
20:43:35 <Pseudonym> I just replaced IORefs with my own Ord-able IORefs.
20:43:46 <Pseudonym> Now I can store them in Data.Sets instead of associative lists.
20:43:47 <SamB_XP> like, you can't just change your monad in C to achieve better performance ;-)
20:43:53 <Pseudonym> O(N^2) -> O(N log N)
20:44:12 <wy> Pseudonym:  I see.
20:44:24 <Pseudonym> wy: It's actually very hard to compare different languages.
20:44:41 <Pseudonym> The closest anyone has come is the pseudoknot benchmark.
20:44:47 <conal> lispy: i'm well, thanks.  sometimes research & sometimes compassionate communication (http://awakeningcompassion.com).  wandering focus.  missing collaboration especially.
20:44:55 <sjanssen> Pseudonym: how do you achieve the Ord instance?
20:44:56 <Pseudonym> That's a single problem where every language was allowed to implement it in its own idiomatic way.
20:45:22 <Pseudonym> sjanssen: data IOStableRef a
20:45:23 <Pseudonym>   = IOStableRef !Unique !(IORef a)
20:45:26 <lispy> conal: i see.  well, irc can be a good way to start collaborations
20:46:07 <wy> Pseudonym: sometimes I think I should learn some Java. Just for pragmatic reason. I want to get a part-time job
20:46:38 <Pseudonym> I would encourage you to learn some Java.
20:46:43 <Pseudonym> The more languages you learn, the better.
20:47:20 <sorear> sometimes it is confusing, though - I keep trying to pattern match in C
20:47:30 <Excedrin> Pseudonym: do you program professionally? do you still use C++ frequently?
20:47:34 <sorear> (fortunately I don't use that much anymore)
20:47:35 <jdev> sorear: Cyclone?
20:47:37 <SamB_XP> sorear: hehe
20:47:46 <Pseudonym> I'm actually doing C now.
20:47:47 <SamB_XP> that would work better if C had constructor
20:47:49 <Pseudonym> Firmware.
20:47:49 <SamB_XP> s
20:48:00 <wy> Pseudonym: But I really want to avoid Perl
20:48:11 * eviltwin_b is afraid to think what a monad might look like in C
20:48:11 <SamB_XP> wy: it isn't as bad as you think
20:48:17 <SamB_XP> just look at the evil mangler!
20:48:26 <Pseudonym> wy: Then you'll miss out on pugs.
20:48:35 <wy> SamB: It's the most ugly language I've ever met
20:48:43 <sorear> perl is a DSL that tried to  become general perpose
20:48:43 <SamB_XP> oh, sure, its ugly
20:48:51 <sorear> text mangling is its domain
20:48:51 <eviltwin_b> take a look at rexx sometime :>
20:48:56 <Pseudonym> I like Perl, personally.  I haven't written a single AWK script since I learned Perl.
20:49:02 <conal> lispy: i haven't tried that.  thanks for the tip.  i'm working on a new & sort-of-simple approach to functional UIs, wrapped up in an arrow.  called "phooey".  not terribly deep, but fun.  i'm working toward a software release.  then back to eros (http://conal.net/papers/Eros), which is more far-reaching.
20:49:07 <johnnowak> Pseudonym: same here.
20:49:10 <SamB_XP> but, yeah, it is able to do things
20:49:23 <Pseudonym> And I've written far fewer shell scripts, too.
20:49:25 <lispy> conal: nice
20:49:38 <lispy> conal: one thing i would like to work on is implementing a nice scene graph library in haskell
20:49:53 <jcreigh> I like Ruby for those sorts of tasks. It's generally good at the same sort of things, except you don't need a PhD to make a nested array.
20:49:59 <lispy> conal: put the rendering algorithm on top of HOpenGL but give the user a nice functional way to construct the scene
20:50:13 <lispy> conal: but at the moment, school, work and research (darcs) gets in the way :)
20:50:26 <conal> lispy: ouch!!  i have a lot of personal pain associated with that term "scene graph".  but maybe you don't mean it the way graphics people tend to use that term.
20:50:50 <conal> very imperative and representation-oriented, rather than functional and denotational.
20:50:54 <lispy> conal: i mean something that works like open scene graph (if you've seen that) but in haskell
20:50:56 <Excedrin> Pseudonym: do you also use Python/Ruby/scsh/etc to replace shell/awk?
20:51:18 <Pseudonym> Excedrin: Would you be shocked to learn that I don't speak Python, Ruby or scsh?
20:51:19 <lispy> conal: well, i think a scene graph has a much better chance of being functional than opengl does :)
20:51:32 * eviltwin_b uses perl and ruby daily
20:51:35 <Pseudonym> 60+ languages on my resume, and neither Python nor Ruby are there.
20:51:55 <lispy> Pseudonym: scala?
20:52:04 * SamB_XP was just about to quip about Pseudonym having run out of room
20:52:07 <Pseudonym> Nope.
20:52:17 <conal> lispy -- sure.  it's going in direction of values rather than actions.  do you want it to be purely functional?  if so, i'd be interested in collaborating?
20:52:19 <SamB_XP> but then I saw you didn't speek them
20:52:22 <sorear> Ohh, I've only got 15, and  that's counting machine langs and assembly langs separately :(
20:52:26 <Pseudonym> If it's any colsolation, I know someone who beats me by a longshot.
20:52:39 <Pseudonym> Yeah, I count things like Perl 4 and Perl 5 separately.
20:52:50 <Pseudonym> If I know the difference AND they're sufficiently different...
20:52:55 * sorear doesn't remember perl 4
20:52:55 <lispy> conal: i do want it to be purely functional, assuming the performance is acceptable
20:53:02 <Pseudonym> And ML, SML, CaML, O'Caml etc are all different.
20:53:18 <lispy> conal: but, i'm really not sure if i could commit to such an undertaking at the moment
20:53:34 <conal> lispy: great.  i love going for high perfomance and semantic elegance.
20:53:37 <eviltwin_b> if you thnk perl 5 references are ugly, you should see the hacks we used in perl4 to accomplsh it
20:53:40 <Pseudonym> And Cg, HLSL and RenderMan SL are all different, too.
20:53:43 <lispy> conal: indeed :)
20:54:14 <eviltwin_b> mmm, package symbol table hacking
20:54:18 <conal> lispy: i've been wanting to do another 3D algebra also, for use with eros.
20:54:30 <lispy> conal: i don't know eros i guess
20:55:14 <lispy> conal: one thing i would like to see a functional scene graph exploit, and i don't know if it makes sense, is the ease of concurrencyin haskell
20:55:15 <conal> lispy: it's unpublished & unreleased but described at http://conal.net/papers/Eros
20:55:16 <lambdabot> Title: Functional Programming by Interacting with Tangible Values
20:55:18 <Pseudonym> FWIW, I tend to stay away from games programmers, so I don't have an aversion to the term "scene graph".
20:55:28 <Pseudonym> I think of Open Inventor and Maya when I think of that term.
20:56:19 <lispy> conal: interesting
20:56:54 <brad__> anyone here have experience with Network.HTTP ?
20:57:28 <conal> my first eros examples are functional imaging, but functional 3D may be easier, as it's less taxing on software optimization.  i want the compilation response to be immediate.
20:57:42 <Lemmih> brad__: Somewhat.
20:59:02 <magma> how can I split a string into a 2-d array of triples? For example something that splits "000111222000111222" to [[(0,0,0),(1,1,1),(2,2,2)],[(0,0,0),(1,1,1),(2,2,2)]]
20:59:02 <brad__> my question has to do with how headers are stored for responses; as [Header], where the type constructor is Header key value...i am wondering why this is used as opposed to [(key1,val1),(key2,val2)...]
20:59:29 <brad__> then at least i could use 'lookup' to easily get the values for a header key
20:59:36 <magma> with single quotes around those Ints
21:00:53 <brad__> oh well, thanks for listening, i will just try mailing the maintainer
21:01:03 <brad__> take care all
21:01:40 <conal> Pseudonym: i developed my aversion working on and reviewing various 3D api designs at Sun & Microsoft.  my conclusion is that these apis were about data structures that represent languages, but do so poorly enough that they have to make them mutable by the run-time of another language (e.g., C/C++).  so much more straightforward to just use a single language.  and then pick one with a decent type system and lightweight (functional) constru
21:01:47 <lispy> magma: i don't really understand the problem exactly
21:01:57 <lispy> conal: looks like your client cut your message in half
21:01:57 <Pseudonym> Roght.
21:02:39 <jcreigh> lispy: probably the IRC server, actually. IRC is line-based, with lines limited to 512 bytes.
21:02:39 <lispy> magma: with your example you might be able to use group
21:03:15 <magma> lispy: I thought about splitAt, but group may work as well
21:03:28 <conal> lispy: thanks.  weird.  continuing...  and then pick one with a decent type system and lightweight (functional) construction syntax.  oh, and lambda is very helpful!
21:03:30 <lispy> > map (\[x,y,z] -> (x,yz) (group "000111222000111222")
21:03:31 <lambdabot>  Parse error
21:03:40 <lispy> > map (\[x,y,z] -> (x,yz)) (group "000111222000111222")
21:03:41 <lambdabot>  Not in scope: `yz'
21:03:49 <lispy> > map (\[x,y,z] -> (x,y,z)) (group "000111222000111222")
21:03:50 <lambdabot>  [('0','0','0'),('1','1','1'),('2','2','2'),('0','0','0'),('1','1','1'),('2',...
21:03:55 <lispy> heh, i'll get it right eventually...
21:04:07 <magma> yeah, that looks good
21:04:16 <magma> thanks =)
21:04:21 <lispy> magma: np
21:04:39 <lispy> magma: but becareful with taht lambda, you could easily get a pattern math failure
21:04:44 <lispy> er match*
21:05:10 <magma> hmm, why?
21:05:22 <lispy> > map (\[x,y,z] -> (x,yz)) (group "0001112220001112221")
21:05:23 <lambdabot>  Not in scope: `yz'
21:05:28 <lispy> > map (\[x,y,z] -> (x,y,z)) (group "0001112220001112221")
21:05:30 <lambdabot>  Non-exhaustive patterns in lambda
21:05:41 <lispy> the last block isn't a list of length 3
21:05:46 <magma> right
21:05:49 <lispy> > (group "0001112220001112221")
21:05:50 <lambdabot>  ["000","111","222","000","111","222","1"]
21:06:06 <magma> I plan on treating that as an error
21:06:20 <lispy> > map (\[x,y,z] -> (read x::Int,read y::Int,read z::Int)) (group "000111222000111222")
21:06:21 <lambdabot>  Couldn't match `String' against `Char'
21:06:28 <conal> lispy: (backing up) darcs is part of your research?
21:06:34 <lispy> conal: yeah!
21:06:46 <lispy> conal: droundy is at my university now and i'm his student
21:07:13 <lispy> conal: i got sick of the research i was doing, floated around a bit and then found out he was coming to my university
21:07:30 <conal> lispy: nifty.  which uni is that?
21:07:32 <dons> lispy, that's really cool
21:07:38 <lispy> conal: oregon state
21:07:41 <magma> lispy, that was an illustrative example.
21:07:54 <conal> lispy: of course.  sorry i forgot already!
21:08:07 <lispy> conal: np, i was about to say, we met in person once :)
21:08:26 <lispy> conal: in fact, i think i spotted you at the haskell-workshop but didn't get a chance to say hi
21:08:39 <wy> It has been a long time compiling ghc... My processor is 2G Hz...
21:08:46 <dons> lispy, you were hacking darcs, then droundy turns up to supervise you... ?
21:08:56 <lispy> dons: heh, kinda
21:09:14 <lispy> dons: i was hacking darcs because i like darcs and i wanted my research group to use it :)
21:09:24 <lispy> dons: thinking, "Man, this would be fun to do for research"
21:09:53 <lispy> dons: and then he announced to the darcs-devel list that he took an assistant (or is it associate?) professor ship at osu
21:10:23 <lispy> my research group wasn't really going anywhere
21:10:26 <lispy> funding is hard
21:10:41 <lispy> so i asked if i could leave and they didn't stop me :)
21:11:02 <conal> lispy: too bad i missed you at icfp.  i would have enjoyed a chat.  i'd love to arrange another visit to osu.  i've corresponded with martin e about it.  if we got some direction & progress on doing 3d stuff, i'd be more motivated.  also, please check out the eros paper and let me know if it interests you.
21:11:46 <lispy> conal: okay, i'll put it in the queue, but it will likely be at least a week out, because i'm supposed to be slaving away on a term project until the 6 th :)
21:13:47 <conal> lispy: understood
21:13:57 <conal> lispy: and good luck
21:14:14 <lispy> conal: i'll also keep in mind that you'd like to work on a functional scene graph, so if/when i write the code and create the repository i'll send you an email
21:14:17 <lispy> conal: thanks
21:16:56 <conal> lispy: perhaps we could also collaborate on the design before the.  i've been thinking about this kind of thing for about 15 years now.  btw, is martin involved?  he also mentioned functional 3d to me at icfp.
21:17:25 <lispy> conal: interesting, i did mention the idea to him once
21:17:40 <lispy> conal: in the same meeting where i decided to work on darcs :)
21:19:06 <conal> lispy: oh!  perhaps you inspired him.  i don't know.  well, 3d & darcs aren't very related, so maybe you won't want to divide your attention between them.
21:19:38 <lispy> right
21:19:54 <lispy> and i don't know how far i'll go with darcs
21:20:01 <lispy> right now i think i'll stop after my masters
21:20:14 <lispy> well, i plan to stop school, but i don't plan to stop collaborating with academic types
21:21:36 <conal> lispy: have you been getting discouraged with lack of clarity/focus or professor attention there?  grad school can be such a drag when its a long wander.
21:22:02 <Oejet> Grad school is two years, right?
21:22:11 <lispy> conal: my past discouragements have been related to not studying things that truely interest me
21:22:21 <lispy> conal: for example, HCI
21:22:21 <shapr> I thought grad school had halting problems of its own?
21:22:36 <lispy> conal: it's useful, but not what i want to spend my brain time on
21:22:54 * shapr cheers for doing what you love
21:23:00 <conal> lispy:  doesn't really connect with your passion?
21:23:09 <lispy> conal: that's a great way to put it
21:23:22 <emu> i can't figure out what i want to study
21:24:04 <shapr> emu: I try to study stuff, and then if it falls into what I don't want to study, I do something else.
21:24:14 <emu> officially or just on your own?
21:24:40 <shapr> If "official" means "works towards a degree" then I've never officially studied anything :-)
21:24:44 <emu> ok =)
21:24:56 <emu> yea it's tough to convince admissions if you can't convince yourself
21:24:57 <augustss> conal: hi!
21:25:06 <conal> lispy: yeah, "useful" isn't enough.  has to get a fire going in you.
21:25:20 <emu> i can take classes but i just dont feel motivated about any of the description
21:25:21 <emu> s
21:25:39 <lispy> conal: i'm interesting in mathematics and theory with cool applications :)
21:25:40 <conal> augustss: hi.
21:26:02 <conal> lispy: me too, exactly that combo.
21:26:14 <shapr> emu: Take classes that follow what you know you want to learn?
21:26:38 <conal> augustss: hi lennart
21:26:50 <emu> unfortunately there are no classes on "vague wanderings in logic and type theory"
21:26:56 <shapr> Maybe there are...
21:27:07 <hyrax42> emu: there can be at upper level
21:27:12 <augustss> i think there are :)
21:27:12 <hyrax42> often have silly sounding anmes
21:27:29 <augustss> I think I've taught one
21:27:38 <hyrax42> e.g. my "Advanced programming languages course" next term is going to be domain theory and scott topology, I think
21:27:43 <shapr> I find the imbetween parts of TaPL not very exciting, but I find the end parts exciting. So I flip to the back of the book to get interested, and then I realize I do want to learn the 'boring' parts.
21:27:53 <hyrax42> well my course on that next term is titled "advanced programming langauges"
21:28:10 <hyrax42> it could just as easily have been titles the same but be "vague wanderings..."
21:28:12 <emu> yea im working through TaPL slowly
21:28:27 <shapr> So I'd suggest finding some concepts that you want to learn, and then taking background classes that will work you up towards what you really want to know.
21:28:32 <hyrax42> I had that problem with TaPL
21:28:36 <hyrax42> :/
21:28:59 <edwardk> emu: if you find a course on such vague wanderings, let me know =)
21:29:01 <hyrax42> need to try it out again I think
21:29:07 * mgsloan is beginning to wonder if the docs are out of sync with his modules... I don't have an 'alter' function in Data.Map...
21:29:15 <shapr> emu: You could always organize a non-credit weekend course here on #haskell
21:29:31 <emu> every semester i say im gonna try to take a class, and everytime i slack out of it
21:29:47 <emu> tomorrow i'll look again =)
21:29:55 <edwardk> i found that reading papers on pure type systems really helped motivate understanding the tail end of TaPL
21:30:35 <edwardk> shapr: well, pretty much everything we talk about over on ##logic could be construed as 'vague wanderings in logic and type theory' =)
21:30:51 * shapr adds that to his autojoin list
21:31:00 <conal> any wxhaskell users here?
21:31:25 * lispy raises half a hand
21:32:01 <lispy> conal: i can help with some wx stuff, i used it to make one gui program at work but i didn't try too much before we moved in a different (non-haskell gui) direction
21:32:19 <conal> i just recompiled a wxhaskell app and am getting only the first character for my labels and text fields.  ghc 6.6 and latest darcs wxhaskell.
21:32:29 <conal> anyone seen that?
21:32:44 <emu> i should print this Theoretical CS cheatsheet out and post it on the wall
21:32:45 <lispy> no, i haven't but i haven't used those versions together either
21:33:03 <dons> mm! http://programming.reddit.com/info/t123/comments
21:33:06 <lambdabot> Title: A Newbie in Haskell land (reddit.com), http://tinyurl.com/y5p3br
21:33:20 <dons> alphacar++
21:33:24 <lispy> conal: is it possible that your source files are using an encoding that wxhaskell doesn't support?
21:33:59 <emu> i think one problem people have with monads is that they try to assign one and only one interpretation to them
21:35:03 <conal> lispy: hmm.  i don't know.  i'm using emacs on WinXP.
21:35:13 <mgsloan> emu - yeah, looks like that's what this tut hits :)
21:35:28 <lispy> conal: there is a way to ask emacs for the encoding but i don't know it
21:35:51 <lispy> conal: well, did this example work in a previous version of those things or just a previous test run?
21:36:17 <magma> so lispy, what would I need to do to make that lamba work with a user-defined type instead of a triple?
21:36:57 <hyrax42> dons, how do you find these
21:37:06 <conal> lispy: previous version of ghc & wxhaskell
21:37:14 <lispy> magma: well, you were doing, \[x,y,z] -> (x,y,z) == \[x,y,z] -> (,,) x y z, so we can just replace (,,) with the costom constructor of your user defined type
21:37:22 <conal> i'll ask the wxhaskell-users alias for ideas
21:37:55 <lispy> conal: the encodings of source files was a big change in ghc6.6, and iirc, wxhaskell only does something simple like ASCII...that's why i'm wondering
21:37:57 <hyrax42> or was he on planet already
21:38:42 <magma> lispy: that tells me an Eq instance is required
21:38:50 <lispy> magma: like data Foo a = Foo a a a, \[x,y,z] -> Foo x y z
21:38:58 <magma> yeah
21:39:02 <lispy> magma: right, look at the type for group
21:39:03 <conal> lispy: oh, i hadn't heard that about ghc6.6.  maybe you've put your finger on the problem.  i'll see if people really have wxhaskell & ghc 6.6 working together.
21:39:05 <lispy> ?type groupBy
21:39:07 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
21:39:17 <lispy> ?type group
21:39:19 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
21:39:20 <dons> hyrax42: I have RSS feeds of google's blog search for the keywords 'haskell programming'
21:39:29 <hyrax42> ahhh
21:39:30 <lispy> magma: group = groupBy (==)
21:39:32 <hyrax42> that's what I was going to ask
21:39:42 <hyrax42> well was going to ask if you had technorati search
21:39:51 <hyrax42> but google blog search is about the same
21:39:54 <lispy> magma: if your list elements don't support Eq, then you can swap in your own comparator
21:40:03 <dons> I've looked at that too, but not yet found it as good as google
21:40:07 <magma> ah, ok
21:40:25 <hyrax42> I was only vaguely aware of the existence of google blog search
21:40:40 <hyrax42> I had "passive knowledge" of it
21:40:43 <jdev> > groupBy (/=) "00112012121133"
21:40:45 <lambdabot>  ["0","0112","012121133"]
21:41:05 <dons> hyrax42: oh , also, I see it's on planet.haskell too: http://planet.haskell.org/
21:41:07 <lambdabot> Title: Planet Haskell
21:41:16 <lispy> magma: oh, the compator needs to define equivalence classes, iirc
21:41:16 <hyrax42> ye saw
21:41:45 <jdev> > take 10 $ map length $ groupBy (/=) $ fix show
21:41:47 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
21:41:51 <hyrax42> what is is groupBy (/=) doing
21:42:14 <jdev> It's starting a new group when it finds a value that isn't not equal to the first value in the current group.
21:42:31 <lispy> hah, i never wrote a monad tutorial!
21:42:36 <dons> lispy: shame!
21:42:40 <hyrax42> oh I thought it scanned by adjacent elements
21:42:40 <dons> (me neither :)
21:42:55 <dons> (oh, I guess the irc bot has the phrase 'roll your own monad' in it ...)
21:43:08 <jdev> That's what I thought, but I guess not.  In this implementation, at least.
21:43:25 <hyrax42> dons, would you recommedn perusing lambdabot source as a "real" app?
21:43:47 <dons> mmm. its a fairly weird program. first class modules and so on
21:43:49 <lispy> lambdabot, darcs and ghc could all be considered real haskell apps
21:43:55 <lispy> imo
21:43:59 <dons> pugs is nice too
21:44:02 <lispy> ah, riht
21:44:05 <dons> I like hmp3's src
21:44:08 <dons> ?where hmp3
21:44:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
21:44:10 <hyrax42> well I'm wanting reasonably small ones that will have error handling and such
21:44:19 <dons> have a look at hmp3 then
21:44:20 <hyrax42> and readable
21:44:22 <hyrax42> kk
21:44:25 <dons> lots of error handling, threads, comments
21:44:28 <lispy> hyrax42: i have a compiler i'm working on :)
21:44:32 <hyrax42> yay
21:44:34 <dons> yi's also pretty good comment and exception-handling wise
21:44:39 <lispy> hyrax42: uses some custome monad
21:44:47 <lispy> ?where helisp
21:44:47 <lambdabot> http://www.codersbase.com/index.php/helisp
21:44:51 <lispy> hyrax42: ^^
21:45:24 <hyrax42> nonworking link?
21:45:30 <lispy> hmm..
21:45:53 <lispy> oh weird
21:46:05 <hyrax42> even the gcache isn't working
21:46:22 * lispy looks into it
21:47:12 <lispy> hyrax42: try now
21:47:25 <lispy> restarting apache fixed it
21:47:27 <hyrax42> fixed
21:47:58 <hyrax42> I thought you said compiler
21:48:03 <lispy> hyrax42: Compile is the interesting part
21:48:11 <lispy> hyrax42: ah, righ ti need to update that page
21:48:19 <lispy> hyrax42: it _used_ to be an interpreter
21:48:28 <lispy> hyrax42: now it compiles to x86 and x86_64
21:48:47 <lispy> hyrax42: and CodeGen
21:48:48 <hyrax42> lispy: also your darcs browse link no worky
21:48:58 <lispy> okay...
21:49:07 <hyrax42> no worries
21:49:16 <monochrom> krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the entire human race would have to be rewritten!
21:49:17 <hyrax42> I should just darcs get anyway
21:49:22 <dons> alpheccar++ -- got the spelling wrong earlier
21:49:22 <lispy> hyrax42: running a chmod on it now
21:49:31 <dons> monochrom: hmm!
21:49:34 <mgsloan> dons - you know how Data.Char.isSymbol is missing?  I think Data.Map.alter is as well.
21:49:52 <dons> ?remember monochrom krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the entire human race would have to be rewritten!
21:49:55 <lispy> hyrax42: oh, i see the darcs cgi is broken...
21:49:58 <monochrom> haha
21:50:02 <lispy> hyrax42: i must have uninstalled darcs.cgi
21:50:03 <dons> mgsloan: it may be. sounds like the Char libs got improved recently
21:50:41 <mgsloan> ah, hmm.  Left behind the docs eh? not good.  I don't think my ghc is the most recent though
21:51:02 <sjanssen> mgsloan: are you on GHC 6.4.something?  I think those are both new to GHC 6.6
21:51:31 <mgsloan> oh, yes, i am
21:51:34 <dons> -- | Selects Unicode symbol characters, including mathematical and
21:51:35 <dons> -- currency symbols.
21:51:35 <dons> isSymbol :: Char -> Bool
21:51:38 <dons> only in ghc 6.6
21:52:05 <mgsloan> I suppose I should get something better than my distro's repo's version
21:52:05 <dons> same with: alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
21:53:18 <dons> mmm, I quite like this new little tute, people should mod it up! http://programming.reddit.com/info/t123/details  :)
21:53:21 <lambdabot> Title: A Newbie in Haskell land (reddit.com), http://tinyurl.com/y5tlqm
21:54:00 <dons> getting into ReaderT by section 3 is good good
21:54:21 <mgsloan> I like it too. good strategy for explanation.  Could be expanded to a more elaborated version as not just a tut for those left feeling confused by others
21:54:50 <mgsloan> then again if you totally read through this one you'd probably be even more confused, but you'd understand it alot better ;)
21:54:51 <dons> mm. i should polish up my Reader interpreter as a tut
21:54:53 <dons> its quite cute
21:55:08 <dons> everyone likes interpreters, right?
21:55:19 <dons> just need to add a parsec frontend
21:55:22 <emu> i have yet to write a monad tutorial
21:55:27 <dons> emu, slacker!
21:55:37 <dons> please hand back your #haskell authority form 1A
21:55:40 <emu> i could turn my monad transformer into a literate hs program!
21:55:51 <dons> that's the spirit.
21:56:08 <emu> oh that reminds me: i'm having trouble categorizing a library
21:56:17 <dons> oh?
21:56:24 <emu> it's a temporal network constraint solver.  what would that go under in the hierarchy?
21:56:24 <dons> and you've seen the lib namespace guide?
21:56:28 <emu> yes
21:56:32 <dons> mm. tricky
21:56:49 <Pseudonym> emu, have you written a compiler?
21:56:51 <Pseudonym> Even a small one?
21:56:54 <emu> yes
21:56:57 <Pseudonym> OK, then.
21:56:58 <dons> ah !
21:57:05 <dons> yes, that's ok. that fits the rules
21:57:21 <dons> Pseudonym: did you see the russian haskell site talking about your 'newbie/monad/compiler' comment?
21:57:28 <Pseudonym> No.
21:57:30 <Pseudonym> Where is that?
21:57:50 <mgsloan> what'd be the best way to get ghc 6.6?
21:57:53 <edwardk> newbie/monad/compiler?
21:57:55 <mgsloan> for ubuntu
21:58:03 <dons> http://palm-mute.livejournal.com/2953.html
21:58:05 <lambdabot> Title: palm_mute: Цитата
21:58:28 <dons> make of that what you will :)
21:58:30 <sjanssen> we ought to do a little straw poll, I suspect the percentage of compiler authors is startlingly high here
21:58:49 <emu> i even have ACDI though i havent used it for a while
21:58:49 <dons> ?help poll
21:58:49 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
21:59:00 <Pseudonym> Wht I want to know is why these Russians have a "wombat crossing" sign as an avatar.
21:59:04 <dons> ?help poll-add
21:59:05 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
21:59:14 * Pseudonym digs out babelfish
21:59:26 <Pseudonym> Dammit, internal error.
21:59:27 <dons> ?poll-add Written_a_compiler_or_interpreter?
21:59:27 <lambdabot> Added new poll: "Written_a_compiler_or_interpreter?"
21:59:35 <dons> ?help choice-add
21:59:35 <lambdabot> choice-add <poll> <choice>  Adds a new choice to the given poll
21:59:40 <sjanssen> @yow -- when did that appear?
21:59:40 <lambdabot> I'll eat ANYTHING that's BRIGHT BLUE!!
21:59:41 <emu> well everyone's written an interpreter
21:59:55 <jdev> Does it count if the compiler is from one machine language to another, and does only relatively simple optimizations, and is in C?
21:59:57 <dons> ?choice-add Written_a_compiler_or_interpreter? Yes
21:59:58 <lambdabot> New candidate "Yes", added to poll "Written_a_compiler_or_interpreter?".
22:00:00 <dons> ?choice-add Written_a_compiler_or_interpreter? No
22:00:01 <lambdabot> New candidate "No", added to poll "Written_a_compiler_or_interpreter?".
22:00:08 <dons> ?help poll-show
22:00:08 <lambdabot> poll-show <poll>            Shows all choices for some poll
22:00:09 <mgsloan> ?choice-add Written_a_compiler_or_interpreter interpreter
22:00:10 <lambdabot> No such poll: "Written_a_compiler_or_interpreter"
22:00:12 <Pseudonym> Woo!
22:00:21 <dons> ?poll-show Written_a_compiler_or_interpreter?
22:00:22 <lambdabot> ["No","Yes"]
22:00:22 <Pseudonym> I now know how to spell "monad" in Cyrillic!
22:00:31 <dons> ?help vote
22:00:32 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
22:00:34 * monochrom shivers
22:00:43 <dons> ?vote Written_a_compiler_or_interpreter? Yes
22:00:43 <lambdabot> voted on "Yes"
22:00:53 <emu> oh did the compiler have to be written in haskell?
22:01:05 <dons> ?poll-result Written_a_compiler_or_interpreter?
22:01:05 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=0, Yes=1
22:01:14 <sjanssen> @vote Written_a_compiler_or_interpreter? Yes
22:01:14 <lambdabot> voted on "Yes"
22:01:18 <mgsloan> ?vote Written_a_compiler_or_interpreter? Yes
22:01:18 <lambdabot> voted on "Yes"
22:01:36 <dons> ?poll-result Written_a_compiler_or_interpreter?
22:01:37 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=0, Yes=3
22:01:39 <LoganCapaldo> How complete of a compiler or interpreter?
22:01:46 <magma> I'm quite new to haskell. could someone point me in the right direction for learning IO? Essentially what I'm trying to do is read a file and return a representation of that file for use by some other function.
22:01:55 <mgsloan> LoganCapaldo: Turing complete!
22:01:57 <mgsloan> ;)
22:02:16 <LoganCapaldo> @vote Written_a_compiler_or_interpreter? No
22:02:16 <lambdabot> voted on "No"
22:02:23 <edwardk> ?vote Written_a_compiler_or_interpreter? Yes
22:02:24 <lambdabot> voted on "Yes"
22:02:24 <emu> ?vote Written_a_compiler_or_interpreter? Yes
22:02:25 <lambdabot> voted on "Yes"
22:02:28 <dons> magma, readFile
22:02:37 <emu> @hoogle readFile
22:02:38 <lambdabot> Prelude.readFile :: FilePath -> IO String
22:02:38 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
22:02:38 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
22:02:42 <robreim> in a channel where "hasn't written a compiler or interpreter" has been equated to "newbie" how many people do you seriously expect to volunteer their "no"?
22:02:45 <dons> > readFile "/etc/passwd"
22:02:47 <lambdabot>  <IO [Char]>
22:02:48 <magma> dons, yeah I'm already using readfile, I just don't understand how to return data from an IO function
22:02:53 <emu> lol
22:02:59 <jdev> Enh; between that and the mini-scheme-in-scheme I wrote in '99...
22:03:00 <emu> IO in lambdabot?
22:03:05 <greentea> robreim: Oh, i have no problem declaring myself to be a newbie. :-)
22:03:07 <jdev> @vote Written_a_compiler_or_interpreter? Yes
22:03:07 <magma> I've only figured out how to return an IO version of the data type
22:03:08 <lambdabot> voted on "Yes"
22:03:22 <greentea> ?vote Written_a_compiler_or_interpreter? No
22:03:23 <lambdabot> voted on "No"
22:03:24 <monochrom> No, "written a compiler or interpreter" is admittance, "written a monad tutorial" is newbie.
22:03:35 <edwardk> robreim: heh, maybe the vote should be refined, "did it have types?" "did it have dependent types?" "was it lazy?"
22:03:35 <Lemmih> magma: That's how it's done. You can't escape the IO.
22:03:40 <greentea> monochrom: Heh, so i'm not even a n00b yet?
22:03:49 <magma> ok
22:03:49 <Excedrin> magma: do filecontents <- readFile "some/file"; putStrLn $ f filecontents
22:03:54 * monochrom is still a newbie
22:03:54 <jdev> I see a great need for a Gazebo Monad.
22:03:58 <emu> i would definitely write my next compiler in haskell, i just don't have any call to do so now
22:04:00 * hyrax42 too
22:04:00 <LoganCapaldo> Apparently I'm not allowed in this channel <g>
22:04:21 <Pseudonym> Even the unwashed masses are allowed on this channel.
22:04:27 <LoganCapaldo> Unless a calculator or a 1/8th of a forth counts
22:04:28 <emu> jdev: a "G-onad" for short?
22:04:28 <mgsloan> come back when you've written an interpreter :)
22:04:29 <robreim> @vote Written_a_compiler_or_interpreter? No
22:04:32 <Pseudonym> But we do have spare hair shirts if you want.
22:04:38 <mgsloan> LoganCapaldo: I'd say so
22:04:39 <lispy> hyrax42: working now
22:04:41 <lispy> hyrax42: http://projects.codersbase.com/cgi-bin/darcs.cgi/helisp/?c=browse
22:04:49 <lambdabot> voted on "No"
22:04:59 <lambdabot> Title: darcs repository, http://tinyurl.com/y235m7
22:05:01 <robreim> I stopped writing compilers and interpreters once I started using haskell :P
22:05:10 <dons> magma: here you go, number lines of a file:
22:05:11 <monochrom> ha
22:05:11 <dons> import System.IO
22:05:12 <dons> import Text.Printf
22:05:12 <dons> main = do
22:05:12 <dons>     s <- readFile "/etc/passwd"
22:05:14 <dons>     mapM_ (\(n,s) -> printf "%3d %s\n" n s) $ zip [(1::Int)..] (lines s)
22:05:25 <sjanssen> robreim: why?
22:05:32 <dons> magma: the key is to use <- to get back the String from the IO String
22:05:36 <LoganCapaldo> @type printf
22:05:38 <lambdabot> forall r. (PrintfType r) => String -> r
22:06:07 * LoganCapaldo decides to just accept that that somehow works
22:06:12 <dons> heh
22:06:22 <robreim> sjanssen: because haskell's advanced state intimidated me into figuring I don't know enough about language design to write good compilers / interpreters.
22:06:24 <dons> > printf "%s" "ok!" :: String
22:06:25 <lambdabot>  "ok!"
22:06:31 <dons> > printf "%s" "ok!" :: IO String -- not ok ;)
22:06:33 <lambdabot>  <IO [Char]>
22:06:47 <edwardk> ?poll-result Written_a_compiler_or_interpreter?
22:06:48 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=3, Yes=6
22:06:48 <emu> @type printf
22:06:49 <lambdabot> forall r. (PrintfType r) => String -> r
22:06:55 <mgsloan> robreim - yeah, haskell has killed my language too
22:06:55 <LoganCapaldo> @type printf "%s %d"
22:06:57 <lambdabot> forall r. (PrintfType r) => r
22:07:02 <jdev> @inst PrintfType
22:07:03 <lambdabot> Maybe you meant: instances instances-importing list
22:07:07 <jdev> @instances PrintfType
22:07:09 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
22:07:19 <lispy> dons: have you ever noticed that you can have source modules which cabal doesn't know about and still be able to build your code?
22:07:21 <dons> ?type printf "%s %c" "foo"
22:07:23 <hyrax42> ?instances-importing Text.Printf PrintfType
22:07:23 <monochrom> In particular Int -> String -> IO() is an instance of PrintfType, i.e., it can be the "r".  Therefore you are seeing printf "%3d %s\n" :: Int -> String -> IO() there.
22:07:23 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
22:07:24 <lambdabot> (a -> r), IO a, [c]
22:07:31 <dons> lispy: hmm. maybe in the old days?
22:07:53 <hyrax42> ?inst-imp Text.Printf PrintfType
22:07:53 <lambdabot> Unknown command, try @list
22:07:54 <emu> hmm, how does printf work lol
22:07:59 <emu> crazy overloading?
22:08:02 <dons> ?type printf "%s %c %d %s" "foo" 'x' (42 :: Int)
22:08:03 <lambdabot> forall t. (PrintfType ([Char] -> Char -> Int -> t)) => t
22:08:08 <sjanssen> lispy: I've done that before.  I think you'll get link errors eventually
22:08:13 <hyrax42> emu: for really smart people to kno, and me and you not to
22:08:15 <hyrax42> I think
22:08:19 <hyrax42> know
22:08:22 <emu> how many olegs?
22:08:27 <monochrom> 1 oleg
22:08:28 <dons> note the class constraint building up the list of argument types
22:08:32 <LoganCapaldo> My brain hurts
22:08:33 <hyrax42> 0.2 maybe
22:08:35 * lispy just had an idea
22:08:37 <dons> I think 0.4 Olegs
22:08:42 <hyrax42> damn
22:08:43 <hyrax42> 0.4
22:08:49 <dons> its not too bad (just a recursive class to suck in the n-ary args)
22:08:50 <lispy> maybe the wiki pages should be rated in olegs
22:09:07 <LoganCapaldo> I should have stuck with just accepting that it works somehow :)
22:09:12 <sjanssen> isn't Oleg an incomplete measurement?  An Oleg-hour makes more sense to me
22:09:14 <lispy> so that beginners know if they are too hard to understand at a glance :
22:09:17 <lispy> :)
22:09:29 <hyrax42> aren't oleg's a measure of type-system hackery?
22:09:35 <lispy> hyrax42: yes
22:09:37 <hyrax42> or a measure of brain-hurtness in general
22:09:42 <monochrom> Base case: IO() is a PrintfType.  Induction step: if r is a PrintfType, so are Int->r, String->r, etc.
22:10:10 <hyrax42> also String is a PrintfType
22:10:14 <LoganCapaldo> @type printf "%s" 2
22:10:14 * robreim wonders if people like Guido Van Rossum would have gotten intimidated and given up if they'd looked closely at haskell early in their language design
22:10:16 <lambdabot> forall t t1. (PrintfType (t -> t1), Num t) => t1
22:10:19 <hyrax42> as alternative base case
22:10:20 <hyrax42> ?
22:10:26 <monochrom> Now, whether the actual thing you get matches the format string, that is going to be checked at runtime.
22:10:27 <dons> robreim: hehe
22:10:31 <mgsloan> robreim - probably
22:10:35 <LoganCapaldo> Oh ok
22:10:36 <dons> robreim: you mean like "oh man, I can't compete with this"
22:10:38 <emu> guido is afraid of lambda
22:10:45 <LoganCapaldo> So it's not _that_ scary :)
22:10:54 <mgsloan> dons - more like aw man, this is great but it's really hard to reimplement
22:11:08 <mgsloan> (and thus expand upon)
22:11:15 <robreim> dons: kinda. More like "type inference? type classes? monads? lazy evaluation? Maybe I don't know anything about language design after all"
22:11:17 <emu> so didya know Ruby was the name of the VB-precursor
22:11:21 <dons> Haskell : Destroying the motivation for new languages since 1990"
22:11:29 <mgsloan> hehe
22:11:34 <dons> robreim: hehe. right!
22:11:44 <LoganCapaldo> Haskell: Too lazy to create a new language
22:11:44 * hyrax42 wants to try some epigram some time
22:11:48 <sjanssen> emu: Guido is to Wadler/Lambda Man as Lex Luthor is to Clark Kent/Superman?
22:11:50 <emu> so both Python and Ruby used existing names!
22:11:50 <Pseudonym> sjanssen, one Oleg is the amount of type hackery in one post to the mailing list by Oleg.
22:12:00 <monochrom> Yes!  r can be String instead of IO().  In this case, printf doubles as both printf and sprintf.  How about that!
22:12:04 <lispy> robreim: i thought language design was boring until learning about haskell :)
22:12:10 <dons> monochrom: right!
22:12:15 <hyrax42> monochrom: magic
22:12:16 <Pseudonym> So one published paper by Oleg is actually 2-3 Olegs.
22:12:22 <dons> al you do is change the return type, and it'll dispatch to printf or sprintf
22:12:30 <hyrax42> what is the highest oleg measure of a single document to date
22:12:36 <dons> and so it shoudl be (possibly the only language with polymorphic printf/sprintf ?)
22:12:44 <monochrom> Of course the requirement is your call site has enough context to let the computer know what you know.
22:12:56 <Pseudonym> hyrax: Does the "evolution of a Haskell programmer" page count?
22:13:04 <monochrom> Yeah I don't even see OCaml doing this.
22:13:07 <hyrax42> oh my
22:13:08 <dons> anyone know of a polymorphic printf/sprintf anywhere else?
22:13:12 <emu> ugh, .+.
22:13:17 <emu> or was it .+
22:13:17 * sjanssen waits for Oleg level tests to crop up on the internet
22:13:21 <emu> %#%^&# ocaml
22:13:23 <lispy> dons: do dynamic languages count?
22:13:28 <LoganCapaldo> emu: I think its +.
22:13:35 <Pseudonym> I think that the HList paper has caused more Olegs than anything ele.
22:13:37 <monochrom> You can argue that "<<" of C++ does that too...
22:13:37 <Pseudonym> else
22:13:39 <dons> lispy: well, can you call the same function and get printf or sprintf?
22:13:40 <hyrax42> dynamic languages can't print to string and console wiht same function
22:13:50 <Pseudonym> But there was only a couple of Olegs in the paper itself.
22:14:05 <dons> > printf "no?" :: IO ()
22:14:06 <lambdabot>  <IO ()>
22:14:07 <lispy> dons: oh well, now we're talking about polymorphic in terms of side-effecting
22:14:12 <dons> > printf "maybe!" :: String
22:14:13 <lambdabot>  "maybe!"
22:14:15 <lispy> and that is pretty special
22:14:32 <dons> yeah
22:14:34 <lispy> we need a new term i think
22:14:42 <LoganCapaldo> "<<" in C++ would be the closest
22:14:53 <LoganCapaldo> afaik
22:15:01 <dons> its a nice feature. maybe read/show   readIO/print should be overloaded on String and IO
22:15:11 <sjanssen> the OOHaskell could very well be the most Oleg abundant document
22:15:13 <LoganCapaldo> since the left hand side could be an iostream or a stringstream
22:15:44 <lispy> dons: maybe all of the IO "primitives" could be rewritten this way
22:15:53 <lispy> sjanssen: but it's broken!
22:16:04 <Pseudonym> Gotta go.
22:16:06 <Pseudonym> Nytol!
22:16:09 * monochrom shivers more.  actually tremble.
22:16:19 <sjanssen> lispy: how so?
22:16:52 <lispy> sjanssen: well, i tried to turn HList in to a separate library and then make OOHaskell depend on it, but if you build it that way you get type errors on programs that work otherwise
22:17:18 <lispy> sjanssen: iirc, the same thing happens if you build OOHaskell and HList as one and then try to use OOHaskell as a library
22:17:30 <sjanssen> lispy: oh, strange.  Sounds like GHC's fault, though
22:17:36 <dons> magma: did you work out your IO issue?
22:17:48 <lispy> sjanssen: so in the end, the only way i could get the examples from the paper to work was by compiling my code in the same batch as OOHaskell
22:17:49 <magma> not quite =/
22:17:58 <lispy> sjanssen: yeah, and i email the cafe about it, but no one had any ideas
22:18:09 <dons> magma: where are you now?
22:18:13 <dons> want to paste the code?
22:18:14 <dons> ?paste
22:18:15 <lambdabot> http://paste.lisp.org/new/haskell
22:18:30 <lispy> sjanssen: and it's positively beyond me level of understanding
22:18:37 <magma> dons: I've read the data from the file, put it into a data structure, and now I'm trying to hand this data off to another function
22:18:57 <dons> ok. good
22:19:14 <dons> if you want to paste, there's a few here who'd be happy to guide you.
22:19:20 <monochrom> In addition to unifying show and print, I propose the following Pascalian extension: "show x y z" equivales "show x >> show y >> show z".
22:19:44 <dons> well, a read/show instance for IO kind of makes sense, I think
22:19:54 <dons> since the printf feature for this is just so damn usefu
22:20:05 <sjanssen> lispy: a fix would require someone familiar with the type hacks in OOHaskell and the internals of GHC, I imagine
22:20:36 <sjanssen> > intersect ["Oleg", "Ralf"] ["Simon", "Simon"]
22:20:37 <lambdabot>  []
22:20:40 <magma> dons: my project isn't exactly "simple"
22:20:46 <lispy> sjanssen: haah
22:21:18 <lispy> magma: give us as much as you think we need and we'll grumble if we need more :)
22:21:35 <dons> sjanssen: heh
22:21:45 * monochrom goes write a paper "A correspondence between Algol 60 and Haskell".
22:22:36 <calvins> Is there an easy way of testing a function that uses Prelude.interact? Perhaps some way of faking what it gets from standard input and capturing standard output?
22:23:00 <lispy> calvins: well, it takes a pure function right?
22:23:02 <lispy> ?type interact
22:23:04 <magma> dons: if I'm trying to read a file, manipulate its contents and write the new data back to a seperate file, the reading and writing basically need to happen in the same function, right?
22:23:04 <lambdabot> (String -> String) -> IO ()
22:23:09 <dons> calvins: sure. since you just test the argument function
22:23:10 <emu> it's String -> String, so ghci?
22:23:20 <dons> > interact reverse
22:23:21 <lambdabot>  <IO ()>
22:23:34 <calvins> yeah, i was just going to say that perhaps you ignore the io stuff and just test the function. thanks..
22:23:38 <monochrom> Let f :: String -> Int.  (Or anything you like in place of Int.)  How to read a file, pass the content to f, get the int result, and print it?  do { s <- readFile "file"; print (f s) }.  This is for magma.
22:23:45 <dons> ?check \s -> reverse s == (reverse . reverse . reverse) (s :: String)
22:23:46 <lambdabot>  OK, passed 500 tests.
22:23:52 <lispy> calvins: test it with quickcheck!
22:24:04 <dons> calvins: exactly. ditch IO. use QuickCheck to test the pure part, and away you go
22:24:28 <monochrom> In general, you cannot take a value out of IO, but you can push the function into IO.
22:24:31 <calvins> yeah, i was going to learn quickcheck by writing tests for the UnixTools article
22:24:38 <emu> dons: btw did ya think of a category for that kinda thing? or does it need a new one?
22:24:39 <magma> monochrom: yeah, that's what I thought
22:24:41 <lispy> dons: do we have an interact for handles? like hInteract?
22:24:45 <lispy> ?hoogle hInteract
22:24:46 <lambdabot> No matches found
22:24:46 <dons> magma, they don't have to happen in the same function though.
22:25:06 <calvins> dons: lispy: thanks
22:25:13 <magma> yeah, thanks everyone
22:25:20 <magma> I'll let you know when I've got it working =)
22:25:22 <lispy> #haskell++
22:25:58 <dons> ?paste
22:25:59 <lambdabot> http://paste.lisp.org/new/haskell
22:26:16 * lispy laughs to himself as he realizes he has become useful to the channel but when he came here he didn't even know what i monad was :)
22:27:05 <monochrom> No one knows what a monad is.
22:27:23 <mgsloan> because it can be anything ;)
22:27:24 <lisppaste2> dons pasted "magma" at http://paste.lisp.org/display/30984
22:27:27 <dons> magma: ^^
22:27:42 <monochrom> You can paste people?!
22:27:55 * monochrom tries to escape being pasted!
22:27:56 <dons> only "reified" people
22:28:05 <Lemmih> dons: Have you tried pqc with qc2?
22:28:10 <sjanssen> @type \h f -> System.IO.hGetContents h >>= System.IO.hPutStr h . f
22:28:12 <lambdabot> GHC.IOBase.Handle -> (String -> String) -> IO ()
22:28:15 <emu> a monad has no more meaning than a thing like first-order logic, by itself
22:28:17 <dons> Lemmih: nope. But Bringert wants to integrate it
22:28:32 <magma> thanks dons
22:29:03 <Lemmih> dons: As in adding parallel capabilities to the QC library?
22:29:09 <calvins> hmmm, problem with testing the function when it's io-dependent though is that when you have a bunch of short and sweet one-liners (as in http://haskell.org/haskellwiki/Simple_unix_tools), you end up having to convert every one of those one-liners into 2 functions; so tr = interact $ filter (/= 'e') becomes tr = interact tr'; tr' = filter (/= 'e') ;-(
22:29:11 <lambdabot> Title: Simple unix tools) - HaskellWiki, http://tinyurl.com/yynsf4
22:29:20 * edwardk reflects on the reification of people
22:29:25 <monochrom> Gosh dons had fun translating a Haskell program into Arabic!
22:29:42 <dons> Lemmih: yeah, Bringert's got some plans for fine grained parallel strategies
22:29:51 <LoganCapaldo> I thought people were already reified
22:29:52 <dons> combined with higher level stuff like pqc does
22:30:02 <dons> LoganCapaldo: maybe reflected then :)
22:30:09 <LoganCapaldo> I'd be more worried about the serialization of people :)
22:30:21 <dons> calvins: redefined interact as id
22:30:36 <emu> i'm thinking there needs to be a Scientific. hierarchy in the proposal or something
22:30:43 <dons> i.e. first line of the file:interact = id, then test away :)
22:30:44 <monochrom> If you serialize and reify a person, can you beam him up?
22:30:57 <calvins> dons: oh, that's smart
22:31:15 <monochrom> instance (Serializable p, Reifiable p) => Beamable p where ...
22:31:29 <edwardk> anyone here used dr. hylo much? how good is it at generating hylomorphisms from arbitrary code?
22:31:36 <emu> instance Monad m => Person m?
22:31:48 <dons> edwardk: not great I think...
22:31:49 <mgsloan> emu - like units and stuff? because that could indeed be fun
22:31:54 <edwardk> dons: =(
22:31:56 <dons> ?hylo f x = x
22:31:57 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
22:31:57 <lambdabot>  where g (x) = x
22:31:57 <lambdabot>     h x = (x)
22:31:58 <edwardk> dons: was afraid of that
22:32:06 <dons> works a bit, but its easy to break it
22:32:11 <monochrom> scotty :: (Beamable p) => p -> IO()
22:32:11 <dons> apparently there's a new version in the works though
22:32:20 <edwardk> dons: who is working on it?
22:32:26 <dons> same guys at minho
22:32:29 <dons> so you could ping them
22:32:32 * lispy watches as monochrom  creates a science around sci-fi
22:32:36 <edwardk> k
22:32:45 <edwardk> been playing with general hylo fusion stuff
22:32:47 <emu> mgsloan: well i just was trying to categorize a library
22:32:56 <edwardk> and of course for that, you need hylomorphisms =)
22:33:32 <mgsloan> emu - ah. well, sounds good to me!
22:33:55 <mgsloan> haskell could be great for science stuff
22:34:04 <edwardk> monochrom: you also need unsafeScotty, to beam unbeamable things anyways =P
22:34:48 <monochrom> That is better attributed to either Kirk or McCoy.
22:34:53 <edwardk> yeah
22:35:09 <monochrom> unsafeKirk :: a -> b
22:35:26 <monochrom> unsafeMcCoy :: (Medical a, Medical b) => a->b
22:35:45 <LoganCapaldo> Nah, unbeamable things just need to be wrapped in the Moriarty monad
22:36:06 <monochrom> Ha!
22:36:21 <lispy> unsafeMcCoy (Human a) = operateOn a; unsafeMcCoy (NonHuman b) = throwError "Damnit, I'm a doctor not a ..."
22:36:34 <monochrom> hahaha
22:37:03 <LoganCapaldo> `handler` sendToBabylon5 b
22:38:04 <greentea> LoganCapaldo: Only if b doesn't have type 'Shadow', surely?
22:38:21 <beschmi> Lemmih: there is no _darcs/prefs/author for cabal-test, so I used the gmail address in the mininova repo for sending a patch
22:39:58 <Lemmih> beschmi: Thanks.
22:52:12 * Lemmih wonders how to set prefs/author.
22:53:09 <dons> just edit the file
22:53:25 <dons> e.g. :$ cat code/fps/_darcs/prefs/author
22:53:25 <dons> Don Stewart <dons@cse.unsw.edu.au>
22:55:44 <lispy> darcs setpref author foo@bar.com
22:56:00 <lispy> oh nevermind
22:56:08 <lispy> Valid preferences are: test predist boringfile binariesfile.
22:56:51 * lispy grumbles
22:57:04 <lispy> why is it so hard to ask how much memory a subprocess is using?
22:57:38 <edwardk> lispy: well, coz if it forked, is it really using all that memory. half the time thats just cow'ed, etc.
23:01:00 <lispy> cow'ed?
23:01:10 <edwardk> copy-on-write'd
23:01:30 <lispy> i happen to be writing the program in scala and calling darcs, if that helps :)
23:01:45 <lispy> i'm tempted to try some rts options, but that's going to get ugly quick
23:02:42 <lispy> i could do +RTS -sstderr maybe
23:03:18 <lispy> oh, -tstderr is probably what i want
23:03:18 <Excedrin> what OS? does it have to be portable?
23:03:57 <lispy> Excedrin: well, that would be nice, but darcs is probably the only process i'll ever collect the stats on
23:04:07 <lispy> Excedrin: so if it works with ghc built binaries that's okay
23:04:18 <lispy> and i think +RTS -tstderr is exactly what i need
23:04:20 <edwardk> getrusage only gives information on terminated children not executing ones, right?
23:04:39 <lispy> not sure if i can use getrusage from scala
23:04:56 <Excedrin> if it was Linux, it's easy to look at /proc/(pid)/maps
23:05:21 <edwardk> yeah, there doesn't appear to be a portable way to do what you want, so go for os specific hackery ;)
23:06:16 <lispy> hmm...
23:06:23 <lispy> i'll use the rts stuff for now
23:06:28 <lispy> since i have it working :)
23:06:34 <Excedrin> that's probably best
23:08:16 <Excedrin> otherwise, you could try parsing the output of top -b -n 1 -p (pid) ...
23:08:38 <lispy> ?where mathpaste
23:08:38 <lambdabot> http://www.mathbin.net/
23:08:41 <Excedrin> does helisp's compile stuff work?
23:09:02 <lispy> Excedrin: what platfrom are you on?
23:09:09 <Excedrin> x86_32 Linux
23:09:21 <lispy> Excedrin: then the answer is kinda
23:09:35 <lispy> Excedrin: you'll need to undo some of the stuff done in the most recent patch
23:09:48 <lispy> Excedrin: to make it target x86_32
23:10:18 <Excedrin> * after much refactoring helisp is now overly complex
23:10:25 <lispy> :)
23:10:56 <darkdescendant> Hi all. Newbie to Haskell having an issue I could use some help with.
23:11:11 <darkdescendant> I have this function definition:
23:11:21 <darkdescendant> ft :: a -> a -> a -> a -> a
23:11:21 <darkdescendant> ft p0 v0 a t = p0 + v0 * t - 0.5 * a * t^2
23:11:41 <darkdescendant> (simple force function)
23:11:55 <darkdescendant> And I am trying to define the following:
23:11:58 <darkdescendant> p :: (a -> a) -> [a] -> [a]
23:11:59 <darkdescendant> p f [] = []
23:11:59 <darkdescendant> p f (x:xs) = f x : p f xs
23:12:11 <Excedrin> > 2 ** 8
23:12:12 <lambdabot>  256.0
23:12:25 <dons> darkdescendant: that's map?
23:12:35 <dons> ?let ft p0 v0 a t = p0 + v0 * t - 0.5 * a * t^2
23:12:36 <darkdescendant> ahhh... duh
23:12:37 <lambdabot> Defined.
23:12:58 <dons> > map toUpper "haskell"
23:12:59 <lambdabot>  "HASKELL"
23:13:08 <dons> ?hoogle (a -> a) -> [a] -> [a]
23:13:09 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
23:13:10 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
23:13:10 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
23:13:36 <dons> ?users
23:13:37 <lambdabot> Maximum users seen in #haskell: 276, currently: 247 (89.5%), active: 36 (14.6%)
23:16:12 <darkdescendant> Sigh.. that was it. Exactly what I wanted. Thanx.
23:16:19 <darkdescendant> ft p0 v0 a t = p0 + v0 * t - 0.5 * a * t^2
23:16:19 <darkdescendant> f n = (map (ft 1000 0 9.8) [0..] ) !! n
23:19:13 <mgsloan> dons - lamdabot logs are probably pretty huge, eh?
23:20:26 <Eidolos> shrug, my IRC client logs everything, can't be more than a few megs.
23:21:06 <mgsloan> yeah.  My fakey-AI thingamajig will multiply that a few time for its brain storage ;p
23:21:28 <mgsloan> lets just hope the comppiler optimizes it not to copy the data structures..
23:22:20 <Korollary> Hah. I put the haskell report on my pda.
23:23:16 <mgsloan> there's probably good ways to optimize that mem use though
23:24:16 <newsham> hi
23:27:53 <dons> mguh hu. like 400M over 5 years
23:28:05 <dons> mgsloan gone
23:28:24 <newsham> i thought you were speaking some chinese dialect
23:33:08 <kzm> Is GHC still 'difficult' about compiled-in data structures?
23:33:30 <dons> I think so yes. better to stick them in an Addr# or packed bytestring
23:33:46 <kzm> (I tried at one point to compile in matrices, but using read was much more efficient)
23:34:04 <kzm> (matrix constants, that is)
23:34:25 <dons> should be very past to store the data in a string literal that you ByteString.pack (giving you an Addr#) athat you then build from
23:34:31 <dons> s/fast/
23:35:45 <kzm> OK.  My current need is substitution matrices (for sequence alignment), and they tend to be small anyway (20x20?)
23:36:29 <dons> ok. that should be fine
23:36:38 <dons> i'd be worried more after then 1M mark...
23:37:18 <kzm> I finally got around to implement sequence alignment - it's fairly straightforward, but the code is very imperativish and ugly.
23:37:45 * kzm sighs.
23:45:24 <repiret> I'm having some trouble building HXT.  Could someone take a look at the output (http://www2.laiosa.org:81/~mike/hxt.txt) and let me know if they have any thoughts on how to make it build?
23:47:50 <monochrom> ghc 6.6?
23:48:20 <JohnMeacham> anyone have a transitive reduction algorithm for Data.Graph.Graph?
23:49:00 <repiret> 6.4.1
23:49:23 <monochrom> OK, HXT version 7.0 assumes ghc 6.6, and indeed the error you see is one of the differences.
23:50:41 <repiret> well that would explain it.  although the website should be updated.  For requirements it reads: "GHC >= 6.4.1 or GHC-6.6"
23:50:47 <monochrom> I am too lazy to determine how to work around that.  It is an easy fix if you want to stay with ghc 6.4, but I'm too lazy.
23:52:44 <monochrom> Hmm odd, the web page explicitly promises it works with 6.4.2.  The author must have actually tried.  But the error message you get is pointing at a difference between 6.4.2 and 6.6 I am sure.
23:53:15 <monochrom> OK I'm too lazy to investigate. :)
23:58:22 <repiret> well, there's no good reason for me to not use 6.6, so i'll just do that for now.
23:59:13 <repiret> assuming it works anyway, and at the rate the download is going i wont know until morning.  thanks for the help monochrom
