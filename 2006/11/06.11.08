00:12:15 <vegai> http://www.linuxdevices.com/news/NS2986976174.html
00:12:18 <lambdabot> Title: Cheap, hackable Linux smartphone due soon, http://tinyurl.com/sse73
00:16:11 <lispy> vegai: does it run haskell yet?
00:21:55 <kzm> I guess porting Hugs isn't too hard?
00:24:45 <mwc> embedded haskell would be awesmoe
00:25:47 <lispy> kzm: yhc is my bet
00:26:03 <mwc> I haven't read much about yhc
00:26:05 <mwc> what's their niche/
00:26:21 <lispy> kzm: iirc, yhc borrowed code from nhc (or something like that) which used to do embedded stuff
00:26:53 <lispy> and ndm says (and he'd know) that yhc is really easy to retarget
00:27:23 <Cale> a machine implementation of a yhc bytecode interpreter would be awesome :)
00:27:47 <kzm> Okay.  I haven't looked at yhc yet.
00:28:13 <kzm> (Tried to run nhc on SGI way back when, but couldn't get it to work properly)
00:29:11 <mwc> Talking strictly out of my ass, modern CPUs use microcode anyways. One could make a CPU that allowed a usermode program to switch the microcode to something else, in effect running a bytecode on the native processor
00:31:02 <lispy> mwc: one word, transmeta
00:31:52 <Baughn> mwc: Yet of course they're heavily optimized for this particular bytecode, popular decoding paths are hardcoded, and so on
00:32:24 <mwc> I thought microcode was highly dynamic... that way they could work around a lot of CPU bugs
00:32:40 <lispy> mwc: microcode isn't as popular as it once was
00:33:06 <lispy> mwc: but basically, Baughn is right and you're right
00:33:35 <Baughn> mwc: CPU bugs aren't as possible as they used to be, with modern design programs. However, just because there are fast paths for many instructions, doesn't mean it can't be overriden
00:33:50 <lispy> mwc: transmeta had processors which could change their instruction set while running programs...i don't know if they ever marketed it, but i remember reading articles about it back in '98 or so
00:33:56 <mwc> That's cool
00:33:59 <Baughn> mwc: Although in practice the overhead of doing so would mean Intel (or AMD, or whoever) would most likely issue a recall instead
00:34:19 <mwc> I read about their stuff in the Crusoe/Efficeon days... didn't mention anything about switching the code morphing software
00:35:34 <Baughn> mwc: It was an obvious possibility, but for some reason they didn't want customers to get their hands on the required documentation. :'(
00:36:15 <protoloco> Hi
00:40:38 <Cale> hello
00:40:51 <lispy> hmm...
00:41:06 <lalala> or here?
00:51:27 <NewbieHaskell> :)
00:51:38 <Cale> hi :)
00:54:35 <NewbieHaskell> Cale
00:54:40 <NewbieHaskell> could u help me?
00:54:47 <Cale> what with?
00:55:13 <NewbieHaskell> check msg :)
00:55:20 <Cale> I don't see any from you
00:55:29 <Cale>  /msg nickserv help register
00:55:42 <Baughn> /msg-ing is a bad habit anyway
00:55:43 <Cale> You need to register to send private messages.
00:55:59 <NewbieHaskell> ohh
00:56:03 <Cale> Yeah, and it would be better if you posted your questions in channel, so everyone has a chance to help.
00:56:05 <Baughn> There are more people than Cale here, so ask everyone
00:57:17 <NewbieHaskell> ups!
00:57:21 <NewbieHaskell> sorry
00:59:44 <Cale> NewbieHaskell's problem is to construct a function which takes two lists and produces a list of 2 element lists which is the Cartesian product
01:00:12 <mauke> list comprehension
01:00:21 <Cale> I agree :)
01:00:31 <Cale> NewbieHaskell: do you know the list comprehension syntax?
01:01:04 <kzm> Unless it's an exercise to show the grasp of recursion, and list comprehensions are covered in the next lesson?
01:01:25 <velco> or list monad :P
01:01:45 <Cale> yeah, sequence is pretty much ideal for this :)
01:04:48 <dons> ?yow
01:04:49 <lambdabot> I want to dress you up as TALLULAH BANKHEAD and cover you with VASELINE
01:04:49 <lambdabot> and WHEAT THINS ...
01:06:22 <caotic> map ++ ['a' .. 'd']  ['e' .. 'g']
01:06:27 <NewbieHaskell> ohh..
01:06:39 <NewbieHaskell> Cale yeah..
01:07:39 <dons> > (++) ['a' .. 'd']  ['e' .. 'g']
01:07:41 <lambdabot>  "abcdefg"
01:07:53 <dons> > ['a' .. 'd'] ++ ['e' .. 'g']
01:07:54 <lambdabot>  "abcdefg"
01:08:08 <dons> > map toUpper ( ['a' .. 'd'] ++ ['e' .. 'g'] )
01:08:10 <lambdabot>  "ABCDEFG"
01:09:53 <therp> I remember that I heard a quote about haskell that goes like "Haskell is like executable mathematics". Does anyone know where this originates from?
01:10:15 <kfish> hah
01:10:23 <dons> this could be a principle for haskell: "Every 5 minutes you spend writing code in a new language is more useful than 5 hours reading blog posts about how great the language is.'
01:10:24 <kfish> haskell is mathematics with the syntax cleaned up
01:10:37 <dons> therp: yeh, that sounds like a Cale-ism
01:10:48 <dons> let me grep the logs...
01:11:14 <Cale> kfish: I'm not sure about "cleaned up", but "made machine readable" perhaps.
01:11:23 <dons> 03.03.14:07:09:19 <Arnia> Well, executable mathematics :)
01:11:31 <dons> 05.06.06:02:55:19 * autrijus thinks haskell is just executable math
01:11:39 <Cale> It's also not really about the same thing as mathematics.
01:11:39 <dons> 05.02.03:10:16:51 <shapr> Software reduces down to executable math at the core. Hardware doesn't
01:11:54 <caotic> map 'a': ['e' .. 'g']
01:12:01 <dons> > 'a': ['e' .. 'g']
01:12:03 <lambdabot>  "aefg"
01:12:04 <Cale> Haskell is about defining computations, mathematics is about determining what is true in a given system.
01:12:08 <psykotic> i think transition systems are pretty mathematical :)
01:12:15 <therp> dons thanks :)
01:12:41 <therp> cale: I know that it's not the same. but it looks similiar. that's what I need this quote for. syntax similarities
01:14:27 <caotic> map ++ (head [1,2]) (head [4,5])
01:15:06 <Cale> > zipWith ($) (map (++) [[1,2,3], [4,5,6]]) [[7,8],[9]]
01:15:08 <lambdabot>  [[1,2,3,7,8],[4,5,6,9]]
01:16:06 <Cale> "A few years ago, I had the pleasure of teaching my oldest daughter to ski." -- heh, I just managed to totally misread that, due to thinking of 'ski' as a person.
01:16:07 <caotic> im tryng ot get somthing like [[1,4], [1,5],[2,4],[2,5]]
01:16:39 <psykotic> cale: obviously he must be talking about ski-calculus!
01:16:44 <Cale> > [[x,y] | x <- [1,2], y <- [4,5]]
01:16:46 <lambdabot>  [[1,4],[1,5],[2,4],[2,5]]
01:16:57 <Cale> > sequence [[1,2], [4,5]]
01:16:59 <lambdabot>  [[1,4],[1,5],[2,4],[2,5]]
01:18:14 <caotic> i have to build the new list from 2 separate lists
01:18:37 <caotic> sequense i think just works with one list
01:19:04 <caotic> err: sequence
01:19:07 <matthew-_> > zipWith (\x,y -> [x,y]) [1,2,3] [4,5,6]
01:19:07 <lambdabot>  Parse error
01:19:08 <caotic> sorry kinda tired
01:19:12 <matthew-_> > zipWith (\x y -> [x,y]) [1,2,3] [4,5,6]
01:19:14 <lambdabot>  [[1,4],[2,5],[3,6]]
01:19:46 <Cale> caotic: right, so build that list first :)
01:20:10 <Cale> > (sequence . (\x y -> [x,y])) [1,2,3] [4,5,6]
01:20:11 <lambdabot>    The lambda expression `\ x y -> ...' has two argumentss,
01:20:11 <lambdabot>   but its typ...
01:20:19 <Cale> er, right
01:20:33 <Cale> > ((sequence .) . (\x y -> [x,y])) [1,2,3] [4,5,6]
01:20:35 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:20:43 <Cale> > sequence $ (\x y -> [x,y]) [1,2,3] [4,5,6]
01:20:45 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:21:19 <Cale> > let cartesian x y = sequence [x,y] in cartesian [1,2,3] [4,5,6]
01:21:21 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:21:28 <caotic> . concatenates a list ?
01:21:33 <Cale> . is function composition
01:21:47 <caotic> err: appends to a list ?
01:21:48 <Syzygy-> > [1,2,3] >>= [4,5,6]
01:21:49 <lambdabot>  Couldn't match `a -> [b]' against `[a1]'
01:21:56 <Syzygy-> > [1,2,3] <<= [4,5,6]
01:21:57 <lambdabot>  Not in scope: `<<='
01:22:11 <Syzygy-> Wasn't there a way to use the lists monad to do just that?
01:22:11 <Cale> > ((*2) . (+1)) 5
01:22:13 <lambdabot>  12
01:22:23 <Cale> (f . g) x = f (g x)
01:22:31 <Cale> Syzygy-: sure
01:22:49 <Cale> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> return [x,y]
01:22:51 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:22:58 <Syzygy-> Ah. That's how.
01:23:12 <Cale> > do {x <- [1,2,3]; y <- [4,5,6]; return [x,y]}
01:23:14 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:23:15 <Syzygy-> > do a <- [1,2,3]; b <- [4,5,6]; return [a,b]
01:23:17 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:23:23 <Cale> right
01:23:37 <Cale> which is why sequence works
01:23:41 <Syzygy-> Right.
01:24:27 <caotic> can you do that using the map function ?
01:24:56 <Cale> map will never give you a list longer than the input list, however...
01:25:56 <Cale> [1,2,3] >>= \x -> [4,5,6] >>= \y -> return [x,y] = concat (map (\x -> [4,5,6] >>= \y -> return [x,y]) [1,2,3])
01:26:27 <Cale> = concat (map (\x -> concat (map (\y -> return [x,y]) [4,5,6]) [1,2,3])
01:26:49 <Cale> = concat (map (\x -> concat (map (\y -> [[x,y]]) [4,5,6]) [1,2,3])
01:26:55 <Cale> > concat (map (\x -> concat (map (\y -> [[x,y]]) [4,5,6]) [1,2,3])
01:26:56 <lambdabot>  Parse error
01:27:00 <Cale> errr
01:27:03 <matthew-_> lol
01:27:06 <Cale> > concat (map (\x -> concat (map (\y -> [[x,y]]) [4,5,6]) [1,2,3]))
01:27:08 <lambdabot>    Expecting a function type, but found `[[a]]'
01:27:08 <lambdabot>    Expected type: [[a]]
01:27:08 <lambdabot> ...
01:27:10 <Cale> bah
01:27:23 <Cale> oh
01:27:26 <Syzygy-> roconnor: How's your bet coming along?
01:27:31 <Cale> > concat (map (\x -> concat (map (\y -> [[x,y]]) [4,5,6])) [1,2,3])
01:27:33 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:27:38 <lispy> ?check \a b -> (a::Int) >>= \x -> (b::Int) >>= \y -> return [x,y] == concat (map (\x -> b >>= \y -> return [x,y]) a)
01:27:39 <lambdabot>  Couldn't match `m a' against `Int'
01:27:41 <Cale> missed a )
01:28:00 <lispy> ?check \a b -> (a::Int) >>= \x -> (b::Int) >>= \y -> return [x,y] == concat (map (\x -> b >>= \y -> return [[x,y]]) a)
01:28:01 <lambdabot>  Couldn't match `m a' against `Int'
01:28:41 <lispy> ?check \a b -> (a::Int) >>= \x -> (b::Int) >>= \y -> return [x,y] == concat (map (\x -> concat (map (\y -> return [[x,y]]) a)))
01:28:42 <lambdabot>  Couldn't match `m a' against `Int'
01:28:45 <lispy> bleh
01:28:48 <lispy> i give up
01:28:56 <caotic> lol
01:29:02 <caotic> 10x's anyway
01:29:08 <caotic> i'll try to fix it
01:29:26 <Cale> (I fixed it)
01:29:36 <Cale> concat (map (\x -> concat (map (\y -> [[x,y]]) [4,5,6])) [1,2,3])
01:29:42 <Cale> I just left out a paren
01:30:00 <Cale> you can't write it simply as map f (something)
01:30:15 <Cale> well...
01:30:25 <lispy> ?check \a b -> (a::Int) >>= \x -> (b::Int) >>= \y -> return [x,y] == concat (map (\x -> concat (map (\y -> [[x,y]]) b))a)
01:30:27 <lambdabot>  Couldn't match `m a' against `Int'
01:30:37 <Cale> > map (\(x,y) -> [x,y]) (liftM2 (,) [1,2,3] [4,5,6])
01:30:39 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:30:42 <Cale> hehe
01:30:42 <matthew-_> > map (:) [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:30:44 <lambdabot>  Add a type signature
01:30:49 <matthew-_> doh!
01:30:50 <matthew-_> ;)
01:31:10 <Cale> hehe, map id
01:31:17 <matthew-_> oh yeah
01:31:32 * matthew-_ fetches coffee...
01:36:11 <caotic> what does liftM2 does
01:36:11 <caotic> ?
01:36:45 <lispy> it's like liftM but the function it lifts takes 2 argumentns
01:37:09 <lispy> liftM takes a function on pure values and makes it into a function that works on a monadic value
01:37:32 <lispy> > liftM2 (+) (return 1) (return 2) :: [Int]
01:37:34 <lambdabot>  [3]
01:37:34 <caotic> liftM2 is not part of the standard haskell modules ?
01:37:42 <lispy> ?hoogle liftM2
01:37:43 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
01:37:43 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:37:52 <lispy> you'll find it in Control.Monad
01:39:07 <lispy> > liftM2 (+) (return 1) (return 2) :: Maybe Int
01:39:08 <lambdabot>  Just 3
01:39:16 <lispy> > liftM2 (+) (return 1) (return 2) :: Either Int String
01:39:18 <lambdabot>  add an instance declaration for (Num String)
01:39:26 <lispy> > liftM2 (+) (return 1) (return 2) :: Either String Int
01:39:28 <lambdabot>  Right 3
01:42:59 <Cale> > liftM2 (+) (return 1) (return 2) :: [Int]
01:43:01 <lambdabot>  [3]
01:43:18 <Cale> > liftM2 (+) [1,2] [3] :: [Int]
01:43:20 <lambdabot>  [4,5]
01:51:24 <caotic> ting to make this into a function "concat (map (\x -> concat (map (\y -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=x,y) [4,5,6])) [1,2,3])"
01:51:27 <lambdabot> http://tinyurl.com/ssyym
01:52:01 <caotic> huh ?
01:52:08 <caotic> and by ting i ment tring
01:52:24 <caotic> :P
01:52:31 <caotic> men is late
01:59:30 <gds> > concat (map (\x -> concat (map (\y -> "words"++x++","++y) ["4","5"])) ["6","7"])
01:59:32 <lambdabot>  "words6,4words6,5words7,4words7,5"
02:00:35 <gds> > unlines (map (\x -> concat (map (\y -> "words"++x++","++y) ["4","5"])) ["6","7"])
02:00:37 <lambdabot>  "words6,4words6,5\nwords7,4words7,5\n"
02:00:52 <gds> > unlines (map (\x -> unlines (map (\y -> "words"++x++","++y) ["4","5"])) ["6","7"])
02:00:54 <lambdabot>  "words6,4\nwords6,5\n\nwords7,4\nwords7,5\n\n"
02:01:52 <gds> > concat (map (\x -> unlines (map (\y -> "words"++x++","++y) ["4","5"])) ["6","7"])
02:01:53 <lambdabot>  "words6,4\nwords6,5\nwords7,4\nwords7,5\n"
02:05:45 <gds> caotic: That the sort of thing you're after?
02:07:19 <caotic> yeah kinda, i actually i got it to work, but im trying to understand the code
02:07:26 <caotic> i mean i have to learn something :P
02:07:56 <caotic> the (map \x -> ..(map\y-> confuses me
02:09:04 <caotic> this puts the y into the pair of numbers right (map (\y -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=x,y y ))
02:09:06 <lambdabot> http://tinyurl.com/ssyym
02:09:15 <Cale> er..
02:09:34 <caotic> aw crp, how do you get to put textual code without evaluation :P
02:09:39 <Cale> hm?
02:09:45 <Cale> Which IRC client are you using?
02:09:59 <caotic> konversation
02:10:04 <Cale> hmm
02:11:02 <caotic> this puts the y into the pair of numbers right (map (\y -> [<trash>[x,y]<trash>] y ))
02:11:44 <Cale> > let x = 5 in map (\y -> [[x,y]]) [1,2,3]
02:11:46 <lambdabot>  [[[5,1]],[[5,2]],[[5,3]]]
02:12:49 <Cale> > let x = 5 in concat (map (\y -> [[x,y]]) [1,2,3])
02:12:50 <lambdabot>  [[5,1],[5,2],[5,3]]
02:13:00 <Cale> > let x = 5 in concatMap (\y -> [[x,y]] [1,2,3]
02:13:02 <lambdabot>  Parse error
02:13:04 <Cale> > let x = 5 in concatMap (\y -> [[x,y]]) [1,2,3]
02:13:05 <lambdabot>  [[5,1],[5,2],[5,3]]
02:13:25 <Cale> > concatMap (\x -> concatMap (\y -> [[x,y]]) [1,2,3]) [4,5,6]
02:13:27 <lambdabot>  [[4,1],[4,2],[4,3],[5,1],[5,2],[5,3],[6,1],[6,2],[6,3]]
02:14:05 <Cale> > map (\x -> concatMap (\y -> [[x,y]]) [1,2,3]) [4,5,6]
02:14:07 <lambdabot>  [[[4,1],[4,2],[4,3]],[[5,1],[5,2],[5,3]],[[6,1],[6,2],[6,3]]]
02:14:30 <Cale> see how that works?
02:14:31 <dons> ?pl (\x -> concatMap (\y -> [[x,y]])
02:14:32 <lambdabot> (line 1, column 33):
02:14:32 <lambdabot> unexpected end of input
02:14:32 <lambdabot> expecting variable, "(", operator or ")"
02:14:39 <caotic> oh i think i understand now , what happended is that i didnt quite get how the "arrays" where being readed character after character
02:14:47 <dons> lists :)
02:14:48 <Cale> lists :)
02:14:55 <dons> jinx  :)
02:15:01 <caotic> XD
02:15:05 <caotic> thanks
02:15:11 <Cale> hehe
02:15:42 <caotic> and thanks the channel in general, the amount of help was just awsome :)
02:16:45 <dons> we live to serve, and write type-correct code :)
02:17:19 * gds wonders if that quote's available on a t shirt....
02:17:30 <gds> :)
02:17:37 <caotic> lol
02:26:17 <therp> question to all: you as Haskell programmer, would you miss a literal syntax for characters? I have the impression that character literals are seldomly used and would something like (char "a") be sufficient to you? (char=head in this case)
02:27:43 <Cale> therp: uh, I think it would be a shame if it wasn't there... why?
02:28:07 <Cale> You'd like to be able to name your variables starting with a quotation mark?
02:28:42 <therp> cale: I'm just wondering, if I should include it in my parse tree. I  want to use the ' char for something else.
02:29:00 <therp> yes, correctly. and I can't think of anything else that looks nice.
02:29:11 <therp> and then I started to wonder if it's actually required
02:29:13 <Cale> What are you implementing?
02:29:24 <therp> the Liskell thing :)
02:29:37 <Cale> Well, in Haskell, I think most of the literal characters will occur in pattern matching
02:29:54 <therp> hm, true. function calls no good.
02:30:08 <Cale> What were you thinking of using ' for?
02:30:15 <therp> ok that pretty much rules out my idea of omitting it
02:30:35 <therp> cale: it's a shortcut to construct a symbol. only useful for meta programming stuff
02:30:55 <Cale> Perhaps '' ?
02:31:00 <therp> I think TH includes something like it, but I'm not sure. my idea is stolen from Lisp
02:31:22 <lispy> therp: in some sense, lazy evaluation plays the same role
02:31:42 <therp> well that's for strings. of course, I could write a good lexer to recognize the difference but.. hmm. others would have to do the same, like editors/code generators
02:31:51 <Cale> hm?
02:32:01 <Cale> I wrote two single quotes
02:32:19 <Cale> Perhaps that would be the problem with that idea :)
02:32:21 <therp> oh. ok, my font doesn't really show the difference clearly. '' "..
02:33:06 * therp doesn't use mono-spaced fonts for ircing anymore since 2 weeks.. 
02:33:50 <therp> hm. ''a doesn't look bad..
02:34:32 <therp> I think I will postpone the decision _again_ and continue writing my paper :)
02:47:21 <musasabi> therp: you can use both.
02:47:58 <therp> musasabi: both?
02:48:16 <musasabi> therp: TH uses 'foo and ''foo and there are still char literals. Just that one cannot do f' -> 'f' because that will be interpreted as a char constant.
02:49:16 <therp> musasabi: true, I know, but I don't like that. it should be as clear as possible
02:51:36 <musasabi> therp: you could be evil and omit chars ;)
02:52:35 <musasabi> Just provide strings - many languages do it this way.
02:54:11 <therp> musasabi: that was my initial purposal, but then cale pointed out, providing characters only implicit -- for instance via (head "x") -- doesn't work as character matching within patterns.
02:59:31 <Adamant> how much was Haskell designed by committee?
03:02:06 <Cale> Quite a lot
03:02:39 <Cale> though it borrows a lot from Miranda, and I'm not sure how Miranda was designed
03:03:21 <Adamant> interesting. the stereotype is that languages designed by committee have problems. doesn't seem to be the case with Haskell
03:04:39 <sieni> what do you mean?
03:05:17 <caotic> nite every one and thanks for all the help
03:05:30 <sieni> are you implying that there is a language that hasn't been designed by a committee and doesn't have even more serious flaws than the ones designed by a committee in general?
03:05:58 <vegai> much of what haskell practically is was written outside committees, though.
03:06:39 <vegai> If you'd just have haskell98, your hands would be tied a bit like if you only had ANSI C.
03:06:55 <musasabi> PHP is an example what happens if there is no commitee.
03:07:10 <sieni> musasabi: had that in mind as well :-)
03:07:15 <Philippa> more like if you only had ANSI C's standard libs
03:07:44 <profmakx> any sane programmer would be tied up in re-inventing the wheel then ^^
03:11:00 <dons> heh, I missed Bulat's suggestion for `on` et al to live under perhaps Monsters.*  :D
03:15:31 <mnislaih> hey, who is going to be at Oxford for 'Fun in the Afternoon' next week ?
03:21:10 <dons> mnislaih: a few i think.
03:21:18 <dons> the oxford guys, anyway :)
03:21:44 <mnislaih> do you know if there is anything planned for the day after ?
03:23:04 <mnislaih> otherwise, going to Oxford for an afternoon is not worth it :S
03:23:20 <mnislaih> I mean, in my case
03:26:51 <therp> hm, is there a way to remove the initial and the final element of a list easily? or more generally, is there a way to cut a subsequence out of a list, ith to nth element?
03:27:45 <SamB_XP> therp: you mean like take (n-i) . drop i
03:27:46 <SamB_XP> ?
03:27:48 <dons> take y . drop x
03:28:02 <dons> yeah, as SamB_XP says :)
03:28:06 <therp> samb: thanks, dons thanks
03:28:07 <cinema> therp, init . last
03:28:24 <SamB_XP> cinema: huh?
03:28:32 <SamB_XP> don't you mean "init . tail"?
03:28:37 <therp> I thought there might be something like [1..10] !! [4,5,6].. but no there isn't..
03:28:46 <cinema> SamB, you're right
03:29:40 <SamB_XP> I figured I might as well give the supposedly more general answer, because it would be more efficient ;-)
03:29:46 <cinema> therp, with map you can do that with !!
03:29:58 <SamB_XP> cinema: but that isn't very efficient either
03:30:35 <SamB_XP> > map ([1..10] !!) [4..6]
03:30:36 <lambdabot>  [5,6,7]
03:30:43 <cinema> SamB_XP, well, for 10 elements...
03:30:49 <SamB_XP> cinema: true
03:31:14 <SamB_XP> I was considering mentioning it but decided against, on the grounds that it was inefficient in general...
03:31:34 <SamB_XP> (because each !! would start at the beginning of the list)
03:32:08 <SamB_XP> all this reminds me of bytestrings
03:32:09 <cinema> SamB_XP, but the indexes might not be sorted
03:32:41 <SamB_XP> cinema: well, I think therp meant for them to be
03:33:23 <therp> samb: true, only an interval
03:34:07 <sieni> >  (\x y z -> take (z - y + 1) $ drop y x) [1..10] 4 6
03:34:09 <lambdabot>  [5,6,7]
03:34:30 <resiak> @pl (\x y z -> take (z - y + 1) $ drop y x)
03:34:31 <lambdabot> ap (flip . (take .) . flip flip 1 . ((+) .) . subtract) . flip drop
03:34:40 <sieni> cute as hell
03:34:52 <SamB_XP> > let f i n = take (n-i) . drop i in f 4 6 [1..10]
03:34:54 <lambdabot>  [5,6]
03:35:16 <SamB_XP> well, doesn't do the "inclusive" thing
03:35:22 <SamB_XP> but I think maybe I like that ;-)
03:36:34 <SamB_XP> anyway, I think it is about the most efficient you can get...
03:38:11 <SamB> @type scanr
03:38:12 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> [b]
03:38:45 <SamB> @type (:)
03:38:47 <lambdabot> forall a. a -> [a] -> [a]
03:38:53 <Sara|Uni> hi
03:39:16 <SamB> > scanr (:) [] [1..10]
03:39:17 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
03:39:23 <SamB> oh rats
03:39:38 * SamB was trying to make "inits", not "tails"
03:39:42 <SamB> Sara|Uni: hello
03:39:46 <Sara|Uni> I'm trying to pick some data randomly, but it doesn't seem to be working correctly (always picking first, I think)
03:39:54 <Sara|Uni> what was the link to paste code?
03:39:57 <SamB> > scanl (flip (:)) [] [1..10]
03:39:59 <SamB> @paste
03:39:59 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[8...
03:39:59 <lambdabot> http://paste.lisp.org/new/haskell
03:40:08 <Sara|Uni> thanks
03:41:22 <lisppaste2> Sara pasted "Picking randomly" at http://paste.lisp.org/display/29489
03:41:31 <vegai> http://programming.reddit.com/info/q19p/comments
03:41:34 <lambdabot> Title: Every 5 minutes you spend writing code in a new language is more useful than 5 h ..., http://tinyurl.com/ylbdjf
03:42:37 <Sara|Uni> I tried always using the same randomgenerator, but then .. I think .. it's not random at all anymore
03:42:48 <SamB> Sara|Uni: indeed
03:42:59 <Sara|Uni> so then I used the ranGen that randomR returns
03:43:21 <SamB> @hoogle IO StdGen
03:43:22 <lambdabot> Random.getStdGen :: IO StdGen
03:43:22 <lambdabot> Random.newStdGen :: IO StdGen
03:43:45 <Sara|Uni> What about the one that randomR returns?
03:43:54 <Sara|Uni> Isn't that ok?
03:43:57 <SamB> @type Random.randomR
03:43:59 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
03:44:03 <Sara|Uni> What's it for then ? :D
03:44:04 <Smokey`> randomRIO seems good to me.
03:44:13 <SamB> well, you need to pass one *in*
03:44:23 <SamB> you are supposed to then use the new one
03:44:38 <Sara|Uni> well... that's what I'm doing, is it not?
03:44:43 <Sara|Uni> sry
03:44:46 <SamB> and not use the one you passed in
03:44:47 <Sara|Uni> I'll paste more code
03:44:54 <SamB> but you still need to pass a good one in!
03:45:22 <lisppaste2> Sara annotated #29489 with "Some more code" at http://paste.lisp.org/display/29489#1
03:45:27 <SamB> to make one seeded with the time or somesuch, just use newStdGen
03:46:06 <Sara|Uni> Well... I'm getting one from the System (just supposed to implement a few functions for a given framework)
03:47:06 <SamB> the System?
03:47:10 <SamB> what be the System?
03:47:20 <Sara|Uni> So I've got a few modules given
03:47:23 <Sara|Uni> and my task is:
03:47:33 <Sara|Uni> Implement a fct. runLSystem :: StdGen -> String -> [Rule] -> Int -> String
03:47:37 <Sara|Uni> such that this and this happens
03:48:11 <Sara|Uni> and StdGen is a generator for randoms, is it not?
03:48:21 <SamB> yeah
03:48:24 <Sara|Uni> So whoever calls runLSystem... gives me the generator
03:48:28 <SamB> @instances RandomGen
03:48:29 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
03:48:34 <SamB> @instances Random.RandomGen
03:48:40 <Sara|Uni> and afterwards I make new ones
03:48:52 <Sara|Uni> because I use the one that randomR returns
03:48:59 <SamB> @hoogle RandomGen
03:49:01 <lambdabot> System.Random.RandomGen :: class RandomGen g
03:49:21 <SamB> okay.
03:49:49 <SamB> well, if it were my program I'd assume I had made a stupid mistake and accidentally re-used one of the StdGens...
03:50:24 <SamB> may I suggest Control.Monad.State (or an adaptation thereof)?
03:50:45 <Sara|Uni> I only started programming Haskell... eh ... 3 weeks ago
03:50:54 <Sara|Uni> What is Control.Monad.State ? :D
03:51:10 <SamB> it has this nifty thing called a State monad
03:51:15 <SamB> @type runState
03:51:17 <lambdabot> forall s a. State s a -> s -> (a, s)
03:51:55 <SamB> basically, it is just an abstraction over functions of type "s -> (a, s)"
03:52:44 <Sara|Uni> so...?
03:52:45 <musasabi> Any pointers to this small bytestring serialization thing before pushing it out - http://www.cs.helsinki.fi/u/ekarttun/haskell/EncodeBSL.hs ?
03:52:45 <SamB> but it is really good when you want to make sure you use the right state value at each point in your computation ;-)
03:52:48 <lambdabot> http://tinyurl.com/yjeyb2
03:53:36 <SamB> you'd have "applyOnceR :: String -> [Rule] -> State StdGen String"
03:54:14 <SamB> and "replaceR :: Char -> [Rule] -> State StdGen String"
03:55:00 <dcoutts> hia Sara|Uni
03:56:33 * ndm predicates flame wars in haskell mailing lists shortly...
03:56:42 <Sara|Uni> hi duncan :D
03:57:05 <dcoutts> ndm, oh I wanted to talk to you about something
03:57:18 <Sara|Uni> I'm just trying to get some debugging output, sec
03:57:22 <ndm> dcoutts, sure
03:58:07 <ndm> dcoutts, oh, thanks for the offer for FUN in teh afternoon accomodation, but the other York people are driving down on the day, so I have got a lift with them
03:58:27 <dcoutts> ndm, ah, ok, that's what I was going to ask about
03:58:38 <ndm> turns out there is an additional york haskell programmer, who none of us knew about
03:58:41 <dcoutts> ndm, and the other thing was about this FFI cabal win32 thing
03:58:48 <ndm> indeed :)
03:59:01 <ndm> appears that Ross is entirely correct, under hugs its jsut plain wrong
03:59:13 <SamB> and maybe "getRandomR range = State (randomR range)"
03:59:47 <dcoutts> ndm, oh yeah, so you need to get Cabal to generate a different Paths_<pkg> when we're using hugs anyway.
03:59:55 <dcoutts> ndm, well patches gladly accepted.
04:00:14 <ndm> dcoutts, Simon M tweaked it last time, i guess he would have most idea of what needed doing
04:00:52 <dcoutts> I expect you know more than Simon M
04:01:25 <dcoutts> you just need to generate the same paths but using a different mechanism
04:02:28 * beelsebob tickles ndm 
04:02:47 <ndm> dcoutts, i think thats unlikely - Simon M seems to know whats gonig on their
04:02:58 <ndm> beelsebob: i got my black belt at the weekend, fear me!!!
04:03:03 <ndm> :)
04:03:07 <dcoutts> ndm, I suspect it'll not get done in that case
04:03:12 <ndm> :(
04:03:25 <Sara|Uni> SamB: Hmmm... strangely enough ... random doesn't seem to be the problem *scratch scratch* I'll have to look in my code again
04:03:35 <dcoutts> Sara|Uni, btw, I'm not sure I'd recommend using a random monad for this
04:03:59 <beelsebob> ndm: nice
04:04:09 <beelsebob> first dan I assume
04:04:15 <ndm> beelsebob: indeed
04:04:17 <dcoutts> Sara|Uni, you can just pass the StdGen as a parameter like you pass the current position and direction.
04:04:35 <SamB> dcoutts: hmm, not if that isn't the problem, I guess ;-)
04:04:41 * beelsebob tickles ndm and runs away giggling like a little girl
04:04:41 <beelsebob> :P
04:05:07 <beelsebob> hehe
04:05:13 * beelsebob is being evil in #php
04:05:33 <beelsebob> some guy posted a stupid regexp that really shouldn't have been done that way
04:05:48 <beelsebob> I'm trying to get him round to writing in hsp and using parser combinators instead
04:05:59 <araujo> morning
04:06:03 <beelsebob> moin
04:06:06 <dcoutts> Sara|Uni, the other trick is that you don't have to use the StdGen in a single threaded way, ie you don't have to return the StdGen from each function. You can use split, as was hinted in the practical description.
04:07:29 <Sara|Uni> dcoutts: yeah, thinking about that ... but I'm really confused now - it's picking the rules randomly, but it only uses the colours in the first rule .. strange things happening!
04:07:46 <Sara|Uni> dcoutts: don't have the 3d version yet though ;)
04:08:18 <dcoutts> Sara|Uni, I was just updating the description to make the 3D bit rather easier. I think it was too hard at first.
04:08:26 <Sara|Uni> hehe
04:08:37 <Sara|Uni> well, I'm back to debugging...
04:08:49 <dcoutts> Sara|Uni, the colour problem is probably different. Perhaps you're not saving and restoring the colour with the '[' and ']'
04:08:58 <Sara|Uni> thought I was ...
04:09:03 <Sara|Uni> have to check Draw.lhs
04:09:19 <dcoutts> dunno, I can't see your code, this'd be easier to see on Monday :-)
04:09:29 <Sara|Uni> aaaah
04:09:34 <Sara|Uni> saving it, but not loading it
04:09:36 <Sara|Uni> stupid me
04:09:45 <Sara|Uni> happens when you only change half the code ;)
04:09:50 <dcoutts> :-)
04:14:29 <psykotic> anyone know any examples of where non-initial F-algebras show up in programming?
04:24:00 * dcoutts now understands why ndm mentioned the beginning on a flame-fest
04:24:05 <dcoutts> of/of
04:24:09 <dcoutts> err on/of
04:24:25 <ndm> dcoutts, i did try and reduce it in the comments i made directing discussion...
04:24:35 <dcoutts> ndm, yes, very sensible
04:24:56 <ndm> dcoutts, of course, as soon as i push for base inclusion, then the flame war will truely begin...
04:25:02 <dcoutts> heh heh
04:25:08 <yaxu> lambdabot: seen nornagon?
04:25:49 <dcoutts> ndm, it's interesting that people are not currently complaining that FilePath = String, but as soon as you try and make that more useful and less error-prone they do complain.
04:25:51 <yaxu> lambdabot: ?seen nornagon
04:25:52 <lambdabot> I saw nornagon leaving #haskell.jp and #haskell 1d 2h 1m 50s ago, and .
04:26:25 <ndm> dcoutts, the phrase "let sleeping dogs lie" springs to mind - yeah, broken features are fine as long as you don't want to fix them...
04:26:34 <dcoutts> ndm, heh :-)
04:26:58 <dcoutts> ndm, it's specified in H98 afterall, if they want that changed then they know where to go to get language spec changes
04:27:59 <ndm> dcoutts, i did consider saying "if you want to complain about that, flame the writers of the H98 report" - but thought that was a bit unfair
04:28:07 <dcoutts> heh :-)
04:28:14 <dcoutts> I think it'd be fair
04:28:14 <psnl> ndm: do you have backend code for Observe in HatGui, or should I write that at some point?
04:28:22 <earthy> time for a reformulation in haskell' ?
04:28:33 <SamB> flaming would be unfair, I think
04:28:41 <SamB> talking about it, no ;-)
04:28:42 <ndm> psnl: i have nothing done for that at all - everything i've done is in teh darcs repo
04:29:09 <ndm> earthy: no, type FilePath = String is by far the best representation anyone has come up with - people make up these weird ADT's but they are always horribly broken...
04:29:18 <dcoutts> earthy, and the issue there would be that noone has actually proposed a sensible file path ADT, and implemented it and tried it in practise.
04:29:59 <psnl> ndm: cool, that will be this afteroon's job
04:30:12 <SamB> ndm: but is it actually a string of bytes, or a string of characters?
04:30:20 <earthy> ah, but what I meant is that one doesn't need to specify in the language spec that 'type FilePath = String'
04:30:22 <dcoutts> SamB, it's nicely not specified
04:30:23 <ndm> SamB, characters - that answer is easy
04:30:42 <earthy> but that you can leave it up to the implementation, while providing read and show for filepaths, e.g.
04:30:44 <ndm> type String = [Char], therefore a list of Char surely
04:30:45 * SamB isn't sure unix agrees with ndm
04:30:53 <dcoutts> SamB, right.
04:30:57 * ndm knows Unix disagrees with him
04:31:08 <SamB> I agree that it would be nice, personally
04:31:18 <dcoutts> that's part of the problem of an ADT, you'd actually have to address these issues
04:31:20 <ndm> earthy: but then how do you manipulate FilePath's? H98 has no way, other than treating them as strings
04:31:26 <dcoutts> rather than sweeping them under the carpet
04:32:26 <yaxu> Syzygy- / dons: I started looking as Haskore, looks quite a lot like my representation of music so far, I think I would gain a lot by using it
04:32:34 <SamB> also, if FilePath might not be String, shouldn't it be newtyped?
04:33:08 <ndm> you need to put a FilePath library into the base before you make FilePath a newtype
04:33:14 <dcoutts> SamB, well only if you also provide a full set of operations on your new abstract type
04:33:18 <ndm> and at least 2 years before, for depreciation time
04:33:22 <dons> yaxu: I think its a great idea to reuse as much of it as you can
04:33:30 <SamB> ndm: yeah ;-)
04:33:40 * ndm goes to eat lunch, food for flamefests :)
04:33:46 <dons> some smart thinking went into it during the 90s, so there's got to be something sensible in there
04:33:51 <SamB> who knows! maybe by then unix will have its act together!
04:34:56 <dcoutts> SamB, you mean it'll enforce UTF8 encoding of file names ? good luck.
04:35:36 <dcoutts> at least the linux kernel folk are pretty dead set on not caring what the encoding is.
04:35:57 <SamB> that sucks
04:36:13 <SamB> how the hell do they deal with NTFS?
04:36:30 <dcoutts> ok, so some FS impose more restrictions
04:36:44 <dcoutts> but the default ones do not care
04:36:49 <SamB> NTFS uses, what, UCS-2? UTF-16?
04:36:56 <dcoutts> yeah, something like that
04:50:02 <yaxu> is anyone doing anything related to speech synthesis in haskell?
04:51:30 <gour> ndm: yhc does not build - svn: URL 'http://svn.python.org/projects/ctypes/trunk/ctypes/source' doesn't exist
04:51:33 <lambdabot> http://tinyurl.com/wabj8
04:55:31 <kosmikus> ndm: thanks a lot for the System.FilePath release. you can still submit it to HCAR if you want to.
04:58:12 <Sara|Univ> ah! finally!
05:02:04 <dcoutts> Sara|Univ, it works ?
05:02:08 <Sara|Univ> wanna see a pic?
05:02:12 <dcoutts> yeah
05:02:31 <Cale> what is it?
05:02:41 <Sara|Univ> http://users.conquer-space.net/~sara/randomized.png
05:02:44 <lambdabot> http://tinyurl.com/u5mk3
05:02:46 <dcoutts> Sara|Univ, I've just updated the description with more on the 3D extension, so you might like to look at that next.
05:02:48 <dcoutts> :-)
05:02:53 <Sara|Univ> will do
05:02:58 <Cale> ah, an l-system generator :)
05:03:07 <Sara|Univ> indeed cale
05:03:11 <dcoutts> Sara|Univ, looks nice :-)
05:03:27 <Cale> are you using a similar technique to the one that xerox and I took?
05:03:30 <Sara|Univ> dcoutts: thats colours, random rules and fuzzy lengths/angles
05:03:34 <dcoutts> cool
05:03:46 <dcoutts> Cale, somewhat, but it's pure not monadic
05:03:55 <psykotic> cale: you guys wrote yours over an l-system monad, right?
05:04:06 <Cale> Over an arbitrary monad
05:04:13 <dcoutts> Cale, since this is a first FP course, so no monads.
05:04:31 <psykotic> cale: an arbitrary one? don't you need something like MonadPlus? (haven't really thought of this at all)
05:05:14 <Cale> that sounds right actually :)
05:05:45 <Cale> no, arbitrary :)
05:05:55 <Cale> expand :: (Monad m) => Productions m -> String -> m String
05:06:00 <dcoutts> Cale, that and we can't use cairo sadly since our solaris boxes are too old. :-( but we can use opengl :-)
05:06:01 <psykotic> so how do you express choice?
05:06:14 <Cale> psykotic: in a nondeterminism monad, you have choice
05:06:28 <psykotic> right, hence my mention of MonadPlus (with plus representing choice)
05:06:30 <Cale> In the Random monad, you have random choice
05:06:44 <Cale> In the Identity monad, you have an ordinary L-system generator
05:06:58 <Sara|Univ> dcoutts: had to bug the support to get gtk and opengl on my office pc
05:07:13 <psykotic> cale: i still don't see how you express the notion of grammatical alternative/choice, exactly, could you elaborate?
05:07:23 <Cale> You don't, in non-MonadPluses
05:07:37 <psykotic> so... how can this work in arbitrary monads?
05:07:47 <Cale> L-systems don't require choice
05:08:10 <Cale> By default (in the identity monad), you get deterministic L-systems
05:08:11 <psykotic> they don't require it since you can always ignore the alternatives
05:08:19 <psykotic> right
05:08:25 <dcoutts> Sara|Univ, heh, yeah, I had to bug support to get it on the practical workstations :-)
05:08:31 <Cale> You only need choice to represent nondeterministic L-systems
05:09:52 <psykotic> but suppose i want to define the usual kind of non-deterministic L-system and i want it to be interpreted in the identity monad.
05:10:08 <Cale> You'd use the list monad instead.
05:10:10 <psykotic> do you have a default typeclass instance where 'choice' is a no op?
05:10:15 <Cale> no
05:10:20 <Sara|Univ> dcoutts: now 3d, then code cleanup ;)
05:10:27 <Sara|Univ> dcoutts: code cleanup is nasty
05:10:28 <Cale> Note the Productions m
05:10:45 <dcoutts> Sara|Univ, I'll look forward to seeing some cool demos on Monday then :-)
05:10:45 <Cale> The Productions type is parametrised over the monad.
05:10:46 <psykotic> cale: ahh, i gotcha.
05:10:59 <Cale> type Productions m = M.Map Char (m String)
05:11:00 <psykotic> i didn't notice the m part of Productions m
05:11:03 <psykotic> right right
05:11:05 <Cale> type LSystem m = (m Axiom, Productions m)
05:11:13 <dcoutts> Sara|Univ, tell me if the description for the 3D bit doesn't make any sense.
05:11:20 <Sara|Univ> dcoutts: will do
05:13:11 <Cale> By using the multiplicative monoid and WriterT transforming the list monad, you can work with probabalistically-weighted rules, and get out a final list of possible strings generated together with probabilities
05:13:18 <Cale> and you don't have to modify the expander :)
05:23:11 <ndm> gour: are you using the haskell.org repo? that got fixed a while ago
05:24:13 <ndm> kosmikus, no problem - ok, thought i had missed HCAR but will submit something right this second
05:25:03 <kosmikus> ndm: great, thanks
05:26:02 <chessguy> i have a list, something like [8,3,5,6,9,10,12,7,11,13,14,15], nothing very special about it. i want to generate all tuples, in order, like this: [(8,3),(8,5),(8,6),...,(8,15),(3,5),...,(3,15),(5,6),...]. Suggestions?
05:28:03 <chessguy> i'm thinking something like foldr zip tail?
05:29:06 <lennart> @ [(x,y) | x:xs <- tails [1,2,3,4], y <- xs]
05:29:32 <lennart> > [(x,y) | x:xs <- tails [1,2,3,4], y <- xs]
05:29:34 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
05:29:35 <chessguy> > [(x,y) | x:xs <- tails [1,2,3,4], y <- xs]
05:29:36 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
05:29:41 <chessguy> wow
05:29:49 <chessguy> you could at least make it look like it were hard
05:29:57 <Cale> hehe
05:30:06 <lennart> short isn't necessarily easy :)
05:30:09 <merus> list monad is cute :)
05:31:50 <chessguy> beautiful
05:33:01 <lennart> it's why we like haskell :)
05:34:02 <Cale> @undo do (x:xs) <- tails ys; y <- xs; return (x,y)
05:34:03 <lambdabot> tails ys >>= \ a -> case a of { (x : xs) -> xs >>= \ y -> return (x, y); _ -> fail ""}
05:34:21 <Cale> @pl \ys -> tails ys >>= \ a -> case a of { (x : xs) -> xs >>= \ y -> return (x, y); _ -> fail ""}
05:34:22 <lambdabot> (line 1, column 38):
05:34:22 <lambdabot> unexpected "{"
05:34:22 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
05:34:27 <Cale> ah, right
05:34:33 <dylan> does pl like case?
05:34:38 <Cale> no, it doesn't
05:35:08 <chessguy> no, it tends to say things like unexpected "{" and expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
05:35:12 <chessguy> i think
05:36:02 <int-e> @undo xs <- init (tails ys); y <- tail xs; return (head xs, y)
05:36:03 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 4}) "Parse error"
05:36:34 <int-e> @. pl undo do xs <- init (tails ys); y <- tail xs; return (head xs, y)
05:36:34 <lambdabot> liftM2 (>>=) tail ((return .) . (,) . head) =<< init (tails ys)
05:36:50 <dylan> Heh
05:37:11 <dylan> definitely not better than the list comp form
05:37:46 <int-e> that depends. if your mission is to confuse people, I think the list comprehension is worse ;)
05:38:05 <int-e> @type liftM2 (>>=)
05:38:07 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m a) -> m1 (a -> m b) -> m1 (m b)
05:43:53 <Sara|Univ> till later or so
05:44:04 <Sara|Univ> thanks for the feedback - once again :)
05:46:25 <psykotic> @type liftM2
05:46:27 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:48:21 <kpreid> @type \a b c -> liftM a b `ap` c
05:48:23 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a1 -> a -> b) -> m a1 -> m a -> m b
05:51:22 * vincenz invents the nomonad
05:51:33 <vincenz> No >>= f = No
05:51:37 <vincenz> return x = No
05:52:42 <kpreid> type No = ()
05:52:43 <_matthew_> such a stubborn monad
05:52:49 <gour> ndm: no, i'm using york-repo
05:53:16 <ndm> gour: thats out of date, the new repo is http://darcs.haskell.org/yhc
05:53:21 <lambdabot> Title: Index of /yhc
05:53:25 <norpan> the comonad of the No monad is the Yes monad?
05:53:27 <ndm> anyone know how we can stamp out of date on the york repo?
05:54:29 <gour> ndm: thanks. why not putting yhc under gentoo-haskell overlay?
05:55:15 <ndm> gour: we have a gentoo thingy for it, its somewhere, not sure what the status of it is (either Andrew or dcoutts would know)
05:55:36 <Igloo> ndm: Why not remove it?
05:56:06 <Lemmih> ms__: How's your automatic testing coming along?
05:56:12 <dcoutts> ndm, add a motd to the repo so people who pull from it will see the message
05:56:14 <ndm> Igloo: ok, will do :)
05:56:20 <ndm> dcoutts - how?
05:56:23 <ms__> Lemmih: um, are you sure you mean me
05:56:29 <Igloo> ndm: You could make an _darcs/prefs/motd otherwise
05:56:29 <gour> ndm: it is in gentoo overlay
05:56:36 <dcoutts> gour, yep
05:56:46 <ms__> Lemmih: I can't remember what my normal nick is and my passwd doesn't seem to work for this one... ;)
05:57:03 <dcoutts> ndm, _darcs/prefs/motd on the server side
05:59:36 <gour> @where paste
05:59:37 <lambdabot> http://paste.lisp.org/new/haskell
05:59:40 <ndm> Igloo, dcoutts - done, thanks
05:59:48 <Lemmih> ms__: Oh sorry. Got the wrong matthew, I see.
05:59:51 <ndm> gour: it won't build just now, give me 10 mins
06:00:03 <matthew__> Lemmih: np ;)
06:00:18 <gour> ndm: oh, i was just prepared to paste something :-)
06:00:29 <ndm> gour: about System.FilePath?>
06:00:46 <gour> ndm: no, darcs stuff
06:01:00 <lisppaste2> gour pasted "yhc build fails" at http://paste.lisp.org/display/29490
06:01:42 <ndm> gour: ah no, thats a real bug - i've pinged our build guy with it
06:01:57 <gour> :-(
06:02:18 <ndm> gour: give us 5 minutes
06:02:22 <gour> ok
06:03:07 <vincenz> ndm: support on the fly?
06:03:15 <ndm> vincenz: as always :)
06:05:27 <bringert> does anyone know if esc/haskell is available for download?
06:09:51 <ndm> bringert: its not
06:09:55 <ndm> (i want a copy too)
06:10:08 <ndm> bringert: the paper is, if thats what you are after
06:10:31 <xerox> it would be cool to have it as a GHC extension, wouldn't it?
06:10:37 <dylan> hmm.
06:11:25 <dylan> I wonder if I could or should use haskell -- I need to translate some data (in YAML format) to lisp s-exprs... and the thought of doing this in perl makes me feel afraid.
06:11:58 <xerox> dylan: ask in #perl6 for a yaml haskell library, they use it, I think it is called hssyck but I could be wrong
06:12:10 <dylan> I have hssyck installed
06:12:29 <ndm> xerox: maybe a stand alone tool would be better - rather than suck everything into GHC
06:12:39 <bringert> ndm: thanks, I've got the paper, I was looking for the implementation
06:12:53 <ndm> bringert: i asked, Dana said its not ready yet
06:13:00 <xerox> dylan: ah! cool
06:13:04 <bringert> ok, I just sent an e-mail too
06:13:04 <dylan> I'm just wondering if this will make the system even more hackish.
06:13:24 <bringert> everyone should just release early and release often
06:13:32 <bringert> not even release, just put up a darcs repo
06:13:33 <vincenz> bringert: no comment
06:13:38 <dylan> web front end (perl) -> haskell program -> perl program to call autocad -> autolisp...
06:13:53 <dylan> and I've got 10 days left to complete it..
06:14:35 <bringert> vincenz: about what?
06:14:59 <xerox> dylan: eeek :)
06:15:17 <dylan> xerox: unless I could do the COM/OLE stuff in haskell too...
06:15:19 <vincenz> bringert: never mind, I was thinking of taking your comment and sticking it into a different context
06:15:21 <xerox> bringert is right! :)
06:15:32 <bringert> vincens: ewww
06:15:40 <bringert> s/s/z/
06:15:47 <xerox> dylan: there is HDirect which lets you work with win32 API I think, ndm surely knows
06:16:00 <bringert> vincenz: how do you work darcs into that?
06:16:19 <vincenz> bringert: your comment did not include darcs
06:16:38 <ndm> xerox, dylan: there is, but i'm not sure its incredibly well maintained
06:16:41 <bringert> yeah, I know, that came after
06:16:51 <vincenz> :P
06:17:05 <dylan> I just need to call CreateObject("AutoCAD.Application.16.1") and some other crap...
06:17:20 <bringert> I know Krasimir Angelov has been using HDirect for Visual Haskell, and he said it works but it old and buggy
06:17:26 <bringert> is
06:17:26 <ndm> bringert: i find the best way to get code out of someone is to cc haskell-cafe with a comment such as "your paper _claims_ to be able to do this, have you any code to be made available"
06:17:34 <bringert> haha
06:17:41 <dylan> holy crap, sun's going to GPL java?
06:17:59 <bringert> krasimir said he uses HDirect, and then hand-hacks the generated code in some places
06:18:34 <vincenz> ndm: lol :P
06:19:39 <dylan> hmm, how hard is it to get ghc working on windows ? And would foreign import's work the same way?
06:20:20 <dylan> 'cause I could just code a few helper routines in C and link against those (assuming OLE/COM is possible from C)
06:20:21 <bringert> dylan: think so, there is a different calling convention though
06:20:41 <bringert> ah, then you probably even doesn't need that, could just use ccall
06:20:42 <dylan> different calling convention?
06:21:08 <bringert> the win32 API uses some crazy pascall calling convention or something, I can't remember
06:21:15 <bringert> ABI rather
06:21:36 <bringert> but I don't know anything about win32 so I should just shut up
06:22:08 <gds> dylan: sun gpl java? You have a link?
06:22:13 <dylan> gds: slashdot
06:22:21 <gds> Cheers :)
06:22:21 <dylan> gds: http://developers.slashdot.org/developers/06/11/08/0221255.shtml
06:22:25 <lambdabot> Title: Slashdot | Sun To Choose GPL For Open-Sourcing Java, http://tinyurl.com/y4d6vp
06:23:01 * gds finds http://www.theinq.com/default.aspx?article=35599 too...
06:23:05 <lambdabot> Title: Open Sauce Java to get a GPL licence, http://tinyurl.com/yhpnkq
06:25:06 <ndm> gour: try again now
06:25:12 <gour> ndm: ok
06:25:13 <ndm> gour: it won't build, but it should get past that bit
06:25:54 <vincenz> online-debugging
06:26:18 <bringert> Many people are obsessed with making their code perfect before releasing it. Thus, for them, a release is a statement that the code is perfect. This means that they think they will be judged by the quality of their code.
06:26:27 <ndm> vincenz: via a 3rd party - i didn't fix that, it was Andrew he's on the other side of the UK right now
06:26:44 <ndm> bringert: argreed - i have a darcs repo of Catch up from over a year ago, and it still barely works!
06:27:07 <vincenz> do like me, never release :P
06:27:25 <bringert> exactly, that's the result
06:27:51 <bringert> An alternative is to publish all code all the time (e.g. have a public darcs repo and make snapshot releases), so that everyone knows you don't consider the code "done".
06:28:14 <ndm> yes, i think thats the best method
06:28:20 <ndm> darcs tag is the best way to do it
06:28:26 <gour> ndm: ok, it works, i.e. it arrived at FilePath.hs ;)
06:28:29 <vincenz> darcs tag?
06:28:43 <ndm> gour: good good, just waiting for Andrew to fix a bit, then i fix a different bit
06:29:17 <gour> vincenz: "Tag the contents of the repository with a version name."
06:29:25 <moonlite> in what version did ghc get postfix operators?
06:31:23 <Igloo> 6.6, if you mean (foo +)
06:34:06 <moonlite> Igloo: ok.
06:34:18 <vincenz> how is that postfix?
06:34:22 <vincenz> that's just partial application
06:34:30 <dylan> that's a section, no?
06:34:33 <vincenz> yeah
06:34:34 <moonlite> Igloo: im thinking like: "let (!) x = product [1..x]; 5! = 120"
06:34:45 <Igloo> It now doesn't require a second argument
06:34:53 <Igloo> moonlite: Never, then
06:34:58 <moonlite> oh ok
06:35:29 <moonlite> must have misunderstood the manual
06:35:32 <Igloo> let (!) x = product [1..x] in (5!)   would work in 6.6, though
06:35:48 <Igloo> Although personally I wouldn't recommend using it
06:35:53 <swiert> Does anyone here know who writes sigfpe.blogspot.com?
06:36:53 <matthew__> is this some subtle ploy to get 236 hits to your blog?
06:36:56 <matthew__> ;)
06:37:20 <shapr> swiert: Isn't that Dan Piponi?
06:37:27 <vincenz> yeah
06:37:28 <swiert> Nope. I was just curious.
06:37:29 <ndm> @seen sigpfe
06:37:30 <lambdabot> I haven't seen sigpfe.
06:37:58 <Binkley> if it's the same sigfpe, here's his home page: http://homepage.mac.com/sigfpe/
06:38:00 <lambdabot> Title: index
06:38:22 <swiert> shapr: could be. I was just wondering if he/she hung out here.
06:38:25 <Binkley> I guess it probably is, since the home page has some haskell-related links
06:40:26 <swiert> kewl. He also helped make the special effects for several Matrix films.
06:40:35 <swiert> Assuming it's all the same guy.
06:40:53 <Syzygy-> Whoa. sigfpe worked on the matrix films!?
06:41:12 <ndm> gour: all fixed now, give it another go - should work fine
06:41:26 * gour is trying
06:42:35 <Syzygy-> "...the code for proving the existence of grammatically correct poetry with a given number of syllables..."
06:43:29 * Syzygy- looks at the imdb listing for Dan Piponi. Wow.
06:45:16 <shapr> Where's the poetry code?
06:45:57 <Syzygy-> Linked from the homepage.mac.com/sigfpe... I didn't follow the link, so I couldn't tell you more.
06:47:26 <shapr> He got an Academy Award?
06:47:47 <shapr> I don't think there are many Haskellers who can say that.
06:48:26 <malebria> Hello there.
06:49:43 <Binkley> shapr: not until the documentary of ICFP 2006 comes out :-)
06:50:05 <shapr> hah
06:50:10 <shapr> hiya malebria
06:53:23 <gour> @where past
06:53:24 <lambdabot> I know nothing about past.
06:53:28 <gour> @where paste
06:53:30 <lambdabot> http://paste.lisp.org/new/haskell
06:53:49 <lisppaste2> gour pasted "yhc build fails" at http://paste.lisp.org/display/29492
06:54:00 <gour> ndm: ^^^
06:55:06 <ndm> gour: thats an issue with a particular prerelease of scons, you just made our maintainer go "grr"
06:55:21 <gour> ndm: what can i do :-(
06:55:36 <ndm> gour: wait, give our maintainer a few minutes to think
06:55:42 <ndm> gour: whats your scons --version output?
06:55:53 <ndm> gour: and OS and where you got scons from
06:58:12 <lisppaste2> gour annotated #29492 with "scons output" at http://paste.lisp.org/display/29492#1
07:02:24 <malebria> Hello, is there a way to catch when a Label Text has changed in gtk2hs?
07:02:47 <malebria> I asked in #gtk+ in irc.gimp.org, and they sad that the signal raised is notify-label.
07:02:55 <malebria> But I can't find about it in gtk2hs doc.
07:04:53 <ndm> gour: please try again, a change has been pushed
07:08:23 <shapr> Shazam! How's code everybody?
07:08:52 <ToRA> ls
07:08:55 <ToRA> oops
07:09:05 <shapr> .. shapr ndm malebria ...
07:09:15 <vincenz> sounds like an incantatio
07:09:16 <ndm> shapr?
07:09:17 <vincenz> +n
07:09:43 <shapr> ndm: Sorry, ToRA did an ls on the channel.
07:10:15 <shapr> ToRA: Why is the Oliver lowercased? Is that what people call you?
07:10:53 <gour> ndm: yhc is built
07:11:06 <ndm> gour: woohoo!
07:12:06 <ToRA> shapr: style
07:12:34 <lisppaste2> gour annotated #29492 with "guihaskell build" at http://paste.lisp.org/display/29492#2
07:12:53 <dcoutts> malebria, we don't have that bound specifically, we don't have good support yet for the notify signal and it's sub-signals.
07:13:03 <gour> ndm: see paste
07:13:20 <dcoutts> malebria, so we do have the notify signal bound, but you can't yet distinguish one kind of notify from another.
07:13:50 <dcoutts> malebria, in future it'll be possible to get a signal on attributes and then you'll be able to do it directly.
07:14:07 <ndm> gour: GuiHaskell or Yhe inside Yhc
07:14:33 <malebria> dcoutts: but is there onXXX function that is useful for when the text of a label is changed?
07:14:39 <malebria> dcoutts: or any way to do this?
07:14:44 <gour> ndm: guihaskell
07:15:13 <ndm> gour: haven't tried building that in a while, i suspect that the Gtk2Hs people changed that signature and its broken
07:15:24 <ndm> gour: i know they changed one function around their in a similar manner
07:15:45 <gour> ndm: ok. the other day i recommended guihaskell on gentoo forums so would like to be able to build it, at leasr
07:15:58 <dcoutts> malebria, actually, the onNotify signal isn't bound at all so it's not currently possible
07:16:08 <ndm> textTagNew ("fg" ++ name) ==> textTagNew (Just $ "fg" ++ name)
07:16:28 <ndm> dcoutts, any news on what textTagNew's official API is or when a version gets released so everyone has the same API?
07:16:38 <malebria> dcoutts: ok, thanks.
07:17:23 <dcoutts> ndm, you wanted to keep the api of the current darcs version didn't you ?
07:17:35 <dcoutts> ndm, rather than adding textTagNewAnonymous ?
07:18:05 <ndm> dcoutts, couldn't care less, i just want a single API - either is fine by me (but I can't spell Anonymous, which makes the second one harder to use)
07:18:22 <dcoutts> heh, I don't think I can spell it either :-)
07:18:31 <dcoutts> ndm, then the current api will stick
07:18:33 <Syzygy-> A. Nony Mouse
07:18:44 <dcoutts> there will be a new release this year
07:19:05 * gds remembers having to learn to spell anonymous using ftp in the early 90s...
07:19:06 <ndm> dcoutts, any chance of sooner - its hard to have a version that uses it if two different API's are out of sync
07:19:32 <dcoutts> ndm, well exactly, we don't want to release before we've stabilised the api
07:19:46 <ndm> gour: I don't recommend guihaskell yet, there is a nasty threading + GHC + Gtk2Hs + Gtk + Windows bug floating out there which means it goes dead slow on my fast computer
07:20:02 <ndm> gour: plus since i don't use it full time, there are probably plenty of other bugs floating around in it
07:20:08 <gour> ndm: ok, good to know hoping it will change soon
07:20:40 <ndm> gour: dcoutts and JaffaCake are going to try and go through it next week, i want to use it too, so hopefully will get it fixed up
07:20:56 <gour> ndm: * thump up*
07:21:05 <dcoutts> ndm, especially if you're there to talk about it :-)
07:21:10 <gour> i mean, thumb :)
07:21:21 <ndm> dcoutts, i will be, from about 2 onwards
07:21:32 <ndm> dcoutts, any idea what the talk schedule is yet?
07:21:52 <gour> dcoutts: what's the name of that project providing nice gtk theming for win32?
07:21:57 <dcoutts> ndm, ah, we'll be talking in the morning.
07:22:06 <dcoutts> gour, it's called Gtk+ :-)
07:22:18 <dcoutts> it's not a separate project
07:22:21 <gour> noj, wimp or something
07:22:25 <ndm> dcoutts, fair enough - i just want it to work :)
07:22:41 <ndm> dcoutts, feel free to show him GuiHaskell though, to show the goodies he'd get if it did work
07:22:43 <dcoutts> gour, yes, it's no longer a separate project
07:22:53 <gour> really?
07:22:57 <gour> merge?
07:22:59 <dcoutts> really.
07:23:05 <dcoutts> since Gtk+ 2.6.z
07:23:16 * gour is behind the scene :-(
07:23:53 <dcoutts> ndm, the point being that you rely pretty heavily on using lots of lightweight threads to do the gui abstraction
07:24:17 <ndm> dcoutts, indeed - i don't have to though (if you give me some other primitives that work)
07:24:27 <dcoutts> ndm, like ?
07:24:58 <ndm> dcoutts, you provide the primitives - anything would work, threads are probably best though
07:25:14 <dcoutts> aye
07:25:17 * dcoutts has to go
07:25:22 <ndm> dcoutts, my project only uses 2 threads - one for the GUI, one for the computation
07:25:30 * ndm waves bye to dcoutts
07:25:41 <psnl> ndm: threads suck on win32/haskell/gtk2ks?
07:25:52 * dcoutts waves and scarpers
07:26:00 <psnl> are we talking haskell threads, OS threads, or both?
07:26:23 <ndm> psnl: just threads, once you have Gtk you have to have OS threads
07:26:51 <dcoutts> ndm, you don't need OS threads to use Gtk+
07:27:06 <dcoutts> anyway, I was leaving :-)
07:27:11 <psnl> ndm: interesting, since I have been using forkIO in hatgui
07:27:19 <ndm> psnl: successfully?
07:27:30 <psnl> it seems to work.
07:27:38 <ndm> psnl: i can do it successfully on 2 machines out of 3, but the 3rd keeps crashing with it
07:28:01 <psnl> any difference between the machines?
07:28:10 <ndm> speeds, hyper threading
07:28:14 <ndm> it seems that is causing it
07:28:42 <metaperl> does haskell just have comment style {- like this -} or is there another also?
07:28:54 <vincenz> --
07:29:02 <metaperl> vincenz:  oh yeah, thanks
07:29:09 <vincenz> :)
07:29:24 <vincenz> I love communicating effectively with a minimum of ascii symbols
07:30:13 <psnl> ndm: I'll try it on a HT box at some point then
07:31:25 <metaperl> within a module, does a function have to be defined before it is referenced in another function?
07:31:45 <ndm> psnl: submit your patches and i can test them
07:32:18 <musasabi_> metaperl: no.
07:32:24 <metaperl> musasabi_: thanks
07:32:44 <musasabi_> metaperl: but for TH yes - which is very annoying.
07:33:22 <psnl> ndm: I'm having a "don't release anything until its all perfect" moment
07:33:39 <ndm> bad psnl, release early, release often!
07:33:49 * vincenz sighs
07:51:57 <jgrimes> morning.
07:53:21 <ValarQ> hello mr Grimes
07:54:04 <jgrimes> :)
08:07:43 <scodil> ?active
08:07:44 <lambdabot> Unknown command, try @list
08:07:55 <scodil> ?list
08:07:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:08:33 <scodil> ?users
08:08:34 <lambdabot> Maximum users seen in #haskell: 265, currently: 245 (92.5%), active: 50 (20.4%)
08:09:53 <vincenz> > return "lambda-cookie" >>= replicate 50
08:09:57 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
08:10:05 <psnl> yum
08:10:17 <Binkley> Mmmmm lambda cookies.
08:10:31 <vincenz> 'take 1' please :)
08:10:45 <Binkley> just don't drop any
08:10:57 <psnl> what about the crumbs?
08:15:29 <xerox> ?type replicate
08:15:31 <lambdabot> forall a. Int -> a -> [a]
08:15:46 <xerox> I don't think that list counts 50 elements.
08:16:59 <xerox> Isn't it using the list monad?
08:17:39 <ToRA> > ["cookie"] >>= replicate 50
08:17:41 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
08:17:56 <ToRA> > "cookie" >>= replicate 50
08:17:58 <lambdabot>  "ccccccccccccccccccccccccccccccccccccccccccccccccccooooooooooooooooooooooooo...
08:18:02 <ToRA> heh
08:18:24 <xerox> oh that's a monade law, forall a amb. return a >>= amb  =  amb a
08:18:30 <xerox> *monad
08:18:34 <scodil> lets say I wanted to use IO/STRefs like C-pointers, and I made myself some kind of * operator that was just an alias to readIORef.  Is there any way to do the following? :  putStrLn (*stringRef) (*otherStringRef) ?   I know you can do putStrLn =<< (*stringRef)  but what about for multiple arguments?
08:19:03 <scodil> oops suppose putStrLn took 2 arguments in the first case
08:19:16 <xerox> putStrLn doesn't take two arguments
08:19:21 <scodil> suppose
08:19:35 <xerox> why?
08:19:37 <scodil> putStrLn2 a b = putStrLn a >> putStrLn b
08:20:19 <scodil> because in interfacing with real libraries, mostly ui stuff, there are lots of IO functions that take multiple arguments, each provided by other IO functions
08:20:27 <scodil> all the a <- getA  gets tedious
08:20:39 <Syzygy-> The overlap between #math and #haskell is almost scary at times. :P
08:20:57 * xerox snickers
08:21:28 <xerox> scodil: if we had monadic reflection, we could do a syntactic job like the one you are thinking of
08:22:05 <scodil> monadic reflection, you say
08:22:22 * shapr hugs musasabi_ 
08:22:27 <xerox> see #haskell-overflow's backlog for the details :)
08:23:20 <scodil> i tried writing an operator similar to =<< to do what I want, but it got nasty
08:23:30 <scodil> currying and uncurrying of IO tuples
08:23:38 <kpreid> @. pl undo \f x y -> do x' <- x; y' <- y; f x y
08:23:39 <lambdabot> liftM2 (.) (>>=) . (((const .) . ap (>>=) . (const .)) .)
08:23:45 <kpreid> hmf.
08:24:17 <scodil> don't you mean f x' y' ?
08:24:22 <kpreid> @. pl undo \f x y -> do x' <- x; y' <- y; f x' y'
08:24:23 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
08:24:24 <kpreid> yes, I do
08:24:29 <glguy> kpreid: did you mean: \f x y -> x >> y >> f x y -- ?
08:24:32 <kpreid> anyway, I'd use the un-pled version :)
08:24:44 <scodil> whats pl?
08:24:52 <kpreid> removes lambdas
08:24:57 <kpreid> glguy: no
08:25:01 <kpreid> @help pl
08:25:02 <lambdabot> pointless <expr>. Play with pointfree code.
08:25:12 <kpreid> sometimes it makes things pretty
08:25:21 <kpreid> @. pl undo \f x y -> do x' <- x; y' <- y; return (f x' y')
08:25:23 <lambdabot> liftM2
08:25:24 <glguy> kpreid: oh, so you just mean: liftM2 then?
08:25:33 <kpreid> glguy: no, liftM2 takes a pure function
08:25:42 <kpreid> this takes a (a -> b -> m c)
08:25:47 <glguy> ah
08:25:56 <kpreid> it's to (>>=) as liftM2 is to liftM
08:26:18 <scodil> the expr with all the flips in it might look better if the >>=s where changed to =<<. isn't that what =<< is? flip >>= ?
08:26:46 <kpreid> it is, and @pl knows that
08:26:55 <xerox> hehe
08:27:27 <kpreid> scodil: anyway, I'd just write a combinator bind2 f x y = do x' <- x; y' <- y; f x' y'
08:27:35 <xerox> are you suggesting doing flip ((.) . (>>=)) ~~> ((.) . (=<<)) ? that's not how it works! :)
08:27:58 <kpreid> right, if it was pl would have done it, I expect
08:28:43 <kpreid> scodil: note that every time you introduce something like this, you're making the order of effects less explicit (though still well-defined). not that this is often a problem, but you should keep it in mind
08:29:42 <scodil> kpreid: yeah this is mostly for interfacing with C libraries, so the side effects are minimal
08:30:01 <xerox> ?type flip ((.) . (>>=))
08:30:03 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> a1 -> m b) -> m a1 -> a -> m b
08:30:06 <scodil> its stuff like creating new records or reading values from records
08:30:25 <scodil> it could very well be functional, but thats not how the library is imported into haskell
08:32:08 <scodil> think of like, some gtk function that takes 6 arguments, 3 of which are ints and two are structures that you get from a simple call to getStructure or something like that
08:32:18 <scodil> and one something else
08:32:23 <scodil> before any of you wiseasses make a comment
08:42:11 * araujo back
08:46:27 <scodil> there's no hackish way to get at a ptr for a UArray, is there?
09:15:08 * shapr boings
09:17:01 <vincenz> phd students around?
09:17:15 * vincenz kicks em all to #oasis for a question
09:18:16 * beelsebob pokes shapr 
09:18:53 <Syzygy-> Yeah...
09:19:27 <sjanssen> scodil: I imagine there's a way, but it probably isn't a very good idea
09:19:43 <scodil> no of course not, not in most cases, thats why its not in the interface
09:19:48 <scodil> but sometimes you just know its safe
09:20:02 <sjanssen> the GC is allowed to move the data around, so the pointer might not remain valid
09:20:21 <scodil> yeah but if you're passing it to a C function thats going to make a copy anyway, then whats the danger
09:20:40 <scodil> the only reason I ask is because the docs say storablearray is slower. why is that?
09:21:13 <sjanssen> scodil: the GC could move the data and overwrite it with something else while the C function is reading from the array
09:21:52 <scodil> thats what locks are for
09:22:04 <sjanssen> that claim about StorableArray may be out of date, ForeignPtr has had some enhancements in GHC 6.6
09:22:08 <scodil> put the array in an mvar
09:22:34 <scodil> unless the gc doesn't care about mvars and moves em anyway
09:22:50 <sjanssen> I don't think an MVar will help you there
09:22:53 <scodil> i don't know anything about the gc. its multithreaded, right? so maybe that could happen
09:23:16 <sjanssen> nah, the GC is singlethreaded
09:23:42 <ndm> currently, but not for long
09:25:49 <norpan> can the gc run while the rts is executing a foreign call
09:25:53 <norpan> that sounds dangerous
09:26:53 <ndm> not yet, no idea if it will or not in future
09:27:40 <Igloo> I don't think that's more dangerous than anything else, is it?
09:27:43 <sjanssen> even if the GC can't run during the foreign call, the ByteArray could still be moved after you get the Ptr, but before you manage to make the C call
09:30:22 <scodil> sjanssen wins
09:35:35 <scodil> anyone know where there's haskell gaussian elimination code floating arround?
09:40:24 <shapr> @google filetype:hs gaussian elimination
09:40:28 <lambdabot> http://my.fit.edu/~lnagy/haskell/ucf_duel/linear.hs
09:40:44 <scodil> magic
09:40:49 <shapr> scodil: filetype:hs and filetype:lhs make code archeology much simpler :-)
09:41:37 <shapr> hi sara.
09:41:43 <Sara|Uni> hi there ... dcoutts you there?
09:41:52 <shapr> @seen dcoutts
09:41:53 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 2h 14m 46s ago.
09:42:20 * shapr wurbles merrily
09:42:47 <glguy> Anyone know the difference between "weaved" and "wove"?
09:43:03 <shapr> Is weaved a real word?
09:43:05 <shapr> @wn weaved
09:43:08 <lambdabot> No match for "weaved".
09:43:11 <shapr> @wn wove
09:43:11 <glguy> yeah
09:43:12 <glguy> it is
09:43:13 <lambdabot> *** "wove" wn "WordNet (r) 2.0"
09:43:13 <lambdabot> weave
09:43:13 <lambdabot>    n : pattern of weaving or structure of a fabric
09:43:15 <lambdabot>    v 1: interlace by or as it by weaving [syn: {interweave}] [ant: {unweave}]
09:43:17 <lambdabot>    2: create a piece of cloth by interlacing strands of fabric,
09:43:19 <lambdabot> [12 @more lines]
09:43:20 <shapr> WordNet doesn't think so.
09:43:23 <glguy> Inflected Form(s): wove  /'wOv /; or weaved; woven  /'wO-v&n /; or weaved; weaving
09:43:28 <glguy> m-w.com does
09:43:35 <scodil> we've squozen our last lemon
09:43:44 <shapr> My knee done swole up.
09:43:49 <shapr> He brung it over to me.
09:44:37 <pkhuong> glguy: so it's a neologism (from after 1913 ;). I tend to side with shapr on that one.
09:45:14 <int-e> 'weaved' is used for 'weave' in the sense 'to move along by twisting and turning to avoid things that are in one's way.', according to the dictionary in front of me.
09:45:36 <shapr> I'd still use wove in that case.
09:46:07 <int-e> I've never seen 'weaved' :)
09:46:21 <int-e> well, up to a few minutes ago.
09:46:24 <glguy> It appears that "weaved" is the past tense of weave as an /intransitive verb/
09:46:57 <glguy> err
09:47:00 <glguy> both I guess
09:47:04 <Binkley> as in, "George W. Bush weaved all over the place because he was driving drunk"?
09:47:11 <glguy> both transitive and intransitive
09:47:21 <glguy> Binkley: yeah, like that
09:47:31 <Binkley> makes sense
09:47:37 <Binkley> well, no, it doesn't
09:47:42 <Binkley> it's english, it's not supposed to make sense
09:47:47 <glguy> 6. past tense weaved To make (a path or way) by winding in and out or from side to side: weaved our way through the heavy traffic.
09:47:51 <glguy> . past tense weaved To move in and out or sway from side to side.
09:48:03 <glguy> both cases in this dictionary suggest that "weaved" pertains to movement
09:48:30 <glguy> a. To interweave or combine (elements) into a complex whole: wove the incidents into a story.
09:51:25 <glguy> The Chicago Sun-Times thinks they are synonymous: http://www.findarticles.com/p/articles/mi_qn4155/is_20050605/ai_n14669347
09:51:29 <lambdabot> Title: 'Weaved' or 'wove'? Let your ear decide Chicago Sun-Times - Find Articles, http://tinyurl.com/yko2mb
09:54:08 <shapr> Is there a template for new application/librarie pages on haskellwiki?
09:59:06 <genneth> sorry off-topic: does anyone have the opendns dns server ips?
09:59:10 <genneth> my university dns server has taken a dive
10:07:37 <Lemmih> genneth: 208.67.219.38
10:10:04 <genneth> Lemmih: thank you
10:10:50 <Lemmih> genneth: Oh wait. Sorry, I think I misunderstood.
10:11:24 <genneth> it's okay
10:11:25 <genneth> i got them
10:11:31 <pkhuong> Lemmih: well, once he gets to that page...
10:12:03 <Sara|Uni> hm, anyone know a site or sth. where I can find rules for nice 3d lsystems?
10:15:31 <kosmikus> dons, dcoutts, shapr, whoever else: I've been going through the HCAR submissions and couldn't find much about the SoC. I would have assumed someone would write a little "review". I don't mean that one of you has to do it, but you'd probably know who to ask ...
10:22:12 <mentomorph> hi, if I want to use an global and static data in my functions, do I use State monad or Reader monad to pass it around ? Right now, I'm just passing it on as a parameter.. Thx.
10:35:03 <Lemmih> mentomorph: The Reader monad sounds about right.
10:35:32 <tmoertel> is (!!) considered a "good consumer" in the list-fusion sense?
10:40:06 <tmoertel> ans: no.
10:40:39 <mentomorph> thx Lemmih
10:49:51 <lispy> tmoertel: why is that?
10:50:18 <lispy> tmoertel: i would expect drop to be a good consumer
10:50:27 <lispy> tmoertel: and you can imagine writing (!!) in terms of drop
10:50:29 <sjanssen> drop isn't a good consumer
10:50:37 <lispy> why is that?
10:50:47 <lispy> what makes a good consumer?
10:50:49 <sjanssen> lispy: it's a limitation of foldr/build fusion
10:51:10 <sjanssen> good consumers can be expressed in terms of foldr
10:51:25 <NewbieHaskell> Hello,what are some diferences between Scheme and haskell ?
10:51:39 <sjanssen> Haskell is statically typed
10:51:54 <sjanssen> whereas Scheme is dynamic
10:52:01 <NewbieHaskell> oh.
10:52:07 <NewbieHaskell> something else?
10:52:21 <NewbieHaskell> in what is good haskell, and in what is good Scheme ?
10:52:58 <psnl> NewbieHaskell: Monads!
10:53:20 <vincenz> I think haskell and scheme make nice complimentary languages
10:53:43 <sjanssen> lispy: other fusion frameworks have different constraints.  In streams fusion for example, !! is a good consumer
10:53:45 <lispy> yeah, let's stay away from scheme vs. haskell, please
10:54:00 <NewbieHaskell> :)
10:54:17 * psnl has never actually written anything in scheme, and I can't even spell it well
10:54:33 <psnl> apart from really easy things ;-)
10:54:52 * lispy is not a scheme programmer, he just plays one on irc
10:55:45 <lispy> sjanssen: i realy need to learn more about fussion, i thought list-fusion was about streams
10:56:29 <psnl> NewbieHaskell: why do you care? trying to go from one to the other?
10:57:03 <tmoertel> lispy: I expect the reason that drop (and its friends that take a numeric parameter) aren't good consumers is that they consume only part of the input list.
10:57:15 <NewbieHaskell> just, to know...
10:58:31 <sjanssen> tmoertel: foldr/build can fuse some functions like that.  head for example
10:59:53 <sjanssen> actually, one could write a !! in terms of foldr, but performance might suck
11:02:19 <ElPenguin> can someone please explain the benefits of monads? after much reading, i just don't `get it`
11:02:26 <sjanssen> @let index = foldr (\x xs n -> if n == 0 then x else xs (n+1)) undefined
11:02:27 <lambdabot> Defined.
11:02:31 <sjanssen> @type L.index
11:02:33 <lambdabot> Couldn't find qualified module.
11:03:14 <sjanssen> @scheck (\xs i -> L.index xs i == (xs !! i)) :: [Int] -> Int -> Bool
11:03:15 <lambdabot>  Couldn't match `Integer' against `Int'
11:03:16 <Syzygy-> foldr (\x xs n -> if n == 0 then x else xs (n+1)) undefined :: (Num a1) => [a] -> a1 -> a
11:03:51 <sjanssen> @let index = foldr (\x xs n -> if n == 0 then x else xs (n+1)) undefined :: [a] -> Int -> a
11:03:52 <lambdabot> <local>:7:0:     Multiple declarations of `L.index'     Declared at: <local>:...
11:04:00 <sjanssen> meh
11:04:05 <Syzygy-> @undefine index
11:04:06 <lambdabot> Undefined.
11:04:10 <Syzygy-> There you go. :)
11:04:17 <sjanssen> ah, didn't know you could do that
11:04:24 <Syzygy-> :)
11:04:28 <Syzygy-> Learned it yesterday
11:10:31 <astrolabe> ElPenguin: My understanding is that (amongst other things) they let you write purely functional code which does IO.
11:11:03 <astrolabe> So, maybe the question should be 'what is the benefit of functional code?'
11:11:23 <ElPenguin> astrolabe, i gathered that they allow you to return different types of values. but couldnt that be done with algebraic types?
11:11:48 <pkhuong-> ElPenguin: they abstract away the uninteresting bookkeeping.
11:12:02 <ElPenguin> pkhuong-, could you elaborate please?
11:12:17 <astrolabe> ElPenguin: That doesn't sound right about the different types.
11:12:50 <sjanssen> ElPenguin: have you seen the Maybe monad?
11:12:57 <tmoertel> > let index = foldr (\x xs n -> if n == 0 then x else xs (n-1)) undefined in [0..10] `index` 5
11:12:59 <lambdabot>  5
11:13:02 <ElPenguin> astrolabe, i've been reading YAHT and they say they didn't know what type IO operations would return so that's why it's a monad
11:13:13 <ElPenguin> sjanssen, i've seen the Maybe algebraic type
11:13:23 <Heffalump> tmoertel: ick :-)
11:13:44 <sjanssen> tmoertel: that fuses, but preliminary testing shows that performance sucks
11:13:45 <tmoertel> Heffalump: don't blame me, blame sjanssen   ;-)
11:14:40 <sjanssen> ElPenguin: okay.  That type is an instance of the Monad type class
11:14:54 <pkhuong-> sjanssen: it's a gratuitious fusion though. It's just building a list of closures instead.
11:15:14 <ElPenguin> sjanssen, Monad is a type?
11:15:20 <sjanssen> we can use it to abstract the concept of computation that fail
11:15:39 <sjanssen> ElPenguin: Monad is a type class.  A type class is a set of types that support certain operations
11:15:52 <sjanssen> pkhuong-: right
11:16:12 <sjanssen> pkhuong-: this is the same reason why GHC can't do foldl fusion
11:16:27 <ElPenguin> yeah, i understand type classes. what's special about monads?
11:16:28 <pkhuong-> sjanssen: yes.
11:16:37 <sieni> sjanssen: shouldn't that be a _class_ of types ;-)
11:16:48 <sjanssen> sieni: meh, semantics
11:18:55 <sjanssen> ElPenguin: monads are special because they're so general and useful
11:19:18 <sjanssen> parsers, exceptions, state, IO and more can be expressed monadically
11:19:22 <ElPenguin> and i have no clue in what ways
11:19:32 <ElPenguin> what is the point of a monad though?
11:20:16 <sjanssen> usually, we use monads to embed a little imperative sub language inside Haskell
11:20:46 <ElPenguin> ?
11:21:40 <Heffalump> ElPenguin: they provide a common way to structure certain kinds of computation
11:21:58 <Heffalump> for example, if you have some code that needs to pass some state around, you might write it using a state monad
11:22:02 <astrolabe> @where yaht
11:22:03 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
11:22:06 <Heffalump> now you need to add exception handling or backtracking to the code
11:22:14 <Heffalump> just change the underlying monad and your code still works
11:22:51 <astrolabe> ElPenguin: where should I look in YAHT for that bit?
11:23:11 <ElPenguin> astrolabe, the section called monads
11:28:49 <astrolabe> I can't see where it says that they allow you to return different types of values.
11:30:38 <ElPenguin> that was mentioned where they first started talking about IO
11:30:40 <astrolabe> Without monads, you often find yourself passing many arguments into and out of functions.  Monads hide away some of those arguments, and also allow you to control the way that the hidden values are used.
11:30:45 <ElPenguin> in the chapter UI in fact
11:30:47 <ElPenguin> IO*
11:31:49 <astrolabe> Could you give me a page?  I've already skimmed one chapter.
11:31:56 <ElPenguin> sec
11:33:09 <ElPenguin> http://en.wikibooks.org/wiki/Haskell/YAHT/Io about the top of this page
11:33:36 <ElPenguin> it continues all throughout there
11:34:22 <Heffalump> OOI, what makes YAHT so much more popular than the other tutorials?
11:34:44 <ElPenguin> i got recommended it by a haskeller
11:35:55 <astrolabe> ElPenguin: I think that is not saying that monads allow you to return different types, but they let you encode as a pure function, something that otherwise wouldn't be for some reason.
11:36:38 <ElPenguin> i see
11:37:33 <ElPenguin> you could write a pure function without monads though?
11:38:06 <astrolabe> Yes, pure functions are ordinary haskell functions.
11:38:26 <ElPenguin> then what advantage do we derive from monads?
11:39:00 <astrolabe> We can write functions that are sort-of impure with them.
11:39:11 <int-e> less boilerplate code
11:39:24 <ElPenguin> example?
11:40:03 <astrolabe> main = do
11:40:03 <astrolabe>   hSetBuffering stdin LineBuffering
11:40:03 <astrolabe>   putStrLn "Please enter your name: "
11:40:03 <astrolabe>   name <- getLine
11:40:03 <astrolabe>   putStrLn ("Hello, " ++ name ++ ", how are you?")
11:40:35 <int-e> take the state monad. you replace explicit state parameters,   f x y state = ... <something involving state>   by monad code that makes it implicit, f x y = do <... something that rarely mentions state ...>
11:41:11 <ElPenguin> astrolabe, but that's 3 lines of code in python. i don't see it saves anything?
11:41:16 <int-e> with a single state the former is managable, but with monads you can handle different states and other pure effects with the same syntax.
11:41:37 <ElPenguin> int-e, how so? do you have a code example handy?
11:42:02 <astrolabe> ElPenguin: but it allows IO in a purely functional language.
11:42:15 <glguy> ?type showString
11:42:17 <lambdabot> String -> ShowS
11:43:05 <int-e> http://www.nomaware.com/monads/html/transformers.html at bottom
11:43:10 <lambdabot> Title: Monad transformers, http://tinyurl.com/w6lqr
11:44:09 <glguy> ?type \name -> showString "Hello, " $ showString name  ", how are you?"
11:44:12 <lambdabot> String -> String
11:44:13 <int-e> in this particular example, pure code was changed to impure code by adding an IO monad to the monad stack. the changes are minimal.
11:44:28 <int-e> that's the true power of monads as I see it.
11:46:09 <ElPenguin> sorry, had to pop down for some painkillers
11:48:45 <ElPenguin> i'm not seeing it
11:48:48 <ElPenguin> i just don't get it
11:48:49 <int-e> It should be noted that except for the IO monad there's no magic at all involved in monads. IO is the exception, not the rule.
11:49:12 <Heffalump> IO doesn't have any magic either, it's just special because the RTS executes main which has an IO type
11:49:16 <int-e> In that sense you get no new power from them, but they make many abstractions more convenient to use.
11:49:29 <Heffalump> (or rather, it has no semantic magic. Implementation wise it has some, but then so does ST)
11:50:01 <int-e> If you claim that IO isn't magic you taint the language. Most of the time I prefer to think of the language as pure which makes IO magic.
11:51:10 <int-e> (the magic is done by the RTS in that view, it takes IO values and executes them)
11:51:21 <glguy> when you think of IO as sequencing many actions into one action
11:51:27 <glguy> which the RTS deals with at run-time
11:51:35 <glguy> you don't need the magic
11:52:40 <int-e> Sure, because if there were no magic I should be able to implement my own IO monad without using the existing one ;)
11:53:00 * ElPenguin exits this argument
11:53:42 <Heffalump> int-e: but you could imagine a different RTS that executed a different type of value
11:53:43 <Binkley> int-e, does writing a different RTS count as still implementing it yourself?
11:54:45 <int-e> Not in my restricted silly view.
11:55:23 <Binkley> well, I don't think the RTS is magic, in the sense that it's completely straightforward to swap in your own RTS
11:55:36 <int-e> (I have several views on I/O actually, depending on the context.)
11:55:48 <edwinb> For some suitably defined value of "completely straightforward" ;)
11:55:54 <Binkley> well, yes :-)
11:56:13 <Binkley> however, difficult != magic
11:56:29 <edwinb> indeed
11:56:33 <vincenz> Binkley: sure it is
11:56:35 <vincenz> :P
11:56:39 <int-e> I could argue this endlessly. Let's not do it :)
11:56:41 <edwinb> assuming you happen to have an rts handy...
11:56:42 <Binkley> heh
11:56:44 <Heffalump> I guess viewing magic as "something external", then the RTS is magic.
11:57:00 <Heffalump> and I'm not sure what better definition there is of magic.
11:57:04 <int-e> Heffalump: yes. that's what I meant, I think.
11:57:30 <Binkley> what I mean is that while it might be challenging to write a correctly functioning RTS, once you have one, there's no magic required in order to link your Haskell programs with it.
11:59:26 <Heffalump> Binkley: except that in practical implementation terms, the RTS just hooks implementations of IO primitives into the rest of the implementation
12:01:51 <Binkley> well, it's all calling the same C libraries, if I understand you correctly. that's hardly magic either.
12:02:56 * Heffalump returns to his definition of magic as "external"
12:03:51 <int-e> where "external" = "outside of the little, *pure*, haskell world."
12:08:07 * edwinb goes to the pub to do some side-effecting computations on quantities of liquid
12:10:08 <Heffalump> it might be pure when it goes in, but it won't be when it comes out..
12:10:35 <edwinb> I'll let the garbage collector deal with that
12:11:51 <shapr> hah
12:12:01 <Binkley> well, if everything not haskell is magic, I can accept that definition, but... it's an interesting definition of magic :-)
12:12:21 <Excedrin> I'd like to write a monad that lets me use a Data.Map map as if it's global mutable state, but I'm not sure where to start, could someone provide a simple example?
12:12:35 <Heffalump> Haskell is the natural world, everything else is unnatural. How's that?
12:12:43 <Heffalump> Excedrin: look at Control.Monad.State
12:12:47 <Heffalump> or Control.Monad.ST
12:13:05 <Excedrin> I've looked at it, but I'm not quite getting it
12:13:07 <Binkley> heh
12:13:37 <Binkley> if God wanted us to write imperative code, he would have made time run forwards
12:13:39 <shapr> Hey Heffalump, do you have time to say more about single-threadedness in HAppS?
12:13:39 <kpreid> Excedrin: runState <something> Data.Map.Empty
12:13:46 <kpreid> er, Data.Map.empty
12:13:53 <Heffalump> shapr: for about 5 mins, then gotta go
12:14:15 <Heffalump> Binkley: it's ok, in FSM world time moves in random directions
12:14:24 <shapr> Heffalump: k
12:16:54 <shapr> Hi Kyle, how's code?
12:17:03 <kbrooks> What are the rules that languawges have to abide to to be functional?
12:17:07 <kbrooks> oh hi shapr
12:17:35 <kbrooks> to in order to be*
12:17:45 <shapr> I think that 'functional' isn't very specific. I'd say that you need to be able to have a function as a first class value. "Purely Functional" is much more specific.
12:17:49 <Binkley> kbrooks, I'd say that at the minimum, they have to support first-class functions
12:17:49 <Heffalump> there are no rules, it's just a matter of opinion
12:17:55 <Heffalump> but yeah, first-class functions
12:17:56 <Binkley> however, "functional" doesn't have a precise meaning
12:18:05 <Binkley> it's more a matter of what programming style the language is set up to encourage
12:18:09 <ben> Do function pointers count?
12:18:13 <vegai> it has a focus on functions
12:18:26 <Binkley> ben, not in C. they would count if they allowed functions to have the properties of a first-class object#
12:18:40 <kbrooks> Binkley, meaning?
12:18:40 <shapr> Yeah, the best way to describe a language is by what it makes easy to do. Otherwise you get stuck in the turing tarpit.
12:18:42 <ben> Binkley: What properties are these?
12:18:59 <Binkley> http://en.wikipedia.org/wiki/First-class_object
12:19:02 <lambdabot> http://tinyurl.com/y8jdx7
12:19:04 <kbrooks> hmm. is python functional? (i'll cover purely functional later)
12:19:23 <Binkley> although that list of properties is different from the one I've heard before
12:19:24 <shapr> Python can do functional stuff, but Guido doesn't like that fact :-)
12:19:46 <shapr> Guido dislikes reduce, lambda, map, etc and will likely remove them for Py3k
12:19:47 <kbrooks> shapr, not true
12:19:52 <Binkley> the list of properties I've heard is (1) can be named, (2) can be passed as an argument, (3) can be returned as the result of a procedure, (4) can be stored in a data structure
12:19:59 <kbrooks> shapr, false
12:20:00 <shapr> kbrooks: Ok, tell me more?
12:20:04 <kbrooks> shapr, they are staying
12:20:06 <kpreid> Binkley: that still fits C.
12:20:20 <shapr> kbrooks: Ok, my info is a few months out of date.
12:20:29 <kbrooks> shapr, guido said on his blog that they are not being removed due to no replacements
12:20:35 <Binkley> kpreid: nope. You can't return a *function* as the result of a procedure. You can return a function pointer, but that requirs defining the function statically
12:20:37 <kbrooks> no good*
12:20:42 <shapr> But I am sure that Guido does not like the functional approach. I even talked to him about it.
12:20:54 <kpreid> Binkley: I'd call that "being able to make a function"
12:21:01 <Binkley> be sure to be mindful of the distinction between functions, and names for functions
12:21:19 <kpreid> Binkley: since if you could, you could use it within a function and that would still be something C doesn't do; returning them is natural but irrelevant
12:21:26 <int-e> kbrooks: when? http://www.artima.com/weblogs/viewpost.jsp?thread=98196 talks about adding replacements instead
12:21:28 <lambdabot> Title: The fate of reduce() in Python 3000, http://tinyurl.com/65lfo
12:21:29 <kbrooks> is there some code comparison between python and haskell SOMEWHERE ?
12:21:40 <Binkley> kpreid: it's not equivalent, because the combination of higher-order functions and lexical scope allows you to create a function at runtime whose meaning depends on the enclosing environment
12:21:47 <Binkley> can't do that in C. not easily, at least.
12:21:48 <shapr> kbrooks: Where are you going with this?
12:21:52 <kpreid> Binkley: exactly
12:21:57 <shapr> kbrooks: Both Python and Haskell are languages worth learning.
12:22:07 <kbrooks> shapr, i know python
12:22:08 <kpreid> Binkley: and I say that that's the important thing, *not* being able to return a function
12:22:19 <kpreid> returning a function is also a prerequisite, but C has that
12:22:21 <shapr> kbrooks: I know both Python and Haskell.
12:22:25 <kpreid> you just can only return preexisting functions
12:22:30 <kbrooks> i have a haard time understanding haskell
12:22:33 <Binkley> kpreid: well, if you don't conflate functions with names, then it's the same thing
12:22:51 <shapr> kbrooks: I've been using Python since 1.5 was in beta, and Haskell for 5+ years.
12:22:56 <kpreid> Binkley: OK, I get the distinction you're making.
12:22:59 <shapr> @oldwiki HaskellDemo
12:23:00 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
12:23:06 <shapr> kbrooks: Try that url?
12:23:10 <kbrooks> shapr, ok, you've been using python for less, i assume
12:23:14 <kpreid> Binkley: I don't agree with it being a good way to think about the problem, but I understand it :)
12:23:29 <shapr> kbrooks: No, I've been using Python for many more years than I've been using Haskell.
12:23:30 <Binkley> kpreid: well, I can understand how it might seem a little pedantic to some, but it makes sense to me :-)
12:23:44 <int-e> kbrooks: so did Guido change his mind in the past one and a half years?
12:24:01 <shapr> kbrooks: But Haskell fits the way I think better than Python does. That wasn't always true, but it is now.
12:24:28 <shapr> And I'm sure that Haskell won't always fit me, at some point I'll grow into something else.
12:25:09 <kbrooks> int-e, i dont knoiw. but i did see it as a post. ah well. who cares
12:25:35 <shapr> I suspect that the convergence among Epigram, NuPRL, etc will turn up my next favorite language.
12:25:38 <int-e> I do actually, I was hoping you had a link.
12:26:01 <shapr> kbrooks: Did you look at the HaskellDemo page? What do you think? I have a vested interest because I wrote most of that page :-)
12:26:09 * shapr puts on his vest of interest.
12:26:31 <Binkley> an enigma wrapped in a mystery wrapped in a vest
12:26:46 <sjanssen> oh Nelson Mundts
12:26:50 * shapr takes off his vest and throws it at Binkley 
12:26:58 <pitecus> What does that mean:
12:27:00 <pitecus> Ambiguous type variable `a' in the constraint:
12:27:00 <pitecus>       `Show a'
12:27:00 <pitecus> 	arising from use of `show'
12:27:13 * shapr pokes kbrooks
12:27:27 <shapr> kbrooks: Still there?
12:27:32 <shapr> pitecus: Can you paste the code?
12:27:32 <Binkley> pitecus: what are you trying to apply show to?
12:27:33 <shapr> @paste
12:27:34 <lambdabot> http://paste.lisp.org/new/haskell
12:27:48 <sjanssen> pitecus: maybe you wrote something like "show . read"?
12:28:05 <pitecus> shapr, i cant paste the code its long
12:28:15 <Binkley> pitecus, that's ok. just use the url above
12:28:37 <kbrooks> shapr, I'm loking, and I'd love some tiny code as well, perhaps downloading stuff
12:32:36 <kbrooks> shapr, give some cntext for type signature, like why it is needed
12:34:59 <shapr> kbrooks: What's the result of 1 + 'a' ?
12:35:29 <kbrooks> uh, you cant add a Integer and Char together, can you?
12:35:35 <shapr> kbrooks: Yes, but why?
12:36:06 <kbrooks> shapr, why what?
12:36:16 <shapr> Why can't you add integer and char?
12:37:14 <shapr> kbrooks: What if you did that in Python, would you see an error? If so, when would you see an error?
12:37:17 <kbrooks> because it doesnt make sense. i could ask tou to add two numbers together, and you can. but if i ask you to add a integer and character together, you would say 'how?'
12:37:35 <shapr> kbrooks: That's right, because char is not the same type as int.
12:37:54 <zeeeeeee> hi all, is there an `xor` built-in to haskell anywhere?
12:37:59 <Binkley> kbrooks: can you explain that in terms of what the type of (+) is, though?
12:38:34 <zeeeeeee> er, nvm, found, in Data.Bits
12:39:02 <kbrooks> Binkley, well, + accepts two integers and returns another integer. so, the type of + is
12:39:02 <zeeeeeee> hm, is there an equivalent for booleans?
12:39:03 <shapr> kbrooks: Could you describe the type of the + operator in Python?
12:39:04 <sjanssen> zeeeeeee: that's bitwise xor
12:39:05 <kpreid> @type (+)
12:39:07 <lambdabot> forall a. (Num a) => a -> a -> a
12:39:08 <kbrooks> + :: Integer -> (Integer -> Integer
12:39:11 <kbrooks> )
12:39:16 <zeeeeeee> sjanssen: yeah, my mistake
12:39:19 <sjanssen> > True == False -- this is xor for Bool
12:39:21 <lambdabot>  False
12:39:23 <chessguy> @hoogle Boolean -> Boolean -> Boolean
12:39:24 <lambdabot> No matches, try a more general search
12:39:25 <shapr> kbrooks: Aren't there other flavors of numbers?
12:39:28 <sjanssen> oops
12:39:34 <sjanssen> > True /= False
12:39:36 <lambdabot>  True
12:39:37 <Binkley> kbrooks: right. so that's why you can't add an integer and a char
12:39:43 <chessguy> @type /=
12:39:44 <lambdabot> parse error on input `/='
12:39:56 <profmakx> @type (/=)
12:39:56 <chessguy> @type (/=)
12:39:58 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:39:59 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:40:02 <profmakx> yeah ;)
12:40:03 <Binkley> though it's not quite as simple as you said, since (+)'s arguments have type (Num a) for some a, rather than integer
12:40:03 <zeeeeeee> sjanssen: oh, of course...duh
12:40:05 <chessguy> hmm
12:40:06 <zeeeeeee> sjanssen: thanks
12:40:28 <chessguy> oh, it's Bool and not Boolean
12:40:36 <chessguy> @hoogle Bool -> Bool -> Bool
12:40:37 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
12:40:38 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
12:41:08 <chessguy> @hoogle a -> a -> Bool
12:41:10 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
12:41:10 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
12:41:10 <lambdabot> Prelude.(<=) :: Ord a => a -> a -> Bool
12:41:23 <shapr> kbrooks: A type signature in Haskell is inferred to be as general as possible when not explicitly given. A more specific type signature will generate faster code. For example, (+) handles Int, Float, Complex, and more. For comparison, Starkiller's static compilation for Python produces multiple versions of (+) if it can't figure out that you're only using one of int, float, etc.
12:41:55 <kbrooks> shapr, static compilation for python? link
12:42:06 <shapr> @google starkiller salib
12:42:10 <lambdabot> http://salib.com/writings/thesis/thesis.pdf
12:42:15 <shapr> That's a good thesis.
12:42:26 <shapr> Though I've tried to persuade him to rewrite Starkiller in Haskell =)
12:42:52 <shapr> I like his approach, he's extended the static compilation methods originally used in Sun's Self and later in Sun's HotSpot VM.
12:43:34 <shapr> PyPy is another approach, have you read about that also?
12:43:54 <shapr> I met some of the PyPy guys at EuroPython 2004, they were cool people.
12:44:00 <shapr> they *are* cool people.
12:47:05 * shapr likes teufelsknoten
12:47:57 <shapr> kbrooks: Idle question, how'd you heard about Haskell?
12:49:06 <lisppaste2> zeeeeeee pasted "Help: cleaning up a simple boolean expression evaluator" at http://paste.lisp.org/display/29520
12:49:49 <zeeeeeee> hi all, i wrote a simple boolean expression evaluator. this is a homework, but i've already done it; i'm just seeing how i can improve on it.
12:50:18 <zeeeeeee> any feedback would be greatly appreciated, thanks
12:50:33 <Binkley> zeeeeee: you can probably avoid putting the entire program in the IO monad
12:50:37 <zeeeeeee> (i have a feeling it can be much less verbose...)
12:50:41 <Binkley> it's usually good style to separate our your logic from your IO
12:50:54 <Binkley> oh, I see, you're using the IO-monad hash tables
12:51:02 <Binkley> that's probably not necessary, though
12:51:05 <Binkley> you can use Data.Map instead
12:51:05 <zeeeeeee> Binkley: yeah, i'm not sure how to separate
12:51:20 <zeeeeeee> Binkley: well, the use of the hashtable was in fact a homework requirement
12:51:27 <Binkley> ah
12:51:32 <zeeeeeee> i should probably link to the homework spec
12:51:44 <Binkley> I suppose it's hard to avoid that, then
12:52:05 <lisppaste2> zeeeeeee annotated #29520 with "homework spec" at http://paste.lisp.org/display/29520#1
12:53:32 <Binkley> well, another thing is, your cases for EAnd, EOr, and EXor look quite similar
12:53:38 <Binkley> think about how you could parameterize them
12:53:40 <zeeeeeee> Binkley: this homework is just a step in understanding monads
12:53:48 <zeeeeeee> Binkley: hm
12:53:58 <Binkley> or rather, how you could write a single function that handled all three cases, with appropriate arguments
12:54:20 <Binkley> btw I can't load the URL for the homework spec... is it restricted to MIT only?
12:55:30 <zeeeeeee> Binkley: let me check
12:56:57 <zeeeeeee> Binkley: try http://harvard.csail.mit.edu/~yang/tmp/ps3.pdf
12:57:00 <lambdabot> http://tinyurl.com/y7knch
12:57:25 <lisppaste2> zeeeeeee annotated #29520 with "Alternative homework spec location" at http://paste.lisp.org/display/29520#2
12:57:59 <chessguy> what mit class is that from?
12:58:10 <Binkley> ok, yeah, it looks like having things in the IO monad is OK
12:58:23 <dons> kosmikus: i'll get you a SoC report today
12:58:27 <Binkley> but I think you could still write evalExpr a lot more concisely by thinking about how to factor out the repeated code
12:58:31 <dons> (I forgot!)
12:58:38 <zeeeeeee> chessguy: http://csg.lcs.mit.edu/6.827/ 'implicit parallelism: languages and compilers'
12:59:00 <Binkley> you can also write getExpr using higher-order functions rather than explicit recursion
12:59:32 <chessguy> that looks interesting
12:59:32 <zeeeeeee> Binkley: it's basically doing a 'find'...is there such a HOF?
12:59:56 <kbrooks> HOF?
13:00:05 <zeeeeeee> Binkley: oh! lookup
13:00:05 <chessguy> higher order function
13:00:10 <Binkley> @hoogle [a] -> (a -> Bool) -> Maybe a
13:00:11 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
13:02:44 <zeeeeeee> Binkley: in fact i can completely replace getExpr with lookup
13:02:46 <dons> ?users
13:02:47 <lambdabot> Maximum users seen in #haskell: 265, currently: 254 (95.8%), active: 41 (16.1%)
13:02:50 <dons> ?uptime
13:02:51 <lambdabot> uptime: 1d 20h 59m 37s, longest uptime: 6d 23h 44m 3s
13:03:07 <fourbissime> hi there. noob question of the day : i'm trying to do something quite simple like "floor (a * 1.5)". but a is of type Int, and it seems like haskell doesn't like it.
13:03:20 <fourbissime> i'm probably missing something here
13:03:33 <dons> > let a = 7 in floor (fromIntegral a * 1.5)
13:03:35 <lambdabot>  10
13:04:00 <dons> > let a = 7 in floor (a * 1.23432432)
13:04:02 <lambdabot>  8
13:04:07 <fourbissime> okay
13:04:33 <dons> fromIntegral is used to covert between numeric types
13:04:45 <fourbissime> great. i'm trying
13:04:48 <dons> > let a = 7 :: Int in floor (a * 1.23432432)
13:04:50 <lambdabot>  add an instance declaration for (RealFrac Int)
13:04:50 <lambdabot>   In the definition of `wj...
13:05:00 <dons> > let a = 7 :: Int in floor (fromIntegral a * 1.23432432) -- convert explicitly
13:05:01 <lambdabot>  8
13:05:07 <shapr> kbrooks: A higher order function is one that takes a function as one of its inputs.
13:05:09 <fourbissime> thanks
13:05:28 <dons> shapr: i've got to get you a ref for this new QuickCheck-for-Clean
13:05:49 <dons> it generates random higher order functions by generating a data structure representing that function
13:05:52 <shapr> Is it the test-by-exhaustion?
13:05:57 <dons> as wel as using SmallCheck-style depth iteration
13:06:05 <dons> it is test by exhaustion, yeah
13:06:18 <dons> but is better at printing and generating functions than what we currently have
13:06:28 <shapr> I think I've seen the Clean version before, have you seen the Erlang quickcheck as well?
13:06:36 <shapr> oh that sounds cool, I didn't know that.
13:06:44 <dons> the example was testing a parser combinator library by generating random continuation-based parsers
13:07:07 <shapr> Wow cool, link to paper or docs?
13:07:09 <dons> is the erlang quickcheck by Hughes et al?
13:07:15 <dons> i'll find it today. only saw the talk yesterday
13:07:24 * shapr sees this in #python - <asqui> Is there a handy way to dump the state of my application to a logfile/screen when there's an unexpected exception?
13:07:38 <zeeeeeee> so aside from the refactoring, there's no other (major) improvements i can make to my program?
13:07:43 <shapr> dons: Yes, erlang quickcheck is by Hughes et al.
13:07:44 * dons tries to say "parsher combinatorsh" in a dutch Clean-hacker accent
13:07:49 <zeeeeeee> (the refactoring of the or/and/xor code)
13:07:50 <shapr> hah
13:09:03 <kpreid> hi dons
13:11:15 <SamB> zeeeeeee: well, there is always functionality!
13:11:28 <zeeeeeee> SamB: ?
13:11:42 <zeeeeeee> SamB: is it br0ked?
13:11:45 <SamB> well, thats the only thing besides refactoring I can think of ;-)
13:11:48 <SamB> at ALL
13:11:55 * SamB has not seen zeeeeeee's code 
13:12:08 <zeeeeeee> SamB: i didn't mean refactoring in general
13:12:17 <zeeeeeee> SamB: i meant, aside from the refactoring of the xor/and/or code
13:12:22 <SamB> ah ;-)
13:12:26 <zeeeeeee> SamB: of course, most improvements are all about refactoring
13:12:55 <SamB> @remember zeeeeeee so aside from the refactoring, there's no other (major) improvements i can make to my program?
13:12:56 <Binkley> nitpick: there's no need to write return $ e'
13:13:01 <Binkley> you could write return e'
13:13:48 * SamB wonders how many of the quotes in there are unfairly out of context
13:13:49 <lisppaste2> zeeeeeee annotated #29520 with "Latest version of the code!" at http://paste.lisp.org/display/29520#3
13:13:53 <Binkley> heh
13:13:59 <Binkley> probably most of them
13:14:00 <SamB> @quote zeeeeeee
13:14:02 <lambdabot>  so aside from the refactoring, there's no other (major) improvements i can make to my program?
13:14:30 <zeeeeeee> dah
13:14:39 <chessguy> heh, that's a good one
13:15:12 <scodil> i'm trying to write a generic array manipulation function for all 2D arrays, whats wrong with this type signature: gaussElim :: (MArray a e m, Ix (i,i), Enum i, Fractional e ) => a i e -> ((i,i),(i,i)) -> m ()
13:15:22 <shapr> Refactoring often points me to the next improvement.
13:15:50 <nomeata> Hi. Im wondering, is there a way to redirect stderr to a file?
13:16:00 <dons> kpreid: hey
13:16:23 <nomeata> I want to capture all output somewhere else than stdout, which is lost, as the program is called by a svn hook
13:16:31 <dons> ./a.out 2> /my/file
13:16:36 <dons> ?
13:16:52 <nomeata> and just using a different file handle instead of putStr will not capture haskell error messages
13:17:03 <dons> right. they're going to stderr
13:17:15 <nomeata> well, only the program knows where it wants to put the output :-)
13:17:23 <dons> so you can either redirect stderr on the outside , via the shell, or maybe play with duplication stderr to another handle
13:17:23 <nomeata> in C, I could just reopen stderr
13:17:39 <nomeata> the latter sounds good, but can I do it in haskell?
13:17:45 <dons> i think that a careful call to dup would work
13:17:48 <dons> but not 100%.
13:18:01 <dons> please ask on haskell-cafe@ if you can't get it working. sounds like an interesting problem to solve nicely
13:18:06 <SamB> don't you mean dup2?
13:18:07 <shapr> kbrooks: Any questions about HaskellDemo?
13:18:16 <nomeata> @hoogle dup
13:18:17 <lambdabot> Control.Concurrent.Chan.dupChan :: Chan a -> IO (Chan a)
13:18:17 <lambdabot> Control.Concurrent.STM.TChan.dupTChan :: TChan a -> STM (TChan a)
13:18:17 <lambdabot> Language.Haskell.Syntax.HsFieldUpdate :: HsQName -> HsExp -> HsFieldUpdate
13:18:25 <nomeata> @hoogle dup2
13:18:26 <lambdabot> No matches found
13:18:33 <dons> in System.Posix.Process iirc or System.Posix.Files
13:18:49 <SamB> did they crazily rename it?
13:19:41 <dons> import System.Posix.IO          (createPipe,stdInput,stdError
13:19:41 <dons>                                 ,stdOutput,closeFd,dupTo)
13:19:49 <dons> example in http://www.cse.unsw.edu.au/~dons/code/hmp3/Utils.hs
13:19:51 <lambdabot> http://tinyurl.com/y66pbf
13:20:10 <kpreid> dons: btw, I noticed that "@undo do x $ y; z" produces precedence-wrong output.
13:20:19 <dons> yeah
13:20:29 <dons> well spotted. i've noticed that too
13:21:00 <nomeata> so I hopen a handle and then I use dupTo stdErr handle
13:21:02 <kpreid> such things were on my mind after working on unpl's overcautious parenthesis management
13:21:19 <dons> if you can fix it, that'd rock
13:21:30 <kpreid> I'll put it on my maybe-do list :)
13:21:36 <shapr> y0 CosmicRay, wassup?
13:25:45 <psnl> @karma+ ndm fast code
13:25:46 <lambdabot> ndm's karma raised to 8.
13:26:41 <SamB> @undo doesn't accept full Haskell, either...
13:26:42 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 28}) "Parse error"
13:26:52 <SamB> oh, oops
13:27:15 <SamB> @undo [(x, y) | x <- xs, y <- ys]
13:27:16 <lambdabot> [(x, y) | x <- xs, y <- ys]
13:27:19 <SamB> hmm.
13:27:52 <SamB> @undo [(x, y) | x <- do xs, y <- ys]
13:27:53 <lambdabot> [(x, y) | x <- xs, y <- ys]
13:28:05 <SamB> well, I can't remember what I had trouble with.
13:28:09 <SamB> perhaps it has been fixed anyway...
13:28:48 * SamB thinks perhaps it ought to desugar list-comprehensions too, though
13:29:08 <CosmicRay> hey shapr
13:29:19 <SamB> @pl \xs ys -> [(x, y) | x <- xs, y <- ys]
13:29:20 <lambdabot> (. (return . (y <-))) . (:) . (((x, y) | x) <-)
13:29:24 <CosmicRay> shapr: I fell like returning ENOSLEEP to any request right now ;-)
13:29:35 <SamB> @. unpl pl \xs ys -> [(x, y) | x <- xs, y <- ys]
13:29:36 <lambdabot> compose module failed: IRCRaised Parse error: "unpl"
13:32:51 <shapr> CosmicRay: Or maybe EIRREGULARCHILDSLEEP ?
13:33:11 <CosmicRay> heh
13:33:15 <Taral> SamB: I don't think it understands list comprehensions...
13:33:42 <SamB> what kind of crap parser is it using?
13:34:29 <shapr> CosmicRay: I want to get a user-level Haskell book out there into the world. What's the next step?
13:34:47 <Heffalump> shapr: I'm here for a bit longer now
13:35:10 <ropine> shapr: lulu.com?
13:36:02 <Taral> SamB: It's not the parser. @pl does not do desugaring.
13:36:10 <SamB> oh.
13:36:14 <SamB> @pl
13:36:15 <lambdabot> (line 1, column 1):
13:36:16 <lambdabot> unexpected end of input
13:36:16 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
13:36:28 <SamB> you need to be more specific about what you mean by "it"
13:36:40 <SamB> indeed, that doesn't look good
13:36:59 <Heffalump> @pl 5
13:37:00 <lambdabot> 5
13:37:03 <Taral> @pl do { a <- b; c a }
13:37:04 <lambdabot> (line 1, column 4):
13:37:04 <lambdabot> unexpected "{"
13:37:04 <lambdabot> expecting variable, "(", operator or end of input
13:37:09 <Taral> yeah, no desugaring.
13:37:30 <SamB> but, @pl obviously isn't using a decent parser either...
13:37:38 <Taral> SamB: Entirely possible.
13:37:56 <SamB> if it were, it would not think that | was an operator
13:38:01 <SamB> > x | y
13:38:02 <lambdabot>  Parse error
13:38:08 <SamB> > x <- y
13:38:09 <lambdabot>  Parse error
13:38:15 <Taral> @pl x | y
13:38:16 <lambdabot> x | y
13:38:19 <Taral> Yup.
13:38:24 <Taral> @pl \x y -> x | y
13:38:25 <lambdabot> (|)
13:38:25 <scodil> ?paste
13:38:26 <lambdabot> http://paste.lisp.org/new/haskell
13:41:30 <lisppaste2> nomeata pasted "redirecting error messages" at http://paste.lisp.org/display/29525
13:41:57 <scodil> somebody want to look at the three possible types for this function I've got, and tell me why the most generic won't work. It works in ST and IO, but not for generic Monads and MArrays
13:41:58 <nomeata> dons: thx for the dup tip, its working
13:42:03 <lisppaste2> scodil pasted "abstracting of IO and ST arrays" at http://paste.lisp.org/display/29526
13:42:19 <scodil> that was supposed to be abstracting over...
13:42:21 <scodil> but whatever
13:45:35 <Taral> @pl flip concatMap [0,1] $ \x -> flip map [2,3] $ \y -> (x, y)
13:45:36 <lambdabot> flip map [2, 3] . (,) =<< [0, 1]
13:45:53 <Taral> @pl \xs ys -> flip concatMap xs $ \x -> flip map ys $ \y -> (x, y)
13:45:54 <lambdabot> (. ((. (,)) . flip map)) . (>>=)
13:46:12 <Taral> @pl \xs ys -> concatMap (\x -> map (\y -> (x, y)) ys) xs
13:46:13 <lambdabot> liftM2 (,)
13:46:18 <Taral> *snort*
13:46:50 <Taral> Looks like @pl needs to inline flip during optimization.
13:47:28 <Taral> Is there an @todo or something to put suggestions like that in?
13:48:53 <shapr> @todo
13:48:54 <lambdabot> 0. SamB: A way to get multiple results from a google search
13:48:54 <lambdabot> 1. dons: improve formatting of @dict
13:48:54 <lambdabot> 2. dons: write Haskell Manifesto
13:48:54 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
13:48:54 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
13:48:56 <lambdabot> [19 @more lines]
13:48:59 <shapr> I guess so.
13:49:25 <SamB> except noone ever empties it :-(
13:49:36 <SamB> and nobody ever gets to the bottom, either
13:49:41 <chessguy> haskell manifesto?
14:04:00 <ikegami--> Hello
14:04:51 <ikegami--> I'm very pleased because my Ruby library (not Haskell, but) RushCheck was appeared at the current Haskell weekly news
14:05:03 <ikegami--> The library is similar to QuickCheck in Haskell
14:05:26 <ikegami--> Thanks to the write (maybe dons? I don't know who was notice the library)
14:05:33 <ikegami-->               writer
14:06:34 <ikegami--> I think because QuickCheck is so nice, it should be implemented in another popular languages, such as Java or Python
14:06:43 <Taral> :D
14:06:44 <ndm> it would definately be dons
14:07:04 <ndm> yeah, but hte Haskell type classes + purity makes it more appealing
14:07:08 <ndm> but definately useful everywhere
14:07:12 <ikegami--> even functional testing in Haskell is better than in procedual languages
14:08:16 <ikegami--> ndm: yes, Haskell is the most lovely environment for me
14:08:48 <ikegami--> Ruby is my second good friend :)
14:09:10 * DynWind drowns in the sea of coolness surrounding Haskell
14:09:25 <DynWind> I just discovered Hoogle, that is :)
14:10:26 <ikegami--> DynWind: welcome to Hoogle :)
14:10:43 <DynWind> thanks :D
14:11:03 <ndm> DynWind: good good - its good people find hoogle useful
14:12:06 <SamB> @pl     showList xs = foldr (.) id (map shows xs)
14:12:07 <lambdabot> showList = foldr (.) id . map shows
14:12:28 <DynWind> I haven't started using it or anything, but I can see how damn useful it can be
14:13:49 <ndm> @hoogle Ord a => [a] -> [a]
14:13:50 <lambdabot> List.sort :: Ord a => [a] -> [a]
14:13:50 <lambdabot> Data.Graph.Inductive.Internal.Heap.heapsort :: Ord a => [a] -> [a]
14:13:50 <lambdabot> List.insert :: Ord a => a -> [a] -> [a]
14:13:57 <ndm> you can also use it via lambdabot
14:14:17 <DynWind> cool
14:14:42 <DynWind> I used to write Haskell code about a year ago. A lot of great things seem to have happened since then
14:14:57 <ndm> Hoogle is over a year old, but has improved a lot in teh last year
14:15:18 <ndm> Hoogle 4 (unreleased) is another order of magnitude better than Hoogle 3
14:15:41 <Heffalump> can it cope with generalising from a specific type to a type class yet?
14:15:51 <Heffalump> @hoogle Double -> Int
14:15:52 <lambdabot> No matches, try a more general search
14:15:56 <Heffalump> is the kind of thing I find myself wanting most
14:16:05 <ndm> Heffalump: try the web one, not hte lambdabot version
14:16:40 <ndm> Heffalump: Hoogle 4 does the nicely, there is a specific coerce from a concrete type to a type class it is a member of
14:16:44 <Heffalump> cool, ta
14:17:02 <Heffalump> though it does seem to go a bit overboard, e.g. ignoring the Double
14:17:16 <ndm> Prelude.	exponent	:: RealFloat a => a -> Int
14:17:32 <ndm> Double is a RealFloat, hence that is a pretty good match
14:17:34 <Heffalump> yes
14:17:41 <ndm> (using the web version, the lambdabot version is a bit more strict)
14:17:46 <Heffalump> but findIndex isn't very good
14:17:56 <Heffalump> and Network.Socket.maxListenQueue is just awful
14:17:59 <nomeata> hmm. Im working with utf8-files here, but it seems that hReadContents reads it byteways, destroying the non-ascii-characters
14:18:15 <Heffalump> but hey, it's got the results I wanted on the first page, that's as good as google generally manages
14:18:17 <nomeata> it works fine if I output it like that, but the Char.* functions dont behave correctly
14:18:31 <nomeata> can I tell ghc to treat everything as utf8, and not byte sequences?
14:18:35 <ndm> Double has Ord, but yes, the Map is expensive in reality (but not in Hoogle 3, fixed in Hoogle 4)
14:18:44 <nomeata> (after all, Strings are [Char], not [Byte])
14:18:52 <ndm> Hoogle 4 would fix those things, i am pretty sure
14:19:20 <ndm> all i need to do is finish it...
14:19:30 <Heffalump> what's the topic of your thesis?
14:19:44 <ndm> Catch - pattern match checking for Haskell (nothing to do with Hoogle)
14:19:56 <Heffalump> or to do with yhc, right?
14:20:01 <ndm> proving statically that error will not be called
14:20:14 <ndm> using Yhc.Core as a desugaring of Haskell, yes, but not that tied to Yhc
14:20:43 * Heffalump wonders where you find the time for it :-)
14:20:47 <ndm> Yhc is a side project with some relation, but its not that important to it
14:20:55 * ndm wonders that too sometimes
14:21:09 <ndm> Heffalump: you coming to Fun in the Afternoon?
14:21:19 <Heffalump> no, not enough holiday spare :-(
14:21:45 <kosmikus> dons: thanks
14:21:58 <kosmikus> Heffalump: :(
14:22:00 <ndm> :(, it looks like being interesting
14:22:05 <kosmikus> Heffalump: I'm going ...
14:22:15 <edwinb> I'm off to Fun in the Afternoon. It seems completely crazy to travel all that way for one afternoon, but it will be Fun so I'm going anyway.
14:22:21 <Heffalump> sorry, _really_ not enough holida spare
14:22:39 <ndm> kosmikus, edwinb: see you there :)
14:22:56 <kosmikus> edwinb: you'll be in nottingham next week?
14:23:03 <edwinb> yes, briefly
14:23:08 <kosmikus> nice
14:23:14 <edwinb> I haven't actually worked out what I'm doing
14:23:18 <edwinb> I've booked travel there, but not back again ;)
14:23:24 <kosmikus> heh
14:23:32 <kosmikus> you could just stay, you know
14:23:50 <edwinb> depends how long I can sofa surf...
14:24:58 <ndm> the York people are driving down and back in one day
14:25:21 <edwinb> yes, you're a bit nearer than we are!
14:25:43 <ndm> true, but still 6 hours of driving in one day
14:25:48 <ndm> and Matt is travel sick :)
14:26:08 <edwinb> I think we're just using it as an excuse to go somewhere else for a couple of days
14:26:57 <kosmikus> so it's really more like "Fun in the middle of the week" :)
14:27:44 <edwinb> well, end of the week, but yes.
14:27:51 <edwinb> kosmikus: so are you visiting Nottingham too?
14:28:28 <kosmikus> yes, from Tuesday to Saturday
14:28:50 <edwinb> splendid
14:33:19 <dons> re.
14:35:38 <dons> ?yow
14:35:39 <lambdabot> ... I have read the INSTRUCTIONS ...
14:35:54 <yaxu> hey dons
14:36:07 <dons> hey.
14:38:40 <yaxu> i'm not sure if i should use haskore after all, it does seem quite tied to the midi way of looking at things
14:39:19 <dons> i wonder if tools or some of the data structures can be borrowed. at least, it would be useful to understand the haskore design
14:39:46 <yaxu> oh definitely
14:40:10 <yaxu> i'm sure i'm not using types very well at the moment
14:40:37 <shapr> yaxu: Have you seen the most recent Haskore version?
14:41:54 <shapr> From what I heard, it's changed to more complex datatypes to give better support for non-midi stuff.
14:42:03 <dons> yeah, there was a release in the last month or so
14:42:05 <yaxu> shapr: i'm looking at http://www.haskell.org/haskore/Haskore/Haskore/Docs/tutorial.ps
14:42:09 <lambdabot> http://tinyurl.com/yc32m8
14:42:22 <yaxu> that looks like feb 2000
14:42:25 <yaxu> ok
14:42:25 <shapr> yaxu: What about http://darcs.haskell.org/haskore/ ?
14:42:28 <lambdabot> Title: Index of /haskore
14:42:51 <nomeata> there is no utf8 converting function in the standard library, or cant I just find it?
14:42:54 <yaxu> i'll grab that, thanks
14:43:10 <shapr> yaxu: Ah, check out the Readme, it mentions supercollider and CSound as well.
14:43:40 <yaxu> thanks
14:43:56 <shapr> I think basti_ sent me code to do an audible infinite stream with the new version. I'd asked for lorenz fractal -> audio output.
14:44:31 * shapr never gets around to publishing most of the interesting code he receives...
14:45:24 <pzpz> If had http://paste.lisp.org/display/29529#1
14:45:40 <shapr> yaxu: Do you have a blog where you document your investigations?
14:45:52 <shapr> yaxu: ps. Teff is way cute, more pix!
14:45:57 <yaxu> :)
14:46:10 <yaxu> doc.gold.ac.uk/~ma503am/
14:46:22 <pzpz> i'm trying to use the state monad, and i can't seem to get around this error. i'm trying to accept a connection (Network), however, it complains that it's not the proper type
14:48:55 <SamB> nomeata: there is none
14:49:01 <SamB> there are some floating around
14:49:05 <SamB> one in gtk2hs
14:49:12 <SamB> or, at least, I think there is none...
14:49:27 <yaxu> shapr: publish how?
14:50:02 <shapr> Via my blog(s) or The Monad.Reader
14:50:24 <yaxu> aha, right
14:50:50 <shapr> I have lots of crazy and interesting ideas that run around in my head. Most of them never reach sufficient clarity to describe them on my blog.
14:51:09 <nomeata> SamB: hmm. I must admit, I am a bit disappointed. We can use  in our code, but not in the data the code handles!
14:51:38 <yaxu> shapr: sadly i can't say the same thing about myself
14:52:19 <yaxu> shapr: i have one or two hazy, shapeless entities skulking around in the back of my mind that i spend a lot of time squinting at
14:53:13 <ndm> perhaps Yhc deserves a project report in The Monad Reader...
14:53:15 <yaxu> hopefully learning haskell will afford me a torch/flashlight :)
14:57:59 <nomeata> http://darcs.haskell.org/takusen/Foreign/C/Unicode.hs has unicode conversion functions. should I just steal there or is there better code around?
14:58:04 <lambdabot> http://tinyurl.com/y2v97u
15:01:49 <dons> hey sjanssen
15:02:16 <sjanssen> hello dons
15:06:16 * merus wants _Numerical Recipes in Haskell_ :(
15:08:16 <vincenz> > let 1 + 1 = 3 in 1 + 1
15:08:18 <lambdabot>  3
15:08:41 <sjanssen> > let (1+1) = 3 in 1 + 1
15:08:42 <lambdabot>  Parse error in pattern
15:08:48 <sjanssen> lame
15:09:12 * vincenz pats sjanssen on the back
15:09:25 <vincenz> > let 1 + 1 = 3 in 1 + 2
15:09:27 <lambdabot>  Non-exhaustive patterns in function +
15:09:38 <merus> :O
15:09:44 <sjanssen> stupid haskell-src not supporting n+k
15:10:19 <sjanssen> > let ~1 + ~1 = 3 in 1 + 2 -- any bets on how this will turn out?
15:10:21 <lambdabot>  3
15:10:43 <vincenz> > let ~1 + ~1 = 3 in 2 + 3
15:10:44 <lambdabot>  3
15:10:52 <Heffalump> heh
15:10:57 <merus> how handy
15:10:58 <vincenz> sjanssen: your example was not very demonstrating
15:11:10 <vincenz> 1+2 = 3 no matter which interpretation
15:11:15 <vincenz> what does ~ stand for?
15:11:22 <vincenz> > let _1 + _1 = 3 in 2 + 3
15:11:23 <lambdabot>    Conflicting definitions for `_1'
15:11:24 <lambdabot>   In the definition of `+'
15:11:27 <vincenz> hmm
15:11:29 <vincenz> not a variable
15:11:33 <sjanssen> vincenz: lazy/irrefutable pattern match
15:11:57 <scodil> is there an Unboxable class? So that I can write a function with type :: (Unboxable e) => UArray i e ?
15:12:04 <scodil> or something to that effect
15:12:06 <int-e> > let ~(x@1) + ~1 = x in 2 + 3
15:12:08 <lambdabot>  Irrefutable pattern failed for pattern ((x@1))
15:12:18 <int-e> yay :)
15:12:26 <sjanssen> scodil: no unboxable class
15:12:33 <vincenz> > let int-e = 3 in 1 - 4
15:12:35 <lambdabot>  3
15:12:48 <vincenz> :P
15:12:52 <int-e> note: x@(~1) and ~(x@1) mean different things.
15:12:52 <Heffalump> "Irrefutable" always makes me think they should be stricter
15:12:56 <Heffalump> when actually they are laier
15:13:05 <scodil> so if you want to use unboxed arrays it can't be polymorphic in the array type, then?
15:13:05 <Heffalump> s/laier/lazier/
15:13:22 <Heffalump> scodil: YM the element type?
15:13:26 <scodil> yeah
15:13:30 <scodil> thats what i meant
15:13:44 <Heffalump> I don't think that could work
15:13:45 <sjanssen> scodil: you can probably write "type :: (IArray UArray e) => UArray i e"
15:14:09 <Heffalump> the dictionary for Unboxed would have to contain all the array operations
15:14:22 <Heffalump> at which point you might as well do what sjanssen suggests
15:14:28 <scodil> ok i'll try that
15:14:57 <vincenz> shapr is on skype
15:21:38 <shapr> vincenz: ?
15:22:05 <vincenz> you're on skype
15:23:38 <SamB> hmm, I wonder what is wrong with nofib/nofib-analyse...
15:30:11 <ndm> SamB, you still working on GHC's inliner...
15:30:23 <Excedrin> I still haven't figured out how to use the state monad with Data.Map, if anyone could provide a trivial example (from Data.Map.empty, insert, insert, delete, etc), I'd appreciate it
15:30:50 <syntaxfree> there should be specific extensions to the type system that allow a program to enforce laws on type constructors.
15:30:56 <syntaxfree> (Like functor laws, monad laws, etc.)
15:31:13 <ndm> syntaxfree: why extensions to the type system? why not separate property assertions?
15:31:38 <syntaxfree> maybe.
15:32:00 * ndm is worried one day that all computation will be done in the type level, with the kind providing types for types
15:32:39 <syntaxfree> and then Oleg will focus on kind hackery.
15:33:22 <syntaxfree> how do you enforce a strict data type again?
15:33:32 <ndm> yes, and real programmers will use something that still has data values!
15:34:08 <syntaxfree> Real programmers won't use meta-kind hackery.
15:34:22 <syntaxfree> Real programmers will use newtypes and functions over type spaces.
15:34:47 <ndm> no, real programmers will then go back to using Java...
15:35:12 <syntaxfree> or C++.
15:35:14 <dcoutts> quitter programmers!
15:35:21 <SamB> ndm: if that happens, types and kinds will be indistinguishible from values and types today...
15:35:23 <ndm> real programmers manipulate real values, perhaps with types to guide them, but not to rule over them
15:35:39 <SamB> what are these "real programmers"?
15:35:42 <ndm> SamB, true - but the syntax will be uglier
15:35:52 <ndm> SamB, real programmers produce real code that does real stuff
15:35:54 <SamB> ndm: how so?
15:35:58 <syntaxfree> SamB we can't see beyond the meta-meta-meta-meta-...-meta-kind singularity. That's the whole point of a singularity.
15:36:10 <SamB> how will it be uglier?
15:36:23 <ndm> SamB, because values will still exist, they'll just all be "undefined"
15:36:35 <syntaxfree> @google real programmers don't
15:36:38 <SamB> oh, that would be stupid
15:36:39 <lambdabot> http://www.pbm.com/~lindahl/real.programmers.html
15:36:40 <lambdabot> Title: Real Programmers Don't Use Pascal
15:36:45 <SamB> you can't do that in epigram can you?
15:36:47 <syntaxfree> @google the story of mel
15:36:49 <lambdabot> http://www.pbm.com/~lindahl/mel.html
15:36:50 <lambdabot> Title: The story of Mel
15:36:59 <SamB> mel didn't use values, silly!
15:37:09 <SamB> he used drums!
15:37:14 <dolio> You need a monad for undefined in epigram, don't you?
15:37:39 <dolio> Or, that's their idea, I guess.
15:37:49 <dolio> It still has general recursion right now if you want it.
15:38:49 <SamB> anyway, what is the difference in epigram between a type and a value?
15:39:42 <sjanssen_> @paste
15:39:43 <lambdabot> http://paste.lisp.org/new/haskell
15:39:43 <syntaxfree> epigram is a programming language?
15:39:54 <syntaxfree> SamB: so are computers a series of drums?
15:40:03 <syntaxfree> do those drums get clogged?
15:40:24 <lisppaste2> sjanssen pasted "like this, Excedrin?" at http://paste.lisp.org/display/29531
15:40:26 <SamB_XP> there was probably one or two drums?
15:40:34 * SamB_XP hasn't read the story of mel in a while
15:40:40 <dolio> http://www.e-pig.org/
15:40:44 <lambdabot> Title: Epigram
15:41:24 <psnl> SamB_XP: was it you asking about epigram?
15:41:40 <SamB_XP> psnl: asking which?
15:41:50 <SamB_XP> I asked the difference between values and types
15:41:58 <psnl> SamB_XP: yeah, that was it
15:42:12 <syntaxfree> oh. Epigram supports dependent types out of the box.
15:42:18 <syntaxfree> I've been wanting those forever.
15:42:41 <syntaxfree> is it related to Haskell somehow?
15:42:52 <SamB_XP> um
15:42:53 <SamB_XP> types?
15:42:55 <SamB_XP> hello?
15:43:03 <psnl> SamB_XP: off the top of my head, a type has a provably computatable value and a value doesn't. plus all the normal differences between types and values.....
15:43:19 <syntaxfree> haha.
15:43:26 <syntaxfree> so what is Epigram concretely?
15:43:29 <pkhuong-> psnl: not if you restrict to a strongly terminating language
15:43:31 <SamB_XP> psnl: "normal differences"?
15:43:32 <pkhuong-> *yourself
15:43:37 <syntaxfree> An entirely different programming language with dedicated compilers and all?
15:43:48 <syntaxfree> Or an extension to Haskell like O'Haskell, Concurrent Haskell and so on?
15:43:50 <pkhuong-> syntaxfree: http://www.e-pig.org
15:43:53 <lambdabot> Title: Epigram
15:43:57 <SamB_XP> syntaxfree: entirely different
15:44:04 <SamB_XP> but don't go using the plural
15:44:20 <dolio> Epigram is a language of its own.
15:44:38 <SamB_XP> that is, it only has one implementation afaik...
15:44:50 <syntaxfree> well, to the date.
15:45:02 <ndm> you can look at DML and Cayene as well
15:45:13 <SamB_XP> I wouldn't bother with the latter
15:45:20 <SamB_XP> well, I did try to get it to compile
15:45:22 <ndm> why?
15:45:24 <SamB_XP> but was not very successful...
15:45:37 <ndm> Lennart does Cayene, and is sometimes in here
15:45:45 <psnl> SamB_XP: pkhuong- is right, a type is computed at compile time and a value at run time
15:45:51 <ndm> (or rather did, i'm not sure he does any more)
15:46:12 <SamB_XP> I was under the impression that that had been abandoned?
15:46:18 <SamB_XP> and used some wierd compiler to boot?
15:46:22 <ndm> it uses GHC
15:46:34 <ndm> it used to use LML, lazy ML, based on hbc, but not any more
15:46:46 <SamB_XP> uh
15:46:59 <ndm> hbc used to be the main haskell compiler, before GHC was
15:46:59 <SamB_XP> wasn't hbc based on the lazy ML compiler, not the other way round?
15:47:02 <ndm> yes
15:47:20 <SamB_XP> you just said it in a way that sounded backwards
15:47:22 <ndm> (but my fingers had already typed LML and i was too lazy to go back and edit that bit of the line)
15:47:28 <SamB_XP> oh
15:47:44 <ndm> just me being lazy :)
15:47:56 <SamB_XP> anyway, are you *sure* you aren't talking about Agda?
15:48:07 <ndm> pretty sure
15:48:19 <ndm> @google Lennart Cayenne
15:48:23 <lambdabot> http://portal.acm.org/citation.cfm?id=289451&coll=portal&dl=ACM
15:48:43 <syntaxfree> ndm: I've seen Lennart's name in some research paper.
15:49:11 <SamB_XP> apparantly google has seen it in association with one, too
15:49:13 <ndm> syntaxfree: its in _loads_ of research papers - the initial work in compiling pattern matches to case expressions, for example
15:49:20 <syntaxfree> oh.
15:49:28 <SamB_XP> he must be ancient!
15:49:43 <syntaxfree> The recurring names in research papers I've seen are Meijer, Jones, Hudak, Wadler and Peyton-Jones.
15:49:52 <syntaxfree> ah, and Hughes.
15:50:03 <SamB_XP> I was just going to mention Hughes
15:50:21 <ndm> Lennart pops up in quite a few
15:50:24 * syntaxfree has two Hughes papers in his collection.
15:50:32 <ndm> but those are more prolific
15:50:49 * ndm has at least 20 SPJ papers in his collection
15:51:14 * psnl just has a desk covered in paper
15:51:14 <SamB_XP> ndm: that isn't particularly impressive, unless you actually got them on paper, from a publisher!
15:51:18 <ndm> not so much Meijer or Hudack, but plenty of the other three
15:51:28 <ndm> SamB_XP: from his website :)
15:51:46 <psnl> I resisted buying the Haskell 98 report on paper when I was in Cambridge
15:51:48 <SamB_XP> ndm: I mean, not impressive on *your* account
15:51:52 <syntaxfree> Half of the Meijer I've got is deep theory, and half is software engineering-type stuff.
15:51:58 <SamB_XP> it is rather impressive that he did so many
15:52:01 <ndm> SamB_XP: we have a complete archive of Journal of Functional Programming behind my desk, which is quite impressive
15:52:09 <SamB_XP> wow!
15:52:15 <psnl> ndm: nice
15:52:18 <SamB_XP> how do you get those!
15:52:20 <ndm> i tried to track down SPJ's thesis, but it apppears he never did one
15:52:24 <syntaxfree> btw, "Bananas in space" is so much more readable than "Functional programming with bananas, etc.". Maybe because I've read the latter before
15:52:27 <ndm> our uni has 2 subscriptions
15:52:48 <SamB_XP> just... wow!
15:52:50 <ndm> one for Colin, one for our group
15:52:55 <psnl> ndm: nice effort
15:52:57 <syntaxfree> FP people tend to upload their papers to their websites.
15:53:01 <syntaxfree> Economists often do not.
15:53:08 <psnl> ndm: one for the main lib as well?
15:53:11 <ndm> syntaxfree: everyone but Colin Runciman
15:53:16 <ndm> psnl: no, just 2 for our group
15:53:37 <SamB_XP> ndm: does the library know this, at least?
15:53:39 <ndm> syntaxfree: the only paper i've ever had to go get in real paper form!
15:53:39 * syntaxfree is such a nerd.
15:54:01 <syntaxfree> I'm often screwed up as for research papers in economics.
15:54:11 <ndm> SamB_XP: i have no idea, certainly the uni librarians have no idea - i doubt hte department ones do either
15:54:22 <psnl> there is normally a pile of jfps in the compsci journals section of the library here
15:54:23 <ndm> SamB_XP: they are our group's own copies, for our use only :)
15:54:24 <SamB_XP> ndm: you ought to tell them
15:54:25 <syntaxfree> Of course, I'm now screwed up because I've been spending so much time in FP, I'm completely lost about my thesis.
15:54:41 <SamB_XP> ndm: you surely wouldn't refuse to let someone look at them!
15:54:46 <SamB_XP> you are not mean, you know!
15:54:54 <ndm> SamB_XP: the number of FP programmers outside the research group is pretty limited... - but yes, we'd surely share if anyone else wanted
15:55:07 <psnl> ndm: no undergrads?
15:55:16 <syntaxfree> fp PR
15:55:25 <syntaxfree> fp programmers ls like ATM machines.
15:55:39 <ndm> psnl: the uni has an electronic subscription for everything, undergrads tend to just use that
15:55:51 <SamB_XP> syntaxfree: they all use the same password?
15:55:52 <syntaxfree> Also, it's often with research journals laying around in main libraries that undergrads find out about exotic fields.
15:56:13 <psnl> ndm: sorta, I'm a fan of leafing though the journal stack
15:56:28 * psnl shrugs
15:56:32 <SamB_XP> yeah, I'd do it too
15:56:50 <ndm> psnl: i perfer that with conference proceedings, rather than journals - they tend to be a bit lighter for casual reading
15:57:49 <psnl> that being said, I'm being lazy with the library right now
15:58:05 <psnl> I was going to stand on them until they got SPJ's books
15:58:16 <syntaxfree> ndm: is there a "review" journal in FP?
15:58:28 <syntaxfree> Economics has the Journal of Economic Perspectives.
15:58:47 <syntaxfree> It's somewhat accessible even to people with multivariate calculus, intermediate statistics and econ 101.
15:59:14 <syntaxfree> (whereas you'd be lost staring at the Journal of Economic Theory, even more at loss than I was when first encountering the Bananas paper)
15:59:21 <SamB_XP> so what would the FP equivalent of that be?
15:59:31 <syntaxfree> that's what I'm asking :)
15:59:32 <ndm> syntaxfree: not that i know off
15:59:48 <SamB_XP> lambda calculus, lambda calculus, and more lambda calculus?
16:00:13 <syntaxfree> I know less lambda calculus than I should, but I'm getting by reading some type theory.
16:00:22 <syntaxfree> Maybe because I have some assorted bits of cat theory as well.
16:00:39 <SamB_XP> man, there is no such thing as cat theory
16:00:44 <SamB_XP> nobody understands cats!
16:01:02 <syntaxfree> @google helurophilia
16:01:04 <lambdabot> No Result Found.
16:01:21 <ndm> @users
16:01:22 <lambdabot> Maximum users seen in #haskell: 265, currently: 249 (94.0%), active: 39 (15.7%)
16:01:33 <syntaxfree> @google ailurophilia
16:01:36 <lambdabot> http://l.webring.com/hub?ring=ailurophilia
16:01:36 <lambdabot> Title: Ailurophilia--For the Love of Cats
16:01:49 <syntaxfree> @google ailurology
16:01:53 <lambdabot> http://answerpool.com/eve/forums/a/tpc/f/172603602/m/4296098331
16:01:53 <lambdabot> Title: Study of the cats - Topic :
16:01:55 <syntaxfree> there you are!
16:02:09 <psnl> right, should I a) sober up, do some work, and ignore lectures in the morning or b) sleep, go to lectures, do it later or c) something else?
16:02:41 <merus> a)
16:03:16 <syntaxfree> psnl: should I a) sober up, not think about programming for the next 18 months and focusing on getting my thesis done, b) keep on watching lectures and slacking off, learning FP instead or c) drop out and spend all my time in FP theory?
16:04:07 <merus> C)!
16:04:21 <SamB_XP> what time will you have if you drop out?
16:04:27 <psnl> syntaxfree: what area is your thesis on?
16:04:40 <syntaxfree> SamB_XP: I'll probably need to get a job.
16:04:45 <syntaxfree> psnl: Optimal insurance contracts.
16:04:49 <SamB_XP> syntaxfree: exactly!
16:05:04 <psnl> syntaxfree: holy crap, thats a vote for b
16:05:08 <SamB_XP> syntaxfree: you should write an EDSL to calculate them
16:05:13 <syntaxfree> SamB_XP: not that I have stipends or anything.
16:05:22 <syntaxfree> SamB_XP: I'd need a full CAS first.
16:05:57 <syntaxfree> The "contracts" in optimal contracts are something entirely different from the financial "contracts" Simon Peyton-Jones has done some work with.
16:05:59 <SamB_XP> surely not! surely you'd only need *half* of one
16:06:10 <SamB_XP> syntaxfree: oh, he really did that?
16:06:14 <syntaxfree> "contracts" here is far more general.
16:06:16 <syntaxfree> yes.
16:06:30 * SamB_XP had some trouble seperating fact and fiction
16:06:31 <syntaxfree> Everytime I mention my research here people think of financial derivatives and whatnot.
16:06:34 <SamB_XP> @joke enron
16:06:35 <lambdabot> Maybe you meant: join more vote
16:06:37 <syntaxfree> The kind of stuff SPJ worked with.
16:06:43 <syntaxfree> @google peyton-jones contracts
16:06:44 <SamB_XP> @google haskell enron
16:06:46 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/financial-contracts/contracts-icfp.htm
16:06:46 <lambdabot> Title: Simon Peyton Jones: papers
16:06:48 <lambdabot> http://www.mirrorservice.org/sites/www.haskell.org/humor/enron.html
16:06:48 <lambdabot> Title: Haskell Fingers Enron
16:07:05 <syntaxfree> the joke reflects the fact that SPJ wrote an EDSL to calculate financial derivative contracts.
16:07:18 <syntaxfree> Which is not, at all, what I'm supposed to be working with.
16:07:34 <gzl> that paper was actually interesting.
16:07:58 <gzl> the derivatives one.
16:08:18 <scodil> if i'm writing an ST function to manipulate an array in place, does that function have to return said STArray? or can it just return (). I'm having the damnedest time getting this to typecheck
16:08:31 <syntaxfree> anyway, regarding option B)...
16:08:38 <syntaxfree> It's not like I have a stipend or anything.
16:08:38 <SamB_XP> @type runSTArray
16:08:40 <lambdabot> Not in scope: `runSTArray'
16:08:44 <SamB_XP> @type runSTUArray
16:08:47 <lambdabot> Not in scope: `runSTUArray'
16:08:53 <SamB_XP> @hoogle STArray
16:08:54 <lambdabot> Data.Array.ST.STArray :: data STArray s i e
16:08:55 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
16:08:57 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
16:09:00 <syntaxfree> Option B basically means keep on getting an allowance from my parents till I get kicked out from grad school.
16:09:01 <SamB_XP> @hoogle runSTArray
16:09:03 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
16:09:15 <syntaxfree> *unless* I manage to sober up and work exclusively on economics for a while.
16:09:34 * psnl takes one look at hatobserve, then one look at his bit of php, and decides to sleep on it
16:09:54 <SamB_XP> please tell me you are sleeping on the hat!
16:10:01 <SamB_XP> the php is probably very dangerous
16:10:14 <syntaxfree> php passes of functions as strings. it's hilarious.
16:10:15 <psnl> sleeping on a hat would be hard
16:10:26 <scodil> yeah i know the type.  but the function which is the argument to runSTArray, it first creates and array, then manipulates it, then returns it. can it go like " a <- newArray; muckWithArray a; return a" or does it have to be " newArray >>= muckWithArray >>= return "
16:10:29 <SamB_XP> depends on what kind of hat it is
16:11:14 <SamB_XP> the difference being?
16:11:21 <SamB_XP> scodil: the difference is what?
16:11:46 <psnl> SamB_XP: I don't even think I could sleep on a big hat
16:11:52 <scodil> in the former, muckWithArray has type ST s (), whereas the latter has type ST s ( STArray.. )
16:12:10 <scodil> i wouldn't think it made a difference. but I don't understand ST very well
16:12:15 <scodil> and its causing me problems
16:12:16 <SamB_XP> psnl: I was thinking that some kinds of hats are so soft and thin you might not even feel them
16:13:19 <SamB_XP> well, you need to return the array...
16:13:38 <SamB_XP> otherwise how is it going to be unsafeFreeze 'd?
16:13:58 <scodil> yeah, the last part is return a in both cases
16:14:31 <scodil> but in the middle, it takes a and returns ()... does that cause probablems with the threading-of-the-phantom-variable and all that? cause STArrays are parameterized on the s
16:15:14 <SamB_XP> I don't think so
16:23:44 <scodil> what does it mean when it says : Inferred type is less polymorphic than expected
16:24:51 <mauke> some kind of type error
16:25:07 <sjanssen_> scodil: you probably gave an incorrect explicit type signature
16:25:24 <sjanssen_> alternately, your code is wrong and you signature is correct
16:34:04 <syntaxfree> type errors are there so you don't make mistakes.
16:34:15 <syntaxfree> it's annoying until it stops being so.
16:35:41 <qwr> fromMaybe_ _ (Just x) = return x
16:35:41 <qwr> fromMaybe_ x Nothing = x
16:35:56 <qwr> is there something like that in somewhere in the standard libraries?
16:36:39 <emu> @hoogle a -> Maybe a -> a
16:36:41 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
16:36:42 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
16:36:52 <emu> @hoogle a -> Maybe a -> M a
16:36:53 <lambdabot> No matches, try a more general search
16:37:06 <emu> @type mapM
16:37:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
16:37:34 <emu> @hoogle forall (m :: * -> *) a. (Monad m) => a -> m a -> M a
16:37:35 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) a.'
16:37:37 <emu> @hoogle forall (m :: * -> *) a. (Monad m) => a -> m a -> m a
16:37:38 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) a.'
16:37:47 <emu> @hoogle (Monad m) => a -> m a -> m a
16:37:48 <lambdabot> Prelude.asTypeOf :: a -> a -> a
16:37:49 <lambdabot> Prelude.const :: a -> b -> a
16:37:49 <lambdabot> Prelude.seq :: a -> b -> b
16:39:04 <scodil> makeSTArray = runSTUArray ( newListArray (1,5) (take 5 $ repeat 12)  )
16:39:14 <scodil>  No instance for (MArray (STUArray s) a (ST s))
16:39:20 <scodil> arising from use of `newListArray'
16:39:23 <scodil> whats up with that?
16:39:29 <qwr> @hoogle (Monad m) => m a -> Maybe a -> m a
16:39:31 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
16:39:31 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
16:39:36 <sjanssen_> @hoogle runSTUArray
16:39:37 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
16:39:50 <sjanssen_> @hoogle newListArray
16:39:51 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
16:40:19 <emu> @type liftM (fromMaybe)
16:40:21 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (Maybe a1 -> a1)
16:40:34 <emu> @type \x -> liftM (fromMaybe x)
16:40:36 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m (Maybe a) -> m a
16:40:40 <ski> @type (`maybe` id)
16:40:42 <lambdabot> forall a. a -> Maybe a -> a
16:41:08 <sjanssen_> scodil: you probably need to give some more type declarations
16:44:55 <scodil> where? I've tried putting the MArray qualifier everywhere and it always says "No instance for MArray..."
16:45:23 <scodil> like this for instance:
16:45:25 <scodil> newListUArray :: (MArray (STUArray s) e (ST s)) => (Int,Int) -> [e] -> ST s (STUArray s Int e)
16:45:26 <qwr> hmm, maybe blaah return a does the thing
16:45:31 <scodil> newListUArray = newListArray
16:47:07 <scodil> if I annotate everything eventually it complains that it can't match rigid variables s and s1 arising from the two difference declarations
16:47:15 <scodil> as in ST s and ST s1
16:47:35 <scodil> two different declarations, i meant to say
16:49:26 <sjanssen_> scodil: this works: makeSTArray :: UArray Int Int; makeSTArray = runSTUArray ( newListArray (1,5) (take 5 $ repeat 12)  )
16:50:10 <scodil> ok now make that polymorphic in the array element type
16:50:41 <shapr> kbrooks: Hey, any thoughts on Haskell or the code you've seen so far?
16:50:53 <SamB_XP> scodil: you can't do that...
16:50:57 <scodil> why not?
16:51:03 <SamB_XP> that damn forall!
16:51:21 <SamB_XP> this is why I would typically resort to unsafePerformIO
16:51:33 <sjanssen_> ah, SamB_XP might have a point here
16:51:51 <scodil> I don't follow
16:52:07 <SamB_XP> try it, then
16:52:14 <scodil> i have been for hours
16:52:18 <sjanssen_> @type Data.Array.ST.runSTUArray
16:52:20 <lambdabot> forall e i. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
16:52:21 <SamB_XP> and see the nasty error you get when you try to runSTUArray it...
16:52:52 <scodil> but what does it all mean ?!
16:53:48 <SamB_XP> it means that the compiler has to know that that will work regardless of the value of "s"...
16:54:14 <SamB_XP> which it can't, unless it can pick a particular instance
16:54:45 <SamB_XP> @instances-importing Data.Array.Base MArray
16:54:47 <lambdabot> STUArray s) Bool (ST s, STUArray s) Char (ST s, STUArray s) Double (ST s, STUArray s) Float (ST s, STUArray s) Int (ST s
16:55:05 <SamB_XP> hmm, needs work...
16:55:56 <scodil> why can't it just want until its instantiated with a bad type? like c++ templates? whats the harm in that?
16:56:02 <scodil> want -> wait
16:56:11 <SamB_XP> I don't know :-(
16:56:29 <SamB_XP> probably because it can't represent that in the type?
16:56:33 <scodil> weak. who do I write a letter to to get an Unboxable type
16:56:36 <scodil> er, class
16:56:39 <scodil> Unboxable class
16:56:51 <SamB_XP> um, I'm not sure what you mean exactly
16:57:09 <sjanssen_> scodil: check out Bulat Ziganshin's array library
16:57:12 <SamB_XP> but you could try ghc-users or the bugtracker...
16:57:16 <sjanssen_> it's called NewArray, or something like that
16:57:19 <scodil> so I can abstract over Double, Float, Int and still use UArrays
16:57:34 <SamB_XP> well, I just use IO
16:57:46 <SamB_XP> because with IO you don't have to deal with those pesky foralls
16:57:47 <scodil> well, i just use c
16:57:54 <scodil> cause in c...
16:57:59 <edwinb> \
16:58:14 <sjanssen_> because in C, you can't write polymorphic code at all?
16:58:17 <SamB_XP> well, IOUArrays are about the same as STUArrays
16:58:18 <sjanssen_> modulo void*
16:58:30 <SamB_XP> except for the foralls
16:58:38 <SamB_XP> and the use of the IO monad
16:58:49 <scodil> and unsafePerformIO i suppose
16:58:50 <dcoutts> ST is good for you, if you can make it fit
16:58:58 <dcoutts> since it's pure etc
16:59:06 <SamB_XP> yeah, but the typesystem is weak :-(.
16:59:22 <sjanssen_> I think it's the MArray system that's at fault here
16:59:33 <SamB_XP> in terms of proof power, I mean. not in terms of...
16:59:36 <SamB_XP> sjanssen_: oh please!
16:59:45 <SamB_XP> what would you suggest?
17:00:07 <sjanssen_> SamB_XP: a proper Unboxable class would be a good start
17:00:15 <scodil> wait so would this work with STArrays then?
17:00:20 <scodil> I still see a forall in runSTArray
17:00:28 <dcoutts> sjanssen_, it's not just a class problem, how do you represent it ?
17:00:31 <sjanssen_> it might
17:00:34 <SamB_XP> well, I think so... because it can resolve the instance
17:00:39 <dcoutts> what is an unboxed array of (Int, Int) for example ?
17:00:41 <SamB_XP> sjanssen_: I suppose
17:00:42 <musasabi_> AT might help.
17:00:45 <SamB_XP> but how would it work?
17:00:51 <sjanssen_> musasabi_: yes, I think it would
17:00:57 <SamB_XP> I mean, what would it look like?
17:00:57 <sjanssen_> fundeps might even be sufficient
17:01:29 <dcoutts> my complaint with MArray is that all instances must be polymorphic in the index type. So you can't have bitmaps as MArray instances.
17:01:46 <SamB_XP> dcoutts: what kind of bitmaps?
17:01:47 <sjanssen_> I'd start with "class MArray a e m | a -> e m
17:01:57 <dcoutts> SamB_XP, I mean 2D bitmap images
17:02:04 <SamB_XP> dcoutts: ah.
17:02:25 <dcoutts> since a 2D bitmap image type really can only work with Int, Int indexes
17:02:29 <sjanssen_> actually, I'd stick the index type in there too
17:02:38 <dcoutts> sjanssen_, exactly!
17:02:48 <dcoutts> then I can make an instance just for (Int, Int)
17:05:48 <sjanssen_> is it really impossible to write polymorphic code with runSTUArray?
17:06:33 <sjanssen_> @hoogle unsafeFreeze
17:06:34 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
17:06:57 <sjanssen_> scodil: I think that function will save you
17:09:48 <chessguy> wow, that's a messy type signature
17:10:22 <SamB_XP> sjanssen_: you need to use that with the unsafePerformIO too...
17:10:32 <SamB_XP> and runSTUArray also uses that
17:10:39 <SamB_XP> but... how does that help?
17:11:03 <sjanssen_> SamB_XP: I don't think it does
17:11:14 <sjanssen_> this is really dumb
17:17:32 <dons> ?users
17:17:34 <lambdabot> Maximum users seen in #haskell: 265, currently: 239 (90.2%), active: 29 (12.1%)
17:19:59 <fnord123> hi all
17:20:07 <dons> hey fnord123
17:20:24 <fnord123> hi dons.
17:20:41 <dons> how's the haskell hacking?
17:20:49 <fnord123> mu
17:21:06 <dons> mu?
17:21:09 <fnord123> there's no oz channel... I was curious if anyone here ever touched it.
17:21:24 <dons> pretty small user base, I guess?
17:21:25 <fnord123> http://en.wikipedia.org/wiki/Mu_(negative)
17:21:29 <dons> :)
17:21:38 <Excedrin> I have, Oz is interesting
17:21:51 <shapr> Yeah, Oz is neat.
17:22:21 <shapr> It feels halfway between Erlang and Haskell to me.
17:22:50 <fnord123> a friend of mine wrote a paper on a small constrains based language he made. and he compares solutions in his language with those in Oz
17:22:52 <shapr> (I've only used it a tiny bit though, other opinions?)
17:23:18 <fnord123> he has one bit where he says Oz was unable to solve a problem in an acceptable time when his language took only 4 seconds...
17:23:42 <shapr> What was the problem?
17:23:49 <fnord123> obviously i think this is a bug so I'm trying to correct it; but I dont have his code and I'm having trouble with the Search module
17:23:56 <fnord123> subset sum of 40 numbers
17:23:57 <shapr> And how does his language handle constraint solving differently?
17:24:43 <vincenz> shapr: very carefully :)
17:24:48 <fnord123> his language is based on ROBDDs http://www.nist.gov/dads/HTML/reducedOrderedBDD.html
17:24:51 <lambdabot> Title: reduced ordered binary decision diagram, http://tinyurl.com/nsf8m
17:25:25 <vincenz> so it's specifically targetted towards binary decisions :)
17:25:32 <fnord123> no
17:25:43 <sjanssen_> how does one turn a MutableByteArray# into a ByteArray#?
17:25:57 <fnord123> afaics, Oz uses these in the constraints. but he seems to think his is the first language to be based on these concepts
17:26:05 <fnord123> its a neat little paper. i like it.
17:26:17 <araujo> hello
17:26:52 <heatsink> wow, I've never been able to stop a conversation by saying hello.
17:27:08 <heatsink> ;)
17:27:21 <araujo> heatsink, a power only a few chosen one have
17:27:53 <chessguy> araujo :)
17:27:59 <dcoutts> sjanssen_, first turn it into a ForeignPtr
17:28:05 <shapr> fnord123: Which paper?
17:28:15 <fnord123> the one my friend wrote.
17:28:48 <shapr> Is it online?
17:29:42 <sjanssen_> dcoutts: next question . . . how do I do that? ;)
17:29:52 <fnord123> shapr: no
17:30:17 <dcoutts> sjanssen_, well you can cheat and do it directly by importing the constructors from GHC.ForeignPtr
17:32:28 <shapr> fnord123: Why not? If it's interesting I want to read it!
17:33:16 <fnord123> he's submitted it to some conference. im not sure on how these things work as im not an academic, so I don't want to spread the paper and find out I disqualified him from presenting it.
17:36:07 <shapr> ok
17:57:59 <scodil>  Not in scope: `--::'
17:58:07 <scodil> whats that all about
17:58:16 <vincenz> scodil: yeah, make sure that your comment is not attached to any other symbols
17:58:28 <mauke> insert space after --
18:01:07 <scodil> so i don't know if the people from earlier are still around, but is the consensus that you cannot use runSTArray in a function which is polymorphic in the array element type?
18:05:34 <sjanssen_> scodil: so it seems
18:06:23 <scodil> there's a reason for this?
18:06:36 <scodil> because of the unsafeFreeze or something?
18:06:42 <sjanssen_> yes, but it's a bit tricky to explain
18:06:49 <sjanssen_> @hoogle runSTUArray
18:06:50 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
18:07:04 <sjanssen_> bleh, that isn't the actual type signature
18:07:10 <sjanssen_> @type Data.Array.ST.runSTUArray
18:07:13 <lambdabot> forall e i. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
18:07:29 <sjanssen_> scodil: see that "forall s" part?
18:07:31 <scodil> yeah
18:07:41 <scodil> i understand what it does
18:07:47 <scodil> but why does it need to be there
18:08:05 <sjanssen_> it's so that the s var can't leak out
18:08:20 <scodil> is that the same type as runST?
18:08:28 <scodil> minus the array parts
18:08:31 <sjanssen_> because then you could write operations with ST that break referential transparency
18:08:34 <sjanssen_> scodil: yes
18:08:51 <scodil> so no ST action can be polymorphic?
18:09:06 <scodil> or is it because the s in STArray and the s in ST s are the same s?
18:09:31 <sjanssen_> now, the MArray class has parameters for the array type, the element type, and the monad that it's mutable in
18:10:21 <sjanssen_> for ST, the 's' is mentioned in those instance parameters
18:11:12 <sjanssen_> so we can't give those class constraints, because the type system can't prove that the MArray instance is valid for *any* choice of s
18:12:04 <sjanssen_> so you can have polymorphic ST computations, just not ones where the type is constrained by a class that depends on the 's' parameter
18:12:20 <scodil> and converting runSTArray into runST( newArray (...  wouldn't help
18:12:22 <scodil> for that reason
18:12:28 <scodil> because newArray uses the s
18:12:45 <Excedrin> does Control.Monad.State have anything to do with threading state thru a set of operations?
18:13:11 <sjanssen_> Excedrin: it has *everything* to do with threading state
18:13:17 <scodil> and this is just a quirk of the type system. those no reason why you couldn't make the s-dependent types polymorphic
18:13:24 <scodil> i mean, no practical reason
18:13:32 <sjanssen_> not that I can see
18:13:44 <sjanssen_> it isn't unsafe or anything, as far as I can tell
18:14:28 <sjanssen_> Excedrin: did you catch my paste about the state monad and Data.Map?
18:14:57 <Excedrin> sjanssen_: I think so, let me check
18:15:19 <sjanssen_> http://paste.lisp.org/display/29531 if you didn't
18:16:09 <Excedrin> thanks, I missed it
18:19:26 <lisppaste2> sjanssen annotated #29531 with "lookup is another useful operation" at http://paste.lisp.org/display/29531#1
18:19:52 <Excedrin> I'm still missing the state threading part
18:19:52 <ralf`> sjanssen_: Hmm...  I'm curious, but I'm not sure I'll be able to get Control.Monad.State to load.  I'm running an old version of hugs.  Perhaps it's time to apt-get another?
18:19:59 <ralf`> ERROR "Control.Monad.State" - Unable to open file "Control.Monad.State"
18:21:00 <sjanssen_> ralf`: how old is your hugs?
18:21:24 <ralf`> probably pretty old.  Must socialize.  Sorry.  I'm being harassed.
18:21:32 <ralf`> This is good stuff though.  I appreciate the pastes.  More later.
18:28:03 <scodil> so if i've got an st-computation that I wan't to use with a polymorphic type, what do I do?
18:29:14 <scodil> if the only stateful things in ST are refs and arrays, how do you do anything with ST and polymorphic types?
18:29:57 <scodil> because both STRefs and STArrays are dependent on the s type parameter
18:31:46 <sjanssen_> scodil: it can be polymorphic, you just can't have a return type that is constrained by a class instance that mentions both the polymorphic type and the 's' type
18:34:13 <sjanssen_> scodil: I THINK I FIGURED OUT HOW TO DO IT!!!
18:34:20 <scodil> tell me tell me
18:35:41 <dibblego> ~coq
18:35:47 <dibblego> @where coq
18:35:48 <lambdabot> I know nothing about coq.
18:38:10 <Excedrin> dibblego: http://coq.inria.fr/
18:38:12 <lambdabot> Title: The Coq proof assistant
18:38:19 <dibblego> ta, I was just being lazy :)
18:38:26 <sjanssen_> sorry, false alarm
18:42:08 <scodil> what about newtype or something?
18:42:56 <scodil> so my best bet is just unsafePerformIO then
18:43:31 <sjanssen_> I guess
18:44:45 * ralf` is very eager to learn about coq
18:45:22 * ralf` is reading about topology and daydreaming about writing up the proofs in Haskell.
18:46:28 <chessguy> what's the relationship between haskell and coq?
18:47:25 <dibblego> none really, I was just hoping
18:49:16 <pkhuong-> chessguy: you can extract haskell code from coq proofs.
18:49:33 <chessguy> hmm, can you give an example?
18:51:05 <pkhuong-> http://coq.inria.fr/doc/Reference-Manual021.html (the examples extract ocaml code, but coq can also generate scheme or haskell)
18:51:08 <lambdabot> Title: Extraction of programs in Objective Caml and Haskell, http://tinyurl.com/yd9qr4
18:52:42 <chessguy> interesting
18:53:51 <ralf`> When i start hugs, it says "version nov 2002" but when I type hugs -v, it doesn't work.  Nor does hugs --version or hugs --help or hugs -h.
19:02:09 <zptao> what is the recommended haskell compiler?
19:02:54 <Taral> @pl \a b c d -> a (b c) (b d)
19:02:55 <lambdabot> join . ((flip . ((.) .)) .) . (.)
19:02:55 <dibblego> recommended for whaT?
19:02:57 <fik> @where GHC
19:02:58 <lambdabot> http://haskell.org/ghc
19:03:06 <Taral> @pl \a b c -> a b (c d)
19:03:07 <lambdabot> flip flip ($ d) . ((.) .)
19:03:13 <Taral> @pl \a b c -> a c (c b)
19:03:14 <lambdabot> (. flip id) . ap
19:03:51 <Taral> @pl \a b c -> a c (b c)
19:03:52 <lambdabot> ap
19:10:24 <dolio> @pl \x y -> x
19:10:25 <lambdabot> const
19:11:00 <fik> @type .
19:11:02 <lambdabot> parse error on input `.'
19:11:09 <fik> @type (.)
19:11:11 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
19:30:34 <scodil> what do I do if they type checker tells me to add a type qualification for a type variable that I didn't declare.  I'm only parametrizing on 'f' and it came up with an 'a'
19:33:16 <dons> ?paste the code?
19:33:17 <lambdabot> http://paste.lisp.org/new/haskell
19:33:31 <dons> need to see the actual code and error msg, to efficiently diagnose
19:34:45 <mauke> paste
19:41:11 <dons> hmm, longest .. identifier ... ever... :
19:41:22 <dons> _automatedQuickCheckMainWhichCanBeDeletedWheneverYouWantButPleaseDoNotChangeThisLineBecauseItMightConfuseTheStupidScriptThatProcessesIt :: IO ()
19:41:34 <merus> ... wow
19:42:48 <dons> but my favourite identifier seen today is: top'n'tail
19:42:53 <dons> by malcolm
19:43:16 <dons> ?let top'n'tail = ("<pre>"++) . (++"</pre>")
19:43:18 <lambdabot> Defined.
19:43:28 <dons> > L.top'n'tail "foo me now"
19:43:29 <lambdabot>  "<pre>foo me now</pre>"
19:43:35 <mauke> that reminds me, haskell needs don't
19:43:41 <dons> yes!
19:43:43 <dons> great idea
19:44:05 <mauke> http://search.cpan.org/~dconway/Acme-Don-t-1.00/t.pm
19:44:08 <lambdabot> Title: Acme::Don't - The opposite of do - search.cpan.org, http://tinyurl.com/yff5cx
19:44:28 <dons> > let don't b e | b = error "i'll kick your butt" | otherwise = e in don't True (1+2)
19:44:29 <lambdabot>  Exception: i'll kick your butt
19:44:45 <pkhuong-> mm. the opposite of do, eh? do for comonads? :)
19:44:54 <dons> ah!
19:44:57 <dons> pkhuong-++
19:47:02 <dibblego> last runs in O(n) right?
19:47:07 <dibblego> Data.List.last
19:47:20 <dons> hey dibblego. got the wireless working I see?
19:47:22 <scodil>     Could not deduce (MArray UArray f IO) from the context (IArray UArray f,  MArray IOUArray f IO, .... whats that all about?
19:47:24 <dons> dibblego: yep
19:47:27 <dibblego> dons, yeah mate :)
19:47:30 <dons> lists are essential O(n) structures
19:47:30 <dibblego> ta
19:47:39 <dons> with fast cons/head
19:47:48 <dibblego> right, as I thought, thanks
19:48:26 <pkhuong-> dons: well, you can have O(1) cons/head/tail and faster random access...
19:50:48 <dons> yeah
20:03:13 <sjanssen_> > filterM (const [True, False]) "abc"
20:03:15 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
20:03:18 <sjanssen_> @keal
20:03:18 <lambdabot> intuitive != imperative
20:03:46 <mauke> @type filterM
20:03:47 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:03:51 <sjanssen_> that's actually a pretty good keal-ism
20:04:35 <mauke> wow, that's pretty cool
20:04:43 <sjanssen_> mauke: yeah, it is
20:04:54 <dons> so we were just looking at a 8-socket, 16 core linux box to run ghc smp on...
20:05:01 <sjanssen_> instance Monad []++
20:05:03 <dons> and were pondering why the harddrive was only 3G
20:05:14 <dons> then we realised that was the *bandwidth* on the drive :)
20:05:28 <sjanssen_> nice
20:05:32 <dons> so hmmm. 16 cores should be a nice haskell/lambdabot box
20:05:33 <sjanssen_> what architecture is that?
20:05:42 <dons> this guy http://www.ipspty.com.au/bone/vx50b4881.htm
20:05:43 <lambdabot> Title: Tyan B4881V50S4H-8P Transport VX50 5U Rack & Pedestal Server 8 Way & Quad Dual C ...
20:06:07 <dons> when this thing arrives, i'm definitly going to run lambdabot on it :)
20:06:26 <sjanssen_> ha
20:06:34 <dons> one core per channel, I guess
20:07:25 <sjanssen_> then I'm going to start programing over IRC with gratuitous use of @let
20:07:31 <dons> heh
20:07:35 <dons> free cores for all!
20:07:52 <dons> since lambdabot forks a thread on every request, this might actually scale really nicely
20:08:59 <zptao> you're dedicating a box with that kind of horsepower just for a bot?
20:09:19 <dons> no ;)
20:09:27 <dons> that would be kinda insane..
20:09:47 <sjanssen_> lambdabot could be a nice advertisement for DPH when it's ready
20:09:48 <dons> its for working on data parallel haskell
20:09:51 <dons> yeah
20:10:07 <zptao> what is data parallel haskell?
20:10:13 <dons> if we can get this in the next month or so, hopefully we can get the transparently parallel arrays out by christmas
20:10:15 <sjanssen_> just wow everybody by computing ridiculously complicated stuff in channel
20:10:31 <scodil> if the type checker is telling me to add an instance declaration for some type parameter that I didn't declare, how do I find out where its coming from?
20:10:36 <dons> sjanssen_: hmm!
20:10:40 <dons> yeah, `par` inline
20:11:11 <dons> zptao: data parallel haskell is a project to add transparently parallel arrays to ghc
20:11:33 <dons> its the 3rd line of parallelism added to ghc, after forkIO and par
20:11:34 <zptao> dons: which is
20:11:51 <dons> arrays that are distributed over multiple cores, on a shared memory machine, transparently
20:12:09 <zptao> and the value of this is
20:12:23 <dons> umm...
20:12:29 <dons> you have 16 cores. you want to use them all
20:12:32 <sjanssen_> dons: DPH would be a neat Christmas present
20:12:37 <dons> I reckon!
20:12:41 <dons> zptao, http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
20:12:45 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki, http://tinyurl.com/y77oeb
20:13:15 <dons> zptao: so you write your normal array algorithm, and the library parallelises it for you to run in multiple threads on multiple processors. == $profit
20:13:41 <zptao> mmm
20:13:46 <pkhuong-> dons: do you intend to also fork into SIMD?
20:13:51 <emu> IArrays?
20:14:12 <dons> there's some talk about SIMD, but we'll have to see how far we can improve the native codegen first
20:14:14 <sjanssen_> emu: special arrays.  Ones that don't suck
20:14:20 <emu> that would be nice
20:14:25 <emu> STArrays defeated me
20:14:56 <dons> sjanssen_: interestingly, the DPH work uses stream fusion to remove intermediate data redistributions between threads (and hence between processors).
20:15:12 <dons> using the same stream combinators, but for a completely different semantic result
20:15:24 <sjanssen_> dons: yeah, I saw that in the preliminary report
20:15:33 <sjanssen_> I think I had a question, but I can't remember anymore
20:16:04 <dons> so now that dcoutts is coming down to unsw early next year, i think we can make some real progress on this
20:16:05 <pkhuong-> dons: do you have some way to gracefully degrade when fusion isn't possible, but a little buffering would be enough (are there even such cases)?
20:16:54 <dons> pkhuong-: when fusion isn't possible, and you program in such a way that the data becomes unbalanced, you'll have to redistribute. nothing much can be done there afaik
20:18:45 <sjanssen_> honestly, with streams fusion, there aren't that many patterns that you can't fuse
20:18:48 <pkhuong-> oh good. That means I can just give up on that. :) I was trying to see how fusion could work for an array DSL, and it seemed sad to either have full fusion or no fusion at all.
20:19:38 <pkhuong-> sjanssen_: well, depending on your rules, `map . sort' may not be fusable.
20:20:12 <sjanssen_> pkhuong-: oh right.  This is what happens when you make bold statements ;)
20:20:56 <pkhuong-> sjanssen_: just add an associative fold for types w/ plus, zero (and unit) and you're good to go, though (:
20:21:12 <thetallguy> Howdy folks
20:21:32 <thetallguy> Anyone know why Text.XML.HaXml is a hidden module in ghc 6.6?
20:21:42 <thetallguy> Or at least, in the Debian distribution of 6.6?
20:22:20 <thetallguy> ?users
20:22:21 <lambdabot> Maximum users seen in #haskell: 265, currently: 229 (86.4%), active: 23 (10.0%)
20:25:36 <skew> doesn't seem to be hidden here
20:25:58 <skew> I built from source, so maybe it's just the debian version
20:29:13 <skew> before that I tried the i386 binary distribution from the GHC page, which hadn't build the GHC api for use from ghci
20:33:32 <skew> hello?
20:38:57 <dibblego> let f x = t where t = length x + length x; f' x = t + t where t = length x -- is f' memoised?
20:39:07 <dibblego> brb
20:43:42 <dibblego> sorry, I should say are there one or two calls to length xs ?
20:44:43 <skew> just one in f'
20:44:54 <sjanssen_> dibblego: most likely two in f
20:44:56 <skew> depends on CSE in f
20:45:05 <sjanssen_> though the compiler is allowed to only compute it once
20:45:11 <skew> run it through -ddump-simpl and find out
20:49:32 <skew> I'm wondering why sum . map f . take n . iterate g isn't getting fused
20:50:23 <sjanssen_> sum isn't fusible under foldr/build
20:50:37 <skew> ah, right
20:50:38 <sjanssen_> left folds in general aren't
20:51:43 <zptao> can anyone explain to me what this haskell stuff means?
20:51:47 <zptao> *** Instance   : Num [a -> b]
20:51:48 <zptao> like that
20:52:02 <sjanssen_> zptao: means you tried to use a list of functions as a number
20:52:27 <skew> *** Instance   : Num [a -> b]
20:52:39 <skew>     ^ talking about some instance of some typeclass
20:52:41 <zptao> is everything in haskell a list or something?
20:52:45 <sjanssen_> no
20:52:52 <sjanssen_> you probably made a typo
20:52:59 <dibblego> skew, what is CSE?
20:53:02 <skew>                   ^ which class it's talking about
20:53:09 <monochrom> everything in Haskell is a value.
20:53:09 <skew> Common Subexpression Elimination
20:53:13 <sjanssen_> impossible to say exactly without seeing the code
20:53:21 <zptao> > until (>900) (*2) 1
20:53:22 <lambdabot>  1024
20:53:27 <monochrom> Some people say "thunk" which is the same thing.
20:53:31 <skew> *** Instance   : Num [a -> b]
20:53:54 <skew>                      ^ which type it's thinking about
20:54:11 <skew> ?t until
20:54:12 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:54:19 <skew> ?type until
20:54:21 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:54:53 <skew> sjanssen_: hey, it fuses if I use foldr (+) 0
20:55:17 <sjanssen_> skew: yeah, but your stack will blow if the list gets too long
20:55:31 <skew> hmm?
20:55:41 <skew> It's fusing clean through to the generator
20:55:52 <sjanssen_> that builds a chain of (1 + (1 + (1 + ... when you evaluate it
20:56:09 <sjanssen_> so that will take O(n) stack
20:56:16 <sjanssen_> as opposed to O(1) with foldl
20:56:50 <skew> hmm
20:56:59 <skew> I'm seeing +#
20:57:16 <skew> so I'm not going to be building a chain of thunks, in any case
20:58:39 <sjanssen_> try it on an infinite list, see what happens
20:59:19 <skew> It's in a pipeline foldr (+) . map f . take n . iterate g
21:02:23 <skew> overflows at n = 10000000
21:02:59 <pkhuong-> you can always fuse the foldl . map by hand :\
21:04:09 <monochrom> does foldl' help?
21:04:19 <skew> foldl'?
21:04:21 <skew> hmm
21:04:29 <skew> I think sum uses foldl'
21:04:47 <Cale> @fptools Prelude
21:04:48 <lambdabot> http://darcs.haskell.org/packagesbase/Prelude.hs
21:06:06 * monochrom enters sum (repeat 1 :: [Int]) and watches
21:06:30 <monochrom> Almost 300MB now :)
21:07:08 <skew> with foldl' it never runs out of stack, but it didn't quite fuse completely
21:07:08 <monochrom> Changing 1 to 0 doesn't help :)
21:07:59 <Cale> sum	l	= sum' l 0
21:08:00 <Cale>   where
21:08:00 <Cale>     sum' []     a = a
21:08:00 <Cale>     sum' (x:xs) a = sum' xs (a+x)
21:08:09 <Cale> @fptools Data.List
21:08:10 <lambdabot> http://darcs.haskell.org/packagesbase/Data/List.hs
21:08:20 <Cale> okay, that's wrong
21:08:23 <Cale> http://darcs.haskell.org/ghc-6.6/packages/base/Data/List.hs
21:09:03 <zptao> anyone doing biology/chem? i have a very un-haskell question
21:09:19 <monochrom> Almost killed my computer :)
21:09:28 <Cale> monochrom: heh, me too
21:09:50 <Cale> you really probably want foldl' (+) 0 if you're doing a large sum
21:23:26 <lambdabot> http://tinyurl.com/ycetae
21:23:46 <monochrom> out of thin air?
21:24:24 <dolio> It's for Data.List
21:24:34 <dolio> Cale posted that 15 minutes ago.
21:24:45 <monochrom> interesting delay
21:25:04 <pkhuong-> zptao: I used to study dentistry, so I may be able to help.
21:25:16 <Cale> that lambdabot sure knows how to make an entrance
21:26:22 <sjanssen> skew: it's likely that foldr (+) with fusion will be a win up until a certain list length
21:27:14 <sjanssen> GHC defines length via foldr when it can successfully fuse
21:27:42 <sjanssen> and length and sum are essentially the same operation
21:32:03 * Cale sighs about reddit. So many blue down arrows.
21:33:00 <monochrom> The weekend is near!
21:33:17 <monochrom> (I heard that it's better during weekends.)
21:33:43 <tmoertel> Cale: on what article?
21:33:56 <Cale> hehe, on the articles themselves
21:34:07 <tmoertel> gotcha
21:34:56 <Cale> There's so much stuff there on programming reddit which I wouldn't really consider to be about programming, and most of the rest is stuff that I automatically mod down because it's agile junk.
21:35:18 <dolio> I've been hiding stories I'm not interested in.
21:35:33 <dolio> So my top story is #29: Haskell Weekly News... :)
21:37:14 <pkhuong-> modding it up ;)
21:37:23 <edwardk> heh
21:38:44 <skew> stream fusion should be able to handle sum, right?
21:41:14 <tmoertel> skew: sum isn't in the list of "good consumers": http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3179621
21:41:17 <lambdabot> Title: 7.11. Rewrite rules, http://tinyurl.com/y7rk9g
21:41:53 <dolio> That's list fusion, though.
21:42:26 <skew> I'm working with lists.
21:43:13 <dolio> ?fptools Prelude
21:43:13 <lambdabot> http://darcs.haskell.org/packagesbase/Prelude.hs
21:44:01 <sjanssen> skew: yeah, streams can handle left folds
21:44:34 <pkhuong-> sjanssen: only?
21:44:47 <sjanssen> pkhuong-: no, right folds too
21:45:59 <skew> lists are pretty much streams to begin with, so I wonder why foldl doesn't fuse with unfold
21:47:20 <skew> The paper "Compact Fusion" describes fusing foldl into unfoldr, among other things
21:47:49 <dolio> I seem to recall a discussion about ghc not doing that because SPJ hasn't gotten around to it yet.
21:48:27 <skew> That's the best kind of reason for not having something
21:48:32 <dolio> :)
21:48:41 <sjanssen> dolio: there's an optimization that would allow GHC to express foldl efficiently in terms of foldr
21:48:53 <skew> oh, what's that?
21:49:01 <sjanssen> I think that's the thing that SPJ hasn't managed to do yet
21:49:11 <sjanssen> I don't know
21:49:17 <skew> oh, I was just thinking of adding a foldl / unfoldr rule
21:49:38 <sjanssen> skew: but what about foldr/build?
21:49:48 <skew> when I wrote the pipeline with foldl is fused down into foldl of an application of iterateFB
21:49:57 <dolio> Could be, I don't remember the details, and I probably won't find the mails.
21:50:02 <sjanssen> good producers in foldr/build are going to be written in terms of build, not unfoldr
21:50:11 <pkhuong-> sjanssen: you build list continuations.
21:50:18 <pkhuong-> s/list//
21:50:28 <skew> but unfoldr is a more special case
21:50:31 <pkhuong-> so yeah, you get fusion, but it's not really interesting.
21:50:36 <dolio> I just remember someone asking why hylo fusion wasn't implemented, and he said something to the effect of "I've been meaning to do it since <someone> wrote a paper a few years ago, but never got around to it."
21:51:43 <skew> so you can just duplicate some rules in an unfoldr and a build version, plus pick up some extra unfoldr cases
21:52:18 <sjanssen> skew: the RULE staging will become very complicated and fragile
21:52:34 <skew> I don't see how that makes it any more fragile than it is already
21:52:58 <skew> all the fragile stuff was about turning things into their fusibile form, and then turning them back later
21:53:08 <sjanssen> yeah
21:53:09 <skew> I think it's orthogonal what the fusible form looks like
21:53:35 <sjanssen> skew: I thought you were recommending two simultaneous fusion schemes?
21:53:42 <skew> not exactly
21:54:06 <skew> The stuff I was saying most recently is just that unfoldr is a very special case of build
21:54:27 <sjanssen> true
21:54:40 <skew> so you can turn things into unfoldr instead of build where possible, and make another version of your X/build rules that work with X/unfoldr
21:55:06 <sjanssen> I don't think you can turn build into unfoldr
21:55:18 <skew> no, but the other way is easy
21:55:24 <sjanssen> yes
21:56:54 <skew> tmoertel: I'm thinking about fusion now because I'm looking at those bowling scoring programs
21:57:06 <sjanssen> heh
21:57:22 <tmoertel> skew: yes, you really need fusion to score those ten frames ;-)
21:58:55 <tmoertel> skew: are you looking at the programs on xprogrammning.com ?
21:58:58 <skew> yes
21:59:32 <skew> especially Alistair Bayley's code can be written nicely as sum . map scoreFrame . take 10 . iterate nextFrame
22:00:53 <skew> which should fuse right back down to monolithic accumulator version
22:00:55 <tmoertel> I had a little back-and-forth email discussion w/ ron jeffries, and in my vigorous defense of recursion's virtue, I ended up de-recursifying my implementation.
22:01:16 <tmoertel> score2 rs = fst . s.s.s.s.s.s.s.s.s.s $ (0, rs) where s = uncurry scoreFrame
22:01:44 <tmoertel> I wanted to make it explicit that I was calling scoreFrame ten times, and that's all my recursive loop was doing.
22:01:55 <tmoertel> So I enumerated each call: s.s.s.s. ...
22:02:19 <tmoertel> Several other versions: score3 rs = fst (iterate (uncurry scoreFrame) (0, rs) !! 10)
22:02:29 <tmoertel> score5 rs = fst (foldr ($) (0, rs) (replicate 10 (uncurry scoreFrame)))
22:03:27 <skew> I like take 10 for that
22:03:28 <tmoertel> who would have thought that such a small problem would have sparked off such a large discussion?
22:04:06 <pkhuong-> tmoertel: no sane person.
22:04:16 <skew> Oh, we're all mad here.
22:04:22 <tmoertel> skew: my scoreFrame is cumulative, so you only want the final element, not all ten.
22:04:48 <skew> I liked John Hughes' "Why Functional Programming Matters"
22:05:07 <thetallguy> skew: Thanks for the info.  Sorry, I got distracted.  I'll check the Debian config.
22:05:36 <skew> heck, my solutions rely on lazy evaluation even to stop iterate nextFrame from falling off the edge of the world
22:05:47 <skew> also, I'm seeing that more lazy pattern matching might be nice
22:06:02 <skew> at least, if it's needed at all
22:06:46 <skew> although, knowing all the structure from the pattern actually exists is nice too
22:07:08 <skew> my letter is taking after Oleg
22:07:17 <skew> lhs with footnotes
22:07:20 <tmoertel> skew: do you think you can reliably determine how to interpret the final frames from pattern matching on the final few rolls?  (i have doubts)
22:08:13 <skew> [10,2,3] can show up as the last two frames, or the last frame
22:08:26 <tmoertel> that's the case I was thinking of  ;-)
22:09:18 <skew> do you use HUnit much? I noticed that the code for stripping the user text out from show (IOException (userError "str")) doesn't work with ghc6.4 or hugs20050308
22:10:11 <tmoertel> my bowling implementation, in fact, uses HUnit for its tests.  seems to work fine from w/in GHCi
22:10:22 <edwardk> ok, borrowing from pkhuong-, which do you like better, codo or don't? =)
22:10:26 <skew> what if they fail?
22:10:29 <tmoertel> skew: but I'm running 6.4.2
22:10:39 <tmoertel> skew: I've never had a test fail.    ;-P
22:10:44 <skew> I'm using 6.4.1 or 6.6
22:10:47 <skew> they pass fine
22:10:57 <tmoertel> skew: let me see, I'll break a test and see what happens ...
22:11:42 <skew> HUnit really ought to be using DynException anyway, unless there's some kind of crazy backwards-compatibility requirement
22:11:50 <tmoertel> I get "user error (HUnit:expected ... )"
22:12:09 <skew> yeah, should be "expected ..."
22:12:34 <tmoertel> mostly, though, I'm a QuickCheck man.
22:12:41 <skew> Test/HUnit/Lang.lhs has a few fixed prefixes it tries to strip from the show result
22:12:50 <skew> can't say I approve
22:13:17 <skew> It seems like HUnit might be nice for organizing a bunch of QuickCheck cases
22:13:29 <tmoertel> ah, c'mon, everybody loves QuickCheck.
22:14:03 <skew> I disaprove of hardcoding the implementation-dependend garbage at the beginning of show . IOException . ioError $ str
22:14:22 <tmoertel> oh, that makes more sense.  now I understand.
22:15:12 <skew> that reminds me, it looks like we need to start begging for an ESC/Haskell release
22:15:21 <edwardk> skew: agreed
22:17:54 <monochrom> ESC FTW :)
22:18:24 <monochrom> Who needs testing?  Write down invariants and prove them already.
22:18:25 <skew> I've only got one question about ESC, how can you help it figure out something true, if it's getting stuck
22:18:55 <monochrom> Add more assertions.  More and more and more.  Some assertions are lemmas to help it.
22:19:17 <skew> how about rules?
22:19:31 <skew> it's easy to see how to feed Epigram a lemma
22:19:53 <skew> but randomly adding assertions doesn't sound very fun
22:20:04 <monochrom> I don't know how to guide Simplify.  It's... too automatic.
22:20:18 <skew> does ESC/Haskell even use Simplify?
22:20:26 <skew> I thought it was totally relying on abstract interpretation
22:21:03 <monochrom> ESC/Modula-3 and ESC/Java use Simplify.
22:21:47 <monochrom> (Evidently I am based on only knowledge of them :) )
23:19:11 <dons> araujo: translation? http://sequence.complete.org
23:19:17 <dons> ?users
23:19:18 <lambdabot> Maximum users seen in #haskell: 265, currently: 228 (86.0%), active: 15 (6.6%)
23:19:56 <dons> ?yow!
23:19:57 <lambdabot> These PRESERVES should be FORCE-FED to PENTAGON OFFICIALS!!
23:21:28 * lispy waves
23:28:29 <dons> Cale: nice post on the `on` thread
23:28:31 <dons> Cale++
23:28:37 <Cale> :)
23:28:59 <dons> anything to increase the density of one liner haskell code is a good thing :)
23:29:15 * dons plans `par` support for lambdabot's @run command...
23:34:29 <Heffalump> WHY?
23:34:39 <Heffalump> oops, sorry, left caps lock on
23:35:46 <monochrom> What, we can now get karma points here by wasting our time on reddit?
23:37:45 <dolio> No, the haskell libraries mailing list.
23:38:17 <monochrom> Oh that's sweet.
23:39:06 <Heffalump> the only post I can see by Cale is a top-posted one-liner agreeing with someone else
23:46:33 <Cale> Not on reddit
23:46:43 <Cale> on the mailing list, he meant
23:46:56 <Cale> I have been posting lots on reddit too though
23:47:12 <Cale> look at the O'caml vs Haskell performance thread there
23:47:12 <skew> the one with equations for (.) as a method of Functor at (a -> b) . (f a -> f b)
23:47:17 <skew> ?
23:47:23 <Cale> yeah
23:54:20 <edwardk> skew where?
23:55:00 <skew> Cale wrote to the libraries list
23:56:37 <edwardk> trying to find it
23:58:20 <skew> with the instance Functor ((->) a), that looks like (.) :: (a -> b) -> (c -> a) -> (c -> b)
23:58:47 <edwardk> skew: yeah, we were talking about it on ##logic a couple days ago
23:58:57 <edwardk> i just wanted to see the post =)
23:59:11 <skew> those little coherence rules are interesting
23:59:33 <skew> I wonder if it's actually related to higher-dimensional categories
