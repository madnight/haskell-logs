00:00:06 <astrolabe> noob questions are good: I can answer some of them
00:00:15 <Korollary> astrolabe meant 'bitte'
00:00:29 <merus> Yeah, I know.
00:00:37 <astrolabe> Korollary: danke
00:00:44 <Korollary> cheers m8
00:02:31 <theoco> Wunderbar!
00:03:16 <Botty> Ich bin ein Berliner und deine Mutti sind ein Flugzeug!
00:03:53 <theoco> you are in berlin and your mom is in _______
00:04:25 <Botty> nah, is an airplane, though I probably got the conjugation and such wrong
00:04:50 <Botty> I am a donut and your mother is an airplane.
00:05:00 <theoco> lol
00:05:17 <Korollary> ...sind in einem Flugzeug I believe
00:05:28 <Korollary> err
00:05:33 <Turks> Heh
00:05:36 <Korollary> I thought you wrote in an airplane
00:05:51 <Turks> Good night crazy programmer dudes :)
00:06:00 <Korollary> nonetheless, a beatiful sentence. bound to make lots of german friends.
00:06:11 <Botty> oh it has, it has
00:06:17 <Korollary> nite Turks
00:06:20 <theoco> scheizekopf is my favorite german word
00:06:38 <Korollary> it's with 'ss', not z.
00:06:51 <theoco> google says otherwise
00:06:55 <Korollary> hmm
00:07:07 <robreim> @pl \a -> ask >>= \b -> liftIO $ writeIORef b a
00:07:08 <lambdabot> (ask >>=) . (liftIO .) . flip writeIORef
00:07:15 <Botty> Halt oder ich sheize!
00:07:47 <Korollary> theoco: google is full of scheisse, then.
00:08:14 <theoco> Korollary: yes, there are more results for your spelling
00:08:29 <Botty> yeah, everyone spells it wrong, including me apparently
00:10:28 <theoco> hey you guys should join #compsci
00:10:36 <theoco> its the coolest
00:11:01 <theoco> free food and even neked ladies
00:11:10 <merus> Wow, sequence is cooler than expected.
00:11:36 <robreim> @pl \f = (asks f >>=) . (io .) . (flip writeIORef)
00:11:37 <lambdabot> (line 1, column 4):
00:11:37 <lambdabot> unexpected "="
00:11:37 <lambdabot> expecting operator, pattern or "->"
00:11:46 <robreim> @pl \f -> (asks f >>=) . (io .) . (flip writeIORef)
00:11:46 <lambdabot> (. ((io .) . flip writeIORef)) . (>>=) . asks
00:11:53 <robreim> yuck
00:15:38 <theoco> why doesn't this code work
00:15:59 <theoco> http://webpages.charter.net/jtlien/hasseq.html Phone word generator
00:16:01 <lambdabot> Title: Haskell Sequence examples, http://tinyurl.com/tvgbp
00:18:34 <theoco> I get parse error on imput 'main'
00:19:52 <theoco> anybody?
00:20:05 <TSC> I'll try it
00:20:21 <Korollary> works for me
00:20:32 <theoco> really?
00:20:37 <Korollary> yeah
00:21:44 <Korollary> it generates a lot of gobbledygook words
00:22:22 <theoco> how you run it?
00:22:33 <Korollary> runghc a.hs
00:22:35 <TSC> Works for me too, once the layout is correct
00:22:39 <Korollary> I put it in a file
00:22:50 <TSC> You have to be careful if you copy and paste it
00:24:15 <theoco> TSC: what needs to be fixed if i copy and paste?
00:24:25 <theoco> does whitespace matter?
00:24:32 <TSC> Yes
00:24:52 <TSC> Particularly the do-expression in prntlst
00:26:06 <theoco> can you pastebin the working code
00:26:34 <TSC> Sure
00:27:12 <theoco> nevermind
00:27:18 <TSC> Alright
00:32:46 <theoco> now i can tell people to call xxx-dick
00:42:32 <dblhelix> anyone built gtk+ 2.0 for mac os?
00:50:09 * ascii beep
00:50:51 <Korollary> another fax?
00:51:36 <ascii> . tired and it's all that is working at the moment
00:52:17 <ascii> kind of you tho
00:52:48 <Korollary> Thanks. Would you like some of my vicodin?
00:53:17 <ascii> woot, imma take a rain check.
00:54:02 <Korollary> $10 says the new Bond movie sucks royale.
00:54:13 * merus cackles.
01:00:36 <ascii> it would be nice to have 10 bucks.
01:06:16 <lispy> ascii: you should change your nick to ^G ;)
01:07:36 <therp> pfew I finally got rid of this incorrect ligature in definstance...
01:10:12 <ascii> lispy:  ^G ?
01:11:20 <lispy> ascii: yeah, if you hit ctrl g on most terminals it makes a beep :)
01:11:43 <lispy> * ascii beep
01:11:52 <lispy> and so i would call that an ascii beep :)
01:12:19 <lispy> does this  work?
01:12:29 <ascii> not yet.
01:12:32 <ascii> :(
01:12:36 <lispy> (that was me sending a ^G)
01:14:32 <therp> I would suspect sending control chars is filtered by the IRC server. just image the fun when sending stuff like \nKICK yournick #haskell "Haha"
01:15:11 <lispy> it makes sense yeah
01:15:20 <lispy> is this
01:15:26 <ibid> or the client does
01:15:42 <lispy> I just tried, "is this ^M two lines?" and emacs said, "*** two: Unknown command"
01:16:01 <dons> Elifant: did you see the newtype/record bug is fixed?
01:16:04 <dons> Elifant:   * resolution:  => fixed
01:16:04 <dons>   * status:  new => closed
01:16:10 <dons> http://hackage.haskell.org/trac/hugs/ticket/46
01:16:14 <lambdabot> Title: #46 (Records aren't working properly when declared using 'newtype' syntax.) - Hu ..., http://tinyurl.com/y83dmy
01:16:31 <dons> "The corresponding bug for pattern matching (#48) appears tougher." though
01:16:40 <Elifant> dons: wow! cool
01:16:50 <dons> Elifant: active community! ;)
01:17:13 <Elifant> ok, I've come with another stupid question :)
01:17:18 <Elifant> Can anyone show me a simple example of combining State monad with Error monad. I need to execute series of operations on state, but each of operations may cause error.
01:18:04 <lispy> Elifant: okay, there was a tutorial about that recently
01:18:11 <lispy> Elifant: i'll look for it
01:19:08 <lispy> Elifant: read this and you'll be enlightened :)
01:19:09 <lispy> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
01:19:12 <lambdabot> Title: Monad Transformers Step by Step, http://tinyurl.com/esboz
01:19:25 <lispy> it's easy and relatively short
01:19:28 <Elifant> lispy: thanks!
01:19:31 <lispy> np
01:20:17 * lispy calls it a night
01:20:19 <lispy> peace!
01:23:49 <dons> Elifant: looks like the segfault/blackhole bug is fixed too, http://hackage.haskell.org/trac/hugs/ticket/47
01:23:52 <lambdabot> Title: #47 (Hugs segfaults on black hole.) - Hugs - Trac, http://tinyurl.com/y6xqd2
01:24:44 <Elifant> hey, I like #haskell & Hugs more and more :)
01:24:50 <dons> :)
01:25:01 <Elifant> dons, btw, does 'Elifant++' mean something?
01:25:41 <vincenz> Elifant: yes, means you got more karma
01:25:43 <vincenz> @karma Elifant
01:25:44 <lambdabot> Elifant has a karma of 2
01:26:03 <Elifant> and what can I do with it? any simple magic?
01:26:22 <merus> Karma and $1.50 will get you a cup of coffee.
01:26:22 <beelsebob> dons: *ping*
01:26:43 <beelsebob> @karma beelsebob
01:26:44 <lambdabot> You have a karma of 3
01:26:46 <beelsebob> shiny
01:26:54 * beelsebob pat pats his karma
01:27:14 <vincenz> @karma vincenz
01:27:14 <lambdabot> You have a karma of 11
01:27:15 <Elifant> @faq
01:27:15 <lambdabot> The answer is: Yes! Haskell can do that.
01:27:21 <Elifant> :)
01:27:35 <therp> pah I have 0 karma. Well I don't like coffee anyway.
01:28:05 <Elifant> yes, I don't like coffee too... anyone want to buy some karma? :)
01:28:17 <dons> beelsebob: yo
01:28:23 <beelsebob> ah yay, hi dons
01:28:43 <beelsebob> I have been trying to poke lambdabot into compiling with ghc6.6... is this a totally unsupported and silly idea?
01:29:02 <dons> no no. grab the darcs repo, and use the ghc-6.6 cabale file
01:29:17 <beelsebob> oh? How does one use the ghc-6.6 cabal file?
01:29:24 <dons> so before you build, mv lambdabot.cabal.ghc-6.6 lambdabot.cabl
01:29:28 <dons> .cabal
01:29:32 <beelsebob> ah, okay
01:29:33 <beelsebob> win
01:29:36 <dons> cool
01:29:37 * beelsebob goes and trys
01:30:23 <beelsebob> win... actually building now, instead of complaining bitterly about FPS
01:30:35 <dons> heh
01:30:48 <dons> (that's always easy   to fix, just remove the fps dep now its in base)
01:31:08 <dons> oh, did you see http://programming.reddit.com/info/qrph/comments :)
01:31:11 <lambdabot> Title: Compiling Haskell to JavaScript (reddit.com), http://tinyurl.com/ycexf6
01:31:13 * beelsebob patches ./build to check the ghcversion and move the appropriae one
01:31:22 <dons> ah, good idea
01:31:34 <dons> beelsebob++
01:31:57 <beelsebob> ohh... doom mid build
01:32:09 <dons> how so?
01:32:09 <beelsebob> @paste
01:32:10 <lambdabot> http://paste.lisp.org/new/haskell
01:32:32 <lisppaste2> beelsebob pasted "doom" at http://paste.lisp.org/display/29881
01:33:18 <vincenz> dons: splicing in cpp is with two # right?
01:33:23 <vincenz> erm, concating
01:33:24 <vincenz> not splicing
01:33:26 <dons> oh, beelsebob easy.
01:33:32 <dons> chmod +x configure
01:33:36 <beelsebob> oh, okay
01:33:37 <dons> and rerun ./build
01:33:47 * beelsebob patches ./build to chmod configure as it goes
01:33:50 <dons> vincenz: yeah, iirc check K&R.
01:33:58 <dons> I thought it did? guess not.
01:34:12 <dons> chmod +x Setup.hs configure
01:34:24 <dons> you running the darcs repo version?
01:34:28 <beelsebob> yep
01:34:33 <beelsebob> chmodding didn't fix it
01:34:39 <beelsebob> but that might be through the lack of a clean
01:34:52 <beelsebob> what can I use to do a clean with this build system?
01:34:59 <dons> whta's in config.h ?
01:35:08 <dons> ./Setup.h clean
01:35:11 <dons> ./Setup.hs clean
01:35:24 <lisppaste2> beelsebob annotated #29881 with "more doom" at http://paste.lisp.org/display/29881#1
01:37:02 <beelsebob> nope, same bug after a clean
01:37:19 <beelsebob> configure definately has the x bit set
01:37:36 <beelsebob> it appears just not to be doing c pre-processing on it
01:37:45 <dons> what's in config.h ?
01:38:17 <dons> should be  something like:
01:38:19 <dons> #define GHC_VERSION     "6.4.2"
01:38:20 <dons> #define PLATFORM        "OpenBSD i386"
01:38:20 <dons> #define REPO_PATH       "http://www.cse.unsw.edu.au/~dons/lambdabot"
01:38:20 <dons> #define GHC_LIB_PATH    "/home/dons/lib/ghc-6.4.2"
01:38:20 <lambdabot> Title: Index of /~dons/lambdabot
01:38:22 <dons> #define PATCH_COUNT     "250"
01:38:25 <dons> #define CPU             ""
01:38:27 <dons> feel free to fake it
01:39:16 <beelsebob> dons: it's in the annotated paste
01:39:19 <beelsebob> it looks fine
01:42:59 <Excedrin> I'm writing a small HAppS app, and I finished changing some code to use simpleHTTPIO instead of simpleHTTP before I "got" that Prelude.reads lets me check for errors without using exceptions, so the IO is unnecessary
01:45:19 <beelsebob> ohhh...
01:45:34 <beelsebob> I've just figured out why it's not working
01:45:34 <beelsebob>      warning: #warning config.h is deprecated; please use ghcconfig.h instead
01:45:34 <beelsebob> it's using the wrong config.h
01:45:45 <beelsebob> it's using the one from /usr/local/lib/ghc-6.6/include/config.h
01:46:02 * beelsebob wonders why
01:47:13 <beelsebob> fixed my copying config.h into Plugin (which is a massive hack)
01:47:23 <beelsebob> I wonder why the search path gets b0rkened
01:47:50 <beelsebob> dons *poik*
01:49:18 <araujo> morning
01:49:49 <dons> beelsebob: ah.
01:49:56 <dons> weird
01:50:02 <beelsebob> any ideas why the search path is cocked up?
01:50:11 <Excedrin> eh; it's late, now I realized that using IO makes it easier to return errors to the client
01:50:20 <dons> no idea. should work. you checking the -I flag?
01:50:35 <beelsebob> at the moment I'm checking if anything else blows up
01:50:36 <beelsebob> but I will
01:50:45 * dons dinner. bbl
01:51:49 <beelsebob> k, np
01:56:29 <beelsebob> @message dons o.O "fd:9: hClose: resource vanished (Broken pipe)" <-- what did I break?
01:56:29 <lambdabot> Maybe you meant: messages messages?
01:57:10 <beelsebob> @tell dons o.O "fd:9: hClose: resource vanished (Broken pipe)" <-- what did I break?
01:57:11 <lambdabot> Consider it noted.
02:22:40 <Elifant> if I need state and error reporting, why can't I use (State Env (Either Error Value)), why should I use monad transformers like StateT?
02:29:29 <boegel> can anyone point me to a good State monad tutorial? (for someone who doesn't understand monads just yet)
02:30:41 <Philippa> Elifant: for the same reason you'd use Either as a monad rather than by hand
02:31:29 * beelsebob snuggles Philippa 
02:32:05 <dons> boegel: here's a little StateT http://haskell.org/haskellwiki/Simple_StateT_use
02:32:06 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
02:32:08 <lambdabot> Title: Simple StateT use - HaskellWiki, http://tinyurl.com/uyu6d
02:33:15 <boegel> dons: thanks
02:35:06 <beelsebob> @hoogle Data.Map.Map
02:35:07 <lambdabot> No matches, try a more general search
02:35:09 <beelsebob> o.O
02:35:48 <xerox> it's opaque
02:36:25 * beelsebob wonders how to get the empty map
02:36:30 <xerox> fromList []
02:36:39 <xerox> there even is a function
02:36:44 <xerox> err, a value :)
02:36:47 <xerox> @docs Data.Map
02:36:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
02:36:58 <dons> oh, nice, dibblego! http://blog.tmorris.net/maybe-in-java
02:37:00 <lambdabot> Title: λ Tony&#8217;s blog λ » Blog Archive » Maybe in Java
02:37:01 <xerox> singleton
02:37:37 <dons> http://programming.reddit.com/info/qt96/details
02:37:41 <lambdabot> Title: Maybe in Java (reddit.com), http://tinyurl.com/y5moza
02:40:29 <xerox> beelsebob: sorry, empty, not singleton
02:41:10 <beelsebob> xerox: cheers - do I need to start importing qualified modules if I want to use set and map in the same file?
02:41:21 <Elifant> tutorial on monad transformers uses "ReaderT Env (ErrorT String Identity) Value" type, can't it be replaced by "ReaderT Env (Either String Value)"?
02:41:34 <xerox> beelsebob: yep
02:41:39 * beelsebob notes that there should be a "container" class
03:00:36 <beelsebob> > [[1]..]
03:00:36 <lambdabot>  add an instance declaration for (Enum [a])
03:00:37 <lambdabot>   In the definition of `nwt': ...
03:00:39 <beelsebob> damn
03:08:44 <threeq> is there any way to make a function like atomicallyWithTimeout :: TimeInterval -> STM a -> Maybe a ?
03:15:33 * beelsebob pokes about for anyone who knows about lambdabot 
03:16:04 <dons> yes?
03:16:10 <dons> I'm somewhat familiar
03:16:16 <dons> ?users
03:16:17 <lambdabot> Maximum users seen in #haskell: 265, currently: 252 (95.1%), active: 29 (11.5%)
03:16:38 <sdf> hello there can someone help me with an exersise?
03:16:55 <vegai> most probably, if you ask right questions :)
03:17:04 <dons> possibly, sdf, we can hint and help you along
03:17:04 <sdf> I was asking yesterday
03:17:52 <beelsebob> dons: having problems getting it to connect to freenode
03:18:06 <beelsebob> and for that matter getting the eval module to work, but that's beside the point
03:18:21 <dons> ok, eval *won't* work in ghc 6.6, until hs-plugins does
03:18:23 <beelsebob> it connects to a random irc server that I use fine, but with freenode it just times out
03:18:26 <beelsebob> ah, okay
03:18:27 <beelsebob> I see
03:18:34 <dons> freenode. hmm. make sure you're not trying to connect here with the nick 'lambdabot'
03:18:41 <dons> freenode blocks connections if the nick is too similar
03:18:46 * beelsebob slaps self
03:18:52 <beelsebob> *IDIOT*
03:18:55 <dons> :)
03:19:25 <sdf> well the program has to check two char lists. it counts how many times the second list appears in the first
03:19:39 * beelsebob wishes freenode would give a more informative error msg
03:20:15 <dons> sdf, ah interesting. so how do you want to approach solving that?
03:20:45 <dons> you'll need an algorithm :)
03:21:07 <sdf> it has recursive,f :: [Char]  -> [Char] -> Int
03:21:14 <sdf> exampl:
03:23:03 <sdf> Input : ['a','b','a']    ['a','b','a','b','a','a','a','b','a']   output :3
03:30:29 <Elifant> sdf, quick and dirty, I'm a newbie too :) : f in out | (length out < length in) = 0; f in out = (if out `startsWith` in then 1 else 0) + f in (tail out) where startsWith = ...
03:31:42 <dons> good idea. its easier to work out the ones that don't match first
03:31:48 <dons> ?type isPrefixOf
03:31:50 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
03:31:50 <dons> could be useful
03:32:02 <dons> > isPrefixOf "foo" "foobar"
03:32:03 <lambdabot>  True
03:32:07 <sdf> I dont think I understand it Elifant
03:32:07 <dons> hint hint ;)
03:32:22 <Elifant> sdf: then ask :)
03:32:25 <dons> > "foo" `isPrefixOf` "foobar" -- nicer syntax
03:32:26 <lambdabot>  True
03:32:33 <sdf> I am asking :)
03:33:00 <Elifant> if 'out' list is shorter than 'in', we definitely has no occurences
03:33:20 <dons> sdf, so you can use isPrefixOf to check if your first list is at the start of the second list, if it is, you've found 1 sublist, if its not, move the list along, and recurse
03:33:43 <dons> enough hints! now write some code and play around with isPrefixOf :)
03:33:56 <Elifant> > isPrefixOf "foo" "f"
03:33:58 <lambdabot>  False
03:34:15 <Syzygy-> > isPrefixOf "f" "foo"
03:34:17 <lambdabot>  True
03:34:32 <sdf> isPrefixOf?whats that?
03:34:42 <Elifant> specially checked searching large in small :)
03:34:47 <dons> the list function that tells you if one string is a prefix of another
03:34:54 <basvandijk> Hello, quick question, is there a standard function that is equal to:
03:34:54 <basvandijk> freaky e = Monad.join . Monad.foldM (flip Monad.liftM) e  ?
03:34:59 <basvandijk> freaky :: Monad m => m a -> [a -> m a] -> m a
03:35:04 <dons> > isPrefixOf [1,2,3] [1,2,3,4,5,6,7]
03:35:05 <lambdabot>  True
03:35:07 <Binkley> @hoogle Monad m => m a -> [a -> m a] -> m a
03:35:09 <lambdabot> No matches, try a more general search
03:35:15 <dons> basvandijk: almost certainly not :)
03:35:19 <dons> but 'freaky' is a good name
03:35:28 <basvandijk> haha... ok thx
03:35:31 <dons> ?hoogle Monad m => m a -> [a -> m a] -> m a
03:35:32 <lambdabot> No matches, try a more general search
03:35:33 <sdf> dons:it returns 1 or TRUE?
03:35:38 <dons> True
03:35:44 <dons> > fromEnum True
03:35:45 <lambdabot>  1
03:35:48 <dons> > fromEnum False
03:35:50 <lambdabot>  0
03:35:54 <dons> ok. too many hints now ;)
03:35:57 <Elifant> he, another hint ^)
03:36:39 <dons> sdf, so think about isPrefixOf and using its result to work out the number of sublists
03:38:51 <kzm> The next person who calls lisp a functional language will be scorned and loathed.  Severely.
03:38:58 * kzm is trying to write an emacs mode.
03:39:04 <ski> which lisp are you talking about ?
03:39:11 <ski> oh
03:39:21 <xerox> ?type foldl (>>=)
03:39:23 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
03:39:31 <xerox> dons -^
03:39:39 <xerox> err, Binkley
03:39:48 <kzm> I kinda expect functions to return something sensible, but I guess I'm spoiled by exposure to functional programming.
03:39:55 <dons> kzm ,heh.
03:40:12 <kzm> So - what's the state of Yi? :-)
03:40:25 <dons> it is a decent vi
03:40:29 <xerox> entangled
03:40:32 * kzm ughs.
03:40:36 <kzm> I'
03:40:40 <dons> its state, it has none! its referentially transparent
03:40:52 <sdf> f [x] [y]  | length y <length x =0
03:40:56 <dons> its not emacs ;)
03:41:06 <dons> sdf, almost
03:41:07 <kzm> 'm writing a small wiki-like mode for Emacs, only local on-disk, nothing web-based or collaborative.
03:41:07 <Binkley> wait, you mean emacs isn't referentially transparent?
03:41:08 <xerox> sdf: f xs ys | length ys < length xs = 0 | ...
03:41:09 <sdf> :)
03:41:09 <Igloo> That must make editing difficult
03:41:10 <Binkley> I'm so disillusioned
03:41:27 <dons> > let f x y | length y < length x = 0 in f "foo" "f"
03:41:28 <lambdabot>  0
03:41:50 <xerox> Binkley: its architecture is *based* on having this programs stealing each other's memory "concurrently"
03:42:05 <dons> Igloo: yes, you have to thread the document around manually ;)
03:42:06 <kzm> I thought it might be neat for simple note taking, etc.
03:42:19 <kzm> Well - off topic here, anyway, and I have to run. BBL.
03:42:21 <sdf> | what is foo?
03:42:31 <dons> its a guard, like an if-then-else
03:42:46 <dons> > let f x y = if length y < length x then 0 else 1 in f "foo" "f"
03:42:47 <lambdabot>  0
03:42:52 <dons> > let f x y = if length y < length x then 0 else 1 in f "foo" "foofarfum"
03:42:52 <sdf> and in f "foo" "F" ?
03:42:55 <lambdabot>  1
03:43:04 <dons> that's the application of the function 'f' to two arguments
03:45:23 <dons> I think dibblego has taught us something valuable here: http://programming.reddit.com/info/qt96/comments
03:45:26 <lambdabot> Title: Maybe in Java (reddit.com), http://tinyurl.com/y6vhwp
03:45:26 <dons> dibblego++
03:46:00 <Binkley> @remember dons Java's type system is unsuitable for young children, the elderly or infirm of constitution
03:46:06 <dons> heh
03:46:46 <Binkley> but yes, dibblego did teach us something valuable: it takes 20 lines to define in Java what can be defined in one line of Haskell :-)
03:48:24 <sdf> f :: [Char] -> [Char] -> Int // f [] [] = 0//f [] [y] = 0//f [x] [] = 0//          f [x] [y]  if length x > length y =0// else sth I cant find :)
03:48:28 <dozer> hi
03:49:08 <dozer> If I'm writing lots of functions of the form (a,b) -> (a,c) where a is some sort of accumulator, and then chaining these together, presumably I should be thinking of using a monad?
03:49:40 <Elifant> State monad, probably
03:49:43 <sdf> dons I have problem with that sth..
03:49:50 <dons> ?paste
03:49:50 <lambdabot> http://paste.lisp.org/new/haskell
03:49:51 <dozer> a in this case is gathering assumptions that need to be recorded in transforming b->c
03:50:12 <Elifant> btw, is ErrorT Exception (State MyState) an instance of (MonadState MyState)?
03:50:15 <ski> "please talk to your son or daughter about parametric polymorphism"
03:50:16 <sdf> paste how?
03:50:17 <lisppaste2> dons pasted "sdf hints" at http://paste.lisp.org/display/29887
03:50:26 <xerox> dozer: newtype State s a = State { runState :: s -> (a,s) }
03:50:26 <dons> sdf ^^ :)
03:50:32 <dons> ski, heh
03:50:33 <xerox> dozer: do you know record syntax?
03:50:48 <dozer> xerox: thx
03:51:02 <dozer> xerox: only used it for datat constructors
03:51:05 <xerox> dozer: that's how Control.Monad.State(.State) is defined
03:51:27 <dons> ?remember ski please talk to your son or daughter about parametric polymorphism
03:51:32 <xerox> dozer: so you get a function runState :: State s a -> s -> (a,s) to run your stateful computations, ok?
03:51:50 <dozer> thanks - will have a play with that
03:51:51 <ski> dons : the saying is from Dave Benjamin
03:51:59 <ski> (usenet)
03:52:04 <dons> ah nice.
03:52:06 <xerox> dozer: now, there is this b from which you construct a c, which is somewhat nasty :)
03:52:22 <Elifant> dozer, here is an example with State monad: http://www.nomaware.com/monads/html/statemonad.html
03:52:24 <lambdabot> Title: The State monad, http://tinyurl.com/yldt3d
03:52:29 <dons> sdf, note that we can merge:
03:52:30 <dons> f [] [] = 0
03:52:31 <dons> f [] y  = 0
03:52:33 <dons> to be just:
03:52:36 <dons> f [] y  = 0
03:52:48 <xerox> even this! f [] _ = 0
03:52:51 <dons> since the 'y' matches any list
03:52:59 <dons> and indeed, yes! we can just use a wildcard
03:53:02 <Syzygy-> _
03:53:06 <Syzygy-> f [] _ = 0
03:53:07 <ski> f [] y@_ = 0
03:53:30 * ski wonders whether '_@y' is a valid pattern
03:53:33 <xerox> f [] = const 0
03:53:44 <lisppaste2> dons annotated #29887 with "more hints" at http://paste.lisp.org/display/29887#1
03:53:53 <dons> > f _@y = y in f 87
03:53:54 <lambdabot>  Parse error
03:54:05 <ski> xerox : but, you can't have different arity for several equations/clauses ..
03:54:07 <dons> > f y@_ = y in f 87
03:54:08 <lambdabot>  Parse error
03:54:15 <ski> 'let' ..
03:54:15 <dons> >  let f _@y = y in f 87
03:54:15 <lambdabot>  Parse error
03:54:16 <xerox> ski: auhm.
03:54:25 <dons> >  let f y@_ = y in f 87
03:54:26 <lambdabot>  87
03:54:31 <ski> (:
03:54:34 <dons> huh, i'd almost have bet that _@y was valid
03:54:49 <dons> let's campaign for it! ;)
03:54:49 <sdf> I havnt been taught isPrefixOf and we are not allowed to use it...
03:55:00 <xerox> > let f [] = const 0; f xs = \ys -> xs ++ ys in f "sk" "i"
03:55:01 <lambdabot>  add an instance declaration for (Num [Char])
03:55:01 <lambdabot>   In the definition of `mdz'...
03:55:04 <dons> sdf, hmm. ok. you'll need to write your own version of it then
03:55:06 <xerox> argh, silly me.
03:55:08 <ski> the left of '@' apparently should be an identifier (not a general pattern, e.g.)
03:55:16 <xerox> > let f [] = const "foo"; f xs = \ys -> xs ++ ys in f "sk" "i"
03:55:17 <lambdabot>  "ski"
03:55:22 <xerox> hee hee.
03:55:30 <dons> sdf, this might give you some hints:
03:55:31 <dons> isPrefixOf [] _         =  True
03:55:31 <dons> isPrefixOf _  []        =  False
03:55:32 <dons> isPrefixOf (x:xs) (y:ys)=  x == y && isPrefixOf xs ys
03:55:36 <ski> > let f [] = const "foo"; f xs = (xs ++) in f "xer" "ox"
03:55:37 <lambdabot>  "xerox"
03:55:46 <xerox> ski: beaten on my own ground!
03:56:04 * xerox goes back to linear algebra....
03:56:18 <ski> xerox : writing '(++)','foldr','foldl' in that style is fun
03:56:21 <xerox> (test tomorrow)
03:56:28 <dozer> thx xerox, looks like the state monad is precicely what I need today
03:56:48 <xerox> dozer: cool, feel free to ask if you get stuck
03:57:02 <ski> http://www.rbjones.com/rbjpub/philos/classics/leibniz/monad.htm
03:57:05 <lambdabot> Title: THE MONADOLOGY, http://tinyurl.com/skuke
03:57:40 <xerox> you just experienced the "help the random newcomer" frenzy we have here in #haskell.
03:57:48 <ski> "Further, there is no way of explaining how a Monad can be altered in quality or internally changed by any other created thing"
03:57:51 <dons> so many memories.
03:57:59 <xerox> haha.
03:58:02 <ski> xerox : though i think i've seen dozer before ..
03:58:12 <dons> i should photocopy my cover of the monadology. there's lots of great quotes to take out of context
03:58:15 <xerox> ski: sdf :)
03:58:19 <dons> about monads being indivisble and so on
03:58:53 <dozer> yeah, my day job is Java, but I dabble in haskell
03:59:30 <ski> "Indeed, each Monad must be different from every other" <- you see ? *must* !
04:00:02 <dons> leibniz was 100s of years ahead of the curve
04:00:29 <dons> i wouln't be surprised if there's some secret code for monad transformers and comonads in there somewhere
04:00:47 <xerox> stuff for the next icfp
04:00:49 * ski is finding some
04:01:24 <ski> "But, besides the principle of the change, there must be a particular series of changes [un detail de ce qui change], which constitutes, so to speak, the specific nature and variety of the simple substances."
04:01:30 <ski> "This particular series of changes should involve a multiplicity in the unit [unite] or in that which is simple"
04:01:38 <dons> mm!
04:01:38 <xerox> return :: a -> m a
04:01:38 <ski> that's bind and return, obviously
04:01:42 <xerox> haha
04:01:49 * xerox falls over the chair
04:01:53 <dons> yep.
04:02:11 <dons> and people ask what the connection between leibniz's monads and category theory are!
04:02:37 <sdf> help...!!!
04:03:08 <dozer> sdvf: is that just general I'm drowning help!!!?
04:03:09 <dons> sdf, you need to take that defintion of isPrefixOf, load it up in ghci or hugs, and play around with it
04:03:16 <dons> understand how it works.
04:03:34 * xerox wants to write a lambdabot plugin
04:04:06 <dons> sdf, we can't write the code for you. but we can point you in the right directoin
04:04:12 <dons> but the steps there you *have* to make yourself
04:04:25 <xerox> it is an interpreter, but it is really cool... no spoilers
04:04:44 <dons> hmm. interesting..
04:05:48 <sdf> I knoww...but my hugs doesnt have isPrefixOf
04:05:54 * xerox writes a post-it
04:06:01 <sdf> :(
04:06:14 <xerox> use ":also List"
04:06:23 <sdf> :((((((((((
04:06:36 <xerox> sdf: do you have written .hs module?
04:06:54 <dons> sdf, yes it does!
04:06:55 <xerox> add "import Data.List" after "module Whatever where"
04:06:58 <dons> Hugs.Base> :l Data.List
04:06:58 <dons> Data.List> :t isPrefixOf
04:06:58 <dons> isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:06:58 <dons> Data.List> isPrefixOf "f" "fffoo"
04:06:58 <dons> True
04:07:23 <xerox> argh, food.
04:07:46 <sdf> lsoargh,solution
04:08:05 <sdf> my hugs doesnt know what is doing
04:08:14 <dons> sdf, what is it doing? :)
04:08:58 <sdf> it does stuff with lists but not those that I need and I mean isPrefixOf
04:09:09 <dons> did you run the above commands?
04:09:13 <dons> :l Data.List
04:09:16 <dons> for example?
04:09:21 <dons> ?paste
04:09:22 <lambdabot> http://paste.lisp.org/new/haskell
04:09:48 <sdf> unable to open file data
04:09:57 <sdf> sorry,Data
04:10:36 <lisppaste2> dons pasted "hugs transcript for sdf" at http://paste.lisp.org/display/29888
04:10:56 <dons> sdf, look at the transcript carefully ^^
04:11:11 <sdf> ok wait a sec
04:13:04 * xerox waves goodbye
04:14:12 <sdf> to be honest  "undefined variable" and "cannot open file"
04:15:06 <sdf> came up all the time
04:16:23 <Igloo> sdf: What version of hugs do you have?
04:17:08 <sdf> how can I learn this?
04:17:15 <Igloo> It says when you start it
04:17:24 <dons> sdf, undefined variable will happen if you mistype the function name
04:17:28 <dons> and haskell []
04:17:49 <dons> and "cannot open file" if you get the module name wrong
04:17:53 <sdf> haskell 98 version November 2002
04:18:00 <dons> sdf, can you paste a transcript of what you're doing?
04:18:05 <dons> oh, that's a very old version of hugs too
04:18:11 <dons> (not that that should matter)
04:18:50 <Igloo> You might need to :l List instead of Data.List
04:20:02 <sdf> ERROR "Data.List" - Unable to open file "Data.List
04:20:18 <sdf> that is when I type :l Data.List
04:20:22 <dons> could you perhaps install a newer version of hugs?
04:20:29 <dons> try the 2005 or 2006 hugs versions
04:20:32 <Binkley> try :l List instead
04:20:40 <dons> or try that.
04:21:09 <Binkley> although it would probably be better to install a newer version of hugs, ultimately
04:21:54 <sdf> well I dont have time to do this  but can I solve my exersise without isPrefixOf?
04:22:02 <dons> does :l List work?
04:22:16 <dons> and yes, you can . just reimplement isPrefixOf, its 3 lines (I paste them above)
04:22:21 <sdf> yep I can see this : List>
04:22:35 <dons> ok. now try:   :t isPrefixOf
04:23:21 <sdf> isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:23:38 <dons> so you have it :)
04:23:46 <sdf> :):)
04:23:50 <dons> now you can use it. you'll need to: import List   in your code
04:24:00 <dons> (your old hugs is using the haskell98 modules only, it seems)
04:24:07 <Syzygy-> dons: Haskell to Javascript? Sounds icky... :P
04:24:10 <dons> heh
04:24:16 <dons> sounds useful!
04:24:43 <sdf> how  to import list?
04:24:58 <Syzygy-> dons: Didn't you post it to reddit? I thought I saw dons there...
04:25:01 <dons> in your source file, you add the line:   import List
04:25:13 <dons> Syzygy-: ah yes.
04:25:20 <sdf> in the beginning before f :: etc?
04:25:39 <dons> yep.
04:25:46 <dons> do you have a haskell tutorial or book?
04:25:55 <dons> it will *really* help
04:26:00 <Turks> Morning..
04:26:03 <dons> start on http://haskell.org
04:26:05 <lambdabot> Title: Haskell - HaskellWiki
04:29:34 <sdf> oh god I have to give the exersise tomorrow and  I dont have a book if anyone has any idea how can I do this without tutorials(I dont have time to study) and import lists and weird functions please help
04:30:15 <sdf> it has to be sth recursive but I dont know  how to compare [Char]..
04:31:46 <sdf> it has recursive,f :: [Char] -> [Char] -> Int
04:31:48 <sdf> 	exampl:
04:31:50 <sdf> 	Input : ['a','b','a'] ['a','b','a','b','a','a','a','b','a'] output :3
04:32:31 <Syzygy-> > 'a' == 'a'
04:32:32 <lambdabot>  True
04:32:41 <Syzygy-> > compare 'a' 'a'
04:32:42 <lambdabot>  EQ
04:32:47 <Syzygy-> > compare 'a' 'b'
04:32:48 <lambdabot>  LT
04:33:04 <roconnor> > 'a' < 'b'
04:33:05 <lambdabot>  True
04:33:43 <Syzygy-> sdf: If you don't want to work with the libraries available, then start out by writing one function that compares two lists to see if the first is the prefix of the second, and then use the functio nyour wrote and the ideas that came previously to use it.
04:33:48 <roconnor> > 'b' `mem` ['a'..]
04:33:49 <lambdabot>  Not in scope: `mem'
04:33:51 <sdf> compare ['a','b','a']  with a,b,a of 2nd list then with b,a,b then with a,b,a and so on
04:34:09 <Igloo> YM elem
04:34:12 <Syzygy-> sdf: Nonono, you'll have to write something that runs through the lists and compares them...
04:34:39 <sdf> yep in that specific way
04:34:52 <sdf> in threesums
04:35:32 <Syzygy-> No, you can do better than that - and moretransparent to read.
04:35:53 <Syzygy-> sdf: dons has given you a LOT of help. Just read back, consolidate what he's told you, and put it all together.
04:36:58 <sdf> OK I will try ,and update hugs too!! thanx for the help all of you!
04:41:07 <SamB> > isPrefix "aba" "ababaaaba"
04:41:08 <lambdabot>  Not in scope: `isPrefix'
04:41:17 <SamB> @hoogle prefix
04:41:18 <lambdabot> Distribution.Simple.Configure.prefix :: LocalBuildInfo -> FilePath
04:41:18 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
04:41:18 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
04:41:23 <SamB> hmm...
04:41:40 <ski> > "aba" `isPrefixOf` "ababaaaba"
04:41:41 <SamB> > "ababaaaba" `startsWith` "aba"
04:41:42 <lambdabot>  True
04:41:42 <lambdabot>  Not in scope: `startsWith'
04:41:45 <SamB> oh
04:41:49 <SamB> okay ;-)
04:42:07 * SamB thought it was something like that...
04:46:15 <robreim> Where's the darcs repository for the haskell standard libraries?
04:46:24 <sdf> :e
04:46:35 <sdf> oops sorry :)
04:46:42 <robreim> oh wait... I think I just found them...
04:47:09 <SamB_XP> @hoogle Kleisli
04:47:10 <lambdabot> Control.Arrow.Kleisli :: a -> m b -> Kleisli m a b
04:47:10 <lambdabot> Control.Arrow.Kleisli :: newtype Kleisli m a b
04:47:10 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
04:47:15 <SamB_XP> hmm...
04:47:23 <SamB_XP> that isn't a type synonym...
04:47:43 <dons> ?source Data.List
04:47:43 <lambdabot> http://darcs.haskell.org/packagesbase/Data/List.hs
04:47:46 <dons> robreim: ^^
04:47:53 <dons> hmm. is there a missing /
04:48:05 <dons> sjannsen's patch must have moved that out
04:48:41 <SamB_XP> eek
04:48:50 <robreim> darcs.haskell.org. Of course. I should have tried that from the start *slaps head*
04:48:52 <robreim> thanks :)
04:51:03 <SamB_XP> @type runState (((\x -> return (x+1)) >>> (\y -> return (y*2)) 3) ()
04:51:05 <lambdabot> parse error (possibly incorrect indentation)
04:51:15 <SamB_XP> @type runState (((\x -> return (x+1)) >>> (\y -> return (y*2))) 3) ()
04:51:17 <lambdabot> forall b (m :: * -> *). (Monad m, Num (m b), Num b) => (m b, ())
04:51:34 <SamB_XP> dons: that somehow does not look right to me.
04:52:25 <ski> numeric monads, yay !
04:53:54 <ski> @type runState ((Kleisli (\x -> return (x+1)) >>> Kleisli (\y -> return (y*2))) `runKleisli` 3) ()
04:53:56 <lambdabot> forall a. (Num a) => (a, ())
04:54:11 <ski> @type evalState ((Kleisli (\x -> return (x+1)) >>> Kleisli (\y -> return (y*2))) `runKleisli` 3) ()
04:54:13 <lambdabot> forall a. (Num a) => a
04:55:22 <ski> @type evalState ((pure (+1) >>> pure (*2)) `runKleisli` 3) ()
04:55:24 <lambdabot> forall b. (Num b) => b
05:32:10 <sdf> can we initialise variables in haskell just like in C or pascal?
05:32:17 <sdf> eg: int i=0;
05:32:43 <beelsebob> no
05:32:50 <beelsebob> variables are not initialised
05:32:56 <beelsebob> because there is no sequence of events
05:33:10 <beelsebob> you do not know what order your program will be executed in
05:33:15 <beelsebob> instead, variables are bound
05:33:33 <Lemmih> > let i = 0 in i
05:33:35 <lambdabot>  0
05:33:43 <beelsebob> you make a binding e.g. i = 0, and for the entire duration of the program i is 0
05:34:18 <beelsebob> and as Lemmih has just pointed out, you can limit the scope of making such a binding - so let i = 0 makes i 0 for all the declarations with the 'in' block
05:34:27 <beelsebob> sorry, the expression is the in block
05:35:14 <mauke> > let int :: (Monad m) => Int -> m Int; int = return in do { i <- int 0; return i }
05:35:14 <lambdabot>  add an instance declaration for (Show (m Int))
05:35:49 <ski> (another way to look at it is that you can, indeed *have*to*, initialize variables .. but you can't assign to variables)
05:36:09 <beelsebob> yes...
05:36:17 <beelsebob> but you're not quite initializing them
05:36:25 <beelsebob> in that you can say i = 0 at the end of the file
05:36:37 <beelsebob> and even at the beginning of the file, i will have been set to 0
05:37:02 <beelsebob> @hoogle a -> [(a,b)] -> [b]
05:37:03 <lambdabot> No matches, try a more general search
05:37:08 <ski> that's just a question of when it is initialized
05:37:16 <beelsebob> @hoogle a -> [(a,b)] -> Maybe b
05:37:17 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
05:37:24 <ski> (or rather, what its scope is)
05:37:36 <beelsebob> hmm, is there a lookup that will return all matches instead of just one?
05:37:46 <ski> @type find
05:37:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
05:37:52 <ski> hm
05:38:00 <ski> @hoogle find
05:38:01 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
05:38:01 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
05:38:01 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
05:38:03 <beelsebob> ski: yes, but from a C programmers perspective, i will not be initialized until the end of the file
05:38:39 * ski thought there were some .. but can't recall what it's named
05:39:00 <xinming> I'd say haskell is a template language indead of a programing language. :-P
05:39:27 <ski> @type filter . (==)
05:39:28 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
05:40:01 <mauke> @pl \k -> map snd . filter ((k ==) . fst)
05:40:02 <lambdabot> (map snd .) . filter . (. fst) . (==)
05:40:38 <ski> beelsebob : iirc Java won't let you access a (method-local) variable, until it has been initialized
05:40:56 <beelsebob> ski: exactly
05:41:01 <beelsebob> ski: Haskell will
05:41:11 <beelsebob> not only that, but it's been initialized even though it hasn't
05:41:21 <ski> huh ?
05:41:22 <beelsebob> (from an imperative programmers perspective)
05:41:50 <roconnor> circular programming with let expressions?
05:41:50 <Binkley> "it's been initialized even though it hasn't"?
05:41:52 <beelsebob> from an imperative programmers perspective... if I were to do:
05:41:52 <beelsebob>  f x = x + i
05:41:52 <beelsebob> i = 5
05:42:04 <xinming> beelsebob: What the function in haskell is nothing instead of templates
05:42:05 <beelsebob> i has not been initialized in the definition of f
05:42:15 <beelsebob> but it has
05:42:18 <xinming> beelsebob: No...
05:42:21 <beelsebob> i is always initialised
05:42:25 <beelsebob> (or rather, it's bound)
05:42:33 <Binkley> beelsebob: no, it's that the evaluation mechanism is different
05:42:46 <xinming> It means when you refer to i, You always get 5,
05:42:49 <beelsebob> indeed
05:42:55 <ski> beelsebob : iirc, toplevel variables in C are evaluated at compile-time
05:42:57 <beelsebob> my point is that this is *not* initialisation
05:43:14 <xinming> beelsebob: Don't stick your mind in imperative programming language.
05:43:20 <Binkley> well, yeah; it doesn't really make sense to talk about initialization in a language without side effects
05:43:20 <xinming> beelsebob: haskell is all different...
05:43:21 <beelsebob> there is no initialisation because there is no direction of computation in a functional program
05:43:35 <beelsebob> xinming: I do know this, I am writting a debugger for it
05:43:37 <ski> Binkley : how about pure prolog ?
05:43:44 <xinming> >_<
05:43:45 <Binkley> ski: what about it?
05:44:00 <xinming> beelsebob: Ok, sorry, I'm newbie. But I ever thought you might be newer than me... :-P
05:44:01 <ski> Binkley : does it make sense to talk about initialization there ?
05:44:07 * xinming shuts up.
05:44:10 <Binkley> ski: I don't think so; not if it's pure
05:44:38 <Binkley> but I don't know much about Prolog, so maybe there's some way to define "initialization" that makes sense in Prolog
05:44:42 <ski> Binkley : but there can still be restrictions depending on initialization
05:44:49 <beelsebob> xinming: np, don't shut up, sorry, I didn't mean to say "don't try to correct me" I meant to say " yes, I know, I'm just saying what an imperative programmer would understand that as"
05:44:55 <beelsebob> ski: my point is that there is a difference between a binding, and a initialisation
05:45:02 <beelsebob> you can't initialise something if there is no start
05:45:04 <ski> ?- X = 2,Y is X + 3.
05:45:05 <lambdabot> Maybe you meant: . v
05:45:06 <beelsebob> or initial thing
05:45:10 <ski> X = 2, Y = 5
05:45:18 <ski> ?- Y is X + 3,X = 2.
05:45:18 <lambdabot> Maybe you meant: . v
05:45:32 <ski> run-time instantiation error
05:46:21 <ski> that's a difference depending on whether 'X' is initialized or not
05:46:54 <ski> beelsebob : could you elaborate that last you said ?
05:47:24 <beelsebob> ski: the word initialize implies that you give something it's "initial" value... not that you make it permanantly that value
05:47:34 <beelsebob> there is no set time at which you give the variable that value
05:47:40 <beelsebob> it always has the value and always will
05:47:43 <beelsebob> it is bound
05:47:46 <ski> there is in prolog
05:47:55 <beelsebob> yes... but we were talking about Haskell
05:47:58 <ski> even though it will always be that value
05:48:35 <ski> if you want, you can say that first a prolog variable is initialized to unknown value .. and some time later, we may get to know what the value it is initialized to actually is
05:48:49 <beelsebob> sure, in prolog
05:48:57 <beelsebob> in haskell though a variable is not initialised
05:48:59 <beelsebob> it is bound
05:49:12 <ski> *and* (lazily) initialized, i'd say
05:49:30 <beelsebob> no, there is no initialisation, because it's evaluation is the same always
05:49:44 <beelsebob> if I have the line "x = doSomeReallyComplicadStuff"
05:49:58 <beelsebob> then doSomeReallyComplicatedStuff is only done when needed
05:50:00 <ski> the evaluation to WHNF could be thought of as initialization
05:50:06 <beelsebob> it's not initialised
05:50:13 <beelsebob> it could be
05:50:18 <beelsebob> but it would be incorrect and inacurate
05:50:20 <Philippa> having a thunk at all, that's initialisation
05:50:23 <ski> why ?
05:50:35 <beelsebob> Philippa: no, that's existing - that's binding
05:50:38 <ski> Philippa : the thunk is an implementation detail
05:50:49 <beelsebob> ski: because there is no point at which the variable is initiallised
05:50:56 <beelsebob> it always has had and always will have the value
05:51:08 <ski> beelsebob : how about when it is evaluated ?
05:51:17 <beelsebob> that's an implementation detail
05:51:22 <Philippa> beelsebob: I think the point I'm making is that "initialisation" is an implementation detail
05:51:27 <beelsebob> in terms of the concept it always has had the value
05:51:31 <ski> (Philippa : hm, that wasn't right, let me try to rephrase ..)
05:51:57 <ski> Philippa : yes
05:53:04 <dylan> 3
05:53:14 <ski> Philippa : (rephrasing) setting the thunk is telling the system what it would compute to initialize the variable, in my language here
05:53:44 <ski> (s/language/language usage/)
05:54:05 <beelsebob> ski: yes, and as you rightly point out it's an implementation detail... as is any form of initialization... I could have a mystical implementation that actually does have the defined variables always bound from begining to end
05:54:39 <ski> i guess a point i'm trying to make is that binding doesn't need to be done at same time as initialization .. it can even be logically decoupled, like Prolog,Oz
05:55:03 <ski> i.e. that there's a point to talk about initialization
05:55:09 <beelsebob> but there isn't
05:55:15 <beelsebob> because it's an imlementation detail
05:55:23 <ski> there isn't what ?
05:55:28 <beelsebob> I can have an implementation that doesn't do any initialisation
05:55:38 <beelsebob> thus it's pointless to talk about initialisation
05:55:44 <roconnor> is -> left associative or right associative?
05:55:48 <ski> what are you thinking of ?
05:56:02 <ski> roconnor : if you mean the type constructor, then right-associative
05:56:18 <beelsebob> ski: there is a mystical implementation in which the program runs for all eternity, and the bound variables are always set
05:56:26 <beelsebob> they are never initialised
05:56:29 <beelsebob> they are just always there
05:56:34 <ski> 'set' means ?
05:56:41 <beelsebob> bound
05:56:57 <ski> ok, either they are initialized at program start
05:57:09 <beelsebob> my program could have been running forever
05:57:14 <beelsebob> and indeed continue to run forever
05:57:17 <beelsebob> with all the variables bound
05:57:21 <ski> or (if you say the program didn't start), they always were initialized
05:57:24 <beelsebob> they were never initialised
05:57:30 <beelsebob> they were always bound
05:57:40 <beelsebob> they were just there at the beginning of time
05:57:40 <ski> 'bound' is a lexical property
05:57:47 <beelsebob> no it isn't
05:57:57 <Philippa> what is this time of which you speak?
05:58:05 <beelsebob> exactly Philippa
05:58:12 * beelsebob must go teach
05:58:14 <beelsebob> see you later
05:58:17 <ski> whether a variable is bound or not (relative to an expression) can be determined without running the program
05:58:51 <Philippa> lexical != syntactic
05:59:14 <ski> which difference is relevant here ?
06:00:02 <Philippa> you need grammatical awareness, not just lexical
06:00:32 <ski> i'm using 'lexical' as in 'lexical scope', here
06:03:08 <ski> (anyway, yes i'm talking partly about operational semantics, when i'm talking about initialization .. but e.g. in a language like Prolog or Oz, this separation of binding and initialization can make a real difference in what you can express, irregardless of implementation)
06:05:45 <eviltwin_b> a haskell program is a system of equations; running that program reduces the system of equations.  but being a system of euations, there is no state.
06:05:51 <ski> beelsebob : already done teaching ?
06:06:09 <beelsebob> nope, in the class - checking that none of my students are in IRC :P
06:06:26 <eviltwin_b> the evaluator has state but tht's not visible either inside the system of equations or (barrng a debugger running on the runtime) outside of the evaluator
06:06:40 <ski> eviltwin_b : how about taking the current state of the reduced equation system ?
06:07:03 <eviltwin_b> any valid reduction produces an equivalent state
06:07:07 <ski> eviltwin_b : yes
06:07:08 <ski> eviltwin_b : yes
06:07:24 <eviltwin_b> so the concept of "current state" is meaningless
06:07:48 <eviltwin_b> (now, monads, in particular IO, do have state --- but accessing that is restricted by design)
06:08:31 <ski> eviltwin_b : the current state of the implementaion is not meaningless, though
06:08:41 <ski> (and that's the one i was partly talking about)
06:08:50 <eviltwin_b> in fact you can't really acess it; the whole point of monads is encoding state as functional transformations so the actual state can remain hidden inside the evaluator
06:09:01 <eviltwin_b> it's no meaningless but it's also not accessible
06:09:13 <ski> indeed
06:09:27 <eviltwin_b> <eviltwin_b> the evaluator has state but tht's not visible either inside the system of equations or (barrng a debugger running on the runtime) outside of the evaluator
06:10:12 <ski> i'd say it is visible 'inside the system of equations', since that to me means inside the evaluator/implementation (e.g. using a debugger)
06:10:49 <dblhelix> @seen dcoutts
06:10:49 <ski> .. i guess someone would say we're arguing semantics now
06:10:50 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 10h 26m 49s ago.
06:11:02 <eviltwin_b> no, my intent by "inside the system of equations" is within the program itself.  haskell doesn't let you introspect the evaluator, so its state is not visible
06:11:04 <dblhelix> dcoutts: ping
06:11:28 <dblhelix> or:
06:11:36 <dblhelix> dcoutts_: ping
06:12:39 <ski> eviltwin_b : yes, i see now you meant that
06:12:55 <Binkley> I think you've been arguing semantics the whole time :-)
06:13:28 * ski must admit to not knowing what 'arguing semantics' really mean
06:13:43 <Binkley> well, the problem is that idiomatically, people use "arguing semantics" to mean "arguing something trivial"
06:13:44 <eviltwin_b> "what does 'is' mean?"
06:13:54 <Binkley> but of course semantics means "meaning", so there's nothing trivial about it. semantics is everything.
06:14:26 <ski> it seems to at least sometimes mean "argue about definitions (explicitely or implicitely)"
06:14:37 <ski> (which i think was partly what we did above)
06:14:55 <ski> (Binkley : exactly :)
06:15:39 <psykotic> the trivial semantics (where a term is its own denotation) is rather trivial!
06:17:27 <ski> in haskell you could either say a variable is lazily initialized when it is bound (in which case there's not much to talk about, since this always holds)
06:17:35 <ski> or you could say it is initialized when it is evaluated (to WHNF, say), in which case it shouldn't affect semantics (of course), but can affect efficiency
06:18:04 <beelsebob> ski: no
06:18:06 <beelsebob> there is no when
06:18:14 <beelsebob> a computation of haskell has no concept of time
06:18:27 <ski> in Oz you can have one thread create a structure with uninitialized variables, and another thread initialized these variables (and note that this is declarative concurrency .. no side-effects)
06:18:46 <beelsebob> you cannot have an initial value if there is no time
06:18:54 <ski> beelsebob : as i say above, i'm partly talking about implementation here, and there there's certainly a concept of time, no ?
06:18:56 <beelsebob> it is an implementation detail that the computation takes time
06:18:57 <psykotic> beelsebob, 'when' can be said to exist in an operational semantics.
06:19:24 <beelsebob> psykotic: that's why that's a bad representation of a haskell computation
06:19:43 <ski> why's it bad ?
06:19:52 <beelsebob> because it includes a concept of time
06:19:55 <beelsebob> which there should not be
06:19:58 <ski> one can reason on different operational levels
06:20:22 <ski> this level is at the level of detail wrt our machines that it includes time, in this sense
06:20:24 <beelsebob> any description of the semantics of haskell should accurately describe the fact that there is no concept of time
06:20:47 <ski> beelsebob : i'd say that, time, if it exists, doesn't matter
06:20:59 <beelsebob> ski: in that case you've brought in an implementation detail that you're running it on an imperative machine
06:21:08 <beelsebob> of course initialisation makes sense in an imperative world
06:21:14 <beelsebob> it doesn't in a functional world though
06:21:24 <ski> surely a description of haskell doesn't *have* to include any concept of time .. i'm arguing that it *can*
06:21:35 <beelsebob> no, it can't
06:21:40 <beelsebob> because then it's not haskell
06:21:40 <ski> beelsebob : yes, exactly, that's what i'm doing
06:21:45 <beelsebob> it's haskell on an imperative machine
06:21:49 <ski> yes
06:22:07 <ski> remember, i'm talking about implementation / operational semantics
06:22:07 <beelsebob> in terms of someone learning what it means, they shouldn't know about such implementation details
06:22:16 <ski> agree
06:22:29 <beelsebob> so the original question about whether you could initialise a variable...
06:22:32 <beelsebob> the answer is no
06:22:34 <beelsebob> you can bind one
06:23:03 * ski admits he forgot the original question :)
06:23:06 <beelsebob> sdf: can we initialise variables in haskell just like in C or pascal?
06:23:06 <beelsebob> sdf: eg: int i=0;
06:23:06 <beelsebob> beelsebob: no
06:23:27 <CrewdenX> beelsebob: so, did you read the entire series? =)
06:23:31 <ski> (and i didn't dispute your answer, i think)
06:23:32 <Binkley> but to understand why, you need a BA in philosophy
06:23:57 <beelsebob> ski... I think it all decended from this statement...
06:23:57 <beelsebob> ski: (another way to look at it is that you can, indeed *have*to*, initialize variables .. but you can't assign to variables)
06:24:10 <ski> yes .. "another way to look at it is .."
06:24:11 <beelsebob> I didn't like the fact that you said you initialised things
06:24:15 <beelsebob> because you don't
06:24:18 <psykotic> what about the single-assignment view from logic programming?
06:24:23 <beelsebob> it's a flawed way of looking at things
06:24:45 <psykotic> there are multiple useful ways of thinking about something.
06:25:22 <vincenz> no there are not
06:25:26 <vincenz> only my way
06:25:38 <ski> (and that sentence was intended as an useful imperative intuition of how an imperative implementation could work, so as to get a comparision which what the OP knew before)
06:25:54 <psykotic> another example is something like continuations.
06:26:00 <ski> psykotic : i've brought that one up, yes :)
06:26:02 <psykotic> i personally find it useful to be able to think about them on a number of levels.
06:26:10 <ski> (logic programming, i.e.)
06:26:22 <psykotic> ski: ah sorry, i didn't read all of the backscroll.
06:26:22 <beelsebob> ski: you see I don't think it is - because from an imperative point of view, you go from the top of the file to the bottom of the file... that's not a view you want to reinforce
06:26:42 <beelsebob> you want to remove as much of a concept of time from the world as you can
06:26:53 <beelsebob> so saying you can initialise things is not useful
06:27:25 <Philippa> beelsebob: that's not true
06:27:33 <beelsebob> hmm?
06:27:36 <ski> beelsebob : i wasn't talking about how things are usually done in imperative languages .. but how you could imperatively think about haskell (i.e. like a strange imperative language (that also happens to now allow side-effects))
06:27:39 <Philippa> you're confusing imperative languages and single-pass compilers
06:27:52 <Philippa> you don't necessarily go from the top of the file to the bottom
06:28:12 <psykotic> speaking of 'arguing semantics'... :)
06:28:22 <beelsebob> hehe :P ture enough Philippa
06:28:49 <ski> psykotic : hm, how should continuations relate to binding and initialization, you mean ?
06:29:21 <psykotic> ski: sorry, it was meant as another example of a subject that can be regarded profitably from several vantage points.
06:29:28 <ski> (ah, ok)
06:30:06 <ski> (s/now allow/not allow/)
06:32:05 <lesshaste> hi
06:32:23 <lesshaste> in ghci I want to record a session "the commands I type at least and preferably the results"
06:32:26 <lesshaste> how can I do that?
06:32:46 <lesshaste> hmm.. subsitute brackets for the quotes above :)
06:34:40 <psykotic> how about running ghci with 'tee' and filtering out the banner, if that's a problem for you
06:35:31 <lesshaste> sounds good... sorry to be dumb but how exactly would I do that?
06:35:39 <lesshaste> I am not worried about the banner
06:36:22 <sjanssen> copy and paste from your terminal?
06:36:31 <shapr> @users
06:36:32 <lambdabot> Maximum users seen in #haskell: 265, currently: 255 (96.2%), active: 32 (12.5%)
06:37:13 <shapr> lesshaste: Is your nickname derived from the research paper "more haste less speed lazy vs eager evaluation" ?
06:38:08 <sjanssen> > sum . take 8 . iterate (join (+)) $ 1
06:38:10 <lambdabot>  255
06:42:36 <shapr> Oh hey, someone recently emailed me and said they're living in the same city as me and recently picked up an interest in Haskell, so they want to ask me some questions. What's the likelihood?
06:42:58 <Philippa> weirder things have happened
06:43:25 <shapr> It'd be funny to do the #haskell tour in person =)
06:43:28 <beelsebob> > let bisect f a b = (c : if (a > 0 && c > 0) then bisect f c b else bisect f a c where c = (a + b) / 2) intake 6 $  bisect (\x -> 2 * x * exp(-2) + 1 - 2 * exp(-2 * x)) 0.25 0.315
06:43:29 <lambdabot>  Parse error
06:43:33 <beelsebob> where bitch?
06:43:47 <beelsebob> > let bisect f a b = (c : if (a > 0 && c > 0) then bisect f c b else bisect f a c where c = (a + b) / 2) in take 6 $  bisect (\x -> 2 * x * exp(-2) + 1 - 2 * exp(-2 * x)) 0.25 0.315
06:43:47 <lambdabot>  Parse error
06:43:51 <sjanssen> shapr: the odds seem low, especially in the US
06:44:40 <beelsebob> > let bisect f a b = ((a+b) / 2) : if (a > 0 && ((a + b) / 2) > 0) then bisect f ((a + b) / 2) b else bisect f a ((a + b) / 2) in take 6 $  bisect (\x -> 2 * x * exp(-2) + 1 - 2 * exp(-2 * x)) 0.25 0.315
06:44:42 <lambdabot>  [0.2825,0.29874999999999996,0.306875,0.3109375,0.31296875,0.313984375]
06:46:50 <xerox> beelsebob: that's why you were checking whether your students were on #haskell? (:
06:47:10 <beelsebob> > let bisect f a b = (f (a+b) / 2) : if (a > 0 && ((a + b) / 2) > 0) then bisect f ((a + b) / 2) b else bisect f a ((a + b) / 2) in take 6 $  bisect (\x -> 2 * x * exp(-2) + 1 - 2 * exp(-2 * x)) 0.25 0.315
06:47:10 <beelsebob> > let bisect f a b = f ((a+b) / 2) : if (a > 0 && ((a + b) / 2) > 0) then bisect f ((a + b) / 2) b else bisect f a ((a + b) / 2) in take 6 $  bisect (\x -> 2 * x * exp(-2) + 1 - 2 * exp(-2 * x)) 0.25 0.315
06:47:10 * beelsebob pokes lambdabot 
06:47:10 <beelsebob> > let bisect f a b = (f (a+b) / 2) : if (a > 0 && ((a + b) / 2) > 0) then bisect f ((a + b) / 2) b else bisect f a ((a + b) / 2) in take 6 $  bisect (\x -> 2 * x * exp(-2) + 1 - 2 * exp(-2 * x)) 0.25 0.315
06:47:12 <lambdabot>  [0.2534311786064332,0.2781588775517332,0.2900378067854497,0.2958605699492402...
06:47:12 <beelsebob> tum tee tum
06:47:13 <lambdabot>  [-6.025585848639481e-2,-1.9507931567553927e-2,4.277921260760209e-4,1.0288155...
06:47:14 <lambdabot>  [0.2534311786064332,0.2781588775517332,0.2900378067854497,0.2958605699492402...
06:47:24 <xerox> beelsebob: /QUERY lambdabot
06:49:32 <shapr> yow!
06:49:40 <Binkley> @yow
06:49:41 <lambdabot> I wonder if there's anything GOOD on tonight?
06:50:08 <ski> @yarr
06:50:09 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
06:50:20 <Binkley> Hehe lambdabot said "bunghole".
06:51:05 <dylan> @. yow pl
06:51:06 <lambdabot> Sometime in 1993 NANCY SINATRA will lead a BLOODLESS COUP on GUAM!!
06:51:15 <beelsebob> @yar
06:51:16 <lambdabot> Prepare to be boarded!
06:51:18 <dylan> @. pl yar
06:51:19 <lambdabot> compose module failed: IRCRaised Parse error: "yar"
06:51:35 <shapr> @yarr
06:51:35 <lambdabot> This is the END for you, you gutter-crawling cur!
06:51:40 <shapr> @. elite yarr
06:51:40 <lambdabot> 4Y3 Aye cap'n
06:51:55 <shapr> @. pl elite quote
06:51:55 <lambdabot> quOtE
06:52:19 <shapr> How do I compose three or more calls?
06:53:03 <xerox> @state
06:53:04 <lambdabot> Unknown command, try @list
06:53:08 <xerox> no more state?!
06:53:17 <xerox> @. pl . elite quote
06:53:17 <lambdabot> (line 1, column 3):
06:53:18 <lambdabot> unexpected "\\"
06:53:18 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
06:53:20 <xerox> @. pl . elite quote
06:53:20 <lambdabot> (line 1, column 1):
06:53:21 <lambdabot> unexpected "|"
06:53:21 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
06:53:25 <xerox> doesn't quite work shapr :)
06:54:43 <shapr> aww
06:54:52 <shapr> @state alabama
06:54:53 <lambdabot> Unknown command, try @list
06:56:01 <dylan> So, I heard someone in Kansas is working a form of fusion using corn.
06:56:47 <dylan> Soon Kansas will be known as the state of corn fusion.
06:57:30 <dylan> it's a maizing.
06:58:39 <dino-> heh, wow, that's really bad
07:00:08 <xerox> ‽
07:00:19 <dino-> corn pun  :D
07:00:22 <dylan> I don't know why I think of puns all the time.
07:00:25 <dylan> it was a corny joke.
07:01:18 <vincenz> I would say it was rather puny
07:01:35 * therp just recognized: no surprise that his search in GHC fails for "summarize". GHC is British. 
07:02:43 <xerox> ?spell summarize
07:02:44 <lambdabot> summarize
07:02:56 <therp> summarise it is
07:03:00 <xerox> ah!
07:03:28 <therp> that's exactly what I thought :)
07:04:35 <ski> we need more 'z' !
07:05:56 <dylan> move every 'z'?
07:08:00 <ski> like Kagazitzaga, e.g.
07:08:30 <ski> or Tadatizaga
07:09:07 <therp> just use Z-encoding for symbol names.
07:09:50 <Igloo> I remember my chemistry teacher making fun of someone for writing about lazers
07:11:03 <dcoutts> dblhelix, pong
07:11:28 <dblhelix> dcoutts: I've some troubles builing gtk2hs :(
07:12:16 <ski> Bajdokritzaga, Nadgazad
07:12:26 * ski 's having fun looking at Magnamund maps
07:12:53 <dblhelix> dcoutts: configuration succeeds, but then it complains about not being able to find Types.hs (there is a Types.chs, though)
07:13:53 <dcoutts> dblhelix, did c2hs build ok? Are you trying to build 0.9.10 using ghc-6.6 ?
07:14:11 <dblhelix> dcoutts: let's see
07:14:13 <dcoutts> if you're using ghc 6.6 you need the darcs version of gtk2hs
07:14:34 <dblhelix> dcoutts: ah, okay.. let me then check it out from darcs and try again
07:15:35 <dblhelix> ah, only 1140 patches
07:16:21 <dcoutts> dblhelix, use --partial
07:16:28 <dcoutts> darcs get --partial
07:16:36 <dcoutts> the it's only 140 ish
07:16:45 <dblhelix> dcoutts: btw, I could not fetch c2hs from darcs
07:17:09 <dcoutts> dblhelix, oh, there's an issue there we've not fixed yet with case sensitive file names
07:17:20 <dcoutts> so you can't check it out on windows at the moment
07:17:40 <dblhelix> dcoutts: nor on mac os? ;)
07:18:06 <dblhelix> 140ish? 198! :)
07:18:10 <dcoutts> dblhelix, is osx case-insensitive ?
07:18:30 <dcoutts> dblhelix, oh, ok I added a big pile patches the other day :-)
07:18:32 <LoganCapaldo> HFS+ is case insensitive but case preserving
07:18:45 <dcoutts> ok, so same problem as on windows then
07:20:31 <dblhelix> dcoutts: no configure in gt2hs from darcs, is that intended?
07:20:43 <earthy> um, macosx is case-insensitive but case-preserving
07:20:46 <dcoutts> dblhelix, yep, you need to autoreconf
07:20:49 <earthy> but only if you use hfs+
07:20:54 <earthy> it is case-sensitive on ufs
07:20:57 <dblhelix> dcoutts: okay
07:21:06 <earthy> not many people do that though, run mac os x on ufs
07:21:15 <dcoutts> dblhelix, this will be easier when we make the next release :-)
07:22:31 <dblhelix> dcoutts: mmm... seems like the autoconf script needs some m4_pattern_allows...
07:22:59 * dcoutts doesn't know what that means
07:23:15 <dcoutts> but I do know that autoconf is itself a portability problem
07:23:15 <dblhelix> configure.ac:117: error: possibly undefined macro: AC_MSG_ERROR
07:23:15 <dblhelix>       If this token and others are legitimate, please use m4_pattern_allow.
07:23:16 <dblhelix>       See the Autoconf documentation.
07:23:16 <dblhelix> autoreconf: /usr/bin/autoconf failed with exit status: 1
07:23:43 <dcoutts> make sure you're using automake 1.8 or 1.9, and autoconf 2.58 or 59
07:24:15 <dblhelix> autoconf --version
07:24:15 <dblhelix> autoconf (GNU Autoconf) 2.59
07:24:26 <dcoutts> dblhelix, if it's not being happy then I've got a recent snapshot tarball
07:24:38 <dblhelix> automake --version
07:24:39 <dblhelix> automake (GNU automake) 1.6.3
07:24:42 <dblhelix> mmm,,,
07:24:43 <dcoutts> ah
07:25:32 <dcoutts> the result of automake & autoconf is ultra-portable but we do have problems running autoconf & automake on some platforms. It seems to vary a lot.
07:25:41 * dblhelix gets automake 19.6
07:25:46 <dcoutts> dblhelix, sometimes you get multiple version of automake
07:25:48 <dblhelix> /s/19/1.9
07:25:52 <dcoutts> but the default is not the one you want
07:26:10 <dcoutts> eg, try just running automake-1.8 / -1.9
07:26:52 <dblhelix> i've neither one
07:27:09 <dcoutts> dblhelix, here's a snapshot from late october if you need it:
07:27:09 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10.2.tar.gz
07:27:11 <lambdabot> http://tinyurl.com/ycmua5
07:28:01 <dblhelix> dcoutts: tnx, I'll first try to build the one from darcs... if that does not work out, I'll try the snapshot
07:28:51 <dblhelix> okay, autoreconf succeeded now...
07:29:02 <dcoutts> ah good good
07:29:38 <dblhelix> ah... no alex installed
07:29:48 <jgrimes> morning
07:29:49 <lambdabot> jgrimes: You have 1 new message. '/msg lambdabot @messages' to read it.
07:31:03 <dcoutts> dblhelix, ah, yes and happy.
07:31:14 <dblhelix> dcoutts: I built happy last week :)
07:31:31 <dblhelix> alex from darcs: same problem with case-insensitive file names?
07:33:51 * dblhelix is heading for home: will try to further build gtk2hs tonight
07:34:04 <dblhelix> dcoutts: thanks for helping me out
07:34:09 <dcoutts> dblhelix, np
07:34:24 <dcoutts> @pl \h c -> h * 33 + ord c
07:34:25 <lambdabot> (. ord) . (+) . (33 *)
07:42:56 <Turks> Heya
07:54:02 <ptolomy> Sometimes I get the impression that there are people for whom "You can simulate OO with closures!" is a perfectly reasonable solution to a lack of objects while "Closures can be simulated with objects!" is clunky and unacceptable.
07:54:47 <merus> That's weird.
07:56:05 <vincenz> Those bastards
07:56:35 <shapr> ptolomy: I think they're both the same thing.
07:56:43 <LoganCapaldo> And neither closures via objects or objects via closures quite get all the way there
07:57:13 <xinming> BTW, may I ask what the difference between closure and lambda?
07:57:22 <vincenz> ptolomy: Truth be told, most languages that are object-based, simulating closures with objects tend to be clunky
07:57:26 <xinming> and also anonymous function.
07:57:30 <vincenz> but there is no theoretical ruling against ti
07:57:31 <xinming> IMHO, they are the same... >_<
07:57:38 <vincenz> xinming: not so
07:57:47 <vincenz> xinming: only because most languages that support lambda support closures
07:57:59 <vincenz> A closure is a lambda with a saved environment
07:58:20 <xinming> vincenz: ???
07:58:28 <xinming> more precise please.
07:58:31 <vincenz> foo x = \y -> x + y
07:58:34 <vincenz> foo 2 returns a closure
07:58:36 <vincenz> not just a lambda
07:58:39 <vincenz> for it saves the value 2
07:58:43 <LoganCapaldo> A closure is a function (not necessarily anonymous) with one or more free variables that are bound to the functions enclosing scope
07:59:48 <xinming> vincenz: In my understanding, foo 2 would return a anonymous function which does 'plus 2'
08:00:04 <vincenz> yes and therefore it must save the value "2" in a closure
08:00:16 <xinming> yes.
08:00:22 <xinming> then, we can this a closure.
08:00:24 <vincenz> an anonymous function does not do this perse
08:00:38 <vincenz> Except that in most fpl languages, all functions are closures, so the point is moot
08:00:44 <vincenz> erm, fp languages
08:00:57 <LoganCapaldo> (\x -> x + 1) -- No free variables, therefore can't be a closure
08:01:16 <vincenz> LoganCapaldo: it can be a closure, just one without variables
08:01:39 * LoganCapaldo has had this particular argument before, although last time he was on the other side of it
08:01:56 <LoganCapaldo> Is it a closure if it doesn't close over anything?
08:02:11 <vincenz> it can be implemented as a closure
08:02:20 <LoganCapaldo> heh
08:02:21 <xinming> vincenz: in fact, I didn't see lambda in most language except lisp and perl 5, and in perl 5, It's called closure.. and I found, they have the same effect as lambda...
08:02:25 <LoganCapaldo> this is fun
08:02:30 <therp> lgoncapaldo: Is an empty list a list?
08:02:35 <xinming> oops
08:02:40 <xinming> in lisp and haskell
08:02:43 <therp> s/lgon/logan/ sorry
08:02:49 <integral> A "lambda" is usually just an the syntax for an _anonymous_ function.
08:03:09 <integral> eg. in haskell (\x -> x + 1) versus f x = x + 1; They're both closures
08:03:10 <vincenz> except that in haskell and lisp, all functions are automatically closures, but not all languages have support for clsoures
08:03:18 <LoganCapaldo> This is really funny because I had the exact same response "It can be implemented as a closure" when I fought the other way
08:04:52 <xinming> integral: then, Could you please explain the word from vincenz ? :-P
08:05:22 <xinming> or, I just hold one idea of them. and that's enough...
08:05:23 <xinming> :-P
08:05:26 <integral> Pardon?  I didn't say anything about functions or lisp.
08:06:37 <xinming> hmm, Is closure a "dynamic" lambda with value saved?
08:06:53 <xinming> if so, can we call dynamic lambda partial application. :-P
08:07:15 <xinming> they are confusing
08:07:19 <LoganCapaldo> If you put enough "quotes" around it you can call anything anything you want :)
08:08:05 <xinming> LoganCapaldo: well, what I mean is, closure = partial application...
08:08:21 <xinming> dynamic lambda is just a proof... :-P
08:08:36 <LoganCapaldo> xinming: But its not necessarily: let y = 2 in (\x -> x + y)
08:09:07 <LoganCapaldo> Or even (\y -> (\x -> x + y)) 2
08:09:23 <xinming> It's a closure,
08:09:24 <emu> actually that's prototypical of partial application
08:09:26 <LoganCapaldo> Ok that second one is aprtial application
08:09:27 <emu> heh
08:09:54 <xinming> ...
08:10:11 <LoganCapaldo> but afaik the first one isn't partial application
08:10:12 <emu> parameters are substituted by their argument's term.  "closures" are a way of simulating that efficiently.
08:10:36 <LoganCapaldo> but still a closure
08:10:56 <LoganCapaldo> correct me if I am wrong
08:11:02 * xinming thinks that his theoretics isn't enough to understand this. >_<
08:11:37 <vincenz> xinming: look it is simple
08:11:45 <vincenz> a lambda does not save variables from the surrounding scope
08:11:47 <vincenz> a closure does
08:11:59 <vincenz> except that in lisp and haskell, lambda's are implemented as closures
08:12:01 <vincenz> not just nameless functions
08:12:23 <vincenz> closureSet `isSubSetOf` nameless functions
08:12:40 <LoganCapaldo> Does anyone know of a language that has anonymous functions but no closures?
08:13:24 <xinming> C... :-P
08:13:35 <LoganCapaldo> C doesn't have anonymous functions
08:13:39 <vincenz> LoganCapaldo: an older python
08:13:47 <vincenz> ruby most likely
08:13:56 <vincenz> yeah ruby
08:13:57 <LoganCapaldo> ruby has closures
08:13:59 <vincenz> no it doesn't
08:14:06 <LoganCapaldo> yeah it does
08:14:12 <vincenz> or wait, yeah, I'm thinking of continuations
08:14:16 <vincenz> but it didn't always have em
08:14:18 <LoganCapaldo> it has those too
08:14:34 <vincenz> LoganCapaldo: No, I am very ceertain it does not, cause there was this note on how matz does not even want to implement it
08:14:40 <vincenz> you're thinking of stacklelss python
08:14:47 <LoganCapaldo> No, he doesn't want to reimplement it for YARV
08:14:53 <LoganCapaldo> ri callcc
08:14:58 <LoganCapaldo> its in the current impl
08:15:00 <vincenz> ah wlel
08:15:12 <vincenz> anyways, an older version of ruby or python didn't have full closures
08:15:23 <vincenz> boost, most likely does not have full closures
08:15:42 <LoganCapaldo> Does boost count?
08:15:51 * LoganCapaldo ponders
08:15:52 <chessguy> howdy
08:16:25 <vincenz> LoganCapaldo: well sure, if you restrict yourself to languages that made the effort to have closure-full lambdas, then all languages that have lambdas has closures
08:16:39 <LoganCapaldo> No I mean boost is library
08:16:39 <vincenz> But from that perspective, al llanguages have full type-inference, cause the rest don't count
08:16:58 <vincenz> LoganCapaldo: you can see it as a language extension
08:17:08 <LoganCapaldo> I'm wondering if theres a language with a lambda that isn't a closure
08:17:15 <vincenz> isn't that what scheme is all about? language extensions as library
08:17:19 <LoganCapaldo> doesn't create closures rather
08:17:21 <xinming> vincenz:  closureSet `isSubSetOf` nameless functions  <--- Is lambda also a subset of nameless functions please?
08:17:24 <vincenz> LoganCapaldo: again, older rubies and pythons
08:17:38 <vincenz> xinming: lambda is just syntax for namelelss functions
08:17:54 <xinming> vincenz: thanks
08:18:01 <LoganCapaldo> vincenz: I'm not sure about that, esp. as regards python, because lambda got added late in pythons life
08:18:19 <vincenz> LoganCapaldo: well if you keep restricting everything, all languages have type inference and monads
08:18:23 * vincenz rolls his eyes
08:18:34 <chessguy> i still don't get why lambda is so powerful. i mean, it just lets you write a function, so what?
08:18:35 <LoganCapaldo> vincenz: No
08:18:39 <LoganCapaldo> Do you have a link?
08:18:48 <LoganCapaldo> to a python with lambda but no closures?
08:19:26 <LoganCapaldo> (and if boost counts, then all languages _do_ have Monads)
08:19:30 <RetroHelix> hi, im currently learning Haskell. In one of my exercises i have to Express the functional map using foldr and foldr1. Is there a website with solution for such exercises
08:19:33 <LoganCapaldo> (or at least many)
08:19:39 <xinming> chessguy: lambda is powerful, Because you can pass the function as a variable.
08:20:03 <vincenz> xinming: lambda is just syntax
08:20:09 <vincenz> xinming: stop confusing lambda with first-class functions
08:20:13 <xinming> vincenz: sorry....
08:20:19 <xinming> >_<
08:20:28 <vincenz> LoganCapaldo: prior to 2.2 python did not have closures
08:20:34 <vincenz> sure you could say it had "broken lambdas"
08:20:44 <Botje> RetroHelix: foldr (
08:20:50 <vincenz> but I'm certain that prior to that change, they would have objected to it being calelld broken
08:21:10 <Botje> nm :)
08:21:33 <RetroHelix> @Botje ?
08:21:34 <lambdabot> usage: @vote <poll> <choice>
08:21:59 <vincenz> btw, you might find this interesting
08:22:01 <vincenz> http://www.google.com/url?sa=t&ct=res&cd=2&url=http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2006%2Fn1968.pdf&ei=4-xZRe2iI4ycnQPXrKm3CQ&usg=__tqrDUuRBs0TpSlvx56PqQz9JQKg=&sig2=hDXPVLtE2TswaqfUZqZMsw
08:22:04 <lambdabot> http://tinyurl.com/yybcsj
08:22:08 * vincenz thanks LoganCapaldo 
08:22:11 <vincenz> lambdabot even
08:22:12 <Botje> foldr (\x y -> (f x) : y) [] [1..5]
08:22:32 <RetroHelix> thanks i have a look at it
08:23:01 <LoganCapaldo> vincenz: interesting
08:23:08 <Botje> @pl \x y -> (f x) : y
08:23:09 <lambdabot> (:) . f
08:23:15 <chessguy> dons posted a link to a paper called lambda-calculus cooked four ways, but Augustsson, which i downloaded (and haven't read yet), but i can't find the original link now
08:23:16 <Botje> yay! I guessed correctly
08:24:12 <Botje> @pl \x -> if x == 1 then (+1) else id
08:24:13 <lambdabot> flip (flip if' (1 +) . (1 ==)) id
08:24:16 <glguy> I got an instant message from someone at work asking if the "Internet was down" -- I mentioned that AIM uses the "Internet" so no, it could not be "down"
08:24:20 <emu> emacs lisp is an example of a language with lambda but not closures
08:24:27 <emu> not "lexical closures"
08:24:34 <Botje> glguy: AOL internet beats all other internets!
08:26:35 <vincenz> LoganCapaldo: To draw an analogy, it's like talking about a car without airbags.  Sure they exist and have existed, but airbags have become so std.  And now that lambda and fpl has become more popular as of late, closureless lambdas are frowned upon as wel.
08:26:46 <vincenz> +l
08:33:03 <Lemmih> shapr: ping.
08:34:13 <shapr> pong?
08:34:53 <chessguy> dumb question...does compiled code run significantly faster than interpreted code?
08:35:00 <shapr> Lemmih: pong?
08:35:19 <chessguy> > maxInt
08:35:20 <lambdabot>  Not in scope: `maxInt'
08:35:26 <glguy> > maxBound :: Int
08:35:28 <lambdabot>  2147483647
08:35:31 <vincenz> glguy beat me
08:35:35 <chessguy> aw crap
08:35:40 <glguy> vincenz: a high-five!
08:35:41 <vincenz> > maxBound :: Uint32
08:35:42 <lambdabot>  Not in scope: type constructor or class `Uint32'
08:35:45 <vincenz> > maxBound :: UInt32
08:35:46 <lambdabot>  Not in scope: type constructor or class `UInt32'
08:35:48 <vincenz> :/
08:35:54 <chessguy> > maxBound :: Integer
08:35:55 <lambdabot>  add an instance declaration for (Bounded Integer)
08:35:56 <lambdabot>   In the expression: ma...
08:36:01 <vincenz> Integer is unbounded
08:36:11 <eviltwin_b> maxBound :: Word32
08:36:16 <eviltwin_b> > maxBound :: Word32
08:36:17 <lambdabot>  4294967295
08:36:21 <glguy> chessguy: Integer's size depends on how much RAM + Virtual memory you have
08:40:19 <Lemmih> shapr: Hiya. Was just wondering what theme you were using for Hope. I took the liberty to copy it. Hope you don't mind.
08:43:42 <shapr> Lemmih: No, I don't mind. I'm using the other theme... I can check the config.
08:46:40 <araujo> Hello!
08:47:20 <shapr> Lemmih: The theme is called hope
08:47:44 * lispy waves hi
08:48:11 <chessguy> > length [0..2^((2^n)-1)-1]
08:48:12 <lambdabot>  Not in scope: `n'
08:48:18 <chessguy> oops
08:48:23 <chessguy> > length [0..2^((2^5)-1)-1]
08:48:27 <lambdabot> Terminated
08:48:40 <chessguy> pff, weak bot
08:51:38 <Lemmih> shapr: Btw, I'm having trouble editing entries containing two sequential newlines. Have you experienced anything like that?
09:01:07 <fabiim> guy's , i have a problem , I am using the function !! , but it cannot accept Integer arguments , like foo x = list!!x
09:01:19 <Binkley> not everyone here is a guy
09:01:35 <fabiim> loll =) sorry
09:02:04 <fabiim> everyone : i have a problem  =)
09:02:29 <fabiim> should i define !! again , my way?
09:02:41 <kpreid> @type List.genericIndex
09:02:42 <Binkley> fabiim: what are you applying foo to?
09:02:42 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
09:02:49 <Binkley> @type (!!)
09:02:51 <kpreid> fabiim: use genericIndex
09:02:51 <lambdabot> forall a. [a] -> Int -> a
09:02:54 <Binkley> ah, I see...
09:02:57 <Binkley> yes, what kpreid said.
09:03:58 <Cale> You could also just use fromIntegral on your Integer to convert it to an Int
09:04:07 <shapr> alexj: y0 alex!
09:04:16 <Cale> since any valid index is likely to be small enough that you won't lose information that way
09:04:38 <alexj> shapr: trying to pm you but haven't registered here.
09:04:48 <vincenz> Binkley: What do you mean, not everyone is a guy?  This is IRC!
09:05:00 <fabiim> yeah that sounds better , I like !! =)
09:05:07 <Cale>  /msg NickServ help register
09:05:44 <kpreid> Cale: "LIKELY"? NEVER! I WILL NOT STAND FOR THIS! etc etc
09:06:33 <Cale> kpreid: :)
09:06:51 <shapr> Lemmih: Nope, haven't had that problem.
09:07:32 <Binkley> vincenz: ...
09:07:33 <Binkley> ;-)
09:08:56 <vincenz> :P
09:13:25 <vincenz> in #oasis: 18:12 < lispy> i wish haskell had goto
09:13:30 <vincenz> Someone burn him at the stake
09:13:41 <lispy> hehe
09:14:08 * lispy was just trying to think of a way to code up a goto in haskell, but is completely stumped
09:14:24 <shapr> Does @seen only get activated by irc traffic?
09:14:55 <vincenz> prolly
09:14:58 <lispy> shapr: what other ways could it get activated?
09:14:58 * eviltwin_b isn't even sure what goto would *mean* in haskell
09:15:13 <lispy> eviltwin_b: it would probably need to be in a monad
09:15:26 <lispy> so maybe you could get it with cps
09:15:29 <shapr> lispy: Not sure, join/leave?
09:15:31 <eviltwin_b> even then it wouldn't mean anything
09:15:49 <eviltwin_b> a monad is just syntactical sugar for function composition, when you get down to it
09:16:22 <psnl> lispy: design the semantics first.
09:16:59 * Daveman pokes xerox
09:17:05 <Turks> heh, can you guys do me a favor?
09:17:46 <shapr> Turks: Like what?
09:18:11 <Turks> im testing a ircd DNS but im unsure who can connect
09:18:19 <fabiim> i got  digitList :: Integer -> [Int] ;  digitList x  =  x /= 0  mod x 10 : digitList(div x 10) .
09:18:20 <Turks> so far everyone from Louisiana cant
09:19:25 <fabiim> ghci can't match [integer] with [Int].
09:19:45 <eviltwin_b> fromIntegral
09:20:09 <eviltwin_b> but you should probably decide which one you really want, IMO
09:20:29 <fabiim> ? i can't mess around with the Integer type .
09:20:48 <eviltwin_b> huh?
09:21:07 <Binkley> fabiim: if you're not concerned about performance, just use Integer everywhere
09:21:11 <Binkley> and I'd guess you're probably not.
09:21:56 <fabiim> i'm  concerned about understanding this , performance is not a big deal , it's just a work for school...
09:21:57 <eviltwin_b> if you really want to be parsimonious about what goes into the list, use Word8 and fromIntegral
09:22:12 <fabiim> parsimonious ?
09:22:49 <eviltwin_b> if you want to use the absolute minimum space
09:22:56 <Binkley> fabiim: ignore that, use Integer ;-)
09:23:00 <shapr> parsniponius.
09:23:17 * eviltwin_b suggests a dictionary.  online will do for that word :)
09:23:38 <eviltwin_b> if you just want to get it done, just use Integer and don;'t worry about it
09:24:49 <Turks> spiffy?
09:24:54 <fabiim> Binkley: well I could , but digitList 123 = [3,2,1] , I mean  i don't see wy I should have a list of Integers , if the elements are just 0..9 , And I don't see why i get this error , haskell should "compose" the list only after running every element trough digitLIst right?
09:25:05 <fabiim> then all of them should be Int's ....
09:25:11 <spiffy> Hi Turk
09:25:17 <spiffy> err Turks
09:25:27 <Turks> o.0
09:25:40 <Cale> fabiim: internally, all of them are small enough that it won't use GMP integers anyway
09:25:41 <eviltwin_b> but at no point do you turn the input Integer into something else, so it retains that type
09:26:02 <eviltwin_b> what were you exp0ecting to automagically convert an Integer to an Int?
09:26:23 <Turks> o.0
09:26:34 <fabiim> eviltwin_b:  , yeah lol ...
09:26:44 <spiffy> O.o?
09:26:47 <Cale> A value of the Integer type is either a machine integer, or a GMP arbitrary-precision integer, and the operations check to see whether conversions need to be done.
09:26:50 <fabiim> ok , i'll just put Integer everywhere
09:27:05 <Cale> (at least in GHC)
09:27:25 <Cale> I wonder how much worse it would be to have generic list operations be the defaults and have specialise pragmas at specific types.
09:27:46 <Turks> i know a spiffy on zdirc...just wondering..
09:28:15 <spiffy> not me
09:28:21 <spiffy> rathher common nick tho
09:28:29 <Turks> lol...
09:29:20 <spiffy> But, ive had it so long I even respond to it in the real world.
09:29:26 <spiffy> that, and mcspiff
09:29:52 <Turks> hehe
09:30:04 <Turks> ill respond to CS and Turks
09:30:50 <Lemmih> SyntaxNinja: Yo.
09:31:11 <Turks> Ello
09:31:54 <Turks> Hrm
09:32:09 <liyang> SyntaxNinja: yarr!
09:32:11 <Turks> would getContents work to get variables from a file?
09:32:24 <Turks> (i think its getcontents...)
09:32:24 <SyntaxNinja> hi Lemmih
09:32:26 <liyang> SyntaxNinja: I don't suppose there's been any updates to HFuse since last year?
09:32:28 <SyntaxNinja> hi liyang
09:32:35 <Turks> ello ninja
09:32:38 <liyang> (I'm using it for a pet project of mine...)
09:32:57 <Lemmih> SyntaxNinja: You poked me yesterday?
09:32:57 <SyntaxNinja> liyang: no
09:33:08 <liyang> I notice the darcs repo on darcs.h.o has dates from 2005. :)
09:33:25 <SyntaxNinja> Lemmih: yeah. just wondering about moving your web interface to hackage.
09:33:27 <shapr> SyntaxPolice!
09:33:29 <SyntaxNinja> hi shapr
09:34:31 <Turks> :o
09:34:31 <shapr> eviltwin_b: Parsniponius is when you never want to buy veggies.
09:34:40 * Turks throws a brick at dan12
09:36:17 * vincenz winces at SyntaxNinja "Gaim, huh?"
09:37:41 <SyntaxNinja> vincenz: don't like Gaim?
09:38:29 <vincenz> SyntaxNinja: IT ain't great for irc
09:39:32 <eviltwin_b> some people like it for IRC, some people hate it
09:39:37 <SyntaxNinja> vincenz: I beg to differ. although I haven't used a lot of IRC clients, gaim does quite well, and also allows me to interface to AOL and Jabber, has tabbed chat windows for each network, and it's all completely seamless. I don't know what more I could want from an IRC client, honestly.
09:39:41 * eviltwin_b was less than impressed with gaim for IRC
09:39:47 <SyntaxNinja> it also does SIP
09:40:00 <vincenz> SyntaxNinja: wel lthe font is ugly, the lack of hilighting, the lack of filtering
09:40:03 * vincenz prefers irssi
09:40:24 * shapr prefers jabber
09:40:42 <eviltwin_b> hm, think you can change the font and the rest can be done with plugins
09:40:52 * eviltwin_b runs x-chat over vnc
09:40:57 <SyntaxNinja> vincenz: what do you mean about highlighting?
09:41:13 <SyntaxNinja> or filtering for that matter.  maybe I don't require as complex IRC features as you do :)
09:41:15 <vincenz> SyntaxNinja: like when you say my name, your name is highlighted to yelow (I have a black background, it's in a terminal)
09:41:30 <vincenz> SyntaxNinja: yeah but then you easily get overwhelmed by spam of JOINS and QUITS and such
09:41:44 <SyntaxNinja> vincenz: yeah, gaim does that, and when someone is talking to me, it turns the tab blue, when someone just talks, it tunrs the tab red, so I can tell in every channel if someone is talking to me.
09:42:07 <SyntaxNinja> and it highlights everyones name different colors, when you talk to me, it highlights it in orenge.
09:42:07 <vincenz> Ok that it does do, but you get lost in al lthe other spam of JOIN/PART/QUIT
09:42:15 * SyntaxNinja shrugs.
09:42:19 <SyntaxNinja> wfm ;)
09:42:24 <vincenz> wfm?
09:42:40 <SyntaxNinja> omg I totally thought you, like, were all about IRC!
09:42:46 <SyntaxNinja> @wtf is wfm
09:42:47 <lambdabot> Maybe you meant: bf ft wn
09:42:50 <SyntaxNinja> ;hm
09:42:54 <eviltwin_b> 'works for me'?
09:42:57 <SyntaxNinja> ja!
09:42:58 <spiffy> irssi FTW (although im in mirc atm)
09:43:00 <vincenz> ohl, lol
09:43:17 <vincenz> SyntaxNinja: I apologize about not being 1337
09:43:23 <SyntaxNinja> now spiffy's got the 1337
09:43:30 <Turks> bloop
09:43:31 <Binkley> lolz
09:43:56 <xerox> Daveman: yes?
09:44:00 <Turks> heh, are there any documents regarding opening a file to read variables?
09:44:10 <spiffy> laugh Haskell is the leetest of the leet speak as far as im concered.
09:44:48 <vincenz> Like, yeah, totally dude
09:44:57 <Binkley> that's Valley Girl, not l33t
09:45:05 <Turks> lol...
09:45:09 <vincenz> it's' l33t for west-coast beachers
09:45:39 <Binkley> yeah, but people who speak valley girl wouldn't want to get anywhere near people who speak l33t
09:45:51 <Turks> l33t
09:45:53 <vincenz> You've never been to california?
09:45:53 <Turks> :>
09:46:10 <SyntaxNinja> Turks: haskell isn't like python where you can just import a module at runtime and get configuration, if that's what you mean, but you can use Read & Show to input a file using readFile
09:46:12 <SyntaxNinja> @type readFile
09:46:13 <lambdabot> FilePath -> IO String
09:46:44 <Binkley> sure, I'm from California
09:46:46 <Binkley> I know :-)
09:47:06 <vincenz> socal?
09:47:24 <Turks> like for instance, have a config file which sets default irc variables...that possible to open it and read?
09:48:43 <Binkley> Turks: sure. start by using readFile to get the file's contents, then you have a string that you can do whatever you want with
09:48:59 <Turks> hehe
09:49:03 <Binkley> if readFile is too slow for you there are other functions you can use for I/O instead. but try that first.
09:49:20 <spiffy> through in Parsec for a lil spice :D
09:49:39 <Turks> after my mom leaves my apartment ill go back to my main comp...
09:49:44 <Turks> which...sadly is on dial up
09:50:06 <vincenz> Then stay on the one you are?
09:50:24 <Turks> GHCi isnt on here nor the source im writing
09:50:53 <Turks> but oddly enough, i have a very stable IRCd running off that dial up connection
09:50:56 <vincenz> Why isn't your maini comp on the juicy connection?
09:51:12 <Turks> im too lazy to forward ports :>
09:51:28 <vincenz> so you pay for dialup and another connection?
09:51:31 * vincenz peers at Turks 
09:51:42 <Turks> acually, my dad pays for the dial up but never uses it
09:51:53 <Turks> he mainly has it as a back up if a hurricane comes
09:52:01 <Turks> <--- new orleans
09:52:11 * spiffy 's highspeed came with dial-up, this isnt the norm?
09:52:18 * vincenz would thank that dial up would be less stable lthan cable, cause cable is typically underground
09:52:35 * vincenz 's highspeed comes over CATV
09:52:36 <Turks> vincenz, ive got a T1 line :)
09:52:49 <vincenz> I can easilyl download at 1MB/s
09:53:01 * spiffy has shitty dsl
09:53:17 <Turks> dsl is acually, to a certin degree better then cable
09:53:27 <vincenz> how do you figure?
09:53:34 <Turks> less packet loss :)
09:53:39 <SyntaxNinja> dcoutts dcoutts_ xerox is ready to merge the branches :)
09:53:59 <vincenz> Turks: my cable is great
09:53:59 <Turks> SyntaxNinja...nick has a nice ring to it :P
09:54:26 <SyntaxNinja> Turks: thanks.
09:54:29 <SyntaxNinja> vincenz: my cabal is great!
09:54:35 <Turks> well people in louisiana dont exactly get the best of the pick
09:54:57 <vincenz> ah, well in belgium DSL and cable are on about equal footing, though I think cable might be slightly faster
09:55:16 <Turks> anyway, if you dont believe im running an IRCd off a dial up line, try joining irc.boomlol.com :)
09:55:59 <vincenz> thanks for the gratuitous commercial :)
09:56:14 <Turks> ..lol?
09:56:26 <Turks> acually i kinda like dial up...
09:56:36 <Turks> it could do without the fancy terminals though
09:56:44 <Turks> ads blog down the connection speed
09:56:52 <dylan> my cable has ups and downs..
09:57:08 <Turks> shit
09:57:13 <dylan> there's this one hub (hub 59, the ISP calls it) that always has issues
09:57:20 <eviltwin_b> in some places cable is better, in others dsl is better
09:57:29 * vincenz rolls his eyes at http://merd.sourceforge.net/pixel/language-study/scripting-language/
09:57:32 <lambdabot> Title: Scriptometer: measuring the ease of SOP (Script-Oriented Programming) of program ..., http://tinyurl.com/2ekjk
09:57:36 <vincenz> should look at the haskel lbits, so verbose
09:57:57 <cjeris> 1
09:57:59 <tibbe> eviltwin_b: programming.reddit.com is what makes my workdays bareable
09:58:02 <xerox> > fix (("dcoutts" :) . map (++ "_")) -- SyntaxNinja
09:58:03 <lambdabot>  ["dcoutts","dcoutts_","dcoutts__","dcoutts___","dcoutts____","dcoutts_____",...
09:58:05 <Turks> well thats not good...
09:58:11 <Turks> i think the line just hungup
09:58:19 <Turks> :\
09:58:35 <SyntaxNinja> hi Turks!
09:58:35 <Turks> yep
09:58:39 <Binkley> tibbe: your job must really suck, then
09:58:40 <SyntaxNinja> xerox: thanks
09:58:43 <xerox> hehe
09:58:51 <Turks> my server just blew
09:58:54 <Turks> lol
09:59:04 <Turks> 2h is kinda good though...
09:59:06 <tibbe> Binkley: a temporary internship at a big Co in France, it's over in 2 weeks and I've got no work left to do
09:59:16 <Binkley> tibbe: excellent! that's the best kind of job
09:59:17 <cjeris> xerox: damn opera IRC's automatic yellow smiley faces... fix (("dcoutts" [SMILEY] . map (++ "_"))
09:59:50 <Turks> gah
09:59:51 <SyntaxNinja> tibbe: hack on something fun
09:59:52 <xerox> yeah, "[SMILEY]" is really ':':')':[].
10:00:02 <Turks> my mom is like...naked in my shower..wtf!
10:00:11 <Turks> my eyes, they burn
10:00:14 <Binkley> ?remember Turks my mom is like...naked in my shower..wtf!
10:00:18 <tibbe> SyntaxNinja: I should, I want an online ghci session
10:00:21 <Turks> o.o
10:00:21 <spiffy> LoL whyd you look?
10:00:30 <Turks> i had to redial my server
10:00:36 <tibbe> SyntaxNinja: with a "boss" feature ;)
10:00:37 <Turks> and i didnt know the door was open
10:00:40 <xerox> ?where lambdaweb
10:00:41 <lambdabot> http://lambdabot.codersbase.com
10:00:42 <spiffy> buwahaha
10:00:44 <xerox> ^- tibbe
10:00:45 <spiffy> sorry
10:00:50 <Turks> is it just me or did i just get quoted?
10:01:05 <xerox> ?quote Turks
10:01:06 <lambdabot>  my mom is like...naked in my shower..wtf!
10:01:07 <tibbe> xerox: :D I'll play with that
10:01:10 <Turks> haha
10:01:11 <spiffy> be on bash in mere moments. Now thats what lambdabot needs...
10:01:23 <spiffy> ?quote spiffy
10:01:24 <lambdabot> spiffy hasn't said anything memorable
10:01:27 <spiffy> excellent
10:01:31 <Turks> lol
10:01:32 * xerox vanishes forcibly
10:01:47 <vincenz> @quote vincenz
10:01:47 <lambdabot>  Geek is Chique.
10:01:49 <eviltwin_b> now all you need is a cube
10:01:49 <Binkley> ?remember spiffy [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
10:02:08 <Turks> ?quote spiffy
10:02:09 <lambdabot>  [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
10:02:16 <vincenz> @quote vincenz
10:02:17 <lambdabot>  [talking about lambdabot] cause it really is a grand development tool
10:02:34 <Turks> lol
10:02:55 <Turks> i need to read on how the ?remember fuctions work in lambdabot
10:03:14 <vincenz> @remember Turks i need to read on how the ?remember function work in lambdabot
10:03:17 <vincenz> @quote Turks
10:03:18 <lambdabot>  i need to read on how the ?remember function work in lambdabot
10:03:31 <Turks> heh
10:03:40 <Turks> how is that memorable?
10:04:13 <Turks> fuck i have to reset the irc.boomlol.com dns ><
10:04:26 <spiffy> ?quote lambdabot
10:04:27 <lambdabot>  <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=UTF8&s=books  <
10:04:27 <lambdabot> lambdabot> http://tinyurl.com/root7
10:04:38 <Turks> heh
10:05:02 <spiffy> is this book good?
10:05:03 <spiffy> lol
10:05:50 <vincenz> @quote dons
10:05:50 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and ugly
10:06:11 <SyntaxNinja> @quote SyntaxNinja
10:06:12 <lambdabot>  You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean I'll keep doing
10:06:12 <lambdabot> what I'm doing." ;)
10:06:30 <vincenz> Those lazy programmers
10:06:36 <SyntaxNinja> heh
10:06:45 <dylan> vincenz> you have to force their evaluation
10:06:58 <spiffy> ?quote Cale
10:06:59 <lambdabot>  [more monad clarity] monads as food gathering in post-industrial America
10:07:20 <vincenz> dylan: yeah, money tends to work
10:07:29 <vincenz> @quote dylan
10:07:30 <lambdabot>  I run emacs for the games
10:07:45 <Binkley> SyntaxNinja: I hope that quote wasn't inspired by me ;-)
10:07:59 <vincenz> @quote Binkley
10:07:59 <lambdabot>  It's more fun than kicking puppies, even, since puppies don't tend to say nonsensical things about lambda calculus.
10:08:37 <vincenz> good thing people aren't quoting me from #oasis
10:08:55 <Binkley> wait, we're not supposed to quote things that get said on #oasis?
10:08:56 <Binkley> Damn.
10:10:20 <SyntaxNinja> Binkley: heh
10:10:34 <vincenz> @remember Binkley most people's gender inference is broken
10:12:00 <Binkley> @remember vincenz why do you want to be dynamicalyll gendered? lexically gendered is cleaner
10:12:14 * vincenz snicker
10:18:23 <Turks> hey, can someone do me a favor?
10:19:09 <Binkley> depends what kind of favor
10:19:35 <Turks> are you able to join irc.boomlol.com or does it say "FAILED" ?
10:20:03 <Binkley> sec
10:20:06 <chessguy> works for me
10:20:14 <Binkley> works for me
10:21:01 <Turks> Thanks =]
10:21:07 <Turks> fucking dial up dropped the server
10:24:04 <dcoutts_> xerox, yay
10:33:12 <xtruppaw> hi anyone can suggest a good haskell gfx library that enable me to do some simple animations ?
10:33:34 * ptolomy seconds xtruppaw's question.
10:33:54 <Lemmih> SDL?
10:33:57 <xtruppaw> I am working on origami models and I would like gfx library to show origami folds!
10:34:15 <xtruppaw> thx ptolomy ;-)
10:34:38 <xtruppaw> hmm let me check abit about sdl
10:34:46 <xtruppaw> never heard of it!!
10:36:20 <xtruppaw> right now i am completely lost what should i do...
10:36:40 <xtruppaw> I was thinking in generating ActionScript 2 code .... to show folds
10:36:53 <Lemmih> @google SDL
10:36:55 <lambdabot> http://www.libsdl.org/
10:36:55 <lambdabot> Title: Simple DirectMedia Layer
10:37:01 <xtruppaw> but it seems that Flash do not have great support for 3d objects!
10:37:43 <Lemmih> xtruppaw: How about SDL+OpenGL or GLUT+OpenGL?
10:38:36 <xtruppaw> can you brief the difference between them?
10:40:51 <Turks> Binkley: would it be a good idea to use haskell to make ghetto irc services?
10:41:02 <Lemmih> xtruppaw: Look it up.
10:41:35 <Binkley> Turks: depends on your definition of "good"
10:41:55 <Binkley> I'm not really the person to ask, though
10:41:56 <Turks> workable
10:42:03 <Binkley> the only networky things I've done in Haskell are simple HTTP things
10:42:08 <Binkley> which worked ok enough.
10:42:23 * eviltwin_b wrote a finger client/server to familiarize himself with haskell
10:42:36 <xtruppaw> Lemmih: I am :) thanks for being helpful! cheers
10:42:41 <Turks> well the bot design paired with a database could serve as a ChanServ/NickServ
10:43:03 <Binkley> I get the feeling that the sockets library that comes with GHC isn't really the best thing ever
10:43:08 <Binkley> but, suck it and see.
10:43:26 <Turks> the bot works pretty well on localhost =]
10:55:28 <astrolabe> I gave a talk about haskell at my work yesterday.
10:55:35 <shapr> How did it go?
10:56:02 <astrolabe> Today somebody has decided to implement an algorithm.  They are 50 pages into YAHT :)
10:56:12 <shapr> Awesome!
10:56:28 <astrolabe> Mostly ok thanks.  I tried to demonstrate it, which was doomed to failure from the start.
10:56:41 <shapr> Why was that doomed?
10:57:16 <astrolabe> but I think I managed to get across that lines of functional code tend to be more independent than imperitive code, and hence easier to understand and refactor.
10:57:41 <astrolabe> My IQ drops by about 50 points when I talk to more than 3 people at a time.
10:57:56 <astrolabe> I made a stupid mistake, and couldn't find it.
10:58:02 <shapr> Couldn't find what?
10:58:10 <eviltwin_b> heh
10:58:13 <Binkley> Mmm... yes, I know the feeling
10:58:22 <astrolabe> But I'd already shown them quicksort working by them, and type inference, so it wasn't too bad.
10:58:24 <Binkley> though you're talking to more than 3 people at a time right now :-)
10:58:32 <astrolabe> shapr: the mistake
10:59:01 <astrolabe> You are all chat-bots, which doesn't worry me.
10:59:03 <shapr> I suck at specifics, but I'm great at understanding and communicating general ideas. So that's how I give talks.
10:59:11 <shapr> astrolabe: knock knock
10:59:21 <shapr> oh wait, no matrix jokes...
10:59:32 <astrolabe> who's there? Ah :)
10:59:55 <Binkley> how do you feel about the fact that I am all chat-bots, which doesn't worry you?
11:00:03 <astrolabe> heh
11:00:27 <shapr> I have hugged binkley on two different continents, no chat bot there.
11:00:38 <Binkley> heh
11:01:09 <astrolabe> but you would say that.  You are a chat bot
11:01:15 <shapr> good point.
11:01:16 <dino-> hugbot
11:01:31 <shapr> astrolabe: Where do you live? =)
11:01:37 <shapr> astrolabe: Even better, what's your phone number?
11:02:09 <astrolabe> shapr: I've looked into the Loebner prize.  I don't really think you're a chatbot.
11:02:29 <astrolabe> Also, I've seen photos of you on a unicycle.
11:02:35 <shapr> That's true.
11:02:39 <shapr> You may even have seen my blog.
11:02:42 <Binkley> even better, a unicycle-riding chatbot
11:02:44 <Adamant> I-am-a-chatbot
11:03:50 <astrolabe> I'd quite like to make a chatbot.  Using bayesian stuff to try to parse natural language.
11:04:05 * edwardk wonders how hard it would be to put together a bot, and a corresponding news filter that just grepped through articles looking for 'functional programming' and 'tornado codes' in order to build a shapr. =)
11:04:13 <shapr> :-P
11:04:47 <shapr> CosmicRay ran a HiddenMarkov bot on four years of #haskell logs and it kept trying to talk to me about unicycling.
11:04:54 <edwardk> heh
11:05:07 <astrolabe> There are other subjects too.  What would be really impressive is a program that could predict whether shapr would be interested in a subject.
11:05:22 <dino-> shapr: heh, that's funny
11:06:01 <astrolabe> probably if it had been run on #unicycling, it would have talked about haskell :p
11:06:13 <shapr> Here are some quotes from that bot - http://www.haskell.org/hawiki/MegaMonad
11:06:13 <ptolomy> Anyone know the status of GHC on darwinports?
11:06:15 <lambdabot> Title: MegaMonad - The Haskell Wiki
11:06:29 <pejo> ptolomy, works fine for me.
11:06:31 <eviltwin_b> as of last update, it was still 6.4.x (6.4.2?)
11:06:45 <eviltwin_b> it works but is a bit old
11:06:51 <ptolomy> pejo: Which processor?
11:07:02 <pejo> ptol, Core Duo
11:07:03 <Binkley> heh, those quotations are excellent
11:07:07 <ptolomy> Whoa.
11:07:22 <ptolomy> I always get rejected due to my intelness.
11:07:23 <eviltwin_b> wouldn't know about intel though :)
11:07:23 <ptolomy> hmm.
11:07:48 <astrolabe> MegaMonad was pretty good.
11:09:13 <Binkley> especially the conversation where it passes the turing test
11:09:19 <cjeris> that's amazing, like #haskell as reinterpreted by Salvador Dali.
11:09:28 * shapr snickers
11:09:38 <Binkley> I saw a human fail the turing test once
11:10:12 <ndm> @seen dons
11:10:13 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 6h 22m 8s ago.
11:11:25 <ndm> I'm about to release a new library, Safe
11:11:42 <ndm> if anyone has a chance to quickly check i haven't done anything stupid, or has any feedback, I'd be grateful
11:11:44 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#safe
11:11:48 <lambdabot> Title: Neil Mitchell - Haskell Libraries, http://tinyurl.com/hagza
11:15:41 <astrolabe> ndm: from your PhD?
11:16:02 <ndm> astrolabe: no, i started working on that about an hour ago
11:16:22 <ndm> astrolabe: although abort, which i kind of sneaked into it, is useful to my PhD
11:17:30 <glguy> well... considering that abort = error... you didnt' sneak much in (-;
11:19:52 <ndm> glguy: operationally, yes, but abort means that program wants to exit, error means the program screwed up
11:20:19 <ndm> its a world of differnce from my semantics of an error detector :)
11:21:42 <astrolabe> 'Vegai starts a summerjob as a directed graph.'
11:23:56 <edwardk> They should run the Turing test in reverse, and make people try to act like machines. That sounds more fair. Some sort of human mechanical turk test.
11:25:03 <astrolabe> > pi * pi
11:25:05 <lambdabot>  9.869604401089358
11:25:11 <astrolabe> hard for people to do that
11:25:24 <Binkley> depends if they have a calculator or not
11:25:38 <Binkley> didn't Douglas Hofstadter write about the reverse Turing test, though?
11:26:03 <Adamant> captchas are a way for some humans to find out their image recognition is worse than an tweaked OCR package
11:26:12 <Taral> LOL
11:26:30 <Binkley> indeed
11:27:30 <Adamant> Binkley, Berkeley Breathed fan?
11:27:37 <Binkley> Adamant: you know it
11:27:41 <Adamant> nice
11:27:58 <Binkley> I have an autographed copy of _Bloom County Babylon_
11:28:05 <Binkley> though I had him inscribe it "to a future cartoonist"
11:28:11 <Binkley> since I was 13 at the time and hadn't learned programming yet :-)
11:28:49 <Adamant> I have pretty much all the books.
11:28:53 <Binkley> yeah, me too
11:28:59 <Binkley> only right now they're in a storage locker in San Jose
11:29:23 <Binkley> the question is, though, do you have the Academia Waltz book?
11:29:55 <Adamant> no, that one is unknown to me
11:30:15 <Binkley> hah!
11:30:18 <Binkley> I don't have it either, though.
11:30:19 <Adamant> I have the children's book he did with the bassalope
11:30:25 <Binkley> it's a collection of Breathed's college newspaper comic strip
11:30:31 <Adamant> ah, cool
11:30:33 <Binkley> very hard to find, except on ebay occasionally
11:30:49 <Binkley> there are a few strips from it in Classics of Western Literature
11:31:50 <Adamant> "someone better go hide Papa Mouse's guns"
11:31:54 <Binkley> heh
11:32:10 <Binkley> "Mrs. Claus is living with a Hell's Angel in Oakland"
11:32:49 <Adamant> the Anxiety Closet!
11:33:16 <Binkley> I have an Anxiety Closet t-shirt :-)
11:33:49 <Adamant> nice. I need to make this more #haskell, though
11:33:52 <Binkley> heh
11:34:01 <Binkley> well, what would Bill the Cat have said about Haskell?
11:34:12 <Adamant> pfbbbtttttt
11:34:15 <Binkley> indeed
11:34:30 <Binkley> In fairness, though, he would've said the same thing of SML.
11:37:51 <eviltwin_b> or java
11:47:12 <monochrom> template haskell is evil! XD
11:50:06 <SamB> what in particular do you not like about it?
11:50:23 <SamB> (or are you one of those people who likes evil things?)
11:50:32 <monochrom> I like evil things.
11:50:47 <SamB> okay, in that case, what in particular do you like about it?
11:52:26 <monochrom> It's so powerful. I've never felt that power before. I'm slowly dissolving. That much power corrupts me. I'll soon become an orc.
11:52:43 <ventonegro> or a sith
11:54:00 <monochrom> I think I have a plan of using template haskell, existential types, and type classes to turn haskell into an OOPL...
11:55:01 <SamB> sort of like HOC?
11:55:48 <monochrom> No.
11:56:06 <mwc> HOC looks pretty interesting... binding a language as dynamic as objective-c has to be tricky to get right
11:56:12 <tibbe> like Java? :)
11:56:19 <astrolabe> He must be stopped!
11:56:32 <SamB> who must be stopped? monochrom?
11:56:46 <mwc> The dark side of the force is a gateway to abilities some find to be... unnatural.
11:58:22 <monochrom> Perhaps actually yes.
11:59:45 * mwc starts building a burning stake
11:59:51 <monochrom> I didn't know that one can write [|...|] inside $( )
12:00:12 <SamB> monochrom: perhaps actually yes what?
12:00:20 * eviltwin_b isn't sure OO makes sense in haskell, either
12:00:36 <monochrom> To your question.  Perhaps my plan is like how HOC does things afterall.
12:00:48 <eviltwin_b> objects are, after all, things that hold state and act on procedural commands
12:00:58 <eviltwin_b> so the closest thing to an object is a monad
12:01:22 <dylan> objects can be purely functional.
12:02:29 <monochrom> Suppose you don't mind state.  Something like "data GetSet = GS{ get :: IO Int; set :: Int -> IO() }" is an object.
12:03:08 <SamB> eviltwin_b: that doesn't mean you can't make one...
12:04:47 <monochrom> Suppose you do mind state.  Something like "data Get = forall a. GN (a -> Int)" is an immutable object.
12:06:08 <monochrom> Now, the only hard part is that Haskell doesn't provide implementation inheritance.  So every time you subclass, you have lots of boilerplate forwarding calls to code.
12:06:49 <SamB> or, you could just skip overriding...
12:08:13 <monochrom> Template Haskell may be evil enough to generate implementation inheritance code.
12:08:25 <SamB> of course it is
12:09:25 * monochrom writes an article that mocks both Wadler and Peyton Jones.
12:09:48 <tibbe> how standardized is template haskell? anything else than ghc supports it?
12:09:49 <SamB> now, you might need to be careful about not trying to use it on things you just defined in the same module...
12:10:01 <monochrom> "Shall I be functional or object-oriented?"  "With these features, Haskell is the finest object-oriented language in the world. :)"
12:17:04 * SamB thinks the GHC testsuite should skip GHCi tests when you aren't running with a stage>=2 GHC
12:26:03 <monochrom> Hahaha this is krad.  I define "tt = [d|type TT = Int|]" in one module.  I write "$([d|$(tt)|])" in another module (it imports the first).  I crash GHC 6.4.2.
12:27:57 <Binkley> A++++ would coredump again
12:32:47 <vincenz> Binkley: what does a++++ have to do with anything
12:32:55 <Binkley> vincenz: sometimes I like to speak in eBay feedback
12:33:15 <Heffalump> this isn't #haskell.ebay, you know :-)
12:33:22 <Binkley> heh
12:33:30 <vincenz> Heffalump: yes it is, get with the program
12:35:18 <Turks> lawl
12:35:29 <Binkley> @quote qwe1234
12:35:30 <lambdabot>  'static' and 'dynamic' are disjoint sets. no matter if you're talking about typing or anything else.
12:35:58 <Turks> its not about how big it is, its how you wiggle it damnit
12:36:40 <tibbe> anyone know if there's any proof to the effect of dynamic languages are a subset of staticly typed languages?
12:36:53 <Binkley> tibbe: depends what you mean by "subset"
12:37:06 <Binkley> the proof is the church-turing thesis
12:37:22 <Binkley> or rather, the fact that both are turing-complete
12:37:23 <tibbe> all dynamic programs can be encoded in a static language
12:37:40 <Heffalump> but all static programs are directly expressible in a dynamic language
12:37:56 <tibbe> yes
12:37:58 <glguy> Other than the added CPU cost, is there a compelling reason to not use compression in an SSH connection?
12:38:29 <Binkley> glguy: might not be a good idea over an unreliable link
12:38:33 <tibbe> but I was thinking of something along the lines of, static programs contain strictly more information that dynamic (i.e. the dynamic program + types)
12:38:52 <Binkley> tibbe: you can always implement a static type system on top of a dynamic language
12:39:07 <Binkley> but correctness is up to you#
12:39:09 <glguy> Binkley: wouldn't an unreliable link be unusable anyway because the data would fail to decrypt?
12:39:40 <tibbe> so there's no program that can be expressed in say lambda calculus but not in typed LC?
12:40:02 <tibbe> (note that my knowledge of typed LC is virtually nonexistant)
12:40:35 <Binkley> glguy: no, since you'd be retransmitting the data
12:41:05 <Binkley> but compression could potentially result in more retransmissions... well, I don't know. maybe fewer retransmissions, since there's less data being transmitted
12:41:19 <Binkley> tibbe: depends *which* typed lambda calculus you mean
12:41:43 <Binkley> simply typed lambda calculus is less expressive than untyped lambda calculus
12:41:50 <tibbe> Binkley: that I don't know :) but it would be enough if there is one that's as expressive
12:42:37 <nominolo> how do i convert an Int to a Double in Haskell? fromInteger doesn't work
12:43:07 <int-e> fromIntegral
12:44:54 <nominolo> hm
12:45:10 <tibbe> Binkley: perhaps my question is equivalent to: is there a typed lambda calculus that is more expressive than LC?
12:45:13 <monochrom> There is no compelling reason to compress or not compress ssh transmissions
12:45:24 <Binkley> tibbe: by LC do you mean untyped lambda calculus?
12:45:37 <pkhuong> monochrom: compressed text is harder to decrypt (more entropy)...
12:46:43 <vincenz> tibbe: expressive is not a well-defined measure
12:46:59 <monochrom> compressed text may be a data structure with some regular header or footer that helps decryption.
12:50:06 <tibbe> Binkley: yes
12:50:18 <tibbe> vincenz: ok :/
12:50:23 <Binkley> tibbe: simply-typed calculus plus the Y-combinator is what you're looking for
12:50:25 <Binkley> I think
12:50:30 <Binkley> er, simply-typed lambda calculus
12:50:42 <ihope> Simply-typed calculus?
12:50:56 <ihope> Whee.
12:51:02 <SamB> monochrom: maybe you shouldn't encrypt the headers, then?
12:51:47 <nominolo> hm, how do I rewrite this to typecheck   n :: Int, f :: Double -> a  |--  f (360/n)
12:51:51 <nominolo> ?
12:52:34 <nominolo> fromIntegral and fromInteger both don't work
12:52:54 <Lemmih> nominolo: I don't understand your notatoin.
12:53:00 <Lemmih> *notation
12:53:44 <nominolo> ok, the same as:  (f :: Double -> a) ((n :: Int)/360)
12:54:05 <nominolo> the other way round
12:54:08 <Lemmih> f :: Double -> a; f n = n/360?
12:54:12 <Binkley> ?type fromIntegral
12:54:14 <lambdabot> forall b a. (Num b, Integral a) => a -> b
12:54:30 <Binkley> nominolo: f ((fromIntegral n)/360)
12:55:16 <monochrom> The header may be the dictionary of the compression.  Take Huffman code for example.  The compressor examines the text and decides that "Bush is stupid" is a very frequent string.  The compression consists of replacing every occurence of that string with "011", and prepending the dictionary that says "011->Bush is stupid".  If you don't encrypt the dictionary, you're showing the string in plain open.  If you encrypt the dicti
12:55:16 <monochrom> onary, the regular format of the dictionary can be exploited.
12:55:28 <nominolo> ah just convert the n
12:55:30 <nominolo> thanks!
12:56:47 <SamB> @hoogle showHedx
12:56:48 <lambdabot> No matches found
12:56:49 <SamB> @hoogle showHex
12:56:50 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
13:26:03 <tibbe> > let intercalate x = concat . intersperse x in intercalate ["waky", "paky","haskell!"]
13:26:05 <lambdabot>  <[[[Char]]] -> [[Char]]>
13:26:14 <tibbe> > let intercalate x = concat . intersperse x in intercalate " " ["waky", "paky","haskell!"]
13:26:15 <lambdabot>  "waky paky haskell!"
13:29:59 <chessguy> > foldr (++) [] ["waky", "paky","haskell!"]
13:30:01 <lambdabot>  "wakypakyhaskell!"
13:30:20 <tibbe> sometimes I think it would be nicer if ghci/lambdabot wrote String instead of [Char]
13:30:26 <pitecus> ?hoogle Map a b -> Map b c -> Map a c
13:30:27 <chessguy> > foldr (++ " " ++) [] ["waky", "paky","haskell!"]
13:30:27 <lambdabot> No matches, try a more general search
13:30:28 <lambdabot>  Parse error
13:32:07 <fasta> > foldr (\e s->e++" "++s) [] ["waky", "paky","haskell!"]
13:32:07 <pitecus> ?djinn Map a b -> Map b c -> Map a c
13:32:08 <lambdabot>  "waky paky haskell! "
13:32:09 <lambdabot> -- f cannot be realized.
13:32:24 <fasta> > init$ foldr (\e s->e++" "++s) [] ["waky", "paky","haskell!"]
13:32:26 <lambdabot>  "waky paky haskell!"
13:32:42 <pitecus> ?djinn (Map a b -> Map b c -> Map a c)
13:32:42 <lambdabot> -- f cannot be realized.
13:33:00 <fasta> Does this have an actual application? :)
13:33:42 <tibbe> fasta: the waky paky?
13:33:48 <fasta> tibbe: right
13:34:04 <chessguy> who cares about actual applications :)
13:34:10 <tibbe> fasta: the channel went kinda quiet, that makes me nervoud ;)
13:34:13 <tibbe> nervous*
13:34:14 <chessguy> playing with the bot is application enough
13:34:19 <tibbe> I need the constant buzz
13:34:23 <Taral> We should have an Obfuscated Haskell Code Contest.
13:34:27 <fasta> tibbe: how sad for you
13:34:34 <tibbe> Taral: that's called @pl
13:34:35 <Taral> ooo, there is one
13:35:10 <tibbe> @ pl (,)
13:35:16 <tibbe> @pl (,)
13:35:16 <lambdabot> (,)
13:35:27 <tibbe> @pl (,) . (,)
13:35:27 <lambdabot> (,) . (,)
13:35:39 <chessguy> @pl f e s = e++" "++s
13:35:39 <lambdabot> f = (. (' ' :)) . (++)
13:35:49 <chessguy> woohoo
13:36:26 <Taral> A friend of mine asks:
13:36:33 <Taral> "So what is a cool kind of problem that is easier to solve in Haskell?"
13:36:40 <Taral> Any suggestions?
13:36:58 <roconnor> something involving MonadFix
13:37:20 <Taral> No, no.
13:37:24 <roconnor> :)
13:37:26 <tibbe> Taral: what's a cool problem? :) I like parser combinators but that's quite technical
13:37:26 <fasta> Taral: "cool" problems? Can you name one?
13:37:27 <Taral> I'm trying to convince him to learn Haskell, not scary him off.
13:37:40 <roconnor> oh
13:37:44 <tibbe> Taral: find a problem he likes then
13:37:48 <wolverian> I thought it's the solutions that are cool :)
13:37:50 <roconnor> something involving list comprehensions?
13:37:57 <Taral> roconnor: Ooh, yes. List comprehensions.
13:38:08 <tibbe> just do quick sort ;)
13:38:20 <fasta> Taral: you should just go your way and let him go his way.
13:38:27 <wolverian> no, mergesort!
13:38:39 <Taral> wolverian: mergesort?
13:38:40 <fasta> How about something that hasn't been implemented yet?
13:38:47 <fasta> All these pet problems...
13:39:02 <fasta> "Look we can add two numbers too!"....
13:39:13 <wolverian> good luck finding that..
13:39:32 <fasta> wolverian: I know _plenty_ of algorithms with that property.
13:40:03 <fasta> wolverian: but they are probably not "cool".
13:41:21 <guerra_> @hoogle show
13:41:22 <lambdabot> Prelude.show :: Show a => a -> String
13:41:23 <lambdabot> Text.Show :: module
13:41:23 <lambdabot> Prelude.Show :: class Show a
13:41:38 <monochrom> One man's bread is another man's poison.  Cool things can scare people off.
13:42:12 <tibbe> I think writing functions that looks like unix pipes is cool: point free style
13:42:23 <tibbe> or almost
13:42:25 <monochrom> Yeah, and that turns off people.
13:42:31 <tibbe> :)
13:42:33 <tibbe> not me
13:42:33 <tibbe> '
13:43:25 <monochrom> Incidentally the same people embrace unix pipes and disdain "f . g . h" at the same time.  It's most intriguing.
13:43:35 <tibbe> > 210 * 2 / 297
13:43:36 <lambdabot>  1.4141414141414141
13:44:21 <mncharity> I would like to add some links to haskellwiki re "numeric prelude/dcon/basic algebra proposal" et al.
13:44:25 <pitecus> monochrom, its reversed
13:44:34 <xerox> h >>> g >>> f
13:44:35 <tibbe> is sometimes which I had map and filter like they work in haskell in unix
13:44:37 <mncharity> And carve out a corner of the wiki where they can be discussed.
13:44:43 <tibbe> I mean I have grep and stuff but still
13:44:56 <edwardk> > log (640320^3 + 744) / sqrt 163
13:44:58 <lambdabot>  3.141592653589793
13:45:10 <xerox> gulp
13:45:21 <SamB> rc(1) might be a start
13:45:46 <monochrom> If a mere syntactic matter of reversing the order is capable of causing such a big mental gap, I be damned.  You're suggesting people are that stupid.
13:45:54 <mncharity> Most of the current info is in www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics , but other things are there too (so links to the topic elsewhere don't point there), and it seems an inappropriate page to add clutter.
13:46:24 * tmoertel finally gets on Reddit's case about broken left-angle-bracket quoting in code snippets: http://reddit.com/info/qvn5/comments
13:46:25 <lambdabot> Title: Ask Reddit: How can I put a left-angle bracket in a code snippet? (reddit.com)
13:46:28 <theoco> > (1 + sqrt 5)/2
13:46:29 <lambdabot>  1.618033988749895
13:46:58 <mncharity> There doesn't seem to be a lot of discussion pages on haskellwiki compared to the old hawiki(?).
13:46:58 <SamB> doesn't having the outermost things first help you to edit them more easily?
13:47:14 <mncharity> Any thoughts on appropriate course of action?  Create a page?
13:47:16 <Maddas> monochrom: Unix pipes don't cause programs to pass their return values as arguments to the next program (:
13:47:23 <SamB> mncharity: probably related to the relative newness
13:47:23 <Taral> Which linux distribution was it that decided to rewrite all their stuff in Haskell?
13:47:24 <monochrom> (Of course I believe that people are stupid, but I want it to be said by other people than me.  You know, the you-may-have-rediscovered-people-are-stupid-too thing.)
13:47:30 <SamB> Taral: not rewrite
13:47:34 <Taral> ah, linspire.
13:47:40 <SamB> just write their own tools in it
13:47:51 <xerox> Maddas: it happens the same thing in stdin/stout
13:47:56 <xerox> *stdout
13:48:16 <tibbe> my plan is to try to convert Google to haskell, any thought about my odds? ;)
13:48:21 <monochrom> Maddas: the name "return value" is an artificial distinction.
13:48:23 <glguy> > take 5 $ map (foldr1 (\x y -> x + 1 / y)) $ map (1:) (iterate (2:) []) :: [Rational]
13:48:25 <lambdabot>  [1%1,3%2,7%5,17%12,41%29]
13:49:53 <Excedrin> tibbe: I thought Haskell was popular at Google
13:50:04 <monochrom> OK, people set up artificial, untenable distinctions all the time and just refuse to apply alpah-conversion.  I surrender.
13:50:36 <tibbe> Excedrin: perhaps it is, I dunno yet
13:50:53 <tibbe> Excedrin: perhaps popular but not used?
13:52:02 <glguy> > take 5 $ iterate ((+1) . recip . (+1)) 1 :: [Rational]
13:52:04 <lambdabot>  [1%1,3%2,7%5,17%12,41%29]
13:52:32 <glguy> > take 5 $ iterate (succ.recip.succ) 1 :: [Rational]
13:52:34 <lambdabot>  [1%1,3%2,7%5,17%12,41%29]
13:52:58 <tibbe> recip?
13:53:02 <tibbe> ?type recip
13:53:03 <lambdabot> forall a. (Fractional a) => a -> a
13:53:04 <glguy> recip x = 1 / x
13:53:24 <tibbe> ?type succ
13:53:26 <lambdabot> forall a. (Enum a) => a -> a
13:53:38 <tibbe> > succ zero
13:53:38 <lambdabot>  Not in scope: `zero'
13:53:44 <tibbe> > succ 0
13:53:46 <lambdabot>  1
13:54:27 <tibbe> what anamorphism would create all natural numbers using succ?
13:55:10 <tibbe> > [0..]
13:55:12 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:55:26 <pitecus>  Possible fix: add (Ord b) to the class or instance method `compose'
13:55:39 <pitecus> How would I add that to the instance method?
13:57:11 <SyntaxNinja> bringert: alive?
13:57:19 <monochrom> That depends on the context.
13:57:20 <bringert> SyntaxNinja: yep
13:57:32 <bringert> SyntaxNinja: barely
13:58:18 <Taral> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
13:58:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:58:45 <SyntaxNinja> bringert: do you think you could massage haxr to get cabal-put to accept it?
13:58:59 <SyntaxNinja> haxr violates all kinds of assumptions that cabal-put makes about the name of the package, the tarball, the .cabal file, the verison, etc.
13:59:07 <SyntaxNinja> have you looked at that at all?
13:59:08 <Cale> > unfoldr (Just . join (,) . succ) 0
13:59:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:59:32 <Cale> iterate succ 1
13:59:35 <Cale> > iterate succ 1
13:59:36 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:59:49 <glguy> > unfoldr(return.join(,).succ)0
13:59:50 <bringert> SyntaxNinja: haven't looked at it. I guess I should, seeing how I wrote many of the packages you guys are testing with
13:59:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:00:07 * glguy is aware that he didn't contribute anything with that
14:00:29 <glguy> > fix ((1:) . scanl (+) 1)
14:00:30 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:00:31 <SyntaxNinja> bringert: it's pretty easy. just log into monk and do "cabal-put haxr-100000000000000.tar.gz" (or whatever the version number is), and it'll start complaining :)
14:00:44 <tibbe> Cale: unfoldr was what I was thinking about
14:00:52 <glguy> > let fibs = 1 : scanl (+) 1 fibs in fibs
14:00:53 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:01:01 <SyntaxNinja> I'm not sure about the complains because there's not much error checking, but making the package name, the .cabal file, and the name of the tarball consistent would probably get it ready.
14:01:10 <SyntaxNinja> but I don'T want to fork it, so best if you do it.
14:01:59 <bringert> ok. which one is monk again?
14:02:32 <bringert> ah darcs.haskell.org
14:05:37 <bringert> grr, darcs won't let me rename xmlrpc.cabal to XmlRpc.cabal
14:05:53 <pitecus> Can I add a constraint on a type to one of the instance methods rather than to the type signature of the function in the class?
14:06:03 <bringert> XmlRpc is the package name so I think I should stick with that for compatibility
14:07:21 <bringert> ah, screw that, I'm calling it all haxr
14:12:49 <glguy> man... I can't wait for C# 3.0.  The new Linq syntax will give me a fraction of the power of CL's loop macro at the cost of a mere couple decades!
14:13:58 <spiffy> is linq more of a compile time thing, or a run time thing
14:14:16 <SamB> glguy: but you don't have to deal with that nasty lack of a typesystem that CL has, do you?
14:14:21 <monochrom> haha
14:14:22 <bringert> SyntaxNinja: Tue Nov 14 14:13:44 2006 --- bringert adds package "haxr" version "2006.11.14" to section "unstable".
14:15:00 <glguy> Fortunately C# is sufficiently inexpressive enough that such a feature needs to be added at the language level
14:17:56 <spiffy> SamB: the hassle of a type system ;-)
14:19:16 <kpreid> SamB: CL has a type system. It just doesn't have polymorphic types, mandatory type inference, or type classes :-)
14:19:54 <SamB_XP> kpreid: that sounds kind of ad-hoc to me
14:20:32 <kpreid> SamB_XP: huh? ad-hoc?
14:20:34 <glguy> SamB: Do you feel like more people are on your side when you argue your side from multiple nicks? (-;
14:20:39 * araujo back
14:20:46 <SamB_XP> no
14:20:57 <SamB_XP> I just don't feel like learning irssi atm
14:22:17 <monochrom> hahaha
14:23:06 <SamB_XP> It is more fun to play zelda
14:23:38 <glguy> I need to get off work so I can go home and rock out to Guitar Hero II
14:25:30 <Cale> What's Linq?
14:25:46 <edwardk> anyone here in the boston area? might wind up moving out that way shortly
14:25:49 <Cale> ah, here it is
14:25:58 <dibblego> lol @ <Binkley>       but yes, dibblego did teach us something valuable: it takes 20 lines to define in Java what can be defined in one line of Haskell :-)
14:26:08 <dibblego> I hope most readers can see it that way too
14:26:10 <glguy> it lets you write: from p in people where p.Name == "Cale" select p.PhoneNumber
14:26:21 * lispy waves
14:26:43 <SamB_XP> is that particularly impressive?
14:27:02 <glguy> Stands for... Language Integrated Query
14:27:17 <glguy> A0.  [KF] LINQ stands for "Language Integrated Query".  It is a set of features such as lambdas, extension methods, and query comprehensions that enable compilers to understand and implement query logic over in-memory collections of objects.  For more information about lambdas, extension methods, and query comprehensions, please refer to http://msdn.microsoft.com/netframework/future/linq and the LINQ Project Overview document at http://msdn.microsoft.com/
14:27:26 <lambdabot> http://tinyurl.com/und6w
14:27:35 <SamB_XP> glguy: that would explain why it remends me of SQL
14:27:42 <Cale> Seems obviated by higher order functions.
14:27:58 <glguy> it reminds me of a half-assed attempt at Lisp's (loop)
14:28:06 <SamB_XP> Cale: see "list comprehensions"
14:28:11 <Cale> indeed :)
14:28:21 <edwardk> cale: its actually a slightly easier to use monad comprehension
14:28:28 <SamB_XP> I mean, you could say the same of them, but nobody wants to remove those from Haskell
14:28:48 <SamB_XP> they just want to turn them back into monad comprehensions...
14:28:54 <edwardk> they have some fancy record types and automated join calculus stuff, so while they are equivalent, arguably the linq stuff IS a bit easier to use
14:29:07 <SamB_XP> ooh, joins
14:29:09 <SamB_XP> neato
14:30:05 <edwardk> and if you look at c_omega/xen/x# where they stole the stuff from, they have list maybe and non-empty list functors, that they autolift method calls over.
14:30:09 <glguy> If DLinq is able to replace NHibernate, I'll be happy
14:31:42 <edwardk> i have some issues with the decidability of their principal types in some corner cases as written though they claim confluence. i need to do more homework on it.
14:31:54 <lispy> i have yet to be convinced that serializing data is worth the effort compared to using a database or text representation
14:32:20 <glguy> lispy: re: HAppS?
14:32:33 <lispy> probably my main objection is using a format that is hard to work with
14:32:35 <Cale> well, yeah, it looks roughly like the do-syntax, with from v in x being rather like v <- x, and where p being roughly guard p, and select being return
14:32:38 <edwardk> lispy: you need to get the stuff in and out of the database somehow =)
14:32:59 <Cale> though I haven't seen very much of it
14:33:20 <lispy> when i've used serialized objects in java i've had lots of problems with changing those objects then trying to read in the serialized data
14:33:45 <lispy> but if the data had been in a text file or a database i could have inspected it
14:34:02 <lispy> and maybe even fixed it to work with the newly modified classes
14:35:22 <Cale> in fact, it's exactly the list monad :)
14:35:37 <Cale> unless there are further features nobody is mentioning
14:36:16 <edwardk> cale: there is a channel9 video of eric meijer talking about linq. you do realize this is all coming from a haskell guy right? =)
14:36:39 <edwardk> http://channel9.msdn.com/Showpost.aspx?postid=223865
14:36:43 <lambdabot> Title: Erik Meijer: Democratizing the Cloud, http://tinyurl.com/yk7wjp
14:38:07 <dons> moin
14:39:08 <Cale> hehe, I should see if MS will hire me to integrate the Cont monad into C#
14:39:21 <dons> heh!
14:40:33 <monochrom> If you do that, I threaten to ditch Haskell and switch to C# !
14:40:56 * SamB_XP still hasn't figured out how to *use* the Cont monad
14:41:36 * lispy was just thinking about looking at "all about monads" again w.r.t the Cont monad :)
14:41:53 <lispy> i think the UI for darcs uses it...
14:44:22 <edwardk> heya shapr
14:44:25 <shapr> y0 edwardk
14:45:00 <shapr> edwardk: Did you see any interesting papers on today's planet.haskell post? Any cool papers I haven't mentioned?
14:45:27 * shapr must unicycle quickly before the light runs out...
14:46:09 <dons> shapr: there's 'testing higher order functions'..
14:46:24 <dons> shapr, http://www.st.cs.ru.nl/papers/2006/koop2006-TestingOfHigherOrderFunctionsAPLAS.pdf
14:46:28 <lambdabot> http://tinyurl.com/v93ys
14:47:12 <dons> hey protoscript
14:47:34 <monochrom> who is protoscript and why are you greeting it?
14:47:37 <protoscript> hey buddy
14:48:10 * glguy can't think of a time when a "who" can be an "it"
14:48:19 <protoscript> when I try to enter any function definition into GHC, eg,  factorial 0 = 1
14:48:19 <protoscript> factorial n = n * factorial (n-1), I receive an error complaining about the "="
14:48:22 <glguy> Except "Who was it"
14:48:37 <dons> you need to use 'let'
14:48:43 <protoscript> ahhhh thanks
14:48:57 <dons> see the 'haskell in 5 steps' link on http://haskell.org
14:48:59 <lambdabot> Title: Haskell - HaskellWiki
14:49:06 <dons> (there's a quick example there)
14:49:53 <Cale> protoscript: the usual way to program in Haskell is to put declarations (like function declarations) into a file
14:49:58 <protoscript> odd that the tutorials don't mention it
14:50:17 <protoscript> but i like to program iteratively in a repl... is that style supported?
14:50:17 <monochrom> because the tutorial is supposed to be timeless.
14:50:20 <Cale> protoscript: you then load the file into GHCi/hugs and type just expressions to evaluate at the prompt
14:50:34 <monochrom> in the future there may be an repl that accepts it.
14:50:36 <Cale> If you edit your file, typing :r will reload it
14:50:45 <protoscript> oh that;s nice at least
14:50:50 <Cale> Which gets you pretty close to a repl style
14:50:52 <dons> you can play around in ghci though, with 'let'
14:51:07 <dons> but best results will come from using :reload, as Cale says
14:51:18 <dibblego> I don't trust ghci and :reloa
14:51:25 <Cale> dibblego: why?
14:51:30 <dibblego> sometimes it keeps an old value lying about
14:51:34 <Cale> dibblego: it shouldn't
14:51:41 <dons> it does?
14:51:45 <dibblego> I know it shouldn't, but I'm 99% sure it does
14:51:46 <protoscript> factorial 0 = 1
14:51:47 <protoscript> "let factorial n = n * factorial (n-1)" still gives me an error
14:51:48 <dons> please provide an example :)
14:52:00 <dibblego> next time, I'll let you know and confirm it for sure
14:52:01 <Cale> I've never ever seen it happen
14:52:03 <protoscript> o n/m
14:52:08 <protoscript> i see the problem
14:52:17 <dibblego> I'll post a screenshot of the behaviour next time
14:52:18 <dons> $ ghci
14:52:18 <dons> Prelude> let factorial n = n * factorial (n-1)
14:52:18 <dons> Prelude> factorial 0
14:52:18 <dons> ^CInterrupted
14:52:25 <RemiTurk> Hi guys
14:52:32 <protoscript> thanks mate
14:52:35 <Cale> protoscript: you'd want   let factorial 0 = 1; factorial n = n * factorial (n-1)
14:52:47 <protoscript> right,... i see now
14:52:57 <protoscript> what a wonderful way of expressing factorial, btw
14:53:03 <Cale> :)
14:53:21 <RemiTurk> protoscript: then what do you think of let factorial n = product [1..n] ?
14:53:22 <xerox> factorial n = product [1..n]
14:53:33 <RemiTurk> hi xerox ;)
14:53:37 <xerox> hiya (:
14:53:49 <xerox> factorial = product . enumFromTo 1
14:53:50 <Cale> factorial = product . enumFromTo 1
14:53:54 <Cale> damn you!
14:53:55 <Cale> hehe
14:53:56 <xerox> haha
14:53:57 <RemiTurk> haha :)
14:54:12 <RemiTurk> with or without -fno-monomorphism-restriction?
14:54:23 * RemiTurk is really happy with -fno-mono<Tab>
14:54:41 <monochrom> you'll get -fno-monochrom for that
14:54:41 <dons> is that in bash?
14:54:46 <RemiTurk> (or actually, :set -fno-monom<Tab>)
14:54:58 <SamB_XP> > product [1..0]
14:54:59 <lambdabot>  1
14:54:59 <RemiTurk> (no, that's in ghci)
14:55:05 <Cale> With the MR, you get factorial :: Integer -> Integer
14:55:12 <xerox> dons: you can do that in Prelude> :set -TAB
14:55:16 <protoscript> very nice
14:55:19 <RemiTurk> Cale: which actually isn't that bad indeed
14:55:26 <xerox> dons: Lemmih wrote the autocompletition code :)
14:55:32 <RemiTurk> Lemmih++
14:56:27 <protoscript> horray for autocomplete
14:57:16 <dons> I was wondering if we had command line completion in the shell yet
14:57:30 <xerox> dons: that would be cool
14:57:32 <xerox> !!
14:57:44 <RemiTurk> in zsh (and I guess bash too) one can write really complicated auto completion thingies
14:59:12 <RemiTurk> (although I never bothered to find out how to set them up)
15:00:46 <monochrom> Ubuntu defaults bash to have this much autocompletion:  I type scp whee.html vex.net:pub<tab>, and it actually goes out of its way to ssh to my account at vex.net to look for files/dirs of name pub* !
15:01:16 <RemiTurk> that's quite far...
15:01:27 <monochrom> But I like evil things. :)
15:01:43 <RemiTurk> my university setup things to disallow public-key ssh, and entering passwords for tab-completion sounds evil ;)
15:01:45 <SamB_XP> that isn't evil exactly
15:01:59 <SamB_XP> well, see, it needs to be configurable...
15:02:15 <RemiTurk> NEW!! Now with configurable Evil!
15:02:16 <SamB_XP> (or give up if confronted with password authentication)
15:02:42 <xerox> ...and DWIM, obviously.
15:05:08 <Excedrin> why would they disallow public-key ssh?
15:05:18 <RemiTurk> 'cause it's "insecure"
15:05:33 <RemiTurk> 'cause it allows logging in without a password!
15:05:35 <RemiTurk> *sighs*
15:06:14 <SamB_XP> ... just tell them those things are better than passwords, because nobody will guess them!
15:06:33 <RemiTurk> a few years ago, some students implemented a LD_PRELOAD thingie which worked around the config...
15:07:00 <xerox> RemiTurk: ...and?
15:07:17 <SamB_XP> wait, how does that work?
15:08:08 <RemiTurk> xerox: I'm afraid it says something about my universities IT department if implementing a password-typing-LD_PRELOAD-library is easier than convincing them that public keys are _more secure_ than passwords..
15:08:31 <monochrom> I understand the sentiments of both sides.
15:08:50 <Excedrin> that's pretty funny.. if I couldn't ssh around without entering my password each time (thanks to ssh-agent) I might have to make my password short and easy to type
15:08:55 <SamB_XP> that sounds like a pretty convincing proof that passwords can be just as insecure
15:09:20 <glguy> at my school, we couldn't use pub-key auth because they used a kerberos system or something
15:09:24 <RemiTurk> but actually, I don't really care. I'm happy I have enough quota to store a tar cjf of /scratch/rturk/ghc in my home-dir ;)
15:09:35 <Excedrin> it's annoying that it's impossible to guarantee that a ssh-key is encrypted on disk, but it's just another expression of "can't trust the client"
15:09:42 <pejo> glguy, so use your tickets?
15:10:23 <glguy> pejo, the tickets were not issued in a standard way
15:10:33 <glguy> pejo: and you couldn't get them for personal computers
15:10:39 <monochrom> I know a friend who uses public-key ssh but on his client he uses a passphrase to protect his own private key.
15:10:52 <pejo> glguy, what was the point of kerberos then?
15:10:58 <glguy> monochrom: that's the way you are expected to use them
15:11:09 <glguy> pejo: I'm not arguing that they did it correctly
15:11:52 <monochrom> Yeah, so I understand the sentiment against no-password logins.  Even if you're given the freedom, you probably still have a reason to add a password.
15:12:06 <monochrom> "keep a password in the loop" hehehe
15:12:10 <pejo> Boggle. The entire point of single-sign-on should be to sign on once.
15:13:03 <glguy> pejo: that falls apart when you don't all personal comptuers to do the signon
15:13:21 <glguy> pejo: if you were only using campus computers, you didn't need to reauthenticate
15:13:22 <adymo> hi
15:13:49 <Eidolos> monochrom: I do the same thing (public-key ssh with passphrase)
15:13:53 <Eidolos> It's convenient with ssh-agent.
15:14:45 <adymo> i'm looking at the sentence "remember again that Tree is a type constructor, whereas Branch and Leaf are data constructors" in gentle introduction to haskell (2.2.1) and wondering why Tree is called type constructor and not data constructor
15:15:29 <pejo> glguy, as a user you should be fine with just a ticket, if your ssh-client has GSSApi and stuff configured correctly. No need to involve the computer.
15:15:29 <kpreid> because that's what it is
15:15:43 <Igloo> adymo: Because "Tree Int" is a type, not data
15:15:45 <kpreid> adymo: "Tree" is a type constructor; "Tree Int" is a type
15:16:00 <dons> RemiTurk: how can they disallow public key auth?
15:16:06 <dons> you mean they really disable it in sshd?
15:16:09 <kpreid> adymo: "Just" is a data constructor; "Just 1" is data
15:16:27 <monochrom> Before the advent of ssh, you do remember the great controversy of "xhost".  A computer lab wanted to ban xhost.  It was a time when everyone played xblast, so there was interest in working around it.  First stab: ls -l /usr/X11/bin/xhost, it's rwxr--r--.  LOL!
15:16:43 <dons> ?kind Maybe -- type constructor, builds a new type
15:16:44 <lambdabot> * -> *
15:17:01 <dons> ?type Just -- data constructor, builds a new data value
15:17:02 <lambdabot> forall a. a -> Maybe a
15:17:07 <RemiTurk> dons: I actually have no idea. I don't know much about ssh ;)
15:17:29 <monochrom> yeah probably disable in sshd-config
15:18:03 <dons> seems a bizarre thing to do
15:18:04 <pejo> dons, technically just turn off PubkeyAuthentication in sshd_config.
15:18:12 <dons> right. but *why* ?
15:18:13 <dons> :)
15:18:29 <monochrom> You can't understand stupid people.
15:18:37 * dons head hurts
15:18:38 <monochrom> (I can't either.)
15:18:42 <adymo> ok, in a "data Point a = Pt a a" Point is type constructor and Pt is data constructor - right?
15:18:54 <monochrom> Yes adymo
15:18:55 <dons> yep
15:18:55 <RemiTurk> adymo: yes
15:19:02 <adymo> ok, thanks
15:19:06 <monochrom> now try "data Point a = Point a a"...
15:19:08 <dons> so Pt 7 8 :: Point Int
15:20:48 <adymo> and i guess that in "Pt 7 8 :: Point Int" i'm applying Pt as data constructor and Point as type constructor...
15:20:57 <RemiTurk> yep
15:21:36 <monochrom> Hahaha I love the logo of Template Haskell.
15:22:03 <ozone> i understand stupid people!  oh, uhh, wait...
15:22:26 <monochrom> Good for you.  Care to explain some? :)
15:22:34 <mncharity> Ok, new www.haskell.org/haskellwiki/Mathematical_prelude_discussion article started.  Thanks SamB, all.
15:28:31 <dons> ?users
15:28:31 <lambdabot> Maximum users seen in #haskell: 265, currently: 251 (94.7%), active: 45 (17.9%)
15:30:33 * shapr boings happily
15:30:56 <shapr> g'day ChilliX
15:31:02 <shapr> How's the big apple?
15:31:07 <ChilliX> Hi shapr!
15:31:13 <ChilliX> Rainy...
15:31:17 <Pseudonym> Mmmm... apple...
15:31:51 * shapr boings cheerfully
15:32:02 <ChilliX> shapr: What are you up to?
15:32:05 <shapr> ChilliX: got any good papers to suggest?
15:32:09 <monochrom> Oh I forgot to say.  One thing evil about Template Haskell is runIO :: IO a -> Q a.  So basically in the macro I can read and write arbitrary files!  XDDDDD
15:32:23 <Pseudonym> shapr: You've been keeping up with sigfpe's blog?
15:32:23 <shapr> ChilliX: Actually, I'm getting paid a decent amount of money to write BSD3 licensed Haskell code. Can't beat that with a stick.
15:32:32 <shapr> Pseudonym: Yeah, but he's more your style than mine.
15:32:36 <Pseudonym> Yeah.
15:32:38 <Pseudonym> I know.
15:32:40 <Pseudonym> Woo!
15:33:03 <shapr> monochrom: That's not evil. That's called real ultimate power.
15:33:40 <monochrom> evil = [|real ultimate power|]  is in my dictionary heh heh heh!
15:33:50 <shapr> monochrom: In fact, before hs-plugins, I suggested running programs inside that runIO so you'd get runtime dynamic code loading. You'd never actually execute the program, you'd just compile it.
15:34:02 <shapr> ChilliX: What are you up to?
15:34:34 * shapr just got back from another fun bit of unicycling around the golf course.
15:35:25 <shapr> dons: This paper looks good, thanks for the suggestion!
15:35:33 <monochrom> krad. this is opening up a whole new dimension I have never seen before.
15:36:09 <RemiTurk> shapr: what's a normal unicycle-speed?
15:36:20 <ChilliX> shapr: Cool!  Who you work for?
15:36:28 <shapr> RemiTurk: Depends on wheel size, but I do about 12 - 15 mph.
15:36:47 <shapr> ChilliX: I work for HAppS LLC, they're in NYC and I'm in Birmingham, AL.
15:37:11 <RemiTurk> (I've been complaining I want a foldable cycle fitting in my knapsack, and recently realized the answer may have beeen waiting for years in my favourite programming language ;))
15:37:11 <ChilliX> What does HAppS do?
15:37:27 * ChilliX is always curious about companies using Haskell..
15:37:29 <jgrimes> I think I've asked before, but how could one create something like a Joule class, and whenever you have something of type Joule * Joule it returns something of a different type (like Joule^2). I would rather use the Num typeclass than create something new.
15:37:33 <dons> ?where happs
15:37:34 <lambdabot> http://happs.org
15:37:46 <Pseudonym> "Foldable cycle fitting" sounds like something Robert Tarjan would write a paper about.
15:37:49 <shapr> ChilliX: HAppS is a webapp framework.
15:37:52 <RemiTurk> shapr: that's quite nice
15:38:10 <RemiTurk> Pseudonym: but what about the bananas then?
15:38:12 <ozone> shapr: oh, alex jacobson took happs commercial?
15:38:17 <shapr> ChilliX: It has a nice way of doing things, you define state, a state transformer, and a way to serialize your state.
15:38:28 <Pseudonym> RemiTurk: Nah, that's not Tarjan.
15:38:46 <Pseudonym> Bananas are really expensive in Australia at the moment.
15:38:49 <ChilliX> Hi dons, hi ozone.
15:38:50 <Pseudonym> They have been all year.
15:38:57 <ozone> sup chillix
15:39:00 <ChilliX> Ok, nori and Leon just came...dinner time.
15:39:02 <dons> hey ChilliX.
15:39:08 <ozone> sorry i picked playing NWN2 over going to SAPLING ;)
15:39:10 <shapr> ozone: Sort of, yeah. He doesn't expect HAppS itself to make money, but he does have a bunch of very cool money making ideas (No, I can't say, I signed an NDA) and he wants a powerful webapp framework to write them.
15:39:12 <Pseudonym> A cyclone wiped out something like 90% of the crop
15:39:12 <RemiTurk> ahhh, my brain is trying to tell me I should get some sleep again..
15:39:12 <dons> Pseudonym: I saw $7.99 ones yesterday!
15:39:21 <ozone> shapr: ah, of course
15:39:22 <Pseudonym> dons: Isn't it amazing when you think that's great.
15:39:39 <dons> scary, huh?
15:39:57 <ozone> i reckon we should just invade new zealand and steal their bananas
15:39:58 <ChilliX> later
15:40:02 <ozone> and their ski slopes
15:40:09 <dons> you think they have bananas?
15:40:16 <shapr> And in answer to the people who say "many frameworks exist," none of them do the stuff AlexJ wants to do. Have you heard of Amazon's S3 and EC2 services?
15:40:19 <ozone> well... if they don't, they have ski slopes
15:40:24 <ozone> you can't really go wrong
15:41:02 <monochrom> jgrimes: Can't.  Num a => (*) :: a -> a -> a, you can't have Joule of one type and Joule*Joule of another.  I suggest, instead, a type of PolynomialsOverJoule, so that Joule is a value of that type, and Joule*Joule is another value of that same time.
15:41:33 <shapr> jgrimes: Oh, I thought you were talking about Joule the programming language :-(
15:41:58 <shapr> I was all set to write my own proglang until darius pointed me to Joule.
15:42:11 <jgrimes> monochrom, thats what I was afraid of.
15:42:24 <jgrimes> monochrom, and was pretty sure of, but I didn't know if perhaps there was some type trickery or something
15:42:40 <monochrom> Why are you afraid of sound, mathematically correct endeavours?
15:42:40 <Pseudonym> The trouble with Joule is that a program in Joule can never be more efficient than a program in Carnot.
15:42:53 <monochrom> hahaha
15:43:30 <monochrom> AH!  You want to do dimension analysis as type checking.
15:43:43 <jgrimes> monochrom, yeah, I guess afraid isn't quite what I meant. And the other method will probably be more beneficial anyway... Since I would like to generalize it over a lot of physical quantities
15:44:00 <shapr> jgrimes: Have you seen Pseudonym's physical properties code?
15:44:16 <jgrimes> no I haven't
15:44:26 <monochrom> There is a way.  But you will not use the Num typeclass.
15:44:34 <RemiTurk> good night everyone
15:44:38 <shapr> g'nite RemiTurk
15:44:56 <shapr> RemiTurk: If you have more questions about unicycles, feel free to ask me!
15:44:58 <dons> interesting, I think seth implemented some kind of manual fusion? http://programming.reddit.com/info/qw63/details
15:45:01 <lambdabot> Title: An anecdote: using deforestation in Python for a 100-fold speed up (reddit.com), http://tinyurl.com/yjb9q6
15:45:14 <RemiTurk> shapr: thanks :)
15:45:51 <shapr> dons: You're infecting other communities with deforestation fever!
15:46:06 <dons> more secret russian blogs! http://community.livejournal.com/ru_lambda/28333.html
15:46:09 <lambdabot> Title: ru_lambda: Преобразователь Yhc Haskell Core в Javascript (ано ..., http://tinyurl.com/uf4h6
15:46:09 <dons> ru_lambda!
15:46:12 <dons> shapr: hmm!
15:46:24 <jgrimes> shapr, I'm guessing it is on the wiki?
15:46:34 <shapr> Hm, not sure.
15:46:40 <shapr> I know it was on haskell-libs.
15:46:43 <shapr> Speaking of which, I gotta shut that down.
15:47:10 <shapr> Pseudonym: Do you know if anyone is still using haskell-libs?
15:48:15 <Pseudonym> I'm not aware of anyone.
15:48:25 <jgrimes> shapr, recall the title of the post perhaps?
15:48:31 <Pseudonym> I only use it when it turns up earlier in Google.
15:48:49 <Pseudonym> But I should probably be using Google source code anyway.
15:48:54 <shapr> Pseudonym: Hey, is your physical units code online somewhere?
15:49:38 <Pseudonym> Erm.
15:49:46 <Pseudonym> Yes.  haskell-libs.
15:49:55 <shapr> heh, ok
15:50:00 <psnl> shapr: <drunk>what are you on about with deforestation fever?</>
15:50:06 <Pseudonym> Hang on, I'll put it in my darcs repo.
15:50:12 <jgrimes> Pseudonym, thanks
15:50:40 <shapr> psnl: One of the Python/Haskell guys started doing deforestation in Python. I think dons mind control lasers are working.
15:50:58 <robreim> are there primitive signed logical right-shift operators in hugs and NHC?
15:51:00 <jgrimes> deforestation makes too much sense.
15:51:06 <shapr> Silly question... does anyone consider me an academic?
15:51:21 <psnl> shapr: would you like the drunk answer?
15:51:24 <dons> robreim: something in Data.Bits ?
15:51:28 <dons> ?docs Data.Bits
15:51:28 <shapr> konichiwa robert
15:51:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
15:51:31 <shapr> psnl: sure!
15:51:40 <robreim> dons: all shift operators in Data.Bits are arithmetic
15:51:46 <shapr> psnl: btw, it was fun meeting you!
15:52:03 <monochrom> forall x. exists y. y thinks x is an academic.
15:52:07 <robreim> I want to add logical shift operators and to do that I need the primitives. Got them for GHC but I don't know what they might be for hugs and NHC
15:52:09 <Pseudonym> OK, done.
15:52:12 <shapr> monochrom: hm, true.
15:52:16 <Pseudonym> http://andrew.bromage.org/physics/
15:52:20 <dons> robreim: ah hmm. robreim you could roll your own with the ffi
15:52:22 <Pseudonym> http://andrew.bromage.org/darcs/physics/
15:52:23 <shapr> jgrimes: Check Pseudonym's darcs repo =)
15:52:26 <lambdabot> Title: Index of /darcs/physics
15:52:26 <dons> just wrap a C function to do it?
15:52:26 <psnl> shapr: you lack the ability to ramble on about type systems that I link with CS academics and fp people
15:52:29 <robreim> shapr: こんいちわ
15:52:32 <jgrimes> thanks shapr, Pseudonym
15:52:32 <monochrom> Proof.  Find y who has a lower education level.
15:52:33 <psnl> shapr: nice meeting you too
15:52:38 <Pseudonym> Stop trying to hack my IRC client!@
15:53:05 <shapr> psnl: hm, could be.
15:53:12 <robreim> dons: yeah, I can do that. Was just wondering if it was already available as it is in GHC. Thanks :)
15:53:31 <dons> you've got the primops in ghc
15:53:40 <shapr> monochrom: The problemis that my education level is weakly typed.
15:53:46 <dons> e.g.
15:53:47 <dons> primop   ISrlOp   "uncheckedIShiftRL#" GenPrimOp Int# -> Int# -> Int#
15:53:47 <dons>      {Shift right logical.  Result undefined if shift amount is not
15:53:47 <dons>           in the range 0 to word size - 1 inclusive.}
15:54:00 <dons> and if these are not exposed to Data.Bits, they should be!
15:54:09 <dons> robreim: so a patch to Data.Bits might be welcome :)
15:54:12 <psnl> shapr: why do you ask?
15:54:31 <robreim> dons: Yeah, that's what I've been using for GHC. Just need the Hugs and NHC equivalents :)
15:54:36 <dons> yep
15:54:39 <kpreid> dons, help? my lambdabot is broken: "fd:8: hClose: resource vanished (Broken pipe)"
15:54:49 <kpreid> when I @run anything
15:54:57 <dons> you don't have hs-plugins installed?
15:55:03 <dons> or you're using ghc 6.6/
15:55:07 <kpreid> neither
15:55:07 <dons> (means runplugs isn't running)
15:55:12 <shapr> psnl: I was chatting with someone who writes Haskell and at some point they said they're not an academic, and I said that too. And then there was what I perceived to be a small disbelieving silence, so I wondered.
15:55:31 <dons> if you've ghc 6.4.x, build and install hs-plugins , and try again using the .plugins cabal file
15:55:48 <dons> shapr: oh nice!
15:55:50 <kpreid> aha, the cabal file is probably the problem
15:56:02 <psnl> shapr: thats mildly interesting
15:56:12 <dons> ?remember shapr I was chatting with someone who writes Haskell and at some point they said they're not an academic, and I said that too. And then there was what I perceived to be a small disbelieving silence...
15:56:35 <shapr> psnl: Well, I looked at the blog post I wrote earlier today and it made me question my non-academic status.
15:57:11 <dons> shapr: all the papers? :)
15:57:12 <dons> hehe
15:57:36 * dons confers on shapr an honorary degree in hackology
15:58:18 <Igloo> dons: Are you fully accredited?
15:58:34 * shapr wonders if PhD stands for Probably Hackology Driven
15:58:35 <dons> You'll never know! Don't sue.
15:59:09 <dons> so who are these guys, and why aren't they in #haskell.ru ? http://community.livejournal.com/ru_lambda
15:59:56 <psnl> shapr: two words; Barry Jay
16:00:02 <Igloo> I wonder if they'll be inundated with leet-speaking Haskellers when Haskell becomes mainstream
16:00:14 <shapr> psnl: What about him?
16:00:15 <dons> yikes
16:00:24 <robreim> l4mbd4 r0x muh j0x
16:00:26 <Igloo> i 4m teh lambda!
16:00:27 <shapr> Other than the fact that he writes bunches of cool stuff?
16:00:38 <dons> ?remember Igloo i 4m teh lambda
16:00:39 * shapr laughs
16:00:44 * shapr laughs more
16:00:58 <Igloo> Note to self: Don't say things like that when dons is around
16:01:05 <robreim> I'm in your base hacking all your lambdas
16:01:17 <dons> hehe
16:01:18 * shapr just saves quotes via private messages to lambdabot 
16:01:32 <shapr> @quote Igloo
16:01:32 <lambdabot>  [dons: anyone know what happened to [the] Haskell wishlist?]  Igloo: Did it have "Crush Java" listed?
16:01:37 <shapr> @quote Igloo
16:01:38 <lambdabot>  i 4m teh lambda
16:01:41 <shapr> @quote Igloo
16:01:41 <lambdabot>  [dons: anyone know what happened to [the] Haskell wishlist?]  Igloo: Did it have "Crush Java" listed?
16:01:48 <psnl> shapr: no one; with the exception of academics, understand the full depth of his papers
16:01:56 <chessguy> @todo
16:01:57 <lambdabot> 0. SamB: A way to get multiple results from a google search
16:01:57 * Igloo clearly doesn't say enough interesting things
16:01:57 <lambdabot> 1. dons: improve formatting of @dict
16:01:57 <lambdabot> 2. dons: write Haskell Manifesto
16:01:57 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
16:01:57 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
16:01:59 <lambdabot> [19 @more lines]
16:02:20 <shapr> Hm, who's Dan P?
16:02:27 <shapr> Oh, probably Dan Piponi
16:02:33 <shapr> Does he hang out on #haskell?
16:03:09 <shapr> I still love that quote from the gravitomagnetic superconductors paper: This disagreement with theory is discussed in the literature, without any apparent solution.
16:03:11 * Igloo decides learning Russian by trying to infer meaning from blurb around Haskell programs is non-trivial
16:03:19 <shapr> You don't often see than in physics papers.
16:03:45 <shapr> Igloo: Swedish is significantly closer to trivial.
16:03:46 <Cale> http://xkcd.com/ -- hehe
16:03:48 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:03:57 <Eidolos> <3 xkcd
16:03:58 * vincenz high-fives Cale 
16:04:24 <psnl> Cale: the crypto comics make me laugh
16:04:30 <Cale> yeah :)
16:04:35 <Igloo> psnl: The which?
16:04:50 <Cale> http://xkcd.com/c177.html -- for instance
16:04:51 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:04:58 <Taral> coi shapr.
16:05:13 <shapr> coi Taral .i ma nuzba
16:05:28 <Taral> what's this about a haskell lojban channel?
16:05:29 <shapr> mi djica lenu mi cilre
16:05:35 <shapr> Yeah, I'd actually join it...
16:06:09 <vincenz> brute but classic: http://xkcd.com/c179.html
16:06:10 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:06:13 <shapr> I was amused when Taral joined the Haskell world, since I met him years earlier in the lojban world.
16:06:18 <Taral> :D
16:06:25 <Taral> Small world.
16:06:44 <shapr> I think the set of people who fit my new definition of academics is small and well connected.
16:06:52 <shapr> Cale: Have you read that Set paper before?
16:06:57 <vincenz> bwahaha: http://xkcd.com/c175.html
16:06:58 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:07:14 <shapr> Taral: In fact, I'm thinking of publishing a list of such...
16:07:25 <Taral> Nifty.
16:07:26 * Igloo wonders what the 5 linked with small pictures at the bottom are
16:07:27 <Taral> I feel privileged.
16:07:28 <shapr> Do you already know of Kragen Sitaker, Zooko, etc?
16:07:54 <Taral> I know zooko.
16:07:58 <Taral> I don't know Kragen.
16:08:04 <Taral> Met zooko via mojonation.
16:08:09 <Taral> and freenet.
16:08:29 <shapr> I'm trying to think of people outside the Haskell world who are sufficiently nifty...
16:08:36 <Taral> Bram Cohen. :D
16:08:40 <shapr> True!
16:08:51 <shapr> I've only chatted with him a few times though.
16:08:54 <robreim> shapr: you were into lojban too?
16:08:55 <chessguy> anybody know of any work done in implementing neural networks in haskell?
16:09:00 <vincenz> ok
16:09:03 <vincenz> moving the comics to 3oasis
16:09:15 <robreim> wtf is it with haskellers and lojban?! It's too bizarre...
16:09:16 <shapr> robreim: Yeah, I got into loglan in the late 80s.
16:09:40 <robreim> that's crazy...
16:09:49 <shapr> Howso?
16:10:01 <Taral> small world ftw!
16:10:07 <shapr> @google filetype:hs neural network
16:10:12 <lambdabot> http://www.mrtc.mdh.se/projects/DFH/examples/sans-relax.hs
16:10:29 <shapr> @google filetype:lhs neural
16:10:32 <lambdabot> http://ci.uofl.edu/tom/software/Haskell/SCG.lhs
16:10:35 <robreim> just how many haskellers seem to independently toy with lojban at some stage. I'm surprised all haskell primitives aren't 5 letter gismu from the influence
16:10:53 <Taral> LOL
16:10:57 <shapr> One reason I got started with Haskell was that I wanted to write a spoken programming language based on lojban.
16:11:28 <edwardk> shapr: how is that working out for you? =)
16:11:37 <shapr> edwardk: Well, I got distracted...
16:11:40 <Pseudonym> You know, it'd be nice if people paid me to come up with cool new Haskell ideas.
16:11:45 <Pseudonym> Without actually writing any papers.
16:11:52 <Pseudonym> I reckon I could handle that as a career.
16:11:55 <dons> heh
16:11:57 <robreim> heh. Seems many new lojbanists have that dream. I think LOkadin was wanting to do that too.
16:11:59 <edwardk> shapr: know the feeling
16:12:04 <Taral> shapr: You'd best talk to edwardk about his work generalizing the prelude stuff.
16:12:09 <dons> you know ... you could always write the ideas up, Pseudonym. its not that hard ;)
16:12:26 <edwardk> taral: it works well, in a language that isn't haskell =)
16:12:29 <robreim> I'm curious about plugging natural language generators into parsed lojban to get lojban-> natural language translations for free...
16:12:36 <Taral> edwardk: Exactly. Like a spoken programming language.
16:12:43 <edwardk> heh
16:12:47 <Taral> :D
16:12:50 <shapr> robreim: Talk to bringert
16:12:59 <shapr> Or check out the Grammatical Framework
16:12:59 <shapr> @where gf
16:13:00 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
16:13:17 <robreim> *another* lojban speaking haskell coding anarchist?
16:13:39 <edwardk> besides by now i think shapr knows i'm not the best person to throw stones at unfinished projects ;)
16:13:46 * vincenz snickers
16:13:48 <vincenz> http://xkcd.com/c26.html
16:13:50 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:13:56 <beelsebob> o.O
16:14:00 <beelsebob> what's lambdabot doing in here?
16:14:04 <beelsebob> oh...
16:14:07 <beelsebob> this is #haskell
16:14:09 <beelsebob> oops
16:14:11 <dons> hmm?
16:14:11 * vincenz peers at beelsebob 
16:14:13 <dons> hehe
16:14:19 <Pseudonym> dons: The problem isn't writing up, it's raising research money.
16:14:19 <beelsebob> sorry - I thought I was in #bored
16:14:21 <shapr> Nah, bringert speaks Swedish, English, Russian, and some other languages. He did a dual major in Functional Programming and Russian, but he's doing a PhD in FP.
16:14:26 <Pseudonym> $120 per paper isn't a lot.
16:14:29 <beelsebob> which would imply that someone had sajoined my lambdabot in
16:14:31 <dons> beelsebob: this is lambdabot's home. what are *you* doing here? ;)
16:14:48 <dons> Pseudonym: true.
16:14:52 <Pseudonym> Researchers in Australia seem to spend half their time raising money.
16:14:58 <shapr> robreim: Also, I'm not an anarchist, I'm a futarch.
16:14:59 <beelsebob> dons: :P
16:15:03 <psnl> beelsebob: are you a member of the drunk set?
16:15:08 <dibblego> Pseudonym, I resent the comment
16:15:12 <robreim> shapr: thanks for the link. Interesting :)
16:15:12 <beelsebob> pissibly
16:15:33 * shapr nominates #haskell 'most interesting channel on freenode'
16:15:42 <dons> hehe http://kaol.livejournal.com/23530.html
16:15:44 <lambdabot> Title: kaol: !BSP
16:15:48 * beelsebob nominates #unicycling
16:15:49 <edwardk> how many lamdabot clones are there floating around out there anyways?
16:15:52 <dibblego> shapr, agreed
16:15:55 <edwardk> er lambdabot instances i guess
16:15:58 <dons> my rss search tools turn up some weird random haskell mentions
16:16:12 <dibblego> edwardk, I used to have a couple, until Igave up trying to build it after updating ghc
16:16:14 <dons> kaol, found your blog!
16:16:18 <dons> ?seen kaol
16:16:18 <lambdabot> kaol is in #haskell.fi and #haskell. I last heard kaol speak 2h 21m 43s ago.
16:16:21 <robreim> shapr: the anarchist reference was to something a few nights ago. What's a futarch?
16:16:21 <psnl> beelsebob: you can't be drunk
16:16:28 <shapr> @google futarchy
16:16:29 <edwardk> mbot, lambdabot, bottom, i've never seen another one.
16:16:31 <lambdabot> http://en.wikipedia.org/wiki/Futarchy
16:16:39 <beelsebob> Pseudonym: confused?
16:16:43 <beelsebob> any reason?
16:16:48 <Pseudonym> dibblego, do you resent the comment or resemble the comment?
16:16:57 <shapr> robreim: imho, a futarchy integrates the good points of both a democracy and republic.
16:16:58 <edwardk> ah wait i think samb brought one on here once by accident
16:17:02 <robreim> Oh right. Command economy :P
16:17:06 <dibblego> Pseudonym, reSENT :)
16:17:09 <Pseudonym> :-)
16:17:14 <shapr> dons: Why doesn't @join work for me?
16:17:18 <SamB_XP> sometimes I do it on *purpose*
16:17:22 <dons> I think we've maxed out the channels
16:17:25 <dons> ?seen lambdabot
16:17:25 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell_ru, #haskell.se, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.
16:17:26 <lambdabot> fi, #haskell.es, #haskell.de, #haskell-overflow, #haskell-blah and #haskell
16:17:34 <shapr> oh, 20 chans already?
16:17:36 <dibblego> shapr, I had that trouble when the channel required lambdabot to be registered
16:17:36 <dons> ?part #haskell_ru
16:17:40 <dons> shapr: try again
16:17:51 <shapr> dons: ok, it works now.. why?
16:17:52 <edwardk> that an irc limit or a limit in the bot?
16:17:58 <dons> must be the channel limit
16:18:02 <dons> we need lambdabot2 ...
16:18:03 <SamB_XP> or a *freenode* limit?
16:18:05 <dons> yep
16:18:09 <robreim> It's a freenode limit
16:18:10 <shapr> freenode limits to 20 chans
16:18:12 <dons> ?seen lambdabot
16:18:13 <lambdabot> Yes, I'm here. I'm in #unicycling, #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.se, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.
16:18:13 <lambdabot> fi, #haskell.es, #haskell.de, #haskell-overflow, #haskell-blah and #haskell
16:18:21 <shapr> Wow, there's a #haskell.hr ?
16:18:26 <shapr> hrvatska!
16:18:27 <shapr> w00
16:18:31 <dons> ?users #haskell.hr
16:18:31 <lambdabot> Maximum users seen in #haskell.hr: 3, currently: 2 (66.7%), active: 0 (0.0%)
16:18:35 <dons> 3!
16:18:36 <psnl> ?part #unicycling?
16:18:37 <lambdabot> Not enough privileges
16:18:53 <vincenz> gotta admit
16:18:54 <dons> we could garbage collect any empty channels
16:18:56 <vincenz> I like the way that guy draws
16:18:58 <vincenz> even if it is simplistic
16:19:04 <dons> ?users #unicycling
16:19:05 <lambdabot> Maximum users seen in #unicycling: 11, currently: 11 (100.0%), active: 3 (27.3%)
16:19:07 <vincenz> especialyl lhsi earlier work
16:19:11 <Taral> Yup, GC the misc language channels.
16:19:27 <Taral> If it's a small enough number of users, they can come here for their lambdabot fix.
16:19:32 <dons> or we could have lambdabot2 for the #haskell.* chans
16:19:37 <Taral> what is haskell-blah?
16:19:41 <dibblego> haskellbot
16:19:45 <Taral> ?users #haskell-overflow
16:19:46 <lambdabot> Maximum users seen in #haskell-overflow: 19, currently: 15 (78.9%), active: 4 (26.7%)
16:19:46 <shapr> Taral: specifically for off-topic
16:20:06 <Taral> addeded.
16:20:44 <robreim> is lambdabot of much use in channels where haskell talk is prohibited like #haskell-blah?
16:20:56 <shapr> Sure, lambdabot does lots of non-haskell stuff.
16:20:58 <robreim> I suppose for vixen and messages etc...
16:21:10 <dons> google
16:21:13 * edwardk didn't realize haskell talk was verboten in #haskell-blah, oops =)
16:21:27 <beelsebob> tinyurling
16:21:44 <robreim> Yeah. I got told off rather harshly when I said something about haskell in the wrong channel by accident one time :)
16:22:05 <edwardk> @yow
16:22:05 <lambdabot> Quick, sing me the BUDAPEST NATIONAL ANTHEM!!
16:22:20 <Taral> (Budapest is not a nation.)
16:23:21 <dibblego> dons, that Maybe in Java is a result of a brain fart triggered by a conversation with Simon (does he use IRC?) that I "re-pondered" as I traversed Pitt Street (I'd already thunk it all out without a fruitful ending but I decided to do it again just to be sure)
16:23:37 <dons> yeah, glad you did dibblego. thanks
16:23:43 <dons> he doesn't use irc much
16:24:25 <shapr> robreim: Really? Which chan? I traumatized #java early on...
16:24:46 <robreim> shapr: #haskell-blah
16:25:12 <dibblego> shapr, I did that once with lambdabot :) I answered all their questions in one line of haskell
16:25:23 <pitecus> How can i convince GHC to say something more informative than just: Map.find: element not in the map
16:25:43 <pitecus> Like a stack trace?
16:25:43 <Taral> Find a way to pass up the error.
16:25:50 <Taral> or use hat :)
16:25:56 <Taral> got code?
16:25:57 <Taral> @paste
16:25:58 <lambdabot> http://paste.lisp.org/new/haskell
16:26:00 <shapr> dibblego: I told a java newbie to use a parser monad...
16:26:04 <pitecus> Its lots of code
16:26:07 <robreim> pitecus: Perform the find in a maybe monad and do something wit the Nothing?
16:26:07 <dibblego> shapr, nice one :)
16:26:09 <Taral> ^ paste.
16:26:37 <pitecus> I dont even know in which file it is
16:26:48 <Taral> hat.
16:26:52 <Taral> @where hat
16:27:01 <lambdabot> www.haskell.org/hat/
16:27:13 <Taral> @where+ hat http://www.haskell.org/hat/
16:27:14 <lambdabot> Done.
16:27:19 <Taral> @where hat
16:27:20 <lambdabot> http://www.haskell.org/hat/
16:27:22 <Taral> much better.
16:27:24 <pitecus> So that's not included in GHC?
16:27:27 <Taral> nope
16:27:34 <Taral> debian users can apt-get install hat, I think.
16:27:38 <pitecus> sigh
16:27:44 <Taral> It's rare to need it, but this is one of those cases.
16:28:13 <Taral> It's possible you might be able to use prof and auto-scc to get a virtual stack trace.
16:28:21 <Taral> Try in #ghc?
16:29:07 <dons> or do you just want to print which element wasn't in the map?
16:29:12 <dons> i.e. wrap lookup?
16:29:29 <Taral> dons: He's having trouble finding the particular instance of Map.find that's breaking.
16:29:36 <pitecus> thats it
16:29:46 <shapr> salut kowey
16:29:55 * Pupeno_ decides to correctly use "throughput" instead of "bandwidth" from now on.
16:30:01 <pitecus> I ll try to guess, sounds easier than downloading and installing this hat thing
16:30:45 <kowey> hi shapr, how's unicycling?
16:30:48 <dons> ah right. profiling and check the stack trace
16:30:54 <dons> the last call should be on top of the call stack
16:31:10 <dons> ghc -prof -auto-all Foo.hs
16:31:18 <dons> ./a.out +RTS -p
16:31:21 <dons> check a.out.prof
16:31:30 <Taral> Does that print out the call stack for Prelude.error?
16:31:43 <pitecus> i ll try that dons thanks
16:31:55 <dons> Taral: it should...
16:31:59 <Taral> k good
16:32:59 <shapr> kowey: I just ordered some new parts, yay!
16:33:03 <dons> Taral: so re. >>> , we worked out it was the -> instance making it work?
16:33:12 <dons> so I should continue with the push to add >=>
16:33:19 <Taral> Yes.
16:33:28 <dons> ok. good. thanks for the feedbac
16:33:30 <Taral> :D
16:33:53 <kowey> shapr: i don't remember; these would be otherwise unavailable European parts you're getting?
16:34:14 <shapr> Nah, I'm ordering the pieces I'm missing to mount my hydraulic brakes.
16:34:35 <kowey> oh yes, brakes... good, that
16:34:43 <Cale> dons: yeah, to get Kleisli composition from >>> you need to use the Kleisli newtype.
16:35:18 <shapr> kowey: After that, I'm saving up to buy a geared hub so I can go faster.
16:35:22 <robreim> Lot of unicyclers here too... any tricyclers? As in recumbent tadpole design tricycles?
16:35:46 <shapr> robreim: Yeah, John Tromp is big into that..
16:35:55 * Taral goes home.
16:35:57 <shapr> I'd like to get one of those myself.
16:36:17 <shapr> Recumbent trikes are much faster than unicycles, even if they do handle like a brick in comparison :-)
16:36:45 <robreim> Haha. But you're less likely to fall off :)
16:37:05 <robreim> Unless you take a corner fast enough to roll...
16:38:22 <robreim> I plan to get a trike as soon as my co-op starts paying me regularly enough to afford it
16:38:35 <robreim> Speaking of which, any suggestions on where to get freelance haskell work?
16:39:56 <araujo> i can take it robreim
16:39:58 <shapr> Do you have any code?
16:40:30 <dons> araujo: HWN is out.
16:40:59 <araujo> dons, wow! ...
16:41:05 <dons> ;)
16:41:13 <robreim> Some. I've got a program in the works which I intend to sell open-source...
16:41:32 <dibblego> how do you sell open-source?
16:41:49 <shapr> Programs are not just the source and/or binary, they're also the understanding.
16:41:49 <dibblego> my bike is handling like a trike at the moment - need new tyres
16:41:52 <robreim> dibblego: you don't release the code without someone paying for it first :P
16:42:25 <dibblego> which reminds me...
16:42:34 <pitecus> dons I'm looking at this .prof file but all it has are some statistics. Doesn't seem to have a stack trace...
16:42:55 <dons> ?paste
16:42:56 <lambdabot> http://paste.lisp.org/new/haskell
16:43:13 <dons> can you paste the file, and the src you used to generate it
16:43:22 <dons> (btw, how many 'find's are there in your code?)
16:43:32 <dons> could you use a regex to replace find with safeFind ?
16:44:12 <lisppaste2> pitecus pasted ".prof" at http://paste.lisp.org/display/29918
16:44:37 <dons> btw, http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#safe
16:44:39 <lambdabot> Title: Neil Mitchell - Haskell Libraries, http://tinyurl.com/hagza
16:44:53 <pitecus> I don't think I m using find anywhere actually
16:45:00 <pitecus> Just Map.!
16:45:18 <dons> ok, you could wrap it with a function that takes a line number
16:45:22 <dons> or an assertion
16:45:51 <shapr> hiya olliej, ltns
16:46:23 <pitecus> Ya I'll try
16:46:29 <olliej> yo
16:46:33 <dons> pitecus: does the 'individual inherited' graph help?
16:46:54 <robreim> shapr: the program uses some fun stuff like separating gtk2hs into MVC components with a reader transformer controller and uses hs-plugins to plugin additional backends. I think it's got some understanding in it :)
16:47:10 <dcoutts> sounds nice
16:47:27 <pitecus> frankly not much
16:47:45 <shapr> robreim: cute!
16:47:53 <olliej> sorry my irc client played up -- what has been said since i joined?
16:47:57 <robreim> using reader transformers as arguments to event handler binders was an interesting challenge :P
16:48:11 <olliej> hmm i recall a web site the logged this channel
16:48:15 * olliej searches
16:48:22 <shapr> @logs
16:48:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:48:25 <shapr> oops
16:48:27 <shapr> @where logs
16:48:27 <dcoutts> robreim, got any nice screen shots? :-) I'm always on the lookout for more screeshots to put on the gtk2hs web site
16:48:28 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
16:48:58 <robreim> dcoutts heh, nah, the interface is still very ugly. I'm still just getting the logic working at this stage :)
16:49:30 <dcoutts> robreim, perhaps I need a links section on the gtk2hs site as well as screenshots
16:49:34 <dons> ?hoogle assert
16:49:35 <lambdabot> Control.Exception.assert :: Bool -> a -> a
16:49:35 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
16:49:35 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
16:49:36 <robreim> I'll send you a screenshot once it's done though :)
16:49:41 <dcoutts> robreim, cool
16:49:42 <dcoutts> ta
16:50:52 <robreim> dcoutts: speaking of gtk2hs, do you know any way to get the installer working with ghc 6.6 on windows? I'm using wine and can't get it to compile from source.
16:51:15 <dcoutts> robreim, I need to build a new installer basically
16:51:31 <dcoutts> robreim, I've never tried wine
16:51:31 <robreim> cabal seems to work fine with wine but not shell-script based make installs :(
16:51:37 <robreim> oh ok then
16:52:10 <dcoutts> robreim, it does build on real windows boxes, though it's a bit tricky, it needs a lot of stuff, Mingw+MSYS etc
16:53:07 <robreim> Yeah. I don't have windows so I might just have to wait for the next release.
16:53:24 <dcoutts> I'm working on it now :-)
16:54:07 <robreim> Cool. I grabbed the latest darcs and have had a look at the cairo bindings. If I have some time I'll do some work on it. I haven't used cairo yet though so it might be a while :)
16:54:24 <dcoutts> cairo is cool :-)
16:54:37 <dcoutts> there are some nice demos to run and read
16:55:02 <robreim> Given it looks like it's a vector graphics dealie it looks like it'll be pretty interesting to combine with a fruit front-end to gtk2hs :)
16:55:24 <dcoutts> does fruit provide a vector graphics thingie ?
16:55:47 <robreim> It expects vector graphics for doing image translations if I understand correctly
16:55:51 <dcoutts> I've never really looked into fruit
16:56:00 <dcoutts> well cairo can do that easily, and more
16:56:12 <dcoutts> cairo can do arbitrary affine transforms
16:56:28 <dcoutts> (well invertible ones at least)
16:57:16 <robreim> nice. Well I guess if I help update the port I'll end up knowing a little about cairo :)
16:57:25 <dcoutts> aye :-)
16:58:05 <mwc> @type Data.Array.MArray.mapArray
16:58:07 <lambdabot> forall e i (a :: * -> * -> *) (m :: * -> *) e'. (Ix i, Data.Array.Base.MArray a e m, Data.Array.Base.MArray a e' m) => (e' -> e) -> a i e' -> m (a i e)
16:58:39 <mwc> Quick question: why couldn't that be (e' -> m e) -> a i e' -> m (a i e)
16:58:56 <mwc> seems to me that if you're in for a penny, you're in for a pound.
17:04:40 <SamB_XP> I would think a dollar would be more appropriate
17:09:02 <Cale> Then it would be mapMArray, of course, that's nicely ambiguous :)
17:10:18 <dibblego> inits (x:xs) =  [[]] ++ map (x:) (inits xs) -- is the [[]] ++ used simply to have the map have its type inferred to [[]]? or what is point of prepending an empty list?
17:10:48 <Cale> because the whole thing wouldn't work without that
17:11:09 <dibblego> oh right thanks :)
17:11:36 <Cale> (the list returned would be the same length as the list returned by the base case)
17:11:55 <dibblego> hm yes
17:11:56 <dibblego> ta
17:13:03 <guerra> hail all! how do i make a function return either a type or other?
17:13:14 <dibblego> ?docs Either
17:13:14 <lambdabot> Either not available
17:13:23 <dibblego> there is Either somewhere
17:13:32 <guerra> @hoogle Either
17:13:33 <lambdabot> Prelude.Either :: data Either a b
17:13:33 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
17:13:40 <guerra> ooh cool
17:13:44 <guerra> thanks
17:20:15 <guerra> is this the correct use?
17:20:40 <guerra> jogadaHuman :: [Int] -> Int -> Int -> (Either [Int] String)
17:21:44 <guerra> aaa either is the funct :P
17:22:25 <sjanssen> guerra: you can use Left and Right to build the Either
17:22:58 <guerra> sjanssen: how? i dotn knwo Left and Right
17:23:14 <sjanssen> @type Left
17:23:16 <lambdabot> forall b a. a -> Either a b
17:23:48 <sjanssen> Left takes a value of the type of the first type variable, and makes an Either out of it
17:25:36 <sjanssen> @let example x = if x < 0 then Left "No negatives!" else Right (x - 1)
17:25:38 <lambdabot> Defined.
17:25:46 <sjanssen> > L.example (-1)
17:25:47 <lambdabot>  Left "No negatives!"
17:25:55 <guerra> haa got it
17:25:56 <sjanssen> > L.examle 10
17:25:57 <lambdabot>  Not in scope: `L.examle'
17:26:09 <guerra> inside my code i use left and right to say what i will return
17:26:16 <sjanssen> right
17:26:26 <guerra> but in teh definition, what do i do?
17:26:29 <guerra> like i sent?
17:27:01 <sjanssen> the type definition you supplied is a function that results in either an [Int] or a String.  Is this what you meant?
17:27:16 <guerra> yes
17:27:20 <robreim> uh, is there any way to cast an int into a word and vice-versa without affecting the underlying bit structure in haskell? Or should I just implement it in C?
17:27:49 <sjanssen> robreim: I believe fromIntegral does what you want
17:27:52 <guerra> what u mean with underlying bit structure
17:27:57 <guerra> ?
17:28:04 <robreim> sjanssen: won't that change the bit structure in the case of negative ints?
17:28:18 <sjanssen> > fromIntegral (minBound :: Int) :: Word
17:28:20 <lambdabot>  2147483648
17:28:30 <sjanssen> > maxBound :: Word
17:28:31 <lambdabot>  4294967295
17:29:06 <robreim> Oh, it doesn't. Lovely! Thanks :)
17:29:27 <sjanssen> I really thought that would work . . . hmm
17:29:51 <robreim> fromIntegral (2147483648 :: Word) :: Int
17:30:01 <robreim> > fromIntegral (2147483648 :: Word) :: Int
17:30:03 <lambdabot>  -2147483648
17:30:15 <robreim> > minbound :: Int
17:30:16 <lambdabot>  Not in scope: `minbound'
17:30:21 <robreim> > minBound :: Int
17:30:22 <lambdabot>  -2147483648
17:30:52 <guerra> robreim:  got your question ^^
17:30:55 <guerra> hehe
17:31:20 <guerra> sjanssen: still i dont understando what do i do in the definition of my function
17:32:22 <sjanssen> guerra: do you mean the type declaration?
17:32:34 <guerra> sjanssen: yes
17:32:44 <sjanssen> okay, what specifically is confusing you?
17:33:57 <guerra> when i define the types i will pass and return
17:34:41 <guerra> what do i do with either?
17:35:04 <guerra> @hoogle either
17:35:05 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
17:35:05 <lambdabot> Prelude.Either :: data Either a b
17:35:12 <sjanssen> first, don't use lower case 'e' either in your type declaration.  You want "Either"
17:35:36 <guerra> humm, ok
17:36:16 <sjanssen> data Either a b = Left a | Right b -- this is all Either is, a data type that wraps a value that has one of two types
17:36:53 <sjanssen> so if you want to write a function that operates on Either a String or an Int, you use "Either String Int"
17:37:56 <sjanssen> and you can use that in either the result (f :: Char -> Either  String Int), or in a parameter (g :: Either String Int -> Char)
17:38:40 <guerra> ok
17:38:43 <guerra> lemme try
17:48:29 <guerra> sjanssen: i did all u said but there is some problems now in the calls i make to the function
17:51:55 <guerra> brb will talk to u later, tahnks
17:52:38 <robreim> Is there an unsigned equivalent to Integer? Or at least some way of performing unsigned bit operations on Integers?
17:55:02 <dons> sjanssen: around for a teensy bit of beta testing?
17:55:33 <robreim> Actually, maybe I just need to know how Integers in haskell work...
17:55:43 * robreim goes off to study
17:56:14 <dons> sjanssen, anyone, interested in src-location error messages, I've just put up:
17:56:15 <dons> http://www.cse.unsw.edu.au/~dons/loch.html
17:56:15 <lambdabot> Title: LocH
17:56:21 <dons> and am looking for some feedback
18:00:44 <hyrax42> ok so...
18:01:12 <dons> yes?
18:01:20 <hyrax42> I'm (possibly foolishly) trying to reconcile the definition of monad in category theory (as read briefly by me on wikipedia) with my understanding of monads in Haskell
18:01:28 <dons> heh
18:01:56 <hyrax42> where is the "monad" in haskell... ?
18:02:06 <hyrax42> the combination of m, (>>=) and return
18:02:12 <dons> yes
18:02:14 <hyrax42> (or join, since that would be mu, I believe?)
18:02:50 <hyrax42> ok so what category is 'm' a monad on?
18:02:54 <hyrax42> "values"?
18:02:58 <hyrax42> is the best I can come up with
18:03:27 <hyrax42> * by 'm' I mean the triple m, join, return
18:03:43 <monochrom> mu is join, eta is return
18:03:53 <hyrax42> monochrom, :)
18:04:22 <hyrax42> but what category are we dealing with?
18:04:35 <hyrax42> typed values? (?)
18:04:55 <monochrom> each type is an object. each function is a morphism.
18:05:08 <hyrax42> ok that is what I was thinking
18:05:24 <hyrax42> so could one say, par example
18:05:54 <hyrax42> hm
18:06:00 <hyrax42> need to think a bit on phrasign
18:07:42 <hyrax42> ok another quick question whiel I'm digesting
18:08:01 <hyrax42> functors from category theory have two "parts" in the haskell definition
18:08:17 <hyrax42> constructor + fmap
18:08:32 <monochrom> a monomorphic function such as Int->Maybe Int is a morphism.  a polymorphic function such as a -> Maybe a is a natural transformation (from the identity functor to the Maybe functor)
18:09:05 <hyrax42> ah, was hoping I didn't have to click the natural transformation link
18:09:09 <monochrom> Yes.  Maybe is a functor.  The constructor is Maybe.  There is an fmap for Maybe too.
18:09:23 <Cale> > fmap succ (Just 5)
18:09:24 <lambdabot>  Just 6
18:09:34 <Cale> > fmap succ Nothing
18:09:35 <lambdabot>  Add a type signature
18:09:37 <Cale> hehe
18:09:43 <Cale> > fmap succ Nothing :: Maybe Int
18:09:45 <lambdabot>  Nothing
18:09:58 * Botty wonders if it's faster to do a bunch of cons and one reverse than an equal number of concats
18:10:04 <monochrom> @free a->Maybe a
18:10:05 <lambdabot> Extra stuff at end of line
18:10:22 <monochrom> How do I use the free theorem plugin?
18:10:32 <hyrax42> but I'm meaning that in def of functoro n wikipedia, the functor associates an object with each object, and a morphism with each morphism
18:10:35 <monochrom> @free f :: a -> Maybe a
18:10:35 <chessguy> @free ?
18:10:35 <lambdabot> $map_Maybe g . f = f . g
18:10:36 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
18:10:36 <dons> ?free sort
18:10:37 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> [a]\n"
18:10:48 <dons> ?free ord
18:10:49 <lambdabot> ord = ord
18:10:52 <dons> ?fre map
18:10:53 <lambdabot> Maybe you meant: free freshname
18:10:56 <dons> ?free map
18:10:58 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
18:11:05 <dons> ?free a -> b -> a
18:11:05 <lambdabot> Extra stuff at end of line
18:11:07 <hyrax42> for which you need the two parts m and fmap in the haskell rendition?
18:11:34 <Cale> Botty: If you're building a list in reverse like that, it's usually better to work with functions that add whatever to the start of a list, and then start the thing off by passing in an empty list.
18:12:01 <monochrom> Maybe is a functor.  It maps a type to a type, e.g., it maps the type "Int" to the type "Maybe Int".
18:12:04 <Cale> that will avoid the need to do any concats at all, you can use function composition
18:12:31 <monochrom> It also maps a function like "Int->Int" to a function like "Maybe Int -> Maybe Int".
18:12:32 <Botty> Well, I'm taking an item off the front of one list in the parameter, so I have to stick it on the end of the bit i'm working on, since its recursive
18:12:53 <monochrom> (The latter is named "fmap" generically in Haskell.)
18:12:55 <hyrax42> and Int -> Bool to Maybe Int -> Maybe Bool
18:13:01 <hyrax42> and so on?
18:13:04 <monochrom> Yes.
18:13:22 <Cale> > fmap even (Just 5)
18:13:23 <lambdabot>  Just False
18:13:52 <dino-> Botty: Also, reverse is implemented in terms of (:)
18:14:14 <jcreigh> wait...so if I have a -> a, I can just "lift" (is that the right word?) it into Maybe and make Maybe a -> Maybe a?
18:14:20 <jcreigh> > fmap (+2) (Just 4)
18:14:22 <lambdabot>  Just 6
18:14:28 <jcreigh> > fmap (+2) Nothing
18:14:29 <lambdabot>  Nothing
18:14:46 <jcreigh> @type fmap
18:14:48 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
18:14:53 <hyrax42> ok and thinking of "monads as computation", would it be correct to say "Maybe maps types to computations that will compute a value of that type or fail"?
18:15:21 <robreim> @type liftM
18:15:23 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
18:15:31 <hyrax42> ?type fmap
18:15:32 <monochrom> Yes.
18:15:32 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
18:15:48 <hyrax42> hrmmm
18:15:50 <Botty> dunno about 'fail', but they don't return a value
18:15:50 <shapr> yes
18:16:04 <monochrom> liftM = fmap  if the monad laws are obeyed.
18:16:34 <hyrax42> hrmmm
18:17:02 <monochrom> You will need to know natural transformations because the definition of monad requires return and join to be natural transformations.
18:17:20 <hyrax42> ok I'll read up the definition
18:17:37 <hyrax42> (silly me for initially thinking it somehow mean "intuitively natural"!)
18:17:53 <monochrom> It is intuitively natural to me.
18:18:07 <hyrax42> me too soon, p'raps
18:18:07 <monochrom> This is after I have learned it.
18:18:20 <Cale> Botty: here's some example code for you, let me paste it
18:18:23 <Cale> lisppaste2: url
18:18:23 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:18:37 <dino-> Maybe's fail impl is:  fail s = Nothing
18:18:45 <monochrom> Chinese Chess is intuitive to me after I have played many games.
18:19:04 <monochrom> Chess is not very intuitive to me, since I haven't played many games.
18:19:08 <lisppaste2> Cale pasted "tree traversal" at http://paste.lisp.org/display/29924
18:19:19 <monochrom> I can't wait for Chess to become intuitive before I play.
18:19:21 <Botty> thanks cale
18:19:54 <Cale> Botty: try inorderL (exampleTree 10000), and then try inorderF (exampleTree 10000)
18:19:55 <monochrom> But people wait for Haskell to become intuitive before they learn it.  This greatly baffles me.
18:20:06 <Pseudonym> Some day I'd like to implement a mental card game.
18:20:10 <Excedrin> monochrom: maybe it would be if you played many 2d turn based abstract wargames
18:20:13 <Pseudonym> In software, of course.
18:20:29 <Pseudonym> I'm more of a bridge person than a chess person.
18:20:48 <monochrom> Heh, I played some 2d turned based abstract war games too.  Somewhat intuitive.
18:21:08 <hyrax42> mental card game?
18:21:17 <Botty> Cale - heh, nice
18:21:19 <Cale> Botty: or better yet, add a 0 to the end of each of those numbers :)
18:21:29 <hyrax42> ack now I have to read what covariatn functors are
18:21:45 <Cale> hyrax42: those are the ordinary kind of functor
18:21:52 <hyrax42> at least the set of mathematical definitions is well-founded
18:21:55 <hyrax42> it has to bottom out somewhere
18:21:59 <Pseudonym> I find it easier to just think of "functors".
18:22:00 <monochrom> I don't see why covariant functors are needed.
18:22:03 <Pseudonym> I don't either.
18:22:05 <Botty> Cale++
18:22:10 <Pseudonym> Just say that C -> D^op is a functor.
18:22:16 <hyrax42> "If F and G are covariant functors between the categories C and D, then a natural transformation η from F to G ..."
18:22:28 <Cale> hyrax42: ignore the word "covariant"
18:22:36 <monochrom> C->D^op  that will be contravariant...
18:22:54 <hyrax42> m ok
18:23:00 <Cale> a contravariant functor from C to D is a covariant functor from C -> D^op
18:23:06 <Pseudonym> I find it easier to say that F : C -> D^op is a functor than to say that F : C -> D is a contravariant functor.
18:23:08 <Cale> that is, it reverses the directions of arrows
18:23:15 <shapr> Cale: Hey, did you read that Set paper I reference in my blog?
18:23:22 <hyrax42> what is ^op?
18:23:30 <Pseudonym> hyrax: The dual category.
18:23:32 <monochrom> OH!  OK, you can keep the word "covariant", but it's still the same definition as just "functor".
18:23:38 <Pseudonym> In this case, ^ mean superscript.
18:23:44 <Cale> hyrax42: If C is a category, then C^op is the same category except all the arrows have been reversed.
18:23:50 <hyrax42> I figured on the ^
18:23:53 <Pseudonym> Incidentally...
18:23:58 <hyrax42> hmmmm
18:24:02 <Pseudonym> ?free natTrans :: F a -> G a
18:24:03 <lambdabot> $map_G f . natTrans = natTrans . $map_F f
18:24:13 <Pseudonym> That's the definition of a natural transformation.
18:24:17 <hyrax42> is there a source more recommendable than wikipedia for learning this?
18:24:26 <monochrom> #haskell
18:24:29 <Pseudonym> hyrax42: Yes.  There are a lot of books online.
18:24:29 <hyrax42> a "standard" intro category theory text?
18:24:44 <hyrax42> monochrom, :)
18:24:48 <hyrax42> thanks btw
18:25:01 <hyrax42> I'm still working towards phrasing the question that is leading to all this
18:25:23 <Cale> So a contravariant functor is like a covariant one, except that if f: A -> B is an arrow, Tf: TB -> TA.
18:25:31 <shapr> I like that sort of questions.
18:25:44 <Cale> shapr: I noticed the link, I haven't read it yet
18:25:46 <hyrax42> the ones you can't even ask till you learn a bunch?
18:25:55 <Pseudonym> http://www.di.ens.fr/~longo/download.html
18:25:58 <lambdabot> Title: Downloadable Publications
18:26:04 <Pseudonym> The first entry there isn't a bad book.
18:26:11 <Pseudonym> But the first two chapters go quickly.
18:26:24 <Pseudonym> If you have access to a good university library, try looking for Barr & Wells.
18:26:26 <hyrax42> I thikn that is in the library
18:26:26 <shapr> Cale: ok, just curious.
18:26:33 <hyrax42> I prefer dead tree
18:26:55 <Pseudonym> ?google barr wells category
18:27:11 <lambdabot> search module failed: IRCRaised thread killed
18:27:18 <Pseudonym> Woo!
18:27:22 <dons> :)
18:27:23 <Pseudonym> http://www.let.uu.nl/esslli/Courses/barr-wells.html
18:27:27 <lambdabot> Title: Courses: Barr / Wells, http://tinyurl.com/e5zmx
18:27:42 <hyrax42> Pseudonym, "Category theory for computing science"?
18:27:47 <hyrax42> that's in library too
18:27:58 <Pseudonym> I think it's actually called "Categories for Computing Science".
18:28:25 <Pseudonym> Ideally, you want to steer clear of books which require in-depth knowledge of topology.  Unless you have in-depth knowledge of topology.
18:28:27 <hyrax42> well LC is QA76.9 M35 B37 1999  in any case
18:28:32 <hyrax42> I do not
18:28:36 <Pseudonym> Right.
18:28:49 <hyrax42> so I probably will
18:28:59 <Pseudonym> Barr & Wells is pretty good, then.
18:29:18 <Pseudonym> Asperti and Longo is worth it once you have the basics because the second half of the book is all on types and lambda calculus.
18:29:50 <Pseudonym> And it explains the Curry-Howard isomorphism from the point of view of category theory.
18:30:02 <hyrax42> so asperti spends too little time on category theory or?
18:30:07 <hyrax42> *introduction of ~
18:30:21 <Pseudonym> I think it skips over it a bit quickly.
18:30:44 <Pseudonym> For me, I preferred a book that works on developing the intuition.
18:30:54 <hyrax42> advice noted
18:30:56 <hyrax42> thanks
18:30:56 <monochrom> I now remember.  I learned all these from Bird & de Moor, "Algebra of Programming".  Took me a month though.  Can't say any other venue would be any faster though.
18:31:12 <hyrax42> probably not
18:31:30 <Pseudonym> One other thing I found helpful was Ian Stewart's "Galois Theory".
18:31:38 <Pseudonym> It has nothing to do with category theory.
18:31:40 <monochrom> But I liked it because it's written for Miranda.
18:31:57 <Pseudonym> Except that it throws around terms like "automorphism", so you get to see how they work in practice.
18:31:58 <monochrom> or I mean Miranda programmers such as Bird himself.
18:33:39 <shapr> I didn't know Ian Stewart did Miranda.
18:34:04 <monochrom> I was still talking about Bird's book.
18:35:19 <Pseudonym> You can almost see that Stewart wants to use the word "adjunction", but he never quite brings himself to say it.
18:35:51 <Cale> shapr: yeah, that is a nice paper :)
18:36:52 <hyrax42> hm
18:38:04 <Cale> I wish I knew of a good introductory algebraic topology book with a category theory bent to it. There's Hatcher's book, but I don't recall liking the way that he treats the Seifert-van Kampen theorem.
18:38:27 <hyrax42> are types somehow sets?
18:38:30 <Pupeno_> foreign import ccall safe "io.h _open" expects to find the file io.h and an _open function on it ?
18:38:30 <Cale> (It's okay, but it's so much nicer when you look at it categorically as a pushout)
18:38:40 <Cale> hyrax42: they're quite a lot like sets
18:39:18 <Cale> and Haskell functions are quite a lot like functions :)
18:39:29 <hyrax42> ok I'm going to give in and ask possibly badly phrased question
18:39:55 <monochrom> Within the confine of HM-polymorphism, the only polymorphic first-order functions you can write are natural transformations.
18:40:07 <hyrax42> is there an analogy between Maybe and computations that may or may not halt
18:40:15 <Cale> yes, of course :)
18:40:23 <monochrom> Yes, if you ignore decidability.
18:40:29 <hyrax42> where _|_ can be considered as Nothing
18:40:46 <Cale> yeah, but pattern matching there becomes hard :)
18:40:46 <Pseudonym> monochrom: That's a slight lie.  A natural transformation is between fucntors.
18:40:52 <Pseudonym> Not between types.
18:41:00 <monochrom> Damn, I lied.
18:41:02 <Pseudonym> To be a natural transformation, you need a notion of "map".
18:41:11 <hyrax42> well we're doing computability theory now in my intro computation class
18:41:23 <hyrax42> and we're doing a lot of things that look like (>>=) for Maybe
18:41:26 <Pseudonym> But yes, if F and G are functors, then any function of type F a -> G a is a natural transformation.
18:41:28 <dons> mmm, nice. http://www.warren.usyd.edu.au/bulletin/NO48/ed48art4.htm  (pity it doesn't mention that the work uses Haskell to provide the kernel proofs over to Isabelle )
18:41:29 <Cale> because when you go to determine whether or not something halts, well, you can't do that easily.
18:41:32 <lambdabot> http://tinyurl.com/yfd4tz
18:41:46 <Cale> Sometimes you can't do it at all.
18:41:48 <dons> "creating a mathematical proof that the operating system code is free of faults" == Haskell + Isabelle
18:42:15 <monochrom> "Software Faults for Free!"
18:42:26 <hyrax42> well for example when proving the union of two recursively enumerable sets is RE
18:44:10 <hyrax42> we sort of define the seme-charectersitc function of A union B as 1_AuB x = 1_A x >>= (1_B x &&) . return
18:44:13 <hyrax42> or some such
18:44:32 <hyrax42> ((1_B x) &&)
18:44:49 <hyrax42> or still doesn't type check
18:46:10 <mcnster> hello
18:46:11 <lambdabot> mcnster: You have 1 new message. '/msg lambdabot @messages' to read it.
18:46:12 <hyrax42> 1_A x >>= \b1 -> 1_B x >>= \b2 -> b1 && b2
18:46:45 <hyrax42> where at any point something may fail to halt, but that's "fine"
18:47:35 <hyrax42> so can we say there is a monad that maps types to computations that may produce a value of that type or diverge?
18:48:39 <mcnster> can anyone say a word or two about the issues regarding making the x86_64 arch obey -dynamic?
18:48:57 <lambda_the_insig> is there any way of getting a list of all types which have instances for a particular typeclass?  (Probably have to be something TH or other metaprogramming related)
18:49:09 <heatsink> lambda_the_insig, no
18:49:22 <hyrax42> cale, monochrom, Pseudonym... anyone?
18:49:26 <monochrom> yes.
18:49:42 <hyrax42> good
18:49:45 <lambda_the_insig> is this theoretically infeasible, or do things like Dynamic make it impossible?
18:49:53 <hyrax42> thank you
18:49:53 <hyrax42> all
18:49:57 <lambda_the_insig> s/infeasible/feasible/
18:50:05 <Pseudonym> Sorry.
18:50:09 <heatsink> lambda_the_insig, it's infeasible, but also the things that are possible aren't implemented.
18:50:14 <Pseudonym> AFK briefly.
18:50:21 <Cale> lambda_the_insig: you can type :info MyClass at the ghci prompt and you'll get a list of them
18:50:26 <Cale> but not from code, no
18:50:42 <heatsink> It's probably infeasible to get a list of all types, because the list may be infinite
18:51:01 <heatsink> e.g., [Int], [[Int]], [[[Int]]] ... are all in Show
18:51:14 <lambda_the_insig> how about for all concrete types?
18:51:52 <heatsink> The information is there in the compiler, but there's no way to get it out in TH.  I don't think there's any other way either, except for what Cale mentioned.
18:54:19 <mcnster> [haskell t-shirt:  "We won't know until it runs.  And it *will* run."]
18:54:20 <dons> ?instances Monad
18:54:22 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:54:25 <dons> lambda_the_insig: ^^
18:54:52 <dons> ?instances Num
18:54:53 <lambdabot> Double, Float, Int, Integer
18:55:42 <heatsink> ?instances Writer
18:55:44 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
18:56:04 <lambda_the_insig> ?instances Show
18:56:05 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
18:56:09 <heatsink> ?instances MonadWriter
18:56:10 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
18:56:39 <heatsink> Only up to 4-tuples?  I thought the default was like 5 or 6
18:56:41 <lambda_the_insig> would one of the GHC.* modules help in this regard?
18:56:54 <lambda_the_insig> on ghci, I'm showing 5-tuples
18:56:56 <lambda_the_insig> 6.4
18:57:50 <mcnster> [haskell t-shirt:  Haskell programmers do it lazily and layed-out."]
18:59:02 <monochrom> haha
18:59:46 <Pseudonym> Haskell programmers do it when demanded.
18:59:55 <heatsink> do it on demand?
19:00:11 <Pseudonym> Nah, we're pure.
19:00:49 <shapr> Wow cool, I'm going to get to do my #haskell tour in person for the first time!
19:00:59 <heatsink> what?
19:01:05 <heatsink> Also, is [| Nothing :: forall a. Just a |] a CAF?
19:01:06 <shapr> I'm going to meet a guy here in Birmingham who wants to learn about Haskell and found me on google.
19:01:19 <Smokey`> haha :)
19:01:25 <heatsink> on google?
19:01:51 <shapr> Yeah, he searched google for haskell alabama and found my blog post about getting my Alabama driver's license.
19:02:16 <heatsink> Oh, okay.  I thought google had some beta version of a matchmaking service.
19:02:25 <heatsink> Hey, it's search...
19:02:27 <shapr> hah
19:02:41 <shapr> Good point actually.
19:02:51 <shapr> Now I have to get Hugs working on my 770...
19:02:51 <dons> shapr: cool!
19:03:00 <shapr> Best would be lambdabot...
19:03:06 <heatsink> I thought you were in the netherlands... did you move?
19:03:24 <dino-> shapr: oo, I'd like to see that. Hugs on the 770.
19:03:32 <dino-> Would be cool.
19:03:39 <shapr> I was in Sweden, and I moved back to Alabama a coupla months ago.
19:03:48 <shapr> dino-: Should be easy, it's a C program.
19:03:55 <heatsink> I see.
19:03:59 <shapr> GHC on the 770 would be much niftier.
19:04:07 <shapr> And slower...
19:04:53 <shapr> heatsink: I left Sweden because the tax office was out for my blood. After much confusion on my part I refiled... and now the tax office owes me ~ $10k
19:05:13 <heatsink> wow, that's huge.
19:05:39 <shapr> I should read SPJ's "How to Write a Financial Contract" twice in a row.
19:05:44 <dcoutts> :-)
19:05:49 <shapr> Just for penance...
19:06:28 <dcoutts> shapr, I just read that paper you recommended on models of the mechanics of unicycling. Fun :-)
19:06:49 <shapr> yay!
19:07:11 <dcoutts> it's both serious and silly at the same time :-)
19:07:20 <dons> a new logo for the HWN: http://www.haskell.org/haskellwiki/Haskell_Weekly_News  :)
19:07:23 <lambdabot> Title: Haskell Weekly News - HaskellWiki, http://tinyurl.com/yhepg7
19:08:19 <chessguy> @go model mechanics unicycling
19:08:20 <hyrax42> ?pl \f -> (>>= return.f)
19:08:34 <lambdabot> search module failed: IRCRaised thread killed
19:08:35 <lambdabot> fmap
19:09:00 <heatsink> > do {x | True <- [1,2,3]; | False <- [4,5,6]; return x}
19:09:00 <lambdabot>  Parse error
19:09:54 <hyrax42> what ?
19:10:28 <heatsink> hyrax42, it's fmap
19:10:39 <hyrax42> no I know that
19:10:46 <hyrax42> what  I don't know is whaty ou meant with your do
19:11:01 <heatsink> I was trying to use guard syntax
19:11:20 <heatsink> > let {x | True = [1,2,3]; | False = [4,5,6]} in x
19:11:21 <lambdabot>  Parse error
19:11:23 <hyrax42> though I was wanting lambdabot to give me it with (.), bt ah well
19:11:31 <heatsink> > let {x | True = [1,2,3]} in x
19:11:32 <lambdabot>  [1,2,3]
19:11:41 <shapr> dons: nice logo
19:14:24 <dino-> dons: heh, it's amusing
19:14:36 <jcreigh> YAHT is trying to scare me: "Be sure you understand it well: things only get more complicated."
19:15:06 <LoganCapaldo> jcreigh: Haven't I seen you before?
19:15:11 <LoganCapaldo> ;)
19:17:06 <jcreigh> LoganCapaldo: well, it can't really be helped, seeing as how your channel list is a subset of mine. :)
19:17:19 <heatsink> @pl foldr mplus mzero
19:17:20 <lambdabot> foldr mplus mzero
19:17:25 <chessguy> jcreigh, it's true. it does get more complicated
19:24:32 <dcoutts> dons, hah, nice logo! :-)
19:25:55 <sieni> hva?
19:26:48 <sieni> cool :-)
19:29:50 <dibblego> > length [[]]
19:29:51 <lambdabot>  1
19:30:06 <dibblego> damn it, I have made that mistake so many times (thinking it is 0)
19:31:35 <lennart>                                                                                                                                                                                                                                  
19:32:12 <Turks_> hiss
19:32:28 <Turks_> o.0
19:32:31 <heatsink> haha
19:32:47 <Pupeno_> When trying to build an executable I get the error: "Examples/Binary.hs:2:7: Could not find module `System.Stream': it is a member of package Streams-0.1.7, which is hidden" from Cabal. I've tried adding Build-depends and Other-modules, but Streams remains hidden (note: this is IN the Streams package). How should I 'unhide' it ?
19:32:48 <lennart> > length $ transpose $ transpose [[]]
19:32:50 <lambdabot>  0
19:32:56 <Turks> die evil laptop
19:32:58 <Turks> :>
19:33:51 <Turks> kinda off topic, but does anyone know if there is a channel for Anope irc services?
19:35:15 <Pupeno_> > transpose [[]]
19:35:16 <lambdabot>  Add a type signature
19:35:28 <dons> Pupeno_: ghc-pkg expose Streams-0.1.7 -- ?
19:36:37 <Pupeno_> dons: it is shown in ghc-pkg list, I don't know why, I never installed Streams-0.1.7
19:36:59 <Pupeno_> oh, I did.
19:37:03 * Pupeno_ uninstalls.
19:38:04 <Pupeno_> there, now the error changed.
19:40:04 <Pupeno_> I now simple get "Examples/Binary.hs:2:7: Could not find module `System.Stream': Use -v to see a list of the files searched for.". It should include Streams, how do I do that ? this package *is* Streams.
19:42:37 <shapr> lennart: Your mind is blank.
19:42:58 <lennart> how did you know? :)
19:43:27 <shapr> lennart: I had a nightmare about you last week. Get out of my head!
19:43:54 <lennart> hmmmm, I'm not sure if that is a comliment or not
19:44:02 <lennart> (insert p)
19:44:06 <shapr> You kept trying to teach me something and I just could not grasp it.. everytime understanding was within my reach, a vital piece would slip away....
19:44:41 <shapr> I've never had nightmares about functional programmers before.
19:45:20 <lennart> :)
19:45:36 <shapr> Anyway, doing anything cool these days?
19:45:40 * Botty has had dreams about dysfunctional programmers before...
19:45:50 <Botty> nightmares, rather
19:47:39 <Korollary> That's not really a nightmare anyways.
19:48:15 <Korollary> I bet lennart can try to teach me a lot of things that I couldn't grok.
19:48:31 <lennart> shapr: I'm trying to add a flag to switch on and off my overloadable strings
19:48:43 <SamB_XP> well, having parts of your understanding slip away all the time would be...
19:48:59 <dons> lennart: yeah, sounds nice
19:49:09 * dons wants bytestring literals in lambdabot :)
19:49:10 <lennart> Korollary: I could teach you things you couldn't grok?  Hmmmm, sounds kinda contradictory
19:49:23 <dons> currently the best I can do (performance wise) is to use unboxed string literals, "foo"#
19:49:23 <Korollary> lennart: I said 'try to teach'
19:49:30 <dons> and a rewrite rule which packs them to ByteString
19:49:44 <dcoutts> dons, yeah, isn't that enough performance wise ?
19:49:44 <lennart> Korollary: so you did :)
19:49:58 <SamB_XP> lennart: overloadable strings? ooh... that reminds me of my idea for a Stringy class...
19:49:59 <dons> its enough perf-wise, but its ugly :)
19:50:03 <dons> "(^| )(should )i($| |\\.|!|,|\\?).*"#
19:50:15 <dcoutts> dons, it's just a matter of using pack, it's not that bad
19:50:18 <lennart> dons: exactly, I want my strings literals to look nice
19:50:45 <robreim> How can I get past this error when manually recompiling a module from the haskell library:  GHC/Base.lhs:272:5: Illegal binding of built-in syntax: []
19:50:52 <dons> dcoutts: a nice soln to overloaded strings would be useful though, if done with grace and tact.
19:51:03 <dcoutts> dons, why do you need to use ""# rather than pack "" ?
19:51:11 <shapr> robreim: rebuild GHC?
19:51:17 <SamB_XP> robreim: don't try to compile GHC.Base on your own!
19:51:18 <shapr> robreim: What are you doing anyway?
19:51:32 <dons> dcoutts: oh, right. the # is obsolete
19:51:39 <robreim> So I can't just compile one part of the libraries? Gotta recompile all of GHC? :(
19:51:41 <dons> the alternative is to use: pack "foo", + a rewrite rule
19:51:48 <dons> that gives us packAddress "foo"#
19:51:54 <SamB_XP> dons: and you got that to work now?
19:51:57 <Pupeno_> how do I make an executable in a Cabal 'project' be able to use the library the project builds ?
19:52:05 <dcoutts> dons, yes, which is already implemented in the BS lib isn't it?
19:52:07 <dons> pack "foo" does yeah, the rule was a bit borken. its fixed now
19:52:09 <dons> right
19:52:29 <dons> so its not a killer. i'm not agitating for change. but if overloaded string literals happened, i wouldn't complain :)
19:52:36 <dcoutts> aye
19:53:21 <dons> hmm. this 'assert' passing makes me think we could have the compiler insert the assert tags for us... via a rewrite rule!
19:53:32 <dons> RULE fromJust m = fromJustSafe assert m
19:53:43 <SamB_XP> heh
19:53:50 <SamB_XP> do you really think that would work?
19:53:51 <dons> any takers?
19:53:54 <dons> I think maybe!
19:53:56 * dons tries it
19:54:05 <dons> i.e. you could add tracing by turning on a rewrite rule...
19:54:27 <lennart> gah!  Getting hold of flags in ghc is non-trivial
19:54:44 <SamB_XP> lennart: wait for someone to hand them to you
19:57:13 <Korollary> let's fork java until it's lazy with a better type system.
19:57:26 <shapr> Then we can call it... Haskell!
19:57:31 <Korollary> gradually
19:57:34 <lispy> Korollary: look at scala, they've done the second part and partially the first :)
19:57:51 <pkhuong> lispy: just have to add macros then ;)
19:58:02 <lispy> heh
19:58:07 * lispy just gave a talk about darcs
19:58:10 <lispy> i think it went okay
19:58:19 <lispy> but i was *COMPLETELY* unprepared...
19:58:20 <shapr> and?
19:59:04 <Pseudonym> Thankfully, all modifications to your talk will commute.
20:00:13 <Korollary> darcs is free of chemical toxins of big pharma. It's made using all natural herbs and other woo. It's good for you. Cheers.
20:01:15 <shapr> I didn't know herbs were a type of w00
20:01:19 <shapr> But it makes sense!
20:01:47 <Korollary> some herbs do have good stuff in them.
20:02:36 <lennart> like magic mushrooms
20:02:44 <robreim> I could do with some woo right about now. Maybe I should crack open a can of darcs.
20:03:49 <lispy> darcs the other pharmacutical
20:04:49 <lennart> beware of the darcs IDE
20:05:03 <Pupeno_> is it possible to make an executable use a library that is the same package where they are part of ?
20:05:38 <dons> dcoutts: want to debug a rule? SamB_XP too?
20:05:41 <dons> test program: http://www.cse.unsw.edu.au/~dons/tmp/A.hs
20:05:49 <dons> grab loch, http://www.cse.unsw.edu.au/~dons/loch.html
20:05:49 <lambdabot> Title: LocH
20:06:02 <dons> now, we should be able to get the rewrite rule to change the use of fromJust into safeFromJust
20:06:12 <dcoutts> dons, what's the problem exactly ?
20:06:20 <dons> can't get the rule to fire yet
20:06:38 <dons> but if we can, then we can use rewrite rules to add src locations to partial functions *transparently*
20:06:42 <dons> without having to modify the user's src
20:07:01 <dons> ie.. RULE "safe head" head = safeHead assert
20:07:06 <dons> would be all that is needed
20:07:19 <dcoutts> dons, but where does the assert get its source location from ?
20:07:23 <lennart> dons: will that code actually have assert located at the right place in the error message?
20:07:26 <dons> the compiler expands it at some point
20:07:33 <dcoutts> dons, wont it come from the location of the rule itself ?
20:07:36 <dons> depends on whether the rewrite rule inserts it into the right location...
20:07:45 <dcoutts> aye
20:07:55 <dons> not sure... if the rewrite rules inserts it into the tree, and *then* its expanded...
20:08:02 <dcoutts> mm
20:08:04 <dons> (which maybe could be done ...)
20:08:21 <dons> which means we could just about do this with TH too..
20:08:47 <dons> so the key is to get assert put into the AST at the right place, before 'assert' is expanded into its loc
20:08:53 <dcoutts> dons, step 1, add -fglasgow-exts, or rules are ignored
20:08:56 <dons> ah yes!
20:09:10 <dcoutts> then tell me if it still doesn't work ;-)
20:09:13 <dons> 5 RuleFired
20:09:13 <dons>     1 safe fromJust
20:09:16 <dcoutts> woo
20:09:52 <dons> ok, weird. I think we're seeing what ghc does to assert here:
20:09:53 <dons> $ ./A 3
20:09:53 <dons> A: Prelude.undefined
20:10:01 <robreim> as far as signed types go, I only really need to worry about the Int* family and Integer, right?
20:10:19 <dons> ah hang on ...
20:10:25 <robreim> in stock haskell that is
20:11:50 <theoco> data never changes!!!
20:11:51 <dcoutts> robreim, there's a bunch of int types in Data.Int, Int8, Int16, Int32, Int64
20:12:19 <theoco> time changes rendering data obsolete
20:12:19 <robreim> dcoutts: yeah, that's what I meant by the * in Int*
20:12:23 <dcoutts> robreim, oh you said the Int* family, sorry I missed that
20:12:30 <dcoutts> robreim, so yeah, that's it.
20:12:36 <robreim> cool, thanks
20:12:43 <theoco> can someone give me a high-level description of monads?
20:12:49 <dcoutts> robreim, there's rationals too, dunno if that's relevant
20:13:21 <sieni> theoco: high level being what?
20:13:34 <theoco> sieni: skip the details
20:13:40 <dcoutts> theoco, they're a framework for organising various kinds of computation, how's that for high level and non-specific? ;-)
20:14:07 <robreim> dcoutts: I'm only interested in members of the Bits typeclass right now so I don't think that includes rationals, though thanks for pointing that one out
20:14:14 <sieni> theoco: http://www.nomaware.com/monads/html/analogy.html
20:14:18 <lambdabot> Title: A physical analogy for monads, http://tinyurl.com/osvs6
20:14:48 <theoco> is a monad basically a function that doesn't act in the literal way that a mathamatical function should
20:15:19 <sieni> no
20:15:38 <theoco> k, reading... ty
20:15:56 <lispy> darcs IDE?
20:16:32 <robreim> ?where monads as containers
20:16:33 <lambdabot> http://www.nomaware.com/monads/html/index.html
20:16:50 <sieni> monadic operations are as pure and referentially transparent as any other haskell functions
20:16:58 <theoco> what is it called in haskell when a function modifies outside values?
20:17:19 <kpreid> a bug?
20:17:25 <dcoutts> impure?
20:17:47 <theoco> is there a scheme set! equivalent in haskell?
20:17:48 <Pseudonym> unsafePerformIO?
20:18:04 <dcoutts> theoco, no. No mutable variables.
20:18:08 <sieni> the point is that you can emulate modifiable state by passing the state to every function and monads can hide that conveniently
20:18:25 <theoco> good, I hate scheme set!
20:18:44 <Pseudonym> theoco: You're one of us!
20:18:46 <theoco> ruins the language imho
20:18:56 <theoco> Pseudonym: nice :)
20:18:57 <Pseudonym> Pull up a lambda!
20:19:05 <kpreid> hrmph.
20:19:14 <kpreid> less ideology, more this-is-a-useful-thing
20:19:24 <sieni> theoco: if you know scheme, you might like http://okmij.org/ftp/Scheme/monad-in-Scheme.html
20:19:26 <lambdabot> Title: Monads in Scheme, http://tinyurl.com/y9towy
20:19:26 <robreim> theoco: here's a high level description of monads: http://www.haskell.org/haskellwiki/Monads_as_Containers
20:19:29 <lambdabot> Title: Monads as containers - HaskellWiki, http://tinyurl.com/llgo9
20:20:23 <theoco> so is it correct to say there is no assignment in haskell?
20:20:52 <encryptio> there is no assignment as it exists in other languages
20:20:56 <dons> there's mutable variables if you need them. they're not the default.
20:21:35 <theoco> I am starting to think mutables/assignment are the bane of computation
20:21:41 <dons> (being the default would be kind of insane, since you immediately massively complicate reasoning about the code, and make life hard for everyone)
20:22:07 <Cale> theoco: there are a few times where they're justifiable, but in general, I strongly agree with you.
20:22:08 <robreim> dons: I see you're implying virtually every language but haskell is insane :)
20:22:11 <theoco> my professor today told me, data changes
20:22:15 <theoco> I was furious
20:22:32 <Pseudonym> Constants aren't.  Variables won't.
20:22:48 <dons> robreim: right. it just wasn't recognised until the last 20 years or so that having mutable state by default bites. like having sequential evaluatoin by default bites .. once you start going multicore/parallel
20:23:01 <theoco> data can be old, obsolete, or incorrect.  but changing data, I've never seen that in my life
20:23:05 <dons> not recognised by the mainstream until last year even ;)
20:23:20 <robreim> like having strict evaluation by default is insane :)
20:23:22 <dons> dcoutts: hmm. I think i see now
20:23:28 <dons> you need -O to get rewrite rules on
20:23:33 <dons> but -O *disables* assert
20:23:37 <dcoutts> ah right yes
20:23:49 <dons> now, you can disable assert with -fignore-asserts
20:24:01 <dons> but we'd actually need -fdont-ignore-asserts for -O
20:24:01 <Pseudonym> Strict evaluation by default isn't as dumb, admittedly.
20:24:08 <Pseudonym> Some things are better and some things are worse.
20:24:11 <theoco> hey Im trying to start up #compsci
20:24:19 <dons> strict eval's fine. its not as evil as a lot of other things.
20:24:24 <Pseudonym> Right.
20:24:37 <Pseudonym> There's a lot to be said for a predictable performance model if you need it.
20:24:49 <Cale> It's still kind of dumb, if you ask me, but yeah, not nearly as dumb :)
20:24:52 <robreim> Pseudonym: I kind of think of strict evaluation as an optional optimisation over lazy evaluation which is more declaritive... to me it makes sense to have lazy evaluation as the default, not the other way around.
20:24:53 <theoco> you guys should join cause I think lots of stuff that I like to discuss in various channels is off-topic.  cause it applies to lots of areas
20:25:30 <Pseudonym> robreim: From the point of view of semantics, I agree with you.
20:25:38 <Pseudonym> Lazy evaluation is more logical.
20:25:53 <Pseudonym> But from the point of view of pragmatics, strict evaluation isn't stupid.
20:26:57 <Cale> non-strict semantics is the smart way to have programs behave, lazy evaluation may not be the absolute best way to get it
20:27:44 <robreim> Oh I never said it was stupid, nor even insane in general. Just that it probably isn't suitable as a default evaluation strategy for almost the same arguments as doing away with assignment as a default strategy: improves reasoning of code and can always be brought in if optimisation requires it
20:27:57 <dons> dcoutts: oh, I can get the rule to fire without -O... hmm!
20:28:13 <dcoutts> dons, really? how?
20:28:13 <Cale> robreim: yeah, I agree with that :)
20:28:48 <dcoutts> dons, -fgive-me-rules ?
20:29:14 <dons> seems to just work in ghc 6.6
20:29:27 <dons> VICTORY IS MINE!
20:29:27 <Pseudonym> Lazy evaluation is what gives Haskell its modularity, IMO.
20:29:28 <dons> $ ./A
20:29:29 <dons> A: A.hs:19:36-41: Maybe.fromJust: Nothing
20:29:35 <dcoutts> :-)
20:29:40 <Cale> Pseudonym: I totally agree.
20:29:48 <dcoutts> dons, you mean rules are always on in 6.6 irrespective of -O?
20:29:53 <Pseudonym> But unfortunately, it's also what gives it its occasionally unpredictable performance model.
20:30:04 <dons>  fromJust s -> "located fromJust" fromJust = check assert . myFromJust -> A: A.hs:19:36-41: Maybe.fromJust: Nothing ->
20:30:07 <dons> 1 RuleFired
20:30:10 <dons>     1 located fromJust
20:30:15 <dons> dcoutts: local rules, I think
20:30:24 <dcoutts> hmm, ok
20:30:35 <dons> that's the only rule that fies
20:30:42 <dons> let me write this up...
20:30:47 <dcoutts> good work
20:30:50 <Pseudonym> I think there's a research hurdle that has to be overcome with lazy evaluation.
20:31:05 <dons> ah, but what line is that assert on?
20:31:07 <Pseudonym> Don't get me wrong.  Right now, it's practical for many, possibly even most, applications.
20:31:23 <dons> dcoutts: doh. its the line in the rewrite rule..
20:31:28 <dcoutts> :-(
20:31:33 <dons> so the assert is expanded before the rules fire
20:31:38 <dcoutts> yeah
20:31:39 <Pseudonym> But I think that someone is going to have to think hard about it a bit more before it's mainstream.
20:31:40 <dons> but i bet we could convince spj to think about this..
20:31:44 <dibblego> lazy evaluation is all around us
20:31:48 <dcoutts> dons, probably, yes
20:31:58 <dibblego> even in your local J2EE shop
20:32:21 <dcoutts> they just don't call it that
20:34:37 <dons> what's a good commad line tool for numbering lines of a file?
20:34:46 <dons> is there a cat flag for that?
20:34:47 <encryptio> cat
20:34:51 <dcoutts> cat -n
20:34:51 <encryptio> cat -n
20:34:53 <dons> ah yes
20:38:55 <Cale> "60. Dana Scott is the Church of the Lattice-Way Saints." -- haha
20:40:01 <sjanssen> @type interact $ unlines . zipWith (\i s -> show i ++ " " ++ s) [1..] . lines
20:40:03 <lambdabot> IO ()
20:43:29 <sjanssen> @pl \ i s -> show i ++ " " ++ s
20:43:30 <lambdabot> (. (' ' :)) . (++) . show
20:44:15 <robreim> intercalate! :)
20:45:45 <theoco> are mutables a requirement of programing, or are they just "easy-ways-out" of doing things in a functional manner
20:46:26 <theoco> yes, or no?
20:46:33 <Botty> theoco - more of a pre-emptive optmization
20:46:45 <robreim> theoco: mostly they just make some things more efficient. Like mutable arrays.
20:46:48 <lispy> turing machines allow mutable state
20:46:56 <lispy> and i think it just sort of cascades from there
20:47:04 <lispy> but the lambda calc dosen't need them
20:47:13 <Cale> that is, when they're needed at all
20:47:36 <theoco> k, nobody said yes or no
20:47:45 <Botty> dunno about cascading from there, I mean, I doubt they were really thinking much about turing machines when they made languages with mutables
20:47:49 <Cale> There are also some abstractions which can be built with them which are really quite effective, but they tend to damage compositionality in the long run.
20:48:15 <lispy> Botty: von neumann is based on implementing a TM in hardware though righT?
20:48:32 <lispy> Botty: and the languagse like C are about being efficiently compiled to what the hardware does
20:48:41 <Botty> not sure about that, turning machine is pretty general i thought
20:48:42 <Cale> It seems that for things like I/O, things like the location of the mouse pointer, for instance, it's nice to have mutable variables.
20:49:02 <lispy> Botty: yeah, that's why it starts there :)
20:49:03 <dcoutts> na, the location of the mouse pointer is a time series
20:49:09 <theoco> lispy: von neumann just specified a orgainization of a computational system, nothing more
20:49:10 <Botty> yeah, mutable variables are nice for asking questions like "what is it right now?"
20:49:20 <Cale> Though what you'd rather do is have a uniform way to work with that state declaratively.
20:49:40 <Cale> What is the current time? :)
20:50:08 <theoco> Cale: but the location of the mouse pointer is just a funciton of time
20:50:30 <Cale> The problem with dealing with user input as a function of time is that it will be a function which is always partially defined.
20:50:44 <Cale> and in fact, changing over time anyway
20:50:56 <theoco> partially defined?
20:51:09 <encryptio> you cant
20:51:15 <encryptio> can't look into the future
20:51:18 <Cale> yes, you can't just ask for the location of the mouse 10,000 years into the future
20:51:31 <lispy> theoco: it doesn't specify the load/store archiecture?
20:51:36 <Cale> Well, you might be able to, but you'll certainly have to wait if you do
20:51:37 <theoco> so its a complex dynamic function, so what?
20:52:10 <Cale> So what semantics would you have? Evaluation of mouseLocation at a future time blocks?
20:52:45 <Botty> and can you live with the fact that it looks up the current time, for no real reason
20:53:10 <Botty> on that thought, how would you even do that... I suppose the IO monad solves it
20:53:30 <Cale> What you really want is a way to declaratively specify how bits of user input get shuffled around to outputs.
20:53:37 <lispy> there is a wxhaskell that does bouncing balls on a form and it uses infinitely lists of ball positions.  Runs quite fast and memory stable.  That's basically just a big time series
20:53:41 <theoco> shouldn't the processor know what "time" it is, just how many ticks it has gone through
20:54:41 <Excedrin> RDTSC returns that on x86
20:54:54 <sjanssen> Does Anybody Really Know What Time It Is?
20:55:02 <Cale> lispy: sure, but those infinite lists have more to do with the output
20:55:19 <sjanssen> Does anybody really care?
20:56:01 <Botty> another thing, what if you ask it for the mouse position 20 hours ago - is it really going to have to remember all of them just so it's properly functional?
20:56:02 <Cale> and while yes, you can construct stream-processing models of IO, you end up with systems in which you have complicated merge operations, and it's really still not all that easy to reason about most of the time
20:56:14 <dons> sjanssen: want to tackle the "Use TH to rewrite fromJust to safeFromJust" challenge? :)
20:56:31 <dcoutts> dons, I don't think TH will help you
20:56:32 <theoco> Botty: no, I think there should be a way to prove data is obsolete and then remove it
20:56:45 <dcoutts> dons, it's completely the opposite of transparent
20:57:00 <dons> possibly. maybe a preprocessor would be simpler
20:57:06 <Botty> I suppose, if your input library is statically linked and the compiler can handle that proof (and knows to do it)
20:57:15 <dons> that just preprocessed fromJust/head/... to check assert . fromJust ..
20:57:27 <dons> hmm. that's probably a 10 line program with Language.Haskell ..
20:57:28 <Cale> It will be easier to do that if you actually represent state somehow, just maybe not in such a way that things can be updated directly :)
20:57:46 <sjanssen> dons: I was just about to suggest Language.Haskell
20:58:02 <Cale> Like, if you let the programmer say "This variable is the value of the mouse pointer ten seconds ago"
20:58:08 <dons> sjanssen: ok. i'll try that
20:58:38 <Cale> but then not reassign that variable to something else -- it's declarative
20:58:46 <Botty> purity in the sense of not modifying external functions is ok, purity in the sense of always returning the same thing with the same args isn't cool
20:58:50 <robreim> as I understand it, yampa solves this "what time is it" problem by just not allowing time to be first class. ie, you can manipulate signal transformers, but not the signal/time itself. Apparently it solves the problems you guys are speaking of quite nicely.
20:59:00 <Botty> well, it is cool, just not always good
20:59:01 <sjanssen> dons: using the generics stuff makes it quite easy
20:59:22 <Cale> Well, this way you'd still get some level of referential transparency.
20:59:43 <Cale> Depending on how well-separated these new variables were.
20:59:45 <theoco> Botty: maybe lots of things are really time dependent, but that is not currently taken into account
20:59:48 <Botty> *external vars
21:00:17 <Cale> I personally value referential transparency quite a lot -- at least in the core language :)
21:00:40 <Cale> It even kind of bothers me that getStdGen is there, even though that's in IO
21:00:53 <dons> sjanssen: generic traversals, you mean?
21:01:14 <dons> eveywhere "fromJust" "safeFromJust" roughly?
21:01:32 <sjanssen> yeah, but probably way more verbose
21:01:50 <Botty> I had a thought - if you can prove something about a DSL (in the non-haskell sense), then you can easily prove things about things written in it.
21:02:03 <dons> i'm quite excited about this. a preprocessor is also a fairly lightweight way to track down these bugs..
21:02:09 <Botty> even if the things written do not have obviously referentially transparent syntax
21:02:13 <dons> anything that means you don't have to actually modify the src
21:02:13 <Cale> Botty: yes
21:02:23 <Cale> Botty: like my Sudoku solver :)
21:02:48 <hyrax42> what would safeFromJust do
21:02:59 <hyrax42> or how do you guarantee its safety, assuming same type
21:03:16 <dons> no no. it just tags the call site onto the exception
21:03:23 <dons> so you can track down
21:03:23 <Botty> Right.  That's my main idea atm - have a core language like haskell (probably more minimal) and make a tree of DSLs
21:03:25 <hyrax42> ohhh
21:03:26 <hyrax42> making it
21:03:28 <hyrax42> useful
21:03:30 <dons> so its : locatedFromJust
21:03:38 <sjanssen> dons: Language.Haskell even annotates the parse tree with source locations, so you don't have to use the assert hack
21:03:40 <hyrax42> got it
21:03:47 <dons> sjanssen: hmm. just strings would do
21:03:51 <dons> ok.
21:03:55 * dons investigates
21:04:01 <hyrax42> so would then that be useable straight insstead of fromJust
21:04:18 <hyrax42> and even desireable to have it replace it?
21:04:19 <Cale> Botty: yep, that's what the whole Monad/Idiom/Arrow thing is all about :)
21:05:50 <Botty> really... I think the main difference is that in mine the whole syntax is left behind :)
21:06:56 <hyrax42> ?docs Language.Haskell
21:06:56 <lambdabot> Language.Haskell not available
21:07:09 <Cale> Well, there's something nice about having EDSLs which share common syntactic and semantic building blocks -- it means that you can share parts between programs written in different EDSLs, especially control structures
21:07:21 <robreim> Gah! I just spent 30 minutes trying to figure out why GHC was insisting my function was undefined when it was. Then I realised the function was only defined in a copy of the file which I had open, not the one being compiled. *sigh* there's 30 minutes of my life I'll never get back.
21:07:22 <Botty> right
21:07:26 <lispy> dons++
21:07:29 <lispy> dons: nice email!
21:08:00 <Pupeno_> Can runhaskell use .o/.hi files for neede modules in a program being run (instead of requiring the .hs and compiling it ?)
21:08:51 <hyrax42> if runhaskell points to runghc I think yes
21:08:58 <hyrax42> but not if runhugs
21:09:13 * Pupeno_ never had hugs installed.
21:09:16 <hyrax42> (I'm not an authority)
21:09:42 * hyrax42 mentioned it in case Pupeno_ was planning on distributing...
21:10:26 <hyrax42> but I guess the only way to find out is to check
21:11:16 <lispy> dons: but maybe rewriting things to insert assert is not the right idea...maybe error should be tweaked to have the assert
21:11:39 <Pupeno_> hyrax42: what I meant if that I already tried and it didn't work.
21:12:12 <Pupeno_> and I thought that maybe some parameter might help...
21:13:15 <Cale> lispy: but then the errors would be reported in the definition of head/tail/etc?
21:13:23 * mwc bitches and moans about the Shootout not running ghc .6
21:13:26 <mwc> * 6.6
21:14:17 <mwc> Cale, I don't think that'd be too bad if you got a stack-trace-like display... this line in this file failed.
21:14:27 <mwc> and then recurses upwards to main.
21:14:31 <lispy> Cale: certainly that's no good, but really error is the fundamental thing which needs fixed right?
21:14:38 <Cale> Right, the problem is that in a lazy language, stack traces are quite bizarre
21:14:56 <mwc> Well, it seems to me that if you sorted it by the expression, it wouldn't be too bad
21:15:00 <Cale> What you really want is something like cost-centres give you.
21:15:15 <lispy> Cale: right
21:15:55 <Cale> So at the very least, things could give better error messages when profiling is turned on :)
21:16:03 <mwc> error: head barfed on empty list\nin function "head" GHCPreludeFile.hs:4313\nin function "headSomething" MyModule.hs:54
21:16:53 <Cale> You can do that, but it hurts performance of evaluation.
21:17:13 <dibblego> data NonEmptyList = NonEmptyList a [a]
21:17:21 <dibblego> data NonEmptyList a = NonEmptyList a [a] -- even
21:17:30 <sjanssen> why can't we use the profiling information to give something like stack traces?
21:17:47 <Cale> Isn't there something like -xc for that?
21:18:29 <sjanssen> Cale: I saw something about that in a recent list post, but I couldn't find any docs on it
21:20:11 <Cale> cale@zaphod:~$ ghc -prof -auto-all -o sample sample.hs
21:20:15 <Cale> cale@zaphod:~$ ./sample +RTS -xc
21:20:15 <Cale> <Main.badLast,Main.main,Main.CAF>sample: oops!
21:20:26 <Cale> badLast :: [a] -> a
21:20:26 <Cale> badLast [] = error "oops!"
21:20:26 <Cale> badLast (x:xs) = badLast xs
21:20:26 <Cale> main = print $ badLast [1,2,3,4,5]
21:21:08 <sjanssen> oh, so why is everybody so worried about all this?  just use -xc
21:21:19 <Cale> yeah, I don't think most people know about it
21:21:59 * dcoutts pushes another big pile of patches to the gtk2hs code gen
21:22:37 <dons> sjanssen: can you just check the Debugging page on the wiki to ensure it shows exactly how to use -xc ?
21:23:59 <Cale> I wonder why -xc was chosen as the name of that flag. eXCeption?
21:25:04 <Cale> also, is there any reason for it not to default to being on when compiling with -prof?
21:26:09 <dons> still, I think there's something for getting located exceptions. thta's nicer than having to inspect .prof files
21:29:57 <Cale> well, I didn't have to inspect a .prof here
21:30:07 <Cale> It just prints the error message with more detail.
21:30:15 <Cale> It would be nice to get a line number too
21:30:25 <Cale> I'm sure that much is doable.
21:30:51 <Cale> Probably could be formatted a bit more nicely too, but it looks like all the machinery is there.
21:34:22 <Pegazus> are there tuples with zero or one elements? i mean () and (1)
21:34:36 <sjanssen> > () -- zero
21:34:37 <lambdabot>  ()
21:34:45 <sjanssen> Pegazus: but there is no 1-tuple
21:35:05 <Pegazus> k thanks...
21:35:20 <sjanssen> or, you could argue that *everything* is a 1-tuple . . . but that's a little silly
21:35:49 <Pegazus> :type says otherwise :)
21:36:57 <sjanssen> > (1, 2) :: (Int, Int)
21:36:59 <lambdabot>  (1,2)
21:37:13 <sjanssen> > (1) :: (Int)
21:37:15 <lambdabot>  1
21:38:24 <Pegazus> hugs says different O_o
21:39:12 <Pegazus> sorry, i got it :)
21:39:58 <dons> ok, cool, my preprocessor rewrites fromJust to:
21:39:59 <dons> f = let
21:39:59 <dons>       m = M.fromList [(1, "1"), (2, "2"), (3, "3")]
21:39:59 <dons>       s = M.lookup 4 m
21:40:00 <dons>     in (check assert) . (fromJust s)
21:40:18 <dons> now just have to get it to typecheck and have user-defined functions to rewrite
21:43:56 <sjanssen> ah, so the problem with -xc is that it doesn't seem to work across modules
21:46:57 <sjanssen> for example, "main = putStrLn $ fromJust Nothing" yields "<Data.Maybe.CAF>foo: Maybe.fromJust: Nothing" with no mention of main
21:47:16 <Cale> ah, hmm
21:47:18 <dons> argh
21:47:43 <sjanssen> so it's effectively useless
21:48:06 <Cale> that's odd
21:48:13 <Cale> I wonder why it doesn't
21:48:22 <sjanssen> unless your bad code is in the same module as the error
21:49:35 <dons> ok, here we go:
21:49:36 <dons> $ ghc --make -Onot A.hs -no-recomp 2> /dev/null
21:49:37 <dons> $ ./A
21:49:37 <dons> A: Maybe.fromJust: Nothing
21:49:37 <dons> $ ghc --make -Onot A.hs -no-recomp -pgmF loch -F 2> /dev/null
21:49:39 <dons> $ ./A
21:49:42 <dons> A: /tmp/ghc18063_0/ghc18063_0.hspp:14:14-19: Maybe.fromJust: Nothing
21:49:44 <dons> :D
21:49:50 <dons> so just add the preprocessor flag to the command line
21:50:01 <Cale> cool
21:50:05 <dons> we lose the file name though. hmm.
21:50:10 <dons> (preprocessing)
21:50:21 <dons> line number should be right though
21:50:36 <dons> ah, some pragmas might help there
21:54:29 <mwc> > (1)
21:54:31 <lambdabot>  1
21:55:06 <mwc> I got the impression from something up there that it was treating 1-tuples specially. That blew a mind fuse
21:55:21 <MP0> > [1..]
21:55:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:56:01 <MP0> > [0.5..]
21:56:03 <lambdabot>  [0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5,...
21:56:04 <desrt> 1-tuples don't really exist....
21:56:47 <MP0> > (1,2)
21:56:48 <lambdabot>  (1,2)
21:56:54 <MP0> > (1)
21:56:55 <lambdabot>  1
21:57:01 <MP0> I suppose so
21:57:05 <Pegazus> <desrt> 1-tuples don't really exist.... --> they could...
21:57:16 <desrt> Pegazus; but they don't in haskell
21:57:20 <Pegazus> i know :)
21:57:29 <desrt> and certainly not in ghc :)
21:57:33 <xnito> hello does anyone know how to store an Int in haskell?
21:57:53 <dons> > 1 :: Int
21:57:53 <desrt> xnito; like assign an integer value to a variable?
21:57:55 <lambdabot>  1
21:58:08 <MP0> 1 :: Float
21:58:12 <xnito> to store it at a memory location
21:58:12 <MP0> > 1 :: Float
21:58:14 <lambdabot>  1.0
21:58:15 <dons> > let x = 1 in 1
21:58:16 <desrt> xnito; no.
21:58:16 <lambdabot>  1
21:58:17 <Pete_I> store? you can store things in a functional language?
21:58:29 <MP0> you can store, you can't modify I assume.
21:58:29 <Pete_I> i thought it was just passing to other functions....
21:58:32 <desrt> Pete_I; unsafePerformIO + IORef :)
21:58:35 <xnito> yes
21:58:35 <xnito> its called IO i believe
21:58:48 <desrt> oh.  you want IORefs then
21:58:55 <xnito> yup
21:59:08 <Pete_I> hmm
21:59:22 <mwc> you want STRefs is you don't need all the IO machinery
21:59:34 <dons> xnito: please go and read http://haskell.org. you need to start with a tutorial or two
21:59:36 <lambdabot> Title: Haskell - HaskellWiki
21:59:41 <mwc> ST you can safely put a functional wrapper around
21:59:50 <desrt> xnito; do you know haskell?
21:59:56 <dons> xnito: I remember all your questions about namespaces a few days ago.
22:00:04 <desrt> ah.
22:00:07 <xnito> im possibly looking for some constructor
22:00:19 <mwc> @hoogle STRef
22:00:19 <Pete_I> xnito, you probably won't find one.
22:00:20 <lambdabot> Data.STRef :: module
22:00:20 <lambdabot> Data.STRef.STRef :: data STRef s a
22:00:20 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
22:00:23 * desrt watches dons answer with more context :)
22:00:27 <mwc> there ya go
22:00:30 <dons> desrt: heh
22:00:42 <desrt> dons; well.. it's a difficult question :)
22:00:54 <desrt> dons; it either means "i don't know haskell" or "i know haskell and i need to do something evil" :)
22:01:02 <dons> right
22:01:09 <dons> or "i'm trolling", option 3.
22:01:10 <dons> ;)
22:01:14 <desrt> hey guys?!
22:01:18 <desrt> i need to store an int!
22:01:19 <desrt> plz help
22:01:29 <Pete_I> isn't that was = is for?
22:01:34 <Pete_I> x = 3
22:01:41 <Pete_I> yay, stored
22:01:46 <desrt> no.  not stored.
22:01:48 <desrt> x is not a place.
22:01:57 <Pete_I> or atleast defined as a function....
22:03:32 <sjanssen> @hoogle malloc
22:03:33 <lambdabot> Foreign.Marshal.Alloc.malloc :: Storable a => IO (Ptr a)
22:03:33 <lambdabot> Foreign.ForeignPtr.mallocForeignPtr :: Storable a => IO (ForeignPtr a)
22:03:33 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
22:03:37 <sjanssen> @hoogle poke
22:03:38 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
22:03:39 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
22:03:39 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
22:03:48 <sjanssen> there you go, desrt ;)
22:15:04 <dons> ok. so I pushed the 'loch' preprocessor into darcs
22:15:22 <dons> if people are interested, we can extend it to take a user supplied list of functions
22:43:22 <Cale> shapr: http://www.crypto.com/masterkey.html -- you might be interested in this paper by the same guy as the one on safes
22:43:24 <Elifant> is there overview of PrettyPrint library available anywhere? google just gives me ton of links to API reference...
22:43:25 <lambdabot> Title: Master-Keyed Lock Vulnerability
22:43:45 <dons> there's a paper, let me see...
22:44:19 <dons> http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps
22:44:23 <lambdabot> http://tinyurl.com/y8gr4o
22:44:25 <dons> http://www.haskell.org/haskellwiki/Research_papers/Program_development#Pretty_printing
22:44:27 <lambdabot> Title: Research papers/Program development - HaskellWiki, http://tinyurl.com/yyhcqf
22:44:36 <dons> (there should be examples around if you google for 'import Text.Pretty.*'
22:44:57 <Elifant> thanks!
22:45:44 <Cale> Wadler's "A prettier printer" describes a better one, which unfortunately, I don't think is in the standard libraries.
22:45:57 <dons> oh, its quite recent. hmm.
22:46:13 <Cale> (It builds on Hughes' original idea)
22:46:17 <dons> its interesting how recent some of those papers are.
22:46:30 <dons> maybe there's hope for 'A prettier ncurses printer' yet...
22:49:39 <glguy> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo.
22:49:52 <glguy> http://en.wikipedia.org/wiki/Buffalo_buffalo
22:50:57 <Korollary> lol
22:52:07 <glguy> Or: Bison from Buffalo, NY, who are intimindated by other bison in their community also happen to intimidate other bison in their community
22:52:19 <Korollary> I got it. Genius.
22:53:52 <Korollary> How nice of them to add a picture of Buffalo, NY in that article.
22:54:06 <Korollary> They forgot the Buffalo Sabers, though.
22:54:25 <Korollary> kicking ass and taking names this year in NHL
22:55:40 <glguy> Who polices the police? - The police police. So, who polices the police police? Police police police police police police.
22:56:02 <Botje> So who polices the police police police ?
22:56:19 <Cale> Haha, "If imitation is the sincerest form of flattery, perhaps being accused of copyright infringement is the second sincerest."
22:56:21 <glguy> the police police police police, of course
22:56:38 <glguy> lol
22:56:46 <Cale> (from http://www.crypto.com/papers/flattery.html)
22:56:47 <lambdabot> Title: Matt Blaze: The second sincerest form of flattery
22:57:00 <robreim> I just compiled GHC and attempted to install it in a non-standard location. Now I keep getting "Failed to load interface for `System.IO'". Any idea what I've done wrong with my install?
22:57:06 <aaae> www.mldesigners.com just released a public gmail hack
22:57:10 <aaae> who should i contact?
22:57:19 <Botje> gmail
22:57:22 <Cale> gmail
22:57:38 <aaae> just email gmail@gmail.com ?
22:58:21 <Cale> https://mail.google.com/support/bin/request.py
22:58:24 <lambdabot> http://tinyurl.com/yl4pmv
22:58:58 <Cale> https://services.google.com/inquiry/googlemail/bugs/?referrer=bugflow
22:59:00 <lambdabot> http://tinyurl.com/y4pwdt
22:59:01 <Cale> maybe that
23:00:05 <dons> why would you join this channel to discuss that? :/
23:00:36 <Korollary> we're the 'discriminating' hackers, eh.
23:00:51 <dons> ah 'hackers' maybe ..
23:01:42 <glguy> discriminating == Lawful Good?
23:01:46 <robreim> discriminating h4X0rz
23:02:22 <robreim> glguy: nah, I think discriminating just requires a relatively high wisdom roll :P
23:02:46 <sjanssen> "I purchased a saxophone a few days back and I'm having trouble finding research papers that cover jazz improv." -- dead Jazz musicians are rolling in their graves, shapr ;)
23:03:24 <kfish> ahh, the elusive improv monad
23:04:02 <sjanssen> do {dot; }
23:04:29 <glguy> Jesus saves..
23:04:32 <glguy> and takes half damage!
23:04:34 <robreim> shapr: What would you suggest I tell a pythonist to convince them to try haskell?
23:04:52 <robreim> actually, anyone can answer that, I just happened to notice shapr is an ex-pythonist.
23:05:12 <sieni> robreim: don't suggest anything. he chose python on purpose, so he should suffer the consequences
23:05:15 <dons> hmm. its a nice, fun language to hack in, not too far from python?
23:05:25 <dons> (ok, so we can lie just a little ;)
23:05:48 <glguy> If someone used C#, you could tell them that rather than waiting around for C# 4.0, they could just start using Haskell now
23:06:00 <sjanssen> do replicateM_ 4 I; replicateM_ 2 IV; replicateM_ 2 I; V; IV; replicateM_ 2 I
23:06:15 <robreim> I think he's one of those "tired programmers" who can't be bothered learning a new language.
23:06:27 <robreim> and haskell takes a fair whack of learning...
23:06:31 <glguy> "tired programmers" quickly become "not programmers"
23:06:36 <dons> ah well. tell him he'll be left behind when we're all running 80 core boxes next year... ;)
23:06:52 <robreim> :)
23:06:57 <glguy> dons: #haskell programmers are getting free computer upgrades/
23:06:58 <glguy> ?
23:07:15 <dons> yeah, when the new lambdabot server arrives in a couple of months
23:07:26 <dons> 16 cores of goodness for you to write your fragments on
23:07:27 <dons> ;)
23:07:50 <glguy> will parallel strategies be available for evalutaion in IRC?
23:07:57 <dons> let's hope so
23:08:02 <dons> i'm thinking it would be fun to enable `par`
23:08:10 <sjanssen> no reason not to
23:08:15 <dons> and actually run it with -N16
23:08:18 <dons> right
23:08:31 <glguy> the fib generators will get even more exciting
23:09:00 <shapr> sjanssen: :-P
23:11:19 <shapr> robreim: It's easiest to convert J2EE programmers to Haskell.
23:12:00 <Korollary> mother &&&&&&&& windows media player. Why do I have to restart after an install?
23:12:40 <robreim> Yeah, that's easy. I'd just like all my colleagues to use the same language so we can actually work on projects together :/
23:12:42 <dons> i guess the media player modified the kernel in some evil way/
23:13:00 <glguy> http://programming.reddit.com/info/qx36/comments
23:13:04 <lambdabot> Title: The Haskell School of Expression: Learning Functional Programming through Multim ..., http://tinyurl.com/yn6uue
23:13:17 <dons> urgh, why post that old book?
23:13:17 <dons>  hmm
23:13:31 <glguy> I don't know how to argue with TrueTom, however
23:13:46 <shapr> glguy: Ask him exactly what's bad about it.
23:14:09 <dons> yeah, just answer "Why?"
23:14:16 <glguy> O RLY?
23:14:26 <dons> lololz
23:14:27 <shapr> Purely judgemental or emotional statements don't help others learn.
23:14:30 <dons> or something like that
23:14:49 <robreim> I just compiled GHC and attempted to install it in a non-standard location. Now I keep getting "Failed to load interface for `System.IO'". Any idea what I've done wrong with my install?
23:14:51 <dons> i wish people wouldn't post really old, easy to find material
23:14:52 <shapr> If the guy actually put any effort into reading the book, he should have more to say than that, right?
23:14:54 <glguy> "Well... I DISAGREE"
23:15:03 <dons> someone's probably posted "K&R" at some point
23:17:36 <Korollary> robreim: It should have worked. Where did you install?
23:17:48 <robreim> Korollary: ~/testing/
23:18:21 <Korollary> robreim: Check the following files under that path: bin/ghc, lib/ghc-$VERSION/package.conf. They have hardcoded paths in them.
23:18:35 <glguy> Has anyone here played with "Factor" and have anything positive ot say about it?
23:18:40 <shapr> robreim: Points for a Python programmer: 1. [].sort() doesn't return the sorted list value. If you think it should, you'll probably like Haskell. 2. Python's list comprehensions came directly from Haskell. 3. Haskell has significant whitespace too.
23:18:56 <shapr> glguy: Concatenative languages are interesting, though I got started with Joy.
23:19:37 <Korollary> robreim: maybe /home/robreim should have been used instead of "~". I am not sure about that.
23:19:45 <shapr> robreim: 4. If you like lambda, reduce, and map but wish they weren't so much trouble to use, you'll probably like Haskell.
23:19:54 <robreim> Korollary: ah. I found bin/ghc's hard-coded path, but not packages.conf. Any idea why it sets it to /usr/local/ instead of the prefix I configured it with?
23:20:05 <shapr> robreim: If you blow the stack limit writing recursive code, it's very likely you'll like Haskell.
23:20:20 <Korollary> robreim: It should absolutely not have done that.
23:20:23 <dons> shapr: hehe. nice python list
23:20:27 * robreim notes down shapr's suggestions
23:20:40 <dons> i'd add sometihng about transparently smp threads
23:20:49 <shapr> robreim: If you think functions should have all their inputs explicitly passed to them, including outside state, you'll like Haskell.
23:21:15 <dons> if you think functions should return the same result, everytime ...
23:21:16 <shapr> If metaclasses bore you, learn Haskell now!
23:21:20 <shapr> dons: good point.
23:21:23 <Korollary> Those are bad points
23:21:30 <dons> ah well :)
23:21:46 <robreim> Korollary: ok, file a bug report then I suppose?
23:21:47 <dons> if you like fast code ...
23:21:51 <robreim> or could it be something I did?
23:21:52 <ValarQ> morning folks
23:21:58 <shapr> That's true, Haskell is faster than Python for the most part.
23:22:10 <Korollary> robreim: I just rebuilt it myself. I would try it again before submitting a bug.
23:22:28 <robreim> Korollary: ok.
23:23:08 <shapr> Oh, and Haskell's FFI is simpler than SWIG.
23:23:40 <glguy> When I think of things I miss when coding in not-Haskell, speed isn't one of them
23:23:49 <robreim> some nice "oop sucks, use fp" material might help :)
23:23:51 <glguy> I miss things like curried functions
23:23:54 <shapr> Oh, if you think the number of keywords should be as close to zero as possible, you'll like Haskell.
23:24:14 <glguy> I miss thingslike infered types
23:24:16 <robreim> partial application rocks
23:24:27 <dons> if you hate finding bugs after you've sold the code ...
23:25:26 <Korollary> A fairer comparison would be between Python & a lisp dialect.
23:26:40 <robreim> yikes, got to run - I'll read up on any more suggestions when I get back.
23:26:45 <Cale> shapr: I don't mind some additional syntax for added clarity, but yeah :)
23:26:47 <shapr> If you wish you could freeze an instance so you could trust that its values wouldn't change, you'll like closures.
23:27:35 <shapr> Hm, maybe I should write up this list, tomorrow when I've had sleep.
23:27:46 <Korollary> closures can have mutables in them
23:28:17 <shapr> Ok, you'll like partial application in haskell?
23:28:44 <Korollary> Yeah. But it matters more for a functional language anyway.
23:33:53 <user317> does anyone know parsec well?  i am trying to figure out how to write a parser that will recognize email addresses, just a learning exersize
23:36:27 <shapr> dons: wow, 46 - http://www.tiobe.com/index.htm?tiobe_index
23:36:29 <lambdabot> Title: TIOBE Software - The Coding Standards Company
23:38:21 <encryptio> noob question: i have an [IO String] that i want to concantenate, end to end, into a single IO String. how do i do that?
23:38:27 * shapr falls over asleep
23:38:37 <Cale> user317: okay
23:38:43 <Cale> encryptio: sequence
23:39:07 <Cale> user317: can you ask a more specific question?
23:39:51 <Cale> encryptio: er, actually, that'll give you an IO [String], but then you could do something like apply liftM concat
23:41:07 <Cale> shapr: I have a really hard time believing that the Haskell community is less active than the Icon community.
23:41:37 <encryptio> Cale: i'm not following.
23:41:46 <Cale> @type sequence
23:41:48 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
23:41:54 <Cale> @type liftM concat . sequence
23:41:56 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
23:42:00 <Cale> er
23:42:08 <Korollary> numbers that low are dominated by noise.
23:42:10 <Cale> yes
23:42:18 <encryptio> Cale: there seems to be no liftM in hugs...
23:42:31 <Cale> encryptio: it's in the Control.Monad module
23:42:35 <Cale> you could also use fmap
23:42:44 <Korollary> use the bot
23:42:47 <Korollary> @index liftM
23:42:48 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
23:42:55 <Cale> @type liftM concat . sequence :: [IO String] -> IO String
23:42:57 <lambdabot> [IO String] -> IO String :: [IO String] -> IO String
23:43:11 <Cale> I really wish it would break at the last ::
23:43:18 <Cale> hehe
23:43:39 <Cale> @type fmap concat . sequence :: [IO String] -> IO String
23:43:41 <lambdabot> [IO String] -> IO String :: [IO String] -> IO String
23:43:44 <Cale> that's the same thing
23:44:23 <Cale> fmap and liftM are the same up to level of polymorphism -- fmap is more general, and works on all functors, liftM only for monads. Don't ask me why we have both.
23:45:50 <user317> whats the prefered pastebin for haskell?
23:46:02 <encryptio> hmm. maybe i don't have an [IO String]. (pain in the brain, pain in the brain...)
23:46:31 <Cale> lisppaste2: url
23:46:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:46:40 <Cale> encryptio: hmm :)
23:47:02 <Cale> encryptio: you can probably ask hugs/GHCi what you have.
23:47:26 <lisppaste2> user317 pasted "parse email" at http://paste.lisp.org/display/29942
23:47:26 <Cale> encryptio: I'm assuming you generally know how IO works in Haskell?
23:47:39 <encryptio> a very very very general idea.
23:48:08 <encryptio> playing with random numbers - random password generator.
23:48:12 <user317> Cale, http://paste.lisp.org/display/29942 , i get an error Couldn't match `GenParser Char ()' against `(->) String'
23:49:02 <encryptio> [ mkPassChar | x<-enumFromTo 1 12 ] :: (Num a, Enum a) => [IO String]
23:49:20 <encryptio> says hugs
23:49:35 <Cale> user317: string is a function which builds parsers
23:49:43 <Cale> (that match exactly one string)
23:50:23 <Cale> encryptio: try  replicateM 12 mkPassChar
23:50:53 <Cale> user317: you probably want something like...
23:51:16 <user317> Cale, is there a way to pass a regular expression into the parser?
23:51:42 <Cale> name <- many1 (alphaNum <|> char '_')
23:51:53 <user317> oh i see
23:51:59 <Cale> which will match one or more alphanumeric characters or underscores
23:52:59 <Cale> If you want to include more potential punctuation (I'm not sure off-hand what's allowed, but I know hyphens are), you can use something like  oneOf "-_"  in place of  char '_'
23:53:18 <Cale> which is a little simpler than using lots of <|>'s
23:53:44 <user317> Cale, ok, i think this makes more sense now, thanks
23:54:07 <Cale> you might even do something like make a definition
23:54:35 <Cale> emailLetter = alphaNum <|> oneOf "_-."
23:54:39 <Cale> and then use that
23:54:46 <Cale> name <- many1 emailLetter
23:55:21 <user317> i see
23:55:24 <desrt> is there any way to do inline <-?
23:55:51 <xerox> hehe
23:55:54 <Cale> inline <- ?
23:55:59 <xerox> top-level?
23:56:01 <desrt> like instead of writing do guess <- [True, False] if guess then ...
23:56:15 <desrt> write something more like if (magic([True, False])) then...
23:56:28 <Cale> oh, like that - there are functions 'when' and 'unless'
23:56:36 <Cale> but otherwise no
23:56:38 <desrt> ?type when
23:56:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:56:49 <desrt> oh.  that's boring.
23:56:52 <Cale> You could even write ifM
23:57:37 <Cale> @type let ifM b t e = do { b' <- b; if b' then t else e } in ifM
23:57:38 <desrt> that's just (\c a.if c then a else return ())
23:57:39 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
23:58:00 <desrt> that's a bit better
23:58:02 <Cale> that ought to be in the library, perhaps
23:58:20 <Cale> People have suggested a monadic case
23:58:30 <Cale> but so far, nobody's implemented it
23:58:44 <desrt> i'm writing some small convenience functions to have non-deterministic turing machines in haskell
23:58:49 <encryptio> got it working now... still not completely sure why.
23:59:15 <desrt> i've heard that you can have polynomial time solutions to integer factorisation on a non-deterministic machine
23:59:21 <desrt> and i'm looking to collect some RSA prizemoney
23:59:41 <Cale> hehe
23:59:43 <xerox> sorry?
23:59:58 <Cale> Of course, simulating a non-deterministic machine on a deterministic computer takes exponential time.
