00:01:18 <satan> ok thanks Korollary
00:10:57 <Itkovian> Korollary: I found that his writing style degraded in the last ASoIaF book
00:16:17 <satan> whats the biggest difference between creating a newtype and using the data keyword?
00:16:40 <xnito> i knoq this one
00:17:15 <xnito> newtype has no optional iinheritance
00:17:42 <satan> ok
00:17:58 <_matthew-> isn't there also something about ghc basically compiles out newtype so it's really really fast, but it doesn't with data
00:18:25 <_matthew-> so you should ues newtype where possible. I think. I may have got that the wrong way round though...
00:18:46 <satan> hmm
00:19:24 <xnito> with data you specify instances and inheritance
00:19:58 <xnito> with newtype is similar to defining a synonym for Int for example but you have to add a constructor
00:20:37 <satan> so a newtype is like an alias for the class its being derived from?
00:20:44 <therp> is there some DWIM indention shortcut for haskell-mode in emacs?
00:20:55 <satan> does it make a difference if i derive Show, like so: newtype Check = Check Bool deriving Show
00:21:08 <satan> how would that be different if it was:  data Check = Check Bool deriving Show
00:21:35 <xnito> not exactly that would describe the keyword "type"
00:21:53 <xnito> newtype adds its own type checkng
00:22:02 <xnito> via the constructor
00:22:14 <xnito> ok
00:23:48 <xnito> in that case you could overide functions such as not
00:23:51 <dons> http://www.haskell.org/haskellwiki/Newtype
00:23:53 <lambdabot> Title: Newtype - HaskellWiki
00:23:55 <astrolabe> I thought you could make newtypes instances of classes (if that's what you meant)
00:24:00 <dons> "One frequent question is what is the difference between data and newtype?" ....
00:24:01 <xnito> actually
00:24:02 <xnito> no
00:24:25 <xnito> they are very similar in that instance
00:46:10 <emu> therp: TAB?
00:46:11 <xnito> does anyone know how to connect the consecutive integers in a sorted list?
00:47:10 <dons> um?
00:47:13 <dons> > [1..10]
00:47:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
00:47:15 <dons> ?
00:47:26 <emu> do you mean [[2,3,4],[7,8,9]]?
00:47:46 <therp> emu: that does only work for the current line, and it's not DWIM at all.. whenever I wrap something in an expression, I want the wrapped thing to be reindented correctly (as it was before) but moved down the indention hierarchy one step.. but I guess this wish is unfulfillable
00:47:52 <xnito> ie [11,6,5,4,3,1] => [[11],[6,5,4,3],[1]]
00:48:03 <xnito> seems easy but is tricky
00:48:12 <xnito> groupBy doesnt want to work
00:48:26 <dons> ah, interesting
00:48:44 <dons> so while they're consecutive, in either direction, group.
00:48:53 <dons> ?type groupBy
00:48:55 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
00:48:58 <xnito> yep
00:49:02 <dons> its a fold
00:49:11 <xnito> ok
00:49:14 <dons> you'll have to write it by hand though
00:49:17 <dons> a nice puzzle!
00:49:20 <xnito> ok
00:49:23 <xnito> thanks
00:49:27 <xnito> ill try a fold
00:52:38 <emu> therp: well
00:52:46 <emu> therp: i agree the indent-region doesn't work so great
00:53:14 <emu> you can select rectangles and paste/delete them
00:53:23 <emu> or you can cycle TAB for each line
00:54:15 <emu> if you are moving haskell code around, i suggest taking advantage of rectangular commands: C-x r C-h
00:54:58 <therp> interesting, will try thanks
00:56:05 <emu> im slowly working on fixing haskell-mode here and there
00:56:23 <vincenz> dons: you're going to hate me, I'm considering emacs
00:57:54 <dons> go for it. why would i care? :)
00:58:08 <xnito> are you a vimmer?
00:58:10 <dons> if you were 'considering php' it would be a different story... ;)
00:58:12 <dons> yes :)
00:58:16 <opqdonut> :D
00:58:31 <opqdonut> i've had no trouble with emacs's haskell-mode
00:58:44 <dons> yeah, its good, well supported, active emacs contrib community.
00:58:45 <satan> whoops got disconnected for far too long there
00:58:49 <dons> a good choice for haskell hacking.
00:59:14 <opqdonut> esp. the type signatures in the status line are great
01:01:04 <emu> opqdonut: except haskell-doc only works on a pre-set list of functions
01:02:28 <emu> i added a function to query ghci for the type, and i think i can integrate that with haskell-doc easily enough though
01:03:09 <opqdonut> nice
01:03:15 <dons> oh, have you seen my vim script for that?
01:03:20 <emu> yes
01:03:30 <emu> this is different: it interacts with ghci that's running as a subprocess
01:03:45 <dons> ah nice
01:04:22 <emu> i don't know how vim integration works, but emacs tends to have modes that run "toplevels" in comint style buffers
01:04:36 <dons> so you keep the code loaded in ghci/
01:04:36 <dons> yep
01:07:54 <emu> i sent 1 patch to the haskell-mode maintainer, to which he responded, but i don't know if he's actively maintaining it anymore
01:24:30 <dblhelix> boegel: i don't know llvm, but crafting a simulator for it, sounds like fun!
01:36:14 <Itkovian> dblhelix: boegel is holding a defense for a grant proposal
01:36:18 <Itkovian> brb
01:36:28 <dblhelix> Itkovian: ah, okay, tnx
01:37:58 <dancor> why doesn't import work in ghci
01:38:05 <dancor> > 4
01:38:07 <lambdabot>  4
01:38:11 <dancor> > import Ix
01:38:12 <lambdabot>  Parse error
01:38:56 <dblhelix> dancor: try :m + Ix
01:39:29 <dons> $ ghci
01:39:29 <dons> :m + Prelude> :m + Ix
01:39:29 <dons> Prelude Ix> :t range
01:39:29 <dons> range :: (Ix a) => (a, a) -> [a]
01:39:55 <dancor> ok
01:43:20 <dancor> is there a function like (join "a" ["b", "c", "d"]) = ("bacad") built-in
01:43:36 <dancor> and what is the best way to find something like that out
01:43:52 <EvilRanter> http://haskell.org/ghc/docs/latest/html/libraries/
01:43:55 <lambdabot> http://tinyurl.com/hxrk7
01:44:20 <EvilRanter> > (concat . interleave "a") ["foo", "bar", "baz"]
01:44:21 <lambdabot>  Not in scope: `interleave'
01:44:30 <dons> intercalate, in the head, otherwise: concat . intersperse
01:44:43 <EvilRanter> > (concat . intersperse "a") ["foo", "bar", "baz"]
01:44:44 <dons> > concat . intersperse "a" $ ["b", "c", "d"]
01:44:45 <lambdabot>  "fooabarabaz"
01:44:46 <lambdabot>  "bacad"
01:44:48 <EvilRanter> there be go
01:44:54 <dancor> cool
01:47:06 <xnito> >concat . intersperse "ay " $ ["w", "d", "m","s",""]
01:47:26 <xnito> > concat . intersperse "ay " $ ["w", "d", "m","s",""]
01:47:27 <lambdabot>  "way day may say "
01:50:07 <dblhelix> @seen SyntaxNinja
01:50:08 <lambdabot> I saw SyntaxNinja leaving #haskell and #darcs 4h 19m 27s ago, and .
01:53:41 <dons> The little known marketing effect of having haveing somthing mysteriously named, difficult and seemingly of awesome power: "This of course has nothing to do with what the term monad means in the Haskell language. The latter
01:53:46 <dons> usage has piqued my curiosity enough to get me to try to learn Haskell"
01:56:21 <pejo> Heh. Maybe the compiler should insult people in the error messages too? "There is no way you could learn this!".
01:57:33 <xnito> yay i did it :)
01:59:23 <xnito> http://rafb.net/paste/results/gFa86E81.html
02:01:50 <Cale> pejo: haha, "Unexpected kind unification failure: Good luck figuring this one out!"
02:04:11 <xnito> how important are arrows, i cant see the advantage yet
02:07:34 <Cale> xnito: they're important because certain EDSLs can be implemented much more efficiently in terms of the arrow primitives than the monad primitives -- basically, because the arrow primitives allow for more observation of code. (the monadic >>= takes a function on one side, which is essentially opaque)
02:08:11 <EvilRanter> monads're opaque? who knew? :P
02:08:19 <Syzygy-> What does EDSL stand for?
02:08:34 <Cale> Embedded domain specific language
02:08:46 <Syzygy-> Ah
02:09:50 <xerox> Good morning.
02:10:11 <Maddas> Morning (:
02:10:21 <Syzygy-> moin
02:32:37 <xerox> astrolabe: http://math.ucr.edu/home/baez/week240.html
02:32:39 <lambdabot> Title: week240
03:33:09 <dons> ?users
03:33:09 <lambdabot> Maximum users seen in #haskell: 275, currently: 246 (89.5%), active: 21 (8.5%)
03:36:22 <opqdonut> xerox: interesting link, thanks
03:41:30 <xerox> opqdonut: really :)
03:48:18 <Igloo> dons: ByteString's coerce from Char# to whatever writeByte wants looks suspicious to me
03:49:58 <Philippa_> 'lo edwinb - did you show to FitA?
03:50:29 <edwinb> hi
03:50:32 <edwinb> yes, I did
03:50:38 * EvilRanter was at the Fun. had to leave halfway thru the second talk, tho :(
03:50:39 <edwinb> then I hung about in Nottingham for a bit
03:50:43 <dons> Igloo: it does doesn't it.
03:50:46 <dons> i should check if its even used
03:51:19 <dons>  go p (C# c:cs) = writeByte p (unsafeCoerce# c) >> go (p `plusAddr#` 1#) cs
03:51:22 <dons> bit strange
03:51:26 <dons> should cast down
03:51:53 <Philippa_> ...D'oh. If I'd known you were doing that I could've given you a yell. Dunno if you heard what happened to me en route?
03:52:01 <edwinb> no...
03:52:27 <Philippa_> I got the 1034 out of nottingham, it broke down just before Long Eaton. Was stuck sitting there for 5.5 hours...
03:53:11 <ms_> gosh, what a lovely part of Nottingham to be stuck in for 5.5 hours
03:53:13 <edwinb> oh lovely. That beats my record of 4 hours outside Dunbar...
03:53:17 <dons> Igloo: yeah, its casting a Char# to an Int#
03:53:21 <dons> safe, but we have ord# for that
03:53:22 <Philippa_> ms_: just outside. That is, stuck in the train.
03:53:46 <ms_> Philippa_: yes, I assumed so. and was being sarcastic
03:53:56 * ms_ used to live in Notts ;)
03:54:03 <Philippa_> yeah, just wasn't sure if you were being sarky about the train or Long Eaton :-)
03:54:31 <Philippa_> anyway, didn't figure it was worth another 6 hours of travel and getting home at 1am to go to the pub
03:54:44 <Igloo> dons: Only safe on 32-bit arches, no?
03:55:22 <dons> Igloo: seems to work fine (it'll just truncate and take the bottom 8 bits)
03:55:33 <dons> but i've changed it to: int2Word# (ord# c)
03:55:41 <dons> i suspect i was just being lazy there :)
03:57:31 * Igloo would need to be convinced a 64-bit arch of the wrong endianess wouldn't go wrong, but it's easier just to fix it  :-)
03:57:38 <vincenz> cll i the breeding ground of trolls
03:57:45 <vincenz> @localtime dons
03:57:47 <lambdabot> Local time for dons is Mon Nov 20 22:55:21 2006
03:58:31 <dons> Igloo: i'd need to see ghc on a 64-bit arch of the wrong endianess first ;)
04:00:08 * beelsebob licks Philippa_ 
04:00:14 <Igloo> I think alpha is one
04:00:29 * psnl is sure he has had ghc on his alpha
04:00:36 <Philippa_> 'lo beelsebob
04:03:48 <dblhelix> @pl (.) . (:)
04:03:48 <lambdabot> (.) . (:)
04:03:53 <dblhelix> eh, duh
04:05:12 <earthy> lunch, stefan? :P
04:05:37 <dblhelix> earthy: seems about time ;)
04:06:30 <Blejdfist> hi, has anybody used wxhaskell and know how to paint on a Image using the DC-functions? I know that in wxWidgets you use wxMemoryDC, but i cannot find how to construct one in wxHaskell
04:09:26 <ArtemGr> did you checked the samples?
04:09:56 <ArtemGr> like "samples/contrib/PaintDirect.hs"?
04:10:58 <vincenz> emu: ping
04:11:07 <Blejdfist> ArtemGr: i'll check it out
04:11:55 <xerox> dblhelix? (:
04:13:28 <ArtemGr> Blejdfist: or "samples/wx/Paint.hs", or others. I don't know if it is the direct drawing you want, but there is a lot of drawing in the samples.
04:16:06 <Blejdfist> ArtemGr: they don't seem to do what i want.. i want to draw on an WX.Image
04:23:11 <ArtemGr> Blejdfist: What is "WX.Image"? I see only one "Image" in documentation, and that is "Graphics.UI.WXCore.WxcClassTypes.Image", and that is what is returned by "im <- imageCreateSized rgbSize" in the PaintDirect.hs sample.
04:23:59 <Blejdfist> yeah that's the one.. i want to draw on that one with functions like line :: DC a -> Point -> Point -> [Prop (DC a)] -> IO ()
04:24:12 <Blejdfist> without having to implement the line function myself :)
04:24:53 <Blejdfist> in wxWidgets it's a piece of cake.. just create a wxMemoryDC dc(image); and use that one.. MemoryDC seems to exist in wxHaskell, but how do i create one?
04:25:55 <Blejdfist> what i really want to do is to draw on a panel in the on paint-function without having to redraw everything, so i was thinking about using an Image to draw one and then blit the image to the panel
04:29:01 <Blejdfist> hmm.. dcBufferWithRef might work
04:30:58 <Itkovian> boegel: wanna discuss the LLVM issue?
04:31:13 <boegel> Itkovian: not now, PIM2 coming up
04:31:18 <boegel> Itkovian: later :-)
04:31:20 <Itkovian> right
04:31:24 <Itkovian> I've escaped that :-)
04:31:30 <Itkovian> give Bertrand hell
04:39:01 <vincenz> woo
04:39:06 <vincenz> I found an even better troll
04:39:16 <dons> Igloo: for you: http://www.haskell.org/pipermail/cvs-all/2006-November/051517.html
04:39:18 <lambdabot> Title: patch applied (packages/base): One less unsafeCoerce# in the tree, http://tinyurl.com/sqa62
04:39:41 <Igloo> dons: Christmas has come early for me  :-)
04:39:48 <dons> :D
04:40:00 <Igloo> When do you celebrate it over there?
04:40:14 <dons> during the christmas period, usually
04:40:27 <dons> often on Christmas day itself
04:40:59 <yaxu> i think i'm going to spend christmas programming
04:41:09 <vincenz> Holy crapperoli
04:41:19 <Igloo> Ah, same day as us according to WP
04:41:22 <vincenz> cll is really the foundational ground for literary trolls
04:42:16 <dons> vincenz: you reading troll posts?
04:42:19 <dons> that's bad for your health
04:42:26 <dons> didn't your doctor advise against it?
04:42:30 <yaxu> festive programming, with port rather than beer
04:42:37 <dons> :)
04:42:51 <vincenz> it's like reading comics
04:43:05 <vincenz> *KAPOW* *ZING*
04:44:45 <yaxu> *ONOMATOPOEIA*
04:46:51 <vincenz> *META-ONOMATOPOEIA*
04:46:53 <greentea> vincenz: Care to share some more examples? :-)
04:47:07 <vincenz> of sounds?
04:47:21 <greentea> Heh, no, of cll trolling.
04:47:25 <vincenz> oh
04:47:27 <vincenz> Erig Naggum
04:47:33 <greentea> Ah. :-)
04:47:36 <vincenz> s/Erig/Erik
04:48:02 <vincenz> greentea: A known contender?
04:48:51 <Itkovian> the wiki says: (***) combines two arrows into a new arrow by running the two arrows on a pair of values (one arrow on the first pair and one arrow on the second pair).
04:49:09 <Itkovian> Isn't that supposed to be: one arrow on the first of the pair and one on the second of the pair?
04:49:11 <greentea> vincenz: No, i just recognise the name.
04:49:22 <Itkovian> at http://www.haskell.org/haskellwiki/Arrow_tutorial
04:49:25 <lambdabot> Title: Arrow tutorial - HaskellWiki, http://tinyurl.com/yjhzgy
04:49:27 <greentea> i'm pretty sure i've read various stuff of his.
04:49:52 <vincenz> Itkovian: yes
04:49:59 <vincenz> @type (***)
04:50:01 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:51:38 <greentea> vincenz: Oh yes, this is what i'm thinking of: http://www.underlevel.net/jordan/erik-perl.txt
04:51:40 <lambdabot> http://tinyurl.com/qty37
04:52:01 <vincenz> yaxu: thanks for teaching me a new word :)
04:52:05 <Itkovian> All right, I'm going to add my first contribution to the wiki then
04:52:47 <yaxu> vincenz: i've only just learned how to spell it myself :)
04:53:23 <vincenz> greentea: all his posts tend to become really strong like that, and he's great at destructive criticism
04:53:24 <yaxu> i'm starting work on an onomatopoeia related haskell project
04:53:32 <vincenz> what might that be?
04:54:12 <yaxu> perhaps mapping the morphology of a word to synthesis parameters
04:54:25 <Syzygy-> Onomatopoeia?
04:54:34 <yaxu> ie turning words like "krink" into some related noise
04:54:36 <Syzygy-> It isn't thaaaat hard to spell. :)
04:54:42 <Syzygy-> yaxu: Oooooh, neat!
04:54:42 <yaxu> like speech synthesis but not speech
04:55:30 <yaxu> i wrote a bit about it here - http://doc.gold.ac.uk/~ma503am/alex/onomatopoeia
04:55:32 <Syzygy-> Wonder what would happen if you fed the final product tinyurl-tags. :P
04:55:34 <lambdabot> Title: Onomatopoeic synthesiser | Alex McLean, http://tinyurl.com/yn4363
04:55:43 <yaxu> heh
04:56:38 <yaxu> another approach might be to use hidden markov models to segment audio samples somehow
04:57:25 <greentea> vincenz: Ah, okay.
04:57:27 <yaxu> and then somehow map those segments to strings of characters
05:14:14 <fabiim> guys I'm trying do perform a function only on strings wich  the first element is either 'Z' , 'U', 'D' ,'T','Q','C','C','S','S','O' , any easy way ? i guess i'll have to perform patter matching on all of them
05:14:21 <fabiim> can i use case n of
05:14:30 <fabiim> 'Z','T' -> foo
05:14:31 <fabiim> ?
05:14:58 <LoganCapaldo> @hoggle any
05:14:59 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
05:15:00 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: CharParser st Char
05:15:00 <lambdabot> Text.ParserCombinators.Parsec.Combinator.anyToken :: Show tok => GenParser tok st tok
05:15:23 <LoganCapaldo> @hoogle elem
05:15:24 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
05:15:24 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
05:15:24 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
05:16:07 <LoganCapaldo> case n of x:xs | x `elem` "ZUDTQCCSSO" -> do stuff
05:16:40 <Philippa_> you can cut the second C and S, it'll just slow things down
05:16:52 <LoganCapaldo> oh yeah
05:17:04 <Philippa_> and yeah, the guard's a good way to approach it
05:17:13 <fabiim> good! like elem z "ZUDTQCCSSO"
05:17:23 <fabiim> ok thanks
05:17:24 <fabiim> =)
05:24:23 <vincenz> > '_' `elem` " Philippa_ "
05:24:24 <lambdabot>  True
05:25:32 <Philippa_> yeah, I cba to write a script to switch when the ghost drops :-)
05:28:32 <xerox> Philippa_: you can actually force the ghost drop
05:29:56 <vincenz> Anyways, my hypothesis is that haskell does not suffer as much from trolling because the language is so complex that we don't brow-beat people into the ground for asking questions
05:30:23 <Philippa_> xerox: yeah, I still cba to write the script though
05:31:22 <kzm> @hoogle Data.PackedString  -- dcoutts, you in?
05:31:23 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- dcoutts'
05:31:26 <kzm> :-)
05:31:36 <dcoutts> heh
05:31:49 <dcoutts> kzm, what do you mean?
05:32:30 <kzm> Recent post to the ghc list.  Data.PackedString?  I thought that was old and deprecated?
05:32:48 <kzm> "when [D.PS] becomes available" ?
05:32:48 <Igloo> The old one is deprecated, the new one isn't written yet
05:33:14 <kzm> Are there any particular plans?
05:33:29 <kzm> btw - what parts of base depends on D.BS?
05:33:38 <Igloo> None, I believe
05:34:02 <arjanb> what would be the difference between the new PackedString and ByteString?
05:34:09 <dcoutts> arjanb, Unicode
05:34:23 <arjanb> ah ok
05:34:27 <dcoutts> kzm, Igloo, I've put in a proposal for an Msc project here at the lab, so I hope I get some student to supervise on it.
05:34:43 <Igloo> (my "None" was to "what parts of base")
05:35:05 <dcoutts> Igloo, ah, yes though I don't think it'll be that way for ever
05:35:32 <dcoutts> eg we could easily take advantage of it in the pretty printer
05:35:53 <Igloo> Is there a reason the prettyprinter needs to be in base?
05:36:00 <dcoutts> nope
05:36:18 <dcoutts> well it means that things like Cabal don't need to dep on anything other than base
05:36:21 <Igloo> That doesn't make the case for bytestring being there, then  :-)
05:36:24 <dcoutts> there is a certain convenience
05:36:31 <dcoutts> Igloo, I'll find a better example :-)
05:38:30 <dons> it would have to be a core lib though
05:38:40 <dons> since TH,win32, unix, ... all depend on it
05:38:43 <Igloo> Yup
05:38:47 <dons> and simon had plans for things in base to depend on it too
05:38:59 <dons> i'm ambivalent.
05:39:11 <kzm> the main downside is that it is harder to track the development.
05:39:49 <dons> its harder on the bytestring devs. since it ties us to base. but it seems like bytestring itself will be pretty stable after 0.9, and we won't care.
05:40:01 <dcoutts> aye
05:40:05 <kzm> I used to do regular pulls, look into the code, etc.  It's a great way to dig into new stuff and learn from other's code.
05:40:21 <kzm> (but of course, it saves you guys a lot of naïve questions :-)
05:41:01 <kzm> Especially since I don't have any other Hs programmers around.
05:41:14 <LoganCapaldo> What are the implications for things like elem and esp. (++) with data packed/ byte string. Is there just gonna be a new type class "Concataable" or something, or will strings have a different concat operator, etc.?
05:41:56 <dcoutts> LoganCapaldo, there's the monoid class
05:41:58 <dons> there's Monoid for that
05:42:18 <Igloo> Did hugs' ./configure always end with "config.status: executing ultra-evil commands"?
05:42:30 <dons> yeah i think so
05:42:36 <dons> probably should say something else..
05:42:41 * dcoutts goes off to teach FP
05:42:49 <vincenz> dcoutts: haskell?
05:42:52 <dcoutts> yep
05:43:16 <dcoutts> Richard Bird is coming round this session to see all the pretty pictures the students have been making
05:43:29 <dcoutts> lots of 3D trees
05:43:38 <vincenz> :D
05:43:52 <vincenz> Anyone know if yhc is gpl?
05:44:32 <LoganCapaldo> So it's gonna be (++) :: (Monoid a) => a -> a -> a ?
05:45:00 <dons> ?remember JaffaCake Casting boxed types to unboxed types or vice versa is pretty much guaranteed to end in tears
05:46:14 <desrt> dons; is this like quotes?
05:47:18 <Cale> @quote JaffaCake
05:47:19 <lambdabot>  I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
05:47:43 <Cale> @quote desrt
05:47:43 <lambdabot>  man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
05:49:01 <dons> hmm, Couldn't match kind `*' against `!'
05:49:05 <dons> there's a ! kind now?
05:49:24 <vincenz> @quote cale
05:49:25 <lambdabot> cale hasn't said anything memorable
05:49:27 <vincenz> @quote Cale
05:49:28 <lambdabot>  [discussing names for Haskell, after suggesting Sapphire] Diamond: The Hardest Programming Language on Earth
05:49:43 <vincenz> lambdabot should become case insensitive
05:49:44 <Cale> I didn't suggest Sapphire
05:49:49 <Cale> it was someone else :)
05:50:00 <vincenz> @quote Cale
05:50:01 <lambdabot>  desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal object in the
05:50:01 <lambdabot> category of religions and theomorphisms.
05:50:22 <vincenz> Cale: yeah, you and xkcd go hand in hand :D
05:50:44 <opqdonut> @quote vincenz
05:50:45 <lambdabot>  why do you want to be dynamicalyll gendered? lexically gendered is cleaner
05:51:27 <dblhelix> @pl \f y g x -> x `f` g y
05:51:28 <lambdabot> (. flip id) . (.) . flip
05:51:59 <Philippa_> *snigger* Dynamic's more fun though
05:52:35 <desrt> Cale; is there any difference between ? and @?
05:52:48 <vincenz> desrt: no
05:52:55 <desrt> @awesome
05:52:56 <lambdabot> Unknown command, try @list
05:53:09 <vincenz> \pl \f y g x -> x `f` g y
05:53:24 <dons> I should have pushed harder for lambdas, oh well
05:53:26 <vincenz> hmm, I'm pretty certain there's a few other prefixes, or at least there used to be
05:53:41 <vincenz> dons: nicks should be caseless!
05:53:41 <dons> there used to be, but all the whingers whinged.
05:53:55 <dons> vincenz: don't you mean cases should be nickless?
05:54:13 <vincenz> It is, submission to CASES is doubly blind
05:54:13 * dons goes to bed. night!
05:54:26 <vincenz> night dnos
05:54:34 <desrt> λ is currently rocking me on all fronts.  it's been in all of my courses except computational complexity... until recently where it showed up in a very unexpected form... eigenvalues!
05:58:00 <Itkovian> ah, the insidiousness of lambda ...
06:00:46 <roconnor> what Heaviside is the name of a person?!
06:01:14 <roconnor> I thought the Heaviside function was so named because it put all the ``weight'' on one side of the real number line.
06:01:48 <Cale> heh
06:02:04 <roconnor> seriously
06:02:13 <therp> desrt: eigenvalues are connected to λ?
06:02:15 <roconnor> but his name is Oliver Heaviside.
06:02:16 <Cale> yeah, it's a proper name
06:03:00 <Cale> that's a good way to remember it though :)
06:03:31 <CosmicRay> Igloo: ping
06:03:33 <yaxu> Cale: nice religion, where do I sign up?
06:04:22 <Cale> there are no papers to sign, in fact, I still don't even have a name for it yet :)
06:04:32 <Igloo> CosmicRay: pong
06:05:09 <CosmicRay> Igloo: are you using ./setup copy --copy-prefix=debian/packagename ?
06:06:06 <Igloo> ./setup-ghc copy --copy-prefix=`pwd`/debian/`dh_listpackages`/usr
06:06:21 <Cale> vincenz: my former housemate and I knew all about the "delicious cycle" referred to in xkcd.
06:06:25 <CosmicRay> is setup-ghc just the result of ghc --make -o setup-ghc Setup.lhs ?
06:07:00 <Igloo> ghc --make Setup.hs -o setup-ghc
06:07:08 <CosmicRay> ok.
06:07:39 <xerox> Wasn't that called cabal-setup ?
06:08:01 <Igloo> Wasn't what called that?
06:09:43 <yaxu> Cale: i guess it's a performative statement
06:11:14 <xerox> setup-ghc
06:11:35 <xerox> That is, a compiled Setup.hs...
06:12:03 <Igloo> Isn't cabal-setup a separate program?
06:12:31 <kzm> Anybody know how/if ghc is profiling FFI calls?
06:12:41 <kzm> (Seems it gets folded into main?)
06:12:53 <kzm> (but that could be an optimization, though)
06:25:54 <dblhelix> any cabal experts present??
06:27:50 <xerox> Igloo: nope
06:28:27 <xerox> I think it's Duncan's invention.  Just a precompiled standard Setup.hs.
06:33:22 <CosmicRay> Igloo: ah HA!   dh_pycentral is the culprit.
06:34:06 <Igloo> It's helpfully removing empty directories for you?
06:34:33 <CosmicRay> yes, and it's actually trying to remove the entire usr/lib/haskell-packages/ghc6 tree, but include is the only empty dir.
06:34:50 <Igloo> heh
06:34:52 <CosmicRay> finally I had to strace through the commands in binary-arch, one at a time, to track this down.
06:35:04 <Igloo> Make dh_haskell remove anything with python in its name!
06:35:10 <CosmicRay> heh
06:41:16 <CosmicRay> Igloo: check this out, from /usr/bin/pycentral:
06:41:27 <CosmicRay>             # remove empty dirs in /usr/lib
06:41:27 <CosmicRay>             for root, dirs, files in os.walk(self.pkgdir + '/usr/lib', topdown=F
06:41:27 <CosmicRay> alse):
06:41:27 <CosmicRay>                 try:
06:41:27 <CosmicRay>                     os.rmdir(root)
06:41:28 <CosmicRay>                 except OSError:
06:41:30 <CosmicRay>                     pass
06:42:30 <vincenz> CosmicRay: @paste
06:42:41 <Itkovian> @paste
06:42:42 <lambdabot> http://paste.lisp.org/new/haskell
06:49:55 <CosmicRay> I wanted to share this particular bit of shortsightedness with the entire channel ;-)
06:50:41 <boegel> Itkovian: ?
06:51:04 <camster> ComsicRay: I've seen worse. I knew someone who's nightly cron job went something like this: cd ~/tmp; rm -fr *
06:51:18 <Syzygy-> ...
06:51:18 <camster> CosmicRay: Worked fine until he removed the ~/tmp directory one day.
06:51:26 <Syzygy-> Heeee
06:52:31 <CosmicRay> haha
06:53:19 <sieni> pwned
06:54:14 <camster> That was his initial reaction. We all saw him run the length of the office to the rack at the end whereupon he started ripping out network cables on the grounds that we've been "hacked".
06:54:48 <Itkovian> CosmicRay: thanks for sharing then :-)
06:55:08 <Itkovian> boegel: did you whack Bertrand for the whole DRM mess?
06:55:55 <fabiim> i have finished my work , thank to all you guys who have been helping me in the last day's =)  it works ! lol
06:56:32 <boegel> Itkovian: nah ;-) He didn't even mention Microsoft during his talk
06:56:49 <Itkovian> but he surely mentioned DRM-like crap?
06:57:07 <Itkovian> I guess he's not allowed to speak of anything he did at microsoft
06:57:16 <boegel> Itkovian: yeah, he did mention some stuff
06:57:17 <Itkovian> especially with the patent that's been filed
06:57:19 <boegel> no details though :)
06:57:33 <boegel> Itkovian: I think he explained the system quite a bit
06:57:37 <xerox> fabiim++
06:57:50 <fons> hi all
06:57:59 <boegel> hi fons !
06:58:05 <Itkovian> boegel: I think the idea is good, but will probably be used for all the wrong reasons
06:58:06 <BCoppens> Itkovian: DRM, brrrrr :/
06:58:06 <fabiim> =)
06:58:19 <Itkovian> BCoppens: exactly
06:58:20 <fons> How can Float converted to Double?
06:58:21 <vincenz> we moeten #haskell.be starten
06:58:28 <vincenz> @hoogle Float -> Double
06:58:30 <lambdabot> No matches, try a more general search
06:58:31 <BCoppens> vincenz: ;)
06:58:32 <Itkovian> still, I'm an iPod user ;-)
06:58:34 <boegel> Itkovian: they are trying to protect their money...
06:58:40 <vincenz> @hoogle (Floating a) => a -> Double
06:58:41 <Igloo> realToFrac
06:58:42 <lambdabot> No matches, try a more general search
06:58:48 <vincenz> > realToFrac 1.1
06:58:49 <BCoppens> Itkovian: yes, that's also not really DRM-free ;)
06:58:49 <lambdabot>  1.1
06:58:50 * boegel runs off into the dark
06:58:56 <vincenz> > realToFrac (1.1::Float) ::Doube
06:58:56 <lambdabot>  Not in scope: type constructor or class `Doube'
06:58:57 <vincenz> > realToFrac (1.1::Float) ::Double
06:58:57 <Itkovian> boegel: it's been kinda proven that DRM is the wrong way to go, no?
06:58:59 <lambdabot>  1.100000023841858
06:59:07 <earthy> ;)
06:59:09 <Itkovian> BCoppens: only if you but iTunesMS stuff
06:59:15 <fons> thanks vincenz
06:59:16 <fons> :)
06:59:19 <boegel> Itkovian: I don't know too much about it :)
06:59:22 <vincenz> welcome
06:59:27 <Itkovian> BCoppens: and burning it in audio format and re-ripping it frees the DRM, I think
06:59:50 <BCoppens> Itkovian: you can burn it to a regular audio CD?
07:00:03 <Itkovian> yes
07:00:09 <Itkovian> about fice times or so
07:00:43 <BCoppens> that's..... weird
07:00:51 <vincenz> yeah, fice isn't even a number
07:01:47 <BCoppens> that you're allowed to burn it is weird, rather :)
07:05:22 <fons> uhm, strange ghc behaviour. My module is called ForSyDeEqualizer but the root init symbol created is __stginit_ForSyDeEqualizzer (note the double z)
07:07:30 <norpan> fons: yes, the mangler uses z
07:07:40 <fons> If I rename the module to "module Zzzaabb" the symbol created is __stginit_ZZzzzzaabb_
07:08:36 <norpan> try a name with _ in it
07:09:15 <fons> norpan, then I guess that shoule be mentioned at http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html
07:09:17 <lambdabot> Title: 8.2. Using the FFI with GHC, http://tinyurl.com/ylojgn
07:09:30 <norpan> i suppose
07:09:50 <fons> I'll fill a bug report
07:09:59 <norpan> (_ gets mangled to zu)
07:10:03 <norpan> if you didn't try it
07:11:32 <fons> damn ... Z_z_z gets mangled to __stginit_ZZzuzzzuzz
07:13:00 <fons> norpan, how can I mangle a string?
07:13:14 <fons> norpan, so that I can predict how the symbol will be
07:13:22 <norpan> z -> zz, _ -> zu
07:13:50 <fons> norpan, just that?
07:13:56 <norpan> that's all i know
07:14:06 <norpan> i don't know any other characters that can be present in identifier
07:14:07 <norpan> s
07:14:21 <norpan> i suppose operators have rules too, but module names cannot contain those symbols
07:15:11 <Renkin> @type fromJust
07:15:12 <lambdabot> forall a. Maybe a -> a
07:15:36 <Renkin> What's the command for seeing in which library something is?
07:15:52 <kpreid> @index fromJust
07:15:52 <lambdabot> Data.Maybe
07:16:00 <Renkin> Cool, thanks
07:18:37 <thetallguy> ?remember
07:18:38 <lambdabot> Incorrect arguments to quote
07:22:42 <malebria> Hello guys.
07:33:48 <vincenz> @type forM
07:33:49 <lambdabot> Not in scope: `forM'
07:33:54 <vincenz> @type mapM
07:33:56 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
07:34:22 <xerox> forM_ = flip mapM_ -- is the usual definition
07:34:41 <vincenz> thx
07:36:57 <vincenz> @type ($!)
07:36:59 <lambdabot> forall b a. (a -> b) -> a -> b
07:38:44 <Syzygy-> @type ($)
07:38:46 <lambdabot> forall b a. (a -> b) -> a -> b
07:43:34 <vincenz> @hoogle String -> Integer
07:43:35 <lambdabot> No matches, try a more general search
07:43:38 <vincenz> @hoogle String -> Int
07:43:39 <lambdabot> No matches, try a more general search
07:43:47 <glguy> length?
07:44:20 <vincenz> no,read
07:44:32 <vincenz> @pate
07:44:33 <lambdabot> http://paste.lisp.org/new/haskell
07:44:33 <vincenz> @paste
07:44:34 <lambdabot> http://paste.lisp.org/new/haskell
07:44:44 <lisppaste2> vincenz pasted "getting this faster" at http://paste.lisp.org/display/30285
07:46:45 <Syzygy-> @hoogle (a -> b) -> (b -> a)
07:46:46 <lambdabot> No matches, try a more general search
07:47:00 <glguy> flip?
07:47:07 <glguy> oh
07:47:12 <glguy> nevermind, co-routines?
07:47:34 <Syzygy-> It's a question I'm getting asked from another relative Haskell n00b...
07:47:37 <xerox> Syzygy-: eeek.
07:47:52 <Syzygy-> Is there any function that for sufficiently general types a,b could fulfill this? (his question).
07:48:04 <xerox> id
07:48:07 <Syzygy-> Gut feeling: No, since functions need not have inverses, but otoh inverses are not asked...
07:48:11 <Syzygy-> @type id
07:48:13 <lambdabot> forall a. a -> a
07:48:47 <glguy> ?djinn (a -> b) -> (b -> a)
07:48:48 <lambdabot> -- f cannot be realized.
07:48:57 <Syzygy-> Or, in other words, can it be proven that no such can exist?
07:49:24 <xerox> ski, edwinb?
07:49:52 <Cale> There are no nonidiotic values of type forall a b. (a -> b) -> (b -> a)
07:50:26 <Syzygy-> Cale: Nice. You wouldn't happen to have a proof up your sleave?
07:50:35 <swiert> Just use Curry Howard.
07:50:41 <xerox> Interpret it logically?
07:51:04 * edwinb wakes up
07:51:04 <Cale> What they said :)
07:51:15 <xerox> if (if a then b) then (if b then a)
07:51:20 <edwinb> no chance ;)
07:51:30 <xerox> edwinb: spit out the sequents!
07:52:12 <xerox> (Hi!)
07:52:26 <Cale> Also, just think about it -- you have a function (a -> b), and a value of type b, and you need a value of type a. You can't even apply the function you have, (since you don't have a value of type a) making it useless.
07:53:01 <DRMacIver> Right. But 'making it useless' isn't a proof. :) It's obvious there shouldn't be such a function.
07:53:14 <DRMacIver> (Thanks for the curry howard proof by the way. I like that.)
07:53:43 <DRMacIver> (Sorry, that was to swiert)
07:53:44 <dolio> ?type (let g f = undefined in g :: (a -> b) -> (b -> a))
07:53:46 <lambdabot> forall a b. (a -> b) -> b -> a
07:54:23 <xerox> ?type (const undefined :: (a -> b) -> (b -> a))
07:54:25 <lambdabot> forall a b. (a -> b) -> b -> a
07:54:31 <Cale> dolio: that's why I qualified by statement with "nonidiotic" :)
07:54:33 <DRMacIver> 'undefined' is clearly cheating. :)
07:54:41 <dolio> Cale: Right.
07:55:07 <dolio> ?type (const (const undefined) :: (a -> b) -> (b -> a))
07:55:09 <lambdabot> forall a b. (a -> b) -> b -> a
07:55:51 <Cale> @djinn (a -> b) -> (b -> a)
07:55:51 <lambdabot> -- f cannot be realized.
07:55:52 <xerox> ?type (fix (const undefined) :: (a -> b) -> (b -> a))
07:55:54 <lambdabot> forall a b. (a -> b) -> b -> a
07:55:55 <xerox> :)
07:56:23 <xerox> ?type (fix undefined :: (a -> b) -> (b -> a))
07:56:25 <lambdabot> forall a b. (a -> b) -> b -> a
07:56:28 <xerox> gah.
07:56:55 <dylan> hmm, tortoisedarcs
07:57:11 <Cale> To really prove the statement formally, you'd need to pick a decent axiomatic system to work in.
07:57:29 <DRMacIver> What does @djinn do?
07:57:38 <Cale> It's a theorem prover
07:58:05 <Cale> @djinn (a -> b) -> (c -> d) -> Either a c -> Either b d
07:58:06 <lambdabot> f a b c =
07:58:06 <lambdabot>   case c of
07:58:06 <lambdabot>   Left d -> Left (a d)
07:58:06 <lambdabot>   Right e -> Right (b e)
07:58:10 <swiert> Having any such function would identify any two logical statements - assuming that you're type system is not too broken, this should be pretty easy to see.
07:58:35 <Cale> @djinn Bool -> a -> a -> a
07:58:35 <lambdabot> f a b c =
07:58:35 <lambdabot>   case a of
07:58:35 <lambdabot>   False -> c
07:58:35 <lambdabot>   True -> b
08:00:06 <DRMacIver> swiert: Yeah, I see that. It just hadn't occurred to me as a line of attack before.
08:00:13 * DRMacIver is very new to the whole type theory thing.
08:00:15 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
08:00:16 <lambdabot> f a b c = a (\ d -> b d c)
08:01:47 <Cale> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
08:01:47 <lambdabot> f a b = a (\ c _ -> b c) b
08:03:10 <Cale> @djinn ((a -> b) -> a) -> a
08:03:10 <lambdabot> -- f cannot be realized.
08:06:47 <Cale> > let implies a b = b || not a in and [((a `implies` b) `implies` a) `implies` a | a <- [False,True], b <- [False, True]]
08:06:49 <lambdabot>  True
08:06:56 <ValarQ> @djinn (b -> a,b) -> a
08:06:57 <lambdabot> f (a, b) = a b
08:07:04 <ValarQ> @. pl djinn (b -> a,b) -> a
08:07:05 <lambdabot> f = ap fst snd
08:07:59 <ValarQ> hmm
08:14:07 <Syzygy-> ?type ap
08:14:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
08:14:19 <Syzygy-> ?type (ap fst snd)
08:14:21 <lambdabot> forall b b1. (b1 -> b, b1) -> b
08:14:34 <Syzygy-> Is there sucha  thing as the non-monad?
08:14:45 <xerox> No, there is the ((->) e) monad
08:14:52 <Syzygy-> Huh?
08:15:41 <xerox> ap f g x = f x (g x) :: (e -> a -> b) -> (e -> a) -> e -> b
08:16:20 <xerox> ...which is the S combinator in the SKI calculus.
08:16:30 <xerox> (K is const, I is id.)
08:16:58 <xerox> the ?pl plugin uses the fact that every lambda term can be reduced to a SKI term.
08:17:37 <xerox> (and the latter do not have any formal arguments)
08:18:02 <Syzygy-> e -> ??? What's the e?
08:18:13 <Syzygy-> e is the same as () is it?
08:18:19 <Syzygy-> @type () -> 3
08:18:20 <lambdabot> not an expression: `() -> 3'
08:18:22 <xerox> ((->) e) is a type constructor
08:18:33 <xerox> of kind * -> * (or something)
08:18:43 * Syzygy- doesn't understand.... Oh well. Some other day.
08:18:51 <xerox> it construct the types of functions from e to whatever you want
08:18:55 <xerox> e is just a type variable.
08:19:01 <Syzygy-> Ok....
08:19:12 <xerox> if type-level sections were allowed, one could write (e ->)
08:19:50 <Ontolog> I'm reading the Introduction to Haskell on the Haskell wiki and it says that this is an implementation of QuickSort: qsort [] = []; qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
08:20:00 <xerox> if you apply a type `a' to that type constructor, you get back the type of functions from `e' to `a'.  sorry if my explanation is not clear
08:20:24 <xerox> you can find that monad instance defined in the Control.Monad.Reader module.
08:20:27 <Ontolog> But since Haskell is 'functional' and there are no steps, and since QuickSort is a particular algorithm, consisting of specific steps, how is this true?
08:20:50 <Botje> Ontolog: a quicksort is a process. processes can be modeled in functional languages.
08:20:53 <Botje> your point being?
08:21:03 <xerox> newtype Reader e a = Reader { runReader :: e -> a } -- if you are familiar with newtype syntax.
08:21:06 <Ontolog> quicksort is an _algorithm_ last time i checked
08:21:12 <Ontolog> sorting is a process
08:21:40 <xerox> it is called `e' because it looks like an environment in that monad.  a shared environment in all your actions, which you get access with `ask'.
08:21:50 <xerox> (a read-only environment.)
08:21:52 <Syzygy-> ?type ask
08:21:53 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
08:21:58 <Syzygy-> Ah...
08:22:30 <xerox> which is basically (well, it's exactly) equivalent to passing around an argument of type e to all of your functions.
08:22:30 * Syzygy- really has to leave the keyboard now though. Thanks, xerox for explanations.
08:22:34 <Syzygy-> xerox++
08:22:39 <xerox> You're welcome!
08:23:36 * Syzygy- is a strong believer in karma. :)
08:23:40 <Botje> Ontolog: i'd say the steps are necessary to emulate the process in an imperative language.
08:23:56 * xerox hugs Syzygy- 
08:28:09 <Philippa_> Ontolog: Quicksort may be an algorithm, surely "a quicksort" is an instance thereof and can thus refer to a running process?
08:29:13 <alexj__> shapr: ping?
08:33:00 <Renkin> When i try to compile my wxHaskell program:  "Error: Can't create window of class wxWindowClass (error 1407: cannot find window class)"
08:33:48 <Renkin> I started GHCi with -package wx  and the module imports Graphics.UI.WX
08:34:35 <Renkin> Anyone know what's going on?
08:38:25 <sjanssen> is this an error while the code is loading, or when you try to run some function?
08:38:43 <twanvl> it sounds to me like you need to call some kind of initialization function
08:38:50 <Renkin> Oh right, when I try runnign a function
08:38:52 <Renkin> Not compile, my wrong
08:39:17 <sjanssen> yeah, I don't know wx, but sounds like twanvl may be right
08:39:37 <Renkin> And he is, it seems. I missed some start thing
08:41:34 <Renkin> Yep, now it works. Thanks
08:53:15 <glguy> ?typ getArgs
08:53:17 <lambdabot> Not in scope: `getArgs'
08:53:22 <glguy> ?hoogle args
08:53:23 <lambdabot> Distribution.Simple.Args :: type Args
08:53:23 <lambdabot> System.getArgs :: IO [String]
08:53:23 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
08:55:38 <glguy> ?hoogle env
08:55:38 <lambdabot> System.Environment :: module
08:55:39 <lambdabot> System.getEnv :: String -> IO String
08:55:39 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
08:57:01 <ski> xerox : ?
08:57:35 <xerox> ski Syzygy- were looking for a (dis)proof that (a -> b) -> (b -> a)
08:57:45 <xerox> I though you might know one
08:58:33 <opqdonut> xerox: disproof what?
08:59:21 <ski> hm
08:59:29 <ski> maybe
08:59:31 <xerox> opqdonut: a proof that there are no such values of that type.
08:59:46 <opqdonut> ok
09:00:00 <ski> foo :: Not (forall a b. (a -> b) -> (b -> a))
09:00:10 <ski> foo ab_to_ba = ab_to_ba void ()
09:00:17 <xerox> ..or, equivalently, that "if (if a then b) then (if b then a)".
09:00:36 <xerox> (disproof that, the negation is true)
09:00:38 <ski> xerox : does that qualify ?
09:00:54 <xerox> ski ha.
09:01:15 <ski> (i'm not sure djinn likes higher-ranked types, though)
09:01:20 <xerox> () = b?
09:01:56 <ski> the argument function is polymorphic, 'b' gets instantiated to '()' and 'a' to 'Void', locally
09:02:04 <xerox> AH.
09:02:12 <ski> i.e. we use
09:02:26 <ski> (Void -> ()) -> (() -> Void)
09:02:28 <ski> and since
09:02:34 <ski> void :: forall a. Void -> a
09:02:38 <ski> specifically
09:02:42 <ski> void :: Void -> ()
09:02:50 <ski> ok ?
09:02:52 <xerox> yes
09:02:54 <ski> @djinn (forall a b. (a -> b) -> (b -> a)) -> Void
09:02:55 <lambdabot> -- f cannot be realized.
09:03:00 * xerox hugs ski
09:03:16 <ski> (seems it doesn't like higher-ranked, yes)
09:03:43 <xerox> :)
09:03:54 <ski> hm
09:04:04 <ski> @djinn (forall a. a -> a) -> b -> b
09:04:05 <lambdabot> f _ a = a
09:04:53 <ski> @djinn (forall a. f a -> a) -> f b -> b
09:04:54 <lambdabot> -- f cannot be realized.
09:05:16 <ski> @djinn (f b -> b) -> f b -> b
09:05:17 <lambdabot> f a = a
09:05:45 <xerox> gulp
09:06:11 <glguy> Is there a better way to express this: fromMaybe 100 . findIndex f . take 100
09:06:32 <glguy> or: length . takeWhile g . take 100
09:43:27 <glguy> h <- liftM (liftM read) (lookup "LINES")
09:43:52 <glguy> hmm, I think my attempt at combining Maybe and Reader is resulting in the code being less readable than I had hoped :)
09:45:06 <opqdonut> :D
09:45:08 <Philippa_> I find it's often better to wrap the actions you want for direct use in the new monad
09:45:37 * shapr wakes up
09:45:43 <Philippa_> though thinking about it I've misread - assuming you do indeed mean liftM rather than lift
09:45:53 <glguy> example:
09:45:55 <glguy>    result <- liftM (do
09:45:55 <glguy>            h <- liftM (liftM read) (lookup "LINES")
09:45:55 <glguy>            w <- liftM (liftM read) (lookup "COLUMNS")
09:45:55 <glguy>            return $ fromMaybe (error "Env lookups failed") $ liftM2 foo h w) getEnvironment
09:46:42 <glguy> I'm just screwing around, I realize that this is slowly approaching point-free
09:47:40 <opqdonut> not point-less, i hope
09:47:43 <opqdonut> *rimshot*
09:48:19 <sjanssen> glguy: this code looks too light weight to benifit from the reader monad
09:48:42 <Philippa_> I'm inclined to say almost all code that has that usage pattern benefits from it at least somewhat
09:48:44 <glguy> sjanssen: I'm just playing around, I realize that this is not necesarily a "better way"
10:00:46 <glguy> Here we go, I solved away all of those pesky variables
10:00:47 <glguy> putStrLn =<< liftM (liftM fromJust $ liftM2 (liftM2 foo) ((liftM read) `liftM` lookup "LINES") ((liftM read) `liftM` lookup "COLUMNS")) getEnvironment
10:01:11 <glguy> now I just need to switch fromJust to a fromMaybe (error "env lookups failed")
10:01:13 <opqdonut> well thankyou, that really cleaned it up
10:01:16 <psnl> yeouch
10:02:30 <glguy> ?pl   putStrLn =<< liftM (fromMaybe (error "lookups failed" `liftM` liftM2 (liftM2 foo) ((liftM read) `liftM` lookup "LINES") ((liftM read) `liftM` lookup "COLUMNS")) getEnvironment
10:02:30 <lambdabot> (line 1, column 176):
10:02:31 <lambdabot> unexpected end of input
10:02:31 <lambdabot> expecting variable, "(", operator or ")"
10:02:35 <glguy> ?
10:02:45 <glguy> oh
10:02:53 <glguy> ?pl putStrLn =<< liftM (fromMaybe (error "lookups failed") `liftM` liftM2 (liftM2 foo) ((liftM read) `liftM` lookup "LINES") ((liftM read) `liftM` lookup "COLUMNS")) getEnvironment
10:02:55 <lambdabot> putStrLn =<< fmap (fromMaybe (error "lookups failed") `liftM` liftM2 (liftM2 foo) (fmap read `liftM` lookup "LINES") (fmap read `liftM` lookup "COLUMNS")) getEnvironment
10:03:05 <glguy> see what lambdabot's rewrite rules would say...
10:04:07 <opqdonut> ?help pl
10:04:09 <lambdabot> pointless <expr>. Play with pointfree code.
10:04:12 <opqdonut> ah
10:06:04 <glguy> I wonder what distinction lambdabot makes between fmap and liftM, and why some of my liftMs were converted to fmaps while others were not
10:06:45 <opqdonut> they were converted when it simplified code?
10:07:13 <xerox> yeah, when you didn't need parenthesis
10:07:23 <xerox> (:
10:08:24 <opqdonut> ?pl forkIO (print foo) >>= \x -> threadDelay 10 >> throwTo x Deadlock
10:08:24 <lambdabot> (threadDelay 10 >>) . flip throwTo Deadlock =<< forkIO (print foo)
10:08:26 <glguy> it's cases like this that a generalized (.) operator would be great
10:08:41 <opqdonut> generalized in what way?
10:09:02 <glguy> > ( (*2) . (+1) ) 5
10:09:04 <lambdabot>  12
10:09:15 <glguy> > ( (*2) `fmap` (+1) ) 5
10:09:16 <lambdabot>  12
10:09:33 <xerox> > ((+1) . (*3)) . [1,2,3]
10:09:35 <lambdabot>  Couldn't match `a -> b' against `[a1]'
10:09:41 <xerox> yuck, what was that?
10:09:49 <glguy> to allow what xerox typed to actually work
10:10:13 <xerox> ?type fmap
10:10:15 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
10:10:25 <xerox> f = ((->) e)
10:10:40 <xerox> (a -> b) -> (e -> a) -> (e -> b)
10:10:45 <xerox> ?type (.)
10:10:47 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
10:11:28 <glguy> opqdonut: then I could replace all of the liftMs in my code to (.)
10:11:33 <glguy> s/to/with
10:12:58 <glguy> putStrLn =<< ((fromMaybe (error "lookups failed") . liftM2 (liftM2 foo) ((read .) . lookup "LINES") ((read .) . lookup "COLUMNS"))) . getEnvironment
10:12:58 <xerox> (because ((->) e) is a monad as well)
10:13:43 <xerox> ?type liftM2
10:13:45 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:14:05 <xerox> and if composition (.) was variadic, even those :)
10:14:15 * xerox mumbles.
10:14:36 <glguy> a variadic operator might be a bit difficult though...
10:14:41 <glguy> a . b c d?
10:14:56 <xerox> compose
10:15:00 <sjanssen> xerox: but then you'll complain when you mean simple (.) and the variadic version gets in the way
10:15:04 <xerox> wait, I think have written that.
10:15:06 <glguy> we could just have: a .. b c
10:15:13 <glguy> and a ... b c d
10:15:20 <xerox> sjanssen: I will not :)
10:15:25 <sjanssen> glguy: can't have ..
10:15:37 <sjanssen> > [1.. 2 ] -- there's a conflict
10:15:38 <lambdabot>  [1,2]
10:15:57 <glguy> sjanssen: I'm aware that this can't work in Haskell as Haskell stands
10:16:16 <xerox> I have the code, do you want to see it
10:16:18 <xerox> ?
10:16:23 <vincenz> > let (..) a b = a +b in 1..2
10:16:25 <lambdabot>  Parse error
10:16:29 <vincenz> > let (...) a b = a +b in 1...2
10:16:31 <lambdabot>  3
10:16:36 <glguy> and it seems that it would just serve to make code harder to read
10:16:50 <xerox> I've called that c
10:16:51 <glguy> but it's still a fun idea to toss around
10:17:04 <vincenz> > let (....) a b = a +b in 1....2
10:17:06 <lambdabot>  3
10:17:09 <xerox> and then I use it on a list of arguments
10:17:24 <vincenz> > let (..) a b = a +b in 12
10:17:25 <xerox> http://darcs.haskell.org/~paolo/darcs/tao/VarArg.hs
10:17:26 <lambdabot>  Parse error
10:17:28 <lambdabot> http://tinyurl.com/y6aodz
10:17:36 <vincenz> > let f a b = a +b in 1..2
10:17:37 <lambdabot>  Parse error
10:17:46 <dolio> Variadic compostion seems like something Oleg would have done by now.
10:17:51 <dolio> Or is that too trivial for him?
10:17:53 <glguy> ?type \f -> liftM2 (liftM2 f)
10:17:55 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> a2 -> r) -> m1 (m a1) -> m1 (m a2) -> m1 (m r)
10:17:56 <xerox> :(
10:18:56 <xerox> I should polish that thing.
10:20:08 <xerox> ...if d is the only way to use c, yuck, that's nonsensical :P
10:20:32 <sjanssen> dolio: polyvariadic composition of type functions sounds more like something Oleg would do
10:20:49 <dolio> Oh, wait, his page does have "Polyvariadic composition."
10:21:04 <dolio> At the very bottom.
10:21:14 <glguy> > let x .. = x + 1 in 3 ..
10:21:14 <lambdabot>  Parse error
10:21:25 <sjanssen> xerox: it requires -fundecidable-instances? :(
10:21:37 <dolio> http://okmij.org/ftp/Haskell/polyvar-comp.lhs
10:21:42 <glguy> > let x ... = x + 1 in 3 ..
10:21:42 <lambdabot>  Parse error
10:21:44 <glguy> > let x ... = x + 1 in 3 ...
10:21:44 <lambdabot>  Parse error
10:21:50 <glguy> what's the syntax for this?
10:22:08 <glguy> > let (...) x = x + 1 in (3 ...)
10:22:08 <lambdabot>  add an instance declaration for (Num (t -> t1))
10:22:10 <lambdabot>   In the definition of `n...
10:22:11 <sjanssen> xerox: have you attempted to do it without undecidable instances?  Do you think that is possible?
10:22:23 <glguy> or is lambdabot not running a sufficiently recentversion of GHC?
10:22:24 <xerox> sjanssen: good question
10:22:38 <dolio> That last one is correct, but it probably needs some kind of flag.
10:23:04 <glguy> ah, that last work works w/o flags in 6.6
10:23:05 <xerox> sjanssen: OTOH, mine does not require writing out instances like Oleg's.
10:23:06 <glguy> ?version
10:23:06 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
10:23:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:24:13 <xerox> But at the time I didn't know the [[]] trick.  I should try to write versions of my typesystem-crazy-stuff that make use of that instead of those Wrappers.
10:24:25 <sjanssen> xerox: I'd rather have an ugly implementation than import a module with undecidable instances
10:24:38 <sjanssen> if we're talking about real world use
10:24:57 <xerox> they are *so* bad?
10:25:06 <xerox> auhm.
10:25:09 <xerox> i smell runtime errors
10:26:20 <cjeris> grrr.  how do i move down the page image in an A4 PS?  i'm trying to print out wadler's deforestation paper on my US Letter printer, and the top keeps getting cut off...
10:27:41 <sjanssen> xerox: undecidable instances can make the type checker go into a loop
10:28:15 <xerox> so one could inject an higher-level bug this way, gah.
10:28:45 <sjanssen> it makes sense to burden the implementer just a little bit if you can give the user guarantees about decidability of type checking and such
10:28:54 <newsham> xerox: arrow do-notation not that complicated, but not that useful for my code:  http://www.thenewsh.com/~newsham/x/machine/Transform4.hs
10:28:57 <lambdabot> http://tinyurl.com/ycv3vq
10:29:08 <newsham> since its already fairly linear, the (>>>) notation is fine.
10:29:11 <sjanssen> again, for real world use.  Doesn't matter to me if it's just a hack
10:29:28 <newsham> but if you have some non-linear arrow code, the do-notation will keep track of the splitting and stuff for you
10:29:33 <xerox> newsham: nice!
10:29:48 <xerox> newsham: can you produce an example?
10:30:02 <newsham> other tha nthe one in the url i pasted?
10:30:09 <xerox> a non-linear one
10:30:09 <newsham> i think maybe liftA2 would be a better example.
10:30:22 <xerox> uhm
10:30:25 <xerox> ?type liftA2
10:30:27 <lambdabot> Not in scope: `liftA2'
10:30:33 <xerox> ?type Control.Arrow.liftA2
10:30:35 <lambdabot> Not in scope: `Control.Arrow.liftA2'
10:30:52 <newsham> proc x -> do {  y <- f -< x;  z <- g -< x; returnA -< (y `op` z) }
10:30:59 <xerox> right
10:31:05 <newsham> thats nonlinear (since x is used twice)
10:31:05 <xerox> that's nearly 2D
10:31:40 <newsham> pretty clever syntax
10:31:46 <xerox> is there anything available with this syntax?
10:31:51 <xerox> anything else
10:32:16 <newsham> there's a (-<<) which look similar to (-<)  which i'm not sure the details of.
10:32:23 <xerox> !
10:32:29 <newsham> but i think thats omre or less the gist of it
10:33:03 <xerox> ok cool
10:33:14 <xerox> somebody enable it in lambdabot!
10:33:15 <xerox> :)
10:34:03 <glguy> I still have yet to see a compelling and illustrative example explaining what Arrows do to someone who understands Monads
10:34:17 <glguy> (and I would welcome any links)
10:35:06 <newsham> > (runKleisli (proc x -> do { y <- (arr (++ ">")) -< x; returnA -< y })) "test"
10:35:07 <lambdabot>  Parse error
10:35:57 <glguy> > (runKleisli (\x -> do { y <- (arr (++ ">")) -< x; returnA -< y })) "test"
10:35:58 <lambdabot>  Not in scope: `-<'
10:35:58 <glguy> ?
10:36:02 <newsham> (runKleisli (proc x -> do { y <- (arr (++ ">")) -< x; returnA -< y })) "test" :: [String]
10:36:02 <newsham> ["test>"]
10:36:13 <glguy> what's this "proc" business?
10:36:18 <newsham> in ghci I have to specify :: [String] for some reason
10:36:21 <dolio> Have you read Hughes' original paper?
10:36:24 <newsham> glguy: arrow do-notation  (-farrows)
10:36:28 <glguy> ah
10:36:45 <newsham> dolio: the first half, didnt get through the more advanced exapmles at the end
10:37:12 <dolio> It discusses his rationale for introducing arrows (as a standard interface for combinator libraries that can't be made monadic).
10:37:47 <newsham> yah, but i found it useful for a monadic problem I was workign on (which is how I got to this path in the first place)
10:37:48 <glguy> does anyone have a link to the "final draft"?
10:37:50 <dolio> Specifically, a parser that avoids space leaks using statically known information.
10:38:13 <newsham> I was writing combinators for transformation fnctions   a -> [a]  (String -> [String] in particular)
10:38:22 <newsham> and someone pointed out that those are just a kleisli arrow.
10:38:37 <dolio> I just have the draft (according to the arrows page).
10:38:39 <newsham> and most of my combinators turn out to already exist in the arrow lib
10:38:46 <dolio> I don't know how different the final is.
10:39:42 <Philippa_> glguy: Arrows are more general. Monads support higher-order computations, Arrows don't necessarily
10:40:47 <Philippa_> if you don't support higher-order computations, assorted analyses are easier. Plus there're some things that can't support them
10:41:14 <glguy> If a Monad is a method of computation, and a Functor is a container, what might an Arrow be?
10:41:27 <Philippa_> it's a method of computation still
10:41:28 <glguy> just a more general computation?
10:41:32 <Philippa_> yeah
10:42:40 <Philippa_> if you really insist, functors're computations that can be described entirely by a sequence of maps. It just so happens that this also means describable by just one map
10:43:06 <ski> Arrow : method of "transforming computation"
10:43:58 <glguy> as in a method for transforming a computational method? or it is a transforming-computation?
10:44:09 <ski> the latter
10:44:17 <newsham> an arrow is a process from input to output (like a function)
10:44:28 <Philippa_> though transforming () to something is equivalent to a non-transforming one anyway
10:44:36 <ski> monads are concerned with constructing some output, but in doing so, also perform some effects
10:45:00 <ski> arrows are concerned with transforming input to output, while performing effects
10:45:35 <ski> comonads are concerned with deconstructing some input, and performing effects while doing so
10:46:06 <ski> those above are rough intuitions that i think describes it approximately
10:46:51 <tibbe> there was an arrows tutorial on reddit today and now it's gone, anyone have the link?
10:46:58 <ski> Philippa_ : how about a stream-transformer from '()' ?
10:47:23 <glguy> alrighty, I'll bear that in mind while I read this lecture-slides pdf
10:47:45 <newsham> you <- heart -<< blame; let badname = love where badname = (head you)
10:47:48 <Philippa_> ski: elaborate? () isn't a stream in and of itself, right?
10:48:16 <newsham> -- (c) 1986 jon bon jovi
10:48:38 <ski> (one possible example of comonads in natural language could be indexial expressions, like "today", "i", "here", "the king of france", whose meaning depends on in which context one uses them)
10:49:02 <ski> Philippa_ : 'foo :: StreamTransf () X'
10:49:24 <Philippa_> right. What's relevant about () compared to a monadic StreamTransf X?
10:49:48 <gFunk> as you've explained it, sounds like comonads would be better for parsing than monads
10:50:01 <ski> i was just wondering how you would define such a monadic version of it ..
10:50:39 <Philippa_> it doesn't seem to me to be much different to state transformer monads, though I understand there're leak issues
10:50:50 <ski> gFunk : hm .. i think they possibly aren't .. i'd love to see otherwise, though
10:50:58 <gFunk> what's the difference between "deconstructing text" and "constructing and AST from text"?
10:51:07 <gFunk> *an
10:51:33 <ski> newtype StreamTransf a b = ST ([a] -> [b])
10:51:49 <Philippa_> gFunk: I don't know about better. Equivalent I can see
10:52:32 <Philippa_> ski: ah, d'oh, of course. Though that's kind of the other [] monad
10:52:44 <ski> hm, how would one structure the text as a comonad from where the AST can be extracted ?
10:52:54 <Philippa_> is it ArrowApply? If so, feel free to substitute away until you have the equivalent >>= and return
10:53:25 <ski> Philippa_ : istr it wasn't 'ArrowApply' (at least not obviosuly)
10:53:29 <gFunk> ski: no idea
10:53:45 <ski> Philippa_ : by 'the other [] monad', i assume you mean the stream monad ?
10:53:57 <Philippa_> or something related, yeah
10:54:02 <gFunk> as i recall, EHC uses just pure functions for all its parsing, so maybe all this category theory is totally overcomplicating things
10:54:16 <ski> extract :: Comonad w => w a -> a
10:54:25 <Philippa_> anyway, if there isn't an ArrowApply instance then my comment doesn't apply
10:54:30 <Philippa_> not per se
10:54:38 <ski> i'm wondering if we structure the text as 'w a' in some way, would 'a' be the AST that we could extract, then ?
10:54:40 <dolio> Monads can be built of pure functions.
10:54:41 <Philippa_> (and you just get [()] or repeat () anyway)
10:55:00 <dolio> More or less.
10:55:04 <Philippa_> gFunk: maybe that attitude's ignoring the possibility it's just plain useful?
10:55:04 <gFunk> ski: yes, that's what i'm thinking
10:55:19 <ski> (Philippa_ : elaborate that ?)
10:55:30 <ski> hm
10:55:30 <Philippa_> ski: which "that"?
10:55:33 <vincenz> (please use haskell not scheme in this channel)
10:55:43 <ski> Philippa_ : "and you just get [()] or repeat () anyway"
10:55:56 <Philippa_> as the initial input
10:56:17 <Philippa_> perhaps the former if you're allowing finite streams, the latter otherwise
10:56:21 <ski> hm
10:56:37 <gFunk> Philippa: it just seems like we're trying to fit problems into categories, rather than recognizing that certain problems are members of categories in the end
10:56:49 <ski> how would you transform 'StreamTransfAr a b' into 'a -> StreamTransfM b', in general, though ?
10:57:15 <Philippa_> ski: if there's no arrowApply instance? You wouldn't be able to necessarily
10:57:37 <Philippa_> gFunk: it's trying on ways of looking at problems to see if they offer us additional tools we might not've realised we had otherwise
10:57:41 <ski> (then i don't see how there could be a corresponding monad)
10:58:03 <Philippa_> yes, the (possibility of an) ArrowApply instance is a condition for that
10:58:41 <Philippa_> gFunk: IME, monadic parsing works extremely well and is a very natural fit
10:59:08 * ski agrees
10:59:22 <Philippa_> give or take clunkiness involving (), arrow-based parsing can be similarly so (which's appropriate depends on the balance of parsing power and analytical power you want)
10:59:52 <glguy> From the Hughes Arrow lecture slides: "But whereas monadic computations are parameterised
10:59:56 <glguy> over the type of their output, but not their input, arrow computations are parameterised
10:59:59 <glguy> over both.
11:00:02 <glguy> I think that someone might have mentioned this already when I asked
11:00:03 <ski> yes
11:00:17 <glguy> but it didn't really "hit" me until now
11:00:20 <ski> which means that you can analyze "transformations" statically
11:01:19 * ski is wondering if one could make some syntax for arrows somewhat akin to "internal language" (e.g. in topos)
11:01:46 <ski> (i'm not convinced using "do"-notation is so natural for arrows ..)
11:01:57 <Philippa_> I think it depends on the arrow, but I agree for many
11:02:05 <Philippa_> I've not met internal language directly, I need to read up on more CT
11:02:06 <gFunk> ski: what would be better?
11:02:22 <ski> gFunk : i'm not sure :)
11:02:46 * ski doesn't know a lot about it either .. but it's an idea i mean to explore
11:02:58 <gFunk> ski: I find the do-notation for arrows to be very similar to drawing a flow chart
11:03:03 <dolio> Perhaps Haskell could adopt a 2D-inspired syntax for arrows. :)
11:03:39 <vincenz> dolio: like in icfpc
11:05:06 <Renkin> What props do I need to set for a line in wxHaskell to make it visible?
11:05:35 <Renkin> I think the problem I have is that the line simply isn't visible, but I'm not sure
11:07:00 <Renkin> line dc pt1 pt2 [???]
11:07:22 <Renkin> brushColor := black didn't help
11:08:09 <Syzygy-> > length $ show 18446744073709551616
11:08:10 <lambdabot>  20
11:09:39 <glguy> fmap (+1) . (elemIndex 0) . iterate (`div` 10) $ 18446744073709551616
11:09:41 <glguy> > fmap (+1) . (elemIndex 0) . iterate (`div` 10) $ 18446744073709551616
11:09:43 <lambdabot>  Just 21
11:09:48 <glguy> oops
11:09:56 <glguy> >  (elemIndex 0) . iterate (`div` 10) $ 18446744073709551616
11:09:57 <lambdabot>  Just 20
11:10:32 <Syzygy-> And now for 340282366920938463463374607431768211456
11:10:42 <vincenz> > 2^ 128
11:10:45 <lambdabot>  340282366920938463463374607431768211456
11:10:48 <Syzygy-> > (elemIndex 0) . iterate (`div`10) 340282366920938463463374607431768211456
11:10:49 <lambdabot>    Expecting a function type, but found `[a]'
11:10:50 <lambdabot>    Expected type: a1 -> [a...
11:11:00 <glguy> missing $
11:11:06 <vincenz> > (elemIndex 0) . iterate (`div`10) $ 2^128
11:11:07 <Syzygy-> > (elemIndex 0) . iterate (`div`10)$ 340282366920938463463374607431768211456
11:11:08 <lambdabot>  Just 39
11:11:09 <lambdabot>  Just 39
11:11:13 <vincenz> > (elemIndex 0) . iterate (`div`10) $ 2^256
11:11:15 <lambdabot>  Just 78
11:11:22 <Syzygy-> vincenz: Please tell me you don't recognize 2-powers that high on sight.
11:11:52 <vincenz> Syzygy-: I recognized 64, so I figured, the next one must be 128
11:11:58 <vincenz> hence I tested and foud out I'm right
11:12:13 <vincenz> it's called extrapolation
11:12:21 <Syzygy-> Hehe
11:12:21 <Renkin> Heheh, recognized 64
11:12:34 <Syzygy-> But it's still scary that you recognize 2^64 on sight.
11:12:43 <dolio> Agreed.
11:13:15 <glguy> Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
11:13:18 <glguy> /scary/
11:13:41 <gFunk> is there an arrow operator like: (a,b) =>- c
11:13:45 <Renkin> What would that person look like? :)
11:13:50 <dolio> Are you sure you have enough pocket protectors?
11:13:50 <gFunk> that's the same as   a &&& b >>> c
11:13:50 <vincenz> no it's not
11:13:54 <vincenz> I know it starts with 18 something
11:14:07 <vincenz> and it's gotta be in that range
11:14:14 <vincenz> 2^x ~= 10^(x/3)
11:14:15 <Syzygy-> > 2^1024
11:14:16 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
11:14:23 <Syzygy-> Not 18 something. :P
11:14:31 <Syzygy-> > length $ show 2^1024
11:14:32 <lambdabot>  add an instance declaration for (Num String)
11:14:37 <vincenz> Syzygy-: I meant 2^64
11:14:38 <Syzygy-> > length $ show (2^1024)
11:14:40 <lambdabot>  309
11:15:17 <glguy> > iterate (join (^)) 2
11:15:21 <lambdabot> Terminated
11:15:25 <glguy> )-:
11:15:32 <dolio> > length . show $ 10 ^ 10 ^ 100
11:15:37 <lambdabot> Terminated
11:15:42 <Syzygy-> dolio: That's just cruel
11:16:05 <glguy> > take 4 $ iterate (join (^)) 2
11:16:06 <ski> gFunk : well, maybe that is not so bad .. but when the translation uses some kind of "bind" analogue for arrows, i get a bit suspicious ..
11:16:07 <dolio> Lambdabot can't handle googolplexes?
11:16:07 <lambdabot>  [2,4,256,3231700607131100730071487668866995196044410266971548403213034542752...
11:16:50 <glguy> > map (length . show) $ take 4 $ iterate (join (^)) 2
11:16:51 <lambdabot>  [1,1,3,617]
11:18:33 <glguy> speaking of exponents, I'm tired of people on the news saying things like "The prices are increasing exponentially"
11:18:39 <vincenz> > iterate (^2) 1
11:18:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:18:47 <vincenz> > iterate (^2) 2
11:18:49 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
11:19:07 <dolio> Do you prefer "geometrically"?
11:19:09 <ski> > let zap = zipWith ($) in  repeat replicate `zap` [0,1,2,3] `zap` "abcdef"
11:19:10 <lambdabot>  ["","b","cc","ddd"]
11:19:16 <vincenz> 1 bit, 2 bit, 4 bit, 8 bit, 16 bit..
11:19:19 <glguy> dolio: I prefer the correct term
11:19:24 <vincenz> glguy: memorize that list
11:19:26 <vincenz> > iterate (^2) 2
11:19:28 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
11:19:43 <vincenz> > drop 10 $ iterate (^2) 2
11:19:45 <lambdabot>  [179769313486231590772930519078902473361797697894230657273430081157732675805...
11:19:50 <vincenz> > drop 100 $ iterate (^2) 2
11:19:55 <lambdabot> Terminated
11:20:27 <Syzygy-> Hey......... I just realized.
11:20:37 <vincenz> No you didn't
11:20:51 <Syzygy-> Derived categories probably gets easier to explain/understand/grok if you have the Arrow concept well lodged in your mind.
11:21:05 <ski> (or vice versa)
11:21:09 <glguy> I was just happy when I recognized 2584 as a fibonaci number on sight
11:21:19 <Syzygy-> glguy: 1729.
11:21:26 <pkhuong> prime?
11:21:30 <vincenz> I wonder how they print long nums in base 10
11:21:39 <glguy> Syzygy-: probably not
11:21:54 <Syzygy-> Not fibonacci. But holds a place in mathematics history anyway.
11:22:16 <tibbe_> let vincez = \x -> head . x, is = fromJust, scary = Just ["yes"] in vincez is scary
11:22:19 <tibbe_> > let vincez = \x -> head . x, is = fromJust, scary = Just ["yes"] in vincez is scary
11:22:19 <lambdabot>  Parse error
11:22:23 <tibbe_> bah!
11:22:30 <tibbe_> work with me here lambdabot!
11:22:31 <tibbe_> ;)
11:22:42 <ski> s/,/;/
11:22:57 <tibbe_> > let vincez = \x -> head . x; is = fromJust; scary = Just ["yes"] in vincez is scary
11:22:58 <glguy> > [x | x <- [2..40], 1729 `mod` x == 0]
11:22:58 <lambdabot>  "yes"
11:23:00 <lambdabot>  [7,13,19]
11:23:00 <vincenz> > let {vincenz = \x -> head . x; is = fromJust; scary = Just ["yes"]} in vincenz is scary
11:23:02 <lambdabot>  "yes"
11:23:03 <vincenz> Why am I scary
11:23:12 <dolio> How who prints long nums?
11:23:13 <tibbe_> > 2^64
11:23:14 <lambdabot>  18446744073709551616
11:23:20 <Syzygy-> Because you recognize high powers of 2 on sight.
11:23:24 <vincenz> lol
11:23:29 <vincenz> only the 64 one
11:23:36 <vincenz> never read that fable about the rice on a chess board?
11:23:40 <vincenz> when I read it, I calculated how much
11:23:43 <Syzygy-> Well, yeah...
11:23:56 <vincenz> and it's one less than that number.  I don't know the exact digits, but how many numbers are "interesting" that look more or less like that
11:23:57 <Syzygy-> I did too. I only didn't bother memorizing the amoutn.
11:23:58 <tibbe_> perhaps I could write that using intercalate, fromJust, head and bikeshed, hmmm
11:24:13 <vincenz> Syzygy-: I mean if you had written another number with a few digits more or less, I wouldn't have noticed
11:24:15 <Syzygy-> And I did it quite a while ago...
11:24:16 <ski> 'intercalate' ?
11:24:20 <Syzygy-> vincenz: Hehe
11:24:29 <vincenz> it's just the 184 prefix and the length
11:24:32 <Syzygy-> Ooooooik. I've seen intercalate. WTF is bikeshed??
11:24:32 <vincenz> (give or take)
11:24:51 <Syzygy-> 184000000000000000 would fool you? :)
11:24:51 <tibbe_> bikeshed is a very special function...
11:24:54 <vincenz> > intercalate f g = \x y -> f x `g` f y
11:24:55 <lambdabot>  Parse error
11:24:58 <vincenz> Syzygy-: obviously not
11:25:11 <tibbe_> it's an infinite generator
11:25:16 <dolio> ?google bikeshed argument
11:25:24 <lambdabot> http://www.unixguide.net/freebsd/faq/16.19.shtml
11:25:24 <lambdabot> Title: Why should I care what color the bikeshed is?
11:25:36 <Syzygy-> > let intercalate f g = \x y -> f x `g` f y in intercalate (+1) (*) $ 3 5
11:25:37 <lambdabot>  add an instance declaration for (Num (t -> a))
11:25:38 <eviltwin_b> or just subscribe to freebsd-current for a wek, you're sure to encounter ta least one :>
11:25:49 <vincenz> Syzygy-: errm, duh?
11:26:06 <vincenz> > let intercalate f g = \x y -> f x `g` f y in intercalate (+1) (*) 4 5
11:26:08 <lambdabot>  30
11:26:11 <Syzygy-> vincenz: Can't blame me for trying?
11:26:18 <vincenz> Syzygy-: with the $
11:26:21 <Syzygy-> Hmmm.... My $ was highly misplaced, was it?
11:26:23 <vincenz> you're forcing the parsing of (3 5)
11:26:28 <Syzygy-> Ah.
11:26:29 <Syzygy-> Right.
11:26:33 <ndm> @seen dcoutts
11:26:34 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 5h 43m ago.
11:26:42 <vincenz> once you know the pattern, it's quite aesily recognizeable
11:26:47 <vincenz> ndm: yhc gpl'd?
11:26:59 <ndm> vincenz: mainly, yes
11:27:01 <vincenz> ndm: after seeing your javascript backend, I was thinking a scheme backend :)
11:27:19 <ndm> vincenz: do you want it gpl'd, or not?
11:27:36 <vincenz> ndm: I dunno
11:27:40 <vincenz> I want a lot of things
11:27:53 <pkhuong> ndm: bsd? :)
11:27:55 <ndm> vincenz: the back end is entirely separate from the compiler, so you could pick a different license - we've been doing libraries as BSD, the core as GPL, but we're not overly fussy
11:28:07 * vincenz nods
11:28:11 <vincenz> but, it's free :)
11:28:31 <Syzygy-> Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
11:28:41 <ndm> vincenz: essentially yes, free, but we'd rather people were happy and carefree rather than worried overly abotu licenses
11:28:55 <ski> @arrow
11:28:56 <lambdabot> Aye Aye Cap'n
11:28:56 <vincenz> ndm: No I know, it was mostly about "if I do omething, can I get sued"
11:28:57 <ndm> vincenz: we'd certainly welcome a scheme back end
11:29:05 <vincenz> ndm: I couldn't care less about licensing for the rest
11:29:30 <ndm> vincenz: indeed, write whatever you want, no one is going to sue you, unless you make a pile of money off someone elses work, in which case we'd appreciate a cut ;)
11:29:32 <dolio> Because they decided on "arr" instead of "pure"?
11:30:08 <durdn> Hi, can I fire my silly newbie question of the day ?
11:30:15 <ski> sure
11:30:16 <durdn> HStats> :t liftM head $ load "test.txt"
11:30:17 <durdn> liftM head $ load "test.txt" :: IO Entry
11:30:26 <durdn> now the question is
11:30:33 <durdn> how do I print this thing ?
11:30:40 <durdn> already have a function that prints an Entry
11:30:41 <integral> durdn: >>= print ?
11:30:47 <durdn> but not an IO Entry
11:30:57 <ski> print =<< liftM head (load "test.txt")
11:30:59 <ski> e.g.
11:31:00 <integral> durdn: you need to use >>= or the equivalent in the do notation
11:31:09 <durdn> perfect! let me try
11:31:26 <ski> or
11:31:27 <ski> print . head =<< load "test,txt"
11:31:49 <durdn> do I need anything special to use =<< ?
11:31:56 <durdn> HStats> print . head =<< liftM head $ load "test.txt"
11:31:56 <durdn> ERROR - Type error in application
11:31:56 <durdn> *** Expression     : print . head =<< liftM head
11:31:56 <durdn> *** Term           : print . head
11:31:56 <durdn> *** Type           : [d] -> IO ()
11:31:56 <glguy> ?type (|||)
11:31:57 <durdn> *** Does not match : a b -> a [b] -> c
11:32:01 <lambdabot> forall (a :: * -> * -> *) d c b. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
11:32:14 <dolio> ?index (=<<)
11:32:14 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:32:44 <ski> durdn : note i removed the 'liftM head', when i added the '. head' instead
11:32:52 <durdn> :) oops
11:33:37 <durdn> now I get something else :(
11:33:43 <durdn> HStats> ps . head =<< load "test.txt"
11:33:43 <durdn> Program error: Prelude.read: no parse
11:33:57 <durdn> where ps was my print function
11:34:05 <durdn> cause print did not work either
11:34:15 <ski> so 'load "test.txt"' monadically returns an empty list ..
11:34:23 <durdn> ah
11:34:35 <ski> hrm
11:34:36 <durdn> so maybe it's not reading anything after all
11:34:40 <durdn> that might explain it
11:34:49 <ski> um, i think i misread
11:35:00 <durdn> infact if I do: HStats> liftM ps $ liftM head $ load "test.txt"
11:35:07 <durdn> i get an empty line
11:35:13 <glguy> ?type (&&&)
11:35:14 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:35:19 <ski> yes, you use 'read' somewhere in 'ps', yes ?
11:35:37 <ski> and something can't be parsed correctly at some point ..
11:35:55 <durdn> ski: err ... no
11:35:57 <durdn> ps s@(Session a b c d e) = putStrLn ((date s) ++ " " ++
11:35:58 <durdn>                  (site s) ++ " " ++
11:35:58 <durdn>         show (duration s) ++ " " ++
11:35:58 <durdn>         show (balance s))
11:36:02 <mentomorph> Hi! Is it possible to match on function names?
11:36:14 <mentomorph> I have a list of functions..
11:36:36 <integral> mentomorph: functions don't have names... (...)
11:37:11 <ski> mentomorph : you can match functions into a name, so you can use that name to refer to the function yes .. but you can't check if the function is a particular function if that was what you were asking ..
11:37:20 <ski> durdn : hm
11:37:23 <ski> (if you want to be able to catch parse errors, use something like 'reads', instead ..)
11:37:30 <integral> (-| Not ((a->b)->String))
11:37:50 <durdn> ski: ok, will have a look at reads
11:38:08 <ski> (durdn : btw   liftM ps $ liftM head $ load "test.txt"  =  liftM (ps . head) $ load "test.txt"  )
11:38:09 <araujo> Hello!
11:38:16 <mentomorph> ski: ok. what u mean is kinda type newName = myFuncion right ?
11:38:25 <ski> durdn : @type load
11:38:38 <durdn> ski: that's way more elegant! my haskell is in so early stage that I am struggling :)
11:38:40 <mentomorph> darn
11:38:50 <durdn> HStats> :t load
11:38:50 <durdn> load :: String -> IO Diary
11:39:12 <ski> ok .. hm, then possibly the parse error occurs inside 'load' ?
11:39:16 <durdn> type Diary = [Entry]
11:39:29 <Baughn> Say, does lambdabot not work wit ghc 6.6?  (Pipes keep breaking, and it's a real mess on the floor)
11:39:34 <durdn> ski: yep it is likely ...
11:39:37 <ski> mentomorph : i'm not sure what you mean
11:39:54 <ski> mentomorph : you could do things like
11:40:15 <ski> foobar f (x,y) = (f x,f (f y))
11:40:58 <ski> so, if you pass a function as first argument to 'foobar', then that will be matched against the name 'f', and then inside 'foobar' you can use 'f' to refer to whatever function was passed in
11:41:22 <durdn> ski: now I understand it's not me that don't understand the IO monad, its me that don't understand why parsing the file fails ;)
11:41:28 <vincenz> @pl foobar f (x,y) = (f x,f (f y))
11:41:30 <lambdabot> foobar = (`ap` snd) . (. fst) . liftM2 flip (((.) . (,)) .) (join (.))
11:41:39 <ski> > let  foobar f (x,y) = (f x,f (f y)) ; square n = n * n in  foobar square (4,3)
11:41:40 <lambdabot>  (16,81)
11:41:51 <mentomorph> seems like a try.. thx!
11:41:56 <vincenz> @pl foobar f (x,y) = (f x,join f y))
11:41:58 <lambdabot> (line 1, column 32):
11:41:58 <lambdabot> unexpected ")"
11:41:58 <lambdabot> expecting variable, "(", operator or end of input
11:42:00 <vincenz> @pl foobar f (x,y) = (f x,join f y)
11:42:02 <lambdabot> foobar = (`ap` snd) . (. fst) . liftM2 flip (((.) . (,)) .) join
11:42:18 <ski> (mentomorph : i'm still not sure if this was what you was asking about, though ..)
11:42:18 <vincenz> @pl \f -> f *** join f
11:42:19 <lambdabot> ap (***) join
11:42:22 <vincenz> :)
11:42:26 <vincenz> @type ap (***) join
11:42:28 <lambdabot> forall (a :: * -> * -> *) b a1. (Arrow a, Monad (a b)) => a b (a b a1) -> a (b, b) (a b a1, a1)
11:42:56 <ski> > ((***) `ap` join) (\n -> n * n) (4,3)
11:42:57 <lambdabot>    Occurs check: cannot construct the infinite type: b = b -> a
11:42:58 <lambdabot>    Expec...
11:43:17 <vincenz> whoops
11:43:19 <vincenz> it's not join!
11:43:36 <ski> well
11:43:41 <mentomorph> I have a list [foo1, foo2, etc] and then I want to break the list in two when I see foo2.
11:43:43 <vincenz> @pl \f -> f *** (f.f)
11:43:44 <ski> maybe you were thinking of
11:43:45 <lambdabot> ap (***) (join (.))
11:43:47 <ski> join f x = f x x
11:43:50 <durdn> ski: thanks a lot for now I'll try to debug my loading function
11:44:01 <vincenz> > ap (***) (join(.)) (\x -> x + x) (4,3)
11:44:03 <lambdabot>  (8,12)
11:44:11 <ski> mentomorph : and is 'foo2' some function that you have already defined before ?
11:44:13 <vincenz> kinky
11:44:21 <vincenz> @type ap (***) (join(.))
11:44:22 <Pete_I> @type ap
11:44:23 <lambdabot> forall b'. (b' -> b') -> (b', b') -> (b', b')
11:44:24 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
11:44:25 <mentomorph> yes
11:44:36 * ski likes infix `ap` better
11:44:37 <mentomorph> all functions do different things.
11:45:49 <ski> mentomorph : ok .. then you should know that if you pattern-match on '[foo1, foo2, etc]', then whatever the first element of the list is, 'foo1' will now be a local name for that (over-shadowing the previous definition) .. so you can't use this to check whether the first element is the 'foo1' function you have defined earlier
11:46:20 <ski> (or shorter, you can't (in general) compare functions for equality)
11:46:34 <mentomorph> thanks a lot man
11:46:36 <vincenz> dinner time!
11:46:47 <ski> mentomorph : np
11:51:52 <glguy> > take 10 $ fix ((1:) . (1:) . (zipWith (+) `ap` tail))
11:51:54 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
11:52:51 <Jaak> neat
11:53:12 <desrt> therp; λ is usually the symbol used to represent an eigenvalue
11:53:43 <desrt> eg: Ax = λx for eigenvalue λ and eigenvector x of A
11:53:51 <desrt> *and corresponding eigenvector
11:54:12 <vincenz> just a symbol
11:54:26 <vincenz> it could be FooBar
11:54:28 <vincenz> for all you care
11:54:30 <desrt> but some symbols see use for certain things quite frequently
11:54:51 <desrt> λ is all over the place... eigenvalues, distribution tuning parameters, half-life, wavelength
11:54:58 <vincenz> yes, it's called the greek alphabet
11:55:02 <glguy> half-life 2
11:55:09 <desrt> λ++
11:55:26 <vincenz> in fact in greek, they use a lot of symbols!
11:55:33 <vincenz> but thinking about it, OMG! in english too
11:55:39 <vincenz> :P
11:55:42 <desrt> ...
11:55:43 <vincenz> </troll>
11:56:27 <vincenz> anyways, delta is popular too, as is epsilon
11:56:39 <vincenz> and gamma is more current than lambda in statistics (distributions)
11:56:57 <vincenz> mu ... ro ...
11:56:59 <desrt> afaik, delta is only used to mean 'difference' (including upsidedown delta for graident)
11:57:20 <desrt> and epsilon has two meanings: the empty character and something very small
11:57:45 <desrt> i shouldn't say "meaning" so much as "commonly used for..."
11:57:47 <vincenz> desrt: it is your attitude that leads to the priorization of lambda
11:58:02 <desrt> damn straight it is.
11:58:06 <desrt> lambda is awesome
11:58:08 <desrt> lambda is the ultimate
11:58:16 * vincenz is going to start a countermovement
11:58:16 <glguy> the ultimate what??
11:58:24 <ski> glguy : imperative
11:58:26 <vincenz> mu!
11:58:35 <vincenz> ski: no it's functional
11:58:36 <desrt> µ?
11:58:42 <vincenz> desrt: yes
11:59:04 <glguy> vincenz: bring back the Ψ
11:59:09 <glguy> it doesn't get enough exposure
11:59:13 <Binkley> vincenz, what is your movement going to promote instead of lambda?
11:59:15 <Jaak> fork!
11:59:20 <desrt> psi is lame
11:59:25 <desrt> psi is what you use when phi is already taken
11:59:37 <desrt> otherwise it has no purpose :)
11:59:43 <vincenz> (define-syntax mu (syntax-rules () (mu . a) (lambda .a)))
11:59:44 <ski> vincenz : http://citeseer.ist.psu.edu/context/83048/0
11:59:56 <glguy> Η is a classy greek-letter, you could bring it back into the norm
12:00:16 <vincenz> ski: Hah, that's just lambdaganda
12:00:20 <Binkley> so, guys, I'm building a bikeshed... what color should I paint it?
12:00:27 <vincenz> Binkley: transparent
12:00:35 <glguy> Binkley: Psi-blue
12:00:35 <vincenz> What is a bikeshed anyways
12:00:35 * ski remembers onw time he accidentally wrote 'syntax-rulez' ..
12:00:36 <Binkley> lolz
12:00:43 <Binkley> vincenz: it's a shed to put your bikes in
12:00:46 <Binkley> don't you speak english?
12:00:49 <vincenz> Binkley: no seriously
12:00:51 <glguy> ΐ
12:00:53 <vincenz> what's with bikesheds as of late
12:00:58 <Botje> Binkley: octarine!
12:01:02 <Binkley> vincenz: it's from a phil wadler blog post
12:01:05 <Binkley> or actually a post he linked to
12:01:10 <glguy> vincenz: Google should know
12:01:12 <vincenz> Binkley: link?
12:01:21 <vincenz> glguy: it makes no sense, it's a one paragraph article that says little
12:01:22 <glguy> ?google bikeshed color
12:01:23 <Binkley> @google phil wadler bike shed
12:01:25 <lambdabot> http://www.wechange.org/fighting_spam_at_the_source_and_the_color_of_the_bikeshed
12:01:25 <lambdabot> Title: a bikeshed color problem | www. We Change .org
12:01:27 <lambdabot> http://wadler.blogspot.com/2006/01/bikeshed-coloring.html
12:01:27 <lambdabot> Title: Wadler's Blog: Bikeshed coloring
12:01:31 <Binkley> yeah, that second one
12:01:33 * earthy laughs
12:01:41 <ski> vincenz : for the counter-movement, you could take 'gamma' for continuation abstraction ..
12:01:45 <vincenz> come on, it's meaningless
12:01:51 <vincenz> ski: why gamma?
12:01:53 <vincenz> I know!
12:02:39 <ski> vincenz : some paper used that ..
12:02:50 <ski> (dunno why)
12:03:08 <vincenz> I know the perfect character, but I can't find it
12:03:21 <desrt> Said to signify unity under oppression, explaining its use in the video game Half-Life
12:03:22 <glguy> There are some neat Cyrillic character that could be useful in avoidign the overcrowded greek-alphabet-space ;)
12:03:25 <desrt> ^^ lowercase lambda
12:03:39 <glguy> Ж Щ Њ Љ could all be fun )
12:03:45 <vincenz> There's this one unicode character that looks like a falling star!
12:03:53 <desrt> vincenz; let's see
12:03:59 <vincenz> can't find it
12:04:11 <pkhuong> glguy: or chinese ideograms.
12:04:21 <glguy> pkhuong: that, sir, is too bold
12:04:45 <glguy> no more lambda‽
12:05:02 <vincenz> how do I get a list of all the unicode chars
12:05:04 <ski> one could use an upside-down (upper case) omega ..
12:05:19 <dolio> I look forward to the day when I construct my programs by copying from a text file with a list of "<symbol> : explanation".
12:05:21 <pkhuong> glguy: i've been meaning to quiz my gf about that ;)
12:05:33 <pkhuong> dolio: just grab your APL manual!
12:06:03 <dolio> Maybe I should try installing scim again, although last time I did, it caused programs to crash randomly.
12:07:06 <vincenz> 嫖
12:07:34 <dolio> You're right. That just cries out "continuation".
12:07:38 <vincenz> Binkley: to be honest, I don't get the bikeshed post, it's really short and rather devoid of interesting information
12:07:43 <vincenz> dolio: that ain't it
12:07:49 <dolio> :)
12:07:58 <Binkley> vincenz: the point is that people have the biggest arguments over the silliest details
12:08:07 <Binkley> it's a way of telling people not to sweat the small stuff
12:10:14 <glguy> vincenz: was that last unicode character you pasted supposed to  be a dotted box?
12:10:36 <glguy> vincenz: and a double-wide one at that?
12:10:42 <dolio> It should be a Chinese (I think) character.
12:11:41 <vincenz> no, I'm looking for the character
12:11:44 <vincenz> it was on reddit a while ago
12:11:45 <vincenz> can't find it
12:11:58 <vincenz> anyone know a good way to enumerate all unicode chars?
12:12:28 <glguy> all multiple 100,000s of them?
12:12:42 <vincenz> erm yeah
12:13:11 <glguy> linux?
12:13:14 <vincenz> yeah
12:13:29 <glguy> you could uset he gnome font vieer to look at '-*-fixed-medium-*-*-*-15-*-*-*-*-*-iso10646-*'
12:13:38 <glguy> it's got most of the characters
12:13:44 <vincenz> but how do I get them on screen
12:14:00 <glguy> screen the application at version 4.0.3?
12:14:05 <glguy> or your monitor?
12:14:29 <vincenz> No, as in, how do I print them out.
12:14:36 <vincenz> I guess I'll just do a haskell thingy and print to file
12:15:00 <dblhelix> @yow
12:15:01 <lambdabot> hubub, hubub, HUBUB, hubub, hubub, hubub, HUBUB, hubub, hubub, hubub.
12:15:19 <vincenz> > iterate (take 80) [1..10]
12:15:21 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3...
12:15:35 <vincenz> > iterate (take 3) [1..10]
12:15:37 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2...
12:15:54 <vincenz> > map take 2 $ iterate (drop 2) [1..10]
12:15:55 <lambdabot>    Expecting a function type, but found `[b]'
12:15:56 <lambdabot>    Expected type: a -> b
12:15:56 <lambdabot>  ...
12:16:00 <Baughn> @type iterate
12:16:02 <lambdabot> forall a. (a -> a) -> a -> [a]
12:16:05 <vincenz> > map (take 2) $ iterate (drop 2) [1..10]
12:16:07 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
12:16:22 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just .splitAt 2)) [1..10]
12:16:23 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
12:16:35 <desrt> drop has a perverse but occasionally useful definition
12:17:17 <vincenz> dam
12:17:27 <desrt> > tail []
12:17:28 <vincenz> > length ([minBound..maxBound]::[Char])
12:17:29 <lambdabot>  Add a type signature
12:17:30 <lambdabot>  1114112
12:17:41 <desrt> > tail ([] :: [Int])
12:17:43 <lambdabot>  Exception: Prelude.tail: empty list
12:17:47 <desrt> as it should be.
12:17:52 <vincenz> odd
12:17:53 <desrt> > drop 1 ([] :: [Int])
12:17:54 <vincenz> it keeps goind
12:17:55 <lambdabot>  []
12:17:58 <desrt> ^ wtf?
12:18:19 <desrt> vincenz; Char is unicode characters
12:18:42 <vincenz> > map (take 2) $ iterate (drop 2) [1..10]
12:18:44 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
12:18:45 <vincenz> > map (take 2) $ iterate (drop 2) $ [1..10]
12:18:48 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
12:18:48 <vincenz> aha
12:18:50 <glguy> > unfoldr (\x -> (guard.not.null) x >> return.splitAt 2 x) [1..10]
12:18:51 <lambdabot>    Expecting a function type, but found `([a], [a])'
12:18:52 <lambdabot>    Expected type: a...
12:19:11 <vincenz> > takeWhile (not . null) . map (take 2)  iterate (drop 2) $ [1..10]
12:19:12 <lambdabot>    The function `map' is applied to three arguments,
12:19:12 <lambdabot>   but its type `(a -...
12:19:13 <vincenz> > takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1..10]
12:19:16 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
12:19:35 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just .splitAt 2)) [1..10] -- oh well, I'd say stick with this one :)
12:19:45 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
12:20:29 <Baughn> Lambdabot keeps throwing me "hClose: Resource vanished" messages when I try to evaluate things (using GHC 6.6). Is this my fault?
12:20:48 <glguy> I didn't know you could run lambdabot on 6.6 yet
12:20:57 <Baughn> That would explain it
12:21:02 <glguy> ?version
12:21:03 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
12:21:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:21:11 <glguy> I don't think that hs-plugins runs on 6.6 yet
12:21:43 <vincenz> hmm
12:21:51 <vincenz> it won't show the unicode properly
12:24:58 <vincenz> > drop 1000 $ ([minBound .. maxBound] :: [Char])
12:25:00 <lambdabot>  "\1000\1001\1002\1003\1004\1005\1006\1007\1008\1009\1010\1011\1012\1013\1014...
12:26:52 <vincenz> Woot, I found it!
12:26:54 <vincenz> ☄
12:27:03 <vincenz> copy paste that in vim and change your fontsize
12:27:14 <vincenz> http://jp-larocque.livejournal.com/30238.html
12:27:18 <lambdabot> Title: jp_larocque: U+2604 (Name: COMET; Subblock: Weather and astrological symbols), 1 ...
12:27:50 <vincenz> heh, the version in my font looks even nicer than the version they put in the screen-dump
12:28:51 <vincenz> > let x ☄ y = x + y in 1 ☄ 2
12:28:52 <lambdabot>  Illegal character ''\152''
12:29:02 <vincenz> > let  ☄ x y = x + y in ☄ 2 2
12:29:04 <lambdabot>  Illegal character ''\152''
12:29:16 <vincenz> > ord '☄'
12:29:17 <lambdabot>  Improperly terminated character constant
12:29:30 <vincenz> > ord '\☄'
12:29:32 <lambdabot>  Illegal escape sequence
12:29:37 <vincenz> blegh
12:31:56 * shapr boings
12:32:27 * vincenz throws shapr a ☄
12:32:27 <eviltwin_b> heh.  I can't even paste it
12:32:38 <vincenz> looks like a falling comet
12:32:41 <vincenz> with a tail of small particles
12:32:50 <vincenz> the one on screenshot only has plain lines as tails
12:33:30 <glguy> I need to make an "AskReddit" for "What metal disorder does qwe1234 have?"
12:33:35 <glguy> mental*
12:34:17 <vincenz> for your viewing pleasure: http://img518.imageshack.us/my.php?image=screenshotjo2.png
12:34:19 <glguy> but I don't want to give him the honor.
12:34:24 <lambdabot> Title: ImageShack - Hosting :: screenshotjo2.png, http://tinyurl.com/yzpsjd
12:34:54 <pkhuong> vincenz: neat. I wonder if I can type that in emacs :)
12:35:11 <vincenz> that's one detailed character
12:35:22 <eviltwin_b> yay gucharmap :>
12:36:06 <Botje> slightly OT: how do you insert wide chars in xterm by their hex codes?
12:36:09 <xerox> vincenz: name!
12:36:14 <vincenz> xerox: ?
12:36:57 <xerox> ✬
12:37:04 <xerox> hm
12:38:00 <xerox> how is tat called?
12:38:14 <Zr40> "Black Centre White Star"
12:38:34 <xerox> ✬
12:38:36 <xerox> this one?
12:39:03 <Zr40> I can't actually see them in this font, but if it's the same as ✬, then it is
12:39:14 <xerox> hehe I can't even.
12:39:31 <vincenz> same one, yes
12:39:36 * vincenz has a good irssi and screen
12:39:55 <xerox> type it here
12:40:13 <vincenz> ✬
12:40:35 <xerox> uhm
12:40:47 <xerox> that is not the one you did in green in the shot
12:40:52 <vincenz> o
12:40:56 <vincenz>  ☄
12:41:08 <xerox> cool
12:41:20 <xerox> COMET.
12:41:22 <vincenz> :)
12:41:24 <Zr40> ☄? That's a "Comet"
12:41:36 <xerox> ☍
12:41:40 <xerox> OPPOSITION :)
12:41:50 <vincenz> ooh nice
12:41:53 <xerox> yess.
12:42:02 <xerox> ☃
12:42:09 <xerox> is there SNOWBALL?
12:42:10 <xerox> :P
12:42:22 <vincenz> WOAH, that thing is detailed when enlarged
12:42:25 <vincenz> with tiny stars
12:42:26 <xerox> ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄
12:42:34 <Zr40> ☃ <-- snowman :)
12:42:45 <vincenz> Zr40: yeah it looks very nice in big
12:42:50 <vincenz> with lots of tiny snowflakes around it
12:42:52 <pkhuong> vincenz: making a list of identifier-esque unicode characters?
12:42:57 <xerox> Ⓐ
12:42:58 <xerox> (;
12:43:10 <vincenz> xerox: that one doesn't render for me
12:43:18 <xerox> CIRCLED LATIN CAPITAL LETTER A
12:43:24 <vincenz> Oh, anarchy
12:43:37 <xerox> it's in the topic of #ideologies
12:43:49 <vincenz> yeah doesn't render in the latest font
12:43:50 <earthy> ;)
12:43:58 <vincenz> in ubuntu+1
12:44:34 * glguy just changed fonts to see all of the pretty chracters... I wonder what the purpose of including all of these in unicode was
12:44:45 <Botje> glguy: filler.
12:44:51 <vincenz> for your viewing pleasure http://img507.imageshack.us/my.php?image=screenshotnx9.png
12:44:54 <lambdabot> Title: ImageShack - Hosting :: screenshotnx9.png, http://tinyurl.com/ybddzg
12:45:18 <xerox> vincenz: haha
12:45:23 <vincenz> I wonder who the hell takes the time to draw all that
12:45:24 <xerox> vincenz: that's not the "default" one.
12:45:32 <vincenz> it's "Sans"
12:45:47 <vincenz> Like the snowman?
12:45:57 <xerox> ±
12:46:26 <xerox> ⊦
12:46:37 <xerox> ⁂
12:46:41 <xerox> ASTERISM O-o
12:46:50 <vincenz> xerox: where do you get these
12:46:54 <xerox> I'm using Circe version from CVS (2006-08-15 19:38:32) with GNU Emacs 22.0.50.1 (of 2006-08-19)
12:47:05 <xerox> + friend's code ^_^
12:47:32 * Zr40 uses windows' charmap
12:47:40 <xerox> can search them by name?
12:47:44 <Zr40> yep
12:47:46 <xerox> with tab completition?
12:47:55 <Zr40> no :)
12:47:56 <xerox> ^_^
12:48:24 <xerox> regexp search? etc? :P
12:48:39 <xerox> Ⰰ
12:48:51 <xerox> GLAGOLITIC CAPITAL LETTER AZU
12:48:52 <Daveman> ^_^
12:48:53 <xerox> ok.. :P
12:48:54 <eviltwin_b> hm, that's the first onee that didn;t work here
12:49:04 <xerox> that was too much :)
12:49:05 <eviltwin_b> got a hexbox
12:49:21 <xerox> ⏥ FLATNESS
12:49:28 <Daveman> /xerox/
12:49:44 * lispy thought he was in ##emacs for a second
12:49:53 <xerox> ㍏ Daveman
13:08:53 <Ontolog> I understand this: listLength :: (List t) -> t1
13:08:58 <Ontolog> but I don't understand this: listLength :: (Num t1) => (List t) -> t1
13:09:31 <lispy> "(Num t1) => " means that when you see t1 you know it is an instance of the Num type class
13:10:09 <lispy> so that type means that listLength takes a list of type t to a some type of number
13:11:02 <glguy> ?type genericLength
13:11:03 <lambdabot> forall i b. (Num i) => [b] -> i
13:11:22 <Ontolog> ok because I tried to do listLength :: (List t) -> (Num t1)
13:11:27 <Ontolog> which would seem to mean the same thing
13:11:29 <Ontolog> but doesn't
13:11:31 <glguy> ?instances Num
13:11:33 <lambdabot> Double, Float, Int, Integer
13:11:43 <glguy> > genericLength [1..10] :: Float
13:11:44 <lambdabot>  10.0
13:12:28 <lispy> Ontolog: i don't know they did it the way they did, but type class constraints have to come bofer the rest of the type signature
13:12:37 <lispy> before*
13:15:43 <Ontolog> ?pastebin
13:15:44 <lambdabot> Unknown command, try @list
13:15:48 <Ontolog> @list
13:15:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:16:05 <lispy> ?where pastebin
13:16:06 <lambdabot> http://rafb.net/paste
13:16:10 <Ontolog> oh
13:16:19 <lispy> ?where paste
13:16:19 <lambdabot> http://paste.lisp.org/new/haskell
13:16:26 <lispy> actually i prefer that one
13:16:55 <lisppaste2> Ontolog pasted "Problem with listTail" at http://paste.lisp.org/display/30313
13:17:24 <lisppaste2> Ontolog annotated #30313 with "Error" at http://paste.lisp.org/display/30313#1
13:17:39 <lispy> Ontolog: you're returning the wrong type ;)
13:18:02 <lispy> Ontolog: how can it return a List if you don't use a List constructor ;)
13:18:23 <lispy> oh wait
13:18:26 <lispy> i'm being stupid
13:18:32 <SamB_XP> heh
13:19:28 <Ontolog> the error has to do with Show
13:19:53 <Ontolog> I guess GHCi can't print the return value of listTail
13:19:53 <lispy> Ontolog: yeah, just add deriving (Show) to your data declaration
13:20:23 <Ontolog> like this? data List a = Nil | Cons a (List a) deriving (Show)
13:20:28 <lispy> exactly
13:20:53 <lispy> you probably want to add Ord and Eq while you're at it and maybe Read
13:21:37 <Ontolog> like this? data List a = Nil | Cons a (List a) deriving (Show, Ord, Eq, Read)
13:21:49 <lispy> yup
13:22:04 <Ontolog> thanks
13:22:08 <lispy> yw
13:26:59 <pitecus> What does that mean: Coverage Condition fails for one of the functional dependencies
13:29:06 <lispy> pitecus: no idea, which haskell compiler is that?
13:29:14 <pitecus> ghc
13:33:44 <SamB_XP> read a paper or something!
13:35:52 <vincenz> @join #scheme
13:54:44 <pitecus> Any idea how I can import a module, and reexport it under a different name?
13:55:45 <dolio> module Foo (list of exports) where import Bar (functions to import)
13:56:46 <pitecus> dolio thats just the module declaration syntax
13:57:06 <bringert_> pitecus:  you can write "module Bar" in the export list
13:57:38 <pitecus> bringert_, that'll just the functions in Bar unqualified
13:57:49 <bringert_> yeah
13:57:59 <bringert_> you can't rename modules that you export
13:58:16 <pitecus> sucks
13:58:21 <bringert_> the only way is to create a module with the new name, and have it re-export the old module
13:58:55 <bringert_> there is no "export qualified"
14:00:01 <pitecus> What I'd like to do is to have a module Foo which imports Data.Map, Data.Set etc, and reexports the functions in them qualified, so that I can just say import Foo
14:00:25 <pitecus> instead of having 10 lines of qualified imports in each module that I write
14:00:27 <bringert_> yeah, I've wanted that too
14:01:06 <twanvl> You could always mess with the C preprocessor...
14:01:25 <astrolabe> yuk
14:01:43 <dolio> You could just make yourself some modules with the qualified name you want, no?
14:02:06 <dolio> Make a module "S" and import Data.Set, and put it where ghc(i) will find it.
14:03:13 <pitecus> dolio, i dont see how it solves the problem
14:03:59 <dolio> Then you just put S.empty everywhere, and it uses the empty function from the S module, which is actually Data.Set.empy.
14:04:12 <dolio> Instead of having to say "import qualified Data.Set as S".
14:04:47 <pitecus> but i still have to repeat the import Set, import Map,import List and so on
14:05:13 <dolio> No, you only have to import Data.Set in S, and then export it all from S.
14:05:36 <dolio> You don't have to import if you use fully qualified names, no?
14:05:57 <pitecus> No?
14:06:03 <pitecus> OK I see
14:06:28 <dolio> I'm not sure. That might only be true in ghci...
14:06:38 <bringert_> dolio: yes, only ghci
14:06:44 <dolio> Ah, well, scratch that, then.
14:06:54 <lisppaste2> Ontolog pasted "Error" at http://paste.lisp.org/display/30322
14:09:17 <dolio> "elements left" is type [t]
14:09:31 <dolio> so you have [t] : t : [t]
14:09:42 <dolio> You need [t] ++ t : [t], or something like that.
14:09:55 <vincenz> t:t:[t]
14:10:07 <vincenz> > 1:2:3:4:[5]
14:10:09 <lambdabot>  [1,2,3,4,5]
14:10:57 <Ontolog> thanks
14:11:15 <Ontolog> why wasn't the : operator made to work with lists like ++ .. it seems silly to me
14:11:21 <Ontolog> that you can't do [1,2] : [3,4]
14:11:29 <integral> because that's what the ++ operator does?
14:11:38 <integral> They do different things ... so shouldn't they be different?
14:11:44 <Botje> Ontolog: what are you talking about? [1,2] : [[3,4]]
14:11:45 <lisppaste2> vincenz annotated #30322 with "better" at http://paste.lisp.org/display/30322#1
14:11:46 <lispy> Ontolog: (:) is analgous to your Cons
14:11:46 <Botje> works perfectly.
14:11:59 <Botje> granted, it might not do what you want, but meh :)
14:13:56 <Ontolog> I want to switch the order of 'x' and 'elements left'
14:14:00 <Ontolog> but now it's not working again :(
14:14:39 <vincenz> x:elements left ++ elements right
14:14:48 <Botje> that's just downright geeky.
14:14:53 <vincenz> What?
14:14:57 <Botje> having the Y combinator in your quit line :)
14:15:02 <vincenz> Who does?
14:15:02 <Blejdfist> or elements left ++ [x] ++ elements right
14:15:07 <Botje> 23:11 -!- Nshag [n=nshag@Mix-Orleans-110-2-87.w193-250.abo.wanadoo.fr] has quit ["((λ (x) (x x)) (λ (x) (x x)))"]
14:15:12 <vincenz> Heh
14:15:16 <vincenz> I'm talking to this girl atm how I am geeky
14:15:17 <heatsink> I thought that was omega?
14:15:22 <vincenz> She's geekophobia
14:15:36 <Botje> astound her with your Y-combinator prowess!
14:15:46 * vincenz fix's Botje with himself
14:16:00 <vincenz> fix Botje
14:16:05 <Botje> :)
14:16:05 <vincenz> you decide which direction your lambda is pointing
14:16:13 <Botje> up, of course!
14:16:41 * lispy can't resist
14:16:48 <lispy> it's not the size of the monad, it's how you use it
14:17:05 <Botje> s/use/bind/ :)
14:17:12 <lispy> heeh
14:17:28 <vincenz> it's the way you liftM_ it
14:17:30 <Botje> haskell is like BDSM: the fun only starts when you start binding
14:17:40 * bringert_ tries to come up with a clever joke using the monad/gonad closeness
14:17:46 * bringert_ fails
14:17:51 * vincenz returns
14:17:58 <metaperl> what fn takes a list of strings and injects "\n" between them?
14:18:02 <Botje> WARNING: over-binding monads may lead to purpleness
14:18:05 <Botje> metaperl: unlines
14:18:05 <vincenz> metaperl: intersperse
14:18:09 <metaperl> hmm
14:18:12 <Ontolog> you guys are freaks
14:18:20 <metaperl> Botje: and vincenz  thanks
14:18:21 <vincenz> > intersperse "\n" ["A", "B","C"]
14:18:23 <lambdabot>  ["A","\n","B","\n","C"]
14:18:26 <vincenz> > concat $ intersperse "\n" ["A", "B","C"]
14:18:28 <lambdabot>  "A\nB\nC"
14:18:33 <CosmicRay> hey metaperl!
14:18:35 <vincenz> > unlines ["A", "B", "C"]
14:18:36 <lambdabot>  "A\nB\nC\n"
14:18:37 <vincenz> Ontolog: you must be new here
14:18:43 <bringert_> intercalate of course
14:18:54 <vincenz> @hoogle intercalate
14:18:55 <lambdabot> No matches found
14:18:56 <vincenz> ?
14:18:57 <lispy> yeah, whas the name not obivous?
14:19:04 <metaperl> CosmicRay: aloha!
14:19:14 <bringert_> vincenz: you have to wait for 6.8
14:19:20 <vincenz> bringert_: what's the type-def
14:19:29 <CosmicRay> metaperl: how goes it?
14:19:42 <metaperl> CosmicRay: well... my job is aggravating
14:19:50 <bringert_> vincenz: it's just  concat and intersperse
14:19:52 <metaperl> CosmicRay:  they are strict on lunch breaks and dress code
14:20:00 <vincenz> bringert_: and unlinesi s?
14:20:10 <metaperl> CosmicRay: I spent some time in King of Prussia, PA. how far is that from you?
14:20:11 <CosmicRay> ugh
14:20:20 <CosmicRay> metaperl: probably about 2000 miles
14:20:25 <bringert_> unlines = intercalate "\n"
14:20:31 <metaperl> oh, PA is _that_ big, huh :)
14:20:33 * CosmicRay checks google maps
14:20:36 <CosmicRay> metaperl: I'm in Kansas ;-)
14:20:37 <metaperl> are you still in PA?
14:20:38 <metaperl> oh!
14:20:46 <metaperl> never mind! I thought you were in PA
14:20:51 <CosmicRay> nope, never been there
14:21:00 <CosmicRay> ah, I was off.  Only 1300 miles. ;-)
14:21:09 <metaperl> were you born in PA? oh. I think you follow a form of Christianity that started in PA?
14:21:41 <CosmicRay> nope, though I am a Mennonite, and there are some large groups of particularly conservative Mennonites in PA.  (I'm not one of the particularly conservative ones though)
14:21:43 <metaperl> Kansas is bitter cold now I'm sure... I'm in Tampa, FL... we are suffering through a 61 degree day here... but it will go down to 38 tonight
14:21:53 <metaperl> oh I see Mennonite
14:22:13 <CosmicRay> it's unseasonably warm this week.  High of 66 tomorrow, low of 34
14:22:46 <metaperl> I saw a striking Russian Orthodox Christian Website this weekend.. http://www.desertwisdom.org/
14:22:48 <lambdabot> Title: DesertWisdom.org - Gateway to Ancient Mystical Christianity
14:23:23 <CosmicRay> metaperl: checking it out.  in the meantime, I discovered xkcd.com today thanks to someone in the other channel
14:23:44 <CosmicRay> for whatever reason, I can't seem to connect to desertwisdom.org
14:24:08 <CosmicRay> oh there we go
14:28:08 * metaperl shuts down and heads home
14:28:41 <metaperl> CosmicRay: the "Death to the World" PDF files are the most articulate part of that website.. cya later
14:28:43 <vincenz> bringert_: intercOlate would be a better naem
14:29:13 <vincenz> CosmicRay: xkcd rocks
14:29:22 <bringert_> @google intercalate
14:29:27 <lambdabot> http://www.wordreference.com/definition/intercalate
14:29:27 <lambdabot> Title: Yahoo!
14:29:30 <bringert_> @google intercolate
14:29:31 <Ontolog> bodily pleasure from which comes sexual passion
14:29:32 <lambdabot> http://www.madsci.org/posts/archives/2003-09/1064282156.Me.r.html
14:29:48 <vincenz> @google intercollate
14:29:51 <lambdabot> http://www.newmediamedicine.com/forum/archive/index.php/t-2161.html
14:30:10 <vincenz> intercolate seems right, check the dna bits
14:31:28 <CosmicRay> vincenz: yes, I had to read the entire xkcd archives.
14:36:22 <araujo> Hello
14:36:27 * araujo been very lazy lately
14:36:58 <araujo> Haskell is the best language ever made.
14:38:28 <psnl> no
14:39:23 <heatsink> @hoogle fromNothing
14:39:24 <lambdabot> No matches found
14:39:28 <heatsink> :(((
14:39:57 <psnl> araujo: if haskell is the best language ever made, what waits for us in heaven?
14:40:24 <araujo> psnl, Son , you are already on heaven if you use haskell
14:41:40 <psnl> this is heaven? I imagined more dossing around and angels.
14:41:59 <araujo> we have lambdabot
14:43:26 <dons> :)
14:43:38 <Itkovian> and more women too
14:43:51 <psnl> Itkovian: yeah, I was trying not to say that.
14:44:04 * psnl waits the wrath of Philippa_ 
14:44:27 <araujo> dons!!!!
14:44:39 <vincenz> dons: you should alias !!! to ++
14:44:44 <vincenz> dons: your karma would fly through the roof
14:44:55 <heatsink> heh
14:44:59 <psnl> dons: if lambdabot is an angel, that would make you god
14:45:06 <dons> araujo: are you still interested in translating the HN, or you a bit too busy?
14:45:28 <araujo> dons, yeah, got a new one up now?
14:45:34 <newsham> hi
14:46:03 * araujo checks
14:46:06 <dons> araujo: only from last tuesday,
14:46:13 <dons> i didn't remember getting anything darcs mail
14:46:20 <dons> ah i see it
14:46:23 <dons> in my inbox :)
14:46:32 <dons> never mind :)
14:46:37 <araujo> dons, yeah, been away from my pc lately
14:47:18 * araujo pulls
14:47:41 <araujo> yeah, gotcha
14:47:58 * araujo drinks caffeine and translate
14:48:21 <araujo> dons, i have been thinking of getting some script to upload to the wiki
14:48:29 <araujo> you might proably give me some ideas
14:49:53 <araujo> dons, Btw, #haskell.es is the second largest spanish programming language on this net
14:50:25 <dons> cool!
14:51:01 <araujo> we are behind #php.es i think :-)
14:51:12 <dons> ?users #haskell.es
14:51:13 <lambdabot> Maximum users seen in #haskell.es: 14, currently: 0 (0.0%), active: 0 (NaN%)
14:51:26 <dons> oh, i'd have to ask lambdabot2
14:51:33 <araujo> oh, yeah
14:51:42 <araujo> are they different bots?
14:52:01 <dons> same src, different instances
14:55:35 <Igloo> To to write lambdanet so they can communicate!
14:55:44 <Igloo> s/To/Time/
14:57:42 <dons> hehe
14:58:44 <encryptio> !
14:58:54 <encryptio> monads make sense now... sweet!
14:59:23 <glguy> > let fibs = 1 : 1 : zipWith (+) `ap` tail fibs in take 10 $ fibs
14:59:24 <lambdabot>  Couldn't match `(->) [b]' against `[]'
14:59:39 <glguy> > let fibs = 1 : 1 : (zipWith (+) `ap` tail) fibs in take 10 fibs
14:59:40 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
14:59:50 <glguy> pop-quiz, which monad does that use :)
15:00:13 <dons> (-> a) ?
15:00:30 <dons> ?type let fibs = 1 : 1 : (zipWith (+) `ap` tail) fibs in take 10 fibs
15:00:32 <lambdabot> forall b. (Num b) => [b]
15:00:36 <glguy> Thanks dons :-p
15:00:55 <glguy> I was obviously wondering if you understood that monad, and not encryptio
15:01:10 <encryptio> list monad, no?
15:01:17 <dons> (->) [b]
15:01:18 <glguy> encryptio: nope, not the list monad..
15:01:33 <glguy> the list is there... but not really being used as a monad
15:01:35 <encryptio> (btw, i said they make sense - i have yet to read up on what's there)
15:01:51 <glguy> Fair enough, I was just having fun
15:02:22 <agocorona> hi people
15:02:23 <dons> so you can tell: hide the monad instances, and try to infer the type:
15:02:24 <dons> A.hs:2:28:
15:02:25 <dons>     No instance for (Monad ((->) [b]))
15:02:44 <agocorona> I have problems with GHC 6.6
15:09:33 <agocorona> ok thanks
15:13:44 <newsham> hrm
15:18:55 <agocorona> my problen with UTF8 is ok now.
15:19:41 <agocorona> what happened is that for some reasons the editor did not translated the ansi codes to UTF8
15:20:21 <agocorona> I just retyped al the no ascii characters, I saved as UTF8 and everithing went ok with GHC 6.6
15:21:14 <agocorona> sorry for the disturbance
15:22:44 <agocorona> by the way: what do you think about Clean
15:22:47 <agocorona> ?
15:23:23 <agocorona> I just read some manual and some features are impressive. performance for example
15:24:12 <Excedrin> Clean is nice, but the parallel/concurrent stuff is lacking at the moment (it was revised around the 2.0 release afaik)
15:24:55 <Excedrin> it seems to me that there's also a smaller community and progress moves more slowly
15:25:11 <agocorona> I do know that these features are superb in Haskell
15:25:13 <vincenz> m/quit/quit
15:25:15 <vincenz> ack
15:25:19 <ptolomy> Hm. Well, I'm delighted. My naive haskell 'read a big file, print all anagrams' program is faster than my semi-naive C program that does the same thing.
15:25:50 <glguy> agocorona: you were impressed with Clean's performance after reading a list of featuers?
15:26:07 <SamB_XP> heh
15:26:19 <dons> there was an interesting story a few days ago by lennart, on how basically all lazy functional programming researches set aside their toy languages to work on haskell. except the clean guys.
15:26:20 <SamB_XP> I too can write "performance" on a bullet list!
15:26:50 <dons> so its almost haskell, but not quite. and they miss out on the community. its a pity, since the languages are almsot identical
15:26:50 <agocorona> in clean the arrays are part of the core and Strings are defined as arrays of unboxed arrays.  That is something that contribute to the astohishing speed of Clean
15:27:02 <dons> right. like haskell's are now
15:27:12 <dons> unboxed strings are essential
15:27:37 * ptolomy wonders why exactly his C code is slower.. probably IO.
15:27:39 <SamB_XP> shouldn't vincencz have used mfix and a lot of >>?
15:27:43 <Excedrin> uniqueness typing is easier for me to understand than Monads, but ymmv
15:27:43 <dons> ?google rewriting haskell strings
15:27:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
15:27:45 <lambdabot> Title: Rewriting Haskell Strings
15:27:45 <agocorona> glguy: lol
15:27:46 <dons> agocorona: ^^
15:28:14 <dons> Excedrin: but it doesn't scale up as well. its a nice solution of IO, but you won't get a Cont or STM abstraction out of it (?)
15:28:35 <agocorona> sorry, Strings are defined as unboxed arrays of Chars, In Clean
15:28:43 <dons> yes, and now in haskell :)
15:28:55 <dons> ?docs Data.ByteString
15:28:56 <lambdabot> Data.ByteString not available
15:29:00 <dons> ?where fps
15:29:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:29:26 <glguy> dons: other than pattern matching on arguments, what does one lose by using ByteStrings?
15:29:38 <agocorona> dons but Data.BitString are something not as elegant as the Clean solution
15:29:56 <dons> glguy: that's about it.
15:29:57 <agocorona> byteString i mean
15:30:13 <dons> agocorona: no? the stream fusion system is quite elegant, i feel. but YMMV :)
15:30:23 <LordBrain> well, there's also the loss of the " " sugar...
15:30:34 <mlh> the problem with clean is that it's hard to google for :-)
15:30:49 <LordBrain> which is not as missed as the pattern matching...
15:30:50 <dons> yeah, you have to type: pack "foo", until lennart's overloaded strings patch lands in ghc
15:30:59 <agocorona> and "Clean Language" too
15:31:31 <glguy> Has anyone here read "The Seasoned Schemer"?
15:31:51 <agocorona> what happened to fastPackedStrings ?
15:32:01 <SamB_XP> hmm. is that like the evolution of a haskell programmer -- the seasoning of a schemer?
15:32:11 <glguy> I own, and enjoyed, "The Little Schemer" and "The Reasoned Schemer"
15:32:14 <kosmikus> I don't remember anymore. I've certainly read the Little Schemer, maybe I looked into the Seasoned one as well.
15:32:36 <dcoutts> agocorona, it got renamed to ByteString
15:32:45 <agocorona> ah, ok
15:33:17 <Excedrin> the Clean IDE is also interesting, but it's ugly looking
15:33:28 <glguy> and sucks at being an editor
15:33:52 <agocorona> Im still working with slowUnpackedString
15:34:01 <LordBrain> i didnt know there was an over loaded strings patch
15:34:15 <agocorona> Have you seen the new Dynamic types in Clean?
15:34:22 <LordBrain> does that mean the old strings will be completely gone?
15:34:36 * ptolomy continues to be impressed by the speed and ease of ByteString.
15:34:40 <glguy> not if the patch "overloads" the syntax
15:34:47 <kosmikus> LordBrain: of course not, that's why they're going to be overloaded
15:34:49 <sjanssen> LordBrain: no, no, they'll stick around
15:35:08 <Excedrin> agocorona: the last I looked at the Dynamic stuff, it was unfinished. The docs had "unimplemented" warnings near each part
15:35:44 <agocorona> Excdrin: seems  to be a big task
15:36:00 <agocorona> in the last version there are some little examples
15:36:04 <glguy> > pack "test"
15:36:05 <lambdabot>  Not in scope: `pack'
15:36:14 <glguy> > Data.ByteString.pack "test"
15:36:15 <lambdabot>  Not in scope: `Data.ByteString.pack'
15:36:26 <glguy> ?index pack
15:36:27 <lambdabot> bzzt
15:36:35 <glguy> ?hoogle pack
15:36:36 <lambdabot> Data.PackedString.packString :: String -> PackedString
15:36:36 <lambdabot> Distribution.InstalledPackageInfo.package :: InstalledPackageInfo -> PackageIdentifier
15:36:36 <lambdabot> Distribution.PackageDescription.package :: PackageDescription -> PackageIdentifier
15:36:45 <dcoutts> glguy, that's out of date
15:36:45 <hyrax42_> cabal is confusing me...
15:37:00 <hyrax42_> Setup.lhs: src/Main.hs doesn't exist
15:37:01 <LordBrain> i see
15:37:10 <hyrax42_> $ ls src
15:37:10 <hyrax42_> Main.hs
15:37:18 <hyrax42_> :?
15:37:25 <LordBrain> so, when we import Data.ByteString... automatically our " " will be packed strings/
15:37:27 <LordBrain> ?
15:37:34 <dcoutts> nope
15:37:39 <dcoutts> "" :: String
15:37:43 <dcoutts> pack "" :: ByteString
15:37:59 <LordBrain> i mean after lennart's patch
15:38:08 <hyrax42_> if you pack literals are they compiled directly ?
15:38:08 <LordBrain> pack "" works right now doesnt it?
15:38:19 <sjanssen> LordBrain: you'll have to add a "default (ByteString)" declaration
15:38:25 <LordBrain> oh i see
15:38:31 <dcoutts> then it'll be: "" :: IsString a => a
15:39:07 <agocorona> the patch is included in GHC 6.6?
15:39:26 <LordBrain> if it is then i already have it..
15:40:31 <sjanssen> dons: I don't see how the release of Data.ByteString-0.9 will resolve problems with having both an actively developed ByteString with a fairly static base library
15:40:50 <sjanssen> agocorona: no, it isn't
15:40:51 <dcoutts> it'll be the preview of what will go into base
15:41:21 <dons> sjanssen: it won't be actively developed after that :)
15:41:33 <dons> and will be pushed into base at the same time.
15:41:54 <sjanssen> my major problem is that it's impossible to develop ByteString on ByteString on GHC 6.6
15:42:05 <dons> hmm?
15:42:10 <dcoutts> dons, sjanssen, we just need to rename the module
15:42:17 <sjanssen> because of namespace conflicts
15:42:19 <dcoutts> Data.ByteString.Dev :-)
15:42:22 <dons> or remove the one from base
15:42:26 <sjanssen> dcoutts: yes.  Also, the cbits functions
15:42:30 <dons> that too
15:42:37 <dcoutts> well they're ok
15:42:44 <dcoutts> the static linker doesn't mind duplicates
15:42:48 <sjanssen> dons: not workable anymore, the regex lib depends on ByteString
15:42:49 <dcoutts> though ghci does
15:43:07 <dons> sjanssen: ah. so you develop in base/ yeah, annoying.
15:43:15 <dons> the tools should be able to handle this
15:43:20 <sjanssen> and it's a pain to hack GHC just to work on ByteString
15:43:21 <dons> its just names!
15:43:29 <dons> right
15:43:39 <sjanssen> dons: yeah, it sounds like GHC will fix this eventually, but by the time it does, we won't care anymore
15:43:54 <sjanssen> because ByteString will be actually stable
15:44:01 <dons> right
15:44:34 <dons> so one thing is that with the new ndp library, Data.ByteString will get ported to use Data.Stream
15:44:45 <dons> so there's a common stream fusion library in base
15:44:51 <dons> on which to build ndp, bytestring and the fast arrays
15:44:53 <dcoutts> dons, so what's the good reason for ByteString to be in base? What is going to depend on it?
15:45:02 <dons> maybe there is no good reason
15:45:14 <dons> if simon M says it should be -package fps instead, we can do that
15:45:17 <dcoutts> I'd like to see serialisation in base too and make ghc itself use it
15:45:20 <dons> it would make a ot of things easier
15:45:30 <dons> yeah. so the door is still open for base to depend on bytestring
15:45:31 <sjanssen> dons: I support ByteString in base
15:45:51 <sjanssen> it's such a fundamental thing.  I think everybody will be using it in a year
15:45:54 <dons> so i guess simon had in mind some base-ish things
15:45:58 <dons> mmap, for example?
15:45:59 <dons> sjanssen: right
15:46:09 <dons> the Text.PrettyPrint could use it
15:46:16 <dons> some stuff in Foreign.* coud
15:46:28 <hyrax42_> ?paste
15:46:28 <lambdabot> http://paste.lisp.org/new/haskell
15:46:31 <LordBrain> hey, i havent messed with ByteString until recently, and i found it pretty easy to use, althouh, i didnt find i could do: pack "string", instead i made a function like so: bs = BS.pack . (map (fromIntegral . ord))
15:46:45 <dons> LordBrain: import Data.ByteString.Char8
15:46:49 <LordBrain> ah
15:47:50 <LordBrain> i knew i had to be missing something :)
15:48:50 <agocorona> wow I didnt realize that DataByteString implements the full set of methods of Data.List.  I though that ByteStrigs were just a way to store Strings and litle more. Good
15:49:09 <lisppaste2> hyrax42 pasted "cabal woes" at http://paste.lisp.org/display/30331
15:51:37 <hyrax42_> anyone have a clue?
15:51:51 <hyrax42_> I've been trying to follow the "how to bulid a haskell app" thingy
15:52:21 <hyrax42_> but didn't like the cluttered top-level directory, so used Hs-Source-Dirs
15:52:33 <dons> yep. that's a good idea.
15:52:40 <dons> i'm going to add that to the document
15:52:41 <hyrax42_> but it isnae working
15:52:49 * dons looks
15:53:45 <hyrax42_> thanks
15:53:49 <dons> Main-Is:                src/Main.hs -> Main-is: Main.hs
15:54:06 <dons> you might even be able to leave that line out
15:54:12 <hyrax42_> ah ok
15:54:21 <hyrax42_> well it doesn' thurt
15:54:24 <hyrax42_> and the main might move
15:54:29 <hyrax42_> thanks!
15:59:31 <LordBrain> hmmm maybe the list sugar should be transfered to a ListClass, and then just make ByteString an instance
15:59:47 <agocorona> Sorry for my lack of attention: could you point me to the DataByteString patch that you mentioned before?
16:00:15 <LordBrain> dons brought it up... i dont know where to find it
16:01:01 <sjanssen> agocorona: you're referring to the overloaded strings patch?  It's a GHC patch
16:01:15 <agocorona> LordBain: thanks. By the way, your suggestion make a lot os sense
16:01:42 <sjanssen> LordBrain: yes, perhaps list literals ought to be overloaded too
16:01:50 <agocorona> sjanssen: I see. Lets waith for the 5.7 version
16:02:22 <sjanssen> agocorona: 5.7?  That'd be going back in time ;)
16:02:25 <Cale> However, people might be encouraged to program things the same way that they would with lists, destroying much of the benefit of using the other structures in the first place.
16:02:40 <agocorona> 6.7, sorry
16:02:47 <sjanssen> Cale: also true
16:03:02 <dons> Cale: yeah, see claus reinke's cons issues.
16:03:09 <sjanssen> agocorona: 6.7 is a perpetual unstable version.  It's like Linux used to version their trees
16:03:17 <sjanssen> agocorona: so you might see it i n 6.8
16:03:27 <Cale> If what you want is cons and nil, then just use a list :)
16:03:48 <LordBrain> well
16:03:51 <Cale> (esp. with regard to recursion)
16:04:18 <LordBrain> i thought it would be a step toward having pattern matching like ('a':xs)
16:04:44 <Cale> overloading the pattern matching syntax for lists seems a little on the pointless side to me, since you'll end up with algorithms that are at best as efficient as those for lists.
16:04:58 <LordBrain> yeah
16:05:07 <LordBrain> well there is one point
16:05:21 <dolio> Yeah, a big point of using ByteStrings is to use fold and map and such so that the operations can be fused together efficiently.
16:05:23 <Renkin> @type mapM_
16:05:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
16:05:28 <dons> today's paper: http://programming.reddit.com/info/rrjp/comments
16:05:33 <lambdabot> Title: Automatic testing of higher order functions [pdf] (reddit.com), http://tinyurl.com/yh68pf
16:05:37 <LordBrain> quickly switching from lists to bytestrings
16:05:37 <dons> dolio: right. i.e. use the hofs, not roll your own
16:05:39 <dolio> Doing patterm match destruction would probably make things slower.
16:05:49 <LordBrain> yeah
16:05:51 <dons> it breaks fusion anyway
16:05:52 <Renkin> @type map
16:05:53 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
16:07:48 <sjanssen> Cale: I think pattern matching is fine, but construction via cons isn't
16:08:04 <LordBrain> it would be nice to pattern match on a string like so tho case x of "quit" -> exitWith ExitSuccess
16:08:05 <dcoutts> it could be made efficient
16:08:19 <LordBrain> wouldnt it/
16:08:37 <sjanssen> taking the head and tail of a ByteString is already quite quick
16:08:39 <dons> yeah, patterns are ok.
16:08:43 <dons> its just peek
16:08:45 <LordBrain> i guess we dont need the list like patterns for that
16:09:30 <sjanssen> LordBrain: I think we'd need MPTC+FD or ATs to do overloaded list literals well
16:10:12 <LordBrain> hmm.. well there may be good reasons not to do list literals like Cale pointed out
16:10:39 <dolio> We just need dependent types so we can build arbitrary destruction/recursion schemes. :)
16:11:07 <sjanssen> LordBrain: sure, sticking with "pack" or "fromList" is okay
16:11:43 <agocorona> Another option is to hide byteString handling as a optimization of Lists when they are made of Chars, so that we use the same [Char] notation . Simply the strings pack and unpack internally depending on the operation.
16:11:51 <LordBrain> if i pack a literal string, will that be done at compile time in ghc?
16:12:01 <dcoutts> agocorona, the semantics are different
16:12:23 <dcoutts> agocorona, pack ['a', 'b', 'c', undefined] ?
16:12:37 <dons> stick that in a box and smoke it
16:12:40 <sjanssen> LordBrain: there are RULES in ByteString that can handle that
16:12:50 <agocorona> pack would never be something visibke
16:12:52 <dons> yeah, there's already a rule for strict literals
16:13:17 <agocorona> with this option packing and unpacking would be done by the compiler
16:13:24 <LordBrain> i'm afraid i dont know what a rule is in this context
16:13:34 <sjanssen> agocorona: but you'd still have to prove lack of bottoms in all of the elements
16:13:54 <sjanssen> LordBrain: GHC has an extendible rewrite-rule system
16:14:43 <LordBrain> ok
16:14:47 <sjanssen> you can write stuff like "map f (map g xs) = map (f . g) xs" and GHC will replace all the things that match the LHS with the RHS
16:14:50 <LordBrain> i didnt know that, that's cool
16:15:09 <LordBrain> i want to play with that some day
16:15:12 <LordBrain> hehe
16:15:12 <dons> yeah, its a user-extensible optimisation system
16:15:21 <dons> every compiler for pure languages should have them
16:15:24 <pkhuong> sjanssen: will that work if you use let (linearly)?
16:15:47 <sjanssen> pkhuong: if the inner part is inlined, yes
16:16:04 <pkhuong> sjanssen: ah k.
16:16:35 <dons> i think an embedded, user visible rewrite rule system should be a standard compile technique these days. they're just so powerful
16:16:42 <dons> assuming your language can handle it
16:16:57 <LoganCapaldo> wait it does what now?
16:16:58 <LordBrain> yeah
16:17:03 <dons> s/compiler technique/
16:17:34 <dcoutts> dons, did you see the PAPI thing, might be useful for tuning NDP/ByteString
16:17:40 <agocorona> it is not neccesary to be sure that there would be no bottons, just whenever Bottom appears as consequience of a computation, unpack the string
16:17:59 <dons> LoganCapaldo: http://haskell.org/haskellwiki/GHC/Using_Rules
16:18:02 <lambdabot> Title: GHC/Using Rules - HaskellWiki, http://tinyurl.com/z26ev
16:18:03 <dons> dcoutts: yeah! good idea
16:18:12 <dons> that might give us the edge we're looking for
16:18:17 <dons> and should help with the code gen work too
16:18:20 <dcoutts> dons, since cache is so important
16:18:24 <dons> yes.
16:18:30 <dons> i'll point this out to roman
16:18:30 <agocorona> wekk i know it is not as easy as that.
16:18:45 <sjanssen> dons: has your new lambdabot box come in yet?
16:19:03 <dons> not yet. but its very exciting!
16:19:37 <LoganCapaldo> Haskell is magic, I swear
16:19:37 <sjanssen> how many cores?
16:19:44 <dons> 16
16:19:51 <sjanssen> what's that quote about advanced technology and magic?
16:20:23 <LordBrain> I know the one you mean, something like when technology is advanced enough it becomes indistinguishable from magic...
16:20:50 <LoganCapaldo> It's Clarke's law
16:21:14 <dcoutts> dons, oh so you've ordered the 8-way x dual-core amd64 thing ?
16:21:32 <dons> I think so, yes.
16:21:45 <LordBrain> 8-way?
16:23:00 <dolio> 8-way amd64? That sounds expensive.
16:23:14 <dolio> I figured you bought one of the movidis boxes.
16:23:38 <dons> 8 way amd64, yeah
16:23:39 <shapr> His university bought it :-)
16:24:14 <Pastorn> ways?
16:24:16 <shapr> I heard rumors you get an account on that server as long as you continually improve the DPH code.
16:24:21 <Itkovian> some people have all the luck
16:24:22 * Pastorn is clueless *
16:24:32 <dons> some people have all the cores
16:24:38 <Itkovian> yeah well ...
16:24:40 <shapr> Pastorn: It means 8 sockets on the motherboard, each socket with a dual-core die.
16:24:46 * Itkovian drools
16:24:48 <shapr> For a grand total of 16 cpus.
16:24:58 <Itkovian> think of the experiments I could run
16:25:01 <pkhuong> and soon 32 :)
16:25:18 <Itkovian> and the machine would not have to be shared and such
16:25:23 <Pastorn> shapr: sounds VERY expensive *
16:25:26 <Itkovian> And I could keep one CPU to game on
16:25:31 <shapr> Pastorn: Yeah, but that's how research goes.
16:25:34 * Itkovian drools some more
16:25:45 <Itkovian> Pastorn: it depends on how you look at it
16:25:46 <dmead> bonk
16:25:49 <dons> nah, not so bad.
16:25:52 <sjanssen> research?  I heard it was the new lambdabot box!
16:25:53 <shapr> Researchers need the latest hardware to investigate their ideas.
16:26:00 <dons> compare to a 32 processor sparc machine for say $1M
16:26:06 <Itkovian> Pastorn: it might be cheaper to buy 16 machines, but you could not do the same on them
16:26:06 <shapr> ouch
16:26:07 <dons> a 20k amd64 box is a bargain
16:26:24 <Pastorn> Itkovian: when you decide to get your next new computer, think of that system and me...
16:26:25 <Excedrin> shapr: unless they use a simulator
16:26:31 <pkhuong> dons: an E10k was ~3.5k a couple years ago, iirc.
16:26:39 <Pastorn> oh, wrong person
16:26:42 <Itkovian> dons: we've got 40K to spend ... so maybe yours is an idea ;-)
16:26:51 <shapr> dons: Hey, will you set up a buildbot that builds and publishes the latest profiles of the DPH code?
16:27:04 <dons> mmm. maybe.
16:27:07 <shapr> dons: A 'private' shootout might encourage public contribution.
16:27:10 <dons> that would be a good idea
16:27:12 <dons> yeah, i agree
16:27:51 <Itkovian> I should get some sleep ... but darcs refuses to finish ... grmbl
16:29:18 <shapr> dons: The two benchmark categories I'd suggest would be threaded ghc-smp and transparently parallelized array computation. Are there other flavors?
16:30:05 <dons> checking the performance of flat, non-parallal arrays too, I guess, since they're the base layer of ndp
16:32:16 <Pastorn> dons: I'd suggest the latest game from valve :)
16:33:29 <shapr> Does valve do stuff for Linux?
16:34:04 <pkhuong> or one based on doom 3's engine.
16:34:17 <Pastorn> nah, but i read about their new aproach to SMP
16:34:33 <pejo> pkhuong, 3.5k?
16:34:44 <Pastorn> they're "ahead of their time"
16:34:55 <pejo> pkhuong, as in an old half-full E10k, refurbished from Sun?
16:35:15 <pkhuong> pejo: ebay, by parts, assemble yourself.
16:35:30 <pkhuong> but the electricity bill would have been awesome.
16:35:50 <shapr> In Seattle we had a 32 cpu @ 35MHz Sun
16:35:54 <pejo> pkhuong, yeah, 16 amps 380V or whatever. (Computer society has one in the basement).
16:36:22 <pkhuong> pejo: pretty full, iirc. At least more than 14 way.
16:36:27 <shapr> It big thick wheels and took four people to move from room to room.
16:36:40 <pkhuong> shapr: 35*0* MHz?
16:36:47 <shapr> no, 35MHz
16:37:17 <pkhuong> ouch.
16:37:20 <shapr> I started it up once, the lights dimmed, and I discovered that the entire bottom of the monstrous box was covered in fans. I thought it would levitate.
16:37:42 <LordBrain> lol
16:37:47 <shapr> Then my boss came out and said "That thing eats way too much electricity! Shut it off!"
16:38:30 <cjeris> yay, my typechecker typechecks the literal 1 :D
16:39:12 <dons> cjeris++
16:39:35 <SamB_XP> wouldn't it be so horrible if 1 was ill-typed?
16:39:43 <cjeris> "today the natural numbers, tomorrow rank-2 polymorphism!" or something
16:40:06 <dons> dcoutts: what stage is ghc 6.6 in the gentoo system?
16:40:24 <dons> cjeris: you didn't say whether the literal 1 was a value or a type or a kind?
16:40:31 <dons> maybe you've already got some funky kind system going on ;)
16:40:47 <dcoutts> dons, it's waiting for one of us to find some time to figure out how to make the deps work now that all the libs are modular.
16:40:59 <dons> ah ok
16:41:07 <dcoutts> none of the approaches are simple and we've all been quite busy
16:41:16 <dcoutts> poke me, kolmodin, araujo and kosmikus about it
16:41:18 <dons> just getting itchy about the shootout :)
16:41:21 <dcoutts> aye
16:41:34 <dons> since we have bytestring programs in there now, that fail to compile :)
16:41:35 <dcoutts> dons, so what is their policy on base libs ?
16:41:48 <dons> anything that comes installed with ghc is ok
16:41:57 <dcoutts> on gentoo that means nothing
16:42:06 <dons> so it would have to be easy to get core libs and extra libs
16:42:09 <dons> we'd need both
16:42:28 <dons> how do the debian guys do it?
16:42:34 <dcoutts> it's easy to emerge whichever packages are needed but there is no defined set of them
16:42:47 <dcoutts> dons, they also just have a deb per package
16:42:48 <dons> sjanssen: did we ever check the perf of fasta against http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=ghc&id=3 ?
16:42:50 <lambdabot> Title: fasta Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ..., http://tinyurl.com/y2726u
16:43:10 <shapr> Igloo: Could we have a ghc package that depends on the latest ghc and core libs?
16:43:16 <sjanssen> dons: no, I didn't
16:43:51 <dcoutts> dons, so on gentoo you 'emerge dev-haskell/mtl' on debian you do something like 'apt-get install ghc6-mtl-dev'
16:44:04 <dcoutts> dons, either way, you don't get those extra libs if you just install ghc
16:44:12 <dons> ok good
16:44:25 <dons> so that means the shootout guys know enough to grab the extra packages (fingers crossed)
16:44:41 <Excedrin> dons: do you use OpenBSD on your desktop machine(s)?
16:44:46 <dcoutts> dons, so what counts for their purposes? I thought they said no 'extra' libraries.
16:44:51 <dcoutts> whatever extra means
16:45:13 <dons> dcoutts: not sure. but they already have ghc 6.6 on the debian shootout box
16:45:17 <dons> and i think it has the extra libs
16:45:20 <dons> Excedrin: yeah
16:45:27 <dons> and laptop and firewall and GF's machine
16:45:59 <pkhuong> dons: she let you intall open on her box?
16:46:17 <dons> though admittedly she uses latex, nedit and firefox, so openbsd isn't too scary
16:46:46 <dons> pkhuong: well, i paid for it, and i ain't paying for windows ;)
16:46:51 <pkhuong> ah k. She appreciates my typesetting her stuff, but I don't think she's ready to use emacs + latex yet. Maybe LyX...
16:47:26 <dons> now there's open office on opebsd too, so that might make some things esaier
16:47:57 <dcoutts> @tell ndm how is takeDirectory defined for Windows? the docs only mention posix.
16:47:57 <lambdabot> Consider it noted.
16:47:58 <SamB_XP> dons: makes what easier?
16:48:02 <SamB_XP> running out of RAM
16:48:03 <SamB_XP> ?
16:48:07 <dons> girlfriends
16:48:12 <pkhuong> it won't any less like ass under OOo than w/ under word.
16:48:23 <pkhuong> -w/
16:48:37 <SamB_XP> well, Word costs money
16:48:45 <SamB_XP> and probably doesn't run too well on OpenBSD
16:48:54 <dylan> dons: dwm is interesting!
16:49:02 <dons> dylan: oh you got it going?
16:49:09 <dylan> dons: however, a bit too limited for what I would want.
16:49:18 <dons> you worked out floating/tiled mode?
16:49:19 <dylan> dons: is wmii2 still maintained actively or...?
16:49:27 <dons> wmii3 isn't it now?
16:49:30 <dons> or 4?
16:49:40 <Igloo> dcoutts: by "nothing" you mean "core libraries only", right?
16:49:47 <dons> it seems to have some new maintainers, but the original author has abandoned it to work on dwm instead
16:49:49 <dcoutts> Igloo, right
16:50:02 <dylan> hmm.
16:50:08 <dons> its all very odd on the shootout
16:50:09 <Igloo> shapr: ghc6 includes the core libs
16:50:15 <dons> since you can get gmp or pthreads too if you're in C.
16:50:34 <dons> so as long as its easy to get from the package system, the library might be ok... maybe...
16:50:39 <dylan> dons: any idea about keybindings for moving left/right/up/down using the arrow keys?
16:51:32 <dons> dylan: nope, haven't tried that
16:51:36 <dmead> whatcha doing dylan?
16:51:51 <dmead> sounds like game sutff :o
16:52:02 <dylan> dmead: playing with alternate window managers.
16:52:09 <dons> dcoutts, Igloo: what's the state of Jeremy + HaC ?
16:52:27 <dmead> dylan: for haskell apps?
16:52:36 <dmead> o0
16:52:42 <dcoutts> dons, I'm asking tomorrow, I was too busy teaching today
16:52:46 <dons> ok
16:52:49 <dylan> dmead: well, part of the reason was to switch between lambdabot and vim easily
16:53:23 <SamB_XP> screen and GOA?
16:53:26 <dcoutts> dons, I slept in 'til just before my 2-6pm teaching session today as I was catching up on sleep from the weekend :-)
16:53:46 <dylan> SamB_XP: screen doesn't do vsplit and I have a lot more vertical area.
16:53:57 <SamB_XP> doesn't it?
16:54:01 <dylan> SamB_XP: both my laptop and desktop are wide screen
16:54:09 <SamB_XP> oh, that
16:54:28 * SamB_XP can't keep vertical and horizontal split straight
16:54:33 <dylan> I can run four 89x26 terminals right now.
16:54:42 <dylan> SamB_XP: horizontal == horizon
16:54:53 <dmead> ah
16:54:58 <LordBrain> @post
16:54:59 <lambdabot> Maybe you meant: list part paste
16:55:00 <SamB_XP> well, but, when you add "split", it gets confusing
16:55:08 <LordBrain> ?post
16:55:08 <lambdabot> Maybe you meant: list part paste
16:55:16 <LordBrain> @paste
16:55:16 <dylan> currently in ion3 my haskell-hacking is quite fun.
16:55:17 <lambdabot> http://paste.lisp.org/new/haskell
16:55:30 <dcoutts> Igloo, can you specify exactly what it is that determines the preference? is it just the order of introduction of the flags then? Or does the if {} else {} also make a difference ?
16:55:41 <dylan> Except sometimes left/right can confused... so instead of jumping to lambdabot's query window in irssi I go to my mail client.
16:55:44 <Igloo> dcoutts: Only the flag introduction order
16:56:13 <dylan> and it doesn't know what I mean by @hoogle
16:56:13 <dcoutts> Igloo, ok, an excellent reason for makeing the introduction explicit then.
16:56:23 <Igloo> Indeed
16:56:43 <dcoutts> Igloo, would it also make sense to have some default to False rather than true to control preferences ?
16:56:58 <Igloo> If we introduct them explicitly then we could even allow a preference to be specified rather than always try True first, but I'd not allow that for now as we can always put it in later
16:57:09 <dcoutts> :-)
16:57:39 <pkhuong> (OT) PLT Scheme has a call-by-need dialect :)
16:58:56 <dcoutts> Igloo, just to be clear: so currently Auto = "try True then False" and we're suggesting could add a way to say Auto = "try False then True" on a per-flag basis.
16:59:07 <Igloo> Right
16:59:07 <lisppaste2> LordBrain pasted "trouble with TVars" at http://paste.lisp.org/display/30337
16:59:42 <LordBrain> the del function seems to be innefectual
16:59:47 <LordBrain> in that paste
17:00:01 <LordBrain> i keep staring at it
17:00:25 <dcoutts> Igloo, so do you think we need another iteration of review? ie go back and write out the full proposal with BNF & semantics etc.
17:00:43 <dcoutts> Igloo, we could forward it to JaffaCake and SyntaxNinja
17:00:43 <LordBrain> oooooooh
17:00:56 <dcoutts> Igloo, oh and Ross.
17:01:11 <LordBrain> dumb mistake...
17:01:40 <LordBrain> i filtered (==h) when i meant (/=h)
17:01:43 <Igloo> Another round probably makes sense. I'd like to avoid drowning c-d if possible, as the large threads of subtly different proposals are hard to read
17:01:53 <dcoutts> Igloo, indeed they are.
17:02:09 <dcoutts> Igloo, btw, I like the list monad way of specifying the bactracking semantics.
17:02:34 <Igloo> there's a reason they call it the backtracking monad  :-)
17:02:38 <dcoutts> :-)
17:03:05 <dcoutts> Igloo, perhaps that's the right presentation in general, it can take care of the satisfation tests too
17:03:16 <dcoutts> ie the configuration bodies as filters
17:03:27 <dcoutts> fiilters/gaurds whatever
17:03:35 <dcoutts> @type guard
17:03:37 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:07:59 <LordBrain> i'm writing a peer to peer, and i'm using getLine and putStrLn to talk between them, is that vulnerable?
17:09:35 <dons> over the network?
17:09:38 <LordBrain> for instance, can some hacker send something big enough to cover flow the buffer and crash the program?
17:10:04 <dons> you're managing buffers now?
17:10:06 <LordBrain> yeah over the internet
17:10:09 <LordBrain> no
17:10:11 <LordBrain> i'm not
17:10:26 <LordBrain> there are buffers in the kernel and stuff
17:10:30 <LordBrain> for the sockets
17:10:40 <bringert_> dons: HWN is posted at Chalmers now
17:10:40 <dons> better ask the kernel guys :) (you should be fine)
17:10:46 <dons> bringert_: great.
17:10:50 <dons> is the format ok?
17:11:03 <bringert_> I have tweaked the latex a bit
17:11:15 <dons> want to send me a patch, so it can be auto generated for you?
17:11:33 <dons> (see utils/publish.hs, or jsut send me the improved format, and I'l move it into the publishing tool)
17:11:49 <bringert_> dons: this repo contains the patch: http://www.cs.chalmers.se/~bringert/darcs/hwn/utils/publish.hs
17:11:51 <lambdabot> http://tinyurl.com/y6spwc
17:11:59 <bringert_> eh
17:12:05 <bringert_> without utils/publish.hs
17:12:08 <dons> yep
17:12:12 * dons pulls
17:12:24 <dons> two columns. good idea
17:12:45 <bringert_> is the source for the back0issues available anywhere?
17:12:51 <bringert_> s/0/ /
17:13:11 <dons> not the .wiki src
17:13:19 <dons> all the back issues are in archivess/
17:13:38 <dons> (should be pretty easy to turn archives/*.txt into *.tex
17:13:55 <bringert_> so there is no way (except darcs or txt hackery) to regenerate the PDFs etc?
17:14:15 <bringert_> the motivation for my changes were to allow a larger font, and use more of the page, to allow more content
17:14:27 <dons> i'll regenerate them, yep
17:14:54 <bringert_> a notice board has been ordered for HWN btw
17:14:54 <dons> format looks good bringert_
17:15:08 <dons> so we can probably get more of the issue onto the single page
17:15:19 <dons> such as the discussoin and H' sutff
17:15:33 <bringert_> yeah, that'd be great
17:15:37 <dons> bringert++
17:15:39 <bringert_> jobs would be fun too
17:15:51 <dons> ah yes, and confs.
17:15:56 <dons> i'll do that
17:16:12 <bringert_> have the jobs section would be good when students see it
17:16:17 <dons> :)
17:16:23 <bringert_> they need to understand that haskell is mainstream now :-)
17:16:25 <dons> just need more jobs to be posted to me/haskell@
17:16:34 <bringert_> well, there's that
17:17:47 <bringert_> I think it's good to keep it to one page. I'll try to keep the last two issues posted (or something like that, I don't know how big a notice board the department bought for this)
17:18:53 <bringert_> I want to make a nice banner to put above the posted issues too, to make it obvious that people should watch that space
17:19:22 <dons> yep. great idea.
17:19:32 <dons> i'll ensure it always fits on one page
17:20:05 <dons> i've put them up at my office too :)
17:20:57 <bringert_> maybe there should be a footer with more info about HWN?
17:22:18 <dons> yeah, i think that can be done
17:22:56 <dons> your tex skills are l33t :)
17:23:10 <bringert_> :-) mostly google-fu
17:23:22 <bringert_> it took a while
17:23:42 <dons> not too hard to work out the publish.hs structure?
17:23:49 <bringert_> some sort of slogan under the "Haskell Weekly News" could be fun too
17:23:53 <bringert_> not at all
17:23:53 <dons> or how the tools work? do i need to write more docs?
17:23:56 <dons> ah yes. good idea
17:24:13 <bringert_> I only had to change the canned latex header and footer
17:24:15 <wolverian> meh, what's up with mathematicians and huge tuples? why can't they just name the components? :)
17:24:41 <bringert_> I made one Makefile tweak: ./publish -> 	runghc utils/publish.hs
17:24:49 <emu> wolverian: there's always subscript_hell
17:25:15 <bringert_> dons: I think the tools and docs (not that I read any) are fine, at least for what I needed
17:25:19 <pkhuong> emu: sub_script_hell_i
17:25:19 <dons> good
17:25:39 <bringert_> maybe it could make sens to keep the .wiki files around in archive
17:25:42 <wolverian> emu, I very much prefer that over single characters. I'm weird like that.
17:25:44 <dons> yeah. i think so
17:25:51 <dons> i've wanted them a few times now
17:26:30 <bringert_> maybe we should try to make the PDF look like the picture on http://haskell.org/haskellwiki/HWN
17:26:31 <lambdabot> Title: Haskell Weekly News - HaskellWiki
17:26:38 <dons> heh
17:27:13 * heatsink has a data type data X a = X [a] deriving(Show)
17:27:21 <dons> newtype!
17:27:23 <bringert_> a short humour section could be fun in the PDF, not sure how to select that automatically though
17:27:27 <heatsink> Is no type constraint on `a' required, or is it derived automatically?
17:27:40 <bringert_> autmatically
17:27:41 <dons> bringert_: i could have it prompt for quotes to include
17:27:46 <dons> at publishing time
17:28:06 <heatsink> bringert_ thx
17:29:21 <bringert_> @localtime bringert_
17:29:23 <lambdabot> Local time for bringert_ is 2006-11-21 02:26:38 +0100
17:29:27 <bringert_> yikes
17:29:30 <bringert_> good night
17:29:41 <heatsink> heh, good night
17:32:10 <dons> ?users
17:32:10 <lambdabot> Maximum users seen in #haskell: 276, currently: 250 (90.6%), active: 37 (14.8%)
17:32:20 <dons> oh, new high score (again)
17:32:36 <heatsink> what do we win?
17:32:43 <dons> monads!
17:33:32 <heatsink> Aww... they're heavy...
17:33:39 * heatsink already has one and can't lift any more
17:34:56 <heatsink> Actually, I did come up with a useful monad transformer the other day, for computations that suspend when they want new input.
17:35:11 <dons> oh, nice idea
17:35:37 <newsham> can anyone tell me why I have to define two versions of liftA2 (identically!) to avoid a type error?
17:35:45 <dons> anyone know where the channel stats web page on freenode.org is?
17:35:50 <dons> newsham: hmm
17:35:52 * heatsink shrugs
17:36:02 <heatsink> @hoogle liftA
17:36:03 <lambdabot> No matches found
17:36:33 <newsham> its defined in the arrows paper, and on this page: http://www.haskell.org/haskellwiki/Arrow_tutorial  there's XXX marked near where I had to do the dup define
17:36:35 <lambdabot> Title: Arrow tutorial - HaskellWiki, http://tinyurl.com/yjhzgy
17:39:08 --- mode: ChanServ set +o dons
17:39:37 <dons> ?topic-tail #haskell
17:41:07 --- topic: set to '["Haskell - the language of ICFP winners 3 years running", "Distribute your cognition", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
17:41:13 --- mode: ChanServ set -o dons
17:42:33 <dons> ?remember GentleIntro If k1 and k2 are kinds, then k1->k2 is the kind of types that take a type of kind k1 and return a type of kind k2.
17:42:46 <dons> what part of that isn't gentle :)
17:45:53 <heatsink> That's like saying "what part of quantum chromodynamics don't you understand?"
17:46:25 <pkhuong> dons: it looks fine... An example wouldn't hurt, I guess.
17:48:32 <newsham> I find abstractions easier to learn through concrete examples.  \x -> x + 3 is a function of type Int -> Int.  It takes a value of type Int and returns a value of type Int.  in general k1->k2 is ....
17:49:43 <newsham> I have a shirt that says "what part of <maxwell equations here> dont you understand?"
17:49:59 <heatsink> I think containers would be the easiest examples to understand.  "List of X" and "map from X to Y" have an intuitive meaning...
17:50:28 <newsham> (maybe succ woulda been a better choice than (+ 3))
17:51:53 <newsham> similar concrete instances lead to generalizations.
17:52:33 <fons> hi all
17:52:41 <newsham> hi
17:54:51 <lennart> yow!
17:54:59 <lennart> @yow
17:54:59 <lambdabot> WHOA!!  Ken and Barbie are having TOO MUCH FUN!!  It must be the
17:54:59 <lambdabot> NEGATIVE IONS!!
17:55:05 <dons> hey lennart!
17:55:30 <lennart> so, how's that thesis goin? ;)
17:55:48 * dons works away on thesis. can't talk, must write.
17:56:09 <lennart> your supervisor claims you're slackking off ;)
17:56:33 <dons> argh :|
17:56:35 <fons> does anyone know when is the template-haskell GHC's "imported from another module" restriction gonna be resolved? (if there are plands to do so)
17:56:35 * dons writes more
17:56:45 <lispy> hmm...
17:56:48 <lennart> fons and dons?
17:56:52 <lispy> lennart: are you dons' advisor?
17:57:12 <newsham> lennart: now generalize :)
17:57:14 <lennart> lispy: no, but I sit next to her
17:57:25 <fons> fons, I'm an admirer, hence my fake name
17:57:26 <lennart> eons?
17:57:33 <heatsink> fons, as far as I know, it's not planned.
17:57:53 <fons> heatsink, that sucks :(
17:58:55 <lennart> here is the time I should mention Adrup, Bedrup, and Cedrup, but only Swedes would appreciate it
17:58:55 <heatsink> It's awkward.  But how would one fix it?
17:58:57 <fons> heatsink, it's like only allowing to apply cpp macros on symbols imported with #include (although cpp doesn't know about symbols at all)
17:59:29 <newsham> I'm tim.  I have siblings jim and kim (and robert and candra)
17:59:30 <fons> lennart, living in sweden right now, is it a popular joke?
18:00:06 * dons notes that its hard to write thesis material when its 3 celcius
18:00:12 <dons> 36.
18:00:13 <newsham> the generalization falls apart on {timothy, jim, kimberly}
18:00:25 <lispy> jimothey?
18:00:28 <heatsink> Ick.  air conditioning?
18:00:30 <lispy> s/e//
18:00:34 <greentea> dons: Either way. :-)
18:00:41 * dons goes to find some air con. bbl
18:00:41 <newsham> just Jim.  dad was James, but he hated being called James.
18:01:01 <lennart> fons: it's not a joke.  But if you don't know Bengt Bedrup it's not funny.
18:01:17 <lispy> Jim/James, Chuck/Charles, Hank/Henry, those are all so odd to me
18:01:30 <newsham> Dick/Richard
18:01:48 <newsham> Jack/John
18:02:12 <heatsink> heh, I knew someone who changed his name from John to Jack.
18:02:29 <newsham> Daniels?  Walker?
18:02:41 <heatsink> huh? no?
18:02:58 <newsham> Jack Daniels.  Johnnie Walker.
18:03:12 <newsham> whisk{ey,y}s
18:03:17 <heatsink> oh.
18:03:26 <pkhuong-> well, JD's debatable.
18:03:41 <newsham> jack is a whiskey.  just not a scotch or a bourbon.
18:03:49 * lispy points at #haskell-blah
18:03:55 <newsham> sorry.
18:04:10 <lispy> np, just want to catch  it before it turns into a long discussion
18:04:24 <lennart> yuck
18:04:50 <lispy> i am interested in hear the discussion by the way :)
18:04:56 <lispy> so finish the story over there :)
18:10:31 <dylan> newsham: my dad is legally named "jim" too. Not James. Always confuses people
18:21:49 --- mode: ChanServ set +o Cale
18:21:51 --- mode: Cale set -b palomer!*@*
18:22:20 --- mode: Cale set -o Cale
18:22:27 <Lemmih> palomer was banned?
18:22:44 <Cale> yeah, I don't know why
18:22:48 --- mode: ChanServ set +b palomer!*@*
18:22:53 <Cale> hmm
18:23:52 <lispy> when he came back recently he was very negative and off topic
18:24:03 <lispy> dons warned him a few times and finally just banned him
18:25:55 <robreim> I believe it was shapr who banned him, no?
18:26:26 <lispy> maybe
18:26:37 <lispy> i wasn't here during the banning i just heard about it
18:30:59 <robreim> http://tunes.org/~nef/logs/haskell/06.11.07 <- background. I'm still trying to figure out what he was referring to when he said "now I'm pissed at dons, and I associate dons with haskell". It's kinda entertaining.
18:47:32 <shapr> me me!
18:47:56 <shapr> robreim: yup, it was me.
18:51:15 <lispy> but if you're missing him there is a solution
18:51:18 <lispy> ?palomer
18:51:19 <lambdabot> woof
18:51:35 <lispy> the same is true of keal
18:51:36 <lispy> ?keal
18:51:37 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
18:52:33 <Lemmih> ?keal
18:52:33 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
19:04:26 <Cale> shapr: does he have to stay banned? How bad was the offense?
19:06:34 <lispy> Cale: IMO, no, but he does need to contribute more (read: stay on topic) and whine/vent less
19:06:58 <Cale> He's been talking to me about GADT parsers lately
19:07:18 <lispy> that's certainly positive
19:07:49 <lispy> Cale: and he's welcome to do his off-topic chatting in #haskell-blah
19:14:25 <Excedrin> is there something like show, but that doesn't quote stuff? (toString or something)?
19:14:42 <Cale> show only quotes strings
19:15:04 <Cale> (and so you just don't pass strings to show if you don't want them to appear quoted)
19:15:28 <Excedrin> ok, thanks
19:15:45 <lispy> Excedrin: and that only gets tricky if you hand a structure with embedded stings to show
19:15:57 <lispy> > show ["foo", "bar", "baz"]
19:15:58 <lambdabot>  "[\"foo\",\"bar\",\"baz\"]"
19:16:53 <newsham> > (show . show . show) (words "foo bar baz")
19:16:54 <lambdabot>  "\"\\\"[\\\\\\\"foo\\\\\\\",\\\\\\\"bar\\\\\\\",\\\\\\\"baz\\\\\\\"]\\\"\""
19:17:24 <lispy> > fix show
19:17:25 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:21:55 <satan> can i ask a newtype related question?
19:22:04 <satan> i asked last night, but got disconnected...
19:22:57 <Lemmih> Can I answer it once you ask?
19:24:11 <satan> sure :P
19:24:34 * lispy gets a hold of satan's network connection in preparation
19:24:51 <satan> so i have: newtype Check = Check Bool deriving Show and data Check = Check Bool deriving Show
19:25:12 <Cale> okay
19:25:21 * lispy pulls the plug ;)
19:25:45 <satan> there is a function f, f (Check _) = Check True, and another, p = error "E"
19:26:14 <satan> so when I call f p with newtype, I get Check True, and when f p with data, I get E
19:26:19 <satan> why do they differ like that?
19:26:52 <dons> re.
19:27:03 <satan> i read the haskell report on types and it said that newtype wasnt lifted, but i don't see how not having a Bottom element produces this difference here
19:27:23 <Cale> because (Check _|_) is not _|_ for data
19:27:54 <satan> but this is Check _, not Check _|_
19:28:19 <Cale> Well, f (Check _), in the case of data, will force the evaluation of the value passed, up to determining the top level constructoer
19:28:23 <Cale> constructor*
19:28:35 <satan> I guess i don't get why with the newtype, it doesnt bother looking into the _ arg, but for data it does, finds the error and complains
19:28:36 <Cale> That is, it'll actually check that it's Check
19:28:44 <lispy> satan: here is another way to look at it, the data version creates something called Check which really exists, newtype does not, the "Check" is just there syntatically
19:28:45 <Cale> with newtype, there's nothing to test
19:28:54 <satan> right, thats what i figured, but don't see how/why that happens
19:28:59 <satan> ok
19:29:02 <Cale> It *must* be (Check k) for some k
19:29:33 <satan> lispy: ah i see
19:29:34 <jdev> So one of them's a unary product and the other's a unary sum?  Ugh.
19:29:49 <satan> Cale: ok, so thats it eh, hmm
19:30:30 <satan> thanks
19:54:35 <dons> ?yow
19:54:36 <lambdabot> I'm DESPONDENT ... I hope there's something DEEP-FRIED under this
19:54:36 <lambdabot> miniature DOMED STADIUM ...
19:54:47 <Adamant> ?quote fear
19:54:47 <lambdabot> fear hasn't said anything memorable
19:55:57 <lispy> ?quote shaper
19:55:58 <lambdabot> shaper hasn't said anything memorable
19:56:00 <lispy> ?quote shapr
19:56:01 <lambdabot>  [on causing trouble in #java] I told a java newbie to use a parser monad...
19:57:28 <Korollary> ?users
19:57:28 <lambdabot> Maximum users seen in #haskell: 276, currently: 248 (89.9%), active: 36 (14.5%)
19:58:03 <newsham> ?quote newsham
19:58:04 <lambdabot>  haskell's like chess.  easy to learn. hard to master.
19:58:51 <Korollary> ?quote Dijkstra
19:58:52 <lambdabot> Dijkstra hasn't said anything memorable
19:58:55 <Korollary> baloney
20:00:47 <newsham> lambdabot doesnt get out much
20:01:18 <dolio> Dijkstra: "BASIC sux lol!"
20:02:04 <newsham> "i told you not to GOTO 10!"
20:02:06 <LordBrain> lol
20:02:16 <SamB_XP> @djinn Not (Not ())
20:02:16 <lambdabot> f a = a ()
20:02:25 <SamB_XP> @djinn Not ()
20:02:26 <lambdabot> -- f cannot be realized.
20:02:37 <SamB_XP> @djinn Not (Not (Not ()))
20:02:37 <lambdabot> -- f cannot be realized.
20:02:44 <SamB_XP> hmm. how mystical.
20:03:05 * SamB_XP wonders why the double-negation of excluded middle is allowed.
20:03:19 <SamB_XP> (but not excluded middle)
20:03:44 <SamB_XP> @djinn a -> Not (Not a)
20:03:45 <lambdabot> f a b = b a
20:03:55 <eviltwin_b> djinnx?
20:04:53 <fons> going to bed
20:05:00 <fons> gnight guys
20:05:11 <SamB_XP> @djinn List a -> a
20:05:11 <lambdabot> -- f cannot be realized.
20:05:19 <SamB_XP> @djinn List a -> Bool
20:05:19 <lambdabot> f _ = False
20:05:23 <SamB_XP> hmm.
20:06:03 <psykotic> kilimanjaro, yo
20:06:06 <SamB_XP> @djinn out :: List a -> ListN a (List a)
20:06:07 <lambdabot> Cannot parse command
20:06:13 <SamB_XP> @djinn List a -> ListN a (List a)
20:06:14 <lambdabot> -- f cannot be realized.
20:07:54 <kilimanjaro> psykotic: whatup
20:08:29 <kilimanjaro> psykotic: i'm learning haskell, and the first little program I decided to write is giving me trouble :/
20:09:19 <kilimanjaro> it involves search w/ backtracking. i could easily do it in Scheme using call/cc, but I guess in haskell I should rely on lazy lists or something weird like that
20:09:49 <dolio> You could do it with callcc if you prefer that. :)
20:09:51 <psykotic> could you lisppaste your code?
20:10:20 <kilimanjaro> psykotic: well, i don't really have any
20:10:23 <psykotic> oh, hehe
20:10:25 <kilimanjaro> just datatypes
20:10:43 <psykotic> well, like he dolio says you can actually use callcc within a monad if you want
20:10:58 <kilimanjaro> is there an already implemented monad for that?
20:11:04 <psykotic> yeah
20:11:04 <dolio> Lazy lists are almost certainly easier, though. :)
20:11:09 <dolio> In my opinion, at least.
20:11:24 <SamB_XP> well, sometimes the types are most of the battle ;-)
20:11:27 <psykotic> it depends on how "non-local" the conceptual transfer of control flow is
20:12:22 <kilimanjaro> ok, here's what I am doing: given a proposition in predicate calculus, I want to determine if it is realizeable, and if it is, give a model that implies the proposition
20:12:28 <kilimanjaro> using the tableau method
20:13:39 <kilimanjaro> it basically involves a top down decomposition of the proposition, where the search branches at each connective
20:16:08 <psykotic> could you give a rough example?
20:16:21 <LoganCapaldo> So maybe do something like branch (compute firstChoice) (compute secondChoice) (compute thirdChoice) and let the laziness avoid actually doing the work for each branch, like if the first choice fails grab the second one?
20:16:25 <LoganCapaldo> Maybe?
20:17:18 <psykotic> kilimanjaro, do you need any fancy search strategy or is depth-first adequate?
20:18:05 <JFT> Hi, could anybody points me to paper, book (and some example) on how to use IArray, MArray etc (I read the reference provided by Hoogle but so far I fail to translate this into working code) Thanks
20:19:15 <kilimanjaro> psykotic: dohh, i lost power...
20:19:52 <kilimanjaro> ok, anyways, the gist of the algorithm is this: you have two sets, the first is of necessary truths and the second is of necessary falsities
20:21:40 <kilimanjaro> actually, I think I may have misspoken earlier, this algorithm checks if a proposition is necessarily true, and if not, provides a countermodel
20:22:14 <kilimanjaro> ok, to continue: we begin with truths = null and falsities = {the proposition}
20:24:32 <Korollary> JFT: did you check the wiki?
20:24:33 <kilimanjaro> for each proposition in the sets we either a) decompose it if it is compound, branching the search to handle all subpropositions in the compound one, or if it is a variable, we just leave it alone
20:25:12 <kilimanjaro> psykotic: actually, nvm. i'd probably be better off implementing this and explaining later ;)
20:25:16 <psykotic> hehe
20:25:28 <psykotic> i think i get the gist of it, and it's similar to gentzen's algorithm for search of counterexamples
20:25:47 <JFT> Korollary: Doh! Nope I used hoogle/google search....
20:25:54 <psykotic> when you see something like P & Q in the set of necessary falsities you say, if P & Q is a necessary falsity then either P is a necessary falsity, or Q is a necessary falsity, or both.
20:26:07 <kilimanjaro> yea
20:26:17 <psykotic> and i'm assuming if you see ~P then P moves into the set of necessary truths
20:26:48 <kilimanjaro> yea, for this one
20:27:01 <psykotic> and eventually you either end up with identical propositions in the sets of necessary truths and falsities (indicating a contradiction), or you end up with atomic propositions
20:27:15 <JFT> Korollary: So far I'm often confused by the "hoogle"/GHC doc :( I got SOE and Haskell Road to Logic but neither seems to cover enough "ground" to allow me to "feed" from the reference do you have any book to suggest? (I'd really appreciate)
20:27:25 <kilimanjaro> yea, but really my issue is how to write this via lazy lists ;)
20:27:32 <psykotic> hehe ok, just making sure i got the hang of it
20:27:37 <kilimanjaro> yup
20:28:05 <kilimanjaro> i got a pretty cool book today, on modal logic, and I had never heard of the tableau method until I started reading it
20:28:42 <psykotic> kilimanjaro, it seems like you should be able to write this over any MonadPlus (of which lists are an examples) although the search strategy might be an issue...
20:29:30 <kilimanjaro> what is the general strategy when using lazy lists? what list are we ultimately trying to create?
20:29:42 <kilimanjaro> would it in this case be a list of counterexamples?
20:29:47 <psykotic> right, i think so
20:30:21 <Excedrin> I wrote a HAppS ladder app that uses the Glicko rating system, if anyone would like to take a look before I reply to the mailing list: http://harlan.lerp.com:9990/
20:30:24 <kilimanjaro> ok, so generally each branch in the search would need the two subbranches to be appended
20:30:29 <araujo> Anybody could give me a synonym for 'constraint' ?
20:30:31 <psykotic> right, and that's what mplus is for
20:31:14 <pkhuong> psykotic: yeah, you could do something like the list monad + some strategy...
20:31:16 <newsham> "restriction" ?
20:31:22 <araujo> thanks newsham
20:31:33 <kilimanjaro> psykotic: oh cool, I didn't know about that
20:32:55 <psykotic> kilimanjaro, mplus is supported by MonadPlus instances, which are like monads with support for some kind of 'choice'.
20:33:10 <araujo> newsham, one for 'shootout'
20:33:22 <psykotic> @type mplus
20:33:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
20:33:57 <psykotic> so in the list case this would be [a] -> [a] -> [a], which is just ++
20:34:01 <psykotic> @type (++)
20:34:02 <lambdabot> forall a. [a] -> [a] -> [a]
20:34:03 <newsham> shootout's already used in a weird way.. hard one
20:34:44 <araujo> mmm..
20:34:51 <araujo> newsham, nothint near to it?
20:34:53 <newsham> competition?  tournament?
20:35:00 <kilimanjaro> @type guard
20:35:02 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:35:24 <araujo> newsham, mmm .. i think i can go with it, thanks
20:38:26 <psykotic> lambdabot doesn't work for ghc 6.6 yet, right?
20:40:06 <araujo> mmm....
20:41:47 <palomer_> yo my bitches
20:41:53 <psykotic> haha
20:41:59 <palomer_> >:O
20:42:23 <palomer_> who's got a new ghc cvs installed?
20:42:28 <palomer_> newish
20:45:52 <Lemmih> palomer_: Why?
20:46:41 <palomer_> I want to compile a small file
20:46:46 <palomer_> but my ghc pukes on it
20:46:48 <palomer_> but it shouldn't
20:46:53 <palomer_> I'm using mad GADT hacks
20:49:03 <palomer_> like MAD
20:50:00 <palomer_> did you guys miss your pimp daddy?
21:00:04 <dons> palomer_: be extremely good. i suggest leaving out the pimping and bitches. ok ?
21:01:00 --- mode: ChanServ set +o dons
21:01:07 --- mode: dons set -b palomer!*@*
21:01:11 --- mode: ChanServ set -o dons
21:01:36 <dons> palomer_: its a test: can you be good and play by the rules? if so, we'll all be happy happy
21:04:49 <kilimanjaro> dons: it's not his fault, he's a product of viacom
21:05:56 <kilimanjaro> psykotic: btw, I got it
21:06:25 <kilimanjaro> psykotic: you need more than monadPlus, you need monadTimes
21:07:53 <psykotic> kilimanjaro, you already have sequencing for that.
21:08:06 <psykotic> > let prod xs ys = do { x <- xs ; y <- ys ; return (x,y) } in prod [1,2,3] ["a","b","c"]
21:08:08 <lambdabot>  [(1,"a"),(1,"b"),(1,"c"),(2,"a"),(2,"b"),(2,"c"),(3,"a"),(3,"b"),(3,"c")]
21:08:41 <newsham> > zip [1,2,3] ["a","b","c"]
21:08:42 <lambdabot>  [(1,"a"),(2,"b"),(3,"c")]
21:08:48 <newsham> oh, product.
21:10:48 <kilimanjaro> psykotic: well, i didn't know about that ;)
21:11:09 <dons> nice list monad use, psykotic
21:11:13 <dons> psykotic++
21:11:52 <psykotic> kilimanjaro, you should read x <- e in the list monad as a nondeterministic 'x in e'.
21:12:05 <JFT> Dumb question but "where" is the List moand "specified"
21:12:26 <JFT> I understand the line but I"m surprised the "DO" comes out of nowhere !
21:12:37 <JFT> (yes I'm just starting Haskell ;))
21:12:52 <satan> can someone spare a minute or two and tell me if I've defined the fold function for this type correctly? It's at http://paste-bin.com/1459
21:13:03 <psykotic> JFT: the prod works for any MonadPlus instance. there's a MonadPlus instance for lists, and it infers that's the one to use based on the fact that i pass lists to prod.
21:13:28 <mwc_> What's monad times? Never heard of it
21:13:32 <JFT> psykotic: thanks I guess now I have to find out what a MonadPlus is :P
21:13:44 <psykotic> JFT: It's like Monad with a few additional operations.
21:13:48 <dons> in GHC.Base, JFT:
21:13:49 <dons> instance  Monad []  where
21:13:49 <dons>     m >>= k             = foldr ((++) . k) [] m
21:13:49 <dons>     m >> k              = foldr ((++) . (\ _ -> k)) [] m
21:13:49 <dons>     return x            = [x]
21:14:06 <dons> so your x <- xs is really running'foldr ((++) . k) [] m'
21:14:06 <psykotic> @type concatMap
21:14:08 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
21:14:23 <JFT> Thanks
21:14:25 <dons> rebindble syntx ;)
21:14:28 <kilimanjaro> psykotic: yea, I used concatMap for lack of knowledge about list monad
21:14:32 <dons> vwls sck
21:14:39 <JFT> Learning haskell is trully a lesson of humility lol
21:14:40 <psykotic> dons: ys
21:14:48 <dons> kilimanjaro: foldr ((++) . k) [] m
21:14:51 <dons>  is concatMap, no?
21:14:55 <psykotic> yes
21:14:56 <dons> ?type concatMap
21:14:58 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
21:14:59 <dons> ?type \k m -> foldr ((++) . k) [] m
21:15:01 <lambdabot> forall a a1. (a -> [a1]) -> [a] -> [a1]
21:15:14 * psykotic waves the alpha equivalence wand
21:19:04 <emu> heh, i wrote a function  [Either a b] -> ([a],[b]) the other day, didn't think ppl were trying to standardize it too
21:24:53 <psykotic> emu: is there a neater definition than separate = foldr f ([],[]) where { f (Left l) (ls,rs) = (l:ls,rs) ; f (Right r) (ls,rs) = (ls,r:rs) }?
21:25:28 * psykotic is waiting for the brain-busting point-free definition :)
21:26:18 <dolio> There may be if you use arrow combinators.
21:30:06 <psykotic> @hoogle [Either a b] -> [a]
21:30:07 <lambdabot> No matches, try a more general search
21:31:25 <psykotic> > let getLefts = concatMap f where { f (Left l) = [l] ; f _ = [] } in getLefts [Left 1, Right 2, Right 3, Left 4]
21:31:26 <lambdabot>  [1,4]
21:32:02 <psykotic> @hoogle Either a b -> Maybe a
21:32:04 <lambdabot> No matches, try a more general search
21:32:45 <jdev> @hoogle [Either a b] -> ([a],[b])
21:32:46 <lambdabot> No matches, try a more general search
21:33:53 <lennart> yo!
21:34:08 <psykotic> j0
21:34:21 <dolio> ?type (first . (:)) ||| (second . (:))
21:34:23 <lambdabot> forall b c. Either b c -> ([b], [c]) -> ([b], [c])
21:34:35 <psykotic> dolio: niiiice :)
21:34:42 <jdev> ?type (|||)
21:34:44 <lambdabot> forall (a :: * -> * -> *) d c b. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
21:34:48 <lennart> j0?  bessel functions?
21:35:12 <dolio> ?type let f (Left l) (ls, rs) = (l:ls,rs) ; f (Right r) (ls,rs) = (ls,r:rs) in f
21:35:14 <lambdabot> forall a b. Either a b -> ([a], [b]) -> ([a], [b])
21:36:10 <psykotic> > let separate = foldr (first . (:)) ||| (second . (:)) ([],[]) in separate  [Left 1, Right 2, Right 3, Left 4]
21:36:11 <psykotic> <lambdabot>  [1,4]
21:36:11 <lambdabot>  Couldn't match `[a] -> ([a], d)' against `(d1, [a1])'
21:36:31 <palomer_> noone has a recent CVS of haskell?
21:36:54 <dolio> > let demux = foldr (first . (:) ||| second . (:)) ([],[]) in demux [Left 1, Right 2, Right 3, Left 4]
21:36:55 <psykotic> > let separate = foldr ((first . (:)) ||| (second . (:))) ([],[]) in separate  [Left 1, Right 2, Right 3, Left 4]
21:36:56 <lambdabot>  ([1,4],[2,3])
21:36:57 <lambdabot>  ([1,4],[2,3])
21:37:00 <psykotic> bah :)
21:37:23 <alexj__> can implicit parameters propogate accross modules?
21:39:12 <dons> ?pl separate = let  f (Left l) (ls,rs) = (l:ls,rs) ; f (Right r) (ls,rs) = (ls,r:rs) in foldr f ([],[])
21:39:12 <lambdabot> (line 1, column 10):
21:39:12 <lambdabot> unexpected "="
21:39:12 <lambdabot> expecting variable, "(", operator or end of input
21:40:00 <dons> ?pl separate = let f l (ls,rs) = case x of Left l -> (l:ls,rs); Right r -> (ls,r:rs) in foldr f ([],[])
21:40:00 <lambdabot> (line 1, column 10):
21:40:00 <lambdabot> unexpected "="
21:40:00 <lambdabot> expecting variable, "(", operator or end of input
21:40:03 <dons> boo
21:40:07 <psykotic> hiss
21:43:28 <pkhuong> > let getLefts x = do { elt <- x; case elt of { (Left y) -> return y; (Right _) -> mzero } } in getLefts [Left 2, Right 3]
21:43:28 <pkhuong> ?
21:43:29 <lambdabot>  [2]
21:43:57 <pkhuong> i'm sure there's a nicer way w/ comprehension + a guard.
21:44:18 <lennart> palomer: you're still around, eh?
21:44:38 <dons> palomer_: grab a nightly snapshot and use that, it'll take 3 mins
21:44:50 <jdev> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
21:44:51 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
21:45:07 <dons> palomer_: http://www.haskell.org/ghc/dist/current/dist/
21:45:08 <lambdabot> Title: Index of /ghc/dist/current/dist
21:46:52 <kilimanjaro> so generally when search is implemented using lists, do we first generate all possible states and then filter the bad ones out?
21:47:28 <sjanssen> kilimanjaro: often times, yes
21:47:30 <pkhuong> kilimanjaro: for a lazy list, there isn't much of a difference, but the order in which they're generated can affect the performance, in my experience.
21:47:33 <kilimanjaro> will ghc be able to deforest such a thing?
21:48:07 <sjanssen> kilimanjaro: GHC can deforest any list comprehension, and many maps and folds
21:48:13 <sjanssen> and filters
21:48:22 <kilimanjaro> :)
21:49:02 <dolio> You should be able to modify the point free separate to make getLefts...
21:49:52 <sjanssen> @hoogle either
21:49:53 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
21:49:53 <lambdabot> Prelude.Either :: data Either a b
21:50:01 <dolio> I think, at least.
21:50:45 <dolio> > let getLefts = foldr ((:) ||| const) [] in getLefts [Left 1, Right 2, Right 3, Left 4]
21:50:46 <lambdabot>  add an instance declaration for (Num [a])
21:51:09 <psykotic> sjanssen, church encoding to the rescue!
21:51:35 <psykotic> (i guess it's church _decoding_ here, actually)
21:52:07 <dolio> > let getLefts = foldr ((:) ||| flip const) [] in getLefts [Left 1, Right 2, Right 3, Left 4]
21:52:08 <lambdabot>  [1,4]
21:52:36 <psykotic> @type const
21:52:38 <lambdabot> forall a b. a -> b -> a
21:52:38 <dolio> > let getRights = foldr (flip const ||| (:)) [] in getRights [Left 1, Right 2, Right 3, Left 4]
21:52:39 <lambdabot>  [2,3]
21:52:52 <psykotic> @hoogle a -> b -> b
21:52:53 <lambdabot> Prelude.const :: a -> b -> a
21:52:54 <lambdabot> Prelude.seq :: a -> b -> b
21:52:54 <lambdabot> Control.Parallel.par :: a -> b -> b
21:53:06 <sjanssen> @type foldr (either (first . (:)) (second . (:)) ([], [])
21:53:07 <lambdabot> parse error (possibly incorrect indentation)
21:53:15 <psykotic> @type flip const
21:53:16 <lambdabot> forall a b. b -> a -> a
21:53:19 <psykotic> ah right
21:53:38 <sjanssen> @type foldr (either (first . (:)) (second . (:))) ([], [])
21:53:40 <lambdabot> forall a a1. [Either a a1] -> ([a], [a1])
21:53:49 <psykotic> sjanssen, nice one
21:54:15 <sjanssen> @pl \c -> either (first . c) (second . c)
21:54:16 <lambdabot> liftM2 either (first .) (second .)
21:54:50 <sjanssen> @pl \op -> liftM2 either (op first) (op second)
21:54:50 <lambdabot> ap (liftM2 either . ($ first)) ($ second)
21:55:09 <sjanssen> hmm, too far ;)
21:55:46 <sjanssen> @type foldr (either (:) (flip const)) []
21:55:48 <lambdabot> forall b a. [Either a b] -> [a]
21:57:03 <dolio> Mine's shorter. :P
21:57:17 <kilimanjaro> is there a function that takes a value a and returns a unary function that returns a regardless of argument?
21:57:46 <dolio> > const 1 2
21:57:48 <lambdabot>  1
21:57:50 <kilimanjaro> ohh
21:57:51 <kilimanjaro> thanks
21:57:57 <psykotic> it's like the K from SK :)
21:57:58 <dolio> > const 1 "Bamboozle"
21:58:00 <lambdabot>  1
21:59:11 <sjanssen> > fix (const 1)
21:59:12 <lambdabot>  1
21:59:46 <psykotic> kilimanjaro, btw you should check out lambdabot's hoogle. (you can also use it in private message). you give it a type signature (even polymorphic, i.e. it can have free variables) and it will search for definitions that fit it. so in this case...
21:59:54 <psykotic> @hoogle a -> b -> a
21:59:56 <lambdabot> Prelude.const :: a -> b -> a
21:59:56 <lambdabot> Prelude.seq :: a -> b -> b
21:59:56 <lambdabot> Control.Parallel.par :: a -> b -> b
22:00:07 <kilimanjaro> o.O
22:00:12 <psykotic> yeah it's great
22:00:39 <psykotic> @hoogle (a -> b) -> [a] -> [b]
22:00:40 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
22:00:40 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
22:00:40 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
22:00:51 <sjanssen> also on the web at http://www.haskell.org/hoogle
22:00:52 <lambdabot> Title: Hoogle
22:01:06 <sjanssen> more hits and direct links to the docs
22:01:18 <psykotic> i didn't even know about that.
22:01:19 * psykotic hits self.
22:01:43 <goltrpoat> psyk
22:01:58 <psykotic> yo
22:05:35 <kilimanjaro> ok i'm gonna paste this up, since i'm getting a type error that's confusing me
22:05:38 <kilimanjaro> lisppaste2: url
22:05:38 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:07:08 <lisppaste2> kilimanjaro pasted "type error" at http://paste.lisp.org/display/30349
22:07:41 <kilimanjaro> Ohh, nvm
22:07:54 <kilimanjaro> i'm so stupid
22:15:59 <Adamant> hey dons, anyone managed to snag a PS3^H^H^HCell Workstation for the fine haskell.org folks?
22:16:18 <psykotic> heh
22:16:38 <psykotic> apparently there's a sanctioned version of Fedora anyone can install, right?
22:16:51 <kilimanjaro> @hoogle (a -> Maybe b) -> [a] -> [a]
22:16:52 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
22:17:03 <sjanssen> psykotic: I believe the sanctioned distro is Yellow Dog Linux
22:17:22 <Adamant> can you load arbitrary distros?
22:17:32 <Adamant> (once they get Cellified)
22:17:46 <psykotic> Cellified should just mean PPCified
22:18:21 <psykotic> actually i guess it has some extra SIMD vector registers that you'd want to be stored/restored across context switches...
22:19:01 <sjanssen> psykotic: not to mention those extra processors you probably want to use
22:19:16 <Korollary> The cell has an application-specific arch. It's not a general purpose kick-butt cpu.
22:19:28 <psykotic> the PPU sure is.
22:19:40 <psykotic> well, i wouldn't say kick butt, it's a piece of shit. but it's general purpose.
22:20:16 <Korollary> It has to have general purpose capabilities sure. But the rest is tailored for you -know-what
22:20:35 <pkhuong> psykotic: the PPC core only has the usual altivec, iirc.
22:20:51 <psykotic> pkhuong, i thought it had a larger than usual vector register file.
22:20:55 <Korollary> for instance that new arch from nvidia (gx 88?) is a monster of a piece of silicon.
22:21:12 <psykotic> pkhuong, in any case i'm staying far away from that piece of crap. :)
22:21:32 * psykotic prods goltrpoat .
22:21:50 <Korollary> ?seen goltrpoat
22:21:50 <lambdabot> goltrpoat is in #haskell. I last heard goltrpoat speak 20m 6s ago.
22:21:57 <pkhuong> bah, waiting 2-3 years
22:22:01 <Korollary> ?quote goltrpoat
22:22:02 <lambdabot>  Lemma: three cats chasing a deranged cricket all over the living room at 4am does not provide for a good reading environment
22:22:18 <Korollary> he was trying to read at 4am
22:22:44 <psykotic> goltrpoat is a fellow, um, _fan_ of sony's hardware archs.
22:23:05 <Korollary> Hmm, I dont remember that bit. I would have guess him neutral on that subject.
22:23:10 <Korollary> +ed
22:23:19 <psykotic> me and him go back. trust me :)
22:23:24 <Korollary> oh ok
22:23:54 * Korollary realizes that psykotic has thrown his weapon away and started to run back to the trenches.
22:24:21 <psykotic> it's very much a "fool me once, shame on you. fool me twice, shame on me" kinda thing.
22:24:41 * monochrom ♡ haskell
22:24:45 <sjanssen> I thought it was "well, you can't fool me twice, see"
22:24:58 <Korollary> ?pl (fool me) me
22:24:59 <lambdabot> fool me me
22:25:24 <monochrom> ?pl \me -> (fool me) me
22:25:24 <lambdabot> join fool
22:25:25 <sjanssen> @pl \me -> fool me $ me
22:25:25 <lambdabot> join fool
22:25:30 <Korollary> > sequence_ [fool me, fool me]
22:25:31 <lambdabot>  Not in scope: `me'
22:25:39 <Korollary> hah
22:25:43 <monochrom> haha, "join fool" is a great idea!
22:25:48 * monochrom joins the fools.
22:25:53 <Korollary> ?pl \me -> #fool me $ me
22:25:53 <lambdabot> (line 1, column 8):
22:25:53 <lambdabot> unexpected "#"
22:25:53 <lambdabot> expecting lambda abstraction or expression
22:26:00 <Korollary> blah
22:26:00 <monochrom> If you can't beat them, join them!
22:26:38 <Excedrin> no feedback for my ladder? http://harlan.lerp.com:9990/
22:26:43 <Korollary> ok, #fool is empty. There's still hope for mankind.
22:32:52 <Korollary> If you wanna make a cool winamp skin, you have to use unreadably small fonts.
22:49:19 <goltrpoat>  <psykotic> goltrpoat is a fellow, um, _fan_ of sony's hardware archs.
22:49:21 <goltrpoat> HAHA
22:50:00 <psykotic> admit it, you love it
22:51:32 <Korollary> Hmm, the scrollbar could be the most useless gui widget I can think of.
22:51:33 <goltrpoat> yes.  i want to make sweet love to the Synergistic Processing Units.
22:52:35 <psykotic> i think they (IBM) used sony as consultants when they named the cell and its parts. broadband engine, synergistic processing units--seriously, it's emotion engine, etc all over again.
22:52:39 <kilimanjaro> goltrpoat: all 7 at once?
22:52:52 <goltrpoat> kilimanjaro:  yes.  i want to send them dma packets.
22:52:55 <goltrpoat> from my altivec unit.
22:53:39 <kilimanjaro> goltrpoat: you live in austin?
22:53:43 <goltrpoat> yeah
22:53:49 <kilimanjaro> do you go to UT?
22:53:51 <psykotic> the most hilarious thing i've heard about the cell is that the local scratchpad memory of each SPU is slower to access in both latency and bandwidth than DMA
22:53:54 <goltrpoat> nope
22:54:29 <Korollary> oh that's sad
22:54:34 <pkhuong> psykotic: wasn't that a typo in the slide?
22:54:49 <psykotic> pkhuong, the slide said '(you read that right)'
22:54:53 <psykotic> or something to that effect
22:54:57 <kilimanjaro> psykotic: yea, I saw that
22:55:12 <psykotic> so that makes me think it definitely wasn't a typo
22:55:50 <int-e> Korollary: why are scrollbars useless? I rarely click on them but they're useful indicators (for example of how much text I've processed and how much is still left)
22:56:02 <kilimanjaro> psykotic: I sort of wondered about that... do you have any clue as to why they even have scratchpad memory if that is the case?
22:56:16 <Korollary> int-e: they take too much space to convey just that bit.
22:56:33 <psykotic> kilimanjaro, there might be some high bus contention scenarios where the local scratchpad memory becomes a win. you know, the cell is infinitely scalable, MAN!
22:56:48 <psykotic> so once they get to 500 cells!!
22:56:56 <Korollary> int-e: and if it's a large text, they can't even convey that decently
22:57:41 <kilimanjaro> psykotic: so I'm guessing you aren't getting a ps3...
22:57:44 <psykotic> kilimanjaro, the bus architecture is ring topology so it should scale well in bandwidth if not in latency, so that might become the issue when they start introducing dozens of spus. that's my guess.
22:57:56 <Botty> scrollbars could be good if designed properly
22:58:01 <goltrpoat> one of my partners went to this sony presentation at a conference.  not fully sure why.  anyway, i guess this sony guy was there talking about ps3 development, and he basically said, well guys, the altivec unit is going to be used for nothing but packet dispatch if you want to get the most out of the console
22:58:07 <Botty> more as the kind of location/viewport identifier than control
22:58:10 <goltrpoat> and we've been saying that literally since the day those first specs leaked
22:58:53 <Botty> I do use them as a control though.
22:59:06 <kilimanjaro> goltrpoat: do you develop for the cell?
22:59:14 <goltrpoat> good lord no.  not intending to.
22:59:15 <int-e> Korollary: yes, they could be smaller. and the two buttons at the ends should go away.
22:59:18 <Botty> scroll bar that could deliver more information would be cool too - colored regions
22:59:21 <goltrpoat> been bitten on the ps2.
22:59:44 <psykotic> goltrpoat, "please sir, may i have another". haha.
22:59:45 <Botty> could be as small as 2 or 3 pixels wide
22:59:47 <goltrpoat> haha
23:00:07 <kilimanjaro> i've played with dreamcast, that's actually a pretty sweer (and mainstream) rig
23:00:12 <kilimanjaro> err, sweet*
23:00:27 <psykotic> it was. it even had dx7 support, if i recall. it had some kind of stripped down wince for its kernel.
23:00:35 <Excedrin> Botty: I use xterm without scrollbars; are scrollbars really necessary?
23:00:37 <psykotic> you had the choice between dx7 and katana, sega's own sdk
23:00:57 <Botty> not if xterm is the limit of your computer useage
23:01:01 <Korollary> int-e: I don't know why they should exist at all. You may just drag along where they are as if they exist. Why does it matter whether I click exactly on them or anywhere in that margin.
23:01:02 <goltrpoat> what happened to powervr anyway
23:01:03 <int-e> Excedrin: in xterm, maybe not :)
23:01:04 <kilimanjaro> psykotic: well, i don't have all of that. but from a hardware perspective, it's relatively mainstream (at least, compared to ps2/3)
23:01:23 <psykotic> goltrpoat, powervr was NEC owned, right? i don't think powervr is in business, i'm assuming NEC cut their losses.
23:01:49 <goltrpoat> probably because of dreamcast
23:01:49 <goltrpoat> heh
23:02:03 <goltrpoat> heard good things about it, as far as development goes, though.
23:02:33 <psykotic> yeah, if you released a title for it you had a captive audience of 26 people lining up to buy.
23:02:41 <Excedrin> Botty: is there any case where it's really useful to have a scroll bar? I never really use them, even without xterm
23:02:57 <kilimanjaro> psykotic: do you use directx for your job?
23:03:00 <psykotic> anyway it'd be cool if someone tries to get ghc running on ps3
23:03:05 <psykotic> kilimanjaro, yeah
23:03:05 <goltrpoat> psyk:  the other 14 were in line for the 3do title.
23:04:15 <goltrpoat> er, i guess i'm on crack, that's 4-5 years earlier, isn't it.
23:04:28 <psykotic> re: ps3 and ghc though, if you guys are hoping to run DPH on the SPUs you are in for a fun surprise though.
23:04:30 <Korollary> ghc should run on ps3 just for the geek factor.
23:04:46 <Botty> Excedrin -well, I'm going to assume you're one of those guys that navigates his code a page at a time using key commands.  Frankly I prefer a more analog control.  Wheel for small areas, bar drag for large stuff
23:05:00 <goltrpoat> korollary:  we briefly talked about porting ghc to the 360.
23:05:19 <Korollary> goltrpoat: you can't deny the ps3 devs the beauty of darcs etc!
23:05:27 <Botty> Humans don't naturally navigate data digitally
23:05:28 <goltrpoat> fuck the ps3 devs.
23:05:28 <goltrpoat> :)
23:05:38 <goltrpoat> jk
23:05:41 <goltrpoat> it's not their fault.
23:05:52 <Korollary> Kick them while they're down.
23:06:40 <goltrpoat> or at least poke them with a stick or something.
23:07:13 <psykotic> goltrpoat, regarding ghc on 360, i think the in-order-ness would be a huge issue perfwise. iirc the way the STG-machine works is by having thunks self-modify to a single instruction 'return <value>' once they've evaluated. that kind of indirection is hell when you don't have an OOE to hide latency.
23:07:20 <Excedrin> I use a lot of stuff to navigate: regex, pgup/dn, mouse wheel, line numbers, folding, etc
23:07:27 <psykotic> i don't know how much strictness analysis helps there.
23:07:57 <goltrpoat> psyk:  it was a very brief conversation that started with "doesn't ghc have a ppc backend" and ended with me saying "there's no way we'll get this done in any reasonable amount of time"
23:08:07 <psykotic> hehe
23:08:09 <Korollary> psykotic: What do you mean by in-orderness?
23:08:19 <Botty> ah, well, humans have excellent location memory - often times I can associate functions I wrote with a location in the file - the vertical bar is a good visualization of the position of the view within a document
23:08:20 <psykotic> Korollary, the 360 CPUs are in-order execution engines.
23:08:30 <pkhuong> Korollary: the xenon has something like a 2-instruction reordering window.
23:08:44 <psykotic> it makes it really hard to hide latency of branches and memory accesses
23:08:47 <Korollary> ah ok. I don't see why that's particularly bad for the STG.
23:08:55 <psykotic> well, it's fairly indirection heavy.
23:09:00 <pkhuong> Korollary: the STG is very branchy.
23:09:47 <pkhuong> psykotic: otoh, haskell's type system makes it pretty good for compiled DSEL :)
23:10:50 <psykotic> yeah
23:11:19 <psykotic> i remember the early slides from MS on the 360 cpus
23:11:27 <goltrpoat> i guess on that topic, is hbc a g-machine derivative?  might be more suitable
23:11:30 <psykotic> there was a slide, "don't branch"
23:11:47 <psykotic> goltrpoat, stg is a g-machine derivative. that's what the g stands for :)
23:11:58 <Korollary> he said hbc
23:12:21 <psykotic> i'm pretty sure hbc is since lennart invented g-machine and initially wrote hbc
23:12:35 <goltrpoat> yeah, the reason i mentioned it was that lennart did both
23:12:44 <goltrpoat> i didn't realize stg was a g-machine derivative
23:12:45 <Korollary> well, "don't branch" is a somewhat weird advice.
23:12:55 <psykotic> Korollary, i know, the absolutism was what cracked me up.
23:13:07 <psykotic> the following slides were about how crucial it was to stay in L1 or at least L2 cache
23:13:16 <Korollary> "We have a turing machine with one kind of state transition. Enjoy!"
23:13:27 <psykotic> iirc missing L2 cache means ~500 cycles of latency
23:13:37 <pkhuong> Korollary: masking, etc.
23:13:41 <psykotic> and with no way to hide latency, oh boy :)
23:13:56 <pkhuong> psykotic: they could have pulled a sparc and exposed branch delay slots :)
23:14:27 <psykotic> yeah, that would be fun. i'm pretty sure the last sparc assembly programmer has shot himself by now :)
23:15:09 <pkhuong> python exploits it for nefarious purposes, iirc.
23:15:47 <goltrpoat> they can be found, occasionally, in basement corners.  shivering.
23:16:23 <Korollary> They must have transformed into something else I am sure.
23:16:36 <psykotic> axe murderers is my guess
23:16:50 <goltrpoat> i was going to say chihuahuas, but i'm clearly not on my game right now.
23:17:20 <Korollary> So much love
23:17:28 <psykotic> goltrpoat, anyway, you said you considered porting ghc to ppc?
23:17:32 <Korollary> No, I haven't written a line of sparc assembly myself.
23:17:34 <psykotic> i thought it already ran on ppc?
23:17:48 <goltrpoat> last i checked the ppc backend was in an experimental stage
23:18:08 <psykotic> what about the c backend?
23:18:10 <psykotic> hehe
23:18:21 <goltrpoat> i'd MUCH rather port ghc than port gcc
23:18:42 <psykotic> oh, i hadn't considered that gcc might not run on it. hm
23:18:47 <goltrpoat> on the 360?
23:19:03 <goltrpoat> :)
23:19:06 <psykotic> hehe, good point
23:21:12 <psykotic> goltrpoat, regarding the cell, one of the more surreal things i've heard was when IBM requested a meeting with my friend who works at the serverside stuff at arena.net (the guildwars guys). they were trying to sell him the cell for server backend stuff, specifically databases. haha.
23:21:23 <Korollary> Uh
23:21:36 <Korollary> IBM guys can screw anybody into buying anything
23:21:37 <psykotic> seriously, they invented this thing, and now they're trying to figure out what to do with it.
23:22:10 <psykotic> they really have no idea. it's pretty much good for taking dot products of 100000000000-component vectors, and that's about it.
23:22:36 <pkhuong> psykotic: you'd probably have 0 bit of precision left with single floats and that many components ;)
23:22:41 <goltrpoat> psyk:  databases on the cell?  do they have a db engine that actually.. does that?
23:22:41 <goltrpoat> hehe
23:22:58 <psykotic> goltrpoat, i'm sure they can convince oracle to rewrite everything for the SPUs.
23:23:20 <monochrom> I think cells are great SAT solvers.
23:23:43 <psykotic> good point. or for seti@home style stuff.
23:23:48 <Korollary> awesome. let's tackle np-complete stuff
23:23:58 <pkhuong> now, I don't want to put an end to the flame-fest, but I have some code that made itanium look like a gift from above, and I'm sure something like the SPU would <3 it.
23:24:01 <monochrom> Or alternatively imagine doing 100000000000 quickchecks in one second.
23:24:48 <monochrom> (That is practically as good as a correctness proof. :) )
23:25:08 <Korollary> not really.
23:25:14 <mwc> monochrom, I saw a talk once on a guy who used a computer to check all the 50,000 cases of a theorem
23:25:21 <Korollary> no io. what good is 1M quickchecks
23:25:37 <kilimanjaro> Korollary: What good is 350 horsepower?
23:25:44 <mwc> They had a specific discussion as to the error rate, and the probability that his "proof" was correct
23:25:52 <Korollary> kilimanjaro: I don't argue by analogy
23:26:02 <dons> @tell bringert example of tweaked 'front page' latex, www.cse.unsw.edu.au/~dons/tmp/20061114.pdf
23:26:02 <lambdabot> Consider it noted.
23:26:03 <pkhuong> mwc: fun. How did the proof go?
23:26:06 <mwc> kilimanjaro, pretty much useless next to a 420 HP freebreathing engine :)
23:26:28 <mwc> pkhuong, dunno, I just thought the computational aspect was interesting. I'm kind of a physicist/empiricest at heart
23:26:37 <kilimanjaro> Korollary: but that's what makes arguments interesting
23:26:39 <monochrom> The next level is monkey programming.  Have the cells breadth-first-search all syntactically correct Haskell programs to find one that passes the quickchecks.
23:27:30 <dons> monochrom: hmm! parallel quickcheck eh?
23:27:32 <dons> i like.
23:27:34 * dons hacks
23:27:36 <pkhuong> monochrom: do you really think you can fit a haskell runtime on an spu's local memory?
23:27:46 * dmead very hacks
23:28:22 <dons> monochrom: so the plan is: fork a thread (on the smp runtime) for every property. push results back into a chan, and have a printer thread display them as they come in
23:28:35 <Korollary> If monkeys could hack in haskell, that would be a sad day for those who bitch about monads, imho.
23:28:43 <dons> that would really improve the 1000-odd bytestring quickchecks
23:29:00 <psykotic> dons: do you have your 64-core box yet?
23:29:15 <dons> 64 cores? :)
23:29:23 <dons> 16 cores coming soon, the big machine next year sometime
23:29:23 <monochrom> But really, I have been to a couple of Cell introductions (e.g., was there in the ACM Programming Contest World Finals).  They did raise the question "with this immense amount of computing power, what are we going to do?"  And my thought was, "OK, why don't you use it to replace programmers!  They aren't that smart anyway."
23:29:53 <dons> monochrom: of course you'll need strong, expressive types to guide/prune the search tree
23:29:55 <Korollary> Do they really have an "immense" amount of computing power?
23:29:55 <psykotic> dons: weak! :P
23:29:59 <dons> ?djinn a -> b -> (a,b)
23:30:00 <lambdabot> f a b = (a, b)
23:30:19 <dons> psykotic: so we'll have the 16 core machine within 4 weeks or so, i guess. and a really big machine next year sometime. some sparc monster
23:30:32 <psykotic> Korollary, they do, until you start thinking and realize that every app these days is memory or IO limited.
23:30:40 <psykotic> (memory as in memory bandwidth).
23:31:01 <dons> monochrom
23:31:10 <kilimanjaro> psykotic: so I guess there's no big movement to port firefox to the cell...
23:31:19 <dons> monochrom++ i'm going to see if i can submit a patch to -package QuickCheck to add parallel property testing
23:31:28 <dons> thanks for the inspiration :)
23:31:37 <Korollary> psykotic: well, in any case, for the amount of power they suck, which is probably less than what a high end AMD/Intel sucks, I don't think even the theoretical power shouldn't be classified as "immense".
23:31:55 <monochrom> I thought I was nuts. :)
23:32:21 <dons> sjanssen: around? sound reasonable?
23:32:27 <psykotic> i'm reminded me of the awesomo 3000 episode of southpark where cartman is hired by hollywood to make up movie ideas
23:32:40 <dons> heh
23:32:44 <psykotic> keep going, monochrom! :)
23:37:20 <dmead> are you programmed for pleasure, awesmo?
23:37:28 <dmead> weakkkkkkkk
23:37:31 <dmead> weakkk!
23:42:23 <therp> good morning
23:56:40 <goltrpoat> is it just me, or is there precious little useful documentation for epigram
