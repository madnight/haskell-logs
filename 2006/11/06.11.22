00:06:35 <bran_> whats the recommended way to talk to mysql with haskell?
00:06:48 <bran_> hsql doesn't like macs :(
00:06:49 <bran_> Loading package hsql-mysql-1.7 ... can't load .so/.DLL for: mysqlclient (dlopen(libmysqlclient.dylib, 10): image not found)
00:07:14 <lispy> bran_: hdbc works fine for me on windows
00:07:54 <lispy> bran_: but maybe you installed just hsql and forgot the database specific drivers?
00:09:19 <bran_> do you mean on the c/mysql side or the haskell side?
00:10:26 <lispy> haskell
00:10:53 <lispy> i don't remember how hsql works or if i've used it, but it seems like hdbc had sub dirs that you had to go into and build db specific drivers
00:11:04 <bran_> i did that..
00:11:28 <Excedrin> it looks like the mysqlclient is missing to me
00:11:33 <zeeeee> is there a function like span but which returns (items satisfying predicate ++ the first one that doesn't, the rest)?
00:11:39 <lispy> if you go to the root of the project and type find . | grep "\.dylib"  do you see that file?
00:12:03 <lispy> zeeeee: hmm...not sure...is break what you want?
00:12:06 <lispy> ?hoogle span
00:12:07 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
00:12:07 <lambdabot> Data.PackedString.spanPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
00:12:07 <lambdabot> Text.Html.colspan :: Int -> HtmlAttr
00:12:25 <lispy> ?hoogle (a -> Bool) -> [a] -> ([a], [a])
00:12:27 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
00:12:27 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
00:12:27 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
00:12:30 <bran_> lispy: nope
00:13:20 <zeeeee> hmm
00:13:21 <lispy> bran_: my feeling is that you're very close to getting it working (so don't give up yet) but maybe ask on haskell-cafe@ or if hsql has a website check there (or maybe google your error code)
00:14:30 * lispy sleeps, good luck all!
00:14:53 <zeeeee> lispy: thanks
00:15:04 <zeeeee> (break didn't do the trick though)
00:16:18 <lispy> zeeeee: well, try Data.List.partition?
00:16:29 <zeeeee> lispy: i did, that's not it either
00:16:37 <lispy> zeeeee: or maybe write a wrapper function which fixes up the return value of span?
00:17:04 <zeeeee> lispy: yeah, that's what i'll do
00:17:11 <lispy> cool
00:17:35 <greentea> zeeeee: Could you not just take the first element of the second list in the tuple that's returned?
00:18:21 <greentea> Er, by span?
00:20:36 <zeeeee> greentea: yeah, that's what my wrapper does now :)
00:20:40 <greentea> :-)
00:21:16 * araujo throws tuples at everywhere
00:25:37 <therp> what are the next bigger haskell conferences in 2007?
00:26:09 <therp> and there was some hacking in oxford in january right?
00:29:19 <dblhelix> therp: dons and dcoutts will be performing at padl in january
00:29:42 <dblhelix> @google PADL 2007
00:29:45 <lambdabot> http://www.informatik.uni-kiel.de/~mh/padl07/
00:29:45 <lambdabot> Title: PADL 07: Practical Aspects of Declarative Languages
00:31:21 <dblhelix> not too much haskell talks though...
00:31:26 * dblhelix counts two
00:31:39 <satan> hello all, quick question
00:32:14 <satan> would i be correct in thinking that foldr (:) [] (x:xs) == x:(foldr (:) [] xs) ?
00:32:15 <Excedrin> @paste
00:32:15 <dblhelix> satan: fire
00:32:16 <lambdabot> http://paste.lisp.org/new/haskell
00:32:40 <dblhelix> satan: yep
00:32:46 <satan> sweet, thanks
00:32:46 <Syzygy-> @pl foldr (:) []
00:32:47 <lambdabot> foldr (:) []
00:33:02 <Syzygy-> > foldr (:) [] [1,2,3,4]
00:33:04 <lambdabot>  [1,2,3,4]
00:33:05 <dblhelix> satan: you even have that foldr (:) [] xs == xs
00:33:07 <Syzygy-> Thought so.
00:33:32 <satan> right, i'm showing that its equivalent to id, but wanted to make sure of that :)
00:33:41 <dblhelix> if I was a category theorist I'd be very happy right now ;)
00:34:04 <Syzygy-> dblhelix: How so?
00:34:13 <araujo> Wouldn't anybody know here an application to translate between different notations? , (infix -> postfix .. etc)
00:34:16 <araujo> And expresion
00:34:19 <lisppaste2> Excedrin pasted "for zeeeee" at http://paste.lisp.org/display/30452
00:34:22 <dblhelix> mmm... don't know much about freud... but I almost typed "category terrorist" :)
00:34:24 <araujo> s/and/an/
00:34:30 <Syzygy-> Bwahahahahaha!
00:34:35 <Syzygy-> I've got to use that at some point.
00:34:50 <Syzygy-> Syzygy- -- Category terrorist and homo-logical algebraist....
00:35:27 <Excedrin> oh, that's silly
00:35:39 <Syzygy-> Well, yeah... That's the point of it, init?
00:35:46 <Syzygy-> Hrm. innit.
00:35:47 <dblhelix> Syzygy-: the constructors of a data type forming the initial algebra of the F-algebra with the data type being equivalent to the least fixed point of F and such... ;)
00:36:11 <lisppaste2> skeh pasted "grab 5 lines, make a list of strings" at http://paste.lisp.org/display/30453
00:36:45 <skeh> Im really confused
00:37:02 <skeh> I have never done IO in haskell :(
00:38:35 <dblhelix> skeh: well, you're quite close actually...
00:39:19 <lisppaste2> Excedrin annotated #30452 with "make spanWhat's interface  like span" at http://paste.lisp.org/display/30452#1
00:39:43 <Johhaidiiijavall> How do i cet list all sublists ?
00:39:46 <Johhaidiiijavall> get*
00:40:42 <dblhelix> skeh: seems however that you're matching a tuple against a list at some point
00:40:42 <Excedrin> > inits [1..3]
00:40:43 <lambdabot>  [[],[1],[1,2],[1,2,3]]
00:41:11 <dblhelix> skeh: in line 3, that is
00:41:41 <dblhelix> skeh: and the type is not quite okay
00:42:34 <Excedrin> skeh: what are you trying to do exactly?
00:42:50 <Johhaidiiijavall> Excedrin, it dons't give me all lists
00:43:09 <Johhaidiiijavall> there are missing [2,3] [1,3] etc
00:43:32 <Excedrin> oh, you want permutations?
00:43:43 <Johhaidiiijavall> if you call it that way :P
00:44:23 <satan> ok, to define a fold function for a custom type, you must have it defined for each constructor, right?
00:44:49 <dblhelix> satan: more or less
00:45:03 <satan> what if one of the constructors is Const String?
00:45:21 <dblhelix> satan: let's do this by example
00:45:26 <satan> ok
00:45:29 <dblhelix> suppose my custom type is
00:45:41 <dblhelix> data Tree a = Leaf a | Node (Tree a) (Tree a)
00:45:45 <satan> ok
00:45:57 <dblhelix> then, the type of my foldTree would typically be
00:46:12 <dblhelix> foldTree :: (a - b) -> (b -> b -> b) -> Tree a -> b
00:46:24 <dblhelix> take a moment to grasp this ;)
00:46:46 <dblhelix> now, define foldTree:
00:46:51 <Syzygy-> dblhelix: You mean (a -> b) -> (b -> b -> b) -> Tree a -> b
00:47:11 <satan> ok
00:47:13 <dblhelix> Syzygy-: yes, I do... I'm sorry
00:47:22 <dblhelix> foldTree l n (Leaf x) = l x
00:47:52 <dblhelix> foldTree l n (Node lft rgt) = n (foldTree l n lft) (foldTree l n rgt)
00:48:14 <dblhelix> you see this is really a very systematic approach?
00:48:14 <satan> right
00:48:24 <satan> the fold replaces each recursive constructor
00:48:59 <dblhelix> just note what happens for the recursive calls in the data type's definition: these correspond to the recursive calls in the fold
00:49:03 <dblhelix> satan: yes, it does
00:49:16 <satan> ok
00:49:59 <satan> i guess i'm confused by the Const String in this data type, it wouldnt change anything, would it?
00:50:46 <satan> maybe i should type it out or pastebin it
00:53:04 <skeh> hey all back, I am trying to get 5 lines from a .txt and put them into a List as strings
00:53:11 <dblhelix> satan: you could paste it
00:53:34 <skeh> i asked this question earlier, i was just too inept to implement peoples code
00:53:35 * araujo goes and gets more caffeine
00:53:52 <satan> ok dblhelix here it is http://paste.lisp.org/display/30455
00:54:36 <satan> I've tried to write the fold function for it, but am not sure if I've done it right
00:54:52 <dblhelix> satan: I'd say foldLambda :: (String -> b) -> (b -> b -> b) -> (String -> b -> b) -> Lambda -> b
00:55:13 <dmead> hmm
00:55:27 <dmead> I have some parec code written and it loads
00:55:36 <dmead> but when i try to run it
00:55:41 <dmead> hugs can't find run =/
00:56:22 <dmead> *parsec
00:56:29 <satan> ok
00:56:29 <dmead> yarr
00:57:09 <Oejet> skeh: You can use the functions: getContents, lines, and take.
00:59:17 <satan> dblhelix: i think i've got it, lemme annotate it and show you, if thats ok
00:59:32 <dblhelix> satan: that's fine
00:59:59 <satan> ok http://paste.lisp.org/display/30455#1
01:00:03 <Excedrin> > (\l -> foldM (\s _->[a:s|a<-l\\s]) [] l) [1..3]
01:00:05 <lambdabot>  [[3,2,1],[2,3,1],[3,1,2],[1,3,2],[2,1,3],[1,2,3]]
01:00:48 <dblhelix> satan: not quite yet
01:00:54 <satan> dblhelix: oh
01:01:07 <dblhelix> satan: it will not even compile, I think :)
01:01:27 <satan> heh ok
01:01:27 <dblhelix> the Application case is okay, though
01:01:33 <dblhelix> let's look at the case for Const
01:01:34 <satan> ok
01:01:57 <dblhelix> foldLambda c app abs (Const s) = c s
01:02:08 <satan> oh
01:02:14 <dblhelix> now, you do the case for Abstraction :)
01:02:19 <satan> so the String isn't meant to be that way
01:02:23 <satan> ok lemme try :)
01:03:41 <satan> foldLambda c app abs (Abstraction s x) = abs s (foldLambda c app abs  x) ?
01:05:00 <dblhelix> yep, that's it
01:05:08 <satan> ok cool
01:05:26 <satan> thanks for your help, btw :)
01:05:59 <satan> now to use it in a function that checks if the lambda expression has a free variable in it...
01:06:01 <dblhelix> you're welcome
01:06:11 <satan> i think thats a bit beyond me too :S
01:06:44 <dblhelix> satan: you'd first want to write a function that collects the freevars of a lambda expr, I think
01:07:15 <dblhelix> then, hasFreeVars = not null . collectFreeVars
01:07:41 <satan> hmm sorry, i was unclear, freeIn has to return True if variable is a free variable, when called with freeIn variable expression
01:07:42 <dblhelix> and, collectFreeVars = foldLambda (:[]) ... ... ;)
01:08:01 <dblhelix> that's even more easy:
01:08:32 <satan> oh?
01:08:59 <dblhelix> well, not that easy if you want to write it as a fold :)
01:09:02 <amiddelk> one way to solve it is first try to collect all vars of a lambda expression, and then alter the code such that it removes those variables that are not free
01:09:09 <satan> right
01:09:35 <dblhelix> you're fold has to produce a function of type String -> Bool
01:09:37 <satan> ok i should start off by defining what im looking for, so a free variable is one that is not referenced within the expression, right?
01:10:01 <satan> right, so freeIn :: String -> Lambda -> Bool
01:10:41 <dblhelix> satan: yeah and then freeIn = flip (foldLambda ... ... ...)
01:11:10 <dblhelix> satan: no, a free var is a var that appear is the expr in a position where it is not bound by an abstraction
01:11:17 <amiddelk> satan: a free variable is a variable that is not bound by a lambda: i.e. the x in \y -> x + y
01:11:30 <dblhelix> flip (foldLambda (==) ... ...)
01:12:13 <dblhelix> and then it gets tricky... ;)
01:12:29 <satan> so we'd have to check to see if it's not in any abstractions
01:12:41 <dmead> is there something special you have to do to get parsec modules to load correctly?
01:13:11 <satan> dblhelix: why the flip before the foldLambda?
01:13:16 <dblhelix> satan: it's a bit more complicated then that...
01:13:35 <dblhelix> satan: so the foldLambda can produce a function of type String -> Bool
01:13:52 <satan> ok
01:14:08 <skeh> Oejet, I am unsure how getContents works, I am looking at the prelude now
01:14:38 <dblhelix> to see why it's tricky, consider x in               (\x . x) x
01:14:39 <Oejet> ?type getContents
01:14:40 <lambdabot> IO String
01:14:49 <satan> hmm yeah that does seem complex
01:14:50 <satan> ok
01:15:06 <dblhelix> satan: although the x gets bound in the expression, it also appears free ;)
01:15:08 <satan> that just evaluates to x, right?
01:15:19 <dblhelix> satan: yes, it does :)
01:15:40 <satan> hmm it gets bound but also appears free?
01:16:33 <Oejet> skeh: "x <- getContents" is how it is used.
01:17:04 <skeh> how does getContents know where to get the contents from
01:17:35 <Oejet> skeh: It takes it always from stdin.
01:17:48 <skeh> ah, I need file IO
01:18:45 <Oejet> skeh: Then you could use readFile.
01:20:26 <satan> dblhelix: so what's the best way to approach this?
01:20:49 <dblhelix> satan: i'd first try and write it without the fold
01:20:59 <dblhelix> satan: that is, write out the recursion explicity
01:20:59 <satan> ok
01:21:06 <satan> ah i see
01:21:11 <dblhelix> have to go now... good luck!
01:21:19 <satan> awesome thanks for all your help
01:22:08 <ski> satan : http://paste.lisp.org/display/30455#2
01:23:12 <satan> ski wow
01:24:53 <satan> ski: thanks
01:25:19 <Johhaidiiijavall> ski, little help needed :P
01:25:20 <Johhaidiiijavall> sublists (a:as)= map (a:) sublists (as)
01:25:20 <Johhaidiiijavall> sublists (a:as) = let b = sublists as in b ++ map (a:) b
01:25:24 <satan> so then i'd just check if variable was a member of the list of freevars returned by that
01:25:29 <Johhaidiiijavall> arent these same ?
01:25:36 <Johhaidiiijavall> first one not working
01:26:46 <ski> http://paste.lisp.org/display/30455#3
01:27:24 <ski> (satan : note, i haven't read what you said after you made the first paste)
01:27:37 <satan> ski: heh alright
01:27:50 <dmead> ski: do you know parsec?
01:28:12 <ski> Johhaidiiijavall : no
01:28:21 <Johhaidiiijavall> ski, no help needed anymore, got it working
01:28:41 <satan> ski: thanks a bunch :)
01:28:47 <dmead> ?type run
01:28:48 <lambdabot> Not in scope: `run'
01:28:48 <Johhaidiiijavall> sublists (a:as)= [as] ++ map (a:) (sublists as)  right ? :)
01:28:55 <ski> Johhaidiiijavall : first, in the former variant, you have forgot parens .. it should be 'map (a:) (sublists (as))' .. still this is not right either, since you're still missing those sublists that doessn't start with 'a'
01:29:17 <ski> sorry, no
01:29:23 <Excedrin> > (\l -> foldM (\s _->[a:s|a<-l\\s]) [] l) [1..3]
01:29:25 <lambdabot>  [[3,2,1],[2,3,1],[3,1,2],[1,3,2],[2,1,3],[1,2,3]]
01:29:36 <ski> let b = sublists as in b ++ map (a:) b
01:29:48 <ski> will have same value as
01:29:59 <ski> sublists as ++ map (a:) (sublists as)
01:30:14 <ski> (just plugged 'sublists as' in place of 'b')
01:30:21 <Johhaidiiijavall> i see
01:30:25 <Johhaidiiijavall>  tanx
01:30:32 <ski> you can't replace the first 'sublists as' there with just '[as]'
01:30:49 <ski> dmead : not so much ..
01:31:00 <dmead> ;/
01:31:21 <dmead> man
01:31:32 <ski> (satan : i added a 'freeVars' for the non-IndirectComposite variant, too)
01:31:33 <dmead> I thought this was the regular parser everyone uses
01:31:37 <dmead> and it's not updated for 3 years
01:31:47 <ski> what is the problem ?
01:33:12 <dmead> i've got my tables defined
01:33:14 <dmead> and it compiles
01:33:33 <dmead> but it says in the help to do start parsec with "run" and then your parser info
01:33:43 <dmead> but "run" is not loaded with the parsec imports
01:34:55 <dmead> http://taz.cs.wcupa.edu/~dmead/code/InfixLogic.hs
01:34:58 <lambdabot> http://tinyurl.com/sbanx
01:35:06 <dmead> it's at the bottom
01:35:36 <ski> maybe you want 'parse','parseFromFile','parseTest' or 'runParser' ?
01:36:00 <dmead> ooohhhh!
01:36:01 <dmead> yea
01:36:04 <dmead> runParser
01:36:08 <dmead> thanks :)
01:36:15 <dmead> it still just says run in the docs
01:36:19 <dmead> they should update =/
01:36:27 <ski> which docs ?
01:36:32 <dmead> the parsec homepage
01:36:40 <dmead> their docs seem to be seriously outdated
01:36:50 <dmead> yea
01:36:54 <dmead> october 2001 =/
01:36:55 * ski is not sure he's looked around that page
01:37:01 <dmead> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
01:37:04 <lambdabot> http://tinyurl.com/syalv
01:37:15 * ski just looked at the API to find above function names
01:37:23 <dmead> =p
01:43:16 <ski> satan : you could write your 'freeIn' in terms of 'freeVars' easily .. you could also define it directly as a folding
01:43:43 <satan> ski: yeah i'm gonna try to write it using the foldLambda
01:43:49 <ski> ok
01:44:47 <ski> (i can show afterwards how it looks with the IndirectComposite variant ..)
01:45:49 <satan> alright, er...what is the IndirectComposite variant?
01:48:23 <lisppaste2> Excedrin annotated #30453 with "." at http://paste.lisp.org/display/30453#1
01:49:08 <Excedrin> skeh: a couple alternative ways to get 5 lines
01:50:03 <satan> ski: i'll ask you tomorrow, 2 am here, i'm out, thanks for the help, night
01:50:21 <Cale> Excedrin: do x <- c; return x is the same as c
01:51:25 <Cale> so in particular, that last one could be written as:  main = liftM (take 5 . lines) $ readFile "in.txt"
01:57:43 <ski> satan : m
01:58:18 <ski> (the IndirectComposite variant is the second part of http://paste.lisp.org/display/30455#2)
02:05:53 <Excedrin> Cale: thanks, I remember that from looking over the Dr Haskell pattern list, but I still don't notice it every time
02:12:33 <Cale> find | ghc -e 'let maxl (l1,x) (l2,y) = if l1 > l2 then (l1,x) else (l2,y) in mapM_ print . Data.List.nub . scanl maxl (0,"") . map (\x -> (length x, x)) . lines =<< getContents'
02:14:26 <Itkovian> Cale that would be 'find .' ?
02:14:38 <Cale> Itkovian: it's a shell command
02:15:23 <Itkovian> find on its own doesn't do anything ... ah, but it does on Linux. Sorry
02:15:40 <Itkovian> on my mac it needs at least a dir to start finding in
02:15:47 <Cale> ah, okay
02:16:00 <dons> find . ?
02:16:00 <Cale> yeah, that's equivalent to find . | ...
02:16:17 <Cale> (292,"./media/hdc1/Backups/home/cale/.nautilus/metafiles/file:%2F%2F%2Fhome%2Fcale%2Fmm%2Ft%253F%2520%2501%2Ft%253F%2Ft%253F%253F%2Ft%253Facting%2520%2525s%2F%253F%253F%2524%2501'%2501.%2501)%2501*%2501%252B%2501%252C%2501-%2501%2F%253F%253F%250F%2F%253F%253F%250F%2F%253F%253Facting%2520%2525s.xml")
02:16:19 <Syzygy-> I think that's the expected behaviour, and the Linux an extension...
02:16:32 <Syzygy-> Cale: That looks ... uuuugly.
02:16:46 <Itkovian> Syzygy-: maybe we should say the GNU extension before the zealots come down on us
02:16:52 <Cale> (235,"./media/hdc1/Backups/home/cale/.javaws/cache/http/Dwww.cs.brown.edu/P80/DMexploratories/DMfreeSoftware/DMrepository/DMedu/DMbrown/DMcs/DMexploratories/DMapplets/DMspecialFunctionConvolution/ATspecial_function_convolution_java_jnlp.jnlp")
02:17:08 <Itkovian> @type Data.List.nub
02:17:10 <lambdabot> forall a. (Eq a) => [a] -> [a]
02:29:45 <dozer> I'm getting there with my code
02:30:11 <dozer> but have a type problem (isn't it always a type problem?)
02:31:03 <dozer> which has amazingly gone away now that I've used the right method L)
03:16:28 <Oejet> ?channel
03:16:29 <lambdabot> Unknown command, try @list
03:17:53 <ski> @seen
03:17:53 <lambdabot> Lately, I have seen brx, malcolm, oejet, pjd and ski.
03:20:21 <Oejet> I was wondering about the command for the max/active users counts.
03:22:59 <profmakx> ?users
03:22:59 <lambdabot> Maximum users seen in #haskell: 276, currently: 253 (91.7%), active: 27 (10.7%)
03:30:02 <Philippa> what's the preferred solution to the expression problem at the moment, given GHC extensions?
03:56:33 <opqdonut> i'm coding a genetic algorithm which means i use lots of randomization. atm i'm juggling RandomGens around, unzipping them out of lists and passing them along everywhere. is there a haskell way to facilitate this?
04:01:21 <sieni> monads?
04:03:12 <roconnor> @wiki MonadRandom
04:03:13 <lambdabot> http://www.haskell.org/haskellwiki/MonadRandom
04:03:13 <profmakx> The universal answer to all questions haskell ist either monads or higher order function
04:03:19 <profmakx> though i am not sure which
04:03:57 <roconnor> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
04:04:00 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/y5xzau
04:04:10 <sieni> http://www.haskell.org/haskellwiki/NicoleKidmanIsABigFatBitch
04:04:12 <lambdabot> Title: NicoleKidmanIsABigFatBitch - HaskellWiki, http://tinyurl.com/y2utqg
04:04:22 <sieni> almost as useful
04:04:50 <opqdonut> yeah i thought there'd be a monad for it
04:04:55 <opqdonut> thanks, i'll have a look
04:05:36 <SimonRC> I have to say that random numbers are a PITA in Hskell.
04:07:20 <opqdonut> hmm that's a monad transformer :/ i'm not really comfortable enough with monads to make use of that i'm afraid
04:08:20 <opqdonut> hmm, randomIO sounds better
04:11:58 <Philippa> SimonRC: I don't think they're too bad if you're used to writing monadic code
04:12:55 <earthy> random numbers are a PITA in general
04:17:32 <SimonRC> Y'know that all of StateT, ReaderT, WriterT, ContT, etc each instances of MonadState, MonadReader, MonadWriter, MonadCont, etc defined for them... Is there any way to derive all these automatically if another moand is added?
04:18:20 <Cale> SimonRC: by adding appropriately general instances
04:18:39 <Cale> (for each of the classes, and the given monad transformer)
04:18:51 <SimonRC> oh
04:19:04 <SimonRC> not quite what I had in mind
04:20:06 <Cale> what did you have in mind?
04:20:26 <dozer> Cale: I got that code you looked at all running
04:20:28 <dozer> thanks for your help
04:20:34 <Cale> dozer: great :)
04:20:39 <dozer> adding in stochastic fireing rates today :)
04:21:33 <Cale> SimonRC: If you newtype a monad, you can use the newtype deriving extension implemented by GHC, hugs, and probably most of the other implementations in order to just derive any classes you want.
04:21:51 <SimonRC> If two Monad transformers M1T and M2T, which give instances of MonadM1 and MonadM2 respectively, are written by people without them knowing about each other, it would be nice if we could automatically have: instance (MonadM1 m) => MonadM1 (M2T m)
04:21:53 <Cale> (since the instances exist for the monad before the newtype)
04:22:15 <Cale> SimonRC: that's theoretically impossible
04:22:25 <SimonRC> oh, why?
04:22:49 <Cale> Because there's no way of knowing exactly how to lift all the operations in the MonadM1 class
04:22:57 <SimonRC> I was thinking something that automatically put otgether the right number of lifts would work.
04:23:16 <Cale> If they're all very simple, there are straightforward ways (which might be "wrong" sometimes, but that's another thing)
04:23:50 <SimonRC> what a pity
04:23:54 <Cale> but there are places where there has to be a little bit of M2T-specific interactions in order to make things work
04:25:36 <SimonRC> I though that you just wrote "instance (MonadReader m) => MonadReader (WriterT m) where { get = lift get }" or whatever
04:25:41 <Cale> Remember that you're defining the semantics of a new programming language by wrapping up the structure of another one in some extra machinery. Exactly how you want to lift operations from the inner monad might depend on the specific language you're creating, and the structure of that extra machinery.
04:26:09 <Cale> In the trivial case like that, you just apply lift
04:26:29 <SimonRC> what more complex case might there be?
04:26:34 <dancor> where is an example of using a makefile that calculates dependencies on the fly with ghc -M
04:26:38 <Cale> have a look at MonadReader
04:26:56 <SimonRC> ah
04:26:58 <SimonRC> ask
04:27:02 <Cale> local
04:27:02 <SimonRC> oops
04:27:07 <SimonRC> I meant that
04:27:09 <Cale> local is a big problem :)
04:27:24 <Cale> because it takes an (m a) as a parameter
04:27:27 <psnl> SimonRC: what are you planning?
04:27:31 <SimonRC> so local need to know how to "run" the inner monad
04:27:39 <Cale> the outer one
04:27:40 <SimonRC> psnl: Just enquiring generally.
04:27:49 * SimonRC thinks of an evil plan...
04:27:58 <SimonRC> Cale: oops, yeah
04:27:58 <psnl> are there other sorts of plan?
04:28:22 <dancor> ones destined for failure
04:28:34 <Cale> so it'll run the outer monad, then apply local, and then lift the result -- at least, that's the obvious way to handle it
04:29:23 <Cale> however the outer monad might require additional information to run, which would make things tricky
04:29:48 <Cale> for example, in the state monad, you need a state -- so you want to use the current state for that, most likely
04:29:57 <Cale> So get will be involved
04:30:10 <SimonRC> class (Monad m) => MRun m i o where run :: m a -> i -> (a, o)
04:30:14 <SimonRC> mwahahaha!
04:30:19 <SimonRC> maybe
04:30:20 <opqdonut> if i do "foo <- bar; return baz where baz = foo" i get "foo not in scope"
04:30:25 <opqdonut> how should i write this?
04:30:35 <Cale> SimonRC: better to make it work with transformers
04:30:56 <Cale> opqdonut: bar :)
04:31:00 <SimonRC> class (Monad m, Arrow oa) => MRun m i oa where run :: m a -> i -> oa a
04:31:02 <Cale> opqdonut: alternately
04:31:06 <SimonRC> mwahahahahaah!
04:31:14 <Cale> do foo <- bar; let baz = foo; return baz
04:31:19 <opqdonut> ok
04:31:28 <opqdonut> i tried let .. in and it broke
04:31:37 <Cale> you could write
04:31:40 <Cale> do foo <- bar; let baz = foo in return baz
04:31:46 <dancor> oh i think ghc -M is more normal than i thought
04:31:49 <Cale> or even
04:31:54 <SimonRC> so run would be approximately foldr for [], runST for ST, runReader for Reader, etc, etc, etc
04:31:56 <Cale> do foo <- bar; return (let baz = foo in baz)
04:32:11 <opqdonut> let baz = foo in return baz broke
04:32:25 <Cale> SimonRC: but that won't solve this problem
04:32:26 <opqdonut> The last statement in a 'do' construct must be an expression
04:32:34 <opqdonut> ^ that was the error
04:32:38 <SimonRC> Cale: yeah
04:32:39 <Cale> er, well, perhaps it will
04:32:57 <opqdonut> but the let ..; seems to work, thanks Ca
04:32:59 <opqdonut> le
04:33:16 <Cale> opqdonut: that often happens when you get the indentation wrong
04:33:31 * SimonRC considers some sort of inside-out monad transformer that tells you how to "run" a monad in the general case.
04:34:04 <Cale> The problem is that every monad has different extra stuff which is required to make it run.
04:34:14 <SimonRC> OST, arrow is not what I want above
04:34:52 <SimonRC> Cale: well, you'd need a different instance of MRun for each Monad, then.
04:35:12 <SimonRC> of course, it may not be possible to give enough information to get it to "meet in the midddle"
04:35:17 <Cale> actually, you probably want MRun to take a monad transformer as parameter
04:35:23 <SimonRC> yes
04:35:23 <Cale> but that's a detail
04:36:00 <Cale> actually, I find the automatic lifting instances are often convenient, but sometimes a pain
04:36:04 <SimonRC> I will have to try to fit all the monad transformation instances in a grid and work from there
04:36:09 <SimonRC> Cale: why?
04:36:21 <Cale> because they automatically define behaviour which you might want to control.
04:37:00 <SimonRC> You could use a newtype and wrap it somehwo?
04:37:07 <Cale> Yes, you can :)
04:37:11 <SimonRC> ah, good
04:37:27 <dozer> is Real what I use for non-whole numbers?
04:37:28 <Cale> In fact, I *always* do that at least at the outermost level.
04:37:37 <Cale> dozer: Double, Float
04:37:44 <Cale> Or Rational
04:37:52 <dozer> What's the most general one?
04:38:00 <Cale> @type fromRational
04:38:00 <dozer> (want to give myself the most rope)
04:38:02 <lambdabot> forall a. (Fractional a) => Rational -> a
04:38:13 <Cale> there's the Fractional class
04:38:15 <dozer> @type Fractional
04:38:16 <lambdabot> Not in scope: data constructor `Fractional'
04:38:20 <Cale> @info Fractional
04:38:21 <lambdabot> Fractional
04:38:24 <Cale> hmm
04:38:25 <Cale> hehe
04:38:29 <dozer> lol
04:38:29 <Cale> @instances Fractional
04:38:30 <lambdabot> Double, Float
04:38:41 <Cale> There are more, but those are the only ones in the Prelude
04:39:00 <Cale> (Num a) => Fractional (Ratio a)
04:39:22 <Cale> er no
04:39:25 <Cale> (Integral a) => Fractional (Ratio a)
04:39:59 <dozer> ah, and fractional introduces trig and exp - I think that's the layer I need, since I need exponential prob distributions
04:40:25 <SimonRC> the current number types are conusing at best and messy at worst.
04:40:41 <dozer> yeah, I get lost all the time
04:41:55 <Cale> dozer: no
04:42:07 <Cale> Floating introduces trig and exp
04:42:27 <dozer> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AFractional
04:42:30 <lambdabot> http://tinyurl.com/ovjef
04:43:45 <dancor> hm
04:43:53 <dancor> why does ghc -M eat my makefile
04:44:28 <dancor> instead of outputting the dependencies so i can use them from my makefile
04:45:10 <dancor> i want 'ghc -isrc -M src/Main.hs' to make Main.d.  is that possible
04:47:33 <SimonRC> Would it help to stick (*), (^), multZero, multOne, isMultZero, isMultOne, and maybe (1/) in a class seperate from (+) and (0-), so we can have instances of the former for matrices, which have: (*) :: Matrix -> Matrix -> Matrix, (^) :: Matrix -> Integer -> Matrix, recip :: Matrix -> Matrix, multZero :: Matrix, multOne :: Matrix, isMultZero :: Matrix -> Bool, isMultOne :: Matrix -> Bool
04:47:39 <SimonRC> ?
04:47:57 <SimonRC> oh, and sign, or course
04:48:09 <dancor> matrices have a sign?
04:48:21 <SimonRC> sign of the determinant
04:48:31 * Syzygy- would very much like to see a little bit more algebraic sense in the Prelude typeclasses personally...
04:48:46 <SimonRC> a multiplicative zero is a matrix with a 0 determinant, i.e. it has no multiplicative inverse
04:49:43 <dancor> are these nxn matrices
04:49:45 <SimonRC> Syzygy-: it is rather humerous that the Reals are defined solely by a surjection onto the Rationals.
04:49:47 <dancor> or nxm ones
04:49:49 <SimonRC> dancor: yes
04:49:55 <SimonRC> n*n
04:50:09 <dozer> some classifications of matricies are determined by what values the scalars are taking - these would be hard to represent in the class system
04:50:13 <SimonRC> argh! we need dependant types for N*M!
04:51:10 <SimonRC> Maybe metaclasses would help?  metaclass Field f where ...; metaclass Ring r where ...; ?
04:51:31 <SimonRC> OST the numeric error messages are bad enough already.
04:52:18 <dancor> OST?
04:52:24 <SimonRC> On Second Thoughts
04:53:15 <dancor> this nonstandard ghc -M blows my mind
04:53:21 <SimonRC> There is an art to interpreting them, to realise that "Could not find instance Floating ((t2 -> b) -> t2) means you missed an argument off somewhere.
04:53:44 * SimonRC goes
04:53:45 <dancor> is the idea that i'd do like ghc -M && make && mv origMakeBack
04:54:21 <dons> HWN is out! http://programming.reddit.com/info/rztp/comments
04:54:23 <lambdabot> Title: Haskell Weekly News: Haskell XML toolbox, Haskell Hackathon 2007 (reddit.com), http://tinyurl.com/yyez6x
04:54:42 <opqdonut> hrmm, is there no way to import libraries from the ghci command line?
04:54:51 <dons> opqdonut: :m + Data.List
04:54:56 <dozer> perhaps an extention to haskell source where you can add in clear explanations for compiler messages?
04:54:59 <opqdonut> dons: thanks!
04:55:29 * dozer starts on a Cream marathon session
04:55:46 <Cale> SimonRC: Matrices form a ring, so it shouldn't be too much of a problem deriving an instance of Num for them
04:56:05 <Cale> at least, matrices of the same square shape
04:56:39 <Cale> the only thing which kind of sucks about Num for them is abs and signum
04:57:31 <dons> swiert: oh i just realised i forgot to include the FitA summary. I'll have that in next week
04:57:33 <araujo> Wouldn't anybody know here an application to translate between different notations? , (infix -> postfix .. etc)
04:57:40 <Cale> but you could, for instance, define abs to be the matrix norm, and signum as scaling by the matrix form
04:57:43 <Cale> norm*
04:57:44 <dons> araujo: a parser? :)
04:58:01 <araujo> dons, :-P
04:58:11 <araujo> dons, i was thinking more of a program.
04:58:23 <araujo> eh ... that already does that
04:58:36 <yuten> hello
04:58:55 <yuten> i have a question about haskell, can anyone help me~
04:59:03 <araujo> shoot
04:59:15 <sieni> Cale: which matrix norm? ;-)
04:59:31 <yuten> if i have a data type such that
04:59:32 <yuten> data TState =
04:59:32 <yuten>         TState
04:59:32 <yuten>         { prePoint ::Point       -- the pre location of turtle
04:59:32 <yuten>         , currentPoint::Point    -- the current location of turtle
04:59:42 <SimonRC> Cale: determinants?
04:59:44 * SimonRC goes
04:59:45 <yuten>  }is it possible that i can write a function that take an attribute name and
04:59:45 <yuten> a  new value for it then i can update the corresponding attribute?
04:59:45 <yuten> Ex:
04:59:45 <yuten> state :: TState
04:59:45 <yuten> foo state prePoint (Point 1 1) -- which will update the prePoint in State
04:59:45 <yuten> into (Point 1 1)
04:59:49 <araujo> dons, Or more specifically, what algorithm would you recommend to implement that purely functional?
05:00:01 <araujo> dons, i have found some algo. but they are very imperatives
05:00:21 <dons> yuqyes, using record syntax: st { prePoint = 8 }
05:00:27 <dons> yuten: ^^
05:00:42 <yax1> hi all
05:00:47 <dons> let st = TState 1 2 in st { currentPoint = 7 } -- for example
05:01:13 <yuten> but i want to set the general form of the function
05:01:32 <yuten> when i want to update the attribute currentPoint,
05:01:48 <yuten> i can just write, foo state currentPoint newPoint
05:01:49 <dons> yuten: ok, so a function of type: a -> (a -> b) -> b -> a
05:01:52 <dons> right
05:02:20 <yuten> i see!!
05:02:30 * araujo off, brb
05:02:49 <dons> ah but you can't do the update. yes, i think there's no general function for this
05:02:55 <dons> since its paramaterised by the label
05:03:10 <dons> so you can pass in a selector function, but there's no 'putter' to update
05:03:13 <yuten> i just need to return a new state
05:03:29 <nornagon> ?pl subOne n = (-) n 1
05:03:29 <lambdabot> subOne = subtract 1
05:03:37 <nornagon> ... i see
05:03:41 <Syzygy-> > (-) 3 1
05:03:43 <lambdabot>  2
05:04:00 <dons> yuten: since labels aren't first class, you can't write:
05:04:01 <dons> update :: a -> (a -> b) -> b -> a
05:04:01 <dons> update v sel x = v { sel = x }
05:04:01 <dons>     where old_x = sel v -- ok
05:04:15 <nornagon> I'm learning Clean.
05:04:20 <dons> so there's no general function for updating an arbitrary record field
05:04:32 <nornagon> Its syntax seems very similar to Haskell's so far.
05:04:40 <dons> nornagon: they're almost the same language
05:04:50 <dons> born out of the lazy functional research of the 80s
05:04:51 <nornagon> Does clean do monad stuff?
05:04:56 * dozer has fallen in love with higher order functions
05:05:12 <dons> most research focused on haskell, but the clean guys kept working away on clean, and it ended up a little different
05:05:32 <malebria> Hello there.
05:05:32 <dons> not sure how well its kept up with the last 5 years of haskell growth.
05:05:51 <dons> nornagon: there are state monads at least
05:05:52 <nornagon> Clean beats the crap out of haskell in the language shootout
05:05:56 <nornagon> not that that means much.
05:06:04 <dancor> oh sweet 'ghc --make -isrc -odir obj -hidir obj src/Main.hs' does exactly what i want
05:06:06 <dons> it has strict strings, and a better native gen
05:06:13 <yuten> dons: so i can's pass a function to reutnr a new state?
05:06:13 <malebria> Prelude Database.HDBC> filter (/= SqlNull) [SqlString "Teste"]
05:06:13 <malebria> *** Exception: fromSql: cannot convert SqlNull to String
05:06:16 <dancor> and so much easier to type than make :)
05:06:20 <dons> so bytestrings + fixing ghc's asm backend should be enough
05:06:24 <nornagon> dons: native gen?
05:06:30 <nornagon> oh
05:06:33 <nornagon> right, yeah.
05:06:39 <malebria> Why does HDBC call fromSql in comparing SqlNull to SqlString?
05:06:57 <nornagon> Basically i was looking through the shootout trying to find something C++-speed but less horrible.
05:06:58 <dons> yuten: you can pass a function to extract a field, but not to update the state
05:07:10 <dons> nornagon: clean, haskell, ocaml: all good choices
05:07:19 <nornagon> *nod*
05:07:24 <dons> you might have issues with libraries in clean
05:07:30 <yuten> dons: ok, i see, thanks a lot,
05:07:30 <dons> (the community is pretty small)
05:07:35 <dons> (and you're tied to one compiler only)
05:07:41 <nornagon> I'm going to steer clear of ocaml, i hear bad things about its community
05:07:57 <nornagon> mm
05:08:00 <malebria> In the code it converts fromSql if the constructor of SqlType is not the same.
05:08:12 <malebria> But this is not a good thing.
05:08:22 <nornagon> Really I'm just trying other things until I work my way up to wrapping my head around monads.
05:09:14 <nornagon> hm, clean has this plus :: Int Int -> Int thing going
05:09:31 <nornagon> apparently it's the same thing as plus :: Int -> (Int -> Int)
05:09:38 <dons> right, they elide ->'s
05:09:43 <nornagon> *nod*
05:09:46 <dons> and put class constraints on the rhs, iirc
05:09:48 <nornagon> can haskell do the same thing?
05:10:03 <nornagon> or are the ->s absolutely necessary?
05:10:08 <dancor> can haskell elide ->?   on it loves them
05:10:12 <dancor> s/on/no
05:10:18 <nornagon> heh.
05:10:22 <dons> yeah, woudn't be terribly popular
05:10:32 <nornagon> not that it really matters much
05:10:35 <nornagon> just wondering.
05:10:38 <dons> its not like type annotations are a critical dev path that needs to be optimised for brevity
05:10:43 <nornagon> yeah.
05:11:52 <dancor> also haskell is cool because you can like implement itself in it and -> is like a binary operator there.  the empty string would be a crazy binary operator
05:12:21 <nornagon> it's function application.
05:12:29 <nornagon> the empty string, that is.
05:12:31 <nornagon> f x
05:12:42 <nornagon>  ^- note the emptiness.
05:12:51 <dancor>  noted
05:12:57 <nornagon> 'k.
05:13:10 <dons> ?kind (->) Int
05:13:11 <dancor> i should have noted it with emptiness
05:13:12 <lambdabot> ? -> *
05:15:36 <psykotic> dons: ? meaning "hither be dragons"? :)
05:15:44 <nornagon> :P
05:16:14 <dons> psykotic: I think approximately, yes.
05:16:41 <psykotic> i'm somewhat curious about how clean's implementation is so efficient. i thought it was based on graph rewriting (or is that just the semantics)?
05:17:00 <dons> that'd just be the eval strategy surely? like haskell
05:17:05 <nornagon> I have nooo idea.
05:17:05 <dons> its all graph rewriting on paper
05:17:25 <dons> they have a good code gen, and strict, unboxed strings. makes the world of difference
05:17:28 <nornagon> I imagine it's just that clean is better at the native code gen stuff
05:17:35 <nornagon> and that, i guess.
05:17:42 <psykotic> dons: right but in the lazy movement in the 80's before the g-machine, etc everything was based explicitly on interpretive-style graph rewriting, no?
05:17:44 <nornagon> haskell should get those. :P
05:17:50 <dons> so ghc with the new native gen SSA optimisations, and other loop spotting goodies, should catch them with time
05:17:57 <dons> psykotic: right
05:18:09 <dons> before lennart et al worked out how to compile to hardware
05:18:33 <dons> nornagon: we have strict unboxed strings now, and the code gen issues are a *hot* topic
05:18:35 * psykotic high fives lennart :)
05:18:52 <dons> ?google compiled graph reduction
05:18:56 <lambdabot> http://portal.acm.org/citation.cfm?id=647555.729739
05:19:11 <nornagon> dons: awesome.
05:19:13 <dons> and the rest is history
05:19:30 <psykotic> so the current x86 codegen is in bad shape?
05:19:39 <dons> nah its ok. about 3% off gcc
05:19:46 <dons> but it coudl do much better with loops and registers
05:20:03 <nornagon> so it's about 3% off gcc ... except when it's not.
05:20:05 <dons> we lose a lot of registers via gcc, it steals them and won't give them back
05:20:05 <psykotic> how does the gcc codegen deal with self-modifying thunks and such? isn't that part of the STG?
05:20:19 <psykotic> nornagon, he means 3% off the gcc codegen, not native c code.
05:20:22 <nornagon> why not compile to C and let gcc do the optimization? >.>
05:20:23 <dons> nornagon: no, the code gen backend is about 3% off the gcc backend
05:20:35 <nornagon> dons: ahh, right
05:20:42 <dons> gcc is very stupid with haskell code
05:20:52 <psykotic> dons: what about the self-modifying thunk thing i mentioned?
05:21:13 <dons> thunks can be destructively updated. the code doesn't change
05:21:15 <dons> just the code pointer
05:21:28 <nornagon> what's a thunk?
05:21:32 <dons> ghc does play some post-processing asm games to improve gcc's output
05:22:04 <psykotic> dons: right, you just change the environment to contain the evaled thunk's value.
05:22:21 <dons> yep
05:22:39 <dancor> nornagon: container that allows for lazy evaluation
05:22:46 <dons> anyway, catching clean in all areas is a goal. i expect to see some good progress on this :) plus we have monads
05:22:49 <psykotic> i thought the original STG had the evaled value inlined
05:22:49 <dons> ;)
05:22:51 <nornagon> dancor: ah, okay. Thanks.
05:22:56 <dancor> http://en.wikipedia.org/wiki/Thunk
05:23:00 <Cale> sieni: I'd use the operator norm
05:23:17 <psykotic> i.e. instead of the indirection through the environment it'd literally generate a new piece of code saying 'return <value>', basically
05:23:30 <dons> noticing how clean did so well with its unboxed strings was one of the motivations behind the new bytestring library
05:23:33 <Cale> as it's probably the only matrix norm you're likely to care much about
05:24:18 <dons> psykotic: ah yeah, there's a bit of that with the FFI still, in fact
05:24:22 <dons> 'Adjustor thunks'
05:24:36 <dons> that mean a few bytes of stack tweaking code get produced to handle FFI calls
05:24:49 <psykotic> gotcha
05:25:16 <dons> here, in all its glory: an adjustor thunk!
05:25:17 <dons>   __asm__ (
05:25:17 <dons>      ".globl " UNDERSCORE "obscure_ccall_ret_code\n"
05:25:17 <dons>      UNDERSCORE "obscure_ccall_ret_code:\n\t"
05:25:17 <dons>      "addl $0x4, %esp\n\t"
05:25:20 <dons>      "ret"
05:25:22 <dons>    );
05:25:25 <dons> :)
05:25:36 <dons> (i keep a supply on hand for just these moments)
05:25:37 <malcolm> hi dons
05:25:50 <dons> hey malcolm. so i haven't received any fps patches yet. i was just about to write.
05:26:03 <malcolm> dons: oh
05:26:19 <dons> did darcs/sendmail swallow them?
05:26:19 <malcolm> dons: looks like my mailer is not working somehow then
05:26:35 <malcolm> dons: I did a darcs send, and got no error message
05:26:57 <dons> you could: darcs send -o /tmp/f.patch , the mail me that file
05:27:06 <dons> and i'll stick it into fps stable tomorrow morning
05:27:36 <opqdonut> lastlog tissit
05:28:37 <malcolm> dons: I just tried darcs send again, and it claims "successfully sent patch bundle to ..."
05:28:52 <malcolm> dons: will try some other route as well
05:29:13 <Igloo> Can you see if your MTA logs talk about it?
05:29:19 <dancor> crazy darcs, who wrote that thing anyway
05:29:31 <dons> malcolm: nothing here yet
05:29:47 <dons> its almost always the MTA in my experience
05:30:41 <dons> ?quote Korollary
05:30:41 <lambdabot>  [On Perelman going AWOL before the Fields Medal award] I can have it if he doesnt want it. Chicks dig Fields Medals
05:30:44 <dons> ah well
05:30:45 <malcolm> igloo: good plan.  here is what the postfix log says:
05:30:49 <malcolm> postfix/smtp[7507]: BFF272C2308: t
05:30:49 <malcolm> o=<dons@cse.unsw.edu.au>, relay=none, delay=443998, status=deferred (connect to
05:30:49 <malcolm> blackhole.cse.unsw.edu.au[129.94.242.28]: Operation timed out)
05:30:52 <dons> I was hoping for "Darcs is free of chemical toxins of big pharma."
05:30:59 <dons> malcolm: hmm!
05:31:17 <dons> blackhole eh?
05:31:30 <dons> malcolm: can you just stick the patch file somewhere i can darcs pull or wget from?
05:31:31 <Igloo> I can connect fine
05:31:39 <Igloo> That is a bit of a worrying name for a mail server, though!
05:32:17 * Igloo wonders why bh and bh2 are listed 5 times each in the MX records
05:32:28 <malcolm> the MTA also appears to try note.orchestra.cse.unsw.edu.au and tone.orchestra....
05:32:38 <dons> those should be the right ones, yes
05:32:47 <dons> tone is where my mail usually comes from
05:33:08 <Igloo> Right, note and tone are higher priority, with the bh's being backups
05:34:09 <dons> so why would it just be malcolm's mail getting blocked. hmm.
05:34:30 <malcolm> hmm, methinks it is probably a firewall issue locally.  I suspect I need to use the Dept relay
05:35:00 <dons> ah maybe
05:35:40 <dancor> dons: why does Yi want #!/usr/bin/env runhaskell
05:35:43 <malcolm> any ideas if I can do that with an option to darcs send?  --sendmail-command= ?
05:35:57 <dancor> is that standard, am in not setup right
05:35:57 <dons> dancor: to run the configure script?
05:36:03 <dancor> dons: yeah
05:36:10 <dons> you don't have runhaskell?
05:36:24 <dancor> right
05:36:27 <dons> malcolm: could you dump it to a file and send from your mail client?
05:36:33 <Igloo> malcolm: You'll probably have to change the postfix config
05:37:02 <malcolm> dons: sure, I'll send a copy manually, but I'd also like to fix my config so it works in future.
05:37:09 <dons> yep
05:38:27 <dancor> should i just link ghc to runhaskell.  is that what everyone's doing these days.  google isn't talking
05:38:32 <ndm> malcolm: do send --output filename, then email that normally
05:38:59 <dons> mm. we should all be thankful for our daily curry: http://tinyurl.com/y5593h
05:39:00 <ndm> dancor: runghc should be linked to runhaskell
05:39:01 <lambdabot> Title: Currying
05:39:08 <dons> (currying in ruby, yikes!)
05:39:19 <dons> dancor: hmm, or update to ghc 6.4.2?
05:41:24 <nornagon> dons: mmm, ruby
05:41:51 <dons> they try so hard
05:41:51 <malcolm> dons: received my patch bundle yet?
05:42:07 <dons> nothing yet
05:42:53 * malcolm wonders if anyone knows how to configure postfix on MacOS X 10.4
05:44:02 <noj> $EDITOR/etc/postfix/* ?
05:44:12 <noj> $EDITOR /etc/postfix/* ? even
05:44:29 <dons> malcolm: coming to the hackathon? :)
05:44:44 <malcolm> noj: yeah, but I'm sure apple must have a nice GUI widget to make it easy :-)
05:44:57 <dancor> ok i was just running sudo when it wasn't time for that.  however i have been stymied again: Setup.hs: cannot satisfy dependency fps-any
05:45:09 <dons> ?where fps
05:45:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
05:45:10 <noj> malcolm, not for OS X Client, Server version though, I think.
05:45:22 <dons> dancor: ^^ package yourself up :)
05:45:29 <dancor> oh, i'm gonna
05:46:51 <noj> dons, if I wanna have a shot at updating the ghc port in OpenBSD, where should I begin? Should I try for 6.6 or 6.4.2?
05:47:04 <dons> I reckon go for 6.6
05:47:08 <dons> since you get a working ghci then
05:47:16 <noj> that would be nice
05:47:18 <dons> (I'm using ghc 6.6 on openbsd right now)
05:47:32 <dancor> wait can you actually like paste into ghci 6.6
05:47:39 <dancor> instead of having to put in let's
05:47:53 <dons> you migth want to look at the python stuff, to have separate 6.2 and 6.6 subdirs
05:48:07 <dons> then you won't have to worry about breaking the other ports
05:48:10 <noj> ok
05:49:08 <noj> I tried compiling 6.6 with the port version, 6.2.2 and my box hung
05:49:27 <dons> oh? interesting
05:49:39 <dons> i've only tried it with 6.4.2 built with 6.2.2
05:49:40 <noj> don't know why. maybe a bug in 4.0-current or something
05:50:02 <nornagon> hr, clean requires that the coder use function composition to do pointfree stuff
05:50:17 <dons> nornagon: that's usual isn't it? :)
05:50:24 <nornagon> i mean
05:50:30 <dons> ?pl \f g x y -> f (x (g y) x)
05:50:30 <lambdabot> (. (join . (flip .) . flip (.))) . (.) . (.)
05:50:37 <nornagon> scary.
05:50:39 <dons> function composition for all!
05:51:00 <dons> ?pl \f g x y -> f (g x y)
05:51:01 <lambdabot> (.) . (.)
05:51:28 <nornagon> f = g . h . i . j . k <-- can't you just write that as f = g h i j k ?
05:51:38 <dons> nope
05:51:41 <nornagon> oh.
05:51:45 <nornagon> nevermind then :)
05:53:51 <dylan> ?type (\f g h u j k -> g h i j k)
05:53:53 <lambdabot> Not in scope: `i'
05:54:08 <dylan> ?type (\f g h i j k -> g h i j k)
05:54:10 <lambdabot> forall t t1 t2 t3 t4 t5. t5 -> (t -> t1 -> t2 -> t3 -> t4) -> t -> t1 -> t2 -> t3 -> t4
05:54:31 <Cro> hi all.
05:55:16 <Cro> This is the Haskell programmers' community, right?
05:55:27 <dons> yep!
05:55:39 * Cro jumps with joy.
05:55:40 <dons> > map (^2) [1..]
05:55:42 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
05:55:55 <dons> welcome :)
05:56:00 <Cro> Thanks.
05:56:04 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint
05:56:05 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:56:29 <ToRA> @type fix
05:56:30 <lambdabot> forall a. (a -> a) -> a
05:56:35 <dons> Cro: and you know about http://haskell.org ?
05:56:37 <lambdabot> Title: Haskell - HaskellWiki
05:56:40 * malcolm is interested in the Hackathon in Oxford
05:56:43 <dons> the best place to find tutorials, libraries, and so on
05:56:48 <dons> malcolm: great.
05:56:51 <Cro> Yes, that's how I found this channel.
05:57:11 <dancor> lambdabot does infinite lists, that's amazing
05:57:27 <Cro> I find it hard to learn a language if I don't have someone to discuss it with...
05:57:39 <Cro> ... and I couldn't find a single Haskell enthusiast in Croatia.
05:57:41 <dons> yeah, this channel should help there. feel free to hang out and learn
05:57:51 <dons> ah, have you seen our new croatian channel?
05:57:54 <dons> #haskell.hr
05:58:08 <dons> we have 2 croatian haskellers, that i know of
05:58:29 <Cro> great!
06:02:32 <Cro> are there any channel guidelines or rules i should be aware of?
06:02:39 <Cro> Besides the usual.
06:03:30 <dons> only the usual: have fun!
06:03:36 <Cro> :-)
06:03:38 <Cro> And learn!
06:04:00 <dons> anything else is here: http://www.haskell.org/haskellwiki/IRC_channel
06:04:02 <lambdabot> Title: IRC channel - HaskellWiki, http://tinyurl.com/utxdx
06:04:41 <dons> malcolm: your patches have arrived
06:04:59 <dons> oh, interesting:
06:05:00 <dons> +#ifdef __NHC__
06:05:00 <dons> +#define assert  assertS "__FILE__ : __LINE__"
06:05:02 <Cro> I saw that page.
06:05:04 <dons> malcolm++
06:05:25 <malcolm> dons: hurrah.  Remember what I originally said though - you might think some of the renaming of things is a step too far.
06:05:39 <Cro> And read a lot of wiki, including the great article on requesting homework help.
06:05:47 <dons> malcolm: yes, i'll look carefully
06:05:56 <dons> Cro: heh :)
06:06:16 <Cro> I have a different problem, though... I'm willing to learn, but don't have any homework :-)
06:06:35 <Cro> I'm not an IT student/pro, just enthusiast...
06:06:35 <dons> do you have YAHT yet?
06:06:37 <dons> ?where yaht
06:06:38 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
06:06:44 <Cro> Yes.
06:07:04 <dons> or you could do the ruby quiz problems: http://www.haskell.org/haskellwiki/Haskell_Quiz
06:07:06 <lambdabot> Title: Haskell Quiz - HaskellWiki, http://tinyurl.com/y6afxw
06:07:14 <Cro> Thanks.
06:07:23 <Cro> I also found SICP very helpful.
06:09:35 <yaxu> dons: i would like to continue that language-design-for-performance discussion we started a couple of weeks back sometime
06:09:59 <dons> yes sure. its a bit late here, but if you want to do that in depth, mail me
06:10:04 <dons> ?time dons
06:10:07 <lambdabot> Local time for dons is Thu Nov 23 01:06:09 2006
06:10:24 <yaxu> ok will do that cheers
06:10:26 <opqdonut> ?time opqdonut
06:10:30 <lambdabot> Local time for opqdonut is Wed Nov 22 15:55:07 2006
06:10:41 <opqdonut> cool :)
06:10:42 <dancor> lb does everything
06:10:43 <dons> :)
06:10:47 <Svrog> hi
06:10:51 <dancor> ?legalCounsul
06:10:51 <lambdabot> Unknown command, try @list
06:10:56 <dons> hey Svrog, how's code?
06:11:05 <Svrog> not too bad
06:11:09 <Igloo> opqdonut: I think your clock is probably wrong, though  :-)
06:11:12 <Svrog> i have a question regarding point-free style in haskell
06:11:22 <yaxu> ?time yaxu
06:11:37 <Svrog> is it possible to rewrite something like this in point-free style: test x y = putStrLn x >> putStrLn y
06:11:49 <dons> ?pl test x y = putStrLn x >> putStrLn y
06:11:49 <lambdabot> test = (. putStrLn) . (>>) . putStrLn
06:11:54 <Svrog> oh
06:11:54 <yaxu> my irc client isn't good enough i guess
06:12:09 <Svrog> nice :)
06:12:09 <Igloo> Svrog: I wouldn't recommend doing so, though
06:12:17 <Svrog> how come?
06:12:23 <dons> that's pretty obfuscated
06:12:33 <dons> no one likes (. f) -- hard on the brain I find
06:12:34 <Svrog> hah - i thought there was another reason
06:12:36 <Igloo> In 6 months time when you read the code, will you know what (. putStrLn) . (>>) . putStrLn does?
06:12:51 <Svrog> i think it's a matter of getting used to it - much like programming in apl and j
06:13:05 <dancor> svrog is in it for the long haul
06:13:09 <dons> heh
06:13:29 <dancor> variables be damned
06:13:39 <Svrog> hehe
06:13:41 <Cro> lol
06:13:57 <opqdonut> Igloo: it is ^^
06:14:01 <Cro> is it *bad* not to use point-free?
06:14:20 <Svrog> actually once i figure out how (. putStrLn) . (>>) . putStrLn works i think i should be able to remember in a few months time too
06:14:44 <Svrog> i dont see using or not using point-free as bad
06:14:49 <Svrog> it's good practice
06:14:55 <norpan> using unreadable code is bad
06:14:56 <Svrog> especially since im trying to learn j as well :)
06:15:28 <dons> ?wiki Pointfree
06:15:28 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
06:15:39 <dons> ponder why there's a link to 'obfuscation' on that page ;)
06:15:51 <dons> ?unpl (. putStrLn) . (>>) . putStrLn
06:15:52 <lambdabot> (\ d j -> (putStrLn d) >> (putStrLn j))
06:15:57 <dons> not too bad!
06:16:04 <dons> but even our tools have trouble unfactoring pointfree style
06:16:06 <dons> its hard
06:16:12 <sieni> ?unpl (+)
06:16:13 <lambdabot> (+)
06:16:33 <dancor> dons: fps says Registering fps-0.8...
06:16:37 <osfameron> and they say perl looks like line noise...
06:16:37 <dons> good
06:16:47 <Igloo> dons: Why d and j, OOI?
06:16:54 <dancor> dons: but yi says Could not find module `Data.ByteString.Base':
06:16:59 <Igloo> Did the other letters get optimised out or something
06:17:01 <sieni> why not (\x y -> (+) x y) ?!?!
06:17:04 <Svrog> well according to pretty much everyone I've talked to j and apl are unreadable
06:17:06 <dancor> is it supposed to go in /opt/ghc/lib/ghc-6.4.2/imports/Data
06:17:19 <Svrog> and imo j is one of the few languages worth learning
06:17:23 <dancor> because Array/ is there and stuff but ByteString is not!
06:17:28 <Cro> a language becomes readable once you learn it
06:17:50 <dancor> i like svrog's extreme stance
06:17:55 <dons> Igloo: no idea. ask kpreid
06:18:03 <dons> dancor: you using the darcs version of yi?
06:18:09 <dancor> dons: yeh
06:18:15 <dancor> maybe i'm not ready for that
06:18:32 <dons> ok, rerun yi's configure
06:18:38 <dons> it should pick up that you've installed fps now
06:19:01 <dancor> ok got it
06:19:03 <dancor> duhhh
06:19:09 <Cro> ruby quiz downloaded so i'm off to do some work.
06:19:23 <sieni> or even (\x y -> (\x y -> (+) x y) x y)
06:19:29 <Cro> thanks for the hint, i'll come back when i have some questions... or something to show... or it's just raining and boring :-)
06:20:26 <dancor> i become unable to solve obvious problems when i'm unsure of myself and my build environment
06:21:22 <dancor> yi is amazing.  i need to define :x immediately tho
06:21:33 <dancor> momma didn't raise no exit verbosity
06:27:41 <Svrog> are there any haskell expressions that cannot be written in point-free style?
06:28:51 <Igloo> dcoutts dcoutts_: Can you have multiple packages with the same name installed?
06:28:59 <Cale> Svrog: well, there's case
06:29:14 <Svrog> good point
06:29:32 <dons> but then there's always a maybe or either to abstract over the case ;)
06:29:43 <Svrog> hehe
06:29:46 <Cale> The monad instance for ((->) e) helps a lot in making things points-free.
06:30:05 <Svrog> cool
06:30:07 <dons> yeah, breaks the (f x y) barrier
06:30:08 <Cale> Basically, it gives you an automatic solution to eliminating duplication of parameters
06:30:20 <Svrog> oh
06:30:21 <dons> ?pl \x -> x * x
06:30:22 <lambdabot> join (*)
06:30:54 <dons> there's probably a paper on bananas/lenses with the -> a monad.
06:30:57 <dons> Cale, want to write it?
06:31:13 <Cale> hmm?
06:31:27 <Cale> ?pl \x -> f x * g x
06:31:27 <lambdabot> liftM2 (*) f g
06:31:31 <dons> i'm not sure the pointfree uses of instance Monad (-> a) have been documented anywhere
06:31:46 <Cale> (a ->), if you want section notation :)
06:32:06 <dons> we just started using it in here, and TheHunter added it to @pl (stroke of genius)
06:32:19 <Svrog> which section of the GHC docs talks about that?
06:32:24 <dons> but do you know of any paper that talks about using ((->) a) this way?
06:32:34 <dons> to solve, e.g., liftM2 (*) f g
06:32:46 <dons> I remember Wadler being surprised by this use of liftM2 last year
06:32:52 <Cale> Well, I almost wouldn't use the abstract operations right away
06:33:09 <Cale> It's easier to work in do-notation to start with.
06:33:25 <dons> certainly
06:33:36 <dons> but has it ever been written up?
06:33:41 <Cale> I don't know
06:33:44 <Svrog> ive used liftM a fair bit already with parsec
06:34:49 <Cale> Here, you want to calculate \x -> f x * g x, and so that involves computing f and g at the shared parameter x, and then combining the results with *, so we get: do {v <- f; w <- g; return (v * w)}
06:35:11 <Svrog> oh
06:35:30 <Cale> which we recognise as liftM2 (*) f g
06:37:14 <Cale> > let f = (+1); g = (*2) in (do {v <- f; w <- g; return (v * w)}) 5
06:37:22 <lambdabot>  60
06:38:03 <Svrog> hmm.. and that works for any f and g functions? even ones that don't use monads?
06:38:06 <Cale> > let f = (+1); g = (*2) in (liftM2 (*) f g) 5
06:38:08 <lambdabot>  60
06:38:20 <Cale> We're only using one particular monad here
06:38:28 <Cale> which is the monad of functions from a given type
06:39:23 <Svrog> typing this into ghci: Control.Monad.liftM2 (*) (\x -> x * x) (\x -> x + x) $ 5
06:39:26 <Svrog> returns: No instance for (Monad ((->) a))
06:39:33 <Cale> import Control.Monad.Reader
06:39:34 <Svrog> what am i missing?
06:39:36 <Svrog> ah
06:39:38 <Svrog> cool
06:39:43 <Cale> or Control.Monad.Instances in newer GHCs
06:39:58 <Svrog> thanks :)
06:40:04 <Cale> the monad we're using is isomorphic to the Reader monad, just unwrapped
06:40:29 <dons> Cale: you should write an article entirely devoted to use of Monad ((->) a) for the Monad.Reader
06:40:47 <Cale> hehe
06:41:15 <Svrog> it works :)
06:41:38 <Cale> Let's suppose that instead, we want to express the function \x -> f x x
06:42:14 <Cale> well, what is that really doing? It's applying f to the shared parameter x, and then applying *the result of that* to the same shared parameter.
06:42:55 <Cale> So translating that into do-notation, we get do { v <- f; w <- v; return w }
06:43:09 <Cale> which you can simplify and write as do { v <- f; v }
06:43:23 <Cale> which we might recognise as  join f
06:43:28 <Svrog> neat
06:44:20 <Cale> > join (*) 5
06:44:21 <lambdabot>  25
06:47:18 <Cale> One nice thing about this instance of Monad, is the Functor instance which comes along with that
06:48:43 <Cale> liftM f g = do { v <- g; return (f v) }
06:48:52 <Svrog> im just reading the section on control.monad.instances
06:49:05 <Cale> So it computes v = g x
06:49:09 <Cale> and then applies f to that
06:49:10 <Svrog> nice
06:49:20 <Cale> so liftM f g = f . g
06:49:37 <Cale> In fact, one really nice thing to do is to rename fmap to (.)
06:49:48 <Cale> and use this instance to get back to ordinary composition
06:50:12 <dons> Cale would have this in the Prelude, I wager
06:50:25 <Cale> at which point it makes sense to write things like join (*) . [1,2,3,4,5] = [1,4,9,16,25]
06:50:44 <swiert> Of course! Who can live without covariant homfunctors?
06:51:03 <ndm> no one has flamed my FilePath proposal - i'm almost a bit upset
06:51:18 <dons> ndm, it seems reasonabe
06:51:19 <Svrog> would renaming fmap to (.) break anything?
06:51:26 <Cale> Personally, I don't mind having a rather large Prelude.
06:51:28 <dons> so you need to wait a reasonable time for a reasonable flame
06:51:36 <dons> ;)
06:51:44 <dons> ndm++ proposals, code, the works!
06:51:47 <ndm> i guess, i did cc about 6 people who flamed it to hell last time
06:51:53 <dons> heh
06:51:54 <Cale> Svrog: not as long as the instance of Functor for ((->) e) was present
06:52:02 <Svrog> cool
06:52:16 <ndm> (i thought it was only fair not to have a follow up discussion and not let them spot it)
06:52:30 <swiert> Cale: Are you sure?
06:52:55 <Cale> swiert: well, it reduces to exactly the same definition in the case where function composition makes sense.
06:53:07 <Cale> (when the right parameter is a function)
06:53:52 <Cale> So it might make more things typecheck than before, but it doesn't break code which already typechecks.
06:54:14 <swiert> Yeah. I can see that - I'm just wondering whether there is no way for it to break existing code - for instance, when type annotations suddenly don't match up...
06:54:43 <Cale> any type annotations which are already present will be restrictions of the most general type available
06:54:52 <Cale> (which has become more general after the change)
06:55:20 <Cale> The real problem with the proposal is that it raises the bar a little bit for newbies :)
06:55:33 <Svrog> i gotta save this irc transcript - this is just too cool :)
06:56:15 <Cale> This is partially fixable by lying, but would be better fixed by explaining Functors right away.
06:57:19 <Svrog> most newbies wouldnt use (.) much i would think
06:57:23 <Cale> Seeing as this unifies the idea of 'map' with the idea of 'function composition', obviously functor application is one of the central concepts of functional programming, and so high importance should be given to teaching it :)
06:58:01 <swiert> I'm tempted to believe you. I'm just trying to convince myself there's no exotic corner case anywhere.
06:58:52 <Cale> @type let (.) = fmap in \f g -> ((.) f) . ((.) g)
06:58:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> a
06:58:54 <lambdabot>    Expected type: t -> t -> a1
06:59:05 <Cale> hehe
06:59:23 <Cale> @type let (.) :: (Functor f) => (a -> b) -> (f a -> f b); (.) = fmap in \f g -> ((.) f) . ((.) g)
06:59:24 <lambdabot> (Functor f) => (a -> b) -> (f a -> f b); (.) = fmap in \f g -> ((.) f) . ((.) g) :: forall b (f :: * -> *) a b1. (Functor f) => (b1 -> b) -> (a -> b1) -> f a -> f b
06:59:35 <Cale> ugh
06:59:47 <Cale> that really should break on the last ::
07:00:25 <Cale> @type let (.) :: (Functor f) => (a -> b) -> (f a -> f b); (.) = fmap in \f g -> ((.) (f . g))
07:00:27 <lambdabot> (Functor f) => (a -> b) -> (f a -> f b); (.) = fmap in \f g -> ((.) (f . g)) :: forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
07:00:52 <Cale> and you can see, if you look carefully, that even those are the same type :)
07:02:02 <Cale> the infix (.) there must be the ((->) e) instance, whereas the other ones are general
07:02:29 <Cale> ((.) f) . ((.) g) = ((.) (f . g))
07:02:47 <Svrog> out of curiosity, do you use this stuff a lot in your code?
07:02:55 <Cale> I haven't
07:02:58 <Svrog> oh
07:03:12 <Cale> we found out about this one only a few weeks ago
07:03:19 <Svrog> oh
07:03:22 <Svrog> interesting
07:03:28 <Cale> the join/liftM2 stuff is a good bit older
07:03:33 <Svrog> ah
07:03:39 <Cale> and I do use that
07:03:44 <Svrog> nice :)
07:04:33 <Cale> another really nice source of combinators is Control.Arrow, specifically the trivial instance of Arrow for (->)
07:04:42 <Cale> @type (&&&)
07:04:44 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:05:14 <Cale> if a = (->), then (&&&) :: (b -> c) -> (b -> c') -> b -> (c,c')
07:05:41 <Cale> ((*2) &&& (+1)) 5
07:05:42 <Cale> > ((*2) &&& (+1)) 5
07:05:44 <lambdabot>  (10,6)
07:07:30 <Cale> > map (second (^2)) [1..5]
07:07:31 <lambdabot>  add an instance declaration for (Num (d, b))
07:07:31 <lambdabot>   In an arithmetic sequence:...
07:07:40 <Cale> er, right :)
07:07:57 <Cale> > map (second (^2)) (zip [1..5] [1..5])
07:07:59 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25)]
07:08:04 <Cale> of course...
07:08:20 <Cale> > map (ap (,) (^2)) [1..5]
07:08:21 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25)]
07:09:00 <opqdonut> Cale: wow
07:09:39 <Cale> So, map (second f) . join zip = map (ap (,) f)
07:09:39 <Svrog> im still trying to figure out how that arrows example works haha
07:10:16 <metaperl> @type second
07:10:17 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a b c -> a (d, b) (d, c)
07:10:30 <Cale> replace a b c with (b -> c)
07:10:47 <Cale> because we're only using a = (->)
07:11:01 <metaperl> @type ap
07:11:03 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
07:11:27 <Cale> and there, you want to use m = ((->) e)
07:11:35 <Svrog> yeah - ill need time to figure all this out - but it's definitely very cool
07:11:47 <Cale> so you have ap :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
07:11:52 <Svrog> more useful than stuff ive been able to find online on these topics
07:12:05 <Cale> So we're applying ap to (,) and then to f
07:12:51 <opqdonut> ?fp \x y->((x,y):)
07:12:51 <lambdabot> \x y->((x,y):) not available
07:12:55 <metaperl> [(x, x^2) |   x<- [1..5] ]
07:12:57 <opqdonut> hmm
07:13:03 <Cale> metaperl: exactly :)
07:13:07 <metaperl> > [(x, x^2) |   x<- [1..5] ]
07:13:09 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25)]
07:13:12 <metaperl> :)
07:13:38 <metaperl> that seems a little more straightforward, but I guess Arrows do have their uses
07:13:54 <glguy> ?type (((:) .) . (,))
07:13:55 <lambdabot> forall a a1. a1 -> a -> [(a1, a)] -> [(a1, a)]
07:14:08 <Cale> metaperl: well, these are games in trying to write things points-free
07:14:14 <metaperl> oh
07:14:22 <glguy> opqdonut: ^^
07:14:43 <Cale> ?pl \x y -> ((x,y) :)
07:14:44 <lambdabot> ((:) .) . (,)
07:16:16 <Cale> I bet some too-smart-for-their-own-good IRC clients will mangle that badly :)
07:18:42 <opqdonut> glguy: thanks :)
07:19:27 <kiloboot> kiloboot
07:22:27 <kiloboot> kiloboot2
07:23:17 <kiloboot> kiloboot3
07:25:04 <Svrog> well im off to bed - thanks Cale and dons :)
07:25:10 <kiloboot> sorry. I need "regexp" to make HydraIRC to notify me when message on channel contains my nick. Anyone help me?
07:27:11 <ptolomy> Anybody ever tried to make a shared-suffix Trie in haskell? or know of an implementation?
07:34:43 <kpreid_> @tell Igloo re @unpl "Did the other letters get optimised out or something" -- yes, exactly. the temporary generation is verry stupid
07:34:43 <lambdabot> Consider it noted.
07:36:13 <kpreid_> @tell sieni re @unpl "why not (\x y -> (+) x y) ?!?!" -- because it sees the x and y as useless applications and optimizes them out. as far as it cares (+) is just another variable name. I think it'd be better to generate (\x y -> x + y) but it doesn't do that yet
07:36:14 <lambdabot> Consider it noted.
08:00:58 <xinming> @type choose
08:01:00 <lambdabot> Not in scope: `choose'
08:01:03 <xinming> hmm...
08:02:41 <int-e> @type let choose n 0 = 1; choose n k = choose (n-1) (k-1) * n `div` k in choose
08:02:43 <lambdabot> forall a. (Integral a) => a -> a -> a
08:03:55 <xinming> hmm, anyone here would tell me why choose function won't be imported while we are in ghci? even if we write a test file which imports System.Random
08:05:27 <int-e> because your module doesn't export those functions
08:05:34 <int-e> I guess
08:06:03 <swiert> xinming: you need to import Debug.QuickCheck I think.
08:06:31 <liyang> xinming: it seems that functions won't be imported unless they are actually used in your test file. They are still accessible via the fully-qualified name though, e.g. System.Random.choose (?)
08:06:37 <int-e> @index choose
08:06:37 <lambdabot> Test.QuickCheck, Debug.QuickCheck
08:07:08 <xinming> liyang: No, They won't
08:08:02 <xinming> swiert: thanks, done.
08:08:11 <xinming> I need to import Test.QuickCheck
08:08:26 <swiert> no problem.
08:28:59 * CosmicRay gripes more about haskell-mode.  this one thing might drive me to vim.
08:29:17 <CosmicRay> today I started to type a string that starts with a y.  I typed "y  and haskell-mode converted it into a y with an umlaut, no quote!
08:29:21 <CosmicRay> GRR!
08:30:09 <osfameron> that isn't just standard digraph handling ?
08:30:26 <CosmicRay> no, I am in the US, US keyboard.  when I press a quote, it should display a quote.
08:30:34 <CosmicRay> emacs also doesn't do this for me in other modes.
08:30:59 <osfameron> how odd
08:31:49 <emu> never seen that happen either
08:34:09 <glguy> > let x `notDivides` y = y `mod` x /= 0 in take 10 $ map head $ iterate (\xs -> [x | x <- tail xs, head xs `notDivides` x]) [2..]
08:34:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
08:42:19 <glguy> Nothing's more fun that fixing a bug that doesn't exist
08:44:27 <araujo> hello!
08:45:28 <glguy> oops, I was wrong, sneezing unexpectedly with a mouthful of crackers is more fun
08:47:49 <Oejet> glguy: ...when you are on a date with a very hot girl, who unfortunately are wearing a white shirt.
08:53:18 <norpan> mmmm, white tight t-shirt
08:53:21 <norpan> :)
08:53:23 <earthy> this is *weird*
08:53:57 * earthy has defined a variablerecord with a field 'scheurVliezenMoeder'
08:54:10 <earthy> s/variablerecord/record/
08:54:31 <earthy> calling    Data.Generics.constrFields . Data.Generics.toConstr  outputs that field as 'scheurVliezzenMoeder'
08:55:59 <norpan> yes
08:56:15 <norpan> it seems you have been bitten by the z mangling
08:56:34 <earthy> which is there why, exactly? :)
08:57:12 <Syzygy-> z mangling? What a bizarre idea... Why?
08:57:33 <norpan> ghc does it for symbols in the linker
08:57:54 <norpan> i have no idea why it would appear in this context
08:58:19 <earthy> time for a bug report then? :)
08:58:48 <norpan> yes
08:59:28 <norpan> probably the constrFields function must unmangle again
09:03:54 * araujo `offTo` Eat :: IO Food
09:04:15 <norpan> you mean Food -> IO Excrement?
09:05:20 <araujo> Implementations details are hidden.
09:05:27 * psnl doesn't like having crap returned 
09:06:01 <norpan> araujo: sure, but at least Food is not produced by your eating
09:06:38 <sjanssen> @quote wadler
09:06:38 <lambdabot>  If your map's not accurate and people get lost, it'll act as a filter
09:06:45 <norpan> unless you consider yourself as Food
09:06:49 <sjanssen> ha
09:06:51 <vincenz> sjanssen: lol
09:07:05 <sjanssen> vincenz: see his quote in HWN?
09:07:11 <araujo> norpan, as i told you ... those are implementations details
09:07:13 <psnl> Food -> IO Energy ,surely? the crap is just a side effect
09:07:33 <vincenz> sjanssen: fraid not
09:07:35 <araujo> You can implemente Food in whetever way you want :-)
09:07:36 <sjanssen> @quote wadler
09:07:47 <vincenz> Anyone familiar with lambdabot internals
09:07:48 <lambdabot>  Curried food and curried functions are both aquired tastes
09:07:56 <norpan> @quote norpan
09:07:56 <lambdabot>  the comonad of the No monad is the Yes monad?
09:07:57 <sjanssen> vincenz: "The way we can tell it's C# instead of Haskell is because it's nine lines instead of two."
09:08:21 <vincenz> I wonder why lambdabot repeats URLS -as is- from specbot in #scheme
09:08:26 <sjanssen> vincenz: internals?  I've written a plugin or two, is that enough knowledge?
09:08:28 <vincenz> Normally it makes a shorter one, but it jsut repeats them
09:08:51 <sjanssen> oh, that's strange
09:09:01 <vincenz> Yeah, it doesn't make a mini url, and it just copy pastes them
09:09:09 <psnl> sjanssen: is that in the wadler quotes?
09:09:32 <sjanssen> psnl: yeah, I eventually found it in there
09:09:52 <psnl> were you there?
09:10:21 <sjanssen> no, I'm not even sure where it comes from
09:10:29 <sjanssen> was it that "Fun in the afternoon" event?
09:10:49 <psnl> sjanssen: aye
09:11:13 <psnl> sjanssen: Andrew Kennedy did a talk on why c# is a functional language
09:11:48 <sjanssen> and Wadler got the last laugh, apparently
09:13:00 <sjanssen> I wish I was in .uk, then I could go to these things
09:13:59 <tibbe> do tell!
09:14:03 <tibbe> what happened?
09:15:29 <vincenz> @tell dons Very strange... When specbot in #scheme returns some sort of url to a request, lambdabot literally copies the url.  Now ideally lambdabot would ignore, but ok.  What I find strange is taht it doesn't give the title or a shorturl, but just literally gives a copy of it.
09:15:30 <lambdabot> Consider it noted.
09:17:19 <sjanssen> http://www.google.com -- it still works here, yeah?
09:17:20 <lambdabot> Title: Google
09:18:36 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/#1
09:18:38 <lambdabot> Title: Christophe Poucet
09:18:40 <vincenz> hmm
09:18:57 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/index.html#%_lala_2
09:18:57 <lambdabot> http://homes.esat.kuleuven.be/~cpoucet/index.html#%_lala_2
09:19:00 <vincenz> aha!
09:19:24 <sjanssen> it looks like tinyurl is giving a bogus answer
09:19:28 <vincenz> @tell dons I found the bug.  the reason is that lambabot does not like a url that ends with 'html#%_sometext'  Specifically the % is a problem
09:19:28 <lambdabot> Consider it noted.
09:19:37 <vincenz> sjanssen: no, lambdabot should also give a title
09:19:44 <vincenz> the problem is the #%
09:19:49 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/index.html#%_
09:19:50 <lambdabot> http://homes.esat.kuleuven.be/~cpoucet/index.html#%_
09:19:52 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/index.html#%
09:19:53 <lambdabot> http://homes.esat.kuleuven.be/~cpoucet/index.html#%
09:19:55 <sjanssen> oh, right
09:19:56 <vincenz> yeah
09:20:00 <sjanssen> that should be an easy fix
09:20:07 <vincenz> but is that valid?
09:20:13 <vincenz> The % bt
09:20:18 <vincenz> I thought % was used to escape in urls
09:20:45 <sjanssen> yeah, it is
09:20:57 <vincenz> well it all came from http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_idx_136
09:20:58 <lambdabot> http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_idx_136
09:21:12 <sjanssen> http://homes.esat.kuleuven.be/~cpoucet/index.html#foo
09:21:14 <lambdabot> Title: Christophe Poucet, http://tinyurl.com/y55eon
09:22:29 <vincenz> Yeah it's the % bit
09:22:42 <vincenz> I think tha t either that ul is malformed, or that Network.URI of GHC libs is faulty
09:22:50 <vincenz> Cause I see no special handlign anywhere else in lambdabot for urls
09:23:15 <LoganCapaldo> Hmmm
09:23:18 <sjanssen> vincenz: where are the URLs handled?
09:23:26 <LoganCapaldo> COuld it be that tinyurl is freaking out?
09:23:31 <vincenz> Lib/Url.hs
09:23:35 <vincenz> getHtmlPage
09:23:39 <vincenz> that's the core bit
09:23:43 <glguy> I think I might make a SETI@Home style project to try to generate the same GUID on two different computers
09:23:45 <sjanssen> LoganCapaldo: it works when I copy 'n paste at tinyurl.com
09:23:47 <vincenz> @hoogle getURIContents
09:23:48 <lambdabot> No matches found
09:23:49 <LoganCapaldo> aha
09:24:03 <vincenz> oh, nm
09:24:25 * vincenz shrugs
09:28:01 <vincenz> http://www.%faulty.com
09:28:06 <vincenz> http://www.faulty.com/%fault
09:28:07 <lambdabot> Title: faulty.com
09:28:13 <vincenz> http://www.faulty.com/#%fault
09:28:14 <lambdabot> Title: faulty.com
09:28:21 <vincenz> http://www.faulty.com/i.tml#%fault
09:28:23 <lambdabot> Title: faulty.com
09:28:36 <vincenz> That's odd
09:28:38 <vincenz> http://www.faulty.com/i.tml#%_f
09:28:40 <LoganCapaldo> http://www.happy.com/%_whee
09:28:54 <vincenz> http://www.faulty.com/i.html#%_f
09:29:05 <glguy> does lambdabot use tinyrul for already tiny urls?
09:29:11 <vincenz> no
09:29:28 <vincenz> @arr
09:29:29 <lambdabot> Aye
09:29:36 <vincenz> http://www.faulty.com/index.html#%_f
09:29:42 <vincenz> hmm
09:29:47 <vincenz> Oh, it's too short!
09:30:05 <vincenz> http://www.faulty.com/averylongwebpage/notfindableindex.html#%_f
09:30:06 <lambdabot> http://www.faulty.com/averylongwebpage/notfindableindex.html#%_f
09:30:10 <vincenz> yeah there it is
09:31:16 <vincenz> The bug is in fetchTiny
09:31:18 <vincenz> and it doesn't show a title
09:31:20 <vincenz> as it cant' find one
09:32:28 <vincenz> @tell dons I think I found the bug.  Basically it only happens with long urls, so the bug is in fetchTiny... It seems to also be affected if you append > to a url, meaning the url isn't cut well
09:32:28 <lambdabot> Consider it noted.
09:34:44 <vincenz> @tell dons For the second bug, about >... Basically in "containsUrl" in "Plugin.Url" add more terminators besides just whitespace.  As for the other bug, well I think that the %_ url might be malformed.  But it's better not to print a url if a url is malformed instead of pretending the original url is the short one
09:34:44 <lambdabot> Consider it noted.
09:41:47 * vincenz looks at the invasion of cmeme's
09:41:57 * lispy waves
09:42:11 <lispy> is it code time yet?
09:43:37 <lispy> vincenz: the regexp for checking for valid urls are quite wonky
09:44:17 <LoganCapaldo> what it's not http://.* ? <g>
09:44:19 <opqdonut> impossible, even
09:47:09 <lispy> LoganCapaldo: it's easy when the url is terminated by whitespace, but what if it is terminated by non-alphanumeric characters like '.'
09:49:03 <LoganCapaldo> But urls can contian '.' obviously. And what if I make a typo and forget to put a space after my period when I write the next sentence? The obvious solution is probabilistic determination of urls instead of regular expressions :)
09:49:17 <LoganCapaldo> there could be a @trainurl command
09:49:19 <vincenz> or a proper parsec
09:52:37 <lispy> i think the simplest solution is to use regex and assume they will be wrong once in a while :)
09:54:03 <LoganCapaldo> simple?
09:54:10 <LoganCapaldo> who cares about simple <g>
09:54:15 <ms_> pragmatic?
09:54:40 <russo> hey guys can you take a look if i wrote my bouble sorter correctly?
09:54:41 <lisppaste2> russo. pasted "BubbleSort?" at http://paste.lisp.org/display/30486
09:54:50 <lispy> bouble?
09:54:55 <lispy> oh, bubble
09:55:23 <LoganCapaldo> writing bubblesort with lists mus tbe a PITA
09:55:59 <russo> sorry :D
09:56:01 <russo> i misspel
09:56:05 <russo> misspelled*
09:56:35 <russo> i think thats correct isn't it...
09:56:42 <lispy> russo: your coding style is unconventional for haskell :)
09:57:00 <russo> lispy: :( whats unconventional?
09:57:20 <lispy> take this for example
09:57:21 <lispy> bubbleSort([]) = []
09:57:21 <russo> i mean what specifically
09:57:30 <russo> pattern matching? :D
09:57:32 <lispy> typically we would write that
09:57:34 <russo> haskell has it :)
09:57:38 <lispy> bubbleSort [] = []
09:57:43 <russo> oh i see
09:57:46 <russo> yeah thats true
09:57:49 <russo> i'm used to opal :)
09:57:55 <russo> well rather thats what i have to do my hw in
09:58:05 <lispy> (not the spacing and the lack of parens)
09:58:13 <lispy> er note*
09:58:23 <lispy> but anyway, none of that really matters
09:59:54 <russo> i know that that also works fine
09:59:57 <glguy> > let bubbleSort xs = iterate f xs !! length xs where f (a:b:c) | a < b = a : f (b:c) | otherwise = b : f (a:c); f xs = xs in bubbleSort [1,5,2,6,8,3,5]
09:59:59 <lambdabot>  [1,2,3,5,5,6,8]
10:00:01 <russo> i actually didn't think about it at all
10:00:09 <lisppaste2> glguy pasted "what i jsut typed indented" at http://paste.lisp.org/display/30487
10:00:30 <russo> lispy: i wrote quicksort and a ton of other stuff... so i don't feel like changing all of tha tnow
10:01:44 <lispy> russo: also, usually when a parameter is a list we name it xs, ys, or zs or as or something, which you read as the plural of that thing
10:01:54 <lispy> xs -> 'exes'
10:03:44 <russo> oh okay :0
10:03:47 <russo> :) *
10:04:06 <russo> do you do ft:rt though?
10:04:11 <russo> or a:b ?
10:04:18 <russo> whats the convention there
10:04:19 <lispy> usually x:xs
10:04:22 <russo> oh i see
10:04:39 <russo> hmm
10:04:45 <russo> noone beat me into convetion
10:04:51 * russo taught himself haskell
10:04:51 <russo> :)
10:05:01 <lispy> :)
10:05:16 <russo> ugh... i meant noone beat convetion into me
10:05:22 <lispy> bubbleRepeater(bubbleSorter(a),(n-1))
10:05:39 <lispy> normally we'd put spaces before the parens
10:05:44 <russo> iyes
10:05:45 <russo> i know
10:05:50 <lispy> and none around the a
10:06:02 <russo> i know i know :)
10:06:02 <vincenz> not to mention, passing tuples is bad
10:06:07 <lisppaste2> glguy annotated #30487 with "slightly more efficient bubblesort, if such a thing exists" at http://paste.lisp.org/display/30487#1
10:06:13 <vincenz> bubbleRepeater (bubbleSorter a) (n-1)
10:06:19 <russo> lispy: woudln't i need that for the tuple
10:06:24 <russo> vincenz: does that work?
10:06:34 <lispy> it would work if you change one type sig
10:06:52 <vincenz> constructing and destructuring tuples is inefficicent and pointless :)
10:07:01 <lispy> if you avoid tuples you get partial function application for free because of haskell's syntax
10:07:05 <russo> is quick sort the most effective?
10:07:19 <glguy> merge sort is
10:07:25 <russo> do you type Int x Int in haskell
10:07:26 <lispy> quicksort has a good complexity, but it's unstable
10:07:35 <russo> when you want a function with 2 parameters
10:07:46 <russo> or do you just make a tuple?
10:07:59 <lispy> (+) :: Int -> Int -> Int -- plus restricted to ints
10:08:01 <russo> i always made tuples... but that may not mean that its not possible
10:08:06 <vincenz> qsort [] = []; qsort (x:xs) = qsort (filter (< x) xs) ++ x:qsort (filter (>= x) xs)
10:08:30 <Oejet> russo: f x y =... or f (x,y) =...
10:08:38 <russo> i have a quicksort
10:08:40 <lispy> glguy: heap sort is another good sort
10:08:44 <vincenz> Hey Oejet, we missed you at icpc
10:08:48 <vincenz> You kinda dropped out completely
10:08:56 <glguy> I just meant that mergesort performs well using singlely-linked lists
10:08:58 <vincenz> icfpc even
10:09:01 * lispy leaves for work
10:09:24 * vincenz works for leaves
10:09:29 <lispy> glguy: heap sort too and heapsort always takes the same number of operations :)
10:09:32 <lisppaste2> russo. pasted "QuickSort" at http://paste.lisp.org/display/30489
10:09:46 <Oejet> vincenz: Yep, unfortunately I had other obligations.  Too bad, because you did quite well.
10:09:49 <vincenz> russo: stop tupling arguments
10:09:51 <russo> it always loses the spacing :)
10:09:52 <vincenz> Oejet: yeah :)
10:09:57 <norpan> sort =fst . filter isSorted . permutations
10:10:04 <norpan> there you go, it's on the house
10:10:12 <russo> how would i right that in non tuples?
10:10:13 <vincenz> norpan: you mean head
10:10:15 <vincenz> not fst
10:10:17 <russo> write*
10:10:19 <glguy> ok, who can sorten i?
10:10:20 <glguy> bubbleSort = join (foldl (const . f))
10:10:21 <glguy>  where f (a:b:c) = min a b : f (max a b:c)
10:10:21 <glguy>        f xs = xs
10:10:30 <glguy> shorten*
10:10:32 <norpan> i mean head
10:11:04 <vincenz> @type \f -> join (foldl (const . f))
10:11:05 <lambdabot> forall b. ([b] -> [b]) -> [b] -> [b]
10:11:07 <russo> vincenz: what did you mean without tuples... i don't see how that would work without tuples..
10:11:11 <tibbe> norpan: that's exponential :)
10:11:26 <norpan> exponential is good, it heats your house
10:11:36 <tibbe> true
10:12:01 <tibbe> i have a neural network app that managed to heat my cpu like nothing else
10:12:30 <russo> tibbe: it happens i had one in C++ a while back like that :)
10:12:51 <russo> bubbleSort with 5000 integers works well too :)
10:13:22 <norpan> tibbe: if permutations does the right thing, it's constant time for sorted lists at least
10:13:33 <norpan> err, linear time
10:14:19 <lisppaste2> vincenz annotated #30489 with "tuppleless" at http://paste.lisp.org/display/30489#1
10:14:23 <vincenz> russo: like ethat
10:14:51 <vincenz> tupling arguments is bad practice
10:14:57 <tibbe> norpan: you mean that the first permutation will be right one?
10:15:11 <norpan> tibbe: exactly
10:15:12 <tibbe> you don't need sort for sorted lists ;)
10:15:18 <tibbe> it's constant then even
10:15:21 <tibbe> or hmmm
10:15:25 <vincenz> tibbe: but he generates all perms!
10:15:26 <tibbe> well depends
10:15:28 <norpan> it's constant if you KNOW it's sorted
10:15:40 <vincenz> norpan: so bestcase it's O(1)
10:15:47 <tibbe> vincenz: lazily and pick the first which is the correct one? :)
10:15:48 <russo> is filter just a function for lists that filters out ones you don't want
10:15:48 <vincenz> norpan: which is not true for other sort methods ;)
10:15:58 <vincenz> ys
10:16:00 <vincenz> yes
10:16:06 <vincenz> russo: I suggest you loko at yaht
10:16:08 <glguy> filter picks the oens that you *do* want
10:16:11 <vincenz> @where yaht
10:16:12 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
10:16:12 <norpan> i can easily make a sort algorithm that is O(1) if it's allowed to return the wrong answer :)
10:16:15 <russo> whats the syntax for filter
10:16:28 <vincenz> @type filter
10:16:30 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:16:32 <vincenz> syntax? it's just a function
10:16:35 <vincenz> russo: really, look at yaht
10:16:50 <glguy> the best case of the permutation genating sort algorith mis O(n) since you have to check if the first result is sorted
10:17:05 <vincenz> ah yeah
10:17:07 <norpan> yes, that's what i said, linear
10:17:19 <vincenz> heh, but if t's sorted
10:17:22 <glguy> I'm reading about every other IRC line to keep up
10:17:25 <vincenz> I can give you a O(1) func
10:17:32 <norpan> sort = id
10:17:33 <glguy> id?
10:17:36 <glguy> heh
10:18:03 <palomer> are there any papers on the haskell glasgow compiler?
10:18:08 <russo> thanks vincenz
10:18:10 <norpan> sort = const []
10:18:12 <vincenz> I can return a sorted partial list
10:18:14 <vincenz> norpan: exactly
10:19:06 <norpan> or even
10:19:09 <norpan> sort = take 1
10:19:13 <tibbe> glguy: then I'll repeat everything twice so you dont miss anything
10:19:20 <vincenz> ultraEfficientEncryptionCompressionSystem :: String -> String; ultraEfficientEncryptionCompressionSystem = const []
10:19:37 <tibbe> > filter (>3) [1,2,4,5,3,7]
10:19:39 <lambdabot>  [4,5,7]
10:19:58 <vincenz> russo: small suggestion, no point in filtering out the == x
10:20:02 <vincenz> russo: just do < and >=
10:20:07 <vincenz> or <= and >
10:20:11 <glguy> > [x | x <- [1,2,4,5,3,7], x > 3] -- demonstrating equivalence for russo's benefit
10:20:13 <lambdabot>  [4,5,7]
10:21:03 <tibbe> > [1,2,3,4,5] >> guard (>1)
10:21:05 <lambdabot>    Expecting a function type, but found `Bool'
10:21:05 <lambdabot>    Expected type: Bool
10:21:05 <lambdabot>  ...
10:21:10 <russo> vincenz: true...
10:21:15 <vincenz> qsort [] = []; qsort (x:xs) = let (a,b) = partition (< x) xs in qsort a++x:qsort b
10:21:30 <tibbe> > do x <- [1,2,3,4,5] ; guard (x > 3)
10:21:31 <lambdabot>  [(),()]
10:21:40 <tibbe> um, not what I wanted
10:21:44 <ndm> @index guard
10:21:45 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:21:50 <tibbe> always mess up in the list monad
10:21:54 <vincenz> guard is m ()
10:21:57 <tibbe> feels unnatural to me
10:22:04 <glguy> tibbe: do x <- [1,2,3,4,5] ; guard (x > 3); return x
10:22:09 <vincenz> > do x <- [1..5]; guard (x>3); return x
10:22:11 <lambdabot>  [4,5]
10:22:14 <tibbe> ah
10:22:15 <tibbe> return
10:22:23 <fasta> Heh, I knew that :)
10:22:26 <russo> vincenz: in our lecture (for another language) we did == too
10:22:35 <vincenz> russo: ah well
10:23:02 <russo> i remember now he said it isn't necessary but nicer :P
10:23:22 <vincenz> sure
10:23:23 <vincenz> so is doing
10:23:28 <vincenz> while (true) ;
10:23:56 <tibbe> what's the function of the month?
10:24:07 <vincenz> tibbe: intercalate
10:24:17 <tibbe> ah yes
10:24:51 <fasta> We have a function of the month?>
10:24:58 <vincenz> now we do
10:25:07 <tibbe> > let intercalate x = concat . intersperse x in intercalate " " ["intercalate", "is", "the", "function", "of", "the", "month"]
10:25:08 <lambdabot>  "intercalate is the function of the month"
10:25:28 <glguy> while (true) ; looks like an ugly version of for(;;);
10:25:47 <fasta> while true is readable
10:25:55 <fasta> for (;;) is a "trick"
10:26:26 <glguy> I think it was the obsd kernel guidelines that said for(;;) was prefered
10:26:41 <CosmicRay> yet another reason to avoid obsd ;-)
10:26:44 <tibbe> probably some voodoo efficiency reason ;)
10:26:58 <glguy> I don't remember what caused me to start using for(;;) exclusively, but I do
10:27:04 <glguy> I read it as "forever"
10:27:17 <pkhuong> tibbe: probably maintenance, actually; it's open.
10:27:19 <tibbe> where I'm doing my internship they don't use any getters or setters in their C++ code because it's inefficient...
10:27:28 <psykotic> i use while (1). for (;;) is an eyesore. :)
10:27:29 <fasta> OpenBSD is insecure ;)
10:27:42 <glguy> all operating ssystems are insecure
10:27:44 <Philippa_> I like for(;;), though it's odd the first time you meet it
10:27:45 <psykotic> tibbe, are they stupid?
10:27:46 <glguy> OpenBSD is just less insecure
10:28:07 <pkhuong> tibbe: define them inline, not abstract, and there's no efficiency! :|
10:28:07 <Philippa_> I think while (1)'s only better because it's a wider-spread idiom
10:28:10 <tibbe> psykotic: yes, they also keep a binary blob in their DB and decode fields manually from it
10:28:19 <psykotic> that settles it
10:28:23 <tibbe> yes
10:28:31 <tibbe> they're daily wtf material for sure
10:28:51 <tibbe> they don't write tests either because they don't have time
10:29:01 <glguy> tibbe: what are you doing that needs such efficiency that they will sacrifice any good coding sense for raw apparent speed?
10:29:01 <tibbe> because they are busy correcting bugs
10:29:21 <tibbe> glguy: airline ticketing
10:29:38 <psykotic> tibbe: that kind of thing is even worse in a company culture where you have a test department. the devs don't worry too much about making sure their shit works, they just hammer it out and throw it over the wall to the test monkeys.
10:29:42 <glguy> ah, that makes sense, I've never heard of an airline ticketing system that didn't scerw people over
10:29:53 <tibbe> glguy: and I doubt it's efficient, since transfering that damn blob wastes bandwidth when they only want a few fields
10:30:08 <glguy> tibbe: that's why I said "apparent efficiency" ;)
10:30:13 <tibbe> :)
10:30:23 <tibbe> I call that kinda stuff voodoo efficiency
10:30:25 <glguy> it sounds like they just don't know what the ehll they are doing
10:30:27 <tibbe> ie they don't measure
10:30:29 <tibbe> they gues
10:30:45 <tibbe> did I mention that I declined their job offer?
10:30:50 <glguy> I bet that they didn't so much chose that method for it's efficiency as they didn't know any better
10:30:56 <vincenz> I was afk
10:31:01 <vincenz> coming back to for(;;);
10:31:08 <vincenz> forloops are syntactic sugar for whileloops
10:31:09 <psykotic> tibbe: if they bothered doing a gcc -S they'd see about the getter/setter thing immediately. otoh there are people who are overoptimistic and think the compiler makes things magically go fast. :)
10:31:26 <psykotic> like c++ people who seem completely ignorant of template bloat.
10:31:34 <tibbe> psykotic: yeah, plenty of both hence measure :)
10:32:12 <vincenz> template bloat is a compiler deficiency
10:32:17 <fasta> psykotic: template bloat?
10:32:30 <vincenz> but OT, I suggest #oasis for these kinds of conversations *whistles*
10:32:31 <glguy> The one thing about C++ i didn't like while programming in it for college were all of the special cases you had to be aware of
10:32:32 <psykotic> vincenz, it's very hard for compilers to factor things optimally.
10:32:35 <psykotic> vincenz, sorry :)
10:32:37 <fasta> psykotic: AFAIK, template writers can write them in such a way that users don't notice.
10:32:48 <fasta> psykotic: in some cases at least.
10:33:02 <vincenz> A good liner and template compiler should generate pretty good code
10:33:05 <vincenz> s/liner/inliner
10:33:08 <psykotic> fasta, sure, for instance if you're writing a an array template class you should write one version for void* and have all the T* versions use it, etc.
10:33:24 <psykotic> vincenz, have you tested this assumptions? template bloat is a huge issue with every c++ compiler on the market.
10:33:36 <psykotic> you have to very carefully factor things to fight it.
10:33:44 <fasta> I don't like the lack of discovarability in C++.
10:33:46 <psykotic> anyway, OT, sorry.
10:33:57 * tibbe is sorry too
10:33:59 <vincenz> (send-to #oasis (call/cc call/cc)0
10:34:02 * vincenz winks
10:34:16 * glguy isn't sorry, #haskell is about many things ;)
10:34:19 <tibbe> so, I need a category-theory-in-24-minutes-crach-course
10:34:53 <Philippa_> vincenz: "good" may prove to be unachievable
10:35:07 <Philippa_> especially with a language like C++ involved
10:35:07 <psnl> I think the shortest is Category-theory-in-24-years, but you could just wave your hands and make it up
10:35:19 <tibbe> i like that
10:35:21 * tibbe waves
10:35:50 <Codex_> tibbe: id. composition. arrow. morphism. diagram commutes.  // here's your 24 minutes crash course.
10:35:55 <vincenz> Philippa_: tell me aobut it
10:35:57 * vincenz sighs
10:36:01 <psnl> tibbe: use every letter and symbol you can think of
10:36:05 <tibbe> the jump from having an okay understanding of monads to the next step feels huge
10:36:16 <cjeris> tibbe: "Many parts of mathematics behave like they're made of arrow diagrams."
10:36:29 <tibbe> :)
10:37:02 <cjeris> tibbe: Actually, the "Slogans" in the first chapter of Lambek/Scott, Introduction to higher order categorical logic, were useful to me in getting oriented.
10:37:30 <cjeris> tibbe: But if you're still struggling with the idea of a functor then that text is probably too telegraphic.
10:38:27 <tibbe> I mean, in many languages there's an initial hump you need to get over but in haskell you need to do quantum tunneling
10:38:41 <tibbe> I need a better grip of functors
10:41:49 <cjeris> tibbe: i don't understand the role of category theory in haskell very well myself.
10:42:17 <tibbe> it's not just CT, type theory and all this morphism stuff :)
10:42:37 <tibbe> hylo there and ana here
10:42:45 <tibbe> ?type foldr
10:42:47 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
10:42:53 <tibbe> ?type foldr
10:42:55 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
10:42:57 <tibbe> ?type scanr
10:42:59 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> [b]
10:43:09 <opqdonut> yay, i just understood ((:).).(,)
10:43:35 <opqdonut> ?type  ((:).).(,)
10:43:36 <lambdabot> forall a a1. a1 -> a -> [(a1, a)] -> [(a1, a)]
10:43:54 <opqdonut> >  ((:).).(,) $ 1 2 []
10:43:56 <lambdabot>  add an instance declaration for (Num (t -> [a1] -> a))
10:44:09 <opqdonut> > (((:).).(,)) 1 2 []
10:44:10 <lambdabot>  [(1,2)]
10:44:32 <cjeris> > (((:).).(,)) 1 2 [(3, 4)]
10:44:34 <lambdabot>  [(1,2),(3,4)]
10:45:24 <cjeris> Point-free programming in Haskell: All the "why won't the compiler take it?" aggravation of typeful functional languages, combined with the readability and maintainability of J.  :D
10:45:43 <opqdonut> :)
10:50:09 <palomer> anyone know how to escape \ in listings?
10:50:21 <palomer> and how to insert latex stuff?
10:51:19 <metaperl> oh my god, that is cryptic
10:54:46 <glguy> J wins on cryptic points
10:54:53 <glguy> and giving you a special feeling when you code it
10:55:05 <glguy> that even if someone was looking over your shoulder to steal your brilliant idea...
10:55:11 <glguy> that they wouldn't know what that idea was
10:55:25 <glguy> it's just you and the compiler ;)
10:55:48 <tibbe> whitespace
10:56:06 <tibbe> try to look over the should of a whitespace programmer!
10:56:13 <glguy> yeah yeah yeah :-p
10:57:22 <opqdonut> hehe guess i should learn J, just looked it up in wikipedia
10:57:40 <glguy> the tacit quicksort line is mine =D
10:57:50 <opqdonut> btw, there's a whitespace mode for emacs with syntax hilighting :)
10:57:52 <opqdonut> glguy: wow
10:57:55 <opqdonut> gz
10:59:19 <glguy> in J, if x and y are values, and f g h are functions
10:59:33 <glguy> x (f g h) y means: (x f y) g (x h y)
10:59:45 <glguy> in J, functions have one or two arguments, a right, or a right and a left
11:00:12 <glguy> and x (f g) y means:  x f (x g y)
11:01:39 <glguy> I can't imagine writing anything of substance in J, but apparently many people do
11:03:57 <glguy> anyone where do any Python programming?
11:06:34 <glguy> -w
11:07:29 <psnl> aye
11:07:39 <psnl> what about it?
11:08:08 <glguy> I was curious what kind of functional programming techinques it supported (that were considered "Pythonistic")
11:08:16 <glguy> basically, what you thought about it from a Haskell point of view
11:08:33 <glguy> We were reading about IronPython for ASP.NET at work today
11:08:42 <glguy> but I dont' know much about the language itself
11:08:56 <glguy> I figured that it had to be pretty flexible if MIT was going to use it for their Course VI series
11:09:41 <wolverian> well, Guido is removing all FP the from it (the little there is) :)
11:10:09 <psnl> glguy: from a haskell pov, python is terrible. duck typing, no currying syntax, no monads, lambda being screwed, etc. map and filter are being removed for LCs.
11:10:37 <glguy> LCs?
11:10:44 <wolverian> list comprehensions
11:10:48 <glguy> ah
11:11:15 <psnl> glguy: have a careful look at andrew kennedy's talk on C# as a functional language, becuase it gives a big hint as to why adding fp features to a language doesn't quite work
11:11:30 <psnl> glguy: its a nice language, and I solve different problems in it
11:12:07 <wolverian> (also, broken closures)
11:12:27 <wolverian> (which isn't relevant from a haskell point of view, I suppose.)
11:12:43 <psnl> but its not a functional language, and will never be
11:12:54 <Excedrin> are there any lawyers on #freenode? I have a question about open source licenses and copyright, but I have no idea who to ask (aside from actually paying some lawyer, which doesn't make much sense)
11:13:04 <pejo> glguy, one could argue that maybe fp isn't the best way to start with programming, esp if you're EE instead of CS. (The fp could always be taught later).
11:13:11 <wolverian> Excedrin, have you checked e.g. FSF's FAQ?
11:13:34 <glguy> I was aware that it was not FP, I just was looking for opinions on it from someone who knew Haskell
11:13:39 <psnl> glguy: as for MIT teaching in it, well, I assume they know best
11:13:55 <glguy> (someone who has been spoiled ;) )
11:14:02 <psnl> glguy: as a teching language, its very good
11:14:18 <psnl> glguy: and its a nice language overall
11:14:23 <psnl> slow, though
11:14:29 <vincenz> no it's not, as a teaching language it's a bad idea
11:14:30 <glguy> slower than ruby?
11:14:35 <Excedrin> pejo: I think it's probably best to teach declarative programming before imperative programming; but I'm strongly biased in favor of the CTM approach
11:14:36 <wolverian> no. ruby is slowest. :)
11:14:46 <vincenz> But that article is taken out of context, it's not intended as teaching language for a PL course, but a robotics course!
11:15:14 <psnl> vincenz: go on?
11:15:26 <vincenz> In what sense?
11:15:46 <glguy> I thought that the robotics aspect of that course was simply one of the projects that they would assign, while teaching the language
11:15:47 <psnl> about why python isn't a good teaching language
11:15:52 <Excedrin> wolverian: the gpl faq?
11:16:18 <vincenz> psnl: Well for PL stuff it's not a good language.  It doesn't allow to easily try out different PL-styles: FP, OO, Imperative
11:16:31 <pejo> Excedrin, it's not only CS who does programming, remember EE, ME, Space engineers (?), etc.
11:16:38 <psnl> vincenz: oh, I see what you mean
11:16:39 <Excedrin> wolverian: yea, this helps, I think I'll email them
11:16:41 <vincenz> psnl: I think scheme is more ideal for that.  A) The syntax is more minimal, b) less corner cases, c) allows you to easily build something oo-like
11:16:56 <pejo> Excedrin, physicists too.
11:17:00 <pkhuong> (instead of being force-fed one re c)
11:17:09 <psnl> vincenz: yeah, I always thought moving from scheme was a bit odd
11:17:13 <vincenz> I'm a great proponent for scheme as teaching langauge.  As a generic engineer, I had it in my first year, but a few years after me they switched to java
11:17:22 <vincenz> psnl: But the article is misleading!  It's for a robotics course
11:17:28 <glguy> this talk: Parametric Polymorphism for Popular Programming Languages?
11:17:52 <glguy> or this: Transposing F to C# (ppt)
11:18:07 <Excedrin> pejo: so you're asserting that "non-cs students" learn "better" with imperative programming? How can something more complicated be easier to learn?
11:18:44 <pejo> Excedrin, no, I'm asserting that maybe learning complex analysis is better than learning fp for the physicists.
11:19:05 <Excedrin> pejo: I suspect that people with a science/math background would have an easier time with a programming language that resembles math
11:19:38 <integral> Excedrin: Fortran? Fortress?
11:19:38 <pkhuong> Excedrin: you'll have to be more precise w/ `resembles'. Looks? Semantics?
11:19:53 <Philippa_> pkhuong: supporting equational reasoning might be a good start
11:19:55 <vincenz> I think that  for teaching Programming and PL, scheme is great.  If you want to teach something else and just want people to use some language to access a library, then go with what you have
11:20:12 <Excedrin> semantics, specifically lack of mutable state
11:20:21 <vincenz> Philippa_: I'll settle for orthogonal features
11:20:24 <pkhuong> Philippa_: yeah, that's what I was thinking would help the most, but usually you don't teach programming that way.
11:20:25 <vincenz> Philippa_: that ain't even true in most lanuages
11:20:39 <vincenz> Philippa_: combine X and Y, works fine, combine X and Y with Z, boom
11:20:40 <pejo> Excedrin, I simply believe that after one programming course, people in average aren't very capable of abstracting over languages, if the course is in Java they will have trouble writing Fortran. The leap between Haskell and Fortran is even bigger.
11:22:40 <Excedrin> pejo: from what I've read, 6.001 should provide a good handle on the differences between languages, so that someone coming out of that class should be able to relate what they've learned to other languages.
11:23:12 <Excedrin> if there's an intro course based on CTM, then that applies even more strongly, even though Oz has a very weird syntax
11:24:00 <glguy> This talk comparing System F to C# manages to prove one thing to me, System F can be emulated in C# with bulky disgusting code...
11:24:26 <glguy> but anything you can do in System F can be done in assembly... doesn't make it a good idea
11:25:23 <pejo> Excedrin, do you find it reasonable to cover CTM in one course, for people who haven't been exposed to programming before?
11:26:14 <Philippa_> glguy: you're wrong there, assembly doesn't have static semantics worth a damn...
11:26:56 <glguy> all I'm saying is that just because you *can* express this stuff in C#, doesn't mean tht it is realistic to use the language this way
11:27:34 <pejo> Philippa, how is the semantics of assembly dynamic?
11:28:04 <Excedrin> probably not, it's too long. But I think it's reasonable to split it up into a few courses, starting from an introductory level
11:28:11 <Philippa_> pejo: it's all about what the machine does when you execute the code
11:28:24 <Philippa_> aka the dynamic semantics of the code
11:28:47 <Philippa_> if you want to hand me the mnemonic->opcode mapping as static semantics that's fine :-)
11:29:17 <cjeris> I don't suppose there's been any serious psychological research connecting preferred or most productive programming language to other traits of brain or personality?
11:29:27 <Philippa_> 'moff
11:29:37 <dcoutts> Igloo, multiple packages with the same name? Do you mean in gentoo or something else?
11:35:28 <cjeris> I mean, when I cracked open SICP for the first time (knowing only C, TeX, and a little shell), something in my brain said "Yes! This [functional programming] is the correct way to write programs."  But from my experience with people around me, that's clearly not the common case.
11:37:00 <malebria> dcoutts: are you there?
11:37:03 <malebria> dcoutts_: ?
11:37:08 <dcoutts> @arr
11:37:08 <lambdabot> I want me grog!
11:37:18 <vincenz> he's gone mad!
11:37:27 <dcoutts> who, me?
11:37:32 <vincenz> @arr
11:37:33 <lambdabot> Yeh scurvy dog...
11:37:37 <dcoutts> mm, quite
11:37:45 <malebria> dcoutts: hello.
11:37:51 <dcoutts> hi
11:37:59 <malebria> Is it bad to ask if you're here?
11:38:47 <dcoutts> malebria, if you don't need an instant reply then just ask, people can read it later
11:39:27 <malebria> dcoutts: Ok, I just would like to ask if you intend to add glade signals support in gtk2hs.
11:39:43 <dcoutts> malebria, no, it's not clear how it'd work.
11:39:48 <vincenz> dcoutts: that model doesn't work cause there's only one type of nickname hilighting, which means that we'll always go to look at the window instantaneously
11:40:36 <dcoutts> vincenz, sure, what I meant was they if you just aks, then either you get a reply soon or some time later
11:40:45 <dcoutts> either way asking if they're there is redundant
11:40:51 <vincenz> True
11:40:56 <Cale> vincenz: that assumes that we're not so lazy that we won't bother to click on the tab :)
11:41:00 <vincenz> It's like asking if you can ask a question
11:41:05 <dcoutts> aye
11:41:32 <vincenz> Cale: I have found that nickname highlighting evaluates the spine of the person
11:41:43 <glguy> dcoutts: I was asking around earlier about GHC 6.6 support plans (in a release version of gtk2hs) and I was told to ask you, do you have any idea when that would happen?
11:41:58 <malebria> dcoutts: Isn't getting the signals from glade the same as adding the callback functions with onDestroy or so?
11:42:17 <dcoutts> glguy, the current darcs version of gtk2hs supports ghc-6.6 and so the next official release will do too.
11:42:28 <glguy> ah, cool
11:42:29 <dcoutts> glguy, though there's no need to wait for an official release
11:42:40 <glguy> the darcs version is relatively stable?
11:42:47 * dmead wrote his first parsec definitions last night
11:43:00 <dcoutts> malebria, perhaps, how would you like it to look exactly ?
11:43:39 <dcoutts> malebria, perhaps you want to be able to bind a signal without having to also get widget
11:43:59 <dcoutts> remember that it must be typed.
11:44:33 <dcoutts> malebria, so if you've got any suggestions I'm quite happy to hear it, perhaps email your suggestion to the gtk2hs-devel mailing list.
11:44:39 <malebria> dcoutts: associate delete_event to mainQuit perhaps?
11:45:00 <malebria> dcoutts: this kind of signal does not envolve a lot of thing.s
11:45:24 <dcoutts> malebria, ok, do you mean "delete_event" as a String ?
11:45:42 <dcoutts> malebria, how do you imagine the code would look?
11:45:56 <malebria> dcoutts: you mean gtk2hs code or the user code?
11:46:01 <dcoutts> the user code
11:46:06 <dcoutts> what do you want to write
11:46:13 <dcoutts> and what would it mean
11:46:22 <dcoutts> then I can think about if it's possible
11:46:50 <malebria> dcoutts: I was wondering about no code, when you load the glade file you associate all the signals from the widgets that are specified.
11:47:16 <dcoutts> malebria, the tricky bit is how exactly you do that
11:47:27 <LoganCapaldo> import DWIM ;)
11:47:32 <dcoutts> eg how do you specify the signals in the Haskell code
11:47:46 <malebria> dcoutts: This I don't know for sure, but from the users point of view it doesn't seem to be a problem.
11:48:04 <malebria> dcoutts: What's the problem of being a string?
11:48:46 <dcoutts> malebria, remember that we can't just look through the symbol table of the program to find a function with the name "widget_foo_pressed"
11:49:31 <malebria> dcoutts: hum..
11:49:32 <Binkley> join #haskell-blah
11:49:34 <Binkley> oops
11:49:41 <malebria> dcoutts: it really makes things harder.
11:50:10 <glguy> automatically connecting events based on a name makes baby Jesus cry
11:50:15 <LoganCapaldo> Use a preprocessor ;)
11:50:29 <dcoutts> indeed, it's something that you can do with some IDE tool
11:50:36 <Binkley> {-# MAKEBABYJESUSCRY #-}
11:50:47 <dcoutts> we can make it simpler perhaps by allowing something like:
11:51:16 <dcoutts> hmm, nm
11:51:31 <palomer> yo my bitches
11:51:39 <metaperl> ahem
11:51:49 <dcoutts> the point would be to connect a signal to a named widget in one line of code
11:52:04 * metaperl clears his throatadn glances up and down at palomer
11:52:38 <ValarQ> palomer: hej kamrat
11:53:18 <LoganCapaldo> connect signal "widget" wouldn't work?
11:53:31 <palomer> how dare you clear your throat and glance at me dervish swine?
11:54:02 <LoganCapaldo> Or do signals have more than one type?
11:54:07 <LoganCapaldo> Ooooo
11:55:00 <LoganCapaldo> can you do multiple dispatch ala CLOS? Something like connect :: (Signal a, Widget b) => a -> b -> ()
11:56:35 <palomer> darcs uses GADTs for verification purposes, right?
11:56:39 <malebria> gotta go... See you.
11:57:09 <glguy> dcoutts: I darcs get'ted the gtk2hs sources... step one is to run autoreconf... whoever that doesn't exists, it would seem (and configure isn't built yet) any suggestions?
11:57:16 <glguy> however*
11:57:59 <glguy> OH
11:58:07 <glguy> autoreconf is not specific to gtk2hs
11:58:52 <dcoutts> glguy, right, you would need to have automake+autoconf installed
11:59:03 <dcoutts> then you can run autoreconf
11:59:08 <glguy> do you know which version of automake+autoconf?
11:59:13 <glguy> 1.9?
11:59:33 <dcoutts> yep, automake 1.9 and autoconf 2.58+
11:59:34 <glguy> ah, i see a 1.10
11:59:42 <glguy> (does this work in cygwin?)
11:59:46 <dcoutts> 1.9 or later should be fine
11:59:58 <dcoutts> glguy, oh, on windows. dunno I've never tried
12:00:09 <glguy> I'll let you know when it fails, so you can tell the next guy not to ;)
12:00:10 <dcoutts> it'd also need the pkg-config automake macros
12:00:29 <dcoutts> so I don't rate your chances
12:00:54 <glguy> cygwin doesn't have pkg-config?
12:00:57 <dcoutts> for building from source on windows I'd always start with a tarball which includes configure
12:01:06 <dcoutts> glguy, dunno, it might.
12:01:17 <glguy> dcoutts: so, the configure script is portable?
12:01:25 <dcoutts> yeah, it's really portable
12:01:26 <glguy> from oepnbsd to windows, say?
12:01:29 <glguy> ok
12:01:31 <glguy> I'll do that then
12:01:31 <dcoutts> sure
12:01:41 <dcoutts> but building configure is a PITA
12:01:46 <dcoutts> especially on windows
12:02:35 <dcoutts> it's quite funny that automake & autoconf which produce ultra-portable scripts are themselves riddled with issues when using them on different platforms and different versions
12:03:18 <sjanssen> I imagine an autoautoconf could solve that issue
12:03:29 <dcoutts> heh heh
12:03:31 * dcoutts will be back later
12:12:28 <dmead> dcoutts: yea, it's terrible
12:12:37 <dmead> dcoutts: ever tried scons?
12:15:34 <metaperl> some people like unsermake
12:24:36 <astrolabe> The execution path of some code can be deduced by the compiler.  It would be nice if there was a special syntax for such code.
12:36:57 <metaperl> The Hoogle page looks sharp! http://haskell.org/hoogle/
12:36:58 <lambdabot> Title: Hoogle
12:37:19 <Binkley> Ooo rainbows.
12:37:27 <Binkley> I approve.
12:37:33 <astrolabe> It is nice
12:37:42 <palomer> who wrote the GHC user's guide?
12:37:46 <palomer> I'm putting it as a reference
12:38:02 <metaperl> I wonder if [a] -> a -> Bool and a -> [a] -> Bool need separate Hoogling
12:38:13 <astrolabe> My guess is SPJ etal
12:38:21 <Binkley> palomer: if I had to, I'd probably cite it as "Simon Peyton Jones, Simon Marlow, et al"
12:38:38 <metaperl> they dont. nice: http://haskell.org/hoogle/?q=%5Ba%5D+-%3E+a+-%3E+Boolhttp://haskell.org/hoogle/?q=%5Ba%5D+-%3E+a+-%3E+Bool
12:38:40 <lambdabot> Title: [a] -> a -> Boolhttp://haskell.org/hoogle/?q=[a] -> a -> Bool - Hoogle, http://tinyurl.com/tpc7v
12:41:16 <astrolabe> hoogle is ndm too?
12:41:28 <metaperl> it is. what else did he do?
12:41:32 <astrolabe> funny how a few people seem to do most of the stuff
12:42:02 <astrolabe> he provides hat for windows
12:42:27 <astrolabe> also, and functional interface (unfinished) for hs2Gtk
12:42:36 <psnl> ndm? all round bad-ass-ness
12:42:43 <metaperl> :)
12:42:47 <astrolabe> and he's doing something else entirely in his PhD
12:43:50 <Oejet> Ah, that's why he has so much time on his hands. ;-)
12:44:45 <LoganCapaldo> Is there a way to hack ghci so that having just some_function is equivalent to :type some_function instead of "Ack! I don't know how to show this!!??"
12:46:23 <Binkley> LoganCapaldo: sure. Get the source and implement it :-)
12:46:46 <LoganCapaldo> k, ;) I was hoping for an easier method but such is life
12:46:48 <psnl> LoganCapaldo: type ?
12:46:53 <LoganCapaldo> it should be a good challenge <g>
12:47:07 <Binkley> such is the beauty of open-source software. I can't imagine it would be that hard to do, but, famous last words
12:48:12 <skeh> I am trying to get 5 lines from a .txt and put them into a List as strings
12:48:31 <LoganCapaldo> take 5 $ getContents :)
12:48:47 <complaisant> @paste
12:48:47 <lambdabot> http://paste.lisp.org/new/haskell
12:48:54 <Excedrin> skeh: I annotated your paste last night
12:49:15 <Excedrin> LoganCapaldo: getContents doesn't return lines
12:49:31 <LoganCapaldo> lines $ getContents
12:49:33 <LoganCapaldo> right?
12:50:02 <lisppaste2> complaisant pasted "caesar cipher" at http://paste.lisp.org/display/30502
12:50:20 <skeh> thanks Excedrin!
12:50:50 <Excedrin> http://paste.lisp.org/display/30453#1
12:51:30 <skeh> I doing file IO though logan
12:51:33 <complaisant> need some help here with my code.. i need to apply this function (#>) to a list of [0..25] so i can get the list of all the possible shifts of a cipher
12:51:49 <complaisant> i really am not figuring out how am i going to do that
12:52:22 <Binkley> complaisant: is this for homework?
12:52:31 <LoganCapaldo> cat some_file | haskell_program :)
12:52:48 <complaisant> no. just helping some guys with it.. & i'm practicing
12:52:51 <skeh> what does the return statement do in haskell
12:52:54 <skeh> ive never used that
12:53:10 <complaisant> Binkley : is it yours?
12:53:16 <glguy> anyone know whre I'm supposed to unzip happy for ghc6.6
12:53:27 <Binkley> complaisant: is it my homework, you mean?
12:53:28 <LoganCapaldo> skeh: It puts it in the Monad
12:53:36 <complaisant> yes
12:53:37 <Binkley> glguy: doesn't matter where so long as you put it in your $PATH
12:53:43 <Binkley> complaisant: Heh. No.
12:53:48 <complaisant> ;)
12:54:15 <lisppaste2> metaperl pasted "critique my unique" at http://paste.lisp.org/display/30504
12:54:37 <complaisant> so have u seen the code.. ? i tryed map (#>) [0..25] "ola" but as expected didnt work out
12:54:59 <Binkley> metaperl: I'm a little slow -- what is your code supposed to do?
12:55:12 <metaperl> return a list of the unique elements of a list
12:55:12 <complaisant> i guess it's something with the flip function.. i don't really know how to apply it.. but my guess is that i should use it
12:55:28 <Binkley> why not just use nub?
12:55:33 <metaperl> you need a trampoline to apply that function complaisant
12:55:35 <metaperl> :)
12:55:43 <metaperl> you must be upside-down before it works
12:55:52 * metaperl researches into nub
12:55:57 <wilx> Well, it looks O(n^2).
12:56:16 <complaisant> what do u mean with upside-down?
12:56:18 <metaperl> Binkley - I'm trying to do te problems in SJT's "Craft" book
12:56:25 <Binkley> Ah ok
12:56:25 <metaperl> complaisant - I'm being stupid - ignore me
12:56:29 <lisppaste2> glguy annotated #30504 with "unique'" at http://paste.lisp.org/display/30504#1
12:56:49 <Binkley> well, compare it to the library definition of nub and see how it's different :-)
12:57:01 <glguy> ?fptools nub
12:57:02 <lambdabot> nub not available
12:57:08 <glguy> ?fptools Data.List.nub
12:57:08 <lambdabot> Data.List.nub not available
12:57:14 <glguy> =/
12:57:18 <Binkley> @hoogle nub
12:57:18 <lambdabot> List.nub :: Eq a => [a] -> [a]
12:57:19 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
12:57:22 <complaisant> List.nub
12:57:23 <Binkley> ?fptools GHC.List.nub
12:57:24 <lambdabot> GHC.List.nub not available
12:57:28 <glguy> ?fptools List nub
12:57:28 <lambdabot> List nub not available
12:57:29 <Binkley> ?fptools List.nub
12:57:29 <lambdabot> List.nub not available
12:57:33 <glguy> ?fptools Data.List nub
12:57:33 <lambdabot> Data.List nub not available
12:57:36 <glguy> I give
12:57:39 <metaperl> Binkley - nub does not return a list of unique elements.. it removes dups
12:57:41 <Binkley> where's my nub???
12:57:45 <glguy> in hugs, write:    :f nub
12:57:52 <Binkley> metaperl: what's the difference?
12:58:10 <metaperl> *Main> unique [4,2,1,3,2,3]
12:58:11 <metaperl> [4,1]
12:58:13 <pkhuong> Binkley: if the duplicates aren't next to each other.
12:58:21 <metaperl> nub would return [4,2,1,3]
12:58:42 <glguy> ahhh
12:58:42 * metaperl is sleepy
12:58:49 <Binkley> Ah! okay
12:58:56 <Binkley> I understand now
12:59:03 <palomer> > nub [1,2,1,2]
12:59:04 <lambdabot>  [1,2]
12:59:14 <glguy> unqiue [1,2,1,2] => []
12:59:54 <pkhuong> ah. wow. even weirder than unix then :)
13:00:05 <Binkley> metaperl: why do you have parens around the uses of xs in your version?
13:00:09 <glguy> > concat $ filter (null.tail) $ group $ sort [4,2,1,3,2,3]
13:00:11 <lambdabot>  [1,4]
13:00:29 <metaperl> Binkley - thanks . i'll remove them
13:05:13 <LoganCapaldo> I'm dissapointed that take 1 $ unique [1,1..] doesn't work
13:05:28 <LoganCapaldo> ah well
13:05:29 <glguy> you are?
13:06:10 <Binkley> sorting an infinite list can be pretty slow :-)
13:06:20 <metaperl> glguy - I put your name in lights man : http://www.livingcosmos.org/Members/sundevil/haskell/what-would-i-use-to-repeat-a-function-over-its-results-ex-10-applied-4-times-to-2-gives-20000/#find-the-unique-elements-in-a-list
13:06:23 <lambdabot> Title: FAQ &mdash; The Living Cosmos, http://tinyurl.com/y7eqxo
13:06:40 <complaisant> > group [1,2,3]
13:06:41 <lambdabot>  [[1],[2],[3]]
13:07:14 <metaperl> > group [1,2,2,3]
13:07:16 <lambdabot>  [[1],[2,2],[3]]
13:07:29 <glguy> metaperl: you could change my unique to:
13:07:43 <glguy> unique = concat . filter (null . tail) . group . sort
13:08:15 <LoganCapaldo> > group [2,1,2]
13:08:16 <lambdabot>  [[2],[1],[2]]
13:08:37 <LoganCapaldo> Binkley: I didn't sort in mine
13:08:46 <metaperl> glguy - recorded. thanks
13:09:17 <LoganCapaldo> it looked like glguy's on the paste
13:09:34 <Binkley> checking whether something is an element of an infinite list can also be pretty slow :-)
13:09:41 <LoganCapaldo> I know
13:09:57 <LoganCapaldo> if it took the other way it would work though
13:10:46 <LoganCapaldo> no it still wouldn't
13:10:55 <Binkley> what do you mean "if it took the other way"?
13:11:33 <LoganCapaldo> mmm
13:11:50 <LoganCapaldo> Nothing my logic was faulty
13:12:09 <LoganCapaldo> the branch with x:(unique xs)
13:12:17 <LoganCapaldo> but the elem would still have to work
13:12:28 <glguy> ?type empty
13:12:29 <lambdabot> Not in scope: `empty'
13:12:32 <glguy> ?type S.empty
13:12:34 <lambdabot> Couldn't find qualified module.
13:12:43 <glguy> ?type Data.Set.empty
13:12:44 <lambdabot> forall a. Data.Set.Set a
13:12:45 <LoganCapaldo> @hoogle emtpy
13:12:45 <lambdabot> No matches found
13:12:53 <LoganCapaldo> lol
13:12:55 <LoganCapaldo> typo
13:13:49 <complaisant> how can i make a high order that replaces this code
13:13:51 <complaisant> cesar x = aux x [0..25]
13:13:51 <complaisant>    where aux _ [] = []
13:13:51 <complaisant>          aux x (h:t) = [x <# h] ++ aux x t
13:13:56 <complaisant> sry about the paste
13:14:10 <Binkley> @paste
13:14:11 <lambdabot> http://paste.lisp.org/new/haskell
13:14:14 <Binkley> use that for pasting instead
13:14:20 <complaisant> http://paste.lisp.org/display/30502
13:14:24 <glguy> complaisant: (x <# h) : aux x t
13:14:35 <glguy> as a general pointer
13:14:38 <complaisant> there's the rest of it
13:16:52 <complaisant> glguy : what?
13:17:03 <glguy> complaisant: I think you want: zipWith
13:17:10 <glguy> err
13:17:13 <glguy> oh
13:17:15 <glguy> no
13:17:15 <glguy> map
13:17:17 <glguy> i see what you are doing
13:17:28 <complaisant> yes .. map
13:18:01 <glguy> cesar x = map (x <#) [0..25]
13:18:16 <metaperl> what is that # sign doing?
13:18:28 <metaperl> @type (<#)
13:18:29 <glguy> he's defined an operator
13:18:29 <lambdabot> Not in scope: `<#'
13:18:33 <metaperl> oh
13:18:37 <glguy> (<#) :: String -> Int -> String
13:18:39 <glguy> x <# nr = i2c $ shift (-nr) $ s2i $ lower x
13:19:09 <complaisant> dammit.. tnks 4 the help :D
13:19:19 <glguy> complaisant: [x] ++ ys    is the bad way to write    x : ys
13:19:24 <glguy> is what I was saying earlier
13:23:44 <glguy> cesar = flip map [0..25] . (<#)
13:23:45 <metaperl> @type shift
13:23:45 <lambdabot> forall a. (Bits a) => a -> Int -> a
13:23:45 <glguy> ?pl \x -> map (x <#) [0..25]
13:23:45 <lambdabot> flip map [0..25] . (<#)
13:24:33 <complaisant> o
13:24:34 <complaisant> ok
13:24:58 <lisppaste2> skeh pasted "Read .txt as a big string" at http://paste.lisp.org/display/30507
13:25:30 <skeh> hopefully one day i will gain knowledge to repay those who continue to help me
13:25:33 <glguy> skeh: nope, once something is inside IO, it stays there
13:25:37 <skeh> and distribute it amongst this channel
13:25:59 <skeh> glguy then is there anyway to do this?
13:26:05 <skeh> thanks for that tip too
13:26:05 <glguy> skeh: input <- readFile inFileName     --- is shorthand for:
13:26:11 <skeh> I didnt know that
13:26:18 <glguy> readFile inFileName >>= \input ->
13:26:24 <glguy> you have to finish the right hand side
13:27:18 <glguy> skeh: what is it that you want to do with the contents of that file?
13:27:49 <skeh> I want to read an entire file as a string to pass to a function that will parse it
13:28:45 <lisppaste2> glguy annotated #30507 with "and parsing too" at http://paste.lisp.org/display/30507#1
13:31:08 <skeh> so would main's signature main :: IO() glguy?
13:31:15 <glguy> yeah
13:31:22 <glguy> which you don't need to specify
13:31:44 <Botje> skeh: you might want to use the interact function.
13:32:01 <skeh> im new to haskell
13:32:11 <skeh> K.I.S.S for me
13:32:17 <glguy> interact is a hold over from the pre-Monadic IO days
13:32:33 <glguy> (but is still a valid function of course for use)
13:32:33 <Botje> glguy: that doesn't make it any less useful :)
13:32:50 <glguy> Botje: soif he is trying to learn Haskell, that wouldn't be the best place to start
13:32:58 <glguy> he needs to understand Monadic IO
13:33:07 <Botje> doing IO in haskell is a PITA. interact takes away the pain :)
13:33:10 <Botje> kind of.
13:33:28 <glguy> much like a lobatomy takes away your worries
13:33:29 <Botje> glguy: how did interact work in the pre-monadic I/O days, then?
13:34:35 <glguy> Haskell fed in data from the std input and you produced output...
13:35:16 <glguy> main :: [Response] -> [Request]
13:35:22 <Botje> oh.
13:35:48 <LoganCapaldo> It wasn't [Request] -> [Response] ?
13:35:54 <glguy> nope
13:35:59 <LoganCapaldo> Now I am confused
13:36:21 <glguy> the function would return a request, and would receieve a response
13:36:26 <glguy> thanjks to lazy lists
13:36:40 <glguy> the responses didn't have to exist before the requests were generated
13:36:57 <glguy> the function might return "give me your name, yo"
13:37:07 <glguy> and then an element would be added to the response list
13:37:12 <glguy> "I'm glguy"
13:37:32 <glguy> or you might return a "open this file"
13:37:43 <glguy> and then the file would be added to the input list
13:37:51 <skeh> thanks glguy!
13:37:56 <skeh> I think i am good to go
13:38:09 <glguy> good luck
13:38:21 <skeh> the hard part of my project is done
13:38:26 <skeh> I am just doing IO
13:38:45 <LoganCapaldo> so you did: "open this file":(main requests) ?
13:38:47 <skeh> i am writing operators for DFA arithmetic
13:39:00 <skeh> see glguy's annotation
13:39:09 <LoganCapaldo> err
13:39:15 <LoganCapaldo> :(main responses)
13:39:21 <hyrax42> DFA arithmetic?
13:39:24 <glguy> LoganCapaldo: I've never used it
13:39:32 <skeh> taking the AND of two DFA
13:39:35 <glguy> i've read "A History of Haskell"
13:39:41 <skeh> taking the OR, IMPLIES, NOT, EQUIVALES
13:39:50 <hyrax42> skeh: cool
13:39:52 <skeh> yea
13:39:55 <hyrax42> I was planning to do that at some point
13:40:09 <hyrax42> but I got carried away trying to make the same code be deterministic and non-deterministc
13:40:12 <hyrax42> with monads
13:40:13 <skeh> its really easy once you get one operator done (AND or OR
13:40:15 <LoganCapaldo> How does one AND a DFA?
13:40:41 <hyrax42> when really you never run nfa straight, you determinise and run
13:40:49 <skeh> right hyrax
13:40:59 <skeh> which is 0(2^n)
13:41:18 <skeh> logan, its when both DFA are in an accept state
13:41:28 <skeh> thats the only time the ANDed DFA can accept
13:41:30 <LoganCapaldo> ah
13:41:34 <LoganCapaldo> ok
13:41:36 <LoganCapaldo> that makes sense
13:41:46 <skeh> and you build operators from using NOT and OR
13:41:49 <skeh> or NOT and AND
13:41:51 <hyrax42> but typically say from a regexp, you create an NFA, determnise and run, right?
13:41:51 <Excedrin> is there a preferred relational database library?
13:41:53 <skeh> w/ boolean alg
13:41:58 <LoganCapaldo> And they are running in parrallel on the same input?
13:42:02 <skeh> yes
13:42:09 <skeh> yes Logan
13:42:19 <skeh> but you can build it as well
13:42:31 <hyrax42> skeh, your intersection must have n*m states, right?
13:42:33 <hyrax42> before minimising
13:42:43 <hyrax42> n, m, sizes of each machine
13:42:50 <metaperl> Excedrin - haskellDB?
13:42:52 <skeh> yes
13:43:35 <hyrax42> the intersection is easier to do directly than union, irrc
13:43:37 <hyrax42> iirc
13:43:55 <skeh> I thought so
13:44:02 <skeh> thats why I built my AND op first
13:44:06 <hyrax42> then complement is a joke, and most everything else is free
13:44:21 <skeh> everything else you can build with NOT and AND/OR
13:44:25 <skeh> yep
13:44:55 <hyrax42> do you have minimisation in there?
13:46:01 <skeh> I dont
13:46:35 <skeh> Im having a hard time seeing how I would do that in functional
13:46:42 <skeh> in C i would just treat the DFA as a graph
13:46:44 <hyrax42> mind posting your datatype for the NFA?
13:46:57 <hyrax42> skeh, I was giong to use runSTArray
13:47:29 <skeh> I can post one that isnt mine
13:47:38 <hyrax42> but not yours?
13:47:38 <skeh> :)
13:47:40 <skeh> yea
13:48:07 <hyrax42> well are your states just Int or are you having some kind of DFA s a
13:48:16 <hyrax42> where s is state type, a is alphabet type
13:48:19 <skeh> yes
13:48:38 <skeh> i ran into some typing issues
13:48:43 <skeh> so I just made it DFA Int Char
13:48:44 <hyrax42> my thikning was to have everything internally Int
13:48:53 <hyrax42> with two functions s -> Int and Int -> s
13:49:06 <skeh> ah
13:49:25 <hyrax42> since anyway after most operations (union/intersection etc.) the labels of states are mostly meaningless
13:49:43 <skeh> right
13:49:47 <hyrax42> so they may as well be Int
13:50:14 <hyrax42> sorry for pressing on it
13:50:31 <hyrax42> just curious to hear from someone who actually finished up such a thing
13:50:31 <skeh> hehe np
13:50:53 <hyrax42> do you run it with state monad or?
13:51:00 <skeh> no monads
13:51:09 <skeh> I dont understand those yet
13:51:14 <skeh> Im really new to Haskell
13:52:00 <hyrax42> ah
13:52:17 <hyrax42> well getting a dfa to run was one of the first thigns I did with monads
13:52:56 <skeh> I'll probobly look over monads pretty soon and ammend this project
14:15:26 <emu> i'm having a bit of trouble with generic arithmetic: I have a type Dist a = [(a,Double)] and I want to do something like: distMean = sum . map (uncurry (*)), but that seems to default to :: [(Integer,Integer)] -> Integer
14:16:00 <emu> is there a way to write distMean such that it will work on any Dist a?
14:16:35 <kaol> @type sum . map (uncurry (*))
14:16:37 <lambdabot> forall b. (Num b) => [(b, b)] -> b
14:17:06 <emu> that restricts the tuple to contain two values of the same type, though
14:18:05 <kaol> @type (*)
14:18:06 <lambdabot> forall a. (Num a) => a -> a -> a
14:19:01 <emu> i suppose i could live with \a b -> (coerceToDouble a) * b, if such a function exists
14:20:05 <kaol> @type (\x y -> (fromIntegral x) * y)
14:20:06 <Luitzen> @type fromInteger
14:20:07 <lambdabot> forall b a. (Num b, Integral a) => a -> b -> b
14:20:08 <lambdabot> forall a. (Num a) => Integer -> a
14:20:44 <emu> except it could be any num, not just integers
14:23:12 <glguy> emu: so did you solve your mean problem?
14:23:16 <emu> no
14:23:27 <glguy> can you restate what you wanted?
14:23:32 <glguy> I just cleared the window
14:23:52 <LoganCapaldo> emu: why not just do Dist = [(Double,Double)] ??? 1 :: Double works after all right?
14:23:54 <emu> type Dist a = [(a,Double)]; meanDist :: ???; meanDist = sum . map (uncurry (*)) -- or something
14:24:08 <chessguy> @type (:)
14:24:09 <lambdabot> forall a. a -> [a] -> [a]
14:24:47 <chessguy> > 3 : []
14:24:49 <lambdabot>  [3]
14:24:55 <emu> LoganCapaldo: well i had distributions of various numbers.  forcing them all to be doubles, all the time, seems a bit harsh
14:27:09 <glguy> ?type toRational
14:27:11 <lambdabot> forall a. (Real a) => a -> Rational
14:27:13 <glguy> ?type fromRational
14:27:15 <lambdabot> forall a. (Fractional a) => Rational -> a
14:28:56 <glguy> emu: if you are always multiplying by a Double
14:28:59 <glguy> on the right side
14:29:28 <glguy> you'll always have to multiply it by a Double if you don't want to lose information from the Double
14:30:22 <emu> well I figured that (*) applied to some type and a Double will preserve as much info as possible
14:30:25 <glguy> but
14:30:33 <emu> for example, Integer * Double should be fine
14:30:34 <glguy> you could say:
14:30:57 <glguy> ?type \x -> (3 :: Double) * fromRational x
14:30:58 <lambdabot> Rational -> Double
14:31:04 <glguy> emu: not all Integers fit into Doubles
14:31:44 <emu> well, by that reasoning, Double * Double has issues too
14:31:56 <hyrax42> 0% of them in fact
14:32:00 <hyrax42> ;)
14:33:15 <glguy> hyrax42: I'm not sure what you mean
14:33:30 <glguy> > fromInteger 4 :: Double --
14:33:32 <lambdabot>  4.0
14:33:48 <hyrax42> well there are infinitely many Integer values, and only finitely many Double values
14:33:58 <glguy> ah
14:34:10 <hyrax42> I was being a pedant
14:35:07 <glguy> > liftM2 (,) fromInteger fromInteger (256^256) :: (Double,Integer)
14:35:08 <lambdabot>  (Infinity,323170060713110073007148766886699519604441026697154840321303454275...
14:35:19 <emu> i think i may settle for sum . map (\(n,p) -> (fromRational . toRational $ n) * p)
14:35:20 <chr1s> hey everyone!
14:35:39 <chr1s> I'm figuring out how to do stuff with do
14:35:53 <chr1s> This is my minimal testcase:
14:35:59 <hyrax42> ?paste
14:36:00 <lambdabot> http://paste.lisp.org/new/haskell
14:36:09 <emu> with type  :: (Real a) => [(a, Double)] -> Double
14:36:20 <hyrax42> ?instances Real
14:36:21 <lambdabot> Double, Float, Int, Integer
14:36:36 <hyrax42> ?hoogle Real a => a -> Double
14:36:37 <lambdabot> No matches, try a more general search
14:36:52 <Pseudonym> :type fromRational
14:36:57 <LoganCapaldo> heh
14:36:57 <Pseudonym> ?type fromRational
14:36:58 <lambdabot> forall a. (Fractional a) => Rational -> a
14:37:02 <LoganCapaldo> more general search
14:37:05 <LoganCapaldo> this is more general
14:37:10 <LoganCapaldo> @hoggle a -> b
14:37:12 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
14:37:12 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
14:37:12 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
14:37:18 <emu> wow, that works?
14:37:22 <lisppaste2> chr1s pasted "do stuff with do" at http://paste.lisp.org/display/30514
14:37:34 <hyrax42> emu: it's half the point!
14:37:36 <glguy> emu: if you are going to restrict everything to the accuracy of a Rational converted to a Double... you not make the type more general
14:37:42 <emu> i'm hoggling things from now on
14:37:58 <chr1s> the first declaration works
14:37:58 <hyrax42> it's great for looking up all sorts of things
14:38:04 <glguy> why are you tied to having a Double at all?
14:38:08 <chr1s> but the second doesn't work
14:38:11 <hyrax42> ?hoogle (a->Bool) -> [a] -> Bool
14:38:12 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
14:38:13 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
14:38:15 <emu> my probabilities are representing as Doubles. yes, shoot me now.
14:38:36 <Pseudonym> chr1s: What error message do you get?
14:38:38 <Pseudonym> I know you get one.
14:38:42 <Pseudonym> :-)
14:38:46 <glguy> emu: why not represent them as any instance of Real?
14:38:55 <LoganCapaldo> chr1s: You've got no  monad in there
14:38:57 <eviltwin_b> my question there is, where's the monad?
14:39:10 <lisppaste2> chr1s pasted "do stuff with do (error)" at http://paste.lisp.org/display/30515
14:39:11 <eviltwin_b> I'd expect the implicit >>= to complain
14:39:32 <chr1s> Pseudonym: see my second paste
14:39:34 <Pseudonym> OK, chr1s, now let's diagnose that error.
14:39:35 <eviltwin_b> hm, guess it focused on the list monad
14:39:56 <glguy> chr1s: you forgot the return
14:40:02 <Pseudonym> Do you know what (,) String means?
14:40:03 <dibblego> ?hoogle a -> [a] -> [a]
14:40:04 <lambdabot> List.intersperse :: a -> [a] -> [a]
14:40:04 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
14:40:04 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:40:13 <chr1s> Pseudonym: nope
14:40:17 <Pseudonym> Right.
14:40:23 <Pseudonym> (a,b) is a short hand for (,) a b
14:40:28 <glguy> chr1s: return (a,xs)
14:40:40 <Pseudonym> glguy: Bear with me, that's obviously not the only error.
14:40:45 <emu> glguy: hmm, the arithmetic would probably get even more complicated :/
14:40:53 <Pseudonym> The key here is to understand what the compiler is telling you.
14:40:55 <chr1s> hm, ok
14:41:00 <Pseudonym> Teach a man to fish and all that.
14:41:03 <Pseudonym> OK.
14:41:07 <Pseudonym> Now.
14:41:11 <chr1s> yes :)
14:41:21 <Pseudonym> Basically, there are two types of "thing" you can put in a do statement.
14:41:26 <Pseudonym> One is a generator: p <- m
14:41:30 <glguy> teach a man to fish, and he'll never need you again, give a man a fish and he'll know wher to buy fish :) (I wasn't reading the channel when I was typing that)
14:41:49 <chr1s> yeah
14:42:16 <dibblego> is there a hoogle function that will take inputs, an output and find a function that meets that criteria?
14:42:36 <Pseudonym> The other is where you put in a literal monad: m
14:42:37 <hyrax42> dibblego: interesting extension
14:42:47 <Pseudonym> It's usually a call.
14:43:20 <Pseudonym> The reason for the cryptic error message is that (,) s is actually a legitimate monad.
14:43:23 <emu> i wonder if anyone has dreamt up an implicit type system that can represent all of "natural arithmetic" statically w/o need for any weird annotations
14:43:31 <Pseudonym> It's the "reader" monad.
14:43:35 <chr1s> so do I want to change the (a,xs) line to a monad?
14:43:36 <Pseudonym> Err...
14:43:42 <Pseudonym> No, not the reader monad.
14:43:47 <dibblego> ?hoogle f "x" ["abc", "def", "ghi"] == "abcxdefxghi"
14:43:48 <lambdabot> Hoogle Error: Parse Error: Unexpected character '"x" ["abc"'
14:43:56 <Pseudonym> So actually, it's correctly interpreting (a,xs) as a monad.
14:44:03 <chr1s> ok
14:44:05 <glguy> Pseudonym: the problem is just that each line must be basing on a list monad
14:44:06 <Pseudonym> But it's saying that (,) s is not the same monad as [].
14:44:07 <glguy> (,) wasn't
14:44:25 <glguy> that (,) String isn't [], not that (,) String is a monad
14:44:32 <Pseudonym> Right.
14:45:00 <chr1s> hm, it's getting clearer...
14:45:01 <Pseudonym> But note that the error is on the generator line.
14:45:11 <Pseudonym> From the second line it's inferred that this must be the (,) String monad.
14:45:17 <chr1s> yeah, that's the strange thing
14:45:24 <chr1s> aaaah
14:45:25 <Pseudonym> But the generator line looks like a list monad.
14:45:25 <chr1s> ok
14:45:36 <Pseudonym> Right?
14:45:37 <Pseudonym> OK.
14:46:02 <Pseudonym> If you put return (a,xs) in as the last line, that almost does what you want.
14:46:09 <Pseudonym> But you'll find it has a different type from the first f.
14:46:09 <chr1s> yeah
14:46:36 <LoganCapaldo> do notation has implications beyond syntax :)
14:47:19 <chr1s> well, actually I still get the same error with the return, but I'm still captivated...
14:47:23 <dibblego> is there a way to continue code on the next line without using ; ?
14:47:36 <Pseudonym> dibblego: Yes.
14:47:37 <glguy> indent
14:47:39 <Pseudonym> Use the offside rule.
14:47:43 <Pseudonym> do some very long
14:47:45 <dibblego> oh right
14:47:47 <Pseudonym>      expression
14:47:52 <Pseudonym>    return result
14:47:53 <araujo> ay!
14:48:00 * araujo throws lambdas
14:48:20 <Pseudonym> Sorry, you get the same error?
14:48:27 <dibblego> thanks
14:48:46 <Pseudonym> This actually catches people.
14:48:50 <Pseudonym> Many people expect this:
14:48:53 <Pseudonym> do if condition
14:48:56 <Pseudonym>    then something
14:49:00 <Pseudonym>    else somethingElse
14:49:01 <Pseudonym> to work
14:49:06 <Pseudonym> But it doesn't.
14:49:13 <glguy> and shouldn't!
14:49:13 <Pseudonym> You have to indent the "then" and "else" lines.
14:49:36 <LoganCapaldo> Just don't use if then ;)
14:49:38 <Pseudonym> glguy: Arguably this breaks the principle of least surprise.
14:49:47 <chr1s> Pseudonym: yes, I still get the same error
14:49:50 <Pseudonym> In practice, it's not a huge deal.
14:50:00 <LoganCapaldo> Pseudonym: It also breaks the principle of "the compiler is not psychic" ;)
14:50:01 <dibblego> yes I've been caught by that
14:50:04 <Pseudonym> chr1s: What's your code now?  It's short enough that you can paste it here.
14:50:17 <chr1s>       2 f (x:xs) = do
14:50:17 <chr1s>       3   a <- [x];
14:50:18 <chr1s>       4   return (a, xs)
14:50:18 <glguy> if then else is one expression, putting it on three lines says "here are three expressions"
14:50:23 <Pseudonym> LoganCapaldo: Actually, the offside rule already satisfies taht principle.
14:50:35 <Pseudonym> Implement an offside-rule-compliant parser if you don't believe me.
14:50:43 <LoganCapaldo> Pseudonym: I meant if it let you not indent then else
14:51:08 <Pseudonym> There's a rule in the Haskell grammar to the effect of "if inserting a semicolon would fix a parse error, do it".
14:51:17 <Pseudonym> No, close brace.
14:51:22 <Pseudonym> But it amounts tot he same thing.
14:51:39 <Philippa_> yeah, the semicolon rule's only available on newlines
14:51:43 <Pseudonym> Right.
14:51:58 <Pseudonym> The moral of the story is that Haskell parsers are already magic.
14:52:19 <Pseudonym> One more magic rule would bugger things up probably, but arguably no more than they already are.
14:52:21 <glguy> I saw that if-then-else change idea in the Hskell' list
14:52:31 <glguy> cringed a little bit
14:52:35 <chr1s> Pseudonym: did you catch my paste?
14:52:41 <glguy> seems like we should just teach people that it's 1 expression
14:52:44 <Pseudonym> Yes.
14:52:57 <LoganCapaldo> I think the error is because he has the type declaration
14:53:01 <Pseudonym> First off, ditch the semicolon, chr1s.
14:53:03 <Pseudonym> You don't need it.
14:53:19 <chr1s> ok
14:53:37 <complaisant> ei again
14:53:58 <complaisant> is there any function pre-defined that given a list of bools tests if all of them are equal?
14:54:05 <complaisant> & true..
14:54:11 <chr1s> complaisant: and?
14:54:15 <dibblego> ?type and
14:54:18 <lambdabot> [Bool] -> Bool
14:54:36 <complaisant> tnks
14:54:45 <Excedrin> I thought it might be nice to use SQLite, but what's the deal with this "everything is a string"?
14:54:52 <Pseudonym> Aha.
14:54:57 <Pseudonym> OK, chr1s, suggestion.
14:55:01 <Pseudonym> Comment out the type signature.
14:55:09 <Pseudonym> And see what GHCi says the type of f really is.
14:56:08 <chr1s> that's f :: [a] -> [(a, [a])]
14:56:10 <Pseudonym> complaisant: A more commonly-used function is all.
14:56:14 <Pseudonym> ?type all
14:56:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:56:21 <chr1s> so the [a] is the String
14:56:25 <Pseudonym> Yes.
14:56:37 <Pseudonym> You want it to return (String,String).
14:56:45 <Pseudonym> It wants to return [(Char, String)]
14:56:45 <chr1s> But it returns a list of (Char, String)
14:56:49 <Pseudonym> Yeah./
14:56:55 <Pseudonym> First thing:
14:57:01 <Pseudonym> You're in the list monad.
14:57:17 <Pseudonym> So the do-expression as a whole is going to return a list.
14:57:27 <chr1s> aaah wait
14:57:51 <chr1s> does the list monad extract the x from [x]?
14:57:56 <Pseudonym> Yes.
14:58:04 <Pseudonym> But it is itself a list.
14:58:47 <chr1s> and why's that?
14:59:09 <Pseudonym> Basically a <- [x] draws a from the list [x].
14:59:09 <chr1s> (I'm sorry if I ask stupid questions)
14:59:32 <Pseudonym> ItIt's functionally identical to this:
14:59:38 <Pseudonym> f (x:xs) = do
14:59:42 <Pseudonym>     let a = x
14:59:46 <Pseudonym>     return (a,xs)
14:59:49 <Pseudonym> Whcih is identical to:
14:59:52 <Pseudonym> f (x:xs) = do
14:59:56 <Pseudonym>     return (x,xs)
14:59:59 <Pseudonym> Which is identical to:
15:00:03 <Pseudonym> f (x:xs) = [(x,xs)]
15:00:27 <Pseudonym> Since return just wraps up a value in the monad.
15:00:31 <Pseudonym> Which in this case is the list monad.
15:00:42 <chessguy> @type [(a,[a])]
15:00:44 <lambdabot> Not in scope: `a'
15:00:44 <lambdabot>  
15:00:44 <lambdabot> <interactive>:1:5: Not in scope: `a'
15:00:45 <chr1s> ah, so the <- gets the content of the list, and the return puts it back in a list
15:00:54 <Pseudonym> Yeah.
15:00:56 <chr1s> yeak
15:01:03 <Pseudonym> If the list had more than one element:
15:01:11 <Pseudonym> f (x:xs) = do
15:01:11 <chr1s> ok, so I probably don't want the element
15:01:14 <Pseudonym>     x <- [1,2]
15:01:17 <Pseudonym>     return (x,xs)
15:01:20 <Pseudonym> Then you would get this:
15:01:26 <Pseudonym> f (x:xs) = [(1,xs),(2,xs)]
15:01:31 <Pseudonym> Make sense?
15:01:39 <chr1s> yes!
15:01:59 <Pseudonym> In this case, you don't want to return a list.
15:02:11 <Pseudonym> So you probably don't want to implement this code in the list monad.
15:03:05 <chr1s> so, basically, my more advanced tryout is a really simple parser
15:03:21 <Pseudonym> Err... kind of.
15:03:29 <chr1s> suppose I want to read an int surrounded by brackets
15:03:33 <Pseudonym> List monad-based parsers do kind of resemble this.
15:03:48 <chr1s> wait for a sec
15:04:13 <chr1s> I want to parse, for example "(123)"
15:04:33 <Pseudonym> Right.
15:04:46 <chr1s> and I want it to return (123, ""), where "" is the rest of the string
15:04:56 <Pseudonym> http://www.cs.nott.ac.uk/~gmh/pearl.pdf
15:05:25 <chr1s> and parse "(123)aaa" should return (123, "aaa")
15:05:32 <Pseudonym> If you just have a problem to solve, you could just use Parsec or something.
15:05:38 <chr1s> so what I did was something like this
15:05:41 <Pseudonym> But if you'er trying to learn something, this is useful to know.
15:05:43 <Pseudonym> How it works.
15:05:54 <chr1s> no, I'm actually trying to learn something!
15:06:01 <chr1s> I'm doing a course on it
15:06:24 <Pseudonym> Cool.
15:07:05 * complaisant heist  	Bugatti Type 35  	 28%  	$ 46,400  	 Baltimore --> pm le needed thief+
15:07:21 <Pseudonym> Then go read that paper.
15:07:28 <Pseudonym> If you can find the earlier Wadler paper, read that first.
15:07:33 <chr1s> ok, thanks
15:07:42 * complaisant heist  	Bugatti Type 35  	 28%  	$ 46,400  	 Baltimore --> pm le needed thief+ (quick)
15:08:11 <vincenz> complaisant: ????
15:08:21 <complaisant> ups
15:08:22 <complaisant> sry
15:08:31 <complaisant> wrong server
15:08:35 <Botty> 0-o
15:08:49 <chr1s> thanks a lot btw, you really helped me out
15:08:49 <complaisant> leaving.
15:08:56 * chr1s is off reading the paper
15:09:36 <Pseudonym> No problem.
15:12:14 <dons> today's haskell paper appears to be: http://programming.reddit.com/info/s22r/comments
15:12:15 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
15:12:17 <lambdabot> Title: Why Dependent Types Matter [pdf] (reddit.com), http://tinyurl.com/yx4ej2
15:12:18 <dons> oh
15:12:33 <emu> hehe
15:12:51 * Pseudonym considers replacing 20% of dons' work on IRC with a lambdabot plugin that greps reddit
15:13:11 <Botty> haskell paper? I thought haskell didn't have dependent types
15:13:16 <dons> hmm interesting idea Pseudonym
15:13:23 <Pseudonym> Currently reading: http://homepages.inf.ed.ac.uk/wadler/papers/oopsla/oopsla.pdf
15:13:26 <lambdabot> http://tinyurl.com/saass
15:13:30 <dons> you can already get a key-word limited rss feed from reddit
15:13:34 <Pseudonym> It'd be better if Wadler were actually talking, of course.
15:13:38 <dons> i.e. anything that mentions haskell/types/... in the title
15:13:55 <dons> Botty: Epigram is written in Haskell, and inspired by it
15:14:04 <Botty> oh ok
15:14:43 <wchogg> Also, you can get some of the effects of dependent types in Haskell anyway, e.g. Lightweight Static Capabilities.
15:14:55 <dons> yeah
15:14:58 <Botty> yesh, but not full blown ones
15:14:59 <Pseudonym> I particularly like page 16 of that Wadler presentation, BTW.
15:15:07 <Pseudonym> I want to know where he got that.
15:15:36 <Excedrin> looks like complaisant plays http://www.barafranca.com/
15:15:46 <Pseudonym> I might even take up wearing suits again if I had a tie-dye lambda bow tie.
15:15:54 <dons> Pseudonym: heh
15:16:10 <wchogg> Botty:  Now that I think about it, I guess I'm not actually sure what the difference between what you can do in Haskell versus true dependent types.
15:16:21 <Pseudonym> Sadly, my beard isn't a "neck beard", which is required to look like a true guru.
15:16:59 <fik> Pseudonym, i looked at the log and could'nt catch what presentation you are talking about. @where is it?
15:17:11 <Pseudonym> http://homepages.inf.ed.ac.uk/wadler/papers/oopsla/oopsla.pdf
15:17:12 <Botty> wchogg - compile-time checking that a particular matrix multiplication will work?
15:17:13 <lambdabot> http://tinyurl.com/saass
15:17:32 <Botty> (just an example)
15:17:40 <Igloo> dcoutts: In gentoo, yes
15:17:40 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
15:18:15 <fik> oh yes. you said before i look...
15:18:15 <Botty> lots of other stuff too - have the type system differentiate between empty lists, lists of known length, and lists of unknown length
15:18:19 <Pseudonym> Oooh, Wadler has an O'Reilly book!
15:20:17 <dons> he does?
15:21:00 <Pseudonym> Java Generics
15:21:58 <dons> huh
15:23:46 <wchogg> Botty:  I thought you could do a lot of things like array bounds and empty vs. non-empty lists in Haskell, like in some of those notes by Oleg Kiselyov.  So at what point can you no longer emulate a dependent type system and have to start using a real one?
15:25:17 <Botty> I'm not sure, wchogg, certainly you can do something like it in haskell, but that'd probably get ugly, fast.
15:27:02 <wchogg> Okay.  I was just wondering if there was some theoretic boundary, where there are problems that strictly cannot be attacked in Haskell even with its type system extensions.
15:27:58 <emu> the consistency of arithmetic
15:27:58 <Botty> There could be.  I only know a bit of epigram, and I've only used functional languages for about 3 months ;)
15:28:09 <Pseudonym> Termination.
15:28:11 <dons> I think there probably is: we just don't know yet. There are certainly things in epigram we have no way to do yet
15:28:20 <dons> termination would be a good case
15:28:36 <dons> and any other strong proof. simple things like Nats on the type level we can do
15:28:36 <Pseudonym> Compute the busy beaver function using typeclass meta-programming.
15:29:25 <dons> so only trivial dependently typed tricks are doable in haskell
15:29:34 <wchogg> Ah, okay.
15:29:37 <dons> but you can always add a theorm prover to the compilation process
15:29:44 <dons> and get as many proofs sa you want
15:29:45 <emu> it's not slow enough as it is
15:30:17 <Botty> emu - is that a crack at defining Nats using church numerals
15:30:32 <emu> no, adding a thm prover to the compilation process
15:30:33 <Botty> because epigram plans numeric primitives :)
15:30:34 <dons> so people looking for some strong proofs, that maybe they could write in a dependently typed system, currently translate their haskell into their theorem prover, and check that
15:30:36 <Botty> oh ok
15:30:38 <wchogg> I'm confused though.  I thought you couldn't in general prove that a program terminates?
15:30:50 <Botty> you can for many functions
15:30:57 <dons> see epigram :)
15:31:21 <dons> we could partition a terminating sub language in haskell into its own kind
15:31:23 <Botty> does epi have strong termination stuff?
15:31:29 <emu> if you restrict yourself to the primitive recursive functions
15:32:14 <wchogg> Okay, so you're using a restricted enough sublanguage that you don't get bitten by the halting problem?
15:32:32 <Excedrin> that's the typical approach to genetic programming afaik
15:32:54 <Pseudonym> Gotta go.  Seminar.
15:32:55 <Pseudonym> BBS
15:33:04 <dons> check the epigram paper, iirc it goes through how they use recursion based on structural induction only to get proofs of termination (iirc)
15:33:13 <wchogg> Okay.
15:34:20 <Botty> so, does this solve the halting problem...
15:34:37 <Botty> or theorem or whatever it is called
15:35:07 <pkhuong> Botty: no, since it doesn't accept arbitrary programs that do terminate.
15:35:23 <pkhuong> (some)
15:36:25 <psnl> Botty: a epigram program is strongly normalizing
15:36:42 <psnl> Botty: in real terms, a computation that never ends is useless
15:36:49 <Botty> oh
15:37:34 <psnl> things like servers have some input, do some computation, give some output, then repeat that forever
15:43:11 <greentea> Hi all.
15:51:41 <dons> hey greentea
15:52:24 <greentea> Hi dons. :-)
15:57:07 <palomer> grr
15:57:19 <palomer> how do you escape characters with listings (latex)?
15:59:59 <eviltwin_b> if you're doing program listings, look at the verbatim environment
16:00:51 <eviltwin_b> (and for short inline stuff, \verb)
16:06:10 <_matthew-> palomer: the other trick is to use {} to separate out the backslash from the work to stop latex interpreting it
16:06:29 <_matthew-> but the verbatim class is better (also, fragile and semiverbatim if you're using beamer is good)
16:06:59 <_matthew-> @seen ToRA
16:07:00 <lambdabot> ToRA is in #haskell. I last heard ToRA speak 10h 10m 17s ago.
16:20:46 <dons> ?users
16:20:47 <lambdabot> Maximum users seen in #haskell: 276, currently: 233 (84.4%), active: 30 (12.9%)
16:26:47 <EvilRanter> hm... are there any weird caveats i need to be aware of wrt the Network module (or IO in general) on winhugs?
16:27:26 <Limbic_Region> lambdabot nopaste?
16:27:39 <Limbic_Region> lambdabot paste?
16:27:43 <kpreid_> @paste
16:27:44 <lambdabot> http://paste.lisp.org/new/haskell
16:27:46 <Limbic_Region> thanks
16:31:18 <dons> EvilRanter: you have to initialise sockets on  windows  first. that's it.
16:31:33 <dons> (if you're using sockets: and that's just a windows thing, not winhugs specifici)
16:32:01 <EvilRanter> main = withSocketsDo $ do {...} etc?
16:32:18 <dons> yep
16:33:45 <dons> no need for the { } though
16:34:02 <dibblego> ?hoogle [[a]] -> [a]
16:34:04 <lambdabot> Prelude.concat :: [[a]] -> [a]
16:34:23 <dons> morning dibblego
16:34:27 <dibblego> g'day
16:34:30 <dons> you watch the cricket?
16:34:35 <dibblego> not really
16:34:39 * dons enjoys being a phd student sometimes
16:34:41 <dibblego> far too slow
16:34:48 <dibblego> I really should be one of those too
16:36:21 <dibblego> let f [] = []; f [[x]] = [x]; f (x:xs) = x ++ f xs in f ["abc", "def", "ghi"]
16:36:23 <dibblego> > let f [] = []; f [[x]] = [x]; f (x:xs) = x ++ f xs in f ["abc", "def", "ghi"]
16:36:25 <lambdabot>  "abcdefghi"
16:37:49 <sjanssen> dibblego: the [[x]] case is redundant
16:38:10 <dibblego> > let f [] = []; f (x:xs) = x ++ f xs in f ["abc", "def", "ghi"]
16:38:11 <lambdabot>  "abcdefghi"
16:38:19 <dibblego> why did I think that?
16:38:40 <sjanssen> the world may never know
16:38:46 <dibblego> @let f [] = []; f (x:xs) = x ++ f xs in f ["abc", "def", "ghi"]
16:38:47 <lambdabot>  Parse error
16:39:10 <sjanssen> > concat ["abc", "def", "ghi"] -- in fact, the whole function is redundant ;)
16:39:11 <lambdabot>  "abcdefghi"
16:39:31 <yaxu> http://yaxu.org/haskell2.avi # another haskell music experiment
16:39:52 <metaperl> yaxu developed using what?
16:40:06 <metaperl> i'm listening to something right now or I would d/l it
16:40:43 <dibblego> > let f [] = []; f (x:xs) = x : f xs in f ["abc", "def", "ghi"]
16:40:44 <lambdabot>  ["abc","def","ghi"]
16:40:59 <dibblego> > let f [] = []; f [[x]] = [x]; f (x:xs) = x : f xs in f ["abc", "def", "ghi"]
16:41:00 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
16:41:00 <lambdabot>    Expected...
16:41:37 <yaxu> metaperl: i'm using parsec to parse a simple grammar and sending OSC packets to supercollider to trigger sounds
16:41:49 <metaperl> oh
16:42:01 <dons> i love structural recursion. it makes coding list processing mechanical. more coding without thinking
16:42:22 <dons> (along with pattern matching. those two together)
16:42:44 <sjanssen> I love folds, even less coding ;)
16:42:47 <dons> :)
16:43:04 <dons> sjanssen: you have 60 seconds: give me this as a fold.
16:43:05 <dons> teXesc []       = []
16:43:05 <dons> teXesc ('#':xs) = '\\':'#':teXesc xs
16:43:05 <dons> teXesc (x  :xs) = x : teXesc xs
16:43:42 <sjanssen> > foldr (\x xs -> if x == '#' then '\\':'#':xs) [] "#stuff$#"
16:43:43 <lambdabot>  Parse error
16:43:48 <dons> close!
16:44:00 <sjanssen> > foldr (\x xs -> if x == '#' then '\\':'#':xs else xs) [] "#stuff$#"
16:44:02 <lambdabot>  "\\#\\#"
16:44:06 <dons> sjanssen++
16:44:08 <dons> :D
16:44:18 <sjanssen> that could be made shorter, if we had a fold for Bool
16:44:30 <dons> [11:38  dons> sjanssen: you have 60 seconds] . [11:39  sjanssen> > foldr ..]
16:44:37 <Pseudonym> > foldr (\c -> if c == '#' then ("\\#"++) else (c:)) [] "#stuff##"
16:44:39 <lambdabot>  "\\#stuff\\#\\#"
16:44:40 <Pseudonym> Slightly shorter.
16:44:54 <dons> sjanssen: or guards on lambdas
16:45:01 <sjanssen> @pl (\x xs -> if x == '#' then '\\':'#':xs else xs)
16:45:02 <lambdabot> join . (. ("\\#" ++)) . if' . ('#' ==)
16:45:23 <sjanssen> wow, pl is smart enough to join the characters?
16:45:26 <araujo> yaya aya
16:45:31 <dons> trikcy
16:45:38 <dons> TheHunter put some good stuff in @pl
16:46:01 <Pseudonym> > "#stuff##" >>= \c -> if c == '#' then "\\#" else [c]
16:46:02 <lambdabot>  "\\#stuff\\#\\#"
16:46:11 * araujo jumps at throws lambdas at everybody 
16:46:43 <dons> Pseudonym++ nice
16:46:48 <Pseudonym> Even more elegant with =<<
16:47:08 <dons> yeah, bonus points for implicit folds encoded in a monad
16:47:49 <Pseudonym> If I was being truly monadic, of course, I'd use return c instead of [c].
16:48:04 <dons> ?pl teXesc xs = (\c -> if c == '#' then "\\#" else [c]) =<< xs
16:48:05 <lambdabot> teXesc = (ap (flip if' "\\#" . ('#' ==)) return =<<)
16:48:44 <Pseudonym> I'd be tempted to use the robot ninja operator instead of return there.
16:48:55 <dons> should be in Data.List
16:48:55 <Pseudonym> Sorry, robot monkey ninja.
16:49:09 <psykotic> no zombie pirates?
16:49:09 <dons> hmm. box = (:[]) -- would make a good proposal. but then return is ok for that
16:49:15 <Pseudonym> Right.
16:49:26 <Pseudonym> "box" is only useful if you're trying to save characters.
16:49:44 <dons> yeah
16:49:59 <psykotic> monkey = (:[])
16:50:08 <EvilRanter> i like "enlist x = [x]; unlist [x] = x"...
16:50:23 <Pseudonym> ?hoogle (a -> Bool) -> a -> a
16:50:25 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
16:50:44 <EvilRanter> 'cos (:[]) is ugly, and return'll confuse people who don't grok monads
16:51:12 <kosmikus> I actually think (:[]) is the clearest
16:51:19 <wolverian> I've seen wrap x = [x]
16:51:31 <Pseudonym> @let cond p a b = if p a then a else b
16:51:32 <lambdabot> Defined.
16:52:05 <dons> its called box (as a helper) in data.list
16:52:07 <sjanssen> dons: you're on the committee, you should try to get cond in the standard ;)
16:52:38 <dons> sjanssen: you could propose it for Data.Function
16:52:48 <Pseudonym> Oh, free food.
16:52:50 <Pseudonym> BRB
16:53:12 <dons> there's libraries of pointfree stuff out there that could go into Data.Function
16:53:26 <dons> the minho guys' work, and stuff from the bananas papers
16:53:39 <sjanssen> arguably, cond should go in Data.Bool
16:53:45 <sjanssen> and should probably be called cond
16:53:45 <dons> and a generalisation of (.) . (.)
16:53:58 <sjanssen> s/cond/bool
16:54:04 <psnl> I really ought to start parsing "pointfree" as "pointfree" rather then "pointless"
16:54:12 <dons> ?pl \f g x y -> (f (g x y))
16:54:12 <lambdabot> (.) . (.)
16:54:36 <dons> kosmikus: do you know of any work on these functions ^^
16:54:42 <dons> i'm trying to work out a good name for them
16:54:53 <dons> (.),  (.) . (.), ...
16:55:04 <sjanssen> heh, sometimes Bulat's speech is surreal
16:55:51 <dons> we should try to resolve this can't-update-fps-without-rebuilding-base issue one way or the other
16:55:52 <sjanssen> @remember Bulat Base lib includes everything, from 'const' to starship control
16:55:59 <dons> that's a good quote :)
16:56:14 <kosmikus> dons: do you really think we need all of these as library functions?
16:56:44 <sjanssen> well, the true problem is that GHC can't handle overlapping module names
16:56:52 <sjanssen> so that should be fixed, if at all possible
16:56:56 <dons> kosmikus: maybe not. (not in base anyway). just wondering if they have names already
16:57:07 <dons> cond , perhaps. yes.
16:57:10 <dons> sjanssen: yes.
16:57:37 <kosmikus> dons: cond in the strange definition above?
16:57:56 <kosmikus> dons: I've always used "cond" as a functional version of "if-then-else"
16:58:09 <sjanssen> however, as soon as somebody tries to tackle that problem, we get all kinds of package mounting proposals
16:58:12 <dons> ah yes, that's what I read it as :) sjanssen means something else I see.
16:58:12 <sjanssen> so it doesn't happen
16:58:38 <dons> cond a b c = if a then b else c -- is what I meant
16:59:05 <kosmikus> dons: would comp1 = comp = (.) and compN = (.) . comp(N-1) make sense?
16:59:13 <dons> hmm!
16:59:30 <kosmikus> dons: yes, I could live with your definition of cond
16:59:31 <sjanssen> looks like I didn't read Pseudonym's function closely enough
16:59:49 <sjanssen> I meant a function like if'
17:00:47 <kosmikus> ?hoogle Bool -> a -> a -> a
17:00:49 <lambdabot> No matches, try a more general search
17:02:21 <dons> yes, so these functions:
17:02:22 <dons> compose  = (.)
17:02:22 <dons> compose2 = (.) . (.)
17:02:22 <dons> compose3 = (.) . (.) . (.)
17:02:22 <dons> compose4 = (.) . (.) . (.) . (.)
17:02:53 <dons> (just noticing that particularly compose{2,3} come up a lot here)
17:03:54 <sjanssen> how about "class (HNat n) => Compose n f where compose :: n -> f"
17:04:20 <dons> i.e.
17:04:22 <dons> sequence `compose2` replicate ==
17:04:23 <dons> (sequence .) . replicate      ==
17:04:23 <dons> replicateM
17:04:24 <kosmikus> fix (\x -> yes, but I generally think that that's the x where an x becomes useful again)
17:04:27 <sjanssen> then "instance Compose Zero a where compose = flip const"
17:04:34 <kosmikus> er
17:04:38 <kosmikus> well, whatever
17:04:43 <araujo> dons, comp2 , comp3 .. compN ?
17:05:06 <kosmikus> didn't make sense, too tired, good night
17:05:10 <dons> :)
17:05:25 <dons> sjanssen: yeah, good idea to use HNat there
17:05:50 <kosmikus> sjanssen, dons: we're not seriously proposing to use HNat in standard libraries, are we?
17:05:53 <sjanssen> then, we simply add numeric kinds . . .
17:05:58 <dons> hehe i hope not
17:06:05 <sjanssen> kosmikus: not actually
17:06:08 <kosmikus> ok
17:06:18 <kosmikus> then have fun
17:06:19 <sjanssen> but, to play the devil's advocate, why not?
17:07:09 <sjanssen> we can generalize and automate all these compose functions, so it doesn't seem to be a /terrible/ solution
17:07:55 <dons> would be ok for a self-contained standalone package
17:08:12 <dons> where the type goo was hidden from the user
17:09:13 <dons> kosmikus: thinking about coming to the hackathon?
17:09:21 <kosmikus> sjanssen: error messages?
17:09:28 <kosmikus> dons: are you going?
17:09:33 <dons> yes :)
17:09:57 <dons> ?where+ hac07 http://haskell.org/haskellwiki/Hac_2007
17:09:57 <kosmikus> wow, long trip
17:09:58 <lambdabot> Done.
17:10:12 <dons> kosmikus: yeah, i'll be over your side of the globe for PADL/POPL anyway
17:10:28 <kosmikus> ah, right. that's why you placed it there.
17:10:31 <dons> yep
17:11:33 <kosmikus> I'm not so sure. I just recently had one hackathon ...
17:11:44 <dons> oh? at ICFP?
17:12:05 <kosmikus> yes. and since you said you've got only 20 slots for participants, they'll probably be very easy to fill.
17:12:28 <kosmikus> so it's probably better to leave them to others who haven't had the general ghc hacking intro yet.
17:12:51 <dons> this isn't a ghc hackathon though, its more libraries/cabal/infrastructure stuff.
17:12:57 <kosmikus> right
17:13:09 <dons> but yes, i take your point.
17:13:21 <kosmikus> maybe I should read the announcement again ;)
17:15:08 <kosmikus> let's see how many registrations you have a week from now.
17:15:14 <kosmikus> registration deadline is very soon, I see
17:15:28 <dons> yes, 6th.
17:15:43 <dons> since if we have over 20 registrants, we intend to prune the list in favour of hackers who know the code
17:15:50 <Igloo> It's only soon so we can confirm soon so people can book travel
17:15:52 <dons> and then we'll have to confirm to those who will be coming
17:16:00 <kosmikus> will Syntax be there?
17:16:12 <dons> haven't heard from him yet.
17:16:24 <kosmikus> Igloo: travel to Oxford is usually unproblematic. so many flights to London ...
17:17:03 <Igloo> If we have <20 signed up by the registration date then there is no deadline at all
17:17:08 <dons> yep
17:17:17 <Igloo> (which I suspect will be the case)
17:18:15 <dons> hmm, beginner haskeller writes gtk road/traffic simulator: http://docs.google.com/View?docid=d7wwtkj_3dg5667
17:18:18 <lambdabot> Title: Programa dos carrinhos (Haskell), http://tinyurl.com/y3ss2a
17:18:28 <kosmikus> Igloo: difficult to judge; very many people came to Fun
17:18:37 <dons> "road congestions can sometimes behave like waves, and
17:18:37 <dons> decided to take that as an oportunity to learn Haskell. The result is my
17:18:38 <dons> first Haskell program."
17:18:54 <Igloo> True
17:19:29 <metaperl> can you create categories with HOPE <http://www.scannedinavian.com/hope/entry>
17:20:05 <metaperl> ah, I see them <http://www.scannedinavian.com/hope/tag>
17:20:13 <kosmikus> dons: your paper is famous ;) --> http://www.cs.uu.nl/wiki/Stc/RewritingHaskellStrings
17:20:17 <lambdabot> Title: Stc / Rewriting Haskell Strings, http://tinyurl.com/uxnor
17:21:05 <dons> oh my!
17:21:28 <dons> hehe cool. yes, he mentioned he was going to give a talk
17:22:08 <kosmikus> it's a good paper
17:22:22 <dons> its good to put slides online: people can give your talks for you, all over the world
17:22:38 <kosmikus> heh :)
17:23:37 <kosmikus> dons: do you know already what you'll do when your PhD is finished?
17:23:47 <dons> I expect to finish in July
17:23:54 <dons> but after that, not sure yet
17:24:22 <kosmikus> could you stay at UNSW?
17:24:47 <dons> possibly, but i'm more interested in heading over to the UK (or US).
17:25:12 <kosmikus> but still at a university?
17:25:14 <dons> perhaps intern at MS Research? or one of the haskell companies out there..
17:25:51 <dons> kosmikus: if there was a good project to work on, university would ok, yeah.
17:27:55 <kosmikus> the more I think about it, the more I'd like to work on Cabal a bit. too much stuff has been happening that I didn't really like. seems like the hackathon would be my chance ;)
17:28:07 <dons> exactly!
17:28:10 <kosmikus> I'll check if I can find the time.
17:28:30 <dons> even if you drop by for just 1 or 2 days, that would be worthwhile
17:28:58 <kosmikus> it's only 3 days, isn't it?
17:29:09 <dons> yes
17:29:17 <dons> Jan 10-12, Wed,Thu,Fri
17:29:28 <palomer> yo my bitches
17:29:42 <psykotic> crap, that's just after i go back to korea after visiting my family in denmark for christmas
17:29:59 <psykotic> palomer, do you have that phrase bound to a hot-key?
17:29:59 <Pseudonym> Back.
17:30:17 <Pseudonym> It's a weird experience, going to seminars where you don't understand most of it.
17:30:25 <dons> Pseudonym: heh
17:30:35 <kosmikus> Pseudonym: reminds me of my time as a mathematician.
17:30:42 <psykotic> kosmikus, i was just going to say that.
17:30:59 <Igloo> kosmikus: What don't you like?
17:31:24 <Pseudonym> kosmikus: In future years I'll be reminded of my time as a nanotechnician.
17:32:00 <kosmikus> Igloo: oh, it's nothing in specific, actually, I'm just being negative ;) just a general feeling that things are too complicated and that it's not really working well in general.
17:32:11 <Pseudonym> Actually, this seminar wasn't too bad.
17:32:14 <Pseudonym> I could follow most of it.
17:32:32 <Pseudonym> Even though I had no idea, for example, why titanium dioxide and not something else.
17:32:44 <dons> I think cabal is working pretty well as a build system for libs and executables
17:32:59 <dons> getting hackagedb done might be the big goal for the hackathon though
17:33:00 * Igloo is scared by the cabal code I've seen
17:33:37 <kosmikus> I've heard various complaints by people that have existing products out there that Cabalizing them proves hard.
17:33:51 <kosmikus> with my own lhs2tex experience, I'm tempted to confirm this impression.
17:34:10 <dons> yeah. it keeps new projects portable and clean, but isn't flexible enough yet with arbitrary preprocessing and building requirements
17:34:24 <Igloo> Isn't lhs2tex just a single executable?
17:34:44 <kosmikus> the main problems I see are (1) it's not released often enough, (2) compatibility between releases is usually not maintained (I know this is somewhat contradictory)
17:35:10 * Igloo thinks the release rate matches the development rate well, but both are too slow
17:35:15 <kosmikus> Igloo: lhs2tex is difficult because it installs some TeX files as well
17:35:25 <Igloo> Ah, OK
17:35:37 <dons> right, so extra files is an outstanding issue still I think
17:35:44 <dons> data files and so on
17:35:56 <dons> (there's some way to deal with this though, iirc?)
17:36:10 <kosmikus> I think that the current philosophy of Cabal is to integrate *everything* in Distribution.Simple.
17:36:24 <Igloo> You could certainly do it with a hook; I don't know about anything else
17:36:28 <kosmikus> I'd rather focus on providing a good library and making the hooks mechanism more usable.
17:36:55 <dons> kosmikus: you and swiert could always sit down and implement a new version control system based on your paper, for the hackathon ;) that'd be fun.
17:37:03 <kosmikus> Igloo: I do. But you can bet that I have to rewrite the Setup.hs for every new Cabal version there might be ;)
17:37:18 <Igloo> :-)
17:37:39 * Igloo wonders how much resistance there would be to changing the defaultHooks name to refer to the actual default hooks
17:37:40 <kosmikus> dons: when I was in Nottingham last week, I actually started to hack a small system with swiert.
17:37:46 <dons> ooh nice!
17:37:54 <dons> code online?
17:38:00 <edwardk> > let g(q,r,t,k,n,l) = if 4*q+r-t<n*t then n:g(10*q,10*(r-n*t),t,k,div(10*(3*q+r))t-10*n,l) else g(q*k,(2*q+r)*l,t*l,k+1,div(q*(7*k+2)+r*l)(t*l),l+2) in concatMap show $ g (1,0,1,1,3,3)
17:38:03 <lambdabot>  "314159265358979323846264338327950288419716939937510582097494459230781640628...
17:38:05 <kosmikus> dons: however, I don't really want to replace darcs. I'd much rather convince the darcs developers to implement our paper :)
17:38:16 <dons> yeah
17:38:19 <dons> agreed
17:38:23 <dons> edwardk++
17:38:31 <edwardk> hah
17:38:32 <kosmikus> or not even implement it, but prove more stuff about the well-behavedness of darcs.
17:39:12 <dons> kosmikus: its good that the theory is now finally ahead of the implementation (so often in RCS' the theory is way behind, or not there at all)
17:39:14 <kosmikus> I'm curious what the rejection reports will say about the paper.
17:39:37 <Igloo> Do you know it's been rejected, or are you predicting it will be?
17:39:40 <dons> oh, it wasn't accepted?
17:39:51 <coffeemug> hey guys
17:39:54 <metaperl> @seen shapr
17:39:55 <lambdabot> I saw shapr leaving #haskell-blah, #ScannedInAvian and #haskell 1d 7h 5m 16s ago, and .
17:39:56 <dons> hey coffeemug
17:40:00 <metaperl> coffeemug hello
17:40:08 <coffeemug> good evening gentlemen :)
17:40:09 <kosmikus> dons: I wouldn't necessarily say that. There's a gap between the theory (if you mean the paper) and the implementation that must be bridged. Probably the implementation is still way ahead, because we haven't solved all problems.
17:40:21 <kosmikus> Igloo: I'm predicting it will be.
17:40:35 <kosmikus> notification is sometime in Decemeber
17:40:40 <dons> ah, interesting. so darcs is doing things we don't have a good theory for yet.
17:41:36 <coffeemug> dons: I was digging through some stuff recently and thouhgt of smtg
17:41:43 <dons> ah yes?
17:42:00 <coffeemug> the file merging functionality of hs-plugins should probably be separated into another library
17:42:19 <dons> yeah, i was thinking of that for hs-plugins 2.0
17:42:26 <dons> just a stripped down linker only
17:42:34 <dons> and have the merge stuff separate (its useful for other things)
17:42:49 <coffeemug> yeah, the merge stuff is very useful outside of hs-plugins
17:43:06 <coffeemug> just for preprocessing haskell code
17:43:12 <coffeemug> so scrap some boilerplate
17:43:13 <dons> yep
17:43:14 <coffeemug> to
17:43:37 <coffeemug> I'm just going to rip out a relevant module for now :)
17:43:39 <kosmikus> ok, really good night this time :)
17:43:46 <dons> night kosmikus
17:43:52 <dons> coffeemug: go for it
17:44:42 <edwardk> anyone here comfortable with ana/cata/hylo/etc morphisms and feel like kicking around a concrete syntax for them?
17:45:57 <edwardk> been toying with them a lot the last day or so, got to apo, zygo, etc and the syntax i have so far starts to make less sense for them
17:46:17 <coffeemug> why does TH seem to be using different data types from what Language.Haskell.Syntax provides?
17:46:18 <edwardk> http://comonad.com/paste/9 has some examples
17:46:57 <dons> coffeemug: just happens to be that way :) (could be merged, I suspect)
18:01:17 <palomer> psykotic, you're going to korea?
18:01:21 <palomer> 안녕!
18:10:33 <Pseudonym> > let z a b c d xs'@(x:xs)=let t=a`div`c in if all(>0)[a,b,c,d]&&t==b`div`d then t:z(10*(a-c*t))(10*(b-d*t))c d xs' else z(x*a+b)a(x*c+d)c xs;f n=1:1:n:f(n+1)in concatMap show.z 1 0 0 1$[2,1,2]++f 4
18:10:35 <lambdabot>  "271827725797700741844009111824681176907613550637995191159701186484239994486...
18:10:39 <Pseudonym> Woo.
18:10:45 <Pseudonym> ...
18:10:47 <edwardk> pseudonym =)
18:10:49 <Pseudonym> Except it's wrong.
18:10:53 <edwardk> =/
18:11:51 <Pseudonym> > let z a b c d xs'@(x:xs)=let t=a`div`c in if all(>0)[a,b,c,d]&&t==b`div`d then t:z(10*(a-c*t))(10*(b-d*t))c d xs' else z(x*a+b)a(x*c+d)c xs;f n=1:1:n:f(n+2)in concatMap show.z 1 0 0 1$2:1:2:f 4
18:11:53 <lambdabot>  "271828182845904523536028747135266249775724709369995957496696762772407663035...
18:11:56 <Pseudonym> That's it.
18:12:21 <psykotic> palomer: i live there.
18:12:23 <Pseudonym> It's a little more succinct than pi, too.
18:12:27 <edwardk> yeah
18:14:45 <palomer> psykotic, what do you do?
18:15:45 <Pseudonym> Anyway, gotta go.
18:15:46 <Pseudonym> Cya tomorrow.
18:15:49 <Pseudonym> Fare well.
18:17:26 <palomer> brb
18:31:37 <dcoutts> Igloo, it is possible to slot multiple versions of a package, yes. However for Haskell packages we can't actually do it sensibly because of some dep problems.
18:33:04 <Igloo> OK
18:36:48 <dcoutts> we've spent some time thinking about how to improve portage to the point where we could express the deps properly and then slot ghc and all the libs
19:11:57 <dons> dcoutts: any screen shots of the gtk traffic simulator?
19:12:08 <dcoutts> lemme make one
19:12:47 <dcoutts> http://dhcp0878.gradacc.ox.ac.uk:8080/~duncan/Screenshot-S.A.R.A.H..png
19:12:49 <lambdabot> http://tinyurl.com/y4nahh
19:13:22 <dons> oh very interesting
19:13:47 <dcoutts> dons, the circles (cars) go around a circular circuit
19:14:06 <dcoutts> you can see that I've introduced a temporary roadblock to slow the cars
19:14:29 <dons> right
19:14:34 <dcoutts> then the interesting this is to see if this tailback is self-sustaining
19:14:38 <dcoutts> thisthing
19:14:42 <dcoutts> this/thing
19:14:43 <dons> is there an easy way to create a screen cast of it?
19:14:51 <dcoutts> not sure
19:15:17 <dons> ?seen yaxu
19:15:17 <lambdabot> I saw yaxu leaving #haskell 2h 9m 58s ago, and .
19:15:21 <dufflebunk> tightvnc shared mode?
19:15:40 <dcoutts> I've used something like that before but the results were pretty poor
19:15:53 <dcoutts> vnc2svf
19:15:56 <dcoutts> or something like that
19:16:02 <dons> xwd should have a --mpg mode ;)
19:16:08 <dcoutts> it made flash things from vnc
19:16:20 <dons> there must be a free tool these days for creating screen dumps as mpgs, surely..
19:16:28 <dcoutts> you'd think so
19:19:17 <Revision17> @hoogle weighted graph
19:19:18 <lambdabot> Did you mean: Weighted Graph
19:19:18 <lambdabot> Prelude.undefined :: a
19:19:18 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:19:19 <dufflebunk> I think I've seen them from time to time on freshmeat
19:20:13 <dcoutts> dons, you subscribe to gtk2hs-users then do you ? :-)
19:20:20 <wolverian> @hoogle inductive
19:20:21 <lambdabot> Data.Graph.Inductive :: module
19:20:26 <wolverian> Revision17, that's probably what you want.
19:20:35 <wolverian> (roughly, anywa.y)
19:20:43 <wolverian> er. that's a weird typo.
19:20:46 <Revision17> wolverian: thanks, I hadn't anticipated it being named that
19:24:01 <dons> dcoutts: yes
19:24:18 <dcoutts> keeping track of things :-)
19:24:52 <dons> yep
19:25:04 * dons hacks on smp-parallel Properties.hs driver
19:25:50 <dcoutts> dons, oh parallel quickcheck ?
19:25:55 <dons> yeah
19:25:58 <dcoutts> nice
19:26:02 <dons> run all the tests on as many cores as we can :)
19:26:13 <sjanssen> jawesome
19:26:25 <dons> i'll create a little cabal module for Test.QuickCheck.Parallel
19:26:28 <dcoutts> dons, so for that kind of thing is it best to take as a parameter the level of parallelism?
19:26:34 <dons> which looks like Test.QuickCheck.Batch, but more so
19:26:43 <dons> dcoutts: I'm thinking just let the -N flag sort it out
19:26:46 <dons> but we'll see how it goes
19:26:55 <dons> might have to constraint the granularity
19:27:11 <sjanssen> dons: using par, then?
19:27:39 <dcoutts> dons, I mean spawning all 100 tests and letting 2 of them run in parallel at once is not likely to be faster than running 2 threads which to 50 each.
19:27:41 <sjanssen> or do you fork all your threads right away and just let them run simultaneously?
19:27:41 <dons> basically just:
19:27:42 <dons>     chan <- newChan
19:27:42 <dons>     (`mapM_` tests) $ \(s,a) -> forkIO $
19:27:42 <dons>             v <- a n
19:27:42 <dons>             writeChan chan (printf "%-25s: %s" s v)
19:27:45 <dons>     mapM_ putStr ls =<< getChanContents chan
19:27:55 <dons> but you could tune the chunks size
19:28:13 <dons> i.e. maybe set the -N size, and break the list into those chunks
19:28:20 <dons> the list of tests
19:28:47 <dcoutts> dons, in general, many parallel algorithms take a parallelism parameter (aka num cpus), I wonder if there should be a lib function for getting that.
19:28:55 <dons> dcoutts: hmm!
19:29:01 <dons> there's probably a C lib for that..
19:29:08 <dons> an env var would do
19:29:10 <dcoutts> though of course only for tuning, not for correctness or other dodgy assumptions
19:29:24 <Botty> Syntax idea, string interpolation:
19:29:24 <dcoutts> dons, just getting the rts -N parameter is enough, no?
19:29:24 <Botty> "({line}, {column})"
19:29:24 <Botty> Equivalent to:
19:29:24 <Botty> '(' : (shows line $ showString ", " $ shows column)
19:29:41 <dons> Botty: have you seen the existing string interpolatoin lib?
19:29:45 <dons> dcoutts: right
19:29:51 <Botty> uh, nope
19:30:12 <dcoutts> dons, so it'd be easy to do as a ghc primop or a foreign call into the rts.
19:30:18 <dons> yeah
19:30:46 <dons> Botty: http://www.cse.unsw.edu.au/~dons/code/icfp05/tests/unit-tests/VariableExpansion.hs
19:30:48 <lambdabot> http://tinyurl.com/tpkn7
19:30:52 <dons> (note the url ;)
19:30:59 <dons> (not the "dons" part)
19:31:06 <Botty> heh, yeah, thanks
19:36:46 <dibblego> hey dons I wrote instance Monad for that Maybe type :) but I dare not publish it
19:37:13 <dons> heh
19:37:29 <dibblego> I think it will scare people away
19:38:18 <dibblego> ah bugger it, I will
19:40:09 <dons> yeah, this seems to work nicely:
19:40:10 <dons>     let jobs = splitN (length tests `div` cpus) tests
19:40:10 <dons>     chan <- newChan
19:40:10 <dons>     (`mapM_` jobs) $ \ts -> forkIO $ (`mapM_` ts) $ \(s,a) -> do
19:40:10 <dons>             v <- a n
19:40:12 <dons>             writeChan chan (printf "%-25s: %s" s v)
19:40:15 <dons>     mapM_ putStr =<< getChanContents chan
19:40:23 <dons> so fork 'cpu' count threads, and distribute the tests over that
19:40:47 <dons> now to try it on the smp machine
19:52:26 * monochrom is reading Landin's original papers on "applicative expressions" and using them to understand Algol :)
19:53:52 <monochrom> It's amazing.  The one on Algol basically contains all inventions we use today, ranging all the way from the most trivial "let's use layouts" to the most profound "J operator" that would become continuations later.
19:54:18 <monochrom> ("applicative expression" = lambda calculus with call-by-value.)
19:55:04 <LoganCapaldo> I was under the impression that Algol was call-by-name? Did my professor lead me astray?
19:55:58 <monochrom> Algol offers both by-value and by-name.  Use a keyword to request by-name.
19:56:20 <LoganCapaldo> Ah
19:56:30 <palomer> screw haskell, algol is the language of the future
19:56:32 <jcreigh> monochrom: points for refering to Algol in the present tense. :)
19:56:38 <palomer> yo my sistas
19:56:42 <monochrom> haha
19:56:48 <monochrom> Hey palomer you're back?!
19:56:51 <palomer> yeah
19:56:54 <palomer> it was a nickban
19:56:57 <palomer> and then it got removed
19:57:22 <palomer> and #haskell isn't #haskell without palomer
19:57:30 <palomer> monochrom, have you heard of PEGs?
19:57:39 <monochrom> No, I don't think so.
19:58:10 <palomer> http://pdos.csail.mit.edu/~baford/packrat/
19:58:12 <lambdabot> Title: Packrat Parsing and Parsing Expression Grammars
19:58:14 <palomer> linear time parsing
19:58:21 <monochrom> krad
19:58:30 <palomer> the only disadvantage is no left recursion
19:58:31 <pkhuong> O(eek!) space parsing too ;)
19:58:31 <palomer> I think
19:58:43 <Korollary> JohnMeacham_ wrote a packrat parser iirc
19:58:58 <palomer> Korollary, PEGs = CFGs without left recursion
19:58:58 <palomer> ?
19:59:20 <monochrom> I don't miss left recursion.
19:59:27 <Korollary> Umm, I dont really know.
19:59:28 <edwardk> palomer: and they are also linear space, so they are HUGE memory wise
19:59:38 <monochrom> AH!
20:00:03 <palomer> erm
20:00:06 <palomer> they're all linear space
20:00:06 <LoganCapaldo> The order matters in PEGs too
20:00:28 <edwardk> palomer: the others are like n log n worst case, but they tend to be log n in practice
20:00:41 <palomer> LoganCapaldo, order doesn't matter in unambiguous CFGs though
20:00:46 <edwardk> packrat is rules * n always
20:01:25 <monochrom> Hmm, if we talk about parsing into an abstract syntax tree, linear space is the minimum right?
20:01:36 <LoganCapaldo> palomer: k, was just pointing differences besides no left recrsion
20:01:37 <palomer> monochrom, right
20:01:44 <palomer> LoganCapaldo, righto!
20:02:05 <edwardk> monochrom: well, assuming no reductions, if you parse and reduce as you go, then you can deal with less, plus the constant is big
20:02:34 <monochrom> Right, I'm thinking the space question should be set in the evaluate-as-you-parse setting.
20:02:50 <palomer> edwardk, what are the disadvantages (expressibility wise) of PEGS?
20:03:15 <palomer> rules * n doesn't seem like much space
20:03:41 <edwardk> well, if i have a lot of rules that can be pretty bad
20:03:45 <LoganCapaldo> Just have many small source files instead of one large one :)
20:03:52 <monochrom> I also gather from some other source that a parser of log space is also probably very slow in time.
20:04:35 <palomer> and really complicated to code
20:04:42 <edwardk> mono: i was just pointing out you only need to keep around just the part of the stack that you haven't reduced.
20:05:13 <palomer> http://www.haskell.org/haskellwiki/Embedding_CFG <--this is for PEG parsing, right?
20:05:16 <lambdabot> Title: Embedding CFG - HaskellWiki, http://tinyurl.com/y3w9ut
20:05:16 <edwardk> that depth tends to be low, ~log n or better in practice.
20:06:50 <edwardk> the other issue is that PEGs can't be used in a lot of cases where a near-CFG can, to use a peg your grammar really must be context-free, you can't disambiguate symbols using incremental information
20:07:13 <palomer> edwardk, example?
20:07:49 <edwardk> palomer: a c++ parser needs to know if a symbol is a typedef and parse differently accordingly
20:08:12 <edwardk> as c++'s grammar isn't context-free
20:08:48 <edwardk> you can mangle a CFG into a usable form with some local disambiguation, a PEG can't be mangled into something usable.
20:08:57 <palomer> hrmph
20:08:58 <palomer> that sucks
20:09:01 <edwardk> its noted in the original PEG paper
20:09:55 <edwardk> i may also be biased coz they are completely useless for parsing my toy language =)
20:10:09 <palomer> <:O!
20:10:20 <edwardk> which is also very much non-context free =)
20:10:23 <palomer> edwardk, is there any other difference other than PEGS don't have left recursion?
20:11:12 <edwardk> left recursion, unsuitability for near cfg tasks, you have to be careful sorting rules, huge average space usage, otherwise nothing
20:11:24 <palomer> sorting rules?
20:11:55 <edwardk> iirc order of rules in a PEG matters.
20:12:00 <palomer> yeah
20:12:05 <palomer> I think that's the only difference, really
20:12:07 <palomer> <:o
20:12:09 <edwardk> you have to make sure your order makes sense =)
20:12:12 <monochrom> If you combine PEG with Parsec you can do very non-context-free things.  Note that Parsec parsers have to be written almost like PEGs because of performance issues, e.g., no left recursion, don't writing your own right-recursion, use "many" instead.
20:12:16 <palomer> so if a grammar is unambiguous
20:12:21 <palomer> it doesn't matter if you parse it as a PEG
20:12:22 <palomer> or as a CFG
20:12:31 <LoganCapaldo> edwardk has given the most negative description of PEGs I've ever heard. Everywhere else on the net everyone talks about how cool they are :)
20:12:37 <palomer> right?
20:12:52 <palomer> I like negative points of view
20:13:01 <palomer> I don't like it when everyone goes "this is the best!!"
20:13:06 <palomer> it's so...fake
20:13:12 <palomer> like they're forcing themselves to like it
20:13:22 <JohnMeacham_> palomer: it is not really a limitation, the tool can just rewrite all left recursion automatically.
20:13:24 <edwardk> monochrom: the issue is that a PEG works its time guarantees by ensuring that it can cache the result of parsing the item at position x, and get the same answer next time. now, use that in a context-non-free setting, and parse in a way that has to interpret the value at position x with a different context and lo and behold your cache is invalid
20:13:45 <dibblego> ?type (>>)
20:13:48 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
20:13:55 <edwardk> monochrom: so you have to give up linear time and run it in the new context
20:14:24 <palomer> edwardk, if a grammar has no left recursion and is unambiguous, then it can be parsed as a PEG or a CFG and the result will be the same, right?
20:14:30 <edwardk> LoganCapaldo: i admit i'm a bit of a curmudgeon =)
20:14:34 <LoganCapaldo> palomer: forcing yourself to like something? geez. I don't think I've ever come across someone doing that
20:14:50 <LoganCapaldo> At least not as far as things like parsing methods go :)
20:14:53 * palomer gets the feeling that PEG refers more to how something is parsed rather than the meaning of a grammar
20:15:11 <edwardk> palomer: i don't know if they have shown that every such grammar can be parsed as a PEG, but thats pretty close to an intuitive understanding of it
20:15:35 <LoganCapaldo> palomer: Yes, the interesting bit is the packrat parser bit, and not really the PEG bit
20:16:10 <palomer> brb
20:16:17 <JohnMeacham_> actually, a fully lazy packrat parser can be O(k) space. where k is the maximum you need to lookahead. if a parser never fails, it will never have to backtrack. for instance the kleene star * in regexps always succeeds, so you can throw away text before it as you know it will never backtrack past that point.   for a language, what you would do is rather than having a parse failure on an error, include a 'failure' node
20:16:17 <JohnMeacham_> in your abstract syntax, so bad terms are replaced by BadTerm "parse errror" or something. it has teh added advantage that you can still carry out typechecking and have very informative parse error messages.
20:16:25 <monochrom> PEG refers to the grammar.  But still I like thinking Parsec as a style that makes you write things that look like PEGs.
20:16:54 <LoganCapaldo> well Parsec is LL(1) right?
20:16:57 <dibblego> ?type Monad.fail
20:16:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
20:17:09 <monochrom> Parsec is probably Turing-complete.
20:17:10 <LoganCapaldo> (modulo try)
20:17:33 <monochrom> Even with try it's probably Turing-complete.  It can do XML for example.
20:17:55 <edwardk> JohnMeacham_: *nods*
20:18:02 <LoganCapaldo> Why would having try decrease its turing completeness?
20:18:05 <monochrom> The thing is Parsec is just a library to be used inside a Turing-complete programming language.
20:18:08 <sieni> LoganCapaldo: yes, and more than that
20:18:09 <lambdabot> sieni: You have 1 new message. '/msg lambdabot @messages' to read it.
20:18:14 <JohnMeacham_> vaugely, parsec can only look ahead in characters, PEGs let you examine the already parsed future.
20:18:15 <sieni> O_O
20:18:18 <monochrom> err
20:18:26 <monochrom> Correction.  Even without try it's probably Turing-complete.  It can do XML for example.
20:18:46 <LoganCapaldo> That makes more sense
20:19:10 <coffeemug> is there a way to hide an imported instance declaration in a module so that I can "redefine" it?
20:19:35 <edwardk> coffeemug: you could import it qualified, then make your local version point to that
20:19:55 <LoganCapaldo> Of course you can always break out into general purpose code with Parsec, but within of itself its LL(1) with selective backtracking no? Which lends itself to a grammar similar to PEGs
20:20:03 <JohnMeacham_> that is pretty much the fundamental difference between LL and PEG grammers, LL ones let you see only the pre-parsed input when looking into the future, PEGs let you see the already parsed output when looking into the future.
20:20:09 <coffeemug> hmm
20:20:10 <edwardk> import qualified foo as L; somethingElse = L.something
20:20:10 <coffeemug> ok
20:20:15 <JohnMeacham_> but they are both recursive decent.
20:20:33 <JohnMeacham_> by pre-parsed I mean raw token stream.
20:20:40 <dons> sjanssen: single threaded rts (only using 1 thead, 1 core):
20:20:42 <dons> ./par 1 > /dev/null  34.43s user 0.08s system 98% cpu 34.860 total
20:20:44 <coffeemug> edwardk: that doesn't help with redefining Eq though
20:20:49 <dons> 4 cores, 8 forkIO threads:
20:20:53 <dons> ./par 8 +RTS -N4 > /dev/null  26.77s user 0.32s system 181% cpu 14.892 total
20:20:56 <monochrom> I think you're right, once it's properly formalized.
20:21:03 <edwardk> coffee: heh, there i think yer screwed =)
20:21:08 * LoganCapaldo feels good about what JohnMeacham_ just said. makes me feel like my understanding is correct
20:21:13 <monochrom> (It's very hard to separate Parsec from Haskell :) )
20:21:20 <dons> sjanssen: that's running fps' Properties.hs file
20:28:02 <hyrax42> what about import Foo hiding (...)?
20:28:59 <coffeemug> I just realized that the primary reason I was swayed towards haskell was that the only free viable common lisp implementation for windows is CLISP and it has no support for threads
20:29:13 <monochrom> haha nice
20:29:21 <coffeemug> what a pity it would be if it did have support for threads :)
20:29:54 <monochrom> how much do you miss runtime typing?
20:30:13 <coffeemug> depends
20:30:38 * qwr . o O ( forget windows and use sbcl for lisp ;) )
20:30:44 <monochrom> what things do you like in common lisp?
20:30:45 <hyrax42> I think using Haskell will amek you a much more careful programmer in such languages
20:30:53 <hyrax42> since you know you don't have the compiler safety net
20:31:00 <coffeemug> refactoring a reasonably large body of haskell code to work with a monad is a huge pain in the ass
20:31:01 <dons> forkIO forever!
20:31:02 <hyrax42> that you became used to
20:31:13 <pkhuong> coffeemug: sbcl works on win32. No threads yet, though.
20:31:19 <dons> coffeemug: yeah. we need some tools support if you're backpatching a monad in
20:31:22 <monochrom> OH!  Haha I always forget imperative programming.
20:31:26 <dons> HaRe can do that, iirc
20:31:27 <coffeemug> and in those case you just scream and swear at haskell for not giving you defvar
20:32:12 <coffeemug> also some of lisps runtime features like ability to rebind any symbol I want at any given time is very useful
20:32:30 <coffeemug> for example, hs-plugins has a whole module to deal with merging two files
20:32:50 <coffeemug> in CL that would be implicit
20:32:59 <monochrom> But on typing, whenever I write in lisp I manually type them, i.e., in the comments I give very specific type signatures (though sometimes in English).  This is even before I knew ML and Haskell; at that time I knew only Basic, C, C++, Prolog, Lisp.  Static typing was very natural to me.
20:33:09 <monochrom> Err add Pascal to that list.
20:33:27 <coffeemug> dons: HaRe can do that?
20:33:44 <monochrom> Sometimes I even write down a type signature before I write down an implementation.
20:33:44 <coffeemug> monochrom: yes, that's true
20:34:11 <coffeemug> monochrom: that's the thing, in some cases you want static typing, in others it's a huge pain in the ass
20:34:33 <monochrom> Sometimes I have no idea how to start writing the implementation, and then I write down the type signature, and then the type signature suggests me how to code.
20:34:42 <coffeemug> it would be very nice to have the best of both worlds - a dynamic typing that can be statically proven to be correct
20:34:47 <coffeemug> and haskell gives you some of that
20:34:48 <coffeemug> with Dynamic
20:34:54 <coffeemug> but not nearly enough IMO
20:35:35 <coffeemug> basically in some cases haskell makes things that would take a second in lisp a huge pain in the ass that requires days of work
20:35:37 <monochrom> Yes, but because of my experience I have grown to insist on static typing and then I will say let's make it static and also rich enough to be convenient.
20:35:38 <jcreigh> Sometimes I try to figure out what the type signature should be, and I can't. If I try to start coding at that point, the function is invariably wrong.
20:38:43 <coffeemug> I think if there was an easy tool to refactor code to work with monads it would go a long way to eliminate the need for defvar :)
20:39:27 <coffeemug> although I would argue that every time your language requires a tool to automatically do stuff for you it means it lacks a certain abstraction ability
20:39:29 <monochrom> Let us ask the Eclipse-plugin-for-Haskell guy to do that!
20:40:30 <palomer> edwardk, still around?
20:40:32 <monochrom> Hmm haha nice we should generalize the ($) operator for that!  (Heresy! XD)
20:41:40 <coffeemug> noooo
20:41:43 <coffeemug> no eclipse :)
20:42:29 <Revision17> @Eq
20:42:29 <palomer> great, I finally find someone who knows something about PEGs and he runs away
20:42:30 <lambdabot> Maybe you meant: . bf faq ft id pl v wn
20:42:36 <Revision17> @hoogle Eq
20:42:37 <lambdabot> Prelude.Eq :: class Eq a
20:42:37 <lambdabot> Prelude.EQ :: Ordering
20:42:37 <lambdabot> Text.PrettyPrint.HughesPJ.equals :: Doc
20:42:41 <monochrom> ($) and (.) should have monadic types.  "\x -> ..." should be syntactic sugar for monads just like do is.  The default monad should be (->) just like the default num is integer or double.
20:43:24 <monochrom> I think that will suffice for the abstraction sought.
20:43:56 <coffeemug> is there a list of refactorings HaRe can do?
20:44:00 <monochrom> Someone should submit that to the Haskell' committee and scare the hell out of them :)
20:44:03 <dons> i find monads make some other refactoring problems trivial (like adding new state
20:45:03 <monochrom> It has been said that for production code you should writing monadically right at the beginning, even for pure functions.  I think my proposal institutionalizes that.
20:45:13 <Revision17> by any chance is there a depth first search function for inductive graphs?  I can't seem to find one in the libs
20:45:18 <edwardk> monochrom: i've been playing with just that, its not typable in haskell though
20:45:51 <edwardk> monochrom: you would have to embed everything in the Identity monad by default in order to type monadic ($).
20:45:54 <coffeemug> dons: yeah, but if you have a lot of code that never needed state, then you add a state monad, and then you have to go and lift stuff all over the place it becomes a huuuugeee pain
20:45:56 <edwardk> monadic (.) = fmap is fine though
20:46:09 <palomer> coffeemug, amen
20:46:21 <palomer> coffeemug, not to mention the fact that your types become super uglified
20:46:28 <newsham> gobble gobble.
20:46:31 <edwardk> but it and ($) don't cover ap and a couple others that they should
20:46:37 <monochrom> Yeah this heretic proposal needs much work.
20:46:52 <edwardk> mono: i'm changing the type system to make it possible in my toy language
20:46:53 <palomer> coffeemug, and you can get some pretty incomprehensible errors
20:47:08 <edwardk> mono: already (.) = fmap there
20:47:12 <palomer> edwardk, if a PEG parser returns a parse tree, then it's a parse tree for the corresponding CFG grammar, right?
20:47:17 <edwardk> and liftM etc don't exist
20:47:31 <monochrom> I'm also thinking maybe arrows instead of monads.  Same power if you go ArrowApply.
20:47:33 <dons> coffeemug: yeah, starting in StateT IO might be a reasonable default for  code expecting to do IO
20:47:55 <coffeemug> palomer: yeah
20:47:59 <dons> then you can switch to ReaderT if you want, or IdentityT, or add new state component without touching anything
20:48:18 <coffeemug> dons: yeah, but that's a hack, not a solution
20:48:23 <coffeemug> a tool would be a solution
20:48:29 <dons> HaRe is probably that then
20:48:35 <coffeemug> HaRe doesn't seem to do that
20:48:42 <edwardk> palomer: i don't recall a proof that every PEG had a corresponding a CFG
20:48:45 <dons> i thought it had lifting powers?
20:48:48 <edwardk> but maybe i just forgot it
20:48:53 <coffeemug> their README has a list of refactorings it can do
20:49:02 <palomer> edwardk, the corresponding CFG would replace every occurrence of / with |
20:49:12 <palomer> edwardk, that's what I mean by "corresponding"
20:49:29 <LoganCapaldo> I don't think the parse tree would necessarily be for the corresponding cfg
20:49:29 <coffeemug> http://www.cs.kent.ac.uk/projects/refactor-fp/hare/README_20012006.txt
20:49:32 <lambdabot> http://tinyurl.com/y23z6a
20:49:49 <coffeemug> this kind of crap makes me wish for a defvar
20:50:01 <palomer> coffeemug says yes, LoganCapaldo says no
20:50:04 <palomer> ugh!
20:50:10 <hyrax42> fwiw, a reddit post I just made
20:50:17 <coffeemug> it would be nice if IO monad could do that
20:50:20 <hyrax42> http://programming.reddit.com/info/s43f/comments
20:50:22 <lambdabot> Title: [video] Simon Peyton-Jones and Tim Harris discuss STM (Software Transactional Me ..., http://tinyurl.com/y76aoo
20:50:25 <edwardk> monochrom: my first version of (.) was ridiculously generic like a b c -> (f a) (g b) (g c) but it rapidly spirals out of control
20:51:02 <edwardk> monochrom: i am currently defining (->) inside of my prelude, its not part of the base language, so i'm taking some steps in that direction
20:51:10 <palomer> who's right?
20:51:17 <dons> hyrax42++ (was it you?)
20:51:26 <hyrax42> yeah
20:51:38 <dons> good work
20:51:38 <hyrax42> I was discussing with this guy in the concurrent lock free data in haskell thread
20:51:47 <LoganCapaldo> you could have a b c / a b in a PEG
20:51:49 <hyrax42> then decided that since that's where I learned what I'm saying to post the soruce
20:52:01 <LoganCapaldo> but a b c | a b would be ambigous
20:52:06 <coffeemug> I wish IORef had an implementation where you could just name them
20:52:07 <LoganCapaldo> in a CFG
20:52:10 <LoganCapaldo> I think
20:52:11 <coffeemug> and use strings as keys
20:52:20 <hyrax42> it was an informative watch
20:52:25 <nornagon> ?type aRecursion = aRecursion
20:52:26 <lambdabot> parse error on input `='
20:52:29 <dons> coffeemug: how's defvar work?
20:52:35 <nornagon> blah, what's the command?
20:52:42 <coffeemug> dons: defvar is just a global variable :)
20:52:44 <LoganCapaldo> no thats a bad example
20:52:50 <coffeemug> a mutable global variable
20:53:20 <palomer> LoganCapaldo, yes, so something can have several parse trees in the CFG but only one in the PEG
20:53:34 <palomer> LoganCapaldo, nonetheless, that one parse tree is also a valid parse tree for the CFG
20:54:00 <LoganCapaldo> Well that last one was a wrong example anyway :)
20:54:11 <LoganCapaldo> but yeah that was kind of the poitn I was trying to get across
20:55:23 <LoganCapaldo> Are not and and part of PEGs or just generally part of the parsers with pegs
20:55:33 <LoganCapaldo> cause I'm pretty sure you can't have not and and in cfg
20:56:25 <lispy> palomer: welcome back!
20:56:26 <palomer> eh?
20:56:32 <palomer> lispy, yay for me!
20:56:39 <palomer> let's see how long I last
20:56:43 <lispy> :)
20:56:45 <dons> coffeemug: you know how to create mutable globals in haskell?
20:56:48 <lispy> what is a PEG?
20:56:59 <dons> (even thread safe ones...) ?
20:57:13 <LoganCapaldo> lispy: parsing expression grammar
20:57:14 <edwardk> lispy: http://en.wikipedia.org/wiki/Parsing_expression_grammar
20:57:17 <lambdabot> http://tinyurl.com/y4mbzg
20:57:19 <palomer> lispy, parsing expression grammar
20:57:47 <LoganCapaldo> looks like & and ! are part of PEGs
20:57:56 <LoganCapaldo> at least if wikipedia can be trusted
20:58:07 <LoganCapaldo> and I don't think you can do those with CFGs
20:58:22 <lispy> edwardk: how are they different from BNF?
20:58:50 <palomer> ok, PEGS with only & and |
20:58:54 <palomer> (or & and \)
20:59:10 <edwardk> lispy: the rules are ordered, its not generative but parsing oriented, linear time, better space guarantees as long as the grammar is really context free
20:59:12 <lispy> oh hmm..they have prioritaziation
20:59:49 <LoganCapaldo> palomer: & is not concatenation, I think you mean just concatenation and |
20:59:53 <lispy> hmm...so we can't use it for programming languages? (I thought PLs were CFG+)
20:59:54 <palomer> yeah
21:00:30 <LoganCapaldo> Ok, then its more likely
21:00:32 <palomer> my statement is: given a PEG grammar G (which has only concatenation and \) and it's corresponding CFG grammar G', if P is a parse tree of x in G then it's a parse tree of x in G'
21:00:46 <LoganCapaldo> That seems likely
21:01:13 <lispy> palomer: and also x is not the only possibility in G'?
21:01:28 <lispy> er the parse tree of x
21:01:38 <palomer> P may not be the only parse tree of x under G'
21:01:44 <palomer> but at least it's one
21:01:49 <palomer> so if G' is unambiguous, it is the only one
21:01:50 <edwardk> palomer: sure, but it is unlikely to be a leftmost derivation in G' so while it is generated by G', it is not likely that you would find it as the result of applying G' in an LL(k), etc. manner
21:02:21 <palomer> edwardk, LL(k) parsers whine when the grammar is ambiguous
21:02:35 <palomer> I mean, who uses ambiguous grammars?
21:02:59 <palomer> so it IS likely that I'll find it as the result of applying G' in an LL(k) fashion
21:03:17 <edwardk> you stated your problem in general terms, i answered in general terms =)
21:03:24 <coffeemug> dons: mutable globals in haskell?
21:03:36 <coffeemug> dons: the closest thing I can think of is IORef
21:03:38 <palomer> touche
21:03:52 <palomer> ok, now I'm clear on PEGs
21:03:57 <palomer> which is good, since I mention them in my thesis
21:04:13 <coffeemug> dons: otherwise, I need a state monad
21:05:39 <coffeemug> ok guys, time to go to sleep
21:05:42 <coffeemug> night everyone
21:05:49 <palomer> so if you're grammar is unambiguous and has no left recursion, might as well use a PEG parser, eh?
21:06:49 <LoganCapaldo> Also you can skip the whole lexing step, which I like
21:07:02 <palomer> sweet
21:07:14 <dons> hmm, guess he doesn't know about global IORefs.
21:07:34 <lispy> dons: are those thread safe?
21:07:45 <lispy> (me doesn't actually know)
21:07:56 <lispy> i guess they are because you can use a global MVar?
21:08:45 <dons> yeah
21:09:51 <lispy> dons: re: .net at work, it's really hard to make abstractions!
21:10:31 <lispy> haskell and lisp own at making abstractions
21:10:40 <monochrom> Darn all languages that make it hard to abstract.
21:11:04 <lispy> i'm very tempted to write some sort of interpreter in VB.NET (like a scheme interpreter) and finish the project in it :)
21:11:09 <monochrom> But something tells me the majority of people don't like to abstract.
21:11:52 <lispy> yeah, buggy ad-hoc for loops are cool
21:12:28 <lispy> but i did learn something today
21:12:55 <lispy> if i imagine the solution in haskell and then just code up a function in language X to match the haskell one-liner i'm not too bad :)
21:13:06 <edwardk> hahaha
21:13:30 * lispy was being serious
21:14:09 <eviltwin_b> modify that yhc backend to output vb.net instead of javascript?
21:14:20 <lispy> eviltwin_b: wow, that's good
21:14:27 <dons> lispy: yeah, prototype if nothing else
21:14:36 <dons> or just use machine checked pseudocode
21:14:42 <dons> ;)
21:15:10 <lispy> dons: at this point, i know exactly how it would look in haskell (I can just open the .hs files...) but translating is sometimes error prone
21:15:15 <lispy> a lot of things have to be coded up
21:15:44 <lispy> anyway, enough venting
21:16:00 <lispy> which cool things are people working on today?
21:16:32 <lispy> anyone tried Pappy?
21:16:34 <lispy> ?where pappy
21:16:35 <lambdabot> I know nothing about pappy.
21:16:38 <dons> smp parallel quickcheck :)
21:16:48 <lispy> ?where+ pappy http://pdos.csail.mit.edu/~baford/packrat/thesis/
21:16:48 <lambdabot> Done.
21:16:54 <lispy> dons: really?
21:17:00 <lispy> dons: cool!
21:17:17 <Korollary> seriously, how long is the typical quickcheck taking?
21:17:25 <dons> sure.
21:17:26 <dons> should be done soon
21:17:32 <dons> Korollary: hmm. 5-10 mins?
21:17:37 <dons> few 1000 propreties
21:18:48 <lispy> dons: if you just used the threaded RTS can't it automatically parallelize this?
21:18:54 <dibblego> where is instance Monad [] defined?
21:18:56 <Korollary> when you change only one def, does it still check everything else?
21:19:04 <lispy> or, what i mean is, isn't there an RTS for parallelizing automatically?
21:19:19 <lispy> ?doc Monad
21:19:19 <lambdabot> Monad not available
21:19:23 <lispy> ?index Monad
21:19:24 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:19:38 <lispy> dibblego: probably in the source of Control.Monad
21:19:50 <lispy> ?src Prelude
21:19:50 <lambdabot> Maybe you meant: arr ghc url
21:19:56 <Korollary> dibblego: the report has it in the prelude
21:19:57 <lispy> ?fptools Prelude
21:19:57 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
21:20:16 <dibblego> ah thanks
21:21:22 <lispy> dibblego: the all about monads tutorial should explain it as well
21:21:32 <dibblego> I just want to check the source
21:21:50 <dibblego> finding source is such a PITA
21:22:01 <lispy> actually, ?fptools is for that
21:22:10 <lispy> but yes, i agree
21:22:21 <lispy> and searching the new wiki is near impossible
21:22:49 <lispy> for some reason, my google searches never find it and i forgot/lost the url to the haskell specific google
21:22:50 <dibblego> ?fptools instance Monad []
21:22:51 <lambdabot> instance Monad [] not available
21:23:04 <lispy> ?instances Monad
21:23:06 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:23:28 <lispy> dibblego: i guess for fptools to work you do already have to know which module you want :(
21:23:32 <dibblego> yeah but, where do I find the source?
21:23:35 <dons> Korollary, lispy: its 10 lines of code ;) (since the rts does all the hard smp work)
21:23:43 <lispy> dibblego: ?fptools Prelude
21:23:57 <monochrom> Wow, new layout for haskell wiki!
21:24:01 <dons>     (`mapM_` jobs) $ \j -> forkChild children $ (`mapM_` j) $ \(s,a) -> do
21:24:01 <dons>         v <- a depth
21:24:01 <dons>         writeChan chan $ printf "%-25s: %s" s v
21:24:13 <lispy> dibblego: that will point you at some source code, from there, you'll need to follow the modules it imports to get to the correct one
21:24:50 <lispy> weird
21:25:00 <dibblego> it points to Control.Monad
21:25:10 <dibblego> which does not have it
21:25:29 <lispy> dibblego: i have to go, right now...or i'd help you find it
21:25:34 <dibblego> righto ta
21:26:05 <lispy> http://www.cs.dartmouth.edu/~doug/cs118/Prelude.hs
21:26:08 <lambdabot> http://tinyurl.com/y7nswd
21:26:31 <dibblego> oh yay
21:26:57 <lispy> that was the google search, "instance Monad [] Prelude.hs"
21:26:59 * lispy &
21:27:52 <monochrom> http://darcs.haskell.org/packages/base/GHC/Base.lhs
21:27:55 <lambdabot> http://tinyurl.com/zcmat
21:28:08 <monochrom> Try that.
21:28:28 <nornagon> why does lambdabot tinyurl stuff?
21:28:42 <monochrom> I don't actually know.
21:28:54 <dibblego> thanks
21:28:55 <nornagon> I wonder.
21:29:23 <nornagon> http://xrl.us/te7g
21:29:31 <nornagon> aw.
21:29:39 <monochrom> hee
21:30:18 <dons> big urls are bad for pasting
21:30:18 <dibblego> ?where yaht
21:30:19 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:30:39 <nornagon> oh, that'd be a cool way to force a link to take a long time to reach, in a paper trail game or something.
21:30:58 <monochrom> haha
21:31:07 <LoganCapaldo> Some people still use IRC clients from the dark ages and long urls will get truncated
21:31:13 <nornagon> xrl->tinyurl->xrl->tinyurl->xrl->...
21:31:20 <LoganCapaldo> At least I believe that's why
21:31:22 <nornagon> LoganCapaldo: really? weird...
21:31:28 <nornagon> http://xrl.us/te7gaoeuaoeuaoeuaoeuaoeuoeuaoeu
21:31:29 <lambdabot> Title: Metamark
21:31:35 <nornagon> i see.
21:31:44 <monochrom> actually the IRC servers truncate.  nothing you can do.
21:32:00 <jcreigh> but that's like 500 bytes or something.
21:32:09 <LoganCapaldo> If the IRC server truncates, lambdabot won't see it either
21:32:12 <jcreigh> and lambdabot couldn't get the full URL in that case anyway.
21:32:31 <monochrom> of course clients can truncate more.
21:32:33 <nornagon> http://xrl.us/te7gaoeuaoeuaoeuaoeuaoeuoeuaoeuaoeuaoeu
21:32:36 <lambdabot> Title: Metamark, http://tinyurl.com/y4enzc
21:32:39 <eviltwin_b> if you run an old text-mode client it'll break a long URL at the end of the line, and reassembly is difficult
21:32:47 <nornagon> oh, so it gives titles now?
21:33:24 <nornagon> eviltwin_b: i don't think anyone uses text-mode clients that aren't irssi or bitchx or ircii any more.
21:33:26 <monochrom> Ah, yes, xterm haha
21:33:33 <jcreigh> use irssi with openurl and /alias o openurl Problem solved.
21:33:33 <nornagon> and i'm pretty sure all of them handle that case.
21:34:24 <monochrom> incidentally it is also the same people who opposes progression to utf-8.  "my xterm doesn't do it!"
21:34:39 <eviltwin_b> modern xterm does utf8 if you select the appropriate font
21:34:50 <eviltwin_b> postmodern xterm even has a menu item to select a unicode font
21:34:52 <monochrom> Sometimes you are glad there is such a thing as aging and death.
21:34:57 <nornagon> monochrom: haha
21:35:01 <nornagon> xterm does do unicode
21:35:11 <nornagon> i have a lot of friends who use xterm with unicode
21:35:19 <monochrom> Yes, but some people never upgrade.
21:35:20 <eviltwin_b> but yeh, I hang out with a bunch of throwbacks whose IRC clients do have that problem
21:35:53 <nornagon> monochrom: well we can all just laugh at them. Anyway, xterm has supported unicode for a while now, i think.
21:35:55 <eviltwin_b> no idea what they're using but they're generally opposed to fancy clients
21:36:45 <nornagon> I use irssi and xterm and unicode works fine.
21:36:58 <monochrom> nice
21:37:11 <nornagon> screen has issues sometimes, though
21:37:18 <nornagon> with really long characters
21:37:21 <nornagon> that is, many bytes.
21:37:54 * eviltwin_b uses vnc instead of screen :)
21:38:02 <nornagon> sloooow.
21:38:20 <nornagon> especially over wireless
21:38:20 <eviltwin_b> enh.  good enough for what I do with it
21:38:22 <LoganCapaldo> eviltwin_b's friends probably use this: http://irc.suckless.org/view.sh/simple+irc+client ;)
21:38:25 <lambdabot> Title: suck less, http://tinyurl.com/unml8
21:38:36 <nornagon> <3 sucless
21:38:38 <nornagon> suckless
21:39:09 <nornagon> LoganCapaldo: it probably supports unicode though >.>
21:39:41 <LoganCapaldo> nornagon: It supports unicode by ignoring everything ;)
21:41:44 <Excedrin> hahaha - "It multiplexes also all channel traffic into one output, that you don't have to switch different channel buffers, that's actually a feature."
21:42:43 <monochrom> scary
21:54:27 <sjanssen> dons: nice results on the parallel fps tests.  Now somebody needs to add parallel building to Cabal . . .
22:13:37 <dons> sjanssen: here: darcs get http://www.cse.unsw.edu.au/~dons/code/pqc
22:13:37 <lambdabot> Title: Index of /~dons/code/pqc
22:13:43 <dons> ?where+ pqc darcs get http://www.cse.unsw.edu.au/~dons/code/pqc
22:13:44 <lambdabot> Done.
22:14:20 <dons> i'll add some more notes on smp building, then release it
22:14:30 <dons> maybe if i (or others) use it when can add it to -package QuickCheck
22:16:34 <dons> could you give examples/Example.hs a run on your setup? and check it works?
22:20:09 <sjanssen> seems to work
22:20:44 <sjanssen> goes from 3.8 sec. actual time to 2.7 sec. with -N2
22:21:47 <dons> coo
22:22:14 <Revision17> I'm trying to create an instance for Num String, and the declaration looks just like Num Int in the GHC source, however GHC doesn't like it: http://pastebin.com/831112
22:22:37 <sjanssen> Revision17: there are two problems there
22:22:57 <sjanssen> 1.  You're not supposed to write instances for type synonyms (type String = [Char])
22:23:36 <sjanssen> 2.  instance Num [Char] isn't legal in Haskell '98
22:24:06 <sjanssen> Revision17: should work with -fglasgow-exts
22:24:52 <Revision17> ah, yes that worked perfectly; thanks sjanssen
22:25:16 <Revision17> why would instance Num [Char] be made illegal in Haskell '98?
22:25:47 <sjanssen> not sure, I've never seen an explanation for it
22:25:54 <Cale> dons: hey! I thought I said that, not Baughn. He did start that conversation though.
22:26:34 <Cale> If I didn't then excuse me, I'm tired :)
22:28:37 <monochrom> probably was easier to implement typeclasses if things like Num[Char] were disallowed.
22:28:39 <sjanssen> Revision17: also, it isn't anything specific to that example, all instances of form "instance SomeClass (C T)" are illegal, where T is a concrete type, not a type variable
23:09:27 <dibblego> is there a proper term for FP languagaes that are not pure?
23:09:42 <monochrom> impure
23:09:48 <dibblego> that's all I know of as well
23:10:09 <araujo> hah, i sometimes also hear people calling them 'dis-functional languages'
23:11:02 <sieni> sp
23:11:16 <sieni> shoulnd't that be dysfunctional?
23:11:26 <araujo> oh, yes, sieni
23:11:31 <araujo> sorry, not a native hre
23:14:11 <therp> good morning everyone
23:16:03 <dibblego> ?where yah
23:16:04 <lambdabot> I know nothing about yah.
23:16:04 <dibblego> ?where yaht
23:16:04 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
23:23:16 <jeffz> hmm, if I want to return the max in a list of numbers, I can do: foldl max 0 [1,2,100,3,9], how do I write this as a function?
23:23:34 <jeffz> foo :: [a] -> Int b
23:23:43 <jeffz> foo [] = 0
23:23:46 <jeffz> ...
23:27:02 <therp> why not just "mymax list = foldl max 0 list"
23:28:04 <dibblego> ?paste
23:28:05 <lambdabot> http://paste.lisp.org/new/haskell
23:28:12 <monochrom> If you use foo [] = 0, it probably won't be nice to foo [-1,-2,-3].
23:28:13 <therp> actually I would do "mymax (x:xs) = foldl max x xs"
23:28:31 <monochrom> But then again foldl max 0 [-1,-2,-3] is not nice either.
23:29:14 <monochrom> But here it goes.  foo [] = 0.  foo (x:xs) = is it clear how to complete it?
23:29:36 <xnito> > maximum [2,1,23,1,11,3]
23:29:38 <lambdabot>  23
23:31:00 <therp> monochrom: foo [x] = x as base case would be more correct, although not identical to jeffz's foldl
23:31:13 <monochrom> Right I agree.
23:31:43 <monochrom> But I like to play by the customer's rule, too.
23:31:56 <jeffz> hmm, excuse my slowness, I'm testing and attempting to think of intelligent questions.
23:32:25 <jeffz> Haskell is a bit perplexing.
23:32:46 <xnito> i find it eisier to read than c++
23:33:07 <dibblego> the worst case scenario for learning Haskell is that your Java gets 100 times better
23:33:11 <monochrom> That's perplexing.  When I first met Haskell I had the feeling that I'd finally met something that made sense.
23:33:15 <dibblego> er, nothing
23:34:12 <monochrom> But that's probably because I didn't completely buy C++, Perl, Java, etc., mind you.
23:34:33 <xnito> whats wrong with perl?
23:36:18 <monochrom> typing, those $@# hacks to get nested data structures such as trees.  Note that I say "didn't completely buy", so it's also "didn't complete reject" either.
23:37:02 <sieni> yeah, e.g. multidimensional arrays are really pleasant in perl
23:37:47 <xnito> fair enough, no one likes dereferncing i think
23:38:03 <xnito> especially not in a dynamically typed language
23:41:38 <monochrom> The Albert Lai Test is a test of how high-level a language is.  It goes like this.  Get an (or a bunch of) introductory book on language L, find which chapter it tells you how to do binary search trees in L.  For C and C++, it's probably like chapter 6.  For Perl it's probably chapter 10 or even not in the introductory book --- the hack is too advanced.  For Haskell it's probably 2 or 3.
23:42:10 <MP0_> Really? It was the first thing I saw in Haskell. The one line qsort.
23:42:33 <monochrom> I don't actually like the qsort example.  But I think you get the idea.
23:42:45 <monochrom> (Also I am not talking about qsort.)
23:43:02 <MP0_> Oops, you're right
23:43:09 <MP0_> they're so similar :-)
23:43:36 <audreyt> monochrom: well, perl people usually just grab http://search.cpan.org/dist/Tree-Binary/ and never write (or think about) binary trees :)
23:43:40 <lambdabot> Title: Stevan Little / Tree-Binary - search.cpan.org
23:44:01 <lisppaste2> jeffz pasted "newbie" at http://paste.lisp.org/display/30537
23:44:20 <jeffz> what's wrong with my type signature?
23:44:28 <monochrom> well, C++ people usually just use STL, and haskell people Data.Map.  My point still stands.
23:44:50 <MP0_> And java people, TreeMap
23:46:17 <monochrom> Do you realize that it's very hard to read, jeffz?
23:46:33 <audreyt> monochrom: *nod* what I mean is that it depends heavily on how algorithmic are those "intro" books
23:46:53 <audreyt> e.g. in the "Algorithms with Perl" book it's on Chapter 3.
23:46:56 <Korollary> @type foldl max
23:46:58 <lambdabot> forall b. (Ord b) => b -> [b] -> b
23:47:02 <monochrom> foo :: (Ord a) => [a] -> a,  try that jeffz.
23:47:14 <Korollary> but, in the type signature, you don't have Ord as a constraint
23:47:18 <audreyt> but it's true that the default audience of e.g. "learning perl" is not considered interested in algorithms
23:47:22 <jeffz> monochrom: hmm, apologies, it looks ok here, perhaps too much whitespace
23:47:56 <monochrom> Yeah I happen to be one of those nutties who refuse to "maximize" my browser window.
23:48:50 <glguy> Did anyone tell jeffz that his function should be: foo = foldl1 max ?
23:49:03 <Korollary> No need
23:49:07 <glguy> I just screen -r'd my way in
23:49:48 <jeffz> what is the english equivilant for '=>'?
23:50:03 <monochrom> audreyt: what if you are to write an introductory perl book for an audience interested in data structures and algorithms?
23:50:18 <Korollary> jeffz: "implies" I think
23:50:34 <Korollary> or, given (Ord a)
23:50:47 <audreyt> monochrom: "higher order perl" or "algorithms with perl" or "computer science and perl programming" are all good choices for this niche
23:52:04 <Korollary> I love that perl5 just flattens complex data structures when passing as args
23:52:04 <jeffz> Korollary: ah, excellent, thank you
23:52:35 <audreyt> they are not considered introductory by most perl people simply because of the bias toward glue-programming in perl crowd; there's nothing really "advanced" about e.g. the algorithms book -- you can pick it up and learn about perl without previous exposure, if you're already versed in algorithms somewhat.
23:52:40 <jeffz> monochrom: yes, your suggestion worked, thank you
23:54:08 <monochrom> My thought is this.  By "introductory" I mean it assumes no prior programming knowledge, and it has to teach first-year CS at least.  So in order to cover binary search trees, for example, the book has to first teach all the language constructs necessary for trees.  For C and C++ you have to first explain structs and pointers, which are not easy to explain but ok.  For perl you have to explain hacks concerning @, which is qui
23:54:08 <monochrom> te non-obvious.
23:54:40 <audreyt> ah, you mean the whole reference thing. yeah, it's about as hard to explain as pointers
23:54:51 <Korollary> I thought it was harder
23:54:53 <audreyt> not more so than pointers, though, as they are just GCed pointers
23:55:22 <audreyt> Korollary: it's harder if you drag the other two sigils into the cirriculum, that is @foo and %bar
23:55:36 <Korollary> yeah I didn't like the sigils
23:55:39 <audreyt> but if you use only the $ sigil, it's exactly the same as pointers in difficulty to teach, I think
23:55:54 <audreyt> (that's how I teach my students anyway)
23:56:02 <audreyt> the other two sigils should be considered advanced technique :)
23:56:05 <Korollary> Do the sigils even help? I know that perl6 is more lenient on those.
23:56:08 <glguy> $ is dereference?
23:56:27 <audreyt> Korollary: in perl6 sigils is part of variable name, so the confusions generally go away.
23:56:29 <glguy> or are those scope specifiers
23:56:56 <audreyt> glguy: dereference. scope-specifier is ruby
23:57:19 <Korollary> audreyt: then it's kind of like hungarian notation in perl6?
23:57:39 <audreyt> Korollary: oh, definitely. it's just a hint that "this holds an object that responds to indexing"
23:58:08 <glguy> what are % and @ in Perl?
23:58:21 <audreyt> glguy: HashTable and Array, respectively
23:58:55 <monochrom> Yeah, after much arm-twisting, Larry finally agreed to make Perl6 easier to use.
23:59:07 <Korollary> The most important data structures in the world!
