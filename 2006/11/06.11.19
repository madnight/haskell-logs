00:02:26 <dobblego> yay! what a mission
00:04:22 <lisppaste2> dibblego pasted "replace" at http://paste.lisp.org/display/30210
00:09:16 <Cale> @type lookup
00:09:18 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
00:09:54 <dibblego> ?hoogle lookup
00:09:55 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
00:09:55 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
00:09:55 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
00:10:53 <dibblego> was that for me?
00:11:18 <Cale> yeah -- you seem to be going a little out of your way to recurse through the list of replacements.
00:11:41 <dibblego> I don't see how lookup helps
00:12:04 <dibblego> as in, I think you're right, but I am blind after that traumatic experience
00:12:38 <dibblego> wouldn't lookup require me to apply every prefix?
00:12:52 <Cale> well, possibly :)
00:13:38 <dibblego> gotta go feed the kids now
00:13:38 <Cale> well, actually, it would probably be better to split this up another way
00:13:42 <Cale> replace one string
00:14:03 <Cale> and then fold that over the list of replacements
00:14:24 <dibblego> I had that function already - I deleted it!
00:15:49 <dibblego> do you mean have ([a], [a]) -> [a] -> [a] then use fold for [([a], [a])] -> [a] -> [a] ?
00:15:59 <xinming> hmm, I don't wish to start a flame war, But, anyone here can tell me what you used for indent haskell code?
00:16:15 <dibblego> xinming, the spacebar of my keyboard?
00:16:20 <Cale> dibblego: yes
00:16:22 <mauke> fingarz
00:16:30 <dibblego> Cale, fold as in foldr?
00:17:01 <Cale> yeah
00:17:06 <dibblego> I'll have to do that one after dinner
00:17:11 <dibblego> I already had ([a], [a]) -> [a] -> [a]
00:17:35 <xinming> dibblego: Ok, thanks
00:17:52 <dibblego> xinming, actually, I use the tab key and set it to spaces in my editor
00:18:59 <Cale> replaceMany rs xs = foldr replace xs rs
00:19:23 <doktorteo> slm
00:19:27 <doktorteo> merhaba
00:19:41 <Cale> doktorteo: hm?
00:20:00 <doktorteo> o maygatttttttttttttttttt
00:20:04 <eviltwin_b> that'd be "hello"
00:20:56 <doktorteo> türkey
00:23:59 <Botty> it'd be nice for if/when the type system manages info on if a list is infinite or not, you could do stuff like "deparen ('(':xs:')') = ...", except obviously a different syntax (I prefer "deparen ['(' {xs} ')']")
00:25:11 <Botty> just that alone would probably make most parser libs pointless
00:26:28 <dons> ?wiki Indent
00:26:28 <lambdabot> http://www.haskell.org/haskellwiki/Indent
00:26:31 <dons> xinming: ^^
00:27:10 <dons> ?pretty main=let{x=7;y=3;z=4}in case x+y of { _|z<2 -> 1}
00:27:10 <lambdabot>  main = let x = 7
00:27:11 <lambdabot>       y = 3
00:27:11 <lambdabot>       z = 4
00:27:11 <lambdabot>        in
00:27:11 <lambdabot>        case x + y of
00:27:12 <lambdabot>          _ | z < 2 -> 1
00:27:36 <dons> would be an easy 3 day project for someone to write, actually
00:27:40 <dons> a hindent for haskell
00:27:42 <kbd-lover> dons: were is the code for lambdabot?
00:28:03 <dons> ?version
00:28:04 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
00:28:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:28:09 <lisppaste2> Cale annotated #30210 with "rewrite" at http://paste.lisp.org/display/30210#1
00:30:46 <dons> kbd-lover: you found the src?
00:32:23 <dons> kbd-lover: learning haskell, btw?
00:32:24 <Cale> hehe, we should make lambdabot a permanent fixture in ##c :)
00:32:29 <dons> heh
00:32:47 <dons> how's mbot getting on in there?
00:33:06 <Cale> I haven't actually been watching
00:33:14 <Cale> but it hasn't been kicked :)
00:33:23 <dons> ok good
00:33:31 <Cale> People played with it for a while at least :)
00:34:25 <dons> what did they try? the haskell eval plugin... ?
00:34:35 <Cale> yeah
00:34:45 <dons> nice! got the logs somewhere?
00:34:46 <Cale> We used it to crush a troll :)
00:34:53 <Cale> uh, maybe :)
00:34:56 <dons> in State/Log/* ?
00:35:46 <dons> that actually, that doesn't log lambdabot's responses
00:36:15 <Cale> http://cale.yi.org/autoshare/2006-11-18.txt
00:36:57 <Cale> <twincest> > concatMap (++ " ") [replicate (floor (sin x * 10)) '*' | x <- [0,0.1..3]]
00:37:09 <Cale> I thought that was cute :)
00:38:21 <dons> mmm 22:47:25 <runtime> thats a mad slick bot
00:38:27 <Cale> yep :)
00:38:29 <dons> > concatMap (++ " ") [replicate (floor (sin x * 10)) '*' | x <- [0,0.1..3]]
00:38:30 <lambdabot>  "  * ** *** **** ***** ****** ******* ******* ******** ******** ********* **...
00:38:33 <dons> nice
00:38:49 <Cale> > concatMap (++ " ") [replicate (floor (sin x * 10)) '*' | x <- [0,0.3..3]]
00:38:50 <lambdabot>  " ** ***** ******* ********* ********* ********* ******** ****** **** * "
00:40:04 * Heffalump gets the following when trying to use load_ from hs-plugins. Any ideas what might be wrong?
00:40:07 <Heffalump> Ix{Int}.index: Index (3145728) out of range ((0,25))
00:41:46 <dons> Heffalump: can't use hs-plugins with ghc 6.6?
00:41:56 <Heffalump> ah :-)
00:41:59 <dons> or, you compiled with a different version of ghc to the one you're using now?
00:42:06 <Excedrin> how does Haskell compare floats? is there a way to check if a pair of floats are within some small range?
00:42:08 <Heffalump> I'm using the Debian packages
00:42:15 <Heffalump> and I just upgraded to ghc 6.6
00:42:25 <dons> ah ok. that's it. the .hi file format changed and doesn't parse anymore
00:42:36 <Heffalump> ah. So I just need to downgrade again?
00:42:42 <dons> 6.4.2 would be ok
00:42:56 <dons> Excedrin: should be trivial to do?
00:43:28 <Excedrin> yea, I'm just curious what == or floatEq do
00:43:30 <dons> ?let eta x y = x - y < 0.005
00:43:31 <lambdabot> Defined.
00:43:38 <dons> > L.eta 0 1
00:43:40 <lambdabot>  True
00:43:52 <dons> ?type (==)
00:43:53 <lambdabot> forall a. (Eq a) => a -> a -> Bool
00:43:55 <Botty> ?let eta x y = abs (x - y) < 0.005
00:43:56 <lambdabot> <local>:2:0:     Warning: Pattern match(es) are overlapped              In th...
00:44:01 <dons> ?undefined
00:44:03 <lambdabot> Undefined.
00:44:06 <dons> ?let eta x y = abs (x - y) < 0.005
00:44:07 <lambdabot> Defined.
00:44:12 <dons> > L.eta 0 00001
00:44:13 <lambdabot>  False
00:44:25 <dons> > L.eta 0 100
00:44:27 <lambdabot>  False
00:44:38 <dons> > L.eta 0 0.0001
00:44:40 <lambdabot>  True
00:45:00 <Botty> ?type (floatEq)
00:45:02 <lambdabot> Not in scope: `floatEq'
00:45:03 <dons> no floatEq, we have bounded parametric polymorphism
00:45:14 <dons> leave floatEq for OCaml
00:45:42 <dons> instance Eq Double where
00:45:43 <dons>     (D# x) == (D# y) = x ==## y
00:46:16 <dons> instance Eq Float where
00:46:17 <Excedrin> the Gentle Introduction mentions floatEq
00:46:17 <dons>     (F# x) == (F# y) = x `eqFloat#` y
00:46:29 <dons> might be an old hugs primitive?
00:46:53 <dons> ?hoogle floatEq
00:46:54 <lambdabot> No matches found
00:47:07 <Botty> ?let near eps a b = abs (a - b) < eps
00:47:09 <lambdabot> Defined.
00:47:33 <Botty> ?let veryClose = near .000001
00:47:34 <lambdabot> <local>:3:18:     No instance for (Num (a -> b))       arising from the liter...
00:47:42 <dons> 0.000001
00:47:48 <Botty> ?let veryClose = near 0.000001
00:47:49 <lambdabot> Defined.
00:48:07 <Botty> ?let close = near .0001
00:48:08 <lambdabot> <local>:4:14:     No instance for (Num (a -> b))       arising from the liter...
00:48:16 <dons> L.ner
00:48:17 <Botty> bah, nevermind
00:48:30 <dons> > L.near 0.0001 1 2
00:48:31 <lambdabot>  False
00:48:36 <dons> > L.near 0.0001 1 1.00000001
00:48:38 <lambdabot>  True
00:49:02 <dons> near .0001 looks like:   near . 1
00:49:13 <dons> i.e. function composition
00:49:13 <Botty> I know
00:49:26 <dons> hence Num (a -> b) :)
00:49:29 <dons> ?type (.)
00:49:29 <Botty> it's dumb that the parser works that way though
00:49:31 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
00:49:46 <dons> maybe. not sure. that's the first time i've seen that error in here
00:50:02 <Botty> should force you to space it when its before a num (why would it ever be before a num anyway)
00:50:04 <Botty> really?
00:50:13 <Botty> you must never see me use the interpreter...
00:50:31 <Botty> most people have probably already been burned by that enough that its habit not to
00:51:18 <dons> oh actually, there's been some:
00:51:18 <dons> $ egrep ' >.* \.[0-9]' * | wc -l
00:51:19 <dons> 13
00:51:21 <dons> in 6 years
00:51:23 <dons> :)
00:51:25 <Botty> lol
00:51:36 <dons> 06.03.12:15:40:46 <ihope_> > 2** .5
00:51:36 <dons> 06.03.25:18:20:19 <ihope> > .96 ^ 25
00:51:36 <dons> 06.08.22:11:51:34 <Amran> > sin .3
00:51:36 <dons> 06.09.07:11:50:18 <dfranke> > .020 * 100000 / 3600
00:51:36 <dons> 06.10.26:17:23:44 <SamB_XP> > .14*5*4/0.4
00:51:38 <dons> 06.10.26:17:28:45 <SamB_XP> > .5 * .14 * (5 * .4 * 4)^2
00:51:45 <Botty> must be some mistake in that regex....
00:51:45 <dons> 06.01.13:14:29:16 <Keal> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^^p) / b - fl (fl (v/b^^p)/b)) in map (digit pi .1) [0,(-1)..(-64)] -- even keal!
00:52:03 <dons> 05.12.27:18:26:25 <syntaxfree> >  (let f x = fst $ randomR (0.0, 1.0) (mkStdGen ((sum . map ord) x))) > .5) in f "I hope this works"
00:52:22 <Botty> heh, wall of shame
00:52:29 <dons> heh
00:53:01 <dons> ah a few more:
00:53:02 <dons> 04.09.14:11:18:26 <Kelt> @eval map (\x -> x+1) [-1, .00000000000000001]
00:53:03 <Botty> does that work for the cases where there's no spaces before the '.' - I don't know regex well (prefer proper parsing tools)
00:53:18 <dons> well, one more.
00:53:35 <dons> it expects a ' ' before the '.', yes
00:53:42 <Botty> could have sword i've done it lots on here
00:53:52 <Botty> *sworn
00:54:14 <Botty> maybe that's just in ghci...
00:57:30 <Heffalump> in the GHC6.4.2 Debian packages, where did the mtl come from?
00:57:46 <Botty> hmm, just thought of a clever idea - a $ that encompasses as much as is required on the right in order to make the expression evaluate.  Definitely not for haskell, but some other, wierder language
00:57:48 * Heffalump has lost it :-(
00:59:49 <Botty> Thought of another - selective currying via '_':  (foldl _ 0 [1,2..5]) (+)
01:00:40 <Botty> I think that's totally haskell' or haskell'' or haskell''' material
01:01:48 <dons> Heffalump: hmm.should be in the standard libs
01:01:55 <dons> its not a separate package
01:01:56 <Heffalump> that was what I thought
01:02:11 <Heffalump> but I can't find the .hi files. The .o and .a is there.
01:02:21 <dons> $ ghc-pkg-6.4.2 list mtl
01:02:21 <dons> /home/dons/lib/ghc-6.4.2/package.conf:
01:02:21 <dons>     mtl-1.0
01:02:24 * Botty has been ignored, probably for some unknown, but good reason
01:03:47 <Heffalump> oh. I think my package.conf file has got buggered somehow
01:03:56 <Heffalump> is there an easy way to get it rebuilt?
01:06:34 <dons> hehe xahlee made the list of all time mad lisp people, http://www.tfeb.org/lisp/mad-people.html
01:06:41 <dons> ?seen xahlee
01:06:41 <lambdabot> I saw xahlee leaving #scheme 19d 12h 13m 20s ago, and .
01:07:07 <therp> dons: that's pretty old
01:07:26 <dons> ah ok. just bubbed up on reddit
01:07:55 <dons> (are there people trying to create an impression that the lisp community is dysfunctional?)
01:09:00 <therp> dons: I guess this list was created to redline the stupid minds in comp.lang.lisp and prevent troll feeding. but it seems that only comp.lang.lisp has that specific problem
01:09:15 <dons> good.
01:09:24 <dons> I was more wondering why someone would post that link to reddit?
01:09:41 <dons> unless it was just because keyword=lisp
01:10:29 <therp> well, the lisp community is dysfunctional. I experienced it myself, but posting this link is pretty useless as the last entry on that page was made 3 years ago..
01:10:34 * Heffalump finally fixes up his ghc installation
01:11:52 <Botty> heh, I see a bit of myself in the description of llias...
01:12:17 <psykotic> botty: you ask people to explain why (expt n 0) is 1 in terms of subtracting apples? :)
01:12:31 <dons> heh
01:12:45 <Botty> "he needs to invent some `perfect' language before he can do anything, and he's starting with the syntax." <- has me all over it
01:13:15 <Botty> psykotic - yes, routinely
01:13:38 <Botty> j/k - I don't even understand that
01:14:48 <Botty> oh, wow, crazy
01:14:56 <Botty> I bet its possible though
01:17:08 <emu> ilias was just nuts
01:17:13 <Botty> since exp is defined in terms of a power series you'd probably start there
01:19:08 <shapr> dons: Have you seen http://tryruby.hobix.com/ ? You think lambdaweb could do something like that?
01:19:09 <lambdabot> Title: try ruby! (in your browser)
01:19:21 <dons> shapr: yeah
01:19:24 <dons> that's the plan
01:19:29 <dons> all the pieces are available
01:19:34 <dons> just needs someone to work on it!
01:19:46 <dons> lispy has some plans/schemes to make it happen
01:20:17 <psykotic> the tutorial is particularly cool
01:20:35 <Botty> that'd be sweet, especially with tutorial stuff (hopefully better than there's)
01:20:50 <shapr> What do you think about a Help typeclass specifically designed to give haddock docs in ghci/hugs/lambdaweb?
01:21:01 <dons> hmm. interesting
01:21:08 <dons> per-type based help?
01:21:15 <dons> ?where lambdaweb
01:21:15 <lambdabot> http://lambdabot.codersbase.com
01:21:17 <shapr> I'm just reading http://lambda-the-ultimate.org/node/1733 and thinking about ways to ease newbies.
01:21:19 <lambdabot> Title: Why Johnny can&#039;t code | Lambda the Ultimate
01:21:46 <shapr> Python has help() and rebol has something similar.
01:21:48 <Botty> Have it use helium.
01:21:55 <shapr> So I figure, why not put something like @docs or @help into ghci?
01:22:18 <dons> yeah, an embedding of haddock help docs into ghci is doable
01:23:42 <shapr> That would appeal to me especially. I pulled my ethernet cable to get work done, and realized that lambdabot speeds up my haskellcoding.
01:25:08 <Heffalump> is there an easy way to decode the raw names of symbols in object files?
01:28:01 <dons> decode the Z encoding?
01:28:12 <dons> could be done. the key is zi == .
01:28:16 <dons> and zh == #
01:28:31 <dons> then there's also ( ) and [  ]
01:28:47 <Heffalump> it's the "d4iX" bit of "PerlziEmbed_d4iX" that is confusing me
01:29:01 <dons> oh, that's a code gen sym
01:29:06 <dons> it doesn't mean anything
01:29:17 <dons> its just a label to a block of C--
01:29:21 <Heffalump> it must mean something, and it's upsetting me cos I'm missing it :-)
01:29:30 <dons> usually means you're missing a package
01:29:45 <dons> since some other code is trying to call PerlziEmbed_d4iX, i.e. Perl.Embed
01:29:51 <dons> which isn't linked for some reason
01:29:55 <dons> missing --make or -package something ?
01:30:16 <Heffalump> Perl.Embed is part of something that isn't a package, but does need an external library
01:30:30 <Heffalump> is there a way to tell hs-plugins I need it?
01:31:28 <dons> it should find the packages for you. but there is an arg to load (iirc) that lets you add arbitrary linker flags
01:31:32 <dons> including missing paths
01:31:46 <dons> you up to something, I take it...;)
01:32:11 <Heffalump> it doesn't seem to have such an arg
01:32:30 <Heffalump> nothing particularly extreme, I just have a hacked-up perl binding and my plugin happens to depend on it
01:39:35 <greentea> Hi all.
01:48:18 <psykotic> dons: hey, got a random idea for a lambdabot feature. smalltalk has this classic method called findBy that lets you find a method by specifying its behavior, so you might specify e.g. f "hello" == 5, f "" == 0, f "abc" == 3, and it would return a list containing the length method. this is easy to code in smalltalk, python, etc but has the disadvantage that side effecting functions are a pain in the ass. so it should work much better in haskell.
01:49:17 <psykotic> i figure you would use something like hoogle to find potential matches and then test them against the provided cases in turn, and return all the ones that pass.
01:50:26 <Botty> whoah, that'd be sweet!
01:51:04 <psykotic> yeah. in dynamic languages it's usually a 5 line hack but side effects are seriously scary :)
01:51:17 <robreim> like djinn? http://lambda-the-ultimate.org/node/1178
01:51:18 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
01:51:19 <Botty> ?find f where f "abc" == 3
01:51:20 <lambdabot> parse error on input `where'
01:51:54 <psykotic> i didn't know djinn did that. in any case it's much simpler than djinn.
01:52:01 <robreim> ?djinn [a] -> Int
01:52:01 <lambdabot> -- f cannot be realized.
01:52:07 <robreim> hmm
01:52:15 <robreim> ?type length
01:52:17 <lambdabot> forall a. [a] -> Int
01:52:25 <robreim> ?djinn forall a. [a] -> Int
01:52:26 <lambdabot> -- f cannot be realized.
01:52:34 <mauke> ?hoogle [a] -> Int
01:52:34 <psykotic> robreim: it's not just a type-level spec, it's also a term-level spec.
01:52:35 <lambdabot> Prelude.length :: [a] -> Int
01:52:49 <psykotic> (note that i suggested using hoogle for the initial selection of candidates)
01:52:56 <mauke> yeah, sounds like a good idea
01:53:00 <psykotic> it
01:53:09 <shapr> It sounds a bit like QuickCheck.
01:53:36 <Botty> except we only give it one case to check
01:53:38 <psykotic> shapr: not really. you specify specific test cases and it finds matching functions from some basis set.
01:53:43 <shapr> Yeah, you could write it with hoogle and QuickCheck.
01:54:40 <shapr> Well, it sounds similar to me.
01:54:43 <psykotic> i guess the advantage of using quickcheck is that you could also specify general properties rather than specific cases that the candidates should have
01:54:44 <shapr> psykotic: Write it! It sounds cool!
01:54:49 <Botty> ?hoogle (a->b->a) -> a -> [b] ->a
01:54:50 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
01:54:50 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
01:55:12 <psykotic> shapr: my haskell-fu is weak :)
01:55:17 <robreim> maybe I don't understand djinn...
01:55:20 <robreim> ?djinn a -> a
01:55:21 <lambdabot> f a = a
01:55:30 <Botty> hmm, what's a type hoogle that returns some very different functions?
01:55:31 <shapr> Your idea would be a good way to increase your haskell-fu.
01:55:32 <psykotic> robreim: djinn finds inhabitants of given types.
01:55:46 <mauke> ?hoogle a -> b
01:55:47 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
01:55:48 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
01:55:48 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
01:55:52 <Botty> ah good point mauke
01:55:55 <psykotic> shapr: it would and i might do it but i have very little coding time these days.
01:56:03 <psykotic> shapr: so i thought i'd throw it out there in any case :)
01:58:41 <Heffalump> right, I've put my library into a package and strace shows it's making no effort to actually read it
01:58:52 <Botty> ?check \f -> f "abc" /= 3
01:58:53 <lambdabot>  Add a type signature
01:58:57 <Heffalump> it reads the package.conf file I told it to
01:59:18 <Botty> technically, if quickcheck could try various fs, this would do what psykotic is talking about
01:59:19 <dons> psykotic: hmm i like it!
01:59:31 <dons> we've thought about it, but not had much of a hint how to do it
01:59:37 <dons> but now we've got hoogle, we can get pretty close
01:59:46 <dons> so infer the type, hoogle it, try the results
01:59:50 <psykotic> right
01:59:57 <dons> and possibly get djinn to generate an option too
02:00:06 <dons> ?djinn a -> b -> (a,b)
02:00:07 <lambdabot> f a b = (a, b)
02:00:26 <psykotic> ?djinn a -> [a] -> [a]
02:00:27 <robreim> dons: how's hs-plugins looking?
02:00:27 <lambdabot> f _ a = a
02:00:46 <psykotic> ?djinn a -> (a,b) -> (a,a,b)
02:00:47 <lambdabot> f a (b, c) = (b, a, c)
02:17:02 <therp> I don't think it is a good idea to nest monads.. IO (MyMonad a) - The only thing MyMonad does is a exception monad with a custom exception payload. there is no way to way a user payload into the userError stuff of the IO Monad, right?
02:18:53 <dons> can you use ErrorT ?
02:19:28 <Heffalump> therp: or dynamic exceptions?
02:20:03 <therp> dons: I think so
02:20:13 <dons> -- Our parameterizable error monad, with an inner monad
02:20:14 <dons> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
02:20:16 <therp> heffalump: hm, what's that?
02:20:32 <therp> google already answered that ^
02:21:36 <Heffalump> therp: the IO exception type has a DynException constructor
02:21:40 <Heffalump> or something similarly named
02:29:14 <therp> dons: hm, the only problem is, I want to use it inside of GHC, that makes GHC depends on its extralibs.. I guess I should just copy paste the code ..
02:29:27 <therp> speaking of ErrorT
02:34:15 <blackdog> g'day all
02:34:47 <greentea> Hi blackdog.
02:35:41 <blackdog> wow, dons and shapr aren't active? This might be the first time ever...
02:36:01 <greentea> They were around earlier . . . .
02:36:57 <dons> yow!
02:37:03 <dons> ?seen
02:37:04 <lambdabot> Lately, I have seen anatolyv, blackdog, dons, greentea, nothingmuch and therp.
02:37:28 <dons> therp: hmm. better ask on cvs-ghc@?
02:38:20 <psnl> I'm awake too, but haven't got anything to say
02:39:33 * psnl mutters about how hard it is to explain haskell
02:41:25 * therp mutters about how hard it is to understand advanced haskell
02:43:54 <greentea> therp: Out of interest, what do you regard as 'advanced'?
02:44:46 <therp> greentea: let's start with reset/shift continuations :)
02:44:59 <therp> and probably combinations with other monads..
02:45:26 <therp> well and actually I have trouble with this particular monad combination at the moment.
02:45:44 <greentea> Heh, i get the concept of continuations, but i've not even /heard/ of reset/shift continuations until this moment. :-P
02:46:35 <blackdog> g'day don
03:04:20 <Cale> http://video.google.com/videoplay?docid=1996321846673788606 -- this was posted on Slashdot. It's an absolutely incredible talk. :)
03:04:23 <lambdabot> Title: Should Google Go Nuclear? Clean, cheap, nuclear power (no, really) - Google Vide ..., http://tinyurl.com/yazbyv
03:05:38 <therp> oh my god. mixing monads is pure horror
03:06:21 <psykotic> therp: calm down, take a deep breath :)
03:08:02 <Cale> therp: which part of the tutorial are you in?
03:08:20 <Cale> (in particular, do you know about monad transformers yet?)
03:09:04 <Cale> also, I should say that All About Monads has the property that many of its examples are terrible, because they use the Cont monad heavily, which tends to make code all but incomprehensible :)
03:09:22 <norpan> monad incomprehensions?
03:09:48 <therp> cale: none at all. I'm just trying to mix my error monad with the IO Monad, by hand..
03:10:29 <xerox> Cale, yeah, I saw that yesterday's morning, it indeed is!
03:10:59 <therp> cale: and I have mostly no idea how to do it...
03:11:23 <xerox> ?google all about monads
03:11:27 <lambdabot> http://www.nomaware.com/monads/
03:11:28 <lambdabot> Title: Nomaware | Monads
03:11:33 <xerox> therp: check that out
03:12:05 <xerox> it has a walk-trough the stacked monads thing
03:14:06 <therp> ha, "Combining monads the hard way" is pretty much of what I'm doing :)
03:14:11 <Cale> yeah :)
03:15:38 <therp> xerox: I know this site but I never read it entirely because it's not nice for printing
03:17:55 <psnl> question: if I buy a mac, will ghc work?
03:18:05 <Cale> psnl: yes
03:18:08 <psnl> yey
03:18:36 <Cale> One thing which I recommend to do which that site won't tell you is to newtype your newly transformed monad, and put the result in a module, and write a specific run function for your monad.
03:19:19 <Cale> You can derive instances of Functor and Monad, as well as any other instances you want with the newtype-deriving extension implemented in GHC and Hugs.
03:19:43 <Cale> (it's a really easy extension to the language to implement, and I'm fairly sure it'll go into the next standard)
03:20:52 <therp> I'm not afraid of writing non-portable code. :)
03:20:58 <Cale> but what that does is it gives you control over what's actually exported -- so you can, say inside your module, write a new state-updating function which makes sure that certain constraints are met before modifying the state, and then not export the full MonadState instance
03:21:30 <Cale> and it gives the transformed monad a nice name
03:21:43 <Cale> and avoids you having to write "lift $ ..." all over the place
03:22:16 <Cale> (only in building the exported operations)
03:23:28 <robreim> You'd still need to write liftIO $ all over the place if you're using a IO monad underneathe...
03:26:19 <Cale> well, yes, in the sense that you're unlikely to wrap all of the IO operations you need
03:46:37 <blackdog> anyone got some good synonyms for continuations?
03:46:48 <blackdog> i'm stuck on a variable name :)
03:47:23 <Cale> future?
03:48:25 <blackdog> hm, not bad
03:49:21 <blackdog> (i only just realised that they are continuations - i have a set of $things, and at any given step of the program, some subset of them are active. sort of a multi-threaded program, but with no resources for each thread)
03:49:57 <blackdog> (each thing dictating what thing is active in the next round. naming suggestions welcomed gratefully - future or continuation are both pretty close)
03:52:49 <rahikkala> Hmm, it seems I'm working with [[[[Int]]]]s, perhaps it's time to declare some types...
03:53:02 <Syzygy-> Heh
03:53:51 <Cale> at least you're not using the Ints as tuples by recording values as digits in some large base :)
03:55:12 <greentea> blackdog: next_comp?
03:55:19 <greentea> (Yes, i'm reaching. :_P )
03:55:21 <greentea> :-P even
03:56:52 <blackdog> hm. no, i think next_comp should be a field in the thing...
03:57:07 <greentea> *nod*
03:57:46 * greentea is trying to think of something to do with frames, call stacks etc.
04:00:01 <greentea> Well, i guess if you're going to use next_comp as a field, why not current_comp?
04:01:02 <_matthew-> I always think of them as the receiver of the result of the current computation
04:01:04 <blackdog> well, the problem there is that it's really an array of these things
04:01:23 <blackdog> so having current_comp[4] would be a bit confusing
04:01:27 <_matthew-> so I'd be tempted to call them receivers
04:01:33 <greentea> Hm.
04:01:38 <blackdog> apologies for deeply non-haskell-related chatter :)
04:02:14 <blackdog> _matthew-: there's really no state being passed - it's just on or off
04:02:19 <dons> can you rephrase the question as a research project?
04:03:30 <blackdog> dons: ...
04:03:36 <dons> :)
04:03:55 <dons> ::
04:03:59 <dons> (:)
04:04:16 <dons> ?type (((:[]) :) :)
04:04:17 <lambdabot> forall a. [[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]
04:05:11 <kpreid> I forget what it was for, but I recently named a haskell function :::
04:05:40 <blackdog> oh god, i'd forgotten haskell humour
04:06:22 <dons> oh dear.
04:06:31 <Syzygy-> dons: Can you give a usage example of (((:[]):):) ?
04:06:38 * dons hears whooshing lambdas
04:06:47 <dons> Syzygy-: hmm. I suppose....
04:06:52 <Baughn> Is there any obvious reason why lambdabot would fail to start, citing out of memory after attempting to allocate 2184 exabytes?
04:06:55 <dons> it can be used to DoS your type checker.
04:07:01 <blackdog> most of the humour here is of the form "Is it live?" "I don't know, why don't you put it on your tongue and see?"
04:07:02 <Syzygy-> Hehe
04:07:03 <dons> Baughn: yes: rm State/seen
04:07:06 <dons> Baughn: and try again
04:07:25 <Syzygy-> dons: Or even tell me what the type signature means? I cannot really decipher the bloody thing....
04:07:47 <dons> ?type (:[])
04:07:57 <Baughn> dons: That worked. Thanks, but.. what did that do?
04:07:59 <dons> oh , someone's DoS the type checker..
04:08:01 <Syzygy-> @type (:[])
04:08:13 <psykotic> Baughn, that reminds me of some code a friend of mine found in Active MQ (an open source message queue package released by amazon). there was a case where they forgot to do a ntohl on a length int before trying to malloc that much storage :)
04:08:18 <Syzygy-> a -> [a]
04:08:18 <dons> Baughn: when the state/seen data format changes, it doesn't parse properly
04:08:35 <dons> leading to an obscure error message
04:08:39 <Syzygy-> So (:[]) takes an element and returns the corresponding single element list.
04:08:49 <Syzygy-> > (:[]) 4
04:09:02 <lambdabot> forall a. a -> [a]
04:09:02 <lambdabot> forall a. a -> [a]
04:09:02 <lambdabot>  [4]
04:09:07 <Cale> hehe
04:09:10 <dons> :)
04:09:14 <dons> good bot
04:09:17 <dons> bad typechecker!
04:09:18 <Syzygy-> So what about ((:[]):) ?
04:09:23 <Cale> someone's abusing poor lambdabot's typechecker :)
04:09:24 <dons> ?type ((:[]):)
04:09:26 <lambdabot> forall a. [a -> [a]] -> [a -> [a]]
04:09:45 <_matthew-> so it's higher order
04:09:50 <Cale> It adds (:[]) to the start of a list of functions of that type
04:09:52 <Syzygy-> So it takes a list of functions that send elements to lists, and give a list of functions that sends elements to lists back.
04:09:52 <dons> its lifting :[] into lists
04:10:07 <psykotic> (:[]) is the happy monkey operator
04:10:15 <dons> heh
04:10:35 <Syzygy-> So ... ((:[]):) (:[]) is a valid thingie giving a list of functions?
04:12:08 <Syzygy-> @hoogle [a -> [a]]
04:12:09 <lambdabot> No matches, try a more general search
04:12:58 <dons> lispy: I'm writing mkcabal right now
04:13:02 <dons> give me 30 mins or so..
04:14:17 <lispy> dons: haah
04:14:47 <Syzygy-> HAH!
04:14:54 * Heffalump gives up on trying to get hs-plugins and his package to work together
04:14:54 <Syzygy-> I think I understand ((:[]):)
04:15:28 <lispy> ?type ((:[]):)
04:15:29 <lambdabot> forall a. [a -> [a]] -> [a -> [a]]
04:15:45 <Syzygy-> Oooooh. And (((:[]):):) tacks the function ((:[]):) to the beginning of a list of other stuff that does more-or-less-the-same.
04:16:09 <Syzygy-> Just as ((:[]):) tacks (:[]) onto another bunch of functions that send an element to a list of such.
04:16:26 <Syzygy-> ?type ((((:[]):):):)
04:16:27 <lambdabot> forall a. [[[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]] -> [[[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]]
04:16:35 <Syzygy-> (or is that cruel and unusual? :)
04:17:40 <lispy> ?type ((:[]):) [(\x -> [x])]
04:17:42 <lambdabot> forall a. [a -> [a]]
04:17:49 <lispy> ?type ((:[]):) [(\x -> [x])] [1,2]
04:17:51 <lambdabot>   The function `(((: [])) :)' is applied to two arguments,
04:17:51 <lambdabot>   but its type `[a -> [a]] -> [a -> [a]]' has only one
04:17:57 <lispy> ?type ((:[]):) [(\x -> [x])] [return]
04:17:58 <lambdabot>   The function `(((: [])) :)' is applied to two arguments,
04:17:59 <lambdabot>   but its type `[a -> [a]] -> [a -> [a]]' has only one
04:18:13 <lispy> ?type (((:[]):) [(\x -> [x])]) [return]
04:18:14 <lambdabot>   The function `((((: [])) :) [(\ x -> [x])])' is applied to one arguments,
04:18:14 <lambdabot>   but its type `[a -> [a]]' has none
04:18:18 <lispy> grr.!
04:20:21 <lispy> ?type map (((:[]):) [(\x -> [x])]) [1,2]
04:20:23 <lambdabot>   Expecting a function type, but found `[a -> [a]]'
04:20:23 <lambdabot>    Expected type: a -> b
04:20:46 <lispy> ?type map ($) (((:[]):) [(\x -> [x])]) $ [1,2]
04:20:47 <lambdabot>   Expecting a function type, but found `[b]'
04:20:48 <lambdabot>    Expected type: a -> b
04:21:12 <lispy> hmm...
04:21:33 <lispy> i have a [a -> [a]], i should be able to map that with apply to a [a]
04:21:36 <lispy> right?
04:21:46 <lispy> ?type (map ($) (((:[]):) [(\x -> [x])])) [1,2]
04:21:48 <lambdabot>   The function `(map ($) ((((: [])) :) [(\ x -> [x])]))'
04:21:48 <lambdabot>   is applied to one arguments,
04:23:59 <lispy> ?version
04:24:00 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
04:24:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:24:59 <zekvent> >map ($ 4) (((:[]):)[\x->[]])
04:25:28 <lispy> >map ($ 4) (((:[]):)[\x->[]])
04:25:31 <lispy> > map ($ 4) (((:[]):)[\x->[]])
04:25:33 <lambdabot>  [[4],[]]
04:30:49 <xerox> > let box = (:[]) in [box, const []] `ap` return 4
04:30:50 <lambdabot>  [[4],[]]
04:30:53 <xerox> (-:
04:34:27 <Syzygy-> ?type const . const
04:34:28 <lambdabot> forall b a b1. a -> b -> b1 -> a
04:34:39 <Syzygy-> ?type const . const []
04:34:40 <lambdabot> forall b a a1. a -> b -> [a1]
04:36:20 <Jaak> right. somebody dragged lambdabot to ##C. Now I got banned from there for showing some of haskell features. :\
04:36:24 <Jaak> lovely
04:36:48 <Syzygy-> Hehe
04:40:09 <lispy> Jaak: serious?
04:40:10 <lispy> ?seen
04:40:11 <lambdabot> Lately, I have seen bourbaki, chris2, jaak, lispy, syzygy- and xerox.
04:40:19 <lispy> ?seen lambdabot
04:40:20 <lambdabot> Yes, I'm here. I'm in #oasis, #ScannedInAvian, #unicycling, #perl6, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell
04:40:39 <lispy> she's not there now...
04:40:43 <Jaak> nay, luckily not a real bann, just +b for few minutes
04:40:48 <Jaak> s/nn/n/
04:41:12 <lispy> unreal ban man
04:41:15 <Jaak> :D
04:41:37 <Cale> can we see the logs?
04:42:30 <Syzygy-> Please?
04:43:45 <Jaak> eh, simple foldr (*) 1 [1..5] and take 10 $ fix (\f -> 1 : 1 : zipWith (+) f (tail f)) and then bam!
04:44:06 <lispy> no love for the fibs
04:44:14 <Syzygy-> It would be offtopic for ##c, though....
04:44:14 <Jaak> but i get it, it's not #haskell :)
04:44:15 <Jaak> yeah
04:44:43 <Cale> http://alixcomsi.com/PvNP.htm -- I totally fail to see how the thing which is proved here is connected to P vs. NP. The author cites boolean satisfiability in polynomial time, and then fails to talk about time complexity for the entire rest of the paper. Moreover, he talks about Turing-decidability of statements instead. Does anyone see the connection?
04:44:45 <blackdog> dude, you're not gonna win over C# people with math tricks...
04:45:10 <Cale> blackdog: not C#, C
04:45:26 <lispy> Cale: in this case C# and C are interchangable though :)
04:45:26 <blackdog> oh, ok. well, you won't win them either :)
04:45:51 <Cale> actually, it was fairly popular earlier on
04:45:57 <lispy> Cale: people are always claiming to make progress on PvsNP but they're crack pots sualy ;)
04:46:10 <Cale> lispy: well, yes :)
04:46:24 <Cale> lispy: the interesting thing is to determine exactly where they're being crackpots
04:47:33 <Cale> In this case, most of the argument is pretty sane (at least I didn't find any obvious flaws there), but the final link to P vs. NP isn't clear to me.
04:48:19 <lispy> yeah, turing decidability is at a level above the PvsNP weird
04:48:24 <lispy> s/weird/vorld/
04:48:28 <lispy> s/v/w/
04:50:39 <lispy> i find it odd that i sometimes typo by typing a word which is semantically completely unrelated to the one i ment
04:50:42 <Jaak> bah, got to go
04:53:53 <Cale> Actually, there are some odd jumps near the very end too which I don't quite understand
04:57:08 <dons> lispy: ok done. sent to haskell-cafe
04:57:17 <dons> i'd be interested in initialising the darcs stuff in the project next
04:57:30 <dons> as well as creating sub tests and haddock goo
04:58:15 <greentea> Cale: Have you seen the paper on P vs. NP by Sergey Gubin?
04:58:57 <Cale> greentea: this is actually the first one which I've bothered to read through because it was short :)
04:59:07 <greentea> Heh.
04:59:31 <greentea> Gubin's is only 9 pages, but there's no way i'm qualified to make an assessment of it.
04:59:55 <lispy> dons: nice
05:00:01 <lispy> dons: i think we got Douglas interested
05:00:13 <Cale> http://arxiv.org/abs/cs.CC/0610125
05:00:15 <lispy> or Dougal actually
05:00:23 <lispy> not a name i'm used to :)
05:00:52 <dons> my dad calls me Dougal, fine Scottish name.
05:01:11 <lispy> heh
05:01:40 <lispy> dons: there is a lot of irish and scottish ancestry in austraila?
05:01:42 <greentea> Cale: Ah! Missed that, thanks.:-)
05:02:02 <dons> lispy: yeah.
05:02:27 <greentea> Cale: Although the latest revision of Gubin's paper is 9 November; maybe it addresses the examples in that paper?
05:02:32 <dons> the area i grew up in was a bit of a scottish enclave.
05:02:48 <lispy> dons: cool, i listen to some irish music and they talk about austraila a lot, but i was never sure if it was authentic or not
05:03:26 <lispy> i think of the songs that talks about .au a lot is botany bay
05:05:32 <psnl> Cale: I assume you have seen http://geomblog.blogspot.com/2004/04/meta-proof.html ?
05:05:35 <lambdabot> Title: The Geomblog: A meta-proof, http://tinyurl.com/vn9ct
05:08:19 <Cale> psnl: well, here he might have proven something remotely useful, just not P/=NP.
05:09:41 <lispy> dons: i contest this runhaskell Setup.hs configure --prefix=$HOME
05:09:55 <lispy> dons: i think it should be runhaskell Setup.hs configure --bindir=`pwd`
05:10:46 <dons> yes. it should be
05:10:50 <dons> hmm no...
05:11:00 <dons> we don't want to install into `pwd` by defualt do we?
05:11:10 <dons>  --prefix=/usr/local perhaps?
05:11:30 <dons> (its really only there to illustrate that you can pass a --prefix arg)
05:12:39 <psnl> Cale: "constructive interpretation" worries me, since it implies he is approaching it though contsructive maths
05:13:07 <lispy> dons: i dunno, i guess cabal doesn't have a nice whay to do this
05:13:31 <dons> what are you trying to do?
05:13:35 <lispy> i like --bindir but i usually only build a single binary file from the entire project
05:13:57 <dons> but you want the binary installed inplace?
05:14:01 <lispy> well, when i used make, i would always just dump the finaly exe in to the root level of the project so i could then run it :)
05:14:22 <lispy> yeah just to make it easy to run it and test it
05:14:39 <Cale> psnl: not quite -- he's still talking about ZF -- in order to generalise some results he's ignoring the potential for other models though, which is odd. However, the way he's described things, it ought not to affect the P vs. NP part, though how that connection is made is totally unclear.
05:15:11 <swiert> dons: have you seen the slides and abstracts for fun in the afternoon?
05:15:57 <dons> no, but I'd like to see them (with a writeup!) for the HWN..
05:16:21 <swiert> http://sneezy.cs.nott.ac.uk/fun/nov-06/
05:16:25 <lispy> dons: your tutorial is really good, and i like that you don't give them the tool until you explain at least once, everything that they would do
05:16:31 <lambdabot> Title: Fun in Oxford, November 2006
05:16:48 <swiert> It has abstracts for all the talks as well.
05:16:48 <dons> lispy: ok good.
05:16:54 <dons> swiert: ah great!
05:16:57 <lispy> dons: only concern might be that the steps look longerbecause youspell it all out in gory detail...but i thkn i like it...let's see if any n00bs comment
05:17:08 <swiert> dons: no problem.
05:17:08 <dons> swiert: so I can include text from here into the HWN?
05:17:21 <swiert> dons: by all means please do.
05:17:34 <dons> lispy: right. it should all boil down to 'joincabal myproject' or something in the end
05:17:53 <dons> swiert: ok. very good.
05:17:57 <lispy> oh was joincabal meant as the name of the tool?
05:18:10 <lispy> i thought that was a suggestion to Dougal to join his project with cabal :)
05:18:20 <dons> well, i just called it 'mkcabal' but I see you're having a biked shed discussion about the name?
05:18:38 <dons> there-is-a-cabal-now ?
05:18:41 <lispy> yeah, i thought bikeshedgen would be a good name :)
05:19:09 <lispy> i think Haskell Project Wizard is actually the best name
05:19:20 <lispy> because it's pretty clear what it's for :)
05:19:22 <dons> lispy: so, what do you think: should I detect if darcs is installed, and if so, use it to initialise the proejct...
05:19:42 <lispy> dons: well...you need two modes then
05:19:50 <dons> so maybe --darcs
05:19:55 <dons> and there needs also to be --library
05:20:08 <lispy> dons: what if i already have a repo and i'm just using mkcabal to create the.cabal file?
05:20:43 <dons> right, i was thinking that
05:20:50 <dons> mkcabal does more than create the .cabal file though
05:21:01 <dons> currently it initialises the whole project
05:21:16 <dons> it should be able to just create the cabal stuff too, on its own
05:21:34 <dons> i.e. default is to just make a .cabal and Setup.hs file
05:21:44 <dons> but with --all you get darcs, and stub files and so on
05:22:23 <lispy> sounds good
05:22:28 <lispy> or --project-init
05:23:47 <dons> yeah
05:25:11 <lispy> starting to make a wishlist...it might be nice if mkcabal could try to guess about your project...like trying to put all of your source modules into the .cabal file with a comment telling you to edit as needed
05:25:33 <dons> ah, so take a tree and populate the .cabal file
05:25:36 <dons> yeah, that'd be good
05:26:25 <lispy> it doesn't have to be right, just save someone a few minutes
05:28:13 <lispy> ?localtime lispy
05:28:14 <lambdabot> Local time for lispy is Sun Nov 19 05:25:40 2006
05:28:21 <lispy> i should be asleep!
05:28:25 <lispy> night!
05:28:25 <malebria> Hello there.
05:28:28 <lispy> (or morning)
05:28:39 <malebria> lispy: morning.
05:28:46 <lispy> malebria: hey, welcome to #haskell
05:28:51 <malebria> =D
05:29:02 * lispy passes out
05:31:33 <dons> lispy: ok done.
05:31:41 <dons> adds --init-project
05:31:46 <dons> and makes .cabal files only by default
05:34:19 <lispy> nice
05:34:22 <lispy> ?where mkcabal
05:34:22 <lambdabot> I know nothing about mkcabal.
05:34:53 <dons> ?where+ mkcabal darcs get http://www.cse.unsw.edu.au/~dons/code/mkcabal
05:34:54 <lambdabot> Done.
05:35:04 <dons> just sent a summary of the current state
05:35:08 <dons> agile yourself up!
05:35:14 <lispy> heh
05:35:25 <lispy> okay, gone to bed for real now
05:35:29 * dons is 3/4 asleep. thanks the gods for typecheckers
05:35:40 <dons> ?time lispy
05:35:42 <lambdabot> Local time for lispy is Sun Nov 19 05:33:07 2006
05:35:45 <dons> ah yes
05:36:00 <robreim> Wow. That's some impressive nocturnalism
05:44:01 <vegai> Heh, lambdabot was too much for  ##c
05:44:20 <dons> oh ?
05:44:23 <dons> what happened in the end?
05:44:33 * dons isn't too surprised
05:44:42 <dons> more surprised it lastest this long..
05:45:29 <vegai> Somebody hated bots in general, and the rest is history
05:46:31 <Oejet> vegai: Is the history logged somewhere?
05:48:09 <xerox> dons wants to study this ##c anima^H^H^H^H^Hpeople as well
05:50:41 <erider> good morning all
05:50:50 <vegai> perhaps we should try a C bot here
05:51:02 <vegai> though I reckon it won`t do much more, save segfaulting
05:52:52 <psnl> > malloc(all_the_mem)
05:52:53 <lambdabot>  Not in scope: `all_the_mem'
05:52:55 <xerox> Aren't eggdrops written in C?
05:53:41 <xerox> ...but even then, they are scripted in TCL.
05:54:48 * Heffalump runs an eggdrop, it doesn't segfault
05:54:53 <Heffalump> I even hacked a perl scripting interface into it.
05:55:13 <dons> an EDSL for building irc bots would be pretty simple..
05:55:26 <dons> then again, bots themselves are simple
05:55:43 <Heffalump> eggdrop isn't :-(
05:55:47 <dons> Heffalump: you run an eggdrop instead of a lambdabot? shame!
05:55:49 <dons> ;)
05:55:49 <mauke> no, bots are hard
05:55:53 <xerox> "...they are just a morphism in the category of IRC channels together with an endomapping ..."
05:55:58 <dons> heh
05:55:59 <Heffalump> I've had it for ages, well before lamdabot existed
05:55:59 * xerox pokes dons
05:56:17 * dons prods xerox
05:56:17 * Heffalump pokes resiak, he was talking about reimplementing what it does with lambdabot
05:56:52 <mauke> @remember xerox <dons> then again, bots themselves are simple  <xerox> "...they are just a morphism in the category of IRC channels together with an endomapping ..."
05:57:06 <xerox> hehe
05:57:13 <dons> :)
05:57:26 <xerox> I know _that's_ what you were thinking.  Somehow.
05:57:51 <resiak> Heffalump: I got distracted :)
05:59:30 <Heffalump> anyone would think you had a degree to do
06:00:23 <resiak> Heffalump: ha
06:06:12 <dons> i really enjoy writing shell script-level tools in haskell
06:06:32 <dons> you get to play with such nice abstractions that mechanical boring code becomes fun
06:30:50 <ventonegro> hi, does anyone know why libghc6-opengl-dev depends on ghc6-prof?
06:30:55 <ventonegro> (debian)
06:31:32 <Cale> perhaps Igloo?
06:31:50 <ventonegro> ah, he's the packager, yes
06:32:18 <ventonegro> Igloo, hello? :-)
06:32:28 <Cale> @seen Igloo
06:32:29 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 1d 16h 49m 27s ago.
06:32:51 <ventonegro> maybe asleep
06:34:41 <psnl> ventonegro: what version are you looking at?
06:34:55 <ventonegro> unstable
06:35:07 <ventonegro> the opengl package just arrived
06:35:21 <psnl> ventonegro: ok, on sarge its a link to hopengl
06:35:28 <Igloo> ventonegro: Because it includes the profiling libraries
06:35:39 <psnl> ventonegro: "This package contains additional HOpenGL libraries, including suitable profiling libraries for the Glorious Glasgow Haskell Compilation
06:35:43 <psnl>  system (GHC)."
06:35:46 <ventonegro> Igloo, i know, but why
06:35:55 <ventonegro> Igloo, just out of curiosity
06:35:57 <psnl> ventonegro: so you can profile your code?
06:36:21 <ventonegro> psnl, shouldn't i install another package if i want to do that?
06:36:38 <Igloo> For simplicity. I'll probably split it out after etch
06:38:00 <ventonegro> ok
06:38:08 <ventonegro> thanks
06:47:35 <spiffy> hello
07:06:36 <spiffy> how to I send a buffer to gchi using haskell-mode?
07:07:43 <Cale> http://www.xach.com/lisp/taste-for-the-web.html -- hahaha
07:07:46 <lambdabot> Title: Taste for the Web, http://tinyurl.com/y3exmx
07:09:07 <Cale> spiffy: I'm not completely sure, I'd need to install emacs here, but I think it was C-c C-l
07:10:21 <spiffy> hmmm symbol's function definition is void: inferior-haskell-load-file
07:11:24 <spiffy> looks like I need to set something up
07:12:28 <therp> (require 'haskell-mode) (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
07:14:22 <spiffy> symbols value as variable is void: haskell-gchi-mode-map
07:16:06 <ivant> > Data.Generics.everywhere Data.List.sort ([3, 2], [1, 0])
07:16:07 <lambdabot>  Not in scope: `Data.Generics.everywhere'
07:16:29 <therp> spiffy: (require 'haskell-ghci) maybe before?
07:17:34 <spiffy> same error
07:17:35 <Cale> ghci
07:18:00 <spiffy> but something is getting spawned
07:18:13 <spiffy> yup ghci got spawned
07:21:03 <therp> spiffy: where did you get your haskell mode from?
07:21:29 <therp> spiffy: I had the impression that I had to quit emacs once, as some parts where half loaded for hugs.
07:22:52 <spiffy> apt-get in ubuntu
07:23:56 <therp> hm, no idea if that is a good choice.
07:25:58 <spiffy> probably not
07:27:34 <malebria> Hello there.
07:27:43 <malebria> dcoutts: Are you there?
07:27:45 <malebria> dcoutts_:
07:41:46 <therp> hm, no idea if that is a good choice.
07:41:50 <therp> uh sorry
08:41:32 <monochrom> > repeat "<3 Haskell"
08:41:36 <lambdabot>  ["<3 Haskell","<3 Haskell","<3 Haskell","<3 Haskell","<3 Haskell","<3 Haskel...
08:44:58 <vegai> >  repeat $ (take 4 $ repeat "Haskell") ++ (take 2 $ repeat "Mushroom")
08:45:00 <lambdabot>  [["Haskell","Haskell","Haskell","Haskell","Mushroom","Mushroom"],["Haskell",...
08:46:03 <stepcut> aaaaaaaaa!
08:46:28 <eviltwin_b> you forgot the snaaaaaaaake! :>
08:47:07 <monochrom> data DeCarte = forall a. Think a => Exist a
08:47:47 <monochrom> @remember monochrom data DeCarte = forall a. Think a => Exist a
08:48:18 <dolio> Quoting yourself?
08:48:27 <Maddas> monochrom: Do you mean Descartes?
08:48:30 <LoganCapaldo> Laziness is so cool!
08:48:45 <monochrom> Oops!
08:48:49 <vegai> data Rand = forall a. Exist a => Maybe (Think a) ...
08:48:49 <LoganCapaldo> Every other language would have a repeat n function
08:48:53 <Maddas> LoganCapaldo: Yeah, I've been doing nothing other than playing nethack all weekend! (:
08:49:29 <dolio> > replicate 4 "Haskell" ++ replicate 2 "Mushroom"
08:49:31 <lambdabot>  ["Haskell","Haskell","Haskell","Haskell","Mushroom","Mushroom"]
08:49:50 <vegai> dolio: oh, much better
08:51:06 <dolio> ?pl take n . repeat
08:51:07 <lambdabot> take n . repeat
08:51:15 <gds> > unwords $ replicate 4 "Haskell" ++ replicate 2 "Mushroom"
08:51:17 <dolio> ?pl head . drop n
08:51:17 <lambdabot>  "Haskell Haskell Haskell Haskell Mushroom Mushroom"
08:51:17 <lambdabot> head . drop n
08:53:24 <kpreid> ?unpl head . drop n
08:53:25 <lambdabot> (\ c -> head (drop n c))
08:53:27 <astrolabe> It would be good to have @pl in ghci
08:53:40 <xerox> astrolabe: and you can!
08:53:49 <astrolabe> xerox: you can?
08:53:51 <xerox> Ever heard of GHCi On Acid? (GOA)
08:54:02 <astrolabe> Did you just make that up?
08:54:06 <kpreid> No.
08:54:12 <Syzygy-> > unwords $ replicate 8 "Haskell ++ replicate 2 "Monads"
08:54:13 <xerox> Yes, I made it :)
08:54:13 <lambdabot>  Improperly terminated string
08:54:20 <Syzygy-> > unwords $ replicate 8 "Haskell" ++ replicate 2 "Monads"
08:54:21 <lambdabot>  "Haskell Haskell Haskell Haskell Haskell Haskell Haskell Haskell Monads Monads"
08:54:21 <LoganCapaldo> Does GOA have @djinn too?
08:54:27 <LoganCapaldo> That's my favorite
08:54:29 <xerox> Yep.  It has all the \bot commands.
08:54:37 <Syzygy-> @help djinn
08:54:38 <lambdabot> djinn <type>.
08:54:38 <LoganCapaldo> gimmie! ;)
08:54:38 <lambdabot> Generates Haskell code from a type.
08:54:38 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
08:54:43 <xerox> ?version
08:54:44 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
08:54:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:54:45 <Syzygy-> o.O
08:54:48 <xerox> darcsget.
08:54:50 <astrolabe> oooh
08:54:50 <Syzygy-> What does djinn make!?
08:54:58 <xerox> Syzygy-: functions!
08:55:06 <Syzygy-> @djinn Integer -> [[Integer]]
08:55:07 <lambdabot> -- f cannot be realized.
08:55:18 <Syzygy-> @djinn [[Integer]] -> Integer
08:55:19 <lambdabot> -- f cannot be realized.
08:55:23 <LoganCapaldo> @djinn Bool -> a -> a -> a
08:55:24 <lambdabot> f a b c =
08:55:24 <lambdabot>   case a of
08:55:25 <Syzygy-> Hmmm.
08:55:25 <lambdabot>   False -> c
08:55:27 <lambdabot>   True -> b
08:55:35 <astrolabe> @djinn (a -> b) -> [a] -> [b]
08:55:35 <lambdabot> -- f cannot be realized.
08:55:40 <kpreid> ?djinn a -> b -> Either (c -> a) (c -> b) -> c -> Either a b
08:55:40 <lambdabot> f a _ b c =
08:55:41 <lambdabot>   case b of
08:55:41 <lambdabot>   Left d -> Left (d c)
08:55:41 <lambdabot>   Right _ -> Left a
08:55:52 <xerox> Recursively defined types are not supported (yet).
08:55:54 <astrolabe> bah I can realise it
08:55:59 <kpreid> hm, djinn got mine wrong
08:56:10 <xerox> http://www.cse.unsw.edu.au/~dons/code/goa/
08:56:11 <lambdabot> Title: Index of /~dons/code/goa
08:56:39 <astrolabe> coo  #haskell makes it impossible to get anything done.
08:57:01 <Heffalump> it's got too busy to be on all the time, IME
08:57:16 <xerox> astrolabe: try it out :)
08:57:39 <astrolabe> xerox: get thee behind me!
08:57:56 * xerox scratches head
08:58:10 <astrolabe> it is a temptation
08:58:22 <xerox> yess!
08:58:47 <xerox> didn't you read of that guy...
08:59:13 * xerox hunts the article
09:00:14 <fabiim> how could i make something like this :
09:00:17 <LoganCapaldo> Ah I see I must also darcs get lambdabot as well
09:00:33 <fabiim> [ filter (==a) "ZEROONET"  | a<-["ZERO","ONE","THREE"..]
09:00:35 <fabiim> ?
09:01:14 <xerox> astrolabe:  http://www.wired.com/news/technology/0,70015-0.html
09:01:16 <lambdabot> Title: Wired News: LSD: The Geek's Wonder Drug?, http://tinyurl.com/7o6zk
09:01:25 <fabiim> the first run of that shouldn't be : filter (=="ZERO") "ZERONET" ?
09:01:39 <xerox> yep.
09:02:35 <fabiim> filter ::  (a->bool) ...
09:02:37 <dolio> Two possibilities.
09:02:38 <fabiim> that's the problem ...
09:02:58 <fabiim> i'm doing [a] to bool ...
09:02:58 <dolio> Oh, wait...
09:03:20 <monochrom> It is hard to guess the intention.
09:03:40 <dolio> Yeah, I'm confused as to what you want now. :)
09:04:01 <fabiim> are you guy's talking to me?
09:04:05 <dolio> Yeah.
09:04:19 <fabiim> i want to filter words in a list
09:04:22 <monochrom> I offer [ filter isPrefixOf "ZEROONET" | a<-["ZERO","ONE","THREE"] ]
09:04:36 <fabiim> i have a [String]  and i want to filter every element of it
09:04:38 <fabiim> in a word
09:05:10 <fabiim> isPrefixOf does what?
09:05:47 <LoganCapaldo> @hoogle isPrefixOf
09:05:48 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
09:06:06 <dolio> > [ a | a <- ["ZERO, "ONE", "THREE"], a `isInfixOf` "ZEROONET" ]
09:06:07 <lambdabot>  Improperly terminated string
09:06:18 <astrolabe> > isPrefixOf [1..5] [1..10]
09:06:20 <lambdabot>  True
09:06:25 <dolio> > [ a | a <- ["ZERO", "ONE", "THREE"], a `isInfixOf` "ZEROONET" ]
09:06:25 <monochrom> isPrefixOf x y == x is a prefix of y
09:06:26 <lambdabot>  Not in scope: `isInfixOf'
09:07:59 <dolio> @let isInfixOf p l = any (isPrefixOf p) (tails l)
09:08:00 <lambdabot> Defined.
09:08:09 <dolio> > [ a | a <- ["ZERO", "ONE", "THREE"], a `L.isInfixOf` "ZEROONET" ]
09:08:09 <LoganCapaldo> Hmm, can we do f xs ys case ys of zs ++ xs ++ qs -> True ; _ -> False ?
09:08:11 <lambdabot>  ["ZERO","ONE"]
09:08:50 <dolio> (++) isn't a constructor of lists, so no.
09:09:25 <dolio> That'd also require unification, I think, which haskell doesnt' do.
09:10:10 <monochrom> GHC 6.6 has Data.List.isInfixOf.  That will do.
09:10:34 <LoganCapaldo> import Language.Semantics.Prolog ;)
09:10:35 <monochrom> lambdabot doesn't do 6.6 yet.
09:10:59 <dolio> Is there a reason for that? Or has dons just not gotten around to it?
09:12:59 <astrolabe> is there a built in command returning the quotient and the remainder of a division?
09:13:03 <fabiim> what do i have to import to have L.isInfixof
09:13:04 <fabiim> ?
09:13:17 <fabiim> astrolabe: divMod
09:13:25 <astrolabe> fabiim: thanks
09:13:40 <astrolabe> @hoogle isInfixOf
09:13:41 <lambdabot> No matches found
09:14:03 <dolio> In lambdabot L.foo is the foo function defined by @let.
09:14:08 <ndm> hoogle doesn't do 6.6 either
09:14:19 <dolio> If you're running 6.6, though, isInfixOf should be in Data.List.
09:14:29 <LoganCapaldo> @hoogle (Integral a) => a -> a -> (a, a)
09:14:30 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
09:14:30 <lambdabot> Prelude.quotRem :: Integral a => a -> a -> (a, a)
09:14:30 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
09:14:42 <LoganCapaldo> lol quotRem
09:14:47 <LoganCapaldo> nice
09:14:57 <astrolabe> @type divMod
09:14:59 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:15:05 <astrolabe> @type quotRem
09:15:06 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:15:14 <astrolabe> hmmm
09:15:16 <dolio> 5 `quotRem` (-2)
09:15:20 <dolio> > 5 `quotRem` (-2)
09:15:21 <lambdabot>  (-2,1)
09:15:25 <dolio> > 5 `divMod` (-2)
09:15:27 <lambdabot>  (-3,-1)
09:15:27 <LoganCapaldo> Ahhhh one of those ;)
09:16:10 <astrolabe> both wrong?
09:16:11 <fabiim> i'm not running 6.6
09:16:41 <astrolabe> 5 = (-3)(-2) + 1
09:16:46 <astrolabe> ER
09:17:17 <astrolabe> 5 = (-3)(-2) - 1
09:17:23 <astrolabe> ah
09:17:35 <LoganCapaldo> For GOA, do I have to build lambdabot before I point GOA at its directory?
09:18:21 <astrolabe> If god had meant us to use negative numbers, he'd have given us all debts.  Oh, hang on a minute.
09:23:18 <fabiim> so , no easy solutions for my problem?
09:23:45 <xerox> LoganCapaldo: yes
09:23:56 <xerox> LoganCapaldo: it _runs_ lambdabot, inside an ADT, heh.
09:24:26 <xerox> lambdabot's experience of the world changes, because she's now inside the ADT.
09:24:57 * xerox goes back to finish his stuff...
09:25:17 <glauber_sp> hi guys. I need to show how Haskell implements lambda calculus. I've writeen about untyped lambda calculus and I need to introduce typed lambda calculus to connect lambda calculus and Haskell. Should I introduce Curry or Church type system?
09:27:19 <therp> glauber_sp: Curry
09:27:55 <glauber_sp> therp, thanks a lot =)
09:28:22 <Baughn> Is there any particular reason GHC uses .hi files instead of baking the interface into a new section of the .o files?
09:29:12 <Igloo> Having two different timestamps is useful for recompilation checking
09:29:18 <xerox> Baughn: yes! And Simon Pejton-Jones explains it in the GHC Hackaton videos!
09:29:31 <Oejet> xerox: Where are they?
09:29:35 <xerox> On the GHC wiki.
09:29:52 <xerox> Well, they are on Google Video, and you can find the links on the GHC wiki.
09:30:16 <malebria> dcoutts: are you there?
09:30:18 <malebria> dcoutts_:
09:30:32 <malebria> I think I found a bug, I don't know if it's in gtk2hs or in libgtk itself.
09:30:33 <xerox> malebria: are you one of his students?
09:30:48 <xerox> Oh, nevermind.
09:30:51 <astrolabe> he has students?
09:30:51 <malebria> xerox: no, I just talk to him usually about gtk2hs.
09:31:08 <xerox> astrolabe: TA
09:31:20 <malebria> xerox: are you also a gtk2hs developer?
09:31:22 <astrolabe> territorial army
09:32:06 <xerox> Teaching Assistant
09:32:21 <xerox> malebria: I contributed some code yes
09:32:24 <astrolabe> ah
09:32:27 <Oejet> xerox: Thank you.
09:32:40 <xerox> Oejet: You're welcome!
09:33:30 <malebria> xerox: I'm trying to use EntryCompletion, and in the popup it is matching case-insensitive, on the inline match it's matching case-sensitive
09:33:42 <malebria> xerox: isn't it strange?
09:34:05 <xerox> malebria: I don't know, is there any documentation for that thing?
09:34:22 <malebria> xerox: in the doc it sais that it's case-insensitive.
09:34:42 <xerox> Prod Duncan :)
09:35:10 <malebria> ?
09:35:30 <xerox> Er, ask, poke, talk to
09:35:58 <xerox> ...or try to find the related binding code, to realize what is going on.
09:36:45 <malebria> xerox: I'll try to talk to him. I think it's probably a gtk bug.
09:37:03 <malebria> And about this I don't know who to talk with.
09:37:06 <xerox> Then you could go on #gtk on irc.gtk.org, I think there exist something like that.  Maybe it is irc.gnome.org.
09:37:50 <Baughn> xerox: The video quality is a bit unfortunate, but he is understandable at least. :)
09:40:24 <newsham> > let b x = arr (x ++); a x = arr (++ x); i t = (arr id) <+> t in ["hi", "test"] >>= (runKleisli $ (i$b "<") >>> (i$a ">") >>> (i$((b "!") >>> (a "!"))))
09:40:25 <lambdabot>  ["hi","!hi!","hi>","!hi>!","<hi","!<hi!","<hi>","!<hi>!","test","!test!","te...
09:40:44 <xerox> wow.
09:41:13 <newsham> yay kleisli arrow
09:41:44 <xerox> unfortunate syntax
09:41:55 <newsham> its just ugly as a one liner
09:42:01 <xerox> Does it look better with -farrows, and proc?
09:42:23 <malebria> xerox: people there don't seem to talk too much.
09:42:23 <newsham> dont know what that means.
09:42:28 <newsham> see main2 in http://www.thenewsh.com/%7Enewsham/x/machine/Transform3.hs
09:42:30 <lambdabot> http://tinyurl.com/sr7y9
09:42:37 <xerox> malebria: :-/
09:43:49 <xerox> newsham: how is Kleisli defined?
09:44:07 <xerox> In particular, what are its three arguments?
09:44:26 <xerox> Kleisli m a b = a -> m b ?
09:45:29 <xerox> This is mixing monads and arrows, isn't it?
09:45:37 <xerox> Will this be the fifth question in a row?
09:45:58 <newsham> newtype Kleisli m a b = Kleisli { runKleisli :: (a -> mb) }
09:46:02 <newsham> its in the arrow library.
09:46:31 <newsham> the kleisli arrow is already a monadic function thingamajig
09:46:57 <newsham> so Kleisli [] String String     is    String -> [String]
09:47:05 <newsham> which is the function I'm using above.
09:47:08 <newsham> err.. signature
09:49:53 <newsham> can you explain the -farrows,proc thing?
09:50:47 <dolio> It lets you use a syntax similar to monads instead of >>>.
09:51:05 <newsham> ooh..  in ghc documentation somewhere?
09:51:52 <dolio> It's something like... "proc x do y <- a -< x ; z <- b -< y ..." gets translated to "a >>> b".
09:52:26 <dolio> Which isn't impressive on its own, but when you start getting into lots of convoluted combinations, it gets cleaner.
09:52:30 <newsham> sigfpe blogspot was hinting at some sort of parallel to do {} for comonads..  is this that?
09:52:50 <xerox> http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
09:52:53 <lambdabot> Title: 7.7. Arrow notation, http://tinyurl.com/tts6c
09:53:01 <eviltwin_b> he was suggesting that there *should* be such a thing, and was a bit cofused about the semantics, IIRC :)
09:53:05 <newsham> xerox: danke.
09:53:12 <xerox> newsham: you're welcome!
09:53:18 <dolio> And, for instance, you can use "if ... then ... else ..." instead of doing stuff with ArrowChoice.
09:53:18 <xerox> I'd love to see the translation.
09:54:19 <newsham> me too :)   I'l get cracking.
09:54:26 * xerox hugs newsham 
09:56:48 <newsham> does lambdabot -farrows?
09:57:20 <xerox> I don't think so.
09:57:42 <xerox> So you've verb-ed an option.  That's a new idiom :P
09:58:46 <newsham> do you yahoo?
10:00:29 <Botje> -no
10:06:58 <benmos> Hi all. I have a quick cabal question... When I try to build my app with "runhaskell Setup.hs build" it fails to find the "Array" module which is referenced without the "Data." prefix in a file generated by Happy...
10:07:07 <benmos> ...it compiles fine when I use "ghc --make"...
10:07:29 <benmos> ..and also if I manually edit the Happy output to include the "Data." package qualification...
10:08:15 <benmos> ...anyone have any idea about this?
10:08:26 <Igloo> You need to build-depend on haskell98
10:08:48 <benmos> I have "Build-Depends:	base"  at the moment...
10:08:56 <benmos> ...do I need to change that?
10:11:46 <fabiim> i need a for  to do in haskell
10:11:47 <fabiim> lol
10:14:59 <benmos> Igloo: I changed to: "Build-Depends:	base -any, haskell98 ==1.0", and that seems to have resolved the issue - thanks very much!
10:16:17 <ValarQ> fabiim: for to do?
10:21:28 <fabiim> ValarQ: forget it...
10:21:28 <fabiim> lol
10:23:13 <ValarQ> done
10:24:09 <LoganCapaldo> > let for x y = map y x in for [1..5] (\i -> putStrLn $ (++) "Line no: " $ show i
10:24:09 <lambdabot>  Parse error
10:24:19 <LoganCapaldo> Or something like that
10:24:23 <LoganCapaldo> > let for x y = map y x in for [1..5] (\i -> putStrLn $ (++) "Line no: " $ show i)
10:24:24 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
10:27:21 <newsham> I dont understand why they defined "first" and "second", but then just inline (arr (\b -> (b,b))   (which I guess would be called something like "split")
10:27:34 <newsham> why doesnt that deserve a name of its own?
10:31:22 <newsham> if there was a "split" then the definition of liftA2 would read very easily
10:31:53 <newsham> err.. f &&&g would read.     split >>> (f ** g)
10:32:27 <newsham> liftA2 op f g would be    split >>> (f *** g) >>> arr (uncurry op)
10:33:02 <newsham> maybe arr . uncurry would be called "unsplit"
10:33:09 <newsham> split >>> (f *** g) >>> unsplit op
10:33:14 <newsham> something like that.
10:36:07 <newsham> or even more clearly:    split >>> first f >>> second g >>> unsplit op
10:37:04 <newsham> that seems much easier to understand to me.
10:52:38 <xerox> Yeah.
10:53:30 <xerox> split = (id &&& id)
10:53:55 <xerox> unsplit = uncurry
10:54:13 <Oejet> xerox: Those videos are great!
10:54:21 <xerox> They arrrre!
10:54:45 <eviltwin_b> hm, yi still doesn't like me, even with ghc 6.4.2.  link failure with what looks like fps
10:55:12 <newsham> f &&& g = split >>> f *** g     =     split >>> first f >>> second g
10:55:19 * eviltwin_b would not be surprised if his machine is now thoroughly confused about versions, even though he's trying to keep the 6.4.2 and 6.6 stuff separate
10:55:24 <newsham> split is more primitive than (&&&) (in my mind at least :)
10:55:26 <xerox> newsham: split = join (curry id); unsplit = uncurry
10:55:52 <newsham> arr . uncurry
10:56:30 <xerox> okay
11:06:13 <newsham> http://www.thenewsh.com/~newsham/x/arrow.txt
11:13:15 <newsham> sane?  comments?
11:15:47 <Codex_> newsham: you could give arrow implementation too
11:17:08 <Codex_> or explain runKleisli etc?
11:18:35 <newsham> yah, good ideas.  i should probably define a really simple (ie. non-monad) arrow to demonstrate the concepts.  and then at the end show the kleisli arrow briefly.
11:25:44 <LoganCapaldo> @hoogle a -> b -> a
11:25:45 <lambdabot> Prelude.const :: a -> b -> a
11:25:46 <lambdabot> Prelude.seq :: a -> b -> b
11:25:46 <lambdabot> Control.Parallel.par :: a -> b -> b
11:27:58 <xerox> newsham: please do! :)
11:32:56 <newsham> ?hoogle (a -> b) -> (a, c) -> (b, c)
11:32:58 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
11:32:58 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:33:43 <newsham> ?hoogle (a -> b) -> (c, a) -> (c, b)
11:33:44 <lambdabot> Data.Graph.Inductive.Query.Monad.mapSnd :: (a -> b) -> (c, a) -> (c, b)
11:33:44 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:34:36 <dolio> > first (+1) (3, 4)
11:34:38 <lambdabot>  (4,4)
11:49:49 <JohnMeacham_> brup
11:50:32 <dufflebunk> I have a list of tuples which I'm putting into a tree. I then search the tree for some data. However I need the tree to be constructed lazilly, and the function which builds the tree is currently sucking up the whole list and returning the whole tree.
11:51:24 <dufflebunk> I'm guessing I'm doing something pretty basic which is wrong, so if anyone has any ieas or examples it would be great
11:52:18 <spiffy> dufflebunk: why not show us in a paste what you have so far?
11:52:21 <spiffy> ?paste
11:52:22 <lambdabot> http://paste.lisp.org/new/haskell
11:52:28 <dufflebunk> Ok
11:53:59 <lisppaste2> dufflebunk pasted "fixed length field searching" at http://paste.lisp.org/display/30235
11:56:22 <dufflebunk> I thought that treeFromList would only start going through the list as needed, ie as you traverse the tree it would build it.
11:58:57 * Lemmih can't access http://paste.lisp.org/display/30235
11:59:31 <dufflebunk> hmm, neither can I now
11:59:53 <dufflebunk> I can't get to http://paste.lisp.org/ anymore
12:00:00 <pkhuong> it'll come back up soon.
12:01:11 <spiffy> i still have the paste open
12:01:23 <spiffy> ill repost it
12:01:24 <spiffy> one sec
12:01:38 <dufflebunk> ah, it's back
12:02:40 <spiffy> good stuff
12:05:20 <Lemmih> dufflebunk: Notice how 't2' doesn't return anything before it has traveled the entire list.
12:07:06 <dufflebunk> I kinda do... I was hoping it would be able to return the root node, but looking more closely, yeah, you're right.
12:09:27 <dufflebunk> Any suggestions on how to make it not do that?
12:11:19 <dufflebunk> Perhaps I can build it the opposite way..
12:16:57 <Lemmih> dufflebunk: perhaps: [] = Nil; (x:xs) = Node x (treeFromList (filter (<x) xs)) (treeFromList (filter (>x) xs))
12:18:34 <dufflebunk> I was thinking about that... I'm still not too sure about the IO stuff, the list comes from a file. But I'd might as well try it and see
12:18:45 <Lemmih> @type partition
12:18:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:19:49 <newsham> OK, updated the arrow.txt with a concrete simple example and a Kleisli example
12:20:11 <newsham> also its now runnable as .lhs as it should be.
12:20:26 <newsham> if anyone knows why I'm getting weird type problem mentioned at the bottom, please let me know
12:32:59 <dufflebunk> Woohoo! It worked. Thanks Lemmih
12:38:34 <desrt> ?type bind
12:38:36 <lambdabot> Not in scope: `bind'
12:38:44 * desrt raises an eyebrow
12:38:47 <desrt> ?hoogle bind
12:38:48 <lambdabot> Network.Socket.bindSocket :: Socket -> SockAddr -> IO ()
12:38:48 <lambdabot> Language.Haskell.TH.bindS :: PatQ -> ExpQ -> StmtQ
12:38:48 <lambdabot> System.Console.Readline.bindKey :: Char -> Callback -> IO ()
12:38:59 <desrt> ...
12:39:02 <Lemmih> ?type (>>=)
12:39:03 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
12:39:22 <desrt> it doesn't exist by name?
12:39:34 <Lemmih> Not to my knowledge.
12:40:46 <astrolabe> if drawingAreaGetSize returns (xSz,ySz), what is the set of valid pixels?
12:41:22 <araujo> Hello!
12:41:29 <dufflebunk> Hello araujo
12:41:54 <Lemmih> ?users
12:41:55 <lambdabot> Maximum users seen in #haskell: 270, currently: 263 (97.4%), active: 38 (14.4%)
12:42:56 <desrt> ?hoogle unsafePerformIO
12:42:57 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
12:43:08 <newsham> xerox alive?
12:43:20 <xerox> yep
12:43:49 <newsham> also codex.
12:43:58 <newsham> I updated arrow.txt.
12:43:59 <Daveman> xerox :D
12:44:53 <xerox> newsham: yuck, GHC allows Arrow (->) :)
12:45:13 <newsham> is that what is causing the type ambiguities for liftA2?
12:45:20 <xerox> It is possible.
12:45:59 <desrt> ?hoogle IORef
12:46:00 <lambdabot> Data.IORef :: module
12:46:00 <lambdabot> Data.IORef.IORef :: data IORef a
12:46:00 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
12:47:23 <desrt> debugging haskell programs can become truly evil....
12:47:33 <fabiim> i need to check out if a string contains only words that i have in a list of strings , any hints on a good approach  to the problem ?
12:48:24 <newsham> all [word in wordlist | word <- eachWord inputString]    ?
12:48:24 <mwc> ?type words
12:48:26 <lambdabot> String -> [String]
12:49:14 <fabiim> what's the all?
12:49:25 <newsham> ?type all
12:49:26 <mwc> all [True, True, False]
12:49:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:49:31 <mwc> > all [True, True, False]
12:49:32 <lambdabot>  Couldn't match `a -> Bool' against `[a1]'
12:49:51 <newsham> hmm.. didnt quite get that right :)
12:49:59 <mwc> I think we were looking for and?
12:50:03 <mwc> ?type and
12:50:04 <lambdabot> [Bool] -> Bool
12:50:05 <newsham> yes, probably
12:50:11 <newsham> but all is still useful :)
12:50:40 <newsham> all (`in` wordlist) (eachWord inputString)
12:50:45 <newsham> something like such
12:50:55 <mwc> let's see, there are n words in the input string, and m in the safe list... that's n*m complexity
12:50:56 <newsham> where "eachWord" is probably "words"
12:51:14 <fabiim> words (of the wordlist)
12:51:17 <fabiim> right?
12:51:27 <mwc> > words "Your mother wears army boots."
12:51:28 <lambdabot>  ["Your","mother","wears","army","boots."]
12:51:37 <fabiim> ok
12:51:40 <mwc> probably want to strip punctionation as well.
12:51:45 <newsham> are we doing your homework?
12:51:52 <fabiim> lolol
12:51:56 <fabiim> no ! part of it
12:52:02 <fabiim> it's a work for college
12:52:15 <fabiim> i'm trying to break viginiere cipher
12:52:43 <fabiim> so i need to test if each guess contains only the words allowed
12:52:50 <fabiim> if so , i have found the key
12:53:16 <fabiim> but i have been playing around with lists comprehensions  and filter
12:53:25 <fabiim> and i only got a huge mess till now
12:53:39 <fabiim> i'm trying to get new ideias...
12:54:13 <Cufisz> I've been struggling trying to write a Class that would contain a function that "extracts" a data member. The major problem is with defining the type of the function. I've pasted very simplified code here (http://www.rafb.net/paste/results/yCyZ2v16.html) if anyone's interested.
12:54:47 <fabiim> but your solution doesn't work too ... i can't check the word in a wordlist
12:55:18 <fabiim> i have a text like ONETOOTREE
12:55:53 <fabiim> i guess i will have to go for the character by character approach ... but that seems so C (imperative)
12:56:08 <dylan> Doesn't have to be.
12:57:41 <fabiim> well I was thinking to unwords the list of words
12:58:52 <fabiim> and then filter every  character wich belongs to that (lists of words)
12:58:59 <fabiim> in the input text
12:59:09 <fabiim> does that make sense?
13:03:23 <newsham> ?hoogle [a] -> a -> Bool
13:03:24 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
13:03:24 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
13:03:41 <newsham> > elem "test" (words "this is a test")
13:03:42 <lambdabot>  True
13:03:48 <newsham> > elem "test" (words "this isnt")
13:03:49 <lambdabot>  False
13:04:44 <newsham> > all (`elem` (words "foo bar baz")) (words "foo foo bar foo")
13:04:45 <lambdabot>  True
13:04:55 <newsham> > all (`elem` (words "foo bar baz")) (words "foo foo bar not foo")
13:04:56 <lambdabot>  False
13:04:59 <newsham> make sense?
13:06:55 <newsham> fabiim?
13:07:05 <fabiim> i'm reading and testing wait
13:07:06 <fabiim> lol
13:08:17 <newsham> (`elem` w) is just (\x -> x `elem` w)    btw, if you're not familiar with that notation
13:08:19 <fabiim> well that makes sense
13:09:00 <fabiim> but
13:09:36 <fabiim> my strings it's like "ONETOOASJADK" elem "ONE" to that won't work.
13:10:04 <integral> :t isInfixOf
13:10:05 <newsham> that seems like a much harder problem (a knapsack problem?)
13:10:23 <fabiim> knapsack is what?
13:11:00 <newsham> knapsack is "here's a bag of numbers, find a combination from this bag that adds up to X"
13:11:15 <fabiim> oh
13:11:17 <fabiim> right
13:12:06 <newsham> i think your problem is an exponential problem.
13:12:19 <newsham> if you dont care about efficiency, though, there's probably a pretty easy solution in haskell.
13:12:36 <fabiim> what?
13:12:53 <newsham> for example,  if "TOO" is in "ONETOOASJADK" then remove it and split up into "ONE" and "ASJADK" and recurse
13:13:15 <newsham> if that works, you have an answer.  if that fails, try without taking out "TOO" (or taking out "TOO" somewhere else in the string, perhaps)
13:13:16 <fabiim> i care about efficiency tough , i'm brute-forcing a ciphertext (tough it's a really wek cipher)
13:13:28 <ihope> Cufisz: have you tried "class Class a b | a -> b where"?
13:13:46 <Cufisz> Problem solved:
13:13:48 <Cufisz> http://cvs.haskell.org/Hugs/pages/hugsman/exts.html
13:13:51 <lambdabot> http://tinyurl.com/y7bxf6
13:13:52 <newsham> fabiim: maybe there's a cheaper, less sound strategy you can use that works almost as well?
13:13:55 <Cufisz> umm no i haven't
13:14:03 <Cufisz> hehe, but i just think i solved my problem
13:14:09 <Cale> hmm, there may be more than one way to break the string up into permitted words -- or perhaps only one way to do it completely, so you need nondeterministic parsing :)
13:14:23 <Cufisz> ihope, http://www.rafb.net/paste/results/qssSaY49.html
13:14:46 <Cufisz> ihope, i'm not quite familiar with the | a -> b, but i'm reading about it right now
13:14:47 <newsham> you just need something which rejects the bulk of the candidates
13:14:49 <Cufisz> thanks
13:15:00 <fabiim> and nondeterministic parsing is what?
13:15:00 <Cale> ah, okay :)
13:15:18 <Cale> I was thinking you really needed to check definitively
13:15:20 <newsham> he means a parser which tries all possible combinations
13:16:06 <xerox> ?type (. isPrefixOf) . flip any . tails
13:16:07 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
13:16:12 <fabiim> of input text's ? there are infinities combinations
13:16:22 <Cale> Say, if you have TOO and TO along with ONE and THREE in your word list, TOONETHREE
13:16:35 <Cale> no, there are usually a fairly small number
13:17:03 <Cale> So here, if the start of the string matches a word, it's TOO or TO
13:17:08 <newsham> for each word : for each match in string : split string by removing match, if strin gis empty we're done, otherwise recurse into both halfs
13:17:30 <Cale> if we try TOO first, we'll end up getting stuck
13:17:45 <Cale> Because the rest of the string is NETHREE
13:18:14 <newsham> alternately:    for each string: if prefix match, discard prefix, if empty string done, else recurse
13:18:20 <fabiim> newsham: removing match  , can i do that easy if the match isn't in the beginning of the string?
13:18:31 <fabiim> Cale:
13:18:38 <newsham> you can do matching entirely at the start of the string if you want
13:18:50 <newsham> since, if the entire string is made up of words, then the prefix must be a word.
13:18:56 <fabiim> Cale:  I will have to check it's WORD then take it away , then checking the next word right?
13:19:10 <newsham> fabiism: this may be pretty inefficient though.
13:19:20 <Cale> fabiim: but you have to branch out if there's more than one word at the start
13:19:31 <newsham> you'll have to check  "header" against "he", then "head" then "header"
13:19:32 <fabiim> brach out?
13:19:37 <newsham> exponential search problem.
13:19:37 <fabiim> brench out?
13:19:50 <Cale> try both, and accept if either one works
13:20:26 <Cale> that is, in this case, you'd want to see if it's TO or if it's TOO
13:20:38 <Cale> since both of those words are prefixes
13:20:39 <newsham> a string is made up entirely of words if the prefix is a word and the remaining string after the prefix is made up of words.
13:20:53 <newsham> there may be many prefixes which are words.
13:21:00 <newsham> there's your entire problem description :)
13:21:30 <fabiim> well i could just check if the firs word is [ZERO..NINE] if yes take it away and check the rest of it
13:21:32 <fnord123> anyone here run fastcgi with haskell?
13:21:48 <eviltwin_b> right, so you match and delete leading words until you're left with an empty string (success) or a nonempty string that has no prefix (fail), with backtracking
13:22:06 <Tzintzi> where can I find the easiest tutorial for haskell ?
13:22:08 <newsham> eviltwin_b ++
13:22:13 <fik> @type (\y z f g h x -> (y ((f g) h)) ((z (g h)) x))
13:22:14 <lambdabot> forall t t1 t2 t3 t4 t5. (t -> t3 -> t5) -> (t1 -> t4 -> t3) -> ((t2 -> t1) -> t2 -> t) -> (t2 -> t1) -> t2 -> t4 -> t5
13:22:31 <newsham> tzintzi: www.haskell.org has a getting started tutorial.  it references other tutorials as well
13:22:36 <fabiim> well going to play around then ...
13:22:44 <newsham> i'm partial to "two dozen short lessons" myself.
13:22:53 <Cale> fabiim: you could, if those are the only words you care about
13:22:58 <Cale> @where yaht
13:22:59 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
13:23:30 <fnord123> I recommend YAHT, Tzintzi. I'm learning with haskell as well and yaht has been really helpful for me
13:23:34 <Cale> Yet Another Haskell Tutorial is decent, if a little incomplete -- it's on a wiki now, we should edit it :)
13:24:09 <fabiim> Cale:  yes they are , i guess i was thinking much , it seems easy now ...
13:24:10 <fabiim> lol
13:24:23 <encryptio> how do i pass a new function to subtract 10 from the first argument? (-10) doesn't work because - is being parsed as an unary operator (type (Num a) => a -> a) rather than binary (type (Num a) => a -> a -> a)
13:24:26 <fik> @hoogle forall t t1 t2 t3 t4 t5. (t -> t3 -> t5) -> (t1 -> t4 -> t3) -> ((t2 -> t1) -> t2 -> t) -> (t2 -> t1) -> t2 -> t4 -> t5
13:24:29 <lambdabot> Did you mean: Forall t T1 T2 T3 T4 T5. (t -> T3 -> T5) -> (T1 -> T4 -> T3) -> ((T2 -> T1) -> T2 -> t) -> (T2 -> T1) -> T2 -> T4 -> T5
13:24:42 <Tzintzi> fnord123, I'm a real idiot. So i'll need the 'Complete idiot's guide'
13:24:45 <Cale> encryptio: (+(-10)) or (subtract 10)
13:24:45 <fik> @hoogle Forall t T1 T2 T3 T4 T5. (t -> T3 -> T5) -> (T1 -> T4 -> T3) -> ((T2 -> T1) -> T2 -> t) -> (T2 -> T1) -> T2 -> T4 -> T5
13:24:46 <lambdabot> No matches found
13:24:47 <newsham> > (subtract 10) 20
13:24:49 <lambdabot>  10
13:25:19 <fnord123> Tzintzi: thankfully the ghc compiler errors explain what you did wrong and spell out how to fix a lot of newbie mistakes. you just need to take the time to read them
13:25:38 <fnord123> (I come from mostly c++ where the errors can be completely useless or lies)
13:25:59 <encryptio> Cale: thanks
13:26:32 <Cale> fnord123: yeah, usually if you get a bunch of errors from GHC, they're all separate problems too
13:27:05 <fik> @hoogle Forall t T1 T2 ((T2 -> T1) -> T2 -> t)
13:27:06 <lambdabot> No matches, try a more general search
13:27:18 <fik> @hoogle Forall T1 T2 (T2 -> T1) -> T2
13:27:19 <lambdabot> No matches, try a more general search
13:27:25 <fnord123> also, a lot of my experience starting with c++ was with msft vc6 which...
13:27:33 <fik> @hoogle (a -> b) -> a
13:27:34 * fnord123 begins to sob like a rape victim
13:27:35 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
13:27:35 <lambdabot> Control.Monad.State.gets :: MonadState s m => (s -> a) -> m a
13:27:35 <lambdabot> Control.Monad.Writer.listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
13:27:58 <Cale> fnord123: haha, I used VS6 way back when too :)
13:28:18 <eviltwin_b> how does it compare to error messages involving the STL? :)
13:28:36 <newsham> STL errors arent so bad if you have an STL-error-postprocessor ;-)
13:28:40 <Cale> The STL in VC++ was completely broken in various subtle ways
13:28:52 <fnord123> remember forgetting the ; at the end of a class? the error message would point out the cpp file; or point out another .h file and say it was expecting a ; on the first line of the include
13:29:17 <Cale> Not to mention the implementation of templates.
13:29:46 <fnord123> to this day i still say stuff to colleagues about "oh you can't really specialise a function... no wait. maybe that was vc6. :( "
13:29:49 <pkhuong> Cale: yeah, templates in general seem to be broken in VC++.
13:29:57 <fik> @bf f**k
13:29:58 <lambdabot> Done.
13:30:05 <newsham> fnord: thats all dependant on the compiler.  there's nothing saying a compiler couldnt mention the file that started the context requiring a semicolon.
13:30:12 <Cale> I found it amazing that any software at all got written in C++ for windows.
13:30:47 <newsham> you underestimate the human capacity to face adversary :)
13:30:49 <Cale> What I'd mostly used before that for GUI windows applications was Borland Delphi, and while it wasn't perfect, it was a lot saner. :)
13:30:51 <fnord123> newsham: I'm specifically talking about the vc6 compiler
13:31:15 <Philippa> Delphi was in many ways a niche product though
13:31:40 <Philippa> and Borland's libs came with their own look and feel, stuff like that
13:32:01 <integral> and it came with Borland's horrible database :-(
13:32:14 <Philippa> I didn't know them well enough to know how much there was that was still easier to achieve in C++ - VB was full of stuff where if it didn't do what you wanted then welcome to hell
13:32:43 <Excedrin> are there any free gui builders that approach Delphi's functionality?
13:33:25 <newsham> adversity?  hmm.. cant think.
13:35:39 <eviltwin_b> "adversity"
13:39:47 <LoganCapaldo> Excedrin: Besides Delphi?
13:40:39 <Cale> There's glade
13:41:12 <Cale> http://glade.gnome.org/screenshots.html
13:41:13 <lambdabot> Title: Glade - Screenshots
13:41:22 <LoganCapaldo> (Unless you meant free with a capital "F")
13:41:23 <newsham> in my experience its usually easier (and more powerful) to write gtk code directly than use glade
13:41:45 <newsham> (at least in a sane language.  gtk in C is such a chore that glade easily wins there)
13:41:46 <LoganCapaldo> {H,V}Boxes for the win
13:41:56 <Cale> It's handy in Haskell.
13:42:13 <mwc> There's an article I read a while ago that mentions why GUI builders are harmful
13:42:13 <newsham> i've done a bit in python (pygtk).  glade was more hassle than help
13:42:52 <mwc> http://weblogs.java.net/blog/johnreynolds/archive/2005/07/gui_builders_co.html and the article linked in the first sentence
13:42:56 <Cale> Remember that you don't have to set up every little thing. If there's something which is easier to add as code, you can still do it.
13:42:57 <lambdabot> Title: John Reynolds's Blog: GUI Builders Considered Harmful, http://tinyurl.com/tn6b3
13:43:24 <newsham> i'm aware.  for one applicaiton, my coworker did the framework in glade and I coded the rest directly.
13:43:40 <newsham> it woulda been easier to just do the whole thing directly though
13:43:55 <newsham> but i wasnt going to redo it just for the sake of redoing it
13:44:12 <Cale> Why in particular?
13:44:14 <ibid> http://meyerweb.com/eric/comment/chech.html
13:44:15 <lambdabot> Title: "Considered Harmful" Essays Considered Harmful
13:44:44 <newsham> because it was just so easy to build things in pygtk.  it was more work to fire up glade, do the layout, then go back to python and hook-up to the appropriate pieces.  and less modular.
13:45:08 <Cale> less modular?
13:45:12 <newsham> and if you decided later to add some dynamic features, its easy to add to py code, but you have to undo glade if its in glade.
13:45:22 <Cale> I found it nice that I could work on the interface without touching the code.
13:45:32 <newsham> well, less modular if you have one (or a small number) of glade guis defined.
13:46:02 <newsham> yah, see, if i was working with a team that had good artistic people who would do all the tweaking, then i twoulda been a good separation to let them tweak without affecting code.
13:46:47 <newsham> so i guess i'll buy that glade can be good for that purpose
13:47:15 <newsham> usually i'm working alone or with one or two other programmers...
13:47:33 <Volatile> hmm, is there a standard way to convert an Int to a Double? Read.Show seems a little stupid...
13:47:47 <Cale> I've always found window-construction code as some of the most painful code to have to write.
13:47:55 <integral> fromIntegral is your friend, Volatile :)
13:48:11 <Volatile> nope, it hates me because Int is not an Integral =/
13:48:17 <integral> pardon?
13:48:18 <Cale> yes it is
13:48:26 <Cale> > fromInteger (5 :: Int) :: Double
13:48:27 <Volatile> my GHC disagrees
13:48:27 <lambdabot>  Couldn't match `Integer' against `Int'
13:48:31 <newsham> i think its pretty easy, but tedious in that you constantly want to tweak the constants.
13:48:31 <Cale> > fromIntegral (5 :: Int) :: Double
13:48:32 <integral> Volatile: Who told you that?
13:48:33 <lambdabot>  5.0
13:48:40 <integral> Volatile: Your GHC is broken.
13:48:47 <Volatile> =/
13:48:55 <Cale> what's the error message?
13:49:02 <newsham> i dont much care for writing gui code, and dont do it very often.
13:49:08 <Cale> perhaps you could paste some code which causes the problem?
13:49:11 <Volatile> fromInteger :: (Num a) => Integer -> a
13:49:27 <integral> Volatile: Since when has fromInteger been the same as fromIntegral?
13:49:29 <Cale> fromIntegral :: (Integral a, Num b) => a -> b
13:49:31 <LoganCapaldo> > fromIntegral 1 :: Double
13:49:32 <lambdabot>  1.0
13:50:00 <Volatile> integral, hehe, my bad
13:50:25 <Volatile> Seems this is one of those illiterate days...
13:52:44 <Cale> the repetition problems which http://www.hacknot.info/hacknot/action/showEntry?eid=76 is citing don't happen with Glade, because you lay out the repeated part, and the surrounding framework separately, then just load the part multiple times from the code.
13:52:46 <lambdabot> Title: Hacknot - Beware The GUI Builder, http://tinyurl.com/d6f7p
13:53:08 <Cale> also, you don't generate code, that's the stupid way to do it
13:53:31 <Cale> You store your interface templates in files.
13:53:48 <ibid> you could generate code. the stupid thing is to generate code *for editing*
13:54:08 <ibid> any generated code should be treated as opaque and uneditable
13:54:12 <newsham> but code isnt xml!
13:54:13 <Cale> yeah
13:54:22 <LoganCapaldo> You're all fools. I manually create my glade xml files
13:54:29 <Cale> haha
13:54:33 <LoganCapaldo> It is the best of both worlds
13:54:45 <Philippa> newsham: exactly, XML is data and so's the GUI layout
13:55:02 <newsham> unless data is code.
13:55:30 <Philippa> here, have a lisp
13:55:35 <fik> scheme
13:55:38 <LoganCapaldo> (xml (looks (nothing like code)))
13:56:12 <fik> undefined variable xml
13:56:39 <ibid> no, undefined variable nothing
13:56:43 <ibid> lisp is applicative
13:57:05 <ibid> or should i say, undefined variable like?
13:57:10 <fik> yes. i suposed my scsh was refering to xml
13:57:43 <LoganCapaldo> Wise man once said, "Running joke code examples results in error messages"
13:58:02 <fik> ?quote wise man
13:58:03 <lambdabot> wise man hasn't said anything memorable
13:58:21 <newsham> > let con x xs True = x; con x xs False = xs in (con 5 $ con 6 $ con 7 8) False True
13:58:22 <lambdabot>  add an instance declaration for (Num (Bool -> t))
13:59:31 <pkhuong> ibid: the evaluation order of function and arguments is undefined in scheme.
13:59:42 <fabiim> hoogle : a function that take n elements from the head of the list and returns the rest
13:59:55 <fabiim> =) you guy's should be faster...
14:00:09 <ibid> pkhuong: and what makes you think i was talking about scheme? :)
14:00:15 <ibid> pkhuong: but still, point
14:06:27 <LoganCapaldo> > let f n xs = if n == 0 then xs else (f (n - 1) (tail xs)) in f 2 [1,2,3,4]
14:06:29 <lambdabot>  [3,4]
14:06:54 <shapr> blackdog: y0
14:07:17 <newsham> i was trying to represent the list as a function, except i made a booboo (infinite type)
14:14:59 <hyrax42_> ?type guard
14:15:00 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:16:07 <hyrax42_> > Just 0 >>= guard.fmap.(>0)
14:16:08 <lambdabot>  Couldn't match `a -> b' against `Bool'
14:16:20 <hyrax42_> > Just 0 >>= guard.(fmap (>0))
14:16:21 <lambdabot>  Couldn't match `Bool' against `f b'
14:17:12 <hyrax42_> *sigh*
14:17:31 <hyrax42_> > do { x <- Just 0; guard $ x > 0; return x}
14:17:32 <lambdabot>  Nothing
14:17:56 <hyrax42_> > do { x <- Just 12; guard $ x > 0; return x}
14:17:58 <lambdabot>  Just 12
14:18:08 <hyrax42_> > do { x <- Nothing; guard $ x > 0; return x}
14:18:10 <lambdabot>  Nothing
14:24:20 <durdn> hi all, I am a bit of a newbie with Haskell, I am having problem with readPrec, ReadS and the like
14:25:24 <durdn> I have a data structure like the following:
14:25:35 <durdn> data Entry = Session {date::Date, site::Site, duration::Minutes, limit::String, balance::Float}
14:25:36 <durdn>            | Deposit {date::Date, site::Site, balance::Float}
14:25:36 <durdn>            | Withdrawal {date::Date, site::Site, balance::Float} deriving (Show, Read)
14:25:59 <durdn> and a type like this
14:26:00 <durdn> type Diary = [Entry]
14:26:41 <durdn> I am trying to write something that will parse a String into a Diary and I am going crazy :)
14:27:19 <LoganCapaldo> @help paste
14:27:19 <lambdabot> paste. Paste page url
14:29:40 <durdn> i am able to read a single Entry no problem:
14:30:14 <durdn> HStats> head td
14:30:14 <durdn> Session {date = "05/01/2006", site = "ubet", duration = 60, limit = "d", balance = 600.0}
14:30:14 <durdn> HStats> read (show $ head td)::Entry
14:30:14 <durdn> Session {date = "05/01/2006", site = "ubet", duration = 60, limit = "d", balance = 600.0}
14:31:03 <durdn> but I am at a total loss to write the correct readPrec to parse [Entry]
14:33:24 <Lemmih> How about: read (show td) :: [Entry]?
14:33:46 <durdn> let me try :)
14:34:32 <durdn> hey, it didn't crash
14:34:45 <durdn> cool
14:34:51 <Lemmih> (:
14:35:06 <durdn> so I didnt need readPrec
14:35:15 <durdn> thanks a lot Lemmih
14:37:13 <kzm_> @seen
14:37:14 <lambdabot> Lately, I have seen durdn, dylan, kzm_, lemmih, logancapaldo and salty-horse.
14:37:40 <dylan> me?
14:38:06 <_matthew-> how good is ghc at constant propogation?
14:38:44 <_matthew-> will it create specialised curried functions if it detects they're always invoked with the same values?
14:39:11 <kzm_> dylan, at least, now.
14:45:18 <heatsink> Is there a CPS monad, something like CPS m a = CPS (a -> m (CPS m a))
14:45:21 <heatsink> ?
14:45:53 <heatsink> (Maybe CPS isn't the right name for it)
14:46:19 <Cale> there's http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
14:46:23 <lambdabot> http://tinyurl.com/vp4ok
14:46:58 <LoganCapaldo> heatsink: Perhaps this can help http://en.wikibooks.org/wiki/Talk:Haskell/Continuation_passing_style
14:47:02 <lambdabot> http://tinyurl.com/wqq5f
14:47:05 * heatsink tries to remember how callcc works
14:47:52 <heatsink> ah, that's right.  So this isn't really CPS, it's more of an... incremental computation, I guess.
14:48:23 <heatsink> It's meant to represent an event-driven process that responds to input (a) with some action, then waits for more input.
14:51:01 <Lemmih> _matthew-: You can ask GHC.
14:52:43 <heatsink> What would this moand be called... ConsumerT, perhaps?
14:55:29 <twanvl> How would return work in that monad?
14:58:33 <_matthew-> Lemmih: any pointers?
14:58:35 <_matthew-> Lemmih: or do you mean the dump-simpl stuff?
14:58:37 <_matthew-> (sorry, connection dropped)
14:58:44 <heatsink> Ah, it can't because it always has to have a 'next' computation as written... Perhaps it should produce an Either, with Left as the return type.
15:04:25 * heatsink goes to think about it some more
15:15:08 <dons> moin
15:15:12 <dons> ?users
15:15:12 <lambdabot> Maximum users seen in #haskell: 275, currently: 271 (98.5%), active: 39 (14.4%)
15:15:17 <dons> oh!
15:16:34 <dcoutts> @arr
15:16:35 <lambdabot> Har de har har!
15:17:30 <dons> dcoutts: seen Claus Reinke's fusible cons idea?
15:17:56 <dcoutts> not yet
15:18:10 * dcoutts just returned from an all-weekend party
15:18:17 <dons> we do have fusible cons in the stream unstable branch though
15:18:20 <dons> i guess he didn't look there
15:24:55 <shapr> dons: Was that in ghc-users?
15:25:55 <dons> on glasgow-haskell-users@, yeah
15:26:15 <dons> dcoutts: oh, I think Roman pointed out that using bools here breaks specConstr
15:26:17 <dons>     consS w (Stream nextx xs0 len) = Stream next' (True :*: xs0) (len+1)
15:26:17 <dons>       where next' (True  :*: xs) = Yield w (False :*: xs)
15:26:17 <dons>             next' (_     :*: xs) = case nextx xs of
15:26:19 <dons>                 Done        -> Done
15:26:22 <dons>                 Skip xs'    -> Skip    (False :*: xs')
15:26:24 <dons>                 Yield x xs' -> Yield x (False :*: xs')
15:26:31 <dcoutts> dons, yes, that's right.
15:26:43 <dcoutts> we have to use Either to take advantage of specConstr
15:26:50 <dons> yep
15:34:03 <shapr> @index specConstr
15:34:04 <lambdabot> bzzt
15:34:11 <shapr> @google specConstr filetype:hs
15:34:15 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/main/DriverState.hs
15:34:16 <lambdabot> Title: CVS log for fptools/ghc/compiler/main/Attic/DriverState.hs
15:34:36 <dons> clever
15:39:01 <dylan> note to self, do not ask about bugs in freenode channels.
15:39:26 <shapr> ?
15:39:32 <shapr> dylan: wot appen?
15:39:55 <dylan> not much, just the ion author got a bit upset with me, I think.
15:40:05 <dons> tuomov?
15:40:09 <dons> ?seen tuomov
15:40:09 <lambdabot> I saw tuomov leaving #darcs 1m 7d 5h 32m 17s ago, and .
15:40:35 <dylan> yeah. I guess I should've just used the mailing list.
15:40:54 <ndm> i have got loads of bug reports on IRC
15:40:55 * shapr shrugs
15:41:07 <shapr> Tuomov gets upset. But he gets over it after a few months.
15:41:19 <dylan> Heh.
15:41:46 <dylan> meanwhile, I just need to figure out how to resize windows from lua, and wait for the next release of ion3.
15:41:47 <dons> dylan: join the dwm revolution! :)
15:41:50 <shapr> He used to hang out on #haskll a lot.
15:41:52 <dons> (or wmii)
15:42:06 <dylan> dons: well, I like the way ion looks and behaves.
15:42:11 <dons> mmm peaches. tastes like summer!
15:42:19 <shapr> After the most recent changes in ion3 blowing away all my config files, I think today is a good time to try dwm and wmii
15:42:23 <dylan> just because I changed every single key binding...
15:42:27 <shapr> Which one is more Haskell friendly?
15:42:30 <shapr> dylan: me too
15:42:39 <dylan> shapr: Ah, those were easy to fix
15:42:42 <shapr> But the latest debian/unstable blew away all my bindings...
15:42:48 <dons> shapr: oh, wmii is probably easier on haskell. i actually wrote an entire wmii core in haskell
15:42:51 <dons> its around here somewhere
15:42:53 <shapr> oh?
15:42:54 <dons> but i like dwm more now
15:43:01 <dons> its very small and light
15:43:11 <dylan> dwm doesn't seem to support dual head displays
15:43:42 <dylan> And I need a statusbar that swallows kde systray items.
15:44:12 <newsham> is it possible to make a haskell.org wiki page which is literate haskell code?
15:44:20 <shapr> I'd like that.
15:44:36 <shapr> Especially if I could do lhs2TeX wiki pages and create inline graphics.
15:47:25 <newsham> i put up my arrows tutorial on the wiki.  It was literate, now its just almost-literate.
15:48:56 <ndm> newsham: cool (I'm Neil on email, who you just emailed)
15:49:00 <dons> one thing about dwm is that since the config file is cpp, you tend not to want to change the keybindings from the default
15:49:12 <newsham> ndm: hi!  thanks for the help.
15:49:25 <dons> at least I found that upgrading from dwm 1.0,1.1...2.0 I quickly stopped bothing with my own config.h's
15:49:32 <ndm> newsham: why not put your > -- stuff as just "stuff", in Haskell blocks without the leading >
15:49:45 <ndm> newsham: that way you still get syntax hilighting on the other bits
15:50:04 <newsham> good idea.
15:51:51 <newsham> done.
15:52:01 <dons> I must admit that when I see a headline "Which Lisp?" I think to myself "Use Haskell"
15:52:09 <ndm> hehe
15:53:45 <drakioned> did anyone see the Lambda Man at Fun in the Afternoon in Oxford?
15:53:49 <olliej> dons: real people write code in bcpl :D
15:53:55 <psnl> drakioned: heh
15:54:10 <ndm> drakioned: yep :)
15:54:29 <drakioned> I have a nice photo :) happened to have an SLR with me at the time
15:54:33 <psnl> drakioned: argh, yet more hordes from nott.ac ;-)
15:54:53 <dons> dcoutts, ndm: any feedback/ideas on a mkcabal/joincabal tool that creates new cabalised/darcsised projects automagically?
15:55:16 <sjanssen> there is a Lambda Man?  Any pictures?
15:55:17 <ndm> dons: a great idea, the point is that its necessary to have teh user find it and invoke it easily
15:55:32 <sjanssen> can he leap tall closures in a single bound?
15:55:39 <drakioned> sjanssen: yes, let me find an appropriate place to upload it
15:55:48 <sjanssen> faster than a speeding y combinator?
15:56:01 <ndm> dons: i intend to add a Cabal tab to GuiHaskell once dcoutts has got the threading working ( ;) ), which will provide that feature (either through a library, stealing your code, or doing it myself) with appropriate GUI/wizard to set the options
15:56:09 <dons> ndm, so two things. 1) if its useful, we should bundle it with cabal (along with a default setup executable), and 2) i guess a full command line interface would be a good idea so that a gui can call it
15:56:19 <dons> sjanssen++ unfoldr suggestion
15:56:25 <dons> unfoldr++
15:56:28 <psnl> ndm: threading? whats the problem?
15:56:29 <Igloo> I hear he is vulnerable to omeganite, though
15:56:34 <dons> oh!
15:56:41 <sjanssen> unfoldr++ You're under rated
15:56:47 <shapr> @karma unfoldr
15:56:48 <lambdabot> unfoldr has a karma of 5
15:56:55 <ndm> but my idea was that you take a working project, and auto create a .cabal file for it - but anything is good
15:56:56 <dcoutts> dons, yeah, I suspect that would either have to be included in an IDE or with cabal/ghc for it to be useful, otherwise there's a bootstrapping problem.
15:57:01 <shapr> Igloo introduced me to the joys of unfoldr years ago.
15:57:04 <ndm> dons: a command line interface = ugly, a library would be better
15:57:04 <Igloo> dons: Wouldn't a GUI be better off calling a library?
15:57:12 <dons> dcoutts: well, runhaskell mkcabal.hs works :)
15:57:22 <dons> ok ok
15:57:24 <dons> library!
15:57:24 <dcoutts> dons, ok fair enough
15:57:26 <newsham> McCabal?
15:57:29 <ndm> psnl: its all screwed is the problem, locks and threads and crying...
15:57:33 <newsham> O'Haskell
15:57:34 <drakioned> sjanssen: http://www.mycorneroftheweb.co.uk/lambda/lambdaman.jpg
15:57:37 <lambdabot> http://tinyurl.com/yewy9f
15:57:44 * Igloo is also slightly nervous about it declaring the licence to be BSD3 without asking
15:57:53 <sjanssen> drakioned: nice
15:57:55 <dons> oh, that's just a random default.
15:58:01 <dons> the idea would be to try to work out something reasonable
15:58:11 * xerox is feeding his Roman numerals to a poor soul in #haskell.it
15:58:14 <dons> and actually dump the license in the dir as well.
15:58:19 <xerox> (the type-system ones)
15:58:33 <dons> xerox: is lambdabot2 working ok?
15:58:35 <ndm> xerox: have you seen the javascript roman numerals?
15:58:41 <xerox> dons: yep
15:58:46 <xerox> ndm: nope
15:59:29 <Igloo> dons: What do you mean by "reasonable"?
15:59:35 <dons> ask the user
15:59:49 <Igloo> OK, cool
15:59:49 <dons> or at least print some options and encourage them to pick one
15:59:54 <xerox> he asked me: "so, if I take a value of type I (I a) ..."
15:59:58 <ndm> dons: once its a GUI, a default and a drop down box makes it perfectly easy
16:00:01 <dons> (I just went for the most free license., but its arbitrary)
16:00:07 <xerox> "sorry, there is no value of type I a, beside underfined."
16:00:15 <ndm> xerox: http://www.golubovsky.org/repos/Echo_20061119_sat.html
16:00:19 <lambdabot> Title: Echo, http://tinyurl.com/ukdpg
16:00:21 <sjanssen> xerox: maybe there should be a #haskell.typeclasses -- they're practically another language ;)
16:00:27 <xerox> sjanssen: yarr :)
16:00:27 <dons> :)
16:00:31 <dons> instance #haskell It
16:00:37 <xerox> #haskell-overflow or ##logic is fine :)
16:00:41 * Igloo just doesn't want people not realising they are giving away rights (although if they don't realise then maybe they aren't, and argh!)
16:01:36 <xerox> ndm: that page loads up blank here O-o
16:01:44 <ndm> xerox: safari?
16:01:47 <xerox> yes
16:02:06 <dons> Igloo: also, how do you feel about the --init-project code, which create stub .hs files, license files, readmes. and if darcs is present darcs init and darcs add ?
16:02:10 <ndm> yeah, currently doesn't work on safari, although its being worked on
16:02:22 <sjanssen> does it work in Konqueror?
16:02:43 <ndm> dons: not that useful, i don't want a license, or a readme, i can type darcs add on my own and a stub .hs is so short (main = ...) that its almost irrelevant
16:02:51 <ndm> dons: but the complex cabal file is really handy
16:02:58 <ndm> sjanssen: yes, weirdly enough
16:03:48 <Igloo> dons: Well, I don't have anything against it
16:04:03 <xerox> oh cool.
16:04:10 <xerox> I only accept valid roman numerals as types.
16:04:16 <dons> I thought it might be useful to create the stub Tests.hs with a basic QuickCheck property
16:04:17 <xerox> I'm smarter than I thought!
16:04:27 <dons> and with a darcs hook to call the quickchecks on commit
16:04:35 <newsham> xerox: congrats.
16:04:41 * xerox hugs himself
16:04:42 <dons> if that kind of thing is setup by default, it will help out the beginners
16:04:44 <norpan> xerox: that's something you don't notice every day
16:04:59 <dons> ndm, Igloo, feedback on the 'structure' described here http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
16:05:02 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yy6xkk
16:05:03 <dons> would be really useful
16:05:17 <Igloo> dons: It sounds like maybe it should be modular, and you should be able to add the QC bit later
16:05:48 <dons> yeah, the tools is pretty modular as is (for 10 mins work...)
16:06:01 <dons> so I see no problem with making it more flexible
16:06:12 <ndm> dons: i agree with igloo here, but i think the focus should be on "the user has something", not "the user has nothing" - as i think by the time most users want to turn a hack into a project, they've already got at least a "main"
16:06:14 <Igloo> dons: For a tool that looks OK, but for a library I think it should ask for a hierarchial library prefix
16:06:38 <ndm> i certainly never start a darcs repo until i've at least proved the idea isn't just stupid at the lowest level
16:07:07 * Igloo makes too many darcs repos. I need to hierarchialise them.
16:07:17 <dons> ndm, ah good idea
16:07:31 <dons> Igloo: hmm. that's a good idea too
16:07:35 <shapr> How does that work?
16:07:39 <dons> i.e. it has the default hier tree
16:07:42 <dons> and you have to find a place
16:07:44 <shapr> I'd like to have subrepos that are automatically pulled in
16:07:53 <shapr> and I'd like darcs pull to automatically update subrepos
16:08:00 <ndm> shapr: can darcs do that yet? Yhc needs it badly...
16:08:10 <Igloo> shapr: I don't mean any clever darcs stuff, I just need to have e.g. code/foo/ rather than just foo/ in my repo farm
16:08:11 <shapr> If that worked, it would also encourage people to refactor apps to libs
16:08:22 <shapr> Igloo: huh?
16:08:28 <shapr> konichiwa uebayasi
16:09:00 <Igloo> shapr: e.g. http://urchin.earth.li/darcs/ian/diki/ should be http://urchin.earth.li/darcs/ian/code/diki/
16:09:01 <lambdabot> Title: Index of /darcs/ian/diki
16:09:22 <shapr> oh
16:09:31 <shapr> I still want subrepos..
16:09:34 <Igloo> But I need to do it without breaking the backups and with some magic to update all the repos that know where that is, ideally, so I keep putting it off
16:09:52 <shapr> ndm: don't know
16:11:15 <dcoutts> dons, we could combine the string builder concept with a tree-based lazy bytestring to provide efficient O(1) cons/snoc.
16:11:33 <shapr> That's starting to sound like 2-3 finger trees.
16:11:35 <dcoutts> dons, by having two kinds of tree nodes, ordinary and builder ones.
16:11:42 <dcoutts> shapr, yes, but not balanced
16:11:53 <dcoutts> so we can still be lazy for stream-based things
16:11:58 <shapr> hm, yeah
16:11:59 <alexj__> Igloo: searchpath may do what you want?
16:12:11 <Igloo> alexj__: Hmm?
16:12:21 <dons> dcoutts: yeah, I think a string builder is a good idea
16:12:40 <alexj__> are you looking just to automatically grab current versions of things or to maintain multiple repos.  what do you want on "darcs record"
16:12:45 <alexj__> ?
16:12:54 <alexj__> searchpath is http://searchpath.org
16:13:56 <Igloo> alexj__: The repos are entirely separate, they just live in the same place so I can easily back them up and find things. I just want to arrange them into subdirectories without causing myself too much pain
16:14:48 <alexj__> I keep all my repos in ~/projects/<reponame>  and have my bulid files point up a directory to find other repos.  would that work for you?
16:15:28 <Igloo> These repos are on a separate machine to where I do my building
16:15:42 <dcoutts> dons, so one idea is to have two kinds of tree node, one for ordinary and one for builder nodes, so when you insert a char or cons/snoc then we allocate a new builder node and after that we use the builder to do a sequence of inserts at that location.
16:16:05 <alexj__> oh then searchpath is actually what you want.  It is basically import chasing accross URL space.
16:16:13 * Igloo shouldn't have mentioned it; it's not interesting enough to warrant half the attention it's received  :-)
16:16:22 <alexj__> ok.
16:16:25 <Igloo> I don't want import chasing at all
16:17:45 <alexj__> if your project uses Repo.Foo.Bar in  http://repohost.com/repo/src then searchpath makes it transparent to use it.
16:18:01 <Igloo> Half the repos aren't even Haskell code
16:18:12 <alexj__> ah ok.  nevermind.
16:18:40 <ndm> searchpath looks way neat
16:18:54 * alexj__ smiles
16:18:56 <shapr> Yeah, it seems like it should fit into cabal-get somehow.
16:19:11 <ndm> yep, i always wanted cabal-auto-get, which did just that
16:19:17 <ndm> and my intention was to integrate that into Yhc
16:19:29 <ndm> (if Cabal had dependancy chasing, that might be more feasible)
16:19:30 <dons> oh interesting:
16:19:31 <dons> *Spiral> makeSpiral 1000
16:19:31 <dons> (<interactive>: internal error: interpretBCO: unknown or unimplemented opcode 35528
16:19:34 <dons>     (GHC version 6.5 for i386_unknown_openbsd)
16:19:37 <dons>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
16:19:39 <lambdabot> Title: 1.2. Reporting bugs in GHC
16:20:08 <alexj__> searchpath ignores cabal stuff and just looks at import declarations.
16:20:14 <dons> huh and in 6.6
16:20:37 <ndm> alexj__: yeah, thats all i wanted
16:20:44 <alexj__> you use map files to map from module names to URLs.  you can use multiple map files that override each other as needed.
16:20:50 <ndm> alexj__: although that map file could be derived from Cabal
16:21:02 <shapr> Yeah, cabal <-> searchpath integration would be nice.
16:21:35 <alexj__> then you would need map files that designate the URL of your cabal packages.
16:21:39 <robreim> dons: did you manage to get hs-plugins working over the w/e?
16:21:48 <dons> nope. but I'm comitted to making it happen
16:22:02 <robreim> cool
16:22:13 <robreim> (sorry, don't mean to bug)
16:22:19 <dons> i'm getting there. got ghc 6.6 setup and the hs-plugins build failing
16:22:27 <dons> no, don't be. please bug me :)
16:23:17 * shapr bugs dons 
16:23:22 * shapr begs for hs-plugins on ghc 6.6
16:23:36 * ndm bugs dcoutts and JaffaCake for Gtk2Hs + threading
16:24:02 <emu> do people here use things like hIDE?
16:24:10 <dons> Igloo: is it right that I can't attach a file to a trac bug till after I've create the bug ticket?
16:24:12 <ndm> emu: winhugs + textpad
16:24:21 <Igloo> dons: I believe so
16:24:23 <dcoutts> emu, ghci + nedit
16:24:36 <dons> ghci + vim!
16:24:39 <dons> + lambdabot :)
16:24:45 <robreim> ghci + emacs here :)
16:24:55 <emu> yes i tend to work within ghci and either vim or emacs
16:25:03 <shapr> ghci + emacs, trying to figure out how to get a local lambdabot integrated.
16:25:22 <emu> but hIDE seems to be an introspective IDE attached to your favorite editor {vim,nedit,emacs}
16:25:33 <robreim> shapr: if you figure it out, a howto would be most welcome :)
16:25:43 <emu> i've been thinking about ways to get at that information conveniently
16:25:50 <xerox> emacs + goa!
16:25:59 <xerox> shapr, goa!
16:26:03 <emu> besides typing ":info .." for some things all the time
16:26:07 <xerox> robreim: goa!
16:26:23 <robreim> goa's part of lambdabot, yeah?
16:26:35 <emu> "local lambdabot" would be kinda useful, i suppose that exists
16:26:40 <xerox> yes yes yes.
16:27:18 <robreim> what does goa do that ghci doesn't anyway?
16:27:24 <emu> what about stuff like cross-referencing? who-calls and friends?
16:27:27 <xerox> automatize things
16:27:44 <xerox> you can type everything goa does in ghci if you want.
16:28:57 <xerox> but you were looking for integration, I think?
16:29:43 <robreim> which scripts in lambdabot deal with GOA? I can't find it...
16:29:51 <robreim> s/scripts/modules/
16:30:25 <dons> ?where goa
16:30:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
16:30:29 <robreim> tah
16:30:31 <dons> grab goa and follow the build instructions
16:31:04 <robreim> ah, so it is separate from lambdabot. I thought it was a subcomponent.
16:31:21 <dons> its a small library loaded by ghci, which interfaces to a persistent lambdabot
16:31:39 <dons> so that you can use lambdabot functions from the ghci prompt
16:31:52 <robreim> oh right. I remember reading that now. Thanks :)
16:32:22 * Igloo looks - oh, so lambdabot isn't capable of playing http://www.boardgamegeek.com/game/9216 yet, then?
16:32:44 <robreim> Cool, so as soon as hs-plugins is available for ghc 6.6 I'll be able to use lambdabot and GOA :)
16:32:50 <dons> :)
16:33:03 <emu> goa looks good
16:33:29 <dons> sjanssen: btw, i'm really happy with that fasta you wrote
16:33:46 <dons> no weird tricks or extensions, and it runs around 1.5x the fastest entry on my box
16:34:12 <dons> "Goa is a strategy game of auctions and resource managment."
16:34:30 <dons> lambdabot does have some fun strategies for resource managment.
16:34:37 <dons> mostly : killthread
16:34:48 <dons> (there are games about resource management now??)
16:34:57 <Igloo> I heard its resource managment was sufficiently poor it had to be rebooted every week
16:35:04 <xerox> dons yeah
16:35:20 <xerox> dons, beside fighting, that's the biggest part of the work in some
16:35:20 <Igloo> I bet the erlangers mock us
16:35:31 <dons> Igloo: heh. no no. there is a leak in there somewhere though. I think sjanssen worked it out
16:35:51 <dons> i introduced it a month ago, but haven't run any profiling tools since then
16:36:00 <xerox> shame!
16:36:01 <dons> xerox: ah true
16:36:10 <seafood> I've got an interesting opinion question to ask. How many characters wide should an editor window be for Haskell code? I think 80 is probably too little.
16:36:10 <lambdabot> seafood: You have 1 new message. '/msg lambdabot @messages' to read it.
16:36:19 <Igloo> 80
16:36:24 <emu> seafood: i've been maximizing all my windows lately
16:36:25 <xerox> seafood: yeah, I go for at least 100
16:36:28 <dons> hmp3 ran for 6 months until the power was disconnected though...
16:36:37 <dons> in constant space. that was fun.
16:36:41 <xerox> dons haha, phas would hug you
16:37:04 <dons> seafood: $ resize
16:37:04 <dons> COLUMNS=101;
16:37:04 <dons> LINES=37;
16:37:06 <dons> fwiw
16:37:18 <robreim> I try to keep it under 75 characters wide, but if it gets longer than that without ruining clarity (eg a long literal string) I don't sweat it.
16:37:48 <Igloo> The best way to make it look good portably is to assume 80
16:37:48 <dons> seafood: but wrapping at 72-80 chars is still best practice for non-windows
16:37:58 <newsham> > let f >>>+ g = returnA<+>f >>> returnA<+>g in ["hi","there"] >>= runKleisli ((arr ("<" ++)) >>>+ (arr (++ ">")) >>>+ ((arr ("!" ++)) >>> (arr (++ "!"))))
16:38:00 <lambdabot>  ["hi","!hi!","hi","!hi!","hi>","!hi>!","<hi","!<hi!","<hi>","!<hi>!","there"...
16:38:08 <xerox> newsham: that makes my eyes hurt
16:38:13 <seafood> Okay, make the case for 80.
16:38:28 <seafood> (Because people don't seem to want to budge from this for some reason.)
16:38:43 <newsham> hmm.. there's dups in that list.
16:39:38 <xerox> > let f >>>+ g = returnA<+>f >>> returnA<+>g in
16:39:38 <xerox>     ["hi","there"] >>= runKleisli (("<" ++) >>>+ (++ ">"))
16:39:38 <xerox>     >>>+ (("!" ++) >>> (++ "!"))
16:39:38 <lambdabot>  Parse error
16:39:56 <xerox> > let f >>>+ g = returnA<+>f >>> returnA<+>g in
16:39:56 <xerox>     ["hi","there"] >>= runKleisli (("<" ++) >>>+ (++ ">")
16:39:56 <xerox>     >>>+ (("!" ++) >>> (++ "!")))
16:39:56 <lambdabot>  Parse error
16:39:58 <xerox> ops
16:40:25 <dons> seafood: lots of tools still assume your window is no wider than 80, and anyway, TeX wraps lines at 60 chars...
16:40:31 <dons> so knuth sez: > 80 is too hard on the brain
16:40:35 <robreim> For text, the argument for <80 characters is usually that it's harder to read lines much longer than that (no idea if that's been properly studied)
16:40:46 <robreim> That probably doesn't apply so strongly to code
16:40:48 <xerox> newsham: hmpf, there is no way to do implicit keisli?
16:40:55 <newsham> (returnA <+> f) x returns   (id x) `concat` (f x)
16:40:58 <xerox> newsham: like implicit arrow (->)
16:41:12 <seafood> I'll say why I think 80 is too little. Haskell is a language which is indentation sensitive.  There can be many levels of indentation. You lose a lot that indentation when working in let expressions/where clauses and nested let expressions/where clauses.
16:41:18 <seafood> Which means you lose space at the beginnin.
16:41:23 <newsham> xerox: you mean run it without "runKleisli" ?
16:41:29 <xerox> newsham: without arr
16:41:33 <seafood> I can't see how that "space" is hard on the brain. You just lose it.
16:41:43 <xerox> and yes, without runKleisli
16:41:49 <xerox> that's probably too much?
16:41:55 <newsham> oh,   (Kleisli (\x -> [x ++ ">"]))    ?
16:42:01 <xerox> uhm.
16:42:20 <seafood> Also, in response to the tools argument let me say this: join the twenty first century!
16:42:25 <xerox> I was trying to make your code more lightweight
16:42:26 <newsham> arr (\x -> f x)    is     Kleisli (\x -> return (f x))
16:42:40 <xerox> why the return?
16:42:51 <newsham> because i'm using the Kleisli [] String String
16:42:59 <xerox> i thought it was the same
16:43:06 <xerox> i.e. f had to me a -> m b
16:43:07 <newsham> so String -> [String].    return puts it in a list.
16:43:47 <xerox> arr = (return .) ?
16:43:54 <newsham> for kleisli, yes.
16:44:01 <xerox> no sorry
16:44:10 <xerox> (Kleisli . return .)
16:44:20 <newsham> *nod* right.. puts it into the wrapper, too.
16:44:26 <robreim> seafood: your arguments as well as the opposing ones have been debated for decades. You can probably find more arguments through google and then make your own mind up from what you find.
16:44:40 <xerox> newsham: then it means I didn't understand arr
16:45:08 <xerox> does it actually do anything in the case of the arrow (->) ?
16:45:20 <newsham> i'm not familiar with (->)
16:45:22 <seafood> robreim: Good point. However, I wanted to debate some Haskell-specific points too.
16:45:44 <xerox> newsham: it doesn't.  but that doesn't mean anything right?  different arrows express different behaviours
16:45:51 <xerox> @spell behaviour
16:45:53 <lambdabot> behavior behaviors behaver behave behavior's
16:45:56 <xerox> ops.
16:46:03 <sjanssen> dons: thanks.  I bet it'd be even faster if we had Data.ByteString.Lazy.unfoldrN
16:46:12 <robreim> functional languages indeed have a lot of indentation. You could perhaps strike a compromise by only counting the width of code after ignoring indentation if you want.
16:46:34 <dcoutts> sjanssen, remember that unfoldrN can't fuse easily
16:46:58 <dcoutts> and it shouldn't be needed much for .Lazy anyway
16:47:07 <dons> sjanssen: you saw I submitted it ?
16:47:12 <dons> http://www.haskell.org/haskellwiki/Shootout/Fasta#Proposed_entry
16:47:15 <lambdabot> Title: Shootout/Fasta - HaskellWiki, http://tinyurl.com/vznau
16:47:23 <sjanssen> dcoutts: yeah, I'm not really recommending that it be added
16:47:23 <sjanssen> dons: yeah
16:47:36 <sjanssen> we need some function to accomplish what I needed to do in Fasta
16:47:42 <dons> yep
16:48:20 <sjanssen> maybe this is what we need: (s -> Either (Word8, s) a) -> s -> (ByteString, a)
16:50:43 <dons> knuc looks like a good one to try to tackle..
16:50:51 <dons> and regex-dna
16:50:52 <xerox> you use unfoldrN to generate random numbers?
16:51:09 <sjanssen> xerox: yeah
16:51:19 <xerox> what's (3 * n), (5 * n) ?
16:51:24 <newsham> hmm..  (>>>+) doesnt work as well as I had hoped
16:51:43 <sjanssen> xerox: because it's the only way I could get the seed out without memory leaks
16:51:57 <sjanssen> xerox: magic numbers given in the spec
16:52:00 <xerox> sorry I don't understand
16:53:35 <xerox> ?type unfoldr
16:53:37 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
16:54:00 <sjanssen> the program reads in n, and then is supposed to generate certain random sequences of (3 * n) and (5 * n)
16:54:05 <xerox> so when you are unfolding, you always rely on the parameter
16:54:22 <sjanssen> @type Data.ByteString.unfoldrN
16:54:24 <lambdabot> forall a. -> (a -> Maybe (Word8, a)) -> a -> (Data.ByteString.Base.ByteString, Maybe a)
16:54:30 <xerox> i wonder if one can have an unfoldHList.
16:54:49 <dons> "Standard ML and Ocaml is beginning to look
16:54:50 <dons> old compared to Haskell."
16:55:14 <xerox> sjanssen: so you collect the numbers in word8 in the bytestring?
16:55:23 <xerox> and the a is the seed?
16:55:45 <sjanssen> xerox: yeah, a is the seed
16:55:57 <xerox> nice =)
16:56:29 <newsham> can ocaml be embedded in haskell?
16:56:35 <sjanssen> and I fuse together random generation of a probability with selecting a 'Base' because there's really no other way
16:56:58 <xerox> fuse?
16:57:39 <sjanssen> by hand, not with any fancy rules
16:57:43 <dons> newsham: hmm. maybe...
16:57:45 <xerox> right
16:57:53 <dons> typeclasses + associated types give us almost modules
16:58:00 <xerox> sjanssen: maybe with the rules would have looked better? :)
16:58:12 <sjanssen> xerox: because unfoldrN generates ByteStrings instead of [Double]
16:58:36 <xerox> so?
16:58:57 <newsham> sometimes i think it would be nifty having an ocaml like language with haskell-like syntax
16:59:14 <newsham> ghci --impure-nonstrict
16:59:21 <xerox> ...after spending the day typing >>>+ <<< and the like? :)
16:59:23 <newsham> sometimes i just dont think
17:00:11 <sjanssen> dons, dcoutts: what do you think of "unfoldrFinish :: (a -> Either (Word8, a) b) -> a -> (ByteString, b)"?  As far as I can tell, there is no function in the .Lazy API that can accomplish this
17:07:29 <Cale> Squeak is quite fun. From the looks of it so far, I don't think I'd want to write anything really computationally tricky in it, but it's fun to play around with.
17:11:55 <dons> today's paper: http://programming.reddit.com/info/rlpb/details
17:11:58 <lambdabot> Title: No more locks: concurrent lock free data in Haskell [pdf] (reddit.com), http://tinyurl.com/y3rqhu
17:15:41 <astrolabe> ping Cale
17:15:46 <Cale> hi
17:16:18 <astrolabe> Cale, you know how sunflower seeds pack on the head of a flower using the golden ratio?
17:16:27 <Cale> apparently, yes
17:16:31 <dons> maybe...
17:16:40 <astrolabe> How would they pack in 3d?
17:17:04 <astrolabe> The pattern you get using the golden ratio looks really like the head of a sunflower
17:17:17 <Cale> I don't know :) I don't think sunflowers are formally-enough defined to be able to generalise them like that meaningfully.
17:17:25 <LoganCapaldo> This isn't  a mathematical sunflower we're talking about here right? Don't they already pack in 3d?
17:17:40 <astrolabe> Let me re-phrase
17:20:56 <astrolabe> the sequence   map (\x -> x - floor x) [n*g | n <- [0..]] has a very large value of the closest pair using a minimum distance including wrap-around within the first n terms.  Is there a version for directions in 3-space?
17:23:03 <astrolabe> maybe a maximally irrational element of SO(3)
17:47:33 <dons> sjanssen: accepted. http://alioth.debian.org/tracker/?func=detail&atid=411646&aid=304147&group_id=30402
17:47:37 <lambdabot> Title: Alioth: The Computer Language Shootout Benchmark: Detail: 304147 GHC 6.6/ByteStr ..., http://tinyurl.com/y64xvu
17:50:19 <lennart> howdy
17:51:03 <dons> heya lennart
17:54:09 <sjanssen> dons: when do they update the standings pages?
17:56:49 <shapr> astrolabe: I've tried to come up with a 3D yin-yang symbol... any ideas?
17:57:59 * johnnowak reckons two interlocking sphere halves
18:08:32 <Renkin> I have a problem with wxHaskell..
18:09:42 <Renkin> I'm doing two varUpdates in a row, like do {varUpdate var1 updateFunc1; varUpdate var2 updateFunc2}
18:10:20 <Renkin> And the compiler complains about the second one (in whatever order I put them), saying it wants type  Var ()  for var2 in this case..
18:11:33 <SamB_XP> Renkin: try adding "; return ()" at the end
18:12:09 <Renkin> Worked. Thanks :)
18:12:15 <Renkin> Why, though?
18:13:02 <SamB_XP> well, I think whatever was calling that function wanted it to have a return type of m (), where m is probably IO but could be some other monad...
18:13:54 <Renkin> Yeah, that's right
18:14:09 <Renkin> Isn't just leaving out return the same as return () ?
18:14:16 <SamB_XP> no indeed.
18:14:34 <Renkin> Ah, ok
18:14:37 <Renkin> That's good to know :)
18:14:49 <SamB_XP> return doesn't act much like in other languages at all
18:14:54 <jrud> its like doing res <- laststatement; return res
18:15:05 <SamB_XP> it doesn't do any kind of control flow, all it does is return a value ;-)
18:15:35 <Renkin> Yeah, I'm trying to get into the funcprog thinking =)
18:15:47 <SamB_XP> I mean, if you did: main = do message <- return "Hi!"; putStrLn message
18:16:10 <SamB_XP> that would do exactly the same as: main = putStrLn "Hi!"
18:16:14 <Renkin> I should probably sit down and convert some code back and forth between bind- and do-notation to get the hang of it =)
18:16:25 <Renkin> Ok
18:16:26 <SamB_XP> @undo main = do message <- return "Hi!"; putStrLn message
18:16:27 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
18:16:31 <SamB_XP> @undo do message <- return "Hi!"; putStrLn message
18:16:32 <lambdabot> return "Hi!" >>= \ message -> putStrLn message
18:16:42 <SamB_XP> @. pl undo do message <- return "Hi!"; putStrLn message
18:16:43 <lambdabot> putStrLn "Hi!"
18:17:18 <Renkin> Cool
18:17:55 <dufflebunk> I have a line like: contents <- readFile fileName, then I fold contents. If I don't mention contents later it never has more than a char or two from the file in memory at a time, right?
18:17:57 <Renkin> I think I was fooled by the fact that the main function is of type IO () but rarely contains a return () itself
18:18:12 <Renkin> But that totally makes sense now when I think
18:18:25 <SamB_XP> well..
18:18:32 <SamB_XP> @type putStrLn "Hi!"
18:18:33 <lambdabot> IO ()
18:18:36 <sjanssen> dufflebunk: yes, if you make sure that the fold is strict
18:18:53 <Renkin> SamB_XP: Yeah, that's what I meant
18:19:09 <dufflebunk> sjanssen: why would strictness matter?
18:19:12 <sjanssen> a foldl' will be constant space, foldr might be linear
18:19:13 <Renkin> It's just a tree of function calls
18:19:21 <SamB_XP> uh huh
18:19:24 <Renkin> Or a list =)
18:19:24 <SamB_XP> thats all ;-)
18:19:52 <dufflebunk> sjanssen: right foldr would have to read to the end then go backwards.
18:19:56 <sjanssen> dufflebunk: you might keep thunks that have the Chars in them
18:20:03 <Renkin> The do-notation doesn't help in making it looks imperative, though =)
18:20:10 <Renkin> -s
18:20:22 <SamB_XP> it is imperative
18:20:26 <sjanssen> dufflebunk: readFile will work similarly to any other lazy list, so use the strategies
18:20:37 <sjanssen> s/strategies/same strategies
18:20:49 <Renkin> Yeah, but the notation makes it look different from what it is
18:21:14 <Renkin> But I guess you just have to learn to think about it the right way
18:21:24 <SamB_XP> I blame those languages where "return" means "return this value from the entire enclosing named function"
18:22:01 <sjanssen> SamB_XP: there are arguments for both meanings
18:22:10 <LoganCapaldo> I blame Haskell for picking a bad function name ;) They coulda called it "wrap" or something
18:22:26 <Renkin> In the case of C and such languages it's becase it's build close to the machine
18:22:28 <dufflebunk> mmm wraps...
18:22:32 <Renkin> And it has its advantages
18:22:44 <SamB_XP> well, kinda-sorta close
18:22:47 <Renkin> But Haskell is very nice, indeed. I just need to get the hang of it better
18:22:49 <sjanssen> "return to the caller" is a reasonable choice for a language like C
18:23:01 <SamB_XP> okay.
18:23:06 <SamB_XP> yeah.
18:23:22 <Renkin> Which I am in the process of doing now =)
18:23:53 * dufflebunk is still trying to figure out the line noise associated with monads
18:24:35 <Renkin> And yeah, with close to the machine I meant in the way it works. It executes code in a linear way and you can branch back and forth
18:25:34 <greentea> dufflebunk: You mean '>>=' and such?
18:26:22 <dufflebunk> greentea: yeah. And all the other operators I've seen in all the docs about monads
18:26:39 <sjanssen> dufflebunk: do you understand do syntax?
18:26:50 <greentea> *nod* Have you read the "Tackling the Awkward Squad" paper?
18:27:04 <dufflebunk> greentea: Reading it right now.
18:27:32 <greentea> :-) i found it the most enlightening of all the monad-related stuff i've read.
18:27:41 <dufflebunk> sjanssen: Nope, not yet. Working on it though. Right now it's more trial and error than anything for me
18:28:28 <sjanssen> dufflebunk: okay.  You might want to try the @undo and @redo commands in lambdabot when you're learning
18:28:29 <Renkin> I found it easier to get do after really understanding bind (>>=), but I lose the understanding again when writing larger do-things
18:28:51 <sjanssen> @undo do x <- m; return m -- do syntax to monad operators
18:28:52 <lambdabot> m >>= \ x -> return m
18:29:09 <sjanssen> @redo m >>= \ x -> return m -- monad operators to do syntax
18:29:09 <lambdabot> do { x <- m; return m}
18:29:20 <Renkin> That's useful
18:29:36 <sjanssen> Renkin: beware, this version has a bug or two
18:29:45 <Renkin> Ok
18:29:47 <sjanssen> @redo m >>= return
18:29:48 <lambdabot> do { _ <- m; return}
18:30:08 <sjanssen> but that will be fixed next time dons updates lambdabot
18:30:14 <LoganCapaldo> @undo do { _ <- m; return }
18:30:15 <lambdabot> m >>= \ _ -> return
18:30:31 <SimonRC> I found the secret to learning monads is just to keep pounding.
18:30:32 <sjanssen> also, all operators are considered to have the same fixity, so some stuff is wrong
18:30:35 <LoganCapaldo> ... Does that or doesn't it mena the bug is consistent? :)
18:30:43 <dolio> @redo m >>= putStrLn
18:30:43 <lambdabot> do { _ <- m; putStrLn}
18:30:49 <SimonRC> Eventually, it clicks.
18:30:53 <sjanssen> LoganCapaldo: no bugs in @undo, just @redo
18:30:53 * SimonRC goes to bed.
18:31:02 <LoganCapaldo> aha
18:31:33 <Renkin> @undo do x <- a; y <- b; return (fun x y)
18:31:34 <lambdabot> a >>= \ x -> b >>= \ y -> return (fun x y)
18:31:54 <Renkin> Nice
18:33:33 <Renkin> @type (>>=)
18:33:35 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:35:23 <Renkin> Drawing boxes and arrows on a piece of paper is also a nice way to get monads
18:35:45 <LoganCapaldo> I like doing | this | it | worked | for | me
18:36:01 <LoganCapaldo> Also, turning down the mysterious dial helped ;)
18:36:32 <LoganCapaldo> I'm still not fully wrapped around making monads
18:36:34 <Renkin> What's with all the pipes? =)
18:36:51 <LoganCapaldo> like I couldn't tell how to make Cont or something crazy like that
18:36:56 <Renkin> | | |
18:37:00 <eviltwin_b> you can think of >>= as a pipe from the monadic value into a lambda?
18:37:15 <LoganCapaldo> yeah
18:37:17 <Renkin> Oh, ok
18:37:46 <Renkin> I'm far from making monads so far =)
18:38:01 <Renkin> I can barely use them
18:38:36 <dufflebunk> woohoo! The akward doc speaks truth: "This is an admirably abstract statement, and I would not be surprised if it means almost nothing to you"
18:38:43 <sjanssen> LoganCapaldo: Cont is a pretty tricky example.  If you can write out State or StateT, I'd say you're doing fine
18:39:10 <sjanssen> dufflebunk: heh, to which statement is it referring?
18:39:23 <dufflebunk> A value of type IO a is an "action" that, when performed, may do some in-
18:39:23 <dufflebunk> put/output, before delivering a value of type a.
18:39:30 <eviltwin_b> start with Maybe, work up to State :)
18:39:44 <Renkin> I've done Maybe!
18:41:19 <LoganCapaldo> I guess Either is afterMaybe and before State ;)
18:41:24 <eviltwin_b> as a monad?
18:41:40 <LoganCapaldo> yeah
18:41:43 <sjanssen> yeah, Either should be simple once you've done Maybe
18:42:44 <Renkin> eviltwin_b: No, not as a monad :)
18:43:15 <Renkin> oh
18:43:38 <Renkin> Oh well, I'm tired as hell, time to sleep
18:53:56 <Ontolog> http://pastebin.com/828545
18:54:10 <Ontolog> I'm doing excercise 4.7 of Yet Another Haskell Tutorial
18:54:24 <Ontolog> I'm getting errors when reading my translate function
18:54:32 <sjanssen> Ontolog: what is this supposed to do?
18:55:25 <Ontolog> take a Tuple
18:55:32 <Ontolog> and translate it into a Haskell type
18:55:45 <Ontolog> if it's a Tuple1 then return just the value
18:55:54 <Ontolog> if it's a Tuple2 return a Haskell (a, b)
18:56:02 <Ontolog> if it's a Tuple3 return a (a, b, c)
18:56:02 <Ontolog> etc
18:56:09 <sjanssen> you can't write this function in Haskell
18:56:26 <Ontolog> it's an exercise in a tutorial
18:56:43 <sjanssen> maybe you need to read the question more closely?
18:57:08 <chessguy> or explain it more clearly
18:58:08 <Ontolog> Based on our definition of Tuple from the previous exercise, write a
18:58:08 <Ontolog> function which takes a Tuple and returns either the value (if it¡¯s a one-tuple), a
18:58:08 <Ontolog> Haskell-pair (i.e., (¡¯a¡¯,5)) if it¡¯s a two-tuple, a Haskell-triple if it¡¯s a three-tuple
18:58:08 <Ontolog> or a Haskell-quadruple if it¡¯s a four-tuple. You will need to use the Either type to
18:58:08 <Ontolog> represent this.
18:58:39 <lennart> The last sentence is the key.
18:59:13 <Ontolog> yeah i don't understand how to use the Either type to do this
18:59:20 <chessguy> i annotated the post with the problem statement: http://pastebin.com/828551
19:01:11 <sjanssen> data Either a b = Left a | Right b
19:01:49 <sjanssen> Either a b is the type lets you contain either an a or a b
19:02:05 <Ontolog> yep
19:02:06 <Ontolog> got that
19:02:08 <sjanssen> you wrap a with Left, and b with Right
19:02:12 <Ontolog> btw i updated the code a little bit
19:02:19 <Ontolog> I put in Left and Right
19:02:25 <Ontolog> but the code still doesn't compile
19:03:05 <sjanssen> @where paste
19:03:06 <lambdabot> http://paste.lisp.org/new/haskell
19:03:35 <sjanssen> Ontolog: next time you have a paste, you should try this out.  It automatically pings the channel when somebody enters a paste/adds an annotation
19:03:45 <lisppaste2> Ontolog pasted "Tuples" at http://paste.lisp.org/display/30254
19:04:45 <lisppaste2> sjanssen annotated #30254 with "notice how this works when I comment out the type sig and the last two cases?" at http://paste.lisp.org/display/30254#1
19:04:45 <Ontolog> I don't understand how to use the Either type
19:04:54 <Ontolog> since there are effectively 4 different types to return
19:05:16 <sjanssen> Ontolog: yeah, thats the trick.  You have to use nested eithers
19:05:25 <lambda_the_insig> this may have been addressed before, but is there a way to establish a type class negation, i.e., the set of all types which do not have instances defined for a particular class?
19:05:48 <Ontolog> sjanssen: how do you nest Eithers?
19:06:06 <sjanssen> @type Right (Right 'a')
19:06:08 <lambdabot> forall a a1. Either a1 (Either a Char)
19:06:14 <Ontolog> sjanssen: make a new data type?
19:06:19 <Ontolog> hmm
19:06:48 <sjanssen> so the result type of your function will be considerably longer than "Either a b"
19:07:49 <lambda_the_insig> say: class (...some syntax indicating that a is not an element of Show...) NoShow a
19:08:06 * Ontolog is slow
19:08:09 <Ontolog> can you just show me
19:08:19 <sjanssen> lambda_the_insig: I don't believe there is such a thing
19:08:21 <Ontolog> I don't seem to ge tit
19:08:26 <Ontolog> *get it
19:08:36 <sjanssen> oh, but you're so close
19:08:47 <sjanssen> I'll extend the code to work with Tuple3
19:09:04 <Ontolog> thanks
19:09:46 <lisppaste2> sjanssen annotated #30254 with "works up to Tuple3" at http://paste.lisp.org/display/30254#2
19:14:22 <Ontolog> sjanssen: ok I got it now, and made it work for all 4 tuples
19:14:30 <Ontolog> however if I still want the function signature
19:14:34 <Ontolog> what does that look like?
19:15:06 <Ontolog> I'm still not confident with my understanding of the syntax
19:15:51 <lisppaste2> Ontolog annotated #30254 with "Got it to work, but what about the function signature?" at http://paste.lisp.org/display/30254#3
19:16:32 <lisppaste2> asdf pasted "asdf" at http://paste.lisp.org/display/30256
19:17:15 <dons> sjanssen: the standings should get updated each night
19:17:20 <dons> depending on if the entry compiles...
19:17:26 <dons> (though it should in the sandbox at least)
19:18:48 <sjanssen> Ontolog: your Haskell interpreter can tell you, try ":type translate"
19:19:59 <Ontolog> god damn
19:20:18 <Ontolog> from doing these examples this seems like the most impractical language ever... sorry for trolling :(
19:20:26 <Ontolog> i still just don't get it on a whole
19:21:51 <Ontolog> anyway you helped a lot, thanks
19:22:49 <shapr> Ontolog: What language are you used to using?
19:23:25 <sjanssen> Ontolog: well, it is tough to write a tutorial that has you doing really useful stuff right away.  But I promise you, Haskell is plenty practical
19:23:58 * shapr has a Haskell job
19:24:14 <Ontolog> shapr: I'm used to Java, Perl, C, etc...
19:24:30 * Ontolog is hoping to stick with it long enough to help with Pugs
19:24:51 <shapr> It's a big jump from those languages to Haskell. I came in from BASIC, Java, VB, and Python.
19:25:03 <shapr> I also had a bunch of difficulty making the jump.
19:25:20 <shapr> But it is very much worth the effort.
19:26:21 <shapr> Ontolog: Do you have any general or specific questions I may be able to help with?
19:26:51 <Ontolog> shapr: not until the next exercise ;) thanks
19:27:09 <shapr> What's your perception of Haskell so far?
19:27:27 <jrud> 'the most impractical language ever' haha
19:27:59 <Ontolog> what jrud said
19:28:00 <Ontolog> lol
19:28:17 <Ontolog> i guess I'm really struggling with the syntax
19:28:24 <shapr> My first Haskell program took me two months to write, and I complained so much that Hal Daume started writing YAHT
19:28:24 <sjanssen> even if you were very critical of Haskell, something else would have to take the "most impractical" crown
19:28:26 <sjanssen> probably C ;)
19:28:37 <Ontolog> true
19:28:43 <shapr> Ontolog: What seems impractical about it?
19:29:11 <Ontolog> well i just don't see what i can do with it yet
19:29:38 <shapr> You mean, why is it a good choice for Pugs? Or, how can it do all the same stuff other languages do?
19:29:52 <Ontolog> the latter
19:30:19 <Ontolog> you know I really should just get back to the tutorial and come back here with a specific question
19:30:24 <Ontolog> i've only been at it like 3 days
19:30:28 <shapr> heh, ok
19:30:51 <shapr> But the "on the whole" explanation may help if you want to try that.
19:31:18 <sjanssen> think about it, after three days of learning C, you'd be in ##C asking "what does segmentation fault mean?"
19:31:53 <SamB_XP> and they'd tell you unhelpful stuff like "you did something bad"
19:31:54 <Ontolog> yeah i guess so but it's very easy to see the parts of a c program and how they work
19:31:54 <shapr> Yeah, I just can't bring myself to write C code these days.
19:31:55 <stepcut> in C++, you forget a ; and you get 1000's of lines of errors :)
19:32:28 <shapr> Ontolog: Not always, pointers/refs/etc
19:32:29 <Ontolog> i can't just look at haskell and understand whats going on
19:32:59 <shapr> Have you seen the HaskellDemo I wrote? It's a super-micro-tutorial..
19:33:10 <Ontolog> i guess i have a hard time getting use to this pattern-matching type stuff
19:33:16 <Ontolog> nope
19:33:20 <Ontolog> i'm following the YAHT
19:33:23 <shapr> http://www.haskell.org/hawiki/HaskellDemo
19:33:24 <lambdabot> Title: HaskellDemo - The Haskell Wiki
19:33:27 <Ontolog> thanks
19:33:31 <shapr> I never got around to reading YAHT, is it good?
19:34:31 <dufflebunk> hmm, IO makes more sense if I don't use the do notation.
19:34:47 <Ontolog> yeah it's pretty good except the exercises seem purely to demonstrate a feature of the language but not how it is applied pragmatically
19:35:00 <shapr> Oh, I see.
19:35:06 <shapr> Ontolog: That's a good point.
19:35:39 <shapr> Maybe looking at small working programs would help?
19:36:00 <shapr> Or could you suggest any specific features and I/we could tell you how I/we use them?
19:36:21 <stepcut> or, some people learn haskell by writing a haskell compiler...
19:36:35 <Ontolog> i'm all set now i just have to get over the learning curbe i think, i'll continue with YAHT and take a look at your tutorial as well
19:36:36 <shapr> My brain is too small for that.
19:36:46 <jrud> i found it allot easier playing with ml for a few months before jumping directly into haskell
19:36:47 <Ontolog> *curbe=curve
19:36:49 <shapr> Ok, feel free to ask any questions.
19:36:54 <Ontolog> thx
19:38:53 <pepe> hi all, how I do pairs in haskell?
19:39:00 <stepcut> > (1,2)
19:39:02 <lambdabot>  (1,2)
19:39:02 <shapr> pairs of what?
19:39:02 <sjanssen> Ontolog: not sure whether you're up to the point of reading this, but http://haskell.org/haskellwiki/Roll_your_own_IRC_bot is a pretty neat tutorial
19:39:04 <Cale> (x,y)
19:39:06 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
19:39:24 <shapr> oh, duh
19:39:33 <sjanssen> teaches IO, networking, and other neat stuff while writing a simple IRC bot
19:39:36 <pepe> in scheme.. '((30 5) (2 7))
19:39:44 <shapr> stepcut: Hey, have you recently setup scratchbox? I have a weird error...
19:40:10 <stepcut> shapr: oh ? I have a maemo 2.0 scratchbox...
19:40:32 <shapr> I'm trying to setup maemo 2.1 scratchbox, I want to try a Hugs package first.
19:40:49 <stepcut> what is the error ?
19:41:14 <shapr> I ripped out my maemo 2.0 scratchbox with apt-get -uf remove --purge scratchbox* and then reinstalled, and now I get Directory /targets/HOST already exists! \n  You have 4 other Scratchbox sessions running! \n You must terminate them before the active target can be changed. \n awk: cmd. line:2: fatal: cannot open file `/targets/links/scratchbox.config' for reading (No such file or directory)
19:41:37 <dufflebunk> pepe: ((30, 5), (2, 7))   I think is what you want
19:41:45 <sieni> lambdabot: > (((30,5),
19:41:45 <stepcut> shapr: heh, that is a weird error
19:41:49 <dons> sjanssen: http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=ghc&id=2
19:41:53 <lambdabot> Title: fasta Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ..., http://tinyurl.com/srpk4
19:42:47 <sieni> > ( ((30,5),(2,7)), [(30,5),(2,7)], ([30,5],[2,7]), [[30,5],[2,7]] )
19:42:49 <lambdabot>  (((30,5),(2,7)),[(30,5),(2,7)],([30,5],[2,7]),[[30,5],[2,7]])
19:42:57 <sjanssen> dons: so they don't actually have GHC 6.6?
19:43:05 <sieni> pepe: pick one ;-)
19:43:11 <dons> sjanssen: on the debian shootout box yes, but the gentoo box is waiting for 6.6 still
19:43:20 <dons> i've got Igouy's approval to submit 6.6-based entries though
19:43:22 <vincenz> moin
19:43:26 <sjanssen> oh, right.  You've told me that before.
19:43:29 <dons> and he'll rerun them once he gets ghc 6.6 + gentoo
19:43:54 <pepe> Thks :d
19:43:54 <dons> we have the same issue with sum-file: http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=sumcol&lang=ghc&id=2
19:43:58 <lambdabot> Title: sum-file Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 The  ..., http://tinyurl.com/yh9bek
19:44:57 <sjanssen> dons: well, there is Data.ByteString.Char8.readInt ;)
19:45:06 <sjanssen> did you bake that in just for the shootout?
19:45:07 <stepcut> shapr: after you purged the scratchbox* did you also remove /scratchbox ?
19:45:15 <shapr> stepcut: yes
19:45:27 <stepcut> shapr: hrm, that was my one idea :(
19:45:35 <shapr> I'm guessing something was left over in /var somewhere?
19:45:42 <stepcut> could be
19:45:51 <shapr> I can't find anything though.
19:45:57 <shapr> I especially can't find any of the files mentioned.
19:46:10 <sjanssen> dons: that should be a simple sum . unfoldr BS.readInt
19:46:34 <stepcut> shapr: /scratchbox/users/shapr/target ?
19:46:39 <dons> yeah. I also have a highly tuned version already
19:46:55 <dons> I think Ian just went ahead and submitted something. which is good
19:48:46 <shapr> stepcut: Ah, so that's what it meant...
19:49:25 <shapr> Waitasec, all of these symlinks point to /targets, not /scratchbox/...
19:50:40 <stepcut> shapr: yes, but you will be in a chroot rooted at /scratchbox/users/shapr/ -- so those links make sense
19:50:50 <shapr> ah right
19:51:24 <stepcut> OT: chroot is stupidly simple and awesome at the same time
19:51:49 <dons> dcoutts, sjanssen: Roman's going to finalise a release of the DPH array library in the next 3 weeks
19:51:59 <shapr> yay!
19:52:03 <dons> so we're going to fork off the stream fusion and strict prelude types as separate packages
19:52:15 <shapr> Should I buy a multicore system?
19:52:16 <dons> and i'll move Data.ByteString to depend on -package stream-fusion
19:52:29 <dons> shapr: almost... well, yes. since you already have forkIO/par + SMP..
19:52:49 <dons> array parallel programming is just the icing on the cake :)
19:53:06 <shapr> What gives the most cores for the money today?
19:53:28 <dons> the mips boxes are super cheap (but also a bit slow), however you get 16 cores for 3k
19:53:31 <SamB_XP> don't you want more than just a lot of cores?
19:53:37 <dons> we're looking at a 16 core amd64 for around 20k
19:53:45 <shapr> yow
19:53:55 <dons> or i suppose you could get a 40 core sparc machine for 200k
19:53:59 <dons> 40 cpu.
19:54:00 <encryptio> just gimme a macbook pro and i'll be happy. =p
19:54:00 <SamB_XP> hah
19:54:04 * shapr is poor!
19:54:09 <SamB_XP> encryptio: how many cores do those have?
19:54:18 <alexj__> if you have lots of cores don't you end up with memory bottlenecks?
19:54:19 <dons> then again, a 32 core GPU might be < 2k..
19:54:21 <SamB_XP> shapr: in that case, no, you should not get a mult-core box
19:54:23 <encryptio> SamB_XP: two 64 bit cores
19:54:31 <SamB_XP> or at least, not more than 2 or 4
19:54:37 <alexj__> can all the cores hit memory at the same time?
19:54:43 <encryptio> iirc, the new macbooks (not pro) also have two 64 bit cores
19:54:51 <shapr> alexj__: Memory bottlenecks already exist, most multicore boxes have a lot more memory bandwidth built-in.
19:55:05 <SamB_XP> alexj__: they better not try to all write the same memory at the same time...
19:55:06 <shapr> The biggest weakness of x86 boxes these days is the lack of memory bandwidth.
19:55:15 <dons> ?users
19:55:15 <lambdabot> Maximum users seen in #haskell: 275, currently: 245 (89.1%), active: 33 (13.5%)
19:55:20 <dons> shapr: ^^ new record over night
19:55:27 <shapr> yay!
19:55:46 <pkhuong> shapr: which is why you go with amd ;)
19:56:34 <alexj__> how much memory can you put in the 16core amd64 box?
19:56:44 <shapr> AMD puts memory controllers attached to their own CPU, so four cores could each have their own 1GB of ram.
19:56:47 * encryptio httracks a bunch of monad pages so he'll have something to read on his flight
19:57:35 <dons> alexj__: >32G anyway (32 G comes standard in the one i'm looking at)
19:57:44 <alexj__> shapr: then you need to write various wierd per-cpu memorymanagement/aching stuff, right?
19:57:56 <dons> alexj__: isn't that what the SMP runtime is for?
19:58:04 <shapr> It's in the hardware, I think.
19:58:09 <pkhuong> alexj__: it's transparent to the software.
19:58:39 <shapr> My Athlon MP box was NUMA, only half the ram slots were accessible if you had only one CPU.
19:58:41 <pkhuong> afaik, it just removes one bottleneck from the architecture (n cores -> 1 memory controller becomes 1 core/controller)
19:58:59 <alexj__> ok.  I am trying to get a feel for whether to push happs in the direction of shared memory or non-shared memory architectures.  do we tell people to scale by buying more boxes or by buying bigger boxes.
19:59:06 <shapr> 1+ years ago, Intel used a single memory bus.
19:59:22 <shapr> alexj__: With GHC-SMP, bigger boxes
19:59:27 <dons> on 06.10.31 we had a little bet on when #haskell would hit 300 (hit had just hit 250)
19:59:30 <dons> 15:58:24 <dcoutts> so, one year from now
19:59:33 <sjanssen> surely, shared memory is easier to implement?
19:59:39 <sjanssen> @users
19:59:40 <lambdabot> Maximum users seen in #haskell: 275, currently: 246 (89.5%), active: 32 (13.0%)
19:59:44 <dons> and I bet on just before christmas
19:59:45 <dufflebunk> alexj__: if you're looking for reliability you have to move to multiple boxes
19:59:50 <dons> so we'll see..
20:00:02 <shapr> Reliability is a separate issue though.
20:00:37 <encryptio> sjanssen: then you've got to do hardware memory locks on every read and write...
20:00:45 <encryptio> unless you're super clever
20:00:51 <pkhuong> encryptio: or use haskell.
20:00:54 <shapr> There's a lot of super-clever stuff out there.
20:00:59 <sjanssen> encryptio: not necessarily. STM is supposed to be pretty performant
20:01:08 * dufflebunk points to Erlang for really really nice multi threading
20:01:43 <dons> dufflebunk: does Erlang support concurrency abstractions other than the message passing model?
20:01:54 <shapr> NUMA requires cache coherence as well, whenever main memory is updated anywhere, each CPU cache must be either flushed or checked to see if it holds some of that data.
20:02:42 <shapr> It ends up being roughly equivalent to hardware GC, imho
20:02:49 <dufflebunk> dons: Nope. But internally it uses pointers and shared memory when it can
20:03:13 <dons> so no MVars, Chans, TVars, par / forkIO / par arrays to play with? :/
20:03:50 <pkhuong> dons: it feels much lower level in a certain way.
20:03:59 <dufflebunk> No idea what those are.
20:04:24 <shapr> alexj__: Tyan S4881G2NR Quad Socket mobo supports 64GB of ram, costs $1600 - http://www.newegg.com/Product/Product.asp?Item=N82E16813151008
20:04:28 <lambdabot> http://tinyurl.com/mkm5r
20:04:43 <dolio> Well, forkIO + Chans is basically what erlang does, no?
20:04:51 <dons> I *think* so
20:05:00 <shapr> The reviewer there says he runs four dual cores on that mobo.
20:05:17 <dolio> Only it's a little easier, since there's syntax designed around them.
20:05:19 <dons> shapr: we're looking at 4 dual cores on an 8 socket mobo
20:05:27 <shapr> Wow
20:05:28 <dufflebunk> parallel array operations is easy, just use map and spawn new processes
20:05:43 <dons> you want to use gang threads underneath though
20:05:52 <shapr> Is it an amd system?
20:05:56 <dons> since a pool of worker threads is way better than forking all the time
20:06:15 <dons> and then you get issues with fusing pipelines over structures
20:06:19 <dons> shapr: yep
20:06:20 <alexj__> shapr: nice.  I really like the idea of being able to scale using ec2, but perhpas the story is that we use s3 and buy these boxes to scale.
20:06:34 <dufflebunk> Not with Erlang, it's usually better to spawn new processes... but it's processes are extremly light
20:06:44 <shapr> alexj__: ghc-smp on that hardware would definitely scale.
20:07:01 <dolio> Well, erlang's processes are all lightweight, and then they distribute them across OS threads, I assume.
20:07:09 <dons> dufflebunk: same in haskell (haskell / erlang threads are about the same)
20:07:22 <dons> but there's still a benefit we find to fork once, and hand jobs down
20:07:26 <shapr> alexj__: Though, images with EC2 fits more into your vision of 'zero maintenance'.
20:07:34 <dons> dolio: right.
20:07:45 <dufflebunk> dolio: I don't know, I do know it has it's own internal scheduler
20:08:00 <SamB_XP> can't they distribute erlang threads across machines?
20:08:10 <dolio> dufflebunk: Well, I imagine they only use os threads when there are multiple cores.
20:08:14 <LoganCapaldo> I believe they can
20:08:18 <dufflebunk> SamB_XP: Yeah, transparently
20:08:52 <alexj__> shapr: yes and true scalabilty would be an architecture that allows you to grow linearly by adding ec2 instances.  the big box model means that you have to rearchtitect once you max out the biggest box you can find.
20:08:57 <dolio> But I don't know. Maybe they do something else to make use of multiple processors.
20:11:01 <alexj__> shared memory is really nice.  its too bad you can't have hotswappable memory addressable like a SAN.
20:21:32 <dons> ?users
20:21:32 <lambdabot> Maximum users seen in #haskell: 275, currently: 244 (88.7%), active: 31 (12.7%)
20:23:00 <LoganCapaldo> a watched pot never boils
20:24:22 <pkhuong> damn. someone should have told me before.
20:27:24 <robreim> Sure it does. I've watched a pot until it boils. Anyone who says differently just hasn't been patient enough to watch it the whole time.
20:29:47 <LoganCapaldo> It's just a turn of phrase
20:30:10 <LoganCapaldo> (go ahead say it, "How do you turn a phrase?")
20:30:39 <robreim> ok. how do you turn a phrase?
20:30:45 <eviltwin_b> what it really says is that the kind of personwho watches a pot until it boils is the kind without patience.  (except when it's the kind of person who enjoys watching paint dry too :)
20:31:28 <Thomas2> hmm.
20:31:38 * Thomas2 is surprised you can't extract a range of values from a Map
20:31:42 <robreim> It could be the kind of person who has nothing more interesting to do... or has more interesting things to do but is trying their best to procrastinate doing them.
20:34:01 <robreim> aw. I was hoping LoganCapaldo had an answer to that question given he wanted me to ask it :(
20:34:13 <LoganCapaldo> lol
20:34:16 <LoganCapaldo> No sorry
20:34:41 <eviltwin_b> ?siht ekiL
20:34:42 <lambdabot> Maybe you meant: dict list
20:34:48 <eviltwin_b> heh
20:35:08 <sjanssen> @type Data.Map.split
20:35:09 <lambdabot> forall a k. (Ord k) => k -> Data.Map.Map k a -> (Data.Map.Map k a, Data.Map.Map k a)
20:35:10 <dons> shapr: just spoke to roman, and showed him the nbody shootout benchmark (using Double arrays)
20:35:21 <sjanssen> Thomas2: ^^^
20:35:22 <dons> he said "oh, but that's trivial to parallelise with parallel arrays"....
20:35:39 <pkhuong> did he do it?
20:35:46 <dons> he's working on it :)
20:35:52 <pkhuong> unfair :)
20:35:58 <dons> i.e. change the import Array to import Data.Parallel.Array
20:35:59 <sjanssen> dons: the key question: will the shootout consider it cheating?
20:36:16 <dons> he said the current 4x slow down for the double math, compared to Clea
20:36:19 <dolio> Are the shootout boxes multi-processor?
20:36:27 <dons> l is purely because of the GHC->GCC mismatch in the code generator
20:36:29 <dons> dolio: nope
20:36:46 <Thomas2> sjanssen: this is well known?\
20:37:01 <sjanssen> Thomas2: nah, I just remembered seeing something like it
20:37:07 <dons> pkhuong: I suspect its not cheating if the arrays are transparently parallel
20:37:08 <sjanssen> @docs Data.Map
20:37:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
20:37:12 <sjanssen> you have seen that, yeah?
20:37:19 <Thomas2> yeah, that's what I'm looking at
20:37:19 <dons> i.e. if you just "import Data.Array.Parallel"
20:37:22 <dons> then its fair game.
20:37:31 <dons> (since the compiler is working out the parallelism for you)
20:37:33 <Thomas2> there are a million things I can do, but none of them allow me to supply two keys and get a range of hits
20:37:36 <Thomas2> ditto sets
20:37:59 <sjanssen> Thomas2: it's really simple to do that with the split function
20:38:41 <Thomas2> sjanssen: yes, but if I expect to get few elements (in this case 1, the point is to check a range only has 1 element), i think that's inefficient
20:39:13 <Thomas2> yeah, we're allocating O(n) intermediate objects which will immediately be freed
20:39:19 <Thomas2> erm, O(log n)
20:39:33 <sjanssen> allocating and then freeing is very cheap, but I catch your drift
20:40:22 <Thomas2> well, this operation is used *everywhere*, and probably dominates the performance of the system
20:40:53 <dons> Thomas2: you've profiled?
20:41:34 <dons> Thomas2: btw, if you ever want to chat haskell issues, we can talk over coffee :) i'm happy to help out
20:41:50 <Thomas2> dons: no, but I strongly suspect. remember the physical space model phil does everything with?
20:42:03 <dons> yep
20:42:14 <dons> that was a big Map?
20:42:17 <dons> (or was that something else?)
20:42:45 <sjanssen> hmm, is there a way to cheat and access the internals of Map?
20:42:52 <Thomas2> well, it was a custom tree for evil reasons
20:42:56 <dons> sjanssen: don't think so
20:42:58 <Thomas2> some of which may be going away
20:42:59 <dons> Thomas2: ah yes
20:43:22 <Thomas2> but I was interested in whether you could quickly produce a list of associations within a range
20:43:42 <dons> ah you want ranged sets maybe?
20:44:07 <sjanssen> Data.Map should have a "viewMap :: Map k a -> Maybe (Map k a, (k, a), Map K a)"
20:44:26 <Thomas2> ranged sets?
20:44:37 <dons> sjanssen: yeah
20:45:23 <dons> Thomas2: not sure, exactly, if its what you need: http://sourceforge.net/projects/ranged-sets/
20:45:42 <sjanssen> maybe I'll write one of those trendy library proposals
20:45:57 <Thomas2> dons: no, not that complex
20:46:23 <Thomas2> http://www.cse.unsw.edu.au/~java/documentation/jdk1.4.2/docs/api/java/util/SortedSet.html#subSet(java.lang.Object,%20java.lang.Object)
20:46:25 <lambdabot> Title: SortedSet (Java 2 Platform SE v1.4.2), http://tinyurl.com/wtxgr
20:46:42 <Thomas2> that interface describes 6 operations, and one is to take a range
20:47:25 <sjanssen> after further consideration, I agree that split will be somewhat slow
20:47:47 <Thomas2> not hugely, probably much better than current implementation, but point remains
20:48:14 <sjanssen> Map is strict, so the tree will have to be rebalanced after each split call
20:48:41 <Thomas2> oh, ouch, that will hurt
20:56:05 <sjanssen> Thomas2: if you do end up rolling your own (which sucks, my condolences), consider Data.FingerTree.  It should support range queries quite well
20:56:25 <sjanssen> @google Data.FingerTree
20:56:31 <lambdabot> http://www.soi.city.ac.uk/~ross/software/html/Data-FingerTree.html
20:59:13 <emu> is there a "standard library" for operating on pathnames?
20:59:38 <desrt> glib has some functions :)
21:00:35 <dons> emu: the new FilePath library, yes.
21:01:12 <dons> ?where+ FilePath http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
21:01:12 <lambdabot> Done.
21:01:32 <desrt> ?where dons
21:01:32 <lambdabot> http://www.cse.unsw.edu.au/~dons
21:02:32 <dons> heh
21:02:41 * desrt learns by experiment
21:05:18 * dons is loaded on caffeine! code fest!!
21:05:52 <vincenz> :D
21:05:57 <vincenz> go dons go!
21:10:47 <pkhuong> same here, but it's midnight :|
21:12:40 <dons> code for all!
21:13:00 <dons> ?type fmap -- forall code!
21:13:02 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
21:17:59 <yiddel> > let sep c l = iterate (break (== c) . snd) ("", l) in sep ':' "hello:world"
21:18:01 <lambdabot>  [("","hello:world"),("hello",":world"),("",":world"),("",":world"),("",":wor...
21:18:21 <yiddel> better way of above?
21:18:36 <yiddel> ie make break work on lists
21:24:36 <dmead> hey all
21:24:42 <dmead> is Hunit included with hugs?
21:25:10 <dons> I think so
21:26:02 <dmead> =/
21:26:07 <Lemmih> > let sep c l = takeWhile (/=("","")) $ iterate (break (== c) . dropWhile (==c) . snd) ("", l) in sep ':' "hello:world"
21:26:09 <lambdabot>  [("","hello:world"),("hello",":world"),("world","")]
21:26:23 <dmead> cann't find module =(
21:26:31 <dmead> with import HUnit
21:26:48 <Lemmih> dmead: :l Test.HUnit?
21:27:22 <dmead> oh
21:27:24 <dmead> yea that works
21:27:26 <dmead> thanks =)
21:27:54 <dmead> Lemmih ++
21:29:08 <dons> Lemmih++
21:29:11 <dons> (syntax that works)
21:29:19 <dons> ?karma Lemmih
21:29:20 <lambdabot> Lemmih has a karma of 26
21:29:37 <emu> i think i just hacked support for a HOOGLEPATH into hoogle
21:29:41 <yiddel> thanks Lemmih :)
21:30:03 <dmead> Lemmih++
21:30:07 <dmead> =p
21:30:27 <dmead> ?karma dmead
21:30:28 <lambdabot> You have a karma of 2
21:30:30 <dmead> ;o
21:30:33 <yiddel> guess im going to have to be helpful to get some of that eh?
21:30:45 <dmead> ?karma dons
21:30:45 <lambdabot> dons has a karma of 90
21:30:50 <dmead> ;o
21:31:03 <yiddel> yiddel ++
21:31:09 <dmead> - space
21:31:09 <yiddel> ?karma yiddel
21:31:10 <lambdabot> You have a karma of 0
21:31:17 <yiddel> darn
21:31:32 <dmead> yiddel++
21:32:38 <vincenz> yodel++
21:33:21 <yiddel> hmm, now how would i do this? liftM_ iterate (yiddle++)?
21:34:18 <emu> @type repeatM
21:34:20 <lambdabot> Not in scope: `repeatM'
21:35:56 <dons> ?type Control.Monad.repeatM
21:35:57 <lambdabot> Not in scope: `Control.Monad.repeatM'
21:36:01 <dons> (oh, 6.6-ism)
21:36:53 <emu> is hs-plugins whats holding up lambdabot for ghc 6.6?
21:48:54 <dons> emu: yep
21:49:06 <dons> emu: you can build lambdabot by default without hs-plugins with 6.6 though
21:49:12 <dons> just use the .cabal-6.6 file
21:52:17 <vincenz> lol
21:52:19 <shapr> dons: That's great! I wonder how many of the problems can be parallel?
21:52:24 <vincenz> I found the biggest troll ever
21:53:07 <Adamant> vincenz, where?
21:53:17 <vincenz> http://groups.google.com/group/comp.lang.lisp/browse_frm/thread/25a9a0b117e725e1?hl=en
21:53:19 <lambdabot> Title: Google Groups : comp.lang.lisp, http://tinyurl.com/y4fuac
21:53:22 <vincenz> read through this thread
21:53:27 <vincenz> ken tilton
21:53:55 <pkhuong> he's not even a troll
21:54:00 <vincenz> no?
21:54:01 <pkhuong> he's somethingelse.
21:54:09 <vincenz> you mean > troll
21:54:29 <pkhuong> he never begins a thread, only answers in the most infuriating way possible.
21:54:48 <vincenz> yeah, and for the rest remains quiet
21:54:52 <vincenz> until he can jump on someone
21:54:56 <dons> the best trolls are the ones that begin threads
21:54:58 <shapr> horribly maimed by a lisp repl as a child?
21:54:59 <vincenz> people like that should be banned from the interwab
21:55:13 <vincenz> shapr: lol
21:55:25 <pkhuong> shapr: he <3s CL.
21:55:35 <sjanssen> I'd like to see this guy vs. qwe1234
21:55:53 <shapr> qwe1234 is clueless, he's not any good as a troll.
21:55:56 <dons> yeah
21:55:56 <vincenz> sjanssen: qwe1234 would die a horribble death
21:56:09 <dons> xah lee however, there's a troll
21:56:10 <shapr> Good trolls have at least some clue.
21:56:17 <vincenz> dons: he'd die a horrible death too
21:56:36 <vincenz> he's not dumb, but he's aggressive as ever, this guy
21:56:46 <vincenz> oooh!!
21:56:48 <vincenz> smerdy vs kt
21:56:58 <shapr> I think xah is a fanatic who's convinced there is a single right solution, and everything else is wrong.
21:57:02 <vincenz> now there's a fight worth watching
21:57:16 <shapr> smerdy is just frickin immune
21:57:19 <vincenz> and as warmer upper, xahlee vs qwe1234
21:57:20 <psykotic> smerdy?
21:57:24 <dons> shapr: that's and the rampant misogyny
21:57:25 <vincenz> shapr: so is this guy
21:57:31 <psykotic> celebrity trollmatch
21:57:34 <dons> hehe
21:57:38 <shapr> psykotic: smerdyakov
21:57:50 <dons> i don't think trolls can fight amongst themselves though
21:57:59 <dons> they need living breathing human hosts in order to feed and grow strong
21:58:02 <sjanssen> dons: is there a secret handshake?
21:58:08 <vincenz> I think they have a (if-troll? other (don't-troll other))
21:58:11 <dons> on their own they're lifeless, like viruses
21:58:24 <vincenz> shapr: seriously, read the thread
21:58:38 <shapr> no way
21:58:40 <vincenz> kt is on the level of smerdy
21:58:45 <shapr> I'd rather do something productive
21:58:53 <vincenz> it's entertaining!
21:58:56 <greentea> 'smerdy'?
21:59:13 <shapr> Smerdy is the only person where I've ever wanted to fly to their house and beat them up after chatting on IRC. I'd rather not repeat that experience.
21:59:21 <psykotic> hehe
21:59:23 <greentea> Ah.
21:59:31 <vincenz> he's the reason I left #ocaml
21:59:38 <shapr> greentea: Smerdyakov
21:59:41 <vincenz> well, implicitly
21:59:47 <vincenz> he sort of tends to kill any and all conversation
21:59:51 <vincenz> so it's silent as hell in there
22:00:01 <vincenz> you can hear the ping-pongs cricket
22:01:03 <shapr> greentea: He's on #scheme, isn't he?
22:01:11 * dufflebunk wants to see crickets play ping pong
22:01:44 <vincenz> I said "ping-pongs cricket" not "crickets ping-pong" :D
22:01:47 * dons wants to play ping pong with cricket bats
22:01:52 <greentea> shapr: Don't know, sorry; i've only joined #scheme recently.
22:02:02 <sjanssen> apparently Smerdyakov means something similar to "shithead" in Russion
22:02:05 <sjanssen> Russian
22:02:33 <sjanssen> according to the Wikipedia article on The Brothers Karamazov
22:02:59 <psykotic> haha
22:03:23 <psykotic> shapr: nope, haven't seen him on #scheme.
22:03:39 <vincenz> he's on ##c
22:04:23 <pkhuong> didn't someone plan on creating a non-sucky (not filled with 13 yo punks) ##c/##c++, btw?
22:04:26 <shapr> Does he tell people that SML is the One True Way?
22:04:44 <Botty> quick google on smerdyakov: http://www.schizomaniac.net/
22:04:45 <lambdabot> Title: Adam Chlipala
22:04:52 <Botty> "Smerdyakov on freenode"
22:05:06 <shapr> Yup, that's him.
22:05:09 <emu> kt isnt a troll
22:05:41 <emu> oddly, i've met both of thm
22:06:07 <vincenz> emu: ?
22:06:58 <emu> kt in NYC, lisp conference and all, and smerdy at school
22:07:31 <vincenz> I meant, why are you saying he's not a troll
22:08:02 <emu> i dunno, he has a weird style, sometimes it comes across poorly
22:08:16 <vincenz> I use troll in a more general sense
22:08:27 <vincenz> I used it here in the sense that he beats down on everyone
22:09:23 <Botty> holy crap, knew smerdy sounded familiar - about 2 years ago he was trying to convince me to throw out my mouse
22:09:36 <emu> he's generally pretty friendly, maybe overly friendly
22:09:51 <vincenz> emu: I guess he has a difference facet in NGs :)
22:10:04 <vincenz> pseudo-anonimity on the net can make people do weird things
22:10:15 <emu> he runs the LispNYC group
22:10:20 <vincenz> (and somehow the grammar feels off in that sentence)
22:10:24 <emu> i think cll just sours people
22:11:00 <vincenz> perhaps
22:11:04 <vincenz> what's smerdy like irl
22:11:26 <newsham> ?seen xerox
22:11:26 <lambdabot> xerox is in #haskell-overflow and #haskell. I last heard xerox speak 5h 12m 13s ago.
22:11:35 <dons> emu: I know the cure for CL bitterness
22:11:51 <dons> some pure, typed, monadic sweets!
22:12:00 <vincenz> dons: HAskell-HAppiness?
22:12:00 <emu> i think just as you'd imagine ;) bit scruffy, small, difficult to talk with
22:12:04 * dons hands around the lambda candies
22:12:26 <emu> i think at the time he was all about C++
22:12:32 * dons throws lambda candies to the crowd
22:12:34 <emu> and getting into SML
22:12:52 <shapr> Smerdy was at Haskell Workshop in Portland.
22:13:18 <shapr> pkhuong: What did you say before about unfoldr for explicit state machines?
22:13:38 <shapr> I can't remember my idea about explicit state machines with GADTs.
22:17:08 * emu is just poking at some elisp to integrate hoogle in
22:18:07 <vincenz> emu: emacs?
22:18:20 <vincenz> emu: why not use lambdabot as interface to hoogle
22:19:09 <xnito> I heard they took out memoizations in GHC, does ghc optimizations include any memoization?
22:21:00 <emu> vincenz: well i'm just invokign hoogle from the command line
22:21:06 <emu> vincenz: what does lambdabot add to that?
22:22:29 <dolio> GHC should memoize thunks upon evaluation, but it won't memoize unrelated function calls.
22:22:38 <vincenz> emu: oh, well lambdabot gives you a running process, that way you don't need to use elips, just start a console window in emacs (I don't know emacs but I know it's possible)
22:22:59 <vincenz> plus it gives you @type, @pl, and other nice features
22:23:00 <emu> oh sure, it's not a big deal though. i already have things going pretty much now.
22:23:00 <vincenz> @quote vincenz
22:23:01 <lambdabot>  then you call 1-800-GET_DONS
22:23:03 <vincenz> @quote vincenz
22:23:03 <lambdabot>  [Philippa] you can catch stuff off someone who's asymptomatic [vincenz] Philippa: only if you allow your body to become assymptotic with his [Binkley] nice typo [vincenz] it's a typo?
22:23:05 <vincenz> hmm
22:23:11 <vincenz> well one of my quotes is about lambdabot being a nice ide
22:23:19 <emu> definitely
22:23:20 <vincenz> emu: ok, just a suggestion :)
22:23:21 <dons> heh having an rss feed of haskell material seems to create the impression that i'm everywhere at once. http://programming.reddit.com/info/rlpb/comments
22:23:23 <lambdabot> Title: No more locks: concurrent lock free data in Haskell [pdf] (reddit.com), http://tinyurl.com/ylx8xa
22:23:23 <dolio> So "let w = expensive x y z in w + w" should only evaluate expensive once.
22:23:26 <emu> i just haven't been able to compile lambdabot til now
22:23:34 <emu> until dons pointed out the 6.6 cabal file
22:23:40 <dons> seriously guys, i recommend getting rss feeds of stuff you're interested in. its an easy way to appear more productive than you really are :)
22:23:57 <dons> emu: got it working?
22:24:03 <emu> its compiling
22:24:05 <psykotic> @quote Smerdyakov
22:24:05 <lambdabot> Smerdyakov hasn't said anything memorable
22:24:10 <dons> should "just work" if you use the right cabal file
22:24:12 <emu> what aggregator are you using
22:24:22 <dons> i'm using google's blog search feeds
22:24:24 <emu> i just browse planet.haskell
22:24:35 <vincenz> dons: blog search feeds?
22:24:37 <vincenz> dons: link?
22:24:40 <xnito> so if i Have function [Int] -> Bool which takes 2 secs to calculate will i have to wait another 2 seconds to calculate it?
22:24:40 <dons> as well as planet, reddit and a few others
22:25:05 <dons> vincenz: http://www.google.com.au/blogsearch?as_q=haskell+programming&hl=en
22:25:09 <lambdabot> Title: Google Blog Search: haskell programming, http://tinyurl.com/w7o36
22:25:17 <dons> (you might want to tweak it to bring back recent results, or sorted by date)
22:25:25 <sjanssen> xnito: if you want sharing, you'll probably have to be explicit about it
22:25:59 <sjanssen> xnito: by using let, keeping track of results in a data structure, etc.
22:26:06 <eviltwin_b> that seems odd, any function not involving a monad should be cacheable
22:26:09 <vincenz> dons: ooh nice
22:26:41 <xnito> but that would eat up lots of memory
22:27:01 <sjanssen> eviltwin_b: in principle, it could be.  But in practice, it's hard to tell when to save and when not to
22:27:47 <shapr> There are cases where it's easier to recalculate than to cache.
22:28:04 <sjanssen> exactly
22:28:44 <sjanssen> take the even function.  It's very quick, so any attempt to memo will be more slow than evaluating the function each time
22:29:49 <sjanssen> > sum . filter even $ [1..10000] -- think how slow this would be with caching overhead for each element
22:29:51 <lambdabot>  25005000
22:30:21 <pkhuong-> sjanssen: not just that, but also GC. Do you make memo tables weak on keys? Weak on values?.. Loads of fun :)
22:31:08 <xnito> like this http://rafb.net/paste/results/47NU3W29.html
22:32:05 <eviltwin_b> well, I'd think the compiler should be smart enough to realize it's not going to be reusing the results there so there's no need to memoize
22:32:11 <sjanssen> pkhuong-: and once you've tackled that, do you attempt to tackle memoization things that are not pointer equal but are still equivalent?  Sooo many worms . . .
22:32:25 <emu> ok lambdabot compiled=)
22:32:31 <eviltwin_b> I wouldn't try to touch that one
22:32:33 <sjanssen> xnito: the best thing to do is put a "where x = length a" after your guards, and use x instead
22:32:35 <dons> emu: cool
22:32:43 <xnito> ok
22:33:29 <pkhuong-> sjanssen: of course, that's not a problem if everything (or at least, all your constructors) is memoised ;)
22:34:23 <sjanssen> heh, the day (:) uses a memo table, shoot me
22:34:32 <dons> heh
22:34:44 <eviltwin_b> ...and I'd not expect it to cache the result for a later use unelss that exact expression (or a subexpression thereof --- but in this case I'd clamp it for length) were reused
22:34:44 <emu> is lambdabot invoking ghci to get the type of an expression?
22:34:49 <sjanssen> somebody ought to write a Haskell RTS that does this
22:35:01 <pkhuong-> sjanssen: hash consing? Probably, yes.
22:35:06 <sjanssen> call it Elephant, because an elephant never forgets
22:36:09 <pkhuong-> you can have weak memo tables (except for things like Ints) on key (but not value) at least.
22:37:14 <eviltwin_b> maybe we're not talking abou the same thing.  I'm not talking about generic caching, more like CSE
22:37:26 <dons> emu: yep
22:37:42 <sjanssen> eviltwin_b: yeah, CSE could be improved
22:37:45 <emu> that doesn't work with user code though?
22:37:53 <xnito> http://rafb.net/paste/results/vGIfII34.html
22:38:10 <sjanssen> xnito: yes
22:57:33 <vincenz> off to work
22:57:34 * vincenz wave
23:03:33 * Botty finally gets epigram notation
23:12:02 <lispy> sjanssen: doesn't ghc-api provide a haskell rts for doing things like getting type information?
23:12:27 <sjanssen> lispy: I don't know much about ghc-api
23:12:50 <lispy> sjanssen: same here, but i have used Visuall haskell a fair but, and it seems that ghc-api is what makes it possible
23:12:51 <sjanssen> I think Elephant would be a radical departure from regular Haskell
23:13:07 <sjanssen> it wouldn't even need a garbage collector
23:18:12 <pkhuong-> sjanssen: it could use refcounting, I guess, but you could optimise the memory usage a lot w/ some sort of storage reclaimation.
23:25:08 <therp> good morning
23:29:38 <therp> oh no, not again broken linux resume from S3.
23:38:36 <satan> hello all
23:38:57 <Korollary> hi vancouver
23:39:04 <satan> if f a = b, then the least fixed point of f occurs when a = b, right? cause then we'd get f b = b
23:39:27 <satan> but what about f _|_, since f _|_ = b too....even though it doesnt satisfy f x = x
23:39:35 <satan> Korollary: talking to me?
23:39:40 <Korollary> yes
23:39:48 <satan> Korollary: well, hello then :)
23:40:30 <dolio> > fix (const 5)
23:40:32 <lambdabot>  5
23:41:31 <Botty> what does fix do? whenever I see it I think "Well, why was it broken in the first place?" ?
23:41:45 <satan> finds least fixed point? or just fixed point?
23:41:52 <Korollary> finds it
23:41:57 <dolio> fix f finds the least fixed point of f.
23:42:14 <satan> ok so here it would be when a = b then
23:42:15 <Botty> ah
23:42:54 <Korollary> In order to understand the significance of fix, you need to know lambda calculus first. But, it's not something one needs to know in order to write haskell per se.
23:43:27 <Botty> yeh, i've been avoiding it
23:44:06 <satan> right i'm trying to get the hang of lambda calculus too
23:44:15 <satan> do you know any good tutorials/sites you might recommend?
23:44:23 <Korollary> I can dig up a link
23:44:26 <dolio> It more or less allows you to write generally recursive functions in terms of non-recursive higher order functions.
23:44:29 <satan> if you don't mind
23:44:40 <satan> ok
23:44:54 <Korollary> http://www.cs.utah.edu/plt/publications/pllc.pdf
23:44:58 <lambdabot> http://tinyurl.com/t3ues
23:45:30 <Korollary> see section 3.6 there
23:51:06 * Korollary hopes that George RR Martin is doping himself to finish A Dance with Dragons ASAP.
