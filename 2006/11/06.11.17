00:02:06 <psykotic> oh, it does have a jump instruction.
00:02:38 <psykotic> then you can still do indirection to a bounded number of known targets by using a dispatcher
00:02:38 <pkhuong> psykotic: yeah, conditional or unconditional branch, but no indirection there either.
00:03:50 <psykotic> (defunctionalization)
00:04:08 <pkhuong> psykotic: only 99 memory cells. Don't have space to waste on that :p
00:04:15 <psykotic> too bad :)
00:04:22 <psykotic> what's the exact problem? now i'm curious
00:05:13 <pkhuong> random assignments. That one was read 2 3-digit number in 4's complement, add or substract and output the result in 4's complement (and detect overflow).
00:05:38 <pkhuong> nothing really hard or interesting, just sort of long.
00:05:48 <pkhuong> good night :)
00:28:22 <bringert> dons: got the message, thanks!
00:33:21 <shapr> I want @index for a while dir of darcs repos...
00:34:50 <bringert> shapr: since you're everyone's user, I thought you might want to try the time package with parsing: http://www.cs.chalmers.se/~bringert/darcs/time/
00:34:50 <lispy> shapr: hmm?
00:34:53 <lambdabot> Title: Index of /~bringert/darcs/time, http://tinyurl.com/y4wmkp
00:35:18 <shapr> I'm really getting into this whole developer thing now...
00:35:30 <shapr> bringert: Yes, I can definitely use that.
00:36:11 <bringert> shapr: good to hear that, soon you'll be everyone's developer too
00:36:57 <shapr> I hope so :-)
00:37:22 <shapr> The hardest part of programming is understanding. Once I understand a problem, the solution is obvious.
00:37:40 <bringert> in haskell, yes :-)
00:38:04 <vegai> lispy: ""It is practically impossible to teach good programming style to students that have had prior exposure to Haskell: as potential programmers they are mentally mutilated beyond hope of regeneration."
00:38:20 <vegai> hmm, I might've misquoted there a bit :P
00:38:47 <vegai> (in reference to < lispy> imperative languages are getting harder to code in!)
00:38:54 * ValarQ slaps vegai around with a PDP-7
00:40:28 <skew> "For example, if one were to state that the simplest way to
00:40:34 <shapr> bringert: True, the solution is sometimes not obvious in Python.
00:40:37 <skew> store a value of 65536 in a 32-bit INTERCAL variable is: DO :1 <- #0$#256
00:40:59 <skew> any sensible programmer would say that that was absurd."
00:41:43 <skew> for some reason vegai mentioning the diffculties in getting Haskell students to use other programming languages brought that passage to mind
00:42:09 <skew> shapr: how are stuff? finding jobs?
00:42:16 <shapr> Have job
00:42:28 <shapr> Life is good.
00:42:36 <skew> that's good. A good job?
00:42:49 <shapr> Yeah, I get paid to produce BSD3 licensed Haskell source.
00:42:56 <ValarQ> shapr: having kr√∂samos yet?
00:42:57 <skew> nice!
00:43:00 <boegel> shapr: w00!
00:43:09 <skew> where can I find one?
00:43:14 <vegai> shapr: Can you feel the jealosy? ;)
00:43:33 <shapr> skew: If you're interested, I can talk to my boss :-)
00:43:42 <skew> where is this job?
00:43:48 <shapr> At home
00:44:06 <shapr> I'm doing contract work for HAppS
00:44:10 <skew> Ah.
00:44:27 <skew> sounds nice.
00:44:38 <vegai> Very nice.
00:45:52 * shapr pokes skew 
00:47:56 <robreim> Wow, nice! I want a haskell job :(
00:48:18 <robreim> as in... one that pays me now
00:49:44 <vegai> Once shapr has conquered the world, perhaps there'll be crumbs for all
00:49:49 <shapr> heh
00:50:45 <robreim> ooh yeah, gotta love economic rationalism's trickle effect. bbl
00:51:24 <vegai> "Can I write that monad transformer for you, sir? It'll be nice and shiny"
00:51:46 <dons> actually, i think we can make fromJust safer, and more like C, if we change:
00:51:47 <dons> fromJust Nothing  = error "Maybe.fromJust: Nothing"
00:51:47 <dons> to
00:52:02 <dons> fromJust          :: Arbitrary a => Maybe a -> a
00:52:02 <dons> fromJust Nothing  = arbitrary
00:52:02 <dons> fromJust (Just x) = x
00:52:05 <dons> who's with me!!
00:52:06 <dons> ?
00:52:17 <shapr> dons: That's really scary.
00:52:20 <dons> i know shapr'd go one of these.
00:52:41 <vincenz> dons: that's like c-coding
00:52:41 <dons> no one's programs would ever go wrong again
00:52:42 <shapr> dons: Oh hey, is plugs accessible on the web somewhere?
00:52:49 <dons> yeah
00:52:55 <dons> ?where lambdaweb
00:52:56 <lambdabot> http://lambdabot.codersbase.com
00:52:58 <shapr> aha
01:14:34 * shapr bounces cheerfully
01:18:25 <Itkovian> shapr: shouldn't you be ... like ... sleeping?
01:22:37 <shapr> Itkovian: Probably, but I'm coding.
01:22:48 <Itkovian> :-)
01:22:55 * lispy has been coding too
01:23:04 <lispy> but in SCALA!
01:23:13 <lispy> and not enjoying it very much
01:26:51 <lispy> more languages should be lazy
01:27:27 <lispy> i've already had a bug in the scala program i'm writing because something with side effect was being evaluated too often
01:27:30 <Cale> lispy: yeah, I agree
01:27:52 <lispy> i was creating a list of tuples like [(Double, IO ())]
01:28:01 <lispy> and when i put the IO () into the list it was getting evaluated
01:28:15 <Cale> hehe
01:28:25 <lispy> so all my actions happened when i created instances of my objects
01:28:38 <Maddas> lispy: do you think simply adding laziness to imperative languages would be a good idea?
01:28:43 <Cale> does scala eveen have first-class actions?
01:29:01 <lispy> Cale: well, it's purely functional if you want it to be
01:29:08 <lispy> Cale: monads can be easily implemented
01:29:20 <lispy> Cale: it has type inference and pattern matching too
01:29:22 <Cale> Are functions side-effecting by default though?
01:29:28 <lispy> yup
01:29:32 * Maddas doesn't know Scala. Does 'purely functional if you want it to be' mean anything more than that you can use pure functions if you want to?
01:29:34 <lispy> like in scheme or lisp
01:29:48 <Cale> okay, so you have to use something like () -> a, instead of IO a
01:30:03 <lispy> to have a mutable variable you have to declare it specially, but other side effects can be placed anywhere
01:30:29 <Maddas> lispy: Sounds like a fairly regular imperative setting to me :)
01:30:33 <Cale> I should probably learn a little bit of Scala :)
01:30:40 <Maddas> Yeah, it looked very interesting.
01:30:43 <lispy> Cale: right, and specifically i had to do this, [(1.0, \() -> firstAction), (1.0, \() -> secondAction)]
01:30:50 <Cale> yeah
01:31:12 <Cale> because the language is strict, so you have to do the explicit laziness trick :)
01:31:21 <lispy> and this is why lisp has a single character quote function :)
01:31:36 <Maddas> It's not the same at all :-)
01:31:38 <lispy> yeah, and they kinda tricked me with laziness
01:31:46 <lispy> Maddas: for this use it was
01:31:59 <Maddas> lispy: No; in lisp you'd do (lambda () foo)
01:32:15 <Maddas> (Unless I misunderstood your idea, of course)
01:32:22 <lispy> Maddas: for this could have done 'foo because later i'd just call it anyway
01:32:25 <lispy> or #'
01:32:41 <Maddas> Wait, are you referring to Common Lisp and using FUNCALL?
01:32:52 <lispy> sure
01:33:09 <Maddas> Can you give a small example, perhaps? I don't see how quoting gives you laziness as you used in the Scala example
01:33:22 <Maddas> (I assume that "\() -> foo" creates a thunk in Scala)
01:33:44 <lispy> i didn't really need laziness, i just needed to be able to not evaluate foo when i created the list
01:33:51 <Cale> I think we may be talking in terms of Scala translated into strict Haskell -- I don't know Scala's syntax :)
01:33:52 <Maddas> Oh, okay.
01:34:09 <lispy> yeah, scala syntax was () => foo
01:34:19 <lispy> pretty similar about lambdas
01:34:38 <lispy> one more point before i go to bed though
01:34:51 <Maddas> I don't see how 'foo will be similar to (lambda () (foo)) except if you use Common Lisp's FUNCALL (or APPLY, or similar), though :]
01:35:05 <Syzygy-> > \() -> "foo"
01:35:06 <lambdabot>  <() -> [Char]>
01:35:20 <skew> hey, has anybody used HOpenGL? I haven't gotten it to use depth buffering.
01:35:23 <Syzygy-> Hmmm. Can this actually be evaluated in Haskell...
01:35:27 <Maddas> lispy: Good night!
01:35:27 <lispy> in scala you can define a mutable value (basically an ST/IORef) with 'var' and an immutable value with 'val' and some other type of thing with 'def'
01:35:38 <Syzygy-> skew: I've used it a bit. Haven't been fiddling much with depth buffering though. Pastebin your code?
01:35:49 <Cale> I like the Rationale document. It makes it seem like they feel a little bit guilty for creating the language, but not guilty enough not to do it, as if creating a programming language is somehow inherently negative, and you have to provide enough benefit in the first place in order to do any good.
01:36:10 <lispy> so they said 'def' doesn't evaluate the RHS immediately like 'var' and 'val'
01:36:13 <lispy>  so i thought it was lazy
01:36:19 <lispy> that lead to many bugs in my coed too
01:36:42 <Syzygy-> Bugs in your coed?
01:36:48 <lispy> er code
01:37:25 <lisppaste2> skew pasted "GL with broken depth buffering" at http://paste.lisp.org/display/30077
01:37:36 <lispy> from the tutorial i read i thought that if i used 'def' and defined something which didn't have parameters that it would get evaulated once whenit was needed and then stay that value
01:37:49 <lispy> but instead it's just a function with no parameters which is evaluated every time it's used
01:38:02 <lispy> ?where nehe-tuts
01:38:02 <lambdabot> I know nothing about nehe-tuts.
01:38:41 <lispy> skew: i don't remember if there are any depth buffer examples here, but maybe this will help: http://projects.codersbase.com/repos/nehe-tuts/
01:38:45 <lambdabot> Title: Index of /repos/nehe-tuts, http://tinyurl.com/z45ck
01:38:54 <lispy> skew: it's just some small example programs using HOpenGL
01:39:19 <skew> I think I've got all the things that tutorials say are necessary, it even agrees with what I can translate from straight C examples
01:39:53 <lispy> what is broken about it?
01:40:01 <skew> have you tried running it?
01:40:19 <skew> as it spins some of the cubes that should pass in front are going behind instead
01:40:27 <skew> looks like it's just working in draw order, perhaps
01:40:41 <shapr> I think that started happening with ghc6.4
01:41:01 <shapr> iirc, Igloo wrote a spinning cube that worked fine before that, and with 6.4 it started having that exact problem.
01:41:17 <astrolabe> @time shapr
01:41:18 <lambdabot> Local time for shapr is Fri Nov 17 03:40:04 2006
01:41:22 <astrolabe> @time Cale
01:41:24 <lambdabot> Local time for Cale is Fri Nov 17 04:40:11
01:41:35 <shapr> yow, it's nearly 4am
01:41:41 <astrolabe> Have you guys heard of bed?
01:41:49 <lispy> of what?
01:42:13 <Syzygy-> skew: Depthbuffering works with your code on my box.
01:42:16 <Syzygy-> ghc 6.6
01:42:42 <skew> odd, same here
01:42:42 <Syzygy-> (at least I think it does)
01:42:47 <lispy> hrm
01:43:14 <Syzygy-> No, wait, it doesn't.
01:43:21 <Syzygy-> But it was a bit tricky to see that it didn't.
01:43:27 <lispy> i tihkn there is a bug in your program
01:43:31 <skew> + and - speed ans slow the rotation
01:43:36 <lispy> i should not get bus errors
01:43:49 <shapr> @where bed
01:43:50 <lambdabot> I know nothing about bed.
01:43:58 <shapr> astrolabe: Sorry, can't help you.
01:44:18 <astrolabe> :)
01:44:23 * shapr grins
01:44:50 <ValarQ> shapr: still running on CEST? :)
01:45:18 <shapr> Yeah, something like that.
01:45:55 <shapr> I was really hoping to get around to making Hugs packages for my Nokia 770 tonight, but I'll just use lispy's online lambdabot to show off Haskell to this guy tomorrow at lunch.
01:46:22 <lispy> shapr: i'll remember to break it in the meantime :)
01:47:56 <lispy> skew: i wonder why your program getsa bus error
01:47:58 <shapr> noo
01:48:20 <lispy> skew: i just tried some other hopengl programs i have and not a single problem
01:48:45 <skew> weird
01:48:49 <skew> I have not a single problem
01:51:21 <skew> besides the depth buffering - but those nehe-tuts seems to get depth right
01:51:33 <Syzygy-> nehe-tuts?
01:51:35 <shapr> ask Igloo when he's awake
01:52:14 <lispy> skew: do you clear the depth buffer?
01:53:04 <lispy> Syzygy-: yeah, i started converting the nehe opengl tutorials to haskell
01:53:16 <skew> yes, "  clear [ColorBuffer, DepthBuffer]"
01:53:19 <lispy> ah yeah in display you clear them
01:54:11 <Cale> yeah, I just woke up :)
01:54:44 <astrolabe> frightening
01:56:02 <astrolabe> If you have more than one version of ghc installed, how do you manage them?  rename the ghc.exe to ghc64.exe etc.?
01:56:29 <astrolabe> where you = anyone
01:56:33 <Syzygy-> nehe tutorials?
01:56:34 <Cale> keep them in separate paths?
01:57:09 <Cale> I have ghc6.7 installed in /usr/local/ and ghc6.4.2 installed in /usr/
01:57:13 <lispy> Syzygy-: i thought everyone know about them...hang on
01:57:25 <astrolabe> Cale I see, thanks.
01:57:30 <Cale> which makes 6.7 the default
01:57:48 <lispy> Syzygy-:      -- get a 640 x 480 window
01:57:49 <lispy>      initialWindowSize $= Size 800 600
01:57:50 <lispy>      -- window starts at upper left corner of the screen
01:57:51 <lispy>      initialWindowPosition $= Position 0 0
01:57:54 <lispy> oops
01:57:54 <astrolabe> 6.7?  Is that out?
01:57:56 <Cale> but yeah, you should also be able to do this by naming the executables separately
01:58:01 <lispy> Syzygy-: http://nehe.gamedev.net/
01:58:03 <Cale> astrolabe: it's a development version
01:58:04 <lambdabot> Title: NeHe Productions: Main Page
01:58:07 <Syzygy-> Hmmm. I get depthbuffering to work with the code from panitz tutorial...
01:58:40 <Syzygy-> lispy: Where's your translated tutorials?
01:58:56 <lispy> http://projects.codersbase.com/repos/nehe-tuts/
01:58:59 <lambdabot> Title: Index of /repos/nehe-tuts, http://tinyurl.com/z45ck
01:59:08 <lispy> Syzygy-: if you translate more, just send me some darcs patches
01:59:11 <Syzygy-> Ah. Ok.
01:59:17 <Syzygy-> :)
01:59:28 <lispy> ?where+ nehe-tuts darcs get http://projects.codersbase.com/repos/nehe-tuts/
01:59:29 <lambdabot> Done.
01:59:36 <Syzygy-> I'll see if I get into it ... need to try to focus on my research (though it's bloody difficult :)
01:59:47 <lispy> Syzygy-: understood
01:59:57 <Cale> lispy: does Scala obey operator precedence rules?
02:00:06 <lispy> Cale: what do you mean?
02:00:24 <Cale> I mean, does multiplication happen before addition
02:00:34 <Syzygy-> skew: Sorry that I can't help any more - but I'd be buggered to see why it doesn't work with your code... if not ... are you sure the thingies really do get different z-coordinates?
02:00:46 <lispy> Cale: i hope so, but good luck finding that bit of info in the documentation :)
02:00:49 <Syzygy-> (you probably are, and if so, I'm buggered to help more)
02:01:09 <lispy> Cale: look for ProgrammingScala.pdf (or somethnig close to that) seems to be the best ref
02:02:13 <lispy> Cale: i would imagine it follows the same rules at C on precedence since it seems to be bent on brining FP to the java crowd
02:02:21 <Cale> I ask because this infix rule of translating a f b into a.f(b), if it was applied too uniformly, would break operator precedence.
02:02:22 <lispy> Cale: so they mimic java in many places
02:02:48 <lispy> well, that rule doesn't even seem to work correctly
02:02:56 <lispy> and they screwed up on fold
02:03:08 <lispy> if you translated the type to haskell you'd basically have
02:03:10 <lispy> ?type foldl
02:03:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:03:23 <lispy> foldLeft :: (b -> b -> b) -> b -> [b] -> b
02:04:10 <lispy> (well, modulo parameter order)
02:04:22 <lispy> and to call it you have to use werid syntax
02:04:34 <lispy> xs.foldLeft(defaultValue)(function)
02:04:47 <lispy> which seems like the it's just currying
02:05:00 <lispy> but if you try xs.foldLeft defaultValue function you get erros
02:05:10 <lispy> maybe i needed to try foldLeft xs defaultValue function
02:05:36 <lispy> anyway, many things have confused me so far
02:05:49 <lispy> it's like they had the right idea but poor follow thorugh
02:07:41 * lispy goes to sleep
02:13:05 <Cale> aha, the precedence of an infix operator is determined by the operator's first character, on page 57. :)
02:14:00 <therp> vincenz: we have recently discussed two parameter O(..) notation. have a look at http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntSet.html - there are a few examples
02:14:02 <lambdabot> http://tinyurl.com/wqcbn
02:14:09 <Cale> and the associativity is determined by the last character -- in Scala, everything is left-associative unless it ends in :
02:14:18 <lispy> Cale: Brian would be proud
02:14:28 <Cale> hehe
02:15:12 <lispy> Cale: i probably should have read the manual more closely, but they have so many i didn't really know which to start with
02:15:38 <lispy> like why does foldLeft not allow you to create a list with a new type?
02:15:45 <Cale> yeah, and I don't see a good tutorial for people who actually want to learn the language from the beginning
02:15:54 <lispy> i really hope my failure to do that was just user error and now a flaw in the library
02:16:09 <lispy> s/now/not/
02:17:01 <Cale> where's the library documentation?
02:17:20 <lispy> Cale: you'll want this http://scala.epfl.ch/docu/files/ProgrammingInScala.pdf
02:17:23 <lambdabot> http://tinyurl.com/ya676a
02:17:26 <Cale> http://scala.epfl.ch/docu/files/api/index.html
02:17:29 <lispy> Cale: that seems to be the best tutorial i've found on the language
02:17:29 <lambdabot> Title: Scala Library Documentation, http://tinyurl.com/ykqbom
02:17:36 <Cale> there it is :)
02:18:17 <Cale> def  foldLeft  [b] (z: b)(f: scala.Function2[b, a, b]) : b
02:18:30 <Cale> I'm guessing that's a kind of type signature
02:18:31 <lispy> but what is the type parameter of List?
02:18:41 <Cale> @type foldl
02:18:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:18:51 <lispy> yeah, the first [b] says that b is a type variable local to that function
02:19:17 <lispy> so then, the first value has type b ( z: b)
02:19:27 <lispy> andthen f has type f :: b -> a -> b
02:19:34 <lispy> and the whole thing returns a b
02:20:22 <lispy> and they givea really cool use of mixins as an example on this page
02:20:22 <lispy> http://scala.epfl.ch/docu/files/api/scala/util/logging/Logged.html
02:20:25 <lambdabot> Title: Trait Logged in package scala.util.logging, http://tinyurl.com/y2ps2e
02:20:27 <lispy> but it doesn't compile :(
02:20:50 <lispy> as soon as you go to instantiate with the ConsoleLogger it will tell you that you need to override log, but you can't
02:20:53 <lispy> or at least i couldn't
02:21:55 <lispy> Cale: you might like these
02:21:57 <lispy> http://scala.epfl.ch/examples/more.html
02:21:59 <lambdabot> Title: The Scala Programming Language: More Examples
02:23:32 <lispy> the lazy example is neat in that you can do it
02:23:47 <lispy> but a bit sad because i don't want to have to go to all that work to create/use laziness :)
02:24:07 <lispy> but maybe i should since i was bitten by it already :)
02:25:08 <lispy> Oh, probably the coolest thing is that they tell you how to implment H-M type inference in one of the pdfs
02:26:04 <lispy> http://scala.epfl.ch/docu/files/ScalaByExample.pdf <-- that's the one with H-M inference
02:26:07 <lambdabot> http://tinyurl.com/y2ymmo
02:26:20 <Cale> Yeah, something tells me that Martin Odersky actually does know something about programming languages :)
02:26:27 <lispy> oh yeah
02:26:40 <Cale> As opposed to, say, Guido van Rossum
02:26:58 <lispy> as frustrating has this has been, i'd love to get to use scala at work over, say java/.NET
02:27:02 <Cale> that's maybe a little bit mean :)
02:27:10 <Cale> yeah
02:27:21 <lispy> i know nothing about Guido, but i do know people seems to polarize around him
02:27:46 <lispy> scala actually has a very NICE type systems
02:28:13 <lispy> and it seems to have blended the best of OO with many good FP ideas
02:28:18 <Cale> http://www.artima.com/weblogs/viewpost.jsp?thread=98196
02:28:22 <lambdabot> Title: The fate of reduce() in Python 3000, http://tinyurl.com/65lfo
02:30:28 <lispy> Cale: we use python at work a little, but i wish we used something else
02:30:35 <lispy> python isn't bad, but there are better things
02:30:39 <Cale> yeah
02:31:16 <lispy> i don't see why he thinks the list comp is more clear
02:31:22 <Cale> This document was just an example of GvR being stupid :) Also, he claimed that Haskell was doomed because it doesn't have loops.
02:31:32 <lispy> seeing 'map' expresses your intent rather plainly
02:31:58 <psykotic> cale: it's probably more a case of him being stuck in his ways than outright stupid. i know a lot of good programmers who are that way.
02:32:25 <Cale> Being set in your ways is a form of stupidity
02:32:41 <lispy> and did he just say, let's toss map, but let's add any and all?
02:32:55 <Cale> yes
02:32:59 <psykotic> cale: so people get stupid as become more experienced? that's nonsense.
02:33:02 <lispy> that's seems silly
02:33:21 <lispy> psykotic: hehe, there is that saying about PhDs ;)
02:33:24 * lispy leaves for real
02:33:27 <lispy> night all
02:33:41 <Cale> It's possible to learn things without turning them into the absolute word of God(tm)
02:34:02 <psykotic> sure
02:35:37 <astrolabe> Oh wow.  GtkToHs seems to work  :D
02:37:07 <robreim> GvR probably got miffed at Paul Graham's essay about Python being a half-arsed lisp and decided to make it as different to lisp as he could :P
02:37:32 <profmakx> what? C++ is not the absolute word of God?
02:37:35 <psykotic> i didn't know anyone with a clue actually took pg seriously :)
02:37:39 <Cale> [Haskell] is a strongly typed pure functional language, where just about everything is written as recursive functions, because the language has no looping construct.
02:37:40 <profmakx> now i?m confused
02:38:11 <Cale> Hello! Someone hasn't heard of higher-order functions!
02:38:12 <psykotic> cale: he ultimately comes from the algol tradition; look at his background. do you think you are smarter than knuth or dijkstra?
02:38:24 <psykotic> both of those guys see limited usefulness in functional programming.
02:38:51 <earthy> knuth as well as dijkstra grew up in a different world
02:39:02 <psykotic> that's right, and it comes back to the earlier point i was trying to make.
02:39:07 <earthy> both of them saw great usefulness in denotational semantics
02:39:21 <astrolabe> Cale, but he'd know it was a loop under the surface!
02:39:29 <psykotic> as far as i know dijkstra only did work in axiomatic semantics.
02:39:30 <astrolabe> um a recursion
02:39:38 <earthy> programming haskell is not much more than programming directly in denotational semantics
02:40:04 <earthy> psykotic: true. doesn't mean he didn't see the use in denotational semantics
02:40:15 <astrolabe> psykotic: what about dijkstra's algorithm?
02:40:18 <psykotic> what's your source on him being a fan?
02:40:25 <psykotic> astrolabe, what about it?
02:40:32 <earthy> not a fan, just not as much a basher as you imply. :)
02:40:36 <Cale> I sent a long message to Wirth recently, arguing for the usefulness of functional programming, actually :)
02:40:49 <astrolabe> It doesn't seem like denotational semantics.
02:41:16 <psykotic> astrolabe, did i mention dijkstra being a fan of denotational semantics? or anything about dijkstra or DS aside from my response to astrolabe's claims? :)
02:41:16 <astrolabe> er axiomatic semantics
02:41:34 <psykotic> oh, well i was talking about within the subfield of semantics and correctness of programs.
02:41:46 <psykotic> if you'd read his work you'll notice that he uses floyd-hoare style axiomatic semantics everywhere
02:42:59 <Cale> Have Knuth or Dijkstra made any comments to the effect of FP being useless?
02:43:05 <psykotic> anyway i guess my point about cale's comment on GvR relates more to arrogance or "laziness" than stupidity as such.
02:43:35 * earthy nods
02:43:37 <psykotic> cale: i didn't say they said it was useless. but there's a famous comment from dijkstra about functional programming in particular, i'll see if i can find it.
02:43:55 <psykotic> dijkstra is of course the most arrogant man in CS :)
02:44:06 <psykotic> no-one was more stuck in his ways than him, i think
02:45:32 <Philippa_> I think it's fair to point out that dijkstra will've missed some developments we all now take for granted, too
02:45:49 <Cale> yeah, he's missed the last 4 years in particular
02:46:26 <profmakx> sure Cale?
02:46:45 <earthy> Dijkstra is dead, and has been for a while, so, yeah. :)
02:46:59 <psykotic> i'm pretty sure he stopped following new developments about 15 years before i was born
02:46:59 <profmakx> perhaps he is watching
02:47:00 <Cale> and I'm not sure whether anyone told him about monads before he died
02:47:01 <profmakx> ^^
02:47:05 <Philippa_> yeah, but even before that a lot of stuff we in here do was highly obscure
02:47:11 <Philippa_> exactly
02:47:37 <Philippa_> hell, even the trick ST uses to scope its references properly
02:47:46 <earthy> otoh, there's a Dijkstra right next door
02:47:58 <earthy> but that's not EWD ;)
02:48:05 <robreim> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD12xx/EWD1213.html
02:48:08 <lambdabot> Title: E.W. Dijkstra Archive: Introducing a course on calculi (EWD 1213), http://tinyurl.com/yfx3c9
02:48:31 <astrolabe> I used some Dijkstra quotes in my haskell presentation.  Maybe he's turning in his grave :)
02:49:06 <Itkovian> is ghc6.6 available on ubuntu?
02:49:20 <psykotic> you should string together some outrageous claims from out-of-context quotes of his and i bet he'll rise as Zombie Dijkstra
02:49:28 <astrolabe> The other quote I used was the Blubb paradox, by someone who I think has disparaged haskell :)
02:49:50 <earthy> 'The clarity and economy of expression that the language of functional programming permits is often very impressive, and, but for human inertia, functional programming can be expected to have a brilliant future, the more so because today's computers admit quite efficient implementations of functional programming languages'
02:49:51 <Itkovian> apt-get claims 6.4 is the most recent version
02:50:18 <astrolabe> earthy: is that djikstra?
02:50:22 <psykotic> earthy, that's quite supportive. hmm.
02:50:25 <wolverian> Itkovian, no. submit a backport request if it's in the dev version.
02:50:25 <earthy> it is. in EWD 1213.
02:51:05 <psykotic> the quote i recalled was related to how the FP people overestimated the effect on how easy FP made it to write correct programs over algol-style languages. i'm trying to dig it out with google.
02:51:06 <Cale> Yeah, I'd always had the impression that he was somewhat supportive of functional programming
02:51:06 <Itkovian> wolverian: I'll compile it myself then, thx.
02:51:34 <wolverian> it is in feisty. I wonder if someone would like to backport it. hm.
02:51:48 <Cale> psykotic: they maybe even did, to some extent. It's really easy to write bugs in lisp :)
02:51:51 <Philippa_> I think it's true for values of FP including (for example) lisps
02:52:20 <Cale> We have really decent type systems now, which make wide classes of bugs a whole lot harder to write.
02:52:21 <psykotic> cale: lisp 1.5 certainly, which had little relationship to the lambda calculus.
02:52:26 <Philippa_> most of us could do pretty well in an algol with algebraic datatypes
02:52:44 <Philippa_> at least, if we could handle the syntax :-)
02:53:29 <Cale> I mean, if 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself "Dijkstra would not have liked this.", well, that would be enough immortality for me.
02:54:01 <astrolabe> heh.  Dijkstra was cool.  I'm glad he liked fp.
02:54:36 <psykotic> he was cool but started yelling at the kids to get off his damn lawn around 70 and never really did anything else :)
02:57:00 <Cale> He was also a fan of program derivation.
02:57:17 <psykotic> yeah though his was based on a very low tech/low power axiomatic semantics approach, from what i've read
02:57:38 <astrolabe> Does that mean deducing the program from the requirements?
02:57:38 <Cale> Well, they were probably the best people had at the time
02:57:41 * earthy knows ALGOL 68
02:57:45 <earthy> so, yeah
02:57:48 <Cale> yes, from the proof of correctness
02:57:50 <psykotic> cale: well he contined doing that in his recent notes too.
02:58:04 <psykotic> he definitely didn't seem to keep up with what what was happening in CS.
02:58:21 <basvandijk> Hello, I'm having trouble with the folllowing code: http://paste.lisp.org/display/30080 When I print for example a (Var "x") ghci gives a stack overflow. Why is that?
02:58:33 <astrolabe> I guess that isn't actually that practical at the moment (or we would all be doing it).  Why not?
02:58:38 <psykotic> compare to something like danvy's approach to program transformation, which i find completely beautiful.
02:58:57 <psykotic> or the bird-de moer calculational approach
02:59:20 <psykotic> astrolabe, well do you many people who even bothers to write a full spec for their programs? :)
02:59:21 <Cale> basvandijk: You have instance Show a => Show (Bhv a), but no implementation of show
02:59:27 <psykotic> *do you know many
02:59:36 <earthy> Oege de Moor was a student of Dijkstra, wasn't he? :)
02:59:53 <basvandijk> Cale: ok lets define one...
03:00:07 <earthy> but yeah, programming has devolved from it's humble beginnings in the '50's
03:00:11 <astrolabe> psykotic: but the reason for that, surely is that it isn't helpful enough to do it.
03:00:25 <earthy> when programmers were cheaper than machines and therefore had to deliver good code
03:00:28 <psykotic> astrolabe, well, that depends on how much you value correctness. some people do it.
03:00:37 <Cale> basvandijk: maybe even just add Show to the deriving clauses for your two datatypes.
03:00:53 <Cale> (er, or to the Bhv one anyway)
03:01:26 <psykotic> astrolabe, there's a formal specification language called Z (and associated model checkers) that are used by some companies working on high-reliability systems.
03:01:40 <Cale> That will require removing the explicit instance declaration.
03:01:43 <basvandijk> Cale: yes I had that before but ghci complained about it... but now I tried again and it works...thx
03:01:44 <astrolabe> psykotic: when I think about my programs I realise I often have to change my spec as I go, often in complicated ways, in order to make the program practical.
03:01:52 <psykotic> sure
03:01:53 <Cale> basvandijk: no problem
03:02:16 <astrolabe> psykotic:interesting
03:37:53 <fons> hi all
03:38:50 <fons> does anyone know if ghc 6.6 binaries are avialable for OSX 10.3?
03:39:13 <fons> in ghc it seems only avaliable for Tiger
03:42:53 <SamB_XP> which version is tiger?
03:43:28 * SamB_XP is not a Mac owner -- those things are expensive
03:44:56 <vegai> mine was 300e ;)
03:45:30 <vegai> fons: I haven't seen any
03:45:54 <fons> SamB_XP, 10.4
03:46:03 <SamB_XP> ah.
03:46:27 <SamB_XP> well, I would personally suggest that you use the existing 10.3 binaries to build one yourself
03:47:12 <fons> it seems to be avalible en macports ... lets see
03:53:59 <vincenz> ;
04:01:48 <Itkovian> SamB_XP: expensive, perhaps, but they rock
04:02:17 <SamB_XP> I expect they do...
04:06:56 <Itkovian> does ghc 6.6 yield better performing binaries compared to 6.4?
04:15:53 <christine> hi, anyone in there?
04:16:53 <Philippa_> 245 people, why?
04:17:29 <christine> need some help...
04:17:47 <Pupeno> Itkovian: as far as I know, some people worked hard to make 6.6 libs work faster than 6.4. That would lead to have faster programs in 6.6 than 6.4. If there's also a speed up of the binary (that is, better optimization), I don't know... (note: I am an outsider just repeating what I've heard).
04:17:55 <Pupeno> s/heard/read/
04:18:00 <Itkovian> Pupeno: thx
04:19:10 <rahikkala> christine: Just ask the question, whoever happens to be interested will answer
04:19:26 <Cale> Itkovian: one thing in particular is that Data.ByteString comes with 6.6
04:19:58 <Cale> Itkovian: which has had dramatic performance impacts on many things
04:20:08 <Itkovian> Ok, then I'll wait before compiling darcs
04:20:13 <christine> i had Winhugs (sept 06) installed and i need to uninstall it.
04:21:43 <profmakx> ?users
04:21:44 <lambdabot> Maximum users seen in #haskell: 270, currently: 247 (91.5%), active: 27 (10.9%)
04:22:22 <Cale> christine: okay -- I've never used WinHugs -- does it have an uninstaller in Add/Remove Programs?
04:22:44 <christine> no.
04:22:45 <Philippa_> Cale: I hadn't noticed that, how braindead am I?
04:23:37 <Philippa_> is anyone working on conversions to/from network order for ints and words? Given that as well, I think I'll be actually willing to think about doing non-trivial binary IO :-)
04:23:39 <Cale> Philippa_: there's lots of cool new libraries -- it's worth looking through the new hierarchy documentation carefully :)
04:23:55 <Cale> Data.Sequence seems particularly magical
04:23:56 <Philippa_> I know Network.CGI's been replaced, I should experiment with its successor
04:24:08 <Cale> christine: hmm
04:24:16 <vincenz> whois Cale
04:24:21 <Cale> christine: You really want to ask ndm.
04:24:31 <Cale> but he doesn't seem to be here at the moment
04:26:07 <Cale> vincenz: good question :)
04:26:14 <vincenz> yeah yeah
04:26:24 <vincenz> screw my multiple typos and tab completion
04:27:18 <christine> anyone else willing to help?
04:27:21 <Itkovian> heelo vincenz
04:27:46 <Itkovian> christine: I have no clue about windows machines
04:28:29 <Cale> Yeah, I'm sort of a bad person to ask, given that I haven't used windows an appreciable amount in the last 6 years :)
04:28:36 <vincenz> hiya Itkovian
04:28:43 <christine> itkovian: Thanks anyway...
04:28:52 <vincenz> christine: where in greece?
04:28:57 <Cale> @seen ndm
04:28:57 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 10h 33m 29s ago, and .
04:29:00 * vincenz is going to Greece for 3 months next year
04:29:04 <Cale> hmm.
04:29:08 <vincenz> Itkovian: HiPEAC project :)
04:29:11 <Cale> Yeah, he's usually on around now.
04:29:24 <Itkovian> vincenz: cool!
04:29:31 <vincenz> 1 july - 1 september
04:29:32 <vincenz> :D
04:29:50 <vincenz> er
04:29:50 <christine> vincenz:Ioannina...
04:29:58 <vincenz> 1 july - 30 sept, of course
04:30:03 <vincenz> christine: I'm going to xanthi
04:30:34 <christine> vincenz:what for?
04:30:40 <vincenz> A collaboration with the university there
04:31:30 <christine> vincenz:our university is beter though...
04:31:53 <vincenz> christine: Yeah but since I'm collaborating with specific people
04:32:06 <christine> vincenz:hope you will like it here...
04:32:10 <vincenz> me too :)
04:33:04 <christine> vincenz:we are far behind in tech...
04:33:42 <christine> vincenz:but we have cute girls...
04:33:48 <vincenz> christine: you're including yourself?
04:34:03 * vincenz looks at the name of the channel
04:34:04 <christine> vincenz: :-) maybe...
04:34:39 <vincenz> perfect
04:35:34 <christine> vincenz: can you help me?
04:35:44 <vincenz> Noe
04:35:45 * Cale imagines a #cute-girls in which everyone just talks about Haskell all the time.
04:35:46 <vincenz> Nope
04:36:09 <christine> ok...
04:36:13 <vincenz> I don't use windows
04:37:08 <Cale> christine: you're uninstalling it -- does the installation do much more than put a bunch of files in the installation directory?
04:37:30 <Cale> It looks like it has an actual installer program, so perhaps.
04:39:34 <vincenz> Cale: good luck on imagining sf
04:39:51 <Cale> sf?
04:40:26 <vincenz> scifi
04:40:33 <vincenz> #cute-girls-doing-haskell
04:40:55 <christine> vincenz: :-)
04:42:41 <dons> christine: you could ask on haskell-cafe@haskell.org, then ndm will at least see it in his mail
04:42:42 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:42:50 <dons> christine: btw, did you get your prefix function working?
04:43:45 <Cale> http://www.boasas.com/?c=725
04:43:47 <lambdabot> Title: [Boy on a Stick and Slither]
04:44:22 <christine> still trying, dont worry i will make it work...
04:44:32 <dons> great
04:47:14 <christine> i want to change my windows...
04:47:58 <christine> with something more funcional...
04:48:35 <syntaxfree> @pl f x = g x x
04:48:35 <lambdabot> f = join g
04:49:04 <vincenz> christine: you mean a rock?
04:49:19 <fabiim> do any general map exists? like map :: (a->b->[a] )
04:49:21 <fabiim> ups
04:49:28 <vincenz> @type map
04:49:30 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
04:49:42 <syntaxfree> what would a general map be?
04:49:48 <vincenz> @type fmap
04:49:50 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
04:49:54 <Cale> @type foldr
04:49:55 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
04:50:00 <vincenz> @type Cale
04:50:01 <lambdabot> Not in scope: data constructor `Cale'
04:50:02 <syntaxfree> @google bananas in space
04:50:04 <lambdabot> http://www.3dwonders.com/
04:50:05 <lambdabot> Title: 3D Wonders - Cool 3D Screensavers and Desktop Enhancements for Microsoft Windows
04:50:10 <Itkovian> haha
04:50:13 <syntaxfree> @google meijer bananas in space
04:50:15 <Cale> well, that's inappropriate :)
04:50:16 <fabiim> i meant , i want a map wich accept a function who haves more than 1 argument
04:50:17 <lambdabot> http://portal.acm.org/citation.cfm?id=224225&coll=portal&dl=ACM
04:50:30 <Itkovian> fabiim: I can't make anything from your type definition for map
04:50:51 <vincenz> fabiim: please type what you mean, in the non finger sense
04:50:53 <Cale> fabiim: map does
04:50:57 <Itkovian> fabiim: and how would you apply that to a list of things that are basically singular?
04:51:00 <syntaxfree> there you  have. that paper describes how to write a super-general map (called a catamorphism, for kicks & giggles) in Haskell.
04:51:04 <Cale> @type map (+) [1,2,3,4,5]
04:51:05 <lambdabot> forall a. (Num a) => [a -> a]
04:51:22 <vincenz> @type map ($3) $ map (+) [1..5]
04:51:24 <lambdabot> forall a. (Num a, Enum a) => [a]
04:51:29 <vincenz> > map ($3) $ map (+) [1..5]
04:51:30 <Cale> @type zipWith ($) (map (+) [1,2,3,4,5]) [5,4,3,2,1]
04:51:30 <lambdabot>  [4,5,6,7,8]
04:51:31 <lambdabot> forall b. (Num b) => [b]
04:51:38 <vincenz> I prefer mine
04:51:40 <Cale> > zipWith ($) (map (+) [1,2,3,4,5]) [5,4,3,2,1]
04:51:42 <lambdabot>  [6,6,6,6,6]
04:51:47 <Itkovian> aargh
04:51:51 <Itkovian> the devil extended
04:52:07 * Itkovian should work on his paper
04:52:13 <syntaxfree> > foldr (.) (map (+) [1,2,3,4,5]) id
04:52:14 <lambdabot>  Couldn't match `a -> c' against `[b]'
04:52:29 <syntaxfree> @type map (+) [1,2,3,4,5]
04:52:30 <lambdabot> forall a. (Num a) => [a -> a]
04:52:36 <dons> > getChar -- Cale, did you see?
04:52:37 <Cale> > foldr (.) id (map (+) [1,2,3,4,5]) 0
04:52:38 <lambdabot>  <IO Char>
04:52:38 <vincenz> > zipWith ($) [1..5] $ zipWith (.) (map (*) [1..5]) $ map (+) [1..5]
04:52:39 <lambdabot>  15
04:52:39 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
04:52:39 <lambdabot>   In an arithmetic ...
04:52:41 <syntaxfree> ah.
04:52:44 <fabiim> loll , you guy's love this don't you?
04:52:51 <Cale> dons: nice
04:53:05 <syntaxfree> I love lists of functions.
04:53:15 <syntaxfree> They give me this warm mathematical feeling.
04:53:16 <Cale> fabiim: lots of fun -- anything here which looks remotely what you're looking for?
04:53:57 <Pupeno> Can lambdabot handle looping URLs ? http://software.pupeno.com/loop.html
04:53:59 <lambdabot> Title: The URL of this page is http://software.pupeno.com/loop.html
04:54:01 <vincenz> > zipWith ($) [1..5] $ zipWith (.) (map (*) [1..5]) $ map (+) [1..5]
04:54:02 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
04:54:03 <lambdabot>   In an arithmetic ...
04:54:05 <vincenz> o.O
04:54:10 <Pupeno> It seems so.
04:54:21 <dons> we tend to understand recursion here ;)
04:54:29 <Cale> lambdabot never replies to anything which it said :)
04:54:38 <vincenz> > zipWith ($) [1..5] . zipWith (.) (map (*) [1..5]) . map (+) $ [1..5]
04:54:39 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
04:54:39 <lambdabot>   In an arithmetic ...
04:54:41 <syntaxfree> dons: do you happen to know if email is infinitely recursive?
04:54:42 <vincenz> why won't that work
04:54:48 <fabiim> i am looking for something like map , because map it's like this ( a-> b) -> [a] -> [b] , I want to do something like (a->b->a) [a] ...
04:54:51 <Cale> http://software.pupeno.com/loop.html
04:54:51 <mbot> Title: The URL of this page is http://software.pupeno.com/loop.html
04:54:52 <syntaxfree> what happens if I have email A and email B..
04:54:52 <lambdabot> Title: The URL of this page is http://software.pupeno.com/loop.html
04:55:00 <fabiim> did I make any sense?
04:55:01 <fabiim> lol
04:55:06 <vincenz> fabiim: finish the thought
04:55:11 <syntaxfree> and I set B as a  forward address for A and vice versa?
04:55:17 <syntaxfree> do I get to crash Gmail?
04:55:20 --- mode: ChanServ set +o vincenz
04:55:29 --- kick: mbot was kicked by vincenz (-- Too many bots)
04:55:38 <fabiim> i want to do a function in every element in one string , but my function receives a constant number and the element in the string
04:55:42 <Cale> er, I could have just made it part :)
04:55:46 <Pupeno> Cale: oh, when it output the title of a googled page it was a special case ? not answering itself with the title of the URL just output(ed) ?
04:55:47 <vincenz> this was funner
04:56:26 <syntaxfree> Pupeno: http://www.test.com
04:56:27 <lambdabot> Title: Test Central Home
04:56:31 <Pupeno> if mbot had replied to lambdabot then we could have had a loop there.
04:57:07 <Cale> Pupeno: Well, with only one bot, there's no need for a special case. I don't know what happened there though. Perhaps it just won't repeat a URL lookup too soon
04:57:20 <Itkovian> fabiim: basically you want something like a fold that doesn't roll up
04:57:25 <flux__> I suppose it can simply disregard urls it has seen recently?
04:57:26 * syntaxfree has them IORef blues.
04:57:30 <syntaxfree> @paste
04:57:31 <lambdabot> http://paste.lisp.org/new/haskell
04:57:46 <vincenz> > zipWith (flip ($)) [1..5] . zipWith (.) (map (*) [1..5]) . map (+) $ [1..5]
04:57:48 <lambdabot>  [2,8,18,32,50]
04:57:50 <vincenz> better
04:57:52 <Philippa_> fabiim: so apply the constant, and then map the resulting function across the string
04:58:09 <Philippa_> as in map (+1) [1,2,3]
04:58:17 <syntaxfree> @type IORef
04:58:18 <lambdabot> Not in scope: data constructor `IORef'
04:58:24 --- mode: vincenz set -o vegai
04:58:26 --- mode: vincenz set -o vincenz
04:58:30 <syntaxfree> @type Data.IORef.newIORef
04:58:31 <lambdabot> forall a. a -> IO (GHC.IOBase.IORef a)
04:58:52 <syntaxfree> is the proper syntax newIORef var value or var <-newIORef value?
04:59:04 <Philippa_> the latter
04:59:14 <Philippa_> the former isn't correct in any way whatsoever, and won't typecheck
04:59:16 <syntaxfree> I thought so.
04:59:32 <Philippa_> you can't pass variables around in haskell, only the values they refer to
04:59:34 <syntaxfree> From the type signature. Yet, I keep on geting Not in Scope errors.
04:59:49 <Philippa_> your problem is elsewhere
05:00:48 <syntaxfree> one thing I like about Haskell is that the regularity of its syntax is second only to S-expr languages.
05:01:19 <lisppaste2> fabiim pasted "how do i map decifraCesar?" at http://paste.lisp.org/display/30081
05:01:39 <Philippa_> yeah, and it gets a lot of human-expressiveness out of it at the same time
05:02:00 <Philippa_> let vs where corresponds to a top-down vs bottom-up decomposition of ideas, for example
05:02:41 <syntaxfree> it could be a little more flexible EDSL-wise, but that can be said of any language, even of the ones with macros.
05:07:28 <syntaxfree> fabiim: I have a very nice Caesar decipher that guesses the right rotation ammount.
05:08:10 <syntaxfree> it's a simple heuristic, but it looks spooky in an AI-miracle way.
05:08:41 <fabiim> yeah ? show me that ...
05:08:50 <syntaxfree> http://www.navarro.mus.br/diego/blog/2005/10/26/magica/
05:08:55 <lambdabot> Title: m√°gica! ¬ª diego navarro, http://tinyurl.com/ykkv2u
05:08:59 <syntaxfree> it's all in portuguese, but you can look at the code.
05:09:33 <fabiim> i made one too , but my work is really easy since the plaintex only can have 9 words , lol =)
05:10:23 <syntaxfree> My code basically distinguishes english sentences from the ZOHRL UHUK UHUK stuff based on letter frequency. It works very well.
05:10:39 <Cale> it does :)
05:10:54 <Cale> I think I'll have to save that :)
05:11:39 <syntaxfree> There's more Haskell stuff in that blog. I should really write a blog in english.
05:11:56 <Cale> I wonder how well it works with arbitrary substitution ciphers
05:12:49 <syntaxfree> I think the magic is in constant letter distance.,
05:12:51 <fabiim> syntaxfree: where you from ?
05:12:59 <yaxu> dons: hey did you hear more about that music dsl project?
05:13:23 <Cale> It would possibly work even better if you considered adjacent character frequencies.
05:13:24 <syntaxfree> Arbitrary substitution ciphers would just decipher into "OOOOOEEEAAN" or something.
05:14:09 <syntaxfree> Cale: yes, but then I'd have 26^2 cases to deal with. Part of the fun is the very short code with a magic frequency vector.
05:14:12 <syntaxfree> > 26 ^ 2
05:14:14 <lambdabot>  676
05:14:22 <Cale> hmm
05:14:38 <chessguy> 'morning
05:15:03 <Cale> Well, you could look at the frequencies of characters in the given piece of text and order them according to the frequencies of English letters.
05:15:24 <Cale> But yeah, arbitrary substitution ciphers will be harder of course :)
05:15:38 <syntaxfree> I never posted the calibration code.
05:15:40 <syntaxfree> I need to undig it at some point.
05:15:47 <Cale> I wonder whether 2 and 3 letter combination frequencies would help.
05:15:49 <syntaxfree> (The code that produced that vector of frequencies)
05:16:04 <Cale> well, it seems like they would :)
05:16:07 <syntaxfree> Cale: for arbitratry substitution ciphers or for caesar ciphers?
05:16:27 <chessguy> mutation strings are the key!
05:16:29 <Cale> for arbitrary ones -- Probably for rotation ciphers, just letter frequency is enough
05:16:43 <syntaxfree> yes, for
05:16:59 <syntaxfree> strings longer than ~12 characters.
05:17:40 <Cale> haha, new xkcd :)
05:17:54 <syntaxfree> anyway, gotta go.
05:18:03 <Cale> see you around
05:18:09 <syntaxfree> yeah.
05:18:15 * syntaxfree has to go be an economist now.
05:19:34 <syntaxfree> rock on.
05:20:08 <vincenz> \o/
05:20:43 <chessguy> by the way, if you like crypto, you have to read Dan Brown's book Digitial Fortress
05:21:12 <desrt> xkcd++
05:21:47 <christine> question: can reverse work with a funcion that does sth to a list rather than a list?
05:22:13 <vincenz> desrt: :D
05:22:22 <vincenz> christine: sure
05:22:26 <vincenz> func . reverse
05:22:28 <Cale> christine: it can be composed with such a function
05:22:41 <Cale> or reverse . f
05:22:50 <chessguy> > (reverse . filter) (Char.isUpper) "Hello World"
05:22:51 <lambdabot>    Expecting a function type, but found `b'
05:22:51 <lambdabot>    Expected type: (a1 -> Boo...
05:22:53 <vincenz> or reverse .f . reverse
05:23:01 <chessguy> grrr
05:23:11 <vincenz> > reverse . filter isUpper $ "Hello World"
05:23:13 <lambdabot>  "WH"
05:23:13 <vincenz> ;)
05:23:15 <Cale> > reverse . filter Char.isUpper "Hello, World!"
05:23:15 <lambdabot>    Expecting a function type, but found `[a]'
05:23:16 <lambdabot>    Expected type: a1 -> [a...
05:23:18 <Cale> > reverse . filter Char.isUpper $ "Hello, World!"
05:23:19 <lambdabot>  "WH"
05:23:24 <Cale> yeah
05:23:28 <vincenz> Cale: you're slow today
05:23:41 <Cale> I've only had a few sips of coffee so far
05:23:45 <chessguy> why is the $ needed?
05:23:55 <christine> thanks, hope it works out. i use reverse.f.reverse
05:24:01 <Cale> because otherwise "Hello, World" is a parameter of filter
05:24:08 <vincenz> precedence
05:24:09 <Cale> rather than of the combined function
05:24:14 <chessguy> ah
05:24:21 <Cale> > (reverse . filter isUpper) "Hello, World!"
05:24:22 <lambdabot>  "WH"
05:24:44 <dolio> > ((reverse .) . filter) isUpper "Hello, World!"
05:24:46 <lambdabot>  "WH"
05:24:47 <Cale> christine: right :)
05:25:55 <christine> you make me vwant to sent my functions to you...
05:26:45 <vincenz> kinky
05:26:46 <lennart> chessguy: if you know anything about crypto and read Digital Fortress you might puke :)
05:26:47 <Cale> aww :)
05:26:52 <Cale> hehe
05:26:53 <christine> you are both helpfull and confiousing atthe same time...
05:27:06 <vincenz> yeah, Cale tends to be that way
05:27:40 <vincenz> sensei Cale, please show us the light of -the- monad
05:27:52 <Cale> Does X have the monad-nature?
05:28:01 <vincenz> mu
05:28:09 <Cale> hehe
05:28:12 <vincenz> or wait that should be plain 'm'
05:28:35 <Cale> mu would be a particularly good response to a question as to whether something had the least-fixed-point-nature
05:28:36 <lennart> mu is a good fixpoint operator
05:28:47 <vincenz> Cale: yeah :D
05:28:55 <desrt> the xkcd discussion forums are hilarious
05:28:56 <christine> i will sent my functions to you...
05:28:57 <vincenz> Does a cow have least-fixed-point-nature?
05:29:10 <Cale> hehe
05:29:14 <desrt> http://xkcd.com/c162.html this comic threw off a ridiculously intricate discussion
05:29:15 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:29:41 <desrt> at first people were like "assuming no air resistance and without dealing with quantum or relitavistic effects...."
05:29:43 <vincenz> xkcd rocks
05:29:52 <desrt> but soon, such restrictions had left the conversation :)
05:30:09 <desrt> *relitivisitic
05:30:14 <desrt> *oh screw it
05:30:28 <vincenz> realitytvistic
05:30:49 <christine> tyt...
05:31:15 <Binkley> vincenz, that sounds better than the comments on the livejournal feed
05:31:21 <Binkley> it's usually people being all, "I don't get it!"
05:31:27 <vincenz> Binkley: which livefjournal feed?
05:31:54 <Binkley> vincenz: xkcd_rss
05:32:09 <Binkley> srsly, it's always like, "This comic makes me feel stupid! Math is hard!" why are these people reading xkcd?
05:32:15 <Cale> heh
05:32:16 <vincenz> I loved the last one
05:32:22 <vincenz> Cale: did you see the rotation matrix?
05:32:30 * vincenz snickers
05:32:36 <vincenz> I feel like starting a comic now
05:32:40 <Cale> vincenz: yes, that was incredibly funny
05:32:45 <Binkley> yeah, I'm going to do a comic about denotational semantics
05:32:51 <Binkley> and throw in an occasional sex joke so people will read it
05:32:51 <vincenz> Maybe oen around haskell, and you guys could send in guest stuff
05:33:03 <Binkley> and then the rest of the time they'll be all "IIII DON'T GET IIIIITT"
05:33:11 <christine> vincenz: please no...
05:33:13 <Philippa_> I did like the "Damn you, Feynman!" one...
05:33:13 <vincenz> Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
05:33:22 <Cale> vincenz: the only thing I would have changed about it would be to write pi/2 rather than 90¬∞.
05:33:29 <Binkley> ?remember vincenz Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
05:33:38 <Binkley> Philippa: yes, that was excellent
05:33:50 <vincenz> Philippa_: I admit not getting that one
05:34:03 <Binkley> vincenz: feynman -- at least according to his autobiographical writing -- was always drowning in pussy
05:34:13 <vincenz> ah
05:34:21 <vincenz> autobiography is great that way
05:34:25 <vincenz> you can write as much fiction as you want
05:34:37 <Binkley> yeah, pretty much
05:34:45 <vincenz> Binkley: so you like the semantics joke, huh?
05:35:01 <Binkley> vincenz: yeah, that was pretty good
05:35:07 <Itkovian> Binkley: you mean he had cats walking all over the place? :-)
05:35:08 <vincenz> goes to show you I'm a romantic
05:35:12 <vincenz> or I might have reversed it
05:35:20 <Binkley> Itkovian: hur hur hur
05:35:24 <vincenz> Itkovian: yeah, most likely the quantistic ones
05:35:46 <Itkovian> the what?
05:35:50 <vincenz> heisenberg's cat
05:35:51 <Binkley> schrodinger's cat
05:35:53 <Binkley> heh
05:35:54 <Itkovian> right
05:35:56 * vincenz shoots himself
05:36:05 <vincenz> couldn't remember the name
05:36:06 * Itkovian opens the box
05:36:15 * vincenz sees Itkovian die from the Cianide
05:36:16 <Itkovian> you missed.
05:36:37 <vincenz> heisenberg would do too tho
05:37:54 <christine> vincenz: i have finally done it... Mint if i sent you my exercise? i am too scared to run it... I know it will crush...
05:37:58 <vincenz> Itkovian: feel like a chuckle?
05:38:03 <vincenz> christine: erm, sure
05:38:04 <vincenz> @paste
05:38:04 <lambdabot> http://paste.lisp.org/new/haskell
05:38:58 * ibid just got a copy of the dragon book 2nd ed
05:39:39 <sieni> dragon book?
05:39:40 <vincenz> I guess the cyanide really killed him
05:39:46 <vincenz> sieni: erm yes -the- dragon book
05:39:52 <vincenz> sethi ullman and ...
05:39:59 <vincenz> vho?
05:40:06 <dolio> Aho.
05:40:13 <sieni> ahh
05:40:14 <vincenz> ah right, thx
05:40:35 <vincenz> They even talk about type-inference :)
05:40:44 <sieni> vincenz: the program is called `awk', not `vwk' ;-)
05:40:59 <vincenz> right right
05:41:05 <lisppaste2> christine pasted "this wont work" at http://paste.lisp.org/display/30086
05:41:24 <vincenz> christine: easy: functions should start with lowercase
05:41:25 <vincenz> erm
05:41:28 <vincenz> functionnames
05:41:47 <dolio> Heh, that's actually the first amazon hit if you search for "dragon book".
05:41:55 <vincenz> christine: and you might have issues with precendence
05:42:14 <vincenz> to be sure (h+lenght ...) : g t
05:42:27 <Cale> askisi5 = reverse . g . reverse
05:42:46 <Cale> you don't need to break it into cases
05:43:47 <lisppaste2> vincenz annotated #30086 with "better" at http://paste.lisp.org/display/30086#1
05:44:09 <ibid> aho lam sethi ullman in the 2nd ed
05:44:23 <ibid> (monica s. lam)
05:45:21 <vincenz> @join #scheme
05:45:41 * vincenz hmm
05:45:44 * vincenz prods lambdabot 
05:45:45 <vincenz> @yow
05:45:46 <lambdabot> Mmmmmm-MMMMMM!!  A plate of STEAMING PIECES of a PIG mixed with the
05:45:46 <lambdabot> shreds of SEVERAL CHICKENS!! ... Oh BOY!!  I'm about to swallow a
05:45:46 <lambdabot> TORN-OFF section of a COW'S LEFT LEG soaked in COTTONSEED OIL and
05:45:46 <lambdabot> SUGAR!! ... Let's see ... Next, I'll have the GROUND-UP flesh of CUTE,
05:45:47 <lambdabot> BABY LAMBS fried in the MELTED, FATTY TISSUES from a warm-blooded
05:45:48 <lambdabot> [3 @more lines]
05:45:49 <vincenz> woah
05:45:57 <vincenz> Itkovian: ping
05:46:23 <Cale> @more
05:46:23 <lambdabot> animal someone once PETTED!! ... YUM!!  That was GOOD!!  For DESSERT,
05:46:24 <lambdabot> I'll have a TOFU BURGER with BEAN SPROUTS on a stone-ground, WHOLE
05:46:24 <lambdabot> WHEAT BUN!!
05:46:29 * vincenz ponders
05:46:35 <vincenz> I lost lambdaperms?
05:46:54 <Cale> lambdabot: @join #scheme
05:47:02 <Cale> hmm
05:47:05 <vincenz> yeah
05:47:06 <christine> vincenz: this works? i did not know how to use @...
05:47:16 <vincenz> christine: @ is just a way to bind something to a variable
05:47:28 <vincenz> l@(h:t) => l == h:t
05:47:41 <vincenz> Cale: odd ain't it
05:47:44 <vincenz> @help join
05:47:44 <lambdabot> join <channel>
05:47:46 <vincenz> @help part
05:47:47 <lambdabot> part <channel>
05:47:47 <Cale> vincenz: yeah
05:47:55 <Itkovian> vincenz: pong
05:48:03 * lambdabot slaps Cale
05:48:06 <vincenz> still have perms
05:48:10 <vincenz> Itkovian: wanna have a chuckle?
05:48:17 <Syzygy-> @slap Syzygy-
05:48:17 * lambdabot smacks Syzygy- about with a large trout
05:48:21 <Syzygy-> Owie.
05:48:35 <vincenz> except that I used @msg
05:48:40 <christine> vincenz: another way? without @?
05:48:40 <vincenz> @msg #haskell WOO
05:48:41 <lambdabot> WOO
05:48:47 <Syzygy-> @msg #haskell Me too?
05:48:48 <lambdabot> Not enough privileges
05:48:48 <vincenz> christine: as you had it with (h:t)
05:48:51 <Syzygy-> Doh.
05:49:00 * Syzygy- sulks in a corner. :)
05:49:06 <vincenz> I guess her join/part module must be down
05:51:09 <christine> going for lunch. be back in 30'. hope i will work it through...
05:51:20 <vincenz> caliorexi
05:51:35 <vincenz> or is it kaliorexi?
05:51:36 <christine> euxaristo.
05:52:04 <christine> the 2nd looks better.
05:55:17 <Cale> http://www.geomerics.com/index.php?page=lighting -- this is extremely cool :)
05:55:23 <lambdabot> Title: Geomerics - Lighting, http://tinyurl.com/vbawk
05:56:23 <dons> vincenz: she's already in too many channels. freenode limits to 20.
05:56:27 <vincenz> ah
05:56:32 <vincenz> but I tried @part #oasis to the same result
05:56:36 <vincenz> @part #oasis
05:56:38 <vincenz> @join #oasis
05:56:46 * vincenz ponders
05:56:47 <vincenz> @help part
05:56:48 <lambdabot> part <channel>
05:56:56 <vincenz> no avail
05:58:37 <vincenz> Cale: won't work
06:00:33 <vincenz> the video that is
06:01:08 <Cale> vincenz: no?
06:01:10 <Cale> vincenz: hmm
06:01:47 <Cale> Do you have flash installed?
06:02:11 <vincenz> erm
06:02:14 <vincenz> yeah but it won't load
06:03:31 <Philippa_> 'lo swiert. I'm told I missed good talks yesterday
06:03:51 <Cale> vincenz: odd - the same video is downloadable from the link there
06:04:01 <vincenz> wmv dun work in linux
06:04:06 <Cale> sure it does
06:04:18 <vincenz> not here
06:04:20 <Cale> I'm in linux :)
06:04:27 <vincenz> windows isn't linux
06:04:33 <vincenz> as much as you hack it
06:04:36 <Cale> what distribution are you running?
06:04:43 <vincenz> ubuntu+1
06:04:58 <Cale> okay, so use EasyUbuntu to install video codecs
06:05:08 <Cale> and then it will all work properly :)
06:05:22 <vincenz> ah well
06:05:23 <vincenz> not now
06:07:10 <christine> vincenz: i am back...
06:08:56 <matley> i got an error building yi of type: "it was found in multiple packages: fps-0.8 base"
06:09:40 <christine> vincenz: could you tell me the errors in my program?
06:09:57 <dons> ah nice, people seem to be discovering the haskell back catalogue :) http://programming.reddit.com/info/ratk/comments
06:10:00 <lambdabot> Title: House: An operating system written in Haskell (reddit.com), http://tinyurl.com/y2v4w2
06:10:22 <dons> matley: you using ghc 6.6?
06:10:27 <matley> dons, yes
06:10:29 <dons> in which case, you don't need fps anymore, its in base.
06:10:34 <vincenz> christine: check the page you made
06:10:36 <dons> so remove the fps dependency from the .cabal file
06:11:05 <matley> dons, thx
06:13:35 <LoganCapaldo> OS in Haskell eh?
06:13:46 <pejo> Why is there such a fuzz about reddit.com? I get the impression it's mostly trolling there?
06:13:55 <LoganCapaldo> Does that make it a lazy operating system?
06:15:09 <dons> pejo: not that much trolling.
06:15:13 <LoganCapaldo> Heck forget the laziness, its an os written in a language with GC. How the heck does that work
06:15:15 <Binkley> dons: I'm afraid to go look and see how many people are asking, "why would you want to do that in Haskell?"
06:15:20 <dons> LoganCapaldo: hm??
06:15:31 <dons> you stick the runtime system on the hardware, and let it go
06:15:41 <christine> vincenz: if you run it. it crashes or not?
06:15:42 <dons> just like you stick the C rts on your hardware, for a C kernel
06:16:04 <dons> Binkley: nah, reddit's lisp origins make it rather pro-haskell, I find
06:16:36 <dons> at least the programming subreddit
06:16:48 <LoganCapaldo> dons: I'm mostly messing around :) But as far as C goes, usually you stick the runtime system on after the kernel, and base it on some of the kernel functionality
06:17:14 <dons> so the haskell rts runs on L4, iirc
06:17:42 <vincenz> christine: erm?
06:17:50 <pejo> dons, isn't it the toher way around, they run OsKer on the haskell rts?
06:18:14 <christine> vincenz: erm?
06:18:33 <christine> vincenz: what is that?
06:18:35 <dons> could be, been a while since I read the paper. i seem to recall it being 100 lines of asm -> Haskell rts -> Haskell OS , but L4 is involved somehow :)
06:18:41 <dons> s/1000/
06:18:44 <vincenz> christine: as in, how can it crash, it's not a complete program
06:19:28 <christine> vincenz: i thought it could work...
06:19:54 <pejo> dons, yeah, Osker implements the L4 API I think.
06:19:59 <christine> vincenz: what is it's ploblem?
06:21:35 <vincenz> you don't have input data
06:21:38 <vincenz> you don't have a main
06:21:40 <vincenz> hwo the hell can I run that
06:23:12 <christine> vincenz: god.do you at least understand what i am trying to do?
06:23:23 <vincenz> Of course I am
06:23:26 <vincenz> the function you made is quite simple
06:23:47 <vincenz> am/do
06:23:59 <vincenz> And I put the corrections on that page, and Cale gave you the corrections
06:24:09 <vincenz> So unless you show us -what- crashes, we can't really help you now, can we
06:24:57 <vincenz> i
06:25:38 <christine> vincenz: well that is all i know, and all i have been tought... no main, no nothing...
06:25:50 <vincenz> is this homework?
06:26:22 <christine> vincenz: yes...
06:26:31 <yaarg> eugh...
06:26:42 <christine> vincenz: that is why i am so lost...
06:26:45 <vincenz> christine: and you then insult me and expect me to do it?
06:27:07 <vincenz> This channel is for learning haskell, not for solving homework
06:27:18 <dons> ok guys. please :)
06:27:35 * vincenz goes back to wrok ;)
06:27:48 <dons> christine: enough hints for today, you'll have to figure out more on your own.
06:28:53 <christine> vincenz: i am so sorry to have insulted you... really... :-(
06:29:01 <vincenz> christine: no worries :)
06:29:34 <christine> vincenz: no really... sorry...
06:29:51 <vincenz> Really, don't worry :)
06:29:59 <vincenz> I exagerated a bit
06:30:02 * vincenz coughs
06:30:08 <christine> vincenz: :'(
06:30:27 <dons> christine: I don't understand why your ip address changes all the time? and your nick?
06:30:36 <vincenz> christine: either way, dons made a point, homework is something to be done by you
06:30:43 <vincenz> otherwise it sort of loses its purpose
06:30:59 <vegai> unless the purpose is to get bonus points for the exam
06:31:12 <vincenz> yeah but you walk away with zilch
06:31:29 <vegai> Well, diploma isn't zilch
06:31:43 <christine> vincenz: zilch?
06:31:43 <vegai> I know, I'm too cynical.
06:31:48 <vincenz> zero, nada, njet
06:32:30 <dons> we seem to have a lot of people turning up this week with haskell homework, based in .gr.
06:32:35 <dons> i guess its just that time of the year
06:32:39 <vincenz> yeah
06:32:43 <vincenz> first semester's closing
06:33:01 <dcoutts_> I'll have to look out for my students :-)
06:33:01 <LoganCapaldo> I wish I had Haskell homework
06:33:12 <dons> ah, hehe
06:33:12 <dcoutts_> LoganCapaldo, we can give you some :-)
06:33:13 <dons> 06.11.15:12:29:21 <Binkley> why do I suspect that autokratoras and christine go to the same school?
06:33:15 <LoganCapaldo> I had like one ML homework
06:33:16 <dons> 06.11.15:12:29:32 <autokratoras> possible
06:33:19 <dons> 06.11.15:12:29:41 <autokratoras> christine sounds like a greek name
06:33:21 <dons> 06.11.15:12:30:17 <autokratoras> is there by any chance anyone greek in here?
06:33:26 <LoganCapaldo> In "Introduction to Programming Languages"
06:33:48 <vegai> LoganCapaldo: Actually implementing something is probably more fruitful ;)
06:33:59 <LoganCapaldo> That might of had a design and implementation in the title
06:34:03 <vegai> But I like mindless exercises too, sometimes.
06:34:40 <LoganCapaldo> vegai: I don't really want it for the sake of the exercise. More for what it would imply about the contents of the class ;)
06:35:09 <christine> autokratoras is greek for emperror
06:35:37 <vegai> ?users #haskell.gr
06:35:37 <lambdabot> Maximum users seen in #haskell.gr: 1, currently: 0 (0.0%), active: 0 (NaN%)
06:35:46 <vincenz> NaN
06:35:47 <vincenz> :D
06:36:19 <christine> you do have a lot of greeks in here, looking for sollutions...
06:36:20 <Itkovian> christine: have a look around the web, on haskell.org etc. Try writing some small functions in ghci, before moving on to compiled code.
06:36:56 <vincenz> Itkovian: so the chuckle, yes or no?
06:37:03 <Itkovian> we''' gladly help with actual problems, but you mujst show us that you tried first
06:37:15 <Itkovian> vincenz: sorry, mate, but you lost me there
06:37:36 * Itkovian should learn to type
06:37:47 <Itkovian> or pay attention to his spell checker
06:37:56 <christine> vincenz: don't be mad at me, ok?
06:38:02 <vincenz> I'm not mad
06:38:03 <vincenz> :)
06:38:09 <dons> christine: better go get some work done, and stop baiting vincenz
06:38:10 <Itkovian> no, he's crazy
06:38:20 <vincenz> Itkovian: definitely
06:38:21 <Binkley> christine: you have to understand that regulars on this channel see a lot of students come in asking us to do their homework for them. It does get old after the first 20 times.
06:38:39 <vincenz> christine: just cause I'm not mad doesn't mean I'll do homework
06:38:43 <Binkley> since we were all once students, and some of us still are, and did our own homework, it gets old because of that too.
06:38:47 * vincenz is a teacher himself and doesn't like people getting a free ride
06:38:51 <Itkovian> christine: that's why we have the paste bin: paste your code and we'll have a look
06:39:03 <vincenz> Itkovian: she pasted it and cale and myself fixed it
06:39:12 <Itkovian> yes, but if she wants more ...
06:39:18 <vegai> Binkley: those are some large generalisations ;)
06:39:22 <Itkovian> haha
06:39:29 * Itkovian sides with Binkley 
06:39:40 * vincenz takes Binkley's other side
06:39:58 <Binkley> last night I was talking with some people about helium and how it sends student errors back to the server so that the developers can improve the product, and I was saying, "you don't need that feature in order to collect buggy student code -- you just need to hang out on #haskell"
06:40:29 <dons> heh
06:40:44 * hyrax42_ wishes "it compiles" had any useful meaning in C
06:40:52 <dons> i wonder how the helium type reporting system works out, i've thought at times that would be good for ghc too
06:41:03 <Binkley> that would make me feel incredibly self-conscious
06:41:31 <Binkley> I would also probably stop naming my variables things like "dongs"
06:41:35 <dons> heh
06:41:47 <hyrax42_> presumably it's an anonoymous process
06:41:53 <hyrax42_> though I suppose some mining could be done
06:42:01 <Binkley> well, if you're the student, it kind of takes a leap of faith to assume it's anonymous
06:42:06 <hyrax42_> if it ever got out like those AOL searches...
06:42:08 <Binkley> plus, yes, there's tons of information leakage
06:42:09 <hyrax42_> damn
06:42:15 <christine> vincenz: i am not here waiting for solved problems, i do work...
06:42:18 <Binkley> even if it's not tied to IP address/username/anything obvious like that
06:42:46 <hyrax42_> how is helium
06:42:50 * hyrax42_ thinks he shoudl try it
06:43:02 <Binkley> http://www.cs.uu.nl/helium/
06:43:05 <lambdabot> Title: [ The Helium Homepage - Home]
06:43:08 <dons> hehe. we could DoS the entire Helium project with nasty comilatoin errors ;)
06:43:13 <Binkley> heh
06:43:14 <hyrax42_> ack no port in macports for it
06:43:18 <hyrax42_> some other time thne
06:43:20 <dons> let's compile lambdabot in helium, and watch the errors roll in
06:43:22 <Binkley> I should totally try to build GHC in Helium :-)
06:43:25 <hyrax42_> now whatn I'm 10 hours lat on an assignment
06:43:30 <dons> or, say, the linux kernel.
06:43:33 <Binkley> hah
06:43:42 <hyrax42_> or my current C assgnment
06:43:44 <christine> vincenz: i hope you will talk to me if you see me here again...
06:43:46 <Binkley> or anything written by Oleg
06:43:55 <hyrax42_> gcc accept it...it must work right?
06:43:58 * Binkley plays the world's tiniest violin
06:43:59 <Maddas> hyrax42_: Earlier today, I found (after looking in all the wrong places) a bug caused by a line of the form "float foo = x > 1 ? foo : foo/x"
06:44:00 <Itkovian> christine: stop worrying and code some stuff
06:44:13 <Binkley> "#haskell: How To Stop Worrying and Love the IO Monad"
06:44:32 <Maddas> hyrax42_: the compiler accepted it, despite the fact that there was no valid (outer) definition of foo that was referred to
06:44:34 <therp> haha kubrik :)
06:44:35 <Itkovian> For a moment I read ... make love to the IO Monad ...
06:44:46 <ventonegro> Maddas: that's an ugly line
06:44:48 <Binkley> gives a whole new meaning to unsafePerformIO
06:44:53 <Binkley> but then, I already made that joke
06:44:54 <Itkovian> idd
06:44:55 <hyrax42_> that's sort of pathetic
06:44:55 <ventonegro> if i've ever seen one
06:44:58 <christine> itkovian: allright...
06:45:01 <Maddas> ventonegro: The ugly part is that it compiled without error.
06:45:22 <ventonegro> Maddas: yeah
06:45:43 <ventonegro> does float foo = foo + 1.0f work?
06:46:20 <Maddas> sure. :)
06:46:49 <Maddas> uh, even "float foo = foo;" is accepted by g++. *boggle*
06:46:50 <ventonegro> beautiful
06:47:16 <ventonegro> for global scopes it's 0.0f, but inside a function...
06:47:40 <Maddas> if it at least only returned _|_... ;-)
06:47:51 * Maddas departs
06:48:03 <pejo> dons, is the type reporting system the stuff that sends information to a central server, or the machinery for giving type errors to hte user?
06:48:19 * vincenz ahs
06:48:24 <vincenz> freedom
06:48:29 <Binkley> lol
06:49:19 <vegai> Maddas: perhaps it was their version of random numbers ;P
06:50:02 <vegai> Indeed very ugly that gcc doesn't say anything about that, even with full warnings, -pedantic
06:50:25 <eviltwin_b> yeh
06:50:39 <eviltwin_b> sounds like a bug report to me :)
06:50:43 <Binkley> vegai, actually the -pedantic flag in gcc just warns you about any occurrences of "Linux" in comments that aren't prefixed with "GNU/"
06:50:54 * vegai chuckles.
06:50:57 <eviltwin_b> ("workaround: program in haskell instead")
06:51:14 <Binkley> @quote cjeris
06:51:15 <lambdabot>  Cale: I like how you conveniently gloss over the part where your head explodes.
06:51:18 <Binkley> @quote cjeris
06:51:18 <lambdabot>  instance (TicTacToe a) => (GlobalThermonuclearWar a) where ...
06:51:21 <vegai> Actual response might be "Workaround: stop doing crazy shit like that"
06:51:22 <Binkley> eh, never mind
06:51:23 <Binkley> heh
06:51:40 <Binkley> gcc -psychoanalyze-programmer
06:51:58 <Binkley> obviously gcc's error messages need to be delivered in the style of M-x doctor
06:52:09 <eviltwin_b> they already put that in emacs, only the spell it psychoanalyze-pinhead instead :)
06:52:26 <vegai> What makes you think that pointer is *char?
06:52:36 <Binkley> how do you feel about main cannot return void?
06:52:48 <Binkley> is it because of your mother that you added an integer to a pointer without a cast?
06:54:42 <dons> ?remember Binkley is it because of your mother that you added an integer to a pointer without a cast?
06:56:58 <dcoutts_> hmm, but adding an integer to a pointer is ok, what would one cast?
06:57:07 <dcoutts_> @hoogle plusPtr
06:57:08 <lambdabot> Foreign.Ptr.plusPtr :: Ptr a -> Int -> Ptr b
06:57:27 <Binkley> heh
06:57:33 <ventonegro> it's the famous pointer arithmetic
06:58:06 <Binkley> ghc error messages would look more like, "you have to *want* to overcome the monomorphism restriction"
06:59:11 <Cale> hehe
06:59:35 <vegai> Expected: String -> String, Inferred: Arrow m -> (((a -> b) -> (c -> d ->a)) -> a) -> IO m -> a -> b -> String
07:00:11 <vegai> I hope I didn't exaggerate.
07:01:51 <Cale> @ghc
07:01:51 <lambdabot>  Functional dependencies conflict between instance declarations
07:02:05 <Cale> @ghc
07:02:06 <lambdabot>  Multiple default declarations
07:02:08 <Cale> @ghc
07:02:08 <lambdabot>  parse error on input
07:02:10 <Cale> @ghc
07:02:10 <lambdabot>  Illegal unboxed tuple type as function argument
07:02:11 <Binkley> @ghc
07:02:11 <lambdabot>  Can't mix generic and non-generic equations for class method
07:02:13 <Binkley> @ghc
07:02:13 <lambdabot>  eval_thunk_selector: strange selectee
07:02:18 * vegai laughs
07:03:02 <Cale> @ghc
07:03:02 <lambdabot>  mkProtoBCO: stack use won't fit in 16 bits 150813
07:04:26 <vincenz> @ghc
07:04:27 <lambdabot>  Bindings in hs-boot files are not allowed
07:04:57 <Cale> @ghc
07:04:57 <lambdabot>  internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
07:05:01 <Binkley> What makes you believe functional dependencies conflict between instance declarations?
07:08:27 <Cale> GADT pattern match in non-rigid context
07:08:43 <Cale> There are prescriptions available for that sort of thing.
07:09:37 <CosmicRay> Igloo: do you have any ideas on #396817?
07:09:53 <CosmicRay> arjanoosting: are you here?
07:10:12 <CosmicRay> dcoutts: why is gentoo using wash 2.5 instead of 2.9?
07:10:37 <dcoutts_> CosmicRay, oh, there's a new release? We'll take a look then.
07:10:54 <dcoutts_> is it any quicker to build these days? :-)
07:10:54 <CosmicRay> dcoutts: yeah, was released in June ;-)
07:10:59 <CosmicRay> dcoutts: not a chance
07:11:12 <dcoutts_> ho hum, I recall that two modules take about 10 min each
07:11:43 <dcoutts_> and try to use >200 Mb of memory
07:11:44 <CosmicRay> dcoutts: we had a bug reported to debian in which our powerpc autobuilder killed its build after taking over 90 minutes.  I strongly suspect that it would have eventually finished.
07:11:50 <CosmicRay> yes
07:12:51 <dcoutts_> CosmicRay, yeah, we stuck an info messages into the ebuild to tell people to be very patient :-)
07:13:05 <CosmicRay> heh
07:13:54 <CosmicRay> you will still have to patch it for ghc 6.6
07:14:04 * gds wonders how useful it'd be to have lambdabot hooks in a text editor...
07:14:06 <CosmicRay> arjan did that for us, you're welcome to our patch
07:14:17 <LoganCapaldo> I just noticed something. Lazy evaluation makes errors interesting
07:14:41 <LoganCapaldo> > fst (1, (error "Wheee"))
07:14:42 <lambdabot>  1
07:14:46 <Cale> re: haskell homework -- that's basically how I learned Haskell, by lurking in this channel and secretly doing all the homework problems which people would come here with
07:15:04 <dcoutts_> Cale, heh, nice :-)
07:15:07 <Cale> LoganCapaldo: indeed
07:15:24 <dons> gds: already has hooks :)
07:15:25 <astrolabe> dcoutts: I downloaded ghc-6.4.1 to get Gtk2Hs to work, and after than, it seemed to work first time :)
07:15:31 <dons> you can call it from vim, anyway. i do
07:15:38 <gds> Ah...
07:15:55 <gds> Might be time for my regular emacs/vim switch then, I guess...
07:16:31 <gds> :)
07:17:42 <dons> http://programming.reddit.com/info/ratk/comments so does this mean non-fp people are exploring haskell, based on the appearences on reddit?
07:17:45 <lambdabot> Title: House: An operating system written in Haskell (reddit.com), http://tinyurl.com/y2v4w2
07:17:55 <dons> has haskell become something random people know to reddit, since it rates well?
07:17:58 * dons idly speculates
07:18:12 <Binkley> no, trolling qwe1234 is the main thing that rates well
07:18:23 <dons> that's true
07:18:29 <dons> though haven't seen him around recently
07:18:32 <thetallguy> Heh.  dons, that reminds me.  I had an epiphany yesterday morning.
07:18:33 <Binkley> oh, he's around
07:18:34 <LoganCapaldo> > let a = [1,2,3] ++ map (\_ -> error "Out of bounds") [1..] in a !! 3
07:18:36 <lambdabot>  Exception: Out of bounds
07:18:38 <dons> thetallguy: oh?
07:18:46 <gds> Didn't someone suggest once that reddit folk are pre-selected for haskell freindliness, since they're largely lisp folk to begin with...?
07:18:59 <Binkley> check out http://programming.reddit.com/info/r761/comments if you want to hate yourself
07:19:02 <lambdabot> Title: Most people who criticize Lisp don&#39;t understand it (reddit.com), http://tinyurl.com/vwdry
07:19:02 <dons> that's almost certainly true, yes.
07:19:07 <thetallguy> Using and advocating Haskell is like being Calvin (and Hobbes).
07:19:21 * dons is intrigued
07:19:33 <thetallguy> To you, it's alive, real, a true delight.
07:19:47 <thetallguy> To those who know better, it's a stuffed tiger.
07:20:13 <Binkley> ?remember thetallguy Using and advocating Haskell is like being Calvin (and Hobbes). To you, it's alive, real, a true delight. To those who know better, it's a stuffed tiger.
07:20:14 <dons> :}
07:20:21 <Binkley> Yeah, but Haskell isn't as girl-crazy
07:20:25 <thetallguy> lol
07:20:38 <thetallguy> But it does get you into trouble, sometimes.
07:21:01 <LoganCapaldo> Stretching metaphor: Transmogrifier == Monads?
07:21:09 <Cale> Can these people really be said to know better?
07:21:17 <Binkley> I tried to build a transmogrifier in Haskell but I got this weird error message about rigid type variables, can anyone help?
07:22:25 <thetallguy> Logan:  Nice.
07:22:36 <thetallguy> Monad transformers, perhaps.
07:23:05 <LoganCapaldo> ContT is the time machine ;)
07:23:19 <dons> hehe [lisp] Compare that to Haskell, which draws on a large pool of graduate students looking for something paper-worthy
07:23:21 <thetallguy> And Spiff?
07:23:25 <pkhuong-> dons: sorry :p
07:23:28 <dons> :)
07:23:39 <pkhuong-> and then the only 2 replies and qwe and some other dude with reading comprehension troubles.
07:23:43 <pkhuong-> *are
07:23:48 <dons> ah well. i thought it was funny
07:24:17 <thetallguy> It sort of is.
07:24:24 <thetallguy> And it's sort of sad.
07:24:34 <pkhuong-> why? It's a good thing!
07:24:45 <thetallguy> I think it's a good thing
07:24:52 <thetallguy> It's sad that others see it as bad.
07:25:11 <dons> true. but screw 'em. we have the technology.
07:25:24 <thetallguy> I think it's an extension of ``I don't like math.''
07:25:41 <Binkley> ?remember dons screw 'em. we have the technology.
07:25:55 <thetallguy> which is odd coming from people who excelled at the abstraction of programming.
07:25:59 <thetallguy> Indeed.
07:26:25 <dylan> using a lisp dialect without tail recursion is painful
07:26:40 <thetallguy> I feel like Haskell's going to go jiffypop any time now.
07:27:01 <dons> is jiffypop good or bad? :)
07:27:07 <pkhuong-> dylan: s/dialect/implementation/
07:27:22 <thetallguy> Well, good if I get some stuff done first.
07:27:22 <dylan> dialect is probably a better word
07:27:23 <dons> Panic: The jiffypop happened. Please report it to glasgow-haskell-bugs@haskell.org
07:27:31 <dylan> it's not quite lisp...
07:27:35 <thetallguy> lol
07:27:49 <dylan> it's between lisp and scheme.
07:27:52 <thetallguy> Do you know what jiffypop is?
07:28:03 <thetallguy> I don't know how far that product travelled.
07:28:27 <dons> haven't seen any product of that name here, but I can imagine.
07:29:03 <dons> ah, it *is* like haskell, I see: Jiffy Pop is the family fun treat. No other brand of popcorn offers a self-contained popping pan. It can even be used outdoors.
07:29:21 <thetallguy> :-D
07:29:27 <dons> just like ghc!
07:29:30 <thetallguy> lol
07:29:50 <thetallguy> Alright, enough fun, I'm afraid.  Off to the showers.
07:29:59 <pkhuong-> wow. you guys still use real pop corn?
07:30:18 <thetallguy> ?remember dons  ah, it *is* like haskell, I see: Jiffy Pop is the family fun treat. No other brand of popcorn offers a self-contained popping pan. It can even be used outdoors.
07:30:20 <dons> corn goes pop now?
07:31:26 <dylan> there exists unreal popcorn?
07:33:30 <Binkley> ?remember dons corn goes pop now?
07:33:36 <Binkley> they have the internet on computers now?
07:33:46 <vincenz> Binkley is a woman now?
07:34:13 <pkhuong-> [latex]: is there an easy way to change the font used by a verbatim environment so that my ascii art looks more like it does in emacs?
07:35:46 <LoganCapaldo> pkhuong-: Yes. Do I remember how? No. :)
07:36:44 <dons> how intriguing: on haskell-cafe: "So, it's Friday afternoon (well, here anyway), and
07:36:47 <dons> presumably everyone is thinking of leaving for the
07:36:50 <dons> weekend. Is anyone interested in playing a little game?  I'm
07:36:52 <dons> going to make the first move, and then just wait and see if
07:36:55 <dons> anyone makes the next. I'm certainly not promising to make
07:36:57 <dons> any further moves myself, but I'm not promising I won't,
07:37:00 <dons> either.
07:37:02 <dons> "
07:37:20 <pkhuong-> LoganCapaldo: too bad. Bah, it's only homework.
07:37:24 <dons> then comes the puzzles: http://www.haskell.org/pipermail/haskell-cafe/2006-November/019622.html
07:37:27 <lambdabot> Title: [Haskell-cafe] Friday Afternoon Play: The Burrows Wheeler Transformation, http://tinyurl.com/ygq2rx
07:37:52 <Binkley> pkhuong: you have to do ASCII art for homework?
07:37:53 <Binkley> *envious*
07:39:13 * glguy wrote a simple Burrows Wheeler transformation one-liner a while back for SPOJ
07:39:25 <pkhuong-> Binkley: An experiment plan (as a graph). Lots of nicely curvy arrows :)
07:39:45 <Binkley> heh. I read ASCII art and I was assuming kittens and such
07:40:02 <pkhuong-> Binkley: s/kittens/pin-ups/ ? :p
07:40:05 * earthy hugs Haskell again
07:40:17 <dons> ah, what the hell, http://programming.reddit.com/info/rbpc/details  :D
07:40:19 <lambdabot> Title: Friday afternoon, and its Haskell puzzle time. Go nuts! (reddit.com), http://tinyurl.com/y69jkh
07:40:21 * hyrax42_ misses haskell
07:40:30 <hyrax42_> especially parsec right now
07:40:47 <dons> My mission is to prove to the world that Haskell hackers have more fun!
07:40:57 <ropine> @arr
07:40:57 <lambdabot> Swab the deck!
07:41:04 <Binkley> pkhuong: well, I try to spread around the responsibility -- I can't be the only one dragging this channel into the gutter
07:41:04 <dons> (and we also do it in a monad, but that's widely known already)
07:41:09 <hyrax42_> honestly I was tempted to write the 100 lines of haskell (conservative upper bound) and hand in the ghc intermediate C
07:41:36 <hyrax42_> instead I'm at 1300 loc C and counting
07:41:40 <Binkley> heh
07:41:55 <dons> hyrax42_: heh, we already have a tool for that
07:41:57 <Binkley> try compiling that intermediate C with gcc and no extra options, though
07:42:05 <hyrax42_> (mostly because I never programmed in C before beyond for loops, so I'm not using it's "power")
07:42:14 <dons> it'll turn your haskell binary into a valid ansi C file
07:42:16 <hyrax42_> e.g. I could have made a "polymorphic" linked list
07:42:22 <dons> suitable for ACM programming contests requiring C
07:42:24 <hyrax42_> by doing a round trip void* cast
07:42:29 <hyrax42_> super safe!
07:42:33 <hyrax42_> but I didn't know I could do that
07:42:36 <Binkley> dons: what's that tool called?
07:42:39 <hyrax42_> so I have 2-3 linked lists
07:42:52 <pkhuong-> hyrax42: heh, that's how java generics work.
07:43:09 <hyrax42_> but some static enforcement must be there?
07:43:36 <pkhuong-> hyrax42: checked by the compiler, but nothing at the jvm level.
07:43:55 <dons> Binkley: http://www.cse.unsw.edu.au/~dons/code/hsinc/hsinc
07:43:56 <lambdabot> http://tinyurl.com/jjh5r
07:44:15 <dons> it was awarded the 'Not in the spirit of the competition' award, at the 2004 ACM programming contest,
07:44:17 <Binkley> cool. too bad my ACM programming contest days are long past
07:44:18 <Binkley> heh
07:44:24 <dons> example http://www.cse.unsw.edu.au/~dons/data/run_haskell.c
07:44:25 <lambdabot> http://tinyurl.com/jw9ed
07:45:18 <Binkley> seems like the same approach would work for any language, right
07:45:20 <Binkley> ?
07:45:32 <dons> yes
07:45:45 <dons> well, they'd all not be in the spirit of the contest, I'd imagine :)
07:46:03 <glguy> What was the spirit of the contest?
07:46:38 <dons> program in C, C++ or Java, and crack your head
07:46:44 <dons> (or that was the gist of it)
07:47:11 <dons> our very own blackdog (aka mrak) took up the challenge though, armed himself with hsinc, and a good ghc, and was leading for the first 2 hours..
07:47:14 <glguy> were those languages requried to make the competition more challenging?
07:47:15 <dons> until the questions started
07:47:54 <glguy> questions about what was generating those byte arrays?
07:48:05 <dons> we were fairly sure beforehand that the 'preprocessors and generators allowed' exception applied to ghc, being a C preprocessor
07:48:23 <pkhuong-> and generator :)
07:48:34 <Binkley> haha
07:48:39 <Binkley> GHC: the world's best C preprocessor
07:48:51 <dons> indeed. so although ghc was being used under the same principle that yacc and lex were, apparently ghc was doing too much work or something... mumble mumble
07:48:55 <dcoutts> dons, so why do we use a list of chunks for a lazy byte string rather than an unbalanced tree?
07:49:09 <dcoutts> O(1) ++
07:49:10 <dons> dcoutts: you were lazy?
07:49:13 <dcoutts> heh
07:49:32 <dcoutts> I've been reading more about ropes
07:51:14 * hyrax42_ randomly says "vlists"
07:51:20 <Binkley> @yow
07:51:20 <lambdabot> It don't mean a THING if you ain't got that SWING!!
07:51:40 <hyrax42_> though adding to the end screws them up pretty badly
07:51:50 <glguy> do wop do wop do wop do wa
07:53:56 <vincenz> "I'm leaving....where you gon go...barcelona"
07:54:21 <hyrax42_> what wouldn't I give
07:54:23 <hyrax42_> to get <|>
07:54:26 <hyrax42_> for C
07:54:34 <hyrax42_> and try
07:55:02 * dons `threadDelay` ((10^6) * 28800)
07:55:04 <dons> night all.
07:55:06 <Binkley> if i have to call strtok() i think i will just cry
07:55:10 <dcoutts> g'night dons
07:55:11 <hyrax42_> night
07:55:16 <hyrax42_> Binkley: already done
07:55:19 <hyrax42_> and some more coming up
07:55:28 <dcoutts> hyrax42_, though vlists are strict in their tail
07:55:32 <dcoutts> so no good for lazy IO
07:55:40 <hyrax42_> also you can't append to them
07:55:45 <dcoutts> right
07:55:47 <hyrax42_> without making them into crappy old linked lists
07:55:52 <dcoutts> unbalanced binary trees can be lazy
07:55:59 <hyrax42_> aye aye
07:56:00 <Binkley> the crying? or the calling strtok()?
07:56:07 <vincenz> dcoutts: english phd students too
07:56:07 <hyrax42_> strtok
07:56:12 <hyrax42_> crying saved for later
07:56:15 <Binkley> i guess the two of them go hand in hand
07:56:22 <dcoutts> vincenz, aye, I'm very lazy
07:56:59 <vincenz> dcoutts: do you only act on evaluation?
07:57:06 <Binkley> I know I only act when I'm forced to
07:57:21 <dcoutts> vincenz, I act on stage
07:57:21 * psnl returns
07:58:24 <astrolabe> ping dcoutts
07:58:31 <dcoutts> astrolabe, pong
07:58:37 <astrolabe> dcoutts: I downloaded ghc-6.4.1 to get Gtk2Hs to work, and after than, it seemed to work first time :)
07:58:49 <dcoutts> astrolabe, great
07:59:08 <astrolabe> Now I have to work out how Gtk2Hs works :(
07:59:32 <dcoutts> astrolabe, there's an intro presentation, a glade tutorial and several demo progs
07:59:57 <astrolabe> dcoutts: I haven't found the presentation
08:00:05 <dcoutts> astrolabe, on the gtk2hs front page
08:00:15 * astrolabe blushes
08:01:50 <ndm> hi psnl and dcoutts, sorry i barely got to see either of you yesterday!
08:02:03 <ndm> and where was Philippa_? I didn't spot her at all
08:02:04 <astrolabe> I wonder if a more functional wrapper for guis would be possible/nicer
08:02:08 <dcoutts> ndm, yeah, it was all very busy :-)
08:02:13 <ndm> astrolabe: you mean PropLang :)
08:02:17 <ndm> @where proplang
08:02:17 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/proplang
08:02:19 <Binkley> ndm: Philippa couldn't make it
08:02:21 <Binkley> trains got fscked up
08:02:26 <ndm> shame
08:02:26 <dcoutts> astrolabe, there are several approaches
08:02:29 <astrolabe> ndm thanks
08:02:43 <ndm> yeah, was incredibly busy! 20 minutes late for the first talk, left within 20 minutes of the last talk
08:02:44 <babusrini> I have question regarding foldr
08:02:52 <dcoutts> ndm, no, I didn't spot her either
08:03:32 <psnl> ndm: you should have stayed around for the part where Conor denied he was Conor.
08:03:36 <Binkley> haha
08:03:58 <astrolabe> babusrini: ask away
08:04:02 <babusrini> foldr (\x y -> (x*x + y*y)) 1 [1..2] gives 26 which I understand
08:04:12 <ndm> psnl: did Conor get drunk?
08:04:17 <babusrini> But why foldr (\x y -> (x*x + y*y)) 2 [1..2] returns 65
08:04:29 <Binkley> > foldr (\x y -> (x*x + y*y)) 1 [1..2]
08:04:30 <lambdabot>  26
08:04:33 <psnl> ndm: he was well on his way
08:04:38 <Binkley> > foldr (\x y -> (x*x + y*y)) 2 [1..2]
08:04:39 <lambdabot>  65
08:04:52 <psnl> ndm: the higher reasoning whent when he paid the bill on his credit card
08:05:46 <Binkley> babusrini: if you think about foldr as something that replaces the constructors in a list with its first two arguments, you can "evaluate" it on paper
08:05:51 <Binkley> Do you know what I mean by that?
08:06:34 <astrolabe> > 1^2 + (2^2+2^2)^2
08:06:35 <lambdabot>  65
08:07:06 <glguy> ?type (>>)
08:07:07 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
08:07:08 <glguy> ?type (><)
08:07:10 <lambdabot> Not in scope: `><'
08:07:17 <Binkley> ?type (^_^)
08:07:18 <lambdabot> parse error on input `)'
08:07:25 <glguy> ?type Data.Graph.Inductive.Query.Monad.(><)
08:07:26 <lambdabot>   Not in scope: data constructor `Data.Graph.Inductive.Query.Monad'
08:07:26 <lambdabot>  
08:07:44 <glguy> ?hoogle (>>)
08:07:46 <lambdabot> Did you mean: (>>)
08:07:46 <lambdabot> Prelude.undefined :: a
08:07:46 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:07:52 <glguy> ?hoogle >>
08:07:53 <lambdabot> Prelude.(>>) :: Monad m => m a -> m b -> m b
08:07:53 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
08:07:53 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
08:07:55 <glguy> ?hoogle ><
08:07:55 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:08:12 <glguy> is that like &&&?
08:08:17 <glguy> ?type (&&&)
08:08:19 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:08:42 <glguy> errr
08:08:44 <glguy> ?type (***)
08:08:46 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:08:47 <Cale> babusrini, Binkley: http://cale.yi.org/index.php/Fold_Diagrams
08:08:50 <lambdabot> Title: Fold Diagrams - CaleWiki
08:09:06 <Binkley> Cale: thanx
08:09:13 <Binkley> babusrini: yes, take a look at the upper left-hand diagram
08:09:19 <Binkley> try it with your values of f and z
08:09:27 <RemiTurk> hi everyone
08:09:32 <Cale> hi
08:09:40 <Binkley> @karma+ Cale
08:09:40 <lambdabot> Cale's karma raised to 21.
08:10:18 <hyrax42_> oh goddamn it
08:10:20 <hyrax42_> no tail recursion
08:10:32 <Cale> hm?
08:10:59 <Cale> tail recursion is actually kind of evil a good lot of the time
08:11:03 <vincenz> Cale: ah!
08:11:08 <vincenz> Cale: wrong
08:11:19 <vincenz> Cale: tail recursion is the splitting knife betweene eager and lazy fps
08:11:36 <babusrini> astrolabe, OK. I parsed it as ( (1*1 + 2*2) * (1*1 + 2*2) ) + 2*2 which is 29
08:11:39 <Cale> wrong?
08:11:43 <Binkley> vincenz: perhaps I'm slow, but why couldn't you have proper tail-recursion in an eager functional language?
08:11:46 <Binkley> IIRC, Scheme is required to have it
08:11:46 <Cale> I didn't even explain :)
08:11:51 <vincenz> Binkley: what?
08:11:53 <vincenz> Binkley: nono
08:12:16 <vincenz> Binkley: For list creation, in haskell you -don't- want tail recursion cause you force out laziness, and in eager languages you -do- want it or you get stackblow
08:12:27 <astrolabe> babusrini: Ah, check Cale's link.
08:12:30 <Binkley> ah, sorry. should have waited you to explain before starting to argue :-)
08:12:31 <vincenz> IT's the one main difference in coding I felt between haskell and ocal
08:12:33 <vincenz> ocaml
08:12:41 <Cale> If you have a choice between writing something tail recursively, and writing it so that it produces a constructor right away, then you probably want to choose the latter.
08:12:44 <vincenz> Binkley: no it's good, I tend ot not explain enough otherwise
08:12:53 <ndm> psnl: ah, that does sound quite drunk :)
08:12:54 <vincenz> Cale: in haskell yes, not in eager fps
08:13:05 <Cale> yes, this is #haskell, right?
08:13:09 <Cale> hehe
08:13:16 <hyrax42_> for me right now it's #C :(
08:13:26 <Cale> aha :)
08:13:32 <hyrax42_> the problem is I just defined my main program loop tail-recursively
08:13:36 <hyrax42_> which will blow stack
08:13:43 <hyrax42_> and I'm too lazy to fix it
08:13:44 <Cale> Doesn't gcc implement tail recursion?
08:13:54 <hyrax42_> does?
08:13:57 * hyrax42_ has no clue
08:14:08 <rahikkala> It does, at least for C
08:14:09 <Binkley> presumably if it does, it's only in some special cases?
08:14:23 <Binkley> and possibly requires having optimization turned on?
08:14:28 <rahikkala> Definitely
08:14:38 <rahikkala> -foptimize-sibling-calls IIRC
08:14:45 <psnl> ndm: we did  all give him cash...
08:15:11 <Cale> ndm: christina was here earlier asking about how to uninstall winhugs
08:15:24 <Cale> er, christine
08:15:27 <babusrini> Binkley, astrolabe, thanks I will look at the Fold_diagrams
08:15:50 <ndm> Cale: why would anyone want to uninstall it? ;)
08:15:50 <Cale> babusrini: the top left one in particular
08:16:09 <ndm> Cale: although Add/Remove programs in the Control panel should work fine - although there have been some bug reports of it not working
08:16:20 <Cale> ndm: she said it wasn't listed there
08:16:22 <ndm> Cale: deleting the C:\Program Files\WinHugs will also work just fine
08:16:27 <Cale> ah, okay
08:16:37 <ndm> Cale: which version of WinHugs? Any from this year should be listed there, older ones won't be
08:16:49 <Cale> ah, I think that might have been the problem
08:16:50 <ndm> (since i didn't write them, and they had no uninstaller)
08:17:37 * Cale ponders how windows people manage to get by without a standard package management system.
08:17:58 <Binkley> Cale: poorly
08:18:07 <ndm> Cale: i have no idea either...
08:18:15 <ndm> it would be nice to have
08:20:31 <RemiTurk> by reinstalling the whole system every year?
08:22:29 <vincenz> sudo rm -rf c:\
08:24:14 <pejo> Cale, isn't the packages called MSI or something like that?
08:24:51 <glguy> > let bwTransform xs = liftM2 (:) last init $ (iterate (sort . zipWith (:) xs) [[] | _ <- xs] !! length xs) !! 5 in bwTransform "OBRSDDB"
08:24:53 <lambdabot>  "DRDOBBS"
08:25:10 <Cale> pejo: I think they do have something along those lines, but it's sort of like deb/rpm files, rather than something along the lines of apt
08:25:14 <psnl> http://sneezy.cs.nott.ac.uk/fun/nov-06/receipt.pdf <- what were we thinking?
08:25:16 <lambdabot> http://tinyurl.com/yf89x7
08:25:29 <Cale> also, most people don't seem to use MSI files
08:25:58 <dylan> @hoogle chdir
08:25:59 <lambdabot> No matches found
08:26:22 <vincenz> psnl: holy fuck
08:26:23 <pejo> Cale, um, deb/rpm files are packages, hence rpm/dpkg is the package management system.
08:26:47 <dylan> msi files don't have dependency information, do they?
08:26:53 <pejo> (I'm the first one to admit apt/yum are handy).
08:27:24 <Cale> dylan: I don't think they do
08:27:43 <dylan> I hate yum, but not as much as up2date...
08:28:06 <dylan> admining a RHEL system is about like adminning a windows box, package-wise.
08:28:08 <Cale> and without that, it's a little hard to even say that it's like dpkg/rpm
08:28:51 <Cale> But yeah, by "package management", I mean a system which manages collections of packages.
08:29:00 <Cale> Not individual package files.
08:30:07 <dylan> what's haskell call chdir?
08:30:19 <dino-> I don't know how widespread its use is, but about a year ago I was working with a Fedora user who was using apt-rpm with it.
08:30:22 <dylan> I hoogled for changeDirectory and changeCurrentDirectory...
08:30:39 <dylan> dino-> apt-rpm is deprecated in favor of yum
08:30:46 <dino-> ah, I didn't know that
08:30:56 <dylan> due to the technical inferiority of yum, IMHO.
08:31:42 <dylan> at least 'yum search' works, though. The best way of searching for things with up2date is up2date --showall | grep
08:32:36 <glguy> > let bwTransform xs = liftM2 (,) succ ((liftM2 (:) last init $ iterate (sort . zipWith (:) xs) (map (const []) xs) !! length xs) !!) (fromJust . findIndex (head xs ==) $ sort xs) in bwTransform "OBRSDDB"
08:32:44 <lambdabot>  (5,"DRDOBBS")
08:33:04 <vincenz> glguy: o.O
08:33:17 <glguy> It's the FRIDAY PUZZLE!
08:33:51 <glguy> I'm writing it on one line to test it in IRC
08:37:04 <glguy> sort is stable, right?
08:37:08 <glguy> ?hoogle stable
08:37:09 <lambdabot> Foreign.StablePtr :: module
08:37:09 <lambdabot> System.Mem.StableName :: module
08:37:09 <lambdabot> Foreign.StablePtr.StablePtr :: data StablePtr a
08:37:42 <ndm> pejo: they have .msi files, but they are more like executable installers with a bit of logic offloaded to a library - not real package installation
08:38:02 <ndm> dylan: setCurrentDirectory
08:39:15 <dylan> hm, or changeWorkingDirectory
08:44:06 <ndm> @hoogle directory
08:44:07 <lambdabot> Directory :: module
08:44:07 <lambdabot> Distribution.Compat.Directory :: module
08:44:07 <lambdabot> System.Directory :: module
08:44:13 <ndm> @hoogle setDirectory
08:44:14 <lambdabot> System.Console.Readline.setDirectoryCompletionHook :: Maybe (String -> IO String) -> IO ()
08:44:34 <ndm> @hoogle setCurrentDirectory
08:44:35 <lambdabot> Directory.setCurrentDirectory :: FilePath -> IO ()
08:44:35 <lambdabot> System.Win32.File.setCurrentDirectory :: String -> IO ()
08:44:35 <lambdabot> System.Win32.File.c_SetCurrentDirectory :: LPCTSTR -> IO Bool
08:45:32 <dylan> changeWorkingDirectory is in System.Posix.Directory
08:46:22 <ndm> dylan: if you use setCurrentDirectory it will work on Posix and Windows, that will break your app on Windows
08:46:37 <dylan> my app won't work on windows anyway
08:46:55 <dylan> as it needs symlinks and dotfiles.
08:47:01 <ndm> dylan: yes, but one day someone might want to port it - best to do all you can to make it work easier
08:47:06 <ndm> dylan: windows has both of them
08:47:36 <dylan> it'd work under cygwin
08:48:19 <ndm> @karma- cygwin -- for being horrible
08:48:19 <lambdabot> cygwin's karma lowered to -1.
08:48:35 <dylan> indeed. I don't even program for windows on window.s
08:48:38 <dylan> *windows.
08:48:58 <dylan> I program on *nix and push the (perl) source over a samba share. ;)
08:49:23 <dylan> anyway, this is basically a super-smart shell script, so I can 'snarf' my dotfiles to ~/wc/conf/dotfiles/
08:49:42 <dylan> the rest of the system won't work without the Z shell anyway
08:49:50 <ndm> zsh works on windows :)
08:51:04 <dylan> can one have 200x60 terminals on windows?
08:51:06 <yaarg> cygwin is the only thing that makes my life on windows bearable
08:51:18 <yaarg> i use putty for a local cygwin shell
08:51:34 <ventonegro> yaarg: indeed
08:51:46 <glguy> is there a ever a compelling erason to write: map (uncurry (:)) (x `zip` y) -- instead of -- zipWith (:) x y?
08:51:53 <ventonegro> windows without msys / cygwin is unbearable
08:52:07 <dylan> indeed.
08:52:30 * glguy doesn't understand the need for cygwin and does everything in putty windows on a different machine
08:52:32 <astrolabe> a lot of people are stuck with windows
08:52:33 <dylan> it's department-wide policy that IT doesn't run windows, here.
08:52:46 <sjanssen> glguy: only reason I can imagine is not knowing zipWith
08:52:52 <dylan> Except in a VNC session.
08:52:55 <ventonegro> glguy: that's because you have 2 machines :-)
08:53:11 <Ontolog> http://pastebin.com/826713
08:53:19 <Ontolog> Something is wrong with line 15
08:53:26 * glguy 's IT department uses .NET langauges almost exclusively... having to program through a VNC session would suck :)
08:53:48 <dylan> programming autocad crap through VNC isn't bad
08:54:00 <vincenz> programming autocrap cad?
08:54:06 <sjanssen> Ontolog: what is the compiler error?
08:54:08 <dylan> most of the time I do it in a vim session locally, with the file being on a file server
08:54:19 <yaarg> 'cause the standard unix utils are still useful on windows?
08:54:22 <dylan> and just use VNC to load/compile it
08:54:29 <yaarg> although not quite as useful for sysadminy type stuff
08:55:07 <sjanssen> the error is in line 13
08:55:23 <sjanssen> Ontolog: ^^^, you should have "return ()", not []
08:55:36 <Ontolog> ok thnaks
08:55:53 <ndm> astrolabe: i choose to run windows
08:56:03 <sjanssen> for future reference, always post the compiler error when you're having trouble with code
08:56:14 <ndm> ventonegro: and choose not to use mingw or cygwin
08:56:16 <vincenz> As well as the error you made :)
08:56:25 <dylan> I choose to never use a mouse, so windows is difficult to use. :)
08:56:29 * glguy prefers windows on the desktop, and BSD in a terminal window
08:57:02 <ventonegro> ndm: i don't have any problem with this
08:57:03 <yaarg> i prefer coding on linux and photo editing and doing my media stuff on windows :-)
08:57:10 <ventonegro> ndm: but *I* don't like it
08:57:25 <dylan> I wonder, has anyone ported ion3 to windows?
08:57:39 <glguy> it should be mildly difficult to get a heated OS debate going in this channel
08:57:50 <ventonegro> brb
08:58:00 <dylan> windows isn't that, the default window manager is annoying though.
08:58:12 <dylan> *isn't that bad
08:59:16 <glguy> Linux is OK, but it's GPL'd and I prefer a free license ;)
08:59:27 * shapr boings
08:59:40 * shapr throws lambdas
08:59:42 <sjanssen> glguy: but you're okay with Windows? ;)
08:59:42 * vincenz sgniobs shapr 
08:59:57 <vincenz> shapr: lambdas are curved like bananas, they return
09:00:11 <Renkin> does anyone know a good site for learning basic drawing shapes and lines in wxHaskell?
09:00:17 * shapr gets smacked from behind
09:00:23 <Renkin> The quickstart is nice, but it's not so much about drawing
09:00:39 <glguy> sjanssen: yeah, but when I have to chose between a BSD licensed OS, and a GPL'd one, I'll chose the BSD one
09:00:53 * vincenz wonders what the hell the license of an OS matters
09:01:00 <vincenz> unless you're developing one
09:01:13 <shapr> Hey, don't talk bad about my holy war!
09:01:14 <dylan> vincenz> almost everything I use I find the need to change.
09:01:23 <glguy> vincenz: it's the principle of the thing :)
09:01:27 * shapr jihaas vincenz' license
09:01:29 <dylan> or utterly rewrite.
09:01:30 <vincenz> dylan: I guess you don't have Real Work (TM)
09:01:31 <Binkley> ?remember shapr Hey, don't talk bad about my holy war!
09:01:39 <dylan> vincenz> I'm an IT department.
09:01:47 <vincenz> dylan: you -are- a departement?
09:01:52 <dylan> I just hate anything that doesn't do exactly what I want.
09:01:54 <dylan> vincenz> yes.
09:02:00 * shapr hugs Binkley
09:02:01 <vincenz> dylan: like the walls and everything?
09:02:02 <glguy> dylan: you wouldn't like me thing
09:02:04 <glguy> then*
09:02:11 <dylan> I am the only person fully capable of doing anything IT related here.
09:02:15 * vincenz pokes shapr and hugs Binkley 
09:02:17 <Binkley> *huggles*
09:02:20 <shapr> wheee
09:02:23 <dylan> glguy> you're not software.
09:02:31 <glguy> dylan: could be a bot?
09:02:36 <SyntaxNinja> y0y0
09:02:42 <dylan> glguy> hmm, perhaps. Where's your source code?
09:02:43 <shapr> If I don't exercise more I'll just be firmware :-/
09:02:54 <SyntaxNinja> shapr: get on that unicycle!
09:02:54 <glguy> dylan: using colons is better than greater than symbols when addressing someone in IRC
09:02:57 <glguy> =D
09:02:58 <vincenz> shapr: not hardware?
09:03:22 <Binkley> exercising would make you hardware
09:03:33 <dylan> glguy: oh. I changed irssi's default because someone in another channel didn't like colons.... usually I just tab complete names
09:03:42 <shapr> vincenz: Right. Santa Claus can have a bowl full of jelly, but it's not appealing on programmers.
09:03:54 <glguy> dylan: I don't actually care, I'm just trying to start a battle in some fashion
09:03:59 <SyntaxNinja> someone didn't like colons? man. IRC has gotten really anal in the last couple of months ;)
09:04:05 <vincenz> shapr: no the big glasses are
09:04:15 <Binkley> if IRC were anal, it *would* like colons
09:04:17 <shapr> Aw, I only have small titanium glasses.
09:04:18 <Binkley> *hides under desk*
09:04:23 <shapr> Binkley: ick!
09:04:24 <SyntaxNinja> Binkley: omg
09:04:33 <sjanssen> a colon is the most grammatically reasonable character to use
09:04:53 * SyntaxNinja is going to go find the syntax police if you guys aren't careful.
09:05:02 <shapr> Binkley: yow, busy day at the orifice?
09:05:07 <Binkley> the syntax police, they live in my parser
09:05:14 <Binkley> shapr: heh, i misread that at first
09:05:26 <Binkley> Answer is no. Maybe this weekend, though...
09:05:32 <Binkley> *whistles nonchalantly*
09:05:32 <vincenz> orifice?
09:05:35 <shapr> I should NOT have asked.
09:05:41 <Binkley> so how about those local sports teams
09:05:46 <glguy> SyntaxNinja: Who polices the police?
09:05:51 * vincenz *blinks*
09:05:51 <Binkley> lulz
09:05:58 <shapr> vincenz: In American english 'orifice' sounds like 'office' when spoken quickly.
09:06:11 <sjanssen> glguy: the ninjas?
09:06:17 <shapr> And their death robots?
09:06:20 <glguy> The police police police police!
09:06:27 <glguy> But who polices the police police?
09:06:47 <Binkley> STACK OVERFLOW to increase use +RTS -K -RTS
09:06:53 <sieni> - "please come to my back office."
09:06:59 <glguy> The police police police police police police!
09:07:01 <sieni> - "what did you say?!?!?!"
09:07:17 <Binkley> man, you know it's 5 PM on a Friday when...
09:07:19 <sjanssen> > unwords . replicate 8 $ "buffalo"
09:07:20 <lambdabot>  "buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo"
09:07:39 <glguy> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo.
09:07:43 <sieni> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo
09:07:47 <glguy> I win!
09:07:50 <glguy> ;)
09:08:19 <ToRA> > "arrrrrgh!" >> "Buffalo "
09:08:21 <lambdabot>  "Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo "
09:09:42 <SyntaxNinja> glguy: the ninjas!
09:09:58 <SyntaxNinja> oh, sieni already said that. bah
09:10:03 <sjanssen> > join (>>) "Buffalo "
09:10:04 <lambdabot>  "Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo Buffalo "
09:10:16 <kaol> > guard (0 == 1) >> "Buffalo"
09:10:18 <lambdabot>  ""
09:12:18 <vincenz> @type guard
09:12:19 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:12:52 <glguy> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo Buffalo buffalo buffalo
09:13:02 <glguy> (still valid)
09:14:56 <kaol> > unfoldr (\x -> guard (x /= 0) >> return (uncurry (flip (,)) (divMod x 10))) 1234567890
09:14:57 <lambdabot>  [0,9,8,7,6,5,4,3,2,1]
09:16:15 <glguy> > liftM2 (:) last init [9..0]
09:16:17 <lambdabot>  Exception: Prelude.last: empty list
09:16:29 <glguy> > liftM2 (:) last init [9,8..0]
09:16:31 <lambdabot>  [0,9,8,7,6,5,4,3,2,1]
09:16:57 <kaol> > unfoldr (\x -> guard (x /= 0) >> return (uncurry (flip (,)) (divMod x 7))) 1234567890
09:16:59 <lambdabot>  [3,0,2,0,4,4,0,1,4,2,4]
09:18:27 <glguy> > unfoldr (liftM2(>>)(guard.not.null)(Just .splitAt 2)) [0..9]
09:18:29 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8,9]]
09:39:59 * shapr boings
09:40:09 * dcoutts_ grins
09:40:24 <ValarQ> %¬§#& boinging...
09:40:43 * vincenz boings shapr in dcoutts's general direction
09:40:48 <vincenz> Catch!
09:40:52 <dcoutts_> aaahrg!
09:41:34 <vincenz> Poor dcoutts_, stuck behind the wrong profile and therefore unable to stop the shaprinvasion
09:41:56 <dcoutts_> freaks!
09:41:57 * dcoutts_ runs away
09:42:23 <astrolabe> I can't parse this as haskell
09:42:51 <astrolabe> onExpose canvas $ \Expose {eventRegion = region } -> do ... return True
09:43:05 <dcoutts_> astrolabe, which bit?
09:43:15 <araujo> morning
09:43:22 <shapr> Time for Haskell lunch!
09:43:32 <astrolabe> dcoutts \Expose with a captial seems wierd
09:43:44 <astrolabe> then I don't know what the {} are about either
09:44:22 <dcoutts_> astrolabe, it's record pattern matching
09:44:28 <astrolabe> oh.  of course
09:44:31 <astrolabe> thanks
09:59:23 <kpreid> ha! it works!
09:59:30 <kpreid> *Eval> peval "map (\\m -> m >>= \\x -> return (succ x)) [[1], Just 3]"
09:59:30 <kpreid> ParseOk [[2],(CoJust 4)]
09:59:39 <kpreid> dynamically typed haskell :-)
10:00:04 <vincenz> ?
10:00:22 <vincenz> What is CoJust
10:00:32 <kpreid> a broken bit of my evaluator
10:00:45 <kpreid> all the datatypes are special cases at the moment
10:00:47 <glguy> kpreid: what's this \\ business?
10:00:53 <vincenz> glguy: ever heard of strings?
10:00:56 <kpreid> lambdas written inside strings
10:01:00 <glguy> OHH
10:01:05 <glguy> vincenz: nope
10:01:08 * vincenz gives glguy a gun for his foot
10:01:22 <glguy> ha, that was a silly mistakes
10:01:25 <glguy> mistake* :)
10:01:32 <glguy> shoots vincenz's foot
10:02:35 <opqdonut> I get a "parse error (possibly incorrect indentation)" on the last line of my source file
10:02:42 <kpreid> this works by having 'values' which are dependent on the expected typeclass instance to support return and so on
10:03:02 <opqdonut> (which is an empty line)
10:03:03 * lambdabot kicks glguy in the nuts
10:03:29 <glguy> lol, making lambdabot fight your battles
10:03:37 <Binkley> ?remember glguy lol, making lambdabot fight your battles
10:03:55 <vincenz> Binkley: how do you copy paste so fast
10:03:56 <pkhuong-> kpreid: that sounds like a lot of indirection.
10:04:09 <ski> 'CoJust' ?
10:04:19 <kpreid> pkhuong-: well, it ain't exactly intended to be practical...
10:04:24 <Binkley> vincenz: lots of practice
10:04:24 <glguy> in putty, you just have to highlight the text and it's copied... shift insert or right click pastes
10:04:33 <glguy> I think it's the same in xterm (middle click maybe?)
10:04:38 <vincenz> @remember Binkley vincenz: lots of practice
10:04:47 <vincenz> That can be taken -so- out of context
10:04:49 <Binkley> no, no, it's not putty. it's my extra-fast brain
10:04:50 <Binkley> heh
10:04:52 <opqdonut> glguy: same thing thruout x
10:04:58 <Binkley> well, lots of things can be taken out of context.
10:05:03 <glguy> I'm mostly impressed that he commits to ?remember ing things so fast
10:05:22 <vincenz> glguy: Binkley was faster
10:05:27 <Binkley> well, I'm often in error and never in doubt
10:05:30 <glguy> I usually take a while to decide it needs to be immortalized
10:05:52 <kpreid> pkhuong-: I haven't given it enough testing to be certain it works in all cases, either
10:06:16 <vincenz> glguy: your brain is slower, the string is an excellent demonstration
10:06:17 <Binkley> obviously there needs to be a complicated system for voting on which of the lambdabot quotes are best, and GCing the unpopular ones periodically
10:06:21 <pkhuong-> kpreid: so basically you delay everything until you have enough information to force it w/ the right type?
10:06:41 <kpreid> pkhuong-: exactly
10:06:45 <vincenz> > "\\"
10:06:47 <lambdabot>  "\\"
10:06:53 <glguy> vincenz: actually, if you want to go back to just telling lambdabot your complaints in private, that would be fine
10:07:05 <vincenz> I will
10:07:06 * vincenz sighs
10:07:29 <Binkley> @yow
10:07:30 <lambdabot> RELATIVES!!
10:07:39 <Binkley> @keal
10:07:39 <lambdabot> i just got banned from math because i not have good ability to convey thoughts
10:08:19 <vincenz> @protontorpedo
10:08:19 <lambdabot> are objects kina just subroutines
10:08:25 <Binkley> @quote qwe1234
10:08:26 <lambdabot>  a language with type inference isn't more expressive -- because type declarations are redundant, much like 'sigils' in perl.
10:08:33 <vincenz> ooh, qwe1234
10:08:37 <Binkley> @quote qwe1234
10:08:37 <lambdabot>  laziness is TEH SUCK, by the way. there's a reason we got rid of it after writing the first fortran compiler.
10:08:43 <vincenz> @palomer
10:08:43 <glguy> qwe1234, isn't he on reddit a lot?
10:08:43 <lambdabot> Brump!
10:08:46 <vincenz> @palomer
10:08:47 <Binkley> yeah
10:08:47 <lambdabot> (_|_)
10:08:49 <vincenz> glguy: yeah
10:08:50 <Binkley> @palomer
10:08:51 <lambdabot> I think vim is good for the rubbish bin
10:09:26 <glguy> ?grauenwolf
10:09:27 <lambdabot> Unknown command, try @list
10:09:30 <glguy> :(
10:09:32 <Binkley> hah#
10:09:37 <Binkley> @quote grauenwolf
10:09:37 <lambdabot> grauenwolf hasn't said anything memorable
10:09:55 <pitecus> can one fake paramtized modules in haskell somehow?
10:09:57 <glguy> He makes some pretty dumb comments, but they are all stored away in Reddit... we need to get him to stop by
10:10:14 <Binkley> pitecus: sure, with functions and records
10:10:27 <vincenz> @quote glguy
10:10:27 <lambdabot>  this is like Web 5GL. I like it
10:10:37 <vincenz> @quote glguy
10:10:38 <lambdabot>  lol, making lambdabot fight your battles
10:10:44 <lispy> ?quote lispy
10:10:45 <lambdabot>  a := new Maybe(); a.envalue(1);
10:10:45 <vincenz> @quote vincenz
10:10:46 <lambdabot>  Geek is Chique.
10:10:49 <vincenz> \o/
10:10:51 <Binkley> @quote Binkley
10:10:52 <lambdabot>  are there any Haskell users who haven't implemented a compiler?
10:10:58 <pitecus> ok
10:11:03 <lispy> heh
10:11:04 <therp> that's a nice quote :)
10:11:08 <vincenz> @quote Binkley
10:11:09 <lambdabot>  are there any Haskell users who haven't implemented a compiler?
10:11:13 <astrolabe> @quote astrolabe
10:11:13 <lambdabot>  I guess missile launching would have to be in IO
10:11:14 <vincenz> lambdabot: you're repetitive
10:11:15 <vincenz> @quote Binkley
10:11:16 <lambdabot>  can you represent "more moronic than Slashdot" with a 32-bit integer?
10:11:41 <astrolabe> @quote Cale
10:11:42 <lambdabot>  [discussing names for Haskell, after suggesting Sapphire] Diamond: The Hardest Programming Language on Earth
10:11:54 <astrolabe> heh
10:12:18 <vincenz> @quote roconnor
10:12:19 <lambdabot>  If one wants to go swimming with sharks, or program in a non-pure langauge, I suppose that is one's choice
10:12:33 <lispy> ?quote dons
10:12:34 <lambdabot>  the type system is *great* for coding while sleepy.. you just hack any garbage together, and let the type checker deal with it
10:12:41 <vincenz> @quote vincenz
10:12:42 <lambdabot>  shapr: lambdas are curved like bananas, they return
10:12:49 <vincenz> hmm
10:12:51 <lispy> ?quote shapr
10:12:51 <lambdabot>  Academics are continually chewing pieces off of impossible and making them merely difficult.
10:13:16 <lispy> ?quote dcoutts_
10:13:17 <lambdabot> dcoutts_ hasn't said anything memorable
10:13:20 <lispy> ?quote dcoutts
10:13:20 <lambdabot>  jcreigh, you mentioned Haskell, so dons found you. He can smell that kind of thing.
10:13:21 <eviltwin_b> pitecus: parsec does some (simplistic) trickery to simulate it
10:14:46 <pitecus> I'll look at it eviltwin_b
10:14:48 <pitecus> thanks
10:15:04 <lispy> pitecus: you trust someone named eviltwin_b ?
10:15:26 <opqdonut> Hey, i get a "parse error (possibly incorrect indentation)
10:15:31 <opqdonut> " on an empty line
10:15:43 <opqdonut> and the line before that should be fine, parens match etc
10:15:56 <Binkley> opqdonut: that doesn't mean the error is on that line, it means that there are mismatching parens or incorrect indentation elsewhere, and the parser got confused
10:16:14 <eviltwin_b> heh
10:16:41 * eviltwin_b is just a bit tired of being mistaken for Russ online
10:17:00 <tibbe> happs.org is down :(
10:17:14 <glguy> Not for me
10:17:15 <lispy> eviltwin_b: who is this russ you speak of?
10:17:26 <tibbe> hmpf
10:17:34 <lispy> ?palomer
10:17:34 <opqdonut> Binkley: the whole file is just one level of indentation, one line definitions
10:17:34 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
10:17:40 <opqdonut> Binkley: and as i said, the parens match
10:17:54 <eviltwin_b> hm, guess people don't look behind the /nick here
10:18:02 <vincenz> behind the nick?
10:18:03 <Binkley> opqdonut: could be another syntax error, then.
10:18:07 <lispy> opqdonut: to help more, we'd have to see it
10:18:10 <lispy> ?where paste
10:18:10 <lambdabot> http://paste.lisp.org/new/haskell
10:18:23 <tibbe> I think they use IP-over-iPod here in France. Someone collects all the packets, puts them on an iPod and takes a plane to whatever country they are distined for.
10:18:23 <Binkley> oh! russ allbery
10:18:35 <tibbe> either that or well all share one 1200 baud modem
10:18:38 <opqdonut> ok, will paste
10:18:54 <lispy> allbery_b: hey russ
10:18:56 <Binkley> he's in my random .signature file :-)
10:18:56 <tibbe> s/distined/destined
10:18:57 <lispy> ;)
10:19:03 * allbery_b rols his eyes
10:19:08 <glguy> tibbe: are you trying to download the 0.8.4 tarball?
10:19:09 * allbery_b rolls his eyes
10:19:26 <lisppaste2> opqdonut pasted "syntax error on line 10" at http://paste.lisp.org/display/30098
10:19:30 <tibbe> glguy: I got there now :)
10:19:36 <tibbe> i.e. it worked
10:19:46 <glguy> oh, cool (I was going to DCC it to you if you wanted
10:19:49 <Binkley> opqdonut: are you a perl programmer by any chance?
10:20:13 <vincenz> Binkley: don't insult people
10:20:14 <opqdonut> Binkley: we have a oneliner competition here :)
10:20:27 <Binkley> heh
10:20:44 <Binkley> you try to write a one-liner and then you complain when you can't isolate syntax errors? :-)
10:20:44 <glguy> opqdonut: where is the problem statement?
10:20:44 <opqdonut> and yes, i happen to be somewhat of a perl programmer :)
10:20:52 <lispy> opqdonut: by my count you don't have 10 lines
10:20:57 <opqdonut> yep
10:21:04 <opqdonut> the error is on the last "empty" line
10:21:19 <opqdonut> sorry, line 8 that is
10:21:22 <vincenz> opqdonut: because your [] code is wrongly put there
10:21:31 <vincenz> opqdonut: it needs to be onthe same line as foo or indented
10:21:54 <opqdonut> vincenz: it is
10:22:06 <opqdonut> that foo def. is one line
10:22:07 <Binkley> yeah, it's just getting wrapped
10:22:22 <vincenz> ah nm
10:22:38 <vincenz> interesting
10:22:40 <vincenz> add more lines
10:22:42 <tibbe> glguy: I had this idea to add a REST module for a while now
10:22:45 <vincenz> the problem keeps moving
10:22:50 <vincenz> I think you might have an unmatched something
10:23:51 <lispy> seems like there might be an unmatched paren in the list comp
10:24:04 <vincenz> yep
10:24:06 <vincenz> unmatched parens!
10:24:16 <lispy> > [(\x->(x,x))((3*x/w-2) :+ (2*y/h-1)) | y <- [0..h], x <- [0..w]]
10:24:17 <lambdabot>  Not in scope: `w'
10:24:26 <opqdonut> d'oh!
10:24:41 <lispy> > [(\x->(x,x))((3*x/5-2) :+ (2*y/h-1)) | y <- [0..h], x <- [0..5]]
10:24:42 <lambdabot>  Not in scope: `h'
10:24:43 <opqdonut> emacs doesn't recognize \( ) as a paren pair
10:24:53 <lispy> > [(\x->(x,x))((3*x/5-2) :+ (2*y/10-1)) | y <- [0..10], x <- [0..5]]
10:24:55 <lambdabot>  [((-2.0) :+ (-1.0),(-2.0) :+ (-1.0)),((-1.4) :+ (-1.0),(-1.4) :+ (-1.0)),((-...
10:25:10 <opqdonut> and i had the defs of w and h in the file but i removed them for the paste
10:25:25 <opqdonut> (and to check whether they were the problem
10:25:27 <opqdonut> but yeah, solved
10:25:33 <lispy> well,t hat list comp worked
10:25:37 <lispy> so where was the paren missing?
10:26:18 <lispy> anyway, i'm outtie
10:26:29 <opqdonut> \(x0,x) -> if magnitude ....
10:26:39 <opqdonut> emacs didn't recognize those as a paren pair
10:26:52 <opqdonut> so i was one paren short in the end just before the list comp
10:27:08 <kpreid> you could write \ (x0,x) -> to help emacs
10:28:18 <glguy> you ought to just be able to use iterate and takeWhile instead of unfoldr
10:28:31 <glguy> if you are trying to shorten it
10:34:57 <Syzygy-> Oh joy.
10:35:13 <Syzygy-> The nehe-tutorial lesson 5 crashes my X when I try to resize the bloody window.
10:39:27 <opqdonut> glguy: that's what i'm doing right now ^^
10:43:18 <glguy> and rather then doing the (\x -> (x,x)) you can just say: (\x -> iterate ((x+).(^2)) x)
10:45:57 <glguy> -or- you could use unfoldr to do the countign
10:46:00 <glguy> instead of length
10:46:16 <glguy> err
10:46:28 <glguy> yeah, i guess that wouldn't help much, since you'd stil have to call last
10:46:48 <glguy> it'd be more of a foldl operation
10:48:34 <sjanssen> @scheck (\xs -> foldl1 (flip const) xs == last xs) :: [Int] -> Bool
10:48:36 <lambdabot>  Exception: Prelude.foldl1: empty list
10:50:04 <arjanoosting> @seen CosmicRay
10:50:05 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 2h 28m 30s ago, and .
10:51:56 <glguy> opqdonut: instead of mapping twice (beginning and with the list-comprehensino at the end, you can merge the whole into into the list comprehension
10:52:21 <glguy> foo = putStr $ [(".-~^,:=+rcfkwO*H8#B@$"!!) . (`div` 5) . length . take 100 . takeWhile ((<100) . magnitude) . (\x-> iterate ((+x).(^2)) x) $ (3*x/w-2) :+ (2*y/h-1) | y <- [0..h], x <- [0..w]]
10:54:59 <opqdonut> glguy: good point
10:55:13 <glguy> and of course that makes the first $ unnecessary
10:55:31 <glguy> oh, and what exactly ist his code doing?
10:56:39 <opqdonut> hehe, drawing the mandelbrot set in ascii
10:56:53 <glguy> ah, ok
10:56:55 <ascii> ?
10:57:12 <glguy> makes sense, so h and w are the height and width of the terminal?
10:57:33 <ndm> @seen monochrome
10:57:34 <lambdabot> I haven't seen monochrome.
10:57:42 <ndm> @seen mono*
10:57:43 <lambdabot> I haven't seen mono*.
10:58:00 <ndm> we need regular expression support for @seen! anyone remember the user name of mono...
10:58:27 <ndm> @seen monochrom
10:58:28 <lambdabot> I saw monochrom leaving #haskell-blah and #haskell 13h 1m 35s ago, and .
10:58:28 <opqdonut> glguy: yep
10:58:30 <sjanssen> @seen monochrom
10:58:30 <lambdabot> I saw monochrom leaving #haskell-blah and #haskell 13h 1m 37s ago, and .
10:58:59 <ndm> @tell monochrom There are some docs on unsafeJS now, http://haskell.org/haskellwiki/Yhc/Javascript/Programmers_guide#Calling_Javascript_from_Haskell:_unsafeJS
10:59:00 <lambdabot> Consider it noted.
10:59:08 <glguy> hmm.. is there a good way to determine what the dimensions of your terminal are?
10:59:15 <glguy> without actually counting the characters
10:59:30 <opqdonut> echo $LINES $COLUMNS
10:59:50 <glguy> brilliant :)
10:59:55 <opqdonut> :)
11:00:09 <opqdonut> glguy: your version is slower that the original tho
11:00:13 <opqdonut> not that that matters
11:03:19 <glguy> I'm not sure why... I tried to nto change the meaning
11:03:54 <glguy> "tried to not"
11:04:00 <opqdonut> :)
11:04:09 <opqdonut> must be some laziness thing
11:04:12 <opqdonut> (as always)
11:05:59 <glguy> opqdonut: switch the take 100
11:06:01 <glguy> and takeWhile
11:06:06 <opqdonut> yep
11:07:58 <Syzygy-> @tell gds You know, I get completely different mental images of you depending on whether I see you @ LJ or @ #haskell...
11:07:59 <lambdabot> Consider it noted.
11:08:31 <opqdonut> glguy: shortest c++ is 137 chars :/
11:08:44 <opqdonut> (w/o imports both)
11:09:42 <gds> Syzygy-: :)
11:09:43 <lambdabot> gds: You have 1 new message. '/msg lambdabot @messages' to read it.
11:10:01 <glguy> opqdonut: do you count white space?
11:10:08 <opqdonut> glguy: i removed all of them
11:10:20 <opqdonut> we're at 156
11:10:24 <gds> Syzygy-: I guess I ramble more on LJ ;)
11:10:29 <glguy> fromMaybe 100 . findIndex ((>=100) . magnitude)
11:10:34 <glguy> this is more efficient... but longer
11:10:42 <opqdonut> well, bbl, off to sauna
11:10:46 <paolino> @seen xerox
11:10:47 <lambdabot> I saw xerox leaving #haskell.it, #haskell-overflow and #haskell 1d 21h 12m 18s ago, and .
11:12:36 <glguy> (\x->".-~^,:=+rcfkwO*H8#B@$"!!div x 5) that's possible shorter
11:12:42 <glguy> even with the \x
11:27:52 <pzpz> http://www.dailymail.co.uk/pages/live/articles/news/news.html?in_article_id=416761&in_page_id=1770
11:27:56 <lambdabot> Title: Jedi Knights demand Britain's fourth largest 'religion' receives recognition | t ..., http://tinyurl.com/y3nqc7
11:28:24 <Botje> rofl
11:31:27 <Ontolog> foldr (\x c -> if p x then c+1 else c) 0 l
11:31:43 <Ontolog> So c starts out as the second argument to foldr?
11:32:20 <Botje> yes
11:32:32 <Ontolog> what does foldr do again?
11:32:46 <pkhuong-> yes. You can think of foldr as inserting the first argument in place of (:) and the second in place of [].
11:33:21 <Ontolog> –ª–ª
11:33:44 <Ontolog> is there a way to address elements of a list?
11:33:51 <Botje> list !! index
11:33:59 <Botje> it's slow, though.
11:33:59 <Ontolog> i see
11:34:11 <Ontolog> slow as in particular slow compared to other languages?
11:34:33 <Botje> slow as in O(n) slow.
11:34:44 <Botje> unlike O(1) for arrays/vectors
11:34:46 <Ontolog> does anyone else think haskell is just the idealist creation of a bunch of mathematicians who aren't really interested in pragmatic programming?
11:34:59 <pkhuong-> no.
11:35:03 <Ontolog> aww
11:35:07 <dylan> Ontolog: Nope. haskell is the most practical language I know of
11:35:16 * Ontolog is still failing to see the light
11:35:30 <Ontolog> i guess ill have to actually write something in it
11:35:36 <dylan> I wanted monads in perl the other day
11:35:44 <dylan> specifically the Reader monad.
11:35:58 * Ontolog has yet to get to the part about monads
11:36:04 <Botje> Ontolog:
11:36:12 <Botje> try to solve some of these problems in haskell: http://acm.uva.es/problemset/
11:36:14 <lambdabot> Title: online-judge.uva.es - PROBLEM SET ARCHIVE
11:36:25 <Botje> i'm doing that now
11:37:14 <Ontolog> they don't accept haskell solutions!
11:37:42 <Botje> you don't have to send them in .. :)
11:37:55 <Botje> you could post them on the haskell wiki and become famous!
11:37:58 <Ontolog> maybe ill try after i finish this blasted tutorial
11:38:01 <Ontolog> lol
11:38:09 <ArtemGr> Ontolog: my first experience writing in Haskell wasn't satisfying, it took several attempts ...
11:38:11 <Ontolog> the only reason i'm learning haskell is to contribute towards pugs
11:38:26 <Botje> Ontolog: ah, I thought I recognized your nick :)
11:38:33 <pzpz> what an ugly page.
11:39:15 <Daveman> Botje :)
11:39:20 <Botje> hello there, Daveman  :P
11:39:29 <Daveman> Greetings, friend.
11:39:40 <chessguy> Daveman :)
11:39:43 <Daveman> I didn't know you were into hs
11:39:47 <Daveman> hey chessguy o/
11:40:01 <Botje> Daveman: i'm into lots of things :)
11:40:06 <Daveman> :p
11:40:12 <pzpz> you know what that means!
11:40:35 <Daveman> huhu
11:41:14 <metaperl> anyone with a few free cycles to help me through Lemmih's brainchild:
11:41:19 <dylan> pugs, darcs, and lambdabot: gateway drugs to haskell.
11:41:20 <metaperl> > let leftpad len str = reverse (take len (reverse str ++ repeat ' ')) in (leftpad 6 "Hi", leftpad 6 "Hello")
11:41:21 <lambdabot>  ("    Hi"," Hello")
11:41:59 <integral> metaperl: The first idea (the one on the outside) is to convert the problem from happening on the left to happening on the right
11:42:25 <metaperl> @type repeat
11:42:26 <integral> Then we pad all the way out to infinity, but then just trim back to how much we want
11:42:26 <Daveman> silly integral :)
11:42:26 <emu> > take 6 "iH           "
11:42:27 <lambdabot> forall a. a -> [a]
11:42:28 <lambdabot>  "iH    "
11:42:31 <integral> hello daveman
11:42:34 <emu> > reverse $ take 6 "iH           "
11:42:35 <lambdabot>  "    Hi"
11:42:43 <integral> err, s/on the outside/wrapped around it/
11:42:53 <metaperl> whoa, we have bad internet connect here
11:42:53 * Daveman envelopes integral
11:43:21 <integral> Daveman: ITYM "envelops"
11:44:25 <Daveman> negative
11:46:00 <metaperl> str ++ repeat ' '   -- gives us the string with an infinite number of spaces concatenated to it.. .no?
11:46:11 <emu> yup
11:46:12 <integral> metaperl: yeah
11:46:41 <glguy> > [' ',' '..]
11:46:42 <lambdabot>  "                                                                           ...
11:46:49 <Daveman> one meeeeeeeeeeeeelleon
11:47:02 <integral> > length $ repeat ' '
11:47:07 <lambdabot> Terminated
11:47:19 <Daveman> neeners
11:47:38 <glguy> > let length [' ',' '..] = 7 in length [' ',' '..] -- yeah yeah, I know
11:47:39 <lambdabot>  Parse error in pattern
11:47:42 <emu> > cycle " "
11:47:43 <lambdabot>  "                                                                           ...
11:47:46 <pzpz> > take 10 (repeat 'e')
11:47:47 <lambdabot>  "eeeeeeeeee"
11:47:52 <emu> > replicate 10 'e'
11:47:53 <lambdabot>  "eeeeeeeeee"
11:48:15 <glguy> [0..9] >> "e"
11:48:18 <glguy> > [0..9] >> "e"
11:48:19 <lambdabot>  "eeeeeeeeee"
11:48:31 <tibbe> >> ?
11:48:36 <tibbe> ?type >>
11:48:37 <lambdabot> parse error on input `>>'
11:48:39 <pkhuong-> tibbe: list monad :)
11:48:42 <emu> @type (>>)
11:48:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
11:48:46 <tibbe> concatMap right?
11:48:51 <emu> sorta
11:49:01 <emu> except it doesn't bind a parameter
11:49:04 <glguy> > map (const ' ') [0..9]
11:49:05 <lambdabot>  "          "
11:49:14 <jgrimes> > fix (' ':)
11:49:16 <lambdabot>  "                                                                           ...
11:49:23 <Ontolog> What's the difference between => and -> in a type definition?
11:49:34 <emu> lhs of => are type classes
11:49:41 <metaperl> I understand it now. That's a different approach to what I did. I used something like Lemmih's second soln: > let pushRight len str | length str >= len = str | otherwise = ' ':pushRight (len-1) str in (pushRight 6 "Hi", pushRight 6 "Hello")
11:49:47 <metaperl> > let pushRight len str | length str >= len = str | otherwise = ' ':pushRight (len-1) str in (pushRight 6 "Hi", pushRight 6 "Hello")
11:49:49 <lambdabot>  ("    Hi"," Hello")
11:49:59 <tibbe> Ontolog: type classes are kinda like requirements on the type variables
11:50:11 <Ontolog> thanks
11:50:28 <emu> (Num a) => a -> a -- a is polymorphic variable that satisfies "of class Num"
11:50:38 <emu> *type variable
11:51:03 <emu> @type (+)
11:51:04 <lambdabot> forall a. (Num a) => a -> a -> a
11:52:00 <tibbe> > [0,1,2] >>= "e"
11:52:01 <lambdabot>  Couldn't match `a -> [b]' against `[Char]'
11:52:06 <tibbe> > [0,1,2] >>= \_ -> "e"
11:52:13 <lambdabot>  "eee"
11:52:56 <tibbe> maps the function \_ -> "e" over the list [0,1,2] and then concats the result?
11:53:32 <tibbe> concatMap (\_ -> "e") [0,1,2]
11:53:38 <tibbe> > concatMap (\_ -> "e") [0,1,2]
11:53:39 <lambdabot>  "eee"
11:54:06 <Pete_I> what's the \_ mean?
11:54:08 <tibbe> could someone give a concrete example of when that might be useful?
11:54:21 <glguy> when >> is useful?
11:54:21 <tibbe> Pete_I: an argument that we don't care about
11:54:25 <Pete_I> ok
11:54:27 <tibbe> glguy: list monad
11:54:41 <glguy> list monad is for non-deterministic computation
11:54:46 <tibbe> Pete_I: \ is a lambda (if you didn't know that)
11:54:56 <glguy> so... any time you want to search a tree or do anythign else that branches
11:54:59 <glguy> it's useful
11:55:01 <tibbe> glguy: I know, hence _concrete_ example :)
11:55:06 <tibbe> ok
11:55:12 <glguy> sudoku solver on the wikipedia cale made
11:55:19 <tibbe> cool
11:55:40 <tibbe> > [0,1,2] >> guard (<3)
11:55:41 <lambdabot>    Expecting a function type, but found `Bool'
11:55:41 <lambdabot>    Expected type: Bool
11:55:41 <lambdabot>  ...
11:55:55 <glguy> > guard (False) >> "test"
11:55:57 <lambdabot>  ""
11:56:00 <glguy> > guard True >> "test"
11:56:01 <lambdabot>  "test"
11:56:16 <tibbe> > [0,1,2] >>= guard (<3)
11:56:17 <lambdabot>  Couldn't match `[b]' against `()'
11:56:21 <tibbe> hmm
11:56:26 <glguy> guard . (<3)
11:56:40 <tibbe> > [0,1,2] >>= \x -> guard (<3) >> return x
11:56:41 <lambdabot>    Expecting a function type, but found `Bool'
11:56:42 <lambdabot>    Expected type: Bool
11:56:42 <lambdabot>  ...
11:56:46 <tibbe> bah
11:57:01 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just .splitAt 2)) [0..9] -- one of my favorites
11:57:02 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8,9]]
11:57:41 <tibbe> how would guard be used to mimic list comprehension?
11:57:45 <glguy> > [0,1,2] >>= \x -> guard (even x) >> return x
11:57:47 <lambdabot>  [0,2]
11:57:55 <tibbe> say [x | x <- [0,1,2] , x < 3]
11:57:58 <pzpz> > replicate (-2) '5'
11:57:59 <lambdabot>  ""
11:58:01 <tibbe> ok
11:58:19 <tibbe> didn't I just write that??
11:58:20 <glguy> tibbe: do { x <- [0,1,2]; guard (x < 3); return x }
11:58:27 <glguy> or
11:58:38 <tibbe> ah, the x
11:58:39 <glguy> [0,1,2] >>= \x -> guard (x < 3) >> return x
11:58:52 <tibbe> mine was missing the x
11:59:04 <tibbe> I'm not 100% stupid then :)
11:59:08 <tibbe> just 99%
11:59:16 <metaperl> no, I am
11:59:22 <glguy> nah:
11:59:22 <metaperl> yes, I take the cake :)
11:59:41 <glguy> > recip $ genericLength "[0,1,2] >>= \x -> guard (<3) >> return x"
11:59:41 <lambdabot>  Illegal escape sequence
11:59:47 <glguy> > recip $ genericLength "[0,1,2] >>= \\x -> guard (<3) >> return x"
11:59:48 <lambdabot>  2.5e-2
11:59:59 <glguy> 2.5%
12:01:37 <Ontolog> So a data-type is the same as a class?
12:01:48 <glguy> nope
12:02:21 <Cale> Ontolog: what do you mean by class?
12:02:22 <Ontolog> is there a seperate "class" keyword for creating classes?
12:02:26 <Cale> Ontolog: yes
12:02:27 <tibbe> couldn't it said to be like a tagged union in C?
12:02:30 <Ontolog> ok
12:02:39 <astrolabe> You can think of a Class as a set of types
12:02:41 <Cale> tibbe: sort of
12:02:46 <tibbe> class in haskell is almost like an interface
12:02:47 <ArtemGr> Ontolog: about type classes i've recently found a nice paper: http://web.cecs.pdx.edu/~mpj/pubs/springschool.html
12:02:58 <Cale> I think of typeclasses as predicates on types
12:02:58 <lambdabot> Title: Functional Programming with Overloading and Higher-Order Polymorphism, http://tinyurl.com/yzsecv
12:03:01 <Ontolog> ArtemGr: thanks
12:03:18 <Cale> where if the predicate is true, then some functionality is provided
12:03:37 <Ontolog> hmm
12:03:44 <Ontolog> looks like i need to finish this tutorial :p
12:03:50 <tibbe> :)
12:04:16 <astrolabe> I remember it being confusing
12:04:32 <tibbe> I will never get arrows though
12:04:45 <Cale> tibbe: never say never :)
12:04:56 <tibbe> I never say never
12:05:05 <tibbe> ;)
12:05:16 <tibbe> although I might write it once in a while
12:05:29 <tibbe> so what's the step from monads to arrows?
12:05:39 <tibbe> what's the magic sauce?
12:06:11 <Cale> Well, the realisation that monads are really just one way to structure a combinator library
12:06:32 <tibbe> I read some paper with parser combinators and arrows I think
12:06:40 <Cale> I think in actual use, the special arrow syntax helps a lot
12:06:42 <Cale> yeah
12:06:52 <tibbe> and arrows where useful cause you got some additional static info, although I can't remember what it was
12:07:01 <tibbe> something with space efficiency
12:07:04 <astrolabe> Anyone here used Graphics.UI.Gtk.Layout.Table?
12:07:18 <Cale> the reason for wanting arrows is that it gives you more ability to rewrite things before they're used
12:07:30 <tibbe> xD
12:07:36 <tibbe> too abstract for me, sorry
12:07:54 <tibbe> I got monads when I was first shown the Maybe monad
12:08:00 <tibbe> I want the Maybe arrow :)
12:08:01 <pkhuong-> Cale: `rewrite' at compile-time or dynamically?
12:08:18 <Cale> dynamically
12:08:44 <shapr> tibbe: I just like that pointy syntax. That's what I find compelling about arrows.
12:08:44 <Cale> that's the problem with arrows, we don't really have easy examples of arrows which aren't already monads.
12:08:54 <shapr> Just <- Too -< Cool
12:09:55 <Cale> With a monad, your actions are built up using bind
12:10:18 <Cale> but the problem with bind is that one of its parameters is a function
12:10:22 <Cale> (necessarily)
12:10:28 <Cale> and functions are opaque
12:10:29 <pkhuong-> so a black box?
12:10:33 <Cale> you can't deconstruct them
12:10:39 <sjanssen> hmm, I wonder if Stream fusion could be modeled by arrows
12:11:07 <Cale> With an arrow, you use things like >>> which take an arrow value on both sides, which might be possible to inspect.
12:11:23 <Cale> and so you get more ability to optimise things
12:11:35 <shapr> but when you lift functions into arrows, no inspection allowed.
12:11:40 <Cale> right
12:11:52 <pkhuong-> Cale: so functions compose inspectable actions?
12:12:09 <Cale> but an arrow is completely boring if all its values are constructable via pure/arr
12:12:15 <shapr> So if you use only arrows, you get lots of cool properties.
12:12:17 <pkhuong-> oh,well. I'll just read.
12:12:18 <tibbe> hmm
12:13:05 <Cale> So you can define >>> and your eventual arrow-running action so as to apply some extra simplification in various cases.
12:13:31 <tibbe> but I guess that parser combinator library is a concrete exampel
12:13:46 <Cale> yeah
12:13:57 <tibbe> but the optimization is only possible with arrows right? since a part of the input need to be inspected at compile time
12:13:59 <Cale> and it uses algebraic properties of the parsers to be more efficient
12:14:15 <Cale> nothing special is happening at compile time
12:14:32 <Cale> well, not at Haskell compile time anyway :)
12:14:58 <tibbe> but the efficiency has something to do with lack of non-opaque functions?
12:15:00 <Cale> but if you think of your arrow as a domain-specific language, it's like arrows give you a bit of ability to do just-in-time compilation
12:15:47 <tibbe> ok
12:15:47 <pkhuong-> Cale: and then someone points out that staging is less complicated ;)
12:15:57 <ArtemGr> i'm using HXT with arrows, and i've found it less convenient that monads. with "arrow syntax", i don't see how can i apply two arrows and then use their result with third. (what is possible with ($<))
12:16:03 <tibbe> so something can be precomputed?
12:16:20 <tibbe> http://programming.reddit.com/goto?id=r761
12:16:22 <lambdabot> Title: Factor: a stack language: Most people who criticize Lisp don't understand it
12:16:32 <tibbe> how come lisp post always get a gazillion comments?
12:16:41 <tibbe> i so few people are actually using lisp?
12:16:55 <pkhuong-> tibbe: it's the huge bikeshed in the middle of the living room.
12:16:56 <pkhuong-> erh.
12:17:25 <Cale> lisp people are extremely vocal :)
12:17:34 <tibbe> :)
12:17:54 <tibbe> how, a lightning storm just broke out
12:19:34 <Cale> ArtemGr: hm?
12:19:52 <integral> hrm, I'm getting a bit annoyed with ghci atm:  I've setup ":m Module1 Module2 Module3" and I use :r to reload, but my set of modules keeps being reset after the :r,  am I doing something wrong?
12:21:25 * integral is also annoyed that splices aren't working in types
12:21:43 <glguy> Cale: did you read the one particularly well formatted (used headers) lisp critisism in that comments thread?
12:21:46 <ArtemGr> Cale: i can use result of arrow a in arrow b with ($<), but i don't see how can i do this with "arrow syntax", and without "arrow syntax" i can't, say, remember (bind to a name, like with "name <-" or ">>= \name ->") some string in the beginning of the XML processing to reuse it in the end of the XML processing
12:24:11 <tibbe> what wheater!
12:24:27 <Cale> proc x -> do { y <- f -< x; z <- g -< y; returnA -< z }
12:24:28 <Cale> ?
12:24:44 <Cale> something like that?
12:25:00 <Cale> glguy: which one?
12:25:59 <tibbe> what does y <- f <- x mean? run f with input x and bind the result to y?
12:26:15 <ArtemGr> Cale: no, there is an XML document in the arrow, and i want to parse different parts of it, so i can't just feed y to the second arrow, i need both x and y in g
12:26:19 <Cale> tibbe: yeah
12:26:33 <tibbe> what are the types?
12:26:49 <glguy> http://programming.reddit.com/info/r761/comments/cr963
12:26:52 <lambdabot> Title: Most people who criticize Lisp don&#39;t understand it (reddit.com), http://tinyurl.com/vwugr
12:27:03 <Cale> I would say x :: b, y :: c, f :: a b c
12:27:26 <tibbe> ?type (<-)
12:27:27 <lambdabot> parse error on input `<-'
12:27:28 <glguy> that one, I felt that that was the only really useful thing to come out of that thread
12:27:46 <Cale> tibbe: it's special syntax
12:27:50 <tibbe> right
12:27:52 <tibbe> I remember
12:27:58 <tibbe> desugared to >>>= ?
12:27:59 <pkhuong-> glguy: agreed.
12:28:05 <Cale> ArtemGr: pass g a pair?
12:28:17 <Cale> z <- g -< (x,y) ?
12:29:04 <tibbe> ?type (>>>=)
12:29:05 <lambdabot> Not in scope: `>>>='
12:29:13 <tibbe> ?hoogle Arrow
12:29:14 <lambdabot> Control.Arrow :: module
12:29:14 <lambdabot> Control.Arrow.Arrow :: class Arrow a
12:29:14 <lambdabot> Control.Arrow.ArrowMonad :: a () b -> ArrowMonad a b
12:32:02 <ArtemGr> Cale: in g i need to use the usual HXT functions, so i would need to start g with something like \(x,y) -> arr x again... and then again i don't know how can i use y in that arrow x, becouse the y is an arrow by itself. it's just too compilcated for me due to lack of experience with type system
12:32:36 <Cale> ArtemGr: it is? You have arrows which return other arrows?
12:33:20 <Cale> you'd start it with proc (x,y) -> do ..., I think
12:33:41 <Cale> not that I've spent a lot of time working with the arrow syntax
12:33:51 * SamB_XP would like to see some code for translating ADTs to squiggol
12:35:51 <pzpz> how can i limit a lazy generator in list comprehension?
12:36:03 <SamB_XP> limit?
12:36:06 <Heffalump> take n
12:36:12 <ArtemGr> Cale: currently i have:
12:36:12 <ArtemGr>     readDocument [(a_validate, v_0)] "translated.xml"
12:36:12 <ArtemGr>     >>> getChildren >>> hasName "photos" >>> (
12:36:12 <ArtemGr>       (translatePhoto $< (getChildren >>> hasName "action" >>> getAttrValue "id"))
12:36:12 <ArtemGr> i'll try now to convert it to arrow syntax with the proposed "proc (x,y) -> do"
12:36:29 <pzpz> oh, duh.
12:36:45 <Cale> let me figure out what this $< thing is
12:37:04 <SamB_XP> isn't it the leftmost dependency?
12:37:09 * SamB_XP makes stupid make joke
12:37:26 <glguy> $< reminds me of stuf in Control.Applicative
12:37:58 <ArtemGr> Cale: ($<) :: (c -> a b d) -> a b c -> a b d
12:38:30 <glguy> oh, that's <$
12:38:55 <glguy> (<$) :: (Functor f) => a -> f b -> f a -- is what I was thinking of
12:39:38 <SamB_XP> is that like fmap . const?
12:39:43 <SamB_XP> @type fmap . const
12:39:45 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => a1 -> f a -> f a1
12:39:49 <glguy> (fmap .) .const?
12:39:56 <glguy> ah
12:40:01 <glguy> yeah, what you said I suppose
12:40:23 <glguy> ?type (fmap .) . const
12:40:24 <lambdabot> forall (f :: * -> *) a b a1. (Functor f) => (a -> b) -> a1 -> f a -> f b
12:40:57 <Cale> so  f $< u = proc b -> do { x <- u -< b; y <- f x -< b; returnA -< y }
12:41:34 <Cale> I think
12:41:41 <ArtemGr> yeah, but "y <- f x -< b" isn't allowed
12:41:46 <Cale> no?
12:41:59 <ArtemGr> no  : (
12:42:02 <Cale> try
12:42:09 <Cale> y <- (f x) -< b
12:42:09 <ArtemGr> wait a minute
12:42:17 <glguy> What Arrow are you using?
12:42:18 * SamB_XP wishes people wouldn't intentionally misuse the crosshair cursor shape in CSS stylesheets...
12:42:21 <Cale> though I wouldn't think that should matter
12:44:30 <Cale> hmm, odd
12:46:28 <Cale> that really should be allowed, I think, but perhaps the syntax isn't versatile enough to allow it
12:46:37 <metaperl> what's wrong iwth .. here: rotate90 p  = [ i | i <- 0 .. (len-1) ]
12:46:57 <Cale> i <- [0 .. (len - 1)]
12:47:09 <Heffalump> except the whole comprehension is redudant
12:47:30 <Cale> yeah, if you're not going to map or filter :)
12:47:41 <Cale> or use p :)
12:47:51 <ArtemGr> currently
12:47:51 <ArtemGr>     >>> getChildren >>> hasName "photos" >>> proc photos -> do
12:47:51 <ArtemGr>       _id <- (getChildren >>> hasName "action" >>> getAttrValue "id") -< photos
12:47:51 <ArtemGr>       (translatePhoto _id) -< photos
12:47:52 <ArtemGr> gives:
12:47:54 <ArtemGr> src/translator.hs:54:6:
12:47:56 <ArtemGr>     The last statement in a 'do' construct must be an expression
12:48:12 <ArtemGr> sorry
12:48:19 <rahikkala> lisppaste2: url
12:48:19 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:49:26 <metaperl> ok, thanks... i'm just building up a solution piece by piece. Wait til you see the finished masterpiece
12:50:07 <lisppaste2> ArtemGr pasted "err" at http://paste.lisp.org/display/30107
12:50:24 <ArtemGr> here (pasted)
12:52:04 <lisppaste2> ArtemGr annotated #30107 with "original code" at http://paste.lisp.org/display/30107#1
12:53:12 <lisppaste2> ArtemGr annotated #30107 with "version without returnA" at http://paste.lisp.org/display/30107#2
12:54:23 <Cale> ArtemGr: yeah, I'm getting that "not in scope" error as well. It's bizarre that the arrow components seem to need to be in scope outside the do.
12:54:49 <Cale> perhaps it's because in general, there's not really an ordering on the computations inside that do.
12:55:00 <ArtemGr> it's ok if you consider the transformation: http://haskell.org/arrows/syntax.html
12:55:01 <lambdabot> Title: Arrow syntax
12:55:14 <ArtemGr> addA f g = arr (\ x -> (x, x) >>>
12:55:14 <ArtemGr>                first f >>> arr (\ (y, x) -> (x, y)) >>>
12:55:14 <ArtemGr>                first g >>> arr (\ (z, y) -> y + z))
12:55:33 <Igloo> CosmicRay: If you don't think it's just a timeout-too-low then let me know
12:55:35 <ArtemGr> (or at least i think it's ok)
12:56:47 <CosmicRay> Igloo: I think indeed that's what's going on (if you are referring to washngo)
12:57:20 <CosmicRay> Igloo: dan told me it's a dual 500MHz PPC machine with, iirc, 384MB RAM.  it is entirely possible that it is a slow CPU and swapping heavily
12:57:31 <Igloo> CosmicRay: I think so; whichever bug you asked me about
12:57:42 <Cale> aha!
12:57:53 <Cale> so  f $< u = proc b -> do { x <- u -< b; y <- f x -<< b; returnA -< y }
12:58:15 * Itkovian bows
12:58:17 <Itkovian> a good evening
12:58:30 <Cale> Prelude Control.Arrow> let f $< u = proc b -> do { x <- u -< b; y <- f x -<< b; returnA -< y }
12:58:30 <Cale> Prelude Control.Arrow> :t ($<)
12:58:30 <Cale> ($<) :: (ArrowApply t2) => (t1 -> t2 t b) -> t2 t t1 -> t2 t b
12:58:32 <CosmicRay> Igloo: I was asking you about the missingpy one, which I reassigned to ghc6
12:58:46 <ArtemGr> yeah, with -<< it works!
12:58:50 <CosmicRay> Igloo: I believe Cabal is erroneously inserting the includes path into the generated installed-pkg-config file
12:58:56 <Cale> yeah, that's actually what -<< is for
12:59:16 <Cale> referring to the results of previous arrow computations on the left of it
12:59:49 <arjanoosting> CosmicRay: you were looking for me?
13:00:02 <CosmicRay> arjanoosting: yes.  were you planning to take over haskell-devscripts?
13:00:03 <ArtemGr> Cale: honestly, i haven't seen "-<<" docummented anywere.  : (
13:00:17 <CosmicRay> Igloo: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=395104
13:00:19 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
13:00:20 <lambdabot> Title: #395104 - libghc6-missingpy-dev: Fails to configure due to missing directory - D ..., http://tinyurl.com/y8d5kp
13:00:22 <lambdabot> Title: 7.7. Arrow notation, http://tinyurl.com/tts6c
13:00:34 <ArtemGr> Cale: thanks!
13:00:49 <Igloo> CosmicRay: Err, OK, I think you pasted the wrong bug number then  :-)
13:01:00 <CosmicRay> Igloo: quite possible
13:01:11 <ArtemGr> Cale:  : )
13:01:17 <arjanoosting> CosmicRay: I am intending too. I haven't had the time to make more changes apart for fixing a bug
13:01:25 <Igloo> CosmicRay: Can you give me missingpy as a plain old cabal package please?
13:01:58 <CosmicRay> Igloo: just run "python gencabal.py" and you'll have it.
13:02:13 <CosmicRay> from then on you can ignore gencabal
13:02:19 <CosmicRay> (unless you run debian/rules clean)
13:02:32 <CosmicRay> arjanoosting: ok, I was just wondering what I ought to do with the patches from you for it
13:03:07 <CosmicRay> do you want me to build 0.5.14 or will you?
13:03:32 <Igloo> CosmicRay: is 0.8.9 broken in the same way?
13:03:45 <arjanoosting> CosmicRay: if you could apply them to your darcs archive. I have already uploaded 0.5.14
13:04:04 <CosmicRay> Igloo: yes, this was tested against 0.8.9
13:04:10 <CosmicRay> arjanoosting: got it.
13:04:43 <CosmicRay> arjanoosting: done, and thanks.
13:05:15 <arjanoosting> CosmicRay: well I introduced the bug, so I should fix it :-D
13:05:44 <CosmicRay> arjanoosting: too bad the people that wrote git support for darcs-load-dirs didn't feel the same way, grrr.
13:06:22 <arjanoosting> don't know anything about git, so I can not help you there
13:06:54 <CosmicRay> arjanoosting: I'm not asking you to.
13:07:03 <CosmicRay> arjanoosting: I was saying thanks, in an odd way
13:07:27 <arjanoosting> CosmicRay: I know, I should have included a smiley
13:09:57 * Igloo realises he's going across ADSL the wrong way to a slower machine to build this
13:10:16 <philipp_> is it possible to call haskell funktions from c? I have to implement some algorithms and want to use C for the main program (system dependent parts, IO etc.) and haskell only for implementing the algorithms, I read about C->Haskell but it seems to be the other way round
13:10:21 <arjanoosting> Igloo: did you look at the FTBFS of haskell98-report yet?
13:10:48 <Igloo> arjanoosting: Not yet, sorry  :-(
13:11:26 <Cale> philipp_: the FFI allows for that, though you do have to make some provisions for starting up the Haskell runtime.
13:11:34 <Heffalump> Igloo: across two ADSLs presumably
13:11:47 <Igloo> Only one the wrong way
13:11:49 <philipp_> Cale: thx, I'll google for that
13:11:49 <arjanoosting> Igloo, CosmicRay: any ideas on how to fix http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=397622 ?
13:11:53 <lambdabot> Title: #397622 - pugs - FTBFS: pugs: internal error: adjustor creation not supported on ..., http://tinyurl.com/y8e2no
13:11:59 <Heffalump> this one is a bit laggy the right way cos we got the cheap option
13:12:03 <Cale> philipp_: Yeah, the Haskell FFI spec is quite readable
13:12:10 <philipp_> k
13:12:16 <Cale> @where ffi
13:12:16 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
13:12:23 <philipp_> ah nice
13:12:56 <Igloo> arjanoosting: It needs some arch-specific stuff in GHC
13:13:11 <Igloo> arjanoosting: Or libffi might fix it globally
13:13:43 <arjanoosting> libffi?
13:14:20 <Igloo> CosmicRay: Where should glue.h come from?
13:14:46 <Igloo> CosmicRay: Never mind, I was looking in the wrong directory
13:15:15 <Igloo> arjanoosting: A library (part of gcj IIRC) to do FFI stuff for any platform
13:16:55 <arjanoosting> OK. So is this a bug in GHC or should pugs not be build on s390 for now?
13:17:07 <Ontolog> http://pastebin.com/826915
13:17:13 <Igloo> arjanoosting: Did it work in the past?
13:17:17 <Ontolog> I'm not understanding how to write the explicit type declarations
13:17:39 <Igloo> arjanoosting: I'm pretty sure it's not a regression in GHC, but it is a bug
13:17:41 <arjanoosting> Igloo: yes
13:17:57 <arjanoosting> But that was a earlier version of pugs
13:18:40 <Igloo> CosmicRay: OK, your package builds fine with my Debianisation (except you aren't telling Cabal that the .h files should be in the source dist)
13:19:24 <Igloo> CosmicRay: I'm not going to unravel what your packaging does in the short term, but I'm pretty sure the bug is yours
13:20:14 <arjanoosting> Igloo: does the libghc6-missingpy-dev you have build install properly?
13:20:19 <Igloo> arjanoosting: Yes
13:21:03 <arjanoosting> Does it include an empty include dir?
13:21:32 <Igloo> It includes /usr/lib/MissingPy-0.8.6/ghc-6.6/include , yes
13:22:47 <arjanoosting> Igloo: then it works indeed. But why does Cabal insists on creating an empty directory and include it in the installed-pkg-config file?
13:23:16 <Igloo> arjanoosting: To avoid having special code for the empty set of includes, presumably
13:25:22 <arjanoosting> Igloo: hmm probably.
13:27:00 <arjanoosting> So the .deb should either include the empty dir or remove the reference to the included dir from the installed-pkg-config file.
13:30:47 <arjanoosting> Igloo: any idea on when "adjustor creation" will be support on all arches?
13:35:46 <moconnor> What is the history of continuations?  What was the first language to have them as a first class entity, and when?  The earliest I can find reference to is Lisp, sometime in the 50s.  Is that about right?
13:37:03 <ibid> i'd be surprised it's that old
13:38:19 <blakkino> 58..
13:38:40 <ibid> lisp yes, but continuations
13:38:43 <Philippa_> the first lisp didn't have continuations
13:39:09 <Igloo> arjanoosting: Not for etch, certainly
13:39:12 <Philippa_> IIRC the last time I read a history the main inventions (they were reinvented a couple of times) were mid-60s onwards
13:39:35 <arjanoosting> Igloo: was not expecting that :-)
13:39:36 <Igloo> arjanoosting: If libffi can do it then 6.6.1 isn't impossible, if I find time to do it, and 6.8 certainly ought to be able to have it
13:39:40 <ibid> i'd say whoever used spaghetti stacks first probably had continuations too
13:40:04 <Igloo> arjanoosting: And the Debian packaging shouldn't need to know anything about the directory, it should just be getting cabal to do all the work
13:40:26 <rahikkala> moconnor: According to Wikipedia it was some Steve Russell guy who invented them, you should ask him ;)
13:42:01 <Igloo> arjanoosting: If it's outside the scope of libffi then I can't begin to make guesses, though
13:52:21 <vincenz> > foldr (+) 1 [1..1000]
13:52:22 <lambdabot>  500501
13:52:28 <vincenz> > foldr (+) 1 [1..10000]
13:52:29 <lambdabot>  50005001
13:52:31 <vincenz> > foldr (+) 1 [1..1000000]
13:52:33 <lambdabot>  Exception: stack overflow
13:52:52 <Binkley> > foldr (+) 1 [1..]
13:52:54 <lambdabot>  Exception: stack overflow
13:52:57 <Binkley> darn.
13:53:14 <vincenz> > foldl (+) 1 [1..1000000]
13:53:16 <Cale> > foldl' (+) 1 [1..1000000]
13:53:17 <lambdabot>  Exception: stack overflow
13:53:18 <lambdabot>  500000500001
13:53:24 <vincenz> skew you
13:53:29 <vincenz> or rate
13:53:31 <vincenz> or rather
13:53:35 <vincenz> skwew yew
13:53:52 <profmakx> prost vincenz
13:55:29 <vincenz> prost?
13:55:55 <emu> how do I work with src that's placed into hierarchical modules, in ghci?
13:56:11 <emu> ghci seems to have trouble locating other modules in the tree
13:58:14 <profmakx> vincenz, german for "cheers"
13:58:18 <emu> say I had: src/Foo/Bar.hs with module Foo.Bar, and src/Foo/Main.hs which imports Foo.Bar
13:58:23 <vincenz> profmakx: thx :)
13:58:36 <emu> if I try to :load Main.hs it tells me it can't find Foo.Bar
13:59:48 <sjanssen> emu; launch ghci with -isrc
14:00:54 <Ontolog> What's up with the "Maybe" datatype
14:00:57 <Ontolog> I think it's bullocks
14:01:00 <sjanssen> ghci will also search the current directory by default, so you can just cd src if you want
14:01:04 <sjanssen> Ontolog: it's awesome!
14:01:04 <Binkley> Ontolog: how so?
14:01:07 <Ontolog> Why can't you just return null?
14:01:20 <sjanssen> Ontolog: it enforces checking
14:01:34 <Binkley> null means many things. Nothing means one thing.
14:01:39 <Binkley> Well, technically it means nothing.
14:01:44 <Ontolog> In Java you can return (a == b) ? object : null;
14:02:03 <sjanssen> also, there isn't really "null" in Haskell.  There's "error", and you aren't supposed to check those
14:02:07 <emu> Ontolog: so, when you look something up in a hash-table, is the result "missing" or is it "there" but null
14:02:19 <sjanssen> Ontolog: right, and how many NullPtrExceptions have you gotten in your life ;)
14:02:21 <emu> Ontolog: Java is quite possibly the worst example to bring up
14:02:22 <Ontolog> if it's not there you return null
14:02:30 <emu> Ontolog: what if it is there, and the value IS null
14:02:54 <Ontolog> good point
14:03:02 <Ontolog> then you throw an exception!
14:03:03 <Ontolog> and catch it
14:03:04 <Binkley> Ontolog: besides everything else, using the Maybe type rather than returning null (ignoring the fact that Haskell doesn't have a concept of a null pointer) lets you distinguish program bugs from legitimate error cases
14:03:04 <emu> Common Lisp deals with this by returning 2 values
14:03:18 <emu> Haskell deals with this by defining a data type which is orthogonal
14:03:22 <Binkley> Ontolog: Haskell does have exceptions, but returning something of type Maybe is just a simpler way to throw an exception
14:03:25 <Binkley> and it's statically checked
14:03:36 <sjanssen> Ontolog: throwing exceptions in pure code can break referential transparency
14:03:39 <ArtemGr> Ontolog: http://nice.sourceforge.net/safety.html#id2448199
14:03:42 <lambdabot> Title: Type safety in Nice, http://tinyurl.com/y69wz6
14:03:47 <Binkley> if you use the Maybe type correctly to represent errors, you can't have an uncaught exception
14:04:03 <pzpz> Maybe!
14:04:12 <emu> Maybe isn't the way to do that really
14:04:14 <Ontolog> ahh ok i guess Maybe I need a little more time with this new paradigm
14:04:28 <sjanssen> > Just "yes, I think you do"
14:04:29 <lambdabot>  Just "yes, I think you do"
14:04:37 <Ontolog> ok about Just
14:04:41 <Binkley> brother, can you paradigm?
14:04:44 <emu> I'd say it's more useful for characterizing the situation where "no value" is meaningful
14:04:47 <Ontolog> Why use Just x and not just x by itself?
14:05:01 <sjanssen> Ontolog: because x isn't a Maybe
14:05:04 <emu> Ontolog: data Maybe a = Just a | Nothing
14:05:19 <sjanssen> Just is the function that lifts it into the world of possibly failing computations
14:05:20 <Ontolog> but why isn't Maybe defined as : data Maybe a = Nothing | a
14:05:26 <emu> not valid
14:05:31 <emu> you need to construct it
14:05:47 <Ontolog> k
14:05:52 <emu> how about: data MyType a = a | Blah?
14:06:03 * araujo loves Haskell
14:06:08 <Ontolog> wouldn't that be the same problem?
14:06:11 <araujo> Haskell i the most beautiful language out there.
14:06:16 <emu> yep, quite a conflict
14:06:41 <Ontolog> Haskell... more like hassle!
14:06:46 <Ontolog> ;)
14:06:49 <Ontolog> ok back to tutorial
14:09:15 * araujo sings ... "You are soooo .. beautiful ...."
14:09:32 * profmakx sings "I am soooo drunk"
14:09:54 <Binkley> let's develop a special IDE for programming while drunk
14:10:20 <profmakx> with blackjack
14:10:22 <profmakx> and hookers
14:10:30 <Binkley> everything should have blackjack and hookers.
14:10:33 <Binkley> especially ICFP.
14:10:37 <araujo> Binkley, been writting a small editor here lately
14:12:36 <araujo> Far from bein an idea, but i at least can replace gedit now :-P
14:12:48 <Ontolog> Why does this not work? data Tuple a b c d = Tuple a | Tuple a b | Tuple a b c | Tuple a b c d
14:12:58 <Ontolog> I want to define the type Tuple with 4 different constructors
14:13:04 <Ontolog> one that takes 1 value, another that takes 2, etc
14:13:14 <pzpz> ls
14:13:16 <Binkley> Ontolog: then name the constructors with four different names
14:13:16 <Excedrin> then they need to be named differently
14:13:18 <pzpz> err, i hate doing that.
14:13:26 <Binkley> the type constructor, on the LHS, is different from the data constructor(s), on the RHS
14:13:27 <araujo> Because son ... you are using the same name for different data constructors
14:13:30 <pejo> Binkley, isn't that what Programmatica is doing?
14:13:38 <Binkley> though when there's only one constructor, you can get away with using the same name
14:13:43 <pejo> (The IDE, haven't seen any blurbs about not using it while drunk).
14:13:46 <Ontolog> ok
14:13:53 <Binkley> pejo: well, I'll be sure to get drunk and try it, then
14:14:02 * araujo continues singing ... "You are soooo .. beautiful ...."
14:14:24 <Ontolog> araujo: if you like Haskell so much why don't you marry it?!
14:14:30 * araujo looks at the sky and sings ... "You are soooo .. beautiful ...."
14:14:52 <araujo> Ontolog, I am .... internally .... i am
14:15:18 <Binkley> araujo: I hear that's legal in Massachusetts now.
14:15:26 <Ontolog> hey that's my state!
14:15:36 <araujo> muahaha
14:15:40 <Binkley> I used to live there.
14:15:57 <Ontolog> did you move out because gay marriage is legal here?
14:16:15 <Binkley> Ontolog: no, that would have been a reason *not* to move
14:16:19 <profmakx> 0o.o
14:16:25 <Ontolog> lol
14:16:30 * Ontolog is indifferent on the matter
14:16:35 <araujo> bah, i thought it was programming language marriage
14:16:46 <Binkley> well, it's all lambdas either way.
14:16:49 * Ontolog wants to marry his PS3
14:16:58 <araujo> :-P
14:17:00 <Ontolog> that he doesn't have because the store SOLD OUT!
14:17:04 <Ontolog> :`(
14:17:17 <Ontolog> anyone have a PS3?
14:17:24 <Binkley> I have a PS/1
14:17:29 * araujo wants a Wii!
14:17:30 <Ontolog> eww
14:17:33 <Ontolog> eww
14:17:38 * Ontolog is a Sony loyalist
14:17:47 <Ontolog> I had a PS1 and then a PS2 for a short time but then sold it
14:17:56 <Excedrin> did you read/hear about the people who were mugged while waiting in line to buy a PS3?
14:17:57 <Ontolog> however now I want a PS3 I think it will dominate all your faces
14:17:59 <Binkley> but really, I miss the days of Zork
14:18:18 <Ontolog> I'm sure people got jacked this morning trying to get 'em
14:18:19 * araujo was a sega loyalist .... until the thing just broke
14:18:26 <Ontolog> hehe sega
14:18:27 <merus> Sony has done such stupid things lately.
14:18:41 * olliej is a mac loyalist
14:18:42 <Excedrin> http://news.yahoo.com/s/ap/20061117/ap_on_re_us/playstation_shooting
14:18:45 <lambdabot> Title: 1 shot in Conn. amid PlayStation mayhem - Yahoo! News, http://tinyurl.com/yko85e
14:18:50 * olliej also doesn't play games
14:18:54 <olliej> coincidence? :D
14:19:06 <Ontolog> i used to rock ut2004 on my mac
14:19:23 <Excedrin> I think you meant xbill
14:19:30 * olliej sucks at all games outside of myst :D
14:19:47 <olliej> assuming for now myst fits under a really broad definition of game :D
14:19:59 <Botje> olliej: the world needs myst speedruns!
14:20:06 <olliej> Botje: heheh
14:20:33 <olliej> Botje: but i haven't worked out how to rocket jump in myst yet :D
14:20:49 <olliej> Botje: you seen the quake done quick spped runs?
14:20:55 <Botje> olliej: yup.
14:21:04 <Botje> i've been collecting speedruns of games I like :)
14:21:09 <olliej> hehe
14:21:23 <Botje> speeddemosarchive.com++ #just because
14:21:54 * olliej listens to builders thumping other side of his office wall
14:22:20 * olliej is sure they aren't meant to start until night time
14:22:26 <vincenz> olliej botje ... now just add "lle
14:22:30 <vincenz> olliej bolletje
14:22:41 <Botje> =)
14:22:47 <olliej> hah
14:22:48 <olliej> :D
14:23:27 <Ontolog> so after the initial release, how long do we have to wait for more to arrive?
14:23:41 <vincenz> more oliebollen?
14:23:44 <Ontolog> more PS3
14:23:45 * vincenz hmms
14:24:08 <Botje> too damn long.
14:24:12 * olliej gets back to work
14:24:20 <Botje> but that's okay because sony is a moneyhungry whore anyway
14:24:30 <vincenz> Long enough for people to sleep in the streets for 4 weeks
14:24:40 <Ontolog> lol
14:24:42 <Ontolog> so a month?
14:24:47 <vincenz> no
14:24:48 <Ontolog> those pluckers
14:24:56 <vincenz> people won't be desperate in a month to wait for a month
14:24:57 * pzpz computer > ps{n}
14:25:14 <Botje> ANY computer > ps\d
14:25:24 <Ontolog> bullocks
14:25:25 <Maddas> Yeah, playstations are quite small compared to computers.
14:25:30 <Maddas> It's quite convenient.
14:25:31 <Botje> :)
14:25:32 <Ontolog> ps3 is diferent
14:25:41 <Ontolog> it's super celled up
14:25:42 <vincenz> yeah
14:25:47 <vincenz> it's so diffident
14:25:47 <Ontolog> big juicy tech in there
14:25:56 <vincenz> Ontolog: so?
14:25:59 <vincenz> Ontolog: you can't use it
14:26:02 <Ontolog> so it is a full computer
14:26:06 <Ontolog> you can throw linux on it
14:26:06 <vincenz> HAH
14:26:07 <vincenz> bullshit
14:26:11 <vincenz> you don't have a cell compiler
14:26:12 <pzpz> honestly. the computing power available for a computer surpasses any console, and the price argument is retarded since a computer is far more usable than any console.
14:26:12 <Ontolog> why is that bullshit?
14:26:23 <vincenz> how the fuck will you compile for a multicore like that
14:26:26 <Ontolog> cell is different
14:26:33 <vincenz> not to mention you need apps that are multithreadable
14:26:34 <Ontolog> yellowdog linux already has a distro son
14:26:41 <vincenz> thank you dad
14:26:47 <Binkley> @karma+ vincenz
14:26:47 <lambdabot> vincenz's karma raised to 15.
14:27:24 <Ontolog> http://www.terrasoftsolutions.com/products/ydl/
14:27:29 <Excedrin> gcc compiles to cell
14:27:29 <lambdabot> Title: Terra Soft: PowerPC Linux for Desktop, Workstation, Server, and HPC Clusters., http://tinyurl.com/86sd7
14:27:37 <vincenz> Excedrin: efficiently?
14:27:40 <Maddas> pzpz: People buy consoles to play games, not for raw computing power. And consoles seem to be quite good at letting people play games :-)
14:27:44 <vincenz> in a manner that actually uses multiple cores?
14:27:46 <vincenz> or just to one core
14:27:49 <vincenz> giving you a slow pc
14:27:58 * vincenz tsks
14:28:00 <Ontolog> multi-core son!
14:28:00 <ArtemGr> amygdala spike neural networks library (it's C++) is working on porting to cell processors, for example
14:28:01 <Excedrin> 4Ghz 64bit powerpc
14:28:05 <pzpz> Maddas: name one amazing game that's better without a mouse/keyboard
14:28:09 <vincenz> Ontolog: bs
14:28:13 <Maddas> pzpz: Tekken
14:28:21 <vincenz> but then again
14:28:23 <vincenz> what do I know
14:28:29 <Ontolog> nothing son your just a son!
14:28:35 <Ontolog> MY son
14:28:43 <vincenz> I only do research at an institute that does ampping to heterogeneous mpsocs
14:28:56 <Cale> pzpz: haha, Duck Hunt
14:29:02 <pzpz> Maddas: oh, i forgot about fighters:( ... Would you prefer tekken on a fast internet connection on your computer? or in your livingroom?
14:29:14 <Excedrin> pzpz: Red Steel
14:29:19 <Maddas> pzpz: My living room. I have tekken on my computer, it does not run very well.
14:29:46 <pzpz> my argument held better several years ago, before consoles began becoming more "computerized"
14:29:54 * vincenz would love to see the day that a compiler maps to multiple processors with a click of the button
14:30:49 <Maddas> pzpz: The price argument is not retarded at all either. Just like a buying a bicycle because it's cheap isn't stupid because motorbikes are more usable -- a console is usually bought as a device with a fairly clear purpose.
14:31:23 <vincenz> Cale: you mean with a gun
14:31:30 <whyso> challenge: 1 liver quine in haskell
14:31:37 <whyso> liner*
14:31:44 <vincenz> ooh
14:31:45 <vincenz> liver quine
14:31:50 <Maddas> pzpz: My laptop is outdated by newer models far more often than consoles are, too, and the price difference there is quite significant ;-)
14:31:59 <vincenz> can I get that with some red monads?
14:32:29 <pzpz> Maddas: i think i'm just a little ignorant. I don't see any point in playing a game if it isn't starcraft or counterstrike :)
14:33:30 <Maddas> pzpz: I'm probably just a little frustrated because I can't play HL or the new AoE on my mac laptop, I know the feeling :-)  (I do not own any consoles)
14:33:35 <vincenz> pzpz: spank the monkey?
14:33:37 <Maddas> erm, s/HL/TFC/
14:33:57 <pzpz> the new tfc for hl2?
14:34:11 <Excedrin> pzpz: you should try playing katamari damacy (perhaps at a friend's house or something)
14:34:29 <pzpz> Excedrin: is that the game where you roll over objects and absorb them?
14:34:34 <pzpz> Excedrin: and the rainbows?
14:34:34 <rahikkala> Or you could learn to be a real man / a truly womanly woman by getting addicted to adom
14:34:36 <Maddas> pzpz: er, even remembering that hl2 *exists* hurts. I never got to play it yet :-)
14:34:36 <Excedrin> yea
14:34:45 <pzpz> Maddas: it's amazing :)
14:34:52 <Maddas> Yeah, I didn't miss that part.
14:35:03 <pzpz> Excedrin: doesn't seem very competitive. Then again, all I know is you roll over stuff.
14:35:10 <pzpz> Excedrin: read the xkcd comic on it?
14:35:16 <Maddas> pzpz: In any case, the motion-sensitive controllers of the Wii (and PS3) should make for quite interesting applications :)
14:35:27 <Excedrin> it's fun, not competitive
14:35:51 <pzpz> Excedrin: I need competitive games. If i'm not angry at people, i'm not happy.
14:35:55 <Maddas> Excedrin: That's not a positive thing if you're talking to someone who plays Starcraft and CS :-P
14:35:57 <Excedrin> there is a two player mode, but it's basically pointless, you can compete for better times/larger size though
14:36:25 <shapr> I like friendly competition.
14:36:34 * vincenz boings at shapr 
14:36:39 <vincenz> take that!
14:36:46 <pzpz> Excedrin: http://xkcd.com/c83.html
14:36:47 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
14:37:11 <Excedrin> I used to play SC (and other RTSes), and CS (and RA3 and other FPS) and I'm basically tired of games in general
14:38:12 <pzpz> Excedrin: The competitive aspect of online games is what makes them addictive :)
14:38:21 <pzpz> Excedrin: you're not playing the game, you're playing to beat other people.
14:38:33 <Ontolog> I can't believe I'm waiting so long for UT 2007
14:38:39 <Ontolog> I want to pwn the world in that game
14:38:45 <pzpz> Excedrin: the game just makes hte process enjoyable.
14:38:52 <Excedrin> yea, I've gone thru that, it gets boring after a while
14:39:06 <Ontolog> Everything does
14:39:07 <pzpz> Different strokes for different folks :)
14:39:14 <Ontolog> I like the back-stroke
14:39:27 <pzpz> Ontolog: not true. I'll never tire of candy.
14:39:47 <pzpz> Given enough candy, i'll die untired of diabetic stroke.
14:39:51 <Ontolog> I get bored of everything... I'm like A.D.D. if it's not new and exciting I'm not interested
14:40:01 <pzpz> Ontolog: haskell is for you then :)
14:40:16 <vincenz> Ontolog: welcome to haskellitis
14:40:19 <pzpz> objc, ruby, python... i was a language whore.
14:40:23 <whyso> (\x -> putStr (x ++ show x))"(\\x -> putStr (x ++ show x))"
14:40:24 <pzpz> then i ran into haskell
14:40:52 <vincenz> pzpz: now you're just a ...
14:41:04 <vincenz> whyso: that's missing a main
14:41:12 * pzpz \ldots
14:41:22 <vincenz> \latex
14:42:14 <whyso> sorry im new to haskell :(
14:42:31 <Cale> Actually it's a perfectly good expression quine
14:42:44 <Maddas> whyso: hey, that's just a transliteration of Riastradh's one, isn't it :-P
14:42:55 <whyso> hehe
14:43:01 <whyso> *red handed*
14:43:06 <Cale> I don't think it's hard to extend that to a full program
14:43:08 * araujo continues singing ... "You are soooo .. beautiful ...."
14:43:20 <glguy> first thing that came to mind when I saw x ++ show x was : showString x (show x)
14:43:43 <glguy> I know that it doesn't add anything at all
14:43:49 <glguy> just thinking out-loud :)
14:44:01 <pzpz> i love my os teacher. so oblivious....   http://.../lastAss.html
14:44:10 <pzpz> and, .../ass.html
14:44:10 <glguy> (which then lead to : ap showString show
14:44:45 <ibid> pzpz: they could be just poking you :)
14:44:51 <profmakx> and blackhack
14:44:55 <profmakx> AND hookers!
14:45:17 <Ontolog> http://pastebin.com/826988
14:45:33 <Ontolog> I want the function tuple1 to return the first value of the Tuple
14:45:36 <glguy> (putStr . ap showString show)"(putStr . ap showString show)"
14:45:38 <Ontolog> but I get an error loading this code
14:46:03 <Cale> Ontolog: a won't be of type Maybe a
14:46:13 <Cale> You need to wrap it in Just
14:46:28 <Cale> tuple1 (Tuple1 a b c d) = Just a
14:46:34 <Cale> er
14:46:36 <Ontolog> tuple1 (Tuple a b c d) = Just a
14:46:38 <Cale> tuple1 (Tuple4 a b c d) = Just a
14:46:39 <Ontolog> still gives me same error
14:46:47 <Ontolog> i dont get that
14:46:54 <Ontolog> what if I give it a Tuple3?
14:47:02 <Cale> then the pattern match will fail
14:47:12 <Cale> you need more cases for tuple1
14:47:27 <Ontolog> ohh k
14:47:56 <Ontolog> so in the function definition
14:48:00 <Cale> note that the "Tuple" on the left hand side of the = in the data declaration is the name of a type constructor -- something which will show up in types, not in values
14:48:34 <Cale> Tuple1, Tuple2, Tuple3 and Tuple4 are the data constructors for that type
14:49:04 <Ontolog> ok so in the function definition for the parameters to the function you need to always use data constructors?
14:49:10 <Cale> yeah
14:49:44 <Cale> In general you match patterns of data constructors with variables put into them which will be bound to whatever parts matched
14:50:40 <Ontolog> Cale: does this make for incredibly verbose code?
14:50:47 <Cale> not usually
14:50:51 <Cale> this is a poor example
14:51:02 <Cale> It actually makes for really concise code most of the time
14:51:27 <ArtemGr> correct me if i'm wrong:
14:51:27 <ArtemGr> tuple1 a = ... -- will take anything, but won't be of much use except passing it somewhere else
14:51:27 <ArtemGr> tuple1 (Tuple4 a b c d) = ... -- extracts imbued values from the type
14:51:36 <Cale> right
14:51:44 <Cale> from the data
14:52:08 <Cale> but it only matches a Tuple4
14:52:54 <Cale> This Tuple type is a little artificial, I'd have a hard time finding a place to use it
14:53:04 <Ontolog> gah.. it's in the tutorial :(
14:53:22 <Cale> Well, it's an okay tutorial type
14:53:34 <Cale> because it gives you some idea of how the syntax works
14:53:47 <Cale> but I don't think you'd actually use that particular type
14:54:34 <ArtemGr> you can also write:
14:54:34 <ArtemGr> tuple1 t = ... case t of {(Tuple4 a b c d) -> ...; ...}
14:54:54 <Cale> without that first ... even
14:55:14 <Ontolog> dag nabit
14:55:16 <Cale> tuple1 t = case t of
14:55:22 <Cale>   Tuple1 a -> a
14:55:28 <Cale>   Tuple2 a b -> a
14:55:32 <Cale>   Tuple3 a b c -> a
14:55:36 <Cale>   Tuple4 a b c d -> a
14:55:47 <Ontolog> interesting
14:57:10 <Ontolog> would the function prototype still be tuple1 :: (Tuple a b c d) -> Maybe a?
14:57:23 <Cale> oh
14:57:33 <Cale> If you want the Maybe a, you'd apply Just
14:57:50 <Cale> either inside each case, or to the case expression as a whole
14:58:09 <Cale> data Maybe a = Nothing | Just a
14:58:18 <Ontolog> so you can do: Just case to of ...
14:58:25 <Ontolog> *case t of
14:58:36 <ArtemGr> (that's why we need Just, by the way, so that type of the function can be inferred)
14:58:51 <SamB_XP> don't you want to return Nothing from some cases?
14:59:09 <Ontolog> not for tuple1
14:59:14 <Ontolog> but for tuple2, 3, etc
14:59:15 <Ontolog> yes
14:59:22 <SamB_XP> oh, right ;-)
14:59:24 <Ontolog> so I guess in those cases I need to specify Just for each
14:59:42 <Cale> actually you'll need parens
14:59:48 <Cale> (or a $)
15:00:22 <Ontolog> where do parens go around? or  the $ affix to?
15:00:44 <Cale> the parens go around the whole case expression, or the $ would go between the case and the Just
15:01:11 <Cale> $ is just an infix operator defined as:  f $ x = f x
15:01:35 <Cale> but it has low precedence, so it acts a little like wrapping the stuff before and after it in parens
15:01:37 <Ontolog> so for parens it's case t of (...) or (case t of...)?
15:01:44 <Cale> (case t of ...)
15:02:17 <shapr> @where soe
15:02:18 <lambdabot> http://haskell.org/soe/
15:02:28 <shapr> Where's the Gtk2Hs clone of the SOE libs?
15:02:47 <dcoutts> shapr, http://haskell.org/~duncan/soegtk/
15:02:49 <lambdabot> Title: Index of /~duncan/soegtk
15:02:55 <Cale> the $ is nice here because you don't have to close it
15:03:02 <ArtemGr> actually, it would be better to use
15:03:02 <ArtemGr> tuple1 (Tuple4 a _ _ _) = a
15:03:02 <ArtemGr> then
15:03:02 <ArtemGr> tuple1 (Tuple4 a b c d) = a
15:03:02 <ArtemGr> -Wall should give a warning about that
15:03:04 <Ontolog> yeah I like the $
15:03:06 <shapr> dcoutts: ah, thanks!
15:03:10 <dcoutts> np
15:03:17 <shapr> @where+ soe-gtk http://haskell.org/~duncan/soegtk/
15:03:17 <lambdabot> Done.
15:03:55 <Ontolog> ArtemGr: what's the differencE?
15:04:03 <Cale> There's little difference
15:04:18 <Cale> You use _ to emphasize the fact that you're not using that variable.
15:04:26 <ArtemGr> Ontolog: you clatter namespace inside the tuple1 : )
15:04:33 <shapr> dcoutts: Is that a reimplementation of the SOE api?
15:04:37 <Ontolog> got it
15:04:59 <Cale> oh, one nice trick
15:05:19 <dcoutts> shapr, yep
15:05:22 <shapr> Ya know, solving problems with Haskell is totally addictive.
15:05:22 <Cale> Suppose you want to write the function which returns the number of components in the TupleN
15:05:46 <Cale> You might think you have to write Tuple4 _ _ _ _
15:05:57 <Cale> but you can actually just write Tuple4 {}
15:06:00 <shapr> I've been working on HAppS in Haskell, doing much the same sort of stuff I've done with Python in Zope. Except fixing problems in Haskell means they stay fixed.
15:06:12 <Cale> which works regardless of whether you're using record-syntax or not
15:06:16 * shapr hugs SPJ
15:07:13 * shapr hugs the entire Haskell language committee
15:08:15 <Ontolog> cool
15:08:17 <Ontolog> thanks for the help
15:08:21 <Cale> no problem
15:10:44 <vincenz> Cale++
15:10:49 <shapr> So I had lunch with this guy and talked to him about Haskell.
15:11:00 <shapr> And I loaned him my rabhi & lapalme FP Algorithms book.
15:11:05 <shapr> And I asked him to show up here on #haskell !
15:13:23 <fons> hi all
15:17:56 <shapr> hej fons, how's universitet?
15:18:20 <fabiim> fun l = [3* x | y<-l , x<-y] , what does this do ? my guess is fun [2,1] = [6,3,6,3] , but i can't check it , it gives me a type error
15:18:27 <fons> det gÂr bra
15:18:34 <fons> :)
15:18:57 <Heffalump> try providing different input
15:19:17 <fons> I'm trying to model optional functions in a type class using maybe
15:19:28 <fons> class Foo a where
15:19:46 <fons>  optional :: Maybe (a -> Bool)
15:19:51 <fons> for example
15:20:34 <fons> it is valid
15:21:30 <fons> but given an element of an instantiated type (i.e. Foo a => a) I don't know how to obtain optional
15:21:53 <dolio> fabiim: The argument to fun must be a list of lists.
15:21:53 <fons> mainly becuase optional doesn't have arguments
15:22:38 <fons> So I wonder if it's just useless to declare class functions without arguments or I'm missing something
15:23:52 <fabiim> oh , i see  thanks
15:24:08 <TSC> optional a :: Maybe Bool ?
15:24:18 <TSC> It's not quite the same, but it might work
15:24:38 <TSC> Instances that don't use it can say "optional = Nothing"
15:24:41 <dolio> You'd need to do something like: "case optional of Just f -> f a ; Nothing -> ..."
15:25:06 <fons> dolio, thanks that's exactly what I needed
15:25:11 <fons> didn't think about that :)
15:25:17 <TSC> ... or you could do that (:
15:25:18 <sjanssen> fons: why not separate the optional operation into another class?
15:25:27 <eviltwin_b> you declared optional to returnb either Nothing or Just ({- some boolean function here -})
15:26:00 <fons> sjanssen, there are two optional operations
15:26:08 <eviltwin_b> is that what you really intended?  that optional return a value which is a function?
15:26:12 <fons> wouldn't it make it too complicated?
15:26:46 <fons> eviltwin_b, that's my way of modelling an optional function
15:26:58 <eviltwin_b> really, I'd say the correct implementation depends on what "optional function" means in context
15:26:59 <sjanssen> fons: perhaps, but using case optional of ... all the time is pretty complicated already
15:27:06 <fons> eviltwin_b, which might not be right
15:27:19 <fons> sjanssen, that is a good idea
15:27:43 <sjanssen> is there any way that optional could be implemented in terms of the other class members?
15:28:09 <fons> sjanssen, no
15:28:36 <fons> sjanssen, but the problem is ... how to check if that is implemented or not?
15:28:57 <eviltwin_b> the problem with the notion of optional function is tat it more or less defeats type checking
15:29:41 <fons> I'm modeling a plugin ... which can provide or not certain functions
15:29:44 <eviltwin_b> normally you'd check its presence by declaring a type class containing the function, and then when you need it you declare in the function using it that it requires an instance of the type class implementing it
15:30:11 <sjanssen> fons: ah, for a plugin system it might be better to use Maybe
15:30:24 <eviltwin_b> which raises a compile time failure if the instance doesn't support it; that's using static typpe checking in your favor
15:30:45 <eviltwin_b> for a dynamic check you want a function which returns a Maybe, not a function which returns either Just somefunc or Nothing
15:31:12 <eviltwin_b> so myOptionalFunc x = Nothing -- not implemented
15:31:13 <fons> eviltwin_b, the C host must always know if those functions are implemented or not
15:31:22 <sjanssen> eviltwin_b: I think "Maybe (a -> Bool)" is a better solution here
15:32:11 <eviltwin_b> hm, if you really need to model presence/absence of the function itself, yes that would be the way.  would be a pain to work with, but no more so than checking in C if a function pointer is NULL
15:32:31 <eviltwin_b> but I'd probably model that as:
15:33:00 <sjanssen> you could also use MPTCs and fundeps to have compile time checking, but that gets complicated
15:33:18 <fons> I have to translate that to C, as a pointer to the function or a NULL value
15:33:18 <eviltwin_b> checkOptional funcTag = {- coppde to check if function is there and returnb Nothing or Just funcval -}
15:34:02 <eviltwin_b> if the tags are actually static then you were on the right track to start with:
15:34:20 <monochrom> I just drop by to say the new HWN logo is cool!
15:34:21 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
15:34:27 <eviltwin_b> instance Foo Mytype where optionalFunc x = Nothing -- not implemented in Mytype
15:34:52 <eviltwin_b> sorry: instance Foo Mytype where optionalFunc = Nothing -- not implemented in Mytype
15:35:06 <vincenz> eer
15:35:34 <eviltwin_b> instance Foo MyOtherType where optionalFunc = Just $ realFunction -- implemented here
15:36:39 <fons> eviltwin_b, that's the plan
15:38:31 <fons> thanks
15:38:33 <fons> :)
15:41:33 <shapr> hi osser__
15:41:35 <shapr> how's code?
15:41:41 <psnl> morning
15:42:21 <shapr> y0 psnl
15:43:31 * psnl wonders if shapr is pissed, or if ts too early for him these days
15:44:02 * shapr hasn't had any alcohol in weeks
15:44:08 * vincenz pats shapr on the back
15:45:07 <psnl> shapr: good for you
15:45:36 <profmakx> and blackjack
15:45:38 <profmakx> and hookers
15:48:53 * psnl hasn't had a good night's sleep in .... so .... long
15:52:08 <shapr> ya know, #haskell should offer a weekly code toy.
15:52:38 <monochrom> What is a code toy?
15:53:10 <shapr> A small bit of generally useful code that encourages reuse and extending.
15:53:23 <profmakx> > 1 + 1
15:53:25 <lambdabot>  2
15:53:33 <profmakx> introducing: operator "+"
15:53:42 <profmakx> @type (+)
15:53:43 <lambdabot> forall a. (Num a) => a -> a -> a
15:53:52 <shapr> Like, pick tasks that people deal with everyday and write a bit of code towards that.
15:53:59 <psnl> shapr: and you suggestion for this weeks entry is....
15:54:45 <shapr> hm, html scraping?
15:54:56 <totolezero> hello shapr
15:55:07 <shapr> salut totolezero
15:55:12 <totolezero> salut :)
15:55:17 <vincenz> bonsoire
15:55:22 <totolezero> bonsoir les mecs
15:55:27 <psnl> shapr: any html problem that can't be done with grep needs sleep
15:55:33 <shapr> How's code treating you?
15:55:40 <totolezero> de quoi Áa discute ici ?
15:55:56 <monochrom> I solve all html reading problems with haxml.
15:56:09 <monochrom> err probably writing problems too :)
15:56:11 <shapr> psnl: Well, what sort of thing do you do everyday that would be easier if you had a bit of code to automate the boring or repetitive parts?
15:56:28 <SamB_XP> psnl: what?
15:56:34 <monochrom> t e m p l a t e  h a s k e l l
15:56:35 * psnl thinks
15:56:35 <shapr> totolezero: This channel is about the programming language Haskell
15:56:47 <SamB_XP> what makes you think grep will work for html?
15:57:28 <psnl> SamB_XP: years of bad abuse of grep
15:57:30 <monochrom> No, he's saying sometimes grep is inadequate, in which case you need sleep.
15:57:48 <totolezero> thanks shapr
15:57:57 <psnl> then in the morning, when you are sober, you can do it with <foo>
15:58:03 <shapr> totolezero: Would you like to see a short intro to Haskell?
15:58:06 <fabiim> how can i turn a : [[a]] in [a] with map ?
15:58:10 * SamB_XP thinks relaxng would be more usefull
15:58:14 <monochrom> Hmm CFG matching...
15:58:21 <totolezero> what is Haskell ?
15:58:53 <shapr> totolezero: langue fonctionelle
15:58:58 <psnl> totolezero: http://www.haskell.org/haskellwiki/Haskell
15:59:00 <lambdabot> Title: Haskell - HaskellWiki
15:59:01 <shapr> logiciel libre
15:59:17 <fabiim> i'm trying map (++) [[a]] , it doesn't go there , i don't get it, shouldn't that evaluate to something like x1 ++ x2 ++ x3++ [] , ?
15:59:20 <monochrom> what is logiciel?
15:59:28 <SamB_XP> shapr: did you just tell him to go to the library?
15:59:38 <profmakx> and blackjack
15:59:40 <profmakx> and hookers
15:59:48 <totolezero> program in OCaml
15:59:48 <shapr> No, I said it's free/open source software.
15:59:51 <monochrom> libre as in liberty
15:59:59 <SamB_XP> oh, right
16:00:00 <monochrom> OH!  logiciel = software?
16:00:12 <Saulzar> fabiim, Have a look at folds (foldl, foldr)
16:00:16 <monochrom> books and libraries would be "biblio*"
16:00:21 <shapr> totolezero: Haskell is much like OCaml, except even more.
16:00:30 <shapr> monochrom: yup
16:00:33 <fabiim> i'm studying , i have to do it with map lol :)
16:00:35 <SamB_XP> except for the ugly part
16:00:42 <SamB_XP> haskell isn't uglier than ocaml
16:00:58 <totolezero> :)
16:01:00 <monochrom> Hmm what is the logic behind logiciel = software?  hee hee hee
16:01:25 <lisppaste2> fons pasted "instantiation problem" at http://paste.lisp.org/display/30119
16:01:57 <fons> can aonyone have a look at that instantiation problem?
16:02:11 <shapr> Yeah, French makes it clearer than English that software is logic/math.
16:02:18 <Saulzar> fabiim, Well map just applies a function to each element and outputs it in the same list structure f [x, y, z] = [f x, f y, f z]
16:02:32 <fons> the compilation errors I get are "Ambiguous type variables"
16:02:35 <shapr> fabiim: How would you put two lists together to make one list?
16:02:43 <Saulzar> er, map f [x, y, z] = [f x, f y, f z]
16:03:26 <beelsebob> @where lambdabot
16:03:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:03:29 <fabiim> Saulzar:  yes so map ( ++ ) [[a]]   should be = to : a1 ++ a2++ a3++ []
16:03:43 <fabiim> because [] is a element of this list right?
16:04:04 <fabiim> i don't get what's wrong ....
16:04:06 <fabiim> :S
16:04:13 <shapr> fabiim: No, it's [(++) x, (++) y, (++) z]
16:04:14 <fabiim> shapr:  yes
16:04:42 <shapr> fabiim: Should map (+) [1,2,3] add all the numbers together?
16:04:46 <Saulzar> (++) x by itself is a half-applied function
16:04:47 <fabiim> but doesn't that curry thing transforms ++ x into (x ++ )?
16:04:48 <fons> I don't really know how to supply type information due to the hidden parameter in the existentially quantified type
16:05:11 <monochrom> I'll bite, fons.  But don't hope too much.
16:05:27 <fabiim> shapr:  no but should end up like z + []
16:05:34 <shapr> fabiim: Yeah, you made a list of (thing ++) items.
16:06:02 <fons> thanks monochrom
16:06:07 <Saulzar> The elements adjacent to each other don't combine in any way
16:06:10 <shapr> > map (+) [1]
16:06:11 <lambdabot>  Add a type signature
16:06:39 <kaol> anyone know if anyone's looked into getting HAppS packaged for Debian yet?
16:06:40 <shapr> > map (+1) [1]
16:06:42 <lambdabot>  [2]
16:06:59 <shapr> > map (+1) [1,2,3]
16:07:00 <lambdabot>  [2,3,4]
16:07:07 <Excedrin> I've packaged HAppS for Arch!
16:07:08 <fabiim> yeah , i get it ...
16:07:30 <shapr> kaol: I haven't heard anything about it, but I'll ask the other HAppS developers.
16:07:33 <fabiim> how should i solve my problem then?
16:07:49 <fabiim> if i do map ([]++) [[a]]
16:08:02 <fabiim> it does nothing ...
16:08:02 <beelsebob> @list
16:08:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:08:20 <shapr> > map ([]++) [[1,2],[3,4]]
16:08:21 <lambdabot>  [[1,2],[3,4]]
16:08:37 <dcoutts> ([]++) = id :: [a] -> [a]
16:08:45 <shapr> > map ([42]++) [[1,2],[3,4]]
16:08:46 <lambdabot>  [[42,1,2],[42,3,4]]
16:08:50 <fabiim> i need to "delete" the [] from each list ...
16:09:02 <dcoutts> > concat[[1,2],[3,4]]
16:09:04 <lambdabot>  [1,2,3,4]
16:09:05 <TSC> Why do you want to use map?
16:09:08 <beelsebob> @help yhjulwwiefzojcbxybbruweejw
16:09:09 <lambdabot> V RETURNS!
16:09:12 <beelsebob> o.O
16:09:14 <fons> sjanssen, the solution including the optional class functions is included in the paste http://paste.lisp.org/display/30119 but it gives me "Ambiguous type"  errors
16:09:16 <beelsebob> @yhjulwwiefzojcbxybbruweejw
16:09:17 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:09:19 <shapr> kaol: Are you having difficulties installing HAppS?
16:09:21 <beelsebob> O.o
16:09:24 <beelsebob> WTF!
16:09:31 <kaol> no ITP open on Debian's WNPP yet... The quickest way for seeing it in Debian might be to package it myself.
16:09:37 <beelsebob> @yhjulwwiefzojcbxybbruweejw a
16:09:37 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:09:41 * beelsebob confused
16:09:48 <SamB_XP> > fix show
16:09:49 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:09:52 <beelsebob> @help protontorpedo
16:09:53 <lambdabot> protontorpedo is silly
16:10:00 <beelsebob> @protontorpedo SamB
16:10:00 <SamB_XP> @help keal
16:10:01 <lambdabot> wat is lazy evaluation?
16:10:01 <lambdabot> keal. Talk like Keal
16:10:07 <shapr> kaol: Sure! Go for it.
16:10:09 <SamB_XP> @help yow
16:10:10 <lambdabot> yow. The zippy man.
16:10:14 <monochrom> fons: I do not understand (.hHandle)
16:10:15 <kaol> shapr: packaging it for Debian wouldn't take that much more effort than setting it up for one server ;-)
16:10:27 <sjanssen> fons: can you paste the compiler error
16:10:36 <Saulzar> fabiim, Only way you can do that is by condensing each list (in the bigger list) into a single value
16:10:42 <fabiim> i'm doing an exercice wich requires to build : fun l = [3*x |  y<-l , x <-y ]  with map , the author wants to relate map's with list comprehension
16:10:44 <fons> monochrom, it is existentially quantified
16:10:50 <shapr> kaol: Yes please!
16:11:08 <shapr> kaol: Can you package it in such a way that the HAppS developers can easily contribute new patches?
16:11:39 <fabiim> ? can't i do what dcoutts said ? map (concat) [[a]]
16:11:53 <kaol> shapr: would a darcs repository qualify for that?
16:11:58 <shapr> kaol: I'll ask alex if we can put a debian/ dir into the darcs repo.
16:11:58 <Saulzar> fabiim, Well, first off - what does that actually do?
16:12:28 <fabiim> it applies concat to each element of the list , wich is itself a list
16:12:37 <fabiim> yeah , it won't work ...
16:12:42 <Saulzar> No, I mean that function you pasted
16:12:51 <Saulzar> With the comprehension
16:12:57 <Saulzar> fabiim, Stop looking for a solution before you know what the question is :)
16:13:34 <fabiim> Saulzar: lolol , i tough i knew the question
16:14:04 <fabiim> i need to break an [[a]] into [a] and then map'it with (3*)
16:14:49 <fabiim> i think so...
16:14:50 <kaol> actually, it's cleaner if there's no debian/ in upstream's tarballs... But I'll try to not overcommit myself and will refrain for now from actually promising to package it. But I'll definitely look into it.
16:14:51 <fabiim> lol
16:14:54 <fabiim> =)
16:15:24 <shapr> kaol: Ok
16:15:42 <sjanssen> fons: I think you need to pattern match in the CHandle instance instead of using record selectors
16:16:20 <Saulzar> fabiim, You need more than just a map
16:16:22 <fons> sjanssen, uhm, that should solve it
16:16:28 <shapr> kaol: I'd like that. I do some HAppS dev and I use debian/unstable.
16:16:29 <fons> thanks sjanssen
16:16:40 <sjanssen> fons: that actually solved it?
16:16:53 <fons> sjanssen, gonna try it right now
16:17:57 <fons> sjanssen, after thinking about it I'm not so sure
16:18:11 <sjanssen> did you try it?
16:18:12 <Excedrin> since HAppS uses Cabal, I had no problems packaging it on Arch. I have a generic package for anything that uses Cabal.
16:18:22 <fons> the problem is that ghc doesn't know how to infer the type of activate in the RHS
16:18:23 <fabiim> Saulzar: do you think so?Is it impossible with just map and a function?
16:18:47 <Saulzar> fabiim, Well there you go, a map _and a function_ :)
16:19:03 <fabiim> i mean map (function) list
16:19:06 <scodil> is there any way to have an IORef at module (ie, global) scope that initially contains an undefined value, or maybe a Nothing?  I'm getting tired of these big huge let-statements in main
16:19:23 <fabiim> then i could make map (3*) to that ...
16:19:25 <sjanssen> fons: I think that inference problem is related to your use of existentials in CHandle
16:19:57 <Saulzar> fabiim, Yes - map doesn't change the structure of the list, you can't merge two lists with a map
16:20:44 <fabiim> humm , great ! i was beginning to fell depressed for not being able to do another exercise  lol =)
16:21:29 <sjanssen> scodil: there are ways, but they're all hacks
16:22:00 <sjanssen> scodil: though I don't see the correlation between let statements and IORefs
16:22:37 <fons> sjanssen, well it's really strange cause it doesn't complain when instanciating run
16:22:49 <fons> actually if I comment the other lines ... no problem arises
16:22:50 <monochrom> fons: it's a bit odd to me that activate does not take any parameter.
16:23:00 <fons> moconnor, for me too
16:23:04 <fons> :)
16:23:26 <Cale> scodil: perhaps a reader-transformed IO monad would help?
16:23:37 <fons> moconnor, it's my way of expressing optional functions
16:23:39 <scodil> sjanssen: if you use a gui library, all your state has to be in scope for your callbacks
16:24:36 <scodil> so you first have to newIORef all your state, and then let-in all your callbacks
16:24:43 <scodil> all in main (or some IO func)
16:24:56 <dcoutts> scodil, or use some data types which bundle up the state
16:24:57 <sjanssen> scodil: so you have to pass in a bunch of params whenever you construct a callback, that could get annoying
16:25:31 <scodil> yeah the other sol'n is what dcoutts says, curry in all the state as params to the callbacks
16:25:57 <dcoutts> or just make a ThisGUI record type and pass that
16:25:58 <scodil> i'm not a fan of either method. sometimes global mutable state is appropriate
16:26:04 <dcoutts> eew
16:26:19 <dibblego> when?
16:26:37 <scodil> not every program evolves into a monster. sometimes you just want to band something out
16:26:43 <dcoutts> fortunately Haskell doesn't let you do global mutable state
16:26:44 <scodil> bang
16:26:59 <dcoutts> (unsafeFoo doesn't count)
16:27:32 <scodil> i don't really see how it doesn't. there's still shared mutable state, its just not allowed to be at the outermost scope
16:27:46 <dcoutts> exactly
16:28:05 <dcoutts> so you can always make multiple instances of the stateful thing
16:28:48 <dons> dcoutts: see Claus Reinke's interesting mail on glasgow-haskell-users?
16:29:06 <dons> "bignums, gmp, bytestring, .." along with a review of the streams paper
16:29:21 <dcoutts> what was the subject?
16:29:30 <dons> "bignums, gmp, bytestring, .."
16:29:39 <dcoutts> ah, just got it
16:31:45 <sjanssen> fons: I'm really not sure how to implement this
16:31:51 <dcoutts> dons, mm, yeah we did ignore all the imperative loop fusion
16:32:04 <fons> sjanssen, thanks anyway
16:32:17 <fons> I'm having loads of trouble myself
16:32:54 <monochrom> fons: Do you know of "referential transparency"?
16:33:02 <dons> dcoutts: we did mention "much work on fusion in an imperative setting" iirc
16:33:09 <fons> moconnor, yep ...
16:33:14 <dcoutts> dons, oh, ok
16:33:25 <fons> ops sorry, I meant monochrom
16:33:32 <dons> but the key concern is rewriting/combinator based techniques. so given the space...
16:34:05 <dcoutts> yeah
16:34:20 <dcoutts> dons, I don't get what he means about a BS-like representation for big nums
16:34:28 <monochrom> Let H1,H2 be two distinct instances of Handle.  For H1, activate (:: Maybe(H1->IO())) is Nothing.  For H2, activate (::Maybe(H2->IO())) is Just whatever.
16:34:38 <fons> dolio, could you have a look at the paste (gien that you suggested how to solve the class functions without parameters problem)
16:34:57 <sjanssen> hmm, can you really fuse multiplication efficiently?
16:34:57 <fons> dolio, it's at http://paste.lisp.org/display/30119
16:35:01 <dons> dcoutts: i just put up the streams talk I gave last friday, http://www.cse.unsw.edu.au/~dons/talks/streams-sapling-talk.ps.gz too.
16:35:02 <lambdabot> http://tinyurl.com/yzzlsz
16:35:11 * dcoutts looks
16:35:14 <dons> dcoutts: yeah, not sure. so gmp numbers are byte arrays
16:35:18 <dons> but more than that I don't know
16:35:26 <dcoutts> aye
16:35:48 <monochrom> Now, you are trying to say, for CHandle, the value of activate (:: Maybe(CHandle -> IO())) is sometimes Nothing and somethings Just ???, depending on whether a CHandle happens to wrap an H1 or an H2.
16:35:49 <dons> silliest bug report ever? -- "ghci crashes when running out of heap"
16:35:49 <dcoutts> dons, I think actually they can be several arrays
16:35:52 <dons> well, duh!
16:35:56 <dons> ah interesting
16:36:03 <monochrom> This violates referential transparency.
16:36:53 <fons> monochrom, no, it doesn't, the quantification just hides the type parameter
16:37:10 <monochrom> I know.
16:37:47 <monochrom> Suppose you have f :: CHandle -> Maybe(CHandle -> IO()).  Then f can behave differently depending on the parameter.
16:37:53 <dcoutts> dons, today I wrote versions of unfoldr & destroy on streams and showed how they fuse
16:37:57 <shapr> Sounds like linear params.
16:37:59 <monochrom> Here you have no parameter.  It is a constant.
16:38:11 <dolio> fons: What about it?
16:38:45 <fons> dolio, the compiler gives errors due to ambigous types
16:39:18 <dons> dcoutts: oh nice!
16:39:25 <dcoutts> dons, eg destroy f = producer (destroyS f)
16:39:30 <dons> ah, look, we did have the ref, but ran out of space: %    \item loop fusion in imperative languages
16:39:39 <dcoutts> ah
16:40:15 <dcoutts> dons, then when it fuses you get: destroy g (unfoldr f e) = destroyS g (unfoldrS f e)
16:40:18 <fons> monochrom, of course it would, but it would always give the same output given the same input, that's referential transparency
16:40:20 <dcoutts> dons, which looks right :-)
16:40:37 <dcoutts> then inline everything and you should get normal destroy/unfoldr fusion
16:40:45 <dcoutts> or one could add a special case rule
16:41:01 <monochrom> There is no input.
16:41:04 <CosmicRay> arjanoosting: I think haskell-devscripts is doing something weird with profiling; see #399127
16:41:18 <dolio> fons: What part does it complain about? The CHandle instance does look a bit fishy.
16:41:22 <fons> <monochrom> Suppose you have f :: CHandle -> Maybe(CHandle -> IO()). I'm refering to your f
16:41:45 <monochrom> Then that has input.  Your activate has no input.
16:41:47 <dons> dcoutts: ah very interesting
16:42:13 <fons> dolio, well, it is fishy, the thing is I have to hide the type parameter in order to export it to C
16:42:27 <dcoutts> dons, so basically we've moved things about so that we're composing two non-recursive functions
16:42:37 <dcoutts> as usual
16:43:29 <dons> so going via the stream data structure, but with different introduction and eliminations functions, and a different rewrite rule?
16:43:35 <fons> dolio, the compiler complains about Ambiguous type variable `hd' in the constraint: `Handle hd'
16:43:40 <dons> any benefit, besides we can do it?
16:44:11 * dons back in 15
16:44:12 <dcoutts> dons, I guess one benefit is it provides another way to write fusible things
16:44:27 <fons> dolio, the curious thing about it is that the compiler doesn't complain in case of the instantiation of run
16:45:23 <fons> monochrom, think it in this way, the compiler doesn't complain about class functions without parameters and is legal haskell. Considering that Haskell is referentially transparent why would that happen?
16:46:26 <monochrom> class Default a where default :: a
16:46:36 <monochrom> instance Default Int where default = 1
16:46:40 <monochrom> instance Default Integer where default = 2
16:46:50 <monochrom> This is legal and sometimes useful.
16:47:21 <monochrom> "default :: Default a => a" is still parameterized by "a".
16:47:43 <TSC> Do any Debian people here know what to do about this?  "libghc6-glib-dev: Depends: ghc6 (< 6.4.2+) but 6.6-3 is to be installed"
16:47:48 <dolio> What happens if you change it to: "case activate of Just f -> Just (f . hHandle); Nothing -> Nothing"?
16:47:49 <monochrom> "default :: Int", however, is no longer parameterized by anything.
16:47:55 <dolio> Even though that should probably do the same thing.
16:48:29 <dolio> I guess that probably won't fix anything.
16:48:41 <monochrom> activate :: Handle a => Maybe (a -> IO())   this is still parameterized by "a".  Can be different for different "a".
16:49:28 <monochrom> activate :: Maybe (CHandle -> IO())   this cannot depend on anything.  The implementation must be a piece of hard code.  No lookup.  (What to lookup?)
16:49:49 <fons> monochrom, I seriously don't see your point
16:51:00 <dolio> fons: I think the problem is that hHandle is specified to return any type of Handle, but no specific type is demanded, so it can't decide.
16:51:06 <kaol> TSC: wait until http://bugs.debian.org/393600 is resolved
16:51:10 <lambdabot> Title: #393600 - gtk2hs: FTBFS with ghc6 6.6 - Debian Bug report logs
16:51:17 <dolio> That might not be what you want hHandle to do, either.
16:51:40 <TSC> kaol: Thanks, I was looking for a bug report like that somewhere
16:52:44 <dolio> But I haven't really studied/used existential types much, so I can't really give you advice there.
16:53:40 <lisppaste2> monochrom annotated #30119 with "my analysis" at http://paste.lisp.org/display/30119#1
16:54:03 <scodil> is there a way to declare a record without giving types to the fields? to just let the type checker infer it?
16:54:33 <monochrom> I have to go.  I will have to document it and let other people explain that reasoning to you.
16:55:12 <lispy> scodil: hmm...i think so but i don't think you'll like it
16:55:26 <dcoutts> scodil, use tuples
16:55:26 <scodil> hit me
16:55:36 <lispy> data MyRecord a b c = MyRecord { mya :: a, myb :: b, myc :: c }
16:55:48 <dcoutts> which is equivalent to (,,)
16:55:50 <lispy> now the types are parameters :)
16:56:21 <lispy> yeah, use dcoutts's idea
16:56:26 <lispy> could you newtype a tuple?
16:56:34 <dcoutts> yep
16:56:43 <lispy> what is the syntax?  I bet this doesn't work: newtype MyTuple = (,,)
16:56:57 <dcoutts> newtype MyTuple a b c = (a,b,c)
16:57:07 <dcoutts> ie pretty much the same as your data suggestion
16:57:14 <dcoutts> oops
16:57:20 <dcoutts> newtype MyTuple a b c = MyTuple (a,b,c)
16:57:21 <lispy> yeah, need the MyTuple on the rhs
16:57:26 <dcoutts> :-)
16:57:46 <fons> monochrom, your assumption is wrong
16:57:59 <fons> "The intention was to define activate for CHandle so that sometimes ..."
16:58:09 <fons> the intention is just hidding the parameter
16:58:50 <monochrom> OK, why is activate for CHandle not = Just (\c -> ...) ?
16:59:01 <fons> please have a look at http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
16:59:02 <monochrom> why do an fmap on .hHandle?
16:59:04 <lambdabot> http://tinyurl.com/f9umb
16:59:36 <fons> I think that by reading that you would understand what I'm trying to do
17:01:17 <monochrom> Meanwhile could you answer my latest question?
17:01:59 <dons> dcoutts: do we get fusible structures already encoded in terms of destroy/unfold for free?
17:02:08 <dcoutts> dons, yes
17:02:15 <dons> i.e. can we encode other fusion strategies into streams, and $profit
17:02:30 <dcoutts> we might be able to do build/fold too
17:02:48 <dcoutts> I think sjanssen tried this
17:03:22 <dcoutts> dons, using destroy allows short-cutting like find
17:03:39 <dcoutts> dons, though it does not take advantage of the yield optimisation
17:03:43 <dcoutts> err skip
17:04:02 <fons> monochrom, well, I'm not doing a fmap _on_ (.hHandle) I'm using (.hHandle) to fmap actiave or deactivate (of type Handle hd => Maybe (hd -> IO()) )
17:04:11 <dons> i'm wondering if we can take an off-the-shell destory/unfold fusible tree, perhaps, and just change the defns of destroy and unfold
17:04:16 <scodil> i read something somewhere about turning off the record field selector function, so that you can only get at your fields by pattern matching, and there's no more name clashing... can this be done?
17:04:38 <dcoutts> dons, have people done destroy/unfoldr for trees?
17:04:44 <dons> not sure.
17:04:46 <dcoutts> it sounds possible
17:04:53 <dons> scodil: hide the constructors?
17:04:54 <Thomas2> hmm.
17:05:04 <dcoutts> Streams should generalise to trees fine
17:05:05 <dons> morning Thomas2
17:05:15 * Thomas2 wonders how close this is to the tree algorithms sebastian is working on
17:05:18 <Thomas2> morning
17:05:19 <scodil> dons: isn't that the opposite? I want the constructors, not the functions named after the fields
17:05:29 <dcoutts> just change Step to Yield x left right
17:05:31 <dons> ah, you want to hide the lables?
17:05:52 <scodil> yeah
17:06:12 <scodil> well, no... still want to be able to deconstruct
17:06:16 <scodil> by name
17:06:21 <Thomas2> aha, yeah, tree transducers
17:06:49 <monochrom> OK, why is activate for CHandle not = Just (\c -> ...) ?
17:06:51 * Smokey`` prods Smokey`
17:06:53 <dons> scodil: you want to deconstruct by name? i.e. by label?
17:07:05 <dons> but you don' twant to use the generated selector functions
17:07:10 <dons> not sure that can be done (?)
17:07:37 <dons> Thomas2: http://programming.reddit.com/info/ratk/comments
17:07:39 <lambdabot> Title: House: An operating system written in Haskell (reddit.com), http://tinyurl.com/y2v4w2
17:07:46 <scodil> I think i read it in regards to haskell prime. thought maybe there could be a ghc flag for it or something
17:07:53 <heatsink> scodil, you mean like views?
17:08:15 <dons> Thomas2: we should probably post a link to your work in the next few days :)
17:08:20 <scodil> heatsink: no probably not, although i'm not quite sure what you mean by views
17:08:21 <fons> monochrom, it dependends on the instance
17:08:40 <fons> monochrom, please have a look at the link I pasted
17:08:53 <monochrom> activate :: Maybe (CHandle -> IO())   there is no more unknown instance.
17:09:14 <dons> oh, this is nice "Is there a simple reason why Haskell beats MLton so handily on the "cheap concurrency" benchmark? ... The Haskell people never cease to amaze me."
17:09:40 <dolio> CHandle is not parameterized by some other handle type, so what other instance's activate is it calling?
17:10:32 <Thomas2> dons: sounds cool. i'll ping the people who wrote some of those papers.
17:10:55 <fons> monochrom, the problem is that the activate on the rhs referes to the hHandle element of the CHandle
17:11:01 <monochrom> In the wikibook, the only example is "data ShowH = forall s. Show s => SH s", and the only class method relied on is "show :: (Show s) => s -> String".  Note that this method takes a parameter.  That will give you instance-depending behaviour alright.
17:11:15 <heatsink> scodil: I'm not sure what it means to use record selectors to deconstruct by name, then.
17:11:25 <monochrom> The wikibook example is completely unlike activate.
17:11:26 <fons> monochrom, why does it work for run?
17:12:03 <fons> if you comment the rest of the functions and leave only run, it compiles
17:12:38 <fons> but cleanup doesn't work either
17:13:44 <monochrom> run takes a parameter.  it is like show.  activate takes no parameter.  it is unlike show.
17:13:54 <fons> moconnor, and so does cleanup
17:14:01 <fons> monochrom*
17:14:09 <fons> but it doesn't either work
17:17:38 <Excedrin> dons: where's the comment about concurrency from? whoever asked it could have also asked, "Is there a simple reason why Oz beats Haskell so handily..."
17:18:21 <dons> it was a 'message', one of the private comments you can send to people
17:20:28 <pkhuong> I wonder if using a lightweight process DSL would be accepted.
17:20:37 <fons> monochrom, I don't relly need to hide the parameter
17:20:47 <fons> I think I have it now
17:22:28 <dons> pkhuong: no, at least not continutation based ones.
17:22:42 <dons> (someone previously implemented such a strategy for a lisp entry, and it was removed)
17:22:52 <dons> has to be real rts-supported threads (but may be light or heavy threads)
17:23:53 <pkhuong> dons: that is arbitrary.
17:24:47 <dolio> Arbitrary describes the shootout pretty well. :)
17:26:29 <monochrom> I do not understand run.  It probably doesn't run.
17:26:53 <pkhuong> obviously, that's a problem with micro benchmarks that don't even describe a task.
17:27:27 <monochrom> cleanup has a problem because the data type is not "forall hd. Handle hd => CHandle { ... hHandle :: hd }"
17:27:50 <monochrom> I have also been wondering why the forall is inside not outside.
17:28:58 <sjanssen> dons: "The Ruthless, Cut-throat ByteString", nice :)
17:29:06 <dcoutts> heh, yeah
17:29:28 <mXconnor> fons: there you go
17:29:54 <dolio> monochrom: Yeah, doesn't hHandle have to return an arbitrary instance of Handle of the caller's choosing?
17:29:54 * lispy thinks the overhead of "doing nothing" is relevant
17:30:00 <fons> mXconnor, I think I don't really need to wuantify existentially
17:30:03 <fons> quantify
17:30:16 <fons> mXconnor, I'm fixing it now
17:30:59 <monochrom> I can hear someone screaming "why am I being chased after, even after I have changed nick to evade it!"
17:31:27 <fons> mXconnor, :) sorry bout it
17:33:53 <monochrom> Thanks dolio, that probably explains run.
17:35:40 <monochrom> run = run.hHandle   probably expands to:  run = run . (hHandle :: CHandle -> CHandle).  It has no polymorphism.
17:36:23 <dolio> Ah, that could be.
17:37:00 <fons> monochrom, uhm
17:37:53 <lisppaste2> fons annotated #30119 with "Not existential anymore" at http://paste.lisp.org/display/30119#2
17:37:54 <dons> pkhuong: yes its arbitrary. the shootout is arbitrary. it can be frustrating
17:38:19 <dons> they're not big on specs :)
17:38:26 <pkhuong> dons: Time to create a new standard, `CL++' ;)
17:38:35 <dons> heh
17:38:42 <pkhuong> now all the libraries are part of the rts!
17:38:46 <fons> monochrom, the problem is ... how to export to C ...
17:38:56 <dons> hehe.
17:39:05 <dons> see, we can't use Data.ByteString, for example, as an external library
17:39:09 <fons> beacuse the FFI doesn't accept type paramters
17:39:20 <dons> but the C and C++ guys happily use libgmp and pthreads and a private hashtable.c
17:39:24 <dons> its all very arbitrary
17:39:50 <dons> so we have to win with cunning and skill, and superior weapons
17:40:10 <pkhuong> i think that's partly why ~only CL newbies participate anymore.
17:41:10 <fons> monochrom, actually, there is something I don't really understand. Why simply "data CHandle hd =  ... " doesn't work? (knowing that "data Handle hd => CHandle hd = ..." )
17:41:25 <dons> the two main shootout guys are quite pro-FP though, I find. certainly they encourage the haskell community, and only disqualify us 1/4 times :)
17:41:46 <dons> sjanssen: speaking of which, i better check out your fasta code
17:42:09 <monochrom> I have to go.
17:44:48 <dons> ?google programming.reddit.com down?
17:45:03 <dons> ?bot
17:45:04 <lambdabot> search module failed: IRCRaised thread killed
17:45:04 <lambdabot> :)
17:45:14 <dons> http://programming.reddit.com
17:45:23 <dons> hmm. I think it might be down?
17:45:39 <pkhuong> reddit down, yeah.
17:45:45 <dons> if only they'd stuck with lisp, instead of switching to python
17:46:53 <psykotic> haha
17:46:54 <lispy> reddit was written in lisp?
17:47:19 <dons> yeah
17:47:25 <lispy> nice
17:47:48 <lispy> lisp is about as good as dynamic languages get
17:47:50 <pkhuong> originally. They then found it was unstable (rumour has it they didn't execute the CMUCL function that makes green threading work right) and switched, iirc.
17:48:11 <lispy> ah, CMUCL, say no more
17:49:12 * lispy uses SBCL pretty much exclusively when lisping
18:00:12 <dons> ?userrs
18:00:13 <lambdabot> Maximum users seen in #haskell: 270, currently: 233 (86.3%), active: 43 (18.5%)
18:06:07 <scodil> is there a way to get your own personal hoogle that indexes your own libraries? or some way to search all names in a module, rather than the by-the-first letter index that haddock makes?
18:07:29 <dons> yep
18:07:43 <dons> check the user's guide, you just run hoogle on your local code
18:08:39 <scodil> users guide for what?
18:08:58 <dons> hoogle
18:09:55 <lispy> " I'm hoping that if I hang out in the type-hackery 'hot zone' long
18:09:55 <lispy> enough I'll start emitting enough picoOlegs myself to solve simple
18:09:56 <lispy> problems. ;)
18:09:57 <lispy> "
18:10:32 <lispy> i wonder how Oleg feels about the jokes about his superior type ability?
18:10:43 <lispy> hopefully he finds them funny too
18:11:23 <dons> hopefully. :) he's remained (modestly) silent on his elevation to international unit of type hackery
18:12:36 <dons> oh nice, and I thought that reddit thread on 'write code, don't read it' was vaguely anti-haskell:  "I'm currently hacking Haskell now, largely because I read this article about how writing code is
18:12:41 <dons> better than reading about it, from reddit. I've been reading about Haskell this and Haskell that for
18:12:44 <dons> a while now, so I thought I better start hacking"
18:12:53 <dons> http://alangloria.blogspot.com/2006/11/okay.html
18:12:56 <lambdabot> Title: As L approaches Hack-Level, http://tinyurl.com/snbuc
18:14:04 <lispy> at the MIT AI lab, way back in the day they had a deragotory term for people that read about code too much without "doing" it enough
18:14:46 <lispy> the book "Hackers" by, iirc, stephen levy mentions it
18:14:52 <dons> hehe.
18:14:59 <dons> yeah, you definitely have to write.
18:15:07 <dcoutts> dons, around here, I'm a unit of the intensity of a fire
18:15:15 <psykotic> did they have a term for people who wrote too much code without thinking about what they were doing? :)
18:15:17 <dons> dcoutts: oh, interesting. and useful!
18:15:22 <dons> psykotic: hehe
18:15:32 <lispy> psykotic: heh
18:15:49 <Philippa_> dons: I definitely wish I wrote more actual code. For some reason people seem to think I'm worth talking to about how still though
18:16:07 <Philippa_> probably because I at least do a lot of thought experiments
18:16:14 <dons> good :)
18:16:16 <dcoutts> dolio, iirc, 1 miliduncan is the intensity of a fire that you can tolerate at a distance of 1 meter
18:16:38 * psykotic only has a few thousands lines of code in him a day and spends most of them at work
18:16:44 <dcoutts> or something, perhaps it was defined in terms of hogsheads and bushels
18:16:54 <psykotic> and that's why weekends are good, heh
18:16:58 <lispy> why do threads about debugging excite such personal and heated debates?
18:17:17 <dons> ?google 1000 joules in dcoutts per square metre
18:17:19 <lambdabot> No Result Found.
18:17:22 <dons> doh!
18:17:22 <dcoutts> lispy, because people have spent time getting frustrated ?
18:17:45 <dons> lispy: i feel vaguely trollish for suggesting the deprecated fromJust now
18:18:01 * dons must go wash his mouth out
18:18:01 <lispy> heh
18:18:06 <lispy> i want to quote you :)
18:18:26 <dons> i knew ndm would bite. bad dons.
18:18:35 <dcoutts> heh :-)
18:18:38 <lispy> dons: careful or you'll get banned by don....er..n/m
18:18:49 <dcoutts> lispy, that's easy @remember ...
18:19:15 <lispy> dcoutts:  i know :)
18:19:23 <lispy> i just don't have the heart to immortalize those words
18:19:25 <dons> i like Henning Thielemann's response though about moving error messages earlier
18:19:35 <dons> that captures exactly the intent
18:20:07 <dons> i'm not even sure if the pro-fromJust people even have a majority. hmm
18:20:23 <lispy> *shrug* I just think it's overkill to worry about fromJust
18:20:37 <dons> lispy: isn't there a darcs bug reported today about fromJust :)
18:20:42 <lispy> i have bigger fish to fry
18:20:51 <lispy> dons: yeah there have been many
18:21:01 <dons> perhaps there should be a fromJust audit..
18:21:04 <lispy> dons: and look at it this way, darcs has a special fromJust which reports the location
18:21:19 <lispy> dons: so if you want to know how useful that is, look at darcs :)
18:21:42 <dons> yeah, i saw that . very good
18:21:50 <lispy> dons: i was actually wondering about using Oleg's stuff in the darcs tree
18:22:06 <lispy> if it would find some bugs
18:22:26 <lispy> alas, i really need to work on darcsSim
18:22:40 <lispy> it's due soon and it's only about 20%
18:23:44 <dons> using Catch or HPC in the darcs tree might be a good idea
18:23:45 <lispy> i think fromJust makes the language just a tiny bit friendly to n00bies
18:23:46 * beelsebob_ notes that darcs still doesn't handle folder diffs any better than any other system
18:23:59 <dons> actually, darcs seems almost ripe for some good static analysis
18:24:02 <lispy> what is a folder diff?
18:24:12 <lispy> dons: yeah
18:24:22 <lispy> dons: but HPC isn't ready yet is it?
18:24:28 <lispy> same with Catch
18:24:35 <beelsebob_> lispy: well... if I change a file... darcs tells me "here are all the files you changed, would you like to put the changes in"
18:24:41 <beelsebob_> specifically, if I add some lines
18:24:43 <beelsebob_> it tells me
18:24:47 <beelsebob_> if I change a folder
18:24:53 <beelsebob_> e.g. by adding some files
18:24:55 <beelsebob_> it doesn't tell me
18:25:01 <beelsebob_> it relies on my remembering what I added
18:25:10 <dons> oh, I wonder if kosmikus and swiert's patch theory handes directories nicely?
18:25:13 <lispy> beelsebob_: have you seen 'darcs changes' ?
18:25:27 <beelsebob_> lispy: darcs changes?
18:25:28 <lispy> dons: this is more of a UI issue
18:25:36 <lispy> beelsebob_: lists the changes
18:25:45 <lispy> or maybe i meant whatsnew
18:25:46 <lispy> sorry
18:25:56 * beelsebob_ confused
18:26:02 <lispy> changes is the log file basically
18:26:08 <lispy> 'darcs what -l'
18:26:15 <lispy> or 'darcs what -ls'
18:26:18 <beelsebob_> but... why should I have to rememer that
18:26:30 <beelsebob_> I don't have to remember to look at logs when I add lines to a file
18:26:42 <beelsebob_> so why do I have to remember when I add files to a directory
18:26:49 <lispy> i didn't meant to say 'darcs changes'
18:26:57 <lispy> try 'darcs what -ls'
18:27:11 <beelsebob_> lispy: no - I want to try dracs record
18:27:28 <beelsebob_> darcs record should tell me "you added a file" in the same way as it tells me "you added some lines"
18:27:37 <lispy> it can
18:27:49 <beelsebob_> it doesn't though... how do I make it?
18:28:05 <lispy>  -l            --look-for-adds          In addition to modifications, look for files that are not boring, and thus are potentially pending addition
18:28:07 <heatsink> Is it possible to define a class synonym?
18:28:12 <lispy> that's from 'darcs record --help'
18:28:28 <dcoutts> heatsink, not really
18:28:30 <lispy> beelsebob_: and if you don't want to type it all the time you can change the default in ~/_darcs/defaults
18:28:37 <beelsebob_> ah, cool :)
18:29:07 <dons> $ grep fromJust * | wc -l
18:29:07 <dons>       86
18:29:07 <dons> $ grep fromMaybe * | wc -l
18:29:07 <dons>       13
18:29:07 <dons> $ grep maybe * | wc -l
18:29:09 <dons>      117
18:29:20 <lispy> dons: darcs-unstable?
18:29:27 <Excedrin> what's -s?
18:29:32 <lispy> Excedrin: summary mode
18:29:45 <dons> that's in 1.0.4, not unstable. btw, where's the custom fromJust kept?
18:29:55 <Excedrin> lispy: is that a new feature?
18:30:08 <lispy> Excedrin: been there since 1.0.3 at least, iirc
18:30:15 <lispy> Excedrin: which means at least a year
18:30:20 <lispy> dons: ah, well that's ancient!
18:30:26 <lispy> dons: it would be in C i imagine
18:30:28 <dons> true.
18:30:31 <dons> ok
18:30:39 * dons installs a new darcs
18:31:01 <dons> (i'm actually using 1.0.8, but don't have the src here)
18:31:06 <lispy> dons: impossible.h i think
18:31:17 <lispy> impossible.h:#define fromJust (\m_fromJust_funny_name -> case m_fromJust_funny_name of {Nothing -> bug ("fromJust error at "++__FILE__++":"++show (__LINE__ :: Int)++" compiled "++__TIME__++" "++__DATE__); Just x -> x})
18:31:21 <dons> oh my
18:31:41 <Excedrin> I don't see where -s is documented, it's not in darcs record --help
18:31:43 <dons> lispy: would you like to mention this on the fromJust thread ?
18:31:52 <dons> lispy: I think the use in darcs is an interesting insight
18:32:07 <dons> lispy: are there stats in the bug tracker of how many bugs reports are due to fromJust failing?
18:32:13 <lispy> sure, droudy has mentioned this in the past on haskell-cafe (that's where i leraned about it)
18:32:26 <lispy> dons: search the bugs.darcs.net for fromJust ?
18:32:47 * lispy tries
18:33:05 <lispy> i see 7
18:33:07 <dons> yep
18:33:07 <dons> a few come up
18:33:22 * lispy repsonds to thread
18:33:32 <dons> lispy: do you think you could just mention the fromJust bug count, and darcs .h response. i'm not sure what it means either way
18:33:37 <fons> why is the signature "Handle hd =>" necesary in the instantiation of (CHandle hd) in http://paste.lisp.org/display/30119#2 ? (it is already provided in the definition of CHandle)
18:33:48 <fons> wouldn't that be enough?
18:33:49 <dons> and perhaps include a count of how many fromJusts, fromMaybes and maybes are used?
18:33:54 <lispy> dons: yeah, i'll just give some numbers without opinion
18:34:03 <dons> yep.
18:34:15 <dcoutts> fons, it's not enough, let me find you the link...
18:34:30 <dons> lispy: I wonder if Neil can step up and check the fromJust's in darcs.
18:34:44 <dolio> fons: That's how data declarations work in Haskell 98. The dictionary isn't stored in the datatype.
18:34:50 <dons> if there's no prospect for a tool able to handle darcs' src use of fromJust, then I really do wonder about deprecating it
18:35:17 <fons> thanks dcoutts, then whats the point of restricting the parameter? simply semantic?
18:35:23 <dcoutts> http://permalink.gmane.org/gmane.comp.lang.haskell.glasgow.user/11192
18:35:26 <lambdabot> Title: gmane.comp.lang.haskell.glasgow.user, http://tinyurl.com/ylyhs4
18:35:28 <dcoutts> fons, ^^ see item 3
18:35:48 <dcoutts> fons, it just affects the type of the constructor
18:36:04 <dcoutts> the above is a thread on making it mean what you'd expect it to mean
18:36:38 <dcoutts> the H98 behaviour isn't very helpful
18:37:27 <SamB_XP> I say either fix it or remove it, the way it is know is only confusing
18:39:11 <fons> dcoutts, damn, that paramter is a pain in the ass to export the class functions to C
18:39:53 <SamB_XP> heh
18:45:28 <scodil> is there a binary of hoogle available for linux? google doesn't think so
18:46:01 <vincenz_> darcs get hoogle
18:46:01 <vincenz_> make
18:46:13 <vincenz_> or somesuch
18:46:13 <lispy> dons: i didn't know who to reply to so i replied to your original email
18:46:17 <scodil> yeah it depends on alot of stuff i don't have and don't want
18:46:18 <sjanssen> scodil: probably not, ndm doesn't like Linux ;)
18:46:57 * lispy is all out of batteries...cruse you wireles mouse!
18:47:13 <dons> thanks lispy
18:47:26 <dons> 1.0.9rc2 seems to run nicely on my openbsd box
18:47:35 <dons> at east, the repos are still 'darcs check'ing correctly
18:47:54 <lispy> cool, i think most of the unstability in darcs-unstable at the moment is either not on by default or only affects windows
18:48:20 <lispy> hashed inventories will be the next major feature as far as the data format goes
18:48:52 <lispy> droundy is giving a colloquium talk next monday at my school
18:49:08 <lispy> about verifying darcs patch theory using haskell
18:49:17 <lispy> it's the same one he gave at a conference or two
18:50:11 <dons> cool
18:51:15 <lispy> did my email work? i got a bounce
18:51:26 <lispy> i dont' hink i'm one of the glasgow lists
18:51:56 <sjanssen> lispy: I received it
18:52:05 <lispy> okay, thanks
18:53:02 <lispy> i think it would be cool if Oleg steps up and does something with the code
18:53:12 <lispy> he did at one point ask for code that uses fromJust
18:54:00 * SamB_XP thinks that unJust would be a more fun name for that
18:54:00 <dons> ah yes.
18:54:04 <dons> oh!
18:54:10 <dons> nice nic eidea
18:54:14 <SamB_XP> better for puns ;-)
18:54:33 <lispy> heh
18:54:59 <lispy> ?remember SamB [on the subject of fromJust] SamB_XP thinks that unJust would be a more fun name for that
19:01:57 <weitzman> let socialEvolution = unJust . aJust
19:07:38 <pzpz> hmm -- i'm trying to return a String via maybe monad, yet it's telling me it's expecting ()
19:08:44 <pzpz> let me paste.
19:08:55 <dons> please do :)
19:09:04 <dons> > return "foo" :: Maybe String
19:09:05 <lambdabot>  Just "foo"
19:09:11 <dons> > return "foo" :: IO String
19:09:13 <lambdabot>  <IO [Char]>
19:09:29 <dons> > return "foo" :: Either String String
19:09:31 <lambdabot>  Right "foo"
19:10:49 <lisppaste2> pzpz pasted "issue with return" at http://paste.lisp.org/display/30126
19:10:58 <psykotic> didn't know Either was a monad. so it just injects into the right component?
19:11:08 <pzpz> i'm still awful, so pardon the horrible code :)
19:11:08 <psykotic> @type Either
19:11:09 <lambdabot> Not in scope: data constructor `Either'
19:11:14 <psykotic> @kind Either
19:11:15 <lambdabot> * -> * -> *
19:11:29 <sjanssen> psykotic: yes
19:12:06 <psykotic> sjanssen, is there a common use case for this?
19:12:11 <heatsink> That's one thing that ghc could provide more helpful error messages on...
19:12:20 <sjanssen> psykotic: yes, errors with descriptions
19:12:25 <psykotic> ah right
19:12:47 <dons> ?type fail
19:12:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
19:12:51 <psykotic> i thought maybe there was a custom type for that
19:13:00 <dons> > fail "get out of here" :: Either String String
19:13:01 <lambdabot>  Left "get out of here"
19:13:07 <dons> > fail "get out of here" :: IO ()
19:13:09 <psykotic> dons: gotcha
19:13:09 <lambdabot>  <IO ()>
19:13:19 <dons> > fail "get out of here" :: Maybe ()
19:13:20 <lambdabot>  Nothing
19:13:32 <dolio> > mzero :: Either String String
19:13:34 <lambdabot>  Left ""
19:13:44 <psykotic> it seems odd to make fail part of the Monad type-class though, what am i missing?
19:14:02 <sjanssen> psykotic: it's to provide nice error messages on pattern match failures
19:14:21 <dons> yeah, but is also a little controversial
19:14:22 <sjanssen> you're right though, fail is often considered a wart
19:14:23 <dons> at least, back in the day
19:14:55 <dons> ?google monads fail ugly haskell
19:14:59 <lambdabot> http://www.nomaware.com/monads/html/meet.html
19:14:59 <lambdabot> Title: Meet the Monads
19:15:01 <dons> heh
19:15:06 <sjanssen> @undo do [x] <- someAction; return x;
19:15:06 <lambdabot> someAction >>= \ a -> case a of { [x] -> return x; _ -> fail ""}
19:15:14 <SamB_XP> I'd personally say "sure it doesn't make a whole lot of sense, but considering it has a default that works fine I don't see any reason why it shouldn't be there"
19:15:25 <sjanssen> @undo do xs <- someAction; return (head x)
19:15:26 <lambdabot> someAction >>= \ xs -> return (head x)
19:15:30 <psykotic> SamB, the default is just to call error?
19:15:33 <SamB_XP> and, really, in a *practical* way it does make sense
19:15:36 <dons> sjanssen: you seen @unpl ?
19:15:38 <SamB_XP> psykotic: yes
19:15:44 <dons> ?pl \f g x y z -> f (g x y z)
19:15:45 <lambdabot> (.) . (.) . (.)
19:15:52 <dons> ?unpl (.) . (.) . (.)
19:15:53 <lambdabot> (\ l b c f i -> l (b c f i))
19:15:59 <fons> sjanssen, now it seems to work ... but I'm facing almost the same problem as at the begining, how to export the class functions to C? (the FFI doesn't accept type parameters) see http://paste.lisp.org/display/30119#2
19:16:00 <dons> ?. pl unpl (.) . (.) . (.)
19:16:01 <lambdabot> (.) . (.) . (.)
19:16:25 <heatsink> @. unpl pl \f g -> g f 1 f
19:16:26 <lambdabot> (\ p -> ((\ f i -> f i 1) >>= \ a b c -> a c b) (\ l -> l p))
19:16:31 <heatsink> :)
19:16:43 <sjanssen> fons: don't you have to serialize to some type that C understands?
19:16:47 <dons> monad yourself up man
19:17:03 <psykotic> gimme some mo' nads
19:17:15 <SamB_XP> @. pl . djinn . type unpl (.) . (.) . (.)
19:17:17 <lambdabot> f = (.) . (.) . (.)
19:17:25 <dons> nice
19:17:26 <heatsink> @. unpl pl (\ p -> ((\ f i -> f i 1) >>= \ a b c -> a c b) (\ l -> l p))
19:17:27 <lambdabot> (\ p -> ((\ f i -> f i 1) >>= \ a b c -> a c b) (\ l -> l p))
19:17:31 <fons> sjanssen, no, I just need a pointer, then C will call some functions providing that pointer
19:17:39 <dons> @. type . unpl pl (\ p -> ((\ f i -> f i 1) >>= \ a b c -> a c b) (\ l -> l p))
19:17:41 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t2 -> t -> t3
19:17:41 <lambdabot>    Expected type: t
19:17:50 <SamB_XP> its too bad djinn sticks that "f =" in front...
19:17:55 <psykotic> did anyone here read that paper that tries to classify the kind of subtype lattices that can be represented faithfully with phantom types?
19:17:56 <dons> kpreid: you thinking about where the type errors are?
19:18:01 <dons> sjanssen: we could fix that...
19:18:03 * psykotic is trying to remember the title.
19:18:05 <dons> s/SamB/
19:18:20 <dons> psykotic: hmm. no. sounds intriguing..
19:18:29 <dons> does it have 'phantom' in the title?
19:18:29 <SamB_XP> we'd have to make it use cases instead...
19:18:46 <dons> we could just have it print expressions, the 'f' is arbitrary
19:19:09 <SamB_XP> dons: I know
19:19:10 <fons> sjanssen, wrappping it with a StablePtr is straightforward, the problem is the mandatory type parameter
19:19:12 <dons> djinn env $ ":set +sorted" <$> "f ?" <+> dropForall s
19:19:18 <kpreid> dons: dunno
19:19:20 <fons> the class signature
19:19:22 <psykotic> dons: let me find it, i think it's due to be posted in J. of F. P.
19:19:34 <sjanssen> fons: can you actually call StablePtr's as functions from C?
19:19:40 <sjanssen> that doesn't sound right to me
19:19:50 <SamB_XP> dons: or, I can see that the f is arbitrary
19:19:53 <dons> psykotic: you got an account on the haskell wiki? i'd be great to stick up papers you read, http://haskell.org/haskellwiki/Research_papers
19:19:56 <lambdabot> Title: Research papers - HaskellWiki, http://tinyurl.com/yx8sfs
19:19:59 <fons> sjanssen, I probably didn't express myself properly
19:20:00 <kpreid> dons: (I'm following other channels; please continue to name me if you have anything to say)
19:20:06 <dons> since currently its pretty much just me putting up papers there... :)
19:20:10 <dons> kpreid: ok.
19:20:16 <kpreid> dons: maybe one of the combinator definitions is wrong?
19:20:17 <dons> kpreid: i will name you!
19:20:19 <dons> kpreid: using your name
19:20:23 <dons> kpreid: ah o
19:20:25 <dons> k
19:20:28 <psykotic> dons: nope, i guess i'll sign up.
19:20:44 <dons> the more paper readers we have putting papers up, the better ! :)
19:21:00 <dons> to register: http://haskell.org/haskellwiki/?title=Special:Userlogin
19:21:02 <lambdabot> Title: Create an account or log in - HaskellWiki, http://tinyurl.com/yg7e4u
19:21:24 <dons> psykotic: http://haskell.org/haskellwiki/Research_papers/Type_systems#Phantom_types
19:21:25 <sjanssen> fons: how are you going to use the passed pointer in C?
19:21:26 <lambdabot> Title: Research papers/Type systems - HaskellWiki, http://tinyurl.com/yan24w
19:21:29 <SamB_XP> I want to read plastic!
19:22:03 <psykotic> fwiw, http://ttic.uchicago.edu/~fluet/research/phantom-subtyping/jfp06/jfp06.pdf
19:22:05 <lambdabot> http://tinyurl.com/yydmu5
19:22:21 <dons> ah nice.
19:22:35 <dons> psykotic: stick it up under the phantom type section, please?
19:22:39 <dons> for free karma points...
19:22:41 <psykotic> yeah i'm signing up atm
19:22:49 <dons> which will be tradable for lambda fuel in the future..
19:23:07 <fons> sjanssen, The C code won't touch it, It will be passed back to Haskell without being touched
19:23:13 <fons> it's a callback handle
19:23:14 <SamB_XP> so, java doesn't get any lambda fuel?
19:23:18 <SamB_XP> @karma java
19:23:19 <lambdabot> java has a karma of -12
19:23:26 <psykotic> haha
19:23:30 <MP0> java++
19:23:36 <MP0> @karma java
19:23:37 <lambdabot> java has a karma of -12
19:23:38 <SamB_XP> MP0: do NOT do that
19:23:41 <MP0> darnit!
19:23:42 <SamB_XP> @karma MP0
19:23:42 <lambdabot> MP0 has a karma of -1
19:23:48 <SamB_XP> it is bad for your karma
19:23:51 <MP0> lol
19:23:56 <MP0> roflmao
19:24:00 <fons> hahahaha
19:24:01 <MP0> lol
19:24:17 <SamB_XP> don't try to lower it, either.
19:24:26 <MP0> why not?
19:24:29 <dons> just don't mess with java. its bad for your health
19:24:31 <SamB_XP> I'm not sure if that will be bad for you or not ;-)
19:24:36 <chessguy> 'evening
19:24:51 <SamB_XP> at one point it was, for some reason, and I haven't tried it lately or looked at the code lately...
19:24:53 <MP0> I dunno, doesn't changing java ruin our referential transparency?
19:24:55 <dons> actually, i think lowering java is ok
19:24:57 <dons> ?karma
19:24:58 <lambdabot> You have a karma of 88
19:25:02 <SamB_XP> dons: it used to be
19:25:03 <dons> java--
19:25:08 <dons> ?karma
19:25:08 <lambdabot> You have a karma of 88
19:25:10 <SamB_XP> then for a while I think it wasn't...
19:25:11 <dons> ?karma java
19:25:12 <lambdabot> java has a karma of -13
19:25:15 <dons> :)
19:25:17 <dons> so all is well
19:25:18 <heatsink> paHAHAHAHA
19:25:21 <SamB_XP> okay, I guess it works properly now ;-)
19:26:04 * heatsink didn't see the other karma check
19:26:10 <psykotic> k, done
19:26:15 <dons> psykotic++
19:26:34 <fons> dcoutts, that dictionary problem is making me crazy, the mandatory type signature doesn't allow me to export the class functions to C which is something I really need
19:26:45 <SamB_XP> MP0++
19:26:52 <SamB_XP> @karma MP0
19:26:52 <lambdabot> MP0 has a karma of 0
19:27:03 * MP0 wipes sweat off of brow
19:27:05 <dcoutts> fons, you can't do that anyway
19:27:11 <fons> I don't get why the FFI doesn't allow type parameters (wrapped in pointers)
19:27:13 <dcoutts> fons, C exports need to be simple C types
19:27:25 <fons> dcoutts, you can wrap it in a pointer
19:27:37 <fons> and would work for me
19:27:39 <dcoutts> fons, in a StablePtr
19:27:40 <SamB_XP> what, no stable pointers to dictionaries?
19:28:00 <fons> dcoutts, yes
19:28:14 <SamB_XP> StablePointer (Show a) ;-)
19:28:34 <dcoutts> that sounds like a really bad idea
19:28:38 <SamB_XP> hehe
19:28:53 <SamB_XP> I think it would work in Core ;-)
19:29:14 <dcoutts> actually, so long as you would use it at the same type when you retrieve it, it should be ok
19:29:14 <dons> dcoutts: are we in a state that we should announce Hac?
19:29:27 <dons> dcoutts: or are we pending further confirmations on locations and so on?
19:29:27 <dcoutts> it doesn't need to pass the dictionary
19:29:41 <SamB_XP> dcoutts: hmm?
19:30:07 <dcoutts> dons, still pending, sorry, but it does look hopeful as Jeremy said he's happy to vouch for us with the numbers I described
19:30:22 <dons> ok. good. what numbers was that, <= 20 or so?
19:30:27 <dcoutts> dons, yep
19:30:33 <dons> so we wait for Jeremy, then confirm the room
19:30:38 <psykotic> @type printf
19:30:40 <lambdabot> forall r. (PrintfType r) => String -> r
19:30:55 <dcoutts> dons, well actually we wait for me to bug the admin staff on Monday :-)
19:30:59 <dons> ok
19:31:00 <dons> good
19:31:11 <dons> i wonder what we shall do if more than 20 people want to visit
19:31:22 <dons> perhaps limit to active devs or some such
19:31:25 <dons> if needed
19:31:28 <dcoutts> aye
19:31:39 <dons> (the openbsd guys do this, invitation only to the hackers@ list)
19:31:51 <dcoutts> or ask for a little description of what they hope to hack on
19:31:51 <SamB_XP> charge admission!
19:31:55 <psykotic> what's the trick behind printf that lets it fake variadic-ness?
19:31:57 <dons> dcoutts: good idea.
19:32:08 <dons> psykotic: recursive typeclsas instances that suck in extra args
19:32:09 <SamB_XP> psykotic: it doesn't fake it
19:32:14 <dons> ?type printf
19:32:16 <lambdabot> forall r. (PrintfType r) => String -> r
19:32:17 <SamB_XP> it actually implements it
19:32:31 <dons> ?type printf "%c%c" 'x'
19:32:32 <lambdabot> forall t. (PrintfType (Char -> t)) => t
19:32:34 <dons> ?type printf "%c%c" 'x'  'y'
19:32:35 <lambdabot> forall t. (PrintfType (Char -> Char -> t)) => t
19:32:39 <dons> see how the constraint builds up?
19:32:41 <psykotic> ahh i see
19:32:50 <dons> ?type printf "%c%c" 'x'  'y' :: String
19:32:51 <lambdabot> String :: String
19:32:52 <psykotic> that's clever
19:32:54 <dons> ?type printf "%c%c" 'x'  'y' :: IO String
19:32:56 <lambdabot> IO String :: IO String
19:33:14 <heatsink> > printf "%d" 4
19:33:15 <lambdabot>  Add a type signature
19:33:21 <SamB_XP> that is mostly because GHC can't know that there is only one way to go, I suppose?
19:33:21 <heatsink> > printf "%d" 4 :: String
19:33:23 <lambdabot>  Add a type signature
19:33:28 <dons> heatsink: (4 :: Int)
19:33:31 <heatsink> > printf "%d" (4 :: Int) :: String
19:33:32 <lambdabot>  "4"
19:33:35 <psykotic> so it's basically like a stream type?
19:33:43 <dons> hmm?
19:33:56 <heatsink> > printf "%d" "error" :: String
19:33:57 <lambdabot>  Exception: Printf.printf: bad argument
19:33:58 <dons> we should add a Num a => PrintfType a
19:34:16 <heatsink> cool
19:34:24 <SamB_XP> that would need an -fannoying-instances flag
19:34:29 <dons> I wonder if we can tweak this:
19:34:31 <dons> instance (IsChar c) => PrintfArg [c] where
19:34:32 <dons>     toUPrintf s = UString (map toChar s)
19:34:32 <dons> instance PrintfArg Int where
19:34:32 <dons>     toUPrintf i = UInt i
19:34:47 <dons> yeah, oh well.
19:35:00 <lispy> dons: the thing to remember about Num a is that' 'a' isn't always a number :)
19:35:05 <sjanssen> arrgh, the ugly IsFoo pops up again
19:35:06 <dons> :)
19:35:16 <SamB_XP> would be nice if all of PrintfArg were exported, though, I think.
19:35:18 <dons> yeah, sjanssen, that's lennart's style :)
19:35:23 <SamB_XP> or at least enough to implement it.
19:35:28 <sjanssen> is that problem slated for fixing in Haskell'?
19:35:37 <sjanssen> I've tried to find a ticket before, but I wasn't able
19:35:41 <dons> Char c vs IsChar c ?
19:35:44 <sjanssen> I don't even know what to call the problem
19:35:49 <dons> (like IsString s?)
19:36:08 <SamB_XP> as opposed to just writing an instance for String directly
19:36:13 <sjanssen> dons: no, I'm talking about the fact that "instance SomeClass [Char]" isn't valid Haskell
19:36:20 <dons> ah
19:36:35 <dons> I think that's under consideration, surely.
19:36:50 <sjanssen> if it doesn't break things, it should absolutely be adopted
19:37:12 <SamB_XP> I think it can only break things if you use it
19:37:19 <lispy> well, isn't realizing that [a] is a subtype of [b] when a is a subtype of b, undecidable in general?
19:37:33 <SamB_XP> and in those cases it is your (or a library author's) fault for not thinking things through properly...
19:37:50 <Philippa_> lispy: what's your value of "in general"?
19:38:02 <Philippa_> also, mutability or otherwise makes a big difference
19:38:04 <fons> I give up, I'll remodel it doing something else
19:38:17 <SamB_XP> [] doesn't support mutation...
19:38:17 <lispy> Philippa_: it's more of a question really...i think i heard my OO prof say this recently in class
19:38:21 <sjanssen> lispy: well, I imagine that the type checker will disallow "T a" instances when there is an instance of form "T U"
19:38:56 <sjanssen> shouldn't that be sufficient?
19:38:56 <Philippa_> in general, there's mutability and thus you can't do it
19:39:11 <dons> fons, are you trying to create a bounded polymorphic ffi function?
19:39:15 <dons> is that even posisble?
19:39:15 <SamB_XP> remind me to never program in general
19:39:21 <SamB_XP> it sounds like a really sucky language
19:39:29 <SamB_XP> ... rather like Java, in fact...
19:39:30 <lispy> sjanssen: i don't know if it's sufficient because i'm not sure what it means :)
19:39:31 <Philippa_> a mutable container needs to have the item type variable invariant
19:39:46 <fons> dons, no it doesn't seem so
19:40:01 <dons> since how would the C side deal with that? :)
19:40:04 <sjanssen> lispy: where T is some fixed type constructor, C is some fixed type, and a is a variable
19:40:13 <MP0> Why does everyone hate java?
19:40:23 <dons> there's a bit of a type system over there, even if it is a bit like: fromJust Nothing = arbtrrary  -- :)
19:40:29 <SamB_XP> MP0: why is java so hateworthy?
19:40:29 <lispy> Philippa_: i didn't really get why he said it because scala can infer that exact instance
19:40:42 <fons> is there a way to check whether a type belongs to certain typeclass?
19:40:50 <dons> ?instances Monad
19:40:50 <MP0> Good question!
19:40:52 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:40:56 <SamB_XP> fons: try to use one of the methods on it
19:40:59 <dons> in ghci, :info Type should tell you something like that
19:41:03 <pzpz> is there a prelude method for getting the first/last item in a tuple?
19:41:16 <dons> > fst (1,2)
19:41:17 <lambdabot>  1
19:41:19 <dons> > snd (1,2)
19:41:20 <lambdabot>  2
19:41:23 <SamB_XP> pzpz: only if it is a pair, though
19:41:23 <sjanssen> fons: you can constrain functions to only work on instances of a class
19:41:37 <pzpz> dons, SamB_XP: that's just what i was looking for, ty.
19:41:43 <SamB_XP> but, probably most tuples are pairs, so that should do nicely ;-)
19:41:45 <lispy> pzpz: try this next time
19:41:49 <lispy> ?hoogle (a,b) -> a
19:41:50 <sjanssen> but you can't generally do something like "if T implements C then .. else .."
19:41:50 <lambdabot> Prelude.fst :: (a, b) -> a
19:41:51 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
19:41:51 <lambdabot> Prelude.snd :: (a, b) -> b
19:42:03 <lispy> pzpz: note that the first hit is fst!
19:42:13 <fons> sjanssen, yes, but I'm facing the "plugin with optional functions" problem
19:42:29 <fons> sjanssen, and that doesn't help
19:42:33 <lispy> pzpz: and lambdabot responds to /msg or you can find hoogle on the web
19:42:46 <SamB_XP> fons: you should use *one* typeclass
19:43:00 <SamB_XP> and give it default implementations of those functions...
19:43:01 <fons> SamB_XP, that was my first attemp
19:43:04 <fons> attempt
19:43:28 <fons> SamB_XP, but then .. I ended up facing the type parameter problem
19:43:43 <SamB_XP> have you seen hs-plugins, btw?
19:44:06 <fons> SamB_XP, see http://paste.lisp.org/display/30119 if you are curious
19:44:40 <sjanssen> fons: can you paste any of your attempts with StablePtr?
19:46:12 <fons> sjanssen, Igave up, but I'll redoit again, give me a sec
19:46:52 <pzpz> lispy: gotcha.
19:48:06 <lispy> pzpz: we don't mind the questions, but we also like to make sure people have the tools to help themselves
19:48:20 <sjanssen> fons: you shouldn't have any trouble with having type parameters to StablePtr, it's designed to be an opaque reference passed to C functions
19:48:52 <sjanssen> and you can even cast to Ptr ()
19:48:54 <fons> sjanssen, I know, the problem are the type class signatures
19:49:31 <sjanssen> you'll have to instantiate the type parameters when you construct the StablePtr
19:53:08 <pzpz> lispy: i understand, thanks :)
19:53:16 <pzpz> gotta run, take care all!
19:54:16 <sjanssen> fons: actually, is there any reason you're using a type class in the first place?
19:55:25 <dons> yeah, what's the use csae?
19:55:47 <fons> In my first (successful) attempt I used existentialy quantified records ... and it works ... but I wanted to make the public part of the library as standard as possible
19:55:56 <fons> that's why I decided to use a class
19:56:12 <sjanssen> it might be easier to create a data type that has the activate, close, deactivate, etc.
19:56:24 <sjanssen> you wouldn't even need existentials, as far as I can tell
19:56:49 <fons> the first version can be seen here http://www.mail-archive.com/haskell-cafe@haskell.org/msg17620.html
19:56:51 <dons> mm. reify your own dictionary, you mean?
19:56:51 <lambdabot> Title: [Haskell-cafe] RFC and Announcement: HLADSPA, LADSPA for Haskell, http://tinyurl.com/yg5ceo
19:57:00 <sjanssen> oh wait, maybe the type of run prevents you from doing that
19:57:15 <sjanssen> fons: what is the purpose of the hd returned from run?
19:57:23 <fons> sjanssen, I posted my problem to haskell-cafe, but I must have formalated it in a really messy way cause nobody answered :(
19:58:02 <fons> sjanssen, the handle is changed by run
19:58:22 <fons> sjanssen, it's a inmutable change right now
19:58:25 <sjanssen> does the old handle become invalid?
19:59:17 <fons> sjanssen, the handler is inmutable right now ... so yes I think so
19:59:43 <sjanssen> hmm
20:00:21 <fons> sjanssen, the problem is explained in a better way in the mailing list post whose link I pasted here
20:00:53 <fons> sjanssen, I'm facing 3 problems
20:00:59 <fons> 1 heterogeneous lists
20:01:11 <Adamant> lambdabot, what is the meaning of life?
20:01:14 <fons> 2 void * types in C
20:01:34 <MP0> > 42
20:01:36 <lambdabot>  42
20:02:55 <sjanssen> fons: we may be able to fix the approach used in the first approach you posted on lisppaste
20:02:56 <fons> 3 the plugin should statically inform of wether it makes use of activate and deactivate (now it does it dynamically)
20:03:38 <sjanssen> I think if we make the optional functions take a phantom type parameter it will work
20:04:49 <fons> you mean creating a multiparametric class?
20:05:43 <sjanssen> no, we just make activate :: hd -> Maybe (hd -> Whatever)
20:06:03 <sjanssen> Whatever is me being to lazy to look up what the rest of the type is ;)
20:06:28 <sjanssen> then hd is an artificial argument to select the correct instance
20:06:33 <sjanssen> the first hd
20:07:40 <fons> sjanssen, well, then it would be just simpler and more elegant to make the functions default to do nothing, activate :: hd -> IO();activate _ = return ()
20:07:58 <sjanssen> that isn't a problem?
20:09:02 <sjanssen> I thought these optional functions were important
20:09:16 <fons> right now that's pretty much what is done
20:10:09 <fons> sjanssen, activate and deactivate in the C code are included with everything else in the same struct
20:10:22 <sieni> morning
20:10:41 <sjanssen> fons: so what was the point of the optional functions?
20:11:11 <sjanssen> can you make the C code not run them somehow, and you want performance gains?
20:11:45 <fons> sjanssen, please have a look at http://www.ladspa.org/ladspa_sdk/ladspa.h.txt
20:11:54 <fons> sjanssen, yes, that is the point
20:12:54 <fons> the thing is that in C ...all the functions (poiinters) are included in the same struct and some of them can be omitted
20:13:05 <fons> so that they are not called
20:13:19 <sjanssen> so the C will check whether they're NULL
20:13:31 <fons> sjanssen, yes
20:13:41 <sjanssen> okay, one more option:
20:13:46 <fons> sjanssen, the problem is that in my model the descriptor is splitted
20:13:59 <sjanssen> hasActivate :: hd -> Bool; activate :: hd -> IO ()
20:14:14 <ben23> how can I run a function until a list reaches a certain length ?
20:14:19 <fons> and there is now way to check if they are implemented until instantiate is called
20:14:42 <sjanssen> the default implementation for hasActivate can be const True, and activate can be const (return ())
20:14:42 <fons> sjanssen, thought about that too, but didn't find a way to make it type consistent
20:15:40 <sjanssen> yes, that will be a problem
20:16:14 <fons> sjanssen, didn't find a way which didn't have inconsistencies
20:16:29 <sjanssen> > sum (take 10 [1..]) -- that is one way ben23
20:16:30 <lambdabot>  55
20:18:33 <ben23> sjanssen something like while length xs < 5 run_command
20:19:17 <sjanssen> ben23: are you doing this in some sort of monad?  Otherwise terminology like "while" and "run_command" don't really apply
20:19:59 <ben23> sjanssen no, I gave the while example because I am new in haskell
20:20:12 <sjanssen> okay
20:20:48 <sjanssen> so you're writing some function that processes a list element by element, but you want to stop when you've processed a certain number of elements?
20:21:12 <ben23> yes
20:21:42 <SamB_XP> take n . f
20:21:56 <sjanssen> okay, let's implement sumN :: Integer -> [Integer] -> Integer
20:22:04 <SamB_XP> oh.
20:22:14 <SamB_XP> f . take n, then ;-)
20:22:37 <sjanssen> ie, a function that computes the sum of the first n numbers in a list.  Is this similar to what you want to do?
20:22:43 <ben23> I still have to jump to the docs to see what that does :)
20:23:00 <ben23> I want to get the first n numbers of the list
20:23:13 <sjanssen> ben23: you want take then ;)
20:23:21 <sieni> > take 7 [1..]
20:23:22 <lambdabot>  [1,2,3,4,5,6,7]
20:23:26 <sjanssen> @docs Data.List
20:23:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
20:23:46 <sjanssen> ben23: take is described there
20:24:03 <ben23> that is not the problem :)
20:24:09 <eviltwin_b> what might not be described there, but instead taken for granted, is that haskell is lazy
20:24:19 <ben23> I want to run a function until list xs has n elems in it
20:25:18 <eviltwin_b> so you can describe an open-ended computation, but haskell will only evaluate the minimum necessary in context.  so the "take" examples are being passed an infinte list, but haskell never tries to generate that infinite ist because take imposes a limit on the evaluation
20:25:45 <SamB_XP> @djinn Either x (Not x)
20:25:46 <lambdabot> -- f cannot be realized.
20:25:51 <SamB_XP> huh.
20:25:56 <SamB_XP> @djinn Not (Either x (Not x))
20:25:56 <lambdabot> -- f cannot be realized.
20:26:02 <SamB_XP> @djinn Not (Not (Either x (Not x)))
20:26:03 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
20:26:06 <eviltwin_b> so if you apply take to the result of your comp[utation, haskell will lazily clamp ther computation when take is satisfied
20:26:20 <Excedrin> what do you want to do differently when the list has fewer than n elems? (return some default value, evaluate a different function, return Nothing?)
20:26:42 <eviltwin_b> even if your computation is described in an open-0ended way (say, processing an infinite list)
20:27:01 <ben23> yes, the function would compute an infinite list
20:27:45 <ben23> let me dig up an example
20:28:18 <dons> > fix ((1:) . scanl (+) 1) -- for example, is infinite
20:28:19 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:28:29 <dons> > take 10 $ fix ((1:) . scanl (+) 1) -- isn't
20:28:31 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
20:28:51 <dons> haskell will just evaluate as much as you demand
20:29:14 <dons> leaving it to worry about the stopping conditions, and letting you think about more interesting problems than when to stop evaluating a list
20:29:57 <SamB_XP> ah.
20:30:19 <SamB_XP> type Not a = a -> Void, huh?
20:30:57 <ben23> how do I look up scanl on the bot ?
20:31:07 <SamB_XP> @hoogle scanl
20:31:08 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
20:31:09 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
20:31:31 <sjanssen> scanl is a bit of an advanced function
20:31:42 <Excedrin> @docs Prelude
20:31:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
20:31:52 <dons> ?docs Data.List
20:31:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
20:32:02 <sjanssen> you're probably better off writing your code without the abstract combinators, for learning purposes
20:32:15 <ben23> @hoogle fix
20:32:16 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
20:32:16 <lambdabot> Control.Monad.Fix :: module
20:32:16 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:32:35 <dons> yeah, there's no need to worry about fix or scanl yet
20:32:46 <dons> just write your infinite list generator, and take as many elements as you need, with take
20:32:52 <dons> > [1..]
20:32:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:32:58 <dons> > map (^2) [1..]
20:33:00 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
20:33:04 <dons> > take 17 $ map (^2) [1..]
20:33:05 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289]
20:33:09 <ben23> ok, I'll try that
20:33:52 <dons> (there's a good reason perl and python have lazy lists now)
20:34:54 <sjanssen> dons: an inferiority complex?
20:35:17 <SamB_XP> to implement parsec with?
20:35:36 <Excedrin> duh, because they keep getting closer to Lisp!
20:35:48 <dons> a compulsion to steal features, and then implement them half-baked?
20:35:50 <SamB_XP> since when does lisp have lazy lists?
20:36:01 <sjanssen> Haskell, why do you have such lazy lists?  Why, the better to implement Parsec, my dearie!
20:36:02 <SamB_XP> I actually implemented lazy lists for Slate...
20:36:08 <SamB_XP> to implement parsec with...
20:36:20 <eviltwin_b> heh
20:36:25 <SamB_XP> but I got bored or ran out of free time
20:36:27 <ben23> I got it, kinda
20:36:38 <SamB_XP> so didn't get too far with the Parsec implementing...
20:36:41 <eviltwin_b> actually, perl added them back when to reduce the pain of for $i (1..100000) :)
20:36:43 <ben23> it works, but I don't think it's the best way to do it
20:36:55 <sjanssen> @where paste
20:36:56 <lambdabot> http://paste.lisp.org/new/haskell
20:37:04 <dons> eviltwin_b: yeah, once you have foreach (i.e. map), you better have lazy lists
20:37:08 <ben23> I just need to remind myself of lazy eval, I'm just not used to it
20:37:10 <dons> strictness just isn't right for some problems
20:37:14 <sjanssen> ben23: if you'd like, #haskell is always willing to golf down some code
20:37:54 <dons> still, should be able to write this in perl:   take 10 ("$x" for (1..)) ; -- no?
20:38:06 <SamB_XP> is that what "hugs" is for? golfing?
20:38:21 <lisppaste2> ben23 pasted "Paste1" at http://paste.lisp.org/display/30129
20:38:24 <eviltwin_b> perl5 doesn;t have infinite lists
20:38:25 <sjanssen> is hugs an acronym?
20:38:38 <dons> eviltwin_b: but in perl6, how'd I do that?
20:38:43 <SamB_XP> isn't it "haskell users" something-or-other "system"?
20:38:58 <dons> Haskell User's Gofer System
20:39:00 <SamB_XP> maybe with some kind of an apostrophe in there
20:39:08 <SamB_XP> dons: oh. Gofer, not golfing?
20:39:14 <sjanssen> ben23: you can remove the 0 case for fun
20:39:15 <dons> noot golfing.
20:39:23 <sjanssen> > 1/2^0
20:39:25 <lambdabot>  1.0
20:39:29 <eviltwin_b> it does but I don't recall the syntax off the top of my head (only started poking at pugs 2 weeks ago...)
20:39:40 <eviltwin_b> I think 1..*
20:39:41 <ben23> sjanssen true :)
20:39:50 <ben23> sjanssen how about test though ?
20:40:05 <dons> > take 10 (map (\n -> 1/2 ^ n) [1..])
20:40:06 <lambdabot>  [0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.953125e-3,...
20:40:22 <dons> ?pl \n -> 1/2 ^ n
20:40:23 <lambdabot> (1 /) . (2 ^)
20:40:37 <ben23> what does ?pl do ?
20:40:51 <dons> it refactors the code to a  more obfuscated form :)
20:41:01 <sjanssen> ben23: if you don't mind the typing, you can just write "take n (map f [0..]) wherever you need it
20:41:16 <SamB> dons: it didn't work this time
20:41:21 <dons> > take 5 . map ((1 /) . (2 ^)) $ [1..]
20:41:22 <lambdabot>  [0.5,0.25,0.125,6.25e-2,3.125e-2]
20:41:35 <sjanssen> ben23: this code looks good, esp. for a newbie
20:41:40 <SamB> dons: that is the way I actually write things like that
20:41:45 <ben23> sjanssen thanks
20:41:53 <dons> ben23: yeah, I agree with sjanssen. looks fine.
20:41:55 <SamB> on purpose
20:42:02 <dons> ?pl test f n = take n ( map f [0..] )
20:42:02 <lambdabot> test = flip take . flip map [0..]
20:42:08 <dons> too many flips :)
20:42:12 <sjanssen> @hoogle recip
20:42:13 <lambdabot> Prelude.recip :: Fractional a => a -> a
20:42:19 <Excedrin> why doesn't 'head $ reverse $ reverse [1..]' work in Haskell?
20:42:32 <dons> um...
20:42:37 <ben23> I just felt that mapping [0..] might be a quick hack, but lazy eval wins :)
20:42:37 <sjanssen> Excedrin: because reverse returns the last element of a list first
20:42:45 <SamB> Excedrin: have you ever tried to reverse an infinite list?
20:42:46 <dons> it would if (reverse . reverse) had a rewrite rule to remove it
20:42:54 <sjanssen> and it takes a *really* long time to get the last element of an infinite list
20:43:07 <ben23> how long ?
20:43:08 <ben23> :)
20:43:21 <sjanssen> ben23: I've had a program trying to do that for the last 3 years
20:43:28 <Excedrin> then why isn't reverse lazy?
20:43:29 <sjanssen> so at least 3 years
20:43:38 <sjanssen> but I think it might be getting close to finishing
20:43:43 <SamB> ben23: well, pull out your notebook. that new one you got, with all the blank leaves -- for you shall need them all!
20:43:45 <eviltwin_b> how do you lazily return the last element of an infinite list?
20:44:04 <Excedrin> you don't return it since it's not needed
20:44:06 <sjanssen> Excedrin: it can't be, you have to touch every cons cell to return a single cons cell
20:44:20 <SamB> sjanssen: you haven't run out of swap yet?
20:44:21 <eviltwin_b> only if something is smart enough to realize that rever . reverse is a no-op
20:44:38 <eviltwin_b> *reverse
20:44:42 <sjanssen> SamB: nah, the program was last [1 :: Int ..]
20:44:49 <SamB> sjanssen: ah
20:44:52 <SamB> heh
20:45:03 <SamB> you are really still running that???
20:45:08 <SamB> that isn't an infinite list...
20:45:20 <dons> eviltwin_b: here you go:
20:45:21 <SamB> > last [1::Int ..]
20:45:21 <dons> {-# RULES
20:45:21 <dons> "reverse.reverse/id" reverse . reverse = id
20:45:21 <dons>   #-}
20:45:22 <dons> main = print . head . reverse . reverse $ [1..]
20:45:25 <lambdabot> Terminated
20:45:29 <sjanssen> SamB: oh, is enumFrom actually smart enough to stop?
20:45:30 <dons> $ ./a.out
20:45:30 <dons> 1
20:45:40 <Excedrin> dons++
20:45:57 <dons> $ ghc -fglasgow-exts -ddump-simpl-stats A.hs
20:46:03 <dons> 1 RuleFired
20:46:03 <dons>     1 reverse.reverse/id
20:46:03 <sjanssen> > [maxBound :: Int ..]
20:46:05 <lambdabot>  [2147483647]
20:46:20 * sjanssen goes to review his old program
20:46:23 <lispy> > last [1::Int16]
20:46:24 <lambdabot>  1
20:46:26 <lispy> > last [1::Int16..]
20:46:27 <lambdabot>  Parse error
20:46:30 <lispy> > last [1::Int16 ..]
20:46:32 <lambdabot>  32767
20:46:36 <SamB> sjanssen: probably it actually used Integer
20:46:42 <lispy> > last [1::Int8 ..]
20:46:44 <lambdabot>  127
20:46:45 <SamB> that doesn't have such a pathetic upper bound
20:47:01 <sjanssen> SamB: probably
20:47:03 <lispy> or it could have used Int64
20:47:14 <eviltwin_b> dons: yes, my point is that the compiler doesn't do that kind of meta-analysis by itself to realize that reverse is its own inverse so (reverse . reverse) can be eliminated, unless you tell it to.
20:47:35 <SamB> for one thing... it isn't QUITE
20:47:37 <eviltwin_b> that kind of meta-analysis is Hard for a compiler to do by itself
20:47:48 <SamB> especially when the results aren't quite true ;-)
20:48:00 <dons> right. hence ghc comes with an extensible optimisation system, via user-supplied term rewrite rules
20:48:06 <dons> fun for the whole family
20:48:07 <SamB> or have side conditions that the compiler won't be able to verify, or that flat-out aren't fulfilled
20:48:14 <dons> for when you're smarter than the compiler
20:48:20 <Excedrin> how are infinite lists represented in Haskell?
20:48:32 <eviltwin_b> conceptually everything is a computation, not a value
20:48:34 <lispy> Excedrin: same way they would be in other languages :)
20:48:36 <SamB> Excedrin: finite lists with thunks for tails
20:48:50 <sjanssen> your mom has a thunk for a tail
20:49:06 <lispy> ?remember sjanssen your mom has a thunk for a tail
20:49:29 <Adamant> a thunk is a function that generates more data, in this case?
20:49:40 <Excedrin> I wonder if Oz/Prolog style "difference lists" would work better, I guess it wouldn't make it easier to notice that reverse . reverse is a no-op
20:49:42 <SamB> ... something like that...
20:49:44 <eviltwin_b> (the compiler can be expected to optimize things sensibly for the most part, so ==SamB)
20:49:50 <sjanssen> Adamant: it's a value that's waiting to be evaluated
20:49:51 <lispy> Adamant: a think is a suspended computation
20:49:56 <Adamant> ah, ok
20:49:57 <lispy> er thunk
20:50:32 <SamB> it tends to be represented similarly to a function, iirc...
20:50:47 <eviltwin_b> lazy eval means when a value is needed it (cenceptually) iterates the computation to produce the next value
20:50:49 <SamB> but it doesn't particularly want arguments
20:51:07 <SamB> in fact, I guess it won't take arguments...
20:51:16 <SamB> in GHC's implementation...
20:51:20 <eviltwin_b> no, this isn't Icon :)
20:51:40 <eviltwin_b> (you want real head-teisting, go look at co-expressions that take arguments)
20:51:46 <eviltwin_b> *twisting
20:52:02 <SamB> oh, well, what if I had a thunk that would evaluate to a function?
20:52:51 <monochrom> (map . f) is a thunk that would evaluate to a function.
20:52:53 <Excedrin> so, does the thunk store state? which index to evaluate next or something?
20:52:55 <SamB> in some frameworks, it would need to be okay for you to pass arguments to that, wouldn't it?
20:53:07 <SamB> Excedrin: it is just a closure
20:53:22 <sjanssen> Excedrin: no indexes, thunks aren't specific to lists
20:53:23 <SamB> that holds some variables and has some code
20:53:33 <Adamant> http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem
20:53:39 <lambdabot> Title: A type-based solution to the "strings problem": a fitting end to XSS and SQL-inj ..., http://tinyurl.com/uv94m
20:53:50 <Adamant> I thought this was a really nice use of Haskell.
20:54:10 <SamB> it does sound pretty nice
20:54:23 <Excedrin> sjanssen: in the context of infinite lists...
20:54:46 <Adamant> I am using PHP in one of my college classes and making sure there are no code injection possibilities is a pain in the ass.
20:54:47 <SamB> Excedrin: thunks in a haskell implementation are general
20:56:05 <lispy> Adamant: yeah, you need to explain to others, "Why should we do this when a machine can do it correctly in less than a minute for our whole code base?"
20:56:07 <SamB> I thought the main problem was lack of EDSLs for database queries, though
20:56:38 <SamB> not some mysterious "strings problem"
20:57:04 <SamB> hmm, should be in bed I think...
20:57:31 <Adamant> lispy, that's true. but look at how many people still use C and C++ inappropriately, i.e. using it where security is needed and high performance is not
20:57:58 <SamB> since when is C particularly good for performance anyway?
20:58:08 <SamB> anyway, bed...
20:58:17 <lispy> SamB: compared to the average language it's quite performance minided
20:58:20 <lispy> minded*
20:58:29 <Adamant> SamB, there is a sort of EDSL now for PHP/MySQL DB work
20:58:30 <SamB> lispy: but only for really small things
20:58:49 <SamB> bye peoples!
20:58:55 <Adamant> :)
20:58:55 * SamB goes to bed now
20:58:56 <lispy> SamB: yeah, all of C's primitive stuff is optimized, but you can still write slow software if you want to :)
20:58:56 <eviltwin_b> the good thing about C is that it lets you get quite close to the hardware.
20:59:00 <lispy> SamB: night!
20:59:06 <eviltwin_b> the *bad* thing about C is that it lets you get quite close to the hardware.
20:59:08 <Adamant> you can write slow software in any language
20:59:14 <ben23> is the logs website written in haskell ?
20:59:15 <Excedrin> ok, so when you take the next unevaluated element from an infinite list, what happens? it evaluates the thunk, then what?
20:59:33 <sjanssen> ben23: nah, it's run by lisp guys
20:59:38 <lispy> Excedrin: the tail of the list is another thunk!
20:59:40 <dons> it evaluates it to weak head normal form, and you continue on your way
20:59:56 <ben23> sjanssen can you create stuff like that in haskell ?
20:59:59 <Adamant> eviltwin_b, "All the things about Windows that are terrible are typically the things that make it great" - Shellcoder's Handbook
21:00:00 <jdev> C's been fast since compilers got good enough that most people didn't need to write assembly, but won't be so fast once highly parallel machines take over the planet as promised.
21:00:11 <sjanssen> ben23: sure you could
21:00:13 <jdev> As I understand it.
21:00:18 <dons> take 2 [1..] --> <thunk> --> (1 : <thunk>) --> (1 : 2 : <thunk>) -- [1,2]
21:00:28 <dons> jdev: that's the plan, yeah
21:00:29 <ben23> interesting
21:00:30 <sjanssen> we've got HTML tools, HTTP stuff, all the necessary components
21:00:56 <Excedrin> ya, I follow that, but where do the new thunks come from? what goes into their environment
21:01:19 <sjanssen> ben23: you could write that in pretty much any programming language, with varying amounts of effort
21:01:44 <lispy> ben23: what is it that you want to write?
21:01:48 <dons> jdev: http://www.cse.unsw.edu.au/~chak/papers/CLPKM06.html beating C already :)
21:01:50 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/yyj2ur
21:02:00 <dons> and more info http://www.haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency#Parallel_Haskell
21:02:03 <lambdabot> Title: Research papers/Parallelism and concurrency - HaskellWiki, http://tinyurl.com/yybhes
21:02:17 <Excedrin> HAppS makes it easy to write web apps in Haskell, I think there are a few others, but I have no experience with them
21:02:43 <lispy> ben23: we were able to put lambdabot on the web, and everything but the OS and apache are in haskell
21:02:46 <lispy> ?where lambdaweb
21:02:47 <lambdabot> http://lambdabot.codersbase.com
21:02:50 <lispy> ben23: ^^^
21:03:34 <Excedrin> lispy: what's the interface between Apache and lambdabot in that?
21:03:45 <Excedrin> oic, goa
21:03:48 <lispy> Excedrin: cgi
21:04:17 <lispy> goa is the glue between cgi and lambdabot
21:04:30 <Excedrin> not fastcgi?
21:04:37 <lispy> actually it is fastcig!
21:04:52 <lispy> starting lambdabot up all the time would have been slow
21:05:25 <lispy> it's a very layered appoarch
21:06:07 <lispy> browser <--> http <--> apache <--> fastcgi <--> goa <--> lambdabot <--> requested plugin
21:06:19 <Excedrin> I'm curious why it doesn't use Text.Html or HaXml
21:06:29 <lispy> some of the plugins, like run and bf, actually run binaries
21:06:51 <lispy> well, how could we have used it?
21:07:26 <lispy> part of the trick was not modifying lambdabot just to have a web version
21:07:38 <lispy> although, having lambdabot spit out xml wouldn't be a bad thing
21:07:45 <lispy> if she did then we could apply css
21:07:51 <lispy> and get more featureful output
21:09:16 <lispy> Excedrin: we're open to ideas and very accepting of darcs patches
21:09:37 <lispy> Excedrin: we'd like to turn it into part of an interactive tutorial
21:09:54 <lispy> Excedrin: it would be a good way to get famous in the community :)
21:17:46 <dons> Excedrin: just for you, a page on using rewrite rules for various tricks:
21:17:47 <dons>  http://haskell.org/haskellwiki/Playing_by_the_rules
21:17:51 <lambdabot> Title: Playing by the rules - HaskellWiki, http://tinyurl.com/ymzbh3
21:18:05 <lispy> hah
21:18:09 <lispy> dons: did you just write that?
21:18:12 <dons> yes
21:18:43 <Excedrin> thanks
21:19:09 <dons> rewrite rules are my new TH :)
21:19:19 <lispy> dons++
21:20:29 <dons> they're hardly explored, but very powerful
21:20:36 <dons> i suspect there's lots of cool things we can do with them
21:20:45 <Excedrin> what's the state of lambdabot on ghc 6.6?
21:21:01 <sjanssen> Excedrin: it works after a few modifications
21:21:03 <dons> it builds and runs, but without @run
21:21:15 <dons> sjanssen: should only need the lambdabot.cabal.6.6 file?
21:21:18 <lispy> dons: but the argument against them is their lack of safety
21:21:29 <dons> lispy: they're not that unsafe.
21:21:32 <dons> they have to type check
21:21:33 <lispy> oh, lambdabot on ghc6.6 now?
21:21:35 <sjanssen> dons: ah, I probably made my modifications before that existed
21:21:37 <dons> and non-termintaion is pretty easy to spot
21:21:55 <lispy> dons: but they could be wrong and still type check...
21:21:58 <dons> right.
21:22:12 <dons>  you can introduce errors if you claim something is equivalent, and its not
21:22:12 <lispy> and you might not realize ghc is doing the transformation
21:22:14 <dons> just like in TH..
21:22:38 <lispy> right, so caution is advised, but they are safer than i realized
21:23:13 <dons> yeah, quickcheck is useful
21:23:22 <dons> i had an ad hoc rule in fps for quite a while that was wrong
21:23:30 <dons> length  . lines == count '\n'
21:23:40 <dons> not true! (think of a non-\n on the last line)
21:23:42 <lispy> ?type count
21:23:43 <lambdabot> Not in scope: `count'
21:23:50 <lispy> ah
21:24:31 <dons> ?check \s -> length (lines s) == length (filter (=='\n') s)
21:24:32 <lambdabot>  Falsifiable, after 0 tests: "\940714"
21:24:34 <dons> :)
21:24:53 <lispy> lines is evil
21:24:56 <lispy> or is it unlines
21:25:00 <dons> ?check \s -> length (lines (s ++ "\n")) == length (filter (=='\n') (s ++ "\n"))
21:25:01 <lambdabot>  OK, passed 500 tests.
21:25:08 <sjanssen> ?scheck \s -> length (lines s) == length (filter (=='\n') s)
21:25:09 <lambdabot>  add an instance declaration for (Serial Char)
21:25:09 <lambdabot>   In the definition of `ttw...
21:25:12 <dons> yeah, lines is just borken for newlines at the end
21:25:21 <dons> sjanssen: oh we should update that
21:25:34 <dons> its a real pity that length (lines s) == length (filter (=='\n') s) doesn't hold
21:25:36 <sjanssen> dons: yep, you'll get a patch in a few minutes
21:25:37 <Excedrin> :version
21:25:37 <Excedrin> lambdabot 4p272, GHC 6.6 (Linux i686 1.80GHz)
21:25:38 <Excedrin> neat
21:25:50 <dons> sjanssen: want to grab SmallCheck 0.2?
21:26:00 <dons> Excedrin: nice
21:26:17 <dons> it has better depth limiting now
21:26:26 <dons> (though you still have to be careful to remove the IO instance
21:26:45 <sjanssen> dons: sure, I'll do that
21:28:29 <ben23> hm, I'm trying to build lists out of a big list
21:28:33 <ben23> any tips ?
21:28:41 <ben23> no answer, just tips :)
21:29:01 <eviltwin_b> that's a pretty general notion.  what kind of small lists out of what kind of big list?
21:29:21 <eviltwin_b> s/small//\
21:29:51 <ben23> lists of 4 elems out of [1..40] for example
21:29:56 <dons> general question. here's a general answer: use something in Data.List
21:30:01 <dons> ?docs Data.List
21:30:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:30:11 <ben23> thanks
21:30:17 <dons> > splitAt 3 [1..40]
21:30:19 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
21:30:20 <lispy> dons: maybe you already answered and i missed it, but does hs-plugins work on 6.6 now?
21:30:23 <dons> and recurse ;)
21:30:25 <lispy> ?version
21:30:25 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
21:30:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:30:28 <dons> lispy: thanks. no.
21:30:43 <lispy> dons: thanks?  my begging should be annoying by now ;)
21:30:45 * dons kicks dons butt
21:30:54 <eviltwin_b> heh
21:31:02 <lispy> dons: this time i only asked because Excedrin compiled on 6.6
21:31:05 <dons> ok.
21:31:07 <lispy> i promise :)
21:31:17 <dons> i'll build a ghc 6.6 snapshot , and see how far I get ..
21:31:22 * dons wgets
21:31:28 <lispy> sweet!
21:32:19 <sjanssen> it runs on 6.5 though?
21:32:34 <dons> if anyone uses or has ideas for using rules for fun games, please add them to that page: http://www.haskell.org/pipermail/haskell-cafe/2006-November/019648.html
21:32:37 <lambdabot> Title: [Haskell-cafe] Wiki page for rewrite rules tips, types and tricks, http://tinyurl.com/y3q7dm
21:32:49 <dons> sjanssen: it does, on a version just before the package.module name change went into the .hi files
21:32:58 <dons> i.e. the last possible ghc 6.5 before things broke :)
21:33:06 <sjanssen> ah
21:33:26 * eviltwin_b can think of a few evil tricks but is not sure he wants to suggest them in public.  (emphasis on *evil*)
21:33:30 <psykotic> btw what is ghc's current level of support for inference of higher-rank polymorphic types? or does it only do checking for those?
21:34:07 <dons> good questoin. spj said something on this recently
21:34:09 * dons hunts
21:34:19 <sieni> should I upgrade to mac os x 10.4 to use ghc 6.6 (with macports)?
21:34:33 <lispy> dons: ah you sohuld find that on reddit
21:34:38 <dons> eviltwin_b: i wonder if some clever things from the term rewriting world can be pulled in
21:34:57 <dons> lispy: oh, you mean the typeclass/GADT thing?
21:34:58 <eviltwin_b> last I checked 6.6 wasn't in dports; I installed from a binary package
21:35:02 <dons> actually, its probably in the HWN.
21:35:09 <dons> now, were'd i put those archives
21:35:13 <psykotic> dons: the example on that page (changing a non-terminating program to a terminating one) is evil. :)
21:35:36 <lispy> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/11192
21:35:36 <eviltwin_b> no, evil is substituting snd for fst. :)
21:35:38 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/ycmwu7
21:35:41 <lispy> dons: isn't that the email you meant?
21:35:45 <dons> ah,
21:35:46 <dons>   * Adding Impredicative Types to GHC. Simon Peyton-Jones pushed a patch into GHC to handle
21:35:49 <dons>     impredicative polymorphism (see Boxy types: type inference for higher-rank types and
21:35:49 <eviltwin_b> or worse
21:35:52 <dons>     impredicativity). Secondly, GHC now supports GADTs in the more simplified way described in
21:35:53 <psykotic> it breaks certain invariants you'd want non-strict languages to have. for instance, why should inserting a map (+1) in the middle between the two reverses change the termination properties?
21:35:55 <dons>     Simple unification-based type inference for GADTs
21:35:59 <dons> psykotic: http://research.microsoft.com/~simonpj/papers/boxy/
21:36:01 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/ps2wk
21:36:29 <psykotic> dons: ah thanks.
21:36:40 <sjanssen> dons: I need hs-plugins to test SmallCheck, don't I?
21:36:41 <dons> psykotic: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#impredicative-polymorphism
21:36:44 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
21:36:45 <dons> sjanssen: yep
21:36:57 <dons> well, not really, you could test in ghci
21:37:06 <psykotic> dons: presumably it only handles a special class of those types. anyway i'll take a look, cheers.
21:37:28 <sjanssen> dons: I've only got GHC 6.6, so this patch I'm sending isn't really tested
21:37:51 <dons> ok
21:37:53 <dons> i can test it
21:38:02 <sjanssen> I removed the IO stuff and the diffs looked fine, so it should be okay
21:38:08 <dons> ah, musasabi implemented some clever rule things for binary serialisatoin?
21:38:13 <dons> sjanssen: cool
21:38:23 <dons> musasabi: around? did you document or put online your rewrite rule tricks?
21:39:28 <psykotic> dons: so, when people these days still say that haskell uses HM type inference they're lying through their teeth :)
21:39:46 <dons> totally
21:40:09 <dons> HM is long gone, replaced with System Fc for GADTs, ATs and FDs, not to mention all the impredicativity
21:40:10 <lispy> it uses HM++ ;)
21:40:19 <dons> and higher kinded stuff
21:40:39 <dons> sjanssen++ patch
21:41:07 <psykotic> dons: is it the case that most of those extensions sit nicely on top of a HM-style core?
21:41:24 <dons> yeah
21:41:41 <dons> so you still think in terms of "does this translate into System F, can I do HM on it to infer the type"
21:41:52 <dons> the System Fc paper would talk about the new stuff
21:42:19 <psykotic> but, hmm, system f obviously does not have the stratification into schemes and types
21:42:22 <psykotic> that split is what makes HM work
21:42:30 <dons> http://www.cse.unsw.edu.au/~chak/papers/SCP06.html
21:42:32 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/y3kswc
21:43:08 <psykotic> dons: well, type inference for system f isn't decidable, is it?
21:43:33 <psykotic> so i'm assuming that even though they target an extension of system f they only infer types for a subset thereof
21:43:46 <dons> at least there are haskell programs that require type annotations.
21:43:47 <psykotic> i'll shut up and read the paper though, sorry
21:43:58 <dons> > (show . read) "7"
21:43:59 <lambdabot>  Add a type signature
21:44:09 <psykotic> right
21:44:18 <psykotic> i can infer types for the subset of system f in which all terms have type annotations! :)
21:44:35 <lispy> you too?
21:44:36 <lispy> wow
21:44:44 <dons> heh
21:45:17 <psykotic> i'd tell you but i have a patent pending
21:45:35 <Excedrin> is Prelude.seq the same as Control.Parallel.seq ?
21:45:50 <emu> is there anything like a "time limited computation" monad
21:46:12 <dons> emu: yeah, i've seen one
21:46:17 <dons> Cale: might have the url
21:46:41 <dons> Excedrin: seq = Parallel.pseq
21:46:44 <lispy> dons: i think we need a languages.programming.reddit
21:46:51 <dons> ?source Control.Parallel.Strategies
21:46:53 <lambdabot> http://darcs.haskell.org/packages/base/Control/Parallel/Strategies.hs
21:46:56 <dons> lispy: ah maybe
21:46:58 <pkhuong> lispy: it`s called l-t-u.
21:47:03 <dons> to kcik all the web 2.0 "programming" stories
21:47:05 <lispy> pkhuong: heh
21:47:12 <ben23> (length xs) `mod` n  > 0 = group (xs:0) n
21:47:14 <dons> yeah, LtU is too static though
21:47:17 <psykotic> pkhuong, no, ltu is the dynamic vs static typing fight club
21:47:20 <lispy> dons: and the blogs about hiring
21:47:22 <ben23> I'm trying to add 0's at the end of a list
21:47:27 <dons> i like the anarchic free forall
21:47:30 <pkhuong> psykotic: bah, we're past that. OO VS FP now.
21:47:31 <ben23> that's creating an error
21:47:34 <ben23> hm
21:47:39 <lispy> psykotic: if it's your first time at LtU you have to fight
21:47:59 <psykotic> lispy, haha, right
21:48:08 <emu> i was thinking of writing one and base it kinda on the Maybe monad.  what do you use for lambdabot btw?
21:48:15 <Excedrin> I'm sure that the LtU guys would love more article submissions, and aren't the LtU forums more of an anarchic free forall?
21:48:28 <pkhuong> too much so.
21:48:34 <pkhuong> who is that cdiggins dude? (:
21:48:44 <Korollary> It's not quite anarchic
21:49:35 <dons> emu: ah ok. forkIO, here in the LB monad:
21:49:38 <dons> -- | run an IO action in another thread, with a timeout, lifted into LB
21:49:38 <dons> forkLB :: LB a -> LB ()
21:49:38 <dons> forkLB f = (`liftLB` f) $ \g -> do
21:49:38 <dons>             forkIO $ do
21:49:40 <dons>                 timeout (15 * 1000 * 1000) g
21:49:42 <dons>                 return ()
21:49:45 <dons>             return ()
21:49:47 <psykotic> pkhuong, i guess he's getting a free blow-by-blow education in PLT :)
21:50:04 <dons> timeout :: Int -> IO a -> IO (Maybe a)
21:50:05 <dons> timeout n a = parIO (Just `fmap` a) (threadDelay n >> return Nothing)
21:50:20 <dons> parIO lives at http://www.haskell.org/pipermail/haskell-cafe/2005-January/008314.html
21:50:22 <lambdabot> Title: [Haskell-cafe] Implementing computations with timeout, http://tinyurl.com/y66anq
21:50:22 <psykotic> pkhuong, "a fixed-point combinator for recursion? great idea!" :)
21:50:29 <pkhuong> heh, yeah :|
21:50:30 <dons> emu: have a peek in the lambdabot src
21:50:33 <emu> k
21:51:07 <lispy> whoa, scala was a google tech talk
21:51:16 <lispy> i bet we start seeing more of scala
21:51:34 <pkhuong> I wonder what we could do that's interesting with the open source java.
21:52:06 <dons> are there examples in the history of programming where a language supplied say 10 major new concepts, but ultimately it was the competitor langauges that adopted the concepts that became successful?
21:52:29 <emu> i se
21:52:30 <lispy> dons: like smalltalk?
21:52:38 * dons wonders about Scala, C#, lambdas in C++, python with list comprehenions, ...
21:52:41 <emu> dons: this isn't in the standard libraries already, right?
21:52:43 <dons> lispy: yeah. that's one perhaps
21:52:50 <dons> emu, nope. its being discussed though
21:52:56 <emu> dons: lisp
21:53:07 <dons> lisp had a golden age or two, though
21:53:21 <dons> but yeah, hmm.
21:53:41 <pkhuong> dons: BCPL? FP?
21:53:47 <eviltwin_b> concepts from icon are being imported into perl, python, and ruby
21:53:58 <emu> dons: i also am thinking of combining this with StateT such that the computation would continually update the State, and when "Terminated" it would return whatever State there was
21:54:09 <lispy> dons: i think in language design, being conservative for the time is better than being bold
21:54:10 <pkhuong> ISTM perl wants to be icon when it grows up.
21:54:28 <dons> i guess one thing with lisp was that they wanted lisp machines to be the crucial disruptive technology. haskell only needs mainstream multicore machines for that to happen
21:54:32 <lispy> dons: well as far as popularity is concerned
21:54:34 <eviltwin_b> perl6 is looking rather like a crossbreed of icon and haskell :)
21:54:52 <eviltwin_b> (much like ruby looks like a crossbreed of perl and smalltalk)
21:54:53 <dons> so i'm still very hopeful that the 80 core desktop will be very disruptive
21:55:13 <psykotic> lispy: that scala tech talk is great btw, definitely check it out.
21:55:22 <lispy> psykotic: am :)
21:55:40 <dons> lispy, then again, java wasn't that conservative
21:55:56 <lispy> dons: it was sold as an evolutionary step to C++
21:56:03 <dons> the big java lie, eh?
21:56:11 <psykotic> the interesting things about java were related to dynamic class loading and such
21:56:13 <dons> fool them with syntax
21:56:40 <dons> jitting, verified VMs and bytecode were pretty edgy though
21:56:49 <dons> that's java's hair shirt (one of many?)
21:56:53 <psykotic> and some of the work on "open world" issues to deal with backwards and forwards compatibility of classes
21:56:58 <emu> @hoogle Kill
21:56:59 <lambdabot> Control.Concurrent.killThread :: ThreadId -> IO ()
21:57:00 <lambdabot> System.Console.Readline.killText :: Int -> Int -> IO ()
21:57:00 <lambdabot> Control.Exception.ThreadKilled :: AsyncException
21:57:09 <psykotic> jitting was done in the 80's by the smalltalk people (peter deutsch, i think)
21:57:11 <emu> @hoogle throwTo
21:57:12 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
21:57:29 <pkhuong> dons: verified bytecode? Except for the later embedded stuff, isn't it all dynamically checked?
21:57:40 <dons> verified VM
21:57:57 <pkhuong> ah k.
21:57:57 <dons> the semantics of the VM were verified early on.
21:58:36 <pkhuong> psykotic: or Self... That team really pumped out some good stuff.
21:59:58 <psykotic> pkhuong, no, it checks the bytecode before jitting it.
22:00:05 <psykotic> it makes sure that it is well behaved wrt typing and the expression stack.
22:00:05 <psykotic> pkhuong, yeah but that was ultimately based on the work that started in the smalltalk camp. some of the main self people like unger did work on smalltalk before working on self.
22:00:09 <psykotic> i think the first paper that described 'real' jitting (i.e. not something simplistic like threaded code) was the dynamic translation paper by deutsch, which was on smalltalk.
22:00:36 <ben23> how do you add something at the end of a list ?
22:00:38 <psykotic> anyway i think the java work on open world issues is pretty overlooked and some of the more novel parts of the platform.
22:00:45 <eviltwin_b> there was talk about java's jit foo being based on work in smalltalk back in the day
22:00:46 <dons> > [1..10] ++ [9]
22:00:48 <ben23> I have list xs, I tried xs:0
22:00:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,9]
22:00:58 <ben23> [1..5]:6
22:01:02 <pkhuong> ?type (:)
22:01:04 <lambdabot> forall a. a -> [a] -> [a]
22:01:09 <ben23> [1..5] ++ 6
22:01:13 <dons> > let snoc xs x = xs ++ [x] in snoc [1..10] 42213
22:01:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,42213]
22:01:19 <psykotic> eviltwin_b, self, i think. most of the self work was done at sun research labs, and the people who worked on the first hotspot vm were all the old self team guys.
22:01:29 <ben23> [1..5] ++ 6
22:01:42 <dons> ?type (++) -- note well
22:01:43 <ben23> > [1..5] ++ 6
22:01:44 <lambdabot>  add an instance declaration for (Num [a])
22:01:44 <lambdabot> forall a. [a] -> [a] -> [a]
22:01:50 <dons> takes 2 lists
22:01:57 <ben23> ah
22:02:00 <dons> > [1..5] ++ [6] -- safe.
22:02:01 <lambdabot>  [1,2,3,4,5,6]
22:02:11 <eviltwin_b> but self picked it up from smalltalk, and the stuff I recall was targeted at folks who might well have heard of smalltalk but wouldn't have a clue about Self
22:02:39 <psykotic> ah right
22:02:47 <ben23> dons thanks
22:03:20 <psykotic> the self people _did_ expand on smalltalk a lot in this camp.
22:03:22 <eviltwin_b> (after all, IBM talked about Smalltalk in public.  Who talked about Self?)
22:03:32 <psykotic> dynamic deoptimization and stuff like that
22:04:23 <eviltwin_b> it was kind of "useful stuff taked out of esoterica and brought to the masses" marketing foo
22:04:24 <psykotic> btw this stuff is cool, http://java.sun.com/docs/books/jls/second_edition/html/binaryComp.doc.html
22:04:26 <lambdabot> Title: Binary Compatibility, http://tinyurl.com/3sl7x
22:08:04 <emu> dons: do you think it would be a better idea to simply have the delaying thread "throwTo" the primary thread an exception, which it would handle by terminating itself?
22:08:27 <ben23> sleep time, later guys
22:08:43 <dons> emu: also http://www.haskell.org/haskellwiki/Timing_out_computations
22:08:46 <lambdabot> Title: Timing out computations - HaskellWiki, http://tinyurl.com/yhg8hd
22:11:59 <lispy> i get the impression that scala is intended to be whatever the programmer wants it to be
22:12:26 <lispy> which means it tries to allow you to do things instead of trying to save you from yourself
22:13:14 <eviltwin_b> sounds like C, or perl :)
22:15:48 <Pete_I> i thought that's what lisp macros were for?
22:15:53 <psykotic> eviltwin_b, unlike C it has strong typing, and unlike perl it has static typing.
22:16:03 <psykotic> in fact it has a very expressive type system.
22:16:13 <pkhuong> psykotic: C is strong, it's just inexpressive and full of holes :)
22:16:27 <psykotic> no, it's not strong.
22:16:36 <psykotic> it's static but not strong. the holes make it weak by definition.
22:17:37 <psykotic> (i'm assuming you're referring to casts)
22:21:10 <eviltwin_b> psykotic: I was referring to philosophy, not typing.  (not like perl anmd C are comparable in that regard :)
22:25:29 <ptolomy> At work, I'm dealing with C app that is really tightly coupled with a database without keys, constraints, or non-varchar datatypes. I yearn so for types.
22:29:40 <dons> i wonder if in that situation its worth prototyping in haskell, getting the types sorted out, then translating to C
22:29:50 <dons> the way the L4 verified kernel guys do
22:29:57 <ptolomy> I actually have.
22:30:13 <ptolomy> at least part of the position calculation and PnL code.
22:30:20 <dons> ice
22:30:22 <dons> n
22:30:26 <ptolomy> (finance.. haskell's playground)
22:30:34 <ptolomy> but the DB stuff is what is killing me.
22:30:40 <dons> we should probably write more on using haskell for prototyping unsafe languages
22:30:55 <ptolomy> and no amount of joyous typechecking can fix an ad hoc database.
22:31:12 <ptolomy> and a VB6 client that requires it to remain in place..
22:31:36 <ptolomy> worst part about consulting: you can't tell the customer to stop using that crappy amateur piece of crap they wrote and cling to.
22:31:41 <pzpz> is there a better method for doing [ IO a -> a ] other than performUnsafeIO ?
22:31:57 <ptolomy> Is there any good way of doing IO a -> a?
22:32:09 <dons> ptolomy: hmm....
22:32:19 <pzpz> well, i'm sure i could entirely avoid what i'm doing
22:32:24 <Saulzar> pzpz, One could answer ">>=" :)
22:32:33 <dons> stay in the monad, unless you have a proof that its referentially transparent
22:33:00 <psykotic> ptolomy, what are you trying to do?
22:33:11 <pzpz> dons: that's the thing -- i'm not quite sure how to
22:33:30 <pzpz> psykotic: i'm the one trying to circumvent using performUnsafeIO
22:34:14 <psykotic> but why?
22:34:34 <psykotic> like saulzar says the way you get an a out of an IO a while staying within the monad is >>=
22:34:42 <ptolomy> psykotic: I meant that more in (shamefully drunken) response to pzpz's question as a (admittedly poor) way of saying "performUnsafeIO is a bad idea unless you know more than me".
22:34:45 <sjanssen> One should apply the standard mother's wisdom regarding unsafePerformIO: "If you have to ask if it's okay, you probably shouldn't do it."
22:34:57 <psykotic> ptolomy, ah right, i was confused for a second. my apologies.
22:35:23 <pzpz> i didn't quite ask if it was ok. i asked how to avoid it :p
22:36:49 <_Stinger_> why do you need to do IO a -> a?
22:37:03 <dons> pzpz: don't go into the monad in the first place?
22:37:14 <dons> and if you're using io for state only, try using a State monad
22:37:27 <dons> which does let you encapsulate the side effects, and gives you an m a -> a 'out'
22:37:35 <pzpz> i'm using MVars, and i have a function to get a string from one of those MVars
22:37:45 <dons> ok, so that's essentially side effect ful
22:38:01 <dons> do x <- readMVar mv ; return (f x)
22:38:04 <pzpz> and i'm trying to build a string to send via a handle, yet i can't seem to join the strings due to type issues
22:38:16 <dons> sounds doable
22:38:17 <dons> ?paste
22:38:17 <lambdabot> http://paste.lisp.org/new/haskell
22:38:27 <sjanssen> pzpz: not to give you the third degree, but is there a specific reason you're working in the IO monad and using MVars?
22:38:46 <pzpz> sjanssen:: multiple threads modifying state
22:38:53 <sjanssen> pzpz: good reason ;)
22:39:19 <dons> pzpz: joining strings should be very doable, since you need to be in IO for the handle send and the threads and the MVars
22:39:48 <dons> so just use the usual <- and >>= methods to get at data you wnat
22:40:26 <pzpz> i'll paste, i'm sure i'm overlooking osmething retarded.
22:41:03 <lisppaste2> pzpz pasted "m0 betta" at http://paste.lisp.org/display/30138
22:41:32 <pzpz> it's especially ugly now as i'm trying to work around a few blocks :)
22:41:46 <sjanssen> pzpz: could you paste the error message?
22:41:47 * ptolomy really wants to write an efficient FIX engine in Haskell, and with Bytestring, it is probably possible. That would make Haskell a reasonable choice for financial firms the world over...
22:41:55 <pzpz> sjanssen: sure, i'll append it
22:42:02 <dons> (getUser mvH hnd) ++ c ++ " | " ++ a looks wrong
22:42:22 <dons> do x <- getUser ; return $ x ++ c ++ " | " ++ a -- ?
22:42:33 <eviltwin_b> you want to use <- to receive the result of getUser and ==dons
22:43:00 <dons> do x <- getUser mvH hnd ; return $ x ++ c ++ " | " ++ a -- i mean
22:43:06 <jrud> I dont remember, because i just recently started playing with haskell again, but do type names and module names share the same namespace in haskell98?
22:43:17 <Korollary> no
22:43:18 <dons> nope
22:43:23 <jrud> ok, ok good deal
22:43:35 <dons> think import Maybe ; data Maybe a = Nothing | Just a
22:44:52 <jrud> yeah, im doing some stuff with hiding and 'import Foo as' etc, trying to get the typename in the module and the module name both toplevel, so i dont have to qualify the type in signatures, gets a little confusing
22:45:18 <pzpz> oh, i must have also deleted my sendMsg call befor eall of that concatenation
22:45:24 <pzpz> explaining why it seems a bit odd
22:53:43 <Korollary> am I lagged out?
22:53:58 <Korollary> > 1
22:53:59 <lambdabot>  1
22:54:01 <pzpz> yes.
22:54:09 <pzpz> lambdabot gave it away :(
22:54:14 <pzpz> we were all just ignoring you.
22:54:17 <Korollary> I knew I couldnt trust humans
22:55:15 <pzpz> think a teacher would accept haskell generated c for an assignment?
22:55:23 <Korollary> no
22:55:29 <pzpz> :(
22:55:34 <lispy> anyone here use prolog much?  if so, what sorts of things do you use it for?
22:55:34 <pzpz> even if i comment it?
22:55:35 <pkhuong> why would he?
22:55:37 <Korollary> C assignments are easy
22:55:44 <pzpz> because it's in C ?
22:55:48 <Saulzar> Heh, good luck in commenting it ...
22:55:51 <sjanssen> int i; i = 0;
22:55:56 <sjanssen> there we go, assignment done
22:55:59 <lisppaste2> fons pasted "Heterogeneous lists with Data.Dynamic" at http://paste.lisp.org/display/30139
22:56:14 <Korollary> Yes. You "can't" be creative anyway. All you need to be is careful.
22:56:18 <fons> hi again
22:56:19 <lispy> pzpz: use jhc if you're serious about it, but it won't be pretty :)
22:56:41 <fons> I'm trying to create heterogeneous lists using Data.Dynamic
22:56:52 <lispy> heh, my advice about courses is to not be creative...you'll lose marks for it more often than you'll earn them :)
22:57:24 <fons> but in the example I pasted descHead gets a compilation error I cant really understand
22:57:49 <fons>     Ambiguous type variable `a' in the constraint:
22:57:49 <fons>       `Typeable a' arising from use of `desc' at HList.hs:38:12-15
22:58:21 <fons> well, I do understand it but I don't know the cause
22:58:44 <lispy> i've had a lot of problems with HList
22:58:56 <lispy> but i've only tried to use it with OOHaskell
22:59:03 <fons> lispy, it's my own simple implementation
22:59:07 <fons> just an example
22:59:08 <dons> fons, http://haskell.org/haskellwiki/Heterogenous_collections#A_Universal_type :)
22:59:10 <lambdabot> Title: Heterogenous collections - HaskellWiki, http://tinyurl.com/yljltd
22:59:21 <dons> (just added today)
22:59:25 <dons> add your example!
22:59:44 <dons> well, if it type checks
22:59:59 <dons> > [toDyn 'x', toDyn ()]
23:00:00 <lambdabot>  [<<Char>>,<<()>>]
23:00:11 <lispy> dons: did you see ndm's reply :(
23:00:27 <fons> dons, it doesn't typecheck
23:00:47 <fons> dons, it's pretty much the same example
23:00:50 <dons> lispy: yeah. sounds like an argument to remove fromJust ;)
23:00:56 <dons> fons: what doesn't type check?
23:00:59 <dons> your code?
23:01:27 <fons> dons, it doesnt compile
23:01:37 <dons> fons, which code doesn't compile?
23:01:47 <fons> http://paste.lisp.org/display/30139
23:02:07 <dons> personally, I think existentials are the best solution
23:02:20 <dons> i've never needed heterogenous lists that didn't have a common api
23:02:25 <dons> and existentials are quite cheap to use
23:02:29 <fons> dons, I've been fighting with existantials for days now
23:02:34 <fons> existentials
23:03:05 <dons> Typeable is restricted to monomorphic values
23:03:10 <dons> so showF=(\s -> "\""++show s++"\"") won't work
23:03:16 <dons> ?type (\s -> "\""++show s++"\"")
23:03:17 <lambdabot> forall a. (Show a) => a -> [Char]
23:03:22 <dons> ?type  toDyn $ (\s -> "\""++show s++"\"")
23:03:24 <lambdabot> Dynamic
23:03:30 <dons> > toDyn $ (\s -> "\""++show s++"\"")
23:03:31 <lambdabot>  Add a type signature
23:03:40 <dons> > toDyn $ (\s -> "\""++show s++"\"") :: (Show a) => a -> [Char]
23:03:41 <lambdabot>    Expecting a function type, but found `b'
23:03:42 <lambdabot>    Expected type: a -> [Char...
23:03:48 <dons> > toDyn ((\s -> "\""++show s++"\"") :: (Show a) => a -> [Char])
23:03:49 <lambdabot>  Add a type signature
23:05:09 <dons> if we can't make fromJust safe in darcs, there's no hope for it...
23:06:37 <lispy> dons: there is another way to look at it, it's useful to people so even if we take it away they will just write it themselves...what if we made it safe/effective so that when they want it they a version that was done right?
23:07:36 <lisppaste2> fons pasted "How to create an heterogeneous List of this type?" at http://paste.lisp.org/display/30141
23:07:55 <lispy> dons: there is a book, "On Lisp" by PG where he talks about programmers being lazy.  If the RightWay(tm) is the easy way, people will manage to do things the RightWay, but if the RightWay is hard, they'll almost never do it the right way
23:08:12 <dons> TomPledger++ http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
23:08:15 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
23:08:45 <fons> dons, I've been trying to create an heterogeneous list of that type for days now, without elegant results
23:08:50 <lispy> TomPledger++
23:09:02 <sjanssen> whoa
23:09:16 <lispy> it's faster and smaller!
23:09:18 <sjanssen> Haskell #1!
23:09:24 <lispy> okay, let's take bets, how long till it is disqualified?
23:09:31 <fons> dolio, the thing is that comes from a C struct in which the type parameters are modelled with (void *)
23:09:38 <fons> ops, dons I meant
23:09:55 <dons> lispy: hmm. i think it should be ok
23:10:09 <lispy> how did smalltalk get to be #4? ;)
23:10:11 <dons> the last chameneos was only removed for a minor reason
23:10:21 <sjanssen> ah, threading test, that's why GHC wins
23:10:27 <dons> yep
23:10:45 <lispy> oh, so beating erlang is something to be proud of
23:11:00 <sjanssen> I wonder if we can get them to compile with -threaded . . .
23:11:13 <dons> sjanssen: oh. we can...
23:11:36 <dons> yes, huh, we should ask
23:11:48 <sjanssen> doesn't look like it's an SMP system though
23:11:52 <dons> it can be suggested on the submissions page, if musasabi isn't around
23:12:02 <sjanssen> maybe hyperthreading though?
23:12:05 <dons> sjanssen: your fasta needs bytestring, right?
23:12:09 <sjanssen> dons: yep
23:12:11 <dons> yeah, threading might still be a win
23:12:14 <dons> would be worth checking
23:12:21 <Korollary> the user's guide sounds uncertain about hyperthreading
23:12:28 <dons> ok, i think we should hold off submitting the fasta till ghc 6.6 appears
23:12:40 <sjanssen> oh, I thought it was already there
23:12:58 <dons> sequence_ [forkIO (arrive c 0) | c <- subCols] that' um what
23:13:16 <dons> mapM_ (\c -> forkIO (arrive c 0)) subCols
23:13:20 <dons> ?pl \c -> forkIO (arrive c 0)
23:13:21 <lambdabot> forkIO . flip arrive 0
23:13:33 <lispy> any reason why they don't have more implementations of each language?
23:13:34 <dons> mapM_ (forkIO . flip arrive 0) subCols
23:13:43 <dons> they do on the sandbox
23:13:48 <lispy> like why don't they have hugs/yhc/jhc/etc
23:14:00 <dons> most entires don't compile with all compiles
23:14:09 <dons> you have to get at least 60% of so compiled
23:14:10 <sjanssen> dons: could even flip the argument order for arrive
23:14:14 <dons> yeah
23:14:17 <dons> so we should do that.
23:14:20 <dons> more points
23:14:32 <lispy> why is that ocaml entry disqualified?
23:14:39 <dons> doesn't use threads, iirc
23:16:46 <sjanssen> these results for chameneos are really something to be proud of
23:16:54 <dons> :)
23:17:07 <dons> 20 years of concurrency and parallelism research pays off
23:17:10 <sjanssen> a solution that is smaller (in memory), faster, and shorter/cleaner code
23:17:12 <sjanssen> than Erlan
23:17:13 <sjanssen> g
23:17:18 <dons> yeah, that rocks
23:17:21 <sjanssen> at concurrency
23:17:57 <psykotic> i feel a don reddit pimpage post coming.. :)
23:18:12 <lispy> i find this amusing
23:18:15 <lispy> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ruby
23:18:18 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/veo3w
23:18:22 <sjanssen> he better post it quickly, if he wants my upvote before I go to bed
23:18:33 <sjanssen> lispy: heh
23:18:33 <lispy> ruby is apparently really inefficient
23:19:11 <Saulzar> Not entirely supprising...
23:19:20 <sjanssen> lispy: yeah, there's a lot of buzz about the ruby interpreter being outrageously slow
23:19:36 <dons> really, you think I should post that?
23:19:52 <dons> i was sitting here  happily trying to speed up chameneos..
23:20:03 <sjanssen> ha
23:20:13 <dons> oh, what the hell. haven't submitted anything today.
23:20:59 <lispy> ya know, looking at these benchmarks, Haskell of today is comparable to fortran in performance
23:21:35 <lispy> pretty amazing really
23:21:53 <pkhuong> lispy: watch me try to sell haskell to my advisor ;)
23:22:13 <pkhuong> s/advisor/prof/
23:22:28 <psykotic> pkhuong, feeley?
23:22:30 <dons> ok, here we go, http://programming.reddit.com/info/rg95/details
23:22:33 <lambdabot> Title: Great language shootout: fast and light Haskell threads (reddit.com), http://tinyurl.com/yklrfk
23:22:36 <lispy> pkhuong: why would it be hard?
23:23:00 <dons> and thats not using -threaded or smp... that's just the ghc rts scheduler kicking things along. fun fun.
23:23:17 <pkhuong> psykotic: no, I'm w/ the CRT. C++.
23:23:19 <dons> simonmar++ super concurrency guru to the max
23:23:27 <lispy> heh
23:23:35 <psykotic> pkazmier, ouchie
23:23:48 <pkhuong> psykotic: also, feeley is on a sabbatical @ harvard. No, C++ is good. I like it :)
23:24:01 <lispy> ?quote largos
23:24:02 <lambdabot>  [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
23:24:17 <desrt> ?quote shapr
23:24:17 <lambdabot>  Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
23:24:36 <lispy> shapr++
23:24:42 <psykotic> pkhuong, i know way too much c++ too and am quite productive in it. but i'd pretty much rather program in anything else, given the choice. :)
23:24:48 <desrt> ?type shapr
23:24:49 <lambdabot> Not in scope: `shapr'
23:25:18 <lispy> at work there is more and more boost/stl and generally happy C++ showing up in our code base
23:25:43 <lispy> now if i could get them excited about unit testing
23:25:48 <dons> ?pl \c -> forkIO (arrive c 0)
23:25:49 <lambdabot> forkIO . flip arrive 0
23:25:49 <pkhuong> psykotic: Really mostly numeric stuff, and I haven't had to work w/ CPLEX yet.
23:26:11 <desrt> dons; does ?pl always work?
23:26:23 <lispy> ?pl foo . bar
23:26:23 <lambdabot> foo . bar
23:26:27 <desrt> ...
23:26:36 <lispy> desrt: what do you mean by work?
23:27:08 <lispy> desrt: are you asking if it is always possible to transform to a pointfree version?
23:27:16 <dons> desrt: define "always"
23:27:29 <desrt> ?pl fix (\f n -> if (n==0) then 1 else n*f(n-1))
23:27:30 <lambdabot> fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1))
23:27:34 <desrt> nice.
23:27:47 <desrt> dons; can you give it something that it will fail on?
23:27:47 <lispy> ?pl [ x | x <- [1..4]] -- ?pl can't handle this syntax
23:27:48 <lambdabot> [x | x <- [1..4]]
23:27:54 <dons> ?pl if (vs_sm_position(sp, &vp->m_stop, F_ISSET(vp, VC_C1SET) ? vp->count - 1 : 0, P_TOP)) return (1)
23:27:55 <lambdabot> (line 1, column 22):
23:27:56 <lambdabot> unexpected ","
23:27:56 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
23:27:58 <dons> :)
23:28:03 <desrt> ...
23:28:09 <desrt> HASKELL, k thx :p
23:28:11 <psykotic> haha
23:28:23 <lispy> heh
23:28:24 <desrt> <lambdabot> error: asshat
23:29:45 <desrt> what is ap?  ($)?
23:29:52 <desrt> ?type ap
23:29:54 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
23:29:58 <desrt> oh my.
23:30:17 <desrt> that's twisted.
23:30:26 <desrt> does it run the computation for 'a' or 'a->b' first?
23:30:34 <psykotic> pretty natural. just an application inside a bind.
23:31:07 <lispy> ?where paste
23:31:08 <lambdabot> http://paste.lisp.org/new/haskell
23:31:17 <desrt> but it obviously evaluates both the function and its argument
23:31:20 <desrt> one must come first :)
23:31:56 <psykotic> oh, yes.
23:34:59 <dons> sjanssen: you think the record syntax is overkill for the short chameneos?
23:35:05 <dons> ?localtime sjanssen
23:35:07 <lambdabot> Local time for sjanssen is 2006-11-18 01:31:57 -0600
23:35:18 <sjanssen> dons: I'll still be up for a while
23:35:49 <sjanssen> it might be overkill
23:43:19 <sjanssen> dons: it seems that compiling with -threaded slows chameneos down quite a bit
23:43:50 <dons> interesting
23:43:57 <sjanssen> maybe locking on MVars uses a more expensive operation or something
23:44:32 <sjanssen> and adding +RTS -N2 speeds it up some, but not nearly enough
23:44:36 <dons> hmm. we should find out the info from Simon M
23:44:44 <dons> ah i should try on a big machine
23:46:27 <sjanssen> I'm not sure how much concurrency will help here
23:46:52 <sjanssen> there are only two MVars, I think they're the bottleneck
23:48:44 <Heffalump> morning
23:49:03 <dons> morning Heffalump
23:50:22 <dons> sjanssen: yeah, I get the same results, -threaded slows it down
23:50:31 <dons> quite a bit
23:50:46 <dons> and not all is recoved by adding -N2.. (on a 4 way machine)
23:52:33 <sjanssen> the sequence_ [yield | c <- subCols] line at the bottom frightens me
23:52:56 <dons> yeah. *weird*
