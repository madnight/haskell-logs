00:00:07 <zarvok> Well, I'm trying to code up a toy example of a queue, so what I want to write is:
00:00:12 <kosmikus> dons: yes, I tried to compile hmp3-1.0 with ghc-6.4.2 and it failed?
00:00:41 <dons> hmm. let me see..
00:00:53 <dons> using the tarball, or the darcs version?
00:00:59 <zarvok> data EQueue a = forall q . Queue {empty : q, insert : (a,q)->q, remove : q->(a,q)}
00:01:01 <pierre-> hello
00:01:04 <kosmikus> dons: tarball
00:01:10 <zarvok> But it won't let me use records inside the existential type
00:01:12 <zarvok> and I wonder why
00:01:19 <zarvok> where "it" means ghci
00:01:22 <kosmikus> zarvok: because they're difficult to type
00:01:52 <kosmikus> zarvok: GHC doesn't allow "first-class existentials", i.e., the word "exists" never occurs in types
00:02:47 <dons> kosmikus: "Could not find module `Data.FastPackedString'" ?
00:02:53 <kosmikus> but to type a record selector like "empty", you would need something like "forall a. Equeue a -> exists q. q
00:03:08 <kosmikus> dons: I'll repeat the experiment
00:03:48 <kosmikus> dons: iirc, it was a type error
00:03:54 <zarvok> I'm confused as to how a record is significantly trickier than an unlabeled product type, which works fine
00:04:08 <zarvok> but then, I don't know how haskell represents records
00:04:33 <kosmikus> zarvok: it's not an implementation issue, it only has to do with the type system
00:05:00 <dons> kosmikus: possibly you have installed a newer version of fps than hmp3 1.0 knew about, in which case I recommend using the darcs versions of hmp3 and fps together.
00:05:25 <kosmikus> zarvok: unlabeled products can only be opened via pattern matching; at that point the existentially quantified type variable can be bound to a new type constant (called skolem constant) for the scope of the case statement
00:05:48 <dons> the other option is to scroll back to fps 0.2 (I think) (I notice I didn't put an fps version constraint in the hmp3 1.0 cabal file)
00:05:52 <kosmikus> dons: oh, that's possible
00:06:15 <dons> the current darcs version of hmp3 does have a >= 0.7 constraint, however.
00:06:19 <zarvok> ah, I think I see
00:06:29 <dons> so version issues should be better handled in the future
00:07:06 <zarvok> because the return type from empty (somequeue) doesn't make sense
00:07:14 <zarvok> ?
00:08:03 <zarvok> doesn't make sense in the sense that I'm not allowed to know what it is, I mean
00:49:03 <Lokadin> say what's that alternative case form where you use a function on every instance
00:49:30 <ski__> say again ?
00:49:46 <Lokadin> something like, case e of { function | something -> what to do }
00:50:20 <Cale> case e of { pattern | optional guard -> value; pattern -> value; ... }
00:50:38 <Lokadin> oh that's probably it :) thanks
00:50:58 <Cale> and of course the braces and semicolons are both optional if you provide the right layout
00:51:40 <Lokadin> yep, .i'o
00:51:56 <Cale> Is that lojban?
00:52:35 <Lokadin> yep, means appreciation :)
00:53:03 <Lokadin> isCmavo e | True -> 
00:53:14 <Lokadin> assuming isCmavo is String -> Boolean
00:54:07 <Lokadin> is alright i'll try and see :) thanks for the help though
00:56:21 <ski__> that is incorrect syntax
00:56:47 <ski__> 'isCmavo e' is not a valid pattern
00:57:02 <ski__> do you want to do a "if-then-else-if-..." ?
00:57:43 <Lokadin> yea
00:57:56 <Lokadin> i'll do that then :) 
00:57:59 <Lokadin> thanks
00:58:21 <Lokadin> .i'o
00:59:37 <ski__> case () of { () | isCmavo e -> ... | isBlaha e2 -> ... }
00:59:53 <ski__> Lokadin : maybe that could appeal to you ..
01:00:29 <bolrod>  /win 12
01:00:30 <Lokadin> wow .ua.ue .i'osai thank 
01:00:32 <Lokadin> s
01:00:33 <Lokadin> :)
01:00:33 <bolrod> oops -.-
02:15:41 <nomeata> Hi. I have defined a new data type, representing Polynoms. Can I somhow make that an "Instance of Function", i.e. that I can use function syntax for it?
02:16:16 <nomeata> something lke "instance (Real -> Real) Polynom"
02:17:15 <Cale> nope
02:17:21 <Cale> but you can write an apply function
02:17:41 <Cale> and even give it an infix name
02:18:11 <nomeata> hmm, too bad. I can have an infix name that is the empty string? :-)
02:21:09 <dons> you might be able to make a smart constructor for your data type that might be an actual function (or just a tricky constructor for your type itself)
02:23:02 <dons> but its probably easiest to just define an infix # or something, that does application
03:35:46 <sm> morning all
03:36:20 <sm> trying to build HAppS & HaXML with ghc 6.4.1 I get a strange kind error:
03:37:38 <lisppaste2> sm pasted "kind error" at http://paste.lisp.org/display/21753
03:37:54 <sm> any ideas ?
03:39:45 <sm> I found http://cvs.haskell.org/trac/ghc/ticket/745 , but no enlightenment
03:39:46 <lambdabot> Title: "#745 (GHC should recover better from bad type signatures) - GHC - Trac"
03:42:24 <tessier> There seems to be no usenet newsgroup about haskell...interesting.
03:43:23 <Lemmih> SM_ax: What version of GHC and HaXml are you using?
03:43:46 <pharm> tessier: Want to author a request?
03:43:56 <Lemmih> sm: What version of GHC and HaXml are you using?
03:44:17 <sm> Lemmih: 6.4.1 and latest darcs version
03:45:14 <tessier> pharm: Not particularly. Would anyone really use it?
03:45:23 <tessier> pharm: Seems like mailing lists are the way most things go these days.
03:45:33 <sm> tessier: there are gmane groups
03:45:36 <sm> (hi)
03:45:53 <tessier> After many years away from usenet I decided to fire up a news reader just to see if usenet even really existed anymore. Sure enough, it's still there.
03:46:01 * tessier misses the old days :(
03:46:44 <tessier> My first time on usenet/internet was 17 years ago.
03:46:57 * JKnecht enjoys the new old days :)
03:47:37 <pharm> tessier: there are still plenty of people using usenet. Plus google groups actually makes it a useful resource...
03:47:55 <tessier> pharm: I can't get into using google groups. Too slow or something.
03:48:09 <tessier> I am using Pan now but I think I might fire up gnus. Been wanting to learn more about emacs anyhow.
03:48:16 <pharm> tessier: Oh, it's awful for actually *reading* usenet. Not bad for searching though.
03:48:21 <tessier> I used to use...slrn I think it was. ANd before that rn or something.
03:48:29 <tessier> pharm: Oh, right. Certainly
03:48:36 <pharm> comp.lang.functional gets a fair amount of haskell related traffic.
03:51:13 <Lemmih> sm: You could try with the latest stable version of HaXml.
03:51:29 <sm> I tried that first, 1.13
03:52:09 <sm> there's nothing obviously wrong with that class declaration, is there ?
03:53:04 <sm> I haven't been able to find a doc explaining what the error message really means
03:53:21 <Lemmih> sm: It looks normal.
03:53:30 <pharm> w
03:53:37 <Lemmih> sm: It should work with HaXml-1.13 (that's what I'm using).
03:53:38 * pharm oops
03:53:52 <sm> I'll try that again
03:54:03 <Lemmih> sm: It means that 'Element' is not applied enough type arguments.
03:54:20 <sm> I don't understand that
03:54:38 <Lemmih> > undefined :: Maybe
03:54:38 <lambdabot>    `Maybe' is not applied to enough type arguments
03:54:39 <lambdabot>   Expected kind `?', b...
03:54:41 <Lemmih> > undefined :: Maybe ()
03:54:42 <lambdabot>  Undefined
03:56:23 <sm> type argument would be.. x in this case ?
03:56:51 <Lemmih> No.
03:57:26 <Lemmih> The type argument is missing.
03:57:45 <isaacd> compiling nhc98 is failing: "HInteractive.hs:351:12: lexical error in string/character literal" -- using ghc-6.4.1
03:58:22 <sm> Lemmih: from that class declaration ?
03:59:09 <Lemmih> sm: It's not about the class. It's about Types.Element.
03:59:14 <isaacd> invoked by `ghc   -package lang -package util -package base   -i../hmake  -package lang -package util -package base -DUSE_READLINE=1 -lreadline -c -cpp -DUSE_READLINE=1  -o /home/isaac/build/nhc98-1.18/targets/740.750-Linux/obj/interpreter/HInteractive.o HInteractive.hs`
03:59:45 <Lemmih> isaacd: What's in HInteractive.hs at line 351?
04:00:02 <sm> I see, so I should look at the HaXML module eh..
04:00:15 <Lemmih> sm: You can use GHCi for that.
04:00:25 <nibro> \quit
04:00:35 <sm> how so ?
04:00:43 <Lemmih> sm: :i Text.XML.HaXml.Types.Element
04:00:51 <isaacd> Lemmih: banner = "\ 
04:00:59 <isaacd> With a space after the backslash
04:01:10 <isaacd> It uses string gaps
04:01:38 <isaacd> I'll paste a bit more context...
04:01:41 <isaacd> @where paste
04:01:41 <lambdabot> http://paste.lisp.org/new/haskell
04:02:04 <sm> thanks.. I don't know how to make ghci see Text.XML.HaXml yet, probably -idir I'm guessing
04:02:35 <sm> anyway, I told a lie about 1.13 - the problem I had there was conflict: module `Text.PrettyPrint.HughesPJ'    belongs to the current program/library and also to package base-1.0  during runhaskell Setup.hs build
04:02:47 <Lemmih> isaacd: Could it be a cpp/cpphs issue? I seem to recall that cpp doesn't like string gaps.
04:03:22 * sm has assumed it's best to use Setup.hs and not configure; make as some readmes suggest
04:03:43 <Lemmih> sm: Hm, try removing it from the HaXml.cabal file.
04:04:03 <isaacd> Lemmih: Indeed it does not, but the file seems to use the workaround of putting a space after the backslash at the end of the line, and it is getting a lot of warnings about that, as expected
04:04:08 <lisppaste2> isaacd pasted "part of HInteractive.hs" at http://paste.lisp.org/display/21754
04:04:47 * sm gets info for .Types.Element in ghci.. nice
04:07:42 <sm> this module isn't mentioned in HaXml.cabal.. it's imported by a bunch of them
04:07:56 <DukeDave> hi gang
04:08:56 <DukeDave> I was thinking, haskell program with a web interface, am I sane?
04:09:48 <lisppaste2> sm pasted "haxml build error" at http://paste.lisp.org/display/21755
04:10:28 <ndm> DukeDave: have you seen hoogle?
04:10:30 <ndm> @where hoogle
04:10:31 <lambdabot> http://www.haskell.org/hoogle
04:10:36 <ndm> thats written in haskell
04:10:38 <lisppaste2> sm annotated #21753 with "versions" at http://paste.lisp.org/display/21753#1
04:11:54 <DukeDave> good tip 
04:12:54 <Lokadin> say for some reason it's telling me that i can't take 1 xs, when xs is [String]
04:13:34 <ndm> Lokadin: you can, what is the exact error message?
04:13:38 <ndm> and the code that goes with it?
04:14:13 <Lokadin>     Couldn't match `Char' against `String'
04:14:13 <Lokadin>       Expected type: [Char]
04:14:13 <Lokadin>       Inferred type: [String]
04:14:13 <Lokadin>     In the second argument of `take', namely `xs'
04:14:13 <Lokadin>     In the second argument of `(++)', namely `(take 1 xs)'
04:14:15 <Lokadin> make: *** [all] Error 1
04:14:23 <Lokadin> unixOrder :: [String] -> [String]
04:14:23 <Lokadin> unixOrder (x:xs) = if x == "la" then drop 1 xs ++  x ++ ( take 1 xs ) else x ++ xs
04:14:32 <ndm> Lokadin: you probably want head xs
04:14:32 <isaacd> Lemmih: after a bit of testing, the problem does ultimately seem to be that cpp doesn't like string gaps.
04:14:46 <Lokadin> ndm: thanks :)
04:14:47 <ndm> take 1 xs returns you a list with one element in it, what you want is that element inside it
04:14:59 <ndm> and also you probably want tail rather than drop 1
04:16:05 <Lokadin> hmmm
04:16:23 <Lokadin> Couldn't match `String' against `Char'
04:16:23 <Lokadin>       Expected type: [String]
04:16:23 <Lokadin>       Inferred type: [Char]
04:16:23 <Lokadin>     In the expression: x ++ (head xs)
04:16:23 <Lokadin>     In the second argument of `(++)', namely `x ++ (head xs)'
04:16:48 <Lokadin> bah brb, i'm breaking out in hives cause of my cat
04:18:30 <ndm> Lokadin: if x == "la" then tail xs ++ [x, head xs]
04:19:48 <isaacd> Lemmih: is there some way I could just get ghc to run cpphs instead of the "standard" cpp while compiling nhc98? (that is, after I install cpphs!)
04:19:48 <Lokadin> hmmm thanks :)
04:19:56 <Lokadin> ndm: that makes sense! :)
04:20:16 <Lokadin> ndm: would it be possible to do [x] to? or would it have to be [x,""]
04:20:28 <ndm> [x] is fine
04:20:33 <ndm> [x,""] means something else
04:21:52 <arjanoosting> isaacd: -pgmP cmd, Use cmd as the C pre-processor (with -cpp only
04:22:00 <Lokadin> ndm: kk, .i'o thanks :) is much appreciated
04:22:35 <isaacd> arjanoosting: well, if I can figure out how to change the makefiles or whatever it is nhc98 uses
04:25:42 <johnie> Does there currently exist a _quality_ library for reading XML files? I just want to give the library a DTD, and get the relevant data out of it. 
04:25:59 <ndm> isaacd: any particular reason for wanting to compile nhc98, have you seen Yhc?
04:26:43 <Lokadin> when it says expected type, does that mean it's the type it should be? and the inferred type is the one it actually is, or the other way around?
04:27:03 <Cale> johnie: There's some stuff that looks excellent, though I've never used it myself
04:27:06 <Lokadin> s/,/./
04:27:36 <arjanoosting> johnie: take a look at HaXml, http://www.cs.york.ac.uk/fp/HaXml/
04:27:38 <lambdabot> Title: "HaXml: Haskell and XML"
04:27:57 <Cale> and the Haskell XML Toolbox
04:28:02 <Cale> which looks really extensive
04:28:06 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/
04:28:08 <lambdabot> Title: "Haskell XML Toolbox 5.5"
04:28:20 <johnie> arjanoosting: Did you use it?
04:28:27 <isaacd> ndm: I think I wanted to test my code with a variety of Haskell compilers to make sure it worked with them (and it currently uses mutually recursive modules)
04:28:34 <arjanoosting> johnie: yes
04:28:35 <Lokadin> so Expected type is the one that was necessary for it to work..
04:28:55 <johnie> arjanoosting: And it worked smoothly?
04:30:04 <Cale> I think the Haskell XML Toolbox is a derivative of HaXML
04:30:20 <Cale> ah, and HXML apparently
04:30:40 <arjanoosting> johnie: i used DtdToHaskell to generate a Haskell module of the DTD for reading and writing 
04:30:55 <arjanoosting> johnie: worked ok for me
04:31:05 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/index.html
04:31:52 <vincenz> O.OO
04:31:54 <vincenz> HOLY crap
04:31:58 <vincenz> http://tgmandry.blogspot.com/2006/06/worlds-largest-foss-irc-network.html
04:32:00 <lambdabot> Title: "Regular Ramblings"
04:32:21 <Cale> Is that about the freenode insecurity thing?
04:32:36 <Cale> yeah
04:32:43 <Cale> You didn't notice that?
04:32:44 <vincenz> yeah
04:32:47 <vincenz> no
04:32:55 <vincenz> it's scray
04:32:57 <vincenz> scary
04:33:16 <johnie> arjanoosting, Cale: thank you
04:33:18 <Cale> meh, I don't care that much about my IRC account.
04:33:34 <vincenz> should I nick-register?
04:33:56 <johnie> vincenz: not in #haskell 
04:33:58 <vincenz> Cale: it's sitll impressive, and even then, not caring about IRC account
04:34:03 <sm> what does the (..) of SomeType(..) mean in a module declaration ?
04:34:07 <vincenz> johnie: no duh ?
04:34:08 <madpickle> wow
04:34:13 <vincenz> Cale: they could've taken the whole FOSS network down
04:34:17 <Cale> vincenz: I'm identified.
04:34:23 <vincenz> Cale: many projects rely on this medium as the main place for collaboration
04:34:35 <vincenz> well for communication at least
04:34:43 <Spark> nah
04:34:46 <Spark> one hacker
04:34:51 <johnie> vincenz: then maybe they need to switch protocol. 
04:34:51 <Spark> who doesnt have the keys to the server cabinet
04:34:56 <Spark> cant achieve very much
04:35:11 <isaacd> sm: it means export all constructors of that type
04:35:13 <Spark> most projects have a mailing list as well as an irc channel though
04:35:15 <vincenz> Spark: did you read the article?
04:35:23 <sm> ah, thx
04:35:24 <Spark> yeah
04:36:03 <vincenz> on that note
04:36:07 <vincenz> who sponsors freenode?
04:36:07 <Spark> if channels get taken over, people go to opers, passwords get reset
04:36:11 <Spark> everything back to normal
04:36:17 <Spark> i think dos attacks are more damaging
04:36:24 <Spark> they produced a sustained problem
04:36:27 <vincenz> Spark: it was not the channels it was the actual server that was taken over
04:37:02 <Spark> root?
04:37:09 <Spark> even if so, one server to reinstall
04:37:26 <Cale> Spark: yeah, the server was rooted or otherwise compromised, right, it's not a permanent deal
04:37:36 <Spark> debian got worse
04:37:42 <Spark> they had to rebuild all their packages :)
04:37:46 <Spark> (presumably)
04:38:42 <Cale> Do they give O-lines on this network to people who aren't running physical servers?
04:39:26 <madpickle> probably
04:39:33 <madpickle> people who are running servers usually have O:Lines on their own
04:42:27 <vincenz> j #oasis
05:57:17 <sm> well I'm really stumped by this haxml/happs kind error
05:57:48 * sm meditates on "`Text.XML.HaXml.Types.Element' is not applied to enough type arguments"
06:05:34 <ski__> (what kind does it have ?)
06:07:27 <lisppaste2> sm annotated #21753 with "definition of Element" at http://paste.lisp.org/display/21753#2
06:07:50 <sm> I don't know, does this page help ?
06:08:22 <Bacta> can i wash my wanky in ur sinky?
06:09:22 <Bacta> i need sexual healing
06:09:25 <Bacta> oooooooooooooooooooooooh baby
06:09:29 <Bacta> im hot just like an oven
06:09:32 <Bacta> i need some loving
06:09:42 <Bacta> when i get that feeling i want sexual heeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeling
06:09:46 <Bacta> oooooooooooooooooooooooooooooooooooooooooooh baby
06:10:07 * earthy pulls up an eyebrow
06:10:14 <Bacta> sex
06:10:14 <Bacta> sex
06:10:15 <Bacta> sex
06:10:15 <Bacta> sex
06:10:16 <Bacta> sex
06:10:16 <Bacta> sex
06:10:17 <Bacta> sex
06:10:18 <Bacta> sex
06:10:35 * Bacta thinks about all the bad karma this trolling will give him.
06:10:50 <bolrod> @karma- Bacta 
06:10:50 <lambdabot> Bacta's karma lowered to -1.
06:10:52 * earthy gives bacta some haskell dancers.
06:10:55 <bolrod> @karma- Bacta 
06:10:55 <lambdabot> Bacta's karma lowered to -2.
06:10:56 <earthy> @karma- Bacta
06:10:56 <lambdabot> Bacta's karma lowered to -3.
06:11:02 <madpickle> @karma- bacta
06:11:03 <lambdabot> bacta's karma lowered to -1.
06:11:07 <madpickle> lmao
06:11:10 <bolrod> @karma- Bacta 
06:11:10 <lambdabot> Bacta's karma lowered to -4.
06:11:11 <madpickle> it's not case insensitive
06:11:14 <madpickle> there's a bug =)
06:11:18 * earthy laughs
06:11:25 <bolrod> blah...   case sensitive!
06:11:35 <bolrod> @karma- bacta 
06:11:36 <lambdabot> bacta's karma lowered to -2.
06:11:38 <bolrod> @karma- bBacta 
06:11:38 <lambdabot> bBacta's karma lowered to -1.
06:11:40 <bolrod> @karma- Bacta 
06:11:40 <lambdabot> Bacta's karma lowered to -5.
06:11:42 <bolrod> see
06:13:02 <isaacd> sm: should it be this (applying Types.Element to x at the end)?: class ToElement x where toElement::x->Types.Element x
06:14:07 <isaacd> Although I admit I don't understand what it's supposed to do...
06:17:52 <sm> isaacd: not clear on that yet.. too many different versions & paths going on here
06:18:04 <sm> thx for the idea
06:26:16 <sm> isaacd: that's exactly what was needed, on that line at least.. at last, I see what it meant!
06:36:52 <DukeDave> does anything like cpan exist for haskell ?
06:39:01 <DukeDave> further, has anyone here successfully installed WashNGo ?
06:42:27 * sm resolves cabal version breakage and successfully builds HAppS with HaXml 1.13
06:42:31 <sm> thanks all!
06:43:23 <sm> DukeDave: http://haskell.org/haskellwiki/Libraries_and_tools
06:43:25 <lambdabot> Title: "Libraries and tools - HaskellWiki"
06:44:11 <sm> and there is http://hackage.haskell.org/ModHackage/Hackage.hs?action=home
06:44:31 <DukeDave> excellent service as always :)
06:45:31 * mux realizes the HXT never answered his mail with the patch for the cabal description
06:45:39 <mux> s/HXT/& guy/
06:48:16 * sm links the latter on the former.. seems to be just getting started though
07:19:32 <bleicher> @type (+)
07:19:34 <lambdabot> forall a. (Num a) => a -> a -> a
07:19:53 <bleicher> nice
07:24:32 <vincenz> hehe
07:24:40 <vincenz> nerdy email-invitations rule
07:45:41 <jberg_> what is this "visual haskell" ghc has?
07:46:03 <fanopanik> a plugin for Visual Studio 2003
08:15:29 <bolrod> @type (-)
08:15:30 <lambdabot> forall a. (Num a) => a -> a -> a
08:15:32 <bolrod> @type (-1)
08:15:33 <lambdabot> forall a. (Num a) => a
08:15:49 <bolrod> :)
08:16:03 <bolrod> @type (- 1)
08:16:04 <lambdabot> forall a. (Num a) => a
08:17:02 <xerox> ?type subtract 1
08:17:03 <lambdabot> forall a. (Num a) => a -> a
08:17:23 <bolrod> @type  map (foldr map)
08:17:24 <lambdabot> forall b. [[b]] -> [[b -> b] -> [b]]
08:17:28 <bolrod> :]
08:17:51 <bolrod> lets see..
08:19:22 <bolrod> >  map (\x ->zipWith ($) x (replicate 5 x [1..5]))  $ map (foldr map) $ [replicate 5 [1..5]] 
08:19:23 <lambdabot>    The function `replicate' is applied to three arguments,
08:19:23 <lambdabot>   but its type...
08:19:35 <bolrod> >  map (\x ->zipWith ($) x (replicate 5 [1..5]))  $ map (foldr map) $ [replicate 5 [1..5]] 
08:19:36 <lambdabot>  Couldn't match `[[a] -> b]' against `[[a1] -> [a1]] -> [[a1]]'
08:19:55 <bolrod> >  map (\x ->zipWith ($) (replicate 5 [1..5]) x)  $ map (foldr map) $ [replicate 5 [1..5]] 
08:19:56 <lambdabot>  Couldn't match `b1 -> b' against `[a]'
08:19:59 <bolrod> blah..:P
08:41:34 <Phas> there are any news on the #haskell get-togheter ?
08:42:14 <palomer> rumour has it it'll be in montreal
08:42:52 <xerox> Lies!
08:43:11 <Phas> i'm more interested on WHEN will be
08:43:42 <Phas> for me Amsterdam is cool, 'cause there are some low cost flight from Genova
08:44:18 <Phas> but i will be busy on the ond of July
08:44:39 <Phas> i hope it will not be on these days
08:45:26 <bolrod> omg amsterdam!.. that's like 30 km from here :)
08:47:52 <xerox> Hurray for Amsterdam.
08:50:41 <bolrod> :o
08:51:15 <BCoppens> pffft, 3 hours by train ;P
08:57:53 <Phas> Amsterdam > *
08:58:29 <Phas> (but, it'll be someone able to listen and speak if the meeting will be in amsterdam?)
09:03:04 <bolrod> amsterdam.. pff .. 1 hour by bike
09:03:07 <bolrod> :X
09:06:57 <jberg_> i've installed haskell-mode for emacs, and i hit C-c C-z which opens a new window with ghci, but is there a way to load a file or a function directly in to ghci?
09:10:49 <jgrimes_> jberg_: haskell-ghci-load-file and haskell-ghci-reload-file
09:11:50 <jgrimes_> jberg_: which are C-l and C-r
09:12:16 <jgrimes_> jberg_: erm, C-c-l, C-c-r
09:12:31 <DukeDave> 112ms by tcp/ip  :)
09:12:35 <jberg_> ok thanks. is there some documentation on this?
09:13:24 <koffein> "documentation" for emacs modes can be found in the source files
09:13:52 <jgrimes_> jberg_: yeah, I don't know of any other than the elisp file :)
09:14:36 <jgrimes_> files, even.
09:15:07 <jberg_> ok
09:15:59 <jberg_> can you unload a file too? so you get back to prelude?
09:18:04 <dmhouse> jberg_: You mean in GHCi?
09:18:12 <dmhouse> jberg_: If so, just :m with no arguments will do it.
09:22:02 <jberg_> thanks
10:28:06 <kaol> how could I do IO multiplexing (ie. select(2) equivalent)? I didn't spot anything appropriate in System.IO at least.
10:29:49 <kaol> okay, I think I could find something myself too from the plentiful documentation around... Feel free to ignore that last one.
10:30:59 <kaol> or would it make sense to use concurrent haskell instead?
10:31:05 <mux> yes
10:31:13 <mux> I've been asking the very same question as you when I learnt Haskell
10:31:34 <sm> I believe it's done in HAppS
10:31:44 <mux> you should look at concurrent haskell, and more specifically forkIO(), MVars, Chans etc
10:32:47 <mux> haskell's built-in threads are supposed to be very, very lightweight
10:32:55 <Rizenine> Hi all.
10:33:18 <dmhouse> Hey Rizenine.
10:35:07 <Rizenine> Been playing with Haskell under GHC, looks really cool.
10:35:35 <Rizenine> I've been programming Java for so long I'm wanting to learn another language.
10:39:24 <Rizenine> How well suited is haskell for gui app development. I see it talks about using monads in stuff like gtk wx. any qt?
10:39:34 <Rizenine> Does it interface will with C?
10:40:06 <kaol> so, concurrency works out of box with the ghc in Debian? (and sorry for the silly question)
10:44:22 * kaol stops asking questions that he already knows the answer for
10:44:47 <Rizenine> kaol: you new to haskell?
10:48:01 <kaol> Rizenine: quite so
10:48:16 <xerox> dons: you will like this one http://www.df.lth.se/~lft/vim/mandelbrot - I think it is sick.
10:48:30 <Rizenine> kaol: I've not every used it. Just started looking a couple days ago.
10:48:47 <Rizenine> kaol: Been working through the docs on the site.
10:51:17 <kaol> Haskell's different from the C++ and Perl that I've been mostly coding... Though playing around with Mozart has already taught me to appreciate not having to change state destructively.
10:51:24 <bolrod> xerox: how does it work?
10:51:29 <xerox> Good question.
10:51:59 <bolrod> I mean.. how do I start this something mandelbrot?
10:52:00 <bolrod> :P
10:52:06 <dmhouse> Rizenine: what do you think so far?
10:52:20 <Rizenine> kaol: Mozart?
10:52:43 <dmhouse> xerox, what's that?
10:52:53 <Rizenine> dmhouse: I like the idea. But I'm wondering about features.
10:53:19 <dmhouse> Rizenine: what do you mean?
10:53:26 <Rizenine> dmhouse: Like having enough api's to get the job done.
10:53:35 <bolrod> xerox: ?
10:53:39 <kaol> Rizenine: http://www.mozart-oz.org/
10:53:39 <Rizenine> dmhouse: maybe api's in not the write way to say it.
10:53:41 <lambdabot> Title: "The Mozart Programming System"
10:54:09 <dmhouse> Rizenine: As in, not enough support for external libraries (e.g. databases)?
10:54:26 <Rizenine> dmhouse: Like if I want to build a windows gui app, then turn around and create a unix one, does it offer those api's to do it.
10:55:06 <Rizenine> dmhouse: like with Java I can develop on any platform, but I don't get to use the rich features of those platform. 
10:55:12 <dmhouse> It is true that some Haskellers are more interested in inward development of the language rather than writing practical code, but that's just a testament for the depth and beauty of the theory behind Haskell.
10:55:46 <Rizenine> lambdabot: k
10:56:04 <dmhouse> Rizenine: gtk2hs is a portable GUI lib, based on (hence the name) GTK.
10:57:13 <kaol> @botsnack
10:57:13 <lambdabot> :)
10:57:16 <bolrod> xerox: !?!
10:58:17 <bolrod> damnit -.-
10:58:40 <Rizenine> dmhouse: I say that. Probably should look into it more, before asking questions. But on that for example, does it carry the full capabilities as GTK has to offer?
10:58:58 <dmhouse> Rizenine: it's a direct binding to GTK, irrc.
10:59:00 <dmhouse> *iirc
10:59:26 <Rizenine> dmhouse: k.
10:59:37 <Rizenine> dmhouse: like it said, I'm very new. 
10:59:58 <dmhouse> Sure.
11:00:06 <Rizenine> dmhouse: I'm just wanting to try something new. I'm not sure how far I'd go with it.
11:00:28 <dmhouse> Rizenine: It's a sharp learning curve, but for me at least it's the most rewarding language I've ever learnt.
11:01:12 <Rizenine> dmhouse: I just think something like and FP language would be cool to learn.
11:01:30 <Rizenine> dmhouse: all the stuff about less bugs and more productivity.
11:01:54 <wolverian> my haskell lines per hour is still pitiful, but it's great fun :)
11:02:03 <dmhouse> Right. Less bugs is _definitely_ true. Productivity will get you a while to build up.
11:02:25 <dmhouse> The Haskell mantra is "if it typechecks (i.e. compiles), it'll work" :)
11:02:40 <wolverian> productivity depends on the context, as well. haskell doesn't have as many libraries as some languages (e.g. perl). 
11:02:49 <wolverian> (admittedly it has the most important ones.)
11:03:05 <Rizenine> wolverian: ya, libraries is what I was getting at.
11:03:27 <Rizenine> With Java you have library heaven.
11:03:35 <Rizenine> Almost to many.
11:03:38 <wolverian> it'll be better when hackage works, I assume.
11:03:45 <dmhouse> Yep.
11:03:56 <Rizenine> Spend more time wondering if you should use it or build it your self.
11:04:04 <dmhouse> Once xerox get's his act together (:P), cabal-get will revolutionalise building software with Haskell.
11:04:13 <Rizenine> wolverian: hackage?
11:04:14 <bolrod> xerox: yo!  what is it supposed to do?
11:04:26 <mathias> Rizenine: "Library heaven"? You mean data-base code and GUI code? 
11:04:37 <Rizenine> dmhouse: cabal?
11:05:12 <dmhouse> Cabal is a way for packaging up Haskell software, and provides a standardised way of installing the software.
11:05:14 <Rizenine> mathias: well all of it. 
11:05:19 <wolverian> Rizenine, hackage is a repository of libraries, like CPAN. cabal is a packaging architecture for haskell projects. cabal-get is the equivalent of apt-get for haskell.
11:05:31 <jgrimes_> bolrod: it's supposed to draw mandelbrot in ASCII
11:05:32 <mathias> Rizenine: Where's a planarity testing algorithm?
11:05:39 <dmhouse> Sadly there's not centralised DB of Cabal packages at the moment, which is what Hackage will be.
11:05:42 <mathias> Rizenine: Or parser combinators?
11:05:49 <jgrimes_> bolrod: it's a vim script
11:05:53 <dmhouse> And cabal-get is the corresponding installer.
11:05:59 <xerox> bolrod: wait a second.
11:06:03 <bolrod> how do I run a vim script?
11:06:19 <Rizenine> mathias: Hum, well...
11:06:20 <dmhouse> Well, s/installer/automated downloader and installer/
11:06:28 <jgrimes_> bolrod: no idea. :)
11:06:29 <xerox> I've recorded it.
11:06:41 <bolrod> xerox: how do I run a vim script?
11:06:43 <mathias> Rizenine: Java has a lot of "libraries" created by people that have no clue of how to make them. 
11:07:03 <Rizenine> mathias: http://www.infosun.fmi.uni-passau.de/GTL_java/docu/classes/gtl/algorithms/Planarity.html
11:07:04 <bolrod> :P
11:07:07 <xerox> bolrod: READ it.
11:07:15 <lambdabot> Title: "GTL_java API: Class Planarity"
11:07:15 <dmhouse> Rizenine: if you've used Ruby, cabal-get/hackage = gems.
11:07:16 <bolrod> O_O I did!
11:07:17 <xerox> Or watch my video (I'm uploading)
11:07:27 <Rizenine> mathias: That may be, but any language that become popular will.
11:07:37 <bolrod> what's this   GY@ thing... :/
11:07:55 <xerox> Do as it says.
11:07:57 <bolrod> oh wait
11:08:04 <mathias> bolrod: type it
11:08:18 <xerox> It's written.
11:08:24 <bolrod> yes yes  I didn't see the "
11:08:25 <bolrod> >_>
11:08:58 <bolrod> how long does this take :P
11:09:06 <mathias> Rizenine: true, and about that planarity thing: it's research code and thus probably not correct. 
11:09:42 <Rizenine> mathias: I guess that's probably why I spend so much time researching api's to see if there any good. 
11:09:52 <Rizenine> mathias: get crazy.
11:10:04 <xerox> http://www.df.lth.se/~lft/obfuscation/symlinks/index.html
11:10:09 <lambdabot> Title: "Symbolic links"
11:10:10 <mathias> Rizenine: get crazy?
11:10:16 <Rizenine> mathias: Don't know. I just googled it for ya :)
11:10:25 <mathias> Rizenine: That's a good heuristic. 
11:10:35 <Rizenine> *gets crazy.
11:10:46 <mathias> Rizenine: I already thought you did. 
11:10:58 <lispy> @hoogle mapMaybe
11:10:59 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
11:11:11 <xerox> Man, that's even more sich!
11:11:13 <xerox> *sick
11:11:15 <xerox> http://www.df.lth.se/~lft/obfuscation/symlinks/index.html
11:11:16 <lambdabot> Title: "Symbolic links"
11:11:22 <lispy> ghc 6.5 claims that mapMaybe is hidden
11:11:24 <mathias> xerox: Did you figure out whether it actually computes something useful?
11:11:38 <xerox> Sure, it plots the mandelbrot set.
11:11:42 <lispy> anyone know why ghc would say that?
11:11:54 <xerox> Turn your head for you right ear to touch the corresponding shoulder.
11:12:49 <bolrod> how long is this mandelbrot going to take.. nothing is really forming in any way..
11:14:03 <mathias> xerox: Is the hole in the middle the corresponding hole of mandelbrot?
11:14:17 <xerox> Stretch your eyelids :)
11:14:59 <dmhouse> lispy: Got a specific error
11:15:00 <dmhouse> ?
11:16:00 <lispy> C:\projects\temp\HaskellApp2\src\Excel.hs(29): Could not find module `Maybe':   it is a member of package haskell98-1.0, which is hidden 
11:16:04 <bolrod> seriously.. nothing is going on here :P 
11:16:12 <dmhouse> lispy: ghc-pkg list
11:16:18 <dmhouse> lispy: pastebin the output of that
11:16:21 <lispy> dmhouse: but something is fishy here
11:16:29 <xerox> lispy: maybe change haskell98 with base.
11:16:31 <lispy> dmhouse: i commented that line out and i'm still getting the error :(
11:16:48 <bolrod> oh wait..
11:16:58 <bolrod> ic -.-
11:21:31 <lisppaste2> lispy pasted "FFI compile error" at http://paste.lisp.org/display/21776
11:22:04 <lispy> i looked at the lines before that line and they look fine to me
11:22:15 <lispy> plus this module is autogenerated by h/direct
11:22:17 <xerox> lispy: -fffi
11:22:30 <xerox> I think.
11:22:36 <lispy> xerox: hmm...but i have other imports that are compiling
11:22:47 <lispy> xerox: do you happen to know the comment to turn that on?
11:22:50 <xerox> Ah, hm.
11:23:06 <xerox> {-# OPTIONS_GHC -fffi #-} ?
11:23:35 <lispy> i'll try that
11:24:06 <lispy> that didn't seem to do anything
11:24:52 <Igloo> lispy: What's above that?
11:26:32 <lisppaste2> lispy annotated #21776 with "what's before the bad code" at http://paste.lisp.org/display/21776#1
11:30:18 <Igloo> lispy: Works for me. Try with -fffi on your commandline
11:31:00 <lispy> i restarted visual haskell and taht file seems to be compiling now
11:31:15 <lispy> so i guess adding that comment did help, i just needed to restart
11:31:32 <Igloo> (pragma, not comment)
11:31:56 <lispy> hmm...or not, i think visual haskell might be buggy :)
11:32:11 <lispy> i thought I added it to the file with the problem, but actually i added the pragma to a different file
11:32:20 <lispy> but now the file i added it to is having problems
11:39:12 * lispy goes with the  pragmitic solution for now and comments out the functions which don't compile (and he doesn't expect to need them)
11:44:28 <lispy> hmm...i told the .cabal file that ffi was an extension and i'm making it to new errors
11:44:59 <postman> I have access to a program written in Java, which generates too much information in a horrible XML format. What would be the smartest thing to do: strip the useless generating code from the code and turn the XML into a simple format? Or just don't touch the original program and parse the full xml and filter the information I need?
11:44:59 * lispy feel silly but confused
11:46:01 <bolrod> http://www.flabber.nl/archief/016780.php   << watch the middle one.. and then the lower one ;p
11:46:04 <lambdabot> Title: "Flabber.nl | Totally Flabbergasted Weblog: Wanneer een Komeet de Aarde raakt..."
11:46:12 <lispy> postman: the nice thing about xml is that someone already built you a  parser...is the performance bad because fo the excessive output?
11:50:02 <postman> lispy: Good question. About max(2^10*n) (n typically 50-100) useless values are created per thing the program outputs. This implies that at least I need to strip the XML a bit. For the rest you would suggest parsing the full XML?
11:51:48 <lispy> postman: well, you could try it and see how it goes (i'm guess it's easy to get a parser up and runnig)
11:52:05 * lispy has no concrete advice here :)
11:54:59 <postman> lispy: Hmm, maybe this was yet another premature optimization. I will do the parser first. Thanks
11:55:41 <Phas> anyone knows how to evaluate an integral in haskell
11:58:05 <dmhouse> Phas: try googling for a Haskell algebra system.
12:03:34 <bringert_> Phas: maybe there is something on http://haskell.org/haskellwiki/Libraries_and_tools/Mathematics
12:03:35 <lambdabot> Title: "Libraries and tools/Mathematics - HaskellWiki"
12:16:22 <ptolomy> I keep finding places in my C# code where monads would be appropriate.
12:24:53 * CosmicRay wonders if anyone is considering moving #haskell to OFTC yet
12:25:19 <bolrod> ?
12:25:30 <CosmicRay> due to general freenode suckage
12:26:42 <dmhouse> OFTC?
12:27:49 <fanopanik> oftc.net
12:28:14 <fanopanik> like freenode, but smaller and without levin.
12:28:36 <dmhouse> I see.
12:28:46 <CosmicRay> "without levin" == "without general freenode suckage", IMHO
12:28:52 <fanopanik> yes.
12:29:04 <CosmicRay> OFTC is a democratic organization and seems to be an irc network with a clue
12:30:00 <fanopanik> don't know about that, but the admins never sent me a notice in months, compared to 5-10 per day, and the server had no noticable downtime either.
12:31:23 <fanopanik> ok, 5-10 is maybe too much. average must be somewhere between 2 and 5.
12:33:11 <CosmicRay> and they aren't collecting "donations" to pay for the network manager's apartment.
12:34:35 * Igloo joins #haskell/#darcs on OFTC when I remember, but without other people there not much happens  :-)
12:35:14 <CosmicRay> Igloo: I guess you have to publicize the fact that people may be there ;-)
12:35:33 <Igloo> I did a while ago; kosmikus idled with me for a bit but that was about it  :-)
12:36:01 <Igloo> #darcs ownership could do with being rescued too, but I haven't been motivated to try yet
12:59:48 <xerox> ?yow!
12:59:49 <lambdabot> I'm also pre-POURED pre-MEDITATED and pre-RAPHAELITE!!
13:00:10 <xerox> ?yow!
13:00:10 <lambdabot> Everybody is going somewhere!!  It's probably a garage sale or a
13:00:10 <lambdabot> disaster Movie!!
13:33:09 <RyanT5000> is there active work on TH? i'm wondering if, in the near future, i will be able to use TH and profiling at the same time
13:45:39 <dmhouse> Huh. There's an advert for a trance CD on TV and one of the bands were called 'System F'.
13:46:04 <dmhouse> Is this an attempt to make type theory more relevant to today's teenagers? :)
13:47:02 <cjay> :)
13:47:23 <RyanT5000> lol
13:47:34 <zarvok> dmhouse:  I tried to write a good existentials oop example, but ghc doesn't allow records in existential types :(.  I'll try a different method later
13:47:44 <dmhouse> zarvok: Ah, that's a shame.
13:48:09 <dmhouse> zarvok: you might want to check out OOHaskell. It simulates OOP using typeclasses and existentials, I thinkg.
13:48:36 <zarvok> yeah, thanks
13:56:24 <iron32> Anyone know of a good tutorial on Hunit ?
13:56:29 <mattam> hmm, what's a partial list ?
13:57:10 * mattam 's reading Graham Hutton's paper on fold: http://www.cs.nott.ac.uk/~gmh/fold.pdf
13:57:51 <dmhouse> mattam, what's the context?
13:58:16 <dmhouse> A partial list is one that ends in _|_.
13:58:27 <dmhouse> (Quoting a recent [Haskell] thread.)
14:02:06 <monochrom> Perhaps like 1:1:1:undefined ?
14:03:01 <mattam> ok
14:03:27 <mattam> smthg 'can be generalized to partial and infinite lists'
14:03:46 <dmhouse> Right, then yeah, partial lists are those ending in _|_.
14:03:56 <dmhouse> And infinite lists are those that don't end. :)
14:04:03 <iron32> I love partial applications saves so many bloody keystrokes
14:04:30 <monochrom> Yeah, certain routines work as expected for them, e.g., map.
14:04:55 <RyanT5000> now we just need built-in partial evaluation :)
14:05:18 <RyanT5000> sum = !(foldl (+))
14:05:34 <jrmole> what is the bang there for?
14:05:43 <RyanT5000> !(asdf) means "evaluate asdf at compile-time"
14:05:49 <RyanT5000> different from $() though
14:06:32 <jrmole> ghci doesn't accept either... is this proposed or actual syntax?
14:06:33 <mattam> ghc do that i suppose
14:06:34 <mattam> isn't ! for strictness instead ?
14:06:39 <RyanT5000> proposed
14:06:44 <jrmole> by whom?
14:06:46 <RyanT5000> i just invented it
14:06:47 <RyanT5000> lol
14:06:55 <jrmole> it doesn't seem necessary
14:06:56 <RyanT5000> it was just intended as a vague illustration
14:06:57 <RyanT5000> it is
14:07:01 <dmhouse> RyanT5000: that'd likely clash with bang patterns.
14:07:11 <dmhouse> Actually, ignore I said that.
14:07:14 <jrmole> how should that differ from sum = foldl (+)
14:07:16 <RyanT5000> dmhouse: i'm not married to the ! - it could be % for all i care
14:07:34 <RyanT5000> jrmole: it's promising that the partial evaluation won't do anything that screws you up at compile-time
14:07:35 <RyanT5000> e.g.: hang
14:07:36 <dmhouse> RyanT5000: and how do you evaluate a closure?
14:07:54 <RyanT5000> dmhouse: that's for GHCi people to figure out - but certainly for some closures it can be done
14:08:04 <RyanT5000> it could just be inlining
14:08:05 <sieni> RyanT5000: and shouldn't that be like foldl (+) 0 or something?
14:08:14 <RyanT5000> sieni: yes, i meant foldl1
14:08:17 <jrmole> it seems like this is all stuff that the compiler should infer, and shouldn't really be part of the language
14:08:26 <sieni> RyanT5000: but that doesn't work
14:08:31 <mattam> RyanT5000: you may be wrong in saying it won't possibly hang at compile time :)
14:08:36 <sieni> > foldl1 (+) []
14:08:37 <lambdabot>  Exception: Prelude.foldl1: empty list
14:08:42 <sieni> > sum []
14:08:43 <lambdabot>  0
14:08:48 <RyanT5000> fine, that wasn't the point though
14:08:49 <RyanT5000> lol
14:08:59 <RyanT5000> %(foldl (+) 0)
14:09:16 <RyanT5000> everyone happy with my hacked-together vague example yet?
14:09:28 <RyanT5000> the reason you need it is because the compiler can't just try evaluating stuff at compile time
14:09:34 <RyanT5000> because it might hang
14:09:49 <RyanT5000> but if you tell it it won't hang, then the burdon's on you
14:09:56 <RyanT5000> *burden
14:09:57 <mattam> well, having pragmas and the like seems ugly
14:10:18 <RyanT5000> besides, hanging isn't the only nasty thing you can do to the compiler; you might have a function that uses unsafePerformIO
14:10:33 <mattam> you're the nasty one :)
14:10:36 <RyanT5000> yeah, it's ugly, but so are most optimization-related things (as obviously partial evaluation is)
14:10:37 <dmhouse> RyanT5000: that's basically seq, no? I still don't understand how it's meant to work with closures.
14:10:40 <jrmole> well in that case you get what you deserve ;)
14:10:43 <sieni> > foldl1 (+) $ (++) [0] [1..10]
14:10:44 <lambdabot>  55
14:10:49 <sieni> > foldl1 (+) $ (++) [0] []
14:10:50 <lambdabot>  0
14:10:55 <palomer> there's no excuse for ugliness.
14:11:01 <palomer> (except maybe genetics)
14:11:14 <mattam> :p
14:11:25 <jrmole> haskell must remain a beautiful language ;)
14:11:30 <RyanT5000> dmhouse: let's say you have f b = if b then do some_stuff else do some_other_stuff
14:11:54 <RyanT5000> now, if you say f True, presumably the compiler can weed out half of that function when it inlines it
14:12:09 <RyanT5000> but let's say it's really f x, where x is some complex expression
14:12:16 <RyanT5000> maybe x can be evaluated at compile-time, but GHC can't tell that
14:12:36 <mattam> if x isn't a constant i can't see how it could be
14:12:47 <dmhouse> Ah, clever.
14:12:48 <RyanT5000> mattam: what if x is a complicated constant?
14:12:59 <mattam> then ghc should be able to do it
14:13:09 <RyanT5000> right, but it can't tell that it can do it
14:13:15 <RyanT5000> unless you give it literally True or False
14:13:19 <mattam> kildall plus some partial evaluation
14:13:43 <dmhouse> RyanT5000: but what's that got to do with partial application? :)
14:13:54 <sieni> @pl (\x->(head x, tail x))
14:13:54 <lambdabot> liftM2 (,) head tail
14:13:58 <mattam> propagation of constants has been studied for some time
14:13:59 <sieni> cool
14:14:14 <xerox> sieni, I like (head &&& tail) for that :)
14:14:34 <sieni> xerox: :-P
14:15:04 <dmhouse> liftM2 (,) = (&&&), in fact.
14:15:16 <RyanT5000> mattam: what if x is generaated by TH
14:15:28 <xerox> 'cept (&&&) type is more general.
14:15:33 <RyanT5000> anyway
14:15:56 <RyanT5000> i'd love it if this could be automatic
14:16:20 <RyanT5000> so i wouldn't complain either way
14:16:38 <mattam> don't know about TH, but if you had a proper meta/staged language that wouldn't be a problem :)
14:16:48 <RyanT5000> however there could still be an annotation "give me a warning if this doesn't get evaluated at compile-time"
14:16:54 <mattam> ie, you would have this operator
14:17:15 <RyanT5000> yeah TH shouldn't be a problem; that occurred to me right after i said it
14:18:36 <mattam> actually a generalization of this 'eval at compile time' operator is staged languages.
14:18:43 <RyanT5000> right, i know that
14:18:57 <mattam> hence your problem is half solved :)
14:18:59 <RyanT5000> however, it's not usually as easy to write code in them as code not in them
14:19:22 <RyanT5000> besides, i wouldn't be talking about this right now if TH worked with profiling :P
14:20:00 <RyanT5000> and i'm not even trying to profile generated code!
14:20:15 <sieni> > (liftM2 (,) head tail) [0]
14:20:16 <lambdabot>  (0,[])
14:20:30 <mattam> this world cup match won't end
14:20:31 <sieni> strange... why doesn't that work with my ghci
14:20:54 <RyanT5000> 1) Turn on profiling 2) Link in TH 3) Undefined linker symbol
14:21:03 <dmhouse> sieni: import Control.Monad.Reader
14:21:05 <sieni> I get    No instance for (Monad ((->) [Int]))
14:21:05 <sieni>       arising from use of `liftM2' at <interactive>:1:1-6
14:21:05 <sieni>     Probable fix: add an instance declaration for (Monad ((->) [Int]))
14:21:05 <sieni>     In the definition of `it': it = (liftM2 (,) head tail) ([0 :: Int])
14:21:17 <dmhouse> sieni: or import Control.Arrow and use (&&&), because it's better.
14:22:18 <sieni> ok now it worked
14:23:25 <jrmole> ghc is very optimistic about suggesting you add instances ;)
14:24:06 <RyanT5000> lol yeah
14:24:34 <stepcut> jrmole: :p
14:49:48 <iron32> Haskell noob question is there Haskell library that checks if something is inside a list ?
14:50:03 <iron32> I mean library function that is
14:50:10 <RyanT5000> Prelude.elem
14:50:19 <RyanT5000> do you know about hoogle?
14:50:28 <RyanT5000> @hoogle a -> [a] -> Bool
14:50:29 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
14:50:29 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
14:51:01 <jgrimes> or you can use the online version which provides the haddock, both are quite useful :)
14:51:04 <RyanT5000> right
14:51:11 <RyanT5000> and, you can PM lambdabot
14:51:14 <RyanT5000> @where hoogle
14:51:14 <lambdabot> http://www.haskell.org/hoogle
14:51:18 <iron32> thanks I not fully versed in hoggles full capabilities
14:51:32 <RyanT5000> no problem
14:54:39 <stepcut> HSP.Clientside looks like it could be cool
15:12:41 <Methyltheobromin> what is HSP?
15:12:57 <xerox__> Haskell Server Pages
15:14:52 * Lemmih hopes it will continue to be independent of HSP.
15:28:38 <jberg_> if i want a function clamp n which clamps a float value from 0.0 to 1.0 can i define that function using only guards? like clamp n | n > 1.0 = 1.0 | n < 0.0 | otherwise n ?
15:29:25 <jrmole> i don't see why not... have you tried it?
15:31:46 <jberg_> yep, said: parser error: possibly incorrect indentation
15:31:56 <palomer> > let clamp x = max 1.0 (min 0.0 x) in clamp 0.5
15:31:57 <lambdabot>  1.0
15:32:07 <palomer> > let clamp x = min 1.0 (max 0.0 x) in clamp 0.5
15:32:08 <lambdabot>  0.5
15:32:34 <monochrom> Yes you can use guards.  You have a typo.
15:33:19 <jrmole> you forgot the = in the n < 0.0
15:33:26 <jrmole> and otherwise
15:33:51 <jberg_> ah yes. thanks
15:51:24 <xerox> ?yow night!
15:51:24 <lambdabot> I guess it was all a DREAM ... or an episode of HAWAII FIVE-O ...
15:55:20 <palomer> @palomer
15:55:20 <lambdabot> Learning vim is pointless
15:55:26 <palomer> these palomer quotes are _gold_
16:03:52 <iron32> @iron32
16:03:52 <lambdabot> Unknown command, try @list
16:04:26 <iron32> palomer: How do you register a quote ?
16:05:01 <iron32> @list
16:05:01 <lambdabot> list [module|command]. Where modules is one of:
16:05:02 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
16:05:02 <lambdabot> topic type unlambda url version vixen where
16:05:37 <iron32> @quote test
16:05:38 <lambdabot> test hasn't said anything memorable
16:05:49 <iron32> @quote iron32
16:05:49 <lambdabot> iron32 hasn't said anything memorable
16:06:25 <iron32> @compose
16:06:25 <lambdabot> Not enough arguments to @.
16:21:44 <kaol> how could I keep track of time at better precision than seconds? That's what System.Posix.Time would give.
16:22:29 <RyanT5000> getCurrentSeconds :: IO Double 
16:22:29 <RyanT5000> getCurrentSeconds = do 
16:22:29 <RyanT5000>      TOD s ps <- getClockTime 
16:22:29 <RyanT5000>      return ((fromInteger s) + ((fromInteger ps) / (10 ^ 12))) 
16:22:33 <RyanT5000> tjat
16:22:38 <RyanT5000> that's my function
16:22:55 <RyanT5000> it returns stuff to like millionths of seconds
16:23:08 <RyanT5000> (only due to there not being enough precision in a Double)
16:23:20 <RyanT5000> it only uses System.Time
16:23:34 <RyanT5000> feel free to use it as-is or modified
16:27:25 <kaol> basically I have a calculation that I want to run every n milliseconds, deducing from that delay the actual time that the calculation took every time.
16:27:50 <kaol> I wouldn't expect to get any hard realtime behavior, of course
16:28:33 <RyanT5000> that i'm not sure how to do, but if you have a millisecond-precision wait function, you can certainly use my function to achieve that goal
16:28:44 <RyanT5000> i think threadWait or whatever is good enough
16:29:09 <Phas> i'm trying to install GSL, but it's requiring HUnit, wick is in the ghc standard library, WTF?!
16:29:59 <RyanT5000> are you sure your versions are up to date? run "ghc-pkg list" to make sure things are as they seem
16:30:46 <kaol> oh, right. System.Time.getClockTime gives picosecond precision. I can see how that one can be useful.
16:31:27 <RyanT5000> yeah, my function just uses that and multiplies it to get a time in seconds cause i didn't want to bother with TOD structures all over the place
16:32:06 <Phas> phas@zulu:~/Desktop/GSLHaskell-2006-06-02$ ghc-pkg -list | grep hunit
16:32:06 <Phas> phas@zulu:~/Desktop/GSLHaskell-2006-06-02$
16:32:16 <Phas> WTF?! but it's in the standard library
16:32:51 <stepcut> Phas: you probably need, grep -i hunit, for that to work
16:33:07 <RyanT5000> lol ghc-pkg list isn't so long you need to grep at all
16:33:12 <RyanT5000> just move your eyes
16:33:15 <Phas> eheh
16:33:26 <Phas> it was for posting a long bash output
16:33:33 <Phas> it doesn't appear
16:33:36 <RyanT5000> ah, i see
16:33:54 <RyanT5000> well i'm sure you can darcs it pretty easily
16:33:59 <Phas> mmh
16:34:04 <Phas> but's strange
16:34:06 <sieni> Phas: Well, it might give the time in picoseconds, but I'd think that the precision is quite that.
16:34:18 <RyanT5000> otoh, i have HUnit, and i have 6.4.2
16:34:25 <RyanT5000> so if you just get 6.4.2 you should have HUnit-1.1
16:34:35 <RyanT5000> (ghc, that is)
16:34:42 <Phas> i have 6.4.1
16:34:50 <Phas> it's the version packaged with ubuntu
16:35:00 <Phas> there isn't a repository for debs?
16:35:00 <stepcut> I have 6.4.1 from debian sid, and it has HUnit
16:35:09 <RyanT5000> hm
16:35:23 <RyanT5000> well it's probably easier to grab it off darcs than to reinstall
16:35:40 <RyanT5000> (reinstall ghc, that is)
16:36:03 <stepcut> RyanT5000: btw, ghc-pkg -list outputs around 54 different packages for me -- so grep *can* help ;)
16:36:04 <Phas> mmh, sfot easy and FAST
16:36:43 <RyanT5000> stepcut: i suppose, but you have a lot - and really 54 isn't so many to scan manually
16:37:29 <stepcut> RyanT5000: it is long enough, that if you can't find something you think should be there, grep starts to look attractive :p
16:38:07 <Phas> on another pc i have ghc 6.4 (there's ubuntu breezy on) and there is HUnit O_o
16:38:13 <RyanT5000> yah yah, i wasn't being terribly serious :P
16:45:15 <jberg> i have a [[(Float, Float, Float)]] and i need to convert it to a [[(Int, Int, Int)]] and all i have is a function (Float -> Int) is there an easy way to do this?
16:46:32 <bolrod> yes
16:46:33 <bolrod> map map
16:46:47 <bolrod> @hoogle Float->Int
16:46:48 <lambdabot> No matches, try a more general search
16:46:57 <bolrod> erh..
16:47:26 <AtnNn> @type round
16:47:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:47:38 <RyanT5000> map (map (\(x, y, z) -> (func x, func y, func z))) list
16:47:53 <RyanT5000> can it be made better than that?
16:48:01 <jberg> thanks!
16:48:03 <sieni> @pl can it be made better than that?
16:48:03 <lambdabot> (line 1, column 33):
16:48:03 <lambdabot> unexpected end of input
16:48:03 <lambdabot> expecting white space or simple term
16:48:03 <bolrod> don't think so
16:48:06 <sieni> oops
16:48:12 <bolrod> haha
16:48:14 <AtnNn> lol
16:48:21 <sieni> @pl map (map (\(x, y, z) -> (func x, func y, func z)))
16:48:21 <bolrod> @pl  map (map (\(x, y, z) -> (func x, func y, func z))) list
16:48:22 <lambdabot> (line 1, column 17):
16:48:22 <lambdabot> unexpected ","
16:48:22 <lambdabot> expecting letter or digit, operator or ")"
16:48:22 <lambdabot> ambiguous use of a non associative operator
16:48:22 <lambdabot> (line 1, column 17):
16:48:24 <lambdabot> unexpected ","
16:48:26 <lambdabot> expecting letter or digit, operator or ")"
16:48:26 <bolrod> ic
16:48:28 <lambdabot> ambiguous use of a non associative operator
16:48:28 <RyanT5000> i really wish there was an easy way to apply a tuple of functions to a tuple
16:48:45 <sieni> @pl \func -> map (map (\(x, y, z) -> (func x, func y, func z)))
16:48:45 <lambdabot> (line 1, column 26):
16:48:45 <lambdabot> unexpected ","
16:48:45 <lambdabot> expecting letter or digit, operator or ")"
16:48:45 <lambdabot> ambiguous use of a non associative operator
16:49:10 <RyanT5000> pl doesn't understand tuples?
16:49:18 <bolrod> ic;p
16:49:30 <bolrod> @pl  map (map (\(x, y, z) -> (round x, round y, round z))) list
16:49:30 <lambdabot> (line 1, column 17):
16:49:30 <lambdabot> unexpected ","
16:49:30 <lambdabot> expecting letter or digit, operator or ")"
16:49:30 <lambdabot> ambiguous use of a non associative operator
16:49:34 <bolrod> hrm..
16:49:56 <bolrod> > map ( map (\(x,y,z) -> undefined) ) 
16:49:56 <lambdabot>  Add a type signature
16:50:00 <bolrod> > map ( map (\(x,y,z) -> undefined) ) ::Int
16:50:01 <lambdabot>    Expecting a function type, but found `Int'
16:50:01 <lambdabot>    Expected type: Int
16:50:01 <lambdabot>   ...
16:50:17 <bolrod> > map ( map (\(x,y,z) -> undefined) ) [[1.0]]
16:50:18 <lambdabot>  add an instance declaration for (Fractional (a, b, c))
16:50:18 <lambdabot>   In the list elem...
16:50:31 <bolrod> > fromEnum 1.2 ::Int
16:50:32 <lambdabot>  1
16:51:18 <bolrod> > map ( map (\(x,y,z) ->(fromEnum x::Int, fromEnum y ::Int, fromEnum z ::Int ) ) [[(1.0,2.0,4.0)]] 
16:51:18 <lambdabot>  Parse error
16:51:31 <bolrod> What!?
16:51:54 <bolrod> > map ( map (\(x,y,z) ->(fromEnum, fromEnum y, fromEnum z )::(Int,Int,Int) )    [[(1.0,2.0,4.0)]] 
16:51:54 <lambdabot>  Parse error
16:52:00 <bolrod> > map ( map (\(x,y,z) ->(fromEnum, fromEnum y, fromEnum z ))    [[(1.0,2.0,4.0)]] 
16:52:00 <lambdabot>  Parse error
16:52:05 <AtnNn> you only close 2 parenthesis
16:52:05 <bolrod> where?!
16:52:11 <bolrod> > map ( map (\(x,y,z) ->(fromEnum, fromEnum y, fromEnum z )))    [[(1.0,2.0,4.0)]] 
16:52:12 <lambdabot>  Add a type signature
16:52:20 <bolrod> > map ( map (\(x,y,z) ->(fromEnum, fromEnum y, fromEnum z ) ::(Int,Int,Int)))    [[(1.0,2.0,4.0)]] 
16:52:20 <RyanT5000> is there a way to specify that i want a polymorphic function?
16:52:21 <lambdabot>    Expecting a function type, but found `Int'
16:52:21 <lambdabot>    Expected type: Int
16:52:21 <lambdabot>   ...
16:52:32 <RyanT5000> in a function declaration
16:52:37 <bolrod> > map ( map (\(x,y,z) ->(fromEnum, fromEnum y, fromEnum z )))    [[(1.0,2.0,4.0)]]   ::[[(Int,Int,Int)]]
16:52:38 <lambdabot>    Expecting a function type, but found `w_a1Nu'
16:52:38 <lambdabot>    Expected type: Int
16:52:38 <lambdabot>  ...
16:52:46 <bolrod> yeah watever.. 
16:52:54 <AtnNn> bolrod: fromEnum x
16:53:11 <bolrod> >:(\
16:53:17 <bolrod> > map ( map (\(x,y,z) ->(fromEnum x, fromEnum y, fromEnum z )))    [[(1.0,2.0,4.0)]]   ::[[(Int,Int,Int)]]
16:53:18 <lambdabot>  [[(1,2,4)]]
16:53:22 <bolrod> horay!
16:53:24 <AtnNn> :)
16:54:25 <bolrod> @pl map ( map (\(x,y,z) ->(fromEnum x, fromEnum y, fromEnum z )))    [[(1.0,2.0,4.0)]]   ::[[(Int,Int,Int)]]
16:54:25 <lambdabot> (line 1, column 17):
16:54:25 <lambdabot> unexpected ","
16:54:25 <lambdabot> expecting letter or digit, operator or ")"
16:54:25 <lambdabot> ambiguous use of a non associative operator
16:54:34 <bolrod> WHAT?!
16:54:41 <bolrod> I just copy pasted it!
16:54:46 <bolrod> @pl map ( map (\(x,y,z) ->(fromEnum x, fromEnum y, fromEnum z )))    [[(1.0,2.0,4.0)]]  
16:54:46 <lambdabot> (line 1, column 17):
16:54:46 <lambdabot> unexpected ","
16:54:46 <lambdabot> expecting letter or digit, operator or ")"
16:54:46 <lambdabot> ambiguous use of a non associative operator
16:55:01 <sieni> maybe it chokes on triples
16:55:01 <AtnNn> i think pl only does pair tuples
16:55:13 <bolrod> possibly
16:55:15 <RyanT5000> so is there any way to do something like this?
16:55:15 <RyanT5000> thing f = (f (1 :: Double), f (1 :: Float))
16:55:29 <sieni>  @pl map ( map (\(x,y) -> (fromEnum x, fromEnum y)))
16:55:44 <sieni> @pl map ( map (\(x,y) -> (fromEnum x, fromEnum y)))
16:55:44 <lambdabot> map (map (fromEnum *** fromEnum))
16:55:50 <sieni> <3
16:55:54 <RyanT5000> i.e.: pass a polymorphic function as an argument?
16:56:16 <AtnNn> @hoogle ***
16:56:17 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:57:32 <bolrod> @vixen should I sleep?
16:57:32 <lambdabot> whoa whoa whoa, one question at a time!
16:57:38 <bolrod> O_O
17:00:04 <lisppaste2> jberg pasted "problem with tuples and lists" at http://paste.lisp.org/display/21794
17:02:26 <bolrod> @type (floor . (*255))
17:02:27 <lambdabot> forall b a. (Integral b, RealFrac a) => a -> b
17:02:31 <bolrod> hm..
17:04:06 <jberg> is there something obviously wrong with that code?
17:04:48 <bolrod> no
17:04:51 <bolrod> [[(0.318, 0.318, 0.318), (0.318, 0.318, 0.318)][(0.311, 0.829, 1.34), (0.823, 0.218, 0.638)]]
17:04:54 <bolrod> there is something wrong ;)
17:05:01 <bolrod> can you spot it ;)
17:05:43 <jberg> ah!
17:05:44 <jberg> :D
17:05:46 <jberg> thanks
17:05:47 <bolrod> :D
17:19:19 <jrmole> what does ? mean in a haskell kind expression?
17:20:11 <bolrod> ?
17:20:15 <bolrod> what is that.. 
17:20:25 <bolrod> I see a question mark.. but that might be my termianl
17:20:27 <bolrod> terminal
17:20:42 <bolrod> > ord ?
17:20:42 <lambdabot>  Parse error
17:20:43 <jrmole> yes, a question mark
17:20:54 <bolrod> ah.. erhhh
17:21:01 <jrmole> @kind (->)
17:21:02 <lambdabot> ?? -> ? -> *
17:21:14 <bolrod> ;o
17:21:43 <jrmole> all the kind treatments i've seen are generated by K := * | K -> K, and would give (->) :: * -> * -> *
17:26:00 <bolrod> I havent read too much about arrows or something.. and monads
17:26:21 <bolrod> K := *     ^.0
17:28:56 <Lemmih> bringert_: ping.
17:29:05 <bringert_> Lemmih: pong
17:29:09 <bolrod> PANG!
17:29:54 <Lemmih> bringert: Why does your HTTP library use Network.Socket and Network.BSD instead of plain Network?
17:30:17 <bringert> Lemmih: dunno :-)
17:30:29 <bringert> Lemmih: I didn't write the original library
17:31:47 <juhp> morning
17:31:55 <jrmole> hi
17:32:13 <bringert> Lemmih: I could have a look, but my guess would be as good as yours
17:32:20 <bringert> is there a problem with it?
17:34:18 <Lemmih> No, it just seems unnecessary.
17:37:51 <Lemmih> bringert: openTCPPort is pretty much just an error-prone version of Network.connectTo.
17:38:07 <bringert> :-)
17:38:25 <bringert> does it have to do with the Stream abstraction?
17:39:14 <Lemmih> I don't think so. The code doesn't do anything fancy with the sockets.
17:40:25 * kaol contemplates :t (id + id) 1
17:40:46 <bringert> Lemmih: patches are welcome
17:42:14 <Lemmih> bringert: I'll also have some patches for keep-alive handling and pipelining soon.
17:42:29 * kaol finds haskell's type system elegant even with nonsensical cases
17:42:36 <bringert> Lemmih: great
18:11:38 * palomer has noticed that excessive cerebral activity is always followed by excessive head scratching
18:15:10 <aFlag> does ghc's preprocessor define some name that will inform which ghc version is being used?
18:39:20 <ihope> Again? :-P
19:05:15 <dons> aFlag: __GLASGOW_HASKELL__
19:05:22 <dons> used in cpp
19:07:27 <aFlag> thanks
19:13:29 <kaol> somehow I often think that ghc stands for glorious haskell compiler
19:13:53 <Lemmih> What's up, dons? I feel like I haven't heard from you in a while.
19:13:57 <Cale> kaol: that's because it does :)
19:14:12 <Cale> kaol: Glorious or Glasgow
19:17:47 <dons> Lemmih: oh, been busy hacking on a polymer reaction simulation system 
19:18:36 <Korollary> dons: is that part of your studies?
19:19:31 <dons> Korollary: i'm a researcher/paid hacker on a joint project with some chemists, at my uni.
19:19:48 <RyanT5000> ok i have two threads, both bound, which share an IORef
19:19:53 <dons> involves runtime eval of C code, which is fun.
19:19:59 <RyanT5000> IORef (IO ())
19:20:30 <RyanT5000> one of the threads writes it periodically, and the other reads it periodically
19:20:33 <RyanT5000> there's no synchronization
19:20:42 <RyanT5000> the one that reads it runs it
19:21:02 <RyanT5000> any ideas why the threads run in lockstep?
19:21:20 <RyanT5000> can you not move IO ()'s across thread boundaries?
19:25:02 <dons> hmm.
19:25:25 <dons> i can't think of an obvious reason, but you might want to consider using MVars for this kind of job
19:25:42 <dons> they're like ioRefs, but with much nicer properties 
19:26:15 <Cale> RyanT5000: an IO () will run in any thread. It's just a description of an action
19:27:50 <RyanT5000> that's what i thought
19:28:10 <RyanT5000> dons: actually i'm trying to avoid those nicer properties
19:28:20 <RyanT5000> i really do want something totally unpredictable
19:28:23 <RyanT5000> because
19:28:36 <RyanT5000> one thread is polling the OS for events, and the other is rendering stuff to the screen
19:28:50 <RyanT5000> i don't care how many events get processed between frames (i don't even have control over that)
19:31:33 <dons> you can have fully asynchronous stuff. its just that MVars ensure writes won't overlap rea (as well as other higher properties)
19:31:51 <dons> but with just 1 thread writing and one reading, i guess its ok.
19:32:08 <RyanT5000> yah i was told that readIORef and writeIORef are atomic
19:32:40 <dons> nope, you need modifyAtommically* don't you?
19:32:50 <RyanT5000> no, i don't need to read-then-write atomically
19:32:56 <RyanT5000> just read or write atomically
19:33:00 <dons> ah, right.
19:33:19 <RyanT5000> i'm going to try with MVars just for the hell of it
19:33:52 <RyanT5000> also, the problem could be in SDL
20:24:08 <dons> ?uptime
20:24:08 <lambdabot> uptime: 1 day, 22 hours, 28 minutes and 22 seconds
20:28:26 <cmarcelo> dons: did fps get merged in libraries/base?
20:28:32 <cmarcelo> (hi)
20:31:43 <dons> it has been yes, but we've kept develoing of course.
20:31:54 <dons> i hope to merge the current 0.7 version in again in the nexgt week or so
20:32:09 <dons> how's the hacking coming along?
20:32:50 <dons> you're using fps for the mutable collections aren't you? for keys or something?
20:33:09 <dons> would you like to fill me in on how you're using fps? any issues/complaints?
20:35:04 <dons> @localtime cmarcelo 
20:35:05 <cmarcelo> dons: is going great (not so fast as I want because end of semester at uni). didn't touch fps yet =|, still on FFI stuff and experimenting some API design based on h-cafe ideas...
20:35:05 <lambdabot> Local time for cmarcelo is Tue Jun 27 00:34:46
20:35:16 <dons> ok. cool.
20:36:51 <cmarcelo> dons: but when the time comes i'll flood you with questions, dont worry =o)
20:38:08 <dons> ok. great!
20:38:28 <dons> I like people to use and think about the code :)
20:39:54 * lispy was able to get haskell speaking to Excel today
20:40:01 * lispy is very happy about that
20:41:15 <dons> oh my.
20:41:19 <dons> ?karma+ lispy
20:41:19 <lambdabot> lispy's karma raised to 4.
20:41:34 <dons> lispy, did you know that spj designed the first class function extensions to recent excel versions?
20:41:52 <dons> i think there may even be a paper on it, or at least a talk on his page
20:42:00 <lispy> dons: yes, i've read the research paper that is the foundation for that because my advisor worked with him on that research :)
20:42:06 <lispy> well, my ex-advisor
20:42:13 <dons> ah, cool
20:42:24 <dons> who's your ex-advisor?
20:42:39 <lispy> Margaret(sp?) Burnett
20:42:51 <dons> oh yes.
20:43:11 <lispy> it was presented at ICFP actually
20:43:48 <dons> ah right. i didn't see that. i saw spj present it at an ifip 2.8 meeting a few years ago.
20:43:52 <dons> 2003 i think.
20:44:04 <lispy> dons: but for the record, getting excel and haskell to talk was pretty easy once i used the low level com functions :) hdirect is just doing something wrong when it tries to establish the link
20:44:53 <dons> very interesting. can you package up the excel-ffi for general use?
20:45:54 <lispy> i'm using about 8 lines i wrote, and the version of hdirect that ships with visual haskell, so not much to ship yet
20:46:14 <dons> ah ok. so quite simple then?
20:46:14 <dons> which is good
20:46:18 <lispy> i'm still trying to come up with some utility functions to make COM attractive in haskell
20:46:30 <lispy> yeah, it's not too bad
20:46:36 <lispy> but not automated either
20:47:04 <lispy> all the methods have these UUIDs and to invoke them you have to find the UUID and copy&paste it into your haskell source
20:47:09 <dons> yeah, thinking up some nice dsl over the top would be cool
20:47:26 <lispy> yeah, i'm thinking TH is probably the way to go
20:47:35 <dons> or a preprocessor
20:47:39 <lispy> hmm...
20:47:42 <dons> TH can be heavy for some things
20:47:50 <dons> maybe you need an excel2hs preprocessor?
20:47:55 <dons> a la c2hs
20:47:56 <lispy> heh
20:48:24 <lispy> the main thing is that haskell doesn't have any nice syntax for navigating a com object heiarchy since it's not a traditional OO language
20:48:47 <dons> ah, perhaps look at Mocha? the binding to Objective C
20:48:52 <dons> I think there's some nice syntax there
20:48:52 <lispy> onliners in python become 5 or 6 liners in haskell (even with the utility functions i have now)
20:50:27 <Korollary> Wouldn't COM require an object system first?
20:51:02 <lispy> well, i was thinking it should be possible to mimic the way python does it by using a type class in haskell
20:51:38 <lispy> in python they intercept a function called __getattr__ and __setattr__ that is imlicitly called whenever you use a dot to reference a field or a method
20:51:56 <Korollary> ... of an object
20:52:01 <lispy> yeah
20:52:13 * palomer prefers the ruby way
20:52:21 <lispy> so we should be able to define (#) as an operator in this type class
20:52:28 <lispy> and use that inplace of dot
20:52:47 <lispy> palomer: which is?
20:53:10 <palomer> there's syntactic sugar for creating setters and getters automagically
20:54:02 <lispy> the thing that's cool about the python way is that they use com's reflection system to determine if the method or field you want to access is accessible and then invoke it
20:54:41 <lispy> so you have things like ie = win32com.client.Dispatch("InternetExplorer.Application"), ie.visible = True
20:54:52 <lispy> and it works even though python knows nothing statically about the ie object
20:56:53 <lispy> i think in haskell we could do it like, ie <- createDispatch "InternetExplorer.Application"; ie # "visible" $= True
20:57:21 <lispy> so i was thinking maybe TH could make it so that it's even nicer like, ie #visible $= True
20:57:33 <lispy> but i don't really know what TH is capable of
20:58:47 <dons> well, whatever yo ucould do with a preprocessor, but more haskellish and more compiler support
21:00:00 <lispy> i'd also like to know how to implement (#) so that you can chain it
21:00:22 <lispy> in python you can do something like ie.Document.body.HTML
21:00:40 <dons> i think there's been a fair bit of work for object-like systems in haskell, so perhaps check the oohaskell and mocha papers?
21:00:55 <lispy> but currently with the code i have that becomes ie <- ...; document <- ...; and so on
21:01:25 <lispy> well, i'd like to stick to ghc haskell if i can, but maybe they have some good ideas?
21:01:52 <dons> yeah, that's what i think. just the ideas.
21:02:09 <lispy> next on my list is a gui library for win32...wxwidgets looks promising but getting it compiled for ghc6.5 on windows has proven to be a royal pain
21:02:45 <dons> yeah, wxhaskell is probably the best bet. but possibly ask ndm, he knows the win32/haskell area better than most
21:03:00 <Korollary> does gtk2hs work on win32?
21:03:27 <dons> i think so
21:04:40 <lispy> i wonder if it can be compiled so that you don't need to distribute gtk
21:04:51 <lispy> dons: okay, i was thinking i should ping haskell-cafe actually
21:05:45 <dons> always worthwhile
21:11:19 <skew> Hi. Has anybody here read "The Role of Type Equality in Metaprogramming?"
21:12:47 <Korollary> skew: I just saw the comment over at LtU about it, and I was planning on reading.
21:12:49 <skew> The Haskell code uses ugly encodings of type equality ghc didn't have GADTs at the time.
21:13:14 <skew> So far things seem to go much more smoothly with them
21:14:17 <RyanT5000> is there a floating point mod?
21:14:53 <lispy> RyanT5000: sin?
21:14:59 <RyanT5000> huh?
21:15:04 <RyanT5000> no i mean like `mod`
21:15:05 <lispy> sin function
21:15:12 <lispy> er sine i should say
21:15:23 <RyanT5000> yah, that isn't what i'm looking for
21:15:25 <lispy> @type mod
21:15:26 <lambdabot> forall a. (Integral a) => a -> a -> a
21:15:33 <lispy> @type fmod
21:15:33 <skew> I think you could build something out of methods in RealFrac
21:15:34 <lambdabot> Not in scope: `fmod'
21:15:51 <lispy> RyanT5000: how does it work?
21:16:15 <RyanT5000> pi `fmod` 1 = 0.1415926535...
21:16:28 <RyanT5000> pi `fmod` pi = 0
21:16:56 <Korollary> a `fmod` b = c iff exists k (k * b + c = a) ?
21:17:05 <lispy> okay, so it works by subtracting till you get within [0..m]?
21:17:22 <RyanT5000> well it could work that way, but the performance would be horrible
21:17:23 <lispy> or maybe [0..m)
21:17:32 <RyanT5000> yeah [0..m)
21:18:18 <lispy> i don't know how else to get the case pi `fmod` 1 to work...
21:19:10 <lispy> @type fromIntegral
21:19:11 <lambdabot> forall b a. (Num b, Integral a) => a -> b
21:19:21 <Korollary> python seems to have it: "For example, 7 % 4 is 3. For floating-point numbers, the modulo operator returns the floating-point remainder of x // y, which is x . (x // y) * y."
21:19:46 <RyanT5000> yeah
21:19:48 <lispy> in python what is //?
21:20:03 <RyanT5000> you divide by the second number, then you take the fractional bit, and multiply by the second number
21:20:33 <RyanT5000> i just did it a different way though so whatever, lol
21:20:40 <RyanT5000> (i mean the function where i wanted to use fmod)
21:20:53 <lispy> heh
21:37:18 <palomer> in ruby, the setter would be:
21:37:23 <palomer> def a=(x)
21:37:26 <palomer> ...
21:37:27 <palomer> end
21:37:55 <palomer> (usually def a=(x){@a})
21:38:06 <palomer> then again, no one is probably listening anymore
21:45:56 <skew> ah, Omega can drop these proofs IsNat that some type is a properly assembled natural number type
21:49:19 <jer> palomer, for most uses of setter methods, you can use attr_writer :a <-- will create an instance variable @a; and an a= method which takes an argument and sets the value of @a to it
21:50:16 <RyanT5000> god i love higher-order functions; i literally have no idea how i would have written the stuff i just wrote in C
21:50:29 <RyanT5000> it probably would have been 4 times as many functions, and way harder to use
21:50:37 <skew> RyanT5000: for a helpful hint, run the code through ghc -C
21:50:43 <RyanT5000> LOL
21:52:52 <RyanT5000> i now have 7x7x7 clocks tiled in 3space with one simple command, lol
21:53:15 <RyanT5000> because everyone needs 343 clocks in 3 dimensions with perspecctive
21:56:34 <palomer> jer: yeah, that's the syntactic sugar for automagically creating methods
21:57:13 <jer> palomer, not really syntactic sugar; it's a method like any other. it's called metaprogramming, you might have heard of the concept =] 
21:59:26 <cmarcelo> jer: it actually doesn't create the instance variable, just the setter and getter that use @a, right? [not that this matters]
22:00:23 <jer> cmarcelo, attr_writer :foo does create the instance variable and the foo= method; attr_reader creates the instance variable and the foo method (getter); attr_accessor :foo creates the ivar, and both getter and setter
22:01:48 <skew> You're welcome to the bandwidth, but I'm interested to know how you got to talking about ruby metaprogramming here.
22:02:03 <skew> something to do with attribute systems like the one in gtk2hs?
22:03:40 * jer shrugs, i just looked in, and saw it being discussed; dropped in the metaprogramming bit to save some code for most use cases of setters
22:04:04 <palomer> ruby has metaprogramming?
22:04:17 <palomer> lies!
22:05:11 <cmarcelo> jer: take a look... http://rafb.net/paste/results/DqTR9v26.html
22:07:40 <jer> cmarcelo, interesting
22:08:47 <cmarcelo> jer: and more lies^H^H metaprog in "x.instance_variables"..
