00:04:10 <shapr> Lemmih wrote an SDL binding.
00:04:23 <urz> that's the one i'm using
00:04:46 <urz> but i dont know of any drawing primatives
00:04:51 <urz> besides rect
00:04:51 <shapr> Heffalump: You may want to try Hope instead of WASH. Bj√∂rn Bringert wrote hope, here's my installation - http://www.scannedinavian.com/hope/
00:05:20 <shapr> Stinger_: Monads are straightforward, want the five minute explanation?
00:05:40 <Stinger_> okie dokie
00:06:11 <Heffalump> show me the Debian packages ;-)
00:06:47 <Heffalump> got a download URL? google isn't helpful
00:07:55 <shapr> darcs get http://www.cs.chalmers.se/~bringert/darcs/hope
00:08:07 <shapr> It has a bunch of deps, including haskelldb
00:08:14 <shapr> But it sure is nifty :-)
00:08:17 <Heffalump> errm, I just want something to make web pages...
00:08:20 <shapr> oh
00:08:28 <Heffalump> well, and simple CGI
00:08:40 <Heffalump> it'll talk to a database, but I probably want to handle that myself
00:08:55 <shapr> Hope is built on top of Bringert's xhtml and NewCGI libs.
00:09:04 <Heffalump> yeah, was just looking at that
00:09:22 <Heffalump> do you know how they are better/worse than WASH?
00:09:57 <shapr> Last I checked, WASH required Javascript for most of its functionality. I know stepcut sent in a patch to fix that, but I don't know if Thiemann integrated it.
00:10:23 <Heffalump> I'm not sure I mind JavaScript as much as I used to.
00:10:30 <shapr> The bigwig caching stuff didn't really seem that useful to me (tags have hr and hr_T).
00:10:35 <Heffalump> Google has rehabilitated it for me by showing that it's useful :-)
00:10:44 <shapr> Yeah, I agree with you.
00:11:22 <shapr> Much of WASH requires forms to do anything, I didn't like that either.
00:11:55 <shapr> On the good side, Thiemann integrated hs-plugins into JaffaCake's HWS and wrote a WASH servlet on top of that.
00:12:38 <shapr> That's a nifty feature.
00:12:44 <Heffalump> I probably don't need the fancy continuation-based stuff WASH does, but on the other hand it's clearly the right way to do web programming
00:12:55 <shapr> Yeah, but you need to snip the log with WASH.
00:13:02 <Heffalump> wdym?
00:13:05 <shapr> Otherwise your /tmp overflows
00:13:19 <Heffalump> ah.
00:13:55 <shapr> WASH does continuation-based stuff with a log file in /tmp, sometimes (all the time?) you need to snip that file when a session won't be used again.
00:14:45 <shapr> I do agree that continuations seem like a good approach to webdev, I just haven't seen a way to make it transparent.
00:15:09 <shapr> er, transparent in Haskell that is.
00:15:38 <shapr> I think that's all the useful info I have on WASH.
00:17:00 <shapr> Stinger_: My monads intro is "how to use monads" and it boils down to "monads take the significance of a type and turn it into a pipeline." Do you know the Maybe type already?
00:17:15 <Stinger_> yeah
00:17:32 <shapr> And you know how the Maybe type represents failure, yeah?
00:17:50 <Stinger_> I've looked at all some list monad stuff, maybe monad and some of the state things
00:19:17 <shapr> My example is a webshop where you have a client order value and a bunch of functions that check stuff like "doesClientExist" and "doesClientHaveCash" and "isItemInStock"
00:19:57 <defcon8> length (x:xs)  <-- what is the : for?
00:20:15 <shapr> Each of those functions could be a (ShopOrder -> Maybe ShopOrder) value.
00:20:22 <eivuokko> defcon8, It is a constructor.
00:20:31 <defcon8> eivuokko: can you explain?
00:20:33 <shapr> Stinger_: Have you ever written a bunch of nested if-then-else calls and wished they could be abstracted somehow?
00:21:10 <Stinger_> yeah
00:21:18 <shapr> The Maybe monad abstracts exactly that.
00:21:32 <defcon8> anyone?
00:21:47 <eivuokko> defcon8, It is same as Cons in data List a = Cons a | Nil.  ([] would be Nil, and [foo] are special syntax)
00:22:01 <shapr> Stinger_: referring to http://www.nomaware.com/monads/html/maybemonad.html
00:22:17 <defcon8> eivuokko: so when i give a list into there, it takes first and rest?
00:22:34 <shapr> Stinger_: You could build your webshop with doesClientExist >>= doesClientHaveCash >>= isItemInStock
00:22:38 <eivuokko> defcon8, Yeah.
00:23:02 <defcon8> it should explain that in the tutorial
00:23:16 <eivuokko> defcon8, it should use proper variable names, atleast, yes :)
00:23:37 <defcon8> can you only cons 1 item at a time?
00:23:48 <defcon8> how does it know to get exactly first and exactly rest out of it
00:24:01 <defcon8> i mean an item that has a length of 1
00:24:06 <shapr> Since the meaty part of the definition of the Maybe monad is "Nothing >>= f = Nothing ; (Just x) >>= f = f x", that means that if any of those functions fail, the whole computation returns Nothing, otherwise you get a value. Makes sense?
00:24:07 <eivuokko> defcon8, What you mean?  You do get just first item and rest of the list.
00:24:37 <Stinger_> yeah I kindof get how a lot of the monad examples work
00:24:44 <defcon8> how do i try that function out in hugs?
00:24:47 <Stinger_> I think my problem is more fundamental
00:24:50 <defcon8> how do i use the let thing i mean
00:24:50 <shapr> How so?
00:24:51 <eivuokko> > (\(x:y) -> (x,y)) [1,2,3]
00:24:52 <lambdabot>  (1,[2,3])
00:24:59 <eivuokko> > (\(x:y:z) -> (x,y,z)) [1,2,3]
00:25:01 <lambdabot>  (1,2,[3])
00:25:09 <Stinger_> I'm finding it hard to put into words hang on :)
00:25:18 * shapr goes to make coffee
00:25:18 <Stinger_> what IS the monad in all these things
00:25:21 <shapr> Oh!
00:25:25 <Stinger_> is it the source type
00:25:30 <defcon8> shapr: just have caffeine gum
00:25:41 <shapr> defcon8: Haven't seen it here.
00:25:50 <defcon8> thinkgeek.com
00:26:02 <defcon8> can someone tell me how to use let?
00:26:18 <shapr> Stinger_: http://www.haskell.org/haskellwiki/Monads_as_Containers
00:26:33 <shapr> Stinger_: Cale wrote that page, and it really helped me.
00:26:59 <Cale> :)
00:27:12 <defcon8> eivuokko: do you know
00:27:18 <shapr> Stinger_: A monad is an abstraction in the same way that objects are an abstraction. They're both useful coventions that let you ignore parts of your code when you want to focus only on a particular layer.
00:27:25 <eivuokko> defcon8, I've hard time coming up with a good simple example.
00:27:26 <neologism> defcon8: let is similar to #define in C
00:27:38 <neologism> > let f x = x + 1 in f 1
00:27:39 <lambdabot>  2
00:27:55 <defcon8> what is the in for?
00:28:00 <defcon8> oh i get it sorry
00:28:00 <neologism> #define f(x) ((x)+1)
00:28:04 <neologism> f(1)
00:28:26 <eivuokko> defcon8, it is syntactic sugar for basic abstraction via naming.
00:28:45 <defcon8> do i have to use the in at the end? can't i save it for alter
00:28:46 <defcon8> later*
00:29:19 <shapr> Stinger_: This might help some - http://lambda-the-ultimate.org/node/1136
00:29:20 <eivuokko> In non-monad code, yes, you have to have in, and names are only avaible in expression after in.
00:29:59 <neologism> > [ x | let a = 3, x <- [1..a]]
00:30:01 <lambdabot>  [1,2,3]
00:30:26 <eivuokko> In monadic code, using do, you can have let foo=1; and foo is available in all following expressions in that do-block.
00:30:39 <shapr> Stinger_: That gives links to monad implementations in Clean, Haskell, Java, Joy, OCaml, Perl, Prolog, Python, Ruby, Scheme, C++, XSLT, Scala, Miranda, and Tcl
00:31:13 <shapr> Stinger_: Maybe explaining some of the history and motivation of monads would help?
00:33:23 <Stinger_> could do heh, still reading the first page atm
00:33:59 <Stinger_> just a q, is fmap anything like flip >>= , at least in a very abstract sense
00:34:30 <Cale> fmap f x = x >>= (return . f)
00:34:51 <Cale> so yeah
00:34:56 <Stinger_> cool
00:35:02 <Cale> with return stuck in there too
00:35:28 <Stinger_> yeah I figured something would have to be tweaked in there to get the right types
00:36:29 <Stinger_> oh, hmm it even says that further down the page :P
00:37:16 <defcon8> Hugs> data Colour = Red | Green | Blue
00:37:19 <defcon8> ERROR - Syntax error in expression (unexpected keyword "data")
00:37:19 <defcon8> why so?
00:37:48 <shapr> defcon8: You need to load that from a file.
00:38:07 <defcon8> well i wish it would just execute stuff
00:38:30 <shapr> hs-plugins has something that can do that, and I agree it would be nice to have it standard.
00:38:49 <defcon8> can i have a link for that?
00:39:09 <shapr> @where hs-plugins
00:39:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
00:39:58 <therp> is there a way to trace the evaluations of expressions? I'm failing to see how my code bugs
00:40:58 <defcon8> i am in windows
00:41:14 <defcon8> i don't think that'd work for me
00:41:19 <shapr> defcon8: I don't think that comes out of the box with something like ghci. But I'll ask the author (dons) and he might know.
00:41:23 <Cale> therp: you can use Debug.Trace
00:41:38 <shapr> I'm pretty sure hs-plugins works on windows also.
00:41:47 <defcon8> dons how do i get hs-plugins to work for windows?
00:41:51 <Cale> therp: though it's often a good idea to see if you can break up the algorithm a little more so that you can see what's going on better
00:42:03 <shapr> Aha, it's "plugs"
00:44:01 <therp> cale: it's only one recursive function I want to debug, so I think I'm on atomic level :)
00:44:24 <therp> ah! got the problem, I misunderstood the definition of zip
00:45:56 <therp> now my infiniteProduct works. joy. 
00:46:46 <therp> neato, any my pythagorean triples exercise works too.
00:48:46 <Stinger_> just another general q, so if I wanted to write an interactive haskell program, main would generally have to be one big monadic IO expression right?
00:49:47 <shapr> Yup
00:50:01 <shapr> It's like pulling that one string on a sweater that causes the whole thing to unravel.
00:51:40 <Stinger_> though you dont have to write everything such that it deals with the IO monad, cause generally you can call things from within a IO expression
00:53:43 <shapr> That's right.
00:54:38 <Stinger_> heh that almost turned me off haskell :) :P, I wrote this app, to do some calcs, and was originally using static data
00:54:48 <Stinger_> then decided I wanted to use random values
00:55:14 <shapr> I usually start out with a static random value like (mkStdGen 42)
00:55:54 <Stinger_> I thought "OMG I'm going to have to change EVERYTHING to use IO" heh
00:56:27 <Stinger_> is there a way to reverse the order of monads?
00:56:49 <Stinger_> say if I have [IO a] can I get IO [a] easily?
00:57:11 <ValarQ> @type sequence
00:57:12 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
00:58:10 <Stinger_> ok :), although just thinking about it now that can't be done in general eh
00:59:07 <shapr> sequence is general for all monads.
00:59:56 <Stinger_> oh? hmm
01:00:22 <Stinger_> yeah but its a special case for lists
01:01:22 <Stinger_> still can't really think of another case where you'd want it atm
01:01:44 <shapr> Igloo_: Think you'll update ghc6-opengl soon?
01:02:08 <Igloo_> shapr: Are you on debian-haskell?
01:02:21 <shapr> Um, I don't know. I'll check the archives.
01:04:47 <shapr> Yes, I'm on the list, and http://urchin.earth.li/pipermail/debian-haskell/2006-June/000197.html implies that ghc6.4.2 packages are approaching quickly?
01:10:53 <Igloo> I was thinking more of http://urchin.earth.li/pipermail/debian-haskell/2006-June/000200.html
01:14:06 <shapr> Oh
02:21:02 <Spiff> Hello! I'm a newbie and have a newbie question.
02:21:55 <Muad_Dibber> Spiff, how about you just ask the question?
02:22:17 <Spiff> If I have a module 'module Main where\nmain = putStr "Hello, world\n"'
02:22:24 <Spiff> (yeah, getting to it)
02:22:32 <Spiff> And then store that in foo.hs
02:22:42 <Spiff> Using winhugs, I load that file: ":l foo.hs"
02:22:55 <Spiff> When I try to evaluate main I get an action.
02:23:02 <Spiff> I get it -- basically -- 
02:23:34 <Spiff> but I can't figure out how to actually -- uh -- get it to actually perform that action
02:23:45 <Spiff> So I'm sort of missing something.
02:24:28 <Spiff> My understanding is that it's an unevaluated action, but that's it.
02:25:00 <Spiff> If it matters, I'm using the SOE book without an instructor, and am on chapter 3.
02:26:42 <dcoutts> so you can type 'main' at the winhugs prompt
02:26:54 <dcoutts> and it'll execute the action main :: IO ()
02:27:12 <Spiff> Right, so I type "main" as you suggest
02:27:14 <dcoutts> the interpreter allows you to *both* evaluate expressions and execute IO () actions
02:27:29 <Spiff> and it only seems -- to me -- to show the type of the result: "IO ()"
02:27:54 <dcoutts> ok, odd
02:28:17 <Spiff> I KNOW! :)
02:28:49 * dcoutts wonders if it's a winhugs bug
02:29:07 <dcoutts> try opening a command window and running the command line version of hugs
02:29:24 <Spiff> I'm using the version recommended by the SOE site.
02:29:27 <Spiff> OK
02:29:57 <Spiff> You're absolutely right.
02:30:04 <Spiff> command-line hugs does just what you say.
02:30:06 <Spiff> Oh, wait.
02:30:08 <Spiff> Hmm....
02:30:13 <Spiff> I think I know what's yp
02:30:13 <Spiff> up
02:30:51 <Spiff> no
02:31:51 <dcoutts> Spiff, so does it work in the commandline hugs?
02:32:09 <Spiff> I thought it was a Winhugs option, perhaps
02:32:17 <Spiff> Oh yes, dcoutts. Thought I said so
02:32:30 <dcoutts> @seen ndm
02:32:30 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 10 hours, 28 minutes and 16 seconds ago, and .
02:33:08 <dcoutts> Spiff, my guess is that it's because winhugs is not treating the stdin/stdout in the same way as the console version
02:33:28 <Spiff> Perhaps if I run winhugs from a command-line, it'll print it there.
02:33:32 <dcoutts> it ought to direct stdout to the winhugs window
02:33:45 <Spiff> I would think so but I'm ... you know.
02:34:02 <dcoutts> Spiff, that's possible, though I think win32 apps disconnect from a launching console
02:34:31 <Spiff> Yes, you're right.. it did
02:34:38 <Spiff> It was a shot in the dark
02:35:17 <dcoutts> Spiff, I think it's a bug really, you might like to report it
02:35:36 <dcoutts> and its rather confusing to new users
02:36:10 <Spiff> OK
02:36:14 <Spiff> Thanks dcoutts
02:36:20 <Spiff> How disappointing!
02:36:29 <Spiff> Let me ask something else:
02:36:49 <Spiff> How do I ask this one ...
02:37:24 <Spiff> The nature of the hugs as shell suggests that I should have more power on the command-line.
02:37:28 <Spiff> I'm sure you get this question.
02:37:41 * dcoutts is not sure he does
02:37:47 <Spiff> Yeah.
02:38:35 <Spiff> So far, the only way I can find to create a module like the two-line hello world, is to create a file, enter those two lines in the file, and load it in hugs.
02:38:46 <Spiff> I'd much prefer the ability to create a module right there at the prompt.
02:38:57 <Spiff> Attempts to do so have met with failure.
02:39:03 <Spiff> Make sense?
02:39:34 <dcoutts> Spiff, right, that's basically the way it works
02:39:44 <Spiff> Yeah, I wonder why.
02:39:49 <dcoutts> you have the editor in one window and hugs in the other
02:40:21 <Spiff> It's an interesting thing. I'm still sort of helpless and so won't say, 'it should be like this'
02:40:25 <dcoutts> you can define new funsions using let in ghci but they're not persistent, you have to pu them in a module to do that
02:40:54 <dcoutts> Spiff, it's an idea that people have pondered, there are some experimental IDEs that do that kind of thing, but nothing usable
02:40:57 <Spiff> but I can say that I feel like the process could be a little more fluid.
02:41:14 <Spiff> What's ghci?
02:41:21 <Spiff> (short answer is ok)
02:41:22 <dcoutts> well with winhugs, it automatically reloads your module whever you save it in you editor
02:41:39 <Cale> ghci is another interactive environment for Haskell
02:41:43 <Spiff> oh
02:41:54 <dcoutts> Spark, ghc is another Haskell compiler, and ghci is ghc's interactive mode
02:42:08 <Cale> It can interpret Haskell scripts and also load compiled object files.
02:42:43 <dcoutts> Spark, ghc is an optimising Haskell compiler that produces fast binary code
02:43:10 <Spiff> Cool.
02:43:42 <Spiff> Having an interpreter that actually displays a useful value is kinda helpful, so thanks, dcoutts.
02:43:49 * Spiff is being understated.
02:44:55 <dcoutts> Spiff, you'll find that winhugs does display values of things you calculate, it's just the actions of printing to stdout that seem to be messed up in winhugs
02:45:12 <dcoutts> which is a serious bug I agree
02:45:42 <Spiff> Oh yeah, I've been OK otherwise.
02:45:54 <Spiff> I'll contact someone over at Winhugs Central.
02:46:10 <dcoutts> Spiff, that'd be very helpful
02:46:46 <Spiff> As are you. OK, I'm back to the book.
02:47:00 * Spiff appreciates the help and waves goodbye.
02:53:12 <Azmo> how does one get filename and/or location together with ones exceptions? one can get it with "Control.Exception.assert", but what if one want to throw other exceptions?
02:54:25 <Cale> I suppose you'd include that information in the exception
02:54:32 <Azmo> manually?
02:54:35 <Cale> it's not available to the runtime be default
02:54:53 <Azmo> :[
02:59:32 <psnl> dcoutts: are there any papers about GUIs in haskell?
02:59:45 <dcoutts> psnl, yes, a few
02:59:50 <psnl> ta
02:59:58 <dcoutts> psnl, quite a few are rather old
03:00:02 <dcoutts> eg fudgets
03:00:06 <Stinger_> ooh I finally get how this label monad thingy works
03:00:44 <dcoutts> psnl, Daan had one about wxHaskell, there's papers on Yampa and Fran I think
03:01:15 <Stinger_> so how good are the haskell compilers at taking all the cruft out of monads and reducing it to a seq of imperitive comands in object code?
03:01:58 <roconnor> there is cruft in monads? ;)
03:02:29 <Stinger_> well all the rigmarol in getting functional things to act like imperitive statements
03:03:22 <Cale> pretty good in general
03:04:08 <Stinger_> is that why haskell things tend to take a while to compile? :)
03:04:26 <Stinger_> nb : basing my experience entirely off building ghci
03:04:30 <dcoutts> Stinger_, don't guess, look at the generated code. Eg there are loads of -ddump-* flags for looking at the intermediate code at various stages.
03:04:47 <Cale> Stinger_: do you mean building *with* ghci, or building ghci?
03:04:55 <Stinger_> the latter
03:04:58 <Cale> You're not really expected to compile ghc yourself
03:05:04 <Stinger_> well I didnt really
03:05:07 <Cale> There are binary packages
03:05:10 <Stinger_> emerge ghci was it :P
03:05:25 <dcoutts> yah, anothr gentoo user :-)
03:05:36 <dcoutts> yes, ghc does take rather a long time to emerge
03:05:47 <Cale> I even got dcoutts to make a decent binary package for gentoo :)
03:05:57 * lorne happens to be compiling ghc right now
03:06:01 <Cale> so there's no excuse ;)
03:06:08 <dcoutts> Cale, it's always had a binary package
03:06:20 <Stinger_> but then I wouldnt have that extra 0.0000317% performance!
03:06:22 <Cale> dcoutts: for a while there it was out of date
03:06:32 <dcoutts> ah, true
03:06:58 <psnl> "time-space leak" <- what a wonderful term
03:07:39 <Cale> Stinger_: hehe, I'm not sure the cpu-cycle investment is really worth it in the case of ghc
03:07:58 <roconnor> space-time leak?
03:08:07 <Stinger_> well it was only cause I didnt look hard enough at the diff packages
03:08:41 <int-e> gentoo has some other virtues. fine grained dependencies, no hassle with so-called 'devel' packages, and source to look at for almost everything.
03:08:44 <roconnor> Is there a reader-writer monad, or should I build one out of monad transformers?
03:09:36 <Cale> roconnor: see Control.Monad.RWS
03:09:56 <Cale> that's Reader-Writer-State, which is too much perhaps
03:09:59 <psnl> roconnor: it is a term in haskell GUIs, where having signals as first class values can cause wierdness
03:10:35 <Cale> heh, why the unconventional order? It should be spacetime leak :)
03:11:12 <Stinger_> leak in space time reversed the mentioning of those words temporally
03:11:42 <roconnor> :type RWS String String ()
03:11:48 <roconnor> @type RWS String String ()
03:11:49 <lambdabot> Not in scope: data constructor `RWS'
03:11:50 <lambdabot>  
03:11:50 <lambdabot> <interactive>:1:4: Not in scope: data constructor `String'
03:11:57 <roconnor> wait, what am I doing.
03:27:43 <defcon8> has anyone got ibm's  "Beginning Haskell" pdf at hand? there is something wrong with logging in to developer works at the moment
03:28:00 <Kasperle> @t (+) ((\x -> 1) True) ((\x ->1) 3)
03:28:00 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
03:28:17 <Kasperle> @type (+) ((\x -> 1) True) ((\x ->1) 3)
03:28:18 <lambdabot> forall a. (Num a) => a
03:29:24 <Kasperle> @type \f -> ( (+) (f True) (f 3))
03:29:25 <lambdabot>   No instance for (Num Bool)
03:29:25 <lambdabot>    arising from the literal `3' at <interactive>:1:24
03:30:36 <Kasperle> @type (\f -> ( (+) (f True) (f 3))) (\x -> 1)
03:30:37 <lambdabot>   No instance for (Num Bool)
03:30:38 <lambdabot>    arising from the literal `3' at <interactive>:1:25
03:31:56 <defcon8> anyone?
03:32:14 <ValarQ> defcon8: no, sorry
03:32:32 <defcon8> hrmm found it on google, thanks
03:33:08 <Kasperle> hehe... second hit, eh? ;)
03:37:15 <shapr> @yow !
03:37:16 <lambdabot> I left my WALLET in the BATHROOM!!
03:45:30 <defcon8> Kasperle: ibm login isn't working atm
03:46:00 <defcon8> peice of crap
03:46:28 <shapr> i before e except after c
03:47:37 <defcon8> shapr: pardon me. that was a typo
03:47:40 <vegai> agh, i-before-e-except-after-c-huggers
03:48:23 <shapr> defcon8: I'm just teasing :-)
03:48:39 <tic> shapr, any good at compact digital cameras?
03:48:53 <shapr> Any good at doing what with them?
03:49:01 <defcon8> shapr: no. i correct people aswell
03:49:16 <defcon8> i found a dead link on haskell.org. who do i tell?
03:49:32 <shapr> haskell.org is mostly a wiki now, so you can probably fix it yourself.
03:50:50 <shapr> defcon8: Which link is it?
03:51:23 <defcon8> http://www.numeric-quest.com/haskell/hcompanion/index.html
03:52:13 <defcon8> http://www.di.uminho.pt/memoria/afp98/PAPERS/Tutorial.ps is also dead
03:52:51 <shapr> Ah, numeric-quest has been gone for years. It should link to the wayback machine instead.
03:53:09 <defcon8> ftp://ftp.geoinfo.tuwien.ac.at/navratil/HaskellTutorial.pdf also
03:53:12 <defcon8> isn't working
03:53:45 <defcon8> that gentle intro is not gentle at all
03:54:27 * shapr agrees
03:54:40 <shapr> But Hal Daume's "Yet Another Haskell Tutorial" is good.
03:54:41 <Saulzar> I think everyone falls into that trap
03:55:47 <defcon8> the ibm one's pdf is shot
03:55:58 <Stinger_> its ok, then you get to monads and it bites your head off
03:56:06 <defcon8> the text mixes together
03:57:08 <tic> shapr, know about them  :)
03:59:11 <alar> ghc-6.4.2_1 does not install once again :(
03:59:46 <shapr> Only thing I know about compact digital cameras is that most of the big name brands use a proprietary picture format so that you're forced to use their tools to transfer the pix to/from the camera. That also ends up including watermarks and other information in each picture.
04:00:02 <shapr> I'd rather have a USB Mass Storage device myself.
04:00:38 <flux__> apparently canon isn't one of those big brands then. actually I'm not sure though if it supports mass memory storage or not, but atleast gphoto2 supports it just fine with its generic driver..
04:00:51 <flux__> afaik panasonic lumix appears as a mass storage device
04:00:53 <madpickle> most canons i've used worked fine out-of-box
04:01:17 <shapr> Spiffy, maybe times have changed...
04:01:25 <flux__> (I just bought a Canon Ixus IS 800 a few weeks back, I think they call it Powershot S700 or something in the US)
04:03:26 <shapr> tic: In that case, no, I don't know anything about digital cameras :-)
04:11:05 <tic> shapr, dang. :)
04:11:38 <alar> can someone explain me 1 line in GHC's makefile?
04:13:25 <alar> @where paste
04:13:25 <lambdabot> http://paste.lisp.org/new/haskell
04:14:00 <alar> there are no makefile format :(
04:19:36 <mahogny> ok, I'm rusty. did happy have a special way of dealing with comments in files or do I have to code this manually?
04:21:20 <mahogny> bbl
04:32:08 <madpickle> http://news.yahoo.com/s/nm/20060621/od_nm/uganda_pool_dc_1
04:32:11 <madpickle> lmao
04:33:41 <shapr> alar: eh?
04:34:46 <lisppaste2> alar pasted "GHC makefile" at http://paste.lisp.org/display/21585
04:35:09 <alar> shapr: it seems make process trips on theese lines
04:36:33 <shapr> What error do you get?
04:36:47 <alar> ===>  Applying FreeBSD patches for ghc-6.4.2_1
04:36:47 <alar> s+%%LOCALBASE%%+/usr/local+:No such file or directory
04:36:47 <alar> *** Error code 1
04:37:43 <shapr> Oh, I have no idea about that.
04:38:37 <mux> heh
04:38:40 <mux> that's a bug in the port
04:38:54 <mux> if you can wait a bit, I'll look at it later and fix it
04:39:43 <mux> alar: can you tell me what FreeBSD version this is?
04:40:02 <alar> 6.1
04:40:13 <alar> where to look for version?
04:40:15 <int-e> how does ${REINPLACE_CMD} end up being undefined ... hmm.
04:40:28 <alar> sorry
04:40:29 <alar> 6.0
04:41:06 <alar> maybe I should add USE_REINPLACE=yes @beginning of makefile?
04:41:10 <mux> no
04:41:16 <mux> this is deprecated
04:41:31 <mux> did you update your ports tree correctly?
04:41:38 <mux> as in, the whole ports tree, including the ports-base collection?
04:42:23 <mux> looks like you may not have done this, so your /usr/ports/Mk files may be out-of-date
04:42:27 <alar> no
04:42:31 <alar> only ports-lang
04:42:37 <mux> then here's your problem
04:42:42 <mux> *always* update ports-base too
04:42:47 <alar> ok
04:43:09 <alar> on FBSD4 updating the whiole ports tree is unsafe operation
04:43:19 <mux> eh? who told you this?
04:44:08 <alar> I tell you
04:44:16 <mux> well I don't buy it :-)
04:44:30 <alar> newest versions of some ports don't build with newest versions of other
04:44:43 <mux> FreeBSD 4.x just isn't supported anymore
04:44:52 <mux> this is not the same thing
04:45:05 <mux> but you're not running FreeBSD 4.x here, so this is a bit irrelevant
04:45:05 <alar> port collection packed with 4.11 is stable, but update can break this stability
04:45:07 <alar> yes
04:45:12 <alar> yes
04:45:19 <alar> Ive just switched to 6
04:45:41 <mux> in any case, it's safer to always update the whole ports tree, and if you only want specific collections, never ever leave ports-base out
04:46:51 <alar> ok
04:47:07 <alar> ===>  Building for libgmp-4.1.4
04:47:07 <alar> make: cannot open Makefile.
04:48:02 * alar is now updating ports-all
04:48:24 <mux> yeah, do yourself a favor
04:56:04 <shapr> Yay, I found an EtherLink XL PCI combo card with 10Base2, 10BaseT and 10Base5 plugs. Linux loves these cards and is particularly efficient with them.
04:56:46 * shapr finds used cards of this model online for $12.95
04:57:34 <mux> I have more NICs that I'll ever be able to plug into my boxes
04:57:53 <shapr> I think I found an ARCnet card in one of my boxes the other day, I wonder how I ended up with that.
04:58:08 <mux> I have a stack of those lying on my desk
04:58:31 <shapr> They're not much use these days... iirc, ARCnet was only 2Mbps and had problems with collisions.
04:59:00 <mux> some Intel EtherExpress, some 3com 3c90x, some SMC 83c17x, some DEC 21143 etc :-)
04:59:03 <shapr> Token Ring is of course the best choice for heavy traffic.
04:59:13 <dcoutts_> @seen dons
04:59:14 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 12 hours, 12 minutes and 4 seconds ago.
04:59:15 <shapr> Oh, I'd like to get those 3com cards, getting rid of them?
04:59:19 <mux> and some I forgot about
04:59:23 <shapr> Never heard of the Dec 21143
04:59:39 <mux> they are actually Dec/Intel, and pretty common
04:59:58 <shapr> I have a bunch of RTL8139+ cards. They're crappy but they work.
05:00:00 <mux> sorry, but I can't part with those, I'm supposed to make sure the xl(4) driver of FreeBSD works nice using them
05:00:05 <shapr> oh, nm
05:00:23 <alar> @man xl
05:00:24 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
05:00:28 <mux> RTL8139C+ is actually not crappy, if you have a driver that supports the extended features they have
05:00:35 <mux> all other RTL8139 NICs are pure shit
05:00:39 <shapr> I don't think I have C cards.
05:00:42 <alar> @help man
05:00:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:00:44 <mux> IIRC, they only have 2 TX descriptors :-)
05:00:50 <shapr> Yeah, they're pretty sad.
05:01:01 <shapr> But they move bits at least.
05:01:06 * mux nods
05:01:09 <shapr> And they're cheap as dirt and don't take up much room in my luggage.
05:02:07 <shapr> I just threw out a full-length SoundBlaster AWE 32 ISA card with slots for expansion memory, etc
05:02:12 <mux> ahhh, the good old days of 100Mbps
05:02:21 <alar> +))
05:02:34 * alar has SB AWE32
05:02:49 <shapr> alar: I like the emu10k1 more, but I'd like to get an audigy these days.
05:03:20 <mux> now the world is all gigE, with the intel pro/1000 cards, the broadcom 570x and 571x, and syskonnect 984x and 982x
05:04:39 <alar> shapr: my one was bought in the days of old
05:04:48 * earthy still has a Gravis UltraSound lying around somewhere
05:05:03 <shapr> Yeah, so was mine, but I'm moving on no budget and it's time to throw out all my old hardware.
05:05:14 <shapr> I loved the parrot program.. "Don't touch me!"
05:05:18 <earthy> ;)
05:05:22 <alar> mux: in our local net 10mbps segments still do exist
05:05:37 <alar> and I'm on 100mbps and think it's fine
05:06:07 <mux> my local LAN is still mostly 100Mbps, but I have a 10/100/1000 switch and one gigE card
05:06:44 <mux> 10Mbps is not even enough for internet connections these days, depending on where you live :-)
05:07:45 * alar thinks he has 500kbps internet, but not sure
05:08:05 <shapr> Luke Gorrie has 100Mbps in Stockholm, says his 54Mbps wifi is his slowest link.
05:08:31 <shapr> I have 2Mbps in the north of Sweden and a stupid DSL modem that's stuck on 256k :-(
05:08:52 <shapr> It'll do 2Mbps, but somehow the settings were frozen many months ago...
05:11:11 <alar> 951.19 Kbps
05:11:23 <alar> by speed.yoip.ru
05:12:25 <alar> 227.2 Kbps by mcafee
05:13:43 <mux> I'm supposed to get a symmetrical 100Mbps soon now
05:13:54 <mux> they've been putting fiber in Paris
05:14:11 <mux> they guarantee 20Mbps in both directions, which is great
05:25:31 <jer> hey mux!
05:28:18 <jer> binary42, howdy
05:28:25 <mux> hello jer, sup?
05:28:36 <jer> mux, not much, how have you been? havn't talked to you in a while
05:28:41 <binary42> jer: hi. Just waking up and reading the news. :-)
05:28:50 <binary42> jer: Learning Haskell again?
05:28:59 <jer> binary42, yeah, but this time i'm getting further =]
05:29:46 <mux> jer: not much either
05:34:42 <Itkovian> hmm, I'm having trouble looking up stuff in a Data.Map ...
05:34:59 <Itkovian> I am wondering that the Monad is needed for 
05:35:10 <Itkovian> @type Data.Map.lookup
05:35:11 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
05:36:11 <ProfTeggy> Itkovian, m might be Maybe or List here, I guess
05:36:16 <ProfTeggy> (to model failed lookups)
05:36:26 <ProfTeggy> Nothing, []
05:36:27 <Itkovian> nvm, It seems there is a (!) too, according too hoogle
05:36:58 <Itkovian> ProfTeggy: so a single element might then be [x] ...
05:37:01 <Itkovian> or Just x
05:37:06 <ProfTeggy> *nod*
05:37:10 <Itkovian> meaning I can force it into Maybe
05:37:14 <Itkovian> or List\
05:37:19 <ProfTeggy> *nod*nod*
05:37:26 * Itkovian knock head
05:37:28 <Itkovian> +s
05:40:43 * SamB_XP wonders what would happen if you did it in Parsec's monad
05:47:07 <alar> @karma+ mux
05:47:07 <lambdabot> mux's karma raised to 1.
05:47:48 <alar> after updating all ports and make clean ghc agreed to build
05:48:49 <alar> arr
05:54:43 <roconnor> hmmm, this Control.Monada.RWS isn't what I want.
05:55:24 <roconnor> I want a monad for stream processing.
05:55:45 <roconnor> I consume letters, or lines, or whatever, and produce letters, or lines, or whatever.
05:56:10 <roconnor> But with RWS, I can only read one thing, and only write one thing.
05:56:18 <roconnor> it seems
05:56:46 <Cale> you can read a list and write a list
05:57:14 <roconnor> yeah, but I want to abstract it, so I can do it with lists, or file IO.
05:57:37 * roconnor wonders if he is thinking of this the wrong way.
05:58:01 <roconnor> :type interact
05:58:06 <roconnor> @type interact
05:58:08 <lambdabot> (String -> String) -> IO ()
05:58:13 <Cale> have a look at MonadSupply on the (old) wiki
05:58:42 <Cale> that sounds like it's half of what you want
05:59:10 <Cale> The other half is basically provided by the writer monad
05:59:16 <alar> who uses GL with GHC?
06:00:18 <roconnor> I like tell, but I don't have listen or pass.
06:01:05 <roconnor> maybe I just write my own class with ask and tell.
06:01:18 <mux> alar: cool
06:03:08 <roconnor> ask = getChar, put = putChar
06:03:50 <roconnor> ask = getChar, tell = putChar
06:17:44 <Saulzar> alar, I have used it a bit
06:18:26 <alar> Saulzar: at least someone does! I wondered why GHC builds libglut mandatory
06:20:10 <Saulzar> Ah, I have no experience building ghc. I have only used the binaries.
06:20:58 <Saulzar> I imagine it can be turned on/off as per other libraries (if they can at all) ?
06:21:00 <Itkovian> hmm, if I remove the last item of a list in a Data.Map, is the list then also removed? It certainly seems so
06:23:40 <Itkovian> oops, my bad
06:36:23 <Itkovian> @url paste
06:36:23 <lambdabot> http://paste.lisp.org/new/haskell
06:36:47 <lisppaste2> Itkovian pasted "Building a tree from a trace" at http://paste.lisp.org/display/21588
06:37:05 <Itkovian> ok, I'm open to suggestions on how to improve.
06:37:29 <Itkovian> more specifically, how it's possible that I 'insert' the same key more than once into the threadMap
06:37:58 <Itkovian> or, why it suddenly claims there's no thread key available while I know there should be one
06:42:50 <Itkovian> it seems as if the map entries disappear ...
06:46:19 <roconnor> @hoogle [a] -> [a]
06:46:20 <lambdabot> Prelude.cycle :: [a] -> [a]
06:46:21 <lambdabot> Prelude.init :: [a] -> [a]
06:46:21 <lambdabot> Prelude.reverse :: [a] -> [a]
06:47:07 <Itkovian> found my error I think
06:47:10 <Itkovian> aaargh
06:47:35 <bolrod> ok..
06:47:50 * Itkovian feels dumb once more
06:50:46 <bolrod> what is that code supposed to do ? O-O
06:52:58 <lisppaste2> Itkovian annotated #21588 with "Dumb" at http://paste.lisp.org/display/21588#1
06:54:09 <Itkovian> bolrod: it parse (ahem) a trace and builds a list out of it, annotated with timing info and pre and postorder sequences numbers, i.e. a tree written as a list
06:58:26 <bolrod> oh, obviously!
06:58:54 <bolrod> :/
07:01:01 <bolrod> haha.. that IRC context thing is quite nifty
07:01:53 <bolrod> (though really slow)
07:10:09 <Itkovian> but I'm open to suggestions on improving both the readability and the leetness
07:13:50 <Itkovian> and how to decrease the stack space usage
07:18:09 <roconnor> @type toRational
07:18:11 <lambdabot> forall a. (Real a) => a -> Rational
07:40:47 <roconnor> @info Real
07:40:47 <lambdabot> Unknown command, try @list
07:41:00 <roconnor> I think the only think Real implements is toRational
07:41:05 <roconnor> what a terrible name
07:42:22 <mahogny> 'lo
07:42:42 <Itkovian> I've got a function that processes a list, updating intermediary values that are passed along as arguments. 
07:43:31 <Itkovian> Said function is called recursively , as in f (x:xs) a b c d = f xs with updated a b c d 
07:44:09 <Itkovian> would I be better off uncurrying and folding over the list, as ghc seems to require a lot of stack space (the list can be up to 1E6 items long)
07:44:50 <mahogny> not sure about that, but this sounds like a job for the ST monad
07:46:37 <RyanT5000> can you really get more efficient than a tail-recursive function, though?
07:47:37 <RyanT5000> i mean it might be a little cleaner with the ST monad, but shouldn't it be equivalent to the tail recursive version?
07:48:01 <mahogny> pretty much, if the compiler does what it should AFAIK
07:48:56 <Itkovian> will the ST monad allow me to avoid execution stack overflow stuff?
07:49:07 <RyanT5000> are you getting stack overflow?
07:49:48 <RyanT5000> a tail-recursive function shouldn't result in stack overflow, regardless of how many times it recurses
07:50:01 <Itkovian> uhu, I thought that too
07:50:24 <RyanT5000> the following is perfectly legal (and efficient):
07:50:24 <RyanT5000> incr x = x : incr (x + 1)
07:50:51 <Itkovian> yeah
07:51:21 <RyanT5000> are you sure your code is tail-recursive?
07:51:31 <Itkovian> RyanT5000: the code is at http://paste.lisp.org/display/21588
07:51:34 <RyanT5000> k
07:51:49 <Itkovian> afaik each case results in a recursive call
07:52:14 <Itkovian> the Debug statements have been removed
07:54:10 * roconnor wants Rational an instance of Arbitrary in the ghc libraries
07:55:54 <RyanT5000> so when you run this you get a stack overflow?
07:56:24 <bolrod> > let incr x = x : incr (x+1) in incr 4
07:56:25 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
07:56:50 <RyanT5000> bolrod, i wasn't referring to *that*, lol
07:56:59 <bolrod> oh..
07:57:03 <Itkovian> RyanT5000: yeps
07:57:13 <RyanT5000> though that doesn't give a stack overflow either
07:57:44 <bolrod> buy a bigger stack..   you can buy extra slots for 10 silver at IF
07:57:56 <bolrod> :x
07:58:11 <Itkovian> sure, that does the trick ;-)
07:58:14 <RyanT5000> lol
07:58:45 <RyanT5000> well i dunno, because everything definitely look tail-recursive
07:58:56 <RyanT5000> do you have optimizations on? it shouldn't matter, though
07:59:07 <Itkovian> -O2 on x86
07:59:11 <bolrod> bitchmode off
08:00:43 <Itkovian> anyway, I'm off
08:00:44 <Itkovian> ttyl
08:06:15 <ihope> GHCi seems to be ignoring my type signatures.
08:08:03 <ihope> I used classes to do more "raw" overloading, where I apply a function to two values, and it returns either the first or the second, depending on the type needed.
08:08:50 <ihope> Eh, I'll just pastebin it.
08:09:04 <bolrod> excelent then
08:12:45 <Methyltheobromin>  /j #debian
08:12:51 <defcon8> let me guess
08:12:55 <defcon8> "oops"
08:18:04 <mahogny> is it just me or does happy give horrible error messages?
08:18:26 <ihope> It gives happy error messages!
08:18:28 <ihope> :-P
08:19:27 <ihope> Well, the ol' Pastebin conveniently stopped working.
08:19:32 <mahogny> happy.bin: Error when de-litify-ing  <-- sad error message :(
08:19:45 <mahogny> what should I look for?
08:20:09 <dfeuer> Quaere: Given a list of 2-3 finger trees with shared structure, how expensive is it to construct the equivalent structure with object identity?  Or, alternatively, to write the structure to disk using sharing?
08:20:53 <dfeuer> (list of length n, max tree depth k)
08:21:31 <ihope> Here we go. http://pastebin.ca/69122
08:21:39 <dcoutts_> dfeuer, sounds tricky
08:25:31 <Methyltheobromin> has anyone else noticed the Project Euler downtime today?
08:25:55 <Methyltheobromin> it's ip again, but I can't login :'(
08:26:02 <Methyltheobromin> up
08:29:54 <defcon8> roots a b c =. how do i use the function?
08:29:59 <defcon8> roots 1 2 3 ?
08:31:31 <audreyt> you use it like "roots thisMachine thatMachine andAnotherMachine" to gain root priviledge
08:32:51 <defcon8> naah this is from yaht
08:33:10 <defcon8> i added it to my Test.hs, did :r. and it says it is out of scope. but the other functions work fine
08:33:49 <ski> indenting ?
08:34:44 <defcon8> it is fine
08:35:02 <ski> lisppaste2: url?
08:35:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:35:08 <defcon8> worked this time
08:35:09 <defcon8> thanks anyway
08:35:21 <ski> ok
08:40:45 <shapr> @yow !
08:40:45 <lambdabot> Thank god!! ... It's HENNY YOUNGMAN!!
08:40:49 <shapr> EnterTAINMENT!
08:47:16 <int-e> ihope: it can't decide which instance of Coerce you want for (a,a)
08:47:43 <ihope> Shouldn't it wait until I try to use it for an (a, a)?
08:47:48 <int-e> ihope: i.e. it has to assume that a and b could be equal.
08:48:26 <int-e> ihope: it's saying that the choice is incoherent - a version specialised for (a,a) may have different results.
08:49:04 <ihope> Is there a way to make it choose the first for weirdFst and the second for weirdSnd?
08:49:33 <int-e> uh, read the error message? -fallow-incoherent-instances
08:50:22 <int-e> it tells you how to get rid of it, and it even tells you which instance it would use - and it's exactly the one you want.
08:51:30 <ihope> Okay, I did that.
08:51:59 <ihope> weirdFst (mkWeirdPair "foo" "bar") :: String just gives more error messages.
08:55:02 <defcon8> times a 1 = a
08:55:02 <defcon8> times a b = a + times a (b-1)
08:55:17 <defcon8> this works. but is it properly functional. is it properly recursive as it should be in haskell?
08:55:48 <ihope> Well, you'll probably want tail recursion.
08:55:56 <defcon8> how do you mean?
08:56:00 <ihope> times a b = times' a b 0
08:56:11 <ihope> times' a 1 c = a + c
08:56:14 <defcon8> i havent learnt about that yet
08:56:22 <ihope> times a b c = times a (b-1) (a+c)
08:56:44 <defcon8> Define a recursive function mult that takes two positive integers a and
08:56:44 <defcon8> b and returns a*b, but only uses addition (i.e., no fair just using multiplication). Begin
08:56:44 <defcon8> by making a mathematical definition in the style of the previous exercise and the rest of
08:56:44 <defcon8> this section.
08:56:46 <defcon8> sorry
08:56:49 <ihope> Erm, that last line should have times' on both sides.
08:56:50 <defcon8> i thought it'd be in one line
08:57:17 <defcon8> doesn't my version go with the criteria?
08:57:22 <ihope> I think it does.
08:57:39 <dmhouse> defcon8: Yep, that's fine.
08:58:06 <ihope> By the way, you might want to change the first line up there to "times a 0 = 0", if you want to be able to multiply by zero.
08:59:29 <defcon8> mapper func (x:xs) =
08:59:30 <defcon8>     func x
08:59:30 <defcon8>     mapper xs
08:59:34 <defcon8> why isn't that working?
08:59:44 <dmhouse> Because Haskell isn't an imperative language :)
08:59:50 <defcon8> :|
08:59:58 <dmhouse> You can't do two things in one function.
09:00:01 <defcon8> really?
09:00:04 <defcon8> whoah
09:00:05 <dmhouse> Yeah.
09:00:14 <dmhouse> Don't worry, it's not as major as you thinl.
09:00:16 <dmhouse> *think
09:00:18 <defcon8> wait
09:00:19 <defcon8> let me think
09:00:26 <defcon8> i'll figure it :)
09:00:27 <dmhouse> I've been programming Haskell for several months, and have needed it.
09:00:29 <ndm> dmhouse: i updated hoogle to search appropriately for hoogle.txt, have you had a chance to test it
09:00:33 <ihope> mapper func (x:xs) = do ...
09:00:40 <dmhouse> ndm, I got your message, but haven't tested it yet.
09:00:44 <dmhouse> ihope, that's not a good idea.
09:00:50 <ihope> It isn't?
09:00:55 <dmhouse> ihope, he's defining map.
09:01:04 <ndm> dmhouse: cool, let me know when you do, and I can remove teh excess stuff for GHCi on the wiki
09:01:07 <ihope> Oh.
09:01:34 <defcon8> i don't know about do yet
09:02:06 <dmhouse> defcon8: Ignore it.
09:02:14 <defcon8> mapper func (x:xs) =
09:02:14 <defcon8>     mapper (func x) xs
09:02:15 <defcon8> ?
09:02:22 <dmhouse> Almost.
09:02:30 <dmhouse> Think about what you're trying to do.
09:02:47 <dmhouse> Mapping any function to the empty list will produce the empty list.
09:02:54 <defcon8> yeah
09:02:57 <dmhouse> So mapper func [] = [], as I guess you've already got.
09:03:12 <defcon8> so that and what i just wrote is correct?
09:03:22 <dmhouse> Nope.
09:03:44 <ihope> Programming in Haskell can be easier when you work backwards.
09:03:45 <dmhouse> Now, what does mapping do? It applies the function to every element in the list. In other words, it's the list resulting from applying the function to each element in the list.
09:04:45 <liyang> Consider the one-element list: mapper func [x] === mapper func (x:[]) === [func x] === ...
09:05:28 <defcon8> :(
09:05:39 <xerox> You want to build a new list.
09:05:48 <ihope> Well, suppose you've already mapped the list onto all but the first element.
09:05:54 <liyang> === func x : []  -- is the next bit I'd have written.
09:06:03 * mux shakes his fist at php coders
09:06:06 <ihope> Erm, mapped the function onto all but the first element of the list.
09:06:24 <dmhouse> mux, pourquoi?
09:06:38 <mux> would you believe it if I tell you I'm seeing a website here where the guy matches login/passwords with a LIKE in his SQL query, and thus you can use '%' as the password for *any* account?
09:06:54 <ihope> If you've already done that, then you already have "mapper func xs".
09:06:56 <mux> well this is real
09:07:02 <defcon8> tell me the site :)
09:07:14 <mux> I can't, that wouldn't be very professional :-)
09:07:21 <defcon8> party pooper
09:07:33 <ihope> Then you just need to apply the function to the first element, that is, "func x".
09:07:54 <ihope> Then you put that in front of the mapped list, so you have func x : mapper func xs.
09:08:54 <defcon8>   mapper (func x) xs
09:08:56 <mux> this is nearly worth a news entry on thedailywtf.com
09:08:57 <defcon8> that should be fine
09:09:01 <defcon8> i don't understand why it isn't
09:09:06 <dmhouse> defcon8: Think about the types.
09:09:31 <dmhouse> if func has type Int -> Bool, say, then what type does (func x) have, where x is an Int?
09:10:42 <defcon8> damn it
09:11:20 <ihope> With mapper (func x) xs, you're trying to map the function func x onto each element of xs.
09:11:26 <defcon8> i miss imperative
09:11:54 <dmhouse> defcon8: You'll get over it. Honestly.
09:11:55 <ihope> Well, what should the first element of the resulting list be?
09:12:06 <defcon8> func x
09:12:08 <dmhouse> I know I didn't believe them when I was told that, but I did.
09:12:17 <defcon8> yes, nor do i
09:12:27 <ihope> defcon8: yep. And what should the rest of the list be?
09:12:27 <defcon8> i'm sure haskell makes your iq go up by about 10
09:12:38 <defcon8> then i'll be able to join mensa :D
09:12:46 <defcon8> it should be xs
09:13:00 <ihope> Well, you need to map the function func onto each element of xs.
09:13:16 <dmhouse> Experimentation is also a good way to learn:
09:13:18 <ihope> You can use the function "mapper" inside itself.
09:13:28 <defcon8> yeah that's what i'm trying to do
09:13:42 <dmhouse> > let mapper func [] = []; mapper func (x:xs) = func x : xs in mapper (\x -> x + 2) [1..5]
09:13:48 <lambdabot>  [3,2,3,4,5]
09:13:58 <dmhouse> It seems if we use xs it only applies the function to the head of the list.
09:14:09 <defcon8> no examples please
09:14:12 <ihope> Yep. You need to apply it to each element of xs, too.
09:14:38 <ihope> Often, the best way to find the answer is to pretend you already have it.
09:15:06 <int-e> > let pie = pie in pie
09:15:07 <lambdabot>  Add a type signature
09:15:11 <int-e> > let pie = pie in pie :: Int
09:15:12 <lambdabot>  Exception: <<loop>>
09:15:22 <defcon8>     func (mapper x xs) ?
09:15:28 <ihope> So in implementing mapper, you can assume you already have mapper, because you do.
09:15:42 <defcon8> naah
09:16:12 <ihope> Well, "mapper func (x:xs)" applies func to each element of (x:xs).
09:16:31 <ihope> To do that, you need to apply func to x, then apply it to each element of xs.
09:17:03 <ihope> So mapper func (x:xs) = func applied to x : func applied to each element of xs.
09:17:39 <defcon8> i think i need to restructure it
09:17:51 <defcon8> no
09:18:18 <ihope> Well, "func applied to x" is simply "func x".
09:18:46 <ihope> What's "func applied to each element of xs"? Remember that you *can* use the mapper function here.
09:19:12 <defcon8>   func (mapper func xs) ?
09:19:38 <defcon8> i am just guessing now
09:19:41 <ihope> Close.
09:19:44 <defcon8> i think ill get a peice of paper
09:19:49 <ihope> It's mapper func xs.
09:20:32 <ihope> mapper already applies func to each element of xs, so you don't need to do it again.
09:21:30 <defcon8> you know when you get really frustrated as a child when you can't do something and you want to cry?
09:22:00 <jer> defcon8, having a flashback are we?
09:22:08 <ihope> Well, we already have "func x" and "mapper func xs", so we just put them together into "func x : mapper func xs".
09:22:30 <ihope> So that's the answer: mapper func (x:xs) = func x : mapper func xs.
09:22:55 <defcon8> you coulda hinted to use the : :(
09:22:58 <defcon8> jer: yes
09:23:14 <defcon8> ihope: i was thinking about something like that but i didnt think of doing it
09:23:21 <defcon8> i mean i didnt know how to
09:23:49 <defcon8> thanks for your patience
09:27:18 <defcon8> is do, purely functional?
09:27:45 <ihope> Yes.
09:27:58 <dmhouse> do gets translated to purely functional code.
09:28:33 <defcon8> but i could then just use do for imperative purposes
09:28:41 <dmhouse> You can't use it everywhere.
09:28:52 <dmhouse> It's best to pretend it doesn't exist until you learn about monads proper.
09:29:16 <dmhouse> Apart from doing IO.
09:29:44 <ihope> Well, you can make your own monads for doing things that are imperative.
09:30:24 <dmhouse> ihope, "until you learn about monads".
09:30:34 <jer> of course, understanding monads requires a virgin sacrifice
09:30:41 <jer> =D
09:30:50 <ihope> Either that or a good tutorial.
09:30:53 <defcon8> isokay
09:31:18 * defcon8 is virgin :$
09:31:32 <dmhouse> defcon8: Hang in there. Haskell is the most rewarding language you'll ever learn.
09:31:35 <ihope> My mini-tutorial: know what the $ operator does, then compare the type of ($) to that of (=<<)
09:31:45 <defcon8> i wonder why yaht uses do so early on
09:31:49 <defcon8> i don't think it is good to teach
09:32:05 <defcon8> dmhouse: yes. it seems fun already. every recursive function is a little iq question
09:32:16 <defcon8> no, really, it is fun
09:33:05 <jer> defcon8, yaht uses do so early on because it demonstrates basic IO very early on
09:33:25 <defcon8> num <- randomRIO (1::Int, 100)      <--- why can't the 1::Int be 1
09:33:57 <ihope> Because 1 can have different types, and randomRIO can take different types.
09:34:08 <jer> because 1 is an instance of the Num class; if you want an integer explicitly, you need to specify an explicit type
09:34:09 <defcon8> what else can 1 be?
09:34:19 <RyanT5000> a float
09:34:23 <defcon8> double?
09:34:29 <ihope> A Float, an Integer, a Double...
09:34:48 <dmhouse> Float, Int, Integer, Double is about it in the standard libraries.
09:35:03 <ihope> Actually, I think Haskell will assume it's an Integer if it can't figure out what it should be.
09:35:08 <Stinger_> apparently a Rational
09:35:17 <dmhouse> @hoogle Rational]
09:35:18 <lambdabot> No matches, try a more general search
09:35:19 <dmhouse> @hoogle Rational
09:35:20 <lambdabot> Prelude.Rational :: type Rational
09:35:20 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
09:35:20 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
09:35:28 <dmhouse> Oh yeah, Rational and Ratio as well.
09:35:30 <dmhouse> @instances Num
09:35:32 <lambdabot> Double, Float, Int, Integer
09:35:45 <dmhouse> Hrm.
09:35:45 <ihope> So basically, the problem is that you're trying to pass an overloaded value into an overloaded function.
09:36:20 <dmhouse> Oh, Rational is just a Ratio over the integers. 
09:36:22 <dmhouse> @hoogle Ratio
09:36:23 <lambdabot> Data.Ratio :: module
09:36:23 <lambdabot> Ratio :: module
09:36:23 <lambdabot> Data.Ratio.Ratio :: data Ratio a
09:36:32 <dmhouse> @instances-importing Data.Ratio Num
09:36:33 <lambdabot> Double, Float, Int, Integer, Ratio a
09:39:24 <vincenz> re
09:40:27 <defcon8> hello, vincenz
09:40:57 <ihope> Maybe I can settle for that slightly-higher AC.
09:40:59 <vincenz> hello defcon8 
10:03:39 <vincenz> lol: http://it.slashdot.org/article.pl?sid=06/06/22/029243&from=rss
10:04:41 <vincenz> @bot
10:04:41 <lambdabot> :)
10:09:35 * ihope looks up
10:09:40 <vincenz> silence
10:09:45 <defcon8> .
10:09:49 * ihope is silent
10:13:20 <vincenz> @google ibidem
10:13:23 <lambdabot> http://www.bartleby.com/61/47/I0004700.html
10:13:23 <lambdabot> Title: "ibidem. The American Heritage&#174; Dictionary of the English Language: Fourth E ..."
10:33:06 * SamB wonders if something has changed about the linking between GHC 6.4 and GHC 6.4.1
10:35:13 <SamB> Hmm...
10:35:23 * SamB wonders why his menu has no visible entries
10:36:42 * SamB finally got around to installing GHC 6.4.1 and building and installing gtk2hs and trying to build that Inform 7 IDE with it so he could pop up a menu when he has no event
10:38:16 * SamB thinks gtk2hs/demo/mozembed/TestEmbedMoz.hs should have a context menu
10:38:46 * SamB does know that that requires C++, though
10:39:02 <dfeuer> How'd the U.S. do today?
10:39:26 * SamB doesn't follow the world cup
10:40:47 <sieni> dfeuer: lost
10:40:53 <dfeuer> oooh
10:40:55 <dfeuer> So they're out?
10:41:01 <sieni> dfeuer: yes
10:41:06 <dfeuer> ah....
10:41:29 <sieni> dfeuer: although they played a draw against italy, which was quite an achievement
10:41:52 <dfeuer> I remember that.
10:44:54 <SamB> so, what do I need to do to a menu to get the items to show up?
10:45:33 <dfeuer> menu?
10:45:49 <SamB> as in a GTK menu?
10:45:51 <dfeuer> oh
10:50:14 <SamB> @subclasses-importing Graphics.UI.Gtk ContainerClass
10:50:15 <lambdabot> Unknown command, try @list
10:50:18 <SamB> awwwww
11:01:25 <shapr> oj, I've been offered a $100 contract to configure email for a company that wants to send bulk spam.
11:01:52 <mauke> .oO( non-bulk spam? )
11:01:56 <SamB> isn't that illegal?
11:02:17 <dfeuer> The law has so many holes you could drive a truck through it.
11:02:26 <shapr> Yeah, but they're calling it mailing lists with several thousand members.
11:02:43 <dfeuer> There are legitimate lists of that size.
11:02:54 <dfeuer> But not offering $100 contracts, probably.
11:02:55 <shapr> I offered to add a bunch of anti-spam features. They said they don't need those, but outgoing mail has to get through spam filters.
11:03:10 <shapr> Their hostname is fatdrop, what do you think?
11:03:15 <dfeuer> hmmm
11:03:50 <shapr> They're a new company and can't configure email in Linux...
11:04:33 <RyanT5000> lol how much do you want $100?
11:04:52 <shapr> Not enough to have spam on my conscience.
11:05:57 <bolrod> haha
11:06:22 <bolrod> fatdrop?... dot what?
11:06:35 <shapr> dot co dot uk
11:06:57 <bolrod>     Registrant type:
11:06:58 <bolrod>         UK Sole Trader
11:07:00 <bolrod> erhhhhhh
11:07:14 <shapr> They also want BIND9 configured.
11:07:32 <bolrod> how difficult is it to configure postfix!
11:07:43 <shapr> I'd surely think less of myself if I took money from a spammer to help them send spam.
11:07:44 <bolrod> I mean.. there must be hundreds of tutorials out there
11:07:53 <shapr> Yeah, but they've tried postfix & qmail both.
11:07:58 <shapr> And have been unable to get it working.
11:08:08 <bolrod> maybe he's already on the blacklist?
11:08:24 <shapr> I doubt it, he can't send email yet.
11:08:35 <bolrod> maybe his ISP won't let him
11:09:35 <bolrod> which is ofcourse totally reasonable if you want to send spam
11:09:50 <jewel> Rtt.Multi fully embraces all of Microsoft's strategic technology initiatives: &nbspWin32 on the desktop, OLE/COM as the object model, and VBA as the scripting language.
11:10:10 <shapr> What's Rtt.Multi?
11:10:57 <jewel> it's at http://www.dot.co.uk/
11:11:26 <jewel> oh, I missed the fatdrop part
11:11:31 <jewel> different company :-)
11:11:57 <bolrod> shapr: I think it's some box on a university network.. what do you think?
11:12:31 <bolrod> you could call the registrar of the ip-range ;)
11:15:04 <vincenz> yay for packing
11:17:41 <mnislaih> @seen Lemmih
11:17:41 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
11:17:55 <shapr> bolrod: I don't know.
11:18:07 <mnislaih> Lemmih: hi there
11:18:18 <shapr> bolrod: rnds is iomart.com, never heard of 'em.
11:19:09 <bolrod> PING fatdrop.co.uk (62.128.202.126):
11:19:44 <bolrod> person:         Richard Mcmahon
11:20:11 <bolrod> if you search that person on google..
11:20:19 <bolrod> you get Richard McMahon at the Institute of Astronomy, Cambridge Home Page
11:20:35 <bolrod> I'm guessing he didn't order that ip-range for personal use
11:21:42 <shapr> bolrod: How'd you come up with that name?
11:21:55 <bolrod> whois the ip adress
11:22:01 <bolrod> you get phone number and everything
11:22:04 <shapr> oh, I see.
11:22:10 <bolrod> address:        West Of Scotland Science Park
11:22:14 <bolrod> :P
11:22:23 <shapr> It seems he owns iomart.com?
11:22:45 <Excedrin> that's the ISPs info
11:22:52 <shapr> Anyway, I'm sending this guy a mail saying that if he wants to send spam, I'm not interested.
11:23:46 <belleke> i'm new in programming is haskell worth a try?
11:23:51 <Excedrin> sure
11:24:00 * palomer hits opengl over the head a few times
11:24:03 <Philippa> it looks likely to be what I'll teach my boyfriend first
11:24:07 <Philippa> no idea if he'll ever forgive me :-)
11:24:07 <bringert> hej shapr
11:24:44 <belleke> is it simular to c or c++?
11:24:50 <Excedrin> shapr: it doesn't look like a spammer, spammers don't use postfix or qmail
11:24:55 <Excedrin> belleke: no
11:25:19 <shapr> Excedrin: It's possible this person is an especially clueless spammer?
11:25:50 <belleke> no i'm not a spammer
11:25:59 <shapr> belleke: No, not you :-)
11:26:09 <shapr> hoi belleke, hoe gaat het?
11:26:12 <belleke> Sorry
11:26:18 <belleke> hey
11:26:18 <shapr> belleke: Yes, Haskell is worth trying!
11:26:48 <belleke> shapr: eindelijk iemand die nederlands klapt
11:27:00 <int-e> . o O ( but first forget everything you know about C )
11:27:14 <SamB> shapr was talking about someone who wants to pay him $100 to configure mail for some, er, rather large mailing lists
11:27:17 <Excedrin> shapr: seems highly unlikely, just ask for more details about what they're sending and how they get the addresses they send to, etc
11:27:21 <lightstep> int-e, he said he's new to programming
11:27:31 <defcon8> http://deadbeefbabe.org/paste/885  what is wrong with the indentation there?
11:27:44 <defcon8> i've tried with emacs' sole indentation and it doesn't work either. that seems wrong anyway
11:28:00 <bringert> defcon8: try indenting the else one step
11:28:10 <shapr> hej bringert!
11:28:11 <bringert> both elses actually
11:28:16 <defcon8> emacs says sole indentation
11:28:25 <defcon8> who wrote haskell-mode ?
11:28:31 <bringert> defcon8: the emacs mode is not always right
11:28:38 <bringert> unfortunately
11:28:46 <defcon8> that must be worked on i think
11:29:05 <bringert> yep it should
11:29:22 <bringert> but who wants to hack lisp code?
11:29:32 <defcon8> sorry?
11:29:36 <defcon8> oh right
11:29:41 <defcon8> don't you like lisp?
11:30:04 <bringert> well, that's all relative
11:31:03 <bolrod> Excedrin: what would they use then?
11:31:38 <bolrod> belleke: no it's not like C or C++
11:31:50 <bolrod> it's totally different
11:31:55 <belleke> i'm totally new in haskell have no programming experience  not in c , java, basic nothing
11:32:01 <bolrod> cool
11:32:05 <belleke> haha
11:32:06 <bolrod> doesn't really matter :P
11:32:12 <Excedrin> bolrod: typically, stuff that sends mail thru open relays or zombies or whatever
11:32:34 <bolrod> well.. postfix can use relays
11:32:36 <belleke> is it easy to learn?
11:32:48 <bolrod> well.. depends on what you want to do..
11:33:01 <belleke> dunno
11:33:03 <bolrod> I guess gui's aren't the easiest thing in haskell
11:33:14 <shapr> belleke: Haskell rocks, you gonna love it!
11:33:20 <bolrod> hehe :)
11:33:28 <lightstep> (show the demo)
11:33:34 <bolrod> Excedrin: I guess if you're a real spammer.. you write your own software
11:33:44 <bolrod> to relay spam to your own farmed zombies
11:33:50 <belleke> someone has good tutorials for beginners or suggestions?
11:34:04 <Excedrin> @where yaht
11:34:04 <bolrod> do you run windows ?
11:34:05 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
11:34:09 <belleke> linux
11:34:26 <bolrod> first you want to install ghc I guess
11:34:29 <Excedrin> @where helium
11:34:29 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
11:34:35 <bolrod> or that..
11:34:45 <bolrod> but that may take some convincing to install
11:35:37 <belleke> ghc does dis work in a terminal?
11:35:41 <bolrod> yes
11:35:44 <belleke> ah
11:35:45 <bolrod> helium doesn't
11:36:11 <belleke> helium for linux?
11:36:15 <bolrod> helium has better error reports
11:36:20 <bringert> shapr: I've made some serious changes to Hope to make it a more painless to add modules
11:36:26 <bolrod> but doesn't support everything in haskell
11:36:32 <bringert> shapr: you shouldn't have to write any DB code now
11:36:38 <bringert> for simple modules anyway
11:37:26 <belleke> i read that it is a bit slower than c is this right?
11:37:32 <bringert> shapr: I haven't implemented the nice things I want to do with it, but that should come around next week, once I've submitted my ICFP paper
11:37:59 <bolrod> well.. if you're just starting with programming.. I guess speed doesn't matter
11:39:11 <belleke> :-)
11:39:19 <bolrod> and I guess C is more difficult to learn then haskell
11:39:23 <bringert> belleke: given a specific task and a set amount of time, I think you'd often get faster programs in Haskell. This is because coding in Haskell is faster, so you get more time to spend on getting the algorithm right
11:39:42 <bringert> bolrod: it's more difficult to do everything right in C
11:39:51 <bolrod> in C you're wasting more time on getting the variables right
11:39:56 <bringert> like avoid security problems, memory leaks, crashed
11:40:01 <bringert> crashes
11:40:01 <bolrod> ofcourse
11:40:10 <bolrod> Segmentation Fault
11:40:13 <bolrod> etc. ;p
11:40:52 <bolrod> Java is probably a good imperative language to start with
11:41:23 <hyrax42_> python or ruby are friendlier
11:41:25 <int-e> what about python?
11:41:32 <bolrod> belleke: do you have any idea about a program to make then?
11:42:04 <int-e> Hmm. Ruby. I guess I should learn that.
11:43:04 <belleke> nope not really .maybe a calendar that pops up when i forgot something
11:43:40 <bolrod> well.. you could do that yes..
11:44:48 <belleke> a browser??
11:44:55 <belleke> webbrowser
11:45:17 <bolrod> I guess that might be a bit more difficult
11:45:26 <bolrod> since you then have to parse HTML
11:45:33 <bolrod> which isn't always very neatly written
11:46:06 <belleke> yes i see
11:46:22 <bolrod> plus networking.. 
11:46:28 <bolrod> http protocol ;p
11:46:37 <bolrod> nahh... that's a bit too much to start off with
11:47:00 <bolrod> nahh... that's a bit too much to start off with
11:47:02 <bolrod> oops -.-
11:47:04 <bolrod> do you like maths?
11:47:10 <belleke> uhu 
11:47:18 <belleke> yes
11:47:25 <bolrod> you could write some simple functions with haskell very easilly
11:47:36 <bolrod> ABC-formula
11:47:40 <bolrod> fibonaci sequence
11:47:48 <belleke> hhmm
11:48:20 <bolrod> > let fib = 1:[x | zipWith (+) fib (tail fib) ] in take 5 fib
11:48:21 <lambdabot>  Not in scope: `x'
11:48:22 <SamB> belleke: the tricky part of making a calendar that pops up when you forgot something is getting it to figure out when you forgot something
11:48:30 <bolrod> > let fib = 1:[x | x<-zipWith (+) fib (tail fib) ] in take 5 fib
11:48:31 <lambdabot>  Exception: <<loop>>
11:48:41 <bolrod> hrm... something like that.. I forget :p
11:49:02 <bolrod> SamB: you could make a cronjob to run it every minute ofcourse
11:49:07 <belleke> can you write everything in haskell?
11:49:15 <ski> > let fibs = 0 : 1 : [x | x <- zipWith (+) fibs (tail fibs)] in take 5 fibs
11:49:16 <lambdabot>  [0,1,1,2,3]
11:49:19 <ski> > let sieve (p:ns) = p : sieve [n | n <- ns , n `mod` p /= 0] in take 25 $ sieve [2..]
11:49:20 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
11:49:38 <bolrod> hrm... mine didn't start up? ;P
11:49:41 <ski> > let fibs = 0 : 1 : [x | x <- zipWith (+) fibs (tail fibs)] in take 25 fibs
11:49:42 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:49:45 <bolrod> > let fib = 0:1:[x | x<-zipWith (+) fib (tail fib) ] in take 5 fib
11:49:46 <lambdabot>  [0,1,1,2,3]
11:49:50 <bolrod> ahIC
11:49:57 <bolrod> well.. I had it almost right then ;p
11:50:01 <ski> you need two initial elements
11:50:06 <SamB> bolrod: you forget something every minute, on the minute?
11:50:18 <SamB> belleke: everything?
11:50:26 <bolrod> SamB: it could check every minute
11:50:29 <SamB> belleke: can anyone write everything?
11:50:34 <bolrod> hard part then being to make it 'pop up'
11:50:41 <SamB> bolrod: but how would it tell if you *had* or not?
11:50:49 <hyrax42_> where can I find the code referred to in the annotation:
11:50:52 <hyrax42_> http://hackage.haskell.org/trac/ghc/ticket/721
11:50:58 <belleke> like alle the programms i get with linux can i get the same program written in haskell?
11:51:07 <bolrod> SamB: ofcourse.. a calendar isn't a trivial program
11:51:11 <hyrax42_> (ideally http-browsable source)
11:51:15 <SamB> belleke: that would be silly
11:51:28 <SamB> belleke: because you already have those programs
11:51:34 <bolrod> you could probably
11:51:39 <belleke> yes of course but is it possible
11:51:42 <bolrod> since there is gtk2hs
11:51:44 <bolrod> and opengl
11:52:02 <SamB> is it humanly possible?
11:52:05 <SamB> I would have to say no.
11:52:12 <SamB> some of those programs are pretty crazy.
11:52:17 <madpickle> whether or not it is is irrelevant; the point is to remember that haskell is just a tool to do a job
11:52:17 <bolrod> you don't want to rewrite every program into haskell ofcourse
11:52:19 <SamB> and you wouldn't have time!
11:52:29 <bolrod> but that's not the question ;p
11:52:29 <madpickle> and you pick the best tool to do a job
11:52:34 <madpickle> which may or may not be haskell
11:52:41 <SamB> some of those programs are not well suited to Haskell
11:52:52 <SamB> Haskell is not always the best language, unfortunately :-(
11:52:54 <bolrod> just like C isn't suited for every job
11:53:02 <bolrod> haskell isn't suited for every job ;p
11:53:27 <bolrod> haskell is probably alot more portable then C though
11:54:13 <SamB> certainly it shouldn't be too hard to write a lot of them
11:54:18 <belleke> i asked a few people what i should learn for programming language the about all told me c but i don't understand why
11:54:30 <bolrod> no you shouldn't
11:54:33 <belleke> its verry difficult  
11:54:40 <bolrod> well... C isn't difficult
11:54:48 <bolrod> it's just difficult to write a good working program with it
11:54:52 <bolrod> ;)
11:54:52 <SamB> yeah, it is difficult to write programs in ;-)
11:55:10 <belleke> then why do they use it ?
11:55:18 <bolrod> because it's    'fast'
11:55:39 <SamB> we don't understand it either
11:55:39 <lightstep> and because many people already know it
11:55:50 <bolrod> it's probably easier to stick to imperative when you spent 10+ years using that
11:56:01 <SamB> but, why did they write ZSNES in ASM? (actually, I think they had more excuse for that ;-)
11:56:24 <SamB> at least C has variable-name checking
11:56:40 <bolrod> ?..
11:56:40 <lambdabot> Not enough arguments to @.
11:56:52 <bolrod> variable-name checking?..   
11:57:00 <SamB> which?
11:57:02 <bolrod> doesn't every programming language with variable names have that?
11:57:11 <Lemmih> mnislaih: Hiya
11:57:16 <madpickle> any modern assembler would have that too, in fair ness
11:57:28 <SamB> okay, so... I've got my menu displaying correctly now.
11:57:43 <SamB> madpickle: I meant as opposed to Python or something like that ;-)
11:57:50 <madpickle> ah
11:58:21 <SamB> I really hate the way C makes you forward declare everything
11:58:22 <bolrod> what do you mean?... like you can put a string into a variable that was an integer before?
11:58:30 <bolrod> yeah EVERYTHING
11:58:40 <bolrod> even functions... thats a bit of a pain
11:58:45 <SamB> it tends to make your sourcefiles look a bit backwards sometimes
11:59:01 <madpickle> it's more of a pointer to a function
11:59:01 <bolrod> that's probably why they use header files
11:59:11 <madpickle> rather than the function itself
11:59:16 <int-e> hmm, that depends on whether you prefer the bottom up or the top down approach to programming
11:59:19 <madpickle> although i'm sure someone can cite a language that does it differently
11:59:29 <madpickle> int-e: i find a mix of both to be preferable
11:59:34 <lightstep> bolrod, the variable name check occurs only when you execute the code. you get a runtime error about a varible name, sometimes a long time after running the program
11:59:38 <madpickle> but experience in the language usually dictate your style, IMO
11:59:46 <SamB> I like a language which lets me define things in whatever order I like
12:01:08 <bolrod> yeah 
12:01:13 <bolrod> and runs from the bottom line up
12:01:28 <bolrod> well.. that's not functional anymore ofcourse
12:01:54 <GeniXPro> SamB, not exactly
12:01:55 <madpickle> bottom-up is a style of programming.. at least
12:02:00 <madpickle> that's what i think he alluded to
12:02:12 <madpickle> it's more of how you choose to go about writing something
12:02:45 <bolrod> global variables     i,j,n  are also nice
12:02:49 <bolrod> ;p
12:03:05 <madpickle> huh?
12:03:37 <SamB> it is good to be able to arrange my program in whatever order I think it is most easily perused in, without all kinds of redundant forward declarations to break the flow
12:04:11 <bolrod> anyway.. belleke when you know haskell a bit it might be nice to read through the haskell report
12:04:38 <SamB> now, it would also be nice to have more of a clue what order is nice ;-)
12:05:23 <defcon8> how do i print a list?
12:05:34 <bolrod> > show [1,2,3,4]
12:05:35 <lambdabot>  "[1,2,3,4]"
12:05:37 <mauke> print list
12:05:42 <defcon8> thanks
12:05:47 <belleke> ok first i learn the basic stuff maybe then i know what programm i would want to writh ;-)
12:06:10 <bolrod> but learning to program is best done by writing a program
12:06:40 <belleke> but where to start? how to start?
12:06:45 <hyrax42_> bolrod: all too true
12:07:04 <hyrax42_> but without knowing a littl,e it's hard to know what's possible, feasible, reasonable &c.
12:07:15 <bolrod> indeed ;p
12:07:29 <belleke> where can i find the commands?
12:07:35 <SamB> hmm...
12:07:35 <SamB> so, actually, my Back works.
12:07:36 <belleke> or wathever
12:07:40 <defcon8> http://deadbeefbabe.org/paste/887 what is wrong with the defs in main?
12:07:43 <SamB> its just that it doesn't *always* work.
12:08:16 <bolrod> belleke: http://www.cs.uu.nl/wiki/FP/CourseLiterature  <<  since you know dutch ;p
12:08:31 <bolrod> that's what I got for learning functional programming
12:08:32 <belleke> yess i'm dutch
12:08:41 <belleke> how did you know?
12:08:55 <bolrod> you have a belgium hostname
12:09:04 <bolrod> and you spoke some dutch when you came in
12:09:06 <int-e> defcon8: = vs <-
12:09:14 <belleke> uhu
12:09:19 <defcon8> oh of course
12:09:22 <defcon8> why was that again?
12:10:13 <defcon8> does it invoke evaluation before hand?
12:10:20 <int-e> yes
12:10:21 <vincenz> Lol
12:10:26 <vincenz> "PointerFunBig.avi"
12:10:48 <jgrimes_> :p
12:11:00 <vincenz> "Takes one pointer to change it so it points to the same pointee as another pointer" (point point)
12:11:19 <hyrax42_> defcon8: x <- askForWords
12:11:25 <hyrax42_> also in the else of askForWrods
12:11:31 <hyrax42_> rest <- askForWords?
12:11:59 <defcon8> it is in the tutorial
12:12:27 <hyrax42_> as you put it?
12:12:48 <hyrax42_> x = askForWords is a syntax error
12:12:52 <defcon8> i know
12:12:53 <defcon8> i changed it
12:13:17 <hyrax42_> also you can't do word <- read getLine
12:13:38 <hyrax42_> getLine returns IO String; read takes a string
12:13:53 <belleke> i like it
12:13:54 <defcon8> word <- read <- getLine ?
12:13:57 <bolrod> no
12:14:01 <hyrax42_> could be word <- return . read =<< getLine
12:14:07 <bolrod> getLine >>= read
12:14:12 <hyrax42_> or word <- getline
12:14:14 <defcon8> i'll do it with what i already know
12:14:28 <int-e> fmap read getLine
12:14:32 * int-e chuckles
12:14:36 <int-e> (liftM if you prefer)
12:14:45 <lightstep> @type readLine
12:14:46 <int-e> @type liftM
12:14:46 <lambdabot> Not in scope: `readLine'
12:14:47 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
12:15:00 <hyrax42_> @type getLine
12:15:02 <lambdabot> IO String
12:15:03 <hyrax42_> @type read
12:15:05 <lambdabot> forall a. (Read a) => String -> a
12:15:10 <ptolomy> @type fmap
12:15:11 <lightstep> @type readLn
12:15:12 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:15:12 <lambdabot> forall a. (Read a) => IO a
12:15:32 <hyrax42_> @type return . read =<< getLine
12:15:33 <lambdabot> forall a. (Read a) => IO a
12:15:45 <int-e> x <- readIO =<< getLine   ...   x <- readLn
12:15:53 <int-e> @type readIO
12:15:54 <lambdabot> forall a. (Read a) => String -> IO a
12:15:58 <hyrax42_> @type readIO
12:15:59 <int-e> @type readLn
12:16:00 <lambdabot> forall a. (Read a) => String -> IO a
12:16:01 <lambdabot> forall a. (Read a) => IO a
12:16:08 <hyrax42_> hm
12:16:21 <hyrax42_> in any case, if he's expecting strinsg, there's no need to read result of getLine
12:16:29 <defcon8> show doesn't work for lists
12:16:31 <hyrax42_> *you're
12:16:37 <defcon8> well, it didn't work for what i'm doing
12:16:42 <bolrod> show does work for lists
12:16:44 <int-e> but those seem to be ghc specific :/
12:16:48 <int-e> ?
12:16:57 <int-e> *goes check haskell report*
12:17:02 <bolrod> it just has to work too for the things inside the list
12:17:04 <lightstep> they're standard
12:17:10 <defcon8> cmd doesn't like to let people paste
12:17:35 <int-e> ok. yes, found them :)
12:17:51 <bolrod> cmd? .. like.. windows? :)
12:18:19 <defcon8> yes :$
12:18:55 <bolrod> you can
12:19:13 <defcon8> hmm now it works
12:19:15 <defcon8> didn't before
12:19:52 <belleke> windows sucks ,get linux!
12:19:53 <bolrod> windows cmd sucks anyway. 
12:20:04 <bolrod> true
12:20:14 <belleke> linux rullez
12:20:23 <belleke> :-)
12:20:27 <defcon8> i used linux for 4 years
12:20:37 <defcon8> problem: i got a l33t0 rig that 0wnz0rz you all
12:20:45 <defcon8> and i want to play games
12:20:54 <bolrod> leet rig?
12:20:54 <bolrod> hah
12:21:04 <belleke> cedega?
12:21:11 <bolrod> man.. as soon as you own a fast computer..
12:21:13 <defcon8> naah
12:21:14 <bolrod> it's outdated ;p
12:21:14 <defcon8> never works
12:21:23 <bolrod> it works for me!
12:21:25 <defcon8> bolrod: beat mah amd 64 x2 3800+
12:21:26 <bolrod> wine works too
12:21:30 <defcon8> the games never work
12:21:31 <belleke> wine
12:21:37 <belleke> wine works fine haha
12:21:41 <bolrod> games work fine with cedega
12:21:42 <defcon8> yeah, right
12:21:48 <bolrod> defcon8: I would if I had the money
12:21:55 <defcon8> :)
12:22:09 <bolrod> I gues dual G5 dual core 2.5GHZ ownz ur amd's
12:22:20 <hyrax42_> defcon8: edited your paste, but it's slow goig through
12:22:25 <defcon8> bolrod: naah
12:22:32 <defcon8> hyrax42_: i've advanced a lot since then
12:22:33 <hyrax42_> ah there you go
12:22:37 <bolrod> 64 bit procs? and you run windows?
12:22:37 <belleke> http://www.linux-gamers.net/
12:22:38 <defcon8> i will paste the current non-working version
12:22:45 <hyrax42_> oh ok
12:22:54 <hyrax42_> well my editgs make it work :p
12:23:15 <defcon8> http://deadbeefbabe.org/paste/888
12:23:28 <defcon8> doesn't everything work shit slow with cedega?
12:23:35 <bolrod> no way
12:23:36 <defcon8> i'm used to having everything on highest
12:23:52 <bolrod> wine is sometimes even faster then windows 
12:23:55 <hyrax42_> some faster than windows or so I hear
12:23:56 <defcon8> hahaha
12:24:09 <bolrod> it's not emulating anything
12:24:16 <bolrod> it's just a linux implementation of the windows API
12:24:20 <jer> wine won't be faster; however, the underlying operating system may be faster
12:24:28 <defcon8> i'll give it a try
12:24:29 <bolrod> no.. wine can be faster
12:24:40 <bolrod> because the implementation of the function may be better
12:24:42 <hyrax42_> defcon8: you can't do factorial on a string
12:24:46 <defcon8> how do i find the list of the games that cedega supports?
12:24:51 <defcon8> hyrax42_: forgot to read, sorry
12:24:58 <bolrod> on the cedega site
12:25:04 <belleke> thats wright becaus linux has a better calculating than windows
12:25:07 <bolrod> anyway... what games do you play?..
12:25:08 <defcon8> yeah couldn't find where it specifically was
12:25:11 <belleke> winblows i'm sorry
12:25:41 <hyrax42_> bah
12:25:46 <defcon8> oblivion, america's army (it's free, come on!), civ IV, heroes of might and magic V, graw, oblivion (duh?)
12:25:46 <hyrax42_> "reserve power"
12:26:02 <bolrod> aha..
12:26:02 <hyrax42_> prey demo...
12:26:03 <defcon8> still isn't working when you read it
12:26:16 * hyrax42_ wishes he had a decent internet connection here
12:26:24 <defcon8> hmm but that won't work either
12:26:32 <defcon8> i must write a function that returns a read version
12:26:53 <lightstep> defcon8, what type do you want?
12:26:59 <defcon8>   map factorial (read x)  <- i know that won't work
12:27:05 <defcon8> i want ints from chars
12:27:20 <bolrod> > ord 'c'
12:27:21 <lightstep> String -> Integer
12:27:22 <lambdabot>  99
12:27:29 <lightstep> that?
12:27:29 <bolrod> > ord '1' - '0'
12:27:30 <lambdabot>  Couldn't match `Int' against `Char'
12:27:31 <defcon8> no not ord
12:27:35 <defcon8> i want "0" to be 0
12:27:39 <bolrod> > ord '1' - ord '0'
12:27:40 <lambdabot>  1
12:27:43 <bolrod> ;)
12:27:43 <hyrax42_> map (factorial . read :: String -> Integer) x
12:27:45 <lightstep> or do you want to read from the user? then it'd be String -> IO Integer
12:27:50 <bolrod> > read "123321"
12:27:51 <lambdabot>  Add a type signature
12:27:53 <lightstep> err, just IO Integer
12:27:54 <bolrod> > read "123321" :: Integer
12:27:55 <lambdabot>  123321
12:27:57 <defcon8> yeah
12:28:02 <defcon8> i forgot about composition
12:28:34 <hyrax42_> :t map (id . read :: String -> Integer) []
12:28:36 <defcon8>   map (factorial . read) x why wont that work?
12:28:50 <hyrax42_> @type map (id . read :: String -> Integer) []
12:28:51 <lambdabot> [Integer]
12:29:03 <defcon8> it worked before
12:29:08 <bolrod> defcon8: what are you feeding it?
12:29:09 <defcon8> without any explicit types and so on
12:29:28 <defcon8> a list of numbers represented as characters
12:29:36 <hyrax42_> your factorial function is incomplete!
12:29:42 <bolrod> probably
12:29:47 <defcon8> yeah i'll do that
12:29:49 <dfeuer> I'd like to continue the discussion of views & such that we started yesterday.
12:30:17 <defcon8> factorial 0 = 1
12:30:17 <defcon8> factorial n =
12:30:17 <defcon8>     n * factorial (n - 1)
12:30:19 <defcon8> still isn't working
12:30:44 <dfeuer> What's it doing?
12:30:44 <hyrax42_> shoul do...
12:30:56 <defcon8> naah map (factorial . read) x isn't working i guess
12:31:17 <mauke> how is it not working?
12:31:24 <dfeuer> > let factorial 0 = 1; factorial n = n * factorial (n-1) in factorial 4
12:31:25 <lambdabot>  24
12:31:26 <belleke> bey 
12:31:31 <hyrax42_> works here
12:31:41 <dfeuer> > let factorial 0 = 1; factorial n = n * factorial (n-1) in factorial 4.5
12:31:42 <lambdabot>  Exception: stack overflow
12:31:45 <dfeuer> > let factorial 0 = 1; factorial n = n * factorial (n-1) in factorial 4.0
12:31:47 <lambdabot>  24.0
12:31:48 <bolrod> > let fac n = product [1..n] in map (factorial . read) ["12","31","31"]
12:31:48 <defcon8> Couldn't match `IO' against `[]'
12:31:48 <defcon8>   Expected type: IO t
12:31:48 <defcon8>   Inferred type: [b]
12:31:49 <lambdabot>  Not in scope: `factorial'
12:31:57 <bolrod> > let fac n = product [1..n] in map (fac . read) ["12","31","31"]
12:31:58 <lambdabot>  [479001600,8222838654177922817725562880000000,822283865417792281772556288000...
12:32:12 <mauke> defcon8: how are you using it?
12:32:22 <defcon8> in a do
12:32:29 <mauke> what kind of do?
12:32:37 <defcon8> main do
12:32:44 <mauke> yeah, that won't work
12:32:51 <bolrod> well duhhhh ! ::x
12:32:57 <mauke> main has an IO type
12:33:01 <bolrod> maybe paste the code?
12:33:05 <defcon8> well crud that
12:33:06 <defcon8> okay
12:33:14 <mauke> defcon8: what do you want to do with the result of map?
12:33:28 <hyrax42_> it sits there
12:33:38 <hyrax42_> you need toi put print $ in front
12:34:10 <hyrax42_> ok laptop will die brg
12:34:11 <defcon8> mauke: print
12:34:13 <hyrax42_> brb
12:34:21 <mauke> defcon8: then use print
12:34:59 <defcon8> http://www.deadbeefbabe.org/paste/889
12:35:22 <bolrod> you can't do that
12:35:37 <mauke> I don't see a "print" there
12:35:55 <xerox> Guess who's this guy <http://www.businessweek.com/magazine/content/04_19/art04_19/0419_24innova.jpg>
12:36:06 <madpickle> alan turing?
12:36:14 <xerox> ?karma+ madpickle 
12:36:14 <lambdabot> madpickle's karma raised to 1.
12:36:18 <madpickle> ;)
12:36:30 <madpickle> thanks
12:36:38 <bolrod> the last expression in a do needs to be of the type of the do block
12:36:41 <defcon8>  print map (factorial . read) x
12:36:42 <defcon8> ?
12:36:46 <bolrod> and in the main function case  IO ()
12:36:54 <mauke> print (map (factorial . read) x)
12:37:04 <hyrax42_> print $ map (factorial . read) x
12:37:09 <hyrax42_> or that
12:37:11 <xerox> bolrod - It needs to be an expression. Type safety is ensured by the type system everywhere, not just in the do blocks.
12:37:12 <lightstep> the parameter should be in parens, or separated with ($)
12:37:28 <defcon8> holy crap
12:37:30 <defcon8> it actually works
12:37:31 <defcon8> thanks
12:38:00 <mauke> GREAT SUCCESS!!
12:38:11 <hyrax42_> :)
12:38:23 <dfeuer> Question:  how tightly do type annotations bind, syntactically?
12:38:27 <hyrax42_> the type system seems like it's just there to kick you in the backside repeatedly at the start
12:38:34 <hyrax42_> but you end up really liking it
12:38:51 <lightstep> defcon8, now make the program not crash on invalid input
12:38:57 <hyrax42_> dfeuer: my guess is maximum
12:38:59 <defcon8> okay
12:39:32 <dfeuer> maximum?
12:39:49 <hyrax42_> tighter than anything else, I mean
12:40:14 <Revision17> any of you know of a good statistics library for haskell?  particularly having stuff for calculating sample confidence intervals (has tables or a method of calculating for different methods and stuff)
12:40:23 <dfeuer> > (/3) 4::Int
12:40:24 <lambdabot>  add an instance declaration for (Fractional Int)
12:40:24 <lambdabot>   In the expression: (/ ...
12:40:45 <xerox> > (`div`3) 4 :: Int
12:40:46 <lambdabot>  1
12:40:54 <dfeuer> meh
12:41:08 <dfeuer> @type div
12:41:09 <lambdabot> forall a. (Integral a) => a -> a -> a
12:42:05 <lightstep> > (\f->f 4 3) div :: Int->Int
12:42:06 <lambdabot>  add an instance declaration for (Integral (Int -> Int))
12:42:16 <dfeuer> > let div a b = fromIntegral a / fromIntegral b in div 3 4
12:42:17 <lambdabot>  0.75
12:42:27 <xerox> lightstep: it parses `...everything... :: Type'.
12:42:30 <defcon8> map print ( map (factorial . read) x) why won't that work?
12:42:45 <xerox> Gotta do `...almost everything (plus this :: Type)'.
12:42:55 <dfeuer> > let div a b = fromIntegral a / fromIntegral b in div 3 4 :: Rational
12:42:56 <lambdabot>  3%4
12:42:58 <mauke> defcon8: that yields a list of IO values
12:43:03 <lightstep> defcon8, the type doesn't fit
12:43:06 <hyrax42_> map returns a list
12:43:11 <defcon8> oh
12:43:11 <hyrax42_> not an IO list
12:43:21 <defcon8> i want to print each value one by one
12:43:21 <xerox> ?type sequence
12:43:23 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:43:24 <lightstep> you need to iterate through the list of actons, performing each
12:43:29 <dfeuer> > let div a b = fromIntegral a / fromIntegral b in div 3 (4::Int) :: Rational
12:43:30 <lambdabot>  3%4
12:43:32 <xerox> ?type mapM_
12:43:33 <mauke> @type mapM_
12:43:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
12:43:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
12:43:38 <lightstep> which sequence and sequence_ do
12:43:38 <dfeuer> Not most tightly.
12:43:45 <hyrax42_> mapM_ would do it
12:43:52 <dfeuer> > let div a b = fromIntegral a / fromIntegral b in div 3 4::Int :: Rational
12:43:53 <lambdabot>  Parse error
12:44:08 <lightstep> dfeuer, it's documented in the standard
12:44:08 <defcon8> how do i do that?
12:44:09 <dfeuer> > let div (a::Int) b = fromIntegral a / fromIntegral b in div 3 4 :: Rational
12:44:10 <lambdabot>  Parse error in pattern
12:44:26 <mauke> defcon8: mapM_ print (...)
12:44:31 <hyrax42_> you can't type annotate a patter, only expression
12:45:00 <defcon8> oh i know how
12:45:03 <defcon8> sorry
12:45:04 <shapr> bringert_: What do you think about something like a member folder where we could upload and list/preview many types of files? For example, a pdf/ps could have a preview image of the first page, etc  Also, what do you think about a forum plugin?
12:45:51 <shapr> bringert: The no-db-code improvement sounds awesome, I'm looking forward to trying it.
12:46:14 <shapr> bringert: The reason I'm asking about member folders and forums is that I have this contract work where the client just doesn't care how the backend works as long as it does work...
12:46:30 <shapr> So I figure, Haskell in the enterprise! Yay!
12:46:32 <defcon8> actually how would i do that in a recursive function?
12:46:40 <bringert> shapr: about forums: I want to added threaded comments to all items (log entries, photos etc.) Would blog entry + comments qualify as a forum?
12:46:45 <bringert> shapr: cool
12:46:48 <hyrax42_> defcon8: how you mean
12:46:50 <dmhouse> Raargh.
12:46:57 <bringert> shapr: what do you mean by member folder?
12:46:57 * dmhouse has just seen United 93
12:46:59 <shapr> bringert: Yeah, threaded comments would work.
12:47:17 <bringert> is it just a place for per-user files?
12:47:18 <shapr> bringert: What about generalized comments like generalized tags?
12:47:21 <shapr> bringert: Yeah
12:47:27 <defcon8> hyrax42_: i want to print all the values in a list on a separate line
12:47:32 <bringert> bringert: yes, generalized comments is exactly what I want
12:47:34 <shapr> Somewhere that users can upload their own files and other people can see a listing.
12:47:37 <vincenz> Anyone know how to open .chm files in linux
12:47:48 <shapr> bringert: Spiffy :-)
12:48:06 <bringert> shapr: now that everything is an item (well users, tags, roles) are not items, at least not yet, I plan to add comments for items
12:48:07 <shapr> I have to go pack now, but I'll check out the no-db-code patches when I get a chance.
12:48:12 <shapr> Oh cool
12:48:14 <madpickle> vincenz: compressed html file. you may have luck with that if you can find the windows exe that handles it and WINE it
12:48:23 * shapr goes off to throw away the last few computers...
12:48:24 <hyrax42_> defcon8: one pe rline?
12:48:26 <lightstep> defcon8, you can follow the pattern matching as adcive
12:48:47 <hyrax42_> something like printList [] = 
12:48:47 <defcon8> yes
12:48:48 <bringert> shapr: maybe ps/pdf, movies, pngs etc. can just be seen as other image types for halbum
12:48:50 <lightstep> and fit the IO actions in each branch
12:48:50 <madpickle> winhlp32.exe ro something
12:48:52 <hyrax42_> printList (x:xs) = 
12:48:55 <bringert> shapr: ok, later
12:48:56 <hyrax42_> (fill inthe gaps)
12:48:58 <defcon8> yeah
12:48:58 <hyrax42_> :)
12:49:02 <defcon8> that's what i'm trying
12:49:14 <vincenz> madpickle: thx
12:49:41 <hyrax42_> so when you want to print an empty list, what do you do?
12:50:01 <Revision17> vincenz: either gnochm or kchmviewer
12:50:07 <defcon8> hyrax42_: i'll sort that out aswell
12:50:10 <Revision17> if you don't want to use wine
12:51:02 <jgrimes_> > print []
12:51:03 <lambdabot>  No IO allowed
12:51:52 <kep> vincenz xchm can open .chm files in linux
12:52:36 <kep> vincenz: apt-cache search xchm
12:52:37 <kep> xchm - Compiled HTML Help (CHM) file viewer for X
12:53:00 <vincenz> kep: kewl
12:53:23 <hyrax42_> are there any "native" win32gui bindings
12:53:45 <dmhouse> I wish there were a way to see all the recent changes to an entire wikibook at once/
12:53:45 <hyrax42_> or is htk2hs the way to go
12:53:48 <hyrax42_> *gtk2
12:54:31 <kep> vincenz translate pls :)
12:54:38 <vincenz> kep: cool
12:54:44 <kep> vincenz ok :)
12:56:42 <jgrimes_> dmhouse: unlike related changes?
12:57:17 <dmhouse> jgrimes_: ooh, that looks good.
12:57:24 <jgrimes_> dmhouse: :)
13:02:45 <defcon8> bolrod: i will blow up your house if oblivion doesn't work
13:02:59 <dmhouse> Grr. Gmail need a feature that, when I hit "Reply", tells me "No, you want 'Reply to all', you stupid fool!".
13:05:54 <apfelmus> hyrax42_: HToolkit / gio has native win32 support but is currently hibernated. otherwise, people are using wxHaskell
13:06:25 <hyrax42_> apfelmus: ok thanks
13:08:50 <dmhouse> Gah. JRegex can't handle inputs of ~250KB.
13:38:19 <Jonnyw2k> hey
13:40:11 <bolrod> defcon8: just make a dual boot
13:40:26 <bolrod> and if you can afford 2 AMD's.. you can probably afford another hdd
13:40:28 <bolrod> ? :P
13:40:37 <defcon8> naah it's just dual core
13:40:42 <defcon8> and yes, i did get a new 250gb sata
13:41:29 <Jonnyw2k> well partition it
13:41:35 <defcon8> yes, i know
13:41:41 <defcon8> i just cant be arsed really
13:41:41 <bolrod> well do it
13:41:56 <defcon8> i've done it so many times before
13:42:06 <bolrod> how long does it take anyway
13:42:09 <bolrod> 2 minutes? !
13:42:13 <Jonnyw2k> ;p
13:42:13 <bolrod> just partition the damn thing
13:42:22 <bolrod> :P
13:42:22 <Jonnyw2k> wat distro do u recommend?
13:42:25 <defcon8> yes but i've already got ntfs on it
13:42:29 <defcon8> can't be asrsed to dl partition magic
13:42:34 <defcon8> Jonnyw2k: gentoo
13:42:37 <defcon8> or debian
13:42:42 <Jonnyw2k> well resize ur ntfs partition
13:42:47 <defcon8> i think i may get debian
13:42:57 <bolrod> and you are saying you don't have another disk ?
13:42:58 <defcon8> where from? windows' manager for partitions?
13:43:05 <defcon8> yes i do. my dad stole it
13:43:16 <defcon8> and i have another small one for windows
13:43:17 <bolrod> kick him
13:43:21 <defcon8> the 250gb is for storage
13:43:33 <defcon8> okay okay. i'll google :(
13:43:34 <zarvok> if you want to resize your ntfs partition you can just download a knoppix live CD and boot from that to do it
13:43:35 <Jonnyw2k> gentoo i dont really like
13:43:37 <bolrod> so you have a 250 GB + ?
13:43:39 <Jonnyw2k> i cudnt get it installed
13:43:46 <bolrod> gentoo takes too long to install
13:43:48 <defcon8> yeah
13:43:51 <bolrod> me neither
13:43:52 <defcon8> gentoo is easy
13:44:03 <bolrod> it gave an error when it was compiling the kernel
13:44:07 <defcon8> haha
13:44:09 <bolrod> now fix that :/
13:44:16 <Jonnyw2k> lol
13:44:24 <Jonnyw2k> i got an error as soon as i put thie disk in
13:44:31 <bolrod> hehe
13:44:34 <Jonnyw2k> (and the disk was fine as i installed it on a mates machine)
13:44:41 <Jonnyw2k> so it doesnt like my pc
13:44:47 <bolrod> possibly
13:44:49 <Jonnyw2k> ive used fedora but every1 moans at me about it
13:44:52 <bolrod> ubuntu is really nice
13:44:56 <Jonnyw2k> so i might try ubuntu
13:44:58 <Jonnyw2k> :p
13:45:06 <Jonnyw2k> iyeh thats the debain based one
13:45:07 <bolrod> I'm running ubuntu, and I'm pleased with it
13:45:19 <Jonnyw2k> wat is heskell based on?
13:45:26 <defcon8> fedora sucks
13:45:35 <defcon8> yum contains no packages
13:45:38 <Jonnyw2k> *haskell
13:45:46 <Jonnyw2k> yum is full of packages
13:45:46 <zarvok> Jonnyw2k: what do you mean based on?
13:45:51 <bolrod> apt is nice
13:46:01 <bolrod> haskell is based on haskell
13:46:06 <Jonnyw2k> uness u get into an rm dependicy loop were u cant install one dependicy wiht out the other
13:46:07 <bolrod> since you need ghc to compile ghc
13:46:21 <bolrod> ;)
13:46:27 <Jonnyw2k> :P
13:46:29 <defcon8> no it isnt
13:46:30 <Jonnyw2k> yeh like that
13:46:31 <dmhouse> GHC is written in Haskell plus a very little amount of C.
13:46:39 <Jonnyw2k> ahh kk
13:46:50 <dmhouse> You compile it on new systems by a very complicated building process :)
13:46:54 <Jonnyw2k> becoz im looking to stufy computer science degree at imperial college london
13:46:56 <bolrod> apt is very good at resoling dependancies
13:47:12 <dmhouse> You basically half-compile it on a seperate machine, then complete the compilation on the target machine.
13:47:16 <toefus> dmhouse, yeah, "emerge ghc" take 3 hours on my gentoo box
13:47:22 <Jonnyw2k> lol
13:47:24 <dmhouse> But if you just want to use it, binary, binary, binary!
13:47:28 <defcon8> Jonnyw2k: holy crap
13:47:29 <zarvok> from a theoretical perspective, haskell has its roots in the language miranda, is that what you're asking?
13:47:35 <defcon8> Jonnyw2k: is it as good as cambridge?
13:47:37 <bolrod> bwah.. if you have a AMD dual core..
13:47:38 * SamB thinks Jonnyw2k thinks Haskell is a Linux distribution
13:47:43 <bolrod> I guess it don't take 3 hours! :P
13:47:48 <Jonnyw2k> um no i dont
13:48:01 * bolrod thinks that SamB might be wrong
13:48:01 <Jonnyw2k> haskell is a language they teahc u in the first year at imperial
13:48:05 <SamB> well... then why did you want to know what it was based on?
13:48:14 <bolrod> well
13:48:17 <Jonnyw2k> well i ment is it based on windows or linux
13:48:18 <dmhouse> defcon8: ICL is one of the top 5 unis in the country for a lot of subjects.
13:48:23 * SamB has been confused before ;-)
13:48:25 <defcon8> yeah
13:48:26 <Jonnyw2k> asin wat platform do u run it on
13:48:30 <SamB> oh
13:48:32 <bolrod> erh
13:48:37 <SamB> well, it works better in *nix
13:48:38 <defcon8> i wonder if ICL accepts advanced highers from scotland
13:48:41 <bolrod> programming language are not based on any OS I guess
13:48:45 <zarvok> It's not "based on" any platform, there are compilers available for any OS
13:48:48 <toefus> bolrod, it takes two hours with a T2600
13:48:48 <Jonnyw2k> defcon8: they do
13:48:49 <SamB> at least, GHC does
13:48:58 <defcon8> nice
13:49:10 <bolrod> ASM is based on architecture...
13:49:23 <toefus> bolrod, i thing ghc generates C--
13:49:25 <bolrod> any other programming language that has that limitation?
13:49:30 <Jonnyw2k> but u need like 3 A's at alevels
13:49:33 <bolrod> toefus: it can... it doesn't need to
13:49:39 <Jonnyw2k> so ull probs need like A's at advanced highers
13:49:42 <Jonnyw2k> or summat like that
13:49:44 <defcon8> may i pm you, Jonnyw2k?
13:49:50 <Jonnyw2k> of course :P
13:50:02 <Jonnyw2k> ive forgot how the highers system works but i used to live in scotland :D
13:50:17 <bolrod> is that an excuse ?
13:50:18 <bolrod> ^.0
13:50:34 <Jonnyw2k> gimme 1 sec i need to register this nick again
13:50:37 <bolrod> he's from Barcelona!  
13:50:39 <bolrod> :D :D
13:50:58 <toefus> bolrod, ok thanks. and it has backends for C with gcc and native code, right ?
13:51:17 <bolrod> erh?
13:51:20 <bolrod> yes
13:51:39 <bolrod> maybe there are even some compilers that make java from the haskell code.. ?
13:52:24 <Jonnyw2k> wudnt that be a converter :S
13:52:56 <Jonnyw2k> ora  translater
13:53:05 <zarvok> Well, ghc itself originall compiled haskell down to C, right?  I mean, you don't have to compile into assembly, you can compile into any language
13:53:09 <toefus> bolrod, do you think the jvm is well-suited for running haskell code ?
13:54:05 <toefus> http://www.cse.unsw.edu.au/~pls/thesis-topics/ghcjava.html seems to be possible
13:56:30 <bolrod> that would be seriously cool though
13:56:43 <bolrod> since java has a fairly full set of gui tools
13:57:47 <toefus> bolrod, but we already have gtk2hs. and i don't know how the jvm can support laziness and haskell's features. maybe the .NET CLR ?
13:57:56 <apfelmus> bolrod: you'll need a functional abstraction on top of that, so it doesn't help that much
13:58:05 <bolrod> ofcourse
13:58:06 <SamB> um.
13:58:25 <SamB> C has a lot of GUI tools too, and doesn't use nearly as much memory!
13:58:26 <bolrod> we have gtk2hs.. but do we have tutorials for gtk2hs yet?
13:58:33 <bolrod> ;p
13:58:43 <bolrod> but it does require compilation on every other system
13:59:04 <bolrod> and I think in a few years we won't bother about the memory usage of java
13:59:22 <bolrod> I mean.... in 6 years we'll all have 8GB+ RAM ?
13:59:29 <bolrod> if not 16
13:59:43 <toefus> and 500 Ghz transistors ?
13:59:47 <bolrod> haha 8_
14:00:00 <bolrod> and 500 liters of liquid helium
14:00:07 <bolrod> 8)
14:00:31 <bolrod> nah... nanotubes on plastic?
14:00:44 <apfelmus> bolrod: we'll have a 512-core chip and not a single application to exploit this
14:00:57 <toefus> apfelmus, we'll have lot of erlang :-)
14:00:57 <bolrod> hahaha  ofcourse :P
14:01:02 <bolrod> though I guess microsoft will find a way
14:01:19 <bolrod> aero this, popup that
14:01:35 <bolrod> eventually you can't do without 512 core chips man
14:01:46 <dmhouse> Functional programming is the future. Worry about how to write your algorithm, not how quickly it runs. Let the advance of technology deal with the latter. :)
14:02:07 <SamB> dmhouse: but... who will worry about the advance of technology?
14:02:15 <bolrod> blah.. in a few years we won't be bothered about the speed of most application implementations I guess..
14:02:23 <bolrod> well... ofcourse a good algorithm
14:02:26 <dmhouse> SamB, Those hardware types. :)
14:02:38 <SamB> what about *compiler* technology?
14:02:40 <bolrod> but not squeeze every millisecond out of it by using a tiny change in the code
14:03:02 <bolrod> I mean.. we're already using memory like running water anyway
14:03:03 <toefus> do you know a good book on compilers using a functionnal language ? "Modern Compiler Implementation in ML" ?
14:03:14 <dmhouse> SamB, I'm not totally serious. But's in an interesting line of thought.
14:03:24 <apfelmus> dmhouse: the big O already abstracts technology :)
14:03:41 <Dino_> I'm going through _All About Monads_ and something is confusing me, pretty early on too. :/
14:03:44 * SamB calls up the memory company to ask why they shut off his memory
14:03:48 <dmhouse> Dino_: ask away.
14:04:13 <Dino_> They have this code, using the sheep example to talk about combinators.. mothersPaternalGrandfather s = (Just s) `comb` mother `comb` father `comb` father
14:04:14 * SamB suspects he did not pay his memory bill last month...
14:04:35 <apfelmus> SamB: because they want to keep it themselves?
14:04:43 <Dino_> Now, these functions mother and father, they take a Sheep. So how are they getting a value in the above code?
14:04:49 <bolrod> :)  well...  how long before we get 1MB of L1 cache and 512MB of L2 ;)
14:04:54 <dmhouse> Dino_: what's the type of comb?
14:05:02 <dmhouse> (It's just >>= for anyone following along at home.)
14:05:03 <Dino_> comb :: Maybe a -> (a -> Maybe b) -> Maybe b
14:05:34 <dmhouse> Dino_: right. So comb rips the sheep out of the Maybe Sheep, and gives it to its second parameter.
14:06:07 * SamB wonders why anyone would have a 512 core chip if no apps supported it
14:06:12 <Dino_> I have the URL to what I'm reading if that will help: http://www.nomaware.com/monads/html/meet.html  The section entitled "An Example"
14:06:25 <bolrod> SamB: it gives you a very big e-penis
14:06:32 <bolrod> ?
14:06:41 <SamB> no, it gives you lots of little e-penii
14:06:49 <dmhouse> Using the computations analogy, comb straps the output of one computation to the input of another: it takes the output of its first parameter, and gives it to its second.
14:06:57 <bolrod> :]
14:07:35 <Dino_> dmhouse: So it's going left-to-right in that mothersPaternal... code? Starting with the (Just s), stripping that and giving it to the mother call?
14:07:46 <dmhouse> Dino_: yep.
14:08:02 <hyrax42_> Dino_: and if any give Nothing, then it's Nothings all the way
14:08:04 <dmhouse> Dino_: but don't lose sight of the computation analogy.
14:08:08 <SamB> hmm, I better stop using this metaphor before I talk about how it would be silly to have 512 cores when only about 5 or 10 of them would be used, and most of those only intermitently
14:08:18 <bolrod> > Just 3 >>= print
14:08:19 <lambdabot>  Couldn't match `Maybe' against `IO'
14:08:24 <Dino_> I see, this is why we don't have to do 'comb _ Nothing = Nothing'
14:08:28 <bolrod> > Just 3 >>= show
14:08:29 <lambdabot>  Couldn't match `Maybe' against `[]'
14:08:31 <Dino_> Because it's going left to right.
14:08:58 <dmhouse> Dino_: as hyrax42_ says, if any of the mother, father etc return Nothing, it's Nothing all the way. This is because comb propogates failures (i.e. Nothings).
14:09:14 <dmhouse> Failure propogation is a key feature of the Maybe monad.
14:09:33 <SamB> in fact, it is just about the only feature
14:09:50 <Dino_> Is it wrong that this vaguely makes me think of exceptions?
14:09:56 <SamB> not a bit!
14:10:01 <hyrax42_> Dino_: not at all
14:10:09 <dmhouse> Nope :) Maybe is a More Elegant Way of doing exceptions, or just general failure.
14:10:12 <vincenz> HIHI
14:10:20 <hyrax42_> wait till you reach Either, which is closer
14:10:28 <SamB> it is very like exceptions... except that in this case there is only one kind
14:10:32 <vincenz> dmhouse: I disagree
14:10:33 <dmhouse> You know all those icky functions that say 'It returns FALSE (or null, or -1, or something) on failure'? In Haskell, you do that with Maybe.
14:10:38 <vincenz> dmhouse: to me, the ideal way of doing exceptions is
14:10:39 <Dino_> Ok, so what did you mean by 'don't lose sight of the computation analogy'?
14:10:49 <vincenz> instance (Read e) => (Monad e) where
14:10:52 <vincenz>   return = ...
14:10:59 <vincenz>  fail = Left $ read
14:11:00 <vincenz> erm
14:11:02 <vincenz> Left .read
14:11:12 <dmhouse> vincenz: you mean Monad (Either e)?
14:11:16 <vincenz> yeah
14:11:18 <vincenz> sorry
14:11:27 <vincenz> But I think the fact that fail requires a string is a limitation
14:11:35 <SamB> vincenz: you really mean "read"?
14:11:36 <Jonnyw2k> how hard is haskell to learn?
14:11:45 <Jonnyw2k> and can i use a windows maching to program in it
14:11:50 <Jonnyw2k> machine
14:11:50 <dmhouse> Jonnyw2k: if you're being taught by Imperial, not that hard. :)
14:11:52 <vincenz> SamB: how else will you get type e?
14:11:55 <Jonnyw2k> lol
14:11:56 <SamB> vincenz: don't you mean "show"?
14:12:00 <vincenz> SamB: no
14:12:01 <dmhouse> @type read
14:12:01 <hyrax42_> Jonnyw2k: varies, and yes
14:12:02 <lambdabot> forall a. (Read a) => String -> a
14:12:06 <Jonnyw2k> well im not going ot be at the imperial for another year
14:12:10 <vincenz> @type fail
14:12:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:12:15 <vincenz> it takes a string!
14:12:16 <Jonnyw2k> and i want to no the basics so i can outstand them at the interview
14:12:26 <dmhouse> Jonnyw2k: it's about as hard as learning to program again, some say.
14:12:37 <bolrod> it's easier 
14:12:39 <SamB> oh...
14:12:41 <dmhouse> So not impossible, and _very_ rewarding, but not the easiest language out there.
14:12:45 <SamB> vincenz: right.
14:13:01 <vincenz> dmhouse: everyone in our team has dissaperaed o.O
14:13:07 <bolrod> it's inversely hard as you are good at thinking of algorithms I guess
14:13:07 <dmhouse> vincenz: That is sucky. Polymorphism++.
14:13:08 <Dino_> dmhouse: Yeah, as a programmer of like 2 decades, it's been pretty severely difficult. But also very enlightening.
14:13:23 <vincenz> dmhouse: polymorhpsim
14:13:25 <Jonnyw2k> ahh so not as easy as newbie nlanguages like delphi n VB :P
14:13:25 <vincenz> ?
14:13:33 <vincenz> Jonnyw2k: right and wrong
14:13:41 <Jonnyw2k> :S
14:13:42 <vincenz> Jonnyw2k: the problem with languages like that is that features don't always combine nicely
14:13:45 <bolrod> it's inversely hard as you are good at thinking of algorithms I guess  <<  if you're good at thinking of neat algorithms..
14:13:49 <vincenz> so while the initial curve is less steep
14:13:51 <bolrod> I guess it is quite easy to understand
14:13:56 <vincenz> the intermediate and final curve are steeper
14:14:00 <bolrod> if you're not good at that.. you may have some more difficulties
14:14:01 <dmhouse> vincenz: It should be fail :: Aaargh a => a -> m b
14:14:05 <Jonnyw2k> ahh
14:14:05 <vincenz> dmhouse: I agree
14:14:15 <Jonnyw2k> im good with logic and understanding
14:14:15 <vincenz> dmhouse: fail :: Failure a => a -> m b
14:14:18 <Jonnyw2k> and syntax
14:14:20 <SamB> @instances MonadError
14:14:21 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:14:23 <dmhouse> vincenz: I want Aaargh :(
14:14:25 <vincenz> dmhouse: or possibly Monad should take two parameter
14:14:32 <vincenz> dmhouse: cause that fail is actualy faulty
14:14:34 <dmhouse> @instances-importing Control.Monad.Error MonadError
14:14:36 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:14:40 <vincenz> dmhouse: most likely the type of failure will be monad dependent
14:14:47 <apfelmus> SamB: to be serious, haskell would have no problem eating the 512 processor cores up. i imagine thousands of tiny tiny core beetles (i should not call them bugs) crawling around in memory and reducing a huge graph.
14:14:48 <vincenz> dmhouse: so more like Monad fail good where
14:14:49 <bolrod> you can write some pretty crazy stuff in a just a few lines with haskell...
14:14:54 <bolrod> so that could make it hard
14:15:09 <vincenz> Monad failure m | m -> failure where
14:15:27 <vincenz> s/^/class
14:15:41 <dmhouse> vincenz: Or even better,
14:15:42 <apfelmus> > fibonacci = 1:1:zipWith (+) (tail fibonacci) (tail (tail fibonacci))
14:15:42 <lambdabot>  Parse error
14:15:56 <bolrod> hehe
14:15:58 <SamB> apfelmus: well... it would require a certain eagerness
14:16:06 <dmhouse> class Monad m where return :: a -> m a; (>>) :: m a -> m b -> m b; (>>=) :: m a -> (a -> m b) -> m b;
14:16:26 <vincenz> dmhouse: and no failure?
14:16:26 <bolrod> > fib = 0 : 1 : [x | x <- zipWith (+) fib (tail fib)] in take 15 fib
14:16:27 <lambdabot>  Parse error
14:16:36 <bolrod> thatsnot right.. hrm..
14:16:36 <dmhouse> class Monad m => FailMonad failure m | m -> failure where fail :: failure -> m a
14:16:39 <SamB> and you'd need a really good compiler to figure out what to reduce
14:16:42 <vincenz> dmhouse: yeah
14:16:52 <apfelmus> > let fibonacci = 1:1:zipWith (+) (tail fibonacci) (tail (tail fibonacci)) in fibonacci
14:16:53 <lambdabot>  Exception: <<loop>>
14:16:57 <dmhouse> > fib = 0 : 1 : [ x | x <- zipWith (+) fib (tail fib) ] in take 15 fib
14:16:57 <lambdabot>  Parse error
14:17:07 <dmhouse> > let fib = 0 : 1 : [ x | x <- zipWith (+) fib (tail fib) ] in take 15 fib
14:17:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377]
14:17:09 <vincenz> dmhouse: but doesn't Monad then just become a monoid?
14:17:18 <bolrod> > let fib = 0 : 1 : [x | x <- zipWith (+) fib (tail fib) ] in take 15 fib
14:17:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377]
14:17:20 <bolrod> argh!
14:17:20 <apfelmus> > let fibonacci = 1:1:zipWith (+) fibonacci (tail fibonacci) in fibonacci
14:17:22 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:17:26 <bolrod> how could I be so stupid :}
14:17:33 <dmhouse> vincenz: Not really.
14:17:34 <Jonnyw2k> so wat does haskell have to do with gasgow
14:17:47 <SamB> @instances-importing Control.Monad.Error MonadError
14:17:48 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:17:52 <vincenz> Jonnyw2k: it's gascow, not gasgow
14:18:00 <bolrod> vincenz: I See
14:18:04 <dmhouse> vincenz: a monoid is a collection with an identity and a binary operation. A monad has neither of those. Moreover, they're different kinds.
14:18:04 <vincenz> :P
14:18:14 <bolrod> that makes all the difference
14:18:15 <vincenz> dmhouse: not true: return = identity
14:18:20 <vincenz> dmhouse: >>= is binary op
14:18:24 <vincenz> dmhouse: right associative
14:18:30 <vincenz> or left...
14:18:32 * vincenz ponders
14:18:37 <dmhouse> Still the kinds issue.
14:18:37 <vincenz> anyways >>= is binary op
14:18:39 <Dino_> Hey, thank you. Very helpful.
14:18:45 <dmhouse> And return doesn't have the right type for a binary operation.
14:18:55 <vincenz> dmhouse: return is the injenction
14:18:55 <bolrod> though I think it might be  Glasgow
14:18:59 <SamB> @instances-importing MonadError Control.Monad.Error
14:19:00 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:19:00 <dmhouse> vincenz: Of course, Monad m => Monoid (m a)
14:19:02 <bolrod> instead of Gasgow
14:19:07 <dmhouse> SamB: that's a bug.
14:19:15 <vincenz> dmhouse: not with your monad
14:19:16 <Jonnyw2k> glasgow
14:19:18 <Jonnyw2k> actually
14:19:18 <vincenz> dmhouse: mzero = fail
14:19:32 <hyrax42_> vincenz: it's Glasgo not gascow
14:19:36 <hyrax42_> oh
14:19:38 <Jonnyw2k> glasgow
14:19:38 <vincenz> hyrax42_: no, it's glasgow
14:19:44 <Jonnyw2k> :P
14:19:49 <dmhouse> @version
14:19:49 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
14:19:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:19:50 <bolrod> yes I said that about some lines ago! 
14:19:51 <hyrax42_> ack
14:19:53 <bolrod> see
14:19:54 <hyrax42_> !
14:19:55 <bolrod> GHC
14:19:55 <Jonnyw2k> i wa more correct than u were fist time
14:19:58 <bolrod> Glasgow haskell compiler
14:19:59 <Jonnyw2k> i only missed a letter
14:20:00 <vincenz> Jonnyw2k: and I was joking
14:20:08 <Jonnyw2k> :P
14:20:10 <vincenz> and please, no fist time
14:20:10 <hyrax42_> vincenz: I had it right but erased to capitalise
14:20:12 * vincenz shudders
14:20:13 <dmhouse> vincenz: Right, so it'd be FailMonad m => Monoid (m a)
14:20:19 <Jonnyw2k> dorry this keyboard is dodgy
14:20:22 <Jonnyw2k> sorry
14:20:23 <bolrod> :P
14:20:29 <vincenz> dmhouse: heard anything of our teammembers?
14:20:34 <bolrod> foist time
14:20:40 <vincenz> bolrod: foist toime
14:20:45 <dmhouse> vincenz: Not really
14:20:49 <Jonnyw2k> does anyone here go to the imperial college?
14:20:51 <vincenz> dmhouse: it seems like bitrot
14:20:56 <bolrod> Move along! Nothing to see here!
14:21:09 <vincenz> bolrod: I used to play a char on a mud that talked like that
14:21:22 <bolrod> :)
14:21:25 <Jonnyw2k> i wanna learn AI scripting lol
14:21:35 <vincenz> Jonnyw2k: define "AI scripting"
14:21:35 <bolrod> scripting even
14:21:39 <vincenz> Jonnyw2k: to me that seems two orthogonal terms
14:21:40 <vincenz> "AI
14:21:42 <vincenz>  and scripting
14:21:45 <Jonnyw2k> :P
14:21:59 <Jonnyw2k> well AI = Artificial inteligence
14:22:08 <vincenz> I figured as much
14:22:11 <Jonnyw2k> scripting = prigmraming snippets than can be reused ;p
14:22:21 <Jonnyw2k> i cal it scripting
14:22:25 <vincenz> Jonnyw2k: no it's not, that's called modular desgn
14:22:26 <Jonnyw2k> dunno why
14:22:28 <vincenz> s/desgn/design
14:22:34 <bolrod> what's with the keyboards yo!   use them correctly!
14:22:51 <vincenz> bolrod: for some stupid reason, the new ubuntu seriously lags on gui, so my keyb is lagged
14:23:00 <Jonnyw2k> Ok bolrod will do.
14:23:10 <bolrod> weird.. I have no problem
14:23:16 <vincenz> bolrod: ATI card
14:23:17 <bolrod> you sure Xorg isn't using 1GB of memory?
14:23:19 <vincenz> bolrod: I can't get direct rendering
14:23:22 <bolrod> hahaha :D
14:23:32 <vincenz> that was helpful
14:23:37 <bolrod> np
14:23:53 <Jonnyw2k> unless your using the new Xorg (forgetten what its called off the top of my head)
14:23:54 <dmhouse> vincenz: mempty = return () works too
14:24:03 <Jonnyw2k> the new 3d one that uses gpu instead of cpu :P
14:24:05 <bolrod> Xgl is cool.... (ok.. that doesn't help either I guess)
14:24:05 <vincenz> dmhouse: that's a big assumption
14:24:15 <Jonnyw2k> Xgl thats the one
14:24:17 <dmhouse> vincenz: And mappend = (>>)
14:24:18 <Dino_> Wow, this is really cool now that I see it working.
14:24:23 <vincenz> dmhouse: for that matter I could say that mempty = return (+1)
14:24:38 <bolrod> I have used it.. but it has alot of bugs
14:24:48 <Jonnyw2k> i want to make a sudoko solver
14:24:56 <bolrod> go ahead.
14:25:06 <hyrax42_> Dino_: if you have time, work through the first half of the scheme interpreter in 48 hours thing
14:25:07 <Jonnyw2k> yeh i need to choose the language first
14:25:16 <bolrod> javascript!
14:25:23 <dmhouse> vincenz: With what (>>)?
14:25:25 <Jonnyw2k> and be able to solve suduko problems myself before i can make a program that solves them
14:25:28 <dmhouse> vincenz: Err, mappend
14:25:46 <Dino_> hyrax42_: Where is that, it isn't part of the document I'm reading, is it? (All About Monads)
14:25:50 <hyrax42_> when you add the ThrowsError stuff in it almost seemed fake how cool it was
14:25:52 <dmhouse> Hmm, actually, return () isn't a right-identity for (>>)..
14:26:06 <hyrax42_> it's not
14:26:09 <hyrax42_> hang on
14:26:21 <Dino_> hyrax42_: I kinda do have time. I'm 'between jobs' as they say.
14:27:02 <hyrax42_> well it starts off really nice and simple, and works up from there
14:27:02 <Dino_> I also have that Haskell School of Expression book on the way.
14:27:09 <hyrax42_> experiment with things a bit in it
14:27:13 <hyrax42_> (link forthcoming)
14:27:21 <bolrod> fortunately everybody has time..
14:27:45 <hyrax42_> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
14:28:00 <Dino_> Luckily I'm in a position to say 'piss off' to every Java web development job that comes along. :o
14:28:27 <bolrod> :]
14:28:43 <Dino_> hyrax42_: Awesome, thank you.
14:29:19 <hyrax42_> :)
14:29:28 <hyrax42_> I never got all the way through though
14:29:39 <hyrax42_> but parsec is very cool
14:29:47 <hyrax42_> at least the glimpse you get in that tutorial
14:29:48 <vincenz> dmhouse: tomorrow I pack my last room
14:30:11 <dmhouse> vincenz: Hehe good luck :)
14:30:17 <dmhouse> vincenz: When are you moving, then?
14:30:20 <vincenz> sunday
14:30:47 <vincenz> monday I'm getting my new internet connection
14:30:51 <dmhouse> Cool.
14:31:13 <hyrax42_> vincenz: priorities :p
14:31:25 <dmhouse> Hey xerox_.
14:31:28 <vincenz> hyrax42_: I'm trying to ensure everything will be done wthin a week
14:31:55 <hyrax42_> except that "last box"
14:32:20 <dmhouse> So noone's written a ByteSting regex library yet?
14:32:21 <bolrod> http://www.macfixit.com/article.php?story=20060622103345459    .. hrm... at least it doesn't explode in your face like the Dell did
14:32:50 <ndm> dmhouse: i am expecting Happy/Alex libraries updated with bytestring at some point
14:33:05 <ndm> My Alex competitor will definately have that feature :)
14:33:45 <dmhouse> But, <3 regexes.
14:33:52 <Lemmih> ndm: How's FilePath coming along?
14:34:13 <ndm> Lemmih: slowly, i haven't had much time to work on it lately, but it is progressing
14:34:14 * dmhouse goes to test Hoogle
14:34:30 <ndm> its amazing how many special cases there are with a filesystem!!!
14:35:04 <dmhouse> @where hoogle
14:35:04 <lambdabot> http://www.haskell.org/hoogle
14:35:41 <ndm> darcs get http://www.cs.york.ac.uk/fp/darcs/hoogle
14:35:59 <ndm> maybe there should be both a @where and an @darcs
14:36:15 <vincenz> hi ndm
14:36:22 <ndm> hi vincenz 
14:36:33 <vincenz> hola Lemmih 
14:37:02 <Lemmih> Hola and goodbye. I'm on my way out.
14:41:18 <Dino_> So, what does the word 'combinator' mean exactly? What I'm reading just casually says it like I know what one is in a general sense.
14:41:18 <dmhouse> ndm: new Hoogle stuff works perfectly.
14:41:27 <ndm> dmhouse: woot :)
14:41:40 <ndm> there is no way for a haskell program to figure out its path, so had to hack it a bit
14:41:45 <dmhouse> Dino_: it has a technical meaning and a more general meaning.
14:42:02 <ndm> Dino_: in haskell, generally means people tend to use operators instead of function names :)
14:42:25 <dmhouse> It's technical meaning is an expression with no free variables. I.e., it can be written solely in terms of its arguments and function application, no other functions or variables or whatnot.
14:42:27 <Dino_> ndm: By that do you mean sticking thing infix?
14:42:27 <kosmikus> dons: ping
14:42:40 <ndm> but the principle is you use it to combine things to produce a program, you can generally ignore the word
14:42:43 <shapr> @timein london
14:42:44 <ndm> Dino_: tends to, yes
14:42:49 * shapr pokes lambdabot 
14:42:56 <ndm> 10:45pm
14:42:58 * SyntaxNinja pokes shapr
14:43:02 <shapr> ndm: Thanks :-)
14:43:05 * shapr hugs SyntaxNinja 
14:43:10 <ndm> easy enough to look at the clock :)
14:43:16 * vincenz waves SyntaxNinja 
14:43:38 <dmhouse> Normally, you use 'combinator' to mean 'function to combine other functions together'. For example, Parsec is a combinator library, because it contains, say, functions like 'many' that you combine with other functions to make bigger and better parsers.
14:44:00 <Dino_> Is >>= also a combinator?
14:44:05 <dmhouse> Sure.
14:44:45 <dmhouse> ndm: You updating the HaskellWiki, or shall I do it?
14:45:15 <ndm> dmhouse: don't mind, if you don't i will
14:45:25 <dmhouse> I'll get to it then. :)
14:45:26 <ndm> but i guess you have the 100% accurate info on it
14:45:50 <ndm> I have removed it from the list of bugs
14:45:52 * SyntaxNinja waves
14:45:59 <SyntaxNinja> xerox_ xerox__ alive?
14:46:23 <Dino_> dmhouse, ndm: Ok, thank you.
14:46:25 <SyntaxNinja> galois might have room for another internship this summer (short notice!) email me if you're a haskell hacker & interested.
14:46:27 <bolrod> I guess he's alive already
14:46:48 <ndm> SyntaxNinja: galois stole the york summer of code person!
14:46:57 <dmhouse> SyntaxNinja: Don't be stealing more SoC people!
14:47:06 <ndm> in the nicest possible way, of course
14:47:21 <ndm> (just jealous he gets two haskell job offers, when i was an undergrad i got to churn C++ all summer)
14:47:28 <bolrod> like killing someone in the nicest possible way, nicest possible way?
14:47:56 <SyntaxNinja> ndm: I'm exclusively looking at SoC ppl ;)
14:48:13 <SyntaxNinja> ndm: for the record, that dude I "stole" I offered him a _part time_ gig so he could do both!
14:48:13 <ndm> SyntaxNinja: as long as it isn't the new Yhc one, I don't care :)
14:48:16 <Jonnyw2k> i saw bruce willis earlier
14:48:29 <SyntaxNinja> ndm: what are you doign this summer? ;)
14:48:33 <ndm> SyntaxNinja: yes, i heard, that was *very* nice
14:48:40 <ndm> SyntaxNinja: PhD, and forever more :)
14:48:52 <ndm> although my supervisor is in Galois, Colin Runciman :)
14:49:05 <Jonnyw2k> galios weres that based?
14:49:29 <SyntaxNinja> ndm: he drinks a lot of tea ;)
14:49:39 <SyntaxNinja> Jonnyw2k: portland, oregon, USA
14:49:43 <ndm> SyntaxNinja: not by English standards, thats just normal
14:49:44 <Jonnyw2k> :(
14:49:55 <Jonnyw2k> i wanna do it but i live in england
14:49:57 <dmhouse> SyntaxNinja: How much is 'a lot'?
14:50:11 <SyntaxNinja> dmhouse: oh, idono
14:50:41 <dmhouse> I mean, I know some people with some pretty mean coffee drinking habits.
14:50:47 <ndm> coffee is a lot more common
14:50:57 <ndm> i know people who take at least a strong cup an hour
14:51:15 <dmhouse> Hm. That's really not healthy.
14:51:16 <ndm> one guy in our department has run up a coffee bill of > ¬£100, and its about 10p per cup
14:51:35 <ndm> he is _very_ bouncey and lively
14:51:38 <SyntaxNinja> ndm: is that per year?
14:51:49 <SyntaxNinja> I wonder at what point it just becomes more healthy to take speed ;)
14:51:53 <ndm> SyntaxNinja: less than a year, maybe two terms
14:52:07 <vincenz> after a while the return on investment of coffee decreases
14:52:08 <vincenz> I know this
14:52:08 <ndm> everyone else has a single line of coins, he has a page
14:52:24 <bolrod> haha :]
14:52:45 <bolrod> coffee is bad yes
14:52:51 <dmhouse> What's that word I'm looking for?
14:53:00 <dmhouse> Oh yeah, control structures. Cheers.
14:53:00 <bolrod> I don't know
14:53:07 * vincenz recently switched to tea, although I still drink some coffee, but I foudn that on long days I'd drink so much coffee that I'd feel my stomach burning
14:53:33 <bolrod> I drink so little cafeine
14:53:39 <dmhouse> Try fruity tea.
14:53:45 <bolrod> that when I drink some,  I can stay awake a whole night with ease
14:54:01 <dmhouse> A.k.a. the most disappointing drink ever. It smells lovely, but tastes like hot water.
14:54:17 <bolrod> hehe :)
14:55:05 <dmhouse> Ooh last House of the season next week.
14:55:15 <ndm> dmhouse: and he gets shot!
14:55:25 <dmhouse> So I saw! Don't tell me the ending.
14:55:41 <ndm> I don't know it, only just saw him get shot at the end of this weeks episode
14:56:17 <dmhouse> Oh, right. I forgot you were british too.
14:56:45 <ndm> indeed, going to go watch sugar rush in 10 mins - i recommend it (or the first series, haven't seen any of this series yet)
14:56:58 <dmhouse> Hehe, I'll leave you to it. :)
14:57:05 <dmhouse> It's a bit late for a school night.
14:57:17 <bringert> @pl foldr (ap . ap (return (:)) . g) (return [])
14:57:17 <lambdabot> foldr (liftM2 (:) . g) (return [])
14:57:56 <ndm> I'll be lucky if i get in for 11am, the advantages of having no one supervising you :)
14:58:05 <bringert> @pl \r a -> foldr (a . a (r (:)) . g) (r [])
14:58:06 <lambdabot> ap (flip . (foldr .) . ap (.) . flip flip g . ((.) .) . flip id . ($ (:))) ($ [])
14:58:07 <dmhouse> Haha :)
14:58:23 <bringert> lambdabot: how is that better?
14:58:41 <ndm> bringert: 2 fewer points :)
14:59:27 <ndm> although i am curious, flip id and flip flip both look a bit dubious - not that i can read or understand that of course
14:59:34 <bolrod> @pl ap (flip . (foldr .) . ap (.) . flip flip g . ((.) .) . flip id . ($ (:))) ($ [])
14:59:34 <lambdabot> ap (flip . (foldr .) . ap (.) . flip flip g . ((.) .) . flip id . ($ (:))) ($ [])
14:59:49 <ihope> @type flip flip
14:59:50 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
14:59:53 <bringert> (this function is mapM by the way)
15:00:05 <bringert> but taking return and ap as arguments
15:00:07 <ihope> @type flip flip flip
15:00:08 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
15:00:14 <ihope> :-
15:00:16 <ihope> )
15:00:37 <bringert> @type flip id
15:00:39 <lambdabot> forall b c. b -> (b -> c) -> c
15:00:48 <bolrod> @type flip id id 
15:00:49 <lambdabot> forall c a. ((a -> a) -> c) -> c
15:00:55 <bringert> @type flip ($)
15:00:56 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
15:01:15 <bringert> hmm, so flip ($) = flip id, makes sense
15:01:36 <dmhouse> ($) = id, up to fixity and the limitation of ($)'s type.
15:01:53 <bolrod> flip `flip` flip
15:01:57 <bolrod> @type flip `flip` flip
15:01:59 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
15:02:01 <bringert> @pl \g -> foldr (ap . ap (return (:)) . g) (return [])
15:02:01 <lambdabot> flip foldr (return []) . (liftM2 (:) .)
15:02:32 <dmhouse> Night all.
15:02:39 <bolrod> night
15:02:44 <bolrod> >>:/
15:03:00 <ihope> @type flip flip `flip` flip flip
15:03:01 <lambdabot> forall a a1 c. (a1 -> a -> c) -> a -> a1 -> c
15:03:06 <ihope> ...
15:03:12 * ihope is disappointed
15:03:52 <bolrod> @type flip flip `flip` flip flip $ (\a b c -> id)
15:03:53 <lambdabot> forall a a1 t a2. a -> a1 -> t -> a2 -> a2
15:04:03 <bolrod> @type flip flip `flip` flip flip $ (\a b c -> id) 1 2
15:04:05 <lambdabot> forall a a1. a -> a1 -> a
15:04:11 <bolrod> @type flip flip `flip` flip flip $ (\a b c -> id) 1 2 4 5
15:04:12 <lambdabot> forall a a1 c. (Num (a1 -> a -> c)) => a -> a1 -> c
15:04:17 <bolrod> hrm?
15:04:23 <ihope> @type (\x y -> x y y) (\x y -> x y y)
15:04:25 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
15:04:25 <lambdabot>    Expected type: t
15:04:33 <ihope> Aww.
15:04:53 <bolrod> @type flip flip `flip` flip flip $ (\a b c -> id) 1 2  4 (+)
15:04:54 <lambdabot> forall a. (Num a) => a -> a -> a
15:04:59 <bolrod> @type flip flip `flip` flip flip $ (\a b c -> id) 1 2  4 (+) 4 5 
15:05:01 <lambdabot> forall a a1 c. (Num (a1 -> a -> c)) => a -> a1 -> c
15:05:08 <bolrod> @type flip flip `flip` flip flip $ (\a b c -> id) 1 2  4 (+) 4 
15:05:10 <lambdabot> forall a c. (Num (a -> c)) => a -> (a -> c) -> c
15:05:19 <bolrod> ok.. I wouldn't understand this anyway
15:05:32 <ihope> @type (\x y -> y x) (\x y -> y x)
15:05:34 <lambdabot> forall t t1 t2. ((t2 -> (t2 -> t1) -> t1) -> t) -> t
15:05:39 <ihope> @type (\x y -> y x) (\x y -> y x) (\x y -> y x)
15:05:40 <lambdabot> forall t t1 t2. ((t1 -> (t1 -> t) -> t) -> t2) -> t2
15:05:43 <bolrod> @type flip flip `flip` flip flip $ (\a b c -> id) 1 2  4 (+) $ (+1)
15:05:45 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a
15:05:53 <ihope> Num (a -> a), eh?
15:06:04 <bolrod> flip flapedie fl00p
15:06:21 <ihope> @type (\a b c d e f g h -> a e c g b f d h)
15:06:22 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. (t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7) -> t3 -> t1 -> t5 -> t -> t4 -> t2 -> t6 -> t7
15:06:31 <ihope> @type let x = (\a b c d e f g h -> a e c g b f d h) in x x
15:06:32 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. t5 -> t3 -> t4 -> (t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7) -> t -> t1 -> t2 -> t6 -> t7
15:06:53 <bolrod> @type (,)
15:06:54 <jer> head... spinning...
15:06:54 <vincenz> spam
15:06:55 <lambdabot> forall b a. a -> b -> (a, b)
15:07:06 <bolrod> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:07:08 <lambdabot> forall t284 t283 t282 t281 t280 t279 t278 t277 t276 t275 t274 t273 t272 t271 t270 t269 t268 t267 t266 t265 t264 t263 t262 t261 t260 t259 t258 t257 t256 t255 t254 t253 t252 t251 t250 t249 t248 t247
15:07:09 <lambdabot> t246 t245 t244 t243 t242 t241 t240 t239 t238 t237 t236 t235 t234 t233 t232 t231 t230 t229 t228 t227 t226 t225 t224 t223 t222 t221 t220 t219 t218 t217 t216 t215 t214 t213 t212 t211 t210 t209 t208
15:07:09 <lambdabot> t207 t206 t205 t204 t203 t202 t201 t200 t199 t198 t197 t196 t195 t194 t193 t192 t191 t190 t189 t188 t187 t186 t185 t184 t183 t182 t181 t180 t179 t178 t177 t176 t175 t174 t173 t172 t171 t170 t169
15:07:09 <lambdabot> t168 t167 t166 t165 t164 t163 t162 t161 t160 t159 t158 t157 t156 t155 t154 t153 t152 t151 t150 t149 t148 t147 t146 t145 t144 t143 t142 t141 t140 t139 t138 t137 t136 t135 t134 t133 t132 t131 t130
15:07:11 <lambdabot> t129 t128 t127 t126 t125 t124 t123 t122 t121 t120 t119 t118 t117 t116 t115 t114 t113 t112 t111 t110 t109 t108 t107 t106 t105 t104 t103 t102 t101 t100 t99 t98 t97 t96 t95 t94 t93 t92 t91 t90 t89 t88
15:07:13 <bolrod> holy crap!
15:07:13 <vincenz> bolrod: stop spamming, please
15:07:14 <lambdabot> [20 @more lines]
15:07:14 <ihope> Ack!
15:07:15 <bolrod> sorry
15:07:19 <vincenz> bolrod: use /msg lambdabot 
15:07:22 <bolrod> I thought it'd break!
15:07:33 <bolrod> I didn't know it defined a tuple that big!
15:07:37 <vincenz> even then, try to use private message
15:07:49 <jer> bolrod, why wouldn't it?
15:08:14 <bolrod> because in the 6.4 ghc every tuple 'til some n-tuble is defined
15:08:20 <bolrod> above that it gives an error
15:08:38 <bolrod> well
15:09:03 <bolrod> guess not then..
15:10:52 <bolrod> or is that the show.. hrm
15:11:15 <bolrod>     A 65-tuple is too large for GHC
15:11:16 <bolrod>       (max size is 62)
15:12:32 <vincenz> lol
15:12:34 <vincenz> make it bigger and you get a parse error
15:14:51 <defcon8> bolrod: does haskell programming come naturally after a while?
15:14:54 <defcon8> do you really have to think?
15:17:11 <vincenz> maximum number of , between () beffore parse error is 437
15:19:19 <bolrod> hehe :)
15:19:28 <bolrod> defcon8: that probably depends on yourself
15:19:47 <defcon8> what about you?
15:20:01 <bolrod> I don't program that much
15:20:07 <bolrod> but I like haskell for some things :)
15:20:13 <defcon8> what like?
15:21:08 <bolrod> well..  it just looks cool :}
15:21:28 <bolrod> like how you can define the fibonacci sequence
15:21:31 <RyanT5000> i find that the thinking required to program something in haskell is only slightly higher than the thinking required to fully understand the problem you're solving
15:21:44 <hyrax42_> @where yaht
15:21:45 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
15:22:27 <defcon8> bolrod: how do _you_ do it?
15:22:32 <bolrod> do what??
15:22:42 <bolrod> I mean... what do you want to program in haskell
15:22:42 <defcon8> fibonacci sequence
15:23:04 <bolrod> well.. I like the one I read in a tutorial
15:23:07 <bolrod> this one:
15:23:28 <bolrod> > let fib = 0:1:[x | x<- zipWith (+) fib (tail fib)] in take 15 fib
15:23:29 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377]
15:23:51 <defcon8> that's way too complicated
15:23:55 <bolrod> it's not
15:24:14 <bringert> defcon8: start with a simple recursive one, just like in a math book
15:24:33 <bolrod> look..  first  you have  fib = 0:1:...
15:24:48 <defcon8> yes, i have found another simple version
15:24:52 <bolrod> then you take that  plus the tail of that  (which is 1:...
15:25:02 <bolrod> and then you zip them together
15:25:03 <madpickle> factorial is a good one
15:25:13 <defcon8> yeah
15:25:20 <bolrod> so you get :
15:25:22 <defcon8> fac x = x * fac(x-1)
15:25:24 <madpickle> my old prof on haskell used to have his notes online
15:25:27 <bolrod> [0,1,..
15:25:28 <madpickle> they were really good
15:25:29 <bolrod> [1,..
15:26:50 <bolrod> well..   anyway :P  it may be a bit hard to visualize
15:27:08 <bolrod> you could define a recursive function as well
15:27:11 <bolrod> but it won't output a list
15:27:27 <defcon8> isn't what i gave, recursive?
15:28:04 <madpickle> thing is: if you can't think of anything to do, why learn to program?
15:28:06 <madpickle> [in haskell]
15:28:11 <madpickle> my reason for learning?
15:28:19 <madpickle> either i learned it, or i'd get my ass whooped by my prof.
15:28:21 <defcon8> mine is that i want to be ready before i get to uni
15:28:22 <RyanT5000> defcon8: yeah, what you said was recursive
15:28:24 <madpickle> now THERE is a motive
15:28:40 <defcon8> i want to be the guy that pisses everyone off by saying "i know" and putting my hand up
15:28:52 <madpickle> you can do that without knowing it in advance
15:28:56 <bolrod> > let fib n | n == 0 = 0  | n == 1 = 1 | otherwise = fib(n-1) + fib(n-2)  in fib 5
15:28:57 <lambdabot>  5
15:29:02 <bolrod> > let fib n | n == 0 = 0  | n == 1 = 1 | otherwise = fib(n-1) + fib(n-2)  in fib 6
15:29:02 <defcon8> anyway. it is fun
15:29:02 <madpickle> suffice to say, it requires that you grasp general concepts of programming
15:29:03 <lambdabot>  8
15:29:13 <defcon8> i have a project atm. i want to write a simple cellular automata programme
15:29:22 <defcon8> yes. i am reading the htdp atm
15:29:30 <madpickle> buy a book
15:29:53 <madpickle> i'd recommend theo ne i have, but the author felt it necessary to use LaTeX symbols to represent the variety-pack haskell uses
15:30:00 <madpickle> making it hard to discern what the ASCII representation is
15:30:33 <defcon8> madpickle: what is that?
15:30:46 <defcon8> the book
15:30:57 <defcon8> isn't htdp good to get the concepts of what programming is?
15:31:07 <madpickle> i can't see the book from where i'm sitting
15:31:08 <bolrod> anyway.. Functional programming is just a small part of uni I guess
15:31:13 <madpickle> now i'm pondering whether i should get up or not
15:31:15 <madpickle> yeah, it is
15:31:21 <madpickle> we did fun stuff like draw fractals
15:31:26 <madpickle> and.. make christmas trees
15:31:31 <madpickle> (don't ask)
15:31:33 <bolrod> haha
15:31:38 <madpickle> prolog though
15:31:39 <defcon8> madpickle: please do
15:31:40 <bolrod> we made the mandelbrot in java
15:31:41 <madpickle> now there's a fun language =)
15:31:41 <defcon8> it may change my life
15:31:47 <madpickle> we did the von koch
15:31:52 <madpickle> no offense, but haskell won't change your life
15:32:05 <defcon8> on the view of learning new concepts of programming
15:32:08 <madpickle> memorizing the 3 rules that's used in lambda reductions and all those combinator ones
15:32:12 <madpickle> THAT will RUIN your life
15:32:21 <madpickle> fun trivia:
15:32:41 <madpickle> brb, phone
15:32:47 <bolrod> woah
15:32:53 <bolrod> what fun
15:33:00 <madpickle> sec
15:33:06 <madpickle> <- phone
15:33:29 <defcon8> TYPE ERROR
15:33:39 <defcon8> madpickle is not device type
15:34:11 <bolrod> @type madpickle 
15:34:12 <lambdabot> Not in scope: `madpickle'
15:34:18 <bolrod> bummer
15:34:27 <madpickle> ok
15:34:28 <madpickle> here we go
15:34:32 <madpickle> http://www-maths.swan.ac.uk/people.html
15:34:34 <bolrod> oh goodie!
15:34:36 <madpickle> http://www-maths.swan.ac.uk/staff/jrh/
15:34:38 <madpickle> see that guy
15:34:41 <madpickle> (no pic on his actual site)
15:34:42 <madpickle> Hindley
15:34:47 <defcon8> which is the book?
15:34:57 <madpickle> which is the guy who taught me math in my first year
15:34:58 <madpickle> ;)
15:35:03 <defcon8> scary shit
15:35:13 <madpickle> now, that is a fun piece of trivia
15:35:32 <madpickle> because i'm sure some of the more functionally-inclined people in here know of him
15:35:52 <madpickle> http://en.wikipedia.org/wiki/Hindley-Milner_type_inference
15:35:55 <bolrod> ;o
15:36:01 <defcon8> madpickle: can you find the book?
15:36:03 <madpickle> he was a nut job tho
15:36:09 <madpickle> i mean woooah nutjob style
15:36:14 <madpickle> he kept making analogies to the french
15:36:16 <madpickle> and how much they sucked
15:36:32 <madpickle> best yet
15:36:33 <defcon8> is he a del boy wannabe?
15:36:48 <madpickle> we called him Dr. Shipman because he looked like this physician who killed a whole bunch of people
15:36:52 <madpickle> nice guy though.
15:38:49 <bolrod> haha
15:39:15 <defcon8> madpickle: the book/
15:39:18 <madpickle> what book?
15:39:34 <bolrod> book!
15:39:36 <defcon8> that you were going to find
15:39:42 <madpickle> oh yeah
15:39:49 <bolrod> find?  I have 2 right in front of me!
15:39:49 <madpickle> i was still debating if i could be arsed
15:39:52 <madpickle> but since you ask so nicely...
15:40:09 <defcon8> defcon8	madpickle: please do
15:40:14 <madpickle> Introduction to Functional Programming using Haskell, S.E., Richard Bird, 1998
15:40:14 <bolrod> defcon8: can you read dutch?
15:40:22 <defcon8> bolrod: no but my cousin does
15:40:28 <defcon8> thanks, madpickle
15:40:31 <bolrod> how does that help you :/
15:40:33 <madpickle> it's "ok"
15:41:16 <defcon8> bolrod: he is my slave and will translate it for me
15:41:22 <defcon8> duuh!
15:42:10 <madpickle> http://www.tvsquad.com/2006/06/22/new-episodes-of-futurama-coming-to-comedy-central-for-real/
15:42:11 <madpickle> woaah baby
15:43:04 <defcon8> 83 dollars :D
15:43:22 <madpickle> 83 dollars hwat?
15:43:43 <defcon8> the book
15:43:56 <waern_> what's the best way to get a darcs patch that is the diff between two repositories?
15:43:56 <madpickle> that's more than what i paid
15:44:13 <defcon8> i may try ebay
15:44:21 <madpickle> aye
15:44:24 <defcon8> i'd rather get some books on calculus first though
15:44:30 <defcon8> or linear algebra
15:44:31 <madpickle> i paid about 36.99 (that's pounds sterling)
15:44:47 <defcon8> 68 usd
15:45:09 <madpickle> i'd focus more on grasping general concepts like recursion and common data structures
15:45:14 <madpickle> (assuming you don't know em already)
15:45:47 <defcon8> oh i know python and java i guess but not what you mean
15:45:50 <defcon8> functional
15:46:02 <bolrod> or this
15:46:03 <bolrod> http://www.duellikerealmen.com/diaper.jpg
15:46:07 <defcon8> i think i need to get a bit of maths in before i start understand more of the logic of programming
15:46:12 <vincenz> madpickle: for what
15:46:13 <madpickle> LMAO
15:46:14 <madpickle> hahahaha
15:46:19 <defcon8> lol
15:46:27 <madpickle> vincenz: for what? recursion is nice to know when you do haskell; data structures too
15:46:39 <vincenz> madpickle: "I paid about 36.99"
15:46:42 <madpickle> a book
15:46:47 <vincenz> I igured as much
15:46:50 <vincenz> which book?
15:46:50 <madpickle> [22 11:39:52 pm] <madpickle> Introduction to Functional Programming using Haskell, S.E., Richard Bird, 1998
15:46:54 <vincenz> ah
15:46:56 <madpickle> i was getting to that =)
15:50:37 <vincenz> Ah that one
15:50:38 <ihope> Palindromic Haskell program: main=main;niam=niam
15:50:50 <defcon8> :)
15:52:01 <bolrod> someone have some good palindromic music?
15:52:03 <jrmole> that's pretty short for a non-halting palindrome ;)
15:52:20 <jrmole> but not as short as brainfuck: +[]+
15:52:53 <stepcut> bolrod: I have heard good music and palindromic music, but I am not sure about goo, palindromic music :)
15:59:25 <bolrod> hrmm
16:04:44 <RyanT5000> you know what would be nice is to be able to set a "deterministic garbage-collection mode" on certain objects
16:09:32 <RyanT5000> there are some times i'd like things to get deleted as fast as possible
16:12:13 <Excedrin> why
16:15:38 <bolrod> implement your own
16:17:14 <ihope> > sqrt (-1)
16:17:16 <lambdabot>  NaN
16:18:07 <RyanT5000> Excedrin: because i want to use finalizers that matter
16:18:22 <RyanT5000> bolrod: i hope you don't mean anything inside the RTS
16:28:55 <shapr> RyanT5000: Non-stop Haskell
16:29:03 <shapr> @google non-stop haskell garbage collection
16:29:09 <lambdabot> http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=351265
16:29:09 <lambdabot> Title: "Non-stop Haskell"
16:29:57 <vincenz> shapr: incremental?
16:30:14 <stepcut> vincenz: I think so
16:30:20 * stepcut tries to remember 
16:30:44 <RyanT5000> cool, although i think i'll just stick to explicit allocation/deallocation
16:31:06 <RyanT5000> i basically have a tree, and in each frame part of that tree changes (or not)
16:31:11 <RyanT5000> and i need to cache things along the tree
16:31:32 <stepcut> "We describe an efficient technique for incorporating Baker's incremental garbage collection algorithm..."
16:32:50 * vincenz nods
16:39:26 <defcon8> what is the point of making people register, just to view documentation? it pisses me off.
16:40:09 <syntaxfree> Apple makes people register, to download nmap binaries.
16:40:49 <defcon8> haha
16:41:24 <syntaxfree> I should make a website and require registration, or something.
16:41:32 <ndm> bugmenot.com
16:41:37 <ndm> the solution to all login things
16:42:08 <syntaxfree> I wonder if bugmenot will require login soon.
16:42:16 <defcon8> "you are required to register to view index.html"
16:42:48 <defcon8> i wonder if bugmenot has pr0n sites :D
16:43:08 <RyanT5000> bugmenot doesn't have any pay sites
16:43:08 <syntaxfree> pr0n is an amazing waste of time.
16:43:36 <defcon8> not when you don't have to search, i guess
16:45:08 <syntaxfree> I'm so bored, I'm almost moving  my web stuff to that Haskell blog.
16:46:05 <defcon8> i have a blog. but it is totally random. normally ramblings about things that piss me off that i see on the news
16:47:02 <syntaxfree> I have a blog. It's about 1/5th bad mathematics. Some bad Haskell too.
16:47:12 <defcon8> link please
16:47:19 <syntaxfree> it's in portuguese.
16:47:24 <syntaxfree> there's some pictures, I guess.
16:47:27 <defcon8> yeah
16:47:30 <defcon8> and haskell and maths
16:47:31 <syntaxfree> www.navarro.mus.br/dieog/blog
16:47:40 <syntaxfree> oops.
16:47:47 <syntaxfree> make that www.navarro.mus.br/diego/blog
16:47:47 <defcon8> ?
16:48:25 <defcon8> i give up
16:48:48 <Excedrin> i have a blog, it's about soup
16:49:04 <defcon8> cool
16:49:05 <jer> soup?
16:49:13 <defcon8> syntactical!
16:49:14 <jer> tomato or chicken-noodle?
16:49:38 <defcon8> i rather minestrone
16:50:09 <Excedrin> typically I make an entry on days that I eat soup
16:50:13 <Excedrin> that's all really
16:50:18 <defcon8> or this strange chinese soup with cut noodles that i can't remember the name of
16:51:25 <syntaxfree> I'm also 24.
16:51:29 <syntaxfree> way too old to run a weblog.
16:51:41 <defcon8> wow
16:51:48 * jer is 25, i have one... i even post to it once a month as well! (mostly just to bitch about politics)
16:51:54 * defcon8 's age * 2 - 8
16:52:17 <vincenz> @seen jethr0
16:52:17 <lambdabot> I saw jethr0 leaving #oasis and #haskell 5 days, 45 minutes and 41 seconds ago, and .
16:52:23 <defcon8> the last politics i bitched about was villagers and their antiproductive "communities"
16:53:33 <jer> last thing i bitched about was the prime minister of canada saying to quÈbec "i dno't want to interfere in provincial politics" then the next day introducing john tory as the next premier of ontario (read: political meddling) ... found it humourous =]
16:53:43 <syntaxfree> I mostly bitch about grad school.
16:54:43 <defcon8> i just invented a really cool word
16:54:48 <defcon8> "revelationoquestional"
16:55:02 <syntaxfree> that's not a word.
16:55:02 <defcon8> it's like a revelation, but it is a really interesting question
16:55:09 <defcon8> revelationoquestional idea
16:55:17 <defcon8> syntaxfree: i know, don't be a party pooper
16:55:49 <syntaxfree> "apoplectic" is better.
16:56:28 <defcon8> are you trying to imply something?
16:57:17 <defcon8> don't you really hate it when you see a really cool banned ad, you click on a link, and when you try to go back, it has changed?
16:57:28 <jer> no
16:58:04 <syntaxfree> I hate it when I go to a nightclub and they play Massive Attack.
16:58:10 <defcon8> syntaxfree: why would apoplectic be better? that has a totally different meaning
16:58:20 <defcon8> i like massive attack but that isn't for a club, is it?
16:58:24 <defcon8> it is slow
17:01:45 <defcon8> http://blog-of-justin.blogspot.com/
17:03:10 <syntaxfree> I can hardly stand my own blog, why would read other people's as well?
17:03:34 <defcon8> to satisfy the human instinct of being nosy of other people's lives
17:03:54 <syntaxfree> my blog isn't really about my life.
17:03:55 <bolrod> > Just "Boring"
17:03:56 <lambdabot>  Just "Boring"
17:04:04 <defcon8> and interests
17:04:48 <syntaxfree> > > 
17:04:48 <lambdabot>  Parse error
17:04:56 <syntaxfree> > (>)
17:04:57 <lambdabot>  Add a type signature
17:05:02 <bolrod> hehe
17:05:05 <syntaxfree> > (>)::Int->Int
17:05:06 <lambdabot>    Expecting a function type, but found `Int'
17:05:06 <lambdabot>    Expected type: Int -> I...
17:05:16 <bolrod> > (#)
17:05:17 <lambdabot>  Not in scope: `#'
17:05:22 <defcon8> what haskell implementation does lambdabot run?
17:05:23 <syntaxfree> > (>):: Int->Int->Bool
17:05:25 <lambdabot>  <Int -> Int -> Bool>
17:05:29 <defcon8> which*
17:05:37 <syntaxfree> it looks like ghc.
17:05:41 <bolrod> 6.5
17:05:45 <defcon8> okay
17:09:03 <syntaxfree> > "In The Wake of Poseidon"
17:09:04 <lambdabot>  "In The Wake of Poseidon"
17:10:32 <defcon8> >map (2 *) [1,2,3]
17:10:52 <defcon8> why won't that work?
17:10:58 <defcon8> > map (2 *) [1,2,3]
17:10:59 <lambdabot>  [2,4,6]
17:11:04 <defcon8> ahh
17:11:05 <bolrod> hehe
17:11:17 <vincenz> > map ($2) . map (*) $ [1..3]
17:11:18 <lambdabot>  [2,4,6]
17:11:24 <bolrod> otherwise I'd give some bogus explanation ofcourse
17:11:29 <defcon8> bolrod: can you give me a map lambda expressions thingo for that, please?
17:11:37 <bolrod> ?..
17:11:38 <lambdabot> Not enough arguments to @.
17:11:44 <vincenz> > map (\x -> 2* x) [1..3]
17:11:46 <lambdabot>  [2,4,6]
17:11:46 <defcon8> map lambda asda in [1,2,3]
17:11:49 <bolrod> > map (\x -> * x) [1
17:11:49 <lambdabot>  Parse error
17:11:50 <bolrod> BLAH
17:12:06 <madpickle> > [2, 4, 6]
17:12:07 <lambdabot>  [2,4,6]
17:12:10 <defcon8> what is the $ infront of the 2 for btw?
17:12:12 <madpickle> simple is better.
17:12:16 <madpickle> :P
17:12:19 <defcon8> madpickle: :)
17:12:27 <bolrod> > [2,4..6]
17:12:28 <lambdabot>  [2,4,6]
17:12:38 <bolrod> simple
17:12:41 <defcon8> > [2,1..10]
17:12:42 <vincenz> > map ($ 1) [(2+), (-3), (3-)]
17:12:43 <lambdabot>  add an instance declaration for (Num (a -> a))
17:12:43 <lambdabot>   In the list element: (- 3)
17:12:43 <lambdabot>  []
17:12:49 <defcon8> peice of crud
17:12:53 <defcon8> piece
17:13:02 <bolrod> well what do you expect it to do then
17:13:06 <vincenz> > map ($ 1) [(2+), (substract 3), (`substract` 3)]
17:13:06 <lambdabot>  Not in scope: `substract'
17:13:10 <defcon8> i don't know where i got into the habit of writing that word wrong
17:13:15 <vincenz> > map ($ 1) [(2+), (subtract 3), (`subtract` 3)]
17:13:16 <lambdabot>  [3,-2,2]
17:13:54 <bolrod> :)
17:14:15 <vincenz> even funkier
17:14:19 <defcon8> what is the dollar for?
17:14:20 <vincenz> > map ($ 1) [(2+), (subtract 3), ((-)3)]
17:14:21 <lambdabot>  [3,-2,2]
17:14:26 <bolrod> f x y = f x $ y
17:14:40 <vincenz> (-3) != ((-)3)
17:14:42 <defcon8> ?
17:14:56 <bolrod> so (-) = flip subtract  ?
17:14:57 <defcon8> don't you mean /= ?
17:15:00 <vincenz> bolrod: no
17:15:06 <vincenz> bolrod: (-) = substract
17:15:11 <vincenz> defcon8: no cause that won't type
17:15:19 <bolrod> > (-) 3 1
17:15:20 <lambdabot>  2
17:15:21 <vincenz> I think
17:15:25 <vincenz> > subtract 3 1
17:15:26 <bolrod> > subtract 3 1
17:15:27 <lambdabot>  -2
17:15:27 <lambdabot>  -2
17:15:29 <vincenz> whohops
17:15:30 <bolrod> see
17:16:30 <bolrod> har har
17:19:05 <bolrod> so .......                           quiet
17:20:22 <syntaxfree> R has implicit maps.
17:20:34 <syntaxfree> like Matlab, actually.
17:21:27 <syntaxfree> flip map [1,2,3] (*2)
17:21:38 <syntaxfree> > flip map [1,2,3,] (*2)
17:21:38 <lambdabot>  Parse error
17:21:48 <syntaxfree> > flip map [1..10] (*2)
17:21:49 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
17:22:18 <syntaxfree> @pl mip n f = flip map [1..n] 
17:22:18 <lambdabot> mip = const . flip map . enumFromTo 1
17:27:02 <Lemmih> Yeah, you better run, you coward!
17:32:51 <vincenz> hola Lemmih 
17:32:56 <vincenz> Lemmih: you're still part of our team, no?
17:33:44 <Lemmih> I think so. Am I?
17:35:15 <vincenz> Yep
17:35:17 <vincenz> just checking
17:35:19 <vincenz> everything's been quiet
17:47:48 <dcoutts> SamB, still confused about the popup event thing?
17:48:48 <ihope> @type Control.Monad.Reader.ap return return
17:48:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> a
17:49:00 <ihope> Monad m => a -> a?
17:49:17 <ihope> @type Control.Monad.ap return return
17:49:18 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> a
17:49:22 <ihope> Hmm.
18:00:35 <syntaxfree> > map (x\->"Skazi") [1..10]
18:00:36 <lambdabot>  Not in scope: `\->'
18:00:46 <syntaxfree> > map (\x->"Skazi") [ 1..10]
18:00:47 <lambdabot>  ["Skazi","Skazi","Skazi","Skazi","Skazi","Skazi","Skazi","Skazi","Skazi","Sk...
18:02:18 <dcoutts> @seen dons
18:02:19 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 1 day, 1 hour, 15 minutes and 10 seconds ago.
18:05:45 <ihope> "Syntax-free"? What sort of language would that be? :-)
18:06:08 <syntaxfree> Scheme.
18:09:44 <iron32> Scheme is minimal syntax and mutable syntax but not syntax free :)
18:10:05 <Pseudonym> I suppose a language based on abstract syntax might be syntax-free.
18:10:07 <Pseudonym> Like a DSL.
18:10:20 <Pseudonym> Embedded DSLs often don't have a syntax of their own, borrowing from the host language.
18:10:23 <Pseudonym> Kind of parasitic.
18:10:40 <iron32> Hmm like a lawyer or a politician scary stuff
18:11:05 <jer> Pseudonym, there are general purpose languages whose source is representative of the ast (c.f. io (iolanguage.com)); though it does have some syntactic sugar which gets transformed into proper messages; so it's not without a teeny bit of syntax
18:11:11 <jer> though that can easily be removed
18:12:07 <Pseudonym> Sure.
18:48:22 <wy> hello, I've got a problem trying Haskell for the first time
18:48:43 <Excedrin> ok
18:49:24 <wy> I just can't get one line from the book " A Gentle Introduction to Haskell" work in GHC
18:49:52 <wy> data Tree a = Leaf a | Branch (Tree a) (Tree a) 
18:49:52 <wy> <interactive>:1:0: parse error on input `data
18:51:15 <wy> Any ideas about this ?
18:52:39 <Excedrin> create a file with that content
18:52:50 <Excedrin> then load it into ghci
18:53:29 <Dino_> I thought the prompt in ghci is basically happening inside a do statement.
18:53:51 <wy> What if I want to do it interactively?
18:55:58 <Excedrin> http://www.haskell.org/hawiki/HaskellNewbie_2fHaskellInterpreterUsage
18:57:28 <Dino_> I see, that's among the things you just can't do without a file.
18:57:57 <Dino_> wy: You could set up some of your stuff in a file and then :l load that in the interpreter where you'll be able to use those defs interactively.
18:58:34 <Cale> wy: The interactive environments are more for debugging than actually writing programs.
19:02:01 <SamB> dcoutts: eh, it works fine in darcs
19:02:14 <vincenz> wy: that's a poor representation of a binary tree
19:02:27 <Cale> vincenz: how so?
19:02:31 <vincenz> Cale: no empty trees
19:02:34 <vincenz> either
19:02:41 <SamB> dcoutts: but you really should add a context menu to a mozembed example
19:02:41 <Cale> vincenz: so?
19:02:45 <vincenz> data Tree a = Empty | Leaf a | Branch (Tree a) (Tree a)
19:02:46 <vincenz> or
19:02:54 <vincenz> data Tree a = Leaf | Branch (Tree a ) a ( Tree a)
19:03:00 <vincenz> Cale: construct an empty tree with hsi spec, you can't
19:03:07 <Cale> those are just different types
19:03:27 <SamB> wy: if you want to do it interactively, use M-x compile!
19:03:51 <vincenz> anyways, personally I'm a believer of elements at branches, not leafs
19:03:55 <vincenz> RB trees use that for instance
19:04:00 * SamB thinks clickable type errors is plenty interactive
19:04:07 <vincenz> and that way, you don't have to go to the bottom to just find an element
19:04:20 <wy> Oh. So I can't build my environment step by step...
19:04:39 <SamB> wy: well, you could also try :r
19:04:42 <SamB> in GHCi or hugs
19:04:49 <vincenz> Cale: imo, Tree a = Leaf | Branch (Tree a) a (Tree a) is better
19:04:53 <SamB> in concert with an editor window
19:05:22 <vincenz> Cale: the other option allows odd constructions, and the original one can't do empty trees, and places all values at the bottom
19:05:34 <vincenz> Cale: which means that you're always doing worstcase to access
19:05:36 <SamB> but really, this isn't any worse than what you'd end up having to do in Python for real programs!
19:05:40 <SamB> or Lisp, for that matter
19:06:01 <wy> Is that a shortcoming of GHC ? Can I do it in another interpreter ?
19:06:19 <vincenz> wy: it makes perfect sense, unlike ocaml, haskell is not compiled downwards
19:06:20 <SamB> it isn't practical
19:06:33 <Cale> vincenz: It depends on what you're using it for, it might be just the right type for some things.
19:06:49 <vincenz> Cale: imho, Leaf | Branc ... is best
19:07:16 <Cale> wy: no Haskell interpreter will let you define types interactively
19:07:16 <vincenz> especially for dancing trees with data-access locality, but that's just a specification
19:07:31 <vincenz> erm, speciation
19:07:34 <vincenz> and with that, I'm off to sleep
19:07:39 * SamB opens his umbrella to ward off the muck from the tree fight
19:07:50 <SamB> ... just in time for vincenz to go to bed
19:08:04 <wy> Cale:  why? I think it's not convenient
19:08:14 <Excedrin> did you read the page I linked?
19:08:17 <Cale> wy: It would be confusing
19:08:21 <Excedrin> it has a good explanation at the bottom
19:08:34 <SamB> it is mostly inconvenient when working with lambdabot ;-)
19:08:44 <vincenz> It's obvious, haskell declarations are corecursive at toplevel, not topdown lexing with shadowing
19:08:49 <Cale> wy: If a Haskell interpreter was able to accept any input interactively that it accepted in a file, you could end up in lots of inconsistent states.
19:09:08 <Cale> Where things are not typeable yet, and such.
19:09:25 <Cale> I don't think I'd want to use such a system, let alone write one :)
19:09:34 <vincenz> wy : echo "blabla" > test.hs
19:09:37 <vincenz> ghci test.hs
19:09:38 <Cale> It's really better that all declarations happen at once.
19:09:39 <SamB> wy: how would you change types then?
19:09:43 <vincenz> > Leaf 1
19:09:43 <lambdabot>  Not in scope: data constructor `Leaf'
19:09:51 * SamB thinks you'd have to say :reset to get rid of all the types
19:10:14 * vincenz points up to his previous point regarding haskell scoping
19:10:17 <Cale> Consider that you can do, in a Haskell file:
19:10:28 <Cale> evens = 0 : map (1+) odds
19:10:30 <vincenz> basically you'd have to get one huge let rec (ocaml syntax), ghci wouldn't know when it ends
19:10:33 <Cale> odds = map (1+) evens
19:10:54 <SamB> so really, what you want is some kind of a buffer to edit
19:10:59 <vincenz> on that note
19:11:04 <SamB> which contains the entire thing
19:11:06 <vincenz> Cale: scoped data-decls would be neat
19:11:10 <Cale> not to mention that you can declare types after the point at which you used them
19:11:11 <vincenz> Cale: cause that example can be done with a letbinding
19:11:23 <SamB> yeah!
19:11:29 <SamB> but what would happen if you did:
19:11:50 <SamB> > let data Foo = Foo deriving Show in Foo
19:11:50 <lambdabot>  Parse error
19:12:10 <SamB> lambdabot: you aren't very good with hypothetical questions, are you?
19:12:12 <vincenz> SamB: the same as exporting a tycons without the datacons
19:12:18 <vincenz> SamB: you can show it, just can't patternmatch it
19:12:37 <SamB> vincenz: what if it was declared in a function?
19:12:43 <vincenz> my point still holds
19:12:47 <vincenz> export the tycons
19:12:48 <SamB> and depended on other types?
19:12:50 <vincenz> not the dataconses
19:12:57 <vincenz> SamB: I fail to see the problem
19:13:02 <SamB> well...
19:13:05 <vincenz> SamB: it's like hidden datacons from an imported module
19:13:19 <vincenz> or hidden types from imported module
19:13:35 <SamB> well, I'd need scoped type variables to do this...
19:13:41 <vincenz> well yeah
19:13:42 <SamB> but I could!
19:13:48 <vincenz> you'd need to annotate them to uniquefy them
19:13:52 <Cale> let data Foo = Foo deriving Show in Foo -- this would be an error
19:13:55 <vincenz> well the compiler would have to
19:14:03 <vincenz> Cale: no it's not
19:14:07 <vincenz> Cale: same as
19:14:19 <Cale> sure, because the type isn't exported from the let
19:14:26 <vincenz> module Bla(plop) where { data Foo = Foo deriving show; plop = Foo}
19:14:32 <Cale> so it's not typeable
19:14:32 <vincenz> module X where{import bla; plop
19:14:42 <vincenz> Cale: yes it is
19:14:48 <vincenz> Cale: try it out with a module and a hidden type
19:14:55 <SamB> oh, yeah, what would be the type of the function?
19:15:06 <SamB> or of the expression, even...
19:15:08 <vincenz> SamB: :: <hidden: Foo>
19:15:17 <vincenz> SamB: whatever GHC uses to represent imported hidden types
19:15:20 <SamB> I don't think that is a valid Haskell type!
19:15:24 <vincenz> look
19:15:26 <vincenz> this is JUST the same
19:15:27 <Cale> It doesn't, I think it just fails.
19:15:32 <vincenz> as hidden types from an imported module!
19:15:39 <SamB> GHC uses qualified names, actually...
19:15:46 <Cale> If you don't export a type, then you can't export things which result in that type.
19:15:51 <vincenz> SamB: so use qualified names based on location in cod
19:16:05 <vincenz> SamB: Test.Loop1_.Foo
19:16:08 <SamB> oh, well, true, you can't export those things...
19:16:22 * vincenz test
19:17:18 <vincenz> works fine
19:17:34 <vincenz> module A(foo) where
19:17:34 <vincenz> data A = A
19:17:34 <vincenz> foo = A
19:17:46 <vincenz> module Main where
19:17:47 <vincenz> import A
19:17:47 <vincenz> main :: IO ()
19:17:47 <vincenz> main = let x = foo in print "aha"
19:18:17 <vincenz> even printing it works
19:18:21 <vincenz> if it derives Show
19:18:34 <SamB> what?
19:18:49 * vincenz will write a post to haskell-cafe tomorrow
19:19:04 * SamB doesn't think GHC would be able to figure out the type for something like let data Foo = Foo deriving Show in Foo, though
19:19:11 <Cale> That's odd if that works
19:19:11 <vincenz> module A(foo) where
19:19:11 <vincenz> data A = A deriving Show
19:19:11 <vincenz> foo = A
19:19:11 <vincenz> module Main where
19:19:11 <vincenz> import A
19:19:13 <vincenz> main :: IO ()
19:19:15 <Cale> I think it ought to fail
19:19:16 <vincenz> main = let x = foo in print x
19:19:18 <vincenz> this works
19:19:25 <vincenz> Cale: why, only datacons are hidden
19:19:28 <SamB> because it wouldn't be able to come up with a name for the type, as far as I know
19:19:31 <vincenz> the type is still a valid type
19:19:42 <vincenz> SamB: just generate module names based on sourcecodelog
19:19:46 <vincenz> loc
19:19:58 <vincenz> Test.__LOCXXX__.Foo
19:20:02 <Cale> Because that means that there are terms for which you can't write a type signature.
19:20:11 <SamB> anyway, that is bad...
19:20:14 <vincenz> Cale: that's another thing
19:20:25 <vincenz> Cale: just cause you can't write it doesn't mean you can't type it
19:20:34 <SamB> well, it should
19:20:37 <Cale> Well, it doesn't have a type.
19:20:39 <Excedrin> :t foo
19:20:39 <Excedrin> foo :: A.A
19:20:45 <Cale> Since its type isn't in scope
19:20:54 <SamB> rather the inverse of the converse should be true ;-)
19:20:54 <Cale> see, but A.A isn't imported
19:21:05 <Cale> or are you exporting it?
19:21:05 <SamB> if you can type it, you ought to be able to write it
19:21:07 <vincenz> Cale: so you can't specify it
19:21:09 <vincenz> Cale: nope
19:21:10 <vincenz> anyways
19:21:11 * vincenz off
19:21:17 * SamB likes scoped type vars for that reason
19:21:18 <Excedrin> I used exactly vincenz' code
19:21:19 <vincenz> and I think it'd work JUST the same for local data stuff
19:21:28 <vincenz> just add compiler generated modules
19:21:33 <vincenz> in fact
19:21:35 <Cale> I don't think it should work at all.
19:21:37 <vincenz> it's just syntactic sugar
19:21:47 <vincenz> with some extra scoping/import rules
19:21:56 * vincenz off now
19:21:58 <vincenz> 4:20am
19:22:08 * SamB thinks vincenz is a bit crazy
19:22:21 * SamB thinks vincenz needs to sleep before talking of this again
19:22:21 <vincenz> SamB: it'd be great for lambdabot
19:22:33 <SamB> oh, yes, I don't doubt it
19:22:41 <SamB> but I'm not sure you should be aloud to return them
19:22:43 <vincenz> and after this
19:22:45 <SamB> er, allowed
19:22:48 <vincenz> scoped classes and instances
19:22:58 <SamB> no, no, no!
19:23:00 <vincenz> which are less nonobvious
19:23:05 <vincenz> cause classes and instances are always global
19:23:07 <SamB> you are very crazy!
19:23:09 <vincenz> nono
19:23:13 <vincenz> classes and instances are always global
19:23:31 * vincenz off for real
19:23:36 <vincenz> I'll send something to haskell-cafe tomorrow
19:23:55 * vincenz grins and
19:24:22 <Cale> It would be fine if you could do something like  let data Foo = Foo deriving Show in print Foo
19:24:29 <vincenz> > let data Mu x = Mu { unMu :: x (Mu x) } in Mu []
19:24:30 <lambdabot>  Parse error
19:24:31 <SamB> oh, sure
19:24:34 <Cale> but not if you could return the value Foo itself
19:24:45 <Cale> I disagree that that should even be allowed
19:24:55 <vincenz> Cale: bring it up as a reply to my post
19:25:03 <vincenz> Cale: BUT be fair and mention the problem with the current GHC as well
19:25:10 <vincenz> instead of just using it to diss on my specific suggestion ;)
19:25:25 <Cale> I'd like to preserve the property that one could write a program which adds type signatures to every term and still have a valid program.
19:25:26 <SamB> yeah, I think thats roughy the same sort of thing as an existential type that you can't use for anything...
19:25:44 <SamB> what property?
19:25:47 <vincenz> Cale: which apparently is already broken!
19:25:54 * SamB points to missing scoped type veriables!
19:25:55 <Cale> vincenz: yes
19:26:05 * vincenz types /quit
19:26:06 <vincenz> bbe
19:26:07 <SamB> and yes, vincenz's exploit
19:26:08 <vincenz> +y
19:26:23 <Cale> vincenz: Though that's with modules though, and everyone knows the module system sucks ;)
19:26:31 <wy> I've read the page http://www.haskell.org/hawiki/HaskellNewbie_2fHaskellInterpreterUsage. But I can't figure out the difference of "typing declarations interactively" and "loading them from a file". What's the difference if you can load the file and modify it and then reload it?
19:26:31 <vincenz> Cale: yeah, no nested modules
19:26:33 <SamB> or whatever you call such blatent violation of what ought to be the rules
19:26:42 <Cale> Separate compilation is a red herring ;)
19:26:53 <vincenz> especially with corecursive modules
19:26:54 <SamB> wy: you don't have to retype everything if you mess up?
19:27:14 <SamB> the compiler can see the end of your program?
19:27:18 <Cale> wy: At the interpreter, you type expressions, which are then evaluated
19:27:21 <vincenz> Cale: imo, separate compilation is a thing of the past
19:27:29 <Cale> wy: In your file, you provide declarations
19:27:40 <vincenz> but, another discussion for another day
19:27:42 <vincenz> tatah
19:27:55 <SamB> vincenz: you are supposed to have left like five times already
19:28:02 <vincenz> SamB: noone says goodbye :(
19:28:07 <SamB> goodbye!
19:28:13 * vincenz woots and goes
19:28:15 <Excedrin> wy: if ghci or hugs had something like, "definitions mode" where you only type definitions, then you finish and go back to "evaluation mode" to evaluate some expressions with the definitions you entered, it's basically the same as using an editor
19:28:16 <SamB> haha
19:28:44 <SamB> except to go back to definitions mode, you would need to go through trash can mode ;-)
19:30:14 <wy>  But then there is problem of time. Can I change type definitions then? If I can, the order of evaluation begin to matter.
19:30:30 <Cale> wy: right, which is why this is forbidden
19:30:58 <wy> Cale:  You mean I can't redeclare a type even in a file ?
19:31:31 <Cale> wy: It's really pretty easy to keep an editor window open alongside GHCi, and whenever you save your file, type :r
19:31:46 <Excedrin> when you reload a file, the compiler throws away what you had before; so yes, you can change everything
19:31:48 <Cale> you can't redeclare types
19:32:02 <Cale> Once a type is declared, anywhere in a file, that's what it is
19:32:16 <Cale> The order of the declarations in your file doesn't matter (mostly)
19:32:42 <Cale> The only place where it does matter is in the case of functions with multiple patterns to match -- they're tried in order.
19:32:57 <wy>  So after reloading a file, the interpreter restarts ?
19:33:01 <Cale> yes
19:33:19 <wy> That's the point. Thank you :-)
19:34:13 <SamB> of coures you can redeclare a type in a file -- simply delete the original declaration and type a new one ;-)
19:35:38 <Cale> SamB: well, sure -- I'm saying that you can't have it be one thing in the first half of the file and another in the second half
19:35:58 * SamB was teasing anyway
19:36:03 <Cale> I know
19:36:03 <SamB> well, mostly
19:36:11 <SamB> a *little* bit not
19:36:35 <SamB> or *leetle*, as they say ;-)
19:36:48 <Cale> was it you that was working on Conjure?
19:36:58 <Cale> I can't remember who was working on that project
19:37:00 <SamB> I was working on conjure a while back
19:37:07 <SamB> I think Lemmih is working on it right now
19:37:09 <Cale> How is it coming along?
19:37:25 <SamB> I will be getting decent bandwidth soon, so maybe I will try it again ;-)
19:37:44 <SamB> I think he said it was almost working
19:37:56 <SamB> I mean, almost working well enough to actually use
19:38:10 <Cale> I'd really like to have a BT client which was smart about very large torrents with lots of files.
19:38:17 <SamB> oh, yes
19:38:26 <SamB> but I don't know if Conjure will be that to start with
19:38:47 <SamB> I heartily agree that huge torrents are quite impractical now
19:39:17 <SamB> you probably need to be able to fit at least a tenth of the torrent in RAM at a time to get decent speed
19:39:35 <Cale> For example, let me put an ordering on them and try to finish them in that order, only grabbing pieces from following files if I have bandwidth left and I can't get another piece from the current file.
19:39:36 <SamB> unfortunately the BT protocol does not really allow progressive startup checking, either
19:39:47 <iron32> well I have problem loading modules in GHC with the pattern Name dot Name for example WFRP.Stat anyone else have this problem ?
19:40:10 <SamB> ooh, well, that sounds a bit too hard and fast to perform well
19:40:33 <Cale> SamB: I can approximate it by hand in Azureus
19:40:40 <SamB> well, true
19:40:43 <Cale> I set all the files to do-not-download
19:40:47 <SamB> maybe it performs well enough
19:40:59 <Cale> and then set the first file to high priority, and the second to normal
19:41:08 <Cale> until the first finishes
19:41:13 <SamB> yeah, I've done the same in bittornado...
19:41:24 <Cale> It's just a pain
19:41:29 <SamB> yeah
19:41:35 <Cale> and I think it could be done more optimally
19:42:02 <SamB> but worse is what happened after I'd downloaded about three seasons of Ranma... well, it happened a bit gradually
19:42:14 <Cale> Once the first file gets close to finished, the fact that the second file has lots of available open parts starts getting in the way of downloading the last few parts of the first file
19:44:41 <Cale> so at that point, I usually have to turn the second file off as well just to let the first one finish properly
19:45:03 <SamB> well, I was talking about the startup time and the fact that it wouldn't be able to keep much cached
20:15:07 <iron32> I have a question does the last statement in the do notation have to return a monad ?
20:16:05 <SamB_XP> all of them have to be monadic...
20:16:05 <SamB_XP> it doesn't have to say "return", if that is what you mean
20:16:15 <SamB_XP> it does have to be an expression
20:18:10 <iron32> ok but if I extract a value out of a monad an use it to build a non monad record it is allowed ?
20:19:13 <SamB_XP> you can build whatever you like -- but inside a do, you are stuck in the monad
20:19:29 <palomer> I wish someone would formalize this idea of being "stuck in a monad"
20:27:25 <dropdrive> what do you mean by "stuck in a monad?"
20:27:42 <iron32> ws :: Int -> Stat
20:27:42 <iron32> ws n = 
20:27:42 <iron32> 	do
20:27:42 <iron32> 	x <- twoD10
20:27:42 <iron32> 	MakeStat { name = "WS", baseValue = ( x + n ) }
20:28:29 <iron32> This is not being compil;ed becuase I should be returning type Monad Stat or stat should simple be a monad instead of a record ?
20:30:22 <palomer> dropdrive: my point exactly
20:31:43 <iron32> palomer: any reference to my post becuase I was framing it as a sort of question to be confirmed :)
20:32:06 <dropdrive> palomer: a simple example?
20:32:18 <Korollary> iron32: Is Stat a datatype that you declared? If yes, is it an instance of Monad?
20:32:39 <iron32> Korollary no it isnt a Monad
20:32:52 <iron32> Stat is a data type that I have declared
20:33:10 <Korollary> iron32: Then you shouldn't be using the do notation for ws.
20:33:47 <iron32> problem is a need the random number generator twoD10 which is type IO Int
20:34:07 <iron32> can I just use the bind operator instead of do notation
20:34:16 <iron32> to get the value out of this generator
20:35:09 <iron32> I think bind just passing the value to another monad in general right ?
20:36:27 <iron32> Random number generators are not deterministic so they mostly seem to be encapsulated in Monads which seems like the right thing to do
20:37:26 <iron32> but how to I get to the center of the tootsie roll so to speak
20:37:52 <palomer> dropdrive: <SamB_XP> you can build whatever you like -- but inside a do, you are stuck in the monad
20:38:04 <palomer> being stuck inside a monad is a vague idea that many haskell programmers use
20:38:08 <palomer> yet they don't know what it means
20:38:11 <palomer> (me included)
20:38:36 <Korollary> iron32: As the IO monad is a one way monad, there is no way out. Your function will get an IO return type.
20:39:25 <iron32> but I can acess the value from inside another Monad I have tried this and it works
20:39:56 <SamB_XP> basically, you just pass stuff into a pure function if you want to stop having to write all your code in the monad
20:40:03 <Korollary> Yes, you can access the value in an expression as long as that expression's type is also IO something.
20:41:22 <iron32> SamB_XP: well I don't see how to extract the Int out of IO Int for use in a pure function i.e a non Monad action or state
20:42:00 <Korollary> iron32: what he means is that you can use other pure functions in an expression whose type is IO something.
20:42:50 <SamB_XP> also you can use "let"
20:43:34 <Korollary> e.g. main = do { c <- getChar; putStrLn (show (toUpper c)) }. toUpper, show are pure.
20:44:44 <iron32> Korollary: What is your definition of pure ? As far I can see the type that haskell would infer from for main is IO ()
20:45:08 <iron32> that is a Monad action not exactly the same as a function
20:45:33 <iron32> of course I am an FP noob
20:45:39 <wy> I need a concise explanation what is Monad
20:45:52 <iron32> wy : You and me both
20:45:55 <Cale> @wiki Monads_as_Containers
20:45:55 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
20:46:03 <Cale> read that :)
20:46:17 <Cale> it's my explanation for beginners about monads
20:46:32 <wy> A Gentle Introduction to Haskell is hell
20:46:34 <Cale> also, specifically for IO,
20:46:39 <wy> Cale:  Thank you :)
20:46:43 <Cale> @wiki Introduction_to_IO
20:46:43 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
20:46:55 <Cale> that should help get you started
20:47:01 <SamB_XP> yeah, for some reason we tend to get our terminology all confused sometimes -- maybe we have had too much C ;-)
20:47:49 <Cale> Well, there's a certain sense in which a function (a -> IO b) is pure, and a certain sense in which it is not.
20:48:20 <Korollary> heh
20:48:25 <Cale> If you look at it as a function from values of type a to IO actions, then it's pure.
20:48:50 <Cale> It you look at it as a computation from values of type a to values of type b, then it is impure.
20:49:15 <Korollary> even if it is "return 1" ?
20:49:27 <Cale> well, that's again, another issue :)
20:49:46 <Cale> return 1 doesn't have any side effects
20:49:54 <Cale> but it's still an IO action here
20:50:03 <Cale> and certainly not the same as 1
20:51:13 <Korollary> right. We're actually not meant to think that two "return 1"s are alike, either.
20:51:29 <skew> You could talk about the subcategory of the Kleisli category of IO isomorphic to the base category of pure Haskell
20:51:41 <dropdrive> palomer: by "stuck in a monad" you don't mean "one-way monad," or do you?
20:52:03 <SamB_XP> skew: I don't really think that would be very helpful
20:52:30 <skew> certainly not for explaining things to somebody learning the language, but maybe for consolidating what you already know
20:52:31 <Cale> Whenever you have a category C, and a monad M on that category, it's possible to form a new category whose arrows A -> B are the arrows A -> M B in the original category, and where composition is defined using (f . g) x = g x >>= f
20:52:50 <Cale> this composition is called Kleisli composition
20:52:51 <SamB_XP> skew: only if you actually know what a *category* is!
20:52:57 <skew> category theory provides some names for this sort of stuff
20:53:06 <Cale> and the new category is the Kleisli category for the monad M
20:53:27 <palomer> @hoogle Pi
20:53:27 <lambdabot> Prelude.pi :: Floating a => a
20:53:28 <lambdabot> Language.Haskell.TH.ClassOpI :: Name -> Type -> Name -> Fixity -> Info
20:53:28 <lambdabot> Data.Map.lookupIndex :: (Monad m, Ord k) => k -> Map k a -> m Int
20:54:25 <Cale> @hoogle (b -> m c) -> (a -> m b) -> (a -> m c)
20:54:26 <lambdabot> No matches, try a more general search
20:54:31 <Cale> too bad
20:54:53 <skew> "Just Sementation Fault"
20:54:55 <iron32> @hoggle Monad
20:54:56 <lambdabot> Control.Monad :: module
20:54:56 <Cale> That really ought to be put somewhere and given a nice operator symbol
20:54:57 <lambdabot> Data.Graph.Inductive.Monad :: module
20:54:57 <lambdabot> Data.Graph.Inductive.Query.Monad :: module
20:55:43 <iron32> @hoggle Arrow
20:55:44 <lambdabot> Control.Arrow :: module
20:55:44 <lambdabot> Control.Arrow.Arrow :: class Arrow a
20:55:44 <lambdabot> Control.Arrow.ArrowMonad :: a () b -> ArrowMonad a b
20:55:46 <skew> Cale: perhaps a -> M b should get the Arrow instance rather than a -> b
20:56:02 <Cale> skew: it has an Arrow instance, indirectly
20:56:11 <Cale> and I like the Arrow instance for a -> b
20:56:25 <skew> why?
20:56:40 <Cale> because it provides lots of useful functions
20:56:57 <Cale> especially when working with pairs
20:57:21 <Cale> @type (***)
20:57:23 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:57:51 <skew> I think I'd rather have >>> for working with monads
20:58:26 <skew> it seems to me that all those combinators are really just a clumsy way of expressing diagrams
20:58:46 <iron32> So if every type you define is an instance of Monad you shouldn't have any problems populating them with data retreived with IO Monads ?
20:59:23 <skew> iron32: that's pretty wrong
20:59:57 <skew> I can't see how your types being monads make it any harder or easier to populate them with data retrieved from IO
21:00:40 <iron32> skew: Well please feel free to educate me how do get an Int out of IO Int
21:00:57 <Korollary> iron32: No. The expression has to be of type IO something. Not just any other Monad.
21:01:12 <Cale> iron32: I think the main point in programming with IO in Haskell, is that main is an IO action, and you simply have to define it to get things to happen. You're allowed to build it out of other IO actions as well as pure functions.
21:01:24 <skew> iron32: probably the easiest way is do use do syntax
21:01:52 <skew> like do text <- getLine; let value = f text ...
21:02:08 <skew> f can be some function String -> a, and you can use "value" in the rest of the do block
21:02:17 <Cale> You normally do the stuff that's directly tied to IO with IO actions, and your harder, algorithmic stuff with pure functions
21:02:39 <Cale> (It's not called the IO monad for nothing)
21:03:05 <skew> one thing you can't do is get use IO in a function for some stuff, and not have IO show up on the function type
21:03:33 <Cale> You can, in the context of a single IO action, get the result of an IO action, pass it off to a pure function and return the result, but that will be defining another IO action, and not a pure value.
21:03:55 <Cale> For example,
21:04:12 <Cale> do putStrLn "What is your name?"
21:04:17 <Cale>    name <- getLine
21:04:30 <Cale>    let rev = reverse name
21:04:48 <Cale>    putStrLn $ "Your name in reverse is: " ++ rev
21:04:53 <Korollary> iron32: Do you have Yet Another Haskell Tutorial? All this stuff is explained in section 5.2 with examples.
21:05:15 <Cale> note that reverse has type [a] -> [a]
21:05:37 <Cale> and so the actual meat of the "work" being done here is in a pure function
21:05:57 <Cale> (one which doesn't have to worry about IO)
21:06:03 <skew> iron32: all this stuff makes it a bit harder to do stuff in a function, but easier to do stuff *to* functions
21:07:56 <iron32> hmm ok but if all I have to work with is IO Int then there is no way to safely use it to build a record I have defined right ?
21:08:32 <iron32> by safely I mean without performing unsafe IO
21:09:09 <skew> you can write something like do x <- ioIntGetter; return (Point {x = x, y = 10}), which has type IO Point
21:09:22 <iron32> well I could build it but it would be lost in the return stement
21:10:08 <skew> yeah, that's about right - you either have to use it inside the do block, or include it inside the value returned
21:11:56 <iron32> thanks
21:12:14 <skew> I'm not sure what it would even mean to use it elsewhere - think about having in any language one function f (x) { .. do stuff ..} and another function g (y) { .. use x ..?
21:12:35 <skew> where they are not related or nested or anything, and wanting that x to refer to the argument of f
21:13:12 <skew> the problem is, you might get to g before f has been called, or between two calls or something, and I have no idea what x should mean then
21:14:00 <Korollary> @seen Lemmih
21:14:01 <lambdabot> Lemmih is in #oasis and #haskell. I last heard Lemmih speak 3 hours, 40 minutes and 16 seconds ago.
21:15:35 <iron32> lots to think about guess I will sleep on it thanks again all good night
21:16:46 <skew> yay, I'm not getting Just Segmentation Fault anymore
21:17:24 <skew> so, does anybody know how to make a monad that lets you make references of any type without either using the built in ones or unsafeCoerce#?
21:17:43 <skew> actually, I've read it can be done with delimited continuations
21:28:11 <bringert> skew: is having an instance of Data.Dynamic to much of a restriction?
21:28:41 <bringert> eh, make that instance of Typeable
21:33:10 <skew> I'd like to be able to make something like my own STRefs
21:33:38 <skew> I've got something working with unsafeCoerce#, and phantom types on the references
21:34:43 <ce> Hey, can someone here help me out with a n00b Haskell question?
21:35:17 <Korollary> just ask
21:35:44 <ce> I'm using Hugs which has a broken modulus function -- -100 `mod` 7 evaluates to -2 instead of 5
21:36:03 <ce> So I'm trying to write my own, but it's not working and I have no idea why
21:36:09 <ce> Here's what I've got:
21:36:20 <ce> int1 %! int2 = let val = int1 `mod` int2
21:36:20 <ce>                in if val >= 0 then val
21:36:20 <ce>                               else val + int2
21:36:55 <ce> but that doesn't do what I want!
21:37:44 <skew> what do you want?
21:37:57 <ce> -100 %! 7 should evaluate to 5
21:38:02 <ce> But it still evaluates to -2
21:38:41 <skew> what about (-100) %! 7?
21:39:06 <ce> d'oh!
21:39:33 <ce> stupid rules of presidence.  
21:39:50 <ce> That works... but now I'm confused
21:39:51 <psykotic> btw you could also try x `myMod` y = (abs x) `mod` (abs y)
21:40:34 <ce> isn't "-100" equivalent to "negate 100"?
21:40:38 <skew> maybe you want rem
21:40:54 <ce> psykotic: that wouldn't work.  I want a true modulus.
21:41:42 <ce> (abs -100) %! (abs 7) evaluates to 2, not 5
21:42:03 <psykotic> good point
21:42:07 <ce> rem doesn't seem to act as I want either... I think it's a bug in Hugs.
21:42:32 <ce> The spec says that mod is supposed to act such that it's the remainder after applying div.
21:42:36 <skew> does it work as file:///usr/share/doc/ghc6-doc/html/libraries/base/Prelude.html#v%3Adiv promised?
21:42:39 <ce> div says that it rounds toward negative infinity.
21:42:42 <Korollary> ce: Yes. -e is negate e.
21:42:43 <skew> oops, guess that's local
21:43:17 <ce> but on hugs, -100 `div` 7 evaluates to -14 instead of -15
21:43:26 <Korollary> ce: I don't think it's a bug. It also works that way in some other languages.
21:43:41 <ce> I'm going by the spec on haskell.org
21:43:57 <skew> yeah
21:44:17 <skew> looks like a unary minus shows up at precedence 6
21:44:31 <skew> oh
21:44:39 <skew> -100 `div` 7 = -(100 `div` 7)
21:44:57 <Korollary> I believe python mandates that mod evaluates to non-negative, while c/c++ don't specify.
21:45:02 <skew> "If no fixity declaration is given for `op` then it defaults to highest precedence and left associativity"
21:45:02 <ce> Korollary: see http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Adiv
21:45:24 <skew> so `div` and `quot` are both stronger than unary -
21:45:47 <ce> This reminds me why I like coding in Lisp. ;)
21:45:57 <skew> (-100) `div` 7 -> -15
21:46:10 <skew> yeah, negation really screws up the expression syntax
21:46:32 <ce> shit.  Yeah, that's why the problem was there.
21:47:11 <ce> so nothing's broken after all
21:47:15 <ce> thanks
21:47:41 <Korollary> np
21:56:43 <RyanT5000> ce: if you parenthesize everything as much as it is in lisp, you don't need to worry about fixity in haskell either
22:04:19 <RyanT5000> are readIORef and writeIORef atomic?
22:06:33 <skew> I think they should be
22:07:09 <ce> Is there a haskell function that acts like usleep in C?
22:07:18 <ce> (yes, I know I'd need to put it in a do)
22:07:39 <skew> there's "atomicallyModifyIORef", which suggests something a bit stronger - probably CAS, but hard to tell
22:07:59 <skew> ce: threadDelay, maybe
22:08:14 <ce> that sounds good.  What module is it in?
22:08:26 <skew> perhaps you could find usleep itself under System.Posix
22:08:30 <Korollary> @index threadDelay
22:08:30 <lambdabot> GHC.Conc, Control.Concurrent
22:09:24 <skew> ah, System.Posix.usleep
22:09:43 <skew> threadDelay is better though
22:10:15 <ce> but it doesn't work on Hugs.
22:11:17 <Korollary> ce: I recommend switching to ghc right away if you can.
22:12:11 <ce> I was using Hugs because "The Haskell School of Expression" said they tested the code and provided the SOEGraphics library
22:19:58 <Pseudonym> No, it takes structs with 243 members instead.
22:19:58 <RyanT5000> lol i hated MFC so much
22:19:58 <stepcut> in the X11 book there is a 6 page long example on how to open a window
22:19:58 <Pseudonym> In Petzold's "Programming Windows", the equivalent is only five pages.
22:19:58 <bringert> hi stepcut
22:19:58 <Pseudonym> So tehre!
22:19:58 <ce> wtf?  6 pafes to open a window?
22:19:58 <stepcut> hi bringert
22:19:58 <bringert> stepcut: I have some fixes for the RSS module
22:19:58 <RyanT5000> does anyone know why window classes exist?
22:19:59 <RyanT5000> or, more importantly, are mandatory?
22:20:03 <bringert> did you every get around to putting up a repo?
22:20:05 <stepcut> bringert: Shapr mentioned something about that...
22:20:11 <stepcut> bringert: nope
22:20:20 <ce> Say, should I install ghc6 or ghc-cvs?  (I'm on Debian)
22:20:20 <stepcut> bringert: I am a terrible maintainer :)
22:20:43 <bringert> stepcut: the version I had was missing some XML escaping stuff, but it could be that I managed to remove it in the past
22:21:14 <stepcut> bringert: it is quite likely it was never there.
22:21:31 <bringert> it was imported, but not used :-)
22:21:38 <stepcut> bringert: heh
22:22:04 <stepcut> bringert: yeah -- it appears to be that way in my version too :)
22:23:27 <skew> ce: I think the big fun in cvs is the smp runtime
22:23:37 * stepcut goes off to do something important sounding
22:24:42 <bringert> stepcut: at the moment my version is here: http://www.cs.chalmers.se/~bringert/darcs/hope/modules/blob2/Text/RSS.hs
22:25:24 <bringert> though it's liable to move to some other place in the Hope repo soon, once I get around to implementing RSS feeds for other things than blog entries
22:27:33 <Pseudonym> bringert: Window classes in Win32 are a bit of an oddity.
22:27:46 <Pseudonym> I _think_ they were a space-saving device back in the bad old days.;
22:28:05 <bringert> Pseudonym: was that for stepcut?
22:28:18 <Pseudonym> No, RyanT5000.
22:28:23 <bringert> ah
22:28:25 <Pseudonym> Sorry.
22:28:34 <Pseudonym> Yes, window classes.
22:28:55 <Pseudonym> Basically, they are the meta-objects for windows.
22:29:34 <Pseudonym> If you think of a GUI library written in C as basically a half-arsed object model, then window classes are the half-arsed meta information.
22:29:45 <Pseudonym> Like the vtable.
22:30:39 <Pseudonym> It made a certain amount of sense at the time, but nowadays, people tend to register one window class and build their own half-arsed metaobject system.
22:30:40 <Pseudonym> e.g. MFC
22:31:24 <RyanT5000> lol
22:31:26 <RyanT5000> sounds about right
22:31:50 <Pseudonym> If you've ever seen a MFC message map, you know EXACTLY what I mean by "half-arsed" in this contxgt.
22:31:53 <Pseudonym> context
22:31:59 <RyanT5000> yes, yes i have, and yes i do
22:32:43 <Korollary> Pseudonym: Aren;t you writing a win32 gui app nowadays for work?
22:32:51 <Pseudonym> Yup.
22:32:56 <Pseudonym> Two, actually.
22:32:58 <RyanT5000> i feel for you, man
22:33:04 <Pseudonym> Thanks.
22:33:11 <Pseudonym> At least I'm acquiring some skills.
22:34:06 <Pseudonym> I'm seriously considering writing the new one using this, though: http://torjo.com/win32gui/
22:34:19 <Pseudonym> Because I don't need cross-platformness, this might be just what I want.
22:35:36 <Korollary> as long as your boss is ok
22:35:45 <Pseudonym> My boss isn't a programmer.
22:35:51 <Pseudonym> It's only me and the guy who comes after me.
22:35:59 <Korollary> ahah. poor sucker.
22:36:16 <Pseudonym> Yeah, but using modern Andrescu-esque C++ just means I'm raising the bar.
22:36:24 <Korollary> Why do you need to write it in c++ anyway?
22:36:33 <Pseudonym> Hysterical raisins.
22:36:41 <Korollary> Roger
22:36:56 <Pseudonym> Mostly, because that's what the hardware guy speaks.  Sort of.
22:37:35 <Korollary> Our hardware guys could only read C.
22:38:03 <Korollary> and they also wrote a lot of C as well (to test their FPGA's)
22:38:44 <skew> ghc -C?
22:40:36 <Korollary> I have to write some perl tomorrow.
22:41:10 <Pseudonym> Well, you know where to find Audrey...
22:41:20 <Korollary> not that lucky. perl 5.8
22:41:22 <Pseudonym> Ah.
22:41:23 <Pseudonym> What for?
22:41:26 <Korollary> work
22:41:34 <Korollary> some minor processing
22:42:04 <Pseudonym> Perl is pragmatic.
22:42:12 <RyanT5000> perl makes my eyes bleed
22:42:19 <RyanT5000> great for getting stuff done, but bleeding ensues
22:42:24 <Pseudonym> But it makes my fingers fly!
22:42:27 <Korollary> Perl would be ok if I could remember every damn exception to the rules of dwim.
22:42:30 <RyanT5000> not as much bleeding as lisp, though
22:43:05 <Pseudonym> Lisp doesn't make my eyes bleed.  More glaze.
22:43:27 <RyanT5000> either way
22:43:44 <RyanT5000> those parentheses start to have a moire effect
22:44:03 <RyanT5000> "is that a parenthesis or an afterimage of one on my retina?"
22:44:16 <Korollary> use plenty of whitespace
22:44:47 <RyanT5000> meh, i prefer to just avoid it
22:45:11 <RyanT5000> though it did cost me an A in my prog lang course
22:46:34 <Korollary> I used to mind syntax, but I've gotten used to it. I can even read & write ocaml without complaining.
22:53:02 <lisppaste2> locksy pasted "syntax fubar" at http://paste.lisp.org/display/21632
22:53:28 <locksy> Can someone tell me what I'm missing here?
22:54:29 <Korollary> locksy: You can't declare a class as an instance of another.
22:55:12 <RyanT5000> Korollary, why is that?
22:56:11 <Korollary> RyanT5000: Because instance declarations are for type constructors or types
22:56:42 <RyanT5000> yeah but you can do such a thing as
22:56:52 <RyanT5000> instance (Blah a) => Blah [a] where
22:57:32 <Korollary> Yes. The instance is [a]. [a] is not a class.
22:57:45 <RyanT5000> right, well above the instance is kt
22:58:00 <RyanT5000> kt represents some type
22:58:19 <RyanT5000> i haven't really thought it through though
22:58:37 <RyanT5000> i just don't see an obvious reason it doesn't make sense
22:58:39 <Korollary> no, the instance is "PKList kt". there is no type constructor named PKList, though.
22:59:12 <locksy> ah! That was what I was missing,  I'll think some more...
22:59:18 <RyanT5000> oh, maybe i misread what he had
22:59:20 <Korollary> he can have instance PMaybe kt
23:01:49 <locksy> No,  hang on. `` instance (PKString kt) => PKList kt '' refers to the instance kt of class PKList in the context of PKString kt
23:02:40 <Cale> locksy: that sort of thing might be allowed with -fallow-undecidable-instances
23:02:57 <locksy> So,  kt really needs to be as Type Constructor?
23:03:03 <Cale> yeah
