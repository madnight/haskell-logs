00:18:24 <evergreen> ghci -e '1'  =>  ghc-6.4.1: cannot use `--interactive' with `-e'
00:18:36 <evergreen> Anybody know what I'm doing wrong?
00:20:26 <Igloo> ghc -e '1'
00:20:54 <lispy> > 1
00:20:55 <lambdabot>  1
00:21:26 <evergreen> Ah.  I guess the "i" in "ghci" stands for "--interactive".  Thanks.
00:22:07 <elias> ghc -e 'x = 1'
00:22:15 <elias> <interactive>:1:2: parse error on input `='
00:22:17 <elias> ?
00:22:27 <Cale> elias: it wants an expression
00:22:35 <Cale> elias: that's a declaration
00:23:04 <elias> I'm just learning haskell, but it seems not even the examples in tutorials work
00:23:25 <Cale> elias: You're supposed to put your code into a source file and load that file into ghci
00:23:39 <elias> oh, it's not interactive :o
00:23:56 <Cale> It is interactive, in that you can interactively evaluate expressions
00:24:08 <Cale> not that you can make declarations interactively
00:24:11 <elias> not like the python interpreter I mean
00:24:14 <Cale> right
00:24:36 <Cale> Haskell declarations can be mutually recursive
00:25:36 <flux__> elias, you can use 'let' to assign names to values, though. ghc -e 'let a = 42 in a + 1'
00:25:38 <Cale> so it would get pretty confusing if it acted like the python interpreter -- you'd end up with terms which were partially defined and you wouldn't even know the type of yet
00:25:56 <flux__> and interactively just 'let a = 42'
00:26:10 <Cale> though you can't define new types
00:26:20 <flux__> well, ocaml uses one solution to that problem, ';;' finishes a block that is sent to the compiler
00:29:10 <Saulzar> Hmm, one could add something like that to ghci or hugs, but you wouldn't be able to edit lines very well
00:29:45 <Cale> yeah, it's easier just to use your text editor to edit, and reload the file with :r, I think :)
00:30:14 * lispy is often distrubed by ocaml syntax
00:30:22 <lispy> disturbed*
00:30:38 <flux__> what's disturbing about it?
00:30:49 <lispy> 'let rec'
00:30:53 <lispy> .+
00:30:58 <lispy> or is it +.
00:31:19 <lispy> and the seemingly random sprinkling of ; ;)
00:31:34 * lispy judges languages too harshly on syntax
00:31:35 <Cale> and all the semicolons, and I seem to remember it had a strange cons symbol
00:31:48 <lispy> well, they mixed up : and ::
00:31:58 <lispy> oh and lists use ; instead of ,
00:32:24 <flux__> so it's disturbing only because you've become familiar with haskell first?-)
00:32:43 <Cale> .+ is disturbing anyway :)
00:32:44 <lispy> potentially yes, but i think there is more to it than that
00:32:54 <lispy> Cale: they don't have ad-hoc polymorphism@
00:33:02 <Cale> and having to specifically declare that let is recursive is dumb
00:33:02 <lispy> so they do weird stuff like that
00:33:05 <flux__> well, +. is sort of annoying
00:33:24 <flux__> I really don't mind having 'let rec'
00:33:35 <flux__> infact it's great when you want to search the source code for recursive functions :)
00:33:38 <Cale> pattern matching is also awkward
00:33:53 <lispy> if they revised the ocaml syntax to be closer to haskell and removed functors for type classes that would help
00:34:11 <flux__> well, there's already haskell, so why bother?
00:34:30 * Saulzar learned OCaml first, and found the +. disturbing
00:34:34 <flux__> actually there's a revised syntax for ocaml
00:34:35 <Cale> Well, the languages still wouldn't be the same
00:34:55 <flux__> but I don't care much of it..
00:34:56 <Cale> o'caml would still be a strict OO-functional language
00:35:08 <lispy> an eager version of haskell (keep everything else the same) would be interesting
00:35:23 <Saulzar> Right, Haskell is great because it forces you to stop thinking C++.
00:35:55 <Saulzar> Otherwise you get slack and it ends up as C++ in disguise
00:36:01 <Cale> I really think that laziness is important to functional programming though
00:36:29 <flux__> well, if there weren't the associated surprising space leaks..
00:36:44 <flux__> the opportunistically eager haskell would help with that I gather
00:36:47 <lispy> yeah, i think there are pros/cons to both lazy and eager
00:37:22 <lispy> i sometimes think it woul be better if the language gave the programmer the option of which they wanted to use when
00:37:44 * lispy has very weak seq-fu
00:38:00 <flux__> well, it would be better if the implementation just did the right thing, but in the mean time, that'd be nice too
00:38:01 * lispy goes to bed now tho, since it's late
00:38:05 <lispy> @localtime lispy
00:38:06 <lambdabot> Local time for lispy is Tue Jun 27 00:37:44 2006
00:38:06 <lambdabot> Local time for lispy is Tue Jun 27 00:37:44 2006
00:38:26 <Cale> @localtime Cale
00:38:27 <lambdabot> Local time for Cale is Tue Jun 27 03:38:07
00:38:33 <flux__> @localtime flux__
00:38:36 <lambdabot> Local time for flux__ is Tue Jun 27 10:38:14 2006
00:38:37 <flux__> off to work..
00:39:00 <dons> @seen sjanssen
00:39:00 <lambdabot> I saw sjanssen leaving #haskell 16 days, 4 hours, 36 minutes and 14 seconds ago, and .
00:45:24 <dons> ?yow
00:45:24 <lambdabot> YOW!!  Everybody out of the GENETIC POOL!
00:47:30 <shemale_magic> does haskell sclae up to programming in the large?
00:47:39 <shemale_magic> or does it become a mishmash of code?
00:47:48 <shemale_magic> as u scale and complexity grows?
00:54:18 <dons> as shown in last year's icfp, it scales better than most or all, due to encapsulation and abstraction techniques it provides, in the form of modules, monads and other type-based tricks. are you considering writing a large application?
00:55:02 <dons> laziness also plays a role in plumbing components, as does the lack of mutable state
00:55:18 <shemale_magic> hmm
00:55:21 <dons> you don't accidentally introduce bugs by using an interface incorrectly.
00:55:31 <shemale_magic> is haskell documented such that a rank beginner liek me can gain an understanding?
00:57:59 <dons> sure, checkout haskell.org
00:57:59 <dons> lots of tutorials, text books examles and so on.
00:57:59 <dons> ?url-on
00:57:59 <lambdabot> Url enabled
00:57:59 <dons> @seen dmhouse
00:57:59 <lambdabot> I saw dmhouse leaving #haskell 10 hours, 12 minutes and 49 seconds ago, and .
00:59:10 <shemale_magic> ok is haskell a type of lisp?
00:59:43 <jer> shemale_magic, no
00:59:57 <shemale_magic> so how do you use haskell tools to build large programs?
01:00:02 <dons> lisp doesn't have a type ;)
01:00:11 <dons> you just write haskell in lots of modules, and away you go
01:00:17 <shemale_magic> modules eh
01:00:21 <dons> lambdabot is 17k lines of haskell over 70 modules
01:00:21 <shemale_magic> whats a module?
01:00:24 <jer> shemale_magic, um.. i'm not sure i understand your question; what makes you think only lisps can be used to develop large programs?
01:00:34 <dons> ghc is some 90k lines of haskell
01:00:41 <jer> only 90k?
01:00:42 <jer> wow
01:00:51 <shemale_magic> no but I hear from an essay by E raymod that perl is shitty for large projects
01:00:52 <dons> there's a lot mor ein the libraries , of course
01:01:06 <shemale_magic> hence his liek of python
01:01:10 <jer> dons, right
01:01:12 <dons> shemale_magic: right. since it lacks abstraction.
01:01:48 <dons> and static typing. that's going to help avoid bugs creeping in as runtime errors in things like python.
01:02:02 <shemale_magic> ok so say I ftp files from some 50 remote servers now, and then read them inot mysql, then ftp back to an ohter 50 servers some info they read into thier informix db
01:02:03 <wilx> Abstraction? :)
01:02:04 <dons> anyway, shemale_magic, go read the howtos and tutorials :)
01:02:20 <jer> unit testing is your 'type checker' in dynamic languages =] most of the task has been offloaded to tests
01:02:22 <shemale_magic> this done in a wakky legacy java app and c++ perl apps helping
01:02:26 <shemale_magic> all on a timed schedule
01:02:27 <wilx> It supports procedural and OO programming. What else is there that you want?
01:02:44 <shemale_magic> and haskell is general purpose?
01:02:54 <jer> shemale_magic, yes
01:02:54 <dons> yes. read the first line of haskell.org :)
01:03:41 <shemale_magic> here is the big one: is it mroe prctical than say python?
01:03:58 <jer> shemale_magic, that's obviously going to yield a biased answer from most people in here
01:04:09 <shemale_magic> well try andbe unbiased
01:04:17 <shemale_magic> for one oment
01:04:18 <jer> shemale_magic, try and define "practical" for us then
01:04:35 <shemale_magic> I personally emailed paul graham the lisp guy today after reading about python in E raymonds essay
01:04:36 <dons> there are a wide range of practica programs written in haskell, doing all sorts of interesting things. i use it for most of my day-to-day tasks
01:04:41 <dons> so i think it is certainly practical
01:04:48 <shemale_magic> he metions ruby n python is u cant use lisp
01:04:55 <shemale_magic> if
01:04:55 <dons> i'm not sure what impractical would be for a general purpose language though.
01:05:04 <shemale_magic> ok
01:05:12 <shemale_magic> can I build a sales database with it?
01:05:31 <shemale_magic> can I build something that lets laptop users sync contacts and client dta over the net?
01:05:38 <jer> shemale_magic, yes and yes
01:05:44 <shemale_magic> brilliant
01:05:55 <shemale_magic> and can this thing be nice n fast?
01:05:56 <dons> "general purpose"
01:06:03 <dons> of course.
01:06:10 <jer> shemale_magic, relatively yes
01:06:23 <dons> its one of the fastest languages around. certainly faster than java or c++, often.
01:06:27 <shemale_magic> I currently use a shiity php mysql mess called www.sugarcrm.com
01:06:39 <shemale_magic> c++?
01:06:46 <shemale_magic> I thought haskell interpreted?
01:06:56 <jer> shemale_magic, it can be; it can also be compiled to native code
01:07:13 <shemale_magic> can modules in native code run along with regular mods?
01:07:20 <shemale_magic> woa
01:07:27 <jer> shemale_magic, i don't think you know what you're asking =]
01:07:31 <shemale_magic> heh
01:07:33 <shemale_magic> maybe not
01:07:37 <shemale_magic> but let me describe
01:07:45 <jer> perhaps you best read the first chapter in any beginners tutorial
01:07:45 <shemale_magic> bash uses sed awk ls etc
01:07:53 <jer> dons mentioned a few several minutes ago
01:07:56 <shemale_magic> it kinda uses fast c code progrms
01:07:59 <dons> yeah, i think you should start playing with the tutorials first.
01:08:10 <shemale_magic> okok
01:08:21 <shemale_magic> but you find haskell a pleasure to use all around?
01:08:30 <shemale_magic> are you wealthy concultants?
01:08:43 <shemale_magic> I wish to learn progrmaming in order to consult and build better apps for clents
01:08:45 <dons> we are all wealthy haskell consultants.
01:08:54 <dons> that's a worthy goal.
01:09:22 * jer is still learning the language myself; i come from 16 years of smalltalk experience, so adapting to haskell has been proving troublesome (but i don't pretend that i can pick up languages which are significantly different to what i'm used too very easily)
01:10:35 <shemale_magic> holy shit i just doenloaded squeak yesterdy
01:10:50 <shemale_magic> im such a moron i couldnt close the intro
01:11:00 <shemale_magic> once i maximized it
01:11:09 <shemale_magic> had to invoke this halo thing
01:11:15 <shemale_magic> kinda cool tho
01:11:35 <shemale_magic> why haskell over smalltalk?
01:11:37 * jer doesn't use squeak
01:11:40 <shemale_magic> I thought smalltalked rocked
01:11:59 <shemale_magic> I had one guy tell me he was 16x as fast to develop something in smalltalk
01:12:02 <shemale_magic> as .net
01:12:05 <jer> shemale_magic, i use many languages regularly; and i've only written off a couple of languages in my close to 20 years =]
01:12:30 <shemale_magic> gnusmalltalk?
01:12:37 <shemale_magic> cincom?
01:12:39 <jer> i use visualworks myself
01:12:59 <jer> anyway, it's getting late
01:14:23 <shemale_magic> check otu squeak
01:14:26 <shemale_magic> seems dope
01:14:36 <jer> i have, i don't much like it
01:14:41 <shemale_magic> why
01:14:50 <jer> i don't like the interface
01:14:57 <shemale_magic> gnu smaltalk claims to be more hacker oriented
01:15:00 <shemale_magic> oh?
01:15:09 <shemale_magic> have you tried seaside?
01:15:14 <jer> (granted, i've yet to find a smalltalk environment which i truly enjoy)
01:15:19 <jer> shemale_magic, i odn't do web stuff
01:15:32 <shemale_magic> oh jeez then what do ya do
01:15:42 <jer> i work mostly in the medical field
01:16:40 <jer> anyhow, it's late, i'm going to sleep now.. g'nite
01:22:18 <bringert> I wonder how shapr's move is going
01:40:27 <roconnor> Is there going to be a #haskell get-together in Amsterdam in June?
01:42:42 <Muad_Dibber> have to hurry then roconnor , June is almost over :)
01:43:46 <roconnor> Must be on Friday ;)
01:47:04 <roconnor> I wonder how many people can make it to Amsterdam?
01:47:25 <dblhelix> roconnor: no prob :)
01:49:16 <roconnor> okay that's 2 people.
01:49:56 <roconnor> maybe one ought to post a meet-up at that meet-up.com or .org thing for some date in July
02:18:51 <_frederik_> hi guys
02:20:38 <_frederik_> what kind of haskell98 extensions are supported by compilers other than ghc?
02:20:50 <dons> ffi, hier modules, mptcs
02:20:59 <dons> let me find the list
02:22:01 <_frederik_> also, i guess it's not possible to compile a package with one compiler and use it with another, is it
02:22:16 <dons> no, definitely not
02:22:16 <dons> diferent runtimes, as w
02:23:00 <_frederik_> shouldn't there be way to compile to a standardized intermediate byte-code?
02:23:41 <_frederik_> maybe not "byte-code", i'm sure there's a name for it though
02:23:52 <dons> here's the list: C[C[C[C[C[C[Chttp://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
02:23:55 <lambdabot> Title: "HaskellExtensions - Haskell Prime - Trac"
02:24:15 <_frederik_> cool, thanks
02:24:39 <_frederik_> what did lambdabot just do?
02:24:54 <dons> it looked up the title for us.
02:25:56 <dons> ?where+ haskellexts http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
02:25:56 <lambdabot> Done.
02:26:17 <dons> mostly you'll care about supporting hugs and ghc, if you're using lots of extensions
02:26:43 <roconnor> ugh, someone ought to replace that True / False matrix with nice icons.
02:26:50 <_frederik_> (where does the title come from? the page? what kind of pages does it work with?)
02:27:01 <dons> http
02:27:25 <dons> source is in the lambdabot Url.hs plugin
02:27:28 <dons> ?versoin
02:27:28 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
02:27:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:28:24 <_frederik_> oh ok
02:28:58 <_frederik_> anyway what's the intermediate language called where classes have been turned into dictionaries and so forth called?
02:29:05 <_frederik_> s/called//
02:29:33 <dons> Core?
02:29:35 <eivuokko> Ghc calls it core, there dictionaries are explicit.
02:31:38 <_frederik_> that's probably it
02:31:56 <_frederik_> so core is not something which can be standardized?
02:32:05 <_frederik_> does it change much? does it vary between compilers?
02:33:14 <dons> yeah, the intermediate language doe vary between compilers. though there's been some effort to try to make hugs and ghc share a common intermediate language, and jhc wants to use core too, there's not a lot of demand.
02:34:55 <_frederik_> hrmph. so it's not like they have to actually *use* the same intermediate language, right, as long as they could all accept say GHC's core as input?
02:35:11 <eivuokko> Accept or produce?
02:35:34 <_frederik_> perhaps there are other ways of looking at it, but i meant "accept"
02:35:46 <eivuokko> What happens to, say, existentials in core?
02:36:27 <_frederik_> is that a rhetorical question, or a tangent?
02:36:33 <_frederik_> because i don't know the answer
02:37:02 <eivuokko> I'm just curious.  I am not deeply knowledgeable about core.
02:37:07 <_frederik_> ok.
02:38:40 <_frederik_> so some compilers try to have a good runtime; others try to support interesting language extensions, or give better type errors. and it just strikes me as very bad that these two practically orthogonal efforts are being coupled
02:39:42 <_frederik_> i sort of assumed that standardizing the core wasn't possible because of theoretical issues unknown to me. but if that's not the case...
02:46:17 <Pawer> this channel rocks
02:47:16 <sieni> http://floatingsignifier.boudist.com/archives/you%20rock%20you%20rule.jpg
03:35:05 <jberg> if have two ints 3 4 how can i convert that to "3 4"
03:41:39 <eivuokko> Use show, and (++)
03:41:44 <eivuokko> @type show
03:41:45 <lambdabot> forall a. (Show a) => a -> String
03:41:49 <eivuokko> @type (++)
03:41:51 <lambdabot> forall a. [a] -> [a] -> [a]
03:42:19 <eivuokko> For general case of list, you might want Data.List.intersperse.
03:43:12 <Cale> > concat . intersperse " " . map show $ [3,4,5,6]
03:43:14 <lambdabot>  "3 4 5 6"
03:50:36 <jberg> thanks thats neat :)
03:52:19 <xerox> > [3,4,5,6] >>= (++ " ") . show
03:52:21 <lambdabot>  "3 4 5 6 "
03:52:28 <xerox> Hm :)
04:09:26 <amiddelk> xerox: you add a space too much :)
04:22:05 <reppie> > concat $ intersperse " " $ map show [3,4,5,6]
04:22:06 <lambdabot>  "3 4 5 6"
04:22:20 <reppie> oh oops, i should have scrolled up
04:23:36 <vincenz> reppie: easier :
04:23:44 <vincenz> > unwords $ map show [3..6]
04:23:46 <lambdabot>  "3 4 5 6"
04:33:08 <jberg> hmm ghci can't find chr in scope and on "import Char" it says parse error on import
04:34:18 <jberg> > chr 97
04:34:20 <lambdabot>  'a'
04:34:44 <nibro> in ghci, say ":m Data.Char"
04:34:58 <nibro> ... instead of import
04:35:55 <jberg> ok, thanks
04:36:06 <Igloo> :m + Data.Char   to add it to the list of modules in scope rather than overwriting it
05:14:25 <roconnor> @hoogle m (a -> b) -> a -> m b
05:14:26 <lambdabot> Prelude.asTypeOf :: a -> a -> a
05:14:27 <lambdabot> Prelude.const :: a -> b -> a
05:14:27 <lambdabot> Prelude.seq :: a -> b -> b
05:14:36 <roconnor> @hoogle m (a -> b) -> m a -> m b
05:14:37 <lambdabot> Prelude.asTypeOf :: a -> a -> a
05:14:38 <lambdabot> Prelude.const :: a -> b -> a
05:14:38 <lambdabot> Prelude.seq :: a -> b -> b
05:14:49 <roconnor> :type Control.Monad.ap
05:14:54 <roconnor> @type Control.Monad.ap
05:14:55 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
05:15:52 <roconnor> @doc Control.Monad
05:15:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
05:16:52 <roconnor> @djinn Monad m => m (a -> b) -> m a -> m b
05:16:52 <lambdabot> Cannot parse command
05:17:15 <roconnor> @djinn Maybe (a -> b) -> Maybe a -> Maybe b
05:17:16 <lambdabot> f a b =
05:17:16 <lambdabot>   case a of
05:17:16 <lambdabot>   Nothing -> Nothing
05:17:16 <lambdabot>   Just c -> case b of
05:17:16 <lambdabot>        Nothing -> Nothing
05:17:18 <lambdabot>        Just d -> Just (c d)
05:18:11 <roconnor> @type \x y -> do { f<- x; return (f y)}
05:18:12 <lambdabot> forall (m :: * -> *) a t. (Monad m) => m (t -> a) -> t -> m a
05:18:37 <roconnor> @type \x y -> x >>= return (f y)}
05:18:38 <lambdabot> parse error on input `}'
05:18:38 <roconnor> @type \x y -> x >>= return (f y)
05:18:40 <lambdabot> Not in scope: `f'
05:18:47 <roconnor> @type \x y -> x >>= \f -> return (f y)
05:18:48 <lambdabot> forall (m :: * -> *) a t. (Monad m) => m (t -> a) -> t -> m a
05:19:56 <roconnor> @pl \x y -> x >>= \f -> return (f y)
05:19:57 <lambdabot> flip (fmap . flip id)
05:21:40 <roconnor> @type flip (fmap . flip id)
05:21:41 <lambdabot> forall (f :: * -> *) c a. (Functor f) => f (a -> c) -> a -> f c
05:21:56 <roconnor> interesting, bind isn't needed
05:22:24 <roconnor> @type \x y -> x >>= \f -> y >>= \a -> return (f a)
05:22:25 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => m (a -> a1) -> m a -> m a1
05:22:47 <roconnor> @pl \x y -> x >>= \f -> y >>= \a -> return (f a)
05:22:48 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
05:23:18 <roconnor> ugh
05:23:57 <int-e> @type (>>=)
05:23:58 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
05:24:31 <int-e> @type flip (>>=)
05:24:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
05:25:09 <int-e> @type \f x -> join (fmap f x)
05:25:11 <lambdabot> forall (f :: * -> *) a a1. (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
05:26:03 <roconnor> @type flip id
05:26:04 <lambdabot> forall b c. b -> (b -> c) -> c
05:26:21 <int-e> roconnor: what you have wasn't a bind
05:26:43 <roconnor> isn't (>>=) bind?
05:26:53 <int-e> yes
05:27:11 <roconnor> so,  \x y -> x >>= \f -> return (f y) can be expressed without bind.
05:28:57 <roconnor> which is nice, because in my monad, map is more efficent than bind/join.
05:32:02 <roconnor> great, someone removed the monad laws from the wikipedia article.
05:32:06 * roconnor frowns
05:33:02 <int-e> roconnor: ok. I misunderstood what you were trying to say.
05:33:27 <Cale> roconnor: they seem to be there...
05:33:28 <roconnor> :)
05:34:13 <roconnor> Cale, which section?
05:34:29 <Cale> "Definition"
05:34:33 <roconnor> oh I see
05:34:46 <Cale> you're referring to the "Monads in functional programming" article right?
05:34:52 <roconnor> I was looking for the map/join/return laws.
05:35:09 <roconnor> but the article is all in terms of bind/return now
05:35:12 <int-e> "For a monad to behave correctly, the definitions must obey a few rules."
05:35:14 <Cale> http://en.wikipedia.org/wiki/Monad_%28category_theory%29 :)
05:35:38 <int-e> bind and return seem to be more meaningful when you think in terms of computations
05:35:55 <int-e> a computation that returns a computation is somewhat awkward to work with for most people
05:36:00 <roconnor> Unfortnately I'm not thinking in terms of computation at the moment ;)
05:36:15 <int-e> but that's what join does: execute such a computation, and then execute the resulting computation
05:38:11 <int-e> The other reason that I see is that you get the functor map for free when you have return and bind; join and return don't do that I believe.
05:39:01 <Cale> Well, with the join and return definition, you're expected to start with a functor
05:39:08 <glauber_sp> hi guys. I know this is not a latex channel, but I need to write the fixed point theorem definition and I don't know how to break the fist line of a theorem definition. any suggestion?
05:39:15 <int-e> Cale: I know :)
05:59:02 <s1> morning all
06:06:21 <sm> is ghc's -W flag on by default ?
06:06:38 * sm warms up with an easy one
06:07:52 <norpan> no, -W gives you additional warnings
06:07:56 <sm> ah, thx
06:08:06 <norpan> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html
06:08:08 <lambdabot> Title: "4.7. Warnings and sanity-checking"
06:13:44 <sm> while learning, I think it's best to frequently re-compile as I make changes, as most of my code declarations can't easily be tested at the interactive prompt - am I right ?
06:18:10 <norpan> well, the interpreter loads files without you having to compile them, but maybe you mean reload?
06:19:15 <norpan> in that case, yes it seems best
06:19:54 <sm> to get feedback on what works and what doesn't I mean - syntax, type declarations etc.
06:20:28 <norpan> yes
06:20:38 <norpan> just change your file and :r in ghci
06:20:46 <sm> at first I tried to to paste things into the interactive prompt, python style, but it seems not the way for haskell
06:21:14 <norpan> no, it's better to work with a file
06:21:42 <Dino_> Some things can't be done interactively, right? Like data declarations.
06:21:54 <Dino_> datatype
06:21:59 <sm> right.. most of the stuff I'm having trouble with
06:22:07 <norpan> the interactive prompt is almost like a do block
06:22:23 <Dino_> I thought I read somebody say that it actually is in fact a do block.
06:22:30 <sm> I've found nice emacs keybindings to reload in ghci and jump to errors
06:22:31 <norpan> except that it will prepend print to anything not IO
06:22:39 <Dino_> ah ha
06:22:57 <norpan> and it lets you do some other stuff like :t
06:23:37 <sm> that helps, thanks
06:25:41 <sm> I wonder if I could select just part of my source and compile only that, like an emacs scratch buffer..
06:25:48 * sm looks
06:29:39 <dons> oh, really nice mail on haskell@haskell.org  about our great performance in the language shootout :)
06:30:15 <neologism> url?
06:30:53 <dons> looking ...
06:31:57 * sm turns on compilation-minor-mode in *ghci* buffer
06:32:41 <dons> http://article.gmane.org/gmane.comp.lang.haskell.general/13857
06:32:44 <lambdabot> Title: "Gmane -- Mail To News And Back Again"
06:35:13 <vegai> yeah, there has been some nice hackery in the shootout
06:36:33 <dons> we put in many hours in Jan-Feb here in this channel, so much so that in Feb we had: http://www.cse.unsw.edu.au/~dons/data/haskell_1.html
06:36:34 <lambdabot> Title: "Create your own Overall Scores | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..."
06:36:59 <vegai> dons: I don't think he's correct in giving ghc the credit there
06:37:46 <dons> well, there's been back end work that made it even possible to write the code we did. ghc still has to compile it to something fast, right?
06:37:47 <vegai> *all* the credit, that is
06:38:01 <dons> sure. much of it is the particular entry's tricks
06:38:07 <vegai> yeah..
06:40:07 <dons> of course, we all code fast haskell every day, but its still a surprise to some, thinking back to the days of hugs and mysterious space leaks
06:46:02 <roconnor> don't we still have mysterious space leaks?
06:46:20 <dons> well, they're not mysterious anymore. we use -prof and all is good.
06:46:25 <roconnor> ;)
06:46:42 <dons> this still amazes me: http://shootout.alioth.debian.org/debian/benchmark.php?test=nsieve&lang=all
06:46:44 <lambdabot> Title: "nsieve benchmark | Debian : AMD&#8482; Sempron&#8482; Computer Language Shootout"
06:47:07 <dons> that's ghc really doing its stuff there.
06:47:31 <dons> nothing uber-magic
06:52:17 * dons -> night and haskell dreams
06:52:19 <roconnor> unsafeWrite!!
06:52:30 <roconnor> booo
06:52:36 <dons> oh, that's essential if you're already doing your own bounds checks
06:52:47 <dons> its not like it breaks type safety or anything.
06:53:13 <dons> just means you have to supply your own proof that you're in bounds -- which is almost always the case
06:53:17 <roconnor> oh, it is only unsafe in the bounds checking thing?
06:53:27 <dons> you won't get an exception thrown when you wander over the bounds
06:53:29 <malcolm> Is there bounds-checking in FPS?
06:53:29 <lambdabot> malcolm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:53:36 <dons> malcolm: yep
06:53:38 <roconnor> when we have dependent types, we will be able to supply the proof and have it checked.
06:53:46 <dons> except for unsafeHead,unsafeTail and unsafeIndex
06:53:52 <dons> which are equiv to the array versions
06:53:57 <roconnor> > unsafeHead []
06:53:58 <lambdabot>  Not in scope: `unsafeHead'
06:53:59 <malcolm> dons: and can I turn it off to get an unsafeIndex operation?
06:54:00 <Igloo> You could equally argue that all type-checking isn't unsafe, you just have to prove it correct yourself
06:54:21 <dons> malcolm: no, you have to ask for the unsafe versions explicitly
06:54:28 <roconnor> @hoogle unsafeHead
06:54:29 <lambdabot> No matches found
06:54:31 <dons> in Data.ByteString.Base, as with arrays
06:54:45 <dons> ?type Data.ByteString.Base.unsafeHead
06:54:47 <lambdabot> Data.ByteString.Base.ByteString -> Word8
06:54:51 * malcolm had not noticed the unsafeIndex before - could be very useful
06:55:17 <roconnor> :hoogle Data.ByteString.Base.ByteString
06:55:23 <roconnor> @hoogle Data.ByteString.Base.ByteString
06:55:24 <lambdabot> No matches, try a more general search
06:55:40 <dons> its not imported into hoogle's db yet
06:55:58 <dons> ?type Data.ByteString.Base.unsafeIndex
06:55:59 <lambdabot> Data.ByteString.Base.ByteString -> Int -> Word8
06:56:15 <dons> (i.e. just a peek)
06:56:23 * malcolm bets that will make his benchmark run a lot faster
06:57:22 <malcolm> unsafeIndex: not in scope.  Bah!
06:58:12 <dons> its not in Data.ByteString.Base ?
06:58:33 <dons> I moved it from Data.ByteString to .Base a few weeks ago
06:59:41 <Itkovian> hmm, on PowerPC/MacOSX, that sieve is not much faster when compiler with the options given on the shooutout page and no optimizations
07:00:06 <Itkovian> 3.4 seconds user time in either case
07:00:13 <Itkovian> little less real time
07:00:46 <malcolm> Yes, it is in D.BS.Base, but I was looking for it in D.BS
07:00:52 <jberg> convertToAscii :: [[(Int, Int, Int)]] -> String convertToAscii colours = concat (map (map (\(r, g, b) -> (chr r, chr g, chr b))) colours
07:01:02 <jberg> says it can't match Char to (a, b, c)
07:01:07 <jberg> what does that mean?
07:01:48 <dons> Itkovian: it could be arch specific. we noticed biggest speed ups on x86
07:01:50 <dons> doh. gone
07:01:54 * dons goes too
07:02:33 <amiddelk> I compiled my program with GHC 6.4.2 for profiling and when I run the program with +RTS -px -RTS it aborts with a glibc double free warning. The residual .prof file that it generates also doesn't seem like XML to me. Do I need to use a newer version of GHC to use the fancy profiling tool?
07:02:37 <df_> dons :: is lambdabot http/1.1 compliant? http://davidf.woaf.net/lamdabot-http1.1-compliance.html
07:02:39 <lambdabot> Title: "lambdabot is http/1.1 compliant"
07:02:50 <roconnor> @type concat (map (map (\(r, g, b) -> (chr r, chr g, chr b)))
07:02:51 <lambdabot> parse error (possibly incorrect indentation)
07:02:55 <roconnor> @type concat (map (map (\(r, g, b) -> (chr r, chr g, chr b))
07:02:56 <lambdabot> parse error (possibly incorrect indentation)
07:03:03 <roconnor> @type concat (map (map (\(r, g, b) -> (chr r, chr g, chr b))))
07:03:04 <lambdabot>   Expecting a function type, but found `[[a]]'
07:03:04 <lambdabot>    Expected type: [[a]]
07:03:58 <roconnor> @type \colours -> concat (map (map (\(r, g, b) -> (chr r, chr g, chr b))) colours)
07:04:00 <lambdabot> [[(Int, Int, Int)]] -> [(Char, Char, Char)]
07:04:17 <roconnor> of course
07:04:41 <roconnor> jberg: you are outputing a list of triples of chars, not a list of chars.
07:04:52 <roconnor> hence the chars don't match with the triple.
07:05:24 <waern> JaffaCake: ping?
07:05:32 <JaffaCake> opng
07:05:41 <JaffaCake> er, pong
07:05:45 <waern> hi!
07:05:53 <JaffaCake> hi there :)
07:06:32 <waern> JaffaCake, hmmh I'm currently doing some thinking 
07:06:56 <JaffaCake> oh?
07:08:09 <waern> JaffaCake, should we have a separate type environment that contains documentation?
07:08:28 <waern> JaffaCake, or should the typechecking phase include the documentation in the type env?
07:08:34 <JaffaCake> good questions
07:08:56 <JaffaCake> I assume we don't want to put documentation in .hi files
07:09:38 <waern> we don't? :)
07:09:42 <JaffaCake> in a sense it could be useful, but Haddock doens't do this currently
07:09:47 <malcolm> JaffaCake: on compiling via C, I recall SPJ giving an invited talk at ICFP/PPDP in Paris in 1999 about c--, and how great it was going to be.  That's nearly 7 years now, and we still all compiler via C.
07:09:56 <waern> JaffaCake, ah, okay
07:10:26 <JaffaCake> malcolm: yes, it's taking a while to get shot of -fvia-C
07:10:41 <JaffaCake> C-- is making slow progress too
07:11:09 <JaffaCake> waern: so yes, we don't need to elaborate ModIface, but we will need to elaborate ModDetails I think
07:11:26 <waern> JaffaCake, right
07:12:44 * JaffaCake peers at the source code
07:18:12 <JaffaCake> waern: I'm thinking we should use GHC.checkModule as the interface to GHC
07:18:42 <JaffaCake> you get back the typecheckedSource, which is renamed + typechecked HsSyn
07:18:52 <JaffaCake> complete with documentation annotations
07:19:14 <JaffaCake> then we probably don't need to elaborate ModDetails at all
07:19:36 <JaffaCake> sound plausible?
07:21:16 <waern> hmm yeah
07:23:58 <JaffaCake> waern: actually it's possible the renamedSource is more useful, because it has the type declarations 
07:24:40 <JaffaCake> we will need to consult the results of typechecking only for finding the types of things that have no signatures, and for finding the types of derived instances
07:25:46 <waern> yeah.. and the renaming to "preferred export names" can be done after that?
07:26:01 <JaffaCake> right. given the renamed HsSyn from GHC, you then need to implement the equivalent of mkInterfacePhase2 from Haddock
07:26:13 <JaffaCake> it has changed a bit since the paper, BTW
07:27:12 <waern> hmm.. that code should still belong in Haddock, shouldn't it? 
07:27:24 <waern> even though it's easier to do it in GHC I guess
07:27:44 <JaffaCake> it should still be a part of Haddock, I think
07:28:01 <JaffaCake> Haddock calls the GHC API, everything above the GHC API is part of Haddock
07:28:11 <waern> yeah.. 
07:34:49 <sm> would anyone know where is docs for inf-haskell.el
07:34:50 <sm> ?
07:36:56 <roconnor> @docs inf-haskell.el
07:36:56 <lambdabot> inf-haskell.el not available
07:38:03 <sm> it's the inferior mode that comes with emacs haskell-mode, sounds to be newer than haskell-ghci
07:39:44 <Cale> sm: I always just run ghci in another terminal, so I have no idea how that works
07:40:04 <Cale> (but running it in another terminal works quite well :)
07:40:40 <sm> I see no jumping-to-error functionality, so I guess I'll stick with haskell-ghci-*
07:40:46 <sm> that's *almost* working really well
07:41:43 <sm> I'm trying to arrange the optimum quick feedback setup
07:42:16 <sm> I wonder if hugs would give me better beginner errors, though ?
07:43:58 <sjanssen> sm: it depends on the error, sometimes GHC is more clear, sometimes Hugs is
07:43:59 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
07:44:18 <sm> good to know.. I'll use both while learning
07:44:33 <sjanssen> sm: hugs has the advantage of shorter load times
07:49:00 * SamB is happy to be off of dialup
07:49:26 <sm> shouldn't hugs -P:/usr/local/lib/HAppS-0.8.1/HAppS  allow me to import HAppS stuff ? HAppS.hi & subdirs are in that directory 
07:49:51 <sm> still getting Can't find imported module "HAppS.DBMS.RSMap"
07:51:32 <sm> well, I'll come back to that
07:53:30 <Lemmih> @seen bringert
07:53:30 <lambdabot> I saw bringert leaving #haskell.se and #haskell 6 hours, 28 minutes and 58 seconds ago, and .
08:14:27 <vincenz> j #oasis
08:16:47 <mathias> Anyone using pretty lambda in Emacs on *nix? If so, what font do you use? http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda#toc0
08:16:49 <lambdabot> Title: "EmacsWiki: PrettyLambda"
08:17:18 <sm> how do I construct a new empty RSMap ?
08:19:56 * vincenz sighs over the c++
08:20:18 <madpickle> mathias: any unicode font would do
08:20:37 <mathias> madpickle: How do I know whether some font is a unicode font without trying them all?
08:20:56 <madpickle> not sure about unix, but most fonts (Tahoma, Arial, Verdana, etc.) are unicode in modern windows
08:21:37 <Cale> Andale Mono
08:22:12 <Cale> You can download the MS Truetype core fonts and install them under X too.
08:22:22 <madpickle> aye
08:22:26 <madpickle> good idea, actually
08:22:28 <madpickle> they are nice fonts
08:22:37 <madpickle> or you could go hunting for the new vista fonts. sexy!
08:23:42 <cjay> ms designed a new font especially for coding, I don't remember the name
08:24:14 <madpickle> there's lots of those
08:24:19 <Cale> That would be Andale Mono
08:24:20 <madpickle> Bit Sans vera Mono
08:24:23 <madpickle> Andale
08:24:25 <madpickle> yeah
08:24:31 <madpickle> i had a great website with a list of coding fonts
08:24:54 <madpickle> see if i can find 'em
08:24:56 <Cale> Though I'm not sure if that was really MS that created that font
08:25:01 <Cale> I think MS just bought it
08:25:05 <madpickle> http://www.lowing.org/fonts/
08:25:06 <madpickle> there
08:25:06 <cjay> my primary terminal font is vera mono
08:25:07 <lambdabot> Title: "Monospace/Fixed Width Programmer's Fonts"
08:25:21 <madpickle> that site has 'em all available for download
08:25:35 <madpickle> i like ProggyClean too
08:27:46 <cjay> ah, consolas was the one I meant
08:28:20 <madpickle> yeah, that's what I use in Delphi, actually, too.
08:28:31 <madpickle> but anywho, that site has some nice free ones.
08:28:31 <mathias> Let me ask a very specific question: what font specified in this form: -monotype-arial-medium-r-normal--0-0-0-0-p-0-microsoft-ansi supports pretty lambda's? I have tons of fonts (including those from Windows since I dual boot), I just have no idea which one to use. 
08:28:45 <madpickle> pick one and find out
08:30:22 <Cale> It's annoying that emacs doesn't use Freetype 2
08:31:09 <Cale> Since then it wouldn't matter which font you picked, you'd just get a close one with that character in it.
08:31:37 <lantis> hai, can I use htoolkit.sf.net's hsql-sqlite to convert from a hsql-database to a sqlite-database file?
08:34:16 <sm> Cale: doesn't emacs-gtk ?
08:35:23 <Cale> sm: Possibly, though I thought it just used gtk for the other parts of the interface
08:36:10 <dmhouse> Cale, it uses GTK for all bits of the interface. Scrollbars, menu, context menu, etc.
08:36:33 <Cale> dmhouse: but not the editor itself?
08:36:51 <dmhouse> What do you mean, 'the editor itself'? Which bits?
08:37:09 <sm> why does the enter key stop working in haskell-mode ?
08:37:19 <dmhouse> You can't use XFT fonts in emacs-gtk, if that's what you mean.
08:37:24 <sm> I do not like this feature
08:37:29 <dmhouse> (Unless you use emacs-gtk-xft, which I do.)
08:37:33 <dmhouse> sm, it does?
08:37:38 <dmhouse> sm, works perfectly for me.
08:37:45 <sm> after a while, yes
08:37:51 <sm> strange
08:37:54 <dmhouse> After a while?
08:38:24 <sm> yes, after a while enter stops working and I have to reload the file
08:38:52 <sm> dmhouse: interesting
08:39:01 <sm> (about emacs-gtk-xft)
08:39:50 <jgrimes_> sm: make sure you didn't change the mode from Haskell mode to one of the Haskell GHCi or Haskell Hugs modes
08:40:07 <jgrimes_> jgrimes_: for the file buffer
08:40:22 <jgrimes_> ... didn't really mean to tell myself that.
08:40:24 <sm> I did turn-on-haskell-ghci
08:41:16 <Cale> dmhouse: is that available as a package?
08:41:18 <sm> I'll check the mode next time it happens..
08:41:36 <Cale> Or do I have to patch the source and compile stuff?
08:42:00 <xerox> Cale, on freedesktop.org there is a guy who does .deb of emacs-xft
08:42:25 <ihope> So what would one call Haskell's type system, minus the typeclasses?
08:43:20 <Cale> ihope: Damas-Milner?
08:43:44 <ptolomy> say, why is "do a <- getLine; b <- getLine; return $ (read a) + (read b)" IO Integer? Is it just because I'm not actually using the result, so it just picks integer until I make use of it outisde the toplevel?
08:43:50 <Cale> Or Hindley-Milner
08:43:58 <dmhouse> Cale, it's available as a package from certain sources.
08:44:01 <Cale> which are the same thing :)
08:44:26 <dmhouse> ptolomy: Nope. You must be constraining the type somewhere.
08:44:33 <Cale> ptolomy: because do-expressions define monadic actions
08:44:40 <dmhouse> Cale, he was refering to the Integer part.
08:44:46 <Cale> dmhouse: ah
08:44:52 <Cale> that's defaulting
08:44:57 <ihope> So I could have a combinator calculus with a Hindley-Milner type system?
08:44:58 <dmhouse> Really?
08:45:15 <Cale> probably
08:45:21 <dmhouse> @type readLine
08:45:22 <ptolomy> interesting. thought so.
08:45:24 <ptolomy> Thanks!
08:45:26 <lambdabot> Not in scope: `readLine'
08:45:30 <ptolomy> @type getLine
08:45:30 <Cale> If nothing else constrains the type
08:45:32 <madpickle> hindley? we used to call him Dr. Shipman
08:45:32 <lambdabot> IO String
08:45:32 <ihope> Would that me the right terminology, I mean?
08:45:37 <dmhouse> ptolomy: I still think it's more likely you're constraining the type somewhere.
08:45:41 <dmhouse> @type readLn
08:45:42 <lambdabot> forall a. (Read a) => IO a
08:45:53 <dmhouse> ptolomy: Anyway, that may be of use to you.
08:46:05 <Cale> Probably it's just the MR and defaulting
08:46:11 <dmhouse> do a <- readLn; b <- readLn; return (a + b)
08:46:12 <sjanssen> @type fmap (+1) readLn
08:46:13 <lambdabot> forall a. (Num a, Read a) => IO a
08:46:17 <ihope> Well, what do you mean by "if nothing else constrains the type"?
08:46:18 <dmhouse> or liftM2 (+) readLn readLn
08:46:27 <ptolomy> dmhouse: I'm pretty certain I'm not constraining the type anywhere else.
08:46:34 <Cale> join (liftM2 (+)) readLn
08:46:36 <dmhouse> ptolomy: want to pastebin? :)
08:46:41 <Cale> heh
08:46:45 <dmhouse> Cale, I was thinking that too :)
08:46:47 <ptolomy> heh. it'd be pretty much the same as what I typed.
08:46:51 <ptolomy> that was literally all I was doing.
08:47:00 <dmhouse> @type liftM2 (+) readLn readLn
08:47:01 <lambdabot> forall a. (Num a, Read a) => IO a
08:47:15 <ptolomy> I was making the equivalent of some "see how good python is for teaching programming!" program I saw online that asks for two numbers and adds them.
08:47:17 <dmhouse> @type do a <- getLine; b <- getLine; return (read a + read b)
08:47:19 <lambdabot> forall a. (Num a, Read a) => IO a
08:47:24 <dmhouse> ptolomy: really?
08:47:35 <sm> jgrimes: exactly right.. my script had turned on compilation-minor-mode in the wrong buffer, thx
08:47:39 <ptolomy> I just noted that when isolated, it defaulted to Integer, and found that curious.
08:48:01 <ptolomy> dmhouse: yep.
08:48:08 <Cale> ptolomy: yeah, probably due to the monomorphism restriction -- unless you give it an explicit type signature
08:48:10 <mathias> How do I map a file foo.ttf to a name which is outputted by xlsfonts?
08:48:25 <dmhouse> Prelude> :t do a <- getLine; b <- getLine; return (read a + read b)
08:48:31 <dmhouse> (Num a, Read a) => IO a
08:48:44 <dmhouse> (Not a direct paste, I removed some cruft.)
08:48:46 <jgrimes_> sm: no problem, :)
08:48:49 <xerox> dmhouse: try to use it, and see the type of the result
08:48:57 <Cale> dmhouse: pattern bind that in a file and load it
08:49:05 <Cale> like
08:49:12 <Cale> myAction = do a <- getLine; b <- getLine; return (read a + read b)
08:49:36 <dmhouse> Ah, I see now.
08:49:37 <xerox> Even just `foo <- do { ... }' imo.
08:49:44 <xerox> (In the GHCi prompt.)
08:50:02 <Cale> oh, if you do that, then it's lambda-bound
08:50:07 <Cale> and again, monomorphic
08:50:10 <dmhouse> What weird behaviour.
08:50:21 <Cale> lambda-binding is always monomorphic
08:50:33 <dmhouse> Why Integer? What if you have a typeclass with no instances?
08:50:54 <sjanssen> dmhouse: this will only work with a few built in classes/types
08:50:55 <Cale> Integer because of the numeric defaulting mechanism
08:51:01 <Cale> it's a special case
08:51:48 <Cale> http://haskell.org/onlinereport/decls.html#sect4.3.4
08:51:49 <lambdabot> Title: "The Haskell 98 Report: Declarations"
08:51:59 <sm> Not in scope: data constructor `String' - shouldn't I have that, as part of the Prelude ?
08:52:06 <sm> at the top level
08:52:12 <Cale> sm: It's not a data constructor
08:52:15 <Cale> It's a type
08:52:15 <Lemmih> sm: String isn't a data constructor.
08:52:16 <dmhouse> sm, no, because String isn't a _data_ constructor.
08:52:17 <sjanssen> woah, that's a neat new lambdabot feature
08:52:21 <sm> urgh urgh urgh
08:52:24 <dmhouse> Why are lambda-bindings monomorphic? Simplicity?
08:52:24 <sjanssen> http://www.google.com
08:52:25 <lambdabot> Title: "Google"
08:52:41 <dmhouse> sjanssen: it even does it http://inline.com
08:52:43 <lambdabot> Title: "InLine | Voice, Data &amp; Networking for Business"
08:52:54 <sm> ok.. what I'm trying to do is construct a Map, say like Map String String
08:52:59 <petekaz> lambdabot is awesome :-)
08:53:15 <ihope> http://www.burble.com/blah/pumble/pickles.html
08:53:21 <ihope> :-P
08:53:34 <Cale> dmhouse: just because of the way the type system assigns types to functions
08:53:38 <ihope> So... I dunno. I feel weird saying that this language has a Hindley-Milner type system.
08:53:48 * sm checks Map docs
08:53:57 <Cale> ihope: why?
08:54:09 <sjanssen> @type "http://www.haskell.org"
08:54:11 <lambdabot> [Char]
08:54:24 <ihope> "http://www.haskell.org"
08:54:26 <lambdabot> Title: "Haskell - HaskellWiki"
08:54:48 <Cale> It's just HM with typeclasses, higher-rank types, existentially quantified types and half a dozen other extensions :)
08:55:39 <sm> no good.. if someone would take pity on me and show me how to construct a Map, I'd be grateful
08:55:54 <ihope> So something like "Foo Integer -> (a -> Foo a) -> Foo a -> Foo a" is a valid HM type?
08:55:54 <dmhouse> sm, you want to create an empty map?
08:55:57 <norpan> @doc Data.Map
08:55:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
08:56:02 <dmhouse> @hoogle empty
08:56:03 <sm> yes I do
08:56:04 <lambdabot> Data.IntMap.empty :: IntMap a
08:56:04 <lambdabot> Data.IntSet.empty :: IntSet
08:56:04 <lambdabot> Data.Map.empty :: Map k a
08:56:09 <dmhouse> > M.empty
08:56:11 <lambdabot>  Add a type signature
08:56:14 <petekaz> sjanssen: It'll only print titles for text/html content obviously, but I have to fix it so that I don't download the entire url before making that assessment (I'm just using the MiniHTTP lib in lambdabot).  I think I'll just do a HEAD request first, if content type is text/html, then do a GET.
08:56:16 <dmhouse> > M.empty :: Map String String
08:56:17 <lambdabot>  Not in scope: type constructor or class `Map'
08:56:22 <dmhouse> > M.empty :: M.Map String String
08:56:24 <lambdabot>  {}
08:56:46 <sm> ok.. why the heck can't I do that in my code ? Not in scope: data constructor `String'
08:56:50 <norpan> fromList is useful
08:56:51 <Cale> > M.fromList [(1,"Hello"), (2,"Goodbye")]
08:56:53 <lambdabot>  {1:="Hello",2:="Goodbye"}
08:56:59 <dmhouse> petekaz: Now, if HTTP were a lazy protocol, you wouldn't have to read the entire file :)
08:57:03 <ihope> sm: what's the code that gives the error?
08:57:04 <dmhouse> sm, pastebin your code.
08:57:13 <Cale> sm: are you forgetting the :: ?
08:57:49 <Cale> The only way that error would occur is if String occured as part of an expression
08:57:50 <sm> I just did m = Map [Char] [Char], no type declaration
08:57:52 <petekaz> dmhouse: the other option I suppose is modifying minihttp to just read at most n bytes from a URL, then close the connection on the server.  But that seemed hacky to me.
08:57:55 <sm> String String I mean
08:58:05 <Cale> sm: = ?
08:58:13 <dmhouse> sm, Map is a type. So is String.
08:58:20 <dmhouse> sm, things can't be equal to a type.
08:58:24 <ihope> sm: um, m = empty :: Map String String?
08:58:35 <sm> I thought Map was also the constructor
08:58:37 <sm> and String
08:58:39 <Cale> no
08:58:43 <petekaz> dmhouse: on the flip side, sometimes people handle HEAD and GET requests differently, so I may end up doing it the hacky way anyways.
08:58:51 <Cale> Map doesn't provide you with a data constructor
08:59:00 <ihope> Map is a *type* constructor.
08:59:02 <Cale> you can only create Maps via the functions in the library
08:59:13 <Cale> like fromList
08:59:13 <petekaz> Cale: I just stumbled across your Soduko solver.  How many years will it take for me to grok that?
08:59:18 <sm> aha
08:59:39 <norpan> learning haskell properly takes two years
08:59:40 <petekaz> Cale: and do you have it in a text file you could send me?
08:59:49 <dmhouse> petekaz: just download it off the wiki?
08:59:57 <ihope> norpan: no, memorizing the Report takes two years.
09:00:03 <petekaz> norpan: good, I'm only at a couple of months.
09:00:05 <Cale> petekaz: Can't you just copy-paste it?
09:00:16 <petekaz> dmhouse: you have to copy and paste it.
09:00:18 <norpan> ihope: perhaps, but that doesn't exclude the other
09:00:22 <petekaz> Cale: ok.
09:00:27 <ihope> Cale: so "(a -> Foo a) -> Foo a -> Foo a" is a valid HM type, as is "(a -> b -> Foo c) -> (a -> Foo b) -> Foo a -> Foo c"?
09:00:42 <ihope> Because those are the sorts of types I'd be dealing with.
09:00:50 <Cale> ihope: yes
09:01:17 <dmhouse> ihope, be careful when declaring synonyms, as HM doesn't have full kind inference.
09:01:18 <ihope> Okay, thanks.
09:01:28 <dmhouse> Actually, if you're not using Haskell, scratch that.
09:02:00 <ihope> norpan: so what is learning Haskell "properly"?
09:02:34 <norpan> well that's a matter of definition of course, so that's why i can say that it takes two years withouth being wrong
09:02:37 <petekaz> ihope: I hope he means being able to effectively make your own monads
09:02:55 <norpan> make your own monads, included
09:02:58 <ihope> Um, I can make monads...
09:03:10 <norpan> good for you!
09:03:15 <dmhouse> Monads aren't hard.
09:03:25 <sm> so I'm one step forward.. but ihope, m = empty :: Map String String isn't it
09:03:26 <dmhouse> You'll get monad within, say, four months.
09:03:52 <petekaz> All the libraries I'm using, like NewCGI, all use monads in ways I don't understand yet.  I haven't figured out these transformer things?  I thought they were little robots disguised as cars and such :-)
09:03:56 <ihope> sm: what's the error this time? Is it "not in scope: empty" or something?
09:04:08 <sm> perhaps because I also have RSMap imported.. I need to disambiguate
09:04:13 <ihope> Ah.
09:04:14 <sm> Ambiguous occurrence `empty'
09:04:25 <ihope> @index Map
09:04:27 <lambdabot> Data.Map
09:04:47 <mathias> I understand monads, but font systems....
09:04:53 <dmhouse> petekaz: Monad transformers? In general a transformer is something that takes one thing and returns a different thing. E.g. computations in State are sometimes called state transformers (hence ST).
09:05:00 <ihope> sm: "import qualified Data.Map as M"?
09:05:17 <ihope> Or "as D", or "as Q"...
09:05:24 <sm> well, they already have different names - Map and RSMap
09:05:31 <dmhouse> petekaz: You use monad transformers to stack monads. I.e. ReaderT Env IO Int is a computation from an environment of type Env to an Int, which might do some IO along the way.
09:05:34 <sm> shouldn't I be able to tell it what I mean which a type signature ?
09:05:37 <sm> with
09:05:44 <xerox> Cale, do you think it's fair to steal Conway's timeline of FLT events for my exam's slides? (-;
09:05:45 <ihope> "Data.Map.Map"?
09:05:48 <sm> which empty I mean
09:06:03 <dmhouse> petekaz: Then in your do-block, when you actually want to do the IO, surround your IO stuff in 'lift' (or liftIO, which is just optimised for IO).
09:06:08 <ihope> That is, "m = empty :: Data.Map.Map String String"
09:06:22 <xerox> dmhouse: I read that problem on the book (FLT), fun :)
09:06:35 <petekaz> dmhouse: right, I think I somewhat get the concept, it's just actually seeing them being used which is confusing at the moment.  For example, I've been trying to grok the CGI (NewCGI) library.
09:06:50 <sm> no difference. I've also tried m :: Map String String followed by m = empty
09:06:52 <dmhouse> xerox, I scrawled the solution all over our Quiet Room's whiteboard at school :)
09:06:56 <petekaz> dmhouse: ahh ... I was wondering what liftIO was for.
09:07:01 <dmhouse> sm, then s/empty/M.empty/
09:07:12 <xerox> dmhouse: Didn't read yet! :D
09:07:38 <ihope> @hoogle liftIO
09:07:40 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
09:07:42 <dmhouse> sm, sorry, that means 'replace "empty" with "M.empty"', if you don't speak sed.
09:07:50 <sm> dmhouse: that did it
09:07:53 <sm> m = Data.Map.empty
09:07:53 <dmhouse> @hoogle lift
09:07:54 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
09:07:54 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
09:07:54 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
09:08:02 <sm> phew
09:08:36 <ihope> @pl \x y z -> y (x z) z
09:08:37 <lambdabot> flip flip id . (ap .) . flip (.)
09:08:42 <ihope> Yipe.
09:09:07 <dmhouse> What the hell happened to paste.lisp.org?
09:09:30 <petekaz> we need a haskell version anywasy.
09:09:50 <sm> and to get the type I wanted: m = Data.Map.empty :: Data.Map.Map String String
09:10:16 * sm is a bit type-shocked
09:11:02 <mnislaih> @seen Lemmih
09:11:02 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I last heard Lemmih speak 18 minutes and 46 seconds ago.
09:12:05 <ihope> sm: that's why we do stuff like "import qualified Data.Map as Q", so that'd be "m = Q.empty :: Q.Map String String" :-)
09:13:15 <mathias> dmhouse: What font are you using? 
09:13:33 <dmhouse> mathias: Me? Why?
09:13:51 <mathias> dmhouse: I got the impression you used unicode. 
09:13:57 <sm> ihope: I see
09:14:32 <dmhouse> mathias: I use 'Monospace', which comes with KDE. That's probably not it's true name, though, hold on.
09:14:45 <mathias> dmhouse: E.g. -bitstream-bitstream vera sans mono-*-*-normal-*-*-*-*-*-*-*-microsoft-* also doesn't show sqrt correctly. 
09:15:05 <ihope> So if "forall a. a" is globally quantified and "exists a. a" is existentially quantified, how's "A" quantified?
09:15:19 <xerox> Globally.
09:16:06 <ihope> ...Really?
09:16:23 <ihope> I thought it would be either existentially or something else entirely...
09:16:24 <dmhouse> s/Globally/Universally/, no?
09:16:27 <xerox> `a' is treated as `forall a. a'.
09:16:35 <dmhouse> xerox, but a is not A.
09:16:41 <xerox> What's A ?
09:16:46 <dmhouse> A isn't really qualified at all, that doesn't make sense.
09:16:53 <dmhouse> xerox, something that isn't a type variable?
09:16:55 <xerox> A TyCon?
09:17:01 <xerox> Oh. I see.
09:17:08 <ihope> Well, by "globally quantified" up there, I probably meant "universally qualified".
09:17:33 <ihope> s/qualified/quantified/, grr
09:17:46 <dmhouse> You qualify something when you want to specify what a variable ranges over.
09:17:47 <ihope> Or do I mean "qualified"?
09:18:16 <ihope> Okay. I have no idea what I'm talking about :-P
09:19:27 <dmhouse> Quantification, yeah.
09:19:42 <dmhouse> s/You qualify/You quantify/.
09:19:51 <dmhouse> Power of suggestion :)
09:21:53 <ihope> SKY calculus is still Turing-complete with an HM time system, right?
09:24:18 <dmhouse> ihope: did you mean 'type system'?
09:24:23 <ihope> Yes.
09:24:45 <dmhouse> I would guess so.
09:25:35 <sm> thanks, later all
09:27:29 <dmhouse> ihope, as you can translate consistently between LC and SKY, I'm pretty sure.
09:27:52 <dmhouse> I'd imagine there'd be a bijection between LC- and SKY-forms.
09:29:11 <ihope> It's easy to translate between LC and SKY, but the resulting SKY stuff might not be valid under HM.
09:29:28 <dmhouse> But you can slap HM on the LC too.
09:30:15 <ihope> Well, not everything in LC is valid under HM.
09:30:29 <dmhouse> Okay, so imagine a LC restricted with HM.
09:30:30 <dmhouse> Say, Haskell.
09:30:44 <dmhouse> (After you've translated it down to LC, and ignored any extensions.)
09:31:16 <ihope> ...Oh yeah, Haskell's Turing-complete.
09:32:39 <ihope> And it's easy-ish to convert into SKY.
09:33:17 <dmhouse> Wikipedia gives a translation.
09:33:26 <dmhouse> On the SKI page there's a proof of the SKI basis
09:33:36 <dmhouse> Which is done by giving a translation for LC -> SKI.
09:33:57 <ihope> Well, Haskell isn't lambda calculus.
09:34:12 <dmhouse> Why not?
09:34:27 <nealar> what is SKY? SK-combinators + Y?
09:34:33 <ihope> nealar: yep.
09:34:45 <ihope> @type (\x -> x x) -- this is a valid lambda calculus expression
09:34:47 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:34:47 <lambdabot>    Expected type: t
09:35:30 <nealar> why does it need Y? is it typed calculus?
09:36:03 <dmhouse> nealar: HM.
09:36:44 <ihope> Wait... are B, C, K and W Turing-complete by themselves?
09:37:22 <ihope> If C = liftM, K = return, and whatever is join, we can construct ap from that...
09:37:45 <nealar> dmohouse: are S and K well typed? Or them were just given some abstract types
09:37:59 <dmhouse> ihope, isn't K const?
09:38:08 <ihope> S :: (a -> b -> c) -> (a -> b) -> a -> c and K :: a -> b -> a.
09:38:20 <dmhouse> @type s x y z = x z (y z)
09:38:22 <lambdabot> parse error on input `='
09:38:22 <ihope> dmhouse: yes, but return in the Reader monad is const, aye?
09:38:28 <dmhouse> @type let s x y z = x z (y z) in s
09:38:29 <ihope> By the way, ap, (>>=), join, liftM and return are all the basic operations on monads?
09:38:30 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
09:38:38 <dmhouse> @type let k x y = x in k
09:38:40 <lambdabot> forall t t1. t -> t1 -> t
09:38:51 <dmhouse> @type let i x = x in i
09:38:53 <lambdabot> forall t. t -> t
09:39:06 <dmhouse> > runReader (return 5) "foo"
09:39:07 <lambdabot>  5
09:39:13 <dmhouse> ihope, ah, right.
09:39:28 <ihope> @hoogle runReader
09:39:29 <lambdabot> Control.Monad.Reader.runReader :: Reader r a -> r -> a
09:39:29 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
09:39:47 <dmhouse> @type lifM
09:39:49 <lambdabot> Not in scope: `lifM'
09:39:54 <dmhouse> @hoogle liftM
09:39:55 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
09:39:55 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
09:39:55 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
09:39:56 <ihope> Reader is just (->) in disguise, isn't it?
09:40:02 <dmhouse> ihope, (->) a.
09:40:10 <dmhouse> ihope, and yes.
09:40:20 <ihope> You mean Reader a = (->) a?
09:40:32 <dmhouse> Oh, okay. :)
09:40:39 <ihope> And what was that "yes" to?
09:40:39 <int-e> pretty much
09:40:49 <xerox> newtype Reader e a = Reader { runReader :: e -> a }
09:40:55 <dmhouse> so liftM in Reader :: (b -> c) -> (a -> b) -> (a -> c). It's (.), yeah?
09:40:57 <nealar> 
09:40:58 <nealar> oh
09:41:07 <ihope> dmhouse: yep.
09:41:17 <nealar> then it' simpossible to construct Y from S and K?
09:41:22 <ihope> And that's the C combinator.
09:41:31 * nealar thought that S&K basis is complete
09:41:36 <dmhouse> nealar: You can do it if the calculus is untyped.
09:41:39 <ihope> Yeah.
09:41:45 <nealar> ah
09:41:49 <ihope> But with types, you get lots of oh noes.
09:42:14 <nealar> dmhouse: Y_from_S_and_K is constructible, but ill-typed?
09:42:19 <dmhouse> ihope, you only need liftM and return, join's not needed.
09:42:19 <ihope> @type \x -> (\y -> x (y y)) (\y -> x (y y))
09:42:21 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:42:21 <lambdabot>    Expected type: t
09:42:22 <dmhouse> nealar: hold on.
09:42:41 <dmhouse> nealar: Y = S (K (S I I)) (S (S (K S) K) (K (S I I)))
09:42:45 <ihope> dmhouse: um, so how can you construct join?
09:43:02 <dmhouse> ihope, oh, I thought you were including join to get ap. Never mind.
09:43:05 * nealar starts typechecking Y_from_S_and_K 
09:43:27 <ihope> Can you get ap with only liftM and return?
09:43:39 <dmhouse> @let s = ap; k = const; i = id in s (k (s i i)) (s (s (k s) k) (k (s i i)))
09:43:39 <lambdabot> Maybe you meant: last list
09:43:44 <dmhouse> @type let s = ap; k = const; i = id in s (k (s i i)) (s (s (k s) k) (k (s i i)))
09:43:46 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
09:43:46 <lambdabot>    Expected type: (a -> b) -> a
09:43:55 <dmhouse> nealar: let Haskell do it for you :)
09:44:04 <ihope> "s i i" is already an error.
09:44:13 <dmhouse> ihope, can't you?
09:44:14 <ihope> @type let s x y z = x z (y z) in s id id
09:44:16 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:44:16 <lambdabot>    Expected type: (t -> t1) -> t
09:44:43 <dmhouse> ap :: m (a -> b) -> m a -> m b
09:44:46 <ihope> dmhouse: that's getting S from C and K.
09:45:04 <ihope> That doesn't seem possible to me.
09:45:07 <dmhouse> ap = liftM . return
09:45:15 <ihope> @type (.) . const
09:45:17 <lambdabot> forall b a a1. a1 -> (a -> b) -> a -> a1
09:45:35 <ihope> That's something else...
09:45:48 <ihope> @hoogle a -> m b -> m a
09:45:49 <lambdabot> Prelude.asTypeOf :: a -> a -> a
09:45:50 <lambdabot> Prelude.const :: a -> b -> a
09:45:50 <lambdabot> Prelude.seq :: a -> b -> b
09:46:13 <dmhouse> Oh, you can construct liftM from ap, perhaps not the other way round.
09:46:23 <dmhouse> liftM = ap . return.
09:46:32 <dmhouse> or liftM f x = ap (return f) x
09:46:49 <ihope> C = C S K?
09:47:16 <dmhouse> Recursion? We don't have Y, do we?
09:47:33 <ihope> Sure we do.
09:47:53 <ihope> But... ish.
09:48:28 <ihope> > let s x y z = x z (y z); c = c s const in c (+2) (+3) 6
09:48:29 <lambdabot>    Occurs check: cannot construct the infinite type: t = t1 -> t2 -> t
09:48:29 <lambdabot>   ...
09:49:16 <ihope> By the way, should I include "a -> m b -> m a" as one of the basic monadic combinators?
09:49:38 <dmhouse> what, return . const? 
09:49:48 <dmhouse> Or fmap . const?
09:50:13 <ihope> @type Control.Monad.liftM . return
09:50:14 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => a -> m a1 -> m a
09:50:22 <dmhouse> Right, yeah.
09:50:28 <dmhouse> Substituting the value.
09:50:45 <ihope> Yeah, should that be one of the basic combinators?
09:51:05 <dmhouse> Didn't you just decide you had liftM and return?
09:53:00 <koffein> hi everybody..
09:53:35 <koffein> what would be the best haskell book to buy if I already know python?
09:54:41 <koffein> can be english or german
09:54:45 <vegai> I suspect that doesn't narrow down the choices too much
09:55:42 <koffein> it does as I don't want a book starting at "what is a programm"
09:55:46 <vegai> hmm, has haskell.org/ been a wiki for long?
09:55:51 <koffein> grogram
09:55:54 <koffein> pr..
09:56:02 <dmhouse> vegai, quite a while now.
09:56:07 <ihope> dmhouse: yeah, but should I have this one, too?
09:56:19 <qwr> koffein: if feel confident, read the gentle introduction to haskell
09:56:32 <dmhouse> ihope, no? If it can already be defined in terms of the others.
09:56:50 <ihope> But I have lots of redundancy already.
09:57:03 <qwr> koffein: http://www.haskell.org/tutorial/
09:57:05 <lambdabot> Title: "A Gentle Introduction to Haskell, Version 98"
09:57:24 <ihope> > (liftM . return) 3 [1,2,3]
09:57:26 <lambdabot>  [3,3,3]
09:57:45 <dmhouse> > (liftM . return) 4 (Just 2)
09:57:47 <lambdabot>  Just 4
09:57:59 <ihope> > (liftM . return) 4 Nothing
09:58:00 <lambdabot>  Nothing
09:58:01 <koffein> okay, thanks
09:58:24 <ihope> Eh, I think I'll include this one, and call it 's'.
09:58:42 <ihope> @djinn a -> (e -> b) -> e -> a
09:58:43 <lambdabot> f a _ _ = a
09:58:46 <ihope> What?
09:59:05 <ihope> @type (.) . const
09:59:06 <lambdabot> forall b a a1. a1 -> (a -> b) -> a -> a1
09:59:34 <ihope> @type const . const
09:59:36 <lambdabot> forall b a b1. a -> b -> b1 -> a
09:59:44 <dmhouse> Djinn's fairly rubbish ;)
09:59:54 <sjanssen> @pl \x y z -> x
09:59:55 <lambdabot> const . const
10:00:11 <koffein> but as a "real" book... is "the Craft of Functional Programming" useful?
10:00:26 <ihope> It seems useless :-P
10:00:34 <koffein> why?
10:00:42 <sjanssen> what is wrong with the defn. that Djinn gave?
10:00:48 <ihope> That is, this s thing seems useless.
10:01:04 <koffein> ok
10:01:09 <koffein> anyone read the book?
10:01:42 <ihope> What's wrong with what Djinn gave is that that's the only way to do it...
10:01:57 <ihope> @djinn a -> Maybe b -> Maybe a
10:01:58 <lambdabot> f a b =
10:01:58 <lambdabot>   case b of
10:01:58 <lambdabot>   Nothing -> Nothing
10:01:58 <lambdabot>   Just _ -> Just a
10:02:09 <ihope> That's more like it...
10:02:34 <sjanssen> yeah, Djinn gets silly sometimes
10:02:41 <dmhouse> > (liftM . return) (+2) (+5) 10
10:02:43 <lambdabot>  Add a type signature
10:02:59 <ihope> Um, it doesn't get any less silly than "f a _ _ = a" in that case.
10:03:02 <dmhouse> > (liftM . return) (+2) (+5) 10 :: Int
10:03:03 <lambdabot>    Expecting a function type, but found `a'
10:03:03 <lambdabot>    Expected type: Int
10:03:03 <lambdabot>    ...
10:03:12 <qwr> koffein: but i have to warn you, that knowing python will not help you much on learning haskell :)
10:03:21 <ihope> @type liftM . const
10:03:22 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => a -> m a1 -> m a
10:03:36 <nealar> is @google actually a reverse of "URL title" plugin? :)
10:03:47 <ihope> http://www.example.com/
10:03:53 <ihope> ...
10:04:03 <ihope> http://www.neopets.com/
10:04:10 <ihope> I couldn't think of a better URL :-P
10:04:14 <dmhouse> ihope broke it.
10:04:24 <ihope> I did?
10:04:41 <ihope> @type (.) . return
10:04:43 <lambdabot> forall b a a1. a1 -> (a -> b) -> a -> a1
10:04:43 <dmhouse> Unless I've inadvertantly got lambdabot on /ignore :)
10:04:53 <ihope> @type liftM (.) const
10:04:55 <lambdabot> forall b a a1. a1 -> (a -> b) -> a -> a1
10:05:01 <ihope> @type liftM (.) return
10:05:03 <lambdabot> forall b a a1. a1 -> (a -> b) -> a -> a1
10:05:07 <ihope> Okay, enough of that...
10:06:17 <nealar> dmhouse: is S I ill-typed?
10:06:29 <ihope> S I I is.
10:06:36 <dmhouse> nealar: why don't you find out?
10:06:39 <dmhouse> @type ap id
10:06:41 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
10:06:57 <ihope> Cool type. :-
10:07:00 <ihope> Erm, :-)
10:07:02 <koffein> qwr, well... list comprehensions, lambda, map, filter etc. are not new to me
10:07:25 <nealar> dmhouse: because I have bad understanding of lambda calculus
10:07:38 <int-e> @djinn (a -> b -> c) -> (b -> a) -> b -> c
10:07:38 <lambdabot> f a b c = a (b c) c
10:07:41 <ihope> Now, this "replace" function and return aren't enough to reconstruct all the other monadic operations, right?
10:08:47 <dmhouse> ihope, I don't think you could recover bind.
10:09:01 <ihope> What about with replace, return, and join?
10:09:03 <nealar> dmhouse: ( f::(a->b->c) g::(d->e)) is invalid even in presence of partial application?
10:09:33 <ihope> nealar: well, you can't pass (a -> a) into something that wants ((a -> b) -> a).
10:09:50 <dmhouse> nealer, no.
10:09:52 <ihope> That would force a to equal (a -> b), but that'd create an infinite type.
10:09:56 <dmhouse> nearler, it's fine.
10:10:35 <nealar> ouch
10:10:55 <nealar> I meant  ( f::((a->b->c)->x) g::(d->e))
10:11:26 <ihope> I think that's still okay.
10:11:28 <dmhouse> @type let f _ _ _ = undefined; g _ = undefined in f g
10:11:30 <lambdabot> forall a t t1. t -> t1 -> a
10:11:36 <nealar> ok
10:11:37 <dmhouse> ERr
10:11:39 <dmhouse> *Err
10:11:44 <dmhouse> @type let f _ _ = undefined; g _ = undefined in f g
10:11:46 <lambdabot> forall a t. t -> a
10:11:57 <ihope> But like I said, "((a -> b) -> c) -> d" can't be applied to "e -> e".
10:12:05 <nealar> yes
10:12:08 <dmhouse> Oh, wait.
10:12:19 <ihope> Hmm...
10:12:34 <ihope> @type undefined (undefined undefined (undefined undefined) undefined)
10:12:36 <lambdabot> forall t. t
10:13:10 * nealar has extremely bad teoretical background
10:13:11 <dmhouse> @type let f _ _ = undefined; h _ = undefined; g _ = undefined (f h) in h g
10:13:13 <lambdabot> forall a. a
10:14:17 <fwfewfwa> what's a good book about haskell? (not an introduction, but an advanced one that shows all the great things of the language)?
10:14:30 <ihope> The Report? :-P
10:14:46 <fwfewfwa> that's the language specification, isn't it?
10:14:47 <dmhouse> fwfewfwa: which things in particular?
10:14:49 <ihope> Yes.
10:14:58 <fwfewfwa> i don't think that shows all the great things :)
10:15:19 <ihope> What about the GHC docs?
10:15:22 <dmhouse> fwfewfwa: the GHC user manual section on type section extensions.
10:15:22 <ihope> Or the GHC source code?
10:15:31 <fwfewfwa> O_o
10:15:38 <dmhouse> fwfewfwa: and papers.
10:15:40 <fwfewfwa> isn't there any "normal" book?
10:18:24 * lispy tries to compile wxhaskell from the begining *crosses fingers*
10:19:03 <ihope> Oh, probably.
10:19:14 <ihope> But who likes those? :-P
10:19:23 <lispy> fwfewfwa: there have been several good books on haskell from what i understand, and yet i think most people get their haskell beginings from classes or off the net
10:19:40 <fwfewfwa> i don't want my haskell beginings :) but my advancenings!
10:19:44 <ihope> @pl \x -> x id (\j n -> n)
10:19:44 <lambdabot> flip ($ id) (const id)
10:19:51 <ihope> Um?
10:19:55 <lispy> fwfewfwa: hehe, then start reading LtU ;)
10:20:07 <lispy> @type ($ id)
10:20:08 <lambdabot> forall a b. ((a -> a) -> b) -> b
10:21:21 <ihope> How would I express ($ id) using those fancy monadic thingies?
10:21:37 <ihope> I guess I oughta get some flip thing, too.
10:21:41 <ihope> @type flip
10:21:42 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
10:22:12 <ihope> m (b -> c) -> b -> m c... ah, the cuffing operator.
10:22:26 * ihope wonders why he calls it the cuffing operator...
10:23:18 <ihope> @hoogle m (b -> c) -> b -> m c
10:23:19 <lambdabot> Prelude.asTypeOf :: a -> a -> a
10:23:20 <lambdabot> Prelude.const :: a -> b -> a
10:23:20 <lambdabot> Prelude.seq :: a -> b -> b
10:24:16 * ihope sighs
10:24:56 * lispy can't figure out what the point of ($ id) is
10:25:22 <ihope> It applies its argument to id.
10:25:27 <lispy> @type ($ id) id
10:25:28 <lambdabot> forall a. a -> a
10:25:37 <ihope> That's id id. :-)
10:25:44 <ihope> @type ($ id) const
10:25:46 <lambdabot> forall a b. b -> a -> a
10:25:48 <ihope> @type const id
10:25:49 <lambdabot> forall a b. b -> a -> a
10:25:53 <lispy> > ($ id) 1
10:25:54 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
10:26:01 <ihope> That's "1 id".
10:26:03 <lispy> so the argument must be a function too?
10:26:07 <ihope> Yep.
10:26:07 <lispy> ah
10:27:08 <ihope> @docs Control.Monad
10:27:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
10:28:12 <lispy> @type flip ($ id)
10:28:13 <lambdabot> forall a b c. b -> ((a -> a) -> b -> c) -> c
10:28:59 * lispy knocks on wood as wxHaskell compiles away
10:30:00 <ihope> @hoogle mapAndUnzip
10:30:01 <lambdabot> Monad.mapAndUnzipM :: Monad a => (b -> a (c, d)) -> [b] -> a ([c], [d])
10:30:01 <lambdabot> Control.Monad.mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
10:32:23 <lispy> argg!!! compile error
10:32:25 <ihope> What...
10:32:32 <ihope> @hoogle P
10:32:33 <lambdabot> Text.Html.p :: Html -> Html
10:32:33 <lambdabot> Control.Parallel :: module
10:32:33 <lambdabot> Data.PackedString :: module
10:32:54 <ihope> But what is P?
10:33:08 <ihope> @index P
10:33:09 <lambdabot> bzzt
10:35:58 * lispy recovers from the error and crosses his fingers again
10:36:08 <lispy> ihope: paragraph tag
10:36:34 <ihope> But the docs for Control.Monad say that P is a monad.
10:36:42 <lispy> P != p ?
10:37:18 * lispy has no clue :)
10:37:30 <dmhouse> ihope, what's the context?
10:37:49 <ihope> Um...
10:38:07 <apfelmus> dmhouse: the docs about Control.Monad identify a strange P as being a monad
10:38:12 <dmhouse> ihope, oh, it may refer to P as in ReadP.
10:38:34 <lispy> @hoogle ReadP
10:38:35 <lambdabot> Text.ParserCombinators.ReadP :: module
10:38:35 <lambdabot> Text.ParserCombinators.ReadP.ReadP :: data ReadP a
10:38:35 <lambdabot> Text.ParserCombinators.ReadPrec :: module
10:38:52 <lispy> wow, hoogle searches a lot now
10:38:52 <ihope> Instances: Monad IO, Monad Maybe, Monad P, Monad ReadP, Monad ReadPrec, Monad STM, Monad [], ArrowApply a => Monad (ArrowMonad a), Monad (ST s), Monad (ST s).
10:39:11 <dmhouse> Read the paper on ReadP, it'll likely explain.
10:39:30 <ihope> Explain why P is a monad?
10:39:35 <dmhouse> I think so.
10:40:07 <lispy> "...And at 5 pm, the story of P, a monad."
10:40:50 <LordBrain> if i have something of type, State Bool Int
10:41:15 <LordBrain> how can i display the int? or the bool?
10:41:24 <lispy> runST ?
10:41:30 <lispy> @type runST
10:41:32 <lambdabot> Not in scope: `runST'
10:41:39 <lispy> @hoogle run
10:41:40 <lambdabot> Test.QuickCheck.Batch.run :: Testable a => a -> TestOptions -> IO TestResult
10:41:40 <lambdabot> Data.Graph.Inductive.NodeMap.run :: (DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> (r, (NodeMap a, g a b))
10:41:40 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
10:41:49 <lispy> @hoogle runST
10:41:49 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
10:41:50 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
10:41:50 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
10:42:01 <dmhouse> LordBrain: that doesn't really make sense.
10:42:16 <Igloo> LordBrain: You might want runState/evalState/execState
10:42:22 <dmhouse> lispy: ST is another State monad.
10:42:28 <lispy> oh, my mistake
10:42:36 <LordBrain> its runState
10:42:38 <LordBrain> thanks
10:42:59 <LordBrain> well.. i'm just trying to learn here.. so 
10:52:16 <SimonRC> lispy: nonono, ST is a imperativism monad
10:52:27 <SimonRC> lispy: a state monad with a magic state
10:55:52 * palomer wonders if ST could be implemented in pure haskell with an extended type system
10:58:13 <xerox> yes.
10:58:33 <xerox> It needs mptc and something like dependent typing I think
10:58:43 <Philippa_> dynamic types're good enough
10:58:55 <xerox> okay :)
10:59:33 <Philippa_> then IIRC GADTs're enough to type a function that builds both a cell and a matching reference
11:01:35 <palomer> isn't that all that's needed?
11:03:37 <Philippa_> yep
11:03:42 <thorondor> why
11:03:43 <Philippa_> well, give or take dropping the cells in a mad
11:03:56 <Philippa_> map, even
11:04:24 <Philippa_> basically the ref holds a type-level typeid you use to cast the dynamic value
11:08:24 <palomer> don't you also rank 2 types for runST?
11:10:01 <apfelmus> i'm unable to locate the/a paper about ReadP. anyone any hints?
11:12:23 <Azmo> isn't "import Prelude hiding (catch)" supposed to work? i still get catch, which clashes with Control.Exception.
11:20:59 <apfelmus> Azmo: what should work? you want to name some of your functions "catch"?
11:22:52 <Azmo> apfelmus: just want to use the Control.Exception.catch instead, which clashes with 'catch' in the Prelude. i do not want to use it qualified or anything, just plain and simple "catch".
11:24:07 <Azmo> according to "http://www.haskell.org/onlinereport/modules.html" it is supposed to work :/
11:24:08 <lambdabot> Title: "The Haskell 98 Report: Modules"
11:29:44 <Lemmih> Azmo: It works for me.
11:29:52 <apfelmus> Azmo: mh, import Prelude hiding (catch) actually works for me
11:30:08 <Azmo> weird.
11:30:23 <apfelmus> Azmo: maybe you accidentially defined catch in some way?
11:30:56 <Azmo> nope. but i'll try again in a new small file.
11:31:27 <apfelmus> Azmo: another option is to paste the code and let other people do the work ;)
11:33:49 <Azmo> ah, damn. i just had to re-load the file into GHCI :/
11:34:03 <Azmo> thanks for the help :]
11:36:59 <Azmo> i meant restarting GHCI, since i was actually just reloading, which works fine for any other change in the imports.
11:49:08 <Lemmih> You had to restart GHCi?
11:51:25 <aFlag> is there something like cscope for haskell?
11:53:09 <JKnecht> what's cscope, a debugger? there's Hat.
11:53:25 <aFlag> no, it's for browsing the code
11:53:51 <aFlag> So i can type in the name of a function and it goes to its definition
11:53:53 <aFlag> and things like that
11:54:45 <JKnecht> IIRC there's a haskell integrated with VS 2K3.
11:54:56 <aFlag> what's vs 2k3?
11:55:13 <JKnecht> Visual Studio 2003.
11:55:27 <aFlag> oh, i don't even have windows :(
11:55:41 <JKnecht> thought you did.
11:55:51 <nealar> Yes
11:56:06 <nealar> there is Visual Haskell
11:56:34 <lispy> hmm...the impossible just happened
11:57:14 <aFlag> hum, i was looking for something that I could use together with vim
11:57:14 <lispy> JKnecht: http://www.haskell.org/visualhaskell/  works with VS.NET
11:57:16 <lambdabot> Title: "Visual Haskell"
11:57:39 <apfelmus> aFlag: :( is the wrong smiley for not having windows :)
11:59:18 <aFlag> hehe
12:07:22 <proton-weapon> so is there such a things as a functional database?
12:07:26 <proton-weapon> we have relational and oo
12:07:30 <proton-weapon> why not fucntional?
12:07:39 <proton-weapon> think of the marketing power
12:08:39 <lightstep> proton-weapon, usually set-algebra databases are compatible with functional programming
12:09:11 <nealar> there is logic database
12:09:21 <nealar> I think, it's enough
12:19:05 <proton-weapon> logic databasE?
12:19:07 <proton-weapon> hmm
12:19:09 <proton-weapon> where?
12:24:58 <JKnecht> proton-weapon: it's called Prolog.
12:25:07 <nealar> yep
12:33:15 <fiete> Hi! Is it possible to create an instance of Show of a tuple of a certain type?
12:35:14 <nealar> fiete: simple instance Show (Type1,Type2) where ... doesn't work?
12:37:24 <fiete> at least not in my ghc. I tried: data Test = Test; instance Show (Test, Test) where;  show = (\a-> "")
12:38:20 <Dino_> From the interactive prompt?
12:38:32 <SamB> most of the tuple types already have Show instances
12:38:35 <fiete> might be the problem that Show is already instanciated for tuples
12:38:41 <SamB> try a newtype on for size
12:39:26 <nealar> SamB: I think predefined instances shpuld be overridable
12:39:30 <nealar> should
12:39:48 <fiete> Dino_: ghc has an interative prompt?
12:39:56 <Dino_> Sorry, ghci
12:40:00 <SamB> well, you could turn on overlapping instances -- but it doesn't fit my brain well.
12:40:48 <SamB> and I somehow doubt it is appropriate in your situation -- what do you want your instance to do?
12:41:14 <fiete> SamB: sorry I'm kind of an haskell noob and dont know what you mean by overlapping
12:41:44 <SamB> fiete: well, then you could have both instances, and the haskell compiler would supposedly somehow figure out which was appropriate
12:41:53 <SamB> I have no idea how it is supposed to actually *do* that, though
12:43:12 <lightstep> what are the usual hours of the ICFP contest?
12:43:44 <fiete> SamB: I see, it a certain ghc feature that makes me able to define multiple instances?
12:44:14 <SamB> sort of, yeah
12:44:34 <lightstep> fiete, the option is -fallow-overlapping-instances
12:45:53 <fiete> Anyway, its not that important for me in my current situation. Its just nice to know. I better do it without Show
12:46:14 <fiete> lightstep: thank you. I will take a look
12:52:28 <lispy> oh, i got wxHaskell to work
12:52:52 <lispy> so now i have COM, GUI, XML and parser libraries ready to go on win32
12:53:10 <lispy> so...i don't really have an excuse to not use haskell anymore :)
13:06:44 <Lemmih> @seen bringert
13:06:44 <lambdabot> I saw bringert leaving #haskell.se and #haskell 11 hours, 42 minutes and 13 seconds ago, and .
13:09:55 <Dino_> lispy: That's great. I just got the SOE book and am hoping the graphics and sound stuff will work with Linux.
13:17:09 <bringert> morning #haskell
13:17:19 <madpickle> morning O.o
13:17:21 <bringert> whoa, it's 1:15
13:17:49 <norpan> it is?
13:17:52 <madpickle> [27 09:06:23 pm] <Lemmih> @seen bringert
13:17:52 <madpickle> [27 09:06:24 pm] <lambdabot> I saw bringert leaving #haskell.se and #haskell 11 hours, 42 minutes and 13 seconds ago, and .
13:18:22 <bringert> madpickle: what timezone is that?
13:18:26 <madpickle> uk
13:18:34 <madpickle> so about 12 mins ago
13:18:52 <norpan> @localtime bringert 
13:18:54 <lambdabot> Local time for bringert is Tue Jun 27 13:18:11 2006
13:19:05 <madpickle> the WA in the hostname gave it away =P
13:19:07 <norpan> ah, that kind of 1:15
13:19:55 <norpan> that am/pm stuff doesn't fully work on the internet
13:19:56 <bringert> it would have been a bit weird to be surprised that it was 1:15 am, after saying good morning
13:20:13 <bringert> norpan: netither does 24h time though
13:20:15 <norpan> maybe you woke up early
13:20:19 <bringert> eh, neither
13:20:25 <bringert> true
13:20:28 <norpan> at least i can relate to it being 13:15
13:20:32 <madpickle> we should all use unix time
13:20:40 <madpickle> and simply use basic arithmetic to determine time differences
13:21:01 <norpan> knowing the local time is often good
13:21:01 <madpickle> now there's a new concept in the world of military
13:21:09 <norpan> wrt lunch etc
13:21:13 <madpickle> "I want you here cleaning the deck at 18361119371 hours"
13:21:18 <norpan> or people being asleep
13:21:29 <madpickle> but what if you're at an airport
13:21:37 <madpickle> that transcends all known sleep- and time patterns
13:21:52 <norpan> how many are at an airport, raise your hands
13:21:58 <madpickle> hey now
13:22:02 <madpickle> BTOpenZone
13:22:05 <madpickle> it's possible
13:22:06 <madpickle> =)
13:22:32 <norpan> sure
13:22:52 <norpan> i've been at airports using my laptop
13:23:02 <norpan> not sure if i chatted on irc though
13:23:05 <norpan> i probably did
13:32:04 <lightstep> how can i pass undefined names to templates?
13:32:29 <Lemmih> bringert_: ping.
13:32:33 <lightstep> as in print $(namelist [''A, ''B, ''C])
13:32:45 <bringert_> Lemmih: pong
13:33:00 <Lemmih> bringert_: More HTTP questions.
13:34:02 <Lemmih> bringert_: 'sendHTTP' always sends the body of a request but it tells 'switchResponse' that it doesn't.
13:34:08 <Lemmih> bringert_: Why is that?
13:35:16 <bringert_> Lemmih: I'll have a look
13:36:33 <bringert_> Lemmih: that's weird
13:37:05 <bringert_> Lemmih: there is a lot of stuff in there that I have never touched
13:37:41 <bringert_> and Warrick Gray has vanished
13:38:04 <Lemmih> Ok, I'll add it to the patch list.
13:38:15 <bringert_> is it causing problems?
13:39:10 <Lemmih> No, just weird. And weird stuff can cause future problems.
13:46:30 <genneth> bringert_: is there somewhere i can get hope from?
13:46:50 <bringert_> genneth: some people use religion
13:46:51 <Lemmih> heh
13:46:54 <Igloo> lightstep: mkName or newName them
13:46:56 <genneth> :p
13:47:13 <bringert_> genneth: http://hope.bringert.net/entry/2
13:47:35 <genneth> thank you
13:47:52 <bringert_> genneth: ask me whenever you have problems or questions
13:48:16 <bringert_> genneth: I'm working a lot on it right now, so things are changing rapidly, and there isn't much documentation
13:48:57 <bringert_> genneth: if you set up a public Hope site, I'd be very happy if you would give me the URL so I can have a look
13:49:08 <genneth> bringert_: sure
13:49:28 <bringert_> it's fun to see your own stuff running somewhere else
13:49:29 <genneth> bringert_: i'm actually trying to write a thing to support the Atom Publish Spec
13:49:56 <genneth> bringert_: was going to start from HAppS; but Hope might be quicker to get things up and running
13:50:00 <bringert_> genneth: is that a blog API?
13:51:06 <genneth> bringert_: yes; it's a REST-ish interface to allow authoring
13:51:28 <bringert_> wtf happend
13:51:32 <bringert_> am I still here?
13:51:33 <genneth> bringert_: essentially atom is trying to define the interface for viewing and authoring updating content
13:51:36 <genneth> bringert_: yes
13:51:51 <bringert_> ok, that sounds like a great addition to Hope
13:52:08 <bringert_> if you implement it, I'd be happy to integrate it into Hope if you want
14:04:13 <CosmicRay> is anyone aware of an RSS parser for Haskell?
14:04:57 <neologism> isnt rss plain xml?
14:05:01 <neologism> so any xml parser will do?
14:05:19 <Igloo> I think someone's done something RSSy...is it atom, or is that a non-Haskell tool?
14:06:35 <CosmicRay> yes.
14:06:40 <CosmicRay> rss is plain xml.
14:06:56 <CosmicRay> I just wondered if anybody had done the work already.
14:07:04 <CosmicRay> atom is a rss-like file format
14:07:11 <monochrom> Some specialization to the RSS tags is still necessary.
14:07:20 <CosmicRay> I only care about a few.
14:07:26 <CosmicRay> I'm writing a podcast downloader.
14:07:33 <CosmicRay> because all podcast downloaders out there suck.
14:08:00 <CosmicRay> I need title of the feed, title of the episode, and url and mediatype of each enclosure to begin with.  so it shouldn't be too bad.
14:08:13 <monochrom> Consider: "isn't xml plain text? so any character input stream will do?"  :)
14:08:34 <CosmicRay> monochrom: isn't .doc plain binary?  so any processor of bits will do? ;-)
14:08:54 <monochrom> Yeah!
14:09:02 <CosmicRay> course I should not say that around Igloo -- he's liable to write a .doc processor as a processor of a list of bits ;-)
14:10:17 * Igloo wonders why CosmicRay doesn't complain at all about the State monad that is the actual speed problem of the library in question  :-)
14:10:37 <CosmicRay> Igloo: <grin>
14:11:00 <monochrom> A: "I need to predict stock prices - some errors are ok."  B: "isn't the whole universe just quantum gravity? so any unified theory will do?"  XD
14:11:39 <CosmicRay> heh
14:19:42 <norpan> quantum gravity is out there
14:20:01 <palomer> it's everywhere
14:20:11 <LordBrain> like the truth
14:20:38 <palomer> I didn't like the epilogue of "crime and punishment"
14:20:40 <palomer> not one bit.
14:21:12 <norpan> it's a good book though
14:21:47 <palomer> the epilogue almost completely ruined it
14:21:52 <palomer> a happy ending? wtf!
14:21:52 <LordBrain> how so?
14:22:08 <norpan> if you call being in work camp a happy ending
14:22:10 * palomer _hates_ happy endings
14:22:20 <LordBrain> hmmm
14:22:22 <palomer> sonia and the hero being in love?
14:22:26 <palomer> looking forward to a bright future?
14:22:30 <palomer> I hate books that end with hope.
14:22:51 <palomer> would have been 10 times better if the hero commited suicide
14:23:04 <norpan> well, life goes on is the sensmorale
14:23:28 <palomer> sensmorale?
14:23:43 <norpan> the moral
14:23:57 <norpan> maybe sensmorale is not a proper english word
14:24:18 <palomer> I think it's a french composite
14:24:27 <vegai> well, that book is largely good by accident
14:24:41 <vegai> as I suppose most other good books are too
14:24:49 <norpan> good by accident, how do you mean
14:24:50 <LordBrain> hmmm.. so writers should aim low
14:24:57 <palomer> I also don't like the fact that the bad guys get what's coming to them
14:25:04 <palomer> and the good guys get what they want
14:25:15 <LordBrain> i never read it
14:25:16 <vegai> norpan: that the writer was in such conditions where you wouldn't normally expect a good book
14:26:03 <norpan> well it was some time since i read it
14:26:46 <norpan> don't know what condition dostojevski was in
14:27:10 <monochrom> mint condition
14:27:17 <norpan> heh
14:27:38 <vegai> he wrote the book to make up gambling debts
14:27:58 <palomer> much of it is pulp
14:27:59 <vegai> well, I suppose money is as good motivation as any
14:28:05 <palomer> the only good bits are the really gloomy ones
14:35:24 <bringert_> CosmicRay: a general RSS parser would be great to have as a library. Especially one that handles all the incompatible dialects of RSS.
14:35:40 <CosmicRay> bringert_: that is one of the incredible annoyances of RSS.
14:35:47 <CosmicRay> bringert_: I am probably not going to write a general parser
14:36:01 <CosmicRay> as a podcast aggregator, I can get away with handling only a subset of RSS and only in a specific dialect.
14:36:03 <CosmicRay> which is nice.
14:36:29 <bringert_> if you use HaXML, couldn't you just take the DTD and generate a parser + abstract syntax?
14:36:47 <CosmicRay> I don't want to break on non-conforming feeds.
14:36:47 <bringert_> that should handle one of dialects fully at least
14:36:50 <bringert_> ah
14:37:00 <CosmicRay> but perhaps I could start there anyway.
14:37:27 <CosmicRay> I wonder what such a parser would do with xml tags it doesn't know if?
14:37:34 <CosmicRay> it would reject the document as non-well-formed, yes?
14:46:12 <turok> hello. can someone give me a tip how to easily sort a [(Int, Char)] list ascending after the Int of every tuple?
14:47:29 <lightstep> @type sortBy
14:47:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:48:02 <turok> oh thank you
14:48:14 <neologism> > sortBy (\x y -> (fst x) `compare` (fst y)) [(1, a), (2, b)]
14:48:14 <lambdabot>  Not in scope: `b'
14:48:21 <neologism> > sortBy (\x y -> (fst x) `compare` (fst y)) [(1, 'a'), (2, 'b')]
14:48:22 <lambdabot>  [(1,'a'),(2,'b')]
14:48:27 <neologism> > sortBy (\x y -> (fst x) `compare` (fst y)) [(4, 'a'), (2, 'b')]
14:48:29 <lambdabot>  [(2,'b'),(4,'a')]
14:48:55 <Lemmih> > let comparing fn a b = fn a `compare` fn b in       sortBy (comparing fst) [(1,'x'),(10,'b'),(2,'n')]
14:48:56 <lambdabot>  [(1,'x'),(2,'n'),(10,'b')]
14:49:33 <turok> oh you guys are great, i appreciate your instant help very much
14:49:37 <turok> thanks alot
14:49:40 <neologism> turok: we are paid to do so
14:49:48 <turok> :D
14:50:04 <aFlag> what is the intersection between two maps?
14:50:42 <aFlag> for what I read on hoogle I think it gets only the keys that are common but get the values only of the first map
14:51:06 <aFlag> is that correct? I'm not sure I understood the documentation well
15:19:51 <sm> hi.. has anyone had experience with the RSMap of HAppS ?
15:20:23 <sm> it's a wrapper for Map that supports Read
15:21:47 <sm> here.. http://happs.org/auto/apidoc/HAppS-DBMS-RSMap.html#t%3ARSMap . If I have imported this, shouldn't I be able to use Map's findWithDefault on it ?
15:35:51 <Cale> sm: RSMap is a newtype, not a type synonym, so you can't apply it directly
15:36:09 <Cale> You can apply it to the Map inside though
15:37:28 <mwolak> in ghc, is foldl' defined with seq, or is it magically extra-strict?
15:37:31 <sm> hmmm
15:37:58 <sm> it's inside, eh!
15:38:27 <Cale> mwolak: defined with seq
15:39:04 <mwolak> rats, that throws off my whole understanding of how I fixxed my program :(
15:39:10 <mwolak> thanks though!
15:40:33 <Cale> foldl' f z [] = z
15:40:53 <Cale> foldl' f z (x:xs) = (foldl' f $! f z x) xs
15:41:21 <Cale> f $! x = x `seq` f x
15:42:34 <sm> Cale: thanks! another hurdle jumped
15:42:55 <Cale> sm: :)
15:43:31 <mwolak> I had something like
15:43:37 <mwolak> do list <- blah
15:43:48 <mwolak> let l2 = map f list
15:44:23 <mwolak> let result = foldl' f stuff l2
15:45:33 <mwolak> profiling showed that my memory issues were in the map line, so I replaced it with map' (a seq'ed version of map), but that didn
15:45:52 <mwolak> didn't fix it, but taking the intermediate list out did
15:51:04 <Cale> mwolak: what do you mean by 'taking the temporary list out'? Did you just let result = foldl' f stuff (map f list) ? Or did you work the map function into the 'f'?
15:53:57 <Cale> seq'ing map isn't usually too likely to help, it probably will only ever make memory issues worse. Lazy lists are just loops that haven't happened yet. If you modify the definition of map to seq all the elements so you'll force the whole structure before one element is accessible, you're just forcing a large structure to be built in memory at once when it's probably not necessary.
15:54:55 <mwolak> ah
15:55:06 <mwolak> I worked the mapped function into the f
15:55:09 <mwolak> thanks
15:55:30 <palomer> does that make me crazy?
15:55:38 <Cale> Right, that would mean that the conses of the intermediate list are never built at all
15:55:42 <Cale> but hmm
15:55:55 <mwolak> I thought the map would be generated lazily and GC'ed
15:56:13 <Cale> yes, that's what I'd think too
15:57:28 <Cale> oh hmm...
15:59:52 <Cale> If it wasn't GC'ing it, there must be some reason that it was keeping the list structure around a long time, and that's probably the fact that you're using foldl' on it. It's going to have to go through the whole list in order to start doing any reduction at all.
16:00:25 <Cale> well, it applies the function as it goes...
16:01:11 <Cale> hmm
16:01:25 <Cale> What's the type of 'result'?
16:01:27 <mwolak> it's actually still taking in a mapped list, but memory consumption is flat
16:01:40 <mwolak> [[[Event]]]
16:01:46 <Cale> oh
16:02:23 <mwolak> wait
16:02:26 <Cale> It seems foldl' will be unlikely to be helpful then, unless you have a lot of seq-like operations inside
16:02:37 <mwolak> sorry, it's (Double,Double,Double,Double,Double)
16:02:40 <proton-weapon> if haskell program crash how do you know where it failed?
16:03:00 <Cale> proton-weapon: what error do you get?
16:05:34 <Cale> proton-weapon: you can compile with profiling on and run the program with the RTS parameter -xc, which I think should give some more clues
16:06:16 <proton-weapon> well
16:06:22 <proton-weapon> I am just asking ingeneral
16:07:29 <Cale> What I normally do is test my functions separately, and if they're not working, break them into smaller parts which I can prove by hand that they work.
16:12:02 <Cale> Since you largely don't have to worry about side effects in Haskell, if you know that the individual functions are correct in terms of what they give on each input, you know the program is correct.
16:12:24 <Cale> (you generally don't have to worry about re-creating some context)
16:16:12 <Cale> There are specific sorts of errors which can be annoying to track down if you're not expecting them, like "Exception: <<loop>>" and the errors associated with using an empty list with head or tail.
16:18:21 <Excedrin_> is there something I should read to understand memoization and lazy lists?
16:19:15 <AtnNn> Is there any tutorial on using hdbc? Does anyone know why quux.org is not responding?
16:19:27 <Excedrin> actually, I have a simple question; does memoization happen automatically?
16:19:39 <SamB> no!
16:19:42 <Cale> Excedrin: To some extent
16:19:49 <Cale> but largely no
16:20:04 <Cale> It happens for things which are pattern (rather than function) bound
16:20:27 <Cale> and for those, it happens so long as they remain in scope
16:21:36 <Cale> Optimisations in GHC can affect that behaviour though
16:40:11 <proton-weapon> wow
16:40:16 <proton-weapon> java scares me
16:40:19 <proton-weapon> so does perl
16:40:24 <proton-weapon> yet so many use them
16:40:30 <proton-weapon> are they safer than haskell?
16:40:36 <Revision17> safer?
16:40:43 <proton-weapon> like less buggy
16:40:49 <proton-weapon> practical
16:40:51 <palomer> no haskell is better than safe haskell
16:40:53 <proton-weapon> or are they jsut crap
16:40:59 <palomer> haskell and practical don't belong in the same sentence
16:41:45 <Revision17> proton-weapon: nobody ever got fired for using Java, etc, etc
16:41:59 <Revision17> plus the libraries of haskell and the like aren't as rich as java/.net/etc
16:42:18 <palomer> I've written applications in java which would have required 10 times the amount of work to write in haskell
16:42:26 <palomer> (for want of libraries)
16:42:32 <palomer> and would be substantially slower
16:42:48 <palomer> (unless I'm willing to write ugliness that's found in the shootout)
16:43:07 <madpickle> it's about picking the right tool for the job
16:43:11 <palomer> I've written things in haskell which would have required 10 times the amount of work to write in java
16:43:15 <madpickle> you wouldn't use assembler to do scientific analysis
16:43:23 <madpickle> that'd be a bit more up haskells' creek
16:43:28 <proton-weapon> hm
16:43:49 <proton-weapon> how about building a rules engine to calculare commission on phone calls in diffrent states for a telcom?
16:43:59 <proton-weapon> compute
16:44:17 <palomer> you'll have to describe the problem more exactly than that, as well as the requirements
16:44:27 <proton-weapon> 50 states
16:44:27 <Revision17> is there any existing code that you would need to interact with?
16:44:32 <proton-weapon> local and long distance
16:44:34 <madpickle> and who will maintain it?
16:44:38 <proton-weapon> differeing taxes
16:44:42 <proton-weapon> differeing contracts
16:44:44 <proton-weapon> me!
16:44:45 <madpickle> if it's someone unfamiliar with haskell (probably) then it's not really a good choice
16:44:47 <proton-weapon> me alone!
16:44:48 <madpickle> right
16:44:49 <palomer> is there a limit to the amount of ram and cpu used?
16:44:51 <proton-weapon> I am the phantom menace
16:44:51 <madpickle> but for how long? =)
16:45:02 <palomer> s/available/used
16:45:10 <madpickle> usually stuff like that will transcend the stay of one sole engineer
16:45:12 <madpickle> hence my asking
16:47:51 <Cale> palomer: did you say you've written things in Java which would require 10 times more code to write in Haskell?
16:48:02 <Cale> What was it?
16:48:02 <palomer> yes
16:48:14 <palomer> I would have to have written midi input libraries for 3 different platforms
16:48:30 <palomer> (or created an interface with rtmidi)
16:48:42 <Cale> Yeah, but someone had to write those libraries for Java :)
16:48:43 <palomer> also, it was _all_ imperative
16:48:56 <palomer> Cale: that's why I said : for want of libraries
16:49:12 <palomer> anyways, the performance wouldn't have been up to par
16:49:16 <palomer> heck, I found it too slow in java
16:49:24 <palomer> so I rewrote it in c++ and got a _huge_ speed increase
16:49:48 <palomer> to write the code in c++ took much longer, since it was missing other libraries
16:50:03 <Cale> What was it doing?
16:50:08 <palomer> it's a computer game
16:50:58 <palomer> and the code is quite imperative and straight forward
16:51:16 <palomer> there aren't very many nice relations which are easily expressible in haskell
16:51:28 <palomer> and the classes follow a nice hierarchy
16:51:39 <Cale> well, it's reasonably easy to write imperative code in Haskell
16:51:43 <Excedrin> Step 1: No libraries in Haskell, write it in Java, Step 2: Java is too slow, Step 3: rewrite libraries in C++, now it's fast!
16:52:10 <Cale> hehe
16:52:37 <Cale> Also, you could have written an FFI binding to C libraries and probably got decent performance with a little effort.
16:52:51 <palomer> a lot of effort!
16:52:58 <palomer> the difference between java and c++ was enormous
16:53:00 <Cale> Using the FFI is not that hard
16:53:07 <palomer> I shiver to think of the differences between java and haskell
16:53:12 <Cale> (I mean in Haskell)
16:53:29 <palomer> I would have had to make everything strict
16:53:33 <Cale> why?
16:53:44 <palomer> it would have taken quite a lot of effort
16:53:52 <Cale> why make everything strict?
16:54:14 <palomer> so it uses less ram?
16:54:22 <Cale> Not necessarily
16:54:47 <palomer> don't make me rewrite this so I can prove you wrong!
16:54:50 <scsibug> new haskell user question here... is there a way to use a type class in the definition of a type synonym?
16:55:22 <palomer> anyways, the haskell code would have been identical to the java code, plus I would have had to tweak the haskell code to get performance up to par
16:55:25 <scsibug> something like "type foo = (Double, Bar a)" ?
16:55:36 <shitlog> what does this error mean:
16:55:36 <shitlog>     Conflicting definitions for `bit0'
16:55:36 <shitlog>     In a case alternative
16:55:47 <palomer> and don't give me that "haskell can be as fast as java" jive talking
16:55:49 <palomer> I'll have none of it!
16:55:56 <Pseudonym> Wow.
16:56:07 <Cale> scsibug: You mean like type Foo = (Bar a) => (Double, a) ?
16:56:13 <Pseudonym> That's the first time I've heard "X can be as fast as Java" as an argument for X, even sarcastically.
16:56:19 <Cale> I think that syntax is supported with -fglasgow-exts
16:56:22 <Pseudonym> Normally it's the other way around.
16:56:46 <ricebowl> why is GHC rejecting my case
16:56:48 <palomer> true true
16:57:02 <scsibug> Cale: yes, something like that...thanks, i'll look into that... although maybe I'm just in need of a real type
16:57:24 <Cale> scsibug: actually, make that type Foo a
16:57:38 <Cale> (I missed the type parameter)
16:58:05 <palomer> there's a reason haskell has the reputation of being slow, and it's not because it's fast!
16:58:22 <Cale> palomer: Haskell is usually much faster than Java, at least, when compiled with optimisations
16:59:25 <ricebowl> interesting, javac seems much faster to me than ghc, although that's hardly an objective comparison
16:59:34 <Cale> Haskell has a reputation for being slow from the days before the compilers were very good. (And because people use [Char] to try to do massive amounts of IO.
16:59:44 <Cale> )
16:59:52 <audreyt> GHC is slow ;)
17:00:00 <audreyt> (but it makes very fast programs)
17:00:14 <ricebowl> my program is pretty slow, but what do I know
17:00:20 <Excedrin> mlton is slow ;) (but it makes very very fast programs)
17:00:21 <SyntaxNinja> hi audreyt. 'sup
17:00:28 <ricebowl> anyway, why does this barf:
17:00:32 <Excedrin> oops, wrong channel
17:00:32 <SyntaxNinja> audreyt: still in US? how was yr talk?
17:00:32 <ricebowl> data Mask a = Mask a a
17:00:34 <audreyt> hihi. just delivered my "Deploy Perl 6" talk to YAPC::NA
17:00:37 <ricebowl> case foo of
17:00:41 <audreyt> the audience was quite happy
17:00:45 <ricebowl>     Mask bit0 bit0 -> ...
17:00:57 <Cale> ricebowl: you're reusing the variable bit0
17:00:57 <SyntaxNinja> audreyt: cool
17:01:07 <Cale> ricebowl: Mask bit0 bit1 ->
17:01:10 <ricebowl> oh, crap, I see now
17:01:14 <ricebowl> I wasn't trying to bind it :P
17:01:18 <ricebowl> never code while tired eh
17:01:39 <ricebowl> for some reason I got it stuck in my head that bit0 == (Bit 0) as an equivalence relation
17:01:51 <LordBrain> i read that functional languages have a harder time with large data types
17:01:51 <Pseudonym> BTW, I should point out that the overwhelming majority of Java programs don't need to be "fast" in the sense in which most people use that term.
17:02:21 <Pseudonym> Most Java programs spend most of their time waiting for the next request/keystroke/mouse action.
17:02:25 <Cale> LordBrain: Lazy functional languages have no problem with infinite data types :)
17:02:26 <LordBrain> there's a lot of annoyingly slow java stuff... 
17:02:34 <ricebowl> the faster it is, the sooner it can go back to waiting
17:02:52 <ricebowl> and having had to use PVCS, a horrible Java-based SCCS, I'm not very fond of Java.
17:02:53 <Pseudonym> I'd also wager that in many applications, the Java code isn't the bottleneck.
17:03:07 <Pseudonym> Compared with, say, the database.  Or the network.
17:03:09 <jer> Cale, any language with lazy streams doesn't have that problem conceivably =]
17:03:18 <Pseudonym> Unless it was written by a newbie.
17:03:22 <Pseudonym> Or a moron.
17:03:23 <LordBrain> Cale: hmm i think i worded it wrong, what i read had to do with the passing of large records as parameters to functions and things... in C you can just pass a pointer for example
17:03:25 <ricebowl> or a coder
17:03:34 <ricebowl> usually the bottleneck is some operation which was thought to be fast
17:03:41 <ricebowl> but which was implemented poorly because of a perceived lack of importance
17:03:43 <Pseudonym> After reading The Daily WTF for a few months, I think I know why Java has a reputation for being slow.
17:03:45 <Cale> LordBrain: Basically everything in Haskell is passed as a pointer
17:04:18 <Pseudonym> This, incidentally, is why I like Haskell.  Haskell programmers tend to be better programmers.
17:04:23 <Cale> LordBrain: a pointer to either data or code which computes it
17:04:32 <LordBrain> hmm
17:04:51 <LordBrain> should i be comfortable passing large record types as parameters then?
17:04:57 <Cale> LordBrain: sure
17:05:01 <Pseudonym> Yes.
17:05:09 <palomer> native english latin speakers tend to speak better english
17:05:13 <Pseudonym> It's a bit inefficient to modify large record types a lot.
17:05:18 <Cale> You can pass infinite data structures as parameters even
17:05:21 <Pseudonym> But there are ways around that.
17:05:41 <LordBrain> hmmm
17:05:46 <LordBrain> yeah, you are right
17:05:57 <Pseudonym> If I'm using IO, for example, I often use a large record of IORefs.
17:05:58 <LordBrain> so what i read cant apply to haskell..
17:06:30 <Pseudonym> Or even more likely, a ReaderT stacked on top of IO.
17:06:46 <LordBrain> i dont know ReaderT yet
17:07:26 <Pseudonym> Well, it's a way of passing a read-only data structure around automatically.
17:07:32 <Pseudonym> Monadicaly.
17:07:35 <Pseudonym> Monadically
17:07:43 <LordBrain> i got, IO,Maybe,List, and i am messing around some with State now... i made a bouncing ball program using State... but i dont feel i have a satisfactory handle on it
17:09:41 <LordBrain> i used four Int's to store cordinates and the x and y components of the velocity which only take on values -1,0,1
17:10:13 <LordBrain> i could have done this all without the State monad... and i'm not clear this is a very good use of it.
17:10:26 <proton-weapon> Im a linux admin
17:10:33 <LordBrain> i'd like that job
17:10:34 <proton-weapon> I support legacy c++ perl and java apps
17:10:48 <proton-weapon> permissoin are a bugger when moving to a colo
17:10:57 <proton-weapon> no one knows what apps run as
17:10:58 <proton-weapon> lol
17:11:09 <proton-weapon> complexity is a bitch
17:11:26 <LordBrain> a colo?
17:11:56 <LordBrain> wb Cale
17:11:58 <joe_k> colocated server i presume
17:12:05 <LordBrain> oh 
17:13:30 <Philippa_> LordBrain: if you know you need the dataflow that State provides and not some other form then State's good for the enforcement
17:13:33 <LordBrain> if i wanted speed, i'd probably use c++ not java...
17:14:19 <LordBrain> speedy and portable
17:14:24 <joe_k> i wonder how java compiled to native code with i.e. GCJ compares
17:14:44 <LordBrain> i suppose java might have better libraries for what you are doing tho
17:14:49 <Philippa_> probably not as well as you'd hope once you've got the initial class loading/JITing done
17:16:02 <LordBrain> i think c++ will outlive java
17:16:16 <joe_k> why
17:16:34 <madpickle> legacy systems
17:16:37 <madpickle> that, and java blows
17:16:42 <Pseudonym> BTW, I think it's getting a bit old to insult a technology just by calling it "legacy".
17:16:47 <madpickle> it's not an insult
17:16:50 <Pseudonym> :-)
17:16:54 <madpickle> at least, i didn't mean it that way
17:16:57 <madpickle> legacy does not imply bad
17:16:58 <Pseudonym> Cobol will live forever.
17:17:00 <Pseudonym> Sadly.
17:17:02 <joe_k> i didnt understand it that way
17:17:03 <madpickle> only that for good or worse society moved on
17:17:12 <LordBrain> hmmm well maybe java will live forever then too
17:17:17 <joe_k> i understood it as "c++ is popular and widely used in many existing apps"
17:17:21 <Pseudonym> Right.
17:17:23 <joe_k> all languages live forever
17:17:24 <Pseudonym> OK, fair enough.
17:17:24 <LordBrain> in the sense that cobol has
17:17:39 <madpickle> i like Delphi
17:17:40 <joe_k> you can download an emulator for a MIT LISP machine current in 1969 if you want!
17:17:41 * madpickle ducks
17:17:46 <LordBrain> lol
17:17:58 <madpickle> i had to simulate a PDP-11 in Maude in Uni
17:18:00 <joe_k> or even EDSAC or WHIRLWIRD i bet
17:18:03 <madpickle> it was fun, but damnit, i hate maude
17:18:22 <madpickle> gotta love a language with no proper syntax checking
17:18:25 <Pseudonym> No, I disagree that all languages live forever.
17:18:28 <madpickle> missed a bracket? a dot? a symbol?
17:18:30 <Pseudonym> Who writes AP/L these days?
17:18:34 <madpickle> it'll just happily continue
17:18:35 <Pseudonym> Who maintains AP/L?
17:18:43 <joe_k> heh i think apl died due to standardization of ASCII
17:18:48 <madpickle> there's J
17:18:49 <joe_k> i bet it comes back with the popularization of unicaode
17:18:50 <Pseudonym> Or PL/I?
17:18:50 <joe_k> errr
17:18:52 <joe_k> unicode
17:18:53 <madpickle> which, apparently, is pretty slick.
17:19:06 <Pseudonym> Everyone who used PL/I has moved on.
17:19:08 <LordBrain> there are versions of apl that use ascii now...
17:19:11 <joe_k> i found the sources for multics in pl/i... i wouldn mind finding a compiler ;)
17:19:34 <Pseudonym> There are probably a few Algol systems still around, but I reckon most of them have moved to Ada.
17:19:43 <madpickle> wow
17:19:44 <madpickle> ada
17:19:45 <madpickle> :P
17:20:56 <joe_k> so by dead do you mean "not being written in anymore"?   what if programs are still running written in it
17:21:12 <Pseudonym> I mean "not being maintained any more".
17:21:18 <madpickle> i think this is more of a philosophical question
17:21:23 <madpickle> the languages will still be around
17:21:29 <madpickle> but it will not be used to develop new programs
17:21:32 <madpickle> on new systems
17:21:34 <madpickle> on new platforms
17:21:35 <madpickle> etc.
17:21:36 <LordBrain> maintained is a good way to draw the line i think
17:21:44 <proton-weapon> Im such a nut im guna try to install netbsd with 2 floppies
17:21:44 <madpickle> i agree
17:21:47 <Pseudonym> Yeah.
17:22:23 <LordBrain> that is, it must have a maintained compiler(or interpretter)
17:22:34 <madpickle> you can probably always find those
17:22:34 <joe_k> what platform proton-weapon?
17:22:39 <madpickle> some guy is stupid enough to port em
17:22:46 <joe_k> or you can emulate
17:22:46 <LordBrain> hmmm
17:22:49 <LordBrain> maybe
17:23:03 <madpickle> "duude, i wrote a pong clone in ADA"
17:23:15 <madpickle> "and this Pocket PC doesn't have anything that compiles that. I better make one!"
17:23:22 <madpickle> "I still have my language spec manuals"
17:23:31 <LordBrain> lol
17:23:42 <madpickle> admit it
17:23:45 <madpickle> some of you would do that
17:23:45 <joe_k> i would like to write a pong clone in VHDL
17:23:58 <Pseudonym> I'm wondering how long it'll be before some GNU person clones Delphi.
17:23:59 <madpickle> i'm buying the G15 Logitech keyboard so i can play with the integrated LCD screen
17:24:10 <madpickle> Pseudonym: freepascal / Lazarus is supposedly a work in progress
17:24:11 <Pseudonym> Given that Borland doesn't want to support it any more.
17:24:17 <Pseudonym> Oh, there you go.
17:24:20 <madpickle> afaik, that was just a rumor
17:24:20 <LordBrain> borland doesnt support it?
17:24:30 <madpickle> they do support it, but they phased it out to a sister corp
17:24:31 <madpickle> (so i heaR)
17:24:37 <Pseudonym> Right.
17:24:40 <Pseudonym> It's being wound down.
17:24:55 <madpickle> i hope not
17:24:59 <madpickle> it's nice for app shrinkware :(
17:25:00 <Pseudonym> Borland doesn't want to be a programming tools company any more.
17:25:12 <LordBrain> wow
17:25:16 <Pseudonym> They want to be an iBuzzword Corporate Solutions company.
17:25:17 <madpickle> they want to transcend development and enter the realm of "architecting and enterprise"
17:25:22 <madpickle> like they were in 1999
17:25:23 <madpickle> Inprise
17:25:34 <madpickle> translation: we sell vaporware
17:25:52 <LordBrain> lol
17:26:11 <Pseudonym> No.  Translation: We sell your soul.
17:26:15 <madpickle> heheh
17:26:27 <madpickle> but you must sign a $200k/yr support contract
17:26:32 <Pseudonym> We sell you words that you can sell to your boss.
17:26:49 <LordBrain> how much do words go for?
17:26:54 <madpickle> about a buck each
17:26:59 <Pseudonym> Talk isn't cheap, if that's what you mean.
17:27:17 <Pseudonym> Conslutants charge a lot for talk these days.
17:27:24 <madpickle> anyone who reads academic papers can agree that there's a price per word
17:27:47 <madpickle> sometimes i still feel that many things can be gleaned off the back of a cereal box
17:27:58 <madpickle> but perhaps it's just bias because you know something already
17:28:05 <joe_k> grr why isnt firefox more multithreaded
17:28:18 <madpickle> learn 2 Opera, joe_k
17:28:24 * joe_k hates locking up 10 tabs because of 1 slow site
17:28:34 <madpickle> never had that problem in opera :P
17:28:35 <joe_k> i downloaded opera 9 maybe i should install it ;)
17:28:39 <madpickle> it's nice.
17:28:48 <madpickle> my friends who used ti all ditched FF
17:28:51 <LordBrain> hmmm i havent had that problem with firefox
17:28:53 <madpickle> (i don't work for opera)
17:29:09 <Pseudonym> madpickle: You're right, but something that people don't realise is that manager jargon serves a very important purpose.
17:29:21 <joe_k> i dont know if its firefox or my hard drive, i am starting to suspect i am getting marginal reads with all the hanging i've had recently
17:29:22 <madpickle> of course
17:29:31 <LordBrain> what's that purpose?
17:29:39 <Pseudonym> If you're the CEO of BigCorp, anything you say will be listened to and picked apart.
17:29:47 <Pseudonym> Even saying nothing can affect your share price.
17:30:01 <Pseudonym> Management jargon appeared as a way of saying nothing while still saying something.
17:30:10 <LordBrain> lol
17:30:16 <Pseudonym> I'm only half kidding, BTW.
17:30:26 <madpickle> oh yeah, i see the truth for what it is.
17:30:29 <Pseudonym> Big CEOs are in an almost impossible situation.
17:30:38 <dgoldsmith> PL/I dead? http://pl1gcc.sourceforge.net/
17:30:38 <Pseudonym> I can't blame them for talking gibberish.
17:30:40 <lambdabot> Title: "PL/I for GCC"
17:30:45 <madpickle> it's like watching two Alice AI bots chatting with one another
17:30:54 <Pseudonym> Having said that, middle managers really shouldn't affect it.
17:30:55 <madpickle> they descend into total madness
17:30:58 <Pseudonym> There's no reason why they need to.
17:31:09 <joe_k> thanks lambdabot!
17:32:22 <madpickle> anywho, it's bedtime
17:32:26 <madpickle> thanks for the chat guys
17:32:28 <madpickle> g'night
17:32:37 <Pseudonym> I have to wonder if this PL/I compiler was made by the same people who collect and repair vintage radios.
17:32:40 <Pseudonym> Night.
17:33:25 <LordBrain> hmm maybe some people learned PL/I and  never learned anything else...
18:02:33 <Lemmih> ...
18:02:47 <palomer> Lemmih: you killed the channel
18:02:52 <palomer> @palomer
18:02:52 <lambdabot> Brump!
18:02:58 <Lemmih> Google is asking me what my favorite color is.
18:03:16 <Lemmih> (as part of Googles SoC mid-term evaluates)
18:03:21 <Lemmih> *evaluations
18:06:01 <palomer> I always knew the SoC was respectable!
18:06:25 <Pseudonym> If you say "red.  no, blue...", do you get thrown over the cliff?
18:07:23 <palomer> man I'm bored
18:07:28 <palomer> thinking of picking up a computer game
18:08:31 <Pseudonym> Makes a change from dysfunctional women.
18:08:38 <gregarican> go old school. like mame
18:26:41 <lispy> > let magic = undefined in magic "trick"
18:26:42 <lambdabot>  Add a type signature
18:27:41 <lispy> > let magic = undefined :: String -> String in magic "trick"
18:27:42 <lambdabot>  Undefined
18:27:50 <lispy> you can do magic in haskell!
18:27:56 <lispy> it's just undefined...
18:28:58 <mwc> palomer, get a copy of DooM legacy
18:29:07 <mwc> simple enough to be lots of fun
18:31:33 <lispy> Lemmih: they ask questions like that to test your creativity
18:31:44 <lispy> Lemmih: so no pressure, but you'd better sound witty!
18:58:39 <skew> type classes and gadts seem to get along a bit oddly
18:59:28 <skew> specifically, type class constraints seem to work ok on any variable that's not the exact result type
19:01:08 <skew> http://rafb.net/paste/results/eCNoRj25.html
19:04:35 <skew> oh, another trick is data Ex a where forall b . (Class b) => Equal a b -> b -> Ex a, using data Equal a b where Refl :: Equal a a
19:06:44 <dons> moin
19:06:53 <skew> hi dons
19:08:50 <skew> how is FPS going?
19:09:16 <LordBrain> i'm not clear on what forall does for me... i thought it is implied in every circumstance except a class declaration
19:09:36 <skew> forall before a constructor makes an existential type
19:10:56 <LordBrain> well... thankyou.. and i don't mean to bother you further... however, in case you're wondering, i dont know what those are. :)
19:11:07 <skew> like, for any b you like you can use the constructor at this type, or given a value using that constructor there exists some type it was built with
19:11:48 <skew> hmm, you probably don't know about the data ... where ... syntax making GADTs either - the existential stuff is separate
19:12:26 <LordBrain> well i do know how to define an enumeratored type or a record type using the data keyword.
19:12:36 <skew> data Showable = forall a . (Show a) => Showable a
19:12:51 <skew> notice that a doesn't appear in the type "Showable"
19:13:32 <skew> so if you pattern match on a value you don't know anything about the "a" inside, except that it's an instance of Show
19:13:39 <Philippa> LordBrain: forall's always implied in Haskell 98
19:14:03 <dons> yeah, or in higher ranked things, data Fn = Fn {fn :: forall t. Eq t => t -> t -> Bool}
19:14:21 <skew> which is covered by "Haskell 98"
19:14:36 <Philippa> or rather, "outside Haskell 98" :-)
19:14:58 <LordBrain> well in the case of the function, is that forall t needed? or is it implied?
19:15:10 <LordBrain> i'm only interested in the non-implied forall
19:15:13 <skew> well, I've got to go but I'll check logs if anybody talks about my GADT example
19:15:53 <LordBrain> Philippa: well, does haskell 98 have such a thing as existential types?
19:16:25 <Philippa> no
19:16:49 <LordBrain> so basicly.. if i search on existential types in haskell.. i may be enlightened
19:17:03 <Philippa> outside H98, you need to understand what the foralls mean - which varies slightly from context to context
19:17:29 <LordBrain> hmm that sounds complex
19:17:30 <Philippa> although not necessarily so much. Existential types in Haskell aren't really existential, although they're isomorphic to types that are
19:18:01 <LordBrain> i dont know what it means to be existential if you are a type
19:18:12 <Philippa> to have an existential quantifier in the front
19:18:17 <Philippa> which'd be exists rather than forall
19:18:19 <LordBrain> hehehe
19:18:37 <LordBrain> i've never seen the exists one
19:18:39 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
19:18:40 <lambdabot> Title: "7.4. Type system extensions"
19:18:45 <LordBrain> thanks dons
19:18:56 <Pitarou> While folks are enlightening one another, can somebody fill me in on what GADTs are all about?  I gather that they are something like "dependent types lite".
19:20:10 <Pitarou> (If that's not too much trouble, etc.)
19:20:52 <ricebowl> is it possible to do this:
19:20:53 <ricebowl> class B a b => A a -> b where ...
19:20:53 <ricebowl> class A a b => B a -> b where ...
19:22:33 <dons> well, that -> in the class head isn't ok.
19:22:40 * Pitarou nods
19:22:46 <Cale> that's a syntax error
19:23:02 <dons>     Cycle in class declarations (via superclasses):
19:23:02 <dons>       A.hs:1:0-25: class (B a b) => A a b
19:23:02 <dons>       A.hs:3:0-25: class (A a b) => B a b
19:23:06 <ricebowl> yeah, sorry
19:23:10 <Pitarou> dons: Unless you're using some kind of extension that I'm unfamiliar with.
19:23:13 <ricebowl> A a b | a -> b
19:23:16 <ricebowl> and B a b | a -> b
19:23:26 <ricebowl> I suspected that... argh
19:23:53 <ricebowl> how frustrating. I have an expression class and a "type" class
19:24:54 <ricebowl> hmm
19:25:04 <Pitarou> ricebowl: What are you trying to do?
19:25:11 <ricebowl> uh, it's a tad complicated
19:25:22 <ricebowl> I'm writing a program optimizer/analysis tool
19:25:45 <Pitarou> Fair enough.  I won't press you too hard on the matter.
19:26:02 <ricebowl> basically I have a structure that represents the state of the machine
19:26:16 <ricebowl> a class called Register which defines some primitives for reading/writing that context structure
19:26:29 <ricebowl> class Register r w e | r -> w e
19:26:57 <ricebowl> r is the register type, w is an appropriate type from Data.Word, and e is a type representing expressions of that size
19:27:13 <ricebowl> now I need to convert an "e" into a "w", but the only way to do that is to make a class for the e's
19:27:17 <ricebowl> which needs to know about r.
19:28:45 <ricebowl> the problem is that since the parameter does not involve r in any way, the compiler can't figure out which instance of Register is being used, so I can't include it as part of the Register class
19:28:47 <ricebowl> I need another.
19:28:56 <ricebowl> but the (r, w, e) combination *must* match exactly
19:30:20 <Pitarou> I don't understand what you mean by 'converting an "e" into a "w"'.
19:30:38 <Pitarou> OH ... hang on.
19:30:40 <Pitarou> Yes I do.
19:30:45 <Pitarou> I think.
19:32:15 <Pitarou> But I don't think I can be of much help to you.  It would take me quite some time to climb up to the level of abstraction at which you're working.
19:32:48 <ricebowl> I was kind've afraid of that :/
19:32:56 <Pitarou> Sorry.
19:33:16 <ricebowl> class Bits w => X86Reg r w e | r -> w e where
19:33:16 <ricebowl> 	rdcxtr :: r -> X86Cxt -> e
19:33:31 <ricebowl> I wrote a function called rdcxtri which is :: r -> X86Cxt -> w
19:33:40 <ricebowl> so I need a function with type e -> w, basically
19:33:49 <ricebowl> I wonder
19:33:58 <Philippa> if you know e and w, do you know r?
19:34:09 <ricebowl> unfortunately not because of the way the system works
19:34:11 <Philippa> that is, can you add w e -> r as a second fundep?
19:36:00 <ricebowl> how?
19:36:08 <ricebowl> can I just add | w e -> r?
19:36:32 <ricebowl> actually what would be even better is to write r -> w | r -> e | w -> r | e -> r
19:36:34 <ricebowl> if that's possible.
19:37:48 * Pitarou was on the verge of suggesting that ricebowl should consult Philippa, but was beaten to the punch.
19:37:57 <ricebowl> :P
19:39:21 <Pitarou> Can anybody tell me what a "monotype" is?
19:40:35 * lispy guesses that it might be the opposite of a polymorphic type
19:42:14 <palomer> Pitarou: a monotype is a type where none of the type variables are universally quantified. does this help?
19:42:38 <Pitarou> Er ... yes, I think it does.  Thanks.
19:43:04 <lispy> palomer: so [a] is not, but [Int] is?
19:43:48 <jrmole> hmm, i'll try this again: can anyone here explain:
19:43:50 <jrmole> @kind (->)
19:43:52 <lambdabot> ?? -> ? -> *
19:43:55 <Pitarou> So "[a]" is a monotype, but "Eq a =>[a]" isn't?
19:44:12 <palomer> [a] is a monotype
19:44:19 <palomer> forall a. [a] isn't
19:44:55 <lispy> Pitarou: in my understanding "Eq a => [a]" just places a constraint on the type a
19:44:58 <palomer> in the expression \x -> (\y -> y) x , the subexpression \y -> y has a monotype who's shape is a -> a
19:45:20 <lispy> @type head
19:45:22 <lambdabot> forall a. [a] -> a
19:45:28 <Philippa> lispy: being more precise, on the range of possible values/types for the type variable a
19:45:40 <lispy> so if i wrote head :: [a] -> a, would it be a monotype?
19:45:50 <palomer> lispy: it would
19:45:53 <lispy> Philippa: ah yeah
19:45:55 <Pitarou> @type \x -> (\y -> y) x
19:45:56 <lambdabot> forall t. t -> t
19:46:15 <lispy> palomer: then did i give head the wrong type?
19:46:34 <palomer> > let head:: a->a ; head (a:b) = a in head [1]
19:46:35 <lambdabot>  Couldn't match the rigid variable `a' against `[a1]'
19:47:11 <palomer> do you see why it failed?
19:47:20 <lispy> > let head :: [a] -> a; head (a:) = a in head [1]
19:47:20 <lambdabot>  Parse error in pattern
19:47:29 <lispy> > let head :: [a] -> a; head (a:b) = a in head [1]
19:47:30 <lambdabot>  1
19:47:39 <lispy> yeah, because you said head :: a -> a ;)
19:47:44 <palomer> ahh, haskell typing is screwy
19:47:45 <palomer> <:o
19:48:08 <palomer> well, it would fail in sml
19:48:25 <lispy> iirc forall is implicit in H98
19:48:52 <lispy> Philippa: can you comment?
19:50:03 <Pitarou> Okay.  I'm lost.  What's the difference between "forall a . [a]" and "[a]"?
19:50:22 <lispy> Pitarou: yeah, that's where i started at in this discussion :)
19:50:39 <palomer> H98 has a confusing annotation system
19:50:48 <lispy> Pitarou: i think, in H98 that the forall is implicit in this case
19:51:49 <Pitarou> lispy: If that is so, then why does palomer (whom I would never doubt) tell us that one is a monotype and the other isn't?
19:52:06 <palomer> > let head [a] = (a::t) in head [1]
19:52:07 <lambdabot>  a :: t
19:52:07 <lambdabot>   In the definition of `head': head [a] = (a :: t)
19:52:07 <lambdabot>   In the defi...
19:52:17 <palomer> there, that should convince you
19:52:25 <lispy> Pitarou: because outside of H98 where it is not implicit he's absolutely correct (if i understand the universe correctly on this issue)
19:52:48 <palomer> someone type that in with ghci -fglasgow-exts
19:53:12 <palomer> now, in that definition head is returning a and we're saying that a has monotype t
19:53:42 <palomer> now monotype t cannot be specified to Int
19:53:46 <palomer> so it fails
19:53:57 <palomer> is that clearer?
19:54:01 <lispy>     Inferred type is less polymorphic than expected
19:54:02 <lispy>       Quantified type variable `t' is mentioned in the environment:
19:54:02 <lispy>         a :: t (bound at <interactive>:1:10)
19:54:03 <lispy>         head :: [t] -> t1 (bound at <interactive>:1:4)
19:54:38 <lispy> palomer: well, what prevents it from being Int?
19:54:49 <palomer> it's not polymorphic!
19:54:51 <Pitarou> > let head [a] = (a::t) in head [1]
19:54:52 <lambdabot>  a :: t
19:54:53 <lambdabot>   In the definition of `head': head [a] = (a :: t)
19:54:53 <lambdabot>   In the defi...
19:55:03 <lispy> palomer: is t inhabited at all?
19:55:14 <palomer> inside that definition it is
19:55:18 <palomer> outside it isn't
19:55:32 <lispy> hmm..that seems almost philosophical ;)
19:55:39 <tato> how can i write a func to generate all n-length tuples of a list? for ex, I want: ntuple 2 [1,2,3,4]->[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] and so forth 
19:56:03 <dons> they're not tuples :)
19:56:05 <lispy> tato: sequence might be of use here
19:56:11 <dons> they're lists of length n
19:56:36 <tato> dons: yea i know, though you can't write a function to return various lengthed tuples
19:56:37 * lispy tries to think of a list comp solution
19:56:44 <dons> right.
19:56:57 <tato> sequences?
19:57:09 <lispy> @hoogle sequence
19:57:10 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
19:57:10 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
19:57:10 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
19:57:27 <lispy> > sequence [[1,2,3,4]]
19:57:28 <lambdabot>  [[1],[2],[3],[4]]
19:57:50 <lispy> but dons is right
19:57:57 <lispy> those aren't tuples
19:58:20 <palomer> then again, I don't think we should be talking about monotypes when talking about the haskell type system
19:58:35 <lispy> > (\xs -> [(x,y) | x <- xs, y <- xs]) [1,2,3,4]
19:58:36 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
19:58:59 <lispy> palomer: why?
19:59:20 <Pitarou> ntpule n (x:xs) = map (x:) (ntuple (n-1) xs) ++ ntuple n xs
19:59:34 <palomer> well, unless we're talking about subexpressions
19:59:40 <palomer> here's a better example:
19:59:48 <Pitarou> ntuple 0 _ = []
19:59:58 <Pitarou> I think that solves it, tato,.
20:00:05 <palomer> >let head x = let tail z = (x:z) in tail
20:00:08 <palomer> > let head x = let tail z = (x:z) in tail
20:00:09 <lambdabot>  Parse error
20:00:53 <palomer> weird
20:00:59 <palomer> ghci doesn't do anything with that input
20:01:22 <palomer> can anyone check this?
20:01:34 <Pitarou> > let ntuple 0 _= []; ntuple n [] = []; ntuple n (x:xs) = map (x:) (ntuple (n-1) xs) ++ ntuple n xs; in ntuple 2 [1, 2, 3, 4]
20:01:35 <lambdabot>  []
20:01:41 <Pitarou> Oh well.  I tried.
20:01:52 <tato> hmm yea I'm getting some weird error Pitarou 
20:02:06 <tato> Program error: pattern match failure: ntuple instNum_v32 1 [] on hugs??
20:02:27 <Pitarou> palomer: that code looks totally weird.  I don't understand what you're trying to do!
20:02:40 <palomer> in that code, tail is not polymorphic
20:02:55 <palomer> pretty funky, eh?
20:03:25 <lispy> palomer: you're off by an 'in' if i read that correctly
20:04:25 <lispy> palomer: so ghci probably thinks the first let is defined in a do block
20:04:27 <palomer> > let head x = (let tail z = (x:z) in tail) in head
20:04:28 <lambdabot>  Add a type signature
20:04:44 <palomer> whoa, why would I need a type signature?
20:05:07 <lispy> @type let head x (let tail z = (x:z) in tail) in head
20:05:09 <lambdabot> parse error on input `in'
20:05:22 <lispy> @type let head x =(let tail z = (x:z) in tail) in head
20:05:23 <lambdabot> forall a. a -> [a] -> [a]
20:05:49 <palomer> yeah, anyways, tail is _not_ polymorphic in the expression let tail z = (x:z) in tail
20:05:52 <lispy> palomer: i think it's just an evaluation problem with 'in head'
20:06:21 <lispy> but how can you tell?
20:06:28 <sjanssen> > let ntup 0 _ = [[]]; ntup n [] = []; ntup n (x:xs) = map (x:) (ntup (n - 1) xs) ++ ntup n xs in ntup 3 [1 .. 4]
20:06:30 <lambdabot>  [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
20:06:47 <palomer> because the type of tail is a -> [a], where a is in the context (namely, x :: a), do we agree?
20:06:54 <palomer> you can't generalize variables that are in the context
20:07:02 <lispy> > foldl1 (,) [1,2,3]
20:07:03 <lambdabot>    Occurs check: cannot construct the infinite type: a = (a, a)
20:07:03 <lambdabot>    Expec...
20:07:05 <palomer> notice:
20:07:09 <Pitarou> sjansson: 'Doh!  I forgot the extra "[]".  Thanks.
20:08:20 <lispy> hmm..so how would you convert arbitrary length lists into the cooresponding length tuples in a general fashion?
20:08:41 <sjanssen> lispy: typeclass-foo?
20:08:45 <palomer> > let head x = (let tail z = (x:z) in (tail 4)) in head 
20:08:46 <lambdabot>  add an instance declaration for (Num [a])
20:08:46 <lambdabot>   In the definition of `ktx': k...
20:09:09 <lispy> sjanssen: i was thinking maybe a repeat application of zip but i'm not sure if that works...you'd probably get nested tuples
20:09:22 * Pitarou gives up and goes to bed.
20:09:22 <sjanssen> yes, you'd get nested tuples
20:09:32 <palomer> Pitarou: don't worry about monotypes
20:09:38 <Pitarou> Maybe it will make sense after a few more hours rest.
20:09:42 <palomer> it won't
20:09:48 <palomer> ignore their existence
20:09:48 <sjanssen> @palomer
20:09:49 <lambdabot> That's nuts!
20:09:54 <Pitarou> Thanks for trying, palomer.  :-)
20:10:20 <dons> hey sjanssen ~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~
20:10:26 <dons> grr. wifi brain explosion
20:10:30 <lispy> heh
20:10:32 <sjanssen> hey dons
20:11:20 <dons> i think we worked out how to tweak irssi to not interpret a delay after an ^] as a chance to input literals, but hmm, what was it again?
20:11:21 * lispy realizes it's almost time to go to the pub...oh better pay bills real quick
20:11:46 <dons> sjanssen: how's the hacking going?
20:12:00 <dons> i've been reading your soc repo, and will have some comments for you in the next hour or so
20:12:08 <lispy> dons: speaking of hacking...i was able to get wxHasklel installed ;)
20:12:13 <dons> cool :)
20:12:19 <dons> on windows? or a unix box.
20:12:30 <lispy> windows
20:12:37 <lispy> our software is windows only :(
20:12:40 <dons> did you try gtk2hs?
20:12:44 <sjanssen> dons: hacking is going well.  Right now I'm thinking about how to tackle this unicode thing
20:13:07 <dons> sjanssen: have you got a copy of simonM's utf8 packed string?
20:13:09 <dons> library
20:13:17 <lispy> nope, i get wxHaskell working and some of the emails from haskell-cafe made me think gtk2hs is not right for this project (the file dialogs would scare away our users)
20:13:25 <sjanssen> dons: I didn't know there was one
20:13:36 <dons> sjanssen: let me rustle up the link..
20:13:37 <lispy> sjanssen: what is your soc project about?
20:14:16 <sjanssen> lispy: a unicode version of ByteString is the big thing, and some smaller string related things
20:14:28 <dons> sjanssen: you've got a blog set up?
20:14:44 <dons> maybe you could just dump darcs commit msgs into it?
20:14:46 <lispy> what is ByteString for? C style strings in haskell?
20:14:56 <dons> fast strings in haskell
20:15:07 <dons> winning the shootout (ssh.. i didn't say that ;)
20:15:20 <lispy> dons: oh, so is it based on FPS?
20:15:38 <dons> ByteString == FPS. sjanssen's working on extensions
20:16:09 <sjanssen> dons: did the shootout make you hack on FPS?  that would be a bit funny ;)
20:16:43 <lispy> iirc things like darcs were the inspiration of FPS
20:16:44 <dons> not really. but i got some experience with the problems of the current string and io library when working on the shootout
20:16:57 <dons> and i use some shootout tests as fps benchmarks
20:17:21 <lispy> dons: so should i worry about upgrading darcs to current fps or what for bytestring at the end of the summer?
20:17:32 <lispy> s/what/wait/
20:17:38 <dons> well, wait.
20:17:43 <dons> wait till 6.6 is out
20:17:50 <dons> sjanssen: http://www.cse.unsw.edu.au/~dons/tmp/packedstring.tar.gz
20:18:27 <dons> i.e. Data/PackedString/UTF8.hs
20:19:06 <lispy> dons: waiting is good since i don't have a lot of time for it now :)
20:23:30 <sjanssen> dons: are you familiar with this code?
20:23:55 <dons> yeah, i've read it a little bit.
20:24:15 <dons> not the utf8 stuff so much though
20:24:41 <dons> but the basic stuff influence fps quite a bit. some packedstring code is in fps
20:24:55 <dons> note that they don't do substrings
20:25:00 <sjanssen> yeah, it looks familiar
20:25:24 <dons> simon sent it to me after last year's hasell workshop to use as the basis for fps
20:25:55 <dons> e.g. i learnt how to use cpp for strictness from PackedString.hs-inc :)
20:26:14 <sjanssen> I wonder if the lists in all these unpacks (unpack :: PackedString -> [Char]) are deforested
20:26:41 <dons> if you look at fps's README file, you'll see benchmarks of fps against'SPS' which is packedstring.
20:27:18 <dons> yeah, he attempts to ensure they're deforested with the rules stuff
20:27:24 <dons> not sure how solid it is, i've not looked into it
20:28:11 <sjanssen> hmm, unpack is faster with SPS, that's interesting
20:28:32 <dons> not sure if it still is though. haven't run that test for a whle. you could look at it though
20:31:41 <sjanssen> oh, ByteString unpack is strict
20:31:57 <dons> ah ha.
20:32:12 <sjanssen> it probably shouldn't be, eh?
20:32:14 <dons> norpan and dcoutts have complained about this too.
20:33:19 <lispy> does having it strict help with space usage?
20:33:24 <dons> yeah, it should be lazy. 
20:33:33 <dons> well, its an unpack, so it'll suck no matter what
20:33:44 <sjanssen> lispy: no, it hurts memory in nearly every case
20:33:45 <dons> but i think i made it strict as an artifact of the test system i was using
20:34:28 <dons> getting it lazy might be tricky. it might need to be in terms of head, to avoid the IO
20:34:53 <dons> a lazy unpack in terms of peek would need to use unsafeInterleaveIO, i think.
20:35:03 <sjanssen> foldr (:) [] might be okay?
20:35:44 <dons> perhaps write a little test to check (or fix the compilation error in Bench.hs preventing the benchmark suite from running)
20:36:16 <dons> just measure the time for a : length . unpack =<< readFile, perhaps?
20:36:41 <dons> or adopt the packedstring version directly?
20:37:02 <lispy> hmm...landlord didn't cash my check for this month's rent but he did respond to a request i made on a note which went with my payment...that's really odd considering it was 27 days ago
20:38:20 <palomer> cancel the check!
20:40:02 <lispy> palomer: i should call first :)
20:40:13 <palomer> don't let him know!
20:40:18 <palomer> cancel the check and skedaddle!
20:43:56 <dons> sjanssen: you got the unicode spec to play with?
20:44:13 <dons> and maybe some C library atht implements unicode to peek at?
20:44:24 <dons> also, grabbing jhc and looking at how it does unicode might be useful
20:44:35 <dons> (they have a small unicode string lib, iirc)
20:44:40 <dons> ?where jhc
20:44:41 <lambdabot> http://repetae.net/john/computer/jhc/
20:44:56 <dons> always good to know the literature in your area :)
20:44:56 <sjanssen> I've read some docs here and there on unicode.org
20:46:50 <dons> cool
20:47:03 <sjanssen> I'll have to read the jhc stuff too
20:47:33 <dons> http://repetae.net/john/repos/jhc
20:47:35 <lambdabot> Title: "Index of /john/repos/jhc"
20:47:36 <sjanssen> is ByteString.foldr lazy?
20:47:42 <palomer> @palomer
20:47:43 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
20:48:26 <dons> sjanssen: no, i don't think s.o. its array fuseable to make up for that.
20:48:34 <dons> however, dcoutts is looking at making it lazy I think.
20:48:56 <dons> he'll be back from holidays (france!) at the end of the week, so we can talk to him about his plans for foldr
20:49:12 <sjanssen> okay, so foldr for lazy unpack won't work
20:49:16 <dons> http://repetae.net/john/repos/jhc/UTF8.hs
20:49:21 <sjanssen> foldr are pretty much the same issue
20:49:35 <sjanssen> erm, foldr and unpack are pretty much the same issue
20:49:41 <dons> right. foldl should always be strict, and foldr lazy.
20:52:01 <Pseudonym> Actually, I'm not convinced that foldl should always be strict.
20:52:11 <dons> here's the soc-fps commits graph :) it'll get updated nightly. http://www/~dons/images/commits/community/fps-commits.png
20:52:17 <Pseudonym> For the most part, that's almost always what you want.
20:52:33 <Pseudonym> But there are reasonable circumstances where it isn't/
20:53:02 <dons> Pseudonym: now, what was that language before haskell, started with O?, hmm. can't remember.
20:53:07 <dons> anyway, it didn't have a lazy foldl
20:53:12 <Pseudonym> Orwell?
20:53:16 <dons> ah, yes.
20:53:22 <dons> foldl == foldl' in Orwell
20:53:36 <Pseudonym> Not that totalitarianism is a good model, or anything.
20:54:07 <dons> and its hard to find a case in Haskell where you need a lazy foldl. so in fps for example foldl == foldl'
20:55:26 <Pseudonym> Well, any circumstance where the binary operation is possibly lazy in the left argument.
20:55:48 <Pseudonym> I can imagine that you might use foldl to implement alpha-beta pruning, for example.
20:55:54 <Pseudonym> I don't know why, but you might.
20:57:20 <dons> yeah, its always possible to construct a case, but the majority of uses you want a strict accumulator, and when you don't people mail haskell-cafe@ complaining of fundamental flaws in the fp model :)
20:57:33 <Pseudonym> :-)
20:57:47 <Pseudonym> OK, I'll agree with you that foldl and foldl' should be swapped.
20:57:52 <Pseudonym> How about that?
20:57:57 <dons> yep
20:58:25 <Pseudonym> Cool.
20:59:00 <Pseudonym> I should also point out that the argument for strict being the default is stronger if you have inter-module inlining.
20:59:15 <Pseudonym> Because the compiler has a chance to optimise out the seq.
20:59:58 <dons> hmm, yeah, that's interesting
21:00:35 <Pseudonym> If the operation is a constructor function, for example (e.g. foldl-based reverse), the eval is undesirable.
21:03:58 <dons> bah, hugs is still in cvs. what is this, the 20th century??
21:04:26 <sjanssen> bah, hugs is still in C.  what is this, the 20th century?? ;)
21:04:39 <dons> hehe
21:04:51 <Pseudonym> CVS is the lowest common denominator, which has its advantages.
21:05:11 <Pseudonym> It's like lex and yacc in that respect.
21:05:26 <dons> well, i can't remotely graph its commit activity :) all other haskell impls are in darcs..
21:05:42 <Pseudonym> Oh, now the truth is coming out.
21:06:01 <Pseudonym> "I hate CVS because I haven't implemented anything for it."
21:06:02 <Pseudonym> Slacker.
21:06:15 <dons> anything in darcs is easy, since you just wget the _darcs/patches ls -l list
21:06:37 <Pseudonym> So what does cvs log look like?  Chopped liver?
21:06:46 <dons> somewhat
21:07:05 <Pseudonym> Somehow I knew you'd respond with something like that.
21:07:25 <Pseudonym> But I couldn't resist the Kath & Kim reference.  Sorry.
21:07:27 <dons> its some kind of internal organ anyway
21:07:30 <dons> hehe
21:08:00 <Pseudonym> Gotta go to the post office.  BBS
21:34:15 <joe_k> bourbon street++
21:48:43 <dons> http://www/~dons/images/commits/community/
21:48:44 <lambdabot> Title: "Haskell Community Project Activity"
21:48:54 <dons> http://www.cse.unsw.edu.au/~dons/images/commits/community/
21:48:55 <lambdabot> Title: "Haskell Community Project Activity"
21:52:43 <RyanT5000> does the default (==) in GHC check for StableName equality before checking for deep equality?
21:53:15 <sjanssen> I believe it's always deep equality
21:53:21 <RyanT5000> hm...
21:53:59 <sjanssen> you could have an instance of Eq such that x /= x
21:54:25 <RyanT5000> yeah, i was asking about the "deriving" version
21:55:11 <dons> it'll recursively descend into the structure. so deep is the default.
21:55:19 <RyanT5000> hm, alright
21:55:24 <dons> some instances might short circuit though, like fps
21:55:33 <ricebowl> is there any way to mark function parameters as strict?
21:55:46 <dons> yep, ricebowl, hang on 3 seconds ...
21:56:05 <dons> #define STRICT2(f) f a b | a `seq` b `seq` False = undefined
21:56:14 <dons>         STRICT2(go)
21:56:14 <dons>         go _ []     = return ()
21:56:15 <dons>         go p (x:xs) = poke p (k x) >> go (p `plusPtr` 1) xs
21:56:19 <dons> cpp forever!
21:56:25 <RyanT5000> lol
21:56:31 <dons> if you're using ghc 6.5 though, you can use bang patterns
21:56:38 <dons> i.e. go !p (!x:xs) = ...
21:56:43 <dons> but that's very new
21:56:56 <ricebowl> I've got 6.4.1, hmm... didn't know 6.5 was out
21:57:00 <dons> its not
21:57:03 <ricebowl> heh :P
21:57:05 <dons> odd numbers are dev versions
21:57:09 <ricebowl> thought so
21:57:20 <dons> so the most portable way, and excellent on performance, is the cpp trci
21:57:21 <ricebowl> ah well, it would massively speed up my program
21:57:23 <dons> trick
21:57:35 <ricebowl> or at least I suspect.
21:57:50 <dons> @google STRICT3 ByteString
21:57:53 <lambdabot> http://www.haskell.org/haskellwiki/Wc
21:57:54 <lambdabot> Title: "Wc - HaskellWiki"
21:58:01 <dons> almost
21:58:01 <ricebowl> is there any way to get GHCi to evaluate an expression without producing a result?
21:58:03 <RyanT5000> heh, i just converted all the OpenGL API i'm currently using, and then some, into a lazy datastructure >.>
21:58:22 <dons> ricebowl, more info? you want to _force_ an eval?
21:58:27 <ricebowl> yeah
21:58:30 <ricebowl> let foo = ...
21:58:30 <dons> @hoogle evaluate
21:58:31 <lambdabot> Control.Exception.evaluate :: a -> IO a
21:58:32 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
21:58:32 <dons> @hoogle seq
21:58:33 <lambdabot> Prelude.seq :: a -> b -> b
21:58:33 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
21:58:33 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
21:58:43 <dons> or deepSeq , if you need to go dee
21:58:44 <ricebowl> and then I want to eval foo somehow
21:58:45 <dons> p
21:58:55 <dons> evaluate or seq are the usual way
21:59:12 <ricebowl> hm
21:59:18 <dons> deepSeq for those who need to force the eval all the way to normal form (not weak head normal)
21:59:21 <ricebowl> why does it wrap it in IO?
22:00:06 <dons> evaluate :: a -> IO a
22:00:06 <dons> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
22:00:31 <dons> use `seq` in  pure code
22:00:35 <ricebowl> I see... seq is just strange to me
22:00:45 <dons> it is strange
22:00:59 <ricebowl> what I would *like* to do is have GHCi start evaluating my computation since it takes time to type it in and so forth
22:01:13 <ricebowl> and the interpreter isn't the fastest thing anyway ;)
22:01:18 <dons> forkIO ?
22:02:02 <ricebowl> no idea what that does
22:02:07 <ricebowl> @hoogle forkIO
22:02:08 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
22:02:10 <dons> fork a thread that runs concurrently
22:02:15 <ricebowl> strange
22:02:17 <dons> @docs Control.Concurrent
22:02:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
22:02:50 <dons> i don't really understand what you mean by " start evaluating my computation since it takes time to type it in .." ?
22:14:51 <RyanT5000> is there any way to turn a record update into a function?
22:15:21 <RyanT5000> without doing something like updateRecord r stuff = r { update = stuff }
22:18:50 <dons> \st -> st { minibuffer = s } ?
22:18:56 <dons> but no, not really
22:19:08 <RyanT5000> i'd love to be able to use it like a slice
22:19:14 <RyanT5000> ({ thing = asdf})
22:19:24 <RyanT5000> i don't see any reason that couldn't be the case
22:19:32 <RyanT5000> (not that i'm an authority on the subject)
22:20:50 <dons> the record labels aren't first class thingies, so they can't be passed around, this limits what you can do 
22:21:35 <RyanT5000> yeah i don't require the labels themselves to be first-class
22:21:39 <RyanT5000> i just want something like
22:21:50 <RyanT5000> \a -> ({thing = a})
22:21:56 <RyanT5000> so thing would still be the label verbatim
22:22:03 <RyanT5000> it's the {} that would be first-class
22:23:38 <dons> well, if thing is constant,then sure, you can write that
22:23:54 <dons> you just can't parameterise over thing
22:24:09 <RyanT5000> oh you can?
22:24:26 <dons> update x = \s -> s { thing = x } -- ?
22:24:33 <RyanT5000> no
22:24:48 <RyanT5000> updateThing s = { thing = s }
22:24:53 <RyanT5000> that's what i want to write
22:24:55 <dons> update what though? ;)
22:25:05 <dons> you're not updating anything there
22:25:15 <RyanT5000> that would be the point-free version :P
22:25:21 <dons> you still have to apply it to some object whose field you want  to update
22:25:28 <dons> well, the lambda seems a compromise
22:25:34 <RyanT5000> yah that's the part i don't want to do :P
22:25:47 <RyanT5000> lol it's not a big deal
22:25:52 <dons> :)
22:26:09 <RyanT5000> i'd just rather an update be a bona fide functiono
22:26:19 <RyanT5000> even though then you'd need to do it like {thing = x} s
22:26:24 <RyanT5000> instead of the other way around
22:26:36 <dons> records are a bit quirky. 
22:26:42 <RyanT5000> i'd say, lol
22:26:55 <RyanT5000> actually all the namespace-management stuff in Haskell needs an overhaul, imho
22:27:22 <RyanT5000> like lexical closures for types ;)
22:27:34 <RyanT5000> now that i would like
22:27:44 <RyanT5000> then i wouldn't need any global typedefs
22:28:41 <RyanT5000> well, i suppose i technically have the choice of parameterizing the crap out of every data declaration
22:28:56 <RyanT5000> but i tend to discount choices that require me to write n^2 code
22:35:53 <RyanT5000> woohoo,  i think i get to use an existential
22:35:54 <RyanT5000> for real
22:36:38 <RyanT5000> here's what i'm trying to do: I have multiple different kinds of Shaders (as in vertex/pixel shader)
22:37:06 <RyanT5000> each kind of shader has a different constant register allocation scheme (potentially)
22:38:04 <RyanT5000> bah nevermind i doubt anyone's interested :P
22:38:20 <RyanT5000> (and i don't know exactly what i'm talking about yet anyway :P)
22:40:28 <RyanT5000> although there is a more fundamental programming languages issue at stake here, so if i figure out what i'm doing i might say something about it
22:42:06 <wolverian> oh, please elaborate, I'm interested
22:43:01 <RyanT5000> i will, as soon as i get unconfused :P
22:43:42 <RyanT5000> ok well here's my problem
22:44:05 <RyanT5000> i have a certain number of registers, which are essentially function parameters
22:44:30 <RyanT5000> now, in some shaders, registers 0-15 might be used to store the transformation matrix
22:44:40 <RyanT5000> but some shaders might not use that (not that i can think of any that wouldn't)
22:45:11 <RyanT5000> i need a way to make closures out of these things
22:45:28 <RyanT5000> so if you set the transformation matrix in some top-level thing
22:45:38 <RyanT5000> every shader that uses a transformation matrix needs it to get loaded
22:46:08 <RyanT5000> whereas other shaders need other things loaded in their place
22:46:17 <RyanT5000> er, its place
22:46:44 <RyanT5000> i think it's something like environment-passing
22:46:51 <wolverian> dynamic binding?
22:46:54 <RyanT5000> yeah
22:47:18 <wolverian> would implicit parameters do the trick?
22:47:32 <RyanT5000> what are they?
22:47:48 <wolverian> dynamic binding, essentially. :)
22:48:01 <RyanT5000> well, i'm trying to figure out how to set it up
22:48:13 <RyanT5000> because i need stuff like translate, scale, rotate, etc.
22:48:50 <RyanT5000> but they only affect shaders that use that variable
22:48:52 <wolverian> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters
22:48:54 <lambdabot> Title: "7.4. Type system extensions"
22:48:55 <RyanT5000> so i need shadowing
22:49:24 <wolverian> may I ask.. why are you coding this in haskell and not, say, in verilog or vhdl?
22:49:37 <RyanT5000> i'm not actually coding this
22:49:41 <wolverian> oh
22:49:49 <RyanT5000> this is in essentially  DSL i'm implementing
22:49:55 <RyanT5000> *a DSL
22:50:10 <wolverian> ala glsl etc?
22:50:17 <RyanT5000> right
22:50:27 <wolverian> sounds like fun
22:50:33 <RyanT5000> lol yeah, well, it has been up until this point :P
22:50:43 <RyanT5000> although i think this is the only hard thing datastructure-wise
22:50:49 <wolverian> I haven't used dynamic binding in haskell, but implicit parameters would certainly work if that's what you need
22:51:04 <RyanT5000> well i need to implement implicit parameters in the DSL
22:51:18 <RyanT5000> there aren't any haskell functions i'll be calling with dynamic parameters
22:51:25 <RyanT5000> just shaders
22:51:35 <wolverian> oh, yeah. I don't know about implementation techniques there. I assume it depends on your type system. 
22:51:42 <RyanT5000> yeah
22:52:22 <RyanT5000> ah
22:52:30 <RyanT5000> i think i'll have each shader input schema have its own type
22:53:08 <RyanT5000> then i'll have something like a Map TypeRep Dynamic
22:53:29 <RyanT5000> i wonder how slow that is :-/
22:53:51 <wolverian> just complain here if it is excessively slow.. it'll get fixed in the next version ;)
22:53:56 <RyanT5000> lol
22:54:22 <RyanT5000> it can't be too bad
22:54:27 <RyanT5000> but believe me, i will complain
22:54:40 <RyanT5000> kind of how i am complaining on a routine basis about TH not working with profiling, lol
22:54:45 <RyanT5000> i need both!
22:54:58 <wolverian> you really need TH? 
22:55:03 * wolverian hasn't, yet
22:55:04 <RyanT5000> SerTH is really sexy
22:55:29 <RyanT5000> i despise the concept of writing my own serialization routines :P
22:55:41 <RyanT5000> although i will do so if TH doesn't get fixed by the time i get around to it
22:56:01 <RyanT5000> although i might be able to separate out the TH-using stuff and the profiling-needing stuff
22:56:40 <RyanT5000> i'm not sure if it's possible to do a profiling build while importing a non-profiling build of a library though
22:57:13 <wolverian> mm. serth looks pretty nice. I have a bias against preprocessors though.. 
22:57:20 <RyanT5000> really?
22:57:22 <RyanT5000> how come?
22:57:38 <wolverian> I guess it feels dirty if it's not a part of the language.
22:57:57 <RyanT5000> hm, well TH is integrated really nicely
22:58:01 <wolverian> it's not such a bad thing in haskell, but in perl it is somewhat fragile, due to the incredibly complex syntax.
22:58:07 <wolverian> that's where I got the bias from, probably.
22:58:15 <RyanT5000> that sounds like everything in perl, lol
22:58:29 <wolverian> the house of cards is a noble house .. 
22:58:33 <RyanT5000> lol
22:58:52 <wolverian> perl is just an interface to CPAN. :) don't worry, we're fixing it.
22:59:05 <RyanT5000> lol
22:59:16 <RyanT5000> replace it with haskell >.>
22:59:26 <wolverian> perl6 is taking a lot from haskell. 
23:00:54 <wolverian> well, STM and the type theory, anyway.
23:01:40 <RyanT5000> what's STM stand for?
23:01:50 <wolverian> software transactional memory
23:01:53 <RyanT5000> ah right
23:02:07 <RyanT5000> i've heard a lot of talk about that around here recently
23:02:13 <RyanT5000> though i can't say i know anything about it :P
23:02:17 <RyanT5000> i'm still quite the Haskell noob
23:02:22 <RyanT5000> i've only been on it since April
23:02:23 <wolverian> as am I. :) 
23:04:12 <wolverian> anyway, STM is an alternative way to do concurrent processing, replacing locks. 
23:04:17 <wolverian> (roughly.)
23:04:25 <RyanT5000> hm, sounds cool
23:04:31 <RyanT5000> i've always wanted to do transactions
23:04:41 <wolverian> right. that's the point
23:04:42 <RyanT5000> my current approach is to just not use anything mutable :P
23:04:50 <wolverian> atomically $ do { ... } 
23:04:54 <RyanT5000> yeah
23:05:03 <RyanT5000> that'd be pretty nice
23:05:08 <wolverian> it works in ghc :)
23:05:14 <RyanT5000> lol awesome
23:05:26 <RyanT5000> what does it protect? IORefs and such?
23:06:06 <wolverian> TVars
23:06:50 <wolverian> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#t%3ASTM
23:07:14 <RyanT5000> ah ok
23:07:52 <wolverian> http://darcs.haskell.org/~lemmih/conjure/Conjure/STM/PeerCtrl.hs uses STM
23:08:16 <RyanT5000> hm
23:08:28 <RyanT5000> well if i have to write something strongly concurrent i'll look into that stuff
23:09:02 <RyanT5000> i just introduced one of my friends to haskell, so he's going to try to write some kind of game engine for PS3 on it
23:09:05 <RyanT5000> *in it
23:09:11 <wolverian> yeah. it's easier than it seems like from reading the haddock. (common haskell problem)
23:09:17 <RyanT5000> he works at a game company, so he'll have access to a dev kit
23:09:24 <wolverian> nice
23:09:30 <RyanT5000> yeah
23:09:44 <RyanT5000> haskell's nice concurrency support should be interesting there
23:10:00 <RyanT5000> although you'll still probably have to explicitly separate cell programs from power programs
23:10:00 <wolverian> have you read http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf ?
23:10:05 <RyanT5000> nope
23:10:29 <wolverian> it's Tim Sweeney's (Unreal fame) talk about "The Next Mainstream Programming Language" (in games programming)
23:10:37 <wolverian> mostly about Haskell...
23:12:35 <RyanT5000> yeah i'm convinced that if the world switched to haskell we'd instantly eliminate most of the bugs
23:12:45 <RyanT5000> well, provided it's not retardedly written haskell
23:13:04 <dons> well, luckily retarded haskell uses induction mostly :) they just forget the base case
23:13:10 <dons> so at least no segfaults
23:13:19 <RyanT5000> lol
23:13:28 <palomer> and sale of ram would go up 1000%
23:13:35 <wolverian> it certainly has a safer type system than C++. so does, for an example, ada. I wonder why sweeney didn't mention it.
23:13:47 <RyanT5000> hah palomer
23:13:56 <wolverian> I guess because it is not pure.
23:14:07 <RyanT5000> windows ram usage >> haskell ram usage
23:14:15 <RyanT5000> i don't even care what you write in haskell or how badly you write it
23:14:19 <RyanT5000> windows will still cause more ram sales
23:14:26 <palomer> I always get skeptical when anyone advocates a single language for all domains
23:14:30 <wolverian> pfft, who uses windows? :) 
23:14:34 <RyanT5000> me :(
23:14:45 <dons> poor RyanT5000 :(
23:14:54 <dons> life is short, use a good OS :)
23:14:57 <wolverian> palomer, me too. 
23:15:05 <ulfdoz> palomer: I remember a statistic, stating increased ram-sales, whenever a new version of windows was introduced on market. ;)
23:15:08 <RyanT5000> palomer: fine, i'll change what i said to "if the java, C++, and other high-level code changed over"
23:15:15 <RyanT5000> which is like 90% of code
23:15:25 <Pseudonym> I get skeptical when anyone advocates a single language for one large application.
23:15:41 * palomer high fives Pseudonym 
23:15:41 <wolverian> DSLs are great.
23:15:56 <wolverian> (and trivial to code nowadays.) 
23:16:04 <Pseudonym> Yup.
23:16:11 <RyanT5000> well people *already* use single languages way too much; i'm just advocating them switching overused languages
23:16:16 <palomer> RyanT5000: you can't actually think that haskell's domain subsumes haskell's, right?
23:16:17 <wolverian> just don't use XML for your DSL..
23:16:19 <Pseudonym> And any language worth its salt can embed a DSL.
23:16:33 <RyanT5000> palomer, what does that mean?
23:16:39 <palomer> err, haskell's domain subsumes c++'s
23:16:48 <palomer> that anything c++ can do, haskell can do better
23:16:56 <RyanT5000> no
23:17:02 <tato> is it possible to do list comprehension for a variable number of lists? like [... | x <- l_1, y <- l_2, ... , z <- l_n] where you can control the number of lists?
23:17:25 <RyanT5000> but i think the vast majority of things people actually do in C++ could be done better in haskell
23:18:05 <palomer> much of the time people don't have the time to formalize things enough to express it as haskell
23:18:08 <Pseudonym> tato: No, but you can come close.  See http://www.dcs.gla.ac.uk/mail-www/haskell/msg01643.html
23:18:13 <lambdabot> Title: "Re: Deriving Enum"
23:18:21 <RyanT5000> palomer: that causes bugs
23:18:32 <RyanT5000> if you can't express something in haskell, you don't understand it well enough to write it without bugs
23:18:43 <RyanT5000> (that's my personal experience, anyway)
23:19:08 <palomer> I remember stacking monad transformers over monad transformers in one application, the encoding was quite tricky
23:19:17 <Pseudonym> Ryan, I'm not sure I agree with that.
23:19:23 <Pseudonym> Haskell does some things inelegantly.
23:19:25 <Pseudonym> Like arrays.
23:19:32 <RyanT5000> true
23:19:38 <RyanT5000> i'm not trying to say haskell is perfect
23:19:42 <RyanT5000> there are tons of things i would change
23:19:55 <palomer> you were advocating changing all java and c++ code to haskell!
23:20:08 <Pseudonym> Yeah.  I'd just change all the Java code.
23:20:21 <RyanT5000> yeah, well i think the things that suck in haskell, for the vast majority of applications, are much less than the things that suck in C++
23:20:31 <Pseudonym> I agree with that.
23:20:41 <Pseudonym> The main thing that sucks with C++ is its C backwards compatibility.
23:20:41 <RyanT5000> so replace my "all" with "nearly all"
23:20:55 <Pseudonym> Unfortunately, that's also one of its greatest strengths.
23:21:04 <RyanT5000> yeah
23:21:04 <Pseudonym> So you can't really win there.
23:21:09 <tato> Pseudonym: so nesting list comprehensions?
23:21:11 <wolverian> well, you need to consider the PHP effect. it keeps the monkeys away from other, nicer scripting languages, which is very nice for users of said languages. perhaps the same thing applies to Java and its peers.
23:21:20 <Pseudonym> tato: Well, you can do that, sure.
23:21:35 * palomer doesn't see DOOM II being written in haskell
23:21:35 <wolverian> (at least it is nice for the users who care about the language's community.)
23:21:40 <palomer> err, DOOM III
23:21:54 <Pseudonym> [ E | p1 <- xs1, p2 <- xs2 ] is the same as concat [ [ E | p2 <- xs2 ] | p1 <- xs1 ]
23:22:16 <Pseudonym> There are more elegant ways to express that, of course.
23:22:26 <Pseudonym> But I do have to ask... what exactly is it that you're doing?
23:22:30 <palomer> or the code found in elevators
23:22:45 <Pseudonym> Actually, I'm not so sure about the elevators.
23:22:57 <tato> trying to take over the world, and also come up with an elegant solution for generating "tuples" of a list
23:23:18 <Pseudonym> The new computer science building (as it was at the time) at unimelb had this cool feature.
23:23:33 <Pseudonym> If you requested a floor from both the outside and the inside of the lift, the doors would open twice.
23:23:33 <RyanT5000> palomer: can you see elevator code being written in C++? it seems like a job for C/asm to me
23:23:39 <RyanT5000> lol
23:23:54 <palomer> the question is, really, how much of an application uses logic which is easily expressible in haskell. This varies wildly
23:24:05 <palomer> RyanT5000: I don't see why it can't be written in C++
23:24:10 <Pseudonym> I don't either.
23:24:23 <dons> > [[x,y] | x <- [0..1], y <- [2..3] ]
23:24:24 <lambdabot>  [[0,2],[0,3],[1,2],[1,3]]
23:24:29 <RyanT5000> it *can* be, but i doubt you'd get much out of it
23:24:37 <palomer> generic libraries?
23:24:43 <palomer> faster deployment?
23:24:43 <RyanT5000> for an elevator?
23:24:50 <dons> tato, was that all you wanted?
23:24:51 <palomer> for many different kinds of elevators
23:24:58 <palomer> you abstract the common functions and you templatize them
23:25:07 <RyanT5000> how much code are we talking about to run an elevator?
23:25:08 <palomer> instead of the unsafe macros
23:25:08 <dons> ah, but you wanted the 'n' tuples
23:25:13 <dons> n-length lists, i mean
23:25:24 <Pseudonym> They don't use tiny microcontrollers in lifts these days.
23:25:28 <Pseudonym> Well, they might in the keypads.
23:25:37 <palomer> RyanT5000: if we can get extra safety at no cost, why not?
23:25:50 <Pseudonym> But the main controller is more likely to be a much bigger board that could handle Haskell no problem.
23:25:59 <tato> dons: that would work if I only wanted doubles
23:26:15 <dons> right
23:26:18 <palomer> but, really, how much of the elevator logic is easily expressible in haskell?
23:26:36 <tato> how to generalize to n-lists without writing new functions with list comprehension for each?
23:26:37 <RyanT5000> why would it be more-easily expressible in C++?
23:26:38 <palomer> and you have stringent memory requirements
23:27:03 <tato> I've been looking at the permutation generating functions with no luck
23:27:21 <Pseudonym> tato, what exactly are you trying to do?
23:27:24 <palomer> RyanT5000: I see operating an elevator as a list of commands. if this happens, open doors. if this happens, close doors. etc...
23:27:43 <Pseudonym> An elevator is actually a network of computers.
23:27:51 <RyanT5000> ok, so in haskell you have a case statement, in C++ you have a switch statement...
23:27:57 <RyanT5000> i don't see how it's really any different
23:28:00 <Pseudonym> There's a small microcontroller on each floor and a slightly larger one on the lift.
23:28:04 <palomer> _but you would gain nothing by using haskell_
23:28:07 <Pseudonym> Plus there's a bigger computer attached to the motor.
23:28:09 <RyanT5000> palomer, maybe so
23:28:18 <RyanT5000> i didn't say haskell was strictly better in the vast majority of cases
23:28:19 <palomer> except unbounded memory requirements
23:28:30 <skew> shouldn't the elevator try to learn what floors it should park at at which times of day?
23:28:30 <palomer> which is a major bummer
23:28:34 <tato> Pseudonym: i want "ntuple 3 [1,2,3,4] = [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]", and "ntuple 2 [1,2,3,4]= [[1,2],..,[3,4]]
23:28:42 <Pseudonym> The small microcontrollers really only have to accept commands from the big computer, and take evasive action if it loses contact.
23:28:59 <RyanT5000> are you saying it's impossible to write code in haskell with known memory limits?
23:29:05 <RyanT5000> that sounds hard to believe
23:29:12 <Pseudonym> tato: Why?
23:29:14 <palomer> unless you make things explicitly strict, yes
23:29:17 <Pseudonym> Oh, hang on.
23:29:22 <Pseudonym> Ah, I see.
23:29:30 <RyanT5000> ... and that's difficult why?
23:29:37 <tato> Pseudonym: because I'm working on something which requires it...
23:29:57 <tato> skew, no, because some c programmer will mess it up and kill a lot of people
23:30:03 <dons> yeah, its a partition n . permutations, for some magical function
23:30:16 <dons> we have some similar functions, tato
23:30:24 <palomer> RyanT5000: to make everything explicitly strict?
23:30:28 <dons> ?type grpupBy
23:30:30 <lambdabot> lexical error
23:30:32 <RyanT5000> yeah
23:30:33 <skew> tato: you have little carefully written things for actually moving around without killing people
23:30:41 <Pseudonym> http://www.haskell.org/hawiki/LicensedPreludeExts
23:30:41 <dons> ?type groupBy
23:30:43 <lambdabot> Title: "LicensedPreludeExts - The Haskell Wiki"
23:30:43 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
23:30:46 <Pseudonym> Scroll down to "combinations".
23:30:50 <palomer> RyanT5000: if you want to use haskell as a poor man's C++, I don't see the point
23:31:00 <Pseudonym> Should be able to modify that easily.
23:31:02 <palomer> RyanT5000: you'd also spend a large amount of time having it interact with lower level libraries
23:31:13 <palomer> anyways, I'm off.
23:31:15 <skew> but with some carefully-proven core functionality you can write code on top that's as buggy as you like, without killing anybody
23:31:36 <Pseudonym> BTW, the main tricky thing about an elevator is its real-timeness.
23:31:50 <Pseudonym> And it's true, Haskell hasn't really been used for hard real-time yet.
23:31:57 <Pseudonym> Possibly with good reason.
23:32:02 <skew> not sure you want to anyway
23:32:30 <Pseudonym> The software in an elevator isn't even safety-critical.
23:32:59 <tato> Pseudonym: aahhh wonderful, thx
23:33:16 <tato> that function should be named powerset though
23:33:42 <skew> not safety critical if you just mean not free-falling if cables go
23:33:44 <Pseudonym> No, because it works on lists, not sets.
23:34:04 <Pseudonym> skew: The safety critical components of a lift are all mechanical.
23:34:06 <skew> dunno about not moving when somebody is halfway through the door
23:34:20 <Pseudonym> Hmm.
23:34:24 <Pseudonym> Actually, you might be right there.
23:34:31 <Pseudonym> My brother got a broken rib in a lift door.
23:34:41 <Pseudonym> That could arguably be bad software.
23:34:43 <skew> door closing, or sheared?
23:34:50 <Pseudonym> Closing.
23:35:16 <skew> or just a spring that wasn't springy enough in the mechanical bits
23:35:16 <Pseudonym> So yeah, I guess it is safety critical.
23:35:34 <Pseudonym> It was a door that didn't know it was supposed not to close.
23:36:07 <skew> anyway, if you care most about proving realtime guarantees, working with something very close to the hardware might be a good idea
23:36:15 <RyanT5000> yeah
23:36:33 <RyanT5000> i explicitly said "high-level" :P
23:36:34 <Pseudonym> Actually, there are arguments about that.
23:36:36 <skew> but there are such things as real time java, so maybe you don't need to get too close
23:36:48 <skew> if "finite" is mostly good enough
23:36:50 <Pseudonym> In principle, you could prove real-time guarantees in something like a type system.
23:37:00 <skew> there are type systems for resource usage
23:37:05 <Pseudonym> But the language would have to be quite high level for that.
23:37:06 <Pseudonym> Yeah.
23:37:24 <skew> depends what you mean by high level
23:37:41 <skew> I think you could make a C-ish language with very fancy dependent types on top of raw bits
23:37:43 <Pseudonym> Well, it means that the langauge rules out anything which means it can't prove the guarantee.
23:38:30 <tato> skew: thats C
23:39:08 * tato is still amazed how short combinations function is
23:39:41 <skew> tato: not really - a C compiler has no idea that stuff like accessing members of a union won't just break.
23:40:11 <Pseudonym> tato: This is precisely the kind of function that Haskell-like languages were original optimised for.
23:40:51 <tato> Pseudonym: are mere mortals like me supposed to be able to write such compact functions?
23:41:33 <skew> yep
23:41:39 <skew> doesn't take too long
23:41:43 <Pseudonym> Sure.
23:42:06 <Pseudonym> It's no harder than writing a simple proof by induction.
23:42:15 <Pseudonym> In fact, it _is_ writing a simple proof by induction.
23:43:05 <tato> so in case of combinations, what exactly is the theorem?
23:44:01 <Pseudonym> What you're actually doing is coming up with an inductive definition of combinations.
23:44:31 <Pseudonym> combinations (x:xs) is those combinations that start with x added to those combinations that don't start with x
23:46:49 <tato> I think I just have a hard time thinking in terms of lists, b/c induction is usually with natural numbers
23:47:07 <Pseudonym> Induction over structures is fairly easy once you've got the hang of it.
23:47:31 <tato> any book recommendations?
23:47:41 <Pseudonym> In this case, you want to work out what combinations (x:xs) means, given the inductive hypothesis that you know what combinations xs means.
23:47:46 <Pseudonym> Bird & Wadler
23:47:51 <Pseudonym> Good book.
23:47:54 <Pseudonym> @google bird wadler
23:48:06 <lambdabot> http://citeseer.ist.psu.edu/context/16767/0
23:48:13 <Pseudonym> Hrm.
23:48:17 <Pseudonym> That book, anyway.
23:48:27 <Pseudonym> Richard Bird and Philip Wadler. Introduction to Functional Programming. Series in Computer Science. Prentice-Hall International, 1988.
23:48:45 <Pseudonym> Any decent university library will have it.
23:51:48 <tato> :-( not berkeley
23:52:04 <tato> I think I'll gonna stare at that page for a while
23:52:51 <Pseudonym> True.  Berkeley library only has books on LSD and BSD.
23:53:12 <tato> berkeley has like the 3rd biggest lib in the country
23:53:28 <Pseudonym> LoC is first, I assume.
23:53:29 <lispy> tato: bigger than oregon state?
23:53:51 <lispy> oregon state has a very huge library, especially for being a state school
23:53:54 <tato> lispy: bigger than everywhere but lib of congress and harvard or somewhere
23:54:09 <lispy> tato: ah, that puts it in perspective
23:54:44 * lispy should have his irc license revoked at the moment considering he is drunk
23:54:56 <tato> http://hj.horriblehorriblecat.com/naked_dudes_1.avi <=== people streaking in the main library
23:55:13 <tato> http://hj.horriblehorriblecat.com/naked_dudes_2.avi more streaking
23:55:17 <RyanT5000> is it illegal to have a class with no functions?
23:55:28 <Pseudonym> Ryan: Nope.
23:55:44 <Pseudonym> Shouldn't be, anyway.
23:55:53 <tato> RyanT5000: nope, otherwise ethnic studies and most social sciences would vanish
23:55:56 <RyanT5000> hm, i think it's causing a parse error
23:55:59 <RyanT5000> LOL
23:56:09 <Pseudonym> Try: class Foo a where {}
23:56:16 <lispy> it's called naked dudes, but i saw naked coeds
23:56:44 <RyanT5000> Pseudonym: thanks, that did the trick
23:56:45 <tato> lispy: its in honor of Naked Guy, who died recently
23:56:45 <Pseudonym> lispy: Thanks, you've just put this channel in most web filters.
23:57:13 <lispy> Pseudonym: hehe
23:57:19 <lispy> tato: naked guy?
23:57:55 <lispy> Pseudonym: if the world knew that lazy fp languages existed, #haskell would be more popular :)
23:57:59 <tato> lispy: you don't know naked guy? in the earlier 1990's this guy spent his entire undergraudate career naked
23:58:08 <lispy> tato: whoa
23:58:22 <lispy> tato: i didn't go to berkley so i guess i didn't hear about it :)
23:58:24 <tato> the college made an ordinance specifically banning nudity because of him
23:58:39 <lispy> heh, bueracary--
23:58:42 <Korollary> I'll paste a relevant url in #haskell-blah
23:59:03 <tato> http://www.google.com/search?q=naked+guy&start=0&start=0&ie=utf-8&oe=utf-8&client=firefox-a&rls=org.mozilla:en-US:official
23:59:03 <lispy> thanks, this is definitely a #haskell-blah conversation
23:59:04 <lambdabot> Title: "naked guy - Google Search"
23:59:21 <lispy> let's take this there infact...
