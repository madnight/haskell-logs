00:03:38 * alar waves to lomeo
00:09:33 * lispy waves good night to #haskell
00:33:49 <l1tch> hi
00:33:53 <l1tch> .g anyad
00:34:06 <l1tch> .google anyad
00:34:36 <alar> @help
00:34:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:34:55 <l1tch> thc
00:35:26 <l1tch> nothing happen alar 
00:57:57 <dons> is it possible ghc in debian unstable doesn't use split objs?
00:58:29 <Igloo> On what arch?
00:58:41 <dons> i presume x86.
00:59:06 <dons> (hnop thread on haskell@, guy wonders why empty program is 2.5M unstripped)
00:59:06 <Igloo> Then it shouldn't be the case
01:03:11 <Igloo> I get a shade over 300k on amd64 with 6.4.2-2
01:03:40 <dons> yeah, and I get similar on x86/unstable
01:03:55 <dons> this guy might have a custom ghc, perhaps. i mailed him about it
01:28:27 <alar> @hoogle fail
01:28:28 <lambdabot> Prelude.fail :: Monad m => String -> m a
01:28:28 <lambdabot> System.Win32.Types.failIf :: (a -> Bool) -> String -> IO a -> IO a
01:28:28 <lambdabot> System.Win32.Types.failIfFalse_ :: String -> IO Bool -> IO ()
01:29:13 <alar> @instances MonadZero
01:29:14 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
01:29:29 <alar> @hoogle MonadZero
01:29:30 <lambdabot> No matches found
01:29:45 <alar> @hoogle MonadPlus
01:29:46 <lambdabot> Control.Monad.MonadPlus :: class Monad m => MonadPlus m
01:29:59 <alar> @instances MonadPlus
01:30:00 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
01:30:53 * alar wonders how mplus and fail are defined for Maybe
01:38:02 <dons> Igloo: ah, he compiled the ghc himself, and didn't turn on split objs
01:40:44 <Igloo> Don't you just have to not turn it off?
01:41:23 <dons> I think its off by default, since it doesn't work in most places
01:41:34 * dons checks
01:42:30 <dons> hmm. no, it should be on if its i386. who knows, maybe he just took the build.mk from the docs, which says to turn it off
01:42:37 <dons> ifneq "$(findstring $(HostArch_CPP), i386 x86_64 powerpc sparc)" ""
01:42:38 <dons> SplitObjs=YES
01:42:56 <dons> cpp is irksome
01:42:59 <dons> make is irksom
02:03:51 <roconnor> when I call hFlush, what guarentees do I get?
02:04:11 <Heffalump> that your computer won't emit blue smoke unless it has a hardware fault.
02:04:25 <roconnor> the magic smoke
02:04:56 <roconnor> If my file system is mounted sync, and I call hFlush, is the data actually on the disk?
02:05:04 <dons> -- | The action 'hFlush' @hdl@ causes any items buffered for output
02:05:04 <dons> -- in handle @hdl@ to be sent immediately to the operating system.
02:05:22 <dons> -- This operation may fail with:
02:05:23 <dons> --
02:05:23 <dons> --  * 'isFullError' if the device is full;
02:05:23 <dons> --
02:05:23 <dons> --  * 'isPermissionError' if a system resource limit would be exceeded.
02:05:25 <dons> --    It is unspecified whether the characters in the buffer are discarded
02:05:27 <dons> --    or retained under these circumstances.
02:05:53 * alar thinks hFlush is just wrapper for C fflush
02:06:19 <roconnor> Will the syscall to the OS wait for the data to be written (for a system mounted sync) before returning.
02:06:30 <roconnor> Maybe this is now the wrong channel for my question.
02:07:31 <dons> alar, nope, its in terms of primitive strict io
02:07:45 <dons> since we use our own handle abstraction
02:08:56 <alar> dons: so hFlush flushes higher-level structures, then call fflush?
02:09:20 <dons> i'm yet to find any call to fflush, but still looking
02:10:11 <alar> oh
02:10:37 <alar> maybe this is only higher-level flush and one needs to call fflush through FFI?
02:11:25 <dons> i've never had to. what FILE * are you going to flush?
02:11:39 <alar> ah,yes
02:11:50 <alar> there's no FILE* exposed
02:11:51 <dons> you'd have to conver the Handle to a File*, which flushes the handle anyway, effectively.
02:18:33 <roconnor> is there a mutiable version of Data.Set?
02:18:44 <Heffalump> nafaik
02:18:52 <roconnor> okay
02:18:53 <Heffalump> it's a tree, so mutability wouldn't help much
02:19:00 <Heffalump> obviously you could wrap it up in a STRef or similar.
02:19:15 <Heffalump> so an explicitly mutable version would just be an implementation optimisation
02:19:21 <Cale> most of the operations on Data.Set are reasonably fast anyway without mutability
02:19:33 <Cale> you'd just be turning O(log n) operations into O(1)
02:19:40 <roconnor> Cale, don't the operations copy the set?
02:19:44 <Cale> no
02:19:52 <roconnor> how is that possible?
02:19:54 <Cale> because most of the structure can be shared
02:20:06 <roconnor> hmmm
02:20:08 <Cale> only the path from the element to the root need be recreated
02:20:41 <roconnor> Wont rebalancing screw everything up?
02:20:55 <roconnor> maybe not
02:21:05 <roconnor> hmmm
02:21:17 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html -- this documents the complexities if you're curious
02:21:21 <lightstep> they choose data structures that need little rebalancing
02:22:43 <Cale> the most expensive operations are map and fromList which are O(n log n)
02:23:01 <roconnor> @hoogle GC
02:23:02 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
02:23:02 <lambdabot> Data.Typeable.gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
02:23:02 <lambdabot> Data.Typeable.gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
02:23:14 <roconnor> can I force garbage collection?
02:23:14 <Cale> but fromAscList is provided if you are sure the list is ascending and want a set in O(n)
02:23:50 <Cale> System.Mem.performGC
02:24:09 <Cale> I've never seen it used though.
02:24:28 <dons> darcs used to use it in its packed string allocatoin code
02:24:28 <xerox> @type System.Mem.performGC
02:24:29 <lambdabot> IO ()
02:24:38 <xerox> > System.Mem.performGC
02:24:38 <dons> i use it in a benchmark that loads huge arrays
02:24:39 <lambdabot>  Not in scope: `System.Mem.performGC'
02:24:44 <xerox> ^_^
02:24:56 <dons> performGC, that is.
02:26:24 <lightstep> xerox, some modules are banned, and so are all IO actions
02:28:01 <Cale> http://www.newscientist.com/article.ns?id=dn9436 -- this is interesting :)
02:28:04 <lambdabot> Title: "New Scientist Breaking News &#045; Ants use pedometers to find home"
02:28:27 <Stinger_> yeah I wonder how accurate it is :)
02:29:14 <Cale> It sounds plausible anyway :)
02:29:23 <roconnor> @docs System.Mem.performGC
02:29:24 <lambdabot> System.Mem.performGC not available
02:29:51 <isaacd> I'm impressed by Yhc. It only took around 10-20 minutes to build -- although of course that process does depend on GHC at the moment.
02:30:00 <Cale> and they have a video of an ant on stilts :)
02:30:12 <Stinger_> wtfwtf?
02:30:39 <Cale> (really just tiny sticks glued to its legs)
02:31:02 <Stinger_> removed 1mm from the ants legs, ouch
02:31:10 <Cale> yeah, I wondered about that
02:31:33 <Cale> It's like "after decapitation, the ants didn't seem to move very far at all"
02:32:24 <alar> "after removing sixth leg cockroach ceases to hear"
02:33:01 <Cale> The article actually says it: "When the researchers shortened the ants' legs the insects had trouble finding home."
02:33:18 <Cale> How about when the researchers' legs were removed?
02:33:30 <Cale> Or "shortened"
02:33:52 <roconnor> @hoogle forkIO
02:33:52 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
02:34:58 <roconnor> ensureIOManagerIsRunning?
02:35:07 <lightstep> how can i get a number of seconds from a TimeDiff?
02:36:13 <vincenz> Lol @ Ashley's email
02:36:14 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
02:36:43 <roconnor> lightstep: hmmmm, addToClockTime x (TOD 0 0)
02:37:22 <roconnor> oh, that's not haskell98
02:37:53 <roconnor> Boy, System.Time is awful
02:37:57 <vincenz> @tell dons The graphs are looking very good :)  I take it you manually choose 25.  Otherwise the bash script could first discern the maximum (and possibly round to the nearest 5-multiple)
02:37:57 <lambdabot> Consider it noted.
02:39:49 <lightstep> roconnor, i'd still need to parse ClockTime into Double
02:39:54 <alar> @hoogle (Monad m)=>m (a->b) -> a -> m b
02:39:56 <lambdabot> Prelude.asTypeOf :: a -> a -> a
02:39:56 <lambdabot> Prelude.const :: a -> b -> a
02:39:56 <lambdabot> Prelude.seq :: a -> b -> b
02:40:15 <lightstep> how much is pico, anyway?
02:40:31 <vincenz> Hehe, anyone read Bullat's IO Inside.  It's good, but the english is so humourous :D
02:40:45 <roconnor> @google 1 picosecond in seconds
02:40:46 <lambdabot> 1 picosecond = 1.0 x 10^-12 seconds
02:41:22 <lightstep> thanks
02:43:50 <lightstep> wtf? it throws errors
02:43:54 <lightstep> wow, this library isn't so good
02:44:52 <roconnor> well, it's hard to write calendar libraries.
02:45:29 <lightstep> they call error "Time.toClockTime: picoseconds out of range"
02:45:32 <roconnor> just work in julian dates using terrestrial time
02:45:47 <lightstep> which means they both have a bug and didn't turn off the assertions
02:46:15 <roconnor> what did you put in ctPicosec?
02:46:55 * roconnor suspects System.Time is a wrapper around some awful C time library
02:47:27 <lightstep> i only used getClockTime, diffClockTimes and addToClockTime. i didn't change any internal structure. i added normalizeTimeDiff, but that didn't help
02:47:48 <lightstep> now i just always convert the ClockTime to Double, and all is find
02:47:52 <lightstep> s/find/fine/
02:48:15 <lightstep> @hoogle pi
02:48:16 <lambdabot> Prelude.pi :: Floating a => a
02:48:17 <lambdabot> Language.Haskell.TH.ClassOpI :: Name -> Type -> Name -> Fixity -> Info
02:48:17 <lambdabot> Data.Map.lookupIndex :: (Monad m, Ord k) => k -> Map k a -> m Int
02:50:04 <roconnor> lightstep: sounds broken.  Maybe a bug ought to be filed.
02:50:18 <lightstep> isn't there a new time library?
02:51:15 <roconnor> there is System.CPUTime
02:51:27 <roconnor> > System.CPUTime.cpuTimePrecision
02:51:28 <lambdabot>  Not in scope: `System.CPUTime.cpuTimePrecision'
02:51:59 <roconnor> There is System.Posix.Time
02:52:19 <eivuokko> There is http://darcs.haskell.org/packages/time/ which is fairly recent, gets built with darcs ghc
02:52:20 <lambdabot> Title: "Index of /packages/time"
02:52:34 <roconnor> hmm, Posix.Time doesn't seem very useful
02:54:10 <roconnor> eivuokko: looks sophisticated
02:54:44 <eivuokko> roconnor, I have no idea.  I just know it because it used not build in Windows.
02:56:24 <alar> can there be a generic transforemer of type (a->Parser b) -> Parser (a->b) ?
02:56:41 <alar> where Parser a is ReadS a or arbitrary monad
02:56:46 <roconnor> eivuokko: is it going to appear in the standard libraries?
02:57:17 <roconnor> Ooooooooh, it has LeapSecondtables
02:57:33 * roconnor suspects an anstronomer wrote it
02:57:40 <eivuokko> roconnor, Well, it is built with into normal ghc distro atm.  The goal of the lib is to become standard lib.  However, I am not so sure what the reality will be if ghc makes the distro smaller as is planned.
02:58:07 <roconnor> ah
02:58:38 <eivuokko> It does build fine with cabal, tho.
02:58:49 <roconnor> I suppose Cabal is intended to solve the package depencancies issues?
02:58:49 <eivuokko> So intalling it shouldn't be a huge problem.
02:58:55 <eivuokko> Yes.
02:59:21 <roconnor> it just needs to be in hoogle so that people can find it.
03:00:11 <lightstep> it also needs to come with GHC by default
03:09:57 <lightstep> how can i use double buffering with cairo and gtk?
03:11:12 <xerox> lightstep: check out the Clock demo
03:11:48 <lightstep> ok
03:17:59 <Cale> this has to be the most sublimely insane formula I've ever seen
03:18:09 <Cale> I_theta(N) = (1/sqrt(2pi)^N) (1/N!) integral over R^N of sum over sigma, rho in S_N of sgn(sigma rho) (product over j = 1 to N of (lambda_sigma^-1(j))^(2N + theta_j - j + rho sigma^-1 (j)) e^(-1/2 p_2) dlambda
03:18:27 <alar> wow
03:18:41 <alar> what does it compute?
03:19:01 <Cale> I have no idea, really. It's something to do with counting maps on orientable surfaces.
03:19:35 <lightstep> @index windowSetGeometryHints
03:19:35 <lambdabot> bzzt
03:19:42 <Cale> It's in a part of my notes for a course that we didn't really get anywhere close to in the actual course
03:19:53 <lightstep> @hoogle windowSetGeometryHints
03:19:54 <lambdabot> No matches found
03:22:58 <lightstep> is gtk2hs compatible between micro-versions? the clock demo uses this and various other functions that i don't have
03:28:17 <dons> Cale, are you trying to hack the fpu with your empty list nsa formula for calculating Cale_digit?
03:28:18 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:28:42 <Cale> dons: hehe, no, just looking at old course notes
03:32:49 <ndm> @seen dmhouse
03:32:50 <lambdabot> I saw dmhouse leaving #oasis and #haskell 12 hours, 29 minutes and 27 seconds ago, and .
03:39:44 <Cale> oh, it needs some parens, actually
03:39:47 <Cale> er
03:39:53 <Cale> ECHAN
03:55:49 <gds> I've discovered "ghci -fglasgow-exts", but I still get "Not in scope: type variable `forall'" when I try to load some lambdabot modules into ghci - is this a similar issue - a command line switch I've not discovered?
04:16:12 <dons> you need a whole bunch of flags, gds. so we have a ./ghci script in the lambdabot dir to use instead
04:16:20 <dons> sh ghci Main.hs should work
04:17:00 <dons> just tested it. $ sh ghci Main.hs -- does indeed seem to work fine.
04:17:18 <dons> if you really want to play with lambdabot inside ghci
04:17:40 <gds> I was hoping to play with isolated bits of lambdabot inside ghci :)
04:17:45 <gds> Individual plugins...
04:17:59 <gds> If that's not "How it's done" - I'm happy to just compile and test.
04:18:01 <dons> yep, you can do that, but you'll need the flags in the 'ghci' script
04:18:18 <gds> Ah :)
04:18:20 <gds> Cool...
04:18:23 * gds plays...
04:19:11 <dons> or at least the bare minimum: $ ghci -cpp -fglasgow-exts -pgmF ./BotPP -F  Plugin/Karma.hs
04:19:15 <dons> *Plugin.Karma>
04:19:26 <xerox> What is 
04:19:33 <xerox> What is -pgmF ?
04:19:35 <gds> dons: Thanks :)
04:19:42 <ndm> ./BotPP ?
04:19:48 <dons> preprocessor we use for some plugin sugar
04:19:55 <dons> the BotPreProcessor ;)
04:20:03 <ndm> that can't be done with CPP?
04:20:10 <dons> oh no. .
04:20:33 <dons> there's a whole heap of boilerplate for first class modules we need in each plugin. the preprocessor adds this
04:20:49 <dons> all you do is write PLUGIN(foo), and you get a heap of magic symbols and instances generated
04:21:07 <dons> hooray for dynamic linking
04:21:09 <xerox> Fun.
04:30:06 <roconnor> @info Cabal
04:30:06 <lambdabot> Unknown command, try @list
04:30:12 <roconnor> @docs Cabal
04:30:12 <lambdabot> Cabal not available
04:30:16 <roconnor> @whereis Cabal
04:30:17 <lambdabot> Maybe you meant: where where+
04:30:21 <roconnor> @where Cabal
04:30:21 <lambdabot> http://www.haskell.org/cabal
04:30:37 <alar> @help where+
04:30:37 <lambdabot> where+ <key> <elem>. Define an association
04:31:50 <yip> what do you guys think about ocaml?
04:32:20 <vincenz> I used to like it
04:32:23 <vincenz> but it has shortcomings
04:32:33 <vincenz> which eventually led me to break my assumptions about haskell
04:32:35 <vincenz> by learning it
04:33:27 <alar> ocaml fans are all around!
04:33:48 <roconnor> Does Cabal automatically get uninstalled dependent libraries?
04:34:28 <yip> i am interested in ocaml only because it is supposed to have good performance
04:34:57 <roconnor> oh wait, that's Hackage
04:35:00 <roconnor> @where hackage
04:35:00 <lambdabot> http://hackage.haskell.org/trac/hackage
04:37:18 <vincenz> yip: haskell is @ par
04:37:29 <vincenz> yip: I used to use ocaml with exactly your agument
04:37:45 <vincenz> and saying "haskell is lazy" blabla... it'll be slow, I don't feel like learning this crazy language
04:37:57 <vincenz> But then ocaml finally pissed me off enough to switch
04:38:01 <vincenz> the lack of typeclasses for instances
04:38:09 <vincenz> the fact that data constructors are not first class
04:38:30 <alar> I've heard that ocaml compiler efficiency is rated just between C and C++
04:38:44 <vincenz> if you really want speed
04:38:46 <vincenz> take sml then
04:38:50 <vincenz> it does whole-program optimizations
04:38:51 <vincenz> ocaml does not
04:39:00 <vincenz> or clean
04:41:29 <alar> > swap (1,2)
04:41:29 <lambdabot>  Not in scope: `swap'
04:41:43 <alar> > flip (1,2)
04:41:43 <lambdabot>  Couldn't match `a -> b -> c' against `(a1, b1)'
04:41:51 <alar> @type flip
04:41:52 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
04:42:18 <xerox> > let swap = (snd &&& fst) in swap (1,2)
04:42:19 <lambdabot>  (2,1)
04:42:37 <alar> @type (&&&)
04:42:38 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:42:47 <alar> @instances Arrow
04:42:48 <lambdabot> (, Kleisli m
04:43:16 <xerox> instance Arrow (->) where
04:43:30 <xerox>   (f &&& g) x = (f x,g x)
04:43:40 <xerox>   (f *** g) (x,y) = (f x,g y)
04:43:52 <xerox>   (>>>) = flip (.)
04:44:00 <xerox>   first f (x,y) = (f x,y)
04:44:07 <alar> xerox: what is (->) in instance decl?
04:44:07 <xerox> second f (x,y) = (x,f y)
04:44:20 <xerox> The functions' type constructor.
04:44:23 <alar> do you mean every (a->b) is Arrow a b?
04:44:26 <xerox> ?kind (->)
04:44:27 <lambdabot> ?? -> ? -> *
04:44:32 <xerox> YEs.
04:44:35 <xerox> *Yes
04:44:44 <xerox> ?type pure
04:44:45 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
04:47:11 <alar> @hoogle pure
04:47:11 <lambdabot> Control.Arrow.pure :: Arrow a => (b -> c) -> a b c
04:49:53 <int-e> @instances Control.Arrow
04:49:54 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
04:50:00 <int-e> @instances Control.Arrow.Arrow
04:50:00 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
04:50:35 <int-e> @instances-importing Control.Arrow Control.Arrow.Arrow
04:50:36 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
04:51:37 <int-e> @instances-importing Control.Arrow Arrow
04:51:37 <alar> pure /= arr ?
04:51:38 <lambdabot> (, Kleisli m
04:52:23 <alar> @tell dmhouse supposedly your plugin has a bug, ask it "@instances Arrow"
04:52:23 <lambdabot> Consider it noted.
04:52:29 <isaacd> alar: pure and arr are synonyms
04:52:39 <vincenz> palomer: ping
04:53:13 <vincenz> @join oasis
04:53:17 <vincenz> @bot
04:53:18 <lambdabot> :)
04:53:21 <vincenz> @join #oasis
04:53:57 <int-e> arr = pure
04:54:10 <alar> @type arr
04:54:11 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
04:54:16 <alar> @type pure
04:54:17 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
04:54:39 <int-e> class Arrow a where  arr = pure; pure = arr
04:55:22 <vincenz> isaacd: welcome, goodbye
04:59:20 <isaacd> vincenz: hello
04:59:41 <isaacd> ?
05:10:22 <vincenz> isaacd: you joined and left #oasis
05:17:54 <dons> alar, re, speed of haskell/ocaml/sml/c/c++ : http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all
05:18:11 <dons> note the haskell entries are actually suboptimal, since they're not using the fast bytestring library for strings
05:19:02 <dons> its hardly likely these days that one would ever have an app where the difference between ocaml/sml/haskell was critical, or noticeable. you'd just code any slow bit in C anyway
05:19:44 <dons> as vincenz says, worrying about speed isn't really sensible (unless you're a php or javascript programmer, i guess)
05:21:16 <ndm> if you are a javascript programmer you still don't need to worry about speed - Firefox is written in Javascript remember!
05:22:12 <dons> so i think no one should ever mention speed again :) performance is a solved problem
05:22:22 <int-e> firefox isn't fast. the rendering engine is C++.
05:22:47 <ndm> int-e: i know, but most of the code is javascript, and its fast enough
05:23:33 <dons> alar, as with everything else, its your algorithms and datastructures that are more important., not any fundamental limit of the compiler or language
05:23:56 <dons> except if you're using an interpreted lang, then you'll have issues compared to native code, of course.
05:23:57 <ndm> although one important point is sometimes Haskell stops you from using the most efficient data structures, because its lazy
05:24:11 <roconnor> ndm: when?
05:24:11 <int-e> there's the ST monad
05:24:15 <ndm> and because its pure
05:24:16 <dons> well, you can always use something else if you want.
05:24:41 <dons> strict, packed data structures with mutable contents for those who need them
05:24:44 <int-e> and a neat FFI
05:24:49 <ndm> roconnor: red black trees in haskell are O(log n) space for insertion - in C they are O(1) space for intsertion
05:24:52 <dons> its not like haskell stops you using strictness, or mutability, or so on.
05:25:00 <ndm> but it does make it a lot harder
05:25:04 <yip> dons: i've tried and tried and can't get my haskell gameboy emulator to run fast enough, i'm trying an ocaml version and we'll see how that turns out
05:25:24 <dons> yip, i'd rather write the core emulator loop in C and call that instead
05:25:26 <ndm> yip: post it to the mailing list, someone will optimise it til it runs faster than hand tuned assembly
05:25:36 <roconnor> presumably C is cheating, and assuming constant time pointer access.
05:25:39 <dons> i doubt (unless your code is inefficient haskell) that you'll see any sudden improvement
05:25:54 <dons> yip, you've profiled?
05:25:59 <yip> dons: yes
05:26:09 <roconnor> ndm: oh wait, you said space.
05:26:18 <dons> are you planning on using the same data structures in ocaml?
05:26:24 <roconnor> okay, I was thinking of time.
05:26:28 <ndm> roconnor: space/time is often related
05:26:50 <ndm> and I never figured out how to get the fast union/find algorithm working in Haskell with any kind of obvious way
05:27:00 <yip> dons: well, the data structures that i need are as simple as they get. i need some arrays, and a fixed-size collection of integers
05:27:07 <dons> (its not like ocaml has any magic powers to compile data structures that you don't have in ghc)
05:27:08 <ndm> yip: unboxed arrays?
05:27:17 <yip> ndm: right
05:27:25 <dons> yeah, you've used unboxed arrays?
05:27:26 <yip> dons: i've tried using a bunch of different haskell data structures
05:27:37 * roconnor doesn't know any problems that are solved faster in strict mutable languages than in lazy pure languages.
05:27:44 <yip> dons: yes, regular, ST and IO unboxed arrays
05:27:44 <ndm> yip: have you space profiled?
05:27:48 <roconnor> space is another story
05:27:54 <dons> i'm not sure an ocaml rewrite would be worth it. would it be possible to write the main emulator loop in C?
05:28:00 <ndm> roconnor: if you can figure out Union/Find algorithm in Haskell using pure stuff, i'd be greatful!
05:28:29 <ndm> Its pretty much O(1) (inverse ackermans) in C, but I think mine was nearly exponential in Haskell
05:28:47 <yip> dons: i've actually almost finished writing the main emulator loop in C. the only thing is that the main emulator loop is basicly the entire emulator. but doing the gui in haskell might be fun
05:28:49 <ndm> of course, I bet it can be done O(n) and even O(log n) in Haskell, but couldn't figure out how to do it O(1)
05:29:02 <roconnor> what is union/find?
05:29:07 <Igloo> Did you try using unsafe array indexing?
05:29:11 <yip> Igloo: yes
05:29:27 <Igloo> I think with that you ought to be able to get about a factor of 2 off of C's speed
05:29:38 <dons> arrays with unsafeRead/Write are around 2x C. so that's about all you can hope to get
05:29:50 <int-e> roconnor: basically you input a set of equations a=b and ask whether x=y can be derived from them; the first is a set union, the second a set member test.
05:29:51 <dons> 1-2x, depending on the case
05:29:56 <ndm> roconnor: http://en.wikipedia.org/wiki/Disjoint-set_data_structure
05:30:02 <dons> some benchmarks with uboxed arrays are faster than C.
05:30:13 <yip> Igloo: soon i'll have my c version working, but my guess is that my fastest haskell version will run at least 10x slower then this initial c implementation
05:30:39 <dons> yip, might be worth posting the code then, once you've got the C loop running, if you'd like comments
05:30:50 <yip> dons: yeah, i will probably make a darcs repos
05:31:29 <dons> since its not always just a matter of data structures. strictness annotatoins are sometimes required, or using better library functions, presuming you've got the best algo already
05:32:25 <ndm> often a space leak will blow any performance
05:32:31 <yip> dons: i think that the main problem is the actual code that ghc is generating for emulation of the cpu instructions
05:33:00 <dons> ndm, but its usually obvious when that happens, and easy to profile away
05:33:08 <dons> yip, interesting.
05:33:29 <roconnor> How do you do O(1) in C?
05:33:45 <dons> you might want to consider primops then, or C stubs for primops, so you control the fragments that are generated for each instr.
05:36:04 <roconnor> oh wait, I see
05:36:41 <int-e> the 1 isn't 1, it's a very very slowly growing function.
05:40:57 <alar> @type liftM2
05:40:58 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:41:50 <alar> @type liftA2
05:41:51 <lambdabot> Not in scope: `liftA2'
05:44:39 <norpan> i opine, most of the time O(log n) is just as acceptable as O(1)
05:46:20 <norpan> especially if you're jumping through hoops to get it down to O(1) by increasing a constant factor
05:47:54 <int-e> norpan: that's not the case here though. disjoint set forests are very elegant and fast, but require in-place updates.
05:49:14 <norpan> also, with the current memory architecture, even O(1) is pretty slow sometimes...
05:49:34 <alar> I can imagine an application exponential about its inner heart, so when heart is O(1), application itself is O(1), when heart is O(log n) - application will be O(n)
05:49:51 <norpan> which is still not bad
05:49:59 <norpan> it all depends
05:50:18 <alar> yes, it depends
05:50:37 <norpan> that's why you shouldn't be afraid of O(log n) until you profile
05:51:07 <alar> I'm not even afraid of O(exp n) until it is too slow
05:51:17 <alar> but I'm not algorithm theorist
05:51:41 <norpan> i'm always afraid of O(exp n)
05:52:08 <norpan> reminds me of the story about e and e^x
05:52:24 <vincenz> Anyone know how to check which tags exist already for a specific repo
05:52:25 <vincenz> darcs repo
05:53:42 <ndm> darcsweb gives the info
05:53:45 <JKnecht> doesn't actually have such a cmd tho
05:53:45 <vincenz> yip: how is the emulator going?
05:53:52 <vincenz> hmm
05:53:56 <yip> vincenz: i'm working on a c version
05:53:56 <vincenz> so what use are tags?
05:54:45 <JKnecht> to reference patches
05:56:47 <vincenz> maybe I'll submit a patch to darcs
05:57:01 <SamB_XP> what use are tags ever?
05:57:28 <roconnor> let's see:  If we are going to be pure, we must put the data in right spot immediatelly.
05:57:38 <vincenz> SamB_XP: to tag a version?
05:57:42 <SamB_XP> well yeah
05:57:47 <roconnor> The hope is that laziness will defer that computation until needed.
05:58:53 * SamB_XP thinks segfaulting is O(1)
05:59:20 * alar is not sure about it
05:59:34 <int-e> ndm: an obvious way to implement the disjoint set data structure is to replace the underlying array with a map - that's O(log n * alpha(n)) for the operations.
05:59:35 <alar> segfaulting is O(1) in RTOS
06:00:01 <ndm> int-e: yeah
06:02:09 * mux thinks it doesn't make much sense to say that segfaulting is 0(1) or whatever
06:02:14 <mux> O(1), rather
06:02:44 <roconnor> so what happens when you make union set all of the element's parents directly to their parent?
06:02:59 <roconnor> lazyness will mean that this isn't executed until find is called
06:03:21 <int-e> ndm: I also suspect O(log n) is a lower bound, because every other bound would require unbounded branching factors, i.e. arrays, which will occasionally have to be copied. But maybe there's a clever way to amortize these costs, who knows.
06:03:34 <int-e> roconnor: the bounds are amortized costs.
06:03:49 <roconnor> of course
06:04:00 <ndm> int-e: yeah, its tricky - i'm not sure how close you can get to the O(alpha) of C
06:09:41 * roconnor begins to see the difficulty
06:14:12 <roconnor> what is the worst case sequence of find/union operations?
06:14:38 <ruffneck> databases ?
06:14:42 <alar> @hoogle ArrowChoise
06:14:43 <lambdabot> No matches found
06:14:43 <ruffneck> what kind of "union" ?
06:14:48 <alar> @hoogle Arrow
06:14:49 <lambdabot> Control.Arrow :: module
06:14:49 <lambdabot> Control.Arrow.Arrow :: class Arrow a
06:14:49 <lambdabot> Control.Arrow.ArrowMonad :: a () b -> ArrowMonad a b
06:15:23 <alar> @google ArrowChoise
06:15:24 <lambdabot> No Result Found.
06:16:27 <xerox> *ce
06:17:08 <alar> oh
06:17:17 <alar> @hoogle ArrowChoice
06:17:17 <lambdabot> Control.Arrow.ArrowChoice :: class Arrow a => ArrowChoice a
06:17:25 <alar> @karma+ xerox
06:17:25 <lambdabot> xerox's karma raised to 16.
06:17:45 * alar is so stupid
06:17:47 <xerox> Happy to help :)
06:18:00 <xerox> Oh, wait a minute...
06:18:23 <roconnor> ruffneck: http://en.wikipedia.org/wiki/Disjoint-set_data_structure
06:18:30 <ruffneck> thanks
06:18:38 <vincenz> roconnor: that algo however, fails one type of operation
06:18:45 <vincenz> namely getting all the x's that are in a certain set
06:19:02 <roconnor> right
06:19:26 <xerox> http://video.google.com/videoplay?docid=342080286217914779 alar watch this :)
06:19:28 <lambdabot> Title: "Edward Teller: Going to see Einstein give a lecture - Google Video"
06:19:51 <xerox> lambdabot spoils the fun.
06:20:16 <ruffneck> Schindlers linked list ;P
06:20:35 <vincenz> roconnor: which makes me wonder about the statement on how they use it for that water stuff
06:22:46 <alar> :D)
06:23:12 <xerox> alar - Answerng your comment on stupidity :)
06:23:16 <xerox> +i
06:24:13 <alar> yes :)
06:28:46 <norpan> good sroty
06:28:47 <norpan> story
06:31:54 <alar> @hoogle left
06:31:54 <lambdabot> Control.Arrow.left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
06:31:54 <lambdabot> Prelude.Left :: a -> Either a b
06:31:54 <lambdabot> Control.Arrow.leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
06:32:05 <alar> @type left
06:32:06 <lambdabot> forall (a :: * -> * -> *) d c b. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
06:33:55 <ruffneck> the syntax is just crazy
06:34:29 <int-e> vincenz: getting all members can easily be done with an additional link field per element; the links form cyclic lists. if you join to formerly disjoint sets, you can join the cycles by swapping the link fields of two members of the (formerly disjoint) cycles.
06:35:57 <vincenz> int-e: I know, was just commenting
06:41:34 <isaacd> Can I get an exact ordering between an integer and the sine of another integer given in degrees? Ditto for other trig functions and preferably extended to rational numbers.  I want to avoid floating point, which has all kinds of traps, especially for equality comparisons.
06:43:08 <int-e> I'm not sure I understand; does it require more than sin(180-x) = sin(x) and sin(360+x) = sin(x) to be answered?
06:43:19 <Lunar^> CosmicRay: in HDBC, the list is the Haddock comment of SqlValue does not render well
06:43:25 <Lunar^> s/is/in/
06:43:54 <Lunar^> CosmicRay: also, is withTransaction reentrant?
06:44:31 <isaacd> int-e: Suppose I want to avoid trig functions implemented to return floating-point numbers
06:45:52 <CosmicRay> Lunar^: to the second question, I belive  the answer is no.
06:46:04 * CosmicRay checks out the haddock docs
06:46:09 <isaacd> The difficulty is that trig functions sometimes return an irrational answer -- but not always
06:46:29 <alar> I don't understand what arrows are useful for apart from clearly outlining flow of computations
06:46:33 <isaacd> I think
06:47:47 <Lunar^> CosmicRay: maybe it should be expliciely documented in withTransaction, as sub-transaction are supported by some databases, IIRC
06:47:58 <int-e> isaacd: if you want to compare sin(a) and sin(b), given a and b, that can be done, quite easily.
06:47:59 <CosmicRay> Lunar^: good point.
06:48:09 <CosmicRay> Lunar^: are sub-transactions part of ISO SQL?
06:48:19 <Lunar^> dunno
06:48:21 <isaacd> int-e: no, I want to compare a and sin(b)
06:49:07 <int-e> isaacd: that's boring if a is an integer.
06:49:14 <isaacd> why?
06:49:19 <isaacd> oh
06:49:21 <isaacd> oops
06:49:33 <int-e> because -1 <= sin(x) <= 1 and you know exactly when it's -1, 1 or 0.
06:49:40 <isaacd> I mean, sin(b)*c, where I guess c is also an integer
06:49:57 <Lunar^> CosmicRay: the API seems nice, otherwise :)
06:50:03 <isaacd> Which I guess is equivalent to saying 'a' is rational
06:51:21 <CosmicRay> Lunar^: thanks
06:51:49 <CosmicRay> Lunar^: withTransaction is nothing but a shallow wrapper around commit and rollback
06:52:15 <CosmicRay> it will run the specified action, then commit if there are no exceptions.  if an exception is raised, it runs rollback, then propogates the exception on.
06:52:53 <alar> nice wrapper
06:53:10 <int-e> isaacd: hmm. it's possible I believe, using the double angle formula for cos to decide cases where the result isn't clear enough.
06:53:37 <alar> does anyone have experience with HSQL on platforms different from GHC on *NIX?
06:54:11 <isaacd> The only thing I'm worried about there is an infinite computation if it turns out they're equal... because the algorithm wouldn't know that they're not just very close to equal.
06:54:26 <int-e> isaacd: basically, try to decide a <=> cos b  by a table; if you can't, try with 1 - 2 a^2 <=> cos 2b, and so on. It's not pretty, and care has to be taken with interpreting the results.
06:54:54 <Lunar^> CosmicRay: for MySQL http://dev.mysql.com/tech-resources/articles/maxdb-transactions.html#subtrans
06:54:55 <lambdabot> Title: "MySQL AB :: MaxDB series: Transactions"
06:55:15 <int-e> isaacd: I think sin 0, sin 30 and sin 90 are the only values to look out for.
06:55:20 <CosmicRay> that's not for mysql then
06:55:25 <CosmicRay> that would be for maxdb only, right?
06:55:38 <Lunar^> uh.. right
06:56:57 <isaacd> int-e: I wonder if those are the only rationals (or +360N of course) that result in a rational... if there's someone who's already figured out something like that
06:57:46 <isaacd> and all the reflections and 90 degree rotations
06:58:39 <norpan> there probably is someone
06:58:42 <norpan> :)
06:59:23 <isaacd> which doesn't help me find the information of course :)
06:59:40 <int-e> Gauss probably did.
07:00:24 <vincenz> dons around?
07:02:24 <norpan> isaacd: the question is, for which rationals x is sin(x) rational?
07:03:00 <isaacd> norpan: yes
07:03:14 <norpan> for x in degrees?
07:03:20 <isaacd> yes
07:03:21 <norpan> or in radians?
07:03:24 <isaacd> degrees
07:04:00 <isaacd> (although radians might be interesting too... it's just not what I'm looking for ;-)
07:04:31 <isaacd> (at the moment)
07:05:00 <norpan> a more interesting question would be for which sin(x) is algrebraic
07:05:49 <int-e> not really - x is a rational multiple of pi then
07:06:23 <int-e> hmm. no, that's wrong.
07:06:52 <alar> sin(rational radians) is never rational IMHO, except trivial case
07:07:08 <int-e> but if x is a rational multiple of pi, sin(x) is algebraic.
07:07:44 <int-e> Gauss answered the question when sin(x), where x is a multiple of pi, can be expressed with square roots.
07:07:53 <isaacd> alar: yes, we opine that, we just haven't proved it
07:07:59 <int-e> *rational multiple
07:08:01 <isaacd> int-e: where?
07:08:18 <int-e> isaacd: find the relation to constructing regular n-gons.
07:10:21 <isaacd> What sort of math do I need to figure out what's going on?
07:12:12 <int-e> Hmm. Galois theory. That's abstract algebra, and deals with fields and field extensions.
07:13:54 <isaacd> Of course, it may be another matter if I want my code to be understandable to ordinary mortals :)
07:17:57 <alar> ordinary mortals vs. cardinary programmers :)
07:18:48 <alar> @hyoogle ArrowApply
07:18:48 <lambdabot> Control.Arrow.ArrowApply :: class Arrow a => ArrowApply a
07:19:10 <alar> @instances ArrowChoice
07:19:11 <lambdabot> (, Kleisli m
07:29:39 <alar> if Arrow represents a computation, then Arrow.app probably represents a closure?
07:43:03 <dropdrive> int-e: I thought that sin(20) isn't constructible?
07:43:40 <dropdrive> int-e: never mind, i misread your statement.
07:57:13 <lispy> > sin 20
07:57:14 <lambdabot>  0.9129452507276277
07:57:20 <lispy> > sin (20)
07:57:21 <lambdabot>  0.9129452507276277
07:57:33 <lispy> > sin $ 20
07:57:34 <lambdabot>  0.9129452507276277
07:57:56 <lispy> > sin $! 20
07:57:57 <lambdabot>  0.9129452507276277
07:59:34 <isaacd> > sin (20 / 180 * pi)
07:59:35 <lambdabot>  0.3420201433256687
08:01:09 <lispy> > let fmod a b = (sin a)*b in pi `fmod` 2
08:01:10 <lambdabot>  2.4492127076447545e-16
08:01:32 <roconnor> >ifactor 360
08:01:33 * lispy has no idea of that definition makes any sense to make
08:01:43 <lispy> roconnor: this isn't maple :)
08:01:59 <lispy> > ifactor 360
08:02:00 <lambdabot>  Not in scope: `ifactor'
08:02:10 <roconnor> > 2^3*3^2*5
08:02:11 <lambdabot>  360
08:04:26 * roconnor thinks back to galios theory
08:04:35 <lispy> @type gcd
08:04:36 <lambdabot> forall a. (Integral a) => a -> a -> a
08:04:45 <roconnor> Doesn't this have something to do with fermat primes?
08:04:45 <lispy> > gcd 360 28
08:04:46 <lambdabot>  4
08:04:58 <roconnor> well, maybe this is easier
08:05:01 <lispy> fermat primes?
08:05:13 <lispy> i'm not familiar with those primes
08:05:23 <roconnor> @wikipedia fermat primes
08:05:26 <lambdabot> No Result Found.
08:05:48 <lispy> ?google "fermat primes"
08:05:49 <lambdabot> http://mathworld.wolfram.com/FermatPrime.html
08:05:49 <lambdabot> Title: "Fermat Prime -- from Wolfram MathWorld"
08:06:26 <lispy> oh, i have heard of those
08:06:27 <isaacd> http://en.wikipedia.org/wiki/Exact_trigonometric_constants has some references
08:09:39 <alar> > let ifactor x = let ifac x y = if (x==1) then  [] else if (mod x y == 0) then (y: (ifac (div x y) 2)) else ifac x (y+1) in ifac 2 in ifactor 360
08:09:40 <lambdabot>  Add a type signature
08:10:00 <alar> > let ifactor x = let ifac x y = if (x==1) then  [] else if (mod x y == 0) then (y: (ifac (div x y) 2)) else ifac x (y+1) in ifac x 2 in ifactor 360
08:10:01 <lambdabot>  [2,2,2,3,3,5]
08:10:37 <lispy> @pl \x -> let ifac x y = if (x==1) then  [] else if (mod x y == 0) then (y: (ifac (div x y) 2)) else ifac x (y+1)
08:10:37 <Stinger_> does haskell do any caching of values at all?
08:10:37 <lambdabot> (line 1, column 110):
08:10:37 <roconnor> if only there were 257 degrees in a circle
08:10:37 <lambdabot> unexpected end of input
08:10:37 <lambdabot> expecting variable, "(", operator, ";" or "in"
08:11:20 <lispy> @pl \x -> let ifac x y = if (x==1) then  [] else if (mod x y == 0) then (y: (ifac (div x y) 2)) else ifac x (y+1) in ifac x 2
08:11:22 <lambdabot> flip (flip flip 2 . flip id) (fix (const . ap (flip if' [] . (1 ==)) . ap (ap . ap (if' . (0 ==) . join mod) . ap (:) . flip flip 2 . (. join div)) (`ap` (1 +))))
08:11:34 <lispy> muwhahahah!
08:12:24 <roconnor> let's see here, if an angle is not constructable then the sin of it cannot be rational.
08:12:36 <lispy> > flip (flip flip 2 . flip id) (fix (const . ap (flip if' [] . (1 ==)) . ap (ap . ap (if' . (0 ==) . join mod) . ap (:) . flip flip 2 . (. join div)) (`ap` (1 +)))) 28
08:12:36 <lambdabot>  Not in scope: `if''
08:12:46 <mahogny> RyanT5000: yo. sup?
08:13:10 <lispy> > let if' b t e = if b then t else e in flip (flip flip 2 . flip id) (fix (const . ap (flip if' [] . (1 ==)) . ap (ap . ap (if' . (0 ==) . join mod) . ap (:) . flip flip 2 . (. join div)) (`ap` (1 +)))) 28
08:13:12 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
08:13:41 <roconnor> because if sin (x) = a/b, then cos x = sqrt (1-a^2/b^2), and the point (sin(x),cos(x)) would be constructable.
08:13:56 <lispy> > let ifactor x = let ifac x y = if (x==1) then  [] else if
08:13:56 <lispy>       (mod x y == 0) then (y: (ifac (div x y) 2)) else ifac x (y+1) in
08:13:56 <lispy>       ifac x 2 in ifactor 28
08:13:56 <lambdabot>  Parse error
08:14:07 <lispy> > let ifactor x = let ifac x y = if (x==1) then  [] else if (mod x y == 0) then (y: (ifac (div x y) 2)) else ifac x (y+1) in ifac x 2 in ifactor 28
08:14:08 <lambdabot>  [2,2,7]
08:14:12 <lispy> hmmm
08:14:31 <lispy> i wonder if that's a bug in @pl
08:15:06 <roconnor> Now, I think that the only constructable angles that are integer degrees are multiples of 3
08:15:45 <roconnor> so the wikipedia page lists all sines of integer multiples of 3
08:16:05 <roconnor> and the only ones that are rational appear to be 0 30 and 90 degrees
08:16:18 <roconnor> (and the rest from 90-360)
08:19:44 <roconnor> yes
08:19:46 <roconnor> http://en.wikipedia.org/wiki/Trisecting_the_angle#Constructible_angles
08:19:56 <mileswu> lol!
08:19:57 <roconnor> ``The only angles of finite order that may be constructed starting with two points are those whose order is a product of a power of two and a set of distinct Fermat primes. ''
08:20:09 <mileswu> rofl rofl
08:20:31 <mileswu> love those fermat primes
08:20:41 <mileswu> "theyre hot"
08:20:54 <mileswu> et vraiment mon sac
08:21:02 <mileswu> encantado... mario
08:21:07 <roconnor> isaacd, int-e: I'm quite convinced that indeed the only ones to watch out for are sin 0, sin 30 and sin 90
08:21:39 <isaacd> ok
08:21:41 <mileswu> they are notable indeed
08:22:44 <isaacd> We know this for integer degrees, and are convinced it is so for rational degrees
08:23:06 <roconnor> no not rational degree
08:23:11 <isaacd> ok
08:23:26 <isaacd> well I really only need integer degrees anyway, at present :)
08:23:36 <roconnor> Although it is also likely true for rational degree, I don't know for sure.
08:24:30 <isaacd> Does it make sense to ask "why" sin 30 is special out of all the possible nontrivial degree-numbers?
08:24:34 <roconnor> It is true for all sin(a/b) in which the only fermat primes dividing b are 3 and 5.
08:25:03 <roconnor> I mean I am convinced it is true for all sin (a/b) in which ...
08:25:31 <mathewm> newb question - is there any way to encode constraints on the values a type may hold - I want a type that consistens of an Int between 1 and 9 only
08:26:06 <roconnor> mathewm: you could make a data type with only 9 constructors.
08:26:30 <mathewm> data foo = n1 | n2 | n2 ... ?
08:26:37 <roconnor> yep
08:26:38 <mathewm> N1 | N2...
08:26:43 <roconnor> make it an instance of Enum
08:26:49 <mileswu> sorry for all that. it wasn't me (a friend being "funnny"). i really do apologise
08:26:59 <roconnor> (can you do deriving Enum?)
08:27:22 <mileswu> is there any way of comparing two functions?
08:27:32 <roconnor> isaacd: It makes sense, but I'm not sure I have an answer for you.
08:28:47 <isaacd> Anyway, thanks everyone for helping me here :)
08:29:15 <kpreid> roconnor: yes; it uses the order of the constructors
08:29:16 <kpreid> mileswu: no
08:29:31 <mileswu> i'm slowly trying to create a differentiator
08:30:11 <mathewm> is there any way to add your own deriving magic for your own classes?
08:30:23 <mileswu> kpreid: so there would be no way of comparing the function in my data Expression to a list of tuples mapping functions to their derrivatives
08:32:34 <roconnor> bah, maple won't convert cos(2*Pi/17) to a radical.
08:33:50 <kpreid> mileswu: use your own data type instead of a Haskell function
08:34:00 <alar> mathewm: there is some software that allows you to add your own deriving, but I don't remember the name
08:34:21 <alar> it is listed on "libraries and tools" page
08:34:39 <kpreid> mileswu: then define some function :: MyFunction a b -> a -> b in order to apply it
08:35:26 <kpreid> mileswu: that is, given one of your comparable values it yields the haskell function you would have usede
08:36:45 <mileswu> kpreid: okay. so i would create a function which took in a MyF data type and returned the actual haskell function
08:39:24 <kpreid> mileswu: yes. and notice that it is equally interpretable as "return the function" or "apply a MyF to this value"
08:40:26 <mileswu> kpreid: so how would the constructor for this data type MyF look like?
08:41:54 <kpreid> whatever fits your needs: describes all the functions you might want to use, and can be compared
08:42:42 <kpreid> it might even be like this:
08:43:34 <kpreid> data MyF a b = MyF (a -> b) FunctionName; instance Eq MyF where (MyF _ a) == (MyF _ b) = a == b
08:43:57 <kpreid> that is, just associate functions with comparable keys
08:44:38 <mileswu> kpreid: i'll try that. thanks very much but i have only just discovered haskell and the whole data type thing is still a little fresh
08:47:23 <kpreid> mileswu: FunctionName should be whatever fits; for simple cases it could be just a string (type FunctionName = String)
08:47:37 <kpreid> e.g. mySin = MyF sin "sin"
08:47:42 <mileswu> kpreid: yeah. i just put a String
08:49:20 <mileswu> kpreid: it's complaining about a type error
08:49:27 <mileswu> kpreid: data MyF a b = MyF (a->b) String      
08:49:27 <mileswu> mySin = MyF sin "sin"
08:49:45 <kpreid> what's the error?
08:49:50 <mileswu> kpreid: then in hugs i wrote sin 1
08:50:19 <mileswu> Type: MyF Double Double   does not match a -> b
08:50:25 <kpreid> ok, you can't do 'mySin 1'
08:50:31 <kpreid> write this:
08:50:57 <kpreid> apply (MyF f _) = f
08:51:00 <kpreid> then:
08:51:12 <mileswu> kpreid: sorry of course not.... silly me
08:51:12 <kpreid> apply mySin 1
08:51:36 <kpreid> and as I mentioned above, this is equivalent to (apply mySin) 1
08:51:53 <lispy> or you could do mySin `apply` 1
08:52:02 <lispy> if that looks better to your eyes
08:52:05 * kpreid nods
08:52:24 <kpreid> (`...` uses a name as an infix operator)
08:52:36 <mileswu> lispy: not really fussed over infix versus prefix. i have a rpn calculator so i'm used to everything!
08:52:50 <lispy> :)
08:53:39 <mileswu> you get easily confused between everything. likewise cos i mainly program in ruby, C and Obj-C, i get confused easily
08:54:04 <mileswu> but this summer's resolution is only to do haskell! it's looking exciting
08:54:08 * lispy gets confused easily and has no escape goat :)
08:54:56 <mileswu> lispy: kpreid: thanks all. i'll have another crack at it
09:05:20 <the_lord> @type (,,)
09:05:25 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
09:05:54 <the_lord> @hoogle a -> b -> c -> (a, b, c)
09:05:55 <lambdabot> No matches, try a more general search
09:08:02 <RyanT5000> why is there if syntax?
09:08:09 <RyanT5000> how come if isn't just in prelude?
09:08:34 <RyanT5000> if :: Bool -> a -> a -> a
09:16:19 <the_lord> how do I see if all the elements of a list are in other list?
09:16:58 <the_lord> intersect and check length?
09:17:13 <the_lord> isn't there any better way?
09:18:08 <jyp> l1 all ('elem' l2)
09:18:13 <jyp> uh
09:18:27 <jyp> all (`elem` l2) l1
09:19:09 <the_lord> > all (elem [2,3,4,5]) [2,3]
09:19:11 <lambdabot>  add an instance declaration for (Num [[a]])
09:19:11 <lambdabot>   In the list element: 3
09:19:20 <the_lord> > all (elem [2,3]) [2,3,4,5]
09:19:21 <lambdabot>  add an instance declaration for (Num [[a]])
09:19:21 <lambdabot>   In the list element: 5
09:19:24 <jyp> > all (`elem` [2,3,4,5]) [2,3]
09:19:24 <the_lord> nope
09:19:25 <lambdabot>  True
09:19:31 <jyp> backquotes
09:19:40 <the_lord> what does backquotes do?
09:19:51 * the_lord didn't knew
09:19:54 <jyp> makes an identifier infix
09:20:07 <jyp> > elem 2 [1..5]
09:20:08 <lambdabot>  True
09:20:16 <jyp> > 2 `elem` [1..5]
09:20:17 <lambdabot>  True
09:25:12 <isaacd> If they are in class Ord, it can be done by putting both lists into Data.Set.Set and checking if one is a subset of the other, which is probably faster (asymptotically anyway)
09:25:56 <isaacd> It might be doable with list-sorting functions with the same speed as that, too...
09:29:00 <isaacd> @instances Arrow
09:29:01 <lambdabot> (, Kleisli m
09:29:04 <sjanssen> ?where happy
09:29:04 <lambdabot> http://www.haskell.org/happy/
09:29:50 <dmhouse> Huh? ( is an arrow?
09:29:51 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
09:29:53 <dmhouse> Smells like a bug.
09:31:28 <alar> maybe your plugin can't handle "->" ?
09:32:34 <dmhouse> Could be the explicit kinding.
09:32:49 <dmhouse> @instances Monad
09:32:49 <lambdabot> ((, ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:32:55 <dmhouse> Seems so. :)
09:33:06 <dmhouse> Someone turned on -fglasgow-exts, by the looks of things.
09:33:39 <alar> "->" is instance of Arrow
09:34:33 <dmhouse> alar, can you get that from GHCi's :i?
09:35:18 <alar> hm
09:35:24 <the_lord> > all (&& True)[True True]
09:35:25 <lambdabot>    The function `True' is applied to one arguments,
09:35:25 <lambdabot>   but its type `Bool'...
09:35:32 <the_lord> > all (&& )[True True]
09:35:32 <lambdabot>    Expecting a function type, but found `Bool'
09:35:33 <lambdabot>    Expected type: Bool ->...
09:35:34 <alar> ghci doesn't show me instances of Arrow
09:35:52 <alar>        -- Imported from Control.Arrow
09:35:53 <alar> instance Monad m => Arrow (Kleisli m)
09:35:56 <alar> that's all
09:36:01 <dmhouse> alar: same here.
09:36:12 <alar> @hoogle Arrow
09:36:13 <lambdabot> Control.Arrow :: module
09:36:13 <lambdabot> Control.Arrow.Arrow :: class Arrow a
09:36:13 <lambdabot> Control.Arrow.ArrowMonad :: a () b -> ArrowMonad a b
09:36:25 <the_lord> > all (True && )[True True]
09:36:26 <lambdabot>    The function `True' is applied to one arguments,
09:36:26 <lambdabot>   but its type `Bool'...
09:36:36 <alar> xerox: how did you get instance Arrow -> ?
09:36:39 <isaacd> > all (&& True) [True, True]
09:36:40 <lambdabot>  True
09:36:44 <alar> xerox: how did you get instance Arrow (->) ?
09:36:53 <isaacd> the_lord: missing comma
09:37:14 <the_lord> isaacd: missing comma???
09:37:33 <the_lord> > and [True True]
09:37:33 <lambdabot>    The function `True' is applied to one arguments,
09:37:34 <lambdabot>   but its type `Bool'...
09:37:35 <isaacd> well, I assume you didn't want to treat True as a function
09:37:43 <mileswu> you tell a lie
09:37:45 <mileswu> lol
09:37:46 <the_lord> isaacd: yes
09:38:18 <isaacd> Haskell literal list elements are separated by commas, and functions applied by adjacency.
09:38:21 <mileswu> que fecha!
09:38:41 <the_lord> isaacd: oh yes
09:38:45 <the_lord> isaacd: my bad
09:38:50 <mileswu> yes yes oh yay
09:38:54 <the_lord> I like more and
09:39:01 <the_lord> > and [True True]
09:39:02 <lambdabot>    The function `True' is applied to one arguments,
09:39:02 <lambdabot>   but its type `Bool'...
09:39:05 <alar> @hoogle ArrowZero
09:39:06 <the_lord> > and [True, True]
09:39:06 <lambdabot> Control.Arrow.ArrowZero :: class Arrow a => ArrowZero a
09:39:07 <lambdabot>  True
09:39:13 <alar> @hoogle ArrowPlus
09:39:13 <lambdabot> Control.Arrow.ArrowPlus :: class ArrowZero a => ArrowPlus a
09:39:22 <mileswu> gaygaygay
09:39:40 <dmhouse> mileswu: what is?
09:43:58 <dmhouse> How do you negate a Parsec parser?
09:44:05 <dmhouse> I.e. Everything but newline
09:44:36 <RyanT5000> is there some exposed module simmilar in function to Distribution.Compat.FilePath?
09:44:42 <RyanT5000> i need to use stuff like joinPath
09:45:03 <alar> negate a parser?
09:45:27 <RyanT5000> dmhouse: you mean reject anything that parser would accept?
09:45:28 <dmhouse> alar, for example, I want this parser to succeed iff newline fails.
09:46:11 <dmhouse> RyanT5000: right.
09:46:38 <alar> ah, that
09:46:41 <RyanT5000> (i don't know)
09:47:11 <the_lord> > deleteBy (\x y = elem) [2,3,4,5] [2,3,6]
09:47:11 <lambdabot>  Parse error
09:47:52 <RyanT5000> @type deleteBy
09:47:53 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
09:48:14 <dmhouse> The only thing I can think of is noneOf "\n"
09:48:18 <alar> is notFollowedBy appropriate?
09:48:46 <the_lord> how do I do [2,3,4,5] - [2,3,6]
09:48:57 <dmhouse> > [2,3,4,5] \\ [2,3,6]
09:48:58 <lambdabot>  [4,5]
09:49:18 <the_lord> [2,3,6] - [2,3,4,5]
09:49:25 <the_lord> > [2,3,6] \\ [2,3,4,5]
09:49:26 <lambdabot>  [6]
09:49:35 <the_lord> dmhouse: thx
09:49:36 <dmhouse> > let xs \\ ys = filter (`notElem` ys) xs in [2,3,4,5] \\ [2,3,6]
09:49:37 <lambdabot>  [4,5]
09:52:21 <dmhouse> I settled on anyChar `manyTill` newline
09:52:21 <sjanssen> ?where alex
09:52:22 <lambdabot> http://www.haskell.org/alex/
09:52:27 <alar> @tell xerox tell dmhouse how did you get instance Arrow (->) from GHCi
09:52:27 <lambdabot> Consider it noted.
09:52:37 <alar> dmhouse there is noneOf
09:52:47 <alar> parses character not from set
09:52:50 <dmhouse> alar, Yes, but as I said, noneOf "\n" is a but ugly.
09:52:57 <alar> yes
09:53:03 <dmhouse> What I have is fine.
09:56:00 <alar> not sure you can negate Parsec parser without deconstructing it 
09:56:44 <dmhouse> Well, you could write a function to do it
09:57:07 <dmhouse> It obviously couldn't return anything easy.
09:57:11 <alar> @type liftM2 (\f x-> f x)
09:57:12 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
09:57:28 <dmhouse> So negate :: CharParser st ()
09:57:34 <dmhouse> Err,
09:57:44 <dmhouse> negate :: CharParser st a -> CharParser st ()
09:58:07 <alar> what should it return?
09:58:29 * alar doesn't know how Parsec handles Success
09:58:30 <dmhouse> As I said, it can't return anything meaningful.
09:58:53 <dmhouse> Perhaps negate p = p <|> pzero?
09:59:05 <dmhouse> If p succeeds, that will fail.
09:59:15 <dmhouse> No, wait.
09:59:17 <alar> ]if Parser a is (String-> [(a,String)])
09:59:21 <the_lord> > [2,2] \\ [2,3,4,5]
09:59:22 <lambdabot>  [2]
09:59:29 <dmhouse> That's not anything like what we want.
09:59:32 <alar> then negate:: Parser a-> Parser a
09:59:46 <the_lord> > (nub [2,2]) \\ [2,3,4,5]
09:59:46 <dmhouse> alar, nah, it's String -> Either ParseError a
09:59:46 <lambdabot>  []
10:00:15 <dmhouse> the_lord: If you want more set-like behaviour, check out Data.Set
10:00:22 <alar> then negate could be defined via either
10:00:37 <the_lord> dmhouse: yes, but I receive Lists and have to send Lists
10:01:00 <the_lord> dmhouse: so It's better this way
10:01:01 <alar> oh
10:01:11 <alar> think it should return Parser ()
10:01:24 <dmhouse> negate p = do in <- getInput; either (return ()) pzero (parse p "" in)
10:01:29 <dmhouse> alar, yes, of course.
10:01:45 <dmhouse> I said that a few times :)
10:01:52 <alar> yes, your definition or something very similar
10:02:14 <dmhouse> getInput >>= either (return ()) pzero . parse p ""
10:03:02 <alar> this one looks nice
10:08:09 <mileswu> dmhouse: i apologize for what happened earlier. it was a very "funny" friend, who has just taught me to left my computer unlocked and unattended
10:08:24 <mileswu> dmhouse: i'm too trusting and forgetful
10:08:27 <dmhouse> mileswu: :) No problem.
10:08:49 <mileswu> dmhouse: at least i'm granted forgiveness. thanks
10:09:09 <dmhouse> mileswu: Did you friend strike anywhere elese?
10:09:14 <dmhouse> *else
10:09:22 <mileswu> dmhouse: no thank god
10:09:36 <palomer> mileswu: get off the computer, I prefer your friend
10:10:10 <alar> lol
10:14:17 <vincenz> palomer: I moved you around a bit
10:15:11 <palomer> you can't
10:15:14 <palomer> I'm not in belgium
10:16:14 <palomer> omg it's friday
10:17:09 <alar> @type arr
10:17:10 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
10:19:31 <alar> @type (>>>)
10:19:32 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
10:21:58 <CosmicRay> dons: are you around?
10:22:54 <dmhouse> @localtime dons
10:22:55 <lambdabot> Local time for dons is Sat Jul  1 03:21:03 2006
10:29:27 <dmhouse> @where ByteString
10:29:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
10:35:57 <the_lord> > nub ["[t1]","[t1]"]
10:36:02 <lambdabot>  ["[t1]"]
10:36:22 <palomer> what's the smallest quine ever found in haskell?
10:37:04 <jyp> main=putStr$q++show q;q="main=putStr$q++show q;q="
10:37:07 <jyp> I believe
10:38:37 <palomer> how does that program even make sense?
10:38:46 <palomer> oh, righto
10:40:03 <vincenz> hnop :D
10:40:23 <alar> hnop that weights 2.5M :)
10:43:01 * vincenz adds a post to the HNOP thread
10:43:51 <kpreid> palomer: if you accept "expression returning its source", this works:
10:43:53 <kpreid> > ap(++)show"ap(++)show"
10:43:54 <lambdabot>  "ap(++)show\"ap(++)show\""
10:45:05 <alar> extra \
10:45:14 <vincenz> kpreid: that's a quine function not a quite program
10:45:18 <alar> you should probably add putStr to the definition
10:46:19 <kpreid> jyp already supplied the other form
10:47:05 <Excedrin> 1 is a shorter "expression returning itself"
10:47:08 <Excedrin> > 1
10:47:09 <lambdabot>  1
10:47:19 <kpreid> @pl (\q -> putStr$q++show q) "..."
10:47:19 <lambdabot> putStr ("..." ++ show "...")
10:52:20 <alar> is map an arrow combinator?
10:55:43 <the_lord> @type and
10:55:44 <lambdabot> [Bool] -> Bool
10:55:57 <the_lord> @type concat
10:55:58 <lambdabot> forall a. [[a]] -> [a]
10:56:10 <SamB> alar: why do you ask?
10:58:46 <alar> SamB: because I don't have clear understanding of theese things yet
10:58:56 <schemebow> If I need library X to build library Y, then the location of X and Y are irrelevant, as long as they are installed via runhaskell Setup.lhs install, right? If that's true, then HXT-5.5 is broken.... 
10:59:07 <the_lord> > length ""
10:59:08 <lambdabot>  0
10:59:14 <the_lord> > length "" ++ ""
10:59:14 <lambdabot>  Couldn't match `[a]' against `Int'
10:59:18 <the_lord> > length ("" ++ "")
10:59:19 <lambdabot>  0
10:59:55 <alar> if arrows can be viewed as processes pipelines by (>>>) then map can be viewed as (>>>) for Kleisli arrow arising from [] monad
11:00:00 <alar> am I wrong?
11:01:34 <vincenz> see you all later
11:39:00 <sylvan> @where hnop
11:39:00 <lambdabot> http://semantic.org/hnop/
11:39:05 <sylvan> :-)
11:39:40 <Igloo> So, is someone going to write a @nop module for lambdabot?
11:40:21 <int-e> @id foo
11:40:21 <lambdabot> foo
11:40:25 <int-e> close enough?
11:41:26 <Igloo> You wouldn't catch hnop giving output!
11:42:46 <palomer> ok, what's hnop?
11:42:52 <dsacode> Hello! Is there some simple haskell library that implements polynomial arithmetic? (plus, minus, mult, divmod)
11:43:49 <palomer> hello!
11:53:59 <alar> hm
11:54:16 <alar> arrows seem to be somewhat more natural than monads
11:54:28 <alar> type of (>>>) is more intuitive
11:54:28 <palomer> take that bad, scoundrel!
12:00:30 <jyp> @arr
12:00:30 <lambdabot> This is the END for you, you gutter-crawling cur!
12:02:46 <xerox> ?yow!
12:02:46 <lambdabot> Kids, the seven basic food groups are GUM, PUFF PASTRY, PIZZA,
12:02:46 <lambdabot> PESTICIDES, ANTIBIOTICS, NUTRA-SWEET and MILK DUDS!!
12:02:53 <xerox> Wee.
12:02:53 <lambdabot> xerox: You have 1 new message. '/msg lambdabot @messages' to read it.
12:02:57 <xerox> Oh.
12:04:05 <int-e> hmm, the @tell module never saw the commands xerox gave, apparently. interesting.
12:04:50 <kombinator> has anyone heard of a hashtable implementation in STM?
12:10:34 <danb> i'm having some trouble putting a class declaration in a hs-boot file
12:11:02 <danb> everything i try gives the same error: "Illegal class declaration in hs-boot file"
12:11:17 <danb> yet the latest ghc users guide says, "Class declarations is exactly as in Haskell, except that you may not put default method declarations. You can also omit all the class methods entirely."
12:11:29 <danb> i'm using ghc-6.4.2
12:12:00 <danb> (ghc and ghci give the same error)
12:12:35 <alar> what is hs-boot file?
12:13:00 <danb> i've tried both: putting the full class declaration (no default method definitions) in the boot file; and putting just "class A" in the boot file
12:13:19 <danb> alar, http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
12:13:20 <lambdabot> Title: "4.6. Filenames and separate compilation"
12:13:51 <alar> thanks, danb
12:15:45 <danb> anyone have ideas on what i'm doing wrong, or if this might be a ghc bug?
12:17:02 <lightstep> in gtk2hs, how can i have the equivalent of cairo_matrix_init()? i want to invert the y axis, so is points upwards
12:18:11 <jyp> lightstep: ask xerox.
12:20:52 <lightstep> @seen xerox
12:20:52 <lambdabot> xerox is in #haskell.it, #perl6, #haskell-overflow, #haskell-blah and #haskell. I last heard xerox speak 17 minutes and 47 seconds ago.
12:21:28 <xerox> http://www.haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo-Matrix.html
12:22:36 <lightstep> these are all orientation-preserving operations
12:23:16 <xerox> Do you basically want to be able to construct a Matric out of 6 Double values?
12:23:50 <alar> scale is the right operation
12:23:52 <Stinger_> erm dont you just want to scale with x,y 1,-1
12:23:59 <Stinger_> and possibly translate
12:24:07 <alar> initmatrix is not for inverting axes
12:24:19 <alar> if Cairo uses PostScript model
12:25:13 <lightstep> i can scale by -1?
12:25:51 <xerox> http://darcs.haskell.org/gtk2hs/cairo/Graphics/Rendering/Cairo/Matrix.chs
12:26:00 <xerox> scale :: Double -> Double -> Matrix -> Matrix
12:26:02 <xerox> scale sx sy m = m * (Matrix sx 0 0 sy 0 0)
12:26:19 <alar> lightstep: why not?
12:27:07 <lightstep> well, there's no real reason. i also didn't notice the Matrix constructor
12:32:09 <DukeDave> a quick newbie question :)
12:32:49 <DukeDave> with records, I'm getting error: "Multiple declarations for selector "name"
12:32:49 <DukeDave> " 
12:33:12 <DukeDave> surely I can have two data types with a field called name ?
12:33:26 <xerox> Nope.
12:33:34 <xerox> Well, not in the same module.
12:33:42 <DukeDave> wow
12:33:49 <DukeDave> interesting
12:33:53 <edwinb> 'name' is actually a function...
12:34:03 <edwinb> which is why you can't do it
12:34:08 <xerox> A record with a `name' field defines a function |name :: Type -> String|.
12:34:49 <DukeDave> makes sense, I just assumed it could be overloaded to the datatype
12:34:53 <xerox> (If you have |data Type = .. { name :: String, .. }| for instance.)
12:34:58 <edwinb> it would be nice if it could ;)
12:35:14 <DukeDave> cheers guys
12:35:17 <xerox> In order to do that overloading you have to write the type class yourself.
12:35:41 <DukeDave> erk
12:36:01 <xerox> |class Named t where name :: t -> String| and |instance Named Type where name (Type name ..) = name| & co.
12:36:13 <lightstep> stay for a while, increase the high water mark
12:36:36 <xerox> Saw that, DukeDave?
12:36:59 <DukeDave> yeah, sorry I'm not as fast at comprehending as ghc :|
12:37:15 <xerox> Do you know type classes?
12:37:16 <int-e> lightstep: any idea how high it is? I believe I saw something around 220 once.
12:37:19 <edwinb> It is a lot of typing just to save another constructor name...
12:37:28 <edwinb> I usually just come up with a new name...
12:37:35 <lightstep> @wiki HaskellIrcChannel
12:37:36 <lambdabot> http://www.haskell.org/haskellwiki/HaskellIrcChannel
12:37:51 <DukeDave> I remember briefly reading up on them xerox 
12:38:14 <DukeDave> have been on holiday for two weeks and now I seem to have lost all ability
12:38:42 <int-e> lightstep: hmm, outdated and wrong wiki (I think @oldwiki gives you hawiki links)
12:38:46 <int-e> lightstep: but thanks.
12:38:47 <xerox> DukeDave - Basically a class is a set of types that define some function(s). Instantiating, in Haskell, means making that type belong to that set, by the means of giving appropriate definitions of the class' function(s).
12:39:38 <DukeDave> ah yes, I remember now,   'implements'
12:39:51 <xerox> Right.
12:39:57 <xerox> ?type (+)
12:39:58 <lambdabot> forall a. (Num a) => a -> a -> a
12:40:03 <xerox> ?instances Num
12:40:03 <lambdabot> Double, Float, Int, Integer
12:40:08 <xerox> (-:
12:40:38 <DukeDave> what would you call Num ?
12:40:40 <xerox> (Those are the possible `a's in lambdabot's environment for the (+) function.)
12:40:44 <DukeDave> a Super type?
12:40:48 <xerox> A class.
12:40:53 <DukeDave> gah
12:40:54 <DukeDave> :)
12:43:27 <lightstep> why does haskell take the closed-world approach to values and open-world approach to types?
12:44:01 <xerox> If I understand correctly your question the typing part makes it decidable.
12:46:38 <lightstep> you can have kinds and pattern-matching on types instead of typeclasses
13:01:03 <monochrom> Num is a typeclass.
13:01:40 <xerox> It's just that we don't have other classes, but sure.
13:02:25 <monochrom> We also have Haskell classes, as in, you go to a Haskell class to learn Haskell.  (duck)
13:02:38 <xerox> (shoot)
13:02:56 <monochrom> (goaaaaaaalllllll !!!!! )
13:03:09 <alar> C lasses
13:03:10 <xerox> Eeek. They're making such a noise around here.
13:08:22 * int-e wonders if there are typing classes where you leanr how to type haskell programs.
13:08:49 <palomer> int-e: do you remember the solution to the 4-gon problem I posted earlier?
13:09:50 <palomer> the solution you gave was ((b-d)cos(phi))^2 + ((b+d)sin(phi))^2 = c^2, I believe
13:10:15 <palomer> do you remember what it was?
13:10:25 <int-e> palomer: I don't remember the problem.
13:10:45 <palomer> nm then
13:10:46 <int-e> palomer: oh wait, I do, actually
13:11:40 <int-e> palomer: I had [a-(b+d)cos(phi)]^2 + [(b-d)sin(phi)]^2 = c^2
13:14:47 <palomer> righto
13:15:02 <palomer> which is a gizillion times simpler than my solution
13:15:20 <palomer> yeah, that's quadratic in cos(phi)
13:34:44 <xczv> www.twilightsex.com
13:34:46 <xczv> www.twilightsex.com
13:34:48 <xczv> www.twilightsex.com
13:34:50 <xczv> www.twilightsex.com
13:34:52 <xczv> www.twilightsex.com
13:34:54 <xczv> www.twilightsex.com
13:34:56 <xczv> www.twilightsex.com
13:34:58 <xczv> www.twilightsex.com
13:35:00 <xczv> www.twilightsex.com
13:35:02 <xczv> www.twilightsex.com
13:35:04 <xerox> Pfft.
13:35:04 <xczv> www.twilightsex.com
13:35:06 <xczv> www.twilightsex.com
13:35:08 <xczv> www.twilightsex.com
13:36:27 <kpreid> he just did that to #lisp too
13:36:36 <int-e> creative
13:36:44 <xerox> ...and #emacs, and #math.
13:37:37 <khaladan> who did what
13:38:03 <koffein__> spambot-thingy did spam
13:38:23 <koffein__> nothing extraordinary
13:40:44 <sjanssen> @keal
13:40:44 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
13:57:46 <bringert> morning #haskell
13:57:51 <bringert> or whatever it is
13:58:05 <bringert> xerox: how's cabal-get coming along?
14:02:37 <xerox> bringert - Started working on it today! Making my way throught the code.
14:02:51 <xerox> (Today it also finished the exams :)
14:04:07 <bringert> ah, that would do it
14:08:32 * xerox `ap` bed `ap` code
14:08:43 <gavino99> hey
14:13:27 <dmhouse> @ask vincenz what he wanted on #oasis?
14:13:28 <lambdabot> Consider it noted.
14:13:46 <gavino99> hey what is a continuation
14:13:52 <gavino99> why is ti important?
14:14:01 <gavino99> how does haskell compare to say java?
14:14:16 <gavino99> what echniques can be used to scael application in haskell?
14:14:18 <Itkovian> better
14:15:12 <gavino99> is ghc or hugs98 or nhc98 best haskell jvm?
14:15:23 <malcolm> gavino99: which question do you want answered first?
14:15:27 <dmhouse> JVM? Those are compilers...
14:15:36 <dmhouse> Haskell is nothing to do with Java.
14:15:42 <dmhouse> GHC is the most popular compiler.
14:16:36 <malcolm> dmhouse: although Hugs is reputed to have more users than ghc
14:16:52 <gavino99> ok
14:16:56 <dmhouse> malcolm: Hmm? Interesting. Where did you hear that?
14:16:56 <norpan> ghc has the most extensions
14:16:57 <gavino99> so haskell is compiled
14:17:02 <dmhouse> gavino99: Yep.
14:17:06 <gavino99> ok i will go with ghc
14:17:08 <norpan> or interpreted
14:17:22 <gavino99> so this java guy I know says that java is the best when things get really complex
14:17:26 <malcolm> dmhouse: I believe the Simons told me that
14:17:28 <gavino99> and u need your apps do do real work
14:17:42 <norpan> you know a java guy do you :)
14:17:45 <gavino99> how does haskell do with large systems?
14:17:57 <norpan> the size of the system is no problem
14:17:58 <gavino99> yeah hes kinda snotty but makes 3x money i do
14:17:59 <norpan> why should it be
14:18:04 <gavino99> I make 34/hr
14:18:11 <gavino99> ok
14:18:26 <gavino99> so with 100s of users adn different daabases haskell does fine?
14:18:40 <norpan> i don't see why not
14:18:58 <gavino99> you see some argue go with the battle tested thing but I am more risky
14:19:05 <gavino99> I think something different and better cna be fun
14:19:08 <gavino99> can
14:19:30 <gavino99> but java guy says stuff liek perl php etc are toys and real complex apps your fucked if u go with them
14:19:56 <norpan> java is popular
14:19:58 <malcolm> the Haskell webserver was comparable in scaleability to Apache (this is a few years ago)
14:20:10 <norpan> sun really did push java
14:20:25 <norpan> invested a lot in documentation and libraries
14:20:47 <gavino99> hm
14:20:53 <gavino99> so why do you like haskell?
14:21:03 <gavino99> does it let you write software more easily?
14:21:08 <norpan> yes it does
14:21:22 <norpan> especially when you do a lot of data processing
14:21:33 <gavino99> what does a beginner need to get started if a local linux pc is available
14:21:48 <gavino99> just ghc?
14:21:48 <norpan> you need a haskell compiler/interpreter
14:21:59 <norpan> yes, ghc has both a compiler and interpreter
14:22:13 <dmhouse> 'Interpreter' is a bit of a misleading term.
14:22:25 <norpan> is it?
14:22:34 <dmhouse> GHCi, which comes with GHC, is an interactive 'shell' which you use to do incremential development.
14:22:51 <norpan> it lets you type haskell expressions and evaluates them
14:22:52 <dmhouse> It turns out it interprets your sources, but this is a side issue, really.
14:23:03 <norpan> that's what i mean by interpreter
14:23:14 <Heffalump> It has both a compiler and a REPL. Better?
14:23:25 <norpan> it has what you need. best
14:23:39 * Heffalump needs world peace.
14:23:46 <vincenz> re
14:23:46 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
14:24:00 <sjanssen> Heffalump: that's in GHC 6.6
14:24:17 <jgrimes> :p
14:26:13 <gavino99> hm
14:26:15 <gavino99> ok
14:26:34 <gavino99> so if I learn haskell i can make cool interactive websites and get rich right?
14:27:05 <dmhouse> Haskell with Web-Dev is not really a fully researched area, but it has been done (e.g. Hope).
14:27:23 * Heffalump is doing some right now
14:27:34 <vincenz> Heffalump: you're a masochist?
14:27:37 <Heffalump> I'll let you know when I get rich.
14:27:47 <vincenz> @localtime Heffalump 
14:27:48 <lambdabot> Local time for Heffalump is Fri Jun 30 22:27:28 2006
14:27:49 <Heffalump> I think the basic infrastructure would have been easier in perl.
14:28:00 <vincenz> Heffalump: where is .li
14:28:02 <Heffalump> but the high level stuff I want to build on it will definitely be much much better in Haskell
14:28:10 <Heffalump> Lichtenstein, a small state near Switzerland.
14:28:15 <vincenz> ah right
14:28:18 <Heffalump> But I'm not actually there, it's a vanity domain.
14:28:21 <iron32> @hoggle import
14:28:21 <lambdabot> Prelude.import :: keyword
14:28:22 <lambdabot> Distribution.InstalledPackageInfo.importDirs :: InstalledPackageInfo -> [FilePath]
14:28:22 <lambdabot> Distribution.Simple.GHCPackageConfig.import_dirs :: GHCPackageConfig -> [String]
14:28:22 <Heffalump> I'm in the UK.
14:28:32 <Heffalump> how does lambdabot know my timezone, did I tell it?
14:28:39 <vincenz> Heffalump: ctcp
14:28:43 <Heffalump> ah :-)
14:28:48 <Heffalump> so it did.
14:29:23 <vincenz> Heffalump: work, undergrad student, phd student?
14:29:30 <Heffalump> right now I'm at home ;-)
14:29:31 <Heffalump> (work)
14:29:37 <dmhouse> Heffalump: whatcha' building?
14:29:39 * Heffalump works for http://www.arm.com
14:29:42 <lambdabot> Title: "ARM"
14:29:49 <Heffalump> dmhouse: a Bridge bidding assistant
14:30:04 <dmhouse> Ooh, fun.
14:30:19 <dmhouse> I should learn bridge, it's like the chess of card games.
14:30:21 <Dreadshoot> Heffalump: you code arm's?
14:30:33 <Dreadshoot> on*
14:30:36 <Heffalump> Dreadshoot: I work on ARM's compiler.
14:30:42 <vincenz> Heffalump: ah cool, I've actually been considering writing an ISS, and posisbly starting with a RISC, like an ARM7
14:31:04 <Dreadshoot> I know you can use asm on them, do they support anything else?
14:31:12 <vincenz> Dreadshoot: C most likely
14:31:20 <Heffalump> Dreadshoot: they support anything you can compile to machine code..
14:31:24 <Dreadshoot> mm yeah probably
14:31:32 * Heffalump isn't sure of the current status of the ghc port.
14:31:40 <Heffalump> I did have a play with fixing it but ran into some problem a while back.
14:31:46 <Dreadshoot> Heffalump: ah well, but do you think there is a c++ compiler for example?
14:32:00 <Heffalump> Dreadshoot: I don't think, I know :-)
14:32:08 <Heffalump> The compiler I work on is a C/C++ compiler.
14:32:09 <Dreadshoot> ok cool :)
14:32:09 <Heffalump> As is gcc.
14:32:22 <Dreadshoot> gcc works on arm?
14:32:28 <Heffalump> yes.
14:32:32 <Dreadshoot> oki
14:33:15 <dmhouse> Who lives near Frankfurt?
14:33:23 <dmhouse> (Specifically Rsselheim?_
14:33:27 <dmhouse> s/_/)/
14:33:54 <vincenz> Heffalump: what arm do you mostly work on
14:34:26 <vincenz> Heffalump: anyways, I was considering writing an ISS in haskell for fun, and making it very component-oriented, so that you can plug and play different pipeliners, datapaths, memory models, busmodels
14:34:42 <vincenz> Heffalump: I think that would be a cool project, and I believe ARMS are reasonably simple enough to use as a first one to work on
14:34:50 <vincenz> that or some other RISC, but ARM is widely used
14:35:11 <vincenz> Heffalump Mind if I privmsg something?
14:36:12 <Dreadshoot> you have overflowed him ;)
14:36:34 <Heffalump> vincenz: sure
14:36:41 <Heffalump> I wasn't reading IRC :-)
14:36:54 <Heffalump> vincenz: all of them. Mostly the unreleased cores, if anything.
14:38:51 <vincenz> Heffalump: Is there any nice document out there (that's available to the public) wit ha complete overview of the arch of one of them?
14:39:02 <vincenz> Heffalump: or should I just stick to the ..... forgot the name .... book
14:39:06 <Heffalump> the ARM ARM is the standard document
14:39:11 <Heffalump> there's nothing more than that
14:39:16 <Heffalump> I forget which architecture is released.
14:39:20 <vincenz> patterson and hennesy
14:39:22 <vincenz> grr
14:39:24 <vincenz> the book name is !
14:39:56 <Heffalump> the ARM ARM does have some clause in the front cover about it not being legal to use it to implement a simulator etc. I have no idea how legally enforceable that is.
14:39:59 <vincenz> Heffalump: is it legible?
14:40:07 <vincenz> Heffalump: o.O
14:40:13 <vincenz> Heffalump: well it'd be a personal project
14:40:15 <Heffalump> (The name stands for ARM Architecture Reference Manual)
14:40:23 <vincenz> Heffalump: at least for the time being....
14:40:28 <Heffalump> it's a pretty clear account of the architecture, yes.
14:40:37 <vincenz> Heffalump: No I meant hte patterson and hennesy book, forgot the name
14:40:43 <Heffalump> Computer Organisation and Design?
14:40:45 <vincenz> yep
14:40:58 * Heffalump hasn't read it
14:41:04 <vincenz> I'v skimmed it
14:41:05 <Heffalump> but I believe it's the standard work
14:41:11 <vincenz> it's got a nice bottom up approach to the design of a risc
14:41:23 <vincenz> I could always use that as body of reference
14:41:38 <vincenz> tho, do you think it would be a worthwhile venture?
14:41:52 * vincenz quietly curses as he hears the pornmodel sing on the radio (Paris Hilton)
14:42:02 <Dreadshoot> arm is that like the pic's avr's but more powerful?
14:42:16 <vincenz> Dreadshoot: no...pic's are microcontrollers
14:42:17 <vincenz> arms are cpus
14:42:18 <Heffalump> vincenz: errm, no idea.
14:42:29 <Heffalump> if you want an ARM ISS to use you could just get qemu.
14:42:37 <vincenz> Heffalump: heh,  we use qemu at work
14:42:41 <Heffalump> if you want to have a play with writing one, it seems a reasonable choice of architecture
14:42:47 <vincenz> colleagues of mine are extending qemu I think
14:43:00 <vincenz> Heffalump: oh no I meant, writing a plugnplay ISS
14:43:03 <vincenz> Heffalump: in haskell
14:43:17 <Dreadshoot> vincenz: well they are.. processors
14:43:19 <Heffalump> sounds nice to me.
14:43:36 <vincenz> Dreadshoot: ok, in detail
14:43:39 <Dreadshoot> and arm is for embedded stuff mostly, aint they
14:43:43 <vincenz> a) arms are not sold afaik, the arm is sold as ip core
14:43:48 <Heffalump> Dreadshoot: yes.
14:43:52 <vincenz> b) arms are meant for highlevel embedded stuff
14:44:01 <vincenz> pics are typically used for washingmachines or windowwipers
14:44:11 <Heffalump> well, people who buy the IP do make chips and sell them.
14:44:12 <Dreadshoot> yeah pics sux0rs
14:44:25 <Heffalump> ARM is trying to break into the deeply embedded world, with Cortex-M3.
14:44:36 <vincenz> Heffalump: define deeply embedded
14:44:43 <vincenz> Heffalump: do you guys collaborate wth ST?
14:44:54 <Heffalump> probably a bit higher up than washing machines, but I'm not really too sure
14:45:06 <vincenz> Heffalump: oh for human related things
14:45:09 <vincenz> ultra lowpoer
14:45:10 <Heffalump> vincenz: errm, dunno. And if I did it might be confidential so I wouldn't be able to say much anyway.
14:45:12 <vincenz> for biosensors
14:45:18 <vincenz> Heffalump: point taken
14:45:47 <Dreadshoot> what kind of stuff is there is pocket calculators?
14:45:51 <Dreadshoot> in*
14:45:56 <vincenz> Dreadshoot: dunno, but probably a dsp
14:46:12 <vincenz> heh
14:46:13 <vincenz> most likely
14:46:17 <vincenz> most calculators are TI
14:46:19 <vincenz> TI makes mostly dsps
14:46:26 <Dreadshoot> Casio and Ti
14:46:28 <vincenz> and some uLP riscs
14:46:33 <Heffalump> http://www.d-silence.com/story.php?headline_id=22387&comment=1 seems to be public evidence that we do.
14:46:54 <vincenz> Heffalump: you guys should consider collaborating with imec
14:46:56 <Heffalump> TI's OMAP range of chips are ARM-based.
14:47:09 <Heffalump> vincenz: tell our sales/marketing guys.
14:47:18 <vincenz> Heffalump: has nothing to do with sales
14:47:25 <vincenz> Heffalump: we do research, we don't sell products
14:47:33 <Heffalump> ah. Well tell our R&D team.
14:47:35 <vincenz> Heffalump: prolly more to do with highlevel management
14:47:49 <vincenz> Anyways, afaik imec's the largesT ME research center in euroep
14:48:13 <vincenz> and we collaborate with lots of companies, but which is of course confidential
14:53:52 <Dreadshoot> Heffalump: http://se.farnell.com/jsp/bespoke/bespoke7.jsp?att=adi&cmp=NLC-Findings&bespokepage=farnell/en/ed_world/news/manufacturer_news/2006/wk5/adi.jsp wonder if this is anything to have
14:54:36 <vincenz> Dreadshoot: why do yo want a uC and not a cpu?
14:54:54 <vincenz> and I doubt uC's have gcc backends
14:55:05 <Heffalump> there are plenty of places to get ARM7 kits, I have no idea how that compares to the others
14:55:35 <Heffalump> I think Atmel are the most frequently mentioned one.
14:55:37 <vincenz> Heffalump: it doesn't at all
14:55:40 <vincenz> that's a 12bit uC
14:55:41 <Dreadshoot> vincenz: im not even sure i got time for this, just looking around.. and what do you mean not cpu.. this is for arm?
14:55:52 <vincenz> Dreadshoot: it's a 12bit microcontrller for data acquisition
14:55:55 <vincenz> hardly a generic cpu
14:55:55 * Heffalump is really quite ignorant about hardware, I just write compilers.
14:56:15 <vincenz> Heffalump: hmm... seems like a problem
14:56:24 <vincenz> Heffalump: how do you write compilers without knowing about hardrware: P
14:56:28 <vincenz> :P
14:56:39 <Heffalump> I understand the architecture and the micro-architecture.
14:56:46 <Heffalump> I don't know very much about interfacing with peripherals, etc.
14:56:51 <vincenz> Heffalump: ah
14:56:52 <Heffalump> Cos in the main, I don't need to.
14:57:05 <vincenz> Heffalump: what kind of stuff do you work on precisely, or is that confidential
14:57:05 <Dreadshoot> whats the difference between uC and cpu then?
14:57:07 <vincenz> well not fully precisely
14:57:17 <vincenz> Dreadshoot: it's not a formal difference, more a continuum
14:57:37 <Heffalump> well, I'm one of the people that work on the compiler. Mainly I work on our mid-end, and I'm specifically responsible for the register allocator.
14:57:43 <vincenz> Dreadshoot: cpu's are generic, uC's are typically lowlevel designed for one sort of purpose, with some extra hardware (for instance for doing FIR ilters), but then lacking in generic instructions
14:57:48 <vincenz> Heffalump: sounds like a fun job
14:58:03 <Dreadshoot> okay, but basically the same thing then
14:58:21 <vincenz> Dreadshoot: for inistance I doubt you dan do virtual methods on a uC
14:58:31 <Heffalump> huh?
14:58:35 <Heffalump> that sounds like rather a large leap
14:58:46 <vincenz> no, I don't think you can do jumps based on data
14:58:47 <Heffalump> you can implement virtual calls on any architecture that has indirect jumps..
14:58:49 <Heffalump> ah.
14:58:52 <vincenz> well...you know what I mean
14:58:53 <Heffalump> fair enough.
14:58:54 <vincenz> indirect jumps
14:59:04 <vincenz> I doubt uC's have indirect jump capabilities
14:59:11 <Heffalump> but I think assuming that all uCs don't have indirect jumps is a bit much
14:59:15 <vincenz> Heffalump: thx for reminding me of the term
14:59:25 <vincenz> Heffalump: it's 12bit processor!
14:59:26 <Heffalump> the uC market is precisely what we are trying to move into with Cortex-M3, and I can assure you that has them ;-)
14:59:27 <int-e> hmm, you can always go the jhc way and make huge switch statements
14:59:36 <vincenz> Heffalump: yeah but you have uC and you have uC
14:59:46 <Heffalump> int-e: not very efficient to implement without indirect jumps, though :-)
14:59:48 <int-e> probably you'll run out of memory but it's possible.
14:59:48 <vincenz> Heffalump: a 12bit data acquisition cpu is not like a lowpoer genericc carm
14:59:58 <Heffalump> vincenz: yes ,ok
14:59:59 <vincenz> s/carm/arm
15:00:00 <Kasperle> how about MMUs then?
15:00:15 <vincenz> the chip that Dreadshoot posted earlier 
15:00:21 <Kasperle> those are generally not found on uCs, are they?
15:00:31 <int-e> Heffalump: true. you should probably avoid it if at all possible. But that doesn't mean it can't be done.
15:00:32 <vincenz> will a) most definitely not have a MMU, b) most liekly not have indirect jumps c) most likely not have a c compiler for it
15:00:43 <vincenz> Kasperle: nope
15:00:59 <vincenz> Kasperle: but in theory that doesn't need to be in the cpu
15:01:06 <Dreadshoot> vincenz: it was like 25$ just saw a link of it ;)
15:01:06 <vincenz> Kasperle: you can put that in an external unit I would think
15:01:19 <vincenz> Dreadshoot: look for some generic RISC based processor
15:01:39 <SamB_XP> is it like a SIC??
15:01:47 <vincenz> SamB_XP: SIC?
15:02:00 <SamB_XP> Single Instruction CPU or something like that
15:02:01 <int-e> Heffalump: there's also the option of self-modifying code; there probably won't be many issues with prefetching or caches in a simple architecture like that.
15:02:07 <vincenz> SamB_XP: SISD?
15:02:17 <vincenz> SamB_XP: there are rscs that are SIMD
15:02:25 <vincenz> s/rscs/riscs
15:02:49 <vincenz> int-e: you need write accecss to the instruction memory
15:02:51 <int-e> hmm. although if the code is in ROM, that'll be sort of hard to accomplish *shrugs*
15:02:54 <SamB_XP> no, a cpu that only has one kind of instruction ;-)
15:02:57 <vincenz> int-e: simple systems like that typically have split data nd instruction memory
15:03:01 <vincenz> int-e: EVEN if it is writable
15:03:14 <vincenz> int-e: I doubt you have write or read statements to instruction memory
15:03:24 <vincenz> int-e: that's prolly in the instruction fetch unit and not available to instructions
15:03:43 <vincenz> like I said, not generic
15:03:53 <vincenz> but yeah, the spectrum between uC and cpu is rather... fuzzy
15:04:40 <vincenz> smoke time
15:04:47 <vincenz> and then time to add SSA stage to my compi
15:04:57 <vincenz> Heffalump: btw, I take it you have a lot of knowhow on compiler construction
15:05:01 <Dreadshoot> vincenz: i'll just stuck to x86 i guess, but the thought of just testing to program something for a arm is a little bit tempting
15:05:17 <vincenz> Heffalump: I have my own compiler for a language close to ML... and I need to to a whole bunch of analyses... mind if I refer to you from time to time
15:05:21 <vincenz> Dreadshoot: heh. go for RISC, they're nicer
15:05:30 <vincenz> Dreadshoot: x86 is CISC
15:05:47 <Dreadshoot> so? kicks ass :)
15:06:11 * vincenz wonders in fact how compilers do effective maximal munch for CISC cpus when generating asm
15:06:23 <vincenz> Dreadshoot: HAH
15:06:24 <vincenz> Dreadshoot: hardly
15:06:59 <vincenz> flopwise dsps are much better
15:07:04 <vincenz> and powerwise, riscs or dsps
15:07:09 <Dreadshoot> sure they do, getting a 2-500mhz arm or whatever they are on wont beat by comps or even come close
15:07:11 <vincenz> depending on what you want
15:07:48 <vincenz> Dreadshoot: sure but you get 500mhz at a few Watt, while you get 2 GHZ for 100 Watt... hardly seems 
15:07:53 <vincenz> ..hardly seems linear
15:08:37 <Dreadshoot> hmm, those 100w costs like nothing in electricy cost anyway so why care about it? its the hardware thats expansive
15:09:26 <vincenz> Dreadshoot: why should you care?
15:09:29 <vincenz> cause packages break down
15:09:45 <vincenz> cause it's very complex to keep cooling these things and they're at their heat levels
15:09:51 <vincenz> cause even intel realizes they should care
15:09:56 <Dreadshoot> No it aint
15:09:57 <vincenz> why do you think the sudden move to multicore
15:10:01 <int-e> vincenz: x86 has become very good at executing the RISC-ish code that compilers like gcc produce.
15:10:18 <vincenz> int-e: at which point you wonder what the use is of all the complex instructions
15:10:27 <vincenz> int-e: instead simplify the core and throw out the useless crud
15:10:31 <Dreadshoot> you put on a fan and a cooling block, no problem with that, and besides we keep servers in a cool server hall
15:10:40 <vincenz> Dreadshoot: keep on dreaming
15:10:51 <vincenz> didn't you hear of the intel 4 melting down?
15:10:52 <Dreadshoot> vincenz: say what?
15:10:59 <vincenz> erm pentium 4
15:11:17 <vincenz> not to mention that with the new 65 nm and especially below, high temperatures lead to high leakage current which heat even more
15:11:17 <Dreadshoot> vincenz: yeah if you are stupid enough to remove the cool block, why not
15:11:21 <vincenz> possibly melting your cpu inside
15:11:42 <vincenz> cause ou have a high chance of hotspots
15:12:09 <int-e> vincenz: Hmm. I don't think you'd get much simplification in the core anymore. Mind you, I don't know, but I'd think that instruction decoding to some sort of microops doesn't take much of the core's chip area; it's the execution units and the scheduling stuff, register renaming, forwarding, memory access, and so on. You'd need that for RISC as well.
15:12:10 <Dreadshoot> vincenz: i handle like 10 servers, from 150k$ and below and several comps at home, i havent had any heat problems with any of them
15:12:45 <int-e> vincenz: to achieve similar performance.
15:12:47 <vincenz> int-e: dunno, my knowhow of is limited
15:13:01 <Dreadshoot> multicore is for performance wise sure, but you have been able to run several cpu systems before that also
15:13:01 <vincenz> Dreadshoot: that's great... they're not gonna sell faulty products of course
15:13:35 <Dreadshoot> vincenz: so then whats the problem
15:13:41 <vincenz> forget it
15:13:50 * vincenz goes to get a smoke
15:13:58 <int-e> vincenz: and in principle CISC could even win by fitting more code into caches, due to smaller instruction encoding.
15:14:12 <Dreadshoot> the thing is you cant put in p4's/amd64 for example in small embedded systems, but for servers, desktops they are superior
15:14:14 <vincenz> int-e: that's arguable as you need more bits
15:14:27 <vincenz> int-e: and if you want that, just go for DSPs 
15:14:43 <Dreadshoot> or well there is others good for servers also, but these are totally ok
15:14:48 <vincenz> Dreadshoot: yes until recently, the heat problem is a serious problem and intel acknowledged this at conferences last year
15:15:23 <vincenz> int-e: my knowledge there is limited, is instruction cacche a great bottleneck?
15:15:25 <Dreadshoot> vincenz: No, videos has been showed several years ago, even 5 years ago they produces a high watt
15:16:11 <vincenz> Dreadshoot: the problem is that you can't have high temperatures with low technology nodes
15:16:18 <vincenz> and now I'm really going for that smoke
15:16:24 <vincenz> heat IS an issue with 65nm and below
15:16:38 <Dreadshoot> there is cooling options
15:16:40 <vincenz> in fact so much so there's been an onsurge of papers in heatrelated techniques
15:16:45 <vincenz> Dreadshoot: no, heat INSIDe the cpu
15:16:57 <int-e> vincenz: I'm not sure myself. Inner loops tend to be small - and most of the time that's what matters.
15:17:14 <Dreadshoot> vincenz: yes ofc, but the ones released to the market haveing no problem to run
15:17:15 <int-e> vincenz: so it probably doesn't make much of a difference
15:17:49 <mileswu> has anyone got any suggestions on the data constructors used for a b* tree. because there is always n+1 values/connectors for n keys
15:18:07 <vincenz> Dreadshoot: for instance why do you think intel implemented the (crude) technique of shutting down a core when it overheats
15:18:15 <vincenz> Dreadshoot: cause of leakage currents in sub65nm
15:18:23 <lispy> oh, is HNOP going to be included in the standard libs? looks like simon thinks so...
15:18:25 <Heffalump> vincenz: sure, though I'm not all that experienced.
15:18:41 <gavino99> ok here is a programming problem for ya
15:18:43 <gavino99> ready?
15:18:51 <lispy> gavino99: wait...okay ready
15:18:58 <mileswu> gavino99: go
15:19:09 <gavino99> 30 linux boxes have a file, /var/bkupexec/agnet.cfg
15:19:31 <gavino99> near the bottom of the file is a line that reads "tell PCS019N"
15:19:38 <Dreadshoot> vincenz: it still aint a problem for the market, more for their developement team, exactly same thing as going to high precision (x)nm makes new problems and harder to make. As a use we hardly even encounter any problems with the released products and the heat
15:19:47 <gavino99> I need to add the line "tell epobackup" right below it
15:19:58 <gavino99> then /etc/init.d/agent.init stop
15:20:07 <gavino99> and /etc/init.d/agent.init start
15:20:12 <gavino99> for all 30 boxes
15:20:17 <gavino99> how do I script that?
15:20:24 <Heffalump> I'd suggest a quick perl script, but that might get me lynched here.
15:20:45 <gavino99> login is same on all 30 boxes
15:20:59 <lispy> you don't need perl
15:21:02 <cjay> a shellscript should do it, too
15:21:10 <vincenz> Heffalump: have any experience in flow-analysis
15:21:14 <int-e> vincenz: I'm curious how the picture will look like in 5 years. Will we have even faster CISC processors or will we try to harness the power of a few dozen or more, smaller, slower, and maybe RISC, cores?
15:21:15 <mileswu> well there is a shellscript that executes the same command on all boxen
15:21:15 <vincenz> Heffalump: or dependencec
15:21:23 <lispy> you just need cat "tel epobackup" >> <your file>
15:21:26 <Heffalump> vincenz: yes.
15:21:29 <vincenz> int-e: embedded for sure is going heterogenoeous multicore
15:21:40 <vincenz> int-e: riscs for system control with dsp for processing
15:21:49 <vincenz> well not going, it's already there
15:21:58 <vincenz> tho more cores will be included
15:22:00 <Dreadshoot> int-e: 5 years..? look at amd and intels roadmaps
15:22:22 <vincenz> int-e: either way, multicore _is_ the only way forward
15:22:44 <vincenz> whether risc or cisc, that I don't know, I should ask my hardware oriented colleagued
15:22:47 <Dreadshoot> no its not the only way forward, but its a big way
15:23:16 <vincenz> Heffalump: mind joining #oasis?
15:24:24 <mileswu> anyone got any ideas for b-tree data constructs
15:25:05 <gavino99> so no one can help me?
15:25:26 <mileswu> gavino99: well do you have ssh passwordless login on all of them?
15:27:56 <mileswu> gavino99: if you do then bash script it quickly
15:33:12 <gavino99> no
15:35:07 <mileswu> gavino99: hmmm... well you can still do the script. you'll just have to type your password in 30 times
15:35:17 <mileswu> gavino99: you can't really do it any other way unfortunately
15:35:45 <gavino99> you can't log in as user:pass@box
15:36:18 <cjay> maybe echo pass | ssh ... works
15:36:18 <gavino99> how do I make bash print something
15:36:28 <gavino99> oh echo
15:36:58 <cjay> if you have to do that often, you should set up ssh key stuff
15:37:13 <mileswu> gavino99: no cjay: no cos of ssh uses ptys to ask for the password
15:37:35 <cjay> hum
15:37:58 <cjay> then make your script and copy&paste the pass 30 times, shouldn't take too long :)
15:38:24 <mileswu> cjay: you have any idea about b-trees?
15:38:34 <cjay> no
15:40:28 <gavino99> hm
15:40:35 <gavino99> please let me kow if u know this one guys
15:40:50 <gavino99> I have to add 1 line to a config file on 30 linux boxes and restart the agent
15:42:27 <vincenz> Anyone know why someone wouldn't be able to connect to freenode with mirc
15:45:30 <norpan> not really
15:45:50 <lispy> lets say a i have a bunch of values with different types but they are all instances of the same type class (in this case show) is it possible to write a general function that takes the values as a list and shows them?
15:46:11 <lispy> for example, showAll :: Show a => [a] -> [String]
15:46:23 <lispy> except that requires that a is always the same type
15:46:42 <lispy> i want to do showAll [1, 'h', "hello"]
15:47:01 <norpan> why?
15:47:17 <lispy> to make writing a custom instance of show easier :)
15:47:44 <lispy> show now i'm doing the equivalent of show (1, 'h', "hello")
15:48:09 <vincenz> FUCK
15:48:12 <vincenz> my laptop charger died
15:48:18 <norpan> show 1 ++ show 'h' ++ show "hello"
15:48:22 <norpan> why is that so bad?
15:48:53 <lispy> because it doesn't generalize
15:48:56 <vincenz> :(
15:49:00 <norpan> it doesn't?
15:49:18 <lispy> norpan: i have to type that again for each dataconstructor
15:49:35 <lispy> i'd rather just put them in a list and call a function that shows them
15:49:41 <norpan> but you have to put the elements in a list for each data constructor
15:49:47 <norpan> so why is the other more work?
15:49:58 <vincenz> I have to run!
15:50:01 <vincenz> 20 minutes left in battery
15:50:02 <vincenz> :(
15:50:05 <lispy> because you have to type show and ++ between them, and i'm inserting spaces
15:50:15 <stepcut> vincenz: should have gotten one of those $100 laptops with the crank
15:50:20 <stepcut> :p
15:50:23 <lispy> so i'm doing, show 1 ++ " " ++ show 'h' ++ " " ++ show "hello"
15:50:27 <norpan> so define a new operator that is (++ " " ++ show)
15:50:36 <vincenz> stepcut: they cancelled the crank
15:50:41 <vincenz> still... only 1 year of battery charger
15:50:42 <kpreid> lispy: existential types is the direct answer
15:50:45 <vincenz> well 1 and 3 months
15:50:47 <vincenz> erm
15:50:48 <vincenz> 2 months
15:50:48 <stepcut> vincenz: now it's a foot pedal or something ?
15:50:49 <vincenz> :(
15:50:54 <vincenz> stepcut: can't talk
15:50:56 <int-e> vincenz: good night
15:50:58 <vincenz> battery decharging
15:51:01 <vincenz> gotta shutdown linux
15:51:05 <vincenz> int-e: cya.. not soon tho
15:51:06 <lispy> kpreid: hmm...how does that work?
15:51:09 <vincenz> not untl I have a charger
15:51:59 <kpreid> lispy: data AnyShow = forall a. (Show a) => AnyShow a; instance Show AnyShow where show (AnyShow x) = show x
15:52:12 * cjay worders how far vincenz is from civilization :>
15:52:22 <kpreid> lispy: then show [AnyShow 1, AnyShow 'h', AnyShow "hello"]
15:52:26 <cjay> s/wor/won/
15:52:44 <norpan> kpreid: and that is less work?
15:52:54 <lispy> kpreid: but i don't have control over the class i'm writing the show instance for, so it doesn't help much does it?
15:53:01 <kpreid> eh?
15:53:09 <kpreid> the definition I gave above is all you need
15:53:34 <norpan> a (+#) x = a ++ " " ++ show x; infixr (+#)
15:53:47 <int-e> hmmmmm. instance Show ShowS where shows = id
15:53:52 <kpreid> lispy: you could also make a data type which is a list-of-Showables, but then you'd have to write 1 `myCons` 'h' `myCons` "hello" `myCons` `myNil`
15:53:58 <norpan> then "" +# 1 +# 'h' +# "hello"
15:54:29 <lispy> hmm
15:54:30 <norpan> err, infixl
15:54:38 <kpreid> lispy: there is simply no way to make [1,'h'] acceptable, because [] is always homogenous
15:54:43 <lispy> maybe i'll just stick with the tuples...
15:54:52 <kpreid> norpan's solution is probably more the right thing
15:54:57 <lispy> they ain't so bad, and it was quick to type in
15:55:10 <lispy> yeah, that one isn't bad
15:55:50 <norpan> since you are constructing the list anyway, you might as well construct something else
15:56:26 <norpan> it would be different if you had the list beforehand, but then you'd probably have some Datatype = I Int | C Char | S String
15:56:50 <kpreid> lispy: also you could write show3 (a,b,c) = show a ++ " " ++ show b ++ " " ++ show c
15:56:56 <kpreid> and bury it in a library somewhere
15:57:13 <norpan> then you could just as well have show3 a b c and no tuple
15:57:18 <kpreid> well, yes
15:57:41 <lispy> yeah i thought about that too
15:57:59 <lispy> my tuples are different lengths, so then i'd have to write a bunch of showN functions
15:58:01 <norpan> do you have a lot of constructors to do this for?
15:58:11 <lispy> only like 15
15:58:16 <norpan> well then it's no problem
15:58:18 <lispy> so i'm done already
15:58:21 <norpan> any solution will do
15:58:40 <norpan> sometimes you need to be pragmatic :)
15:59:06 <lispy> well, this isn't the last time i'll encounter this pattern
15:59:25 <lispy> which is why i was hoping there was a general solution that i liked
16:00:36 <norpan> i've always written show and it is quick
16:01:07 <norpan> most of the time i use the pretty printer stuff
16:03:27 <norpan> show is so crude
16:07:31 <roods> if i'm doing some excercises from CLR is haskell a good language to use?
16:08:51 <fanopanik> CLR?
16:11:02 <sjanssen> roods: you mean the algorithm book?
16:11:11 <roods> yup.
16:12:04 <Dreadshoot> what book is that?
16:12:09 <sjanssen> yes, Haskell is usually nice for that sort of thing
16:12:38 <roods> okay i'll drop the haskell bomb on my machinez!
16:12:54 <Dreadshoot> c++ :)
16:12:56 <norpan> da bomb
16:12:57 <roods> i'm installing GHC
16:13:08 <roods> not that date drug
16:13:32 <roods> Dreadshoot: nawh big dawg, it is in pseudo-code.
16:13:52 <roods> pseudo kind of has nothing that rhymes with it.
16:13:54 <roods> like orange.
16:14:13 <norpan> GHC is the next best thing after GHB
16:14:48 <roods> that is gang*
16:14:58 <Dreadshoot> well c++ is kickass so :)
16:15:22 <norpan> yes, using c++ feels like being kicked in the ass
16:15:24 <roods> not as kick ass as haskell.
16:15:32 <roods> oh no you didn't norpan 
16:15:51 <norpan> i didn't?
16:15:57 <roods> there he goes again.
16:16:09 <norpan> no comprendo
16:16:13 <roods> how long does it take someone of my level to learn haskell?
16:16:30 <SamB> what do you mean when you say "learn"?
16:16:39 <norpan> two years
16:16:46 <norpan> that's my standard reply
16:16:54 <norpan> one year if you're smart
16:16:59 <norpan> six months if your smarter
16:17:02 <roods> do most people here use Hugs or GHC?
16:17:10 <norpan> i use both
16:17:15 <norpan> so, yes
16:17:20 <roods> damn! i only use J right now, because it is PIMP
16:18:26 <jer> takes an afternoon to learn haskell if you're a good bullshitter (but then i guess you're not really learning it) =D
16:19:25 <roods> i'll learn it crazy now. 
16:19:40 <roods> jer: let me know if you need any help with your programs.
16:20:01 <jer> any of them? or just the haskell ones?
16:20:01 <jer> =]
16:20:23 <roods> well i'm an expert C++ programmer and an expert APL programmer.
16:20:39 <roods> and QBASIC is also something i'm a grand master in.
16:20:49 <iron32> roods: My condolences to you
16:20:50 <jer> i see
16:20:52 <norpan> apl is good experience for haskell
16:21:01 <roods> i don't really use apl i use J
16:21:01 * jer is a jack of all trades, master of none =[
16:21:05 <roods> but same difference.
16:21:09 <roods> just no funny characters.
16:21:22 <roods> not sure how much you know of either language.
16:28:00 <freshhawk> has anyone else done the project euler problems? (http://mathschallenge.net/index.php?section=project)
16:28:01 <lambdabot> Title: "mathschallenge.net"
16:28:18 <freshhawk> doing them all in haskell now. good way to get started
16:28:50 <Dreadshoot> did them in c++
16:28:56 <roods> freshhawk: i do crazy math shizal
16:28:59 <Dreadshoot> or some at least, its time consuming
16:30:11 <freshhawk> Dreadshoot, yeah, for some reason i want to complete them all, it's going to take a while
16:30:39 <roods> i did them all but using template metaprogramming 
16:30:52 <Dreadshoot> the math is the easy part, its all functions you have to create in c++ that takes time
16:31:29 <freshhawk> Dreadshoot, yeah...i wouldn't do them in c++. but then again, i wouldn't do anything in C++
16:31:35 <Dreadshoot> and i did it when i hadnt used c++ seriously for long either so i had a very tiny code base
16:32:05 <freshhawk> roods, a few people have done them all in assembly
16:32:32 <Dreadshoot> well, c++ is pretty good to do them in, and you can mix it with just solving with the head or mathematica also
16:38:07 <freshhawk> there are a fair number that are just paper/pencil problems but i'm trying to do the rest in haskell to pick up the basics (well the ones that apply to that problem domain anyway)
16:39:03 <freshhawk> i could see doing them in C or perl for sure (not a fan of C++) but that wouldn't teach me much.
16:41:51 <Dreadshoot> hmm, most c code is also legal c++, and its not like you are gonna make any classes templates for these math problems
16:43:38 <freshhawk> Dreadshoot, good point, in this case C/C++ makes no difference except that i'd have to admit coding in C++ ;)
16:46:18 <DukeDave> part of my assignment:  convert integer value of pence in to a string  pounds.pence.   I'm using div and mod as required; however, eg. 1202 should return 12.20, and not 12.2.  can anyone recommend a `clean' way to do it?
16:47:12 <roods> freshhawk: why aren't you a fan of C++?
16:47:16 <roods> just curious
16:48:25 <Lemmih> > showFFloat (Just 2) 12.2 ""
16:48:26 <lambdabot>  "12.20"
16:49:16 <freshhawk> roods, I find most of the stuff that was added to C to make C++ to be either unnecessary or grating. I don't actively hate it or anything, i just don't like the feel
16:49:52 <roods> freshhawk: interesting, i'm a big fan of it.
16:50:04 <freshhawk> roods, but i program a lot in perl so complaining about weirdness in the template / class system is kindof stupid of me
16:50:22 <freshhawk> roods, not that i wouldn't switch to ruby or something saner if the libraries were there
16:50:34 <roods> i think the real value in C++ is in encapsulation
16:50:35 <DukeDave> cheer Lemmih 
16:50:45 <roods> not templates.
16:51:02 <freshhawk> true, the templates are something that perhaps i do hate
16:51:16 <roods> perl is nice but i'm not too big of a fan.
16:51:21 <DukeDave> urm, showFFloat not in std prelude?
16:51:29 <DukeDave> @find showFFloat
16:51:30 <lambdabot> Not in scope: type variable `showFFloat'
16:51:30 <DukeDave> :o
16:51:47 <roods> really you hate templates?
16:52:10 <roods> i use templates all the time, i find languages like java that don't have a similar construct very annoying.
16:52:18 <freshhawk> roods, perl is only good for getting things done quickly and ugly-y but that's a lot of what i do at work
16:52:29 <roods> true.
16:52:52 <freshhawk> i don't like the implementation of templates in C++
16:53:02 <roods> perl lends itself to parsing files and such. i haven't written many perl programs that are much larger then a couple 100 lines.
16:53:16 <roods> freshhawk: i'm not sure what that means.
16:54:16 <freshhawk> i work on a huge perl project, millions of LOC in total i'm sure
16:56:00 <freshhawk> roods, well the idea of templates is a good one, but the actual use of them in C++ is something that seemed ugly to me. there are some issues with them for sure
16:56:11 <freshhawk> roods, could be worse though, they could be java generics
16:59:23 <mlh> @type showFFloat
16:59:24 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> ShowS
17:01:23 <DukeDave> okay, the other way round now
17:01:53 <DukeDave> 2 :: Int should become "02"
17:02:10 <DukeDave> again, I can think of a way to do it, but it's ugly :|
17:15:58 <Korollary> > (Text.Printf.printf "%02d" (2::Int)) :: String
17:15:58 <lambdabot>  "02"
17:19:32 <int-e> funny. lost track of this window.
17:22:02 <kpreid> > (Text.Printf.printf "" (2::Int)) :: String
17:22:03 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
17:22:17 <kpreid> > (Text.Printf.printf "%02d") :: String
17:22:18 <lambdabot>  Exception: Printf.printf: argument list ended prematurely
17:22:45 <kpreid> @type (Text.Printf.printf "")
17:22:46 <lambdabot> forall r. (PrintfType r) => r
17:23:06 <kpreid> @instances PrintfType
17:23:07 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
17:23:16 <kpreid> @instances-inporting PrintfType Text.Printf
17:23:17 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
17:24:17 <Lemmih> @instances-inporting Text.Printf PrintfType
17:24:18 <lambdabot> (a, IO a, [c]
17:25:15 <Korollary> Lemmih: Is jlouis still contributing to conjure? Or, who else is?
17:29:12 <Lemmih> Korollary: I haven't heard from jlouis since I forked the project.
17:29:29 <Lemmih> Korollary: ADEpt and SamB have helped a lot.
17:29:34 <Korollary> Lemmih: Is it just you nowadays?
17:30:50 <Lemmih> Well, I'm sure others would contribute if I had enough time to pull the main load.
17:31:19 <Lemmih> Right now I'm too busy to even maintain it.
17:34:18 <Korollary> Ok. May I email you with patches or questions?
17:42:21 <SamB> Lemmih: I have cable now, so I actually have enough bandwidth to properly test it ;-)
17:43:12 <SamB> though at the moment I've gotten myself into a big mess in ZSNES. which is to say, the debugger ;-).
17:43:24 <SamB> for some reason I was crazy enough to volunteer to port it
17:53:30 <DukeDave> \quit
17:53:33 <DukeDave> lol
18:10:57 <Lemmih> SamB: There's nothing to test, unfortunately.
18:36:18 <SamB> Lemmih: you broke it?
18:42:45 <lispy> oh man, the HNOP thread just keeps getting funnier
18:47:07 <Lemmih> SamB: Never finished it.
21:00:14 <user317> i cant seem to build bindings with hsc2hs on windows that work on linux
21:00:46 <ruffneck> windus ;) hehe
21:00:56 <ruffneck> they are different programs
21:01:53 <ruffneck> the hardware isn't compatible
21:02:00 <user317> it looks like it cant find any of the cymbols that are in the hsc_make.c file
21:02:18 <user317> i mean symbols :), i cant spell
21:03:01 <ruffneck> I really don't understand quite
21:03:09 <ruffneck> but then again I'm pretty much going to sleep now
21:03:39 <user317> anyone use c2hs on win32?
21:03:47 <ruffneck> no.. I don't know what is it
21:03:52 <ruffneck> hmm
21:03:54 <ruffneck> decrypting...
21:03:56 <ruffneck> c to haskell
21:04:00 <user317> yea
21:04:03 <ruffneck> never done that
21:04:07 <ruffneck> I don't do c anyway
21:04:21 <ruffneck> then again I could learn haskell by making the transformation
21:04:30 <ruffneck> to see how code in c transformes to haskell
21:04:41 <ruffneck> but is it the right approach?
21:04:50 <user317> right approach to what?
21:04:51 <ruffneck> or should you try to get rid of the old paradigm
21:04:58 <ruffneck> to learn a new language
21:05:07 <user317> the only way to learn is to use it
21:05:08 <ruffneck> you could learn a new paradigm along with it
21:05:14 <ruffneck> if you don't use the models from other languages
21:05:18 <user317> once you write 10k lines of code you'll know it
21:05:31 <ruffneck> true, using it gives you physical memory traces
21:05:31 <user317> so think of some project that needs to get done and use haskell for it
21:05:48 <ruffneck> yea.. any good and fun ideas what to do with it?
21:05:56 <ruffneck> when anything is possible.. what actually are you choosing from?
21:06:12 <user317> what do you mean?
21:06:15 <user317> choosing from what?
21:06:56 <ruffneck> choose from design solutions and the underlying paradigm of the model
21:07:12 <user317> you are not saying anything, just a bunch of buz words
21:07:24 <ruffneck> it makes sense to me
21:07:28 <ruffneck> may I'm flipping out :D
21:07:31 <ruffneck> maybe
21:07:46 <ruffneck> I mean.. it's a bit difficult to decrypt
21:08:04 <ruffneck> I meant to ask what kind of application would be fun and not making it on the basis of old habbits
21:08:33 <user317> whatever needs to get done :)
21:08:34 <ruffneck> not making haskell just a transformed version of c but something new and totally difrerent (approach)
21:08:41 <ruffneck> I Don't have needs
21:08:48 <ruffneck> I could live all my life without the computer
21:09:03 <user317> hehe, you are in the wrong profession then
21:09:37 <ruffneck> anything other than computers is frong profession? 
21:09:43 <ruffneck> wrong ;P
21:10:26 <ruffneck> or any profession which doesn't need computers would be lesser.. maybe at efficiency, maybe
21:10:33 <user317> if you can live without computers, then you shouldn't really be doing computers as your profession
21:10:46 <ruffneck> well.. have computers actually made something efficient.. lot of things for sure.. but then making new obstacles
21:11:03 <ruffneck> yea.. I kind of profession in the are between computers and anything else
21:11:10 <ruffneck> the "user interfeace"
21:36:04 <user317> whats the difference between hsc2hs and c2hs
21:36:14 <dons> c2hs is more magic
21:36:36 <user317> is there a c2hs on cygwin or win32?
21:36:48 <dons> it just reads C files to generate complete .hs code. hsc2hs requires .hscfiles, which are a mixture of C and haskell
21:37:02 <dons> user317: i think so. don't see why not
21:37:22 <user317> # runhaskell Setup.hs {configure,build,install}
21:37:22 <user317> *** Exception: Line 21: Unknown field 'hs-source-dirs
21:37:23 <user317> on win32
21:37:29 <user317> c2hs doesn't build for me
21:37:33 <dons> you've got an old Cabal
21:37:49 <ruffneck> what is difference between hsc and c ?
21:37:56 <dons> change hs-source-dirs to hs-source-dir in the .cabal file
21:38:03 <dons> or update your cabal version.
21:38:41 <ruffneck> sorry the unimportant utilityless questions ;P
21:39:21 <user317> does cabal come iwth ghc?
21:40:00 <dons> hsc is a mixture of C and haskell in the one file.
21:41:16 <ruffneck> what does the haskell do with c ? metadata or the code ?
21:41:25 <dons> ?
21:41:29 <ruffneck> how do you use 2 languages in one
21:41:58 <user317> its just bindings, it automates the marshalling, etc...
21:42:16 <user317> like remote stuff in java/python
21:43:18 <ruffneck> ok =)
21:47:09 <user317> basically it takes a haskell type and translates into an equivalent type in C and vice versa, it also makes sure that all the required stuff for the C run time has been initialized before it calls the function
21:55:59 * wli tries to figure out how to use haspr
21:57:23 <wli> I was under the impression hsc was generated C with a large supporting library of runtime/etc. affairs.
21:57:47 <SamB> I think it generates both Haskell and C
21:58:06 <SamB> (which must be linked together to do any good)
21:58:47 <wli> haspr seems to have a dearth of documentation
21:59:20 <SamB> or are you talking about the output of GHC?
22:00:10 <wli> It's the impression I got from looking at ghc's hsc output.
22:00:15 <ruffneck> what is dearth ?
22:00:27 <wli> ruffneck: lack, absence, etc.
22:00:41 <SamB> apparantly hsc has more than one meaning...
22:00:49 <ruffneck> oukei =) thanks... somebody should make a new dictionary.. I could take that as my project then
22:00:55 <ruffneck> to code a new dictionary
22:01:08 <wli> dict(1) should do.
22:01:12 <SamB> no, wait, you are talking about .hc files!
22:01:20 <ruffneck> we have dearth of dictionary
22:01:28 <wli> sorry, hc yes.
22:01:35 <SamB> @web1913 dearth
22:01:36 <lambdabot> *** "Dearth" web1913 "Webster's Revised Unabridged Dictionary (1913)"
22:01:36 <lambdabot> Dearth \Dearth\, n. [OE. derthe, fr. dere. See {Dear}.]
22:01:36 <lambdabot>   Scarcity which renders dear; want; lack; specifically, lack
22:01:36 <lambdabot>   of food on account of failure of crops; famine.
22:01:36 <lambdabot>  
22:01:38 <lambdabot> [7 @more lines]
22:02:00 <SamB> that does not look like a dearth of dictionaries to me!
22:02:08 <SamB> @wordnet dearth
22:02:09 <lambdabot> Unknown command, try @list
22:02:19 <SamB> @easton dearth
22:02:21 <lambdabot> *** "Dearth" easton "Easton's 1897 Bible Dictionary"
22:02:21 <lambdabot> Dearth
22:02:21 <lambdabot>   a scarcity of provisions (1 Kings 17). There were frequent
22:02:21 <lambdabot>   dearths in Palestine. In the days of Abram there was a "famine
22:02:21 <lambdabot>   in the land" (Gen. 12:10), so also in the days of Jacob (47:4,
22:02:23 <lambdabot> [8 @more lines]
22:02:45 <SamB> @devils dearth
22:02:45 <ruffneck> funny.. I feel like formal system processing the word, like in Searles Chinese room.. the word "dearth" still doesn't say me anything else than it is translated to "lack, absence" which is "puute" in finnish but I just looked your example sentence to make my sentence about the absence (dearth) of a good dictionary
22:02:46 <lambdabot> No match for "dearth".
22:02:51 <SamB> @devils devil
22:02:53 <lambdabot> No match for "devil".
22:02:57 <SamB> what!
22:03:08 <SamB> the devil's dictionary doesn't have an entry for devil?
22:04:02 <ruffneck> I guess it's self explicit
22:04:11 <ruffneck> devil is everything that is in that dictionary
22:04:14 <ruffneck> it's the top word
22:05:30 <SamB> but it isn't the devils dictionary -- it is the devil's dictionary
22:05:43 <SamB> so, it ought to be defining "devil" as "nice person" or somesuch
22:05:56 <palomer> the devil's dictionary?
22:06:01 <palomer> isn't that a misspelling?
22:06:26 <SamB> @devil good
22:06:28 <lambdabot> *** "GOOD" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
22:06:28 <lambdabot> GOOD, adj.  Sensible, madam, to the worth of this present writer.
22:06:28 <lambdabot> Alive, sir, to the advantages of letting him alone.
22:06:28 <lambdabot>  
22:52:13 <Azmo> @hoogle unless
22:52:13 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
22:52:13 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
22:52:13 <lambdabot> System.Win32.Types.failUnlessSuccess :: String -> IO ErrCode -> IO ()
23:20:35 <pesco> @seen CosmicRay
23:20:35 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 8 hours, 11 minutes and 51 seconds ago, and .
