00:00:29 <JohnMeacham> RyanT5000, no because it knows what machine it is running on.
00:00:38 <RyanT5000> laptops
00:00:54 <Korollary> I'd go straight for a DSL instead of a gui.
00:00:57 <RyanT5000> i'm not saying there aren't any hints it can pick up on
00:01:04 <RyanT5000> there are tons
00:01:17 <bringert_> RyanT5000: IP should be a very useful one
00:01:17 <RyanT5000> however, there are certainly some things it'd need to be informed of manually
00:01:31 <JohnMeacham> Well, I wrote a little query language so you can have arbitrarily complicated zones. for instance, your IP address can be used to figure out if you are at work probably.
00:01:37 <JohnMeacham> or at least that you arn't at home.
00:01:47 <RyanT5000> that's cool
00:01:59 <RyanT5000> but i think on a fudamental level you can't automate all of that
00:02:05 <RyanT5000> (but the more you do, the better, obviously)
00:02:26 <Korollary> I'd be happy with a simple predicate to describe my typical work hours.
00:02:33 <JohnMeacham> I'll try to darcs up what I have. It uses my Boolean module, so I just wrote the primitive queries, and got a whole boolean algebra over it for free. literally a single line of code. Haskell is sweet. it is the same module I use for filters in ginsu.
00:03:04 <JohnMeacham> heh, a 'lateforwork' context is entirely possible. :)
00:03:15 <JohnMeacham> work_hours && at_home
00:05:41 <JohnMeacham> oh, another feature is infinite history, undo and editing after the fact. So you don't have to leave things around on the off chance you might need to revive them.
00:09:17 <RyanT5000> hm, is there any way to define a type "everything that GC works completely on"?
00:09:53 <RyanT5000> like, not Ptr
00:10:09 <bringert_> JohnMeacham: how is the data stored?
00:10:14 <RyanT5000> i guess that's not even a reasonable thing to ask for
00:10:45 <bringert_> RyanT5000: you can create a type class, and add instances for everything except Ptr :-)
00:11:01 <RyanT5000> bringert: that's exactly what i'm about to do :P
00:12:01 <RyanT5000> actually, not, because i'm writing a cache manager... stuff that is already fully governed by GC is kind off pointless to use a cache manager for
00:12:26 <RyanT5000> although presumably someone could have a function that generates a huge datastructure, and want to cache the results of that function if it gets executed more than once
00:12:50 <dons> ?yow
00:12:51 <lambdabot> Boys, you have ALL been selected to LEAVE th' PLANET in 15 minutes!!
00:13:37 <RyanT5000> oh wait, hah!
00:13:41 <RyanT5000> i don't even need that class
00:13:53 <RyanT5000> i can just pretend it's everything, and depend on the loader to specify
00:14:06 <RyanT5000> god i love this language
00:15:09 <dons> its been a fun couple of months then RyanT5000, learnin Haskell? you've been here most days hacking away, iirc.
00:17:16 <RyanT5000> yeah
00:17:19 <RyanT5000> since april
00:17:32 <RyanT5000> with the exception of a few weeks, i've been hacking continuously
00:17:52 <RyanT5000> and i've gotten further than in half a year of writing C++ and C# on my game
00:18:19 <dons> hehe. cool
00:18:22 <RyanT5000> it's seriously amazing: i estimate my productivity is about 20x rewriting the game in haskell
00:18:31 <RyanT5000> even if you assume some of that is just because it's a rewrite
00:18:33 <dons> hopefully it lets you think at a higher level, not getting bogged down in ptr hacking
00:18:41 <RyanT5000> oh, it does
00:18:41 <dons> or chasing mysterious segfaults for days
00:18:52 <RyanT5000> nah, i've never segfaulted in my own code yet
00:18:56 <RyanT5000> only SDL and OpenGL
00:18:59 <dons> ah, right.
00:19:27 <RyanT5000> the SDL one was because i was linking with msvcrt as well as the msys libs
00:19:46 <RyanT5000> the OpenGL was because i didn't wait for my render thread to stop before killing the whole program
00:19:54 <RyanT5000> other than that, i've hardly even had bugs
00:19:59 <RyanT5000> much less segfaults
00:20:00 <dons> aren't linkers great -- violating any safety your language has.
00:20:05 <RyanT5000> lol yeah
00:20:30 <RyanT5000> well, unless you use C++ linking... in which case you just violate compatibility
00:21:36 <Saulzar> RyanT5000, So you solved the mysterious SDL crash?
00:21:42 <RyanT5000> yep
00:22:01 <RyanT5000> msvcrt's heap manager is quite violently incompatible with mingw's
00:22:13 <RyanT5000> which is something i should have suspected
00:22:20 <RyanT5000> i just didn't know my SDL was linked under mingw
00:22:32 <RyanT5000> now i just link everything under mingw
00:22:58 <RyanT5000> lol i'm using Visual Studio for editing... but only as a tabbed/multipaned text editor with syntax hilighting
00:23:30 <RyanT5000> i'm only using the project system to remember my open windows when i exit (i just have an empty project, lol)
00:24:44 <Saulzar> Hehe. Is the visual haskell stuff usable? (Are you using that?)
00:25:06 <RyanT5000> the syntax hilighting is :P
00:25:17 <RyanT5000> the project system breaks whenever you load a project (rather than create it from scratch)
00:25:26 <RyanT5000> hence my use of the null project system, lol
00:25:34 <RyanT5000> however, visual studio is a very nice editor
00:25:59 <RyanT5000> VS is like the one microsoft product that's actually good
00:26:18 <Itkovian> RyanT5000: Not true, Excel is good as well
00:26:19 <RyanT5000> i guess office isn't terrible
00:26:21 <RyanT5000> yeah
00:26:28 <Itkovian> the rest of offcie sucks
00:26:36 <Itkovian> well, word used to be bearable
00:26:49 <Itkovian> powerpoint is bad, and access is absymal
00:27:00 <RyanT5000> yeah... we don't like to talk about access....
00:27:26 <RyanT5000> although i think now it might be just a crap gui on top of their "real" SQL database engine
00:27:40 <RyanT5000> which means, presumably, you can get access to the database engine directly using VB or whatever
00:27:46 <kep> RyanT5000 did you use Jedit ? :) 
00:27:52 <Saulzar> I guess I'm going to be using visual studio, just got a job doing C++. 
00:27:53 <RyanT5000> Jedit? no
00:29:34 <kep> RyanT5000: http://jedit.sourceforge.net/ small(for java world) and good :) 
00:29:36 <lambdabot> Title: "jEdit - Programmer's Text Editor"
00:29:59 <RyanT5000> ew, but it's written in java
00:30:05 <RyanT5000> which means it will be slow and clunky on windows
00:30:06 <RyanT5000> lol
00:30:34 <RyanT5000> i guess maybe not, but that's been my experience with everything else
00:30:39 <RyanT5000> especially Eclipse
00:30:39 * Saulzar uses KDE's kate editor
00:31:50 <kep> RyanT5000 I use Eclipse IDE for java development and RCP application development, but as i see Jedit more quick than Eclipse IDE :)
00:32:14 <Saulzar> We had to use Together for some Java projects at Uni. That took about 10 minutes to compile "Hello World" on the machines there
00:32:14 <RyanT5000> hm
00:32:29 <RyanT5000> lol
00:32:59 <Saulzar> Mainly because of the 10mbit network connections, for some reason it took _forever_ to do anything
00:33:10 <kep> Saulzar no Together , no netbeans :) eclipse (free) and intellij idea (400$) :)
00:33:36 * Saulzar hasn't used Java since
00:35:03 <kep> Saulzar :) I have  7 jears experience with java :))
00:35:21 <Saulzar> The lecturer never knew, in some class he had to use it for something. He was amazed, "So that's why everyone complains Togther is so damned slow"
00:37:26 <RyanT5000> i love existentials so much
00:37:57 <RyanT5000> well, and that other thing
00:38:05 <RyanT5000> when you put the forall inside the constructor
00:38:11 <RyanT5000> (i know what it does, just not what it's called :P)
00:38:40 <Saulzar> existentials? :)
00:38:57 <RyanT5000> i feel like an Ork right now: i don't really know what i'm doing, but somehow i manage to bang on it in the right way so that it works
00:43:43 <Saulzar> Ork a => a -> a -> Bool... 
00:43:57 <RyanT5000> lol
01:13:30 <lisppaste2> aleator pasted "Hideous hooke-jeeves" at http://paste.lisp.org/display/21827
01:13:35 <aleator> Gah. I just wrote worst piece of code in months and can't see how to make it cleaner. Anyone care to lend a pair of eyes?
01:18:37 * dons looks, but is scared
01:19:00 * ValarQ waves at dons 
01:19:07 <dons> hey ValarQ 
01:19:27 <ValarQ> hiya
01:20:10 <ValarQ> dons: i'm having some problems with lambdabot again
01:20:15 <dons> oh yeah?
01:20:15 <nealar> is there shorter notation for "\x-> \y-> \z-> "?
01:20:16 <dons> how so
01:20:28 <ValarQ> dons: the run command doesn't work for some reason
01:20:28 <Stinger_> \x y z -> ?
01:20:28 <dons> \x y z - > 
01:20:47 <nealar> > (\x y -> x+y) 1 2
01:20:49 <lambdabot>  3
01:20:51 <nealar> thanks
01:20:59 <ValarQ> dons: i just keep getting: fd:6: hClose: resource vanished (Broken pipe)
01:21:17 <dons> you could at least use a guard in hookeJeeves, instead of the if, ale	?
01:21:26 <dons> aleator.
01:21:27 <dons> slow tab... 
01:21:51 <dons> ValarQ: hmm. haven't seen that in ages. you got lambdabot 4.0 ?
01:22:08 <Itkovian> aleator: Perhaps switch over the plus from infix to prefix notation, as the rest seems to be prefix notation
01:22:08 <ValarQ> dons: the latest darcs version
01:22:48 <Itkovian> aleator: use let ... in for the basic definitions, such as steps, and where for the local functions?
01:22:50 <ValarQ> dons: + the latest hs-plugins and fps libraries
01:23:34 <dons> i can only assume that your having trouble getting onto the server for some reason?
01:23:35 <ValarQ> s/latest/latest darcs versions/
01:23:43 <aleator> dons: How? isn't guard is bool -> a ()?
01:23:46 <ValarQ> dons: no, that works
01:23:53 <aleator> Itkovian: Thanks.
01:24:18 <ValarQ> dons: i only get that error when trying to evaluate a line of haskell code with @run
01:24:34 <dons> oh, then probably runplugs  is failing
01:24:39 <dons> check that it wrorks on the cmd line
01:25:14 <dons> $ ./runplugs 
01:25:14 <dons> 1+2
01:25:14 <dons> 3
01:25:17 <dons> should work.
01:25:27 <Itkovian> aleator: drop the fun $ init `plus` pat and the fun (init `plus` pat) together  in a where and use guards
01:26:07 <ValarQ> dons: i don't have 'runplugs'
01:26:14 <dons> ah. there you go
01:26:19 <dons> no wonder the pipe fails
01:26:29 <dons> try rebuilding and _installing_ ?
01:26:48 <dons> you using the cabal build script?
01:26:56 <ValarQ> yeah
01:27:04 <dons> then the last thing built should be runplugs
01:27:14 <dons> check lambdabot.cabal
01:27:52 <ValarQ> oh wait, it just got installed in prefix/bin
01:28:08 <dons> ah right
01:28:08 <Itkovian> aleator: it ouwld also help to grok the code faster for anybody but the writer if you'd jot down the types of the functions as well
01:28:12 <dons> --bindir=`pwd`
01:29:01 <ValarQ> "mismatched interface file versions", sounds like i have to do some rebuilding
01:32:05 <Itkovian> aleator: also, in the 'else' clause of the first if-statement, you jot down a list with two items, and take their minimum by the first item of the tuple. I'm certain you can do that more elegantly, by calculating first bestP and plu bestP bestPat and comparing, perhaps even in a guard
01:35:33 <RyanT5000> @where paste
01:35:33 <lambdabot> http://paste.lisp.org/new/haskell
01:36:31 <lisppaste2> aleator annotated #21827 with "Second iteration" at http://paste.lisp.org/display/21827#1
01:36:46 <aleator> Itkovian: Ok. Got rid of the ifs. Still rather ugly, but no longer vile..
01:37:02 <RyanT5000> dons, think you could take a look at this?
01:37:03 <RyanT5000> http://rafb.net/paste/results/Jngg3U21.html
01:37:30 <RyanT5000> it's saying "Inferred type is less polymorphic than expected", but the polymorphic type i'm expecting is identical to what it says i have, except it has more restrictions
01:42:50 <RyanT5000> hm, maybe trying to make a polymorphic MVar is poorly conceived to begin with
01:43:28 <RyanT5000> but it won't let me move the forall... inside the MVar type
01:43:37 <lisppaste2> Itkovian annotated #21827 with "Clearing a bit" at http://paste.lisp.org/display/21827#2
01:43:52 <Itkovian> I hope I didn't forget anything
01:53:40 <RyanT5000> nvm i found the problem, i think
01:59:34 <RyanT5000> there should be a way to directly make a Map TypeRep a
01:59:46 <RyanT5000> except without using Typeable
01:59:53 <RyanT5000> anyway, it's 5 am here, so i'm off
02:28:35 <satan> the difference between mapM and mapM_ is that mapM_ ignores the returned value, right?
02:29:21 <basti_> yes, and that it helps saving memory that way
02:30:03 <basti_> which might make a huge difference... imagining mapM'ing putStr over an ever-growing list read from a file
02:30:26 <satan> ah ok cool
02:51:20 <IainFraser> hi everybody
02:54:02 <IainFraser> hi guys im having real trouble with type classes
02:54:14 <IainFraser> I basically want a type (String,Integer) tuple
02:54:25 <IainFraser> and I want to sort it so I need to overload it using Ord
02:54:30 <IainFraser> but I can't get it to complile
02:54:43 <IainFraser> I just want the string to be used in comparison, as integer is a index
02:56:44 <Stinger_> well seems I can already do < on two (string,int) tuples
02:57:12 <int-e> @type Data.List.sortBy
02:57:13 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:58:21 <int-e> > sortBy (\(_, a) (_, b) -> compare a b) [("alpha", 1), ("beta", 0)]
02:58:22 <lambdabot>  [("beta",0),("alpha",1)]
03:02:33 <norpan> IainFraser: either use sortBy or you need to make a new data type
03:03:07 <Igloo> Or if all your Integers are unique and you don't mind having (Int, String) tuples instead then you could just use the standard instances
03:03:34 <norpan> Igloo: huh?
03:03:48 <norpan> that would sort on integer, he wanted to sort on the string
03:04:16 <Igloo> Oh, misread. Right, so if all your /strings/ are unique then you can just use the standard instances  :-)
03:05:00 <norpan> and if they aren't and you don't care about stable sorting then you can still use the standard instances :)
03:05:39 <Igloo> Yeah; avoiding sorting on the other part of the tuple was more important when I thought it was an arbitrarily long string  :-)
03:05:40 <IainFraser> sorry just went for a gag
03:05:42 <IainFraser> fag
03:05:52 <IainFraser> basically I only want to sort by the string
03:05:56 <Stinger_> sortby doesnt do a stable sort?
03:06:03 <norpan> sortby does
03:06:03 <int-e> Stinger_: it does
03:06:22 <IainFraser> the intger should be ignored its used to later to connect to its orginal position in bigger set
03:06:38 <int-e> but does it matter? does it have to be ignored?
03:07:05 <IainFraser> oh right ill try the sortby that int-e told me
03:07:05 <Stinger_> oh I getcha with the unstable
03:07:18 <shapr> Yargh!
03:07:19 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
03:07:32 <int-e> IainFraser: beware that I compared the second element of the pair, not the first. You need to change that.
03:07:42 <shapr> I can't believe it's not butter!
03:07:43 <IainFraser> ok
03:08:01 <xerox> A shapr!
03:08:04 <norpan> i can't believe i'm not bitter!
03:08:06 <int-e> @yarr
03:08:06 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
03:08:14 <shapr> @arr
03:08:14 <lambdabot> Drink up, me 'earties
03:08:18 <shapr> @quote
03:08:18 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsible for hastening the adoption of functional programming languages
03:08:24 <int-e> @botsnack
03:08:24 <lambdabot> :)
03:08:31 <norpan> @smile
03:08:31 <lambdabot> Unknown command, try @list
03:08:42 <norpan> you *need* a @smile command
03:08:54 <shapr> norpan: I command you to smile!
03:08:57 <norpan> :)
03:09:00 <shapr> Smile the unbelievers!
03:09:02 <shapr> hmm
03:09:04 <Stinger_> yeah people were saying that all the functional programmers were happy that java was bringing people away from c++ I don't get that
03:09:08 <shapr> Doesn't sound quite right.
03:09:11 <int-e> :(
03:09:45 <IainFraser> I hate java, C++ is far superiror
03:09:48 <shapr> Stinger_: Java gets rid of malloc & free. That's the first step to automating trivial programming details. Haskell is more like a stairway...
03:09:49 <IainFraser> not starting flame
03:10:09 <norpan> i hate c++ programmers the code of which i have to fix
03:10:17 <xerox> whom?
03:10:23 <IainFraser> is says sortBy not in scope
03:10:23 <wolverian> shapr, elevator?
03:10:23 <int-e> Well, C++ has templates. Templates provide you with a compile time functional programming language. That's powerful even though it's awkward to use. Java did away with that.
03:10:25 <IainFraser> how do I import it
03:10:26 * shapr sings stairway to heaven
03:10:37 <xerox> ?index sortBy
03:10:38 <lambdabot> Data.List
03:10:42 <xerox> Import that module.
03:10:51 <IainFraser> the good thing about C++, is if something goes wrong its always your fault
03:10:58 <IainFraser> I like that
03:11:05 <shapr> That's true with Haskell too.
03:11:07 <Stinger_> shapr but I mean thats not a lot really, it hardly seems closer to lisp than c++
03:11:08 <norpan> java has generics
03:11:28 <shapr> Stinger_: True, but from inside the C++ viewpoint, Java is a huge change.
03:11:32 <IainFraser> sorry xerox im a complete noob, I tried to use hoogle but it could not help
03:11:39 <IainFraser> what does ?index sortBy mean
03:11:45 <norpan> our main product is an unhealthy combination of java,c++,c, and haskell
03:11:49 * shapr laughs
03:11:50 <nealar> IainFraser: tht's not always true with C
03:11:55 <shapr> That's so very quotable.
03:11:56 <nealar> that's true with asm
03:12:02 <int-e> IainFraser: index is a bot command ? is a valid command prefix, like @
03:12:10 <Stinger_> the main differences are enforced OO and gc :P
03:12:12 <int-e> \index error
03:12:15 <IainFraser> how do you mean nealar
03:12:32 <shapr> nealar: My arrows article has been in progress for more than a year now, no clue when I'll finish it.
03:12:39 <nealar> have you read "overloading: a syntax heroine"?
03:12:43 <norpan> oh, and tcl
03:12:49 <xerox> IainFraser: check lambdabot's answer to that command.
03:12:52 <norpan> implemented in java via jacl
03:12:56 <IainFraser> ?index sortBy
03:12:56 <lambdabot> Data.List
03:13:05 <Janni> Hello.
03:13:12 <xerox> That's the module which exports that function.
03:13:13 <shapr> Oh hey, the next two days I'll be in the car driving to Stockholm, any good research papers you can suggest?
03:13:15 <IainFraser> int-e im also new to mIRC
03:13:17 <xerox> ?docs Data.List
03:13:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
03:13:18 <xerox> This is the 
03:13:19 <shapr> hiya Janni, how's soccar?
03:13:22 <norpan> last month i got a request: "couldn't you fix so that i can use tk from the tcl command line, shouldn't be hard"
03:13:25 <xerox> documentation's link
03:13:27 <shapr> Janni: um, soccer
03:13:32 <shapr> Janni: Do you still play lots?
03:13:34 <IainFraser> cheers
03:13:44 <Janni> shapr: Hi. Now, I don't unfortunately.
03:13:49 <Janni> s/Now/No
03:13:49 <shapr> norpan: you must be joking...
03:14:02 <shapr> Janni: You switched to unicycling?
03:14:04 <Janni> But I'm watching a lot.
03:14:08 <norpan> shapr: not joking
03:14:15 <int-e> tcl is the quoting nightmare from hell :/
03:14:20 <Janni> I mean, I think you heard of that world cup in germany...
03:14:20 <norpan> indeed
03:14:26 <shapr> norpan: That's another totally quotable bit.
03:14:30 <norpan> tcl is used for scripting
03:14:43 <norpan> using tcl for scripting is "standard" in eda
03:14:44 <shapr> Janni: Look, me and my new unicycle tire! http://www.scannedinavian.com/hope/image/7
03:14:46 <xerox> ?fptools Data.List -- IainFraser this is the source
03:14:47 <lambdabot> Data.List -- IainFraser this is the source not available
03:14:51 <xerox> heh.
03:14:56 <shapr> haha
03:15:42 <Janni> shapr: Nice :-)
03:15:55 <Janni> shapr: Looks like it's for wrecking cars or something
03:16:00 <IainFraser> ok cheers
03:16:16 <shapr> Janni: hah, it's for snow, mud, gravel, sand, etc
03:17:05 <Janni> Hmm. I think climbing Mount Everest on a unicycle has yet to be done..
03:17:12 <shapr> Does anyone here have Google talk? I want to try the voice chat!
03:17:13 <Janni> s/has/is
03:17:37 <Janni> I have a problem building GHC darcs version: "HsBaseConfig.h: No such file or directory"
03:17:51 <Janni> Anybody has got an idea, why this file is missing?
03:18:05 <xerox> I don't have a voice-chat-capable client :|
03:19:58 <Stinger_> any one know of some good examples of using state monads for mutable data structures
03:20:48 <shapr> I think the oldwiki has examples.
03:21:07 <IainFraser> how is sortBy implemented in haskell
03:21:09 <IainFraser> is it quick?
03:21:29 <ndm> IainFraser: have you used it and found it too slow?
03:21:37 <ndm> if not, then its quick enough for your purpose
03:21:55 <ndm> to answer the question though, its quick enough, and in Hugs if you do :f sortBy it will jump you to the code
03:22:13 <IainFraser> fair enough
03:22:27 <IainFraser> im working on a database and ive only got small examples at the moment
03:22:34 <ndm> I would be reasonably certain is merge sort
03:22:34 <IainFraser> if its get bigger ill test it
03:23:00 <IainFraser> does ghc have a way of doing that as well?
03:23:05 <IainFraser> thanks for all the help again guys
03:23:33 <ndm> mergeSort is O(n log n), GHC is probablly reasonable at generating code for it
03:25:13 <IainFraser> I meant seeing the source of the module
03:25:58 <ndm> oh, no
03:26:03 <ndm> its a Hugs only feature
03:26:22 <Stinger_> how does it show it?
03:26:37 <Stinger_> just a dump to console?
03:26:41 <ndm> Stinger_: it opens it in your text editor at the appropriate line
03:26:45 <IainFraser> hugs is made in Nottingham Uni isn't it
03:26:46 <int-e> ghci usually doesn't know the source code anyway, because modules can be compiled.
03:26:47 <norpan> ghc does bottom-up merge sort i think
03:26:59 <ndm> IainFraser: no, I believe its in london that Ross is
03:27:03 <ndm> and he's the maintainer
03:27:08 <ndm> WinHugs is made in York
03:27:30 <IainFraser> oh right I thought I read it was made at Yale & Nottingham
03:27:35 <int-e> norpan: indeed. it's very inspiring.
03:27:42 <IainFraser> oh well would have been cool, as I am nottingham cs dept
03:27:47 <ndm> oh, perhaps it _was_ made in nottingham, but no longer
03:27:55 <IainFraser> ahh
03:28:07 <ndm> in the same way that GHC was made in glasgow, now made in Cambridge
03:28:09 <norpan> int-e: inspiring?
03:29:18 <IainFraser> why did it change
03:29:32 <IainFraser> gotta annoy the kids at cambridge that its still called ghc
03:29:34 <int-e> norpan: well, for me it was; it's where I first saw that bottom-up approach in full glory, in Haskell. It's unnatural in non-lazy contexts.
03:30:00 <norpan> oh
03:36:07 <IainFraser> im thinking about speed issues
03:36:19 <IainFraser> does anyone know how lists are stored in haskell
03:36:32 <IainFraser> does the !! operator truly random access, or is it some form of iterator
03:36:49 <int-e> they're linked lists. merge sort is efficient for linked lists. !! is bad though.
03:37:11 <IainFraser> linked lists
03:37:18 <IainFraser> umm
03:38:21 <norpan> linked lists is *not* optimal for random access
03:38:27 <norpan> *are
03:39:25 <IainFraser> yeah
03:39:51 <shapr> Finger trees are nice.
03:43:10 <norpan> fortunately, haskell provides arrays and other goodie data structures
03:46:32 <ndm> IainFraser: the people at Glasgow moved, the kids at cambridge are the same people
03:46:44 <psykotic> int-e: there is nothing unnatural about a bottom-up merge sort in a non-lazy language.
03:47:10 <ndm> IainFraser: Lists are stored as: data [a] = [] | a : [a]
03:47:25 <ndm> or using different names: data List a = Nil | Cons a (List a)
03:47:37 <ndm> so exactly like all other data structures
03:48:18 <dons> hooray for recursive types
03:49:14 <ndm> dons, I was thinking more about "HaskellSuggest", I think Yhc Core might be the best option for generating it
03:49:51 <ndm> on the basis it doesn't do inline or other transforms, doesn't destroy names, keeps position information and is a reasonably direct translation
03:50:26 <dons> can we write tools to manipulate Yhc Core? is it an 'external' Core?
03:51:02 <ndm> dons, yep :)
03:51:10 <ndm> yhc -corep filename
03:51:15 <ndm> or yhc -core filename
03:51:27 <ndm> corep throws it out in an easily externally parseable form
03:51:34 <ndm> core throws it out in a human readable form
03:51:40 <dons> ok. that sounds not too bad. though depending on yhc seems a bit heavy. though better than ghc-api for sure.
03:51:59 <ndm> it would be depending on Yhc binary just to call out
03:52:07 <ndm> not ideal, of course, but not too bad
03:52:33 <ndm> and it should also get us the automatic spotting of map like patterns
03:53:48 <dons> yeah, ok. this sounds reasonable
03:54:20 <IainFraser> oh cheers ndm
03:54:31 <IainFraser> ndm do you know the perfomance differnece between haskell and C++
03:54:44 <IainFraser> because I love the way the code is soo small
03:55:02 <IainFraser> but ive noticed that it has to iterate over stuff quite a lot in my code, which could be done in iteration in C++
03:55:12 <IainFraser> thats probably my nooby coding
03:55:26 <IainFraser> does the compiler optimize it at all?
03:55:46 <dons> of course
03:56:14 <dons> C++ and Haskell/GHc are about the same, sometimes one is better, sometimes the other.
03:56:21 <IainFraser> Im just gonna ahead with haskell, if its too slow ill have to do it in C++ which will be a real shame because ive loved using haskell
03:56:29 <IainFraser> wow
03:56:50 <dons> IainFraser: check the language shootout, http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all
03:57:03 <norpan> well, it all depends on what task you are trying to solve and how well-versed in the language you are
03:57:16 <dons> its hardly likely that compiled, optimised haskell would be too slow for the majority of problems
03:57:34 <dons> and for those, you code the slow bit up in C
03:57:41 <dons> and just call that chunk from Haskell
03:58:02 <IainFraser> cool
03:58:10 <IainFraser> pity that takes line count into consideration
03:58:32 <norpan> IainFraser: it doesn't, you can choose multiplier
03:58:34 <dons> well, productivity is important too.
03:58:35 <IainFraser> well im sort of writing the database querys in haskell
03:58:57 <IainFraser> im worried about the fact it uses lists
03:59:03 <IainFraser> because im gonna have huge sets
03:59:07 <norpan> if you take code lines into consideration then haskell wins easily
03:59:24 <dons> you'd probably then want to use arrays or bytestrings, IainFraser 
03:59:46 <dons> how big is the data going to get?
04:00:06 <IainFraser> ya haskell owns when it comes to productivity
04:00:26 <dons> < 50k , lists will be fine. bigger and you'll want arrays, or maybe unboxed arrays (or bytestrings if you're dealing with String data)
04:00:42 <IainFraser> 32 MB is the database size maximum
04:00:47 <IainFraser> but it is running on pocket pc
04:00:55 <IainFraser> obivousl that won't all be loaded at once
04:01:24 <dons> ok. you'll want unboxed arrays or bytestrings perhaps. though lazy lists might still be ok depending on how you process the data
04:02:18 <IainFraser> ok intresting
04:02:30 <dons> @docs Data.Array
04:02:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
04:04:32 <IainFraser> thanks for that
04:04:58 <cjay> i wonder why the first haskell implementation in the sum-file benchmark is so much slower than the 4th  -> http://shootout.alioth.debian.org/debian/benchmark.php?test=sumcol&lang=all
04:05:02 <lambdabot> Title: "sum-file benchmark | Debian : AMD&#8482; Sempron&#8482; Computer Language Shooto ..."
04:05:32 <cjay> what makes this line so slow?  putStrLn $ show $ sum $ map read $ lines incoming
04:05:41 <dons> read is slow
04:05:46 <ndm> with ByteString we beat C on that benchmark don't we?
04:05:54 <dons> right
04:06:05 <dons> also, its doing [Char] io, which is inefficient
04:06:40 <cjay> hum
04:07:01 <dons> luckily we have fast, efficient ByteString io these days
04:07:18 <psykotic> int-e: i'm still curious to hear in what way bottom-up mergesort is "unnatural" in a non-lazy language.
04:07:19 <psykotic> :)
04:08:04 <psykotic> i think it's hard to say that about an algorithm that can be easily coded in less than a dozen lines of c code (excluding the merge function itself).
04:09:42 <IainFraser> I was wondering, if I could do this it would be perfect
04:09:58 <IainFraser> if I can alocate the memory in c, then force haskell to map to that memory
04:10:07 <int-e> psykotic: Ok, I had implementing it for arrays in mind; in that context buffer management seems to be simpler to do in a top down fashion. (of course the actual merging has to happen bottom up)
04:10:08 <dons> sure, you can do that
04:10:15 <IainFraser> really
04:10:29 <IainFraser> any links or keywords to point me in the right direction
04:10:33 <int-e> psykotic: the main reason is that in-place merging is painful.
04:10:42 <psnl> Timeout on server
04:10:42 <dons> @docs Foreign.Marshal.Alloc
04:10:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Alloc.html
04:10:55 <dons> @docs Foreign
04:10:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.html
04:10:58 <IainFraser> cheers mate
04:11:44 <psykotic> int-e: bottom up merge sort for an inplace implementation on arrays is actually simpler than the top down version in a language like c.
04:13:07 <psykotic> or at least about the same.
04:14:35 <dons> IainFraser: all the foreign stuff comes under the FFI, the foreign functoin interface.
04:14:38 <dons> ?where ffi
04:14:39 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
04:15:00 <dons> which explains much of the detail of calling between C and Haskell
04:17:26 <IainFraser> thanks alot
04:28:23 <psykotic> int-e: my point is that a top-down merge sort is just as difficult since it needs in-place merging too. when you factor out the common part--the in-place merging--the bottom-up merge sort is actually simpler than the top-down one. i tried and it's literally three lines of code excluding the in-place merge function itself.
04:29:16 <psykotic> anyway, i'll stop :)
04:33:21 <int-e> psykotic: I'd allocate an auxillary buffer of half the array size; sort the first half of the array to that, then merge. And I think managing that extra buffer is easier to do top-down.
04:33:38 <Spark> do you need the extra space?
04:34:40 <int-e> yes.
04:34:57 <int-e> without extra space available I think I'd use a randomized quicksort.
04:35:19 <slowboy> hello, everybody
04:39:38 <slowboy> I am trying to test haskellDB, but when i try to run one of the tests (dbspec.hs) I get the error ( Not in scope: data constructor `GenericConnect') . Any ideas of what the problem might be? I have a MacBook and have installed the ghc 6.5.20060608
04:39:38 <psykotic> int-e: if you are going to use extra space it's not very in-place, is it?
04:40:08 <psykotic> you might as well do an entirely non-inplace merge into the destination (i.e. merging directly into the destination from the source)
04:40:18 <int-e> psykotic: You misunderstood me. (I wasn't very clear) I allocate the extra space because merging in-place is hard.
04:40:57 <psykotic> i know but if you are going to use 1/2x the space of the source you're not buying much compared to just doing it the naive way, you're saving a factor of 2x memory for a short moment of time
04:44:46 <int-e> psykotic: it's a factor of 3/2 (the one extra array is enough).
04:45:55 <roconnor> @hoogle [Word8] -> String
04:45:56 <lambdabot> No matches, try a more general search
04:46:15 <roconnor> @hoogle Integer -> [Word8]
04:46:16 <lambdabot> No matches, try a more general search
04:46:49 <locksy> Is there a reason why a lot of code uses: [a] ++ b rather than a : b ?
04:47:12 <roconnor> presumably they complie to the same thing.
04:47:35 <roconnor> in some contexts [a]++b reads more clearly
04:48:23 <roconnor> > (show 5)++","++(show 6)
04:48:24 <lambdabot>  "5,6"
04:48:28 <roconnor> vs
04:48:34 <roconnor> > (show 5)++',':(show 6)
04:48:35 <lambdabot>  "5,6"
04:49:43 <locksy> no argument there, but I see it all over the place by itself (no other ++ nearby etc)
04:50:06 <xerox> ?type fromIntegral (1 :: Int) :: Word8
04:50:08 <lambdabot> Word8 :: Word8
04:50:51 <roconnor> locksy: I would guess it is just a reflection of what was in the author's head.
04:51:23 <kpreid> I can see writing [a] ++ b if there's no recursive building involved
04:51:55 <kpreid> e.g. "-" ++ numberString
04:52:26 <locksy> Well,  I see it in heaps of places with recursive building.
04:53:02 <locksy> (also string is a special case)
04:54:10 <locksy> Is it possible on (or more) if the haskell compilers is better able to optimize [a] ++ b after unfolding and simplifing?
04:54:56 <locksy> (or used to optimize better *grin*)
04:56:28 <locksy> I think I'll take a close look at the build, fold and map rules in ghc...
05:03:40 <gds> Is there a better (fewer parens or whatever) way of writing something like this:
05:03:43 <gds> > map ((flip ($)) 1) [(\x -> x+1),(\x ->x+2),(\x->x+3)]
05:03:44 <lambdabot>  [2,3,4]
05:03:51 <gds> ?
05:04:11 <dons> @pl map ((flip ($)) 1) [(\x -> x+1),(\x ->x+2),(\x->x+3)]
05:04:12 <lambdabot> [2, 3, 4]
05:04:16 <xerox> swing?
05:04:30 <psykotic> @type swing
05:04:32 <lambdabot> Not in scope: `swing'
05:04:38 <gds> @doc swing
05:04:39 <lambdabot> swing not available
05:04:41 <gds> :)
05:05:05 <Igloo> > map ($ 1) [(\x -> x+1),(\x ->x+2),(\x->x+3)]
05:05:07 <lambdabot>  [2,3,4]
05:05:16 <psykotic> xerox: i think i know what you mean by swing. is it also known as the point-free programmer's instrument of torture? :)
05:05:21 <gds> Igloo: Thanks :)
05:05:46 <Igloo> You can also drop all the parens around the lambda abstractions if you want
05:05:50 <xerox> > let swing f c a = (f ($ a)) c in swing map [(+1),(+2),(+3)] 1
05:05:52 <lambdabot>  [2,3,4]
05:05:57 <xerox> :)
05:06:10 <psykotic> swing = (.).(.), right?
05:06:20 <psykotic> :)
05:06:26 <xerox> ?pl \f c a -> (f ($ a)) c
05:06:26 <lambdabot> flip . (. flip id)
05:06:56 <psykotic> let swing = (.).(.) in swing map [(+1), (+2), (+3)] 1
05:06:57 <gds> Igloo: cheers - I was interested in the first map arg more than the example list this time :)
05:07:01 <psykotic> > let swing = (.).(.) in swing map [(+1), (+2), (+3)] 1
05:07:02 <lambdabot>  Couldn't match `a1 -> a2 -> a -> b' against `[a3]'
05:07:14 <xerox> ?type let swing f c a = (f ($ a)) c in swing any
05:07:15 <lambdabot> forall a. [a -> Bool] -> a -> Bool
05:07:21 <xerox> ?type let swing f c a = (f ($ a)) c in swing foldr
05:07:23 <lambdabot> forall a b. b -> a -> [a -> b -> b] -> b
05:07:32 <xerox> ?type let swing f c a = (f ($ a)) c in swing map
05:07:34 <lambdabot> forall a b. [a -> b] -> a -> [b]
05:07:51 <xerox> It's general, it's good!
05:08:43 * xerox pokes gds 
05:09:22 <locksy> ?type let swing f c a = (f ($ a)) c in swing
05:09:24 <lambdabot> forall a b t t1. (((a -> b) -> b) -> t -> t1) -> t -> a -> t1
05:09:39 <gds> xerox: Thanks - I'm still reading your thing ;)
05:10:52 * gds is happy with map ($ arg) for now - will consider the rammifications of swing more carefully at a later date :)
05:10:56 <gds> Cheers, all:)
05:11:04 <xerox> :(
05:14:57 <bolrod> :)
05:15:20 <Igloo> ~/.
05:16:17 * gds tries to understand why "swing map list arg" might be preferable (to some) to "map ($ arg) list" 
05:16:31 <gds> I suppose it's slightly point-free-er...
05:16:38 <gds> If you're defining it as a function...
05:16:58 <gds> But I'm slapping it in the middle of something where the arg's already available for other reasons....
05:19:03 <xerox> It is just that we name important abstractions, usually.
05:19:16 <xerox> ....abstractions considered important, rather.
05:19:24 <Janni> Hmm. I still have my problem building GHC. It seems like some *.h files are missing in libraries/include
05:19:29 <Saulzar> Well that's exactly what swing _is_ if you look at how xerox defined it ... swing f c a = (f ($ a)) c 
05:20:23 <gds> What's the status of swing then? - it's not accessable from ghci, and hoogle doesn't know about it....
05:20:33 <psykotic> i think cale invented it
05:20:46 <psykotic> that's the status :)
05:20:55 <gds> lol :) -- Likely to find its way into the prelude?
05:21:49 <dblhelix> @pl \f c a -> (f ($ a)) c
05:21:50 <lambdabot> flip . (. flip id)
05:23:05 <xerox> gds - You have to define it yourself.
05:23:58 <gds> Fair enough :)
05:41:11 <norpan> swing indeed
05:41:56 <metaperl_> good morning #haskell, check this new software dev system out: http://www.openlaszlo.org/demos#LZpiX
05:41:56 <metaperl_> it combines flash, AJAX and DHTML all in one. 
05:41:58 <lambdabot> Title: "Demos | OpenLaszlo"
05:42:19 <metaperl_> in an xml-based object-oriented language
05:42:24 * lorne blinks
05:42:41 <cjay> omg
05:42:50 <lorne> IRC spam?
05:42:59 <metaperl_> um...
05:43:02 <metaperl_> well...
05:43:06 <Janni> Heh :-)
05:43:09 <metaperl_> off-topic post perhaps
05:43:12 <Janni> I thought so too...
05:43:20 * metaperl_ is not a bot
05:43:22 <Janni> Or a very intelligent bot.
05:43:23 <norpan> spam spam spam wonderful spam
05:43:26 <lorne> sorry, it just seemed so quick and to the point I assumed it was automated
05:43:38 <metaperl_> hey, a lil offtopic posting is not spam
05:44:01 <metaperl_> it was --- it was cut and pasted. I've been telling everyone about htis thing. it's cool
05:44:25 <vegai> did you make it?
05:44:29 <metaperl_> vegai: no
05:44:36 <vegai> mmkay
05:45:05 <lorne> I've been boling my blood with a particular troll, I apologise for being a bit jumpy
05:45:19 <metaperl_> Here is how it relates to Haskell: #haskell is a channel for discussing Haskell.  Haskell is a programming language. OpenLaszlo is a programming language.
05:45:40 <metaperl_> from specific to general and back to specific
05:45:46 <psykotic> way to go, aristotle
05:46:04 <metaperl_> it does seem like commercial marketing hype, but this is the open source free version
05:46:12 <metaperl_> ok, I'm tired of proselytizing for one day
05:46:14 <metaperl_> laters
05:48:10 <yaxu> could someone help me out with a tutorial exercise please?
05:48:13 <yaxu> halve :: [a] -> ([a], [a]) 
05:48:13 <yaxu> halve xs = (take f xs, drop f xs)
05:48:13 <yaxu>            where f = ((length xs) / 2) - 1
05:48:28 <norpan> Hey, look what a cool thing I found: http://gcc.gnu.org
05:48:36 <yaxu> where am i going stupidly wrong?
05:48:36 <psykotic> norpan: OMG, IS IT A PROGRAMMING LANGUAGE?
05:48:47 <norpan> apparently it's some kind of programming language that is TURING COMPLETE
05:48:52 <psykotic> DUDE
05:49:02 <lorne> yaxu: a guess:, replace / with `div`
05:49:02 <madpickle> uh wait
05:49:03 <norpan> or several programming languages baked into one application
05:49:07 <madpickle> this is about haskell the PROGRAMMING language?
05:49:14 <madpickle> i thought it was for the city of Haskell, Arkansas
05:49:20 <madpickle> O.o
05:49:29 * metaperl_ leaves for work
05:49:57 <norpan> yaxu: you are using / when you should use `div`
05:50:13 <yaxu> thanks norpan
05:50:56 <norpan> and -1 will get you in trouble if the list is empty or one element long
05:51:56 <norpan> hey, lorne already said that
05:52:03 <norpan> i was to excited about finding gcc to notice
05:52:10 <xerox> halve [] = ([],[])
05:52:11 <yaxu> :)
05:52:21 <yaxu> thanks lorne too
05:52:34 <lorne> norpan, yaxu: no problem, thank you for noticing :)
05:52:42 <xerox> halve xs = (take n xs,drop n xs) where n = length xs `div` 2
05:52:45 <yaxu> my window was small, you'd scrolled off
05:53:00 * lorne scrolls off to bed
05:54:10 <yaxu> i don't think gcc will go anywhere until they change the logo
05:54:26 <sieni> where would gcc need to go?
05:54:31 <yaxu> to something more dynamic
05:54:57 <norpan> i think gcc is a temporary fad
05:55:10 <yaxu> sieni: good question
05:55:24 <psykotic> yaxu: would speed stripes do the trick? vroom, vroom!
05:56:47 <yaxu> anyway, thanks, if i'd have asked a similar question on #perl i probably wouldn't be alive now
05:57:53 <psykotic> you also wouldn't have been able to differentiate their answer from someone's cat walking over their keyboard
05:58:34 <norpan> we are overly nice because we want as many people as possible to learn and use haskell
05:58:37 <yaxu> i would, my cats tend to press the power switch
06:02:09 <roconnor> in VI how do I delete all lines matching a regular expression?
06:02:17 <yaxu> my $halve = sub { [@_[0 .. @_ / 2 - 1]], [@_[@_ / 2 .. $#_]] };
06:02:32 <yaxu> psykotic: ok, i take your point :)
06:03:02 <xerox> I'd use sed, roconnor.
06:03:11 <norpan> roconnor: g/re/d
06:03:23 <xerox> g?
06:03:31 <norpan> :g/re/d then
06:03:42 <norpan> re is the regular expression
06:03:42 <xerox> 'g' is just matching?
06:04:01 <norpan> where do you think g/re/p got its name?
06:04:42 <roconnor> norpan: thanks
06:05:09 <ndm> Can I write my own record update function?
06:05:21 <ndm> i.e. data{myfunc = test} calls myfunc?
06:06:30 <Igloo> no
06:07:04 <xerox> Gawk.
06:07:19 <xerox> norpan - yay, cool :)
06:07:36 <ndm> thank, but :(
06:07:53 <norpan> ndm, what's wrong with myfunc data test?
06:08:10 <ndm> more ambiguous in some circumstances
06:08:35 <norpan> more ambigous? how?
06:09:52 <IainFraser> how can I make a function which returns and INT, trying to make a dll
06:09:58 <IainFraser> ive come up with adder :: Int -> Int -> IO INT
06:10:04 <IainFraser> but I get lexical error
06:10:28 <ndm> consider filepaths, imagine setting the drive
06:10:30 <norpan> IainFraser: you're trying to call haskell from c?
06:10:34 <ndm> you have a filepath, and you want to set the Drive
06:10:38 <IainFraser> ya
06:10:43 <norpan> setDrive filepath drive
06:10:46 <ndm> do you give FilePath -> Drive -> FilePath
06:10:51 <ndm> norpan: yep, thats the way i'm going
06:10:57 <IainFraser> what I really want is to combine, c and haskell into 1 dll
06:10:59 <norpan> so what's the ambiguity
06:11:01 <IainFraser> doesn't seem possible though
06:11:04 <ndm> but its slightly counterintuative because the drive goes before the filepath
06:11:14 <norpan> IainFraser: you'll have to use the foreign export stuff
06:11:28 <IainFraser> ya I am
06:11:36 <IainFraser> foreign export stdcall adder :: Int -> Int -> IO Int
06:11:47 <norpan> you don't need IO if you don't do IO
06:12:07 <IainFraser> cheers
06:14:09 <norpan> then the compiler will generate a c stub that sets up stuff so that you can call it
06:14:15 <norpan> from c
06:17:41 <dons> to call haskell from C you also need to start up and quit the rts.
06:17:48 <norpan> yes
06:18:01 <dons> hs_init(&argc, &argv);
06:18:12 <dons> p = hs_some_f();
06:18:17 <dons> hs_exit();
06:18:27 <dons> with possibly lots of stuff between start and exit.
06:18:40 <norpan> potentially an infinite amount of stuff
06:19:06 <norpan> lots and lots of haskell calls
06:20:02 <dons> the more the better
06:21:08 * dons -> sleep
06:21:16 <Igloo> Nah, one is best. Just call Haskell to do all the work  :-)
06:21:25 <jberg> is there an easy way to make [[(Int, Int, Int)]] to a [Char] using chr?
06:21:51 <norpan> a list of three ints to one char?
06:22:01 <norpan> you need to be more specific i think :)
06:22:12 <jberg> to a list of chars.. just "unpack" it
06:22:31 <norpan> but how do you convert three ints to one char
06:22:32 <int-e> > map (const $ chr 12) [[(1,2,3)]]
06:22:34 <lambdabot>  "\f"
06:22:41 <norpan> int-e: very good
06:22:44 <jberg> [[(97, 97, 97), (97, 97, 97)]] -> "aaaaaa"
06:23:34 <norpan> concat . map (\(x,y,z)->[chr x,chr y,chr z]) . concat
06:23:34 <int-e> concatMap (concatMap (\(a, b, c) -> [chr a, chr b, chr c]))
06:24:29 <int-e> @pl concatMap (concatMap f)
06:24:29 <lambdabot> ((f =<<) =<<)
06:24:56 <jberg> thanks!
06:25:35 <norpan> now we can start an endless debate on which version is "best"
06:25:42 <int-e> right. concatMap f . concat seems clearer.
06:26:11 <int-e> let's pretend we already did and didn't find any agreement and skip the actual discussion :)
06:26:57 <norpan> =<< is tricky business
06:27:11 <kpreid> liftM chr $ join $ join $ (liftM $ liftM (\(a,b,c) -> [a,b,c]))
06:27:47 <norpan> join is shorter than concat
06:27:48 <norpan> good
06:28:15 <norpan> otoh liftM is longer than map
06:28:30 <kpreid> @pl (\(a,b,c) -> [a,b,c])
06:28:31 <lambdabot> (line 1, column 7):
06:28:31 <lambdabot> unexpected ","
06:28:31 <lambdabot> expecting letter or digit, operator or ")"
06:28:31 <lambdabot> ambiguous use of a non associative operator
06:28:46 <kpreid> @pl \(a,b) -> [a,b]
06:28:47 <lambdabot> uncurry ((. return) . (:))
06:28:53 <kpreid> @pl \(a,b,c) -> [a,b,c]
06:28:53 <lambdabot> (line 1, column 6):
06:28:54 <lambdabot> unexpected ","
06:28:54 <lambdabot> expecting letter or digit, operator or ")"
06:28:54 <lambdabot> ambiguous use of a non associative operator
06:29:12 <norpan> huh
06:29:25 <norpan> it doesn't allow more than 2-tuples?
06:30:22 <kpreid> @pl \f x -> f (f x)
06:30:23 <lambdabot> join (.)
06:30:52 <int-e> @pl \f g x -> f x (g x)
06:30:53 <lambdabot> ap
06:32:03 <gds> Monads always look so sad :(
06:32:10 <gds> "=<<"
06:33:10 <norpan> yesterday i wrote some code that had the :> constructor
06:33:15 <norpan> happy code
06:33:18 <gds> :)
06:34:03 <kpreid> hm
06:34:11 <yaxu> perl style regular expressions have lots of happy faces (?:   (?=
06:34:17 <kpreid> > (\f x -> f (f x)) (\x -> [x])
06:34:18 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
06:34:18 <lambdabot>    Expected...
06:34:29 <kpreid> is there a type system extension that lets that work? :)
06:34:52 <norpan> that would be an infinite type
06:34:57 <norpan> hard to realize
06:34:57 <kpreid> no
06:35:21 <xerox> ?type fix return
06:35:23 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
06:35:23 <lambdabot>    Expected type: a -> a
06:35:29 <xerox> Seems so :)
06:35:31 <kpreid> it should be of type a -> [[a]]
06:35:43 <xerox> Should it?
06:35:50 <norpan> i think you are mistaken
06:36:17 <norpan> or not
06:36:19 <kpreid> in a dynamically-typed system it would succeed
06:36:32 <kpreid> so I'm wondering if there is some sufficient cleverness to make it work in Haskell
06:36:35 <norpan> > (\f x -> f (f x)) (\x -> [x] :: a -> [a])
06:36:36 <lambdabot>  Couldn't match `a -> [a]' against `[a1]'
06:36:46 <norpan> > (\f x -> f (f x)) ((\x -> [x]) :: a -> [a])
06:36:47 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
06:36:47 <lambdabot>    Expected...
06:37:12 <norpan> > ((\f x -> f (f x)) :: a -> [[a]]) ((\x -> [x]) :: a -> [a])
06:37:13 <lambdabot>    The lambda expression `\ f x -> ...' has two argumentss,
06:37:13 <lambdabot>   but its typ...
06:37:25 <norpan> gah
06:37:35 <norpan> > ((\f x -> f (f x)) :: (a -> [a]) -> a -> [[a]]) ((\x -> [x]) :: a -> [a])
06:37:36 <lambdabot>  [[a]]
06:37:36 <lambdabot>    Inferred type: [a]
06:37:36 <lambdabot>   In the application `f (f x)'
06:37:36 <lambdabot>   In a la...
06:37:57 <norpan> well
06:38:01 <norpan> i must work now :)
06:39:23 <Igloo> @type (\(f :: forall a . a -> [a]) x -> f (f x)) (\x -> [x])
06:39:25 <lambdabot> forall a. a -> [[a]]
06:39:28 <norpan> > (\f::(a->[a x -> f (f x))(\x -> [x])
06:39:28 <lambdabot>  Parse error
06:39:41 <norpan> yes
06:40:24 <norpan> > (\f::(a->[a]) x -> f (f x))(\x -> [x])
06:40:24 <lambdabot>  Parse error
06:40:45 <norpan> bah
06:40:48 <norpan> work i said
06:42:50 <kpreid> Igloo: interesting
06:43:18 <Stinger_> what are you trying to do?
06:44:45 <kpreid> Stinger: originally, I had code like (... $ join $ join $ ...) and wanted to make it into (... $ duplicate join $ ...)
06:46:07 <xerox> I have that code. You need heavy type hackery for that, though.
06:47:53 * nealar doesn't understand why deterministic parsers of Swierstra can not be implemented as a monad
06:48:16 <xerox> nealar - Just check out Hughes arrow paper. It explains it all.
06:56:14 <roconnor> @type replicate
06:56:16 <lambdabot> forall a. Int -> a -> [a]
07:00:52 <IainFraser> trying include haskell c code in visual C++ 2005
07:00:54 <IainFraser> is impossible
07:00:58 <nealar> xerox: where?
07:01:00 <IainFraser> there are thse annoying #if defined(__GNUC__)
07:01:09 <IainFraser> sorry annoying #include_next
07:01:15 <IainFraser> im guessing that is a GNU command
07:02:33 <gds> > let f = (*2) in f $ f 2
07:02:35 <lambdabot>  8
07:02:35 <gds> > let f = (*2) in foldr ($) 2 (replicate 2 f)
07:02:36 <lambdabot>  8
07:02:58 <xerox> nealar - http://haskell.org/arrows/
07:03:00 <lambdabot> Title: "Arrows: A General Interface to Computation"
07:04:32 * gds realises that this doesn't work when f x = [x] :)
07:04:48 * gds -> back to the day job....
07:05:54 <IainFraser> how is this meant to compile really?
07:05:54 <IainFraser> long double __cdecl wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__)
07:06:05 <IainFraser> two variables with the same name
07:07:24 <ndm> is __restrict__ a name, or a restrict directive, which is C99, I think
07:07:33 <ndm> and is probably defined to nothing for Visual Studio
07:07:45 <ndm> hence no names, which is fine for a declaration
07:09:00 <IainFraser> oh right
07:09:04 <IainFraser> what should I do
07:09:14 <IainFraser> #define _restrict_ 
07:09:22 <IainFraser> but that will have to variable name?
07:20:41 <IainFraser> cheers ndm you were right
07:20:45 <IainFraser> extern _CRTIMP unsigned __cdecl int*	__p__osver(void);
07:20:57 <ndm> cool, was just a guess :)
07:21:03 <IainFraser> that seems fine to me but for some reason visual studio spits error C2062: type 'int' unexpected
07:21:05 <ndm> I guess the C visual studio route doesn't get taken much
07:21:16 <IainFraser> why not?
07:21:24 <IainFraser> I thought visual studio was the most popular compiler
07:21:35 <IainFraser> why would you use anything else?
07:21:48 <IainFraser> sorry, didn't mean to start a flame
07:21:53 <IainFraser> me just being stupid
07:22:09 <IainFraser> can you see anything wrong with that function declartion
07:22:19 <IainFraser> I can't, _CRTIMP expands to nothing
07:22:21 <IainFraser> so thats fine
07:23:29 <ndm> most Haskell people use Linux, hence GCC is the most popular, by far
07:23:47 <ndm> I am one of the few Windows Haskell users
07:24:03 <ndm> or at least, one of those who contributes code and uses Haskell and Windows
07:24:12 <ndm> I guess there are plenty of beginners/students on Windows
07:25:25 <IainFraser> fair enough
07:28:04 * Philippa_ doesn't contribute so much code most of the time...
07:28:07 <Philippa_> but I'm on windows too
07:29:54 <IainFraser> can anyone contribute
07:36:02 <IainFraser> does ghc supply a libary 
07:36:20 <IainFraser> c libary to be used when trying to interface between c and haskell
07:36:31 <IainFraser> specfically rts
07:36:43 <sm> Philippa_: I have been looking at your wiki and learning, thx!
07:37:08 <sm> I assume it's yours (flippi)
07:54:59 <apfelmus> hi there!
07:57:43 <Itkovian> hi
07:58:31 <vincenz> \o/
07:58:35 <vincenz> I have internet again
07:58:48 <apfelmus> in lack of internal docs about ReadP, i'm currently looking at http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/HaskellCgi/show-haskell.cgi?file=../koen/Parsek.hs
07:58:51 <apfelmus> and trying to understand it.
07:58:52 <lambdabot> Title: "The Multi Library"
08:01:03 <apfelmus> the "Parsek" library is the predecessor of ReadP, i assume?
08:02:57 <apfelmus> if asked to prove that it works, i could certainly do it. yet i have almost no intuitive feeling about it.
08:06:46 * apfelmus finds crashing irc clients annoying
08:06:56 <IainFraser> ive been programming in visual studio since I started programming, ive spent hours trying to figure how to place haskell functions in a dll using it but with no luck. Please could some give me a hint how I can gcc setup on my computer (xp) so I can get it to work
08:07:35 <apfelmus> IainFraser: the ghc user's guide says something about dll's
08:07:58 <IainFraser> ya ive read them mate, I got stuck because the libary is not provided ( well not in visual studio format)
08:08:00 <ndm> IainFraser: have you installed ghc?
08:08:09 <ndm> in that case gcc at the shell should just work
08:08:10 <IainFraser> yup
08:08:21 <IainFraser> ive done quite a bit all ready infact
08:08:46 <IainFraser> I managed to compile the example on the website you mentioned, but it won't link because I don't have the static libary
08:08:51 <psykotic> IainFraser: in msvc you have to annotate functions which you want to put in the dll with __declspec(dllexport)
08:09:20 <IainFraser> my problem is startupHaskell is unresolved
08:09:26 <IainFraser> because I don't have the libary
08:09:37 <IainFraser> I only have the header files
08:10:39 <IainFraser> any ideas?
08:13:13 <apfelmus> IainFraser: i don't use windows but ghc has to link in startupHaskell in his programs, too. so there should be at least a static library (libHSbase.a on darwin)
08:14:55 <IainFraser> oh .a is lib 
08:15:08 <IainFraser> ive been brought up by micrsoft lol
08:15:26 <IainFraser> doesn't matter anyway because visual studio won't link in to that lib type
08:15:42 <IainFraser> why do academics never use windows
08:15:46 <IainFraser> its a brilliant platform
08:16:29 <fanopanik> so is unix
08:16:42 <apfelmus> different people have different opinions, but maybe you can get gcc into transforming that .a into a .dll and link in that
08:16:52 <IainFraser> ya
08:17:03 <IainFraser> I think im gonna try get into unix, if everyone else is using it there must be a reason hey
08:17:13 <fanopanik> I have Haskell exam in 30 minutes :>
08:17:51 <norpan> not many people are using unix systems these days though
08:17:56 <Kasperle> fanopanik: good luck
08:18:01 <norpan> but linux is quite popular
08:18:08 * Kasperle will have a part haskell exam in two weeks :/
08:19:00 <fanopanik> I'm confident I will pass this time. Last time I didn't know the professor was gonna let us code on paper
08:19:01 <Kasperle> haskell, semantics of haskell, lambda calculus, type checking, etc. plus term rewriting and compiler construction ... time flies when you're studying with a deadline ;)
08:20:36 <ndm> Kasperle: semantics of Haskell? I didn't think that had even been finished yet
08:20:43 <apfelmus> norpan: mac os x is a unix derivate. besides that, every natural science academic i know is using some kind of unix (on work)
08:21:28 <norpan> darwin is unix-like, yes, but not unix
08:21:46 <roconnor> ugh, writing coq is like writing GHC core.
08:21:52 <fanopanik> do you consider BSD a unix?
08:22:11 <fanopanik> +to be
08:22:20 <norpan> bsd is unix
08:22:47 <vincenz> windows is unix
08:22:52 <vincenz> it's like the matrix
08:22:53 <apfelmus> norpan: huh? so what's not so unix about darwin?
08:22:58 <vincenz> everything is unix
08:23:17 <apfelmus> vincenz: mmh, historically, you have a point
08:23:24 <roconnor> OS/2 isn't unix
08:25:23 <norpan> well it doesn't matter
08:25:29 <norpan> linux is unix-like enough
08:25:59 <norpan> windows does have a posix layer but i've never seen it used
08:26:13 <norpan> or subsystem as they call it
08:27:14 <cjay> afaik it is very incomplete, windows doesn't even have fork()
08:27:46 <vincenz> cjay: it replaced it by spoon()
08:27:55 <cjay> lol
08:27:57 <Stinger_> there is no spoon()
08:28:07 <Stinger_> (had to be said)
08:28:15 <dmhouse> Stinger_: ;)
08:28:55 <vincenz> Hmm
08:29:04 <vincenz> Anyone know how to do value-dependence analysis
08:29:37 <Stinger_> ok, whats the old haskell wiki then
08:30:06 <sjanssen> http://www.haskell.org/hawiki
08:30:07 <lambdabot> Title: "FrontPage - The Haskell Wiki"
08:30:24 <Stinger_> oh, whats the new haskell wiki then
08:30:35 <sjanssen> http://www.haskell.org ;)
08:30:38 <lambdabot> Title: "Haskell - HaskellWiki"
08:30:41 <dmhouse> http://haskell.org/haskellwiki
08:30:45 <lambdabot> Title: "Haskell - HaskellWiki"
08:30:56 <xerox> ?wiki
08:30:57 <lambdabot> http://www.haskell.org/haskellwiki/
08:30:59 <xerox> ?oldwiki
08:30:59 <lambdabot> http://www.haskell.org/hawiki/
08:31:06 <Stinger_> ah, I see
08:39:58 <Stinger_> so how much do you guys write as functional versus imperitive code in Haskell?
08:40:42 <roconnor> when you want to compute something use functional
08:40:50 <roconnor> when you want to do something use imperitive
08:40:52 <roconnor> ;)
08:41:07 <Stinger_> what about when you want to do a computation ;)
08:41:34 <Stinger_> I kinda see what you mean though
08:41:55 <roconnor> coverting julian dates to gregorian dates -> functional
08:42:01 <roconnor> opening a socket -> impertive
08:42:25 <sm> so if you're in an imperative do block and you have something functional to do.. you'd reach out to the functional world with where
08:42:37 <sm> ?
08:42:54 <norpan> sm: no
08:43:00 <sm> damn! :)
08:43:05 <roconnor> I suspect many people secretly use impertive code sometimes to do some computations. especially when big arrays are involved.
08:43:08 <Stinger_> you dont have to use where do you? you just call the pure stuff, but it remains in the monad
08:43:14 <norpan> if you want something functional done you just call it
08:43:28 <norpan> and bind it with let most likely
08:43:32 <roconnor> sm: let x = f y
08:43:39 <sm> ok, or use let
08:43:42 <sm> I see
08:43:52 <norpan> where is only allowed on declaration level
08:44:07 <norpan> let is allowed everywhere an expression is allowed
08:44:19 <sm> I can use where in a do block, but it references only the top-level.. I learned this yesterday
08:44:33 <norpan> no, you can use where *outside* of a do block
08:44:34 <roconnor> nopan: well there are two lets: let in, and do let
08:44:45 <norpan> roconnor: but they are the same, just syntax
08:45:25 <vincenz> Anyone know how to do value-dependence analysis
08:45:34 <norpan> vincenz: thankfully, no
08:45:41 <vincenz> :/
08:46:19 <apfelmus> vincenz: for finding space leaks?
08:46:30 <vincenz> apfelmus: no for different purposed
08:46:32 <vincenz> s/d/s
08:46:51 <vincenz> Was just hoping to find some info, the only paper I found treats a C-like language
08:47:01 <vincenz> mine is more functional (close to miniML)
08:48:00 <apfelmus> vincenz: isn't this just the problem of checking wether there is a path between to nodes in a graph?
08:48:11 <vincenz> apfelmus: it's more a pragmatic problem
08:48:15 <vincenz> apfelmus: how to represent it in haskel
08:51:00 <apfelmus> vincenz: mmh, i would perhaps just use an explicit graph
08:51:44 <vincenz> apfelmus: the problem is that then you lose any link with the original AST
08:51:48 <dmhouse> vincenz: just recieved my version of tapl :)
08:51:56 <vincenz> dmhouse: cool
08:52:34 <vincenz> apfelmus: in addition, if you look at graphs like that, they need to be more 'structured' (for lack of better word).  Basically.... take an if-then-else... that will be a node with three subconnections
08:53:36 <vincenz> I guess I'm not quite certain twhat the data-structure should look like
08:54:11 <vincenz> first things first, a flow analysis
08:54:17 <vincenz> fortunately I use indirect composite
08:54:25 <apfelmus> vincenz: mh? what comes out the if-then-else depends on everything in there (statically at compile time)
08:54:43 <vincenz> apfelmus: yeah but I would like the intermediate links as wlel
08:55:26 <vincenz> and yeah, doing cross-function analysis is going to be annoying as hell
08:55:51 <vincenz> erm...hell as well
08:56:49 <apfelmus> vincenz: mh, the three parts of if-then-else don't really depend on each other, do they?
08:56:56 <vincenz> erm
08:57:04 <vincenz> the then and else depend on the if part
08:57:06 <vincenz> my language isn't pure
08:57:31 <vincenz> if (x <- 3; y) then x else y
08:57:35 <vincenz> if (x <- 3; y) then x else !y
08:57:37 <vincenz> erm
08:57:42 <vincenz> if (x <- 3; y) then !x elsey
08:57:47 <vincenz> for instance
08:58:05 <vincenz> (although this won't type of course, !x is int, y is bool)
09:02:46 <apfelmus> vincenz: ah. strange kind of language you have there. dependency somehow means soemthing strange. so !x (what's the ! for?) depends on the value (x <-3; y) :: m Bool. 
09:05:54 <vincenz> apfelmus: ! == read reference
09:05:54 <vincenz> (!) :: Ref a -> a
09:05:54 <vincenz> and my language is not monadic
09:05:54 <vincenz> so (x <- 3; y) :: Bool
09:05:54 <vincenz> imagine ML
09:06:23 <xerox> brr? :)
09:08:00 <apfelmus> vincenz: ah. mh. haskell purified me such i can't program impure anymore :) so i would try to use monadic semantics and extract value dependency out of that
09:08:14 * apfelmus has to take an accidential short break
09:09:07 <vincenz> apfelmus: not sure with what you mean by "try to use monadic semantics"
09:09:12 <vincenz> I don't think they mesh well
09:21:03 <apfelmus> vincenz: still tracking valuable dependencies?
09:26:37 <vincenz> yep
09:26:42 <vincenz> apfelmus: you ever write a compiler
09:26:45 <vincenz> or part of it?
09:26:49 <vincenz> how do you typically write your AST
09:27:00 <vincenz> cause you have different compiler phases that need to annotate diferent stuff
09:28:44 <apfelmus> sadly, i never did write compilers. but i think i'd take the approach you took in your pastes
09:29:08 <vincenz> which pastes?
09:29:20 <apfelmus> weeks ago
09:29:31 <vincenz> the indirect composite stuff?
09:29:38 <vincenz> I guess it's the most flexibile way
09:29:43 <vincenz> but it's seriously starting to piss me off
09:29:56 * vincenz ponders
09:30:01 * vincenz figures
09:30:14 <vincenz> time for some spring cleaning
09:32:07 <roconnor> How big can Set Word256 get before GHC blows up?
09:32:23 <dmhouse> Yay! Someone wrote some cool L=laziness stuff for the Wikibook :)
09:32:27 <dmhouse> s/L=//
09:32:40 <sm> dmhouse: got a url ?
09:32:57 <sm> that wikibook is great
09:33:08 <dmhouse> @google wikibook haskell
09:33:16 <xerox> > maxBound Word256
09:33:17 <lambdabot> http://en.wikibooks.org/wiki/Programming:Haskell
09:33:18 <lambdabot>  Not in scope: data constructor `Word256'
09:33:22 <xerox> > maxBound :: Word256
09:33:23 <lambdabot>  Not in scope: type constructor or class `Word256'
09:33:25 <xerox> > maxBound :: Foreign.Word256
09:33:26 <lambdabot>  Not in scope: type constructor or class `Foreign.Word256'
09:33:29 <xerox> Well.
09:33:43 <vincenz> dmhouse: which subsection
09:33:46 <dmhouse> sm, http://en.wikibooks.org/wiki/Haskell/Laziness_revisited
09:33:57 <roconnor> type Word256 = (Word128,Word128)
09:33:59 <dmhouse> > maxBound :: Data.Int.Word256
09:34:00 <lambdabot>  Not in scope: type constructor or class `Data.Int.Word256'
09:34:16 <apfelmus> vincenz: yes. the main reason for carrying an annotated AST around is to produce meaningful error messages, i think. having to much data in a type always sucks
09:34:39 <dmhouse> vincenz: The 'tying the knot' stuff is new on that page.
09:35:13 <sm> nice.. dmhouse do you know why that edit has a red (Talk) as the note ?
09:35:13 <dmhouse> vincenz: Feel like writing an 'advanced classes' module on MPTCs, FDs etc? :)
09:35:36 <dmhouse> sm, that user doesn't have a talk page? Red links on MediaWiki indicate nonexistant targets
09:35:42 <sm> ah
09:35:43 <roconnor> I suppose newType Word256 = Word256 !Word128 !Word128 probably
09:35:44 <apfelmus> vincenz: maybe i would try to emulate attribute grammars, but i did not yet find a nice way
09:35:50 <vincenz> apfelmus: well for me it's more for analysis
09:35:55 <vincenz> apfelmus: I don't really care about pretty errors
09:36:01 <roconnor> deriving (Eq, Ord)
09:36:07 <vincenz> dmhouse: heh, don't really have a lot of time atm
09:36:19 <dmhouse> vincenz: Okay.
09:37:28 * vincenz is off to dinner
09:48:51 <apfelmus> what is the space behaviour of     let fibs = 1:1:zipWith (+) fibs in fibs !! 10    ?
09:49:32 <apfelmus> i wonder wether the first fibs are garbage collectet or not
09:51:50 <dmhouse> ndm: Just checking out FilePath. Glad someone finally got down to standardising this :)
09:52:04 <ndm> dmhouse: any comments most welcome, yes - it was well needed!
09:52:17 <dmhouse> ndm, I'm going to submit a patch with some additions/fixups to the Haddock docs, I think.
09:53:43 <ndm> dmhouse: just the docs?
09:53:52 <dmhouse> ndm, for now ;)
09:53:55 <ndm> that would be very welcome :)
09:54:23 <ndm> if you have any semantics fixups, check with me first on IRC - there are loads of special cases in FilePaths unfortunately
09:54:28 <ndm> but the docs definately need work
09:55:00 <dmhouse> Sure.
09:55:29 <palomer> @palomer
09:55:29 <lambdabot> Hrmph
09:56:53 <ndm> dmhouse: and please gzip all patches before you send them, or darcs vs Windows tends to get in the way :)
09:57:04 <dmhouse> Hehe, okay.
09:58:49 <dmhouse> ndm, I just threw together a bash script that does the same thing as make-docs.bat as well. (Aside from the 'deploy' stuff.)
09:59:06 <ndm> cool :), send it over with the patch
09:59:26 <palomer> I <3 blur
09:59:55 <palomer> bash should get replaced by ruby or python
10:00:13 <dmhouse> palomer: It's just a list of commands, no logic or anything.
10:00:23 <dmhouse> I can't stomach bash control structures.
10:01:05 <ndm> generating haddock documentation really should be a Cabal thing
10:01:13 <ndm> (and quite possibly even is)
10:03:54 <apfelmus> int-e: ping
10:04:21 <int-e> you rang?
10:05:36 <int-e> apfelmus: pong
10:05:51 <apfelmus> int-e: yes. i'm wondering about the space behaviour of let fibs = 1:1:zipWith (+) fibs in fibs !! 10 and thought you could come to rescue
10:06:58 <int-e> apfelmus: in theory the fibs could be lifted to the top level; I think ghc doesn't do that though.
10:07:18 <int-e> apfelmus: so it would be garbage collected.
10:07:31 <int-e> but you can't really rely on all implementations to do that
10:07:45 <apfelmus> int-e: lifting to top level would be a laziness bug
10:07:58 <int-e> why? it's perfectly lazy ;)
10:08:47 <int-e> (what I mean is lifting the fibs declaration - the fibs !! 10 would stay where it is.
10:08:49 <int-e> )
10:08:55 <int-e> hmm.
10:10:10 <apfelmus> int-e: the fibs will surely become garbage after everything is done.
10:10:10 <apfelmus> but i mean during evaluation of the !! 10 assuming a perfect "immediate" gc
10:10:36 <int-e> if you really have  (let fibs = ... in fibs !! 10) that will eventually be reduced to 89 and the fibs be garbage. yes.
10:11:14 <int-e> what I had in mind was more akin to   f x = let fibs = ... in fibs !! x
10:12:32 <apfelmus> int-e: the fibs will gc
10:12:54 <apfelmus> but in  f = let fibs = ... in \x -> fibs !! x they won't
10:13:34 <int-e> well the two are equivalent, semantically. GC isn't part of the haskell report.
10:14:57 <apfelmus> int-e: not really. lifting would be a laziness bug, as in the f x = ... case, fibs is not memoized. i mean f 1 and f 2 use different fibs
10:15:06 <apfelmus> then
10:16:01 <apfelmus> int-e: anyway, i was pondering about something slightely different.
10:16:29 <apfelmus> assume you have an immediate gc, that is everything garbage gets kicked out instantly
10:17:35 <apfelmus> so (repeat 1) !! 10 would take constant space (read Cons, trash, read next and so on) 
10:17:51 <apfelmus> s/trash/trash it
10:17:55 <int-e> actually repeat 1 is a bad example
10:18:01 <int-e> because that ties a knot
10:18:12 <int-e> but I know what you mean
10:18:27 <apfelmus> int-e: ah, ok.
10:18:37 <apfelmus> but what about the fibs case now?
10:18:50 <dmhouse> ndm: What's the purpose of isPathSeperator?
10:18:57 <int-e> it'd take constant space if the fibs aren't getting shared somehow.
10:19:03 <apfelmus> the Cons are surely trashed, but the numbers themselves might remain
10:19:12 <Lemmih> ndm: Great work!
10:19:15 <apfelmus> so it could take linear space!
10:19:25 <int-e> it could do that, too.
10:19:33 <Lemmih> ndm: Maybe the directory operations should go in System.Directory.
10:19:37 <ndm> dmhouse: isPathSeparator '\\' == True, isPathSeparator '/' == True - on Windows
10:19:45 <ndm> dmhouse: and on Linux, only the second one
10:19:53 <dmhouse> ndm, Ah.
10:20:04 <ndm> Lemmih: yes, and the Temporary file ones as well probably
10:20:08 <dmhouse> ndm, is the type of pathSeperator incorrect?
10:20:18 <dmhouse> ndm, it's listed as Char.
10:20:21 <apfelmus> int-e: so what is it doing now? if it takes linear space, than i suspect that no haskell programm can eliminate space leaks without strictness
10:20:21 <ndm> dmhouse: yes
10:20:31 * dmhouse adds it to the patch
10:20:42 <ndm> dmhouse: it returns the best sparator char, i.e. '/' on Linux, '\\' on Windows
10:20:54 <dmhouse> Oh, I see.
10:20:56 <ndm> so x == pathSeparator /= isPathSeparator x
10:21:04 <Lemmih> @seen JaffaCake
10:21:05 <lambdabot> I saw JaffaCake leaving #haskell 1 day, 7 hours, 27 minutes and 9 seconds ago, and .
10:21:10 <ndm> although ideally users won't use that, they'll use the higher level ones defined in terms of it
10:21:57 <dmhouse> ndm, so pathSeperator is the ideal one. Is there a list anywhere of all the possible ones?
10:22:09 <ndm> dmhouse: no, I guess that can be added
10:22:13 <ndm> pathSeparators
10:22:16 <dmhouse> Sure.
10:22:28 <ndm> If you want to tack that in with your patch, i'll happily accept
10:23:05 <dmhouse> I will.
10:24:01 <int-e> apfelmus: I think that's right. haskell is underspecified in that regard. In practice compiler writers have to be careful; in particular lifting inner bindings to the toplevel is something to be avoided.
10:27:54 <dmhouse> ndm: I think isFileSeperator and isExtSeperator are a bit pointless.
10:28:05 <dmhouse> Perhaps I should add those comments to a reply to your email.
10:28:07 <ndm> dmhouse: isFileSeparator is different Linux/Windows
10:28:09 <apfelmus> int-e: yes, liftings are dangerous. but i mean the fibs example a bit different
10:28:10 <apfelmus> let's assume (and i think it will happen) that the fibs list remains local and gets whacked out as soon as we have the 10nth one
10:28:19 <dmhouse> ndm, but why not just (== fileSeperator)?
10:28:35 <ndm> dmhouse: I have them for symetry, and its possible that some OS will have two different file separators
10:28:44 <ndm> extensions i'm not so concerned about
10:29:20 <ndm> I don't know of any off hand, but I wouldn't be massively suprised if Windows allows another character for file separators, its just hardly ever used
10:29:56 <dmhouse> Then fileSeperator and extSeperators should be [Char].
10:30:05 <eivuokko> ndm, Windows allows \ and /
10:30:20 <dmhouse> ndm, this is for seperating files in $PATH.
10:30:20 <ndm> dmhouse: they return the best, in the same way as pathSeparator is Char
10:30:27 <dmhouse> ndm, ah, true.
10:30:37 <dmhouse> ndm, okay, I'm with you.
10:30:41 <ndm> eivuokko: as dmhouse said, its for between $PATH - pathSeparator is for \ /
10:30:48 <eivuokko> Ah, sorry
10:30:55 <dmhouse> eivuokko: Yes, sorry, that 'ndm, this...' was meant to be directed at you.
10:31:01 <eivuokko> Yeah, convention is to use ; in Windows.  There's no guidelines I know of
10:31:24 <ndm> eivuokko: there are guidelines, FindExecutable doesn't work unless you use ;
10:31:32 <apfelmus> int-e: further we have our immediate gc. imagine the graph reduction now. 
10:31:45 <apfelmus> int-e: (!!) is making it's way through the graph
10:32:03 <int-e> apfelmus: maybe http://www.haskell.org/haskellwiki/GHC:FAQ#Optimization_issues is of interest to you?
10:32:04 <lambdabot> Title: "GHC/FAQ - HaskellWiki"
10:32:13 <eivuokko> ndm, yes, for some known env variables in some uses.  I think some registry expansion also uses ; but I might remember wrong.
10:33:00 <ndm> eivuokko: i've left registry issues out of this module entirely - although Haskell does probably need a registry/config module - although less critially
10:33:05 <dmhouse> ndm, is splitExtension something like splitExtension "foo.txt" -> ("foo", "txt")?
10:33:18 <eivuokko> ndm, Win32-package has registry stuff in it.
10:33:23 <ndm> dmhouse: "foo.txt" -> "foo" ".txt"
10:33:33 <ndm> dmhouse: "foot." -> "foot" "."
10:33:58 <ndm> dmhouse: general principle - let (a,b) = splitBlah x in x == a ++ b
10:34:17 <dmhouse> uncurry (++) . splitBlah :)
10:34:20 <ndm> The test script has examples of what they all do
10:34:23 <apfelmus> int-e: (no no i mean it worse, please wait)
10:34:25 <dmhouse> oh, in x.
10:34:42 <ndm> nah, thats just bugs
10:34:44 <dmhouse> ndm, do we really need two aliases for addExtension?
10:34:49 <eivuokko> ndm, Well, you also left devices out too, I think.  They start with \\ as well.  I don't think it is orthogonal with MSDN docs to call \\share (UNC path) a drive, but I am not sure on that.  But not likely those are big probs.
10:35:01 <ndm> eivuokko: nope, got that - getDrive :)
10:35:26 <apfelmus> int-e: (!!) gets the head of fib Cons 1. nothing happens, no trashing because of the zipWith pointing to fibs
10:35:50 <ndm> dmhouse: its for symetry, all the operations have split and join, add does something differnet for paths and drives
10:36:22 <ndm> eivuokko: oh, do you mean that devices and drives both start \\path\ ?
10:36:24 <eivuokko> ndm, What I meant was exactly that I am not sure yours is correct.
10:36:30 <apfelmus> int-e: then (!!) reads another Cons 1 ( so we are here (dot) Cons 1 (Cons 1 (.)) 
10:36:33 <eivuokko> ndm, (naming-wise)
10:36:35 <eivuokko> ndm, Yes.
10:36:57 <ndm> eivuokko: ah, yes - I have used drive for Unix "/" as well, I'm not sure there is a good all encompasing term
10:37:07 <eivuokko> ndm, Also some reserved devices names are sort of taken.  Not sure on status on CON, PRN, NUL, COMx, LPTx etc
10:37:23 <ndm> but most people will grasp drives c:\ and then the code will just work with shares as well
10:37:59 <eivuokko> ndm, And in case of terminal services there's global/local modifiers.  But again I don't recall exactly how it goes.  Nor am I sure if it should be in portable lib.  Also mutexes and shared memory etc use \\-names.
10:38:13 <apfelmus> int-e: now, the zipWith part. this will yield Cons (red 1) (Cons (green 1) (Cons (blue thunk = red 1+green 1) (.)))
10:38:22 <ndm> yes, those are outside the scope of files - they just happen to pollute the same namespace :)
10:38:23 <lightstep> apfelmus, good consumers should take care of that problem, and tail and zipWith can be good consumers
10:38:36 <eivuokko> ndm, Yeah.  Just pointing out while I am reading your code.  I don't think that stuff can be conviently fixed.
10:38:43 <ndm> i'm not too sure on the rules for devices, that bit might be flakey :)
10:38:48 <eivuokko> ndm, Well, in some sense maybe.
10:39:01 <ndm> lightstep: zipWith can only consume in one list, not both
10:40:02 <apfelmus> int-e: and then Cons (red 1) (Cons (green 1) (Cons (blue thunk = red 1+green 1) (Cons (blue thunk + green 1) (.)))) and so on, except that i forgot that the first Cons are trashed immediately
10:40:07 <apfelmus> but the colored stuff remains (in case + is not strict) 
10:40:24 <int-e> apfelmus: well, abviously you trashed it too soon
10:40:49 <int-e> apfelmus: the unevaluated thunk in fibs had references to it.
10:40:49 <eivuokko> ndm, Anyhow, I'd make splitDrive accept c:/ and //.  If nothing else it is sometimes very inconvient to pass \\-through various unixy tools.
10:41:51 <dmhouse> ndm: getDirectory "/foo/bar/baz/" -> "/foo/bar/baz". Is that the correct semantic?
10:41:54 <ndm> eivuokko: i thought abotu that, then i found out, it just doesn't work
10:42:03 <eivuokko> ndm, Huh?
10:42:08 <apfelmus> int-e: to soon? no not really, because zipWith will trash them. zipWith only references (tail fibs) and (tail(tail(fibs))) on it's first reduction, so at least the very first Const can be trashed
10:42:21 <ndm> eivuokko: cd d:\sources works fine,  cd d:/sources doesn't
10:42:29 <ndm> dmhouse: I think so, yes
10:42:31 <eivuokko> ndm, That is command prompt?
10:42:38 <eivuokko> ndm, Command prompt /= Windows API
10:42:41 <ndm> eivuokko: yes, and I can only assume for other functions
10:43:13 <SamB> cd interprets / strangely
10:43:26 <eivuokko> No, command prompt internals
10:43:28 <ndm> eivuokko: ok, it seems to work for writeFile, so yep, I'll patch that right now
10:43:30 <SamB> like many programs on windows and DOS, actually
10:43:43 <SamB> eivuokko: seeing as CD is a builtin...
10:44:14 <eivuokko> SamB, ndm, From DOS days command prompt builtins and some other things think / as a parameter separator.  And as dir/s for example workjed, it cannot conviently be overloaded for paths
10:44:24 <eivuokko> It is very big burden of old times.
10:44:39 <eivuokko> Good reason to use JS or VB to write your batch files ;)
10:45:04 <SamB> VBS?
10:45:08 <eivuokko> Yeah
10:45:10 <ndm> Visual Basic Script
10:45:18 <SamB> yeah, I know, thanks ndm ;-)
10:45:46 <SamB> I was just questioning why anyone would *want* to?
10:45:55 <eivuokko> Eh
10:46:11 <SamB> is it better than VB?
10:46:46 <eivuokko> SamB, The choices are: batch file or languages supported by windows scripting host or maybe building exe?
10:47:05 <SamB> okay, so install ActivePython ;-)
10:47:11 <eivuokko> Very very often you don't wnat exe.   Sometimes batch files are not expressive enough.
10:47:21 <SamB> or use JS
10:47:31 <eivuokko> SamB, very very very often that is not an option.  And ActivePython sucks imo, anyway ;)
10:47:42 <SamB> well, probably
10:47:48 <eivuokko> Yeah.  It is possible,. as I said.  VB or JS.
10:48:25 <eivuokko> If you can install python, you could as well install haskell....well maybe not for 64bit..
10:48:26 <ndm> eivuokko: committed, allows //share/ and c:/
10:48:52 <apfelmus> int-e: so basically, the Cons will be trashed but a linear size trunk of unfinished fibonacci numbers will remain.
10:49:36 <SamB> I'm not positive Haskell is really a very good shell scripting language, by itself
10:49:40 <eivuokko> ndm, Cool.
10:49:47 <eivuokko> SamB, Yeah, depends.
10:49:58 <eivuokko> SamB, It isn't many heleprs you need usually.
10:50:15 <dmhouse> ndm, could we have a function that combines equalFilePath and fullPath?
10:50:24 <dmhouse> SamB: that's because string manipulation support in Haskell sucks.
10:50:33 <SamB> yeah
10:50:35 <ndm> dmhouse: yes, any idea for a good name?
10:50:44 <ndm> equalFilePathIO ?
10:50:46 <SamB> also, Haskell isn't very dynamic
10:51:00 <dmhouse> ndm, samePath?
10:51:10 <SamB> though I'm not sure that is much of a problem...
10:51:24 <eivuokko> dmhouse, Doesn't "same" cry out for verb next to it?
10:51:31 * apfelmus sees that he just reproduces the (1+) accumulating parameter thunk problem
10:51:42 <ndm> dmhouse: its not quite samePath, because its still wrong in some cases :(
10:51:42 <dmhouse> eivuokko: Not really. "The filepaths are the same."
10:51:46 <eivuokko> are?
10:51:52 <dmhouse> ndm, which ones?
10:51:53 <dmhouse> eivuokko: Yes.
10:51:57 <int-e> apfelmus: yes, that looks right
10:52:04 <eivuokko> dmhouse, My point, it has verb next to it.
10:52:15 <ndm> dmhouse: symlinks, DOSNAM~1 's
10:52:28 <dmhouse> eivuokko: Well, fine, areSamePath.
10:52:53 <dmhouse> ndm, then let's write one that deals with those cases.
10:53:02 <eivuokko> Hehe
10:53:10 <ndm> It would be nice if the name complemented equalFilePath - i.e. was obviously more powerful than that
10:53:21 * int-e wonders why scanl doesn't have a strict equivalent.
10:53:22 <ndm> dmhouse: would love to, but will require the FFI
10:53:35 <dmhouse> Why? Don't we have isSymlink?
10:53:41 <dmhouse> I don't know anything about DOS.
10:53:51 <eivuokko> dmhouse, I don't think that think is portable to DOS.
10:53:54 <dmhouse> (Those two statements were unrelated.)
10:54:03 <ndm> @type isSymlink
10:54:04 <lambdabot> Not in scope: `isSymlink'
10:54:07 <dmhouse> @hoogle symlink
10:54:08 <lambdabot> No matches found
10:54:11 <dmhouse> @hoogle stat
10:54:12 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateInput :: State tok st -> [tok]
10:54:12 <lambdabot> Text.ParserCombinators.Parsec.Prim.statePos :: State tok st -> SourcePos
10:54:12 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateUser :: State tok st -> st
10:54:19 <dmhouse> @hoogle symbolic
10:54:20 <lambdabot> No matches found
10:54:21 <eivuokko> @hoogle link
10:54:22 <lambdabot> Text.Html.link :: String -> HtmlAttr
10:54:22 <lambdabot> Network.Socket.AF_HYLINK :: Family
10:54:22 <lambdabot> Network.Socket.AF_IMPLINK :: Family
10:54:25 <ndm> I tried that first, but I know that Hoogle doesn't index Posix which is where it is likely to be
10:54:49 <apfelmus> int-e: but let's change the numbers into lists now. say we have integers = list of some other crap and (+) not strict (on lists=integers) but strict on crap
10:54:56 <ndm> readSymbolicLink 
10:55:10 <Lemmih> @type System.Posix.Files.isSymbolicLink
10:55:12 <lambdabot> System.Posix.Files.FileStatus -> Bool
10:55:38 <dmhouse> ndm, another thing, can we newtype FilePath?
10:55:48 <apfelmus> then we should have
10:55:48 <apfelmus> flip (!!) 10 $ map head fibs  <-- no space leak due to strictness
10:55:48 <apfelmus> head $ flip (!!) fibs <-- space leak!
10:56:09 <dmhouse> ndm, or use a typeclass. In case we want to use an ADT in the future.
10:56:11 <ndm> dmhouse: no, its defined by the prelude, so would break readFile writeFile
10:56:21 <ndm> and we can't typeclass because its an alias
10:56:23 <apfelmus> err, head $ flip (!!) 10 $ fibs <-- space leak!
10:56:32 <dmhouse> ndm, err, that's not a problem.
10:56:46 <dmhouse> class PathLike p where ...
10:56:59 <dmhouse> instance PathLike String where ... -- the FilePath instance
10:57:07 <Lemmih> I don't think we should go there yet.
10:57:08 <dmhouse> instance PathLike FilePathADT where ...
10:57:17 <SamB> try it and see, dmhouse ;-)
10:57:25 <ndm> yeah, I agree with Lemmih on this one, a nice library of FilePath stuff
10:57:26 <dmhouse> SamB: fine, [Char].
10:57:37 <SamB> that isn't the problem I meant ;-)
10:57:41 <ndm> then if the need arises, move towards an ADT
10:58:08 <dmhouse> ndm, that's my point. Moving to an ADT would break a lot of code if we didn't newtype.
10:58:09 <SamB> we'd really need a Stringy class then ;-)
10:58:20 <SamB> how does newtype help?
10:58:20 <dmhouse> ndm, if we make the type abstract it can be a seamless transition.
10:58:30 <eivuokko> ndm, btw, I don't think 8.3 names should be considered by FilePath.  In fact, I think all win 9x stuff should be optional as they have very little support.  Using them for equality checks is very wasteful in apps that don't need them because of caching Windows does on NTFS to support them.
10:58:31 <Lemmih> dmhouse: newtyping would break a lot of now.
10:58:32 <ndm> dmhouse: i don't think we're going to move to an ADT without breaking a lot of code anyway - for example readFile
10:58:51 <Lemmih> *a lot of code now.
10:59:06 <dmhouse> SamB, we get a constructor, which we needn't export.
10:59:08 <ndm> eivuokko: i know - just its important to remember that sameFile is not always correct
10:59:23 <ndm> but then people need to wrap their existing FilePath's
10:59:27 <dmhouse> SamB, so the only way to create a value would be to go through some smart construtor, whose definition we coul chop and change in the future.
10:59:28 <ndm> as they are just strings
10:59:42 <dmhouse> ndm, yes, I know.
10:59:43 <SamB> dmhouse: but it still breaks everything that expects FilePath to be String, doesn't it?
10:59:53 <ndm> yes, but my worry is that if we do that, no one will hop through our hoop when its only a line to drop the filename
10:59:54 <dmhouse> SamB, yeah. Perhaps now isn't the time.
11:00:17 <ndm> if we did, we'd need to also overload readFile / writeFile with our type
11:00:18 <SamB> such as every code that uses a string literal for that...
11:00:39 <dmhouse> We can sit down as a community and swap over readFile/writeFile at the same time as switching to ADTs, if necessary.
11:00:42 <ndm> then constructing a file will be done, but its unlikely to be deconstructed much
11:00:47 <SamB> which brings me back to: Stringy!!!
11:00:54 <ndm> yep, i think there was a Haskell' proposal for that
11:01:03 <ndm> for an ADT for FilePath
11:01:07 <dmhouse> Right.
11:01:11 <vincenz> e
11:01:12 <vincenz> re
11:01:17 <dmhouse> With ByteStrings?
11:01:33 <ndm> dmhouse: have you been talking to dons too much ;)
11:01:51 <Excedrin> if I wanted to write a program that exits when some operation fails, but it checkpoints the status and can be resumed where it left off, what sorts of things do I need to consider?
11:01:51 <apfelmus> int-e: ah, now i even think that both give space leaks
11:01:56 <SamB> well, I think my original purpose for Stringy was to make packed strings more convenient...
11:02:18 <dmhouse> Excedrin: what data you need to serialise
11:02:44 <dmhouse> Excedrin: you'd basically need to serialise your execution state and write it to a file.
11:03:49 <Excedrin> if it resumes from the exact point where it stopped, it would be after the exception occured, which isn't what I want
11:04:11 <dmhouse> What do you want, then?
11:04:50 <vincenz> dmhouse: "basically" is hardly the proper word
11:04:55 <vincenz> dmhouse: this is going to require a custom monad
11:05:00 <Excedrin> something less sophisticated and higher level; write "operation 1 done, operation 2 done" to a file for example, then on restarting it skips the "done" stuff and starts at the next step
11:05:08 <the_lord> @hoogle (a,b,c) -> a
11:05:09 <lambdabot> No matches, try a more general search
11:05:09 <vincenz> dmhouse: not to mention the issues of checkpointing...what of local vars...what of vars stored in thunks
11:05:15 <the_lord> @hoogle (a,a,a) -> a
11:05:16 <lambdabot> No matches, try a more general search
11:05:19 <the_lord> :(
11:05:32 <dmhouse> the_lord: fst3 (x, _, _) = x
11:05:49 <vincenz> @dmhouse (a,b,(a,b,(c,d))) -> d
11:05:50 <lambdabot> Unknown command, try @list
11:05:51 <the_lord> snd3 trd3?
11:06:01 <vincenz> the_lord: just use
11:06:04 <dmhouse> the_lord: what do you think they'd be?
11:06:08 <vincenz> > let (a,b,c) = x in ...
11:06:08 <lambdabot>  Parse error
11:06:56 * apfelmus feels lonely
11:07:21 <vincenz> apfelmus: me too
11:07:28 <the_lord> @hoogle fst3
11:07:28 <lambdabot> No matches found
11:07:32 <the_lord> :(
11:07:34 <vincenz> @type fst3
11:07:35 <lambdabot> Not in scope: `fst3'
11:07:37 <dmhouse> Excedrin: carry around an environment, which is a record of Bools indicating how far you've got. Then serialise this and write it to a file/
11:07:42 <vincenz> @type Data.Tuple.fst3
11:07:44 <lambdabot> Not in scope: `Data.Tuple.fst3'
11:07:55 <vincenz> apfelmus: phd student/
11:07:57 <vincenz> ?
11:08:22 <apfelmus> vincenz: graduate student
11:08:28 <Excedrin> dmhouse: how would I skip completed operations on resume?
11:08:35 <vincenz> apfelmus: you mean undergraduate
11:09:12 <dmhouse> Excedrin: As vincenz says, probably a custom monad, an adaptation of State perhaps, would be applicable here.
11:09:26 <apfelmus> vincenz: maybe. things are different in germany
11:09:33 <vincenz> achso
11:09:38 <dmhouse> vincenz: A graduate student is someone doing a degree after having finished their first.
11:09:38 <vincenz> ich bin in belgie
11:09:57 <madpickle> we call that post-graduate in the uk, and refer to someone having graduated University as a 'graduate'
11:10:01 <madpickle> whether post- or under-grad.
11:10:03 <vincenz> dmhouse: I do believe he meant undergrad tho
11:10:10 <dmhouse> madpickle: 'graduate' is used too.
11:10:17 <dmhouse> apfelmus: Do you have a degree?
11:10:19 <madpickle> yeah
11:10:24 <madpickle> but that's just confusing
11:10:26 <vincenz> dmhouse: do you have a pickle
11:10:32 <madpickle> have a what? degree?
11:10:36 <madpickle> finishing it now.
11:10:46 <dmhouse> madpickle: I was addressing apfelmus.
11:10:51 <madpickle> sorry.
11:10:58 * vincenz takes madpickle and bites his head off
11:11:00 <vincenz> juicy
11:11:03 <madpickle> O.o
11:11:15 <vincenz> madpickle: No seriously, you're in univ atm?
11:11:20 <madpickle> uh-huh
11:11:24 <vincenz> which year?
11:11:27 <dmhouse> madpickle: Where?
11:11:28 <apfelmus> dmhouse: yes and no. there is some "informal" degree (roughly equivalent to a bachelor)
11:11:28 <madpickle> final
11:11:33 <vincenz> crap
11:11:35 <madpickle> swansea, uk
11:11:53 <vincenz> apfelmus: hooray for the rappy bologna system
11:11:54 <dmhouse> apfelmus: I see.
11:11:56 <vincenz> s/rappy/crappy
11:13:13 <apfelmus> i could avoid it but only barely
11:14:32 <vincenz> ooh
11:14:33 <vincenz> google checkout
11:16:08 <vincenz> https://checkout.google.com/buyer/tour.html#video
11:19:18 <vincenz> ooh, this is something cool: http://googlesystem.blogspot.com/2006/06/meebo-all-in-one-online-instant.html
11:19:19 <lambdabot> Title: "Google Operating System: Meebo - All-in-one Online Instant Messenger"
11:20:31 <vincenz> and now for something funny: Google has a very strict policy regarding items that can be sold using Google Checkout. Here's what you can't buy:Body parts - Organs or other body parts
11:20:33 <madpickle> sorry, but google does not impress me much
11:20:50 <vincenz> madpickle: the second one is not related to google
11:21:01 <vincenz> madpickle: it's just put on their blog, but this blog just talks about new technologies in general
11:21:07 <madpickle> i use trillian =)
11:22:32 <vincenz> a) on linux, b) proxied at work
11:22:33 <dmhouse> @hoogle filterM
11:22:34 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
11:22:35 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
11:22:35 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
11:22:43 <dmhouse> ndm, we don't need to provide our own
11:22:56 <ndm> dmhouse: 
11:22:59 <ndm> dmhouse: good point
11:23:04 <ndm> will fix that now
11:23:10 <sylvan> @where ByteString
11:23:11 <lambdabot> I know nothing about bytestring.
11:23:14 <dmhouse> ndm, I'll add it to my patch.
11:23:15 <sylvan> hmm
11:23:36 <ndm> dmhouse: fair enough, i won't add it to mine then
11:29:19 <vincenz> time do to something useful
11:29:23 <sjanssen> @where fps
11:29:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
11:29:28 <vincenz> ndm: mind joining #oasis?
11:29:41 <sjanssen> @where+ http://www.cse.unsw.edu.au/~dons/fps.html
11:29:42 <lambdabot> Done.
11:29:45 <sjanssen> oops
11:29:54 <sjanssen> @where+ ByteString http://www.cse.unsw.edu.au/~dons/fps.html
11:29:55 <lambdabot> Done.
11:30:01 <sjanssen> @where ByteString
11:30:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
11:30:07 <sjanssen> @where http://www.cse.unsw.edu.au/~dons/fps.html
11:30:30 <int-e> @where bytestring
11:30:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
11:30:31 <ndm> dmhouse: some more patches in the repo now
11:30:33 <int-e> @where bytestrinG
11:30:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
11:30:36 <int-e> hmm
11:30:39 * int-e shrugs
11:30:55 <ndm> dmhouse: i'm off in about 5 mins, so if you could send me whatever you've done so far, i'll commit it now - so people can see better docs right away
11:32:30 <ndm> dmhouse: I have also added a few patches, so do darcs pull first
11:32:33 <ndm> just small tweaks
11:32:47 <vincenz> ndm: what are you two working on?
11:32:53 <vincenz> ndm: the filepath thing?
11:32:57 <ndm> vincenz: System.FilePath, yep
11:33:06 <vincenz> cool
11:33:25 <ndm> he's doing some better docs :)
11:33:42 <roconnor> @hoogle Word32
11:33:42 <lambdabot> Data.Word.Word32 :: data Word32
11:35:57 <ndm> dmhouse: last chance, if not just send me the patches for tomorrow morning - i'm not at the repo before then
11:36:03 <ndm> and thanks for your work on this :)
11:38:25 <ndm> bye
11:38:39 <vincenz> @localtime ndm
11:46:35 <sjanssen> @localtime sjanssen
11:46:37 <lambdabot> Local time for sjanssen is 2006-06-29 13:46:12 -0500
12:06:05 <fanopanik> omg
12:06:56 <dmhouse> fanopanik: ?
12:07:20 <apfelmus> fanopanik: don't panic, fan
12:07:28 <fanopanik> I ameliorated my Haskell grade with today's exam.
12:07:50 <fanopanik> before I had a F (or whatever is the worst grade in your country)
12:07:58 <fanopanik> now I have an A.
12:08:17 <fanopanik> Cheers. :D
12:08:24 <norpan> hola
12:08:42 <apfelmus> fanopanik: and before F, you surely had _|_
12:08:43 <Stinger_> ameliorated?
12:08:58 <norpan> that's a fancy word
12:09:15 <Stinger_> obviously an English major :P
12:09:21 <fanopanik> apfelmus: que?
12:10:04 <fanopanik> capital i?
12:10:26 <apfelmus> fanopanik: _|_ = bottom
12:10:30 <dmhouse> fanopanik: bottom. :) What 'undefined' really is.
12:10:40 <fanopanik> ah! I see :)
12:11:00 <dmhouse> And the value of error, and various other functions.
12:11:04 <fanopanik> either way, that concludes my term. Guess it's time to party
12:11:51 <Stinger_> heh I finished my last exam the other day, so now I'm learning haskell :P
12:11:57 <Stinger_> wooo! :|
12:13:04 <dmhouse> I finished my last exam a few weeks ago, now I'm back at school!
12:13:19 <sjanssen> @yow
12:13:20 <lambdabot> I'm reporting for duty as a modern person.  I want to do the Latin
12:13:20 <lambdabot> Hustle now!
12:16:22 * apfelmus gets garbage collected (NOO000ooo...... 
12:17:42 <vincenz> lol
12:17:59 <Stinger_> pfft, if he was really gced he wouldnt be gced until after he was gone :P
12:18:20 <dmhouse> Stinger_: It's a temporally-eager GC.
12:18:21 <int-e> it was a finalizer
12:18:25 <vincenz> Stinger_: he registered a thunk for deallocation
12:18:28 <vincenz> like int-e said
12:18:58 * Stinger_ nods and smiles
12:22:18 * vincenz puts Stinger_ into a weak-reference
12:22:40 <Stinger_> FINE
12:22:55 <Stinger_> I understand that one
12:27:44 <RyanT5000> hm, you know what would be nice? "type error annotations"
12:27:46 <RyanT5000> by which i mean
12:27:57 <RyanT5000> annotations in the source that change the type error generated for a given type/class/etc.
12:28:08 <vincenz> hehe
12:28:18 <RyanT5000> e.g.: my cache manager generates really, really nasty type errors if you use it incorrectly
12:28:25 <vincenz> proper error messages are already one of the bitchiest parts of writing a compiler
12:28:34 * vincenz for instance has kept it so simple you can't get any useful info
12:28:46 <vincenz> RyanT5000: cache manager?
12:28:48 <RyanT5000> yeah
12:28:58 <vincenz> RyanT5000: Working on a cpu simulator?
12:29:03 <RyanT5000> nope, video game :)
12:29:04 <Stinger_> yeah one of the things that sucks about c++ templates, the errors
12:29:15 <vincenz> RyanT5000: explain more?
12:29:20 <RyanT5000> i need something to deal with my textures, vertex buffers, and other large datastructures
12:30:07 <RyanT5000> basically you define certain kinds of transitions
12:30:08 <RyanT5000> like
12:30:16 <RyanT5000> from Filename to Ptr a
12:30:34 <RyanT5000> then you request a Filename as a Ptr a from the cache manager, and voila
12:30:37 <vincenz> transitions?/
12:30:41 <RyanT5000> cache-transitions
12:30:44 <RyanT5000> "loaders"
12:30:47 <vincenz> oh
12:30:55 <vincenz> a Map
12:30:56 <vincenz> :D
12:31:02 <RyanT5000> busses, if you want to think of it from a CPU arch perspective
12:31:17 <vincenz> the reason I asked is cause I was thinking cache in cpus
12:31:33 <RyanT5000> well it's kind of like a map with an eviction policy :P
12:31:45 <RyanT5000> and also it maps over types as well as values
12:31:58 <vincenz> RyanT5000: eviction based on
12:32:09 <vincenz> RyanT5000: cause I was just browsing the "System.Mem.Weak" stuff
12:32:12 <vincenz> maybe that is what you need
12:32:17 <RyanT5000> well i use that too
12:32:22 <RyanT5000> basically to use it
12:32:28 <RyanT5000> you first get a resource reference
12:32:32 <RyanT5000> from the cache manager
12:32:52 <vincenz> centralized datastructures are bitchy in haskell
12:32:54 <RyanT5000> then, whenever you want to use the resource, you either acquire it permanently (which uses System.Mem.Weak to release it when it gets GCed)
12:33:00 <RyanT5000> or you use "with"
12:33:04 <RyanT5000> to acquire it temporarily
12:33:20 <RyanT5000> the cache manager can keep statistics on how often the resource is used
12:33:32 <vincenz> is
12:33:34 <vincenz> i see
12:33:41 <RyanT5000> as well as do budget accounting on various memory pools at its disposal
12:33:53 <vincenz> RyanT5000: do you have a simple usage example
12:33:53 <RyanT5000> and evict resources based on those parameters :)
12:33:56 <RyanT5000> yeah
12:34:01 <RyanT5000> just a sec
12:34:12 <RyanT5000> i've only finished the API and a "NullCache" so far
12:34:18 * vincenz btw notes that #haskell is one of the greatest channels around, you ask questions in other channels and if you're not 100% accurate, they shoot you down instead of guessing what you really meant
12:34:28 <RyanT5000> a NullCache just loads items for the duration of their use
12:34:41 <RyanT5000> i.e.: it's just like not caching anything
12:34:50 <vincenz> RyanT5000: these all run in IO?
12:34:52 <RyanT5000> yeah
12:35:09 <vincenz> with cleaning stuff happening whenever you requests
12:35:11 <RyanT5000> although presumably you could make one that used unsafePerformIO without really being too unsafe
12:35:13 <vincenz> or as a separate theraD?
12:35:26 <RyanT5000> that's left to the implementer of the specific caching policy
12:35:36 <vincenz> grrr.... fglrx is buggy, no direct rendering, so my typing is seriously lagging, so I get a lot of typos :/
12:35:53 <RyanT5000> don't worry about it
12:36:01 <ndm> dmhouse: i am back briefly, if you have any patches
12:36:08 <dmhouse> ndm, not yet.
12:36:11 <RyanT5000> as soon as i get my module to load again i'll give you a use case example
12:36:25 <dmhouse> ndm, how briefly? I think I'm done, just need to test.
12:36:35 <ndm> dmhouse: about 15 mins
12:36:45 <ndm> have to go home for house, and its about a 10 minute walk :)
12:36:56 <dmhouse> ndm, hehe, sure.
12:37:11 <ndm> are your changes not just mainly docs?
12:37:25 <ndm> otherwise, fire up Tests.hs and run main, that catches most bugs introduced
12:38:16 <dmhouse> All docs, really.
12:38:23 <dmhouse> But I still need to test it doesn't bork Haddock.
12:38:50 <ndm> hehe, yeah, a common occurance
12:39:22 <ndm> do: -- | ''' in a file and run haddock on it
12:39:36 <ndm> three single apostraphes :)
12:48:49 <RyanT5000> let ref = mkRef NullCache "Client.exe.gc" GCPool in with ref putStrLn
12:49:26 <RyanT5000> that prints the contents of the file "Client.exe.gc", subject to caching in NullCache
12:50:24 <RyanT5000> GCPool just tells it you're expecting to get a value that uses up the normal haskell memory pool (as opposed to the Malloc/Free pool, or video ram pool, or something else)
12:51:26 <RyanT5000> right now any string in the second argument to mkRef is treated as a filename, because the standard library used type rather than newtype for FilePath
12:51:45 <dmhouse> ndm, you'd better leave. I'll mail you the patches.
12:51:57 <ndm> dmhouse: fair enough, cheers for your work
12:52:57 <ndm> dmhouse: I just pushed another patch, so you are up to date
12:53:08 <dmhouse> ndm, I will be before I send.
12:53:43 <ndm> there are a few more function in as well
12:53:48 <ndm> anyway, bye (and runs!)
13:24:27 <RyanT5000> can you make a functional dependency based on two types?
13:24:43 <dmhouse> Yeah.
13:24:54 <RyanT5000> i have a class Cache cache ref handle | ref -> cache, ref -> handle
13:24:56 <dmhouse> class Foo a b c | a, b -> c or something
13:25:06 <RyanT5000> ah, ok i put parens around (a, b)
13:25:16 <dmhouse> Ah. That'd be a tuple.
13:25:29 <RyanT5000> no i mean right of the |
13:26:02 <RyanT5000> hm doesn't seem to work
13:26:12 <RyanT5000> i get a parse error
13:26:14 <dmhouse> Check the docs.
13:26:34 <RyanT5000> where are they?
13:26:46 <dmhouse> http://haskell.org/ghc/docs/latest/html/users_guide/index.html
13:26:47 <lambdabot> Title: "The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.4.2"
13:27:08 <RyanT5000> ah right, it'd be ghc docs not haskell docs
13:27:21 <roconnor> dmhouse: no comma
13:27:29 <dmhouse> roconnor: Sure?
13:27:36 <roconnor> pretty sure
13:27:46 <dmhouse> 'a b' would be b applied to the tycon a, no?
13:27:47 <roconnor> (it's bad notation)
13:27:57 <dmhouse> Ah.
13:27:58 <roconnor> only type variables allowed
13:28:00 <RyanT5000> yeah, there's no comma
13:28:26 <RyanT5000> so you can't have higher-kind types there?
13:28:41 <sjanssen> RyanT5000: sure you can, it just doesn't matter
13:28:57 <RyanT5000> ah ok
13:29:09 <RyanT5000> yeah, i guess it wouldnt' matter
13:29:11 <roconnor> RyanT5000: only type variables,  even if they are higher-kinded or whatever
13:29:53 <RyanT5000> right
13:30:14 * Philippa_ gets the impression some're not clear on what "higher kind" means
13:30:54 <roconnor> I get confused by kinds and types and what higher means
13:31:09 <RyanT5000> lol i don't claim to have any idea what i'm talking about
13:31:12 <roconnor> I suppose what we are looking for is higher order type constructors
13:31:39 <Philippa_> probably, yeah
13:31:53 <Philippa_> I mean, we don't have foralls in our kinds
13:32:07 <roconnor> but we could :)
13:32:34 <sieni> Philippa_: <3
13:32:45 <Philippa_> You're talking to someone who wants to play around with the idea of various forms of composition for PTSes :-)
13:33:19 <roconnor> There is a Haskell program for doing that
13:33:24 <Philippa_> yeah?
13:33:29 <Philippa_> got an URL?
13:33:38 <vincenz> PTS?
13:33:41 <roconnor> my office mate managed to build it.
13:33:47 <Philippa_> vincenz: Pure Type System
13:33:56 <vincenz> oh
13:34:00 <vincenz> with . and $?
13:34:05 <Philippa_> probably the best intro's Barendregt's paper - they're a generalisation of the lambda cube
13:34:28 * Philippa_ found the ways of enforcing first-order-only restrictions in them particularly cute
13:36:34 <roconnor> I think it is yarrow
13:36:40 <roconnor> http://www.haskell.org/yarrow/janz/yarrow/userg.html
13:36:42 <lambdabot> Title: "Yarrow User Guide"
13:37:14 <roconnor> I probably can get you Haskell 98 version if you want
13:37:54 <Philippa_> one of the things I want to play with is whether it's possible to define a record calculus as a PTS
13:38:39 <roconnor> well, that's beyond me. But rumour has it yarrow is a nice tool for defining and using PTS's
13:39:00 <Philippa_> I should have a play, definitely
13:39:14 <Philippa_> my to-do list is kinda too huge atm though, I've burnt out just on domestics...
13:39:16 <lispy> /me had a friend named yaro and i thought you were talking about him for a second :)
13:47:14 <jberg_> what does @ mean in pattern matching?
13:47:20 <Philippa_> var@pattern
13:47:26 <Philippa_> match pattern, bind to var
13:47:40 <Philippa_> eg xs@(x:xs')
13:47:48 <Philippa_> xs is the whole list, xs' the tail of xs
13:47:49 <lightstep> this way, you can bind both the big value, and the parts of it
13:47:57 <jberg_> yeah i see
13:47:59 <dmhouse> > let a@(x, y) = (1, True) in a
13:48:01 <lambdabot>  (1,True)
13:48:06 <Philippa_> a particularly pointless example would be foo@_
13:48:10 <jberg_> so you can refer to both parts?
13:48:14 <dmhouse> jberg_: right.
13:48:16 <vincenz> Philippa_: or foo@foo
13:48:21 <kpreid> curiosity: would @ work just as well if both sides were general patterns?
13:48:26 <Philippa_> vincenz: that's not legal
13:48:32 <Philippa_> non-linear pattern
13:48:35 <vincenz> > let foo@foo = 1 in foo
13:48:35 <dmhouse> > let x@x = 1 in x
13:48:36 <lambdabot>    Conflicting definitions for `foo'
13:48:36 <lambdabot>   In the binding group for: foo, foo
13:48:37 <lambdabot>    Conflicting definitions for `x'
13:48:37 <lambdabot>   In the binding group for: x, x
13:48:43 <vincenz> > let a@b = 1 in foo
13:48:43 <lightstep> kpreid, no, that's also illegal
13:48:43 <lambdabot>  Not in scope: `foo'
13:48:47 <vincenz> > let a@b = 1 in a
13:48:48 <lambdabot>  1
13:48:53 <lightstep> > let (x,y)@(a,b) = (1,2) in x
13:48:54 <lambdabot>  Parse error
13:48:59 <dmhouse> kpreid: what would be the point?
13:49:10 <vincenz> Philippa_: but the totality of useless would be _@_
13:49:17 <Philippa_> _ isn't a variable
13:49:17 <vincenz> > let _@_ = 1 in 1
13:49:18 <lambdabot>  Parse error
13:49:22 <vincenz> oh
13:49:23 <vincenz> hmm
13:49:25 <lightstep> you would gain nothing, considering you can nest as-patterns
13:49:29 <kpreid> lightstep, dmhouse: it was hypothetical
13:49:34 <dmhouse> > let a = (1, True); (x, y) = a; (z, w) = a in (x, z)
13:49:35 <lambdabot>  (1,1)
13:49:44 <vincenz> Philippa_: pity, I'd love to litter my code with those airplanes
13:50:14 <vincenz> Philipp@_
13:52:03 <vincenz> Philippa_: do you happen to know any way of forcing my language to be first-order?
13:52:12 <arjanoosting> SyntaxNinja: ping
13:52:27 <vincenz> arjanoosting: lambdabot has a new feature @tell
13:52:49 <Philippa_> vincenz: yeah, don't allow function arrows as LHS arguments to function arrows
13:53:01 <vincenz> Philippa_: so do it during typecheck
13:53:04 <Philippa_> yep
13:53:09 <vincenz> sounds good
13:53:11 <arjanoosting> vincenz: nice
13:53:16 <vincenz> @karma++ Philippa_ 
13:53:16 <lambdabot> Philippa_'s karma raised to 1.
13:53:20 <vincenz> @tell arjanoosting Example
13:53:20 <lambdabot> Consider it noted.
13:53:26 <vincenz> arjanoosting: say smoething
13:53:30 <arjanoosting> hi
13:53:31 <lambdabot> arjanoosting: You have 1 new message. '/msg lambdabot @messages' to read it.
13:53:44 * Philippa_ wonders if the bot knows I'm me when I do this...
13:53:54 <Philippa> it probably doesn't, of course
13:54:09 <vincenz> it'd be neat if lambdabot kept a graph of nickchanges
13:54:13 <vincenz> except that might be dangerous
13:54:21 <vincenz> if people start having another "let's have the shortest nick" day
13:54:27 <vincenz> at which point you get a completely connected graph :D
13:55:49 <SyntaxNinja> hiya arjan
13:55:51 <SyntaxNinja> arjanoosting: 
13:56:04 <lispy> SyntaxNinja: hi
13:56:09 <arjanoosting> hi, i just saw your email
13:56:21 <lispy> SyntaxNinja: do you guys use windows stuff at galois?
13:56:26 <Philippa> it could possibly look up which nicks're linked on nickserv though?
13:56:58 <kosmikus> arjanoosting: hi there. what are you doing these days?
13:57:16 <lispy> well, it could just required that you're identified to nickserv and only alow you to get messages for your current nick
13:57:39 <lispy> but maybe i'm missing the point
13:58:04 <lightstep> nickserv is not really secure
13:58:06 <arjanoosting> SyntaxNinja: my AM (Martin Michlmayr) will probably prepare my NM report this week, so then it is waiting for the Front Desk :)
13:59:57 <SyntaxNinja> lispy: windows stuff?
14:00:17 <vincenz> SyntaxNinja: cleenex
14:00:32 <vincenz> or vim, or some other glass product
14:00:58 <SyntaxNinja> arjanoosting: OK.  let me know if you ever want me to poke people. we need you!
14:01:02 * SyntaxNinja is confused
14:01:15 * vincenz was just kidding
14:01:22 <SyntaxNinja> :)
14:01:29 <Philippa> SyntaxNinja: I think you're being asked if windows gets used for something other than something to run putty on
14:01:45 <arjanoosting> kosmikus: feeling rather stupid for dropping out of my thesis project... :(
14:01:58 <arjanoosting> SyntaxNinja: thanks :)
14:02:00 <SyntaxNinja> Philippa: some of the non-tecs here use windows, but not many, most people, even engineers are mostly using Mac, I'm one of the few linux-only ppl.
14:02:17 <SyntaxNinja> even the engineers using macs are logging into linux machines to do lots of their "real" work :)
14:02:18 <vincenz> arjanoosting: joining galois?
14:02:30 <SyntaxNinja> sorry, gotta run.
14:02:33 <SyntaxNinja> vincenz: no, debian :)
14:02:34 <kosmikus> arjanoosting: :)
14:02:36 <lispy> SyntaxNinja: oh cool
14:02:39 <SyntaxNinja> but if anyone wants to join galois email me :P
14:02:42 <SyntaxNinja> we need to hire.
14:02:46 <vincenz> SyntaxNinja: how many people work @ galois?
14:02:52 <SyntaxNinja> vincenz:  25 I think
14:02:53 <lispy> SyntaxNinja: i was hoping to find someone else that's using haskell in windows land that i could get advice from
14:02:59 <vincenz> SyntaxNinja: I'm possible considered for the future
14:03:01 <SyntaxNinja> lispy: nope, sorry.
14:03:12 <SyntaxNinja> I gotta go to a meeting. email me ppl :) bbiab
14:03:29 <greenrd> So whats the deal with these PTSs then?
14:03:32 <greenrd> What is a PTS?
14:03:46 <vincenz> greenrd: Parent Teacher Society
14:03:47 <Philippa> greenrd: generalisation of the lambda cube. Sort-of build your own typed lambda calculus
14:03:52 <Philippa> "Pure Type System"
14:04:03 <greenrd> vincenz, haha
14:04:15 <greenrd> I don't know what the lambda cube is
14:06:51 <Philippa> it's a set of 8 type systems that share a set of rules and are parameterised on a relationship (which is different for each of the 8 points in the cube)
14:07:07 <greenrd> freaky!
14:07:10 <vincenz> Philippa: yoeah mean each of the 8 edges
14:07:22 <xerox> verticles
14:07:30 <vincenz> lol, verticle
14:07:35 <vincenz> ;0
14:07:36 <xerox> vertex?
14:07:37 <vincenz> :)
14:07:40 <xerox> Well, those.
14:07:40 <vincenz> verticies
14:07:41 <Philippa> the 'nearest' point is the simply-typed lambda calculus, and the 'furthest' the Calculus of Constructions. System F and System F Omega are also featured
14:07:42 <vincenz> erm
14:07:43 <greenrd> vertices
14:07:44 <vincenz> vertices
14:07:48 <Philippa> vertex, node, point, same difference here
14:07:59 <Philippa> (point being acceptable by treating it as a geometric cube)
14:08:01 * vincenz is lagged, dapper is buggy and my keyboard is seriously lagging 
14:08:02 <dmhouse> greenrd: http://www.rbjones.com/rbjpub/logic/cl/tlc001.htm
14:08:03 <lambdabot> Title: "Barendregt's Lambda Cube"
14:12:25 <Manyfold> how to get help on a builtin function like say map in ghci?
14:12:37 <dmhouse> Manyfold: check the Haddock docs.
14:12:43 <dmhouse> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:12:54 <dmhouse> Manyfold: click on 'Prelude' in that list.
14:13:05 <dmhouse> Or...
14:13:07 <dmhouse> @docs Prelude
14:13:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
14:13:13 <dmhouse> Just use that link. :)
14:14:56 <Manyfold> thanks
14:15:31 <vincenz> > 15000 * 6 / 100
14:15:32 <lambdabot>  900.0
14:21:46 <RyanT5000> is it possible to delay instance checking?
14:22:03 <RyanT5000> like, let's say i have a class with an instance Class [a]
14:23:07 <norpan> let's say
14:23:09 <RyanT5000> ah dang, i can't figure out my own example
14:24:39 <RyanT5000> well here's the point: i have an expression that's supposed to a member of a class, but it's polymorphic, and you can't tell if there's actually an instance or not until the polymorphism resolves
14:25:16 <RyanT5000> hm, i guess it wouldnt' make sense if that could work
14:28:57 <lightstep> RyanT5000, like a definition: x :: Read a => a; x = read "5" ?
14:30:41 <RyanT5000> nah, something much dumber :P
14:30:51 <RyanT5000> involving existentials
14:31:01 <RyanT5000> but all i have to do is give it an explicit type signature and it works
14:31:10 <RyanT5000> and in actual use i anticipate always knowing the type anyway
14:39:56 <Heffalump> anyone familiar with HaXml?
14:40:23 <Heffalump> in particular, what do I need to do to unescape the content I read in via readXml?
14:42:17 <RyanT5000> does handle reraise its exception?
14:42:31 <RyanT5000> or rather
14:42:36 <RyanT5000> is there a version of handle that does?
14:42:57 <Heffalump> you want something like finally
14:43:08 <RyanT5000> yes, except i only want it to happen if there's an exception
14:43:10 <Heffalump> oh, maybe not
14:43:17 <Heffalump> right, sorry
14:43:21 <Heffalump> just make your own wrapper for handle
14:43:28 <RyanT5000> yeah, i will
14:43:39 <RyanT5000> i just always prefer to use lib functions if they exist
14:45:05 <Heffalump> I'm not aware of one, and if you're read the API of Control.Exception and not found one, then there almost certainly isn't one.
14:45:22 <RyanT5000> yeah, i read  it
14:49:17 <RyanT5000> is there a way to get a stack trace from an exception?
14:49:25 <RyanT5000> *** Exception: Maybe.fromJust: Nothing
14:49:31 <RyanT5000> i'm looking for something more verbose, lol
14:50:39 <dmhouse> RyanT5000: Hat.
14:50:41 <dmhouse> @where hat
14:50:42 <lambdabot> http://www.cs.york.ac.uk/fp/hat
14:50:51 <dmhouse> RyanT5000: Or don't use fromJust :)
14:51:02 <RyanT5000> lol but it's so easy to use!
14:51:12 * dmhouse wished Haskell had __FILE__ and __LINE__ magic values
14:51:27 <RyanT5000> and i only use it when i want an exception to be thrown if it's Nothing
14:52:50 <RyanT5000> i guess i'll switch to fromMaybe (error "blah")
14:54:26 <RyanT5000> ...
14:54:47 <RyanT5000> i  guess i fixed it
14:54:49 <RyanT5000> lol
14:54:54 <Igloo> RyanT5000: Compiling with -prof -auto-all and giving +RTS -xc at run-time can be helpful
14:55:11 <Igloo> Personally I'd recommend against using fromJust, though
14:55:27 <RyanT5000> fromMaybe (error...) better?
14:55:40 <Igloo> Yup
14:55:47 <bringert_> dmhouse: but it does have __LINE__ and __FILE__
14:55:56 <bringert_> test = __FILE__ ++ ":" ++ show __LINE__
14:56:04 <bringert_> load with "ghci -cpp"
14:56:16 <dmhouse> Well, that's not really Haskell ;)
14:56:19 <dmhouse> > __LINE__
14:56:20 <lambdabot>  Not in scope: `__LINE__'
14:56:31 <dmhouse> But a nice trick nonetheless.
14:57:07 <bringert> hmm, ghci doesn't do cpp on the interactive input
14:57:23 <bringert> I guess that wouldn't be terribly useful
14:58:58 <RyanT5000> maybe TH has __FILE__ and __LINE__ equivalents
14:59:01 <RyanT5000> it certainly seems like it could
15:00:54 <Cale> hi
15:00:59 <dmhouse> Hey Cale.
15:01:19 <Cale> someone said my name, but I don't have enough scrollback to see who :)
15:01:25 <dmhouse> Cale, logs?
15:01:37 <Cale> yeah, I'll have to dig through them :)
15:01:42 <dmhouse> Or search them ;)
15:02:54 <Cale> FreeNode-#haskell.log 1613568L, 117980702C
15:04:04 <Cale> ah, okay
15:04:11 <Cale> just someone looking for a puzzle
15:04:43 <RyanT5000> is there a nonlazy version of hGetContents?
15:05:03 * Heffalump swears at WASH
15:05:16 <Cale> people have written them, but not in the hierarchy, afaik
15:05:19 <Heffalump> I really shouldn't have used it given I want to control my own parameter passing etc.
15:05:24 <RyanT5000> because i have issues: bracket (openFile "name" ReadMode) (hClose) hGetContents doesn't really work
15:05:32 <Cale> There's a rather good implementation by Simon Marlow
15:05:36 <Cale> oh
15:05:44 <Cale> that's because you're closing the handle
15:05:56 <Cale> you're not supposed to close a handle passed to hGetContents
15:05:57 <bringert> Heffalump: have you tried NewCGI?
15:06:01 <RyanT5000> hm
15:06:06 <Cale> It'll close itself when you're done
15:06:10 <bringert> or are you too far along in the project already?
15:06:16 <RyanT5000> but i want to read the whole string at once
15:06:23 <RyanT5000> lol this is in my file cache manager
15:06:31 <RyanT5000> i'm trying to manage the laziness myself
15:06:37 * bringert is plugging shamelessly
15:07:06 <bringert> Heffalump: what are you working on?
15:07:25 <Heffalump> bringert: looks good, what should I use for HTML generation?
15:07:33 <bringert> Text.XHtml
15:07:36 <Heffalump> bringert: a program to practice bridge bidding
15:07:59 <bringert> cgi: http://www.cs.chalmers.se/~bringert/darcs/haskell-cgi/doc/
15:08:06 <bringert> xhtml: http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml/doc/
15:08:13 <Heffalump> yeah, google is my friend :-)
15:08:27 <Heffalump> are there .debs by any chance?
15:08:53 <bringert> not that I know of
15:09:12 <bringert> though several people seem to be making debs of random haskell libs so the might be
15:09:21 <bringert> s/the/there/
15:10:06 <Heffalump> the annoying thing is that I'm this --> <-- far from making WASH do a good enough job.
15:10:26 <Heffalump> but I just can't get it to tell me the CGI parameters.
15:12:05 <bringert> I'm sorry to say that I haven't found WASH very usable for larger / more advanced projects
15:12:18 <Heffalump> yeah, I think I'm going to have to get rid of it.
15:12:25 <Heffalump> I just want to get this thing working now so I can go to bed :-)
15:12:35 <bringert> Heffalump: have you seen Hope btw: http://hope.bringert.net/
15:12:41 <Heffalump> so I don't want to mess around installing NewCGI etc right this second.
15:13:05 <bringert> just to show you an example NewCGI application
15:13:15 * bringert is plugging again
15:14:13 <Heffalump> yet another bloggy type thing? ;-)
15:14:32 <bringert> yep, at the moment at least.
15:14:53 <bringert> it has a module system, but the only modules so far are blog and photo album
15:15:11 <bringert> Heffalump: yet another? are the other Haskell blogging systems?
15:15:33 <bringert> it could certainly have a bridge module :-)
15:15:53 <Heffalump> I wasn't limiting myself to Haskell
15:16:12 <bringert> ah
15:16:22 <Heffalump> I still haven't really got my head round using HaskellDB, sadly.
15:16:38 <Heffalump> (mostly due to lack of effort, but it wasn't completely obvious to me how to use it the first time I looked)
15:17:29 <bringert> Heffalump: many modules shouldn't have to use HaskellDB actually
15:17:48 <vincenz> hi
15:17:51 * Heffalump will take a look when he has time :-)
15:17:57 <vincenz> Anyone familiar with how to do xinerama?
15:18:03 <Heffalump> but I tend to get sidetracked into looking at interesting stuff too easily
15:18:13 <Heffalump> So I really want to get this thing just working, however I do it.
15:18:14 <bringert> yeah, that easy to do
15:18:23 <bringert> getting sidetracked that is
15:20:32 <Heffalump> GAHHHHHHH!
15:20:37 <Heffalump>          rawDecodedParameters 
15:20:37 <Heffalump>            | methodIsGet = []
15:22:51 <bringert> that's interesting
15:23:09 <vincenz> ?
15:23:18 <bringert> Heffalump: WASH uses CGI, right, and GET parameters are in the QUERY_STRING environment variable
15:23:38 <Heffalump> indeed.
15:23:43 <Heffalump> I'm just about to go read that manually.
15:24:51 <bringert> if you want a decoding function, see formDecode in http://www.cs.chalmers.se/~bringert/darcs/haskell-cgi/Network/NewCGI/Internals.hs 
15:25:08 <Heffalump> I'm just going to hack it quickly to get the one number I want so I can go to bed.
15:25:18 <Heffalump> next time I get a few hours to work on this, WASH goes.
15:25:22 <bringert> you can copy and paste from the above
15:25:33 <Heffalump> it'll be quicker to use string pattern matching :-)
15:25:59 <bringert> quicker than copying 7 lines of code?
15:26:03 <bringert> :-)
15:26:35 <bringert> I'm just trying to help you get to bed :-)
15:26:55 <Heffalump> yes ;-)
15:27:03 <Heffalump>         = do ('s':'c':'e':'n':'a':'r':'i':'o':'=':num) <- unsafe_io $ getEnv "QUERY_STRING"
15:27:06 <Heffalump>              scenario <- unsafe_io $ get_scen
15:27:09 <Heffalump> ario (read num)
15:27:15 <bringert> ah
15:27:25 <bringert> that is pretty quick
15:27:34 <Heffalump> sadly my DB reading seems to have an off-by-one error.
15:27:50 <Manyfold> we don't function declarations don't work on an interactive shell?
15:27:58 <Manyfold> in ghc
15:28:30 <Heffalump> use let
15:28:33 <Heffalump> let f x = ...
15:30:04 <Excedrin> Manyfold: http://www.haskell.org/hawiki/HaskellNewbie_2fHaskellInterpreterUsage
15:30:05 <lambdabot> Title: "HaskellNewbie/HaskellInterpreterUsage - The Haskell Wiki"
15:30:20 <Manyfold> thanks
15:33:27 <Heffalump> woo!
15:33:30 * Heffalump gets it working
15:35:41 <Heffalump> does anyone know where ICFP 2007 will be, btw?
15:36:05 <sieni> hopefully close to finland ^_^
15:36:15 <Heffalump> it was pretty close last year :-)
15:36:30 <sieni> Heffalump: unfortunately i missed that completely
16:01:55 <dons> moin
16:02:54 <cjay> moin :)
16:03:31 <palomer> @id moin
16:03:32 <lambdabot> moin
16:03:41 <palomer> what does "moin" mean?
16:04:08 <ruffneck> morning ?
16:04:55 <cjay> yes, it's from a german dialect
16:05:08 <ruffneck> true, and finnish have adopted it and say "moi"
16:05:19 <ruffneck> which is today actually a generic "hi" or "hello"
16:05:53 <cjay> many people in germany use it all the day, too
16:06:03 <ruffneck> looks like it's spreading ;P
16:06:12 <kosmikus> sure, it's a general greeting
16:08:06 <dons> mmm. fast wc/bytestring fan mail. i like, i like :)
16:09:15 <RyanT5000> vincenz, connection issues?
16:09:43 <vincenz> RyanT5000: laptop issues
16:09:47 <RyanT5000> ah
16:21:01 <dons> ?seen sjanssen 
16:21:02 <lambdabot> sjanssen is in #haskell. I last heard sjanssen speak 2 hours, 52 minutes and 20 seconds ago.
16:24:11 <vincenz> re
16:29:10 <AtnNn> Can anyone help me with HDBC? I keep getting "*** Exception: (unknown)" from connectDBC "DSN=mysql".
16:33:48 <jgrimes> AtnNn, can you paste the code somewhere?
16:34:12 <jgrimes> AtnNn, just the connect code for now
16:35:48 <lisppaste2> AtnNn pasted "HDBC-ODBC unknown exception" at http://paste.lisp.org/display/21847
16:35:54 <AtnNn> sure
16:39:26 <AtnNn> Prelude Database.HDBC.ODBC Data.IORef Database.HDBC> connectODBC "DSN=mysql"
16:39:33 <AtnNn> oops, wrong clipboard
16:40:11 <AtnNn> I mean, I pressed [ instead of ]
16:43:09 <jgrimes> AtnNn, I have no idea. 
16:45:07 <AtnNn> ok
16:57:57 <bringert> AtnNn: maybe there is some logging switch you can turn on in the mysql DSN
17:01:21 <AtnNn> dunno, i've never used odbc before, I just installed it with debian and changed the username/password/database in the default .ini, and the tools in unixodbc-bin require X
17:09:25 <bringert> AtnNn: arene't there any command line odbc tools in your unixodbc package?
17:10:12 <bringert> I find that it's better to start debugging these things with the ODBC tools directly, rather than having an extra haskell layer in between
17:13:45 <Lemmih> AtnNn: You can use handleSqlError to get sensible exceptions.
17:16:43 <AtnNn> Lemmih: ah, thats better, thanks
17:18:34 <DrR4n5ch6ur9J3n> is it possible to use the latest snapshot with visualhaskell plugin?
17:23:59 <sudoer> I'm reading a haskell tutorial, what does this mean?  layout is 2-dimensional
17:24:21 <vincenz> is there a scheme interpreter written in haskell?
17:24:29 <dons> that the indentation of the text on the page is significant, sudoer 
17:24:34 <Philippa_> in most programming languages, source code is fundamentally one-dimensional
17:24:43 <dons> so instead of using ';' to terminate expressoins, we use whitespace and indentation
17:24:45 <Philippa_> newline is "just another character"
17:24:54 <dons> (though ; is optional, if oyu wish)
17:25:01 <vincenz> dons: ever get my @tell?
17:25:08 <Philippa_> in Haskell, the (line, column) position of code is relevant due to the layout rule
17:25:14 <dons> vincenz: ah yes, now what was it? i thought i didn't need to respond.
17:25:17 <dons> vincenz: perhaps remind me?
17:25:18 <sudoer> oh like python?  I heard haskell  is similar to python in terms of indentation
17:25:25 <Philippa_> similar though not identical
17:25:32 <dons> yeah, python borrowed the idea, i think
17:25:38 <dons> though in not as general a form (?)
17:25:39 <Philippa_> IIRC the few times I've read a tutorial I've looked at the python rule and thought "yuck!" :-)
17:25:47 <Philippa_> and IIRC the generality was why
17:25:48 <bringert> vincenz: I've written an interpreter for a subset of Scheme at some point
17:25:51 <vincenz> dons: no was just curious on thoughts
17:25:52 <bringert> for a class
17:26:00 <vincenz> dons: it regarded equalizing the scales for those darcs graphs
17:26:03 <vincenz> bringert: interesting
17:26:04 <dons> ah yes.
17:26:16 <dons> its possible, but requires a small (1 line) hack to darcs graph
17:26:34 <dons> if you'd like to add the flag, to specify the y-range on the cmd line, i'll incorporate it
17:26:39 <dons> ?where darcs-graph
17:26:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/darcs-graph/
17:26:46 <dons> currently the yrange is [0:*]
17:26:51 <dons> but you want [0:n]
17:27:13 <dons> if you'd like, submit a patch, so we could say darcs-graph -ymax 50, for example
17:27:20 <dons> and have all scaled to 0-50, yeah?
17:27:26 * vincenz nods
17:27:32 <dons> do you want  to hack this up?
17:27:41 <vincenz> sure I can take a look
17:27:48 <dons> its a pretty quick hack, i think
17:27:52 <the_lord> @type lookup
17:27:54 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
17:28:08 <vincenz> dons: yep and will give me an opportunity to get into the ocde
17:28:10 <vincenz> code
17:28:46 <dons> vincenz: add a new flag, -y, say. pass it through to gnuplotScript, to generate the "set yrange [0:*]" line as [0:n]
17:28:48 <the_lord> @hoogle a -> [a] -> Bool
17:28:49 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
17:28:49 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
17:28:53 <vincenz> dons: yep
17:29:07 <the_lord> :)
17:29:20 <vincenz> dons: oy... your argument-code
17:29:22 <vincenz> @hoogle pack
17:29:23 <lambdabot> Data.PackedString.packString :: String -> PackedString
17:29:23 <lambdabot> Distribution.InstalledPackageInfo.package :: InstalledPackageInfo -> PackageIdentifier
17:29:23 <lambdabot> Distribution.PackageDescription.package :: PackageDescription -> PackageIdentifier
17:29:55 <dons> vincenz: yeah, perhaps it should use getopt at this point
17:30:12 <dons> or maybe not, depends on what you feel like
17:30:30 <dons> or maybe you are wondering about getArgs ;)
17:30:37 <vincenz> nah
17:30:52 <vincenz> I'm wondering about the
17:30:55 <vincenz> if flag  ...
17:30:57 <vincenz> else err
17:31:00 <vincenz> that allows one option
17:31:05 * vincenz shudders
17:31:19 <vincenz> @hoogle getARgs
17:31:20 <lambdabot> System.getArgs :: IO [String]
17:31:41 <dons> right. so maybe getopt is needed. have you used System.Console.GetOpt?
17:31:50 <vincenz> i believe so
17:31:53 <dons> though i'm perfectly happy for a little custom parser
17:31:55 <vincenz> for my compiler
17:32:37 <Cale> sudoer: yeah, unlike python, you can ignore the layout rule if you're willing to insert braces and semicolons
17:33:01 <dons> Cale, do we have an intro to layout on the wiki somewhere?
17:33:04 <Cale> sudoer: It's also possible to use semicolons and not braces, if you want to smash things on to one line
17:33:17 <dons> seems like it comes up a lot, and some demos would be appropriate
17:33:27 <Cale> dons: Yeah, that would be a good thing to have
17:33:42 <Cale> I don't think we do at the moment, but I might just be forgetting
17:33:52 <Cale> There's probably at least some talk about it
17:34:02 <dons> since i think ayout is easy to "get" visually, but less clear to explain
17:34:45 <Cale> The way I usually explain it is if something is "inside" something else, then it has to be indented more.
17:35:20 <dons> yeah, that's fairly good.
17:37:23 <Philippa_> I think the single most helpful thing you can actually do is look up which constructs have braces in the grammar
17:37:39 <Philippa_> my own indentation style seems to be a bit odd compared to most code I've read now?
17:37:46 <Philippa_> The fact I'm putting in the spaces by hand probably shows
17:38:05 <Cale> We should also have a page on how to configure various editors for writing Haskell code (esp. turning on "Expand tabs to spaces")
17:38:21 <vincenz> @type unlines
17:38:22 <lambdabot> [String] -> String
17:38:24 <fanopanik> M-x haskell-mode
17:38:26 <cjay> btw, is there a editor that does the automatic indentation right? I use vim and could not find a script for it that does what I want :|
17:38:34 <fanopanik> emacs! :)
17:39:02 <fanopanik> with TAB you can cycle through the meaningful indentations on a line
17:39:10 <dons> cjay: somewhat. vim does a little , let me find the vimscript magicks
17:39:31 <dons> this helps,
17:39:32 <dons> set comments=bO:--
17:39:32 <dons> set formatoptions=tcqr
17:39:41 <dons> so at least you'll get -- indented properly each time
17:39:44 <mauke> ctrl-d and ctrl-t help a lot
17:40:06 <Cale> I don't like emacs' choices for indentation usually, so I ended up turning off "smart" indent mode
17:40:16 <Cale> the "simple" indent mode is much nicer
17:40:19 <Cale> (imo)
17:40:39 * cjay tries
17:40:49 <dons> now, I wrote a vim indent script at one point, ftp://ftp.cse.unsw.edu.au/pub/users/dons/vim/indent/haskell.vim
17:40:54 <dons> however, it needs more work
17:40:59 <Cale> It's really frustrating when you hit tab a bunch of times and it just cycles through 3 or 4 options none of which is what you want
17:41:01 <dons> vimscript is a horrible language
17:41:14 <dons> i wrote yi, that's how sick it made me feel ;)
17:41:17 <Cale> hehe
17:41:35 <cjay> :D
17:41:48 <cjay> I tried some days ago, but couldn't get yi to compile
17:41:55 <the_lord> @hoogle foldl
17:41:56 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
17:41:56 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
17:41:56 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
17:42:00 <Cale> Which yi though?
17:42:08 <dons> hmm. should be very compilable. what error did you have? using curses yi?
17:42:20 <dons> its actually being actively hacked on at the moment.
17:42:26 <the_lord> @hoogle map
17:42:27 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
17:42:27 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
17:42:27 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
17:42:34 <dons> a guy in the uk is working on a vimacs mode, and some indenting support
17:42:36 <vincenz> dons: what is bracket
17:43:00 <Cale> @type bracket
17:43:02 <lambdabot> Not in scope: `bracket'
17:43:04 <dons> vincenz: its an exception handler that performs some actions after its argument is evaluated, whether it throws an exception or not
17:43:08 <Cale> @type System.IO.bracket
17:43:09 <lambdabot> Not in scope: `System.IO.bracket'
17:43:10 <vincenz> dons: ah cool
17:43:11 <Cale> er
17:43:14 <Cale> hehe
17:43:14 <dons> @type Control.Exception.bracket
17:43:16 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:43:18 <Cale> right
17:43:19 <vincenz> dons: also, what type is mfilter?
17:43:21 <vincenz> Maybe ...
17:43:23 <dons> so we use it to allocate and release the temp files
17:43:41 <cjay> dons: something about a undefined thing.. but the imports in the file were correct. just a moment, I will try to reproduce the error
17:43:44 <dons> which is kind of nice, since even if an io error occurs, we'll clean up the temp files
17:43:55 <vincenz> Maybe xxx
17:43:56 <dons> cjay: perhaps fps versoin?
17:44:07 <cjay> maybe. I took latest fps from darcs
17:44:20 <dons> should be ok then.
17:44:22 <vincenz> @hoogle pack
17:44:22 <lambdabot> Data.PackedString.packString :: String -> PackedString
17:44:23 <lambdabot> Distribution.InstalledPackageInfo.package :: InstalledPackageInfo -> PackageIdentifier
17:44:23 <lambdabot> Distribution.PackageDescription.package :: PackageDescription -> PackageIdentifier
17:44:27 <dons> ghc 6.4.2?
17:44:40 <dons> ?type Data.ByteString.pack
17:44:41 <lambdabot> [Word8] -> Data.ByteString.Base.ByteString
17:44:47 <dons> ?type Data.ByteString.Char8.pack
17:44:49 <lambdabot> String -> Data.ByteString.Base.ByteString
17:45:12 <vincenz> ah, bytestring
17:45:19 <dons> si
17:45:23 <vincenz> last question
17:45:38 <vincenz> assume : data A = X a | Y b
17:45:49 <vincenz> quick way of [A] -> Maybe a
17:46:42 <dons> @hoogle [a] -> Maybe a
17:46:43 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
17:46:43 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
17:46:53 <dons> so maybe something from Maybe?
17:46:58 <vincenz> hmm
17:47:09 <kpreid> vincenz: do you mean [a] -> [Maybe a]?
17:47:12 <vincenz> kpreid: nope
17:47:13 <kpreid> er
17:47:18 <vincenz> nope
17:47:20 <vincenz> not either Maybe [a]
17:47:28 <vincenz> I'll do it like this
17:47:29 <kpreid> so you want the first X in the [A]?
17:47:48 <vincenz> let l' = [x | (X x) <- l] in if null l' then Nothing else Maybe (head l')
17:48:33 <lisppaste2> cjay pasted "yi 0.1.0 build error" at http://paste.lisp.org/display/21851
17:49:05 <dons> oh, maybe try yi from darcs?
17:49:33 <cjay> tried that too, had another error. wait a minute
17:49:57 <dons> the error above is because it requires hs-plugins 0.9.6, iirc
17:50:01 <kpreid> > (\l -> listToMaybe [x | (Left x) <- l]) [Left 1, Right 2, Left 3]
17:50:02 <lambdabot>  Just 1
17:50:06 <kpreid> vincenz:
17:50:11 <dons> but it'd be easier to start with the darcs repo of yi
17:50:22 <dons> i should tag it soon, there's been more than a year of hacking on it
17:50:49 <vincenz> @hoogle isNothing
17:50:49 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
17:50:50 <cjay> dons: gentoo's hs-plugins-1.0_rc0 is installed
17:51:15 <dons> yeah, that's too new. but don't worry. try the yi darcs repo
17:51:36 <Cale> Does it parse Haskell yet? :)
17:51:41 <vincenz> dons: done
17:51:42 <cjay> dons: I think I took it from gentoo bugzilla. I'm on amd64..
17:51:42 <vincenz> dons: testing
17:51:51 <vincenz> dons: hwo do I compile?
17:52:23 <dons> vincenz: its cabalised. so $ grep '\$' README  ;)
17:52:29 <vincenz> cannot satisfy dependency fps>=0.7
17:52:30 <vincenz> doh
17:52:47 <vincenz> @where fps
17:52:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
17:52:55 <dons> yep, i try to infect all my projects with dependencies on all the other ones
17:53:00 <dons> its a weakness
17:53:14 * vincenz kicks dons in the nuts
17:53:18 <vincenz> dons: why the necessity here/
17:53:19 <Cale> heh
17:53:21 <dons> yow!
17:53:21 <vincenz> String would've been fine
17:53:27 <lisppaste2> cjay pasted "yi (from darcs) build error" at http://paste.lisp.org/display/21852
17:53:34 <dons> i needed strict file io, iirc
17:53:34 <vincenz> lol
17:53:39 <vincenz> getPartial of fps = 358 patches
17:53:48 <dons> ah, no, some darcs repos are _huge_
17:53:55 <Cale> It's only because dons does all the coding which everyone knows needs to be done but nobody is willing to go through the hell of coding :)
17:54:02 <dons> so doing string io was way too slow, on e.g. 10 years of ghc patches
17:54:07 <vincenz> dons: erm, ghc has less patches
17:54:16 <vincenz> partially
17:54:18 <dons> have you seen the darcs graph? 18k patches
17:54:19 <vincenz> might wanna optimize
17:54:31 <vincenz> dons: --partial gave me 358 to download from fps
17:54:45 <dons> anyway, i started with string io, and switched once it got tediously annoyingly slow
17:54:48 <dons> vin	sounds right
17:54:50 <dons> its about to be tagged.
17:54:54 <vincenz> cool
17:55:01 <vincenz> what does tagging do?
17:55:18 <vincenz> besides set a a tag
17:55:18 <dons> tag ; then optimise --checkpoint
17:55:25 <dons> so --partial is nice
17:55:55 <the_lord> @hoogle Char -> Bool
17:55:56 <lambdabot> Char.isAlpha :: Char -> Bool
17:55:56 <lambdabot> Char.isAlphaNum :: Char -> Bool
17:55:56 <lambdabot> Char.isAscii :: Char -> Bool
17:56:00 <vincenz> optimise is related to tagging?
17:56:12 <the_lord> @hoogle isNum
17:56:12 <lambdabot> No matches found
17:56:37 <cjay> oh wait, I messed around with the code to fix the error and didn't revert. build successful now
17:58:45 <vincenz> dons: done
17:59:25 <vincenz> odd
17:59:28 <vincenz> nothing is there
17:59:37 <vincenz> when I do a build
18:00:28 <vincenz> dons: it compiles fine but I get no binary
18:00:34 <dons> cjay: so yi/darcs builds?
18:00:45 <dons> vincenz: did you install? or is it in dist/build/*
18:00:52 <vincenz> dons: nothing
18:01:02 <dons> old cabal/ghc?
18:01:06 <cjay> dons: yes, it works now, thanks :)
18:01:10 <vincenz> 6.4
18:01:11 <dons> cool
18:01:28 <dons> hmm. maybe 6.4/cabal doesn't know whow to build executables yet. only library archives
18:01:32 <cjay> can yi do some automatic indenting?
18:01:37 <vincenz> dons: ok I'll submit
18:01:40 <vincenz> dons: presumably it works
18:01:43 <vincenz> it compiles at least :)
18:01:45 <dons> cjay: i think the new vimacs mode does slightly, but in general, no.
18:01:48 <dons> its a todo
18:02:15 <dons> vincenz: well, you can always compile by hand
18:02:18 <dons> ghc --make
18:02:22 <cjay> hum
18:02:23 <dons> or even run it in ghci
18:02:39 <Philippa_> things that build with a simple ghc --make are good
18:02:45 <vincenz> dons: heh, could not find gnuplot
18:02:48 <vincenz> Philippa_: I agree
18:03:08 * vincenz installs gnuplot
18:03:14 <dons> yep. i learnt my lesson with makefiles and crazywackjob build systems long ago
18:03:56 <vincenz> dons: works
18:04:10 <vincenz> dons: maybe some day you can tell me how to use cabal
18:04:13 * vincenz uses makefile for his compiler
18:04:17 <vincenz> although no dependencies
18:04:27 <vincenz> so I gotta remove the binary to force recompile
18:04:29 <dons> ok good stuff. darcs send and i'll tweak my community-graph script to use your new flag
18:04:44 <dons> cabal is easy-peasey
18:04:59 <vincenz> blegh
18:05:06 <vincenz> I'm not adding my name in the file for this stupid change
18:05:09 <dons> check darcs-graph.cabal, that's the lot
18:05:12 <dons> ok.
18:05:20 <the_lord> checkState :: [String] -> Bool
18:05:20 <the_lord> checkState lista = foldl (&&) True (map isAlpha (map head lista))
18:05:30 <the_lord> is there another way to do that?
18:05:49 <dons> foldl (&&) == all?
18:05:53 <vincenz> hm
18:06:03 <vincenz> anyone know how to change password in thunderbird
18:06:18 <the_lord> @hoogle all
18:06:19 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
18:06:20 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
18:06:20 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
18:06:41 <dons> all p                   =  and . map p, and []      =  True
18:06:41 <dons> and (x:xs)  =  x && and xs
18:06:55 <dons> all isAlpha (map head lista)
18:08:07 <the_lord> dons: thx
18:09:00 <the_lord> other question, I'm doing an Interpreter, and I need to print an Error message if that Function gives me False, how can I do that?
18:09:35 <dons> error "there was an error" ?
18:09:46 <dons> or hPutStr stderr "error, dude"
18:10:22 <dons> or just, as long as you're in IO, print "something bad happened"
18:10:40 <the_lord> yes, but how do I ask if the function returns true?
18:10:40 <mauke> putStrLn
18:10:49 <vincenz> dons: sent
18:11:04 <dons> the_lord: test it using a boolean test, such as a guard, an if-then-else, or a case
18:11:15 <mauke> if foo x then putStr "o noes\n" else whatever
18:11:20 <mauke> where whatever = return ()
18:11:20 <vincenz> dons: lemme know if you have probs
18:11:27 <dons> let x = result of my function ; when (not x) $ fail "there was an error" -- even
18:11:32 <the_lord> let me test it
18:11:39 <dons> vincenz: ok. cheers
18:11:53 <vincenz> I remember issues last time with the patch-file
18:12:01 <vincenz> @paste
18:12:01 <lambdabot> http://paste.lisp.org/new/haskell
18:12:03 <vincenz> \o/
18:13:04 <vincenz> heh
18:13:06 <vincenz> it's fascinating
18:13:11 <vincenz> darcs is really being used in more and more places
18:13:15 <vincenz> even other pl
18:13:40 <vincenz> dons: have any experienec with performing flow analyses?
18:13:49 <dons> no, sorry.
18:16:36 <vincenz> I'm mostly stuck on how to do it in haskell
18:16:40 <vincenz> overlaying my AST with a graph
18:16:56 <vincenz> dons: patch worked?
18:17:16 <dons> just checking...
18:17:21 <dons> it arrived, yes.
18:18:29 <the_lord> @hoogle [a] -> Bool
18:18:31 <lambdabot> Prelude.null :: [a] -> Bool
18:18:31 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
18:18:31 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
18:19:49 <dons> vincenz: it applies ok.
18:19:57 <vincenz> dons: coo
18:20:03 <vincenz> then I'm off to sleep
18:20:04 <vincenz> ca
18:20:05 <vincenz> cya
18:20:12 <dons> Could not find module `System'. bad vincenz using h98 ;)
18:20:13 * vincenz grrs at his indirect rendering and laggy typing
18:20:16 * dons fixes
18:20:26 <vincenz> o.O
18:20:35 <vincenz> what module should it be?
18:20:51 <dons> System.Environment
18:20:53 <vincenz> according to GHC hierarchical docs it's there
18:20:56 <dons> @index getArgs
18:20:56 <lambdabot> System.Environment
18:21:01 <vincenz> ah
18:21:05 <dons> sure, but i need to link against -pcakage haskell98, to get it.
18:21:13 * vincenz doesn't
18:21:17 <dons> which is not a dep in the .cabal file (makes the code a bit bigger)
18:21:22 <dons> you get it for free if you use --make
18:21:28 <vincenz> oh
18:21:57 <dons> no biggy.
18:22:07 <vincenz> okies
18:22:09 <vincenz> well I'm off
18:22:17 <vincenz> if you have comments on the code, feel free to @tell
18:22:20 <dons> ok. cool
18:23:17 <dons> works nicely.
18:36:47 <sudoer> are monads used elsewhere besides haskell?
18:37:39 <Philippa_> not as extensively, although ML and Scheme coders are starting to use them and they can be expected to crop up in designs for other pure functional languages
18:37:59 <the_lord> @hoogle Bool -> Bool
18:38:00 <lambdabot> Prelude.not :: Bool -> Bool
18:38:00 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
18:38:00 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
18:38:59 <dons> they've been ported to at least ruby and C++ as well, though these might not be comforatble environments for such a high level abstraction
18:44:27 <the_lord> machineVerifier :: [String] -> Bool
18:44:27 <the_lord> machineVerifier s = if edosT then error "Blah Blah" else True
18:44:42 <the_lord> that does'nt works
18:44:48 <the_lord> *doesn't
18:45:40 <the_lord> :(
18:48:22 <lispy> the_lord: what are you trying to do?
18:49:08 <the_lord> I want to see if all the Strings in the list start with alpha
18:49:20 <lispy> dons: java has monads now two, iirc at least two implmenetations have cropped up
18:49:39 <the_lord> if not, print error and tell which ones don't start with alpha
18:50:05 <lispy> ah, error throws an exception so it's probably not what you want to call at such a low level
18:50:25 <the_lord> lispy: how do I do it?
18:50:54 <lispy> let's start with a single string
18:51:01 <lispy> can you solve that case?
18:51:14 <the_lord> nope
18:51:23 <the_lord> lispy: gives me the same thing
18:51:55 <the_lord> me and IO in haskell don't match
18:51:59 <lispy> try to define this: checkString :: String -> Bool
18:52:05 <the_lord> lispy: help please
18:52:19 * lispy is trying to help
18:52:44 * the_lord is listening closely
18:52:45 <dons> > let f = all isalpha . map head in f ["haskell","foo"]
18:52:45 <lambdabot>  Not in scope: `isalpha'
18:52:52 <dons> > let f = all isAlpha . map head in f ["haskell","foo"]
18:52:53 <lambdabot>  True
18:53:17 <dons> > let f = all isAlpha . map head in if f ["haskell","foo","%890"] then True else error "nope"
18:53:19 <lambdabot>  Exception: nope
18:53:27 <the_lord> > let f = all isAlpha . map head in f ["1haskell","foo"]
18:53:28 <lambdabot>  False
18:53:28 <dons> > let f = all isAlpha . map head in if f ["haskell","foo","xyz890"] then True else error "nope"
18:53:30 <lambdabot>  True
18:54:00 <the_lord> dons: I want to list the ones that begin without alpha
18:54:21 <the_lord> dons: sorry print them
18:54:53 <lispy> dons: i don't think isAlpha is exactly the function the_lord needs to use
18:55:04 <lispy> dons: i think he wants to check if the first char is alpha
18:55:18 <lispy> @type isAlpha
18:55:20 <lambdabot> Char -> Bool
18:55:25 <lispy> oh
18:55:27 <lispy> n/m
18:55:38 <the_lord> lispy: yes, that's the function
18:56:05 <the_lord> I made a function that gives me all the strings that do not start with alpha
18:56:27 <the_lord> what I want to do is return True if the list is empty
18:56:41 <the_lord> or error "blah blah" if not
18:57:00 <the_lord> and in the blah blah, I give all those strings
18:57:15 <the_lord> Couldn't match `[Char]' against `Bool'
18:57:28 <the_lord> that's what ghci gives me if I try
18:57:49 <dons> > let f = all (not.isAlpha) . map head; ss = ["haskell","foo","xyz890"] in if f ss then True else error . show (filter (not.isAlpha.head) ss)
18:57:50 <lambdabot>    Expecting a function type, but found `[Char]'
18:57:50 <lambdabot>    Expected type: a -> ...
19:00:22 <the_lord> set, my bad
19:00:30 <dons> > let f = all (not.isAlpha) . map head; ss = ["haskell","foo","xyz890"] in if f ss then True else error $ show . filter (not.isAlpha.head) $ ss
19:00:31 <lambdabot>  Exception: []
19:00:42 <dons> > let f = all (not.isAlpha) . map head; ss = ["haskell","foo","890xyz"] in if f ss then True else error $ show . filter (not.isAlpha.head) $ ss
19:00:44 <lambdabot>  Exception: ["890xyz"]
19:00:51 <dons> orsomething like that. play with it, learn :)
19:01:04 <lispy> a list comprehension is probably the easiest way to do it
19:01:19 <lispy> you could retrun two lists
19:01:46 * lispy goes to workout, bbl
19:02:38 <the_lord> dons: thx
19:03:23 <the_lord> lispy: thx
19:09:50 <the_lord> machineVerifier :: [String] -> Bool
19:09:50 <the_lord> machineVerifier s = if edosT then error ("Los Estados " ++ "( " ++ (concat (intersperse ", " checkEdos))  ++ " ) de la Maquina " ++ "a" ++ " empiezan por caracteres numericos") else True
19:09:50 <the_lord>                 where {edosT = not (null checkEdos); checkEdos = checkState s }
19:10:11 <the_lord> dons: how about that?
19:10:27 <the_lord> checkState :: [String] -> [String]
19:10:27 <the_lord> checkState [] = []
19:10:27 <the_lord> checkState (s:xs) = if isAlpha (head s) then [] ++ rest else [s] ++ checkState rest
19:10:27 <the_lord>                      where {rest = checkState xs}
19:13:44 <dons> well, its a bit confusing with the recursion. how about
19:13:45 <dons> checkState ss = [ s | s@(h:_) <- ss, not (isAlpha h) ]
19:22:44 <the_lord> dons: I've rewritten it to checkState s = filter (not.isAlpha.head) s
19:29:16 <the_lord> @hoogle [a] -> a
19:29:17 <lambdabot> Prelude.head :: [a] -> a
19:29:17 <lambdabot> Prelude.last :: [a] -> a
19:29:17 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
19:32:02 <mwolak> If I'm being bitten by the state-hack thing, is there a way to refactor so that I don't have to use -fno-state-hack?
19:33:13 <dons> state-hack? hmm. tricky. how did you get into this situation?
19:33:27 <dons> primop gmes?
19:33:29 <dons> games
19:35:03 <dons> i've never heard of state-hack being an issue, are you sure that's the probem?
19:35:05 <mwolak> I though it was because I was using sequence_ $ replicate iters stepFun
19:35:08 <mwolak> yeah
19:35:34 <mwolak> speed goes WAAAAAY down if I turn on -O without also putting on -fnostate-hack
19:35:54 <Lemmih> Tried replicateM_?
19:36:06 <mwolak> didn't try that
19:36:10 <mwolak> @hoogle replicateM_
19:36:11 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
19:36:28 <mwolak> sounds like exactly what I want :)
19:36:30 <dons> interesting. sounds almost bug worthy.
19:36:36 <dons> bug-report worthy
19:37:15 <mwolak> the other thing that made me suspect it is because timingwise I can tell that it's re-creating the Big Lookup Table once for each iteration
19:37:46 <mwolak> OK, I'll put one in tomorrow
19:37:59 <Lemmih> Is it a -O or -fvia-c thing?
19:38:37 <mwolak> I think -via-c by itself didn't do it, but I can't be certain that I tried that
19:39:00 <Lemmih> Try -O -fasm.
19:39:10 <mwolak> (unfortunately, I don't have access to the code from home, or access to IRC from work :/)
19:39:48 <mwolak> but I do know that -O -fno-state-hack works fine
19:55:38 <lispy> state-hack, nice name
20:23:16 <the_lord> @hoogle a -> [a] -> Bool
20:23:17 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
20:23:17 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
20:24:09 <AtnNn> Is it normal that hdbc-odbc's quickQuery returns all the columns of my mysql tables as SqlStrings, even those that are INT?
20:35:09 <the_lord> @hoogle Set
20:35:10 <lambdabot> Data.Set :: module
20:35:10 <lambdabot> Data.Set.Set :: data Set a
20:35:10 <lambdabot> Distribution.Setup :: module
20:35:27 <the_lord> @hoogle [a] -> Set a
20:35:28 <lambdabot> Data.Set.fromDistinctAscList :: [a] -> Set a
20:35:28 <lambdabot> Data.Set.fromAscList :: Eq a => [a] -> Set a
20:35:28 <lambdabot> Data.Set.fromList :: Ord a => [a] -> Set a
20:38:41 <the_lord> @hoogle Set a -> [a]
20:38:42 <lambdabot> Data.Set.elems :: Set a -> [a]
20:38:43 <lambdabot> Data.Set.setToList :: Set a -> [a]
20:38:43 <lambdabot> Data.Set.toAscList :: Set a -> [a]
20:39:08 <the_lord> @hoogle [a] -> Bool
20:39:10 <lambdabot> Prelude.null :: [a] -> Bool
20:39:10 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
20:39:10 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
20:46:55 <Korollary> @type nub
20:47:33 <Korollary> @type nub
20:47:40 <Korollary> @type Data.List.nub
20:47:50 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:47:56 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:47:58 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:48:03 <Korollary> heh
20:48:56 <Korollary> the_lord: you can use nub to remove duplicates, then compare the length against that of the original.
20:49:16 <the_lord> Korollary: yes, that's what I'm doing, thx
20:54:01 <the_lord> @hoogle all
20:54:02 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
20:54:02 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
20:54:02 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
21:13:26 <the_lord> @hoogle (a,b) -> c -> (a,b,c)
21:13:28 <lambdabot> No matches, try a more general search
21:13:44 <the_lord> @hoogle a -> b -> c -> (a,b,c)
21:13:45 <lambdabot> No matches, try a more general search
21:13:54 <the_lord> @hoogle a -> b -> (a,b)
21:13:55 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
21:13:56 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
21:14:06 <Korollary> @type (,)
21:14:07 <lambdabot> forall b a. a -> b -> (a, b)
21:14:25 <Korollary> @type (,,)
21:14:26 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
21:15:11 <palomer> @type (,,,,,,,,,)
21:15:13 <lambdabot> forall j i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a, b, c, d, e, f, g, h, i, j)
21:15:32 <palomer> @type [,]
21:15:34 <lambdabot> parse error on input `,'
21:15:42 <palomer> ([,]) should be a function
21:15:45 <palomer> says I!
21:15:59 <palomer> so should <,,,,,,>
21:16:48 <the_lord> thx
21:16:50 <the_lord> :)
21:17:23 <the_lord> Char does not derive from Show?
21:18:13 <the_lord> @hoogle char
21:18:14 <lambdabot> Text.ParserCombinators.ReadP.char :: Char -> ReadP Char
21:18:15 <lambdabot> Text.PrettyPrint.HughesPJ.char :: Char -> Doc
21:18:15 <lambdabot> Text.ParserCombinators.Parsec.Char.char :: Char -> CharParser st Char
21:18:18 <the_lord> @hoogle Char
21:18:19 <lambdabot> Char :: module
21:18:19 <lambdabot> Data.Char :: module
21:18:19 <lambdabot> Text.ParserCombinators.Parsec.Char :: module
21:18:27 <the_lord> @type Char
21:18:28 <lambdabot> Not in scope: data constructor `Char'
21:18:32 <the_lord> @help
21:18:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:18:39 <the_lord> @help list
21:18:39 <lambdabot> list [module|command]
21:18:40 <lambdabot> show all commands or command for [module]
21:18:53 <the_lord> @list
21:18:53 <palomer> @kind Char
21:18:54 <lambdabot> list [module|command]. Where modules is one of:
21:18:54 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
21:18:54 <lambdabot> topic type unlambda url version vixen where
21:18:55 <lambdabot> *
21:19:26 <palomer> @palomer
21:19:27 <lambdabot> Hrmph, looks like I killed the channel
21:20:05 <the_lord> @help hoogle
21:20:05 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
21:20:09 <Korollary> > show 'c'
21:20:11 <lambdabot>  "'c'"
21:20:23 <palomer> > let x = show x in x
21:20:25 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:20:30 <palomer> looks oddly familiar...
21:20:39 <palomer> I still don't get how that works, though
21:20:39 <JKnecht> wrt HNOP, is Hat or something going to use it?
21:22:11 <the_lord> > 'c' == 'c'
21:22:12 <lambdabot>  True
21:22:19 <the_lord> > True
21:22:21 <lambdabot>  True
21:22:34 <sjanssen> JKnecht: I don't get HNOP . . .
21:22:40 <Cale> palomer: well, look at the 'show' for strings?
21:22:55 <Cale> palomer: it quotes the string, and escapes any quotes in it
21:23:08 <Cale> > show "abcd\"ef"
21:23:09 <lambdabot>  "\"abcd\\\"ef\""
21:23:19 <Cale> hehe
21:23:21 <sjanssen> is HNOP some kind of odd joke?
21:23:31 <the_lord> > show ['a','b']
21:23:33 <lambdabot>  "\"ab\""
21:24:00 <JKnecht> Haskel No Operation. Posted to mail list a few hours ago. Saw discussion prior to that, perhaps same place.
21:24:48 <sjanssen> JKnecht: saw the post on the ML, there was discussion in the channel about it?
21:24:50 <JKnecht> And no not a joke, many languages have this construct. Am curious about special import for Haskell.
21:25:09 <Korollary> @google HNOP
21:25:12 <lambdabot> http://xray.bmc.uu.se/hicup/comp/H_N_O_P_comp.html
21:25:12 <lambdabot> Title: "Hetero compounds with composition H N O P"
21:25:31 <dons> ?where+ hnop http://semantic.org/hnop/
21:25:31 <lambdabot> Done.
21:25:37 <palomer> Cale: well, that brings me closer to enlightenment
21:25:52 <palomer> > show "\a"
21:25:53 <lambdabot>  "\"\\a\""
21:25:55 <JKnecht> http://semantic.org/hnop.tar.gz is the stuff
21:26:02 <palomer> oh, and then it escapes the escapes
21:26:18 <sjanssen> it's just main = return ()
21:26:26 <palomer> how long did it take us to figure out what v was?
21:26:27 <sjanssen> what is release worthy about this?
21:26:42 <dons> sjanssen: that code's copyright Ashley Yakeley, did you get permission to post?  ;)
21:27:10 <sjanssen> dons: oh no!  is that use covered under "simple permissive license"?
21:27:35 <dons> i'm not sure. some other languages have a the 'minimal' program as a library/relased package like this. though i've never had cause to use such a thing
21:27:37 * sjanssen reads the license
21:28:11 <dons> sjanssen: how's the coding going?
21:28:51 <sjanssen> dons: decent, should have patches tomorrow
21:28:59 <dons> good good
21:29:23 <dons> @tell vincenz graphs scaled and ttf fontified, http://www.cse.unsw.edu.au/~dons/images/commits/community/
21:29:24 <lambdabot> Consider it noted.
21:29:41 <sjanssen> dons: oh, and how do I install fps on GHC 6.5 (conflicts with the base package)
21:30:22 <dons> you have to remove it from the base package first
21:30:40 <the_lord> @hoogle [Char] -> [String]
21:30:42 <lambdabot> No matches, try a more general search
21:30:49 <dons> by manually deleteing the Data.ByteString stuff from libraries/base, and removing it from the makefile and .cabal files in base/
21:30:53 <the_lord> how do I do that?
21:31:09 <dons> @hoogle [a] -> [[a]]
21:31:10 <lambdabot> List.inits :: [a] -> [[a]]
21:31:10 <lambdabot> List.tails :: [a] -> [[a]]
21:31:10 <lambdabot> List.group :: Eq a => [a] -> [[a]]
21:31:21 <dons> @hoogle+
21:31:22 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
21:31:41 <sjanssen> dons: so I'll need to rebuild ghc?
21:33:51 <dons> just the base library. and then reinstall
21:34:06 <dons> i.e. cd libraries/base ; edit ; make ; cd ../.. ; make install
21:34:22 <the_lord> @hoogle Char -> String
21:34:23 <dons> the benefit is that with ghc 6.5 everything runs faster :)
21:34:23 <lambdabot> Network.URI.escapeURIChar :: (Char -> Bool) -> Char -> String
21:34:38 <dons> the_lord: what kind of function are you looking for?
21:34:39 <the_lord> @hoogle a -> [a]
21:34:41 <lambdabot> Prelude.repeat :: a -> [a]
21:34:41 <lambdabot> List.intersperse :: a -> [a] -> [a]
21:34:41 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
21:35:05 <dons> @hoogle+ for more matches
21:35:06 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
21:35:06 <lambdabot> Prelude.replicate :: Int -> a -> [a]
21:35:06 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
21:35:17 <the_lord> dons: I want to convert this ['a', 'b'] to ["a", "b"]
21:35:30 <dons> > map (:[])  ['a', 'b']
21:35:32 <lambdabot>  ["a","b"]
21:36:04 <the_lord> dons is smart
21:36:19 <Korollary> @karma+ dons
21:36:20 <lambdabot> dons's karma raised to 37.
21:36:32 <the_lord> > take 1 (repeat 'a')
21:36:34 <lambdabot>  "a"
21:36:35 <lispy> does gtk2hs use gtk1 or gtk2 normally?  a friend is trying to learn haskell and wants to make something gui
21:36:37 <the_lord> :D
21:37:00 <dons> gtk2,  hence gtk2-hs :)
21:37:06 <lispy> > let donskarma = 37 in take donskarma (repeat 'a') 
21:37:07 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
21:37:20 <Korollary> dons: It could be gtk-to-hs ;)
21:37:27 <dons> it could be, true
21:37:30 <dons> @karma-list
21:37:31 <lambdabot> Unknown command, try @list
21:37:36 <dons> @karma-all
21:37:37 <lambdabot>  dons                   37
21:37:37 <lambdabot>  shapr                  18
21:37:37 <lambdabot>  Lemmih                 17
21:37:37 <lambdabot>  lambdabot              15
21:37:37 <lambdabot>  xerox                  15
21:37:39 <lambdabot> [161 @more lines]
21:37:44 <dons> work harder!
21:37:48 <lispy> hehe
21:38:06 <dons> @more
21:38:06 <lambdabot>  dcoutts                12
21:38:07 <lambdabot>  Cale                   11
21:38:07 <lambdabot>  musasabi               10
21:38:07 <lambdabot>  SamB                    9
21:38:07 <lambdabot>  sjanssen                9
21:38:08 <lambdabot> [156 @more lines]
21:38:34 <lorne> > let donskarma = 37 in ((. repeat) . take) donskarma 'a'
21:38:35 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
21:38:43 * lorne bows before 'pl'
21:39:07 <Korollary> Cale is way under-karma'ed
21:39:15 <dons> yeah
21:39:22 <dons> the newbies don't know to karma+ him
21:39:44 <dons> we should spot that, and up his karma when he's thanked for the tutorials and lectures and so forth
21:40:07 <lispy> true
21:40:30 <RyanT5000> hm, i definitely owe Cale some karma
21:40:51 * Korollary wonders why he hadn't read Spineless Tagless G-Machine before.
21:41:40 * lispy bumps up cale's karma since he ought to have by now
21:41:44 <lispy> @karma+ Cale
21:41:44 <lambdabot> Cale's karma raised to 12.
22:00:25 <Korollary> wow. "Pessimal"
22:00:32 <Korollary> didn't know that word
22:03:17 <Cale> It's in OED :)
22:03:27 <Korollary> OED?
22:03:40 <Cale> The Oxford English Dictionary
22:03:53 <lispy> @dict pessimal
22:03:53 <lambdabot> Supported dictionary-lookup commands:
22:03:54 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
22:03:54 <lambdabot> Use "@dict-help [cmd...]" for more.
22:04:04 <Korollary> It;s not in merriam webster online
22:04:18 <lispy> @all-dicts pessimal
22:04:20 <lambdabot> *** "pessimal" gcide "The Collaborative International Dictionary of English v.0.48"
22:04:20 <lambdabot> pessimal \pes"si*mal\ adj.
22:04:20 <lambdabot>   Least favorable for survival; -- of an organism's
22:04:20 <lambdabot>   environment.
22:04:20 <lambdabot>  
22:04:22 <lambdabot> [29 @more lines]
22:04:41 <Korollary> I am guessing it's british
22:04:53 <Cale> It's just uncommon
22:05:04 <lispy> i bet Korollary is right
22:05:21 <lispy> it just sounds unamerican
22:05:35 <Korollary> cambridge online doesn't have it, either
22:05:43 <Cale> It's an obvious construction from Latin, but I think it's relatively new.
22:05:46 <Saulzar> Those pessimal Americans
22:05:51 <lispy> pessimal is the most pessimal word i've seen in american english
22:06:24 <Saulzar> I've never heard it either, though I would guess it from pessimistic.
22:06:41 <Philippa_> something of a case of "well, we use optimal..."
22:06:45 <Cale> Yeah, it was used first in 1921, it seems, and there are also quotes from 1960, 1977, 1987, and 2001
22:07:12 <Cale> I suppose optimal isn't that much older
22:07:16 <lispy> i wonder if you could get a google whack using pessimal
22:07:29 <Korollary> Hah
22:07:42 <Korollary> a character in Discworld is named Lance-Constable A.E. Pessimal
22:07:53 <Cale> pessimum goes back to 1828
22:08:40 <Cale> which is actually slightly older than the quotes for optimum even
22:08:42 <Cale> hmm
22:09:00 <Cale> at least in English
22:09:07 <Cale> They're both Latin words.
22:09:45 <Cale> minimum goes back to the 1600's
22:10:05 <Cale> well, depending on the sense
22:10:33 <RyanT5000> how expensive are MVars?
22:10:36 <lispy> in a minimal sense?
22:10:43 <lispy> RyanT5000: $0.02
22:10:47 <RyanT5000> oh wait they're not what i want anyway
22:10:56 <RyanT5000> i really want a custom box
22:11:02 <Cale> RyanT5000: they're not that expensive
22:11:11 <RyanT5000> where any thread that tries to evaluate it has to wait until something is put in it
22:11:17 <RyanT5000> the point here is for a file cache
22:11:22 <Cale> that would be like an MVar
22:11:28 <RyanT5000> yeah, except you can only take an MVar once
22:11:35 <lispy> heh, yeah sounds like you described an MVar to me :)
22:11:36 <Cale> you can peek it too
22:11:41 <RyanT5000> hm
22:11:44 <RyanT5000> maybe that's appropriate
22:11:47 <lispy> does peeking block tho?
22:12:02 <Saulzar> What value would it give you otherwise?
22:12:10 <RyanT5000> lispy: it would have to if the mvar is empty
22:12:15 <RyanT5000> but since mine will never be (once they're filled)
22:12:17 <Cale> oh, perhaps you can't
22:12:27 <Cale> no, you can
22:12:30 <Cale> readMVar
22:12:33 <RyanT5000> yah
22:12:58 <RyanT5000> how come MVar is in Control.Concurrent anyway?
22:13:08 <RyanT5000> it should be in Data.MVar just like Data.IORef, shouldn't it?
22:13:18 <RyanT5000> i don't see the difference
22:13:36 <lispy> perhaps it's re-exported?
22:13:38 <RyanT5000> (i mean obviously they're different things, but i don't see how an IORef is more of a "data" than an MVar)
22:13:40 <lispy> @hoogle MVar
22:13:41 <lambdabot> Control.Concurrent.MVar :: module
22:13:41 <lambdabot> GHC.Conc.MVar :: data MVar a
22:13:41 <lambdabot> Control.Concurrent.STM.TMVar :: module
22:13:44 <the_lord> bye, thx for the help
22:13:50 <RyanT5000> lispy: no, there's no Data.MVar
22:13:52 <lispy> the_lord: good luck
22:13:54 <Cale> It's part of the concurrency libs
22:14:00 <RyanT5000> although i guess really maybe it's IORef that's in the wrong place
22:14:08 <RyanT5000> yeah, i think IORef should be in System.IO.IORef
22:14:08 <the_lord> lispy: thx, same to you
22:14:17 <Cale> IORefs were never really intended for concurrency
22:14:23 <RyanT5000> yah i know
22:14:28 <RyanT5000> but they aren't really a datastructure either
22:14:35 <Cale> sure they are :)
22:14:42 <RyanT5000> not any more than an MVar
22:14:55 <Cale> Data.MVar wouldn't be too far off
22:15:15 <RyanT5000> they're an opaque datastructure that doesn't store any useful data beyond its contents
22:15:21 <RyanT5000> that's what i call "not a datastructure" :P
22:15:41 <Cale> They're a somewhat trivial datastructure :)
22:15:41 <Saulzar> Difference is that IORef are more commonly used, they're at a "top level" ..
22:15:56 <RyanT5000> Cale: yes, they're trivial datastructure-wise, but not IO wise
22:16:03 <RyanT5000> therefore, imho, they should be in System.IO :P
22:16:04 <Cale> right
22:16:11 <Cale> System.IO.IORef?
22:16:13 <RyanT5000> yep
22:16:16 <Cale> yeah, that makes sense
22:16:22 <Saulzar> Maybe they are..
22:16:39 <RyanT5000> Saulzar: the other side of my argument is that they shouldn't be in Data :P
22:16:42 <Saulzar> Hmm, nope. You're right.
22:16:58 <Saulzar> Yes, I'd agree they don't quite fit
22:17:09 <RyanT5000> (though i wouldn't necessarily advocate actually changing it, since it would break people's code (including my own))
22:17:29 <RyanT5000> (deprecation ftw)
22:17:56 <Saulzar> Hmm, this function suggests IORef's have locking ability too..
22:17:59 <Saulzar> atomicModifyIORef
22:18:04 <RyanT5000> yep
22:18:11 <RyanT5000> but they only have that much locking
22:18:27 <RyanT5000> (is that equivalent to all other locking?)
22:18:44 <Saulzar> Hm, I guess that could be a global lock or something ugly
22:18:47 <RyanT5000> i guess you could nest atomicModifyIORef, but you'd probably have deadlock issues pretty quickly
22:22:26 * Cale wonders why there always seem to be a few pieces on torrents which almost nobody has. You'd think clients would try to distribute parts roughly evenly.
22:23:13 <lispy> Cale: i've pondered that as well
22:23:18 <RyanT5000> Cale: i think they're chosen randomly; maybe it's statistically probable when there are a small number of people?
22:23:20 <Cale> I suppose that the first parts which people download are more available, so everyone gets those, but you'd expect that the tactic of always choosing the least available part would counteract that
22:23:44 <RyanT5000> if you pick 1000 numbers from 1 to 100, you'll inevitably get a few numbers chosen few (or no) times 
22:24:00 <RyanT5000> Cale: does bittorrent actually do that?
22:24:09 <lispy> and from there it might be like a snow ball down a hill?
22:24:12 <Cale> RyanT5000: I don't know -- it's probably client dependent
22:24:16 <Cale> I think Azureus does
22:24:34 <RyanT5000> hm
22:24:56 <RyanT5000> although choosing the least-available part is probably worse for the individual
22:25:06 <RyanT5000> (assuming no one else does it)
22:25:11 <RyanT5000> it's the prisoner's paradox!
22:25:28 <RyanT5000> hah i love it when game theory just stands up and gets in your face
22:25:29 <Cale> no, the least available part which has someone willing to upload of course
22:25:41 <Cale> (it has to be available :)
22:25:56 <RyanT5000> Cale, even so, presumably the most-available part will be faster to download
22:26:15 <RyanT5000> and the least-available part might become more available while you wait
22:26:28 <Cale> Well, you can download more than one part at the same time if you have more bandwidth.
22:26:38 <RyanT5000> hm, that's true
22:27:52 <Cale> So I'd probably have it pick parts starting with the least available, and moving up until my bandwidth was completely filled. I suppose I'd also want them to be parts in the earliest file in some ordering, but that's just my preference :)
22:28:54 <lispy> how is ($) defined?
22:29:13 <RyanT5000> f $ a = f a
22:29:28 <RyanT5000> infix? ?
22:29:32 <RyanT5000> where ? are things i don't know :P
22:29:45 <RyanT5000> infixr 0?
22:29:51 <Cale> infixr 0  $
22:30:02 <RyanT5000> yah that's what i thought
22:30:08 <Cale> actually,  infixr 0  $, $!, `seq`
22:30:23 <lispy> @type ($!)
22:30:24 <lambdabot> forall b a. (a -> b) -> a -> b
22:30:34 <lispy> oh, is ($!) a combination of $ and seq?
22:30:39 <Cale> f $! x = x `seq` f x
22:31:34 <lispy> hmm..how does that differ from the pattern of evaluating the argument sin a guard that always return falso?
22:32:24 <lispy> oh, i see
22:32:33 <lispy> for reference, thisis what i meant: http://okmij.org/ftp/Haskell/#making-function-strict
22:32:34 <lambdabot> Title: "Haskell Programming: Miscellanea"
22:33:26 <lispy> in the example in that page you can pick and choose which are evaluated
22:34:31 <lispy> "It seems that arithmetic expressions are the best candidates for some opportunistic evaluation..."
22:34:40 <lispy> interesting
22:35:27 <lispy> because division for example could raise as exception
22:35:39 <Cale> It would do so anyway
22:36:25 <Cale> numbers generally can't be partially evaluated
22:36:25 <lispy> hmm..
22:37:50 <lispy> ya know, that statement jives with the results connell elliot got
22:38:07 <lispy> was it fran that compiled a haskell dsl to C?
22:38:49 <dons> pan?
22:38:56 <lispy> yeah
22:39:00 <lispy> that sounds more like it
22:40:22 <lispy> iirc he did a bunch of arithmetic simplification with great success
22:41:40 <dons> yep.
22:41:52 <lispy> i think when i spoke with him about it, he mentioned trying to get ghc to do some of the same transformations but on haskell
22:42:10 <dons> sean seefried rewrote pan in Haskel, and did the same transforms in TH for much the same result
22:42:18 <dons> ?google pantheon haskell 
22:42:25 <lambdabot> http://www.springerlink.com/index/5FCGRA65YY0C9DF5
22:42:25 <lambdabot> Title: "SpringerLink - Chapter"
22:42:42 <dons> ?gsite cse.unsw.edu.au pantheon haskell
22:42:45 <lambdabot> http://www.cse.unsw.edu.au/~sseefried/files/papers/seefried04th-pan.pdf
22:43:28 <lispy> oh, so you knew seefried in real life?
22:43:43 <dons> yeah, i play squash with him.
22:43:51 <dons> and sit next to him at work.. :)
22:44:02 <lispy> ah, cool
22:44:29 <lispy> your uni sounds nice
22:44:56 <dons> yeah, i guess its pretty good. i enjoy it here.
22:45:40 <lispy> i'm a whiner when it comes to school :)
22:46:01 <lispy> actually, i liked our math dept pretty good, just not excited about CS
22:46:17 <lispy> the facility is cool and brand new, but the profs could use some...'refinement'
22:46:27 <dons> heh
22:47:48 <lispy> actually, the profs probably aren't half bad if they weren't so dead from having to fight tooth and nail for funding
22:48:13 <lispy> i dont' think any CS prof at my school has received a new nsf grant in 2-3 years now
22:49:18 <lispy> it's sort of like, "Have fun being TA, since we can't afford RA postions.  Oh wait...we can't even give you a full TA position.  Well, I hope your job gives you enough time for classes.  See ya, I have yet another grant proposal to write and not win..."
22:49:38 <dons> :(
22:51:21 <lispy> at least in math they are so used to it that the NSF gives them money anyway :)
22:53:31 <Saulzar> Some students seem to rush around attempting to find scholarships everywhere too, and end up doing no work. 
22:54:15 <RyanT5000> heh, my only option at law school: debt
22:54:34 <Korollary> you will make up for it by suing people randomly
22:54:39 <RyanT5000> assuming tuition, rates, and fees don't go up, my debt at the end will be $188k
22:54:56 <RyanT5000> yeah but i don't want to do that, lol
22:55:10 <RyanT5000> what i actually want to do is break stupid laws like DMCA and get sued
22:55:26 <RyanT5000> which is considerably less lucrative than being on the suing side :-/
22:55:27 <Saulzar> Yow
22:55:35 <Korollary> what better way to bankruptcy
22:55:38 <RyanT5000> lol
22:55:54 <RyanT5000> well i'm hoping to find more productive ways of getting at them
22:56:07 <Korollary> become an artist and release your work for free
22:56:22 <RyanT5000> i don't think that really hurts them very much...
22:56:26 <RyanT5000> i mean sure it does a little
22:56:32 <RyanT5000> and if every artist did that the RIAA would die
22:56:35 <RyanT5000> so i'd love that
22:56:43 <RyanT5000> but me doing that would be counterproductve, lol
22:56:45 <Korollary> but the artists would die as well
22:57:02 <RyanT5000> ah, i'm not convinced
22:57:09 <lispy> Saulzar: yeah
22:57:30 <RyanT5000> only a tiny fraction of artists actually make much money off album sales
22:57:44 <lispy> Saulzar: i always had this problem with scholarships...i didn't win the ones i applied to and half the others i couldn't get access to my transcripts because i didn't pay my fees
22:58:55 <RyanT5000> i heard somewhere that T-Shirt sales were, on average, more profitable for artists than record sales
22:59:38 <RyanT5000> but in any case, DMCA cuts into freedoms which are much more important than the entire music industry, including its artists
23:00:20 <RyanT5000> even baby steps towards the permanent revocation of fundamental freedoms have to be fought as strongly as possible
23:01:01 <lispy> Saulzar: but i understand your point and as i said, i'm a whiner about schools :)
23:01:40 <Saulzar> lispy, Hehe, I'm not a good student anyway - so I never worry too much about scholarships :)
23:03:16 <lispy> Saulzar: ah, i thought you were suggesting i depend less on funding from profs and more from scholarships :)
23:03:18 <RyanT5000> do foreign function calls keep their arguments from being GCed?
23:03:50 <RyanT5000> e.g.: if i have foreign import ccall unsafe "foo" foo :: Ptr a -> IO ()
23:04:13 <RyanT5000> can that Ptr a be GCed while the call is taking place?
23:05:57 <Saulzar> lispy, I'm pretty cynical too. I think it's the other students which probably determine most of your experience anyway.
23:06:18 <lispy> Saulzar: interesting, i didn't interact with them as much as i did my advisor
23:06:37 <lispy> who i couldn't stand...but then i switch and now things are slow and i work full time
23:08:16 <Saulzar> I talked to my supervisor very infrequently. I was spending my time explaining the project from the start all the time.
23:11:02 <Korollary> heh
23:11:29 <Heffalump> RyanT5000: I think this is all carefully documented in the FFI appendix to the Haskell 98 report.
23:11:37 <RyanT5000> ah ok
23:11:39 <Heffalump> I can't remember the answer though
23:12:15 <lispy> Saulzar: interesting appoarch
23:12:47 * lispy decides to pick a millenium problem and work on that instead of a proper master's thesis
23:12:52 <Korollary> heh
23:13:32 <Saulzar> The other students provided invaluable assistance, such as playing cricket and chess :)
23:13:35 <lispy> 'In this body of work we empirically verify that some masters seeking students are incapable of solving a single millenium problem."
23:13:45 <sieni> lispy: I suggest either the yang-mills problem or the navier-stokes problem
23:14:02 <lispy> sieni: what else is left? P ?=? NP?
23:14:45 <sieni> lispy: that and riemann hypothesis and couple others
23:14:47 <lispy> oh, i guessit was just Riemann that was proven
23:15:22 <sieni> lispy: I guess the poincare hypothesis was recently proven (although it has been guessed that perelman's proof strategy was enought)
23:17:07 <lispy> i thought i heard a russian guy proved riemann
23:19:55 <sieni> lispy: of course many have claimed that
23:22:15 <sieni> lispy: possibly you meant the poincare conjecture, where Grigori Perelman claimed to have a proof, which apparently turned out to be actually partly true
23:22:42 <sieni> http://en.wikipedia.org/wiki/Poincar%C3%A9_conjecture#History_of_attempted_solutions
23:23:28 <sieni> or almost true
23:24:05 <sieni> and it seems that these chinese guys showed that the proof works by writing out all details
23:25:48 <lispy> hmm
23:27:30 <sieni> perelman might get fields medal this year, since he was born 2966
23:27:34 <sieni> 1966
23:27:58 <RyanT5000> lol that explains why he can prove it! he's from the future!
23:28:03 <lispy> sieni: and why do you suggest the yang-mills and navier-stokes?
23:31:17 <sieni> I find them very interesting, especially the yang-mills one
23:31:50 <sieni> I'm a mathematical physicist by training
23:32:06 <lispy> ah, so that might help explain why you're drawn to them
23:34:43 <Korollary> sieni: what do you think of the latest string theory controversy (a la Not Even Wrong)?
23:35:57 <sieni> Korollary: I tend to agree with the anti-string theory camp
23:36:20 <sieni> Korollary: although it has produced lots of fun mathematics, it's very unclear, where the physics is
23:40:11 * alar regards string theory as an obscure form of occultism
23:49:12 <Korollary> heh. comp.lang.functional is mostly about haskell nowadays.
