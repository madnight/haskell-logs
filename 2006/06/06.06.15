00:00:03 <shapr> He's been here a few times.
00:03:13 <Lemmih> What's his handle?
00:03:58 <shapr> I don't remember.
00:04:01 <shapr> jnewbern maybe?
00:04:13 <dropdrive> is there a way to ask the lambdabot?
00:05:06 <dropdrive> (I'm just wondering if he'd make a nice printable version available...)
00:05:24 <dropdrive> (or if he has one alreadY)
00:11:39 <bringert> shapr, xerox, jgrimes and any other hope users: I had a productive train ride and fixed some of the stuff you reported, and added som of the obviously missing roles and permissions stuff, see the darcs changelog
00:13:35 <shapr> yay!
00:13:35 <bringert> *poof*
00:13:37 * shapr pulls
00:13:53 <bringert> shape: some db updates need
00:13:54 <bringert> ed
00:14:06 <bringert> I think it's only the roles_meta table
00:14:09 <shapr> bringert: Any table structure changes?
00:14:10 <bringert> good night
00:14:40 * shapr boings happily
00:14:50 <shapr> Thanks bringert! Even though you're not here!
00:33:02 <shapr> Sure is quiet today.
00:36:32 <Lemmih> Sure is.
00:36:46 <shapr> Hope is becoming more fun.
00:39:07 <shapr> Hey, what's the best way to do html syntax hightlighting for Haskell? Is hscolour the best choice?
00:39:13 * shapr has an entertaining idea...
00:39:48 <Pseudonym> How does moinmoin do it?
00:40:18 <shapr> It uses a badly hacked enscript plugin.
00:40:51 <shapr> I know this because I'm the one who hacked up a several versions old enscript.py to make it work with the moinmoin on haskell.org
00:42:51 <shapr> Anyway, my cute idea is to combine lambdabot's safe eval via hs-plugins with the ability to dump a file into it, and stick the whole thing into a flash plugin.
00:43:28 <shapr> Flash handles formatting most easily via html, so I wonder what server side plugin would be best there.
00:44:24 <shapr> Basically, I want multi-user ghci in a browser, without dangerous features that'll kill my server.
00:44:43 <shapr> It'd be an interactive pastebot.
00:44:53 <Pseudonym> Sounds an easy way to DoS your server, though.
00:45:18 <Pseudonym> But yes, cool idea.
00:45:32 <Pseudonym> Speaking of cool ideas, home time for me.
00:45:33 <Pseudonym> Nytol!
00:53:55 <mornfall> shapr: don't listen to him, it's a good idea and you can ulimit the process
00:54:25 <mornfall> well, in fact, you can ulimit the user that runs it
01:05:19 <dcoutts> SamB, presumably you're poping up the menu in response to a right click, in which case you do have an event at hand
01:06:25 <dcoutts> http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Widget.html#v%3AonButtonPress
01:06:36 <dcoutts> onButtonPress :: WidgetClass w => w -> (Event -> IO Bool) -> IO (ConnectId w)
01:06:43 <dcoutts> so you do have an event
01:37:14 <xerox> Goooood mooooorning!
01:38:53 <kzm> (vietnam?)
01:39:56 <dcoutts> @yarr!
01:39:56 <lambdabot> Drink up, me 'earties
01:40:16 <dcoutts> dons, interesting email from Roman
01:40:46 <dons> yeah
01:41:05 <dons> there's still some details, but i quite like the write (f (read ... ) model
01:42:43 <dcoutts> aye, and it fits well with the build/fold ideas
01:42:54 <dcoutts> it's like a more detailed build/fold model
01:42:56 <xerox> Is it possible to ask darcs for what it would be pulling, if one would call it to do so?
01:43:52 <dcoutts> darcs pull --dry-run ?
01:44:15 <dcoutts> "   --dry-run                      don't actually take the action "
01:44:21 <xerox> Right!
01:44:47 <xerox> Would pull the following changes:
01:44:47 <xerox> Thu Jun 15 04:04:21 CEST 2006  bjorn@bringert.net
01:44:47 <xerox>   * Fixed silly copy-and-paste bug which made the Add users link disappear. Thanks you xerox for reporting it.
01:44:47 <xerox> Exactly.
01:44:56 <xerox> (The "Would..." is printed by darcs.)
01:45:07 <xerox> ?karma+ bringert
01:45:08 <lambdabot> bringert's karma raised to 2.
01:45:25 <dons> dcoutts: yep. it seems we're approaching something underlying all the models we've tried, abstracting over reads writes and sequencing
01:45:40 <xerox> mu? :)
01:46:03 <dcoutts> dons, aye, and it puts a greater adn greater strain on ghc's simplidfier/optimiser :-)
01:46:25 <dons> yep :)
01:46:39 <xerox> Do you also know how to see what a specific patch is?
01:46:48 <xerox> Hmm, maybe I can do it interactively while pulling.
01:46:54 <dons> changes -v ?
01:47:44 <xerox> Ah, gotta pull before, in order to do that.
01:48:33 <dons> @tell malcolm I added zipWith', the specialised zipWith we talked about, and a rewrite rule to convert "pack (zipWith f g p) -> zipWith' f g p". 
01:48:33 <lambdabot> Consider it noted.
01:52:04 <xerox> -                   _ -> return OrderByDateAsc
01:52:04 <xerox> +                   _ -> return OrderByStoreDateAsc
01:52:18 <xerox> Woops.
01:53:44 <dons> darcs failed:  Unable to "darcs record" here.
01:53:45 <dons> You need to be in a repository directory to run this command.
01:53:55 <dons> ;)
01:54:04 <xerox> ihih
01:55:36 <kowey> hi all... does anybody know anything about a time locale bug in the libraries?
01:55:37 <kowey> http://bugs.darcs.net/issue140
01:55:43 <lambdabot> The title of that page is "Issue 140: convert to ISO-8601 as default format - Darcs issue tracker"
01:56:49 <xerox> dons - hs-plugins works on OS X?
01:57:32 <dons> don't think so.
01:57:41 <dons> with 6.4.2 probably yes.
01:57:46 <dons> s/6.2.2/
01:58:01 <dons> but since the dynamic linker stuff went in, it doesn't work.
01:58:44 <xerox> I have got 6.5 here.
01:58:49 <xerox> Ah, gotcha.
01:59:03 <xerox> lambdabot can compile without hs-plugins, right?
01:59:09 <dons> right
01:59:16 <dons> just the eval plugin won't work
01:59:16 <xerox> ?version
01:59:17 <lambdabot> lambdabot 4p1, GHC 6.5 (OpenBSD i386 )
01:59:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:59:28 <dons> you'll need to remove the hs-plugins dep from the .cabal file
01:59:37 <dons> and comment out the runplugs stanza in the .cabal file
02:00:07 <xerox> Consider it noted. (lambdabot © 2006)
02:01:16 <kzm> dons: I need to meddle with internals of ByteString.  Is it okay if Base.hs exports the constructor?
02:01:23 <kzm> Or is there another preferred way?
02:02:10 <dons> the way is to import the constructor from Base, yep
02:02:16 <kzm> (I want to "unslice" a bunch of strings, something like: zipWith (PS superPtr) offsets  lengths)
02:02:35 <kzm> Is it exported?  /me rechecks.
02:02:45 <dons> it should be, it is in my versoin
02:02:50 <dons> module Data.ByteString.Base (
02:02:50 <dons>         -- * The @ByteString@ type and representation
02:02:50 <dons>         ByteString(..),  
02:03:27 <kzm> Ah.  Silly me.
02:03:56 <kzm> Typo in the import statement.
02:15:07 <kzm> Any idea what this means?  :  Loading package bio-0.0 ... linking ... <interactive>: /home/ketil/lib/bio-0.0/HSbio-0.0.o: unknown symbol `DataziByteStringziFusion_ZCztZC_con_info'
02:15:32 <kzm> Or, rather, how to solve it.
02:16:23 <xerox> Are you using --make?
02:17:15 <shapr> kzm: Try upgrading fps?
02:17:30 <xerox> (If not, are you using -package fps ?)
02:17:31 <kzm> I added fps to the build-depends of bio.  
02:17:45 <xerox> shapr!
02:17:52 <kzm> ":set -package fps" didn't suffice
02:17:58 <xerox> The writing spree can't stop :)
02:18:05 <kzm> But the build-depends solved it.
02:18:39 <shapr> xerox: hiya, wassup?
02:18:52 <xerox> shapr - Playing with hope :-)
02:18:57 <xerox> (Using HaskellDB-flat)
02:19:11 <kzm> And it even works.  I can unslice strings.  Hooray!
02:20:53 <xerox> UH
02:20:59 <xerox> I need to mail Isaac about this http://conferences.oreillynet.com/cs/os2006/view/e_sess/9498
02:21:01 <lambdabot> The title of that page is "O'Reilly Open Source Convention - July, 24-28, 2006 - Portland, OR"
02:36:01 <shapr> xerox: What's your hope url?
02:36:13 <xerox> http://paolo.is-a-geek.com/mu/
02:36:45 <shapr> haha, mtg card!
02:36:50 * xerox grins
02:37:00 <shapr> I still have some alphas and betas in a box in the USA.
02:37:11 <xerox> Those are worth big bucks.
02:37:16 <shapr> Nah, it's just forests and stuff.
02:37:22 <xerox> I had a...
02:37:23 <shapr> I do have a coupla guardian beasts though.
02:37:29 <shapr> I had everything at one time.
02:37:30 <xerox> That white 4/4 angel?
02:37:38 <shapr> Oh, I have a bunch of those.
02:37:44 <xerox> Beta.
02:37:44 <Kasperle> heh
02:37:49 <Kasperle> M:TG?
02:37:55 <xerox> Silly, can't remember the name.
02:37:59 <shapr> Not in beta, one in alpha though.
02:38:03 <Kasperle> serra angel?
02:38:05 <xerox> Right!
02:38:06 <shapr> yeah, that' sit.
02:38:08 <xerox> hahaha.
02:38:20 <shapr> I think I still have most of the Legends dragons though.
02:38:37 <xerox> I started playing when there were... Mercadian Masques.
02:39:04 <shapr> Haven't heard of that one. I started playing just after Arabian Nights was released, and I got out just after Ice Age.
02:39:13 <xerox> Wow.
02:39:19 <shapr> I still have three thousand cards or so in some boxes.
02:39:21 <xerox> You didn't use covers for cards at the time, right? :)
02:39:38 <shapr> Nah, I didn't use covers, seemed too silly.
02:39:52 <xerox> Also played with...
02:40:07 <xerox> How is it called when you put a random card as "bet"
02:40:10 <shapr> ante
02:40:12 <xerox> haha
02:40:15 <shapr> Yeah, ante is fun.
02:40:17 <xerox> Eeek.
02:40:33 <alar> MTG =)
02:40:37 <shapr> I won a mana drain by ante once.
02:40:52 <xerox> Arabian Nights had all of those freaky cards which were referentially untransparent.
02:40:54 <psi> I had covers :)
02:41:02 <xerox> (They did IO in strange situations)
02:41:05 <psi> is that considered nerdy?
02:41:10 * earthy stopped just before Arabian Nights came out. ;)
02:41:11 <shapr> and I've lost a bunch of random stuff by ante. Force of Nature, multilands, etc
02:41:19 <psi> (as if mtg in itself wouldn't be)
02:41:28 <shapr> mtg == crack for geeks
02:41:31 <shapr> Don't even try it.
02:41:36 <shapr> If you haven't already.
02:41:41 <xerox> When I was playing multilands costed about 15€
02:41:48 <earthy> multilands... multilands...
02:41:49 <shapr> 15 euro?
02:41:51 <earthy> oh, right. ;)
02:41:53 <BCoppens> luckily I've been off mtg for a long while ;)
02:41:54 <shapr> earthy: dual-lands
02:41:57 <xerox> Right.
02:42:07 <earthy> white or black mana
02:42:14 <alar> shapr: there are some strange persons who don't fall in addiction
02:42:18 * earthy still has a reasonably tuned deck
02:42:18 <shapr> Sheesh, I have a nearly complete set of multilands in the USA.
02:42:29 <xerox> I had a cool sliver deck.
02:42:38 <earthy> no idea as to how it would play against current decks though
02:42:54 <xerox> shapr - Now those *are* valuable :)
02:43:10 <shapr> I made a chains of mephistopheles deck that once ran my opponent out of cards on my first turn.
02:43:21 <shapr> Which was also the first turn of the game.
02:43:27 <BCoppens> :D
02:43:29 <xerox> Now it isn't really possible to do such things anymore :)
02:43:49 <shapr> Why not, have they changed the errata on CoM? They were cumulative.
02:43:53 <xerox> They have restricted the ... three black mana for one, how was that called.
02:43:56 <earthy> otoh, you have killer creatures that do massive amounts of damage but cost cumulative upkeep
02:44:05 <xerox> Black rite?
02:44:12 <earthy> Dark Ritual?
02:44:14 <shapr> Oh yeah.
02:44:16 <xerox> Well, they have banned/restricted a lot. 
02:44:17 <xerox> Haha, that.
02:44:30 <earthy> hm. that's a pity. my deck was based around some of those. ;)
02:44:33 <xerox> They have also introduced a whole lot of new rules.
02:44:39 <shapr> I like Pestilence decks.
02:45:06 <Itkovian> Hmm ... I never got into mtg, I've bought two decks, no add-on cards, but I've got nobody to play with :-(
02:45:08 <shapr> Though I heard that they got rid of white and black knights as well.
02:45:09 <xerox> New cards with new rules, the gameplay changes from expansion to expansion. Good for marketing.
02:45:12 <earthy> weird, though, that I still remember this stuff. it must've been like 11 years ago
02:45:21 <xerox> I have a Revised black night!
02:45:22 <shapr> xerox: Yeah, crack for geeks.
02:45:29 <shapr> Is revised worth something?
02:45:33 <xerox> Yup
02:45:45 <shapr> Revised is 3rd edition, yeah?
02:45:49 <xerox> Right.
02:46:00 <shapr> I don't think I have anything later than revised.
02:46:12 <shapr> Heck I should get my cards, maybe I can make some money.
02:46:17 <xerox> I suspect that your cards are worth a bunch of money.
02:46:23 <xerox> You owe me a dual land!
02:46:25 * xerox grins evilly
02:46:36 <shapr> Do you still play MtG?
02:46:40 <xerox> Not really.
02:46:42 <xerox> My brother does.
02:46:48 <BCoppens> is MtG still played widely now?
02:46:48 <Kasperle> i did some revised/fallen empires/ice age... then a long break and then i participated in some drafts of the onslaught block and some of the blocks after that
02:46:52 <shapr> The system itself got boring for me.
02:47:01 <shapr> It's just too limited.
02:47:07 <Kasperle> shapr: think so?
02:47:11 <shapr> But that's why I left Python and went to Haskell as well.
02:47:13 <Kasperle> shapr: there's some amazing stuff in there now
02:47:26 <xerox> He found some interesting things on internet. Like people who make crazy working deck out of a random card suggested by users.
02:47:49 <shapr> I think IceHouse is a lot more interesting than MtG.
02:47:54 <xerox> Or things like that. When he was explaining how some of those worked, I stopped him because it sounded like something I knew (a biT), Quantum ElectroDynamics.
02:48:00 <earthy> hm. I think I only have Revised and 4th Ed
02:48:25 <shapr> I've been trying to figure out how to make a game based on the halting problem.
02:48:27 <earthy> oh, and some Unlimited
02:48:37 <xerox> If you think that rare 4th *italian* edition are worth money.... English one are surely going to be worthy too.
02:49:01 <xerox> shapr - And the thinking didn't... halt? :)
02:49:08 <shapr> xerox: hah!
02:49:25 <earthy> yup, I kinda lost interest before Legends became really available in .nl
02:50:04 <xerox> The point I was making there is that the ball lighting 6/2 is a hoax.
02:51:04 <shapr> Icehouse is much cooler than MtG - http://www.icehousegames.org/
02:51:06 <lambdabot> The title of that page is "IcehouseGames.org - a site for the Icehouse gaming community"
02:52:02 <xerox> Ah, those, I think you mentioned them earlier.
02:52:53 <shapr> Yeah, two that are especially interesting are IceTowers where multiple players who play as fast as they can, not by turn and Zendo, an inductive logic game.
02:53:06 * shapr writes another blog entry to keep xerox entertained.
02:53:21 * xerox boings happily and heads to breakfast
02:54:52 * xerox coughs... 11:54 AM... s/breakfast/lunch/
04:02:20 <boegel> dons: the automatic spamming of webpace-titles by lambabot is pretty annoyinh
04:02:25 <boegel> *annoying
04:02:36 <shapr> It seems useful to me.
04:03:27 <shapr> Some of those links that reppie posts I really don't want to be looking at during work hours... :-)
04:05:31 <bolrod> xerox: well... breakfast is just the first meal of the day.. ;)
04:06:30 <bolrod> so... what is breakfast in space.. every meal would be I guess :)
04:12:34 <alar> bolrod: and day is timeslice between naps?
04:17:21 <mahogny> I once used that definition, but it's not very nice. some of my weeks ended up having no sunday nor saturday for that matter :P
04:18:32 <shapr> xerox: I wish for gif & png suppor for halbum.
04:18:42 <xerox> shapr - Me too.
04:19:26 <xerox> I did take a look at the code, but it needs more reading, I am not sure what needs to be done.
04:23:31 <shapr> I think bringert said that haskell-exif wouldn't be too hard to extend.
04:24:35 <xerox> Do you really use EXIF in general?
04:25:10 <shapr> Nope.
04:30:16 <bolrod> alar: yes... and sometimes a week doesn't have enough days with that definition 
04:31:53 <BCoppens> I'm wondering, is there some kind of tutorial for Network IO and Haskell?
04:32:14 <shapr> BCoppens: There are server & client demos on the old wiki.
04:32:27 <BCoppens> aha
04:32:55 <BCoppens> nice, thanks :)
04:34:31 <BCoppens> shapr: I only seem to find http://www.haskell.org/hawiki/HaskellNewbie_2fTcpIpAndNetworking, which isn't really about clientside, is there a specific url you were thinking of?
04:34:32 <lambdabot> The title of that page is "HaskellNewbie/TcpIpAndNetworking - The Haskell Wiki"
04:37:14 <sieni> is the title nagging an absolute necessity?
04:38:31 <ibid> it could exclude all the hawiki stuff
04:38:37 <ibid> but in general it's useful
04:38:53 <sieni> no it's not
04:39:05 <sieni> it's annoying, irritating and completely useless
04:39:26 <ibid> annoying and irritating maybe, but it is also useful
04:39:42 <ibid> especially when people just paste uris with no explanation
04:39:54 <fluxx> maybe it could trig only with lines that contain only an url and nothing else
04:39:54 <vincenz> pfftftt
04:40:01 <ibid> (which might not be a problem in this particular channel, actually)
04:40:30 <ibid> it could probably also be silent unless asked
04:40:37 <ibid> like
04:40:39 <ibid> @what
04:40:40 <lambdabot>  @where <key>, return element associated with key
04:40:40 <ibid> :)
04:41:01 <sieni> @nag would be nice ^_^
04:41:01 <lambdabot> Maybe you meant: faq map msg
04:44:10 <vincenz> blablabla
04:47:41 * BCoppens also doesn't find any network demos in his hugs demos
04:50:07 <shapr> BCoppens: I know server & client demos do exist on the oldwiki, not sure where. I also know that MissingH includes support code that makes it even easier to write network apps, so you may want to try that next.
04:50:11 <shapr> xerox: Ok, next entry up!
04:51:12 <BCoppens> shapr: it doesn't have to be 'easy' per se, I was thinking of playing a bit with networking to familiarize myself a bit with IO in haskell and monads
04:51:45 <xerox> shapr: Fun fun fun!
04:51:58 <xerox> shapr: I am going to do a new one too ^_^
04:52:21 * shapr put lots of pretty pix in this new entry.
04:52:48 <xerox> Indeed.
04:53:06 <shapr> I think my front page is getting too large.
04:53:17 <xerox> I think bringert added a limit
04:55:59 <bolrod> SoC pages? where :)
04:57:22 <araujo> good morning!
04:57:27 <araujo> vincenz, pong
05:04:48 <fura13> hello all
05:05:25 <Lemmih> Hello you.
05:08:57 * BCoppens is sooo stupid
05:09:44 <xerox> BCoppens: watch this now http://video.google.com/videoplay?docid=342080286217914779
05:09:47 <lambdabot> The title of that page is "Edward Teller: Going to see Einstein give a lecture - Google Video"
05:10:46 <xerox> lambdabot spoils the fun.
05:11:00 <BCoppens> hehe
05:11:03 * BCoppens has a look
05:11:06 <xerox> Great.
05:13:39 <bolrod> shoot lambdabot 
05:15:46 <BCoppens> xerox: nice story :D
05:16:43 <BCoppens> thanks :)
05:17:27 <bolrod> :D
05:17:36 <bolrod> conclusion:  Everybody is stupid.
05:17:39 <bolrod> ;)
05:18:16 <BCoppens> yeah :)
05:19:11 <xerox> bolrod - No. That's only the starting point.
05:19:36 <xerox> shapr - Let's play volity sometime.
05:22:47 <shapr> Yeah, sure, it's fun. I only wish it didn't require Sun's JRE :-(
05:22:52 <shapr> irc
05:22:59 <shapr> oops, wrong window
05:23:03 <BCoppens> now it works =)
05:23:04 <shapr> fura13: Are you learning Haskell?
05:37:29 <fura13> shapr:  yes, trying (8 ... can't make network-alt-0.3.2 =(
05:56:36 * fura13 don't understand ... type make ; echo in console : "ghc --make -package Cabal Setup.lhs -o setup \n Chasing modules from: Setup.lhs Setup.lhs:15:42 Expecting a function type, but found `IO ExitCode` "  etc...
05:57:15 <Lemmih> Post the code?
05:57:39 <fura13> but author write README Either ghc-6.4 with an up-to-date cabal or a cvs snapshot of hugs is needed.
05:57:56 <fura13> i have ghc-6.4.2 and cabal-1.1.4
05:58:22 <Lemmih> Post the code?
05:58:51 <fura13> Setup.lhs?
05:59:19 <fura13>      13 > main = defaultMainWithHooks myHooks
05:59:19 <fura13>      14 >
05:59:19 <fura13>      15 > myHooks :: UserHooks
05:59:19 <fura13>      16 > myHooks = defaultUserHooks { postClean = cleanupHook,
05:59:19 <fura13>      17 >                              postConf = \_ _ _ -> configure >> return ExitSuccess
05:59:19 <fura13>      18 >                            }
05:59:43 <fura13> error in 15 string
06:00:20 <fura13> this Setup.lhs from network-alt-0.3.2.tar.gz from http://cs.helsinki.fi/u/ekarttun/network-alt/
06:00:22 <lambdabot> The title of that page is "network-alt"
06:00:47 <sieni> O RLY?
06:01:59 <fura13> release of 0.3.2 at " Sun May  7 11:05:43 EEST 2006 "
06:03:27 <fura13> maybe i have more latest ghc and cabal than author of network-alt.0.3.2?
06:04:16 <Lemmih> I doubt it. The Cabal distributed with ghc-6.4.2 is pretty old.
06:05:51 <fura13> where i can get fresh cabal ?
06:05:59 <Lemmih> @where cabal
06:05:59 <lambdabot> http://www.haskell.org/cabal
06:06:16 <fura13> i think that ... emerge cabal is latest
06:07:21 <kzm> should I get libghc6-cabal-dev for Ubuntu?
06:08:25 <fura13> from http://www.haskell.org/cabal/download.html ... 1.2 Release Candidate (Version 1.1.4: May 1st, 2006) ... i have also 1.1.4
06:08:26 <lambdabot> The title of that page is "The Haskell Cabal"
06:09:45 <fura13> Lemmih:  1.1.4 is latest cabal version?
06:10:43 <fura13> or exist secret cvs of cabal ? or ?
06:12:54 <fura13> i don't undestand why network-alt can't simple make =(
06:15:09 <Pete_I> how do you get the commandline arguments?
06:16:55 <Lemmih> fura13: Are you sure you read the error message right?
06:17:20 <Dino_> Pete_I: System.getArgs
06:17:45 <yaarg> man = do args<-getArgs
06:18:10 <Pete_I> thank you
06:18:29 <fura13> error message copy-past from console
06:18:39 <fura13> ghc --make -package Cabal Setup.lhs -o setup
06:18:39 <fura13> Chasing modules from: Setup.lhs
06:18:39 <fura13> Compiling Main             ( Setup.lhs, Setup.o )
06:18:39 <fura13> Setup.lhs:15:42:
06:18:39 <fura13>     Expecting a function type, but found `IO ExitCode'
06:18:39 <fura13>       Expected type: Args
06:18:42 <fura13>                      -> Int
06:18:46 <fura13>                      -> PackageDescription
06:18:47 <fura13>                      -> Distribution.Simple.LocalBuildInfo.LocalBuildInfo
06:18:50 <fura13>                      -> IO ExitCode
06:18:51 <fura13>       Inferred type: Args -> Int -> PackageDescription -> IO ExitCode
06:18:54 <fura13>     In the `postClean' field of a record
06:18:56 <fura13>     In the record update: defaultUserHooks
06:18:58 <fura13>                               {postClean = cleanupHook,
06:19:00 <Pete_I> ....pastebot?
06:19:00 <fura13>                                postConf = \ _ _ _ -> configure >> (return ExitSuccess)}
06:19:02 <fura13> make: *** [setup] Error 1
06:19:07 <Lemmih> fura13: Don't paste more than 3 lines here. Use a pastebin.
06:19:33 <fura13> sorry
06:20:00 <Lemmih> fura13: Try adding another '_' after 'postConf'.
06:20:31 <Lemmih> It's a shame musasabi has gone underground.
06:21:01 <xerox> Why did he disappear?
06:21:54 <Lemmih> I don't know. One day he was just gone. Quite unnerving, actually.
06:22:35 <fura13> Lemmih:  like this ?  postConf = \ _ _ _ _ ->
06:22:59 <Lemmih> fura13: Yes.
06:23:32 <fura13> Lemmih:  the same error
06:24:35 <fura13> Lemmih:  and i try \ _ _ -> ... analogously to
06:24:36 <Lemmih> Oh, right. It's for 'postClean', not 'postConf'.
06:25:39 <Lemmih> fura13: Add another '_' to 'cleanupHook'.
06:26:11 <fura13> after cleanupHook ? like postClean = cleanupHook _ , ?
06:26:35 <Lemmih> fura13: Look at the definition of 'cleanupHook'.
06:28:45 <fura13> Lemmih:  i add _ in  "cleanupHook _ _ _  = do " and in "postConf = \ _ _ _ -> co..." and make all ok
06:29:38 <fura13> but i don't undestand why this error appear?
06:30:16 <fura13> strange ...
06:31:02 <fura13> Lemmih:  big thanx !
06:32:51 * fura13 continue learning Haskell
07:22:24 <dfeuer> Cale, ping
07:22:30 <dfeuer> @seen Cale 
07:22:30 <lambdabot> Cale is in #haskell. I don't know when Cale last spoke.
07:22:36 <dfeuer> huh?
07:22:48 <dfeuer> Why doesn't lambdabot know when Cale last spoke?
07:23:07 <petekaz> because it was probably restarted.
07:23:15 <dfeuer> mm
07:23:44 <petekaz> for nightly patches.
07:23:48 * dfeuer is no longer more impressed with lambdabot than sarahbot.
07:24:33 <petekaz> actually ... here is the first patch I'm pulling down today: 
07:24:37 <petekaz> Wed Jun 14 23:58:17 EDT 2006  dons@cse.unsw.edu.au
07:24:42 <petekaz>   * try to sort out seen persistence
07:29:06 <dfeuer> heh heh
07:41:36 <jgrimes_> shapr: whenever I find a bug (in the case, just a bit neglected config code) in hope to where should I report it?
07:42:58 <Wikipedia-Gast> why
07:56:12 <jgrimes_> Wikipedia-Gast: why, to what? :)
07:59:22 <roconnor> Is there some function to compute the log2 rounded down (or up) of an integer?
08:00:41 * roconnor feels like he has asked this before
08:01:34 <dfeuer> meaning...
08:01:47 <dfeuer> most significant bit?
08:04:26 <roconnor> yes, what is the position of the most signifigant bit
08:04:59 <xerox> jgrimes - I believe you'd better mail bringert. Cc: shapr an me maybe? So we all know what's going on before a mailing list will be formed, if any.
08:06:28 <jgrimes_> xerox: alright, sounds good. I'll work on that when I get home.
08:25:48 <BCoppens> @hoogle Debug.Trace
08:25:49 <lambdabot> No matches, try a more general search
08:25:52 <BCoppens> @hoogle Trace
08:25:52 <lambdabot> Debug.Trace :: module
08:25:52 <lambdabot> Debug.Trace.trace :: String -> a -> a
08:25:52 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
08:38:46 <Taral> *snort*
08:38:55 <Taral> http://en.wikipedia.org/wiki/Hylomorphism
08:38:57 <lambdabot> The title of that page is "Hylomorphism - Wikipedia, the free encyclopedia"
08:39:08 <Taral> not exactly what DrHylo intends. :)
08:42:02 <dfeuer> Didn't Aristotle believe something like that?
08:42:11 <Taral> @hylo (\z -> z z)(\z -> f (z z))
08:42:12 <lambdabot> drhylo module failed: IRCRaised user error (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 27}: Parse error)
08:42:14 <Taral> lol
08:42:27 <Taral> @pl (z -> z z)(\z -> f (z z))
08:42:28 <lambdabot> (line 1, column 4):
08:42:28 <lambdabot> unexpected ">"
08:42:28 <lambdabot> expecting variable, "(", operator or ")"
08:42:30 <Taral> @pl (\z -> z z)(\z -> f (z z))
08:42:36 <lambdabot> ap id id (f . ap id id)
08:42:36 <lambdabot> optimization suspended, use @pl-resume to continue.
08:42:42 <Taral> lol
08:42:57 <Taral> You can make @pl go into a loop :)
08:44:50 <Taral> Am I the only one here?
08:45:08 <Dino_> I'm here, but must go soon.
08:45:15 <dfeuer> hm?
08:45:33 <dfeuer> loop where?
08:46:54 <SamB> hmm...
08:47:02 <SamB> I got this compiling gtk2hs:
08:47:02 <SamB> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
08:47:02 <SamB>         types/Type.lhs:(1107,0)-(1108,77): Non-exhaustive patterns in function zip_ty_env
08:48:07 <SamB> compiling gtk/Graphics/UI/Gtk/TreeList/ListStoreNew.hs
08:50:56 <dfeuer> Anyone here good at performance analysis?
08:51:27 <dfeuer> Anyone here at all?
08:51:40 <Taral> dfeuer, The @pl optimizer can loop. It halts after a bit, hence the @pl-resume message.
08:51:48 <Taral> Good at? I dunno. I know a thing or two about it.
08:52:08 <Taral> SamB, ew. Bug report time. :)
08:53:03 <BCoppens> @hoogle Maybe -> a -> a
08:53:04 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
08:53:04 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
08:53:31 <dfeuer> I'm wondering if   Node p v p (Maybe v p)   is better than  Node2 p v p | Node3 p v p v p     when the first two fields can be useful without checking for the last two.
08:53:42 <dcoutts_> SamB, hmm, exciting. try 6.4.1 ot .2
08:53:55 <dfeuer> ummm...
08:53:56 <Taral> SamB, Known problem, fixed in CVS: http://hackage.haskell.org/trac/ghc/ticket/384
08:53:59 <lambdabot> The title of that page is "#384 (internal compiler error: the `impossible' happened) - GHC - Trac"
08:54:10 <dfeuer> i meant    Maybe (v,p)
08:54:25 <dcoutts_> dfeuer, that sounds reasonable
08:54:30 <dfeuer> Shouldn't that reduce the number of tag checks when descending a 2-3 tree?
08:54:33 <Taral> dfeuer, Yes, that is quite likely, so long as the second "v p" doesn't depend on the others.
08:54:35 <SamB> yes, I figured I had to finally do that
08:55:14 <dcoutts_> dfeuer, yes, especially if you can unpack any of the Node fields
08:55:21 <dfeuer> Unpack?
08:55:36 <dcoutts_> it's often possible to unpack strict fields
08:55:39 <Taral> Unpacking is a performance optimization for strict fields.
08:55:48 <dcoutts_> using the {-# UNPACK #-} ghc pragma
08:56:06 <dcoutts_> it's especially beneficial for small things, eg ints
08:56:14 <dfeuer> Would the compiler be able to figure that out by itself if all the fields were marked strict?
08:56:27 <dcoutts_> no, it's not always an optimisation
08:56:27 <SamB> hmm, that isn't a very descriptive bug name
08:56:37 <dfeuer> dcoutts_, explain?
08:56:38 <SamB> shouldn't the bug name specify which impossible?
08:56:47 <dfeuer> What's the optimization exactly?
08:57:19 <dcoutts_> dfeuer, you either compile with -funpack-strict-fields or use the pragma on a per-field basis. See the description in the ghc manual for examples of when it might be an optimisation vs a pesimisation.
08:57:22 <SamB> well, there is a flag to unpack all strict fields, but it isn't very smart.
08:57:55 <dcoutts_> dfeuer, yes, ghc does sometimes unpack things by itself when it's obvious that it's an optimisation
08:58:21 <dfeuer> Would it be possible to tell the compiler to unpack or not based on how the type is instantiated?
08:58:30 <dcoutts_> no
08:58:37 <dfeuer> hmm
08:58:49 <dcoutts_> you can't unpack polymorphic fields
08:59:23 <dfeuer> Figures.
08:59:56 <dfeuer> But without some sort of scary Generic Haskell extension or something, doesn't that mean lots of code duplication?
09:01:14 <SamB> dcoutts: but you can if they are indirectly polymorphic, I hope?
09:03:31 <dcoutts_> SamB, indirectly, eg data Foo a = Foo !Int !Bar a; data Bar a = Bar !Int a
09:03:35 <dcoutts_> yes, I think so
09:03:53 <dcoutts_> that would allow both Ints to be unpacked into the Foo constructor
09:04:21 <dcoutts_> the 'a' field can be strict of course but can't be unpacked into either
09:04:28 <dcoutts_> since we don't know its representation
09:04:29 <SamB> okay, so how to zap old builds of packages...
09:04:57 <dfeuer> But being strict already gives a performance benefit, right?  Because we don't have to check to see if it's been evaluated?
09:06:12 <SamB> not always
09:06:18 <dfeuer> ...
09:06:49 <eivuokko> It might also get evaluated even if it isn't used.
09:07:01 <dfeuer> I mean, if it's going to be used.
09:07:50 <dcoutts_> dfeuer, right, so for example collection types implemented as trees are often strict in the tree structure but lazy in the collection elements
09:07:54 <dfeuer> I'm writing a search tree.  It's strict, except when creating a 1-element tree, which is a case not worth thinking about.
09:07:56 <BCoppens> @hoogle regex
09:07:56 <lambdabot> Text.Regex :: module
09:07:56 <lambdabot> Text.Regex.Regex :: data Regex
09:07:56 <lambdabot> Text.Regex.Posix.regexec :: Regex -> String -> IO (Maybe (String, String, String, [String]))
09:08:53 <dfeuer> dcoutts, what sort of tree-based collection is lazy in the collection elements?
09:09:27 <dfeuer> Search trees and tries are strict.  What else is there?
09:10:50 <dfeuer> dcoutts_?
09:17:36 <dcoutts_> dfeuer, see Data.Map
09:17:50 <dcoutts_> it's lazy in the values
09:17:54 <dcoutts_> strict in the keys of course
09:18:08 <dmhouse> dfeuer: A lot of data structures internally use a tree.
09:26:08 <BCoppens> @hoogle Url
09:26:09 <lambdabot> Text.Html.URL :: type URL
09:26:09 <lambdabot> Distribution.InstalledPackageInfo.pkgUrl :: InstalledPackageInfo -> String
09:26:09 <lambdabot> Distribution.PackageDescription.pkgUrl :: PackageDescription -> String
09:39:41 <vincenz> how's everyone
09:39:51 <Paltas> hi vincenz :)
09:39:55 <vincenz> hi Paltas 
09:40:05 <Paltas> how's life?
09:40:50 <vincenz> ok
09:41:16 <dfeuer> dcoutts_, I had to go for a bit.  But yeah, I was talking about keys, not values.
09:41:58 <vincenz> Paltas: you?
09:42:22 <Paltas> vincenz: fine.. :) I'm hoping i pass my exam in logic and functional programming :)
09:47:57 <vincenz> I'm trying to find more information on top-down reasoning
09:50:30 <BCoppens> @hoogle forkIO
09:50:31 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
10:18:52 <dmhouse> What was that one-liner, using a scan, that produced the fibonnaci numbers?
10:19:09 <dmhouse> > take 10 (scanl (+) 1 [1..])
10:19:15 <lambdabot>  [1,2,4,7,11,16,22,29,37,46]
10:19:24 <dmhouse> > take 10 (scanl (+) 0 [1..])
10:19:24 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
10:19:35 <dmhouse> Hmm, nah, that's not it.
10:19:39 <dmhouse> I'm sure I've seen one.
10:19:49 <dmhouse> (And yes, I know about the zipWith definition)
10:20:30 <dmhouse> > take 10 (1 : scanl (+) 1 [1, 1..])
10:20:31 <lambdabot>  [1,1,2,3,4,5,6,7,8,9]
10:20:42 <dmhouse> hehe, Nope.
10:22:26 <roconnor> Hmm, how do I make a profiled build again?
10:22:58 <roconnor> -prof -auto-all
10:23:18 <Lemmih> roconnor: Using Cabal?
10:23:25 <roconnor> not yet
10:30:38 <dropdrive> dropdrive: let fib = 1: scanl (+) 1 fib ?
10:31:15 <dropdrive> (oops) or was the point not to reuse fib?
10:31:20 <dmhouse> > take 10 (let fib = 1 : scanl (+) 1 fib in fib)
10:31:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
10:31:26 <dmhouse> Aha, that's it!
10:32:02 <Lemmih> > fix ((:) 1 . scanl (+) 1)
10:32:03 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
10:32:25 <jgrimes_> Lemmih: nice.. :)
10:34:50 <jgrimes_> both of those are pretty neat one line fibonacci sequences.
10:35:14 <dmhouse> Yep.
10:35:18 <dmhouse> Along with the standard:
10:35:23 <resiak> The fix one would be neater if fix didn't force my brain out through my ears
10:35:44 <dmhouse> > take 10 (let fib = 1 : 1 : zipWith (+) fibs (tail fibs))
10:35:44 <lambdabot>  Parse error
10:35:49 <dmhouse> > take 10 (let fib = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs)
10:35:49 <lambdabot>  Not in scope: `fibs'
10:35:55 <dmhouse> > take 10 (let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs)
10:35:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
10:36:04 <dmhouse> We got there eventually.
10:36:05 <dmhouse> :)
10:36:08 <jgrimes_> :)
10:37:14 <dropdrive> stupid question: what's fix?  where does one look up stuff like this?
10:37:18 <Paltas> awesome. :)
10:37:37 <jgrimes_> dropdrive: hoogle! :)
10:37:45 <jgrimes_> dropdrive: http://haskell.org/hoogle/
10:37:46 <lambdabot> The title of that page is "Hoogle"
10:37:52 <dmhouse> > take 10 (fix $ ([1,1] ++) .  ((zipWith (+) .) . second tail .) . (,)) -- let's see if my pointsfree skillz are awake today :)
10:37:52 <lambdabot>    The operator `.' [infixr 9] of a section
10:37:53 <lambdabot>     must have lower preceden...
10:38:15 <dmhouse> > take 10 $ fix (([1,1] ++) .  ((zipWith (+) .) . second tail .) . (,))
10:38:15 <lambdabot>    The operator `.' [infixr 9] of a section
10:38:16 <lambdabot>     must have lower preceden...
10:38:36 <dmhouse> Hrm.
10:38:40 * dmhouse takes it to a /msg
10:38:42 <dropdrive> jgrimes_: aha, thanks...time to make it a keyword search in firefox!
10:41:55 <ndm> and there is also a firefox search bar option for it
10:42:02 <ndm> @google hoogle mozdev
10:42:05 <lambdabot> http://mycroft.mozdev.org/download.html?submitform=Search&sherlock=yes&category=9
11:01:10 <br1> Hi.  Does anybody know how to make the anamorphism/unfold/inverse banana bracket symbol in latex?
11:04:18 <dropdrive> br1: can you show it to me somewhere?
11:04:48 <br1> it's like this [(   )]
11:06:37 <dropdrive> br1: I've found (|   |)...
11:07:53 <br1> :)  That's what I've been using. For catamorphisms/fold the symbol is (|  |), and that exists in latex as \llparenthesis \rrparenthesis
11:08:09 <dropdrive> br1: you can try to form [( using "[ negative-horizontal-space (" ?
11:08:36 <br1> maybe
11:10:08 <zarvok> br1: out of curiosity, what package has \llparenthesis?  My latex doesn't seem to have it (although I am using an old version)
11:10:10 <Lemmih> xerox: How's the exams coming along?
11:10:40 <xerox> Lemmih - Working hard on Physics!
11:10:50 <dmhouse> Ooh, xerox, did you attend that lecture?
11:11:09 <xerox> Hmm, attend?
11:11:15 <dmhouse> Well, /join. :)
11:12:14 <xerox> You mean the #Mathematics one?
11:12:27 <xerox> Isn't it on the 21?
11:12:40 <dropdrive> zarvok: stmaryrd
11:13:03 <xerox> Lemmih - I am working through MIT's OCW. They have plenty of good material.
11:13:14 <dropdrive> zarvok: one can look it up here: http://www.ctan.org/tex-archive/info/symbols/comprehensive/
11:13:16 <lambdabot> The title of that page is "CTAN: directory: /tex-archive/info/symbols/comprehensive"
11:13:45 <zarvok> dropdrive: thanks
11:13:46 <dmhouse> xerox, Oh, probably. 
11:15:51 <br1> zarvok: I'm running textex (cygwin version). I only use the  qsymbols package.
11:22:17 <mwc> Hmmm, I take it c2hs 0.14.5's cabal is a little broken wrt to GHC 6.4.2?
11:22:25 <mwc> Getting strange errors in Setup.hs
11:22:57 <Lemmih> GHC 6.4.2 took a Cabal snapshot from darcs /-:
11:23:25 <mwc> Yeah, as I recall, most of the newer releases couldn't work with the version of Cabal in 6.4.1
11:27:10 <perlIsBetter> hello
11:27:19 <perlIsBetter> so hey I know a bit of linux
11:27:24 <perlIsBetter> and want to program
11:27:31 <perlIsBetter> haskell seems very cool
11:27:36 <perlIsBetter> is it practical?
11:27:44 <perlIsBetter> can it be used for biz and government NOW?
11:27:46 <sylvan> better than perl
11:27:47 <sylvan> =)
11:27:50 <perlIsBetter> heh
11:27:53 <neologism> anyone speaking swedish here?
11:27:54 <perlIsBetter> I dont even know perl
11:28:00 <sylvan> neologism: ja
11:28:05 <neologism> heta naetter - what it means?
11:28:10 <sylvan> hot nights
11:28:17 <neologism> thnx
11:29:14 <SamB> well, does the government have people who would use it?
11:29:46 <sylvan> perlIsBetter:  Yes I would say it is practical. There are a few areas that could use some work (particularly if you need very good performance you have to spend far too much effort battling lazyness)
11:29:57 <SamB> also, isn't there just the tiniest chance that you are a troll?
11:30:21 * SamB is lagged
11:33:03 <mwc> perlIsBetter, pugs, the perl6 implementation, is written in Haskell. Darcs, the best RCS IMAO, is written in Haskell
11:33:29 <mwc> perlIsBetter, http://www.pugscode.org/
11:33:31 <lambdabot> The title of that page is "Pugs - pugscode"
11:35:44 <ValarQ> is there any way to make cabal use multiple processes?
11:35:59 <mwc> it'd be sweet if it could hook into distcc
11:36:24 <mwc> ValarQ, in my experience, trying to parallel make haskell packages leads to bad
11:36:34 <mwc> but that's just a few times I've tried it
11:37:05 <mwc> and those were with Makefiles. I'm sure a smarter system like Cabal could figure it out
11:37:14 <ValarQ> mwc: it's not a problem with ghc
11:37:25 <mwc> no, I think it was the makefiles themselves
11:37:35 <yip> is the ghc --make logic able to output a normal makefile?
11:38:15 <xerox> GHC can produce a dependency list palatable to make, somehow.
11:38:23 <ValarQ> mwc: the problems with ghc used to be the dependency checking, so there were not a problem with make being stupid
11:39:08 <ValarQ> but i got here this source distribution of a haskell library that uses cabal
11:40:15 <ValarQ> and i got myself a SMP system, so i'm quite curious on how i can speed it up
11:40:44 <mwc> Submit a feature request to cabal?
11:41:42 <ValarQ> mwc: does that mean that the feature doesn't exist?
11:42:10 <mwc> not that I know of
11:42:18 <mwc> and not that a cursory glance of the TOC of the docs revealed
11:42:54 <perlIsBetter> ok
11:42:59 <perlIsBetter> what do I do to learn haskell
11:43:03 <perlIsBetter> I have the bugger instaslled
11:43:06 <perlIsBetter> on debian
11:43:11 <davidhouse> @google learning site:haskell.org
11:43:13 <lambdabot> http://www.haskell.org/learning.html
11:43:17 <perlIsBetter> looks liek it gave me 6.2
11:43:22 <perlIsBetter> how do I get 6.4 on debian
11:43:34 <Taral> perlIsBetter: unstable
11:43:35 <perlIsBetter> I somehow have to make my distro got 'unstable' using apt-get I think
11:43:39 <davidhouse> @google ghc downloads site:haskell.org
11:43:39 <perlIsBetter> hm
11:43:40 <lambdabot> http://haskell.org/ghc/download.html
11:43:41 <davidhouse> Taral, no it's not
11:43:42 <neologism> perlIsBetter: for learning haskell I dont think it matter much
11:43:48 <perlIsBetter> oh?
11:43:54 <perlIsBetter> but I want the latest!!
11:43:55 <Taral> davidhouse: 6.4 is available in debian unstable
11:43:56 <perlIsBetter> heh
11:44:03 <perlIsBetter> how to I coax apt to ge tthat?
11:44:04 <davidhouse> The stable branch of GHC is 6.4.
11:44:13 <Taral> yes, and it's available in debian unstable.
11:44:31 <davidhouse> Ah, sorry. I thought you were saying that 6.4 itself was unstable.
11:44:34 <Taral> :)
11:44:37 <ValarQ> :)
11:44:54 <Taral> 6.4 is only unstable when you run into a bug.
11:45:00 <davidhouse> Hehe.
11:45:21 <qwr> you just need stable bugs
11:45:25 <apfelmus> perlIsBetter: for a first start, you might want to try the hugs interpreter. it "compilers" haskell code much faster
11:45:31 <SamB> actually, you could also use testing
11:45:44 <ValarQ> qwr: are you talking about features?
11:45:54 <davidhouse> shapr: you around?
11:46:14 <resiak> perlIsBetter: If you want to install a newer ghc, you should get it from backports.org
11:46:49 <Taral> hm, yesterday's 6.5 x86_64 build is truncated
11:46:56 <Taral> s/build/tarball/
11:49:07 <SamB> apfelmus: well, is that any more useful than GHC 6.2?
11:49:24 <perlIsBetter> ok
11:49:29 <perlIsBetter> I jsut installed this stuff
11:49:44 <perlIsBetter> apt-get update; apt-get install ghc6 ghc6-prof ghc6-doc ghc6-hopengl ghc6-libsrc
11:49:59 <perlIsBetter> seems to give haskell 6.2
11:50:06 <perlIsBetter> should I jsut leave it
11:50:18 <perlIsBetter> will installing the backport work with al these other thingies?
11:50:25 <resiak> http://backports.org/instructions.html
11:50:27 <lambdabot> The title of that page is "Debian Backports - Instructions"
11:51:24 <apfelmus> SamB: well, it could be if one doesn't want to have 6.2 ;-)
11:52:42 <SamB> apfelmus: well the usual reason for wanting 6.4 is: wanting latest/greatest libs/extensions/up-to-date package support
11:56:39 <perlIsBetter> wait
11:56:55 <perlIsBetter> http://backports.org/instructions.html
11:56:56 <lambdabot> The title of that page is "Debian Backports - Instructions"
11:56:57 <perlIsBetter> wait
11:57:16 <perlIsBetter> etc apt prefeences doesnt exist for my system
11:57:18 <perlIsBetter> !!
11:58:02 <Cale> perlIsBetter: It exists on my system, but it's empty
11:58:34 <apfelmus> SamB: right. but for dirty code from scratch i prefer hugs: faster loading times (ghci takes a bit)
11:59:04 <SamB> just make one
11:59:17 <SamB> only spell it right, of course
11:59:18 <apfelmus> perlIsBetter: 
12:01:08 <perlIsBetter> oh shit its working I think
12:01:26 <perlIsBetter> wow
12:01:30 <perlIsBetter> linux does work
12:01:34 <perlIsBetter> fuck these microsft fucks
12:01:37 <perlIsBetter> and lazy managers
12:01:52 <perlIsBetter> Apparently lisp smalltalk and haskell can far outdo dot net
12:01:59 <perlIsBetter> Im unsure though
12:02:03 <perlIsBetter> not enuf experience
12:02:09 <perlIsBetter> damn i dont even program bash
12:02:14 <vincenz> hiya Cale 
12:02:14 <perlIsBetter> but I want to leap frog to haskell
12:02:21 <perlIsBetter> can I do ok without an cs degree?
12:02:43 <HasKellIsBetter> heh
12:03:39 <dmhouse> HasKellIsBetter: good choice. :)
12:03:53 <dfeuer> hmmmm
12:04:39 <HasKellIsBetter> I want new powers
12:04:49 <HasKellIsBetter> that dwarf the perl trolls and ASP trolls
12:04:53 <araujo> HasKellIsBetter, be careful
12:04:57 <apfelmus> HasKellIsBetter: welcome convert, welcome to the church of the great lambda. may the higher order guide you.
12:05:05 <araujo> More powers always bring more responsabilities
12:05:09 <araujo> :-)
12:05:16 <HasKellIsBetter> ah thespiderman quote
12:05:20 <HasKellIsBetter> am I a fool then?
12:05:24 <HasKellIsBetter> to tinker with sorcery
12:05:32 <HasKellIsBetter> should I use tried and true perl?
12:05:39 <HasKellIsBetter> or ruby or something
12:05:45 <HasKellIsBetter> jeez
12:05:48 <HasKellIsBetter> I dont know
12:06:05 <araujo> HasKellIsBetter, no, my only advice is that you should stay away from haskell unless you don't want to hate the other languages.
12:06:22 <araujo> i mean, want 
12:06:25 <araujo> :-)
12:06:35 <dfeuer> now, now...  
12:06:44 <dfeuer> There are other good languages.
12:06:59 <dfeuer> ML has a better module system. 
12:07:02 <dfeuer> Scheme has macros.
12:07:52 <qwr> yes, those will also contaminate you.
12:08:40 <Excedrin> perl is worse contamination than ML or Scheme
12:09:22 <qwr> but cobol should be safe choice to not starting hate other languages ;)
12:09:32 <SamB> C++ has templates, at least
12:09:54 <dfeuer> Contaminate?
12:10:05 <dfeuer> They will show you that Haskell is not perfect in every way.
12:10:09 <dfeuer> There's nothing wrong with that.
12:10:22 <dfeuer> I typed up some types, and they look awful:
12:10:23 <dfeuer> data SMaybe a = SNothing | SJust !a
12:10:23 <dfeuer> data SPair a b = SPair !a !b
12:10:23 <dfeuer> data Node d a = Node !a !d !a !(SMaybe (SPair d a)) deriving Show
12:10:23 <dfeuer> data Leaf d = Leaf !d !(SMaybe d) deriving Show
12:10:23 <dfeuer> data Tree23_ d a = Zero !a | Succ !(Tree23_ d (Node d a)) deriving Show
12:10:27 <dfeuer> type Tree23 d = Tree23_ d (Leaf d)
12:10:41 <dmhouse> Yes, Haskell needs better strictness support.
12:11:24 <dmhouse> We also need better records and a more flexible pseudocode system that doesn't have the fugliness of TH. Not even the zealots should argue that Haskell is perfect.
12:12:18 <dmhouse> Hey davidwaern. How's Haddock?
12:12:38 <davidwaern> dmhouse, hey! haddock is fine :)
12:12:53 <araujo> Far from perfect, i do think it is better than most of the stuff out there.
12:13:01 <davidwaern> dmhouse, I'm halfway through the parser
12:13:14 <dmhouse> davidwaern: Good stuff! I'll have to darcs pull.
12:13:56 * dfeuer suspects it's probably better to make strict be the default.
12:14:18 <dmhouse> dfeuer: that would break a lot of programs.
12:14:23 <dmhouse> > take 10 [1..]
12:14:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:14:36 <dmhouse> > take 10 $! [1..] -- ($!) is strict function application
12:14:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:14:52 <dmhouse> Hmm. I expected _that_ to break.
12:15:32 <dfeuer> dmhouse, umm....  obviously that would not be a backwards compatible change!
12:16:00 <resiak> > take 10 ([1..] `seq` [1..])
12:16:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:16:04 <resiak> !
12:16:28 <dfeuer> resiak, that's not gonna help.
12:16:33 <dmhouse> I think infinite lists are a bit funky when you're talking about _|_.
12:16:44 <apfelmus> dmhouse: ($!) [1..] only matches the outer constructor. [1..] == 1:... /= _|_. you need some kind of deepSeq
12:16:45 <resiak> Mm, no, it's not, is it?
12:16:49 <johnnowak> dfeuer: it could be if it was doable via a declaration, no?
12:17:00 <dmhouse> apfelmus: Ah.
12:17:16 <kolmodin> dmhouse: I think that $! as well as 'seq' only will force to see if there is at least one element in the list
12:17:18 <dfeuer> johnnowak, it'd be a very different language.
12:17:19 <dmhouse> johnnowak: That'd be good. {-# STRICT #-}
12:17:32 <dfeuer> kolmodin, it just distinguishes between a pair and a null.
12:17:46 <kolmodin> what?
12:18:34 <dfeuer> list `seq` a   will evaluate list until it knows whether it's empty or not, and then evaluate a.
12:19:01 <kolmodin> if the list was written as data List a = Nil | Cons a (List a)   then $! and 'seq' would only force enough to see which constructor it is
12:19:05 <kolmodin> right
12:19:35 <dfeuer> Right.
12:19:48 <dfeuer> It tells a:b from []
12:19:53 <kolmodin> yeah
12:20:51 <Taral> does ghc 6.5 do parallel (smp) make by default, or do you have to turn something on?
12:27:11 <dmhouse> Are there any examples of monads representing computations with a specific type of outcome, apart from Maybe and []?
12:27:37 <dmhouse> Those two comprehensively cover the interesting cases of '0 or 1' and '0 or many', I suppose.
12:27:57 <dfeuer> There's IO....
12:28:04 <dmhouse> Writer, I suppose.
12:28:11 <dfeuer> And the state monad.
12:28:13 <dfeuer> writer?
12:29:07 <dmhouse> dfeuer: Not what I meant. The main point of State and IO is to encapsulate details, like threading state through. The main point of Maybe and [] is to sequence like operations together.
12:29:26 <apfelmus> @hoogle Writer
12:29:27 <lambdabot> Control.Monad.Writer :: module
12:29:27 <lambdabot> Control.Monad.Writer.Writer :: (a, w -> Writer w a)
12:29:27 <lambdabot> Control.Monad.Writer.Writer :: newtype Writer w a
12:29:27 <dfeuer> ?
12:29:45 <dmhouse> Hmm. I'm not explaining this well.
12:29:50 <dfeuer> not really, no.
12:30:03 * dfeuer has some trouble with monads.
12:30:07 <dmhouse> I suppose there's a weak division between Maybe/[] and the rest of the monads, if at all.
12:30:54 <dmhouse> Huh? What's with that second Hoogle result?
12:35:12 <apfelmus> dfeuer: Maybe and [] represent nondeterministic computation (may fail or give multiple results). they rmain purity (only the parameters determine the result(s))
12:35:59 <dfeuer> ....
12:36:41 <dmhouse> apfelmus: but then that's true of State too, only we're hiding some of the parameters.
12:36:50 <apfelmus> dmhouse: it's likely to be a bug
12:36:59 <dmhouse> Huh?
12:37:07 <dmhouse> Oh, the Hoogle thing.
12:37:22 <dmhouse> @karma- conversational parallelism
12:37:22 <lambdabot> conversational's karma lowered to -1.
12:39:56 <apfelmus> dmhouse: yes, state hides (some) parameters and that leads step by step into non-pure (meta)semantics
12:40:35 <dmhouse> @tell ndm a @hoogle Writer produced 'Control.Monad.Writer.Writer :: (a, w -> Writer w a)'
12:40:35 <lambdabot> Consider it noted.
12:53:18 <Taral> that's a neat feature (@tell)
12:54:02 <dfeuer> Someone remind me of the syntax for case?
12:54:17 <dfeuer> case x of Pat a = a   ?
12:54:40 <dmhouse> case x of Pat a -> a
12:54:47 <araujo> > let f = 1 in case f of 0 -> "hi" ; 1 -> "world"
12:54:48 <lambdabot>  "world"
12:54:53 <dfeuer> oh yeah.
12:55:19 <dmhouse> > let f x = case x of y:_ -> y; _ -> "empty" in (f "hello", f "")
12:55:20 <lambdabot>  Couldn't match `[Char]' against `Char'
12:55:30 <dmhouse> > let f x = case x of y:_ -> y; _ -> error "empty" in (f "hello", f "")
12:55:31 <lambdabot>  Exception: empty
12:55:39 <dmhouse> Taral: thankyou. :)
12:55:48 <Taral> :)
13:10:43 <dfeuer> oy...
13:10:47 <dfeuer> this is getting confusing.
13:11:41 <dfeuer> nested types break my brain.
13:16:08 <palomer> eh?
13:26:12 <HasKellIsBetter> how does haskell compare to say
13:26:16 <HasKellIsBetter> java 5?
13:26:33 <HasKellIsBetter> Imsetting up jboss and sun jdk 5 now on this debina box
13:26:40 <HasKellIsBetter> can haskell outdo those things?
13:26:44 <HasKellIsBetter> if I learn it?
13:26:47 <HasKellIsBetter> if so how?
13:26:49 <dmhouse> @faq
13:26:50 <lambdabot> The answer is: Yes! Haskell can do that.
13:27:25 <BCoppens> dmhouse: lol :)
13:27:44 <dmhouse> Haskell can do everything Java can (as they're both Turing-complete ;)).
13:27:50 <BCoppens> :P
13:27:55 <xerox> > compare "haskell" "Java5"
13:27:57 <lambdabot>  GT
13:27:57 <dmhouse> It depends on yor preferences as to which one you use.
13:28:11 <dmhouse> xerox: hehe! :) Using capitals is cheating.
13:28:20 <neologism> dmhouse: there's one thing haskell wont give you while java will do... a job ;(
13:28:40 * xerox got a job in Haskell
13:28:46 <xerox> (Two, in fact.)
13:28:47 <dropdrive> xerox, what do you do?
13:28:51 <dmhouse> SoC?
13:29:01 <xerox> I do work on Cabal.
13:29:03 <xerox> (Yes.)
13:29:09 <neologism> xerox: you do SoC?
13:29:13 * xerox nods
13:29:16 <sieni> I thought he was working at galois
13:29:22 <neologism> xerox: me too :)
13:29:31 <xerox> neologism - So why you are so negative! :)
13:29:31 <dmhouse> neologism: Which project is yours?
13:29:41 <neologism> dmhouse: I dont do haskell project
13:29:47 <xerox> Ah, that's why!
13:30:16 <dmhouse> Ah, okay. *cough* traitor *cough*. What are you contributing to then? :)
13:30:58 <neologism> freebsd
13:31:43 <xerox> neologism - Which project
13:31:47 <xerox> s/$/\?/1
13:32:08 <dmhouse> xerox, 1 modifier?
13:32:16 <neologism> xerox: linuxolator update
13:34:40 <xerox> neologism - What is it?
13:34:49 <neologism> linux emulation layer on fbsd
13:34:57 <neologism> you can run linux progams in fbsd 
13:37:05 <xerox> Everybody is doing virtualization/emulation these days!
13:37:16 <neologism> its not virtualizaition/emulation :)
13:37:19 <neologism> its just.. translation
13:37:26 <sieni> I thought there wasn't much emulation there
13:37:46 <dmhouse> neologism: Analoguous to wine? In terms of it not being an emulator.
13:37:54 <neologism> dmhouse: I am not familiar with wine
13:38:35 <dmhouse> It's basically an implementation of the Win32 DLLs on top of X and linux.
13:39:18 <sieni> http://www.freebsd.org/doc/handbook/linuxemu-advanced.html
13:39:19 <lambdabot> The title of that page is "Advanced Topics"
13:40:37 <sieni> lambdabot: stfu, please
13:40:47 <neologism> welll.. the linuxollator in fbsd does basically that linux_syscall is mapped to fbsd syscall with flags etc. translated
13:40:50 <neologism> + some other magic stuff
13:40:56 <dropdrive> does anyone know why the haskell-prime mailing list is completely dead?
13:40:56 <neologism> I am extending it to be 2.6.x compatible
13:41:14 <dropdrive> i was sort of reading it...not that i really understood anything, but it was sort of interesting
13:41:23 <sieni> neologism: ahh, cool
13:43:08 <neologism> sieni: not much :) its hard
13:45:35 <davidwaern> dropdrive, I'm wondering too
13:46:28 <sieni> svrjeeeee!!!!!
13:47:26 <noj> :)
13:48:58 <sieni> that was almost as cool as germany's winning goal yesterday
13:49:52 <davidwaern> that was good
13:51:31 <noj> yeah
13:51:32 <sieni> \o/
14:15:54 <Dino_> Is there a more concise way of doing this:  let first = head foo; let everythingElse = tail foo  ?
14:16:09 <Trevion> let (first:rest) = foo
14:16:33 <Dino_> The pattern matching work everywhere, does it.
14:16:40 <Trevion> Generally, yes.
14:17:21 <Dino_> I also was able to reduce some code by using a pattern like: (a,b) <- actionCreatingTuple
14:17:40 <Dino_> elsewhere
14:18:18 <dmhouse> The one slight annoyance is that patterns aren't firstclass.
14:19:30 <SamB> everywhere binding is done, pattern matching is allowed
14:19:53 <Philippa> dmhouse: transformational patterns'd pretty much fix that
14:20:25 <Dino_> Hm. this let (...) isn't working
14:20:34 <Philippa> I forget who I was talking to about this, but most of the use cases're either predicates or doing something akin to views
14:21:14 <dmhouse> Hmm. Transformational patterns?
14:21:23 <dmhouse> Dino_: what have you written?
14:21:28 <Dino_> In my case, the foo is [String]
14:21:56 <dmhouse> Sure. What's your source?
14:22:00 <Dino_> Well, I can't make send it all to the bot, but I get the same error this way:
14:22:10 <Dino_> > let (a,b) = ["foo", "bar"]
14:22:10 <lambdabot>  Parse error
14:22:29 <dmhouse> > let (a,b) = ["foo", "bar"] in a
14:22:29 <lambdabot>  Couldn't match `(a, b)' against `[a1]'
14:22:36 <dmhouse> Oh, right.
14:22:39 <dmhouse> > let (a:b) = ["foo", "bar"] in a
14:22:40 <lambdabot>  "foo"
14:22:41 <Trevion> > let (a:b) = ["foo", "bar"] in a
14:22:42 <lambdabot>  "foo"
14:22:47 <Trevion> argh, too slow
14:22:52 <Dino_> Now, what does that mean?
14:22:56 <Philippa> dmhouse: http://citeseer.ist.psu.edu/299277.html
14:22:58 <lambdabot> The title of that page is "Pattern Guards and Transformational Patterns - Erwig, Peyton (ResearchIndex)"
14:23:02 <Trevion> > let [a,b] = ["foo", "bar"] in b
14:23:03 <lambdabot>  "bar"
14:23:10 <Trevion> > let (a:b) = ["foo", "bar"] in b
14:23:11 <lambdabot>  ["bar"]
14:23:21 <dmhouse> Yep, [a,b] is totally equivalent to a:b:[].
14:23:21 * Trevion laughs.
14:23:25 <Philippa> lambdabot: http://goatse.cx
14:23:27 <Trevion> I just printed that paper.
14:23:35 <bolrod> Philippa: plz
14:23:38 <Philippa> Trevion: postscript associated with printer?
14:23:43 <bolrod> :)
14:23:49 <Philippa> bolrod: just testing the spammy bot feature...
14:24:01 <bolrod> some printers can print postscript I think..
14:24:15 <Philippa> you think? It's the whole point of it
14:24:21 <bolrod> :)
14:24:35 <bolrod> well.. the printer itself.. or the driver on your OS
14:24:58 <Dino_> Oh, I think I know, I'm trying to: let (a,b) = [String]  when it should be: let (a:b) = [String]
14:25:03 <Trevion> We have a PS-capable printer here.. otherwise the boss wouldn't be able to tie it up for entire weekends evaluating his hand-written recursive PS.
14:25:30 <dfeuer> Real printers print PostScript.
14:25:47 <Dino_> Which is what Travion first said. :/
14:26:05 <dmhouse> Philippa: before I dive into the paper, does it allow ++ patterns?
14:26:29 <bolrod> Dino_: (a,b) is a tuple 
14:26:36 <bolrod> you can't match a tuple with a list
14:27:02 <bolrod> > let [a,b,c] = [2,3] in a  
14:27:03 <lambdabot>  Irrefutable pattern failed for pattern [a, b, c]
14:27:34 <Philippa> dmhouse: not directly, but you could probably fake it. You're better off using guards and equality anyway though
14:27:53 <dfeuer> ++ patterns?
14:28:14 <Dino_> Thanks, guys.
14:28:20 <dmhouse> dfeuer: It's nice for matching strings. E.g. case msg of ("hello" ++ x) -> x
14:28:29 <Trevion> I've written classes to simulate first class pattern matching...
14:28:31 <bolrod> erh.. prefix?
14:28:38 <Philippa> dmhouse: there're other ways of doing that...
14:28:42 <dmhouse> At the moment you have to do case msg of 'h':'e':'l':'l':'o':x -> x
14:28:48 <bolrod> O_o
14:28:49 <dmhouse> Philippa: of course, but that's the idea.
14:28:52 <Cale> what does  f (x ++ y) = x  give?
14:28:56 <bolrod> @index prefix
14:28:57 <lambdabot> Distribution.Simple.LocalBuildInfo, Distribution.Simple.Configure
14:29:03 <bolrod> hrm
14:29:05 <dfeuer> dmhouse, yuck.
14:29:09 <bolrod> @index isPrefix
14:29:09 <lambdabot> bzzt
14:29:19 <Cale> dmhouse: no you don't, just use a guard
14:29:21 <bolrod> yo.. it has to be somewhere..
14:29:23 <Trevion> case msg of x | "hello" `isPrefixOf` x -> drop 5 x
14:29:24 <Trevion> right?
14:29:31 <Cale> yeah
14:29:33 <dmhouse> Trevion: right.
14:29:34 <Trevion> is there a version of isPrefixOf that splits?
14:29:45 <Dino_> Thanks guys.
14:29:54 <dmhouse> Dino_: have fun :)
14:30:21 <dmhouse> Trevion: hmm. Not that I know of.
14:30:41 <dfeuer> What're those experimentalish guard thingies?
14:30:48 <bolrod> @type isPrefixOf
14:30:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:30:57 <dmhouse> > dropWhile (uncurry (==)) $ zip "hello" "hello world"
14:30:58 <lambdabot>  []
14:31:07 <dmhouse> Hmm. zip isn't quite what we need.
14:31:12 <dmhouse> dfeuer: pattern guards?
14:31:40 <dfeuer> yeah.
14:31:53 <dfeuer> I can't remember how that goes.
14:32:05 <bolrod> just drop the length of the string you match the prefix with
14:32:09 <bolrod> ^.0?
14:32:09 <dmhouse> Things like: let x | Just 4 <- lookup map key = "yes, it matches" | otherwise = "nope"
14:32:31 <dfeuer> nice.
14:32:42 <dmhouse> dfeuer: basically, you get pattern does match = true, pattern doesn't match = false, and you get bindings.
14:33:16 <Philippa> I'd like to know if there's a good reason beyond lack of demand that transformational patterns never made it into GHC
14:33:28 <dfeuer> ya....
14:33:35 <dfeuer> transformational patterns?
14:33:38 <dmhouse> Philippa: Well, the Hackfest's coming up :)
14:33:54 <bolrod> @hoogle [a]->[a]->Bool
14:33:54 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
14:33:55 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
14:34:09 <Trevion> @hoogle [a] -> [a] -> Maybe [a]
14:34:10 <lambdabot> No matches, try a more general search
14:34:25 <Philippa> dfeuer: I linked to a paper already, same one pattern guards were introduced in...
14:34:34 <Philippa> basically, they're why views're a sucky idea :-)
14:34:40 <dfeuer> I missed it....
14:34:43 <dmhouse> It's ooold, it references FiniteMaps :)
14:34:52 <dfeuer> What's wrong with a FiniteMap?
14:34:53 <dmhouse> @google transformational patterns haskell
14:34:54 <lambdabot> http://citeseer.ist.psu.edu/299277.html
14:35:03 <dmhouse> dfeuer: FiniteMaps are deprecated in favour of Maps.
14:35:05 <Trevion> The title of that page is "Pattern Guards and Transformational Patterns - Erwig, Peyton (ResearchIndex)"
14:35:18 <dmhouse> Thankyou, Trevionbot. :)
14:35:28 <Trevion> Just figured somebody would miss it...
14:35:29 <bolrod> :D
14:35:43 <dfeuer> I think I looked at it a while back.
14:36:05 <bolrod> so anyway.. you don't 'need'  ++ pattern matching
14:36:07 <dfeuer> They just changed the name?
14:36:30 <dmhouse> Of what?
14:36:33 <Philippa> no, it's a different implementation
14:37:52 <dfeuer> What is it now?
14:38:00 <bolrod> > let mem = if "test" == take 4 "testtest"  then 1 else 2 in mem
14:38:01 <lambdabot>  1
14:38:02 <dfeuer> And why should the implementation be linked to the name?
14:38:05 <bolrod> :)
14:38:47 <dmhouse> dfeuer: What are you refering to?
14:39:01 <dfeuer> Map vs. FiniteMap.
14:42:48 <dmhouse> Ah, transformational patterns look cool.
15:06:47 <Pete_I> what does this mean? "read :: Read a => String -> a"
15:07:12 <Pete_I> i know it's a type declaration, but where can i read about these wierd things?
15:07:26 <mathewm> the haskell-98 report, mostly
15:07:39 <Pete_I> alright, thanks
15:07:56 <mathewm> http://www.haskell.org/onlinelibrary/index.html
15:07:57 <lambdabot> The title of that page is "The Haskell 98 Language Report"
15:09:11 <bolrod> really... this plugin is really annoying
15:09:30 <mathewm> I kinda thought it was cool
15:09:57 <xerox> Did you know that liquid oxygen can hang on a magnet? Crazy.
15:10:42 <bolrod> it's cool when you can choose to let it post the title
15:11:01 <Pete_I> it is.
15:11:01 <bolrod> like   !http://..etc.
15:11:02 <lambdabot> The title of that page is "ERROR: The requested URL could not be retrieved"
15:11:03 <bolrod> or something
15:11:11 <sieni> did you know that a frog can be made to levitate using a magnet: http://www.hfml.ru.nl/pics/Movies/frog.mpg
15:11:12 <bolrod> OFCOURSE it gives an error >:(
15:11:41 <bolrod> yes... everything can.. if the magnet is strong enough :)
15:11:43 <xerox> sieni - Yup, I knew that!
15:11:51 <dfeuer> !http://whitehouse.com
15:11:51 <Pete_I> sieni, i doubt it, and i don't care.
15:11:59 <xerox> sieni - Let me point you to the liquid oxygen experiment.
15:12:03 <lambdabot> The title of that page is "Whitehouse"
15:12:12 <revision17_> sieni: woah that frog video is crazy!
15:12:26 <revision17_> if I were that frog I'd be totally freaking out
15:12:26 <xerox> sieni - Last 10 minutes I believe. http://mfile.akamai.com/7870/rm/mitstorage.download.akamai.com/7870/8/8.02/videolectures/wl-802-lec21-220k.rm
15:13:22 <sieni> Pete_I: they got Ig Nobel in Physics year 2000 for the frog levitation experiment!!1!
15:13:53 <bolrod> is that guy dutch?
15:14:40 <xerox> bolrod - I don't think that everything can be made levitating by itself in a strong magnet. Nope.
15:15:01 <bolrod> hah.
15:15:16 <bolrod> my aunt has a  thermometer like that
15:15:28 <xerox> hehehe.
15:15:31 <bolrod> really cool things :)
15:16:17 <bolrod> I think that guy is dutch.. at least.. he speaks dutchy english
15:17:51 <Pete_I> dutchy? is that a word?
15:18:01 <bolrod> hell I don't know
15:20:39 <bolrod> Walter H. G. Lewin is currently a professor of Physics at the Massachusetts Institute of Technology. He earned his Ph.D. in Nuclear Physics at the University of Delft in 1965 in the Netherlands
15:20:43 <bolrod> yep :)
15:21:06 <xerox> I like the way he talks.
15:21:44 <xerox> He has got a funny `r' at times (:
15:22:12 <bolrod> ?
15:23:58 <HasKellIsBetter> isnt physics kinda uselss these days
15:24:17 <HasKellIsBetter> arent they jsut nerds geeting degrees from other nerds in high priced govet research grants that dont produce anythiung?
15:24:31 <Pete_I> couldn't be further from the truth. we use physics every day.
15:24:49 <Pete_I> you don't need a degree to use physics
15:25:05 <HasKellIsBetter> is haskell better than perl?
15:25:17 <Pete_I> HasKellIsBetter, they can't be compared.
15:25:24 <Pete_I> they're from totally different paradigms
15:26:07 <Pete_I> you'll have to try both and see which you like better.
15:26:08 <dfeuer> forall x . x is better than Perl.
15:26:21 <sieni> even python?
15:26:29 <xerox> dfeuer - Now you have to provide a program that proves that type :-)
15:26:42 <dfeuer> That's not a type.
15:26:45 <dfeuer> Just a statement.
15:26:50 <aFlag> i was reading parsec documentation and it says at some point http://www.rafb.net/paste/results/MGeb4A35.html why would testOr2 be better than testOr3?
15:27:04 <dfeuer> actually, a sentence
15:27:24 * xerox throws lambda-cubes to dfeuer 
15:27:42 <anonfunc> aFlag: because the two stings share a prefix of (
15:28:22 <sieni> I heard that people do stuff, like build bridges, design new materials, build microprocessors and hard drives with extreme miniaturization, but no, they don't need physics for that kind of jobs
15:28:26 * dfeuer juggles the lambda-cubes.
15:28:55 <dfeuer> You need physics for designing microprocessors.
15:29:07 <xerox> He is being sarcastic.
15:29:07 <sieni> also physics is completely unneeded in designing aeroplanes or cars
15:29:09 <Pete_I> i think he was being sarcastic...
15:29:18 * xerox throws more cubes
15:29:38 <Pete_I> we don't need physics to tell us how wide the road needs to be at the turns....
15:29:46 <Pete_I> or what the speedlimit should be...
15:30:10 <bolrod> that's true
15:30:22 <bolrod> in Germany they'd not bothered with that for a long time I gues
15:30:23 <bolrod> s
15:30:31 <bolrod> speed limits that is
15:30:35 <anonfunc> aFlag: I totally meant string, and it's explained in the section on predictive parsing
15:30:46 <Pete_I> lasers are cool
15:31:12 <sieni> physicists are not needed, since nowadays the world is full teenage java and .net coders that already know everything
15:31:26 <Pete_I> haha
15:31:35 <aFlag> anonfunc, oh, ok, i read on then
15:31:56 <bolrod> you need physicists to educate new physicists
15:32:02 <anonfunc> aFlag: yep. have fun :)
15:36:47 <HasKellIsBetter> well in my humble estimation we have a lot of technology
15:36:53 <HasKellIsBetter> adn skyscrpers n cars
15:37:09 <HasKellIsBetter> its getting people to learn and use science and technoogy
15:37:31 <HasKellIsBetter> I had 3 people today tell me I m crazy to choose haskell as a first progrmaming language
15:37:39 <HasKellIsBetter> and that lisp is 40 yars old and sucks
15:37:40 <Pete_I> nah
15:37:45 <HasKellIsBetter> yet every time I come online and read
15:37:47 <Pete_I> lisp doesn't suck.
15:38:01 <HasKellIsBetter> haskell, smalltalk, and lisp seem to be at the front curve of technology and power
15:38:12 <HasKellIsBetter> but people think im insane
15:38:18 <HasKellIsBetter> they also tell me linux sucks
15:38:19 <Pete_I> it's sad that so many people are concerned with what "sucks"
15:38:22 <palomer> lisp sucks, then again so does haskell
15:38:39 <palomer> linux does suck
15:38:42 <Excedrin> all OSes suck, all software sucks
15:38:43 <HasKellIsBetter> heh
15:38:48 <Pete_I> none of the stuff sucks, or people wouldn't use it. it's just different.
15:38:53 <HasKellIsBetter> well which things sucks least?
15:39:00 <Pete_I> brainfuck, there's a language that sucks.
15:39:03 <HasKellIsBetter> LOL
15:39:03 <palomer> depends what you want
15:39:11 <HasKellIsBetter> I want money women adn ahppiness
15:39:24 <palomer> then haskell sucks the most
15:39:46 <Pete_I> go with perl. you can obfuscate your code for job security
15:39:57 <Excedrin> if you're new to programming in general, you should find good "intro to programming" sorts of material, which shouldn't matter much which language it is
15:40:54 <dfeuer> Pete_I, I think probably the language best for learning, and also best for obfuscation, is probably Scheme.
15:41:28 * dfeuer removes an extra "probably"
15:41:50 <Pete_I> you may be right.
15:41:57 <Pete_I> i've yet to study scheme.
15:43:11 <dfeuer> Well, it has no type system, which kind of sucks.
15:43:17 <dfeuer> But it's really great otherwise.
15:43:36 <dfeuer> Really good for learning though....
15:47:37 <Pete_I> no type system?
15:47:54 <Pete_I> how can it have no type system?
15:50:31 <dfeuer> Pete_I, I guess you could call it a unitype system, or "dynamic type" system.
15:50:46 <Pete_I> unitype? it only has one type?
15:50:55 <Pete_I> sounds like a pain...
15:52:15 <SamB> Pete_I: the only type is Duck
15:53:04 <dfeuer> Pete_I, you are familiar with the concept of a language without a static type system, no?
15:55:21 <anonfunc> i always thought the best description of the lisp type systems was typed values and untyped variables :-P
15:55:51 <dfeuer> Basically,
15:56:56 <dfeuer> data Number = .....   data String = ....  data Character = .... 
15:57:54 <dfeuer> data Thing = Number | String | Character | Function (Thing -> Thing) | Pair Thing Thing | Null
15:58:46 <Pete_I> hmm. interesting
15:59:08 <dfeuer> And everything is a Thing.
15:59:15 <dfeuer> (I probably missed some)
15:59:43 <dfeuer> (oh, and I definitely missed the fact that a Function is some sort of IO type.
15:59:47 <dfeuer> )
16:12:24 <Pete_I> "read :: Read a => String -> a"
16:12:29 <Pete_I> er, wrong paste.
16:12:41 <Pete_I> "Last generator in do {...} must be an expression"
16:12:44 <Pete_I> what's this mean?
16:13:06 <Pete_I> what does it mean by "expression"?
16:14:06 <bolrod> it musn't be something like    x <- ...
16:14:31 <bolrod> it must be an expression which has the return type of the do block
16:15:19 <bolrod> since it's the last thing that is executed in the do block.. it must have that type
16:16:49 <Pete_I> ...do has a type?
16:17:55 <mauke> no, every do block has a type
16:21:18 <xerox> G'nite.
16:28:08 <palomer> night, brother
17:06:16 <dfeuer> Is that a Cale?
17:07:38 <Cale> yes
17:07:45 <dfeuer> data SMaybe a = SNone | SJust !a
17:07:45 <dfeuer> data SPair a b = SPair !a !b
17:07:45 <dfeuer> data Node d a = Node !a !d !a !(SMaybe (SPair d a)) deriving Show
17:07:45 <dfeuer> data Leaf d = Leaf !d !(SMaybe d) deriving Show
17:07:45 <dfeuer> data Tree23_ d a = Zero !a | Succ !(Tree23_ d (Node d a)) deriving Show
17:07:45 <dfeuer> type Tree23 d = Tree23_ d (Leaf d)
17:07:48 <dfeuer> Isn't that gross?
17:07:54 <Cale> hehe
17:08:07 <dfeuer> Oh, and it's missing two deriving clauses.
17:08:37 <dfeuer> I finally figured out membership testing.
17:08:43 <dfeuer> I haven't even attempted insertion yet.
17:08:56 <dfeuer> (still trying to optimize membership testing.
17:09:17 <dfeuer> You think there's any way to make those types nicer, without compromising efficiency?
17:09:57 <Cale> why make it completely strict like that?
17:10:21 <dfeuer> Because when used as a search tree, it is.
17:10:59 <Cale> oh, this is interesting... failed root login attempts from 61.129.57.229
17:11:04 <dfeuer> ooooh
17:13:03 <differentActGetD> is haskell more powerful than any jedii?
17:13:46 <mauke> what's a jedii?
17:15:24 <dfeuer> Cale, don't you think the type should be strict if its use is, to avoid unnecessary checks?
17:15:39 <dfeuer> or indirectness
17:15:41 <dfeuer> or whatever?
17:15:51 <Cale> dfeuer: well, if it comes down to needing that for efficiency.
17:16:20 * dfeuer wants to code perfectly
17:16:21 <Cale> I usually don't start out making my types strict, I'll add those annotations if it becomes a problem
17:16:43 <Cale> (since, as you mentioned, they do add a lot of noise)
17:17:13 <dfeuer> Ah, but the only reason _not_ to use the annotations is to be able to use standard Maybes and tuples, and then going back to change that is a big mess.
17:17:29 <dfeuer> the !s aren't the problem.
17:17:50 <dfeuer> especiallly tuples.
17:17:55 <dfeuer> That's the real annoyannce.
17:20:25 <Cale> hmm, that IP address is apparently in china
17:30:00 <lambda_the_insig> does anyone know of any large/complicated regression tests for parsec?  I've adapted Parsec to use FPS as its underlying storage (rather than a list-based String), and I want to run tests against my version to ensure that the behavior hasn't changed.  Something that would be heavy enough to use as a benchmark would be useful as well.
17:30:40 <lambda_the_insig> (I've dubbed it Fast-Packed-Parsec, but I have yet to see if it is faster or not... :D)
17:42:36 <differentActGetD> any databases in haskell?
17:42:41 <differentActGetD> heh
17:45:51 <Cale> differentActGetD: depends on what you mean by that
17:47:10 <Cale> differentActGetD: are you looking for database servers, or libraries for connecting to and manipulating databases?
17:49:08 <Cale> differentActGetD: there's a filesystem written in Haskell, if that counts
17:51:14 <Cale> differentActGetD: http://haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces for DB interfaces
17:51:15 <lambdabot> The title of that page is "Libraries and tools/Database interfaces - HaskellWiki"
17:57:15 <Cale> differentActGetD: is any of that useful?
18:02:20 --- mode: ChanServ set -o dons
18:26:00 <differentActGetD> All the queries and operations are completely expressed within Haskell, no embedded (SQL) commands are needed. This close integration makes it possible to do arbitrary computations on the database (like computing the transitive closure).
18:26:09 <differentActGetD> what is gods name is a ransitive closeure
18:26:18 <differentActGetD> transitive closure
18:26:21 <differentActGetD> pray tell
18:27:33 <Pete_I> it's a mathematical term.
18:27:52 <Pete_I> http://en.wikipedia.org/wiki/Transitive_closure ask someone in #math for a better explanation
18:28:14 <Pseudonym> Hang on, we know what it is here.
18:28:27 <Pete_I> that works too :)
18:28:31 <Pseudonym> :-)
18:28:42 <Pseudonym> A binary relation R is a subset of AxA.
18:28:45 <Pseudonym> Where A is some set.
18:28:56 <Pseudonym> So it's a subset of the Cartesian product of some set with itself.
18:29:08 <Pseudonym> As an example, consider the set of modules in a program.
18:29:19 <Pseudonym> (m1,m2) is in R if m1 imports m2
18:29:26 <Pseudonym> Or consider the set of functions in a program.
18:29:32 <Pseudonym> (f,g) is in R if f calls g.
18:29:37 <Pseudonym> These are common uses in compilers.
18:29:48 <Pseudonym> We write fRg if (f,g) is in R
18:29:54 <Pseudonym> With me?
18:31:54 <dfeuer> Pseudonym, what?
18:32:18 <Pseudonym> I paused for everyone to catch up.
18:32:28 <Pseudonym> You may now ask questions about what I just said, just in case you don't get it.
18:34:16 <dropdrive> can we think of a relation as a directed graph, and a transitive closure as "adding a directed edge from A to B whenever there's a path from A to B"..
18:34:37 <Cale> yes
18:35:08 <Pseudonym> I think this sort of thing is easier to understand concretely.
18:35:22 <Pseudonym> If fRg when f calls g, then f R+ g when f calls g possibly indirectly.
18:35:33 <int-e> (where path = nonempty path)
18:36:11 <Pseudonym> If m1 R m2 when m1 directly imports m2, then m1 R+ m2 when m1 depends, possibly indirectly, on m2.
18:48:30 <Spark> what function do i want to convert [[a,b,c],[d,e,f]] into [a,b,c,d,e,f]
18:48:41 <int-e> concat
18:48:45 <Spark> ta
19:12:58 <Spark> whats integer division in haskell? :)
19:13:06 <Spark> @eval 7/3
19:13:17 <Spark> something like "div" maybe?
19:13:28 <dropdrive> the question is, what is integer division, period?
19:13:59 <Spark> do i just want floor (7/3) then
19:14:16 <Spark> its an operation in the ALU isnt it
19:15:04 <Korollary> @type (/)
19:15:05 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:15:28 <Spark> ?hoogle div
19:15:29 <lambdabot> Prelude.div :: Integral a => a -> a -> a
19:15:29 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
19:15:29 <lambdabot> Control.Exception.DivideByZero :: ArithException
19:15:37 <Spark> @type div
19:15:39 <lambdabot> forall a. (Integral a) => a -> a -> a
19:15:48 <Spark> duh, its just not an infix operator
19:15:55 <Spark> @eval 7 `div` 3
19:16:04 <Spark> @eval x
19:16:08 <Spark> am i braindead?
19:16:32 <sylvan> > 7 `div` 3
19:16:33 <lambdabot>  2
19:16:46 <Dino_> > div 7 3
19:16:47 <lambdabot>  2
19:17:20 <dons> ?run 7 `div` 3 -- can't use eval, its overloaed by the perl6 bot
19:17:21 <lambdabot>  2
19:17:27 <dons> use literate syntax instead
19:18:16 <Spark> wonder why i thought it was &eval
19:18:22 <Spark> faulty wiring
19:18:36 <dons> it used to be eval.
19:18:40 <Spark> ahh
19:18:50 <dons> till about 1 month ago
19:19:19 <Spark> > --
19:19:20 <lambdabot>  Parse error
19:21:16 <dons> > 1 -- test
19:21:17 <lambdabot>  1
19:22:32 <Spark> > 
19:22:33 <lambdabot>  Parse error
19:22:37 <Spark> smallest self-replicating program :)
19:27:18 <int-e> main = putStrLn (s ++ show s) where s = "main = putStrLn (s ++ show s) where s = "
19:31:07 <dropdrive> int-e: nice :)
19:37:26 <Spark> heh
19:37:51 <Spark> > putStrLn (s ++ show s) where s = "> putStrLn (s ++ show s) where s = "
19:37:51 <lambdabot>  Parse error
19:38:02 <Spark> it doesn't do where
19:39:36 <mwolak> why "s ++ show s" instead of just "s ++ s"?
19:39:57 <Korollary> Spark: also see http://sigfpe.blogspot.com/2006/03/general-theory-of-self-reproducing.html
19:39:59 <lambdabot> The title of that page is "A Neighborhood of Infinity: The General Theory of Self-Reproducing Programs"
19:40:13 <Spark> mwolak: show s puts the quotes round it i guess
19:40:29 <mwolak> ahh
19:41:50 <Excedrin> hi lambdabot http://127.1.3.45/
19:41:51 <lambdabot> The title of that page is "ERROR: The requested URL could not be retrieved"
19:42:30 <dons> petekaz: around?
19:42:30 <Excedrin> the potential for abuse of that feature seems high
19:42:39 <dons> it has some protectoin measures
19:42:45 <dons> but can do with more fine tuning
19:43:11 <dons> @tell petekaz I think Url.hs should print nothing if the url is not valid, rather than a 404 error
19:43:11 <lambdabot> Consider it noted.
19:43:22 <Korollary> lambdabot: bookmark http://www.cia.gov/
19:43:27 <dons> Excedrin: it can also be switched off and on, if necessary
19:43:34 <Excedrin> does the machine lambdabot runs on run a web server?
19:43:39 <dons> so far, there's been a fairly positive response
19:43:45 <dons> Excedrin: no
19:43:52 <Excedrin> ok, just checking
19:44:17 <Excedrin> yea, it's a nice feature
19:44:34 <dons> @tell petekaz probably rate limiting would be useful too. there's already code in lambdabot to do this
19:44:34 <lambdabot> Consider it noted.
19:44:52 <Excedrin> btw, that's a valid url, it's just not running a web server (127.x.x.x is the same as 127.0.0.1)
19:45:10 <dons> yeah, i just meant anything that errors
19:46:44 <Spark> since lambdabot doesnt have io, i guess the best you can do for a self-replicating program is:
19:46:47 <Spark> > 0
19:46:48 <lambdabot>  0
19:51:15 <Spark> whats the easiest way of concatenating a list with itself n times? :)
19:51:27 <Spark> like, f 3 [a,b,c] = [a,b,c,a,b,c,a,b,c]
19:51:41 <Spark> some kind of fold?
19:51:48 <Spark> or is there a more clever way
19:51:58 <dropdrive> f 0 _ = []
19:52:07 <Spark> thats worse than the fold
19:52:10 <dropdrive> f n l = l ++ f (n-1) l?
19:53:17 <Spark> > let n = 3 in concat map (\x -> [a,b,c]) [1..n]
19:53:18 <lambdabot>  Not in scope: `c'
19:53:23 <Spark> > let n = 3 in concat map (\x -> ['a','b','c']) [1..n]
19:53:24 <lambdabot>    The function `concat' is applied to three arguments,
19:53:24 <lambdabot>   but its type `[[...
19:53:39 <Spark> > let n = 3 in concat $ map (\x -> ['a','b','c']) [1..n]
19:53:40 <lambdabot>  "abcabcabc"
19:53:46 <dons> > concat $ repeat 3 "haskell"
19:53:47 <lambdabot>    The function `repeat' is applied to two arguments,
19:53:47 <lambdabot>   but its type `a ->...
19:53:51 <Spark> thanks dons :)
19:53:53 <dons> > concat $ replicate 3 "haskell"
19:53:54 <lambdabot>  "haskellhaskellhaskell"
19:54:09 <Spark> @type repeat
19:54:11 <lambdabot> forall a. a -> [a]
19:54:11 <dropdrive> thanks dons...
19:54:31 <Spark> > repeat 1
19:54:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:54:39 <Spark> cool
19:54:43 <dons> > take (3*length "haskell") $ cycle "haskell"
19:54:44 <lambdabot>  "haskellhaskellhaskell"
19:55:05 <Spark> @type cycle
19:55:06 <lambdabot> forall a. [a] -> [a]
19:55:09 <Spark> is that the same as repeat?
19:55:21 <Spark> ah no, i'm being daft
19:55:25 <int-e> repeat a = cycle [a]
19:55:29 <Spark> yeah
19:55:30 <dons> nope. it turns a finite list into an infinite list
19:55:34 <dons> so similar
19:55:44 <dons> > cycle [1,2,3]
19:55:45 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,...
19:55:53 <dons> > repeat [1,2,3]
19:55:54 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2...
19:56:22 <int-e> cycle = concat . repeat
19:56:32 <int-e> (but cycle is more memory efficient)
19:56:43 <dons> > unfoldr (\c -> Just (c,c)) "haskell"
19:56:44 <lambdabot>  ["haskell","haskell","haskell","haskell","haskell","haskell","haskell","haske...
19:56:55 <dons> > concat . take 3 $ unfoldr (\c -> Just (c,c)) "haskell"
19:56:55 <lambdabot>  "haskellhaskellhaskell"
19:57:00 <dons> yeah, cycle is better
19:57:09 <dons> you just get a ptr loop constructed
19:57:42 <Spark> heh
19:58:13 <dons> we use some similar tricks for cycle in lazy bytestrings
19:58:21 <dons> you just replicate the pointers to a single chunk
20:02:06 <dropdrive> @hoogle [a] -> [a]
20:02:07 <lambdabot> Prelude.cycle :: [a] -> [a]
20:02:07 <lambdabot> Prelude.init :: [a] -> [a]
20:02:07 <lambdabot> Prelude.reverse :: [a] -> [a]
20:02:26 <dropdrive> i see...
20:02:49 <int-e> @hoogle-more
20:02:50 <lambdabot> Unknown command, try @list
20:02:57 <int-e> hmm.
20:03:03 <int-e> @list hoogle
20:03:04 <lambdabot> hoogle provides: hoogle hoogle+
20:03:08 <int-e> @hoogle+
20:03:09 <lambdabot> Prelude.tail :: [a] -> [a]
20:03:09 <lambdabot> List.intersperse :: a -> [a] -> [a]
20:03:09 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
20:08:50 <Spark> the other day in here i think i saw someone make a function that combines ["a","b"] ["1","2"] to ["a1","a2","b1",b2"]
20:10:24 <dropdrive> > [ x ++ y | x <- ["a","b"], y <- ["1","2"]]
20:10:36 <dons> ... takes a while for freenode to settle ..
20:10:49 <lambdabot>  ["a1","a2","b1","b2"]
20:11:58 <dropdrive> is there a way to extend pattern-matching, e.g. f 2*n = n; f n = 3*n+1?
20:12:34 <Pseudonym> Have a can of worms.
20:12:45 <Spark> dropdrive: ah cool
20:12:45 <Pseudonym> And a can opener.
20:12:49 <Spark> is that list comprehension
20:12:50 <Pseudonym> Now just wait while I run.
20:13:09 <dropdrive> Spark: yes, i think (beware everything i say as i am a novice)
20:13:11 <Pseudonym> Gofer had (a*n + b) patterns.
20:13:19 <Pseudonym> But even (n+k) patterns are controversial.
20:13:29 <Spark> prolog has more in the way of value matching
20:13:34 <Pseudonym> It's usually considered best practice to avoid them.
20:13:38 <Spark> but prolog is special
20:13:43 <dropdrive> Pseudonym: ah yes, i remember reading about n+k patterns
20:13:45 <Pseudonym> Spark: CLP(R) has even more.
20:14:18 <Spark> you can match constants in haskell cant you?
20:14:29 <Spark> or can you not
20:14:30 <Spark> ive never tried it
20:14:43 <Spark> f 0 = 0  f _ = 1
20:14:55 <Pseudonym> > let { f 0 = 0; f _ = 1 } in f 0
20:14:56 <lambdabot>  0
20:14:56 <Pseudonym> > let { f 0 = 0; f _ = 1 } in f 1
20:14:57 <lambdabot>  1
20:15:02 <Pseudonym> No problem.
20:15:22 <Spark> cool
20:18:08 <dons> > let f 0 = 0; f _ = 1 in f 0
20:18:10 <lambdabot>  0
20:18:23 <dons> braces are for school children with bad teeth ;)
20:18:40 <Spark> what do they do?
20:18:54 <Spark> same as other parentheses?
20:19:04 <Spark> > {1}
20:19:05 <lambdabot>  Parse error
20:19:30 <Pseudonym> > [ f x | x <- [0,1], let f 0 = 0; f _ = 1 in f 0 ]
20:19:30 <lambdabot>  Not in scope: `f'
20:19:39 <Pseudonym> > [ f x | x <- [0,1], let f 0 = 0; f _ = 1  ]
20:19:40 <lambdabot>  [0,1]
20:19:46 <Pseudonym> Goodness, I didn't know that worked.
20:19:52 <Spark> heh
20:20:07 <Pseudonym> Excuse me while I de-brainwash myself of Gofer syntax.
20:20:07 <Spark> what about
20:20:11 <dropdrive> @pl \x y -> x + 1
20:20:11 <lambdabot> const . (1 +)
20:20:16 <dons> heh
20:23:23 <Spark> can you create an abstraction with a pattern matching element
20:23:29 <Pete_I> > const . (1 +)
20:23:30 <lambdabot>  Add a type signature
20:23:37 <Spark> > (\ 0 -> 0 ; _ -> 1) 2
20:23:38 <lambdabot>  Parse error
20:23:54 <dropdrive> @pl \a b c d e -> b c d a e
20:23:54 <lambdabot> flip (flip . (flip .))
20:24:03 <Spark> guess not :)
20:24:34 <jcreigh> @pl \a b c d e -> e d c b a
20:24:34 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))
20:25:00 <dropdrive> whee!
20:25:32 <Pete_I> may sound a silly question, but what's the point of pointless?
20:25:48 <Pete_I> just to make it harder to read?
20:25:52 <Spark> sometimes it might be easier
20:25:53 <Korollary> @wiki point free style
20:25:54 <lambdabot> http://www.haskell.org/haskellwiki/point free style
20:25:57 <Korollary> argh
20:26:15 <Korollary> @google haskell wiki point free style
20:26:17 <lambdabot> http://www.haskell.org/hawiki/PointFreeStyle
20:26:17 <dropdrive> ttp://www.haskell.org/haskellwiki/Haskell/Pointfree
20:26:17 <Pete_I> looks like a bad link.
20:26:42 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html   "The point of pointfree"
20:26:44 <lambdabot> The title of that page is "The Point of Pointfree"
20:29:08 <Pete_I> '.' is the pipelining operator?
20:29:16 <Pete_I> sweet :)
20:31:11 <Spark> can you define $ in terms of .
20:31:36 <monochrom> (f . g) x = f (g (x))  so . is indeed combining two stages of data flow.
20:32:29 <dons> ?gwiki Pointfree
20:32:31 <lambdabot> http://haskell.org/haskellwiki/Pointfree
20:32:56 <dons> gwiki uses google site:haskell.org/haskellwiki, so should be more accurate
20:33:07 <Dino_> I believe the . is called 'function composition'
20:34:51 <jcreigh> What does the "(. f)
20:34:54 <jcreigh> err...
20:35:09 <jcreigh> What does the "(. f)" and "(f .)" syntax forms mean, respectively?
20:35:09 <dons> ?type \f -> (. f)
20:35:10 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
20:35:18 <Pete_I> sum = foldr (+) 0 -- how does this take any args?
20:35:21 <dons> that's a partially applied .
20:35:25 <dons> ?type foldr
20:35:26 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
20:35:39 <dons> foldr takes 3, you've applied it to 2 args in the above
20:35:49 <dons> so sum will then accept the 3rd, unnamed arg
20:35:53 <monochrom> f . g  =  (f .) g  =  (. g) f   in the same sense that 1+2 = (1 +) 2 = (+ 2) 1
20:36:01 <dons> > let f = foldr (+) 0 in f [1..5]
20:36:01 <Pete_I> dons, i see. :)
20:36:02 <lambdabot>  15
20:36:15 <dons> > let f xs = foldr (+) 0 xs in f [1..5]
20:36:16 <lambdabot>  15
20:36:28 <Pete_I> guess that's why it's called an idiom...
20:36:39 <dons> > let f = foldr (+) (0::Int) in f
20:36:40 <lambdabot>  <[Int] -> Int>
20:37:29 <Pete_I> does lambdabot have a builtin haskell parser, or does it run it though ghc or something?
20:37:43 <jcreigh> Okay, in my mind, "a . b" = "(.) a b" So I can see how "(a .)" would be "(.) a", but how does "(. a)" work? Is it "(flip (.)) a"?
20:38:14 <dons> Pete_I, it has a built in haskell parser
20:38:29 <monochrom> 1 + 2 = (+ 2) 1
20:38:59 <Pete_I> > 1 + 2 == (+ 2) 1
20:39:00 <lambdabot>  True
20:39:08 <Pete_I> awesome.
20:39:14 <Pete_I> wierd syntax rules.
20:39:15 <Dino_> And the removing the third arg from the sum above, that's the eta reduction.
20:39:28 <monochrom> How to make sense of (+ 2):  ___ + 2  imagine omitting the blank.
20:39:28 <ricebowl> what on earth does the -H14m option do in GHC? Or rather, how can I set the heap size to 1GiB?
20:39:56 <monochrom> Perhaps -H1000m ?
20:40:13 <ricebowl> ah, I see, m for MiB
20:40:17 <Pete_I> > (/ 2) 1
20:40:18 <lambdabot>  0.5
20:40:27 <jcreigh> monochrom: Oh! So the same applies to all infix functions, (.) being one of them?
20:40:35 <ricebowl> doesn't make much sense though
20:40:46 <ricebowl> it crashed and griped that the default value of 256MiB was too small
20:40:58 <ricebowl> but the --help option says that -H14m gives a bigger heap
20:41:15 <Spark> is there a function that will reduce a list to distinct values?
20:41:26 <Spark> like unix uniq(1)
20:41:29 <Pete_I> Spark, you mean remove doubles?
20:41:32 <Spark> yeah
20:41:33 <monochrom> hmm, m = millibytes?  :)
20:41:35 <Pete_I> nub in the List module
20:41:40 <ricebowl> nub
20:41:42 <Spark> s/distinct/unique
20:41:46 <ricebowl> heh beat me to it
20:41:58 <Spark> heh "nub"
20:41:59 <Pete_I> yep. asked that question yesterday
20:42:09 <Spark> @type nub
20:42:10 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:42:19 <Pete_I> > nub [1,2,2,1]
20:42:20 <lambdabot>  [1,2]
20:42:25 <ricebowl> http://www.zvon.org/other/haskell/Outputglobal/index.html
20:42:26 <lambdabot> The title of that page is "Haskell"
20:42:37 <thetallguy> also numBy
20:42:44 <thetallguy> sorry
20:42:47 <thetallguy> nubBy
20:42:53 <thetallguy> @type nubBy
20:42:54 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
20:43:11 <Pete_I> what does the -> mean in type defs?
20:43:33 <monochrom> -H1000m should work.
20:43:43 <thetallguy> function
20:43:48 <thetallguy> a -> b
20:43:53 <Cale> Pete_I: The -> is the constructor for function types. If A and B are types, then A -> B is the type of functions which take a parameter of type A and result in a value of type B
20:43:54 <thetallguy> is a mapping from type a to type b
20:44:17 <thetallguy> @type 3 +
20:44:18 <lambdabot> parse error (possibly incorrect indentation)
20:44:26 <Cale> @type (3+)
20:44:28 <lambdabot> forall a. (Num a) => a -> a
20:44:30 <thetallguy> @type (3 +)
20:44:31 <lambdabot> forall a. (Num a) => a -> a
20:44:37 <Cale> @type (:)
20:44:38 <lambdabot> forall a. a -> [a] -> [a]
20:44:41 <thetallguy> @type (+)
20:44:42 <lambdabot> forall a. (Num a) => a -> a -> a
20:44:47 <Cale> The -> is right associative
20:44:56 <Cale> so  A -> B -> C  means  A -> (B -> C)
20:45:01 <Pete_I> yes, i see that.
20:48:07 <ricebowl> monochrom - nope, it doesn't even compile the first file when I do that.
20:48:34 <ricebowl> this is so strange...
20:48:41 <ricebowl> the file is ~220KB and GHC runs out of memory
20:48:42 <monochrom> "ghc -H1000m ..." I don't think you need this to compile things.
20:48:51 <ricebowl> but most of that's whitespace, I think
20:49:07 <Cale> you have a 220KB source file?
20:49:54 <monochrom> -H is "initial heap size".  It won't limit maximum heap size.  (Your computer setup will, i.e., physical memory plus swap file size)
20:51:09 <ricebowl> I see
20:51:11 <ricebowl> Cale - yes
20:51:35 <ricebowl> confusing, I didn't realize it was an RTS option, and that's why GHC was barfing.
20:52:27 <ricebowl> monochrom - I've got more memory than address space, so that's not really a problem.
20:52:50 <monochrom> Then the address space limit becomes the limit.
20:53:11 <ricebowl> I know. But it was getting GHC to use the option that was my problem... anyway, it's working now, albeit very slowly
20:53:37 <ricebowl> is cc1 written in Haskell, too? I'm on a Windows box, so it's definitely not anything natively installed.
20:53:49 <monochrom> cc1 sounds like part of gcc
20:54:02 <ricebowl> yes, it does, but I don't think I even have GCC on this machine
20:54:14 <Korollary> ghc on win32 ships with gcc iirc
20:54:18 <monochrom> Ja
20:54:22 <ricebowl> hmm, interesting
20:54:43 <ricebowl> well, it looks like (?) it was cc1 that was crashing with the out-of-memory error
20:54:52 <ricebowl> although I am using the term crashing very loosely here.
20:55:10 <monochrom> Possible, and not much you can do.
20:55:20 <ricebowl> crazy, I've never seen a 3MiB .o file.
20:55:37 <ricebowl> whatever I did really kills the compiler
20:56:04 <monochrom> Ja!
20:56:46 <Pete_I> there's a page in the haskell idioms section called 'blow your mind' ....
20:56:46 <ricebowl> oh well, at least it works now.
20:56:50 <Pete_I> sounds complicated.
20:59:41 <Pete_I> how can haskell be "a purely functional language" if it has non-functions ?
21:01:10 <ricebowl> what non-functions?
21:01:24 <Pete_I> IO
21:01:29 <ricebowl> those are functions
21:01:35 <ricebowl> IO is a container
21:01:39 <ricebowl> a data structure
21:01:47 <ricebowl> it's really simple to understand conceptually
21:01:47 <Pete_I> i thought they were "actions", because they have side effects.
21:01:56 <ricebowl> that's how they're explained
21:02:10 <ricebowl> think of it as a function of the current IO state to the next IO state
21:02:13 <Pete_I> that's not how it is?
21:02:15 <ricebowl> that sequences them
21:02:31 <Pete_I> ok
21:02:50 <ricebowl> they do have side-effects, but the abstraction of a state makes it possible to keep the language pure and functional
21:03:04 <ricebowl> in practice, the state parameter doesn't exist and it calls into the C library
21:03:27 <ricebowl> you can neither read nor write the state parameter; but in some sense it exists, and its existance causes the sequencing.
21:03:32 <Pete_I> ok, so the language is purely functional, but the interpreter isn't?
21:03:43 <ricebowl> well the machine it runs on isn't functional
21:03:54 <Pete_I> ....oh yeah, :)
21:04:14 <Pete_I> think they used to have functional machines...
21:04:15 <ricebowl> but functional and imperative are both Turing machines
21:05:30 <jcreigh> Rather, they both can be used to describe Turing machines, right?
21:06:38 <ricebowl> they're both equivalent to the Turing machine, sorry
21:06:49 <Pete_I> i understood, yeah
21:11:06 <Cale> for some values of 'equivalent'
21:11:18 <Cale> most machines don't have unlimited memory :)
21:11:41 <mdmkolbe> Is there a parsec grammer for C++ around?
21:12:22 <Cale> mdmkolbe: I believe that one of the current Google Summer of Code projects is Language.C
21:12:41 <Korollary> mdmkolbe: I think I have a link to a java parser
21:13:16 <Korollary> mdmkolbe: http://www.di.uminho.pt/~joostvisser/software/UMinhoHaskellSoftware-1.0/index.html
21:13:40 <Korollary> hmm
21:13:54 <Korollary> probably not parsec
21:15:34 <mdmkolbe> unfortunately the C++ grammer is very complex or so I'm told. so the last mile from C or Java to a full C++ grammer would be where most of the work is.
21:15:55 <dropdrive> anyone have a haskell brainteaser for me as i try to fall asleep?
21:16:38 <Pete_I> how do i turn a number into a string?
21:16:44 <Cale> dropdrive: how about writing a function which takes two lists, possibly infinite, and produces a list with all the elements of the Cartesian product?
21:16:52 <Cale> Pete_I: show
21:17:24 <mathewm> Cale: is that "diagonalization"?
21:17:31 <Cale> mathewm: yeah
21:17:43 <Pete_I> Cale, thanks.
21:18:35 <dropdrive> Cale: okay, thanks...
21:21:54 <Korollary> mdmkolbe: I'd believe that the C++ grammar is a b**tch
21:23:14 <mdmkolbe> Korollary: though not as bad as the VHDL grammar.  I'm told that there exist *no* fully conforming VHDL parsers. =-)
21:23:36 <ricebowl> interesting, it's hard to conceive of a language harder to parse than C++
21:24:55 <Korollary> mdmkolbe: Some say that about Perl as well ("only perl can parse Perl")
21:25:43 <mdmkolbe> Korollary: but only Haskell can parse Perl 6
21:26:32 <Pete_I> mdmkolbe, i'm sure somebody will make a Perl6 module to parse perl6 in perl5
21:27:46 <Pete_I> it probly won't be too pretty though
21:28:15 <Pseudonym> Fortran 77 and PL/I are notoriously hard to parse.
21:28:32 <Pseudonym> If you're using lex/yacc or the like, anyway.
21:28:52 <Pseudonym> Though the moderator of comp.compilers famously once wrote a F77 parser in only lex.
21:28:53 <Pete_I> brainfuck is easy to parse
21:29:23 <Pseudonym> The "grammar", if you can call it that, was too tightly coupled to the lexical syntax for yacc.
21:29:46 <Korollary> ouch
21:30:35 <Pseudonym> Well, it's one of those old languages that was invented before context-free grammars were fully appreciated.
21:30:46 <Korollary> true
21:31:09 <Pseudonym> The only languages of that ilk that are still in use are Fortran, COBOL and Lisp.
21:31:22 <Korollary> Cobol isn't dead yet?
21:31:26 <Pseudonym> Nope.
21:31:43 <Korollary> I used to know cobol.
21:32:11 <Korollary> I don't remember anything, though. I carefully erased my memory.
21:32:18 <Korollary> hmm. writeln.
21:32:35 <monochrom> MULTIPLY X BY Y INTO Z   (or something like that)
21:33:09 <Korollary> I learned it on an amstrad 128 running cp/m, iirc.
21:33:28 <Pseudonym> In the late 1990s, the Gartner Group, a data-processing industry research organization, estimated that of the 300 billion lines of computer code that existed, eighty percent  or 240 billion lines  were COBOL.
21:33:37 <Pseudonym> That's from Wikipedia.
21:34:38 <Korollary> that sounds a little too high
21:35:09 <Pseudonym> http://www.cs.vu.nl/Cobol/stop-bashing-cobol.pdf
21:35:15 <Pseudonym> You should read that.
21:35:24 <Pseudonym> In particular, note who the author is,.
21:35:37 <Korollary> > 240e9 / 60 / 365
21:35:38 <lambdabot>  1.095890410958904e7
21:35:51 <Korollary> that many lines a day?
21:36:07 <Pseudonym> No, that's the number of lines RUNNING.
21:36:09 <Pseudonym> Not being written.
21:36:19 <Pseudonym> Only about 5 billion lines a year being written.
21:36:29 <Pseudonym> Mind you, this was in the late 90s at the height of the Y2K effort.
21:36:40 <Pseudonym> I suspect there are fewer lines being written today.
21:36:52 <Korollary> > 5e9 / 365
21:36:53 <lambdabot>  1.3698630136986302e7
21:37:33 <Korollary> thats about a million cobol devs at 10 lines a day
21:38:01 <Pseudonym> But one line of COBOL doesn't do very much.  Probably 20 lines is more likely.
21:39:20 <Pseudonym> 15% of all new applications in 2005 will be in COBOL.
21:39:30 <Pseudonym> (Obviously this was written a couple of years ago.)
21:39:35 <Pseudonym> That I'd believe, actually.
21:39:45 <Korollary> ow that hurts
21:39:52 <mdmkolbe> That 15% was probably taken over by Java.
21:39:57 <Pseudonym> Nope.
21:39:58 <Korollary> I was just going to paste that 15%
21:40:06 <Pseudonym> No way.
21:40:22 <Pseudonym> That 15% has to talk to the 75% of data processing applications that are already written in COBOL.
21:41:17 <Korollary> Haskell has 135 hits on software maintenance?
21:41:57 <Pseudonym> The key thing about this presentation is it's by Ralf Laemmel.
21:42:12 <Korollary> I dont know him
21:42:17 <Pseudonym> DrIFT
21:42:33 <Korollary> ah
21:42:54 <Pseudonym> Anyone whose research interests include both Haskell and Cobol is either very brave or mentally ill.
21:43:03 <Pseudonym> Since it's Ralf, I suspect the former.
21:43:23 <Korollary> ow. Aspect oriented programming in cobol.
21:43:50 <mdmkolbe> Korollary: Ralf did "Scrap your Boilerplate"
21:44:27 <Pseudonym> "Language reference reverse engineering".
21:44:30 <Korollary> Pseudonym: I understand this research, though. There's a lot of cobol code that has to be sanitized.
21:44:31 <Pseudonym> How bizarre is that concept.
21:44:36 <Pseudonym> Sure.
21:48:31 <Korollary> I hoped that the slides would end with "let's convert all that code to something else and ditch this boat." The way it ended almost suggests keeping on writing more cobol code.
21:49:11 <Pseudonym> I've thought for about 10 years or so that what the world REALLY needs is a Cobol replacement.
21:49:23 <Pseudonym> Something that allows you to convert Cobol code over piecemeal.
21:50:11 <Korollary> still too much code to be converted manually
21:50:20 <Pseudonym> I know.
21:50:34 <lisppaste2> mathewm pasted "Mathew's silly assignment - what can I do better?" at http://paste.lisp.org/display/21316
21:50:41 <Pseudonym> But at least it'd discourage the 15% of new code being written in Cobol.
21:52:02 <Pseudonym> "Anyone could learn Lisp in one day, except that if they already knew Fortran, it would take three days."  -- Marvin Minsky
21:52:37 <Pseudonym> mathewm: First off, you don't need all those parentheses
21:52:48 <Pseudonym> If you're going to write the code this way, indentation might be more readable
21:53:01 <Pseudonym> BTW, there's a bug.
21:53:05 <Pseudonym>   x == n `div` 2
21:53:14 <Pseudonym> That can be true if n is odd.
21:53:18 <Pseudonym> Did you mean 2*x == n?
21:53:36 <Pseudonym> Uf so:
21:53:40 <Pseudonym>   if 2*x == n
21:53:47 <Pseudonym>    then return "Mathew"
21:53:52 <Pseudonym>    else return (show x)
21:54:01 <Pseudonym> Or even better:
21:54:05 <Pseudonym>   return $
21:54:14 <mathewm> an even 'n' was given, but the 2* is better
21:54:20 <Pseudonym>   return (if 2*x == n then "Mathew" else show x)
21:55:00 <Pseudonym> But now, it's small enough that a list comprehension may be better:
21:55:15 <Pseudonym>   [ if 2*x == n then "Mathew" else show x | x <- [1..n] ]
21:55:18 <Pseudonym> f is now a one-liner
21:57:06 <mathewm> thanks
21:57:11 <Pseudonym> ?hoogle [a] -> (a -> IO ()) -> IO ()
21:57:12 <lambdabot> No matches, try a more general search
21:57:20 <Pseudonym> ?hoogle [a] -> (a -> IO b) -> IO [b]
21:57:21 <lambdabot> No matches, try a more general search
21:57:43 <Pseudonym> Just seeing if there's a builtin for sequence_ of map
21:57:53 <Pseudonym> ?type sequence_
21:57:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
21:58:04 <Korollary> @type mapM_
21:58:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
21:58:10 <Pseudonym> That's it.
21:58:31 <Pseudonym> So: mapM_ putStrLn (f (read n))
21:58:44 <Pseudonym> Or, perhaps: mapM_ putStrLn . f . read $ n
21:59:40 <Pseudonym> In fact, this might be even better:
21:59:51 <Pseudonym> Hmm.
21:59:53 <Pseudonym> Actually, no.
22:01:40 <mathewm> why might it have been better?
22:01:43 <int-e> mapM_ putStrLn . f . read . head =<< getArgs
22:02:01 <Pseudonym> Yikes.
22:02:06 <Korollary> pl mode off
22:02:06 <Pseudonym> Now we're getting silly.
22:02:23 <Pseudonym> Pointlessness for the sake of pointlessness.
22:03:28 <Korollary> strangely, I don't remember any such exercises/examples in any haskell tutorial.
22:03:50 * Korollary checks yaht
22:03:57 <int-e> > take 11 . intersperse "M" $ map show [1,3..]
22:03:58 <lambdabot>  ["1","M","3","M","5","M","7","M","9","M","11"]
22:04:17 <Lokadin> say, as a functional programing language haskell should be very suitable for writing Ai's right?
22:04:58 <Pseudonym> You're right in principle.
22:05:07 <Pseudonym> In practice, a lot of AI code is horrib le.
22:05:07 <sylvan> Lokadin, it's general purpose, it's well suited for a lot of things - AI may be one of them depending on what kind of AI you're talking about
22:05:29 <Pseudonym> But Haskell, while general purpose, is especially suited for sumbol/structure manipulation.
22:05:53 <Pseudonym> Many AI applications fit into that general area.
22:06:00 <sylvan> yep
22:06:13 <Korollary> Pseudonym: What are those horrible ai apps written in?
22:06:21 <Pseudonym> Old Lisp dialects.
22:06:28 <Pseudonym> Or Prolog.
22:06:59 <Lokadin> sylvan: well i don't mean image recognition ai or any such thing, just text to interact with users, which would be controlled by ai's stuff like grammer construction, and data mining
22:09:06 <Lokadin> did my internet just die? or is it just unusually quiet in here?
22:09:19 <mathewm> ?google Haskell NLP
22:09:20 <sylvan> Seems like you could use Haskell for that...
22:09:21 <lambdabot> http://www.nlpcenteroftexas.com/
22:09:40 <mwc> Hey, any body familiar with c2hs? I'm trying to rap a C api with a series of result codes as #define'd constants. Should I declare my own Enum type in haskell, or is there a smarter way to do this?
22:10:00 <sylvan> These days Haskell is very much better at being general purpose than it used to be, so there are very few cases where you couldn't make Haskell do what you want :-)
22:10:34 <Lokadin> cool :) 
22:10:35 <mwc> sylvan, and what's more, where it isn't, you can fake it with ST/IO most of the time
22:11:02 <sylvan> or FFI + C
22:11:16 <Pseudonym> ?google english parser haskell
22:11:19 <lambdabot> http://de.lirio.us/rubric/entries/user/era
22:11:38 <Pseudonym> ?google government binding haskell
22:11:39 <lambdabot> http://browse.barnesandnoble.com/browse/nav.asp?visgrp=nonfiction&N=261972+1035+236664&Ne=236664&z=y
22:11:48 <bringert> Pseudonym: do you want to parse english?
22:11:54 <Pseudonym> Nope.
22:12:02 <Pseudonym> I just feel lucky in the Google sense.
22:12:04 <sylvan> (and by "Haskell" I pretty much mean "ghc")
22:12:18 <Pseudonym> But I used to be interested in this stuff if you have some references.
22:13:37 <Korollary> ?google office space haskell
22:13:38 <lambdabot> http://www.businessreview.ru/stories/33/01.html
22:14:46 <mathewm> ?google haskell cookware
22:14:48 <lambdabot> http://www2.dupont.com/PFOA/en_US/about_teflon/
22:15:53 <Korollary> ?freshname
22:15:54 <lambdabot> Haf
22:15:57 <Korollary> ?freshname
22:15:58 <lambdabot> Hag
22:15:59 <Korollary> ?freshname
22:16:00 <lambdabot> Hah
22:16:01 <Korollary> ?freshname
22:16:02 <lambdabot> Hai
22:16:14 <Korollary> oh come on
22:17:01 <Korollary> ?botsnack
22:17:01 <lambdabot> :)
22:17:08 <Korollary> ?botsnack
22:17:08 <lambdabot> :)
22:17:21 <Pseudonym> ?vixen Explain yourself.
22:17:21 <lambdabot> are you coming on to me?
22:17:48 <Korollary> ?palomer
22:17:48 <lambdabot> Pfft
22:17:52 <sylvan> Man... People have way too much time on their hands.. I mean "botsnack".. heh
22:18:24 <Korollary> It's too simple. I expected some more text.
22:18:35 <Korollary> ?girl19
22:18:35 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
22:18:42 <Korollary> ?girl19
22:18:43 <lambdabot> well.. I never hacked Russians
22:18:56 <Korollary> ?girl19
22:18:56 <lambdabot> am I supposed to be frantic with terror and anxiety?
22:19:01 <Pseudonym> ?keal
22:19:01 <lambdabot> intuitive != imperative
22:19:16 <bringert> Pseudonym: have you seen GF? http://www.cs.chalmers.se/~aarne/GF/
22:19:18 <Korollary> girl19 is too context sensitive. OTOH, keal is timeless.
22:19:19 <lambdabot> The title of that page is "GF Version 2.5"
22:19:41 <Pseudonym> Oooh, cool.
22:19:55 <Pseudonym> I hate the logo.
22:20:02 <Pseudonym> But nice.
22:20:55 <Korollary> ML?
22:21:29 <Korollary> nope
22:22:09 <Korollary> bringert: how do you like Seattle so far?
22:22:17 <mathewm> what lang is it impl in?
22:22:26 <Korollary> mathewm: haskell apparently
22:23:41 <bringert> Korollary: it's very nice. I haven't been around that much really, would be fun to get out more
22:38:49 <Pete_I> is there a simple way to turn ["a","b","c"] into "abc" ?
22:39:05 <Lemmih> > concat ["a","b","c"]
22:39:06 <lambdabot>  "abc"
22:39:14 <Pete_I> concat? what module's that in?
22:39:20 <Lemmih> @index concat
22:39:21 <lambdabot> Data.List, Prelude
22:39:29 <Pete_I> Lemmih, thanks much
22:39:48 <Lemmih> No problem (:
22:40:52 <Korollary> Lemmih: what's  the status of conjure?
22:42:05 <dons> Korollary: <plug>you should run darcs-graph on the repo to see for yourself :)</plug>
22:43:16 <Korollary> dons: I am afraid of real haskell programs :)
22:44:24 <Lemmih> Korollary: Almost usable. I'll bring the last pieces together once I get some time off work.
22:45:14 * SamB has been trying to hack on ZSNES today
22:47:14 <SamB> I'm trying to port their old DOS (raw VGA access) debug.asm to a nice curses-based C version.
22:47:16 <palomer> never eat a whole box of cheese sticks at once
22:47:40 <SamB> but unfortunately to do this I must figure out what the ASM one is doing :-(
22:48:29 <Korollary> SamB: are you getting paid for that?
22:48:44 <SamB> no!
22:49:05 <SamB> I'm going to try to extort some money from them in exchange for the patch, though
22:49:12 <Korollary> SamB: Have you consulted with a doctor before this exercise?
22:50:15 <SamB> look! I already have three lines!
22:50:15 <SamB>     move(1,50); printw("%.11d", numinst);
22:50:15 <SamB>     move(1,20); printw("%.3d",  curcyc);
22:50:15 <SamB>     move(1,26); printw("%.3d",  curypos);
22:51:44 <SamB> that replaces about 16 lines of ASM
22:52:12 <Pete_I> so it's a 2:1 ratio :/
22:52:16 <SamB> which directly accesses the VGA
22:52:29 <SamB> > 3/16 :: Ratio
22:52:30 <lambdabot>    `Ratio' is not applied to enough type arguments
22:52:31 <lambdabot>   Expected kind `?', bu...
22:52:34 <SamB> > 3/16 :: Ratio Integer
22:52:36 <lambdabot>  3%16
22:52:40 <Lemmih> heh
22:52:44 <SamB> > 3/16
22:52:45 <lambdabot>  0.1875
22:53:20 <palomer> that's crayzee
22:53:21 <Korollary> Lemmih: Besides you, who else is still contributing to this?
22:53:29 <Pete_I> that's 6 subroutine calls for 16 lines of asm, so it's a 6:16 ratio
22:53:41 <Pete_I> > 6/16
22:53:42 <lambdabot>  0.375
22:53:51 <Lemmih> Korollary: ADEpt is the only one who has been active recently.
22:54:17 * SamB has this tendancy to drift between projects
22:54:40 <Lemmih> SamB: I hope to get you back once the thing is in the air. (:
22:54:56 <palomer> do you mean "off the ground" ?
22:55:25 <Pete_I> "up in the air" usually means uncertain.
22:55:35 <Lemmih> oh /-:
22:55:38 <Korollary> Lemmih: I may be interested as I am interested in STM.
22:55:39 <Pete_I> which is kind of funny
22:55:47 <palomer> ironic, really
22:55:47 * SamB remembers that he was in the middle of another project when he ran into a problem with GHC, and that he was going to install a newer version, and starts the apt-get again so it will actually happen
22:56:00 <palomer> SamB: focus!
22:57:19 <palomer> holy crap
22:57:28 <palomer> seriously, box of cheese sticks = bad news
22:57:41 <SamB> well, in the air is sufficiently different-sounding not to sound like it means uncertain... though it does have uncertain meaning ;-)
22:57:56 <Pete_I> palomer, if you eat a box of cheese sticks, you should drink prune juice with it.
22:58:01 <SamB> palomer: with a 56k modem, you expect me to remember to finish downloading?
22:58:04 <Pete_I> help even things otu
22:58:06 <palomer> why prune juice?
22:58:14 <palomer> why not grapefruit?
22:58:32 <Pete_I> i don't know anything about grapefruit juice.
22:58:33 <SamB> oooooooh
22:58:34 <palomer> in french, you say "dans les aires"
22:58:37 <SamB> pretty
22:58:38 <palomer> which means "in the air"
22:58:47 <palomer> but why PRUNE?
22:58:49 <SamB> I can paste the debugger screen!
22:58:58 <Pete_I> palomer, natural laxative :)
22:59:08 <SamB>   - ZSNES debugger -
22:59:08 <SamB> 0═══ 65816 ═════ CC:  0 Y:224 ═══════════════════ ----------0 ════════════════╕
22:59:08 <SamB> │008000 SEI                    A:0000 X:0000 Y:0000 S:01FF DB:00 D:0000 P:34 E│▒
22:59:08 <SamB> │00E851 RTS                    A:00AD X:EC0C Y:04D9 S:01F2 DB:00 D:0000 P:A0 e│▒
22:59:08 <SamB> │008034 LDA $12       [000012] A:B700 X:0000 Y:0000 S:01FF DB:00 D:0000 P:32 e│▒
22:59:09 <SamB> │008034 LDA $12       [000012] A:B700 X:0000 Y:0000 S:01FF DB:00 D:0000 P:32 e│▒
22:59:11 <SamB> │008036 BEQ $8034     [008034] A:B700 X:0000 Y:0000 S:01FF DB:00 D:0000 P:32 e│▒
22:59:13 <SamB> │ 084C/69 CMP   ($04C),($04D)  A:00 X:48 Y:04 S:CF N+O+D-?-H-I-Z-C-           │▒
22:59:14 <sieni> augh
22:59:17 <Pete_I> ugh,
22:59:22 <Lemmih> Korollary: I hope STM will help us beat all the other clients in performance and stability.
22:59:25 <Pete_I> pastebin :/
22:59:28 <sieni> no you can't paste a debugger screen
22:59:34 <SamB> hmm, slight aligment issues
22:59:47 <SamB> does pastebin support utf-8?
22:59:56 <Pete_I> i dunno
23:00:00 <Korollary> SamB: that looks like motorola asm
23:00:13 <palomer> my stomach is upset, not my bowels
23:00:21 <Pete_I> pastbin.com is in php, so i doubt it.
23:00:25 <Korollary> Lemmih: Is there a project wiki?
23:00:30 <Pete_I> palomer, that's too bad.
23:00:30 <palomer> rafb.net/paste
23:00:42 <SamB> anyway, the 3 lines I pasted before are supposed to put the numbers on the second line (except the CPU number)
23:01:19 <SamB> Korollary: yeah, the 65816 is a derivative of the 6502
23:01:38 <Lemmih> Korollary: No, I've thought about setting up a WordPress like for HIDE and gtk2hs.
23:09:58 <Korollary> Lemmih: I suppose I need ghc 6.5 for STM, even though readme says >= 6.4?
23:11:03 <Lemmih> I use GHC-6.4.1 when I work on conjure.
23:28:02 <Lokadin> @where fps
23:28:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
23:29:32 <Lokadin> i don't understand, lambdabot needs fps>=0.7
23:29:37 <Lokadin> but only 0.6 is available
23:30:08 <bringert> Lokadin: get it from darcs
23:30:23 <Lokadin> :(, but the ebuilds1!! :'(
23:30:59 <Lokadin> eh i guess i can try making an ebuild with darcs
23:31:08 <lispy> darcs!!!
23:31:18 <lispy> sorry :)
23:31:24 <lispy> just too much excitement
23:34:43 <dons> Lokadin: it needs the darcs version. just build that -- forget ebuild stuff
23:40:11 <Lokadin> yea,,, well alright
23:41:00 <Lokadin> non-uniformity is terrible
23:42:33 <ADEpt> dons: ping
23:42:42 <ADEpt> dons: have you seen http://en.wikipedia.org/wiki/VList ?
23:43:19 <dons> why didn't lambdabot spot that url. hmm.
23:43:28 <dons> hmm
23:44:02 <dons> no, didn't know about that
23:44:08 <dons> dcoutts, http://en.wikipedia.org/wiki/VList
23:44:33 <int-e> http://
23:44:34 <lambdabot> The title of that page is "ERROR: The requested URL could not be retrieved"
23:44:36 <dons> similar to ours, though we owe more to the piecewise execution stuff from data parallel programming
23:44:50 <dons> in particular, the cache-sized array chunks
23:45:03 <dons> rather than arrays whose size decrease
23:45:22 <dons> but definitely related
23:47:58 <Lokadin> say to install fps, i have to run configure build and then what?
23:48:06 <Lokadin> install?
23:48:14 <dons> less README :)
23:48:19 <Lokadin> kk :)
23:48:43 <Korollary> how do you uninstall a cabal-installed package?
23:49:50 <dons> does ./Setup.hs unregister work?
23:50:01 <ricebowl> bah, is there any clever way to take an N-elem list and produce a 2^N elem list of all permutations?
23:50:08 <ricebowl> clever or terse.
23:50:22 <ricebowl> @type sum
23:50:23 <lambdabot> forall a. (Num a) => [a] -> a
23:50:23 <Korollary> dons: That just unregisters it from ghc, but leaves the files where they are.
23:55:17 <lorne> ricebowl: here's my attempt at a powerset function
23:55:18 <lorne> powerset [a] = [ [], [a] ]
23:55:19 <lorne> powerset (x:xs) = p ++ map (x:) p where p = powerset xs
23:57:12 <dons> ?google permute list haskell
23:57:13 <lambdabot> http://www.haskell.org/hawiki/PermutationExample
23:57:56 <dmhouse> Morning channel.
23:58:11 <dons> morning dmhouse.
