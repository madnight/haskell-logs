00:02:35 <lisppaste2> ramza3 pasted "Cant understand functions" at http://paste.lisp.org/display/20742
00:02:48 <ramza3___> Can somebody help with functions (sigh I know)
00:05:12 <kosmikus> ramza3___: the file you pasted should result in a type error, not the error given in the comment
00:05:49 <ramza3___> I am using ghc
00:05:58 <kosmikus> sure
00:06:01 <amiddelk> maybe there are also layout problems?
00:06:30 <kosmikus> possible, but they're not visible in the paste. it looks like every indented line has two spaces
00:07:04 <kosmikus> program looks syntactically correct, but there's at least one type error in the "let res" line ...
00:07:27 <ramza3___> I have been using 'two' spaces; so far the code is compiling
00:11:22 <Korollary> ramza3___: You mean "res <-readHeader "test"
00:11:30 <Korollary> ignore the first " above
00:12:03 <Korollary> I don't think that code as is should typecheck
00:12:21 <ramza3___> hmm
00:12:33 <Korollary> readHeader seems to have type String -> IO String
00:12:43 <ramza3___> yea, that is what I am missing
00:13:05 <hoan> Hello, what is the de-facto standard trie library?  The one in Data.Trie?
00:13:51 <dons> yes, though its pretty easy to code up your own
00:13:59 <hoan> okay, thanks dons
00:14:00 <dons> kzm wrote one in an hour or two, iirc
00:14:10 <dons> how's the hacking coming along, hoan?
00:14:10 <kzm> You called?
00:14:28 <hoan> well, i got accepted for google soc
00:14:29 <dons> kzm, you rolled your own trie pretty easily, iirc?
00:14:38 <dons> hoan, oh, which project?
00:14:42 <hoan> i get to port stm to common lisp, so im happy
00:14:48 <hoan> actually over the moon
00:14:49 <kzm> Sure.  It's not so hard.
00:14:51 <dons> ah, right. well done
00:15:05 <dons> hoan: did you apply for any haskell projects?
00:15:11 <kzm> The hard part is compressing the edges in O(n) time. :-)
00:15:19 <hoan> i was going to, but i don't have enough haskell experience
00:15:24 <hoan> but next year for sure
00:15:31 <dons> cool :)
00:16:00 * kzm just got in the door when Irc popped up in my face at the mention of my nick.
00:16:12 <Korollary> I'm supposed to present STM at work
00:16:17 <Korollary> for kicks
00:16:31 <kzm> Korollary, I just did that.  Want the slides?
00:16:32 <Korollary> There's apparently a C STM library on sf.net
00:16:42 <hoan> Korollary: where do you work?
00:17:20 <Korollary> hoan: the company with the one-click patent
00:17:27 <hoan> aha!
00:17:37 <kzm> Perhaps I'm overly enthusiastic, but I think STM might just be the killer application that will defeat Haskell's long standing goal of avoiding popularity.
00:17:41 <ramza3___> amazon
00:17:54 <dons> kzm :)
00:18:06 <hoan> it just might come true
00:18:10 <dons> but people are porting it to their own languages too quickly perhaps?
00:18:13 <kzm> I used to work with MT code in C++ - what a mess.
00:18:26 <Korollary> kzm: I'll pm you my email
00:18:29 <dons> like layout in python, or list comprehensions or whatever else pythong stole^h^h^h implemented
00:18:40 <kzm> I don't think it is that easy.  You need the STM monad for it to be safe.  I think.
00:18:44 <hoan> well there is a port to Parrot, for another SoC
00:18:59 <Korollary> kzm: I was wondering that. How does it work for languages that can't restrict their side effects?
00:18:59 <hoan> kzm: yes
00:19:21 <dons> yeah, the static typing issue . i guess you just let the user take care of that (?)
00:19:48 <hoan> thats the common lisp way ;)
00:19:49 <dons> i.e. instead of a type , you add documentation
00:20:10 <kzm> I imagine so.  So you get the locklessness, but you must still be very careful that all global mutables are accessed with transactions
00:20:11 <dons> hoan: :D
00:20:26 <dons> right, no machine checking for you
00:20:37 <dons> so we win in the long run in productivity terms
00:20:51 <hoan> sure, but many people spend their whole lives programming without a typechecker
00:21:57 <dons> right, and are less productive, or produce code with more bugs. i think that's the number one icfp/haskell factor: greater productivity and less bugs
00:22:31 <dons> either you code more carefully, slowing you down, since you have to check all these extra side conditions that appear in documentation, or you introduce bugs that have to be found later
00:22:47 <hoan> i've thought about it for a while, and type-checking is probably a net win
00:22:56 <hoan> so you don't have to convince me now :]
00:23:29 <dons> sure, i've just not thought about it directly as a bugs vs speed tradeoff
00:23:38 <dons> for the non-strongly, staticalyl typed guys
00:24:01 <Korollary> speed of what? development?
00:24:02 <hoan> okay
00:24:26 <dons> Korollary: yep.
00:24:47 <Korollary> I am not sure if I write even working code any faster just because it's not statically checked
00:25:17 <dons> yeah, maybe. maybe the benefit is soley in the runtime-debugging phase
00:25:37 <dons> though in the icfp contest, more haskell entries got rewritten succesfully and submitted
00:25:39 <hoan> in my experience a typechecker is just useful like a debugger or a profiler
00:25:43 <dons> the haskell code as just produced at a faster rate
00:25:54 <kzm> The ICFP mantra has always been that the best programmers win, regardless of language.
00:26:04 <dons> and that was before the runtime stress testing weeded out the buggy programs
00:26:15 <hoan> thats what i like most about haskell, its SO concise
00:26:36 <hoan> and points-free rocks!
00:26:38 <dons> kzm, winning, yes, but looking at the overall statistics of how many programs survive all the stress  testing into the last rounds
00:26:56 <Korollary> The proponents of runtime checking want to be able to write code that wouldn't typecheck. But, the way I write, even my python programs would typecheck. So, I don't gain anything by not checking.
00:26:58 <dons> and in particular, last year, with the refactoring contest
00:27:18 <kzm> I haven't run the statistics on that.  But it fits my experience.
00:27:51 <dons> Korollary: yes, very good point
00:28:10 <dons> so then it all comes down to how much time you want to spend debugging, after the code is compiled
00:29:25 <dons> then the languages that made you correct type errors before compilation will win out over those that make you discover them at runtime, when things go wrong, i'm pretty sure (at least that's what happens in the icfp contest)
00:29:30 <Korollary> dons: I am actually looking for good examples from the dynamic check communities for kinds of programs that are not well typed, but elegant/interesting, etc. It just doesn't make sense to me, so I need to see an example.
00:29:54 <Korollary> are not = cannot be
00:30:00 <dons> i'm sure there are metaprogramming programs, that we don't yet have good type systems for
00:30:20 <Korollary> TH typechecks, right?
00:30:30 <dons> yeah, but its compile time metaprogramming
00:30:52 <dons> runtime, multi-stage metaprogramming. that's the bit that's hard. though MetaML gets there 
00:31:36 <Korollary> ok, but that's also way beyond what lisp, Ruby, etc. offer, right?
00:31:43 <dons> but the history of type systems has been working out ways to type useful programs that didn't previously type check.
00:31:44 <Korollary> I may be wrong
00:32:14 <dons> i think lisps reflection capabilities would be examples of elegant, yet not typeable by your everyday language, code.
00:32:22 <dons> maybe its not elegant :}
00:32:55 <Korollary> I guess if you add new methods at runtime to an existing object and pass it around, that qualifies
00:36:40 <Philippa> lisp has runtime, multi-stage metaprogramming
00:38:42 <Philippa> dons: the trick's in the types of the code being generated?
00:40:42 <dons> well, yes, the splice point seems the hard bit. ensuring that code that uses code from another stage correctly propagates type information from that stage
00:41:21 <dons> you need the type checker availabel at runtime to unify types on splice boundaries
00:48:21 <Maddas> dons: Do you know MetaOCaml?
00:48:45 <dcoutts> I do
00:48:51 <Maddas> How does lisp have runtime multi-stage metaprogramming?
00:49:00 <dcoutts> it's like TH but safer
00:49:01 <Maddas> (Surely not because of EVAL)
00:49:05 <Itkovian> seen this: http://www-128.ibm.com/developerworks/linux/library/l-advflow.html?ca=dgr-lnxw06FlowControl ?
00:49:22 <dcoutts> and therefore also less powerful
00:49:26 <Maddas> dcoutts: Right, I just wanted to mention it in (the unlikely, I guess) case he hadn't heard of it.
00:49:52 <dons> yeah, i know about it. been a while since i looked at it. couple of years
00:49:56 <Maddas> dcoutts: Turing... :-)
00:50:10 <dcoutts> so MetaOCaml has mult stage programming but it is type safe
00:50:21 <dcoutts> TH has 2-stage programming but it is not type safe
00:50:33 <dcoutts> well rather it's not staticaly typed
00:50:50 <dcoutts> it can produce type errors after running the first stage
00:51:33 <Maddas> Why does Lisp count as a language having meta-programming, though?
00:51:56 <dcoutts> quote and eval I guess
00:51:58 <Maddas> (oops, I guess eval is it)
00:52:35 <Maddas> Right, at first I immediately thought that having eval couldn't possibly be enough. I guess I'm a little spoiled (:
00:53:22 <Maddas> dcoutts: Why does quote matter? It's more _convenient_ than generating and passing strings to eval, but is it in any way more 'powerful'?
00:56:58 <dcoutts> well I guess there's stuff related to name capture
00:57:26 <dcoutts> but it's certainly much easier
00:57:49 <dcoutts> and if you've got splice, then quote is the obvious inverse
00:58:43 <Maddas> I'm not sure what you mean with stuff related to name capture. Right, it's definitely much easier -- I was just wondering about what it takes to be called meta-programming, not disputing the practical use of quote :)
00:59:48 <Philippa> the alternative would pretty much involve a parser and pretty-printer doing string<->s-expression
01:00:29 <Philippa> I think if you don't supply that, it's a bit questionable as to whether you're really *supporting* meta-programming
01:00:37 <Maddas> Ok.
01:01:16 <dcoutts> well in particular you don't get reflection
01:01:31 <dcoutts> because you can't bind to names in the existing program
01:01:48 <Maddas> How does quote let you do that?
01:02:39 <Maddas> You're talking about accessing the 'outside' environment from within the code passed to eval, right?
01:02:58 <dcoutts> right
01:03:25 <Maddas> I don't see how QUOTE lets you do that (in a way you couldn't with strings) :-)
01:04:59 <dcoutts> no, it's eval
01:05:53 <Maddas> Oh, okay, I see that :-)
01:34:30 <xerox> @arr
01:34:31 <lambdabot> This is the END for you, you gutter-crawling cur!
02:10:12 <davidhouse> my irc connection is being v buggy. anyone alive in here?
02:10:34 <Muad_Dibber> nope, its rather quiet
02:10:42 <ohub> nobody here
02:10:50 <davidhouse> all right then. :)
02:11:16 <Itkovian> we're all alive and kicking
02:11:17 * davidhouse discovered a new way of seeing whether his irc client is working or not: check the channel logs
02:11:23 <ohub> just keep listening. maybe someone will talk something.
02:16:04 <davidhouse_> lets try this again
02:16:44 <davidhouse> @localtime dons
02:16:44 <lambdabot> Local time for dons is Fri Jun  2 19:09:04 2006
02:16:52 <davidhouse> dons, did you get my patch(es)?
02:20:50 <astrolabe> Is there a standard type for infinite 'lists'?
02:21:19 <Cale> nothing standard
02:21:38 <Cale> data Stream a = Cons a (Stream a)
02:22:06 <astrolabe> Thanks.  A shame, maybe there should be a class containing lists and streams.
02:26:29 <dons> davidhouse: ? only the ones last night
02:26:45 <dons> @instance Functor
02:26:45 <lambdabot> Maybe you meant: instances instances-importing
02:26:51 <dons> @instances Functor
02:26:52 <lambdabot> [], IO, WriterT w m, Writer w, ReaderT r m, Reader r, StateT s m, State s, RWST r w s m, RWS r w s, ErrorT e m, Either e, ContT r m, Cont r, Maybe, ST s
02:27:14 <roconnor> is there a pretty printer for Haskell?
02:27:16 <dons> davidhouse: do you think you could sort that list alphabetically?
02:27:20 <dons> roconnor: several
02:27:34 <roconnor> I want my code to fit in 80 columns
02:27:38 <davidhouse> oh, creat! :)
02:27:44 <dons> ?pretty let x :: Int; x = 1 in case False of True -> x ; False -> x
02:27:44 <lambdabot>  i = let
02:27:44 <lambdabot>    x :: Int
02:27:44 <lambdabot>    x = 1
02:27:44 <lambdabot>    in
02:27:44 <lambdabot>    case False of
02:27:46 <lambdabot>     True -> x
02:27:47 <davidhouse> dons, yeah, there were two patches in that bundle
02:27:48 <lambdabot>     False -> x
02:27:54 <dons> roconnor: look at Language.Haskell
02:28:01 <dons> and also, the wiki page
02:28:04 <dons> ?wiki Indent
02:28:04 <lambdabot> http://www.haskell.org/haskellwiki/Indent
02:28:07 <roconnor> dons: um, I think that may be too pretty
02:28:45 <dons> davidhouse: oh, you could try resending anything i forgot to apply. darcs will work out if anything is missing
02:29:25 <davidhouse> @type \a b c d e f g h i j k l m n o p q r s t u v w x y z  -> a b c d e f g h i j k l m n o p q r s t u v w x y z
02:29:26 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25. (t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10 -> t11 -> t12 -> t13 -> t14 ->
02:29:26 <lambdabot> t15 -> t16 -> t17 -> t18 -> t19 -> t20 -> t21 -> t22 -> t23 -> t24 -> t25) -> t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10 -> t11 -> t12 -> t13 -> t14 -> t15 -> t16 -> t17 -> t18 ->
02:29:26 <lambdabot> t19 -> t20 -> t21 -> t22 -> t23 -> t24 -> t25
02:29:27 <dons> roconnor: The Language.Haskell printer lets you set a maximum line width, iirc
02:29:35 <davidhouse> nope, you applied that one too, it seems.
02:29:52 <davidhouse> previously, lambdabot would print each of the t, t1, t2... on a seperate ilne.
02:29:58 <dons> davidhouse: also, regards the @type, it should be a lot better in ghc 6.5, which improved their type pretty printing
02:30:10 <dons> so maybe i could have just upgraded the compiler i'm using.
02:30:13 <dons> maybe this is ok too, though
02:31:16 <roconnor> ribbons per line?
02:37:44 <roconnor> oops, Language.Haskell doesn't seem to like my infix type constructors.
02:37:50 <roconnor> Well, that's fair I suppose.
02:51:01 <davidhouse> dons, just sent to a patch to sort @instances' output alphabetically
03:25:21 <davidhouse> @instances Show
03:25:22 <lambdabot> Float, Double, Integer, ST s a, [a], (a, b, c, d), (a, b, c), (a, b), (), Ordering, Maybe a, Int, Either a b, Char, Bool
03:25:28 <xerox> Wooo.
03:25:33 <davidhouse> mmm. :) i'm quite proud of that
03:25:41 <davidhouse> @instances-importing Text.Html HTML
03:25:42 <lambdabot> [a], HtmlTree, HtmlTable, Html, HotLink, Char
03:26:05 <xerox> @karma+ davidhouse 
03:26:05 <lambdabot> davidhouse's karma raised to 4.
03:27:09 <davidhouse> @instances State
03:27:10 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
03:27:19 <davidhouse> even does error-handling, hehe :)
03:27:35 <xerox> (:
03:27:43 <amiddelk> davidhouse: do I see a double space there? ;)
03:27:45 <mauke> why are there two spaces between the and module?
03:29:10 <davidhouse> err
03:29:17 <davidhouse> poetic license.
03:34:55 <ndm> davidhouse: how do you get the initial instances information?
03:35:32 <davidhouse> ndm, it's scrounging from GHCi :i.
03:35:33 <xerox> :info <Class> does it.
03:35:49 <ndm> davidhouse: thats not very reliable - it depends entirely on teh modules imported
03:35:53 <ndm> try haddock -hoogle :)
03:36:08 <davidhouse> hoogle doesn't appear to get all of them, though.
03:36:10 <davidhouse> e.g.
03:36:12 <davidhouse> @instances Monad
03:36:13 <lambdabot> [], ArrowMonad a, WriterT w m, Writer w, ReaderT r m, Reader r, StateT s m, State s, RWST r w s m, RWS r w s, ErrorT e m, Either e, ContT r m, Cont r, Maybe, ST s, IO
03:36:29 <davidhouse> that's about twice as many as was on the haddock page when i looked
03:36:58 <ndm> so thats a fault of haddock?
03:37:21 <ndm> hoogle doesn't get Monads, but thats a bug in hoogle, that shouldn't be in haddock -hoogle
03:37:51 <ndm> I originally tried to get hoogle data out of GHCi :i
03:38:00 * xerox resumes his Monkey Island game...
03:38:24 <ndm> but I found you needed to load every module, so wrote a script to do that, and realise that GHCi wasn't really designed to do that - it slows to a crawl quite quickly...
03:38:27 * johnnowak is also playing monkey island!!
03:38:34 <amiddelk> old-skool
03:38:46 <xerox> Really? johnnowak, cool.
03:39:00 <johnnowak> verox: Yes, the girlfriend is making me, haha. She loves it.
03:39:07 <johnnowak> er.. xerox too.
03:39:26 <xerox> haha :)
03:42:25 <davidhouse> ndm, okay, another reason not to use haddock's hoogle output: there are too many instances for things like Show! my plugin imports a standard set to begin with. you can then tell it to import more on top of that
03:42:41 <davidhouse> @instances-importing Data.Int Show
03:42:42 <lambdabot> Float, Double, Int8, Int64, Int32, Int16, Integer, ST s a, [a], (a, b, c, d), (a, b, c), (a, b), (), Ordering, Maybe a, Int, Either a b, Char, Bool
03:42:52 <ndm> yes, that is a valid reason :)
03:44:34 <ndm> @instances Show
03:44:35 <lambdabot> Float, Double, Integer, ST s a, [a], (a, b, c, d), (a, b, c), (a, b), (), Ordering, Maybe a, Int, Either a b, Char, Bool
03:45:00 <bolrod> hrm... ByteString doesn't support profiling?
03:56:49 <eivuokko> bolrod, You can compile it with profiling enabled, as well
04:16:41 <Itkovian> is there something like zipWith for PHP?
04:16:51 <Itkovian> or does one write than himself?
04:18:08 <mauke> PHP doesn't even have function pointers :/
04:23:01 <Cale> Itkovian: you're generally expected to do that with a loop
04:23:01 <davidhouse> mauke: yeah it does
04:23:26 <Itkovian> Cale: yeah, crappy, ain't it ;-)
04:23:34 <davidhouse> mauke: http://us2.php.net/callback
04:23:53 <davidhouse> e.g. usort('my_comparing_function', $my_array);
04:24:11 <davidhouse> that's equivalent to sortBy myComparingFunction myList
04:24:46 <Cale> heh, you pass a string?
04:25:20 <davidhouse> yep.
04:25:26 <mauke> davidhouse: that's not a function pointer
04:25:28 <davidhouse> you can also pass a reference
04:25:42 <mauke> how do I get a reference to a function?
04:26:00 <davidhouse> usort(array(&$object, 'method_of_object'), $my_array)
04:26:07 <davidhouse> not really a reference, i suppose
04:26:19 <mauke> oh, shitty closure workaround
04:26:23 <davidhouse> mauke: okay, it's not a function pointer, but it's as good as one
04:26:36 <mauke> not really
04:26:36 <Cale> strings aren't exactly robust in that regard
04:26:53 <Cale> I figure it's doing something like calling eval after splicing them into things
04:26:54 <mauke> make a typo, and you get random runtime failures
04:27:22 <davidhouse> make a typo in any dynamically typed language and it's the same
04:27:28 <Cale> and you're forced to make the functions you want to use that way global
04:27:40 <davidhouse> usort('my_comparing_function', $my_arra); // runtime error
04:27:43 <mauke> Cale: read http://php.net/create_function and weep
04:27:44 <Cale> (at least, as far as I can see)
04:27:56 <mauke> davidhouse: that's a compile time error in perl
04:27:57 <davidhouse> Cale, all functions in PHP are global or members of objects
04:28:13 <mauke> "Creates an anonymous function from the parameters passed, and returns a unique name for it."
04:28:16 <Cale> oh, right
04:28:23 <Cale> heh
04:28:46 <Cale> not exactly anonymous anymore, then is it?
04:28:59 <davidhouse> mauke: is that create_function()?
04:29:18 <davidhouse> create_function() is a kludge toward lambda abstraction.
04:30:15 <davidhouse> Cale, it's anonymous in that you can pass it straight into a usort() or similar
04:30:53 <davidhouse> you don't have to actually write function my_anon_func($a, $b) { return $a * $b } or whatever
04:31:24 <Itkovian> all languages should have zip, fold, map and filter
04:31:35 <Itkovian> well, just zip and fold
04:32:03 <davidhouse> well, in imperative languages, you use loops instead of list manip.
04:32:36 <davidhouse> if this were ##php, they'd be saying "all languages should have for, foreach and while".
04:33:51 <Itkovian> lol
04:34:42 <Cale> hahaha
04:38:35 <Maddas> davidhouse: I'd think that it would be a compile-time error for most dynamically typed languages.
04:39:03 <Maddas> ...oh, maybe not, I forgot global variables.
04:39:31 <Itkovian> global what?
04:39:33 <Itkovian> ;-)
04:40:10 <Maddas> Itkovian: What? I have no idea what you are talking about!
04:47:42 <kzm> Just checking: but a TChan is the right thing when I have multiple writers that need to be funneled out so that they don't mess up each other's output?
04:47:51 <kzm> (the docs are kinda sparse)
04:53:00 <roconnor> anyone have a library for multivariable polynomials that will compute partial derivatives?
04:55:18 <apfelmus> roconnor: if you need derivatives only once, perhaps maxima will do 
04:55:35 <roconnor> I need haskell code.
04:55:58 <roconnor> perhaps I should write it myself
04:57:53 * kzm sighs.  "thread blocked indefinitely"
04:58:35 <roconnor> kzm: you using STM?
04:58:39 <kzm> not yet.
04:58:48 <apfelmus> roconnor: you seem to be on your own then :-|
04:58:48 <kzm> Control.Conc.Chan
04:59:18 <roconnor> apfelmus: I'll figure something out.  I figured I'd vaguely check here first.
04:59:20 <kzm> roconnor, you want symbolic derivation?
05:00:11 <roconnor> kzm: I have polynomials over (Num a) so yes.
05:00:37 <roconnor> sorry, I have multi-variable polynomials ...
05:03:14 <roconnor> maybe this is my big chance to use GADTs
05:03:28 <roconnor> I can use the type system to keep track of the number of variables of the multinomial.
05:04:30 <apfelmus> roconnor: lifting your existing polynomials from Num[X] to (anyring)[X] will give you Num[X][Y] for free.
05:05:08 <roconnor> apfelmus: I was noticing that.  But I don't get partial deriviatives for free.
05:05:39 <roconnor> however I might be able to get away with only needing derivatives of the outer most variable for my purposes.
05:05:47 <roconnor> then I would have everything for free.
05:06:21 <apfelmus> roconnor: indeed. (Num[X])[Y] gives free derivatives in Y.
05:06:50 * roconnor needs to sort stuff out in his head
05:07:44 <apfelmus> the iso Num[X][Y] ~ Num[Y][X] should give you free derivatives in the first variable then,
05:08:20 <roconnor> yeah, but computing the iso is a bit tricky in general.
05:08:28 <roconnor> sure in this case it is just transpose
05:09:06 <roconnor> but Num[x1]..[xn] taking the derivative wrt xi is a bit tricky
05:09:17 <apfelmus> mh, right.
05:09:27 <roconnor> doable, certainly not free
05:10:22 <xerox> roconnor - Were you the guy talking about porting Coq to Haskell?
05:10:53 <roconnor> xerox: sounds like something I'd say
05:11:04 <xerox> Any... news? (:
05:11:26 <roconnor> well, there is another impelmenation of Coq, but I'm not sure the language it is written in.
05:11:38 <apfelmus> ah, maybe      inj :: R -> R[X], fmap :: (R -> R) :: R[X]->R[X], derivate :: R[X] -> R[X]
05:12:42 <apfelmus> and then: derivateany :: Zero -> R[X] -> R[X]
05:13:46 <boegel> is anybody running Alpha computer at his work place or at home which I can use to burn cycles?
05:13:59 <apfelmus> derivateany :: Succ(Zero) -> R[X][Y] -> R[X][Y], derivateany _ poly = fmap derivate poly
05:14:19 <roconnor> xerox: it appears to be in OCaml
05:14:35 <xerox> I knew that one, allright.
05:15:18 <roconnor> apfelmus: oh right, you can do a parital derivitive by ``lifting'' the derivative operator a suitable number of times
05:15:33 <roconnor> I hadn't thought of that
05:15:41 <roconnor> that's not too hard at all
05:15:46 <apfelmus> roconnor: yeah, you fmap the outer derivative as many times as a dependent type tells you
05:16:40 <roconnor> apfelmus: does GADTs give us the dependent types we need?
05:17:18 <roconnor> oh wait
05:17:23 <roconnor> I see what you have done
05:17:42 <roconnor> How is Succ declaired ?
05:17:54 <ADEpt> question: where to send patches to HAppS ?
05:17:55 <apfelmus> roconnor: Succ is on the type level
05:18:14 <roconnor> But how do I define it.  Is it just data Succ a = 
05:18:54 <roconnor> or data Succ a = () if you want to be haskell 98?
05:19:17 <apfelmus> you do some functional dependencies. wait a moment, i need to find the page...
05:19:24 <roconnor> right, I see
05:19:39 <roconnor> deriviateany has to be part of a class, so it can have multiple types
05:21:19 <apfelmus> roconnor: yes. the "static haskell programmer" from http://www.willamette.edu/~fruehr/haskell/evolution.html is my favourite example for fundep mess
05:23:57 <roconnor> I'm going to see if I can get away with just outer deriviatives ;)
05:24:38 <apfelmus> roconnor: that makes me sad  :( 
05:25:40 <roconnor> someone out to implement the general partial deriviate this way.
05:26:29 <apfelmus> roconnor: give me a minute and a place to put a code snippet on
05:26:53 <roconnor> I don't think it can be done in a minute
05:27:15 <apfelmus> roconnor: then give me 2 ;-)
05:27:29 <roconnor> @lisppaste
05:27:29 <lambdabot> Unknown command, try @list
05:27:32 <roconnor> @lisp-paste
05:27:33 <lambdabot> Unknown command, try @list
05:27:52 <roconnor> bah, you can just put your result on the Haskell wiki
05:28:46 <ndm> @paste
05:28:46 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:28:56 <ndm> lisppaste2: @url
05:28:57 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:32:29 <kzm> anybody use nmergeIO?
05:38:03 <lisppaste2> roconnor pasted "Basic Multinomials" at http://paste.lisp.org/display/20750
05:51:13 <lisppaste2> roconnor annotated #20750 with "More Multinomials" at http://paste.lisp.org/display/20750#1
05:51:25 <lisppaste2> apfelmus annotated #20750 with "adding derivatives" at http://paste.lisp.org/display/20750#2
05:51:40 <roconnor> *Multinomial> let yP = (constP xP) in xP^2 + xP*yP - yP^2
05:51:40 <roconnor> Poly [Poly [0,0,-1],Poly [0,1],Poly [1]]
05:51:44 <roconnor> This is great!
05:53:27 <apfelmus> roconnor: it took a bit more then 2 minutes ;-)
05:54:09 <roconnor> apfelmus: still, disturbingly short
05:54:25 <roconnor> apfelmus: can I freely use your code for any purpose I please?
05:54:41 <roconnor> I promise never to sue you if your code should harm anyone.
05:56:10 <apfelmus> roconnor: i'll ask my lawyer ;-) ... wait, he says it's surely worth a Mio$$ software patent :-)
05:56:37 <roconnor> I bet you can patent using dependent types to do deriviatives.
05:58:48 <apfelmus> roconnor: now, I no more have a trustworthy lawyer, so the code is public domain before he is going to patent it for himself ... ;-)
05:59:14 <roconnor> damn, now there is prior art!
05:59:23 <roconnor> quick, hide the IRC logs
06:00:55 <apfelmus> @brain, enforce law now!
06:00:56 <lambdabot> Troz!
06:07:00 <Foobar> Is there an alternative to nesting if experssions without indenting?
06:07:13 <Foobar> er expressions
06:07:13 <davidhouse> $
06:07:25 <dons> well, do them on one line?
06:07:30 <roconnor> don't curly braces always work?
06:07:31 <dons> or use explicit layout
06:07:39 <int-e> add explicit { }
06:07:52 <davidhouse> semicolons, or semicolons with { }
06:08:03 <Foobar> Braces. Thanks :)
06:08:10 <davidhouse> > do Just 4; Nothing; 4
06:08:11 <lambdabot>  add an instance declaration for (Num (Maybe t))
06:08:11 <lambdabot>   In the result of a 'do' ...
06:08:14 <davidhouse> > do Just 4; Nothing; Just 4
06:08:14 <lambdabot>  Nothing
06:08:14 <dons> if x then do { ; ; ; } else do x ; y ; z and friends
06:08:16 <int-e> (indentation is converted to {, ; and } by some more or less intuitive rules)
06:08:59 <davidhouse> > runState (do s <- get; put s + 1; return $ s - 1) 4
06:09:00 <lambdabot>  add an instance declaration for (Num (State s ()))
06:09:12 <davidhouse> > runState (do s <- get; put (s + 1); return $ s - 1) 4
06:09:13 <lambdabot>  (3,5)
06:11:51 * dons -> sleep
06:13:16 <yip> i sort of understand monads, but i only just barely get arrows, how can i learn more?
06:14:00 <kosmikus> yip: have you read John Hughes' AFP article about arrows?
06:14:11 <apfelmus> @google fun of programming arrows
06:14:13 <lambdabot> http://web.comlab.ox.ac.uk/oucl/publications/books/fop/
06:14:35 <davidhouse> yip, what don't you get about them?
06:14:52 <davidhouse> they're very easy once you've got monads
06:15:47 <kosmikus> I don't think so. Arrows are much harder to understand, because they have fewer interesting (known) applications.
06:16:20 <davidhouse> structurally, though, they're deceptively easy. it's not like a whole new step upwards
06:16:21 <apfelmus> for arrows, i've read http://www.soi.city.ac.uk/~ross/papers/fop.html
06:16:44 <davidhouse> yep, Arrows and Computation (that URL apfelmus posted) was good for me too.
06:17:15 <kosmikus> davidhouse: true, it's easy enough to understand the interface, but it's not so easy to see a problem and say "now here's something that'd really benefit from making it into an instance of Arrow"
06:17:41 <apfelmus> kosmikus, davidhouse: no interesting apps?? i'd like to program arrows *only*!
06:18:03 <kosmikus> apfelmus: really? why?
06:18:35 <davidhouse> kosmikus: true. i'm at that stage: analysing my work, looking for a nice arrow application
06:18:42 <apfelmus> the yampa (functional reactive programming) library is almost impossible without arrow (notation)
06:18:51 <davidhouse> once i've written something with Arrows, perhaps i'll then fully understand them.
06:18:59 <yip> kosmikus: yeah
06:19:03 <kosmikus> ok, yampa is one of the few examples where they turn out to be useful
06:19:16 <kosmikus> davidhouse: I've been at that stage. I never found one ;)
06:19:25 <yip> yampa i can actually use and i've done some cool things with it
06:19:56 <lisppaste2> roconnor annotated #20750 with "Multinomial - all together" at http://paste.lisp.org/display/20750#3
06:20:02 <yip> but i'm reading through the source of HXT and it has like dozens of different types of arrows and it's all really complicated
06:20:06 <kosmikus> I think that "applicative functors" seem to be a much more accessible generalisation of monads.
06:20:43 <apfelmus> well, imho the most important thing about arrows is the sugared notation for them.
06:21:13 <roconnor> prop_test_dxy = dx (dy f) == dy (dx f)
06:21:14 <int-e> . o O ( type Poly3 a = Poly (Poly (Poly a)), type Poly9 a = Poly3 (Poly3 (Poly3 a)) )
06:21:33 <apfelmus> with it, you can fake variables and introduce point free notation where in reality there is none
06:21:52 <yip> like this IOStateListArrow i am totally lost on it
06:23:09 <apfelmus> the PAN (functional images) library perhaps benefits from an even weaker version of arrows
06:24:02 <int-e> Applicative (formerly Idiom)?
06:24:26 <roconnor> int-e: does template haskell sove that?
06:24:39 <roconnor> the Poly 9 thing.
06:25:39 <int-e> roconnor: hmm, it certainly can do that.
06:26:03 <apfelmus> pan   image code actually is no haskell anymore, for performance reasons, they use C
06:26:44 <apfelmus> so it "fakes" haskell point free code
06:26:59 <kosmikus> int-e: yes, Applicative, formerly Idiom
06:27:00 <roconnor> It will probably also let me define x_n as constP (x_(n-1)) and x_0 as xP
06:27:13 <davidhouse> could someone give me a one-line summary of a 2-3 tree?
06:27:31 <roconnor> red-black tree?
06:27:43 <kosmikus> apfelmus: you mean that arrow notation allows you to use point*wise* notation ...
06:28:18 <apfelmus> kosmikus: err, of course.
06:28:48 <davidhouse> roconnor: fine, give me a one-line summary of a r-b tree :)
06:29:50 <yip> what is ~?
06:30:00 <davidhouse> is just a tree where each node has either two or three children, and all the nodes appear at the same depth?
06:30:06 <davidhouse> yip, in pattern matches?
06:30:10 <Foobar> Is it possible (in GHC) to disable all debug messages from Debug.Trace (without me adding an if debug to every debug statement)? 
06:30:11 <yip> Daveman: yes
06:30:42 <davidhouse> yip, turns a strict pattern into a lazy one. it asserts that the pattern will match but delays the actual matching.
06:31:03 <yip> davidhouse: hm............................ not sure i quite understand
06:31:14 <davidhouse> Foobar, try something like ghci &3>/dev/null or whatever it is
06:31:16 <davidhouse> yip:
06:31:35 <davidhouse> > let f (x, y) = const 4 in f undefined
06:31:36 <apfelmus> Foobar: i always use mytrace s = trace s if i debug and mytrace s = s if i don't debug
06:31:36 <lambdabot>  Add a type signature
06:31:40 <davidhouse> > let f ~(x, y) = const 4 in f undefined
06:31:40 <lambdabot>  Add a type signature
06:31:45 <davidhouse> oops
06:31:51 <davidhouse> > let f (x, y) = 4 in f undefined
06:31:51 <int-e> > (\ (a, b) -> 42) undefined
06:31:52 <lambdabot>  Undefined
06:31:52 <lambdabot>  Undefined
06:31:57 <davidhouse> > let f ~(x, y) = 4 in f undefined
06:31:58 <lambdabot>  4
06:32:48 <Foobar> davidhouse: Ah, yes trace goes to stderr
06:34:13 <Igloo> Does anyone know more about "6.4.2 now works correctly with gcc 4.x; if you are using gcc 4.x, then you need 6.4.2." on http://haskell.org/ghc/docs/6.4.2/html/users_guide/release-6-4-2.html ?
06:34:43 <yip> what is :->
06:35:01 <davidhouse> yip, it's probably defined somewhere in that module
06:35:50 <yip> davidhouse: i thought that operators are not allowed to start with :
06:36:14 <Igloo> JaffaCake: Do you have an update on when you expect 6.4.3 to be released?
06:36:23 <davidhouse> yip, it's probably a data constructor then
06:36:32 <yip> oh yeah right
06:37:00 <JaffaCake> Igloo: waiting mainly for something to happen on the MacOS X front
06:37:32 <JaffaCake> Wolfgang has been quiet, he said he's been quite busy
06:38:01 <davidhouse> JaffaCake, the GHC website still says "The STABLE branch is still ghc-6-4-branch, and we expect there to be one further release from this branch (6.4.2)"
06:38:14 <Igloo> JaffaCake: Hmm, OK. How important is the above gcc 4.x with ghc < 6.4.2 warning on Linux?
06:38:16 <JaffaCake> davidhouse: oh, thanks
06:38:40 <vincenz> re
06:39:01 <JaffaCake> Igloo: I'd have to go check the diffs, but I beileve some fixes went into the mangler for gcc 4.x
06:40:22 <Igloo> Hmm, OK
06:40:28 <SamB_XP> hmm, I haven't noticed anything yet!
06:41:20 <SamB_XP> is it smart enough to call an earlier version?
06:41:37 <JaffaCake> Igloo: I don't recall the details, but I remember when I upgraded our x86_64 box to gcc 4.1, I had to fix some things in GHC
06:41:54 <roconnor> apfelmus: this multinomial code is totally awsome.  It just needs a pretty printer.
06:42:13 <roconnor> and maybe some template haskell
06:42:29 <roconnor> *Multinomial> dx $ 4*xP*(1-xP)
06:42:29 <roconnor> Poly [4,-8]
06:43:07 <roconnor> *Multinomial> (dx $ 4*xP*(1-xP)) == (4-8*xP)
06:43:07 <roconnor> True
06:44:22 <apfelmus> roconnor: indeed. btw, for space reasons, multinomials with 2 or more variables are commonly stored in a sparse representation.
06:46:20 <roconnor> still, this is less than 100 lines of code
06:47:06 <apfelmus> roconnor: well, that's why we're using |-|askell, right? :-)
06:47:17 <roconnor> ;)
06:47:21 <int-e> hmm. would Poly a -> [(Int, a)]  (Int being the exponent) be reasonably efficient?
06:47:59 <apfelmus> int-e: depends on your needs.
06:48:31 <roconnor> Poly a => Map Int a
06:48:38 <int-e> apfelmus: addition and multiplication.
06:49:21 <int-e> apfelmus: well, I expect it also depends on the size of the polynomials I expect to deal with.
06:49:25 <davidhouse> apfelmus: polyPlus = zipWith (+)
06:49:26 <roconnor> I should add the evalutation function.
06:49:37 <int-e> roconnor: yes, that'd be the next obvious choice.
06:51:04 <davidhouse> well, almost
06:51:45 <davidhouse> define plusPart (Poly x) (Poly y) = Poly (x + y), then polyPlus = zipWith polyPlus
06:52:02 <roconnor> 0 + x = 0
06:52:16 <mauke>  Cannot import `Distribution.Simple': it was found in multiple packages: Cabal-1.1.3 Cabal-1.1.4
06:52:25 <mauke> how does GHC know where to look for packages?
06:52:33 <int-e> davidhouse: [-1] + [1] = []
06:53:00 <vincenz> int-e: filter isZero
06:53:15 <apfelmus> int-e: that's the point. as long as you do not like to extract particular coefficients, a list is perfect (if it's accessed, all numbers are processed anyway)
06:53:17 <roconnor> polyPlus = Map.unionWith +
06:53:19 <roconnor> polyPlus = Map.unionWith (+)
06:53:38 <davidhouse> int-e, well, the current polyPlus would make that mistake too
06:53:54 <davidhouse> roconnor: how? they're not maps
06:54:25 <roconnor>  Poly a => Map Int a
06:54:32 <int-e> davidhouse: heh. I have my own Poly implementation which doesn't.
06:55:04 * apfelmus almost starves and gets some eat
06:55:13 * apfelmus meat
06:56:39 <int-e> unionWith is good :) now if it had a way to let values cancel out each other, that'd be even nicer.
06:57:25 <apfelmus> int-e: important! otherwise sparse representation quickly gets dense
06:57:43 <roconnor> Map.filter (/=0)
06:58:04 <roconnor> bah, what are the chances anything will cancel ;)
06:58:10 * apfelmus realizes that his home-dungeon does not provide enough %
06:58:19 <davidhouse> newtype Coefficient = Coeff Int
06:58:28 <davidhouse> hmm, no, that won't work
06:58:52 <int-e> hmm. I'd probably use fromAscList . <some code> . toAscList
06:58:59 <roconnor> davidhouse: you have see our paste?
06:59:23 <davidhouse> roconnor: that's what i looking at
06:59:38 <davidhouse> int-e, to do what?
06:59:41 <int-e> but I have no idea which version is better. (it also depends on whether the two polynomials have lots of monomials in common or not)
06:59:45 <dozer> can I have 64bit indexed arrays in haskell? I need to build a /big/ table indexed by hashcodes (don't ask)
06:59:50 <int-e> davidhouse: to add two polynomials
07:00:00 <roconnor> @hoogle word64
07:00:01 <lambdabot> Data.Word.Word64 :: data Word64
07:00:23 <roconnor> map Word64 a
07:00:42 <int-e> davidhouse oh, I missed a merge operation in that - there would be two toAscList
07:00:45 <roconnor> Map Word64 a
07:00:51 <davidhouse> int-e, i like unionWith and filter.
07:00:57 <dozer> roconnor: this is more like using the word64 as an offset into the array
07:01:13 <roconnor> > 2^64
07:01:14 <lambdabot>  18446744073709551616
07:01:18 <int-e> davidhouse: I still think a combineWith (which also allows deleting elements) would be the best choice.
07:01:34 <davidhouse> yes, probably.
07:01:46 <roconnor> dozer: your array is going to be sparse.
07:01:54 <int-e> davidhouse: unionWith = O(number of affected entries + log(n)) I believe. filter = O(number of entries), combine could be done as fast as unionWith.
07:01:56 <roconnor> might as well use Map I would think
07:01:57 <dozer> roconnor: almost certainly not
07:02:07 <int-e> davidhouse: (the first n is the number of entries, too)
07:02:26 <roconnor> dozer: you have 18446744073709551616 bytes of ram?
07:02:39 <int-e> > log 18446744073709551616/log 2
07:02:40 <davidhouse> combineWith :: (a -> a -> Maybe b) -> Map k a -> Map k a -> Map k b
07:02:40 <lambdabot>  64.0
07:02:58 <davidhouse> > logBase 2 18446744073709551616
07:02:59 <lambdabot>  64.0
07:03:01 <dozer> roconnor: well, I have 32G, and the java version of this app uses 28G
07:03:04 <int-e> davidhouse: right
07:03:11 <dozer> roconnor: not all 64 bits are significant for the index
07:03:25 <roconnor> how many bits are sigifigant?
07:03:35 <int-e> davidhouse: err, except the two b in the type need to be a
07:03:40 <dozer> that's a user-set parameter, steps in multiples of 5
07:04:01 <davidhouse> hmm, why?
07:04:03 <int-e> davidhouse: (I still want to keep the keys/values that occur in only one map)
07:04:09 <davidhouse> oh, right.
07:04:24 <roconnor> dozer: in that case you question is out of my league. :-)
07:04:48 <int-e> ah. but then we can already implement combine efficiently, on top of intersectionWith, filter and union.
07:04:51 <int-e> cool.
07:05:45 <dozer> do you know if haskell compilers can produce code that addresses large amounts of memory? eg. >4G on a 64bit system?
07:06:23 <ndm> dozer: Yhc can
07:06:34 <ndm> although it would probably be quite slow
07:07:35 <int-e> combineWith f a b = (map unJust . filter isJust . intersectWith f a b) `union` (union a b)
07:08:14 <davidhouse> map unJust . filter isJust = mapMaybe
07:08:21 <davidhouse> oh, never mind
07:08:22 <int-e> combineWith f a b = (update id . intersectWith f a b) `union` (union a b)
07:08:29 <int-e> oh.
07:08:56 <davidhouse> no, (map unJust . filter isJust .) . map = mapMaybe
07:09:11 <int-e> @type mapMaybe
07:09:13 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
07:09:22 <vincenz> davidhouse: evein better
07:09:32 <vincenz> [ x | (Just x) <- map f]
07:09:39 <davidhouse> > mapMaybe (\k -> lookup k [(1, "hello"), (2, "world")]) [1..3]
07:09:39 <lambdabot>  ["hello","world"]
07:09:44 <int-e> Uh, the code was for Data.Map though.
07:09:46 <int-e> not lists./
07:09:51 <davidhouse> int-e, yeah.
07:10:00 <davidhouse> i wrote a mapMaybeMap, i think
07:10:20 <vincenz> mapmaybemap?
07:10:23 <vincenz> what is that supposed to do
07:10:23 <davidhouse> :)
07:10:32 <davidhouse> mapMaybe for Data.Maps
07:10:39 <vincenz> ...
07:10:43 <vincenz> I still fail to see the use
07:10:46 <int-e> if it were in Data.Map, it'd be Map.mapMaybe
07:11:23 <vincenz> you mean ts?
07:11:24 <vincenz> update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
07:11:32 <int-e> davidhouse: but how is it different from update?
07:11:33 <int-e> :)
07:11:49 <davidhouse> oh, perhaps i didn't write that then
07:12:30 <davidhouse> int-e, you'd need map (update id)
07:12:46 <int-e> oh.
07:12:53 <int-e> right :/
07:13:07 <vincenz> be nice if there were a fmapM for Data.Map
07:13:10 <int-e> I'll stick to map . filter then :/
07:15:06 <int-e> heh. combineWith f a b = b `union` differenceWith f a b
07:16:38 <vincenz> why not plain unionWith
07:16:52 <int-e> different type
07:17:01 <vincenz> unionWith . fmap
07:17:04 <davidhouse> we want to be able to delete elems
07:17:14 <int-e> f is of type a -> a -> Maybe a
07:17:27 <vincenz> ah
07:18:21 <int-e> @type Data.Map.differenceWith
07:18:22 <lambdabot> forall a k b. (Ord k) => (a -> b -> Maybe a) -> Data.Map.Map k a -> Data.Map.Map k b -> Data.Map.Map k a
07:18:40 <davidhouse> @type let combineWith f a b = b `union` differenceWith f a b in combineWith
07:18:41 <lambdabot> Not in scope: `differenceWith'
07:18:50 <int-e> add M. :)
07:18:55 <davidhouse> @type let combineWith f a b = b `Data.Map.union` Data.Map.differenceWith f a b in combineWith
07:18:56 <lambdabot> forall a k. (Ord k) => (a -> a -> Maybe a) -> Data.Map.Map k a -> Data.Map.Map k a -> Data.Map.Map k a
07:20:00 <vincenz> @type let a = b; b = a in a
07:20:01 <lambdabot> forall t. t
07:22:15 <davidhouse> > let combineWith f a b = b `Data.Map.union` Data.Map.differenceWith f a b in combineWith (\x y -> if x + y == 0 then Nothing else Just (x + y)) (Data.Map.fromAscList [(0, 1), (1, 2), (2, -1)]) (Data.Map.fromAscList [(0, 4), (1, -1), (2, 1)])
07:22:16 <lambdabot>  Not in scope: `Data.Map.fromAscList'
07:22:31 <davidhouse> > let combineWith f a b = b `Data.Map.union` Data.Map.differenceWith f a b in combineWith (\x y -> if x + y == 0 then Nothing else Just (x + y)) (Data.Map.fromList [(0, 1), (1, 2), (2, -1)]) (Data.Map.fromList [(0, 4), (1, -1), (2, 1)])
07:22:31 <lambdabot>  Not in scope: `Data.Map.fromList'
07:22:52 <davidhouse> i wish @run were more flexible in its imports.
07:23:32 <davidhouse> int-e, that gives {0:=4,1:=-1,2:=1}
07:23:41 <int-e> > M.fromList [(0,1), (2,3)]
07:23:43 <lambdabot>  {0:=1,2:=3}
07:24:07 <int-e> (runPlugs does a import qualified Data.Map as M)
07:24:19 <davidhouse> > let combineWith f a b = b `M.union` M.differenceWith f a b in combineWith (\x y -> if x + y == 0 then Nothing else Just (x + y)) (M.fromList [(0, 1), (1, 2), (2, -1)]) (M.fromList [(0, 4), (1, -1), (2, 1)])
07:24:20 <lambdabot>  {0:=4,1:=-1,2:=1}
07:24:41 <int-e> oh.
07:25:25 <int-e> let me try that in ghci. there's one or two things that need to be fixed.
07:26:12 <mux> mmm, so arrows are just morphisms?
07:26:22 <int-e> > let combineWith f a b = (b `M.difference` a) `M.union` M.differenceWith f a b in combineWith (\x y -> if x + y == 0 then Nothing else Just (x + y)) (M.fromList [(0, 1), (1, 2), (2, -1)]) (M.fromList [(0, 4), (1, -1), (2, 1)])
07:26:23 <lambdabot>  {0:=5,1:=1}
07:26:33 <mux> that is associative
07:27:38 <int-e> davidhouse: thanks for pointing that out.
07:28:29 <mux> correcting: an arrow is an associative morphism that has an identity element, and a pure method to lift purely-functional computation in the arrow?
07:28:30 <davidhouse> you know what?
07:28:50 <davidhouse> a _lot_ of haskell's syntax problems would be solved if we could use UTF8.
07:29:22 <dozer> or full unicode
07:29:24 <davidhouse> mux, it has first as well
07:29:38 <mauke> UTF8 is full unicode
07:29:46 <dozer> doh!
07:30:13 <dozer> is there a good reason not to in this day and age?
07:30:14 <kosmikus> fortress will have a syntax based on unicode (with the possibility to get a 7bit "view" of a program)
07:30:37 <mux> davidhouse: *nods* trying to make that fit into the picture
07:30:40 <kosmikus> I think the latter is still a requirement until there are very good input methods for unicode
07:30:45 <Igloo> kosmikus: fortress?
07:31:03 <kosmikus> Igloo: Sun's "language in development"
07:31:08 <dozer> not heard anything about fortress for at least a year
07:31:17 * dozer is not holding breath
07:31:17 <davidhouse> mux, i think they're equivalent to Freyd-categories if you like the CT picture
07:31:35 <mux> mmm, poetic.
07:31:45 <kosmikus> dozer: it's supposed to be finished by 2010!
07:31:46 <SamB> hmm, you'd think happy with no -g should still produce an OPTIONS or OPTIONS_GHC pragma to enable cpp...
07:32:28 <SamB> kosmikus: finished?
07:32:33 <int-e> Hmm hmm. How about  data Operaration k a c where { Include :: Operation k a a; Map :: (k -> a -> Maybe c) -> Operation k a c; Exclude :: Operation k a c }; combineWithKey :: Operation k a c -> Operation k b c -> (k -> a -> b -> Maybe c) -> Map k a -> Map k b -> Map k c  ... could you wish for more?
07:32:40 <kosmikus> SamB: well, "production-ready"
07:32:55 <SamB> doesn't sun know how long that takes?
07:33:21 <kosmikus> of course not finished as in "frozen forever"
07:33:42 <int-e> ignoring that 'Map' is a bad constructor name in a module that provides Map.
07:33:56 <SamB> hmm, yeah, the latter is impossible for a language that is not dead ;-)
07:34:16 <SamB> even BF has its variants
07:34:16 <vincenz> SamB: except C
07:34:29 <dozer> have you used proofgeneral? it seems to switch between prety symbols and text quite nicely
07:34:29 <SamB> though they generally all have the same syntax
07:34:35 <davidhouse> int-e, and the fact that Operaration has too many letters. :)
07:34:37 <int-e> ook ook
07:34:42 <SamB> vincenz: depend who you ask!
07:34:46 <int-e> davidhouse: oh.
07:34:55 <SamB> microsoft might feel that it is so
07:34:58 <vincenz> SamB: the dead part or the frozen par? :P
07:35:38 <SamB> vincenz: I meant the frozen part
07:35:56 <int-e> (the reason for having Include and Exclude would be performance - these operations can just throw away or keep subtrees instead of traversing them in full)
07:36:04 <vincenz> SamB: it is frozen
07:36:45 <SamB> vincenz: well, I say it doesn't really count as frozen until C99 is actually implemented!
07:37:04 <vincenz> what part is not?
07:37:38 <SamB> I was under the impression that GCC had not yet fully implemented C99?
07:37:41 <mux> VLAs
07:37:51 <mux> apart from that, it's OK as far as I can see
07:38:01 <vincenz> SamB: which parts?
07:38:04 <mux> or maybe it doesn't have complex.h too
07:38:09 <SamB> mux: what? it doesn't implement VLAs?
07:38:09 * mux shrugs
07:38:22 <SamB> that seems like such an easy one
07:38:25 <SamB> mux: GCC definately implements complex numbers
07:38:26 <mux> SamB: not in a fully compliant way
07:38:32 <mux> so that's cool
07:38:42 <mux> SamB: at least that's what they say
07:38:59 <SamB> well, I suppose it is further along than I thought
07:39:09 <mux> everything else I can think of in C99 is implemented in C99
07:39:19 <mux> well the parts that dpend on the compiler at least :-)
07:39:24 <SamB> I don't actually go through and check or anything, I just heard it had a ways to go
07:39:25 <mux> there is a fair bit of host support
07:39:58 <SamB> oh, and when I say "C99 is implemented", I don't mean that every part of it is implemented by at least one compiler...
07:39:59 <mux> there's not much to use in C99 anyways, apart from fixed-size types, sparse structure initializations and a few others
07:40:13 <SamB> I mean that there is one compiler that implements all the parts of it
07:40:25 <vincenz> SamB: but the language is frozen
07:40:28 <vincenz> language = spec
07:40:39 <SamB> oh, well, sure, the spec is
07:40:44 <SamB> specs are
07:40:54 <SamB> the Haskell 98 spec is frozen, too!
07:41:01 <vincenz> I didn't know c99 wasn't fully implemented yet... I know there are big problems with c++...
07:41:17 <vincenz> SamB: well it matters what you consider to be the same language but a different version, and what is a different language
07:41:29 <ndm> SamB, but it says that its intended to be a standard the evolves over time
07:41:29 <vincenz> SamB: I doubt C will have further versions
07:41:33 <SamB> yes, I suppose so
07:41:48 <mux> vincenz: http://gcc.gnu.org/c99status.html
07:41:55 <SamB> vincenz: yeah, you are probably right
07:42:12 <vincenz> a language thati's .. 30 years old and still not fully implemented, makes you worry about the design of it
07:42:15 <mux> VLAs are still tagged "broken"
07:42:36 <vincenz> heh
07:42:41 <vincenz> c++ took 5 years to get right
07:42:57 <vincenz> msvc 2003 I think was first compliant compiler
07:43:14 <SamB> well, the fact that the not-implemented features are only 7 years old makes it less worrisome, I think
07:43:36 <vincenz> SamB: I dunno... I find that quite old
07:43:41 <mux> from what I can see, every import C99 part is OK on FreeBSD with GCC
07:43:46 <mux> the rest I don't care ;-)
07:43:49 <SamB> I heard MS didn't care about C99
07:43:59 <mux> s/import//
07:44:02 <vincenz> SamB: I was talking about c++ now
07:44:05 <mux> brain-o
07:44:25 <mux> FreeBSD still lacks in the Haskell field!
07:44:48 <vincenz> mux: you mean haskell lacks in the freebsd field
07:44:58 <mux> oh yeah
07:45:06 <mux> sorry, I'm not a native english speaker :-)
07:48:25 <Cale> huh?
07:48:30 <Cale> It could be either way
07:48:46 <SamB> vincenz: oh
07:52:14 <vincenz> Cale: yeah but I think the semantics of mine is more apt
07:52:24 <vincenz> Cale: I didn't feel like pressing the point
07:53:12 <yip> what are functional dependencies?
07:54:12 <SamB> they let paramaters to a type class depend on others
07:54:39 <yip> does the -> token have anything to do with this?
07:54:43 <SamB> yes
07:54:50 <yip> and the | token?
07:55:01 <SamB> uh huh
07:55:23 <yip> class Arrow a => ArrowState s a | a -> s where
07:55:47 <SamB> yeah, that means that the "s" parameter is completely determined by the "a" parameter
07:56:06 <yip> this stuff is just insanely difficult for me to understand
07:56:51 <norpan> yip: it just means that if you have something that is ArrowState s Int for instance then the compile knows what s is and can type check it
07:57:09 <norpan> because there can only be one instance that matches
07:57:20 <Stinger_> sweet, gentoo ebuilds for gtk2hs
07:57:31 <SamB> MonadState does the same thing, doesn't it?
07:58:13 <SamB> norpan: only I don't think that Int is an arrow?
07:58:22 <norpan> and my example was a bit bad, because Int is not an Arrow
07:58:29 <norpan> but in general :)
08:00:01 <yip> can you please give a good example?
08:00:04 <SamB> if you have, say, a type "data StateArrow s x y = ..."
08:00:44 <SamB> and an "instance ArrowState s (StateArrow s)"
08:01:06 <dcoutts_> Stinger_, yep, being gtk2hs maintainer and a gentoo developer has certain benefits that way.. :-)
08:01:35 <Stinger_> heh
08:01:40 <SamB> the functional dependency means that you won't be plagued by ambiguity messages if you try to *use* it
08:02:04 <SamB> and, furthermore, that the compiler will actually know what you want
08:02:40 <SamB> yip: does that make sense?
08:02:44 * bolrod waits 'till the day compilers get so smart that they will refuse to compile code on the base that it sucks
08:02:48 <bolrod> :x
08:02:54 <yip> not really, sorry i guess i'm just not ready for this stuff yet
08:03:33 <yip> how did you guys learn all this stuff?
08:03:37 <SamB> well, try making a copy of Control.Monad.State and commenting out the functional dependencies
08:03:40 <SamB> then try using it
08:03:58 <SamB> maybe I learned it trying to do a collections framework ;-)
08:04:29 <yip> who is uwe schmidt?
08:04:52 <SamB> yip: I think if you copy Control.Monad.State and comment out the fundeps, you will learn what fundeps are for
08:05:02 <yip> hm...
08:05:20 <SamB> or maybe reading the documentation would work, too
08:05:47 <SamB> @google ghc documentation "functional dependencies"
08:05:49 <lambdabot> http://portal.acm.org/citation.cfm?id=1086397&dl=ACM&coll=ACM&CFID=15151515&CFTOKEN=6184618
08:05:51 <SamB> hmm
08:05:59 <SamB> @google site:haskell.org ghc documentation "functional dependencies"
08:06:00 <lambdabot> http://www.haskell.org/pipermail/cvs-ghc/2006-February/028379.html
08:07:46 <bolrod> http://www.cse.ogi.edu/~mpj/pubs/fundeps.html
08:08:15 <SamB> hmm, it is indeed possible that I have read a paper on it!
08:08:39 * SamB wishes he had some program to keep track of the papers he has read, and how much he liked them, and what they were about
08:08:49 <bolrod> what about a database?
08:08:53 <bolrod> ^.0
08:08:57 <bolrod> or just 'good memory'
08:15:32 <Stinger_> eek thats a lot of warnings :/
08:22:12 <bolrod> ;o
08:25:07 <bolrod> dons: you here?
08:25:27 <Muad_Dibber> SamB, wasn't it shapr who was talking about some system to save margin scribblings online?
08:25:54 <bolrod> a blog?
08:26:00 <bolrod> :)
08:26:11 <Muad_Dibber> nah, more specialices
08:26:21 <Muad_Dibber> also SamB, I'd like to point you to http://www.citeulike.org/
08:26:30 <ndm> yes, shapr was discussing Fermats Last Margin
08:26:34 <ndm> not sure how far he got with it thought
08:30:21 <SamB> Muad_Dibber: I meant some kind of handy agent that would be able to actually notice when I was reading papers, or something...
08:30:45 <SamB> or at least a PS/PDF viewer that would help with that kind of thing
08:30:52 <bolrod> like a more advanced keylogger type of thing
08:30:56 <bolrod> but then for papers 
08:31:00 <bolrod> :P
08:31:20 <bolrod> I feel weird
08:31:30 <bolrod> maybe because I barely slept last night :)
08:32:14 <Stinger_> I see your barely slept, and raise you an alnighter
08:32:32 <Stinger_> (though I have had a 2 hr nap since :P)
08:33:06 <bolrod> I have slept... don't know for how long
08:33:07 <bolrod> maybe 3 hours
08:33:15 <bolrod> already got light at 4:30 AM
08:33:23 <bolrod> and birds started to make alot of noise ;)
08:33:33 <Stinger_> heh yeah thats the worst 
08:33:48 <Stinger_> makes you wish you had a shotgun handy
08:33:55 <bolrod> hmm. not that loud actually
08:34:05 <bolrod> screaming children make me feel like that
08:34:18 <bolrod> or children in general who make more sound then needed
08:34:49 <bolrod> or people who think it's funny to blow some gas horn 5 times per minute for 10 minutes straight
08:34:56 <bolrod> ;p
08:35:10 <Stinger_> hmm we dont get those here ;)
08:35:26 <bolrod> well.. world championship soccer is coming aye 
08:35:39 <bolrod> so you gotta have a gas horn to be cool
08:35:46 <bolrod> and you got to let everybody know you have one or something
08:35:47 <Stinger_> aaaaah
08:36:00 <Stinger_> yeah we're not a big football country
08:36:59 <bolrod> :)
08:37:06 <bolrod> netherlands here.. so.. like
08:37:09 <bolrod> yah
08:39:47 <bolrod> well... there we have one...
08:39:53 <bolrod> sniper is better
08:40:01 <bolrod> shotguns don't carry well on long distances
08:40:14 <Stinger_> H-bomb perhaps
08:40:16 <bolrod> no
08:40:29 <bolrod> ARGH..  
08:40:37 <bolrod> ok.. I'll record it
08:41:03 <bolrod> well.. whadayaknow.. its going away
08:43:01 <Stinger_> dont suppose gtk2hs is in hoogle>
08:43:10 <dcoutts_> not yet
08:47:04 <Revision17> is there any way to have the compiler create a type which is the "union" of two data types? like data Meat = Chicken | Beef data Fruits = Apple | Pear data Food = Meat `union` Fruits?
08:49:24 <vincenz> Either
08:51:24 <Revision17> hmm, either isn't quite what I want, but now that I think about it comments would do just as well (this is to categorize different types of instructions)
09:04:01 * SamB likes how darcs lets you record work that was actually done mixed together in seperate pieces
09:27:21 <davidhouse> hey all
09:27:38 <davidhouse> anyone read Paterson and Hinze's paper on 2-3 finger trees?
09:28:10 * davidhouse is wondering whether the Reduce class they describe is Data.Foldable
09:50:49 <sjanssen__> davidhouse: the classes are similar
09:54:02 * davidhouse goes barbequeing
09:56:25 * apfelmus apfelmus finally got rid of his evil clone apfelmus_
10:21:40 <metaperl> I'm trying to find a definition of impure versus pure functional languages. COuld someone help me out?
10:22:23 <lampe> metaperl, impure has side effects?
10:22:39 <metaperl> lampe: I dont now... but that sounds good
10:22:58 <norpan> pure languages has referential transparency
10:23:04 <norpan> is that good enough for you?
10:23:12 <Kasperle> which means no side effects, right?
10:23:27 <metaperl> norpan: yes, what you are saying is that you can predict the output of a function by looking at it's inputs
10:23:39 <norpan> yes
10:23:47 <norpan> that a function is a mathematical function
10:24:12 <metaperl> norpan: but how is that possible when  a function accepts I/O?
10:24:28 <Kasperle> metaperl: every time you run a program, it will give you the same result. that means for example that you can't have user input
10:24:31 <norpan> because the function returns an IO action
10:24:34 <metaperl> let me formualate that better
10:24:47 <norpan> the IO action is always the same
10:24:57 <metaperl> Haskell is the only popular pure functional langauge right? Ocaml and SML are not pure
10:24:58 <norpan> however, running the IO action can produce different results
10:25:20 <Kasperle> so you have I/O but you kind of ignore its result ;)
10:25:54 <norpan> you can view it as giving the current state of the world as input to the function
10:25:54 <vincenz> metaperl: haskell is like uncut ocaml
10:26:28 <norpan> given the same state of the world, you will get the same result
10:26:48 <metaperl> I found Ocaml easier to grok. But I'm concerned about the imperative and OO aspects of it
10:26:53 <norpan> of course, the world is never in the same state :)
10:29:42 <SamB> uncut ocaml?
10:29:56 <vincenz> SamB: pure
10:29:58 <vincenz> like cocaine
10:30:01 <SamB> oh
10:30:06 <vincenz> metaperl: ocaml IS easier to grok
10:30:07 <SamB> only not so bad for you, we hope
10:30:09 <vincenz> metaperl: ocaml is terribly easy
10:30:17 <vincenz> metaperl: in fact I'm currently writing a compiler that can handle a lot of ocaml
10:30:23 <norpan> ocaml is strict
10:30:34 <vincenz> that's not the source of it's simplicity
10:30:46 <vincenz> it's the lack of decent higher order types
10:30:58 <SamB> hahaha
10:31:18 <AliStar> Hi, I have a problem in doing a simple exercice from tutorial, can I post it here to have help?
10:31:31 <metaperl> AliStar: rafb.net/paste
10:31:36 <metaperl> is one paste site
10:31:42 <metaperl> paste.lisp.org/new/haskell
10:31:43 <metaperl> is another
10:33:25 <AliStar> it loads into hugs without error, but when I try it it shows error:
10:33:26 <AliStar> http://rafb.net/paste/results/d9GLNU33.html
10:33:34 <Stinger_> data SM a = SM (S -> (a,S)) -- what is this line doing, (I know what data generally does, but not this extra -> syntax)
10:33:52 <AliStar> I'm trying tripleSnd Triple 5 5 5
10:33:57 <norpan> Stinger_: the contents of the data type is a function
10:34:22 <metaperl> AliStar: that looks good to me. I will run it locally and see what errors I get... hold on
10:34:31 <norpan> Stinger_: remember, functions are so-called first class objects and you can put them in data structures and so on
10:34:35 <AliStar> May be it's just winhugs?
10:34:59 <norpan> AliStar: you need parenthesis
10:35:05 <AliStar> where?
10:35:14 <norpan> tripleSnd (Triple 5 5 5)
10:35:35 <AliStar> thanks !!! :)
10:35:42 <Stinger_> oh, that easy huh.. hmm why didnt I think of that
10:35:46 <metaperl> ah, that was my guess, but I wanted to run it first :)
10:35:49 <Stinger_> thanks
10:35:51 <metaperl> damn, norpan beat me :)
10:35:58 <AliStar> It's not farst time when I missed them :)
10:36:30 <AliStar> I'm still not accustomed in reading haskell error messages
10:36:44 <metaperl> AliStar: stay strong...
10:36:52 <AliStar> thanks :)
10:51:22 <Stinger_> ok 1 last q before I go to bed
10:51:49 <Stinger_> data SM a = SM (S -> (a,S)) -- is there any particular reason that S is in caps here?
10:52:29 <mauke> yes, all types start with an uppercase letter
10:52:42 <Stinger_> so that would have to be a predefined type?
10:52:47 <sjanssen__> Stinger_: yes
10:57:29 <Stinger_> aaah this stuff makes my brain hurt, I'll look again in the morning/afternoon/whenever the hell I get up
10:58:07 <Stinger_> cya all
10:58:41 <mauke> @type (. (++)) . (.)
10:58:42 <lambdabot> forall a c. ([a] -> c) -> [a] -> [a] -> c
11:02:39 <int-e> davidhouse: the finger tree implementation by Ross Paterson at http://www.soi.city.ac.uk/~ross/software/Data/FingerTree.hs actually uses Data.Foldable.
11:16:39 <davidhouse> int-e, oh, cool
11:20:11 * SamB has a sneaking suspicion that maybe he should have read the section called "Monadic Parsers" *before* getting knee-deep in explicitly monadic productions...
11:24:26 <sjanssen__> davidhouse: what do you think about the Finger Tree paper?
11:24:47 <sjanssen__> I really enjoy the measurement + monoid approach
11:25:02 <davidhouse> sjanssen__, i'm not that far in to it but i normally enjoy this type of paper
11:26:20 <sjanssen__> I see.  The design is really elegant, you can get a map, a priority queue, and an indexable sequence out of this one data structure
11:37:23 <Beelsebob> moin
11:56:11 <metaperl> what is the difference between import qualified Data.Map as Map and import Data.Map as Map
11:57:04 <int-e> metaperl: the second also imports the names unqualified
11:57:07 <SamB> well, the latter will mean that you can't use many of the Prelude list functions
11:57:22 <SamB> because you will have imported something else with the same name
11:58:11 <davidhouse> metaperl: qualified means you _have_ to use the qualified name (or the as-name) whenever you use a function from that module
11:58:22 <davidhouse> e.g. you'd have to do Map.unionsWith, not just unionsWith
11:58:44 <SamB> but at least you could still use map ;-)
11:59:08 <davidhouse> right, because map is a Prelude and Data.Map function
11:59:09 <metaperl> davidhouse: oh I see... this is the program  I'm referring to. Cale wrote it for me: http://haskell.metaperl.com/locale/Locale.hs
11:59:16 <metaperl> oh I see
11:59:55 <metaperl> the second import Data.Map (Map) also confuses me
12:00:08 <int-e> that's because using Map.Map as a type is awkward
12:02:28 <int-e> (the import imports just the Map type constructor unqualified (and also as Data.Map.Map))
12:04:27 <int-e> So after those two lines you can refer to the Map type as Map, Map.Map and Data.Map.Map while you can refer to all other symbols from Data.Map by Map.<symbol> only.
12:04:51 <metaperl> yes, I see. thanks int-e
12:05:35 <int-e> import is funny. You can also import two separate modules under the same qualified name. import qualified Graphics.UI.Gtk.Cairo as Cairo; import qualified Graphics.Rendering.Cairo as Cairo is perfectly ok.
12:07:29 <metaperl> I'm writing a little program to simulate those phone answering services where they say spell out the name using your phone keypad
12:07:45 <metaperl> Here is my type for a single map between the key and the list of letters it has: type Keymap = Map Int [Char]
12:07:50 <metaperl> is that right?
12:08:26 <int-e> sure.
12:17:59 <metaperl> I'm getting a parse error on my data declaration: http://haskell.metaperl.com/keymap/KeyMap.hs   -- help appreciated
12:18:35 <mauke> can you change the content-type to text/plain?
12:18:40 <davidhouse> metaperl: that's not a data declaration
12:18:48 <davidhouse> metaperl: do you want a type synonym?
12:19:00 <davidhouse> data declarations have to have constructors
12:19:12 <metaperl> mauke: the response to that page depends on how the browser is setup
12:19:20 <metaperl> davidhouse: oh I think I get it
12:20:03 <mauke> hmm, how do I tell firefox to display it in a tab?
12:20:08 <metaperl> do I need parentheses around each Map call?
12:20:28 <davidhouse> metaperl: i don't think you can create a map like that
12:20:45 <metaperl> davidhouse: oh, you see what I'm trying to do right? how would I do it?
12:21:02 <davidhouse> the easiest way to create a map is to use a list of pairs, then use Map.fromList
12:21:11 <metaperl> oh
12:21:23 <davidhouse> e.g. in your case you'd create a list of (Int, String) pairs
12:21:35 <kosmikus> metaperl: looks like you should just swapped "type" and "data"
12:22:03 <kosmikus> s/swapped/swap/
12:22:49 <kosmikus> but if you actually want to use the standard Map type, as your "import" statement indicates, you should probably do what davidhouse suggests
12:25:49 * int-e wonders if there's a firefox plugin that adds a 'view as text' to the download/plugin dialog.
12:26:26 <monochrom> would be nice. generally "view as <choose here>"
12:26:39 <metaperl> wow, I could've specified the list of chars much more compact (1, "abc") instead of (1, ['a', 'b', 'c'])
12:26:42 <davidhouse> an "it's text/plain, honest!" option
12:27:03 <int-e> metaperl: well, the server sends it as text/x-haskell
12:27:10 <metaperl> oh...
12:27:12 <metaperl> hmm
12:27:38 <monochrom> I am actually tired of authors (some incompetent) dictating how our web browsers should behave.  For example too many links bear the attribute "open in new window" I think there is absolutely no reason to obey that.
12:27:40 * int-e hasn't managed to convince firefox to display anything text/plain directly :/
12:28:08 <int-e> *anything but*
12:28:40 <int-e> > M.fromList [(0,""),(1,""),(2,"abc"),(3,"def"),(4,"ghi"),(5,"jkl"),(6,"mno"),(7,"pqrs"),(8,"tuv"),(9,"wxyz")]
12:28:41 <lambdabot>  {0:="",1:="",2:="abc",3:="def",4:="ghi",5:="jkl",6:="mno",7:="pqrs",8:="tuv",...
12:29:09 <metaperl> how do I convert a number to a string? I want to go from 740 to "740" ... I thought read would do it
12:29:17 <int-e> show
12:29:17 <davidhouse> show
12:29:21 <davidhouse> snap!
12:29:50 <monochrom> The W3C is full of authors whose only interest is of course to control users.
12:30:23 <Kasperle> monochrom: ?
12:33:19 <davidhouse> > let tok n = unfoldr (\s -> if null s then Nothing else Just (splitAt n s)) in M.fromList $ [(0, ""), (1, "")] ++ zip [2..] (tok 3 ['a'..'z'])
12:33:20 <lambdabot>  {0:="",1:="",2:="abc",3:="def",4:="ghi",5:="jkl",6:="mno",7:="pqr",8:="stu",9...
12:33:41 <metaperl> how would you lookup 4 in this map: M.fromList [(0,""),(1,""),(2,"abc"),(3,"def"),(4,"ghi"),(5,"jkl"),(6,"mno"),(7,"pqrs"),(8,"tuv"),(9,"wxyz")]
12:33:45 <davidhouse> ah, doesn't quite work. "pqrs". never mind :)
12:33:56 <norpan> hola
12:34:04 <metaperl> norpan: greetings
12:34:10 <int-e> @type data.Map.lookup
12:34:11 <lambdabot> parse error on input `data'
12:34:12 <davidhouse> metaperl: ! 4
12:34:13 <int-e> @type Data.Map.lookup
12:34:15 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
12:34:20 <metaperl> yes I tried using that on my own
12:34:25 <davidhouse> @type Data.Map.(!)
12:34:26 <lambdabot> Couldn't find qualified module.
12:34:26 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
12:34:29 <metaperl> but I couldnt get it to work
12:34:32 <davidhouse> @type (Data.Map.!)
12:34:33 <lambdabot> forall a k. (Ord k) => Data.Map.Map k a -> k -> a
12:35:17 <metaperl> (Data.Map.!) 4 myCell
12:35:19 <metaperl> fails
12:35:22 <int-e> metaperl: lambdabot imports Data.Map as M --> you probably want Map. instead of M.
12:35:24 <monochrom> How about (M.!)
12:35:24 <metaperl> oh
12:35:31 <davidhouse> metaperl: wrong order
12:35:48 <metaperl> > M.fromList [(0,""),(1,""),(2,"abc"),(3,"def"),(4,"ghi"),(5,"jkl"),(6,"mno"),(7,"pqrs"),(8,"tuv"),(9,"wxyz")]
12:35:49 <lambdabot>  {0:="",1:="",2:="abc",3:="def",4:="ghi",5:="jkl",6:="mno",7:="pqrs",8:="tuv",...
12:35:51 <davidhouse> > M.fromList [(1, "hello")] ! 1
12:35:51 <lambdabot>  Couldn't match `Array i e' against `Data.Map.Map k a'
12:36:05 <metaperl> @type M.(!)
12:36:06 <lambdabot> Not in scope: data constructor `M'
12:36:07 <monochrom> Useful to adding "import Data.Map((!))"
12:36:09 <davidhouse> > M.fromList [(1, "hello")] M.! 1
12:36:10 <lambdabot>  "hello"
12:36:11 <monochrom> s/adding/add/
12:37:08 <monochrom> So, you "import qualified Data.Map as M" to avoid wholesale nameclashes.  Then you additionally "import Data.Map( the few infix operators you use )" to avoid having to say the awkward M.!
12:37:32 <metaperl> *KeyMap> Map.(!) 4 myCell
12:37:32 <metaperl> <interactive>:1:0: Not in scope: data constructor `Map'
12:37:45 <monochrom> > 1 Prelude.+ 1
12:37:46 <lambdabot>  2
12:37:50 <norpan> (Map.!)
12:37:52 <monochrom> Oh man this is sick! :)
12:38:03 <monochrom> So, (your map here) M.! 4
12:38:05 <metaperl> import Data.Map(!)
12:38:09 <metaperl> is that right?
12:38:30 <monochrom> Need more parentheses.  import Data.Map( (!) )   reason is obvious.
12:38:32 <davidhouse> aren't you already doing 'import qualified Data.Map as Map'?
12:38:46 <monochrom> I think he's doing "as M"
12:38:48 * int-e would just use lookup *shrugs*
12:38:54 <davidhouse> as M, fine.
12:38:57 <int-e> (I'd want ! for Arrays)
12:38:59 <davidhouse> then just do M.!
12:39:05 <xerox> ?type Data.Map.lookup
12:39:07 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
12:39:09 <davidhouse> int-e, qualified imports, though
12:39:31 <davidhouse> oi, xerox! i wanted to ask you how cabal-get is but i keep forgetting
12:39:48 <metaperl> bingo
12:39:49 <metaperl> *KeyMap> :t (Data.Map.!)
12:39:49 <metaperl> (Data.Map.!) :: (Ord k) => Map k a -> k -> a
12:39:52 <int-e> davidhouse: yes, of course. but qualified names are much less awkward for alphanumeric ids, at least to my eyes.
12:40:06 <davidhouse> hmm
12:40:07 <int-e> (!) == flip lookup
12:40:13 <monochrom> lookup is more tedious to use.
12:40:16 <davidhouse> > M.fromList [(1, "hello")] M.! 1 -- not too bad
12:40:17 <lambdabot>  "hello"
12:40:24 <int-e> > M.lookup 3 $ M.fromList [(2,4),(3,5)]
12:40:25 <lambdabot>  add an instance declaration for (Show (m a))
12:40:44 <davidhouse> it's monadic, int-e
12:40:47 <mauke> hmm, why do we have $ if we can just use `id`?
12:40:49 <int-e> no?
12:40:53 <xerox> > fromJust . M.lookup 1 . M.fromList [(1,'a'),(2,'b')]
12:40:54 <lambdabot>  Couldn't match `Data.Map.Map k a' against `t -> t1'
12:40:57 <norpan> mauke: $ is not id
12:40:59 <xerox> Wops.
12:41:00 <monochrom> @type ( (Data.Map.!), Data.Map.lookup )
12:41:01 <lambdabot> forall k a k1 a1 (m :: * -> *). (Ord k, Ord k1, Monad m) => (Data.Map.Map k a -> k -> a, k1 -> Data.Map.Map k1 a1 -> m a1)
12:41:04 <xerox> > fromJust . M.lookup 1 . M.fromList $ [(1,'a'),(2,'b')]
12:41:05 <lambdabot>  'a'
12:41:08 <monochrom> They are obviously different.
12:41:11 <int-e> why would it be monadic ...
12:41:19 <davidhouse> failure
12:41:22 <xerox> > M.lookup 1 . M.fromList $ [(1,'a'),(2,'b')] :: String
12:41:23 <monochrom> In case the lookup fails.
12:41:23 <norpan> mauke: f $ x = f x
12:41:23 <lambdabot>  "a"
12:41:23 <mauke> norpan: how isn't it?
12:41:36 <xerox> > M.lookup 1 . M.fromList $ [(1,'a'),(2,'b'),(1,'c')] :: String
12:41:36 <mauke> norpan: f `id` x = id f x = f x
12:41:36 <int-e> ok, why isn't it in MonadPlus then?
12:41:37 <lambdabot>  "c"
12:41:38 <davidhouse> > M.lookup 1 . M.fromList $ [(1,'a'),(2,'b')] :: Maybe Int
12:41:39 <lambdabot>  Couldn't match `Int' against `Char'
12:41:44 <xerox> Right, it is not MonadPlus.
12:41:44 <davidhouse> > M.lookup 1 . M.fromList $ [(1,'a'),(2,'b')] :: Maybe Char
12:41:45 <lambdabot>  Just 'a'
12:41:49 <davidhouse> > M.lookup 1 . M.fromList $ [(1,'a'),(2,'b')] :: [Char]
12:41:50 <lambdabot>  "a"
12:42:02 <davidhouse> > M.lookup 1 . M.fromList $ [(1,'a'),(2,'b')] :: Either String String
12:42:02 <lambdabot>  Couldn't match `String' against `Char'
12:42:07 <davidhouse> > M.lookup 1 . M.fromList $ [(1,'a'),(2,'b')] :: Either String Char
12:42:08 <lambdabot>  add an instance declaration for (Monad (Either String))
12:42:08 <norpan> @type ($)
12:42:09 <lambdabot> forall b a. (a -> b) -> a -> b
12:42:12 <norpan> @type id
12:42:12 <davidhouse> eurgh, never mind
12:42:12 <xerox> Relax!
12:42:13 <lambdabot> forall a. a -> a
12:42:17 <norpan> not the same
12:42:17 <reppie> stop. hammer time.
12:42:20 <monochrom> If you anticipate "not found" you lookup.  If you swear "I'm sure it's there please don't make me write a monad to catch the not-found case" you use !
12:42:29 <mauke> norpan: $ is id restricted to function types
12:42:33 * int-e is beginning to really understand Cale's gripe about having fail in Monad.
12:42:52 <monochrom> Yeah, if you ask me, lookup should use a MonadPlus.
12:42:54 * xerox nods
12:42:57 <norpan> mauke: anyway, the reason to have $ is that it lets you skip parenthesis
12:43:05 <mauke> you can do the same thing with `id`
12:43:13 <monochrom> But ! is very important too and it's done right.
12:43:17 <norpan> would you rather write `id` or $?
12:43:25 <mauke> `id`
12:43:39 <norpan> then you are welcome to use it :)
12:43:50 <norpan> but us lazy guys prefer to write $
12:43:57 <mauke> I also like flip id :-)
12:45:02 <monochrom> Normally you use the Maybe or [] monad for lookup anyway.
12:45:13 <xerox> davidhouse - Brainstorming with Isaac atm.
12:46:00 <davidhouse> xerox, cool.
12:46:08 <davidhouse> xerox, you doing a devblog or anything?
12:46:42 <xerox> davidhouse - Nope. But I probably could.
12:46:51 <davidhouse> you should, i'd read it :)
12:46:55 <davidhouse> use a wordpress.com one
12:46:59 <lisppaste2> metaperl pasted "So far so good!" at http://paste.lisp.org/display/20767
12:47:21 <xerox> I'd use LambdaFeed! (:
12:47:44 <xerox> @where lambdafeed
12:47:45 <lambdabot> I know nothing about lambdafeed.
12:47:51 <xerox> @where+ lambdafeed http://www.cse.unsw.edu.au/~chak/haskell/lambdaFeed/
12:47:51 <lambdabot> Done.
12:49:13 <lispy> i'm having a hard time getting H/Direct to do what i want, and there seems to be little or no documentation
12:49:21 <lispy> makes me sad
12:49:35 <lispy> wouldn't happen to be an expert in the house would there?
12:52:20 <davidhouse> anyone read oleg's essay?
12:52:32 <davidhouse> it's long and looks interesting and want to know if it's worth reading
13:02:40 <sethk> how do I tell gtk2hs that I have gnome, and thus glade and gconf and gtksourceview, installed?
13:03:33 <davidhouse> --with-glade and --with-gtksourceview, iirc
13:03:40 <davidhouse> with ./configure
13:05:02 <davidhouse> try the README
13:05:02 <sethk> davidhouse, thanks.  actually I hadn't installed all of glade yet, so I'm doing that now.
13:05:19 <sethk> davidhouse, then I'll redo configure, make, etc. 
13:11:08 * _SamB_ is glad his computers have good capaciters
13:12:18 <_SamB_> so how come Happy won't say *what* the reduce/reduce conflicts are?
13:14:54 <Lemmih> _SamB_: It will if you give it some flag.
13:15:11 <Lemmih> _SamB_: -iinfofile.
13:15:38 <_SamB_> oh, right
13:18:53 <_SamB_> okay, I seem to have a reduce/reduce conflict for identifier between two rules with empty right-hand-sides
13:19:49 <_SamB_> I'm not positive, though...
13:20:18 <_SamB_> it seems that it isn't actually going the wrong way, though, which is nice
13:29:51 <davidhouse> sjanssen__: you around?
13:30:08 <sjanssen__> davidhouse: yep
13:30:24 * davidhouse is struggling to understand the slightly weird FingerTree datatype
13:30:43 <davidhouse> if you've got the paper to hand, i thought i might bother you with a couple of questions :)
13:31:30 <sjanssen__> sure, shoot
13:31:40 <davidhouse> okay, we're on page four
13:32:34 <davidhouse> am i right in saying none of the nodes in the tree pictured there would be an Empty?
13:35:23 <sjanssen__> honestly, I can't really remember the structural constraints of the finger tre
13:35:36 <monochrom> funny name :)
13:35:49 <davidhouse> hmn, okay, never mind
13:37:29 <sjanssen__> I'm sorry, I missd a lttr
13:39:46 <davidhouse> ah, i think i get it.
13:48:46 <lisppaste2> davidhouse pasted "the finger tree?" at http://paste.lisp.org/display/20770
13:49:22 <davidhouse> sjanssen__, don't suppose you'd remember enough to know whether that paste was the correct representation of the tree in the paper?
13:50:01 <dcoutts> sethk, it'll detect them automatically if yoy've got the dev bits installed
13:50:28 <dcoutts> sethk, or yes, --enable-blah
13:50:47 <sethk> dcoutts, I thought it would.  I installed a piece of glade that might have been missing.  I'm checking whether it picked up on that rerunning configure
13:50:54 <dcoutts> and it'll look for the bits and then complain if they're missing
13:51:22 <sethk> dcoutts, it didn't find it, still.  I'll try enable-glade
13:51:44 <sethk> enable-libglade, I think it is, actually
13:51:44 <dcoutts> sethk, try installing libglade-dev or something, same for all the other packages
13:51:53 <dcoutts> ./configure --help will tell you
13:52:09 <sethk> dcoutts, I already did that.  but it still didn't pick up on it.  I'm trying enable-libglade now
13:52:12 <monochrom> Yeah I think you need libglade-dev and generally *-dev
13:52:21 <dcoutts> it needs the header files and pkc-config files for each pkg
13:52:34 <sethk> looks like it won't work with the debian or ubuntu packages
13:53:11 <monochrom> If the stuff is installed under /usr/lib and /usr/include, it should be detected automatically.
13:53:22 <sethk> monochrom, yes, it should.  unfortunately it isn't
13:53:49 <sethk> maybe ubuntu is using a different package name
13:53:53 <sethk> I'll hunt for it
13:53:53 <monochrom> Very odd.  I didn't run into this kind of problem.  Have you checked sunspot activities today?
13:54:00 <monochrom> I'm using ubuntu.
13:54:35 <sethk> monochrom, let me make sure I didn't clobber glade 2 w3ith glade 1, or something dumb like that
13:54:44 <davidhouse> i think the planets have a particularly strange alignment today, monochrom.
13:55:34 <Dino_> I have a question about docs.
13:55:34 <monochrom> I deliberately omitted gtksourceview.  But I have glade and gconf.
13:55:59 <dcoutts> sethk, you'll be able to tell when you've got the required packages because pkg-config --modversion libglade-2.0
13:55:59 <dcoutts>  will tell you something sensible
13:56:11 <sethk> dcoutts, ok, I'll check it.
13:56:29 <dcoutts> sethk, but it's usually a package with the same name -dev or -devel
13:56:32 <Dino_> I looked around for some Haskell "API" docs to download. I did find that ZVON site. But the Haskell Hierarchical Libraries seems to be more extensive.
13:56:43 <monochrom> libglade2-dev it is called.
13:57:04 <sethk> dcoutts, monochrom, I'll reinstall libglade2-dev and see if that helps
13:57:30 <dcoutts> sethk, it should install a '.pc' file for pkg-config
13:57:39 <sethk> dcoutts, ok, I'll look for that.
13:57:40 <monochrom> You can omit libglade0-dev
13:57:54 <sethk> monochrom, ok
13:59:35 <sjanssen__> davidhouse: yeah, I think that's right
14:00:07 <monochrom> If I understand correctly, "libglade-dev" on ubuntu is a virtual package, but the only concrete correspondence is libglade0-dev, so you don't need that either.
14:00:09 <davidhouse> awesome, things are making senes
14:03:20 <monochrom> Dino_: yes, go for the hierarchical libraries.  docs downloadable from ghc site.
14:07:00 <Dino_> Ah, I'm finding it now. You know what it is, I kept seeing the HHL html docs viewable at some or other university or whatever, but never the .tar.gz until I looked for it on haskell.org/haskellwiki
14:07:24 <monochrom> hee hee
14:12:04 <Dino_> Thank you.
14:13:20 <lisppaste2> metaperl pasted "help needed --- bottom of code says what I need" at http://paste.lisp.org/display/20772
14:14:58 <metaperl> ignore the parse error.. there is not one
14:15:21 <metaperl> further down is where I really need help
14:15:26 <monochrom> > sequence ["ab", "cde", "fg"]
14:15:27 <lambdabot>  ["acf","acg","adf","adg","aef","aeg","bcf","bcg","bdf","bdg","bef","beg"]
14:15:40 <metaperl> monochrom:thanks
14:15:42 <monochrom> Is that what you want?
14:15:43 <metaperl> @type sequence
14:15:44 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
14:16:10 <metaperl> yes, I think so
14:16:27 <metaperl> is the implementation of that online?
14:16:47 <davidhouse> yeah, it's a standard function
14:16:49 <metaperl> I was expecting something with a list combination
14:17:17 <davidhouse> metaperl: this is how you'd go about writing such a function:
14:17:53 <sethk> ok, now configure is happy about libglade, but when I try to build something with glade (in demo/glade) it complains that it can't find Graphics.UI.Gtk.Glade.
14:17:55 <lisppaste2> monochrom annotated #20772 with "why sequence works" at http://paste.lisp.org/display/20772#1
14:18:08 <sethk> Is there a separate step to build that?
14:18:14 <sethk> let me make sure I redid make install
14:18:18 <davidhouse> firstly, we choose a char from the first string. then we choose one from the second, and then one from the third, and so on
14:18:26 <monochrom> sequence is a monad combinator, therefore a list combinator.
14:18:47 <metaperl> monochrom: thanks
14:18:47 <monochrom> (See also my recent paste for an illustration)
14:18:54 <metaperl> yes I saw the annotation
14:18:56 <sethk> working now
14:19:07 <davidhouse> yep, if you grok the list monad, then monochrom explained it well
14:19:21 <metaperl> yeah, but I would prefer an explanation based on List combinations
14:19:29 <monochrom> The list monad is trivial to grok.  Just translate to list comprehension. :)
14:19:51 <metaperl> basically that is what that is: all combinations of l1 and l2 and the all of those combinations into l3 into l4, etc, etc
14:20:02 <davidhouse> let's see
14:20:17 <davidhouse> we'll need to map over the first string, something like
14:20:20 <metaperl> yes, but the problem is you dont know the length of the input list of strings
14:20:29 <lisppaste2> monochrom annotated #20772 with "from do to comprehend" at http://paste.lisp.org/display/20772#2
14:20:54 <davidhouse> map (get all the different combinations from the rest of the strings) (first string)
14:20:59 <metaperl> monochrom: problem is, we dont know how many list elements ahead of time
14:21:12 <jamal> GNAA 4 LYFE
14:21:13 <jamal> GNAA 4 LYFE
14:21:14 <jamal> GNAA 4 LYFE
14:21:14 <jamal> GNAA 4 LYFE
14:21:16 <jamal> GNAA 4 LYFE
14:21:16 <metaperl> numberToCandidates 53892  -- will produce i1 i2 i3 i4 i5
14:21:18 <jamal> GNAA 4 LYFE
14:21:20 <monochrom> sequence figures out the length automagically and perform the necessary generalization.
14:21:20 <jamal> GNAA 4 LYFE
14:21:23 <jamal> GNAA 4 LYFE
14:21:26 <jamal> GNAA 4 LYFE
14:21:27 <davidhouse> Igloo, ping!
14:21:28 <jamal> GNAA 4 LYFE
14:21:31 <jamal> GNAA 4 LYFE
14:21:33 <jamal> GNAA 4 LYFE
14:21:36 <jamal> GNAA 4 LYFE
14:21:37 <metaperl> monochrom:yes, but how can I write something to do that?
14:21:38 <jamal> GNAA 4 LYFE
14:21:41 <jamal> GNAA 4 LYFE
14:21:43 <jamal> GNAA 4 LYFE
14:21:46 <jamal> GNAA 4 LYFE
14:21:49 <jamal> GNAA 4 LYFE
14:21:51 <jamal> GNAA 4 LYFE
14:21:53 <jamal> GNAA 4 LYFE
14:21:56 <jamal> GNAA 4 LYFE
14:21:58 <jamal> GNAA 4 LYFE
14:22:01 <jamal> GNAA 4 LYFE
14:22:03 <jamal> GNAA 4 LYFE
14:22:05 <monochrom> sequence is written recursively.  Recursion generalizes :)
14:22:06 <jamal> GNAA 4 LYFE
14:22:08 <jamal> GNAA 4 LYFE
14:22:11 <jamal> GNAA 4 LYFE
14:22:13 <jamal> GNAA 4 LYFE
14:22:16 <jamal> GNAA 4 LYFE
14:22:16 <davidhouse> Cale: can you get op privs?
14:22:16 <metaperl> monochrom: meaning?
14:22:17 --- mode: ChanServ set +o SyntaxNinja
14:22:18 <jamal> GNAA 4 LYFE
14:22:21 <jamal> GNAA 4 LYFE
14:22:22 <davidhouse> never mind :)
14:22:23 <jamal> GNAA 4 LYFE
14:22:25 --- kick: jamal was kicked by SyntaxNinja (SyntaxNinja)
14:22:27 <SyntaxNinja> how do I ban?
14:22:54 --- mode: Igloo set +b *!*@tor/session/external/x-edafcb1e62df3dfe
14:22:54 <davidhouse> -b hostmask
14:22:59 <SyntaxNinja> thanks Igloo
14:23:09 <davidhouse> thanks SyntaxNinja.
14:23:18 <domi> kikoo the bots
14:23:19 <davidhouse> metaperl: sequence:
14:23:19 <SyntaxNinja> how long was that happening?
14:23:20 <Igloo> Does that pile of hex mean anything useful, like a hash of the IP address?
14:23:43 <davidhouse> sequence [] = []; sequence (x:xs) = do x' <- x; xs' <- sequence xs; return (x' : xs')
14:23:46 <sethk> dcoutts, sourceview is just for code syntax highlighting, correct?  So if I'm not doing that, I don't need sourceview?
14:23:49 <domi> is agmk< there ?
14:23:56 <Igloo> SyntaxNinja: Looks like it started just as you joined. Very suspicious  :-)
14:24:05 <metaperl> lol
14:24:15 <metaperl> I always knew we couldnt trust him
14:24:21 <SyntaxNinja> I wanted to show how important I am to the #haskell community.  If I hadn't shown up, it might have taken you 10 more seconds to kick him.
14:25:26 <dcoutts> sethk, right
14:25:37 <Igloo> BTW, for future reference it's /mode #haskell +b *!*@what.ever
14:25:41 <domi> are the norloges clickable ?
14:25:56 <sethk> dcoutts, and if I'm not doing gnome configuration, I don't need gconf either?
14:27:06 <metaperl> I'd like some comments on my software engineering Haskell blog post please: http://sequence.complete.org/node/186
14:27:20 <dcoutts> sethk, yep
14:28:06 <sethk> dcoutts, thanks.
14:28:18 <ihope> So if I connect to myself, what will my HostName be?
14:31:05 <lisppaste2> monochrom annotated #20772 with "the recursion" at http://paste.lisp.org/display/20772#3
14:32:02 <dcoutts> metaperl, hmm, so you think the IO / pure seperation is rather like the seperation of the midle tier out from the cleint & data teir ?
14:32:17 <davidhouse> ihope, 127.0.0.1?
14:32:28 <ihope> Hmm...
14:32:29 <davidhouse> what context do you mean?
14:32:32 <metaperl> dcoutts: I'm thinking it naturally flows from that.... Haskell has always been tiered
14:32:50 <ihope> davidhouse: what do you mean by "context"?
14:33:00 <dcoutts> metaperl, it's an interesting idea, and possibly a good way of pusing the Haskell approach :-)
14:33:08 <dcoutts> pusing/pushing
14:33:14 <davidhouse> ihope, if you connect what to yourself? what's this HostName you're talking about?
14:33:21 <metaperl> Haskell enforces separation of concerns . and multi-tiered web applications are one instance of where other languages had to consciously do what Haskell forces you to do :)
14:33:22 <monochrom> Eh!  metaperl's domain is "sequence" and doesn't know how to define or use "sequence"?!  XD
14:33:26 <davidhouse> metaperl: the problem is that most of the layers aren't pure
14:33:41 <metaperl> monochrom: heh.. that's CosmicRay's domain
14:33:47 <monochrom> darn
14:33:49 <domi> haskell sont jolies les filles de mon pays
14:33:53 <metaperl> davidhouse: pure? in what Haskell or say Java?
14:34:03 <davidhouse> e.g. in a standard multitiered app each layer will need to do IO
14:34:14 <ihope> davidhouse: use listenOn, accept, and all that stuff, then connect to myself however, after which accept would produce a HostName... I think.
14:34:51 <davidhouse> ihope, that sounds like a lib i'm not familiar with :)
14:35:15 <domi> Gniarf< _o/
14:35:15 <ihope> The "Network" one?
14:35:21 * Gniarf fracasse le crane de domi avec une pelle
14:35:29 * CosmicRay sees himself named but doesn't understand the context ;-)
14:35:32 <davidhouse> ihope, try localhost
14:36:03 <monochrom> Just use a lot of tiers of monad transformers.  Even their names ReaderT etc. are pronounced "Reader Tier" etc.
14:36:04 <domi> 23:35 [:artishow]
14:37:27 <davidhouse> monochrom: they are? i always say Reader-Tee
14:37:30 <sethk> dcoutts, I can build everything in demo now (except gconf and sourceview).  I'm trying to build Clock.hs from Gtk2Hs introductory presentation.  It's not finding things (e.g. widgetGetSize).  Am I doing something simple incorrectly?  I haven't read the document yet, so if it isn't trivial, then I'll go read.
14:37:42 <davidhouse> T for transformer, as in monad transformer
14:37:48 <monochrom> Now it's a good time to change :)
14:38:02 <davidhouse> why Reader-Tier?
14:38:12 <monochrom> More commercial :)
14:38:42 <sethk> dcoutts, I'm not getting any complaints on the import lines
14:38:53 <Dino_> I was just reading that May post about Perl: the super-convenient pseudo-functional lang..
14:39:03 <dcoutts> sethk, what version of gtk2hs are you using?
14:39:18 <dcoutts> sethk, a released version or a version from darcs?
14:39:32 <Dino_> A couple of weeks ago I got to that example in Yet Another Haskell Tut where the author has a C++ impl of quicksort and then one in Haskell..
14:39:40 <sethk> dcoutts, I followed the gtk2hs link on haskell.org/ghc then went to downloads
14:40:03 <sethk> dcoutts, and installed gtk2hs-0.9.10 from the tarball
14:40:05 <Dino_> And I thought, oh I bet I can write that in not much more code in Perl.
14:40:15 <monochrom> Probably widgetGetSize is deprecated.
14:40:17 <dcoutts> sethk, then the Clock demo was not included
14:40:36 <sethk> dcoutts, yes, I know, I downloaded it from the link.
14:40:42 <dcoutts> sethk, the Clock demo comes with and requires the development version
14:40:46 <sethk> dcoutts, is there a newer gtk2hs that I should be using?
14:40:58 <sethk> dcoutts, I saw that note about the development version but I didn't know what it meant
14:41:08 <sethk> dcoutts, I didn't see a development version in the download list
14:41:12 <monochrom> When you built, what did you choose concerning deprecated things?
14:41:14 <sethk> dcoutts, so where do I get the latest?
14:41:32 <sethk> monochrom, nothing, so whatever the default is
14:41:37 <dcoutts> sethk, no it's not released so there's no tarball, you can get it using darcs
14:41:46 <sethk> dcoutts, ok, how do I do that?
14:41:50 <dcoutts> sethk, see the development section of the gtk2hs webiste for details
14:42:31 <sethk> dcoutts, sorry, but I don't see such a section on the website
14:42:52 <sethk> dcoutts, oh, you mean in the list of tabs
14:42:55 <dcoutts> http://haskell.org/gtk2hs/ the bit that says development
14:43:00 <dcoutts> http://haskell.org/gtk2hs/development/
14:46:32 <monochrom> Dino_: quicksort in Perl is also nice, yes.
14:49:19 <sethk> dcoutts, ok, I did the darcs install.  Now where does the clock demo live?
14:50:11 <dcoutts> sethk, gtk2hs/demos/cairo/Clock.hs
14:50:17 <sethk> dcoutts, thanks
14:50:17 <Dino_> It made me think a couple of things that hadn't occurred to me. First, that Perl is far more powerful than people often give it credit for.
14:50:36 <Dino_> And that my Perl is probably going to get much cooler after learning some func programming.
14:50:36 <sethk> dcoutts, where is gtk2hs?
14:50:48 <davidhouse> @where gtk2hs
14:50:49 <lambdabot> http://haskell.org/gtk2hs/
14:51:05 <sethk> davidhouse, no, not on the web, on my machine
14:51:24 <davidhouse> it's not a binary, it's a set of libs
14:51:27 <dcoutts> sethk, if you didn't specify then it'll be /usr/local/lib/gtk2hs/
14:51:41 <davidhouse> so where gtk2hs won't work
14:51:51 <sethk> davidhouse, indeed.
14:51:59 <davidhouse> hehe sorry :)
14:52:02 <Dino_> I think I reach for objects way too often. I blame Java.
14:52:05 <yip> perl is the devil
14:52:28 <dcoutts> sethk, in general you can find out using ghc-pkg describe <pkgname>
14:52:39 <mauke> Dino_: it will be awesome, like http://mauke.ath.cx/stuff/perl/add.pl
14:52:51 <monochrom> Hehe, we don't like some of the syntactic choices made in Perl, and we don't like its loose type system.  But it does represent many good ideas.  I commend it for embracing first-class functions/closures (sub), for example.
14:52:51 <dcoutts> sethk, that'll tell you lots of stuffm including where the libs can be found
14:53:03 <agmk> yip, no, Python is
14:53:17 <Dino_> heh, that's crazy
14:53:35 <mauke> what? adding two numbers is crazy?!
14:53:49 <sethk> dcoutts, I do have /usr/local/lib/gtk2hs, but I don't have a Clock.hs anywhere underneath it
14:54:07 <dcoutts> sethk, the demos do not get installed, it's in the source tree
14:54:30 <sethk> dcoutts, now you've lost me completely.  I did the install as you suggested.  I don't have the source tree?
14:54:46 <sethk> dcoutts, what didn't I do?  How do I get the source tree?
14:54:49 <dcoutts> sethk, you just said you got the darcs version
14:55:03 <sethk> dcoutts, yes, and you said the darcs version is the only one with the Clock.hs demo
14:55:04 <Dino_> mono: And lists in Perl. Very easy to cons etc..
14:55:08 <davidhouse> sethk, it's in the dir where you ran ./configure and so on
14:55:36 <sethk> davidhouse, no, it isn't, because there is no such directory.  So I guess there are some steps missing here, like what to do after running the darcs command
14:56:03 <sethk> it says to cd gtk2hs, but where is that supposed to be?
14:56:09 <sethk> is it related to where I ran the darcs command?
14:56:39 <sethk> ah, ok, the darcs command is instead of downloading the tarball
14:56:39 <dcoutts> yes
14:56:43 <dcoutts> yes
14:56:58 <davidhouse> sethk, do you not have a dir called 'demo' in the darcs dir you pulled?
14:58:08 <sethk> davidhouse, I probably do, but I'm still figuring out what you have to do after using the darcs command
14:58:36 <sethk> ok, I see, you do the darcs command, and autoreconf, then pick up as if you downloaded the tarball
14:58:49 <sethk> hmm., this version won't build without happy.
14:58:50 <dcoutts> yep
14:58:54 <dcoutts> indeed
14:59:11 <sethk> ok, I know where I'm at, now.  I'll install happy
14:59:11 <dcoutts> and alex
14:59:21 <sethk> ok, and alex.  I was missing that autoreconf step
14:59:21 * ihope gets dizzy
14:59:29 * dcoutts goes to bed
14:59:39 <dcoutts> sethk, have fun! :-)
15:00:41 <ihope> I need a program which sends a given string to every program that connects to it.
15:01:08 <davidhouse> like, map?
15:01:24 <ihope> davidhouse: like what?
15:01:51 <davidhouse> > map ($ "hello") [ (++ " world"), map toUpper ]
15:01:51 <lambdabot>  ["hello world","HELLO"]
15:02:07 <davidhouse> sending a string to every program (function) in a list :)
15:02:16 <ihope> Heh.
15:02:17 <Excedrin> connect via tcp? like "while [ 1 ] ; do echo foo | nc -l -p 1234; done" (except with support for multiple connections)?
15:02:39 <ihope> Excedrin: sounds right.
15:02:53 <Cale> davidhouse: nope, I'm not an op here
15:03:01 <davidhouse> hmm
15:03:05 <davidhouse> for future reference, who is?
15:03:15 <davidhouse> SyntaxNinja, Igloo, anyone else?
15:03:19 <ihope> The program would be called "drain", and if a program ("faucet") connents to it, drain will send the string to faucet.
15:03:20 <Cale> shapr
15:03:23 <Excedrin> you can use djb's tcpserver, or a simple haskell/perl script
15:03:35 <ihope> davidhouse: /msg ChanServ access #haskell list?
15:03:49 <davidhouse> ihope, oh, nice.
15:04:01 <davidhouse> hmm... i don't know half of those people
15:04:05 <ihope> Heh.
15:05:01 <davidhouse> who are Heffalump, wli, dennisb, emu, Riastradh, Janni? i don't think i've ever spoken to any of those.
15:05:19 <ihope> That means Heffalump, kosmikus, shapr, wli, Pseudonym, Igloo, SyntaxPolice, musasabi, and dons are ops?
15:05:37 <mauke> I remember Heffalump and wli
15:06:35 <davidhouse> seems it's over a year since some of those have +o'd, though.
15:07:58 * ihope tries writing the other half of his faucet/drain pair first
15:08:00 <davidhouse> hmm... SyntaxNinja isn't in the list. odd.
15:08:16 <SyntaxNinja> I am too powerful for the list
15:08:23 <davidhouse> i see. :)
15:08:25 <metaperl> Riastradh is a scheme hacker
15:08:37 * ihope ponders
15:08:41 <metaperl> bloodandcoffee.net is his website I think. he hangs out on #scheme
15:09:04 <Igloo> davidhouse: He is
15:09:20 <ihope> So Mr. Ninja knows the channel password thingy?
15:09:25 <Igloo> Oh, as SyntaxPolice
15:09:51 <Excedrin> @paste
15:09:51 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:10:44 <monochrom> Does the content of that ever get cleared up to avoid unbounded growth?
15:11:35 <davidhouse> @where past
15:11:36 <lambdabot> I know nothing about past.
15:11:36 <davidhouse> @where paste
15:11:37 <lambdabot> http://paste.lisp.org/new/haskell
15:11:38 <davidhouse> use that instead
15:11:57 <davidhouse> @where+ past http://paste.list.org/new/haskell because davidhouse kept making typos
15:11:57 <lambdabot> Done.
15:12:10 <metaperl> people ignore you if you post at paste.lisp.org. Dont paste there
15:12:15 <metaperl> I recommend rafb.net/paste
15:12:36 <ihope> I always use pastebin.org or whatever it is because it's easy to remember the name :-P
15:12:49 <davidhouse> oops
15:12:53 <davidhouse> @where- past
15:12:53 <lambdabot> Maybe you meant: where where+
15:13:00 <ihope> pastebin... whatever.
15:13:07 <ihope> s/\.\.\./.com.../
15:13:08 <metaperl> if I have a list of strings which represent potential substrings of another list of names, how do I check the [Name] to see which substrings match it?
15:13:25 <davidhouse> @where+ past http://paste.lisp.org/new/haskell because davidhouse kept making typos
15:13:26 <lambdabot> Done.
15:13:29 <davidhouse> @where past
15:13:29 <lambdabot> http://paste.lisp.org/new/haskell because davidhouse kept making typos
15:13:31 <davidhouse> good
15:13:51 <davidhouse> metaperl: best way to check if one string is a substring of another is to use regexes, iirc
15:13:58 <davidhouse> unless there's a sublist function
15:14:00 <davidhouse> @hoogle sublist
15:14:01 <lambdabot> No matches found
15:14:07 <davidhouse> @hoogle [a] -> [a] -> Bool
15:14:07 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
15:14:08 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
15:14:22 <ihope> @hoogle [a] -> [[a]]
15:14:23 <lambdabot> List.inits :: [a] -> [[a]]
15:14:23 <lambdabot> List.tails :: [a] -> [[a]]
15:14:23 <lambdabot> List.group :: Eq a => [a] -> [[a]]
15:14:48 <Excedrin> ihope: http://rafb.net/paste/results/1zIEwL80.html trivial drain, no idea if it helps
15:15:41 <ihope> > let isSublistOf x y = x `elem` (inits y >>= tails) in "dog" `isSublistOf` "the lazy dog:
15:15:41 <lambdabot>  Improperly terminated string
15:15:43 <ihope> > let isSublistOf x y = x `elem` (inits y >>= tails) in "dog" `isSublistOf` "the lazy dog"
15:15:44 <lambdabot>  True
15:15:53 <ihope> > let isSublistOf x y = x `elem` (inits y >>= tails) in "dog" `isSublistOf` "the lazy dog's cousin"
15:15:54 <lambdabot>  True
15:16:00 <ihope> > let isSublistOf x y = x `elem` (inits y >>= tails) in "dog" `isSublistOf` "the lazy cat's cousin"
15:16:00 <davidhouse> that is _slow_.
15:16:01 <lambdabot>  False
15:16:24 <Cale> > let isSublistOf x y = any (isPrefixOf x) (tails y) in "dog" `isSublistOf` "the lazy dog's cousin"
15:16:25 <lambdabot>  True
15:16:36 <Cale> > let isSublistOf x y = any (isPrefixOf x) (tails y) in "dog" `isSublistOf` "the lazy cat's cousin"
15:16:37 <lambdabot>  False
15:16:49 <ihope> Excedrin: yep, that'll work. Thanks!
15:16:51 <Cale> this implementation is reasonable
15:17:03 <davidhouse> tails is... what... O(n^2)?
15:17:16 <Cale> O(n)
15:17:35 <davidhouse> > length (tails [1..20])
15:17:36 <lambdabot>  21
15:17:37 <Cale> actually, it's O(k) where k is the part of the list you care about
15:17:40 <davidhouse> oh, right.
15:19:25 <Cale> and isPrefixOf x y is O(n) where n is the index of the first difference between x and y, or the length of x otherwise.
15:19:44 <ihope> Then just take str from stdin and the port from the argument list, and it'll be exactly what I need.
15:20:06 * ihope feels guilty just letting others write these programs instead of doing it himself
15:21:13 <davidhouse> hey, #haskell is great for its algorithm-golf.
15:26:15 <metaperl> Now _THIS_ is a great webpage: http://www.haskell.org/hawiki/HaskellNewbie_2fLowerCase
15:26:22 <metaperl> Now _THIS_ is a great webpage: http://www.haskell.org/hawiki/HaskellNewbie
15:36:43 <SyntaxNinja> does anyone have a link to the damn ACM category codes handy?
15:36:56 <SyntaxNinja> for some reason it's not linked from the obvious place: http://www.acm.org/sigs/sigplan/authorInformation.htm
15:37:31 <monochrom> http://www.acm.org/class/1998/
15:39:04 <metaperl> can you have a where clause on a list comprehension ?
15:39:30 <davidhouse> > [ y | x <- [1..10], let y = x + 1 ]
15:39:30 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
15:39:33 <monochrom> No.
15:39:37 <SyntaxNinja> monochrom: thanjs
15:41:23 <sethk> after a darcs download, what's the configuration command used with Setup.lhs?
15:42:18 <SyntaxNinja> ghc --make -package Cabal -o setup && ./setup configure && ./setup build && sudo ./setup install
15:42:26 <SyntaxNinja> er
15:42:34 <SyntaxNinja>  ghc --make -package Cabal Setup.lhs -o setup && ./setup configure && ./setup build && sudo ./setup install
15:43:31 * bringert just put that stuff in a shell script
15:43:31 <davidhouse> or, 
15:43:33 <sethk> SyntaxNinja, how do I know the package name?  I'm installing happy, but happy is not a known package (nor is Happy)
15:43:48 <sethk> isn't there one with Setup.lhs where you don't need to know the package name?
15:43:58 <davidhouse> runhaskell ./Setup.lhs configure; runhaskell ./Setup.lhs build; sudo runhaskell ./Setup.lhs install
15:44:26 <SyntaxNinja> sethk: the package name above is just for compiling the setup script; it's _always_ Cabal.
15:44:27 <davidhouse> sethk, do as i just posted
15:44:49 <sethk> SyntaxNinja, ok, but I don't need to do that, do I?
15:44:57 <sethk> davidhouse,that's what I was remembering, thanks
15:45:21 * ihope suddenly decides the monomorphism, though extremely evil, can be useful
15:45:35 <ihope> Oh, never mind.
15:45:44 <davidhouse> woah! you had me scared there.
15:45:46 <SyntaxNinja> sethk: you can interpret it, as davidhouse suggested... if you have runhaskell; not everyon edoes, so my instructions are more general.
15:45:54 <sethk> SyntaxNinja, ok, thanks
15:46:14 <davidhouse> SyntaxNinja: i think both ghc and hugs provide runhaskell; not sure about nhc and friends, but that's the major subset
15:46:16 <monochrom> everyone has runghc :)
15:47:33 <sethk> can I ignore warnings on configure?  specifically, I get four; here is the first:  ./Setup.lhs:7:28: Module `Distribution.Setup' does not export `BuildFlags'
15:47:58 <davidhouse> err, that sounds like an error
15:48:14 <bringert> davidhouse: I think the problem with telling people to use runhaskell is that they may have but hugs and ghc, but want to specifically install on one of them
15:48:34 <SyntaxNinja> sethk: your cabal version is probably too old. which is it (ghc-pkg -l |grep Cabal)
15:48:41 <bringert> that's why I don't put runhaskell in installation instructions
15:48:43 <sethk> SyntaxNinja, ok, how do I update it?
15:48:59 <sethk> SyntaxNinja, I have Cabal-1.0
15:50:05 <davidhouse> bringert: ah, makes sense.
15:50:12 <SyntaxNinja> www.haskell.org/cabal
15:50:25 <sethk> SyntaxNinja, I see the tarball, use that?
15:50:55 <sethk> SyntaxNinja, according to the name of the tarball, it's the same version I already have, 1.0
15:51:07 <sethk> should I be using release candidate 1.2?
15:51:18 <bringert> besides, I rarely test the libraries I write with hugs, so I would be lying if I pretended that they work with any haskell implementation
15:51:19 <davidhouse> 1.1.4 at least
15:51:35 <sethk> release candidate 1.2 downloads cabal-1.1.4.tar.gz
15:51:39 <sethk> so I guess that's the latest
15:52:32 <SyntaxNinja> yes
15:53:39 <sethk> now I get the problem that Distribution.Compat.Directory is hidden (meaning hidden in Cabal-1.0).  Now what?
15:54:06 <sethk> do I need to hide Cabal 1.0?  
15:54:06 <davidhouse> you've installed Cabal-1.1.4 already?!
15:54:08 <sethk> does that even make sense?
15:54:14 <sethk> davidhouse, no, I'm trying to install it
15:54:19 <davidhouse> yeah, there are build instructions in the README
15:54:21 <sethk> davidhouse, but I get that error
15:54:32 <davidhouse> specifically, check the instructions about building with Cabal already installed :)
15:56:18 <sethk> davidhouse, found it, thanks
15:58:00 <sethk> ok, that got rid of two errors, but I still have two (this is doing runhaskell ./Setup.lhs configure for happy):  ./Setup.lhs:7:28: Module `Distribution.Setup' does not export `BuildFlags'
15:58:06 <sethk> and another for CleanFlags
15:59:05 <davidhouse> ghc-pkg --field Cabal version again
15:59:56 <sethk> davidhouse, if you meant that as a command, it's an error.
16:00:19 <sethk> davidhouse, with field instead of --field, it works
16:00:29 <sethk> davidhouse, but it lists three versions, 1.0, 1.0, and 1.1.4
16:00:40 <davidhouse> sorry, i don't really know my way around ghc-pkg.
16:00:48 <davidhouse> hmm, that means you need to unregister or hide the older ones
16:00:58 <sethk> I did hide them.  I guess I'll try it again
16:00:59 <davidhouse> you definitely followed the instructions in the Cabal README?
16:01:24 <sethk> davidhouse, yes, and it completed without any complaints
16:02:08 <davidhouse> hmm. not sure then
16:02:26 <sethk> davidhouse, when I do hide of Cabal-1.0, it works, says Savid old package config file... done.   then Writing new package config file... done
16:02:30 <sethk> but nothing has changed
16:02:37 <sethk> field still lists 1.0 twice plus 1.1.4
16:03:30 <lisppaste2> metaperl pasted "a program to figure out which employee to call based on what digits you type" at http://paste.lisp.org/display/20779
16:03:52 <metaperl> all because I got on the phone and wondered just how such a program might be written :)
16:04:14 <davidhouse> :)
16:04:18 <davidhouse> nice
16:05:07 <metaperl> davidhouse: thanks. and thanks for the help
16:06:30 <sethk> I'm still stuck here.  I can't really continue with anything because I can't install happy
16:07:48 <bringert> sethk: why do you need cabal to install happy?
16:08:13 <bringert> or did I misunderstand something?
16:08:13 <sethk> bringert, because I don't have any other way of building it.
16:08:24 <sethk> I'll try downloading a tarball instead of trying to use darcs
16:08:30 <bringert> ah, you're on windows or something?
16:08:47 <sethk> bringert, I've never programmed in windows in my life
16:09:18 <bringert> ok, so the darcs version of happy doesn't have a Makefile, only Cabal?
16:09:39 <bringert> get the 1.15 tarball, it uses autoconf and make
16:10:01 <sethk> bringert, I know how to build from a tarball.  Why would I do autoconf?  configure already exists.
16:10:23 <bringert> sorry, it's me being sloppy. I meant that is has configure
16:11:00 <bringert> I said autoconf to distinguish it from cabal's configure
16:11:59 <sethk> I assumed that since I need the darcs version of gtk2hs, it would be more likely to work with the darcs versions of happy and alex, but apparently not.
16:12:36 <bringert> ah, when I use "ghc-pkg field Cabal version", I also see multiple versions. But "ghc-pkg list" shows which ones are hidden (with parentheses).
16:13:00 <sethk> bringert, yes, I have the same.  so perhaps this happy problem isn't related to cabal at all.
16:13:10 <davidhouse> sethk, were you issuing the ghc-pkg commands as root?
16:13:24 <sethk> davidhouse, yes
16:13:27 <bringert> sethk: I think alex and happy are reasonably stable, so the release versions should normally be fine.
16:14:21 <ihope> If I getContents >>= sendOverNetwork, can I assume that the stuff will be sent over the network as it's recieved?
16:14:31 <sethk> ok, seems to be a consistent set now.  I should report the problem with darcs/happy to someone
16:15:20 <bringert> sethk: i'm trying to build happy from darcs now, to see if I get the same problem
16:15:30 <bringert>   * [happy @ 2001-01-14 13:34:30 by simonmar]
16:15:30 <bringert>   Make the examples work again.  A couple of people complained that they
16:15:30 <bringert>   were out of date after the last release.
16:15:30 <bringert> darcs failed:  Error applying hunk to file ./examples/monadtest.ly
16:15:35 <bringert> hmm
16:16:12 <bringert> --partial worked better
16:17:23 <bringert> sethk: it works fine for me, but I have Cabal from darcs, and a fairly recent GHC HEAD snapshot.
16:17:44 <ihope> Well, here's drain, take 1.
16:17:57 <bringert> my guess is that the darcs version of happy needs the darcs version of Cabal
16:18:47 <sethk> bringert, possible
16:19:19 <ihope> That's interesting.
16:20:33 <ihope> I ran my program, which accepted input via getContents. It didn't actually do anything (it was eternally waiting for a network connection), but the input which I gave it ended up on the command line instead.
16:21:49 <ihope> Is this because the input was never really needed?
16:22:28 <davidhouse> did you Ctrl-C or something?
16:23:18 <ihope> Yeah.
16:23:52 <sehute> Hi, I
16:23:56 <sehute> I'm trying to learn Haskell
16:24:11 <bringert> sehute: you've come to the right place
16:24:12 <davidhouse> yay!
16:24:19 <sehute> This is day 2, of writing Hello World-style programs :)
16:24:19 <davidhouse> @karma+ sehute
16:24:19 <lambdabot> sehute's karma raised to 1.
16:24:27 <sehute> thanks :)
16:24:29 <ihope> Heh.
16:24:51 <sehute> Anyways, I'm writing this function, but struggling whith the types
16:25:03 <sehute> I've got a function "ask", that asks the user a question
16:25:30 <sehute> do putStr question; name <- getLine; name
16:25:33 <sehute> roughly
16:25:43 <sehute> Now, my big question is: what is the correct type for that?
16:25:47 <ihope> Ah. You want "return name" at the end.
16:25:48 <sehute> String -> IO () does not work
16:25:51 <davidhouse> well, that's a type error at the moment
16:25:53 <sehute> neither IO String
16:26:04 <davidhouse> you want 'return name', as ihope states.
16:26:09 <sehute> ah, okay, thanks :)
16:26:09 <ihope> Alternatively, you can "do putStr question; getLine" and leave it at that.
16:26:17 <davidhouse> let's look at the types to find out why:
16:26:19 <davidhouse> @type getLine
16:26:20 <lambdabot> IO String
16:26:36 <ihope> If you just use "name", you're telling Haskell to perform the action "main", but that's not an action.
16:26:56 <ihope> "return main" is an action which doesn't do anything, but has main as the result.
16:26:58 <bringert> ihope: s/main/name/
16:27:01 <davidhouse> that returns an IO String, so we need to use <- to execute the IO action and get the result from it. "name <- getLine" runs the action getLine and binds name to the result.
16:27:04 <ihope> Yeah.
16:27:06 <sehute> ihope: I didn't understand that first thing you said
16:27:11 <sehute> The contents of it
16:27:33 <ihope> sehute: the "return name" thing?
16:27:35 <davidhouse> sehute: how about what i said?
16:27:44 <sehute> uhm
16:27:47 * sehute reads and thinks a bit
16:28:01 <davidhouse> here's the thing:
16:28:08 <davidhouse> a do-block needs to end with an _action_.
16:28:08 <sehute> still a n00b at this, so need to take things a bit slower :)
16:28:26 * ihope wishes the IO monad were called Action instead
16:28:27 <davidhouse> anything with type IO <something in here> is an IO action
16:28:46 <sehute> I think it's a wonderful concept, tagging all IO-data with IO
16:28:57 <davidhouse> e.g. something with type IO String is an IO action that returns a string
16:29:08 <davidhouse> if you're in a do-block, you can execute actions and get their results
16:29:27 <sehute> hm
16:29:28 <davidhouse> e.g. do name <- getLine; you ran the action getLine and name contains the results
16:29:31 <davidhouse> i.e. name :: String
16:29:43 <davidhouse> but you need to end your do-block with an action, too.
16:29:54 <sehute> okay, so... how can this be summed up
16:29:59 <sehute> do blocks needs to end with an action
16:30:07 <davidhouse> so you can't just end with 'name' because name isn't an IO String, it just a String
16:30:10 <sehute> which is the same as IO (), since IO should really be called an action?
16:30:12 <ihope> And "return name" is a "dummy" action, used when you don't want to perform any action at the end.
16:30:35 <ihope> sehute: well, they don't have to end with an IO (), but they do have to end with an IO something.
16:30:37 <davidhouse> you need to say 'return name', which is just the action that doesn't do anything at all but whose result is the variable name.
16:30:39 <sehute> okay, so when to use return and when not?
16:30:57 <davidhouse> return turns a value into an action.
16:31:08 <bringert> dons: you awake yet?
16:31:12 <sehute> okay, and an action is a generator?
16:31:15 <sehute> what is an action?
16:31:26 <sehute> the same as an imperative statement?
16:31:28 <davidhouse> if you're in a place where you need an action (i.e. end of a do-block), you could use return.
16:31:33 <davidhouse> essentially.
16:31:39 <sehute> oh, okay
16:31:53 <xerox> An action is an effectful function.
16:31:54 <sehute> so, I wish to use return at the end of the do-block, essentially :D
16:32:02 <davidhouse> an IO-action is something that can perform some IO, and has a result.
16:32:17 <sehute> Ah, so actions are like functions with "!" in ruby?
16:32:23 <davidhouse> sehute: but only use return with value, not actions.
16:32:32 <sehute> and procedures in Pascal?
16:32:43 <xerox> The type express the *effects* the function can have.  There is no side-effects.
16:32:44 <sehute> (as opposed to functions in Pascal)
16:32:53 <ihope> I can give you the "procedures in Pascal" bit :-)
16:33:07 <davidhouse> e.g. you could do ask = putStr question; getLine; -- notice the lack of a return here, because getLine is already an action. the result of getLine will be the result of ask
16:33:35 <sehute> ah, but that is because it's without the "do", otherwise it would have to be return getLine?
16:33:42 <davidhouse> nope
16:33:59 <xerox> That's a syntax error.
16:34:01 <ihope> There is a "do" in front of it.
16:34:12 <davidhouse> oops
16:34:21 <sehute> xerox: So all side-effects are actually handled by Haskell, by using effects?
16:34:23 <xerox> ask = do { putStr question; getLine }
16:34:25 <davidhouse> yeah, it should be ask = do putStrLn  question; getLine
16:34:28 <xerox> sehute - Right.
16:34:34 <davidhouse> do just allows you to take lots of actions and turn them into one single action.
16:34:41 <sehute> xerox: fantastic! :)
16:34:50 <sehute> Haskell has all the things I've missed from Python
16:34:51 <xerox> sehute - The type of the function tells you exactly what it can and can't do.
16:35:41 <xerox> That's why it is very simple to have a safe Haskell evaluator in the channel's bot.
16:35:48 <sehute> Okay, so ask question = do { putStr question; getLine } should work. Now, what would the type be of that? String -> String ?
16:35:49 <xerox> You just ban IO types.
16:35:59 <ihope> sehute: String -> IO String
16:36:01 <sehute> xerox: I love that
16:36:06 <davidhouse> sehute: that's a function which does some IO, so it must be IO something
16:36:11 <sehute> ihope: yes, of course, since it's tainted by IO :)
16:36:22 <davidhouse> and its result is a String, so it's String -> IO String
16:36:24 <xerox> ihope - No, IO String.
16:36:24 <ihope> Yeah.
16:36:32 <sehute> great
16:36:44 * sehute tries to use the newfound wisdom
16:36:46 <ihope> xerox: it takes the parameter "question", then outputs that.
16:36:48 <davidhouse> xerox, no, because it takes a parameter
16:36:51 <xerox> ask question = do { putStr question; getLine }
16:36:56 <xerox> This is String -> IO String.
16:37:35 <sehute> Okay, so now my ask function works as expected. Thanks a lot for help with that.
16:37:55 <lispy> @hoogle interactive
16:37:55 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
16:37:55 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
16:38:05 <davidhouse> night all.
16:38:12 <sehute> good night davidhouse
16:38:13 <ihope> @type interact
16:38:14 <lambdabot> (String -> String) -> IO ()
16:38:24 <xerox> sehute - `Yet Another Haskell Tutorial' has good exercises about IO, which are fun.
16:38:34 <lispy> ihope: ah yeah that's what i was thinking of
16:38:47 <ihope> I think that grabs all the input, pops it through the function, then outputs the return thingy.
16:38:47 <sehute> But now my main function fails: main = do { greet $ ask "Name?" }
16:39:01 <sehute> main is just :: IO()
16:39:09 <ihope> sehute: you want a semicolon there?
16:39:12 <sehute> What should it be in order to work?
16:39:17 <xerox> sehute - I would suggest to work out through YAHT before.
16:39:24 <ihope> main = do { greet; ask "Name?" }?
16:39:30 <xerox> Nah.
16:39:31 <sehute> I am trying to work myself through a tutorial right now
16:39:35 <sehute> But I was stuck, so I came here
16:39:42 <xerox> He wants ... name <- ask "Name?" ...
16:39:55 <sehute> http://www.iceteks.com/articles.php/haskell/2
16:40:00 <xerox> Which binds `name' to the line replied by the user.
16:40:02 <ihope> Oh, I see.
16:40:10 <lispy> main = do { name <- ask "Name?"; greet name }
16:40:17 <xerox> Right.
16:40:22 <xerox> @where yaht
16:40:23 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
16:40:29 <ihope> Then there's a shorthand for that: ask "Name?" >>= greet
16:40:32 <xerox> This one is very clear wrt this IO issue.
16:40:43 <sehute> I've looked at Yaht already, but I liked this tutorial better
16:40:56 <sehute> What does >>= do?
16:40:59 <xerox> It makes you write a little game which does exactly this thing you are trying to do.
16:41:08 <xerox> ?type (>>=)
16:41:09 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
16:41:12 <sehute> xerox: thanks, I will look into it
16:41:14 <ihope> sehute: x >>= f = do {y <- x; f y}
16:41:15 <lispy> x <- foo; bar x === foo >>= bar
16:41:38 <sehute> that makes my head explode
16:41:43 <sehute> I need to learn more Haskell first
16:41:50 * palomer 's head asplodes
16:41:52 <sehute> This is my fifth hello-world program :)
16:41:53 <lispy> well, the do-notation is sugar for (>>=)
16:42:02 <ihope> Well, nothing says you have to use it. You can stick to do-notation
16:42:09 <sehute> phew
16:42:15 <ihope> But >>= can be shorter, once you know what it does.
16:42:19 <lispy> yeah, sugar tastes good :)
16:42:21 <xerox> ?pl \f xs -> xs >>= return . f
16:42:22 <lambdabot> fmap
16:42:25 <xerox> (-;
16:42:39 <palomer> yeah, if you're not going to write your own monads then you don't really need to know about bind 
16:42:44 <xerox> Goodnight.
16:42:51 <sehute> goodnight
16:43:06 <lispy> palomer: i think you need to know about bind to understand the list monad
16:43:20 <palomer> why?
16:43:20 <lispy> but not the IO monad
16:43:23 <sehute> Well, I'll read some more, and come back and try to ask really clever questions. Thanks for all the help so far. You're all a really helpful... channel :)
16:44:06 <ihope> Well, do-notation for lists is also "clear enough", as long as you can understand it.
16:44:10 <lispy> > do { x <- [1..3]; y <- [1..3]; return (x,y)}
16:44:11 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
16:44:19 <lispy> palomer: because of that example :)
16:44:27 <sehute> lispy: that was cool
16:44:30 <palomer> why would I need bind to understand that example?
16:44:37 <ihope> Do-notation for lists is actually just a fancy way to do list comprehensions.
16:44:40 <sehute> > putStrLn "hello world, yet again"
16:44:41 <lambdabot>  No IO allowed
16:44:44 <sehute> oh
16:44:57 <palomer> anyways, I'm off!
16:44:58 <ihope> > [ (x,y) | x <- [1..3], y <- [1..3] ] -- very similar, aye?
16:44:59 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
16:45:01 * palomer rushes off
16:45:04 <lispy> palomer: it gives your the 'operational semantics' (so to speak) for why that gives a cartesian product
16:45:18 <palomer> you can understand it from a purely semantic point of view
16:45:21 <sehute> > tail ["goodbye", "hello", "world"]
16:45:21 <lambdabot>  ["hello","world"]
16:45:22 <palomer> without knowing the details
16:45:26 * palomer runs
16:46:28 <lispy> > do { x <- "Hello"; y <- "World!"; return [x,y] }
16:46:29 <lambdabot>  ["HW","Ho","Hr","Hl","Hd","H!","eW","eo","er","el","ed","e!","lW","lo","lr","...
16:46:40 <lispy> oh nice, lambdabot truncated it
16:47:14 <sethk> dcoutts, I don't need to follow make with make install?  I'm looking at the build instructions on gtk2hs/development/#development
16:47:32 <sethk> dcoutts, there is an install target, so I'll do it.
16:47:44 <yip> well, i finally got around to watching the first video lecture of sicp
16:48:06 <sehute> lispy: Why didn't it just output ["Hello", "World"] ?
16:48:35 <sethk> dcoutts, clock demo works now, btw.  :)
16:49:19 <sehute> lispy: I got the same in hugs
16:49:48 <lispy> sehute: because the list monad gives you each element of the list all at once :)
16:50:04 <sethk> dcoutts, does Clock.hs show gmt?
16:50:20 <sethk> dcoutts, very neat shadows
16:50:36 <sehute> lispy: can you translate the line you wrote to Python?
16:50:37 <ihope> x <- foo means "For every element in foo, call it x".
16:51:01 <lispy> sehute: i'm just learning python, so i dont' think i can
16:51:21 <sehute> ihope: ah like [x for x in foo], in Python
16:51:27 <ihope> Probably.
16:51:48 <sehute> and something with | in Ruby
16:52:03 <lispy> > [x,y] | x <- "Hello", y <- "World!"] -- if you are comfortable with math definitons
16:52:04 <lambdabot>  Parse error
16:52:05 <sethk> sehute, the | in Ruby comes from the list comprehension concept, so that's quite true
16:52:12 <lispy> > [[x,y] | x <- "Hello", y <- "World!"] -- if you are comfortable with math definitons
16:52:12 <lambdabot>  ["HW","Ho","Hr","Hl","Hd","H!","eW","eo","er","el","ed","e!","lW","lo","lr","...
16:52:21 <ihope> So that line is "for every element of "Hello", call it x, then for every element of "World!", call it y, then finish off with the list of every [x,y]"
16:52:23 <sehute> ah, I get it! Thanks :)
16:52:53 <Igloo> Ooo, shiny "..."ness
16:53:09 * lispy nods
16:53:12 <sehute> cool that you can iterate over "Hello" and "World" at the same time
16:53:20 <sehute> or what seems like the same time
16:53:24 <ihope> > do {x <- ["Hello, ", "world!"]; y <- x; return y} -- you can also do weird stuff like this
16:53:25 <lambdabot>  "Hello, world!"
16:53:44 <lispy> ihope: clever!
16:54:11 <ihope> Eh, it's just the definition of join translated into do-notation.
16:54:25 <lispy> join is handy...
16:54:29 <lispy> @type join
16:54:29 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
16:54:41 <ihope> @type concat -- join, but only for lists
16:54:42 <lambdabot> forall a. [[a]] -> [a]
16:54:48 <lispy> > join ["Hello, ", "world!"]
16:54:49 <lambdabot>  "Hello, world!"
16:55:03 <ihope> > concat ["Hello, ", "world!"]
16:55:04 <lambdabot>  "Hello, world!"
16:55:38 <sehute> If you start with a list
16:55:50 <sehute> > zip "Hello, " "world!"
16:55:50 <lambdabot>  [('H','w'),('e','o'),('l','r'),('l','l'),('o','d'),(',','!')]
16:56:02 <sehute> Can you make that into "Hello, world!", by using the list comprehension?
16:56:23 <ihope> > [ y | x <- ["Hello, ", "world!"], y <- x ]
16:56:24 <lambdabot>  "Hello, world!"
16:56:43 <ihope> ...Oh, I see what you mean.
16:56:50 <lispy> sehute: you can think of do-notation as one way to generalize list comprehensions
16:56:59 <ihope> I don't think you can, but maybe...
16:57:08 <sehute> lispy: okay
16:57:32 <sehute> ihope: okay, just asking random questions in hope of poking into something interesting :)
16:57:40 <ihope> :-)
16:57:43 <lispy> yeah, that happens a lot here
16:58:40 <lispy> there used to be monad comprehensions
16:58:55 <lispy> you could use the list comp. notation but with any monad
16:59:01 <sehute> how can I use list comprehension to extract only "Hello," from the list I gave above?
16:59:19 <ihope> > [ x | (x, y) <- [('H','w'),('e','o'),('l','r'),('l','l'),('o','d'),(',','!')] ]
16:59:20 <lambdabot>  "Hello,"
16:59:30 <sehute> ihope: thanks
16:59:53 <sehute> So, by nesting two list comprehensions in one, it's possible to write a huge list-comprehenshion to make it "Hello, world!" ? :)
17:00:00 <ihope> Heh, yep.
17:00:06 <sehute> A-ha!
17:00:07 <sehute> :)
17:00:09 <Cale> > unzip [('H','w'),('e','o'),('l','r'),('l','l'),('o','d'),(',','!')]
17:00:10 <lambdabot>  ("Hello,","world!")
17:00:10 * lispy likes nesting listcomps
17:00:28 <Cale> > uncurry (++) . unzip $ [('H','w'),('e','o'),('l','r'),('l','l'),('o','d'),(',','!')]
17:00:29 <lambdabot>  "Hello,world!"
17:00:37 <sehute> Cale: Hey, I'm interrogating about list comprehension here. :)
17:01:19 <Cale> yeah, there's nothing in list comprehensions which is quite like unzip
17:02:57 <sehute> [x | x <- [x | (x, y) <- zip "Hello" "World"], [y | (x, y) <- zip "Hello" "World"]]
17:03:04 <sehute> Why does this give "Does not match: Bool"?
17:03:35 <ihope> You'll want to do something like y <- [y | (x, y) <- zip "Hello" "World"]
17:03:48 <ihope> You didn't have the "y <-" there.
17:03:52 <Cale> perhaps you meant: [x | (x, y) <- zip "Hello" "World"] ++ [y | (x, y) <- zip "Hello" "World"]]
17:04:08 <sehute> Cale: No, I wish to combine them through list comprehension :)
17:04:21 <ihope> How do I make it absolutely inescapable to anyone who reads my code that an import declaration is not important?
17:04:36 <monochrom> By deleting it.
17:04:41 <Cale> hehehe
17:04:45 <ihope> What if it's required?
17:04:51 <sehute> ihope: paste what you just said, with time and date and channel in a comment on the line above
17:04:51 <Cale> then it's important
17:04:59 <monochrom> Why is it required and unimportant?
17:05:08 <ihope> Um...
17:05:19 <ihope> Well, can I put an import declaration at the end of code?
17:05:32 <Cale> no, all imports have to be at the top
17:05:34 <monochrom> Why is it important to note that it's unimportant?
17:05:39 <ihope> Meh...
17:05:57 <Cale> (which is a completely arbitrary restriction)
17:06:21 <monochrom> There are a ton of unimportant declarations in C/C++ code and I never heard anyone asking how to make sure readers know their unimportance.
17:06:22 <sehute> You could pretend that your thinking was wrong when you included the import, which should slightly increase the chance of someone removing it, which in order should make it less important
17:06:30 <sehute> -- 2+2=3
17:07:03 <Cale> import Foo -- this is unimportant
17:07:06 <monochrom> After a while your brain doesn't see "#include <iostream>" and "using namespace std;" even though they're right there at the beginning of every file.
17:07:10 <ihope> import bunchOfUsefulStuff, import bunchOfEvenMoreUsefulStuff, import oneBoringButRequiredFunction, import heapsOfUsefulStuff
17:07:41 <Cale> ihope: only list the necessary function, of course
17:07:47 <monochrom> I think you shouldn't worry.  You just shouldn't worry.
17:08:01 <Cale> import BoringButRequiredFunctions (myBoringFunction)
17:08:14 <sehute> Good point. Either what monochrom said, or registering a domain, explaining the issue. www.notsoimportantimport.com
17:10:11 <sehute> What separates IO () from IO String? Is IO () "anything that came from the IO"?
17:10:41 <ihope> IO () is an IO action that doesn't return anything useful, and IO String is an action that returns a String.
17:10:47 <Cale> A value of type IO () is an IO action which returns a value of type ()
17:10:59 <monochrom> If you have "x <- getLine" (IO String), you get a String in x
17:11:07 <Cale> (that is, an empty tuple)
17:11:20 <monochrom> If you have "y <- putStrLn x" (IO ()), you get a () in y.
17:11:29 <Cale> @type ()
17:11:30 <lambdabot> ()
17:11:38 <sehute> ihope: Okay, so IO () is an action that returns the equivivalent of void?
17:11:42 <ihope> Yep.
17:11:42 <Cale> yeah
17:11:57 <ihope> Said equvalent of void is (), which has only one value, also called ().
17:12:18 <sehute> So void is expressed by an empty tuple in Haskell. Right
17:12:20 <Cale> well, actually two values :)
17:12:21 <Cale> hehe
17:12:39 <Cale> There's  undefined :: ()
17:12:43 <monochrom> One of the values is unusable unless you start catching exceptions
17:12:45 <ihope> Errors and infinite loops aren't values; they're thunks. Right?
17:12:46 <sehute> But, how can () be tainted by anything at all?
17:13:00 <sehute> Why is IO () meaningfull?
17:13:17 <Cale> sehute: because the action can do IO before returning that () value
17:13:18 <monochrom> The same reason why void is meaningful
17:13:22 <ihope> sehute: well, it's the "IO" in "IO ()" that's the juicy bit.
17:13:59 <ihope> There's no reason to have a C value of type void, but there's plenty of reason to have a C function that returns one.
17:14:13 <monochrom> Or what Cale says.  "y <- putStrLn x"  the value of y you obtain is utterly useless, but putStrLn x is useful in its own right.  You may write "putStrLn x" and omit "y<-"
17:14:19 <sehute> Okay, so IO is like a handy tag for what the function does, then, not what it returns?
17:14:34 <Excedrin> what a function returns is what it does
17:14:43 <ihope> sehute: the IO bit means it does something, and what comes after it is what it returns.
17:14:45 <Excedrin> there's a distinction between an action and a function
17:14:46 <sehute> But why couldn't one just use () instead of UI ()?
17:14:50 <sehute> sorry IO
17:14:51 <sehute> typo
17:14:53 <Cale> A value of type (IO a) is essentially a program which when executed will return a value of type a.
17:15:02 <Cale> And which may do IO things before finishing.
17:15:04 <ihope> () can't perform actions.
17:15:05 <sehute> ah, I see!
17:15:08 <sehute> thanks :)
17:15:09 <Cale> (like printing to the screen)
17:15:17 <sehute> So IO is more like a tag, and () is more like a return type
17:15:26 <monochrom> YES!
17:15:27 <Cale> sort of
17:15:30 <Cale> hehe
17:15:32 <sehute> :)
17:15:45 <Cale> @type putStrLn
17:15:46 <lambdabot> String -> IO ()
17:16:06 <monochrom> IMNSHO most of "C functions" shouldn't be called functions, should be called procedures/actions and have the IO tag.
17:16:06 <Cale> putStrLn is a "pure" function in that it always gives the same action for the same string you pass it
17:16:44 <sehute> I see :)
17:16:45 <Cale> but you could also think of it as an impure "function" which sends a String to an (), possibly with side effects
17:16:52 <sehute> Are there other "tags" than IO?
17:16:56 <Cale> sure
17:16:56 <sh10151> yes
17:16:57 <ihope> Yep.
17:16:57 <Cale> []
17:16:59 <Cale> Maye
17:17:03 <Cale> Maybe
17:17:05 <sh10151> list :-P
17:17:07 <Cale> State
17:17:07 <monochrom> There are infinitely many tags.
17:17:11 <Cale> Tree
17:17:21 <ihope> Identity? :-)
17:17:24 <Cale> sure
17:17:28 <sehute> Oh, okay :)
17:17:38 <Cale> IO is called a type constructor
17:17:45 <Cale> it takes a type and gives another type
17:17:59 <Cale> (it's sort of a function from types to types)
17:18:00 <ihope> It's like a function that acts on types instead of values.
17:18:01 <sehute> Well, that made things a bit clearer. I found it confusing that both IO and () were considered the return type, as I interpreted the output from hugs
17:18:26 <Cale> @type Just 5
17:18:27 <lambdabot> forall a. (Num a) => Maybe a
17:18:28 <lispy> > -- 
17:18:28 <lambdabot>  Parse error
17:18:35 <Cale> @type Just ()
17:18:36 <lambdabot> Maybe ()
17:18:37 <lispy> why is that a parse error
17:18:37 <ihope> > 
17:18:38 <lambdabot>  Parse error
17:18:52 <ihope> lispy: the same reason what I did is a parse error, probably.
17:19:03 <lispy> right :)
17:19:03 <monochrom> I try not to use the word "return" on pure functions, since the word is reserved with various different meanings in IO and other similar things.
17:19:04 <Cale> lispy: it now ensures that what you put is a valid Haskell expression
17:19:29 <monochrom> So for example "f :: Int -> String" I wouldn't say "it returns a String".  I would say "result".
17:19:36 <lispy> > {- hmm... -} 1
17:19:36 <lambdabot>  1
17:19:48 <sehute> monochrom: I see. So I just have to learn some new terminology. :)
17:19:55 <ihope> Question that I should have asked a long time ago: how do I make GHC output a binary with a given name?
17:20:01 <monochrom> Thus "g :: IO String" I won't say "it returns an IO String" so you can safely say "it returns a String" no confusion.
17:20:05 <Cale> ihope: -o binaryname
17:20:37 <lispy> i tend to think to my self foo :: Int -> Char -> String takes an Int and a Char to a String
17:20:40 <monochrom> Although, it's just me.  If you are already deconfused, any wording I use you will understand.
17:20:53 <Cale> hmm, I'm not sure I'd feel comfortable with that nomenclature either :)
17:21:12 <sehute> ihope: here's the commandline I use when compiling: haskell-compiler -O --make first -o first
17:21:30 <sehute> ihope: if I'm compiling first.hs to an executable named first
17:21:48 <ihope> Okay, thanks.
17:22:06 <ihope> What's -O do?
17:22:13 <sehute> ihope: optimize
17:22:17 <sethk> ihope, names the output file
17:22:20 <perry> is there pointless pattern matching?
17:22:25 <sethk> sehute, he meant -o, not -O
17:22:32 <ihope> No, I meant -O.
17:22:37 <ihope> perry: is there what?
17:22:46 <monochrom> The word "return" is utterly low-level operational control-flow control-freak.  Mathematically (denotationally) "negate 5" *is* -5, the verb is *is*, nothing is called nothing is returned.
17:22:50 <lispy> -O, -O2, -O3 and i thought there was one for don't optimize
17:22:58 <sethk> ihope, sorry, I was looking at -o binaryname
17:23:21 <monochrom> But with IO you do want to be operational.
17:23:23 <sethk> ihope, which I thought you typed, but someone else typed it
17:23:46 <sehute> monochrom: I agree with you there. But, it still have to be written somewhere. ;)
17:23:50 <sehute> *has
17:24:03 <ihope> How can I optimize for size of the binary?
17:24:08 <sehute> monochrom: So writing it down still is a process, of some sort. :)
17:24:15 <Cale> monochrom: There is some notion of evaluation here still though. I like using the words "gives" or "evaluates to" more than "returns" for pure functions, but I don't really mind "returns" too much.
17:24:22 <lispy> ihope: run strip on the binary :)
17:24:24 <perry> ihope, foo (Node x y) = foo x + foo y 
17:24:36 <perry> ihope, make that pointless
17:24:50 <lispy> @pl foo (Node x y) = foo x + foo y
17:24:51 <lambdabot> (line 1, column 16):
17:24:51 <Cale> perry: not without naming the fields
17:24:51 <lambdabot> unexpected "="
17:24:51 <lambdabot> expecting variable, "(", operator or end of input
17:24:58 <ihope> @pl let foo (Node x y) = foo x + foo y
17:24:58 <monochrom> Oh, I don't mind.  I'm not a newbie.
17:24:58 <lambdabot> (line 1, column 15):
17:24:58 <lambdabot> unexpected "x"
17:24:58 <lambdabot> expecting operator or ")"
17:24:59 <sethk> Cale, nothing wrong with return as a verb, but it can be confused easily with return in the language
17:25:03 <ihope> Eeh.
17:25:34 <sehute> monochrom: I like the mathematics-thinking aspect of Haskell, like you mentioned
17:25:48 <monochrom> "evaluate" is excellent
17:26:00 <Cale> Yeah, I suppose there's the issue that we have a perfectly ordinary function that happens to be called return can cause some confusion there
17:26:05 <sehute> monochrom: But it's quite a change from thinking in assembly, pascal, c etc
17:26:15 <monochrom> Mathematicians use "evaluate" too.  "Evaluate this integral" whee....
17:26:31 <lispy> mathematicians are human :)
17:26:35 <ihope> Hmm.
17:26:41 <sehute> monochrom: What would you call the result of an evaluation, without using the word result? :)
17:26:52 <ihope> The returned value?
17:26:59 <sethk> lispy, prove that mathematicians are human  :)
17:27:03 <monochrom> value...  (it's very hard to pick a suitable word :) )
17:27:08 <Cale> @quote Cale
17:27:08 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
17:27:11 <Cale> @quote Cale
17:27:11 <perry> @pl foo (Just x) = x
17:27:11 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
17:27:11 <lambdabot> (line 1, column 14):
17:27:11 <lambdabot> unexpected "="
17:27:11 <lambdabot> expecting variable, "(", operator or end of input
17:27:14 <ihope> sethk: it's a postulate.
17:27:15 <Cale> aww
17:27:25 <Cale> that's not the quote of me I was hoping for :)
17:27:29 <perry> @pl let foo (Just x) = x in foo 2
17:27:30 <lambdabot> (line 1, column 15):
17:27:30 <lambdabot> unexpected "x"
17:27:30 <lambdabot> expecting operator or ")"
17:27:38 <lispy> perry: use lambda notation
17:27:44 <monochrom> And the same quote twice in a row.
17:27:50 <lispy> @pl \(Just x) -> x
17:27:50 <lambdabot> (line 1, column 8):
17:27:50 <lambdabot> unexpected "x"
17:27:50 <lambdabot> expecting operator or ")"
17:27:56 <lispy> er...
17:27:56 <perry> lambda is pointfull
17:28:10 <Cale> The @pl module can't deal with pattern matching
17:28:12 <monochrom> Someone's random number generator is just a tad too referentially transparent :)
17:28:26 <ihope> @quote Cale
17:28:26 <lambdabot>  The perfect programming language is mathematics, but that only runs on mathematicians.
17:28:28 <lispy> @pl \x -> fromJust x
17:28:28 <lambdabot> fromJust
17:28:36 <Cale> that's the one :)
17:28:57 <sehute> :)
17:29:02 <ihope> No, it's ap (const fromJust) id!
17:29:18 <ihope> ...wait...
17:29:24 <ihope> Oh, yeah. It is.
17:29:39 <Cale> perry: you can write functions which extract the individual fields, and express things in points-free form from those
17:30:11 <Cale> perry: if your datatype uses record syntax, then the field names are automatically functions which extract their corresponding components
17:30:27 <perry> Cale, or abstract fold onto trees, etc
17:30:46 <Cale> sure
17:31:17 <perry> i guess i was hoping for something i wouldnt expect
17:31:19 <Cale> > uncurry const (5,6)
17:31:20 <lambdabot>  5
17:31:24 <sehute> Can someone please enlighten me about where my chain of thoughts go wrong? Here's my broken program: http://pastebin.com/754682
17:32:05 <Cale> sehute: greet takes a String, but you're passing it an IO String
17:32:21 <Cale> you have to run  ask "Name?"  first, and pass the result of that
17:32:31 <Cale> main = do
17:32:37 <Cale>    n <- ask "Name?"
17:32:41 <Cale>    greet n
17:33:11 <sehute> Cale: So, that's a way of converting from IO String to String?
17:33:24 <Cale> yeah, within the context of a do-block
17:33:40 <Cale> there's no function of type  IO a -> a  though.
17:33:54 <sehute> Cale: I hadn't really expected that :)
17:34:06 <sehute> Cale: But it was interesting that you can convert temporary, none the less
17:34:10 <sehute> Cale: Thanks for that :)
17:34:18 <Cale> that translates into:
17:34:29 <Cale> main = ask "Name?" >>= greet
17:34:45 <Cale> or, with the parameter intact,
17:34:49 <Cale> main = ask "Name?" >>= \n -> greet n
17:34:54 <sehute> It works!
17:34:57 <sehute> Thanks Cale :)
17:35:01 <Cale> no problem :)
17:35:11 <monochrom> Write a two-tiered program.  The IO tier and the pure tier.
17:35:34 <sehute> monochrom: Good idea, then I'll see the separation properly
17:35:46 <monochrom> example http://groups.google.com/group/comp.lang.functional/msg/9a4a844e63d6feed
17:35:48 <Cale> It's neat that the program he's written is already showing signs of that :)
17:35:53 <sehute> monochrom: Is it common to stick all IO in a single file?
17:36:26 <monochrom> Somewhat.  But even with two tiers you can still spread things out.
17:36:54 <Blicero> isnt unsafePerformIO IO a -> a
17:37:12 <Cale> Blicero: well, yes, but it's cheating :)
17:37:14 <monochrom> It is there for FFI and Debug.Trace.
17:37:15 <Blicero> :D
17:37:34 <sehute> So "<-" can remove the IO tag, until the end of the do?
17:37:52 <Cale> I suppose I should say, if you're not breaking the runtime system, there's no function of that type :)
17:37:58 <Cale> sehute: yeah, basically
17:38:28 <monochrom> That's the 1st-order story.
17:38:32 <Cale> sehute: the do expression itself is defining something of type (IO t) anyway, so you can't really get rid of the IO tag.
17:38:59 <sehute> Cale: but one can fool oneself temporarily? :)
17:39:02 <monochrom> Later when you are mature enough to know >>= it offers a more accurate story, but there is no rush.
17:39:02 <Cale> yeah
17:39:04 <ihope> Yep.
17:39:32 <sehute> monochrom: I will look into >>= after writing a few simple test-programs, I promise :D
17:39:43 <ihope> There's a way to get rid of the IO tag, but you should only use that when it turns out you just applied return to something anyway.
17:40:09 <ihope> You're not supposed to know about that until you know how IO is supposed to work :-)
17:40:37 <Cale> x >>= f = do
17:40:43 <Cale>    v <- x
17:40:48 <Cale>    f v
17:41:06 <sehute> ihope: I was about to say to Blicero that I dared not use unsafePerformIO, as I guessed the ppl here would go into some sort of synthactical rage ;)
17:41:07 <Cale> to define things the other way round than they really are :)
17:41:21 <ihope> Heh.
17:41:51 <Cale> but that should make it clear what >>= does
17:42:04 <monochrom> unsafePerformIO is for extending the Haskell language and its IO libraries.  Not for direct use in applications.  Certainly not for learning purposes.
17:42:05 <bringert> sehute: I think it would be more of a semantic rage
17:42:11 <sehute> Cale: uhm, I think I need to read further into a few tutorials first :)
17:42:27 <sehute> bringert: jeje :)
17:42:29 <sethk> unsafePerformIO is sometimes ok to use
17:42:39 <Cale> x >>= f produces an action which runs x, getting the result and passing it to f, which gives another action which is then run.
17:42:41 <ihope> I guess it's "okay" to use it for debugging and trying to find out how Haskell programs work in general, but don't do stuff like seq (unsafePerformIO (putChar 'x')) to do your IO.
17:43:07 <sehute> ihope: It sounded like a bad habit from the moment I heard about it. No worries. :)
17:43:20 <Revision17> @kind Either
17:43:20 <ihope> Yep.
17:43:21 <lambdabot> * -> * -> *
17:43:36 <monochrom> There is already Debug.Trace.  You look at its source code you see it blatantly calls unsafePerformIO.  All the more reason to use Debug.Trace instead.
17:44:08 <sehute> Cale: Thanks, but I need to clarify all the terms you just used, for myself, until I can understand that :)
17:44:21 <ihope> Now, as monochrom said, unsafePerformIO is for stuff like calling C functions and telling the compiler that they don't "do" anything.
17:45:08 <sehute> ihope: Ah, that's sensible. Have to be careful to IOify the right things then, if one uses C-functions?
17:45:15 <ihope> Yep.
17:45:36 <monochrom> At the danger of indefinite prolonging, summary: Gurus may use unsafePerformIO, they know what is fair use.
17:46:00 <sehute> monochrom: Indefinite prolonging alert! ;)
17:46:02 <ihope> But it's pretty obvious that, say, calculateIntegral probably won't perform any I/O, but spawnTerminalWindow definitely will.
17:46:09 <perry> is there a canonical way to manage subtypes in haskell?  (OR a (OR b c)) with inj and prj functions
17:46:36 <ihope> perry: you mean a type that contains a value of one of three types?
17:46:37 <yip> well, there is a reason that it is there, and that reason is to use it :)
17:46:44 <sehute> void calculateIntegral(void) { printf("Hah, fooled you!\n"); }
17:47:01 <ihope> data Either3 a b c = Left3 a | Middle3 b | Right3 c
17:47:05 <ihope> sehute: :-)
17:47:33 <monochrom> bad bad bad
17:47:55 <perry> ihope, also want OR Foo (Or Baz (OR Bar (OR Woof (OR Moo Goo)))))
17:48:22 <ihope> perry: stick 'em all in a class and use existentials?
17:48:40 <ihope> class ToString a where toString :: a -> String
17:48:53 <monochrom> Just use Either instead of OR
17:48:56 <sh10151> Is there a date parsing library for Haskell?
17:49:10 <sh10151> I looked for a little while and couldn't find a good one
17:49:56 <sh10151> I mean, ideally there would be a do-all read function for CalendarTime, no?
17:49:59 <perry> ihope, you have a example of existentials (that didnt look like one)
17:50:20 <ihope> data ToStringMember where ToStringMember :: ToString a => a -> ToStringMember
17:50:50 <ihope> instance ToString ToStringMember where toString (ToStringMember x) = toString x
17:50:56 <perry> monochrom, i was wondering about Either, but all the examples make left and right asymetric
17:51:37 <ihope> Then you can use ToStringMember to convert any member of ToString to a known type, then you can use toString to access it.
17:51:39 <monochrom> You want "OR Int Double" to equivale "OR Double Int"?
17:52:11 <perry> monochrom, you familer with Liang's Modular Interpreters?
17:52:18 <monochrom> No.
17:52:31 <perry> hmm
17:53:09 <sehute> monochrom: Do you work with teaching at a university?
17:53:14 <monochrom> Yes.
17:53:19 <sehute> monochrom: I knew it :)
17:53:36 <sehute> monochrom: the YES! further up gave you away
17:53:51 <perry> class Subtype sub sup where inj :: sub -> sup; prj :: sup -> Maybe sub
17:54:16 <monochrom> If a guy successfully dates his dream girl he also does that. :)
17:54:25 <ihope> @hoogle Either a b -> Either b a
17:54:26 <lambdabot> No matches, try a more general search
17:54:29 <ihope> Gasp.
17:54:29 <palomer> dooes what?
17:54:39 <monochrom> to say/write "YES!"
17:54:50 <palomer> who's teaching?
17:54:53 <ihope> @type either
17:54:54 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
17:54:56 <perry> dont need commutativty
17:55:14 <monochrom> Then Either is adequate.
17:55:34 <palomer> @type either Left Right
17:55:35 <lambdabot> forall b a. Either a b -> Either a b
17:55:36 <sehute> monochrom: It just reminded me of the reaction of other good teachers I've met at uni. It's fantastic with people who are enthusiastic about what they are teaching. :)
17:55:41 <palomer> @type either Right Left
17:55:42 <lambdabot> forall b b1. Either b1 b -> Either b b1
17:55:43 <perry> type Term = OR TermA (OR Term F (OR TermR ....)))
17:55:53 <perry> type Term = OR TermA (OR TermF (OR TermR ....)))
17:55:54 <monochrom> What is ... ?
17:56:11 <perry> syntax is modular
17:56:11 <palomer> we want a complete listing, sir!
17:56:16 <ihope> More OR'ing?
17:56:26 <monochrom> A teacher considers his class his dream date.
17:56:28 <perry> ... is more OR'ing
17:56:41 <sehute> monochrom: Nice analogue :D
17:56:42 <ihope> data Term = TermA TermA | TermF TermF | TermR TermR ...
17:57:17 <monochrom> I am sure you have a fixed constant number of those you have in mind.  Ask the real question.
17:57:29 <perry> no..  not fixed
17:57:40 <monochrom> Ask the real question anyway.
17:58:18 <sehute> Well, I'm off to get some sleep. It's over midnight here. Thanks for all the help! I've gained much insight thanks to you. :)
17:58:27 <ihope> Aha!
17:58:38 <perry> i asked the real question..  how do you do type directed inj's into a big OR
17:58:44 <sehute> Bye
17:58:46 <ihope> It seems that getContents isn't as lazy as I thought, or something.
17:59:01 <monochrom> Then it's probably very difficult.
17:59:14 <perry> Liang has a method that requires all sorts of hacks
17:59:22 <monochrom> Try some typeclass hacking.
17:59:40 <perry> his paper is circa 1996..  wondering if vanilla haskell had something
17:59:49 <ihope> input <- getContents
18:00:10 <monochrom> Ask Oleg :)
18:00:13 <ihope> Wait a minute...
18:00:31 <monochrom> "input <- getContents"  nothing is read yet.
18:00:36 <ihope> Well, some time later, I have "hPutStr handle input"
18:00:37 <perry> his typeclass hacking is pretty dynamic, and requires -fglasgow-exts -fallow-undecidable-instances -fallow-overlapping-instances
18:00:48 <monochrom> Now the reading kick-starts
18:01:06 <perry> then you easily confuse it
18:01:15 <ihope> It's grabbing input, but it's not getting sent.
18:01:15 <monochrom> do { s<-getContents; print (const 5 s) }   Try this.
18:01:23 <perry> (or it easily confuses you)
18:01:38 <perry> thought maybe i could just do it better
18:01:58 <monochrom> Yeah it's going to be difficult and using ghc extensions.  Oleg does these things for breakfast.
18:02:31 <perry> "Monad Transformer and Modular Interpreters" Liang, Hudak, Jones.  POPL95
18:02:42 <perry> where do i find Oleg?
18:02:42 <monochrom> ihope: that only implies hPutStr is strict
18:02:51 <ihope> Oh.
18:03:48 <monochrom> If you now request hPutStr to be incremental (read a bit, write a bit, repeat), someone multi-threading guy will be extremely unhappy.
18:04:11 <ihope> Actually, I am multithreading...
18:04:18 * ihope writes a lazy version
18:04:19 <monochrom> If you ask on the haskell-cafe mailing list, and catches Oleg's attention, he will reply.
18:04:45 <perry> monochrom, ok..  thanks
18:05:48 * joelr1 waves
18:06:06 <ihope> Well, now I can see my input again./
18:06:13 <monochrom> oleg@pobox.com , http://pobox.com/~oleg/ftp/
18:06:41 <joelr1> does anyone else feel that most of the time with haskell is spent fighting laziness?
18:06:53 <monochrom> If you understand everything on his web page, you can send your resume to SPJ... :)
18:06:59 <ihope> joelr1: no. :-P
18:07:11 <ihope> Why would laziness be a problem?
18:07:24 <joelr1> ihope: ;-)
18:07:34 <monochrom> If you have two threads doing hPutStr stuff ...
18:07:46 <Cale> joelr1: absolutely the opposite -- most of my time in a strict language is spent fighting strictness
18:08:02 <ihope> monochrom: but I'm not seeing any output at all.
18:08:10 <joelr1> rewire my brain i must
18:08:10 <ihope> hPutStr handle ~(x:xs) = hPutChar handle x >> hPutStr handle xs -- this string'll be infinite
18:08:17 <ihope> I did that.
18:08:27 <Cale> I have to turn all my nice data structure transformations into explicit loops.
18:08:27 <joelr1> Cale: because i don't experience what you experience
18:08:41 <Cale> It's a pain :)
18:08:57 <yip> it can be annoying that some haskell programs won't run at all unless you add strictness flags to it
18:09:05 <joelr1> Cale: but the data structure tranforms can be done in strict languages, no?
18:09:19 <joelr1> why translate to loops?
18:09:25 <Cale> Not when they'd operate on infinite or very large structures.
18:09:47 <Cale> Consider doing a search through possible game moves
18:09:50 <monochrom> ihope: so, does your lazy version of hPutStr work?
18:09:58 <monochrom> Also note buffering issues.
18:10:04 <ihope> Nope. There's still no output.
18:10:14 <joelr1> Cale: so you are limiting yourself to that domain then
18:10:15 <Cale> It's stupid in a strict language to try to define the whole game tree
18:10:20 <ihope> But buffering... lemme look at that.
18:10:37 <Cale> You have to mix up the generation of the game tree with your search
18:10:53 <joelr1> Cale: i agree with you re: game tree
18:10:57 <Cale> which is quite irritating, and makes the code harder to maintain
18:10:59 <monochrom> Attempt no-buffering, see if that changes anything.  Then re-introduce a buffering scheme you like.
18:11:10 <ihope> Yes! It was block-buffered!
18:11:19 <Cale> and lots of things you'd normally do with lists have to become loops too, and you can't reuse code as well
18:11:45 <monochrom> Block-buffering is desirable if you write things to files needing no interaction.
18:12:20 <monochrom> If you combine generation and search, you introduce bugs.
18:12:29 <joelr1> Cale: remind me, where/what do you work on again?
18:12:51 <Cale> joelr1: currently I'm a student, working on code generation for DFTs
18:12:52 <ihope> @karma+ monochrom
18:12:53 <lambdabot> monochrom's karma raised to 4.
18:13:04 <monochrom> This is no hinderance to Richard Bird.  He knows fusion laws and can do those combinations calculationally, no bug possible.
18:13:08 <monochrom> But you are no Bird.
18:13:31 <joelr1> Cale: i thought you worked on some compiler stuff
18:13:34 <monochrom> Bird is unable to write buggy programs.
18:13:35 <Cale> yeah
18:13:41 <ihope> Now I just have to fix the fact that if I have 2 faucets, everything will get output twice to each faucet.
18:13:56 <ihope> Likewise, 3 faucets would produce 3 outputs per faucet, etc.
18:13:56 <Cale> Well, I'm working on a very specific part of a big compiler at the moment
18:14:25 <ihope> Actually, maybe not.
18:15:00 <perry> monochrom, is there a description of Bird's bugfree programming technique somewhere?
18:15:15 <ihope> Now, this is weird.
18:15:24 <monochrom> Either Bird's home page of publications, or "Algebra of Programming" book.
18:15:38 <ihope> I'm getting output like normal on faucet 1, but nothing on faucet 2.
18:15:39 <perry> just read the book?
18:15:51 * ihope pops a few yields into the code
18:15:51 <joelr1> Cale: i thought you did dfts?
18:15:54 <monochrom> Yeah.
18:16:11 <palomer> bugfree programming?
18:16:11 <monochrom> It will keep you occupied for a while.
18:16:12 <ihope> Oh, right. hPutStr is strict?
18:16:13 <perry> the other author is the one who never wanted to do it again?
18:16:21 <Cale> joelr1: The compiler is for a special purpose language for signal processing
18:16:23 <monochrom> Hehehehe that's the one  :)
18:16:34 <Cale> joelr1: So yes, both :)
18:16:35 <joelr1> Cale: ah!
18:16:39 <palomer> never wanted to program bugfreely again?
18:16:50 <perry> why did the other author feel that way?
18:17:11 <monochrom> The other alternative is to embrace Haskell laziness and stop complaining.
18:17:43 <perry> bird doesnt do lazy programming?
18:18:02 <perry> or what is that the alternative of?
18:18:33 <monochrom> He's impartial to that.  He knows how to write a producer and a consumer separately.  He also knows how to fuse them.
18:18:54 <monochrom> "Some researchers write impeccable programs.  For the rest of us, there is Haskell."
18:19:00 <palomer> monochrom: are you still a masters student?
18:19:04 <monochrom> No.
18:19:11 <palomer> graduated?
18:19:14 <monochrom> No.
18:19:42 <ihope> Hmm, still not working.
18:19:50 <monochrom> "Some researchers write impeccable programs in any setting.  For the rest of us, there is always Haskell."
18:21:30 <AtnNn> "Impeccable program: priceless. For Haskell coders, there is mastercard."
18:22:15 <palomer> and then for those who actually want to get something done, there's java
18:22:39 * palomer ducks and runs off
18:23:02 <Cale> palomer: have you ever actually tried using Java?
18:23:13 <monochrom> There is a difference between "done" and "looks like done".
18:23:59 <monochrom> Their mouths say "get things done".  Their code is only "looks like done".  A professional-looking GUI goes a long way towards that self-deception.
18:24:17 <monochrom> But don't despair!  With gtk2hs we can do that too!
18:24:56 * bringert can hardly remember the last time he wrote a program with a GUI
18:25:02 <bringert> unless you count web apps
18:34:24 <lispy> i have to put GUIs on things i write at work
18:34:43 <lispy> so we use java, vb and python mostly
18:34:50 <Pete_I> guis are overrated.
18:35:24 <bringert> Pete_I: what do you mean?
18:35:47 <Pete_I> the "must have lots of pretty buttons" thing is anoying in a lot of programs.
18:36:55 <Pete_I> overrated is probably the wrong word.
18:37:14 <Korollary> The productivity gains are overrated
18:37:27 <febuiles> Pete_I, misunderstood maybe?
18:37:37 <dons> moin
18:37:42 <Korollary> moin
18:37:47 <bringert> morning dons
18:37:47 <lispy> moin
18:37:57 <lispy> Korollary: i think you're exactly right
18:37:59 <bringert> morning for you anyway I guess
18:38:12 <lispy> for some tasks,  you need to be visual and for others it's not important or gets in the way
18:38:44 <Pete_I> i suppose some tasks have to be visual. a picture editor would be a pain without it being visual.
18:39:21 <lispy> yeah, ed vs. vi
18:39:46 <bringert> dons: I can't get hs-plugins to build on ghc 6.5. AltData.Typeable uses macros INSTANCE_TYPEABLE{1-3} which don't see to be defined in Typeable.h in my ghc
18:40:20 <dons> yes. you need to manually copy a Typeable.h file from a 6.4.x installation into the ghc include dir
18:40:23 <dons> :/
18:40:31 <bringert> ah, excellent
18:40:42 <dons> i'm hoping to fix the need for hs-plugins to have its own Typeable before 6.5 comes out
18:41:14 <bringert> maybe there could be an #ifndef INSTANCE_TYPEABLE{1-3} that defines them
18:44:06 <bringert> dons: on an unrelated note, I think that ByteString.Lazy should have a generalized version of hGetContentsN, which takes the reading function as an argument, in the same way that createAndTrim generalizes hGet. I have written my own by copying hGetContentsN, code here http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/Network/FastCGI.hsc
18:44:27 <dons> hmm. interesting.
18:44:36 <bringert> one problem is that is uses createAndTrim, which null-terminates each block. this seems wasteful
18:45:14 <dons> buildByteString ?
18:45:15 <bringert> and if you use sensible block sizes like 4096, you actually allocate blocks of 4097 bytes, which might be bad for all sorts of things
18:45:19 <bringert> yep
18:45:24 <bringert> name is stupid
18:45:39 <dons> bringert: hmm, yes, this is a good point.
18:46:21 <dons> we're pondering a solution to the null termination property. it might go away
18:46:39 <dons> and instead, you'd only be able to use it via a copyCString0 or something
18:46:50 <bringert> that makes sense
18:47:04 <bringert> to me anyway
18:47:13 <dons> it was originally added to avoid copies, but the uses are rare where that matters.
18:47:41 <bringert> I have never had use for the fact that ByteStrings are (can be) null-terminated 
18:47:52 <bringert> but of course i'm not everyone
18:49:05 <dons> of course, it seems useful, since you can pass (most) bytestrings to C, without worrying about explicit null termination, but in the presence of sliced substrings, its not consistent enough to be useful
18:49:35 <bringert> since the ByteString already knows its own length, it's easy enough to use the C function variants which take an explicit length
18:49:49 <bringert> my impression is that most have such variants
18:50:10 <bringert> at least functions which work on large strings / buffers
18:50:18 <bringert> for small ones, copying is cheap anyway
18:52:55 <dons> yeah, so maybe i'll remove this null termination thingy, add a copy0, and try to make sure everything works.
18:53:00 <dons> probably it'll all run faster :)
18:53:21 <dons> I think dcoutts would also be happy. no one likes the non-consistent null termination :}
18:53:57 <bringert> you have my vote
18:54:09 * dons has a job for the day 
18:57:06 <ihope> Okay. Test thing #1: drain foo | faucet foo
18:57:25 <ihope> Yep, it works.
18:57:59 * ihope suddenly realizes that Windows has no stderr file, and looks for an appropriate substitute
18:58:52 <_SamB_> ihope: indeed?!?!?
18:59:09 <ihope> Test #2: faucet foo | tee - | yes bar | drain foo
18:59:27 <ihope> Indeed, it no worky.
19:00:04 <ihope> Hmm... and draining into two faucets still doesn't work.
19:01:27 * ihope tries to write an IRC bot in sed and use faucet and drain with it to make a circular pipe
19:03:05 <lispy> heh
19:03:11 <lispy> good luck with that
19:03:26 <SamB> aren't *most* pipes rather circular?
19:03:33 <monochrom> No.
19:03:47 <Pete_I> i thought pipes were usually cylindrical.
19:03:47 * ihope tries to write an IRC bot in sed and use faucet and drain with it to make a toroidal pipe
19:03:57 <monochrom> Oh haha, that.
19:04:56 <SamB> Pete_I: yes, circular cylindrical
19:05:18 <SamB> right circular cylindrical, even
19:08:02 <ihope> Hmm.
19:08:19 <ihope> What's that "if this is the first line" thingy?
19:09:41 <ihope> Like "on the first line, replace foo with bar"?
19:12:29 <SamB> "info sed"
19:18:06 <dons> ihope: how does the bot do network io? via named pipes?
19:18:44 <ihope> faucet 839 | sed 'program' | telnet server | drain 839, for reasonable values of 839
19:21:27 <ihope> If I'm lucky, sedbot will join soon.
19:21:42 <ihope> If I'm unlucky, it won't.
19:21:58 <dons> cool
19:22:15 <ihope> I'm guessing I was unlucky.
19:22:33 * ihope adds a tee
19:22:53 <dons> how good's your sed?
19:23:18 <dons> i learnt a lot of my sed from sed.sf.net
19:23:19 <lispy> sed-fu
19:23:34 <dons> actually, there's some great programs there (i wonder if the site's still up)
19:23:41 <ihope> 1s/foo/bar/;s/baz/quux/ replaces foo with bar on the first line and baz with quux on all lines, right?
19:23:51 <dons> yep
19:24:04 <ihope> Apart from regexes, that's the limit of my sed-fu.
19:24:14 <dons> ah, so no lookup tables, or x and g?
19:24:19 <ihope> Right.
19:24:31 <ihope> Wait, do you mean s/foo/bar/g?
19:24:44 <dons> sed's a great world, since you get two variables, that you have to partition 
19:25:03 <ihope> I also know that # does something. How useful, eh?
19:25:05 <dons> oh, and only regexes and lookups, so no math. it all has to be emulated
19:25:17 <dons> its a bit like unlambda or lambda cal.
19:26:29 <ihope> faucet 185 | tee log2.txt | sed '1s/.*/NICK sedbot\nUSER sedbot sedbot sedbot sedbot/;s/PING :\(.*\)/PONG sedbot :\1/' | telnet brown.freenode.net | tee log.txt | drain 185
19:27:18 * ihope tries a more elaborate faucet/drain test: drain foo | faucet bar and drain bar | faucet foo
19:27:43 <ihope> Oh, right!
19:27:56 <ihope> The drain has to come before the faucet!
19:28:00 * ihope ought to fix that
19:30:50 <ihope> I don't suppose there's a version of connectTo that keeps trying to connect indefinitely, is there?
19:35:47 <sethk> ihope, I think you can set the timeout to infinity
19:35:55 <ihope> How do I do that?
19:35:55 <sethk> ihope, which is effectively the same thing
19:36:05 <sethk> ihope, let me check, I did it a few weeks ago...
19:37:30 <sethk> ihope, I think I had to use Network.Socket and some lower level functions
19:37:46 <ihope> Oop.
19:38:11 <ihope> Writing faucet/drain programs shouldn't be this hard...
19:38:46 <sethk> ihope, generally they aren't, but some things are a bit difficult
19:39:17 <sethk> ihope, I'll try to find it.  I remember going through some of the socket code in the library
19:39:25 <sethk> ihope, I may have had to hack it
19:41:02 <febuiles> Pete_I, misunderstood maybe?
19:41:12 <febuiles> mm sry, early msg :D
19:44:29 <ihope> Oh, right.
19:44:37 <ihope> I'll try bash instead of cmd.
19:47:41 <lispy> BASH!!!!
19:47:47 <lispy> (is your friend)
19:48:42 <ihope> ...does bash expect me to add shebangs to my executables?
19:48:57 <ihope> They're executables! You're supposed to execute them!
19:49:57 <SamB_XP_> uh, you mean .exe files?
19:50:18 <sethk> ihope, if you are running in cygwin, there is a layer added to the file system so you can chmod +w
19:50:22 <SamB_XP_> maybe if you just chmod +x them, it will be happy ;-)
19:50:29 <sethk> ihope, of course, natively windows is too dumb to do stuff like that
19:50:31 * ihope gets dizzy
19:51:48 <ihope> So... I chmod +x'd and chmod +w'd them, but it didn't do anything.
19:52:55 <sethk> ihope, sorry, +x, not +w
19:52:56 <sethk> typo
19:53:06 <sethk> ihope, what are we talking about here?  A script?
19:53:14 <ihope> They're .exe files.
19:53:28 <sethk> ihope, what happens if you do ./whatever?
19:53:36 <sethk> ihope, could it be a path issue?
19:53:40 <ihope> Good idea.
19:54:48 <ihope> Meh, I'm probably trying to do too many things at once.
19:55:13 <SamB_XP_> oh, heh, I didn't even think of the possibility that you wouldn't have called them with ./ if they are just in CWD...
19:55:38 <ihope> Never underestimate the stupidity of a newbie :-)
19:55:48 <ihope> Well, it's bedtime. I'll be back in the morning.
20:02:03 <gvdm> If you are trying to solve a problem and the ways in which you are doing it keep resulting in errors where you have IO a as the result of your working but you wish to have just a, what does this usually indicate you are doing wrong?
20:02:42 <sethk> gvdm, probably that you are trying to escape the IO monad.  The whole point of the monad is that you _can't_ escape it.
20:02:44 <gvdm> I have a feeling I am trying to solve the problem in the incorrect manner, this problem keeps reoccureng, sometimes with strings
20:03:00 <gvdm> sometimes portnumbers
20:03:17 <sethk> gvdm, Probably it's best to look at a few concrete examples
20:03:26 <sethk> gvdm, try to get to the general through the specific
20:03:44 <sethk> because when you start trying to talk in generalities you quickly get to vacuity
20:04:16 <gvdm> ox
20:04:42 <gvdm> getTarget entry = do \n target <- entryGetText \n entry return target
20:05:01 <gvdm> basically, getting a string from a gtk entrybox
20:05:09 <gvdm> and returning it
20:05:17 <gvdm> but it returns IO String
20:05:21 <gvdm> not String
20:05:37 <sethk> gvdm, correct.  First thing to remember is that "return" here is probably not doing what you think it is.
20:05:45 <gvdm> ok
20:06:02 <sethk> gvdm, when you say   return "xyz"    the return makes it an IO String
20:06:03 <gvdm> ...
20:06:19 <gvdm> ok, what if i want to return the string
20:06:19 <sethk> if the last line of a haskell function is    "xyz"     then the function return type is String
20:06:30 <sethk> leave off the return.
20:06:31 <Dino_> I'm very new too, but we were going over stuff like this yesterday. Isn't it enough to do the 'target <- entryGetText' and then use that target in a call to something which takes a String?
20:06:31 <sethk> but....
20:06:56 <sethk> if you are in a monadic context, you'll get an error saying that String is wrong
20:07:20 <sethk> gvdm, if the function is within the IO monad, then you _cannot_ return String
20:07:25 <sethk> gvdm, bad use of language
20:07:36 <sethk> gvdm, the type of the function cannot be String
20:07:57 <gvdm> so, im trying to solve it wrong, how do i then solve this problem...
20:08:15 <sethk> gvdm, the type being   IO String   is not a problem
20:08:31 <sethk> gvdm, so, first, stop trying to make it return String instead of IO String.  IO String is probably correct
20:08:48 <sethk> gvdm, then look at what you may be having problems doing because it is  IO String    rather than just   String
20:08:49 <gvdm> ok.. but the function wants a String
20:09:01 <sethk> gvdm, ok, there is a way to handle that
20:09:09 <sethk> gvdm, can you paste some code that we can look at?
20:09:22 <sethk> gvdm, where you are trying to use the String  ?
20:09:30 <gvdm> preffered paste?
20:09:33 <sethk> Dino_, basically, yes
20:09:41 <sethk> gvdm, hang on, I'll get it.
20:09:45 <gvdm> onClicked startButton $  spy (getPort portEntry) (getTarget targetEntry) (getPort targetPortEntry)
20:09:53 <gvdm> (getTarget targetEntry) is the problem
20:10:26 <sethk> http://paste.lisp.org/new/haskell
20:10:52 <gvdm> oh, crap, my web cache is broken...
20:11:28 <gvdm> hmm this means no http for me
20:13:09 <gvdm> im at uni, everything i do has to go through a caching proxy, this breaks every now and then
20:13:14 <sethk> gvdm, what Dino_ was saying earlier is the basic idea
20:13:57 <sethk> gvdm, if you invoke a function that is returning IO String, say it is called x, then you use either the do notation:    do   z <- x      and then z will be String rather than IO String
20:14:04 <gvdm> ./GUI.hs:37:4: The last statement in a 'do' construct must be an expression
20:14:16 <sethk> gvdm, right, because you have to do something with z
20:14:30 <sethk> gvdm, to understand that message, the do notation is really a shorthand for this:
20:14:33 <febuiles> gdvm you have to use the variable you just created somewhere in the scope of that funciont
20:14:53 <sethk>     x >>= \z -> ......                    and the message means you have done the    \z ->    part but not the rest
20:15:15 <gvdm> thats what i was trying to use return for, but that is wrong or so im told
20:15:20 <gvdm> so what do i do?
20:15:20 <sethk> gvdm, so for example you can do:     do  { z <- x; putStrLn x }
20:15:35 <gvdm> putStrLn z?
20:15:37 <sethk> gvdm, there I used the z in the putStrLn statement (that is, I printed it out)
20:15:53 <sethk> putStrLn z   means put string with newline to standard output
20:16:19 <gvdm> yeah but you said x so i was clarifying the typo
20:16:40 <sethk> gvdm, when I'm coding something in that situation, and I want to make sure the string is what I expect, before I code up the rest of the function, I print it out, which also gets rid of the "last statement must be a " message
20:16:48 <sethk> gvdm, oh, ok, sorry  :)
20:17:01 <sethk> I can't type anymore
20:17:29 <febuiles> now that I see a LTerm up there, anyone has any basic idea of how to implement a substitute function for abstractions? I'm trying to build a LCalculator but its not turning out well -_-
20:17:36 <monochrom> If you don't write like "x<-stuff" in the last statement, you're fine.
20:19:05 <lisppaste2> febuiles pasted "LCalculator" at http://paste.lisp.org/display/20784
20:19:27 <febuiles> that's what I have so far but I'm having troubles in the last part, so if anyone has a suggestion please let me know :D
20:19:29 <Dino_> I think the return is for if you're leaving the do block, needing to return the 'IO a' thingy.  return :: a -> m a
20:20:16 <monochrom> You can also write like do { getLine }
20:20:44 <monochrom> A less degenerate example.  do { putStrLn "enter something"; getLine }
20:21:50 <Dino_> But in gvdm's case, he can really just do { z <- x; putStrLn z }  without doing anything further to that z, knowing that putStrLn takes String.
20:22:35 <sethk> right.  the putStrLn was just my quickie example of what I meant by doing something with the string.
20:22:44 <gvdm> yes, but then the place calling this function cant get at that String
20:23:18 <sethk> gvdm, you lost me
20:23:29 <sethk> gvdm, wish you could paste
20:23:46 <gvdm> yeah, web cache might be up in an hour
20:23:52 <gvdm> will check back here
20:24:08 <sethk> ok
20:27:13 <petekaz> newbie question: I have installed fps via the cabal instructions.  When I compile using ghc, I add the -make option and things work fine.  Now, I am trying to build a local copy of lambdabot, and it seems that it can't find fps.  I also notice that the build for lambdabot doesn't use -make.  So the question, what's the missing link?
20:27:45 <petekaz> Is there some file I need to update on my system that ghc uses to search for local libraries?
20:39:40 <Lemmih> petekaz: -package fps maybe?
20:40:21 <bmedwar41> perekaz: ghc-pkg list, if fps is in parens it is hidden
20:40:39 <petekaz> ok, I'll try both of those
20:43:32 <bmedwar41> lemmih: what is up with www.scannedinavian.org, it is always down for me
20:43:57 * petekaz recalls why he likes python/ruby so much ... no compilation issues
20:44:28 <petekaz> @version
20:44:28 <lambdabot> lambdabot 3.1p35, GHC 6.4.1 (Linux i686 3.20GHz)
20:44:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:45:40 <Lemmih> bmedwar41: www.scannedinavian.org is gone.
20:46:05 <Lemmih> bmedwar41: I've moved my stuff to http://darcs.haskell.org/~lemmih/
20:46:24 <bmedwar41> cool, thanks
21:03:01 <gvdm> will check back here
21:07:50 <Dino_>  /quit
21:27:48 * blackdog sight
21:27:51 <blackdog> sighs, even.
21:28:00 <blackdog> i haven't written a piece of haskell code for months
21:28:04 <blackdog> i feel homesick
21:28:47 <monochrom> hehehehe
21:29:09 <monochrom> I wrote some Haskell code to help me play The 11th Hour.
21:29:47 <blackdog> dynamic languages are fun and all, but getting reacquainted with catching dumb errors at runtime is not.
21:29:55 <blackdog> how'd that work out?
21:31:19 <monochrom> There are search problems.
21:33:33 <monochrom> I wrote small Haskell programs to perform the searches.
21:35:33 <lispy> monochrom: nice
21:36:08 <lispy> blackdog: yeah, i hear you there
21:45:52 <gvdm> will check back here
21:55:47 <dons> petekaz: probably you just need to make distclean
21:56:02 <dons> since i guess you tried to install fps after starting off your lambdabot build
21:56:18 <dons> i should really port lambdabot to Cabal, then the build system complaints would evaporate
21:56:23 <stepcut> :)
21:56:34 <dons> also, you can use ghci if you don't like compilation... ;)
21:56:56 <dons> blackdog: hey, hows things?
21:58:07 * dons -> lunch
22:03:18 <blackdog> hey don. um. enjoy lunch, i guess...
22:06:15 <lispy> lunch?
22:06:25 <lispy> dons: it's 22:05, you can't eat lunch right now :)
22:06:38 <blackdog> ah, but it's 1500 here
22:09:03 <bringert> lispy: you're in PDT I see
22:09:07 <bringert> where?
22:09:15 <lispy> corvallis, OR
22:09:37 <lispy> i went to OSU for years and never finished or left :)
22:09:44 <lispy> you?
22:09:54 <bringert> in Seattle, WA at the moment
22:10:09 <bringert> normally at Chalmers, Gothenburg, Sweden
22:10:18 <lispy> oh wow
22:10:25 <lispy> what are you doing in the us?
22:10:28 <bringert> lispy: you do haskell for work right?
22:10:41 <lispy> no, but i keep trying to sneak it in
22:10:54 <bringert> hanging out with my girlfriend who is doing an intership at Microsoft Research
22:10:57 <lispy> but i keep having requirements like, COM and GUI that make haskell a pain to use
22:11:02 <lispy> cool
22:50:48 <bringert> hmm, lazy parsing is tricky
23:18:09 <bringert> I'm trying to build fps from darcs under ghc 6.5.20060526, but I get conflict: module `Data.ByteString.Base' belongs to the current program/library and also to package base-1.0
23:18:26 <bringert> and I can't really hide the base package
23:31:37 <audreyt> dons: ping
23:32:16 <audreyt> ?eval foo
23:32:17 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
23:32:36 <audreyt> dons: you fixed the ?eval but lambdabot is now free associating instead of evaluating haskell code
23:32:48 <audreyt> dons: is that a... feature? :) can we get it to not do that?
23:33:18 <audreyt> (as seen in #perl6, its conversation with larry wall)
23:33:20 <audreyt> 08:25 < TimToady> ?eval say my $a
23:33:20 <audreyt> 08:25 < lambdabot> nsa try kill me numerous times
23:37:55 <lispy> @keal
23:37:56 <lambdabot> actually it bug in math
23:37:58 <lispy> ?eval
23:37:59 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
23:38:03 <lispy> hmm....
