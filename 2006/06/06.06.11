00:26:35 <vincenz> anyone know anything about haskell compilation?
00:26:52 <vincenz> for instance...functions definitions are turned into case-exprs?
00:27:25 <neologism> vincenz: I'd google for stg
00:27:34 <neologism> (spineless tagless g-machine)
00:28:01 <vincenz> I'm not interested in the lowlevel details
00:28:01 <vincenz> just
00:28:04 <vincenz> foo (x,y) =  ...
00:28:10 <vincenz> is this turned into a 
00:28:15 <vincenz> \a -> case a of (x,y)
00:28:16 <vincenz> ?
00:33:04 <vincenz> hmm
00:33:05 <vincenz> I guess s
00:33:06 <vincenz> ..o
00:33:33 <Philippa> I imagine most sane compilers do so. IIRC the Report defines it that way
00:34:02 <vincenz> another thing that's bugging me is how to deal with native functions transparently
00:34:06 <vincenz> that's why originally I had
00:34:12 <vincenz> Function (Value -> m Value)
00:34:19 <vincenz> so I can encode the native ones as actions
00:34:55 <Philippa> that's a low-level detail
00:35:01 <vincenz> ..
00:35:08 <vincenz> yes but if I want my interpreter to work
00:35:12 <vincenz> that's an important detail
00:35:46 <Philippa> my toy interpreters tend to have some variant of Builtin ... as a constructor in the AST
00:35:53 <vincenz> ah
00:35:58 <vincenz> yeah I basically annotate my functions
00:36:04 <vincenz> with either Code (patterns, Exp)
00:36:06 <vincenz> or Native
00:36:37 <vincenz> maybe I oughta inline natives and have Builtin in my ast
00:37:08 <vincenz> hmm
00:37:11 * vincenz ponders
00:37:43 * vincenz just adds VBuiltin
00:37:49 <vincenz> I'll do a case when I do a func call
00:40:51 <Philippa> you'll need to anyway, if only to cover the possibility you've got a broken AST
00:41:18 <vincenz> hmm?
00:41:24 <vincenz> how's that
00:44:09 <vincenz> I don't think so
00:46:02 <Philippa> it did occur to me afterwards you might be doing the GADT-encoded invariants thing
00:46:20 <vincenz> ?
00:46:27 <vincenz> in englis?
00:46:29 <Philippa> but if not, then you could end up with the application of something that's not a function
00:46:51 <vincenz> I doubt that
00:46:54 <Philippa> so you'd need to pattern-match to catch the error
00:46:55 <vincenz> my ast is errorfree
00:47:21 <vincenz> and because it's properly typed, I know for sure I won't be calling something that's not a function
00:47:27 <Philippa> see GADT-encoded invariants. Though there could be alternatives
00:47:36 <vincenz> ...
00:47:39 <vincenz> I don't use GADT
00:47:54 <vincenz> And I won't be able to discuss much unless you use terms I know of
00:47:56 <Philippa> it's preferable not to assume your typechecker works, if only to make finding the bug easier :-)
00:48:14 <Philippa> you might want to look up "invariant", it's a pretty common one
00:48:14 <vincenz> Well if it fails I'll pattern-match the wrong type of value during interpretation
00:48:25 <vincenz> Philippa: yes so is GADT
00:48:27 <vincenz> Philippa: and so is encoded
00:48:35 <vincenz> however "GADT-encoded invariant" is not
00:48:44 <Philippa> GADT-encoded would suggest "encoded with GADTs"
00:49:12 <vincenz> indeed
00:49:21 <vincenz> now if you told me which invariants I might encode with GADT
00:49:25 <vincenz> we might have something to talk about
00:50:24 <vincenz> (and additionally how to encode variants with a GADT, but that's not necessary for discussion and just "an implementation issue")
00:50:47 <vincenz> I thought we were talking about builtins
00:50:51 <vincenz> you said you use those to represent failures
00:50:55 <vincenz> you never mentioned what sort
00:50:58 <vincenz> I can't have that kind of failure
00:51:03 <vincenz> cause when I do scoping rules
00:51:16 <vincenz> I have a full set of bindings, including to native functions from my custom prelude
00:51:22 <vincenz> anything not resolved is inexistent and thus leads to an erorr
00:51:49 <Philippa> I didn't say I use builtins to represent failures
00:52:02 <vincenz> 09:40 < Philippa> you'll need to anyway, if only to cover the possibility you've got a broken AST
00:52:09 <vincenz> when referring to Builtin
00:52:19 <Philippa> yes. As in, do a case analysis on your applications to see what you're applying
00:52:25 <vincenz> oh
00:52:34 <vincenz> rightio
00:52:36 <vincenz> well right now it's
00:52:47 <vincenz> (VFunction vf) <- interpretExp ef
00:53:02 <vincenz> but yea that was based on the whole monadic value concept
00:53:15 <vincenz> which led to problems in autoderiving my interpretermonad as a monad cause it was self-referring
00:53:19 <vincenz> :(
00:55:45 <vincenz> holy cow: http://en.wikipedia.org/wiki/Image:Assembly2004-areena01.jpg
01:10:38 <AiLr> Does anybody know, where can i find this 2d L-Systems rendering program - http://www.haskell.org/gtk2hs/albums/Cairo-demo/Cairo_demo_13.png ?
01:11:59 <xerox> @where nymphaea
01:12:00 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
01:12:15 <xerox> There :)
01:13:50 <AiLr> Thanks a lot ;)
01:15:26 <xerox> Thank you for your interest in my program =)
01:15:50 <vincenz> buona mattina
01:17:24 <xerox> Oi!
01:25:32 * vincenz >>= pool
02:03:45 <shapr> jiihaa
02:04:08 <shapr> Wassup?
02:04:44 * shapr bangs the drums to wake up people.
02:04:50 <xerox> Eeeek!
02:05:11 <shapr> hiya xerox, is there a public cabal-get repo online?
02:05:22 <xerox> Not yet.
02:05:36 <shapr> ok, just wondering.
02:05:40 <shapr> I had the urge to hack on it today.
02:05:43 <xerox> I've got final *big* exams next week so I am studying now.
02:05:47 <dons> ?quit new code
02:06:00 <shapr> I'd like to at least integrate the cabal-install code.
02:06:12 <shapr> Since it'd save me time to fix cabal-install and then rebuild Hope :-)
02:06:27 <xerox> Hope? What's that!
02:06:40 <xerox> @where hope
02:06:43 <shapr> http://www.scannedinavian.com/hope/
02:07:03 <shapr> @where+ http://hope.bringert.net/
02:07:04 <shapr> oops
02:07:05 <lambdabot> I know nothing about hope.
02:07:09 <shapr> @where+ hope http://hope.bringert.net/
02:07:09 <lambdabot> Done.
02:07:11 <lambdabot> Done.
02:07:11 <xerox> Wow!
02:07:34 <xerox> Now you have distracted me completely from what I was doing.
02:07:38 <shapr> sorry!
02:07:46 <xerox> Not too bad.
02:07:49 <shapr> I just wanted to get cabal and cabal-install integrated so I could use them.
02:07:52 <xerox> Electromagnetism isn't _that_ fun.
02:08:14 <xerox> Well, I can't help you right now, sorry ):
02:08:23 <shapr> It is pretty cool, have you seen inductrack?
02:08:28 <Philippa> I dunno, it's fun when you use it to propel small lumps of metal at people you don't like at high velocities
02:08:31 <xerox> Nope, what's that.
02:08:32 <shapr> Do you know about Halbach arrays?
02:08:47 <xerox> No, again!
02:08:55 <shapr> http://en.wikipedia.org/wiki/Halbach_array
02:09:16 <shapr> http://en.wikipedia.org/wiki/Maglev_train#Inductrack
02:09:45 <shapr> Inductrack has much wider uses than just maglev trains, for example, bearings that give more support and less drag as rotation speed increases.
02:10:14 <shapr> Also, I've been thiking about how to build turing machines with inductrack.
02:11:43 <xerox> `It was later discovered by Halbach, who used the arrangement in particle accelerators.'
02:12:01 <xerox> If you are up to work on such things, electromagnetism is surely fun, okay :)
02:16:33 <dons> @hoogle mapReaderT
02:16:33 <lambdabot> Control.Monad.Reader.mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
02:20:24 <shapr> xerox: Inductrack could be used for the magnetic surfboard from back to the future, would that be cool or what?
02:20:49 * xerox falls over and starts dreaming
02:20:58 <astrolabe> I think the theory of electromagnetism is very nice.  Morning all :)
02:21:39 <xerox> Since I found the OCW lectures the topic is getting more palatable, I must say. =)
02:23:13 <xerox> Hope needs some SQL backend installed?
02:23:40 <astrolabe> shapr:  I think you're asshole/saint clicker would need some kind of google-recursive-cleverness to work properly
02:38:37 <BCoppens> @hoogle [a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
02:38:37 <lambdabot> Hoogle Error: Parse Error: Unexpected character '://en.wiki'
02:38:51 <BCoppens> @hoogle [a] -> [ [a] ]
02:38:52 <lambdabot> List.inits :: [a] -> [[a]]
02:38:52 <lambdabot> List.tails :: [a] -> [[a]]
02:38:52 <lambdabot> List.group :: Eq a => [a] -> [[a]]
02:48:46 <integral> @hoogle [[a]]->[[a]]
02:48:47 <lambdabot> List.transpose :: [[a]] -> [[a]]
02:55:28 <xerox> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6]]
02:55:29 <lambdabot> [[1,4],[2,5],[3,6]]
02:56:37 <shapr> astrolabe: probably, yeah
02:56:50 <shapr> xerox: Yes, Hope needs HaskellDB
02:57:04 <shapr> xerox: Do you have a plan on integrating cabal-install?
02:58:00 <shapr> Did you guys see my new unicycle tire? http://www.scannedinavian.com/hope/entry/15 3.7 inches! w00!
02:59:02 <xerox> shapr - Yes, I think so.
02:59:22 <xerox> Hmm.
02:59:33 <xerox> How is it not-integrated now?
02:59:50 <xerox> cabal-get calls it through the binary, instead of using the code itself?
02:59:54 <shapr> er, good question
03:00:27 <shapr> Nah, I mean I want to be able to do cabal-install hope and all the dependencies are updated, rebuilt and reinstalled in the correct order.
03:00:50 <shapr> Not that I've actually used cabal-install enough to know if it already does that.
03:00:52 <xerox> You will do cabal-get hope to do so, if I understand correctly.
03:00:57 <shapr> yeah, I think so.
03:02:16 <pesco> Is John Goerzen here?
03:02:22 * pesco waves to shapr and xerox.
03:02:33 <xerox> Howdy pesco!
03:02:40 <xerox> ?seen CosmicRay
03:02:41 <lambdabot> I haven't seen CosmicRay.
03:03:19 <pesco> Ah! CosmicRay, right. Of course.
03:03:38 * pesco tries to update his nick-realname memory.
03:04:24 <pesco> I just discovered that he's the author of offlineimap, which is promising to endusershell for me wrt. my email.
03:55:27 <shapr> JohnMeacham: Which autoconf are you using for DrIFT? neither 2.13 nor 2.50 seem to work.
04:20:21 <dmhouse> @messages?
04:20:21 <lambdabot> Sorry, no messages today.
04:20:36 <dmhouse> Afternoon all.
04:22:13 <beelsebob_> mathewm: you know that the take (maximum $ map length [xs,ys]) does nothing in that equasion?
04:22:36 <beelsebob_> gyah... stupid bob
04:22:47 <beelsebob_> stupid client that doesn't show the disconnect and reconnect
04:23:38 <dmhouse> maximum $ map length [xs, ys]   ==   max (length xs) (length ys)
04:25:12 <JohnMeacham> shapr: run the 'reconf' script included. autoreconf doesn't work
04:26:07 <dmhouse> or max `attach` length, if you prefer (and have already defined that Ã¼ber-handy attach combinator)
04:31:20 * pesco breaks into manical laughter.
04:40:57 <beelsebob_> dmhouse: indeed, and when it's in front of a zipWith f xs ys, it does fuck all
04:46:25 <nomeata> Hi. I have defined a typeclass Stack and a instance Stack []. As it is the only instance, can I expect haskell to call the instance function even when I only use functions defined in the typeclass?
04:52:17 <Cale> nomeata: You will likely have to add a few type annotations
04:52:34 <Cale> nomeata: It has to be unambiguous which instance to use at compile time.
04:53:02 <Cale> (though you're allowed to make things polymorphic of course -- just that some explicit type has to be applied to actually use the thing)
05:00:33 <nomeata> Cale: How does it work for the constructor "0", which is defined in a typeclass? I can type 0 in ghci, and do not have to type 0::Int...
05:01:09 <Cale> right, that's actually because there's an explicit defaulting mechanism in the spec for numbers
05:01:57 <Cale> Integer is the default Num type, and Double is the default Fractional type. You can change this with a default declaration.
05:02:09 <Cale> (though default declarations only apply to these cases)
05:02:30 <Cale> (sort of obscure :)
05:03:10 <Cale> http://haskell.org/onlinereport/decls.html#sect4.3.4
05:03:17 <nomeata> ok, thanks
05:03:26 <shapr> JohnMeacham: Thanks, trying now
05:17:23 <dropdrive> I need to do some symbolic/algebraic computations, preferably building off some existing computer algebra system.  The only one I can find is DoCon; are there any others out there?
05:19:35 <nomeata> I have a typeclass Stack of kind (*->*). can I define an instance that works only for one "inner" type? something like instance (Stack Int) SpecialStack?
05:37:44 <mahogny> !seen RyanT5000
05:40:47 <nomeata> I have defined a type IStack: IStack :: (Integral n) => n -> IStack n, and now I want to make that an instance of Stack: instance Stack IStack where
05:41:54 <xerox> instance Stack (IStack Int) where ...
05:42:05 <xerox> @seen RyanT500 -- mahogny 
05:42:05 <lambdabot> I haven't seen RyanT500.
05:42:10 <xerox> Err.
05:42:15 <shapr> JohnMeacham: works, thanks!
05:42:19 <mahogny> @seen RyanT5000k
05:42:19 <lambdabot> I haven't seen RyanT5000k.
05:42:21 <mahogny> hmm
05:42:23 <nomeata> xerox: ah, thanks
05:42:27 <mahogny> I keep forgetting his precise nick :P
05:42:29 <mahogny> anyhow
05:42:42 <xerox> @seen RyanT5000
05:42:43 <lambdabot> I saw RyanT5000 leaving #haskell 16 hours, 54 minutes and 39 seconds ago, and .
05:42:44 <nomeata> xeros: hmm, no:     Kind error: Expecting kind `* -> *', but `IStack Int' has kind `*'
05:42:59 <xerox> nomeata - Than instance Stack IStack where .. is correct.
05:43:10 <Lemmih> nomeata: It may not be possible for the same reasons sets aren't functors.
05:43:25 <nomeata> Lemmih: what is that reason?
05:44:42 <nomeata> might it be that an instance T of class C of kind * -> * has to be valid for _all_ inner types for which C is valid?
05:44:44 <Lemmih> nomeata: The methods of Stack most likely have a more general type than the IStack operations.
05:45:26 <nomeata> Lemmih: You are right, they do. I'd like to add an implementation that works only for Integrals. Can't I do that?
05:45:48 <Lemmih> nomeata: It'll work ff you remove the Integral constraint.
05:45:56 <Lemmih> nomeata: Nope.
05:48:34 <nomeata> Just to make sure I got it right: It is not possible to, for example, have a type of the class Monad that only works with values that are Lists of some kind?
05:49:15 <shapr> Is there some way to make darcs pull -a have a non-zero return value when there are no new patches?
05:49:58 <shapr> @get-bringert
05:49:58 <lambdabot> Unknown command, try @list
05:50:00 <shapr> @seen bringert
05:50:00 <lambdabot> I haven't seen bringert.
05:50:03 <shapr> foo
06:15:43 <ihope> So how's this ANSI scrolling thing work?
06:16:38 <ihope> If I turn scrolling on for everything but the bottom row, what happens?
06:29:25 * ihope_ gets an idea
06:35:38 <xerox> ?where fps
06:35:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
06:42:45 <ihope_> "Fui embora"? Is that Portuguese?
07:02:15 <xerox> fps is hardcore code.
07:02:33 <dons> ;)
07:04:37 <xerox> You read it, and it has everything, from strictness annotations to haddock-doc comments passing through unsafePerformIO code.
07:05:26 <xerox> ...and GHC annotations and precompiler directives...
07:05:37 <dons> heh
07:05:53 <dons> its had many many hours of work on it over the last 6 months
07:06:02 <dons> i don't want to ponder how many hours
07:06:13 <xerox> So dense =)
07:06:18 <ihope_> FPS uses unsafePerformIO?
07:06:46 <dons> ihope_: sure. 
07:06:55 <ihope_> Scary.
07:07:00 <dons> so that we can do peek and poke underneath, while presenting a pure interface
07:07:07 <xerox> Right. But nobody notices or everybody pretend to not to ;)
07:07:08 <dons> its fine, though.
07:07:13 <xerox> (Just kidding)
07:07:16 <ihope_> safePerformIO?
07:07:24 <xerox> Indeed.
07:07:31 <dons> its the kind of use that unsafePerformIO was invented for.
07:07:33 <ihope_> safePerformIO :: IO a -> IO a? :-P
07:10:20 <dons> xerox: are you using fps in a project?
07:10:32 <xerox> inits :: ByteString -> [ByteString]
07:10:33 <xerox> inits (PS x s l) = [PS x s n | n <- [0..l]]
07:10:37 <xerox> Superb!
07:10:58 <xerox> dons, I am just reading it for now
07:15:27 <xerox> Is there a way to delete all that is not part of a darcs repo, in a darcs repo?
07:15:57 <xerox> Well, nm.
07:16:16 <Igloo> darcs getting it would be the easiest way
07:16:53 <Igloo> Well, actually, just copy _darcs/current/
07:17:00 <xerox> Agreed. But then I noticed pugs' is an svn one, sigh.
07:30:59 <mnislaih> @seen Lemmih
07:30:59 <lambdabot> Lemmih is in #haskell-overflow, #haskell-blah and #haskell. I last heard Lemmih speak 1 hour, 45 minutes and 3 seconds ago.
07:31:25 <mnislaih> Lemmih there ?
07:32:31 <Lemmih> Oh hi.
07:33:35 <_frederi1_> hello
07:33:38 <_frederi1_> let (myapp :: forall a b. (a->b)->a->b) = (\ f x -> f x)
07:33:45 <_frederi1_> why does this not work in ghci?
07:34:00 <_frederi1_>     The lambda expression `\ f x -> ...' has two arguments,
07:34:00 <_frederi1_>     but its type `forall a b. (a -> b) -> a -> b' has only 0
07:35:08 <_frederi1_> (i count 2 arguments in the type)
07:35:18 <xerox> ?type \f x -> f x
07:35:19 <lambdabot> forall t t1. (t -> t1) -> t -> t1
07:35:45 <xerox> ?type let (g :: forall a b. (a -> b) -> a -> b) = f x -> f x in g
07:35:46 <lambdabot> parse error on input `->'
07:36:00 <Lemmih> _frederi1_: 'let x :: t = exp' is different from 'let x :: t; x = exp'
07:36:02 <xerox> ?type let (g :: forall a b. (a -> b) -> a -> b) = \f x -> f x in g
07:36:03 <lambdabot> The lambda expression `\ f x -> ...' has two argumentss,
07:36:03 <lambdabot> but its type `forall a b. (a -> b) -> a -> b' has none
07:36:13 <xerox> Right.
07:36:28 <xerox> The latter is equivalent to let `x = exp :: t'.
07:36:43 <_frederi1_> and the former is equivalent to what?
07:36:54 <Lemmih> > let x a :: Int = a+1 in x 10
07:36:54 <lambdabot> Parse error
07:36:58 <Lemmih> Bah.
07:37:02 <Lemmih> Stupid parser.
07:37:11 <xerox> It worked!
07:37:15 <xerox> Sigh.
07:37:29 <xerox> Ah, strange one, that one.
07:38:55 <xerox> `$ try time sudo nice port install gtk2' What a commandline.
07:39:44 <_frederi1_> what is try?
07:40:38 <xerox> It tells me `succeeded' when the command returns true, and `failed' when it returns false.
07:40:50 <xerox> (Via the speakers :)
07:41:47 <_frederi1_> oh.
07:42:49 <_frederi1_> so why does ($) not work for second-order polymorphism sometimes?
07:43:04 <xerox> ?type flip ($)
07:43:06 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
07:43:23 <_frederi1_> i'm trying to find a portable example...
07:43:24 <xerox> Well, higher-order-polymorphism doesn't "work" in general.
07:43:55 <_frederi1_> xerox: what are you saying?
07:45:53 <xerox> GHC doesn't like it very much.
07:47:20 <_frederi1_> > let f :: (forall a . a -> a) -> b -> b; f i x = i x in (f $ id) ()
07:47:21 <lambdabot> Parse error
07:47:28 <_frederi1_> um
07:47:52 <_frederi1_> anyway if you put that into ghci it says "Inferred type is less polymorphic than expected"
07:48:12 <_frederi1_> but "let f :: (forall a . a -> a) -> b -> b; f i x = i x in (f id) ()"
07:48:14 <_frederi1_> works
07:48:31 <_frederi1_> and "let f :: (b -> b) -> b -> b; f i x = i x in (f $ id) ()" works as well
07:48:55 <_frederi1_> so i'm trying to explain the problem with using "$" in a paper i'm writing
07:49:17 <_frederi1_> i will acknowledge you if you can give me a good explanation :)
07:50:08 <_frederi1_> no one's jumping at my offer :)
07:55:58 <xerox> I can't realize how to do this...
07:56:40 <xerox> I have to spawn processes and wait for them to finish
07:57:07 <xerox> It seems that getProcessStatus blocks *all* the threads, not only the one in which it is ran
08:01:23 <xerox> forkOS ?
08:03:38 <Igloo> The docs say it calls waitpid, so it'll block all threads in the current process
08:04:41 <xerox> Right.
08:04:56 <xerox> I wonder if the problem is already solved somewhere so that I can use a more general abstaction.
08:06:48 <kpreid_> any ideas for improving the readability of 'mapM (\(k,x) -> x >>= \v -> return (k, v))' besides @pl?
08:07:29 <_frederi1_> @pl? there is do-notation
08:07:29 <lambdabot> there is do - notation
08:07:48 <kpreid_> oh, yes, sorry
08:07:54 <integral> @pl (\(k,x) -> x >>= \v  -> return (k, v))'
08:07:55 <lambdabot> (line 1, column 39):
08:07:55 <lambdabot> unexpected "'"
08:07:55 <lambdabot> expecting variable, "(", operator or end of input
08:08:02 <integral> @pl (\(k,x) -> x >>= \v  -> return (k, v))
08:08:02 <lambdabot> uncurry (fmap . (,))
08:08:09 <kpreid_> I wrote it without do-notation when I tried to find what @pl provided, which was ...worse
08:08:10 <xerox> forkOS works, it seems.
08:08:12 <xerox> \o/
08:08:31 <xerox> (Programming over the telephone is so nineties.)
08:08:51 <_frederi1_> xerox: why not use getAnyProcessStatus?
08:09:54 <_frederi1_> so no one knows why ($) is second-order-polymorphism-unfriendly...
08:12:19 <xerox> Do you know of something second-order-plymorphism-friendly?
08:12:43 <kpreid_> The documentation for Data.Map sas "This module is intended to be imported qualified, to avoid name clashes with Prelude functions. eg. import Data.Map as Map". When I do that, GHC complains of "Ambiguous occurrence `map' ... either `GHC.Base.map', imported from List ... or `Data.Map.map' ...". Did I miss a step?
08:13:18 <MarcWebe1> What is the status of cabal-install?
08:13:29 <_frederi1_> xerox: no, but not knowing doesn't increase my understanding
08:13:33 <xerox> kpreid_: First you have to`You need to refer it with the qualified name.
08:13:35 <xerox> Err
08:14:01 <xerox> First you have to `import qualified Data.Map as M', then you have to refer the functions with the qualified `M.name' name.
08:14:16 <kpreid_> Oh, so the documentation is missing the word "qualified"
08:15:17 <xerox> kpreid_: err, no.
08:15:25 <xerox> Hmm..
08:15:29 <xerox> Well, yes.
08:15:54 <xerox> The point is that once you use `qualified' and 'as X' you can't omit the 'X.'
08:16:03 <kpreid_> yes, I understand that
08:16:17 <xerox> Right.
08:16:23 <kpreid_> but the Data.Map documentation didn't mention 'qualified'
08:16:31 <xerox> Well, right.
08:16:40 <kpreid_> it just said 'import Data.Map as Map' which is insufficient to avoid name clashes
08:17:04 <kpreid_> or rather, insufficient to make the compiler happy, regardless of how those names need to be referred to
08:17:06 <xerox> Well, wether it is sufficient or insufficient depends on the context in where it is done.
08:17:09 <waern_>  'import Data.Map as Map' which is insufficient to 
08:17:09 <waern_>                  avoid name clashes
08:17:17 <waern_> oops, sorry
08:17:37 <kpreid_> xerox: can you give an example where it would be sufficient?
08:17:44 <kpreid_> oh
08:17:55 <xerox> In a namespace where Map functions aren't defined
08:17:58 <kpreid_> if I always wrote List.map or Prelude.map ...
08:18:20 <xerox> That, too
08:18:59 <xerox> How do you translate      2073.87 real       600.14 user       686.59 sys
08:19:03 <xerox> 2073 secs?
08:19:13 <xerox> > 2073 / 60
08:19:14 <lambdabot> 34.55
08:25:07 <xerox> shapr - How's it going with Haskellnet?
08:25:26 <_frederik_> what is Haskellnet?
08:26:36 <xerox> A project which aims to collect a series of well-written-and-tested implementation of protocols in one easy-to-install Haskell package.
08:27:26 <_frederik_> why?
08:27:57 <xerox> Because what we have no is either incomplete, or duplicated, or non-existent.
08:28:02 <xerox> s/no/now/1
08:29:15 <_frederik_> how do you test a low-level protocol, such as TCP, in a slow language such as Haskell?
08:29:30 <_frederik_> if it should be well-tested, then presumably speed is a concern
08:31:18 <integral> haskell is slow? o_O
08:32:39 <_frederik_> hehe yes it is
08:32:50 <xerox> No way.
08:33:10 <xerox> You _can_ write slow code, as you can in every language, but that is not the point.
08:33:49 <integral> a haskell TCP/IP stack would definately outperform my perl one
08:34:00 <_frederik_> ok, but would it be clearer?
08:34:28 <_frederik_> presumably clarity is important as well, no?
08:34:55 <xerox> Sure, and it would also be safe.
08:35:32 * pesco holds up a sign reading "Moot Discussion".
08:35:47 <_frederik_> in my experience, the contortions haskell demands for decent speed make the code quite unreadable. and i've had very simple programs which executed much faster in perl, and much more legibly
08:37:42 <pesco> in my experience, the contortions perl demands make the code quite unreadable. and i've had very simple programs which executed much faster in perl, and much more legibly
08:37:58 <pesco> Damn, forgot to replace tha last perl with Haskell.
08:38:02 <_frederik_> hehe
08:38:04 <xerox> configure.ac:117: error: possibly undefined macro: AC_MSG_ERROR
08:38:04 <xerox>       If this token and others are legitimate, please use m4_pattern_allow.
08:38:11 <xerox> Any idea of what it does mean?
08:38:20 <_frederik_> well i'll be curious to see the result
08:41:29 <pejo> xerox, wrong version of autoconf?
08:41:49 <xerox> dnl * We require autoconf version 2.59
08:41:49 <xerox> AC_PREREQ(2.59)
08:42:00 <xerox> $ autoconf -V
08:42:00 <xerox> autoconf (GNU Autoconf) 2.59
08:42:04 <xerox> Seems like it is the right one.
08:43:01 * ptolomy hates autotools, mostly.
08:43:10 <pejo> xerox, http://tunes.org/~nef/logs/haskell/05.11.04, search for AC_MSG_ERROR :-)
08:44:19 <pejo> xerox, autoreconf seems to be the way to hack around it, reading a few lines below in that log.
08:45:19 <xerox> Hmm.
08:45:40 <xerox> autoreconf gives that error.
08:51:03 <xerox> Maybe the problem is OS X autotools
08:51:09 <xerox> I'll try installing GNU ones
08:52:14 <xerox> Oh yeah! :)
09:15:51 <_frederik_> has there ever been a proposal for subtypes in Haskell? i.e. so Int could be converted to Integer or Double automatically?
09:19:52 <pejo> _frederik_, there has been research done on polymorphic subtyping. I think one of Pierce's grad students is one of them, for example.
09:20:31 <_frederik_> there is quite a bit about it in his book
09:20:58 <_frederik_> i think it would make the stuff i'm doing with linear algebra much cleaner
09:22:00 <pejo> _frederik_, happen to have a chapter reference handy?
09:24:09 <_frederik_> 15, 16, 17, but if you were emphasizing the "polymorphic" then i don't know if these qualify
09:32:18 <MarcWebe1> Where can I find Data.FastPackedString? It's not in the fps package ,  I want to try out HAppS.
09:33:24 <ndm> @where fps
09:33:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
09:33:42 <ndm> old versions of that were called fast packed string, so you'll have to find out which version happs wants
09:34:10 <Dino__> Why do some commands to lambdabot require ? and others seem to be prefixed with @  ?
09:34:16 <ndm> ?where fps
09:34:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
09:34:20 <ndm> @where fps
09:34:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
09:34:28 <ndm> :where fps
09:34:39 <ndm> >1+2
09:34:50 <ndm> > 1 + 2
09:34:56 <lambdabot> 3
09:35:10 <Dino__> @eval 1 + 2
09:35:12 <ndm> Dino__: it accepts a variety of chars, but > is special for execute haskell
09:35:29 <ndm> although it seems a space is required after the >
09:35:40 <Dino__> I see, the @ || ? is to let it know a command is happening.
09:36:09 <ndm> yes, so it doesn't try and accidentally process everyones messages as commands
09:49:29 <petekaz> What's the easiest way to ensure that a string starts with a '/' character?
09:50:48 <petekaz> I'm doing this:
09:50:57 <petekaz> > case "pete" of { '/':r -> '/':r; r -> '/':r }
09:50:57 <shapr> xerox: It's going
09:50:58 <lambdabot> "/pete"
09:51:05 <petekaz> > case "/pete" of { '/':r -> '/':r; r -> '/':r }
09:51:06 <lambdabot> "/pete"
09:51:14 <Kasperle> startswithslash x:xs = (x == '/')
09:51:43 <petekaz> I don't care about testing it ... I just want it to happen in as few lines as possible.
09:52:29 <petekaz> The case statement above seems works fine, is there a more idiomatic way?
09:56:27 <ndm> slashify x = ['/' | not $ "/" `isPrefixOf` x] ++ x
09:56:34 <ndm> petekaz: thats the best i can come up with
09:57:12 <petekaz> thanks.
09:58:26 <kpreid_> if the expression after case is a variable, you can use it in the first alternative instead of '/':r, or an as-pattern: x@('/':r) -> x
09:58:44 <kpreid_>  x@('/':_) -> x
09:59:40 <petekaz> kpreid_: thanks ... I knew something like that existed, just couldn't find the syntax in YAHT.
10:01:28 <petekaz> so my two case statements look like this now:
10:01:33 <petekaz>                    url@('/':_) -> url
10:01:33 <petekaz>                    url         -> '/':url
10:01:57 <petekaz> is it poor form to use 'url' variable in both lhs of the case statement?
10:02:14 <petekaz> or should I rename the second to 'url_noslash'
10:02:40 <kpreid_> let url = ... in case url of { '/':_ -> url; _ -> '/':url }
10:03:44 <petekaz> ok, got it.
10:03:46 <petekaz> thanks.
10:05:20 <MarcWebe1> In which package is the module Monad?
10:05:36 <ndm> MarcWebe1: haskell98
10:05:43 <ndm> you should now use Control.Monad, I think
10:06:07 <kpreid_> petekaz: or, if it's a top-level function: slashify url@('/':_) = url; slashify url = '/' : url
10:07:36 <MarcWebe1> Could have guessed it. thanks.
10:42:39 <shapr> shazam!
10:46:23 <_frederik_> it's not possible to use splices in type signatures, right?
10:46:34 <_frederik_> i mean template haskell splices
10:47:54 <shapr> I saw a discussion about lazy reads not being referentially transparent unless the file system saves a copy of the file as it was when opened by that handle. Does anyone know where that discussion was?
10:49:41 <LordBrain> Anyone here have experience with OOHaskell?
10:49:48 <LordBrain> i'm reading about it now
10:50:38 <_frederik_> LordBrain: i think i read about it but never was impressed enough to use it
10:50:51 <shapr> I just don't see the need for OO :-)
10:51:03 <LordBrain> its interesting tho
10:51:10 <shapr> Yeah, it's way cool.
10:51:47 <ndm> shapr, i think i saw that on haskell/haskell-cafe
10:52:06 <shapr> Any idea of the thread title?
10:52:10 <ndm> but i remember the topic for the email was way off :)
10:52:11 * shapr surfs haskell-cafe
10:52:35 <ndm> just taking a look, its not that long ago
10:52:46 <LordBrain> my question is, do we trade off somewhat when we use the oo paradigm, are we loosing some of the advantages of functional programming in general?
10:53:07 <LordBrain> or, do we get the best of all worlds?
10:53:15 <ndm> shapr "xml tools in fp?"
10:53:18 <ndm> thats hte title, no wonder its so hard to find
10:54:16 <shapr> ndm: oh yeah
10:54:18 <shapr> thanks!
10:54:22 <shapr> I saw it on the libraries list.
10:54:32 * shapr wants to write about referential transparency and filesystems in his blog
10:54:33 <_frederik_> LordBrain: i don't know about OOHaskell, but i think in Haskell the benefits of the "oo paradigm" are split into modules for namespace partitioning and type classes for "virtualization". but i'd have to look at the paper to give a better answer
10:54:45 <ndm> ah yes, i have them all filed in one haskell folder in gmail
10:55:11 <LordBrain> well, if you're interested, this is what i'm reading http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf
10:56:07 <LordBrain> i'm only like on the fourth page of the pdf
10:56:27 <LordBrain> i was just curious if someone had some insight from experience with it
10:56:32 <xerox> > 2/pi
10:56:33 <lambdabot> 0.6366197723675814
10:58:21 <shapr> I really wish I could track down Ronald W. Doerfler's email address. I'd like to ask why he hasn't done any base switching in his Dead Reckoning book.
11:01:17 <_frederik_> LordBrain: oh dear. that's very long. well, i like the authors, but the topic isn't terribly interesting to me at first glance
11:01:43 <_frederik_> LordBrain: i liked the HList paper, though, if you haven't read that it might be a better place to start
11:05:16 <LordBrain> ok
11:05:29 <LordBrain> how long is the HList paper?
11:06:17 <LordBrain> 15 pages..
11:06:49 <LordBrain> maybe i should just have them both printed
11:07:47 * shapr just sticks papers onto his Nokia 770 and reads them on the bus
11:16:42 <MarcWebe1> xerox: Thanks. HAppS wants to have the module Data.FastPackedString which isn't exposed by fps.cabal. Do you know where I can get it?
11:17:31 <ndm> MarcWebe1: i suggest you try an older version of fps
11:17:38 <ndm> since its now called Data.ByteString
11:17:47 * xerox nods
11:18:27 <MarcWebe1> Did the interface change or can I just rename the module?
11:18:30 <MarcWebe1> Or I
11:18:46 <MarcWebe1> 'll try a older version and add a version to the dependencies..
11:18:50 <shapr> The interface changed a bit.
11:18:52 <xerox> I suspect it didn't change much
11:19:13 <xerox> If you have time, an updating patch would be very much welcome, I think ;)
11:29:04 * shapr boings distractedly
11:29:28 <shapr> Anything exciting happening?
11:30:14 <Igloo> Indubitably
11:31:43 <kpreid_> shapr: I'm making good progress with my e-in-haskell!
11:31:45 <shapr> yay!
11:31:50 <shapr> Good to hear
11:32:06 <ndm> I almost have a demo of Catch ready
11:32:21 <ndm> which detects pattern match errors statically
11:32:24 <ndm> or their absence
11:32:49 <kpreid_> shapr: I got ==, queued sends, auditing working
11:33:01 <ricebowl> any easy/clever way to do a comparison of two Maybe a's? i.e. returns true only if both are Just x and both x's are equal...
11:33:30 <ricebowl> without having to do something verbose like binding them in a case and inspecting the values
11:33:38 <ndm> ricebowl: isJust x && x == y ?
11:33:39 <ricebowl> since that's what I have now, and I was hoping to make the code easier to read :P
11:33:50 <ricebowl> no, I have *two* Maybe's
11:34:00 <ndm> ricebowl: yes...
11:34:02 <palomer> instance Eq (Maybe a) where Maybe a == Maybe b = a == b; _ == _ = False
11:34:04 <ricebowl> oh, hmm, Maybe has == defined?
11:34:10 <ricebowl> d'oh
11:34:12 <ricebowl> thanks :P
11:34:20 <ricebowl> thought there'd be an easy way to do it
11:34:50 <palomer> but, like, instantiating things like this can be dangerous
11:37:27 <ricebowl> ?
11:41:15 <palomer> > Just 2 == Just 3
11:41:16 <lambdabot> False
11:41:25 <palomer> Maybe a is already an instance of Eq
11:41:49 <ricebowl> I wasn't trying to make another instance of Eq
11:41:52 <ricebowl> I just didn't think to use == on them
11:41:58 <kpreid_> @pl \a b -> fromMaybe False (a >>= \a' -> b >>= \b' -> return (a' == b'))
11:41:58 <lambdabot> (fromMaybe False .) . liftM2 (==)
11:42:00 <ricebowl> but it works out to be more complicated anyway
11:44:31 <xerox> > let palyndrome = ap (==) reverse in palyndrome "racecar"
11:44:32 <lambdabot> True
11:45:33 <kpreid_> ricebowl: note that Nothing == Nothing is True, whereas your original request was for returning false then
11:47:04 <ricebowl> I see
11:48:27 <kpreid_> fromMaybe False (liftM2 (==) a b) will do that
11:48:49 <palomer> you can't have 2 instances of a typeclass
11:48:52 <palomer> so my way doesn't work
11:51:18 <ricebowl> palomer - ah, I thought you were stating fact, not making a suggestion... but anyway...
11:51:26 <ricebowl> it turns out that I needed a much more complicated expression
11:51:35 <kpreid_> shapr: would you be interested in looking at the EoHS code, /not/ to tell me how to make ST work but to check for readability?
11:51:47 <kpreid_> (well, anyone)
11:51:50 <ricebowl> I wrote a (small) decompiler in Haskell
11:53:30 <nomeata> :t ap
11:53:40 <palomer> let Just a ==== Just b = a ==b ; _ ==== _ = False in Just 2 ==== Just 3
11:53:45 <palomer> > let Just a ==== Just b = a ==b ; _ ==== _ = False in Just 2 ==== Just 3
11:53:46 <lambdabot> False
11:54:20 <nomeata> @t ap
11:54:21 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
11:54:30 <nomeata> @type ap
11:54:31 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
11:58:30 <nomeata> xerox: if I type let palyndrome = Monad.ap (==) reverse in palyndrome "racecar"   in ghci, I get an error: No instance for (Monad ((->) [Char])). what did you do there?
11:59:40 <palomer> @type ap
11:59:42 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
11:59:55 <palomer> @type reverse
11:59:57 <lambdabot> forall a. [a] -> [a]
12:00:26 <palomer> @type ==
12:00:27 <lambdabot> parse error on input `=='
12:00:30 <palomer> @type (==)
12:00:31 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:00:56 <palomer> ok, you need to lift (==)
12:01:01 <palomer> @type lift (==)
12:01:02 <lambdabot> forall (t :: (* -> *) -> * -> *) a. (MonadTrans t, Eq a) => t ((->) a) (a -> Bool)
12:01:08 <palomer> @type liftM (==)
12:01:10 <lambdabot> forall a1 (m :: * -> *). (Monad m, Eq a1) => m a1 -> m (a1 -> Bool)
12:01:30 <palomer> yeah, that code doesn't typecheck on so many levels
12:02:08 <nomeata> what code doesnt?
12:03:02 <palomer> let palyndrome = Monad.ap (==) reverse in palyndrome "racecar"
12:03:39 <palomer> check the types:
12:03:48 <palomer> @type ap
12:03:49 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
12:03:50 <palomer> @type (==)
12:03:52 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:04:16 <palomer> now, is a -> a -> Bool an instance of m (a -> b) -> m a -> m b ?
12:05:47 <nomeata> no, but why does it work here in the channel, as it did for xerox
12:06:05 <nomeata> > let palyndrome = ap (==) reverse in palyndrome "racecar"
12:06:06 <lambdabot> True
12:09:40 <nomeata> > let palyndrome = ap (==) reverse in palyndrome "noracecar"
12:09:42 <lambdabot> False
12:18:25 <kpreid_> What would you call this function?
12:18:30 <kpreid_> \f (a, b) -> do a' <- f a; b' <- f b; return (a', b')
12:19:43 <shapr> kpreid_: Sure, where is it?
12:22:00 <kpreid_> for the moment, http://homepage.mac.com/kpreid/temp/e.lhs
12:22:10 <kpreid_> (I was using lisppaste but it's down at the moment)
12:28:10 * shapr swears at Python and its stupidity
12:28:39 <shapr> Ok, I'm really swearing at predicates that must be strings in input and get turned into lambdas. If I could put in my own lambdas I could do negation.
12:28:44 * shapr fugly hacks around the stupid code.
12:30:42 * kpreid_ has to go now
12:32:08 <shapr> kpreid_: I'll check it out later
12:33:45 <kpreid_> sure
12:36:22 <xerox> nomeata: you have to import Control.Monad.Reader
12:36:42 <xerox> kpreid_: liftM2 partially curried
12:37:00 <xerox> Who's next!
12:37:51 <kpreid_> xerox: liftM2PartiallyCurried is a bit clunky
12:37:57 <xerox> hehe
12:38:32 <kpreid_> the use is "a' <- f op a" in a messy equality function (thus lots of working with the two things being compared, or their properties)
12:38:45 <kpreid_> I'm calling it 'mapM2' for the moment, which is Wrong
12:38:47 * kpreid_ really goes
12:38:54 <xerox> ((>>= f) *** (>>= f))
12:39:32 <xerox> ap ((***) . (>>=)) (>>=)
12:39:48 <xerox> ?pl \f -> ((>>= f) *** (>>= f))
12:39:49 <lambdabot> liftM2 (***) (=<<) (=<<)
12:39:51 <xerox> Err.
12:39:52 <xerox> Nice.
12:40:21 <xerox> ?type liftM2 (***) (=<<) (=<<)
12:40:22 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> m b) -> (m a, m a) -> (m b, m b)
12:47:19 <gadolin> hey, does someone know about good page with sample haskell problems
12:47:24 <gadolin> ?
12:47:56 <gadolin> i would like to train a little bit befor tomorrows exam
12:47:58 <gadolin> :)
12:51:53 <ndm> gadolin: powerset, pascals triangle
12:52:05 <ndm> write a function to do both of those in haskell
12:52:15 <gadolin> k
12:52:38 <gadolin> thanks
12:54:50 <ndm> unfortunately the York Uni series of haskell exercises is york students only, thats one of the best set of progressively harder problems I've seen...
12:55:55 <gadolin> pity that
12:56:04 * gadolin thinks about powerset
12:56:11 <gadolin> it's incredibly easy in prolog
12:56:27 <gadolin> but somewhat more thought-inducing in haskell
13:11:34 <sam_> i just installed couple of 'cabalized' modules. now that i'm trying to write a program that uses them, gch is saying "Failed to load interface for `HTTP':".. Do I, in general, need to give ghc some library paths or something, or what gives?
13:13:23 <eivuokko> If you don't use --make, you need to say which packages are enabled with -package option, something like -package foo
13:14:13 <eivuokko> You might also want to check that packages are really available with ghc-pkg command.
13:19:24 <thetallguy> Hmm... I don't see why powerset is any harder in Haskell
13:20:41 <gadolin> thetallguy: it's a bit of the context switching that's hard
13:20:47 <gadolin> between the two languages
13:21:40 <thetallguy> Well, I never bothered to become proficient in Prolog, so I'll have to take your word for it.
13:22:22 <thetallguy> Given the right understanding of powersets, the implementation is easy.
13:23:05 <thetallguy> Without that, I don't know.
13:23:52 <greenrd> @paste
13:23:53 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:24:11 <gadolin> I do understand the powerset, I do have an idea how to do it, now I need to write it in correct and accepted haskell
13:25:10 <nomeata> is there a way to import a module while running ghci? > import Monad does not work: <interactive>:1:0: parse error on input `import'
13:25:45 <thetallguy> :m +Module.Path
13:25:58 <thetallguy> :help
13:26:22 <thetallguy> You can add/remove any number with +/- prefix
13:26:28 <thetallguy> they will show up in your prompt.
13:26:46 <thetallguy> If you have a lot, then create a file that does the import and do :load file.hs
13:27:05 <thetallguy> gadolin: cheers
13:27:20 <nomeata> ah, ok. I knew :m, but I thought it was more a "switch into that file" than an "import" command, because of the prompt. thanks for clarifying that.
13:27:23 <xerox> ?foldoc powerset
13:27:25 <lambdabot> *** "powerset" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
13:27:25 <lambdabot> powerset
13:27:25 <lambdabot>  
13:27:25 <lambdabot> <mathematics> The powerset of a set S is the set of possible
13:27:25 <lambdabot> subsets of S, usually written PS.
13:27:27 <lambdabot> [3 @more lines]
13:27:34 <xerox> ?more
13:27:34 <lambdabot>  
13:27:34 <lambdabot> (1994-11-08)
13:27:34 <lambdabot>  
13:30:29 <greenrd> Why does ghc say "Illegal polymorphic or qualified type: forall a1. a a1 -> g a1 a1" for this code:
13:30:30 <greenrd> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:30:52 <greenrd> Is "forall" not allowed at all in method declarations?
13:31:24 <greenrd> (I'm referring to the first code snippet on that page)
13:36:30 <greenrd> Oh, I get it
13:36:43 <greenrd> "There is one place you cannot put a forall: you cannot instantiate a type variable with a forall-type. So you cannot make a forall-type the argument of a type constructor."
13:41:44 <greenrd> d'oh - using a type symonym to hide it doesn't help
13:44:32 <greenrd> ah, but using a data constructor does :)
13:59:38 <ihope_> So is 80x25 or 80x24 the more common terminal size?
13:59:57 <ihope_> I thought it was 80x25, but then something made me think it was 80x24.
14:00:10 <SamB> I believe 80x25 is the IBM PC and 80x24 is the DEC stuff
14:00:12 <jer> it is 80x25
14:00:45 <jer> (though 24 lines may only be visible on some even though their resolution is actually 80x25 too (i.e., linux console))
14:01:40 <SamB> (the DEC stuff being the VT 100 and such)
14:01:46 <ihope_> Is there an ANSI escape code that asks for the term size?
14:01:54 <jer> ihope_, no
14:02:04 <ihope_> Oh.
14:02:15 <SamB> xterm seems to default ot 80x24
14:02:24 <mauke> curses can do it so there's probably a ioctl for it
14:05:30 <ihope_> So... are there any *other* IRC clients in Haskell?
14:12:03 <stepcut> ihope_: you could probably write one that used gtk2hs in a weekend
14:12:21 <ihope_> This weekend? :-)
14:12:22 <gadolin> @paste
14:12:23 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:12:38 <ihope_> That'd give me about 5 hours...
14:13:04 <stepcut> ihope_: you could probably get something that could chat on #haskell in 5 hours
14:13:32 <ihope_> I could get something that could join #haskell in... soon.
14:13:40 <SamB> ihope_: you are of course supposed to start at the *beginning* of the weekend
14:17:41 <ihope_> Hey, I could write a bot from the bottom up, as they say...
14:19:23 <vincenz> WOW
14:19:29 <ihope_> ?
14:19:36 <vincenz> damn good day today
14:26:05 <greenrd> I've had a good day today as well - I've worked out how to reify functions at the type level in Haskell
14:26:28 <greenrd> I already knew how to reify values of ground types at the type level
14:27:19 <ihope_> The POSIX regex /PING :?\(.*\)\.freenode\.net/ will match an IRC PING and return the server?
14:28:31 <ndm> I've also had a good day, I figured out how to write a subtype checker for haskell (for limited subtypes)
14:28:52 * ihope_ wonders if his new bot will work
14:29:09 <vincenz> ndm: checker or inference?
14:29:20 <stepcut> ihope_: if you want to do a bot, make sure to read the FAQs on that
14:29:29 <ndm> vincenz: both
14:29:35 <ihope_> What FAQ's?
14:29:38 <vincenz> ndm: nice
14:29:54 <ndm> kind of, its a limited set of subtypes, so inference == checking all combinations
14:30:06 <vincenz> so it's post linking?
14:30:11 <vincenz> or singlemodule?
14:30:20 <ndm> vincenz: single module
14:30:24 <stepcut> ihope_: there are some guidelines for writing bots that will prevent bots from accidently talking to each other flooding the channel in an endless loop and stuff ;)
14:30:29 <ndm> at the moment, but that could be fixed relatively easily
14:30:37 <vincenz> :)
14:30:39 <vincenz> anyways
14:30:40 <ndm> now head has a safe type :)
14:30:42 * vincenz off to sleep
14:30:47 <ihope_> Well, my bot doesn't say anything, so unless a PONG triggers a PING, I'll be safe.
14:30:54 <vincenz> ndm: head is good :P
14:31:10 <ndm> vincenz: #haskell-blah talk :)
14:31:57 * ihope_ waits
14:32:49 <ihope_> Whoopsie...
14:32:57 <vincenz> daysie?
14:33:44 <ihope_> Well, it got that far, anyway.
14:34:16 <vincenz> blegh, gotta rewrite my language a bit to add case-statements :(
14:34:18 <ihope_> What could be causing that?
14:34:28 <vincenz> and some how figure out how to make my typechecker only allow first order stuff
14:34:38 <vincenz> :/
14:35:19 <stepcut> ihope_: hrm, this is the best I can find at the moment -- see section 1-31, http://www.faqs.org/faqs/irc/undernet-faq/part1/
14:38:49 <ihope_> "[Bots] should use NOTICES to communicate with the rest of the world, and not reply to NOTICES they get."
14:39:18 <ihope_> But now nobody ever uses NOTICES, ever...
14:43:55 <SamB> ihope_: dons tried once!
14:44:05 <SamB> but it didn't work right with the IRC clients
14:44:12 <SamB> blame the client authors!
14:44:19 <ihope_> I already do!
14:44:24 * ihope_ sighs
14:55:16 <stepcut> :p
14:55:50 <ihope_> "gaim considers notices to be personal messages; there is no known workaround at this time."
14:56:01 <astrolabe> Is there a way to get lambdabot to tell me the fixity of '!'?
14:56:16 <ihope_> @fixity !
14:56:17 <lambdabot> Unknown command, try @list
14:56:21 <ihope_> Attarently not.
14:56:30 <astrolabe> hmmm
14:56:38 <astrolabe> @list
14:56:38 <lambdabot> list [module|command]. Where modules is one of:
14:56:39 <lambdabot> babel base compose dice dict djinn drhylo dummy elite fact fresh haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system tell
14:56:39 <lambdabot> todo topic type unlambda version vixen where
14:56:57 <astrolabe> @slap lambdabot
14:56:57 * lambdabot beats up lambdabot
14:57:11 <ihope_> It doesn't seem to have a fixity...
14:58:49 <palomer> @palomer
14:58:50 <lambdabot> Hrmph, looks like I killed the channel
14:59:35 <LordBrain> hmmm i need to know more about multi-parameter classes and functional dependencies. I'm trying to understand the following code> class HAppend l l' l'' | l l' l''
14:59:59 <LordBrain> In particular, l is a type-level function... it's also itself a type?
15:00:01 <palomer> understanding functional dependencies is not for mere mortals
15:00:06 <astrolabe> That is impressively cryptic
15:01:23 <LordBrain> oooh
15:01:24 <ihope_> Apr 2 2005 -> Apr 13.
15:01:28 <LordBrain> i miss typed it
15:01:36 <LordBrain> i meant to say:
15:01:52 <LordBrain> class HAppend l l' l'' | l l' -> l''
15:02:26 <LordBrain> better?
15:03:00 <LordBrain> i'm thinking that | symbol can be read "such that"
15:03:32 <ihope_> Oh, I don't think the stuff after the | matters :-P
15:03:34 <ihope_> <lambdabot> [58801 @more lines]
15:04:00 <LordBrain> i'm reading the paper on HLists
15:04:03 <stepcut> ihope_: hahah
15:04:42 <Lemmih> LordBrain: Interested in the meaning or the terminology?
15:05:04 <LordBrain> both, meaning first i guess
15:05:26 <LordBrain> i want to understand, can something be both a type and a function which acts on types?
15:06:18 <LordBrain> the whole definition to HAppend is as follows
15:06:26 <ihope_> You'd need kindclasses for that :-P
15:06:38 <LordBrain> class HAppend l l' l'' | l l' -> l'' where hAppend :: l -> l' -> l''
15:07:29 <sam_> simple syntax q.. i thought the 'let' expression always had the form "let ... in ...", but I keep seeing it used without "in".. but when trying it out, i always seem to get compiler errors regarding incorrect indentation.. can anyone give me some clarifying examples or point me to something that describes their ue
15:07:31 <sam_> use
15:07:51 <LordBrain> sam_: inside a do block, you dont need "in"
15:08:03 <Lemmih> LordBrain: It means that l and l' uniquely determine l''.
15:08:17 <LordBrain> hmmmmm
15:09:46 <LordBrain> ok, how about the terminology... would it be the same thing if i had said after the |: l' l -> l''
15:09:59 <thetallguy> Hm
15:10:18 <thetallguy> l l' determines a unique l''
15:10:44 <LordBrain> does the order matter?
15:11:27 <thetallguy> Certainly it would if you moved passed the arrow
15:11:38 <LordBrain> well...
15:11:42 <LordBrain> i mean before the arrow
15:11:53 <thetallguy> but the example you gave should be equivalent, I think
15:12:09 <LordBrain> if i have Class C a b c d e f g | a b c d e f -> g
15:12:29 <LordBrain> is that the same as class C a b c d e f g | f e d c b a -> g
15:12:42 <Lemmih> Yes, it's the same.
15:12:48 <LordBrain> ok
15:13:31 <LordBrain> what does this constraint do in practice... how does the compiler know if the l'' is uniquely determined?
15:15:43 <astrolabe> In a list comprehension, I want to discard cases where a variable is Nothing, but the line 'relKn /= Nothing' makes the compiler complain.
15:16:12 <Lemmih> LordBrain: It'll make this illegal: 'instance HAppend HNil HNil HNil; instance HAppend HNil HNil Int'
15:16:59 <Lemmih> LordBrain: And it can infer the type of 'hAppend x y' if the types of 'x' and 'y' are known.
15:17:20 <LordBrain> ok, got ya
15:17:29 <LordBrain> thankyou Lemmih 
15:17:35 <jer> would you recommend that i expressly state the type of all my functions, regardless of whether or not i need to? i'm seeing a lot of code that does this when it doesn't seem like it needs to, and i'm curious
15:17:42 <LordBrain> that's what i thought you were saying, but i wasnt quite sure
15:18:08 <gadolin> thetallguy: hmm, do you have a clean (ie, no sorting afterwards) way to make it print powerset in order of subsets' length?
15:18:11 <Lemmih> jer: Types are great for documentation.
15:19:22 <astrolabe> jer: yes, it helps alot
15:19:23 <LordBrain> jer: well.. what i generally do is express the types at the top level.. but inside let expressions i frequently leave them out 
15:20:07 <astrolabe> right
15:20:50 <ndm> astrolabe: Just x <- xs_with_nothing
15:21:03 <jer> astrolabe, when you say it helps a lot, do you mean performance wise or just in as Lemmih says, documentation?
15:21:22 <ndm> jer, usually documentation
15:21:23 <jer> (or both i guess?)
15:21:35 <jer> ndm, ok
15:21:41 <ndm> occasionally it can help performance, when you say Int instead of Integer, but usually its no performance win at all
15:21:43 <jer> thanks folks
15:22:18 <astrolabe> Yeah, documentation that is checked by the compiler.  It also improves compiler error messages.
15:22:20 <LordBrain> jer: depending on what you are doing you might need a type signature in a let expression or something like that.. where you have overloading of functions, the type inference sometimes needs help... i guess that is what the "monomorphism restriction" section of the manual is trying to tell me..
15:22:53 <LordBrain> or the standard rather.. not the manual
15:23:26 <jer> LordBrain, yeah, i know its sometimes needed, my question was only in cases where it wasn't needed if i should declare the types or just leave it out =]
15:24:21 * jer will declare them just for the sake of consistency (at the top level; if i need to later, then i will, otherwise i'll leave 'em out.. sounds like a good plan)
15:24:49 <LordBrain> yeah.. they are very helpful in terms of readability
15:25:29 <LordBrain> someone sees right off the bat, oh this function takes this and this and that and maps it to whatnot.. it's a good clue to what's going on.
15:26:14 <LordBrain> besides that.. if the function's inferred signature differs from the one you specified, the compiler can catch that and show you.
15:28:41 <astrolabe> solved my problem using 'isJust'
15:33:52 <thetallguy> gadolin: I was just thinking about that
15:34:00 <thetallguy> I have a way, but not a clean way.
15:34:22 <thetallguy> sortBy (\x y -> compare (length x) (length y)) $ sort $ power [1,2,3]
15:34:42 <thetallguy> Obviously inefficient
15:40:56 <gadolin> thetallguy: yeah
15:41:03 <gadolin> it's uglish
15:44:17 <LordBrain> is the power function homegrown?
15:44:27 <LordBrain> or is that in a library somewhere?
15:45:54 <thetallguy> LordBrain: homegrown
15:46:16 <thetallguy> gadolin: I just need to write a better merge
15:46:25 <thetallguy> currently just using (++)
15:46:33 <gadolin> yup
15:46:55 <ihope_> How long does GHC take to compile?
15:47:23 <thetallguy> Roughly 4 hours, I think
15:47:32 <jer> ihope_, long time; depends on the hardware
15:53:26 <thetallguy> gadolin: Okay, I have a solution
15:53:47 <thetallguy> I believe there is a better algorithm
15:54:00 <thetallguy> But this at least is reasonably efficient.
15:56:07 <gadolin> thetallguy: do tell
15:58:54 <thetallguy> power :: [a] -> [[a]]
15:58:54 <thetallguy> power [] = [[]]
15:58:54 <thetallguy> power (x:xs) = zipper (map (x :) pxs) pxs 
15:58:54 <thetallguy>     where pxs = power xs
15:59:07 <ndm> http://www.haskell.org/hawiki/PreludeExts
15:59:11 <ndm> that has an implementation of powerset
15:59:31 <thetallguy> @paste
15:59:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
16:00:02 <AtnNn> zipper?
16:00:08 <ihope_> Suddenly I feel the urge to send a channel notice...
16:00:24 <thetallguy> zipper :: [[a]] -> [[a]] -> [[a]]
16:00:24 <thetallguy> zipper xs [] = xs
16:00:24 <thetallguy> zipper [] ys = ys
16:00:24 <thetallguy> zipper xx@(x:xs) yy@(y:ys) =
16:00:24 <thetallguy>     if length x <= length y then
16:00:24 <thetallguy>        x : (zipper xs yy)
16:00:26 <thetallguy>     else
16:00:28 <thetallguy>        y : (zipper xx ys)
16:00:33 <thetallguy> Needs a rewrite
16:00:57 <ihope_> What's it do?
16:01:00 <thetallguy> It is really merge based on length
16:01:41 <thetallguy> merges two lists, taking the element that is shorter first
16:01:51 <thetallguy> otherwise giving preference to the left side
16:02:18 <thetallguy> power [2,3]
16:02:18 <thetallguy> [[],[2],[3],[2,3]]
16:02:45 <thetallguy> map (1 :) (power [2,3])
16:02:45 <thetallguy> [[1],[1,2],[1,3],[1,2,3]]
16:03:00 <thetallguy> merges those two lists
16:03:07 <thetallguy> put the lower on the left
16:03:15 <thetallguy> to get 
16:03:37 <thetallguy> [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]
16:03:52 <gadolin> okay, that'd be it for today, need to get up for the exam tomorrow
16:03:53 <gadolin> cheers
16:04:07 <thetallguy> cheers
16:10:08 <dbremner> shapr - hello
16:15:25 <Oscar> hi people
16:15:45 <Oscar> I'm new to Haskell and I have a question
16:16:09 <Oscar> I'm reading a tutorial
16:16:25 <Oscar> and they are telling me to make a fibonacci function
16:16:30 <Oscar> I think easy
16:16:33 <Oscar> f 1 = 1
16:16:36 <Oscar> f 2 = 1
16:16:52 <Oscar> f n = f (n-1) + f (n-2)
16:17:07 <ihope_> That looks right.
16:17:18 <Oscar> only problem this fonction I made take more than a minute to compute f 50
16:17:39 <Oscar> (and my computer is an athlon 64)
16:17:48 <Oscar> (and I have 1 Go of memory)
16:17:49 <ihope_> Hmm, that means too much laziness, I think.
16:18:06 <ihope_> Try making a list of the fibonacci numbers, and indexing that using the !! operator.
16:18:48 <ihope_> There might be another way to do it. Let me think...
16:18:54 <Oscar> hum ok thanks I'll try ... how does !! works ? (sorry I didn't go that far)
16:19:02 <ihope_> > "Hello, world!" !! 3
16:19:03 <lambdabot> 'l'
16:19:09 <ihope_> > "Hello, world!" !! 6
16:19:10 <lambdabot> ' '
16:19:13 <ihope_> Stuff like that.
16:19:18 <Oscar> I tried to do it another way : 
16:19:20 <Oscar> fib 2 = (1,1)
16:19:20 <Oscar> fib n = (fst(fib (n-1)) + snd(fib (n-1)) , fst (fib (n-1)) )
16:19:24 <jer> Oscar, try this: fib n = fibs !! n where fibs = 0 : 1 : zipWith (+) fibs (tail fibs) <-- how long does it take to say: fib 50 ?
16:19:32 <Oscar> but haskell being lazy ... it makes just the same !
16:19:58 <Oscar> ok I'll try
16:20:47 <Oscar> instant answer  :)
16:20:49 <Oscar> thanks :)
16:20:52 <thetallguy> Oscar: lazy does not imply caching
16:21:01 <thetallguy> or rather memoizing
16:21:16 <dcoutts> Oscar, lazyness is nto the problem for f, it's that f is an exponential time algorithm
16:21:20 <ihope_> You could also try this: fib 2 = (1,1); fib n = (x+y, x) where (x,y) = fib (n-1)
16:21:39 <Oscar> doesn't work
16:21:43 <Oscar> I tried it
16:21:57 <Oscar> well I tried a version
16:22:08 <Oscar> fib 2 = (1,1)
16:22:08 <Oscar> fib n = (fst(fib (n-1)) + snd(fib (n-1)) , fst (fib (n-1)) )
16:22:11 <Oscar> which is about the same
16:22:24 <ihope_> Well, try my version.
16:22:28 <Oscar> and it's also veeeeeery slow
16:22:31 <Oscar> ok
16:22:41 <ihope_> I think it'll tell the compiler to evaluate fib (n-1) only once.
16:24:22 <Oscar> oh you're right it works too :)
16:24:49 <Oscar> thanks guys :)
16:26:24 <mauke> > let fib 1 = 1; fib n = round (t * fromInteger (fib (n - 1))); t = 0.5 + sqrt 1.25 in fib 50
16:26:25 <lambdabot> 20365011074
16:26:42 <ihope_> Um...
16:27:20 <Oscar> and that works ????
16:27:42 <ihope_> > let fib 1 = 1; fib n = round (t * fromInteger (fib (n - 1))); t = 0.5 + sqrt 1.25 in fib 5000
16:27:44 <lambdabot> 17976931348623159077293051907890247336179769789423065727343008115773267580550...
16:27:54 <ihope_> > let fib 1 = 1; fib n = round (t * fromInteger (fib (n - 1))); t = 0.5 + sqrt 1.25 in fib 500
16:27:56 <lambdabot> 22559151616193942168820708033816376497195991600961228252859813885947799778980...
16:28:08 <ihope_> Meh.
16:28:28 <Oscar> fibs 50 is wrong
16:28:35 <Oscar> fib 50
16:28:47 <mauke> > let fib 1 = 1; fib 2 = 1; fib n = round (t * fromInteger (fib (n - 1))); t = 0.5 + sqrt 1.25 in fib 50
16:28:49 <lambdabot> 12586269025
16:29:01 <Oscar> that's right
16:34:24 <Oscar> oh but it's only right for the first ones
16:34:57 <ihope_> > let fib 1 = 1; fib n = round (t * fromInteger (fib (n - 1))); t = 0.5 + sqrt 1.25 in fib 100
16:34:58 <lambdabot> 573147844013817331712
16:35:28 <Oscar> nope
16:35:29 <Oscar> 354224848179261915075
16:35:46 <ihope_> > let fib 1 = 1; fib n = round (t * fromInteger (fib (n - 1))); t = 0.5 + sqrt 1.25 in fib 99
16:35:47 <lambdabot> 354224848179262062592
16:36:05 <mauke> floating point inaccuracy
16:36:22 <ihope_> Yep.
16:36:25 <Oscar> really ?
16:36:45 <ihope_> > iterate (+0.1) 0
16:36:47 <lambdabot> [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.8999999...
16:36:53 <Oscar> no
16:36:56 <Oscar> not only
16:37:50 <Oscar> f(n) / f(n-1) tends toward (0.5 + sqrt 1.25) doesn't mean it's always that
16:39:09 <Oscar> hum
16:39:17 <mauke> http://en.wikipedia.org/wiki/Fibonacci_number#Closed_form_expression
16:40:32 <Oscar> oh ok thanks for the explanation :)
16:45:26 <dbremner> there's also this page - http://cubbi.org/serious/fibonacci/haskell.html
16:45:34 <AtnNn> > let { a=(1+sqrt(5))/2; b=(1-sqrt(5))/2; fib n = (a^n-b^n)/(a-b) } in round $ fib 5
16:45:35 <lambdabot> 5
16:54:28 <LordBrain> would it be correct to say zipper is like union except that union doesnt preserve it if the lists are sorted by length?
16:55:35 <thetallguy> No
16:55:48 <thetallguy> > union "abc" "bc"
16:55:49 <lambdabot> "abc"
16:56:14 <thetallguy> union eliminates duplicate elements
16:57:06 <LordBrain> hmm, but zipper doesnt.. i see
16:57:11 <thetallguy> my zipper function merges by list length
16:57:34 <thetallguy> and it works because each of the input lists is already sorted
16:58:17 <thetallguy> It is much more like the merge in a merge sort
16:58:35 <thetallguy> except that it doesn't compare the full value, it cheats
16:59:23 <LordBrain> i made my own homegrown power, just for the experience, and it looked very much like yours, except i used union instead of zipper
16:59:42 <thetallguy> My original one used (++)
16:59:42 <LordBrain> it didnt produce a nicely sorted result of course
16:59:47 <thetallguy> no point in using union
16:59:53 <ihope_> Power? Like... what>
17:00:00 <thetallguy> because the sub parts have nothing in common
17:00:03 <LordBrain> powerSet might be a better name ihope_ 
17:00:19 <ihope_> Ah, the ol'...
17:00:20 <LordBrain> hmmm, you're right.. i didnt think about that
17:00:31 <thetallguy> It was a suggested mental exercise, to implement powerset and pascal's triangle.
17:01:11 <ihope_> > foldr (\x y -> x >>= \z -> [y:z,z]) [[]] [1,2,3]
17:01:12 <lambdabot> Occurs check: cannot construct the infinite type: b = [[b]]
17:01:12 <lambdabot> Expecte...
17:01:18 <ihope_> Obviously not...
17:01:48 <ihope_> Oh, of course.
17:01:57 <ihope_> > foldr (\x y -> y >>= \z -> [x:z,z]) [[]] [1,2,3]
17:01:58 <lambdabot> [[1,2,3],[2,3],[1,3],[3],[1,2],[2],[1],[]]
17:02:01 <clausen> when does the Y-combinator work well?
17:02:16 <LordBrain> oh clever
17:02:28 <ihope_> Thanks.
17:02:34 <ihope_> It's in the wrong order, though...
17:02:41 <ihope_> > foldr (\x y -> y >>= \z -> [z,x:z]) [[]] [1,2,3]
17:02:42 <lambdabot> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
17:02:47 <ihope_> Better.
17:03:02 <ihope_> Then there's also this:
17:03:19 <thetallguy> Still not correctly sorted, but nice.
17:03:19 <ihope_> > foldr (\x y -> y ++ map (x:) y) [[]] [1,2,3]
17:03:20 <lambdabot> [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
17:04:09 <ihope_> thetallguy: you mean [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]?
17:04:16 <thetallguy> yes
17:04:30 <thetallguy> That's canonical order
17:05:02 <ihope_> Bah, who cares about canonical order :-P
17:05:54 <thetallguy> Heh
17:06:06 <thetallguy> I did it with a merge based on list length
17:06:34 <ihope_> > sortBy (\x y -> compare (length x) (length y)) (foldr (\x y -> y ++ map (x:) y) [[]] [1,2,3])
17:06:35 <lambdabot> [[],[3],[2],[1],[2,3],[1,3],[1,2],[1,2,3]]
17:06:47 <LordBrain> hehehe
17:06:48 <ihope_> Whoo.
17:06:56 <thetallguy> Yes
17:07:08 <ihope_> > sortBy (\x y -> compare (length x) (length y)) (foldr (\x y -> y >>= \z -> [z,x:z]) [[]] [1,2,3])
17:07:09 <lambdabot> [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]
17:07:19 <ihope_> Okay, now stop obfuscating by functions :-P
17:07:22 <thetallguy> I did that too, but now you've added an n log n op onto it.
17:07:27 <ihope_> s/by/my/
17:18:15 <ptolomy> @pl mapM_ (\h -> hGetLine h >>= putStrLn) . repeat
17:18:15 <lambdabot> mapM_ ((putStrLn =<<) . hGetLine) . repeat
17:18:32 <ptolomy> aww.
17:19:41 <ptolomy> I made a 'display the ascii telnet representation of the world cup' one-liner, and was hoping to make it shorter and more obsure. :-P
17:19:43 <petekaz> what's the 'not equal' operator in haskell?
17:19:49 <ptolomy>  /=
17:19:53 <petekaz> thx
17:20:05 <ptolomy> > :t (/=)
17:20:06 <lambdabot> Parse error
17:20:18 <ihope_> @type (/=)
17:20:19 <lambdabot> forall a. (Eq a) => a -> a -> Bool
17:20:23 <ptolomy> ah.
17:22:29 <ihope_> Oh my.
17:23:17 <thetallguy> ptolomy: what's the current version look like?
17:23:42 <ptolomy> thetallguy: main = connectTo "ascii-wm.net" (PortNumber 2006) >>= mapM_ (\h -> hGetLine h >>= putStrLn) . repeat 
17:23:59 <ptolomy> pretty simple.
17:24:05 <ihope_> Eek. No do-notation?
17:24:33 <ptolomy> wouldn't that make it less needlessly terse?
17:24:46 <ihope_> Hmm...
17:25:15 <ptolomy> I should note that the one-line version also has a space leak, it seems.
17:26:10 <ihope_> main = connectTo "ascii-wm.net" (PortNumber 2006) >>= \h -> sequence (repeat (hGetLine h >>= putStrLn))
17:26:16 <Korollary> @pl f h = hGetLine h >>= putStrLn
17:26:16 <lambdabot> f = (putStrLn =<<) . hGetLine
17:27:08 <stepcut> how about -> connectTo "ascii-wm.net" (PortNumber 2006) >>= hGetContents >>= putStrLn 
17:27:17 <stepcut> ?
17:27:24 <ptolomy> I didn't even think of that..
17:27:28 <ihope_> Yeah, I think that'll work.
17:27:46 <ihope_> And I was just about to think of that. You lousy thought-thief, you...
17:27:50 <stepcut> haha
17:28:14 <Korollary> you could have claimed independent discovery, or jailed stepcut's relatives.
17:28:39 <ihope_> I'll ban stepcut's ISP from #ihope.
17:28:41 <ptolomy> hehe. the hGetContents version seems more "efficient", too.
17:30:22 <ihope_> Wait, somebody else do something...
17:30:58 <ihope_> > last [1..]
17:31:02 <lambdabot> Terminated
17:31:18 <mauke> > last (reverse [1..])
17:31:22 <lambdabot> Terminated
17:31:26 <bolrod> duhh
17:31:47 <bolrod> :)
17:32:03 * ihope_ wonders if Prolog could handle that
17:32:22 * bolrod wonders if anybody can handle that
17:32:33 <ihope_> Well, my new IRC client is faster than ChatZilla.
17:32:51 <ihope_> Unfortunately, you can't really send anything.
17:32:57 <stepcut> heh
17:33:02 <ihope_> You can only recieve.
17:33:28 <Korollary> That's the Paris Hilton plug-in.
17:33:30 <ihope_> At least it handles PINGs properly, maybe...
17:33:51 <bolrod> what is this IRC client called?
17:33:54 <bolrod> Telnet ?
17:33:57 <ihope_> Nope.
17:33:59 <bolrod> but without the sending?
17:34:00 <bolrod> :)
17:34:15 <ihope_> Send a CTCP VERSION to NoBot.
17:34:51 <bolrod> ic...
17:34:54 <bolrod> %.%
17:34:56 <ihope_> See? It doesn't support CTCP, so you can't figure out what it's called :-P
17:35:32 <ihope_> @time NoBot
17:35:54 <bolrod> aha
17:37:29 <ihope_> Okay, I just made a new version.
17:37:42 <ihope_> ...
17:37:57 <ihope_> So a Ctrl+C doesn't kill it.
17:38:11 <stepcut> heh
17:38:23 <ihope_> It's dead, but...
17:42:43 <ihope_> And dropped, too. The only problem is that the nick I wanted was EagleBot :-P
17:43:01 <clausen> the Y-combinator isn't working for me!
17:43:09 <clausen> it's giving me a non fixed-point
17:43:21 <ihope_> What's the combinator you're using?
17:43:45 <clausen> fixpoint = lambda f. (lambda x. f (lambda y. x x y))
17:43:45 <clausen>                      (lambda x. f (lambda y. x x y));
17:44:54 <ihope_> @type \f -> (\x -> f (\y -> x x y)) (\x -> f (\y -> x x y))
17:44:55 <lambdabot> Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
17:44:55 <lambdabot> Expected type: t
17:49:04 <ihope_> Suddenly, I realize that the code I've written consists almost entirely of IO.
17:50:26 <ihope_> Now, hopefully, this won't put my password anywhere other than NickServ and my terminal thing.
17:51:23 <ihope_> Oops.
17:51:28 <ihope_> Ack.
17:51:53 <ihope_> Luckily, this guy's registered.
17:53:23 <thetallguy> ptolomy:  Here's a more obscure version
17:53:34 <thetallguy> main = connectTo "ascii-wm.net" (PortNumber 2006) >>= mapM_ ((putStrLn =<<) . hGetLine ) . repeat
17:54:20 <thetallguy> Ah, nuts.
17:54:38 <thetallguy> The hGetContents version is better
17:58:47 <ihope_> Hey, it's not PINGing.
17:58:54 <ihope_> ...I mean PONGing.
17:59:22 <ihope_> testPing x = fmap head (matchRegex (mkRegex "PING :?\\(.*\\)\\.freenode\\.net.*") x)
18:00:29 <ihope_> Does that do what I think it'll do? :-P
18:08:39 <ihope_> Hmm...
18:11:47 <ihope_> Oh, what a disappointing quit message :-P
18:13:01 <pitkali> hi
18:13:29 <pitkali> do you think I should repost bug report for vim literate haskell support to the haskell mailinglist?
18:14:06 <pitkali> currently it was posted only to haskell-cafe, as it was mentioned as the script's maintainer...
18:15:22 <petekaz> @seen dons
18:15:22 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 11 hours, 5 minutes and 2 seconds ago.
18:15:28 <petekaz> @seen dmhous
18:15:28 <lambdabot> I haven't seen dmhous.
18:15:30 <petekaz> @seen dmhouse
18:15:31 <lambdabot> I saw dmhouse leaving #haskell 13 hours, 45 minutes and 44 seconds ago, and .
18:17:22 <petekaz> @tell dons I had some time tonight and wrote the url page title plugin for lambdabot!
18:17:22 <lambdabot> Consider it noted.
18:17:29 <ihope_> And , eh?
18:24:32 <samx> how do i convert a Float to a Double ?
18:26:10 <mauke> @hoogle Float -> Double
18:26:11 <lambdabot> No matches, try a more general search
18:26:18 <samx> hmm.. I guess I can do a cumbersome "fromRational $ toRational r". Nothing simpler?
18:31:44 <audreyt> @type realToFrac
18:31:45 <lambdabot> forall b a. (Fractional b, Real a) => a -> b
18:31:54 <audreyt> hthhth.
18:37:18 <palomer> >:o
18:38:17 <smoofra> what's the equivilant to -I for ghc
18:38:19 <smoofra> ?
18:38:29 <smoofra> i can't get it to recognise that i have a library 
18:39:14 <audreyt> -i?
19:08:15 <jer> exit
19:08:21 <jer> err
19:21:00 <dons> moin
19:21:01 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:21:04 <thetallguy> Anyone know how to construct a PortNumber from an integer?
19:22:55 <Korollary> thetallguy: PortNumber is an instance of Integral
19:23:08 <Korollary> @type fromIntegral
19:23:09 <lambdabot> forall b a. (Num b, Integral a) => a -> b
19:24:00 <wimp> hey
19:24:03 <wimp> I just entered hugs
19:24:09 <wimp> show me the coolest thing I can do in haskell
19:24:14 <wimp> (i.e. something hard to do in scheme) please
19:24:37 <Pete_I> you might need to define 'coolest'
19:24:41 <Lemmih> > ((+) 1 2) -- Let's see them do that!
19:24:42 <lambdabot> 3
19:25:07 <thetallguy> Thanks.
19:25:20 <wimp> hmm
19:25:25 <wimp> so (+) returns the + function
19:25:30 <wimp> and not 0 ?
19:25:36 <Pete_I> of course.
19:25:40 <wimp> no wiat
19:25:42 <wimp> (+ 1 2) doesn't work
19:26:02 <wimp> [btw, using more ()'s than scheme is not "cool"]
19:26:14 <Korollary> I assure you that is not the case
19:26:18 <Lemmih> (it was a joke)
19:26:30 <dons> > map (+1) [1..10[
19:26:31 <lambdabot> Parse error
19:26:32 <Pete_I> ((((+) 1 2)))
19:26:36 <dons> > map (+1) [1..10]
19:26:37 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
19:27:08 <wimp> hmm; that's pretty nifty
19:27:08 <thetallguy> > concat . (intersperse ",") . words $ "a b c"
19:27:10 <lambdabot> "a,b,c"
19:27:21 <wimp> so I'd have to do (mapcar (lambda (x) (+ 1 x)) (num-sequence 1 10))
19:27:26 <dons> > zip "haskell" [1..]
19:27:27 <lambdabot> [('h',1),('a',2),('s',3),('k',4),('e',5),('l',6),('l',7)]
19:27:33 <dons> how about that!
19:27:40 <dons> there's an infinite list in that expression
19:27:47 <wimp> err?
19:27:49 <wimp> I'm confused
19:27:51 <wimp> care to enlighten me?
19:27:55 <dons> > [1..]
19:27:56 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:28:10 <wimp> hey
19:28:13 <wimp> mine's not stopping
19:28:14 <dons> yet, due to laziness, we can manipulate the infinite structure
19:28:17 <dons> > take 10 [1..]
19:28:18 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
19:28:20 <joe_k> i think a list comprehension that refers to itself recursively is the best
19:28:24 <dons> or,
19:28:33 <dons> > zip "abc" [1..]
19:28:34 <lambdabot> [('a',1),('b',2),('c',3)]
19:28:52 <dons> the computatoin evaluates just as much of the infinite structure as it needs
19:29:00 <wimp> hmm
19:29:04 <dons> > zip "abc" $ repeat 'x'
19:29:05 <lambdabot> [('a','x'),('b','x'),('c','x')]
19:29:11 <wimp> how do you make stuff like fib fast
19:29:13 <wimp> if it's lazy ?
19:29:27 <dons> take just as much as you need
19:29:29 <wimp> seem like fib x = fib(x-1) + fib(x-2) wouild be horrible ...
19:29:35 <wimp> would take exponential time
19:29:37 <dons> laziness /= slow
19:29:37 <wimp> to eval
19:29:50 <kpreid_> wimp: lazy means that it can be evaluated *fewer* times
19:30:04 <Lemmih> > let (-|) = flip ($); (|-) = ($) in take 10 $ fix $ \s -> 1:1: s -| zipWith (+) |- tail s
19:30:05 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
19:30:13 <dons> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20
19:30:14 <lambdabot> 10946
19:30:18 <dons> how's that fib
19:30:18 <joe_k> > take 10 ( 1:1: [i + i2 | zip fib (tail fib)])
19:30:19 <lambdabot> Not in scope: `fib'
19:30:30 <wimp> wow, this reminds me of perl
19:30:39 <Korollary> The $ is amazing
19:30:40 <kpreid_> wimp: so the definition of fib as an infinite list that dons gave, for example, effectively caches the intermediate results
19:30:41 <thetallguy> argh
19:30:58 <dons> > 1 : 1 : zipWith (+) fibs (tail fibs)
19:30:59 <lambdabot> Not in scope: `fibs'
19:31:07 <dons> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
19:31:08 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
19:31:27 <Pete_I> cool...
19:31:30 <dons> and fixpoints for all
19:32:44 <wimp> hmm
19:32:46 <dons> ?google Why Haskell Matters
19:32:48 <lambdabot> http://www.haskell.org/haskellwiki/Why_Haskell_matters
19:32:52 <dons> wimp ^^
19:32:57 <kpreid_> @type maxBound
19:32:58 <lambdabot> forall a. (Bounded a) => a
19:32:59 <dons> has some good overviews
19:33:02 <wimp> sicp talked about infinite lists/steams as computation
19:33:04 <Korollary> > head (sort "Trampoline")
19:33:05 <kpreid_> wimp: here's something that's hard to do in Scheme:
19:33:05 <lambdabot> 'T'
19:33:20 <kpreid_> wimp: the function maxBound returns the maximum value of the type, which is *not* passed in as a nargument
19:33:32 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 30 fibs
19:33:33 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:33:37 <kpreid_> wimp: this works only because haskell guarantess full type inference
19:34:04 <dons> > maxBound :: Int
19:34:05 <lambdabot> 2147483647
19:34:05 <Cale> maxBound isn't exactly a function
19:34:17 <Cale> (though internally, it is one :)
19:34:17 <dons> > maxBound :: Data.Word.Word8
19:34:18 <lambdabot> 255
19:34:21 <kpreid_> wimp: there are many other functions like that too; for example, 'return' and 'fail' (but understanding how that's useful depends on monads)
19:34:50 <kpreid_> Cale: er, true. interesting; I hadn't thought about that before
19:35:31 <dons> wimp, another good point is that the separation of IO/side-effecting code from pure code makes it easy to write online haskell evaluators that use the type checker to statically enforce safety 
19:35:50 <Korollary> > head (sort "Trampoline") -- sort doesn't sort the whole list
19:35:51 <lambdabot> 'T'
19:35:52 <dons> so we can happily let the irc channel run code on my machine:
19:35:57 <dons> > putStrLn "io!"
19:35:58 <lambdabot> No IO allowed
19:36:22 <dons> ^^ the type system caught that.
19:36:26 <Pete_I> > :edit
19:36:27 <lambdabot> Parse error
19:36:52 <wimp> what wait wait
19:36:53 <wimp> the type system
19:36:58 <wimp> caught not allowing IO on you rmachine?
19:37:01 <Spark> > shutdown -h now
19:37:02 <lambdabot> Not in scope: `now'
19:37:03 <dons> right
19:37:15 <dons> lambdabot runs on my machine
19:37:18 <kpreid_> wimp: the most important Reason To Learn Haskell, however, is that it's good brain exercise. Haskell is a particularly different-from-the-others language
19:37:20 <dons> so when someone types:
19:37:22 <dons> > 1+ 2
19:37:22 <Pete_I> Spark, that's not haskell.
19:37:23 <lambdabot> 3
19:37:28 <dons> that is executed on my box
19:37:39 <wimp> kpreid_, different from sscheme?
19:37:49 <dons> however, first the type checker in ghc runs over the code, to check the expression isn't of type IO something.
19:38:03 <kpreid_> wimp: yes.
19:38:13 <Spark> > let shutdown = \x y z => 42 in let h = 5 in let now = 7 in shutdown -h now
19:38:14 <lambdabot> Parse error
19:38:18 <wimp> kpreid_, what should I read other than "the haskell school of expression?"
19:38:20 <kpreid_> wimp: Scheme and other Lisps are also far-from-the-center, but differently.
19:38:23 <wimp> (that book doesn't seem all that advanced)
19:38:23 <dons> essentially establishing a proof of the code's safety, modulo the axioms we set (such as what modules are in scope)
19:38:34 <thetallguy> > system "shutdown -h now"
19:38:34 <lambdabot> Not in scope: `system'
19:38:43 <Korollary> wimp: That book is good enough, albeit a bit bland.
19:38:46 <wimp> > system "rm -rf /*"
19:38:47 <lambdabot> Not in scope: `system'
19:38:50 <dons> thetallguy: wouldn't matter anyway. system is in IO
19:39:01 <dons> so even if it was in scope, it wouldn't type check
19:39:08 <thetallguy> I know, I was just getting the syntax right.
19:39:09 <kpreid_> wimp: for example, Lisps go for separate-layered and small syntaxes; Haskell has a medium-sized but highly flexible syntax.
19:39:45 <wimp> kpreid_, the lose of doing stuff on the parse tree level doesn't hur tyou?
19:40:11 <dons> wimp, how do you mean? 
19:40:16 <kpreid_> wimp: there are places where that's really what you want, and you have the Template Haskell extension for that
19:40:25 <dons> you mean, writing programs that manipulate the AST? in which case we use Template Haskell
19:40:50 <kpreid_> wimp: more often, you can figure out how to express it within the program
19:40:57 <Cale> wimp: most of the stuff that I've seen macros used for can be done with simpler abstractions like monads
19:41:12 <dons> Cale, I'd agree. or just laziness + higher order functions is usually enough
19:41:21 <Cale> yeah, that too
19:41:23 <kpreid_> wimp: it is often feasible to do things which would want macros in Scheme/CL because you don't ned as many explicit lambda expressions (due to currying and lazy eval)
19:41:23 <dons> for things like control structures
19:41:35 <Spark> > let y = 10 in (\x -> 7) -y
19:41:35 <lambdabot> add an instance declaration for (Num (t -> t1))
19:41:36 <lambdabot> In the definition of `tt...
19:41:37 <Spark> whats that all about?
19:41:45 <dons> the -y
19:41:49 <Korollary> Compared to what mainstream languages have, AST level manipulation is a big deal. But, Haskell has quite an arsenal of abstraction facilities than those. Thus, not many miss AST manipulation.
19:41:52 <Cale> Spark: you're subtracting y from (\x -> 7)
19:41:56 <dons> > let y = 10 in (\x -> 7) (-y)
19:41:57 <Spark> oh right yet
19:41:57 <lambdabot> 7
19:41:58 <Spark> yes
19:42:18 <dons> ?pl let y = 10 in (\x -> 7) (-y)
19:42:18 <lambdabot> 7
19:42:24 <dons> hehe. pl is too clever sometimes
19:42:39 <Cale> y :: (Num a) => a, so if there was an instance of Num for functions, that would be fine, but there isn't.
19:42:42 <dons> ?pl \y -> (\x -> 7) (-y)
19:42:42 <lambdabot> const 7
19:43:10 <dons> wow. pl did pretty well there too, I'd say
19:43:19 <Pete_I> what's the concatenate operator in haskell?
19:43:30 <Korollary> ++
19:43:31 <Spark> what does pl compile into?
19:43:31 <Cale> ++
19:43:31 <dons> > "hask" ++ "ell"
19:43:32 <lambdabot> "haskell"
19:43:33 <Spark> some set of combinators?
19:43:41 <dons> yes, I believe so
19:43:55 <dons> TheHunter should have written a paper on it.
19:44:01 <dons> maybe he still could
19:44:09 <Spark> ?pl \x.x
19:44:09 <lambdabot> (line 1, column 3):
19:44:10 <lambdabot> unexpected "."
19:44:10 <lambdabot> expecting letter or digit, operator, pattern or "->"
19:44:12 <Spark> ?pl \x -> x
19:44:12 <lambdabot> id
19:44:13 <Spark> grr :)
19:44:18 <Spark> ?pl \x y -> x
19:44:18 <lambdabot> const
19:44:35 <Spark> ?pl \x y -> y
19:44:35 <lambdabot> const id
19:44:35 <dons> it uses a bunch of rewrite rules internally (not rule pragma ones though -- though I suspect they could be used as well, which'd be cool)
19:44:46 <dons> data RewriteRule 
19:44:46 <dons>   = RR Rewrite Rewrite
19:44:46 <dons>   | CRR (Expr -> Maybe Expr)
19:44:46 <dons>   | Down RewriteRule RewriteRule
19:44:46 <dons>   | Up RewriteRule RewriteRule
19:44:49 <dons>   | Or [RewriteRule]
19:44:51 <dons> ..
19:44:57 <Korollary> @seen TheHunter
19:44:57 <lambdabot> I haven't seen TheHunter.
19:44:59 <Spark> rewrite rules to simplify the result?
19:45:01 <Korollary> where's that guy
19:45:12 <Spark> or rewrite rules to generate the result
19:45:27 <dons> and there's a big simplifier specifying all the reductions:
19:45:29 <dons>   -- (f . g) x --> f (g x)
19:45:29 <dons>   rr0 (\f g x -> (f `c` g) `a` x)
19:45:29 <dons>       (\f g x -> f `a` (g `a` x)),
19:45:29 <dons>   -- id x --> x
19:45:31 <dons>   rr0 (\x -> idE `a` x)
19:45:33 <Spark> ah right yes
19:45:33 <dons>       (\x -> x),
19:45:36 <dons> very nice.
19:45:48 <Spark> ?pl (\x -> x x)(\x -> x x)
19:46:04 <dons> it'll give up after 15s
19:46:05 <Korollary> eww
19:46:15 <Spark> optimisation by finite execution
19:46:18 <dons> at least, it used to..
19:46:35 <Spark> > hello
19:46:52 <dons> hmm. let me inspect the src.
19:46:55 <Spark> i knew i should have interacted with an irc bot after drinking a couple of glasses of wine
19:47:07 <lambdabot> ap id id (ap id id)
19:47:07 <lambdabot> optimization suspended, use @pl-resume to continue.
19:47:07 <lambdabot> Not in scope: `hello'
19:47:12 <dons> ah! 
19:47:13 <Korollary> heh
19:47:14 <Spark> heh there we go
19:47:14 <dons> good bot
19:47:20 <Spark> thats a lame way of optimising though
19:47:21 <palomer>  /me thinks pl should at least see if te term is typeable
19:47:25 <dons> looks like the timeout's a bit long
19:47:45 <Spark> ?pl (\x -> x x x)(\x -> x x x)
19:47:48 <Spark> that will fuck it
19:48:00 <lambdabot> ap (ap id id) id (ap (ap id id) id)
19:48:01 <lambdabot> optimization suspended, use @pl-resume to continue.
19:48:02 <Korollary> palomer: I thought fix was typeable but not expressable.
19:48:03 <Spark> aw
19:48:26 <Korollary> my memory is like a trashcan
19:48:29 <Spark> maybe it checks to see if it runs out of memory
19:48:44 <Spark> Korollary: if you disallow terms that dont type, then no untypable term is expressable
19:49:10 <Spark> fix is usually only typable if you have a special rule and a syntactic "fix" construct
19:49:11 <palomer> Korollary: eh?
19:49:14 <dons> if it runs out of memory. no. it just suspends a thread after timeout period 
19:49:45 <Spark> ah
19:49:56 <Spark> how does it execute, does it map from abstract syntax -> abstract syntax
19:50:18 <Spark> because surely after 15 seconds, with an expression like that, it would be a very large tree very quickly
19:50:19 <dons> how does it execute what? in > commands? or you mean in @pl
19:50:25 <Spark> the optimisation of @pl
19:50:29 <Spark> well, both really
19:50:33 <dons> not sure. check the code.
19:50:36 <Spark> heh
19:50:39 <dons> in > we compile andeval.
19:50:49 <dons> then dynamically link the result object
19:50:50 <Korollary> in > we trust
19:50:55 <Spark> right
19:51:34 <dons> pl is truly a "brain child" (bizarre phrase) of TheHunter. no one else knows how it works ;)
19:52:00 <Korollary> @djinn Just 1
19:52:00 <lambdabot> Cannot parse command
19:52:13 <dons> i wonder if 'brain child' refers to Milton's paradise lost, and the scene where satan's chlid  is born from his skull in front of the hosts of heaven.
19:52:21 <wimp> what is pl?
19:52:25 <dons> ?help pl
19:52:26 <lambdabot> pointless <expr>. Play with pointfree code.
19:52:34 <dons> ?gwiki pointfree
19:52:36 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
19:53:00 <Korollary> @djinn Just Int
19:53:00 <lambdabot> -- f cannot be realized.
19:53:04 <kpreid_> @djinn m a -> m a
19:53:04 <lambdabot> f a = a
19:53:29 <dons> wimp, as you see, we also have code refactorers and theorem provers in our irc bot
19:53:39 <dons> making this possibly the geekiest irc bot on the planet.
19:53:40 <dons> ;)
19:53:41 <Spark> heh
19:53:44 <Korollary> @djinn (String,Int)
19:53:45 <lambdabot> -- f cannot be realized.
19:53:56 <Spark> theorem provers?
19:54:09 <kpreid_> @djinn a -> Maybe a -> a
19:54:09 <lambdabot> f a b =
19:54:09 <Korollary> @djinn Bool
19:54:09 <lambdabot> case b of
19:54:09 <lambdabot> Nothing -> a
19:54:09 <lambdabot> Just c -> c
19:54:10 <lambdabot> f = False
19:54:38 <dons> djinn, uses Djinn interprets a Haskell type as a logic formula using the
19:54:38 <dons> Curry-Howard isomorphism and then a decision procedure for
19:54:39 <dons> Intuitionistic Propositional Calculus
19:54:52 <dons> This decision procedure is
19:54:52 <dons> based on Gentzen's LJ sequent calculus, but in a modified form, LJT,
19:54:53 <dons> that ensures termination.
19:54:54 <dons> :)
19:55:08 <dons> The decision procedure has been extended to generate a proof object
19:55:08 <dons> (i.e., a lambda term).  It is this lambda term (in normal form) that
19:55:08 <dons> constitutes the Haskell code.
19:55:12 <Korollary> Why doesn't it like (String,Int) ?
19:55:26 <dons> it really needs polymorphic arguments to play with
19:55:30 <dons> @djinn (a,b)
19:55:30 <lambdabot> -- f cannot be realized.
19:55:31 <Korollary> hm
19:55:34 <kpreid_> @djinn [a] -> Integer
19:55:34 <lambdabot> -- f cannot be realized.
19:55:35 <dons> @djinn (a,b) -> (b,a)
19:55:35 <lambdabot> f (a, b) = (b, a)
19:55:44 <Spark> @djinn 4
19:55:44 <lambdabot> Cannot parse command
19:55:54 <kpreid_> @djinn a -> Maybei a -> a
19:55:55 <lambdabot> f a _ = a
19:55:55 <dons> ?djin Not (Not (Either x (Not x)))
19:55:55 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-ver
19:56:00 <dons> ?djinn Not (Not (Either x (Not x)))
19:56:00 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
19:56:15 <kpreid_> what's Not?
19:56:20 <dons> ?djinn (a -> b -> c) -> ((a,b) -> c)
19:56:20 <lambdabot> f a (b, c) = a b c
19:56:27 <Spark> ?djinn Int
19:56:27 <lambdabot> -- f cannot be realized.
19:56:28 <Spark> :)
19:56:29 <dons> ?djinn (a -> b) -> (c -> b) -> Either a c -> b
19:56:29 <lambdabot> f a b c =
19:56:30 <lambdabot> case c of
19:56:30 <lambdabot> Left d -> a d
19:56:30 <lambdabot> Right e -> b e
19:56:37 <dons> ?. pretty djinn (a -> b) -> (c -> b) -> Either a c -> b
19:56:38 <lambdabot> "Parse error" at column -13
19:56:45 <dons> oh, that's a pity
19:56:47 <Korollary> lol
19:56:52 <Spark> ?djinn (a -> b -> a)
19:56:52 <dons> ?. type djinn (a -> b) -> (c -> b) -> Either a c -> b
19:56:53 <lambdabot> f a _ = a
19:56:54 <lambdabot> parse error on input `='
19:57:06 <Spark> seems that it finds a function to match the type
19:57:13 <dons> ?djinn b -> (a -> b) -> Maybe a -> b
19:57:13 <lambdabot> f a b c =
19:57:13 <lambdabot> case c of
19:57:13 <lambdabot> Nothing -> a
19:57:13 <lambdabot> Just d -> b d
19:57:29 <dons> Spark, yes, it searches for witness proofs for the type
19:57:31 <Spark> but the types, are curry types, no?
19:57:53 <dons> ?djinn-help
19:57:54 <lambdabot> Cannot parse command
19:57:57 <dons> ?djinn-version
19:57:57 <lambdabot> Unknown command, try @list
19:57:57 <Spark> i guess that means theres a 1:1 correspondance between types and programs, but only for finite programs
19:58:03 <Spark> ?djinn-ver
19:58:04 <lambdabot> Djinn version 2005-12-15.
19:58:05 <dons> ?listcommand djinn
19:58:05 <lambdabot> Unknown command, try @list
19:58:06 <audreyt> ?djinn lamp -> djinn
19:58:07 <lambdabot> -- f cannot be realized.
19:58:22 <Spark> ?djinn a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a->a
19:58:22 <lambdabot> f _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a = a
19:58:31 <Spark> hmm
19:58:31 <dons> anyway, the full docs are : http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/Djinn/
19:58:39 <Spark> ah, thats not a principal type
19:58:45 <palomer> Spark: I can give you many programs with the same type
19:59:00 <Spark> palomer: in the curry type system?
19:59:04 <kpreid_> > ceil $ length "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a" / 2
19:59:05 <lambdabot> Not in scope: `ceil'
19:59:13 <audreyt> ?djinn Not (Not (((a->b)->a)->a))
19:59:13 <kpreid_> > ceiling $ length "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a" / 2
19:59:13 <lambdabot> f a =
19:59:14 <lambdabot> void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
19:59:14 <lambdabot> add an instance declaration for (RealFrac Int)
19:59:21 <palomer> yes
19:59:33 <audreyt> @index void
19:59:33 <lambdabot> Foreign.Marshal.Error, Foreign.Marshal, Foreign
19:59:38 <palomer> \x \y -> x y has the same types as \x -> x
19:59:39 <dons> not that void
19:59:47 <audreyt> which void then?
19:59:48 <palomer> types <-> programs correspondence is hogwash
19:59:56 <dons> ?djinn-env
19:59:57 <lambdabot> data () = ()
19:59:57 <lambdabot> data Either a b = Left a | Right b
19:59:57 <lambdabot> data Maybe a = Nothing | Just a
19:59:57 <lambdabot> data Bool = False | True
19:59:57 <lambdabot> data Void
19:59:59 <lambdabot> type Not x = x -> Void
20:00:08 <palomer> it's about as interesting as the integers <-> programs correspondence
20:00:09 <dons> hmm.
20:00:10 <audreyt> aha.
20:00:30 <Spark> ? void
20:00:33 <Spark> ?djinn void
20:00:34 <lambdabot> -- f cannot be realized.
20:00:36 <Spark> ?djinn void -> void
20:00:36 <lambdabot> f a = a
20:00:46 <dons> void :: Void -> a
20:01:01 <Spark> palomer: all of this is hogwash though
20:01:07 <dons>   Since Djinn handles propositional calculus it also knows about the
20:01:07 <dons> absurd proposition, corresponding to the empty set.  This set is
20:01:07 <dons> called Void in Haskell, and Djinn assumes an elimination rule for the
20:01:07 <dons> Void type:
20:01:07 <dons>   void :: Void -> a
20:01:10 <dons> Using Void is of little use for programming, but can be interesting
20:01:12 <dons> for theorem proving.  Example, the double negation of the law of
20:01:15 <dons> excluded middle:
20:01:17 <dons>   Djinn> f ? Not (Not (Either x (Not x)))
20:01:20 <dons>   f :: Not (Not (Either x (Not x)))
20:01:22 <dons>   f x1 = void (x1 (Right (\ c23 -> void (x1 (Left c23)))))
20:01:25 <Spark> @type \x y -> x y
20:01:26 <lambdabot> forall t t1. (t -> t1) -> t -> t1
20:01:31 <Spark> @type \x -> x
20:01:32 <lambdabot> forall t. t -> t
20:01:34 <kpreid_> @djinn-add data (,) a b = (,) a b
20:01:35 <lambdabot> Cannot parse command
20:01:35 <Spark> !=
20:01:41 <audreyt> ah, it's not intuitionistic
20:01:46 <kpreid_> @djinn-add (,) a b = (,) a b
20:01:47 <lambdabot> Cannot parse command
20:01:56 <kpreid_> @help djinn-add
20:01:56 <lambdabot> djinn-add <expr>.
20:01:56 <lambdabot> Define a new function type or type synonym
20:01:59 <Spark> palomer: functions with the same type must obvious have the same number of arguments!
20:02:19 <palomer> Spark: you're on crack
20:02:30 <kpreid_> @djinn-add data , a b = , a b
20:02:31 <lambdabot> Cannot parse command
20:02:33 <Spark> i wish
20:02:40 <kpreid_> @djinn-add data T2 a b = T2 a b
20:03:03 <dons> ?djinn-env
20:03:03 <lambdabot> data () = ()
20:03:05 <lambdabot> data Either a b = Left a | Right b
20:03:07 <lambdabot> data Maybe a = Nothing | Just a
20:03:09 <lambdabot> data Bool = False | True
20:03:11 <lambdabot> data Void
20:03:13 <lambdabot> type Not x = x -> Void
20:03:15 <lambdabot> data T2 a b = T2 a b
20:03:24 <kpreid_> perhaps there should be a short djinn-env which gives only the names
20:03:50 <dons> this would be a short patch. would you like to add it, kpreid? I suspect around 15 minutes
20:04:03 <Spark> ?djinn Bool -> Bool
20:04:03 <lambdabot> f a = a
20:04:04 <kpreid_> or possibly separates them with semicolons instead of lines
20:04:06 <kpreid_> ooh
20:04:25 <dons> if you're interested, 
20:04:26 <dons> ?version
20:04:27 <lambdabot> lambdabot 3.1p108, GHC 6.5 (OpenBSD i386 )
20:04:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:04:35 <dons> darcs get it, then look at Plugins/Djinn.hs
20:04:35 <Spark> palomer: ah i see what you mean now, *principle* type
20:04:39 <kpreid_> dons: actually, I've had other reason to think about setting up to run/hack lambdabot, so consider that another reason
20:04:49 <kpreid_> dons: I'd have to get hs-plugins, too, right?
20:04:58 <dons> there's lots of good reasons. not least that you get vim support for @pl
20:05:03 <dons> kpreid_: yes. and fps
20:05:09 <dons> both are cabalised and easy to build
20:05:17 * kpreid_ has not looked at cabal
20:05:18 <dons> you'll want ghc 6.4.x or 6.5
20:05:31 <dons> kpreid_: oh, just means you install and build them both with the same commands
20:05:40 <kpreid_> I have 6.4
20:05:42 <dons> and lambdabot too: ./Setup.hs configure ; ./Setup.hs build ; ./Setup.hs install
20:06:31 <dons> its fairly useful to install a lambdabot locally, since then you get access to all the commnds without having to go online
20:06:38 <Spark> heh
20:06:43 <dons> such as hoogle or @docs
20:06:50 <kpreid_> no, online is more useful. I already *have* an IRC window :)
20:06:57 <Spark> how often do you need ?djinn when going about your daily business
20:07:00 <dons> it doesn't run over the network locally, just as a command line ap
20:07:06 <dons> djinn, not so often.. ;)(
20:07:40 <Spark> ?pl on the other hand :)
20:07:40 <lambdabot> (line 1, column 20):
20:07:41 <lambdabot> unexpected ")"
20:07:41 <lambdabot> expecting white space or simple term
20:07:44 <Spark> oops
20:07:53 <dons> yeah, hoogle , pl and index i use for real work
20:07:55 <Spark> ?pl \h\h\h\h\rm -rf /
20:07:55 <lambdabot> (line 1, column 3):
20:07:55 <lambdabot> unexpected "\\"
20:07:55 <lambdabot> expecting letter or digit, operator, pattern or "->"
20:08:27 <Spark> is there an index command?
20:08:29 <dons> Spark: now why would a) lambdabot be running as root , b) the pointless plugin use system() or something similar ? ;)
20:08:32 <dons> ?index map
20:08:33 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
20:08:36 <Spark> ahh
20:08:40 <dons> for finding imports
20:08:58 <dons> ?hoogle a ->b -> [a] -> [b]
20:08:59 <lambdabot> No matches, try a more general search
20:09:07 <dons> bahy, i thought hoogle would have got that.
20:09:14 <palomer> @type \a b -> a b
20:09:16 <lambdabot> forall t t1. (t -> t1) -> t -> t1
20:09:29 <Spark> ?hoogle a -> a
20:09:30 <lambdabot> Prelude.id :: a -> a
20:09:30 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
20:09:30 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
20:09:33 <dons> sure. but parens aren't so hard to fiddle with.
20:10:18 <kpreid_> @djinn (a,Maybe b) -> (a,b)
20:10:18 <lambdabot> -- f cannot be realized.
20:10:29 <kpreid_> @djinn T2 a (Maybe b) -> T2 a b
20:10:30 <lambdabot> -- f cannot be realized.
20:10:40 <kpreid_> @djinn T2 a (Maybe b) -> Maybe (T2 a b)
20:10:40 <lambdabot> f a =
20:10:41 <lambdabot> case a of
20:10:41 <lambdabot> T2 b c -> case c of
20:10:41 <lambdabot> Nothing -> Nothing
20:10:41 <lambdabot> Just d -> Just (T2 b d)
20:11:08 <dons> @tell ndm should hoogle be able to find map with : a -> b -> [a] -> [b] ?
20:11:08 <lambdabot> Consider it noted.
20:11:13 <kpreid_> is it my client, or is djinn producing code with missing indentation?
20:11:20 <dons> it is missing indents
20:11:21 <dons> buglet
20:11:51 <SamB> dons: is it djinn, or is lambdabot messing with it?
20:12:18 <dons> lambdabot's fault. i think i can fix this one now
20:12:42 <Spark> some irc clients also trim() the lines
20:12:50 <Spark> god knows why
20:13:06 <dons> similar plugin works though 
20:13:12 <dons> ?pretty case a of b -> c
20:13:12 <lambdabot> "Parse error" at column 17
20:13:19 <dons> ?pretty let f = case a of b -> c
20:13:19 <lambdabot> "Parse error" at column 25
20:13:28 <dons> well,
20:13:34 <Spark> ?hoogle [a] -> [a]
20:13:34 <lambdabot> Prelude.cycle :: [a] -> [a]
20:13:35 <lambdabot> Prelude.init :: [a] -> [a]
20:13:35 <lambdabot> Prelude.reverse :: [a] -> [a]
20:13:35 <dons> ?pretty f = case a of b -> c
20:13:36 <lambdabot> f = case a of
20:13:36 <lambdabot> b -> c
20:13:39 <dons> oh. hmm.
20:13:46 <Spark> no filter?
20:13:54 <dons> that's new.
20:14:07 <dons> there's always corners in 15k loc
20:14:09 <Spark> ?hoogle a -> Bool -> [a] -> [a]
20:14:10 <lambdabot> No matches, try a more general search
20:14:23 <Spark> heh
20:14:43 <Spark> what programmers call "edge cases", computer scientists just call "cases" :)
20:15:39 <kpreid_> dons: I've made a todo list, for whatever good that might do in encouraging me to do something about lambdabot
20:16:11 <sethk> Spark, does that have anything to do with beer?
20:16:31 <Spark> anything has everything to do with beer
20:17:41 <Spark> right, sunrise is happening, bedtime
20:20:27 <dons> kpreid_: perhaps you could darcs send it to me, and i'll stick it in the lambdabot todo list
20:21:59 <kpreid_> dons: I'll keep that in mind
20:22:01 <sethk> Spark, well, you know, when someone starts talking about cases...
20:23:20 <dons> kpreid_: well, just 'darcs send -o /tmp/dons.patch' ; then mail me that file :) after you darcs record your list in lambdabot/TODO :)
20:24:43 <dons> ah, i see the bug. i'm accidentally stripping the space off the front
20:34:01 <dons> ?quit new code 
20:34:50 <dons> ?pretty f = case a of b -> c
20:35:14 <lambdabot> f = case a of
20:35:16 <lambdabot> b -> c
20:35:22 <dons> hmm.
20:35:36 <SamB> dons: what did I say?
20:35:52 <dons> well, it works now in offline mode
20:35:55 <dons> it was due to the filters
20:36:10 <dons> so i guess there must be an extra filter running in online mode if forgot to check
20:41:39 <Cale> > map (2^) [1..50]
20:41:40 <lambdabot> [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2621...
20:41:51 <Cale> no more @more?
20:42:12 <dons> not for @eval
20:42:26 <dons> should be for other thingies though, that ues it
20:49:50 <dropdrive> A novice here about to go to bed...anyone have a puzzle to help me fall asleep?
20:55:11 <Lemmih> A Haskell puzzle?
20:55:44 <dropdrive> a brainteaser...something for a beginner to chew on
20:56:02 <dropdrive> a neat little trick...
20:58:19 <dons> ?quit try again
20:59:08 <dons> ?pretty f = case a of b -> c
20:59:34 <lambdabot>  f = case a of
20:59:36 <lambdabot>      b -> c
21:00:25 <dons> ?djinn (a -> b) -> (c -> b) -> Either a c -> b
21:00:26 <lambdabot> f a b c =
21:00:26 <lambdabot>   case c of
21:00:26 <lambdabot>   Left d -> a d
21:00:26 <lambdabot>   Right e -> b e
21:00:55 <tato> can I overload operators like (:)? 
21:01:17 <dons> > let x (:) y =  x ++ y in 'x' : 'y'
21:01:18 <lambdabot>  Couldn't match `[Char]' against `Char'
21:01:30 <dons> > let x (:) y =  x ++ y in "haske" : "ell"
21:01:30 <lambdabot>  Couldn't match `[Char]' against `Char'
21:01:44 <dons> > let x : y =  x ++ y in 'x' : 'y'
21:01:45 <lambdabot>  Couldn't match `[Char]' against `Char'
21:01:57 <dons> > let x : y =  x ++ y in "xy" : "yz"
21:01:57 <lambdabot>  Couldn't match `[Char]' against `Char'
21:02:03 <dons> hmm
21:02:07 <Lemmih> No, (:) is a constructor.
21:02:15 <dons> ah, silly me
21:02:35 <dons> you can't shadow constructors? seems odd
21:02:40 <dons> maybe that makes sense
21:03:05 <QtPlatypus> Would this be an approprate place to ask about problems I'm having upgrading ghc?
21:03:10 <dons> sure
21:03:38 <tato> so "(:) elem list" is a constructor for List?
21:03:40 <Lemmih> 'let x : y = ...' doesn't define (:), it splits '...' into x and y.
21:03:57 <dons> oh. doh
21:04:00 * dons needs more coffee
21:04:17 <dons> yeah, so if you hide the constructor explicilty
21:04:41 * QtPlatypus is compiling ghc-6.4.2 from the sources,  I have ghc-6.4 installed.  However when I make it it gets up the stage where libHSbase.a is being created by ar
21:04:42 <Pete_I> tea, that does sound like a good idea...
21:04:56 <tato> hmmm how do I hide something thats in prelude?
21:05:06 <QtPlatypus> It runs for a long time and then dies having terminated by a sig 9.
21:05:13 <Lemmih> tato: import Prelude hiding ((:))
21:05:19 <tato> usually if you want to hide in an import is "import Mod hiding (...) "
21:05:20 <tato> oh
21:05:31 <tato> cool :-)
21:06:11 <tato> though on second thought overloading (:) may not be such a wonderful idea
21:06:31 <dons> yeah. don't do it :)
21:06:33 <QtPlatypus> Any advice or people who have the same problem?
21:06:57 <Lemmih> QtPlatypus: Are you running out of memory?
21:07:07 <dons> there seems to be other problems with redefining :
21:07:22 <dons> since its in the lexical syntax
21:07:30 <QtPlatypus> Lemmih: Possably.
21:08:18 <thetallguy> Why do you want to overload (:)?
21:08:43 <dons> this is invalid, according to ghc: (:) :: [a] -> [a] -> [a]
21:08:45 <tato> thetallguy: I've made a data structure that sorta resembles a list so I thought it'd be cool
21:08:48 <dons> though, say, (:+) isn't
21:10:20 <Lemmih> Yeah, GHC parses (:) directly as 'consDataCon_RDR' /-:
21:10:30 <dons> gconsym is special, in the report too
21:10:58 <dons> ah, section 3.7: The constructor ":" is reserved soley for lists
21:11:10 <dons> like [] it is considered part of the language syntax
21:11:17 <dons> and cannot be hidden or redefined
21:11:29 <dons> tato, there's your answer.
21:11:55 <dons> you can overload operators like ":", but not ":' itself :)
21:12:13 <dons> > x + y = x * y in 2 + 3
21:12:13 <lambdabot>  Parse error
21:12:48 <dons> > let x + y = x * y in x + y
21:12:49 <lambdabot>  Not in scope: `y'
21:12:55 <dons> > let x + y = x * y in 2 + 3
21:12:56 <lambdabot>  6
21:13:00 <dons> just too cold today
21:14:42 <thetallguy> I think I remember Lennart A saying he regretted the special syntax for lists
21:15:01 <palomer> EH??
21:15:06 <palomer> that's nuts!
21:15:24 <thetallguy> He felt that ultimately it was more confusing
21:15:58 <palomer> no way!
21:16:11 <thetallguy> He's been using and teaching Haskell for quite some time...
21:16:19 <thetallguy> It's a gimmick, really
21:16:31 <thetallguy> A nice gimmick.
21:16:57 <thetallguy> Thought I'm not sure I share his opinion on this particular issue, I've had similar thoughts about other shortcuts.
21:17:07 <thetallguy> similar shortcuts
21:17:49 <SamB> it is too useful for practical purposes to give up just because it is confusing to beginners!
21:18:00 <dons> well, : shouldn't be magic, i think
21:18:06 <dons> we should at least be able to redefine it
21:18:07 <SamB> no, it shouldn't
21:18:30 <SamB> that is not part of the really special syntax for lists anyway
21:18:32 <thetallguy> I'll have to look up the message and get the details some time.
21:18:56 <dons> yeah, lennart's proposal for how [] would work is the special bit
21:18:58 <dons> )iirc)
21:19:04 <thetallguy> Although, I have to say
21:19:09 <thetallguy> that with or without coffee
21:19:11 <dons> making [] a constructor is nice
21:19:22 <thetallguy> if dons was treating (:) as a function
21:19:28 <SamB> isn't [] a constructor already?
21:19:36 <thetallguy> perhaps LA has a point.
21:19:44 <dons> SamB, it was parsed diferently back in pre-93 or so Haskell
21:19:55 <dons> the change was to make it a special constructor
21:20:12 <dons> thetallguy: yeah, you shouldn't overload :
21:20:20 <dons> but similar arguments could be made for other things
21:20:28 <dons> and that still wouldn't stop us writing:
21:20:32 <dons> ?gwiki Obfuscation
21:20:33 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
21:20:58 <thetallguy> Hehe.
21:21:05 <SamB> I think it makes sense to make [] and () be real names, and maybe the tuple constructors too
21:21:10 <thetallguy> Jeremy S wanted me to show that to some beginners
21:21:21 <thetallguy> I deferred.
21:21:51 <dons> maybe i shoudl rewrite that example to not use any builtin in names, and just build it all up from lambdas
21:21:56 <dons> that'd be some nice line noise
21:22:10 <dons> and the module name is redundant now
21:22:16 <thetallguy> Is there any recursion in it?
21:22:22 <dons> oh, though i think it was necessary to get layout switched off
21:22:45 <dons> no recursion
21:23:14 <thetallguy> Too bad.  Adding a Y would help obscure things
21:46:16 <dons> oh, we've reached 1000 patches for lambdabot yay
21:46:19 <dons> 1011 in fact
21:46:45 <SamB> hooray! I contributed slightly over 1%!
21:46:49 <Pete_I> that's alot of features.
21:47:05 <SamB> well, it might average 5 patches/feature
21:47:12 <SamB> or higher
21:47:16 <dons> quite so.
21:47:29 <dons> more interesting is how long it took us to get those 1k patches
21:47:29 <SamB> especially if you include all of dons's patches
21:47:35 <Pete_I> not counting the yet undiscovered 'features' of course.
21:47:47 <dons> first darcs patch, is Wed Mar 30 13:20:34 EST 2005
21:47:49 <SamB> those are what dons's patches are for
21:47:54 <dons> heh
21:47:57 <SamB> (often)
21:48:06 <SamB> the newly-discovered features that must be removed!
21:48:18 <dons> so in 26 months we've got 1011 patches
21:48:21 <dons> > 1011 / 26
21:48:22 <lambdabot>  38.88461538461539
21:48:26 <dons> per month
21:48:36 <dons> > 38.88 / 30
21:48:36 <Pete_I> how many lines/files is lambabot?
21:48:36 <SamB> you should do a nice graph of actual activity
21:48:37 <lambdabot>  1.296
21:48:38 <dons> per day
21:48:41 <dons> not too bad
21:48:48 <palomer> @palomer
21:48:48 <lambdabot> That's nuts!
21:48:53 <dons> SamB, i wonder, do we know of any scripts for graphic darcs patch activiity ?
21:49:02 <SamB> dons: no!
21:49:09 <dons> Pete_I, about 12k lines of code
21:49:17 <Pete_I> that's a /lot/
21:49:19 <SamB> but we could perhaps steal something from gmane
21:49:27 <aFlag> wow i didn't know lambdabot was that big
21:49:30 <SamB> and adapt it
21:49:33 <dons> this is a real success for such an ad hoc, loose nit system 
21:49:43 <SamB> or perhaps it would be too much work to be worth it
21:49:46 <dons> very little connection between the components has helped a lot
21:50:06 <dons> SamB oh, i think we could generate gnuplot graphs with about 30 mins hacking
21:50:08 <dons> let me see...
21:50:43 <SamB> you could use a shellscript involving AWK ;-)
21:50:58 <dons> heh.
21:51:01 <dons> i'l try sed first
21:51:07 <SamB> or that
21:51:18 <SamB> and of course ghc -e
21:51:20 <dons> what i need a way to convert Mon Jun 12 13:53:53 EST 2006 into a number
21:51:40 <dons> does date parse these tihngs? 
21:51:49 <dons> actually, i have a haskell parse for these things handy
21:52:21 <dons> oh, much simpler
21:52:25 <dons> just ls the patches/ dir
21:52:33 <dons> they're already in canonical form
21:52:47 <SamB_XP> good point!
21:53:39 * dons hacks
22:02:11 <Pete_I> i have a triple, (a, b, c), how do i tell if the 3 of them have a common factor?
22:03:05 <Cale> gcd a (gcd b c)
22:03:52 <Pete_I> thanks, cale
22:03:59 <Cale> no problem
22:04:01 <Cale> 'night
22:12:39 <Pete_I> why does this give me an error about "unresolved top-level overloading"?
22:12:42 <Pete_I> pythTrip = [ (a, b, c) | n <- [1..], m <- [1..n-1], a <- n^2 - m^2, b <- 2*m*n, c <- n^2 + m^2, (gcd a (gcd b c)) == 1 ]
22:14:15 <Pete_I> what does "top-level overloading" mean?
22:27:00 <dfeuer> Pete_I, it means yer mom.
22:27:24 <Pete_I> how very helpful.
22:27:32 <dfeuer> :-)
22:27:37 * dfeuer bows.
22:27:45 <dfeuer> Glad I could be of service!
22:27:58 <Pete_I> it seems it had to do with the gcd part.
22:28:28 * dfeuer looks at the code.
22:28:50 <dfeuer> can I see the gcd code.
22:29:10 <Pete_I> code?
22:29:15 <dfeuer> oh.
22:29:21 <aFlag> hum, a <- 2*m*n seems weird to me
22:29:24 <aFlag> what's that?
22:29:33 <Pete_I> it's part of a formula.
22:29:46 <dfeuer> yah, that comprehension looks very strange.
22:29:48 <Pete_I> i'm calculating pythagorean triples.
22:30:02 <dfeuer> you're not doing what you mean to be doing.
22:30:04 <aFlag> but m and n are not lists, are they?
22:30:06 <Pete_I> http://www.math.uic.edu/~fields/puzzle/triples.html
22:30:15 <Pete_I> no.
22:30:24 <aFlag> and * and ^ are not defined for lists
22:30:36 <Pete_I> ....yes...
22:30:37 <aFlag> the <- there means belongs
22:30:55 <aFlag> so a <- 3 doesn't work
22:31:06 <Pete_I> so it will. and it does.
22:31:23 <aFlag> well, it doesn't on my hugs
22:31:28 <Pete_I> pythTrip = [ (n^2 - m^2, 2*m*n, n^2 + m^2) | n <- [1..], m <- [1..n-1] ]
22:31:30 <Pete_I> it does.
22:31:48 <aFlag> well, that doesn't have a <- 3, does it?
22:32:16 <Pete_I> neither did the other.
22:32:27 <thetallguy> Hmmm .. I think the number of months should be 14, not 26
22:32:27 <aFlag> the other had c <- 2*m*n
22:32:33 <aFlag> m and n are numbers, right?
22:32:37 <Pete_I> right
22:32:48 <aFlag> so it won't work
22:32:53 <Pete_I> hmm..
22:33:08 <Pete_I> ok
22:33:33 <aFlag> see that you have other thing written on pythTrip
22:34:28 <Pete_I> what?
22:34:54 <aFlag> function applications are on the left side of the |
22:35:16 <Pete_I> ok
22:35:19 <aFlag> so you should apply gcd there
22:35:35 <aFlag> you could apply a function after a , if it returns a bool
22:49:16 <fwfewfwa> does anyone knows by chance all the programming paradigms out there? (not to know them all, but the names and a general idea...)?
22:49:44 <Korollary> wikipedia has a big list
22:50:20 <fwfewfwa> but it doesn't explain them very well :(
22:55:09 <Korollary> It's not easy
23:02:13 <labion> hi noob here, is there a function like span but traverses the entire list instead of stopping when it reaches false?
23:02:20 <aFlag> fwfewfwa, there's logic, functional, imperative, object oriented. I don't think there are actually really good definitions of them
23:03:02 <audreyt> definitions are overrated.
23:03:48 <audreyt> especially now more and more languages are "multi paradigm" :)
23:03:55 <ibid> labion: why do you need one?
23:03:57 <Lemmih> labion: What would it do?
23:04:05 <ibid> labion: it's just wasted effort
23:04:13 <audreyt> labion: fold with $! maybe
23:04:22 <lispy> @type ($!)
23:04:23 <Lemmih> > partition isUpper "Hello World"
23:04:24 <lambdabot> forall b a. (a -> b) -> a -> b
23:04:25 <lambdabot>  ("HW","ello orld")
23:04:42 <aFlag> i think almost any language is multy paradigm
23:04:45 <aFlag> multi
23:04:46 <ibid> labion: remember that the predicate cannot have side-effects
23:05:00 <fwfewfwa> aFlag: it highly depends on what you call "paradigm"
23:05:30 <aFlag> you can program functional or object oriented in C
23:05:47 <fwfewfwa> it depends on what you call a paradigm
23:05:56 <labion> Lemmih: thanks! that was the one im looking for.
23:05:58 <aFlag> what do you call a paradigm?
23:06:05 <fwfewfwa> if you call functional paradigm the ability to make recursive functions, then you can...
23:06:15 <labion> ibid: whats a predicate? im still lost =)
23:06:17 <fwfewfwa> mmm, i really don't have a definition...
23:06:35 <fwfewfwa> but if i had to give one, i would say that a paradigm is a way, an approach to make a program...
23:06:41 <aFlag> functional paradigm for me is basicly having all pure functions
23:06:52 <fwfewfwa> every paradigm ask you to approach in a different way, and think the problem from another perspective...
23:06:58 <aFlag> you can have them in C, you just never change state of your variables :)
23:07:15 <fwfewfwa> i don't think that's functional paradigm
23:07:26 <aFlag> what you think it is then?
23:07:48 <fwfewfwa> solve problems using recursive approachs...
23:07:51 <ibid> labion: the function parameter that returns Bool
23:08:36 <fwfewfwa> there are problems thay are easily solved with recursion, and not to easyly with iteration, and the other way around too...
23:08:47 <labion> ibid: ic, thanks! its amazing how fast help is around here. =)
23:08:59 <ibid> fwfewfwa: iteration is a special case of recursion
23:09:11 <ibid> labion: glad if it helped
23:10:05 <fwfewfwa> <ibid> fwfewfwa: iteration is a special case of recursion --> by iteration i mean using loops
23:10:15 <labion> =)
23:10:42 <fwfewfwa> the fact that every iterative program can be turn into a recursive one, and the other way around doesn't mean that one is a special case of another one
23:11:47 <ibid> fwfewfwa: it's merely a syntactic difference. there is no semantic difference
23:12:10 <fwfewfwa> there are a lot of differences...
23:12:22 <ibid> like?
23:12:26 <fwfewfwa> imperative is based on memory transformations
23:12:41 <fwfewfwa> so you do have a "control" and explicit usage of memory...
23:12:46 <ibid> huh, we were talking about iteration vs recursion, not imperative ;)
23:12:51 <fwfewfwa> functional programs doesn't do that because they can't change anything
23:12:53 <fwfewfwa> ok
23:12:55 <fwfewfwa> if it is the same
23:13:07 <fwfewfwa> can i tell you a simple function in functional paradigm
23:13:16 <fwfewfwa> and you tell me how to do it on imperative paradigm?
23:13:26 <fwfewfwa> (that means you are not allowed to use recursion)
23:13:35 <ibid> no, it doesn't
23:14:07 <ibid> it seems to me you are setting up a strawman argument
23:14:39 <ibid> trying to argue a different problem and then pretend you argued the original problem
23:15:39 <ibid> fwfewfwa: recursion is not limited to functional programming
23:16:27 <fwfewfwa> i know
23:16:39 <ibid> fwfewfwa: if you seriously want to argue that iteration is not a special case of recursion, a better tactic would be to appeal to dijkstra :)
23:16:46 <fwfewfwa> O_o
23:16:52 <fwfewfwa> i don't need to appeal to anyone
23:16:58 <fwfewfwa> iteration isn't a special case of recursion
23:17:09 <ibid> he makes a fairly good case. i don't agree with him, but his argument has merit
23:17:15 <aFlag> ibid, the minimum path algorithm?
23:17:19 <ibid> aFlag: no
23:17:25 <ibid> aFlag: dijkstra did a lot more than that
23:17:32 <aFlag> that's all i know hehe
23:17:54 <ibid> (the reference i think of is his book "a discipline of programming")
23:18:54 <aFlag> i don't suppose i can find the part of it he says iteration is not a special case of recursion on the internet, right?
23:19:02 <ibid> aFlag: dunno
23:19:56 <ibid> basically, his argument is that iteration is more fundamental because its treatment under the predicate transformer model is much simpler
23:20:23 <ibid> that saying that iteration is a special case of recursion is putting that cart ahead of the horse
23:21:21 <aFlag> is there some algorithm that you can write recursively that you can't iteratively?
23:21:30 <fwfewfwa> no so?
23:21:52 <ibid> aFlag: no, assuming that you have at least arrays in the language
23:22:04 <ibid> aFlag: it's just a lot harder to get right :)
23:22:12 <ibid> fwfewfwa: sorry about yanking your chain. i just woke up, and i haven't had a single cup of coffee yet ;)
23:22:24 <fwfewfwa> O_o
23:22:26 <fwfewfwa> it's all ok
23:22:33 <fwfewfwa> but recursion isn't the same as imperative...
23:22:35 <aFlag> well, than i'm not sure how one could be a special case of the other, they're both the same
23:22:42 <ibid> (not that i expect to drink a cup today, but the sentiment stands;)
23:22:42 <fwfewfwa> no
23:22:44 <fwfewfwa> they are not
23:22:54 <fwfewfwa> they are just equally powerfull, or equally expresive...
23:22:56 <ibid> fwfewfwa: no, it isn't. i wasn't saying that recursion is the same as imperative ;)
23:23:26 <fwfewfwa> the fact that regular expressions can define exactly the same set of languages than finite automatons doesn't make one a special case of the other one....
23:23:32 <ibid> aFlag: under tail call elimination, iteration can be treated as syntactic sugar for recursion
23:24:02 <ibid> fwfewfwa: true, but regular languages *are* a special case of context-free languages
23:24:12 <fwfewfwa> yes
23:24:19 <fwfewfwa> as left recursion is a special case of recursion
23:24:32 <fwfewfwa> but iteration isn't a special case of recursion...
23:24:49 <ibid> fwfewfwa: depends on how you look at it, which was sort of my point
23:25:21 <aFlag> well, you can simulate a recursive call using a while loop also
23:25:21 <ibid> fwfewfwa: dijkstra makes a good case against it, but i think the tail call case is equally strong. they just look at the problem from a different angle
23:25:27 <aFlag> you just need a stack
23:25:31 <fwfewfwa> <aFlag> well, you can simulate a recursive call using a while loop also --> and additional memory
23:25:37 <ibid> aFlag: sure, as i said :)
23:25:46 <fwfewfwa> no
23:25:49 <fwfewfwa> you need 2 stacks
23:26:02 <fwfewfwa> with just 1 stack you can't 
23:26:08 <aFlag> fwfewfwa, either way, i can't see how one can be called a special case of the other
23:26:19 <fwfewfwa> that's what i say
23:26:30 <fwfewfwa> they are different things with equall expresive power...
23:26:36 <ibid> fwfewfwa: then how come we need only one stack to implement recursion on the usual IAs?
23:26:53 <fwfewfwa> that's because you can access to elements inside the stack
23:26:54 <ibid> aFlag: do you know what tail-call elimination is?
23:27:03 <fwfewfwa> on a proper stack you can only get the top element, and push or pop
23:27:06 <ibid> aFlag: have you ever programmed in scheme?
23:27:19 <fwfewfwa> IAs let you access to middle element, with pointers and other things...
23:27:21 <ibid> fwfewfwa: point. i was more thinking of arrays, not stacks ;)
23:27:25 <fwfewfwa> well
23:27:27 <fwfewfwa> with arrays yes...
23:27:32 <fwfewfwa> but with just one stack no
23:27:40 <fwfewfwa> but with 2 stacks and unlimited memory yes :)
23:27:50 <aFlag> never programmed scheme, but tail-call elimination is for when you have an acumulator or something like that on the parameter, isn't it?
23:27:52 <ibid> unlimited memory?
23:27:58 <fwfewfwa> yes
23:28:05 <fwfewfwa> really
23:28:13 <fwfewfwa> you don't often need unlimited memory :)
23:28:16 <ibid> fwfewfwa: even if the program doesn't use more than a bounded amount of recursion depth?
23:28:19 <fwfewfwa> but anyway...
23:28:27 <fwfewfwa> <ibid> that's a special case...
23:28:35 <fwfewfwa> if you want to be able to make all computable programs
23:28:41 <fwfewfwa> you need unlimited memory...
23:29:01 <fwfewfwa> (or unbounded integers) wich is the same
23:29:12 <fwfewfwa> (or a dense type)
23:29:21 <ibid> fwfewfwa: sure, but for that you need it in any case, it's not specific to recursion simulation
23:29:41 <fwfewfwa> if you want to emulate all recursion you'll need it :)
23:29:51 <fwfewfwa> there are some recursive functions that doesn't even require a stack
23:30:27 <ibid> fwfewfwa: if you want to write any program whatsoever, you also need it, recursion or no recursion
23:30:35 <fwfewfwa> yes
23:30:40 <fwfewfwa> that's what i told you :)
23:30:46 <fwfewfwa> you need something "unbounded"
23:30:52 <ibid> fwfewfwa: that's utterly trivial then
23:31:25 <ibid> fwfewfwa: i was under the impression you were saying it was an additional requirement for simulating recursion
23:31:31 <fwfewfwa> ?
23:31:40 <fwfewfwa> simulating recursion is just a program
23:31:56 <ibid> fwfewfwa: it's a translation scheme
23:32:00 <fwfewfwa> a what?
23:32:10 <ibid> which you can implement as a program, of course
23:32:47 <ibid> aFlag: tail-call elimination is a (low-level) program transformation that transforms tail calls into parameter-passing gotos
23:32:54 <ibid> aFlag: very useful in fp :)
23:32:56 <fwfewfwa> yes
23:33:07 <fwfewfwa> but there are function that are not tail-call implemented
23:33:15 <ibid> sure
23:33:15 <fwfewfwa> ant it's difficult to eliminate their recursion
23:33:18 <ibid> sure
23:33:27 <ibid> that's why iteration is a special case ;)
23:33:28 <fwfewfwa> (unless you use the "trivial" ugly recursion elimination way)
23:33:32 <fwfewfwa> ?
23:33:36 <fwfewfwa> it's not
23:34:02 <aFlag> ibid, but it can't be done for all recursive functions, can it?
23:34:08 <aFlag> ops
23:34:09 <fwfewfwa> what can't be done?
23:34:14 <aFlag> fwfewfwa, already said it
23:34:18 <ibid> aFlag: no
23:34:26 <fwfewfwa> really talking
23:34:30 <ibid> aFlag: just for tail calls
23:34:43 <fwfewfwa> pure functional programming shouldn't use things as "arrays"
23:34:54 <fwfewfwa> so i could give you a iterative program using much memory
23:35:06 <fwfewfwa> and it would be quite difficult to turn it into recursive...
23:35:16 <dons> SamB, darcs repo graphs: 
23:35:18 <ibid> aFlag: of course, if you first transform the general recursion into tail recursion using accumulators, then it will work for all recursive programs, but it kinda defeats the purpose as a generic transformation
23:35:21 <dons>  http://www/~dons/images/commits/lambdabot-commits.png
23:35:42 <aFlag> well, you could write an algorithm to turn some special iteration into recursive
23:35:56 <fwfewfwa> you can write a program that turns any iteration into recursive
23:35:58 <fwfewfwa> so what?
23:36:01 <ibid> aFlag: you can turn all iteration into tail recursion
23:36:13 <fwfewfwa> you can write a haskell interpreter on c
23:36:16 <aFlag> hum, i see your point
23:36:20 <fwfewfwa> and you can write a c interpreter on haskell
23:36:25 <fwfewfwa> so you can do anything you want with both
23:36:37 <aFlag> fwfewfwa, that's not the point fwfewfwa 
23:36:45 <ibid> aFlag: which is why i tend to think of iteration as syntactic sugar for tail recursion
23:36:53 <fwfewfwa> yes
23:36:58 <fwfewfwa> but now iteration uses memory
23:36:59 <fwfewfwa> arrays
23:37:06 <fwfewfwa> pointers and some other "syntactic" sugar
23:37:08 <ibid> aFlag: except when i don't. it isn't always an advantageous position :)
23:37:12 <fwfewfwa> tell me how you turn it into tail recursion?
23:37:14 <ibid> fwfewfwa: what memory?
23:38:03 <fwfewfwa> imperative uses memory
23:38:29 <ibid> you keep bringing up imperative
23:38:41 <fwfewfwa> so?
23:38:49 <ibid> i don't see why
23:38:50 <aFlag> the point here is recursion vs iteration
23:39:00 <fwfewfwa> how do you do iteration without memory?
23:39:11 <ibid> fwfewfwa: why would you?
23:39:21 <fwfewfwa> why what?
23:39:35 <aFlag> why would you want to do iteration without memory?
23:39:40 <ibid> fwfewfwa: iteration doesn't exist in pure fp, so the comparison of iteration vs recursion makes only sense in an imperative context
23:39:43 <fwfewfwa> then i do have imperative...
23:40:42 <ibid> (notice how we have frightened everyone else away:)
23:44:25 <ibid> i didn't mean to frighten you two too :)
23:45:01 <aFlag> hehe
23:45:11 <aFlag> i was looking something here
23:45:25 <aFlag> i can't find the difference between using newtype and data
23:46:05 <ibid> newtype is almost a special case of data
23:47:20 <aFlag> i can't see the difference between a newtype and a data with only one constructor
23:47:27 <ibid> the difference is that a single-constructor data type is a run-time wrapper, while newtype can be simply a compile-time wrapper
23:48:04 <ibid> aFlag: data Foo = Foo !Bar and newtype Foo = Foo Bar don't have much of a semantic difference
23:48:22 <ibid> aFlag: but the latter is easier for the compiler to optimize away
23:49:11 <ibid> (note the exclamation mark)
23:50:05 <aFlag> the ! is for doing the evaluation, right?
23:52:09 <Pete_I> why does the zip() function exist? it looks pointless...
23:52:37 <ibid> aFlag: it's a strictness annotation
23:53:18 <ibid> Pete_I: first, please unlearn the habit of adding a () to a function name. it's wrong and looks silly in haskell (and it is admittedly silly even if popular in C too)
23:53:35 <ibid> Pete_I: second, it exists because it's a useful tool in many contexts
23:53:50 <fwfewfwa> it's not popular in C
23:53:54 <ibid> fwfewfwa: it is
23:53:55 <fwfewfwa> function names doesn't have a ()
23:54:03 <fwfewfwa> (); means invocation in C
23:54:06 <ibid> fwfewfwa: true, which makes it silly
23:54:07 <Pete_I> ok
23:54:08 <fwfewfwa> (attached to a function name)
23:54:16 <ibid> fwfewfwa: it still is fairly common
23:54:24 <ibid> fwfewfwa: in documentation, not code, of course
23:54:32 <fwfewfwa> the fact that there are too much stupid people around isn't a C fault...
23:54:42 <ibid> fwfewfwa: i didn't say it was ;)
23:55:08 <fwfewfwa> you said it was popular in C
23:55:08 <ibid> Pete_I: i use zip often with map
23:55:11 <fwfewfwa> not in C newbies :)
23:55:49 <ibid> fwfewfwa: i've seen it in C circles a lot, i haven't much paid attention on who uses it and who doesn't
23:56:08 <ibid> fwfewfwa: we do agree, i hope, that it is silly in both C and Haskell contexts ;)
23:56:10 <fwfewfwa> that doesn't mean anything
23:56:18 <fwfewfwa> it's not silly...
23:56:21 <ibid> which was my point
23:56:24 <fwfewfwa> in C means you are calling the function...
23:56:42 <ibid> fwfewfwa: which makes it silly when you're referring to the function and not its return value
23:57:14 <fwfewfwa> it's not silly
23:57:16 <fwfewfwa> it's just wrong
23:57:17 <fwfewfwa> :)
23:57:40 <aFlag> it's not silly depending on your definition of sillyness
23:57:50 <ibid> fwfewfwa: seasoned C programmers, at least with Unix background, tend to use mmap(2), which is even sillier if you look at it from that POV (but you aren't supposed to)
23:58:09 <fwfewfwa> what's mmap(2)?
23:58:27 <ibid> fwfewfwa: i take it you don't have Unix experience, at least in C programming?
23:58:43 <aFlag> fwfewfwa, man 2 mmap
23:58:45 <fwfewfwa> i don't have any C programming experience really :)
23:59:06 <ibid> (i was using mmap(2) as an example. the idea is the function name is suffixed with 2 or 3 in parens)
23:59:35 <aFlag> yeah, i was saying that the idea comes from how the manpages are
23:59:37 <ibid> fwfewfwa: traditionally, it's the way to refer to Unix man pages. mmap(2) means, the page on mmap in Section 2
23:59:38 <aFlag> organized
23:59:45 <fwfewfwa> k
