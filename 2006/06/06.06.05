00:00:35 <tojoko> hi
00:00:52 <Cale> hi
00:02:23 <tojoko> Cale, i'm lookin' for a channel where theoretical computer sience is discussed. Can u point any out to me or tell me, how that is called in english correctly? You know, where Pummpin' Lemma etc. is discusses?
00:02:57 <Cale> um, here, I suppose, sometimes
00:03:02 <Cale> or #math would be okay
00:05:06 <tojoko> MMmhm, that be an idea, math. - But, how is that course named on schedules, where things like Pumpin-Lemma are discussed?
00:06:21 <Cale> Computer Science
00:06:23 <Cale> ?
00:06:34 <Cale> Formal Language theory?
00:07:06 <tojoko> Ahh, ok thanks. - I've got that theory wrong i guess.
00:07:37 <Cale> "Pumping Lemma", by the way
00:07:47 <tojoko> ok ;)
00:13:31 <tessier> tojoko: IRC is generally not the place for that sort of thing. The usenet newsgroups are likely to get you better results.
00:13:43 <tessier> tojoko: Do you have some sort of education in computer science?
00:14:16 <tojoko> mmhmmm, ok tessier, that's an idea.
00:14:56 <tojoko> tessie: No, not yet. I'm struggelin' with  pumping lemma and other stuff like that right now at university.
00:15:44 <Korollary> arent there office hours for that course?
00:17:15 <tojoko> Well, year of course. I just was lookin' for somethin' to get over tha weekend. ;)
00:33:41 <goltrpoat> Q:  how many mathematicians does it take to screw in a light bulb?  A:  one, who gives it to six californians, thereby reducing it to a previous joke.
00:37:36 <Pseudonym> Q: How many stereotypical people does it take to screw in a light bulb?  A: N+1.  One to change it, and N to act in a stereotypical manner.
00:38:27 <Stinger_> Q : What did the constipated mathematician do?
00:42:40 <goltrpoat> that joke had better have one hell of a punchline.
00:42:57 <Stinger_> A : worked it out with a pencil ;)
00:43:33 <Pseudonym> This reminds me of the story of the maths department which was getting a new building.
00:43:47 <Pseudonym> The academics were all consulted on what they'd like in the new building.
00:43:54 <Pseudonym> The #1 requested feature: Whiteboards in the toilets.
00:44:06 <goltrpoat> haha
00:44:11 <goltrpoat> we've actually talked about that
00:44:18 <arctanx> I want a whiteboard for my bedroom
00:44:21 <arctanx> they're damn expensive new though
00:44:46 <Pseudonym> You can use whiteboard markers on a refrigerator.
00:45:07 <arctanx> I don't have a refrigerator in my bedroom.
00:45:08 <Stinger_> heh our maths department has blackboards
00:45:31 <Stinger_> (not in the toilets though :P)
00:45:32 <Pseudonym> No, but you could find some enamelled metal somewhere.
00:45:45 <Pseudonym> Say, a washing machine that someone is throwing out.
00:45:48 <Pseudonym> Grab a panel.
01:07:47 <Stinger_> functions as first class objects makes my brain hurt
01:08:28 <dons> > foldl (\a c -> a + 1) 0 [1..10]
01:08:29 <lambdabot>  10
01:08:32 <dons> they're great!
01:08:56 <Stinger_> I know they're cool, but I just kinda instinctually wrote this code just now (from an excercise)
01:09:17 <Stinger_> and I couldnt REALLY tell you how it works :P
01:10:05 <Stinger_> yeah that stuff isnt too bad
01:10:14 <Stinger_> but functions that take functions and return other functions
01:10:57 <dons> ah well, its good to learn new ways of thinking :)
01:11:21 <Stinger_> like fix, asif that even makes any sense ;)
01:11:29 <dons> ?type fix
01:11:30 <lambdabot> forall a. (a -> a) -> a
01:11:45 <dons> fix f = let x = f x in x
01:11:58 <dons> fix isn't so bad, is it? ;)
01:12:47 <Stinger_> can't really see how it terminates as yet :P
01:13:34 <dons> > fix $ \_ -> 1
01:13:35 <lambdabot>  1
01:13:59 <cpatrick> Stinger_: it works because of lazy evaluation
01:14:09 <Stinger_> yeah, its just odd
01:14:17 <cpatrick> Lazy evaluation is very odd.
01:14:34 <cpatrick> Handy, but also causes brains to explode. (Mine did, anyway.)
01:14:50 <Stinger_> hmm does lazy have another name?
01:15:07 <Stinger_> first inner ..something or other
01:16:56 <norpan> call-by-need?
01:17:23 <Stinger_> perhaps I am remembering a description rather than an actual name, oh well
01:17:43 <norpan> it's implemented by graph reduction
01:18:20 <norpan> and then outermost reduction
01:18:38 <norpan> and for strict evaluation you'd evaluate the innermost expression instead
01:18:48 <norpan> something like that?
01:20:20 <Stinger_> hmm is that def of fix equiv to fix f = f (fix f)
01:21:38 <Stinger_> yeah it is nevermind
01:28:24 <Sentinel> what's trac?
01:32:52 <dons> a bug tracking system
01:33:36 <Sentinel> well what does haskell summer of code have to do with it?
01:34:10 <dons> we use it to keep track of bugs in SoC code
01:34:25 <dons> also, we use it to keep track of ideas and proposals
01:34:38 <Sentinel> aha
02:10:16 <vincenz> Doh
02:10:19 <vincenz> WAke up early to go to work
02:10:25 <vincenz> find out it's a holiday when I arrive there
02:10:41 <Korollary> could be worse. could have been a workday.
02:10:50 <vincenz> Well I plan to work nonetheless
02:10:53 <vincenz> I have stuff todo
02:10:58 <vincenz> but it's time lost on the commute back and fro
02:15:57 <vincenz> btw
02:16:03 <vincenz> anyone here have any experience on giving haskell courses?
02:21:11 <tojoko> vincenz, no, just listenin' to them. ;)
02:21:56 <vincenz> I've had an increased interest at work in a course on the subject
02:22:11 <BCoppens> perhaps you could say Itkovian has some experience
02:22:20 <BCoppens> but he's not here now ;)
02:22:56 <mabillama> hello
02:23:04 <mabillama> I'm having some problems with haskell
02:23:33 <mabillama> having some dificult to define functions with data type
02:23:55 <vincenz> I want to introduce it as an alternative to c/c++/perl/(python) for tool development
02:24:18 <mabillama> do anyone here
02:24:27 <mabillama> know a good Haskell tut?
02:24:31 <vincenz> mabillama: YAHT
02:24:32 <vincenz> @where yaht
02:24:32 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
02:27:19 <mabillama> thx a lot
02:28:22 <mabillama> I'm going to read
02:28:26 <mabillama> :)
02:28:40 <mabillama> It's a college project
02:29:05 <mabillama> I have to write a Haskell set of functions to derive and simplify mat expressions
02:29:22 <mabillama> does someone have any material focused on that?
02:29:48 <JKnecht> No.
02:30:01 <vincenz> mabillama: I am sure that most people will want to give you the opportunity of learning it by having you do it yourself
02:32:31 <mabillama> hahaha
02:32:32 <mabillama> rlx
02:32:35 <mabillama> I'm asking
02:32:48 <mabillama> because I stucked one week ago
02:33:00 <mabillama> and I have one week to finish it
02:33:39 <mabillama> with many other projects on AI courses, high speed networks and algorithms complexity
02:33:40 <mabillama> :(
02:33:43 <vincenz> well a more suitable alternative is that you show us what you have and perhaps illustrate where specifically you are stuck so we can help with that
02:33:53 <mabillama> almost nothing
02:34:01 <mabillama> I'll work based on the material you gave
02:34:05 <vincenz> is haskell a prerequisite?
02:34:12 <mabillama> tomorrow I can show something
02:34:12 <JKnecht> or offer $$$ 
02:34:24 <vincenz> mabillama: why not start with pseudocode... and do the design
02:34:25 <Lokadin> say how do i see non-visibe characters in text?
02:34:26 <mabillama> no money on it :)
02:34:31 <Lokadin> like \n and \t
02:34:35 <vincenz> then later someone can help with the haskell translation
02:34:41 <mabillama> yeah
02:34:43 <mabillama> thx a lot
02:34:54 <mabillama> I'll see what I can get
02:34:57 <vincenz> Lokadin: huh?
02:34:58 <mabillama> tomorrow I'll return
02:35:22 <mabillama> vincenz, thx a lot
02:35:22 <Lokadin> vincenz: isn't there a command line utility that i can pipe output to to see the \n and \t's
02:35:23 <vincenz> Lokadin: isn't that editor dependent?
02:35:26 <vincenz> moonlite1: no worry
02:35:38 <mabillama> going now to university :|
02:35:42 <vincenz> Lokadin: oh...and how would yoou want to see them? escaped?
02:35:56 <Lokadin> yea
02:36:00 <vincenz> Lokadin: open vim and type :list[ENTER]
02:36:05 <vincenz> if you just want to see them
02:36:07 <vincenz> erm
02:36:09 <vincenz> :set list
02:36:11 <Lokadin> thanks :)
02:36:22 <vincenz> but that won't escape, just show them with symbols
02:36:26 <vincenz> Lokadin: what's the purpoose?
02:37:27 <Lokadin> vincenz: wanted' to take out the \n's out of a file so i could add them as one line to my rather primitve note making program
02:37:35 <vincenz> oh
02:37:41 <Lokadin> .ui
02:37:44 <vincenz> Lokadin: just the \n?
02:38:17 <shapr> @yow !
02:38:18 <Lokadin> well yea, cause currently i haven't figured out haxml so i just store all info line by line
02:38:18 <lambdabot> Oh my GOD -- the SUN just fell into YANKEE STADIUM!!
02:38:27 <Lokadin> lol
02:38:28 <vincenz> Lokadin: easy
02:38:36 <vincenz> Lokadin: main = getContents >>= liftM (filter (/='\n') >>= putStr
02:38:43 <vincenz> erm add an extra )
02:38:53 <Lokadin> wow thanks :)
02:38:56 <vincenz> I think
02:38:59 <vincenz> haven't tested yet
02:39:18 <Lokadin> could i run that with runhaskell?
02:39:28 <Lokadin> or ghci?
02:39:38 <vincenz> hmm
02:39:56 <Lokadin> would certainly be convenient
02:40:05 <Saulzar> That will use stdin/stdout, so it's probably easier to compile it and use pipes
02:40:12 <vincenz> Saulzar: it's faulty tho
02:40:30 <vincenz> Saulzar: how do I get a pure function into a monad pipelines
02:40:30 <Saulzar> Really? Looks fine to me
02:40:56 <vincenz> @hoogle (>>=)
02:40:56 <lambdabot> Did you mean: (>>=)
02:40:57 <lambdabot> Prelude.undefined :: a
02:40:57 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
02:40:59 <Saulzar> Ah, yes.. 
02:41:07 <vincenz> @hoogle (a -> b) -> a -> m b
02:41:07 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
02:41:07 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
02:41:07 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
02:41:16 <Saulzar> return . filter (/= '\n') probably
02:41:17 <vincenz> @hoogle (Monad m) => (a -> b) -> a -> m b
02:41:18 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
02:41:18 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
02:41:18 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
02:41:38 <vincenz> @type return . filter (/='\n')
02:41:39 <lambdabot> forall (m :: * -> *). (Monad m) => [Char] -> m [Char]
02:41:42 <vincenz> yep
02:42:01 <norpan> vincenz: is fmap what you are looking for?
02:42:02 <vincenz> woot
02:42:02 <vincenz> works
02:42:08 <vincenz> norpan: no it's filer
02:42:09 <vincenz> filter
02:42:14 <vincenz> main = getContents >>= return . filter (/='\n') >>= putStr
02:42:15 <Saulzar> or liftM (filter (/='\n')) putStr
02:42:19 <Lokadin> hmmm, it's all good tr -d '\n' works fine
02:42:22 <norpan> 11:40 < vincenz> Saulzar: how do I get a pure function into a monad pipelines
02:42:32 <Saulzar> Hmm, no ..
02:42:39 <Saulzar> liftM (filter ..) getContents
02:42:40 <vincenz> Saulzar: version above works fine
02:45:02 <goltrpoat> liftM (filter ...) getContents >>= putStr looks a bit nicer, no?
02:45:09 <Saulzar> Yep, should be the same, funny how discussions of code always proliferate into "n versions of xyz" :)
02:48:50 <vincenz> I prefer the pipelined version
02:50:53 <Lokadin> yea, i haven't been here in a while cause i've been learning lojban btw, in case .ui anyone was curious .ui lol however unlikely .i'a
02:51:33 <vincenz> .ui??
02:51:39 <vincenz> .i'a?
02:51:39 <goltrpoat> how about getLine >>= (filterM $ return . ('\n' /=))
02:51:40 <goltrpoat> hehe
02:51:46 <goltrpoat> er.. getContents
02:52:04 <Lokadin> .ui = happiness attitudinal , .i'a = acceptance attitudinal
02:52:10 <vincenz> ?
02:52:32 <Lokadin> in lojban there are things called attitudinals to describe how one feels
02:52:35 <vincenz> I don't get it
02:52:42 <vincenz> Lokadin: rewrite that statement with smileys?
02:52:49 <goltrpoat> haha
02:52:49 <Lokadin> like :) and yay , and :( but more complex
02:52:59 <Lokadin> lol exactly
02:53:01 <Lokadin> .ui
02:53:03 <vincenz> in case :) anyone was curious :) lol however unlikely :|
02:53:11 <vincenz> that the correct translation?
02:53:25 <bolrod> > let   a (: b = a + b in 5 (: 6
02:53:25 <lambdabot>  Parse error
02:53:27 <bolrod> ;;o
02:53:40 <Lokadin> more or less :P though i must say the precision isn't to my liking :p
02:53:48 <vincenz> Lokadin: well you have an overuse of :)
02:53:50 <bolrod> > let a ;) b = a + b in 1 ;) 2
02:53:51 <lambdabot>  Parse error
02:53:51 <Saulzar> Hehe, can't use a bracket as operator
02:53:57 <bolrod> hrm..
02:53:58 <Lokadin> i haven't been able to translate :p to lojban though
02:54:04 <bolrod> tricky
02:54:04 <vincenz> ; and ) are both special
02:54:37 <bolrod> > let a |: b = a + b in 1 |:  2
02:54:38 <lambdabot>  3
02:54:58 <Lokadin> what's the point of that?
02:55:11 <bolrod> hell if I knew
02:55:16 <Lokadin> lol kk .ui
02:57:59 <vincenz> Lokadin: first time I saw you write that I thought you were talking about a ui
02:59:09 <goltrpoat> lambdabot doesn't do IO, right
02:59:42 <goltrpoat> maybe this'll work..
02:59:43 <goltrpoat> > (return "test") >>= filterM (return . ('t' /=)) >>= \x -> Just x
02:59:44 <lambdabot>  Just "es"
02:59:50 <goltrpoat> sweet
03:00:14 <jyp> Lokadin: what do you think of this translation? :p = .uiga'inai
03:00:24 <vincenz> bonjour jyp
03:00:24 <Lokadin> oh, .ui well all attitudinals start with a . because lojban words starting with vowels all start with . , so i'm sure you wont run into any more unnecessary parse errors .ui.u'i
03:00:41 <Lokadin> er that was a lil late one sec
03:00:47 <vincenz> Lokadin: the problem is that I read it as sounds in my head...not smileys
03:00:50 <vincenz> Lokadin: so I'm reading
03:01:05 <jyp> hey vincenz 
03:01:12 <goltrpoat> i'm reading ".ui" as "whee", which makes it sound odd to say the least
03:01:14 <vincenz> "oh, oui(in french pronounciation) well all attitudinals start with a dot because..."
03:01:17 <dmhouse> haha, this is brilliant: http://www.pugscode.org/euroscon/phd.png
03:01:18 <vincenz> goltrpoat: same here
03:02:12 <Lokadin> jyp: .ie that is a very interesting interpretatino .ui.a'u
03:02:43 <Lokadin> goltrpoat: you're supposed to read .ui as whee
03:02:53 <Lokadin> it's sorta the point :)
03:03:21 <vincenz> Lokadin: it sounds odd tho
03:03:23 <goltrpoat> http://www.pugscode.org/osdc/mariner.xul is rather amusing
03:03:28 <vincenz> Lokadin: especially midsentence
03:03:36 <Lokadin> vincenz: only when you're not used to it
03:03:49 <goltrpoat> slide 8 followed by 9, in particular
03:04:00 <Lokadin> i guess it would somewhat in engilsh now wouldn't it *thinks*
03:06:11 <vincenz> woah
03:06:13 <vincenz> xul rocks
03:06:37 <ksandstr> i think i just got something very fundamental about haskell. it's like this: where in common lisp (or something like it), in a macro context, you'd say (get-type-of 'some-symbol) and get a description of the type of the symbol in that context (if such a thing was available in the compiler environment, say), in Haskell you go info <- reify somesymbol.
03:07:02 <ksandstr> i.e. in haskell, you name your stuff by the very very abstract, even esoteric academic way, not by what it actually does :)
03:07:48 <vincenz> I fail to see how this is a language thing
03:07:59 <ksandstr> more of a culture thing, i'll admit, but still.
03:08:28 <dmhouse> vincenz: it's a nice slide framework, definitely. XUL is a bit wider than slideshows, though ;)
03:08:34 <vincenz> I recently wrote a compiler
03:08:40 <ksandstr> i couldn't just go why oh why didn't they have an alias, maybe typeof or something simple and to the point like that, instead of reify... would've saved me a couple hours' head scratching
03:08:52 <vincenz> and I used the "name what it does style
03:08:52 <dmhouse> http://www.meyerweb.com/eric/tools/s5/ is another cool slideshow framework
03:08:56 <mahogny> typeof??? >_<
03:09:13 <vincenz> dmhouse: xul is firefox specific?
03:09:13 <mahogny> that sounds very Java
03:09:29 <dmhouse> vincenz: pretty much. Firefox or another Gecko-based browser, at least.
03:09:38 <dmhouse> vincenz: that other one I pointed too isn't, though.
03:09:40 <ksandstr> or, you know, getTypeOfSymInMyContextDammit or something. (there's a typeof in C#. it returns objects of type Type, or was it TypeId, can't remember)
03:09:49 <dmhouse> plus with s5 you get niceties like an automatic handout.
03:09:51 <vincenz> ksandstr: I completely disagree... I think it's purely dependent on the person... 
03:10:00 <mahogny> ksandstr, why would you need to use typeof anyway?
03:10:04 <vincenz> dmhouse: thx
03:10:59 <vincenz> ksandstr: I think the people that write type inference algos know the concept as reification
03:11:05 <vincenz> ksandstr: and hence reify is an apt name
03:11:13 <ksandstr> mahogny: i wrote an interpolate function in template haskell, so you can write like $(qq "my $housename is $colour and my favourite number is $num") and it produces an appropriate concat with the proper show-alike for the type of the symbol
03:11:30 <ksandstr> mahogny: mostly it just avoids putting double quotes around strings, like you'd expect from e.g. perl
03:12:12 <mahogny> hm. so now the name of the types has become part of the Viewer model? how icky :(
03:13:09 <ksandstr> vincenz: yes, and there's definite advantages to using the abstract concept's name. i'm just pointing out that it caused me quite a bit of head-scratching which could've been avoided if template haskell's documentation were a little bit more down to earth :) ... of course th isn't something you want on your hands when you want to avoid the head-scratching bit
03:13:14 <goltrpoat> mahogny:  one nice thing about C# reflection, since ksandstr brought it up, is that you can pass variables across processes, and discover the type dynamically without having the type actually defined in the client
03:13:57 <ksandstr> mahogny: i'm not sure what you mean with the Viewer model. i think the qq i wrote just takes the information from the surrounding scope, like i thought it would
03:14:19 <mahogny> goltrpoat, hmmm. passing variables. that sounds so low-level that if you don't know the type, then I have no clue what you are up to :o
03:14:50 <mahogny> ksandstr, MVC? well, it depends on where you intend for the text to go
03:15:20 <vincenz> > let <p> = 1 in <p>
03:15:20 <lambdabot>  Parse error
03:15:23 <vincenz> hmm
03:15:34 <vincenz> > let a <p> b= 1 in 1 <p> 2
03:15:34 <lambdabot>  Parse error in pattern
03:15:46 <goltrpoat> mahogny:  one example is a viewer framework of some sort that displays, say, a graph.  it's not aware of the node and edge types, but it needs to know how many, say, accessors a node has, in order to draw that many "ports" on the node representation, and it may want to typematch based on a delegate you've passed in
03:15:54 <vincenz> I'm looking at the haskell xul things...
03:16:12 <vincenz> greet :: String -> Xml
03:16:13 <goltrpoat> mahogny:  now imagine you're distributing the viewer framework as a dll that picks up objects through remoting, from third party apps
03:16:16 <dmhouse> vincenz: that's what i thought. :)
03:16:26 <vincenz> greet name = <p>Hello <% name %>! </p>
03:16:30 <vincenz> how does that work in haskell?
03:16:33 <vincenz> haskell won't parse that
03:16:48 <dmhouse> preprocessor? TH-like syntax extensions?
03:16:51 <pejo> goltrpoat, if you haven't seen it, Acute by Peter Sewell and others might have a bunch of interesting articles.
03:16:54 <vincenz> dmhouse: ah
03:16:57 <mahogny> goltrpoat, I guess that is one case. quite esoteric one, but still valid
03:17:06 <dmhouse> vincenz: I would guess.
03:17:24 <goltrpoat> pejo:  oh interesting.. thanks
03:18:27 <goltrpoat> mahogny:  it's the first thing i thought of, since i had to write something similar not too long ago.  i agree that the idea of needing typeid within the same project sounds fundamentally broken though.
03:18:57 <mahogny> yeah. it's not exactly an unsolvable problem even without typeof
03:19:08 <Lokadin> so is pugs, THE perl6 interpreter?
03:19:14 <integral> nope.
03:19:18 <mahogny> LoganH, prototype kind of
03:19:23 <Lokadin> oh okay,
03:19:24 <dmhouse> It's a fairly popular one, though.
03:19:34 <integral> dmhouse: it's the only usable one though :-P
03:19:37 <goltrpoat> no, but it pollutes the interface.  instead of passing in an array of objects, you're passing in an array of objects along with port counts and typeids
03:19:49 <dmhouse> integral: Right. It's the dominant one.
03:20:16 <dmhouse> And, clearly, the best. :)
03:20:24 <goltrpoat> and how do you extend the edge typechecking to arbitrary types?  you basically end up having to put a callback to the client app to do the verification for you
03:20:31 <goltrpoat> just a lot more work on the client side.
03:20:45 <Lokadin> which is good no?
03:21:20 <mahogny> goltrpoat, but this already requires some language support (it would be less fun to interface your dll with say C) so in that case one might consider better ways
03:21:37 <goltrpoat> well, it requires that the client is a .net app
03:21:51 <goltrpoat> but.. that's not a terribly restrictive requirement in this case
03:22:07 <Lokadin> what if you're not running windows?
03:22:19 * vincenz leaves
03:22:19 <mahogny> hmmm. I might disagree there but one would need to know more about the circumstances
03:22:23 <goltrpoat> then you wouldn't have much use for that dll, would you now :)
03:23:33 <Lokadin> .ui, oh, didn't understand what the reference was to , .oiro'a
03:24:24 <mahogny> there's a similar problem. java for example supports serializing all your data down to disk (even the GUI!) which must be the most stupid thing I've ever heard of
03:24:53 <dons> I'm giving a lecture tomorrow on DataByteString, here's the slides for that if any bytestring hackers/users are interested: http://www.cse.unsw.edu.au/~dons/code/talks/lazy-fusion/fusion-talk.ps.gz
03:25:07 <dons> comments highly welcome.... !
03:28:11 <goltrpoat> here's another argument for type reflection.  .net forms has a property grid control, where you pass it an object, and it shows the names of whatever properties it has, the user can change values, and you can attach custom value modifiers
03:28:36 <goltrpoat> without reflection, you'd basically have to set up the entire thing yourself.  with reflection, you just pass it the object and it all works
03:30:15 <mahogny> well, as long as one is fine by being locked to .net
03:30:44 <goltrpoat> -shrug- mono's pretty far along, last i heard
03:31:02 <mahogny> it's still .net
03:31:29 <goltrpoat> so what's wrong with being locked into it?
03:31:42 <mahogny> portability
03:31:56 <goltrpoat> to what?
03:32:15 <mahogny> to whatever you want to port it to?
03:32:21 <goltrpoat> that doesn't run mono?
03:32:27 <goltrpoat> i can't think of a platform
03:32:53 <mahogny> that would include a bunch of microprocessors if nothing else. but I also consider language portability
03:33:28 <mahogny> for example, if you can't read files saved using one language in a sane way using another language, then you have a serious language portability barrier
03:33:29 <goltrpoat> you can always write an unmanaged->managed proxy to interface with unmanaged code, if you need to
03:33:58 <goltrpoat> what do languages have to do with file formats? :)
03:34:35 <mahogny> as the example above where a "nice way of storing files" is to simply serialize them down to disk. I wouldn't want to touch such a file with for example C
03:34:48 <mahogny> especially not when the way of serialization is badly defined
03:35:05 <goltrpoat> oh, i missed that example
03:35:22 <goltrpoat> you mean the reflection-based serialization in .net?  i don't think anyone in their right mind uses that
03:35:32 <Lokadin> say are there any current p2p haskell projects?
03:36:14 <mahogny> or java. I have seen some examples where it is actually used, and then you also have to remember that 90% of the commercial coders in world aren't in their right minds. at least not the ones working on the companies I buy software from :P
03:36:25 <mahogny> Lokadin, heard there is a torrent project of sort
03:36:56 <goltrpoat> well true, but the fact that a lot of people code badly isn't necessarily a reflection on what environment they're coding in
03:37:13 <Lokadin> mahogny: well i was hoping for a fully p2p project, something like gnutella, however that will probably do, where should i look to find it?
03:37:22 <mahogny> right. few things are bad as long as you put them in the right hands
03:37:35 <mahogny> but there is a reason why haskell has a static type system ;)
03:37:55 <mahogny> Lokadin, darcs maybe. haven't heard of such a project though
03:39:03 <dmhouse> @google (p2p or peer-to-peer) haskell
03:39:05 <Lokadin> though you would agree that it should be possible?
03:39:05 <lambdabot> http://integralvisioning.org/article.php?story=p2ptheory2
03:39:25 <Lokadin> wow
03:39:28 <Lokadin> .uisai
03:39:30 <mahogny> Lokadin, I'm not a fan of the networking in haskell *as is*. but maybe you can try build it on HApps
03:40:09 <Lokadin> @where sai
03:40:09 <lambdabot> I know nothing about sai.
03:40:12 <Lokadin> er
03:40:16 <Lokadin> @where happs
03:40:16 <lambdabot> I know nothing about happs.
03:40:21 <dmhouse> one of the SoC projects is to build a kick-ass networking library for Haskell.
03:40:25 <Saulzar> Lokadin, Have a look for Conjure, a number of people around here seem to work on it
03:40:26 <dmhouse> (HaskellNet)
03:40:30 <eivuokko> dons, I did a quick read, it looks great :) ..however few comments:  The tuning the chunk size plot axis wasnt' immediately clear to me and More results: Memory plot is pretty hard to read on my setup (both blocks look like filled with same pattern).  And maybe it's me (I don't know something or didn't read carefulyl enough), but "up and down loops fuse" (page 28) isn't clear to me.
03:40:50 <Lokadin> @where conjure
03:40:50 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
03:40:55 <dons> eivuokko: great. thanks. i'll modify some things
03:41:33 <mahogny> dmhouse, I dunno if that library will solve one of the fundamental problems. that is, building a raw protocol *with exceptions and concurrency* is a pain in the ass. solvable of course
03:41:43 <Lokadin> dmhouse: i've been looking for something like that website for ages, at glance anyways seems what i wanted
03:42:58 <Lokadin> not haskell oriented but just general p2p .ui
03:43:00 <dmhouse> mahogny: why is it so hard? We have tools in Haskell for both of those things
03:43:47 <goltrpoat> i don't suppose any of you know of a tool that'll organize pdfs and postscript files and let you enter sticky data for it like authors, keywords, cross-references, etc
03:43:55 <mahogny> dmhouse, the hierarchial libs is somewhat unuserfriendly in this case IMO
03:44:20 <dmhouse> goltrpoat: sounds like a generic file-management tool would do
03:44:24 <goltrpoat> realized the other day that i have over a thousand papers sitting on my harddrive, and i have no clue what 90% of them are until i look at them
03:44:40 <eivuokko> Heh
03:45:04 <mahogny> goltrpoat, favourite: store them by the name they have if you download them from the ejournals :P
03:45:17 <goltrpoat> yeah like TR2003-05a.pdf? :)
03:45:23 <dmhouse> hah :)
03:45:24 <mahogny> yes :)
03:45:36 <goltrpoat> yes that's basically what most of them look like
03:46:05 <dmhouse> it's even worse when the authors name them by the journal they're going to be appearing in. Like Paterson's Arrows and Computations is called fop.pdf.
03:46:13 <mahogny> lol
03:46:18 <goltrpoat> heh
03:46:38 * mahogny just wish unix had a better filesystem for this
03:46:53 <dmhouse> mm... tagging would be great.
03:46:59 <dmhouse> how Vista was planned to be.
03:47:21 <mahogny> well, I would rather see the OS support FS-modules, so it doesn't even have to be hierarchial at some places
03:47:21 <Lokadin> mahogny: how about reiser4?
03:47:23 <goltrpoat> well, i'm half tempted to just write a tool that will grab everything in a directory, match it against an xml file, and ask you to enter details for any papers that aren't in it
03:47:37 <mahogny> Lokadin, doesn't help much unless the kernel supports the functions
03:47:51 <Lokadin> .ie
03:48:11 <dmhouse> goltrpoat: yep, that sounds fairly easy.
03:48:11 <mahogny> unix is broken. no news
03:48:12 <goltrpoat> details being name, authors, year, journal, keywords, bits of bibliography
03:48:24 <goltrpoat> and then be able to search stuff.
03:48:42 <dmhouse> sounds like someone should have already written this.
03:48:44 <goltrpoat> just figured i'd check if there's something like that out there already, since i doubt i'm the only person with that problem
03:48:44 <goltrpoat> hehe
03:48:47 <goltrpoat> yeah exactly
03:49:11 <dmhouse> As I said, a generic file-manager with tagging support might do the trick
03:49:23 <dmhouse> (Not that I know/use any systems like that.)
03:49:43 <goltrpoat> i'll ask microsoft to add it to explorer next time i see them
03:49:44 <goltrpoat> hehe
03:50:11 <mahogny> add it to firefox and you bet they will add it soon
03:50:22 <goltrpoat> actually, doesn't macos have file attributes of that sort
03:50:38 * mahogny dunno
03:50:38 <goltrpoat> oh.. they have metadata that you can attach to a file
03:59:07 <pejo> goltrpoat, www.citeulike.org might be an alternative. But you have to organize it yourself.
04:00:55 <lscd> citeulike is great
04:01:08 <dons> eivuokko: thanks for your comments.i've updated the slides.
04:01:19 <lscd> mahogny: hm... something like fuse?
04:01:20 <dons> ?karma+ eivuokko
04:01:20 <lambdabot> eivuokko's karma raised to 2.
04:01:41 <mahogny> lscd, never heard of
04:02:12 <lscd> http://fuse.sourceforge.net/
04:02:20 <lscd> 'With FUSE it is possible to implement a fully functional filesystem in a userspace program. '
04:02:49 <goltrpoat> pejo:  i'm looking at a thing called "pdf manager" which i think might be sufficient
04:02:57 <goltrpoat> for pdf files anyway, i don't think it does anything with postscript
04:05:12 <shapr> bringert!
04:05:36 <Saulzar> dons, What exactly is the graph on page 18? 
04:08:27 <mahogny> lscd, it's a step in the right direction, but not enough. some rather drastic changes to the unix concept of a file are required
04:09:22 <lscd> i probably missed part of what you're looking for; a non-hierchical fs?
04:10:04 <mahogny> the FS module would decide what topology the file system would have
04:10:17 <mahogny> but tagging is a *need* to make it look sensible
04:11:01 <lscd> ahhh - one of my classmates was saying something really, really similar on friday
04:11:34 <lscd> he was thinking of doing that in the 80s / early 90s, but got talked out of it
04:11:45 <dons> Saulzar: the one marked "Comparing lazy and strict packed strings" ?
04:12:02 <Saulzar> Yeah.
04:12:07 <mahogny> I think it would lots and lots of work. if it is to be done, then one might as well write a whole new OS right away
04:12:11 <mahogny> +be
04:12:31 <dons> it compares the strict and lazy functions applied to the same data. their running times
04:12:47 <lscd> hm.. debatable; with writing a whole new os, there's a lot of irrelevant parts that come into play - ie, device drivers
04:13:08 <Saulzar> labels are both "strict_vs_lazy"
04:13:22 <dons> yeah, ignore the labels. pretend i'm there explaing it to the class :)
04:13:35 <dons> strict strings are red
04:13:43 <mahogny> lscd, yeah. I've been propagating to rip out all drivers from linux and turn them into an OS-independent set making it 1000 times easier to make new OS'
04:14:34 <lscd> mahogny: you'd still need to provide at least a compatability layer for the driver model, it's not a particularily stable target (linux keeps changing internally, sometimes quite a lot), and there's the licensing
04:14:42 <lscd> but yeah... there are a few projects with similar ideas there too
04:15:24 <mahogny> lscd, one would rip out as much as possible from the driver to make it reasonably stable
04:15:50 <mahogny> licensing is a bitch, I agree
04:15:57 <lscd> mmm. it might make more sense to rip from, say, netbsd
04:16:06 <mahogny> fewer drivers there
04:16:09 <lscd> yes
04:16:16 <lscd> but stable driver interface, and freer license
04:16:20 <mahogny> that makes it many many times less interesting
04:16:32 <lscd> disagreed; it's still a big win over nothing
04:16:33 <mahogny> well. write new freer drivers and put into the collection over time
04:17:00 <lscd> and it's not as if linux never ports drivers from various BSDs; support isn't so bad
04:17:44 <mahogny> however, whichever is used, the big gain would be if one could talk any camp such as linux or BSD to also use the collection. then you would be guaranteed to get new drivers. maintenance is equally important
04:18:06 <Saulzar> Hmm, would the drivers not depend _heavily_ on the design of underlying OS?
04:18:15 <lscd> sure; and some people (ie, linus torvalds) are dead set against that
04:18:33 <apfelmus> lscd, mahogny: drivers should be specified abstractly: a dsl in haskell. something like pan
04:18:40 <mahogny> Saulzar, depends on which drivers you consider, and what you would let the drivers do
04:18:55 <lscd> apfelmus: that's nice in theory, but show me it working ^-^
04:18:58 <mahogny> apfelmus, that would be a dream. an unrealistic dream, but still something worth researching
04:19:45 <mahogny> lscd, hm. never heard his opinion on it. I guess that might rule out linux. unless you do the dirty work and add an interface to the portable drivers and hope driver developers switch over to only write portable ones
04:20:04 <lscd> mahogny: highly unlikely though
04:20:08 <mahogny> yes
04:21:10 <mahogny> it might work if one collects a few really elite coders and write such interfaces for *bsd and linux, all in one go. then I think at least the BSD people would be happy to be able to use linux drivers
04:21:30 <lscd> http://www.linuxdevcenter.com/pub/a/linux/2004/09/02/driver_ease.html <-- search for linus, 3rd hit
04:21:45 <lscd> i'm not so sure - the bsd people can be a lot more picky about code quality
04:22:04 <lscd> [sorry, 1st hit, not 3rd]
04:22:05 <mahogny> yes, but nothing stops them from improving the quality :)
04:22:29 <mahogny> hey, wait, this is something different
04:22:31 <lscd> uh-huh; other than time, interest, access to the hardware in question, etc
04:22:38 <mahogny> he's oposing an _ABI_. that's different
04:23:02 <lscd> true; but there's not a stable api either
04:23:20 <mahogny> no, but it's a lot easier to maintain a nonstable API than a nonstable ABI
04:23:27 <shapr> I can't believe it's not butter!
04:23:56 <apfelmus> the house project actually implements an tiny OS in Haskell with some dirvers.
04:23:59 <lscd> ehm.. given that both are unstable, what's your point?
04:24:05 <lscd> apfelmus: yeah, house and hop are cool
04:24:07 <mahogny> apfelmus, "some" is the word
04:24:16 <shapr> House rocks
04:24:25 <shapr> mahogny: I wanna see you do better
04:24:57 * shapr hugs House
04:25:12 <mahogny> shapr, it's not about me doing better, it is about that it shows the problem; unless we have a common way of doing drivers we will forever be stuck with rewriting new drivers
04:25:13 <shapr> It's fun to hack on too, have you used the tun/tap interface for the pure Haskell tcp/ip stack?
04:25:46 <shapr> What about a yacc for drivers?
04:26:04 <shapr> That is, what if manufacturers described their hardware in a format that would allow you to generate drivers for it?
04:26:05 <apfelmus> i'm not a device driver writer but the house driver look extremely *simple*
04:26:06 <mahogny> that's a no-go because we have no grammar
04:26:12 <shapr> So make one up
04:26:17 <mahogny> not so easy
04:26:21 <shapr> Why not?
04:26:40 <mahogny> because the most general grammar turns out to be an entirelly new language and then we are back to scratch
04:26:50 <apfelmus> shapr: specify device drivers in haskell! then compile them to C or whatsoever like pan
04:26:52 <shapr> Not necessarily
04:26:54 <vincenz> woot
04:27:01 <vincenz> my system is much snappier now that I upgraded
04:27:01 <shapr> Yeah, domain specific languages, dig?
04:27:19 <mahogny> that would be a dream, yes. but show one working in practice
04:27:37 <shapr> Since this is a new solution, you wouldn't see that already :-P
04:27:49 <shapr> Actually, there are already DSLs for driver spec
04:27:52 <mahogny> this is the job for some really experienced driver hacker
04:27:54 <shapr> Have you seen OSKit?
04:27:56 <mahogny> yes
04:28:00 <shapr> Sure, but DSLs is a job for Haskellers!
04:28:13 <shapr> So we could get domain experts from both areas and make something awesome.
04:28:26 <mahogny> well, I consider this worth about as much effort as it takes. and it will take effort
04:28:30 <apfelmus> the point is: device drivers need to be turing complete. so there is no way around a dsl if you want abstraction
04:28:44 <mahogny> well, need is a strong word
04:28:49 <Lokadin> co'o rodo (goodbye everybody) i'm off to bed
04:28:53 <mahogny> I believe you can do without it, if you are clever enough
04:29:02 <mahogny> but it for certainly ain't easy
04:29:44 <mahogny> even without turing compatibility, it's still a daunting task to make a sensible OS interface
04:30:06 <ndm> have you seen Ada's device model
04:30:14 <shapr> co'o Lokadin 
04:30:16 <mahogny> haven't coded Ada that much
04:30:25 <ndm> it goes some way towards mapping a hardware device to a software object
04:30:37 <apfelmus> mahogny: well, but you only know afterwards if you need a turing complete device driver or not. so best way is to start out with a turing complete language offering huge abstraction features 
04:30:44 <ndm> you can specify "these bits 3,4,5 in this register make up this integer in this structure"
04:30:57 <ndm> and the ada takes care of doing all the hardware interfacing at the low level
04:31:05 <mahogny> apfelmus, hm. I think I would go from minimalistic and add features over time as they are needed
04:31:19 <ndm> and you can just code in normal Ada, ignoring the fact you are working with a device
04:31:20 <mahogny> ndm, well, I guess it would look kind of like that
04:31:37 <ndm> indeed, that seems to be the "low level" aspect of defining a device
04:31:47 <ndm> you'd probably need another layer above that for Yacc for devices
04:32:07 <mahogny> best way to know; invent a language as you go and implement a driver
04:32:36 <shapr> Probably so
04:32:41 <shapr> House is perfect for that!
04:32:47 <shapr> Look at the Hardware monad, is that cool or what?
04:33:06 <vincenz> there's a big diff between ada and haskell known as static data vs gc
04:33:19 <apfelmus> mahogny: nobody restricts you working on a ADT with fixed functions. it's just easier to add full turing if needed and strip it off if you have a clever idea
04:33:21 <mahogny> I would probably rather try and write replacement drivers for linux as I would assume those drivers are written in an "optimal way"
04:34:09 <mahogny> apfelmus, I don't think I can comment before actually having tried to implement it
04:34:51 <mahogny> the linux drivers are dirty so if your language can cope with them, then you are pretty much set
04:35:12 <vincenz> but with a DSL... is your aim to generate c code that will be the driver?
04:35:13 <apfelmus> mac os x actually uses IOKit, which abstracts at least the driver hierarchy and interfaces. one can steal the interfaces for a new approach
04:35:27 <vincenz> or use this DSL live... and in that case.. there's the issue with the lack of being able to place data where you want it
04:36:01 <vincenz> I was discussing the idea today, but then regarding on how to do data-placement optimization in haskell
04:36:30 <apfelmus> vincenz: right, a dsl first should go to C like in PAN. just to make sure that lazy evaluation does not bring unnecessary problems
04:36:33 <mahogny> vincenz, C+asm would be one goal, for the speed if nothing else
04:37:08 <mahogny> in that case, it might even be possible to generate new drivers without even touching the OS
04:37:18 <vincenz> hmm
04:37:39 <vincenz> however then the issue is that you're not building an OS in haskell, but building tools to build an os, in haskell
04:37:51 <vincenz> which is different
04:38:03 <mahogny> very different
04:38:07 <vincenz> cause you still will need to generate bindings for haskell (although the task is simplified) to these drivers
04:38:23 <apfelmus> vincent: not quite. the tools generate for any language you wish
04:38:23 <mahogny> bindings?
04:38:40 <vincenz> mahogny: well if you want a haskell OS, you need bindings to the device drivers
04:39:13 <mahogny> vincenz, you would prolly write one code generator for each OS. if you have a haskell OS, then you obviously output whatever makes more sense there
04:39:27 <vincenz> I thought the original goal was to build an os in haskell, not write a tool to map YAL (the DSL) to C/asm
04:39:54 <mahogny> house has that goal. this is just for making a unified driver system
04:40:11 <vincenz> right
04:40:15 <vincenz> at which point the question becomes
04:40:17 <vincenz> why perse haskell
04:40:20 <apfelmus> vincent: the goal should be to uncouple language, kernel and device drivers
04:40:27 <vincenz> apfelmus: tab-completion is great
04:40:29 <mahogny> I would just use haskell for the compiler
04:40:56 <vincenz> right but what you're striving for is very little haskell-oriented
04:41:01 <vincenz> namely some highlevel lang for device drivers
04:41:01 <mahogny> yes
04:41:09 <apfelmus> vincenz: sorry.
04:41:15 <vincenz> apfelmus: no worries :)
04:41:43 <vincenz> mahogny: ah alright, was confusing the two contexts
04:41:52 <vincenz> mahogny: I thoguht the original need derived from a haskell os
04:41:57 <mahogny> I wouldn't mind then if later someone writes a linux driver-to-DSL converter. that guy would be my god :)
04:42:01 <vincenz> in which case this would be the long route
04:42:15 <mahogny> the need derives from a new OS in general
04:42:29 <vincenz> mahogny: right... I would think anyone that even maps simple C to some other highlevel lang would be a god
04:42:55 <vincenz> mahogny: it's not a fundamenetal need tho
04:43:00 <mahogny> no
04:43:01 <vincenz> mahogny: just use existing drivers and make bindings
04:43:52 <vincenz> in my experience it's best to focus on the crucial item and do that instead of going on and on about more and more tools that would facilitate the job, cause eventually you lose yourself in writing all those tools and miss the original focus
04:44:56 <mahogny> well, the problem is that the tools are needed. just writing drivers won't do
04:45:03 <apfelmus> vincenz: binding writing for drity C drivers will become a pain. and if you need to change anything in the interface, you're doomed
04:45:15 <vincenz> mahogny: who says you need to write drivers
04:45:28 <vincenz> apfelmus: you just need a minimal set to support the OS on SOME platform
04:45:39 <vincenz> -then- you write tools for device drivers as you port this to other platforms
04:46:32 <apfelmus> vincenz: right, but why starting with an existing OS? you standardize too early in a dirty language
04:46:34 <vincenz> (C-drivers, manual bindings on -a- platform X) -> OS on X -> tools for drivers for * -> OS on *
04:46:39 <mahogny> the goal here is actually the drivers themselves, not the OS
04:46:44 <vincenz> hmm
04:46:46 <vincenz> mahogny: oh
04:47:20 <vincenz> apfelmus: as long as you layer it nicely, you should be able to add layers furtehr down wit hless and less of the existing OS
04:47:53 <psi> I'm trying to use c2hs's "get" hook to access a struct member, but it doesn't appear to allow the member name "type". 
04:48:06 <psi> it seems to accept other names.
04:48:11 <vincenz> but if the goal is the drivers themselves, this discussion is moot
04:48:27 <vincenz> however, mahogny, why is the focus on drivers themselves?  Seems like a nitty job with little payoff
04:48:44 <mahogny> vincenz, to simplify writing more OS in the long run
04:49:14 <psi> in the tutorial they actually use the name "type", however :)
04:49:28 <vincenz> mahogny: I guess it's a different approach
04:49:36 <vincenz> mahogny: incremental vs revolutional
04:49:44 <mahogny> vincenz, yes
04:49:51 <vincenz> :)
04:50:35 <mahogny> the problem is that you certainly can whip up a few drivers, but if you want your OS to become as commercial as linux, then you need *all* drivers at which point it is much nicer if you had all the drivers from the beginning :)
04:50:41 <vincenz> however if I may be frank, (and you can be hmm... dave), then a revolutional approach has more possibilities.  Otherwise people will say 'oh just another OS that does the same, except it's written in haskell... who cares'
04:50:57 <metaperl> lol
04:51:00 <vincenz> mahogny: right but I would start ith the core.. write an OS and manually make some bindings
04:51:04 <metaperl> great comment frank.
04:51:09 <vincenz> :D
04:51:26 <vincenz> mahogny: only when you have that working would I work on the peripherals such as device drivers
04:51:37 <vincenz> otherwise you're just another linux, except writteni n haskell
04:51:42 <vincenz> and most users won't care less 
04:51:42 <apfelmus> vincenz: i thought the other way round: the drivers don't mention any OS and as you go up/down, OS comes into play
04:52:17 <mahogny> vincenz, if the drivers are already there, then you can right away concentrate on making your OS different than just another set of drivers connected :)
04:52:18 <vincenz> basically a "spike" approach
04:52:27 <vincenz> mahogny: but they are there!
04:52:41 <vincenz> mahogny: just not written in haskell, so who cares, your final drivers won't be either, only the driver-generator
04:53:06 <vincenz> and!
04:53:07 <vincenz> if anything
04:53:09 <vincenz> by doing the OS first
04:53:12 <vincenz> and manually binding a few drivers
04:53:21 <vincenz> by the time you need the DSL, you'll have more experience in drivers
04:53:42 <apfelmus> vincenz: writing new drivers in a sane language is a lot easier than in a dirty one
04:53:45 <mahogny> that's why I would start by making DSL for an existing OS first
04:54:03 <vincenz> apfelmus: you don't need to write drivers, they exist
04:54:30 <apfelmus> vincenz: i have to if they don't fit
04:54:32 <mahogny> and yes, depending on what you mean by bindings, you would probably start off by some manual tweaking
04:54:46 <vincenz> apfelmus: add a mini wrapper to abstract it
04:54:50 <vincenz> start at the core of the OS
04:54:57 <vincenz> and slowly layer downwards to the hardware
04:55:14 <vincenz> besides
04:55:19 <vincenz> if you want to do drivers first
04:55:22 <vincenz> and what apfelmus says is right
04:55:27 <vincenz> you won't know what kind of interface you need
04:55:51 <apfelmus> vincenz: steal ideas but don't steal code...
04:56:17 <mahogny> vincenz, the interface would have to be the same as other OS use, otherwise they wouldn't be very portable
04:56:18 * vincenz shrugs
04:56:30 <vincenz> mahogny: at which point you can do the OS first and reuse existing drivers
04:57:01 <mahogny> vincenz, the problem we have today though is that drivers aren't reusable as such because of internal changes in other OS
04:57:03 <vincenz> you're trying to make a ferrari and are focussing on reinventing the wheel that exists on a sedan
04:57:15 <vincenz> that's the analogy
04:57:36 <vincenz> mahogny: wrapper it
04:57:57 <mahogny> that's considered, but not always possible
04:58:20 <vincenz> I still feel like you're taking too much of a tangential that will probably nip the project in the butt
04:58:27 <mahogny> if it was that easy, we wouldn't be in the DSL discussion in the first place :)
04:59:24 <psi> okay - it appears I cannot use c2hs to access a struct member "type" due to a bug. how should I go about doing it manually? write my own C function?
04:59:37 <vincenz> taking the analogy again... assume the wheels of the sedan don't fit perfectly... add some kind of piece in between... sure your ferrari won't be able to go fullspeed on it's trainingwheels, but at least you can focus on it, then later you can start looking at how to efficiently produce ferrariwheels
04:59:54 <apfelmus> vincenz: the drivers in house look extremely simple. it's no problem to write a tcp stack if don't have to worry how to get your packets
05:00:21 <vincenz> got a link?
05:01:00 <apfelmus> vincenz: any C driver must care for exceptions andandand, it's a mess of #define #ifdef and dirty macro tricks go get some kind of abstraction into the C code
05:01:19 <vincenz> apfelmus: so wrapper it
05:01:24 <mahogny> vincenz, I don't fully see how your analogy applies here. the idea is to replace the drivers used in linux and BSD with DSL-generated drivers that are of commercial quality. then and only then would they be used for a new OS
05:01:28 <vincenz> apfelmus: dont' work on a tool to make device drivers
05:01:40 <vincenz> mahogny: right... you're working on the design of a wheel factory
05:02:14 <vincenz> soon you'll have to worry about all sorts of wheels oyur wheel factory can produce
05:02:23 <vincenz> and completely lose sight of the ferrari you were planning to build
05:02:35 <mahogny> I'd say that's a problem you start with
05:03:15 <mahogny> and I don't see why it makes you lose track of the goal
05:03:20 <apfelmus> vincenz: well, you have to refactor the code. it's not just a matter of importing the right symbols as they already incorporate stuff relevant for the OS but irrelevant for the actual driver abstraction
05:05:20 <apfelmus> vincenz: signal() is painful, ErrorT is a joy
05:05:35 <vincenz> hmm
05:05:38 <vincenz> layer it
05:05:43 <vincenz> add some C -interface that does this
05:05:47 <vincenz> just for now
05:05:50 <vincenz> so you can work on the os
05:05:54 <shapr> What's the status of the XMPP binding?
05:07:18 <mahogny> vincenz, that would be half ideal. I think one should study what changes have been done to them over time though before rushing
05:07:43 <vincenz> maybe 
05:07:50 <vincenz> I guess it's a matter of motivation and preference
05:07:59 <apfelmus> vincenz: but you are right, "just for now" is needed to get something working quickly
05:08:21 <shapr> I'd go for something that can build drivers for House and maybe later be genericized.
05:08:24 <vincenz> I'm not saying your approach wouldn't work
05:08:35 <vincenz> just that you might lose motivation halfway through making the DSL you don't even get to the OS
05:08:55 <mahogny> vincenz, even if it only means that BSD can use linux drivers, that's a big gain
05:09:08 <mq_mattr> question
05:09:09 <shapr> I've discovered that motivation stays if the software is always workable.
05:09:22 <shapr> The biggest problems for me come when I get halfway through a rewrite and nothing works anymore.
05:09:29 <shapr> mq_mattr: answer!
05:09:31 <vincenz> I've found motivation is  ~  pay_off/work
05:09:31 * shapr boings
05:09:37 <mq_mattr> do alternatives in a case statement introduce a new binding scope.
05:09:41 <shapr> vincenz: That makes sense.
05:09:45 <vincenz> and to me device drivers have a small pay off and prolly have a lot of work
05:09:52 <mq_mattr> as in, is patt hidden in the case in this
05:10:00 <mahogny> vincenz, very true
05:10:02 <mq_mattr> func :: Int -> Int -> Bool
05:10:02 <mq_mattr> func patt arg = case arg of 
05:10:02 <mq_mattr>                   patt      -> True  -- is this patt a fresh binding variable (ie is the outer patt hidden now), the result of running this would appear to indicate so.
05:10:02 <mq_mattr>                   otherwise -> False
05:10:03 <vincenz> especially to make it complete
05:10:05 <vincenz> and not just a quick hack
05:10:35 <shapr> Depends on how much you want to use the device, I guess.
05:10:47 <shapr> I'd really like to use JHC to hack on my nokia 770
05:11:12 <mq_mattr> func patt arg = case arg of { patt -> True; otherwise -> False}
05:11:17 <mq_mattr> that's nicer
05:11:44 <mahogny> bbl
05:11:46 <mq_mattr> i seem to be missing all my question marks?
05:12:23 <vincenz> mahogny: can't do
05:12:25 <vincenz> erm
05:12:27 <vincenz> mq_mattr: can't do
05:12:31 <vincenz> patterns are not first calss
05:12:46 <mq_mattr> I know patterns are not first class
05:12:49 <mq_mattr> but 5 is
05:12:53 <mq_mattr> and it is also a pattern
05:12:54 <vincenz> then wtf is func patt arg = case arg of patt
05:12:59 <mq_mattr> as in func 5 5 
05:13:05 <vincenz> mq_mattr: you're confusing syntax for semantic
05:13:21 <vincenz> mq_mattr: that won't work
05:13:22 <mq_mattr> I just used patt and arg to indicate what they are doing
05:13:29 <cpatrick> vincenz: to be fair, it's an easy mistake to make though if you're not familiar with Haskell
05:13:33 <vincenz> cpatrick: true
05:13:42 <mq_mattr> I didn't think it would work, but I am trying to track down the rule that stops it working
05:13:56 <mq_mattr> I am familiar with Haskell.
05:14:08 <cpatrick> mq_mattr: what it does is assign a _new_ variable 'patt' to the value of arg
05:14:10 <vincenz> mq_mattr: the fact that you wouldn't be able to compile it?
05:14:19 <mq_mattr> The report gives no indication of whether the second patt would hide the first
05:14:34 <vincenz> oh like that... yes it hides it
05:14:35 <mq_mattr> it compiles
05:14:47 <cpatrick> It should give a warning though?
05:15:00 <mq_mattr> I figured it must be hiding it, but I want to know what rule is making it do that
05:15:03 <vincenz> > let foo x y = case y of (Just x) -> x | Nothing -> 1 in foo 1 (Just 2)
05:15:03 <lambdabot>  Parse error
05:15:15 <vincenz> > let foo x y = case y of {(Just x) -> x ; Nothing -> 1} in foo 1 (Just 2)
05:15:16 <lambdabot>  2
05:15:17 <mq_mattr> ie. does an alternative introduce a new binding scope
05:15:37 <vincenz> > let foo x y = case y of {(Just x) -> x ; Nothing -> x} in foo 1 (Just 2)
05:15:38 <lambdabot>  2
05:15:41 <mq_mattr> I think I am asking the wrong people
05:15:42 <vincenz> > let foo x y = case y of {(Just x) -> x ; Nothing -> x} in foo 1 Nothing
05:15:43 <lambdabot>  1
05:16:00 <cpatrick> mq_mattr: as in, you want a cite from the Haskell report?
05:16:10 <vincenz> mq_mattr: I think the examples I showed are clear... 
05:16:19 <dmhouse> vincenz: foo = const
05:16:21 <mq_mattr> well, just a rule that I can put in my head
05:16:32 <vincenz> dmhouse: the point is not top optimize
05:16:41 <mq_mattr> I was wondering if there is some desugaring, but in fact I think case is the desugared version
05:16:44 <vincenz> mq_mattr: a pattern creates a new scope with the variables in the pattern
05:16:48 <vincenz> mq_mattr: there
05:16:53 <vincenz> mq_mattr: just like a function does
05:17:04 <mq_mattr> cool
05:17:06 <mq_mattr> thanks
05:17:39 <vincenz> anyways
05:17:45 <vincenz> time to write the interpreter for my compiler :)
05:18:32 <mq_mattr> what language will it compile?
05:18:45 <vincenz> it's a mix of ML and haskell
05:19:06 <mq_mattr> hmm, sounds interesting, what bits of which?
05:19:21 <mq_mattr> is this for fun or profit(research)?
05:19:37 <vincenz> module system and recursive declaratiosn (instead of lexical scoping and shadowing of ML) from haskell, side-effects and references from ml
05:19:41 <vincenz> mq_mattr: research
05:19:46 <vincenz> tho the language is just a means
05:20:06 <mq_mattr> a compiler is no small undertaking, what is the ends?
05:20:12 <mq_mattr> are t
05:20:17 <mq_mattr> he ends
05:20:31 <vincenz> explore some source code transformations
05:20:36 <mq_mattr> I just got a new keyboard, please excuse extra enters
05:20:45 <mq_mattr> interesting
05:20:54 <vincenz> mq_mattr: it's ok... took me about two weeks, including learning how to actually do it and make my mind up regarding syntax 
05:21:11 <mq_mattr> source code transformations are something that have been on my mind lately
05:21:27 <vincenz> what kind?
05:21:29 <mq_mattr> serious, two weeks for a compiler.... that's pretty good
05:21:40 <mq_mattr> I just spent a month on an interpreter
05:21:45 <vincenz> haskell's great for compiler dev :)
05:21:47 <mq_mattr> I don't really know
05:21:54 <mq_mattr> sure is
05:22:07 <vincenz> and palomer helped me a lot by teaching me about type inference
05:22:09 <mq_mattr> just starting to get into it
05:22:32 <mq_mattr> we have another phd student looking at that and she has me interested
05:22:37 <mq_mattr> palomer?
05:22:39 <vincenz> what do you do?
05:22:46 <mq_mattr> phd student
05:22:52 <vincenz> on what subject?
05:23:10 <mq_mattr> functional programming languages :)
05:23:17 <vincenz> ah
05:23:24 <mq_mattr> more specifically some pattern matching stuff
05:23:42 * vincenz is a phd student in optimizing transformations for embedded multimedia applications
05:23:48 <vincenz> but since there's no good c++ framework around
05:23:57 <vincenz> I decided to make a mini language that contains the required semantics
05:23:59 <vincenz> and explore in there
05:24:04 <mq_mattr> what transformations?
05:24:11 <vincenz> intermediat variable removal
05:24:24 <mq_mattr> how embedded (palm, 68000, etc)
05:24:25 <vincenz> for variables more complex than scalars of course
05:24:54 <vincenz> mq_mattr: well I don't particularly look at the system, I'm too highlevel for that, but typically multimedia applications, so video/games/3D
05:25:10 <mq_mattr> interesting
05:25:10 <mq_mattr> bbl
05:25:14 <vincenz> bbl
05:34:45 <mq_mattr> bbn
05:34:48 <mq_mattr> nib
05:34:51 <mq_mattr> iabn
05:35:05 <mq_mattr> so many acronymns, none of them mean anything
05:35:12 <mq_mattr> i would be lost without wtf
05:35:20 <audreyt> wtf is wtf?
05:35:30 <mq_mattr> haha
05:35:43 <mq_mattr> audrey: a while ago you told me about tapl
05:35:58 <mq_mattr> well I am most of the way through and I have to say it is great
05:36:03 <audreyt> :D
05:36:08 <audreyt> glad to have helped
05:36:10 <jyp> @wtf wtf
05:36:12 <lambdabot> No match for "wtf".
05:36:27 <mq_mattr> a few bits have been too much for me, but the computery bits are tops
05:36:46 <mq_mattr> what book next people
05:36:48 <mq_mattr> ?
05:37:52 <audreyt> The Art of the MetaObject Protocol </heretical>
05:39:46 <lscd> what's heretical about that?
05:42:21 <audreyt> #haskell and metaobject protocol... is, like, well.
05:43:05 <lscd> pfft. disagreed
05:43:14 <lscd> they're both cool. therefore...
05:43:43 <int-e> apfelmus: ping
05:43:44 <audreyt> two cool things together becomes... icy?
05:43:56 <lscd> icy? hm. naw
05:44:43 <vincenz> mq_mattr: does TAPL deal with inference a lot?
05:44:45 <audreyt> implementing MOP on top of haskell is exciting and fine
05:44:49 <audreyt> vincenz: yes :)
05:44:51 <vincenz> mq_mattr: I only browsed through it and it seemed to do very little
05:44:58 <vincenz> audreyt: you sure?  I'll have to look at it again
05:45:10 <audreyt> but I can't quite think of what MOP _for_ haskell would mean
05:45:24 <vincenz> audreyt: it doesn't exist
05:45:32 <vincenz> MOP is for non-class based OO
05:45:40 <lscd> audreyt: maybe for o'haskell? dunno 
05:45:56 * vincenz doesn't like class based OO
05:46:07 <lscd> vincenz: why not?
05:46:13 <vincenz> it's either Type-classes all the way
05:46:17 <vincenz> or ... what's the name again
05:46:24 <vincenz> non class-based OO is ...
05:47:02 <vincenz> lscd: cause it splits two things into two abstract categories which shouldn't be separate, and then reintegrates them with ugly RTTI
05:47:19 <int-e> vincenz: prototypes?
05:47:22 <vincenz> yep!
05:47:25 <vincenz> int-e: thx
05:47:31 <vincenz> or object-based oo :)
05:47:48 <apfelmus> int-e: hi! found the proof for T ~=F(T). t: T -> F(T), u: F(T) -> T. Then t o u = F(u) o F(t) = F(u o t) = F(id)=id
05:47:51 <vincenz> but yeah it'd be interest
05:48:08 <vincenz> object-based OO, class-based OO, class-based TO and...?
05:48:09 <int-e> apfelmus: yes me too. took me an hour though and when I had it you were gone
05:48:20 * vincenz wonders what object-based TO would be
05:48:47 <vincenz> maybe subtyping
05:48:56 <apfelmus> int-e: i cheated and flipped a textbook ;-)
05:48:58 <int-e> apfelmus: (it was too obvious. I think I had convinced myself the proof would be more complicated.)
05:49:09 <mq_mattr> vincenz : yes
05:49:24 <vincenz> mq_mattr: at w<hich point object-based TO degenerates to class-based oo
05:49:33 <vincenz> interesting
05:49:48 <vincenz> so it's really a hierarchy
05:49:54 <vincenz> with three levels
05:49:57 <mq_mattr> it is all the same shit
05:50:02 <vincenz> and the traditional OOP being neither here or there
05:50:12 <vincenz> mq_mattr: class-based TO == type classes
05:50:40 <mq_mattr> I don't like to bag a language feature, normally I find out my favourite language's favourite feature is just a slight variation of the thing I jsut bagged
05:50:47 <mq_mattr> like generics in Java
05:50:48 <vincenz> mq_mattr: right of course
05:50:58 <vincenz> mq_mattr: but I prefer either cbto, or oboo
05:51:02 <vincenz> but not cboo
05:51:13 <mq_mattr> what is this to?
05:51:28 <vincenz> class based type-oriented?
05:51:32 <vincenz> aka typeclasses
05:51:35 <mq_mattr> ah
05:51:40 <mq_mattr> yeah, that is cool
05:51:56 <vincenz> and then class-based object-oriented : java, c++(parts of it) ...
05:51:59 <mq_mattr> The first two years I programmed haskell I wished it had classes
05:51:59 <vincenz> ocaml...
05:52:08 <mq_mattr> Now I wish every other language had type classes
05:52:12 <vincenz> and oboo = prototype or self
05:52:20 <mq_mattr> yeah
05:52:28 <vincenz> mq_mattr: I like either extreme, just not the middle where most defacto languages reside
05:53:11 <vincenz> cause any system in the middle tends to implement a hack to bring it closer to one of the two extreme
05:53:16 <vincenz> templates = move towards cbto
05:53:23 <mq_mattr> I do enjoy idealistic languages
05:53:25 <vincenz> RTTI = move towards oboo
05:53:32 <mq_mattr> until I try to code something real
05:53:35 <mq_mattr> then I get the shits
05:53:44 <mq_mattr> what is rtti?
05:53:50 <vincenz> run time type information
05:53:55 <apfelmus> int-e: the terminal coalgebra is actually more algebra centered than the initial algebra. i mean it is the  colimit of      X -> F(X) -> F(F(X)) -> F(F(F(X))) -> ... 
05:54:14 <apfelmus> int-e: so we have all F^n(X) -> T
05:54:15 <mq_mattr> what is that in-e thingy
05:54:28 <vincenz> int-e is a person
05:54:30 <int-e> mq_mattr: me
05:54:34 <vincenz> right
05:54:34 <mq_mattr> hello
05:54:40 <mq_mattr> you are being proven?
05:54:40 <vincenz> !int-e
05:54:48 <vincenz> mq_mattr: he's a smart bot
05:54:56 <mq_mattr> love the bots
05:55:00 <vincenz> :D
05:55:09 <mq_mattr> what is hi smart at?
05:55:25 <vincenz> I think category theory
05:55:33 <mq_mattr> jeez
05:55:40 * vincenz grins misschieveously at int-e 
05:55:42 <mq_mattr> no wonder it makes no sense
05:55:55 <sehute> hi people
05:56:01 <mq_mattr> hello there
05:56:09 <vincenz> time to move to my lappy
05:56:12 * vincenz detaches screen
05:56:25 <mq_mattr> half your luch
05:56:27 <mq_mattr> luck
05:56:46 <int-e> apfelmus: T certainly includes (a subalgebra isomorphic to) all of I.
05:56:59 <vincenz> re
05:57:50 <int-e> apfelmus: I is the limit of X <- F(X) <- F(F(X)) <- ... too, so I don't quite see what you mean.
05:58:31 <apfelmus> int-e: yes (we had I -> T last time). but the construction of T can be seen as trying to fit F(F(F(F(F(..))))) into T
06:00:09 <sehute> I've written my very first haskell-program that actually does something more than "Hello World", and I am very proud. But, as it is my very first program, I'm 100% sure that I've done a lot of things in a very akward way. Would any of you be so kind as to fix/improve/look at/critizise/praise/laugh at my program: http://www.pvv.org/~alexanro/calc.hs
06:00:34 <int-e> apfelmus: I think I know what you mean. The notation would have to be defined though. It involves a limit, and then it boils down to what we've done already.
06:00:57 <vincenz> sehute: just a sec
06:01:17 <int-e> vincenz: I wish. I got to natural transformations and never quite understood the point of adjoint functors.
06:01:34 <vincenz> int-e: heh, more than me
06:02:02 <apfelmus> int-e: (limit was    I -> diagram  and colimit  diagram -> T.)
06:02:41 <int-e> apfelmus: yes. but we get the same limit for X->F(X) already so I don't understand the point.
06:02:57 <vincenz> sehute: idigits = map ord cdigits
06:03:38 * apfelmus is confused
06:03:42 <sehute> vincenz: thanks! *looking at source*
06:04:01 <vincenz> sehute: not done yet... telling you as I go
06:04:11 <sehute> vincenz: sure :)
06:04:11 <int-e> apfelmus: err, colimit
06:04:33 <vincenz> sehute: clower is defined
06:04:40 <vincenz> > map toLower ['A'..'Z']
06:04:41 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
06:05:09 <apfelmus> int-e: the colimit T is independet of the type X we start with. that's why the terminal construction is nicer than an explicit colimit construction.
06:05:18 <int-e> apfelmus: ah
06:05:36 <vincenz> sehute: a lot of your stuff is define in Prelude infact
06:05:42 <sehute> vincenz: great
06:06:14 <int-e> apfelmus: oh, that diagram didn't define a category but was in Set. My bad.
06:06:46 <apfelmus> int-e: but the colimit somehow shows that we are interested in the following
06:07:03 <vincenz> sehute: it's also std practice to use foldr/foldl instead of fun f [] = ... fun f (a:as) = ...
06:07:04 <apfelmus> data List a = In (Maybe (a,List a))
06:07:47 <lisppaste2> torman pasted "Far from idiomatic code" at http://paste.lisp.org/display/20870
06:07:53 <apfelmus> int-e: and we want    In . In . In . In . In . .... $ x :: T  fits still in T = List a
06:08:04 <vincenz> sehute: enumerate = zip l [0..]
06:08:38 <torman> How could I make the code pasted above be somewhat easier to understand?
06:08:51 <vincenz> sehute: and regarding your todo, it's easy
06:09:00 <vincenz> has :: (Eq a) => a -> [a] -> Bool
06:09:35 <sehute> vincenz: for the first tip: map ord cdrigits, I got Undefined variable "ord"
06:09:47 <vincenz> @hoogle ord
06:09:48 <lambdabot> Char.ord :: Char -> Int
06:09:48 <lambdabot> Prelude.Ord :: class Eq a => Ord a
06:09:48 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
06:09:55 <vincenz> sehute: import Char
06:10:17 <apfelmus> int-e: ? "my diagram didn't define a category"
06:11:05 <int-e> apfelmus: you could make it into a category if you make X a variable. Just as we did for X -> F(X).
06:11:05 <vincenz> @hoogle index
06:11:06 <lambdabot> Ix.index :: Ix a => (a, a) -> a -> Int
06:11:06 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
06:11:06 <lambdabot> Data.Generics.Basics.indexConstr :: DataType -> ConIndex -> Constr
06:11:33 <SamB_XP> torman: well, you could start by giving it a more descriptive name
06:11:42 <sehute> vincenz: when I import Char, I get unexpected symbol "Main" at "module Main where"
06:11:51 <vincenz> sehute: huh?
06:11:54 <vincenz> module Main where
06:11:55 <vincenz> import Char
06:12:00 <SamB_XP> then, you could name the second function foo', where foo is whatever you decide to name the first function ;-)
06:12:02 <sehute> vincenz: I wrote that at the very top
06:12:09 <vincenz> sehute: imports go inside a module
06:12:16 <sehute> vincenz: ah, thanks
06:13:34 <apfelmus> torman: add type signatures and explain what toList is intended to do
06:14:02 <torman> SamB_XP: It creates a list from a list of tuples. What's wrong with the name toList?
06:14:30 <SamB_XP> torman: well, it looks a bit complicated
06:14:41 <SamB_XP> that, and a list of tuples is a list already
06:14:45 <sehute> vincenz: for some reason, hugs finds Syntax error in input (unexpected symbol "cdigits") for "idigits = map ord cdigits", even though it's defined right above. Any ideas?
06:15:18 <torman> SamB_XP: This is the function I need, I was wondering whether it could be made simpler (use of higher order functions/prelude).
06:15:35 <SamB_XP> torman: quite possibly!
06:16:18 <vincenz> sehute: don't know, not familiar with hug
06:16:20 <vincenz> s
06:16:37 <apfelmus> int-e: ah, i remember that i forgot the categorial meaning of diagrams (something like C^D with small D, right?)
06:16:59 <int-e> apfelmus: yes.
06:17:37 <sehute> > cdigits
06:17:37 <lambdabot>  Not in scope: `cdigits'
06:18:15 <apfelmus> torman: could you explain in words how toList is intended to shuffle the pairs?
06:18:25 <SamB_XP> toListImp [] _ = []
06:18:25 <SamB_XP> toListImp  (x:xs) v  = otherVal v x:toListImp  xs x
06:18:32 <sehute> vincenz: importing Char breaks other parts of the code, unfortunately
06:18:37 <SamB_XP> con that be replaced with a fold or something?
06:18:39 <lscd> sehute: in general, you could be using map more; lowercase = map clower (and can't you just use map toLower) ?
06:19:06 <sehute> lscd: okay, thanks. I'll look into toLower
06:19:11 <lscd> and listlen is the same as the built in function length
06:19:17 <lscd> it's in char (toLower)
06:19:55 <sehute> lscd: the built in function length returns an Int instead of Integer
06:20:01 <lscd> ahh... right
06:20:21 <sehute> lscd: I found out I'd just stick with one type, so I settled for Integer
06:20:31 <Stinger_> what? you mean you cant have more than 2 billion elements in a list?
06:20:33 <SamB_XP> @type scanl
06:20:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
06:20:37 <SamB_XP> @type scanr
06:20:38 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> [b]
06:20:58 <torman> apfelmus: it shouldn't shuffle the pairs. The order should remain the same, only one of the two values of the pairs must be thrown away. I do that by the logic as defined in the program.
06:21:04 <lscd> Stinger_: you're assuming Int is Int32 :D
06:21:24 <Stinger_> isnt it something like only 24 bits min
06:21:31 <lscd> dunno
06:21:55 <vincenz> sehute: if importing Char breaks other parts that means you're reusing function naemes, which could suggest you're rewriting the wheel a lot
06:22:09 <SamB_XP> Stinger_: well, I haven't seen an implementation with less than 32 yet ;-)
06:22:14 <sehute> vincenz: that's the reason I came here :)
06:22:24 <vincenz> sehute: well have a look at the standard libraries
06:22:28 <sehute> vincenz: I highly suspected a high degree of wheel-reinventing
06:22:30 <vincenz> @where docs
06:22:30 <lambdabot> I know nothing about docs.
06:22:36 <vincenz> @where GHC
06:22:37 <lambdabot> http://haskell.org/ghc
06:22:52 <sehute> vincenz: Well, reading through the standard libraries won't do me any good where I've just used the wrong idioms
06:23:24 <vincenz> sehute: for the rest it looks ok, except people use foldr more than fun x y z [] = ... fun x y z (a:as) = ...
06:23:44 <sehute> vincenz: thanks, I'll look into foldr, haven't used that before :)
06:24:24 <vincenz> sehute: simply said
06:24:32 <vincenz> fun x [] = Z
06:24:46 <lscd> @type (fromIntegral 3)::Integer
06:24:47 <lambdabot> Integer
06:24:56 <lscd> @type (fromInteger 3)::Int
06:24:57 <lambdabot> Int
06:25:10 <lscd> you can convert between numeric types - http://www.haskell.org/tutorial/code/part19.lhs
06:25:41 <vincenz> grr...can't talk now, system is laggy, doing a dist-upgrade
06:25:46 <SamB_XP> you know, 3 is already fromInteger 3 ;-)
06:26:02 <vincenz> liar!
06:26:10 <lscd> sehute: btw, one possible tip.. think about learning some basic scheme - things like foldr, etc are used fairly heavily there too
06:26:25 <vincenz> fun x [] = Z
06:26:28 <vincenz> fun x [] = x
06:26:28 <Stinger_> so does haskell do automatic coercing?
06:26:51 <vincenz> fun x (a:as) = fun (f x a ) as
06:26:57 <SamB_XP> Stinger_: no
06:26:58 <lscd> @type (fromInteger (3::Integer))::Int
06:26:59 <lambdabot> Int
06:27:00 <lscd> happy? :D
06:27:04 <sehute> lscd: I might do that. I've used a minimum of Lisp, previously, so foldr rings a bell somewhere.
06:27:05 <Stinger_> anyone got the haskell school of expression handy? :)
06:27:06 <vincenz> => fun x l == foldr f x l
06:27:12 <lscd> Stinger_: i do
06:27:40 <SamB_XP> Stinger_: but numeric literals are in whatever type you like, within reason
06:27:45 <Stinger_> ok in 13.4.2
06:28:02 <lscd> Stinger_: basically, there are type clasess, and the most general type gets inferred for a variable
06:28:24 <sehute> vincenz: thanks, I'll check up foldr. It's a bit hard to follow here at irc :)
06:28:32 <SamB_XP> it would be *extremely* annoying if there wasn't defaulting
06:28:38 <Stinger_> after the bit about lifting, they have an example about time + 5
06:28:55 <Stinger_> just wondering how 5 gets converted to a Behaviour
06:28:58 <torman> > fix (\x->if (length x<5) then 1:x else x)
06:28:59 <lambdabot>  Terminated
06:29:02 <torman> >fix (\x->if (length x<5) then 1:x else x)
06:29:20 <SamB_XP> @type 5
06:29:21 <lambdabot> forall t. (Num t) => t
06:29:47 <SamB_XP> Stinger_: you should find that Behaviour is an instance of Num ;-)
06:30:43 <Stinger_> does it use the fromInteger function then?
06:30:46 <lscd> Stinger_: what sam_ says - look at page 174
06:30:57 <lscd> instance Num a => Num (Behavior a) where
06:30:58 <torman> Is there a function s.t. f (g x) calls g x, then g(g x) g(g(g x)), etc, until two subsequent terms are the same?
06:30:59 <SamB_XP> Stinger_: yes ;-)
06:31:07 <SamB_XP> lscd: I'm not sam_! I'm SamB!
06:31:09 <Stinger_> right ok, thought it might
06:31:15 <lscd> sorry, tab complete
06:31:17 <Stinger_> thanks
06:31:27 <lscd> that's where + is defined for it as well
06:31:32 <SamB_XP> Stinger_: The report says something about that ;-)
06:31:34 <lscd> (+) = lift2 (+)
06:32:15 <SamB_XP> > 2^32
06:32:16 <lambdabot>  4294967296
06:32:24 <SamB_XP> > 4294967296
06:32:25 <lambdabot>  4294967296
06:32:45 <apfelmus> torman: ah, you have a list of line segments and want to make a path out of that?
06:32:49 * SamB_XP wonders how GHC implements such large literals
06:33:03 <vincenz> SamB_XP: erm... intlists?
06:33:04 <int-e> > 2^32 :: Int
06:33:05 <lambdabot>  0
06:33:14 <apfelmus> SamB_XP: libgmp
06:33:21 <Stinger_> dont make me bust out the 2 ^ 1024
06:33:38 <vincenz> > 2 ^1024
06:33:38 <apfelmus> > 2^1024
06:33:38 <lambdabot>  17976931348623159077293051907890247336179769789423065727343008115773267580550...
06:33:39 <lambdabot>  17976931348623159077293051907890247336179769789423065727343008115773267580550...
06:33:44 <Stinger_> aw truncated
06:33:48 <SamB_XP> apfelmus: well, I realize it uses libgmp for Integers, but what does it do for *literals*?
06:33:54 <vincenz> > show $ 2 ^1024
06:33:55 <lambdabot>  "1797693134862315907729305190789024733617976978942306572734300811577326758055...
06:34:00 <Stinger_> hah
06:34:01 <vincenz> > last $ show $ 2 ^1024
06:34:02 <lambdabot>  '6'
06:34:18 <vincenz> SamB_XP: literals?
06:34:33 <lscd> 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
06:34:37 <vincenz> you mean at compile time?
06:34:47 * vincenz would think the same as at runtime
06:34:49 <SamB_XP> vincenz: yes ;-)
06:34:50 <vincenz> use Integer to store em
06:35:01 <vincenz> I hardly see the issue
06:35:01 <torman> apfelmus: you see that I use last xs? It's a cycle.
06:35:19 <vincenz> > 2 ^ 65536
06:35:21 <lambdabot>  20035299304068464649790723515602557504478254755697514192650169737108940595563...
06:35:26 <vincenz> > 2 ^ 1000000
06:35:30 <lambdabot> Terminated
06:35:32 <vincenz> > 2 ^ 100000
06:35:34 <lambdabot>  99900209301438450794403276433003359098042913905418169177152927386314583246425...
06:35:38 <vincenz> > 2 ^ 500000
06:35:42 <lambdabot> Terminated
06:35:44 <vincenz> hmm
06:35:48 <torman> Is there a function s.t. f (g x) calls g x, then g(g x) g(g(g x)), etc, until two subsequent terms are the same?
06:35:54 <SamB> vincenz: well, I am curious to see what it looks like in e.g. Core
06:35:56 <lscd> SamB_XP: infinitely (well, memory-sized) ints have been around for decades
06:35:58 <apfelmus> torman: ah, you want a complete polygon then
06:36:00 <vincenz> > 2 ^ 300000
06:36:02 <vincenz> woa
06:36:03 <lambdabot> Terminated
06:36:05 <vincenz> dons: ping
06:36:17 <dcoutts_> torman, you can write your own using iterate and zipWith
06:36:28 <vincenz> dons: upgraded my system (ubuntu to dapper), now when evaluating stuff in oasisbot I get:  /usr/lib/ghc-6.4/package.conf: openFile: does not exist 
06:36:44 <vincenz> > 2 ^ 200000
06:36:47 <lambdabot> Terminated
06:36:50 <vincenz> > 2 ^ 150000
06:36:51 <lscd> length(show $ 2 ^ 300000) is 90309
06:36:53 <lambdabot>  31575453528088480246713049371391020842584400930866275873225383522686481671644...
06:36:57 <torman> dcoutts_: I will see how far I come with that. 
06:37:12 <dcoutts_> vincenz, probably you updated ghc so now oasisbot is looking for an old ghc installation
06:37:18 <dcoutts_> vincenz, try renstalling your bot
06:37:20 <vincenz> dcoutts_: ah
06:37:59 <SamB>   lit_a1S1 = fromInteger
06:38:01 <SamB>                (GHC.Num.plusInteger
06:38:01 <SamB>                   (GHC.Num.S# 2) (GHC.Num.timesInteger (GHC.Num.S# 2) (GHC.Num.S# 2147483647)));
06:38:44 <SamB> that is what I got from "ghc -ddump-ds -e 4294967296"
06:39:07 <vincenz>  2 ^ 153384
06:39:10 <vincenz> > 2 ^ 153384
06:39:13 <lambdabot> Terminated
06:39:20 <vincenz> > 2 ^ 153383
06:39:23 <lambdabot> Terminated
06:39:25 <vincenz> odd
06:39:29 <vincenz> that worked before
06:39:29 <SamB> > 2 + (2 * 2147483647)
06:39:30 <lambdabot>  4294967296
06:39:33 <vincenz> I got up to 384
06:39:39 <vincenz> > 2 ^ 153380
06:39:43 <lambdabot>  95661005494257482366340726284620453839227505680833414780649469882785164975952...
06:39:50 <vincenz> seems the 3 seconds vary
06:39:56 <lscd> very likely
06:40:12 <vincenz> > length $ show $ 2 ^ 153380
06:40:15 <lambdabot>  46172
06:40:49 <vincenz> show for Integer is funky
06:40:55 <vincenz> given how it does the ... for some values
06:40:59 <SamB> so, it seems that, as I suspected, GHC can't use literal GMP values
06:41:07 <vincenz> SamB: huh?
06:41:10 <vincenz> > 11111111111111111111111111111111111111
06:41:11 <Saulzar> vincenz, I think that's a lambdabot thing
06:41:11 <lambdabot>  11111111111111111111111111111111111111
06:41:16 <vincenz> Saulzar: I doubt it
06:41:18 <vincenz> Saulzar: look
06:41:24 <vincenz> > show $ 2 ^ 153380
06:41:28 <SamB> vincenz: look at the Core I pasted above
06:41:28 <lambdabot> Terminated
06:41:32 <vincenz> > show $ 2 ^ 153300
06:41:35 <lambdabot>  "7912892912217845019371919767863870408252339046640153689068128068934362747139...
06:41:43 <vincenz> hmm
06:41:45 <torman> fixpoint f x |f x == f(f x) = f x | otherwise = fixpoint f(f x)
06:41:51 <Saulzar> > [1..]
06:41:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
06:42:00 <Saulzar> It used to spam about 5 lines, now just one
06:42:01 <torman> dcoutts_: That works too.
06:42:11 <vincenz> Saulzar: hmm
06:42:13 <SamB> vincenz: of course, there was much much more Core than that, but that is just the relevant bit ;-)
06:42:40 <vincenz> SamB: funky
06:44:54 <vincenz> torman: there's an easier way to do that
06:45:22 <vincenz> torman: iterate the f with x then do a list selection
06:45:59 <torman> vincenz: a list selection?
06:46:08 <int-e> Saulzar: dons changed it and frankly I think it's an improvement.
06:46:10 <vincenz> @hoogle takeWhile
06:46:10 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
06:46:10 <lambdabot> Data.PackedString.takeWhilePS :: (Char -> Bool) -> PackedString -> PackedString
06:46:31 <vincenz> torman: takeWhileNotEq $ iterate f x 
06:46:37 <vincenz> torman: and then you can use other stuff
06:46:46 <vincenz> torman: takeWhileNot g $ iterate f x
06:46:54 <vincenz> torman: such as using approximations
06:47:01 <torman> vincenz: iterate generates f(x) f(f x), etc, don't I need to compare two successive elements?
06:47:07 <Saulzar> int-e, Yeah - old infinite list spamming could get over the top
06:47:07 <vincenz> torman: yes
06:47:15 <vincenz> torman: hence some function named takeWhileNotEq 
06:47:24 <SamB> vincenz: well, it seems to me that to do it any other way would require GHC to somehow write GMP values out inline, which would involve knowing the structure of them, wouldn't it?
06:47:35 <vincenz> takeWhileNotEq (a:b:xs) = if a==b then a else takeWhileNotEq (b:xs-
06:47:44 <torman> vincenz: oh, ok, because takeWhile doesn't provide that facility. 
06:47:53 <torman> vincenz: thanks
06:47:55 <vincenz> torman: and then you could pass it another function to determine accuracy
06:48:28 <torman> vincenz: accuracy?
06:48:39 <SamB> now, what I want to know is why do I get like 7 different dumps of desugared programs when I do that
06:48:39 <torman> vincenz: This is not a number problem.
06:48:41 <vincenz> torman: takewhileNot g (a:xs@(b:_)) = if g a b then a else takeWhileNot g xs
06:49:28 <shapr> Hm, how to do nub in Python?
06:51:08 <SamB> lets see, the first one seems to be turning off buffering on stdout and stderr...
06:51:21 <lisppaste2> apfelmus annotated #20870 with "with zip" at http://paste.lisp.org/display/20870#1
06:51:43 <SamB> the second one seems to be for flushing stdout and stderr...
06:52:05 <Stinger_> can you put class restraints in a lambda form?
06:52:30 <SamB> the third and fourth ones look like they are from my .ghci file, perhaps the fifth and sixth ones as well...
06:53:14 <vincenz> or even
06:53:14 <vincenz> torman: takewhileNot g (a:xs@(b:_)) = if g a b then xs else takeWhileNot g xs
06:53:14 <vincenz> @type takewhileNot g (a:xs@(b:_)) = if g a b then xs else takeWhileNot g xs
06:53:14 * vincenz pokes lambdabot 
06:53:15 <vincenz> @type let takewhileNot g (a:xs@(b:_)) = if g a b then xs else takeWhileNot g xs in takeWhileNot
06:53:15 <lambdabot> parse error on input `='
06:53:16 <lambdabot> Not in scope: `takeWhileNot'
06:53:16 <lambdabot>  
06:53:16 <lambdabot> <interactive>:1:77: Not in scope: `takeWhileNot'
06:53:17 <vincenz> @bot
06:53:17 <lambdabot> :)
06:53:19 <vincenz> lambdabot crashed
06:53:21 <vincenz> @version
06:53:21 <lambdabot> lambdabot 3.1p35, GHC 6.4.1 (Linux i686 3.20GHz)
06:53:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:53:23 <vincenz> (oh wait irssi tells me that I have > 2 mins lag)
06:53:28 <SamB> and of course the sixth one is the numeric literal I set out to see ;-)
06:53:31 <SamB> er, seventh
06:54:15 * SamB had no idea that ghc -e read .ghci
06:54:19 <vincenz> damn
06:54:24 <vincenz> wtf was that
06:54:37 <vincenz> @type takewhileNot g (a:xs@(b:_)) = if g a b then xs else takeWhileNot g xs
06:54:38 <lambdabot> parse error on input `='
06:55:04 <vincenz> @type let takewhileNot g (a:xs@(b:_)) = if g a b then xs else takeWhileNot g xs in takeWhileNot
06:55:05 <lambdabot> Not in scope: `takeWhileNot'
06:55:05 <lambdabot>  
06:55:05 <lambdabot> <interactive>:1:77: Not in scope: `takeWhileNot'
06:55:16 <vincenz> @type let takeWhileNot g (a:xs@(b:_)) = if g a b then xs else takeWhileNot g xs in takeWhileNot
06:55:17 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
06:55:40 <SamB> @type takeWhile . (not .)
06:55:41 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:56:13 <psi> yay, Haskell is playing a song through gstreamer :)
06:57:16 <Igloo> psi: Do you know about http://urchin.earth.li/darcs/ian/hgstreamer/ ?
06:57:33 <dons> @seen sjanssen 
06:57:33 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
06:57:36 <dons> sjanssen: ping
06:58:49 <psi> Igloo: I didn't. I'll have a look :)
07:00:34 <torman> vincenz: oh, I see what you mean. 
07:02:10 <vincenz> SamB: it's not that
07:02:14 <vincenz> SamB: mine uses two elems
07:02:45 <SamB> vincenz: oh, well, better not call it that!
07:03:01 <vincenz> takeUntil ?
07:03:09 <vincenz> erm
07:03:10 <vincenz> dropUntil
07:03:30 <SamB> you said "takeWhileNot"
07:03:44 <SamB> which sounds an awful lot like "taleWhile . (not .)" to me
07:04:44 <vincenz> > let dropUntil g (a:xs@(b:_)) = if g a b then xs else dropUntil g xs in dropUntil ((>) . (+))
07:04:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
07:04:45 <lambdabot>   Expect...
07:04:58 <vincenz> @pl f x y = (x+y) > 3
07:04:59 <lambdabot> f = flip flip 3 . ((>) .) . (+)
07:05:05 <vincenz> @pl f x y =  3< (x+y) 
07:05:06 <lambdabot> f = ((3 <) .) . (+)
07:06:03 <vincenz> > let dropUntil g (a:xs@(b:_)) = if g a b then xs else dropUntil g xs in dropUntil (((3<) .) . (+))
07:06:04 <lambdabot>  Add a type signature
07:06:07 <vincenz> > let dropUntil g (a:xs@(b:_)) = if g a b then xs else dropUntil g xs in dropUntil (((3<) .) . (+)) [1..]
07:06:09 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
07:10:03 <apfelmus> @djinn (a->a)->a
07:10:03 <lambdabot> -- f cannot be realized.
07:10:35 <vincenz> apfelmus: fix
07:10:38 <vincenz> @type fix
07:10:39 <lambdabot> forall a. (a -> a) -> a
07:10:55 <apfelmus> vincenz: just kidding ;-)
07:11:50 <vincenz> this really sucks
07:11:56 <vincenz> I upgraded my desktop, went smooth
07:12:00 <vincenz> now I did my laptop
07:12:01 <vincenz> and it's stuck
07:12:05 <vincenz> and I was hoping to get some useful work done
07:12:42 <Stinger_> can you assign a type signature to anonymous function parameters?
07:12:58 <vincenz> Stinger_: annotate the functio
07:13:19 <Stinger_> hmm when I tried that it said it wasnt polymorphic enough
07:13:37 <shapr> What did you try?
07:14:09 <Stinger_> (Eq v) v -> v -> v -- I guess the prob is somewhere else though
07:14:19 <Stinger_> er with the => in there
07:14:27 <vincenz> Stinger_: and the function?
07:14:31 <Stinger_> and no brackets
07:14:58 <Stinger_> its a bit long
07:15:08 <vincenz> @paste
07:15:09 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:15:13 <vincenz> @where paste
07:15:14 <lambdabot> http://paste.lisp.org/new/haskell
07:15:25 <Stinger_> well I'll put it on one line, shouldnt be too bad
07:15:32 <Stinger_> testfn = \g x -> (fix (\f (a :: Eq v) (b :: Eq v) -> if a == b then a else f b (g b))) (g x) (g(g x))
07:15:51 <Stinger_> whoops thats got the sig in the wrong place
07:17:29 <Stinger_> testfn = \g x -> (fix ((\f a b -> if a == b then a else f b (g b)) :: Eq v => v -> v-> v)) (g x) (g(g x)) -- I think thats what I roughly had : /
07:21:25 <psi> Igloo: are you working on them currently?
07:21:31 <kosmikus> Stinger_: that function works fine without any type signature
07:22:21 * vincenz wishes there was a client where commands and other functionality were first class
07:22:24 <vincenz> so I could do
07:22:31 <vincenz> . /who >>= length
07:22:51 <Igloo> psi: I haven't done or a while, but I'll probably do some more work on it in the near future
07:22:55 <vincenz> . /who >>= mapM sendMessage "HI!"
07:23:20 <Stinger_> @hoogle fix
07:23:20 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
07:23:20 <lambdabot> Control.Monad.Fix :: module
07:23:20 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
07:23:39 <vincenz> Stinger_: did you get your fix today?
07:24:51 <Stinger_> heh
07:24:52 <vincenz> Anyone here into the open source movement?
07:24:59 <lscd> define into
07:25:15 <vincenz> well I have a question regarding the economic side
07:25:21 <lscd> go wild
07:25:28 <norpan> fix ('a':)
07:25:31 <norpan> > fix ('a':)
07:25:32 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:25:34 <vincenz> I read an article in a magazine about a guy doing kernel device drivers development
07:25:46 <vincenz> and he works for Novell...cause Novell does a lot of core linux dev
07:25:51 <vincenz> how the hell do they pay for this?
07:26:00 <norpan> with money
07:26:05 <Stinger_> kosmikus if I get rid of the type I get a "Ambiguous type variable `a' in the constraint" at the == sign
07:26:29 <vincenz> norpan: well yeah but where does it come from
07:26:34 <norpan> novell sells linux
07:26:35 <psi> Igloo: ok. one question, are you manually typing out things such as enums? GstState, etc.
07:27:01 <norpan> ever heard of suse?
07:27:08 <psi> I'm using c2hs, and it has some cool features to do that automatically.
07:27:09 <vincenz> norpan: right, why would anyone pay for that?
07:27:19 <vincenz> norpan: and why would they then distribute all their hard work
07:27:20 <norpan> because they want support probably
07:27:26 <vincenz> (novell that is)
07:27:44 <vincenz> open source is a funky market
07:27:56 <norpan> they bundle som non-open-source apps too with their enterprise solution
07:28:05 <norpan> and they sell support
07:28:18 <norpan> obviously they think it will be profitable
07:28:22 <vincenz> yeah
07:28:25 <vincenz> it just seems flimsy to me
07:28:26 <Igloo> psi: Yes, partly to amke it more portable and partly to get the names I want for things
07:28:42 <lscd> vincenz: they pay for this because other people pay them for support contracts, etc
07:28:53 <norpan> it's just like why would anyone pay for someone to clean their car when they can do it themselves
07:29:06 <vincenz> I guess
07:29:14 <vincenz> just feels unstable to me :(
07:29:17 <vincenz> as a market model
07:29:24 <lscd> it's one of ibm's major ways of making money
07:29:26 <norpan> for most people it's not a market model
07:29:28 <lscd> they're not exactly small potatoes
07:29:55 <norpan> it's a way of sharing and receiving
07:30:00 <vincenz> lscd: right but it's my believe they're not small potatoes because of history
07:30:01 <norpan> communism!
07:30:05 <vincenz> lscd: not because of currentness
07:30:17 <vincenz> anyways
07:30:19 <vincenz> lappy reboot
07:30:22 <lscd> that's a factor
07:30:26 <lscd> but they've managed to stay big
07:30:30 <lscd> that's something, given their industry
07:30:34 <norpan> using linux is good for a company too, because they don't have to invest as much in it
07:30:36 <lscd> how many people have heard of honeywell these days?
07:31:11 <norpan> of course they don't have the same leverage as microsoft has, but they aren't as big either
07:31:27 <vincenz> join #oasis for this interesting Ot convo :)
07:31:38 <norpan> and if they file for bancrupcy they just pick up the source and go again :)
07:32:06 <norpan> bankruptcy?
07:35:28 <vincenz> anyone compile lambdabot?
07:35:35 <vincenz> Failed to load interface for `Shared'
07:36:03 <vincenz> anyone any clues
07:36:03 <vincenz> ?
07:37:00 <Stinger_> damn type signatures :(
07:37:35 <vincenz> how do I get an overview of cabalized packages
07:37:46 <audreyt> ghc-pkg list
07:37:50 <torman> I have two polygons, both represented by an edge list. They share exactly one edge. How can I remove that one edge and create one bigger polygon? I tried a few things, but nothing is robust. 
07:37:54 <vincenz> th
07:37:55 <vincenz> thx
07:38:08 <vincenz> funky... I can't compile lambdabot
07:38:26 <Stinger_> \f a b -> is equiv to \f -> \a b -> yeah?
07:38:34 <vincenz> yep
07:38:56 <dons> vincenz: ?
07:39:16 <dons> looks like you need to make dist clean
07:39:24 <vincenz> dons: I did
07:39:26 <dons> and build the static way perhaps
07:39:43 <dons> what error does it emit
07:39:45 <vincenz> grr...can't find Data.ByteString.Char8
07:39:45 <apfelmus> torman: first first make sure you have an exact == on edges. never compare floating point values
07:39:47 <vincenz> when making dist clean
07:39:51 <apfelmus> > 10*0.1 < 10.0
07:39:52 <dons> install fps from darcs
07:39:52 <lambdabot>  True
07:40:03 <dons> you need a recent fps to get .Char8
07:40:04 <audreyt> vincenz: if you are using ghc-6.5 you are hosed
07:40:06 <vincenz> dons: could it be that I upgraded ghc?
07:40:09 <vincenz> dons: it worked before!
07:40:14 <vincenz> audreyt: 6.4.1
07:40:19 <dons> audreyt: well, not quite. you need to delete fps from 6.5's base/
07:40:21 <audreyt> oh. that should be fine
07:40:30 * vincenz upgraded distro
07:40:35 <audreyt> dons: that is very much "hosed" to me :)
07:40:35 <dons> audreyt: but don't worry, we got the go ahead to push the lot into base/ from simon :)
07:40:36 <vincenz> ah
07:40:40 <audreyt> yay
07:40:42 <vincenz> apparently fps ain't installed anymore... that's odd!
07:40:44 <torman> apfelmus: I have, since it are edges in a graph. 
07:40:53 <vincenz> why doesn't ghc automatically take over the cabal list???
07:41:08 <audreyt> please please put other stuff outside fps/ and dissolve the fps package then :)
07:41:11 <vincenz> and how do I remove the packages?
07:41:15 <audreyt> s/dissolve/freeze/
07:41:25 <apfelmus> torman: that's a relief :-)
07:41:51 <vincenz> dons: I upgraded distro...fps-0.7 is still installed but it's not in ghc-pkg list.... how do I remove it and reinstall it to 6.4.1?
07:42:04 <dons> vincenz: will do so.
07:42:09 <dons> s/viaudreyt/
07:42:16 <torman> apfelmus: It should be an easy thing to do, but well it apparently isn't. 
07:42:19 <dons> it will be frozen once we push into base.
07:42:28 <dons> and we're almost done.
07:42:38 <dons> vincenz: rm -rf ?
07:42:54 <vincenz> dons: only /usr/local/lib/fps- right?
07:42:54 <Stinger_> w  t  f
07:43:07 <Stinger_> ok messing around with this thing cant get it to load
07:43:29 <dons> vincenz: yep, that's the only place it touches
07:43:33 <Stinger_> wait nevermind
07:43:34 <vincenz> crap
07:43:39 <vincenz> gtk2hs has same issue
07:43:40 <vincenz> grrr
07:45:58 <apfelmus> torman: looks like euler cycles in a graph? anyway, i would code: helper functions to rotate the edge list, find the common edge, rotate it in front, glue paths together
07:46:27 <apfelmus> > @type iterate
07:46:27 <lambdabot>  Parse error
07:46:33 <apfelmus> @type iterate
07:46:33 <dons> audreyt: little talk on fps i'm giving tomorrow, pugs get a mention right at the end, http://www.cse.unsw.edu.au/~dons/code/talks/lazy-fusion/fusion-talk.ps.gz
07:46:34 <lambdabot> forall a. (a -> a) -> a -> [a]
07:46:57 <audreyt> ooh
07:48:15 <torman> apfelmus: I have thought about doing it in that way, but didn't do it. Now you say it, I will try it in this way.
07:48:28 <torman> apfelmus: no euler cycles.
07:49:03 <apfelmus> > let rotate n xs = let (x,y) = splitAt n xs in y ++ x in rotate 2 [1,2,3]
07:49:03 <lambdabot>  [3,1,2]
07:49:31 <mauke> @. djinn type iterate
07:49:32 <lambdabot> -- f cannot be realized.
07:49:43 <mauke> yay!
07:50:22 <dcoutts_> dons, got some error bars
07:50:47 <dons> oh yeah?
07:50:47 <dcoutts_> dons, usually the pattern is that the first run has a different time from the rest, perhaps we should discard the first run of each
07:50:56 <dons> ok. yes, that's reasonable
07:51:02 <dons> prime the cache, as it were
07:51:18 <dcoutts_> yes, though of course we'll have to say that's what we're doing
07:51:19 <vincenz> dons: ACK
07:51:27 <vincenz> dons: a shitload of /tmp/ghc8484.hspp:1332:42: Not in scope: `P.packAddress'
07:51:41 <apfelmus> mauke: i think djinn uses [a] as an abstract functor, i.e. not much different from f a
07:52:15 <dcoutts_> dons, how should we split them for presentation, perhaps ups, downs, no accs, folds (ie len, min,max) and big
07:52:21 <dcoutts_> dons, that gives 5 graphs
07:52:31 <apfelmus> mauke: it tries to find a function polymorphic in f and a
07:52:47 <Stinger_> bah
07:52:56 <Stinger_> when I seperate it out into a fn it works ok
07:53:06 <dons> vincenz: have you pulled both the latest lambdabot and latest fps? you'll need to do so
07:53:12 <vincenz> dons: damn
07:53:16 <vincenz> dons: yeah now it's even wors
07:53:28 <dons> dcoutts_: yeah, something like that.
07:53:31 <vincenz> icfp@abstractserver:~/lambdabot$ make
07:53:31 <vincenz> config.mk:66: *** missing separator (did you mean TAB instead of 8 spaces?).  Stop.
07:53:55 <dons> vincenz: perhaps clean your tree out. you've mangled things somehow
07:54:08 <vincenz> dons: can't even clean now
07:54:20 <vincenz> @version
07:54:21 <lambdabot> lambdabot 3.1p35, GHC 6.4.1 (Linux i686 3.20GHz)
07:54:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:54:29 * dons `fmap` sleep
07:54:34 <vincenz> might want to rephrase that to --partial
07:55:46 <Stinger_> @paste
07:55:47 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:56:04 <vincenz> @where paste
07:56:04 <lambdabot> http://paste.lisp.org/new/haskell
07:56:58 <Stinger_> right, thats better :)
08:00:14 <lisppaste2> Stinger pasted "fn defn q" at http://paste.lisp.org/display/20876
08:01:18 <Stinger_> if anyone wants to answer that :)
08:01:41 <vincenz> Stinger_: monomorphism restriction
08:01:53 <vincenz> let bindings and toplevel decls are polymorphic
08:01:57 <vincenz> lambda abstractions are not
08:02:35 <vincenz> it's prolly got to do with that
08:02:47 <Stinger_> yeah well thats the error I get
08:03:05 <Stinger_> is there some way I can annotate the type of that second function to make it work?
08:03:24 <vincenz> why use lambdas?
08:03:25 <vincenz> they're ugl
08:03:26 <vincenz> y
08:03:34 <Stinger_> I'm just learning how things work
08:03:44 <Stinger_> experimenting with stuff
08:04:28 <vincenz> ghc -O -package posix -package plugins -o runplugs scripts/RunPlugs.hs
08:04:28 <vincenz> ghc-6.4.1: unknown package:plugins
08:05:33 <__phas> hi at all
08:05:38 <__phas> i need some help
08:05:54 <__phas> i have to write an application that spawns some processes
08:06:06 <vincenz> @where hs-plugins
08:06:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
08:06:20 <__phas> and knows how many of them are alive
08:06:31 <__phas> it seems like a "destructive upgrade"
08:06:44 <__phas> how can i do something like that in haskell??
08:07:20 <greenrd> __phas, IO monad
08:07:41 <vincenz> greenrd: or even ST
08:07:47 <vincenz> all you need is a list
08:07:51 <vincenz> which you modify
08:08:14 <__phas> -greenrd-, ok i guessed something using IO monad, but more precisely?
08:11:07 <audreyt> dons: very nice slides
08:15:19 <__phas> -greenrd-, i mean, if you talk about IO monad i think you are saying to store via IO the value of the living processes somewhere. but where? on a textfile seems to be very expensive, i imagine that it can be done on a memory cell, but how??
08:15:24 <vincenz> dons: I wish the settings weren't in a Config.hs...requires compilation
08:19:15 <mauke> @index IORef
08:19:15 <lambdabot> Data.IORef
08:21:44 <__phas> mauke, this IOref was intended for me? seems like what i need :D
08:23:22 <SamB> __phas: either that, or an MVar
08:25:19 <__phas> how is *bad* using something like this?
08:25:52 <Stinger_> ok in that monomorphism restricted example I gave before, is it possible at all to add a type signature in there to get it to work?
08:26:06 <dcoutts_> yes
08:26:20 <Stinger_> do you have any hints? :)
08:26:31 <dcoutts_> use the type you expect it to be
08:26:40 <Stinger_> I have :(
08:26:44 <dcoutts_> including any class consstraints
08:26:58 <Stinger_> yeah :(
08:27:01 <dcoutts_> if you've given a correct type then it will not complain
08:27:05 <SamB> well, what is the error message?
08:27:13 <dcoutts_> you've probably annotated with an incorrect type
08:27:18 <Stinger_> depends on what type I've put where
08:27:29 <SamB> that is sometimes helpful ;-)
08:27:58 <Stinger_> ok say for example I use ...
08:28:14 <Stinger_> testfn = (\g x -> ((fix (\f a b -> if a == b then a else f b (g b)) (g x) (g(g x)))) :: Eq v => (v -> v) -> v -> v
08:28:44 <Stinger_> I get a parse error cause I've forgotten a bracket.. hold on
08:29:07 <dmhouse> Stinger_: were you a Lisper in a previous life?
08:29:21 <dmhouse> that's enough brackets to last a lifetime
08:29:30 <SamB> Stinger_: you are supposed to put the type on a seperate line
08:29:33 <lscd> dmhouse: not in lisp. that's nearly hello-world ;)
08:29:44 <dmhouse> hehe
08:29:55 <Stinger_> I know, I've been adding them just to make sure everything is ordered as it should be
08:30:03 <SamB> also, you ought to use function bindings
08:31:00 <Stinger_> anyway I get an "ambiguous type var v in the constraint" error
08:31:22 <Stinger_> which points to a monomorphism restriction again
08:31:45 <SamB> the MR doesn't bug you if your functions look like functions!
08:32:05 <dcoutts_> Stinger_, i you wrote is like so it would not be a problem:
08:32:06 <dcoutts_> testfn
08:32:08 <dcoutts_> err..
08:32:14 <dcoutts_> testfn g = ....
08:32:34 <Stinger_> I know, I've got it working, but I want to know if its possible to fix it by adding a type
08:32:36 <SamB> or even:
08:32:40 <SamB> testfn g x = ...
08:32:44 <dcoutts_> Stinger_, yes, it is possible
08:33:02 <dcoutts_> testfn :: ...
08:33:05 <dcoutts_> testfn = ...
08:33:35 <SamB> but it is silly to follow = with lambda!
08:33:39 <Stinger_> what the bloody .. I swear I tried that >_<
08:33:53 <Stinger_> several times :(
08:34:30 <Stinger_> oh well, thanks : /
08:34:43 <dcoutts_> testfn :: (Eq a) => (a -> a) -> a -> a
08:35:23 * SamB thinks the MR should be replaced with a warning
08:35:38 <lscd> MR?
08:35:50 <Stinger_> monomorphism restriction
08:36:16 <dcoutts_> Stinger_, so you've got it working now by adding the type decleration?
08:36:35 <Stinger_> yeah, I thought I already tried it, must've had the wrong sig before
08:36:49 <dcoutts_> or you were using the wrong syntax
08:37:12 <dcoutts_> at one point you were doing: testfn = exp :: type
08:37:33 <dcoutts_> rather than testfn :: <type>; testfun = <exp>
08:38:22 <Stinger_> you can do that though in exprs cant you? 
08:38:48 <Stinger_> was doing something the other day like blah (fromRational(x) :: Float)
08:39:12 <dcoutts_> yes, but the polymorphic vars don't always mean what you expect
08:39:24 <dcoutts_> eg (foo :: a)
08:39:37 <dcoutts_> means (foo :: forall a. a)
08:40:22 <dcoutts_> using top level types is the simplest and most common style
08:40:49 <Stinger_> if I do :set -fno-monomorphism-restriction what I had before works
08:41:05 <Stinger_> but thats cheating so :P
08:42:22 <mauke> <+workbensh> Fear leads to anger. Anger leads to destructive assignments. Destructive assignments lead to suffering.
08:42:32 <Stinger_> hmm and it seems I cant unset that
08:43:50 <Stinger_> oh :set -fmonomorphism-restrictions does it, or am I just replacing the entire arguments string with an invalid option displacing the no-mr flag
08:44:52 <Stinger_> anyway thanks dcoutts that was driving me insane
08:44:58 <dcoutts_> np
08:47:24 <Dino_> Having more monad trouble.
08:47:50 <lisppaste2> Dino_ pasted "monad trouble" at http://paste.lisp.org/display/20879
08:48:49 <Dino_> This is a simplification of a larger program I'm working on.
08:49:07 <Igloo> Dino_: bar has type (m Bool), not Bool
08:49:29 <Dino_> In the real thing, the foo is a recursive thing calculating stuff and needs to see the result of bar repeatedly.
08:49:32 <Igloo> You might want x <- bar; if (x == True) ...
08:49:42 <Igloo> (or equivalently, if x ...)
08:50:00 <Dino_> In the real thing foo is recursive, I didn't think I could put the contents of foo in a do block so easily.
08:50:19 <Dino_> Perhaps I simplified away the real problem here..
08:54:27 <lisppaste2> Dino_ pasted "monad trouble 2" at http://paste.lisp.org/display/20881
08:54:40 <Dino_> Ok, this maybe more accurately represents the issue.
08:55:12 <mauke> you need to monadify foo
08:56:10 <Dino_> I have this vague feeling that I'm incorrectly associating monadyness with having to use a do block.
08:57:33 <Igloo> do block => monad
08:57:42 <Igloo> But you can do monadic stuff without using a do block
08:57:55 <Dino_> So.. ok, I was about to ask that. That's the only way to get this first == second out of bar.
08:58:04 <Dino_> Is with return
08:58:17 <Igloo> Yes
08:58:40 <Dino_> So something has to change in foo, but I'm not sure what.
08:59:05 <Igloo> foo also needs to be in the monad. You probably want (return c) rather than c in the first case, and for the second case to be a do block
08:59:07 <vincenz> x <- bar
08:59:12 <vincenz>   if (x == True)
08:59:15 <vincenz>   the n return 1
08:59:18 <vincenz> else return 0
09:00:11 <Dino_> I see, you can isolate the monadish stuff into those places. You don't have to wrap the entire expression for the func in a do.
09:02:11 <Dino_> But those then and else parts have to call foo again
09:04:47 <Dino_> Ok, I get it now.
09:05:35 <Dino_> otherwise's expr is also a do block, but the then and else just call foo again. Eventually the 'in the monad' return is handled by the n < 1 = return c
09:06:09 <mauke> yes
09:06:10 <Dino_> So, part of the trick here in general seems to be figuring out where you have to stay in the monad and wrap things.
09:07:07 <Dino_> Have to do it this way: ... otherwise = do { x <- bar; if (x == True) .... ?  Can't just: if (bar == True) ?
09:08:09 <Dino_> I see, because the (bar == True) isn't executing that action.
09:08:15 <Dino_> Somebody has to.
09:09:01 <Dino_> Sort of the real original problem wasn't even so much a type mismatch but really a nobody-is-executing-the-action thing.
09:10:07 <Dino_> Very helpful. Thank you very much.
09:36:24 <vincenz> dcoutts_: ping
09:36:31 <dcoutts_> @yarr!
09:36:32 <lambdabot> Arrr!
09:36:50 <vincenz> dcoutts_: I'm having issues installing gtk2hs
09:36:58 <vincenz> checking for C compiler default output file name... configure: error: C compiler cannot create executables
09:37:10 <vincenz> might htis be cause they upped the gcc to 4.0.3 in ubuntu dapper?
09:37:22 <dcoutts_> interestingly sys cpu time is minimal around 8k but user cpu time is minimal around 64k-128k
09:37:30 <dcoutts_> dons, ^^
09:37:45 <dcoutts_> vincenz, possibly
09:37:57 <dcoutts_> vincenz, check the config.log for details
09:38:28 <vincenz> configure:2291: $? = 1
09:38:28 <vincenz> configure:2314: checking for C compiler default output file name
09:38:28 <vincenz> configure:2317: gcc    conftest.c  >&5
09:38:28 <vincenz> gcc: installation problem, cannot exec 'cc1': No such file or directory
09:39:32 <vincenz> hmm
09:39:35 <vincenz> maybe I found it
09:40:29 <vincenz> yep
09:41:20 <dcoutts_> so what's wrong?
09:41:49 <vincenz> it had apparently not installed all of gcc which I had before
09:42:26 <SamB> dcoutts: oh, is there a good widget for board games?
09:42:29 <vincenz> dcoutts_: probably you know this already but: my compiler works \o/
09:42:57 <dcoutts_> vincenz, oh good, well done
09:43:01 <SamB> such as, say, a canvas widget of some kind?
09:43:06 <SamB> dcoutts_, even?
09:43:25 <dcoutts_> SamB, DrawingArea if you want to draw your own stuff
09:43:36 <SamB> but I don't actually want to draw it!
09:43:43 <SamB> I just want to say what I want drawn
09:44:02 <dcoutts_> SamB, or is it's very simple, eg noughts & crosses then just a table of image widgets will do
09:44:15 <SamB> not quite that simple, no :-(
09:44:20 <vincenz> SamB: make a nice board module on top of drawingarea
09:44:26 <vincenz> SamB: and then share it on haskell-cafe :)
09:44:28 <dcoutts_> SamB, then you'll need to draw it yourself
09:44:45 <dcoutts_> there is no canvas api at the moment, feel free to design one
09:44:45 <SamB> there seems to be a third-party widget for this, can I wrap it?
09:44:55 <dcoutts_> really? what's that
09:45:11 <dcoutts_> you don't mean GnomeCanvas I hope...
09:45:32 <SamB> oh, was it gnome canvas?
09:45:40 * SamB forgot where he found it
09:45:42 <dcoutts_> the problem with a canvas api is that everyone thinks it should be different
09:46:03 <SamB> in what way?
09:46:14 <dcoutts_> SamB, a simple canvas api isn't that hard though, see the SOE implementation
09:46:45 <dcoutts_> that provides a declarative api on top of a direct drawing api
09:46:56 <dcoutts_> you might like something similar
09:47:11 <SamB> yeah, I was thinking about that sort of thing...
09:47:28 <SamB> so nobody has wanted to draw things on top of one another before?
09:47:31 <dcoutts_> SamB, my point is that everyone has a different idea of what operations a canvas api should support
09:47:46 <SamB> point...
09:48:09 <dcoutts_> xerox and I were planning a pure cairo api, which would make a declarative canvas api easier to do
09:48:10 <SamB> but I would like just about anything that lets me not have to worry about expose events, as long as it isn't too slow
09:48:33 <dcoutts_> yes, the object intersection stuff can get quite complex in the general case
09:49:02 <dcoutts_> anyone got any quad tree code lying about?
09:49:21 <vincenz> dcoutts_: hmm lemme chec
09:49:35 <vincenz> yes
09:50:02 <vincenz> http://oasis.yi.org:8080/repos/haskell/icfp05/Grid.hs
09:50:08 <SamB> I'd also prefer to be able to do destructive update ;-)
09:50:20 <dcoutts_> SamB, what does that mean then?
09:50:53 <dcoutts_> vincenz, the icfp05 dir doecn't seem to exist
09:50:56 <SamB> or maybe I'd rather not have to do desctructive update...
09:51:00 <vincenz> lemme check
09:51:02 * SamB is confused
09:51:10 <vincenz> hoops
09:51:11 <vincenz> whoops
09:51:23 <vincenz> http://oasis.yi.org:8080/repos/icfp05/Grid.hs
09:51:41 <SamB> what I'd like would be to be able to do it purely, and have the canvas thingy figure out how update destructively ;-)
09:52:04 <dcoutts_> SamB, I don't know what you mean
09:52:21 <SamB> well, rather than redraw everything...
09:52:22 <vincenz> could prolly use some cleaning
09:52:32 <SamB> just ignore my incoherent ramblings...
09:52:44 <dcoutts_> SamB, you mean when you change the attributes of some object
09:52:55 <SamB> or add one, or remove one...
09:53:01 <dcoutts_> SamB, so one has to figure out the bounding box of the change
09:53:08 <dcoutts_> and invalidate that
09:53:12 <vincenz> dcoutts_: lemme know your thoughts
09:53:51 <dcoutts_> vincenz, so it's non-overlapping box packing
09:54:08 <vincenz> dcoutts_: no basically I split either horizontally or vertically at each time
09:54:15 <vincenz> depending on what gives the most gains
09:54:19 <dcoutts_> ah ok
09:54:28 <SamB> oh, isn't that called a bintree?
09:54:41 <vincenz> so not quite quadpack, but the effect is the same
09:54:53 <dcoutts_> however we want to keep a quad tree of bounding boxes, not points
09:54:58 <vincenz> oh
09:55:12 <dcoutts_> the general case is a bit tricky
09:55:15 * SamB has no clue how to implement all that
09:55:22 <vincenz> shouldn't be too hard should it?
09:55:33 <dcoutts_> which is another reason there arn't that many canvas apis about
09:55:42 <SamB> I can either write something like C, or I can just use the SOE style...
09:55:45 <dcoutts_> many applications can get away with non-overlapping objects
09:56:07 <dcoutts_> vincenz, not sure to be honnest
09:56:12 <vincenz> dcoutts_: what's the structure you need?
09:56:34 <vincenz> can we assume a relative coordinate system?
09:56:38 <dcoutts_> vincenz, something that allows you to effeciently find the bounding boxes that intersect a paroticular box
09:56:41 * SamB wonders how to do the layering
09:57:05 <vincenz> so you want to store boxes in this quad thing
09:57:19 <dcoutts_> vincenz, so when I need to redraw a rectange of the screen I can quickly find the objects that intersect it.
09:57:28 * vincenz ponders
09:57:40 <vincenz> do you know your max x and max y?
09:57:41 <dcoutts_> in the non-overlapping case we can do it easily
09:57:55 <SamB> does wxHaskell by any chance have a canvas widget of some kind?
09:57:57 <vincenz> dcoutts_: cause you never intersect?
09:58:00 <dcoutts_> vincenz, you mean is it bounded or not
09:58:04 <vincenz> dcoutts_: yep
09:58:28 <dcoutts_> vincenz, preferably unbounded, but in practice most applications will use a bounded area
09:58:30 <dcoutts_> does it matter?
09:58:38 <dcoutts_> SamB, I don't think so
09:58:39 <vincenz> it might if you want to extend it
09:58:46 <vincenz> dcoutts_: imagine a perfect quad break down of something
09:58:56 <vincenz> dcoutts_: and then you add an object that partially resides outside the outermost box
09:58:59 <SamB> wxWidgets has none?
09:59:11 <dcoutts_> SamB, go take a look
09:59:19 <SamB> oh, good idea ;-)
09:59:20 * vincenz hears the whip crack
09:59:33 <dcoutts_> vincenz, hmm, yes I see
09:59:47 <vincenz> dcoutts_: even worse... first you add one overlapping to the left, then to the right
10:00:09 * vincenz starts with an object
10:00:21 <vincenz> data Box a = Box !Int !Int !Int !Int !a
10:00:23 <vincenz> that good for you?
10:00:29 <dcoutts_> yep
10:00:51 <vincenz> are you building this quad from a list of objects
10:00:53 <vincenz> or slowly adding them?
10:01:10 <vincenz> in the first case you can get bounds calculations pre-addition
10:01:35 <vincenz> @hoogle (<)
10:01:36 <lambdabot> Did you mean: (<)
10:01:36 <lambdabot> Prelude.undefined :: a
10:01:36 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:03:20 <dcoutts_> vincenz, I think we'd want to be able to add more later
10:03:34 <SamB> yes, certainly!
10:03:44 <SamB> what if someone builds a house on their property!
10:03:50 <dcoutts_> so we may need to add more top level boxes as you put objects further and further away from the origin
10:04:04 <vincenz> overlap (Box aminx aminy amaxx amaxy _) (Box bminx bminy bmaxx bmaxy) =
10:04:11 <vincenz> help me define the logic of this?
10:04:20 <vincenz> whoops add an _ for the second box
10:04:25 * vincenz adds record syntax
10:04:51 <SamB> okay, so wxHaskell is a middle-level GUI library. what is a high-level GUI library?
10:05:09 <dcoutts_> SamB, one that doesn't use the IO monad so much
10:05:21 <dcoutts_> that allows ou to describe GUIs declaratively
10:05:33 <dcoutts_> so both Gtk2Hs and wxHaskell are mid-level, not high level
10:05:44 <SamB> oh, you mean it would only use the IO monad for handlers?
10:05:58 <dcoutts_> there needn't be a concept of handler
10:06:12 <dcoutts_> that's a very imperitive event/time-driven concept
10:06:25 <SamB> there would have to be some way of using it with IO, if it is to be useful!
10:06:59 <dcoutts_> perhaps only at the top level
10:07:06 <dcoutts_> runGUI :: ... -> IO ()
10:07:14 <vincenz> how does this look
10:07:19 <vincenz> overlapX :: Box a -> Box a -> Bool
10:07:19 <vincenz> overlapX a b = (minx a) <= (minx b) && (maxx a) >= (minx b) || (minx b) <= (minx a) && (maxx b) >= (minx a)   
10:07:28 <SamB> no, I mean, there should be a way to do IO in it without using unsafePerformIO
10:09:28 <vincenz> dcoutts_: another question: how deep does the quad tree need to go?
10:09:48 <vincenz> cause otherwise
10:09:57 <vincenz> you can just filter a list of boxes with overlap
10:10:13 <vincenz> filter (overlap mybox) boxlist
10:11:37 <vincenz> http://oasis.yi.org:8080/repos/haskell/random/Quad.hs
10:11:44 <dcoutts_> vincenz, but that gives linear time, we want log time
10:11:56 <vincenz> so split until no longer overlap
10:12:02 <vincenz> that can get expensive if two boxes differe only slightly
10:12:09 <dcoutts_> however some objects do overlap!
10:12:16 <vincenz> I mean
10:12:23 <vincenz> split until you can have a dividing line between two boxes
10:12:48 <vincenz> [A | [B |A] | B]
10:12:49 <vincenz> like that
10:12:55 <dcoutts_> we'd probably have some cut-off limit
10:13:09 <dcoutts_> so if there are N objects in a box we stop there
10:13:16 <dcoutts_> if there are more than N we subdivide
10:13:20 <vincenz> that's a faulty logic
10:13:22 <dcoutts_> then we tune N
10:13:28 <vincenz> if you have N+1 objects that overlap perfectly
10:13:32 <dcoutts_> mm
10:14:00 <vincenz> how many objects do you expecT?
10:14:14 <dcoutts_> hundreds I guess
10:14:37 <vincenz> I doubt that would give gains with a quadtree
10:14:42 <vincenz> cause your logic is more complicated
10:14:58 <dcoutts_> depends on how complex the objects are to redraw
10:15:04 <vincenz> not that
10:15:05 <vincenz> I mean
10:15:08 <vincenz> quad vs list 
10:15:22 <dcoutts_> right, but one is linear, one should be log
10:15:25 <vincenz> right
10:15:49 <dcoutts_> but yes, if the constant factors are high then the list version will be better for smaller cases
10:16:02 <vincenz> whhy not stick to list until you find it's a bottleneck?
10:16:15 <dcoutts_> because we don't have a particular app
10:16:20 <vincenz> hmm
10:16:23 <dcoutts_> so we can't predict the scene complexity or size
10:16:27 <vincenz> this is for gtk2hs?
10:16:32 <dcoutts_> I'm not planning on doing it now... :-)
10:16:45 <dcoutts_> SamB, brought it up, I was just thinking
10:17:07 <dcoutts_> vincenz, right, for a hypothetical canvas api on top of cairop
10:17:11 <dcoutts_> cairop/cairo
10:17:20 * vincenz reads typese ;)
10:18:02 <vincenz> I guess it depends
10:18:06 <vincenz> you can go far with quadtrees
10:18:17 <vincenz> for instance not making them symmetrical
10:18:26 <vincenz> and then there's the tradeoff : creation cost vs access cost
10:18:28 <vincenz> I think
10:27:27 * SamB looks for threading hack
10:32:46 <vincenz> anyone have any experience with ast-based interpreters?
10:33:33 <apfelmus> vincenz: what's this?
10:34:19 <vincenz> apfelmus: ?
10:34:36 <lscd> any recommendations for an introductory book on lambda calculus?  i've read the wikipedia article, and know basically high-school-level math
10:34:48 <dmhouse> lscd, Types and Programming Languages is meant to be good.
10:34:57 * dmhouse still needs to see if his library has that book
10:35:01 <vincenz> lscd: the tapl I mentioned
10:35:02 <lscd> dmhouse: hmm, ok
10:35:07 <lscd> okdokie
10:35:27 <Kasperle> lscd: i could look for some videos from a lecture on functional programming
10:35:29 <apfelmus> vincenz: i mean "ast"
10:35:40 <lscd> Kasperle: that would be cool, thank you
10:35:50 <vincenz> apfelmus: abstract syntax tree?/
10:36:31 <lscd> vincenz: yes
10:36:51 <Kasperle> lscd: first of all, the link: http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
10:37:13 <dmhouse> wonderful, no libraries in my county have it.
10:37:23 <lscd> dmhouse: yeah... that's my usual situation with everything
10:37:32 <Kasperle> the videos starting with 2005-SS-FP.V... are from the lectures. i'll just look through my notes to see where the guy started doing lambda calculus
10:37:32 <Lokadin> say is http://yorku.ca down?
10:37:46 <lscd> Kasperle: ehm - are they in german?
10:37:48 <Kasperle> lscd: also, the "low" quality videos are all you need.
10:37:52 <Kasperle> lscd: no, english lecture
10:37:57 <dmhouse> lscd, once I get to university, things will be better : )
10:38:07 <lscd> dmhouse: i'm at university, and things aren't better :D
10:38:10 <apfelmus> vincenz: ah, there are too many abbreviations for me to remember :-)
10:38:29 <lscd> even when things are available in zurich, which is rare, they take forever to get here
10:39:27 <Kasperle> lscd: starting from the end of V19/beginning of V20
10:39:56 <lscd> ok, thanks
10:40:35 <dmhouse> Kasperle: you said there was a lower quality version?
10:41:07 <lscd> dmhouse: yeah, there are two versions
10:41:12 <lscd> ~700 megs vs ~500
10:41:20 <dmhouse> ah, i see.
10:41:24 <lscd> the lower ends with _low
10:43:19 <dmhouse> Kasperle: thanks. :)
10:51:31 <lscd> btw, on http://www.haskell.org/haskellwiki/Books_and_tutorials the link to An Introduction to Functional Programming Systems Using Haskell is broken; http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=0521277248 seems to be the current url
10:53:40 <dcoutts_> lscd, you can fix the link, it is a wiki afterall
10:54:06 <lscd> dcoutts: not without logging in, as far as i could tell
10:54:15 <lscd> if it allowed open edits, i would have
10:54:19 <dcoutts_> lscd, then log in :-)
10:54:24 <lscd> if it involves signing up? it's easier to mention it here, where presumably people have accounts
10:54:41 <dcoutts_> it takes all of 20 seconds to log in
10:55:08 <dcoutts_> just think of a username and passwd
10:58:46 <dcoutts_> lscd, are you going to do it or should I?
10:58:54 <lscd> i'm doing it
10:58:58 <dcoutts_> ok, great
10:59:03 <lscd> i'm not -quite- as fast as you at thinking of usernames :)
10:59:08 <dcoutts_> :-)
10:59:08 <lscd> or passwords, for that matter
11:01:31 <lscd> fixed :)
11:02:04 <dcoutts_> ta
11:02:08 <lscd> np
11:02:08 <goron> Debug.trace "foo" expression is only evaluated when expression is needed, right?
11:02:12 <lscd> it's a hugely useful page
11:02:37 <dcoutts_> goron, right
11:03:06 <goron> I am debugging something... but the bugs just won't go away :( 
11:03:37 <lscd> what're you debugging?
11:04:41 <goron> lscd: something experimental
11:04:52 <lscd> mmk
11:05:27 <goron> lscd: ?
11:05:33 <lscd> nothing
11:05:48 <vincenz> hmm
11:05:48 <vincenz> (\f -> [n | (Top n qid') <- S.toList $ dependencies f], qid' == qid)
11:05:56 <vincenz> why does it say it can't find qid' in the scope???
11:06:04 <vincenz> ack
11:06:07 <vincenz> misplaced comoma
11:08:28 <goron> There is something horribly wrong....
11:09:08 <dmhouse> goron, there is?
11:10:02 <dcoutts_> vincenz, because you meant: (\f -> [n | (Top n qid') <- S.toList $ dependencies f, qid' == qid])
11:10:18 <goron> dmhouse: yes, btw, your thing only worked on your examples, but I managed to make it work.
11:10:31 <dmhouse> goron, oh? what was wrong with it?
11:10:58 <vincenz> dcoutts_: yeah
11:11:00 <goron> dmhouse: Well, I got empty lists, IIRC.
11:11:09 <dmhouse> hmm
11:11:15 <dmhouse> how did you fix it?
11:11:27 <goron> dmhouse: I will msg you the code, ok?
11:15:59 <goron> Is there some graphical debugging tool already available for Haskell?
11:16:06 <vincenz> > if True then 1
11:16:07 <lambdabot>  Parse error
11:16:09 <vincenz> > if True then 1 else 2
11:16:10 <lambdabot>  1
11:19:28 <goron> @type any
11:19:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:19:33 <goron> @type all
11:19:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:20:31 <mabillama> @where yaht
11:20:32 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
11:23:43 <vincenz> @type ($)
11:23:44 <lambdabot> forall b a. (a -> b) -> a -> b
11:24:08 <mauke> ($) = id
11:26:26 <vincenz> mauke: I know
11:26:30 <vincenz> but I needed the full type for my language
11:26:52 <dmhouse> mauke: not quite
11:26:55 <dmhouse> > ($) 4
11:26:56 <lambdabot>  add an instance declaration for (Num (a -> b))
11:26:57 <dmhouse> :)
11:27:04 <vincenz> anyone know the fixity of . ?
11:27:15 <vincenz> ah
11:27:15 <vincenz> 9
11:27:16 <dmhouse> vincenz: :i (.) will tell you
11:27:28 <apfelmus> @info (.)
11:27:29 <lambdabot> Unknown command, try @list
11:27:44 <dmhouse> apfelmus: in GHCi :)
11:27:53 <dmhouse> although a @fixity plugin would be nice
11:27:54 <mauke> > let ($) :: (a -> b) -> a -> b; ($) = id in ($) 4
11:27:54 <lambdabot>  add an instance declaration for (Num (a -> b))
11:27:57 <dmhouse> @fixity (.)
11:27:57 <lambdabot> Unknown command, try @list
11:28:00 <dmhouse> nope.
11:28:03 <mauke> dmhouse: ^
11:28:22 <dmhouse> mauke: 
11:28:23 <vincenz> @type (.)
11:28:24 <dmhouse> > id 4
11:28:37 <dmhouse> someone is tying up lambdabot.
11:28:42 <vincenz> not me
11:29:17 <apfelmus> dmhouse: hehehe... ;-) 
11:29:21 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
11:29:23 <lambdabot>  4
11:29:27 <dmhouse> > id 4
11:29:28 <lambdabot>  4
11:29:30 <dmhouse> > ($) 4
11:29:31 <lambdabot>  add an instance declaration for (Num (a -> b))
11:29:35 <dmhouse> clearly not the same function.
11:29:41 <dmhouse> (they are, up to types).
11:30:21 <mauke> @. djinn type (.)
11:30:22 <lambdabot> f a b c = a (b c)
11:30:41 <vincenz> next item
11:30:45 <vincenz> pushing A.B.C.d into the lexer
11:30:47 <vincenz> instead of parser
11:30:49 <vincenz> so I can use .
11:30:52 <vincenz> as operator
11:30:54 <dmhouse> @. djinn type ($)
11:30:55 <lambdabot> f a = a
11:30:59 <mauke> pwnd
11:31:06 <dmhouse> hah :P
11:31:09 <bolrod> ?
11:31:25 <dmhouse> mauke: but as I say, they're the same up to types.
11:31:39 <vincenz> hmm
11:31:42 <vincenz> maybe I should use #
11:31:43 <vincenz> for modules
11:31:44 <vincenz> and .
11:31:47 <vincenz> for (.)
11:32:11 <vincenz> otherwise I'm nto certain how to lex
11:32:13 <vincenz> A.B.c
11:32:27 <dmhouse> lscd, did you download that video from Kasperle?
11:32:52 <mauke> @. djinn type foldr
11:32:53 <lambdabot> f _ a _ = a
11:33:21 <heatsink> >fmap (+1) $ Data.Set.fromList []
11:33:25 <heatsink> > fmap (+1) $ Data.Set.fromList []
11:33:25 <lambdabot>  Not in scope: `Data.Set.fromList'
11:33:43 <heatsink> hm.
11:33:44 <norpan> vincenz: longest lexeme rules
11:33:54 <dmhouse> heatsink: i don't think Data.Set is a monad, is it?
11:33:55 <fiete> Hi! I have a noobish question: ghc complains about a type error. Inferred type is "Module". As far as I can see I havent used this type. I cant find anything about that type. Help?
11:34:03 <heatsink> Anyway, is there a reason Data.Set.Set isn't a functor?
11:34:03 <vincenz> norpan: how do you write that?
11:34:05 <dmhouse> @instances-importing Data.Set Monad
11:34:06 <lambdabot> [], ArrowMonad a, WriterT w m, Writer w, ReaderT r m, Reader r, StateT s m, State s, RWST r w s m, RWS r w s, ErrorT e m, Either e, ContT r m, Cont r, Maybe, ST s, IO
11:34:10 <vincenz> heatsink: uho...
11:34:11 <norpan> fiete: paste the full error
11:34:14 <vincenz> heatsink: that's a long philosophical discussions
11:34:16 <dmhouse> heatsink: hmm, no, not really.
11:34:20 <dmhouse> vincenz: it is/
11:34:41 <heatsink> vincenz: It's been discussed before?
11:35:13 <norpan> heatsink: meinly because fmap won't preserve the structure
11:35:34 <norpan> mainly
11:35:45 <dmhouse> norpan: what do you mean?
11:36:01 <fiete> here it is: http://nopaste.debianforum.de/3341
11:36:43 <vincenz> heatsink: yes
11:36:56 <norpan> dmhouse: fmap (f' . f) s where f' is the inverse of f /= id
11:37:06 <vincenz> heatsink: the issue is simple... for the moment being. fmap is structure preserving, that is not the case for set
11:37:22 <norpan> rather
11:37:31 <vincenz> imagine
11:37:33 <vincenz> fmap abs
11:37:34 <norpan> fmap f' . fmap f $ s
11:37:38 <vincenz> on a set of integers
11:37:47 <vincenz> norpan: I have used that argument, but it's not valid
11:37:53 <vincenz> norpan: cause if a fucntion is inversible, it's one-to-one
11:37:59 <fiete> norpan: where does this Module type come from. Never seen before
11:38:00 <vincenz> norpan: and in that case #elems remains the same
11:38:27 <vincenz> dmhouse: simple example: fmap abs [-10..10]
11:38:31 <norpan> let's just say it doesn't fulfil the law fmap (f.g) = fmap f . fmap g
11:38:32 <vincenz> dmhouse: simple example: fmap abs $ S.fromList [-10..10]
11:38:34 <heatsink> Does the hidden structure of the set matter?
11:38:38 <mauke> fiete: I'd like to see your whole program
11:38:39 <dmhouse> aah.
11:38:39 <vincenz> norpan: actually it does
11:38:41 <dmhouse> clever.
11:38:43 <vincenz> norpan: but it's not structure preserving
11:38:45 <norpan> vincenz: no
11:39:01 <vincenz> norpan: look I have argued from your side of the thing... and I'm still on your side, but THAT specific argument is invalid
11:39:38 <norpan> let's say i have fmap (sub 1) . fmap (add 1) on the set of [1,2]
11:39:45 <norpan> then i will end up with [2]
11:39:48 <vincenz> norpan: no
11:39:51 <vincenz> you still get [1,2]
11:39:58 <norpan> will i?
11:40:00 <vincenz> yes
11:40:07 <vincenz> [1,2] -> [2,3] -> [1,2]
11:40:08 <norpan> ok, another example
11:40:13 <fiete> mauke: very kind of you, but I really dont want to waste your time
11:40:21 <vincenz> norpan: trst me, I've thought about this a lot, the fmap law is preserved, but there are just side conditions
11:40:33 <vincenz> like the structure changing
11:40:37 <vincenz> and the #elems changing
11:40:45 <norpan> ok maybe it's preserved
11:40:55 <vincenz> it's just not a sufficient condition for fmap in most people's intuition
11:41:00 <vincenz> and that's where set fails to meet the specs
11:42:18 <vincenz> norpan: it's got to do with surjectivity and all that... kinda hard to explain
11:42:28 <norpan> i understand why
11:42:33 <vincenz> if you awnt I can do it, but it'll take a while
11:43:03 <vincenz> anyways fmap laws is preserved, unless you do inplace changing
11:43:06 <vincenz> which is an implementation issue
11:44:24 <heatsink> well alright, I can kinda see why sets are different then.
11:44:46 <dmhouse> sets are different because of the semantic of no-repeated-elements
11:45:39 <fiete> mauke: The error is in Main.hs, line 33: http://www.tzi.de/~florian/imp_err.tar.gz
11:45:41 <dmhouse> just as fmap f . nub . fmap g isn't necessarily fmap (f . g) on lists, fmap f . fmap g isn't necessarily fmap (f . g) on sets.
11:45:46 <dmhouse> yeah?
11:45:51 <heatsink> oh I see.
11:46:00 <dmhouse> vincenz: is that correct?
11:46:23 <fiete> mauke: omg - my stupid program posted on the haskell channel
11:46:59 <vincenz> dmhouse: yep but that law isn't a required one, but an apt way of putting it :)
11:47:19 <dmhouse> fmap f . fmap g == fmap (f . g) is a functor law.
11:47:26 <vincenz> dmhouse: and that is preserved even for sets
11:47:40 <vincenz> dmhouse: that's where the shoe doesn't fit
11:47:41 <dmhouse> you've just given me two contradictory responses :)
11:47:48 <vincenz> no I haven't
11:47:58 <vincenz> fmap (f .g) is held for sets
11:48:07 <vincenz> but hte problem is that the other intuitive thing held for fmap isn't ke
11:48:11 <vincenz> which is structure equivalence
11:48:16 <vincenz> s/ke/kept
11:48:26 <vincenz> and there's no clear way to quantify that other thing
11:49:04 <dmhouse> i think you're wrong
11:49:09 <vincenz> in what way?
11:49:14 <dmhouse> set f = (+1) and g = abs
11:49:24 <int-e> hmm? Set has an Eq instance and indeed if s==s' then fmap f (fmap g s) == fmap (f . g) s'
11:49:26 <vincenz> dmhouse: it still holds
11:49:32 <vincenz> dmhouse: trust me
11:49:57 <vincenz> oh wait
11:50:00 * vincenz ponders
11:50:03 <vincenz> \o/
11:50:15 <mauke> fiete: main :: FilePath -> IO (Result ParseError Absy.Module) <- there's your Module type
11:50:19 <int-e> Of course, some people aren't happy with Eq instances that compare structurally different things as equal ...
11:50:24 <vincenz> dmhouse: great!
11:50:31 <vincenz> dmhouse: at last a counter example to the law
11:50:43 <vincenz> @karma+ dmhouse 
11:50:44 <lambdabot> dmhouse's karma raised to 1.
11:50:54 <dmhouse> wait
11:50:55 <dmhouse> is it?
11:50:58 <vincenz> yes
11:51:05 <heatsink> fmap ((+1) . abs) ?
11:51:11 <vincenz> assume [-1,0,1]
11:51:17 <vincenz> fmap abs -> [0,1]
11:51:22 <vincenz> fmap +1 -> [1,2]
11:51:32 <fiete> mauke: uff Im sorry
11:51:33 <vincenz> hmm
11:51:35 <vincenz> wait...
11:51:38 <int-e> it isn't.
11:51:41 <vincenz> nope
11:51:43 <dmhouse> then fmap ((+1) . abs) Z = { 1, 2 ... }, but fmap (+1) $ fmap abs Z = fmap (+1) { 0, 1, ... } = { 2, 3, ... }
11:51:49 <vincenz> nope
11:51:56 <vincenz> dmhouse: wrong order
11:52:00 <int-e> the law is true for set theoretic sets f(g(M)) = (f.g)(M) ... so it better be true for Set-s.
11:52:14 <vincenz> dmhouse: yeah the law still holds
11:52:19 <vincenz> dmhouse: abs is always done first
11:52:41 <vincenz> int-e: then we need another law which encapsulates where the shoe doesn't fit for Set
11:52:44 <dmhouse> int-e, and trivially fmap id == id, so Set is a functor.
11:52:48 <vincenz> int-e: except that talking about structure is rather...nonabstract
11:53:01 <fiete> mauke: Should really have found this error myself, since in fact I invented this type. Thank you!
11:53:03 <dmhouse> vincenz: exactly what type of structure _are_ you talking about?
11:53:16 <int-e> vincenz: as I said, it fits for Set's Eq instance.
11:53:17 <vincenz> dmhouse: fmap a list, #elem output == #elem input
11:53:28 <vincenz> fmap a map, idem
11:53:33 <vincenz> fmap a monad, idem but less clearly
11:53:35 <dmhouse> #elem? huh? huh?
11:53:35 <vincenz> fmap a set, nope
11:53:40 <vincenz> dmhouse: length for list
11:53:57 <vincenz> "number of elements"
11:54:04 <dmhouse> oh.
11:54:10 <vincenz> in fact more is retained
11:54:14 <vincenz> the exact structure is retained
11:54:18 <vincenz> for each element being applied
11:54:20 <vincenz> it's put back at the same place
11:54:23 <dmhouse> that's not a well-defined property for all functors, though.
11:54:28 <dmhouse> think Maybe.
11:54:28 <vincenz> no
11:54:35 <vincenz> dmhouse: it holds for Maybe
11:54:43 <vincenz> Nothing -> Noting
11:54:45 <vincenz> Just x -> Just y
11:54:48 <vincenz> structure is kept
11:54:58 <dmhouse> oh, right, yeah.
11:55:01 <vincenz> dmhouse: basically take any ADT, and replace the values by (f value)
11:55:05 <vincenz> dmhouse: for Sets that's not valid
11:55:23 <vincenz> 1) structure cahnges (where the output elements are placed w.r.t their input values), and so doesthe size
11:55:28 <heatsink> @type (\f -> return . f)
11:55:29 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b) -> a -> m b
11:56:05 <vincenz> dmhouse: and most people expect that cause they're mapping individual elements..
11:56:08 <apfelmus> @type (\f -> return . f . return)
11:56:09 <lambdabot> forall (m :: * -> *) c (m1 :: * -> *) a. (Monad m, Monad m1) => (m1 a -> c) -> a -> m c
11:56:16 <heatsink> oh, liftM == fmap
11:56:23 <dmhouse> heatsink: yep.
11:56:24 <vincenz> dmhouse: imagine fmap for a sorted list.... it would no longer just treat elements a a time, but would also have to incrementally insert them into a new soretd list
11:56:41 <dmhouse> heatsink: hence any Monad is a Functor by fmap f m = m >>= return . f
11:56:49 <vincenz> teh problem is that this distinction is not placed anywhere in the functor law
11:56:52 <vincenz> anyways
11:56:54 * vincenz off for dinner
11:57:02 <dmhouse> i still think Set is a functor.
11:57:10 <dmhouse> maybe not a Vincenz-Functor, but a Functor.
11:57:13 <vincenz> dmhouse: it's a philosophical thing
11:57:15 <heatsink> hahaha
11:57:20 <dmhouse> no, it's a mathematical thing.
11:57:20 <vincenz> dmhouse: and I think the whole commnity is split 50/50
11:57:25 <int-e> dmhouse: it is.
11:57:29 <heatsink> interesting discussion :)
11:57:34 <vincenz> but I'm late
11:57:43 <dmhouse> okay then. :P
11:57:44 <dmhouse> *:)
11:57:55 * vincenz should get some people to look at his compiler
11:57:57 <vincenz> so they might clean it up
11:57:59 * vincenz whistles
11:58:04 <heatsink> what do you comple?
11:58:24 <vincenz> a language somewhere between haskell and ml
11:58:27 <vincenz> tlak about it later
11:58:29 <heatsink> kay
11:58:32 <heatsink> bye
11:58:33 * vincenz => dinner (people ar expecting me, and I'm late)
11:58:36 <vincenz> thx to dmhouse 
11:58:37 <vincenz> @smack dmhouse 
11:58:38 <lambdabot> Unknown command, try @list
11:58:57 <vincenz> :D
11:59:09 <apfelmus> @slap lambdabot
11:59:09 <lambdabot> why on earth would I slap lambdabot
11:59:18 <dmhouse> hah :)
12:00:05 <vincenz> aha!
12:00:08 <vincenz> @slap dmhouse 
12:00:08 <lambdabot> why on earth would I slap dmhouse
12:00:13 <mauke> @slap myself
12:00:13 * lambdabot smacks myself about with a large trout
12:00:23 <dmhouse> @slap lambdabot
12:00:23 * lambdabot smacks lambdabot about with a large trout
12:00:29 <dmhouse> it's random.
12:00:43 <vincenz> heatsink: anyways... it's a bit like mL, but with hasell style modules, and with haskell style function declarations (Aka recursive toplevel declarations)
12:00:48 <dmhouse> slapList = [("/me slaps " ++) ,(\x -> "/me smacks " ++ x ++ " about with a large trout") ,("/me beats up " ++) ,("why on earth would I slap " ++) ]
12:00:55 <vincenz> heatsink: and with ml references
12:01:22 <int-e> dmhouse: The real problem is a technical one. There's no place to put the Ord dictionary for the result Set into fmap. You'd need an OrdFunctor or something. (class OrdFunctor f where fmap :: (Ord a, Ord b) => f a -> f b)
12:01:25 <vincenz> for an example of syntad
12:01:26 <vincenz> syntax
12:01:37 <vincenz> http://oasis.yi.org:8080/autoshare/insertincremental
12:01:38 <heatsink> but don't you have to go somewhere?
12:01:41 <vincenz> teh reason for { and ;
12:01:47 <int-e> dmhouse: err, forgot the (a->b) argument.
12:01:47 <vincenz> is that I can't quite do vertical layout
12:01:59 <vincenz> heatsink: just got a call, the guy is 5 minutes late, it takes me 5 minutes to get there
12:02:10 <vincenz> heatsink: and just wetting your appetite as well as dmhouse's for later :P
12:02:21 <dmhouse> go to dinner already.
12:02:27 * vincenz dashes off
12:02:32 <vincenz> dmhouse: change yoour nick already
12:02:47 <vincenz> anyway... I might be willing to show the source, not yet decided
12:03:18 <vincenz> however, for further discussions -> #oasis
12:03:36 <dmhouse> @fptools Data.Set
12:03:36 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
12:03:51 <vincenz> hah
12:03:53 <vincenz> it's empty!
12:04:02 <vincenz> oh nm...slow browser
12:04:22 * vincenz blinks
12:04:27 <vincenz> that size-thingy is rather random
12:04:36 <dmhouse> int-e, why do you need an Ord dictionary?
12:04:42 <vincenz> why don't they just us an RBtree
12:04:48 <int-e> dmhouse: because otherwise you get no Set.
12:05:08 <dmhouse> Set's don't require that their inner types instantiate Ord.
12:05:14 <dmhouse> s/Set's/Sets/
12:05:33 <int-e> dmhouse: Set is a functor in the category of types with a linear order; general types don't work. Functor is a class of functors over arbitrary types.
12:06:10 * vincenz finally runs!
12:06:39 <dmhouse> so you can only define fmap on (Ord a) => Set a? why?
12:06:53 * dcoutts_ starts profiling fold loop fusion
12:06:56 <dmhouse> you've just restated your original statement with that last line :)
12:07:02 <int-e> because there is no Set a type for general a.
12:07:39 <dmhouse> sure there is. data Set a = Tip | Bin Size (Set a) (Set a). up to strictness, that's Set.
12:08:00 <int-e> You don't want to implement fmap on that.
12:08:45 <apfelmus> for a general Set a, one only needs Eq a
12:09:08 <int-e> that wouldn't preserve the invariants that the Set module works with.
12:09:19 <int-e> apfelmus: yes, but Data.Set needs Ord to work.
12:09:37 <dmhouse> err, sorry, it was meant to be Bin Size a (Set a) (Set a)
12:09:53 <apfelmus> yeah i know, greedy speedy implementors want Ord a for outstanding performance :-)
12:10:24 <dmhouse> fmap _ Tip = Tip; fmap f (Size sz x s1 s2) = Bin sz (f x) (fmap f s1) (fmap f s2) -- what's wrong with this?
12:10:27 <int-e> dmhouse: Ok, you *can* make a Functor instance for that but it won't be meaningful; it'd break the module.
12:10:49 <apfelmus> the point is:
12:10:52 <apfelmus> @type fmap
12:10:53 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:10:54 <Beelsebob> sweet
12:10:59 <Beelsebob> yhc hat support is working :)
12:11:09 <Beelsebob> hat should support far more now
12:11:20 <Beelsebob> (anything that yhc supports)
12:11:27 <ndm> appart from hat-stack, as error is not done
12:11:34 <ndm> and thats the main thing i want in hat :(
12:11:38 <apfelmus> there is no way to add an Ord a constraint to this
12:11:40 <Beelsebob> error?
12:11:46 <int-e> dmhouse: So it doesn't make sense to define it.
12:11:53 <ndm> Beelsebob: error should do something special, to return a bottom
12:11:58 <ndm> in yhc-hat it doesn't, yet
12:12:02 <ndm> anyway, gtg
12:12:20 * Beelsebob wonders what ndm means by error
12:12:24 <Beelsebob> perhaps the error function
12:12:31 <apfelmus> int-e: ?
12:12:42 <dmhouse> int-e, which invariants? could we define a Set as just a list without a semantic of repeated elements or position within the set and make that a Functor?
12:12:51 <Beelsebob> in which case it should produce an application of a function called error with an argument (the error), resulting in the error it's self
12:13:26 <int-e> dmhouse: all operations in Set work on ordered tree. if you relabel the tree randomly (as your fmap would do) none of those operations would work anymore on the resulting tree.
12:13:51 <int-e> Data.Set is an ordered tree. That's all I'm talking about.
12:14:31 <apfelmus> dmhouse: well, a set has no repeated elements (the ones that do are called multisets)
12:14:50 <int-e> apfelmus: why ?
12:14:54 <dmhouse> apfelmus: hence 'without a semantic of repeated elements'
12:15:02 <int-e> apfelmus: err, what were you wondering about?
12:16:21 <dmhouse> afaiu, Set isn't a Functor because of the way it's implemented. It would be possible to implement it in an alternative way that would give rise to a valid Functor.
12:16:28 <int-e> dmhouse: the Ord requirement allows Sets to be implemented efficiently.
12:16:37 <dmhouse> yep.
12:17:06 <int-e> dmhouse: the thing you want exists: it's called a list.
12:17:08 <apfelmus> int-e: why one can't define fmap on the Tree. But its clear now: you can but you do not want to use this fmap for a Tree with ordered leaves / branches.
12:17:40 <int-e> apfelmus: yes, because what Data.Set actually implements is a subtype of those trees.
12:17:48 <dmhouse> int-e, no, lists have repeated elements and a semantic of order.
12:17:56 <dmhouse> e.g. (!!) can't be defined on sets.
12:18:04 <dmhouse> and nub is the identity on sets
12:18:58 <apfelmus> dmhouse: int-e means a list modulo some equivalence relations
12:19:07 <int-e> dmhouse: you know what? Functor instances don't even have to preserve equality.
12:19:27 <int-e> (as defined by the Eq class)
12:20:45 <dmhouse> i think my fmap does preserve equality, anyway.
12:20:55 <dmhouse> it might not preserve _inequality_, though.
12:21:23 <dmhouse> but that's not unique to sets
12:21:50 <dmhouse> e.g. fmap abs doesn't preserve inequality (it's not injective, in other words; both 3 and -3 get mapped to 3)
12:22:05 <dmhouse> (on lists, i meant)
12:22:13 <dmhouse> (actually, on anything)
12:23:18 * dmhouse gets the distinct feeling he's talking to his-self
12:23:55 <dmhouse> err, himself.
12:24:09 <dmhouse> i have _no_ idea why i said his-self.
12:24:22 <int-e> I've made an irrelevant point in my last remark (a == b doesn't imply f a == f b in Haskell). I think that's a sign I should stop discussing the matter.
12:24:22 * dmhouse goes back to learning elisp
12:24:54 <dmhouse> int-e, where might it not?
12:25:41 * apfelmus is frightened by elisp (evil lisp)
12:25:51 <int-e> dmhouse: data X = A|B; instance Eq X where _ == _ = True; f A = 0; f B = 1.
12:26:03 <dmhouse> hah, okay.
12:26:19 <int-e> dmhouse: or for a more relevant example: imagine Set had a function that returns the depth of the tree.
12:27:00 <dmhouse> yes, okay.
12:27:18 <int-e> dmhouse: the same set can be represented by trees of different depth, so that function would fail that requirement above. (which means that Data.Set shouldn't provide it)
12:27:39 <int-e> it = a depth function.
12:28:01 <dmhouse> i see.
12:28:17 <dmhouse> "depth of a set" doesn't make much sense anyway, it's a consequence of the way it's implemented
12:28:55 <dmhouse> so in the spirit of maintaining an implementation-agnostic API, we shouldn't define one anyway. :)
12:29:47 <apfelmus> i currently wonder how djinn's intuitionistic theorem prover works.
12:30:00 <dmhouse> intuitively. :)
12:30:17 <apfelmus> proving classical propositional theorems is easy (try all cases)
12:30:59 <apfelmus> dmhouse: no, it's using some known algorithms
12:31:04 <int-e> (fwiw, Set could be made a Functor instance if it were defined as data Ord a => Set a = Tip | Bin Int a (Set a) (Set a))
12:31:42 <dmhouse> int-e, isn't that how it _is_ defined? (up to strictness of constructors)
12:31:57 <dmhouse> oh, the Ord dictionary. right.
12:31:58 <apfelmus> but i haven't been able to find any useful online pdf about this yet
12:32:22 <int-e> I don't know if that has an impact on memory usage though.
12:32:34 <dmhouse> Ord isn't a very limiting constraint.
12:32:57 <int-e> (it'd hurt if the Ord dictionary were stored in every node of the tree)
12:33:23 <dmhouse> yeah
12:33:39 <apfelmus> int-e: why? it's just an indirection pointer
12:34:22 <dmhouse> why does the compiler store dictionaries alongside values in any case? can't it just reflect on the type and use a standard type -> instance lookup table?
12:35:05 <heatsink> dmhouse: newtypes can let the same datatype have different instances.
12:35:06 <goron> What's an _easy_ way to find this?  *** Exception: Prelude.head: empty list
12:35:15 <int-e> I don't know if it does. I'm too lazy to check right now. Actually I'm hoping that someone tells me it doesn't do that.
12:35:31 <goron> Turning all applications of head to case patterns?
12:36:01 <dmhouse> heatsink: then consider newtype'd types as unique from their un-newtype'd counterparts.
12:36:33 <heatsink> goron: replace each call to head with (head . trace "functionName")
12:36:58 <heatsink> goron: It'll print that string just before the exception, so you know which call to head is a problem
12:38:45 <heatsink> dmhouse: Newtypes look exactly like regular types during execution, for most newtypes.
12:39:03 <dmhouse> but they have different types :)
12:39:13 <heatsink> dmhouse:  Also, because of polymorphism, there may be an infinite number of possible run-time types in a program.
12:39:39 <heatsink> polymorphism and type-level recursion
12:39:42 <dmhouse> hmm
12:39:59 <dmhouse> right, okay.
12:40:09 * int-e sees no good reason why the dictionary would have to be stored with the data, except for higher order types (forall a.Show a => a)
12:41:12 <dmhouse> heatsink: i don't think it's unreasonable to crash when someone hands you an input file with an infinite amount of isntances :)
12:41:13 <Philippa> the term you're looking for is "impredicative"
12:41:13 <int-e> does anyone have a benchmark for Data.Set?
12:41:14 <Philippa> and you're right
12:41:27 <Philippa> (yeah, you get it with existential data constructors too)
12:41:28 <dmhouse> where "infinite" is any sufficiently large nu,ber
12:41:30 <dmhouse> *number
12:41:45 <dmhouse> heatsink: it's the same as defining the same number of functions.
12:42:05 <int-e> Philippa: thanks. I should've seen the connection to type inference.
12:42:12 <mabillama> I really don't like Haskell
12:42:19 <dmhouse> mabillama: why so?
12:42:20 <mabillama> but the positive point here
12:42:27 <Philippa> dmhouse: the number of functions generated in a functional program is potentially infinite too
12:42:32 <mabillama> is that the community really help
12:42:35 <mabillama> thats nice
12:42:36 <int-e> mabillama: can you dislike it somewhere else please?
12:42:40 <int-e> :P
12:42:46 <Philippa> dmhouse: thing is, you don't need very many in the source code to do that
12:42:53 <mabillama> jk
12:43:21 <dmhouse> Philippa: hmm?
12:43:31 <dmhouse> you can generate an infinite family of functions from a finite set?
12:43:53 <int-e> Philippa: let me ask this straight, do you see any reason why adding Ord a => to the Set data declaration should affect performance?
12:45:01 <kosmikus> dmhouse: if I understand your question correctly, then the answer is "no"
12:45:30 <heatsink> dmhouse: instance Ord a => Ord [a]
12:45:38 <dmhouse> kosmikus: Philippa just stated "the number of functions... is potentially infinite / ... you don't need many [functions] in the source code to do that"
12:45:39 <heatsink> dmhouse: Infinite number of functions right there :)
12:45:52 <heatsink> of types, rather
12:46:09 <dmhouse> yes, okay, we'd need some way to store polymorphic instances too.
12:46:14 <kosmikus> dmhouse: sorry, I hadn't followed the discussion
12:46:16 <dmhouse> but that's not a major problem.
12:47:56 <Philippa> int-e: I don't see any reason for that per se. OTOH, it might cause the dictionaries to be passed when it's not otherwise necessary
12:48:19 <apfelmus> int-e: inside an existential declaration, it certainly will.
12:48:20 <Philippa> (because once the constraint's there, it's fair game to assume it of any type variable Set's applied to)
12:48:47 <int-e> Philippa: hmm, true. that affects traversal.
12:48:51 <mabillama> algum brasileiro?
12:49:22 <Philippa> dmhouse: you can easily generate an infinite number of functions from two of them of the relevant types. They won't be /interesting/, but you'll get something akin to the church encoding of the natural numbers
12:49:47 <heatsink> dmhouse: Then you may be able to store it, but I'm not sure how you'd look things up.
12:49:55 <Philippa> int-e: it's not too bad, you only need a dictionary per-set
12:50:33 <Philippa> in the impredicative case, the set's dictionary will amount to "look it up in the individual item"
12:50:53 <Philippa> but what else is new?
12:51:13 <Philippa> (OTOH, you shouldn't be doing the impredicative case for Ord, it doesn't work)
12:51:30 <int-e> Philippa: yes, but it means I should make some measurements before proposing a change.
12:51:37 <dmhouse> heatsink: "We need an Ord isntance for [Foo]. Hmm... we can match a against Foo, so we have the instance! Ah, but wait, that has an Ord a constraint, so we need Ord Foo. <another lookup> But it's okay, we have that!"
12:52:36 <Philippa> int-e: the cases where it's never actually used are likely amenable to optimisation anyway. And I don't think there /are/ any such cases here, in which case the dictionary's already being passed around
12:52:54 <Philippa> you're not really generating a new constraint at all, you're just moving it
12:53:46 <Philippa> *thinks a moment longer* OK, you don't even need it attached to the set, only to when the set's passed in a polymorphic situation. Nothing to measure at all, then
12:54:05 <Philippa> it's the same thing in practice
12:54:35 <Philippa> (OTOH, sometimes a constructor class would need to express lack-of-constraints?)
12:54:38 <int-e> Philippa: ah, my little test program was too minimalistic. It doesn't work, right.
12:55:07 <Philippa> what doesn't?
12:55:53 <heatsink> dmhouse: The thing is, how do you do the lookup quickly?  At present it's just indirection through a field of the type object.
12:55:59 <int-e> Philippa: trying to cheat to get a constrained passed into a context without it. putting it that way it's clear it can't work.
12:56:06 <int-e> *constraint
12:56:26 <dmhouse> heatsink: you're trading speed of lookup for decreased memory usage
12:57:36 <heatsink> I see.
12:57:46 <heatsink> There may still be a problem with fixed-point types, though.
12:58:02 <apfelmus> int-e: Eq a => just gets replaced by Eq a ->. any optimisations for normal arguments apply then
12:58:06 <heatsink> because there's no base case to look up first.
12:58:10 * dmhouse likes to pretend recursion at the type leve doesn't exist :)
12:58:14 <heatsink> :)
12:58:29 <int-e> apfelmus: I was adding it to a data declaration though.
12:58:37 <apfelmus> int-e: i heard jhc uses a different approach for classes, something like GADT
12:59:53 <Philippa> apfelmus: JHC passes around typeids and looks up the actual code based on that
13:00:00 <int-e> Philippa: The silly part is, I already had a proof that it couldn't possibly work. I just didn't believe it.
13:00:22 <Philippa> heh
13:00:44 <Philippa> Remember, if you tell the type system to forget something, it forgets it. Then doesn't remember it when you want it to
13:00:50 <apfelmus> int-e: why should the data declaration be a problem? i mean, it's as if i drop the contraint at the declaration and introduce it on every function which uses the type
13:01:18 <int-e> (I want a Functor instance for Set. That gives me, for all types a and b, a function Set a -> Set b. Now Set has an implicit Ord constraint (doesn't work otherwise), and fmap could construct Sets without that Ord constraint. Therefore, it's impossible to implement.)
13:01:51 <int-e> (impossible while preserving that implicit constraint)
13:02:21 <int-e> apfelmus: indeed.
13:03:23 <Philippa_> As I was saying...
13:03:25 <Philippa_> yep, you effectively need Functor parameterised on the types it's allowed to take/return
13:03:27 <Philippa_> Cale and I talked about that regarding monads a while back
13:04:53 <int-e> ow.
13:08:24 <heatsink> Do the splits!
13:08:37 * apfelmus 's irc is able to crash without crashing. very clever, uh?
13:33:10 <studix> any idea why http://pastebin.com/760630 is not working ?
13:33:49 <int-e> you need to indent the functions for the instance declaration
13:34:02 <int-e> i.e. lines 4 to 17
13:34:57 <dmhouse> in general, if things are part of something else, indent the subordinates above their parents.
13:35:08 <dmhouse> e.g. here the toEnum definitions are part of the instance declaration
13:35:25 <dmhouse> studix: by the way, you can derive Enum, which does exactly what you're doing.
13:36:50 <int-e> deriving Enum starts at 0
13:37:02 <dmhouse> ah, true.
13:37:25 <int-e> of course, dayAfter would actually be correct then
13:38:39 <dmhouse> you could instantiate Num :)
13:38:44 <studix> tnx people , but http://pastebin.com/760637
13:39:17 <int-e> you have fromEnum and toEnum reversed.
13:39:49 <dmhouse> @type fromEnum
13:39:49 <lambdabot> forall a. (Enum a) => a -> Int
13:39:57 <dmhouse> i.e. Day -> Int
13:40:01 <dmhouse> @type toEnum
13:40:02 <lambdabot> forall a. (Enum a) => Int -> a
13:40:06 <dmhouse> i.e. Int -> Day
13:54:31 <petekaz> In one of the mailing list posts, I see that one of the Simon's makes a comment about using GHC's parser simply by importing GHC.  Where is the documentation for this?  How is this different from the parser in Language.Haskell.Parser?
13:55:21 <Lemmih> It can parse all of Glasgow Haskell.
13:55:53 <dmhouse> does it use happy/alex, or parsec? or something else?
13:55:56 <petekaz> I think for my first Haskell project, I want to write a pastebin in Haskell that is aware of Haskell syntax.  If I have the parse tree, then I just have to implement an xml-like pretty printer right?  Is this a reasonable goal for a newbie?
13:56:03 <Lemmih> dmhouse: happy/alex.
13:56:03 <ADEpt> petekaz: including extensions
13:56:17 <dmhouse> petekaz: that'd be wonderful.
13:56:18 <dmhouse> :)
13:56:39 <dmhouse> i don't know about the difficulty level, i've never used it.
13:56:46 <ADEpt> petekaz: you are righ, and that would be great
13:56:49 <petekaz> So is that documented somewhere, the GHC parser?
13:56:56 <Lemmih> petekaz: You don't need a parser to do syntax-highlighting.
13:57:05 <Lemmih> petekaz: There's no documentation other than the source.
13:57:21 <ADEpt> petekaz: but, if the AST is the same as in Template Haskell (and I bet it does) you could have hard time parsing it.
13:58:17 <dmhouse> Lemmih: you don't?
13:58:37 <petekaz> Lemmih: I don't want to use regexps or any other kludgey method.
13:58:42 <lscd> dmhouse: i asked him the same; he pointed out that you can do a lot with a lexer
13:59:01 <Lemmih> dmhouse: Not unless you want a really advanced form of syntax-highlighting.
13:59:03 <dmhouse> i've never quite grokked the syntax between parser and lexer.
13:59:11 <lscd> the syntax?
13:59:19 <dmhouse> lscd, ooh, did you download any of the videos?
13:59:20 <Lemmih> Lexer based syntax-highlighting: http://darcs.haskell.org/~lemmih/HideUnicodePretty.png
13:59:30 <lscd> dmhouse: ya, 19 and 20, but i haven't had time to see either yet
13:59:45 <petekaz> What's the differenec from a parser and lexer?  The lexer just makes tokens right?  But you don't know what those tokens are right?
13:59:59 <lscd> yeah, basically
14:00:02 <lscd> the lexer matches tokens
14:00:11 <lscd> the parser defines what the grammar is
14:00:15 <dmhouse> lscd, hmm... perhaps it's my system but there was no video on either of them for me. it just came up an entirely blue screen.
14:00:30 <dmhouse> hmm, okay, but then why do systems need both parser and lexer?
14:00:44 <lscd> video works for me
14:00:57 <lscd> mplayer-bin, gentoo/amd64, hi-res version of the vids
14:01:08 <dmhouse> it's something like String --(parser)-> ?? --(lexer)-> ??
14:01:10 <lscd> dmhouse: technically? they don't; but it makes things a lot cleaner to separate the passes
14:01:17 <lscd> lexer, then parser
14:01:26 <dmhouse> okay.
14:01:28 <lscd> the parser generally says how you combine tokens
14:01:44 <dmhouse> but what go in the ??
14:01:45 <petekaz> Lemmih: with a lexer, then I have to write my own rules guessing what a token is based on context right?  I might as well use a real parser, and then pretty print that.
14:02:06 <petekaz> Lemmih: that was a question actually.
14:02:15 <lscd> dmhouse: i've mainly used lex and bison; with those, you've got some generated c code that interfaces them
14:02:18 <Lemmih> petekaz: The lexer tells you what the tokens are.
14:02:25 <lscd> petekaz: i'd say so, ya
14:02:56 <Lemmih> Context is irrelevant.
14:03:02 <lscd> Lemmih: but they can mean different things in different contexts; and some examples, like the one i gave you about coloring different parentheses-levels differently, can't be done with just the lexer
14:03:29 <Lemmih> lscd: But do you really want that?
14:03:39 <lscd> Lemmih: it's more of a win in lisp than haskell
14:03:49 <lscd> but yes, it can be useful
14:04:12 <lscd> likewise, the lexer may not be able to tell function and variable names apart, if there's no restriction in the language that differentiates them
14:04:28 <dmhouse> there's no difference between functions and variables, though.
14:04:32 <dmhouse> you're thinking in lisp.
14:04:44 <lscd> hm? how am i thinking in lisp?
14:04:51 <dmhouse> there's no difference between functions and variables, though.
14:05:27 <lscd> sure there is; not all variables are functions
14:05:28 <stepcut> Lemmih: is that a non-fixed-width font in the screenshot?
14:05:40 <dmhouse> lscd, why not? how do you distinguish them?
14:05:50 <lscd> and i might want to be able to say, for instance, a = 1; b = 2; putStrLn a + b
14:05:55 <Lemmih> stepcut: No, I don't think so.
14:05:57 <lscd> and want putStrLn to be a different color than a and b
14:06:03 <mauke> even the parser doesn't know the difference
14:06:14 <lscd> dmhouse: with a parse tree, you can see if something is being used as a function
14:06:16 <petekaz> Lemmih: with the parser, I think I'll be able to do cool stuff like highlighting a whole 'do' block with a mouseover.
14:06:19 <Lemmih> petekaz: If you want better highlighting than Vim and Emacs then use a lexer. If you want divine highlighting then use a parser.
14:06:25 <lscd> that doesn't preclude variables from being functions; but if they're not the one being called, so be it
14:06:42 <dmhouse> lscd, putStrLn (a + b). a and b are functions that return 1 and 2 respecively. everything is a function.
14:06:56 * stepcut decides it looks fixed-width after all
14:06:56 <lscd> an Int is a function in haskell?
14:07:08 <dmhouse> it's not a variable either
14:07:13 <Lemmih> petekaz: Your choice. It's just a lot of work for very little payoff.
14:07:19 <lscd> ok; let's say 'function being applied' vs 'arguments'
14:07:35 <mauke> (sequence . (const >>= map)) [1,2,3]  -- what's applied here and what isn't?
14:07:39 <lscd> Lemmih: well, if he already has a parse tree he can walk, how bad is it?
14:07:44 <dmhouse> lscd, what about getLine?
14:07:48 <Lemmih> lscd: But he doesn't.
14:07:50 <lscd> what about it, dmhouse?
14:07:58 <dmhouse> lscd, no arguments. is it a function?
14:07:59 <stepcut> lscd: http://foldoc.org/?constant+applicative+form
14:08:07 <dmhouse> if so how do you distinguish it from your a and b?
14:08:08 <lscd> <petekaz> In one of the mailing list posts, I see that one of the Simon's makes a comment about using GHC's parser simply by importing GHC <-- thought he did
14:08:15 <mauke> getLine is a constant, obviously
14:08:15 <Lemmih> lscd: Finding a parser for Glasgow-Haskell is very difficult.
14:08:16 <lscd> dmhouse: sure, functions don't need arguments
14:08:24 <mauke> it's not a function
14:08:45 <lscd> it's an impure function - i don't know the haskell terminology for that
14:08:56 <mauke> getLine isn't a function in haskell
14:09:00 <lscd> procedure?
14:09:03 <mauke> no, constant
14:09:06 <mauke> it's a value
14:09:10 <lscd> hm... ok
14:09:17 <dmhouse> technically, it's a functional constant
14:09:31 <dmhouse> as it has type RealWorld -> (String, RealWorld) (ish).
14:09:33 <mauke> dmhouse: that's an implementation detail, no?
14:09:46 <dmhouse> fair point, but you can't ignore the monadicity.
14:09:51 <dmhouse> (hehe, just made up that word)
14:10:03 <mauke> IO doesn't have to be a function type
14:10:17 <lscd> it's a monad type
14:10:35 <stepcut> in haskell constants == zero arity functions == CAF (constant applicative form) (i think...)
14:10:35 <mauke> monad is just an interface
14:10:37 <dmhouse> okay, never mind.
14:11:01 <lscd> stepcut: how does CAF differ from a lisp thunk?
14:11:04 <dmhouse> 'constant' is a very ambiguous term.
14:11:21 <lscd> haskell uses a lot of terminology somewhat differently from other areas 
14:11:29 <dmhouse> e.g. the primops are called constants.
14:11:44 <studix> http://pastebin.com/760689 , I dont understand , this is defined in prelude.hs , this shouldnt overlap or something , argh
14:11:58 <stepcut> lscd: I do not know
14:12:10 <mauke> what's a lisp thunk?
14:12:13 <lscd> stepcut: alright
14:12:17 <lscd> mauke: 0-argument function
14:12:24 <dmhouse> a thunk in list. :)
14:12:27 <dmhouse> *lisp
14:12:37 <lscd> http://www.google.com/search?q=define%3Athunk
14:12:41 <lscd> 2nd definition
14:12:56 <dmhouse> a thunk is what you use to do lazy evaluation
14:13:18 <mauke> then (abs 42) is a thunk in haskell
14:13:22 <dmhouse> it's a thing that says 'This is how you get my value'.
14:13:42 * stepcut goes to lunch
14:13:46 <lscd> hm. possibly
14:13:51 <dmhouse> actually, the last defn on the google result is the best.
14:14:05 <lscd> the haskell way of doing and seeing things still makes my head spin
14:14:24 <lscd> not the 3rd? 
14:14:58 <lscd> hm... thunks are used to emulate laziness in strict functional languages, according to wikipedia
14:15:12 <lscd> i doubt it's how lazy eval is done in haskell, but dunno
14:15:12 <dmhouse> hehe, the third is good too :)
14:15:29 <dmhouse> well haskell is compiled to a strict language, so thunks are used.
14:15:50 <dmhouse> which is why e.g. foldl' runs in constant memory space but foldl runs in linear (or something)
14:15:55 <dmhouse> foldl accumulates thunks.
14:16:17 <lscd> it accumulates, yes
14:16:24 <lscd> is it accumulating thunks? i don't know
14:16:36 <dmhouse> i think so.
14:16:37 <mauke> everything is a thunk by default
14:16:38 <goron> lscd: A thunk is an unevaluated handle to code which can be forced (in Lisp terms). 
14:16:56 <lscd> goron: sounds right
14:17:34 <goron> lscd: if you call a function on some lazy value (a thunk), the code gets executed and given to the calling function.
14:17:55 <lscd> its return value gets given, ya
14:18:25 <goron> lscd: this is how it works conceptually, for details read the STG paper by Simon P. Jones
14:18:37 <lscd> thank you i will
14:18:44 <goron> lscd: that basically describes how GHC works.
14:18:56 <lscd> excelletn
14:20:53 <lscd> dumb question: what does 'stg' expand to, again?
14:21:13 <mauke> Star Trek: Generations
14:21:15 <lscd> spineless tagless g-machine, or?
14:21:48 <int-e> yes.
14:22:14 <lscd> ah-hah
14:23:53 <lscd> bleh. downloading it doesn't work in my browser.
14:24:11 <lscd> even after i allow pop-ups as the javascript says. annoying
14:25:56 <lscd> citeseer to the rescue :p
14:29:03 <mauke> weird, the direct link works: http://research.microsoft.com/users/simonpj/papers/spineless-tagless-gmachine.ps.gz
14:30:14 <lscd> yeah; unsurprising. citeseer had it in pdf though, which is nicer
14:30:54 <goron> lscd: maybe you need a new browser?
14:31:03 <vincenz> re
14:31:13 <lscd> goron: happily. my current one sucks.  which do you recommend?
14:31:32 <vincenz> hmm
14:31:38 <vincenz> that was nice, japanese cuisine
14:32:22 <mauke> or maybe microsoft needs to fix their crappy javascript
14:32:47 <lscd> mauke: sure, but what're the odds of -that- happening?
14:34:21 <goron> lscd: konqueror > firefox > ie, I am not sure of where to place opera.
14:34:47 <lscd> goron: hm... konqueror has been unstable and rendered too many sites poorly for me in the past, though it's improving
14:34:56 <lscd> aside from that, agreed
14:34:57 <dmhouse> konqueror => crappy gmail
14:35:04 <goron> dmhouse: It works here
14:35:06 <lscd> dmhouse: that too, yes
14:35:14 <lscd> goron: it works, but not as well as with firefox
14:35:23 <lscd> or at least, that was so last time i used gmail with konqueror, many months ag
14:35:25 <goron> lscd: I identify as firefox
14:35:25 <lscd> ago
14:35:29 <lscd> ahh
14:35:32 <goron> lscd: I get the "whole experience"
14:35:39 <lscd> nice
14:36:07 <goron> What website doesn't render good on konqueror?
14:36:27 <lscd> off the top of my head, i'm not thinking of any - i've just been incredibly underwhelmed every time i've tried it as a web browser
14:36:31 <lscd> as a file browser, it rocks
14:37:09 <goron> lscd: I think it's too slow for a file browser.
14:37:28 <lscd> well, i mainly use fish:// at that point, or use it as a cheap photo viewer
14:37:37 <lscd> for actual file management, i just use the shell
14:37:44 <goron> lscd: I have a few hundred files and folders, and it should render in 0.5 seconds. 
14:37:49 <goron> lscd: It doesn't.
14:38:05 <lscd> you've turned off all the slow features?
14:38:33 <goron> lscd: No, but well, it's mostly the booting.
14:38:41 <lscd> ah.... yes, it's sloooooow to start
14:38:57 <lscd> also, web browsers crashing scares me
14:38:59 <goron> lscd: I already keep one preloaded, but that doesn't solve the problem.
14:39:10 <lscd> if it crashes, it's probably also got tons of fun exploitable bits
14:39:13 <lscd> yeah... i know
14:39:42 <goron> lscd: I think konqueror is more secure than firefox for the simple fact that its design is better.
14:39:59 <lscd> they're both pathetic in terms of security, though
14:40:22 <lscd> but sure... design-wise, only ie is worse than firefox :D
14:40:30 <goron> lscd: Well, we don't have a browser written in Coq yet.
14:40:36 <lscd> yeah
14:40:39 <lscd> but you've started, right?
14:40:45 <mauke> most browsers don't have firefox's extensions :/
14:40:45 <goron> lscd: heh
14:41:05 <lscd> mauke: yes - that, firefox being oss, and the default keybindings are what keep me on it instead of opera
14:41:38 <goron> I like the extensions too. Konqueror has them too, but they are not so hyped.
14:41:49 <goron> (and less integrated I think)
14:41:52 <lscd> sure.. opera has extensions as well, i tihnk
14:41:56 <lscd> but firefox has a -lot- of them
14:42:25 <mauke> right now I'm running linkification, all-in-one gestures, adblock plus, tamper data, target alert, view source with, digger, flashblock, greasemonkey, platypus, locale switcher, restart tabbed, tab history, server spy
14:42:37 <lscd> wow
14:43:03 <goron> I have flashblock, bugmenot, greasemonkey, adblock.
14:43:13 <vincenz> anyone care to help me with a compiler issue
14:43:23 <goron> Those are the ones I know I use, I don't know about the rest. 
14:43:26 <lscd> i'm using more than i realised; bugmenot, stumbleupon, adblock, talkback, and dom inspector, plus some language packs
14:43:35 <lscd> and sessionsaver
14:43:44 <lscd> vincenz: shoot
14:43:52 <vincenz> lscd: join #oasis, it's an involved discussion
14:44:24 <Kasperle> i can really recommend tab mix plus
14:44:36 <lscd> what's good about it?
14:44:38 <Kasperle> tabbed browsing features + session saver
14:44:53 <Kasperle> felt nicer/easier to use than the session saver extension for example
14:45:00 <lscd> hm... ok
14:46:01 <Cale> Add N Edit Cookies, All-in-One Gestures, All-In-One Sidebar, BugMeNot, CustomizeGoogle, DOM Inspector, Flat Bookmark Editing, Gmail Manager, Image Zoom, Nuke Anything Enhanced, Remove It Permanently, Search Marker, Tab Mix Plus, (and Talkback)
14:46:29 <Cale> All-in-One Sidebar is pretty cool once you have it configured so that it doesn't get in your way.
14:47:35 <Lokadin> cd ..
14:47:45 <Cale> ls
14:47:49 <yaarg> the web developer extension is essential if you do any web dev
14:47:51 * yaarg nods
14:47:54 * lscd waves hi to LoganH and Cale 
14:47:57 <Cale> hi
14:48:12 <lscd> [you guys invoked me, sort of]
14:48:23 <Cale> I don't use AdBlock since I just use Privoxy.
14:49:14 <goron> I use Privoxy in Konqueror, because it didn't have Adblock. 
14:51:02 <vincenz> Cale: join #oasis...deep discussion gong on
14:52:01 <vincenz> Cale: could use your help ;)
14:53:42 * Maddas looks at some of the mentioned extensions
14:54:27 <bringert> shapr: there is now preliminary RSS support in Hope/Blob2
14:54:54 <bringert> you need to update Hawl too to compile it
14:55:13 <SyntaxNinja> is there a Haskell RSS parser?
14:55:34 <bringert> SyntaxNinja: I haven't seen one. I just produce RSS
14:56:40 * SyntaxNinja nods
14:57:59 <ADEpt> bringert: what's Hope?
14:58:48 <jcreigh> ADEpt: Hope is the belief that change is possible. Oh, wait... :)
14:59:16 <ADEpt> jcreigh: well... define Hope/Blob2 then :)
14:59:52 <reilly> has anyone built Darcs using GHC 6.5?
14:59:52 <bringert> ADEpt: Hope a framework for Haskell web applications. It currently has two modules, Blob2 for blog entries, and Halbum2 for photo albums
14:59:59 <bringert> reilly: yes
15:00:17 <ADEpt> bringert: and Hawl?
15:00:27 <ADEpt> bringert: it moves castles? :)
15:00:30 <bringert> ADEpt: my sentence no verb
15:00:53 <lscd> bringert: i shall verbify it
15:00:55 <reilly> bringert: I'm getting errors at link time: _ControlziMonadziError_zdf21_closure
15:00:55 <reilly> _ControlziMonadziError_ZCDError_static_info
15:01:01 <reilly> undefined
15:01:04 <azuroth> hi-oh
15:01:05 <ADEpt> @where Howl
15:01:05 <lambdabot> I know nothing about howl.
15:01:10 <ADEpt> @where Hope
15:01:10 <lambdabot> I know nothing about hope.
15:01:20 <bringert> ADEpt: nope :-) didn't he spell it differently? Hawl is a library of web programming utilities used by all of the above
15:01:21 * ADEpt googles
15:01:32 <yaarg> hope the programming language?
15:01:39 <bringert> ADEpt: it's just a darcs repo
15:01:49 <bringert> bringert: and I only told shapr about it
15:01:55 <bringert> and you guys now
15:02:11 <bringert> reilly: that looks like a missing -package flag
15:02:14 <lisppaste2> azuroth pasted "factory? multiple-param classes?" at http://paste.lisp.org/display/20897
15:02:38 <ADEpt> bringert: url(s)?
15:03:20 <bringert> reilly: try adding "-package mtl" to GHCFLAGS in autoconf.mk
15:03:28 <reilly> OK
15:03:30 <reilly> thanks
15:03:36 <bringert> ADEpt: it's a pain to build
15:04:21 <bringert> ADEpt: I should set up a demo somewhere, so people can see what it is before the waste an hour installing all the dependencies
15:04:33 <azuroth> I'm trying to... figure out how to do this, but I think I'm on the wrong tangent. I want a Factory class that I can take and will give me a certain instance of Object
15:05:25 <bringert> ADEpt: the Hope repo is http://www.cs.chalmers.se/~bringert/darcs/hope/
15:05:44 <bringert> ADEpt: you need to check out some modules too, I'll add that to INSTALL
15:05:46 <Excedrin> does hope use fastcgi?
15:07:37 <reilly> bringert: Thanks, that did the trick.  Between being relatively new to both the Mac & GHC, it can be difficult to puzzle out why stuff doesn't work.
15:07:38 <bringert> Excedrin: CGI or FastCGI
15:08:12 <bringert> with NewCGI it's really easy to use either, just change the run-function
15:08:33 <reilly> bringert: and I wasn't sure if the problem was in my GHC build, or an issue with 6.5 and DARCS
15:08:35 <bringert> I recently added a runFastCGIorCGI that actually can do both in the same binary
15:08:45 <ADEpt> bringert: now you scared me :) i'll look at it tomorrow
15:09:04 <bringert> reilly: I think I had the same problem when building darcs on ghc-6.5 on OS X
15:09:44 <bringert> anyway, anytime you get link errors referring to things that look like haskell functions, your best bet is a missing -package flag
15:10:00 <reilly> that's what i was doing, complicated by the fact that I'm running an intel mac
15:10:17 <bringert> reilly: me too
15:12:15 <azuroth> I'll be back with more pestering later!
16:12:28 <vincenz> anyone written interpterters?
16:12:31 <vincenz> I could use some help
16:12:39 <lscd> only a really, really bad one
16:12:46 <vincenz> lscd: I'm trying to define my value types
16:13:08 <vincenz> data Value = VNil | VInt Int | VBool Bool | VTuple [Value] | VClosure ..?
16:13:15 <lscd> k.?
16:13:25 <vincenz> not sure how to define a closure
16:13:45 <lscd> my interpreter didn't have them, sorry
16:14:30 <vincenz> I'm thinking a map of variable names -> Value
16:16:27 <Cale> Well, a closure is just a function together with some of its parameters.
16:17:33 <Cale> You could make it really concrete by saying that it's a function together with a supplied parameter value.
16:17:58 <Cale> i.e. (a, a -> b)
16:18:13 <vincenz> so
16:18:21 <vincenz> VClosure Function [Params]
16:18:27 <vincenz> or more specificlly
16:18:31 <vincenz> VClosure Function [Value]
16:18:42 <Cale> VClosure Value Function, even
16:18:55 <vincenz> Cale: assuming fucntions only have one parameter
16:18:59 <vincenz> let foo x y z = ...
16:19:00 <vincenz> foo a b
16:19:03 <Cale> right, which you can always do
16:19:15 <Cale> and which is done in Haskell anyway :)
16:19:17 <vincenz> only if Function is again a VCLosure
16:19:50 <Cale> well, the result of Function you mean?
16:20:00 <vincenz> VClosure (VClosure "foo" a) b
16:20:20 <vincenz> for foo a b
16:20:57 <Cale> You probably want the possibility for functions with not all their parameters supplied too.
16:21:04 <vincenz> right
16:21:04 <vincenz> but
16:21:07 <vincenz> let foo x y z = ...
16:21:09 <vincenz> foo a b
16:21:29 <Cale> what?
16:21:32 <vincenz> foo requires three args
16:21:35 <vincenz> I only apply two
16:21:38 <vincenz> so I get
16:21:49 <vincenz> VClosure (VClosure (Function "foo") a) b
16:21:57 <vincenz> according to your idea
16:22:05 <Cale> yeah
16:22:13 <Cale> which should evaluate to a function
16:22:48 <vincenz> of
16:22:57 <Cale> a single parameter
16:22:58 <vincenz> VClosure (Function (VCLosure (Function "foo") a) b))
16:23:13 <Cale> er, yeah
16:23:31 <vincenz> in which case
16:23:32 <vincenz> I better have
16:23:38 <vincenz> VFunction Function
16:23:43 <vincenz> and Function being the actual closure
16:23:51 <vincenz> if it has supplied args
16:23:53 <Cale> is there any particular reason for representing closures directly?
16:24:04 <vincenz> let foo x y z  =....
16:24:07 <vincenz> let bar x = foo x
16:24:09 <Cale> You could also just get them for free
16:24:33 <Cale> by representing functions as functions
16:24:48 <vincenz> yes
16:24:53 <vincenz> and putting the closure stuff inside the function
16:24:53 <Cale> I suppose that's not so good for analysus
16:24:55 <Cale> i*
16:25:08 <vincenz> not sure I follow your logic
16:25:56 <Cale> Well, you can't really manipulate the internal workings of a function in Haskell
16:27:23 <vincenz> well
16:27:27 <vincenz> I keep my code in AST form
16:27:32 <vincenz> so without parameter
16:27:38 <vincenz> a function is just an expression
16:27:49 <vincenz> (a piece of AST)
16:28:12 <vincenz> but thanks for the food for thought
16:28:26 <vincenz> I have anothre more implementational issue
16:29:06 <vincenz> care to have a go?
16:29:29 <ruffneck> does predicate calculus apply to haskell=?
16:29:58 <vincenz> Cale: generically it involves annotating something with constraints, solving these constraints, and then later updating the constraints
16:31:48 <vincenz> anyone a happy-user?
16:32:48 <Cale> ruffneck: depends in what way you're talking about
16:33:26 <Cale> ruffneck: obviously, you can define predicates in Haskell as functions to Bool, and use logical operators on Bool results
16:33:33 <Cale> and in that sense, it applies
16:36:01 * stepcut is very happy
16:40:38 <azuroth_tafe> whoa oh oh
16:41:39 * jer sees "ruffneck" and i just wanna shout "go oilers!" =D
17:10:34 <bringert> stepcut: something you would like to share?
17:16:09 <stepcut> vincenz: vincez asked 'anyone a happy-user'...
17:17:23 <azuroth_tafe> stepcut: feed me
17:19:21 <greenrd> woo, simulating depedent types in Haskell is fun!
17:19:44 <greenrd> I've got it to derive the truth tables of boolean functions, as types, using type inference :)
17:19:47 <greenrd> after a lot of work
17:20:06 <greenrd> *dependent
17:22:45 * bringert implemented fixed-width binary arithmetic with multi-parameter type classes and fundeps once
17:23:06 <bringert> we were just fooling around in a break at icfp
17:23:33 <bringert> that is, the arithmetic was done in the type system
17:23:48 <bringert> mostly useless actually
17:26:49 <greenrd> heh
17:27:52 <greenrd> Well, my thinking is:
17:28:31 <greenrd> It seems at first fairly useless to state with such precision what a simple function does in its type, yes
17:29:35 <greenrd> However, the benefit of it should be apparent when using the type system to reason about that function
17:30:05 <greenrd> that is, uses of that function
17:30:16 <greenrd> This is an alternative to using a theorem prover to prove your code correct
17:30:40 <greenrd> with the disadvantage that you don't have all the tactics of a mature prover at your disposal
17:30:50 <greenrd> but the advantage that you don't have to learn a new language
17:31:05 <bringert> greenrd: another problem is the system that you use to define the properties that you want to prove is really under-powered
17:31:28 <greenrd> heh, well, I'm not convinced
17:31:43 <bringert> e.g. no arithmetic, expect by crazy lets-code-prolog-in-the-Hakell-type-system-just-because-we-can
17:31:47 <greenrd> with enough effort, I think anything can be shoehorned into haskell's type system
17:31:49 <bringert> except dammit
17:31:56 <greenrd> heh
17:32:11 <greenrd> I don't know prolog, so maybe I'm missing something
17:32:22 <bringert> greenrd: sure, you can, but do you want to? classic Turing tarpit imho
17:32:35 <greenrd> but basically: want an axiom? just declare it, and make it equal to undefined
17:32:54 <bringert> but you can't use values on the type level
17:33:02 <greenrd> right
17:33:28 <greenrd> that's why I'm rewriting the haskell prelude from the ground up using typeclasses extensively :)
17:33:39 <greenrd> so that values are mirrored on the type level
17:34:39 <bringert> have fun :-)
17:34:49 <stepcut> greenrd: sweet
17:34:50 <bringert> actually it sounds fun
17:34:50 <greenrd> bringert, I don't think it's a turing tarpit, because the type system isn't for programming in
17:34:54 <greenrd> yes, it is :)
17:35:08 <bringert> greenrd: but you are programming in it?
17:35:09 <greenrd> the type system is for stating theorems which are proven by writing code
17:35:23 <bringert> if you rewrite the prelude
17:35:51 <greenrd> you can state "list is sorted" using some silly definition which is far too slow to be executable, but it doesn't matter because it won't be executed
17:36:09 <bringert> except by the type checker
17:36:13 <greenrd> well, yes
17:36:36 <greenrd> that's my intuition anyway - I haven't got very far yet so I don't know if that intuition is correct
17:37:07 <bmp> I'm hazy how you would specify that as a *type*.
17:37:34 <bringert> I meant Turing tarpit not in the sense that "everything is possible, but slow", rather "you can do anything you want, but it's a PITA"
17:38:11 <greenrd> bringert, sure
17:38:22 <bringert> greenrd: I don't think you can prove arbitrary decidable properties, but it will be fun to see how far you can get
17:39:08 <greenrd> bringert, well then I can just use undefined or unsafeCoerce when I can't prove something but I "know" it's true :)
17:39:27 <bringert> :-)
17:40:10 <bringert> that's a sound logic if I ever saw one
17:40:17 <greenrd> heh
17:42:41 <greenrd> bmp: I think you would need heterogenous lists for that, which I haven't investigated yet
17:43:50 <greenrd> bmp: but for tuples, we can say e.g. type SortedTriple = ((a,b,c),LessThan a b, LessThan b c)
17:44:10 <greenrd> the tuple carries with it the evidence that it is sorted
17:44:11 <bmp> I know you can do it for tuples. I just didn't know you could do it for lists.
17:44:14 <greenrd> ah ok
17:47:43 <greenrd> now that I've sort of got the hang of this, I plan to implement some standard searching and sorting algorithms (boring but good test), and then open source the framework
17:47:56 <greenrd> although it's kind of like a new language because it's got a completely different prelude
17:48:40 <greenrd> I was going to create a truly new language originally, but then I figured that haskell can probably be made close enough to what I want
18:11:10 <bringert> ADEpt, shapr: you guys are probably asleep, but here's a live Hope demo anyway: http://hope.bringert.net/
18:11:55 <stepcut> bringert: cool
18:12:31 <bringert> stepcut: it uses your RSS module
18:12:41 <stepcut> bringert: excellent !
18:12:42 <Igloo> bringert: Where is the source for that page?
18:13:13 <bringert> Igloo: read the top story on the page for the darcs repo :-)
18:13:54 <Igloo> bringert: But which file is that page?
18:14:00 <bringert> ah, sorry
18:15:12 <bringert> it's database-driven of course, and there isn't a single source for any given page, tehre are different modules. I'll try to give an overview:
18:15:38 <bringert> The "front" module http://www.cs.chalmers.se/~bringert/darcs/hope/modules/front/Module_front.hs handles the front page
18:16:10 <bringert> I have set it to redirect to the "/entry" page, which is lists all entries in the blog
18:16:54 <bringert> http://www.cs.chalmers.se/~bringert/darcs/blob2/Blob.hs handles all the blog pages, dispatching to the right function based on url and request method
18:17:28 <bringert> handleEntries in Blob.hs is what generates and shows the list of all blog entries that you see
18:18:23 <stepcut> bringert: I have a possible bug/feature request for NewCGI
18:19:05 <Igloo> OK, ta
18:19:08 * Igloo disappears
18:19:21 <bringert> is uses Blob.EntryDB.getAllEntries to generate the list of entries, and entriesPage to convert that into a Blob.Page.Page
18:19:25 <bringert> etc.
18:19:34 <bringert> stepcut: yes?
18:19:41 <stepcut> bringert: I was use 'getInput' to key/value pairs from the QUERY_STRING -- but when the user submits a form -- getInput automatically switched to getting the values from the form instead of the URL
18:20:04 <stepcut> is there a function like getInput, that *only* looks at QUERY_STRING ?
18:20:11 <bringert> stepcut: are you using the latest version?
18:20:18 <bringert> stepcut: was it a get or post form?
18:20:19 <stepcut> bringert: probably not
18:20:25 <stepcut> it was a POST form
18:20:54 <bringert> stepcut: ah, I've done some changes so that it merges that QUERY_STRING stuff with the form input. Is that good enough for you?
18:21:13 <stepcut> bringert: what happens if there is a name collision ?
18:21:14 <bringert> I was doing the same thing as you want to
18:21:28 <bringert> stepcut: they you have two values, use getMultiInput
18:21:38 <bringert> I think anyway, I haven't tested it
18:22:20 <stepcut> bringert: hrm. that seems useful -- though it still might want an option that explicitly looks at one or the other
18:22:47 <stepcut> s/it/I/
18:22:53 <bringert> yeah, that could be useful
18:23:07 <bringert> you can always use getVar to get at the QUERY_STRING
18:23:14 <bringert> but then you have to decode it yourself
18:23:40 <bringert> and there is no way to look at only the form inputs I guess
18:23:49 <bringert> what's the scenario?
18:24:08 <stepcut> bringert: well, I only had one key/value pair anyway, so I just set QUERY_STRING to the value and I am done :)
18:24:28 <bringert> :-)
18:24:34 <bringert> you can use PATH_INFO too
18:24:46 <bringert> for that sort of thing
18:25:01 <bringert> foo.cgi/stepcuts_parameter
18:25:09 <bringert> getVar "PATH_INFO"
18:26:04 <stepcut> the other feature that would be nice is the urlEncode/urlDecode functions from WASH's URLCoding (though, it is easy enough to just swipe them from WASH)
18:27:30 <stepcut> i'll try to document my URL/Form code this weekend and send you a copy. I think the URL monad transformer might work well with hope
18:28:06 <bringert> stepcut: urlDecode = Network.URI.unEscapeString . replace '+' ' '
18:28:50 <stepcut> bringert: ah, looks simple enough :)
18:29:44 <bringert> that's from NewCGI, urlEncode is a bit worse, see bottom of http://www.cs.chalmers.se/~bringert/darcs/hawl/Hawl/Util/CGI.hs
18:29:52 <bringert> but maybe NewCGI should expose those
18:30:56 <bringert> they you need the formEncode and formDecode functions too, which deal which the name,value list encoding / decoding
18:31:44 <stepcut> bringert: cool
18:32:34 * stepcut goes home now
18:39:55 <audreyt> @seen syntaxninja
18:39:55 <lambdabot> I saw syntaxninja leaving #haskell, #darcs and #haskell-blah 1 hour, 37 minutes and 8 seconds ago, and .
18:40:08 <audreyt> @type (and .)
18:40:09 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
18:40:16 <azuroth_tafe> hi audreyt
18:40:27 <audreyt> @type ((,) and .)
18:40:29 <lambdabot> forall b a. (a -> b) -> a -> ([Bool] -> Bool, b)
18:40:50 <audreyt> hi azuroth_tafe
18:40:51 <dons> morning audreyt
18:43:26 <azuroth_tafe> do you know where I can find examples of classes with multiple parameters?
18:44:01 <dons> Control.Monad.* ?
18:44:11 <dons> in the mtl library
18:44:19 <dons> ?fptools Control.Monad.Reader
18:44:19 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
18:46:39 <azuroth_tafe> hmm, I think I'm even more confused now
18:47:53 <azuroth_tafe> what I want is.. a class "Client => Factory a c" with create :: a -> c.. but maybe I'm going in the wrong direction?
18:48:18 <dons> Client ... ?
18:48:34 <dons> Client is missing an argument
18:48:40 <azuroth_tafe> oops, Client c =>
18:48:49 <dons> Client a => Factor a where create :: a -> c ?
18:49:01 <dons> or is the 'c' unique for every 'Factory a' ?
18:49:26 <dons> maybe, class Factory a where create :: Client c => a -> c ?
18:49:46 <dons> what do you want your instances to look like?
18:50:29 <azuroth_tafe> maybe like "instance TestFactory TestClient where ... create = TestClient"
18:51:08 <Excedrin> is there something like "map (\(x,y) -> x y)" already?
18:51:48 <Korollary> ?pl map (\(x,y) -> x y)
18:51:48 <lambdabot> map (ap fst snd)
18:53:18 <dons> ?type map (fst `ap` snd)
18:53:19 <lambdabot> forall b b1. [(b1 -> b, b1)] -> [b]
18:53:40 <dons> ?karma+ pl
18:53:40 <lambdabot> pl's karma raised to 1.
18:58:15 <SamB> @karma- pl
18:58:15 <lambdabot> pl's karma lowered to 0.
18:58:21 <SamB> @karma+ @pl
18:58:22 <lambdabot>  @pl's karma raised to 1.
18:59:25 <SamB> dons: please to be using @ for commands; bare is for people!
19:00:53 <dons> SamB?
19:00:55 <SamB> also, @karma needs to be case sensitive
19:01:01 <dons> it is, iirc
19:01:02 <SamB> @karma @karma
19:01:02 <lambdabot>  @karma has a karma of -1
19:01:05 <dons> ?karma+ PL
19:01:06 <lambdabot> PL's karma raised to 1.
19:01:09 <dons> bah, oh well
19:01:09 <lisppaste2> azuroth pasted "factory? classes?" at http://paste.lisp.org/display/20906
19:01:10 <SamB> er, insensitive
19:01:14 <dons> you know how to patch...
19:01:29 <dons> SamB, what's your point about '@'? I didn't understand .
19:01:33 * SamB said it backwards
19:02:14 <SamB> well, the convention seems to be to refer to commands with @, when setting their karma
19:02:27 <azuroth_tafe> it makes even less sense backwards...
19:02:40 <dons> SamB: oh. I see.
19:02:49 <dons> yeah, good point
19:02:57 <dons> @karma-list
19:02:57 <lambdabot> Unknown command, try @list
19:03:00 <dons> @karma-all
19:03:00 <lambdabot>  dons                   36
19:03:00 <lambdabot>  Lemmih                 17
19:03:00 <lambdabot>  shapr                  17
19:03:00 <lambdabot>  xerox                  15
19:03:00 <lambdabot>  dcoutts                14
19:03:02 <lambdabot> [165 @more lines]
19:03:03 <dons> @more
19:03:04 <lambdabot>  lambdabot              14
19:03:06 <lambdabot>  Cale                   13
19:03:08 <lambdabot>  QuickCheck             10
19:03:10 <lambdabot>  musasabi               10
19:03:12 <lambdabot>  SamB                    9
19:03:14 <lambdabot> [160 @more lines]
19:03:15 <dons> ah well, no commands rate that highly.
19:03:33 <Lemmih> azuroth_tafe: What's up with the post?
19:04:03 <azuroth_tafe> does it look valid, or crazy? I probably should've pasted the errors I was getting, hold on
19:04:41 <Lemmih> It looks crazy (:
19:05:18 <azuroth_tafe> oh, okay. does it.. show my intent?
19:05:22 <SamB> @karma darcs
19:05:22 <lambdabot> darcs has a karma of 2
19:08:02 <SamB> @more
19:08:24 <Lemmih> azuroth_tafe: Hm, it's a bit weird.
19:08:42 <azuroth_tafe> what I really want, is a sort of ListenClient class which returns a certain type of Client, where Client is a class that can send and receive stuff
19:09:35 <azuroth_tafe> i.e. (instance ListenClient TestListen TestClient) which just returns new TestClients
19:13:25 <dons> ?karma+ ADEpt -- HHGttH ,and the quote "darcs get and drown me in patches"
19:13:25 <lambdabot> ADEpt's karma raised to 6.
19:17:23 <SamB> heh
19:17:40 <Lemmih> azuroth_tafe: It's having problem dermining the 'o' from the 'f'.
19:17:43 <Lemmih> *problems
19:19:08 <azuroth_tafe> but... shouldn't that just be whatever is an instance of Factory?
19:21:11 <Lemmih> The last statement 'useFactory fac' is using 'fac' with type 'f' but it doesn't say that the 'o' should be the same as before.
19:22:48 <azuroth_tafe> hmm, okay, so how do I fix that?
19:24:31 <Lemmih> Either with a fundep or a slight restructuring of the function.
19:25:30 <azuroth_tafe> fundep... hmm
19:28:18 <azuroth_tafe> I'll look into it, thanks :D
19:28:41 <Lokadin> when you add things to a list with ++ does it create a new list or does it simply add it to the existing? and is it possible to add to the existing list without creating a new one
19:29:09 <azuroth_tafe> why do you care about that, lokadin? :-p
19:29:13 <mauke> x ++ y copies x but shares y
19:29:37 <SamB> Lokadin: it makes a new one, and it is impossible, but the tail of the new list is the old list
19:29:46 <SamB> er, the back part
19:29:56 <Lokadin> okay thanks :)
19:30:45 <azuroth_tafe> whoaa, it works! thank you lemmih!
19:30:52 <mauke> you can write a ListBuilder that avoids excessive copying
19:32:22 <Daveman> :)
19:32:29 <Lokadin> what's a ListBuilder?
19:35:11 <mauke> an imaginary data structure that supports O(1) appending/prepending and O(n) list conversion
19:35:44 <Lokadin> oh .ui thanks, say could i have different types in a list?
19:36:15 <mauke> no
19:36:44 <Lokadin> oh okay:) just wondering
19:39:19 <Cale> Though if you ever feel the need for it, have a look at existential types, which basically give you a way to throw away all type information except that a particular set of typeclasses is supported.
19:39:44 <Lokadin> kk, thanks 
19:42:28 <azuroth_tafe> oh, wow
19:42:57 <audreyt> and there is HList.
19:44:09 <SamB> hmm, what is good game to play...
19:44:24 <bringert> dons: ever seen this: GHCi runtime linker: fatal error: I found a duplicate definition for symbol
19:44:27 <bringert>    _count
19:44:30 <bringert> whilst processing object file
19:44:32 <bringert>    /usr/local/lib/fps-0.7/ghc-6.5/HSfps-0.7.o
19:54:46 <SamB> ouch!
19:55:23 * SamB would have thought that would have come up before, what with all this hs-plugins and stuff
19:55:45 <dons> bringert: yeah, when someone doesn't remove the cbits in fps from a ghc 6.5 build
19:56:06 <SamB> (Though maybe that doesn't happen because Linker.c only uses the symbols in its list from the executable?)
19:56:33 <Dino_> When using Text.Printf.printf, say I set something like 'let number = 42', why do I then need to pass it to printf like (number::Int) ?
19:56:51 <dons> you have to constrain the type to members of Printf's printable class
19:57:15 <dons> declaring number :: Int would work too
19:57:25 <Dino_> But number isn't :: Int in that let statement already?
19:57:37 <dons> > let n = 42 :: Int in printf "%-2%d\n" n
19:57:38 <lambdabot>  Add a type signature
19:57:41 <dons> > let n = 42 :: Int in printf "%-2%d\n" n :: String
19:57:42 <lambdabot>  Exception: Printf.printf: bad formatting char %
19:57:47 <dons> > let n = 42 :: Int in printf "%-2d\n" n :: String
19:57:48 <lambdabot>  "42\n"
19:57:52 <dons> Dino_: nope
19:57:59 <dons> ?type let n = 42 in n
19:58:00 <lambdabot> forall t. (Num t) => t
19:58:01 <bringert> dons: thank you, that was it
19:58:20 * SamB tries playing Wesnoth again...
19:58:34 <SamB> I'll probably fail the mission again...
19:58:45 <Dino_> Is it because Num isn't specific enough for the %d (in the printf format string)?
19:58:50 <bringert> @karma +1 dons
19:58:50 <lambdabot> +1 has a karma of 0
19:59:03 <bringert> @karma dons +1
19:59:04 <lambdabot> dons has a karma of 36
19:59:06 <bringert> ah
19:59:24 <dons> karma+ ?
19:59:38 <dons> karma isn't higher order ;)
20:00:07 <dons> Dino_: right.
20:00:55 <Dino_> The type inference is trying to use the most general type it can in the let.
20:01:05 <dons> yep.
20:01:10 <Dino_> Thank you.
20:09:20 <bringert> dons: do you know if there is some problem with the current hs-plugins darcs version and ghc-6.5? It keeps saying "couldn't find symbol" when I use load. I may have done something stupid, just checking if there is some known issue, like ABI changes.
20:10:18 <dons> hmm. no, i don't know of anything. other than the mac is broken..
20:10:25 <bringert> heh
20:10:25 <dons> and in 6.4.x too, iirc
20:10:40 <bringert> I guess I should have said I'm on OS X
20:11:10 <dons> i think that's it. something's changed in the way symbols are named, or found, and i've not been able to solve it. needs a mac guy to dive in.
20:11:30 <dons> should be the case with 6.4.x and 6.5. 6.2.2 worked 
20:11:44 <dons> its to do with the new -dynamic stuff, i suspect
20:12:14 <bringert> I'm new to Mac, so I don't think I'd be of much help
20:12:49 <bringert> no biggie, just a demo, I'll run in in my Linux VM instead
20:38:14 <bringert> cool, it worked on Linux. just a few lines of code for a FastCGI server which compiles, loads and runs Haskell files with NewCGI programs
20:39:22 <syntaxfree> has someone implemented matlabby numerical libs for Haskell already?
21:07:33 <Lemmih> We just passed 06-06-06 06:06:06.
21:07:52 <syntaxfree> the numbah of the beast.
21:09:50 <Stinger_> apparently 6/6 passed a while back since the astronomer that changed the dates when the roman empire converted to christianity got the dates wrong or something
21:11:17 <dons> bringert: sounds cool
22:40:40 <scodil> can two types have labelled fields with the same name?
22:41:19 <scodil> data Edge = Edge { next::Edge } ; data DualEdge = DualEdge { next::DualEdge } ; 
22:41:25 <SamB> no :-(
22:41:28 <scodil> bummer
22:41:29 <scodil> why not?
22:41:40 <lispy> because the names are functions at the top level
22:42:09 * lispy isn't sure if the haskell crowd uses the term 'top level'
22:42:22 <scodil> its ok. i'm not in the haskell crowd
22:42:30 <scodil> i got your drift
22:43:35 <scodil> would there be a way to fake that kind of named-parameter behavior, maybe using an overloaded function?
22:43:42 <scodil> can you overload functions, or just operators?
22:44:38 <lispy> overloading happens via type classes
22:44:40 <mauke> operators are functions
22:45:16 <lispy> so you could have an Edge type class that defined things like next, and then each instance of Edge would define 'next'
22:45:32 <scodil> gotcha
22:46:18 <lispy> i wish named records worked the way they do in lisp
22:46:29 <scodil> refresh my memory. how do they work in lisp?
22:46:30 <lispy> then you wouldn't get name classes
22:46:36 <lispy> ec clashes
22:46:43 * lispy can't type
22:47:01 <lispy> the accessor/mutator is named like 'struct-record'
22:47:21 <lispy> so Edge-next in your case, but that's not a valid identifier in haskell
22:47:35 <scodil> i see
22:47:58 <scodil> i suppose you could just call it edge_next and dualEdge_next
22:48:08 <lispy> yup
22:55:55 <Korollary> Gah. We gotta have an article on monomorphism restriction on the new wiki (the old one needs a clean-up if it is to be moved).
23:13:10 <_Stinger_> heh this doesnt have anything to do with me does it? :)
23:13:31 <lscd> is it possible to do type inferencing on a language where data values can be widened and shrunk (where shrinking can cause loss of information / runtime errors)?  
23:15:45 <lispy> lscd: like type erasures in java generics?
23:16:04 <lscd> lispy: i'm not aware of those
23:16:08 <lispy> lscd: i'm not expert so i probably can't comment, but what is an example of widening and shrinking?
23:16:22 <lscd> in this particular case, the most obvious example is with subrange types
23:16:28 <lscd> so, you can have your integer type
23:16:35 <lscd> and various 'subranges' of it
23:16:45 <lscd> such as 0..10
23:16:53 <lscd> and these subranges are considered as distinct types
23:17:08 <lispy> oh, yeah, CL does that
23:17:11 <lscd> the language has fixed syntax, but it doesn't have fixed semantics
23:18:20 <lscd> there are varients where i can pass a subrange type to a function expecting an int, varients where i can do that and i can also pass ints to functions expecting subrange types, and varients where i can't do either
23:19:15 <lispy> i think you could fake it using carefully crafted types and modules
23:19:29 <lispy> but it wouldn't be very dynamic
23:19:34 <lscd> it's a static language
23:19:49 <lscd> variables have types in it
23:21:12 <lispy> afaik, the haskell way to create, for example, naturals as a subtype of Integer would be to create a Naturals module and then only export a smart constructor that allows only valid natrals to be created
23:21:32 <dons> yeah, or lift the Nat to the type level
23:21:37 <lispy> so, mkNat -1 = undefined
23:21:40 <dons> there's some stuff on this on the idioms page
23:21:45 <lscd> yeah.... this system has no idea of things like typeclasses though
23:21:47 <dons> ?wiki Idioms
23:21:47 <lambdabot> http://www.haskell.org/haskellwiki/Idioms
23:21:56 <lscd> it's a very different language from haskell
23:22:04 <dons> actually, not Idioms
23:22:07 <dons> ?gwiki Smart_constructors
23:22:09 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
23:22:55 <lispy> lscd: you don't need type classes for what i was thinking, you just need to be able to hide some functions like the datatype constructor
23:22:55 <dons> yeah, there's an example there of lifting the Nat to the type level, to enforce a constraint on the valid naturals
23:23:46 <lscd> hm. give me a few minutes. it's going on about phantom types at that point
23:24:20 <lispy> i'll give you very many minutes as i'm going to sleep now :)
23:24:28 <lscd> sleep well, lispy; and thanks
23:24:46 <lispy> yw, good luck
23:28:43 <lscd> dons... hm. but it's using peano numbers
23:28:51 <lscd> wouldn't that be insane for large types?
23:29:41 <SamB> lscd: well, you need typeclasses for binary, I think
23:30:12 <lscd> the language, at present, has subrange types, integers, arrays, and first-order procedures
23:30:24 <dons> lscd: for large types, you use type classes to encode decimal
23:30:36 <dons> ie. (D9,D7,D0,D4) == 9704
23:30:44 <lscd> arrays can contain only one type; arrays of different lengths are different types
23:30:58 <lscd> that is, i believe, the whole type system
23:31:25 <SamB> is that Pascal?
23:31:35 <lscd> hm... ok, cool encoding; but it still only helps a limited amount when you want to have a large range, i think?
23:31:41 <lscd> SamB: no, though it's reminiscent
23:31:56 <lscd> it's an obscure academic language (and no, i didn't write/create it)
23:34:02 <lscd> it has a fairly funky mixture of configurable and inflexible components - ie, you can choose scoping, type of type equality, and whether assignments can be to a type wider than that of what's being assigned to it, from a web interface
23:36:58 <lscd> so... what i'm curious about atm is whether or not it's possible to write type inferencing for it
23:37:59 <lscd> it would have to be a fairly weird type inferencer, i think, since things like whether i could assign the value of a variable of a subrange type to a variable of an int aren't fixed in general, though for any particular compile and run they are
23:38:49 <lscd> in general, is there some minimum set of properties that need to hold for type inferencing to be possible?
23:43:47 <_Stinger_> omg I actually got withLinearPattern to work, now I can go to the shop and buy myself some timtams
23:58:28 <SamB> timtams?
