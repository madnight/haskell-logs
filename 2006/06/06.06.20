00:02:04 <satan> can someone please explain what's going on in this line, break it down a little? It's a bit beyond me: reverse = foldr (flip append) [] . map (:[])
00:02:30 <satan> reverse = foldr (flip append) [] . map (:[]) , there now it's in one line, easier to read :)
00:03:12 <Pseudonym> > foldl (flip (:)) [] "hello"
00:03:14 <lambdabot>  "olleh"
00:03:52 <satan> right, thats with foldl
00:06:31 <Kasperle> @type flip
00:06:32 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
00:09:39 <Pseudonym> @pl \x -> flip (.) (x:)
00:09:40 <lambdabot> flip (.) . (:)
00:09:59 <Pseudonym> > flip (foldr (flip (.) . (:)) id) [] "hello"
00:10:00 <Kasperle> what does the "." do?
00:10:00 <lambdabot>  "olleh"
00:10:07 <Pseudonym> Slightly shorter, using foldr.
00:10:57 <Pseudonym> Kasperle: . is function composition.
00:11:47 <Kasperle> ah
00:18:00 <satan> ok that helped, i think i figured that one out now
00:18:03 <satan> boy, haskell is hard
00:19:28 <Pseudonym> No, pointless style is hard to read.
00:19:44 <satan> so, that reverse up there was pointless?
00:19:53 <Pseudonym> Yeah.
00:20:10 <satan> ok
00:21:25 <mwc> We need an unpl function for lambdabot 
00:22:45 <sieni> mwc: what would it do? something like <pl-expr> -> (\x -> (<pl-expr>) x) ?
00:54:14 <jer> anybody know of any reason why ghc would be taking an hour to link an executable? (it keeps consuming memory and releasing it like it's doing something)
00:54:31 <jer> this is starting to get irritating
01:02:20 <Igloo> ghc or ar?
01:02:48 <Igloo> If you have a lot of symbols then it can take a long time, although an hour on a decently specced machine is suspiciously long
01:07:15 <jer> Igloo, it's not really a decently spec'd machine; it's a p3 450... but it's been just over an hour now and i think its getting a little ridiculous; ghc is running and ld is what's using up all the memory
01:07:29 <jer> and yes there are a lot of symbols, but an hour+?
01:12:02 <xerox> ?yow!
01:12:02 <lambdabot> HOORAY, Ronald!!  Now YOU can marry LINDA RONSTADT too!!
01:13:56 <dcoutts> jer, Igloo, I found that too, so I hacked libbfd so that it doesn't take so much memory when generating the archive index. The patch has been included upstream and will be in the next version of binutils.
01:14:49 <jer> that doesn't help me for at elast another year anyway (freebsd 7.0 will be the next chance for a major compiler update)
01:14:52 <jer> heh
01:15:01 <jer> but okay, nice to know the problem has been fixed anyway =]
01:15:02 <dcoutts> on my system it reduced memory consumption from >500mb to <100mb for building libHSbase.a
01:17:20 <jer> now its swapping something hardcore, weee
01:17:25 * jer <3 ghc =/
01:17:27 <jer> oh well, thanks guys
01:18:50 <dons> moin
01:20:15 <dcoutts> dons, nice graphs :-)
01:20:42 <dons> any other projects i should stick in my crontab to graph?
01:26:25 <dons> dcoutts: do you have any example bytestring programs that aren't optimised the way they should be?
01:26:38 <dons> roman's found 3 bugs in the simplifier today, and he's try to collect some example programs
01:26:40 <Igloo> Oh, if you're into swap then taking huge amounts of time is much less suspicious
01:27:30 <dcoutts> dons, I don't think so. I think all the cases where the simplifier didn't do what I wanted were due to unimplemented features / missing analyses etc.
01:27:47 <dons> ok.
01:27:53 <dcoutts> dons, what bugs did Roman find?
01:28:17 <dons> i'm not sure of the details, but the new Stream stuff is running as fast as the C programs from the ndp benchmarks
01:28:20 <dons> !
01:28:43 <dons> so i want to get this ported to fps soon, once it hits the main ndp repo
01:31:45 <mahogny> hm. an interesting addition to the darcs graph would be to show a timeline of when new projects are started and then dependencies to which libraries they use. that would be really useful
01:32:50 <BCoppens> dons: lambdabot is yours, right?
01:32:59 <dons> thats more cabal hacking, mahogny. hackageDB could do it
01:33:01 <dons> BCoppens: yep
01:33:05 <dons> ?version
01:33:05 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
01:33:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:33:32 <dons>                                        ^^^^
01:33:35 <dons> ;)
01:33:35 <BCoppens> dons: you might want to considder putting a size limit on the URL - Title extraction thingie, or at least filter mp3s
01:33:39 <BCoppens> yeah exactly ;)
01:33:46 <BCoppens> that's why I asked you :P
01:33:50 <dons> ah, i thought we had a size limit
01:33:55 * dons checks
01:33:59 <dons> do you have a test case?
01:34:13 <dons> oh, you mean, i probably shouldn't download mp3s
01:34:23 <BCoppens> indeed
01:34:31 <dons> hmm. i hope it doesn't work that way.
01:34:39 <dons> petekaz is the author
01:34:56 <xerox> mp3 plugin for lambdabot?!
01:35:22 <dons> ?url-off
01:35:23 <lambdabot> Url disabled
01:35:25 <BCoppens> dons: I have no clue if it actually downloads it completely, since it didn't get it from me ;)
01:35:36 <dons> well, i think it does :(
01:35:40 <dons> but easy to fix
01:35:43 <dcoutts> dons, sounds very good.
01:35:50 <BCoppens> dons: :)
01:36:20 <dons> @tell petekaz can you tweak Url.hs to only download the first few lines, or else fail. i don't want to blow my ip quota :)
01:36:20 <lambdabot> Consider it noted.
01:36:41 <dons> @tell petekaz i.e. does @url currently download a full .mp3, for example?
01:36:41 <lambdabot> Consider it noted.
01:39:06 <kzm> I need to interface to a (shudder) C++ library.  Is there a standard way?
01:39:18 <dons> via a C wrapper, i think
01:39:55 <kzm> How do I write a portable wrapper?
01:40:26 * dons -> home
01:41:44 <kzm> Anybody have examples/guidelines/documentation for doing this?
01:42:00 * kzm should perhaps ask in a C or C++-related channel.
01:44:44 <mahogny> kzm, no standard way really. a straight-forward way is to provide a function for each method  myfunc_method(class, method parameters)
01:45:17 <dark-mage> so haskell is not a lisp?
01:45:32 <kzm> mahogny, I just need to access a handful of functions, classes etc are just under the hood, I think.  Not externally visible.
01:45:48 * kzm looks up 'extern "C"'
01:45:51 <mahogny> dark-mage, on!
01:45:53 <mahogny> *no
01:46:06 <mahogny> kzm, right. so the straight forward way is just tedious, but nice if you have an automatic converter
01:47:19 <kzm> So if I just wrap the interface functions with 'extern "C"', their names should be unmangled for linking, right?
01:47:30 <kzm> And this should be portable?
01:47:57 <kzm> (My god, it's been a long time since I did any C++)
01:49:13 <Lemmih> Yes.
01:49:33 <xerox> Howdy Lemmih, how's music? (-:
01:50:54 <Lemmih> The music is pretty good.
01:55:33 <xerox> I was having a sugar shortage... breakfast to the resque!
01:55:42 <dcoutts> mmm, tea
02:00:34 <vincenz> que pasa
02:42:22 <defcon8> is there official haskell apparel?
02:42:57 <defcon8> oh found it never mind
02:43:10 <dcoutts> http://haskell.org/haskellwiki/Merchandise
02:45:18 <defcon8> why should one learn haskell over common lisp or scheme?
02:46:14 <psnl> defcon8: the type system
02:46:38 <defcon8> as in separation from ints and strings and so on?
02:48:11 <dcoutts> that's simple stuff, there are many more complex exaples where the payoff is greater
02:48:21 <psnl> yeah, it prevents run time foul-ups
02:48:25 <dcoutts> @type GHC.Base.build
02:48:26 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
02:48:51 <defcon8> which would you say is more practical in a business world?
02:48:52 <dcoutts> defcon8, try using that correctly without the type to guide you
02:49:14 <dcoutts> defcon8, depends how much you value reliability
02:49:32 <defcon8> well reliability would be important i say
02:49:48 <dcoutts> then you should consider static typing 
02:50:11 <defcon8> meaning that a type can not change?
02:50:21 <dcoutts> in my personal experience, strong static typing allows me to be so much more productive
02:50:30 <dcoutts> because my programs work first time much more often
02:50:45 <dcoutts> than if I have to do endless edit-compile-debug cycles
02:51:06 <dcoutts> it also allows one to be more ambitious in the complexity of abstractions that one builds
02:51:27 <dcoutts> and of course, building better abstractions is also a great productivity boost
02:52:07 <dcoutts> in the languages I used to use, I simply couldn't rely onmyself to do the more complex things correctly
02:52:13 <defcon8> i found that i do less errors in scheme than i do in python or similar languages
02:52:19 <defcon8> i don't know about haskell though
02:52:35 <dcoutts> with the use of good types I can haev the compiler tell me when I've been inconsistent
02:53:00 <dcoutts> so you have more of a chance to do the more complex things correctly.
02:54:13 <defcon8> do you do lots of maths things?
02:56:02 <dcoutts> defcon8, not really
02:56:08 * dcoutts -> office
02:56:25 <defcon8> what type of stuff do you programme?
03:18:14 <dcoutts_> defcon8, GUIs, program analyses, tools
03:23:13 <shapr> poing
03:23:14 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
03:25:11 * Igloo wonders why that's on channel
03:32:32 <shapr> yargh
03:33:32 <dcoutts_> @yargh
03:33:32 <lambdabot> Unknown command, try @list
03:33:37 <dcoutts_> bah
03:33:39 <dcoutts_> @yarg
03:33:40 <lambdabot> Maybe you meant: arr part
03:33:42 <shapr> dons: Hey, did you get my message about wiki vs blog?
03:33:45 <dcoutts_> @yarr!
03:33:45 <lambdabot> Swab the deck!
03:34:20 <shapr> @yarrgh
03:34:20 <lambdabot> Unknown command, try @list
03:34:22 <shapr> @yarrgh
03:34:22 <lambdabot> Unknown command, try @list
03:36:28 <dcoutts_> @yarrg
03:36:29 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
03:37:22 <dcoutts_> it's a edit distance of 2 or something like that
04:16:32 <shapr> I wish unix commands had flip.
04:16:51 <shapr> It's hard to use xargs on cp for example.
04:17:10 <Muad_Dibber> cant you write a flip command then?
04:17:12 <Cale> It's easy enough to write flip
04:17:43 <audreyt> isn't it just rev?
04:18:00 <audreyt> or do you want to rev only the first two lines?
04:18:12 <shapr> audreyt: Nah, I want to be able to pass the target of a cp command as the first argument.
04:18:19 <Cale> not reversing files, reversing args
04:19:02 <audreyt> oh.
04:19:17 * audreyt goes back writing slides for the MS talk, due to be on air in <8hrs
04:19:27 <audreyt> I get to advocate Haskell some more :D
04:19:33 <audreyt> emeijer++ # dragged me here
04:19:40 <shapr> Cool!
04:20:13 <audreyt> so... bbiab :)
04:20:14 <audreyt> &
04:30:54 <shapr> It occurs to me that a lazy file duplicate checker could be very much more efficient than a strict checker.
04:31:19 <Philippa_> seems to me this is the one piece of laziness even C has?
04:31:51 <shapr> How so?
04:32:19 <shapr> I was thinking about first checking file size, then checking md5sum of the first and last blocks of the file, and then comparing the rest of the file only if all the previous conditions match.
04:34:45 <Philippa_> yeah, that's not really a laziness thing per se though. I'd been thinking of the fact logical and shortcuts in C
06:51:53 <petekaz> morning?
06:51:54 <lambdabot> petekaz: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:53:48 <neologism> couldnt lambdabot /msg these things?
06:55:19 <Dino_> Morning, pete.
06:56:01 <petekaz> Just wondering if I really was connected as its been dead quiet in here for a few hours.
06:56:17 * gds vaguely wonders if it'd be possible (or even vaguely desierable) to mod the eval plugin to give IRCers access to a subset of the Plugin functionality...
06:56:38 <petekaz> Whatever happened to the 'Monad Reader'?
06:57:11 <petekaz> I just discovered it a few days ago.  It seems like a nice resource.
06:58:01 <SamB> petekaz: shapr stopped editing it
07:05:08 <ihope> @hoogle (a -> Bool) -> [a] -> a
07:05:09 <lambdabot> No matches, try a more general search
07:10:42 <xerox> ?hoogle (a -> Bool) -> [a] -> [a]
07:10:42 <lambdabot> Hoogle Error: Parse Error: Unexpected character ' [a]'
07:10:51 <xerox> ?hoogle (a -> Bool) -> [a] -> Bool
07:10:52 <lambdabot> Hoogle Error: Parse Error: Unexpected character ' Bool'
07:52:07 <dropdrive> Am I right to think that splitAt n xs is somehow "more efficient" than (take n xs, drop n xs)?
07:54:56 <dcoutts_> see how it's defined in ghc
07:55:35 <dcoutts_> yes, the definition is not simply (take n xs, drop n xs)
08:33:29 <Cale> zilt: hello, are you new here?
08:43:28 <zilt> Cale: To Haskell, yes.  I've been working on learning it for the last couple of weeks.  
08:45:40 <Cale> cool, any questions?
08:47:47 <zilt> Cale: Not currently - but I'm sure I will in a few days.  Thanks for asking.
09:03:36 <norpan> learning haskell for a few weeks and NO questions!
09:05:31 <dfeuer> Hey norpan 
09:05:57 <dfeuer> I just read a talk someone linked to (I think) on 2-3 finger trees.  Very cool.
09:07:03 <dmhouse> dfeuer: link?
09:07:15 <dfeuer> uhhh...
09:07:33 <dfeuer> http://www.informatik.uni-bonn.de/~ralf/publications/FingerTrees.pdf
09:07:37 <dfeuer> is the paper
09:07:41 <dfeuer> The talk's around
09:07:43 <dfeuer> 1 sec.
09:07:55 <dmhouse> It's a cool paper.
09:09:01 <dfeuer> The talk's at http://www.informatik.uni-bonn.de/~ralf/talks/Oxford.pdf
09:09:13 <ihope> Thue's a great programming language. Everything works quit automagically.
09:09:20 <ihope> Quite, that is.
09:10:01 <dmhouse> Cool, thanks dfeuer.
09:10:21 <bighead> hi guys, which book would you recommend for someone starting out on Haskell (But more than familiar with functional programing). Especially one which has a bit more emphasis on some practical applications. Paul Hudak's or Simon Thompson's
09:10:47 <dfeuer> Hudak's the reactive programming guy?
09:11:08 <sieni> bighead: neither
09:11:16 <bighead> if thats the The Haskell School of Expression: Learning Functional Programming through Multimedia guy, yes
09:11:19 <bighead> sieni: then?
09:11:31 <dfeuer> bighead, I'd probably avoid the Hudak stuff.
09:11:57 <bighead> ok... why'd you say? because of the Multimedia stuff?
09:12:26 <sieni> bighead: if you already know functional programming, say Scheme, Common Lisp, SML or OCaml, I'd suggest to read "A Gentle Introduction to Haskell" from http://www.haskell.org/tutorial/
09:12:48 <dfeuer> Hudak's books are a bit out of date, as I recall.  His team's come up with better ideas since then.
09:13:12 <dfeuer> BUt I could be confusing him with someone else, I guess.
09:16:01 <dmhouse> bighead: be warned that it takes a while before you can write practical things with Haskell. Not saying it's an impractical language, but just that you need to learn the theory first.
09:22:36 <bighead> ok....so.... in terms of books you guys wouldn't recommend getting any?
09:23:30 <dmhouse> 'Haskell: The Craft of Functional Programming' is popular. However, I'm not one to ask about books, because that's not how I learnt.
09:24:29 <pejo> I've read Thompson's book, I found it just fine at the time. I haven't read Hudak's though, so no opinion there. 
09:24:38 <xerox> `The Haskell way to Logic, Math, and Programming.' is also nice.
09:27:46 <Philippa_> bighead: if you're more than familiar with FP, read A Gentle Introduction to Haskell and start messing around
09:28:20 <bighead> Philippa_: ok...its just that stuff like 'proving your programs' which appear in one of those books seem interesting to me...
09:28:23 <Philippa_> an interpreter for a language that does interactive stuff'd prolly be one good first project - a simple command-line client for a protocol you can just about hack using telnet for another
09:28:46 * bighead tries to find the books in his library
09:28:51 <Philippa_> ah. Never done that out by hand myself, but if you're interested then yeah, books will be more useful
09:29:10 <Philippa_> you'll find induction's one of the more common proof techniques, though it doesn't work any time you can end up with an infinite structure
09:29:39 <Philippa_> anyone got a recommendation for a book for my non-coder boyfriend btw? I don't mind doing some explaining around, but he wants something he can read in bed
09:30:54 <xerox> Yup. Let me find the title.
09:32:02 <Philippa_> (it's less important that it covers things like interactive apps though it'd be cool - I can explain interaction)
09:32:20 <xerox> Ah, something cs-related only?
09:32:50 <psykotic> p5ycho: you can do transfinite induction too.
09:33:11 <xerox> This book makes you jump up and down even if you are not keen in mathematics http://www.simonsingh.net/Fermat_Corner.html
09:33:19 <xerox> (Nothing related to Haskell, though.)
09:33:25 <Philippa_> haskell-specific
09:33:40 <xerox> I suggest that book anyway :-)
09:34:37 <Philippa_> psykotic: does that work on algebraic datatypes?
09:34:42 <bolrod> what will be the next such a problem :)
09:34:50 <bolrod> P=?NP   ?
09:34:50 <bolrod> :)
09:35:16 <Cale> Riemann Hypothesis is getting there
09:35:30 <Cale> the abc conjecture is something closer to FLT
09:35:52 <dmhouse> xerox, I'm reading that right now. :)
09:36:05 <dmhouse> abc conjecture?
09:36:15 <Cale> http://en.wikipedia.org/wiki/Abc_conjecture
09:37:01 <dmhouse> Hmm, can't say I've heard of that one.
09:37:39 <dmhouse> The proof of more of a 'superstar conjecture' like the Riemann Conjecture would likely be more of an analogue to FLT.
09:38:05 <Cale> It depends on how you generalise
09:38:18 <dmhouse> True. abc is at least number-theoretic.
09:38:57 <xerox> What would you suggest to show the beauty in mathematics, apart from FLT?
09:39:31 <Cale> If the abc conjecture is true, it implies FLT (directly) for sufficiently large powers.
09:40:06 <Cale> So it's a "more general version" in some sense.
09:40:09 <int-e> Fermat's theorem was interesting because it is accessible to pretty much everyone. Much like the Goldbach conjecture.
09:41:03 <Cale> The Collatz conjecture is a nice one
09:42:03 <dmhouse> int-e, that's true. But then the four colour proof was similarly accessible, and didn't the same kind of buzz, did it?
09:42:04 <Cale> and the Twin prime conjecture
09:42:26 <Cale> dmhouse: The 4-colour proof was specifically inaccessible
09:42:44 <dmhouse> Cale, sorry, I meant the problem was accessible.
09:42:52 <int-e> dmhouse: me too.
09:43:11 <Cale> Oh, sure, but it got a good deal of attention as far as these things go
09:43:23 <dmhouse> int-e, Yes, I didn't expect you to be calling the _proof_ of FLT accessible ;)
09:43:54 <Cale> oh, here's an unsolved problem
09:44:40 <Cale> Is there an integer solution to a^b + c^d = 6, b >= 2, d >= 2.
09:44:44 <Cale> ?
09:45:15 <int-e> Hmm, the proof dates from 1976? I wouldn't know of any media buzz about it that.
09:45:34 <int-e> then.
09:47:30 <sethk> Cale, you mean whether there is a solution is unknown, or the method of proving that there is (or isn't) a solution is unknown?
09:47:55 <int-e> sethk: that's a silly question
09:48:20 <Cale> sethk: both
09:48:23 <int-e> sethk: if there was a known solution, it wouldn't be an open problem. if there was a known proof, it wouldn't be an open problem either.
09:48:32 <int-e> sethk: (that there are no solutions)
09:48:49 <lightstep> Cale, is it 6 on the rhs?
09:49:02 <Cale> lightstep: that's what I wrote, yes
09:49:27 <int-e> A funny thing would be knowing that there is a solution but not knowing a solution, hmm.
09:49:43 <lightstep> oh, i was confuseing "integer" and "natural"
09:49:55 <sethk> int-e, that's not true.  there are many problems with a known solution but without a known proof
09:50:24 <dmhouse> sethk: What do you mean by proving a problem? Surely that's finding a solution, or proving that no solutions exist?
09:50:27 <int-e> I don't understand your notion of proof.
09:50:33 <Cale> er, hmm, oh
09:50:40 <dmhouse> (Or an existance proof for a solution. Perhaps you're getting things backwards?)
09:50:47 <Cale> actually, all 4 should be greater or equal to 2
09:51:03 <sethk> dmhouse, you can show a solution simply by providing the values.  That's hardly the same as showing a general method of solving.
09:51:12 <int-e> Cale: hmm, that makes no sense.
09:51:24 <Cale> er
09:51:25 <dmhouse> sethk: Oh, so by 'solve' you mean 'find all solutions'?
09:51:27 <Cale> hehe
09:51:34 <dmhouse> sethk: Sorry, but 'prove' you mean 'solve'?
09:51:36 <Cale> right
09:51:38 <dmhouse> s/but/by/
09:51:43 <Cale> nevermind that :)
09:51:50 <sethk> dmhouse, I'm using the terms imprecisely, but that doesn't mean that my question didn't make sense  :)
09:51:54 <dmhouse> You're using the word 'prove' where you probably mean 'solve'.
09:52:01 <Cale> Basically, the question is "does 6 occur as the sum of two powers"
09:52:08 <int-e> sethk: it didn't make sense in terms of exact terms.
09:52:23 <lscd> CaleZ: for all four greater than or equal to two, there is no answer
09:52:35 <sethk> int-e, that's tautological, given that I conceded that my terms were imprecise  :)
09:52:36 <lscd> the bases should be allowed to be negative, i think
09:52:42 <int-e> sethk: anyway, the problem doesn't ask for all solutions, it just asks whether there's at least one or not.
09:52:50 <dmhouse> int-e, I think he's saying there are problems to which you can give solutions, but there's no general method to find all solutions.
09:52:59 <sethk> more seriously, you might want to demonstrate that you've found all possible solutions
09:53:05 <sethk> dmhouse, right
09:53:21 <xerox> int-e: In the FLT case we knew there was a solution without knowing it ;)
09:53:27 <dmhouse> For example, quintics and above.
09:54:16 <dmhouse> E.g. x^5 = 32. Easy solution to that, but no method for the general quintic.
09:55:20 <dropdrive> dmhouse: What do you mean by there's an easy solution to x^5 = 32?
09:55:30 <dmhouse> > 2^5
09:55:31 <lambdabot>  32
09:55:35 <sieni> of course there is a method, but it's not solvable using radicals
09:55:42 <dmhouse> I mean that x = 2 is a solution for that.
09:55:47 <dmhouse> sieni: Oh, true, bad example then.
09:56:05 <int-e> x^5=a is solvable using radicals ;)
09:56:37 <dmhouse> Yeah, it was a rubbish example. :)
09:56:54 <sieni> yes
09:56:58 <dropdrive> I mean, radicals are just symbols, right?   In that case, every quintic has a solution.
09:57:12 <sieni> I was talking about general quintics
09:57:58 <dmhouse> dropdrive: Having solutions is nothing to do with it. We're interested in the method to find those solutions.
09:57:59 <sieni> although it didn's sound like that
09:58:05 <Cale> there are general methods for expressing the solutions of higher degree polynomial equations, just not in terms of radicals
09:58:19 <sieni> a general quintic can be solved using jacobi theta functions
09:58:24 <Cale> right
09:58:45 <dropdrive> I just don't think that x^5 = a isn't easy or hard; it's only easy because you've got radicals in your toolkit.   Every quintic is easy, if you're using the right toolkit.
09:59:03 <int-e> yep
09:59:37 <dmhouse> But the point is that there are equations who we can gives example solutions to, but we know of no general method (or indeed, there _is_ no general method) to find all the solutions.
10:00:05 <dropdrive> dmhouse: but you're can only say that if you've picked a toolkit, e.g. radicals.
10:00:08 <int-e> hmm, is it 'be proven' or 'be proved'?
10:00:21 <sethk> proved
10:00:22 <dropdrive> dmhouse: s/you're/you/
10:00:30 <dmhouse> int-e, authors seem to prefer the latter, but I don't think it reads right.
10:01:07 <dmhouse> dropdrive: Yes, okay.
10:01:17 <dmhouse> dropdrive: Well, actually, no.
10:01:53 <dmhouse> dropdrive: We can solve the halting problem for specific programs, but there is no general solution, no matter which toolkit you choose.
10:02:01 <Cale> btw, right, I had the question right the first time
10:02:27 <int-e> oh. according to Oxford's dictionary there's a UK/US difference there. (it says, prove (pp proved; US proven) ...)
10:02:38 <int-e> interesting.
10:02:46 <Cale> You define a power as a number of the form a^b where a is in Z and b is a natural number >= 2. Then the question is whether 6 is expressible as a sum of two powers.
10:02:52 <sethk> proven is usually used as an adjective before a known
10:02:57 <sethk> s/known/noun/
10:02:59 <sethk> ugh
10:03:08 <int-e> yes, but I was asking for the past participle :)
10:03:12 <sethk> In the 20th century, proven has made inroads into the territory once dominated by proved, so that now the two forms compete on equal footing as participles.
10:03:27 <sethk> but that's from an american dictionary
10:03:58 <sethk> In Scottland you can also say preven
10:04:04 <dropdrive> dmhouse: okay, I don't really know anything about the halting problem.  All I'm saying is that x^5 = a is easy only when you have this mystical machine that takes fifth roots.
10:04:11 <lightstep> Cale, this can be reformulated as difference between two natural powers
10:04:51 <sethk> well, sure, fifth roots are easy for a machine that computes fifth roots.  I'm not sure what that shows, though
10:04:52 <int-e> dropdrive: there is something to be said for taking roots being easy, given that logarithm tables were quite common.
10:05:04 <int-e> (radicals. n-th roots.)
10:05:36 <int-e> it's much harder to tabularize general solutions to polynomials.
10:06:06 <int-e> tabulate. hmm.
10:06:39 <dropdrive> int-e: Well suppose I asked you for the square root of two.  You'd say, well, it's plus or minus 1.414....
10:06:55 <dropdrive> int-e: and you're running Mathematica and reading off the digits...
10:07:01 <int-e> 1.41422 ... but that's a coincidence.
10:07:19 <int-e> > sqrt 2
10:07:20 <lambdabot>  1.4142135623730951
10:07:23 <dropdrive> int-e: and I'm like, dude, int-e, just TELL ME what the square root of two IS already!
10:07:26 <int-e> and wrong, too :)
10:07:30 <dropdrive> int-e: and you're reading off more digits...
10:07:40 <dropdrive> int-e: and I'm getting impatient...I'm tapping my feet...
10:07:43 <int-e> dropdrive: I'll draw you a picture.
10:07:54 <int-e> a square and its diagonal.
10:08:04 <dropdrive> int-e: and finally, you say, dude, dropdrive, it's the number whose square is two.  Now go away.
10:08:44 <int-e> yep
10:08:45 <Cale> lightstep: yeah, I suppose so, since it's not going to happen when they're both positive.
10:09:27 <int-e> dropdrive: the fun thing is, when somebody asks me what the square root of 2 is, I'll assume that they know what a square root is.
10:10:20 <dropdrive> what IS the square root of two?
10:10:29 <int-e> it's also not going to happen when a or c is even.
10:10:47 <int-e> dropdrive: you already said that.
10:11:26 <Cale> Actually, that's a good question, because note that in the rational numbers, the square root of two doesn't exist. So the existence of an x such that x^2 = 2 in the case of real numbers is somehow dependent on the least upper bound property.
10:11:31 <dropdrive> int-e: haha.  I mean, you're saying you're assuming that people know what square/fifth roots are.  I'm saying that that's the exact same thing as saying that x^5 = a is "easy."
10:11:56 <lightstep> dropdrive, last $ iterate (\x -> (x+2/x)/2) 1
10:12:21 <Cale> but indeed, we can prove it
10:12:26 <int-e> dropdrive: But I gave you an explanation why people would consider that easier than solving general polynomials, namely because it can be done with logarithms. I think that's true, too.
10:12:32 <lightstep> at least, this isn't more defined than the square root of 2
10:12:38 <dmhouse> lightstep: or fix (\x -> (x + 2/x)/2)
10:12:46 <dropdrive> lightstep, aren't there algorithms to give roots of quintics?  would that make you say that quintics are easy?
10:12:53 <Cale> we use the fact that f(x) = x^2 is a continuous function (which is easy to prove separately)
10:13:28 <dmhouse> lightstep: or, err, maybe not. Ignore that.
10:13:31 <Cale> Together with the intermediate value theorem
10:13:36 <lightstep> dropdrive, actually, i believe that this is hard. even lambdabot struggles
10:13:45 <lightstep> > last $ iterate (\x -> (x+2/x)/2) 1
10:13:49 <lambdabot> Terminated
10:13:59 <dmhouse> sqrt(2) = Terminated. QED.
10:14:46 <int-e> > [x | x <- [0..6], x*x `mod` 7 == 2]
10:14:47 <lambdabot>  [3,4]
10:15:02 <lightstep> on the other hand, lambdabot can't even compute 1.1 
10:15:04 <lightstep> + 2.2
10:15:15 <int-e> sure it can
10:15:16 <dmhouse> > 1.1 + 2.
10:15:16 <lambdabot>  Parse error
10:15:17 <dmhouse> > 1.1 + 2.2
10:15:18 <lambdabot>  3.3000000000000003
10:15:22 <int-e> > 1.1 + 2.2 :: Ratio Int
10:15:23 <lambdabot>  33%10
10:15:43 <dropdrive> lightstep/dmhouse/int-e: gotta run.  later.
10:15:49 <lightstep> bye
10:16:16 <int-e> > toRational (1.1+2.2)
10:16:18 <lambdabot>  7430939385161319%2251799813685248
10:17:01 <mauke> > 11%10 + 22%10
10:17:02 <lambdabot>  33%10
10:18:27 <lightstep> int-e, Ratio Int is a strange type. i wouldn't rely on it for calculations.
10:18:30 <lightstep> > (100000%3::Ratio Int) * (100000%3::Ratio Int)
10:18:31 <lambdabot>  1410065408%9
10:18:34 <Cale> Suppose that f(x) = x^2 and we want to show that there is some x such that f(x) = a. Note that there's certainly a value b such that f(b) > a, since if a > 1 choose b = a to get f(a) = a^2 > a, and if a < 1 we can simply take b = 1 (and if a = 1, choose b = 2). Since 0 = f(0) < a < f(b), we know by IVT that there is some x in [0,b] such that f(x) = a.
10:19:36 <Cale> So, the square root of a exists (I was assuming in that that a > 0)
10:20:00 <Cale> Essentially the same argument applies to show that the nth root exists.
10:21:10 <lightstep> Cale, the problem is finding the solutions, not proving they exist
10:21:37 <Cale> But what counts as 'finding'?
10:22:08 <int-e> lightstep: use Ratio Integer then. *shrugs*
10:22:36 <int-e> lightstep: it's good enough for 1.1+2.2 and I'm aware of its limitations.
10:23:46 <Cale> I mean, I could say that sqrt(2) is an exact representation of the square root of 2, and since it exists, the problem is solved.
10:26:10 <Cale> If you want a rational approximation to it, the methods used to show its existence are probably not so far off from a reasonable way to approximate it. You could, for example, use bisection on the interval from my proof there, especially taking advantage of the fact that f is an increasing function on positive reals.
10:27:04 <dfeuer> I think Newton's method is popular
10:27:21 <Cale> yeah, Newton's method is quite good.
10:28:49 <Cale> Though in the complex case, determining which root you'll get from the initial guess is hard. (unless your guess is good enough)
10:28:55 <lightstep> by the same account, if the notation SolutionToQuintic(A,B,C,D,E) was popular, quintics were solvable
10:29:31 <Cale> Well, if you're talking in terms of radicals...
10:30:04 <Cale> the existence of a solution to x^2 = a in terms of radicals is not difficult :)
10:30:31 <dfeuer> Has anyone written a computer representation of general algebraic numbers?
10:30:44 <Cale> They exist in mathematica, and probably maple
10:30:55 <Cale> actually, certainly maple
10:31:02 <dfeuer> cool
10:31:14 <dfeuer> How are they represented?
10:31:25 <Cale> In mathematica,  Root[f,k]
10:31:31 <Cale> where f is a polynomial function
10:31:37 <Cale> and k is an integer
10:31:58 <Cale> The ordering is canonical
10:32:26 <dfeuer> And what operations are available on these things?
10:32:46 <Cale> all the usual operations on numbers
10:33:13 <dfeuer> Huh.. Interesting.  I wonder why Haskell doesn't have 'em ;-)
10:33:31 <Cale> They're a pain to implement.
10:33:40 <dfeuer> So is Haskell.
10:33:52 <Cale> hm?
10:34:08 <dfeuer> I imagine the big problem is finding the smallest representation of a given number?
10:34:30 <dfeuer> Haskell is a pain to implement, no?
10:34:43 <Cale> Its numerics are nothing too hard.
10:35:20 <Cale> Compared to this, arbitrary precision integers are easy.
10:35:33 <dfeuer> Compared to the type checker...
10:36:04 <Cale> The type checker's not *that* bad anyway. At least, for Haskell 98.
10:36:26 <dfeuer> The class system is messy, no?
10:36:45 * dfeuer pretty much maxes out at HM type inference
10:37:07 <Cale> It's not so bad
10:37:30 <Cale> MPTC's with functional dependencies are another thing
10:37:41 <Cale> but plain classes are not that hard
10:37:47 <dfeuer> huh.  okay.
10:38:05 <Cale> at least, I don't think so...
10:38:31 <dfeuer> It'd be cool if someone figured out a simple way to understand and implement type checking for a flexible type system.
10:39:29 <lightstep> i think some of the problem is that the design space is huge, for example there is no one clear way to define functional dependencies
10:40:12 <Cale> Root[24 - 2 x + 4 x^5, 3] + Root[x^2 - x - 1, 2] = Root[-99 + 777 x - 989 x^2 + 820 x^3 - 100 x^4 + 16 x^5 - 64 x^6 + 40 x^7 + 20 x^8 - 20 x^9 + 4 x^10, 8]
10:40:21 <dfeuer> I'm not sure I really like type classes at all.
10:40:37 <Cale> dfeuer: really?
10:40:39 <Cale> why?
10:41:34 <Cale> I think typeclasses are quite an elegant solution to the problem.
10:41:39 <dfeuer> Because I /do/ like a powerful module system (say, MOSML's) and type classes don't seem to be an orthogonal feature in a language supporting them.
10:43:16 <lightstep> dfeuer, the ML module system is sometimes used to specify some kinds of polymorphism, that type classes express better
10:43:39 <lightstep> just like bounds checking sometimes is simpler than funny GADTs
10:44:01 <dfeuer> Bounds checking?
10:44:40 <lightstep> well, actually not that. static bounds checking in haskell is done with regual\\lar type classes
10:45:12 <mux> I really like type classes, they look like mathematics writings
10:45:14 <Cale> I honestly don't really know what I'd do with a stronger module system -- I suppose there are certain times where you have a really large typeclass that it might be better.
10:46:44 <dfeuer> lightstep, I agree that classes sometimes express things a bit better, but then there's the whole newtype Foo a b = Foo (Bar a b) deriving class1, class2, class3, class4, class6
10:46:45 <Cale> The real power of typeclasses comes from the fact that they add expressiveness to types of functions by making them more general.
10:47:58 <dfeuer> instance Class5 (Foo a b) ....
10:48:26 <dmhouse> Grr. I hate Amazon's user system. I can never work out whether I'm logged in or out, and how to log in if I'm out.
10:48:32 <lightstep> dfeuer, in ML, if you want a new String module with different hash but the same order, how'd you do that?
10:48:56 <dfeuer> hmmm
10:48:57 <lightstep> haskell provides you with the deriving clause, to do the boring part of the job
10:49:14 <dfeuer> mumble.
10:49:37 <Cale> dfeuer: what's wrong with newtype deriving?
10:49:43 <lightstep> the thing haskell lacks if fully functorial programming (or its parallel with type classes)
10:49:56 <Cale> I use it a lot in order to, well, create new types.
10:50:10 <dfeuer> I'm remembering someone in here complaining about some sort of error handling module defining Either as an instance of Monad in a limited way.
10:50:33 <dfeuer> That was yesterday.
10:51:05 <Cale> dfeuer: Control.Monad.Error defines (Either e) as a monad, but only when Error e holds.
10:51:50 <Cale> That's sane enough though, and you can get the more general instance by writing it yourself, as it's completely trivial (though it would be nice to put it somewhere in the libraries)
10:52:10 <lightstep> Cale, except it conflicts
10:52:22 <Cale> Well of course it conflicts
10:52:43 <dmhouse> Cale, what would you use a more general instance for?
10:52:47 <dfeuer> So if you want error handling and a sane Either monad, then you have a problem.
10:53:14 <Cale> Well, it's not that the declaration there is actually so bad
10:53:21 <lightstep> or you can replace the arguably broken Monad and Error typeclasses
10:53:45 <Cale> If you want to use Control.Monad.Error, you just end up defining instances of Error for your e's.
10:54:08 <dfeuer> Monad broken because it has fail?
10:54:16 <lightstep> yes
10:54:20 <dfeuer> yah.
10:54:22 <Cale> yes, that is a problem
10:54:38 <lightstep> and not subclassing Functor
10:54:51 <dfeuer> What's Functor do again?
10:54:53 <dmhouse> Hmm. What's the alternative? class Monad m => FailableMonad m?
10:54:55 <Cale> though the not-subclassing-Functor thing I can understand
10:55:12 <dfeuer> dmhouse, sure.
10:55:24 <lightstep> i propose another alternative
10:55:29 <Cale> (but I really do want it fixed, though not without adding some features which will handle the automatic definition of Functor on the definition of Monad)
10:55:36 <lightstep> make most functions monadic (or in an arrow)
10:55:39 <Cale> It should look something like
10:56:05 <lightstep> but with proper polymorphism, you shouldn't limit yourself to a specific monad
10:56:20 <lightstep> except for resource creation, and the type of main
10:56:33 <Cale> class Functor f where fmap :: (a -> b) -> (f a -> f b)
10:56:40 <Cale> class Functor f => Monad m where
10:56:46 <Cale>    return :: a -> m a
10:56:55 <dmhouse> Rather than subclassing Functor, we could do instance Monad m => Functor m where fmap = liftM.
10:56:57 <Cale>    join :: m (m a) -> m a
10:57:14 <Cale>    (>>=) :: m a -> (a -> m b) -> m b
10:57:34 <Cale>    join x = x >>= id
10:58:01 <Cale>    x >>= f = join (fmap f x)
10:58:15 <Cale>    instance Functor m where
10:58:39 <Cale>        fmap f x = x >>= return . f
10:59:16 <lightstep> you might want to add app there (or not), and to change "instance" to a new keyword
10:59:32 <dfeuer> instance Functor m?
10:59:36 <lightstep> s/app/ap/ (as in Control.Monad.ap)
10:59:41 <xerox> Monad m => Functor m
10:59:58 <SamB> dmhouse: that needs overlapping instances...
11:00:19 <dmhouse> SamB: is that an issue now?
11:00:38 <SamB> dmhouse: isn't it?
11:00:39 <Cale> well, the idea being that it's a default instance, in case one doesn't already exist, and enough of an instance for Monad exists to get the instance for Functor
11:01:22 <Cale> and yeah, adding applicative stuff might be nice
11:01:27 <dfeuer> Cale, I don't understand you.
11:01:40 <SamB> they make me uncomfortable, because the compiler could get confused, or even if you used something like JHC, an instance that isn't the one that you were expecting might get used
11:01:47 <Cale> dfeuer: Every monad is a functor
11:01:53 <dfeuer> okay....
11:02:35 <Cale> dfeuer: The reason that the class dependency isn't being expressed in the Prelude currently is that it would force everyone who wants a Monad instance to write a Functor instance explicitly.
11:02:39 <dmhouse> SamB, hmm. I figured undecidable/overlapping instances would be fairly high up on the Haskell' list, but it seems not.
11:02:49 <dmhouse> Not sufficiently thoroughly researched?
11:03:01 <lightstep> hmm, this whole fixed class hierarchy is problematic. maybe we also want default instances for related classes, like Idiom or Arrow? or Spear?
11:03:06 <dfeuer> so if you do class Functor f => Monad m, what's that mean?  f doesn't appear in m.
11:03:25 <Cale> dfeuer: oh, sorry, that's a typo
11:03:31 <Cale> Functor m => Monad m
11:03:31 <SamB> overlapping instances offend the sensibilities
11:03:33 <Cale> of course
11:03:48 <dfeuer> Oh.
11:03:58 <SamB> lightstep: we don't even know the spear laws, and their are like 101 of them (or was that 1001?)
11:04:15 <dfeuer> Is that default instance thing actual syntax in some Haskell, or pseudocode?
11:04:19 <lightstep> i know. this is a problem of extensibility
11:04:34 <Cale> dfeuer: It's unimplemented syntax
11:05:18 <Cale> dfeuer: Basically, I was giving some idea of what this feature would look like
11:05:23 <dfeuer> uh-huh
11:06:03 <Cale> But yeah, fine-grained hierarchies are a problem for Haskell classes.
11:06:53 <Cale> Because as you refine a hierarchy, all your library's users have to do more and more work in defining instances.
11:07:19 <dfeuer> And, as I understand it, it tends to get less efficient?
11:07:24 <Cale> Even if the instances could be inferred in some natural way.
11:07:31 <Cale> Less efficient, not so much.
11:07:44 <dfeuer> Isn't there (in many implementations) more pointer-chasing?
11:07:53 <lightstep> dfeuer, only if you use runtime dictionary-passing
11:08:04 <dfeuer> lightstep, are other methods used?
11:08:31 <dfeuer> If so, how do they handle polymorphic recursion?
11:08:31 <lightstep> jhc passes type numbers instead of class witnesses, so it uses "case", and is faster
11:08:33 <Cale> If anything, the => in the class declaration lets you gain efficiency
11:08:51 <Cale> by storing the dictionaries together
11:08:53 <SamB> Cale: yeah, that definately needs some kind of reasonable localized fix
11:08:56 <dfeuer> yah.
11:09:44 <dfeuer> What's a type number?
11:09:50 <int-e> a tag
11:09:52 <lightstep> dfeuer, you have the SPECIALIZE pragma to give you the same efficiency as with C++ or ML module polymorphism
11:10:13 <dfeuer> *nod*
11:10:33 <SyntaxNinja> audreyt: y0!
11:10:58 <dfeuer> How do you deal with polymorphic recursion?
11:11:38 <lightstep> in which implementation?
11:11:41 <int-e> hmm. last I tried I couldn't compile jhc.
11:11:47 <dfeuer> one that doesn't use dictionary passing.
11:12:21 * int-e wanted to look at how data Tree a = Lead a | Nest (Tree (a,a)) would be compiled.
11:12:25 <lightstep> if you pass some other witness, you can branch by the (jhc takes this approach)
11:12:45 <dfeuer> What do you mean by a witness?
11:12:47 <lightstep> s/the/that/
11:13:18 <dfeuer> You couldn't end up with a huge case statement?
11:13:25 <lightstep> a value that tells you what the type is. in this case a number. eg, 1 is Int, 2 is Char, 3 is [IO ()], ...
11:13:44 <dfeuer> and so it comes up with numbers at runtime?
11:13:52 <lightstep> the thing is, you give numbers selectively, on for each "instance" declaration
11:13:56 <Philippa_> a witness isn't a value that tells you what the type is
11:14:13 <Philippa_> it's evidence that some part of the proposition a type represents which can't be otherwise proven is true
11:14:22 <dcoutts_> dfeuer, if you do a whole program analysis then you can assign numbers at compile time
11:14:30 <lightstep> so my terminology is wrong
11:14:36 <Philippa_> and even if you don't you can do it at link time
11:15:00 <Cale> I suppose this is some sort of 'witness', though that wouldn't be the first thing I'd call it
11:15:15 <Philippa_> it's not as direct a one as a dictionary is, certainly
11:15:36 <Philippa_> although in practice if you passed around dictionaries in GRIN and then optimised fully you'd end up with typeids anyway
11:15:53 <dfeuer> Suppose you have   data Tree a = Zero a | Tree (Node a a)
11:16:06 <Cale> Like, the fact that you have a number to pass at all is sort of a proof that one exists. (assuming that your compiler isn't completely broken and passes 0 when it can't figure out which to pass :)
11:16:08 <dfeuer> instance (Ord x) => Ord (Node x)
11:16:18 <Philippa_> yup :-)
11:16:33 <dfeuer> Umm.... back there I meant (Node a), with data Node a = Node a a
11:16:43 <SamB> I kind of thought a dictionary of the right type counted as evidence
11:17:06 <Cale> SamB: it does
11:17:27 <Cale> SamB: we're talking about another mechanism for implementing typeclasses which doesn't use dictionaries
11:17:59 <SamB> ah.
11:18:08 <dfeuer> Now you make Tree an instance of Ord.
11:18:19 <SamB> there is one that doesn't require global transformations?
11:18:27 <dfeuer> And you will end up constructing functions with types that aren't known at compile time.
11:18:40 <dfeuer> How do you deal with that?
11:18:52 <Cale> dfeuer: what?
11:19:04 <dfeuer> Am I missing something?
11:19:14 * dfeuer must be missing something.
11:19:20 <Cale> what sort of function?
11:19:37 <lightstep> i know how i'd solve it, i don't know how jhc does
11:20:20 <Cale> The whole idea of typeclasses is to bound polymorphism -- by saying that type variables don't quite range over all types, just those for which some instance is available.
11:20:29 <lightstep> you could have the dictionary for the typeid of the ord instance for (Tree x) contain the typeid of x
11:20:53 <Cale> but maybe I'm misinterpreting your question entirely
11:20:56 <dmhouse> Someone remind me what constructor classes are again?
11:21:22 <Cale> dmhouse: we call them typeclasses now -- typeclasses where the parameter is of a kind other than *
11:21:35 * dfeuer goes to lisppaste.
11:21:35 <dmhouse> Ah, that's right.
11:21:37 <Cale> dmhouse: Like Functor
11:21:40 <dmhouse> Yep.
11:28:38 <dmhouse> Where is pattern matching lazy, and where is it strict?
11:28:54 <dmhouse> (Obviously it's lazy when you use ~, I know about that bit.)
11:29:11 <monochrom> case x of y -> ...   Also lazy.
11:29:12 <Igloo> case (and hence functions) are strict
11:29:14 <ndm> dmhouse: lazy in let, strict in where, i belive
11:29:15 <adaran> how can i pattern match a list with a single argument? i have a function that terminates when there is one argument left, not zero (using f (x1:x2:xs) = to match), however, f (x1:xs) = did not work for me
11:29:16 <Igloo> let is lazy
11:29:18 <xerox> > let f xs = [x | Just x <- xs] in f [Just 1,Nothing,Just 2]
11:29:19 <lambdabot>  [1,2]
11:29:27 <Igloo> let and where are both lazy
11:29:45 <monochrom> Thus, if the pattern is ~ or just a variable, lazy.
11:29:53 <Igloo> adaran: f [x] = ...
11:30:14 <dmhouse> monochrom just said case was lazy, and Igloo said it was strict. Who's right?
11:30:25 <dmhouse> > let f x = 4 in f undefined
11:30:26 <lambdabot>  4
11:30:33 <dmhouse> It's lazy, then.
11:30:45 <dcoutts_> dmhouse, monochrom said one form of case was lazy
11:30:50 <dcoutts_> case x of y -> ...
11:30:53 <Igloo> That's not case
11:30:53 <dmhouse> > let f x = case x of y -> 4 in f undefined
11:30:54 <monochrom> I do not say case is lazy.  I will not say case is strict either.  I am referring to the pattern used.
11:30:54 <lambdabot>  4
11:31:11 <adaran> Igloo, nm, returns the same error. i guess i was wrong and my mistake is elsewhere
11:31:12 <dcoutts_> because matching against 'y' doesn't force anything
11:31:21 <dmhouse> dcoutts_: Oh, I see, y is a binding rather than a pattern.
11:31:28 <dcoutts_> right
11:31:55 <isaacd> adaran: what's supposed to happen if the function is called with an empty list? do you have a case for that?
11:31:57 <dmhouse> > let f x = case x of Just y -> 4 in f (Just undefined)
11:31:59 <lambdabot>  4
11:32:32 <adaran> isaacd, no, return an empty list i guess. almost forgot, will add =)
11:32:37 <dmhouse> And that's because it unwraps the Just constructor to give a (\x -> case x of y -> 4) undefined, which is just the same as above?
11:32:59 <monochrom> The Maybe type is non-flat, so there are more degrees of laziness.
11:33:36 <monochrom> In the extreme, the [a] type has infinitely many degrees of laziness/strictness.
11:33:47 <dmhouse> Okay. Can someone give an example of a strict case then?
11:34:07 <Igloo> Lazy:
11:34:09 <Igloo> > let y = undefined in let Just x = y in 1
11:34:10 <lambdabot>  1
11:34:15 <Igloo> Strict:
11:34:19 <Igloo> > let y = undefined in case y of Just x -> 1
11:34:20 <lambdabot>  Undefined
11:34:26 <monochrom> > case undefined of {0 -> 0; y -> 1} 
11:34:28 <lambdabot>  Undefined
11:34:31 <monochrom> That's strict.
11:34:49 <dmhouse> So it's strict in the thing you're matching against.
11:35:07 <Igloo> It's as strict as it needs to be to test if the pattern matches
11:35:16 <monochrom> It comes down to how much the combination of patterns asks for.
11:35:21 <dmhouse> > case undefined of _ -> 4
11:35:22 <lambdabot>  4
11:35:25 <dmhouse> Right.
11:36:57 <monochrom> The "Maybe Int" type (for example) contains this chain: undefined, Just undefined, Just 0.  So there are three levels of laziness/strictness.
11:37:39 <dmhouse> Yeah.
11:38:01 <dmhouse> And SMaybe eliminates the middle one by saying Just is strict, so Just _|_ = _|_.
11:38:15 <monochrom> Nice.
11:38:52 * monochrom loves the CPO view.
11:39:29 <lisppaste2> dfeuer pasted "wacky typeclass" at http://paste.lisp.org/display/21487
11:39:36 <monochrom> wacky!
11:41:48 <dfeuer> So how does the system deal with that?
11:42:34 <dfeuer> Cale?
11:43:24 <monochrom> It will be executed just as the code specifies, I predict.
11:43:25 <dcoutts_> dfeuer, seems ok to me, do you think it's odd somehow?
11:43:30 <dfeuer> No...
11:43:32 <dfeuer> Not odd.
11:43:47 <monochrom> I can even see how it makes sense.
11:43:47 <dfeuer> But how do you implement it without passing around dictionaries?
11:44:11 <dcoutts_> if we know the type of 'a'
11:44:45 <dfeuer> We don't generally know the type of the innermost a until runtime.
11:44:50 <monochrom> On that issue, it reminds me of "instance Show a => Show [a] ..."  same deal.
11:45:04 <dfeuer> yup.
11:45:31 <dcoutts_> dfeuer, right, under a seperate compilation and open world model we would be fored to pass dictionaries in that case
11:45:44 <dcoutts_> jhc will be ok though
11:45:46 <dfeuer> So suppose it's a closed world
11:45:54 <dfeuer> How does it do it?
11:46:04 <dcoutts_> then you analyse the whole prog, find out the types it's used at
11:46:09 <dcoutts_> and dispatch on the type code
11:46:12 <dfeuer> But you don't know till runtime.
11:46:18 <dcoutts_> sure you do
11:46:23 <dfeuer> The size of the tree determines the innermost type.
11:46:44 <dfeuer> If the size of the tree is not fixed at compile time, neither is the type.
11:47:08 <monochrom> If whole-program-analysis, all possible concrete types ever used can be statically determined.
11:47:09 <int-e> dcoutts: but what if there are infinitely many types?
11:47:29 <int-e> as in data X a = X (a,a) | Y
11:47:35 * dcoutts_ thinks there is a theorem saying that's not the case for any Haskell prog
11:48:01 <lisppaste2> int-e annotated #21487 with "more weird stuff, actually useful ;)" at http://paste.lisp.org/display/21487#1
11:48:05 <dfeuer> int-e, I think you mean data X a = F (X (a, a)) | Y a
11:48:09 <Philippa_> it can't possibly be for any terminating one
11:48:13 <int-e> dfeuer: no.
11:48:20 <int-e> dfeuer: it wasn't meant to be useful ;)
11:48:29 <int-e> oh
11:48:33 <dfeuer> int-e, it's also not nested.
11:48:36 <int-e> I see what you mean, sorry.
11:48:40 <int-e> you're right.
11:48:52 <Philippa_> and the obvious non-terminating one probably fails to typecheck (polymorphic recursion's one thing...)
11:49:07 <int-e> dcoutts_: it works for type constructors but I don't see how it works for associated instances
11:49:24 <dcoutts_> I admit your example has confused me
11:49:29 <Philippa_> you can't have more instances than types
11:49:35 <dcoutts_> so I'm not sure
11:49:39 <monochrom> Try this.  Write a program that takes input natural number n, outputs your tree of level n.  Or simpler, outputs the nested list [...[0]...] (n levels).
11:50:04 <int-e> dcoutts_: like that Nat instance in the stuff I just posted. My (unchecked) theory is that ghc generates dictionaries on the fly for that, and I wanted to try it with jhc, but couldn't compile the compiler.
11:50:18 <monochrom> If you find that you can't do that, then it's plausible to prove there is no worry.
11:50:25 <dcoutts_> monochrom, you can't have a n level nested list, the types bans it (perhaps except for polymorphic recursion)
11:50:33 <Philippa_> int-e: more likely the dictionary's parameterised in the first place
11:50:39 <monochrom> Yes precisely.
11:50:55 <dcoutts_> int-e, I think ghc does generate dictionaries on the fly
11:51:12 <Philippa_> (so yeah, sort of)
11:51:18 <monochrom> For the same reason the tree of n levels is impossible too.
11:51:36 <int-e> (the use case is that later I define instance Nat m => Num (Ring m) where ... for Z/mZ)
11:51:38 <dfeuer> monochrom, the tree of n levels happens in practice.
11:51:47 <dfeuer> Look at 2-3 finger trees.
11:51:55 <monochrom> Could you write me a program that builds one?
11:52:28 <int-e> 2-3 finger trees exist.
11:52:40 <dfeuer> http://www.informatik.uni-bonn.de/~ralf/publications/FingerTrees.pdf
11:53:04 <satan> i have a list of elements [a,b,c,d], how do i print each element on a new line?
11:53:20 <monochrom> I have never seen 2-3 finger trees, and I doubt its relation with the present question.  But could you write a program that builds an n-level tree as in the tree dfeuer pasted?
11:53:24 <dfeuer> ain't there a println or somesuch?
11:53:27 <satan> is there an equivalent to nl in Prolog?
11:53:30 <lightstep> @type mapM_ print
11:53:32 <lambdabot> forall a. (Show a) => [a] -> IO ()
11:53:32 <int-e> monochrom: they are relevant
11:53:50 <int-e> monochrom: because they're an actual piece of code that makes use of an unbounded number of types at runtime.
11:53:55 <dmhouse> satan: you want to call putStrLn on each of the elements, right? What do you normally do if you want to call a function on each element of a list?
11:53:57 <dfeuer> monochrom, go to the link I just pasted, and look at page 4.
11:54:18 <satan> dmhouse: yeah i'll recurse over each of them, was just wondering about the newline character
11:54:22 <satan> ok lemme try that :)
11:54:31 <dmhouse> satan: putStrLn adds a newline.
11:54:31 <monochrom> "print" gives you newline
11:54:46 <satan> awesome, lemme try it, thanks guys :)
11:54:50 <dmhouse> Yep. If you're strings, then use mapM_ putStrLn. Otherwise, use mapM_ print putStrLn
11:54:58 <sethk> right, or (show listThingy)
11:54:59 <dmhouse> Basically, print x = putStrLn (show x)
11:55:02 <sethk> which print calls
11:55:03 <dfeuer> fold (>>) (map print [1, 2, 3, 4])
11:55:13 <dfeuer> uh... missing an arg.
11:55:45 <dmhouse> foldr (>>) (return ()) (map print [1,2,3,4]), if you're going to be like that.
11:55:46 <satan> so can i do: map print [a,b,c,d] ?
11:55:53 <dmhouse> satan: Not quite.
11:55:54 <isaacd> > unlines $ map show [1,2,3,4]
11:55:55 <lambdabot>  "1\n2\n3\n4\n"
11:56:00 <monochrom> Ralf Hinze always breaks my assumptions :)
11:56:13 <isaacd> putStrLn $ unlines $ map show [1,2,3,4]
11:56:14 <int-e> http://int-e.home.tlink.de/haskell/Ring.hs <-- this is the complete code. note that the use of higher order functions is for passing around Num computations in reflect and inring only, it's not strictly necessary to make the other stuff work.
11:56:18 <dmhouse> satan: Because print is monadic, you need to use mapM. 'M' is short for Monad, so you use mapM when you want to map with a monadic function.
11:56:25 <isaacd> *putStr $ unlines $ map show [1,2,3,4]
11:56:28 <dcoutts_> dfeuer, ah, so we can only have a finite depth tree
11:56:33 <satan> dmhouse: ah i see
11:56:43 <dfeuer> dcoutts_, true, but there's no way to know the depth at compile time.
11:56:55 <satan> dmhouse: works like a charm, thanks :)
11:56:57 <dcoutts_> dfeuer, so when we apply weird at some type then we know the depth
11:57:06 <dfeuer> Which one is MapM_ and which is MapM?
11:57:13 <dmhouse> satan: Note that mapM_ would actually be more appropriate in this case.
11:57:15 <dcoutts_> dfeuer, so we know all the instances/typecodes that it'll need
11:57:21 <dmhouse> You use mapM_ when you don't care about the result of your functions.
11:57:25 <satan> dmhouse: oh, why is that?
11:57:33 <dcoutts_> dfeuer, so we're ok, we can still do it with type case, we do know all the types at compile time
11:57:38 <dfeuer> ?
11:57:42 <dmhouse> As print only returns an IO (), and you don't normally care about (), you can use mapM_ to ignore it.
11:57:44 <satan> dmhouse: dont care about the result? the _ implies that?
11:57:49 <satan> ahhh ok
11:58:06 <int-e> (The technique of reflecting numbers in types was conceived by Oleg I believe)
11:58:09 <dmhouse> satan: yep. If you see '_' on the end of a function, it often means you're ignoring the result.
11:58:18 <isaacd> @type mapM print [1,2,3,4]
11:58:19 <lambdabot> IO [()]
11:58:21 <isaacd> @type mapM_ print [1,2,3,4]
11:58:22 <lambdabot> IO ()
11:58:23 <satan> dmhouse: gotcha
11:58:24 <dfeuer> dcoutts_, I don't know what you're saying.
11:58:28 <dcoutts_> dfeuer, we're going to apply weird to a value with some type, eg Tree (Tree ())
11:58:41 <dcoutts_> dfeuer, whatever level of Tree nesting it is, it'll be finite
11:58:46 <dmhouse> @where yaht
11:58:46 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
11:58:46 <dcoutts_> becuase the type is finite
11:58:51 <dfeuer> dcoutts_, no.
11:59:06 <dcoutts_> dfeuer, try building an infinite tree of your type
11:59:08 <dfeuer> We're going to apply weird to something of type, say, Tree Int.
11:59:11 <monochrom> Alright, I read page 5.  So polymorphic recursion is required to build a variable-level finger tree.  What is the status of polymorphic recursion in Haskell?
11:59:15 <int-e> dcoutts_: anyway, there's no need to generate actual code at runtime, only dictionaries; the code will work out fine because it's type-checked.
11:59:30 * dmhouse wonders if Hal Duamé will ever finish YAHT.
11:59:31 <int-e> dcoutts_: I think that's what you meant earlier.
11:59:32 <dcoutts_> int-e, we're talking about the jhc style of type case
11:59:47 <dmhouse> s/ua/au/
11:59:47 <dfeuer> And that will contain, buried within it, something of type Tree (Node (Tree (Node (Tree Int))))
11:59:50 <int-e> dcoutts_: I'm still wondering about that :)
12:00:19 <dfeuer> monochrom, polymorphic recursion is legal, but requires a type signature.
12:01:38 <dfeuer> dcoutts_, the wacky types aren't visible from above.
12:02:03 <dcoutts_> dfeuer, can you construct a infinite tree of this type?
12:02:37 <isaacd> dcoutts: you'd probably get a type error if you tried
12:02:42 <dfeuer> I don't think you can.
12:02:44 <dcoutts_> right
12:02:48 <dfeuer> So what?
12:03:13 <dfeuer> The "infinite types" are potential, not actual.
12:03:24 <isaacd> That doesn't mean you can't produce arbitrarily large trees of the type
12:03:42 <monochrom> It would be nice to add some tree-building code to dfeuer's paste.  Yes yes we all know similar code is on pages 5 and 6 of the finger tree paper, but you want the discussion to be focused.
12:03:45 <isaacd> say, based on textual input
12:04:02 <int-e> I don't think there will be a type error, just nontermination.
12:04:08 <dfeuer> monochrom, let's use the code in the finger tree paper, and throw out my totally useless hypothetical code.
12:04:19 <monochrom> That works too.
12:04:19 <int-e> dfeuer: 'arbitrary' and 'unbounded' are better words I think.
12:04:26 <dfeuer> yah
12:04:58 <dmhouse> Anyone think of anywhere else you can pattern match? 1) LHS of equations. 2) let/where. 3) case. (And, if you want, 4) pattern guards.)
12:05:23 <int-e> dmhouse: do blocks, list comprehension
12:05:34 <dmhouse> Oh yeah.
12:05:45 <isaacd> dmhouse: LHS of lambdas, if they aren't counted in one of those
12:05:59 <apfelmus> @where paste
12:05:59 <lambdabot> http://paste.lisp.org/new/haskell
12:06:19 <Cale> really equations come in two types -- function bindings and pattern bindings, so you could count those as two if you'd like
12:06:26 <int-e> dmhouse: anything that binds a new variable? are there exceptions?
12:06:39 <dmhouse> int-e, that's what I was thinking. I don't think there is.
12:06:46 <monochrom> dcoutts_: Hinze's finger tree paper has code and types inspiring dfeuer's paste.  Pages 5 and 6 have operators that input a tree and output a tree a level deeper.  Now if you do a fold over that operator...
12:07:29 <int-e> dmhouse: toplevel bindings
12:07:37 <int-e> dmhouse: (also allow pattern matches)
12:07:41 <dmhouse> int-e, such as?
12:07:51 <int-e> (a,b) = (23, 42)
12:07:53 <dfeuer> Yah.
12:08:02 <dmhouse> int-e, I'd count that as LHS of equations.
12:08:12 <dfeuer> It's easy to make an infinite one, but the contents are not lazily accessible.
12:08:38 <int-e> dmhouse: hmm. a possible exception could be instance declarations. (unchecked)
12:08:41 <dfeuer> Without calculating the whole tree, all you can find out is whether it has at least n levels.
12:09:05 <monochrom> Very interesting and wacky.
12:09:06 <dfeuer> hmm
12:09:07 <dfeuer> actually..
12:09:09 <dfeuer> that's wrong.
12:09:13 <dfeuer> hee
12:09:25 <dfeuer> orr....
12:09:26 <dfeuer> hm
12:09:41 * dfeuer ponders whether values are accessible...  they might be!
12:10:27 <bringert> shapr, xerox: get my mail?
12:10:29 <monochrom> Is it just me or does Hinze always come up with ideas that blows up naive Haskell implementations? :)
12:10:40 <dfeuer> Yeep!
12:10:41 <xerox> bringert: yes thank you
12:12:01 <int-e> the really interesting stuff are the helper type classes that make accessing tree elements work almost naturally. it's a great paper.
12:12:12 <dfeuer> if you build the tree as insert (1 (insert (2 (insert 3 ...., the head should, I think, be lazily accessible.  I'm not sure though.
12:12:48 <dfeuer> int-e, the helper type classes are a little abstract for me.  Took me a while to get a handle on them.  I haven't read the actual paper yet, just the slides from the talk.
12:13:29 <lisppaste2> int-e pasted "jhc compile error" at http://paste.lisp.org/display/21489
12:13:38 <int-e> does that look familiar to anyone?
12:13:39 <dcoutts_> dfeuer, actually we can build infine trees:
12:13:40 <dcoutts_> build :: a -> Tree a
12:13:40 <dcoutts_> build x = Succ (build (Node x x))
12:13:57 <int-e> but that doesn't terminate
12:13:58 <dcoutts_> via polymorphic recursion
12:14:07 <dcoutts_> I can make one that does...
12:14:07 <int-e> you could use build = Succ build  instead :)
12:14:41 <dmhouse> build = fix Succ. :)
12:14:46 <int-e> dmhouse: no.
12:14:50 <dmhouse> Ah well.
12:14:58 <dmhouse> int-e, why not?
12:15:00 <int-e> dmhouse: that will not type-check
12:15:12 <dmhouse> But build = Succ build will?
12:15:20 <int-e> dmhouse: with a type signature it will
12:15:21 <dfeuer> The thing that makes finger trees work for it (I -think-) is that elements are stored at all levels.
12:15:21 <dcoutts_> build :: Int -> a -> Tree a
12:15:21 <dcoutts_> build 0 x = Zero x x
12:15:21 <dcoutts_> build n x = Succ (build (n-1) (Node x x))
12:15:35 <int-e> dmhouse: the two 'build' are of different type there
12:15:48 <dcoutts_> that terminates for all n >= 0
12:15:56 <int-e> yep
12:16:09 * dfeuer will type up the code and check in a bit.
12:16:26 <dcoutts_> so in conclusion, I'm not sure how to deal with that without dictionaries
12:16:28 <dcoutts_> :-)
12:17:22 <dcoutts_> try asking JohnMeacham
12:17:31 <isaacd> With polymorphic recursion, I think you can make effectively infinite types, but can't *do* anything with them without typeclasses
12:17:43 * int-e would rather compile jhc and see it fail (or work - which would impress me a lot :)
12:18:16 <dcoutts_> isaacd, you could consume such a structure with polymorphic recursion too
12:18:20 <SamB> I think JHC might have to pass around types at runtime for that
12:18:44 <int-e> isaacd: well, without type classes, constructor tags will work and type tags aren't needed; they are only used for looking up class dictionaries (I believe)
12:18:46 <SamB> as opposed to inlining them
12:19:27 <dmhouse> > \(x:xs -> x) [1..]
12:19:27 <lambdabot>  Parse error
12:19:31 <dmhouse> err
12:19:35 <dmhouse> > (\x:xs -> x) [1..]
12:19:35 <lambdabot>  Parse error
12:19:43 <monochrom> (x:xs)
12:19:49 <dmhouse> Is lambdas the only place you need parentheses in patterns?
12:19:58 <SamB> no
12:20:02 <int-e> > a x:xs = b
12:20:02 <lambdabot>  Parse error
12:20:07 <isaacd> I was thinking of something useless anyway (the list-boxing operation) so my conclusions about what you can't do were probably useless
12:20:13 <SamB> > let a x:xs = b
12:20:13 <lambdabot>  Parse error in pattern
12:20:17 <dmhouse> > let Just x = x in Just 4
12:20:18 <lambdabot>    Occurs check: cannot construct the infinite type: a = Maybe a
12:20:18 <lambdabot>    Expe...
12:20:24 <dmhouse> err
12:20:30 <monochrom> Hahaaha
12:20:34 <int-e> > let Just x = Nothing in Just 4
12:20:35 <lambdabot>  Just 4
12:20:37 <dmhouse> > let Just x = Just 4 in x
12:20:38 <lambdabot>  4
12:20:49 * dmhouse turns his brain on again
12:20:55 <norpan> huh?
12:21:09 <int-e> > let True = False in "to be or not to be"
12:21:10 <lambdabot>  "to be or not to be"
12:21:19 <dmhouse> > let x :+ y = 2 :+ 3 in (x, y)
12:21:20 <lambdabot>  (2.0,3.0)
12:21:22 <norpan> how can that work
12:21:36 <dmhouse> So (:) is the only constructor you need to put parentheses around?
12:21:46 <monochrom> let x:xs = [1,2,3] in xs
12:21:48 <monochrom> > let x:xs = [1,2,3] in xs
12:21:50 <lambdabot>  [2,3]
12:21:53 <dmhouse> (Apart from in lambdas and toplevel equations.)
12:21:59 <monochrom> The plot thickens!
12:22:02 <norpan> oh you don't need parenthesis there
12:22:08 <SamB> @type :+
12:22:10 <lambdabot> parse error on input `:+'
12:22:10 <dmhouse> Oh, that makes it clear.
12:22:13 <isaacd> let f (Just x) = x in f (Just 4)
12:22:14 <SamB> @type (:+)
12:22:15 <isaacd> > let f (Just x) = x in f (Just 4)
12:22:16 <lambdabot> Not in scope: data constructor `:+'
12:22:16 <lambdabot>  4
12:22:18 <dmhouse> SamB: complex numbers.
12:22:21 <isaacd> > let f Just x = x in f (Just 4)
12:22:22 <lambdabot>    Constructor `Just' should have 1 argument, but has been given 0
12:22:22 <lambdabot>   When...
12:22:24 <SamB> dmhouse: ah
12:22:27 <dmhouse> @type Data.Complex.(:+)
12:22:28 <lambdabot> Couldn't find qualified module.
12:22:29 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
12:22:34 <dmhouse> @type (Data.Complex.:+)
12:22:35 <lambdabot> forall a. (RealFloat a) => a -> a -> Data.Complex.Complex a
12:22:39 <dmhouse> Gah. Stupid syntax.
12:22:57 <monochrom> Well, you can't exactly write "3 + 4i" :)
12:23:18 <SamB> @type \i -> 4i
12:23:20 <lambdabot> forall t t1. (Num (t -> t1)) => t -> t1
12:23:22 <dmhouse> No, I mean that you need (Data.Complex.:+) instead of Data.Complex.(:+)
12:23:43 <monochrom> Ah, that's gay.
12:23:46 <norpan> why is that stupid
12:24:17 <dmhouse> A Num instance for (t -> t1) would be great. Things like threadDelay (8 hrs) become possible.
12:24:42 <SamB> yes, I remember discussing that ;-)
12:24:53 <dmhouse> :)
12:24:55 <SamB> somebody didn't think it would work, if I recall
12:24:59 <dmhouse> Yep. Me.
12:25:01 * dmhouse runs away
12:25:05 <SamB> haha
12:25:16 <int-e> norpan: it's not that stupid - it has to work for sections, too, after all
12:25:17 <SamB> sure, it doesn't work *now*
12:25:31 <norpan> int-e: exactly
12:25:50 <int-e> Module.(3 <>) would be extremely ugly.
12:25:51 <dfeuer> int-e, without typeclasses, I think you only have issues with existential types, which are almost the same.
12:26:08 <dmhouse> int-e: Well, you shouldn't be using qualified names with infix functions anyway. Bah.
12:26:18 <int-e> (3 Module.<>) is merely ugly.
12:26:30 <int-e> dmhouse: of course.
12:26:32 <dfeuer> What is <>?
12:26:38 <Philippa_> dmhouse: if there's no other name for the function you might just be stuck doing it
12:26:41 <int-e> <> is a generic infix operator :)
12:26:43 <dmhouse> @hoogle (<>)
12:26:44 <lambdabot> Did you mean: (<>)
12:26:45 <lambdabot> Prelude.undefined :: a
12:26:45 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
12:26:46 <SamB> > let <> = bottom in <>
12:26:46 <lambdabot>  Parse error
12:27:15 <dmhouse> Philippa_: import Module ((<>)) :) As long as the name doesn't clash.
12:27:16 <SamB> > let (<>) = bottom in (<>)
12:27:17 <dfeuer> > let (<>) = bottom in (<>)
12:27:17 <lambdabot>  Not in scope: `bottom'
12:27:17 <lambdabot>  Not in scope: `bottom'
12:27:20 <int-e> one of the few nice ones that aren't taken (not true, it's used in the pretty-printing stuff)
12:27:27 <dfeuer> > let (<>) = undefined in (<>)
12:27:28 <lambdabot>  Add a type signature
12:27:28 <dmhouse> > let (<>) = (<>) in (<>)
12:27:29 <lambdabot>  Add a type signature
12:27:29 <SamB> oh.
12:27:37 * SamB forgot it was called "undefined" in code
12:27:39 <dfeuer> > let (<>) = undefined in (<>) :: Int
12:27:40 <lambdabot>  Undefined
12:27:56 <int-e> <> = 'besides'
12:27:58 <dmhouse> > let (_|_) = undefined; (<>) = (_|_) in (<>)
12:27:58 <lambdabot>  Parse error
12:28:02 <dmhouse> Aww. :(
12:28:18 <dmhouse> > let _ | _ = undefined; (<>) = (|) in (<>)
12:28:18 <lambdabot>  Parse error in expression
12:28:21 <dfeuer> Yeah, the | would be a problem, I guess.
12:28:28 <dfeuer> and the _
12:28:29 <dmhouse> Stupid reserved syntax.
12:28:46 <dfeuer> > let _|_ = undefined in _|_
12:28:47 <lambdabot>  Parse error in expression
12:29:15 <dfeuer> Hey, the Haskell Way would be to make a special rule for _|_
12:29:18 <dmhouse> > let (⊥) = undefined in (⊥)
12:29:19 <lambdabot>  Illegal character ''\138''
12:29:27 <dfeuer> Now that's lame.
12:29:55 <SamB> well, at least lambdabot tells you what character is illegal
12:30:00 <isaacd> > let ? = undefined; (<>) = ? in (<>)
12:30:00 <lambdabot>  Parse error
12:30:02 <SamB> @type let (⊥) = undefined in (⊥)
12:30:04 <lambdabot> lexical error
12:30:08 <Cale> that'll be fixed in the next ghc
12:30:09 <isaacd> > let (?) = undefined; (<>) = (?) in (<>)
12:30:10 <lambdabot>  Add a type signature
12:30:14 <SamB> see, GHC isn't nearly as helpful
12:30:16 <isaacd> > let (?) = undefined; (<>) = (?) in (<>) :: Int
12:30:18 <lambdabot>  Undefined
12:30:59 <dfeuer> I just wish ghci had proper input handling.
12:31:16 <dfeuer> i.e., at least GNU getline.
12:31:37 <dmhouse> Trunk GHCi has tab-completion against names in scope :)
12:31:51 <dfeuer> Can you use the arrow keys sensibly in it?
12:32:03 <dmhouse> You can use <up>, as always. I hope they fix <down>.
12:32:30 <dfeuer> Also, if it can't handle new definitions, it should really provide some facilities to edit modules.
12:32:33 <dfeuer> Or something.
12:32:35 <shapr> bringert: Bug report from a reader: The RSS for your new blog doesn't seem to be well-formed: ">HC&AR report hightlights! w00!</title"
12:32:41 <dmhouse> But then <down> doesn't work in my shell, so that'd be greedy.
12:32:56 <dfeuer> Hey, <up> doesn't work in the released version.
12:32:57 <bringert> shapr: hmm, yes
12:33:21 <dmhouse> dfeuer: Auto reloading when the file on disk changes (as in WinHugs) would be great.
12:33:24 <xerox> <up> and <down> work here.
12:33:47 <shapr> bringert: Did you see my thought that a wiki is like darcs get --partial on a blog? It's like cvs co without the history.
12:33:49 <dmhouse> xerox, go into ghci, type something, hit <down>. Does it get cleared?
12:34:00 <xerox> No.
12:34:05 <dfeuer> I hit <up> and the cursor moves up and then when I type enter I get a lexical error.
12:34:11 <dmhouse> That's what I mean by 'fixing <down>'.
12:34:21 <dfeuer> Unless I backspace out the up code.
12:34:27 <dmhouse> If you do that, it should store it in the history, and clear the line for me.
12:34:30 <dmhouse> Like irssi, basically. :)
12:34:31 <bringert> shapr: no, I didn't see that
12:34:54 <dmhouse> Yay! England just scored!
12:34:55 <dfeuer> Where can I find some algebraic number code?
12:35:07 <dmhouse> Hrm. Probably shouldn't be saying that considering the numbers of Swedes who frequent here.
12:35:10 <shapr> It seems like a blog is updating the wiki of my mind.
12:35:11 <bringert> bringert: hope should keep a revision history of entries, and escpecially static pages when the come around
12:35:33 <shapr> Maybe we should use darcs for the formal version control and publishing system?
12:35:45 <dmhouse> Ooh! I want a darcs based wiki.
12:35:55 <monochrom> horror
12:35:55 <isaacd> @google darcs wiki
12:35:59 <lambdabot> http://www.darcs.net/DarcsWiki
12:36:00 <lambdabot> Title: "FrontPage - DarcsWiki"
12:36:05 <dmhouse> But before that I want VC integration for MediaWiki.
12:36:05 <shapr> Like, instead of WAR files like Jave Enterprise does, how about publishing a website as a repo?
12:36:06 <isaacd> :?
12:36:08 <dmhouse> (in Emacs)
12:36:08 <isaacd> :/
12:36:12 <isaacd> *
12:36:28 <bringert> shapr: blame stepcut for the RSS :-)
12:36:30 <shapr> dmhouse: Make your MediaWiki into a darcs repo?
12:36:34 <shapr> bringert: Heh, ok
12:36:47 <xerox> bringert: I got a new one (-:
12:36:50 <dmhouse> shapr, no, allow me to do C-x v v to save new versions of a MediaWiki page.
12:36:57 <bringert> I guess the title should be have a CDATA thing
12:37:44 <bringert> xerox: a new what?
12:37:48 <xerox> CSS
12:37:54 <xerox> Well, I just tweaked colors.
12:38:02 <bringert> ah, nice
12:38:18 <shapr> dmhouse: Right, make your MediaWiki data dir a darcs repo, then push the changes.
12:38:31 <bringert> the html should be very generic, it'd be fun to see what you could do with just CSS
12:38:37 <xerox> Yeah, indeed.
12:38:51 <dmhouse> shapr: Why? MediaWiki already has versioning.
12:39:07 <dmhouse> shapr, a more natural binding would save new versions using MediaWiki's versioning.
12:39:07 <shapr> Yeah, but can you use your wiki in offline mode?
12:39:23 <shapr> Or, can you pull changes from your frieds?
12:39:32 <bringert> xerox: hmm, maybe it's HaXml's fault
12:40:17 <bringert> eh that was for shapr
12:40:31 <dmhouse> shapr, I'm talking more of an interface to a big centralised wiki like Wikipedia. If I wanted a team wiki I'd probably just use a repo.
12:41:14 <dmhouse> And use something a _lot_ more lightweight than MediaWiki for rendering the wiki markup :)
12:41:37 <shapr> I think that's what I'm describing. Make local changes to your Wikipedia repo then push the changes.
12:41:48 <shapr> Or wikipedia could pull from you only if they trust you.
12:43:02 <dmhouse> Hrm.
12:43:13 <dmhouse> That'd require everyone having their local copy of Wikipedia.
12:43:34 <dmhouse> Unless you employed some sophisticated partitioning techniques
12:43:44 <shapr> Yeah, that's been my biggest problem thinking about FLM.
12:43:50 <dmhouse> FLM?
12:44:52 <shapr> Fermat's Last Margin
12:46:16 <dmhouse> Hehe. What's that?
12:47:01 <shapr> @google fermat's last margin
12:47:05 <lambdabot> http://mathworld.wolfram.com/FermatsLastTheorem.html
12:47:05 <lambdabot> Title: "Fermat's Last Theorem -- from Wolfram MathWorld"
12:47:07 <shapr> hmm
12:47:09 <shapr> @google fermat's last margin haskell
12:47:13 <lambdabot> http://www.scannedinavian.com/~shae/blog/2004Dec.html
12:47:14 <lambdabot> Title: "Shae Erisson's blog"
12:47:17 <dmhouse> @google "fermat's last margin"
12:47:26 <lambdabot> http://www.scannedinavian.org/RandomWiki/AnnotationMockup
12:47:52 <shapr> Basically, turn research papers into page images, then stuff those images into a wiki and add text to those pages as annotations.
12:48:05 <shapr> The idea being to turn on comments for research papers.
12:48:19 <dmhouse> Hmm. 'Firefox can't find the server at www.scannedinavian.org.'
12:48:35 <shapr> Yeah, I should fix that.
12:48:40 <dmhouse> ?
12:49:00 <int-e> .com should work
12:49:18 <int-e> or maybe not
12:50:14 <dmhouse> .com is the right server, but it 404s on that page.
12:53:04 <shapr> Yeah, various things have happened to my ISP hosting...
12:53:14 <shapr> In short, my old wiki is gone.
12:58:17 <dfeuer> Hmm.....  Question:  Are the "2-3 finger trees" in the paper actually 2-3-4 finger trees?
12:58:40 <dfeuer> except at the leaves?
12:59:27 <dfeuer> or something
13:00:06 <dmhouse> dfeuer: I think they're actually 1-2-3-4 finger tress.
13:00:09 <dmhouse> *trees.
13:00:16 <dfeuer> ah
13:00:22 <dmhouse> dfeuer: They mention they're relaxing the 2-3 constraint somewhere, IIRC.
13:00:27 <dfeuer> yeah, they do.
13:00:44 <dfeuer> I wonder if it still makes sense to call 'em 2-3 finger trees.
13:01:20 <dfeuer> Another thing:  they suggest representing digits as  One a | Two a a | Three a a a | Four a a a a.
13:01:23 <dfeuer> That looks kind of icky.
13:01:30 <dfeuer> Shouldn't there be a better way?
13:01:36 <SamB> how would you do it?
13:01:56 <SamB> D1 a | D2 a a | D3 a a a | D4 a a a a?
13:01:56 <dmhouse> I quite like that way.
13:02:12 <dmhouse> You're likely going to have to pattern match on the length of a list if you use a list anyway.
13:02:33 <int-e> the pretty way is [a] ... but that's less efficient.
13:02:38 <dmhouse> E.g. case node of [x] -> foo; [x, y] -> bar; [x, y, z] -> baz; [x, y, z, w] -> baq;
13:02:42 <dfeuer> Not sure.  One option would be type Digit a = Digit (Int, a, a, a, a)
13:03:04 <dmhouse> or even (Int, Maybe a, Maybe a, Maybe a, Maybe a)
13:03:06 <dfeuer> nah.
13:03:12 <dfeuer> Both are yucky.
13:03:33 <dmhouse> dfeuer: How would yours work? You fill it in with _|_s?
13:03:47 <dfeuer> Yeah.  But it'd be gross.  Forget I said it.
13:03:52 <dmhouse> ;)
13:04:46 <earthy> it'd be the C struct implementation :)
13:07:14 <dmhouse> I'm reading an old paper which contrasts Gofer and Haskell. What was the difference?
13:08:55 <dfeuer> One way would be  data Digit a = Digit a (Maybe (Max3 a));  data Max3 a = Max3 a (Maybe (Max2 a));  data Max2 a = Max2 a (Maybe a)
13:09:01 <norpan> gofer was a version of haskell
13:09:18 <dfeuer> Which would be horribly inefficient, as well as hard to write.
13:09:23 <int-e> dfeuer: that's not much better than [a], efficiency wise.
13:09:33 <int-e> perhaps even worse.
13:09:39 <dfeuer> Probably worse.
13:10:05 <bringert> shapr: RSS escaping patch in darcs now
13:10:11 <bringert> time for lunch
13:10:19 <dfeuer> Let's try to figure out the required operations.
13:10:20 <bringert> now how do I get this dog off my lap?
13:10:28 <dmhouse> bringert: stand up.
13:10:32 <shapr> bringert: Thanks!
13:12:32 <dfeuer> Certainly cons on a digit of length 1, 2, or 3, split a digit of length 4 with an addition,
13:12:41 <dfeuer> car, cdr
13:12:48 <Cale> what's wrong with the other version?
13:13:20 <Cale> data Digit a = D1 a | D2 a a | D3 a a a | D4 a a a a
13:13:29 <Cale> that seems reasonable
13:13:40 <dfeuer> Cale, it may very well be best, but it doesn't express that it's acting as a variable-length buffer.
13:13:54 <dfeuer> And it does not support fast cons or cdr.
13:14:25 <Cale> constant-time isn't fast enough?
13:15:07 <palomer> we want 0 time!
13:15:11 <dmhouse> With a maxmium of only four four elements access time seems a moot point.
13:15:21 <Cale> yeah
13:15:22 <dfeuer> Well...  They say using their 2-3 finger trees as search trees is around 3-5 times slower than the best balanced tree implementations.
13:15:22 <palomer> we want it to happen in the past
13:16:02 <dmhouse> Hehe. O(-n) time. :)
13:16:06 <Cale> That's not bad
13:16:15 <dfeuer> Not _bad_
13:16:58 <dfeuer> But it suggests room for improvement, no?
13:17:09 <Cale> maybe
13:17:32 <Cale> Will you harm other properties while making it a better search tree though?
13:17:44 <dfeuer> <shrug>
13:18:42 <shapr> The point of the finger tree to me is that it's a single algorithm that's pretty good at everything.
13:18:54 <shapr> That's why I want to use it.
13:19:59 <shapr> Maybe you could say that it's best feature is that its worst never gets very bad :-)
13:20:09 <shapr> oops, "its best feature"
13:20:22 <lscd> dmhouse: I want algorithms in the -np class! :D
13:20:41 <dfeuer> I guess one trick to making it faster is to avoid using reduce so much.
13:21:04 <dmhouse> Who's checked out the Haskell wikibook lately?
13:21:18 <dmhouse> http://en.wikibooks.org/wiki/Haskell
13:21:32 <dmhouse> I think you should all go forth and share your knowledge. :)
13:21:51 <dmhouse> I've written a few modules, and guy called Kowey has being doing some reorganisation, and it's got a lot better.
13:22:16 <dmhouse> It still needs lots of writing, though, and some of the earlier modules almost certainly need restructuring or improving in different places.
13:22:40 <dmhouse> I think the original guy who wrote it was still quite new to Haskell at the time.
13:22:59 <dmhouse> (He got otherwise confused with _ and wrote bind as <<=. :))
13:24:25 <Cale> I find myself replacing the word 'statement' with 'expression' in various places in that book from time to time :) Also I wrote a good chunk on list functions.
13:24:55 <xerox> Tomorrow -> exam!
13:25:03 <xerox> I'll be heading to bed now :-)
13:25:04 <dmhouse> Cale, :) nice.
13:25:27 <dmhouse> I wrote quite a bit on monads (including the entire Advanced Monads and Additive Monads chapters), and have been doing a bit of refactoring.
13:25:31 <dmhouse> xerox, good luck!
13:25:40 <xerox> Thank you!
13:26:50 <psnl> xerox: being on #haskell boosts haskell exam marks
13:27:49 <Cale> I don't even think there is a 'statement' syntactic class in Haskell
13:30:34 <Philippa_> Cale: there might be via do notation
13:34:18 <Cale> yeah, perhaps those are called statements
13:34:28 <Cale> (the lines)
13:34:49 <Igloo> They are
13:35:12 <int-e> do { stmts } 
13:37:45 <satan> any idea why i'm getting this? Prelude> cube x = x^3
13:37:45 <satan> <interactive>:1:7: parse error on input `='
13:37:57 <dmhouse> satan: use 'let cube = ...'
13:38:04 <dmhouse> You have to use lets with GHCi.
13:38:16 <dmhouse> (Imagine you're in a do-block, if you know monads.)
13:38:18 <Cale> ghci isn't really the place to put your definitions though
13:38:21 <satan> oh? i dont have lets in my source.hs
13:38:28 <Cale> you should actually put them in your source file
13:38:32 <dmhouse> satan: Nope, but you need them in GHCi.
13:38:35 <satan> and thereby avoid the lets
13:38:36 <Cale> ghci is really for evaluating expressions
13:38:38 <satan> ah ok
13:38:40 <satan> gotcha
13:40:00 <satan> thanks guys
13:41:06 <palomer> Cale: here's a tough problem which seems easy: given the 4 side lengths of a 4-gon, and the fact that two angles formed from the base are equal, find the height of the two non base points
13:46:46 <int-e> palomer: that seems to become a quartic equation
13:49:23 <Cale> It's doable
13:49:36 <Cale> but yeah, a bit messy
13:50:48 <int-e> hmm. a quadratic equation in cos(phi) is what I actually get now. good.
13:51:46 <palomer> int-e: is it correct?
13:52:23 <palomer> I get major ugliness
13:52:53 <palomer> one of the base points is going to have height sqrt(-(b*b*d0*d0-4.0*d0*d0*d1*d1+b*b*d1*d1-b*d1*sqrt(b*b*d1*d1-2.0*b*b*d1*d0+b*b*d0*d0+4.0*d0*d2*d2*d1-4.0*d0*d1*d1*d1+8.0*d0*d0*d1*d1-4.0*d0*d0*d0*d1)-2.0*d0*d0*d0*d1-b*d0*sqrt(b*b*d1*d1-2.0*b*b*d1*d0+b*b*d0*d0+4.0*d0*d2*d2*d1-4.0*d0*d1*d1*d1+8.0*d0*d0*d1*d1-4.0*d0*d0*d0*d1)+2.0*d0*d2*d2*d1-2.0*d0*d1*d1*d1)/(d0*d0)/2.0)*d0/d1/2.0; where d0,d1,d2,b are the sides
13:53:00 <int-e> [a-(b+d)cos(phi)]^2 + [(b-d)sin(phi)]^2 = c^2 is definitely a quadratic equation in cos(phi) (using pythagoras' theorem)
13:53:01 <palomer> err, non base points
13:53:25 <palomer> right, it gives you 3 quadratic equations
13:53:31 <int-e> one.
13:53:47 <palomer> what's phi?
13:54:10 <basti_> o.o
13:54:12 <int-e> the unknow angle between a and b (which equals the one between a and d)
13:54:31 <palomer> b is the base?
13:54:37 <int-e> a is the base
13:54:42 <palomer> gotcha
13:54:54 <Cale> int-e chose the same convention that I did :)
13:55:02 <palomer> and how did you get that equation?
13:56:30 <palomer> note: all 4 sides might have different lengths
13:57:15 <int-e> palomer: they do. it's just Pythagora's theorem; one side of the triangle is parallel to a, the other is orthogonal to a; the hypotenuse is c.
13:57:37 <int-e> Pythagoras'
13:57:54 <monochrom> Pythagoras's
13:58:51 <basti_> s's's?
13:59:00 <int-e> if you want, choose cartesian coordinates such that a becomes the x-axis and one endpoint of a the origin, then find the coordinates of the 3 remaining points.
13:59:26 <int-e> > let s = "s"; s's = s++s; s's's = s's ++ s's in s's's
13:59:28 <lambdabot>  "ssss"
14:00:25 <SyntaxNinja> which wiki software is haskell.org?
14:00:32 <dmhouse> MediaWiki.
14:02:25 <SyntaxNinja> thought so, but couldn't find any reference to it.
14:03:30 <basti_> the parser supports multifix notations??
14:03:35 <basti_> :-O
14:04:30 <jer> ?
14:04:46 <dmhouse> basti_: No, (') isn't a function.
14:04:54 <basti_> uhm
14:05:02 <basti_> ah.
14:05:02 <int-e> Cale: I initially messed up slightly and swapped sin and cos; that way I lost the symmetry and got a quartic equation instead of the quadratic one.
14:05:03 <basti_> okay.
14:05:08 <basti_> >_<
14:07:29 <palomer> the hypotenus is c?
14:07:45 <palomer> c could be parallel to a
14:08:08 <int-e> palomer: so what - you get a degenerate right triangle then
14:08:17 <int-e> palomer: with a^2 + 0^2 = c^2
14:08:36 <palomer> so the sides of the triangle ar a, (b+d) and c ?
14:08:41 <int-e> (these a and b are different from the 4-gons a and b)
14:08:42 <palomer> and it's a right angle triangle?
14:08:52 <int-e> palomer: no.
14:08:56 <palomer> oh, I'm talking in terms of the 4-gon
14:09:02 <int-e> the sides depend on phi, obviously.
14:09:15 <palomer> you can make a right angle triangle with that 4-gon
14:09:17 <palomer> who's angle is phi
14:09:19 <palomer> amiright?
14:10:09 <Cale> "Note that in Haskell if is an expression (returning a value) rather than a statement (to be executed). Because of this the usual indentation is different from imperative languages. If you need to break an if statement across multiple lines then you should indent it like one of these"
14:10:14 <Cale> aaaaaaahh!
14:10:24 <Cale> hehe
14:10:56 <Cale> They tell you that it's an expression and not a statement, then proceed to refer to it as a statement immediately after.
14:11:06 <dmhouse> Hehe.
14:11:31 <SamB> well, it could be a statement!
14:11:35 * dmhouse just bought 'Types and Programming Languages' :)
14:11:36 <SamB> what if it were:
14:11:57 <SamB> if feelingNasty then reformatHarddrive else return ()
14:12:20 <SamB> Which isn't really a statement the way the term is used WRT natural languages
14:13:42 <Cale> That's not a statement anyway. The only "statements" we've found so far in Haskell are specifically the lines of do-blocks. (The things which are separated by ;)
14:13:49 <int-e> palomer: http://img480.imageshack.us/img480/4996/t6yv.png <-- look here. (x is phi, and at the top is a nice right triangle)
14:14:23 <palomer> right
14:15:38 <Cale> MonadPlus should be called Ringad ;)
14:15:39 <palomer> very nice
14:18:44 <SyntaxNinja> bringert: does haskelldb work w/ sqlite?
14:18:59 <bringert> SyntaxNinja: yep
14:19:09 <bringert> SyntaxNinja: one problem though
14:20:18 <bringert> SyntaxNinja: sqlite doesn't support character escapes for some reason, so if you insert data with things like newlines in it, you get the literal escapes in the data
14:20:38 <bringert> and when you query it back out, those don't go away
14:21:09 <bringert> another reason why HaskellDB needs back-end dependent SQL generation
14:21:42 <SyntaxNinja> interesting
14:22:07 <bringert> SyntaxNinja: HaskellDB/flat seems to not be entirely unreliable btw, xerox is using it as a back-end for his Hope-installation: http://paolo.is-a-geek.com/mu/entry
14:22:19 <bringert> I did warn him about it
14:23:56 <SyntaxNinja> sweeeeeet
14:24:54 <jgrimes> bringert, you seem to be making good progress on hope :)
14:25:44 <bringert> jgrimes: thank you. did you mean progress on making it good or making it widespread by the way?
14:25:49 <int-e> @index getArgs
14:25:50 <lambdabot> System.Environment
14:25:57 <bringert> jgrimes: did you ever get it working?
14:26:22 <jgrimes> bringert, yes, I got it working
14:26:29 <jgrimes> bringert, I meant progress as in general
14:26:36 <bringert> jgrimes: is it public?
14:27:16 <jgrimes> bringert, not currently
14:27:48 <bringert> oops, looks like my new permissions model locked everyone out from the hope homepage
14:28:19 <bringert> fixed
14:29:09 <jgrimes> :)
14:29:33 <bringert> jgrimes: if it's something you want to keep private, you may want to try the current version which lets you block reading permissions for anonymous users (and lots of other permissions stuff)
14:29:58 <bringert> I forgot to turn on read access for anonymous users after upgrading, hence the lock-out
14:29:59 <jgrimes> bringert, it's not really that, it's just that it is on my internal network currently
14:30:05 <bringert> ok
14:30:18 <jgrimes> bringert, but yeah, I've been messing around with some of the permissions stuff
14:30:25 <jgrimes> works so far
14:30:26 <jgrimes> :)
14:30:47 <bringert> jgrimes: bug reports, suggestions and patches are extremely welcome
14:31:06 <jgrimes> bringert, alright, should I email those to you?
14:32:06 <bringert> jgrimes: yes please. you can say shorter things here if that's better for you
14:32:30 <jgrimes> bringert, I'll email them, it's no problem :)
14:33:58 <dreamEye> what about extending haskell to have reflection?
14:35:30 <dreamEye> to do things like theese: http://www.mail-archive.com/haskell@haskell.org/msg18593.html
14:37:13 <Igloo> ghc-as-a-package and some of the recent debugger work might be steps towards that
14:37:14 <dreamEye> it is very importat to create real frameworks for industrial programming
14:38:16 <dreamEye> for example, some ugly languages such are rubi are gaining momentum because they have reflection so they have good frameworks
14:39:24 <dreamEye> Rails, from Rubi uses a lot of reflection and metaprogramming to ease the creation of web applications
14:39:38 <dreamEye> Haskell should have something like that
14:39:47 <Excedrin> why
14:39:51 <dreamEye> because Haskell IS BETTER
14:40:02 <newsham> mmmmm reflection.
14:40:18 <dreamEye> why? because most of the code needed is made by the framework by examining the user clases and methods
14:40:58 <dreamEye> all the plumbing is created on the fly by inspecting the user code
14:41:44 <dreamEye> the Rails framework do that
14:42:22 <Excedrin> what's the point in re-implementing Rails in Haskell? It's already done, move on and do something interesting and new
14:42:44 <dreamEye> it is already done?
14:43:05 <newsham> because it would be nice to have a nice industrial grade web application framework in haskell
14:43:18 <dreamEye> I wonder how. Maybe with a lot of Template haskell....
14:43:20 <newsham> the point of rails isnt rails itself, but the scripts that you write on top of rails
14:43:39 <newsham> which have to be in ruby.
14:44:34 <dreamEye> rigth
14:45:27 <dreamEye> Template Haskell can do some of this work, but TH is not for everyone
14:46:30 <newsham> TH isnt a replacement for reflection.
14:46:47 <dreamEye> that is true
14:47:09 <dreamEye> It can do something as reflection at compile time
14:47:35 <dreamEye> but not at runtime
14:48:39 <shapr> hs-plugins plus TH can do that.
14:48:58 <dreamEye> must not be as hard to implement haskell reflection
14:49:17 <shapr> Actually, because TH runs code at compile time, you can get reflection at runtime by running your entire app in the compile process.
14:49:38 <shapr> dreamEye: What sort of reflection do you want?
14:50:35 <dreamEye> shapr: for example, Rails rely on the properties on a object to create a table with colums with the same names
14:50:54 <shapr> That's easy enough to do by combining SerTH and HaskellDB.
14:51:40 <dreamEye> but this is not as easy as a line of Rubi code
14:51:43 <Igloo> You don't need run-time reflection to do what rails does, if rails does what I think it does
14:51:52 <shapr> dreamEye: It'd be easier even.
14:51:59 <dreamEye> Rubi does this at runtime
14:52:14 <shapr> You'd add "deriving DB" or something to your datatype.
14:52:21 <newsham> igloo: the point was that reflection makes the code simple.
14:52:22 * Igloo has actually had doing something similar on my todo list ever since getting annoyed with the lack of safety when dealing with SQL in Bark
14:52:34 <dreamEye> I want a framework that does that for me!!!
14:52:44 <jgrimes> dreamEye, start coding ;)
14:52:46 <dreamEye> I don want to train every programmer in TH
14:52:56 <shapr> You don't have to.
14:53:14 <Igloo> newsham: I thought someone was saying the compile-time-only-ness of TH was a problem for a rails-a-like, but maybe I misunderstood
14:53:26 <dreamEye> I need reflection to ease the creation of frameworks as Rails
14:53:58 <shapr> You mean you want transparent database persistence, yeah?
14:53:58 <yaxu> hello, i'm learning haskell - anyone here using it for music?
14:54:10 <shapr> yaxu: I've used it for Haskore a bit. Only a tiny bit though.
14:54:12 <yaxu> well, beginning to learn haskell...
14:54:19 <jgrimes> yaxu, for composing or playing?
14:54:43 <yaxu> jgrimes: composing mainly
14:55:10 <shapr> dreamEye: Refleciton means you want to be able to inspect the datatype and derive another operation on it automatically, yeah?
14:55:15 <yaxu> jgrimes: although i'm interested in live improvising really
14:55:24 <yaxu> jgrimes: so i guess both, at the same time
14:55:36 <shapr> Hm, you could do that with Haskore and CSound.
14:55:46 <dreamEye> aharp: there are much more things than database persistence. Everywhere when a complex system is needed to be accessed easily it is neccesary a short of framework with reflection
14:55:51 <shapr> Haskore can stream to a MIDI player or to CSound.
14:56:13 <shapr> dreamEye: That's really general, can you give some specifics?
14:56:51 <yaxu> shapr: i'd like to use OpenSoundControl rather than midi
14:57:03 <jgrimes> yaxu, I've looked at haskore some. as shapr has said, I think it does some of what you are looking for
14:57:04 <yaxu> and want to avoid csound :)
14:57:21 <shapr> I don't know OpenSoundControl.
14:57:24 <yaxu> open sound control is like midi but a lot more flexible
14:57:39 <dreamEye> shapr: a complex system may be somethig that offers something as  a programming language as interface. SQL does
14:57:39 <shapr> Is it a superset of midi? Is it vaguely related?
14:57:51 <shapr> dreamEye: I don't see how that relates to reflection.
14:58:03 <yaxu> not related really
14:58:26 <yaxu> open sound control is a network protocol, most often sits on top of UDP
14:58:26 <shapr> yaxu: In any case, the Music type is really general, and should be easy to map onto whatever.
14:58:59 <yaxu> i guess my first haskell project would be to implement open sound control :/
14:59:07 <shapr> Sounds like fun to me.
14:59:14 <jgrimes> yaxu, go for it :)
14:59:14 <bobthemonkey13> i have a quick, stupid question: is there anything builtin like fst and snd for triples?
14:59:30 <yaxu> i implemented it in perl once, but am new to functional programming
14:59:37 <monochrom> No, bobthemonkey13
14:59:44 <shapr> You can use "fst3 = \(x,_,_) -> x" etc
14:59:45 <dreamEye> sharp: the program-database  persistence problem is related with a mapping between the namespaces of the program and the namespaces of the database. with reflection we can create automatically something that do it
14:59:49 <jgrimes> bobthemonkey13, I used pattern matching to make my own
15:00:03 <jgrimes> bobthemonkey13, like what shapr just wrote
15:00:04 <jgrimes> :p
15:00:12 <yaxu> i see there is an open sound control (OSC) client for lisp, is it easy to port things from lisp to haskell?
15:00:13 <dreamEye> I have to leave. see yo later.
15:00:19 <bobthemonkey13> yeah, it's easy to write, i just think fewer lines of code == better ;)
15:00:25 <shapr> dreamEye: TH and Generic Haskell solve that problem for the most part.
15:00:44 <bringert> heh, the date range stuff in Hope is completely broken
15:00:44 <shapr> dreamEye: Check out the "scrap your boilerplate" series of papers.
15:00:56 <shapr> bringert: Yeah, I noticed that, but I kept forgetting to tell you.
15:00:57 <dreamEye> generic Haskell is too particular ;)
15:01:09 <bringert>                  let fr = maybe (constant True) ((e!E.date .>=.) . constant) f
15:01:10 <bringert>                      to = maybe (constant True) ((e!E.date .>=.) . constant) t
15:01:10 <shapr> dreamEye: How so?
15:01:21 <bringert> you'd thing one of those should be a .<.
15:01:26 <bringert> think
15:02:07 <shapr> yaxu: Lisp really isn't that close to Haskell. It might give you something to start from though.
15:02:48 <shapr> Does anyone know a simple and fast speech recognition algorithm? With those two limitations, I'm obviously not looking for high quality recognition :-)
15:03:13 <bringert> shapr: patch in darcs now
15:03:21 <yaxu> shapr: now there's a question :)
15:03:25 <bringert> shapr: sure
15:03:35 <bringert> shapr: if you want really low accuracy
15:03:44 <bringert> shapr: always output "banana"
15:03:50 <jgrimes> :p
15:04:09 <shapr> bringert: I want to try writing something ilke spoken unlambda to start with, and run it on my Nokia 770.
15:04:24 <jgrimes> shapr, nice :)
15:04:29 <bringert> does it run a normal linux?
15:04:45 <bringert> shapr: you could try compiling ATK
15:04:49 <shapr> Sort of, it's a modified debian ARM
15:04:55 <shapr> ATK?
15:05:08 <shapr> oh, I see.
15:05:12 <bringert> http://htk.eng.cam.ac.uk/develop/atk.shtml
15:05:35 <bringert> shapr: simple haskell binding here: http://www.cs.chalmers.se/~bringert/darcs/atkrec/
15:05:39 <shapr> w00
15:05:45 <shapr> Perfect!
15:06:13 <shapr> I wonder if it'll be fast enough with 64mb of ram and a 225MHz cpu.
15:09:04 <bringert> sorry, low battery there
15:09:43 <bringert> shapr: yeah, you can compile GF to use that to get a speech recognition command
15:10:05 <bringert> it tells HTK to recognize sentences in the current grammar,
15:10:25 <bringert> so if the grammar is small it's fairly accurate
15:11:04 <bringert> this dog really likes to lick me
15:11:13 * bringert is house and dog sitting
15:11:56 * yaxu is entertaining a kitten
15:12:23 <yaxu> her final sibling got rehomed so she's a bit bored
15:14:52 <int-e> hehe. jhc doesn't like type driven function calls with dummy arguments, ala f (undefined `asTypeOf` x) it seems.
15:23:53 <yaxu> is there a way of interactive programming with haskell?
15:24:08 <yaxu> i guess like hugs but where I can define things
15:24:18 <yaxu> maybe i should try the emacs hugs mode
15:24:30 <lorne> in ghci you can use let
15:24:58 <yaxu> ah, i hadn't heard of ghci, looks good thanks
15:25:09 <yaxu> sorry for all these beginner questions
15:32:02 <shapr> bringert: What's a small grammar?
15:32:22 <bringert> shapr: one which generates few sentences
15:33:08 <bringert> shapr: or did you want an example of one?
15:33:34 <shapr> Nah, just wondering whether that means three pieces like lambda cal, or twenty or thirty pieces like Joy.
15:33:52 <bringert> what's a piece?
15:34:06 <bringert> shapr: a few hundred word forms should be ok
15:34:22 <shapr> Oh, that sounds great.
15:34:42 * shapr considers an agglutinative programming language...
15:34:51 <bringert> shapr: ATK only comes with a basic UK English acoustic model, and a large UK english pronunciation dictionary
15:35:06 <bringert> so it helps if you speak UK english
15:35:41 <shapr> I don't know enough to know if that will make a difference or not.
15:36:06 <newsham> S -> SA | A;  A -> a;    is a small grammar :)
15:36:23 <bringert> some people in out group were frustrated with the recognition performance of a dialog system demo of theirs, until they demoed it at a conference and a native Californian shows up and talks to the system
15:36:31 <bringert> it worked perfectly
15:36:59 <bringert> the dangers of having non-native speakers test speech recognizers
15:38:16 <Igloo> As opposed to a Swedish person?
15:39:03 <bringert> Igloo: last time I check, our native language isn't English. though that may have changed.
15:39:19 <bringert> eh, as demonstrated by my lacking grammar skills
15:39:26 <bringert> s/check/checked/
15:39:40 <Igloo> bringert: Sure, just wasn't sure that's what the comparison was
15:39:51 <bringert> :-)
15:40:08 <bringert> I guess I should have said that the system used a US English recognizer
15:40:18 <bringert> silly me
15:40:35 <Igloo> Right, it was partly the UK -> Californian bit that threw me  :-)
15:41:17 <bringert> everyone does language technology research for English, which seriously affects what sort of things they study
15:41:48 <bringert> there are serious machine translation approaches that don't consider morphology at all
15:42:28 <norpan> you need at least another language with machine translation though :)
15:42:47 <bringert> you'd think so
15:43:17 <norpan> i have a good algorithm for translating english to english but it doesn't scale :)
15:43:31 <AtnNn> Where can I get more information on how liftM2 div sum length works and on what ((->) a) types are? Is there any paper you guys can recommend?
15:44:33 <bringert> mostly it's translation from other language to English (for obvious US government funding reasons (hint Echelon)). they consider each word form in the input to be a different word, and generate English without morphology
15:44:58 <bringert> which kind of works for translating to English
15:54:29 <urz> is it possible to make named constants that can be used in pattern matching?
15:58:58 <Saulzar> AtnNn, It uses the monad instance for a function type which is what the ((->) a) thing is about
15:59:27 <Saulzar> @google all about monads
15:59:31 <lambdabot> http://www.nomaware.com/monads/html/
15:59:32 <lambdabot> Title: "All About Monads"
16:00:28 <AtnNn> I'm reading that atm. Do you know what chapter I should skip to?
16:04:33 <bringert> Saulzar: probably not exactly as you think, (re named constants)
16:04:49 <bringert> Saulzar: you can use guards, or an algebraic datatype
16:05:00 <bringert> foo = 1
16:05:07 <bringert> f x | x == foo = ...
16:05:17 <bringert> (guards)
16:05:20 <bringert> or:
16:05:29 <urz> you must be talking to me 
16:05:36 <bringert> eh sorry
16:05:40 <bringert> yes
16:06:08 <urz> ok
16:06:36 <bringert> many times, using an algebraic datatype works for the same thing, but I guess that's not the case since you are asking
16:12:08 <urz> well actually, there is an algebraic datatype
16:12:12 <urz> and i was using a pattern
16:12:16 <urz> but it was a long pattern
16:12:18 <urz> heh
16:12:52 <urz> the gaurd notation is kind of long itself
16:13:08 <urz> not as bad tho
16:14:55 <hyrax42_> AtnNn: ((->) a) is aka Reader a
16:15:36 <hyrax42_> so skip to the Reader monad chapter
16:16:08 <AtnNn> I just read it, but it doesn't use that notation
16:16:54 <hyrax42_> what are you trying to do?
16:17:54 <bringert> AtnNn: maybe someone said it already, but ((->) a) is the type-level operator (->) applied to a single type a
16:17:54 <hyrax42_> or finding troubling
16:18:27 <bringert> AtnNn: i.e. it is a type-level function which takes any type b and gives you the type a -> b
16:18:38 <AtnNn> I saw avg = liftM2 div sum length in here yesterday, and I'm trying to understand how it works
16:19:30 <hyrax42_> oh
16:20:31 <hyrax42_> well, I might be wrong
16:20:46 <bringert> you can write it as avg xs = div (sum xs) (length xs)
16:20:58 <AtnNn> yeah, the liftM2 makes that pointless though
16:21:05 <hyrax42_> but there the case is that both sum and length are [a] -> *something*
16:21:18 <hyrax42_> i.e. (->) [a]
16:21:33 <AtnNn> ok
16:21:40 <hyrax42_> (which, apparently, must be written thus due to some sytactic reasons)
16:21:47 <hyrax42_> (rather than the more logical ([a] ->)
16:21:55 <hyrax42_> lexical rather
16:21:59 <AtnNn> i see
16:22:01 <AtnNn> @type liftM2 div sum length
16:22:02 <lambdabot> [Int] -> Int
16:22:26 <AtnNn> Prelude Monad> :t liftM2 div sum length
16:22:31 <hyrax42_> ohhh
16:22:38 <AtnNn>     No instance for (Monad ((->) [Int]))
16:22:42 <AtnNn> what am I missing?
16:22:42 <hyrax42_> import Control.Monad.Reader
16:22:59 <hyrax42_> that import at the tope
16:22:59 <hyrax42_> top
16:23:18 <AtnNn> so it's just sugar for a Reader?
16:23:25 <hyrax42_> or :m + Control.Monad.Reader
16:23:42 <hyrax42_> it is reader, just the monad instance isn't defined in prelude
16:23:52 <bringert> liftM2 in the reader monad is a way to give one argument to two functions, and combine the results using a third function
16:23:55 <hyrax42_> so missing definitions of bind and return to make liftM2 work
16:24:03 <AtnNn> ok
16:24:12 <bringert> AtnNn: rather, Reader is sugar for that
16:24:27 <AtnNn> lol, ok
16:24:50 <hyrax42_> I should pay more attention to this
16:24:55 <bringert> AtnNn: see http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
16:25:18 <hyrax42_> I've been making unnecesary use of Control.Arrow stuff
16:25:29 <bringert> newtype Reader r a = Reader { runReader :: (r -> a) }
16:26:24 <bringert> hyrax42_: it doesn't always give very readable code
16:26:45 <hyrax42_> e.g. avg = (sum &&& length) >>> (arr $ uncurry div)
16:26:53 <bringert> I'd prefer avg xs = div (sum xs) (length xs)  to  avg = liftM2 div sum length
16:30:36 <int-e> @type uncurry div . foldl (\(s,n) x -> (s+x, n+1)) (0,0)
16:30:38 <lambdabot> forall b. (Integral b) => [b] -> b
17:19:24 <Cale> http://en.wikibooks.org/wiki/Haskell/Laziness_revisited -- I added some text here, probably some other people could give great examples and reasoning too
18:21:21 <tato_> is it possible to statically link wxhaskell apps?
18:21:42 <Cale> Is it possible to dynamically link them?
18:22:58 <petekaz> Cale: I just read your laziness blurb, I like it.
18:23:14 <newsham> root@discover# ldd a.out
18:23:14 <newsham>         linux-gate.so.1 =>  (0x0077f000)
18:23:16 <sethk> I'm going to read it someday, when I need to  :)
18:23:18 <newsham> appears to be...
18:23:39 <newsham> looks dynamically linked to me
18:24:25 <tato_> obviously you can dynamically link it...
18:25:08 <tato_> but ghc -optl-static --make HelloWorld.hs is giving me:
18:25:14 <tato_> /usr/lib/gcc-lib/i486-slackware-linux/3.3.6/../../../../i486-slackware-linux/bin/ld: cannot find -lwxc-gtk2.6.3-0.9.4
18:25:17 <tato_> collect2: ld returned 1 exit status
18:26:25 <tato_> any ideas?
18:26:34 <hoan> nope ;)
18:35:06 <ihope> So it's just a coincidence that this one character in this one book series is called Don Bruce, right?
18:54:49 <dons> ihope?
20:22:01 <palomer> ok guys
20:22:06 <palomer> I've come up with a new polemerism
20:22:10 <palomer> palomerism
20:22:12 <palomer> are you guys ready?
20:22:25 <Pseudonym> Always.
20:25:31 <Pseudonym> Well, even if nobody else is ready...
20:26:08 <dropdrive> I'm ready.
20:26:16 <Dino_> Me too.
20:26:27 <dropdrive> I'm not sure what could top what he (she?) said about Paris Hilton.
20:30:30 <dropdrive> I'm not sure what could top what he (she?) said about Paris Hilton.
20:30:38 <dropdrive> oops! (sorry)
20:30:50 <Pseudonym> That's okay, it was funnier the second time.
20:37:47 <palomer> I'm not sure what could top what he (she?) said about Paris Hilton.
20:37:59 <palomer> anyways, the palomerism is:
20:38:01 <palomer> shazam!
20:39:26 * palomer waits for an applause
20:39:30 <Dino_> heh. I remember a super crappy TV show from the 70s by that name.
20:39:50 <Pseudonym> Me too.
20:40:02 <Pseudonym> Yay for 70s saturday morning cartoons!
20:40:18 <Spark> luckily i was born after the 70s
20:40:24 <Spark> allowed me to maintain a state of vague sanity
20:40:31 <Dino_> I think that one was actually live-action, the Shazam!
20:41:59 <Pseudonym> http://www.imdb.com/title/tt0071050/ <- This is the one you're thinking of, I assume.
20:42:15 <Pseudonym> http://www.imdb.com/title/tt0448115/ <- This is a truly frightening thought.
20:43:04 <Pseudonym> Hmmm.
20:43:09 <Pseudonym> I'm sure I remember a cartoon.
20:44:07 <Dino_> There probably was a cartoon as well at some point. They cartooned everything. Anybody remember that Mr. T cartoon? :o  I'm scaring myself now.
20:44:27 <Pseudonym> http://www.imdb.com/title/tt0210425/ <- This must be what I recall.
21:10:31 <thetallguy> @uptime
21:10:32 <lambdabot> uptime: 2 days, 44 minutes and 6 seconds
21:11:39 <ptolomy> man, I've been working on my toy compiler in Haskell for the past day or two, then I looked at a couple compilers written in C for inspiration. So painful looking..
21:11:39 <satan> how does one denote Infinity in Haskell?
21:13:08 <thetallguy> [1..]
21:13:15 <Korollary> as in +Inf for float/double? 
21:13:16 <thetallguy> ?
21:14:19 <satan> yes, for float or double
21:14:29 <ptolomy> > Data.List.last [1..]
21:14:33 <lambdabot> Terminated
21:14:52 <ptolomy> > (head . reverse) [1..]
21:14:56 <lambdabot> Terminated
21:15:04 <ptolomy> aww. infinity is hard to count to.
21:15:05 <thetallguy> @type isInfinite
21:15:06 <lambdabot> forall a. (RealFloat a) => a -> Bool
21:15:11 <satan> maybe i dont need it, i just want a good initial value to compare for a minimum function
21:15:17 <satan> to find the minimum of a list, i mean
21:15:36 <thetallguy> Use the first element of the list.
21:16:17 <satan> as the stopping case?
21:16:26 <thetallguy> sure
21:16:54 <thetallguy> You want to scan the list and find the minimum value, right?
21:17:02 <satan> yes
21:18:05 <thetallguy> let xs = [0,-20,40,-100,1] in foldr min (head xs) (tail xs)
21:18:18 <thetallguy> Have to catch [], of course
21:18:40 <satan> ok
21:18:44 <thetallguy> leaves infinity out of the equation
21:19:09 <thetallguy> More general, too.
21:19:37 <satan> cool, lemme try it, thanks
21:19:47 <thetallguy> If you had to provide a value that was less than any value in the type...
21:19:52 <thetallguy> you would have to do that for all types.
21:20:08 <thetallguy> This way, all you need is (Ord a) =>
21:20:09 <ptolomy> I always just end up using 'minimum'.
21:20:12 <satan> right
21:20:17 <thetallguy> @type min
21:20:18 <lambdabot> forall a. (Ord a) => a -> a -> a
21:20:44 <ptolomy> @type minimum
21:20:46 <lambdabot> forall a. (Ord a) => [a] -> a
21:21:09 <Korollary> also see the "..1" versions of foldl (foldl1), which already use the first element.
21:22:39 <urz_> damn
21:22:56 <urz_> im doing functional reactive programming
21:22:57 <lorne> MUTT
21:23:08 <lorne> erh, must have hit a wrong button somewhere, sorry
21:23:28 <urz_> i got a system with a bouncing ball
21:24:33 <urz_> but the bouncing ball update is simply a function that converts a ballstate to a new ballstate periodically
21:25:04 <urz_> and i want to break into more signal functions and signals
21:25:36 <urz_> i cant believe how hard this is
21:25:37 <urz_> heh
21:26:15 <palomer> GIRAFFE
21:26:21 <palomer> woops, I hit the giraffe button
21:27:14 <palomer> my bad
21:28:24 <SamB> lorne: two wrong buttons!
21:28:36 <SamB> you do not need to hit capslock to type "mutt"
21:29:57 <lorne> Instead of `C-a c mutt' I must have hit `C-a Caps z mutt'
21:30:17 <palomer> are you calling me a mutt?
21:30:22 <Korollary> @palomer
21:30:22 <lambdabot> Pfft
21:30:41 <SamB> palomer: no, I think lorne is stuck in Emacs
21:31:32 <lorne> emacs? not currently. screen!
21:32:16 <Korollary> screen + emacs = good
21:32:33 <Korollary> @seen Lemmih
21:32:34 <lambdabot> I saw Lemmih leaving #haskell 7 hours, 36 minutes and 43 seconds ago, and .
21:36:55 <Korollary> hey mathewm 
21:37:06 <mathewm> heya
21:37:11 <Korollary> @seen mathewm
21:37:11 <lambdabot> mathewm is in #haskell. I last heard mathewm speak 4 seconds ago.
21:38:24 * palomer kicks maple in the groin
21:38:36 <mathewm> heh
21:38:47 <mathewm> what did maple do to you?
21:39:47 <Korollary> @palomer
21:39:47 <lambdabot> Category theory is the Paris Hilton of mathematics
21:40:15 <palomer> maple is being silly
21:40:16 * mathewm cackles!
21:40:23 <mathewm> @palomer
21:40:23 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
21:40:34 <mathewm> :)
21:40:51 <Korollary> Ooh. Cheney is going to be on tv in 20 minutes. Frontline.
21:40:54 <Korollary> err
21:40:56 <Korollary> It's about Cheney
21:55:26 <mathewm> @palomer
21:55:27 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
21:55:59 <Korollary> @keal
21:56:00 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
21:57:55 <Pseudonym> @girl19
21:58:21 <lambdabot> I have been into not actually hacking, but social engineering
21:58:32 <Pseudonym> @yhjulwwiefzojcbxybbruweejw
21:58:32 <lambdabot> "\""
21:58:35 <Pseudonym> @yhjulwwiefzojcbxybbruweejw
21:58:35 <lambdabot> "\"#$%&'()*+,\""
21:58:39 <Pseudonym> @yhjulwwiefzojcbxybbruweejw
21:58:39 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
21:58:50 <Pseudonym> I wonder what that dows.
21:58:53 <Pseudonym> does
21:58:55 <Pseudonym> @b52s
21:58:56 <lambdabot> Girl from Ipanema, she goes to Greenland
21:58:59 <Pseudonym> @b52s
21:58:59 <lambdabot> Watch out for that piranha. There goes a narwhale. HERE COMES A BIKINI WHALE!
21:59:08 <Pseudonym> @brain
21:59:09 <lambdabot> Well, I think so, Brain, but it's a miracle that this one grew back.
21:59:11 <Korollary> Does the 'v' thing still work?
21:59:17 <Pseudonym> I don't think so.
21:59:22 <Pseudonym> Anyway, gotta go.
21:59:23 <Pseudonym> Laboratory calls.
21:59:26 <Pseudonym> BBS hopefully.
21:59:28 <Korollary> ciao
22:02:54 <skew> Hi everybody. Has anyone here used Pango?
22:03:32 <skew> The Pango binding in gtk2hs seems to be missing any functions for figuring out which characters ended up in which GlyphItem
22:39:52 <sethk> dons, are you here?
23:56:18 <joelk> dons, I have a prototype BSRead class implemented for ByteString. still quite rough, but useful for me.
23:57:16 <joelk> implemented as: class BSRead a where bsReadS :: ByteString -> Maybe (a, B.ByteString)
23:59:23 <joelk> err... ignore that typo in the return type...
