00:03:58 <RyanT5000> the "parameter" is the thing in the function's declaraction, whereas the "argument" is the thing actually supplied for a parameter, right?
00:04:16 <RyanT5000> "argument" being a value, and "parameter" being part of a type
01:36:19 <Shapr> hello
01:37:14 <Igloo> You're looking very capital today, shapr
01:38:16 <Shapr> Why thank you. The xchat on maemo really likescaps in text fields.
01:39:13 <dons> capital indeed. quite capital.
01:39:31 <dons> Shapr: have you tried wmii? its quite a nice ^h^h capital replacement for ion
01:40:01 <dons> its a lot smaller, maybe 5k loc. almost doable to rewrite in hsakell... as 1k loc :)
01:40:04 <Shapr> I'm standing by the side of the road using some anonymous open wifi point.
01:40:13 <dons> hehe cool
01:45:43 <shapr> Ahem, anyone have google talk installed?
01:47:04 <Muad_Dibber> shapr, at home I do. Here I just use Gaim for it
02:16:02 <pesco> Hrng. wmii. Must resist... urge...
02:16:15 * pesco hastily switches to another workspace.
02:19:36 <Itkovian> boegel?
02:19:46 <Itkovian> I feel like the ball is too high
02:20:52 <boegel> Itkovian: you've probably inflated it too much then
02:20:58 <boegel> are you still sitting on it?
02:21:01 <Itkovian> i haven't inflated it at all
02:21:16 <boegel> hey, you're as tall as I am, so it should be fine
02:21:28 <Itkovian> my calves do hurt though
02:21:34 <boegel> calves?
02:21:39 <Itkovian> (kuiten?)
02:21:46 <boegel> they do?
02:21:53 <Itkovian> yeah
02:21:57 <boegel> well, you will be in pain the first few hours/days you sit on it
02:22:06 <Itkovian> my back also hurts a bit, but it's getting better now
02:22:08 <boegel> your body has to come used to it you know :) train those mucles :)
02:22:20 <Itkovian> how much can I wigle on it?
02:22:24 <Itkovian> wiggle
02:22:48 <boegel> as long as you don't fall off, as much as you like :)
02:22:49 <Itkovian> shit I thought this was #-blah
02:22:55 <Itkovian> sorry folks
02:23:00 <boegel> I often bounce on it to concentrate
02:23:03 * boegel moves there too
02:30:13 <norpan> @seen dons
02:30:13 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 50 minutes ago.
02:30:33 <norpan> dons: re lazy unpack on bytestrings, i did this for my UTF-8 version
02:30:45 <norpan> http://norpan.org/~martin/fps/Data/ByteString/UTF8.hs
02:30:57 <Igloo> Did dons write a Haskell shell, or am I imagining it?
02:32:00 <Igloo> n/m, got it
02:34:38 <dons> h4sh
02:34:43 <dons> norpan: cheers
02:34:47 <dons> sjanssen: see above ^^
02:38:26 <norpan> unsafeInterleaveIO and touchForeignPtr for good measure
03:51:14 <df_> @version
03:51:15 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
03:51:15 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:05:02 <ezraburgh> @hoogle (a, b) -> c
05:05:03 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
05:05:04 <lambdabot> Prelude.fst :: (a, b) -> a
05:05:04 <lambdabot> Prelude.snd :: (a, b) -> b
05:07:16 <ezraburgh> @hoogle a -> b -> c
05:07:18 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
05:07:18 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
05:07:18 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c -> c) -> c -> m (gr a b) -> m c
05:31:28 <glauber_sp> hi guys. I need to write a theorem in a latex document, and it starts with an enumerated env. How do I make latex put the 1.bla bla bla in a new line (not in front of Definition 1.1(name).)?
05:31:58 <ndm> glauber_sp: you're probably best of asking in #latex
05:32:33 <glauber_sp> ndm, I know. I asked, no one answers this. I guess it's to math-related  ehehhe
05:33:01 <ndm> glauber_sp: Latex is too hard, I guess lots of people in here know it, but no one ever knows the details :)
05:34:42 <Igloo> Try putting things like \null, \leavevmode etc in
05:35:06 <glauber_sp> Igloo, I'll try =)
05:35:33 <norpan> wow, what a society we live in
05:35:38 <norpan> everyone is on file on the internet
05:39:46 <glauber_sp> Igloo, thanks. \leavevmode works =)
05:44:40 <vincenz> what happened to HWN?
05:45:08 <Guest1703> oh im here
05:45:11 <Guest1703> hey anyone here
05:45:31 <IainFraser> thats better
05:45:51 <IainFraser> hi, ive been asked to develope a simple dbms at work for pockets pcs
05:45:54 <vincenz> ignore me
05:46:10 <IainFraser> ive done some work on haskell at uni, so I thought why not give it a try
05:46:22 <IainFraser> too much C++ code for my head at the moment on this project
05:46:40 <IainFraser> do you think this is a good idea?
05:47:06 <IainFraser> the searching,inserting and stuff is really easy todo , but the speed + file handling seems to be an issue
05:48:17 <vincenz> @tell dons Great work on the graphing of projects.  If I may make a small suggestion:  I would personally scale the vertical axis for all projects the same way so it is instantly visible what projects are bigger than others for a better overview.
05:48:18 <lambdabot> Consider it noted.
05:48:45 <vincenz> @join #oasis
05:50:39 <vincenz> IainFraser: Hmm.... erm I'm not sure what you're asking.
05:51:02 <vincenz> IainFraser: If you're asking whether it's a good fit for your project, then you'll have to provide a context, because "but the speed + file handling seems to be an issue" is very little information
05:51:16 <vincenz> IainFraser: I think most people will agree that in general, haskell is a good choice
05:51:26 <vincenz> erm, the people in this channel that is
05:52:47 <IainFraser> ok thanks mate
05:52:50 <IainFraser> sorry I was away then
05:53:02 <IainFraser> I just keep running into little issues that are annoying me
05:53:09 <IainFraser> like I want to write a simple function to output a table
05:53:23 <IainFraser> but how do I do that, so that it looks like a table in dos
05:53:40 <IainFraser> I think im probably too much of a newbie
05:53:49 <IainFraser> do any of you know of any practical tutorials
05:53:53 <vincenz> IainFraser: well you can generate the string first and then putstr it
05:53:59 <vincenz> IainFraser: I much liked yaht
05:54:01 <vincenz> @where yaht
05:54:02 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
05:54:33 <vincenz> IainFraser: I would decouple the generation of the table from the actual outputting
05:55:08 <IainFraser> the thing is I can do the evaulation stuff which why I want to use haskell
05:55:28 <IainFraser> its just "practical" things like output, surely this needs to imperative
05:55:31 <IainFraser> ill give you an example
05:55:42 <IainFraser> thanks for the help, I know I must seem like such a noob
05:55:54 <IainFraser> |Field Name| Field Name 2|
05:56:10 <IainFraser> but where the right '|' occurs must the longest string in the table
05:56:17 <IainFraser> how can I calculate pixel length and stuff like that
05:56:33 <vincenz> I don't understand "pixel length"
05:56:58 <vincenz> IainFraser: you can first find the maximum length and then use that to generate enough whitespace
05:57:10 <vincenz> let me cook up a small example
05:57:55 <IainFraser> thank-you very much
05:58:05 <IainFraser> I can really see the beauty of haskell and im trying to get good at it
05:58:14 <ndm> IainFraser: assuming you have a list of lists as the data structure [[String]] with each row as a [String]
05:58:21 <IainFraser> ya thats what im doing
05:58:25 <ndm> display one thing first:
05:58:38 <ndm> you really want the max length of each column
05:58:47 <ndm> maxLen [] = []
05:59:07 <IainFraser> yup
05:59:42 <IainFraser> but aren't some characters bigger than others
05:59:45 <IainFraser> ill try that though
06:00:47 <ndm> maxLen :: [[String]] -> [Int]
06:00:49 <ndm> maxLen xs@(x:_) = [maximum $ map (length . (!! n)) xs   | n <- 0..length x-1]
06:00:56 <ndm> that should do it, assuming a square
06:01:13 <ndm> IainFraser: in a DOS window, no, all characters are the same width
06:01:19 <IainFraser> wicked
06:01:34 <ndm> that just gives you the width of each column, you can then use that to output it relatively easily
06:01:49 <ndm> and don't be fooled into thinking thats good or fast code :) - or even working - I haven't tried
06:01:50 <IainFraser> nice work my man, just make a function padstring yeah!
06:04:19 <int-e> ndm: uh. maxLen l = maximum $ map length l
06:04:58 <int-e> no?
06:05:03 <ndm> int-e, I guess they are stored in Rows [Columns] order of list, so that won't work
06:05:10 <kpreid> > let pad n s = take n (s ++ repeat ' ') in map (pad 2) ["a", "bb", "ccc"]
06:05:11 <lambdabot>  ["a ","bb","cc"]
06:05:23 <ndm> i.e. to get all the columns you have to (!! n) down all the lists
06:06:45 <int-e> ndm: well, then transpose first?
06:06:55 <ndm> int-e, yes, that might be easier :)
06:07:15 <dons> ?type Text.Printf.printf
06:07:16 <lambdabot> forall r. (PrintfType r) => String -> r
06:07:29 <IainFraser> wow this is getting complicated
06:07:33 <IainFraser> for me
06:07:35 <dons> remember there's a printf function as well.
06:07:36 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
06:07:47 <int-e> (Data.List.transpose is better than mapping with (!!n))
06:08:00 <IainFraser> right ok, im gonna go off and try write my own maxstring 
06:08:07 <vincenz> int-e: nearly done
06:08:09 <dons> and it shouldn't be too hard to get decent io performance with ghc and -O
06:08:14 <IainFraser> as I couldn't get yours to work, and I didn't really understand some of the wymbols
06:09:46 <int-e> > maximum $ map length ["abc", "defghik", "b"]
06:09:48 <lambdabot>  7
06:09:48 <vincenz> http://rafb.net/paste/results/JQXJB336.html
06:09:50 <vincenz> there you go
06:09:55 <vincenz> that will do the tabulation
06:10:39 <vincenz> dons: got my tell/
06:10:56 <int-e> > let maxLen l = maximum $ map length l; pad len s = take len $ s ++ repeat ' '; padAll l = map (pad (maxLen l)) l in padAll ["abc", "defghik", "b"]
06:10:58 <lambdabot>  ["abc    ","defghik","b      "]
06:11:16 <vincenz> @type maximum
06:11:17 <lambdabot> forall a. (Ord a) => [a] -> a
06:11:19 <vincenz> doh
06:13:32 <vincenz> cleaned up version http://rafb.net/paste/results/bnqETk15.html
06:14:52 <vincenz> IainFraser: try that
06:15:02 <IainFraser> cheers
06:15:14 <vincenz> is it clear?
06:16:58 <bolrod> > "abcddd" > "bacddd"
06:17:00 <lambdabot>  False
06:17:27 <IainFraser> nice work, im just trying to understand it now
06:17:32 <IainFraser> but that is really userful thanks
06:17:56 <vincenz> I tried to keep it as clean as possible
06:19:36 <ndm> vincenz: (++ "\n") . concat . intersperse "\n" === unlines ?
06:19:46 <ndm> looks similar
06:20:03 <vincenz> ndm: good point
06:20:15 <vincenz> ndm: though unlines does not add extra "\n" afaik
06:20:17 <vincenz> des it?
06:20:29 <ndm> > unlines ["test","test"]
06:20:31 <lambdabot>  "test\ntest\n"
06:20:34 <vincenz> aha :)
06:20:39 <vincenz> thx
06:20:50 <vincenz> that cleans it
06:21:39 <ndm> vincenz: even if it didn't, putStr . (++) "\n" === putStrLn
06:21:50 <vincenz> ndm: good point :D
06:22:01 <vincenz> ndm: I guess this is a good argument for pairprogramming
06:22:38 <ndm> vincenz: I also noticed you did: maximum . map length $ xs , when maximum $ map length xs  is equivalent, but less operators
06:22:43 <dons> > let s = ["abc", "defghik", "b"] ; l = show . maximum . map length $ s; in concat (map (printf ("%-"++l++"s")) s) ++ "\n"
06:22:44 <ndm> vincenz: i agree, pair programming is handy
06:22:45 <lambdabot>  "abc    defghikb      \n"
06:23:13 <vincenz> ndm: yeah but I tend to go for $ on the value
06:23:20 <Stinger_> pair programming, are you refering to the xtreme programming model?
06:23:21 <vincenz> ndm: that's just my style
06:23:24 <vincenz> ndm: easier to modify
06:23:26 <ndm> vincenz: yeah, i noticed - i tend to do $ everywhere
06:23:38 <vincenz> ndm: I find $ less readable... usually I start with $ and then refactor to .
06:23:47 <ndm> but i would have made tabulate points free, i.e. no mention of vals, and no $
06:24:00 <vincenz> good point, but itw as for a newb
06:25:34 <ndm> vincenz: yes, newbie style is quite different :)
06:25:52 <int-e> a (b (c (d x)))
06:26:32 <vincenz> :D
06:26:45 <vincenz> int-e: I've been arguing for . and $ for types
06:26:57 <vincenz> int-e: when using monads and transformers, that would rock
06:31:18 <norpan> at least .
06:31:23 <norpan> $ is not that much use
06:32:51 <Cale> ndm: (f . g . h $ x) is nice style for refactoring, since f . g . h is meaningful on its own, but f $ g $ h isn't.
06:33:20 <norpan> (f . g . h) x
06:33:23 <norpan> you don't need $
06:34:01 <int-e> > map ($ 2) [id, (2*), succ]
06:34:03 <lambdabot>  [2,4,3]
06:34:11 <Cale> sure, you don't need it, but I find it convenient to use $ there
06:34:16 <int-e> it's not completely useless
06:34:36 <norpan> > map (flip id 2) [id, (2*), succ]
06:34:37 <lambdabot>  [2,4,3]
06:34:54 <Cale> Since usually at that point, I won't want to go back and add the '(' at the start.
06:34:56 <ndm> does anyone have any experience with GHC's Rules?
06:35:01 <norpan> for functions i agree $ is good
06:35:02 <int-e> I know, but I don't think  flip id  is that intuitive
06:35:16 <Cale> hehe
06:35:30 <Cale> ($ 2) is definitely clearer
06:35:46 <Cale> That's one reason why it's good to have $ around.
06:35:47 <int-e> dons might have a little experience with that *ducks*
06:35:52 <ndm> I have added some rules, but whne I run with -ddump-rules it doesn't list any
06:35:54 <Cale> (for representing application)
06:36:06 <ndm> compiling with -O
06:36:06 <int-e> did you add -O?
06:36:10 <Cale> It does sort of have the wrong associativity though
06:36:15 <dons> ndm, yeah. i've used some rules
06:36:19 <dons> -ddump-rules is broken
06:36:24 <dons> use -ddump-simpl-iterations
06:36:25 <ndm> ah, what do I do instead?
06:36:27 <dons> and -ddump-simpl-stats
06:36:33 <dons> the latter if you don't want to read core
06:36:57 <ndm> dons, thanks, thats exactly it :)
06:37:18 <IainFraser> yo thanks for the help
06:37:30 <IainFraser> I was wondering if ive got a list in a list e.g. [[String]]
06:37:38 <IainFraser> how can I access the strings in a functions e.g.
06:37:42 <ndm> dons, any way to turn off all rules apart from mine?
06:37:47 <dons> ndm, also, its a good idea to quick check your rules (they translate directly into QC properties)
06:37:50 <ndm> i.e. stop the GHC inbuilt ones fifriing
06:37:51 <dons> nope
06:37:57 <ndm> :(
06:38:00 <dons> only things you've got are -frules-off
06:38:05 <IainFraser> getstring :: [[String]]->Int->String
06:38:07 <dons> though this would be a useful flag
06:38:15 <IainFraser> how would I get the 3rd string in the first string array
06:38:19 <ndm> dons, the RHS of all my rules is error, so I think quickcheck will fail :)
06:38:28 <MarcWebe1> If I want to distribute an executable to a friend who hasn't ghc installed. Is it enough to compile with -static flag?
06:38:29 <norpan> IainFraser: what would the int do? something like concat xs !! n?
06:38:34 <IainFraser> getstring (x:xs) y = 
06:38:37 <dons> hmm! ndm plays some games eh?
06:38:44 <ndm> MarcWebe1: or just compile, its always static
06:38:47 <IainFraser> oh yeah sorry the y is the element in the inner string array
06:38:48 <IainFraser> e.g.
06:38:55 <dons> RULE forall f . f False = True ? ;)
06:39:03 <IainFraser> [ ["Iain","Fraser"], ["Matt","marriott"]]
06:39:04 <MarcWebe1> ndm: He gets an error about loading shared libs
06:39:13 <ndm> dons, I have a cunning plan - if you write some rewriting rules like concat (map f x) = error "use concatMap"
06:39:21 <dons> hehe
06:39:24 <ndm> then by looking at the rules fired, it gives you a list of good code refactorings
06:39:29 <IainFraser> getstring [["iain","fraser"],["matt","marriott"]] 2
06:39:33 <IainFraser> would return "fraser"
06:39:37 <IainFraser> just intrested in the first row
06:39:46 <IainFraser> but the 2 would represent second string in first row
06:39:46 <dons> or just rewrite it to concatMap, and emit a trace msg?
06:39:46 <norpan> so you want head xs !! n then
06:39:50 <dons> its a cool idea though.
06:39:50 <IainFraser> therfore "fraser"
06:40:01 <norpan> or head xs !! (n-1) in this case
06:40:07 <dons> and with -fno-code it would even be a useful lambdabot tool!
06:40:07 <IainFraser> urm
06:40:14 <IainFraser> ok sorry what is the !! operator?
06:40:16 <ndm> dons, yep, could be a good tool
06:40:18 <dons> ndm, I like this idea muchly
06:40:20 <norpan> !! is indexing in lists
06:40:25 <ndm> although GHC might break it, with inlining things
06:40:34 <norpan> > ["a","b","c"] !! 1
06:40:35 <lambdabot>  "b"
06:40:41 <IainFraser> ok wicked so it starts at 0
06:40:42 <IainFraser> nice one
06:40:43 <dons> all you need to do is not rewrite it at all, but just extract the rule name when it fires
06:40:47 <ndm> the other option is to write a special tool separately, identifying folds and maps/filters as well, and improving them
06:41:08 <ndm> yep, the rewrite rule is irrelevant, its just a template to match things
06:41:19 <norpan> yes, it's wicked
06:41:20 <dons> ghc-refactor would just call ghc -ddump-simpl, and pull out any rules that fire as suggested refactorings
06:41:24 <IainFraser> ya I could do it with 2 functions i.e. (x:xs) then pass x to a function wich takes [String]
06:41:28 <IainFraser> but that is a bit tedious
06:41:28 <norpan> but in computer science you always start counting at 0
06:41:36 <cjay> not in lua :)
06:41:39 <IainFraser> ya don't worry im not a newb at computer science
06:41:44 <Cale> "always"
06:41:45 <Cale> hehe
06:41:50 <IainFraser> ive been programming C++ for 8 years
06:41:50 <ndm> yep, that would be neat, unfortunately i'm not sure ghc is useable for that...
06:41:55 <dons> ndm, got a darcs repo?
06:41:56 <norpan> always, with a few modifications of course
06:42:03 <dons> i might have a hack at this tomorrow
06:42:06 <ndm> dons, I've only just started hacking
06:42:10 <IainFraser> ok cheers ill try that !! operator
06:42:12 <ndm> and probably won't take it anywhere :(
06:42:14 <norpan> IainFraser: yes, that's what "head" does
06:42:24 <dons> we could steal the refactorings from HaRe
06:42:34 <dons> and get a preset lib of good transforms
06:42:34 <ndm> dons, that was my plan too :)
06:42:46 <dons> and there's extra ones in lambdabot's Pl module
06:42:54 <dons> (like arrows)
06:42:59 <ndm> although i think most refactoring would be more of the form replace these functions with one single one
06:43:13 <ndm> i.e. concatMap, map f . map g etc
06:43:25 <ndm> since often peoples code is too long because they don't know of these functions
06:43:35 <dons> map f . map g == map (f.g) ;)
06:43:47 <earthy> prove it!
06:43:52 <earthy> ;)
06:44:09 <Cale> earthy: If that property failed, we'd redefine map ;)
06:44:13 * earthy grins
06:44:31 <dons> $ runhaskell FusionProperties.hs 
06:44:37 <dons> map/map       list       : OK, 100 tests.
06:44:39 <int-e> @pl \x -> map f (map g x)
06:44:39 <lambdabot> map (f . g)
06:44:40 <dons> :)
06:44:47 <Cale> I sort of think Haskell needs something better-defined than GHC's rules.]
06:44:50 <int-e> @pl \x -> fmap f (fmap g x)
06:44:50 * dons is writing a paper on this stuff :P
06:44:50 <lambdabot> fmap (f . g)
06:44:57 <earthy> ;)
06:45:03 <Cale> There should be something in the language spec which allows for code transformations.
06:45:06 <int-e> now that's dangerous stuff :)
06:45:10 <dons> Cale, they're called RULES :)
06:45:26 <Cale> dons: Yes, those are pragmas
06:46:00 <dons> let's all sing: "rules are great, rules are cool. if you get them wrong, your code's just goo"
06:46:00 <Cale> But something which is actually part of the language, rather than something which relies on GHC's particular implementation mechanism.
06:46:07 <ndm> Cale: I somehow don't think Yhc would want to support RULES
06:46:19 <ndm> dons, then you need a Haskell proof system
06:46:24 <Cale> ndm: At least not something compatible
06:46:25 <ndm> which would make a good PhD
06:46:30 <vincenz> dons: did you see my @tell?
06:46:46 <dons> right. you either need to hook the rules into QuickCheck, or in the longer term, into Isabelle.
06:46:58 <dons> there's a undergrad honours thesis here at unsw for anyone who wants to work on that.
06:47:02 <Cale> Well, proofs would be something else
06:47:16 <ndm> dons, or add a GHC check -fcheckrules which generates both, and at runtime compares them - that should catch most bugs
06:47:45 <dons> yeah, i've thought about generating QC properties mechanically from rules, since its about 8 chars of sed to do so.
06:47:52 <dons> that'd at least keep the properties and the rules in sync
06:47:53 <Cale> But some meaningful way to arrange for code rewriting, (under the assumption that the human has a proof) would be useful.
06:47:56 <ndm> yeah, thats a very good idea
06:48:24 <dons> ndm, also, you'll want to get a ghc 6.5 if you're doing much rule hacking
06:48:34 <dons> the matching has greatly improved in the last few weeks
06:48:38 <ndm> dons, I probably won't have time, too much else on :(
06:48:48 <ndm> my PhD thingy is wanting attention (as always)
06:48:49 <Cale> RULES seems a little too hackish -- especially with the phase control stuff there.
06:49:00 <vincenz> anyone knnow the proper term for "lexical top-down scoping"
06:49:15 <dons> Cale, its a but fragile, but not too bad. you can imagine a compiler built from scratch with extensible rewrite rules support though
06:49:53 <ndm> dons, you get the feeling such a compiler wouldn't terminate that often...
06:50:35 <ndm> although i did consider such a compiler, which included rewrite rules for things like list comprehensions, case matches, pattern matches etc.
06:50:52 <ndm> so basically all the complex haskell stuff was in the rules, and the compiler just applies them
06:51:02 <ndm> and they confluence at a Core haskell language
06:51:15 <Cale> Perhaps there's a more declarative way to provide for such optimisations.
06:51:48 <vincenz> Anyone?
06:51:52 <dons> more declarative than: forall a b c . f a b c = g a b c?
06:51:52 <ndm> if you had backtracking on rules, and non-determinism, that might give you more power
06:52:02 <dons> backtracking. hmm.
06:52:05 <Cale> dons: Well, which way is that read?
06:52:15 <dons> lhs is transformed to rhs
06:52:23 <Cale> dons: right
06:52:32 <dons> ah.
06:52:51 <Philippa> would it be fair to characterise pure functions including those in an impredicative setting as "those that can be trivially represented as functions in naive set theory"?
06:52:57 <int-e> more power isn't necessarily a good thing
06:53:15 <ndm> int-e: unless it comes to type systems ;)
06:53:17 <Cale> Philippa: I think so
06:53:28 <Cale> Philippa: If you think of types as sets
06:53:40 <Cale> of course, they're not all such functions
06:54:11 <Cale> Most of the set-theoretic functions Integer -> Integer are not representable.
06:54:27 <int-e> is 'trivially representable' a well-defined terminology?
06:54:37 <Cale> Or even Integer -> Bool, for that matter :)
06:54:44 <Philippa> how many of those're (modulo termination) computable?
06:54:51 <Cale> int-e: no, but I know what she means :)
06:54:54 <int-e> countably many
06:55:06 <Philippa> int-e: somewhat. It implies not having to do any real work to build the representation - "it's obvious"
06:55:27 <Philippa> whereas you have to do some heavy lifting somewhere to represent "nuke the president" as a function
06:55:43 <Cale> We could model Haskell in set theory as a mechanism for defining set functions.
06:55:46 <dons> ndm, yeah, you need the default list rules turned off, don't you?
06:55:51 <Philippa> (assuming the action of nuking the president rather than the string, of course)
06:56:01 <ndm> dons, definately - otherwise foldr/build fires too much :)
06:56:08 <dons> right. just noticed that .
06:56:25 <dons> not sure we can do anything about that without hacking ghc.
06:56:26 <ndm> you also (ideally) want to turn off inlining
06:56:39 <dons> unless we can get our rules to run in phase -1
06:56:50 <ndm> dons, right - and ghc won't catch a map defined by explicit recursion
06:57:00 <ndm> or a foldr
06:57:14 <Cale> Philippa: we're sort of assuming that IO t isn't really representable as a set...
06:57:45 <int-e> hmm? IO t isn't that bad, it's just descriptions of world actions
06:57:49 <Cale> right
06:57:58 <Cale> But we're specifically excluding it :)
06:58:04 <Philippa> nah, just that introducing a universe-state set and various other needed mechanisms is "work"
06:58:24 <Philippa> once you have that, functions on that set're still trivially pure
06:58:34 <Cale> Well, it depends on how you picture the arrows a -> IO b
06:59:04 <Philippa> it seems to me that it's bind that's the funky bit
06:59:06 <Cale> There's a somewhat nice yet somewhat annoying duality here.
06:59:10 <Philippa> yep
06:59:19 <int-e> IO t is a string, >>= is basically string concatenation. :)
06:59:22 <Philippa> I'll be wrestling with it once I grok internal category theory sufficiently
06:59:24 <Cale> In defining the word "pure"
06:59:44 <Philippa> it's pure, right up until the president actually gets nuked?
06:59:51 <int-e> if we ignore enough of the underlying meaning of IO actions, it becomes representable.
06:59:51 <Cale> Really, the "impure" functions are the ones in the Kleisli category for IO over the category of Haskell types.
07:00:04 <int-e> (I think)
07:00:08 <Cale> But we never work with those directly (or almost never)
07:00:31 <Cale> We work with (pure) functions a -> IO b, and we think of them as the Kleisli arrows a -> b
07:00:44 <Philippa> anyway, the original question is because I'd been geeking on afp and now I think someone'd like an explanation of WTF I've been talking about
07:00:55 <Philippa> yep
07:01:05 <Cale> afp?
07:01:09 <Philippa> alt.fan.pratchett
07:01:12 <Cale> aha
07:01:30 <vincenz> (15:48:45) vincenz: anyone knnow the proper term for "lexical top-down scoping"
07:01:53 <Philippa> could you clarify "top-down"?
07:02:02 <int-e> Philippa: ok, you're glossing over the whole computability stuff but you probably don't need that anyway.
07:02:03 <vincenz> Philippa: ml style
07:02:07 <vincenz> Philippa: with shadowing
07:02:09 <Cale> So really whether you consider a function a -> IO b pure or not comes down to how exactly you're thinking about it.
07:02:13 <vincenz> Philippa: instead of toplevel recursive
07:02:29 <Philippa> ah
07:02:38 <Philippa> see, I'm tempted to use a variant of a four-letter word ;-)
07:02:57 <dons> ndm, yeah, i think the problem is going to be getting the rules to match consistently
07:03:08 <dons> however, a new tool based on this model would be pretty spiffy
07:03:16 <ndm> dons, indeed, but yes, a new tool is the way to do it
07:03:22 <Philippa> Cale: yup, I'm aware of this. I'm probably going to end up explaining it in a bit while detailing how you can do anything useful with a pure FPL...
07:03:29 <ndm> with a user specifiable list of equivalences, to make it easy to add to
07:03:33 <dons> right.
07:03:39 <Philippa> I *think* it was the same post I mentioned internal category theory in, too
07:03:41 <ndm> and a basic notion of . and $ equivalences and points free
07:04:16 <dons> in fact, lambdabot sort of started down this route, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Pl/Rules.hs
07:04:36 <Philippa> which goes back to the old "can we have a language where application for ordinary functions and monads is the same thing and thus equally analysable"
07:04:41 <Cale> Philippa: What does this have to do with Pratchett?
07:04:55 <Philippa> about as much as most conversation on afp. It's a group in which the fandom hangs out
07:05:02 <Cale> ah, okay
07:05:10 <ndm> dons, exactly what does that module do?
07:05:12 <Philippa> oh, and some old fart in a hat
07:05:22 <dons> that's the rewrite engine and rules for @pl
07:05:42 <dons> it takes a representation of lhs and rhs, and applies it to an ast
07:05:51 <ndm> ok, the problem is pl transformations are generally getting more complex
07:06:04 <ndm> but should definately appear for some reduced cases - not the full list
07:06:38 <int-e> the pl rules aren't all sound either.
07:06:48 <dons> it makes me think though that a decent refactoring tool, useable for the masses, would be doable with not too much work though
07:06:58 <dons> unlike HaRe, which is too heavy for anyone, i think
07:07:15 <ndm> dons, automatic is the important point
07:07:18 <int-e> (I can't name one in particular because I never looked at them, but occasionally pl produces code that doesn't typecheck from code that does)
07:07:21 <ndm> i.e. suggests refactorings
07:07:39 <dons> just start with a set of rules that can be quick checked, and the ast rewriter, and then pop out some things that could be done.
07:07:42 <ndm> users are all too lazy for anything else :)
07:07:52 <dons> yeah, keep it simple
07:08:19 <ndm> the infrastructure - ast format, ast rewriter are the hard bits
07:08:22 <ndm> rule rewritings are easy
07:08:24 <dons> int-e, right. its purely syntactic matching.
07:08:42 <dons> we'd want the same guarantees as RULEs i.e. lhs and rhs at least need to have the same type
07:09:01 <dons> ndm, well, a normal Haskell ast though, wouldn't that be ok?
07:09:02 <ndm> dons, i disagree - adding type inference makes it unnecessarily complex
07:09:11 <ndm> dons, yep thats doable
07:09:18 <ndm> we probably need . and $ removal
07:09:26 <dons> well, perhaps, but you'd want to encourage people to ensure types are the same
07:09:28 <ndm> to put things in a more consistent form
07:09:39 <ndm> dons, perhaps the solution is to have an external rule style
07:09:41 <dons> right. there's some mechanics to matching 
07:09:47 <int-e> ndm: but it adds the complexity to the tool instead of the rules
07:09:57 <ndm> and then have checks on it, check the types, check with quickcheck
07:10:21 <dons> sounds like a job for ghc-api, ultimately
07:10:28 <dons> then you'd get type checking as well, with no hassle
07:10:44 <dons> and the full parser, which everyone wants these days
07:10:44 <ndm> true, although you really only need the parser for a first hack
07:11:17 <vincenz> hwo do you define an empty thing in BNF?
07:11:30 <vincenz> expressionlist ::= expressionlist ';' expression | nothign
07:11:34 * dons -> sleep
07:11:42 * ndm -> food
07:11:45 <Philippa> vincenz: there's a symbol (epsilon?) used for an empty string
07:11:50 <int-e> nothing ::=
07:12:20 * int-e shrugs. there are too many BNF dialects around.
07:12:34 <vincenz> And anyone know the term for the type of scoping that ml does
07:12:44 <vincenz> (top-down, lexical, non-recursive, with shadowing)
07:12:49 <vincenz> at the top-level
07:13:11 <Philippa> not off-hand
07:13:26 <Philippa> you could treat the top-level as a sequence such that the top-down part's "just" shadowing again though
07:14:08 <vincenz> yeah was just trying to differentiate between my language and ml
07:15:12 <IainFraser> is there a stringlenght function
07:15:20 <IainFraser> or do I have to iterate over the list?
07:15:20 <int-e> length
07:15:24 <int-e> strings are lists
07:15:24 <IainFraser> wicked cheers
07:15:34 <IainFraser> oh yeah of course
07:15:36 <IainFraser> what a noob
07:25:33 <IainFraser> I wan a function which is purely for rendering
07:25:50 <IainFraser> do I get it to return IO() because I don't want a return type
07:26:05 <sylvan> In "wearing the hair shirt" it says that "the next ml will be pure"... Where can I find more info on this?
07:26:27 <sylvan> IainFraser: , yes IO () are for actions which returns no result (but may do IO)
07:27:25 <IainFraser> sweet thank-you
07:27:31 <IainFraser> im really making progress thanks to you guys
07:36:07 <Cale> sylvan: I think that was a prediction rather than something based on any real project
07:36:29 <Cale> sylvan: It's an obvious thing to predict because monads are such a nice way to treat IO.
07:37:03 <Philippa> once you find them, they're almost obviously "the way to do it"
07:37:38 <Philippa> I don't think we'll find any related abstractions that aren't essentially more specific monads that're a better fit, assuming we're keeping purity
07:39:30 <sylvan> ah.. I was thinking there might be a prototype implementation somewhere...
07:39:55 <Philippa> I'm pretty sure I've written at least one interpreter for a language that was effectively "Core ML + case + monadic IO" or similar
07:40:01 <sylvan> I like purity, but it seems that the frequency of running into problems with laziness is too high atm, so I thought I'd give a strict purely functional language a try..
07:40:05 <Philippa> but I imagine you're after a bit more than that
07:40:09 <sylvan> yeah
07:40:17 <Cale> One thing I disagree with in the hair-shirt presentation is that he sort of plays down the importance of laziness.
07:40:31 <Philippa> you still need some laziness just for the >>= operation not to go crazy
07:40:58 <sylvan> I'm thinking Sweeney may be right in saying that lenient evaluation is the "right" compromise..
07:41:02 <Philippa> you can certainly have a really useful language that isn't lazy. I do find it useful fairly regularly though
07:41:05 <Cale> Laziness is actually a good part of the glue that makes functional programming really work well.
07:41:09 <sylvan> (although I disagreed passionately at the time)
07:41:22 <Philippa> personally I think better annotation for when you want strictness is the way to go
07:41:24 <Cale> Well, non-strict semantics anyway
07:41:40 <Philippa> seems a lot more plausible now we've discovered mdo and thus can generalise both let and letrec
07:41:42 <ndm> Philippa: you mean Clean
07:42:03 <dons> but these days haskell is strict and lazy, just like Clean
07:42:17 <dons> we have strict types, unboxed (and strict types), bang patterns, and so on
07:42:18 <Philippa> ndm: I'm not entirely sure whether I do or don't. I suspect I mean something a little different
07:42:25 <ndm> but Clean still has a better type system way of saying strict things
07:42:39 <ndm> i.e. you can say in the types is a lazy list with strict items
07:42:45 <Cale> Clean doesn't use monadic IO though, which is a downside, because the monadic framework is really cool.
07:42:47 <Philippa> yeah, that much is important
07:42:52 <sylvan> dons, yes but do we really want to litter our code with strictness annotations? seems somewhat ugly to me
07:43:09 <Philippa> so're laziness annotations
07:43:16 <ndm> Cale, but you can implement monadic IO easily enough, with classes and uniqueness types
07:43:19 <sylvan> yeah... but which occurs more often?
07:43:23 <Cale> I think it would be much cooler to get the compiler/runtime to the point where they're smart enough to work it out.
07:43:31 <sylvan> for me I *need* strictness more often than laziness...
07:43:33 <Philippa> when I'm first coding? Laziness, definitely
07:43:39 <sylvan> Cale, exactly
07:43:43 <dons> do we want to? no. usually the compiler gets it right. sometimes we need to provide hints. mostly though you'll just use libraries that do all the magic under the hood
07:43:44 <Cale> sylvan: quite the opposite for me
07:43:47 <Philippa> strict-by-default = failing to terminate more often by default
07:43:58 <Philippa> that's a good argument for laziness by default IMO
07:44:06 <Philippa> hell, you'd hate it if let were strict by default
07:44:14 <dons> so people use Unboxed arrays or strict bytestrings, and never need to litter the environment
07:44:27 <sylvan> wouldn't a non-strict eager evaluation be good enough for the vast majority of cases where you need laziness?
07:44:47 <int-e> what about sharing results?
07:44:50 <Philippa> I like my lazy-list-as-iterator pattern
07:45:01 <dons> anyway, with bang patterns, i'm happy. that's all the strictness i ever need, other than deep seq once every quadrennium
07:45:02 <Cale> sylvan: you mean something which might evaluate too much all the time?
07:45:33 <sylvan> Cale, I mean of the sort Sweeney proposes on lambda-the-ultimate every now and then =)
07:45:45 <sylvan> I'll see if I can find the message
07:45:47 <Cale> sylvan: I don't follow LtU very closely
07:45:59 * dons >>= (really . sleep)
07:46:01 <Cale> One of the major advantages of laziness is that it allows you to get reasonable performance from "stupid" algorithms
07:46:03 <sylvan> http://lists.seas.upenn.edu/pipermail/types-list/2004/000340.html
07:46:05 <lambdabot> Title: "[TYPES] Combining lazy and eager evaluation of terms"
07:46:25 <Philippa> Cale: no kidding, there was a really spectacular example in flippi after I fixed a case of too much string concatenation...
07:46:44 <Cale> It lets you combine already-written code in ways you'd have to consider ridiculous in a strict language.
07:46:47 <Philippa> at first glance, the "fix" appears to build up this huge buffer and do all sorts of stupid things with it
07:47:01 <Philippa> yeah, that kind of flexibility after the fact's important
07:47:32 <Cale> My favourite little example is  isSubstringOf
07:47:38 <int-e> dynamic programming with lazy evaluation is also fun
07:47:55 <Cale> isSubstringOf xs ys = any (isPrefixOf xs) (tails ys)
07:48:14 <kpreid> is it interesting that (=
07:48:16 <kpreid> oops
07:48:57 <Cale> That should look really dumb to a C programmer, or even an ML programmer.
07:49:07 <Cale> But in a lazy language it's fine.
07:49:36 <sylvan> No doubt laziness *is* useful, and hopefully compilers will be smart enough to find all the strictness of a program automatically in the future. But *right now*, I'm becoming more and more convinced that it's more trouble than it's worth if we had something like eager evaluation
07:49:57 <sylvan> sadly..
07:50:30 <Philippa> the outermost production in Flippi's wikitext grammar is "many lots of (if it's a known piece of markup, return Left <markup>, else take the first character and return Right <char>)", with a function converting the resulting list into text...
07:50:51 <Philippa> (and doing the Right bits without using ++ once per character)
07:51:00 <sylvan> (especially since the latter lends itself fairly well to automatic parallellism, whereas that's tricky with laziness)
07:51:00 <Philippa> that looks *really* retarded to a C coder
07:51:34 <Cale> sylvan: Let's call a piece of data "large" if it has many subcomponents which could reasonably be evaluated separately, and "small" if not.
07:51:36 <kpreid> is it interesting that (=<<) is like half of liftM? (that is, do { y <- f x; g y } == f x >>= g == (=<<) g $ f x)
07:51:48 <Philippa> if you've no unsafePerformIO it's not necessarily that hard at all - you can evaluate thunks leaving in all the references to other thunks, then go back and collate
07:52:22 <Cale> There are essentially 5 kinds of algorithms on data with those classifications (you'd think 4, but one is really two):
07:52:28 <Philippa> kpreid: it's the other way round that's interesting IMO, but yeah, it's a consequence of the monad laws if I've scanread right
07:52:30 <Cale> Small -> Large
07:52:34 <Cale> lazy is great there
07:52:43 <Cale> Large -> Large
07:52:50 <Cale> lazy and strict are about the same
07:52:55 <kpreid> Philippa: other way round?
07:52:55 <Cale> Small -> Small
07:52:59 <Cale> again, about the same
07:53:14 <Philippa> kpreid: you can define >>= in terms of fmap/liftM and join
07:53:17 <Cale> Large -> Small, where the Large thing is entirely consumed
07:53:22 <Cale> strict is better
07:53:28 <Cale> Large -> Small, where the Large thing is being searched
07:53:31 <Cale> lazy is better
07:53:40 <kpreid> Philippa: I see.
07:54:02 <int-e> Large -> Large needs a similar distinction I need (at least thinking in terms of lists - take reverse vs. map)
07:54:03 <Cale> That's the heuristic I generally use for determining which sort of strictness I want.
07:54:16 <kaol> I'd like to do something like type "Foo = Int -> (Int, [Foo])" to set up a bunch of functions that each do something and return the next functions to call... But that fails. Any nice way I could get around this?
07:54:28 <Cale> well, true, there is some issue there
07:54:28 <kaol> type Foo = ..., that is
07:54:42 <Philippa> int-e: yeah, though it's IME only interesting if you fold it down to small later on
07:55:11 <Cale> At least, if you have a choice at each point during programming -- I'm sort of talking about the default behaviour
07:55:32 <kpreid> kaol: use a data type instead of a tuple?
07:55:53 <Philippa> yeah, that's an infinite-looking type so you need it
07:56:12 <Cale> But yeah, if you have a choice between strict and lazy at each point, some more thought should go into the Large -> Large case. Usually, I think you'll want lazy eval, so as to be able to usefully apply lazy eval elsewhere, but there are times it won't matter.
07:56:16 <apfelmus> ah, the strictness discussion! say, are there hard examples that show that strictness really is that performant?
07:56:18 <IainFraser> hi sorry to ask again but what does the $ do in haskell?
07:56:25 <IainFraser> hard to google if you know what I mean
07:56:30 <Cale> IainFraser: f $ x = f x
07:56:35 <apfelmus> @hoggle $
07:56:35 <int-e> Anyway. Implementing strict algorithms in Haskell is a bit painful right now, especially if it involves arrays, not because the functionality isn't there (ST is quite good) but because it's awfully verbose.
07:56:36 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
07:56:36 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
07:56:36 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
07:56:45 <Philippa> apfelmus: ever filled your heap with thunks that amount to (+1)?
07:56:46 <kpreid> IainFraser: Don't google, hoogle!
07:57:16 <kpreid> IainFraser: the first link in http://haskell.org/hoogle/?q=$ is useful
07:57:18 <lambdabot> Title: "$ - Hoogle"
07:57:26 <IainFraser> ok cheers
07:57:43 <Philippa> without optimisation, that's exactly what the standard length function for lists'll do
07:57:44 <flux__> iow, it's a way to write less parenthesis :)
07:57:49 <Cale> So there are times where you want strictness, but I'd say that about 75-80% of the time, laziness is good.
07:57:57 <apfelmus> Philippa: yeah, of course :) but i meant the lazy/strictness overhead
07:58:19 <Philippa> if you're not gaining performance via not having to evaluate stuff, strict is inherantly faster than lazy
07:58:24 <IainFraser> what the hell?
07:58:28 <Cale> Strictness is important when it's needed, but as long as you have a way to get it when you need it, and you know when you do need it, there shouldn't be a problem.
07:58:41 <int-e> 'strict algorithm' meaning that it is fundamentally based on modifying some data in-place, so sharing isn't possible.
07:58:45 <Philippa> put simply, strict needs less paperwork
07:58:47 <IainFraser> so I might as well use brackets?
07:59:02 <Philippa> brackets're actually better in a sense due to a wrinkle in the type system
07:59:03 <Cale> IainFraser: $ is a nice way to avoid brackets
07:59:07 <kpreid> IainFraser: yes, but $ avoids the pileup of them
07:59:09 <Philippa> but return $ foo is a pretty common idiom
07:59:28 <apfelmus> Philippa: that's what i am questioning
07:59:32 <kpreid> IainFraser: it's also right- rather than left-associative
07:59:34 <Cale> f . g . h $ x is often nicer than (f . g . h) x or f (g (h x))
08:00:08 <IainFraser> ok I can see its purpose, but its a complication I don't need at the mometn
08:00:10 <IainFraser> cheers again
08:00:11 <Cale> It's also better for refactoring code later
08:00:19 <IainFraser> refactoring?
08:00:20 <Cale> well, the first two forms
08:00:31 <Cale> f . g . h is a value on its own
08:00:34 <Philippa> apfelmus: show me a zero-overhead way to implement laziness (or even call-by-name) and I'm listening...
08:00:41 <Cale> whereas f (g (h)) isn't
08:00:54 <IainFraser> ok
08:00:57 <Philippa> at the moment, GHC has a dereference for every thunk forced
08:00:59 <Cale> so writing things like that in terms of composition is handy for ripping code apart
08:01:09 <IainFraser> ok cool
08:01:15 <Philippa> also, asympototically worse space usage isn't exactly a bundle of joy either
08:01:17 <Igloo> Philippa: length really_long_list_of_units has poor space usage under strict evaluation too, though
08:01:57 <Philippa> Igloo: only if you count the list against the space usage
08:02:04 <Cale> Of course you do :)
08:02:17 <Philippa> oh okay, and don't have tail calls
08:02:25 <Cale> To get optimal space usage, you have to combine strict and lazy there
08:02:35 <Philippa> (or rather, TCO)
08:02:45 <Cale> You want the list to be lazily evaluated, and the length to be strict
08:03:07 <Cale> so that you get O(1) space
08:03:10 <apfelmus> mh, i'm not considering the fundamental overhead of lazyness but wether it shows up deadly in practice (hard example!)
08:03:56 <Philippa> apfelmus: space leaks're infamously one of the hardest aspects of debugging Haskell code
08:04:04 <Philippa> that aside, there's always an application where it matters
08:04:16 <IainFraser> damn im stuck
08:04:24 <Cale> But once you know how they tend to spring up, they're not *so* bad.
08:04:31 <IainFraser> is their anyway in map I can the position in the list as a second parameter
08:04:36 <Cale> Especially when you have the profiler to tell you where they are
08:04:49 <Cale> IainFraser: not without writing a new kind of map function
08:04:50 <Philippa> Cale: the advantage in laziness on the list's on the items rather than the list structure being lazy, though I agree it's there. But if the items're evaluated /anyway/...
08:04:57 <kaol> speaking of laziness, why isn't type resolution in "type Foo = Int -> (Int, [Foo])" lazy?
08:05:00 <Cale> IainFraser: you can zip with [0..] though
08:05:02 <IainFraser> ok guess im gonna have to do that
08:05:03 <kpreid> IainFraser: map (...) (zip myList [0..])
08:05:12 <Philippa> kaol: because that fundamentally screws up many important properties of the type system
08:05:13 <IainFraser> zip? ill hoogle it!
08:05:23 <Cale> > zip "Hello" [0..]
08:05:25 <lambdabot>  [('H',0),('e',1),('l',2),('l',3),('o',4)]
08:05:59 <Cale> kaol: type synonyms are fully expanded at compile time
08:05:59 <apfelmus> further, how good is strictness analysis? i mean, i can reason about a function being strict or not (and prove this). can't a strictness analyser reproduce this
08:06:01 <kaol> I'll have to read about it some time. It just seems somehow counterintuitive that it fails.
08:06:12 <Cale> kaol: They don't define new types
08:06:13 <kpreid> IainFraser: for things like zip, you can often tell what it does just by asking ghci for its type
08:06:16 <Philippa> kaol: it gives an infinite type, 'nuff said?
08:06:51 <IainFraser> how do you ghci what type something is?
08:06:58 <kpreid> IainFraser: :type <expr>
08:07:06 <IainFraser> wicked cheers
08:07:07 <Cale> IainFraser: Or just :t <expr>
08:07:08 <kpreid> e.g. :type zip
08:07:16 <Cale> @type zip
08:07:18 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
08:07:39 <Philippa> kaol: fundamentally, our type systems don't do lazy because we care about the invalid typings that we wouldn't evaluate
08:07:53 <kaol> but if nobody asks what Foo really is, then is there any harm in it?
08:08:12 <Cale> kaol: Types are purely a compile-time thing in Haskell, they don't exist at runtime
08:08:38 <Philippa> kaol: it's asked every time you pass a Foo around
08:08:42 <Cale> Foo will be expanded completely in place
08:08:48 <Cale> wherever it is used
08:08:54 <Cale> that's what type synonyms mean
08:08:55 <Philippa> otherwise you can't know what is or isn't a Foo
08:09:55 <Cale> If you want the recursive type, you can get it though
08:09:58 <Cale> Use newtype
08:10:15 <Cale> newtype Foo = Foo (Int -> (Int, [Foo]))
08:10:26 <IainFraser> im doing this at the moment is this the best way to do it firststring : laststring
08:10:27 <kaol> ok, ok. but I'd still like to see just what would break if it would be allowed in the type system. But that's just an exercise for myself.
08:10:29 <IainFraser> to concante strings
08:10:32 <IainFraser> is this effcient?
08:10:35 <Cale> IainFraser: ++
08:10:43 <kaol> and I see now how I can get around that. thanks.
08:10:57 <IainFraser> nice
08:10:59 <IainFraser> cheers
08:11:19 <Cale> IainFraser: ++ takes time linear in the length of its left parameter
08:11:42 <Cale> well, really, the min of the left parameter and the length of the resulting string which is actually used
08:11:58 <Philippa> using concat rather than repeated applications of ++ is a good thing
08:12:29 <Cale> So you should be careful about using ++ where you're accumulating short strings onto the end of a long one
08:14:05 <Philippa> like the concat case I just gave
08:14:17 <Philippa> doing it by interspersing ++ will really badly hurt you
08:14:54 <Cale> It's considered better in these cases to accumulate a function which takes the rest of the string and returns the completed string. You can concatenate with composition.
08:15:56 <Philippa> true, that's pretty much the ideal
08:16:04 <Philippa> parameterise-on-[], in effect
08:16:14 <Cale> mhm
08:16:43 <Philippa> (yes, fold really /is/ your friend!)
08:16:56 <Cale> (though this might be confusing to someone who is new, so if what I'm saying doesn't make sense, ignore it for now, and ask about it later if you find things are too slow :)
08:18:52 <Philippa> door
08:27:58 <IainFraser> can I convert a int to a char?
08:28:18 <gds> "show" will convert it to a string.
08:28:23 <IainFraser> nice
08:28:52 <IainFraser> you guys are like the fastest course on haskell ever
08:28:57 <IainFraser> who needs uni
08:29:12 <IainFraser> when I get good at this, I will give back what you have given me
08:29:49 <vincenz> IainFraser: if you meant converting int to char, as in getting the specific char
08:30:00 <vincenz> > chr 97
08:30:01 <lambdabot>  'a'
08:30:07 <ndm> @hoogle Int -> Char
08:30:09 <lambdabot> Char.chr :: Int -> Char
08:30:09 <lambdabot> Char.intToDigit :: Int -> Char
08:30:09 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
08:30:17 <ndm> @hoogle Int -> String
08:30:18 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
08:30:21 <IainFraser> oh right good to know
08:30:25 <IainFraser> but show worked suffciently
08:30:29 <IainFraser> I was doing a bit of testing
08:30:29 <vincenz> ndm: hoogle should do instance checking
08:30:39 <kaol> > intToDigit 2
08:30:41 <lambdabot>  '2'
08:30:41 <ndm> vincenz: it does, technically, its just a bit broken :)
08:30:46 <vincenz> ndm: yeah
08:30:56 <vincenz> ndm: and sometimes it constrains instance-typed stuff
08:30:57 <ndm> esp for other MPTC and higher kind classes
08:31:16 <vincenz> ndm: aka you ask it for something like m a -> m a, and it'll return something specific for lists
08:31:20 <therp> I recently asked in this channel about haskell's type inference, and got the answer that the magic word is "type unification", can some one give me a pointer to a educational suitable implementation of type inference/unification? I'm digging through literature at the moment and I am held up with proofs of stuff I'm not that interested in
08:31:21 <vincenz> @hoogle (Monad m) => m a -> m a
08:31:23 <lambdabot> Prelude.id :: a -> a
08:31:23 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
08:31:23 <lambdabot> Prelude.asTypeOf :: a -> a -> a
08:31:31 <vincenz> @hoogle (Monad m) => m a -> m b
08:31:32 <lambdabot> Prelude.id :: a -> a
08:31:33 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
08:31:33 <lambdabot> Prelude.asTypeOf :: a -> a -> a
08:31:34 <ndm> vincenz: any example with Monad is broken :)
08:31:41 <ndm> Monad = higher kinded type
08:31:46 <vincenz> how is Prelude.id ...
08:31:50 <vincenz> ndm: you said MPTC
08:31:54 <vincenz> ndm: MPTC is another beast altogether
08:32:03 <ndm> vincenz: yes, it breaks on both of them in different ways :)
08:32:20 <vincenz> ndm: ok well if you say "it breaks on monads", the fact it breaks on MPTC will be a near truism
08:32:29 <vincenz> ndm: the other direction is not so true
08:32:46 <ndm> vincenz: they are entirely different cases, it just happens not not handle MPTC at all, and to break on higher kinds separately
08:32:47 <vincenz> ndm: but good work :)
08:32:51 <ndm> wait for version 4 :)
08:33:03 <vincenz> ndm: heh, soon hoogle will be more powerful than a compiler
08:33:12 <vincenz> ndm: especially if you then want to add checks for >1 function used
08:33:15 <ndm> vincenz: just wait...
08:33:28 <ndm> vincenz: combinatorial blow up might break that, sadly...
08:33:36 <vincenz> ndm: yeah we discussed it
08:33:54 * vincenz wishes that he could GPL his code for collaboratoin :/
08:33:59 <vincenz> like hoogle etc
08:34:09 <ndm> how do you mean?
08:34:15 <ndm> Hoogle isn't GPL'd, as it happens
08:34:28 <vincenz> ndm: well opensource
08:34:39 <ndm> yep, why can't you open source your code?
08:34:46 <IainFraser> im trying to make a string of empty characters i long, I can't figure out why this goes on forever
08:34:50 <IainFraser> addspaces :: Int->[Char]
08:34:51 <vincenz> ndm: cause I do research at an institute instead of a univ?
08:34:54 <IainFraser> addspaces 0 = []
08:34:58 <IainFraser> addspaces i = [' '] ++ addspaces(i-1)
08:34:59 <vincenz> ndm: erm, my phd
08:35:03 <ndm> ah, fair enough
08:35:09 <vincenz> IainFraser: much easier
08:35:12 <vincenz> > replicate 10 ' '
08:35:18 <lambdabot>  "          "
08:35:21 <ndm> my main PhD repo is online :)
08:35:23 <IainFraser> that returns a string
08:35:27 <ndm> despite being unreleased and incomplete
08:35:34 <vincenz> IainFraser: sodoes yours
08:35:38 <vincenz> IainFraser: A stirng == [Char]
08:35:40 <vincenz> argh
08:35:41 <IainFraser> mying goes on forever
08:35:42 <vincenz> typos!
08:35:42 <IainFraser> ya I know
08:35:59 <IainFraser> why does my one go on forever though
08:36:04 <IainFraser> I know the values are 0 or above
08:36:09 <IainFraser> never negative
08:36:10 <vincenz> ndm: yeah well, I wish for that too, you may or may not know I built a miniML interpreter in haskell, would be cool if others could fiddle with it
08:36:18 <ndm> ah, shame
08:36:29 <ndm> open source is good, its nice to share :)
08:36:40 <vincenz> ndm: I agree
08:36:47 <ndm> its also much better for debugging, you can fix teh bug where the bug is, not avoiding closed libraries
08:37:00 <vincenz> ndm: well that and you can get more people to collab with
08:37:03 <vincenz> even if just sporadically
08:37:14 <vincenz> great for doing research
08:37:21 <ndm> vincenz: the number of hoogle patches is about 0 I think
08:37:31 <ndm> from people who aren't me, well maybe about 3
08:37:43 <vincenz> @where hoogle
08:37:44 <lambdabot> http://www.haskell.org/hoogle
08:37:47 <vincenz> erm
08:37:54 <ndm> although the contributions to the documentation on the wiki have been useful :)
08:38:12 <vincenz> where -is- the code?
08:38:12 <ndm> darcs get http://www.cs.york.ac.uk/fp/darcs/hoogle
08:38:14 <lambdabot> Title: "Index of /fp/darcs/hoogle"
08:38:20 <ndm> its linked to from the Manual
08:38:37 <ndm> I guess if I made that link I might get more patches
08:38:46 <ndm> but no one else understands how it works, and probably never will...
08:39:40 * vincenz shudders as he sees the code
08:39:46 <vincenz> lookupClass
08:40:22 <ndm> yeah, thats broken for higher kinds
08:40:32 <ndm> not quite sure why, I wrote it, and never debugged it
08:40:43 <ndm> I intend to junk it for Hoogle 4, and go from scratch
08:40:58 <ndm> http://www.haskell.org/haskellwiki/Hoogle/Specs - that is the specs for Hoogle 4 as they stand
08:41:00 <lambdabot> Title: "Hoogle/Specs - HaskellWiki"
08:42:00 <vincenz> ndm: it's a monster
08:42:10 <ndm> vincenz: the code to Hoogle?
08:42:19 <ndm> the code to my PhD makes hoogle look simple :)
08:42:21 <vincenz> yeah :(
08:42:27 <vincenz> not well documented
08:42:31 <vincenz> short undescriptive names
08:42:43 <vincenz> not saying it's big size-wise, just hard to get into
08:43:17 <vincenz> ndm: what's the code of your PhD?
08:46:08 <vincenz> heh
08:46:14 <vincenz> Daemus in #IO is an instance of lambdabot
08:46:49 <ndm> vincenz: Catch, http://www.cs.york.ac.uk/fp/darcs/catch
08:46:51 <lambdabot> Title: "Index of /fp/darcs/catch"
08:46:58 <ndm> I'm not very good at names, hence the code :)
08:47:07 <ndm> and documentation is "not my style"
08:47:12 <vincenz> ack
08:47:14 <vincenz> should've done partial
08:47:39 <vincenz> ndm: I typically refactor to ease my own life as well
08:47:42 <ndm> although don't expect my PhD to work, it required Yhc, GHC and Hugs
08:47:52 <vincenz> ?
08:47:56 <ndm> vincenz: it was a while since I did hoogle, but yes, it needs work on it
08:47:57 <IainFraser> im doing output i.e. return IO
08:48:06 <IainFraser> is there a way to sort of return
08:48:13 <IainFraser> because im using recurssion to render stuff
08:48:20 <IainFraser> but when the list is empty I don't want to output anything
08:48:20 <vincenz> ndm: so you're supposed to turn in code for your phd?
08:48:21 <ndm> vincenz: it prods off to Yhc and Hugs, and GHC to compile it
08:48:28 <IainFraser> but I need it there for extensive pattern ... 
08:48:34 <vincenz> ndm: why is GHC not enough
08:48:42 <ndm> vincenz: no, i turn in a thesis, but to prove my conjectures Code is required
08:48:52 <norpan> IainFraser: what do you mean by doing return
08:48:56 <ndm> vincenz: it prods Hugs to calculate the types with :t, and it uses Yhc for Core
08:49:04 <vincenz> ah
08:49:31 <ndm> its a monster :)
08:49:32 <vincenz> hmm
08:49:37 <vincenz> CoreApp Exp [Exp]
08:49:38 <vincenz> why not
08:49:40 <vincenz> CoreApp Exp Exp
08:49:51 <ndm> where, in Yhc?
08:49:52 <IainFraser> well basically ive got renderlist [] = 
08:49:56 <IainFraser> it has to equal something
08:49:59 <vincenz> ndm: no yourcode
08:50:02 <IainFraser> the rest of the list im calling putstrln
08:50:03 <norpan> IainFraser: you can just return ()
08:50:04 <ndm> that bit is an interface to Yhc, so it matches Yhc
08:50:07 <IainFraser> wicked
08:50:08 <IainFraser> thanks
08:50:13 <IainFraser> I was doing return
08:50:15 <IainFraser> without the ()
08:50:18 <IainFraser> but it was failing
08:50:20 <vincenz> ndm: where is the 'core' of the thing?
08:50:27 <norpan> well, the type of a generic IO action is IO ()
08:50:32 <ndm> and its spineless vector application, hence the CoreExp list type
08:50:35 <norpan> and () is the only element of the type ()
08:50:45 <ndm> vincenz: no such thing, there is the Core of Yhc, which is in Yhc
08:50:46 <vincenz> ndm: not sure I get that reasoning, but ok
08:50:52 <vincenz> ndm: I meant the central part
08:50:56 <ndm> then there is Hite, which is the Core data type of Catch
08:51:12 <vincenz> ndm: I take it Graph is some sort of value-graph representation?
08:51:23 <ndm> then there are several front ends, Checker, Graph, Typey
08:51:27 <ndm> all are alternatives to each other
08:51:28 <vincenz> ndm: in that case, what kind of graph analysis did you do, and do you have any info on it?
08:51:44 <norpan> IainFraser: if all you do for IO is to print strings, you may consider returning a string from renderlist instead and print it later
08:51:44 <vincenz> Hite is a huge dir o.O
08:51:50 <ndm> vincenz: structural graph manipulation and representation of functions, no info on it, and it didn't really work :)
08:52:02 <vincenz> ndm: ah ok
08:52:07 <vincenz> I want to do a value-graph repr of my code
08:52:10 <vincenz> my ast is like a miniml
08:52:20 <vincenz> (with references)
08:52:35 <ndm> I never actually represent values, its all a bit more abstract
08:52:43 <vincenz> value-dependence-graph
08:52:44 <vincenz> sorry
08:52:45 <ndm> Typey is my current work, which does a form of subtype inference
08:53:49 <ndm> Data.Predicate is almost a releaseable module on its own
08:54:09 <ndm> RegExp and Star are representations of regular expressions, alternatives
08:54:15 <ndm> Predicate is an old predicate simplifier
08:54:24 <dropdrive> I just came across a bit of trivia: who first suggested the term "monads?"  Where?  When?
08:55:00 <ndm> a philosipher, i believe
08:55:03 <ndm> its on wikipedia
08:55:14 <xerox> hah.
08:55:38 <ndm> I also came across some itneresting trivia, where does the programming language/paradigm Linda get its name from?
08:55:50 <ndm> its also on Wikipedia
08:55:59 <ndm> but a much more interesting answer ;)
08:56:10 <norpan> lovelace?
08:56:11 <vincenz> ndm: I see you don't use indirect composite for ASTs
08:56:24 <vincenz> ndm: the first female programmer
08:56:33 <dropdrive> ndm: hmm, I can't find it...
08:56:44 <vincenz> linda lovelace
08:56:50 <ndm> norpan: norpan is right, its lovelace
08:56:59 <ndm> certainly not a programmer...
08:57:10 <ndm> http://en.wikipedia.org/wiki/Linda_%28coordination_language%29
08:57:22 <norpan> well she shares the surname with one
08:57:47 <norpan> i've made that connection before :)
08:58:04 <norpan> not that i ever watch porn of course
09:01:57 <ndm> vincenz: indirect composite?
09:02:04 <ndm> i just use standard Haskell data types...
09:05:58 <shapr> Cale: hey, I want to write a blog entry about graph theory, category theory, and how they fit into the standard combinators like map, fmap, Conor McBride's Application and Traversal typeclasses, etc.
09:06:18 <IainFraser> hey guys, I don't think this is possible but if it was it would be wicked
09:06:32 <IainFraser> if I do something like inc :: Int
09:06:34 <IainFraser> inc = 3
09:06:56 <IainFraser> is there a way to update the through the return of a function e.g. inc = Add inc 1
09:07:28 <shapr> I came up with functor, monoid, monad, and arrow for just a few. Can anyone suggest others that fit in there?
09:07:52 <shapr> IainFraser: You can do that with the state monad.
09:08:10 <Cale> IainFraser: but inc = 3
09:08:13 <Cale> :)
09:08:28 <Cale> IainFraser: Think of that as an equation, not an assignment
09:08:44 <Cale> 3 = inc as well
09:08:50 <IainFraser> oh ok
09:09:03 <IainFraser> ill look up state monad
09:09:08 <shapr> I guess I want to write an entry that introduces experience programmers who are new to Haskell how all those pieces fit together.
09:09:10 <Cale> But yeah, if you need a mutable state variable, you use the state monad
09:09:21 <Cale> shapr: hmm
09:09:43 <xerox> > let iter = do { n <- get; put (n+1); return n } in evalState (do { a <- iter; b <- iter; c <- iter; return (a,b,c) }) 1
09:09:44 <lambdabot>  (1,2,3)
09:09:48 <IainFraser> ya that would be wicked
09:10:04 * shapr wanders off to eat food and think about the layers...
09:10:14 <shapr> Cale: If you come up with some layers you think I should include, I'd like to hear about it.
09:11:23 <IainFraser> urm well you should definately do an article on input/output using monads
09:11:30 <IainFraser> inface it should be at the start
09:11:39 <IainFraser> simple stuff like "hello world", and input
09:11:41 <xerox> > let iter = do { modify (+1); get } in evalState (do { a <- iter; b <- iter; c <- iter; return (a,b,c) }) 0
09:11:43 <lambdabot>  (1,2,3)
09:11:48 <Cale> IainFraser: I already have :)
09:11:53 <Cale> Well, a short one
09:12:06 <Cale> @wiki Introduction_to_IO
09:12:06 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
09:12:08 <IainFraser> because I don't know about other people, I learnt the maths part of haskell on my course
09:12:18 <IainFraser> it combined set theory , predicate logic and haskell
09:12:26 <Cale> The Haskell Road?
09:12:28 <IainFraser> which I thought was cool (it was compulsory for first year)
09:13:27 <IainFraser> but now im at work, and I thought of using haskell for those features
09:13:38 <IainFraser> but I don't have time to learn the "formal way"
09:13:56 <IainFraser> or the boss will get pissed, so either I keep doing C++
09:14:01 <vincenz> ndm: so how do you annotate your asts 
09:14:05 <IainFraser> but a hands on approach would be wicked
09:14:12 <ndm> vincenz: i don't
09:14:12 <IainFraser> if you could do that would be absolutely brillant
09:14:28 <vincenz> ndm: hmm, alright
09:15:16 <Cale> IainFraser: well, the little intro article I wrote should take only 5 minutes or so to read and give you the basic idea
09:15:51 <Cale> actually getting used to using it takes a little more practice, but it's a lot easier than it might look at first
09:16:21 <vincenz> ndm: you don't do typing analysis?
09:16:40 <ndm> vincenz: not really, I do in typey, but there i have a map of functions to types
09:17:05 <Cale> Eventually, you just come to regard it as similar to programming in an imperative languages, but there are some small differences about it that can catch you at first -- the largest of which being that you have to maintain the distinction between an action and the value it returns in your head, and use the syntax consistently with that
09:17:07 <gds> IainFraser: If you have the time to look at it, I found http://research.microsoft.com/~simonpj/papers/marktoberdorf/mark.pdf very helpful.
09:17:10 <vincenz> ndm: alright thx
09:17:15 <ndm> vincenz: see Typey.Annotate, and cry :)
09:17:35 <ndm> system $ "hugs " ++ fileHs ++ " < " ++ fileIn ++ " > " ++ fileOut
09:17:40 <Cale> For example, getLine ++ getLine is not valid
09:17:43 <ndm> thats how i wrote a type checker :)
09:17:50 <vincenz> ndm: :D
09:17:56 <Cale> You have to either do x <- getLine; y <- getLine; return (x ++ y)
09:17:59 <vincenz> ndm: well I do type-inference, hence the annotation of ASTs
09:18:08 <Cale> or something like  liftM2 (++) getLine getLine
09:18:12 <ndm> yeah, its much easier if you get another program to do it for you
09:18:14 <vincenz> ndm: do you happen to have any idea on how to do value-dependence-graph analysis in the presence of references
09:18:17 <ndm> although not as flexible
09:18:22 <ndm> nope, no idea sorry
09:18:26 <vincenz> hmm
09:18:37 <IainFraser> cheers gds
09:18:38 <Cale> IainFraser: can you see why?
09:19:52 <IainFraser> uurm not really
09:20:02 <IainFraser> why do you have to assign it first?
09:21:30 <Cale> because getLine isn't a string
09:21:43 <Cale> it's an action which when carried out, results in a string
09:21:56 <Cale> so it's not a list, and it's not valid to use ++ with it
09:22:34 <norpan> that paper gds talked about is really good
09:23:42 <IainFraser> sorry guys im trying to read the papers, chat , and do this as well
09:23:45 <IainFraser> still under a deadline
09:23:52 <vincenz> ndm: do you do any sort of flow analysis?
09:23:53 <IainFraser> but now that ive found this place I will come on often
09:24:04 <ndm> vincenz: no
09:24:05 <IainFraser> after this week ill be willing to answer any questions you want from a noob
09:24:18 <ndm> not explicitly, i do in Checker, a bit
09:24:18 <IainFraser> sorry again, its looks rather selfish I know
09:24:23 <ndm> but not expliclty
09:24:28 <vincenz> ndm: what sort?
09:24:32 <vincenz> ndm: just trying to gather some info
09:24:38 <vincenz> moost flow-papers focus on languages like C
09:24:42 <ndm> vincenz: not well specifiied, just "some"
09:24:51 <vincenz> in addition, not quite sure how to represent graphs
09:24:57 <ndm> its a backward analysis, you might get some clues from my paper
09:25:05 <norpan> IainFraser: we won't go away
09:25:07 <vincenz> in haskell that is
09:25:12 <ndm> vincenz: http://www-users.cs.york.ac.uk/~ndm/downloads/paper-a_static_checker_for_safe_pattern_matching_in_haskell-future.pdf
09:25:38 <ndm> anyway, have to go now, but will be on again tomorrow - bye
09:26:43 <vincenz> ndm: ok, talk to you later
09:28:23 <IainFraser> wow haskell is so fucking amazing
09:28:26 <IainFraser> mind the french
09:28:35 <IainFraser> i just got a query in my database in one line
09:28:50 <IainFraser> the code is insanse, I can make any table I want, display it perfectly and run simple querys in 70 lines of code
09:29:00 <IainFraser> and im sure if I got you guys on it you probably do it in less ;)
09:29:04 <norpan> haskell is amazing, yes
09:29:10 <IainFraser> I love C++, but that would have taken me so much code
09:29:21 <IainFraser> and debugging with all that memory management would have been a killer
09:29:27 <IainFraser> even with the help of boost and STL
09:29:28 <IainFraser> wow
09:29:33 <IainFraser> it was so worth it
09:29:47 <norpan> for small prototype applications it has no match
09:29:56 <IainFraser> yeah
09:30:00 <IainFraser> well my plan for my database is
09:30:03 <norpan> or maybe it has
09:30:07 <norpan> but it's still amazing :)
09:30:09 <IainFraser> php maybe
09:30:19 <IainFraser> php is really handy for quick stuff, because there are so many functions
09:30:21 <norpan> gah php
09:30:25 <IainFraser> but for speed haskell still has it
09:30:47 <IainFraser> this is my plan make a really fast database storage in C++, using threads maybe a bit of asm
09:30:52 <IainFraser> im writing this for pocket pc
09:31:04 <IainFraser> then use sql and regex libary to run simple sql like queries
09:31:10 <IainFraser> so far so good!
09:31:14 <IainFraser> thanks to you guys
09:31:42 <IainFraser> hopefully integrating C++ won't be to hard
09:32:18 <Philippa> it's easier to integrate C code than C++, or at least C-style interfaces
09:34:06 <sm> norpan: what about big, real-world applications then ?
09:35:25 <norpan> harder to tell
09:35:34 <norpan> as there are not as many
09:36:06 <vincenz> norpan: personally I'm a bit afraid of scaling
09:36:29 <IainFraser> oh doing c will be no problem
09:36:52 <norpan> vincenz: indeed
09:37:08 <koffein_> hi
09:37:10 <vincenz> norpan: already the design of my compiler is becoming less than perfect
09:37:21 <norpan> we use haskell somewhat in our product, but the bulk of the application is java/c++
09:37:28 <vincenz> norpan: also unsure about the clean design for gui-based of bigger applications
09:37:34 <vincenz> shit
09:37:35 <vincenz> gotta go
09:37:38 <koffein_> what type signature should I use if I want a value to be both Num a and Ord a?
09:37:52 <norpan> clean design for gui is an oxymoron
09:38:07 <eivuokko> foo :: (Num a, Ord a) => a -> a
09:38:10 <norpan> (Num a, Ord a) =>
09:38:12 <norpan> yea
09:38:14 <koffein_> ok, thanks
09:38:27 <koffein_> did not know that was possible
09:38:35 <norpan> it sure is
09:41:32 <sm> is hoogle the first line of reference for most folks ?
09:41:51 <IainFraser> can I pass an operator to a function?
09:41:53 <IainFraser> like ==
09:41:54 <sm> it says it only searches functions, but I think it finds modules & types as well
09:42:03 <IainFraser> something along the lines of (String->String)->Bool
09:42:07 <sm> what libs does it index ? not third party stuff like HAppS
09:42:21 <IainFraser> I could write my own function but it owuld be neat if I didn't have to
09:43:01 <norpan> IainFraser: you sure can
09:43:28 <norpan> you can pass arbitrary functions as arguments to other functions
09:43:35 <Lemmih> sm: GHCi is the first line of reference for me.
09:43:37 <IainFraser> how do I use it though
09:43:40 <norpan> to make a function of an operator, you write (==)
09:43:49 <Lemmih> sm: Next comes Haddock.
09:43:59 <sm> Lemmih: :t in ghci ?
09:44:06 <IainFraser> e.g. lets say I do compare String->String->(String->String->Bool)->Bool
09:44:18 <Lemmih> sm: I find :i more useful.
09:44:21 <IainFraser> compare a b c = (c a b)
09:44:24 <IainFraser> that doesn't work
09:44:36 <norpan> yes it will
09:44:38 <sm> that's for stuff your code already imports, I assume
09:44:46 <IainFraser> oh right must be somewhere in my own actual code
09:45:43 <norpan> although compare may already be defined in the Prelude
09:45:46 <norpan> not sure where it is
09:45:48 <sm> haddock certainly is great, I'm hoping hoogle will let me get around it a little quicker
09:45:53 <norpan> @hoogle compare
09:45:54 <lambdabot> Prelude.compare :: Ord a => a -> a -> Ordering
09:45:54 <sm> so far so good
09:45:54 <lambdabot> Text.ParserCombinators.Parsec.Error.messageCompare :: Message -> Message -> Ordering
09:45:59 <norpan> yes
09:46:03 <IainFraser> :I forgot to pass the new operator in the recursive call
09:46:04 <IainFraser> my bad
09:46:07 <IainFraser> that is so cool though
09:46:22 <norpan> you can also use partial application of operators
09:46:40 <norpan> > filter (>3) [1,4,6,2,3,1]
09:46:41 <lambdabot>  [4,6]
09:46:54 <norpan> > filter (3>) [1,4,6,2,3,1]
09:46:55 <lambdabot>  [1,2,1]
09:47:02 <norpan> and so on
09:47:18 <IainFraser> wow
09:47:36 <IainFraser> im guessing from the results of my code haskell can't do < then or > on strings
09:47:47 <norpan> sure it can
09:47:52 <norpan> > "apa" > "bepa"
09:47:53 <lambdabot>  False
09:48:09 <xerox> ?instances Ord
09:48:10 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
09:48:15 <xerox> It can do that on all of those.
09:48:19 <IainFraser> for me its returning an empty set
09:48:30 <norpan> a set?
09:48:37 <IainFraser> im doing "a" > "Iain"
09:48:46 <IainFraser> urr
09:48:49 <xerox> > "a" > "Iain"
09:48:50 <lambdabot>  True
09:48:51 <IainFraser> im obivously getting tired
09:48:57 <IainFraser> wait if its true
09:49:02 <IainFraser> must be in my code ill check
09:49:48 <int-e> > sort ["fred", "barney", "wilma"]
09:49:49 <lambdabot>  ["barney","fred","wilma"]
09:52:07 <IainFraser> ive just complicated a sort of "WHERE" from sql in 3 lines of code
09:52:12 <IainFraser> oh my GOD!
09:52:35 <IainFraser> john carmack could nto even get that done in c in less than I don't know 200 lines
09:53:04 <norpan> you're obviously exaggerating, but it's nice that you are so positive :)
09:53:21 <IainFraser> im not
09:53:26 <IainFraser> look
09:54:00 <IainFraser> http://muer.njoerdba.com/paste/view.aspx?id=37d9488d-51c4-48e6-91a4-43913cd9a5ce
09:54:11 <IainFraser> obivously tables and stuff are done above
09:54:39 <roconnor> you should use guards ;)
09:54:43 <IainFraser> oh right, ya obivously its not completely like the WHERE statement
09:54:46 <roconnor> get rid if the if then else
09:54:54 <IainFraser> oh yeah I did guards at uni
09:54:55 <IainFraser> ill check
09:55:04 <int-e> @type filter
09:55:06 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:55:42 <roconnor> good point int-e
09:55:53 <norpan> filter (operator . (!!(fieldnumber ...)) xs
09:56:10 <norpan> or similar
09:56:14 <int-e> simplequery (Table a b xs) value column operator = filter (\x -> operator ...) xs
09:56:19 <norpan> well yes
09:56:21 <int-e> norpan: lambdas aren't evil
09:56:29 <norpan> lambdas are your friends
09:56:53 <norpan> they don't spit like the llamas do
09:57:05 <norpan> or do they
09:57:09 <int-e> (the pointless version would be   flip operator value . (!! fieldnumber b column 0)
09:57:11 <int-e> )
09:57:18 <norpan> yeah, i didn't see the value arg
09:57:27 <int-e> but as soon as it involves a flip I usually use lambda
09:59:20 <roconnor> where is paste.lisp.org?
09:59:28 <int-e> another point, people usually write [x] ++ ... as  x : ...
10:00:06 <int-e> hmm lisppaste2 is here. weird.
10:00:55 <xerox> lisp.org is experiencing DNS problems
10:01:57 <roconnor> four lines: http://muer.njoerdba.com/paste/view.aspx?id=6c02684c-ff92-4e6a-b006-a0c83d531899
10:01:59 <int-e> hmm. paste.lisp.org is an alias for www.common-lisp.net. and the latter is gone
10:03:26 <int-e> well, doesn't exist.
10:05:46 <RyanT5000> but paste.lisp.org still works?
10:06:00 <RyanT5000> aw :(
10:06:12 <RyanT5000> (i was thinking it could be a virtual servers thing)
10:09:12 <RyanT5000> is there any way to build an extensible enumeration?
10:10:26 <RyanT5000> something like
10:10:52 <RyanT5000> class Ord p => C c where {}
10:10:52 <RyanT5000> data AnyC = forall c. C c => AnyC c
10:11:04 <RyanT5000> where AnyC derives Ord
10:11:38 <SyntaxNinja> w00t
10:12:27 <roconnor> RyanT5000: You want existential types?
10:13:05 <roconnor> http://www.haskell.org/haskellwiki/Existential_type
10:13:06 <lambdabot> Title: "Existential type - HaskellWiki"
10:13:25 <RyanT5000> i've got an existential type; now i want it to be an instance of Ord
10:14:07 <roconnor> Well, if derives doesn't work, I suppose you can make it by hand?
10:14:26 <RyanT5000> yeah, i think i'll also derive Typeable
10:14:46 <kpreid> RyanT5000: to build an Ord for anything-at-all, you'd need to define an ordering of types
10:14:57 <kpreid> is 1 < or > "a"?
10:15:01 <roconnor> ah
10:15:07 <RyanT5000> yeah, i know the problem :)
10:15:12 <roconnor> kpreid: good point
10:15:15 <int-e> RyanT5000: cool. it will be back (looking at the registration date, maybe someone forgot to renew the domain in time). common-lisp.net has a nameserver again.
10:15:25 <roconnor> @karma+ kpreid
10:15:25 <lambdabot> kpreid's karma raised to 1.
10:15:28 <RyanT5000> i was hoping there would be a canned solution :)
10:15:30 <kpreid> > Data.Typeable.typeOf 1 > Data.Typeable.typeOf "a"
10:15:31 <lambdabot>  add an instance declaration for (Ord TypeRep)
10:15:31 <lambdabot>   In the definition of `oji...
10:15:40 <RyanT5000> yeah
10:15:46 <RyanT5000> what lambdabot said :P
10:15:58 <kpreid> RyanT5000: I have an existential Eq, if it helps...
10:16:33 <int-e> RyanT5000: or they switched ISPs. So many possibilities.
10:16:37 <RyanT5000> does it use the instance Eq TypeRep ?
10:16:42 <RyanT5000> int-e: yeah
10:16:47 <kpreid> RyanT5000: Not directly
10:16:59 <RyanT5000> ok sure i'd be interested in seeing that :)
10:17:14 <kpreid> data AnyEq = forall a. (Eq a, Typeable a) => AnyEq a
10:17:14 <kpreid> instance Eq AnyEq where (AnyEq a) == (AnyEq b) = maybe False (a ==) (cast b)
10:17:22 <norpan> instance Ord TypeRep where compare x y = compare (show x) (show y)
10:17:29 <kpreid> (that's Data.Typeable.cast)
10:17:44 <RyanT5000> norpan: yep
10:17:56 <RyanT5000> kpreid, ah i see
10:18:23 <kpreid> RyanT5000: the type == is inside of Data.Typeable.cast
10:18:23 <RyanT5000> what's the chance of show TypeRep being fast?
10:18:35 <RyanT5000> kpreid: yeah
10:22:00 <sm> Map.lookup and lookupIndex return a monadic result.. where can I find out more about the purpose of this monad ?
10:22:11 <sm> I have been looking at haddock
10:22:47 <kpreid> sm: I'll guess that they 'fail' if the key isn't found
10:23:01 <RyanT5000> you know, i've had this problem time and time again: i need an enumeration (determinable at link-time), but i need it to be extensible
10:23:05 <int-e> it's a generalisation of returning Maybe a
10:23:05 <norpan> sm: it's because a monadic result is more general than Maybe
10:23:25 <norpan> just think of it as Maybe :)
10:23:35 <sm> who/how decides what monad is used here ?
10:23:38 <norpan> you do
10:23:41 <sm> also, how do I get rid of it ? :)
10:23:48 <int-e> you don't
10:23:54 <int-e> Maybe is a monad, you can just use it
10:24:12 <norpan> just treat it as if it returned Maybe a
10:24:29 <sm> so I could extract the value with Just ?
10:25:03 <norpan> case match on Just and Nothing for instance
10:25:03 <int-e> > M.lookup (M.fromList [(1,32)]) 3 :: Maybe Int
10:25:04 <lambdabot>     add an instance declaration for (Num (Data.Map.Map (Data.Map.Map k a) ...
10:25:17 <int-e> > M.lookup 3 (M.fromList [(1,32)]) :: Maybe Int
10:25:18 <lambdabot>  Nothing
10:25:22 <int-e> > M.lookup 1 (M.fromList [(1,32)]) :: Maybe Int
10:25:23 <lambdabot>  Just 32
10:25:39 <norpan> > M.lookup 1 (M.fromList [(1,32)]) :: [Int]
10:25:41 <lambdabot>  [32]
10:25:46 <norpan> you see?
10:26:17 <sm> not yet, I'll stare at this 
10:26:25 <int-e> hmm. do we have the identity functor, monad, arrow, etc, somewhere?
10:26:26 <sm> thanks
10:26:44 <norpan> > M.lookup 1 (M.fromList [(1,32),(1,33)]) :: [Int]
10:26:45 <lambdabot>  [33]
10:26:53 <int-e> (newtype Id a = Id a, instance ...)
10:27:14 <int-e> it's still just a map, not a multi-map.
10:27:21 <norpan> it still is obviously
10:29:05 <RyanT5000> you need a fail though
10:29:09 <RyanT5000> Id doesn't have a fail
10:29:20 <int-e> of course, having a multimap lookup return a MonadPlus instance value could be interesting.
10:29:28 <int-e> RyanT5000: it'd be implemented as error
10:29:38 <int-e> fail is a wart anyway
10:29:45 <sm> so, in the example above, adding  :: Maybe Int  determines the monad
10:29:54 <RyanT5000> int-e: ah, interesting
10:29:57 <sm> if I didn't add the :: annotation, what would it give me ?
10:30:01 <int-e> But I digress.
10:30:30 <int-e> sm: it gives you what the context demands
10:30:41 <sm> I see-e
10:31:08 <SamB> > return 1
10:31:09 <lambdabot>  add an instance declaration for (Show (m a))
10:31:10 <sm> clever 
10:31:11 <norpan> you use it all the time, perhaps you just haven't seen it on the result side of a function before
10:31:29 <norpan> parametric polymorphism
10:32:24 <int-e> SamB showed you a case where it doesn't work out; in that case you fall back to explicit type signatures.
10:32:44 <SamB> @type return 1
10:32:46 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
10:32:48 <int-e> but often you can get away without them.
10:38:26 <sm> thanks for all the help.. sometimes I digest it slowly
10:40:35 <sm> when you're familiar with haskell, do types , syntax, and the 6 namespaces become clear and second nature ? can you pretty much right correct code the first time ?
10:40:45 <sm> s/right/write/
10:41:37 <mathewm> I am still learning, but I find that the first time I get my code to compile it will work -  takes me a few iterations to get it to compile, though
10:42:36 <RyanT5000> mathewm: i'm a noob too, and i experience the same thing; however, i doubt that's limited to noobs: it's the whole point of strong typing systems
10:43:14 <koffein_> the Gentle Introduction talked about programs that insert printing statments for debugging in your functions.. where can I find one of them? Cant debug my stuff otherwise
10:43:38 <RyanT5000> import Debug.Trace
10:43:46 <RyanT5000> @type trace
10:43:47 <lambdabot> Not in scope: `trace'
10:43:58 <RyanT5000> trace :: String -> a -> a
10:44:05 <astrolabe> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
10:44:24 <sm> excellent
10:44:41 <koffein_> thanks
10:44:58 <RyanT5000> what if i have two existentials, both of which derive Ord, and i try to compare them? what if they're different types?
10:45:50 <RyanT5000> oh huh, nvm,  it's a type error
10:45:56 <dmhouse> You can't derive stuff on existentials.
10:46:13 <RyanT5000> i meant the thing in the existential derived it :)
10:46:22 <RyanT5000> i'm  currently working on making the existential itself derive Ord
10:46:29 <RyanT5000> (first compare types, then compare things)
10:49:47 * sm wonders if trace doesn't work with HAppS apps
10:51:20 <RyanT5000> i can't wait until TH is advanced enough that we can get rid of deriving
10:52:10 <mathewm> I imagine that will be a loooong wait
10:52:15 <RyanT5000> why?
10:52:34 <RyanT5000> SerTH's basic construct is $(derivingSerializable blah)
10:52:42 <mathewm> TH isn't even a candidate for inclusion in the language spec, right?
10:52:53 <RyanT5000> well that's a shame
10:53:05 <RyanT5000> however, i'll admit TH is not very well-developed yet
10:53:15 <RyanT5000> it has a long list of unimplemented features
10:53:16 <mathewm> what is missing from TH?
10:53:51 <RyanT5000> using metafunctions defined in the current module, for one
10:54:01 <RyanT5000> i think there are issues with function reification
11:03:44 <RyanT5000> speaking of TH, is there any way to link in a non-profiled package into a profiled program?
11:03:53 <RyanT5000> e.g.: exclude that package from profiling
11:08:36 <Razor-X> What dependency is ``util-any'' ?
11:14:45 <sm> there's a difference in the effect of let and where, isn't there
11:15:26 <Cale> sm: let is part of expression syntax, where is part of declaration syntax
11:15:38 <Cale> sm: where scopes over guards
11:15:54 <apfelmus> Razor-X: ?
11:16:06 <sm> ahhh
11:16:29 <sm> that means.. where is evaluated at compile time ?
11:16:35 <Cale> no
11:16:44 <Cale> they're the same otherwise
11:16:51 <Razor-X> apfelmus: Ah, nevermind.
11:16:53 <sm> I'm trying to understand the different behaviour in http://rafb.net/paste/results/WW3yht60.html
11:17:00 <Razor-X> I figured out what was going wrong.
11:17:31 <Cale> sm: let in that case is part of the do-notation
11:17:40 <Cale> note that there's no 'in' part there
11:17:52 <sm> there is
11:18:01 <Cale> oh, there is, but you don't need it :)
11:18:23 <Janni> Hello.
11:18:43 <Cale> do {let <decls>; <stmts>} = let <decls> in do {stmts}
11:18:43 <sm> I saw that in other code and wondered.. what does the bare let with no in evaluate to then ? something suitable for this do block ?
11:18:46 <Cale> Janni: hello
11:18:49 <sm> aha
11:19:05 <sm> that helps
11:19:15 <Janni> I hope somebody's here familiar with the GHC sources who's willing to help me.
11:19:48 <sm> Cale: why though can't where see st ?
11:19:56 <therp> janni: I'm not, but in general it's a good advice to just start asking questions
11:20:11 <RyanT5000> "let blah = stuff" is simmilar to "blah <- return stuff"
11:20:19 <sm> aha
11:20:19 <Cale> sm: because it's local to the do-block
11:20:20 <RyanT5000> only better, because it doesn't impose an ordering
11:20:45 <Cale> sm: whereas the 'where' there is part of the top-level definition of app
11:20:51 <sm> aHA
11:21:01 <Cale> sm: so st isn't in scope
11:21:29 <Janni> I'm currently involved with external core, parsing, compiling, etc... But GHC does not implement %local tags, as it is defined in "An External Representation for the GHC Core Language"
11:21:38 <sm> RyanT5000: did you just imply that the lets can be moved anywhere in a do block ?
11:21:56 <RyanT5000> sm: eys
11:21:57 <RyanT5000> *yes
11:22:12 <RyanT5000> i don't know if that's a GHC extension though
11:22:14 <Janni> I'd like to implement that. For my intention it is necessary to know which functions are exported and which aren't.
11:22:15 <Cale> RyanT5000: except they can't :)
11:22:16 <RyanT5000> but i do it all the time
11:22:26 <RyanT5000> Cale: they sure can
11:22:48 <Cale> Well you can't move a let above the point at which a variable is bound which is used in the definition made by the let
11:22:55 <sm> that's what I meant
11:23:00 <Janni> Somebody who is familiar with the GHC sources maybe could tell me how I can determine if a binding is exported...
11:23:10 <RyanT5000> Cale yeah, that's true
11:23:13 <Cale> do {let y = x; x <- getLine; return y} should fail
11:23:18 <RyanT5000> right
11:23:52 <RyanT5000> i was referring to the syntax: lets can be placed anywhere, not just at the top of the do
11:24:01 <Cale> oh, yes, that's true
11:24:02 <apfelmus> > mdo {let y = x; x <- Just "a"; return y}
11:24:02 <lambdabot>  Parse error
11:24:13 <RyanT5000> (the original explanation i read said they had to be at the top >:-/ )
11:24:36 <Cale> that's not true, or else it would be useless
11:24:42 <RyanT5000> lol exactly
11:25:00 <RyanT5000> that's why i was really confused while i was reading it
11:25:09 <RyanT5000> and why i said something now
11:25:41 <Cale> yeah, I suppose it probably arises from the fact that the do-notation is defined recursively
11:25:51 <Cale> and so probably someone confused the statement that
11:25:56 <RyanT5000> yeah
11:26:04 <Cale> do {let <decls>; <stmts>} = let <decls> in do {<stmts>}
11:26:14 <Cale> to mean that let could only occur first :)
11:26:25 <RyanT5000> right
11:27:42 <apfelmus> mdo could do (don't you)?
11:28:07 <Cale> mdo is a whole other can of worms :)
11:30:54 <sm> thanks, again
11:31:03 * sm hacks, hacks, hacks
11:31:24 <koffein_> hm. This trace function does not do what I want. I want to see the content of a list at some point in the program, not just where I am... is that possible? I found nothing on the wiki
11:32:06 <apfelmus> scopy-do ought to do unbounded moving of let
11:33:04 <RyanT5000> koffein_: huh? trace (show myList) whatever
11:35:59 <koffein_> does not work somehow
11:36:15 <RyanT5000> well is it doing anything?
11:39:16 <koffein_> wait, I have broken something else
11:44:00 <koffein_> "When called, trace outputs the string in its first argument, before returning the second argument as its result."
11:44:25 <koffein_> so it just outputs the same string everytime
11:45:05 <sm> perhaps you need to use it in a do block ?
11:45:30 <int-e> f a = trace ("f " ++ show a) (computation involving a)
11:46:03 <int-e> it doesn't always have to be the same string
11:46:12 <koffein_> makes sense..
11:46:19 <koffein_> thanks
11:47:26 <sm> where would I find more introductory docs for  http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html ?
11:47:32 <int-e> > let computation = (+); involving = 23; a = 19 in computation involving a
11:47:33 <lambdabot>  42
11:48:11 <sm> I am confused about when to use << and +++, how to specify attributes for elements etc
11:49:51 * sm finds http://www.cse.ogi.edu/~andy/html/intro.htm
11:49:55 <lambdabot> Title: "Here are some notes on using the HTML libraries"
11:49:58 <koffein__> takes a bit getting used to if you normally just use print
11:51:30 <sm> yes
11:51:46 <koffein__> can I have it print to stout instead of stderr?
11:52:14 <sm> hmm is http://www.cse.ogi.edu/~andy/html/Html.lhs (Haskell Html Library) the same thing as ghc's Text.Html ? if so why do these literate docs not appear in haddock pages ?
11:53:03 <Cale> koffein_: why?
11:54:34 <koffein__> cause I want to read it. I'm running GHCi from an emacs buffer.. don't know where it's printing
11:54:35 <Cale> trace is only for debugging anyway, and should never be used as part of a final program
11:54:39 <Cale> ah
11:54:54 <Cale> somehow emacs is failing to capture stderr?
11:55:06 <koffein__> or it is just not printing
11:55:11 <koffein__> I don't know
11:55:16 <RyanT5000> koffein__: whhy don't you try it once from outside emacs?
11:55:22 <Cale> does it print when you run ghci normally?
11:56:45 <koffein__> wait
11:57:07 <koffein__> the statement was just not evaluated I think
11:57:14 <koffein__> damn laziness :D
11:57:32 <Cale> s/statement/expression/
11:57:47 <koffein__> yeah
11:58:08 <Cale> the only things in Haskell which are called statements are the lines in a do-block
11:58:18 <Cale> (the block itself is a kind of expression)
12:00:37 <koffein__> whoa... now I see it's doing something
12:10:02 <RyanT5000> is Data.List.sort O(n log n) average case?
12:10:34 <norpan> in ghc it's O(n log n) worst case
12:10:44 <RyanT5000> alright
12:10:49 <norpan> using merge sort
12:11:25 <RyanT5000> i'm trying to figure out what datastructure to use to store my meshes; they need to be sorted by texture, shader, etc.
12:13:01 <sieni> how do you sort by texture?
12:13:04 <sieni> or shader?
12:13:26 <RyanT5000> you find all the meshes that use the same texture, and you draw them all at once
12:13:54 <RyanT5000> obviously some meshes may use some of the same textures, so it's really a traveling salesman problem
12:14:03 <RyanT5000> there's a loading cost between any given pair of meshes
12:14:40 <sieni> I asked, how do you sort by texture. Is there some obvious linear ordering on textures?
12:14:47 <sm> why does import Data.Map as Map hiding (!) give a parse error on ! ?
12:15:13 <RyanT5000> sieni: ok, well, i guess you're technically not sorting so much as grouping
12:15:36 <RyanT5000> however i've heard it referred to as sorting so much i just instinctively used that word
12:15:43 <RyanT5000> (and there is definitely sorting involved)
12:16:29 <sm> hmm, needs to be ((!))
12:16:58 <palomer> (_|_)
12:17:15 <palomer> > let a _|_ b = a + b in (_|_)
12:17:15 <lambdabot>  Parse error in expression
12:17:21 <palomer> bastard.
12:17:33 <RyanT5000> _ doesn't begin an operator :P
12:17:47 <norpan> _ is a lower case letter
12:18:08 <bringert> hej shapr
12:18:16 <RyanT5000> yeah, s/begin/exist in/
12:18:26 <bringert> have you moved now?
12:29:59 <fanopanik> data Tree a = Nil | Node a (Tree a) (Tree a) deriving Eq; automatically forces a to be an instance of Eq too, right?
12:30:44 <kaol> wouldn't make much sense if it didn't
12:31:04 <fanopanik> Agreed
12:31:14 <norpan> it makes an instance Eq a => Eq (Tree a)
12:32:18 <norpan> so Tree a will only be an instance of Eq if a is it
12:32:18 <Cale> It doesn't force a to be an instance of Eq
12:32:23 <norpan> it doesn't force anything
12:32:30 <fanopanik> ah ok!
12:32:56 <fanopanik> makes even more sense
12:54:05 <shapr> hej bringert, I'm still in Boden, but we're driving south tomorrow.
12:54:46 <bringert> shapr: have fun
12:54:54 <shapr> bringert: Any good papers you can suggest for the two days of driving?
12:55:22 <shapr> I've just been reading McBride & Paterson's applicative / traversable typeclasses paper today.
12:55:23 <bringert> shapr: i suggest driving when you are driving
12:55:29 <shapr> I'm not driving :-)
12:55:32 <bringert> ah
12:55:42 <shapr> My license isn't valid in Sweden, sadly.
12:55:52 <bringert> shapr: that's a nice paper
12:56:04 <shapr> I very much enjoy driving and our pilot doesn't so it's sad I didn't think of this in time to get a Swedish license.
12:56:42 <shapr> I think I'll grab the McBride collection of papers, and convert the Baker archive to PDF. Any other suggestions?
12:57:08 <bringert> shapr: did you read the coddfish paper?
12:57:23 <shapr> Not yet, is it good?
12:58:01 <bringert> I think so, though some of the fancy database modelling stuff towards the end might not be so useful for the every day hacker
12:58:21 <shapr> Well, group theory and category theory probably isn't useful for the everyday hacker either...
12:58:45 <bringert> I want to change HaskellDB to use their type system for relational algebra operations
12:58:55 <shapr> Cool
12:59:01 <shapr> Is there a HwatDB paper?
12:59:01 <bringert> shapr: hope has a bunch of new stuff btw
12:59:09 <bringert> shapr: there is a report
12:59:10 <shapr> Spiffy, I'm pulling right now.
12:59:31 <bringert> shapr: see http://hope.bringert.net/
12:59:46 <shapr> Wah, cool!
12:59:53 <bringert> threaded comments, css themes, serious DB changes
13:00:05 <shapr> Awesome!
13:00:12 <shapr> Will I have to dump all my data?
13:00:18 <shapr> oh, migration tool, w00
13:00:26 <bringert> shapr: you will need make migratedb; ./migratedb
13:00:34 <bringert> oh, and back up your DB
13:00:48 <shapr> Will do
13:01:13 <shapr> Anon comments can be turned off?
13:01:21 <jgrimes_> bringert: the changes look pretty cool
13:01:29 <bringert> the migration tool does not drop the old tables, so if you are brave you can do that once everything works
13:01:56 <shapr> With a backup in place, I have no limit on my bravery.
13:02:07 <bringert> jgrimes_: thanks. let me know if you have any suggestions or problems
13:02:17 <bringert> jgrimes_: how is your setup working out
13:02:42 * bringert has to go put chemicals in the pool
13:02:49 * bringert is a pool boy today
13:02:52 <jgrimes_> bringert: pretty well, I'm still just messing around with stuff , though
13:02:54 * shapr grins
13:03:02 <bringert> brb
13:08:08 <bringert> bah, "rinse skin for 15-20 minutes"
13:08:13 <bringert> how bad can it be?
13:11:04 <dsacode> Hello! There's `lookup' function, but is there lookup modification that can report if there's duplicated key?
13:11:25 <kpreid> shapr!
13:13:32 <sm> I doubt Map would allow a duplicate key
13:14:39 <dsacode> sm: for example if I have [("x", True), ("x", False)] list, and I do lookup "x", i want to throw error "duplicated x"
13:14:43 <RyanT5000> is there memory-mapped file support in the base libs?
13:14:58 <RyanT5000> something like mapFile :: FilePath -> Ptr a
13:15:04 <sm> ah, List.lookup
13:15:26 <dsacode> sm: thx, i'll check it!
13:15:42 <sm> that meant: I see what you meant. don't know the answer, sorry
13:16:48 <dsacode> sm: np
13:17:17 <int-e> fps (Data.ByteString) has a mmap.
13:17:19 <int-e> @where fps
13:17:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
13:18:21 <RyanT5000> what's the difference between ForeignPtr and Ptr?
13:20:20 <Cale> RyanT5000: ForeignPtrs can have finalisers associated with them
13:22:13 <RyanT5000> Cale: can't *anything* have a finalizer associated with it?
13:22:20 <Cale> hm?
13:22:20 <Cale> no
13:22:55 <RyanT5000> @type System.Mem.Weak.addFinalizer
13:22:57 <lambdabot> forall key. key -> IO () -> IO ()
13:23:20 <Cale> Oh, it might be possible in terms of that
13:23:45 <Cale> That's not part of the FFI spec though.
13:24:49 <Cale> Note: adding a finalizer to a ForeignPtr using addFinalizer won't work as well as using the specialised version addForeignPtrFinalizer because the latter version adds the finalizer to the primitive ForeignPtr# object inside, whereas the generic addFinalizer will add the finalizer to the box. Optimisations tend to remove the box, which may cause the finalizer to run earlier than you intended. The same motivation justifies the existence o
13:24:49 <Cale> f addMVarFinalizer and mkWeakIORef (the non-uniformity is accidental).
13:24:57 <RyanT5000> yeah, i read  that
13:27:27 <kpreid> dsacode: lookupND k l = case dropWhile ((/= k) . fst) l of (found:more) | any ((== k) . fst) more -> error "duplicate" | otherwise -> Just found; [] -> Nothing
13:28:40 <dsacode> kpreid: thanks!
13:32:47 <CosmicRay> I've got some trouble with HaXml parsing what I believe to be a UTF-8 XML document
13:32:52 <CosmicRay> is anyone able to help me with that?
13:32:57 <dsacode> kpreid: sorry, but your function does not match [(String, Bool)] -> Maybe Bool
13:33:08 <CosmicRay> The problem may not be HaXml so much as the generic Haskell input layer
13:33:13 <dsacode> kpreid: hugs report that it's  [(String,Bool)] -> [([(String,Bool)],a)] -> Maybe ([(String,Bool)],a)
13:34:32 <kpreid> I see
13:34:46 <dsacode> kpreid: oops.. that was my problem.. there's other thing..
13:34:53 <dsacode> *** Expression     : dropWhile (flip (/=) k . fst) l
13:34:53 <dsacode> *** Term           : flip (/=) k . fst
13:34:53 <dsacode> *** Type           : ([(String,Bool)],a) -> Bool
13:35:01 <kpreid> dsacode: try this: let lookupND k l = case dropWhile ((/= k) . fst) l of (found:more) | any ((== k) . fst) more -> error "duplicate" | otherwise -> Just (snd found); [] -> Nothing
13:35:02 <dsacode> oops, sorry for long pasting..
13:35:26 <Cale> lookupND x xs | ys = [] = Nothing | ys = [y] = Just y | otherwise = error "lookupND: duplicates" where ys = filter ((== x) . fst) xs
13:35:53 <Cale> er, actually
13:36:08 <Cale> no, that's right
13:36:22 <kpreid> I like that better than mine
13:36:31 <aFlag> is there a simple way for me to print out the different values that a function uses for debugging purposes?
13:36:41 <Cale> er, no
13:37:04 <Cale> lookupND x xs = case ys of [] -> Nothing; [y] -> Just y; _ -> error "lookupND: duplicates" where ys = filter ((== x) . fst) xs
13:37:06 <Cale> there
13:37:08 <aFlag> so far I've been using the error function, but it stops after the first iteration :(
13:37:18 <Cale> I've been sort of lightheaded today :)
13:37:21 <int-e> trace, maybe
13:37:27 <CosmicRay> how, specifically, can I read a UTF-8 file in Haskell, with it handling the leading byte-order marks and everything?
13:38:12 <Cale> might need another semicolon if you want to squish it all on one line like that, but you get the idea
13:38:13 <int-e> you wait for someone to get an UTF8 module into the base libs?
13:38:31 <CosmicRay> int-e: heh.
13:38:53 <Cale> CosmicRay: you write such a library yourself and submit it to the libraries list :)
13:38:57 <CosmicRay> bah
13:39:04 <CosmicRay> I'm busy writing libraries already ;-)
13:39:12 * CosmicRay is writing a podcatcher
13:39:23 <CosmicRay> and some idiots are publishing their RSS feeds in UTF-8
13:39:36 <CosmicRay> and HaXml croaks on the 3-byte UTF-8 byte-order indicator at the start of the files
13:39:39 <CosmicRay> grmbl.
13:39:41 <Cale> I don't think we have anyone around who is knowledgeable enough on Unicode to write proper unicode support. It's really quite complicated.
13:40:04 <Cale> you could just drop 3 Chars ;)
13:40:04 <kpreid> hmf
13:40:12 <CosmicRay> I thought that we had 32-bit Char for unicode?
13:40:15 <CosmicRay> and that hugs already did it somehow?
13:40:17 <kpreid> UTF-8 is pretty messy but straightforward to decode
13:40:27 <Cale> We do, it's just that the IO routines don't use it
13:40:30 <kpreid> Haskell has the wide chars
13:40:54 <kpreid> the hard parts are (a) using the right decoding and encoding in the right place, and (b) working with unicode text fancily
13:41:24 <kpreid> for what CosmicRay wants to do, all you need is (a), which is simple for a single program
13:41:56 <kpreid> (assuming HaXml doesn't fail to implement the XML 1.0 spec WRT character ranges)
13:42:01 <fanopanik> @type (.)
13:42:02 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
13:42:32 <fanopanik> bah
13:43:08 <Cale> Prelude> x <- getLine
13:43:08 <Cale> あ
13:43:08 <Cale> Prelude> x
13:43:08 <Cale> "\227\129\130"
13:43:32 <Cale> as you can see, it does no translation whatsoever
13:43:42 <CosmicRay> right
13:43:47 <CosmicRay> "\239\187\191<?xml v"
13:43:49 <CosmicRay> is what i've got
13:43:51 <kpreid> which just happens to be equivalent to Latin-1
13:43:52 <int-e> you can still implement a utf8 to utf8 cat :)
13:44:43 <Cale> CosmicRay: you could look for those specific chars and drop them if present
13:45:32 <Cale> sure it's a hack, but it'll work, and those are pretty unlikely characters
13:46:26 <CosmicRay> Interesting.  MissingH.Wash.Utility.RFC2279.decode will do this:
13:46:36 <CosmicRay> Prelude MissingH.Wash.Utility.RFC2279> take 10 d
13:46:36 <CosmicRay> "\239\187\191<?xml v"
13:46:36 <CosmicRay> Prelude MissingH.Wash.Utility.RFC2279> decode (take 10 d)
13:46:36 <CosmicRay> "\65279<?xml v"
13:46:49 <CosmicRay> so it's doing something.  not quite sure how it's useful.
13:46:50 <kpreid> (it'll work until someone uses a character above U+007F in the XML content)
13:47:42 <Cale> kpreid: well, depends on how exactly you need to process that character, if all you're doing is copying it as UTF-8, it'll probably work
13:47:49 <kpreid> CosmicRay: that looks like a correct BOM
13:48:04 <Cale> (with some random brokenness :)
13:48:06 <kpreid> CosmicRay: so HaXml should accept it if it's a correct XML parser
13:48:24 <CosmicRay> kpreid: the \65279, you mean?
13:48:42 <kpreid> CosmicRay: yes
13:48:43 <Cale> kpreid: does XML say anything at all about the character encoding?
13:48:50 <kpreid> Cale: yes
13:49:14 <kpreid> a document can specify its own encoding, for example
13:49:21 <kpreid> and there are various rules
13:49:52 <kpreid> so a correct XML parser needs to receive (something equivalent to) the un-decoded bytes and decode them itself based on the standard encoding-determining routine
13:49:53 <Cale> that seems slightly silly to me, I'd think of it as an orthogonal issue
13:50:31 <Cale> Doesn't that hideously complicate the XML spec?
13:50:42 <kpreid> Only in one section. :)
13:50:52 <Cale> Since it would have to subsume basically every character encoding spec in existence?
13:50:56 <kpreid> (disclaimer: I haven't read up on this recently; I may be wrong about the details)
13:51:19 <Cale> CosmicRay: where is quux.org?
13:51:34 <kpreid> Cale: well, an XML parser is only *required* to support UTF-8 and US-ASCII
13:51:40 <kpreid> see the spec :)
13:51:56 <Cale> ugh
13:52:10 <CosmicRay> Cale: try now
13:52:10 <kpreid> Cale: and yes, it is orthogonal, but it exists anyway to support things like xml document stored in metadata-less filesystems
13:52:43 <Cale> CosmicRay: seems to be working, thanks :)
13:53:44 <CosmicRay> +unifrob = $
13:53:45 <CosmicRay> +    encode . (\x -> if ord (head x) >= 60000 $
13:53:45 <CosmicRay> +                       then tail x
13:53:45 <CosmicRay> +                       else x) . decode
13:53:48 <CosmicRay> that seems to have fixed it
13:53:59 <CosmicRay> ignore the dollar signs and plusses, they're from darcs...
13:54:22 <RyanT5000> >= 60000?
13:54:30 <RyanT5000> that looks really, really suspicious
13:54:34 <CosmicRay> RyanT5000: I know nothing at all about unicode ;-)
13:54:40 <RyanT5000> lol
13:54:41 <CosmicRay> what values do I really want to look for?
13:54:47 <Cale> RyanT5000: he's looking for the BOM
13:55:00 <RyanT5000> i dunno
13:55:00 <CosmicRay> I figure that the document has no business starting with any other high-value unicode character either, if it's XML ;-)
13:55:11 <CosmicRay> it seems to be slightly different from file to file
13:55:13 <RyanT5000> lol probably true
13:55:32 <RyanT5000> i dunno, i just get scared when i see things like that :P
13:55:47 <CosmicRay> yeah, me too, but this is an RSS parser, so it can't be helped ;-)
13:55:53 <CosmicRay> RSS parsers are WAAAAAY more evil than this ;-)
13:55:56 <Cale> Well, it'll be some permutation of FEFF
13:56:04 <CosmicRay> FEFF?
13:56:15 <CosmicRay> oh, 0xFE, 0xFF or 0xFF, 0xFE?
13:56:16 <Cale> That's the unicode byte-order-mark
13:56:19 <CosmicRay> but it's three bytes.
13:56:23 <Cale> yeah, or FFFE
13:56:29 <Cale> etc.
13:56:33 <kpreid> CosmicRay: unicode codepoint U+FEFF
13:56:44 <kpreid> which in UTF-8 encoding is three bytes
13:57:14 <Cale> well, in other encodings it could be lots of things I suppose
13:57:32 <lispy> can arrows be used to 'automate' (or hide the details of) manual resource management?
13:57:41 <kpreid> note that it's only really a "byte order" mark in UTF-16, which is a two-byte encoding that can be in either order
13:57:42 <Cale> In UTF-16 it'll be either FEFF or FFFE depending on endianness
13:58:13 <kpreid> in UTF-8 it serves only to hint that the document is UTF-8 by recognizing the FEFF-encoded-in-UTF-8 sequence
13:58:16 <Cale> In UTF-8, it should always be EF BB BF
13:58:17 <kpreid> (AFAIK)
13:58:52 <RyanT5000> how do you do memory mapping with fps?
13:59:57 <lispy> RyanT5000: the last time i looked it used mmap and it would mmap the whole file at once
14:00:23 <lispy> RyanT5000: so a huge file could cause a huge chunk to be mmaped, but maybe that changed when dons optimized things
14:00:43 <RyanT5000> is mmap actually part of fps? or is it somewhere else?
14:00:50 <RyanT5000> i don't need FPS's functionality
14:01:05 <RyanT5000> i just need to somehow get FilePath -> Ptr a
14:01:50 <lispy> RyanT5000: mmap is a POSIX (iirc) function and so there is a haskell counterpart somewhere or you could use ffi
14:01:53 <lispy> @hoogle mmap
14:01:54 <lambdabot> No matches found
14:02:05 <RyanT5000> ah
14:02:09 <RyanT5000> what are the chances of it working on windows?
14:02:34 <lispy> windows has a memory mapping function but it's quirky (according to people i've heard discussing it)
14:02:43 <lispy> no idea what it's named
14:02:47 <RyanT5000> hm
14:02:51 <Cale> hehe, "while Unicode may need another plane for ideographic characters, there are ten planes available if previously unknown scripts with tens of thousands of characters are discovered"
14:03:04 <dsacode> If I've made declaration using "data" and "deriving", can i force my datatype derive another instance later in the code?
14:03:31 <Cale> dsacode: no, that counts as an instance
14:03:51 <Cale> or do you mean, can you add something to the deriving later?
14:04:06 <Cale> No, you have to add it at the data declaration
14:04:10 <sm> hurrah! first haskell app running!
14:04:15 <lispy> sm: congrats
14:04:30 <dsacode> Cale: if i declared datatype deriving Eq, can i say it to derive Eq late?
14:04:32 <dsacode> *later
14:04:37 <dsacode> *Show later
14:04:42 <sm> a wiki using HAppS
14:04:53 <RyanT5000> dsacode: you can later write an instance declaration yourself
14:04:57 <Cale> dsacode: only by adding Show to the list of things which it's deriving
14:05:06 <Cale> or writing an instance decl yourself, yeah
14:05:16 <dsacode> dsacode: if i made declaration, can I add it later in the code? :)
14:05:28 <Cale> dsacode: basically, no
14:05:28 <dsacode> or can i write instance that will use derive?
14:05:31 <lispy> dsacode: talking to yourself? ;)
14:05:39 <dsacode> lispy: oops )
14:05:44 <dsacode> lispy: feeling recursive today )
14:05:47 <RyanT5000> dsacode: the only way to have GHC derive it for you is to do it when you declare it
14:05:52 <lispy> dsacode: hah!
14:06:05 <lispy> what about DrIFT can  it derive later?
14:06:06 <dsacode> RyanT5000: i use hugs.. there's no way?
14:06:17 <RyanT5000> i assume hugs is the same
14:06:21 <RyanT5000> (but i only use GHC)
14:06:26 <dsacode> that's bad :(
14:06:42 <Cale> dsacode: can't you just edit the data declaration?
14:06:53 <dsacode> RyanT5000: no :( that's basic problem..
14:06:55 <Cale> There are only so many classes which you can derive like that for data anyway
14:07:03 <dsacode> Cale, i mean :)
14:07:17 <Cale> and they're done in a fairly simple way, which you could write yourself
14:07:35 <dsacode> Cale: i have declaration for derive Show, but I need also Eq, and i can't modify declaration
14:07:39 <dsacode> Cale: so there's no way?
14:07:46 <Cale> Just write an instance of Eq
14:07:55 <Cale> instance Eq Mytype where
14:08:03 <Cale>    A == A = True
14:08:08 <dsacode> Cale: yeah.. but with derive it is so short :)
14:08:31 <RyanT5000> well why can't you modify the original decl?
14:08:35 <Cale>    B a b == B x y = a == x && b == y
14:08:39 <Cale> and so on :)
14:08:42 <Cale> and then 
14:08:47 <Cale>    _ == _ = False
14:08:50 <CosmicRay> I have EF BB BF at the start of one of these XML files
14:08:52 <CosmicRay> what does that mean?
14:09:08 <CosmicRay> actually that's what they both are
14:09:12 <Cale> CosmicRay: that's a BOM in UTF-8
14:09:18 <dsacode> Cale: BTW, can't I see what code will haskell generate with `derive' and just paste it? :)
14:09:21 <Cale> http://en.wikipedia.org/wiki/Byte_Order_Mark
14:09:30 <CosmicRay> Cale: I thought that was supposed to contain FF and FE?
14:09:35 * CosmicRay reads the link
14:09:43 <Cale> CosmicRay: it does, encoded in UTF-8
14:09:51 <CosmicRay> ah.
14:10:29 <Cale> you can see all the possible encodings on that page
14:11:25 * CosmicRay tries:
14:11:29 <CosmicRay> unifrob ('\xef':'\xbb':'\xbf':x) = x -- Strip off unicode BOM
14:11:29 <CosmicRay> unifrob x = x
14:11:39 <CosmicRay> whoa, UTF-EBCDIC
14:11:41 <CosmicRay> that sounds EVIL
14:13:10 <RyanT5000> lol, yeah
14:14:51 <Cale> GB 18030 sounds more evil
14:15:12 <bringert> whoa, the new hope theme looks like crap in IE
14:15:18 <bringert> stupid browser bugs
14:15:39 <Cale> Who cares? Nobody uses IE anymore anyway ;)
14:15:51 <bringert> if only that were true
14:15:55 <RyanT5000> each XML document should just include a java program to decode it >.>
14:15:56 <RyanT5000> <.<
14:16:46 <Cale> ◑_◑
14:16:46 <int-e> it's 0xFFFE encoded in UTF8 format
14:16:54 <int-e> arg, ignore that
14:19:23 <RyanT5000> i take back what i just said.  each xml document should include a program written in 1 of 30 different bytecode systems, with absolutely no header describing which one it's using
14:22:49 <Cale> RyanT5000: You'll know that you guessed the wrong one because the program won't terminate :)
14:23:44 <RyanT5000> hell yeah
14:24:50 <RyanT5000> we should submit this to W3C
14:25:27 <Cale> It's a good thing that Unicode has a Latin Small Letter Sideways Diaeresized U (ᴞ), since I find myself needing those all the time.
14:26:02 <int-e> "hmm, given a countable, computable family of programs, exactly one of which terminates, find the index of the one that terminates" is computable.
14:26:22 <RyanT5000> int-e: true
14:26:35 <sieni> int-e: of course
14:26:54 <int-e> so what Cale suggests is actually doable, I expected something worse.
14:26:59 <RyanT5000> yeah me too :(
14:27:05 <RyanT5000> let's think of something worse :P
14:27:55 <RyanT5000> "the one that works uses a bounded amount of memory"
14:28:02 <RyanT5000> i think that "works"
14:28:04 <RyanT5000> by which i mean "doesn't work"
14:28:33 <RyanT5000> (specifically, only the one that works uses a bounded amount of memory)
14:28:52 <RyanT5000> that's computable, but only if you have an unbounded amount of memory
14:28:57 <RyanT5000> (i think)
14:29:11 <Cale> int-e: It has to be as ineffective for the task as possible while still being feasible.
14:29:32 <RyanT5000> lol true
14:29:46 <Cale> That's what XML is all about
14:29:50 <int-e> yes, you did quite well for that.
14:30:03 <RyanT5000> we can call it "Extensible Character Encoding"
14:30:18 <RyanT5000> and get it added to the list of mandatory character encodings for XML
14:30:20 <RyanT5000> it'll be awesome
14:30:30 <int-e> I'm beginning to believe that XML was just too good. People abuse it for a lot of stuff it wasn't designed for.
14:30:52 <genneth> maybe one day people will do that to haskell...
14:30:55 <Cale> The problem it solves is easy, and it does not solve it well.
14:31:06 <RyanT5000> right, i don't really see the point
14:31:33 <kaol> what I have heard of XML makes me think that they're trying to reimplement lisp
14:31:43 <rashakil> people already do it to haskell.  is that a bad thing?
14:31:45 <Cale> A scheme-like syntax would save a lot of typing too.
14:31:47 <RyanT5000> i've never  understood the logic behind using human readable data formats
14:31:59 <int-e> it's designed for markup. documents that are mainly text and are edited by humans. it's ok for that.
14:32:16 <RyanT5000> at least not as an end-goal
14:32:30 <int-e> But people use it for storing highly structured data (ADTs) in formats that are never looked at by humans.
14:32:40 <int-e> and that's just plain wrong
14:32:46 <RyanT5000> lol yeah
14:32:54 <Cale> MathML is an abomination
14:33:35 <Cale> It's neither readable nor writable by humans.
14:33:45 <sieni> RyanT5000: I thought that source code is a data format.
14:33:56 <stepcut> > let l = [1..4] in [ (i,j) | i <- l, j <- l]
14:33:57 <int-e> ok, maybe even markup could be done better, but at least in that context being redundant and seamlessly integrating text makes sence.
14:33:58 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
14:33:59 <stepcut> I need to do this operating in my code -- expect, my data type is not (and can not) be a member of the Eq class. Any Ideas? 
14:34:01 <int-e> *sense
14:34:03 <RyanT5000> sieni: source code isn't an end-goal
14:34:20 <stepcut> oops, wrong version
14:34:26 <RyanT5000> (sorry, i'm not being terribly specific)
14:34:36 <Cale> stepcut: hm?
14:34:38 <stepcut> > let l = [1..4] in [ (i,j) | i <- l, j <- l, i /= j]
14:34:40 <lambdabot>  [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
14:34:57 <Cale> stepcut: you could just zip with [0..]
14:35:06 <Cale> and then project out the second component
14:35:09 <stepcut> I have a list, and I want all the pairs of every element in the list. But I don't want an element pair with itself
14:35:16 <RyanT5000> what i mean is, i prefer to keep everything binary, and convert to/from human-readable only when humans are actually reading it
14:35:35 <stepcut> Cale: ah, yes -- that sounds pretty easy :)
14:35:55 <Cale> > let l = [1..4] in [(u,v) | (u,i) <- zip l [0..], (v,j) <- zip l [0..], i /= j]
14:35:56 <lambdabot>  [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
14:36:00 <stepcut> Cale: I knew I was missing something obvious :p
14:36:14 <int-e> Someone made a JVM bytecode to JavaScript 'compiler' by translating the bytecode to XML and then using XSLT to produce JavaScript. How crazy is that?
14:36:30 <stepcut> hah
14:36:33 <Cale> haha
14:36:46 <RyanT5000> lol
14:37:31 <RyanT5000> i bet that's really fast
14:38:05 <Cale> not to mention that what it's doing overall is completely silly
14:38:13 <RyanT5000> lol yeah
14:38:48 <int-e> http://www.xml11.org/ I think these people did that.
14:38:49 <lambdabot> Title: "XML11 - An Abstract Windowing Protocol"
14:38:49 <madpickle> i think that lines up nicely with the convo i ahd last night about people recreating compilers for old languages
14:39:43 <RyanT5000> oh god
14:39:48 <RyanT5000> XML windowing system
14:39:48 <RyanT5000> wtf
14:40:20 <bolrod> O_O
14:40:27 <palomer> woof
14:40:56 <bolrod> what's with XML anyway...  it seems like a buzzword for solving compatibility issues .. 
14:41:20 <RyanT5000> i dunno, i think it's because people refuse to open-source their datastructure code
14:41:21 <int-e> we lift the compatibility issues to a higher level and increase bandwidth and storage usage
14:41:23 <bolrod> any GOOD use of XML would be formatting documents!
14:41:25 <bolrod> but noooo
14:41:26 <JohnMeacham> bolrod: It's useless. don't spend brain cells on it.
14:41:37 <int-e> oh, and processing power requirements. what can be wrong with that?
14:41:53 <bolrod> like..  for openoffice vs. M$ office
14:41:55 <RyanT5000> nothing! we'll always be able to buy chips with higher clock speeds!
14:42:08 <bolrod> not really I guess
14:42:09 <RyanT5000> oh wait, no we can't
14:42:16 <palomer> xml stands for "xtremely mild lullaby"
14:42:34 <RyanT5000> @palomer xml stands for "xtremely mild lullaby"
14:42:35 <lambdabot> That's nuts!
14:42:41 <RyanT5000> gah, you can't add palomers?
14:42:46 <bolrod> I had to learn it for Databases...  I hope I don't have to do the re-test..
14:42:48 <int-e> it's a markup language, dangit
14:43:00 <bolrod> I didn't really learn it.. it hurt my brain after 3 pages
14:43:01 <RyanT5000> in what way is XML related to databases?
14:43:10 <int-e> it's not 'tree structuring language'
14:43:15 <bolrod> because you can create a stupid database in XML
14:43:17 <bolrod> don't ask me why
14:43:24 <bolrod> and use XPath to query it
14:43:30 <bolrod> or SQL/XML or something
14:43:30 <RyanT5000> lol, i'm well aware you can create a stupid database in xml
14:43:36 <int-e> IOW you have a searchable ADT?>
14:43:38 <Cale> <image width="512px" height="710px"><pixel colourspace="http://w3.org/TR/ximage/rgb.csp" red="50%" green="30%" blue="5%"> ...
14:43:39 <int-e> great :)
14:43:55 <RyanT5000> that's disgusting
14:43:58 <Cale> hehe
14:44:06 <Cale> oh, forgot the /
14:44:09 <bolrod> I guess XML uses up 100 times more space then just a good format
14:44:25 <Cale> (but that's obviously a joke :)
14:44:34 <int-e> Cale: oh, that seems a bit worse than RXML
14:44:35 <sieni> bolrod: can't you just gzip it? ;-)
14:44:54 <int-e> (this RXML: http://www.codu.org/rxml.php)
14:44:56 <lambdabot> Title: "Codu - RXML"
14:45:17 <bolrod> I think we need to come up with something better
14:45:31 <int-e> sieni: that's not a joke
14:45:48 <madpickle> xml has its place in modern languages that support it with libraries; it saves you the hassle of writing binary file formats for trivial things like data stores that don't warrant a full-blown RDBMS databases
14:45:51 <int-e> sieni: zlib + XML. people do that.
14:46:06 <madpickle> it's not The End All And Be All, IMO
14:46:10 <madpickle> but it's not 'useless' either.
14:46:54 <int-e> I think it's a bad thing because it prevents everyone from coming up with something better. why? because XML already does it well enough for almost everyone.
14:46:56 <RyanT5000> madpickle: why not just use a decent serialization lib like SerTH or .NET?
14:47:13 <madpickle> assume you're using or have access to either.. i'm not saying don't
14:47:14 <RyanT5000> and then re-use your data code
14:47:21 <madpickle> but .NET seems like quite a package to lug around with
14:47:27 <RyanT5000> sure
14:47:49 <madpickle> i could use delphi's internal object serialization to stream object properties to a file
14:47:53 <bolrod> anyway.. did you read the post about patents on slashdot?  about how you cannot get a patent for something 'obvious'
14:48:00 <madpickle> but in all honesty, xml would just be cleaner for simpler stuff
14:48:18 <madpickle> it doesn't scale, IMO
14:48:26 <Cale> a scheme-like format would have ~50% of the overhead
14:48:29 <RyanT5000> madpickle: perhaps, but i think that's mostly only true when you're marking up text
14:48:44 <madpickle> you can't say: "Ok, this frame in my binary file is XX bytes long, so if I want the i'th item, I just add the header + FrameSize * i to get the cursor pos"
14:48:44 <RyanT5000> if you don't need to store any strings, XML has almost no advantages
14:49:21 <bolrod> it's enterpricey
14:49:25 <madpickle> with xml you don't *really* have thato ption
14:49:34 <madpickle> so i just say: pick whatever you like best, provide you with the best option
14:49:38 <madpickle> what ever that might be =)
14:50:15 <bolrod> and it's really buzzword like, Web2.0,XML.. etc. :)
14:50:41 <madpickle> imo it's a convenience
14:50:45 <madpickle> but it does have niceties
14:51:14 <madpickle> take a .dtd file or whatever and feed it to delphi and it generates an interface that lets you interact with it in a nice and OO way
14:51:34 <bolrod> well.. I read a bit about the XML.. and it has 'namespace'
14:51:50 <bolrod> so you have  http://something.something.ha/something_else   as namespace..
14:52:06 <bolrod> ;/   it's not a website or anything.. it uses that as a namespace?!
14:52:18 <madpickle> i don't use it for web services or similar stuff
14:52:25 <madpickle> merely for data storage locally for programs
14:52:30 <int-e> it's a unified resource identifier
14:52:54 <int-e> that says nothing about how you're gonna use it
14:53:04 <RyanT5000> the http part confuses me
14:53:44 <Cale> It's usually an actual document on a webserver
14:53:54 <Cale> like a dtd
14:54:03 <bolrod> well... here it sais it's not ;/
14:54:06 <Cale> (If I get what you're talking about)
14:54:41 <madpickle> i think the namespace he refers to define the constraints and syntaxtical/semantical usage of the document it's in
14:54:48 <Cale> For example, http://www.w3.org/1999/xhtml is the namespace for xhtml
14:54:49 <madpickle> it usually points to somewhere on w3c.org
14:54:49 <lambdabot> Title: "XHTML namespace"
14:54:52 <Cale> you can use that URL
14:54:53 <madpickle> yeah
14:54:55 <madpickle> exactly
14:55:00 <madpickle> that kinda shit
14:55:18 <Cale> It's not *necessarily* a URL
14:55:27 <int-e> It works a bit like sun's package hierarchy stuff, but it's more honest about it. ;)
14:55:30 <sieni> Have you noticed, that if a multithreaded Windows application exits and some threads are waiting in a system calls, then sometimes such a system call might return and the thread resume executing for a while
14:55:37 <Cale> but conventionally, it's a URL pointing at information about the document type
14:55:45 <sieni> talk about stupid OS design
14:55:48 <bolrod> yes.. but there is nothing useful on that site that xml would use
14:56:05 <Cale> bolrod: It's for a human to read
14:56:13 <RyanT5000> sieni: i wish i were more surprised by that
14:56:20 <Cale> XML uses the string to define which namespace it's in
14:56:25 <madpickle> sieni: well, if i understand you right, it's the developers' fault
14:56:35 <madpickle> like they are at WaitObject() or holding out on a SendMessage() or something
14:56:43 <int-e> xml cares about languages and character encodings ...
14:57:00 <int-e> it's really meant for humans in many ways
14:57:42 <Cale> XML-based languages which are not meant to be read and written by humans are probably better off not existing
14:58:22 <madpickle> i use it because it provides a fairly clean way to store data
14:58:33 <madpickle> who wants to go back to stuff like .INI or classic .CONF files?
14:58:53 <int-e> me
14:58:58 <madpickle> for data storage?
14:59:04 <madpickle> [header]
14:59:08 <madpickle> name=value
14:59:09 <madpickle> ....
14:59:10 <madpickle> O.o
14:59:17 <bolrod> I'll figure of a better way to store something one day!
14:59:19 <int-e> beats xml in readability
14:59:21 <int-e> *shrugs*
14:59:23 <madpickle> yes
14:59:25 <sieni> madpickle: I'm talking about the application not really exiting, when you return from main(), but some threads that are blocking in some API calls continue execution with some error value at least for some time
14:59:27 <madpickle> i said data storage
14:59:39 <madpickle> sieni: hrmm.. strange
14:59:46 <int-e> for data storage I don't care at all what it looks like; I want something compact, binary
14:59:50 <Cale> If I need to store some configuration, and I'm lazy, I'll usually just print the data structure to a file and then read it back later.
15:00:04 <bolrod> What about an interface with perl.. where you just define loads of variables!
15:00:10 <madpickle> uh
15:00:12 <madpickle> no.
15:00:25 <bolrod> hehe ;p
15:00:28 <madpickle> i suppose it depends on what you're doing
15:00:36 <madpickle> i'd probably do .conf or .ini or binary on a *NIx system
15:00:50 <madpickle> simply because i'd probably end up doing something in C
15:00:58 <sieni> madpickle: it's similar to the fact that a segfault only kills the offending thread and not the whole process on windows
15:01:10 <qwr> s-expressions are quite nice structured data
15:01:12 <sieni> which is a known fact
15:01:31 <Cale> Or a directory filled with files whose names are the names of the variables I'm storing, and whose contents are the values.
15:01:32 <neologism> qwr: you consider s-expressions readable?
15:01:39 <qwr> why not?
15:01:47 <Cale> The filesystem is a database, why not use it?
15:01:54 <bolrod> :)
15:02:02 <madpickle> because try doing 'ls' on a directory with a couple hundred k files in it
15:02:04 <bolrod> it's a simple but effective one.
15:02:10 <Cale> madpickle: works just fine :)
15:02:16 <bolrod> madpickle: ls | grep
15:02:22 <Cale> (Mind you, I'm using reiser4)
15:02:25 <madpickle> ah
15:02:28 <qwr> although almost anything is more readable than xml...
15:02:37 <madpickle> how do you go about defragging? did they ever work that one out in reiser?
15:02:52 <bolrod> well.. if you try to rm  100.000 files at once.. it may be a bit too much
15:02:54 <madpickle> (can you tell i've not used it in a while?)
15:03:04 <Cale> There's supposed to be a repacker now
15:03:10 <madpickle> heh
15:03:13 <Philippa> I forget what the max files/dir is in FAT32 and NTFS
15:03:25 <Cale> but I haven't had any problems
15:03:29 <RyanT5000> Philippa: there "isn'tt one" in NTFS
15:03:41 <bolrod> who stores 10k+ files in one dir anyway
15:03:50 <RyanT5000> and i think there also "isn't one" in FAT32, but FAT32 gets really slow at like 1000
15:03:57 <wilx> I do :)
15:04:04 <neologism> bolrod: if its posible people will surely use it
15:04:10 <madpickle> http://en.wikipedia.org/wiki/Ntfs
15:04:14 <madpickle> Max number of files	4,294,967,295 (232 - 1)
15:04:16 <bolrod> I'm using Ext3.. is it possible there? :)
15:04:18 <Cale> bolrod: people using the FS as a database
15:04:18 <wilx> It is not hard to get that many pics in a day...
15:04:21 <madpickle> whether that's in a dir
15:04:22 <madpickle> or total
15:04:53 <bolrod> I guess its total
15:05:09 <bolrod> > 2^32
15:05:10 <lambdabot>  4294967296
15:05:26 <bolrod> hrm.. it's one short
15:05:42 <RyanT5000> must use 0 or -1 as a special value
15:06:09 <bolrod> oh so every file has a number? :)
15:06:17 <madpickle> it's a B+ tree
15:06:29 <RyanT5000> bolrod: your guess is as good as mine
15:06:30 <madpickle> not sure how it's stored internally
15:07:50 <bolrod> http://video.google.com/videoplay?docid=-3941555583115891108&q=hard+disk
15:07:51 <bolrod> woah
15:07:52 <lambdabot> Title: "Hard Disk Working / How a HardDisk Works - Google Video"
15:08:40 * int-e glares at jhc
15:08:41 <bolrod> sometimes it's so fast.. you can barely see it :p
15:09:20 <RyanT5000> lol that's kinda cool
15:09:33 <RyanT5000> that's why western digital makes money on its RaptorX line :P
15:09:41 <bolrod> :)
15:10:18 <int-e> JohnMeacham: I have a haskell program for which jhc generates a /* ERROR: convertVal: (t1207 ) */ in its C output, are you interested?
15:10:20 <RyanT5000> i wonder at what rate sectors are dying on the hdd in that video
15:11:08 <bolrod> hehe :)
15:11:22 <bolrod> well.. there are people that manage to get a plexiglas cover on it
15:11:35 <RyanT5000> yeah, although they probably kill some sectors in the process
15:11:42 <bolrod> http://video.google.com/videoplay?docid=-5178729455996645996&q=hard+disk  << or you could demolish it and do this :)
15:11:44 <lambdabot> Title: "Hard Disk Speaker (We made a Speaker out of a Hard Drive!!) w00t! - Google Video"
15:11:54 <bolrod> well.. some are really handy and don't kill any sectors ;)
15:11:55 <RyanT5000> lol yeah
15:12:02 <RyanT5000> :P
15:14:38 <bolrod> http://video.google.com/videoplay?docid=-744683267829297106&q=hard+disk << some explanation
15:14:40 <lambdabot> Title: "Hard drive in Action - Google Video"
15:15:04 * bolrod shoves a lambda up lambdabot's bot
15:16:59 * SamB thinks he might be missing the fonts needed for JHC output to display properly?
15:17:19 <stepcut> bolrod: khrack:/var/log/process.builder# ls -1 | wc -l
15:17:19 <stepcut> 59453
15:18:18 <bolrod> aha..
15:18:43 <bolrod> that's the cool thing about terminals
15:18:49 <bolrod> you don't see the mess when you don't want to
15:18:50 <bolrod> ;)
15:19:40 <stepcut> bolrod: yeah, but it still took several seconds for it to come up with that total :)
15:19:51 <bolrod> weird
15:20:06 <bolrod> what FS?
15:24:01 <stepcut> bolrod: heh, I reiser3 I think
15:25:35 <stepcut> the worst performance I have seen for lots of files in a directory is umsdos
15:25:49 <bolrod> now creating 100000 files with touch
15:25:58 <bolrod> takes a long time
15:26:52 <bolrod> and it will take another while as well ;/
15:33:31 <Cale> It takes even longer if you use dd to fill them with 1k of random data :)
15:35:09 <SyntaxNinja> Halfs has a directory cache so creating lots of files w/ touch is pretty fast... unless it would overflow the heap or something :)
15:42:10 <bolrod> time ls -1 | wc -l
15:42:10 <bolrod> 100001
15:42:10 <bolrod> real    0m0.428s
15:42:26 <bolrod> Cale: ofcourse ;)
15:43:04 <bolrod>  /dev/random is very slow..
15:43:17 <Cale> not /dev/random, /dev/urandom
15:43:23 <bolrod> but goes 10 times faster when you keep moving your mouse :)
15:43:31 <bolrod> urh
15:43:39 <Cale> You should never use /dev/random for frivolous things
15:43:53 <Cale> or you'll use up all your entropy
15:44:04 <bolrod> eh?
15:44:07 <stepcut> hehe
15:44:17 <SyntaxNinja> and there's only so much entropy.
15:44:23 <SyntaxNinja> mostly caused by shapr
15:44:26 <bolrod>  /dev/random is as random as your computer can get..
15:44:42 <int-e> /dev/urandom is usually good enough
15:44:46 <Cale> the system stores noise generated by device drivers
15:44:54 <int-e> (for everything not security critical)
15:45:00 <Cale> and that's what feeds /dev/random
15:45:11 <bolrod> :)
15:45:30 <bolrod> I know someone who had to fill some hard disks 7 times with /dev/random  
15:45:45 <int-e> uhm
15:46:01 <SyntaxNinja> Oo
15:46:06 <bolrod> good the main board had some random number generator
15:46:14 <Cale> /dev/urandom uses pseudorandom generators along with small amounts of that entropy in order to provide a much faster pool of random data
15:46:27 <int-e> that might speed up the process a tiny little bit, yes
15:46:33 <stepcut> I once wrote a script that would cat /dev/urandom and look for swear words 
15:46:44 <bolrod> O_O
15:46:48 <kaol> did it find any?
15:46:59 <stepcut> that way I could post to the kernel mailing list and complain about the profainity that /dev/urandom generates ;)
15:47:07 <SyntaxNinja> stepcut: why not just write the swear words yourself? that seems awfully convoluted.
15:47:09 <AtnNn> lol
15:47:14 <kaol> or even any of Shakespeare's works?
15:47:19 <stepcut> kaol: found some -- took a while
15:47:34 <norpan> using urandom will eat up your entropy just as fast
15:47:53 <SyntaxNinja> grep 666 /dev/urandom
15:47:54 <SyntaxNinja> Binary file /dev/urandom matches
15:47:54 <norpan> it's just that it won't stop when there is not enough entropy left
15:47:56 <SyntaxNinja> OMG!
15:48:07 <bolrod> oh noe!
15:48:19 * int-e tries to find a four-letter-word
15:48:19 <Cale> norpan: oh?
15:48:36 <Cale> are you sure?
15:48:49 <Cale> That seems like a bad policy
15:48:52 <norpan> yes, they take from the same entropy pool
15:48:53 <bringert> there must be lots of fun stuff in the digits of pi. who can find the first haiku?
15:49:01 <Cale> Well, yes
15:49:02 <ricebowl> is there an easy way to pad a string to a certain length?
15:49:14 <Cale> but there's no reason for urandom to take it at the same rate
15:49:29 <norpan> it takes it at the rate you request it
15:49:29 <ricebowl> I guess just let pad s n = s ++ (replicate ((length s) - n) ' ')?
15:49:39 <bolrod> something like that yes
15:49:41 <ricebowl> er, n - (length s)
15:49:44 <int-e> actually I'd expect urandom to just consume excess entropy from the entropy pool
15:49:45 <Cale> It could take a random number denoting a length and a seed, and generate length random values from that seed.
15:49:48 <ricebowl> is there no function already? :P
15:49:53 <Cale> pseudorandom*
15:49:54 <Excedrin> wow! strings /dev/urandom just said "ODD"
15:49:56 <bolrod> finding 6666 takes considrably longer :)
15:49:56 <stepcut> the difficulty is that the odds of generating a specific four letter work is 1 in ((2^32) - 1)
15:50:14 <stepcut> bolrod: 256 times longer on average ;)
15:50:20 <bolrod> ;p
15:50:43 <int-e> (and indeed taking a few bytes from /dev/random while consuming /dev/urandom worked immediately, for 20 odd bytes)
15:50:56 <Cale> int-e: yeah
15:51:03 <bringert> it would be more efficient to look for 0x6666
15:51:05 <Excedrin> wow it says "2 pm" so something ODD will happen at 2 pm!
15:51:09 <Cale> That's more the behaviour which I recall :)
15:51:29 <stepcut> bringert: heh
15:51:31 <bolrod> you're joking!
15:52:22 <bringert> what hex swearwords are there?
15:52:36 <bringert> fac doesn't count
15:52:49 <bolrod> fag ?
15:52:54 <bolrod> ass
15:53:03 <int-e> hmm, for the java loathers out there: cafebabe
15:53:11 <bolrod> ?
15:53:25 <bringert> boldrod: those aren't hex digits
15:53:27 <int-e> look at the first few bytes of a java class file when you get a chance
15:53:30 <Philippa> I'm more likely to end up in a good pub myself
15:53:50 <bolrod> oh
15:54:05 <Philippa> though A55 works if you read 1337
15:54:08 <bolrod> a44
15:54:15 <bolrod> yes :)
15:54:17 <bringert> Philippa: good one
15:54:31 <Igloo> Would you let me have cac?
15:54:39 <Philippa> heh
15:54:49 <int-e> 45054 works as an insult in German (if written in hex)
15:55:03 <Igloo> faece? (singular of faeces  :-)  )
15:55:06 <bolrod> what's that? :)
15:55:11 <bolrod> haha
15:55:34 <bringert> there must be some that don't use phonetic spelling or 1337-speak
15:55:47 <norpan> foofc7c8
15:55:53 <norpan> f00fc7c8 i mean
15:55:59 <Philippa> but you don't want to use that for debugging whether memory's been freed or not because you'd prolly have 00faece5
15:56:08 <Philippa> which might give people the wrong impression
15:56:08 <int-e> (it's 0xAFFE)
15:56:19 <norpan> my cousin's name is affe
15:56:23 <bringert> a and e are frequent vowels, but bcdf  are not some frequent
15:56:24 <int-e> which is an ape
15:56:42 <norpan> in german yes
15:56:46 <madpickle> 0xc0ffee
15:56:46 <int-e> and calling people by animal names is usually insulting
15:56:48 <bringert> s/some/so/
15:56:48 <madpickle> 0xdecaf
15:56:52 <madpickle> 0xdeadbeef
15:56:53 <int-e> deadface
15:56:54 <madpickle> 0xdeadc0de
15:57:02 <Philippa> or the unfortunate deadbed
15:57:02 <bringert> 0xDECAFBAD
15:57:03 <madpickle> 0xfacade
15:57:07 <madpickle> 0xbabb1e
15:57:13 <madpickle> 0xdebac1e
15:57:19 <bolrod> BEEFCACE
15:57:20 <int-e> deadbea1
15:57:34 <madpickle> 0xacc01ade, 0xb01dface, 0xc0bb1e
15:57:36 <int-e> fee1dead
15:57:38 <bolrod> we need the K..
15:57:43 <Igloo> Maybe we should coin one
15:57:46 <bolrod> > ord 'F' - ord 'K'
15:57:47 <lambdabot>  -5
15:58:16 <norpan> 0xba1dbabe
15:58:22 <Excedrin> 0xfece5
15:58:25 <madpickle> lol
15:58:25 <bringert> "shut up, fbaffe!"
15:58:29 <madpickle> feces
15:58:31 <madpickle> i like that one
15:59:11 <norpan> fece5 is literally the shit
15:59:37 <norpan> it's time for 0xbed
15:59:45 <norpan> good night
15:59:48 <int-e> cea5e & de5151
15:59:50 <bolrod> good night
15:59:55 * int-e gives up
15:59:58 <Excedrin> efb
15:59:59 <bringert> bad f00d: beef, decaf, dead babe
15:59:59 <int-e> good night bolrod 
16:00:09 <bolrod> ?
16:00:24 <int-e> good night norpan 
16:00:29 <bolrod> well.. I could go to sleep yes...
16:00:35 <int-e> bolrod: I messed up the context.
16:01:48 <bolrod> or you could read everything as 1337 in binary
16:01:54 <bolrod> that would sure make live alot happier
16:01:57 <bolrod> :)
16:02:05 <bolrod> argh
16:02:06 <bolrod> life
16:02:11 <bolrod> maybe it is time for bed
16:02:18 <int-e> l1fe
16:02:23 <int-e> deadl1fe
16:02:24 <int-e> hmm.
16:02:46 <bolrod> dead012a1ife
16:03:07 <bolrod> you could make 12 of R
16:03:19 <madpickle> you can do it in roman numerals
16:03:22 <madpickle> you're so MCCCXXXVII!
16:03:30 <bolrod> erh
16:03:37 <int-e> I've been told that people actually used L and O for binary digits.
16:04:00 <int-e> http://www.mcccxxxvii.com/
16:04:02 <lambdabot> Title: ""
16:04:53 <int-e> also, http://bash.org/?654674
16:04:54 <lambdabot> Title: "QDB: Quote #654674"
16:04:57 <bolrod> storing binaries as ascii for human readability would be cool
16:05:21 <madpickle> heh
16:05:50 <bolrod> hehe :)
16:06:03 <bolrod> everything would take up 8 times as much space.. but hey!  
16:06:17 <int-e> uh, we can do better than that
16:06:25 <bolrod> Unicode?
16:06:34 <int-e> we can make it application-agnostic using XML
16:06:40 <bolrod> ofcourse!
16:06:49 <int-e> <digit base=2 value=0 />
16:06:55 <int-e> hmm.
16:07:00 <bolrod> <application> <bit one offset=1>1</bit>..
16:07:02 <int-e> we have a bootstrapping problem :)
16:07:13 <madpickle> you could use BASE64
16:07:16 <madpickle> to store binaries as ascii
16:07:20 <madpickle> or UUENcode
16:07:39 <bolrod> bootstrapping?  no way!
16:07:45 <bolrod> we just need 5 MB bootloaders!
16:09:01 <bolrod> but this method of storing would allow comments inside the binary 
16:09:09 <bolrod> isntead of in the source code!
16:09:30 <bolrod> wow.. my typing is teh suxx0rz
16:10:33 <int-e> oh yes, I can see it: <!-- this is a hateful comment about lilo not being able to deal with xml -->
16:11:40 <bolrod> :)
16:11:41 <bolrod> rm *
16:11:41 <bolrod> -bash: /bin/rm: Argument list too long
16:11:43 <bolrod> :(
16:11:50 <int-e> ls | xargs rm
16:11:56 <stepcut> bolrod: :p
16:12:56 <bolrod> :)
16:15:24 <bolrod> or ssh in xml
16:15:44 <bolrod> <!-- here is the password, don't read --> ..
16:15:47 <bolrod> :)
16:15:57 <int-e> how old fashioned
16:16:34 <Cale> "Argument list too long" is such a stupid error message
16:16:34 <int-e> <!-- please be aware that by reading this you are violating the Digital Millenium Copyright Act -->
16:17:15 <bolrod> <!-- By reading this you agree with this sentence -->
16:17:18 <bolrod> 8)
16:17:23 <int-e> Cale: what's a poor shell gonna do?
16:18:00 <Cale> int-e: There just shouldn't be a limitation of that sort.
16:21:13 <Cale> It's the sort of obvious problem caused by some lazy C programmer allocating a fixed array of string pointers rather than using a linked list. (At least at some point in history, it might be a standard by now)
16:24:40 <bolrod> I concur
16:26:24 <madpickle> heh
16:26:26 <madpickle> is this about 'ls'?
16:28:02 <int-e> no, the kernel. bash could deal with the argument list
16:31:08 <int-e> but the kernel limits it to MAX_ARG_PAGES = 32 pages worth of vois * pointers, so 32k arguments on x86.
16:32:17 <int-e> (checked linux 2.6.14.2 and bash 3.1)
16:34:33 <iron32> Can anyone explain me the differences between data, type and newtype declarations ?
16:38:53 <int-e> data defines a new algebraic datatype with constructors. type is a type synonym; if you write type A = B, that means that whereever you write A you could as well write B instead, and vice versa.
16:42:00 <int-e> newtype  acts very much like  data  with just a single constructor that takes exactly one argumen as far as type checking is concerned; the main difference is that for  newtype X = X Int, X undefined is undefined, while for data X = X Int, X undefined and undefined are different things.  For the implementation that means the type constructor X doesn't have to be explicitely encoded anywhere.
16:48:10 <iron32> thanks int-e sorry I was in another window
16:51:21 <int-e> iron32: no problem. did that help?
16:55:01 <iron32> Yes it did thanks
16:55:45 <iron32> int-e How long you been programming in Haskell ? Sorry it is my clicher question I ask everyone I chat with on this channel 
16:57:10 <iron32> again sorry for the slow responses coding while chatting
16:57:25 <sjanssen> @keal
16:57:26 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
16:57:41 <sjanssen> fads . . .
16:57:45 <sjanssen> @google fads
16:57:47 <lambdabot> http://www.crazyfads.com/
16:57:48 <lambdabot> Title: "Crazyfads.com - Crazy Fads"
16:57:52 <int-e> heh, that's a hard question actually. I learned the language in 2002 but I let it rest for a few years and only came back to it a year ago.
16:59:07 <iron32> int-e : What brought you back to it ?
17:00:04 <int-e> it's just a nice language, and you can do a lot in a few lines of code with it.
17:02:57 <iron32> int-e: Well I am still trying to realize Haskell benefits of course only been at a month
17:04:51 <int-e> there's a lot to learn in Haskell, that's for sure.
17:06:13 <iron32> yes there is still working on Monads but I have made a lot of progress, when I think I have it down pat I will move onto Arrows and FRP
17:06:29 <dropdrive> I wish I could "look over the shoulder" of an experienced Haskell coder, just to see how they do things...
17:06:42 <iron32> dropdrive : Me too
17:07:11 <dropdrive> iron32: How might we accomplish this?
17:07:18 <int-e> @version
17:07:18 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
17:07:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:08:36 <iron32> drop drive: Well if you had a Haskell guru you might volunteer some of your time to their software projects in exchange for some mentoring
17:08:54 <iron32> drop drive: Well if you had a Haskell guru your area you might volunteer some of your time to their software projects in exchange for some mentoring
17:09:06 <dropdrive> iron32: good idea.
17:09:52 <int-e> you can look at other people's code (lambdabot is just an example, and probably not the best one), you can ask questions here. it's not perfect but it's not hopeless either.
17:10:15 <dropdrive> iron32: I wonder if people would make screencasts of themselves coding!  That would also end the whole which-IDE-should-I-use debate
17:11:00 <sjanssen> dropdrive: I believe there isn't a single answer for which IDE to use
17:11:18 <dropdrive> sjanssen: true, but when people ask, you can tell them to "go watch the screencasts!"
17:11:25 <sjanssen> I think most Haskeller's just program with Vi or Emacs (or other text editor)
17:11:31 <lorne> that almost souinds like a debate for #editor-wars
17:11:42 <iron32> dropdrive : well I like Eclipse myself but then I am a java guru ( not that that is something to be proud of or anything )
17:11:44 <int-e> @where hide
17:11:45 <lambdabot> http://haskell.org/haskellwiki/HIDE
17:12:45 <dropdrive> sjanssen/iron32: ack, I wasn't asking (I use emacs :-)) but I was just saying how people could actually /see/ the IDEs in question and not have to ask a whole bunch of questions...
17:13:03 <iron32> oh ok
17:13:47 <hyrax42__> @where conjure
17:13:47 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
17:15:15 <hyrax42__> :o
17:15:15 <hyrax42__> growing a tail
17:15:52 <iron32> dropdrive: So what you would like is maybe an IDE that could sync over the web maybe based on p2p
17:16:13 <iron32> so that everyone could watch an elite coder at work
17:16:47 <iron32> dropdrive:  Could also do remote pair programming :)
17:17:12 <sjanssen> I've never programmed Haskell with another person, I bet that'd be great fun
17:18:15 <iron32> Well I haven't done much pair programming period only brief spurts when helping out fellow students or co workers
17:19:42 <hyrax42> @google subethaedit
17:19:44 <lambdabot> http://www.codingmonkeys.de/subethaedit/
17:19:47 <hyrax42> ;)
17:19:49 <dropdrive> I wonder how easy it is to "broadcast" one's editor...
17:20:02 <hyrax42> (yes, I know macs are not common here)
17:20:32 <hyrax42> oh poo
17:20:36 <hyrax42> it's 4am
17:20:36 <Saulzar> There is some tool people around here have been using, gobby or gobber or something like that.
17:20:39 <hyrax42> 4.20 even
17:22:16 <psnl> pair coding in haskell is harder than it looks
17:22:36 <sjanssen> psnl: why is that?
17:22:56 <psnl> SimonRC and I end up looking over each other's shoulders a lot
17:23:13 <psnl> sjanssen: no idea why, though I could speculate
17:23:54 <iron32> I think pairing in Haskell would be easier because haskell is more concise
17:23:55 <dropdrive> Saulzar: a tool to do what?
17:25:18 <Saulzar> Collaberative programming
17:27:20 <iron32> Well a tool that would allow for remote collaberative programming over p2p would be awesome but I might lead to more outsourcing too
17:27:31 <Excedrin> using screen -x might be a nice way to teach programming in general
17:31:31 <dropdrive> well I don't know who'd ever want to collaborate with me, but watching others work--collaboratively or not--would definitely be interesting
17:33:38 <Saulzar> Collaboration on projects always seemed like a fun thing to me, though I always seem to persist on individual projects.
17:33:52 <SimonRC> One possibility for cooperation is clever uses of screen.
17:34:02 <SimonRC> oh, wait, that's been said
17:34:35 <mlh> libobby
17:35:50 <mlh> and gobby  - http://gobby.0x539.de/index.html
17:35:52 <lambdabot> Title: "Gobby"
17:38:41 <lorne> hello gvdm
17:39:14 <gvdm> hi
17:39:43 <mlh> @google gobby
17:39:48 <lambdabot> http://darcs.0x539.de/trac/obby/cgi-bin/trac.cgi
17:39:48 <lambdabot> Title: "obby - Trac"
17:39:57 <mlh> close enough
17:42:59 <iron32> well time to hit the Gym later all
17:55:40 <greenrd> Has anyone integrated lhs2TeX into lyx?
17:59:43 <greenrd> I've figured out how to create a new document class for lhs2TeX, but I can't work out how to get lyx to generate latex
18:00:22 <greenrd> it seems I need to create a converter in lyx (probably cat will do) but the prefs UI won't let me create one
18:12:00 <lispy> am i correct that finalizers aren't all that useful in practice?
18:13:01 <lispy> it seems that 1) you can't predict when the finalizer will run 2) there are issues with context and threading
18:13:44 <lispy> i bet #2 is rarely a problem but i can see #1 as very pesky
18:57:14 <mwc> Just wrote this: http://www.haskell.org/haskellwiki/Performance/Accumulating_Parameters can somebody check it for spelling, grammar, and typo's in the code?
18:57:16 <lambdabot> Title: "Performance/Accumulating Parameters - HaskellWiki"
18:58:14 * audreyt looks
18:58:25 <mwc> lispy, yeah, I find finalizers are really bad for reason 1. In C++, you use RAII to manage resources, and so you can always know when something will be destroyed. Garbage collection takes that out of your hands, and you pretty much have to manually clean up resources
18:58:36 <skew> well, your first reverse is quadradic
18:58:53 <mlh> mwc: typo's should be typos :-)
18:59:09 <audreyt> mwc: looks pretty decent
18:59:16 <mwc> that's why java had to add a finally block to their exception handling structure, afaik
18:59:35 <skew> It's not really fair to say the performance improvement is due to making it tail recursive
18:59:55 <mwc> skew, I don't see how it's quadratic
18:59:57 <mwc> looks linear to me
19:00:04 <mwc> since I'm not processing over any element twice
19:00:15 <mwc> or repeatedly
19:00:16 <skew> (++) is linear in the length of the first argument
19:00:20 <mlh> "Accumulating parameters are ..." should be "Accumulating parameters is ..
19:00:57 <skew> a ++ b has to walk down a building an equivalent list, so it can stick in b instead of [] at the end
19:01:37 <mwc> right, really I should be building a function tree to achieve that
19:01:39 <mwc> let me go fix that
19:01:47 <mwc> or a function list
19:02:00 <skew> That might complicate things
19:02:22 <skew> it's still a fine example of accumulating parameters
19:02:53 <mwc> yeah, I don't want to make that first version any more compicated
19:03:04 <mwc> since it would remove the clarity of what's going on
19:03:09 <mwc> let me think of a better example
19:03:16 <mwc> preferably one that doesn't involve ++ :P
19:04:56 <skew> Has anyone here looked much at Sheard's Omega?
19:05:53 <skew> I'm wondering what it adds over GADTs in GHC Haskell
19:07:11 <skew> So far only the type functions seem particularly new, and it seems proper integration of type classes (with functional dependencies) and GADT typechecking would give an equivalent of that
19:16:18 <skew> Hi Philippa
19:17:31 <skew> I've the reading "The Role of Type Equality in Metaprogramming" recently, and the examples work out quite nicely in GHC since the additions of GADTs
19:18:01 <lispy> mwc: so does haskell have any answer to this?
19:18:24 <lispy> i guess you can write functions like, withHandle :: (Handle -> IO ()) -> IO ()
19:18:37 <lispy> but taht's the only thing i can think of
19:20:30 <skew> or the thermonuclear version: http://okmij.org/ftp/Haskell/types.html#monadic-regions
19:20:32 <lambdabot> Title: "Haskell Programming: Types"
19:21:16 * Cale watches his 7.18 GiB torrent crawl along at 5 KiB/s
19:22:27 <Cale> reminds me of the days before DSL, only we were sane enough not to download things like this back then
19:31:13 <palomer>  7 gig torrent?
19:34:00 <dons> ?uptime
19:34:01 <lambdabot> uptime: 1 day, 16 hours, 55 minutes and 56 seconds
19:36:03 <mwc> so I fixed http://www.haskell.org/haskellwiki/Performance/Accumulating_Parameters
19:36:04 <lambdabot> Title: "Performance/Accumulating Parameters - HaskellWiki"
19:36:44 <mwc> lispy, as far as I know, you need to manually finalize the resources that you were using 
19:36:57 <mwc> close handles, etc.
19:37:53 <dons> nice mwc
19:37:59 <dons> (the wiki article)
19:38:59 <mwc> How can I add it into little box, it should go under techniques
19:40:35 <lispy> mwc: yeah, well you can write a function that does the cleanup by accepting a function that takes the resource as a parameter.  That seems to be the best way to go in haskell
19:41:28 <petekaz> mwc: why doesn't that tail recursive version of len overflow the stack?  Isn't the '1 + acc' accumulating thunks in memory?
19:42:06 <petekaz> If you are going to use tail recursion, shouldn't you make sure it's strict to avoid the very same problem you were trying to solve?
19:42:08 <mwc> petekaz, strictness analysis prevents taht from ahpepning
19:42:28 <petekaz> mwc: what's that?
19:42:43 <mwc> petekaz, basically, the function always needs the value of acc, so acc will be passed strictly
19:43:02 <mwc> I should mention that, good catch
19:43:58 <petekaz> I see.
19:44:50 <petekaz> Yeah, I do think that you should make it clear that tail recursion in a lazy language can be a Bad Thing if the function is not strict.
19:45:53 <petekaz> mwc: you can refer the reader to http://en.wikibooks.org/wiki/Haskell/List_Processing#Folds for more information (especially the "technical note" part).
19:49:35 <petekaz> mwc: I still don't get this strictness analysis you mention, and I do get a stack overflow with your code.
19:53:45 <petekaz> mwc: you there?
19:53:55 <mwc> yep
19:54:02 <petekaz> I think your code is wrong.
19:54:03 <mwc> just making a change to the wiki entry
19:54:15 <petekaz> I still get an overflow with your code.
19:54:23 <petekaz> with a list of 1,000,000 elements.
19:54:32 <mwc> hmm, I didn't get one with 2 million elements
19:54:35 <mwc> strange
19:54:38 <mwc> x86/Linux?
19:54:41 <petekaz> make it higher then.
19:54:45 <petekaz> yes.
19:57:13 <petekaz> But using `seq` in your code fixed the problem.
19:57:21 <petekaz> len' (x:xs) acc = let s = 1 + acc in s `seq` len' xs s 
19:57:46 <mwc> yeah, I've modified the code using $!
19:57:48 <mwc> same thing
19:58:06 <Cale> petekaz: that's just because it's building an expression like 1 + (1 + (1 + (...)))
19:58:22 <Cale> and then getting a stack overflow when it finally tries to evaluate it
19:59:16 <petekaz> Cale: I understand thanks.  I was actually questioning mwc's theory of strictness analysis.
19:59:26 <petekaz> I actually pointed that out to him :-)
19:59:35 <mwc> I thnk it only occurs at higher optimization levels
19:59:41 <petekaz> I see.
19:59:42 <palomer> > foldr (:) [1,2,3]
19:59:43 <lambdabot>  Add a type signature
19:59:56 * palomer slaps lambdabot
20:00:47 <dons> mwc, higher than -O ? or -Onot
20:00:58 <dons> pretty much everything's on at -O
20:01:18 <mwc> dons, I mean, at -O as opposed to no optimization
20:01:24 <dons> right
20:01:32 <Cale> petekaz: ah, sorry -- I'm only half following the conversation here :)
20:01:36 <palomer> > foldr (:) [1::Int,2,3]
20:01:38 <lambdabot>  <[Int] -> [Int]>
20:01:53 <mwc> anyways, I gotta run.
20:02:17 <mwc> I've posted a correct to deal with petekaz's comments
20:02:29 <petekaz> Regardless of ghc optimization, I think it's probably not a good idea for one to write tail recursive functions without a thorough understanding of what is most likely going to happen unless one's function is strict VS relying on a compiler optimization.
20:03:43 <palomer> (->) a b now instantiates Show ? 
20:03:45 <palomer> since when?!
20:03:52 <dons> yeah, bring on bang patterns
20:04:07 <petekaz> Yay.  I feel like I'm actually starting to "get" this weird language you call Haskell.
20:04:37 <dons> f (x:xs) !acc = f xs (1 + acc) -- or so
20:04:41 <dons> much nicer
20:04:56 <dons> actually, lets try this. i've got a bang patterns compiler sitting here
20:05:26 <petekaz> neat, so this is what the bang patterns are all about.
20:05:29 <petekaz> much nicer.
20:06:35 <dons> yeah, works nicely:
20:06:36 <dons> f []      acc = acc
20:06:36 <dons> f (x:xs) !acc = f xs (1 + acc)
20:06:46 <dons> almost Clean-ish
20:07:37 <petekaz> dons: I just noticed the patch for readNbytes for @url stuff.
20:07:49 <dons> yeah, i thought i better do it :)
20:08:27 <petekaz> I was going to attempt it this weekend, but it's probably best you did it.  It would have taken me forever.
20:08:36 <dons> we could probably just use the readN from fps, but this way is reasonable for our use
20:08:51 <dons> (reading a char at a time)
20:08:56 <dons> since we don't read much
20:10:29 <dons> oh my, i get to use the word "polymerization kinetics' in a comp sci paper
20:42:10 <JohnMeacham> int-e: yeah, that shouldn't happen. send me it.
20:42:49 <JohnMeacham> SamB: jhc assumes your terminal is utf8. I always thought it would be neat to make some sort of mozillaterm so you can run jhc in it and hover over values to get at their types..
20:43:51 <SamB> JohnMeacham: well, yes. but I think I'm missing some fonts that xterm needs to render its output...
20:44:00 <JohnMeacham> I recently posted this to the c-- list, which haskell implementers might be interested in: https://cminusminus.org/lists/pipermail/cminusminus/2006-June/000003.html
20:44:56 <JohnMeacham> SamB: odd, X11 should come with full unicode fonts. I use -misc-fixed-medium-r-normal-*-*-120-100-100-c-*-iso10646-1
20:45:26 <JohnMeacham> SamB: but an ascii option has been on my todo list for a while... there is also -dhtml which may or may not work.
20:47:07 * SamB checks it again
20:48:41 <SamB> okay, now it is showing lines but not curvey things. btw, I don't think those lines work very well with those curvy things outside of xterm...
20:52:12 <SamB> X certainly should come with that font, but I'm not sure if it *did*...
20:57:47 <SamB> I wish JHC wouldn't slow down ZSNES so much
21:00:26 <Cale> heh, file a bug ;)
21:00:39 <SamB> well... I don't think its a bug exactly
21:05:03 <RyanT5000> ok, so i want to implement cached files
21:05:05 <RyanT5000> something like
21:05:31 <RyanT5000> withFileData :: CachedFile -> (Ptr a -> IO b) -> IO b
21:06:10 <RyanT5000> i'm not exactly sure where to start
21:06:54 <SamB> hmm, it occurs to me that I probably need to restart xterm...
21:07:08 <RyanT5000> has anyone done anything like that?
21:09:40 <SamB> JohnMeacham: what does "xlsfonts -fn '-misc-fixed-medium-r-normal-*-*-120-100-100-c-*-iso10646-1'" output for you?
21:21:07 <JohnMeacham> -misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1
21:26:05 <lispy> JohnMeacham: are you a grad student/professor or a computer professional?
21:26:20 <lispy> (by computer professional i mean a developer)
21:41:12 <JohnMeacham> lispy: I work at a finance company at the moment. it has nothing to do with haskell.
21:41:35 <Pseudonym> Finance?!  That's like... suits.
21:42:07 <JohnMeacham> not at all. we wear shorts. I get to do fun math. the company is only like 70 people.
21:42:31 <Pseudonym> Ah, OK.  Fair enough.
21:42:45 <JohnMeacham> fqw.com
21:43:03 <RyanT5000> JohnMeacham:
21:43:03 <RyanT5000> Step 1: Finance
21:43:03 <RyanT5000> Step 2: Haskell
21:43:03 <RyanT5000> Step 3: ...
21:43:03 <RyanT5000> Step 4: Profit!
21:43:22 <dropdrive> Cale, do you have another puzzle for me?  (You asked about products of infinite lists last time I asked.)  A puzzle to help me fall asleep!
21:50:46 <Dino_> I'm working through the SOE book. At one point it says: zip :: (a -> b -> c) -> [a] -> [b] -> [c]
21:50:55 <Dino_> @type zip
21:50:57 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
21:51:17 <Dino_> Please tell me those types aren't the same in some way.
21:51:33 <sjanssen> Dino_: that function is actually called zipWith
21:51:37 <sjanssen> @type zipWith
21:51:38 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
21:51:44 <sjanssen> sounds like a typo
21:52:00 <Dino_> Ok, could be a typo in this para in the book.
21:52:54 <lisppaste2> Ronald Mai pasted "3d logic http://www.thatvideogamesite.com/fullscreen.php?id=392" at http://paste.lisp.org/display/21824
21:52:58 <psykotic> dino: they become the same when you curry by \a -> \b -> (a, b)
21:53:01 <Dino_> Ok, I see it actually listed in the errata online for the book.
21:53:32 <sjanssen> @type zipWith (,)
21:53:34 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:54:44 <RyanT5000> curry is such a great verb
21:54:50 <RyanT5000> it always makes me hungry
21:55:05 <Dino_> Ok. Very cool. Thank you.
21:55:17 <RyanT5000> if you think of functions as sauce, you can think of "currying" as adding the next ingredient
21:56:02 <Dino_> heh
21:56:32 <RyanT5000> i wonder if that metaphor has anything to do with us actually using that word
21:56:56 <RyanT5000> does it evoke that image for anyone else? or am i just unusually cullinarily inclined?
21:57:16 <skew> The word comes from the name Haskell Curry
21:57:22 <RyanT5000> yeah i know that
21:57:49 <RyanT5000> but, for me, the food metaphor gives it an extra potentcy
21:57:52 <skew> Perhaps his family name has something to do with food
21:58:44 * lispy always mentally swaps curry and uncurry
21:58:47 <lispy> @type uncurry
21:58:48 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
21:58:57 <lispy> > uncurry (1,2)
21:58:57 <lambdabot>  Couldn't match `a -> b -> c' against `(a1, b1)'
21:59:07 <lispy> > curry (1,2)
21:59:08 <lambdabot>  Couldn't match `(a, b) -> c' against `(a1, b1)'
21:59:25 <lispy> oh rightyou have to apply it to a function
22:00:21 <RyanT5000> > curry (,) (1, 2)
22:00:22 <lambdabot>  Add a type signature
22:00:27 <RyanT5000> huh?
22:00:49 <RyanT5000> > curry (,) (1::Int, 2::Int)
22:00:50 <lambdabot>  Add a type signature
22:01:01 <RyanT5000> @type curry (,)
22:01:02 <lambdabot> forall a b b1. a -> b -> b1 -> ((a, b), b1)
22:01:07 <skew> > uncurry (,) (1, 2)
22:01:08 <lambdabot>  (1,2)
22:01:18 <RyanT5000> gah!
22:01:24 <RyanT5000> i mentally swapped them
22:01:27 <RyanT5000> :(
22:01:56 <lispy> RyanT5000: yeah, see what i mean :)
22:02:43 <RyanT5000> yeah
22:02:54 <RyanT5000> although i use them all the time, without doing that :-/
22:03:02 <RyanT5000> i dunno
22:04:20 <bringert_> are there any web designers & CSS gurus here? if so, would you like to make a nice theme / many nice themes for a Haskell content management system that I'm working on? I'm talking about Hope: http://hope.bringert.net/
22:05:24 <JohnMeacham> Hmm. is it some sort of blogging software in haskell?
22:06:01 <lisppaste2> Ronald Mai annotated #21824 with "should be working " at http://paste.lisp.org/display/21824#1
22:06:09 <JohnMeacham> I have a few domains I need someting for. perhaps I will start a blog. repetae.net is my main page. but I also have notanumber.net which could make a good domain for something.
22:08:34 <bringert_> JohnMeacham: yes, it is a blog and a photo album at the moment. I've tried to make it general enough to allow adding other modules, like wiki, static pages, calendar, RSS aggregation, bug tracking, darcs interface etc. Noone's written those modules yet though.
22:10:18 <lispy> JohnMeacham: i would probably follow your blog if you had one, i've noticed on the mailing list you have some cool ideas
22:10:37 <bringert_> hmm, I really should write a static page module, so that I can add an "About" page
22:23:14 <__peter> hi all...  after a lot of searching for information on using HaXml and it's Xtract library, i was able to find a mailing list post from the Haskell-Cafe list containing this line of code which seems to extract information from XML: h1 [keep /> dfilter (parseXtract "/greetings/greeting[1]/-")]. however, although i have read through the Haddock, i still do not understand this and was wondering if someone could please explain what
22:28:36 <lispy> __peter: are you familiar with xpath?
22:28:56 <lispy> __peter: iirc Xtract is based on Xpath
22:29:08 <__peter> i have never used Xpath
22:29:50 <lispy> __peter: i'd start there, you can find a pretty short tutorial about it on the web (thats' where I learned it)
22:30:44 <__peter> lispy: ok, thanks, i'll go check that out and see if that helps. thanks
22:30:44 <lispy> __peter: basically you can 'navigate' an XML 'tree' using a notation reminiscent of unix directory structure, but it also has selection/query features
22:30:59 <__peter> ok
22:31:14 <lispy> yw, and good luck
22:49:40 <Korollary> '
22:53:47 <Pseudonym> Sigh.
22:54:01 <Pseudonym> Remembering all of the ideosyncrasies of wheatstone bridges.
22:54:26 <Pseudonym> In theory, this stuff is easy.  In practice, unbalanced bridges have weird current issues.
22:55:46 <RyanT5000> that's why i stick to theory
22:59:09 <Korollary> that's why I never worked as an EE
23:06:30 <RyanT5000> is (isJust $ lookup k m) significantly slower than (member k m)?
23:06:44 <RyanT5000> or, in general, are things like that slower?
23:06:57 <Pseudonym> Depends.
23:07:22 <Pseudonym> If lookup is written well, you could deforest the first version.
23:08:15 <RyanT5000> even if it didn't, what's the penalty like? an extra application of isJust?
23:08:35 <dons> that'll hardly matter at all.
23:08:46 <dons> as long as you're using Map.lookup, of course
23:08:52 <Pseudonym> Right.
23:08:53 <RyanT5000> yeah, that's the one i'm referring to
23:09:06 <Pseudonym> Calling isJust is probably no more expensive than any call.
23:09:13 <RyanT5000> provided all the evaluation is lazy, it'll only evaluate down to whether it's Nothing or Just <something>
23:09:14 <Pseudonym> Especially since it's almsot certainly going to be inlined.
23:09:15 <RyanT5000> right?
23:09:18 <dons> after all,
23:09:19 <dons> member k m
23:09:19 <dons>   = case lookup k m of
23:09:19 <dons>       Nothing -> False
23:09:19 <dons>       Just x  -> True
23:09:20 <RyanT5000> it'll never evaluate the <something>
23:09:27 <dons> i.e. isJust  . lookup
23:09:49 <RyanT5000> lol dons, i thought that might be the case :)
23:10:14 <RyanT5000> i think i've figured out how to unify all my cache stuff now, finally
23:10:43 <RyanT5000> i don't think i've written parameterization this complex before, lol
23:10:52 <RyanT5000> well it's not even that complex per se
23:10:57 <RyanT5000> just hard to get perfect
23:13:58 <Pegazus> hi, anyone familiar with language theory? how to prove that a given language L doesn't have a non ambigous grammar?
23:14:55 <RyanT5000> what's the definition of L, if not a grammar?
23:15:14 <Pegazus> you can define it in many ways...
23:15:28 <Pegazus> and i might give you an ambigous grammar to define it
23:15:53 <RyanT5000> yes, but i mean, in what way do you define a language rigorously without using a grammar?
23:16:05 <Pegazus> i could use many things
23:16:11 <Pegazus> a^n b^n c^n
23:16:11 <RyanT5000> well i presume your proof would depend quite heavily on which way you choose
23:16:12 <Pegazus> :)
23:16:55 <Pegazus> for example you have language a^n b^m c^p with ((n == m) or (n == p))
23:17:04 <Pegazus> can you give me a non ambigus grammar for that language?
23:17:11 <Pegazus> I could give you an ambigous grammar...
23:17:17 <Pegazus> but that doesn't mean it's an ambigous language
23:18:25 <RyanT5000> although i'm pretty sure it is
23:18:38 <RyanT5000> though i have to admit i'm quite rusty on these kinds of things
23:19:16 <Pegazus> im pretty sure it's an ambiogus language, but how to prove it?
23:20:16 <RyanT5000> probably a proof by contradiction
23:20:23 <Pegazus> yeah
23:20:33 <Pegazus> i should prove that i can't find a grammar that is non ambiogus
23:20:34 <Pegazus> but how?
23:20:59 <RyanT5000> assume you have two grammars that both generate the language
23:21:03 <RyanT5000> then prove they are the same
23:21:11 <Korollary> Pegazus: http://www.codecomments.com/archive285-2004-10-286148.html
23:21:17 <Pegazus> they are the same?
23:21:17 <RyanT5000> hm that wouldn't work
23:21:28 <Pegazus> there are infinite grammars that generate that language
23:21:47 <lispy> no, you'd have to assume you have a non-ambiguous grammar then reach a contradiction
23:21:51 <RyanT5000> sorry, i got confused
23:21:53 <RyanT5000> right
23:21:56 <RyanT5000> what lispy said, lol
23:22:08 <RyanT5000> i've been working for like 12 hours
23:22:16 <lispy> the details of that are beyond me, i just know what must be shown :)
23:23:27 <Pegazus> thanks Korollary :) very usefull link
23:45:01 <JohnMeacham> lispy: ideas are the easy part...
23:45:30 <JohnMeacham> My TODO list has consisted of the single entry "Write better todo list software in haskell" for a few years now.
23:45:39 <nealar> @tell shapr Please, notify alar when your arrows article is finished
23:45:40 <lambdabot> Consider it noted.
23:47:00 <RyanT5000> JohnMeacham: please do
23:47:11 <RyanT5000> i could use a programmer-oriented todo list program :P
23:47:40 <kep> JohnMeacham you can research woody(apt-get install woody, woody - Hierarchic text editor) and freemind, I think it's good stuff to start thinking :)
23:49:56 <kep> JohnMeacham woody is very convenient from my point of view, but it's very alpha version :)
23:52:47 <JohnMeacham> Well, all the ones I found out there seem to be nothing more interesting than structured text editors. I can do that on paper, or in vim. I want something that actually does interesting, non-trivial algorithms on the data. Like, it should know whether I am at work or home, or when it is business hours, and only present me with things I can do in my current situation. It should have recipes, so it knows that it needs to add 
23:52:47 <JohnMeacham> a pick up laundry task an hour after the drop off laundry one. and it should understand there are multiple paths to complete a project, like I can get soap at either the department store or the grocery store, but I can only get bread at the second.
23:53:31 <RyanT5000> yeah
23:53:38 <RyanT5000> that'd be an awesome project; i've had the exact same idea before
23:53:39 <JohnMeacham> Although the hierarchy is a useful way to _write_ todo lists, it is exactly the wrong way to view them. the tasks you actually need to complete first are the ones hidden in the deepest levels, they are inverted.
23:53:51 <RyanT5000> you should be able to say
23:53:54 <RyanT5000> "My current state is this"
23:54:00 <RyanT5000> and it should say "here's what you should be doing"
23:54:08 <RyanT5000> including prospective things like
23:54:11 <RyanT5000> "I'm going to work"
23:54:18 <RyanT5000> it should say "don't forget to take x y and z"
23:56:19 <JohnMeacham> I have the beginnings of one in haskell actually. most of the logic is done. I need to reread the code though. I did it a while ago. I call it 'wtd' for 'what to do' as that is the basic query, show me the things I can do right now and nothing extrenious. sort of like 'make' for life. the todo list will be a directed graph rather than a tree like traditional ones.
23:56:41 <RyanT5000> sounds cool
23:56:57 <Korollary> Do you have to query manually?
23:56:59 <JohnMeacham> Hmm.. now I want to ressurect the code.
23:57:20 <RyanT5000> yeah it should automatically issue queries based on time of day
23:57:28 <RyanT5000> and pop up a window if there's a change
23:57:56 <bringert_> JohnMeacham: It would be really cool to have that as a Hope module
23:57:59 <JohnMeacham> well, you would type 'wtd' and it would show you what you can do. it can figure out a lot of things based on the time, what computer you are at, who you are logged in as, even what directory you are in can help it decide how to prioritize.
23:58:11 <Korollary> I am happy with my current reminder, although a structured, smart-ish to-do list could be a good addition.
23:58:14 <bringert_> JohnMeacham: A TODO list module is on the TODO list
23:59:40 <RyanT5000> the thing that's difficult, from a UI standpoint, is getting the user to inform the program about stuff
23:59:48 <RyanT5000> like when he goes to work, he has to remember to say "i'm at work now"
23:59:54 <RyanT5000> etc.
23:59:59 <JohnMeacham> I imagine a UI for editing would be needed, since you have a more complex structure than just a hierarchy. I originally wrote it thinking of using a text editor and some sort of markup, but that turned out to be very limiting. I was probably going to use my curses module from ginsu. but perhaps might do gtk2hs also. web based is an interesting idea, certainly for basic queries it would be nice.
