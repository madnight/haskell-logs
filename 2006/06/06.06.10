00:02:14 <mauke> > "emacs" >> "vim"
00:02:15 <lambdabot> "vimvimvimvimvim"
00:02:39 * dfeuer tries to remember how the list monad works.
00:03:32 * johnnowak has a desire to ask a stupid question
00:04:20 <johnnowak> Why not allow functions to have side-effects, and when you don't want them to, don't make use of them?
00:04:24 <dfeuer> [3, 4] >>= (3+)
00:04:28 <dfeuer> > [3, 4] >>= (3+)
00:04:29 <lambdabot> add an instance declaration for (Num [b])
00:04:44 <dfeuer> > [3, 4] >>= map (3+)
00:04:44 <lambdabot> add an instance declaration for (Num [a])
00:04:45 <lambdabot> In the list element: 4
00:05:35 <jer> johnnowak, because side effects with lazy evaluation can be hazardous to your programs health
00:06:19 <dfeuer> > [3, 4] >>= return
00:06:20 <lambdabot> [3,4]
00:06:24 <dfeuer> > [3, 4] >>= return 5
00:06:24 <lambdabot> add an instance declaration for (Num [b])
00:06:29 <dfeuer> > [3, 4] >>= return [5]
00:06:30 <lambdabot> [5,5]
00:06:39 <dfeuer> oookay.  Someone remind me how the list monad works?
00:09:29 <mauke> > [ [5] | _ <- [3, 4] ]
00:09:30 <lambdabot> [[5],[5]]
00:09:37 <mauke> oh, right
00:10:55 <Pete_I> what is the "|" character called?
00:11:09 <Pete_I> i don't understand how it works.
00:11:38 <dfeuer> > [ (a,b) | a <- [1, 3], b<- [5, 7]]
00:11:39 <lambdabot> [(1,5),(1,7),(3,5),(3,7)]
00:12:35 <dfeuer> > [1,3] >>= \a -> [5,7] >>= \b -> return (a,b)
00:12:37 <lambdabot> [(1,5),(1,7),(3,5),(3,7)]
00:14:13 <dfeuer> > 100000000000000000000000000000000000000000000 * 10000000000000000000000000000000000000
00:14:14 <lambdabot> 10000000000000000000000000000000000000000000000000000000000000000000000000000...
00:16:04 <mauke> dfeuer: instance Monad [] where return x = [x]; fail _ = []; x >>= f = concatMap f x
00:16:32 <mauke> > [3, 4] >>= const [5]
00:16:33 <lambdabot> [5,5]
00:17:01 <mauke> dfeuer: however, your code above used the function monad
00:17:43 <dfeuer> ...
00:19:07 <mauke> instance Monad ((->) a) where return = const; m >>= f = \x -> f (m x) x
00:19:10 <mauke> or something like that
00:19:26 <dfeuer> hm
00:19:30 <mauke> the point is that return is equivalent to const there
00:20:44 <dfeuer> > return 3 :: [Integer]
00:20:46 <lambdabot> [3]
00:21:05 <mauke> > return 3 undefined
00:21:06 <lambdabot> 3
00:21:19 <dfeuer> [3, 4] >>= return 3
00:21:23 <dfeuer> > [3, 4] >>= return 3
00:21:24 <lambdabot> add an instance declaration for (Num [b])
00:21:42 <dfeuer> > return 2 >>= return 3 :: [Integer]
00:21:42 <lambdabot> add an instance declaration for (Num [Integer])
00:21:59 <dfeuer> > (return 2 >>= \a -> return 3) :: [Integer]
00:22:00 <lambdabot> [3]
00:22:27 <mauke> > [3, 4] >> return 3
00:22:28 <lambdabot> [3,3]
00:22:46 <dfeuer> > (return 2 >>= \a -> (a,a)) :: [Integer]
00:22:47 <lambdabot> Couldn't match `[]' against `(,) a'
00:23:01 <dfeuer> > (return 2 >>= \a -> [2,a]) :: [Integer]
00:23:02 <lambdabot> [2,2]
00:23:08 <dfeuer> > (return 2 >>= \a -> [6,a]) :: [Integer]
00:23:09 <lambdabot> [6,2]
00:23:13 <dfeuer> I am lost
00:23:18 <mauke> > return 2 >>= \a -> [6,a]
00:23:19 <lambdabot> [6,2]
00:23:21 <mauke> dfeuer: why?
00:23:38 <dfeuer> It's been too long.
00:23:43 <dfeuer> I can't remember how to figure this out.
00:23:54 <mauke> figure what out?
00:24:41 <dfeuer> What's the translation of [(a,b) | a<-foo, b<-bar] into >>= and return ?
00:25:06 <mauke> do { a <- foo; b <- bar; return (a, b) }
00:25:14 <mauke> foo >= \a -> bar >>= \b -> return (a, b)
00:25:46 <mauke> liftM2 (,) foo bar
00:26:57 <mauke> @pl \x y -> x >>= return y
00:26:57 <lambdabot> (. return) . (>>=)
00:27:19 <mauke> lambdabot: boring
00:27:44 <dfeuer> what's pl?
00:27:59 <mauke> pointless :-)
00:28:02 <mauke> @help pl
00:28:03 <lambdabot> pointless <expr>. Play with pointfree code.
00:29:31 <dfeuer> hm
00:29:54 <mauke> dfeuer: http://haskell.org/haskellwiki/Haskell/Pointfree
00:30:50 <dfeuer> @pl \x -> \(y,z) -> x+y*(\x -> x*z) y
00:30:50 <lambdabot> (`ap` snd) . (. fst) . (. liftM2 (.) (*) (*)) . (.) . (+)
00:31:17 <dfeuer> Well... that definitely produces unreadable code!
00:32:05 <mauke> @pl \x y -> foo x y + bar y x - y
00:32:05 <int-e> @pointless \well look at this commands name -> ()
00:32:05 <lambdabot> join . ((-) .) . ap (ap . ((+) .) . foo) (flip bar)
00:32:06 <lambdabot> const (const (const (const (const (const ())))))
00:32:38 <mauke> dfeuer: sometimes it can simplify code
00:33:03 <mauke> @pl \foo bar -> foo >>= \a -> bar >>= \b -> return (a, b)
00:33:03 <lambdabot> liftM2 (,)
00:33:27 <dfeuer> hm
00:33:38 <mauke> @pl \x -> x
00:33:38 <lambdabot> id
00:34:08 <mauke> @pl twice f x = f x x
00:34:08 <lambdabot> twice = join
00:34:45 <dfeuer> What's join?
00:34:54 <mauke> @type join
00:34:55 <dfeuer> well.... evidently twice.
00:34:55 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
00:35:02 <dfeuer> or not.
00:35:24 <mauke> join x = x >>= id
00:35:55 * dfeuer is about to fall asleep, and cannot absorb abstract concepts.
00:36:04 <dfeuer> I'll try again tomorrow, perhaps.
00:41:58 <lisppaste2> int-e annotated #20982 with "(Mu with Show instance) if done right, this is embarrassingly simple." at http://paste.lisp.org/display/20982#1
00:44:57 <int-e> (hmm. maybe lisppaste shouldn't notify the channel for pastes that are older than a few hours)
00:45:18 <xerox> I am happy that it did :-)
00:51:59 <int-e> oh, good :)
02:27:45 * joelr1 waves
02:47:38 -ChanServ(ChanServ@services.)- davidhouse!n=david@host86-132-138-205.range86-132.btcentralplus.com ACCESS [#haskell] ADD dmhouse 
02:47:54 -ChanServ(ChanServ@services.)- davidhouse!n=david@host86-132-138-205.range86-132.btcentralplus.com ACCESS [#haskell] ADD dmhouse 39
02:47:58 -ChanServ(ChanServ@services.)- davidhouse!n=david@host86-132-138-205.range86-132.btcentralplus.com ACCESS [#haskell] ADD dmhouse 38
02:48:26 <davidhouse> grr.
02:48:30 <dmhouse> Never mind.
02:48:42 <dmhouse> @localtime dons
02:48:44 <lambdabot> Local time for dons is Sat Jun 10 19:39:44 2006
02:48:48 <dmhouse> dons, you around?
02:53:45 <dmhouse> @tell dons I started hacking on Log. Cleaned it up quite a lot and am currently porting it to use contextual. Struggling a little though: What does the second parameter to a callback given to withMS do? Cheers.
02:53:45 <lambdabot> Consider it noted.
03:12:45 <dmhouse> @tell dons the new serialisation stuff works fantastic :)
03:12:45 <lambdabot> Consider it noted.
03:23:23 <joelr1> dmhouse: serialization where?
03:25:45 <dmhouse> joelr1: lambdabot.
03:25:51 <joelr1> cool
03:26:00 <dmhouse> module state serialisation was broken, but now it's fixed :)
03:26:08 <dmhouse> so things like @seen and @tell should start working again
03:44:30 <lscd> hm. I wrote a 'guess the random number' game in haskell a few days ago; is that the kind of thing that can be posted to the gallery on the haskellwiki?  I'm a newbie, so I'm sure there are much better ways to write it, but I had #haskell critique it and nothing really majorly wrong with it was found
03:45:41 <norpan> the wiki is for posting stuff so go ahead!
03:46:11 <norpan> i'm sure someone will delete it if it's not good
03:46:47 <lscd> ok, cool
03:47:35 <lscd> though it would be even better if they'd fix or rewrite it ^-^
03:48:18 <norpan> well who knows
03:48:32 <lscd> yeah; indeed
04:24:42 <lscd> norpan: http://www.haskell.org/haskellwiki/GuessRandom -- feel free to delete ;)
04:27:40 <norpan> looks very nice and well-commented
04:27:42 <dmhouse> lscd, in the second equation for getSeed, your pattern could get (x:_) as you don't care what it's consed onto, only that it's got length > 0
04:27:56 <dmhouse> (I'm in nit-picking mode, it's great in general :))
04:28:09 <lscd> good point; thanks :)
04:28:16 <lscd> i'll change it ^-^
04:28:22 <norpan> well, yes the use of _ is always good
04:28:30 <Dreadshoot> could even write that shorter in c++
04:28:45 <dmhouse> I'd probably write getRandomSeed as fmap (fst . Random.random) getStdGen
04:29:01 <lscd> Dreadshoot: yes; it's not very compact
04:29:24 <dmhouse> in playGame you can collapse the two consequetive let declarations down into one
04:29:46 <dmhouse> Just indent the target so that it lines up with the first bracket of the one above
04:29:50 <pierre-> @where ghc6
04:29:50 <lambdabot> I know nothing about ghc6.
04:29:51 <norpan> dmhouse: you can, but i always do it that way too
04:29:55 <pierre-> @where ghc
04:29:55 <lambdabot> http://haskell.org/ghc
04:30:05 <norpan> i like the fact that it says let on each
04:30:33 <dmhouse> hmn, fine, I'd call that redundancy :) It's readable enough anyway, IMO.
04:30:37 <lscd> norpan: hm, why?
04:31:01 <dmhouse> "You won in " ++ (show numTries) ++ " guesses."  You don't need the parentheses around (show numTries). Application binds tighter than (++).
04:31:13 <norpan> i find it easier to read
04:31:30 <norpan> it's all a matter of taste really
04:31:41 <dmhouse> I'd probably do guessWrong with an if/then/else instead of guards to avoid repition of the guessFor line
04:31:49 <dmhouse> (Disclaimer: most of these are personal taste)
04:31:58 <dmhouse> (And in any case are extremely nitpicky)
04:32:25 <lscd> eh, thank you for them, though; that's exactly the kind of feedback i'm looking for
04:32:35 <dmhouse> (\inchar -> inchar `elem` "yYnN")  --->   (`elem` "yYnN")
04:32:38 <lscd> sorry for the delay, i've just been asked to start some water boiling; back in a min
04:32:48 <dmhouse> (\inchar -> toUpper inchar)   ---->     toUpper
04:33:14 <dmhouse> similarly with (\input -> read input) and (\input -> isNum input) in getNum
04:34:06 <dmhouse> Unneeded parentheses again in showSeed (the whole application has higher precendence than (++) thing again)
04:34:13 <dmhouse> And in showAnswer
04:35:01 <dmhouse> the if statement in playAgain could be reduced to return (again == 'Y')
04:36:02 <dmhouse> or even that whole function could be reduced to do putStr "Play again?"; fmap (=='Y') (getYN "\nPlay again?")
04:36:57 <dmhouse> x == [] is normally written null x
04:37:15 <dmhouse> > ([] :: [Int]) == ([] :: String)
04:37:15 <lambdabot> Couldn't match `Int' against `Char'
04:37:21 <dmhouse> That's why.
04:38:25 <dmhouse> That's about all. :) HTH, don't take anything I said as harsh criticism, I just remember that when I was a newbie these were the kind of timesaving or spacesaving hints I'd love to see.
04:39:01 <norpan> using higher-order functions consistently does wonders for readability when you're used to it
04:39:05 <lscd> none of that was harsh criticism at all; thank you for all of it
04:39:10 <lscd> norpan: agreed
04:40:02 <lscd> i'll start editing my code to match most/all of it, verify that it still works (aka, that i haven't made too many typos), and re-upload :)
04:40:40 <dmhouse> I think you've been bitten by the buggy <haskell> renderer near the bottom there
04:40:45 <dmhouse> (Alliteration unintended :))
04:40:59 <lscd> and dmhouse: frankly, #haskell is a -lot- nicer to newbies than any other language-specific channel i've been to
04:41:15 <dmhouse> Hehe. Yep.
04:41:20 <norpan> we're nice just as long as people don't expect us to do their homework :)
04:41:30 <lscd> ehh, ya, looks like it - any workarounds for that bug?
04:41:48 <lscd> norpan: well, my school is too silly to ever require haskell, and rarely even allows it, so you're safe from that from me ;)
04:42:00 <dmhouse> Not sure. I came across it, the only thing I could do to get rid of it was to attach the .hs file, which isn't exactly an ideal solution.
04:42:27 <lscd> mm.  i guess the source for it is available somewhere?
04:42:28 <norpan> haskell should be mandatory in any cs program
04:42:42 <lscd> norpan: sure, but .... it might mean we'd have less time to cover uml! 
04:42:46 <lscd> </sarcasm> :p
04:42:51 <dmhouse> Hah :)
04:42:59 <norpan> i actually like uml
04:43:11 <norpan> but then, i work in Industry
04:43:21 <lscd> sure; it has its uses
04:43:26 <lscd> i think it's an ok high-level documentation tool
04:43:32 <lscd> especially if you're generating it
04:43:37 <norpan> at least uml gives meaning to peoples strange blocks-and-arrows diagrams
04:43:48 <lscd> but writing uml for toy-size programs, in advance, is just ... wrong, imho
04:44:17 <lscd> yeah; it's better than nothing, in some cases
04:44:45 <lscd> anyhow - it's easier to poke at uml than to admit to myself how much time we spend on java :p
04:45:50 <norpan> java is not bad either
04:46:06 <norpan> languages are not bad, programmers are
04:46:07 <lscd> in the sense that it's not object oriented cobol, i agree with you
04:46:08 <norpan> :)
04:46:19 <lscd> that said, i really dislike using java in general
04:46:30 <norpan> java 5 is actually usable
04:46:48 <norpan> it has generics and enums and stuff
04:46:50 <lscd> norpan: languages vary though
04:47:03 <norpan> they do
04:47:10 <lscd> sure, java 5 is better than java 4
04:47:35 <lscd> but it's still long, tedious to write, and verbose; and i still have many, many philosophical arguments with it
04:47:47 <norpan> i've only used haskell,c,c++,java,python, and prolog to any larger extent and i like them all
04:48:02 <norpan> they all have their advantages
04:48:06 <lscd> indeed
04:48:23 <norpan> but haskell is the best of course
04:48:26 <lscd> i like haskell, c, python, ruby, smalltalk, etc
04:48:40 <lscd> but i've had no luck making myself like java
04:48:41 <norpan> oh, and ocaml
04:48:45 <norpan> i really like ocaml
04:48:49 <lscd> ocaml is cool, but i don't know much about it yet
04:49:01 <norpan> i would like to mix stuff from haskell and ocaml
04:49:08 <norpan> type classes from haskell
04:49:10 <lscd> yeah - i think vincenz is doing something like that
04:49:25 <norpan> and general syntax
04:51:04 <norpan> the ocaml debugger is cool
04:51:10 <lscd> so i've heard
04:51:22 <lscd> though the debugger i like best, of any i've used, is the smalltalk one
04:51:32 <lscd> (especially the one in visualworks, though squeak's should be ok too)
04:51:47 <norpan> never did smalltalk
04:51:59 <norpan> only saw it once or twice
04:52:15 <lscd> i mean... an unhandled exception happens, it asks if you want a debugger; you say yes, and then can go to arbitrary places in the stack frame, change anything (code, variables..), and rerun from an arbitrary place in the stack frame
04:52:29 <lscd> as if nothing had ever gone wrong and your changes had always been there
04:52:44 <dmhouse> lscd, what's smalltalk like? I want to learn it.
04:52:55 <norpan> smalltalk is oo extreme
04:52:57 <lscd> dmhouse: it's a pure oo language; minimal syntax, etc
04:53:06 <dmhouse> That's cool.
04:53:06 <lscd> it's sort of like "oo-specific lisp"
04:53:33 <dmhouse> I wanted to learn an OO language, so I thought that if I were to start with smalltalk everything else would pale in comparison :)
04:53:48 <lscd> everything is an object, in the system, including integers, etc; everything is done with message passing
04:53:56 <norpan> otoh i do a lot of c++ and i can tell you that people who don't know it well (like some of my co-workers) make very stupid mistakes
04:54:13 <lscd> dmhouse: i think so; java is awful, in comparison, from an oo perspective
04:54:22 <norpan> i feel kind of fortunate the don't know haskell so they let my haskell parts alone :)
04:54:23 <lscd> ruby is a bit similar, but it's much more cluttered
04:54:53 <dmhouse> I do like a sugary syntax, though, so perhaps Ruby would be a better choice?
04:55:05 <lscd> smalltalk is the language that convinced me that oo doesn't totally suck
04:55:08 <norpan> i've heard good stuff about ruby
04:55:32 <lscd> dmhouse: hm.... i'd start with smalltalk, as it's a lot more focused; ruby is more perl-like, in that it lets you do pretty much anything in a lot of ways
04:55:49 <lscd> in smalltalk, you -have- to learn the smalltalk way of doing things, i think
04:55:52 <norpan> gah perl
04:56:03 <norpan> i can't stand it
04:56:17 <dmhouse> Yeah. I heard you spend a long time learning the object hierarchy before you become a prolific Smalltalk programmer :)
04:56:19 <lscd> neither can i; ruby is like a cross between it and python though, sort of
04:56:23 <norpan> unless $p $%_++;
04:56:34 <lscd> dmhouse: yeah, people generally say about a year; i'm far from prolific at smalltalk
04:56:46 <lscd> things like the collections hierarchy are really nice in smalltalk though
04:56:47 <dmhouse> Well, I'm a fast learner, so we'll see. :)
04:57:13 <lscd> dmhouse: eh, it'll be at least a few months, i think; but good luck ^-^
04:57:24 <lscd> the major choice is visualworks vs squeak as an implementation
04:57:41 <dmhouse> Well, Haskell took be a good few months.
04:57:42 <lscd> their gui libraries are fairly different; the core systems are similar, but not identical
04:57:45 <dmhouse> *me
04:58:09 <lscd> sure - i could write code that worked in smalltalk a lot faster than i could in haskell; but haskell captures my interest a lot more
04:59:17 <norpan> if i write something for myself i almost exclusively use haskell
04:59:46 <norpan> esp if it involves parsing and data structure manipulation, which it almost always does :)
04:59:51 <dmhouse> This _is_ #haskell, though :)
04:59:55 <lscd> i generally haul out python still; but i've been less and less enchanted with it over the last few years
05:00:06 <lscd> dmhouse: true ^-^
05:00:48 <dmhouse> I think Haskell was a poor choice as a second language. With everything else I'm going to be thinking "Haskell does this 10 times shorter and in a more elegant and more resuable fashion"
05:01:36 <norpan> dmhouse: yes, it should be the first language
05:01:38 <norpan> :)
05:02:12 <norpan> my first computer language was 68k assembler
05:02:16 <norpan> then i learned about c
05:02:21 <lscd> dmhouse: hm.... for a lot of things it does; on the other hand, a fair number of languages would do something like my 'guess the random number' game more concisely, i think
05:02:31 <lscd> norpan: heh. i went javascript -> c
05:02:48 <astrolabe> I've refactored a haskell program, and now it just hangs without using any cycles.  I don't understand how.
05:02:49 <arctanx> basic was good, once.
05:04:47 <goltrpoat> i went from gwbasic on an 8086 to 8086 assembly to 80286 to turbo pascal to watcom c and then it just all went downhill.
05:12:09 <lscd> dmhouse: i've applied the simpler changes you suggested (though not uploaded yet); i'm going to eat lunch, then try to understand fmap, and once i have, i'll think of applying the changes using fmap you mentioned; thanks again
05:12:59 <dmhouse> lscd, fmap is the same as liftM.
05:13:07 <dmhouse> liftM m f = m >>= return . f
05:13:18 <dmhouse> err, liftM f m = m >>= return . f
05:13:27 <dmhouse> it 'lifts' a non monadic function to a monadic one.
05:13:53 <dmhouse> The other way of thinking about it is that you can apply a (pure) function to the contents of the monadic container without affecting the monadic 'plumbing'.
05:14:02 <dmhouse> > fmap (+2) (Just 4)
05:14:03 <lambdabot> Just 6
05:14:14 <dmhouse> > fmap (+2) [1,5,10]
05:14:15 <lambdabot> [3,7,12]
05:14:56 <dmhouse> fmap is actually more general that liftM as liftM requires a Monad but fmap only requires a Functor. But I like fmap more than liftM because fmap is in the Prelude :)
05:15:21 <dmhouse> Basically, whenever you find yourself writing "something >>= return . something2", use fmap or liftM.
05:15:30 <norpan> let guess x = putStr "Guess: " >> readLn >>= \y -> if y > x then putStrLn "Lower" >> guess x else if y < x then putStrLn "Higher" >> guess x else putStrLn "Correct" in (randomIO :: IO Int) >>= guess
05:15:41 <norpan> liftM works for any Monad, fmap doesn't
05:15:48 <norpan> so none is more generic
05:15:57 <dmhouse> Huh? No, fmap works for any Monad.
05:16:02 <norpan> wrong
05:16:03 <dmhouse> as every Monad is a Functor.
05:16:13 <norpan> it isn't unless you make it an instance of it
05:16:27 <dmhouse> I was talking conceptually.
05:16:41 <norpan> conceptually fmap == liftM
05:16:48 <dmhouse> And I believe there's an 'instance Monad m => Functor m' somewhere in the libs.
05:17:42 <norpan> is there?
05:18:07 <dmhouse> What would be the point of instantiating Functor for every Monad? It'd be precisely the same definition all the time
05:18:38 <norpan> you can do it more efficiently than m >>= return . f
05:18:46 <norpan> ?
05:19:15 <dmhouse> Hmm, maybe.
05:19:41 <dmhouse> But anyway, you needn't bother about this in practise. Every Monad in the standard libs is also a Functor.
05:19:52 <dmhouse> So fmap is a more general liftM.
05:19:56 <norpan> you needn't bother as you can use liftm :)
05:20:09 <dmhouse> Why import Control.Monad (liftM) when you can just use fmap?
05:20:45 <goltrpoat> since when are monads automatically functors
05:21:19 <norpan> since fmap f m = m >>= return . f
05:21:37 <dmhouse> goltrpoat: Monad is a subclass of Functor
05:22:28 <norpan> it's not in the standard libs though
05:22:32 <dmhouse> Categorically, a monad is a type of functor.
05:22:36 <norpan> but conceptually it is
05:23:19 <norpan> i guess it was decided that requiring monads to be functors was a burden for those defining monads
05:23:45 <norpan> but otoh this was the same people that decided that it was a good idea to make Num a subclass of Show :)
05:24:00 <goltrpoat> -nod- i meant the haskell types, not the category-theoretic definition
05:24:08 <dmhouse> Well that's an entirely different situation.
05:24:39 <norpan> and having a default instance would overlap the specific instances
05:25:08 <norpan> so you'd have to allow overlapping instances
05:33:37 * dmhouse has just discovered he can type 'darcs' with one hand
05:34:11 <Pete_I> uh...yeah...
05:34:31 <norpan> i can type "typewriter" with one row of keys
05:35:11 <dmhouse> It's the longest word such that that's true, IIRC.
05:35:14 <wilx> Heh, goot know :)
05:35:15 <lscd> i can't
05:35:19 <norpan> i also frequently type "cvs yo" when i have my fingers misaligned
05:35:22 <wilx> good even :/
05:35:45 <lscd> [yay for dvorak on a physical qwertz keyboard..]
05:35:46 <norpan> if you have a german keyboard you can type "tzpewriter" with one row of keys
05:36:11 <lscd> close enough; i think this keyboard is physically swiss-german; but the same would be true of italian keyboards, etc
05:41:06 <chris2> dmhouse: "database" is longer... (but you may type b with the other hand usually)
05:41:50 <lscd> i think he meant 'typewriter' and all on one row
05:42:37 <chris2> misread, then
05:44:30 <chris2> "proprietory" is longer, tho :)
05:44:39 <lscd> naw, it's just a different parse
05:44:41 <lscd> hm. yep :)
05:44:49 <lscd> i really hope you're using a program to figure that out ;)
05:44:51 <chris2> and "rupturewort" even works on a german keyboard
05:45:06 <lscd> yes, but this is the first time i've heard of 'rupturewort'
05:45:09 <chris2> "flagfall" for the homerow
05:45:13 <chris2> me too :P
05:45:39 <lscd> the real challenge is finding longest dvorak-typable words ;)
05:45:45 <lscd> they'll all be home-row
05:45:49 <chris2> and not a single word to be typed on the bottom row
05:45:51 <lscd> since all the vowels are
05:46:41 <chris2> unostentatiousness for dvorak
05:49:15 <lscd> yay. dvorak wins
05:49:31 <norpan> i have dvorak on my todo list
05:50:19 <lscd> cool; i quite like it - it has some rarely-stated benefits, ie, no one uses my laptop without asking me, at least not for more than a few seconds; and when pair-programming, it keeps people from grabbing my keyboard
05:50:45 <chris2> same for hp calculators ;)
05:50:47 <dmhouse> Hehe :)
05:51:05 <dmhouse> RPN++. Actually, emacs calculator++.
05:51:14 <goltrpoat> ive found that a baseball bat is a far better deterrent.
05:51:17 <lscd> aside from that, my wrists tend to feel a bit better using it, and i type quite a bit faster than i did on other keymaps
05:51:22 <dmhouse> Or, really, as we're in #haskell, (+1) RPN, (+1) emacs calculator.
05:51:24 <dfeuer> Ooh.... I use Dvorak too.
05:51:29 <dfeuer> Have since elementary school.
05:51:42 <lscd> goltrpoat: the thing is, i don't need to be there with a baseball bat for the advantages to apply; i can just leave my laptop there and go to lunch
05:51:54 <lscd> dfeuer: cool, i started using dvorak in high school
05:52:10 <goltrpoat> lscd:  wait, i didn't mention that this was a sentient baseball bat, did i
05:52:18 <dmhouse> goltrpoat: hehe
05:52:29 <lscd> goltrpoat: what can i say? i prefer non-violent solutions ^-^
05:53:26 <goltrpoat> oh it's perfectly non-violent.  the baseball bat is named bob.  it sits down the person who's trying to use your keyboard, and tries to get to the bottom of the issue while offering helpful suggestions.
05:53:45 <lscd> goltrpoat: i can see a sentient baseball bat, but a sentient baseball bat which speaks italian? naw
05:54:00 <goltrpoat> it's more common than you think.
05:54:13 <lscd> mmhmm. i'm sure. unfortunately, my pet unicorn took mine
05:54:18 <goltrpoat> hehe
05:54:47 <lscd> http://pastebin.ca/63656 <-- would anyone point out why this code is wrong? the 5th line is taken to be part of the argument to the putStrLn on the 4th line 
05:55:13 <Igloo> You don't have a "do"
05:55:19 <lscd> ah-hah
05:55:27 <norpan> do do do
05:55:42 <lscd> i accidentally borked that; i'd accidentally removed the = too, then put that back in but forgot the do
05:55:43 <norpan> do re mi fa sol la ti do
05:55:43 <lscd> thanks!
05:55:45 <dmhouse> That's a sloooow pastebin.
05:55:56 <norpan> @where paste
05:55:56 <lambdabot> http://paste.lisp.org/new/haskell
05:56:08 <lscd> dmhouse: ya - i tried pastebin.com first, but it started giving me missing table errors, which was... not a good sign
05:56:18 <dmhouse> If I knew enough CL I'd write haskell syntax highlighting for paste.lisp.org, then everyone would live it. :)
05:56:21 <dmhouse> *love
05:56:44 <goltrpoat> you can write plugins for paste.lisp.org?
05:56:47 <lscd> hm. how hard is haskell syntax highlighting? haskell has a fair amount of syntax
05:56:53 * dfeuer knows no CL.  He falls on the Scheme side of Lisp.
05:57:06 <dmhouse> It doesn
05:57:12 <dmhouse> *It doesn't have to be complicated.
05:57:24 * lscd knows minimal CL
05:57:26 <norpan> lscd: not that hard, depending on what you want
05:57:32 <dmhouse> Highlight the keywords and, say, literals, and you're already most of the way there.
05:57:33 <dfeuer> It can borrow a parser from a Haskell compiler...
05:57:45 <lscd> CL can? how?
05:57:58 <dfeuer> lscd, what??
05:58:26 <lscd> dfeuer: i see how a parser written in haskell could borrow a parser from a haskell compiler; but what glue would you use to get that ability from CL?
05:58:57 <lscd> i mean, i guess both have ffis with c, but... short of that?
05:59:17 <dfeuer> How 'bout ASCII?
05:59:30 <dmhouse> Set up a Haskell-parsing web service and communicate through that. Or be all old-fashioned and use the shell. :)
05:59:58 <dfeuer> How hard would it be to write a parsed-Haskell -> s-expression convertor?
06:00:03 <dmhouse> dfeuer: I think what lscd means is that you can't go (import GHC) in CL.
06:00:27 <lscd> hmm. ah, right... sure, you could just dump the parse tree into something (hopefully) easier to deal with
06:00:37 <dfeuer> Well no... You'd have to do some work, but I think not nearly as much as writing a Haskell parser from scratch.
06:00:52 <goltrpoat> why not just write it in lisp? :)
06:00:58 <dfeuer> lscd, Lisp likes s-expressions.
06:01:14 <dfeuer> goltrpoat, because Haskell's better for writing parsers than Common Lisp?
06:01:16 <lscd> dfeuer: aye; i know that much, at least ^-^
06:01:23 <goltrpoat> yes, but you're talking about a lot more up front effort.
06:01:29 <lscd> goltrpoat: plus, there already are haskell parsers in haskell
06:02:00 <dmhouse> tbh, the original point of this conversation was to get Haskell syntax highlighting for paste.lisp.org. Now we've dragged the lispers out of lurking, you've got no excuse. :)
06:02:45 <lscd> well, you've dragged me and dfeuer out, but dfeuer doesn't know CL, and mine is pretty weak :)
06:03:04 <dmhouse> goltrpoat?
06:03:27 <goltrpoat> mine is fairly weak as well, although it doesn't sound like a terribly hard project
06:03:48 <lscd> goltrpoat: so, go for it ^-^
06:04:06 <goltrpoat> -nod- i'm rather tempted to
06:04:29 <dmhouse> http://paste.lisp.org/system-server/show/lisppaste there's the source
06:04:30 * dfeuer thinks a Scheme->CL compiler might be a good idea.
06:04:52 <goltrpoat> dm:  yah i was just looking through that
06:05:53 <lscd> dmhouse: where's the source for the code that provides the <haskell></haskell> stuff on the wiki? i'm having a bit of trouble finding it
06:06:15 <dmhouse> lscd, not sure. It might be (gasp!) in PHP anyway, as i assume it's a MediaWiki extension.
06:06:22 <lscd> ahhh
06:06:25 <dmhouse> hrm, if it's PHP I'll have a hack.
06:06:34 * lscd reluctantly admits to knowing some PHP
06:06:41 <lscd> hmm, cool
06:06:52 <lscd> i'll try to find a minimal case where it breaks, if you want
06:07:25 <dmhouse> That'd be great.
06:08:13 <dmhouse> I _think_ it's length of the excerpt that triggers it.
06:08:28 <dmhouse> You could look for other lengthy code blocks and see if they break.
06:08:45 <lscd> well, the new version of my code is slightly shorter than the old version; and it still breaks
06:08:53 <lscd> [i think the difference is 10-20 lines]
06:09:03 <lscd> the breakage is all on the last line, as far as i can see at a glance
06:09:19 <xerox> dmhouse - Write an Haskell synhl module for lisppaste :)
06:09:37 <dmhouse> xerox, I already persuaded goltrpoat to do that.
06:09:52 <lscd> hm - the sandbox is immutable, ironically enough
06:09:59 <goltrpoat> whoa, i said i'm tempted :)
06:10:33 <dmhouse> lscd, try creating a user page.
06:10:45 <lscd> dmhouse: ah, found the problem; i ended up in hawiki, rather than haskellwiki
06:10:47 <dmhouse> goltrpoat: pwease? :)
06:12:11 <lscd> dmhouse: i found 3 lines that break it
06:12:15 <lscd> i'll try to reduce it further
06:12:24 <lscd> but my isNum function is enough to do it
06:12:35 <dmhouse> Great.
06:13:14 <lscd> ah-hah
06:13:20 <lscd> isNum (x:xs) = all isDigit xs && (x == '-' || isDigit x) 
06:13:28 <lscd> is enough to trigger it - 1 line; i'll see if i can reduce it more though
06:14:00 <lscd> isNum (x:xs) = (x == '-' || isDigit x) triggers it too
06:16:18 <lscd> x == '-' || True     is as small as i can get it, i think
06:17:09 <dmhouse> which page is this on?
06:17:21 <lscd> http://www.haskell.org/haskellwiki/TestMarkupBreakage
06:19:38 <lscd> http://www.haskell.org/haskellwiki/TestMarkupBreakage2 is the shortest i can get internal corruption on too
06:20:35 <lscd> http://www.haskell.org/haskellwiki/TestMarkupBreakage3 has more significant internal corruption
06:21:16 <dmhouse> lscd, I think it breaks with the (||) operator.
06:21:53 <lscd> no, a || b works
06:22:01 <dmhouse> it does?
06:22:03 <dmhouse> False || True doesn't
06:22:06 <dmhouse> nor does 4 || 5
06:22:18 <lscd> http://www.haskell.org/haskellwiki/TestMarkupBreakage4
06:22:45 <lscd> indeed, 4 || 5 doesn't
06:22:54 <dmhouse> http://www.haskell.org/haskellwiki/TestMarkupBreakage
06:23:51 <lscd> ack
06:25:15 <dmhouse> lscd, it's not quite literals.
06:25:19 <dmhouse> refresh that page
06:25:33 <lscd> refreshed
06:25:41 <lscd> 5 == 5 || 6 == 6 breaks, fwiw
06:25:57 <dmhouse> well, 5 || 6 breaks.
06:26:14 <lscd> yes; i was wondering if making it into an expression would help; it doesn't
06:26:39 <lscd> (a == a) || (b == b) works too
06:27:52 <dmhouse> more examples up.
06:29:03 <dfeuer> hmm?
06:29:08 <dmhouse> I think any number or constructor on either side of the || makes it break.
06:29:10 <dfeuer> What's broken?
06:29:20 <dmhouse> dfeuer: http://www.haskell.org/haskellwiki/TestMarkupBreakage
06:29:28 <dmhouse> the syntax highlighting on HaskellWiki is buggy
06:30:02 <lscd> added two more examples
06:30:23 <dfeuer> hmm
06:30:24 <lscd> numbers seem to make it break, yeah; but you can write function calls
06:30:50 <dfeuer> Why not look through its source code, rather than working all backwards?
06:30:58 <dmhouse> dfeuer: can't find it.
06:31:06 <dfeuer> oh
06:31:15 <dmhouse> I found GeSHi, but the wiki says it uses a Haskell config file, and I can't find that.
06:32:42 <lscd> A is a constructor, right?
06:33:15 <dfeuer> yeah.
06:33:20 <dfeuer> Unless it's a class.
06:33:24 <lscd> so... constructors work
06:33:32 <dmhouse> constructors make it break.
06:33:45 <dfeuer> They work, and they make it break.  This is confusing.
06:34:01 <lscd> dmhouse: see last example
06:34:03 <lscd> a || A works
06:34:31 <dmhouse> hmm
06:34:48 <lscd> a || AlmostTrue breaks
06:35:20 <lscd> if the constructor has more than one letter, it breaks
06:35:38 <dmhouse> yep.
06:36:57 <dmhouse> oh! no.
06:37:01 <dmhouse> see the last example now.
06:37:41 <lscd> mm. interesting
06:40:10 <lscd> is the GeSHI source anywhere near as convoluted and ad-hoc as this is suggesting?
06:40:46 <dmhouse> Dunno.
06:40:50 <lscd> mmk
06:44:02 <dons> ~[6~[6~[6~[6~[6~hey
06:44:02 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:44:14 <dons> thank you mr. bot
06:45:44 <dmhouse> dons, you can use @messages? for that.
06:46:03 <dons> did you work out your withMS question?
06:46:32 <dmhouse> dons, nope, not quite.
06:46:44 <dmhouse> I have whipped up a couple of generally useful patches, though
06:46:55 <dons> was the question what the second argument to withMS was?
06:47:07 <dmhouse> Yeah, almost.
06:47:14 <dons> i.e. withMS $ \s r -> ... -- what is the 'r' ?
06:47:17 <dmhouse> withMS (\state writer -> ...). What's writer?
06:47:26 <dons> its a functoin that will write the state back
06:47:38 <dmhouse> Ah.
06:47:40 <dons> check the State.hs plugin
06:47:54 <dmhouse> thanks. :)
06:47:56 <dons> it should probably be rewritten to instead have withMS return (state,result)
06:48:10 <dons> like some of the MVar functoins do
06:48:17 <dons> though, actually, its not such a bad interface
06:48:28 <dmhouse> I wrote a patch to make you a priveleged user when you're in offline mode, by the way,
06:48:35 <dons> oh, good
06:48:35 <dmhouse> (My first dive into lambdabot's internals :))
06:48:43 <dmhouse> currently hacking on Log.
06:48:49 <dons> cool
06:49:35 <dons> from log, collecting various statistics wouldn't be too hard either
06:59:20 <dons> yeah, the i fixed the serialising, i think. and the exception/signals handling is now a lot cleaner
06:59:34 <dons> sending external signals actually works safely now :)
06:59:49 <dons> i'm not sure why the scheme was so obfuscated before. 
07:03:29 <dmhouse> @version
07:03:30 <lambdabot> lambdabot 3.1p90, GHC 6.5 (OpenBSD i386 )
07:03:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:03:48 <dmhouse> Did I send you the patch for serialisation with @tell?
07:04:26 <dons> don't think so.
07:05:16 <dmhouse> Right, I'll send that in a minute.
07:08:09 <dmhouse> @echo
07:08:10 <lambdabot> echo; msg:IrcMessage {msgPrefix = "dmhouse!n=david@host86-132-138-205.range86-132.btcentralplus.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo"]} rest:""
07:14:23 <dons> @hoogle throwDynTo
07:14:23 <lambdabot> Control.Exception.throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
07:14:36 <dmhouse> @hoogle isUpper
07:14:36 <lambdabot> Char.isUpper :: Char -> Bool
07:22:43 <dons> dmhouse, just pushed a patch that affects Lambdabot.hs and some other core stuff. you should pull and check for merge issues
07:22:54 <dmhouse> right.
07:23:17 <dmhouse> Seems to be okay.
07:23:54 <dons> cool
07:26:38 <dons> i wish ghc --make didn't print the list of all the things its skipping
07:26:42 <dons> its so noisy
07:30:02 * dons edits the 'Skipping' line from his compiler
07:32:22 * dmhouse wonders why Log is using StateT LogState LB, and not just using the already-provided state functions
07:33:26 <dmhouse> dons, and what's all the theMODULE stuff?
07:33:29 <dmhouse> is that deprecated?
07:33:38 <dons> no!
07:33:45 <dons> that's the symbol used by the dynamic linker when linking plugins
07:33:51 <dmhouse> oh?
07:33:55 <dmhouse> Then what's PLUGIN?
07:33:58 <dons> (the cabal build system doesn't use dynamically linked plugins yet)
07:34:11 <dons> check scripts/BotPP.hs
07:34:18 <dons> it expands to some plugin symbol boilerplate
07:34:25 <dons> which the dynamic linker looks for
07:35:04 <dons> basically, we provide an implementation of modules as first class citizens, so the bot can manipulate plugins in a nice manner
07:35:50 * dmhouse pops open BotPP
07:35:56 <dmhouse> BotPP is the new DSL?
07:36:25 <dons> yeah, just a little preprocessor for some boilerplate we have
07:36:29 <dons> i.e. PLUGIN and MODULEs
07:36:44 <dons> much lighter weight than depending on TH
07:36:49 <dmhouse> yep
07:38:05 <dons> we should document this, if its not in the COMMENTARy file yet
07:38:18 <dons> feel free to add it if you can
07:40:47 * dons tries out his ghc patch
07:41:02 <xerox> Added an option, like, --quiet? :)
07:41:09 <dmhouse> You were serious in patching it?
07:41:09 <dmhouse> Nice.
07:41:15 <dons> nah, just make it quiet by default, like make
07:41:29 <dons> and noisy about what its skipping with -v 3 or above
07:41:30 <dons> yep
07:42:22 <dons> yeah, since we use cabal for developing these days, we've been inundated with 'Skipping ...' messages, so you lose some info in the noise about the dependencies of your change
07:45:25 <dons> yay, much nicer. no more noisy 'Skipping'
07:45:43 <dmhouse> Send it upstream.
07:45:48 <dmhouse> (to the GHC folk)
07:45:56 <dons> yep
07:46:04 <dons> i.e.:
07:46:04 <dons> Chasing modules from: Main.hs
07:46:05 <dons> [33 of 76] Compiling Lambdabot        ( Lambdabot.hs, dist/build/lambdabot/lambdabot-tmp/Lambdabot.o )
07:46:08 <dons> Linking dist/build/lambdabot/lambdabot ...
07:46:13 <dmhouse> Lovely!
07:46:18 <dons> so i actually know what the deps were
07:46:23 <lscd> sweet
07:46:50 <SamB_XP> maybe it could output a single dot instead of each "skipping" message? or every 10 or so?
07:47:16 <SamB_XP> probably too much work to make it newline after that before printing anything else?
07:47:31 <dons> well, does make? i think it should just be quiet if its doing no work
07:47:34 <dmhouse> dons, ModuleT instantiates MonadTrans, right?
07:47:55 <dons> hmm, no?
07:48:00 <lscd> i'd agree with dons
07:48:19 <lscd> at most, add some --show-skipping argument or something, but just having -v N show it seems good enough to me
07:48:21 <SamB_XP> well, it might take longer to figure out it is skipping than make would
07:48:23 <dmhouse> hmm? Deceptive name.
07:48:48 <dons> dmhouse: yeah, i think so.
07:48:52 <SamB_XP> because make never looks at the contents of any files but makefiles
07:49:23 <SamB_XP> whereas GHC has to look at interface files and stuff
07:50:52 <dons> dmhouse: though ModuleT is a transformer of sorts
07:51:11 <dons> at least according to Thomas, when he wrote it
07:51:14 <dmhouse> Haha! It builds. I love these moments.
07:51:26 <SamB_XP> so why doesn't it instantiate MonadTrans?
07:51:40 <dmhouse> Except for the warnings. lambdabot's build seems to crash and burn if you get any warnings.
07:51:53 <dons> sure. that's what -Werror is for
07:51:54 <dmhouse> That's probably deliberate, but it's _really_ annoying sometimes :) (you can't show bindings, etc)
07:52:03 <dons> you can edit the .cabal file ;)
07:52:23 <dons> to make sure randoms on the internet don't add more bugs than they should :)
07:52:26 <dmhouse> But the 'defined but not used' warnings are useful when refactoring.
07:52:36 <dons> and those who know what they're doing can edit the .cabal file
07:55:45 <SamB> it makes some of us feel dirty, though!
07:58:10 <dmhouse> :) I think it works!
08:03:25 <dmhouse> dons, how useful was @last?
08:03:26 <xerox> If you were to doing a scheduler, how would you proceed?
08:03:50 <xerox> It gets request for computations, and has to decide what, how many, and when to run them.
08:04:10 <xerox> (And give back answers. It has to work over the network, too.)
08:05:39 <dmhouse> xerox, I'd google for a load-balancing algorithm :)
08:06:19 <xerox> I am wondering which conding techniques to use.
08:06:43 <dons> dmhouse: @last? its useful for channels that don't have logs, or people who disconect a lot. 
08:06:54 <xerox> ...listen on a port, spawn threads, and use exceptions to communicate, seem awful.
08:06:55 <dons> also, we once had a patch that piped the output of @last into @babel
08:06:56 <dmhouse> Okay. I'll implement it then.
08:07:06 <dons> so you could translate foreign languages without copy/paste
08:07:28 <xerox> Ah, dons, I think babel should move over libtranslate.
08:07:44 <xerox> Libtranslate is *cool*, it does japanese and a number of languages.
08:07:49 <dmhouse> I've got rid of the history being part of the State. I could 1) put it back in 2) just read the logs from the disk
08:08:17 <xerox> (fsbot recently got it)
08:08:30 <dons> yeah, quite possibly 
08:08:49 <dons> dmhouse: yeah, do as you see fit
08:08:59 <dons> reading from the disk would be fine
08:09:01 <xerox> About the scheduler problem, is my problem what STM solves, perhaphs?
08:10:27 <dmhouse> Ooh, I can port the logger to use ByteStrings as well.
08:10:28 <xerox> Basically I want to accept requests, consider wether I can do it, acknowledge the client in that case, or tell him I can't. Come back with answers in case.
08:10:44 <dmhouse> Not that speed is that important because it's a long-running service, but hey.
08:11:00 <xerox> KISS :)
08:11:52 <dmhouse> well it wouldn't be hard to use ByteStrings. I'd keep the internal state using Strings, but then change the interface with the disk to pack the Strings first
08:11:53 <SamB> dmhouse: but... memory usage!
08:12:24 <dmhouse> SamB, ?
08:12:34 <dons> dmhouse: no, use ByteStrings internally
08:12:48 <dons> i'll be switching all io to bytestrings soon enough
08:13:02 <dmhouse> Ah, okay.
08:13:16 <xerox> ?docs Network
08:13:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
08:13:22 <dons> well, if its not too much work. if the existing code runs fine with String, then it can stay
08:13:25 <dmhouse> I'm getting ahead of myself. I need to write @last first.
08:13:31 <dons> but if you start flushing things to disk, you don't want to pack . write
08:13:53 <dmhouse> dons, actually, we don't store Strings internally at all. We store an ADT, then show it and write it to disk.
08:14:33 <dmhouse> There is a little bit of parsing code that turns an IRC message into the ADT which I could port over, though.
08:14:34 <dons> ah right.
08:15:00 <dons> so instead we should have a Binary instance for the ADT?
08:15:06 <dons> as in Seen.hs
08:15:27 <dmhouse> What's Binary?]
08:15:58 <dons> a class like Show/Read but for packed binary data. much more efficient
08:16:01 <dons> check Lib/Binary.hs
08:16:09 <dons> and the Binary instance for the Seen data type
08:16:18 <dmhouse> Right
08:16:36 <xerox> If I listen() on a port, can I accept() more than one connection at time?
08:17:45 <xerox> do { s <- listenOn port; let loop = do { i <- accept s; forkIO handle i; loop }; loop }
08:19:09 <dons> darcs makes hacking on ghc so much easier
08:19:13 <dons> ?karma+ darcs
08:19:13 <lambdabot> darcs's karma raised to 3.
08:20:36 <pierre-> @where fps
08:20:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
08:21:54 <xerox> Do we have a MonadScheduler? :)
08:23:13 <dons> that's a cool idea.
08:23:37 <xerox> Cale any ideas? I'm sure...
08:23:57 <xerox> Parametrized on the type of the process to schedule, and how to do it, maybe.
08:24:43 <xerox> But hmmm, there are a variety of schedulers, I think. One need to implement just one, or a limited subset.
08:26:26 <xerox> StateT IntMap IO a ...
08:26:27 <dons> hmm, ghc "feels" faster without all those Skipping messages printed
08:26:37 <xerox> (:
08:26:41 <dons> the psychology of debug info
08:26:54 <xerox> haha
08:26:56 <xerox> @karma- debug
08:26:57 <lambdabot> debug's karma lowered to -1.
08:29:27 <xerox> class Hash k where
08:29:27 <xerox>   hash :: k -> Int
08:29:28 <xerox> class (Monad m, Hash k) => MonadScheduler m p k where
08:29:28 <xerox>   schedule :: Process p -> m k
08:29:47 <xerox> Even without `Process'
08:30:56 <xerox> No I think it is okay.  Can one do: data Process p = Process { cmdLine :: String, p } ?
08:31:08 <xerox> Nah. info :: p or something.
08:31:20 <xerox> Yay for extensible records.
08:33:05 * dons -> sleep `ap` dons
08:33:11 <xerox> haha
08:33:15 <xerox> Goodnight
08:33:19 <dons> night.
08:34:30 <xerox> ?hoogle MonadError
08:34:31 <lambdabot> Control.Monad.Error.MonadError :: class Monad m => MonadError e m
08:34:38 <xerox> ?docs Monad.Error
08:34:39 <lambdabot> Monad.Error not available
08:34:42 <xerox> ?docs Control.Monad.Error
08:34:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
08:37:16 <xerox> ?docs Data.IntMap
08:37:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
08:39:55 <xerox> data Process = Process { cmd :: String, foo :: p }
08:39:55 <xerox> newtype Scheduler p a = Scheduler { runScheduler :: ErrorT (StateT (IntMap (Process p)) ()) a }
08:41:45 <dmhouse> xerox, what's an IntMap?
08:42:02 <xerox> ErrorT (StateT (IntMap (Process p)) IO a) a
08:42:09 <xerox> A Map whose keys are Ints.
08:42:28 <dmhouse> Oh, okay.
08:42:48 <dmhouse> weird that there'd be an entire module for it when type IntMap a = Map Int a would do :)
08:42:50 <xerox> (Particularly optimized, so to deserve a name.)
08:42:55 <dmhouse> Ah, okay.
08:59:52 <ptolomy> Any fun SoC news?
09:02:40 <dmhouse> The YHC project has swapped students
09:10:17 <astrolabe> Does anyone know of an efficient algorithm for finding the cut vertices of a graph?
09:13:34 <SamB> cut vertices?
09:14:28 <SamB> how does a project swap students?
09:15:14 <ptolomy> Similar to tires; when one has been worn down, you remove it with a crow bar and get a new one.
09:15:28 <mahogny> you remove students with a crowbar? :(
09:16:18 <BCoppens> astrolabe: erm, isn't there such an algorithm using BFS?
09:16:28 <astrolabe> A cut vertex in a connected graph is a vertex that, if you remove it and the edges touching it, leaves a dis-connected graph.
09:16:41 <BCoppens> yeah I know
09:17:00 <BCoppens> I've used that algo once
09:17:00 <astrolabe> BCoppens: Do you mean the obvious O(n^2) one?
09:17:17 <Pete_I> what is this O() you speak of?
09:17:19 <BCoppens> that's possible, I don't remember the details
09:17:31 * BCoppens didn't care much about the speed back then
09:17:43 <astrolabe> Try each vertex, and floodfill the remainder
09:17:47 <Pete_I> and what is the n in O(n) ?
09:17:52 <BCoppens> astrolabe: no I think not
09:17:55 <Pete_I> what's it called?
09:17:59 <BCoppens> astrolabe: it was using Breadth First Search
09:18:11 <astrolabe> n = number of vertices here
09:18:42 <astrolabe> BCoppens: Breadth first to do the flooding?
09:18:52 <Pete_I> what is this O(...) thing?
09:18:54 <joe_k> heh
09:19:10 <dmhouse> Pete_I: how slow an algorithm becomes as you increase the size of its input.
09:19:10 <astrolabe> petekaz: assymptotic efficiency
09:19:17 <mahogny> Pete_I, take a course in algorithms
09:19:23 <joe_k> google for "big o complexity"
09:19:29 <dmhouse> O(n) = algorithm's speed is proportional to the length of its input.
09:19:31 <Pete_I> joe_k, thank you.
09:19:45 <dmhouse> O(n^2) = algorthim's speed is proportional to the square of the length of its input
09:19:48 <dmhouse> and so on.
09:20:10 <Pete_I> i'd think that depends on the algorithm...
09:20:30 <BCoppens> astrolabe: it uses a single BFS
09:20:33 <astrolabe> Pete_I: exactly
09:20:44 <astrolabe> BCoppens: sounds interesting
09:21:01 <BCoppens> astrolabe: well, I think, I just glanced at it again ;)
09:21:36 <BCoppens> astrolabe: it's described in "Graph Theory and its Applications" J Gross & somebody's name I can't read =)
09:23:18 <BCoppens> astrolabe: http://www-math.cudenver.edu/~wcherowi/courses/m4408/gtaln6.html
09:23:25 <BCoppens> 'Finding Cut-vertices of a connected graph'
09:25:43 <astrolabe> BCoppens: Thanks! that might be really helpful.
09:26:12 <BCoppens> :-)
09:37:51 <dmhouse> Static typing might be able to catch typos at compile time, but it sure doesn't have a dumbass catcher.
09:38:01 * dmhouse deletes 'when' and writes 'unless'
09:47:37 <dmhouse> @tell dons I don't think ./ghci Main.hs is working any more, it dies with 'lexical error'.
09:47:37 <lambdabot> Consider it noted.
09:49:17 <petekaz> Does anyone have a 6.4.2 debian package available?
09:54:52 <petekaz> Do most folks compile and build their own ghc?
09:55:09 <Cale> almost nobody compiles their own ghc
09:55:23 <Muad_Dibber> Cale??
09:55:25 <olliej> petekaz: because ghc fights you every step of the way
09:55:54 <Cale> Muad_Dibber: It takes bloody ages.
09:56:32 <olliej> Cale: last time i was buildding i was trying to convinve ghc to dump the Core representation of the base libraries
09:56:37 <olliej> that was "fun"
09:56:53 <Muad_Dibber> Cale: I still think there are more people than you think that build ghc themselves (i.e. gentoo users that install ghc instead of ghc-bin?)
09:57:28 <Cale> (but who'd be silly enough to not take the binary ghc? :)
09:57:46 <Cale> I suppose gentoo users
09:57:52 <dmhouse> Hardcore gentooers.
09:57:59 <Muad_Dibber> Indeed
09:58:02 <dmhouse> s/Hardcore/Masochistic
09:58:18 <Muad_Dibber> It would be bullshit to compile your complete system "so it is faster", then not compile ghc yourself 
09:58:32 <olliej> dammit
09:58:45 <olliej> client carked it -- what was said since i last said anything
09:58:45 <olliej> ?
10:00:44 <dmhouse> olliej: meme.b9.com
10:00:49 <dmhouse> or, even
10:00:51 <dmhouse> @last #haskell
10:00:52 <lambdabot> 16:55:41 <Muad_Dibber> Indeed
10:00:52 <lambdabot> 16:55:44 <dmhouse> s/Hardcore/Masochistic
10:00:52 <lambdabot> 16:55:59 <Muad_Dibber> It would be bullshit to compile your complete system "so it is faster", then not compile ghc yourself
10:00:52 <lambdabot> 16:56:13 <olliej> dammit
10:00:52 <lambdabot> 16:56:26 <olliej> client carked it -- what was said since i last said anything
10:00:54 <lambdabot> [5 @more lines]
10:01:01 <dmhouse> use that in a /msg
10:01:07 <dmhouse> you can say @last 20 
10:01:19 <dmhouse> err, @last 20 #haskell if you want the last 20 lines (etc)
10:01:20 <olliej> :)
10:01:32 <olliej> dmhouse: cheers
10:02:17 <xerox> Cale, what do you think about |class Hashable h where hash :: h -> Int| |class (Monad m, Hashable h) => MonadScheduler m p h where schedule :: Process p -> m h; {- and something else to think yet -}| with |data Process p = Process { cmdLine :: String, etc :: p }| or something like that, to enforce some kind of standardization of the processes representation.
10:02:35 <Stinger_> I built ghc, just cause I was too slack to bother looking for the ghc-bin ebuild (didnt see it in the list) :P
10:03:25 <Stinger_> so add lazy gentoo users to the list I spose :)
10:03:42 <Stinger_> (its winter here my room gets cold ;D)
10:16:26 <dmhouse> > [] ++ ["foo"]
10:16:32 <lambdabot> ["foo"]
10:16:41 <dmhouse> jeez, I'm going insane trying to get this to work!
10:16:54 <Korollary> ?
10:17:39 <dmhouse> Hacking on lambdabot. One of those really frustrating moments where you _know_ it should work, but it doesn't.
10:27:16 <xerox> audreyt - ping
10:27:56 <dmhouse> Yes! Figured it out.
10:29:53 <xerox> Anybody using audrey's GHC bindist for macintels?
10:30:00 <xerox> The link the GHC trac is broken ):
10:33:27 <olliej> is there an url i can use to track progress of intel mac support?
10:34:04 <olliej> (for ghc)
10:34:29 <xerox> @tell audreyt The last ghc macintel bindist link is broken, mey you provide a working one? Thank you very much.
10:34:29 <lambdabot> Consider it noted.
10:36:42 <alar> what is delta-reduction?
10:37:43 <xerox> ?foldoc delta-reduction
10:37:45 <lambdabot> No match for "delta-reduction".
10:37:48 <xerox> ?foldoc delta reduction
10:37:50 <lambdabot> *** "delta" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
10:37:50 <lambdabot> delta
10:37:50 <lambdabot>  
10:37:50 <lambdabot> 1. A quantitative change, especially a small or incremental
10:37:50 <lambdabot> one (this use is general in physics and engineering).  "I just
10:37:52 <lambdabot> [70 @more lines]
10:37:54 <xerox> Nah.
10:38:04 <xerox> I never heard of that before, by the way.
10:38:26 <alar> @foldoc beta-reduction
10:38:27 <lambdabot> No match for "beta-reduction".
10:38:42 <alar> @foldoc beta reduction
10:38:44 <lambdabot> *** "beta" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
10:38:45 <lambdabot> beta
10:38:45 <lambdabot>  
10:38:45 <lambdabot> /bay't*/, /be't*/ or (Commonwealth) /bee't*/
10:38:45 <lambdabot>  
10:38:46 <lambdabot> [52 @more lines]
10:38:54 <xerox> \x -> f x  ~beta~reduction~>  f
10:38:58 <alar> @foldoc alpha-conversion
10:38:59 <lambdabot> No match for "alpha-conversion".
10:39:00 <xerox> (a.k.a. function application)
10:39:08 <alar> foldoc knows nothing
10:39:39 <alar> epigram papers mention beta, delta and iota reductions
10:39:55 <alar> and describe iota reduction
10:40:09 <alar> I wonder - what's delta
10:40:25 <xerox> #epigram ? :)
10:43:51 <alar> xerox: there are noone 
10:43:57 <alar> only shadow of shapr
10:44:10 <xerox> :|
11:01:10 <alar> @foldoc UTT
11:01:11 <lambdabot> No match for "UTT".
11:10:44 <VyNiL> hey, im new to haskell, and im having troubl developing a graph
11:11:22 <VyNiL> i dont understand how do you store the data
11:11:37 <VyNiL> if you insert a new node
11:11:52 <VyNiL> how do you make the graph store that new info_
11:11:54 <VyNiL> ?
11:12:03 <Muad_Dibber> you are on the wron track of thinking
11:12:11 <Muad_Dibber> storing is something you do in imperative programming
11:12:20 <Muad_Dibber> whereas haskell does parameter passing and returning
11:12:30 <VyNiL> yes, i belive thats the problem 
11:12:42 <VyNiL> but if i want to develop something like A*
11:12:47 <VyNiL> ok interactive data
11:13:11 <VyNiL> and I need to change the actual graph on wich im working
11:13:29 <VyNiL> how does the impertive way translate to haskell/functional?
11:13:29 <neologism> VyNiL: updateGraph :: Graph -> Graph
11:13:32 <neologism> where's the problem?
11:14:41 <VyNiL> your right... maybe i just need to 'stay functional', hehe
11:14:43 <VyNiL> thnx
11:19:51 <RyanT5000> has anyone written a Collada loader?
11:25:52 <fwfewfwa> hi, does anyone knows how to make this function tail recursive? partition :: [[Int]] -> [Int] -> Bool wich checks if the first parameter is a partition of the second? i need to do it only using list constructors, i can't use any list function, nor high order function nor anything that it isn't a list constructor... what i can only do is call directly a "generalizator" function of this one (partition = somefunction with more parameters)
11:32:28 <int-e> fwfewfwa: what exactly is a partition here? is [[1],[2,3]] a partition of [1,2,3]? what about [[],[1,2,3]]? Or [[1,3],[2]]?
11:33:11 <fwfewfwa> [[1],[2,3]] a partition of [1,2,3] yes... and sorry i forgot to mention that it should mantain the original relative order of the elements in the list...
11:33:21 <fwfewfwa> [[1,3],[2]] yes
11:33:31 <fwfewfwa> [[],[1,2,3]] this one whatever is easier for you...
11:33:45 <fwfewfwa> i don't care if null list is or is not...
11:33:55 <fwfewfwa> (i might prefer that is not, but whatever is easier for you in that case)
11:34:48 <int-e> ok. it can be done tail-recursively then; what problem do you have? could you compare two lists tail-recursively?
11:34:53 <norpan> should it return False if it is a partition but the elements are not in the correct order?
11:35:02 <fwfewfwa> <norpan> should it return False if it is a partition but the elements are not in the correct order? --> yes
11:35:19 <fwfewfwa> i know it can be done tail recursively
11:35:28 <fwfewfwa> the problem is that i don't realize at the moment how to do it :)
11:35:35 <int-e> (because this really is just a minor extension of comparing two lists)
11:35:45 <fwfewfwa> it's not just that, but well...
11:36:13 <fwfewfwa> i need to find a generalizator function strong enought (if it's really needed)
11:36:44 <RyanT5000> fwfewfwa: so, your function should be equivalent to \a b -> (sort $ concat a) == (sort b)
11:36:52 <RyanT5000> (i know you can't use any of those functions)
11:36:57 <fwfewfwa> mmm
11:37:16 <int-e> RyanT5000: the order isn't allowed to change --> remove the sort.
11:37:22 <fwfewfwa> nono
11:37:28 <RyanT5000> oh ok
11:37:30 <fwfewfwa> the order is allowed to change but not in any way
11:37:36 <int-e> ?
11:37:42 <RyanT5000> what does that mean?
11:37:54 <fwfewfwa> [1, 2, 3], [a, b, c]  and [1, 2, 3, a, b, c] is true
11:38:04 <fwfewfwa> [1, 2, 3], [a, b, c]  and [1, a, 2, b, 3, c] is true
11:38:11 <fwfewfwa> [1, 2, 3], [a, b, c]  and [a, 1, 2, b, 3, c] is false
11:38:30 <fwfewfwa> [a, b, c], [1, 2, 3]  and [a, 1, 2, b, 3, c] is true
11:38:43 <fwfewfwa> you could sort the "sublists" by the first element
11:38:44 <RyanT5000> so any interleaving is valid?
11:38:50 <fwfewfwa> in the order they appear in the final list...
11:38:55 <int-e> uhm.
11:38:59 <fwfewfwa> (and you can think that all elements are differents)
11:39:47 <int-e> uhm. I don't see any meaningful difference between [1, 2, 3], [a, b, c] and  [a, b, c], [1, 2, 3] then.
11:39:55 <RyanT5000> can you write it using normal functions, just so that we can understand it?
11:39:57 <fwfewfwa> yes
11:40:16 <fwfewfwa> [1, 2, 3], [a, b, c] can give [1, a, b, c, 2, 3] but [a, b, c], [1, 2, 3]  can't
11:40:27 <fwfewfwa> it's just a way to eliminate duplicates...
11:40:42 <RyanT5000> btw you know that everything in a haskell list has to be the same type, right?
11:40:49 <RyanT5000> so a b c better be the same type as 1 2 3
11:40:50 <fwfewfwa> yes
11:40:55 <fwfewfwa> i was just an example :)
11:41:55 <norpan> well, it's easy, just write the partitions function and then partition x y = x `elem` (partitions y)
11:42:39 <RyanT5000> norpan: isn't that obscenely slow?
11:42:50 <norpan> oh, you want a *fast* function
11:42:55 <RyanT5000> no
11:43:04 <RyanT5000> i'm just thinking that might be n! or something
11:43:19 <RyanT5000> i presume he needs to be able to run it in his lifetime
11:43:28 <norpan> n! it's certainly not
11:43:28 <int-e> hmm. I don't think it can be done fully tail-recursively.
11:43:38 <fwfewfwa> i don't care about speed
11:43:45 <norpan> or is it
11:43:46 <norpan> :)
11:43:59 <fwfewfwa> it *can* be done fully tail-recursively.
11:44:07 <int-e> f a b = concat a == b  could be.
11:44:10 <fwfewfwa> it might be really difficult, but it's possible to do it...
11:44:12 <RyanT5000> fwfewfwa: if it's n! you probably can't ever finish running it on a list over 15 or 20 long
11:44:34 <fwfewfwa> RyanT5000: i can, and complexity wouldn't be n!
11:44:35 <RyanT5000> int-e: can't you technically make anything tail recursive using continuations?
11:44:36 <norpan> partitions xs (p:ps) = partitions (remove p from the head of one of the elements in xs) ps
11:45:07 <int-e> RyanT5000: uhm, right. the run time system does that.
11:45:09 <norpan> and add a check if p is head of one of the elements of xs of course
11:45:11 <fwfewfwa> i can only use 1 function (and one that calls it with proper arguments)
11:45:17 <RyanT5000> int-e: i know :P
11:45:32 <RyanT5000> he needs it to be explicitly tail recursive
11:45:35 <int-e> norpan: but you have to keep track of which lists you already took elements from, because their order doesn't matter anymore.
11:45:39 <RyanT5000> not usefully tail recursive ;)
11:46:07 <norpan> oh, there is a restraint on the order of the partitions as well?
11:46:16 <norpan> i thought the restraint was only on the elements in each partition
11:46:52 <int-e> norpan: yes. the first elements of the partition are supposed to be a subsequence of the given list.
11:47:01 <int-e> norpan: or that's how I currently interpret it.
11:47:05 <RyanT5000> fwfewfwa: i think the best thing would be if you'd write it using normal functions so that we can understand exactly what you mena
11:47:06 <RyanT5000> *mean
11:47:21 <norpan> mena means mean in swedish
11:47:21 <int-e> norpan: (examples make bad specifications)
11:47:30 <norpan> int-e: indeed they do
11:47:59 <RyanT5000> int-e: i think an example would make a better spec than what we currently have
11:48:05 <RyanT5000> or do you guys understand what he's talking about?
11:48:58 <int-e> RyanT5000: scroll up to ten minutes ago
11:49:10 <int-e> RyanT5000: there were a few examples.
11:49:59 <norpan> if there is a restriction on the order of the partitions then it's a really tricky problem, otherwise, easy
11:50:04 <RyanT5000> ok so there are two constraints: concat a needs to contain the same elements as b
11:50:19 <RyanT5000> and each element of a needs to be a subsequence of b
11:51:08 <norpan> and the third is that (map head a) is a subsequence of b
11:51:09 <int-e> oh, another interesting question
11:51:14 <int-e> are duplicate elements allowed?
11:51:20 <norpan> at least that's what i gather from the examples above
11:51:21 <fwfewfwa> no
11:51:25 <RyanT5000> ah
11:51:32 <int-e> ok. that's at least something to work with.
11:52:14 <norpan> but then he said that empty elements are optional so maybe it's not that strictly specified after all
11:52:29 <int-e> so partion_check p l = and [subsequence t l | t <- map head p : p]
11:52:49 <RyanT5000> i'd just write it in high-level code then rewrite each of the functions i used, until i finally have something that uses only what i'm allowed to sue
11:52:50 <RyanT5000> *use
11:53:08 <int-e> hmm. and all subsequences are disjoint
11:53:15 <int-e> and their union is the complete list :/
11:54:01 <norpan> i find it not so interesting to solve underspecified problems
11:54:45 <RyanT5000> i agree
11:55:23 <RyanT5000> i need a complete spec before i'll understand what exactly you want fwfewfwa
11:56:47 <int-e> manual list fusion isn't exactly fun either.
11:59:18 <fwfewfwa> :(
12:27:13 <int-e> @pl foldr id
12:27:13 <lambdabot> foldr id
12:27:22 <int-e> > let part [] = [[]]; part (x:xs) = mapM (\x' -> [first (x':), second (x':)]) xs >>= return . foldr id ([], []) >>= \(l, r) -> (fmap ((x:l):) $ part r) in part [1,2,3]
12:27:23 <lambdabot> [[[1,2,3]],[[1,2],[3]],[[1,3],[2]],[[1],[2,3]],[[1],[2],[3]]]
12:32:13 <RyanT5000> has anyone here used HXT?
12:33:21 <evergreen> I'm tinkering with HAppS.  Anyone know what :*: means?
12:43:49 <skew> no, but what type is it from?
12:45:15 <mauke> @index (:*:)
12:45:16 <lambdabot> bzzt
12:47:07 <int-e> hmm. type e :*: l = HCons e l ... from HList.
12:47:14 <skew> It's part of a "StdPart", whatever that is
12:47:39 <skew> a list of type "exists cf . ConfHandler cf => cf -> Handler st"
12:47:48 <mauke> @where HList
12:47:48 <lambdabot> http://homepages.cwi.nl/~ralf/hlist/
12:48:22 <skew> The :*: in HAppS is different
12:50:57 <int-e> oh. it's just a fancy list, not heterogenous at all.
12:51:47 <int-e> that :*: is just a data constructor, similar to :
12:52:27 <skew> exactly the sort of thing we need impredicative polymorphism for
12:55:38 <skew> ConfHandler is an odd class
12:55:56 <skew> an instance for cf consists of operations on functions of type (cf -> Handler st)
12:58:02 <jer> as far as naming convention goes, why would someone suffix an identifier with a ' ? (apologies for the [seemingly] silly question)
12:58:37 <lscd> that's a natural suffix for a boolean function; aside from that, no idea
12:58:52 <jer> ok
12:58:56 <resiak> I think jer means suffixing with an apostrophe
12:59:02 <jer> yeah
12:59:05 <lscd> oh.... right
12:59:08 <resiak> (as in "let x prime = foo x"
12:59:38 <lscd> hm.. to show that it was related to the original x?
13:08:06 <int-e> jer: for me, it's also a natural suffix for variables that are similar to, or strongly related to, another variable. Say, f xs = if null xs then 0 else let (x:xs') = xs in 1 + f xs' ... xs' is almost the same as xs, just one item shorter. (f is a bad implementation of length; it's just an example)
13:09:20 <jer> int-e, thanks
13:38:02 <stepcut> is there something like haskell weekly news for LtU ?
13:40:46 <Korollary> If there was, it would be like "User X drags on the static vs dynamic debate to its third week..."
13:41:34 <stepcut> Korollary: yeah, that is why I don't subscribe to LtU -- but it seems like 1% of the threads would be interesting to know about
13:42:01 <stepcut> like this one: http://lambda-the-ultimate.org/node/1540
14:58:35 <beelsebob_> hmm... is it possible to get the equiv of "make -j2" using ghc --make, or hmake?
14:58:56 <beelsebob_> or for that matter yhc --make
14:59:38 <xerox> I don't think so.
14:59:48 <beelsebob_> damn
15:00:03 <beelsebob_> because compiling is IO bound on this box
15:00:19 <beelsebob_> and make -j2 just about lifts manages to stop it from blocking enough
15:00:33 <beelsebob_> s/lifts//
15:00:39 <xerox> Maybe you can do that by using something like `Distribution.Parallel' (not that it does exist as now.)
15:00:54 <beelsebob_> indeed
15:01:21 <beelsebob_> I take it then that ghc --make doesn't spawn seperate ghc processes for each compile then
15:01:29 <beelsebob_> that's all it would need to do
15:01:51 <beelsebob_> (i.e. spawn n processes for the number of jobs and keep filling them up with things to do)
15:01:55 <Igloo> I think the HEAD supports -j
15:01:55 <skew> I think ghc 6.5 has a -j option with --make
15:02:02 <xerox> Impressive!
15:02:06 <hyrax42> @hoogle [(a, b)] -> a -> [b]
15:02:07 <beelsebob_> cool :)
15:02:07 <lambdabot> No matches, try a more general search
15:02:20 <skew> which spawns a separate thread for each file, which just blocks until all the dependencies have been built
15:02:23 <beelsebob_> @hoogle lookup
15:02:24 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:02:24 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
15:02:24 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
15:02:27 <xerox> I think GHC is the most elaborate *useful* program I have ever seen.
15:02:40 <skew> one of the examples from the multithreaded runtime paper - took 30 lines of code or so
15:02:53 <hyrax42> @hoogle [(a, b)] -> (a -> Bool) -> [b]
15:02:54 <lambdabot> No matches, try a more general search
15:02:56 <hyrax42> or hm
15:02:58 <hyrax42> filter 
15:03:10 <beelsebob_> xerox: and and emacs is the most elaborate paper progarm you've ever seen
15:03:11 <beelsebob_> ?
15:03:15 <beelsebob_> *g*
15:03:37 <skew> hyrax42: [b | (a,b) <- list, pred a]
15:04:21 <hyrax42> @index array
15:04:21 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
15:04:33 <hyrax42> skew: argh
15:04:37 <beelsebob_> hyrax42: f g = map snd . filter (g . snd)
15:04:41 <beelsebob_> oops
15:04:48 <beelsebob_>  f g = map snd . filter (g . fst)
15:04:49 <hyrax42> beelsebob_: I was almost there
15:05:14 <hyrax42> but the list comp is way nicer
15:05:19 <beelsebob_> indeed it is
15:05:29 <beelsebob_> but I tend to avoid list comp... for no real reason
15:05:35 <beelsebob_> just providing an alternative :)
15:05:40 <hyrax42> apparently so do I
15:05:45 <hyrax42> it didn't even cross my mind
15:06:24 <mauke> @djinn [(a, b)] -> (a -> Bool) -> [b]
15:06:25 <lambdabot> -- f cannot be realized.
15:07:05 <beelsebob_> @djinn [(a,b)] -> a -> [b]
15:07:05 <lambdabot> -- f cannot be realized.
15:07:05 <int-e> \_ _ -> []
15:07:28 <xerox> [] :: c there?
15:07:38 <int-e> @type \_ _ -> []
15:07:39 <lambdabot> forall a t t1. t1 -> t -> [a]
15:08:03 <xerox> That's what I mean, it is not "constructive".
15:08:14 <int-e> this is just what I'd expect Djinn to print if it knew about lists.
15:09:14 <xerox> Since we have ArrowPlus I imagine such a function would look pretty in arrow syntax, but I am too sleepy to roll it up.
15:09:26 <xerox> By the way, goodnight.
15:10:11 <beelsebob_> gn
15:10:20 <hyrax42> @index minMax
15:10:21 <lambdabot> bzzt
15:10:43 <hyrax42> @hoogle Ord a => [a] -> (a,a)
15:10:43 <lambdabot> No matches, try a more general search
15:14:13 <hyrax42> bleh too late
15:14:19 <hyrax42> night and thanks
15:15:06 <beelsebob_> minMax :: [a] -> Maybe (a,a)
15:15:07 <beelsebob_> minMax [] = Nothing
15:15:07 <beelsebob_> minMax (x:xs) = case minMax xs of
15:15:07 <beelsebob_>                   | Nothing -> (x,x)
15:15:07 <beelsebob_>                   | Just (min,max) -> (if x < min then x else min,if x > max then x else max)
15:15:10 <beelsebob_> night hyrax42 
15:16:00 <beelsebob_> bah... insert necessary Justs
15:16:06 <hyrax42> oh beelsebob_ I can do it, just decided I wanted to stop rewriting prelude functions
15:16:07 <Cale> Just (a,b) -> (min a x, max b x)
15:16:19 <beelsebob_> Cale: yes... but that's not as efficient
15:16:25 <hyrax42> cale, inefficient
15:16:26 <Cale> hm?
15:16:32 <hyrax42> double traversal
15:16:44 <Cale> I'm just replacing the last case there
15:16:46 <hyrax42> unless ghc is smarter than I thought
15:16:54 <beelsebob_> indeed, but I don't think it is
15:16:57 <Cale> those only test one element
15:17:08 <hyrax42> oh gah
15:17:10 <hyrax42> like I said
15:17:12 <hyrax42> too late!
15:17:17 <hyrax42> @localtime hyrax42
15:17:20 <lambdabot> Local time for hyrax42 is Sun Jun 11 02:17:21 2006
15:32:14 <lscd> what data structure / module is it conventional to use in haskell to look up values given some key?  In most languages, I'd use some kind of dictionary or assoc list
15:32:24 <skew> Data.Map
15:32:31 <mauke> Data.Map.Map
15:32:38 <lscd> thank you
15:32:48 <mauke> or an assoc list, if you're lazy
15:32:54 <mauke> @type lookup
15:32:56 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
15:33:34 <lscd> googling on those on haskell.org brought me to some wishlist-linking pages, but was short on actual info - details/url?
15:33:44 <Cale> @docs Data.Map
15:33:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
15:33:54 <beelsebob_> lscd: haskell.org/hoogle
15:34:02 <lscd> Cale: ehm, i was unclear, sorry; i found Data.Map, but not much on assoc-list
15:34:13 <Cale> oh, they're just lists of pairs
15:34:22 <Cale> [(a,b)] for some types a and b
15:34:30 <Cale> @type lookup
15:34:31 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
15:34:38 <Cale> you can use that to do lookups
15:34:40 <lscd> ahh, ok; that's what i thought at first, but then i started googling and got confused
15:34:54 <lscd> cool, thanks
15:35:30 <Cale> Assoc lists are much slower than Data.Map, and are a common reason for a Haskell program being slow
15:35:46 <Dino__> Wow, I'm glad I was here to read that. After reading YAHT, I was under the impression that Data.FiniteMap was what you use.
15:36:00 <Cale> Data.FiniteMap is the old version of Data.Map
15:36:01 <Dino__> But I see now from the HHL that FiniteMap is deprecated.
15:36:01 <lscd> hm.... what i'm trying to do is, given a fairly small (~100-1500 lines), parse it and then deal with the data in it
15:36:15 <lscd> fairly small file, even
15:36:24 <Korollary> Data.Map is quite easy to use
15:38:04 <lscd> woah; this is a binary-tree based pure functional map?
15:38:11 <Cale> yes
15:38:14 <lscd> cool!
15:43:27 <kpreid_> is there a function for Dynamic -> TypeRep?
15:43:45 <Lemmih> @hoogl Dynamic -> TypeRep
15:43:45 <lambdabot> Maybe you meant: hoogle hoogle+
15:43:50 <Lemmih> @hoogle Dynamic -> TypeRep
15:43:50 <lambdabot> No matches, try a more general search
15:47:07 <kpreid_> I actually only want a string describing the type, so this is good enough, though ugly:
15:47:17 <kpreid_> (\x -> read $ let s = show x in take (length s - 4) (drop 2 s)) :: Dynamic -> String
15:47:28 <kpreid_> er, remove the "read $"
15:47:35 <kpreid_> (that was an experiment)
15:47:52 <lambda_the_insig> is Data.FiniteMap deprecated for performance reasons?
15:48:48 <kpreid_> @type take
15:48:49 <lambdabot> forall a. Int -> [a] -> [a]
15:49:00 <skew> hyrax42: [b | (a,b) <- list, pred a]
15:49:03 <kpreid_> @hoogle Int -> Int -> [a] -> [a]
15:49:04 <lambdabot> No matches, try a more general search
15:49:09 <skew> oops
15:49:13 <lambda_the_insig> I've written an interface to Data.Map which emulates Data.FiniteMap's interface.  I don't know if it would be somewhat useful to people out there, but I have the code available which should be API compatible with Data.FiniteMap
15:49:15 <kpreid_> @hoogle [a] -> Int -> Int -> [a]
15:49:16 <lambdabot> No matches, try a more general search
15:49:52 <darrint> Is there a library for writing png or jpeg, or even mpeg files?
15:52:33 <Anil> is GHC available on netbsd pkgsrc? (sorry, I a compiling my firefox)
15:52:40 <lambda_the_insig> darrint: http://haskell.org/haskellwiki/Graphics
15:54:10 <stepcut> darrint: native haskell ? or C ?
15:54:23 <darrint> hugs atm
15:57:23 <stepcut> darrint: I have not seen much in the way of graphics file formats in haskell -- especially writing them. You could probably bind to a C library, or use a command-line tool to convert from raw -> png
15:57:40 <darrint> what I can't figure out is way to write that raw format in the first place.
15:57:42 <stepcut> darrint: though, in 6+ months, I may have a png and jpeg library 
15:58:26 <darrint> Is there an "easy" way to get from opengl to a series of images/
15:58:27 <darrint> ?
15:58:39 <stepcut> darrint: Yes
15:58:49 <darrint> I'd greately appreciate a pointer.
15:59:05 <stepcut> darrint: let  me look it up real quick
15:59:17 <Taral> Does John Goerzen happen to be around?
15:59:33 <stepcut> @seen CosmicRay
15:59:33 <lambdabot> I haven't seen CosmicRay.
15:59:59 <Taral> :( can't compile missingh
16:00:25 <darrint> stepcut, http://www.mesa3d.org/brianp/sig97/offscrn.htm ?
16:01:31 <stepcut> darrint: yes, something like that 
16:01:44 <stepcut> darrint: you render the image into a buffer, and then read the pixels out
16:01:50 <stepcut> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-ReadCopyPixels.html#v%3AreadPixels
16:02:16 <stepcut> I think readPixels is the right function for getting the OpenGL out of OpenGL and into a pointer
16:02:16 <darrint> Thanks. I'll play with this.
16:02:34 * darrint goes hunting for hello world in hopengl
16:03:06 <lscd> darrint: http://www.haskell.org/~pairwise/HOpenGL/HOpenGL.html might be of interest to you
16:03:16 <stepcut> darrint: http://www.haskell.org/hawiki/HaskellOpenGl
16:04:45 <stepcut> darrint: I recommend using Lemmih's SDL binding over GLUT
16:05:15 <Taral> aha fixed!
16:05:22 <stepcut> SDL is more functional programming friendly (ie, processing event streams) than GLUT (callbacks)
16:05:32 <Taral> remove "Allow" from the Extensions lines (there are two of them)
16:09:31 <lscd> dumb question: how do I import the ParsecToken module in ghc?  I can import Text.ParserCombinators.Parsec -- but i'm not able to find the ParsecToken module
16:10:34 <skew> check the docs - it's Text.ParserCombinators.Parsec.Token, probably
16:11:09 <skew> but quite close to that, there's the thing where makeTokeParser returns a record full of functions, but they are documented like a module
16:11:39 <skew> Do you have a copy of the GHC documentation open?
16:11:50 <lscd> I was checking the docs - http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html specifically; it mentions module Text.ParserCombinators.Parsec.Prim, module Text.ParserCombinators.Parsec.Combinator, and module Text.ParserCombinators.Parsec.Char
16:12:53 <darrint> rats, debian doesn't ship with hsSDL for hugs
16:13:03 <skew> those are the ones re-exported by Text.ParserCombinators.Parsec.
16:13:15 <lscd> ah... i had to go to the parent directory of that url, at which point i found the token page; googling wasn't turning it up
16:13:24 <lscd> thanks
16:13:42 <skew> it's a good idea to get a copy of the docs and keep the index open
16:13:48 <lscd> ack
16:14:06 <skew> \msg lambdabot @lisppaste
16:15:11 <darrint> Is there a deb for cabal?
16:15:40 <lisppaste2> skew pasted "OpenRecord.hs" at http://paste.lisp.org/display/21114
16:16:07 <skew> that might be useful if you actually intend to use the Token module
16:17:04 <skew> It automates binding all the elements of that TokenParser record at the top level
16:17:45 <lscd> thanks
16:17:51 <lscd> right now, i'm trying to figure out what to use, frankly
16:18:00 <skew> what are you trying to parse?
16:18:12 <skew> the Token stuff is probably the right thing if you generally want to ignore whitespace
16:18:27 <lscd> a file with a bunch of records in the form "blah: someval", plus some extended sections which start, have a bunch of records, and end
16:18:49 <lscd> yes; the files are pretty regular, but i'd mildly prefer ignoring whitespace
16:20:57 <skew> Parsec should work well
16:21:17 <lscd> sure - once i get the hang of it
16:21:43 <lscd> right now i'm thinking of trying to read the elements and put them into a map
16:22:27 <lscd> i've used lex and yacc; and in python, i'd just do a bunch of ad-hoc things and use a dictionary; but trying to do this cleanly in haskell is still something i'm trying to figure out
16:23:12 <skew> The thing most parser generators seem to be missing is abstraction - some way to parse a list of things matching some production
16:23:14 <lscd> the receipt example in the parsec docs shows a lot of the bits that i need, but i'm still trying to figure out all the stuff to import to make it work
16:23:30 <lscd> and parsec isn't missing that?
16:23:47 <skew> no, there are nice combinators like many :: Parser a -> Parser [a]
16:24:03 <lscd> ahhh; yeah - the parsec combinators are really nice
16:24:26 <skew> have you tried looking up the missing functions in the index of the GHC documentation?
16:25:34 <Philippa_> lscd: parsec's core is close to if not actually turing complete, you can built arbitrary combinators on top
16:25:43 <lscd> doing; it's a bit annoying that it's letter-by-letter though
16:25:47 <Philippa_> many et al aren't 'core' :-)
16:26:11 <Philippa_> the Parsec docs're useful once you look at the per-module function listings
16:26:16 <lscd> Philippa_: yeah; in this case, i was looking for Data.Char for digitToInt
16:26:25 <Philippa_> ah :-)
16:26:36 <skew> It's all letter-by-letter in the end - but there are nice things like string :: String -> Parser String
16:27:18 <skew> parsing a number is one of the things Token gives you - token basically takes care of the layer that might go in the lexer if you were using yacc + lex
16:27:30 <skew> or have you been around here long enough I should say Alex and Happy?
16:27:47 <lscd> i've heard of Alex and Happy but not looked at either
16:28:10 <lscd> i'm more familiar with lex and yacc
16:28:18 <skew> they are pretty close, just cleaner
16:28:29 <skew> that and Happy does GLR, which is fun to play with
16:28:33 <lscd> hm, ok
16:28:33 <palomer> alex/happy are pretty similar to yacc/lex
16:28:35 <lscd> GLR?
16:29:48 <skew> parses arbitrary context-free grammars, and preserves ambiguity if there is any
16:30:09 <lscd> ahhh
16:34:46 <skew> I've just experimented with it a bit, but I suspect it might be useful for incremental parsing
16:35:10 <skew> or some related sort of algorithm, anyway
16:35:37 <lscd> bleh. I seem to be able to get all of the example code I try, except for the receipt example, to load
16:35:48 <skew> what's the problem there?
16:36:13 <lscd> a bunch of type errors; if I can't figure it out in another min or two, I'll pastebin it
16:39:07 <lscd> http://www.cs.uu.nl/~daan/download/parsec/parsec.html <-- the definition of 'lexer' has a syntax error, if I'm not mistaken; it has a ( without a )
16:39:47 <skew> yep
16:41:08 <skew> has anybody heard the phrase "binding structure"? I seem to recall seeing it in some paper related to CINNI, but I haven't found it again
16:42:49 <skew> It's something like an algebra, but a constructor takes patterns as well as terms, and the type description includes a specification of the scoping
16:48:17 <lscd> hm.... given that i'm importing import Text.ParserCombinators.Parsec.Language( haskellStyle ) -- why is haskellDef not in scope? It's definined in Text.ParserCombinators.Parsec.Language
16:48:40 <Philippa_> skew: interesting. It sounds much like a formalised version of how I'd describe let, do et al...
16:48:44 <skew> because you are just importing "haskellStyle" from that module
16:48:52 <lscd> d'oh. right. thank you
16:49:22 <skew> Philippa_: yeah, that's kind of the idea. I'm trying to figure out if I can mix this with polymorphic variants or something to let ordinary functions control binding
16:49:31 <lscd> ' GHC internal error' is probably something I don't want to be seeing, ne? :/
16:49:43 <skew> yeah - what GHC?
16:49:50 <lscd> 6.4.2
16:50:29 <Philippa_> skew: ooh, interesting idea. I suspect next time I explain monads to someone I might describe do as generalised let (and mdo as generalised letrec)
16:51:25 <skew> I'm trying to chip away at the things you "really need macros" to do :)
16:51:58 <lscd> [built from source, on gentoo, ~amd64]
16:52:07 <Philippa_> see if it'd give you the flexibility to build case statements on top of it?
16:53:43 <Philippa_> wow, googling "binding structure" doesn't yield a bondage link at the top
16:54:01 <Philippa_> though in fairness I guess it's only a term people who actually practice it'd look for rather than those looking for porn
16:54:01 <lscd> http://pastebin.ca/63987
16:54:02 <skew> I know, doesn't yield much at all, in fact
16:54:35 <lscd> shows the code i've (slightly) changed from the parsec home page (to get it to load) and the ghci error
16:54:54 <skew> oh, now it's about binding books
16:56:06 <skew> Philippa_: even so, sounds like you should at least see a howto or something
16:56:17 <Taral> Is there a shift/reset implementation for haskell?
16:56:22 <Taral> perhaps a monad transformer?
16:56:25 <skew> yeah
16:56:30 <darrint> Can anyone help me install hssdl with hugs on Debian? I've done darcs get but can't figure out what to do next.
16:56:46 <skew> or, there was some kind of more general delimited continuations
16:57:17 <Philippa_> skew: it wouldn't be a howto, it'd be a detailed discussion - rope bondage can get pretty intricate
16:57:38 <Philippa_> howto level stuff'd amount to "here's a book of knots, here're the important safety points to bear in mind..."
16:57:54 <Philippa_> you can find that in the better generic FAQs anyway
16:58:52 <skew> darrint: ./configure --help? less README? ./Setup.lhs --help?
16:59:40 <darrint> there's a not executable configure script and ./Setup.lhs file that doesn't seem to work...
17:00:03 <darrint> rats... pastebin is broken.
17:00:53 <lscd> darrint: yeah - i'm using pastebin.ca instead
17:01:54 <darrint> ok, I'm an idiot. I'm supposed to chmod +x it.
17:02:27 <darrint> But I still can't get it to work with runhugs (vs. runhaskell)
17:02:49 <darrint> http://pastebin.ca/63990
17:04:43 <skew> Philippa_: The google results start with lots of pages on other subjects that use the phrase "binding structure" - it's the Yahoo results that are strange, pages of things on biochmistry that just talk about "structure" and "binding" separately a lot
17:05:32 <skew> ha, adding quotes to the Yahoo query give you bunches of pages containing the string "binding. Structure"
17:06:11 * Philippa_ sniggers
17:06:24 <Philippa_> I managed to find the name of a paper that might be useful, but can't track it down on citeseer
17:08:57 <Philippa_> (see PM, yell if you can find it online? I can't...)
17:09:12 <skew> PM?
17:09:45 <Philippa_> private message
17:09:50 <skew> ah, yeah
17:10:12 <skew> perhaps "binding signature" was the term
17:11:17 <skew> anyway, the general idea of adding binding information to a type system seems pretty simple
17:12:06 <skew> I was thinking of making first class patterns, with types like Pattern (Int,Bool) { x:: Int, arg:: (Int,Bool}
17:17:07 <skew> lscd: getting along with the parser?
17:17:22 <lscd> nope; still stuck with the ghci internal error i pastebin'd
17:18:33 <Philippa_> have you got any nicely-scaling use cases for first-class patterns?
17:19:28 <Philippa_> I'm not sure ones with variables in them make a lot of sense to me. Actually scratch that, they sound a lot like 'views'
17:19:43 <Philippa_> so the main thing they'd be competing with's transformational patterns
17:20:29 <Philippa_> the rest of the time they're just generalised equality, no?
17:21:11 <skew> lscd: it looks like it's just saying that it doesn't know about that label
17:21:50 <skew> the matching part is pretty much just equality
17:21:58 <skew> but the interesting part is actually being able to bind stuff with them
17:22:09 <lscd> hm... reservedOpNames = P.reservedOpNames lexer -- is given as a definition; and I'd expect a simple 'Not in scope', not a ghci internal error
17:22:43 <skew> oh - field names and functions are in the same namespace, so ghci probably got quite confused
17:23:44 <lscd> ahh
17:24:28 <skew> I
17:24:56 <skew> I don't have too many use cases - maybe stuff like higher-order abstract syntax
17:25:08 <lscd> right, fixed; thanks
17:25:22 <lscd> that was annoyingly painful
17:25:28 <Philippa_> it's only interesting if you can do type inference on them, anyway - otherwise you're really just saying "here's a function and I'll bind the tuple it returns"
17:25:44 <Philippa_> (and the inference just gets you not naming the variables they bind)
17:26:15 <skew> type inference would just need to fill in the types anyway - names and some structure comes from the pattern itself
17:26:31 <skew> I'm thinking along the lines of Daan's first class label stuff
17:27:06 <Philippa_> er, surely if the pattern's first class you /don't know what names it's binding/? And therefore they need to be in the type to make it 'safe'?
17:27:25 <Philippa_> so you're still using inference to propagate the names
17:27:57 <Philippa_> and it'd be unobvious if no patterns're coming from within the module/compilation unit, too
17:27:59 <lscd> so - on the receipt example, here's the code and the error i'm getting trying to use it: http://pastebin.ca/64002
17:28:29 <Philippa_> (OK, so you could just say "all other-wise unbound variables within the relevant scope"...)
17:28:42 <skew> right, I was just thinking of how you type a pattern definition. I'm hoping the machinery from row-variable polymorphism will help with the type propagation
17:29:03 <skew> One big hole in my scheme is how you handle the terms that have names getting bound
17:30:02 <Philippa_> the machinery'd do the propagation from pattern to usage site fine, the problem's specifying which variables within the binding-block you actually intend to be bound
17:30:21 <skew> yeah - if you know the list it can just take a record, and things are good
17:31:21 <Philippa_> OTOH, if you know the list you're not far off not having first-class patterns any more. They may as well be pattern-match functions returning a record
17:31:36 <skew> yeah
17:32:23 <skew> your point about views is good
17:33:00 <Philippa_> I'm increasingly convinced transformational patterns're the Right Thing there if anything is
17:33:50 <skew> "Pattern Guards and Transformational Patterns"?
17:33:56 <Philippa_> yeah
17:34:21 <Philippa_> pattern guards got implemented, I'd like to know if transformational patterns weren't through lack of demand or through turning out to be an even bigger PITA to implement well than expected...
17:36:05 <skew> they say they can be implemented by translation to pattern guards
17:36:13 <skew> the Right Thing for what?
17:37:44 <skew> darrint: looks like the package is broken
17:37:54 <darrint> I managed to get it to work though.
17:38:08 <skew> oh, good - did you have to edit the Setup.lhs file?
17:38:52 <darrint> Well, I had to use ghc, not hugs, but it worked fine when I figured out to chmod +x the setup file.
17:39:32 <skew> right, I'm just being stupid - sounds like the . was from a forall
17:44:33 <mathewm> > const 1 2
17:44:34 <lambdabot> 1
17:44:47 <Philippa_> skew: d'oh, got caught up elsewhere. The Right Thing for views and related pattern-matching extensions
17:45:00 <Philippa_> (and also in terms of being a minimal extension)
17:45:06 <mathewm> for what is const useful?
17:45:41 <Philippa_> something like \l -> fold (+) 1 (map (const 1) l
17:46:05 <Philippa_> only with the closing paren, and where the partial application'd be more of a pain in the arse instead of easier
17:46:06 <mathewm> count + 1?
17:46:34 <Korollary> id is not very useful by itself either. It helps to have them when you're manipulating existing code, tho.
17:46:49 <mathewm> ok, I see that now
17:47:01 <mathewm> Korollary: hows it going?
17:47:26 <Korollary> groovy. Watching the stanley cup
17:47:52 <Philippa_> mathewm: it's late here :-)
17:48:00 <palomer> my ex lived on stanley street :<
17:48:17 <Korollary> Philippa_: But you have the sleeping patterns of Dracula
17:48:57 <skew> thus the smile - she rules the night
17:49:27 <Korollary> the ansi common lisp standard is 1300 pages.
17:50:17 <skew> I remember when I used to be up to talk with the Swedes all the time, but now I have to get up for a job :(
17:50:35 <Philippa_> Korollary: I don't, as it happens. I should go to bed soonish or I'm really going to regret it tomorrow
17:50:45 <Philippa_> if I get to the point of it being light when I go to sleep, it sucks
17:54:30 <lscd> indeed\
17:54:33 <mathewm> sadness ~ length [1..n]  seems to be O(n); seems like that could be trivially optimized
17:55:11 <lscd> given that it's an hour later here, i shall sleep 
17:55:16 <Korollary> mathewm: heh. Fortunately it's not a common usage pattern.
17:56:16 <mathewm> In general, though, it seems like list comprehensions should know or be able to compute their lengths without being strict
17:58:09 <mathewm> This is smart: length [ [1..1000000000000] !! 3000000 ]
18:03:52 <Taral> mathewm: That would require some form of dependent types.
18:04:00 <mathewm> um, how do you interrupt GHCi? I asked it to do something stupid...
18:04:09 <Taral> ctrl-c, unless you're on windows.
18:05:54 <mathewm> took it a while, but ctrl-c finally worked - thanks
18:07:21 <Taral> yeah, if you're stuck in a compiled pure computation, it can take a while.
18:07:35 <Taral> (ctrl-c takes effect when we call the allocator)
18:10:45 <Lemmih> Taral: Really?
18:11:03 <Taral> That's what I've been told.
18:11:17 <Lemmih> Taral: 'let l () = l () in l ()' never allocates memory and it can be terminated with C-c.
18:11:26 <Taral> did you compile it?
18:12:01 <mathewm> ?hoogle Integeger -> [a] -> ( [a], [a] )
18:12:02 <lambdabot> No matches, try a more general search
18:12:13 <Taral> Lemmih: Like I said, just what I've been told.
18:12:31 <Taral> Although you're right... we should just be able to siglongjmp out when SIGINT arrives.
18:12:53 <Taral> Perhaps he was dealing with a lot of output and had to wait for buffers to empty.
18:12:53 <kpreid_> Does this exist already, in a library or not?  data AnyEq = forall a. (Eq a, Typeable a) => AnyEq a; instance Eq AnyEq where (AnyEq a) == (AnyEq b) = case cast a of Just a' -> a' == b; Nothing -> False
18:13:13 <Taral> kpreid_: Don't think so.
18:13:46 <Lemmih> Taral: oh actually, you were told the truth.
18:14:04 <Taral> okay, byebye
18:18:40 <kpreid_> and is it more or less readable if I rewrite that case expression as "maybe False (== a) (cast b)"?
18:32:37 <mathewm> ?pl \(a,b) -> [a,b]
18:32:37 <lambdabot> uncurry ((. return) . (:))
18:32:54 <mathewm> wow
18:33:46 <mathewm> ?pl \(a,b,c) -> [a,b,c]
18:33:46 <lambdabot> (line 1, column 6):
18:33:47 <lambdabot> unexpected ","
18:33:47 <lambdabot> expecting letter or digit, operator or ")"
18:33:47 <lambdabot> ambiguous use of a non associative operator
18:37:46 <audreyt> xerox: sorry, retry the link
18:37:47 <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.
18:38:51 <audreyt> xerox: http://pugs.blogs.com/dist/ghc-6.5.20060608.tar.bz2
18:39:23 <audreyt> notably I didn't include fps in base for that build
18:39:40 <audreyt> because the half-merged-in state is broken for the purpose of building pugs
18:41:45 <mathewm> anyone know how to get ':info' on a function of a specific class?  I want to see info on 'return' of the [] monad
18:45:08 <Korollary> mathewm: there's no more info than the type. You can check the instance declaration in the standard, tho
19:17:12 <mathewm> (. return) . (:)    That is really a great example of just how deeply different functional composition is
19:23:39 <mathewm> ?hoogle [ a->b ] -> a -> [b]
19:23:40 <lambdabot> No matches, try a more general search
19:25:15 <mathewm> ?hoogle (a->b) -> a -> b
19:25:16 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
19:25:17 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
19:25:17 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
19:26:09 <Pete_I> ....scary
19:26:21 <Pete_I> looks like perl6
19:26:27 <joe_k> heh
19:27:27 <Cale> what does?
19:27:43 * jer presumes $!
19:30:54 <Dino__> The $ I think yeah, and the dot thing. P6 is adopting that for much (all?) places where -> used to be used.
19:32:29 * jer wonders if "3" + "5" * 5; will still be a legal expression in perl6 (producing the value 40)
19:32:38 * jer shivers
19:32:41 <Pete_I> yep
19:33:29 <Pete_I> why would that be bad?
19:33:44 <mathewm> I haven't even seriously tried to learn perl6 yet - just seems so much "up in the air" still
19:34:29 <Pete_I> there're implementation of the current spec, but they're still developing the specifications for it.
19:34:56 <jer> Pete_I, personal taste... i'm not too big on types, so long as it walks like a duck and talks like a duck i'llconsider it a duck.. but i read "3" + "5" and i don't get at 8 =]
19:35:04 <Pete_I> i've only learned a small bit of it. i'm sticking with perl 5 till i see better stuff on perl6
19:35:38 <Pete_I> jer, why not? 3 + 5 is 8.
19:35:42 <Dino__> ..jer The thing in that expression may be that, in Perl, the + is for numbers, never string concatination. That's the . (dot) operator.
19:35:44 <jer> but even if i did, "8" * 5 <-- just ... icky in my opinion
19:35:48 <Pete_I> + isn't the concatenation operator.
19:36:23 <Pete_I> it's usually bad to put numbers in quotes....
19:36:37 <Pete_I> but yeah
19:36:38 <Dino__> Exactly. So totally ignoring the * 5, it's already numberifying the first two.
19:37:08 <jer> Dino__, i know, but for example: perl -e 'printf(("3" + "5") * 5);' <-- returns "40" to my screen... i'm talking about mathematical operations, not concatenation
19:37:44 <jer> using a string and adding it to an integer (in my opinion, please keep that in mind) just seems icky
19:37:45 <Pete_I> that makes sense though.
19:38:02 <jer> Pete_I, i'm not a perl guy so it doesn't make any sense to me =]
19:38:11 <Pete_I> ok
19:38:25 <Pete_I> how would you add "5" + 3 in haskell then?
19:38:29 <jer> i would not, fire up in smalltalk: Transcript show: (('3' + '5') * 5)  <-- and expect it to print "40" to the screen
19:38:32 <Dino__> Sure, I understand. And it can be icky if you're not expecting it. But such is the landscape of many scripting langs, I suppose.
19:38:35 <Pete_I> there must be some bit of wizardry to do it.
19:38:35 <mathewm> is there a "zipWith" that works with lists of different lenths, just rotating back to the start of the shorter list when neeeded?
19:39:13 <woggle> jer: The conceptual thing in perl is that there is no 'string' and 'integer' type, only a 'scalar' type.
19:39:15 <Dino__> (read "5") + 3 ?
19:39:31 <jer> Pete_I, one would convert "5" to an integer ...
19:39:39 <jer> woggle, right
19:39:46 <Pete_I> cool.
19:39:50 <woggle> jer: There are different operators for doing integer-like things and string-like things. Except where there were design mistakes.
19:39:52 <jer> woggle, i'm not saying i don't know why it works, i was saying it just looks icky
19:40:33 <Dino__> I've read tht P6 will have optional strong typing if you want to use it.
19:40:34 <Pete_I> it is a bit odd. but once you get used to it it's pretty cool
19:40:49 <woggle> jer: Good perl programmers get very angry at people who write code like ("3" + "5"). Unfortunately, good perl programmers are also relatively rare.
19:41:19 <Dino__> wog: You said it, you just don't write stuff like that to begin with.
19:41:27 * SamB wonders if he qualifies as a good perl programmer? he gets angry at people who write code like that, anyway!
19:41:31 <SamB> or would, given the chance!
19:41:39 <Pete_I> ("3" + 4) is bad, but $x=<STDIN>; print $x*5; isn't that uncommon.
19:42:21 <Dino__> Pete_I: Good point, and the same conversion is going on there, it seems like.
19:42:43 <Pete_I> Dino__, yes.
19:43:54 <Dino__> Can I ask the bot to evaluate something here?
19:43:59 <Korollary> It is similar to python's combining integers and floats, but nobody really whines when your variable, which held an integer up to that point, now holds a float. Mixing numbers and strings into the same type is similar, but it's a bit over the top imho.
19:44:58 <Cale> Dino__: yep,
19:45:04 <Cale> > map (+1) [1,2,3,4,5]
19:45:05 <lambdabot> [2,3,4,5,6]
19:45:39 <Dino__> > (read "5") + 3
19:45:40 <lambdabot> 8
19:45:51 <Dino__> > "5" ++ (show 3)
19:45:52 <lambdabot> "53"
19:45:52 <Cale> > read "5" + 3
19:45:53 <lambdabot> 8
19:46:04 <Dino__> Thanks.
19:46:09 <mathewm> ?pl zw f xs ys | (length xs) <= (length ys) = zipWith f (cycle xs) ys | otherwise = zipWith f xs (cycle ys)
19:46:09 <lambdabot> (line 1, column 41):
19:46:10 <lambdabot> unexpected "="
19:46:10 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
19:46:46 <Cale> > read "5" + 3.0
19:46:47 <lambdabot> 8.0
19:47:03 <Dino__> > 5 + 3.0
19:47:04 <lambdabot> 8.0
19:47:23 <Cale> > (5 :: Int) + (3.0 :: Double)
19:47:23 <lambdabot> Couldn't match `Int' against `Double'
19:47:42 <Pete_I> 3.0 is a float, not a double :/
19:47:51 <Cale> @type 3.0
19:47:53 <lambdabot> forall t. (Fractional t) => t
19:48:01 <Cale> It's anything Fractional
19:48:09 <Pete_I> oh, ok
19:48:22 <Dino__> @type 5
19:48:23 <lambdabot> forall t. (Num t) => t
19:48:35 <Cale> > 5 :: Double
19:48:36 <lambdabot> 5.0
19:48:42 <Cale> > 5 :: Float
19:48:43 <lambdabot> 5.0
19:48:47 <Cale> > 5 :: Integer
19:48:48 <lambdabot> 5
19:48:52 <Cale> > 5 :: Rational
19:48:53 <lambdabot> 5%1
19:49:33 <joe_k> % as the ratio operator instead of / ?
19:49:41 <Cale> yeah
19:49:51 <Cale> @type (%)
19:49:52 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
19:49:57 <Cale> @type (/)
19:49:58 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:50:21 <Cale> > 5/3 :: Rational
19:50:22 <lambdabot> 5%3
19:50:22 <joe_k> Fractional contains Ratio ?
19:50:28 <Cale> yeah
19:50:53 <Cale> % is a sort of smart data constructor for ratio values
19:51:03 <Cale> (the real data constructor is hidden)
19:51:12 <Cale> > 20%10
19:51:13 <lambdabot> 2%1
19:51:35 <mathewm> ?pl  zw f xs ys = take (maximum $ map length [xs,ys]) $ zipWith f (cycle xs) (cycle ys)
19:51:36 <lambdabot> zw = ap (ap . ((take . maximum . map length) .) . (. return) . (:)) . flip flip cycle . ((.) .) . (. cycle) . zipWith
19:52:06 <joe_k> that clears that up
19:52:40 * mathewm passes out
19:58:26 <Dino__> I went through pat of YAHT where the author talks about how this: map toLower (filter isUpper "Hello World")
19:58:38 <Dino__> Can also be done like this: [toLower x | x <- "Hello World", isUpper x]
19:58:55 <Dino__> And then goes on to show this: [(x,y) | x <- [1..5], y <- [x..7]]
19:59:23 <Dino__> What is this [ foo | bar, baz ] thing called?
19:59:35 <mathewm> list comprehension?
19:59:48 <Dino__> And these guys are clearly different, as in the last one has two "sections" with <-'s
19:59:58 <sam_> i'm wanting to convert an Int to a Float. Is there anything simpler to do it than "fromInteger $ toInteger n" ?
20:00:38 <kpreid_> sam_: fromIntegral
20:00:44 <mathewm> Dino__: I don't think they are fundamentally different, but the second one has an "inner loop", so to speek
20:01:29 <Dino__> mathewm: Ok. But in the first one, the ", isUpper x" seems more like a conditional.
20:01:56 <mathewm> Dino__: oh yes, they can be interspersed - guards and generators I think they are called
20:02:37 <mathewm> > [ (a,b) | a <- [1,2,3], a > 2, b <- [a..5] ]
20:02:38 <lambdabot> [(3,3),(3,4),(3,5)]
20:03:02 <Dino__> Now, earlier I had read what I thought was telling me that stuff like [1..10] and [1,3..10] are list comprehensions. I think I didn't realize that these other things in [ ] are as well.
20:03:14 * mathewm is quite the newbie himself, so any answers should be taken with a healthy dose of salt!
20:04:34 <mathewm> > [ x <- [1,2,3] ]
20:04:35 <lambdabot> Parse error
20:04:37 <dfeuer> Cale, ping!
20:04:40 <mathewm> > [ x | x <- [1,2,3] ]
20:04:42 <lambdabot> [1,2,3]
20:04:49 <mathewm> > [ 1..3 ]
20:04:50 <lambdabot> [1,2,3]
20:05:07 <mathewm> seems like '|' or '..' in [] makes for a "comprehension"
20:05:21 <Dino__> Ok. That helped. Thank you. It's all the same stuff but in the ones with the | you're writing code in there, say.
20:05:49 <mathewm> Dino__: yeah, in fact, I just learned that you can do the same things with the 'do' syntax
20:06:37 <mathewm> [ x | x <- [1..3], x > 1 ] === do { x <- [1..3]; guard ( x > 1 ); return x }
20:06:45 <mathewm> > do { x <- [1..3]; guard ( x > 1 ); return x }
20:06:46 <lambdabot> [2,3]
20:06:55 <mathewm> > [ x | x <- [1..3], x > 1 ]
20:06:56 <lambdabot> [2,3]
20:07:52 <Dino__> Huh, ok. In the special mini-language of the do block. I had not yet seen that guard function.
20:08:25 <dfeuer> @when was Cale last here?
20:08:26 <lambdabot> Maybe you meant: seen what where wn
20:08:39 <dfeuer> @seen Cale here?
20:08:41 <lambdabot> Cale is in #haskell. I last heard Cale speak 17 minutes and 27 seconds ago.
20:08:52 <dfeuer> @what did Cale last say?
20:08:53 <lambdabot> I know nothing about did.
20:09:45 <mathewm> Dino__: I might have lied to you...
20:10:20 <mathewm> Dino__: It looks like the haskell98 report defines [1..3] as an "arithmatic sequence", not a comprehension
20:10:40 <dons> moin
20:10:40 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:10:48 <dons> thank you mr. bot
20:13:20 <Cale> hello
20:13:24 <Dino__> mathewm: The correct name for those doesn't seem completely clear from the docs I'm reading either. But I mostly wanted to ask about what's going on in those [ ] things.
20:14:10 <Cale> dfeuer: ?
20:14:34 <dfeuer> Ah.
20:14:42 <ptolomy> man, I just typed an unreasonably long question, then realized, "I am pretty sure the GHC user's guide would say something about that..", then got annoyed at myself. I rtfm'd myself.
20:14:57 <mauke> > ['h'|[1,3,2]]
20:14:58 <lambdabot> Couldn't match `Bool' against `[a]'
20:15:03 <dfeuer> I was wondering: once you've defined a nested datatype for 2-3 trees, how the heck do you write insert and delete?
20:15:04 <mauke> ah, right
20:15:49 <mathewm> > ['h'|x<-[1,3,2]]
20:15:51 <lambdabot> "hhh"
20:16:19 <dfeuer> Cale?
20:16:53 <Cale> dfeuer: well, you'd have to come up with something which preserved the invariants -- also, with that type it's a little unwieldy to work with, due to all the extra constructors
20:17:38 <dfeuer> yah.
20:18:08 <dfeuer> I was tryin' to figger out how to define membership testing, and I couldn't even do that.
20:18:25 <dfeuer> Know if anyone's actually written it down somewhere?
20:18:57 <Cale> nope, I'm not sure, but membership testing doesn't sound too bad, I'll try it
20:20:39 <dfeuer> 'kay.
20:20:48 <dfeuer> I just don't know how to work with nested datatypes really.
20:20:56 <dfeuer> They make my brain go funny.
20:21:18 <dfeuer> Oh, and I'm not sure how the type you showed me could be a 2-3 tree...  Doesn't it put all the data in the leaves?
20:22:10 <Cale> yes
20:24:49 <dfeuer> But a 2-3 tree puts data all over the place.
20:24:54 <dfeuer> So how is that a 2-3 tree?
20:25:17 <Cale> It does?
20:25:37 <dfeuer> Each node of a 2-3 tree has either 1 value and two pointers or 2 values and 3 pointers.
20:26:12 <Cale> A 2-3 tree is just any tree whose leaves are all at the same level and where each node has either 2 or 3 children
20:26:39 <dfeuer> oh.  I was looking at what Wikipedia said.  Guess I shouldn't trust it.
20:26:51 <Cale> (each internal node)
20:27:17 <Cale> well, I suppose you could define it that way
20:27:39 <Cale> things would get a little more complicated
20:32:45 <dfeuer> Well....
20:32:58 <audreyt> dons, dcoutts: before the new fps is made into base, I'd like to suggest that the cbits functions get prefixed
20:33:17 <audreyt> e.g. "count" should become "fps_count" or "bytestring_count" or something
20:33:19 <dfeuer> Basically, I'm just trying to see what /any/ good balanced search tree would look like with a fancy datatype that enforced the balance invariants.
20:33:29 <audreyt> lest it duplicates with commonly named symbols in user code (this just happened)
20:37:51 <dons> audreyt: ok, that's a great idea
20:37:56 <dons> fixing now.
20:38:31 <audreyt> darcs patch is http://perlcabal.org/~audreyt/tmp/fps-prefix.patch
20:38:48 <dons> even better :)
20:38:51 <audreyt> :)
20:39:07 <dons> i note in ghc they're often prefixed with 'hs_' or 'ghc_'
20:39:16 <audreyt> hs_fps_ would do
20:39:21 <audreyt> fpstring_ would do too
20:39:27 <audreyt> but fps_ is not likely to clash either
20:39:31 <audreyt> whatever that works for you :)
20:39:42 <dons> right
20:39:58 <Cale> dfeuer: Getting sophisticated invariants into Haskell's type system is generally pretty tricky.
20:40:14 <dons> and runtime stuff has 'stg_'
20:40:31 <Cale> I recall seeing some things where they were using typeclasses to enforce balance constraints at compile time
20:40:34 <dons> oh, and then there's also '__hscore_'
20:41:57 <Cale> but of course, anything which puts even moderately heave compile-time constraints on your code will end up making things a bit hard to work with, as you essentially need to work things so that your code is a proof that the invariant is always maintained.
20:44:19 <dfeuer> But that's kind of cool...
20:45:35 <Cale> Well, since Haskell isn't really *too* geared towards it, it can be frustrating... there are languages which take this route a little further though, like Epigram.
20:46:00 <dfeuer> Izzat one of them langwiches with an undecidable type system?
20:46:24 <dons> undecidability isn't so scary
20:46:40 <dons> its got a dependent type system
20:46:46 <audreyt> with not "undefined"
20:46:48 <audreyt> iirc
20:46:51 <audreyt> s/not/no/
20:47:29 <dfeuer> I don't know what a dependent type system is, and I think undecidability in a compiler-checked type system is kind of yucky.
20:47:53 <audreyt> template haskell makes the compiler possibly  nonterminate
20:47:59 <audreyt> does that stop anyone? no ;)
20:48:27 <dfeuer> Template Haskell?
20:48:37 <dons> yeah, so do rewrite rules
20:48:39 <audreyt> macro thing. http://haskell.org/th/
20:49:01 <dfeuer> Macros and type systems to me seem very different.
20:49:06 <dons> mostly, we're happy if things work after adding a couple of type annotations
20:49:09 <dfeuer> But I guess not to you folks.
20:49:29 <Cale> http://www.e-pig.org/downloads/epigram-notes.pdf
20:49:36 <audreyt> dfeuer: with logic programming expressed in typeclasses... they are kind of blurry
20:49:54 <dfeuer> Sorry.  You're all zinging things over the top of my head.
20:50:34 <SamB> dfeuer: we use type systems to keep our macro names short ;-)
20:50:52 <dfeuer> whaaa?
20:51:06 <dons> audreyt: i'm preparing the base/ patch today. any other fps points you've noticed need tweaking? all the the right symbols exported?
20:51:12 <dons> anything missing that you like?
20:51:40 <audreyt> dons: I just merged trunk to pugs. bench is largely the same
20:51:52 <audreyt> though I didn't try the new GHC macros
20:51:56 <audreyt> like loopu rewrite
20:52:05 <Cale> heh, I'm finding this a little confusing too... but if you'd like to see an example of swindling the typeclass system into doing almost macro-like things, take a look at HList
20:52:10 <audreyt> (ghc 20060608 here)
20:52:18 <Cale> http://homepages.cwi.nl/~ralf/HList/
20:52:23 <audreyt> should I expect a significant speedup?
20:52:28 <dons> oh, you get the new fusion system by default
20:52:44 <audreyt> oh. then I'm sorry to report that it doesn't affect runtime speed here
20:52:45 <dfeuer> kay
20:52:49 <audreyt> probably my use case
20:52:54 <dons> audreyt: yep.
20:53:02 <audreyt> I havn't switched to .Lazy nor tried it
20:53:03 <dons> it'll matter around 5% for maps and filters
20:53:08 <audreyt> but the API is looking good
20:53:18 <audreyt> ah. then no, probably not much fusion here
20:53:24 <dons> for foldrs and other 'down' loops, you'll see fuseable pipelines
20:53:31 <audreyt> understood
20:54:05 <dons> ok. good.
20:54:17 <audreyt> so, scanning is full in base bytestring
20:54:22 <audreyt> but only scanl for lazy?
20:54:44 <audreyt> what about l1?
20:54:57 <audreyt> I understand the argument for omitting scanr, but l1?
20:55:01 <dons> oh , that's in there, isn't it?
20:55:11 <dons> ah, but not for lazy. hmm
20:55:32 <dons> an omission. thanks for spotting that
20:55:45 <audreyt> np. why is partision omitted?
20:55:59 <dons> yeah, its on the todo list. we should implement that too. 
20:56:02 <audreyt> also, unzip?
20:56:04 * dons adds that to the todo list as well.
20:56:09 <dons> unzip for lazy strings?
20:56:22 <audreyt> hm, prolly doesn't make a lot of sense
20:56:45 <dons> yeah, unzips are in general not to efficient here
20:56:45 <audreyt> but why not just make two nonlazy strings?
20:56:59 <audreyt> I mean, instead of omitting the api, give a version that still works
20:57:07 <dons> yep
20:57:18 <audreyt> at least it'd be workable, unlike scanr
20:57:24 <audreyt> and mapAccumR
20:57:28 <audreyt> but even those can be emulated
20:57:39 <dons> yeah, i've added unzip to the list.
20:57:53 <audreyt> ok. also Lazy.Char8 needs scanl and scal1
20:58:07 <dons> depending on how .Lazy is used, we may want to implement the whole list api
20:58:12 <dons> oh, gwell spotted
20:58:18 <audreyt> and mapAccumL and mapIndexed and inits and tail
20:58:20 <audreyt> tails
20:58:30 <audreyt> basically .LAzy.C8 should match .Lazy
20:58:36 <dons> hmm. looks like we didn't keep Char8 in sync
20:58:37 <audreyt> that's all I can see right now
20:58:46 <dons> yeah, i'll review the export lists there
20:58:52 <audreyt> cool
20:58:56 <audreyt> excellent work :)
20:59:36 <dons> cheers. thanks for the useful comments too.
20:59:57 <audreyt> np. I look forward to switch all Pugs strings to bytestrings, including lazy ones
21:00:07 <audreyt> how's sjanssen's work going, btw?
21:00:19 <dons> cool :)
21:01:15 <dons> i think he's progressing, though i haven't heard from him in a week or so. we keep missing each other in the timezone diff
21:01:31 <dons> ?seen sjanssen
21:01:32 <lambdabot> I saw sjanssen leaving #haskell 58 minutes and 24 seconds ago, and .
21:01:38 <dons> grr
21:02:26 <mauke> ?kale
21:02:27 <lambdabot> i cant think anymore
21:08:14 <audreyt> @pl map ($ y) x
21:08:14 <lambdabot> map ($ y) x
21:08:37 <audreyt> @pl \x -> choice (map ($ x) depPostfix)
21:08:38 <lambdabot> choice . flip map depPostfix . flip id
21:08:43 <audreyt> ow.
21:08:45 * SamB didn't know lambabot used to be able to think!
21:08:56 <mauke> <3 flip id
21:08:56 <dons> ?vixen-on
21:08:57 <lambdabot> What's this channel about?
21:08:59 * audreyt is finding @pl always unhelpful these days
21:08:59 <lambdabot> constantly?
21:09:13 <dons> can you think?
21:09:13 <lambdabot> of course i can
21:09:18 <dfeuer> lambdabot, who's your daddy?
21:09:28 <dfeuer> who's your daddy?
21:09:28 <lambdabot> that's a good question, who?
21:09:31 <audreyt> maybe it means my mind is sufficiently pointless now...
21:09:31 <lambdabot> why, aren't you sure?
21:09:33 <dons> ?vixen-off
21:09:34 <lambdabot> Bye!
21:09:38 <SamB> dons: you cheateth!
21:09:50 <dons> heh
21:10:15 <SamB> or, well, actually you don't
21:10:28 <dons> no, lambdabot can talk on her own now
21:10:49 <dons> so no cheatething required
21:11:09 <SamB> @vixen-on
21:11:09 <SamB> do you like Haskell?
21:11:09 <SamB> @vixen off
21:11:09 <lambdabot> Not enough privileges
21:11:10 <lambdabot> so?
21:11:30 <dons> using the same mechanism as @tell uses
21:11:49 <dons> ?tell SamB vixen-on/-off are a bit spammy, so they're restricted
21:11:49 <lambdabot> Consider it noted.
21:12:20 <SamB> hmm, that seems odd
21:12:21 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
21:12:32 <SamB> oh
21:12:54 <dons> see how lambdabot responded to contextual info?
21:13:01 <dons> not just something with a '@' prefix
21:13:13 <SamB> so, does lambdabot wait til I say something?
21:13:23 <dons> so its possible now to write plugins that do arbitrary transformations on the channel stream
21:13:26 <dons> yep, it waits
21:13:28 <dfeuer> dons, restricted to whom?
21:13:41 <dons> dfeuer: the lambdabot admins
21:13:45 <dons> though i thought SamB was one.
21:13:46 <dons> hmm
21:13:47 <dfeuer> mu
21:13:51 <SamB> so, if I say:
21:14:11 <SamB> dons: um, why would I be?
21:14:22 <dons> you've contributed a fair few patches in your time
21:14:51 <SamB> really?
21:15:01 * SamB doesn't remember contributing a whole lot
21:15:17 <mauke> maybe it was your evil twin
21:15:28 <SamB> not to complain ;-)
21:15:35 <SamB> maybe I just forget
21:15:49 <SamB> anyway, I really need to go to bed ;-)
21:16:19 <dons> oh, i thought you wrote the style guide.
21:16:51 <SamB> dons: I think then that *you* are the one who is forgetting
21:17:08 <dons> oh, yeah, i see it was jlouis
21:17:38 <dons> $ darcs changes | grep Sam  | length
21:17:39 <dons> 14
21:18:01 <dons> between Apr 7 and May 28 2005 :)
21:18:25 <SamB> hehe
21:18:31 <SamB> I am like that ;-)
21:18:41 <dons> oh, you wrote the todo plugin.
21:18:45 <SamB> I get into one thing for a while, and then I go on to something else
21:18:47 <dons> Sat Apr 23 14:41:01 EST 2005  Samuel Bronson <naesten@gmail.com>
21:18:49 <dons>   * Todo plugin
21:18:57 <SamB> I wish I would go back to the other things more, though
21:19:08 <dons> oh, and all the search stuff
21:19:13 <SamB> I did????
21:19:13 <dons> Tue Apr 12 13:40:54 EST 2005  Samuel Bronson <naesten@gmail.com>
21:19:14 <dons>   * Merge GoogleModule and WikipediaModule into SearchModule
21:19:24 <dons> Thu Apr  7 13:36:26 EST 2005  Samuel Bronson <naesten@gmail.com>
21:19:25 <dons>   * Google Plugin
21:19:28 * SamB REEALLLY does not remember the todo plugin
21:19:36 <dons> that's one of the most popular plugins, the google plugin
21:19:54 <dons> remember, we discussed it, and i encouraged you to write it.
21:20:11 <dons> -- (c) 2005 Samuel Bronson
21:20:11 <dons> --
21:20:11 <dons> module Plugin.Todo (theModule) where
21:20:13 <SamB> yeah, I remember I did the search stuff, except I think blackdog actually put the WikipediaModule there, but it was mostly copy/pasted from my GoogleModule
21:20:42 <SamB> okay, so, I totally did not remember that I had done that
21:21:07 <dons> yeah, if you stick with one thing for longer, you get more stuff done on that one thing :)
21:21:21 <SamB> yes!
21:21:30 <dons> just imagine where lambdabot'd be now if you'd been hacking the odd plugin each weekend for the last year
21:21:52 <dons> i should graph lambdabot contributions
21:21:59 <dons> its an interesting development model.
21:22:10 <SamB> at least I got those things working and out the door ;-)
21:22:20 <SamB> a lot of things just sit around half finished in repositories
21:22:34 <SamB> (or older things, not in repositories)
21:22:43 <dons> basically, i work on it once or twice a week, and i get 3 or 4 patches a week from random people, who write maybe 10 patches, then drop it.
21:22:46 <vincenz> moin
21:23:05 <dons> somehow the whole thing keeps chugging along. mostly due to the lack of dependencies between plugins
21:23:05 <mauke> btw, there's a bug in lambdabot
21:23:12 <dons> mauke: yes plaease?
21:23:17 * SamB actually goes to bed now ;-)
21:23:20 <vincenz> moin?
21:23:31 <SamB> vincenz: see you around!
21:23:32 <vincenz> @localtime SamB 
21:23:39 <vincenz> SamB: hasta luego
21:23:41 <mauke> to reproduce: run ./lambdabot, press ^D, run cat, press ^D, be annoyed because cat doesn't exit
21:24:01 <lambdabot> Local time for SamB is Sun Jun 11 00:23:40
21:24:12 <mauke> something seems to switch the terminal in raw mode without resetting it on exit
21:24:35 <mauke> yep, line buffering is disabled
21:25:02 <dons> ah yes. that's it. thanks.
21:26:36 <dons> i can fix that easily enough
21:26:59 <dons> i've noticed this too (all you need to do is quit and then try to hit return, instead getting a ^M)
21:33:04 <vincenz> hmm
21:33:05 <vincenz> I'm moving soon
21:33:20 <vincenz> and have like 5 spare mice (one COM, and 4 ps2)... what do I do with them?
21:33:26 <vincenz> toss em in the bin?
21:33:56 <arctanx> give them to the neighbour's cat
21:34:09 <vincenz> seriously
21:34:23 <vincenz> likewise I got a spare ps2 keyb, and one with the old connector
21:34:38 <vincenz> (not to mention a 486 and a 15" crt)
21:34:53 * vincenz wonders what to do with em
21:45:03 <gregb> vincenz: Ever get your "Type Class Hell" problem figured out?
21:45:24 <vincenz> gregb: nope
21:45:32 <vincenz> gregb: most of the answers circumvented the problem
21:45:40 <vincenz> and mostly reformulated the original problem
21:45:55 <vincenz> I can show you what I currently have
21:46:06 <vincenz> tho it still has not combined the different TC's
21:46:33 <gregb> I guess I never understood what you were looking for.
21:46:49 <vincenz> let me demonstrate
21:47:26 <vincenz> tho
21:47:41 <vincenz> actually I have rethought it over and I now think they can't be combined, even conceptually
21:47:44 <vincenz> http://rafb.net/paste/results/K2DmUU61.html
21:48:16 <vincenz> http://rafb.net/paste/results/NAyAq346.html
21:48:27 <vincenz> first is the core part, second is the recursive us of it
21:48:37 <vincenz> gregb: most answers made it non-infinite as datastructure
21:48:47 <vincenz> HasVars works fine
21:48:53 <vincenz> the problem was in defining Type
21:48:55 <vincenz> for MonoType
21:49:08 <vincenz> erm "HasType"
21:49:35 <vincenz> actually no Type... 
21:49:42 <vincenz> the problem is that
21:49:45 <vincenz> instance Type ... where
21:49:49 <vincenz>   mt -> Monotype mt
21:49:51 <vincenz> it makes no sense
21:49:56 <vincenz> cause for Monotype, it already is a monotype
21:50:03 <vincenz> I tried just making the two methods 'id'
21:50:07 <vincenz> but that's obviously wrong 
21:51:09 <vincenz> gregb: out of curiousity, interested in the ICFPC?
21:52:07 <gregb> ICFPC?  That the functional programming contest?
21:52:09 <vincenz> yep
21:53:06 <vincenz> holy cow my webpage is down
21:53:37 <gregb> hmm.  July 21-24.  I think I'm outta town.
21:53:50 <vincenz> alright
21:54:02 <gregb> You guys having a #haskell team entry?
21:54:16 <vincenz> sorta
21:54:25 <vincenz> I was gonna show you our webpage
21:54:28 <vincenz> but my website is down
21:55:21 <vincenz> crap
21:55:26 <vincenz> can't even ftp for it
21:58:32 <vincenz> grr
21:58:44 * vincenz needs to find better hosting
21:59:40 <gregb> Yeah. Webhosts generally suck.  I'm currently pretty happy with pair.com
21:59:51 <gregb> So far.
22:00:19 <vincenz> I guess that's what you get for something cheap (15euro/year)
22:00:28 <vincenz> gregb: out of curiousity, what do you do
22:01:50 <gregb> I'm currently looking for work.  But I'm an electrical engineer.
22:01:58 <vincenz> ah like me (the second bit)
22:02:06 <vincenz> recent graduate?
22:02:27 <gregb> But I get more interested in Comp Sci as time goes on.
22:02:33 <gregb> '98
22:02:34 <vincenz> likewise :D
22:02:43 <vincenz> (the compsci bit)
22:04:46 <gregb> You still a student?
22:04:49 <vincenz> nope
22:04:55 <gregb> New grad?
22:04:56 <vincenz> graduated in 2003
22:04:57 <vincenz> erm
22:04:58 <vincenz> 2002
22:05:48 <gregb> You an analog or digital guy? 
22:05:52 <vincenz> digital
22:06:18 <gregb> Verilog or VHDL
22:06:26 <vincenz> oh hmm neither
22:06:42 <vincenz> I was more aimed at crypto, filters, multimedia stuff, optimizations
22:07:06 <gregb> DSP type stuff?
22:07:09 <vincenz> yeah
22:07:28 <vincenz> and my last year was a lot of optional courses, so compiler construction and then AI stuff
22:07:46 <vincenz> you reside in europe?
22:07:52 <vincenz> cause if you're looking for a ojb
22:07:54 <gregb> U.S.
22:08:01 * vincenz is at the largest electronic research center in europe
22:08:22 <vincenz> they do all sorts of stuff, from communication, to nano, to chips, to analog, to software optimizations
22:08:59 <gregb> They have a name for it?
22:09:05 <vincenz> www.imec.be
22:09:31 <vincenz> are you an analog or digital guy?
22:09:40 <vincenz> I take it digital, in which case VHDL, verilog or Systemc?
22:10:25 <gregb> Analog bipolar ICs are my specialty.
22:10:35 <vincenz> what are bipolars?
22:11:11 <gregb> http://www.google.com/search?q=bipolar+junction+transistors
22:11:40 <vincenz> yeah the analog world is a small one to work in
22:11:42 <vincenz> afaih
22:12:06 <vincenz> should come take a look at imec, if you're willing to relocate
22:12:41 <gregb> Ah, I think my wife would have a heart attack if we moved any farther away from here family.
22:12:50 <vincenz> here being?
22:12:54 <gregb> *her family*
22:13:04 * vincenz coughs
22:13:14 <vincenz> anyways, doing my phd there, it's grea
22:13:21 <vincenz> great international environment
22:13:31 <gregb> Kennewick, Washington
22:13:34 <gregb> http://maps.google.com/maps?oi=map&q=Kennewick,+WA
22:13:42 <vincenz> above oregon
22:13:46 <gregb> yup.
22:14:23 <vincenz> http://maps.google.com/maps?f=q&hl=en&q=leuven,+BE&om=1
22:14:46 <vincenz> center of DSP valley :)
22:14:56 <vincenz> which is a circle about 200km around leuven
22:15:03 <vincenz> including places like eindhoven and such (in holland)
22:15:29 <vincenz> (eindhoven being mainly philips I'd presume)
22:16:05 <vincenz> so how come you're out of a job?
22:16:12 <vincenz> (well besides the fact that you live in the US)
22:17:30 <gregb> A lot of factors really.  But it boils down to too many hours.
22:17:45 <vincenz> ah you quit?
22:17:58 <vincenz> hmm
22:18:00 <vincenz> yeah
22:18:01 <gregb> yeah.
22:18:06 <vincenz> I wouldn't mind going back to california
22:18:16 <vincenz> but that's one of the things I fear, the work-environment in the US
22:18:19 <wimp> how easy is it to write a haskell interpreter in C?
22:18:32 <gregb> Got your PH.D. thesis topic picked out?
22:18:33 <vincenz> wimp: I would say that all depends on what you use as intermediate language
22:18:42 <vincenz> gregb: pretty much yep, took me two years but :D
22:18:45 <JKnecht> vincenz: there's also the tech univ. there (EIndhoven).
22:18:50 <vincenz> JKnecht: indeed
22:18:53 <wimp> vincenz, what's your topic?
22:19:08 <dons> wimp: hugs is written in C. but compiling down to whatever your interpreter interpets is going to be a pain in C
22:19:18 <vincenz> in general, data optimizations for multimedia applications
22:19:27 <vincenz> in specific, intermediate variable removal for DDTs
22:19:30 <wimp> dons, please explain, I'm confused
22:19:43 <vincenz> wimp: noone interprets haskell as is
22:19:49 <vincenz> wimp: first yo compile to some intermediate language
22:19:54 <gregb> vincenz: DDTs?
22:20:00 <vincenz> once you have the intermediate language it's "easy"
22:20:04 <vincenz> compilation is gonna be your problem
22:20:07 <wimp> what does hugs use for that intermediate lnaguage?
22:20:08 <vincenz> gregb: dynamic data structures
22:20:17 <vincenz> gregb: aka lists/vectors..
22:20:27 <vincenz> (in c++ parlance)
22:20:54 <vincenz> but still working on some transformations, so most things I have published haven't been related to that yet
22:21:10 <dons> wimp, right, and its writing the compilation -- symbolic manipulation -- that's not easy in C (no pattern matching, no algebraic data types)
22:21:18 <vincenz> in fact I'm going to be in your neighbourhood soon :D
22:21:22 <dons> wimp, hugs interprets a form of STG code, I think
22:21:27 * vincenz is going to toronto the second week of july
22:21:35 <dons> a specialised variety of Haskell Core, .
22:22:19 <dons> so,  writing an interpreter (the bit that actualy interrepts) not too hard. writing a Haskell to Core compiler in C. much more work. it would be a bit crazy to attempt it in C, in fact.
22:22:28 <vincenz> I concur
22:23:31 <dons> the lack of pattern matching alone would be enough to make it not worth while.
22:26:37 <vincenz> time to boot up an OLD computer with a floppy to see what's on there
22:27:01 <vincenz> gregb: I'd show you my current publications , but yeah... website is down, seems to be a php problem
22:34:37 * vincenz sighs and switches irc back to laptop, my desktop cpu fan makes way too much noise
22:34:53 <vincenz> gives me a headache
22:35:57 <vincenz> re
22:36:32 <dons> vincenz: you need a fanless box :)
22:36:54 <dons> i.e. http://www.cse.unsw.edu.au/~dons/via_openbsd.html  :)
22:38:47 <vincenz> dons: don't know what to do :(
22:38:58 <vincenz> I've been considering buying a new desktop
22:39:03 <vincenz> but... I almost always use my lappy
22:39:09 <vincenz> so it'd be a big investment for little return
22:39:20 <vincenz> on a sidenote, anyone know how to clear a harddrive (the main one) from inside linux
22:39:30 <vincenz> I want to empty my hd before I toss this old 486 out
22:39:35 <dons> me too. desktops are overrated (so i just have the above as a firewall, gf machine)
22:39:52 <dons> dd if=/dev/null of=/dev/hda1 ?
22:40:10 <dons> ?google wipe harddrive dd linux
22:40:12 <lambdabot> http://www.bsdforums.org/forums/archive/index.php/t-8785.html
22:40:19 <dons> ?google wipe harddrive dd linux howto
22:40:21 <lambdabot> http://www.hermann-uwe.de/blog/howto-disk-encryption-with-dm-crypt-luks-and-debian
22:40:33 <vincenz> dons: that work if the hd you're emptying is the one with dd on it?
22:40:55 <dons> hmm. yes. but you won't be able to do anything after that...
22:40:59 <dons> and things will go screwey
22:41:05 <dons> better to put dd on a boot disk
22:41:13 <vincenz> crap, can't remember the root pw
22:41:15 <dons> and boot up that, then mount the hd, and zap it
22:41:25 <vincenz> I tried a bootdisk, but no really good disks lying around
22:41:50 <dons> or you take a drill, and drill 3 holes into the top of the hd.
22:42:48 <vincenz> don't have a drill
22:43:10 <dons> perhaps stick it in a microwave for 30 seconds on high? :}
22:44:39 * vincenz finds a working bootdisk
22:44:44 <vincenz> dons: sure with all the metal?
22:45:02 <dons> i'm just joking with that one ;)
22:45:07 <dons> maybe it would work. maybe not.
22:45:19 <vincenz> how do I launch sh from lilo?
22:45:23 <vincenz> cause I can't remember boot pw
22:47:18 <mathewm> init=/bin/sh
22:48:11 <vincenz> thx
22:48:28 * vincenz does a dd if=/dev/random of=/dev/hda1
22:48:49 <mathewm> SLOW
22:49:02 <vincenz> oh well
22:49:07 <mathewm>  /dev/urandom may be faster...
22:49:21 <mathewm> or do I have that backwards?
22:49:42 <bsmith__> i think you have it backwards
22:49:46 <vincenz> 8am
22:49:51 <vincenz> time to work on my interpreter
22:50:18 <bsmith__> nevermind, i have it backwards
22:50:33 <bsmith__>  /dev/random blocks to wait for entropy
22:50:38 <vincenz> crud
22:50:41 <mathewm> with clear names like 'random' and 'urandom' how can there be any doubt? :)
22:50:45 <bsmith__> :)
22:52:43 <vincenz> so use urandom?
22:53:01 <mathewm> if it isn't too late
22:53:06 * vincenz uses wero
22:53:12 <vincenz> mathewm: it wasn't, funily enoug
22:53:25 <vincenz> I just used zero
22:55:03 <mathewm> zero should be just fine for all but the most paranoid - supposedly a field of 0's leaves ghosts that are easy to read
22:55:48 <vincenz> there's nothing really important on there
22:55:55 <vincenz> it's an old pc I used to use as router
22:56:25 <mathewm> we should probably mention Monad before people start checking for '#linux' in their title bars ;)
22:57:06 <vincenz> :D
22:57:17 <vincenz> thx for the help
22:57:26 <vincenz> btw I noticed a cool design pattern with monads
22:57:41 <mathewm> oh?
22:57:56 <vincenz> you can have monad-subclasses and then choose whether you want to export the inhereted methods or not
22:58:02 <vincenz> inherited
22:58:14 * vincenz does this for his compiling stages
22:58:52 <mathewm> have a pointer to an example?  I am too new to this to make much sense of the description
22:59:17 <vincenz> basically I have a bunch of standard monad transformers I reuse
22:59:27 <vincenz> customized statet's and readert's
22:59:51 <vincenz> then for instance I defined a typechecking monad
22:59:53 <vincenz> class (Monad m, MonadScope BoundIdent (PolyType mt) m, MonadSupply Var m) => TyperMonad m mt | m -> mt where
22:59:58 <vincenz> notice hwo I have requirements
23:00:08 <vincenz> this means I export those methods
23:00:17 <vincenz> and people who use TyperMonad can access stuff defined by MonadScope and MonadSupply
23:00:28 <vincenz> however my actual immplementation also uses other transformers, which I have not exported thusly
23:00:32 * mathewm copy&paste's for more detailed examinations
23:03:27 <mathewm> I get the constraints, but I don't quite have the structure of Monad's down yet
23:03:51 <vincenz> newtype (Type mt) => TyperT mt m a = TyperT { runTyperT :: ScopeT BoundIdent (PolyType mt) (EnvT Var mt (SupplyT Var m)) a
23:03:54 <vincenz> } deriving (Functor, Monad, MonadIO)
23:03:59 <vincenz> notice how I don't have EnvT as constraint
23:04:02 <vincenz> so whomever uses my monad
23:04:05 <vincenz> does not have access to this
23:04:21 <vincenz> (which is basically my type substitution environment, which of course should be inaccessible)
23:05:32 <vincenz> @hoogle first
23:05:33 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
23:05:33 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
23:05:33 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
23:11:20 <mathewm>   vincenz: newtype (Type mt) => TyperT mt m a = TyperT { runTyperT :: ScopeT BoundIdent (PolyType mt) (EnvT Var mt (SupplyT Var m)) a
23:11:20 <mathewm>    vincenz: } deriving (Functor, Monad, MonadIO)
23:11:20 <mathewm>    vincenz: notice how I don't have EnvT as constraint
23:11:20 <mathewm>    vincenz: so whomever uses my monad
23:11:45 <vincenz> yes EnvT is an instance of MonadEnv
23:11:49 <vincenz> which is not a constraint for my TyperMonad
23:12:03 <vincenz> and I don't instantiate TyperT as an instance of MonadEnv
23:12:24 <vincenz> (while I do so for MonadSupply and MonadScope, by just lifting the operations properly)
23:12:26 <mathewm> now how the heck did my clipboard get into the IRC channel :(
23:12:38 * mathewm thinks this is dangerous...
23:15:21 <vincenz> what iS?
23:15:48 <mathewm> my clipboard randomly emptying into the IRC channel...
23:16:43 <vincenz> oh
23:17:22 <mathewm> Your pattern is beyond my comprehension right now - it might be dangerous too, but I wouldn't know it ;)
23:18:08 <mathewm> Me, I am just noticing that IO is an instance of Functor and wondering if you can do anything interesting by fmap'ing over an IO...
23:23:18 <vincenz> damn
23:23:34 <mathewm> ?
23:23:35 <Philippa> mathewm: yes, you can. You can apply a pure function to the result of an action!
23:23:51 * vincenz made a monad that is self-referring
23:23:58 <vincenz> and now I can't auto-derive it
23:24:57 <vincenz> :(
23:25:18 <vincenz> http://rafb.net/paste/results/Pb5g0i97.html
23:25:37 <vincenz> the problem is that Value can contain actions
23:25:41 <vincenz> so it must refer to the monad itself
23:28:25 <vincenz> suggestions are welcome
23:29:15 <vincenz> Currently I have this (which leads to those monad requirements)
23:29:16 <vincenz> http://rafb.net/paste/results/9xVrOu10.html
