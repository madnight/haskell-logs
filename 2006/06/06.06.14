00:00:09 <shapr> good_boy: It means that one of the operators you're using wants a floating point input somewhere.
00:00:15 <shapr> @type div
00:00:17 <lambdabot> forall a. (Integral a) => a -> a -> a
00:00:22 <shapr> @type mod
00:00:24 <lambdabot> forall a. (Integral a) => a -> a -> a
00:00:31 <shapr> @type **
00:00:32 <lambdabot> parse error on input `**'
00:00:36 <shapr> @type (**)
00:00:37 <lambdabot> forall a. (Floating a) => a -> a -> a
00:00:40 <shapr> @type (^)
00:00:41 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
00:01:07 <shapr> > [2 ** 7,2 ^ 7]
00:01:08 <lambdabot>  [128.0,128.0]
00:01:26 <shapr> good_boy: That illustrative code sample meant, why not try switching your use of ** to ^ ?
00:01:56 <good_boy> what about mod and div?
00:02:09 <shapr> Did you see the resut of @type mod and @type div ?
00:02:22 <shapr> result*
00:02:29 <good_boy> Num
00:02:34 <good_boy> sorry
00:02:36 <good_boy> integral
00:05:13 <shapr> good_boy: How do you like Haskell so far?
00:05:43 <good_boy> i think its cool
00:05:48 <good_boy> better than imperative languages
00:05:57 <shapr> I share that feeling :-)
00:06:09 <good_boy> esp. that u have to solve everything recursively
00:06:24 <shapr> Even though I get paid to write imperative languages, I do most of my prototyping in Haskell and then rewrite in the target language.
00:06:26 <good_boy> and that with few code u do a lot
00:06:33 <shapr> Yeah, that's my favorite part.
00:06:57 * jer does most of my prototying in an object-oriented language named io.. it handles recursion very nicely too (though not iwth tailcalls like most functional languages)
00:07:14 <shapr> I've heard of Io, though I haven't tried it.
00:07:18 <Cale> What's often better than using recursion directly is to use higher-order functions
00:08:09 <shapr> Cale: Any progress on laziness as modularity?
00:08:51 <jer> shapr, it's a really nice language; been using it for the last 2 years, actively developing it with two other core members for the last year and a half and i have to say, it's the nicest language i've used to any degree (still using haskell, perhaps my mind will change)
00:08:57 <jer> err still learning haskell
00:10:03 <shapr> Hey, use what fits your head, whatever that may be.
00:10:08 <jer> nod
00:10:38 <good_boy> Prolog and Haskell share many similiarties... Prolog is cool too
00:10:46 <good_boy> similiarities*
00:10:48 <shapr> Python used to be the best language for me, but I started using recursion and trying to have the result of a block of code be the evaluation of the entire chunk, not the return value. Then someone mentioned Haskell to me, and tada!
00:11:03 <Cale> shapr: I found that much of what I wanted to say was already said in "Why Functional Programming Matters" -- though perhaps it could use more emphasis in that paper. It's not just FP that makes the programs there nice, but laziness.
00:11:32 <shapr> It could use more emphasis, definitely.
00:11:38 * JKnecht after 30+ years has shifty eyes for any Final Programming Language.
00:12:04 <shapr> JKnecht: I didn't say final, and I know that Haskell won't be my favorite language forever.
00:12:09 <Cale> I'm not after a final programming language, but a current one :)
00:12:27 <shapr> Something like Epigram will likely be my next favorite language.
00:12:33 <jer> i've only decided to pick up haskell to add another language to my "toolbelt" if you will
00:12:42 <shapr> I think that's a good approach.
00:12:48 <jer> if it goes beyond that, it will =]
00:12:55 <Pete_I> me too.
00:12:58 <shapr> Yeah, I agree.
00:13:01 <Pete_I> i'm learning it to learn it.
00:13:20 <shapr> I learned Joy for the same reason and still have lots of fun with concatenative stack based pure fp languages.
00:13:28 <Pete_I> it seems more mathematical than perl does.
00:13:47 <jer> that said, i do hope to use it for a few non-trivial, long term projects if i think its the right fit heh
00:14:08 <shapr> I think it's hard to really learn a language without using it for something non-trivial.
00:14:20 <Pete_I> it is.
00:14:24 <Pete_I> atleast for me.
00:14:27 <shapr> Me too
00:14:47 <Pete_I> have to make some complicated stuffs with it atleast.
00:14:49 <shapr> In postgresql, anyone know how to dump a table to disk such that I can easily reload it?
00:15:08 <jer> well its hard to show on irc, but i was putting the emphasis on "long term" =]
00:15:36 <Pete_I> i'm thinking maybe a nice calculator...
00:15:42 <Pete_I> not that long term :)
00:15:47 <shapr> heh
00:16:04 <shapr> I've written a few things, most of which have disappeared.
00:16:35 <Pete_I> i've not found any large projects that interest me.
00:16:52 <jer> well i'm going to hold off until i think i "get it" enough to start work on; but i've decided if not haskell, then ocaml to use as the host language for a language interpreter i'll be starting work on in a few months
00:17:17 <shapr> Have you seen the modular monadic interpreters paper(s)?
00:17:25 <jer> shapr, nope
00:18:59 <shapr> There are many papers along those lines, here's one http://citeseer.ist.psu.edu/liang95monad.html
00:19:01 <lambdabot> The title of that page is "Monad Transformers and Modular Interpreters - Liang, Hudak, Jones (ResearchIndex ..."
00:19:34 <jer> shapr, ah; i'll have a read thanks
00:20:35 <good_boy> why for decToBin -127 []
00:20:43 <good_boy> i get ERROR - Cannot infer instance?
00:20:46 <daugherty> sorry failure of one of my ISPs. JKnecht will be frozen until restored.
00:20:51 <good_boy> only for negative numbers...
00:21:32 <JKnecht> though haskell is a credible contender, especially as the pretender to throne of The FP Language.
00:22:15 <Lemmih> good_boy: decToBin (-127) []?
00:22:33 <good_boy> oh yes 
00:30:04 <xerox> @arrrr
00:30:05 <lambdabot> Arrr!
00:36:24 <skew> Does anyone here know how to tranform cyclic structures without losing sharing?
00:37:09 <skew> Aside from the ugly solution using StableNames and a map
00:41:05 <JKnecht> is an elegant solution with those inconceivable?
00:43:24 <bringert> shapr: createdb -sql will give you the create table statements
00:43:54 <bringert> good night
00:48:38 * ProfTeggy got FIFA world cup tickets!
00:48:56 <ProfTeggy> Tunisia vs. Saudi Arabia... woah!
00:52:11 <ulfdoz> Congrats, you're now an official participant of a minority. :)
00:52:14 <Dreadshoot> http://blog.moertel.com/articles/2004/03/13/concurrent-port-scanner-in-haskell
00:52:16 <lambdabot> The title of that page is "Concurrent port scanner in Haskell"
00:54:01 <Pete_I> is there a haskell version of the split function?
00:54:17 <int-e> @type splitAt
00:54:18 <Pete_I> i can't seem to find it.
00:54:18 <lambdabot> forall a. Int -> [a] -> ([a], [a])
00:54:29 <dons> ?type Data.ByteString.split
00:54:31 <lambdabot> Word8 -> Data.ByteString.Base.ByteString -> [Data.ByteString.Base.ByteString]
00:54:38 <dons> the String version is in MissingH
00:54:49 <Pete_I> > splitAt 1 "string"
00:54:50 <lambdabot>  ("s","tring")
00:55:10 <Pete_I> hmm...
00:56:03 <int-e> oh. the missing gap between span and words + lines.
00:56:52 <Pete_I> i was looking for ("s","t","r","i","n","g")
00:56:56 <skew> One thing you can do is add an extra field to your constructors, and make smart constructors parameterized over the algebra of your fold , which fill that extra field with the fold
00:56:59 <int-e> missing gap ... hmm. my wording got awry.
00:57:03 <int-e> oh, that's easy
00:57:11 <skew> Pete_I: map (:[]) does that, if it's really necessary
00:57:11 <int-e> > map (:[]) "abcdef"
00:57:12 <lambdabot>  ["a","b","c","d","e","f"]
00:57:27 <Pete_I> hmm
00:57:34 <skew> although, String = [Char] already, so you don't really need that if you are just trying to get at characters
00:57:38 <Pete_I> that's odd.
00:58:03 <Pete_I> ok
00:58:09 <int-e> > map return "abcdef" :: [String]
00:58:10 <lambdabot>  ["a","b","c","d","e","f"]
00:58:18 <skew> oh, and building variable-size tuples at runtime doesn't really work so well
00:58:20 <int-e> that's odd.
00:58:41 <skew> how so? return for [] is (:[])
00:58:45 <int-e> (not really, it's abusing the list monad though)
00:59:28 <skew> anyway, using extra references on the type I can build one fixed tranformation in parallel with the structure, preserving sharing
00:59:34 <int-e> > map (:"") "abc" -- you might prefer that?
00:59:35 <lambdabot>  ["a","b","c"]
00:59:50 <int-e> > "" == []
00:59:51 <lambdabot>  True
01:00:17 <skew> I guress I could abuse unsafePerformIO and some MVars to decide on the fold after the structure is built
01:00:20 <shapr> skew: Can you use the Data.Graph.Inductive trick?
01:00:39 <skew> oh, which is that?
01:01:08 <shapr> Er, for the cyclic structures without losing sharing.
01:01:12 <skew> that's built on maps and stuff, isn't it?
01:02:05 <shapr> I'm not sure what it's built on, but I do know that it lends itself to incremental work because each node holds values that point to the other nodes.
01:03:01 <skew> it's got labels, I don't think nodes can directly refer to each other, though
01:04:09 <skew> I'd like to be able to just work in terms of constructor fields, but not lose sharing
01:04:28 <shapr> oh
01:04:43 <xerox> http://www.zug.com/gab/index.cgi?func=view_thread&head=1&thread_id=44344
01:04:43 <lambdabot> xerox: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:04:45 <lambdabot> The title of that page is "ZUG: Comedy Articles: Prank Phone Call To AT&T"
01:05:11 <skew> like, take (cycle [1,2,3]), map (+1) down it, and not lose the laziness as it unfolds
01:05:20 <skew> not lose the cycle any more, rather
01:05:54 <shapr> I see what you mean.
01:06:10 <shapr> Hudak had a trick for that on the mailing lists recently.
01:06:26 <skew> I've got some code built with base functors and explicit recursion
01:06:53 <shapr> I think Hudak built an ADT and transformed that.
01:07:35 <skew> data Rec f = In (f (Rec f)), but then you can hang on an extra value like data RecFold a f = RecFold a (f (RecFold a f))
01:07:41 <dcoutts> @yarr!
01:07:41 <lambdabot> Har de har har!
01:07:43 <dcoutts> g'morning
01:07:51 <shapr> g'morning dcoutts
01:08:09 <skew> and then when you make your constructor functions, you can use the extra cells to memoize the fold
01:08:16 <dcoutts> shapr, did you apply for the ghc consulting job?
01:08:17 <skew> but it only does that one fixed fold
01:08:28 <shapr> dcoutts: Half an hour after it was mentioned to me, yes.
01:08:37 <dcoutts> shapr, hah, good.
01:09:02 <dcoutts> JaffaCake, if you offer it again in two years I'd definately apply.
01:09:08 <dons> sliding averages on darcs repos: http://www.cse.unsw.edu.au/~dons/images/commits/fps-commits.png :)
01:09:21 <JaffaCake> dcoutts: I'll keep that in mind :)
01:09:43 <JaffaCake> shapr: thanks for the application
01:10:20 <shapr> JaffaCake: I'd love to get that contracting work, if there's anything I can do to improve my chances, I want to know :-)
01:10:20 <good_boy> what is wrong here? head a * (2 ^ (length a - 1))
01:10:48 <dcoutts> @type \a -> head a * (2 ^ (length a - 1))
01:10:50 <lambdabot> forall a. (Num a) => [a] -> a
01:10:50 <skew> is a :: [Int]?
01:10:57 <good_boy> no
01:10:59 <good_boy> yes
01:11:01 <good_boy> yes
01:11:02 <shapr> dons: That's cool, does your darcs plotting code work for any repo?
01:11:12 <skew> oh, right ^ is like Num a => a -> Int -> a
01:11:53 <dons> shapr, yep.
01:11:56 <JaffaCake> shapr: the fact that we know you is definitely a good start... we'll be taking a look through the applications in a week or so I think
01:12:05 <shapr> Spiffy
01:12:10 <dons> ?where darcs-graph
01:12:11 <lambdabot> I know nothing about darcs-graph.
01:12:20 <dons> ?here+ darcs-graph http://www.cse.unsw.edu.au/~dons/code/darcs-graph/
01:12:21 <lambdabot> Done.
01:13:07 <skew> I don't know any good way to pick the funciton after the object is originally built, except ugly stuff with unsafePerformIO and MVars
01:13:29 <shapr> skew: Partial application?
01:13:51 <skew> well, you'd have to lift the parameter pretty far
01:14:23 <skew> if the structure is originally constructed with something like build, I suppose you could compose functions parameterized on the fold
01:14:35 <skew> but it seems like you'd rebuild the object each time the fold is applied
01:14:37 <shapr> build?
01:14:43 <skew> like foldr/build
01:14:47 <shapr> oh
01:15:50 <shapr> What was the recent sequel to foldr/build? unfold/destroy?
01:16:10 <skew> yeah
01:16:49 <dcoutts> JaffaCake, btw, you saw that building with gcc-4.1.x causes borkage
01:17:01 <dcoutts> JaffaCake, and I though it was just some gentoo ricer using silly CFLAGS 
01:17:16 <JaffaCake> dcoutts: right, I tried to talk to you yesterday but guess you weren't around
01:17:31 <JaffaCake> do you want to have a go at debugging it?
01:17:56 <dcoutts> could do, or I might be able to get a minion to try
01:18:01 <alar> @hoogle build
01:18:01 <lambdabot> GHC.Exts.build :: ((a -> b -> b) -> b -> b) -> [a]
01:18:02 <lambdabot> Distribution.Simple.Build.build :: PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()
01:18:02 <lambdabot> Data.Graph.Inductive.Internal.Heap.build :: Ord a => [(a, b)] -> Heap a b
01:18:15 <shapr> dcoutts: How many minions do you have?
01:18:21 <dcoutts> shapr, 4 now :-)
01:18:28 <dcoutts> as of yesterday anyway
01:18:30 <JaffaCake> nice
01:18:38 <shapr> Wow
01:18:52 <skew> how did you get minions?
01:19:13 <dcoutts> they got involved informally, and then we persuaded them to apply
01:19:14 <int-e> gcc 4.1 is nasty, it exploits certain undefined behaviour in its optimizer. at the very least, it exploits that the behaviour on signed integer overflows is undefined.
01:19:54 <skew> good for them
01:20:04 <skew> does it format your disks?
01:20:18 <int-e> no, but it compiles formerly finite loops to infinite ones.
01:20:27 <dcoutts> skew, on signed integer overflow you mean?
01:20:39 <skew> sure
01:20:40 <int-e> it has managed to let printf("%d", c); 256, where c is a char variable.
01:20:40 <dcoutts> int-e, that might be the problem in the rts
01:21:19 <alar> what's bad with unsigned chars?
01:21:23 <int-e> (of course the 256 was calculated by overflowing a char. it's still quite surprising.)
01:21:28 <alar> ah
01:21:30 <alar> 256
01:21:41 <dcoutts> JaffaCake, where would you start looking? is there a test which if it came out the wrong way would cause an infinite allocation loop?
01:21:45 <int-e> unsigned chars work; for them, overflow behvaiour is defined in the C standard.
01:22:01 * alar wonders how 256 was produced from char
01:22:07 <good_boy> Type error in guarded expression -> what does this mean?
01:22:08 <xerox> dcoutts: what do the minion apply for exactly? :)
01:22:18 <dcoutts> xerox, gentoo developer status
01:22:20 <JaffaCake> dcoutts: what goes into the infinite loop, is it only GHC itself?
01:22:37 <int-e> alar: just by ignoring the fact that overflow happened; the char ends up in a 32 bit register, which is just incremented.
01:22:42 <dcoutts> JaffaCake, I suspect it is the rts, but it manifests itself first in ghc
01:22:56 <dcoutts> JaffaCake, it's in a loop allocating MBlocks
01:23:11 <JaffaCake> can you try running some small programs from the testsuite?
01:23:16 <dcoutts> JaffaCake, it could quite easily be a signed integer issue or a pointer aliasing thing
01:23:26 <int-e> alar: in absence of overflows it works; if it overflows the behaviour is undefined, so ... nothing wrong with the result, says gcc.
01:23:37 <dcoutts> JaffaCake, compiling them with what? the stage1 compiler?
01:23:38 <JaffaCake> use the stage1 compiler if the stage2 is going into an inf loop
01:23:42 <alar> int-e: 32-bit char is a violation of sanity IMHO
01:23:44 <ski> good_boy : possibly you used an expression that doesn't have type 'Bool' in a guard
01:23:44 <dcoutts> right
01:23:59 <int-e> alar: well, I wouldn't claim the C standard is sane.
01:24:07 <JaffaCake> try testsuite/tests/ghc-regress/codegen first
01:24:14 <alar> tha's why I dislike C
01:24:57 <alar> wish asm was that portable - to eliminate C forever :)
01:24:58 <int-e> alar: virtually every pointer comparison of two pointers is undefined; they have to point to the same chunk of memory for the comparison to be defined.
01:25:10 <good_boy> http://rafb.net/paste/results/fvlrjZ49.html
01:25:51 <good_boy> last line...
01:25:58 <int-e> alar: (oh, and comparison with the null pointer is defined, too)
01:26:36 <int-e> alar: but checking if a pointer points to a certain memory area is impossible.
01:26:58 <Dreadshoot> int-e: why would it be that?
01:27:42 <alar> int-e: that point is good, but unapplicable: implementation would either perform _any_ pointer arithmetic regardless of anything or have unCish restrictions on it, therefore discrediting the idea of pointer arithmetic
01:27:59 <Dreadshoot> are you trying to say that pointer comparision to an adress is undefined?
01:28:12 <int-e> Dreadshoot: how would you do it? f(char *mem, size_t length, char *ptr,) { return ptr >= mem && ptr-mem < lengt; } ? that's undefined if ptr doesn't point to the same memory object as 'mem'.
01:28:24 <alar> yes
01:28:52 <Dreadshoot> huh
01:29:01 <int-e> fun, eh?
01:29:15 <Dreadshoot> mem == ptr wont work?
01:29:15 <alar> lots of
01:29:39 <int-e> only if they point the the same memory object
01:30:03 <Dreadshoot> c++?
01:30:20 <skew> I wonder if anyone has made a C implementation that specifically tries to point out all this stuff
01:30:21 <int-e> (which means, roughly, a malloc'd chunk, or a single statically allocated variable)
01:30:22 <alar> think sometimes pointer arithmetic does even emit int E
01:30:29 <int-e> I've not checked C++.
01:31:11 <alar> skew: I wonder if it is possible to handle this stuff both systematically and efficiently
01:31:18 <int-e> Anyway, exploiting these facts is a bad move by the gcc team, IMHO.
01:31:24 <ski> good_boy : i think you don't want the '\a ->' there
01:31:28 <Dreadshoot> is pointer compare to reference also undefined is they dont point at same address?
01:31:42 <Dreadshoot> or nvm, reference dont even exist in c
01:31:42 <skew> like, if you hit the equality with an unacceptalbe pointer, it draws a sad face and kills the program
01:31:44 <Dreadshoot> :)
01:32:13 <shapr> skew: Is that where the sad mac came from?
01:32:21 <int-e> Dreadshoot: if you have an array, the pointers can point to different elements of that array and the comparison will work
01:32:27 <good_boy> ski : why ?
01:32:44 <int-e> the pointers are also allowed to point to one element after the array. and that's it. all other pointers are undefined.
01:32:50 <skew> I think there's a formal model of a bit of the C spec, if you want a program that does something boring like pointing out code that hits undefined behaviour
01:33:40 <ski> good_boy : since your function takes two arguments, and you've already written 'a b' in the head of the clause, you shouldn't return a function ('\a -> ...') after that .. that would make 'binToDec' take three arguments
01:33:41 <good_boy> here a simpler version of the function and the complete error... http://rafb.net/paste/results/hj4yH330.html
01:34:13 <ski> erm
01:34:28 <ski> how many arguments is 'binToDec' supposed to take ?
01:34:36 <ski> two or one ?
01:34:40 <good_boy> one.
01:34:49 <int-e> @type Data.Char.ord
01:34:50 <lambdabot> Char -> Int
01:35:13 <ski> good_boy : so why do you have 'b' still there in the head of the clause ?
01:35:56 <good_boy> forgotten to remove it...
01:36:11 <int-e> @type Text.Read.Lex.readDecP
01:36:12 <lambdabot> forall a. (Num a) => Text.ParserCombinators.ReadP.ReadP a
01:37:15 <Dreadshoot> int-e: you are wrong, i just tested
01:37:29 <good_boy> I think i fixed it
01:38:00 * ski tries to figure out how to exit text insertion in w3m ..
01:38:02 <int-e> Dreadshoot: hmm, 'undefined' doesn't preclude the implementation from doing something sensible.
01:38:05 <Dreadshoot> int-e: http://cpp.sourceforge.net/?show=16747
01:38:06 <lambdabot> The title of that page is "#C++ Pastebin"
01:38:41 <Dreadshoot> hmm
01:40:45 <Dreadshoot> int-e: i dont see why it would be undefined though
01:41:00 <Igloo> dons?
01:41:17 <Igloo> Oh, just testing?
01:41:28 <dons> oh. yes. sorry
01:41:34 <skew> Dreadshoot: so the compiler can do something strange for performance, of course
01:41:44 * dons uses Igloo as test data too often ;)
01:41:49 * shapr wonders...
01:42:23 <int-e> Dreadshoot: because the C specification says so. A more reasonable reason is that memory may be implemented in several seaparate memory banks and pointers to different banks could compare equal; this allows C to be used on DSPs while making pointer comparisons cheaper.
01:42:43 <Dreadshoot> int-e: yeah C, i wonder if it applies to c++ also
01:42:53 <Dreadshoot> who uses C.. :)
01:42:55 <skew> oh, for the specific case of pointers that's a good story
01:43:20 <Dreadshoot> skew: strange for performance?
01:43:51 <skew> allowing signed chars to go out of range seems like a pretty obvious way to avoid checking if they've gotten too big for the byte and resetting it
01:44:09 <Igloo> dons  :-)  np
01:44:13 <int-e> Dreadshoot: as I said, I've not checked. And there's an awful lot of C code out there, so it does matter.
01:44:57 <Dreadshoot> int-e: well its pretty standard to make them 0/null also
01:46:12 <int-e> Dreadshoot: Hah. The C standard defines that; if 0 is converted to a pointer, it gets converted to the null pointer's representation (which may be different)
01:46:47 <Dreadshoot> huh
01:47:14 <Dreadshoot> 0 converted to a pointer
01:47:16 <Pete_I> can hugs generate a binary, or do i need ghc for that?
01:47:18 <int-e> (different = it may not be represented by a word (or whatever) that has all bits set to 0)
01:47:25 <int-e> Dreadshoot: (void *)0
01:48:17 <skew> Pete_I: you need ghc, or at least not hugs
01:48:25 <skew> depends what you mean by "
01:48:33 <Dreadshoot> int-e: you can still do like if (ptr)
01:48:42 <skew> "generate a binary", I guess. If it's something involving running faster, then you need ghc
01:49:27 <int-e> Dreadshoot: yes, that's treated as if (ptr != 0) and the 0 is implicitely converted to the appropriate pointer type. (I don't know if that's how it's specified, but that's the effect the specification has)
01:55:11 <lisppaste2> skew pasted "broken resettable thunk" at http://paste.lisp.org/display/21251
01:57:49 <skew> that doesn't work at all, does it
01:58:05 <skew> the unsafePerformIO thunk is just going to be overwritten with the root of the giant object
01:58:19 <int-e> Dreadshoot: C++ isn't better either, but at least it specifies that the comparison yields either true or false (but the comparison need not have reproducable results)
01:58:34 <skew> heh
01:58:57 <skew> I hate it when an expression that looks like a == b evaluates to 5
01:58:57 <Dreadshoot> good enough ;)
01:59:47 <skew> although, I guess you could make a case of a "==" with a type like Maybe a -> Maybe a -> Maybe a
02:01:05 <skew> in the same spirit as "or" in scheme returning the first non-false operand (which msum on Maybe does, I suppose)
02:01:30 <int-e> I wish C did that; it would fit into the language, too.
02:01:58 <int-e> (well, except for some typing issues. hmm.)
02:02:43 <skew> typing issues? In C?
02:02:45 <skew> just cram it in
02:03:00 <skew> what's it going to do, spoil the proof of soundness?
02:05:58 <good_boy> i have one string, one function decToBin which converts a number in binary number format and the function Char.ord. how do i combine these in a map function, so that for every letter of the string i get the corresponding binary representation?
02:06:41 <good_boy> map (decToBin . Char.ord ) a where a is a string doesnt work..
02:07:19 <Lemmih> What's the type of decTobin?
02:07:45 <good_boy> decToBin returns [Int]
02:08:15 <Lemmih> good_boy: So: decToBin :: Int -> [Int]?
02:09:03 <good_boy> decToBin -> [Int] -> Int -> [Int]
02:09:09 <good_boy> decToBin :: [Int] -> Int -> [Int]
02:09:25 <Lemmih> 'map (decToBin [] . Char.ord)' perhaps?
02:09:27 <good_boy> where first [Int] is the temporary list of bits
02:09:33 <good_boy> nope
02:09:55 <Lemmih> Why not?
02:10:00 <alar> what would be the best way to emulate Either in SQL?
02:10:04 <good_boy> i get this : Type error in application
02:10:05 <good_boy> *** Expression     : decToBin a [1]
02:10:05 <good_boy> *** Term           : [1]
02:10:05 <good_boy> *** Type           : [a]
02:10:05 <good_boy> *** Does not match : Int
02:10:45 <Lemmih> good_boy: 'decToBin [1] a'?
02:11:06 <good_boy> oops, forgot to switch them 
02:11:30 <alar> 2 sub-tables: one for Lefts, one for Rights?
02:20:11 <Pete_I> good_boy, what module is that in?
02:20:43 <good_boy> Steganographie
02:20:57 <good_boy> but i solved it, i just hadnt switched the arguments
02:28:23 * shapr boings
02:34:30 <araujo> hello
02:35:12 <kosmikus> hi araujo 
02:35:28 <araujo> hello kosmikus :-)
02:40:39 <shapr> psykotic: Did you work on ut2004?
02:41:09 <psykotic> err, yeah. are you google stalking me? :)
02:41:14 <onrue> is unicode enabled in ghci by default? i have LANG=en_GB.UTF-8 but in ghci i get 2 for length "Ð°"
02:41:16 <shapr> Is it obvious? :-)
02:41:46 <shapr> Your name was familiar but I couldn't place it, so I thought I'd look around. I think I've seen your comments on ltu mostly.
02:41:53 <psykotic> probably.
02:42:11 <shapr> Ã„r du svensk?
02:42:17 <psykotic> dansk :)
02:42:20 <shapr> ah, ok
02:42:22 <psykotic> i live in south korea these days though
02:42:25 <shapr> Nifty
02:42:46 <shapr> I'm Alabamsk and I live in Boden for two more weeks.. then Stockholm! w00!
02:43:05 <psykotic> nice, stockholm is great
02:43:13 <psykotic> especially this time of the year
02:43:23 <shapr> I'm looking forward to it, hopefully I can have type theory discussion face to face.
02:43:45 * psykotic rates stockholm higher than seoul in any case :)
02:43:47 <ski> @yay
02:43:47 <lambdabot> Maybe you meant: faq map yow
02:44:01 <shapr> Are you in seoul for life or job purposes?
02:44:10 <psykotic> i guess you could say both
02:44:18 <shapr> My moves to Finland & Sweden were female related, so...
02:44:22 <psykotic> ah, haha
02:44:29 <alar> onrue: you use String.length but there is a module for unicode strings
02:44:52 <psykotic> i didn't move her for a woman but the best thing about seoul so far is definitely the female element, heh
02:44:56 <psykotic> err, move here
02:45:09 <onrue> alar: what's that module name?
02:45:28 <alar> don't know
02:45:36 <good_boy> the nordic beauties are outbeautied by no race on earth ^^
02:45:39 <onrue> i see only ghc.unicode 
02:45:40 <shapr> psykotic: sounds good :-)
02:45:41 <alar> and think it is still under development
02:45:59 <alar> maybe ghc.unicode
02:46:01 <psykotic> good_boy: it's different when you've lived there all your life, trust me :)
02:46:20 <onrue> ghc.unicode has no functions for measuring length
02:46:23 <psykotic> although when i came back to denmark from a two year stint in the states i was somewhat stocked by how good the women looked. much better than i remembered, haha.
02:46:33 <psykotic> shocked, not stocked.
02:47:12 <shapr> In my experience, nordic > usa when it comes to cute females. I think it's the emphasis placed on physical fitness here.
02:47:13 <alar> onrue: does it have functions for transformations byte-char strings <->multibyte-char strings ?
02:47:40 <psykotic> shapr: it's even more pronounced here in korea. it's ridiculous actually.
02:47:56 * alar wonders if he can be considered "nordic"
02:48:05 <K3wq52k3r3kH4rc> hi
02:48:06 <onrue> it only has functions in style isAscii isLower isUpper and so on. and of course, no functions for conversion
02:48:27 <shapr> I think Sweden is already extreme about fitness, to the point that I know too many people with eating or exercise disorders.
02:48:39 <shapr> hiya K3wq52k3r3kH4rc, interesting nickname.
02:49:12 <K3wq52k3r3kH4rc> :))
02:49:29 <shapr> I keep meaning to pick up an eating or exercise disorder so I can fit in, but I'm too lazy. It's just too much work to exercise several hours a day or remember to 'forget' to eat.
02:49:31 <sieni> better than AFDJ=98nckea)¤
02:50:12 <sieni> just ride 30 kilometers per day with your unicycle
02:50:18 <shapr> psykotic: Were you doing gamedev during your stint in the USA?
02:50:34 <psykotic> yup
02:50:37 <psykotic> still doing that
02:51:11 <shapr> sieni: I only unicycle between SÃ¤vast and Boden, that's about 45 mins one way. That's not enough for an exercise disorder.
02:51:40 <shapr> Hm, maybe I could take the mountainous route. That would increase my calorie output...
02:51:51 <alar> onrue: that's sad 
02:52:02 <K3wq52k3r3kH4rc> is data.graph the right choice for having a huge static graph for fast traversal?
02:52:35 <onrue> may be situation with unicode is better in other compilers: nhc, yhc?
02:53:01 <onrue> huh, hugs work in normal way
02:54:32 <shapr> K3wq52k3r3kH4rc: I don't know, but you might like Data.Graph.Inductive for large graphs.
03:03:30 <Cale> Data.Graph is array-based, it should be reasonably good at it, though Data.Graph is so simple that yeah, you might like Data.Graph.Inductive instead
03:06:59 <Pete_I> how can haskell have "incorrect indentation"?
03:07:11 <shapr> You can put in too many or too few spaces.
03:07:37 <Pete_I> ...all my functions are one-liners...
03:08:02 <Pete_I> hmm...
03:09:14 <Pete_I> nogcd (a,b,c) = (gcd a (gcd b c)==1) -- is there something wrong with this?
03:09:44 <Cale> it's uncurried?
03:09:45 <ski> looks ok
03:09:57 <Pete_I> Cale, what does uncurried mean?
03:09:58 <ski> (but the outer parens in the body is not needed)
03:10:15 <Cale> nogcd a b c = gcd a (gcd b c) == 1
03:10:20 <Cale> is the curried form
03:10:27 <Pete_I> it's parsing a triple.
03:10:36 <Cale> you might not need/want that though, right
03:10:42 <ski> s/parsing/taking/
03:10:49 <Pete_I> right
03:11:52 <int-e> > 2 `gcd` 4 `gcd` 6
03:11:53 <lambdabot>  2
03:13:03 <ski> hm .. isn't that usually called "coprime" or something like that ?
03:13:15 <Cale> yeah
03:13:42 <Pete_I> yes it is.
03:18:08 <alar> mutually prime
03:18:18 <alar> at least in russian :)
03:18:20 <Pete_I> alar, that's what coprime means.
03:18:35 <Pete_I> co- means mutually :)
03:19:10 <ski> hm .. brings another aspect to all the 'co-' things in CT, then
03:19:31 <Pete_I> ski, CT?
03:19:37 <ski> Category Theory
03:19:45 <Pete_I> not thinking about it....
03:20:02 <Pete_I> it'd probly just give me a headache.
03:20:08 <ski> like, e.g. coproduct, colimit, comonad, cokleiski category, etc
03:20:12 <dcoutts> JaffaCake, the codeGen tests all seem to be working which is a suprise, so it seems that not all progs built by the stage1 compiler are going into this infinite alloc loop
03:20:23 <ski> s/kleiski/kleisli/
03:20:34 <JaffaCake> even the threaded way?
03:20:50 <int-e> that kl-kley is nasty :)
03:20:56 <dcoutts> JaffaCake, yep there are some threaded tests running
03:21:19 <JaffaCake> ok, could you try the concurrent tests too?  (ghc-regress/concurrent/should_run)
03:21:28 <dcoutts> ok
03:22:17 <dcoutts> JaffaCake, what are the default CFLAGS for the rts if I didn't specify any myself in mk/build.mk ?
03:22:23 <dcoutts> JaffaCake, does it include -O2 ?
03:22:26 <dcoutts> or just -O
03:22:44 <JaffaCake> I think I switched to -O2, I'll just check
03:22:54 <dcoutts> this is 6.4.2 though, not head
03:23:21 <dcoutts> # default C compiler flags
03:23:21 <dcoutts> SRC_CC_OPTS = -O
03:23:29 <dcoutts> in mk/config.mk
03:24:05 <JaffaCake> dcoutts: I think it's still -O in 6.4
03:24:18 <dcoutts> JaffaCake, right, I'll have to rebuild with -O2 i think
03:24:32 <dcoutts> JaffaCake, what target can I use to just rebuild the rts?
03:24:50 <JaffaCake> dcoutts: cd ghc/rts; make clean; make
03:24:55 <dcoutts> ok
03:25:04 <dcoutts> and with mk/build.mk set appropriately
03:25:15 <alar> can someone explain Curry paradox to me?
03:26:32 <dcoutts> JaffaCake, in GCCompact.c loads of warning about "dereferencing type-punned pointer will break strict-aliasing rules"
03:27:04 <dcoutts> and in Schedule.c
03:27:07 <JaffaCake> dcoutts: yes, don't worry about those, I fixed them in HEAD recently, I don't think they indicate real problesm
03:27:14 * psykotic gets hungry. mmm, curry.
03:27:18 <dcoutts> JaffaCake, with gcc-4.1.x they may do
03:27:56 <JaffaCake> well, it's possible I suppose
03:28:18 <int-e> add -fno-strict-aliasing if you suspec that may be the cause.
03:30:00 <dcoutts> JaffaCake, after rebuildign the rts, will running the ghc-inplace build progs with the rebuilt rts, or do I need to do anything else first?
03:30:20 <JaffaCake> yes (to your 1st question)
03:30:32 <dcoutts> ok, well the codeGen tests still pass
03:30:52 <int-e> -ftree-vrp (enabled by -O2) is, as far as I see, the most likely one to cause infinite loops, though. At least that's the one that turns  t = 0; do { t++; } while (t); into an infinite loop if t is signed.
03:32:30 * dcoutts tries to regain control of his machine which has started thrashing
03:32:39 <dcoutts> ok, got the bug :-)
03:32:58 <JaffaCake> aha
03:33:11 <dcoutts> conc006(normal)
03:33:22 * dcoutts tries again to make sure it was that one
03:34:02 <dcoutts> yep
03:34:07 <JaffaCake> right, you could try recompiling the RTS with -optc-fno-strict-aliasing
03:34:28 <dcoutts> ok
03:34:44 <JaffaCake> cd ghc/rts; make clean; make EXTRA_CC_OPTS=-fno-strict-aliasing
03:35:08 * dcoutts does so
03:35:59 <wferi> Hi! I installed HaskellDB and all the necessary stuff (I hope) as local (not system-wide) packages:
03:36:00 <wferi> $ ghc-pkg list
03:36:00 <wferi> /usr/lib/ghc-6.4.1/package.conf:
03:36:00 <wferi>     [elided]
03:36:00 <wferi> /home/wferi/.ghc/i386-linux-6.4.1/package.conf:
03:36:00 <wferi>     NewBinary-0.1, Crypto-3.0.3, (Cabal-1.0), Cabal-1.1.4, hsql-1.7,
03:36:02 <wferi>     hsql-mysql-1.7, haskelldb-0.9, plugins-1.0, haskelldb-dynamic-0.9,
03:36:04 <wferi>     haskelldb-hsql-0.9, haskelldb-hsql-mysql-0.9
03:36:06 <wferi> Still, DBDirect doesn't run:
03:36:08 <wferi> $ ~/haskell/installed/bin/DBDirect Test mysql server=myserver,db=test,uid=wferi,pwd=secret
03:36:10 <wferi> DB/Direct: Daan Leijen (c) 1999, HWT (c) 2003-2004,
03:36:12 <wferi>            Bjorn Bringert (c) 2005
03:36:14 <wferi> Connecting to database...
03:36:16 <wferi> DBDirect: user error (Couldn't load Database.HaskellDB.HSQL.MySQL.driver from package haskelldb-hsql-mysql-0.9)
03:36:19 <wferi> strace -eopen shows it checks /usr/lib/ghc-6.4.1/package.conf only, not the local one...  Any ideas?
03:36:47 <dcoutts> wferi, is it using hs-plugins?
03:37:19 <wferi> dcoutts: how can I find out? It should I guess.
03:37:30 <dcoutts> JaffaCake, hah! that was it
03:37:41 <dcoutts> the test runs fine now
03:37:47 * dcoutts tries the rest of concurrent
03:37:51 <JaffaCake> good, we're getting somewhere
03:38:20 <dcoutts> yes
03:38:36 <JaffaCake> now to narrow it down to a file
03:38:45 <dcoutts> in the rts you mean
03:38:49 <JaffaCake> yes
03:39:04 <dcoutts> it's likely to be one where we got alisaing warnings
03:39:09 <JaffaCake> yup
03:39:20 <dcoutts> and I'd execpt it to be the schedule one rather than the gccompatc
03:39:25 <JaffaCake> since it's a concurrent test that fails, try Schedule.c first
03:39:30 <JaffaCake> yep :)
03:39:34 <dcoutts> since for these tests we're not using that much heap
03:39:54 <dcoutts> so we should compile just schedule.c with -fno-strict-aliasing then?
03:40:01 <dcoutts> and everything else with -O2
03:40:05 <int-e> hmm, delete the .o file, type make?
03:40:30 <int-e> (okay, there are two ends to work from)
03:41:00 <dcoutts> JaffaCake, right, so I should make clean; make; rm Schedule.o; make EXTRA_CC_OPTS=-fno-strict-aliasing
03:41:08 <JaffaCake> yes, just rm Schedule.o; make
03:41:28 <JaffaCake> don't bother cleaning
03:41:52 <dcoutts> oh, I see you want to compile everything with -fno-strict-aliasing and just Schedule.c with it
03:41:59 <JaffaCake> this only started happening with gcc 4.1.1,right?
03:42:00 <dcoutts> I was going to do the opposite
03:42:08 <dcoutts> JaffaCake, with gcc-4.1.0 too
03:42:16 <JaffaCake> oh, I have 4.1.0 here
03:42:18 <dcoutts> which is what I am currently using
03:42:37 <JaffaCake> I just tried to reproduce, I didn't see anything
03:42:40 <JaffaCake> I'll try harder :)
03:43:05 <dcoutts> you might have accidentally fixed it in head
03:43:34 <JaffaCake> trying in 6.4 branch
03:43:50 <JaffaCake> nope, conc006 works fine w/ RTS compiled with -O2
03:44:00 <JaffaCake> and I get all those warnings
03:44:02 <dcoutts> hmm, odd
03:44:11 <dcoutts> gcc (GCC) 4.1.0 (Gentoo 4.1.0-r1)
03:44:52 <JaffaCake> all of concurrent works for me
03:45:46 <JaffaCake> are you on x86 or x86-64
03:45:47 <JaffaCake> ?
03:46:06 <dcoutts> x86 (inside a x86 chroot on an x86-64 box)
03:46:25 <dcoutts> the original reporter was on an x86 laptop
03:46:28 <JaffaCake> ok, I was trying x86-64, maybe that makes a difference
03:46:36 * JaffaCake tries x86
03:47:03 <JaffaCake> darn, don't have gcc-4.1.x installed on x86 here
03:47:17 <dcoutts> JaffaCake, discovered the ease of chroots yet?
03:47:28 <dcoutts> I only discovered it recently
03:47:37 <JaffaCake> no, chroot was hard last I checked :)
03:48:02 <JaffaCake> are there tools to make it easy nowadays?
03:48:11 <dcoutts> linux32 chroot /mnt/gentoo-x86 /bin/bash
03:48:28 <dcoutts> you just untarr a gentoo stage 3 image and chroot into it
03:48:42 <JaffaCake> hmm, sounds almost too easy...
03:48:50 <dcoutts> they can all share a single gentoo portage tree
03:48:54 <dcoutts> using bind mounts
03:49:16 <dcoutts> and you can do x86-64 or x86 ones if you've got an x86-64 box
03:49:30 <JaffaCake> that's handy
03:49:36 <dcoutts> you don't need to be running gentoo as the host to use a gentoo chroot image
03:50:04 <dcoutts> each image is a few hundred mb
03:50:28 <dcoutts> sharing the portage tree helps
03:50:44 <dcoutts> and bind mounting home dirs can be helpful
03:51:46 <JaffaCake> what about passwd files, etc.?
03:52:19 <dcoutts> one can just work as root inside, or copy passwd files in
03:52:34 <JaffaCake> i see
03:52:44 <dcoutts> JaffaCake, ok so building the rts with -O2 -fno-strict-aliasing and then just Schedule.c with -O2 still works ok
03:52:50 <dcoutts> and the converse doesn't
03:52:59 <dcoutts> so it looks like it's not Schedule.c
03:53:07 <JaffaCake> ok
03:53:14 <dcoutts> next?
03:54:21 <int-e> the other one with warnings, gccompatc?
03:54:27 <int-e> compact?
03:54:31 <JaffaCake> there's one warning in Main.c here
03:54:47 <dcoutts> tried that GCCompat.c and MBlock.c
03:54:51 <JaffaCake> compacting collector shouldn't be running, I'd be surprised if that was the problem
03:55:06 <int-e> right
03:55:26 <dcoutts> not Main
03:55:29 <JaffaCake> also Stable.c
03:55:57 <dcoutts> nope
03:56:18 <JaffaCake> strange
03:56:22 * dcoutts is doing this procedure: rm Stable.*o; make; cd -; make TEST=conc006
03:56:24 <JaffaCake> Storage.c?
03:57:05 <JaffaCake> that procedure should be fine
03:57:12 <dcoutts> we're doing the right thing? I built initially with EXTRA_CC_OPTS=-fno-strict-aliasing
03:57:24 <dcoutts> and now one by one rm'in .o files and doing make
03:57:28 <dcoutts> which just used -O2
03:57:31 <JaffaCake> yes
03:57:40 <JaffaCake> at some point we should trigger the bug
03:57:49 <dcoutts> ok
03:58:00 <dcoutts> well not yet, Storage.c is ok
03:58:52 <JaffaCake> ok, try all the .cmm files: for i in *cmm; rm ${i%.cmm}*o; done
03:58:52 <int-e> 42 files to go?
03:59:05 <JaffaCake> oops, missed out a 'do'
03:59:10 <dcoutts> JaffaCake, right, ok
04:01:01 <JaffaCake> for i in *.c; do rm ${i%.c}*o; make; (cd -; make TEST=conc006); done
04:01:55 <dcoutts> still works
04:02:24 <JaffaCake> try the for loop above ^^^
04:03:13 <dcoutts> ah cunning
04:03:31 <JaffaCake> could probably change that make to 'make libHSrts.a' to speed it up a bit
04:03:51 <int-e> no echo $i?
04:03:54 <dcoutts> as opposed to the threaded and debug versions?
04:04:02 <JaffaCake> yes
04:04:06 <int-e> ok, make is verbose enough I guess
04:04:15 <JaffaCake> add an echo if you like
04:04:38 <dcoutts> right
04:06:02 <dcoutts> JaffaCake, would we not want the threaded version of libHSrts.a ?
04:06:19 <JaffaCake> the normal way triggered the bug, didn't it?
04:06:36 <dcoutts> true
04:07:00 <JaffaCake> you could add WAY=normal to run the test just one way
04:07:21 <dcoutts> ok about to run:
04:07:21 <dcoutts> for i in *.c; do echi $i; rm ${i%.c}*o; make libHSrts.a; (cd -; make TEST=conc006 WAY=normal); done
04:07:40 <JaffaCake> s/echi/echo
04:07:57 <dcoutts> yeah :-)
04:07:59 <Pete_I> why is gcd 0 0 undefined?
04:08:16 <dcoutts> Adjustor.c
04:08:29 <ski> Pete_I : since there is no greatest common divisor there
04:08:36 * dcoutts tries again to be sure
04:08:38 <JaffaCake> Adjustor.c is the problem?
04:08:44 <Pete_I> ski, shouldn't it be 0?
04:09:02 <sieni> Pete_I: since every integer divides zero, gcd would be infinity
04:09:04 <Pete_I> ....ah, nevermind. i got it.
04:09:24 <Pete_I> so then, shouldn't it say infinity?
04:09:57 <int-e> infinity isn't a number
04:10:01 <ski> hm
04:10:04 <alar> inf is not member of Integer type
04:10:06 <JaffaCake> Pete_I: there's no representation of infinity in most integral types
04:10:19 <alar> int-e: Inf is not Nan :)
04:10:38 <ski> actually, wouldn't it sometimes be nice to not use the standard ordering, instead use the 'divides' ordering ?
04:11:17 <ValarQ> back in the inf discussions are we? :)
04:11:24 <alar> what is "divides" ordering?
04:11:28 <int-e> > 0/0 == 0/0
04:11:29 <lambdabot>  False
04:11:39 <Pete_I> ...
04:11:40 <alar> 0/0 = Inf
04:11:41 <ski> forall a. a `divides` 0
04:11:47 <alar> sorry
04:11:50 <alar> 0/0 = Nan
04:11:56 <alar> 1/0 = Inf
04:11:59 <ski> so '0' is the greatest element, according to that ordering
04:12:35 <int-e> sure, you can define gcd 0 0 as 0 ...
04:12:57 * ValarQ still got problems with the fact that 1/0 gives a positive number
04:13:11 <int-e> > 1/(-0)
04:13:12 <lambdabot>  -Infinity
04:13:14 <Pete_I> ValarQ, it doesn't give a number.
04:13:27 <int-e> > 0 == -0
04:13:28 <lambdabot>  True
04:13:32 <Pete_I> > 1/0
04:13:33 <lambdabot>  Infinity
04:13:38 <ski> > 1/0 :: Integer
04:13:39 <lambdabot>  add an instance declaration for (Fractional Integer)
04:13:39 <lambdabot>   In the expression: ...
04:13:53 <ValarQ> Pete_I: ok, so why the Infinity then?
04:13:56 <ski> > 1 `div` 0
04:13:57 <lambdabot>  Exception: divide by zero
04:14:15 <Pete_I> hmm...i didn't know it was infinity. i thought it was undef.
04:14:30 <ski> @type div
04:14:32 <lambdabot> forall a. (Integral a) => a -> a -> a
04:14:33 <ski> @type (/)
04:14:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:14:36 <ValarQ> and even if it isn't a number, it's still positive
04:14:49 <int-e> > 1/0 > 0
04:14:50 <lambdabot>  True
04:14:55 <int-e> > 1/(-0) > 0
04:14:56 <lambdabot>  False
04:14:58 <dcoutts> JaffaCake, ok that was wrong, it looks like GC.c
04:15:15 <ValarQ> int-e: yeah, thats the funny part :)
04:15:16 <JaffaCake> that sounds more plausible
04:15:44 <Pete_I>  > -0/-0 == 0/0
04:15:56 <Pete_I> > -0/-0 == 0/0
04:15:56 <lambdabot>  Not in scope: `/-'
04:16:05 <ski> > (-0)/(-0) == 0/0
04:16:06 <lambdabot>  False
04:16:07 <Pete_I> > -0/(-0) == 0/0
04:16:08 <lambdabot>  False
04:16:16 <ski> > let nan = 0/0 in nan == nan
04:16:18 <lambdabot>  False
04:16:19 <Pete_I> that seems...wrong
04:16:23 <dcoutts> JaffaCake, yep, confirmed, with the whole rts built with EXTRA_CC_OPTS=-fno-strict-aliasing it works and then with just GC.c built with the default -O2 strict aliasing it triggers the bug.
04:16:39 <JaffaCake> dcoutts: can you gdb conc006 to find out where the loop is?
04:16:43 <alar> yes, one NaN is not equal to another
04:16:51 <ski> Pete_I : yes, IEEE float NaN is horrible
04:16:52 <dcoutts> JaffaCake, there was no gcc aliasing warning in GC.c
04:17:01 <dcoutts> JaffaCake, I'll give it a go
04:17:04 <JaffaCake> probably want to compile it with -debug
04:17:14 <JaffaCake> so you'll need libHSrts_debug.a
04:17:16 <int-e> well, 0 == -0 together with 1/0 /= 1/(-0) is just plain wrong.
04:17:23 <fluxx> well, should 1/0 == 0/0 then?
04:17:32 <Pete_I> > (1.#INF) * 2
04:17:32 <lambdabot>  Not in scope: data constructor `INF'
04:17:37 <fluxx> if not, what would be a meaningful way to differentiate
04:17:38 <Pete_I> hmm
04:17:40 <ski> iirc they revoked the equality type status of 'real' in SML
04:17:45 <dcoutts> JaffaCake, ok, got that, so then how do I build the test without running it?
04:17:47 <fluxx> short of actually storing the ratios or something
04:17:48 <dcoutts> or just by hand
04:17:49 <JaffaCake> dcoutts: it's probably still an aliasing thing
04:18:06 <dcoutts> JaffaCake, oh, sure, just not an easy one that gcc warns about
04:18:11 <JaffaCake> make TEST=conc006 EXTRA_HC_OPTS=-debug
04:18:20 <JaffaCake> then you'll have to ^C it and run gdb
04:18:46 <dcoutts> ok
04:19:07 * JaffaCake wonders if it is probably best just to compile the whole RTS with -fno-strict-aliasing
04:19:13 <dcoutts> JaffaCake, heh, -debug makes the problem go away :-)
04:19:14 <int-e> ski: hmm. but it is reasonable to campare reals for equality in some cases. (like if you're actually doing integer math, or if the values you're comparing are the same value, propagated through several assignments)
04:19:26 * JaffaCake thumps head against keyboard
04:19:34 <dcoutts> I can gdb it anyway
04:19:35 <Pete_I> did computers exist in 1969?
04:20:30 <integral> Pete_I: of course!  multics was just out of development then iirc
04:20:44 <JKnecht> did they ever. 
04:20:50 <ski> int-e : yes, one can still have such a function, just not calling it an equality function
04:21:03 <JaffaCake> the type structure we use in the RTS doesn't work too well with strict aliasing: we have subtypes, which gcc considers to be distinct types
04:21:07 <Pete_I> I was wondering how they counted the time in seconds from dec 31 1969 without pcs
04:21:21 <int-e> Lisp developemnent started in 1958
04:21:27 <integral> Pete_I: electro mechanical clocks?
04:21:41 <int-e> *development
04:21:43 <Pete_I> int-e, that's really old
04:21:48 <JKnecht> epoch origin is a matter of convention.
04:22:03 <Pete_I> where did the epoch come from?
04:22:08 <int-e> unix
04:22:23 <dcoutts> JaffaCake, the mem use only creaps up gradally
04:22:23 <integral> they picked a notional creation date of UNIX
04:22:24 <JKnecht> needs to be recent if timekeeping precision low, not otherwise.
04:22:28 <Pete_I> ...unix can't be that old
04:22:32 <int-e> sure
04:22:35 <int-e> it can
04:22:36 <integral> Pete_I: it is!
04:22:44 <dcoutts> JaffaCake, I have to skip 100,000's of evacuate calls to see the mem use start to rise
04:22:45 <JKnecht> unix is post 1970
04:22:54 <JaffaCake> D'OH
04:23:04 <JaffaCake> from rts/Makefile in HEAD:
04:23:04 <JaffaCake> GC_HC_OPTS += -optc-O3 -optc-fno-strict-aliasing
04:23:15 <JaffaCake> I already found this bug :(
04:23:19 <dcoutts> :-)
04:23:21 <dcoutts> heh
04:23:22 <dcoutts> good!
04:23:27 <dcoutts> what is it?
04:23:39 <JaffaCake> there's a comment in rts/Makefile
04:23:42 <dcoutts> or you found it and fixed it with -optc-fno-strict-aliasing
04:23:51 <JaffaCake> http://darcs.haskell.org/ghc/rts/Makefile
04:24:23 <dcoutts> aye, I see
04:24:41 <JaffaCake> yes, it's not really a bug in our code, but strict aliasing is too strict: it doesn't understand our types
04:25:03 <dcoutts> so we should just add -fno-strict-aliasing to the rts cflags
04:25:27 <int-e> http://www.levenez.com/unix/history.html has a UNICS from 1969 ...
04:25:27 <JaffaCake> or just use GC_HC_OPTS as above
04:25:29 <lambdabot> The title of that page is "UNIX history (preview)"
04:25:44 <dcoutts> JaffaCake, for 6.4.2 (.3) I mean
04:25:51 <JaffaCake> I'll commit that patch to the 6.4 branch
04:25:58 <dcoutts> JaffaCake, you think it's ok to use -O3 in 6.4.x ?
04:26:23 <JaffaCake> I don't know; I've tested it with HEAD, at least on GC.c, but not on the 6.4 branch
04:26:35 <JaffaCake> probably best to be safe and avoid it
04:26:41 <dcoutts> even gentoo doesn't encourage -O3 these days ;-)
04:28:46 <dcoutts> JaffaCake, I don't see GC_HC_OPTS used, I guess it's a $(THING)_HC_OPTS rule somewhere
04:28:56 <JaffaCake> yes
04:29:02 <JaffaCake> I just committed the patch
04:29:09 <dcoutts> so we could just add GC_HC_OPTS += -optc-fno-strict-aliasing to the rts makefile in 6.4.x then?
04:29:13 <JaffaCake> leaving out the -O3
04:29:16 <dcoutts> yep
04:29:24 <dcoutts> I'll patch the gentoo ebuilds then
04:29:27 <JaffaCake> yes, that's what I did
04:29:40 <dcoutts> and it'll be in for 6.4.3
04:30:01 <dcoutts> great, so we can close the bugs
04:31:12 <JaffaCake> dcoutts: thanks for helping to track it down
04:31:24 <dcoutts> np, thanks for the directions
04:41:00 <ski> hm, 'ContT o' can't be made into a functor, right ?
04:46:39 <dcoutts> JaffaCake, so if you move to building without gcc on win32, doesn't that mean the whole rts will need to be written in .cmm ?
04:46:59 <dcoutts> or you'd build the rts with gcc, but then not distribute gcc
04:47:51 <dcoutts> there are quite a few libs that use ghc to compile C code, eg fps, darcs, others
04:48:21 <dcoutts> though for those examples we could use .cmm instead, it's only fragments
04:50:15 * kzm uses GHC to compile C code :-)
04:51:06 <kzm> The nice thing is that I don't have to worry about the whereabouts of Rts.h and whatnot - GHC seems to know, but GCC must be told.
04:51:22 * dcoutts goes out shopping
04:51:25 <kzm> But perhaps I could write the necessary snippets in c-- instead?
04:54:33 <ski> hm, 'instance (MonadTrans t,Monad m) => Monad (t m)' is false, right ?
05:05:59 <ski> Pete_I : actually, if you want all those three numbers to have no common divisors, that above is not sufficient, i just learned
05:09:52 <Pete_I> ski, how so?
05:11:24 <ski> > let nogcd (a,b,c) = gcd a (gcd b c) == 1 in map nogcd [(2,15,5),(2,3,3)]
05:11:25 <lambdabot>  [True,True]
05:12:28 <Pete_I> ....
05:13:27 <ski> so you need to compare each pairing of "different" elements
05:14:17 <Pete_I> but (gcd b c) returns the gcd of those. if they don't have anything in common, then gcd a b doesn't matter.
05:14:20 <Pete_I> wait....
05:14:24 <Pete_I> blast.
05:14:35 <ski> right
05:15:21 <ski> > let nogcd (a,b,c) = gcd a (gcd b c) == 1 in map nogcd [(15,5,2),(3,3,2)]
05:15:22 <lambdabot>  [True,True]
05:15:41 <ski> (actually that was what i intended, but the previous one shows the problem just fine, too)
05:16:13 <Pete_I> wait.
05:16:19 <Pete_I> it's supposed to return true.
05:16:37 <Pete_I> if the numbers are coprime it returns true.
05:16:52 <Pete_I> i created the nogcd function for use in the filter function
05:17:01 <ski> yes .. but they aren't (pairwise) coprime
05:17:16 <Pete_I> pairwise doesn't matter.
05:17:27 <Pete_I> not for what i'm doing atleast.
05:17:45 <ski> so then you don't want 'nogcd' to be symmetric ?
05:17:56 <ski> hm
05:18:02 <Pete_I> it is symmetric. you just showed that.
05:18:31 <ski> ah, right (ignore that, then :)
05:18:35 <xerox> > and [gcd (x*y) z == gcd x (y*z) | x <- [2,3,5], y <- [2,3,5], z <- [3,5,5], x /= y && y /= z]
05:18:36 <lambdabot>  True
05:18:53 <ski> so, the question just boils down to what the intended semantics was
05:19:17 <Pete_I> yes. i intended for it to return true if there wasn't anything the 3 numbers had in common
05:19:30 <ski> the one i was thinking of was pairwise coprime .. but it now seems the one you had in mind was for their greatest common divisor to be 1
05:19:34 <ski> right
05:19:45 <Pete_I> yes
05:19:45 <xerox> ski, that works, right?
05:19:54 <ski>  > and [gcd (x*y) z == gcd x (y*z) | x <- [2,2,2, y <- [2,2,2], z <- [2,2,2], x /= y && y /= z]
05:19:59 <ski> > and [gcd (x*y) z == gcd x (y*z) | x <- [2,2,2, y <- [2,2,2], z <- [2,2,2], x /= y && y /= z]
05:19:59 <lambdabot>  Parse error
05:20:05 <ski> mrf
05:20:12 <ski> > and [gcd (x*y) z == gcd x (y*z) | x <- [2,2,2], y <- [2,2,2], z <- [2,2,2], x /= y && y /= z]
05:20:13 <lambdabot>  True
05:20:25 <xerox> Ops.
05:20:41 <ski> that's why i said '"different" elements'
05:20:42 <xerox> > and [(gcd (x*y) z == 1) && (gcd x (y*z) == 1) | x <- [2,3,5], y <- [2,3,5], z <- [3,5,5], x /= y && y /= z]
05:20:43 <lambdabot>  False
05:20:49 <xerox> I see.
05:21:16 <Pete_I> hmm, that gives me an idea...
05:21:44 <Pete_I> gcd (a*b) c == 1 should work just as well for my function.
05:21:56 <Pete_I> ...i think
05:22:56 <Pete_I> and it does :)
05:23:37 <xerox> Woopee :)
05:27:02 <ski> > let select [] = do {mzero}; select (x:xs) = do {return (x,xs)} `mplus` do {(y,ys) <- select xs; return (y,x:ys)} in and [gcd a b == 1 | (a,rest) <- select [2,3,5], (b,_) <- select rest]
05:27:03 <lambdabot>  True
05:27:34 <ski> actually, that is somewhat overkill, since 'gcd' is symmetric .. using 'unAppend' would suffice, here
05:28:21 <Pete_I> does look overly complex for something so simple
05:28:42 <ski> 'select' is just a helper function, that should be in a lib
05:29:02 <ski> (and that implements the pairwise coprime variant, not your variant, Pete_I)
05:29:30 <Pete_I> :)
05:29:38 <ski> > let nogcd (a,b,c) = gcd (a*b) c == 1 in nogcd (2,3,4)
05:29:39 <lambdabot>  False
05:29:54 <ski> hm
05:30:00 <Pete_I> eh...
05:30:31 <Pete_I> it doesn't look like it should work that way...
05:30:45 <ski> right ..
05:30:50 <xerox> Aw.
05:31:06 * ski grins an evil smile
05:31:25 <int-e> > let nogcd (a,b,c) = gcd (a*b) c == 1 in nogcd (2,4,3)
05:31:26 <lambdabot>  True
05:32:16 <Pete_I> > let nogcd (a,b,c) = gcd a (gcd a b) == 1 in nogcd (2,4,3)
05:32:17 <lambdabot>  False
05:32:34 <Pete_I> > let nogcd (a,b,c) = gcd a (gcd a b) == 1 in nogcd (2,5,3)
05:32:35 <lambdabot>  True
05:33:10 <ski> > let nogcd (a,b,c) = gcd a (gcd b c) == 1 in map nogcd [(2,4,3),(2,3,4),(2,5,3)]
05:33:11 <Pete_I> don't understand why the former doesn't work.
05:33:12 <lambdabot>  [True,True,True]
05:33:26 <ski> Pete_I : presumably s/gcd a b/gcd b c/ ?
05:33:34 <int-e> > let nogcd (a,b,c) = (a*b) `gcd` (b*c) `gcd` (a*c) == in  map nogcd [(2,4,3),(2,3,4),(2,5,3)]
05:33:34 <Pete_I> the first one should be false.
05:33:34 <lambdabot>  Parse error
05:33:42 <int-e> > let nogcd (a,b,c) = (a*b) `gcd` (b*c) `gcd` (a*c) == 1 in  map nogcd [(2,4,3),(2,3,4),(2,5,3)]
05:33:43 <lambdabot>  [False,False,True]
05:34:20 <ski> int-e : would that be the pairwise one ?
05:34:21 * xerox stares
05:34:21 <Pete_I> that's like it should be
05:34:26 <Pete_I> ...
05:34:34 <int-e> ski: yes
05:34:55 <ski> interesting
05:35:00 <Pete_I> cool.
05:35:03 * xerox is happy
05:35:27 <Pete_I> the reason i'm not using pairwise, i'm filtering pythagorean triples.
05:35:42 <int-e> > let nogcd (a,b,c) = a `lcm` b `lcm` c == a*b*c in  map nogcd [(2,4,3),(2,3,4),(2,5,3)]
05:35:43 <lambdabot>  [False,False,True]
05:36:06 <xerox> hehe
05:36:15 <Pete_I> i forget. what does 'lcm' mean?
05:36:22 <xerox> Lowest Common Multiple
05:36:26 <int-e> least
05:36:30 <Pete_I> what is it?
05:36:31 <xerox> Sorry
05:36:37 <ski> int-e : yes, i assumed it could be derived by dualizing in somesuch way
05:36:43 <int-e> lcm a b = a*b `div` gcd a b
05:37:00 <ski> yes
05:37:17 <xerox> Now define gcd in terms of lcm and we're done.
05:37:46 <ski> a `gcd` b = a*b `div` (a `lcm` b)
05:38:34 <Pete_I> gcd a b = (a*b)/(lcm a b)
05:38:47 <xerox> > let lcm a b = a*b `div` gcd a b; gcd a b = a*b `div` lcm a b in gcd 4 5
05:38:48 <lambdabot>  Exception: stack overflow
05:38:54 <Pete_I> haha
05:39:03 <ski> :)
05:39:38 <ski> > let gcd a b = a*b `div` lcm a b in let lcm a b = a*b `div` gcd a b in gcd 4 5
05:39:39 <lambdabot>  1
05:40:10 <int-e> > let nogcd (a,b,c) = all (1==) $ zipWith gcd [a,b,c] [b,c,a] in map nogcd [(2,4,3),(2,3,4),(2,5,3)]
05:40:11 <lambdabot>  [False,False,True]
05:40:29 <int-e> ski: haha
05:40:44 <int-e> > let x = x where x = 42 in x
05:40:45 <lambdabot>  42
05:40:48 <xerox> ?!?!?!?!
05:40:48 <lambdabot> Unknown command, try @list
05:41:14 <xerox> ski, why does your one work?
05:41:30 <int-e> xerox: uhm. think about scopes.
05:41:35 <ski> xerox : 'gcd' definition uses outer 'lcm' definition
05:41:40 <Pete_I> > let 0 = 1 in 0/0
05:41:41 <lambdabot>  NaN
05:42:07 <xerox> I can understand your one int-e
05:42:11 <Pete_I> what's "-1.#IND
05:42:14 <Pete_I> supposed to mean?
05:42:16 <ski> > let 0/0 = 42 in (12 - 12) / 0
05:42:18 <lambdabot>  42
05:42:38 <int-e> ski: heh
05:42:43 <Pete_I> i'll have to put that in all my programs.
05:42:48 <Pete_I> just for kicks.
05:42:51 <xerox> But there is really a difference between let a = ..; b = .. in .. and let a = .. in let b = .. in .. ?
05:43:00 <int-e> xerox: sure
05:43:02 <ski> of course
05:43:12 <int-e> xerox: the bindings in a single let declaration are mutually recursive
05:43:24 <ski> xerox : the first one is like 'letrec', the second one like 'let*'
05:43:43 <xerox> int-e - Aren't they mutually recursive in either case?
05:43:51 <ski> no
05:44:09 <int-e> > let x = y in let y = 42 in x
05:44:10 <xerox> Ah-ha
05:44:10 <lambdabot>  Not in scope: `y'
05:44:12 <Pete_I> > let 0/0 = 1; let a / b = b in 0/0
05:44:13 <lambdabot>  Parse error
05:44:20 <Pete_I> darn.
05:44:25 <xerox> ...the first binding uses the well-defined gcd.
05:44:35 <ski> > let 0/0 = 1; a / b = b in 0/0
05:44:36 <lambdabot>  1
05:44:43 <int-e> lcm actually, but yeah
05:44:46 * xerox is tempted to give negative karma to ski -- bad boy :)
05:44:56 * ski grins
05:45:02 <int-e> @karma ski
05:45:02 <lambdabot> ski has a karma of 4
05:45:07 <Pete_I> what use is lcm?
05:45:10 <Pete_I> i can't remember...
05:45:17 <ski> xerox : you should thank me, for expelling your illusions !
05:45:23 <xerox> Thank you.
05:45:44 <int-e> lcm a b is the smallest positive integer that's a multiple of both a and b.
05:45:51 <xerox> But in *reality* you illuded me the mutually recursive version worked
05:45:52 <xerox> :)
05:46:00 <darrint_> does anyone have an example of using readPixels (from hopengl?)
05:46:02 <ski> and it did :)
05:46:13 <xerox> No!
05:46:15 <ski> er, my version worked, i meant
05:46:18 <xerox> Eh.
05:46:48 <xerox> You're like Descartes' evil.
05:47:02 <ski> what's that ?
05:47:50 <int-e> > let (x,y,z) = (1,x,y) in z -- that's evil
05:47:51 <lambdabot>  1
05:48:01 <xerox> hop hop hop..
05:48:05 <xerox> ..splash
05:48:09 <ski> int-e : no, attribute grammars are cool !
05:49:27 <xerox> ski http://plato.stanford.edu/entries/descartes-epistemology/#3.2
05:49:29 <lambdabot> The title of that page is "Descartes' Epistemology"
05:49:45 <Pete_I> let (x,y) = (y,x) in x
05:50:08 <Pete_I> > let (x,y) = (y,x) in x
05:50:09 <lambdabot>  Add a type signature
05:50:19 <Pete_I> > let (x,y) = (y,x) in x :: Integer
05:50:20 <lambdabot>  Exception: <<loop>>
05:50:29 <Pete_I> cool, never seen that before.
05:50:37 <ski> > let (x,y) = (y,1:x) in x
05:50:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:51:21 <Pete_I> > let (x,y) = (y:x:1, 2:x)
05:51:22 <lambdabot>  Parse error
05:51:47 <Pete_I> > let (x,y) = (y++x:1, 2:x) in (x,y)
05:51:47 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
05:51:47 <lambdabot>    Expected ...
05:51:59 <Pete_I> i hate infinate type.
05:52:06 <int-e> don't do that then
05:52:30 <xerox> ?type (:)
05:52:31 <lambdabot> forall a. a -> [a] -> [a]
05:52:56 <Pete_I> that doesn't tell me much...
05:52:56 <int-e> @unlambda `````sii``s``s`ks``s`k`s`ks``s``s`ksk``s`k`s``si`kik`k``s`ksk.*. #
05:53:02 <lambdabot> *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *
05:53:02 <lambdabot> *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *
05:53:02 <lambdabot> *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *
05:53:02 <lambdabot> *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *
05:53:04 <lambdabot> *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *
05:53:07 <lambdabot> [5496 @more lines]
05:53:09 <shapr> ouch
05:53:11 <Pete_I> :/
05:53:22 <Pete_I> what was that?
05:53:26 <ski> > let (x:xs) /\/ ys = x : (ys /\/ xs) in let (x,y) = (1:(y /\/ x),2:x) in x
05:53:27 <lambdabot>  [1,2,1,1,2,2,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,...
05:53:34 <shapr> Unlambda is scary stuff.
05:54:06 <Pete_I> @unlambda (\x -> [1..x])
05:54:06 <lambdabot> unlambda: Unknown operator '('
05:54:13 <Pete_I> @unlambda \x -> [1..x]
05:54:13 <lambdabot> unlambda: Unknown operator '\\'
05:54:18 <Pete_I> wierd.
05:54:19 <xerox> > let cycle xs = let (ys,zs) = (zs,ys++xs) in zs in cycle "hi"
05:54:20 <lambdabot>  Exception: <<loop>>
05:54:20 <ski> @unlambda s
05:54:21 <lambdabot> Done.
05:54:33 <Pete_I> @unlambda xs
05:54:33 <lambdabot> unlambda: Unknown operator 'x'
05:54:39 <shapr> Pete_I: Unlambda is a pure lambda calculus interpreter.
05:54:41 <Pete_I> @unlambda `s
05:54:42 <lambdabot> unlambda: Parse error at end of file
05:54:46 <Pete_I> oh
05:54:58 <ski> @unlambda .*
05:54:59 <lambdabot> Done.
05:55:02 <xerox> ?unlambda ski
05:55:02 <lambdabot> Done.
05:55:04 <shapr> Pete_I: http://www.ofb.net/~jlm/unlambda/
05:55:05 <lambdabot> The title of that page is "Unlambda"
05:55:50 <ski> @unlambda `.*i
05:55:50 <lambdabot> *
05:55:55 <Pete_I> fascinating. i'll have to give it a read.
05:56:39 <int-e> > let pattern s t = s ++ pattern t (s ++ t) in pattern "*" " "
05:56:40 <lambdabot>  "* *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *...
05:57:35 <int-e> well, the unlambda program does something like that
05:59:25 <Pete_I> @unlambda * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *
05:59:25 <lambdabot> unlambda: Unknown operator '*'
05:59:41 <Pete_I> it's got me confused now.
05:59:42 <int-e> > let pattern s t = s ++ pattern t (t ++ s) in pattern "*" " "
05:59:43 <lambdabot>  "*  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  ...
06:01:27 <Pete_I> must sleep. later people.
06:01:38 <shapr> g'nite
06:03:01 <int-e> @unlambda `r`..`.C`.B`.A`. `.s`.a`. `.y`.s`.a`.e`. `.s`.a`. `.s`.'`.t`.Ii
06:03:01 <lambdabot> It's as easy as ABC.
06:07:41 <int-e> @unlambda `r``.O..``.r.t``. .'``.m.n``.a.s``.y.i``.b. ``.e.t``. .ii
06:07:42 <Pete_I> @unlambda `r`..
06:07:43 <lambdabot> Or maybe it isn't.
06:07:45 <lambdabot> unlambda: Parse error at end of file
06:09:18 <int-e> @unlambda `r`..i
06:09:18 <lambdabot> .
06:09:51 <int-e> .<char> is a single combinator
06:10:33 <ski> > let interleave xss = map head xss ++ interleave (map tail xss) in fix (\cantor -> '*' : tail (interleave [cantor,repeat ' ',cantor]))
06:10:34 <lambdabot>  "* *   * *         * *   * *                           * *   * *         * * ...
06:10:51 <ski> int-e : can you write that in a similar way as your 'pattern' above ?
06:11:14 <int-e> hmm.
06:11:41 <ski> (the "obvious definition" doesn't work, of course)
06:13:05 <ski> (it seems some kind of left -factoring / -rewriting is needed ..)
06:18:15 <int-e> let pattern s t = t ++ s ++ pattern (s ++ t ++ s) (t ++ t ++ t) in '*':pattern "*" " "
06:18:17 <int-e> > let pattern s t = t ++ s ++ pattern (s ++ t ++ s) (t ++ t ++ t) in '*':pattern "*" " "
06:18:18 <lambdabot>  "* *   * *         * *   * *                           * *   * *         * * ...
06:20:46 <ski> ty
06:21:07 <ski> i was trying something like that, but couldn't make it work out ..
06:22:02 <ski> the other day i made a nice mutually recursive definition of the stream of primes, and the stream of composites ..
06:23:34 <ski> composites are the pairwise products of primes and composites, and primes are what is left if you remove composites from the naturals greater than 1
06:23:50 <int-e> oh. okay ...
06:24:41 <ski> (but, similarly as my 'cantor' above, i needed a little bootstrapping, not requiring another list of primes or anything like that, though)
06:38:22 * shapr boings furiously
06:38:25 <shapr> wheee!
06:42:10 <kzm> boingy today, shapr?
06:45:48 <ski> > let foo [] bs = bs; foo (a:as) ~(_:bs) = a : foo as bs in let pattern s t = foo s $ pattern s' t' ++ t' ++ pattern s' t' where s' = s ++ t ++ s; t' = t ++ t ++ t in pattern "*" " "
06:45:49 <lambdabot>  "* *   * *         * *   * *                           * *   * *         * * ...
06:45:56 * ski is happy
06:45:57 <darrint_> How does one get from an MArray to a Ptr?
06:46:02 <ski> int-e : how about that ?
06:46:10 <shapr> kzm: Yeah, lotsa energy.
06:47:17 <kzm> Do let me know if you want to spend some of it on my code :-)
06:47:43 <Itkovian> what's the best way to join a few thingies with types (in order) a, [a], a
06:48:01 <ski> join ?
06:48:08 <Itkovian> wrap up the a's in a [] and concat?
06:48:28 <Itkovian> ski: join from which lib?
06:49:02 <ski> yes, that, or, in simple cases, '(:)','(++)','(:[])'
06:49:20 <ski> (Itkovian : sorry, i just wondered what you meant by 'join')
06:50:29 <int-e> ski: hmm, whay's the ++ t' ++ pattern s' t' part for?
06:51:26 <ski> hrm, yes
06:51:40 <ski> that's not needed, of course
06:53:01 <ski> int-e : i guess that was a left-over from my version using 'interleave'
06:53:26 <int-e> @type maybe
06:53:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:55:18 <ski> (m, possibly .. i first tried a fancy definition of 'foo', but it got so ugly i just reverted to the direct one)
06:56:09 <shapr> kzm: I'm spending it on paying code, and probably Hope or HaskellNet after that.
06:56:49 <int-e> > let pattern s t = s ++ foldr (const tail) (pattern (s ++ t ++ s) (t ++ t ++ t)) s in take 80 $ pattern "*" " "
06:56:50 <lambdabot>  "* *   * *         * *   * *                           * *   * *         * * ...
06:58:53 <darrint_> Is there a place where hopengl folks hang out?
06:59:15 <shapr> Mailing list mostly, but some users are here.
07:02:54 <ski> > let pattern s t = s ++ foldr (const tail) (pattern (step s) (step t)) s where step x = x ++ t ++ x in take 80 $ pattern "*" " "
07:02:56 <lambdabot>  "* *   * *         * *   * *                           * *   * *         * * ...
07:03:26 <SamB> does anyone use MozEmbed
07:04:06 <SamB> ?
07:04:16 <shapr> I tried it awhile back, it's cool.
07:04:21 <shapr> I never got around to building a Haskell browser though.
07:04:59 <JKnecht> that's general isn't it, not haskell specific? Are you gonna make a haskell plug-in?
07:05:13 <SamB> well, I'm wondering if there is some easy way that I have somehow missed to get it to give you a context menu if you right click (I don't care if it is just the normal mozilla one, I just want my "back" like in IE ;-)
07:05:16 <shapr> MozEmbed.hs is haskell specific.
07:05:46 <SamB> the understanding is that I'm asking about the gtk2hs bindings ;-)
07:05:58 <SamB> seeing as this *is* #haskell
07:06:44 <JKnecht> shapr: where does MozEmbed.hs live?
07:07:01 * BCoppens wonders if there are any haskell bindings for Qt or KDE
07:07:13 <SamB> maybe if I got it to use Firefox instead of Mozilla, it would work batter
07:07:17 <SamB> er, better
07:07:32 <SamB> but for some reason I don't think so.
07:11:03 <sinfinity> shapr: so there aren't any docs for hope other than the code?
07:12:35 <int-e> ski: how about  let pyr x y z = let t a b = map concat $ transpose [a,b,a] in t x y ++ pyr (x ++ t x y) (t y z ++ y) (z ++ t z y) in putStr $ unlines $ take 16 $ "*" : pyr ["*"] [""] [" "]
07:13:59 * BCoppens looks sad as even the linspire folks are still only thinking about haskell/Qt it seems
07:15:57 <ski> int-e : interesting
07:16:50 <ski> (i'd call it something like 'sierpinski', though)
07:16:56 <dcoutts_> SamB, I'm not sure how you enable the right-click menu
07:16:58 <SamB> well, would it really be that much more work to bind KDE as well?
07:17:07 <int-e> ski: sure. but I didn't want to give it away :)
07:17:20 <ski> :)
07:17:33 <SamB> dcoutts_: I actually couldn't find anything in the MozEmbed docs...
07:17:34 <shapr> sinfinity: Not that I know of, but ask me if you have any questions.
07:17:46 <sinfinity> shapr: alright 
07:17:47 <dcoutts_> SamB, google for the GtkMozEmbed class and see if it's something possible with that or if you need to go deeper into the C++ mozilla api
07:18:03 <SamB> the GTK docs, not the haddock ones.
07:18:08 <dcoutts_> SamB, I doubt that building against mozilla/firefox/xulrunner makes much difference
07:18:23 <SamB> yeah, me too :-(
07:18:34 <SamB> I wonder how much work this is for IE.
07:18:37 <dcoutts_> SamB, right, the GtkMozembed docs, not the haskell bits
07:19:10 <shapr> sinfinity: I've done webdev in Java & Python the last 6 years and enjoyed Haskell more than other languages the last five years, so Hope makes sense to me.
07:19:19 <SamB> (nevermind using IE from Haskell -- but I bet it wouldn't be too hard if you could get hdirect to work)
07:20:18 <sinfinity> shapr: cool deal. I've done webdev in php for the past 2.5 and it is pretty nightmarish
07:20:33 <sinfinity> shapr: so I'm coming in with high 'hope's
07:20:34 <shapr> sinfinity: Also bringert writes really nice code. It's easy to read and well factored.
07:20:34 <sinfinity> shapr: ;)
07:20:37 <shapr> hah
07:21:56 <SamB> @seen JaffaCake 
07:21:56 <lambdabot> JaffaCake is in #haskell. I last heard JaffaCake speak 2 hours, 50 minutes and 43 seconds ago.
07:22:28 <dcoutts_> SamB, or write your own right click popup menu, it'd not too hard I think.
07:22:29 <JaffaCake> SamB: can I help?
07:22:55 <SamB> JaffaCake: I tried to send a message to the haskell-libraries list
07:23:22 <SamB> is it sitting there waiting for moderator approval, has it gotton through, or did it get lost somewhere?
07:23:24 <JaffaCake> and it got held for moderation?
07:23:35 <JaffaCake> I'll go check
07:24:05 <SamB> usually I get a message when something is held for moderation, I think
07:24:13 <Lemmih> JaffaCake: Do you want a drone to help moderate the mailing list(s)?
07:24:15 <kzm> I got a bounce from -libraries recently.
07:24:22 <JaffaCake> SamB: nothing in the moderation queue, I think the list is set to auto-reject these days
07:24:32 <shapr> I bet the ghc-drone job will get to do moderation among other things.
07:24:33 <JaffaCake> Lemmih: that would be nice :)
07:24:46 <SamB> even for too-large messages?
07:24:47 <kzm> No good error message, just unable to deliver.
07:24:59 <JaffaCake> SamB: you should get a reject message
07:25:06 <JaffaCake> yes, even for large msgs
07:25:07 <Lemmih> JaffaCake: I'd like to volunteer, then.
07:25:27 <JaffaCake> Lemmih: great! which list(s) would you like
07:25:27 <shapr> SamB: I saw your message with attachment. You're talking about the schema patch?
07:25:52 <SamB> oh, it went through ;-)
07:26:42 <JaffaCake> Lemmih: I have most of the lists set to auto-reject non-subscribers now, because the volume of spam became too much, only ghc-bugs and the cvs lists are moderated for non-subscribers
07:27:12 * dcoutts_ has the same problem with cabal-devel
07:27:13 <shapr> Community moderation would be nifty, I wonder how it'd work.
07:27:15 <JaffaCake> regretfully most days I don't get around to checking all the moderator queues
07:27:33 <dcoutts_> too much spam, and yet we have to allow non-subscriber darcs send patches
07:27:36 <Lemmih> JaffaCake: libraries@, cafe@.
07:27:39 <JaffaCake> shapr: moderation is a no-brainer
07:27:42 <SamB> apparantly a small darcs repo is *not* too large to send to the list ;-)
07:28:10 <JaffaCake> Lemmih: those are set to auto-reject right now - do you want to enable moderation?
07:28:24 <shapr> JaffaCake: Yeah, just wondering about some way to expose moderation to the clueful masses, like, any known-good citizen of the mailing list.
07:28:33 <dcoutts_> JaffaCake, can't we arrange for the non-subscriber to go via a spam filter? then moderation would be easier
07:28:46 <SamB> so, is there no way to run a spam catcher before mailman looks at things/
07:28:52 <SamB> s|/|?|
07:29:04 <Lemmih> JaffaCake: Yeah, but perhaps I should start with only libraries@.
07:29:09 <shapr> SamB: I think it'd be straightforward.
07:29:18 <JaffaCake> dcoutts_: possibly, I believe the Yale folks have tried to get some spam filtering implemetned without much success, and I haven't had the time to look into it
07:29:34 <dcoutts_> shapr, might you have the time/know-how ?
07:29:46 <shapr> dcoutts_: Depends on the mailer, I'm using postfix.
07:29:55 <JaffaCake> Lemmih: ok, I'll add you as a list maintainer and send you a password
07:30:01 * dcoutts_ checks what they use on haskell.org
07:30:05 <shapr> Greylisting gets rid of 99% of the spam I received before.
07:30:06 <Lemmih> Great.
07:30:18 <SamB> and maybe it wouldn't be too hard to convince the filter to let through darcs patches
07:30:30 <SamB> what does greylisting do?
07:30:40 <shapr> It temp bounces the first time a mail comes in.
07:30:46 <SamB> ah
07:30:48 <JaffaCake> shapr: you're welcome to be in charge of spam filtering on haskell.org, if you want
07:30:57 <shapr> Spam zombies almost never retry.
07:30:59 <dcoutts_> $ /etc/init.d/postfix status
07:30:59 <dcoutts_> master (pid 17355) is running...
07:31:04 <dcoutts_> shapr, so yes, postifx
07:31:13 <shapr> JaffaCake: It's postfix, I'll take it.
07:31:20 <JaffaCake> sorry, could have told you that :)
07:31:26 <Pete_I> what is % used for in haskell?
07:31:31 <shapr> Pete_I: Rationals
07:31:31 <dcoutts_> shapr, you've got sudo access on haskell.org right?
07:31:37 <shapr> um, I think so.
07:31:43 <dcoutts_> ok, great
07:32:00 <shapr> yup, I got it.
07:32:35 <shapr> I promise I won't switch to http://postmaster.cryp.to/ immediately ;-)
07:32:38 <lambdabot> The title of that page is "Postmaster ESMTP Server"
07:32:42 <SamB> shapr: does that mean that *all* good mail has to be sent twice, or just mail from addresses that haven't retried before?
07:33:01 <SamB> (nevermind that the mail server actually does the retrying)
07:33:11 <shapr> I'm just joking, I wouldn't switch a production box that's not mine to Postmaster.
07:33:46 <JaffaCake> Lemmih: you are now libraries-owner@haskell.org, along with me
07:33:47 <shapr> SamB: I don't know, but I think the policy is adjustable.
07:33:50 <kzm> shapr, isn't NoCeM a sort of community moderation?
07:34:45 * shapr googles for NoCeM
07:35:02 <shapr> Oh, I see.
07:35:11 <shapr> Yeah, gmane has something like that.
07:35:23 <SamB> shapr: would you switch a not-your production box to postmaster if the owner *wanted* you to?
07:35:29 <shapr> SamB: Yeah, sure.
07:35:33 <kzm> Gnus can use NoCeM, I think.  Never got around to it.
07:35:45 <kzm> (Gnus is written by the same guy as Gmane)
07:35:52 <shapr> I didn't know that.
07:35:57 * kzm must run.
07:35:59 <kzm> Later.
07:36:00 * shapr must unicycle!
07:36:36 <shapr> For my own laziness, I wish haskell.org used debian/unstable.
07:51:28 <dcoutts_> SamB, from a look at other mozembed-using apps, it seems the right click menu is not standard
07:51:45 <SamB> yes
07:51:46 <dcoutts_> each on has different capabilities, so no standard one would suffice
07:51:51 <dcoutts_> on/one
07:52:15 <dcoutts_> anyway, doing you're own shouldn't be to hard
07:52:24 <SamB> but it would be *nice* if you could tell it to use the default one, even if it *would* come out blue
07:52:38 <dcoutts_> but what would the default be?
07:52:46 <dcoutts_> just < > ?
07:53:19 <SamB> the one used in the web browser?
07:53:37 <dcoutts_> the web browser has many more capabilities
07:53:46 <dcoutts_> like downloading, saving etc
07:53:50 <SamB> I suppose so
07:54:26 <dcoutts_> which is more than you want for an rss viewer or email editor or help viewer
07:55:09 <SamB> so how do these other apps know when to show the menu?
07:57:47 <SamB> also, which apps are they?
07:59:05 <shapr> dcoutts_: Any idea what RedHat uses for package management? Is there an apt/yum something?
07:59:29 <shapr> Or does rpm do network fetching these days?
07:59:36 * shapr reads manpages...
08:00:38 <dcoutts_> shapr, apt-get I think
08:01:03 <gds> mandrake has a "urpmi" thing which is aptish...
08:01:10 <shapr> apt-get doesn't seem to be installed on haskell.org
08:01:20 <shapr> Nor urpmi, nor yum.
08:01:33 <Pete_I> you could fix it.
08:01:40 <dcoutts_> shapr, I swear it used to be, or perhaps it was some other name
08:01:49 <gds> they used to have a "redhat update" thing too...
08:02:10 <shapr> That's not installed either.
08:02:19 <SamB> dcoutts: hello?
08:02:21 <shapr> At least, no binary named redhat.
08:02:32 <ibid> an sf author discusses copyright and why it's too extensive today: http://www.baens-universe.com/articles/principle
08:02:35 <lambdabot> The title of that page is "articles : A Matter of Principle - Jim Baen's Universe"
08:02:47 <SamB> binary named redhat!
08:02:48 <SamB> haha
08:03:04 <shapr> well, "redhat update" implied that...
08:03:07 <dcoutts_> shapr, it definately used to be there. I've got uses of apt-cache and apt-get in my .bash_history on haskell.org
08:03:17 <dcoutts_> SamB, yes?
08:03:19 <SamB> I think it is typically listed in a menu that way, shapr
08:03:26 <shapr> dcoutts_: weird
08:03:27 <SamB> dcoutts_: you mentioned apps!
08:03:34 <SamB> what are they?
08:03:43 <dcoutts_> SamB, I did? in what context?
08:03:52 <SamB> MozEmbed
08:04:06 <dcoutts_> SamB, oh, right, eg rss readers
08:04:07 <shapr> locate shows nothing for apt-get
08:04:12 <SamB> yes
08:04:18 <dcoutts_> like liferea
08:04:29 <Dino_> ibid: Thanks for that link. I think may have had that Baen's Universe bookmarked for a while intending to go there and subscribe to the mags.
08:05:04 <dcoutts_> SamB, it has a popup menu, it's written in python
08:05:31 * SamB apt-src installs it
08:05:39 <SamB> oh, nice, python ;-)
08:06:08 <SamB> here I was thinking "an unholy blend of C and C++"
08:06:46 <dcoutts_> SamB, no, that's galeon an epiphany
08:06:53 <dcoutts_> an/and
08:07:22 <SamB> hehe
08:07:23 <dcoutts_> they both use gecko but at the C++ level, not via GtkMozEmbed
08:08:08 <xerox> I am having too much fun with the MIT 8.02 lectures. The professor (Walter Lewin) is such a guy :)
08:08:13 <SamB> though I think I'll likely need to use an unholy blend of Haskell and C++, since XPCOM doesn't have Haskell bindings
08:09:33 <ski> xerox : what class is that ?
08:10:26 <xerox> Electricity and Magnetism.
08:10:54 <xerox> Eek, my icecream slipped over while I was writing it. Today your evil flux is high :) Gotta clean...
08:11:04 <dcoutts_> SamB, what are you hacking on then?
08:12:15 <SamB> dcoutts: well, I haven't actually started yet, but I want to get http://www.thewhitelion.org/inform7/ to be at least tolerable to people who have used the windows Inform 7 IDE.
08:12:16 <lambdabot> The title of that page is "I7 for Linux"
08:12:24 <SamB> which includes being able to go back, in my opinion ;-)
08:14:07 <xerox> ski http://ocw.mit.edu/OcwWeb/Physics/8-02Electricity-and-MagnetismSpring2002/VideoLectures/index.htm
08:14:10 <lambdabot> The title of that page is "MIT OpenCourseWare | Physics | 8.02 Electricity and Magnetism, Spring 2002 | Vid ..."
08:14:22 <SamB> ideally, it would also include support for the "inform:" resource locators that Inform 7 uses in its HTML
08:15:35 <shapr> Everytime I do some sysadmin work on haskell.org I want to switch the whole thing to debian/unstable.
08:15:42 <ski> xerox : danke
08:16:14 <BCoppens> xerox: interesting, too bad I didn't find out last week, before my monthly bandwidth is reset ;)
08:16:21 <SamB> shapr: yeah, I know what you mean. at least with the debian part.
08:18:25 <SamB> dcoutts: this looks an awfull lot like C code...
08:20:15 <dcoutts_> SamB, oh, yeah, hmm, my mistake
08:20:38 <SamB> not that that makes it less useful or anything
08:21:10 <dcoutts_> SamB, you can't write your own uri-resource handlers with GtkMozEmbed, that's in the FAQ
08:21:26 <SamB> dcoutts: yeah, yeah, I know...
08:28:19 <SamB> hmm, someone doesn't seem to know about endianness...
08:28:54 <SamB> (see mozsupport_get_mouse_event_button() in mozsupport.cpp)
08:29:06 <SamB> (in liferea)
08:30:51 <resiak> Eew!
08:37:18 <aFlag> i need to write a parser. I'm thinking on somehow verifying if the sintax is valid before actually parsing the stuff into data structures, does it seem like the right thing to do?
08:38:34 <alar> aFlag: "before" imho is not right term
08:38:35 <ski> use parser combinators ?
08:38:41 <alar> does order of execution matter?
08:39:00 <dcoutts_> aFlag, why not do both at once? that's quite normal
08:40:01 <aFlag> i thought if i knew the sintax was correct it would be easy to parse
08:40:16 <dcoutts_> but knowing the syntax correct *is* parsing
08:40:36 <dcoutts_> or rather to find out if it's correct pretty much requires parsing
08:40:43 <aFlag> hum
08:41:24 <ski> aFlag : is it homework ?
08:41:29 <aFlag> yes
08:41:55 <aFlag> i have to write a parser then a type inferer for a little lambda-calculus based language
08:42:41 <ski> if you had a function for checking if a token list has correct syntax, can you tell me what type that function could have ?
08:44:22 <ski> aFlag : btw, is there any hints on parsing packages you could use .. or are you supposed to write the parser fully from scratch (i.e. not using any library, e.g.) ?
08:45:10 <alar> e.g. parser not using standard Prelude :)
08:45:14 <aFlag> well, if that function returns a bool saying if the syntax is correct or not, then probably not
08:45:24 <aFlag> no, i'm supposed to use parsec
08:45:36 <aFlag> the type inferer is the main part of it
08:45:52 <aFlag> i looking for parsec documentation by the way
08:45:58 <ski> alar : well, i should have said 'parsing library' (including class 'Read' :)
08:46:34 <ski> ok, if you're supposed to use Parsec, it becomes easier :)
08:46:54 <aFlag> is there a good article or something about parsec that you could point me to?
08:48:14 * ski doesn't know of such
08:48:31 * alar thinks Parsec docs are good enough
08:48:51 <aFlag> yeah, the teacher keeps saying it's easy, but I'm finding all these concepts rather hard to understand, maybe I shoulda take this class later on. Well, too late now :P
08:49:33 <ski> the main thing is understanding the parsing monad
08:50:05 * alar started to understand parsing monads after writing one
08:53:49 <ski> a parsing action of type 'Parser a', is something that, when run, will try to parse something, eating tokens (which can be characters), and then, if successful, return a value of type 'a'
08:54:02 <ski> @hoogle anyChar
08:54:03 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: CharParser st Char
08:54:21 <ski> anyChar :: Parser Char
08:54:50 <ski> is a parser that tries to grab the next character, and successfully return it .. if there's no more characters it fails
08:55:34 <ski> upper :: Parser Char
08:55:44 <ski> upper = do c <- anyChar
08:55:55 <ski>            if isUpper c
08:56:02 <ski>              then return c
08:56:07 <ski>              else pzero
08:56:20 <ski> that just accepts upper-case characters
08:56:28 <dmhouse> upper = satisfy isUpper :)
08:56:28 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
08:56:39 <dmhouse> Ooh, I haven't got one of these so far.
08:56:58 <ski> dmhouse : i wanted to show how this is Just A Monad (TM)
08:57:10 <ski> pzero :: Parser a
08:57:13 <dmhouse> ski, sure.
08:57:22 <ski> is the parser that always fails
08:57:55 <aFlag> ski, yeah, i read an article from graham hutton, it made things clearer, now i'm trying to read the parsec documentation :)
08:57:56 <ski> aFlag : is this helping any ?
08:58:18 <aFlag> yes it is
08:58:22 <ski> if you have
08:58:25 <ski> do blah
08:58:28 <ski>    bleh
08:58:30 <ski>    ...
08:58:49 <ski> then it will try 'blah', and if that succeeds, try 'bleh', etc
08:59:20 <ski> of 'bleh' fails, it will go back and see if 'blah' could succeed in another way (consider ambiguous grammars)
08:59:41 <aFlag> pzero returns an empty list, right? It's a parser that always fails, right?
08:59:44 <ski> so, it reminds on 'Maybe' and list monads, in this way
09:00:00 <ski> pzero does not monadically return
09:00:02 <ski> it fails
09:00:03 <aFlag> actually (parse pzero) == empty list
09:00:45 <ski> for simplified purpose, we could say
09:01:06 <ski> parse :: Parser a -> String -> Maybe a
09:01:42 <ski> so, then 'parse pzero anyString' would give 'Nothing'
09:01:57 <aFlag> oh, i think graham hutton redifined parse in his code
09:02:23 <ski> yes, if we're doing ambiguous parsing, we'd have
09:02:28 <ski> parse :: Parser a -> String -> [a]
09:02:38 <ski> so then, yes, an empty list of answers
09:02:52 <dmhouse> You could indeed have parse :: MonadPlus m => Parser a -> String -> m a
09:04:15 <ski> (dmhouse : hm, possibly you could make it into a monad transformer, that transforms an underlying monad-with-plus into a parser monad ..)
09:05:07 <ski> aFlag : 'Maybe' is for when you want to have at most one answer, list when you could want to have more than one answer (even if only internally)
09:05:54 <aFlag> yeah, i see, thanks :)
09:06:30 <ski> aFlag : now, maybe you could try to write the parser
09:06:43 <ski> string :: String -> Parser ()
09:07:08 <ski> aFlag : that succeeds only if it can succeddfully eat exactly the given string from the token input
09:07:40 <ski> (so 'parse (string "foo") "foo"' would succeed ..)
09:08:02 <ski> (s/succeddfully/successfully/)
09:10:49 <aFlag> hum, there's an implementation of something like that on the article I read. One of my main difficulties is how to think in monads, I find always thinking on terms of >>= is rather inefficient and that thinking like imperative languages when writting monads leads to incorrect assumptions sometimes
09:11:41 <ski> well, you should think a bit like imperative languages, yes
09:12:23 <ski> anyway, you want to walk through the given string, eating an input char for each char in the string, and check that they're the same
09:12:25 <ski> actually
09:12:29 <ski> maybe you want to write
09:12:39 <ski> char :: Char -> Parser ()
09:12:40 <ski> first
09:13:07 <ski> this succeeds only if the given char is the same as the one it eats
09:13:33 <ski> 'upper' above should give you an idea of how to define that
09:14:51 <ski> aFlag : what do you think ?
09:15:40 <aFlag> i think it would be pretty much the same as the upper one except that it would be c== instead of isUpper
09:15:56 <ski> yes
09:16:07 <ski> so, then, how to write 'string' using 'char' ?
09:16:24 <ski> what to do if the string is empty ?
09:16:31 <ski> what to do if the string is nonempty ?
09:23:49 <aFlag> hum
09:23:57 <aFlag> i'm actually doing something wrong on char
09:26:05 <aFlag> i have this http://www.rafb.net/paste/results/AGHTXH40.html and hugs says Last generator in do {...} must be an expression on line 3
09:26:28 <dmhouse> aFlag: indentation.
09:26:39 <dmhouse> indent the 'if' to be below the 'c'.
09:27:06 <aFlag> oh
09:51:50 <araujo> hello
09:56:33 <shapr> hiya
09:58:02 <aFlag> ski, does this look ok? http://www.rafb.net/paste/results/HgGt8d75.html
10:00:27 <ski> aFlag : almost
10:00:44 <aFlag> what's wrong?
10:00:57 <ski> why do you return the character 'a', when asked to eat the empty string ?
10:01:42 <ski> this is a type error, if you want to stick to the type i gave above (which you don't necessarily have to)
10:02:05 <aFlag> because the value returned doesn't actually matter, all that matters is that it returns Right _
10:02:05 <ski> (string :: String -> Parser ())
10:02:49 <aFlag> when it's used with parse function
10:02:53 <ski> so, why not 'return ()' ?
10:03:06 <ski> '()' is the dummy value
10:03:13 <aFlag> oh
10:03:13 <ski> compare
10:03:20 <ski> @type putChar
10:03:25 <lambdabot> Char -> IO ()
10:03:26 <aFlag> my char was returning Parse Char
10:03:28 <aFlag> actually
10:03:32 <ski> ok
10:03:49 <ski> imo, it is simplest for these to just return '()'
10:04:33 <ski> i though think the Parsec ones return the char (or string) passed as input .. as some sort of confirmation or for when you want to do something with that char or string later, i suppose
10:04:34 <aFlag> yeah, now this: http://www.rafb.net/paste/results/KyIwLU69.html indeed looks better
10:04:56 <ski> ok, now, the other thing
10:05:09 <ski> your 'string' now should work, but could be simplified
10:05:32 <ski> the 'string [c]' case can actually be handled by the two other cases, so is not needed
10:05:42 <ski> do you see that ?
10:06:08 <ski> string (c:[])
10:06:12 <ski> =
10:06:15 <ski> do char c
10:06:18 <ski>    string []
10:06:19 <ski> =
10:06:23 <ski> do char c
10:06:29 <ski>    return ()
10:06:43 <ski> = {assuming 'char c' returns a '()'}
10:06:45 <ski> do char c
10:07:11 <ski> (anyway, this is a minor point)
10:08:01 <aFlag> i was thinking that always having a return () on the end would make it always accept the string, but now I see that it's not true
10:08:34 <ski> right, since it will stop going forward as soon as some parsing action fails
10:24:34 <ruffneck> hi
10:25:15 <ski> hello ruffneck
11:00:44 <_coder_> I just bought Compilers by Alfred V. Aho :DD
11:03:10 <sethk> I like the earlier aho books, although I don't have that one yet.
11:07:35 <wilx> Is there a Haskell plugin for Eclipse?
11:08:28 <sinfinity> wilx: http://eclipsefp.sourceforge.net/haskell/
11:09:03 <sinfinity> wilx: I haven't used it, though.
11:11:28 <wilx> Thanks.
11:30:23 <wferi> Hi! Constructing simple queries by HaskellDB I find that projections do not have any effect on the generated SQL, all fields (columns) are requested in SELECT. Can anybody provide some insight?
11:34:20 <yaarg> wferi: you just use project()...
11:37:47 <wferi> yaarg: I do, but still...
11:38:26 <wferi> imp = do t <- table horde_prefs
11:38:26 <wferi>          restrict (t!pref_uid .==. constant "nemecsek@iif.hu" .&&.
11:38:26 <wferi>                    t!pref_scope .==. constant "imp")
11:38:26 <wferi>          project (pref_name << t!pref_name # pref_value << t!pref_value)
11:38:26 <wferi>          return t
11:38:40 <wferi> It does not matter what I put after project above.
11:40:13 <wilx> Hm, I've never used it but it looks like you are returning whole table object.
11:40:37 <wilx> Not the projected set of columns.
11:40:42 <ski> what is type of 'project' ?
11:40:53 <ski> maybe you should just skip the 'return t' line ?
11:41:06 <Cale> wferi: the results of that restrict and project are thrown away
11:41:26 <Cale> as far as I can tell
11:41:50 <yaarg> ditto
11:42:01 <wferi> gosh, 'return t' looks silly indeed!
11:42:25 <wferi> thank, guys!
11:42:30 <wferi> it works now.
11:43:07 <Cale> oh, apparently restrict is side-effecting
11:43:14 <ski> (Cale : possibly the 'restrict' filters by effect)
11:43:17 <ski> heh :)
11:43:17 <Cale> but yeah, project isn't
11:43:47 <ski> (s/side-// (depending on POV))
11:45:06 <wferi> they are orthogonal, that's why I could use t in project, IIUC.
11:45:51 <yaarg> yup :)
11:49:12 <ski> well, the 'restrict' is orthogonal, but the 'project' is not, i think
11:51:28 <wferi> Hmm, I don't get you, I meat they are orthogonal (wrt each other)
11:51:36 <wferi> s/meat/meant/
11:52:35 <ski> yes, but you can probably have two 'restricts' after each other, both referring to the same 't' .. but not so with 'project'  (this is if i guess correctly, i.e.)
11:54:56 <ski> (s/s'/'s/)
11:56:21 <wferi> Not that I understand this fully, but you certainly can have multiple tables and project columns from each. Not sure what multiple restricts and projects would mean, they can be moved accross each other, given their orthogonality... I mean restricts first, collapsed into a single restrict, then projects collapsed into a singe project. Huh. There may be operational differences, though.
11:57:48 <ski> (yes, additional restricts should just be anded together)
12:00:27 <wferi> That's what happens with restricts preceeding a project. But error results if I move one of them after the projection.
12:02:11 <wferi> Consecuting projects also behave as expected.
12:03:41 * ski thinks deductive databases possible has better notation, anyway
12:07:13 <ski> imp {prefName = PrefName,prefValue = PrefValue} :- hordePrefs {prefName = PrefName,prefValue = PrefValue,prefUId = "nemecsek@iif.hu",prefScope = "imp",...}.
12:07:18 <ski> or something
12:07:26 <ski> (possibly with punning)
12:08:09 <ski> @seen ProfTeggy
12:08:09 <lambdabot> I saw ProfTeggy leaving #Haskell 6 hours, 22 minutes and 4 seconds ago, and .
12:08:29 <ski> lambdabot: and what ?
12:09:11 <wferi> what's that?
12:09:42 <ski> just a made-up syntax of how it could possibly look like
12:09:48 <wferi> Ah.
12:10:37 <wferi> I looked up deductive databases on wikipedia, but couldn't make a connection
12:10:48 <xerox> ?pinky
12:10:49 <ski> (if you ignore that i used records instead of tuples (for unordered attributes/columns/fields), it's basically how it looks in some deductive database langs)
12:10:49 <lambdabot> Unknown command, try @list
12:10:56 <ski> @brian
12:10:56 <lambdabot> Umm, I think so, Brain, but what if the chicken won't wear the nylons?
12:11:17 <xerox> Should it be called pinky?
12:11:37 <ski> @vixen what do you think ?
12:11:37 <lambdabot> let's don't talk about that
12:31:06 <lollan> yo
12:40:07 <VyNiL> is there a way to make a function that would print a string and then return it?
12:40:57 <ski> foo :: String -> String
12:41:06 <ski> foo s = do putStr s
12:41:14 <ski>            return s
12:41:19 <fluxx> how is that going to work?-o
12:41:22 <ski> er
12:41:32 <ski> foo :: String -> IO String -- i of course meant
12:41:44 <fluxx> iow, there is no way ;)
12:41:46 <VyNiL> thats the problem...
12:41:58 <VyNiL> im working with happy and it expects a string
12:42:09 <fluxx> debugging?
12:42:12 <VyNiL> but i want to print the string before returning it
12:42:15 <ski> it returns an action that when run prints the string and monadically returns it
12:42:30 <ski> VyNiL : and 'foo' does that
12:42:44 <SamB> @hoogle trace
12:42:45 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:42:45 <lambdabot> Debug.Trace :: module
12:42:45 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
12:44:23 <SamB> Debug.Trace.trace will print the trace message the first time something wants to actually use its return value
12:44:49 <VyNiL> thnx that worked perfectly
12:44:51 <VyNiL> !
12:46:07 <VyNiL> no... last time error :s
12:46:10 <VyNiL> on foo
12:46:22 <VyNiL> it keeps infering IO
12:46:39 <VyNiL> and expecting []
12:47:09 <ski> so you're using some more io-action, somewhere ?
12:47:51 <ski> maybe you could show the code in question ?
12:48:23 <VyNiL> Param : tran         { "Param 1" } | estados      { "Param 2" } | todo         { prueba "Param -> todo" }
12:48:27 <VyNiL> sorry
12:48:34 <VyNiL> new to irc :s
12:48:35 <SamB> VyNiL: try Debug.Trace.trace ;-)
12:48:36 <ski> lisppaste2: url
12:48:36 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:48:39 <SamB> like...
12:48:39 <lambdabot> The title of that page is "Enter your paste"
12:48:55 <ski> @vixen thank you
12:48:55 <lambdabot> my pleasure
12:49:10 <SamB> lisppaste2: die
12:51:29 <lisppaste2> VyNiL pasted "Parser.y" at http://paste.lisp.org/display/21266
12:51:32 <monochrom> I like lisppaste
12:51:49 <monochrom> But I don't like Parser.y :)
12:52:09 <VyNiL> Debug.Trace didnt work either... im actually not debugging... i need it for the final version
12:52:49 <ski> i believe happy has some way of specifying the underlying monad ..
12:53:13 <ski> btw. why do you need the parser to do io ?
12:53:16 <sethk> VyNiL, I don't see Debug.Trace anywhere in that post
12:53:34 <monochrom> prueba's inferred type should be like String->IO String.  (Why are you doing putStr there?)
12:53:57 <VyNiL> i've deleted it... but was using it instead of 'prueba'
12:54:35 <sethk> VyNiL, I'd try doing putStrLn followed by hFlush
12:54:36 <monochrom> What is writeS ?
12:54:48 <ski> (VyNiL : yes, i accidentally before left out the 'IO' in the type of (what you've now called) 'prueba')
12:55:00 <VyNiL> i need it to do IO because its part of requirement (an unnecessary one if you ask me)
12:55:12 <sethk> preuba is "try", isn't it?
12:55:16 <VyNiL> yes...
12:55:17 <monochrom> Not this again.
12:55:26 <VyNiL> more like test
12:55:40 <ski> couldn't you first parse, and later, walk through AST and do io ?
12:56:11 <ski> otherwise, you could possibly store io-actions (possibly using IndirectComposite) in the AST, and perform those later
12:56:36 <sethk> VyNiL, I think someone already said, but the type of preuba is IO String, not String (because the last line is return s)
12:56:49 <ski> (or, there's maybe a way to make happy do io during parsing ..)
12:56:58 <sethk> VyNiL, Debug.Trace will work if you code it properly
12:57:20 <VyNiL> sethk, yes, i tryed that, but the problem is that it is suposed to be String
12:57:38 <monochrom> I'm tired of this.  We went through this last month with Alex.  Just use unsafePerformIO and whatever.
12:57:44 <sethk> VyNiL, if you are in the IO monad, you cannot use a function that returns String
12:57:52 <sethk> and I believe you are in the IO monad here
12:58:23 <VyNiL> i could print on the tree but im not suposed to... its part of a university project, and the specification demands me to do it before the tree
12:59:03 <ski> seems like a stupid specification
12:59:30 <ski> hm
12:59:31 <sethk> VyNiL, doesn't he need  { do { _ <- preuba "Param -> todo" } }
12:59:44 <Zarvok> > nub [2,3,2]
12:59:45 <lambdabot>  [2,3]
12:59:46 <SamB> ski: you can do monadic parsers in Happy, yes
12:59:55 <Zarvok> @type nub
12:59:55 <sethk> ski, might seem stupid.  might be stupid, yes, but if that's his assignment ...
12:59:56 <lambdabot> forall a. (Eq a) => [a] -> [a]
13:00:00 <ski> possibly you could make the "AST" returned to be 'IO ParseTree'
13:00:15 <ski> sethk : ..
13:00:17 <Zarvok> \msg lambdabot @hoogle nub
13:00:21 <SamB> @google site:haskell.org intitle:happy inurl:doc
13:00:23 <lambdabot> http://darcs.haskell.org/happy/doc/
13:00:31 <SamB> @google site:haskell.org intitle:happy inurl:documentation
13:00:33 <lambdabot> No Result Found.
13:00:35 <SamB> er.
13:00:42 <SamB> @google site:haskell.org intitle:happy documentation
13:00:44 <lambdabot> http://www.haskell.org/happy/
13:01:07 <monochrom> The guy last month promised "yes there is a way, I'll show you the official solution after it's due tomorrow".  A month has passed, and I have even finished my long overdue paper review I promised an editor, and that guy never showed anything.  I no longer believe anything he will say.
13:01:24 <SamB> http://www.haskell.org/happy/doc/html/sec-monads.html
13:01:26 <lambdabot> The title of that page is "2.5. Monadic Parsers"
13:01:45 <SamB> VyNiL: you should check that page out
13:05:19 <araujo> VyNiL, ve?
13:05:32 <monochrom> The same ve last time.
13:05:44 <sieni> VyNiL: If you have a value a of type IO Foo, a function f of type Foo -> Bar and want to get a value of type IO Bar (remember, you can't get rid of the IO), then you can just use bind and return as follows: (>>=) a (return . f)
13:05:54 <sieni> (I hope :^)
13:06:32 <SamB> sieni: well, happy lets your parser be monadic, without making you deal in monadic values all the time
13:08:28 <ski> (sethk : actually that's not legal syntax ..)
13:09:00 <xerox> ski - Isn't it?
13:09:09 <xerox> sieni - Even just: fmap f a
13:09:12 <ski> (sieni : there's also 'liftM' / 'fmap')
13:09:30 <xerox> ?pl \xs f -> xs >>= return . f
13:09:30 <lambdabot> (. (return .)) . (>>=)
13:09:36 <ski> > do {_ <- "foo"}
13:09:37 <lambdabot>  Parse error
13:09:40 <xerox> ?pl \f xs -> xs >>= return . f
13:09:40 <lambdabot> fmap
13:09:42 <VyNiL_> ill try the ilegal syntax, hehe
13:10:15 <ski> VyNiL_ : maybe you want to see what you missed ?
13:10:48 <SamB> http://www.haskell.org/happy/doc/html/sec-monads.html
13:10:49 <lambdabot> The title of that page is "2.5. Monadic Parsers"
13:10:55 <SamB> say:
13:11:15 <SamB> %monad { IO }
13:12:29 <SamB> then, where you need to do some IO instead of just returning a value, you can use {% do ... } instead of { ... }
13:12:46 <SamB> but be careful, because happy mangles your indentation
13:15:23 <VyNiL_> lets try that
13:16:40 <SamB> so, you might want the explicit block structure
13:19:21 <VyNiL_> the problem is the {% do ... } also returns IO
13:19:34 <ski> which should not be a problem
13:19:43 <VyNiL_> because of %monad?
13:20:02 <ski> yes, and since you use '{%' instead of '{'
13:28:18 <araujo> VyNiL_, you from .ve?
13:28:59 <SamB> yes, that is what {% do ... } is *for*
13:29:17 <VyNiL_> yes
13:29:53 <SamB> well, really the syntax is just {% ... }, but typically you'd put a do in there ;-)
13:30:00 <VyNiL_> i found a way without the monad
13:30:14 <araujo> nice, me too
13:30:54 <VyNiL_> araujo, usb?
13:31:30 <araujo> VyNiL_, nop , 
13:35:41 <shapr> hej bringert!
13:35:48 <bringert> hej shapr
13:35:48 <shapr> How was the talk? Do you have slides online?
13:35:55 <shapr> Nice hostname :-)
13:36:12 <xerox> Yow bringert!
13:36:16 <mahogny> lol
13:36:25 <bringert> oh, yeah, of course that would be visible
13:36:33 <bringert> shapr: no slides online atm
13:36:39 <mahogny> is galois is the only company around here or what? :)
13:36:41 <bringert> shapr: they will be after ICFP
13:36:51 <bringert> I don't work here
13:36:58 <bringert> I'm just visiting
13:37:29 <bringert> hi xerox
13:38:02 * xerox was about unrolling the dependencies to get a hope up.
13:41:14 <shapr> bringert: What was the talk about? Or is that ICFP material also?
13:41:33 <bringert> shapr: yes, I'll present it at ICFP
13:41:41 <bringert> xerox: cool
13:42:03 <bringert> xerox: be aware that it is in a lot of flux, and some things don't work
13:42:34 <xerox> I am compiling and installing the Haskell of the INSTALL list now...
13:42:55 <bringert> cool, be sure to get the darcs versions
13:43:09 <shapr> xerox: Did you see my unicycle pic from an hour ago? http://www.scannedinavian.com/hope/image/7
13:43:28 * shapr boings happily
13:43:29 <xerox> Yup, I am chasing your RSS closely, you write so much (:
13:43:32 <shapr> heh, cool!
13:43:50 <xerox> I watch a 8.02 lecture, check shapr, 4 items.
13:43:52 * shapr laughs
13:43:59 <xerox> Really! :)
13:44:26 <bringert> man, that is a fat unicycle tire
13:44:49 <shapr> I can barely wait till the hscolour plugin is available for blob, then I can write long detailed entries about stuff like deforestation.
13:45:01 * xerox wants hope more now
13:45:10 <xerox> bringert - What is that doesn't work, exactly?
13:45:20 <shapr> bringert: Yeah, it's 3.7 inches! It's awesome on mud, gravel, sand, etc. It also goes over curbs like going over small rocks.
13:45:47 <xerox> Heh, for one, the haskell-exif package, it seems.
13:46:06 <bringert> xerox: do you have gd2?
13:46:12 <araujo> VyNiL_, you from usb?
13:46:33 <xerox> bringert - Hmm. Maybe not. I'm installing it.
13:46:39 <bringert> xerox: hmm, for non-working things first see the TODO, then off the top of my head there's entry and tag deletion which is not implemented
13:47:00 <bringert> xerox: you're using darwinports, right?
13:47:01 <xerox> bringert - Does it need an SQL server running?
13:47:04 <xerox> Yup.
13:47:18 <bringert> xerox: either that, or SQLite
13:47:34 <xerox> What do you reccommend? I never played properly with SQL.
13:47:43 <bringert> xerox: HaskellDB/SQLite has an annoying problem with character escapes
13:47:59 <bringert> xerox: I'd reccomend that you use MySQL or PostgreSQL
13:48:00 <shapr> MySQL is what bringert uses, so it's probably easiest. I use postgresql myself.
13:48:35 <bringert> shapr: actually I use MySQL on hope.bringert.net but PostgreSQL on my local machine
13:48:44 <shapr> Oh, I didn't know that.
13:48:47 <xerox> What is the difference?
13:49:11 <shapr> xerox: MySQL doesn't use transactions by default, and doesn't have great support for nested transactions even when they're on.
13:49:18 <bringert> xerox: from your point of view the difference would mostly be the ease of installation
13:49:29 <bringert> since hope doesn't use transactions yet
13:49:31 <shapr> That means that MySQL is commonly perceived as fast but unsafe, and postgresql is commonly perceived as safe but slow.
13:49:58 <bringert> though if you are going to start using an RDBMS I'd recommend PostgreSQL for the reasons shapr is giving
13:49:59 <shapr> When in fact, there's not really much difference past the default settings of mysql not using transactions and postgresql using transactions.
13:51:12 <xerox> bringert - It can't find exif-data.h where is the proper place to specify the path?
13:51:27 <bringert> I have been playing with a native Haskell database back-end for HaskellDB. It's gotten far enough to run Hope with, but it doesn't support concurrent writes and transactions, which would make it not work for multi-user Hope installations
13:51:40 <shapr> The Cargo Cultists who do webdev use LAMP, which is short for Linux, Apache, MySQL and PHP. They perceive that MySQL is faster than PostgreSQL, and so MySQL is more often used. (and more often cursed for weird data errors when the cultists don't understand transactional semantics)
13:51:44 <bringert> xerox: you use Darwinports, right?
13:51:50 <xerox> bringert - Yes.
13:52:13 <xerox> shapr - I see. Thanks.
13:52:13 <shapr> (but that was probably more information than you really wanted)
13:52:26 <bringert> @where paste
13:52:27 <lambdabot> http://paste.lisp.org/new/haskell
13:52:57 <lisppaste2> bringert pasted ".profile for Darwinports" at http://paste.lisp.org/display/21270
13:53:02 <shapr> xerox: Any pix of you online?
13:53:08 <bringert> xerox: see paste
13:53:15 <VyNiL_> araujo, yes
13:53:28 <xerox> shapr - Not that I know of (:
13:53:38 * xerox flies to see
13:53:39 <bringert> put that in your profile, and ghc should find your darwinports libs and headers
13:53:55 <bringert> i.e. in your ~/.profile
13:54:02 <bringert> and source it
13:54:05 <xerox> bringert - Ah cool. My .profile has part of that, namely the PATH parts :-)
13:54:11 * xerox goes tweaking
13:54:38 <bringert> I've never used CPATH and LIBRARY_PATH before, but they work really well
13:54:54 <shapr> Anyone know if it's possible to persuade Yale to install debian/unstable on haskell.org? The version of RedHat AS it's using now is ancient (last updated in 2003).
13:55:21 <shapr> I guess I should ask Olaf Chitil or John Peterson?
13:55:55 * shapr considers Postmaster for a moment...
13:56:04 <xerox> bringert: haskell-gd install fails with `Reading package info from ".installed-pkg-config" ... done.\n
13:56:04 <xerox> ghc-pkg: invalid package identifier: '
13:56:18 <bringert> huh?
13:57:01 <bringert> weird
13:57:07 <bringert> what ghc version do you have?
13:57:09 <xerox> Mumble.
13:57:20 <xerox> audreyt's one.
13:57:26 <xerox> The Glorious Glasgow Haskell Compilation System, version 6.5.20060608
13:58:01 <bringert> can you try compiling Setup.hs instead of running it with runghc?
13:58:10 <xerox> Sure.
13:58:12 <bringert> mand redoing the configure, build, install
13:58:20 <bringert> s/^m//
13:59:32 <xerox> Worked!
14:00:14 <xerox> No luck with the exif build, by the way, still can't find exif-data.
14:00:37 <xerox> And in fact there is no exif-data.h there...
14:00:47 <bringert> oh, right
14:00:56 <bringert> you need libexif for that of course
14:01:11 <shapr> bringert: Um, I have a somewhat insane question... any thoughts on a generalized xml-rpc interface for all of Hope? See, I've been using haXe to generate Flash lately, and I was thinking about a Flash UI for Hope...
14:01:36 <xerox> bringert - I do have installed it. Maybe it doesn't search in subpaths?
14:02:12 <bringert> shapr: I tried to keep that sort of thing in mind when designing hope, but I haven't done anything about it
14:02:22 <bringert> shapr: it shoulds cool
14:02:48 <shapr> Yeah, I just don't know if it'd be easy to do without major hacking around.
14:03:02 <bringert> I'm not sure about XML-RPC, I was glancing at REST when designing hope
14:03:28 <bringert> shapr: it would require some serious hacking, but nothing too disruptive
14:04:33 <shapr> Replacing the tree with a flashlet would be easy. Generating UIs for the modules wouldn't be much more difficult.
14:04:35 * shapr thinks more
14:04:43 <tlampo> @type EOF
14:04:44 <lambdabot> Not in scope: data constructor `EOF'
14:04:52 <shapr> @hoogle eof
14:04:53 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
14:04:53 <lambdabot> Text.Read.EOF :: Lexeme
14:04:53 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
14:04:58 <bringert> some things that I think are needed: allow submitting username + password with every request, as alternative to using cookies, maybe use Accept header to give output in something other than XHTML
14:04:59 <tlampo> thanks
14:05:20 * xerox saw 20 lectures on EM in two days...
14:05:25 <xerox> ...eeek.
14:05:36 <bringert> other than that, I think the normal URLs hould work fine for a REST-style interface
14:05:40 <bringert> should
14:05:43 <shapr> bringert: I'm going to really need range limiting if I keep writing this many entries a day.
14:07:26 * shapr considers trying to hack it in like the user limiting patch.
14:07:34 <shapr> But first, postgrey on haskell.org...
14:08:53 <bringert> shapr: did you know that halbum already has range limitiing? it's just not advertised, just like the ordering parameter
14:09:50 <shapr> In that case, I'll see if I can steal that same code for blob.
14:09:50 <bringert> shapr: http://hope.bringert.net/image?start=4&count=2
14:10:03 <bringert> shapr: maybe it should be generalized
14:10:08 <xerox> bringert - aww...
14:10:11 <shapr> Probably so.
14:10:36 <bringert> xerox: did you figure it out?
14:10:40 <shapr> I'd like to have icon style negative slices.
14:10:48 <bringert> huh?
14:11:10 <xerox> Not exactly. LIBRARY_PATH=/opt/local/include/libexif:$LIBRARY_PATH ./setup build doesn't work.
14:11:22 <shapr> bringert: 'abcdefghijklmnopqrstuvwxyz'[-5:] -> 'vwxyz'
14:11:26 <sethk> xerox, you want to use   export LIBRARY_PATH...
14:11:39 <sethk> and you would a semicolon before ./setup
14:12:02 <bringert> xerox: what happens?
14:12:08 <xerox> Same error.
14:12:33 <bringert> xerox: you need CPATH not LIBRARY_PATH
14:12:41 <xerox> Ah!
14:12:43 <sethk> ordinarily it is LD_LIBRARY_PATH, or CPATH, but not LIBRARY_PATH
14:12:56 <bringert> CPATH is for includes, LIBRARY_PATH is for static libraries
14:12:58 <shapr> bringert: How to encode that in an url? Maybe range=-5: ?
14:13:18 <sethk> bringert, OK, didn't know that one
14:13:27 <xerox> Right!
14:14:02 <bringert> sethk: me neither, but I figured that there should be something like LD_LIBRARY_PATH for static libs, and dug it out of some gcc manual
14:14:46 <xerox> I thought LD_ was for the linker
14:14:51 <bringert> shapr: if you use start and count as they are, and just let a negative start count from the end
14:15:03 <shapr> I like it.
14:15:15 <xerox> How do you pronounce Dijkstra?
14:15:29 * shapr guesses dayk-struh?
14:15:57 <bringert> where uh is schwa
14:16:28 <bringert> or short a as in english "bus"
14:16:39 <bringert> that's how I heard people say it anyway
14:17:19 * shapr tries to figure out how to get cpan working on haskell.org
14:19:59 <xerox> (on install) ghc-pkg: /usr/include/libexif doesn't exist or isn't a directory (use --force to override)
14:21:05 * xerox evilly modified .installed-pkg-config
14:24:49 <bringert> xerox: yeah, maybe the cabal-file shouldn't have the hard-coded Include-dirs: /usr/include/libexif
14:25:23 <bringert> are there a flag to cabal for setting thinks like include-dirs?
14:25:34 <bringert> s/a flag/flags/
14:25:47 <bringert> I should read what I type before hitting enter
14:28:30 <shapr> dcoutts_: I spoke too soon, haskell.org is using ancient versions of everything and policyd (and therefore greylisting) is not supported for postfix 2.0.x.
14:29:08 <xerox> bringert - I was about to ask wether you have wrote something to make all those same-looking pages for your programs/libraries, until I watched the very bottom line... hehe.
14:30:14 <shapr> Hm... the simple and evil hack is ... point the haskell.org MX to my own server and then route spamchecked mails back to haskell.yale.edu
14:30:28 <xerox> Maybe it will be a good idea to use that software, or something similar, in conjunction with HackageDB once we will have a good index of Haskell applications.
14:32:48 <jgrimes> bringert or shapr: whenever I try to access a compiled hope, it isn't recognizing it as a cgi for some reason; any ideas? 
14:33:20 <bringert> I was thinking of adding a hook to my darcs repo to make update the home page including making a release, building haddock, etc
14:33:35 <monochrom> Some .htaccess work is needed (assuming Apache server)
14:33:54 <monochrom> Or the easiest is to name the executable "whatever.cgi"
14:33:55 <bringert> jgrimes: have you added htaccess-cgi as the .htaccess file 
14:34:22 <bringert> jgrimes: are you installing Hope too?
14:34:23 <jgrimes> bringert, htaccess-fastcgi, yes
14:34:34 <jgrimes> bringert, yes
14:34:50 <bringert> and the name is .htaccess and and it is in the same dir as hope.fcgi?
14:34:56 <jgrimes> yep
14:35:01 <bringert> oh, are you using hope.cgi or hope.fcgi?
14:35:11 <jgrimes> hope.fcgi
14:35:20 <bringert> do you get anything in the log?
14:35:43 <bringert> try adding some gibberish to the .htaccess and check if it trips up the server
14:35:56 <bringert> if not, the server isn't seeing the .htaccess
14:36:04 <bringert> it could be configured not to
14:36:20 <jgrimes> bringert, well, it isn't putting anything in the log now. but a minute ago before I had mod_rewrite enabled, it was complaining about the .htaccess
14:36:29 <bringert> hmm
14:36:29 <jgrimes> so, I think it is seeing it.
14:36:42 <bringert> weird
14:36:56 <xerox> bringert: is HaXmL non-development-version okay?
14:36:57 <bringert> can you try a simple hello world shell script cgi?
14:37:01 <bringert> xerox: yes
14:37:05 <xerox> Great.
14:37:13 <jgrimes> bringert, yeah, one second
14:37:54 <shapr> dgoldsmith: Hiya, nice to see an apple.com hostname :-) Any questions I can help you with?
14:38:11 <shapr> Last month we had a google.com hostname, that was nifty.
14:38:15 <dgoldsmith> Just lurking for now. :-)
14:38:43 <bringert> and why have microsoft.com people too
14:38:46 <shapr> And we have long term members of #haskell working at yahoo.com too.
14:39:21 <bringert> eh, s/why/we/, I didn't mean that as a question
14:39:31 <xerox> cd tools; mv a.out  DtdToHaskell
14:39:33 <xerox> mv: a.out: No such file or directory
14:39:35 <xerox> -- grrr --
14:39:58 <bringert> xerox: you can install HaXml-1.13 with cabal I think
14:40:03 <shapr> dgoldsmith: If you have any questions, feel free to ask me or just the channel in general.
14:40:22 <dgoldsmith> shapr: Thanks!
14:40:30 <xerox> The problem happens during building... hmm.
14:40:47 <bringert> xoerx: when building with cabal?
14:40:51 <bringert> xerox that is
14:40:54 <xerox> Nope, with make.
14:41:01 <bringert> cabal worked for me
14:41:05 <xerox> With cabal dies for another reason.
14:41:11 <xerox> src/Text/PrettyPrint/HughesPJ.hs:1:0:
14:41:12 <xerox>     conflict: module `Text.PrettyPrint.HughesPJ'
14:41:12 <xerox>     belongs to the current program/library and also to package base-1.0
14:41:16 <bringert> ah, right
14:41:40 <bringert> rm -rf src/Text/PrettyPrint
14:41:44 <bringert> the use cabal
14:41:47 <bringert> then
14:41:48 <bringert> dammit
14:42:04 * xerox stares blankly
14:42:15 <bringert> that's what I did anyway
14:42:20 <xerox> And it worked.
14:42:35 <xerox> This way it doesn't install the tools, right?
14:42:57 <bringert> dunno
14:43:17 <xerox> I don't mind either way... hmm. HaskellDB now.
14:43:24 <xerox> (Last dependence!)
14:43:54 <bringert> xerox: you'd think so, did you install the deps for your HaskellDB driver? :-)
14:44:13 <xerox> Sigh, there is no _last_ dependence in life.
14:45:23 <xerox> developement version or release, bringert ? (:
14:45:33 <bringert> need devel HaskellDb
14:45:53 <xerox> Go go darcs!
14:46:05 <jgrimes> bringert, ok, I figured out what the problem was
14:46:15 <bringert> jgrimes: what was it?
14:46:37 <jgrimes> bringert, in the .htaccess I had to change the "AddHandler fastcgi-script .fcgi" to "AddHandler fcgid-script .fcgi"
14:46:47 <jgrimes> or remove it altogether, since it is also in my apache2.conf
14:47:04 <bringert> ah
14:47:19 <jgrimes> well, not directly in apache2.conf
14:47:34 <xerox> FastCGI is really Fast, over CGI?
14:47:36 <bringert> yeah, I put pretty much everything you need in the htaccess, may I should note that some things might already be set somewhere else
14:47:57 <bringert> xerox: it avoids the process creation overhead
14:48:14 <bringert> xerox: and Hope/FastCGI uses persistent database connections
14:48:15 <xerox> Is it difficult to implement, in general?
14:48:40 <xerox> I wanted to use reppie's httpd.hs, but it does CGI only.
14:49:31 <xerox> bringert - How is wxHaskell a backend for haskelldb?
14:49:34 <bringert> xerox: if you only want to run Haskell FastCGI programs in your web server, you can implement your own Haskell-based protocol
14:49:43 <bringert> xerox: bit-rotted probably
14:50:22 <bringert> xerox: NewCGI is pretty easy to interface from the outside, that's what the FastCGI lib does
14:50:56 <bringert> so you could us hs-plugins, or even compile the CGI app into the webserver
14:51:08 <xerox> Ah, I see.
14:51:25 <xerox> So I do need htoolkit in order to compile HaskellDB.
14:51:33 <bringert> only HSQL
14:51:42 <bringert> get the CVS version
14:52:47 <bringert> you can also use HDBC, but there is currently an issue with date types with HaskellDB/HDBC
14:53:17 <xerox> Checking out HSQL
14:53:25 <xerox> What's the difference, by the way?
14:54:36 <reppie> P=NP
14:55:52 <shapr> > let p = 1 ; np = 1 in p == np
14:55:53 <lambdabot>  True
14:56:39 <monochrom> Please don't abuse Haskell :)
14:56:50 * shapr grins
14:58:00 * xerox grins evilly
14:58:03 <xerox> > let n p = p in (\p -> p == n p) ()
14:58:04 <lambdabot>  True
14:58:25 * xerox starts laughing incontrollabily
15:02:17 <xerox> bringert - Can Hope simply use the fs as `backend' ?
15:02:39 <bringert> xerox: yes, kind of
15:02:46 <xerox> Oh.
15:02:49 <bringert> but that's very experimental
15:03:12 <bringert> and can give data loss with multiple users
15:03:26 <xerox> I'd very much like, in fact, over the SQL madness now.
15:03:39 <bringert> and doesn't really work with persistent database connections as used by HopeFastCGI
15:03:50 <xerox> (I wouldn't use FastCGI anyway.)
15:04:09 <xerox> Is it going to be supported better in the future, or not?
15:04:31 <bringert> xerox: if you are just playing around and you will be the only user, it could work
15:04:39 <bringert> xerox: hopefully
15:04:41 <xerox> Yes, that sounds good.
15:05:14 <bringert> xerox: switching between back-end is just a config change and a recompile + data migration if you want to keep the data
15:05:40 <bringert> xerox: if you want to try doing without a DB, use http://www.cs.chalmers.se/~bringert/darcs/haskelldb-flat/ as your DB driver
15:05:42 <lambdabot> The title of that page is "Index of /~bringert/darcs/haskelldb-flat"
15:05:45 <bringert> it's very rought
15:05:51 <bringert> rough
15:05:58 <bringert> but seems to work ok for small tests anyway
15:06:27 <bringert> hmm I should cabalize that
15:06:39 <xerox> So I still need HSQL/HaskellDB, plus that
15:06:46 <bringert> not HSQL
15:06:53 <bringert> just HaskellDB + that
15:07:06 <bringert> if you give me a few minutes I will cabalize it
15:07:11 <xerox> Sure!
15:07:15 * xerox goes getting a drink
15:27:09 <xerox> bringert - I really was asking how come that a GUI lib is a SQL backend, but...
15:27:15 <bringert> ha
15:27:17 <bringert> ah
15:27:41 <bringert> wxHaskell is a binding to wxWidgets, which includes an ODBC interface for some reason
15:27:49 <bringert> I think QT does that too
15:28:19 <xerox> Oh, I see!
15:28:29 <xerox> Any luck with haskelldb-flat ?
15:29:18 <bringert> xerox: cabalized in darcs, current hope darcs has config example, I'm working on a tool for creating an empty FlatDB database right now
15:29:42 <bringert> cause there is no way to do that with out running ghci and finding the right functions
15:29:58 <bringert> I'm the only person who ever used it
15:29:59 <bringert> '
15:30:26 <bringert> shapr: hope has untested range limiting in blob now
15:30:37 * xerox hops happily
15:31:28 <darrint_> anyone know how to use hopengl readpixels? 
15:38:27 <bringert> xerox: ok, now there is a flatdb-create tool in haskelldb-flat
15:38:51 <bringert> pull hope and see Config.hs for setup instructions
15:39:00 * xerox does that
15:39:40 <bringert> you can install haskelldb-flat including flatdb-create using cabal
15:39:58 <mauke> why is there no select() in haskell?
15:49:36 <dcoutts> shapr, we might be able to persuade the haskell.org admins to upgrade postfix
15:49:43 <SamB> mauke: because the library has stolen it!
15:49:45 * xerox is nearly there
15:49:57 <SamB> or actually, the RTS
15:50:11 <SamB> you are supposed to use threads, anyway ;-)
15:50:22 <mauke> SamB: I want to write my own threads
15:50:33 <dcoutts> mauke, there's a nice paper on that
15:50:38 <SamB> well, tough -- the implementors stole select for *theirs*
15:50:39 <xerox> Compiling hope.
15:50:58 <dcoutts> mauke, it's quite possible and quite useful
15:51:07 <mauke> dcoutts: do you have a name/url?
15:51:13 * xerox want to know too
15:51:15 * dcoutts looks
15:51:44 <David_Feuer> I finally figured out how to write the search function for a 2-3 tree written to express the balance invariant in the type system.
15:51:54 <David_Feuer> Next challenge: insert.
15:52:01 <xerox> Woopee, I have a hope.cgi!
15:52:25 <cyyoung> has anyone gotten around to writing a library for doing affine arithmetic in haskell?
15:52:31 <dcoutts> mauke, xerox, "A Language-based Approach to Unifying Events and Threads"
15:52:38 <xerox> Ah, that one.
15:52:39 <dcoutts> @google A Language-based Approach to Unifying Events and Threads
15:52:41 <lambdabot> http://lambda-the-ultimate.org/node/1435
15:54:09 <xerox> bringert - I am not supposed to run createdb, am I?
15:54:24 <bringert> xerox: yes, you are
15:54:29 <bringert> after flatdb-create
15:54:58 <xerox> bringert - It takes an argument like flatdb-create, or should I run it in the same directory?
15:55:10 <xerox> (...of the db, I mean.)
15:55:13 <bringert> same dir as hope.cgi
15:55:22 <bringert> xerox: SyntaxNinja says hi
15:55:29 <bringert> he's standing beside me
15:55:34 <David_Feuer> Cale, ping.
15:55:37 * xerox waves to Isaac
15:55:42 <xerox> Hello man! :)
15:56:11 <David_Feuer> @seen Cale
15:56:11 <lambdabot> Cale is in #haskell. I last heard Cale speak 4 hours, 12 minutes and 54 seconds ago.
16:03:10 <xerox> bringert - How does one add a user? (:
16:05:15 <bringert> click add user
16:06:00 <xerox> Simpler said that done...
16:06:29 <xerox> Found the url manually.
16:10:03 <bringert> it should be under users
16:10:51 <xerox> In the default homepage?
16:11:18 <xerox> Howdy Pseudonym!
16:11:19 <bringert> xerox: should be
16:11:22 <bringert> maybe I brok it
16:11:24 <bringert> broke
16:11:25 <Pseudonym> G'day!
16:11:26 <xerox> I have only "Log In"
16:11:29 <Pseudonym> Woohoo, enthusiasm!
16:11:42 <bringert> I probably broke it then
16:11:55 <xerox> bringert - What is the polocy for making users, exactly?
16:12:18 <bringert> you mean who can create users?
16:12:25 <xerox> Yes.
16:13:02 <bringert> canAddUser = noUsers `orM` hasPermission UserAdd
16:13:31 <xerox> Great.
16:14:17 <xerox> 500 Internal Server Error
16:14:18 <xerox> Prelude.read: no parse
16:14:19 <xerox> eeek ! :)
16:14:24 <xerox> ...you said that... :)
16:14:35 <bringert> hmm
16:14:49 <bringert> what did you do to get that?
16:15:00 <xerox> I did new entries, but never saved the,
16:15:02 <xerox> *them
16:15:10 <xerox> And clicked elsewhere
16:15:13 <SamB> aww. no instance for Show MozEmbed.
16:15:21 <bringert> hmm
16:15:36 <bringert> I have commited some untested stuff, maybe I shouldn't have done that
16:16:23 <xerox> Hmm.
16:16:26 <xerox> Again.
16:21:50 <xerox> *boom*
16:35:46 <xerox> OK, running again.
16:38:31 <bringert> xerox: did you get it working?
16:38:40 <xerox> Yes.
16:38:49 <bringert> I'm going to get on a train soon, I can hopefully do some testing there
16:38:52 <xerox> Where has to be put the styles/ files?
16:39:21 <bringert> xerox: make installball-cgi
16:39:28 <bringert> see INSTALL
16:39:31 <xerox> Nevermind.
16:43:37 <xerox> It runs :)
16:45:11 <xerox> I want to do a LaTeX module :-)
16:46:42 <rashakil_> I have started using an operator # where (#) = fmap, which I use like a version of ($) that dips under monads.  Have you wanted to do this or seen it done, and is there a typical name that people commonly use for this?  Or do you all just use do all the time?
16:47:52 <mauke> I normally use liftM or my own >>+ operator
16:48:27 <mauke> (>>+) = flip liftM
16:49:52 <xerox> ?type flip liftM
16:49:54 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
16:50:50 <mauke> ?type \f x -> return f `ap` x
16:50:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
16:53:20 <bringert> xerox: have fun
16:53:35 <xerox> Trying image uploading now
16:53:50 <bringert> I should better support for extensible markup
16:54:47 <xerox> It spits a *lot* in error_log
16:55:51 <bringert> what sort of stuff?
16:56:07 <xerox> shows of Project
16:57:09 <xerox> Let me paste
16:57:45 <xerox> http://rafb.net/paste/results/q8sJw714.html
16:59:31 <xerox> (On image upload, it uploads the image, do the thumbnails, but shows "Empty.")
17:07:19 <bringert> xerox: it's probably the bug shapr found, images only show if they have an EXIF date
17:07:24 <bringert> gotta go to my train
17:07:28 <bringert> bye
17:07:37 <xerox> See you!!!
17:07:43 <xerox> ?karma+ bringert
17:07:43 <lambdabot> bringert's karma raised to 1.
17:33:29 <LordBrain>  i usually have used liftM too... but when I think about it, i'm not sure why liftM would be preferable to fmap
17:34:21 <LordBrain> fmap is more general, so wouldn't it be better to use fmap? 
17:35:12 <mauke> liftM is more specific, so wouldn't it be better to use liftM?
17:35:14 <LordBrain> is liftM easier for people to understand?
17:36:43 <LordBrain> well, i've read its a good idea to try to program for monads without specifying which monad if possible, thereby making a more useful function, wouldn't the same principle apply here? if i use fmap, i could be so general it might not be a monad but rather just a functor
17:37:22 <Pseudonym> Surely that depends what you're using it for.
17:37:29 <LordBrain> yeah
17:37:39 <mauke> monads aren't required to implement fmap
17:37:54 <LordBrain> in the case wehre fmap would grant me nothing, should i then just use liftM as it's more documenting?
17:38:08 <LordBrain> i'm not really sure it is more documenting
17:38:32 <LordBrain> i suppose it's another hint we're working with a monad..
17:38:56 <LordBrain> yeah, its probably easier conceptually
17:39:02 <mauke> liftM/liftM2 looks better than fmap/liftM2
17:39:05 <Pseudonym> More general types are more useful, but more restrictive types are better documentation.
17:39:14 <Pseudonym> It really depends what you're doing.
17:39:16 <Pseudonym> Consider:
17:39:18 <Pseudonym> f (a,b) = a
17:39:28 <Pseudonym> The most general type is (a,b) -> a
17:39:48 <Pseudonym> And if your function is called fst, that's the type you should give it.
17:40:09 <Pseudonym> But if the name of the fucntion is getId, then you should use aless general type.
17:40:14 <Pseudonym> e.g. Record -> Id
17:40:22 <Pseudonym> where type Record = (Id,MoreData)
17:40:27 <LordBrain> yeah
17:42:09 <LordBrain> plus, if your program doesn't use the concept of a functor at all (except that it uses monads) then throwing fmap in there would just add another abstraction for the human reader to be aware of.. And of course, there is always the advantage the type inference catching more errors.
17:44:09 <LordBrain> arguably a functor is a simpler concept tho
17:44:26 <Pseudonym> Well, yes.  In category theory, all monads are functors.
17:44:43 <Pseudonym> This is a known problem with the Haskell type system, BTW.
17:44:54 <LordBrain> what's the problem?
17:44:57 <Pseudonym> All monads should support fmap, but fmap might be easier to express in terms of the monad operations.
17:45:07 <Pseudonym> But there's no real way to say that nicely.
17:45:16 <Pseudonym> To give a default "fmap" implementation in terms of the monad operations.
17:46:01 <LordBrain> by monad operations, you are including liftM?
17:46:13 <LordBrain> or you mean the primitive ones?
17:46:50 <Pseudonym> I mean the primitive ones, yes.
17:46:52 <Pseudonym> return and bind.
17:47:18 <mauke> instance (Monad m) => Functor m where fmap f m = do { x <- m; return (f x) }
17:47:54 <Pseudonym> Inheritance inversion, yuck.
17:48:05 <Pseudonym> In theory, class (Functor m) => Monad m
17:48:27 <Pseudonym> Every monad is a functor.
17:48:47 <LordBrain> but... i thought that's what that instance statement just said
17:49:26 <Pseudonym> Suppose you want this: class (Functor m) => Monad m
17:49:32 <LordBrain> m is a monad implies m is a functor where...
17:49:39 <Pseudonym> Then you need to declare a Functor instance _before_ you declare a Monad instance.
17:49:50 <Pseudonym> So you can't define fmap in terms of return and (>>=)
17:50:07 <Pseudonym> Ideally, you should be able to say something like this:
17:50:13 <Pseudonym> class (Functor m) => Monad m where
17:50:21 <Pseudonym>     return :: a -> m a
17:50:31 <Pseudonym>     (>>=) :: m a -> (a -> m b) -> m b
17:50:40 <Pseudonym>     fmap = {- etc -}
17:50:52 <Pseudonym> So that declaring a Monad instance automatically declares the Functor instance.
17:51:11 <Pseudonym> By giving an implementation for fmap.
17:52:55 <SamB> so how to spell gtk_menu_popup in Haskell...
17:53:46 <LordBrain> hmm.. i'm satisfied with the instance declaration solution.. but thats just me.. is this something people are actually working on?
17:53:57 <Pseudonym> You spell it "Raymond Luxury-Yacht", but pronounce it "Throat Warbler-Mangrove".
17:54:16 <Pseudonym> LordBrain: Ask the haskell-prime people.
17:54:24 * SamB hits Pseudonym with a frying pan
17:54:29 <Pseudonym> It's possible that this would have unintended consequences.
17:54:56 <Pseudonym> Seemingly innocent changes to the type system often have unintended consequences, like making type checking undecidable.
17:55:16 <SamB> well, seeing as it is an imiginary frying pan, it shouldn't have too many unintended consequences
17:55:35 <Pseudonym> I could get imaginary concussion.
17:57:01 <LordBrain> hmmmmm.. a sociologist once stated in a book i read.. that violence in art is more or less proportional to violence in the culture... but then that's not to say eliminating violence in art would pacify the culture..
17:57:52 <LordBrain> so, i'm not sure the imaginary frying pan does have unintended consequences...
17:57:52 <Pseudonym> One of the big myths of art is that art changes the world.
17:58:04 <Pseudonym> I don't think there is a single work of art that has changed the world.
17:58:14 <Pseudonym> Art changes art.  And art reflects the world.
17:58:26 <Pseudonym> Possibly in a better way than most things.
17:58:26 <mwolak> do you count literature as art?
17:58:33 * Pseudonym thinks
17:58:34 <Pseudonym> Yes.
17:58:36 <LordBrain> well reflecting the world might be an unintended consequence i suppose
17:58:48 <Pseudonym> It could be a very shiny imaginary frying pan.
17:58:53 <LordBrain> lol
17:59:33 <Dino_> shapr: That neg slice, you can do that in Perl.  ('a'..'z')[-5..-1] -> 'vwxyz
18:00:35 <LordBrain> this same person went on to elaborate about ancient cultures for which are striking in the respect that almost none of their art contains any violence at all.
18:00:44 <mwolak> if I want SMP goodness, I have to use ghc 6.5 or wait for 6.6, right?
18:01:47 <LordBrain> what's SMP?
18:02:06 <sylvan> Symmetric MultiProcessing
18:02:11 <mwolak> multiprocessing
18:02:15 <Pseudonym> @vera smp
18:02:16 <lambdabot> *** "smp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:02:17 <lambdabot> SMP
18:02:17 <lambdabot>    Software Motion Picture (DEC)
18:02:17 <lambdabot>  
18:02:17 <lambdabot> *** "smp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:02:18 <lambdabot> [11 @more lines]
18:02:23 <Pseudonym> @more
18:02:23 <lambdabot> SMP
18:02:23 <lambdabot>    Symmetric MultiProcessor [system] (SMP)
18:02:24 <lambdabot>  
18:02:26 <lambdabot> *** "smp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:02:28 <lambdabot> SMP
18:02:30 <lambdabot> [6 @more lines]
18:02:34 <Pseudonym> @more
18:02:34 <lambdabot>    Symmetrisches MultiProzessor [system]
18:02:36 <lambdabot>  
18:02:38 <lambdabot> *** "smp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
18:02:40 <lambdabot> SMP
18:02:42 <lambdabot>    System Modification Program
18:02:44 <lambdabot>  
18:02:48 <Pseudonym> There you go.
18:02:54 <mwolak> like everything else, it sounds more awesome in german
18:02:58 <Pseudonym> Yeah.
18:03:07 <Pseudonym> The Germans have a single word for just about any concept.
18:03:13 <LordBrain> lol
18:03:13 <Pseudonym> And if not, they can invent one.
18:05:12 <banshee412> I'm trying to process a file one line at a time and I'm having trouble figuring out loops. What is the proper way to do something like that in haskell?
18:05:49 <mwolak> mapM?
18:06:32 <mauke> banshee412: what kind of loop?
18:06:38 <mauke> do you need to keep state?
18:07:17 <banshee412> well I need to read a line, put it through a function, read the next line and so on
18:07:22 <Pseudonym> What is this "loop" of which you speak?
18:07:29 <Pseudonym> @type readFile
18:07:30 <lambdabot> FilePath -> IO String
18:07:35 <Pseudonym> @type lines
18:07:36 <lambdabot> String -> [String]
18:08:00 <Pseudonym> @type fmap lines . readFile
18:08:02 <lambdabot> FilePath -> IO [String]
18:08:04 <Pseudonym> There you go.
18:08:36 <Dino_> If the file is ridiculous large and you don't want to load 'er all up in mem, can you process the lines one at a time?
18:08:36 <Pseudonym> Lazy list of lines.  You can now do what you like with them.
18:08:47 <Pseudonym> Sure.
18:08:52 <Pseudonym> Lazy evaluation rules.
18:09:03 <mauke> main = interact (unlines . map a_function . lines)
18:09:06 <jer> so what happens if the file disappears?
18:09:08 <xerox> ?yow
18:09:08 <lambdabot> Are you selling NYLON OIL WELLS??  If so, we can use TWO DOZEN!!
18:09:11 <Dino_> Ok, so it's all actually doing that, even through the readFile (not really read-fully at all).
18:09:29 <Pseudonym> jer: Under an inode-based filesystem, nothing.
18:09:32 <mauke> jer: what do you mean by "disappear"?
18:09:45 <Pseudonym> Opening a file keeps the inode active.
18:09:56 <jer> Pseudonym, right, unless the inode is overwritten with other data
18:09:58 <xerox> Ops.
18:10:10 <Pseudonym> Under a legacy filesystem (e.g. NTFS), you generally can't delete a file that someone else has open.
18:10:34 <Pseudonym> jer: Sorry?  You can't overwrite an inode that someone is holding open.
18:10:40 <jer> that is; in your haskell code you readLine ... all that jazz, get your lazy list of results; then the file goes bye bye sometime between when you "finished" reading the data in and when you want it, and something else was put in place over that inode
18:10:40 <xerox> shapr - ping
18:10:41 <Pseudonym> At worst, you can only modify it.
18:10:56 <jer> Pseudonym, so haskell maintains a lock on a file until you do something with that data?
18:10:59 <Pseudonym> I suppose it could be NFS mounted and the server could disappear.
18:11:04 <jer> if that'st he case, *ICKY*
18:11:11 <Pseudonym> In which case you get an exception thrown.
18:11:19 <Dino_> I'm thinking that the file is still open as long as that readFile is involved in being evaluated with everything else.
18:11:20 <Pseudonym> Now, this is an issue with lazy I/O.
18:11:38 <Pseudonym> jer: Yes, the file stays open until you close it.
18:11:47 <Pseudonym> Which could be because the data is garbage collected.
18:11:57 <jer> Pseudonym, so what if you close it, is your lazy list of lines evaluated then?
18:12:09 <Pseudonym> jer: Look at the type of readFile.
18:12:11 <jer> if it's not, how does it know what's actually in the list?
18:12:17 <jer> Pseudonym, i saw the type of readFile
18:12:17 <Pseudonym> It doesn't take a file handle.
18:12:20 <Pseudonym> You can't close it.
18:12:25 <LordBrain> i have found interact behaves differently in ghc and hugs
18:12:25 <Pseudonym> It takes a file NAME.
18:12:45 <jer> let me start over and try and explain this better then since you obviously think i'm saying something i'm not
18:12:49 <Pseudonym> That's critical.  If it took a file handle, then yes, you could close it.
18:12:55 <Pseudonym> OK
18:13:12 <Pseudonym> To answer the question I think you're asking: Yes, you can get I/O exceptions in readFile.
18:13:16 <Pseudonym> And no, they're not elegant.
18:13:28 <Pseudonym> Because in general they get thrown from a random place.
18:13:34 <jer> Pseudonym, you do what Dino_ wants, and you get a lazy list of lines of that file.. now the readFile function has finished, so presumably it has closed the file handle, or does it keep it open?
18:14:00 <Pseudonym> When it finishes reading the file, it closes the file handle, yes.
18:14:02 * jer has a second part to this, but i want to verify assumptions before continuing
18:14:30 <jer> Pseudonym, okay, so how can the list be lazy if the file handle is gone? that is, does it open up the file again when you go to access an element at index N (where N is somewhere between the front and the end of the list)
18:14:33 <Pseudonym> I'm 99% certain that when you evaluate the empty list at the end of readFile, you can be sure the file is closed.
18:15:11 <jer> okay, so there's a chance that an attacker could replace your file with some other data, and then readFile will like a dolt read a particular line of that file at an arbitrary point in time, right?
18:15:20 <Pseudonym> Sure.
18:15:26 <jer> urgh
18:15:33 <jer> that's not cool
18:15:34 <Pseudonym> But that's true in any I/O scenario.
18:15:37 <mauke> same for line-based reading in C or whatever
18:15:46 <Pseudonym> Anyone can concurrently modify a file that you're reading.
18:16:21 <LordBrain> unless its locked..
18:16:30 <Pseudonym> File locking is advisory in Unix.
18:16:42 <mauke> a lock just prevents other locks
18:16:55 <Pseudonym> And it doesn't work reliably over NFS anyway.
18:16:57 <LordBrain> hmm thats a good point mauke which i had momentarily forgotten
18:17:08 <jer> my concern is that you could read the lines in a file, save that lazy list of lines of that file and then your program may run for a week before accessing any data in that list; by then the file could be replaced with something else
18:17:12 <jer> atl eas
18:17:15 <jer> aterr
18:17:17 <petekaz> didn't sysV provide mandatory locking with some bit in the file mask?
18:17:23 <LordBrain> the lock wont really gaurd you against an attacker.. it only stops nice programs from causing disasters
18:17:29 <jer> at least in C, you'd have to save the data at the time you read it, and then you use it a week later, it's the data as of one week prior
18:17:40 <Pseudonym> jer, my first comment is that if you don't access any of the data, it doesn't get read.
18:17:49 <Pseudonym> Well, if you don't access any of the cons cells, anyway.
18:17:51 <jer> Pseudonym, I KNOW; that's my concern
18:18:08 <Excedrin> you can achieve that in Haskell easily
18:18:21 <jer> i suppose you could write a recursive function to look at each element in the list just to make sure the list you have has been evaluated already
18:18:26 <Excedrin> re, strictly reading a file's contents
18:18:31 <jer> but that seems like hoop jumping for no reason =/
18:18:33 <Pseudonym> It _is_ true that readFile isn't a good idea in general.
18:18:38 <SamB> @google inurl:gtk2hs inurl:doc uiManager
18:18:40 <lambdabot> http://rpmfind.net/linux/RPM/fedora/devel/x86_64/gtk2hs-doc-0.9.10-1.fc6.x86_64.html
18:18:44 <Pseudonym> Because of the way it delivers exceptions.
18:19:04 <Pseudonym> It's useful for small uses.
18:19:10 <Pseudonym> Not for industrial-strength uses.
18:19:13 <LordBrain> that's why people use bracket ...
18:19:15 <LordBrain> ?
18:19:50 <Dino_> On a somewhat related note, I see that there's System.Posix.Temp.mkstemp
18:19:53 <Pseudonym> bracket serves a number of purposes, but yes.
18:19:54 <xerox> ?google uiManager site:haskell.org/gtk2hs
18:19:55 <lambdabot> http://www.haskell.org/gtk2hs/docs/current/doc-index-U.html
18:21:31 <mauke> great, I still don't understand why there's no System.Posix.IO.select
18:21:48 <xerox> mauke, sigh.
18:23:07 <xerox> @tell shapr What are your insights about hope's bug wrt images (without EXIF tags)? Danke!
18:23:08 <lambdabot> Consider it noted.
18:23:15 <xerox> Goodnight chaps.
18:23:33 <LordBrain> hmmmm, i would have thought.. that to ensure a list has been completely evaluated, all that would be necessary is to read the last element
18:23:34 <Pseudonym> Night.
18:24:00 <LordBrain> is that an unsafe assumption on my part?
18:24:46 <SamB> how am I supposed to make popup menus?
18:25:51 <Pseudonym> LordBrain: Yes and no.
18:26:09 <Pseudonym> Obviously all the cons cells will be evaluated.
18:26:13 <Pseudonym> But the elements may not be.
18:26:20 <Pseudonym> > [undefined,2] !! 1
18:26:21 <lambdabot>  2
18:26:32 <LordBrain> SamB, did you search that website xerox triggored lambdabot to post
18:26:33 <Pseudonym> Clearly, the "undefined" is not evaluated.
18:26:39 <Pseudonym> > [undefined,2] !! 0
18:26:40 <lambdabot>  Undefined
18:27:22 <LordBrain> hmmm
18:27:24 <LordBrain> ok
18:29:11 <mwolak> does anyone have any words of advice/warning for calling a really statefull C++ library from haskell?
18:29:39 <SamB> LordBrain: the website does not say *how*, but merely *what*
18:29:42 <Pseudonym> Yes, shoot the programmer who made the library.  They obviously can't write competent C++.
18:30:01 <Pseudonym> Just kidding.  Embed it in the IO monad.
18:30:01 <SamB> in the foot!
18:30:04 <mwolak> :P
18:30:34 <Pseudonym> Seriously, a stateful C++ library is just plain wrong unless it's controlling a nonsharable physical resource, like OpenGL.
18:30:36 <mwolak> does greencard automatically deal with C++, or do I have to extern c stuff myself?
18:30:53 <Pseudonym> Or I/O
18:30:53 <mwolak> (it is! irrlicht game 3d engine)
18:31:01 <Pseudonym> Ah.  OK, then.
18:31:10 <Pseudonym> See the Haskell SDL binding for inspiration.
18:31:24 <mwolak> ahh, thanks
18:39:56 <LordBrain> SamB, i have code which pops up a window.. it might not be a "popup window"... i'm guessing thats not what you want right?
18:40:08 <SamB> probably not,
18:40:18 <SamB> I guess I'll just build my menu manually...
18:41:15 <LordBrain> by popup, do you mean something which pops up in the menu and lets you select an option? or do you mean something that pops-up on the screen and maybe gives a once read message or something?
18:41:52 <LordBrain> from my reading.. the uiManager creates menus from xml
18:42:20 <vincenz> Cale: ping
18:42:51 <LordBrain> SamB: have you looked at the C documentation for Gtk?
18:43:37 <SamB> hmm, perhaps I should look at the C documentation about <popup>
18:43:55 <SamB> but I don't want to spend forever just staring at docs and never getting anything done, so I won't
18:44:11 <LordBrain> yeah i meant just the specific part you want
18:44:28 <LordBrain> i think its more thurough
18:45:28 <LordBrain> tho i still dont know what we mean by popup 
18:46:09 <LordBrain> i can think of a right-click menu...
18:46:13 <LordBrain> is that a popup?
18:46:34 <SamB> that is what I want, yes
18:46:54 <SamB> right now I'm working on building the menu
18:54:04 <LordBrain> SamB: I found this, it's in C, but maybe that would be helpful, i dont know.. http://www.gtk.org/faq/#AEN670
18:54:17 * SamB looks
18:54:45 <SamB> the code is ugly at right now :-(
18:57:02 <SamB> hmm, how am I supposed to attach the menu to the widget?
18:57:19 <SamB> and how am I supposed to pop up a menu if I have one of Mozilla's wierd event objects?
18:58:22 <LordBrain> i'm just as clueless if not more than you on all this.. i'm just searching..  I keep seeing the word "activate" what does that mean?
18:58:44 <SamB> I think that means like when you click on an item, but I'm not sure
18:58:46 <LordBrain> "A Menu is most commonly dropped down by activating a MenuItem in a MenuBar or popped up by activating a MenuItem in another Menu."
18:59:24 <LordBrain> "A Menu can also be popped up by activating a OptionMenu. Other composite widgets such as the Notebook can pop up a Menu as well."
18:59:58 <LordBrain> "Applications can display a Menu as a popup menu by calling the menuPopup function. "
19:00:50 <SamB> dcoutts: heeeelp! I have no Event to pass to menuPopup!
19:01:07 <LordBrain> this is what i am posting from.. you've probably already seen it.. http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-MenuComboToolbar-Menu.html
19:01:53 <SamB> yeah
19:04:10 <LordBrain> SamB, could you pass it the map event?
19:04:21 <SamB> what event?
19:04:35 <SamB> the only event I have is some funky XPCOM object
19:04:59 <SamB> which I hold onto as a "Ptr a", which is about the same as a void*
19:06:23 <LordBrain> so.. you have a window and you want the user to right click on that window and see a popup menu?
19:06:36 <SamB> a MozEmbed, actually
19:06:46 <LordBrain> well i havent done anything with those..
19:06:57 <SamB> and really its more like the user might right click and want to see a context menu
19:07:03 <LordBrain> yeah
19:07:22 <SamB> really, the author of MozEmbed should be shot... or made to finish that job, his choice.
19:07:22 <LordBrain> so, the MozEmbed has to respond to the click event
19:07:34 <LordBrain> haha
19:08:09 <SamB> you have to use C++ to make it actually do what you want, I think
19:08:46 <LordBrain> what are you making any how?
19:08:58 <LordBrain> mozEmbeds are like plugins?
19:09:26 <SamB> oh, I'm just trying to add browser widget context menus to the Inform 7 IDE for Linux
19:09:32 <SamB> so that the user can go back and whatnot
19:09:39 <SamB> mostly back, though
19:10:01 <SamB> hmm, strangely my code seems to have compiled?
19:10:15 <SamB> wait
19:10:25 <SamB> oh good, it didn't.
19:10:59 <Pete_I> i'd think that's a bad thing.
19:11:43 <SamB> well, if I don't feel like I've finished all that I've begun, my code shouldn't compile ;-)
19:18:59 <SamB> I don't suppose anyone here knows how to use arch?
19:19:46 <Dino_> SamB: Do you mean the Haskell I7 IDE?
19:19:58 <SamB> Dino_: of course!
19:20:26 <SamB> what other I7 IDE do you know of that is written in Haskell?
19:20:28 <Dino_> Did you write it, or is the source out there already?
19:20:36 <SamB> source is out already
19:21:19 <SamB> If I had written it, I would hardly need to use arch to submit a patch ;-)
19:21:27 <SamB> http://www.thewhitelion.org/inform7/
19:21:28 <lambdabot> The title of that page is "I7 for Linux"
19:21:37 <Dino_> See, there it is again. Person sits down and decides to do something with Haskell. Work progresses scary ass fast.
19:22:25 <SamB> I dunno how much has happened in the past month, but initially yes ;-)
19:23:32 <Dino_> haha: "If you have used Haskell, I'm sorry about what I did to it."
19:23:35 <dons> moin
19:23:37 <SamB> okay, so, I just made up an event "Event False"
19:23:53 <Dino_> Hello dons.
19:23:53 <SamB> well, I think my code is going to look worse than his code, so I don't know what his problem is
19:28:44 * SamB wonders if the people in #darcs would be more able to help him with arch than those in #arch
19:28:59 <David_Feuer> I just had a yucky sort of thought....
19:30:44 <dfeuer> The obvious way to represent nodes in a (nested) 2-3 tree is data Node d a = Node2 a d a | Node3 a d a d a
19:30:50 <banshee412> so I am still having trouble with this file processing stuff. This is what I have readFile "codes.txt" >>= \codes -> interact(unlines . map runIt . lines)
19:31:21 <Korollary> banshee412: you don't refer to codes in the body of the lambda
19:31:39 <dfeuer> But I'm thinking it'd be a little faster if it were data Node d a = Node a d a (Maybe (d,a))
19:31:51 <banshee412> yeah, I was confused as to where it would go
19:31:52 <dfeuer> With some strictness annotations.
19:32:15 <dfeuer> So when taking the left branch, there's no need to check the tag.
19:33:41 <banshee412> Korollary: where should I put the file handle so that it is used in the function?
19:33:52 <SamB> hmm, I apparantly need to send a button event
19:34:05 <dfeuer> Nobody listens to me :-(
19:34:14 <SamB> er, synthesize
19:34:15 <Korollary> banshee412: You don't need a file handle. Are you ok with the do-syntax?
19:35:01 <banshee412> Korollary: I guess. I pretty have no clue what I am doing though. This is still pretty new to me
19:35:49 <vincenz> > insert 1 [1..10]
19:35:51 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10]
19:35:59 <dons> i suspect you don't need that interact there, banshee412 
19:36:28 <dons> or do you really want to read from stdin?
19:36:36 <vincenz> > splitAt 2 [1..10]
19:36:38 <lambdabot>  ([1,2],[3,4,5,6,7,8,9,10])
19:36:40 <vincenz> @join #oasis
19:36:49 <dons> readFile "codes.txt" >>= putStr . unlines . map runIt -- perhaps
19:36:55 <dons> readFile "codes.txt" >>= putStr . unlines . map runIt .lines -- perhaps
19:38:05 <vincenz> hiya dons
19:39:00 <dfeuer> @seen Cale 
19:39:01 <lambdabot> Cale is in #haskell. I last heard Cale speak 7 hours, 55 minutes and 44 seconds ago.
19:39:55 <banshee412> dons: that looks like it worked. one question, what does a period mean?
19:40:15 <dons> its functoin compositoin
19:40:30 <dons> > map . filter (/='e') $ "heskell"
19:40:31 <lambdabot>  Couldn't match `a -> b' against `[a1]'
19:40:36 <dons> > map toUpper . filter (/='e') $ "heskell"
19:40:37 <lambdabot>  "HSKLL"
19:40:49 <dons> > map toUpper (filter (/='e') "heskell")
19:40:50 <lambdabot>  "HSKLL"
19:41:27 <dons> > let a = filter (/='e') "heskell" in map toUpper a
19:41:28 <lambdabot>  "HSKLL"
19:43:06 <ruffneck> pjö3~óifs
19:47:03 <vincenz> @hoogle fold
19:47:03 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
19:47:04 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
19:47:04 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
19:47:04 <vincenz> @hoogle foldM
19:47:05 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
19:47:05 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:47:05 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
20:03:12 <dtribble> Hi.  I was wondering if there is a Haskell implementation that takes advantage multicore procecssors?
20:03:30 <dons> sure. ghc 6.5
20:03:47 <dtribble> thanks!
20:04:45 <dons> ?wiki GHC/Concurrency
20:04:45 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Concurrency
20:04:48 <dons> ^^ here
20:04:58 * dtribble follows links
20:05:16 <dons> "As of version 6.5, GHC supports running programs in parallel on an SMP or multi-core machine."
20:14:17 <vincenz> \o/
20:14:39 <vincenz> brb
20:17:01 <vincenz> re
20:17:10 <vincenz> re
20:24:49 <vincenz> Cale: ping
20:25:27 <vincenz> araujo: ping
20:26:06 <Coldhak> i'm getting a "due to bad layout" error, but i don't see it.
20:26:11 <Coldhak> http://sial.org/pbot/17741 what's wrong?
20:26:13 <lambdabot> The title of that page is "Paste #17741 from "Pete_I" at 69.19.20.62"
20:28:53 <vincenz> Pete_I: first of all... your stuff should be defined in a module
20:28:59 <vincenz> module Main where ...
20:29:40 <Pete_I> ok, i didn't know that.
20:29:57 <Pete_I> thanks.
20:31:35 <vincenz> secondly
20:31:40 <vincenz> your main is missing a ) at the end
20:31:46 <vincenz> third, don't import OI
20:31:48 <vincenz> no need for ths
20:42:36 <Pete_I> vincenz, thanks for the input. it works :)
20:51:05 <vincenz> np
21:07:29 <vincenz> Could anyone explain me the diff between call-by-name and call-by-need?
21:15:36 <jer> vincenz, http://en.wikipedia.org/wiki/Call_by_need#Call_by_name <-- call by need is right below that
21:16:33 <dons> @foldoc call-by-need
21:16:34 <lambdabot> *** "callbyneed" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
21:16:34 <lambdabot> call-by-need
21:16:34 <lambdabot>  
21:16:34 <lambdabot>     <reduction> A {reduction strategy} which delays evaluation of
21:16:34 <lambdabot>     function arguments until they are needed because they are
21:16:36 <lambdabot> [10 @more lines]
21:16:41 <dons> @more
21:16:42 <lambdabot>     arguments to a {primitive} function or a conditional.
21:16:42 <lambdabot>     Call-by-need is one part of {lazy evaluation}.
21:16:42 <lambdabot>  
21:16:44 <lambdabot>     The term first appears in Chris Wadsworth's thesis "Semantics
21:16:46 <lambdabot>     and Pragmatics of the Lambda calculus" (Oxford, 1971, p. 183).
21:16:48 <lambdabot> [5 @more lines]
21:16:54 <dons> @more
21:16:54 <lambdabot>     It was used later, by J. Vuillemin in his thesis (Stanford,
21:16:55 <lambdabot>     1973).
21:16:56 <lambdabot>  
21:16:58 <lambdabot>     (1995-05-27)
21:17:00 <lambdabot>  
21:17:13 <dons> @foldoc call-by-name
21:17:14 <lambdabot> *** "callbyname" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
21:17:14 <lambdabot> call-by-name
21:17:14 <lambdabot>  
21:17:14 <lambdabot>     (CBN) (Normal order reduction, leftmost, outermost reduction).
21:17:14 <lambdabot>     An argument passing convention (first provided by {ALGOL 60}?)
21:17:16 <lambdabot> [19 @more lines]
21:17:22 <dons> @more
21:17:22 <lambdabot>     where argument expressions are passed unevaluated.  This is
21:17:23 <lambdabot>     usually implemented by passing a pointer to some code which
21:17:23 <lambdabot>     will return the value of the argument and an environment
21:17:24 <lambdabot>     giving the values of its {free variable}s.  This {evaluation
21:17:26 <lambdabot>     strategy} is guaranteed to reach a {normal form} if one
21:17:28 <lambdabot> [14 @more lines]
21:17:55 <dons> oh well. foldoc is often beter than wikipedia for defns , i've found
21:18:03 <dons> better
21:19:21 <jer> dons, if he wanted the etymology then that description is better; otherwise i think in this case, the wikipedia description is better
21:19:34 <jer> but normally, i'd agree with you =]
21:19:36 <vincenz> thx
21:19:51 <vincenz> ghc is call-by-need I take it?
21:20:02 <vincenz> erm, haskell
21:20:04 <vincenz> yep it seems so
21:20:06 <vincenz> alright thx
21:20:07 <jer> haskell is yes
21:20:08 <dons> jer, yep
21:20:21 <vincenz> anyone know how to make an AST-based interpreter that allows for single-stepping
21:20:24 <dons> for computer science stuff, of course.
21:20:37 <dons> vincenz: implement the single step semantics ?
21:20:45 <vincenz> dons: well the problem is that basically
21:20:46 <vincenz> I do
21:20:48 <vincenz> interpretExp
21:20:55 <vincenz> env -> exp -> m value
21:21:01 <Korollary> I think he means single-stepping in source code
21:21:03 <vincenz> and it's recurive
21:21:10 <dons> ah, right. not small step semantics.
21:21:55 <vincenz> (on a sidenote, why use call-by-name over call-by-need?)
21:22:24 <dons> sharing, yeah?
21:22:26 <vincenz> dons: yeah it's one big-step
21:22:35 <vincenz> dons: erm... reread?
21:22:39 <dons> versus simplicity.
21:22:40 <vincenz> dons: why not use sharing
21:22:45 <vincenz> sharing hardly seems complicated
21:22:55 <dons> i guess it depends on your implementation language
21:23:17 * vincenz had call-by-need in his lang cause he thunkified the toplevel decls, I moved to call-by-value, however this means that I can't have toplevel decls that are not funcs
21:23:18 <Korollary> cbneed is often referred to as the optimized case of cbname
21:23:31 <dons> right.
21:23:39 <vincenz> anyways
21:23:48 <vincenz> single-stepping ...
21:23:58 <vincenz> be nice if I could single-step
21:24:04 <vincenz> or set breakpoints
21:24:19 <vincenz> by having an implicit breakpoint everytime interpretExp is called again
21:24:21 * dons tags lambdabot 4.0
21:24:29 <vincenz> dons: how do you tag?
21:24:33 <dons> darcs tag
21:25:36 * vincenz goes to shower, if in the meantime you come up with some bright idea on how to do single-stepping, I'd be interested
21:25:36 <dons> cd
21:30:28 <dons> ?quit version 4.0
21:31:09 <dons> ?version
21:31:35 <lambdabot> lambdabot 4p1, GHC 6.5 (OpenBSD i386 )
21:31:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:42:12 <palomer> > 2 + 2 is four
21:42:14 <lambdabot>  Not in scope: `four'
21:50:45 <sethk> dons, quick question, is template haskell a possible solution to my c/s problem?  I have a concept that might work.   If I can get the compiler to generate getRequest/putRequest and getResponse/putResponse for a series of types, then each request can be a separate type (still an instance of Request) and eash response can be a separate type (still an instance of Response) and runServer will remain as it is currently coded.
21:51:32 <sethk> dons, so I'm wondering whether template haskell can be used to generate putRequest/getRequest and putResponse/getResponse for a series of types, with only one coded implementation of put/get request/response
21:53:07 <sethk> dons, Hopefully I posed the question comprehensibly
21:54:09 <sethk> I think you would have to paste runServer into the same file with the generated get/put functions, but that would be a simple paste of a polymorphic function and the compiler would do the magic.
21:54:34 <sethk> so it would be, in a sense, repeated code, but since it would be a paste of identical code there wouldn't be any actual new coding involved.
21:55:03 <sethk> and you might have to use different names (runServer1, runServer2, etc.) in a program with multiple client/server things going on.
21:56:27 <sethk> the coded handleRequest functions will accept one request type and return one response type, but that's the same as what is coded in the present arrangement
21:56:37 <sethk> the type structure is different, but the code does not change.
21:57:07 <sethk> although again you would probably have to use different names as different handleRequest functions would have different type signatures
21:57:40 <sethk> I'm not quite sure how this last part would work
21:57:55 <sethk> I want to know if this is a productive direction before I put in some real work and figure out how to implement it.
23:29:05 <kzm> vincenz, for breakpoints, add FFI calls and use gdb to halt execution on their entry?
23:29:06 <kzm> :-)
23:31:57 <vincenz> right
23:31:59 <vincenz> ...
23:35:03 <kzm> I guess you could also set breakpoints at the mangled haskell function names, but the result would probably be more confusing than not.
23:41:03 <vincenz> kzm: that's hardly a usable approach
23:41:57 * vincenz sighs
23:41:58 <kzm> I know. :-)
23:42:04 <vincenz> then don't suggest it
23:42:09 <vincenz> it detracts from possible real answers
23:42:47 <vincenz> The reason I need stepping is cause I want to do GUI stuff in the midst of my program
23:46:12 <kolmodin> vincenz: I suggest you take a look at the code of "poor mans concurrency monad"
23:46:30 <kolmodin> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/Papers/concurrent-claessen.ps
23:46:40 <kolmodin> you should be able to do stepping with that
23:47:01 <kolmodin> it's used at chalmers to do this lab: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lab2.html
23:47:02 <lambdabot> The title of that page is "Advanced Functional Programming - Laboration 2"
23:47:21 <kolmodin> lambdabot: cool, thanks :)
23:49:07 <kolmodin> vincenz: hope you get what you need there
23:49:11 <kolmodin> got to go. bye
23:55:31 <vincenz> kolmodin: thank you
23:57:44 <vincenz> yeah I was figuring I'd need a continuation, but I don't fully see the whole solution yet
23:59:35 <dropdrive> does the author of "all about monads" hang around here?
