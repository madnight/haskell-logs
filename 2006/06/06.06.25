00:01:20 <dons> so somehow the sequence.org media thingy marks it up weirdly.
00:01:37 <dons> maybe it doesn't like the long lines my script generates
00:02:42 <dons> i wonder if i change the font...
00:03:49 <dons> yeah, it seems to insert line breaks at bad places 
00:04:21 <dons> in an attempt to handle long lines (un)gracefully :/
00:14:16 <dons> looks like running fmt(1) over the .html before uploading is enough to fix it
00:18:48 <dons> lorne: does it look better now?
00:18:55 <dons> on sequence.org
00:20:34 <wolverian> is there a way to insert debug prints in my program? :)
00:20:59 <dons> import Debug.Trace
00:21:08 <wolverian> thanks!
00:21:12 <dons> ?type trace
00:21:13 <lambdabot> Not in scope: `trace'
00:21:14 <dons> ?type Debug.Trace.trace
00:21:15 <lambdabot> forall a. String -> a -> a
00:21:36 <dons> i.e. trace ("line 1") $ 1 + 2
00:22:35 <wolverian> well, no wonder my program didn't work
00:22:40 <wolverian> I misunderstood how Contexts are represented
00:25:27 <wolverian> this behaviour is actually _very_ odd
00:27:55 <wolverian> I was assuming that each Context would contain _all_ the applicable edges. they do not, apparently. if that edge can be represented as both an out and an in edge, it is only shown in one, not both positions.
00:28:22 <wolverian> (when running gmap over a graph)
00:32:23 <xerox> ?type gmap
00:32:24 <lambdabot> Not in scope: `gmap'
00:32:34 <xerox> ?hoogle gmap
00:32:35 <lambdabot> Data.Graph.Inductive.Graph.gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
00:32:35 <lambdabot> Data.Generics.Basics.gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
00:32:35 <lambdabot> Data.Generics.Basics.gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
00:32:46 <xerox> Ah. No idea.
00:33:04 <xerox> ?docs Data.Graph.Inductive
00:33:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive.html
00:33:23 <xerox> type Context a b = (Adj b, Node, a, Adj b)
00:33:26 <wolverian> it simply seems to be that I can not insert two edges that are the same edge, just described from a different point of view
00:33:32 <xerox>   Links to the Node, the Node itself, a label, links from the Node.
00:33:50 <wolverian> (right, via Context)
00:34:19 <xerox> Maybe you are using a Graph while you want a DynGraph?
00:34:30 <wolverian> I'm using Gr
00:34:37 <wolverian> I think
00:35:20 <wolverian> yes, I am.
00:35:26 <wolverian> the problem is:
00:36:12 <wolverian> first insert a Context like ([("", 1), 0, "a", []), then one like ([], 1, "b", [("", 0)]) 
00:36:20 <wolverian> this described the same edge (b -> a) twice
00:36:30 <wolverian> which gives an exception. :)
00:37:16 <wolverian> in any case, since the Context is given in a form that does not describe all the edges, it's not at all useful to me in this program
00:37:21 <wolverian> sigh! 
00:37:28 <wolverian> it only took me two hours to realise this :)
00:38:00 <wolverian> thanks, anyway 
00:38:20 <xerox> :)
01:07:09 <Lokadin> this may be a silly question, but how do you convert a string into a group of strings, er String -> [String]
01:07:22 <Lokadin> er how would i go about doing that, using what functions
01:07:31 <Saulzar> @type concat
01:07:32 <lambdabot> forall a. [[a]] -> [a]
01:07:58 <Saulzar> Er, there are many ways of doing that
01:08:19 <Saulzar> How do you want to chose what the group are?
01:08:22 <Lokadin> er isn't that the opposite? concat i mean
01:08:22 <dons> @type lines
01:08:23 <lambdabot> String -> [String]
01:08:33 <dons> @hoogle a -> [a]
01:08:33 <lambdabot> Prelude.repeat :: a -> [a]
01:08:34 <lambdabot> List.intersperse :: a -> [a] -> [a]
01:08:34 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
01:08:41 <dons> @hoogle+
01:08:41 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
01:08:41 <lambdabot> Prelude.replicate :: Int -> a -> [a]
01:08:41 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
01:08:54 <dons> you probably want a split of some sort?
01:09:01 <dons> @type Data.ByteString.split
01:09:02 <lambdabot> Word8 -> Data.ByteString.Base.ByteString -> [Data.ByteString.Base.ByteString]
01:09:10 <dons> but that's not available for [a]
01:09:26 <Lokadin> say i want it to change a line and for all '.i' that are encountered it would  break it into a ":" or what not but i dono if that's legal
01:09:29 <dons> (unless you take it from a library, or write it yourself (easy))
01:12:14 <Lokadin> so could i just do that? have it start with a new list with " and go on through the x's till it finds '.' followed by 'i' and just add on ":" while giving drop 2 xs to next function
01:14:03 <Lokadin> or would i have to escape them in some special way
01:14:14 <Lokadin> like with a \? eh i guess i can find out
01:22:11 <Lokadin> nm i'll just do it a different way
01:28:47 <lorne> dons: yes, that seems to fixed it
01:34:52 <dmhouse> Morning *.
01:50:55 <dmhouse> Hmm, is haskell.org down?
01:52:56 <Lokadin> i was about to ask
01:53:12 <Lokadin> @hoogle (!!)
01:53:13 <lambdabot> Did you mean: (!!)
01:53:13 <lambdabot> Prelude.undefined :: a
01:53:13 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
01:53:31 <dmhouse> @type (!!)
01:53:32 <lambdabot> forall a. [a] -> Int -> a
01:54:42 <Lokadin> hmmm, so it's used as { list !! 2} to get the third item from the list?
01:56:41 <jer> > [16, 23, 42] !! 2
01:56:42 <lambdabot>  42
01:57:00 <Lokadin> cool thanks :)
01:57:59 <jer> np
01:58:04 <Lokadin> @type words
01:58:05 <lambdabot> String -> [String]
01:59:14 <Lokadin> yay it worked :)
02:28:08 <koffein> mornin everybody
02:28:13 <xerox> Morning you.
02:30:13 <koffein> um.. what do you use in haskell if you want to check wether two numbers are evenly dividable?
02:30:22 <koffein> I found no modulo operator
02:30:37 <xerox> > even 2
02:30:39 <lambdabot>  True
02:31:07 <xerox> > (\n -> n `mod` 2 == 0) 10
02:31:08 <lambdabot>  True
02:31:34 <koffein> ok, thanks
02:32:27 <xerox> You're welcome.
02:35:51 <bolrod> > (not . odd) 3
02:35:52 <lambdabot>  False
02:35:54 <bolrod> > (not . odd) 2
02:35:55 <lambdabot>  True
02:35:58 <bolrod> woah!
02:37:15 <wolverian> that's so odd
02:37:38 <bolrod> @type odd
02:37:39 <lambdabot> forall a. (Integral a) => a -> Bool
02:39:15 <lispy> > (odd >>> even) (3,4)
02:39:16 <lambdabot>  add an instance declaration for (Integral Bool)
02:39:33 <lispy> @type odd >>> even
02:39:34 <lambdabot>   No instance for (Integral Bool)
02:39:34 <lambdabot>    arising from use of `even' at <interactive>:1:8-11
02:39:42 <xerox> > map (\x -> foldr (const not) True [1..x]) [1..6]
02:39:43 <lambdabot>  [False,True,False,True,False,True]
02:39:50 <xerox> *^_^*
02:40:13 <xerox> (even)
02:40:19 <lispy> @type (>>>)
02:40:20 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
02:40:32 <xerox> > (odd *** even) (3,4)
02:40:33 <lambdabot>  (True,True)
02:40:38 <lispy> ah, thanks
02:40:45 <xerox> > (odd &&& even) 3
02:40:46 <lambdabot>  (True,False)
02:40:47 <lispy> my next guess used arr
02:40:52 <bolrod> O_o
02:41:02 <bolrod> @type (&&&)
02:41:02 <lispy> > (arr odd) >>> (arr even) (3,4)
02:41:03 <lambdabot>  Couldn't match `a Bool d' against `Bool'
02:41:03 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:41:21 <xerox> odd doesn't take a tuple.
02:41:30 <xerox> ...and even doesn't take a bool.
02:41:36 <xerox> (>>>) = flip (.)
02:41:59 <xerox> > (first odd >>> second even) (3,4)
02:42:00 <lambdabot>  (True,True)
02:42:12 <lispy> ohhh...
02:42:29 <lispy> > (head &&& tail) [1..6]
02:42:30 <lambdabot>  (1,[2,3,4,5,6])
02:42:34 <bolrod> > (not>>>even) 3
02:42:34 <lambdabot>  add an instance declaration for (Integral Bool)
02:42:46 <xerox> > (even >>> not) 3
02:42:47 <lambdabot>  True
02:42:52 <bolrod> > ((flip (>>>)) not even) 3
02:42:53 <lambdabot>  True
02:42:57 <bolrod> :O
02:43:36 <bolrod> (head &&& tail &&& last) [1..6]
02:43:40 <bolrod> > (head &&& tail &&& last) [1..6]
02:43:40 <lispy> > head &&& (map (+1)) $ [1..6]
02:43:41 <lambdabot>  (1,([2,3,4,5,6],6))
02:43:42 <lambdabot>  (1,[2,3,4,5,6,7])
02:44:15 <xerox> > (head &&& tail &&& init &&& last) [1..6]
02:44:16 <lambdabot>  (1,([2,3,4,5,6],([1,2,3,4,5],6)))
02:44:29 <xerox> Gawk.
02:45:08 <bolrod> > map (inits &&& first) (inits [1..10])
02:45:09 <lambdabot>  Couldn't match `a b' against `[]'
02:45:20 <bolrod> erh?
02:45:54 <bolrod> > (inits &&& first) [1..10]
02:45:54 <lambdabot>  Couldn't match `a b' against `[]'
02:46:18 <lispy> @type inits
02:46:20 <lambdabot> forall a. [a] -> [[a]]
02:46:20 <bolrod> > inits [1..10]
02:46:21 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
02:46:41 <bolrod> @type (&&&)
02:46:42 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:46:44 <lispy> > sequence [1..10]
02:46:45 <lambdabot>  add an instance declaration for (Show (m [a]))
02:47:08 <lispy> @type sequence
02:47:10 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
02:47:37 <lispy> > sequence $ inits [1..10]
02:47:38 <lambdabot>  []
02:47:42 <lispy> hmm...
02:47:48 <lispy> not what i expected :)
02:47:55 <bolrod> > sequence [1..10] ++ [4]
02:47:55 <lambdabot>  add an instance declaration for (Num [a])
02:47:55 <lambdabot>   In the list element: 4
02:48:18 <bolrod> > sequence [[1..10]] ++ [4]
02:48:18 <lispy> > sequence $ tail $ inits [1..10]
02:48:18 <lambdabot>  add an instance declaration for (Num [a])
02:48:18 <lambdabot>   In the list element: 4
02:48:19 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,1,1,3],[1,1,1,1,...
02:48:31 <lispy> > nub $ sequence $ tail $ inits [1..10]
02:48:32 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,1,1,3],[1,1,1,1,...
02:48:42 <lispy> > map nub $ sequence $ tail $ inits [1..10]
02:48:43 <lambdabot>  [[1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[1,2],[1,2],[1,2...
02:49:07 <lispy> > nub $ map nub $ sequence $ tail $ inits [1..10]
02:49:08 <lambdabot>  [[1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[1,2,3],[1,2,4],...
02:49:19 <lispy> powerset?
02:49:25 <lispy> well, minus []
02:50:24 <lispy> > reverse $ nub $ map nub $ sequence $ reverse $ inits [1..10]
02:50:25 <lambdabot>  []
02:52:25 <int-e> > sequence . map (tails . return) $ [1..3]
02:52:26 <lambdabot>  [[[1],[2],[3]],[[1],[2],[]],[[1],[],[3]],[[1],[],[]],[[],[2],[3]],[[],[2],[]...
02:53:07 <int-e> > map concat . sequence . map (tails . return) $ [1..3]
02:53:08 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
02:54:49 <lispy> nice
02:54:58 <int-e> > map concat . sequence . map (([]:) . (:[])) $ [1..3]
02:54:58 <lambdabot>  add an instance declaration for (Num [a])
02:54:58 <lambdabot>   In an arithmetic sequence: [1...
02:55:27 <bolrod> > let f list = [x:y | x <- list , y<- tails list] in f [1..5]
02:55:28 <lambdabot>  [[1,1,2,3,4,5],[1,2,3,4,5],[1,3,4,5],[1,4,5],[1,5],[1],[2,1,2,3,4,5],[2,2,3,...
02:55:43 <bolrod> > let f list = [x:y | x <- list , y<- tails list] in f [1..3]
02:55:44 <lambdabot>  [[1,1,2,3],[1,2,3],[1,3],[1],[2,1,2,3],[2,2,3],[2,3],[2],[3,1,2,3],[3,2,3],[...
02:55:46 <bolrod> hrm
02:56:07 <lispy> > map union $ inits [1..3]
02:56:08 <lambdabot>  Add a type signature
02:56:15 <lispy> @type union
02:56:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
02:56:32 <bolrod> > let f [] = [] ; f (l:ls) = [x:y | x <- list , y<- (f ls)] in f [1..3]
02:56:33 <lambdabot>  Not in scope: `list'
02:56:35 <int-e> > let f list = [x:y | (x,y) <- zip list (tails (tail list))]
02:56:35 <lambdabot>  Parse error
02:56:38 <int-e> > let f list = [x:y | (x,y) <- zip list (tails (tail list))] in f [1,2,3]
02:56:39 <lambdabot>  [[1,2,3],[2,3],[3]]
02:56:52 <bolrod> > let f [] = [] ; f lss@(l:ls) = [x:y | x <- lss , y<- (f ls)] in f [1..3]
02:56:53 <lambdabot>  []
02:56:58 <lispy> @type map union
02:56:59 <lambdabot> forall a. (Eq a) => [[a]] -> [[a] -> [a]]
02:57:08 <int-e> > let f [] = [[]]; f list = [x:z | (x,y) <- zip list (tails (tail list)), z <- f y] in f [1,2,3]
02:57:09 <lambdabot>  [[1,2,3],[1,3],[2,3],[3]]
02:57:33 <int-e> funny.
02:57:38 <lispy> @type map union [[1],[2]]
02:57:39 <lambdabot> forall a. (Num a) => [[a] -> [a]]
02:57:49 <lispy> oh
02:57:49 <bolrod> > union [[1],[2]]
02:57:50 <lambdabot>  Add a type signature
02:57:57 <int-e> > let f [] = [[]]; f list = [t | (x,y) <- zip list (tails (tail list)), z <- f y, t <- [x:z, z]] in f [1,2,3]
02:57:58 <lambdabot>  [[1,2,3],[2,3],[1,3],[3],[1,2],[2],[1],[],[1,3],[3],[1],[],[2,3],[3],[2],[],...
02:58:00 <lispy> > foldl1 union $ inits [1..3]
02:58:01 <lambdabot>  [1,2,3]
02:58:10 <bolrod> hrm
02:58:20 <int-e> ah. I'm stupid
02:58:20 <lispy> map doesn't work well with a binary function :)
02:59:00 <lispy> > zipWith union $ inits [1..3]
02:59:01 <lambdabot>  Add a type signature
02:59:16 <int-e> > let f [] = [[]]; f l = [x:z | x:y <- tails list, z <- f y] in f [1,2,3]
02:59:16 <lambdabot>  Not in scope: `list'
02:59:20 <lispy> @type zipWith union
02:59:21 <lambdabot> forall a. (Eq a) => [[a]] -> [[a]] -> [[a]]
02:59:22 <int-e> > let f [] = [[]]; f l = [x:z | x:y <- tails l, z <- f y] in f [1,2,3]
02:59:23 <lambdabot>  [[1,2,3],[1,3],[2,3],[3]]
02:59:42 <bolrod> @type delete
02:59:43 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
02:59:49 <lispy> delete?
02:59:55 <lispy> that one is new to me
03:00:02 <lispy> > delete 3 [1..5]
03:00:03 <lambdabot>  [1,2,4,5]
03:00:08 <bolrod> @type lookup
03:00:09 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
03:00:42 <bolrod> > zip [1..5] [5..16]
03:00:43 <lambdabot>  [(1,5),(2,6),(3,7),(4,8),(5,9)]
03:00:45 <int-e> > let f l = []:[x:z | x:y <- tails list, z <- f y] in f [1,2,3]
03:00:46 <lambdabot>  Not in scope: `list'
03:00:50 <int-e> > let f l = []:[x:z | x:y <- tails l, z <- f y] in f [1,2,3]
03:00:51 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
03:00:53 <lispy> > lookup 2 [(x,y) | x <- [1..26], y <- ['a'..'z']]
03:00:54 <lambdabot>  Just 'a'
03:00:56 <int-e> HAH.
03:01:11 <lispy> nice
03:01:23 <lispy> > lookup 1 [(x,y) | x <- [1..26], y <- ['a'..'z']]
03:01:24 <lambdabot>  Just 'a'
03:01:34 <bolrod> > [(x,y) | x <- [1..26], y <- ['a'..'z']]
03:01:35 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(1,'e'),(1,'f'),(1,'g'),(1,'h'),(1,'i'),(1,...
03:01:43 <lispy> er..yeah, not what i wanted
03:01:55 <int-e> zip
03:02:02 * lispy nods
03:02:07 <int-e> > zip [1..] ['a'..'z']
03:02:08 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(10...
03:02:27 <lispy> > lookup 13 $ zip [1..] ['a'..'z']
03:02:28 <lambdabot>  Just 'm'
03:02:31 <int-e> > [(x,y) | x <- [1..26] | y <- ['a'..'z']]
03:02:32 <lambdabot>  Parse error
03:02:37 <lispy> > fromJust $ lookup 13 $ zip [1..] ['a'..'z']
03:02:38 <lambdabot>  'm'
03:04:40 <bolrod> > let ps [] = [] ; ps (x:xs) = x : ps xs in ps [1..10]
03:04:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:05:08 <int-e> shiny
03:05:53 <bolrod> > let ps [] = [[]] ; ps xss@(x:xs) = xss: (x:ps xs)       in ps [1..10]
03:05:54 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
03:05:54 <lambdabot>    Expected...
03:06:00 <bolrod> > let ps [] = [[]] ; ps xss@(x:xs) = xss++ (x:ps xs)       in ps [1..10]
03:06:01 <lambdabot>  add an instance declaration for (Num [a])
03:06:01 <lambdabot>   In an arithmetic sequence: [1...
03:06:06 <bolrod> blah
03:07:02 <int-e> > let ps [] = [[]] ; ps xss@(x:xs) = xss : (map (x:) $ ps xs)       in ps [1..10]
03:07:02 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3...
03:07:14 <lorne> > let ps [x] = [ [], [x] ] ; ps (x:xs) = map (x:) (ps xs) ++ (ps xs) in ps [1,2,3]
03:07:14 <int-e> silly
03:07:15 <lambdabot>  [[1,2],[1,2,3],[1],[1,3],[2],[2,3],[],[3]]
03:07:19 <bolrod> > do { x<-[1..10],y<-[11..20], return (x+y)}
03:07:20 <lambdabot>  Parse error
03:07:32 <bolrod> > do { x<-[1..10];y<-[11..20]; return (x+y)}
03:07:33 <lambdabot>  [12,13,14,15,16,17,18,19,20,21,13,14,15,16,17,18,19,20,21,22,14,15,16,17,18,...
03:07:41 <xerox> > liftM2 (+) [1..10] [11..20]
03:07:42 <lambdabot>  [12,13,14,15,16,17,18,19,20,21,13,14,15,16,17,18,19,20,21,22,14,15,16,17,18,...
03:07:47 <bolrod> > do { x<-[1..3];y<-[10..13]; return (x+y)}
03:07:48 <lambdabot>  [11,12,13,14,12,13,14,15,13,14,15,16]
03:07:51 <bolrod> :)
03:08:07 <bolrod> > do { x<-[1..3];y<-[10..13]; return (x:y:[])}
03:08:08 <lambdabot>  [[1,10],[1,11],[1,12],[1,13],[2,10],[2,11],[2,12],[2,13],[3,10],[3,11],[3,12...
03:12:54 <bolrod> >  map (\x -> "B"++x++"h")  (zipWith (\x-> replicate x 'a') [1..])   
03:12:54 <lambdabot>    Expecting a function type, but found `[a]'
03:12:55 <lambdabot>    Expected type: [[Char]]...
03:13:24 <bolrod> @type  (zipWith (\x-> replicate x 'a') [1..])   
03:13:25 <lambdabot>   Expecting a function type, but found `[a]'
03:13:25 <lambdabot>    Expected type: b -> c
03:13:54 <bolrod> >  map (\x -> "B"++x++"h")  (map (\x-> replicate x 'a') [1..])   
03:13:55 <lambdabot>  ["Bah","Baah","Baaah","Baaaah","Baaaaah","Baaaaaah","Baaaaaaah","Baaaaaaaah"...
03:14:04 <bolrod> >  map (\x -> "Bl"++x++"h")  (map (\x-> replicate x 'a') [1..])   
03:14:05 <lambdabot>  ["Blah","Blaah","Blaaah","Blaaaah","Blaaaaah","Blaaaaaah","Blaaaaaaah","Blaa...
03:14:09 <bolrod> eeexcelent
03:15:36 <Igloo> > map ("bl" ++) $ iterate ('a':) "h"
03:15:36 <lambdabot>  ["blh","blah","blaah","blaaah","blaaaah","blaaaaah","blaaaaaah","blaaaaaaah"...
03:16:14 <bolrod> > let f n | n==1 = [1] | even n = n: f (n`div`2) | otherwise = n : f (3*n+1) in f 7
03:16:15 <lambdabot>  [7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1]
03:16:18 <bolrod> :]
03:16:31 <bolrod> > let f n | n==1 = [1] | even n = n: f (n`div`2) | otherwise = n : f (3*n+1) in f 9
03:16:32 <lambdabot>  [9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1]
03:16:58 <bolrod> > let f n | n==1 = [1] | even n = n: f (n`div`2) | otherwise = n : f (3*n+1) in drop 80 $ f 27
03:16:59 <lambdabot>  [1154,577,1732,866,433,1300,650,325,976,488,244,122,61,184,92,46,23,70,35,10...
03:18:20 <xerox> > unfoldr (\a -> Just (concat ["Bl",a,"h"],'a':a)) "a"
03:18:23 <lambdabot>  ["Blah","Blaah","Blaaah","Blaaaah","Blaaaaah","Blaaaaaah","Blaaaaaaah","Blaa...
03:20:32 <bolrod> @type fix
03:20:33 <lambdabot> forall a. (a -> a) -> a
03:20:56 <bolrod> > fix (\(x:y:xs) -> x:y:'a':xs) "Blah"
03:20:56 <lambdabot>  Couldn't match `t -> t1' against `[a]'
03:21:26 <bolrod> > iterate (\(x:y:xs) -> x:y:'a':xs:) "Blah"
03:21:26 <lambdabot>  Parse error
03:21:32 <bolrod> > iterate (\(x:y:xs) -> (x:y:'a':xs):) "Blah"
03:21:32 <lambdabot>  Parse error
03:22:23 <bolrod> let blah xss@(x:x':xs) = xss: blah (x:x':'a':xs) in blah "Blah"
03:22:26 <bolrod> > let blah xss@(x:x':xs) = xss: blah (x:x':'a':xs) in blah "Blah"
03:22:27 <lambdabot>  ["Blah","Blaah","Blaaah","Blaaaah","Blaaaaah","Blaaaaaah","Blaaaaaaah","Blaa...
03:23:07 <bolrod> @index fix
03:23:07 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
03:23:21 <int-e> > fix (("Blah" :) . map (\(x:y:xs) -> x:y:'a':xs))
03:23:22 <lambdabot>  ["Blah","Blaah","Blaaah","Blaaaah","Blaaaaah","Blaaaaaah","Blaaaaaaah","Blaa...
03:23:32 <bolrod> aha
03:24:13 <lispy> @type Control.Monad.Fix.fix
03:24:14 <lambdabot> forall a. (a -> a) -> a
03:24:22 <int-e> iterate f x = fix ((x:) . map f)
03:24:34 <bolrod> > lookup 50 $  zip [1..] (fix (("Blah" :) . map (\(x:y:xs) -> x:y:'a':xs)))
03:24:35 <lambdabot>  Just "Blaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaah"
03:24:52 <int-e> @type (!!)
03:24:53 <lambdabot> forall a. [a] -> Int -> a
03:25:04 <bolrod> ofcourse!
03:25:06 <int-e> @type (!!50)
03:25:08 <xerox> I've got it :-)
03:25:09 <bolrod> but this is cooler
03:25:10 <xerox> > fix (\f a -> concat ["Bl",'a':a,"h"] : f ('a':a)) ""
03:25:19 <lambdabot> forall a. [a] -> a
03:25:21 <lambdabot>  ["Blah","Blaah","Blaaah","Blaaaah","Blaaaaah","Blaaaaaah","Blaaaaaaah","Blaa...
03:25:24 <xerox> (-:
03:25:38 <bolrod> :-O
03:25:40 <xerox> Ops, int-e gave it before.
03:25:52 <int-e> xerox: not really, I did it differently
03:25:57 <xerox> I see
03:26:45 <xerox> I was trying to pattern match 'B':'l' before hehe
03:27:36 <lispy> @localtime lispy
03:27:50 <bolrod> I think lambdabot isn't registered
03:27:54 <lispy> :(
03:28:06 <lispy> it's almost 03:30 here...
03:28:16 <bolrod> 12:27:49 [freenode] CTCP TIME reply from lispy: Sun Jun 25 03:27:46 2006
03:28:20 <int-e> > concatMap concat $ sequence $ [["Bl"]]:replicate 3 ["a", "aa", "ah Bl"] ++ [["ah"]]
03:28:21 <lambdabot>  Couldn't match `[Char]' against `Char'
03:28:33 <bolrod> Sun Jun 25 12:28:13 CEST 2006
03:28:35 <int-e> > concatMap concat $ sequence $ ["Bl"]:replicate 3 ["a", "aa", "ah Bl"] ++ [["ah"]]
03:28:36 <lambdabot>  "BlaaaahBlaaaaahBlaaah BlahBlaaaaahBlaaaaaahBlaaaah BlahBlaah BlaahBlaah Bla...
03:28:56 <xerox> hah
03:29:41 <bolrod> > "Bl"++repeat 'a' ++"h"
03:29:42 <lambdabot>  "Blaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
03:29:47 <bolrod> the neverending blah
03:30:03 <int-e> right. that's a string of length omega+1 ;)
03:30:19 <lispy> nice
03:30:57 <bolrod> :)
03:31:33 <int-e> concat $ repeat (repeat 'a') is a string of length omega^2 .. unfortunately it's computationally indistinguishable from a string of length omega.
03:32:01 <bolrod> erh
03:32:08 * int-e is only half serious, btw.
03:32:37 <bolrod> > length (map (^2) [1..])   -- we will soon find out
03:32:41 <lambdabot> Terminated
03:32:44 <bolrod> too bad
03:33:21 <xerox> FSVO soon
03:33:26 <bolrod> ?
03:34:21 <lispy> "for some values of"
03:35:58 <bolrod> hrm.... my laptop now has a bigger uptime then my desktop ever has
03:36:59 <lorne> built in UPS does come in handy
03:37:08 <bolrod> yep :)
03:37:28 <bolrod> well...  few dayas ago the power did fail
03:37:41 <bolrod> or someone turned it off..
03:38:00 <lorne> my laptop has to restart every ten seconds for updates.. (where ten seconds currently is at least 43 days)
03:38:04 <bolrod> I wasn't at home though
04:57:13 <roconnor> @seen int-e
04:57:13 <lambdabot> int-e is in #darcs, #haskell-overflow and #haskell. I last heard int-e speak 1 hour, 25 minutes and 6 seconds ago.
04:57:23 <int-e> yes?
04:57:35 <roconnor> Hows the new Socket API?
04:58:00 <int-e> I sent a mail to libraries@haskell.org earlier.
04:58:22 <roconnor> is that a public mailing list?
04:58:53 <int-e> http://article.gmane.org/gmane.comp.lang.haskell.libraries/4818
04:58:55 <int-e> yes
04:58:56 <lambdabot> Title: "Gmane -- Mail To News And Back Again"
05:13:37 <roconnor> int-e: what happens when I give getSocketOption or setSocketOption a so-called exotic function?
05:13:56 <roconnor> ie, something that isn't actually one of the constructors.
05:14:02 <roconnor> but just some random function?
05:14:56 <int-e> roconnor: well, the type of that function is limited. there are, as far as I can see, no buffer overflows possible (because the buffers are allocated with a certain size and that's passed down to the C level) - so all that happens is that you get random results back.
05:15:30 <int-e> roconnor: that's exactly the 'small loss in safety' I hinted at at the end of the message
05:15:36 <roconnor> I don't fully appreciate why this it isn't better just to make n set and get functions.
05:16:25 <int-e> code explosion
05:16:27 * int-e shrugs
05:17:14 * roconnor is pleased that a patch was made so quickly after my complaint
05:17:20 <roconnor> karma+ int-e
05:17:24 <int-e> I don't see why n set and get functions would be better.
05:17:26 <roconnor> @karma+ int-e
05:17:26 <lambdabot> int-e's karma raised to 7.
05:17:43 <roconnor> int-e: there is not way to call the functions incorrectly.
05:17:55 <int-e> because you have to try really hard to do that, in my humble opinion.
05:18:02 <roconnor> that is true
05:19:31 <int-e> anyway we'll see what the maintainers think.
05:20:04 <roconnor> but anything that can go wrong will go wrong.
05:20:13 <roconnor> http://r6.livejournal.com/66825.html
05:20:15 <lambdabot> Title: "r6: Murphy&rsquo;s Law"
05:21:38 <roconnor> maybe I should make a compeating patch.
05:21:52 <roconnor> OTOH, it is easy to take your code and wrap it in a safe module.
05:22:06 <int-e> yep
05:23:34 <int-e> btw, one reason is that coming up with a type system hack was way more interesting than duplicating a lot of code.
05:23:40 <int-e> I'll admit that
05:29:03 <int-e> roconnor: btw, http://www.improb.com/airchives/paperair/volume9/v9i5/murphy/murphy1.html is interesting.
05:30:22 <int-e> (hmm, replace 1 with 0 for the index)
05:45:14 <dmhouse> haskell.org is back up, it seems.
05:57:46 <dmhouse> Hehe. http://www.willamette.edu/~fruehr/logos/PNGs/RealHackers.png
05:58:41 <bolrod> haha
05:58:48 <wilx> :))
05:59:25 <Saulzar> Where as it should really be the other way around - most languages provide such a feature everywhere :)
05:59:46 <dblhelix> dmhouse: that's one actually on the door of the lab, here
05:59:55 <dblhelix> /s/that's/that
06:00:07 <dmhouse> dblhelix: Wow! :)
06:00:15 <bolrod> "To others however the Law is a pessimistic comment that underscores, albeit in more elegant terms, that shit happens."
06:00:18 <bolrod> haha
06:02:00 * bolrod feels soo sorry for the people that went to parkpop
06:02:01 <bolrod> muahahahaha
06:02:26 <dblhelix> bolrod: what happened to parkpop, then?
06:02:45 <bolrod> it's raining 
06:02:52 <bolrod> and it'll rain for a while too
06:03:13 <dblhelix> bolrod: ah, that's lousy
06:03:15 <bolrod> well.. good I'm not there
06:03:29 <bolrod> last year was perfect weather
06:10:59 <bolrod> dblhelix: do alot of students apply to be an assistant for FP ?
06:11:11 <int-e> roconnor: I've added some comments in http://article.gmane.org/gmane.comp.lang.haskell.libraries/4819
06:11:14 <lambdabot> Title: "Gmane -- Mail To News And Back Again"
06:11:21 <dblhelix> bolrod: not sure
06:11:30 <dblhelix> bolrod: are you interested to become one?
06:12:02 <bolrod> possibly..  I mean, if I'd want to try being an assistant.
06:12:04 <bolrod> I'd choose FP
06:12:41 <dmhouse> Anyone happen to know the license of the Haskell logo? http://haskell.org/haskellwiki_logo.png
06:12:48 <dmhouse> Would it come under the simple permissive license?
06:13:12 <bolrod> Imp is just too boring.. it's probably just help solving some problems with variables or something
06:13:50 <bolrod> though I heard it's really easy to be an assistant at imp for 'Informatiekunde'  since half of them are gone after the first test or so
06:14:14 <dblhelix> bolrod: and what problems to you expect to help solving for FP?
06:14:30 <bolrod> help with the sums... excercises?
06:14:56 <dblhelix> bolrod: and the lab of course...
06:15:02 <bolrod> ofcourse :)
06:15:19 <bolrod> but I guess the java is 'just the lab'
06:15:41 <dblhelix> well, doaitse is teaching FP next year, and I'm TA'ing again... so, you're more than welcome to apply for being a student assistant
06:16:11 <bolrod> well.. I still have a long time to think about it :)
06:16:19 <bolrod> since you can only apply for the 1st and 2nd period
06:16:20 <dblhelix> bolrod: that's true
06:18:48 <MarcWeber> Is there a function to check wether a string contains another?
06:19:26 <bolrod> isn't there already one in the List module/
06:19:27 <bolrod> ?
06:19:44 <dmhouse> @hoogle sublist
06:19:44 <MarcWeber> bolrod: How is it called?
06:19:45 <lambdabot> No matches found
06:20:06 <dblhelix> @hoogle (Eq a) => [a] -> [a] -> Bool
06:20:07 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
06:20:07 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
06:20:23 <dblhelix> nope, no such thing, afik
06:20:26 <MarcWeber> isSuffixOf will do. thanks
06:20:35 <dblhelix> MarcWeber: ah, ok
06:20:57 <bolrod> you could use the bruteforce method
06:21:43 <xerox> > let isSublistOf xs ys = any (xs `isPrefixOf`) (tails ys) in [1,2] `isSublistOf` [1..4]
06:21:44 <lambdabot>  True
06:21:56 <bolrod> > let contains s p = any $ map isPrefixOf (tails s) in contains "testtest" "test"
06:21:56 <lambdabot>  Couldn't match `a -> Bool' against `[b]'
06:22:04 <xerox> That way.
06:22:05 <bolrod> hrm.. yes
06:22:15 <xerox> any does map.
06:22:32 <bolrod> @type any
06:22:33 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:22:51 <bolrod> ohyeah.. confused with or
06:23:24 <xerox> > let any = (or .) . map in any (>2) [1..10]
06:23:25 <lambdabot>  True
06:23:40 <xerox> > let any = (or .) . map in any (>10) [0..9]
06:23:41 <lambdabot>  False
06:24:30 <xerox> > let or [] = False; or (b:bs) = b || or bs in or [False,True,False]
06:24:31 <lambdabot>  True
06:24:57 <bolrod> yes yes yes! :)
06:25:07 <bolrod> > or [False]
06:25:08 <lambdabot>  False
06:25:10 <xerox> Thinking out loud.
06:25:24 <bolrod> on irc..... wow
06:25:55 <xerox> It's because lambdabot is a terrific toy.
06:26:35 <bolrod> @vixen are you a terrific toy?
06:26:35 <lambdabot> yes, i am
06:26:42 <bolrod> hmm.. guess so.
06:27:19 <int-e> @arr
06:27:20 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
06:29:05 <roconnor> wow, that's pretty crude
06:29:38 <dmhouse> Anyone happen to know the license of the Haskell logo? http://haskell.org/haskellwiki_logo.png
06:29:41 <dmhouse> Would it come under the simple permissive license?
06:30:23 <roconnor> isn't everything on the wiki under that licence
06:31:03 <bolrod> LGPL ?    ;)
06:42:48 <int-e> LGPL, hmm. You can link to it but you can't embed it into other images? Hehe.
06:43:45 <bolrod> well.. if you change the source.. you have to provide it along with it
06:43:49 <bolrod> or something ;p
06:54:41 <dmhouse> Where are phantom types useful?
06:55:58 <xerox> In medieval type castles!
06:56:04 * xerox runs hiding under a rock
06:56:20 <bolrod> hoho!
06:56:24 <bolrod> who hates callcenters?
06:56:29 <int-e> in driving the type checker insane. in generating arbitrary many type classes.
06:56:46 <int-e> arbitrarily
06:56:58 <bolrod> http://www.flabber.nl/archief/016754.php  << genius
06:57:02 <lambdabot> Title: "Flabber.nl | Totally Flabbergasted Weblog: Telemarketeer krijgt er van langs"
06:57:05 <bolrod> do you ONDERSTAND  :D
06:57:49 <dmhouse> Also, would it be a crime against humanity to call foralls 'type lambdas'?
06:57:56 <int-e> I like http://www.xs4all.nl/~egbg/counterscript.html
06:57:58 <lambdabot> Title: "anti-telemarketing EGBG counterscript"
06:58:20 <int-e> dmhouse: yes.
06:58:44 <dmhouse> int-e, well, they 'bring type variables into scope' by qualifying them.
06:59:12 <int-e> but there meaning is different - there's no type level application for them
07:01:05 <bolrod> int-e: :D
07:02:04 <int-e> it's really type level quantification.
07:02:08 <roconnor> dmhouse: foralls are not lambda
07:02:11 <int-e> see, there's a name for it :)
07:02:13 <roconnor> foralls are pis
07:02:20 <xerox> piss?
07:02:24 <roconnor> pi's
07:02:26 <roconnor> Pi's
07:02:31 <xerox> > pi -- s
07:02:32 <lambdabot>  3.141592653589793
07:02:33 <dmhouse> Argh! Not Pi's.
07:02:41 <roconnor> capital Pi
07:02:45 <xerox> What are Pi's?
07:02:45 <dmhouse> Never Use An Apostrophe For A Plural. :)
07:02:46 <bolrod> Pie?
07:02:50 <dmhouse> xerox, you too.
07:02:51 <bolrod> hmmmm pie
07:03:08 <dmhouse> roconnor: And how are they Pis?
07:03:13 <roconnor> pi types are types that have lambdas as members
07:03:25 <dmhouse> Oh, yeah, I remember the usage now.
07:03:50 <roconnor> a -> b is just shortand for Pi x:a . b
07:04:19 <roconnor> Pi is a dependent product
07:05:43 <dmhouse> roconnor: But Pis are a bit like lambdas at the type level. I know that's a crude explanation, but it's somewhat true.
07:05:44 <roconnor> Pi expressions cannot (directly) be applied
07:06:00 <roconnor> like lambda expessions are applied
07:06:13 <dmhouse> I suppose 'qualifiers' is just a better explanation, and not much more complex than 'type lambdas'.
07:06:22 <roconnor> function application is the defining feature of lambdas.
07:07:14 <dmhouse> Yeah.
07:07:42 <roconnor> Pi's are dependent products.  Pi x:a . b(x) = {(x,y) | x:a and y:b(x)}
07:08:04 <roconnor> wait, is that right?
07:08:14 <schoinobates> Pi's are the type of lambdas in that kind of type theory.
07:08:48 <dmhouse> roconnor: don't Pis qualify types?
07:08:57 <dmhouse> I.e. isn't it Pi a. lambda x. b(x)
07:09:19 <dmhouse> schoinobates: and my comment 'Never Use An Apostrophe For A Plural' goes for you too :P
07:09:37 <dmhouse> Or even, Pi a. lambda x:a. b(x)
07:10:32 <roconnor> Pi's are type constructors 
07:10:40 <roconnor> like ->
07:10:52 <roconnor> (because -> is shorthand for Pi)
07:11:24 <dmhouse> Hrm. Really?
07:11:24 <schoinobates> (in the acse where the product is not dependent)
07:11:29 <roconnor> but no, Pi a. lambda x. b(x) is not correct
07:11:45 <dmhouse> roconnor: Then Pis are not foralls.
07:12:02 <dmhouse> As the equivalent Haskell would be forall a. \(x::a) -> b x
07:12:13 <roconnor> Pi's are foralls.
07:12:48 <roconnor> the equivalent in haskell would be forall (a:*) -> b a
07:12:52 <roconnor> opps
07:13:00 <roconnor> the equivalent in haskell would be forall (a:*). b a
07:13:18 <roconnor> Sorry I see I was being confusing before.
07:13:51 <dmhouse> Ah, right.
07:13:57 <dmhouse> But that's not shorthand for b -> a.
07:14:30 <roconnor> right
07:15:04 <mgoetze> hullo
07:16:00 <roconnor> a -> b = forall x:a. b  and forall a. a -> a = forall a:*, a -> a
07:16:04 <mgoetze> > let r = mkRegex "(([1-7][CDSHN]|P)*)" in matchRegex r "1CP1DP1H"
07:16:04 <lambdabot>  Not in scope: `matchRegex'
07:16:16 <mgoetze> hm, lambdabot doesn't do regexs :(
07:16:46 <mgoetze> anyway, my question is, is there anyway to write that so only "1CP1DP1H" is returned as a subexpression, and not "1H"?
07:16:49 <roconnor> a -> b = forall x:a. b  and forall a. a -> a = forall a:*, a -> a = forall a:*. forall x:a. a
07:17:52 <dmhouse> > let r = Text.Regex.mkRegex "(([1-7][CDSHN]|P)*)" in Text.Regex.matchRegex r "1CP1DP1H"
07:17:53 <lambdabot>  Not in scope: `Text.Regex.matchRegex'
07:17:57 <dmhouse> :(
07:19:08 <totu> ls
07:19:16 <totu> err... sorry =)
07:19:42 <dmhouse> mgoetze: try matchRegexAll? Or perhaps you want the 0th substring match?
07:20:25 <mgoetze> dmhouse: well i can ignore that one, just that i want to construct a larger regexp and use lots of subexpressions, so was looking for a cleaner way to do it
07:20:32 <dmhouse> Ah.
07:21:13 <dmhouse> Don't think so. In other regex systems there are ways to bracket expressions without making them subexpressions, but POSIX regexps are limited to say the least.
07:21:28 <dmhouse> (No non-greedy qualifier? What?! And so on.)
07:22:42 <mgoetze> don't suppose there is a perl-compatible regex library for haskell? (e.g. bindings to libpcre)
07:23:39 <dmhouse> Yep. JRegex.
07:23:50 <dmhouse> @hoogle JRegex haskell
07:23:51 <lambdabot> Did you mean: JRegex Haskell
07:23:55 <dmhouse> @google JRegex haskell
07:23:58 <dmhouse> Oops :)
07:23:58 <lambdabot> http://repetae.net/john/computer/haskell/JRegex/
07:23:58 <lambdabot> Title: "JRegex"
07:24:30 <mgoetze> thanks :)
07:27:08 <dmhouse> Is http://khjk.org/ up for anyone?
07:27:10 <lambdabot> Title: "Karl Hans Janke Kollaborativ"
07:27:26 <dmhouse> Huh. Seems to be for lambdabot.
07:28:01 <dmhouse> Anyone else?
07:36:50 <bolrod> yep
07:37:56 <petekaz> @seen Cale
07:37:56 <lambdabot> Cale is in #haskell. I don't know when Cale last spoke.
07:39:11 <bolrod> pfff
07:39:21 <dmhouse> bolrod: it works for you?
07:40:38 <bolrod> yes
07:41:18 <dmhouse> Grr. Odd.
07:41:40 <bolrod> traceroute it
07:42:23 <Dino_> Still going through _All About Monads_. This is very cool and freaking me out:  traceFamily s l = foldM getParent s l where getParent s f = f s
07:42:51 <Dino_> So you can make calls like traceFamily sheep [father, mother]  to get paternal grandmother.
07:43:09 <mnislaih> do overlapping instances conflict with standard propagation of instances via type declarations? GHC complains that RReal is not instance of Integral where RReal is defined as 'type RReal = Float'
07:43:16 <Dino_> First time I had seen sending a list of functions to a fold. Neat stuff.
07:44:54 <monochrom> [father, mother] represents a path.
07:45:40 <monochrom> Float is not an instance of Integral to begin with.
07:46:38 <mnislaih> oops, indeed
07:48:19 <mnislaih> what could this error mean then "No instance for (Integral RReal) arising from use of `floor' at..." ?
07:49:05 <mnislaih> floor is not in integral after all
07:49:09 <monochrom> @type floor
07:49:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:49:25 <mnislaih> oh, yep
07:49:47 <mnislaih> damn, I'm dumb :O
07:51:22 <SimonRC> Dino_: "Haskell is like a foreign country.  We do things differently here."
07:52:07 * JKnecht peeks into the promised land
07:52:16 <mnislaih> god thanks I have the type system to help with my natural dumbness
07:52:19 <SimonRC> in fact, that applies to functional programming generally
07:52:31 <SimonRC> mnislaih: that's what it's there for
07:53:31 <SimonRC> it gives you hints as to what functions you need, and makes sure what you ask for can be sensibly done
07:58:48 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "Vote on a European #haskell get-together", "http://snappoll.com/poll/84228.php'
07:58:48 --- topic: set by kosmikus on [Mon Jun 12 09:18:44 2006]
08:00:25 <petekaz> What's the easiest way to serialize something in haskell?  Say I want to serialize a list of words and their definitions?  If I store those in a tuple, do I just use 'show' and 'read'?
08:01:45 <petekaz> Or is there an even easier way?  Any primitives to read a file that contains all of my tuples?
08:03:57 <nealar> Data.Bits or something
08:04:20 <mnislaih> you want to use the Storable class in that case
08:05:25 <petekaz> I'm just writing a small CGI program that will generate vocab quizzes.
08:05:40 <petekaz> I'll look up both Data.Bits and Storable.
08:40:27 <fanopnaic> did anybody have and solve the "ghc-6.2.2: unable to load package `base'" problem on openbsd 3.9?
09:23:18 <mnislaih> :r
10:22:22 <SimonRC> Is it morally wrong to program in an imperative style in Haskell?
10:23:02 <Korollary> no
10:23:13 <SimonRC> Ah, good, I feel my problem is naturally an imperitive problem in some parts, and functional purity would be horrible, with lots of state being passed abck and forth.
10:24:31 <SimonRC> :-)
10:27:33 <int-e> use a monad
10:27:42 <SimonRC> I tried that.
10:27:49 <int-e> (does that mean it's imprative in style?)
10:28:06 <SimonRC> I ended up with 3 different monads and hundreds of lines of plumbing code.
10:28:17 <SimonRC> I am going to try ST next
10:29:00 <int-e> ST is fun
10:29:32 <koffein> ST?
10:29:44 <int-e> Control.Monad.ST
10:29:56 <koffein> does what?
10:30:10 <SimonRC> imperativ programming
10:30:16 <int-e> hmm, I guess you could say it's an IO monad restricted to memory operations
10:30:31 <SimonRC> needs universal qualification, so not availble in normal Haskell
10:30:33 <int-e> so you have mutable arrays
10:30:46 <int-e> but no file access
10:30:46 <SimonRC> yup
10:31:05 <koffein> a way down to the raw metal
10:31:09 <koffein> or part of it
10:31:29 <SimonRC> it's a bit like C.M.State, but with invisible states
10:31:38 <int-e> Well, getting within a factor of 2 to 3 of C is possible.
10:32:28 <int-e> (But C beats Haskell at that stuff, the Haskell code ends up being unreadable. At least it does when I use ST.)
10:32:52 <int-e> maybe it's my fault :)
10:33:17 <norpan> i wonder what could be considered morally wrong in programming style
10:33:54 <SimonRC> I was not being terribly serious
10:33:57 <koffein> ugly indentation
10:34:06 <koffein> very wrong
10:34:19 <norpan> wrong perhaps, but morally wrong?
10:34:25 <int-e> norpan: 'gotos considered harmful' ;)
10:34:25 <Korollary> bragging in your comments
10:34:32 <norpan> bragging is wrong
10:34:57 <int-e> let a = b + 1 -- let a be the sum of b and 1
10:35:03 <Korollary> sexist function names
10:35:15 <norpan> if (i = 0) { // do this when i is 0
10:35:20 <koffein> making the job intentionally harder for the guy who has to maintain it
10:35:25 <int-e> really, there are many programming sins
10:35:31 <int-e> norpan: heh.
10:35:42 <int-e> norpan: was the '=' intentional?
10:35:48 <norpan> of course
10:35:55 <norpan> that's what made it morally wrong
10:36:02 <int-e> ah.
10:36:16 <int-e> is 2["unix"] morally wrong?
10:36:31 <norpan> in c it's at least confusing...
10:37:51 <int-e> > let x x = x where x = 23 in x 42 -- is this morally wrong?
10:37:57 <lambdabot>  23
10:38:10 <SimonRC> See the essay "how to write unmaintanable code" for an hour or so of entertainment and education.
10:38:40 <joe_k> ooh haskell is like PL/I then!
10:38:49 <joe_k> IF IF = THEN THEN THEN = IF ELSE ELSE = IF
10:40:19 <int-e> that doesn't do anything does it?
10:40:27 <int-e> oh
10:40:44 <int-e> the else=if probably does
10:40:56 <joe_k> well no not really, because it assigns a variable thats already been found equal to what its being assigned to
10:41:04 <joe_k> but such code is legal in pl/i
10:41:14 <int-e> it's not legal in haskell :)
10:41:40 <norpan> some of the people who used to work where i work seem to have followed that essay to the letter
10:43:44 <koffein> for example?
10:45:04 <norpan> the section on naming is spot on
10:45:29 <norpan> sub-functions are called DoTheWork and stuff like that :)
10:46:02 <int-e> WithNineWordsIGet512DifferentCamelCaseVariations
10:46:26 <neologism> norpan: people here in 1st year used to name variables liek "var1, var2, var3 ... varN"
10:46:53 <koffein> nice
10:47:11 <int-e> int intVar1; float floatVar1; ...
10:48:27 <koffein> foo and bar are better than that
10:48:40 <koffein> even*
10:49:00 <koffein> cause you can't confuse them
10:49:36 <neologism> int function132(int var1, float var2) {if (var1 == var17) {var32 = var8 - var2} return var1 - var2}
10:49:39 <neologism> lovely ;)
10:50:36 <norpan> here is another one they've practised: global variables are bad so instead the have one global struct so the only have one global var
10:51:45 <Korollary> it's a singleton! ;)
10:56:44 <int-e> hmm, I hope it's an object with settable properties so the global state is easily extensible
10:56:58 <int-e> (and noone needs to document the global variables they use anywhere)
11:01:55 <norpan> of course there is also the nice global setProperty stuff that makes how many global variables you like
11:03:00 <int-e> good.
11:07:07 <apfelmus> globabble varuables? setProsperty? what complicated and intriguing programming languages are  you talking about?
11:07:32 <norpan> setProsperty is even better
11:07:40 <norpan> this is in java/c++ actually
11:07:50 <jer> java... globals?
11:08:01 <norpan> yes
11:08:13 <jer> norpan, now you have me intrigued
11:08:13 <norpan> static classes
11:08:16 <jer> oh i see
11:08:20 <jer> not real globals then
11:08:29 <norpan> as real as any other globals
11:08:56 <jer> perhaps in usage, not in how they are implemented. java doesn't have globals
11:09:10 <norpan> then what is a static class if not a global?
11:09:40 <apfelmus> it's something electrifying, like a static band
11:10:54 <norpan> anyway
11:11:15 <norpan> they are tantamount to golbal variables and have the same problems
11:21:38 <lispy> norpan: yeah, but they call it the 'singleton' pattern and somehow that makes it all okay.  (actually, i think global variables have their place, but it requires great discipline to use them 'correctly')
11:22:46 <Philippa> I'd rather module-scope variables than globals, as that acknowledges the possibility you might, sometime, become part of a bigger system. But otherwise yeah
11:23:18 <norpan> well singleton objects have their place i guess
11:23:57 <norpan> but in my opinion (and i know a great deal about it) object orienting is the primary tool for code obfuscation available :)
11:29:32 <Philippa> I said modules rather than objects for a reason :-)
11:29:50 <Philippa> I prefer not blending all my useful concepts into a big mess...
11:31:08 <norpan> i would like oo + pattern matching on objects
11:31:20 <lispy> norpan: then checkout scala
11:31:58 <lispy> i'd would describe it as a cross between python and ocaml inspired by haskell and compiled to java bytecode
11:32:03 <Oejet> norpan: Pattern matching on object values or object types?
11:32:29 <Philippa> Oejet: this is why I don't like 'object' as a language-level concept :-)
11:32:44 <norpan> Oejet: on both
11:33:38 <Oejet> lispy: That reminds me of http://home.cs.tum.edu/~mai/poly.sh.pl.tcl.cpp.bf.py.c.lhs.txt .
11:33:50 <lispy> norpan: http://scala.epfl.ch/intro/patmatch.html
11:33:53 <lambdabot> Title: "The Scala Programming Language: Pattern Matching"
11:34:00 <lispy> Oejet: i'll take a look
11:34:18 <lispy> Oejet: hehe, quite different than that
11:34:41 <norpan> interesting
11:36:07 <lispy> scala has a lot of potential, but i don't like the syntax very much
11:36:35 <lispy> and it's more closely related to ML than haskell and so that takes a fair bit of getting used to
11:37:21 <lispy> probably the biggest turn off syntax-wise is that you can't separate type signatures from function definitions
11:38:39 <norpan> doesn't bother me
11:40:00 <neologism> any native speaker here?
11:40:10 <norpan> native speaker of what? haskell?
11:40:19 <neologism> of english :)
11:40:25 <norpan> sorry
11:44:33 <lispy> neologism: i am
11:46:08 <MarcWeber> How is the function called which does the opposite of concat?
11:46:23 <lispy> decat?
11:46:29 <lispy> @hoogle concat
11:46:30 <lambdabot> Prelude.concat :: [[a]] -> [a]
11:46:30 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
11:46:30 <lambdabot> Data.PackedString.concatPS :: [PackedString] -> PackedString
11:46:45 <lispy> @hoogle [a] -> [[a]]
11:46:46 <lambdabot> List.inits :: [a] -> [[a]]
11:46:46 <lambdabot> List.tails :: [a] -> [[a]]
11:46:46 <lambdabot> List.group :: Eq a => [a] -> [[a]]
11:47:00 <Lemmih> What's the opposite of concat?
11:47:10 <lispy> @hoogle split
11:47:10 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
11:47:10 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
11:47:10 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
11:49:04 <SimonRC> Ah, you evidently need the function that takes a list and splits it up into sublists non-deterministically. ;-)
11:49:06 <lispy> @hoogle Int -> [a] -> ([a], [a])
11:49:07 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
11:49:26 <neologism> lispy: have solved that... thnx
11:49:28 <lispy> i would bet that splitAt is probably the closest to what MarcWeber wants
11:49:35 <MarcWeber> ;)
11:49:44 <MarcWeber> It's missing
11:50:01 <lispy> > splitAt 4 [1..10]
11:50:02 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
11:50:49 <MarcWeber> > foldr (\b a -> (a:[]):b) [] [1,2,3]
11:50:50 <lambdabot>    Occurs check: cannot construct the infinite type: a = [[a]]
11:50:50 <lambdabot>    Expect...
11:51:02 <zarvok> > splitAt 0 [1..10]
11:51:03 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
11:51:37 <MarcWeber> > foldr (\a b -> (a:[]):b) [] [1,2,3]
11:51:38 <lambdabot>  [[1],[2],[3]]
11:52:07 <hyrax42__> > map return [1..3]
11:52:08 <lambdabot>  add an instance declaration for (Show (m a))
11:52:19 <hyrax42__> > map return [1..3] :: [[Int]]
11:52:20 <lambdabot>  [[1],[2],[3]]
11:53:05 <lispy> > map (:[]) [1..3]
11:53:06 <lambdabot>  [[1],[2],[3]]
11:53:56 <hyrax42__> (:[]) is a funny-looking function
11:54:28 <lispy> yeah, i'm at odds as to which on is clearer, the one with return or the one with (:[])
11:54:56 <lispy> return requires that type signature and knowledge of monads, but (:[]) is just odd to read
11:55:30 <hyrax42> not sure
11:55:56 <hyrax42> wrap x = [x]
11:56:34 <hyrax42> > map wrap [1..3] where wrap x = [x]
11:56:35 <lambdabot>  Parse error
11:56:47 <hyrax42> > map wrap [1..3] where {wrap x = [x]}
11:56:47 <lambdabot>  Parse error
11:56:58 <lispy> use a let
11:57:06 <hyrax42> how come
11:57:13 <lispy> > let wrap x = [x] in map wrap [1..4]
11:57:14 <lambdabot>  [[1],[2],[3],[4]]
11:57:27 <lispy> maybe your {} are in the wrong place?
11:57:34 <hyrax42> mebbe
11:57:45 <lispy> > map wrap [1..3] { where wrap x = [x]}
11:57:45 <lambdabot>  Parse error
11:58:00 <dmhouse> I think that's because inputs to lambdabot execute as if they were in a do-block.
11:58:12 <dmhouse> Actually, no, that doesn't make sense. Never mind.
11:58:41 <lispy> oh, i bet you seend a semi
11:58:42 <dmhouse> Certainly a top-level binding 'foo = map wrap [1..3] where wrap x = [x]' is valid.
11:58:47 <lispy> > map wrap [1..3]; where wrap x = [x]
11:58:48 <lambdabot>  Parse error
11:59:07 <dmhouse> > let foo = map wrap [1..3] where { wrap x = [x] } in foo
11:59:08 <lambdabot>  [[1],[2],[3]]
11:59:19 <dmhouse> In fact,
11:59:23 <dmhouse> > let foo = map wrap [1..3] where wrap x = [x] in foo
11:59:24 <lambdabot>  [[1],[2],[3]]
12:00:03 <dmhouse> > let in foo = map wrap [1..3] where wrap x = [x]
12:00:04 <lambdabot>  Parse error
12:00:09 <dmhouse> > let in map wrap [1..3] where wrap x = [x]
12:00:09 <lambdabot>  Parse error
12:00:26 <dmhouse> > let in ()
12:00:27 <lambdabot>  ()
12:00:32 <dmhouse> > let in x where x = 4
12:00:32 <lambdabot>  Parse error
12:00:45 <dmhouse> > let in { x where x = 4 }
12:00:45 <lambdabot>  Parse error
12:01:02 <hyrax42> boo
12:01:32 <dmhouse> > let in { let x = () in x }
12:01:32 <lambdabot>  Parse error
12:01:51 <dmhouse> Okay, a more serious question :)
12:01:59 <lispy> dmhouse: no
12:02:00 <ndm> let is an expression, where is a statement
12:02:24 <Lemmih> Say what?
12:02:30 <dmhouse> ndm, I think technically where is a 'clause'. Statements are the things in do-blocks. do { stmts }.
12:02:47 <ndm> dmhouse: you are probably right
12:03:45 <dmhouse> What would be a good example usage for existentials? I've got a heterogeneous list. I know ST uses existentials but its usage isn't exactly easy. :) Any suggestions?
12:04:07 <Sebo> hi
12:04:20 <Korollary> Lemmih: Is there a conjure wiki? I can't tell what the high level progress status is.
12:04:30 <zarvok> hi
12:04:42 <Lemmih> Korollary: No, there isn't one.
12:04:48 <Sebo> How can  I define a datatype with an infinite list e.g data Polynom = Polynom ...
12:05:06 <dmhouse> Sebo: What do you mean?
12:05:21 <dmhouse> data Stream a = Cons a (Stream a) is an infinite-list datatype.
12:05:29 <dmhouse> But I'm not sure that's what you mean.
12:05:47 <hyrax42> conjure is the bt client?
12:05:56 <Lemmih> hyrax42: Yes.
12:05:57 <Korollary> hyrax42: yes
12:05:58 <Sebo> hm
12:06:51 <lispy> Sebo: you want to define polynomials? is this a homework exercise?
12:06:58 <Sebo> Polynom should be defined as data Polynom = Polynom [Float] , but is there a possibilty that length [Float] = infinity
12:07:07 <Sebo> yes it is
12:07:18 <Sebo> ;)
12:07:29 <dmhouse> Sebo, what you have is fine.
12:07:36 <lispy> Sebo: ah okay, I an example that turns [a] into polynomials, but i won't show you since it's homework :)
12:08:00 <dmhouse> Sebo, Haskell can deal with infinite lists.
12:08:03 <dmhouse> > take 10 [1..]
12:08:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:08:08 <dmhouse> > [1..]
12:08:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:08:11 <zarvok> Sebo: haskell is lazy, so you don't have to worry about the possiblity the lsit is infinite
12:08:24 <Sebo> I knew that
12:08:27 <dmhouse> Hrm. Can't you use existentials with newtypes?
12:09:03 <Sebo> I thought data is better
12:09:23 <dmhouse> Sebo, this isn't related to your problem.
12:09:23 <Sebo> is there a possibility to fix the list [Float] to infinity
12:09:39 <zarvok> I'm not sure I know what you mean
12:09:45 <lispy> Sebo: not sure what you mean, but i don't think you'd want to
12:09:49 <Sebo> sry my englisch is bad
12:09:51 <dmhouse> Sebo: yeah. Think about infinite lists. What makes them different from finite lists?
12:10:11 <lispy> dmhouse: the letters 'in' ;)
12:10:32 <zarvok> :)
12:10:58 <dmhouse> Sebo: In terms of their constructors, how do infinite lists and finite lists differ?
12:11:28 <Sebo> by length ?
12:11:44 <dmhouse> Think about it like this:
12:11:47 <Dreadshoot> > fst ("C++", "Haskell")
12:11:48 <lambdabot>  "C++"
12:11:52 <dmhouse> Here's a finite list. 1:2:3:4:5:[].
12:12:06 <Sebo> ok
12:12:10 <dmhouse> Here's an infinite list: 1:2:3:4:5:...
12:12:16 <dmhouse> What's missing from the infinite one?
12:12:28 <Sebo> the operator []
12:12:39 <lispy> @type []
12:12:40 <lambdabot> forall a. [a]
12:12:41 <Sebo> replaced by ... ?
12:12:53 <lispy> Sebo: it's probably better to call [] a value
12:12:54 <dmhouse> Sebo: right. Normal lists are defined like this:
12:13:00 <dmhouse> lispy: more a constructor.
12:13:09 <dmhouse> data [a] = [] | a : [a]
12:13:34 <dmhouse> Now, if we want only infinite lists, we're not allowing the use of []. So our new datatype would be... ?
12:14:17 <Sebo> data [a] = a : [a]
12:14:21 <Sebo> i got it thanks
12:14:50 <dmhouse> Right.
12:14:58 <dmhouse> An infinite list is normally called a 'Stream'
12:15:09 <dmhouse> So you'll have something like data Stream a = Cons a (Stream a)
12:15:38 <Sebo> ok
12:16:10 <dmhouse> The only way to construct Stream values is to use recursion.
12:16:17 <dmhouse> For example, the infinite stream of ones:
12:16:24 <dmhouse> ones :: Stream Int
12:16:29 <dmhouse> ones = Cons 1 ones
12:17:24 <Sebo> I should remember my last exercise : data Tree a w = Branch (Tree a w) (Tree a w) | Leaf a w deriving(Read, Show, Eq)
12:17:25 <Sebo> ;)
12:17:26 <Korollary> Lemmih: Is there a mailing list? How do you communicate with others?
12:17:38 <Sebo> ok thanks
12:17:52 <Sebo> goodbye
12:18:26 <dmhouse> So, any suggestions for my question about existentials examples?
12:18:40 <dmhouse> What would be a good example usage for existentials? I've got a heterogeneous list. I know ST uses existentials but its usage isn't exactly easy. :) Any suggestions?
12:22:48 <zarvok> dmhouse:  I don't know anything about how they work in haskell, but usually OOP examples work
12:23:10 <zarvok> bob harper's book at got a
12:23:10 <zarvok>           heterogeneous list. I know ST uses existentials but its usage isn't
12:23:10 <zarvok>           exactly easy. :) Any suggestions?
12:23:10 <zarvok>  SignOff rzy: #haskell (Connection timed out)
12:23:10 <zarvok>  gdsx [n=xsdg@XSDG.MIT.EDU] has joined #haskell
12:23:10 <zarvok> <zarvok> dmhouse:  I don't know anything about how they work in haskell, but
12:23:13 <zarvok>           usually OOP examples work
12:23:14 <zarvok>  [03:22pm][zarvok(+eiw)] [#haskell(+n)]                                        
12:23:16 <zarvok>  [Lag  0] [O/0 N/186 I/0 V/0 F/0]                                   [U:a:S:b:h]
12:23:20 <zarvok> shit, oops
12:23:38 <lispy> zarvok: oh man, you'll get banned for sure now
12:23:47 --- mode: ChanServ set +o dmhouse
12:23:49 <dmhouse> Right.
12:23:57 <dmhouse> :)
12:23:59 <zarvok> heh
12:24:16 <zarvok> bob harper's book at http://www.cs.cmu.edu/~rwh/plbook
12:24:17 <lambdabot> Title: "Index of /~rwh/plbook"
12:24:27 <zarvok> has some good examples of existentials for oop stuff
12:24:34 --- mode: ChanServ set -o dmhouse
12:24:37 <lispy> i used to have an ibm laptop and sometimes the little red mouse button thing would freakout and move all over the screen and send mouse clicks...since i was using X this meant that it would paste *whatever* was in the clip board buffer
12:24:44 <zarvok> of course, his language is eager, adn I have no idea how it meshes with the haskell stuff
12:25:00 <zarvok> yes, I am in a computer lab with really terrible mice
12:25:01 <lispy> i uh...had a bit of an accident in #lisp once and stopped hanging out there for a while ;)
12:25:03 <zarvok> it's a problem
12:25:05 <zarvok> hahaha
12:26:37 <int-e> was that choice a voluntary one?
12:27:42 <lispy> int-e: if you're asking me, yeah i was embarrased by the flood pasting...
12:28:14 <zarvok> dmhouse: anyway, I found his presentation of using existentials for data abstraction and oop stuff enlightening
12:29:06 <apfelmus> dmhouse: mh existentials? so you wanna kind of exshow :: [forall a . Show a => a] -> [String]
12:30:09 <dmhouse> apfelmus: MH?
12:30:23 <dmhouse> apfelmus: And I've already got the example of a hetero list.
12:30:43 <Lemmih> Korollary: We usually talk on IRC.
12:30:55 <apfelmus> dmhouse: ah, you wanna something more INTRICATE, hehe...
12:31:10 * dmhouse doesn't get it
12:32:24 <apfelmus> dmhouse, as far as i understand you, you want a different existential example than heterogenous lists and runST?
12:33:00 <dmhouse> Right.
12:34:00 <apfelmus> dmhouse: so some example that's more INTRICATE, hehe...
12:35:16 <dmhouse> apfelmus: Err, yes. Sorry, is there an pun I'm missing?
12:35:23 <dmhouse> Perhaps you should just give up on me as a lost cause.
12:36:30 <apfelmus> dmhouse: no, i'm just kidding :) existentials are nothing really complicated (when you don't have to write the type inference engine, of course)
12:37:08 <dmhouse> Existentials are a bit complicated if you don't know how to use them properly. You get error messages that begin with 'My brain just exploded!', which are a little uncomforting to the newbie.
12:37:51 <apfelmus> dmhouse: ah, you have a concrete problem. paste?
12:38:30 <dmhouse> No, no. I'm writing a wikibook chapter on existentials.
12:38:36 <dmhouse> I'm just speaking from experience :)
12:39:38 <zarvok> do you know offhand how I can enable existentials in GHCi?
12:39:50 <zarvok> (now you've made me want to play around)
12:40:02 * apfelmus hopes dmhouse got a new head as he finds exploded heads disgusting
12:40:19 <dmhouse> zarvok: -fglasgow-exts
12:40:21 <Korollary> zarvok: check the ghc user's guide. glasgow exts
12:40:29 <dmhouse> zarvok: http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
12:40:31 <lambdabot> Title: "7.4. Type system extensions"
12:41:17 <zarvok> thanks much
12:44:55 <dmhouse> zarvok: you might also want to read http://en.wikibooks.org/wiki/Haskell/Existentially_qualified_types
12:45:05 <dmhouse> (Shameless plug: I just wrote that :))
12:45:20 <dmhouse> (Disclaimer: as I just wrote that, it's probably quite rubbish.)
12:45:56 <zarvok> I'll have a look, thanks
12:46:13 <apfelmus> dmhouse: an example would be from the wiki "continuations done right". the type of callCC becomes callCC :: ((forall b . a -> Cont r b) -> Cont r a) -> Cont r a
12:46:40 <dmhouse> apfelmus: used for similar reasons to runST?
12:47:01 <apfelmus> dmhouse: indeed.
12:47:57 <dmhouse> apfelmus: Feel like flexing your tutorial-writing muscles? :) http://en.wikibooks.org/wiki/Haskell/Existentially_qualified_types could do with a second example.
12:49:38 <apfelmus> dmhouse: first excuse: i'm not a poet. second excuse: i wont deprive you of your fame :)
12:50:00 <dmhouse> Pah. Well, both continuations and ST baffle me.
12:50:02 <dmhouse> :)
12:53:10 <zarvok> dmhouse: unfortunately, I've got to get back to work.  If I have time tonight I may try to come up with a good OOP-like example, though, if I find one I'll e-mail you or something
12:53:21 <hyrax42> dmhouse: could you not derive Show in that example
12:53:35 <dmhouse> zarvok: That'd be great. If you want to write the chapter yourself, that would be even better :)
12:53:44 <zarvok> yeah, I noticed derving show doesn't work for existential types
12:53:48 <dmhouse> hyrax42: you can't derive stuff with existentials.
12:53:50 <dmhouse> Reason:
12:53:52 <zarvok> heh, well, hopefully I'll find the time
12:54:00 <dmhouse> Consider data Foo = Eq a => Foo a
12:54:06 <dmhouse> deriving Eq
12:54:14 <dmhouse> The compiler tries to write something like:
12:54:30 <dmhouse> (Eq a) == (Eq b) = ... ? a and b are of distinct types. How do you compare them?
12:54:37 <hyrax42> oh right
12:54:42 <hyrax42> but show is unary
12:54:46 <hyrax42> is why I thought it i guess
12:55:05 <Sebo> hm, same problem : data Polynom = Polynom (Float:[Polynom]) didn't work :(
12:55:13 <dmhouse> zarvok: :)
12:55:43 <dmhouse> Sebo: you need to make that datatype I described, then use data Polynom = Polynom (Stream Float)
12:55:57 <dmhouse> zarvok: If you do find the time, thanks in advance.
12:56:15 <Sebo> ok
12:56:24 <apfelmus> dmhouse: come on, ST is nothing to baffle you. see, if runST had the type runST :: ST s a -> a, one could do runST (newSTRef ()) :: STRef s () and you get a mutable variable floating around
12:57:20 <dmhouse> Yeah, actually ST isn't that bad. Perhaps I could write about that.
12:57:25 <apfelmus> look how the type s "escapes"
12:58:09 <dmhouse> Do you mean runST (newSTRef () :: STRef s ()) ?
12:58:21 <apfelmus> dmhouse: yes
12:58:31 <dmhouse> @type Control.Monad.ST.newSTRef
12:58:32 <lambdabot> Not in scope: `Control.Monad.ST.newSTRef'
12:58:37 <Sebo> this one ? data Stream a = Cons a (Stream a) but it is no list
12:58:40 <dmhouse> @hoogle newSTRef
12:58:40 <lambdabot> Data.STRef.newSTRef :: a -> ST s (STRef s a)
12:58:47 <Sebo> ok its a list
12:58:51 <apfelmus> the point of the forall s is, that the type of a may in no way depend on s. but in our case, a = STRef s () does.
12:58:52 <Sebo> but no haskell list
12:59:08 <dmhouse> Sebo: nope. As I said, the only way to create values for it would be to use recursion.
12:59:49 <dmhouse> Sebo: why exactly do you want to limit it to infinite lists anyway?
12:59:53 <Sebo> dmhouse, ok so i can't create a infinite list with of Float with data?
13:00:28 <Sebo> [2,3,4,0] should be the same polynom as [2,3,4]
13:00:48 * apfelmus may not miss crime time
13:01:10 <lispy> Sebo: well, making [2,3,4,0] be the same polynom as [2,3,4] is a matter of equivalence
13:01:18 <Sebo> yes 
13:01:31 <Sebo> i can define it in instance of eq
13:01:50 <lispy> another thing to remember is that all polynomials are finite
13:01:54 <lispy> (in lengeth)
13:02:13 <Sebo> but it would be nicer
13:02:19 <dmhouse> lispy: They are?
13:02:27 <hyrax42> well a finite number of non-zero coefficients
13:02:34 <Sebo> yes
13:02:41 <lispy> dmhouse: yes, there are objects like polynomials that are infinite in length, but they are not polynomials exactly
13:02:57 <Sebo> the list should look like [2,3,4,0,0,0..]
13:03:12 <hyrax42> Sebo: it need nt
13:03:13 <hyrax42> not
13:03:36 <Sebo> but it would be cool ;)
13:03:47 <lispy> Sebo: so lets say you stored [2,3,4] as [2,3,4] ++ repeat 0
13:04:03 <lispy> Sebo: how would the eq instance be defined now?
13:04:40 <lispy> > take 10 ([2,3,4] ++ repeat 0)
13:04:41 <lambdabot>  [2,3,4,0,0,0,0,0,0,0]
13:04:42 <Sebo> ok thats a problem :)
13:05:02 <Sebo> I don't know where to stop then
13:05:22 <lispy> yeah, so you might as well only store the finite part of the polynomials
13:05:47 <lispy> and then be able to pad them with an arbitrary number of zeros 
13:06:00 <xerox> > let polyEq = (all (==EQ) .) . zipWith compare in polyEq [2,3,4] ([2,3,4] ++ repeat 0)
13:06:01 <lambdabot>  True
13:06:02 <Sebo> yes that would be better
13:06:10 <Sebo> yes
13:06:33 <dmhouse> > let polyEq = (and .) . zipWith (==) in polyEq [2,3,4] ([2,3,4] ++ repeat 0)
13:06:34 <lambdabot>  True
13:06:56 <xerox> Talking of Eq instance I thought about using Eq functions and datatype.
13:07:26 <dmhouse> > let polyEq = (all (uncurry (==)) .) . zip in polyEq [2,3,4] ([2,3,4] ++ repeat 0)
13:07:27 <lispy> > polyAdd = zipWith (+) in ([1,2,3] ++ repeat 0) `polyAdd` ([2,3,4] ++ repeat 0)
13:07:27 <lambdabot>  True
13:07:27 <lambdabot>  Parse error
13:07:36 <lispy> > let polyAdd = zipWith (+) in ([1,2,3] ++ repeat 0) `polyAdd` ([2,3,4] ++ repeat 0)
13:07:37 <lambdabot>  [3,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:07:37 <Sebo> :)
13:08:11 <xerox> Why you would descrybe a polynomial like this, anyway?
13:08:49 <lispy> xerox: it's a quick and simple reperesentation?
13:08:55 <Sebo> you should go to me mathematics lectures
13:08:56 <Sebo> ;)
13:09:17 <xerox> I mean I don't understand what [2,3,4]++repeat 0 represent.
13:09:31 <hyrax42> canonicalise = reverse . (dropWhile (==0)) . reverse
13:09:50 <dmhouse> hyrax42: reversing an infinite list? Nice trick.
13:10:13 <hyrax42> :p
13:10:21 <dmhouse> Storing them like that makes comparing polynnomials impossible.
13:10:22 <hyrax42> well I'm thining this infinite list of zeros is a waste of time
13:10:26 <lispy> xerox: oh, i was trying to make the point that you don't really want to store the polynomial with all the extra zeros, you just want to be able to add them on when you need them
13:10:40 <Sebo> xerox, 2*x^0  + 3*x^1 + 4*x^2 + 0*x^3 + ...
13:10:53 <Sebo> hyrax42, yes it is ;)
13:14:07 <Sebo> gn9
13:19:19 <kaol> I coded a plasma height field generator in Haskell. It was educational.
13:20:17 <lispy> kaol: heh, fun
13:22:19 <dmhouse> When are phantom types useful?
13:22:41 <xerox> Deja vu.
13:23:18 <lispy> dmhouse: when you want to add a bit more information that is required
13:23:26 <dmhouse> lispy: such as?
13:23:33 <dmhouse> xerox, well, I wasn't answered the first time :)
13:23:50 <lispy> dmhouse: :)
13:24:07 * lispy was being a smart ass and now has to fess up that he doesn't know
13:24:55 <lispy> dmhouse: http://www.haskell.org/hawiki/PhantomTypes
13:24:57 <lambdabot> Title: "PhantomTypes - The Haskell Wiki"
13:25:17 <lispy> dmhouse: so when you have a big union type you can use phantom types to bring some sanity back
13:38:15 <dmhouse> Anyone recommend a good contuniations tutorial? I'm yet to find one.
13:44:22 <lispy> dmhouse: i read one in ruby once that helped a lot even though i don't know ruby
13:46:16 <dmhouse> lispy: URL?
13:47:43 <lispy> dmhouse: i'm having trouble with that part :)
13:47:51 <dmhouse> Hehe :)
13:49:12 <lispy> dmhouse: http://idea-log.blogspot.com/2005/10/why-are-continuations-so-confusing-and.html
13:49:13 <dmhouse> I think I get the general point of CPS, but it's grokking specific things like callCC which is worrying me.
13:49:14 <lambdabot> Title: "idea.log: Why Are Continuations So Confusing, and What Do They Really Do?"
13:49:40 <Korollary> dmhouse: read any scheme tutorial
14:03:31 <bolrod> geniuz
15:45:02 <petekaz> Hmm .. the Text.HTML library is neat.
15:46:23 <petekaz> I'm not very familar with combinator libraries so it's very novel for me.
15:47:51 <petekaz> I love how all of the tags are really just partially applied functions.
15:48:09 * petekaz just realized how dead #haskell is on the weekends
15:50:07 <lispy> heh
15:50:34 <lispy> yeah, seems unsually dead to me...perhaps colleges are out for the summer months in the norther hemi has something to do with it?
15:50:45 <lispy> (or maybe that doesn't affect europe...i reallydon'tknow)
15:51:04 <petekaz> Don't Europeans get the whole summer off?
15:51:25 <petekaz> Or at least the scandanavian countries?
15:51:53 <madpickle> off from what?
15:51:54 <madpickle> O.o
15:51:58 <petekaz> vacation?
15:52:01 <madpickle> standard is 5 or 6 weeks vacation
15:52:13 <madpickle> and people wanna take time off for easter and x-mas too
15:52:13 <petekaz> yeah, that's crazy in the US>
15:52:42 <petekaz> I get a measely 3 weeks, but I take 4 anyways (no one tracks it).
15:52:45 <lispy> petekaz: it's for historical agricultural reasons
15:52:56 <madpickle> most people don't want 5 or 6
15:53:02 <madpickle> + bank holidays and whatnot
15:53:06 <madpickle> more time with the kids
15:53:10 <madpickle> some people just wanna go back to wokr
15:53:35 <lispy> actually, some highschools in cities in the US are now doing full year school, but each 'group' gets a 3 month break and the groups that are in session rotate
15:53:40 <madpickle> i think the american comedian Bill Hicks said it best: "Kids? The kids are the smart ones -- THEY don't have kids nor do they have to get up each morning and go to fucking work"
15:53:48 * petekaz goes to eat dinner
15:53:50 <madpickle> meh, university in the uk is worse
15:53:54 <madpickle> 1 month easter
15:53:57 <madpickle> 3 weeks of x-mas
15:54:02 <madpickle> 3 months of summer vacation
15:54:08 <madpickle> we do bupkis
15:54:56 <cjay> bupkis?
15:55:42 <thetallguy>  bupkis = nothing
16:01:18 <wolverian> 1 month easter? wow.
16:01:20 <wolverian> sign me up :)
16:03:51 <SimonRC> wolverian:    http://www.dur.ac.uk/dates/
16:03:54 <lambdabot> Title: "Dates of meetings and events - Durham University"
16:04:32 <wolverian> haha, epiphany term 
16:19:08 <madpickle> http://www.houstonpress.com/Issues/2006-06-22/news/hairballs.html
16:19:10 <lambdabot> Title: "houstonpress.com | News | CSI: New Caney"
16:38:02 * SimonRC goes.
16:43:35 * psnl detects SimonRC causing trouble
17:18:44 <dropdrive>  /nsg nickserv identify asdfasdf
17:21:55 <petekaz> dropdrive: guess you better change your password.
17:27:29 <dropdrive> petekaz: perhaps, though i wonder who could possibly want to pretend to be me...
17:28:00 <petekaz> dropdrive: :-)
19:41:58 <Revision17> for a new project, is it better to use hsql or hdbc?
19:54:27 <Lemmih> I'd say hdbc.
19:55:02 <Revision17> thanks
20:53:54 <dons> ?yow
20:53:54 <lambdabot> I want another RE-WRITE on my CAESAR SALAD!!
20:58:49 <zarvok> anyone else watching the disaster in freenode-moderated?
20:58:51 <zarvok> it's priceless
20:59:05 <AtnNn> *nod*
20:59:14 <zarvok> They are voicing individual users who have questions, and they turn out to be GNAA plants
20:59:16 <zarvok> I love IRC
20:59:22 <Korollary> heh
21:00:22 <palomer> GNAA plants?
21:00:44 <zarvok> As in, GNAA member who troll as soon as they are voiced, instead of people with actual questions
21:00:48 <zarvok> members*
21:00:50 <palomer> GNAA?
21:00:56 <zarvok> they've just had like 3 in a row
21:01:13 <pimaniac> it's easiest to use the acryonym.
21:01:20 <palomer> WHAT DOES IT MEAN?
21:01:23 <zarvok> hahaha
21:01:23 <pimaniac> for some spelling of that.
21:01:44 <zarvok> wikipedia it or something
21:01:50 <zarvok> they are a group of trolls/hackers
21:02:33 <palomer> ahh yes, the gay niggers
21:03:54 <zarvok> yes, they are completely owning the freenode admins
21:03:56 <zarvok> it's very funny
21:05:15 <Korollary> was there an agenda behind all this, or is it just another entry in the general, random menace?
21:05:52 <zarvok> I think it's just more trolling
21:06:19 <zarvok> they have targeted freenode before
21:06:24 <Korollary> not wise. They should troll elsewhere to diversify their investment of time.
21:06:47 <zarvok> heh, well, the freenode management did go to the trouble of collecting all the users into one place
21:06:53 <zarvok> seems like prime trolling opportunity
21:07:13 <zarvok> with the current Q/A sessino, I mean
21:07:53 <zarvok> I have to go, later
21:10:49 <mtf> hi all, i'm trying to get wxhaskell examples to run on ubuntu dapper
21:11:07 <tessier> The "Q&A" is pointless. They haven't said squat about what happened.
21:11:27 <tessier> No idea if a password was compromised or if code was exploited or anything.
21:11:56 <tessier> They are holding a sort of "press conference" to tell us all that they really can't tell us anything.
21:12:43 <Korollary> maybe they have the former white house press secretary
23:33:01 <dons> ?brain
23:33:01 <lambdabot> I think so, Brain! How much deeper would the ocean be if there weren't sponges down there?
23:43:23 <zarvok> anyone know why I can't use named records inside an existentially quantified type?
23:48:43 <zarvok> anyone played with ghc's existential types at all?
23:59:25 <kosmikus> zarvok: sure
23:59:49 <dons> kosmikus: you pinged a couple of days ago?
