00:01:00 <Korollary> dons: heh, it feels weird to have to install fps before running the tests.
00:03:29 <Korollary> oops. I got an error.
00:06:06 <dons> yeah. you have to install first.
00:06:09 <dons> what kind of error?
00:06:37 <dons> oh, there's spellcheck.hs, it fails due to bit rot
00:06:40 <dons> but ll the properties should pass..
00:06:45 <dons> s/ll/all/
00:09:20 <Korollary> I got this:
00:09:37 <Korollary> Compiling QuickCheckUtils  ( ./QuickCheckUtils.hs, ./QuickCheckUtils.o )
00:09:57 <Korollary> Prologue junk?:         .type   s5Vr_dflt, @function
00:09:57 <Korollary> s5Vr_dflt: xorl    %eax, %eax movl    %eax, 4(%esp)
00:10:45 <dons> oh. that's the -optc level too high
00:10:53 <dons> very interesting
00:11:08 <dons> fixing...
00:12:19 <dons> can you try that fix just pushed?
00:14:46 <Korollary> how do I update my repository with darcs?
00:15:04 <int-e> darcs pull
00:15:06 <int-e> ?
00:16:34 <Korollary> hmm. You have to cd into "fps" to pull
00:17:31 <dons> sure.
00:28:50 <Korollary> ok, it made it past that point. Still running, tho.
00:29:56 <dons> still running, what do you mean? still testing?
00:30:02 <dons> there's a _lot_ of properties to test
00:30:27 <Korollary> yes
00:30:36 <dons> its very test-driven dev, or whatever they call it :)
00:30:51 <Korollary> ok, finished
00:32:07 <Korollary> why can't cabal satisfy FilePath-any, even though ghc-pkg lists FilePath-0.1 available in --user conf?
00:33:55 <Korollary> ah, I need to pass --user to configure
00:38:15 <Korollary> dons: Data.ByteString.Char8 doesn't export unsafeHead anymore (which broke conjure). Intentional?
00:38:23 <dons> its in Base.hs
00:38:52 <dons> all unsafe* are found only in Base.hs now. its intentional.
00:39:06 <dons> so people don't burn themselves on the stove
00:46:22 <Lokadin> burning yourself on the stove is rather painful i hear
01:08:06 <eivuokko> Is there any library that can be used to generate binary asm (x86 for now) in haskell?
01:08:51 <audreyt> yes.
01:09:10 <audreyt> AsmCodeGen.lhs and friends
01:10:40 <eivuokko> I wouldn't call it a library, being ghc backend, and it produces symbolic assembler (text).
01:10:59 <audreyt> oh. you want post-"as" assembly
01:11:06 <audreyt> I don't know of one
01:11:09 <eivuokko> I would like to generate asm and call it right away, in a program.  I'm not too happy including external assembler.
01:14:57 <dons> Haskell Weekly News: June 16, 2006 out now, http://sequence.complete.org/
01:15:02 <lambdabot> The title of that page is "The Haskell Sequence - News about Haskell"
01:15:29 <eivuokko> Good job :)
01:16:17 <dons> cheers
01:34:10 <Lemmih> @seen musasabi
01:34:10 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. I don't know when musasabi last spoke.
01:34:39 <xerox> dons - Woohoo, lambdabot release!
01:44:31 <giksos> I have a question: the ghc docs says "So you cannot make a forall-type the argument of a type constructor. ". Do I understand correctly that function type constructors "->" have special treatment in this respect?
01:47:43 <Lokadin> say would all Strings that the user see be in an IO () function?
01:48:06 <Lokadin> or at least called out of an IO function
01:49:00 <xerox> giksos: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
01:49:02 <lambdabot> The title of that page is "7.4. Type system extensions"
01:49:09 <Lemmih> Lokadin: Yes, no I/O outside of IO.
01:49:34 <giksos> xerox: thats exactly where I took the quote from :)
01:49:37 <Lokadin> alright, just checking ki'e
01:49:46 <Lokadin> (thanks)
01:50:30 <giksos> it says that you can have forall-types on the left and right of "->" but later it says that you cannot have forall-types as arguments of type constructors
01:50:56 <xerox> giksos - I think the example uses (->) because it doesn't need to put data declaration in the example, making it more complex. In principle it applies to every TyCon.
01:51:39 <Lokadin> say, so would all strings be from a putStr of some sort? (including putChar and the rest of them)
01:51:44 <xerox> E.g. data Mu = forall a. Mu a, or variation on the subject.
01:51:50 <Lokadin> i'm just thinknig of making a localization funciton
01:52:43 <giksos> xerox: I mean, you can have "(forall a. a -> a) -> b" but not "[forall a . a]". So type constructors "->" and "[]" are treated differently
01:52:52 <xerox> Lokadin - If your code doesn't need IO, it will not have `IO' in the type. If it does, it will have. What does your code do?
01:53:11 <Lokadin> well i have a shell
01:53:19 <xerox> ?type (undefined :: (forall a. a -> a) -> b)
01:53:21 <lambdabot> forall b. (forall a. a -> a) -> b
01:53:30 <xerox> ?type (undefined :: [forall a. a])
01:53:33 <lambdabot> parse error on input `forall'
01:53:41 <xerox> ?type (undefined :: forall a. [a])
01:53:42 <lambdabot> forall a. [a]
01:54:18 <xerox> giksos - I am not sure I understand.
01:54:34 <giksos> ok, i'll try to explain...
01:55:16 <giksos> "->" is a type constructor (of the kind * -> * -> *). So is "[]" (of the kind * -> *)
01:56:04 <giksos> now you can have a forall type (like "forall a. a") passed to the "->" constructor, but not to "[]" (like you saw before)
01:56:12 <xerox> (Me wonders what is a useful implementation of |(forall a. a -> a) -> Int -> Int|)
01:56:17 <lennart> yeah, -> is different
01:56:23 <xerox> Howdy ski_
01:56:50 <giksos> don't know, but Data.Generics for instance uses such functions
01:57:15 <lennart> xerox, there are no useful ones
01:57:28 <giksos> and I personally would find [forall a. MyConstraint => a] usefull as well :)
01:57:38 <lennart> since we already know what (forall a. a -> a) does
01:57:54 <xerox> undefined
01:58:05 <lennart> or identity
01:58:12 <giksos> but if it has a class constraint on it, it becomes useful!
01:58:13 <Lokadin> what does the => mean?
01:58:14 <xerox> Right.
01:58:38 <xerox> giksos - I think you can do that, with exist.
01:58:48 <Lokadin> @hoogle (=>)
01:58:50 <lambdabot> Did you mean: (=>)
01:58:50 <lambdabot> Prelude.undefined :: a
01:58:50 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
01:58:58 <dons> gday giksos
01:59:00 <Lokadin> o
01:59:19 <giksos> gday dons
01:59:40 <xerox> Lokadin: The syntax <name> :: <type> can be extended as <name> :: <constraints> => <type>. Do you know type classes?
01:59:52 <dons> @tell ndm hoogle buglet @hoogle (=>) --> Did you mean: (=>)
01:59:52 <lambdabot> Consider it noted.
01:59:59 <Lokadin> xerox: well i thought i did
02:00:11 <giksos> xerox: yes, I can. I was just wondering, if I understand it correctly that -> is treated differently from other type constructors. Seems so
02:00:34 <Lokadin> xerox: i'll look it up thanks :)
02:01:03 <Lokadin> unless you don't mind explaining
02:01:03 <xerox> Lokadin - A type class is a set of types. `Class a' says that the type `a' is a member of the set `Class'.  It is a constraint you can put in your <name> :: Class a => <type>.
02:01:39 <xerox> Thereby restricting the possible types `a' to be only the ones in the set `Class'.
02:02:21 <Lokadin> er so something like number :: Num => Int
02:02:22 <xerox> Also, you make types member of the set by means of instantiation; the syntax is: instance Class Type where <functions implementation>
02:02:46 <xerox> For example (+) hasn't type a -> a -> a.
02:02:52 <xerox> But it has type Num a => a -> a -> a
02:03:07 <Lokadin> oh
02:03:12 <Lokadin> cool :) i get that
02:03:20 <Lokadin> thanks! .i'osai
02:03:49 <xerox> You can do `:info Class' on the GHCi prompt to see which functions are defined under the class. And also which instances are loaded.
02:03:55 <xerox> @instances Num
02:03:56 <lambdabot> Double, Float, Int, Integer
02:04:08 <xerox> Ah, we have this now too, thanks to davidhouse (:
02:04:24 <xerox> (Which does indeed parse `:info Class'.)
02:04:34 <Lokadin> wow cool :)
02:04:53 <Lokadin> say are there are limited amount of Classes? or can you make your own?
02:05:01 <xerox> Sure you can!
02:05:25 <xerox> I think HaskellDemo shows it.
02:05:30 <xerox> ?oldwiki HaskellDemo
02:05:30 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
02:05:39 <Lokadin> cool thanks :) 
02:05:48 <Lokadin> .i'osai
02:05:56 <Lokadin> i was really confused after YAHT
02:06:03 <dons> ?unlambda .i'osai
02:06:04 <lambdabot> Done.
02:06:06 <dons> almost ;)
02:06:09 <xerox> haha
02:06:32 <Lokadin> what dooes that do?
02:06:34 <xerox> Lokadin: the syntax is just `class Name tyvars where <name> :: <type>'.
02:06:45 <dons> ?help unlambda
02:06:45 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
02:06:56 <dons> ?google unlambda
02:06:57 <lambdabot> http://www.madore.org/~david/programs/unlambda/
02:07:13 <dons> scary language of strict, impure combinators
02:07:38 <dons> the anti-lambda calc
02:07:58 <Lokadin> lol .uanai
02:08:08 <xerox> What does .i'osai mean?
02:08:16 <Lokadin> strong appreciation
02:08:29 <Lokadin> or rather, appreciation strong 
02:08:37 <xerox> In what language?
02:08:43 <Lokadin> i'o = the feeling of appreciation in lojban
02:09:12 <dons> ?unlambda ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk
02:09:12 <lambdabot> *
02:09:12 <lambdabot> *
02:09:12 <lambdabot> **
02:09:12 <lambdabot> ***
02:09:12 <lambdabot> *****
02:09:41 <dons> :)
02:10:40 <Lokadin> reminds me of brainfuck
02:12:41 <Lokadin> .u'isai @ unlambda, quite impressive
02:13:32 <xerox> ?unlambda .i'o
02:13:32 <lambdabot> Done.
02:13:54 <int-e> @unlambda `````sii``s``s`ks``s`k`s`ks``s``s`ksk``s`k`s``si`kik`k``s`ksk.*. #
02:13:55 <lambdabot> *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *
02:13:55 <lambdabot> *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *
02:13:55 <lambdabot> *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *
02:13:55 <lambdabot> *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *
02:13:57 <lambdabot> *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *
02:13:58 <int-e> hmm
02:14:00 <lambdabot> [6 @more lines]
02:14:11 <int-e> dons hasn't recompiled lambdabot yet
02:15:10 <giksos> I still wonder why [forall a. a->a] is forbidden. The same effect can be achieved by using existential data of course, but it's more cumbersome.
02:15:18 <dons> oh, maybe i should
02:15:39 <giksos> I mean just [forall a.a] 
02:16:09 <dons> giksos: it's at least a legal type with the new impredicative stuff,
02:16:10 <dons> Prelude> :t undefined :: [forall a. a]
02:16:11 <dons> undefined :: [forall a. a] :: [forall a. a]
02:16:25 <dons> whether there's anything interesting to put in that list, hmm.
02:16:40 <eivuokko> Keeping items alive, possibly.
02:16:48 <eivuokko> Say, foreignptrs
02:16:49 <giksos> as said before: if you add class constraints, it becomes interesting
02:16:52 <xerox> ?type ['a',"b",('c',"d")] :: [forall a. a]
02:16:54 <lambdabot> parse error on input `forall'
02:16:59 <dons> yeah
02:17:25 <xerox> ?type [1 :: Int,2 :: Double] :: [forall a. Num a => a]
02:17:26 <lambdabot> parse error on input `forall'
02:17:40 <dons> xerox, lambdabot only allows h98 + a few special extras
02:19:23 <giksos> dons: I tried ":t undefined :: [forall a. a]" in ghci -fglasgow-exts, doesn't work, I have 6.4.1
02:19:37 <dons> yep. you need  a recent 6.5 
02:19:46 <giksos> i see
02:20:21 <giksos> so the docs for 6.5 are not up-to-date? (they prohibit this)
02:20:52 <dons> hmm. possibly not. an issue of the weekly news from a few weeks back talks about the changes.
02:21:28 <int-e>     No instance for (Num (. (forall a) a)) ... hmm
02:21:29 <dons> here: http://www.cse.unsw.edu.au/~dons/code/hwn/archives/20060130.html
02:21:30 <lambdabot> The title of that page is "Haskell Weekly News: January 30, 2006"
02:21:47 * giksos reading
02:22:36 <int-e> funny. maybe the grammar shouldn't accept that stuff without -fglasgow-exts
02:23:32 <dons> ?quit unlambda limits
02:25:00 <dons> @unlambda `````sii``s``s`ks``s`k`s`ks``s``s`ksk``s`k`s``si`kik`k``s`ksk.*. #
02:25:00 <lambdabot> *  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * *  * *  *...
02:25:04 <dons> nice
02:37:30 <giksos> is there any documentation about "impredicative stuff"?
02:40:11 <dons> just the paper references in the news article, i thik
02:40:26 <dons> or hopefuly there's something in the darcs version of the ghc docs
02:41:25 <dons> there's a note in the docs for 6.6 to add a section on impredicative types
02:42:17 <giksos> yes, I see the paper now
02:42:28 <boegel> dons: maintaining HWN seems a time-consuming job?
02:43:06 <dons> it is :) its about 2 hrs a week
02:43:16 <dons> some tool support could help a bit.
02:44:05 <dons> probably i could get it down to an hour if i mechanised most tasks
02:45:00 <boegel> then you should mechanise them :)
02:47:46 <sylvan> I'm having anxiety attacks because I'm starting a new job soon where I'll have to use C++... Is that normal?
02:48:03 <giksos> )))
02:48:21 <int-e> no despair?
02:48:27 <sylvan> That too...
02:49:16 <sylvan> Haven't done any C++ in years..... Guess I'll have to bite the bullet and leave this wonderful Haskell-land
02:49:58 <dons> now, where's that C++ monad implementation? that should make you feel more relaxed..
02:50:32 <sieni> fc++ has something like that
02:50:49 <sylvan> hehe, maybe that's exactly what I need... The ultimate goal is to get them to convert to Haskell of course =)
02:50:55 <sieni> http://www-static.cc.gatech.edu/~yannis/fc++/FC++.1.5/monad.h
02:51:02 <dons> that's it.
02:51:21 <dons> why worry when you can code in monad.h :S
02:51:47 <sylvan> =)
02:51:54 <sieni> http://www.hurmio.org/~ville/template.html
02:52:01 <neologism> I wonder how many C++ programmers are able to think in such abstract way to use monads :)
02:52:27 <sylvan> sieni, that's *so* going on a t-shirt
02:53:41 <sieni> sylvan: that was kind of the idea :-) A colleague of mine had a similar t-shirt with Navier-Stokes equations in it instead of the template thingie and I got the idea from there :-)
02:54:12 <ndm> @seen dons
02:54:13 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2 minutes and 52 seconds ago.
02:54:27 <dons> @seen ndm
02:54:28 <lambdabot> ndm is in #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 15 seconds ago.
02:54:33 <Pete_I> there's an overflow channel? why?
02:54:41 <ndm> dons, have you seen my darcs-graph :) http://www-users.cs.york.ac.uk/~ndm/temp/yhc-patches.html
02:54:42 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:54:44 <lambdabot> The title of that page is "Darcs Statistics for Yhc"
02:55:00 <Cale> I like how the comments are in Haskell
02:55:19 <Pete_I> Cale, they're not bad
02:55:26 <dons> ndm, oooh. nice
02:55:33 <ndm> I only just saw your one announced on HWN
02:55:34 <dons> ndm, how'd you do that darcs graph?
02:55:48 <Cale> well, some anyway
02:55:52 <ndm> dons, thats with my own code - http://yhc06.blogspot.com/2006/03/patch-statistics.html
02:55:53 <lambdabot> The title of that page is "York Haskell Compiler: Patch Statistics"
02:56:09 <dons> http://www.cse.unsw.edu.au/~dons/images/commits/fps-commits.png
02:56:29 <ndm> does your code use xfig or something? i.e. is it win32 compatible?
02:56:35 <dons> gnuplot
02:56:54 <xerox> dons, what are the green crosses?
02:56:55 <ndm> my code doesn't generate any images, its all HTML, so is entirely portable with no dependancies, beyond darcs
02:57:10 <dons> xerox, individual patch dates.
02:57:27 <dons> yeah, mine needs gnuplot, and assumes /tmp and '/' seprators.
02:57:55 <dons> got a url for the graph generating code?
02:57:59 <ndm> hmm, maybe i should revive my darcs-graph
02:58:42 <ndm> http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=yhc-devel;a=headblob;f=/misc/DarcsGraph.hs
02:58:45 <lambdabot> The title of that page is "darcs - yhc-devel"
02:58:54 <ndm> although i am too lazy to keep it up, to be honest
02:58:59 <dons> :)
02:59:05 <ndm> but you are free to steal as much as you want
02:59:18 <dons> just wondering if you used the same approach
02:59:30 <dons> h98, too, i see :)
02:59:36 <ndm> of course :)
02:59:50 <ndm> and pretty simple, it looks like - can barely remember it myself
02:59:53 <dons> http://www.cse.unsw.edu.au/~dons/code/darcs-graph/Graph.hs
03:00:12 <dons> most of the tricksy stuff was just so i could use fps for everything
03:00:14 <ndm> yeah, i saw that - a bit more complex
03:00:21 <ndm> why do you need FPS?
03:00:39 <dons> it made it a fair bit faster when reading patch dirs on large repos
03:00:44 <ndm> ok, fair enough
03:00:50 <dons> since i could suck in the dir, and then just take substrings
03:00:54 <ndm> should ByteString not be used instead?
03:01:01 <dons> that's what it uses.
03:01:09 <dons> s/legacy name/new name/
03:01:27 <dons> the other tricky thing was the sliding average. 
03:01:33 <dons> without that it'd be 20 loc
03:01:53 <ndm> yeah, looks quite nice - it was readDir that scared me :)
03:02:00 <dons> heh
03:02:59 <araujo> morning
03:03:17 <dons> xerox, sorry, the green crosses are patch counts for individual days
03:03:23 <dons> the blue line the sliding average.
03:05:50 <giksos> dons: yes, these boxy types and impredicativity look like what I was asking about. Let's hope the docs get updated accordingly.
03:07:42 <giksos> thanks for help!
03:08:23 <dons> :)
03:19:42 <ndm> dons, thanks for your hoogle bug report - its been added to the list and will be fixed in hoogle 4
03:19:51 <ndm> @seen dmhouse
03:19:53 <lambdabot> I saw dmhouse leaving #haskell 3 hours, 7 minutes and 4 seconds ago, and .
03:20:14 <ndm> "and ." - is that a lambdabot bug?
03:22:36 <dons> yes :)
03:22:45 <dons> it'll be fixed in lambdabot 5.0
03:23:09 <xerox> `will probably come back' plugin?
03:23:10 <dblhelix> dons: which will be available before windows vista is? ;)
03:23:36 <dons> nah, its about 12 months per lambdabot major version
03:23:56 <dblhelix> dons: that'll be a close race then
03:28:36 <mux> @version
03:28:37 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
03:28:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:31:48 <ndm> Hoogle is about 6 months between major versions, but no version has ever left beta :)
03:48:30 <kombinator> are there any standard priority queue implementations for haskell?
03:51:50 <dons> yeah, i think there's one in edison
03:52:04 <dons> oh, and Data.Queue (is that a priority queue?)
03:52:10 <dons> @docs Data.Queue
03:52:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Queue.html
03:52:29 <dons> otherwise check the data structures page of haskell.org's libraries and tools page
03:52:50 <kombinator> it doesnt have any Ord constraint, so I guess it's a normal queue
03:54:09 <earthy> http://www.dtek.chalmers.se/~sylvan/PriorityQueue/
03:54:11 <lambdabot> The title of that page is "Index of /~sylvan/PriorityQueue"
03:55:00 <kombinator> thanks
03:55:36 <kombinator> would be nice if some priority queue made it into standard library
03:58:44 <ndm> I think Data.Sequence can do a priority queue
04:03:19 <kombinator> I don't see Data.Sequence in GHC documentation...
04:03:20 <earthy> well, Data.Edison.Coll.MinHeap is a priority queue...
04:04:48 <ndm> kombinator: GHC 6.6 adds it
04:14:15 <Cale> kombinator: it's in the 6.5 docs
04:15:09 <kombinator> is it really suitable as a priority queue?
04:15:35 <kombinator> I don't see Ord constraints there as well
04:16:40 <int-e> @where edison
04:16:41 <lambdabot> I know nothing about edison.
04:17:35 <int-e> @where+ edison http://www.eecs.tufts.edu/~rdocki01/edison.html
04:17:35 <lambdabot> Done.
04:17:54 <kombinator> judging by the types, Data.Edison.Coll.MinHeap look ok, but the docs are sparse
04:18:45 <petekaz> dons: I modified the url plugin to not print errors.  I forgot that non-2xx responses include html bodies that would have a text/html content type.
04:18:45 <lambdabot> petekaz: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:21:41 <Cale> actually, a map of pairs looks like it could do the trick
04:21:49 <Cale> (for a prio queue)
04:22:04 <Cale> er, hmm
04:22:11 <kombinator> Cale: truw
04:22:14 <kombinator> true
04:22:31 <Cale> Set rather
04:34:56 <xerox> Howdy JaffaCake! How's SoC ?
04:35:05 <JaffaCake> hey xerox
04:35:21 <JaffaCake> David is making good progress on the Haddock project, AFAIK
04:35:59 <xerox> Cool.
05:17:15 <ndm> has anyone written a parsec expression to parse haskell type signatures?
05:17:26 <ndm> just simple ones, but it would be nice :)
05:34:52 <roconnor> @type foldr1
05:34:54 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
05:36:10 <Pete_I> @type foldr
05:36:11 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
05:38:10 <roconnor> @hoogle [a] -> ([a],[a])
05:38:11 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
05:38:11 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
05:38:11 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
05:38:35 <Pete_I> @pl 1 + 2
05:38:36 <lambdabot> 3
05:38:47 <Pete_I> ....what does pl do again?
05:38:57 <roconnor> removes lambdas
05:39:05 <Pete_I> ah
05:39:08 <roconnor> @pl (\x -> x))
05:39:08 <lambdabot> (line 1, column 10):
05:39:09 <lambdabot> unexpected ")"
05:39:09 <lambdabot> expecting variable, "(", operator or end of input
05:39:11 <roconnor> @pl (\x -> x)
05:39:12 <lambdabot> id
05:39:23 <roconnor> er, there is probably a better example.
05:39:32 <Pete_I> @pl (\x ->x^2)
05:39:32 <lambdabot> (^ 2)
05:39:46 <Pete_I> cool.
05:46:41 <roconnor> @djinn ((((a->b)->a)->a)->b)->b
05:46:42 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
05:46:53 <roconnor> @pl  f a = a (\ b -> b (\ c -> a (\ _ -> c)))
05:46:53 <lambdabot> f = ap id (flip id . (. const))
05:47:09 <Pete_I> @help
05:47:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:47:28 <roconnor> best to call list in a private message to lambdabot
05:48:02 <dropdrive> we can play pointfree anti-golf...get the longest response from lambdabot with short lambdas....
05:48:26 <Pete_I> sounds fun.
05:48:45 <dropdrive> anyway, when I type ['a'...] I get chars like \18945...what is \18945?
05:49:01 <roconnor> unicode characters I suppose
05:49:46 <Pete_I> @pl (\x->[2^n|[0..n]])
05:49:46 <lambdabot> const [2 ^ n | [0..n]]
05:49:57 <Pete_I> ...
05:50:13 <Pete_I> that's sweet.
05:50:26 <roconnor> @type const
05:50:27 <lambdabot> forall a b. a -> b -> a
05:50:52 <fluxx> @pl (\x y z->4)
05:50:52 <lambdabot> const (const (const 4))
05:51:08 <Pete_I> @pl (\x->[2^n|[0..x]])
05:51:08 <lambdabot> return . (2 ^) . (n |) . enumFromTo 0
05:51:41 <roconnor> um
05:51:44 <fluxx> hey, did lambdabot always knwo how to handle list comprehensions?
05:51:46 <roconnor> that's not good
05:51:52 <fluxx> or am I just thinking of not supporting monads
05:51:54 <Pete_I> roconnor, what isn't?
05:52:03 <roconnor> (n |) isn't valid haskell
05:52:15 <roconnor> I think the list comprehension confuses it
05:52:22 <Pete_I> roconnor, yeah...that's not good
05:52:30 <roconnor> but then again your input isn't good either
05:52:30 <fluxx> right, it doesn't support them :)
05:52:36 <Pete_I> that did look a bit wierd.
05:52:47 <roconnor> @pl (\x->[2^n|n<-[0..x]])
05:52:48 <lambdabot> return . (2 ^) . ((n | n) <-) . enumFromTo 0
05:52:48 <Pete_I> what's wrong with my input?
05:52:57 <Pete_I> oh
05:52:58 <roconnor> you need n<-[0..x]
05:53:03 <Pete_I> right right
05:53:06 <roconnor> but @pl still doesn't understand it
05:53:24 <roconnor> @pl (\x->do {n<-[0..x]; return 2^n})
05:53:24 <lambdabot> (line 1, column 9):
05:53:24 <lambdabot> unexpected "{"
05:53:24 <lambdabot> expecting variable, "(", operator or ")"
05:54:18 <Pete_I> @pl (\x->if x==0 then 1 else x*(x-1))
05:54:18 <lambdabot> ap (flip if' 1 . (0 ==)) (ap (*) (subtract 1))
05:54:27 <roconnor> @pl (\x->[0..x]<<=(\n->return (2^n))}
05:54:27 <lambdabot> (line 1, column 33):
05:54:27 <lambdabot> unexpected "}"
05:54:27 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
05:54:28 <roconnor> @pl (\x->[0..x]<<=(\n->return (2^n))
05:54:28 <lambdabot> (line 1, column 33):
05:54:29 <lambdabot> unexpected end of input
05:54:29 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
05:54:32 <roconnor> @pl (\x->[0..x]<<=(\n->return (2^n)))
05:54:33 <lambdabot> (<<= (return . (2 ^))) . enumFromTo 0
05:56:09 <Pete_I> what module is <<= in?
05:57:10 <xerox> Do you know how to do parens-highlight in vim?
05:57:16 <xerox> (matching parens)
05:57:38 <xerox> Pete_I: nowhere, is roconnor's combinator, it seems.
05:57:39 <Pete_I> xerox, it highlights the corresponding left parens when you close it with the right
05:57:49 <xerox> Pete_I: it doesn't now, do you know how to enable it?
05:58:07 <Pete_I> i'm not sure. i'm sure the folks in #vim know.
05:59:32 <xerox> Sigh. It doesn't exist in vim < 7.
05:59:38 <ndm> @hoogle <<=
05:59:39 <lambdabot> No matches found
06:00:00 <gds> @pl \x -> x^2 + 4*x + 9
06:00:00 <lambdabot> (9 +) . liftM2 (+) (^ 2) (4 *)
06:00:02 * gds wonders where that monad came from...
06:00:10 <xerox> @pl >my<funny>looking<combinator>here<
06:00:11 <lambdabot> (line 1, column 1):
06:00:12 <lambdabot> unexpected ">"
06:00:12 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
06:00:16 <xerox> Err, well.
06:00:29 <xerox> gds - It is the Reader Monad.
06:00:48 * gds goes to look it up...
06:01:01 <xerox> Which in turn is just ((->) e).
06:01:56 <Pete_I> @pl \x y z -> x^y^z^(1/x*y*z)
06:01:57 <lambdabot> ap ((.) . (.) . (^)) (liftM2 (.) (^) . ((ap (^) . (*)) .) . (*) . (1 /))
06:02:14 <Pete_I> horrible :)
06:03:35 <gds> Pete_I: ":DoMatchParen"
06:04:03 <gds> assiming the plugin is loaded, apparently...
06:04:17 * gds re-reads...
06:04:24 <gds> xerox: ":DoMatchParen"
06:04:30 <gds> Sorry Pete_I :)
06:04:53 <xerox> Well, I have done without, sigh!
06:05:16 * gds reads "doesn't exist in vim < 7" and goes to hide somewhere...
06:05:34 <Pete_I> ok, 
06:05:52 <gds> I'm sure I had a plugin for that before vim 7 actually...
06:06:04 <xerox> Seems like I can use %
06:06:19 * Pete_I gets the same message
06:06:47 <Pete_I> @pl \x y -> x % y
06:06:47 <lambdabot> (%)
06:06:53 <Pete_I> :o
06:06:58 <xerox> gds: Yes, but I was in a desperate situation, not time to work with plugins.
06:07:24 <gds> fair enough...
06:07:30 <xerox> Pete_I - @pointless works with a substitution-based algorithm, it leaves as they are combinators it doesn't know of.
06:07:36 <xerox> @pl <<=
06:07:37 <lambdabot> (line 1, column 1):
06:07:37 <lambdabot> unexpected "<"
06:07:37 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
06:07:52 <xerox> @pl \x y -> x <<= y
06:07:53 <lambdabot> (<<=)
06:07:58 <xerox> That doesn't mean <<= exist.
06:09:07 <Pete_I> @type (<<=)
06:09:08 <lambdabot> Not in scope: `<<='
06:09:16 <Pete_I> @type <<=
06:09:17 <lambdabot> parse error on input `<<='
06:09:21 <xerox> @pl this_does_not_exist
06:09:21 <lambdabot> this_does_not_exist
06:09:49 <Dino_> @type <-
06:09:50 <lambdabot> parse error on input `<-'
06:09:57 <Dino_> @type (<-)
06:09:58 <lambdabot> parse error on input `<-'
06:10:06 <Pete_I> @pl \x y -> y % x
06:10:06 <lambdabot> flip (%)
06:10:34 <Pete_I> @pl \x y z -> z % x % y
06:10:35 <lambdabot> flip . ((%) .) . flip (%)
06:16:59 <Pete_I> @pl (\x -> map(\y->y^x)[0..x])
06:16:59 <lambdabot> ap (map . flip (^)) (enumFromTo 0)
06:22:37 <dcoutts> dons, aye, I did know of VLists
07:09:59 <xerox> jgrimes: What do you think about that?
07:10:26 <jgrimes_> xerox: hmm
07:10:40 <xerox> Do you use the SQL server when you have to tweak the db?
07:10:49 <jgrimes_> yeah
07:10:49 <xerox> I think halbum's interface is very very rough atm.
07:12:08 <jgrimes_> xerox: anything specific?
07:12:41 <xerox> jgrimes_: Being able to refer pics by other means than the number would help
07:12:45 <xerox> I think..
07:12:53 <jgrimes_> xerox: true :)
07:13:28 <xerox> Now I get mad when they are not exactly a continuous subset of [1..] starting at 1 :)
07:15:13 <jgrimes_> :)
07:16:10 * xerox goes back to the lectures
07:17:30 <gramuxius> Can anyone shed some light on what this means? > :kind Point
07:17:32 <gramuxius> Point :: *
07:17:55 <xerox> Kinds are types of types.
07:18:02 <xerox> ?kind Int
07:18:04 <lambdabot> *
07:18:08 <xerox> Types have kind *
07:18:29 <ndm> ?kind map
07:18:30 <lambdabot> Not in scope: type variable `map'
07:18:38 <xerox> What kind would a type constructor, which takes a type and return a type, have?
07:18:41 <ndm> ?kind Just
07:18:43 <lambdabot> Not in scope: type constructor or class `Just'
07:18:50 <ndm> ?kind Maybe
07:18:51 <lambdabot> * -> *
07:18:58 <xerox> ndm spoils the fun.
07:19:13 <gramuxius> Aha
07:19:15 <ndm> sorry :P
07:19:25 <ndm> i am still trying to understand kinds...
07:19:47 <dons> ?kind Control.Monad.RWST
07:19:48 <lambdabot> Not in scope: type constructor or class `Control.Monad.RWST'
07:19:48 <gramuxius> So what is the point if everything is *?
07:19:56 <dons> ?kind Control.Monad.RWS.RWST
07:19:58 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
07:19:58 <xerox> See Ωmega for kind madness.
07:20:02 <xerox> ?kind (->)
07:20:03 <lambdabot> ?? -> ? -> *
07:20:05 <xerox> ?kind 1
07:20:07 <lambdabot> *
07:20:07 <mux> every Monad is * -> *
07:20:13 <dons> xerox plays games
07:20:19 <xerox> ^_^
07:20:55 <bruno> kinds classify types in the same way types classify values
07:20:57 <xerox> Haskell does not *yet* have extensible kind. Ωmega implements that. It is crazy!
07:21:51 <alar> what is Ocmega?
07:22:00 <xerox> By the way they are useful, in fact if you read the Monad class definition you'll see something like: class forall (m :: * -> *). Monad m where ...
07:22:05 <xerox> (Modulo syntax.)
07:23:07 <bruno> alar: http://web.cecs.pdx.edu/~sheard/Omega/index.html
07:23:07 <lambdabot> The title of that page is "Omega Download Page"
07:23:21 <xerox> http://lambda-the-ultimate.org/node/625
07:23:23 <lambdabot> The title of that page is "Omega | Lambda the Ultimate"
07:24:27 <xerox> I was expecting to find the dual here http://research.microsoft.com/Comega/ but err.. :-)
07:24:29 <lambdabot> The title of that page is "Comega - Home"
07:24:56 <gramuxius> Hm, fascinating.
07:25:03 <xerox> Indeed.
07:32:55 <roconnor> @lisp-paste
07:32:55 <lambdabot> Unknown command, try @list
07:33:00 <roconnor> @where paste
07:33:00 <lambdabot> http://paste.lisp.org/new/haskell
07:35:42 <lisppaste2> roconnor pasted "Can this be optimized?" at http://paste.lisp.org/display/21322
07:35:57 <roconnor> I spend 53% of my time in this function
07:36:41 <dons> maybe
07:36:50 <ihope> "genpowers x = 1:(map (x*) (genpowers x))"
07:36:54 <ihope> Maybe that's what's hurting.
07:37:06 <roconnor> can that be faster?
07:37:08 <dons> oh. hmm.
07:37:26 <ihope> roconnor: you could use expenentiation by squaring.
07:37:52 <roconnor> ihope: is that actually faster?  because I will consume an entire initial segment of the list anyways
07:38:17 <ihope> Um...
07:38:20 <dons> ?index (%)
07:38:21 <lambdabot> Data.Ratio
07:38:42 <xerox> ``...you make a ByteString...''
07:38:44 * xerox hides
07:38:49 <dons> heh
07:39:00 <bolrod> @index rational
07:39:01 <dons> roconnor: how big is the list you need to generate?
07:39:01 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
07:39:06 <roconnor> I could break the Ratio abstraction somehow by forcing the constructor.
07:39:26 <roconnor> dons: I'm not sure how much of the list I use.
07:39:50 <ihope> Why not just use "powers x = map (\y -> x^y) [0..]"?
07:39:50 <roconnor> If I force the constructor, then I avoid the GCD calculations.
07:40:23 <roconnor> ihope: because I think that implementation would end up recomputing lower powers again and again.
07:40:41 <roconnor> because each call to x^y becomes independent of each other.
07:40:49 <ihope> Oh.
07:41:16 <roconnor> Is it possible to get access to the (:%) constructor?  Any cheats?
07:41:33 <int-e> > iterate (*2) 1
07:41:34 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:41:56 <bolrod> > iterate (*2) (1%2)
07:41:58 <lambdabot>  [1%2,1%1,2%1,4%1,8%1,16%1,32%1,64%1,128%1,256%1,512%1,1024%1,2048%1,4096%1,8...
07:42:08 <bolrod> > iterate (^2) (1%2)
07:42:09 <lambdabot>  [1%2,1%4,1%16,1%256,1%65536,1%4294967296,1%18446744073709551616,1%3402823669...
07:42:13 <bolrod> ^.0
07:42:18 <ihope> Well, given [a, b, c...], you can return [a, a*a*x, b, b*b*x, c, c*c*x...]
07:42:24 <ihope> At least, I think you can.
07:42:28 <ihope> Wait, no...
07:43:06 <ihope> [a*a, a*a*x, b*b, b*b*x, c*c, c*c*x], maybe?
07:43:25 <ihope> > let [a, b, c] = [1, 3, 9] in [a*a, a*a*x, b*b, b*b*x, c*c, c*c*x]
07:43:25 <int-e> @index :%
07:43:26 <lambdabot>  Not in scope: `x'
07:43:26 <lambdabot> bzzt
07:43:35 <int-e> @type GHC.Real.:%
07:43:37 <lambdabot> parse error on input `GHC.Real.:%'
07:43:41 <int-e> @type (GHC.Real.:%)
07:43:42 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
07:43:44 <ihope> > let [a, b, c] = [1, 3, 9] in [a*a, a*a*3, b*b, b*b*3, c*c, c*c*3]
07:43:45 <lambdabot>  [1,3,9,27,81,243]
07:43:49 <ihope> Ah, yes.
07:44:17 <roconnor> > 1 :% 2
07:44:17 <lambdabot>  Not in scope: data constructor `:%'
07:44:27 <bolrod> > let power x = [ (x^i) | i<-[1..]] in power (1%2)
07:44:28 <lambdabot>  [1%2,1%4,1%8,1%16,1%32,1%64,1%128,1%256,1%512,1%1024,1%2048,1%4096,1%8192,1%...
07:44:34 <bolrod> ?
07:44:59 <ihope> > 2 GHC.Real.:% 2
07:45:00 <lambdabot>  Not in scope: data constructor `GHC.Real.:%'
07:45:00 <dons> yeah, I had something like: 
07:45:03 <dons> powers x = [ k (x^n) | n <- [1..] ]
07:45:03 <dons>     where k = (:% 1)
07:45:14 <dons> import GHC.Real
07:45:26 <dons> powers :: Integer -> [Rational]
07:45:33 <bolrod> works on more then Rationals --> let powers x = [ (x^i) | i<-[1..]] in power (1%2)
07:45:39 <int-e> > let p n = n:(p (n*n) >>= \a -> [a, a*n]) in 1:p 2
07:45:41 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:45:55 <bolrod> > let power x = [ (x^i) | i<-[1..]] in power 4
07:45:56 <lambdabot>  [4,16,64,256,1024,4096,16384,65536,262144,1048576,4194304,16777216,67108864,...
07:46:04 <dons> anyway, looks like lots of much more efficient versions :)
07:46:32 <int-e> but I'd think using GHC.Real.:% directly is the biggest time-saver.
07:46:32 <bolrod> isn't list comprehension generally faster then trying to figure out something complex yourself?
07:46:51 <int-e> bolrod: err, not if you duplicate computations
07:46:58 <bolrod> aha 
07:47:06 <dons> yeah, I'd suspect so. the list comprehension using :% will just pack Integers
07:47:11 <dons> should be pretty quick
07:47:22 <dons> let see...
07:47:49 <bolrod> but you can't use :% ?
07:47:58 <dons> sure you can
07:48:11 <int-e> you have to import it from the right place, and it won't be Haskell 98
07:48:25 <bolrod> >  3:%2  
07:48:26 <lambdabot>  Not in scope: data constructor `:%'
07:48:31 <dons> GHC.Real
07:48:31 <bolrod> well.. here you can't :)
07:48:42 <roconnor> I can import it?
07:48:53 <roconnor> but it isn't exported by the Ratio module.
07:49:05 <int-e> import GHC.Real
07:49:07 <dons> import GHC.Real
07:49:15 <int-e> Prelude GHC.Real> 2 :% 4
07:49:15 <int-e> 2%4
07:49:17 <dons> powers :: Integer -> [Rational]
07:49:17 <dons> powers x = [ k (x^n) | n <- [1..] ]
07:49:17 <dons>     where k = (:% 1)
07:49:25 <roconnor> woah, what is GHC.Real?
07:49:27 <dons> runs in 3 sec ((powers 2) !! 100000) on my box
07:49:32 <dons> the old version takes at least 30 seconds
07:49:34 <dons> (I gave up)
07:50:03 <roconnor> my code is far, FAR, from Haskell 98 already.
07:50:36 <dons> 10x speed up in a hammered function is worth it. you can probably tweak it further if necessary
07:50:45 <dons> the old version is really really slow :}
07:50:47 <int-e> powers x = zipWith (:%) (iterate (*numerator x) 1) (iterate (*denominator x) 1)
07:51:06 <xerox> (* (numerator x)) maybe?
07:51:27 <dons> hmm. the old version is at least 20x slower..
07:51:32 <int-e> I'd use that if all the list is used; if the list is used sparsely, I'd use something built from  map (x^) [0..]
07:51:51 <int-e> xerox: that's the same.
07:52:03 <xerox> I always think... well, okay.
07:52:11 <bolrod> dons: in the ghci my version is just as fast..
07:52:17 <bolrod> maybe compiled it's different
07:52:20 <xerox> ?type \x -> (* succ x)
07:52:21 <lambdabot> forall a. (Num a, Enum a) => a -> a -> a
07:52:22 <int-e> function application binds tightest.
07:52:32 <dons> compiled with -O -funbox-strict-fields, 3s versus well, at least 2mins now.
07:52:41 <int-e> bolrod: the :% is the key.
07:53:14 <roconnor> @docs GHC.Real
07:53:14 <lambdabot> GHC.Real not available
07:55:12 <int-e> dons: note that your test case constitutes 'sparse' use.
07:55:21 <roconnor> unbox-strict-fields?
07:56:00 <bolrod> dons: your version is not really faster then just  [x^i|i<-[1..]]
07:56:01 <ihope> Unboxed functions!
07:56:07 <bolrod> ;/
07:56:12 <dons> bolrod: yeah, itd be the same
07:56:38 <int-e> > let p n = n:(p (n*n) >>= \a -> [a, a*n]) in (1:p 2) !! 1000000
07:56:40 <bolrod> hrm... lets see again
07:56:41 <lambdabot>  out of memory (requested 2097152 bytes)
07:56:50 <int-e> > let p n = n:(p (n*n) >>= \a -> [a, a*n]) in (1:p 2) !! 100000
07:56:53 <lambdabot>  9990020930143845079440327643300335909804291390541816917715292738631458324642...
07:56:55 <roconnor> weeeeeeee another 2 fold increase in speed.
07:57:08 <Pete_I> @type (!!)
07:57:09 <lambdabot> forall a. [a] -> Int -> a
07:57:13 <roconnor> My test suite took over nine minutes last week.  Now it runs in 36 seconds
07:57:21 <int-e> that one is a compromise ... it has reasonable performance for both dense and sparse use.
07:57:44 <roconnor> int-e: In my case I use an entire initial segment.
07:57:44 <bolrod> dons: does yours work when you input  1%2 in it?...
07:57:48 <bolrod> it gives an error for me
07:57:58 <Pete_I> what's the !! operator called?
07:58:04 <bolrod>     No instance for (Integral (Ratio a))
07:58:05 <int-e> roconnor: yep, I'd use iterate for that (which should compile to pretty much the same as your code)
07:58:22 <ihope> Pete_I: index?
07:58:35 <roconnor> So where is the documenation for GHC.Real?
07:58:41 <Pete_I> oh, i see. thanks.
07:58:58 <bolrod> type :browse GHC.Real  in ghci to get some indication
07:59:02 <roconnor> Boy, I think I'm going to need to expand my test suite.  It's beginning to run too fast.
07:59:09 <mathewm> List index (subscript) operator
08:00:22 <bolrod> :)
08:00:57 <roconnor> yikes, :% really doesn't look like a safe function for me to have access to.
08:01:09 <bolrod> then don't...
08:01:23 <roconnor> ahhh, but it is so useful for me. :)
08:01:24 <bolrod> I mean... you don't really need it
08:01:30 <roconnor> speed wise
08:01:39 <bolrod> for what?
08:01:41 <int-e> well. it's not safe, but it's fast.
08:01:43 <roconnor> I'm just surprised that I get access to it.
08:01:52 <bolrod> I mean.. the very simple list comprehension is like... 20 times faster already
08:01:53 <int-e> so if you know what you're doing, blah, blah :)
08:01:57 <bolrod> why need 20.001 times?
08:02:01 <roconnor> Prelude GHC.Real> (2 :% 4) == (1 :% 2)
08:02:02 <roconnor> False
08:02:02 <roconnor> P
08:02:03 <bolrod> (or something)
08:02:10 <int-e> roconnor: I know.
08:02:31 <bolrod> > 2%4
08:02:32 <lambdabot>  1%2
08:02:51 <bolrod> @type GHC.Real.%
08:02:52 <lambdabot> parse error on input `GHC.Real.%'
08:02:56 <dons> you are supposed to know what you're doing if you hack in the internals of the type, since you could break all sorts of invariants
08:02:56 <int-e> roconnor: but for powers it's perfectly safe to use, so ...
08:03:02 <roconnor> When i write this in Coq, I will prove what I and doing is safe.
08:03:40 <int-e> of course it'd be nicer if the smart constructor could optimize away its use of gcd :)
08:04:19 <lisppaste2> roconnor annotated #21322 with "Optimized code" at http://paste.lisp.org/display/21322#1
08:06:41 <roconnor> int-e: may I freely use your code?
08:06:46 <int-e> sure
08:07:06 <roconnor> may everyone freely use your code?
08:07:31 * roconnor wonders if one like of haskell is subject to copyright?
08:08:17 <int-e> hmm. most likely not.
08:08:25 <Pete_I> i wouldn't think most people would care, as long as you give them their credit
08:08:32 <int-e> (there may be exceptions. and I'm not a lawyer.)
08:08:34 <dons> i'm not sure what the legal status of utterances in #haskell are. i presume its all rights reserved for code fragments (like unlicensed code)
08:08:46 <mathewm> is there an arbitrary precision sqrt?  Maybe one that returns an infinite list of digits?
08:08:51 <dons> or like code on the wiki
08:09:34 <roconnor> int-e: I plan to put it in my project which (will be) released under a modifed BSD licence.
08:09:38 <Pete_I> that's a good question...how do you find infinate digits of a sqrt?
08:09:38 <dons> mathewm: we don't have arbitrary precision Floatings, do we?
08:09:45 <dons> ?type sqrt
08:09:47 <lambdabot> forall a. (Floating a) => a -> a
08:09:51 <dons> > sqrt 2
08:09:52 <lambdabot>  1.4142135623730951
08:09:55 <Pete_I> oh, that's just cold. perl can do it.
08:09:57 <roconnor> @wiki ExactRealArithmetic
08:09:57 <lambdabot> http://www.haskell.org/haskellwiki/ExactRealArithmetic
08:10:01 <Paltas> sqrt -5
08:10:02 <Pete_I> cheepness.
08:10:12 <roconnor> @oldwiki ExactRealArithmetic
08:10:12 <lambdabot> http://www.haskell.org/hawiki/ExactRealArithmetic
08:10:13 <dons> yeah, you need a library
08:10:34 <dropdrive> are Haskell's Integers based on GNU MP?
08:10:40 <dons> yep
08:10:48 <dons> ghc's are,
08:11:10 <araujo> hello
08:11:23 <dons> hey araujo 
08:11:37 <araujo> hello dons :-)
08:11:57 <dons> watching much of the football?
08:13:53 <dropdrive> > 1.00000000000000001 == 1.00000000000000002
08:13:54 <lambdabot>  True
08:14:10 <araujo> dons, hah, sort of, been kind of busy with univ , yourself? :-)
08:14:14 <mathewm> depressing, isn't it
08:14:34 * araujo will get some free time to watch the mexico game today though
08:14:47 <Pete_I> > show(1.00000000000000000001) == show(1.0000000000000000000002)
08:14:48 <lambdabot>  True
08:14:52 <Pete_I> :o
08:14:57 <dons> oh, its hard here, since games start at 11pm, and finish around 7am or so
08:15:11 <dons> so i see the first match, and fall asleep the next day during work :}
08:15:17 <araujo> oh haha
08:15:22 <dons> > 1.1 + 2.2
08:15:23 <lambdabot>  3.3000000000000003
08:15:26 <roconnor> Prelude ICReal> answer 160 (sqrt 2)
08:15:26 <roconnor> "14142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727350138462309122970249248360558507372126441214970999358314132x10^-160"
08:15:38 <dons> at times like this, i feel reminded of keal
08:15:40 <dons> @keal
08:15:40 <lambdabot> i use an 8088
08:15:43 <dons> @keal
08:15:44 <lambdabot> all i know is i have experienced my own death unhappening...
08:15:52 <dons> @keal -- this time for sure
08:15:52 <lambdabot> one prollem. T broke confines of the visual basic langage and would not compile
08:15:52 <Pete_I> dons, that appears to be quite an accuracy problem.
08:16:04 <Pete_I> > 1.1 + 3.3
08:16:05 <lambdabot>  4.4
08:16:08 <dons> oh, i really wanted one of the quotes about broken fpus
08:16:16 <Pete_I> > 1.1 + 2.2
08:16:17 <lambdabot>  3.3000000000000003
08:16:26 <Pete_I> how's it get that?
08:16:33 <dons> i.e. will it return [] if map gives fpu infinite list?
08:16:34 <int-e> try to write 1/5 in binary
08:16:37 <mathewm> Prelude ICReal > answer 1 $ sqrt 5
08:16:40 <dons> to quote keal :)
08:17:03 <dropdrive> so 1.1 is interpreted as a double, not a rational?
08:17:09 <int-e> yes
08:17:10 <roconnor> Prelude ICReal> answer 1 $ sqrt 5
08:17:10 <roconnor> "22x10^-1"
08:17:17 <dons> ?type 1.1
08:17:18 <lambdabot> forall t. (Fractional t) => t
08:17:19 <dons> ?type 2.2
08:17:20 <int-e> > 1.1 :: Rational
08:17:21 <lambdabot> forall t. (Fractional t) => t
08:17:21 <lambdabot>  11%10
08:17:36 <mathewm> roconnor is the new lambdabot!
08:17:42 <roconnor> ;)
08:17:46 <int-e> > toRational 1.1
08:17:47 <lambdabot>  2476979795053773%2251799813685248
08:17:54 <roconnor> *l*
08:17:56 <dons> heh
08:18:00 <dropdrive> yuck...
08:18:09 <dons> > toRational 1.0
08:18:10 <lambdabot>  1%1
08:18:15 <dropdrive> phew!
08:18:15 <dons> very nice.
08:18:26 <roconnor> I will answer everyone's arithmetic questions.
08:18:27 <roconnor> ;)
08:18:28 <Pete_I> ...isn't 1.1  11%10 ?
08:18:34 <int-e> > 2251799813685248 == 2^51
08:18:35 <lambdabot>  True
08:18:54 <dropdrive> Pete_I: apparently not :)
08:19:05 <roconnor> Pete_I: 1.1 is first converted to binary, then truncated, then converted into a rational number.
08:19:16 <vincenz> ouch
08:19:27 <Pete_I> > 11%10 == toRational(1.1) == 1.1
08:19:28 <lambdabot>    precedence parsing error
08:19:28 <lambdabot>     cannot mix `(==)' [infix 4] and `(==)' ...
08:19:28 <shapr> roconnor: What's the pi'th digit of pi?
08:19:32 <dropdrive> roconnor: what's this ICReal?
08:19:33 <int-e> > toRational 1.1 - 1.1
08:19:34 <lambdabot>  1%11258999068426240
08:19:48 <Pete_I> shapr, there isn't one.
08:19:52 <shapr> Why not?
08:19:53 <Pete_I> you can't have partial digits.
08:19:58 <shapr> What about fractions?
08:20:03 <Pete_I> you could round, and get the 3rd digit.
08:20:11 <roconnor> dropdrive: darcs get http://r6.ca/FewDigits/
08:20:13 <lambdabot> Title: "Few Digits 0.4.0"
08:20:26 <dons> > [1..] !! pi -- that's why, shapr ;)
08:20:27 <lambdabot>  add an instance declaration for (Floating Int)
08:20:44 <shapr> dons: What should that do?
08:21:10 <dons> i suppose round would be reasonable 
08:21:39 <Pete_I> > [1..] !! floor(pi)
08:21:40 <lambdabot>  4
08:21:48 <int-e> > 1+pi
08:21:49 <lambdabot>  4.141592653589793
08:21:50 <roconnor> mmmmm floor pie
08:21:54 <int-e> I want that result ;)
08:22:11 <int-e> because clearly [1..] maps x to x+1.
08:22:14 <dropdrive> roconnor: thanks
08:22:21 <Pete_I> how do you figure?
08:22:40 <roconnor> > [1..]!!1
08:22:41 <lambdabot>  2
08:22:47 <roconnor> > [1..]!!0
08:22:48 <lambdabot>  1
08:22:48 <shapr> JaffaCake: Hey, haskell.org is running an ancient (2001-2003) version of RedHat that has a postfix too old for postgrey. Should I ask you, John Peterson, or someone else about upgrading postfix or switching to a newer version of Linux?
08:22:52 <Pete_I> ah
08:22:52 <Dino_> Oho, pleasant surprise of the day, nested pattern matching:  ((a,b):xs)
08:23:08 <JaffaCake> shapr: ask John
08:23:11 <Pete_I> > [0..pi+1] !! pi
08:23:12 <shapr> Ok, thanks.
08:23:12 <lambdabot>  add an instance declaration for (Floating Int)
08:23:21 <dropdrive> so is there a wrapper (or whatever) for the floating point stuff in GMP?
08:24:04 <Pete_I> > [e .. pi]
08:24:05 <lambdabot>  Not in scope: `e'
08:24:15 <Pete_I> > [exp(1) .. pi]
08:24:16 <lambdabot>  [2.718281828459045]
08:24:27 <Pete_I> ...
08:24:44 <Pete_I> > pi - exp(1)
08:24:45 <lambdabot>  0.423310825130748
08:24:47 <mathewm> anyone know BigFloat?
08:24:48 <roconnor> > [exp(1) .. 5*pi]
08:24:49 <lambdabot>  [2.718281828459045,3.718281828459045,4.718281828459045,5.718281828459045,6.7...
08:24:55 <shapr> mathewm: Does he show up here? :-)
08:25:09 <roconnor> mathewm: I do, more or less.
08:25:14 * mathewm evidently not ... ;)
08:25:28 <mathewm> how do I make a BigFloat?
08:25:57 <dons> how big do you want it?
08:25:59 <roconnor> well, I suppose I only know an outline of how BigFloat works.  I've never actually used it.
08:26:13 <mathewm> about yay big
08:26:15 <roconnor> I would have assumed it would have made an instance of Floating.
08:26:29 <roconnor> have you tried fromRational or fromInteger?
08:27:36 <mathewm> I am just trying to get the BigFloat for sqrt 5
08:28:03 <lisppaste2> roconnor pasted "Now I spend 52% in this code." at http://paste.lisp.org/display/21329
08:28:25 <roconnor> oops Base is defined to be Rational
08:28:59 <dons> well, at least map only once over l
08:29:17 <mathewm> hmm, OK, now how do I limit the digits in the show of BigFloat ? :)
08:29:31 <roconnor> dons: hmm, ok
08:30:00 <Dino_> Maybe Text.Printf.printf
08:30:12 <roconnor> @pl (\x -> (numerator x, denominator x)
08:30:13 <lambdabot> (line 1, column 36):
08:30:13 <lambdabot> unexpected end of input
08:30:13 <lambdabot> expecting variable, "(", operator or ")"
08:30:15 <roconnor> @pl (\x -> (numerator x, denominator x))
08:30:16 <lambdabot> liftM2 (,) numerator denominator
08:30:53 <shapr> jmuk: hiya!
08:30:55 <dons> then you zip that structure. so maybe fuse the zip with the map
08:31:03 <shapr> jmuk: Nice to see you on #haskell
08:31:14 <jmuk> hello
08:31:17 <shapr> jmuk: konichiwa
08:31:21 * xerox boings to shapr
08:31:24 <sethk> dons, did you see my lengthy question from a couple of days ago?  My IRC thing crashed so I lost any response
08:31:24 <jmuk> konnichiwa
08:31:25 <int-e> roconnor: how about lcm' [x] = x; lcm' xs = lcm' (lcm'' xs); lcm'' [x] = [x]; lcm'' (a:b:xs) = lcm a b:lcm'' xs? ... gets rid of the splitAt
08:31:25 * shapr boings to HaskellNet
08:31:27 <xerox> Two n!
08:31:47 <int-e> roconnor: won't save much time I suspect because lcm is costly.
08:31:57 <xerox> こんばんは、jmuk！
08:32:14 <shapr> jmuk: I have another FTP library on a spare harddrive, do you want a second ftplib to look at?
08:32:21 <jmuk> xerox: nice Japanese :)
08:32:35 <roconnor> maybe I need to write my own specialized lcm for lists of integers.
08:32:39 <xerox> ありがとう:)
08:33:11 <jmuk> shapr: i want to look at it
08:33:32 <shapr> I'll plug in that hard drive later today and get it.
08:34:21 <shapr> jmuk: Any questions I can help you with?
08:35:12 <jmuk> shapr: do you require a kind of progress report?
08:35:15 <roconnor> dons: removing the zip and maping once helped a bit
08:35:26 <roconnor> still have 51% of the time there ;)
08:35:28 <jmuk> By now, I have few commitment into the darcs repo
08:35:29 <shapr> jmuk: Not unless you want to write one.
08:35:42 <shapr> jmuk: The project is about producing code, not so much text :-)
08:35:57 <shapr> So I figure I can look at your darcs repo and figure it out myself.
08:35:59 * roconnor ponders how to quickly sum a list of rationals.
08:36:46 <int-e> do you know anything about the denominators, perhaps?
08:36:47 <shapr> jmuk: I do enjoy seeing the cc'ed emails.
08:37:19 <xerox> shapr: Do you think that referentiating halbum images by their id is the best way to do it? I get mad every time my ids aren't [1..]
08:38:14 <shapr> xerox: I'd rather use the name I uploaded with, like [halbum:deathbymath] for deathbymath.jpg
08:38:38 <xerox> True, true!
08:40:59 <vincenz> or...
08:41:03 <vincenz> have the user choose an id
08:41:09 <vincenz> [halbum:id]
08:41:15 <vincenz> id -> deathbymath.jpg
08:41:15 <roconnor> int-e: I'm summing powerseries, so actually I do.
08:41:29 <jgrimes_> I think both ways of referencing the images are useful
08:41:46 <int-e> so ... lcm' = last would do the job?
08:42:06 <xerox> shapr, shouldn't id decrease when one deletes an image, in principle?
08:42:07 <sethk> dons??????
08:42:15 <roconnor> int-e: often, but not always.  It's a good idea
08:42:53 <vincenz> xerox: why do id's need to be numbers and sequential/
08:43:10 <vincenz> erm..consecutive
08:43:16 <xerox> vincenz - Because you use them by hand, and it is a pain if they aren't.
08:43:32 <jgrimes_> hm, having the user choose an id, possibly separate from the current id, could be pretty useful, too.
08:47:24 <vincenz> indeed
08:47:33 <vincenz> xerox: on the wiki I have now... whenever you upload something, you choose an id
09:06:47 <mathewm> shoot.  ghc 6.5 doesn't want to build FewDigits
09:13:57 <xerox> http://www.plover.com/~mjd/misc/math/die.html
09:14:41 <aFlag> I'm using parsec and I want reserved words that can't happen in variable names (like \, . and = in my case) could be written as \x, instead of having a obrigatory empty space between \ and x. Is there a predefined parser to do that? I've been using the reserved one, but it doesn't work in this case
09:16:26 <dmhouse> aFlag: sorry, I didn't really follow all of that. Could you give an example of what you want to parse?
09:18:04 <ndm> dmhouse: you sent me a message about hoogle via lamdabot - i didn't quite understand what you were saying
09:18:10 <dmhouse> ndm:
09:18:11 <aFlag> I have "\\" as a reserved word and I want to parse "\\x", x being an identifier and "\\" being a reserved word, so when I do reserved "\\" on "\\x" it doesn't give me an error
09:18:12 <dmhouse> @hoogle Writer
09:18:13 <lambdabot> Control.Monad.Writer :: module
09:18:14 <lambdabot> Control.Monad.Writer.Writer :: (a, w -> Writer w a)
09:18:14 <lambdabot> Control.Monad.Writer.Writer :: newtype Writer w a
09:18:20 <dmhouse> ndm, what's the second result there?
09:19:02 <ndm> dmhouse: ah, understand now :)
09:20:22 <ndm> dmhouse: no, that makes sense
09:20:38 <ndm> Write is a type, and if you pass it (a,w) it will give you a Writer w a
09:20:58 <ndm> the brackets are in the wrong place though  -thats a bug with the hoogle.txt file
09:21:08 <dmhouse> So what should it be?
09:21:11 <ndm> will be fixed by generating hoogle.txt from haddock
09:21:22 <ndm> its a function - should be :: (a,w) -> Write w a
09:21:34 <dmhouse> Writer is nothing like that. newtype Writer w a = Writer { runWriter :: (a, w) }.
09:21:58 <ndm> exactly, the type of the constructor, Writer, takes a (a,w)
09:22:02 <ndm> and returns you a Writer w a
09:22:08 <ndm> @hoogle Just
09:22:09 <lambdabot> Prelude.Just :: a -> Maybe a
09:22:09 <lambdabot> Maybe.fromJust :: Maybe a -> a
09:22:09 <lambdabot> Maybe.isJust :: Maybe a -> Bool
09:22:13 <dmhouse> Oh, I see.
09:22:19 <ndm> the same as Just does
09:22:30 <ndm> constructors are in the database as functions as well
09:22:34 <dmhouse> Yeah, I know what you mean now. The repeated Writer/Write typo was confusing me.
09:23:49 <ndm> ah, sorry - my fingers get easily confused :)
09:24:05 <ndm> but there is a but in the search, it puts the tuple brackets in teh wrong place
09:24:17 <dmhouse> Okay.
09:24:29 <dmhouse> Isn't hoogle.txt already generated from Haddock, though?
09:24:53 <ndm> its currently haddock -> HTML -> hoogle
09:25:02 <ndm> the new one is haddock -> hoogle
09:25:11 <ndm> and the intermediate HTML stage really screws things up
09:25:12 <dmhouse> Yeah, Haddock has Hoogle output, so that's what I was wondering.
09:25:30 <ndm> currently hoogle.txt goes via HTML
09:25:38 <ndm> i need to set it up to go direct, when i get round to it
09:25:47 <ndm> then the tuple bracketing in that example will be fixed
09:33:30 <astrolabe> @where StateT
09:33:30 <lambdabot> I know nothing about statet.
09:36:54 <dmhouse> astrolabe: you probably mean @index.
09:37:08 <astrolabe> @index StateT
09:37:09 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
09:37:28 <astrolabe> I was after a tutorial really.
09:38:57 <dmhouse> Oh. 
09:39:03 <dmhouse> Do you understand monad transformers?
09:39:30 <astrolabe> I wrote some code using StateT, and now I can't understand it!
09:40:19 <astrolabe> So, I used to, but now I'm not sure.
09:40:47 <dmhouse> Hehe.
09:40:50 <dmhouse> How about you pastebin it?
09:41:44 <astrolabe> I've found some documents now, but thanks for the offer.
09:42:39 <dmhouse> Okay.
09:50:42 <roconnor> mathewm: Oh, that's not good.  What error do you get?
09:56:24 <mathewm> CReal.hs:195:0:
09:56:24 <mathewm>     Illegal instance declaration for `MultinomialUniformCts (Interval Base,
09:56:24 <mathewm> 							     i)
09:56:24 <mathewm> 							    (Polynomial p)
09:56:25 <mathewm> 							    ((:=>) Base r)'
09:56:27 <mathewm> 	(the Coverage Condition fails for one of the functional dependencies)
09:56:29 <mathewm>     In the instance declaration for `MultinomialUniformCts (Interval Base,
09:56:31 <mathewm> 							    i) (Polynomial p) (Base :=> r)'
09:58:40 <dmhouse> @instances MonadPlus
09:58:44 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
09:59:05 <dmhouse> How is IO an instance?!
10:02:53 <lightstep> @wiki MonadPlus
10:02:53 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
10:13:20 <dmhouse> What exactly is STM?
10:13:29 <dmhouse> Anything to do with ST?
10:13:42 <RyanT5000> has profiling with TH been fixed yet?
10:13:52 <RyanT5000> i still get an undefined symbol `_era'
10:14:00 <mathewm> dmhouse: Shared Transactional Memory, I think
10:14:25 <RyanT5000> and the only relevant hit on google is the log of the last time i asked about that in this channel >.>
10:14:38 <dmhouse> @spell fulfil
10:14:47 <RyanT5000> fulfill
10:14:52 <dmhouse> lambdabot: ping
10:15:22 <dmhouse> Well, thanks RyanT5000.
10:15:25 <RyanT5000> np :P
10:16:48 <lightstep> dmhouse, actuall, Software Transactional Memory
10:16:56 <lightstep> @where stm
10:16:56 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
10:17:04 <dmhouse> So nothing to do with ST?
10:17:09 <lightstep> not at all
10:17:25 <lightstep> it's kinda like a subset of the IO monad
10:17:37 <lightstep> (limited to memory transactions)
10:23:45 <giksos> is there any way to search in the haskell mailing list?
10:24:10 <dmhouse> Try gmane or similar.
10:24:23 <dmhouse> @google gmane haskell
10:24:25 <lambdabot> http://news.gmane.org/gmane.comp.lang.haskell.general
10:26:35 <giksos> yes, it has a search function, thanks!
11:06:06 <RyanT5000> why isn't there a libHSrts_debug_p? is it nonsensical or do i just need to install something?
11:14:08 * ihope wonders where the "else" in "if/then/else" came from
11:14:55 <ProfTeggy> ihope, hmm?
11:15:14 <ihope> Why is it if/then/else and not if/then/otherwise?
11:15:53 <ndm> otherwise is just too long
11:16:01 <ProfTeggy> 'else' is more economical (saves 5 characters) and aligns better with 'then'
11:16:20 <RyanT5000> otherwise and else have to be different because one is syntax and the other's a value
11:16:30 <RyanT5000> (though that doesn't preclude you from switching them)
11:17:33 <ibid> ihope: remember that it is a very old tradition. i suspect the reason is that back then every byte counted :)
11:18:01 <ihope> Then why if/then/else and not ite?
11:18:13 <ihope> Erm, i/t/e.
11:18:37 <monochrom> i is an integer variable, t and e are floating point variables
11:18:51 <ndm> in some old languages every single letter was a single variable
11:18:59 <ndm> i.e. a letter on its own == variable
11:19:26 <ihope> Then there's Unlambda, where it's easy to do some hard things and hard to do most easy things.
11:19:36 <RyanT5000> cmp jne FTW!
11:19:42 <ihope> @unlambda ````.H.i.!ri
11:19:43 <lambdabot> Hi!
11:20:44 <monochrom> wow lambdabot knows unlambda!
11:21:09 <ihope> Oh boy, how's this work...
11:25:59 <ihope> Leaf = ``s`kk`si and Branch =...no, that's not right.
11:26:16 <ihope> \xybl.``bxy = \xyb.`k``bxy = \xy.``s`kk``s``si`kx`ky = \x.``s`k`s`kk``s`k`s``si`kxk = ``s`k`s`k`s`kk\x.``s`k`s``si`kxk
11:26:26 <ihope> But then it gets all messed up.
11:26:42 <Trevion> I'm glad it only gets messed up after that part.
11:27:02 <RyanT5000> that code looks highly maintainable
11:27:09 <monochrom> Is that Klingon? XD
11:27:20 <Trevion> I think Klingon has fewer backquotes.
11:28:08 <RyanT5000> and is significantly more readable
11:28:29 <Trevion> Somewhat less Turing complete, however.
11:28:57 <RyanT5000> hm, could you consider human languages to be turing complete?
11:29:05 <RyanT5000> ambiguous, yes
11:29:09 <ihope> \xybl.``bxy. It can't be *that* hard to eliminate...
11:29:20 <RyanT5000> but theoretically you can describe any turing machine in English
11:29:50 <RyanT5000> also, in theory you could make a subset of english that could still do that and was still turing-complete
11:29:58 <RyanT5000> and was unambiguous
11:30:13 <ihope> English can solve its own halting problem!
11:30:32 <RyanT5000> so can you have a language that is turing complete, such that supersets of that language are not turing complete?
11:30:42 <ihope> Um, no.
11:31:15 <RyanT5000> well, then english is turing complete :)
11:31:28 <RyanT5000> and so presumably klingon is as welll
11:35:16 <ihope> Let's try this thing...
11:35:37 <ihope> ````s`k`s`k`s`kk``s``s`ks``s`kk``s`ks``s`k`sik`kk is the branch operator, and ```s`kk`si is the leaf operator?
11:36:14 <ihope> @unlambda ``````s`k`s`k`s`kk``s``s`ks``s`kk``s`ks``s`k`sik`kk```s`kk`si.H```s`kk`siiii
11:36:14 <lambdabot> Done.
11:36:19 <ihope> Bleh.
11:49:32 <vincenz> @unlambda s
11:49:32 <lambdabot> Done.
11:49:38 <vincenz> what's that good for?
11:49:46 <vincenz> @unlambda .s
11:49:46 <lambdabot> Done.
12:31:57 <vincenz> @unlambda i.H
12:31:57 <lambdabot> Done.
12:42:24 <mauke> @unlambda `.Hi
12:42:24 <lambdabot> H
12:45:37 <vincenz> what does ` do?
12:45:43 <mauke> function application
12:45:53 <vincenz> @unlambda `.H
12:45:53 <lambdabot> unlambda: Parse error at end of file
12:45:57 <vincenz> and .
12:46:10 <mauke> .H is the function that prints 'H' when called
12:46:19 <vincenz> with any arg
12:46:24 <vincenz> @unlambda `.hk
12:46:24 <lambdabot> h
12:46:30 <vincenz> @unlambda `.h.h
12:46:31 <lambdabot> h
12:46:36 <mauke> yes, it's otherwise equivalent to i
12:47:02 <vincenz> too bad you can't see the result
12:49:52 <RyanT5000> is iterating over an Array with ! better or worse than using assocs?
12:50:07 <RyanT5000> (assume you're iterating over the entire thing)
12:50:11 <RyanT5000> (in order)
12:51:15 <xerox> Worse.
12:52:12 <RyanT5000> that's what i figured
12:52:29 <RyanT5000> but it's still doing a ton of allocation
12:52:47 <RyanT5000> otoh i'm not sure that it's just assoc doing the allocation
12:58:07 <RyanT5000> so apparently mapM_ (stuff) (zip (stuff) (assocs a)) is a bad idea
12:58:46 <RyanT5000> some day i'll understand the performance of high-level languages... lol
13:04:15 <mahogny> hello RyanT5000 
13:04:37 <RyanT5000> hi
13:04:43 <mahogny> how's it going?
13:04:58 <RyanT5000> pretty good; i'm not really working on the formal gui stuff any more, although i'm writing the same code anyway
13:05:10 <mahogny> ah ok
13:05:15 <RyanT5000> i'll probably still write the resource caching system though
13:06:18 <RyanT5000> i'm really getting impressed by haskell now, though
13:06:49 <mahogny> only now? :)
13:06:57 <RyanT5000> yesterday in about 10 hours i wrote some simple datastructures from my game, rendering, and picking
13:07:06 <RyanT5000> that took me like 2 weeks in C++
13:07:13 <RyanT5000> granted this is my second or third shot at it, but still
13:08:02 <RyanT5000> let me clarify: the CS part of my brain has been ridiculously impressed the whole time; now the business side is getting interested, lol
13:08:14 <mahogny> OOP usually means writing more setters and getters than actually producing code. if you allow yourself to abstract classes away from OOP, then C++ is still rather efficient
13:08:18 <mahogny> lol
13:08:33 <RyanT5000> yeah OOP pisses me off
13:08:40 <RyanT5000> i mean, syntactic oop
13:08:44 * mahogny likes OOP, but not classes
13:08:49 <RyanT5000> right, i agree
13:09:02 <RyanT5000> i was thinking of going back to C, before
13:09:15 <RyanT5000> just to force myself to not get caught up in any of the C++ BS
13:09:24 <mahogny> lol
13:09:29 <mahogny> I never left C. that was my solution :P
13:09:42 <RyanT5000> well i technically started in C++
13:09:52 <RyanT5000> so "going back" i mean history-wise, not personally
13:10:00 <RyanT5000> but then i found haskell :P
13:10:14 <mahogny> I disliked C++ as soon as I heard that it didn't have realloc
13:10:34 <RyanT5000> hm, actually all the array allocation semantics in C++ kind of suck
13:11:07 <RyanT5000> e.g.: it's a total pain in the ass to use new to make an array whose elements are initialized to nondefault values
13:11:16 <wilx> Well, you are supposed to use std::vector<>.
13:11:17 <mahogny> aha
13:11:32 <mahogny> wilx, not in the original C++ :)
13:11:54 <wilx> Eh, what is "original C++?"
13:12:12 <mahogny> the first version, without the later additions such as STL etc
13:12:21 <mahogny> STL is what made C++ usable
13:13:04 * mahogny still laughs at the early debate about STL not being OOP
13:13:13 <wilx> Who cares about pre-standard C++ these days?
13:13:32 * palomer still laughs at the muppet show
13:13:43 <mahogny> hm. I think it was rather nasty even the first standard
13:13:53 <mahogny> anyhow. just don't use it. simple solution :)
13:15:02 <RyanT5000> it seems to me that with your platform's asm, haskell, and c (for interfacing to nonhaskell libs), you're pretty much set
13:15:21 <RyanT5000> especially once TH becomes stable (in reality, not version number)
13:17:19 <thetallguy> I'd agree, although I think there are some tasks that are not quite there yet.
13:17:54 <thetallguy> GUI work is still fragmented.  Not that it isn't outside the Haskell environment...
13:18:15 <RyanT5000> yeah, i'm semi-working on that
13:18:31 <RyanT5000> i would be actually working on it if google hadn't turned me down :-(
13:19:07 <reppie> why did thy turn you down?
13:19:22 <RyanT5000> there were like 112 applicants for SoC, and they accepted like 10
13:19:34 <reppie> oh it wasn't google who turned you down
13:19:39 <RyanT5000> yeah, it was the haskell people
13:19:50 <reppie> clearly they hate you
13:19:54 <RyanT5000> but that's ok :) i understand that language stuff > GUI
13:20:02 <reppie> they hate freedom and want to destroy your way of life
13:20:05 <RyanT5000> lol
13:21:58 <thetallguy> Ooh.
13:22:05 <thetallguy> I think that language === GUI
13:22:53 <thetallguy> Where === is defined as, are so intertwined that they should be considered equally important.
13:23:03 <thetallguy> RyanT5000: what was your proposal?
13:24:52 <RyanT5000> to make a purely-functional GUI combinator and widget library intended to render into OpenGL or other 3d environments
13:24:54 <dmhouse> > let _ === _ = True; language = True; gui = True in language === gui
13:24:55 <lambdabot>  True
13:25:19 <palomer> can't argue with FACTS
13:25:39 <vincenz> > let _ ==== _ = True; dmhouse = 1; dumb = 1 in dmhouse ==== dumb
13:25:40 <lambdabot>  True
13:27:46 <thetallguy> :-)
13:27:49 <thetallguy> Sounds nice
13:28:01 <thetallguy> There are several others here interested in such a thing
13:28:08 <vincenz> huh?
13:28:29 <thetallguy> replying to RyanT
13:28:34 <vincenz> ah
13:28:42 <vincenz> but I disagree with language === GUI
13:28:56 <vincenz> at best, runtime === GUI with your definition of ===
13:29:06 <thetallguy> No
13:29:16 <RyanT5000> i have no idea what === is supposed to mean
13:29:20 <thetallguy> I have a very agressive definition of GUI
13:29:29 <mahogny> I wouldn't mind a separate language for GUI-stuff; usually you want to have the GUI well-separated anyway
13:29:47 <RyanT5000> meh, there's no need for a separate language
13:29:48 <thetallguy> I disagree with that as well.
13:29:56 <RyanT5000> unless you mean a DSL
13:30:18 <thetallguy> I think you want your GUI to use some very powerful features of your language
13:30:24 <mahogny> not really; I usually find class based languages much nicer for GUIs
13:30:25 <RyanT5000> how about this thedward: computer == GUI
13:30:30 <vincenz> woot
13:30:30 <vincenz> cool
13:30:34 <mahogny> O_O
13:30:39 <RyanT5000> er
13:30:42 <RyanT5000> thetallguy
13:30:59 <vincenz> Please reply to this message or send an email to banquet@......org indicating your meal choice for the main course at the conference banquet.
13:31:14 <RyanT5000> if you define a GUI as a multimedia interaction paradigm, that includes the entire system
13:31:34 <RyanT5000> since technically the processing semantics are part of the interaction semantics
13:31:35 <mahogny> GUI... I hate GUIs. UIs need a major revamping overall
13:31:43 <RyanT5000> true
13:31:46 <thetallguy> A small example: http://portal.acm.org/citation.cfm?id=259008&dl=ACM&coll=ACM
13:31:51 <lambdabot> Title: "Generating efficient virtual worlds for visualization using partial evaluation a ..."
13:31:59 <mahogny> and then just in yet-another-widget-manager
13:32:05 <mahogny> *not just
13:32:27 <RyanT5000> yeah, i agree
13:32:49 <thetallguy> Making truly dynamic UI's involves putting the power of programming at a user's fingertips, without forcing them to actually program.
13:32:55 <RyanT5000> right
13:33:28 <thetallguy> To that end, you want to have the full feature set of a language/compiler available to you as a developer.
13:33:35 * palomer pokes cale
13:33:38 <vincenz> dmhouse: I was just playing around, hope you're not pissed
13:33:40 <mahogny> Death to WIMP
13:33:46 <thetallguy> I've very glad to see GHC. modules being published.
13:34:07 <thetallguy> You might talk to stepcut about this as well
13:34:09 <mahogny> computers need to be better integrated overall
13:34:13 <thetallguy> He's not on right now.
13:34:22 <thetallguy> Death to two level languages.
13:34:28 <dmhouse> vincenz: I'm reading up on how I op up so I can kick you, FYI.
13:34:29 <dmhouse> :)
13:34:43 <dmhouse> Don't worry, I've got a good sense of humour.
13:35:12 <vincenz> :)
13:35:27 <vincenz> dmhouse: if you want, I'm op, and I can kick you, the net result will be the same, we won't be in the same room
13:35:41 <vincenz> :D
13:35:41 * mahogny wonders when he can get hold on some lcd to put on his glasses. or laser retina drawing
13:35:55 <vincenz> mahogny: why not go for straight brain projection
13:36:15 <mahogny> vincenz, because unlike the above, I doubt I will have it for a while :)
13:38:20 <vincenz> you won't have laser retina for a while either
13:38:31 <vincenz> after a shorter while they'll burn your eyes out
13:38:49 <mahogny> well. it exists already, but not really for commercial applications...
13:39:01 <vincenz> I was putting another semantics on the term "while"
13:39:26 <mahogny> shorter :: Word -> Word
13:39:29 <mahogny> hm? :)
13:40:13 <dmhouse> vincenz: How proficient are you with IRC-fu?
13:40:23 <vincenz> dmhouse: depends
13:40:44 <vincenz> mahogny: no as in...even if they exist now, you'll only use them for a short while before your eyes burn out
13:40:58 <dmhouse> vincenz: Would I myself be able to delete davidhouse from the #haskell access list and add dmhouse?
13:41:05 <mahogny> vincenz, they haven't gotten farther than that yet?
13:41:09 <RyanT5000> lets say i have a function makeDisplayList :: IO () -> IO DisplayList, and a function callDisplayList :: DisplayList -> IO (); now let's say i have a function render :: Stuff -> IO (); is there a way to make it so that the first time it's called with the same exact "Stuff" argument it makes  the display list and calls it, and all subsequent times it just calls it?
13:41:32 <vincenz> dmhouse: I think you need a higher number to add yourself
13:41:47 <ricebowl> question
13:41:51 <dmhouse> vincenz: I'll ping shapr.
13:41:55 <dmhouse> shapr: around?
13:41:56 <RyanT5000> i presume i'd need some way of getting some kind of low-level "reference" to the Stuff (it's too expensive to use (==))
13:42:05 <ricebowl> I have a generic function, and I need for one particular specialization to behave differently
13:42:09 <ricebowl> what is the syntax to do that?
13:42:14 <vincenz> RyanT5000: I have an interpreter written in haskell with a same concept
13:42:18 <mahogny> RyanT5000, in C, I usually toss around a flag
13:42:24 <dmhouse> ricebowl: talk more concretely.
13:42:27 <vincenz> RyanT5000: basically I have a heap .... and I compare references into that heap
13:42:47 <ricebowl> take a hypothetical function, foo :: Num a => a -> a
13:42:49 <vincenz> ricebowl: parametric polymorphism is not lke c++ templates
13:42:52 <aFlag> i have to implement the language that i have commented in the begining of the code. Everything seems fine, except the "e e" part of the grammar, I can't figure out how to parse it. Could someone help me out?
13:42:56 <ricebowl> I want foo :: Int -> Int to be special
13:42:57 <RyanT5000> ricebowl: classes
13:43:05 <ricebowl> (easier than explaining what I'm doing)
13:43:06 <ricebowl> hmm
13:43:17 <RyanT5000> it's not exactly the same though
13:43:21 <vincenz> RyanT5000: that won't do it either
13:43:23 <ricebowl> I see... well, it will work
13:43:30 <ricebowl> is there a way to supply a default version?
13:43:31 <vincenz> cause then he has to copy paste the default instance for all other instances he want
13:43:34 <vincenz> ricebowl: no
13:43:43 <RyanT5000> yeah, there's no way of doing it with a default
13:43:45 <ricebowl> I can paste, there are only 3 instances
13:43:58 <RyanT5000> it's not a good idea anyway, though
13:43:59 <vincenz> class Foo where
13:44:00 <ricebowl> not as elegant, but it will work... thanks
13:44:11 <vincenz> class Foo poo where
13:44:16 <vincenz>   foo :: poo -> poo
13:44:19 <vincenz> instance Foo Int where 
13:44:19 <vincenz> ...
13:44:20 <RyanT5000> defaults mean that other people changing code that you import can change the meaning of your code without you knowing
13:44:38 <dmhouse> ricebowl: There might be a better task for what you want. What are you aiming for in a wider context?
13:45:12 <aFlag> ops
13:45:20 <aFlag> i forgot to say the code address
13:45:23 <aFlag> http://www.rafb.net/paste/results/OCQ8ZE20.html
13:45:44 <dmhouse> s/task/solution/. Not thinking today.
13:46:16 <vincenz> hmm
13:46:25 * vincenz wonders if he should use parsercombinators
13:46:38 <vincenz> dmhouse: btw did ya know my interpreter works too?
13:47:10 <vincenz> \o/
13:47:35 <dmhouse> Nice! :)
13:47:41 <aFlag> :(
13:48:05 <vincenz> aFlag: smple answer, not feasible
13:48:08 <vincenz> e = e e 
13:48:10 <vincenz> is not LL
13:48:49 <vincenz> you can do something like
13:48:51 <vincenz> e = e' e'
13:48:54 <vincenz> e' = (e)
13:49:07 <vincenz> or some other hack
13:49:07 <aFlag> what's LL?
13:49:15 <vincenz> parsec is ll
13:49:21 <dmhouse> LL1, isn't it?
13:49:26 <vincenz> left-to-right, leftmost
13:49:29 <aFlag> oh
13:49:30 <aFlag> i see
13:49:40 <vincenz> dmhouse: no, LL(k) they claim...but that's assuming you do the dirty hacking
13:49:47 <aFlag> but it would be the same right to left, wouldn't it?
13:49:56 <dmhouse> vincenz: Without try it's LL1. It's optimised for LL1.
13:50:04 <vincenz> aFlag: simple example
13:50:10 <vincenz> e e e e
13:50:17 <vincenz> there's multiple ways to parse this
13:50:23 <aFlag> yes
13:50:30 <vincenz> so...you want to fix your grammar
13:50:33 <vincenz> so it's parseable
13:50:36 <dmhouse> aFlag: LL1 means you need to be able to tell which branch of a parser to take given one character.
13:50:53 <aFlag> hum
13:51:15 <dmhouse> For example, if both "abcd" and "abdc" were possible inputs, that's an ambiguous LL1 grammar because you can't tell them apart by looking at the first character.
13:51:40 <aFlag> hum
13:53:07 <vincenz> dmhouse: know of any fast lc interpreter around?
13:53:15 <dmhouse> LC?
13:53:20 <vincenz> lambda-calc
13:53:36 <dmhouse> Ah. It's quite easy to write one. I don't know about efficiency.
13:54:27 <dmhouse> It's a lovely application of Reader, at least :)
13:54:37 <dmhouse> You even get to use local (!).
13:55:15 <aFlag> hehe i'm not finding it that easy :P
13:55:16 <vincenz> how so?
13:55:21 <vincenz> dmhouse: how do you even need reader?
13:55:44 <dmhouse> It's nice to use Reader to keep an environment of all the current bindings.
13:55:57 <vincenz> oh
13:55:59 <vincenz> don't need that
13:56:39 <vincenz> dmhouse: I read this interesting article where they simulated a virtual environment by having like 10000 LC-strings floating around, randomly selecting two and using one as input to the other, then saving the results, and randomly picking out stuff to throw away to keep a fixed size population
13:57:25 <xerox> Any link?
13:58:29 <vincenz> sadly the implementation is in c
13:58:39 <vincenz> http://www.santafe.edu/~walter/AlChemy/
13:58:41 <lambdabot> Title: "Index of /~walter/AlChemy"
14:05:44 <vincenz> it's interesting cause unlike systems that use turing machines, there's no programs that run infinitely, so it's easier to simulate, at least that's what the source where I got this info said
14:09:16 <mahogny> interesting. I'm currently using turing machines for this, but OTOH I dunno how much use I would have of LC-machines for the properties I want to study
14:10:40 <dmhouse> Is there syntactic sugar/a handy function for [minBound..maxBound] :: [a]?
14:11:59 <mahogny> don't recall one in H98 at least
14:13:43 <vincenz> there are some other points made
14:13:49 <vincenz> if you guys are interested
14:14:02 <vincenz> mahogny: care to discuss privately in oasis?
14:14:10 <mahogny> vincenz, sure
14:18:02 <RyanT5000> is there a priority heap in the hierarchical libraries?
14:18:31 <Trevion> You can approximate one with a Data.Map
14:18:40 <RyanT5000> efficiently?
14:19:02 <Trevion> insert and findMin are both O(log n), but I have no idea about coefficients.
14:19:11 <RyanT5000> hm
14:19:19 <Trevion> I believe Edison has quite a few heap-like things, but I don't know the details of their differences.
14:19:35 <dmhouse> I think 2-3 Finger Trees are good for priortiy queues. Hinze wrote a paper on them, they're quite fun.
14:19:43 <RyanT5000> i think Data.Map will be good enough probably
14:20:27 <RyanT5000> i guess technically i just need a priority queue
14:20:32 <RyanT5000> i'm making a simple cache manager
14:20:56 <Trevion> They're not hard to write either.  I hacked one together a while ago that uses IOArrays.
14:21:03 <RyanT5000> hm
14:21:20 <vincenz> dmhouse: got a link?
14:21:38 <dmhouse> @google 2-3 finger trees "ralf hinze"
14:21:39 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/talks/Oxford.pdf
14:22:57 <vincenz> dmhouse: wellversed in LC?
14:23:16 <vincenz> @google lambda calculus
14:23:17 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
14:23:39 <dmhouse> == Relationship with Monoids ==
14:23:44 <dmhouse> err, sorry.
14:24:00 <dmhouse> vincenz: fsvo wellversed :) Why?
14:24:20 <dmhouse> It certainly interests me.
14:24:21 <vincenz> dmhouse: can you type the s k an i thingies?
14:24:35 <dmhouse> Can I type them? In what way?
14:24:39 <dmhouse> S, K, I. Seems so.
14:24:45 <vincenz> ... as in what they do
14:24:57 <xerox> I = id
14:24:59 <xerox> K = const
14:25:04 <xerox> S = I always forget
14:25:17 <vincenz> how would you write (lambda x (x x))
14:25:36 <dmhouse> xerox: S = ap
14:25:42 <xerox> ap! /me takes note
14:25:53 <dmhouse> S x y z = x y (y z).
14:26:06 <thetallguy> @type \x -> x x
14:26:07 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
14:26:07 <lambdabot>    Expected type: t
14:26:09 <vincenz> dmhouse: that's give x(y (yz))
14:26:14 <dmhouse> err, x z (y z), i think.
14:26:15 <vincenz> ?
14:26:43 <dmhouse> vincenz: Sorry?
14:26:57 <vincenz> dmhouse: (x z) (y z) or x (z (y z))
14:26:59 <vincenz> erm
14:27:01 <dmhouse> thetallguy: not possible in a typed lambda calculus.
14:27:11 <dmhouse> (x z) (y z).
14:28:03 <dmhouse> \x -> x x should be possible, as the SKI calculus is untyped.
14:28:09 <vincenz> how
14:28:20 <thetallguy> dmhouse: yup.
14:28:31 <dmhouse> Ah, SII is it.
14:28:45 <vincenz> I would think
14:28:47 <vincenz> S*I
14:28:50 <vincenz> * being anything
14:28:59 <vincenz> oh wait, nm
14:30:39 <dmhouse> (\x y z -> x z (y z)) (\x -> x) (\x -> x) a; (\x -> x) a ((\x -> x) a); a a.
14:31:44 <vincenz> dmhouse: you need te proper amount of ` tho
14:31:47 <vincenz> in the right places
14:31:58 <dmhouse> What do you mean?
14:33:02 <vincenz> dmhouse: `... to apply
14:34:35 <dmhouse> Sorry, I'm quite tired and am not really following you. You don't need anything other than SII to produce \x -> xx.
14:45:42 <dmhouse> Haha, here's one to confuse you if you're not used to combinatory calculi: or = true, and = false.
14:46:36 <vincenz> ah I knkow :)
14:46:38 <vincenz> dmhouse: and 1 = true
14:46:44 <dmhouse> Yep.
14:46:48 <dmhouse> and true = const.
14:46:52 <vincenz> 2 = true true
14:46:57 <vincenz> 3 = true true true
14:47:01 <dmhouse> Too true.
14:48:26 <int-e> so ... or = true = const? something is fishy there.
14:48:41 <int-e> (true = 1 = id, false = 0 = const  are familiar to me.)
14:49:08 <palomer> true = const is familiar to me
14:49:22 <int-e> hmm.
14:49:37 <int-e> sorry, I messed that one up :(
14:49:49 <palomer> false = \x y -> y is familiar to me too
14:49:58 <palomer> grr, where's cale when you need'em
14:50:11 <int-e> true = const, 1=id, false = 0 = flip const.
14:50:25 <palomer> sure
14:51:09 <int-e> anyway, I'd still have or x = x true; and x = x false ...
14:51:38 <int-e> no. and x = flip x false
14:51:47 * int-e tries to wake up.
14:51:52 <palomer> 3 = true true true = const const const = const
14:51:58 <palomer> =1
14:52:12 <dmhouse> @type const const const
14:52:13 <lambdabot> forall a b. a -> b -> a
14:52:23 <dmhouse> > (const const const) 4 'a'
14:52:24 <lambdabot>  4
14:52:36 <palomer> const const const is obviously const
14:53:24 <dmhouse> int-e, the definition offered by wikipedia are as followed:
14:53:29 <dmhouse> *follows
14:54:18 <dmhouse> T = K; F = KI; OR is an infix function and is T.
14:54:48 <int-e> 'infix function' ... argh.
14:55:09 <int-e> that's a big abuse of terminology.
14:55:30 <dmhouse> so (T)OR(T) = T(T)T = T. (T)OR(F) = T(T)F = T. (F)OR(T) = F(T)T = T. (F)OR(F) = F(T)F = F.
14:55:32 <int-e> T x y = x, F x y = y. That's standard.
14:56:22 <dmhouse> AND is postfix and = F.
14:56:28 <int-e> that makes AND a postfils function? Gah.
14:56:36 <int-e> Sorry, I don't like that.
14:56:41 <dmhouse> No, nor do I.
14:57:45 <dmhouse> int-e, so what are your OR and AND in SKI?
14:58:22 <int-e> hmm. OR: \x -> x (KI) = SI(K(KI))
14:59:18 <dmhouse> hmm?
14:59:27 <dmhouse> You just said OR x = x T.
14:59:31 <xerox> Oyasuminasai.
14:59:35 <xerox> Err.. goodnight.
14:59:36 <heatsink> goodnight
14:59:49 <BCoppens> お休み to you too
15:00:54 <mahogny> more jap students here?
15:01:01 <int-e> so? that's good for defining a new combinator. But in terms of SKI it's useless.
15:01:26 <dmhouse> int-e, no, but then \x -> x (KI) would mean that OR x = x F.
15:01:32 <BCoppens> mahogny: nah, just infrequent anime watcher ;)
15:01:39 <mahogny> BCoppens, :)
15:01:54 <BCoppens> :)
15:01:59 <int-e> ah dang. SI(KK) then.
15:02:35 <vincenz> int-e: sick indeed
15:03:00 <heatsink> a combinator just left.
15:03:19 <dmhouse> I've always wanted to ask him if that's where he got his name
15:03:56 <int-e> AND = \x y -> x y (KI) = \x -> Sx(K(KI)) = SS(K(K(KI)))  if I didn't mess up again.
15:04:22 <Lokadin> @seen dons
15:04:22 <lambdabot> dons is in #haskell-overflow, #haskell-blah and #haskell. I last heard dons speak 6 hours, 33 minutes and 28 seconds ago.
15:04:43 <int-e> It's been a while that I've done that unabstraction stuff manually.
15:04:57 <dmhouse> Let's see.
15:07:04 <dmhouse> (AND)TT = (\x y -> x y (KI))TT = T T (KI) = T.
15:07:16 <dmhouse> (AND)TF = (\x y -> x y (KI))TF = T F (KI) = F.
15:07:31 <dmhouse> (AND)FT = (\x y -> x y (KI))FT = F T (KI) = KI = F.
15:07:53 <int-e> well, I'm confident the \x y -> x y (KI) is right. It's the  SS(K(K(KI))) that I'm not absolutely sure about (still looks good though)
15:08:06 <dmhouse> (AND)FF = (\x y -> x y (KI))FF = F F (KI) = KI = F, so that bit checks out.
15:08:27 <dmhouse> Hmm, someone should write an @ski lambda -> combinatory calculus plugin.
15:10:03 <int-e> > let s x y z = x z (y z); i x = x; k x y = x; or = s i (k (k i)); and = s s (k (k (k i))); true = k; false = k i; toString x = x "T" "F" in map toString $ zipWith and [false, false, true, true] [false, true, false, true]
15:10:04 <lambdabot>  ["F","F","F","T"]
15:10:10 <int-e> > let s x y z = x z (y z); i x = x; k x y = x; or = s i (k (k i)); and = s s (k (k (k i))); true = k; false = k i; toString x = x "T" "F" in map toString $ zipWith or [false, false, true, true] [false, true, false, true]
15:10:11 <lambdabot>  ["F","T","F","F"]
15:10:42 <int-e> > let s x y z = x z (y z); i x = x; k x y = x; or = s i (k (k i)); and = s s (k (k k)); true = k; false = k i; toString x = x "T" "F" in map toString $ zipWith or [false, false, true, true] [false, true, false, true]
15:10:43 <lambdabot>  ["F","T","F","F"]
15:10:52 <int-e> oops.
15:11:02 <int-e> > let s x y z = x z (y z); i x = x; k x y = x; or = s i (k k); and = s s (k (k (k i))); true = k; false = k i; toString x = x "T" "F" in map toString $ zipWith or [false, false, true, true] [false, true, false, true]
15:11:03 <lambdabot>  ["F","T","T","T"]
15:11:05 <int-e> there.
15:11:41 <int-e> dmhouse: that'd be a restricted version of @pl
15:11:44 <dmhouse> > sequence [[True, False], [True, False]]
15:11:45 <lambdabot>  [[True,True],[True,False],[False,True],[False,False]]
15:12:17 <dmhouse> > let pairise [x,y] = (x, y) in map pairise $ sequence [[True, False], [True, False]]
15:12:18 <lambdabot>  [(True,True),(True,False),(False,True),(False,False)]
15:13:09 <int-e> > join (liftM2 (,)) [False,True]
15:13:10 <lambdabot>  [(False,False),(False,True),(True,False),(True,True)]
15:13:34 <int-e> > join (liftM2 (||)) [False,True]
15:13:35 <lambdabot>  [False,True,True,True]
15:14:50 <dmhouse> ski: Your nick anything to do with the combinator calculus with the same name?
15:26:06 <vincenz> hmm
15:26:15 <vincenz> I found a little problem with types in haskell
15:27:16 <heatsink> well fix it already!
15:27:27 <heatsink> :p what is it?
15:28:14 <vincenz> basically
15:28:23 <vincenz> you can not have recursive types without some data constructor n between
15:28:38 <vincenz> (recursive haskell types are equirecursive not isorecursive)
15:28:48 <vincenz> erm, the other way around
15:29:02 <vincenz> anyways
15:29:05 <heatsink> yea.  I've never been bothered by that.
15:29:07 <int-e> newtype works. that's as close as you get.
15:29:12 <vincenz> right but wait
15:29:13 <vincenz> let me finish
15:29:26 <vincenz> data Foo a b = A a | B b
15:29:30 <vincenz> ok?
15:29:34 <heatsink> yea
15:29:45 <vincenz> now...
15:29:52 <vincenz> let's simplify
15:29:54 <vincenz> data Foo a = F a
15:30:13 <vincenz> newtype RecursiveFoo = RF (Foo RecursiveFoo)
15:30:23 <vincenz> now Foo already has a datacons, so why the need for this to be reucrsive
15:30:33 <vincenz> aka... the recursion goes through a type that's a data or newtype (Foo)
15:30:39 <vincenz> why force this to be newtype'd too
15:30:53 <vincenz> a compiler should be able to check this
15:32:31 <heatsink> You mean, instead of [| data RecursiveFoo = Foo RecursiveFoo |]?
15:32:41 <vincenz> no
15:32:54 <vincenz> wait
15:32:58 <vincenz> heatsink: what does that mean?/
15:32:59 <heatsink> s/data/type/
15:33:05 <vincenz> oh yes then
15:34:05 <dmhouse> > Just 4 `mplus` Just 5
15:34:06 <lambdabot>  Just 4
15:38:08 <heatsink> Well, data declarations are meant to be syntactic sugar that get eliminated during compilation.  I don't know what goes on with 'em in the compiler.
15:39:08 <dmhouse> data declarations are syntactic sugar?! The most complicated sugar I've seen, if so.
15:39:16 <heatsink> d'o
15:39:20 <heatsink> s/data/type/
15:39:40 <dmhouse> Oh, synonyms. Heh. Yep. :)
15:40:01 <dmhouse> They're not quite, because of the interactions with the typeclass system.
15:40:03 <shapr> dmhouse: Can you link your nickname?
15:40:09 <dmhouse> shapr!
15:40:18 <dmhouse> shapr: Sure, give me a minute.
15:40:31 <shapr> I think that'll give you access anyway.
15:41:09 <shapr> dmhouse: Yeah, it will.
15:41:22 <dmhouse> Okay. I think I already have a link davidhouse -> dmhouse, so I'll need to do some nick-fu, hold on.
15:41:50 <franka> "link"?
15:42:08 <dmhouse> shapr, All right, linked up.
15:42:13 <dmhouse> franka: /msg NickServ help list
15:42:23 <dmhouse> shapr: I'll try opping up.
15:42:50 <dmhouse> Hrm.
15:43:10 <dmhouse> To op myself, it's /mode #haskell +o dmhouse, right?
15:43:20 <dmhouse> Or do you do something funky when opping yourself?
15:43:29 <BCoppens> not /ns OP #haskell dmhouse?
15:43:41 <dreamEye> @fortune
15:43:41 <lambdabot> Witch!  Witch!  They'll burn ya!
15:43:41 <lambdabot> 		-- Hag, "Tomorrow is Yesterday", stardate unknown
15:43:42 <BCoppens> apparently not
15:44:03 --- mode: ChanServ set +o dmhouse
15:44:05 <BCoppens> dmhouse: /cs OP is more likely =)
15:44:11 <dmhouse> Got it.
15:44:13 <dreamEye> hi, Good save Haskell
15:44:38 <dmhouse> shapr, BCoppens, thanks.
15:44:44 <BCoppens> :)
15:44:48 <shapr> :-)
15:45:00 <shapr> hoi franka 
15:45:07 <dreamEye> why people do things? for the power, for the money? for the beauty of itself?
15:45:10 <franka> Hi, shapr.
15:45:21 <shapr> dreamEye: I do Haskell for the beauty.
15:45:28 <dreamEye> me too
15:45:34 <dreamEye> And this is strange
15:45:41 <dmhouse> I did Haskell initially for the beauty, but now it's because of the intense theory behind it.
15:45:47 <dreamEye> given that im a practical man
15:45:54 <shapr> Yeah, but the theory is so beautiful.
15:46:14 <dmhouse> True. I meant I did it initially for the elegant code I was writing.
15:46:20 <dreamEye> Its a combination of simplicity and complexity
15:46:22 <dmhouse> dreamEye: I had precisely the same experience.
15:46:26 <vincenz> @join #oasis
15:46:29 <shapr> And it's so easy to see how my paid code could be more beautiful and powerful if I were allowed to apply these theories.
15:46:54 <dmhouse> Mmm. Jools Holland. :) I love Friday nights.
15:47:59 <dreamEye> dmhouse I think that beauty is a mix of simplicity, utility and powerfulness
15:48:03 <franka> Eh?  Jools Holland?
15:48:49 <dmhouse> http://en.wikipedia.org/wiki/Jools_Holland
15:49:16 <dreamEye> Beauty is a unconscious appreciation of these three qualities
15:49:45 <vincenz> wow
15:49:45 <franka> Oh.
15:49:47 <shapr> Sometimes I see beauty in complex abstract art, and that doesn't have any of those.
15:49:47 <dreamEye> so utility is hidden in beauty
15:50:18 <franka> I don't think Monica Belucci is simple or useful or powerful...
15:50:27 <dmhouse> franka: He does a great show which is basically a showcase of quite new music. All the bands on it rock. And he himself is an awesome pianist.
15:50:32 <franka> Well, "useful" for certain purposes, perhaps.
15:50:40 <dreamEye> but my theory is beatiful, dont mess me with the reallity
15:51:33 <dreamEye> Monica Belucci is simple because you know how to handle it. It is  powerful because she proyect your genes in the next generation. so is utile
15:51:53 <dmhouse> s/utile/useful/. Francophone? :)
15:52:01 <dreamEye> useful, sorry
15:52:25 <franka> Hm.
15:52:28 <franka> Yeah.
15:52:36 <franka> I will pretend I understood what you just said.
15:53:20 <dreamEye> according with evolutionary psychologists, out perception of beauty is the conscious experience of a unconscious perception of potential utility
15:54:01 <dmhouse> Someone name a random function that ends with Maybe something, and isn't a lookup-style function.
15:54:19 <dmhouse> And no smart-ass answers like mplus, return or (>>=) :)
15:54:30 <shapr> Maybe something?
15:54:37 <shapr> je ne comprends pas.
15:54:38 <franka> fooMaybe
15:54:40 <dmhouse> Maybe a. I don't care what the a is.
15:54:44 <shapr> catMaybes?
15:54:48 <shapr> ah
15:55:02 <franka> maybeMaybe
15:55:16 <shapr> dmhouse: Parsers function can use that for failure.
15:55:23 <shapr> Is that lookup?
15:55:29 <dmhouse> I was thinking something I could use as an example when explaining the Maybe monad, so something that lends itself to compuational thinking.
15:55:43 <dmhouse> Hmm... parsers might do.
15:55:47 <franka> monus is a maybe function.
15:55:57 <franka> monus = subtraction on naturals
15:56:15 <franka> Nat -> Nat -> Maybe Nat
15:56:42 <franka> All partial functions can be characterized the same way.
15:57:33 <dreamEye> Beauty at last is the result of a (complex) algorithm executed in our brain. THere are a lot of interesting things about this subject.
15:57:43 <bringert> shapr: you can now tag blog entries in hope
15:58:25 <bringert> shapr: note that there is a DB schema change, see the darcs changelog
15:58:57 <shapr> yay!
16:00:41 <mathewm> For type Key = String, and type Value = String; I want to turn a [ Key, Value, Key, Value ... ] into [ (Key,Value),(Key,Value)... ]
16:00:48 <mathewm> what is the shortest solution?
16:03:26 <franka> I think: zip (odds xs) (evens xs)
16:03:38 <dmhouse> @index odds
16:03:38 <lambdabot> bzzt
16:03:46 <dmhouse> You'd have to define those functions first.
16:03:47 <franka> where odds (x:xs) = evens xs; odds [] = []
16:04:08 <franka> evens (x:xs) = x : odds xs; evens [] = []
16:04:11 <bringert> dmhouse: this might not be the shortest, but it's easy: f [] = []
16:04:12 <bringert> f (k:v:xs) = (k,v) : f xs
16:04:32 <bringert> note that it fails on lists of odd length
16:04:44 <dmhouse> bringert: Also note it was mathewm who asked the question :)
16:04:51 <bringert> e
16:04:55 <bringert> right
16:05:20 <bringert> mathewm: f [] = []
16:05:21 <bringert> f (k:v:xs) = (k,v) : f xs
16:05:32 <shapr> bringert: Is tagging generic now? I was thinking about an "Edit Types" entry where I can allow tagging for any module/type, maybe even tags themselves :-)
16:05:42 <dmhouse> > let collect [] = []; collect [_] = []; collect (k:v:xs) = (k, v) : collect xs in collect [1..10]
16:05:43 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
16:05:52 <dmhouse> > let collect [] = []; collect [_] = []; collect (k:v:xs) = (k, v) : collect xs in collect [1..11]
16:05:53 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
16:06:08 <dmhouse> What bringert said was what I was thinking too, but I like franka's better.
16:06:37 <bringert> shapr: yes, it's generic, though each module that wants to use it needs to implement a gui for adding tags and viewing entries with a given tag
16:07:06 <dmhouse> Although he got odds and evens backwards.
16:07:55 <dmhouse> > let odds [] = []; odds (x:xs) = x : evens xs; evens [] = []; evens (x:xs) = odds xs; collect = liftM2 zip evens odds in collect [1..10]
16:07:56 <lambdabot>  [(2,1),(4,3),(6,5),(8,7),(10,9)]
16:08:01 <dmhouse> Haha, oops :)
16:08:02 <shapr> bringert: Excellent!
16:08:11 <dmhouse> > let odds [] = []; odds (x:xs) = x : evens xs; evens [] = []; evens (x:xs) = odds xs; collect = liftM2 zip odds evens in collect [1..10]
16:08:12 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
16:08:44 <xerox> bringert - Hi! The db change kills my simple -flat file? :)
16:08:59 <bringert> xerox: yep
16:09:24 * xerox cries. I shouldn't have taken hours to upload images on images :)
16:09:24 <bringert> xerox: did you add a lot of stuff to the db already?
16:09:41 <bringert> xerox: you can probably hack around it
16:10:06 <dmhouse> Nice definitions of odds and evens by the way. I would probably have done something ugly like odds = map snd . filter (odd . fst) . zip [1..]
16:10:40 <dmhouse> Or perhaps using a concatMap, to avoid multiple traversals.
16:11:23 <dmhouse> xerox: There's a guy called Paolo Nutini on the TV, and I keep thinking they're saying your name.
16:11:24 <xerox> bringert: not so big anyway, yeah, it can be done.
16:11:29 <bringert> a flatdb file is just show on a Data.Map of table names to tables, and a table is just a schema plus a list of rows, and a row is a list of name-value pairs
16:11:30 <franka> I think odds and evens is a standard example for infinite lists.
16:11:31 <xerox> dmhouse: hah!
16:11:41 <int-e> > map (\[a,b] -> (a,b)) $ takeWhile (not . null) $ unfoldr (Just . splitAt 2) [1..10]
16:11:42 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
16:11:53 <xerox> odds = 1 : map (+1) evens; evens = map (+1) ones
16:12:04 <dmhouse> ones?
16:12:10 <xerox> Woops.
16:12:13 <bringert> xerox: I wouldn't recommend using flatdb for storing lots of data btw
16:12:31 <xerox> bringert: I see. I was thinking about making a nicer frontend.
16:12:37 <dmhouse> franka: Probably. Doesn't mean they're not pretty. :)
16:12:50 <bringert> xerox: nice front-end for flatdb?
16:13:03 <xerox> Better than just editing it, which is a bit painful.
16:13:07 <bringert> ah
16:13:08 <bringert> yes
16:13:25 <bringert> you could implement simple SQL support for it :-)
16:13:41 <xerox> heh
16:13:42 <int-e> @pl \[a,b] -> (a,b)
16:13:43 <lambdabot> (line 1, column 2):
16:13:43 <lambdabot> unexpected "["
16:13:43 <lambdabot> expecting pattern
16:13:55 <int-e> @pl \(a:b:[]) -> (a,b)
16:13:55 <lambdabot> (line 1, column 7):
16:13:55 <lambdabot> unexpected "["
16:13:55 <lambdabot> expecting natural, identifier, "_" or "("
16:14:00 <int-e> aww
16:14:15 <bringert> xerox: I didn't really mean to hand edit the file, rather read it into haskell, modify and write back out
16:14:17 <int-e> @pl \x -> (head x,head $ tail x)
16:14:17 <lambdabot> liftM2 (,) head (head . tail)
16:14:34 <dmhouse> @hoogle Int -> Char
16:14:35 <lambdabot> Char.chr :: Int -> Char
16:14:35 <lambdabot> Char.intToDigit :: Int -> Char
16:14:35 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
16:14:43 * xerox howls in TheHunter's general direction
16:15:02 <xerox> bringert - Right. I was thinking the same but in the end I just hand-edited it.
16:16:10 <bringert> ah, so the hours spent uploading files was just a joke
16:16:13 <bringert> :-)
16:16:39 <xerox> Well, I had to do it multiple times.
16:16:52 <xerox> I got mad at the id not being [1..]
16:17:01 <int-e> @karma+ jhc (ghc-6.5: panic! (the 'impossible' happened))
16:17:02 <lambdabot> jhc's karma raised to 1.
16:17:06 <xerox> (Since you have to use them by hand in posts.)
16:17:37 <xerox> Also, seems like that if you upload multiple images the id order is reversed or something.
16:17:51 <xerox> More importantly `nextId' seem to be `lastId' in reality.
16:22:04 <vincenz> hmm
16:22:40 <dmhouse> I hate it when vincenz says that.
16:23:04 <dmhouse> It means he's about to go into a 30-line rant about the limitations of the typeclass system, which I have no hope of understanding.
16:24:04 <bringert> xerox: hmm, they seem to get ids starting from 1 for me, and when I upload multiple images, they get increasing ids
16:24:15 <int-e> @where yhc
16:24:16 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
16:24:19 <greenrd> I don't use typeclasses at the moment, I just use GADTs and stuff to do the same sorts of things
16:24:30 <xerox> bringert: when you delete the id don't decrease, right?
16:24:36 <bringert> right
16:24:42 <xerox> Sigh!
16:24:44 <greenrd> No head-scratching over instance inference that way, because there is no instance inference
16:25:10 <vincenz> dmhouse: lol
16:25:27 <vincenz> dmhouse: nah was just hmmming purposelessly
16:25:52 --- mode: ChanServ set +o vincenz
16:26:10 <xerox> bringert: Maybe it would be better to have some other means through which refer the images.
16:26:13 <bringert> xerox: silly me, why did I do it so that nextId is the last ID? 
16:26:32 <bringert> xerox: yes, it would
16:26:34 <xerox> No idea.
16:26:40 <xerox> Off-by-one error? (:
16:27:21 <bringert> OTOH, you can just bring up the image index page in a different browser window, and hover the mouse over a thumbnail to see the ID in the status bar
16:27:37 <bringert> I need lunch
16:27:47 <bringert> hmm, it's 16:27
16:27:53 <vincenz> xerox: how hard is it to dynamically generate gui?
16:28:33 <vincenz> more concretely... assume I have some box that I want to replicate a few times verticallly, and that I want to be able to change the number @ runtime
16:28:39 <xerox> vincenz - What do you want to dynamicize?
16:29:01 <xerox> bringert - Yes, but well... by the way, good meal :)
16:29:36 <xerox> vincenz - That is possible.
16:30:23 <xerox> vincenz - You simply use the right values of packing or whatever is called (look it up via Glade), and you createWidget and pack it at runtime... I think in principle it would work.
16:30:31 <vincenz> xerox: the difficulty lies that I would have somethng as follows verticall [X, A ,A ,A ,A ,Y]
16:33:26 <xerox> vincenz - What does it mean?
16:34:44 <vincenz> xerox: I would repliciate a certain amount of A's at runtime
16:35:03 <vincenz> xerox: secondly, would it be possible to use glade to design [X,A,Y] then cut out the A and paste it the required amount of times?
16:35:20 <vincenz> @runtime
16:35:20 <lambdabot> uptime: 9 hours, 1 minute and 5 seconds
16:37:58 <xerox> vincenz - If I remember correctly it is indeed possible.
16:38:49 <vincenz> any knowledge on how
16:38:50 <vincenz> ?
16:39:56 <xerox> HMM.
16:40:11 <xerox> You first pack objects, then you do a showAll or something.
16:40:40 <xerox> That makes objects' destruction or creation more difficult.
16:40:47 <xerox> (aha same length.)
16:41:12 <xerox> You can't use a ListBox or something, can you?
16:41:15 <vincenz> wanna see a cool piece of gui code?
16:41:26 <xerox> Go!
16:41:39 <vincenz> http://rafb.net/paste/results/DjlC7I19.html
16:42:08 <vincenz> notice the similarity with 
16:42:09 <vincenz> http://rafb.net/paste/results/caJG9e18.html
16:42:40 <xerox> Right.
16:42:57 <vincenz> ;)
16:43:06 <xerox> By the way I am not sure you can pack object simply at points later in time than the showAll...
16:43:12 <vincenz> damn
16:43:19 <xerox> You should ask GTK people on that.
16:43:24 <vincenz> anyways...the openDialogBox should be interesting to you
16:43:26 <xerox> Maybe there _is_ a show function for those.
16:43:46 <vincenz> http://rafb.net/paste/results/GI8ekF69.html
16:45:12 <xerox> shapr - In your last pic it seems like your right arm is detached from the rest of the body through the elbow :)
16:46:39 <xerox> Good luck with your GUI vincenz.
16:46:44 <xerox> 'night.
16:47:40 <vincenz> notte
16:48:25 <franka> 'night
17:26:12 <RyanT5000> i want to call glSwapBuffers asynchronously, but I don't want to start drawing again until it exits; what's the proper way to do this with Control.Concurrent?
17:26:14 <RyanT5000> MVars?
17:26:27 <RyanT5000> i don't see semaphores or any of the "traditional" datastructures listed by name
17:27:56 <int-e> have a look at MVars
17:28:03 <RyanT5000> k
17:28:08 <RyanT5000> they're looking appropriate
17:29:16 <RyanT5000> am i correct in my understanding that using an MVar Int with modifyMVar (return . (+1)) and modifyMVar (return . (-1)) would be analogous to using a semaphore?
17:31:38 <int-e> not quite, because there's nothing that prevents the counter from going below 0. think of it as a mutex with a queue of waiting threads - takeMVar takes a lock, putMVar wakes up the next waiting thread and passes a token (which may or may not contain additional information)
17:31:51 <RyanT5000> alright
17:31:58 <RyanT5000> yeah i'm using an MVar ()
17:34:16 * int-e ponders building a semaphore on top of MVars.
17:41:25 <mathewm> anyone have pointers on how to model communicating systems in Haskell; specifically where each system has state that changes as messages are received?
17:44:53 <mathewm> "macs never crash" - yeah, right... :(
17:44:58 <RyanT5000> lol
17:45:22 <triplah> haha
17:45:28 <triplah> i have a usb flash stick
17:45:41 <triplah> that will garantee's crash anyhting running 10.4 :P
17:45:50 <triplah> guarantee'd
17:45:55 <mathewm> I'll take your word for it ;)
17:46:03 <triplah> :P
17:46:51 <triplah> probably dodgy implementation of UMS on the part of the hardware manufacturer
17:47:23 <mathewm> did anyone have any input on modeling communicating systems in haskell ( I froze right after asking ... )
17:48:11 <int-e> RyanT5000: http://pastebin.com/714125 should do it (build a semaphore from MVars) I believe.
17:56:25 <int-e> (hmm. if you fix the misplaced parentheses)
17:58:35 <RyanT5000> hm, looks about right
17:58:45 <RyanT5000> i only needed a mutex though :P
18:00:09 <int-e> yep. MVar () is your friend then. and withMVar gives you a bracket-style critical section.
18:01:30 <int-e> (modifyMVar will do it if you don't need the exception safety)
18:02:22 <RyanT5000> yeah, although i actually need withTryTakeMVar
18:03:04 <RyanT5000> (i only want to try to update the screen if it's not currently waiting for vsync)
18:03:34 <RyanT5000> also, the update function (which is wrapped in the withTry) is what spawns the thread that calls the buffer swap function
18:04:15 <RyanT5000> huh maybe that's the wrong way to do it
18:04:31 <RyanT5000> i should probably just have the containing function take the value and the spawned thread return it
18:09:44 <RyanT5000> how come GHCi links like 20 times as fast as GHC?
18:09:56 <RyanT5000> is it just because it already has the 10 or so packages loaded?
18:11:13 <Philippa> bytecode is much easier to link, you don't need to do a search-and-replace in the actual code
18:12:24 <SamB> also, GHCi insists on having the binary packages linked into a single .o file, doesn't it?
18:12:34 <SamB> (single .o for each package, that is)
18:13:14 <SamB> so the linker doesn't have to deal with (as many) hundreds of .o files 
18:14:06 <RyanT5000> ah
18:14:13 <RyanT5000> i didn't realize it was bytecode-based
18:14:18 <RyanT5000> or the other thing, for that matter
18:14:33 <SamB> the restriction might have been relaxed a bit
18:14:42 <RyanT5000> i think it's an option now
18:14:46 <RyanT5000> i seem to remember seeing something in cabal about that
18:15:28 <SamB> which is okay now that people are used to GHCi liking .o files rather than .a files
18:16:48 <SamB> now, if anything is slower than *linking* with those .a files, it must be making them ;-)
18:21:01 <RyanT5000> i'm having this weird problem where linking hangs the first time and succeeds on the second try
18:21:20 <RyanT5000> i'll write that off as "yet another 'that's what you get for working on windows' issue"
18:22:08 <SamB> huh
18:22:14 <SamB> even on windows, that sounds a bit crazy
18:23:02 <SamB> and its not like we hate windows users, we just don't have enough of them who can hack GHC
18:23:20 <RyanT5000> oh i'm not complaining, although i know i phrased it that way
18:23:36 <RyanT5000> (sorry, i'm sick - i'm scared to think of what quality of code i'm producing now)
18:23:53 <RyanT5000> (also it's my first time with haskell multithreading...)
18:25:05 <RyanT5000> unfortunately i don't have the time to hack on OSS stuff right now - i go to law school in 2 months, which means that's the dropdead date for whatever big programming projects i want to finish (potentially "forever")
18:26:02 <thetallguy> You should rewrite the  law in Haskell.
18:26:04 <thetallguy> ;-)
18:26:13 <RyanT5000> lol i wish
18:26:23 <RyanT5000> it wouldn't be any harder for n ormal people to understand either
18:26:38 <thetallguy> Just the tax law, then.
18:26:41 <RyanT5000> lol
18:26:56 <RyanT5000> well i'm hoping to do some p2p stuff, actually
18:26:58 <SamB> RyanT5000: I bet it would be easier
18:27:06 <RyanT5000> lol probably true SamB
18:27:16 <SamB> especially with the type system to tell you what kinds of effects different laws could have
18:27:35 * jer thinks there'd still be plenty of people whose heads pop reading it in either version =]
18:27:46 <RyanT5000> i want to get together a group of law students and a group of CS students and throw together a p2p network
18:28:23 <RyanT5000> with the idea of making it robust both technically and legally
18:28:38 <RyanT5000> kind of how Kazaa was, except we don't have to hide like that since we won't be making a profit etc.
18:28:40 <SamB> hmm, fascinating
18:28:53 <RyanT5000> i think i'm insane, though: i'd love to get sued by the RIAA for something like that
18:28:58 <RyanT5000> get to the supreme court
18:29:50 <RyanT5000> also, hopefully do something with DRM
18:29:52 <RyanT5000> not sure what though
18:30:08 <RyanT5000> it's unfortunate that i'm not on the side of the RIAA/MPAA arguments with the money
18:30:21 <RyanT5000> the only way i get paid is if i convince the electronics industry to back me
18:30:37 <RyanT5000> which is risky for them, since i'll probably be purposely breaking laws like the DMCA
18:30:56 <RyanT5000> or at best being ambiguous
18:31:01 <jer> RyanT5000, get licenced in another country w/o such a silly copyright act like... Canada, or Sweeden or something
18:31:42 <RyanT5000> yeah, that's an idea i'll think about, but part of the point is to engage in civil disobedience at home
18:32:36 <RyanT5000> what i really need is connections: with enough high-powered attorneys and law professors behind it, the RIAA will think twice about suing us
18:33:10 <RyanT5000> though i'm not sure whether it'll help anything if they don't sue us
18:33:26 <RyanT5000> (i don't know if you can set legal precedents in other ways - that's why i'm going to go to school :P)
18:33:59 <RyanT5000> anyway i'll definitely hit up this channel when i'm looking for people for that
18:34:36 <RyanT5000> so people who never intend to enter the US, or who are willing to take that kind of risk, will be welcome to join :)
18:39:49 <RyanT5000> what's the deal with MVar garbage collection?
18:40:04 <RyanT5000> i don't need to worry about it, right?
18:40:17 <RyanT5000> once the containing closure is gone, the MVar is too, right?
18:40:43 <skew> mvars are garbage collected, if that's what you are asking
18:41:03 <RyanT5000> i think it is
18:41:12 <skew> I think threads blocked on garbage mvars are also garbage collected
18:41:14 <RyanT5000> i have to admit my understanding of GC in haskell is basically 0
18:41:26 <RyanT5000> wait, how can you be blocked on a garbage mvar?
18:41:33 <RyanT5000> isn't each thread its own GC root?
18:41:46 <skew> no, I'm pretty sure the list of runnable threads is the GC root
18:42:06 <RyanT5000> huh
18:42:14 <skew> if a thread is blocked on an empty mvar, and nobody else references that mvar, it's all garbage
18:42:24 <int-e> makes sense.
18:42:35 <RyanT5000> true
18:44:11 <RyanT5000> so far my productivity reimplementing my game client in haskell is about 30x
18:44:24 <RyanT5000> not sure how much of that is that it's my second try and how much of it is haskell
18:44:55 <RyanT5000> however i have about 8 years of C++ experience and about 4 months of haskell
18:45:08 <skew> only 4?
18:45:35 <RyanT5000> yeah, roughly
18:45:35 <skew> I thought you were in here longer ago than that
18:45:45 <RyanT5000> i don't think so; i think february this year
18:45:47 <RyanT5000> i'll check
18:45:52 <RyanT5000> i got into this chatroom like 3 days in
18:47:35 <RyanT5000> april 5
18:47:42 <RyanT5000> RyanT5000:     I'm new to haskell and i'm trying to write some simple 3D stuff in it; lots of sites seem to point to http://www.scannedinavian.org/~lemmih/SDL/ for SDL, but the host doesn't seem to exist.  Could anyone suggest what graphics/audio library to use? (i don't particularly care whether it's an SDL binding or something else)
18:49:40 <int-e> % Random[]
18:55:42 <skew> CINNI reminds me of Daan's record system with scoped labels
19:14:29 <skew> \quit
19:20:52 <petekaz> Anyone here use clean?  How does it compare to haskell?
19:24:41 <RyanT5000> i think it has way less support, due to not being open source (or having some weird licensing issue), but i haven't used it
19:28:26 <petekaz> It looks impressive.
19:29:06 <RyanT5000> is there a way to change the priority of a GHC thread?
19:29:07 <petekaz> Just reading about Brian Hulley's claim on the mailing list that lazyiness is more of a burden than a blessing.
19:29:24 <RyanT5000> how so?
19:29:31 <RyanT5000> laziness is very expressive
19:29:42 <RyanT5000> [1..] is extremely concise
19:30:03 <RyanT5000> and if you care about performance, (at least in haskell) just figure out which things shouldn't be lazy
19:30:17 <petekaz> He claims that more times than not, he fights laziness and wants strictness, and also claims laziness results in slower programs.
19:30:43 <RyanT5000> maybe that has to do with his style?
19:30:56 <RyanT5000> and what about parallelization?
19:30:58 <petekaz> I think his point was basically, the language would be much better if it were by default strict, with the option to do laziness.
19:31:05 <RyanT5000> hm
19:31:09 <RyanT5000> well i can't really comment on that
19:31:20 <petekaz> And I started wondering if others felt the same?
19:31:26 <petekaz> (I'm a newbie)
19:31:44 <RyanT5000> i'm a newb too, so we should wait for someone else to join the discussion, lol
19:31:55 <petekaz> And then Bulat Ziganshin suggested Clean.
19:32:25 <petekaz> And now here I am asking about this line of reasoning.
19:32:43 <petekaz> Not many people here though it seems.
19:38:31 <Dino_> I've only just started (about a month ago) with H myself, and it's the first time I've ever touched a functional language.
19:39:16 <tato> are there any good tutorials on creating C bindings?
19:42:17 <RyanT5000> i found just looking at source was pretty sufficient
19:42:30 <RyanT5000> it's fairly simple
19:42:49 <tato> of.. ghc?
19:43:03 <RyanT5000> no
19:43:10 <RyanT5000> of some library binding that someone else wrote
19:43:19 <RyanT5000> in my case, the SDL binding
19:43:24 <RyanT5000> @where SDL
19:43:25 <lambdabot> I know nothing about sdl.
19:43:30 <RyanT5000> @where hssdl
19:43:30 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
19:43:33 <RyanT5000> there we go
19:43:56 <tato> hmmm thats so crazy it might work, i'll take a swing at it :-)
19:44:42 <RyanT5000> k, lemme know if you have any questions
19:44:47 <tato> (i love it how all haskell projects uses darcs)
19:45:19 <RyanT5000> yah
19:45:30 <RyanT5000> gah, that reminds me
19:45:37 <RyanT5000> i need to get my project under darcs ...
19:45:58 <RyanT5000> i really really don't want to though - i've never used it before so it'll take me awhile probably
19:46:07 <petekaz> I'm still having a hard time getting used to darcs to be honest.
19:46:38 <petekaz> I'm so used to cvs/svn command line.  It's really the darcs command line that is a total pita for me.
19:48:29 <petekaz> Say I just download 4 patches, is there a quick way to see the diffs?  The command line is so hefty, I find myself using darcsweb for everything, but I'm a unix guy so I'd prefer a good cli anyday.
19:49:13 <Dino_> Yeah. Honestly, I was surprised that the commands don't have short versions with darcs.
19:53:18 <Dino_> As far as diffs goes, I haven't used it much yet, don't know.
19:57:08 <RyanT5000> MVars work with forkOS too, right?
20:04:28 <jer> petekaz, yeah; darcs diff --from-patch="pattern of previous patch" --to-patch="name of 'new' patch" from within your repo dir
20:05:21 <kfish> petekaz, darcs diff --last=4
20:05:39 <petekaz> kfish: ahh ... that's what I was looking for!
20:06:11 <petekaz> jer: the problem with that version of the command, is I have to do 'darcs changes' first and try to remember both names of the patches for the next command.
20:06:13 <tato> why wasn't the state monad included in the haskell 98 report?
20:06:45 <dfeuer> What's forkOS?
20:06:45 <Dino_> > Text.Regex.matchRegex (Text.Regex.mkRegex "(a+)(b+)") "aabbb"
20:06:46 <lambdabot>  Not in scope: `Text.Regex.mkRegex'
20:06:53 <dfeuer> tato, the Haskell 98 report was lame.
20:07:01 <RyanT5000> forkOS makes an OS thread rather than a GHCi thread
20:07:03 <RyanT5000> er, GHC thread
20:07:08 <tato> dfeuer: oh, it was??
20:07:19 <jer> petekaz, well, you can use darcs diff --last=n where n is the number of patches back you want to go (if you just want to diff against the head)
20:07:28 <tato> how so?
20:07:36 <dfeuer> tato, you started it.
20:07:48 <jer> petekaz, of course, i suppose that may still require you to look at your inventory
20:08:15 <Dino_> Having a problem with trying to bind (a:b) to something that returns Maybe [String]
20:08:24 <petekaz> jer: true.  still just trying to adjust to darcs, the cli is rough around the edges in my opinion.
20:09:17 <tato> besides state monads, how does it fall short?
20:09:24 <tato> (i'm a noob btw)
20:13:03 <Dino_> Is it just that you can't, I wonder. Like: (a:b) = foo   Where foo :: Maybe [String]
20:14:21 <tato> you're trying to split the [String] in Maybe to a head and tail?
20:14:31 <Dino_> tato: yes
20:14:52 <Dino_> And I acknowledge the compiler's fear about wtf to do when it's Nothing.
20:14:54 <Dino_> I just don't know what to do about it.
20:15:56 <tato> i think you have to do something like "case foo of, Nothing -> bla, Just (h:t) -> something"
20:16:53 <Dino_> Hm. But it's the result of foo that I want in the (h:t).
20:17:36 <tato> yea, when foo isn't nothing, it gets pattern matched to Just (h:t)
20:17:57 <Dino_> Right that what do I put there for 'something' above.
20:18:06 <Dino_> s/that/but/
20:18:26 <tato> an expression which involved h and t
20:25:47 <Dino_> Hm. This seems to work..
20:25:55 <Dino_> > let (h:t) = case foo of { Just x -> x ; Nothing -> ["bad"] } ; foo = Just ["xx","yy"] in h
20:25:56 <lambdabot>  "xx"
20:26:01 <Dino_> > let (h:t) = case foo of { Just x -> x ; Nothing -> ["bad"] } ; foo = Just ["xx","yy"] in t
20:26:02 <lambdabot>  ["yy"]
20:27:39 <Dino_> > let (h:t:[]) = case foo of { Just x -> x ; Nothing -> ["bad"] } ; foo = Just ["xx","yy"] in t
20:27:40 <lambdabot>  "yy"
20:29:22 <Dino_> > let (h:t:_) = case foo of { Just x -> x ; Nothing -> ["bad"] } ; foo = Just ["xx","yy"] in [h,t]
20:29:23 <lambdabot>  ["xx","yy"]
20:30:17 <Dino_> Is that an ok way to do this? Bearing in mind that probably something constructive should be done when this comes up Nothing, that I'm ignoring for now.
20:32:53 <tato> I shouldn't be using Data.Array.IArray directly, correct?
20:35:15 <Dino_> Not sure. Doesn't seem to say not to use it in the docs.
20:36:43 <tato> when I do import Data.Array.IArray; a = array (1,10) [(i,i*2) | i <- [1..10]]; hugs gives me an Unresolved top-level overloading error
20:38:01 <SamB> you have to specify the type of the array *or* at least specify an explicitly polymorphic type
20:38:01 <SamB> stupid monomorphism restriction
20:39:03 <tato> oohoh so a:: Array Int Int or something
20:39:53 <tato> is it because hugs interprets the integers as Num a => a instead of Int?
20:41:15 <SamB> nah, not the integers
20:41:15 <SamB> its the Array type constructor
20:41:26 <SamB> @type Data.Array.IArray.array
20:41:27 <lambdabot> forall e i (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (i, i) -> [(i, e)] -> a i e
20:41:51 <SamB> @type Data.Array.IArray.array (1,10) [(i,i*2) | i <- [1..10]]
20:41:52 <lambdabot> forall a (a1 :: * -> * -> *). (Ix a, Data.Array.Base.IArray a1 a, Enum a, Num a) => a1 a a
20:44:16 <tato> hmm so the problem is it can't deduce the exact type of a
20:44:41 <mlh_> df
20:46:30 <SamB> tato: actually, it is most likely a1 that it was complaining about
21:04:59 <tato> oohh because (IArray a1 a) is a class, and there are many instances of this class
21:05:23 <tato> so it can't tell what array type to use internally
22:48:29 * Cale just got back from the Zappa Plays Zappa concert.
22:49:00 <Cale> It was absolutely incredible -- they have some astounding musical talent there.
23:01:09 <mq_mattr> hi 
23:01:18 <mq_mattr> I am trying to play with gtk2hs
23:01:29 <mq_mattr> but I can't work out the pacakge name I need
23:01:56 <lorne> I think it's Graphics.UI.Gtk
23:02:05 <mq_mattr> aha!
23:02:08 <mq_mattr> I found it
23:02:13 <mq_mattr> it is gtk as I expected
23:02:18 <mq_mattr> lorne: taht is the lib I need
23:02:30 <mq_mattr> now I have to work out why my sytem can't find it
23:05:45 <mq_mattr> ok, i have it, but it is not where ghc is looking for packages
23:05:57 <mq_mattr> how can I add a path to where ghc looks for packages?
23:25:45 <mq_mattr> hey peeps
23:25:57 <mq_mattr> does anyone have any experience getting gtk2hs to work on os x
23:25:59 <mq_mattr> ?
23:26:12 <mq_mattr> without x11.app
23:28:25 <mq_mattr> nope?  OK then
