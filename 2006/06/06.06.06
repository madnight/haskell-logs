00:00:47 <dons> the greatest biscuit on the planet :)
00:02:00 <cpatrick> dons: pfft. They're overrated.
00:02:57 <dons> hehe.
00:17:14 <_Stinger_> mmm dark chocolate
00:19:16 <dons> @see sjanssen 
00:19:17 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
00:22:04 <scodil> so, if i've got a recursive data type like "data DList a = Node a DList", and its circular so I don't need a Nil element, and I can define a list of constant size like this "let n0 = Node a n1; n1 = Node b n2; ... n25 = Node z n0 in n0", how would I go about creating a new list which is spliced from two existing lists?
00:57:12 <dblhelix> scodil: you mean data ... = ... (DList a), right?
00:59:02 <dblhelix> scodil: can you give an example of what you're trying to achieve?
01:00:01 <Cale> scodil: the problem with that sort of thing is that it's kind of difficult to actually use because it's impossible to tell when you've traversed the whole list once you're done, unless you keep the lengths around
01:05:17 <scodil> yeah after i asked that question i found a bunch of stuff on the web. its not as easy as i thought it would be
01:05:32 <kzm> @remember ADEpt "Modern" means that it is written in Haskell.
01:05:33 <lambdabot> Unknown command, try @list
01:05:50 <kzm> Hm?
01:05:55 <kzm> @help quote
01:05:56 <lambdabot> quote <nick>
01:05:56 <lambdabot> remember <nick> <quote>
01:05:56 <lambdabot> Quote somebody, a random person, or save a memorable quote
01:06:10 * kzm scratches his head.
01:06:19 <dons> there's a bug in @remember, i disabled it till its fixed
01:06:25 <dons> but i haven't fixed it yet.
01:06:59 <Stinger_> a = fix remember 
01:07:23 <Cale> yeah, it's a shame that it seems you really need mutable references to work with doubly linked lists in any but the simplest cases
01:08:35 <Stinger_> you could use a state monad to -no thats just silly :P
01:08:41 <scodil> it kind of makes sense. if you splice in a new node then you've created an entirely new list, so without some kind of state change you'd have to copy the whole thing
01:08:55 <Cale> right
01:09:15 <Cale> unless you could just store differences in some way
01:09:40 <Cale> You can get mutable references in the ST monad (not State), but most people will usually opt to use another datastructure.
01:10:03 <scodil> what kind of other data structure?
01:10:42 <Cale> depends on the application, we have efficient Queues
01:11:26 <Cale> i.e. O(1) in the worst case for en/dequeuing
01:11:49 <scodil> yeah, this thing i'm trying to do is really just a data structure and nothing else. there's no abstract interface to it. it is what it is : http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html
01:13:30 <Cale> it's also reasonable, though not entirely pretty, to use an Array
01:13:48 <Cale> References just become array indices
01:13:54 <scodil> right
01:14:04 <Cale> Usually if you do that, you really want a nicer interface put on top though :)
01:14:38 <dons> hmm "Moderate amounts of the coffee stimulant can increase people's willingness to be persuaded"
01:14:48 <Cale> yeah
01:14:50 <scodil> when you say References with a capital R, are you refering to some kind of type? I've seen "reference cell" thrown about, but I haven't seen it defined anywhere
01:15:02 <dons> "scientists found that after consuming caffeine, volunteers were more likely to agree
01:15:04 <Cale> scodil: no, just the usual pointers
01:15:05 <dons> with persuasive arguments."
01:15:08 <scodil> is it anything like in ML?
01:15:09 <scodil> oh ok
01:15:09 <Cale> scodil: though there are STRefs
01:15:23 <scodil> yeah thats what i figured.. it was some kind of monad
01:15:52 <Cale> STRefs only work in the ST monad, and have a pretty simple interface, at the cost of making things a bit more imperative.
01:16:14 <scodil> thats fine. I only need one imperitive function: splice
01:16:14 <Cale> dons: yeah, that seems to have something to do with being more alert
01:16:34 <Cale> dons: because they actually take in the points in the argument better than someone who is tired.
01:16:48 <dons> Cale: yeah, seems so. it only works when you're forced to focus and assimilate the opposing argument
01:16:59 <scodil> so, where would I find out more about these STRefs? the documentation is rather terse. somethign with examples, maybe
01:17:01 <dons> if you don't pay attention, you don't change your mind
01:17:33 <Cale> scodil: Well, the documentation is most of all there is to it... are you familiar with how IO works already?
01:17:42 <dons> so, let's send a few boxes of coffee over to the python guys, with some literature on static typing...
01:17:46 <Cale> hehehe
01:18:11 <scodil> well, "how it works" is subjective. I can use it :) but i don't _understand_ it
01:18:16 <Cale> okay
01:18:21 <Cale> well, that's basically good enough
01:18:26 <Cale> ST is similar
01:18:27 <tennin> well, I'm much more receptive to persuasion by my internal half-bakery while stimulated with caffeine
01:18:33 <Cale> though you don't have access to IO
01:18:41 <dons> tennin: ah, indeed. i find that too.
01:18:55 <Cale> the only things you really have access to are the three functions in Data.STRef for manipulating STRefs
01:19:00 <dons> dons: "let's rewrite ghc's native code gen". dons: "yeah, great idea, dons!"
01:19:17 <Cale> you construct an action in ST, making sure that it doesn't return any STRefs directly
01:19:26 <Cale> and then apply runST to it
01:19:30 <Cale> and you get a pure function
01:20:08 <Cale> the fact that you don't return any STRefs will be enforced by the compiler at the point where you apply runST
01:20:32 <Cale> you can return STRefs, you just can't runST yet if you do.
01:21:14 <Cale> the primitives are:
01:21:24 <Cale> newSTRef :: a -> ST s (STRef s a)
01:21:38 <Cale> which creates a new STRef with a given initial value
01:21:51 <Cale> readSTRef :: STRef s a -> ST s a
01:22:07 <Cale> which, obviously, gives the action for reading the STRef
01:22:28 <Cale> and  writeSTRef :: STRef s a -> a -> ST s ()
01:22:34 <Cale> which updates the value of the cell
01:22:51 <Cale> there's also modifySTRef :: STRef s a -> (a -> a) -> ST s ()
01:23:28 <Cale> which is just  modifySTRef r f = do v <- readSTRef r; writeSTRef r (f v)
01:25:33 <Cale> dons: are you going to do that?
01:25:51 <dons> nah, just the kind of crazy idea i could convince myself to do on enough coffee
01:26:08 <dcoutts> @yarr!
01:26:08 <lambdabot> Get out of me way, yeh landlubber
01:26:09 <dons> after i crash though...
01:27:09 <scodil> Cale: ok, so, on a higher level, i would have maybe an STRef which refers to a list of things (these things are maybe circular linked lists). And if I want to splice two lists together, I write a function of STRef [things] which grabs two things, splices them, and pushes them back on the list, using readSTRef and writeSTRef, resp.
01:27:15 <scodil> sound right?
01:27:31 <mq_mattr> hello
01:27:49 <mq_mattr> can anyone help me with a typing problem?
01:27:53 <mq_mattr> its a simple one
01:28:13 <Cale> sure
01:28:37 <mq_mattr> I want to say "data Foo a = a -> String"
01:28:40 <mq_mattr> but I can't
01:28:46 <Cale> scodil: most likely, you'd have data structures containing STRefs
01:28:57 <Cale> scodil: you'd use them just like pointers
01:28:58 <mq_mattr> explain
01:29:15 <Cale> mq_mattr: you need a data constructor
01:29:28 <kzm> @seen JaffaCake
01:29:29 <lambdabot> I saw JaffaCake leaving #haskell 3 days, 2 hours, 32 minutes and 41 seconds ago, and .
01:29:31 <Cale> mq_mattr: if all you want is a synonym, you can do  type Foo a = a -> String
01:29:48 <kzm> Any other GHC hackers here?  I get:  undefined reference to `stgMallocBytesRWX'
01:29:51 <scodil> Cale: thats fine. are there any effeciency implications there? these STRefs are compiler constructs, right? Do they exist at all in the executed code?
01:30:04 <kzm> compiling GHC 6.5 from a tarball, I should add.
01:30:05 <Cale> mq_mattr: if you want a new type though, you'll have to write  data Foo a = MakeFoo (a -> String)
01:30:24 <mq_mattr> hey, it worked this time
01:30:31 <mq_mattr> excuse my stupidity
01:30:49 <mq_mattr> yeah, I had tried that (left it out of post though)
01:30:51 <Cale> scodil: they exist in the compiled code, I'm actually not 100% sure how they exist, but the operations on them are certainly O(1), and they take O(1) space
01:31:01 <mq_mattr> but I thought I was getting an error, but now it is gone
01:31:06 <mq_mattr> lets see what I did wrong
01:31:07 <Cale> scodil: Most likely, they're just pointers
01:31:08 <mq_mattr> thanks
01:31:09 <scodil> Cale: ok. just curious.
01:31:26 <Cale> mq_mattr: no prolem
01:31:28 <Cale> b*
01:32:58 <Cale> scodil: The neat thing here is the type of runST :: (forall s. ST s a) -> a
01:33:40 <Cale> that is, it must be passed an ST computation which is polymorphic in the s parameter, and a cannot depend on s.
01:34:28 <Cale> This effectively prevents references from escaping into pure code, where they would otherwise destroy referential transparency.
01:36:10 <scodil> i don't follow. if the data structure is composed of references (ie, its a linked list made with pointers) how can you use it in "pure" code? or can you not?
01:36:40 <Cale> If it's composed of STRefs, you'll only be able to really do anything with it from ST.
01:36:56 <dcoutts> dons, so how did the talk go?
01:37:08 <Cale> (though you could pass it to pure code from inside ST)
01:37:50 <Cale> (you just couldn't manipulate it very well)
01:38:12 <Cale> You could write a function which turns the structure into an ordinary Haskell value
01:38:19 <Cale> (devoid of STRefs)
01:38:30 <flux__> such a function could work lazily, right?
01:38:36 <scodil> http://www.cse.ogi.edu/PacSoft/projects/rmb/doubly.html <--- this page shows a data structure (linked list) that has IORefs as the "payload" of the data structure, but the structure itself is just a recursively defined type. Is this different from what you're talking about? Would I need to build my list/graph/whathaveyou out of STRefs?
01:38:38 <flux__> outsite the ST monad?
01:38:42 <flux__> s/te/de/
01:38:58 <Cale> flux__: well, it would be in the ST monad, but it could be lazy with Lazy ST.
01:40:11 <Cale> scodil: Those have the same problem as the other linked lists, only slightly less, since you'll be able to mutate the elements from IO
01:40:28 <scodil> but the list topology is fixed?
01:40:33 <Cale> scodil: yeak
01:40:36 <scodil> ok
01:40:37 <Cale> h*
01:42:11 <Cale> It seems plausible to me that you should be able to create an STDList type which would have mutable structure in ST, together with an ST computation which converted to DList.
01:42:42 <Cale> (in O(n) time, of course, or with Lazy ST, O(k) where k is the number of cells you care about)
01:43:04 <scodil> that sounds reasonable
01:43:07 <Cale> I'll try
01:44:49 <scodil> so if i had a pure function, something take or map, and I wanted to use it on my graph'o'STRefs, I'd do something like take n convert(graph) ... where convert is this lazy function that converts an STRef graph into a pure graph
01:44:59 <scodil> pure graph as in, a recursively defined type
01:45:02 <Cale> yeah
01:45:59 <alar> Can someone give me an overview of haskell tools for UI building? libraries with haskell frontend, ported toolkits, etc.
01:46:37 <alar> I know there are HToolkit, GLUT and wxHaskell
01:46:45 <Cale> alar: There's Gtk2Hs which is rather nice. It's especially nice with Glade.
01:46:48 <alar> but I don't know what offers what
01:47:08 * alar starts googling for Gtk2Hs
01:47:17 <dcoutts> @where gtk2hs
01:47:17 <lambdabot> http://haskell.org/gtk2hs/
01:47:21 <scodil> Cale: so does the graph consist of STRefs or Lazy STRefs? Again, i'm not totally following when you say "in" the monad. Is the graph "in" the monad in the same way as the lazy traversal/conversion function?
01:47:34 <Cale> data STDList s a =
01:47:34 <Cale>     STDNode { stdlLeft  :: (STRef s (STDList s a)),
01:47:34 <Cale>               stdlValue :: STRef s a,
01:47:34 <Cale>               stdlRight :: (STRef s (STDList s a)) }
01:47:45 <Cale> something like that
01:48:08 <Cale> that will have mutable pointers and values
01:48:14 <scodil> ok so what does a lazy next function look like? 
01:48:20 <scodil> just something that graphs stdlRight
01:48:26 <scodil> graphs->grabs
01:48:35 <Cale> yeah, I think so
01:49:08 <Cale> STRefs are comparable for equality too, so we'll be able to tell when we've come around.
01:49:21 <Cale> I'll take a shot at it
01:51:25 <Cale> the mdo in the url you gave before should make things a little prettier, I think
01:52:25 <scodil> so, something like     next STDNode l x r = let ( _ y _ ) = r in y
01:52:30 <scodil> thats not right, but
01:52:34 <scodil> you see what i'm getting at
01:52:49 <Cale> what's next?
01:53:01 <scodil> given a node, grab the contents of the node to the right of it
01:53:05 <Cale> oh
01:53:06 <Cale> okay
01:54:02 <Cale> next d = do r <- stdlRight d; readSTRef (stdlValue r)
01:54:32 <scodil> ah
01:55:18 <scodil> ok, so this Lazy thing, is this an explicit type? or do you make an ST lazy using these functions stringToLazyST and lazyToStrictST?
01:55:45 <Cale> you just import Control.Monad.ST.Lazy
01:55:50 <scodil> oh
01:55:53 <scodil> instead of the other one
01:55:57 <Cale> right
01:56:39 <scodil> ok thats good. i was thinking that it was an explicit thing. like how you can make values strict. whats that operator again?
01:56:42 <scodil> to make something strict
01:56:47 <Cale> seq
01:56:49 <Cale> or $!
01:56:50 <Stinger_> !
01:56:54 <scodil> yeah !
01:57:04 <Cale> or in the case of data declarations !, yeah
01:58:28 <alar> is Cairo library a pert of GTK?
01:58:35 <scodil> what was that, in the statement "r <- stdlRight d;"  is that just accessing a named field?
01:58:36 <alar> sorry for stupid questions
01:58:40 <dcoutts> alar, it's used by Gtk+
01:58:47 <dcoutts> alar, it can also be used seperately
01:58:54 <Cale> alar: no, but the Cairo binding is part of Gtk2Hs
01:59:40 <alar> Cale: so Gtk2Hs can work with 2 backends?
02:00:16 <Cale> well, you just use the Cairo binding directly
02:00:20 <dcoutts> alar, it's not a backend as such
02:01:03 <dcoutts> as Cale says, when doing custom drawing with Gtk2Hs you can either use the old Gdk drawing api or the nice new shiny cairo api
02:01:34 <dcoutts> can you guess which one we reccomend? ;-)
02:03:06 <mq_mattr> is gtk up to speed on windows yet?
02:03:10 <dcoutts> yes
02:03:15 <mq_mattr> I have seen some bad glitches
02:03:21 <mq_mattr> is that because of cairo?
02:03:22 <dcoutts> report them
02:03:32 <dcoutts> not especially, it was fine in 2.6 too
02:03:39 <mq_mattr> It was a while ago, I am not that into it.
02:03:50 <mq_mattr> Just have been avoiding it since then
02:03:51 <alar> gtk on windows looks rather clumsy ( I had not use it, just seen a few screenshots)
02:04:08 <mq_mattr> if it is improved, I will put it back on my list of technologies to consider
02:04:17 <dcoutts> http://haskell.org/gtk2hs/gallery/HRay/HRayScreenShot6
02:04:35 <dcoutts> here's the 'clumsy' win32 version of a gui ^^^
02:05:15 <mq_mattr> how declarative is GTK2hs?
02:05:26 <dcoutts> or comparing the various win32 themes with a linux one:
02:05:27 <dcoutts> http://www.haskell.org/gtk2hs/gallery/HRay
02:05:41 <dcoutts> mq_mattr, not especially, it's a mid-level gui api
02:06:07 <mq_mattr> right, so it is a little better than a thi wrapper over foreign calls, but not much?
02:06:23 <dcoutts> mq_mattr, there are no usable high level declarative gui apis for Haskell yet, there are some experimental ones but nothing big enough to use for real apps
02:06:26 <mq_mattr> still, that is what we need right?
02:06:37 <dcoutts> mq_mattr, no, it's rather more than a thin wrapper
02:06:45 <dcoutts> but it's still imperative
02:07:30 <mq_mattr> last time I used something in that line (hopengl) I found the haskell version far enough from the original that I needed separate documentation, but there was none
02:07:37 <mq_mattr> is this the case with gtk2hs?
02:07:49 <alar> dcoutts: Cairo has not only shiny api but also nicer appearance, right?
02:08:03 <mq_mattr> i hate trying to guess the haskell interface from the c documentation
02:08:13 <dcoutts> mq_mattr, we've got full documentation
02:08:18 <mq_mattr> YAY!
02:08:19 <dcoutts> alar, right
02:08:41 <mq_mattr> many thanks to whoever did that, the doucmentation is dull to create, but so very necessary
02:09:05 <dcoutts> mq_mattr, we generated it from the C docs and then fixed it up manually
02:09:11 <alar> dcoutts: then who needs original GTK api for new development?
02:09:35 <dcoutts> alar, huh?
02:10:30 <alar> mq_mattr: there are some attempts at building functional GUIs (FRAN or something) but they are still in research state
02:10:47 <Cale> scodil: half finished -- I have the mutable side of things done
02:11:13 <dcoutts> alar, we think gtk2hs would be a fine base on which to build a high level declarative api
02:11:26 <alar> dcoutts: when there is Cairo with better look and newer API
02:11:40 <scodil> Cale: wow. i didn't realize you were actually going to write this. thanks.
02:12:14 <Cale> scodil: It's interesting enough an idea, and someone should do it :)
02:14:36 <scodil> Cale: the only thing close I've seen sofar is this: http://haskell.org/hawiki/TyingTheKnot which is not that great to learn from because everybody there is trying to do it "the haskell way" instead just something that works. Plus, I don't think those lists/graphs are structurally mutable
02:14:52 <Cale> right, they're not
02:15:04 <Cale> (but in those applications, it doesn't matter much)
02:15:16 <scodil> er, that came out bad : "the haskell way, instead of just something that works" :)
02:15:47 <scodil> you know what i meant. some things just have to be imperitive
02:16:06 <Cale> yeah -- it sort of is imperative the way that they do it though
02:16:12 <Cale> (anyway)
02:16:34 <scodil> yeah there's the one solution that uses a dictionary, not unlike how you recommended using an array
02:16:35 <Cale> Think of haskell values as pointers and it looks just like the imperative solution
02:16:53 <Cale> (I mean the Tying the Knot trick)
02:17:20 <Cale> The only strangeness is that they're using recursion instead of the loop you're conditioned to see for that sort of thing.
02:17:42 <Cale> (Admittedly, it took me a long time to see that)
02:18:25 <dmhouse> hey, Cale, there was something I wanted to ask you:
02:19:07 <dmhouse> you were explaining how Functors were functors a while back and said they were endofunctors in the category of Haskell types.
02:19:13 <Cale> yeah
02:19:22 <dmhouse> I thought about this, and think we can be more specific than that
02:19:30 <Cale> really?
02:19:44 <dmhouse> for example, [] is a functor between categories Hask (Haskell types) and List (Haskell list types)
02:19:53 <Cale> oh, yes, certainly
02:20:16 <dmhouse> which is less general than saying they're endofunctors in Hask.
02:21:20 <Cale> I suppose the best you could say is that they're endofunctors on the category of Haskell types whose range is a full, faithful subcategory given by the application of a type constructor.
02:21:45 <Cale> hmm, actually, maybe better still
02:21:49 <Cale> just subcategory :)
02:22:11 <dmhouse> hah, okay, I think I need to go learn some more CT terminology then. :)
02:22:34 <Cale> and you can say something about the arrows too, since the only arrows are the ones in the image of fmap
02:22:48 <Cale> So you don't have all list functions
02:22:57 <Cale> for instance
02:23:24 <Cale> you only have those which apply a single function to all the elements
02:23:27 <dmhouse> why not just say Functors are functors bettween Hask and the subcategory given by (an abuse of set-theoretic notation, but I don't know much CT) { f t : t in Hask }?
02:23:41 <Cale> sure
02:23:45 <Cale> but you can say more
02:23:54 <Cale> which arrows does the sucategory have?
02:23:56 <Cale> b*
02:24:10 * Cale has a terrible b key.
02:24:15 <dmhouse> hehe,
02:24:46 <dmhouse> they'd be in the form f a -> f b.
02:25:07 <Cale> there are usually more things in that type than actually occur
02:25:10 * dmhouse remembers when his 'e' key got stuck down once. he had to press it really hard at the beginning of every session, then copy-paste it everywhere
02:25:15 <Cale> they're all of the form fmap f for some function f
02:25:21 <dmhouse> right.
02:25:58 <Cale> and by polymorphism, we know that fmap absolutely must be a natural transformation 1 -> f
02:25:58 <dmhouse> well.
02:26:24 <dmhouse> hmm, okay
02:27:08 <Cale> actually, hehe, but on a yet different category
02:27:19 <Cale> The subcategory consisting of function types. :)
02:28:01 <Cale> see, we can't define fmap to do funny things based on what the function passed actually is
02:28:08 <dmhouse> fmap would be an arrow in that category
02:29:02 <Cale> fmap would be a natural transformation on Func of type 1 -> f
02:29:28 <Cale> but yeah, it's also an arrow in that category
02:29:38 <Cale> because we have a bunch of isomorphisms going on here :)
02:29:57 <Cale> er, hmm
02:30:06 <alar> dcoutts: if low level has callbacks and polling on variables and quirks and stuff - I'm not sure high level can be functional enough]
02:30:40 <dcoutts> alar, why?
02:30:55 <dcoutts> also we can get notified of widget state changes, not just poll
02:31:04 <Cale> yeah
02:31:51 <Cale> dmhouse: It's easy to say simple things in a complicated way with category theory (though the reverse is also true)
02:32:01 <dmhouse> mm. :)
02:32:37 <Cale> Basically, the idea here is that fmap isn't allowed to, for example, look at the structure of the function it's passed, or the elements of the list.
02:33:00 <alar> dcoutts: I beleive good UI should be totally reactive ( at least at lowest level) and not every mid-level code can present this functionality to high level unharmed
02:33:08 <Cale> Even if there is some way to do so consistently for all types which would otherwise give a functor.
02:33:47 <Cale> Polymorphism and the fact that functions are not entirely observable in Haskell places some additional restrictions on fmap which should be possible to express in CT.
02:34:05 <Cale> (above and beyond the ordinary restrictions for a functor)
02:34:33 <dcoutts> alar, as I said, we can get notified of all GObject property changes
02:34:39 <roconnor> > k `choose` i
02:34:40 <lambdabot>  Not in scope: `i'
02:34:48 <roconnor> > 4 `choose` 3
02:34:49 <lambdabot>  Not in scope: `choose'
02:35:10 <roconnor> @hoogle choose
02:35:11 <lambdabot> Test.QuickCheck.choose :: Random a => (a, a) -> Gen a
02:36:15 <Cale> In topology, you have things like the functor pi_1: Top* -> Group, taking pointed topological spaces to groups, and continuous functions to group morphisms. In order to do that, it actually has to do observe the behaviour of those functions in a way which would be impossible in Haskell.
02:37:00 <alar> dcoutts: I know nothing about GTK atm , so I'm not sure whether this notification is enough
02:37:15 <dmhouse> roconnor:
02:37:31 <Cale> (even for more discrete things)
02:38:03 <dmhouse> > let fac n = product [1..n]; n `choose` r = fac n `div` (fac r * (fac n - r)) in 4 `choose` 3
02:38:04 <lambdabot>  0
02:38:08 <dmhouse> err
02:38:14 <dmhouse> > let fac n = product [1..n]; n `choose` r = fac n `div` (fac r * fac (n - r)) in 4 `choose` 3
02:38:15 <lambdabot>  4
02:38:20 <dmhouse> alternatively,
02:39:12 <Cale> scodil: I'm going to have to sleep -- sorry I've not written the tricky part, but I'll give you what I have, which should be illustrative anyway.
02:39:22 <dmhouse> > let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]; n `choose` r = pascal !! n !! r in 4 `choose` 3
02:39:22 <roconnor> k `choose` i = product (take i [k,k-1..]) `div` (factorials!!i)
02:39:23 <lambdabot>  4
02:39:41 <dmhouse> Cale, thanks for your mini-lecture, i'll be sure to digest it fully. :)
02:40:01 <Cale> http://cale.yi.org/autoshare/STDList.hs
02:40:15 <scodil> Cale: thanks. i appreciate it
02:41:12 <Cale> scodil: If you don't want the dependence on mdo, it's possible to remove it, but you end up creating STRefs with undefined values and then setting them after
02:41:57 <Cale> mdo basically lets you use values before they should be computed, as long as you're not really looking at them too hard :)
02:42:56 <kosmikus> or mfix directly ...
02:43:18 <scodil> gotcha
02:44:22 <Cale> actually, it'll probably be essential for freeze to be lazy
02:44:38 <Cale> so might as well use it :)
02:47:02 <scodil> I'll have to think about this while I sleep.
02:47:09 <scodil> night. thanks again Cale.
02:53:18 <araujo> morning
02:55:04 <alar> afternoon
03:02:31 <shapr> yow!
03:04:21 <alar> :)
03:06:23 <dmhouse> @yow!
03:06:23 <lambdabot> ... I want a COLOR T.V. and a VIBRATING BED!!!
03:15:29 * joelr1 waves
03:15:41 <joelr1> is anyone running a haskell web server?
03:15:49 <norpan> not me
03:15:56 <shapr> I'm playing with Hope, does that count?
03:16:10 <shapr> http://hope.bringert.net/
03:16:32 <norpan> are there any free h-words for new haskell projects?
03:16:47 <norpan> hijack?
03:16:47 <dmhouse> sure.
03:16:51 <dmhouse> heffalump?
03:16:56 <shapr> haftigt
03:17:05 <joelr1> shapr: and how is that going?
03:17:08 <norpan> hejåhå
03:17:09 <joelr1> heffaklumpen!
03:17:23 <roconnor> @hoogle two
03:17:24 <lambdabot> Test.QuickCheck.two :: Monad m => m a -> m (a, a)
03:17:24 <lambdabot> Network :: module
03:17:24 <lambdabot> Network.BSD.NetworkEntry :: NetworkName -> [NetworkName] -> Family -> NetworkAddr -> NetworkEntry
03:17:27 <joelr1> hobbit?
03:17:42 <dmhouse> plus, really random ones like hBanana. :)
03:18:18 <dmhouse> Haberdashery.
03:18:26 <dmhouse> Hemidemisemiquaver.
03:18:47 <joelr1> can we get back to the haskell web server?
03:18:53 <dmhouse> Hibernation.
03:22:53 <shapr> joelr1: I haven't built Hope yet, but it sure looks nice.
03:23:07 <dmhouse> HIPPOPOTO­MONSTRO­SESQUIPED­AL­IAN = pertaining to a very long word.
03:23:08 <dmhouse> From Mrs. Byrne's Dictionary of Unusual, Obscure and Preposterous Words
03:23:14 <dmhouse> there's one. :)
03:23:21 <joelr1> shapr: what makes it nice?
03:23:52 <dmhouse> HEPATICO­CHOLANGIO­CHOLECYST­ENTERO­STOMIES another nice possibility.
03:24:35 <dmhouse> of course, we're not going to beat http://www.llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch.co.uk/
03:25:04 <joelr1> dmhouse: is that an irish word or something?
03:25:09 <joelr1> gaelic?
03:25:13 <dmhouse> it's a Welsh town.
03:25:23 <joelr1> ah!
03:25:48 <joelr1> where all the residents are proud of their ability to properly pronounce the name 
03:25:50 <dmhouse> http://en.wikipedia.org/wiki/Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch
03:26:11 <dmhouse> pronounciation: http://www.llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch.co.uk/soundfiles/llandad4.wav
03:26:18 <earthy> the chapel of mary in the hollow by the brook, was it not? :)
03:26:32 <earthy> near the hazel, even
03:27:40 <dmhouse> St Mary's church in the hollow of the white hazel near to the rapid whirlpool and the church of St Tysilio of the red cave
03:28:08 <dmhouse> hehe, The village is split into two, smaller, villages, Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch-isaf (Lower Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch) and Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch-uchaf (Upper Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch).
03:28:56 <alar> is it Wales?
03:29:10 <dmhouse> not all of it. :)
03:29:14 <dmhouse> it's _in_ Wales, yeah.
03:29:29 <dmhouse> and is therefore Welsh. Perhaps that's what you meant.
03:30:03 <alar> yes, exactly
03:30:47 * alar is still puzzled by that name
03:31:36 <dmhouse> the Wikipedia page explains it as the amalgamation of two shorter names, when two villages combined.
03:31:52 <dmhouse> and a bit extra was added in, as the villages were linked by the whirlpool.
03:59:08 <apfelmus> roconnor: ping
04:00:36 <petekaz> @seen dons
04:00:36 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2 hours, 34 minutes and 25 seconds ago.
04:24:09 <joelr1> should i use HASP or HappS?
04:24:17 <joelr1> any suggestions?
04:24:46 <dcoutts_> can any one think of a genuine foldl, that is one that would not be expresable as a foldl' ?
04:26:48 <dmhouse> dcoutts_: aren't they the same apart from strictness?
04:26:57 <dcoutts_> dmhouse, right
04:27:12 <dcoutts_> so are there any example where the non-strictness is essential?
04:27:14 <dmhouse> oh, right. you want something that utilises the laziness of foldl?
04:27:18 <dcoutts_> exactly
04:27:30 <dcoutts_> I can't think of a single example
04:27:32 <boegel> coolness @ the town in Wales
04:28:05 <dmhouse> > foldl (\x xs -> x ++ take 20 xs) [1] [[1..], [2..]]
04:28:06 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,2,3,4,5,6,7,8,9,10,11,1...
04:28:46 <dmhouse> > foldl' (\x xs -> x ++ take 20 xs) [1] [[1..], [2..]]
04:28:47 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,2,3,4,5,6,7,8,9,10,11,1...
04:28:52 <dmhouse> nope.
04:29:10 <dmhouse> which argument is foldl' strict in?
04:29:25 <dmhouse> the function?
04:30:18 <Cale> ugh, can't sleep
04:30:35 <alar> > foldl' undefined 0 []
04:30:35 <lambdabot>  0
04:30:41 <alar> nope
04:30:57 <dmhouse> > foldl' (+) undefined [1..10]
04:30:57 <lambdabot>  Undefined
04:31:17 <dmhouse> but then foldl would be strict there as well
04:31:23 <Cale> Stupid news reporting on the "threat" of terrorism. In 2001, 11.5 times as many deaths were attributed to alcohol in the US than terrorism worldwide.
04:31:29 <micky0> @help
04:31:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:31:31 <alar> yep
04:31:39 <Cale> In 2003, that was 68.2 times.
04:31:49 <dmhouse> > foldl (+) undefined []
04:31:49 <lambdabot>  Undefined
04:32:05 <dmhouse> @fptools Data.List
04:32:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
04:32:08 <micky0> @list
04:32:08 <lambdabot> list [module|command]. Where modules is one of:
04:32:08 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo
04:32:08 <lambdabot> topic type unlambda version vixen where
04:32:09 <Cale> I wish they'd stop over-reporting non-threats.
04:32:21 <wolverian> Cale, wow, people really picked up drinking eh? :)
04:32:22 <micky0> @list localtime
04:32:22 <lambdabot> localtime provides: time localtime localtime-reply
04:32:30 <micky0> @localtime time
04:32:39 <dmhouse> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:32:52 <Cale> wolverian: not really, there's been ~40000 deaths in the US every year due to alcohol since at least 1982.
04:32:58 <alar> Cale: that's simple: internal enemies try to distract your attention on external enemies
04:33:02 <micky0> > [1..10]
04:33:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:33:12 <micky0> @list haddock
04:33:12 <lambdabot> haddock provides: index
04:33:17 <micky0> haddock
04:33:21 <Cale> alar: you mean the other way around?
04:33:23 <micky0> @haddock
04:33:24 <lambdabot> Unknown command, try @list
04:33:24 <Cale> oh
04:33:24 <wolverian> Cale, well, it was a poor joke :)
04:33:26 <Cale> I see :)
04:33:36 <Cale> yes, internal in that sense :)
04:33:40 <micky0> @index Maybe
04:33:40 <lambdabot> Data.Maybe, Prelude
04:33:58 <micky0> @list state
04:33:58 <lambdabot> state provides: state
04:34:46 <joelr1> Cale: have you used HASP or HappS?
04:35:10 <alar> our TV often throws the message about NATO threat between the lines , and talks about international terrorism alot. So people don't see real threats
04:35:45 <Cale> joelr1: nope
04:36:04 <joelr1> Cale: ok, thanks
04:36:09 <joelr1> musasabi: ping
04:36:34 <Cale> alar: yeah, 17 people were arrested in Canada on charges of conspiracy to commit terrorism, so the news won't shut up about it
04:37:11 <micky0> @list quote
04:37:11 <lambdabot> quote provides: quote ghc fortune yow arr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw
04:37:19 <micky0> @quote
04:37:20 <lambdabot> sethk says: it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
04:37:34 <micky0> @list seen
04:37:34 <lambdabot> seen provides: seen
04:37:38 <micky0> @seen
04:37:38 <lambdabot> Lately, I have seen alar, boegel, cale, dcoutts_, dmhouse, joelr1, micky0 and wolverian.
04:37:45 <boegel> @quote boegel
04:37:45 <lambdabot> boegel hasn't said anything memorable
04:37:49 <boegel> pfft
04:37:52 <joelr1> hehe
04:37:52 <boegel> @quote shapr
04:37:53 <lambdabot>  I don't know why the GHC team won't accept my spoonIO patch
04:38:01 <boegel> @quote shapr
04:38:02 <lambdabot>  GHC has more flags than the UN
04:38:05 <boegel> :)
04:38:06 <micky0> @list elite
04:38:06 <lambdabot> elite provides: elite
04:38:11 <micky0> @elite
04:38:11 <lambdabot> Say again?
04:38:14 <joelr1> @quote joelr1
04:38:14 <lambdabot> joelr1 hasn't said anything memorable
04:38:15 <micky0> @elite help
04:38:15 <lambdabot> |-|3lp
04:38:25 <micky0> @dice
04:38:26 <lambdabot> "dice" (line 1, column 1):
04:38:26 <lambdabot> unexpected end of input
04:38:26 <lambdabot> expecting digit
04:38:32 <micky0> @help dice
04:38:32 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
04:38:54 <dmhouse> > foldl' (\x y -> if y < 5 then x+y else undefined) 0 [1..5]
04:38:55 <lambdabot>  Undefined
04:38:58 <dmhouse> > foldl (\x y -> if y < 5 then x+y else undefined) 0 [1..5]
04:38:59 <lambdabot>  Undefined
04:39:40 <dmhouse> > foldl' (\x y -> if y < 5 then undefined else y) 0 [1..6]
04:39:41 <lambdabot>  Undefined
04:39:44 <dmhouse> > foldl (\x y -> if y < 5 then undefined else y) 0 [1..6]
04:39:45 <lambdabot>  6
04:39:48 <dmhouse> dcoutts_: ^^
04:39:59 <dcoutts_> ohh
04:41:05 <dcoutts_> so we pass a _|_ accumulator value and then discard it later
04:41:15 <dcoutts_> > foldl (\x y -> if y < 5 then undefined else y) 0 [1..5]
04:41:17 <lambdabot>  5
04:41:20 <dcoutts_> > foldl (\x y -> if y < 5 then undefined else y) 0 [1..4]
04:41:22 <lambdabot>  Undefined
04:41:24 <dcoutts_> > foldl (\x y -> if y < 5 then undefined else y) 0 [1..5]
04:41:25 <lambdabot>  5
04:41:28 <dcoutts_> right
04:41:38 <dmhouse> the point is that with foldl', you're seq'ing the value with the rest of the fold, so if it's undefined at any point, the whole thing is undefined. 
04:41:45 <dcoutts_> yes
04:41:50 <dmhouse> but with foldl, you can ignore the previous undefineds.
04:41:59 <dcoutts_> right
04:43:04 <dmhouse> is foldl' faster than foldr'?
04:43:16 <dcoutts_> there is no foldr'
04:43:24 <dmhouse> oh?
04:43:55 <dmhouse> just as there's no foldrM, or is there a more technical reason?
04:43:57 <dcoutts_> it's not needed like it is with foldl'
04:44:14 <dcoutts_> because foldr can produce values lazily
04:44:26 <dmhouse> strictly, you mean
04:44:34 <Cale> no, lazily
04:44:36 <dcoutts_> and because you can't do it strictly anyway
04:44:49 <dcoutts_> you can't jump to the end of the list and foldr' from there
04:44:55 <dcoutts_> which is what you'd need to do
04:45:04 <dcoutts_> for Data.ByteString we can do foldr' though
04:45:11 <dcoutts_> for exactly that reason
04:45:20 <dcoutts_> foldr is an up loop and foldr' is a down loop
04:45:40 <dcoutts_> you can do down loops with arrays, but not lists
04:51:03 <psi> whoa. new slashdot.
04:52:45 <psi> looks pretty spiffy
04:53:12 <dmhouse> yeah, it does.
05:05:19 <SamB_XP> @type foldM
05:05:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:06:29 <SamB_XP> it isn't called foldrM, because you can't sensibly have a foldlm
05:07:29 <dmhouse> SamB_XP: it _is_ a foldlM, and you _can_ have a foldrM.
05:07:39 <dmhouse> @fptools Control.Monad
05:07:40 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
05:08:34 <SamB_XP> wait, I got backwards?
05:08:39 <dmhouse> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
05:08:41 <SamB_XP> ...
05:08:44 * SamB_XP too tired
05:09:15 <kzm> JaffaCake, time for a small problem compiling GHC snapshots?
05:09:36 <JaffaCake> kzm: sure, what's up?
05:10:11 <kzm> I was going to toy with SMP - but my compile of a 6.5 snapshot failed.  Let me get you the error message...
05:10:38 <kzm> In function `s5TX_info':ghc18833_0.hc:(.text+0x1fc1): undefined reference to `stgMallocBytesRWX'
05:11:16 <kzm> When linking the stage 2 compiler, AFAICT.
05:11:35 <kzm> 20060530 snapshot, if it matters.
05:12:52 * kzm tries to keep his voice down, so as not to disturb the tranquil athmosphere.
05:14:30 <roconnor> @pf \x -> (fromInteger x)*q
05:14:31 <lambdabot> (q *) . fromInteger
05:14:36 <roconnor> @pf \x -> q*(fromInteger x)
05:14:36 <lambdabot> (q *) . fromInteger
05:14:51 * kzm stares intently at his computer's unblinking network activity leds.
05:14:59 * dmhouse wonders
05:15:07 <dmhouse> @pl \x -> (f x) - q
05:15:08 <lambdabot> subtract q . f
05:15:13 <dmhouse> aha!.
05:15:18 <dmhouse> clever bot.
05:15:21 <dmhouse> @botsnack
05:15:21 <lambdabot> :)
05:16:25 <arctanx> kzm: /part #ubuntu or /part #gentoo may help
05:17:00 * kzm raises an eyebrow.  Say what?  Why?
05:17:09 <arctanx> (assuming your network activity lights are stuck on)
05:17:17 <kzm> Heh.
05:17:53 <kzm> Actually, I /joined #ubuntu, just to check that my network was working :-)
05:18:08 <kzm> It was meant as a (more or less) gentle prod.
05:19:10 <kzm> But I guess I'll just have to wait.  Perhaps I'll get a cup of tea and a JAFFACAKE while I'm waiting?
05:19:19 <kzm> :-)
05:19:35 <JaffaCake> kzm: sorry, hang on a sec
05:19:46 <kzm> Sure :-)
05:20:22 <JaffaCake> I think you may have just hit a transient bug, update to the latest snapshot and try again
05:20:33 <kzm> Ah, okay.
05:21:01 <kzm> I was really trying to port to a big IBM thing, since somebody said it was "easy". (possibly you?)
05:21:22 <kzm> So I got an identical snapshot on my PC, which might be why it is a bit dated.
05:21:34 <kzm> Does bitness etc matter for the .hc files?
05:23:27 <SamB_XP> what is a JAFFACAKE, anyway?
05:23:42 <JaffaCake> SamB_XP: try wikipedia
05:23:48 <dmhouse> an English biscuity type thing.
05:24:00 <SamB_XP> ah
05:24:09 <dmhouse> or is it a cake? There was a big legal battle concerning this.
05:24:22 <dmhouse> (different tax laws for biscuits and cakes)
05:25:19 <dmhouse> ah, they're cakes.
05:25:29 <kzm> JaffaCake, is it interesting to do a binary distribution for POWER and AIX?
05:25:49 <kzm> And is there a binary snapshot for Solaris/Sparc?
05:26:07 <JaffaCake> kzm: POWER/AIX, sure, why not
05:26:24 <JaffaCake> we currently have some problems on Solaris/Sparc which we're trying to sort out
05:26:35 <kzm> The web page cites lack of access as the main reason for the missing IBM support.
05:26:36 <lennart> and speaking of binaries, is there a binary for wxHaskell with 6.4.2 for windows?
05:26:44 <JaffaCake> I believe Chrstian Meader put up a binary distribution recently, check the mailing list archives
05:26:55 <JaffaCake> wxHaskell: no idea
05:27:02 <kzm> Wasn't that only Solarix/x86?  Or do I misremember?
05:27:17 <joelr1> JaffaCake: hi simon! is ghc as a library available as part of 6.5 or earlier versions?
05:28:00 <JaffaCake> joelr1: 6.5 and later
05:28:00 <kzm> I guess I should really wait for tonight's number-of-the-beast version :-)
05:28:07 <joelr1> JaffaCake: ack
05:28:11 <JaffaCake> hehe
05:28:38 <kzm> let him who hath understanding recon the virtues of laziness...
05:29:47 <kzm> Anyway.  I'm compiling the neighbor of the beast, will get some tea, and undobtedly commence my rude complaints later in the afternoon.  
05:30:03 <SamB_XP> since when is 20060606 the number of the beast?
05:30:17 <lennart> hmmm, maybe i should send in my resource leak fixes for ghc so they get fixed some time :)
05:30:38 <SamB_XP> who is the neighbor? the evil mangler? no wait, that is written in PERL, and cannot be compiled!
05:30:38 <dmhouse> > filter (`notElem` "26") "20060606"
05:30:39 <lambdabot>  "0000"
05:30:42 <dmhouse> err
05:30:49 <dmhouse> > filter (`notElem` "20") "20060606" -- :)
05:30:50 <lambdabot>  "666"
05:30:59 <kzm> SamB_XP, well - like all of those NoB things, you need to apprehend the problem with some flexibility.
05:31:18 <lennart> > filter (== '6') "20060606"
05:31:19 <lambdabot>  "666"
05:31:19 <kzm> There is, however, increased police protection of churches today.
05:32:16 <dmhouse> > partition (=='6') "20060606"
05:32:17 <lambdabot>  ("666","20000")
05:32:23 <SamB_XP> 6/6/06 (The stupid american notation) made at least a little more sense
05:32:43 <dmhouse> SamB_XP: you don't need the American style.
05:32:46 <SamB_XP> (we don't have a smart notation)
05:32:53 <lennart> but dropping leading zeros it's 6/6/6 in any notation :)
05:33:08 <dmhouse> American: 6/6/06 (m/d/y). Everyone else: 6/6/06 (d/m/y)
05:33:24 <lennart> dmhouse: what do you mean "everyone else"?
05:33:35 <lennart> All civilized places use the ISO standard
05:33:39 <dmhouse> ;)
05:33:45 <dmhouse> I use 6th May 06 :)
05:33:46 <lennart> yy-mm-dd
05:33:48 <dmhouse> err, June
05:34:00 <kzm> lennart, i.e., nobody is civilized?
05:34:08 <lennart> swedes are
05:34:22 <kzm> you actually use ISO dates?
05:34:28 <lennart> yes
05:34:36 <SamB_XP> er, yy-mm-dd isn't that civilized
05:34:38 <kzm> we usually use 06.06.2006 or 06/06-2006
05:34:56 <lennart> i think yy-mm-dd is the only one that makes sense
05:34:58 <kzm> (in Norway, dare I say it, the neighbor of the Swedes)
05:35:00 <SamB_XP> yyyy-mm-dd is what *I* call civilized, yyyymmdd mostly so
05:35:07 <lennart> or yyyy-mm-dd actually
05:35:22 <dmhouse> d/m/y isn't too bad
05:35:28 <lennart> yes it is
05:35:30 <dmhouse> or even, dd/mm/yyyy
05:35:39 <dmhouse> if it weren't for the silly American style, that'd be great.
05:35:43 <kzm> but 2006-06-06 evaluates to 1994
05:35:43 <SamB_XP> well, yeah, d/m/y makes more sense than the stupid american style
05:35:46 <lennart> when i see numbers i expect most significatnt first
05:35:53 <dcoutts_> but how on earth the US ended up with midfix mm/dd/yy I have no idea
05:35:53 <SamB_XP> which is worse than VAX endianness
05:36:26 <lennart> nothing wrong with VAX endianess, it was the PDP11 that made little sense
05:36:30 <SamB_XP> lennart: well, at the very least they should be in *some* order of signifigance
05:36:48 <dmhouse> To be honest I use 6th Jun 2006 more than anything else.
05:36:53 * kzm was worried that this discussion had cheated him of his tea, but thankfully, GHC is still compiling.  Fast compilation times, bah, who needs'em?
05:37:12 <lennart> fast compilation is overrated :)
05:37:13 <SamB_XP> okay, so the PDP-11 ABI that gave the VAX wierd endianness... so?
05:37:52 <SamB_XP> s// it was/
05:38:06 <SamB_XP> (you can figure out where to put that ;-)
05:38:28 * SamB_XP wonders how one goes about contributing to HXT, since it seems not to have a darcs repository
05:38:48 <lennart> or hdirect :)
05:39:09 <apfelmus> *snob* ... a ghc compiled program bus errord. it's a shame. my world picture collapsed
05:39:09 <SamB_XP> well, in the case of hdirect, you ask to be maintainor, since it is currently dead!
05:39:15 <SamB_XP> apfelmus: haha
05:39:37 <SamB_XP> didn't you know Haskell has Ptrs?
05:39:55 <apfelmus> SamB_XP:  @!$#
05:39:56 <SamB_XP> (Or is a BUS ERROR more complicated than that?)
05:41:13 * SamB_XP never found out what those are for, doesn't remember if he's gotten them or not
05:41:40 * apfelmus sets up for a crusade against Ptrs
05:41:57 <SamB_XP> so, do you suppose if I sent a Darcs repo containing code to be added to HXT to the libraries list, that would be effective?
05:42:24 <SamB_XP> JaffaCake: what is the message size limit for the libraries list?
05:42:56 <JaffaCake> probably 40k, that's the default I think
05:43:11 <Cale> SamB_XP: they could also mean bad hardware, though that's rare
05:43:22 <JaffaCake> I could bump it if necessary
05:43:39 * SamB wonders how large his repo comes out when tarballed and suitably 7-bit-ified
05:44:09 <SamB> yes, I realize ;-)
05:44:45 * SamB really ought to check the Conjure list one of these days, someone might have sent a message to it that was too big
05:44:52 <SamB> (but who wants to wade through all the spam?)
05:45:31 <SamB> (at least I upped the size limit to fit the darcs patches we had been getting ;-)
05:47:08 * SamB has a really ugly parser which he is always getting types wrong in, maybe it would be better if he had used Happy's monad support...
05:47:13 <jmmv> hi
05:48:01 <SamB> jmmv: greetings
05:54:00 <ruffneck> jer ;)
05:54:08 <psi> if A and B are instances of Enum, and I have a function that returns an IO (A, A, B), and I have lastly in my do-block: return (toEnum a, toEnum b, toEnum c). Why would the compiler infer that to be IO (B, B, B)? 
05:59:09 <psi> bbl
06:00:44 <dmhouse> psi, what are the types of a, b and c?
06:00:54 <dmhouse> and that looks like the monomorphism restriction
06:00:58 <dmhouse> @type toEnum
06:00:58 <lambdabot> forall a. (Enum a) => Int -> a
06:01:05 <dmhouse> yeah, i think it is.
06:02:07 <roconnor> :type (,)
06:02:13 <roconnor> @type (,)
06:02:14 <lambdabot> forall b a. a -> b -> (a, b)
06:02:36 * alar never really understood monomorphism restriction
06:03:11 <roconnor> > zipWith (,) "hello" [0..]
06:03:12 <lambdabot>  [('h',0),('e',1),('l',2),('l',3),('o',4)]
06:03:29 <roconnor> oh wait, that's just zip
06:03:37 <roconnor> heh
06:03:40 <dmhouse> alar, within a given expression, something must have the same type.
06:04:19 <dmhouse> alar, for example, in (toEnum a, toEnum b, toEnum c), the compiler comes across toEnum a, infers that toEnum has a given type, then uses that for all the other toEnums in the triple
06:04:35 <alar> ah
06:04:38 <alar> thanks!
06:04:38 <roconnor> dmhouse: Is it: given an expression, any two equal subexpressions must have the same type?
06:04:46 <alar> didn't know it's that simple
06:04:50 <dmhouse> alar, it's not :)
06:05:00 <dmhouse> there are a whole load of other complexities which I don't remember.
06:06:01 <dmhouse> roconnor: ('a', 5). here the 'a' and the 5 are subexpressions of the pair, but have different types. Or was that not what you mean?
06:06:25 <roconnor> dmhouse: two _equal_ subexpressions
06:06:27 <dmhouse> oh, 'equal'.
06:06:42 <roconnor> I guess what I said isn't quite right
06:06:48 <dmhouse> ish.
06:06:54 <roconnor> @typeof (0,0)::(Int,Double)
06:06:55 <lambdabot> (Int, Double)
06:07:03 <roconnor> > (0,0)::(Int, Double)
06:07:04 <lambdabot>  (0,0.0)
06:07:17 <roconnor> anyhow, numbers are treated funny anyways
06:07:41 <roconnor> I might argue the two 0 are not equal expressions ;)
06:07:45 <Igloo> If you mean syntactically identical then no, e.g. id can be used with many types
06:08:01 <dmhouse> @type (^^)
06:08:02 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
06:08:06 <dmhouse> @type (^)
06:08:07 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:08:08 <roconnor> > (id 0, id 0) :: (Int, Double)
06:08:09 <lambdabot>  (0,0.0)
06:08:11 <dmhouse> @type (**)
06:08:13 <lambdabot> forall a. (Floating a) => a -> a -> a
06:08:17 <roconnor> Igloo: Yep, so I am totally wrong.
06:08:43 <dmhouse> > let x = 10 in (x/2, fromIntegral 10 :: Integer)
06:08:44 <lambdabot>  (5.0,10)
06:08:45 <vincenz> Igloo: have any clues on how to annotate something with constraints, then solving these, and then updating them?
06:08:51 <alar> is there easy way to force compiler to think different staying polymorphic? I mean cases when one cannot simply specify all toEnums to fixed types
06:08:52 <dmhouse> huh, didn't expect that.
06:10:03 <dmhouse> @type ceiling
06:10:04 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:10:11 <vincenz> dmhouse: you're wrong... regarding toEnum blabla before
06:10:24 <vincenz> dmhouse: different toEnums in a tuple don't have to be the same
06:10:50 <dmhouse> > let x = 1 in (toEnum x :: Char, toEnum x :: Bool)
06:10:51 <lambdabot>  ('\SOH',True)
06:11:14 <dmhouse> > let x = 1 in (toUpper *** not) (toEnum x, toEnum x)
06:11:15 <lambdabot>  ('\SOH',False)
06:11:19 <dmhouse> hmm
06:11:40 <vincenz> confusing lists and tuples?
06:11:45 <dmhouse> no
06:11:50 <ForgeAus> mmm tuples :)
06:12:06 <ForgeAus> hangon isn't a list a kind of tuple?
06:12:07 <dmhouse> I've seen examples of the monomorphism restriction of that form before,
06:12:17 <dmhouse> ForgeAus: err, kind of
06:12:25 <dmhouse> a list is a special case of a tuple, yes.
06:12:32 <ForgeAus> same as a set
06:12:34 <dmhouse> but we normally consider them distinct.
06:12:38 <dmhouse> no, a list /= set
06:12:41 <ForgeAus> well different special casecase
06:12:46 <ForgeAus> dmh..
06:12:51 <dmhouse> > [1, 2, 2, 3, 4]
06:12:52 <lambdabot>  [1,2,2,3,4]
06:12:53 <Igloo> They aren't special cases in Haskell
06:12:56 <ForgeAus> no I mean the aspect thats the same is a set is a kind of tuple also
06:13:01 <dmhouse> > Data.Set.fromList [1, 2, 2, 3, 4]
06:13:01 <lambdabot>  Not in scope: `Data.Set.fromList'
06:13:23 <dmhouse> ForgeAus: if you want to consider things that way, sure.
06:13:35 <dmhouse> Igloo: aside from implementation, why not?
06:13:38 <vincenz> Igloo: So any clues regarding what I asked?
06:14:43 <Igloo> dmhouse: Different typing rules
06:15:04 <Igloo> vincenz: Nothing non-obvious
06:15:14 <dmhouse> Igloo: that's why I said a list was a special case of a tuple: a list is a homogenuous tuple.
06:15:17 <Cale> A list is either the empty list, or a pair consisting of an element and a list :)
06:15:25 <vincenz> Igloo: Non-obvious is ok too, I need a constraint based system to annotate something
06:15:42 <vincenz> dmhouse: a list is not a homogeneous tuple
06:15:43 <dmhouse> oh, that's true, you can't have the empty tuple.
06:15:53 <Cale> In Haskell, you can :)
06:15:56 <vincenz> dmhouse: nor can tuples vary in size
06:16:00 <Cale> @type ()
06:16:01 <lambdabot> ()
06:16:06 <vincenz> Cale: that's nil :D
06:16:13 <vincenz> Cale: how about a one tuple?
06:16:13 <Cale> @type []
06:16:15 <lambdabot> forall a. [a]
06:16:43 <dmhouse> vincenz: ah, true.
06:16:44 <Cale> vincenz: not one-tuples though, as their syntax would conflict with ordinary bracketing
06:16:50 <dmhouse> forget about what I said, thne :)
06:16:54 <dmhouse> *then
06:16:54 <vincenz> Cale: yep and that's where the shoe doesn't fit
06:17:13 <vincenz> (well that and recursive types)
06:17:23 <ForgeAus> what so a tuple suddenly becomes something else if you remove all but one element from it?
06:17:32 <vincenz> ForgeAus: a tuple can't change sie
06:17:51 <vincenz> different sized tuples are completely different types
06:17:54 <ForgeAus> oh ok, scrap that question then, I wasn't aware of it
06:18:09 <vincenz> Cale: Any idea regarding constraint based system?
06:18:14 <Cale> hm?
06:18:28 * vincenz needs to annotate his typedexp with constraints and solve these and then fill it back in
06:18:36 <ForgeAus> so taht means you have to create a whole new tuple and dump the old data in to remove an element? or just ignore the element and work with the rest uh?
06:18:47 <vincenz> ForgeAus: no you wouldn't use a tuple
06:18:50 <vincenz> ForgeAus: you'd use a list
06:18:55 <Cale> ForgeAus: yeah
06:19:10 <Cale> (but probably you'd use a list, if the data were all the same type)
06:19:13 <ForgeAus> but isn't a list a "special case" type of tuple anyhow?
06:19:20 <Cale> no, not really
06:19:31 <dmhouse> vincenz: there is however an injective functor between the category of lists and the category of tuples (assuming a one-tuple).
06:19:57 <dmhouse> actually, no, scrap that too
06:20:06 <dmhouse> it would fail on arrows.
06:20:26 <dmhouse> namely the arrows that change the size of the list, e.g. (4:).
06:20:31 <Cale> dmhouse: It would also treat lists of different length as separate objects
06:21:17 * vincenz sighs
06:21:18 <dmhouse> Cale, well that's what we want
06:21:21 <vincenz> no constraint based system?
06:21:24 <vincenz> or even a paper I can look at?
06:21:26 <vincenz> dmhouse: no we don't
06:21:30 <Cale> vincenz: I don't know :)
06:21:45 * vincenz looks pleadingly at Igloo 
06:21:55 <Cale> vincenz: I've written a system sort of like that, but I just collected a set of constraints
06:22:02 <vincenz> Cale: right
06:22:07 <vincenz> Cale: that'd be great :)
06:22:38 <Cale> I don't know if I even have the code for it though
06:22:39 <dmhouse> anyone else noticed a marked increase in phishing recently?
06:22:51 <vincenz> Cale: well can you give me the general idea?
06:23:35 <Igloo> vincenz: I don't understand what you're asking. Just write a data structure that represents the constraints and a function that solves them, presumably returning a substitution
06:24:04 <vincenz> right just since I haven't done it before
06:24:05 <Cale> vincenz: well, you have some typing rules, and you go through your tree, say from top down, and whenever a typing rule applies, you add its consequences to your context set.
06:24:10 <vincenz> not sure what the datastructure would look like
06:24:16 <Igloo> What do the constraints look like?
06:24:19 <vincenz> basically
06:24:28 <vincenz> expressions can have side effecst
06:24:31 <vincenz> so !
06:24:35 <vincenz> and in recursive fucntions
06:24:48 <vincenz> some functions might have to be delayed (constraints) until all the recursive functions are treated
06:25:07 <vincenz> foo x = print ()
06:25:11 <Cale> vincenz: hmm
06:25:12 <vincenz> foo :: a -> T!
06:25:21 <vincenz> notice that only the returntype has !
06:25:36 <vincenz> and that should be nil of course, but heh
06:25:40 <vincenz> foo x = ... bar x ...
06:25:41 <Cale> ! is roughly IO :)
06:25:41 <alar> vincenz: Curry does solve constraints, instantiate free vars and it is written in Haskell
06:25:46 <vincenz> bar x = ... foo x ...
06:26:04 <vincenz> Cale: except I don't require do syntax, no monads
06:26:09 <vincenz> Cale: it's purely annotation
06:26:13 <Cale> right
06:26:21 <vincenz> and I can mix ! with non !
06:26:34 <Cale> hmm
06:26:36 <vincenz> just that the expression containing them both will have type !
06:26:46 <Igloo> Still sounds like IO to me
06:27:05 <Cale> what are the typing rules concerning ! ?
06:27:22 <vincenz> if a then b else c
06:27:24 <vincenz> a::T
06:27:27 <vincenz> b::T2
06:27:30 <vincenz> c::T2
06:27:31 <Cale> If I have a function a -> b, can I apply it to something of type a! ?
06:27:37 <vincenz> if any of the T's has ! then it returns !
06:27:44 <vincenz> Cale: yep
06:27:52 <Cale> hm
06:27:52 <vincenz> Cale: that's why it's a post-type thing
06:27:56 <Igloo> You're just implicitly insertings returns and >>= from the sound of it
06:27:57 <vincenz> it doesn't affect the typing rules
06:28:06 <vincenz> Igloo: yp
06:28:10 <vincenz> Igloo: pretty much
06:28:15 <vincenz> Igloo: it's like SML
06:28:22 <Cale> so you're keeping track of when IO occurs, but never restricting its use?
06:28:33 <vincenz> only in one place am I restricting it
06:28:36 <vincenz> hence the requirement :D
06:28:45 <Igloo> Cale: Explicit type sigs will restrict its use
06:28:47 <vincenz> toplevel nonfunc declarations
06:29:08 <vincenz> look the !
06:29:15 <vincenz> does -not- affect the typing system
06:29:23 <vincenz> it's done posttypecheck as an annotation on all types
06:30:01 <Cale> vincenz: If I give something an explicit type signature, and the ! isn't there when it's supposed to be, is it an error?
06:30:17 <vincenz> Cale: there are no explicit type sigs
06:30:21 <vincenz> at least not atm
06:30:26 <Cale> oh, okay
06:31:44 <vincenz> only foreign functions are explicitly type-decled
06:31:47 <vincenz> which is obvious
06:31:52 <vincenz> cause they have no body
06:32:08 <Cale> So I guess what you do is for each bit of syntax, work out the typing rules that apply to it. You'll mostly probably just be collecting equations
06:32:26 <Cale> type equations are usually easy to solve because equality is structural
06:32:36 <Cale> (mostly)
06:32:56 <vincenz> actually I don't collect constraints
06:32:58 <vincenz> I unify in place
06:33:25 <Cale> doing it in-place seems like more trouble than it's worth to me, but okay
06:33:33 <vincenz> not really
06:33:36 <vincenz> it's quite simple
06:33:45 <vincenz> the typechecking that is
06:33:53 <Cale> ...if you have mutable datastructures :)
06:34:04 <vincenz> ?
06:34:11 <vincenz> again no
06:34:21 <vincenz> since ! doesn't affect typing
06:34:24 <Cale> How are you representing your AST?
06:34:24 <vincenz> it's done in a second pass
06:34:33 * vincenz kicks his laptop
06:34:38 <Cale> no, not in your language, in your abstract syntax
06:34:42 <vincenz> for some reason it has a proxy setting and I cant find where
06:35:00 <vincenz> Cale: hmm?
06:35:07 <Cale> Unless you're using IORefs or STRefs for type variables, unifying in place seems like a pain.
06:35:12 <vincenz> Cale: no
06:35:19 <vincenz> Cale: I do a postnormalize on toplevel exps
06:35:24 <vincenz> Cale: I use a map
06:35:28 <vincenz> in StateT
06:35:39 <Cale> oh, okay
06:35:44 <vincenz> quite easay
06:35:48 <Cale> that sounds more like collecting equations to me
06:36:05 <vincenz> sort of except I already partially decorate
06:36:15 <vincenz> depending on how much normalization can be done locally
06:36:21 <vincenz> and
06:36:26 <vincenz> I require normalization pre-unification
06:36:31 <vincenz> so I don't get cycles
06:36:33 <Cale> well, you should always at least decorate everything with unique type variables
06:36:41 <vincenz> but
06:36:46 <vincenz> let's focus on the bit that needs doing :D
06:38:23 <vincenz> the ! stuff
06:38:46 <Cale> You could even keep that part in a separate map
06:39:06 <Cale> Or just include an additional bool in your types
06:39:13 <vincenz> that's the plan
06:39:36 <vincenz> annotate my types
06:40:01 <vincenz> except I do it in a separate pass
06:40:06 <vincenz> cause it shouldn't bleed through unification
06:40:15 <Cale> It should be pretty trivial -- when you unify types, you take the OR of their flags.
06:40:17 <vincenz> the rules of expansion (or whatever you call it) are different
06:40:25 <vincenz> Cale: not so
06:40:29 <Cale> no?
06:40:31 <vincenz> no
06:40:39 <vincenz> take this example
06:40:39 <Cale> hmm
06:40:52 <vincenz> let foo x = { x <- 3; !x}
06:41:00 <vincenz> this has type :: Ref Int -> !Int
06:41:16 <vincenz> ok?
06:41:16 <Cale> okay
06:41:40 <vincenz> let bar .. = {y = new 1; zed (foo y); }
06:41:52 <vincenz> zed should be :: Int -> ...
06:41:55 <vincenz> not !Int -> ...
06:41:58 <Cale> so yeah, I suppose you have to determine in each case if you want the flag to propagate
06:42:01 <vincenz> cause the language is strict
06:42:06 <vincenz> right
06:42:13 <vincenz> that's why I prefer doing it in a separate pass
06:42:20 <vincenz> cause the rules are different than when I unify
06:42:24 <Cale> okay
06:42:33 <vincenz> afaict
06:42:36 <vincenz> only return types can be !
06:42:42 <Cale> overall, the structure of the code should be similar though
06:42:46 <vincenz> yep
06:42:50 <vincenz> it's just a bottomup approach
06:42:57 <vincenz> except for recursive declarations
06:43:04 <vincenz> which is where I need constraints
06:45:28 <vincenz> and that's why I need em
06:45:32 <vincenz> let foo x = ... bar ...
06:45:36 <vincenz> let bar x = .... foo ...
06:45:40 <vincenz> if I don't use constraints
06:45:43 <vincenz> in the worst cas
06:45:50 <vincenz> I have to N passes for N recursive declarations
06:46:20 <vincenz> just not sure how to write em
06:46:20 <LPhas> Hi, i'm trying to get the binary rappresentation of integers, anyone knows how to do it?
06:46:30 <Cale> LPhas: Data.Bits
06:46:59 <LPhas> Cale : i looked at it, but i cannot really uderstands how it works :|
06:47:48 <Cale> LPhas: testBit x n will tell you if the nth bit of x is on or off
06:48:06 <LPhas> oh
06:48:38 <Cale> Of course, you can write something pretty easily which does without Data.Bits
06:48:47 <Cale> and just uses div and mod by 2
06:49:01 <Cale> n `mod` 2 is the ones-bit of n
06:49:05 <LPhas> Cale, yes but i prefer using builtin functions when there are
06:50:18 <alar> graduate education tends to liberate one of petty concerns such as efficiency of built-in integers :)
06:51:38 <ndm> alar, memories of trying to track down Int overflows in an embeded device liberates me from the concern of using a buggy abstraction :)
06:52:13 <alar> ndm: that was from "evolution of Haskell programmer"
06:53:10 <Cale> > unfoldr (\n -> if n == 0 then Nothing else let (x,y) = divMod n 2 in Just (y,x)) (product [1..20])
06:53:11 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,1,1,...
06:53:28 <Cale> @more
06:53:36 <Cale> hmm, no more @more
06:54:39 <Cale> > unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` 2, n `div` 2)) (product [1..10])
06:54:40 <lambdabot>  [0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1]
06:54:46 <Cale> that's possibly clearer
06:55:16 <Cale> note that the bits are in reverse order
06:55:37 <Cale> this has the advantage of working correctly with Integers
06:55:42 <Cale> and not just Ints
06:56:58 <Cale> or, clearer still...
06:57:42 <Cale> > let bits = map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) in bits 32189071
06:57:43 <lambdabot>  [1,1,1,1,0,0,0,1,0,1,0,1,0,1,0,0,1,1,0,1,0,1,1,1,1]
06:59:14 <Cale> Most applications of unfoldr are easily replaced by clearer applications of iterate, takeWhile, and map
06:59:41 <Cale> (probably not all of them though)
06:59:57 <wolverian> that's cute. 
07:00:08 <Cale> but I'm tired, I might just not see it
07:00:11 <vincenz> Cale: so...
07:01:39 <waern> JaffaCake: ping
07:03:06 <Cale> vincenz: just collect "equations", which are basically pairs of type variables (in this case second-pass type variables, which are different from your original ones, probably)
07:03:06 <Igloo> waern: He left an hour ago
07:03:16 <waern> ah, ok
07:03:28 <vincenz> Cale: alright 
07:03:42 <Cale> you then go through that set of equations at the end, and build a replacement map from it
07:03:51 * vincenz nods
07:04:58 <Cale> basically, when you see an equation like a = Bang or a = NotBang (or either of those swapped), you add the map rule a |-> Bang or NotBang as the case may be, and apply that to your set
07:05:31 * vincenz nods
07:05:35 <Cale> So all the a's become Bang or NotBang. Then you recurse on the remainder of the set (probably just a list will do)
07:05:42 <vincenz> right
07:05:45 <vincenz> what about recursiveness?
07:05:51 <LPhas> uhm, strange thing here
07:05:58 <LPhas> data Packet = Info Int | Send Int | Aya (Int, Int) deriving (Show,Read)
07:06:22 <Cale> vincenz: If there's an equation like a = b, you can't do anything with it yet, so leave it alone.
07:06:23 <LPhas> *Packet Network> read (show (Info 3))
07:06:24 <LPhas> *** Exception: Prelude.read: no parse
07:06:32 <vincenz> Cale: ah right
07:06:45 <Igloo> LPhas: read (show (Info 3)) :: Packet
07:06:53 <Igloo> It'll be defaulting the type to Int
07:07:01 <Cale> vincenz: either it'll get resolved at some point, or you have an ambiguity
07:07:02 <Igloo> Ermm, IM Integer
07:07:07 <vincenz> Cale: correct
07:07:08 <LPhas> Igoo , i love you
07:07:20 <vincenz> Cale: I take it that when you only have pure ones you get left with ambiguity
07:07:28 <vincenz> pure ones being a = b
07:07:32 <Igloo> LPhas: Thanks  :-)
07:07:34 <Cale> right
07:07:38 <vincenz> except
07:07:40 <vincenz> not ini this case
07:07:42 * vincenz ponders
07:07:43 <vincenz> :D
07:07:56 <vincenz> Cale: I actually have a resolve rule for that \o
07:08:00 <vincenz> let foo x = ... bar x ...
07:08:04 <vincenz> let bar x = ... foo x ...
07:08:08 <vincenz> foo -> bar, bar -> foo
07:08:17 <vincenz> but if neither is ! except for the recursiveness, then neither is !
07:08:29 <Cale> I guess if you're left with only rules like a = b
07:08:36 <vincenz> then they're all notbang
07:08:38 <Cale> then you just type all of the mentioned variables as pure
07:08:41 <Cale> right
07:08:45 <vincenz> alrighty
07:10:30 <Cale> 'night at 10am
07:11:55 <vincenz> night
07:37:56 <greenrd> Can type inference "see into" existentially quantified data types?
07:38:50 <dmhouse> greenrd: depends, could you give an example?
07:39:23 <greenrd> In other words, if I have data Foo = forall a. Foo a and f :: Foo -> Foo, can the compiler infer that f (Foo 1) contains 1?
07:39:33 <greenrd> if indeed it does
07:39:38 <greenrd> suppose f = id
07:40:22 <greenrd> er, sorry, I'm thinking in terms of dependent types here
07:40:41 <greenrd> I should have said "can the compiler infer that f (Foo 1) contains an Int?"
07:40:44 <greenrd> or something
07:42:21 <alar> greenrd: do you really understand dependent types?
07:42:29 <greenrd> No
07:42:52 <greenrd> But I'm attempting to simulate them in Haskell by using some extensions like GADTs
07:43:45 <alar> I thought about simulation of dependent types by using Template Haskell
07:43:58 <alar> GADTs have less power than DT
07:44:02 <alar> IMHO
07:55:17 <greenrd> Did you mean to say, GADTs have less power than TH?
07:55:34 <dmhouse> DT = dependant types
07:55:37 <greenrd> sure
07:57:11 <alar> I think I can construct an example of what is possible with DT but impossible with GADTs
07:57:16 <alar> but I'm not sure
07:57:16 <greenrd> ok, go ahead
07:57:25 <alar> too low knowledge on both subjects
07:57:46 <greenrd> I'm trying to figure out how to simulate a dependently-typed version of foldr
07:59:01 <alar> you mean when [a] is replaced by Vec n a ?
07:59:19 <greenrd> Well, yes
07:59:39 <greenrd> I already have that
08:00:20 <greenrd> but my idea is that if you have foldr f x c, and f's type states some relation between its input and its output, foldr should establish the nth-iteration of that relation, or something
08:01:36 <greenrd> e.g. suppose f is VecCons, which states that the output list is one longer than the input list, and x is VecEmpty
08:02:42 <alar> what's the definition of VecCons?
08:03:10 <alar> are VecCons and VecEmpty the constructors of Vec?
08:03:15 <greenrd> yeah, basically
08:03:23 <greenrd> my implementation is somewhat different, but that's the basic idea
08:04:35 <vincenz> anyone know how to write BNF style syntax in tex?
08:26:21 <vincenz> is inobtrusive a proper english word?
08:26:42 <wilx> @dict inobtrusive
08:26:43 <lambdabot> Supported dictionary-lookup commands:
08:26:43 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
08:26:43 <lambdabot> Use "@dict-help [cmd...]" for more.
08:26:53 <vincenz> @all-dicts inobtrusive
08:26:55 <lambdabot> *** "Inobtrusive" gcide "The Collaborative International Dictionary of English v.0.48"
08:26:55 <lambdabot> Inobtrusive \In`ob*tru"sive\, a.
08:26:55 <lambdabot>  Not obtrusive; unobtrusive. -- {In`ob*tru"sive*ly}, adv. --
08:26:55 <lambdabot>  {In`ob*tru"sive*ness}, n.
08:26:55 <lambdabot>  [1913 Webster]
08:27:01 <vincenz> yep :)
08:27:03 <wilx> :)
08:30:32 <Igloo> Technically, maybe, but unobtrusive is the word that would be used
08:30:44 <roconnor> @pf (\x y -> x*(constP y))
08:30:45 <lambdabot> (. constP) . (*)
08:30:54 <vincenz> Igloo: thx
08:31:04 <roconnor> @pf (\x y -> (constP y)*x)
08:31:05 <lambdabot> (. constP) . (*)
08:31:47 <Igloo> roconnor: @pf makes (incorrect) assumptions about commutativity
08:32:02 <vincenz> @help pf
08:32:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:32:15 <vincenz> @help pl
08:32:16 <lambdabot> pointless <expr>. Play with pointfree code.
08:33:23 <ForgeAus> Vincenz BNF? what you writing a compiler?
08:33:39 <ForgeAus> its mostly unobtrusive
08:33:41 <norpan> what's the point
08:34:00 <roconnor> I <3 Haskell
08:34:04 <roconnor> "foldr (zipWith (+)) (repeat 0) $ zipWith toBernsteinzXs p' [0..]"
08:34:26 <vincenz> ForgeAus: erm yes I'm also writing a compiler, but the BNF notation is not related to that
08:34:46 <dmhouse> @instances Show
08:34:47 <lambdabot> Float, Double, Integer, ST s a, [a], (a, b, c, d), (a, b, c), (a, b), (), Ordering, Maybe a, Int, Either a b, Char, Bool
08:34:59 <dmhouse> grr. dons still hasn't applied my newest patch
08:36:34 <Spark> http://web.media.mit.edu/~vyzo/papers/computability.pdf
08:37:54 <Spark> @dict unobtrusive
08:37:56 <lambdabot> Supported dictionary-lookup commands:
08:37:56 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
08:37:56 <lambdabot> Use "@dict-help [cmd...]" for more.
08:38:08 <Spark> ah, been there done that
08:38:10 <Spark> fair enough
08:41:43 <alar> Spark: is it serious?
08:42:54 <joelr1> musasabi: ping
08:44:24 <vincenz> alar: as long as it's not published, no
08:45:24 <vincenz> I find the logic used in it rather... sparse
08:45:57 <alar> Good luck waiting for the end of time  I have other things to do.
08:45:58 <alar> lol
08:46:44 <alar> seems that date is wrong
08:46:52 <alar> it should be 01.04.06
08:47:05 <alar> not 06/06/06
08:57:30 <Spark> vincenz: yeah :)
08:58:03 <Spark> its like "proof: cats and monkeys can both climb trees so clearly badgers feel inadequate about it"
08:58:22 <Spark> it also loses for confusing lisp with the lambda calculus
08:58:53 <Spark> also, havent people encoded LC in TM and vice versa
08:59:58 <Spark> http://web.media.mit.edu/~vyzo/papers/computability.pdf
09:00:00 <Spark> oops
09:00:13 <Spark> acrobat is refusing to copy to the clipboard
09:00:26 <Spark> The UTM is an axiomatic system with one axiom: innity, provided by the innite tape.
09:00:37 <Spark> what about time?
09:56:14 <shapr> @get-bringert
09:56:14 <lambdabot> Unknown command, try @list
09:56:16 <shapr> doh!
09:56:20 <kombinator> where can I find some info on concurrency (lightweight threads) in GHC? For instance, how they interact with IO
09:56:41 <alar> @get
09:56:42 <lambdabot> Maybe you meant: get-definition get-shapr ghc
09:56:56 <alar> who is bringert?
09:57:19 <alar> @put-shapr
09:57:20 <lambdabot> shapr!!
09:57:26 <alar> oh
09:57:30 <alar> @put
09:57:30 <lambdabot> Maybe you meant: part pl quit run
09:57:41 <Igloo> @post-shapr
09:57:42 <lambdabot> Unknown command, try @list
09:57:55 <alar> =)
09:58:02 <Igloo> (I'll get my coat)
09:58:54 <dmhouse> @put-shapr, you mean
09:58:54 <lambdabot> Unknown command, try @list
09:58:58 <dmhouse> and @modify-shapr
09:59:12 <dmhouse> perhaps even @bind-shapr
09:59:36 <roconnor> @pf \x y -> x / (fromInteger y)
09:59:36 <alar> oh, ah @head-shapr then
09:59:37 <lambdabot> (. fromInteger) . (/)
10:09:10 <alar> @ping-shapr
10:09:10 <lambdabot> Unknown command, try @list
10:11:26 <shapr> bringert: it worked!
10:11:53 <shapr> <shapr> @get-bringert \n *** bringert (n=bjorn@71-212-45-240.tukw.qwest.net) has joined channel #haskell
10:12:38 <shapr> bringert: The asian market near First Hill is really fun to wander through. I had no idea people at those sorts of thing.
10:14:14 <alar> cool command!
10:14:20 <alar> @seen reductor
10:14:20 <lambdabot> I haven't seen reductor.
10:16:36 <shapr> bringert: modules/halbum2/Halbum/ImageInfo.hs:13:5: \n No instance for (Read Properties) \n arising from the 'deriving' clause of a data type declaration at modules/halbum2/Halbum/ImageInfo.hs:13:5 \n Probable fix: add an instance declaration for (Read Properties) \n When deriving the `Read' instance for type `ImageInfo'
10:16:47 <shapr> bringert: And that's after darcs pull -a in all the repos
10:16:58 <shapr> Well, yesterday... lemme try again today.
10:19:57 <shapr> bringert: No updates
10:21:25 * shapr hops
10:21:27 * shapr boings
10:23:29 <shapr> bringert: awaken!
10:23:52 <Excedrin> do ghc lists store list length internally?
10:24:07 <dmhouse> i don't think so.
10:25:05 <dcoutts_> Excedrin, no
10:25:17 <dcoutts_> finding the length takes O(n)
10:26:12 <dcoutts_> you couldn't have lazy lists if they knew their length
10:26:29 <shapr> Igloo: whoa, you have ops... doing some kickin?
10:27:22 <Excedrin> I imagined that it could store Just length/Nothing
10:32:08 <Igloo> shapr: I'm leaving them on since people said they didn't know who to prod in times of trouble
10:35:05 <dmhouse> Igloo: good idea. I think we should have 2-3 people opped up all the time
10:35:18 <dmhouse> because if you're asleep, etc.
10:37:13 <bringert> shapr: morning
10:37:37 <bringert> I thought I'd fixed that Read thing
10:37:38 <shapr> Igloo: smart
10:37:54 --- mode: ChanServ set +o shapr
10:37:59 --- mode: ChanServ set +o dons
10:38:09 --- mode: ChanServ set +o dmhouse
10:38:13 * shapr grins
10:38:47 <bringert> shapr: ok, seems I forgot to push it
10:38:51 * shapr pulls
10:38:57 <bringert> shapr: not yet
10:39:06 * shapr waits
10:39:27 <bringert> shapr: I made some changes when compiling in my Linux VM which has ghc 6.4.1, forgot to push them from there
10:39:34 <bringert> booting it up...
10:39:36 <shapr> ok
10:40:07 <bringert> shapr: but you got the RSS patch right?
10:40:35 <shapr> Er, I dunno...
10:40:37 <dmhouse> shapr: woah, i get ops?!
10:40:46 <shapr> Probably, I just did darcs pull -a in all three repos.
10:41:02 <shapr> dmhouse: Sure, you want to keep the channel clean, yeah?
10:41:15 <dmhouse> sure.
10:41:19 <shapr> awright then!
10:41:20 <bringert> shapr: ok, pull!
10:41:25 <dmhouse> hey, I'm on study leave, so I don't do anything all day :)
10:41:42 <bringert> I kinda liked that GNAA guy
10:41:44 <bringert> cute
10:41:50 <shapr> Who?
10:41:52 <dmhouse> shapr: thanks
10:42:07 -ChanServ(ChanServ@services.)- shapr!n=user@2002:51e0:9345:0:0:0:0:2 ACCESS [#haskell] ADD dmhouse 39
10:42:09 <bringert> some troll the other day
10:42:12 <shapr> oh
10:42:18 <shapr> @keal
10:42:19 <lambdabot> with KealDigit quantum crackproof encryption possible
10:42:20 * vincenz wants ops
10:42:40 <bringert> SyntaxNinja showed up and kicked him out
10:42:42 <alar> =)
10:42:53 <alar> @keal what
10:42:54 <lambdabot> how do i search for someone saying 'Keal' in mirc
10:42:55 <shapr> vincenz: Will you be responsible and do things to encourage the development of community? Even when it means leaving the channel when you feel grumpy? :-)
10:43:33 <vincenz> shapr: Of course
10:43:40 <shapr> That's the hardest part of being an op, imho, knowing when to get out of the way.
10:43:42 <shapr> ok!
10:43:47 -ChanServ(ChanServ@services.)- shapr!n=user@2002:51e0:9345:0:0:0:0:2 ACCESS [#haskell] ADD vincenz 39
10:43:51 <vincenz> shapr: I typically just answer new qs
10:43:52 <vincenz> \o/
10:44:04 <vincenz> s/new/newbie
10:44:15 <dmhouse> :(
10:44:22 <dmhouse> now I want someone to spam, so I can kick them.
10:44:25 <shapr> heh
10:44:27 <bringert> shape,ADEpt: live Hope demo at http://hope.bringert.net/
10:44:34 <bringert> Java rocks!
10:44:34 <dmhouse> vincenz: we should have kick races.
10:44:36 <shapr> It's more fun to have a smoothly functioning channel honestly.
10:44:36 <vincenz> bringert: what is op?
10:44:42 <vincenz> erm hope
10:44:48 --- mode: ChanServ set +o vincenz
10:44:56 <bringert> vincenz: see link :-)
10:44:59 --- mode: vincenz set -o vincenz
10:45:02 <vincenz> bringert: checking it out :)
10:45:12 <shapr> It's hard to strike a balance between tolerance and taking out the trash.
10:45:16 <bringert> noone kicked me yet?
10:45:25 <shapr> bringert: Sorry, you write too much useful Haskell code.
10:45:42 <vincenz> bringert: So I take it that currently it's a sort of wiki?
10:45:43 <shapr> Hmm, it's not so happy with HDBC...
10:45:44 <bringert> asm is waay better than your lame Haskell!11!!!! lol
10:45:55 <bringert> shapr: what?
10:45:57 <shapr> bringert: Too few caps, the lame filter didn't notice you.
10:46:09 * shapr grins
10:46:26 <vincenz> Anyone know how to use different happy parsers together?
10:46:29 <dmhouse> @remember bringert asm is waay better than your lame Haskell!11!!!! lol
10:46:29 <lambdabot> Unknown command, try @list
10:46:34 <dmhouse> gah, still broken.
10:47:10 <shapr> -import Database.HaskellDB.HSQL.MySQL \n +import Database.HDBC.PostgreSQL -> ./Config.hs:18:20: Not in scope: `driver'
10:47:10 <bringert> vincenz: together in the same program, or using them to parse the same input
10:47:27 * shapr looks for HDBC docs
10:47:29 <bringert> shapr: I'll checkit out
10:48:01 <vincenz> bringert: well I have a compiler that parses a language somewhere between haskell and ml.  And part of it parses types, however I want to split this out so I can use it separately.
10:48:01 <shapr> If HSQL weren't such a pain in the butt to build I'd just use it.
10:48:28 <bringert> vincenz: ah, haven't tried that
10:48:40 * alar didn't have much trouble with HSQL
10:49:02 <bringert> shapr: my Database.HaskellDB.HDBC.PostgreSQL exports driver
10:49:12 <bringert> ah
10:49:13 <alar> shapr: with ghc-6.4.2 its build proceeds smoothly
10:49:20 <bringert> shapr: you imported HDBC directly
10:49:31 <bringert> shapr: you need to import Database.HaskellDB.HDBC.PostgreSQL
10:49:34 <alar> with older versions it complains
10:49:39 <bringert> you forgot the HaskellDB part
10:49:46 <shapr> bringert: ah, thanks
10:50:51 <bringert> shapr: eh, seems I called you shape before. sorry about that. I meant to say:
10:51:02 <bringert> shapr, ADEpt: live Hope demo at http://hope.bringert.net/
10:51:11 * shapr shrugs
10:51:12 <shapr> No worries
10:51:16 <vincenz> woot
10:51:16 <shapr> I've been called worse.
10:51:19 <vincenz> dmhouse: you want ops on #oasis?
10:51:25 <vincenz> You can have your go at kicking someone
10:51:41 <dmhouse> vincenz: let him explain himself first
10:51:45 <vincenz> dmhouse: I will
10:51:49 <vincenz> dmhouse: hence the questions ;)
10:52:03 <shapr> gwahr, it can't find the module
10:52:04 <alar> .         
10:52:23 * alar thinks the first kickandidate has just arrrived
10:52:53 <bringert> shapr: did you install haskelldb-hdbc-postgresql ?
10:53:02 <shapr> um
10:53:10 <bringert> which requires haskelldb-hdbc
10:53:25 <shapr> Do I need to drop into the subdirs and do stuff?
10:53:35 <shapr> oh, I do
10:53:36 <bringert> HaskellDB is like 13 Cabal packages
10:53:39 <bringert> shapr: yes
10:54:03 <shapr> yow
10:54:33 <shapr> Gah, I hate using 1 CPU again after a coupla years of two. Now my music drops out when I compile.
10:54:49 <bringert> you normally need haskelldb + haskelldb-{hsql | hdbc } + haskelldb-{hsql | hdbc }-{sqlite3 | postgresql | mysql | ... }
10:55:00 <stepcut> shapr: :p
10:55:11 <shapr> bringert: yikes!
10:55:12 <vincenz> shapr: get some pci chiponaboard
10:55:12 <bringert> + haskelldb-dynamic if you want dynamic driver loading
10:55:23 <Excedrin> does Network.HTTP support HTTPS?
10:55:32 <bringert> shapr: that's the best I could figure out
10:55:36 <shapr> Makes sense
10:55:39 <shapr> I can't think of anything better either.
10:55:43 <bringert> Excedrin: no, not in itself
10:56:06 <shapr> Doesn't cryptolib have SSL?
10:56:14 <dcoutts_> shapr, you should be using a distro which provdes packages for this db stuff :-)
10:56:30 <shapr> The debs are old.
10:56:38 <shapr> And I'm too lazy to become a DD and fix that problem.
10:56:41 <bringert> Excedrin: But I think it could be done with Network.HTTP and hsgnutls http://www.cs.helsinki.fi/u/ekarttun/hsgnutls/
10:56:44 <shapr> Though admittedly, it might take less time.
10:56:58 <dcoutts_> shapr, though actually I didn't know that HaskellDB supports HDBC, is that new? I should get the gentoo packages up..
10:57:17 <dcoutts_> shapr, we've got the latest HSQL and HDBC packages, but not HaskellDB yet
10:57:19 <bringert> Excedrin: I gave it a spin at some point, but got stuck on something, maybe it works with current hsgnutls
10:57:27 <shapr> HaskellDB kicks butt.
10:57:38 <shapr> Every day I use SQL I wish I could use HaskellDB instead.
10:57:42 <dcoutts_> so the current release supports HDBC then?
10:58:04 <bringert> dcoutts_: HDBC support is kinda new, it's been around for a few months in darcs, but never announced
10:58:13 <dcoutts_> shapr, btw, contributing ebuilds is easy, we maintain them in a darcs overlay :-)
10:58:17 <bringert> dcoutt_: there hasn't been a release for ages
10:58:18 <shapr> The code I've been writing the last few days would become about ten lines of higher order queries in HaskellDB. But instead, I have umpteen globs of SQL.
10:58:30 <dcoutts_> bringert, ah ok, we can only really package released software
10:58:48 <bringert> maybe I should try to make a release someday
10:59:02 <bringert> but there are some many bugs left
10:59:09 <dcoutts_> bringert, when you do, ping me and i'll add the gentoo ebuilds
10:59:10 <bringert> and no good test suite
10:59:11 <Excedrin> bringert: thanks, this looks promising
11:01:57 <shapr> After 1.5 hours of unicycle today, my tire gave out :-(
11:02:46 <shapr> aargh, Hope got linking errors!
11:02:50 <shapr> hei esap, ltns
11:02:59 <esap> hei shapr!
11:03:02 <bringert> shapr: what?
11:03:13 <dmhouse> hmm... what do people think about using http://meme.b9.com/cdates.html?channel=haskell as the logs instead of the current tunes URL?
11:03:17 * shapr runs make clean && make
11:03:24 <shapr> dmhouse: They don't always work.
11:03:30 <dmhouse> no?
11:03:43 <shapr> cmeme is the meme.b9.com bot, and clog is the tunes.org bot.
11:03:48 <shapr> cmeme dies a lot.
11:04:09 <dmhouse> aha. i thought meme just used tunes's logs.
11:04:10 <shapr> esap: How's code?
11:04:30 <shapr> bringert: It's building RSS, so I must have the RSS patch!
11:04:31 <esap> shapr: same as ever (not much progress...)
11:04:35 <shapr> crap, same linking error!
11:04:45 <bringert> shapr: paste!
11:05:04 <shapr> /usr/lib/gcc/i486-linux-gnu/4.0.4/../../../../lib/libpq.a(thread.o): In function `pqGetpwuid': \n (.text+0x7a): warning: Using 'getpwuid_r' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking \n /usr/lib/gcc/i486-linux-gnu/4.0.4/../../../../lib/libpq.a(ip.o): In function `pg_getaddrinfo_all': \n (.text+0xde): warning: Using 'getaddrinfo' in statically linked applica
11:05:04 <shapr> tions requires at runtime the shared libraries from the glibc version used for linking
11:05:10 <shapr>  /usr/lib/gcc/i486-linux-gnu/4.0.4/../../../../lib/libpq.a(thread.o): In function `pqGetpwuid': \n (.text+0x7a): warning: Using 'getpwuid_r' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking \n /usr/lib/gcc/i486-linux-gnu/4.0.4/../../../../lib/libpq.a(ip.o): In function `pg_getaddrinfo_all': \n (.text+0xde): warning: Using 'getaddrinfo' in statically linked applic
11:05:10 <shapr> ations requires at runtime the shared libraries from the glibc version used for linking
11:05:23 <bringert> shapr: those are just warnings
11:05:27 <shapr> oh
11:05:45 <shapr> /usr/lib/gcc/i486-linux-gnu/4.0.4/../../../../lib/libpq.a(fe-connect.o): In function `default_threadlock': \n (.text+0x34b3): undefined reference to `pthread_mutex_lock'
11:06:06 <bringert> shapr: if you want to get rid of the warnings, edit Makefile to removed the static stuff from GHCLINK
11:06:13 <bringert> shapr: oh, that is an error
11:06:38 * shapr pastes
11:06:45 <shapr> http://rafb.net/paste/results/MbPhUj56.html
11:06:56 <bringert> shapr: probably HDBC's PostgreSQL missing a C lib dependency
11:07:01 <shapr> hm
11:07:47 * shapr looks for missing C bits
11:08:27 <shapr> Seems ok..
11:08:30 <shapr> I'm using the debs.
11:08:40 <bringert> hmm, weird
11:09:18 <bringert> it's libpq that uses stuff that it can't find
11:09:31 <bringert> like pthread and ssl
11:09:34 * shapr rips out the pgsql-7.1-dev debs
11:09:43 <bringert> shapr: before you do that,
11:09:45 <shapr> ?
11:09:57 <bringert> shapr: try adding some -l flags to the Hope build
11:10:13 <int-e> -lpthread -lssl ?
11:10:13 <bringert> quicker way to try out what you need
11:10:41 <shapr> CosmicRay! Just the man I need!
11:10:48 <bringert> int-e: something like that 
11:11:32 <shapr> CosmicRay: Do you immediately know what's wrong with this? http://rafb.net/paste/results/MbPhUj56.html If not, I'll keep playing with it myself, but thought you might know since it seems to be HDBC debs not liking postgresql-dev debs or something.
11:11:33 <CosmicRay> shapr: hmm!  I hope this is good ;-)
11:11:49 * CosmicRay takes a look
11:12:07 <CosmicRay> first thought is that you may have forgotten -package HDBC-postgresql
11:12:19 <shapr> It's in there
11:12:31 <CosmicRay> second thought, then: try not compiling it statically and see if that helps
11:12:41 <CosmicRay> I have never tried compiling an app like this statically
11:13:00 <bringert> shapr: can you include the ghc command line output by make in the paste?
11:13:11 <shapr> Yup, just a moment
11:13:42 <CosmicRay> so, anyone have any thoughts on HSH?  Something cool or something I should just give up on right now?
11:13:50 <CosmicRay> http://www.haskell.org/pipermail/haskell/2006-June/018059.html if you haven't seen the announcement yet
11:13:56 <Igloo> shapr: Why are you compiling statically?
11:14:12 <bringert> Igloo: that's my fault
11:14:17 <shapr> I'm just a poor user. I cannot answer such questions.
11:14:20 * shapr grins
11:14:34 <bringert> Igloo: I compile Hope statically so that I can upload it to my webhost which doesn't have all the libs
11:14:43 <CosmicRay> shapr: this sounds like a zen question
11:14:47 <stepcut> CosmicRay: do you handle return codes ?
11:14:50 <CosmicRay> shapr: why is the universe compiled statically?
11:14:52 <bringert> though shapr probably doesn't need that
11:14:59 * esap googles for HSH and finds Albanian railways, hmm...
11:15:00 <shapr> CosmicRay: Because it doesn't have the libs?
11:15:05 <Igloo> Ah, OK
11:15:12 <CosmicRay> stepcut: yes.  at present the run function transforms them into exceptions.
11:15:25 <CosmicRay> stepcut: I am trying to figure out a more useful way to do that yet though.
11:15:36 <shapr> I don't know how to turn of static compiles.
11:15:38 <stepcut> CosmicRay: how do you detect when the program has finished running ?
11:15:42 <shapr> oh, duh
11:15:45 <CosmicRay> stepcut: waitForProcess
11:15:50 <shapr> let's get rid of GHCLINK     = -static -optl-static
11:15:55 <bringert> shapr: yes
11:15:58 <CosmicRay> or whatever the System.Posix.Process version of waitpid() is
11:16:09 <CosmicRay> esap: see http://www.haskell.org/pipermail/haskell/2006-June/018059.html
11:16:10 <shapr> bringert: anyway, http://rafb.net/paste/results/0w1jPy80.html
11:16:12 <shapr> hoi boegel 
11:17:05 <bringert> shapr: looks ok, let's see what happens without -static
11:17:10 <shapr> trying now
11:17:12 <Igloo> CosmicRay: I think for every day use you'd want a frontend that heuristically decides whether the input is haskell or something more like traditional shell, and use ghc-as-a-package to evaluate it
11:17:18 * shapr waits for the link...
11:17:20 <bringert> maybe I should remove the static stuff from the darcs version
11:17:29 <stepcut> CosmicRay: do run the waitForProcess in a seperate thread ?
11:17:42 <Igloo> CosmicRay: run ("ls", []) just isn't practical as a replacement for ls
11:17:43 <shapr> wargh - Compiling Hope.Html        ( ./Hope/Html.hs, ./Hope/Html.o ) \n ./Hope/Html.hs:21:18: Not in scope: `faviconLink' \n ./Hope/Html.hs:40:33: Not in scope: `rssLink'
11:17:48 <psi> dmhouse: thanks! monomorphism restriction seemed to a correct guess
11:18:05 <CosmicRay> stepcut: no.  I initially tried mixing threads with forking and it didn't work out so well.  it blocks for the entire pipe to finish just like a regular shell would.
11:18:14 <shapr> It didn't fork out so well?
11:18:15 <CosmicRay> Igloo: Yes.  I agree.  I am thinking of something along the lines of wash's preprocessor.
11:18:21 <CosmicRay> shapr: heh
11:18:23 <psi> dmhouse: -fno-monomorphism-restriction made it compile. :)
11:18:33 <stepcut> CosmicRay: so you can not lazily read the output of the pipeline ?
11:18:34 <dmhouse> psi, great! does it work, or just compile?
11:18:50 <CosmicRay> stepcut: oh.  Yes, you can do that.  I haven't provided convenient tools for it yet, but it is possible.
11:18:58 <dmhouse> psi, and it wasn't i guess, i knew exactly what i was talking about... ;) err... :)
11:18:58 <bringert> shapr: you need to update your Hawl :-)
11:19:00 <shapr> CosmicRay: seen dons' h4sh and volker's hsshellscript?
11:19:02 <psi> dmhouse: I haven't tried yet :)
11:19:03 <shapr> bringert: oh, thanks
11:19:05 <xerox> おはよう！
11:19:07 <CosmicRay> stepcut: each Haskell function is forked off into its own process.
11:19:10 <dmhouse> xerox!
11:19:15 <CosmicRay> shapr: no, but thanks for the google keywords ;-)
11:19:17 <bringert> shapr: I know it's a pain, I develop all these packages in parallel
11:19:44 <CosmicRay> stepcut: that turned out to be easier than using fork for the system commands and forkIO for haskell functions.
11:19:57 <CosmicRay> I had a lot of trouble getting fds and file handles to match well when trying to mix the two apis
11:20:11 <dmhouse> xerox, guess what happened to me?
11:20:21 <CosmicRay> if it turns out to be a performance issue, it can be addressed later.
11:20:24 <xerox> dmhouse - Your house has burnt?
11:20:32 <CosmicRay> for now it is the KISS approach to the problem ;-)
11:21:04 <dmhouse> xerox: err, almost. shapr gave me +o :) *beams* (he was handing it out for free, you missed out ;))
11:21:09 <psi> dmhouse: yes, it works. I assume the restriction is there for a good reason, though?
11:21:21 <dmhouse> i figure as i do nothing all day i may as well sit here and kick people.
11:21:28 <dmhouse> psi, i would assume so too.
11:21:31 <xerox> Oh. One time I quit IRC...
11:21:36 <xerox> Well, good (:
11:21:36 <stepcut> CosmicRay: if waitForProcess is blocking, who is reading the data from the end of the pipeline ?
11:21:40 <shapr> gwahr, Linking ... \n ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1): unknown exception
11:21:52 <shapr> Oh, I bet it didn't like me removing the old hawl after configure
11:22:13 <CosmicRay> stepcut: the output from the last item goes to stdout.  of course, is the last item is writeFile or something, nothing actually goes to stdout.
11:22:23 <dmhouse> xerox, hehe
11:22:38 <CosmicRay> stepcut: this is almost certainly not the ideal way to do it.
11:22:44 <CosmicRay> stepcut: I wrote this code in a few hours on a train ;-)
11:23:04 * esap feels I need to implement shell functionality in my programming language :-)
11:23:08 <CosmicRay> stepcut: feel free to pull the code and poke around
11:23:09 <stepcut> CosmicRay: Just curious... I worked on a library similar to this for a while 
11:23:36 <CosmicRay> stepcut: basically, what is passed to run is a ShellCommand object
11:23:59 <CosmicRay> a ShellCommand can be a program to run, some Haskell function, or a pipe (which encapsulates two other ShellCommand objects)
11:24:08 <bringert> shapr: I'm thinking that I should merge hope, halbum2 and hope2 into one repo. That should give you a bit fewer pulls to make
11:24:10 <CosmicRay> or really anything that makes itself a member of the ShellCommand typeclass.
11:24:20 <xerox> I am envious now, tough! (:
11:24:29 <shapr> bringert: it BUILT!
11:24:35 <bringert> shapr: great!
11:25:07 <bringert> shapr: now it probably won't work with your apache config :-)
11:25:16 <CosmicRay> run, then, sets up the command and waits for it to complete.  the Pipe type simply uses a "wait for completion" function that waits on both of its sub-objects
11:25:20 <CosmicRay> if that makes sense
11:25:36 <CosmicRay> all the completion codes are gathered up and a final success or failure is determined
11:25:51 <CosmicRay> if there is a failure, the error message lists the termination reason for each individual component of the command that was run.
11:26:14 <stepcut> CosmicRay: when you run the ShellCommand, how do you get the output back into your program?
11:26:32 <shapr> bringert: I have my own virtual server for only $15 a month, so I can fix my apache config
11:26:37 <CosmicRay> stepcut: you mean for use with the Haskell functions that things are piped to?
11:26:48 <CosmicRay> (like countLines in the example)
11:27:30 <bringert> shapr: you don't need stuff that's very crazy, so you might have it set up already
11:27:35 * stepcut looks at the examples again
11:28:09 <stepcut> CosmicRay: ok, for this example: run $ ("ls", ["-l"]) -|- ("wc", ["-l"])
11:28:25 <dmhouse> stepcut: is that your shell?
11:28:26 <stepcut> CosmicRay: how do I get the output of 'wc' back into my main program ?
11:28:32 <CosmicRay> ah.
11:28:36 <dmhouse> oh.
11:28:41 <bringert> is there a way to take two existing darcs repos, and put one inside the other, giving only one repo but with patch history for everything?
11:28:43 <CosmicRay> the run command doesn't support that yet
11:28:48 <CosmicRay> though the infrastructure does
11:29:06 <stepcut> CosmicRay: how will that work?
11:29:40 <CosmicRay> stepcut: via hGetContents (or similar), based on an endpoint of a pipe.
11:29:56 <bringert> ah, screw that, I'll just copy it
11:30:00 <stepcut> CosmicRay: how will that interact with the waitForProcess ?
11:30:09 <CosmicRay> stepcut: I have some similar code in MissingH.Cmd
11:30:35 <CosmicRay> stepcut: I will probably have to write my own hGetContents.  After the available data is consumed, it will do a waitForProcess, and if there was an error, raise an exception at that point.
11:31:18 <CosmicRay> alternatively I can return a (PipeHandle, String) tuple to the user and force them to explicitly call a function on the PipeHandle after they have consumed the data.
11:31:18 <psi> dmhouse: can it be solved without the flag to ghc?
11:31:39 <psi> i've been trying to add some annotations but it doesn't help
11:31:41 <dmhouse> psi, i think you can do it by using lets, or something.
11:31:45 <stepcut> CosmicRay: I am going to send you some code
11:31:51 <dmhouse> there is a way of getting around it.
11:32:00 <CosmicRay> stepcut: see http://quux.org/devel/missingh/html/MissingH-Cmd.html#v%3ApipeFrom for something similar
11:33:36 <stepcut> CosmicRay: ok, I sent you some (messy) code that is similar to what you are doing
11:35:02 <CosmicRay> stepcut: great, thanks
11:35:05 <CosmicRay> shapr: how's hdbc coming?
11:35:17 <stepcut> In my code, when you fork off a pipeline you get back a tuple (CheckProcessStatus, String, String), where CheckProcessStatus can be used to do a non-blocking check to see if the pipeline is done. the String, String  are stdout and stderr
11:35:53 <stepcut> CosmicRay: the rest is build on top of that
11:36:17 <stepcut> CosmicRay: there is also a hGetContentsThen -- which runs a IO action after all the content has been read
11:37:19 <stepcut> CosmicRay: and there is this idea of 'guards' which guard a Process. If the process dies, the guard can actually take over for the failed process and the components on either side won't know the difference
11:37:31 <shapr> CosmicRay: It built without static
11:37:32 <stepcut> (though some pipeline data may be lost)
11:37:34 <CosmicRay> shapr: thanks for the references.  hsshellscript looks like some stuff I planned to add to hsh in the future, so I may just bring it in.  and h4sh looks interesting and should be good for some ideas.
11:37:44 <CosmicRay> shapr: ah, good.
11:37:50 <CosmicRay> cool, thanks stepcut.
11:37:50 <shapr> CosmicRay: Also, scsh appears to be the niftiest shell available at the moment.
11:37:56 <shapr> "scheme shell"
11:38:00 <shapr> It'd be good for some ideas.
11:38:14 <stepcut> CosmicRay: and there is an 'ifP' which let's you do if/then/else based on the process return code
11:38:16 <bringert> shapr: I've moved the blob2 and halbum2 modules into Hope now, so before you pull next time, get rid of modules/halbum2 and modules/blob2
11:38:24 <bringert> hi swiert 
11:38:35 <swiert> hi bringert
11:38:56 <CosmicRay> shapr: I'm sort of hoping to design a system that sucks enough less than everything else that the really smart haskell folks and shell designers will send me diffs ;-)
11:39:11 <bringert> swiert: how's your administrativia working out?
11:39:13 <stepcut> CosmicRay: I think there might be some minor bugs in the code still
11:39:18 <jmmv> hmm... been learning Haskell during this semester, loving it so far :)
11:39:49 <dmhouse> jmmv: good! :)
11:39:53 <swiert> bringert: could be worse - although I must admit - I haven't spent much time worrying about it.
11:40:04 <dmhouse> jmmv: what do you like about it?
11:40:10 <swiert> the HW paper and marking exams have been taking up all my time.
11:41:27 <jmmv> dmhouse: hmm... it feels "correct"
11:41:33 <bringert> swiert: is the term over now (= no more teaching for a while)?
11:41:42 <bringert> ours is
11:42:05 <jmmv> dmhouse: (I'm new to functional programming)
11:42:12 <swiert> bringert: yes! The exam marking was more of a favour to Graham anyway.
11:42:14 <dmhouse> jmmv: that's good to know. I loved Haskell at first because it produced such lovely-looking code. What languages do you know already?
11:42:15 <bringert> shapr: thanks for the asian market tip btw
11:42:36 <swiert> bringert: how's the weather in Seattle ;-) ? 
11:42:48 <bringert> swiert: sunny
11:43:06 <bringert> my weather widget says 64 F, but it looks warmer
11:43:06 <toki2_0> rainy here in germany
11:43:07 <stepcut> CosmicRay: oh, also, I have that Pipe data-structure so that you can do things like fmap a guardian over the process tree or something -- but I think sometime is not quite right with the implementation
11:43:10 <jmmv> dmhouse: I've coded a lot in C/C++, Java, Perl, shell scripting... and a tiny bit in Miranda (that was what I was tought at class a month ago)
11:43:13 <bringert> hold on, I'll go outside
11:43:45 <dmhouse> jmmv: ah, cool. I came from PHP so it didn't take much to impress me :)
11:44:08 <jmmv> dmhouse: hehe
11:44:16 <dmhouse> jmmv: Haskell can be a little hard to grok at times, but stick at it, it's extremely rewarding.
11:44:20 <CosmicRay> dmhouse: at least you recognize that ;-)
11:44:41 <bringert> swiert: it's really nice and warm
11:45:01 <swiert> bringert: great. I'm looking forward to coming over.
11:45:10 <bringert> swiert: I saw a University of Washington ad today that said Seattle has some of the best summer weather in the country
11:45:30 <bringert> for some reason they didn't say anything about the weather the rest of the year
11:45:31 <jmmv> dmhouse: I just know very, very few about it yet; only used it to implement a task assignment for a course... but I'm thinking about using it in one of my pet projects which are just ideas at the moment
11:45:43 <swiert> bringert: so I hear.
11:45:51 <dmhouse> jmmv: I'd recommend it :)
11:46:45 <jmmv> dmhouse: although... I've been a oop supporter for a long time; switching my mind now feels "strange" ;)
11:46:59 <CosmicRay> jmmv: isn't it wonderful?
11:47:09 <swiert> bringert: will you be around until July?
11:47:23 <bringert> swiert: yep
11:47:39 <esap> jmmv: OOP and functional programming have very different way of thinking.
11:47:56 <jmmv> CosmicRay: maybe.  can't know for sure until I learn more about haskell
11:48:37 <Lemmih> Has anyone heard from musasabi the last couple of weeks?
11:48:39 <CosmicRay> jmmv: I mean the feeling of getting your head all twisted up
11:48:45 <CosmicRay> jmmv: haskell is just *that different*
11:48:50 <CosmicRay> jmmv: I like being blown away by things.
11:48:53 <dmhouse> jmmv: it's worth learning, then, just to get the different perspective on things.
11:48:56 <shapr> bringert: The Catwalk is an interesting club, but, um, may not be your style.
11:49:05 <swiert> bringert: what's Angela working on btw?
11:49:07 <jmmv> CosmicRay: I think that's why I like it so far :)
11:49:30 <bringert> swiert: Boogie / Spec# stuff
11:50:06 <swiert> bringert: do you believe in that stuff?
11:50:15 <bringert> shapr: some online reviews: "Too much attitude for this covercharge. Major posing joint with not a lot of good intentions abound. The decor IS nice though, but they aren't even open on a regular schedule. If this, and their prices change MAYBE, but overall it's low on the ladder of places to explore."
11:50:19 <monochrom> If you have only known English, then even getting to know a few Chinese words unmakes many of your presumptions.
11:50:30 <bringert> shapr: "Girl4Girl was some of the most fun I've ever had (and I'm not even a lesbian). "
11:50:59 <bringert> swiert: which stuff? proving properties about object-oriented programs?
11:51:17 <bringert> shapr: it seems to be out of business
11:51:20 <shapr> bringert: They played Rammstein and NIN on three meter tall speakers and I danced for hours. I liked it.
11:51:23 <shapr> bringert: Ah, too bad.
11:51:36 <bringert> shapr: sounds good
11:51:43 <monochrom> Just last night I brought to the attention of someone that there is a Chinese character for "cup" and it applies to all of what an English person would carefully distinguish as "glass", "cup", "mug".
11:52:09 <jmmv> dmhouse: hmm, are you related to the house os in some way?
11:52:23 <alar> CosmicRay: epigram papers make me feel my head twisted for a long time :) Haskell was lower, but considerable danger to my sanity
11:52:29 <dmhouse> jmmv: afraid not, 'House' just happens to be my surname.
11:52:43 <jmmv> dmhouse: ah, ok
11:52:47 <shapr> monochrom: I like that. I've never thought the differences were meaningful.
11:52:47 <dmhouse> hehe.
11:53:22 <alar> monochrom: do you know that Eskimo language has 19 words meaning "snow"?
11:53:34 <monochrom> Yeah I've heard of that.
11:53:44 <BCoppens> I heard that that was not true
11:53:53 <swiert> bringert: yes - I remember a bit about ESC/Java, Spec#, etc. being either unsound or incomplete and possibly both.
11:53:56 * BCoppens read that in a language FAQ, let me look for it
11:54:06 <shapr> English has that many word to describe snow too... ever heard of crunchy, mushy, etc for describing ski conditions at Aspen?
11:54:23 <alar> shapr: nouns
11:54:24 <Maddas> alar: Did you read http://itre.cis.upenn.edu/~myl/languagelog/archives/000405.html ? :-)
11:54:34 * stepcut has 19 works for snow
11:54:34 <shapr> alar: Hey, you didn't specify.
11:54:39 <bringert> swiert: I can't say I've studied it a lot. I think they are very pragmatic, they want to catch bugs
11:54:47 <BCoppens> http://www.zompist.com/lang16.html
11:54:50 <stepcut> sleet, hail, powered, etc
11:54:51 <BCoppens> alar: ^
11:54:55 <stepcut> powdered  :)
11:55:25 <shapr> bringert: You seem to have put the Read/deriving bug back into the repo
11:55:42 <bringert> damit
11:55:54 <Maddas> alar: Also, I can construct you far more german compound nouns than 19 (:
11:55:54 <vincenz> Anyone know how to show ~ character in latex?
11:56:01 * shapr betatests furiously
11:56:05 <swiert> bringert: that was the impression I got as well.
11:56:14 <stepcut> vincenz: \~ does not work ?
11:56:31 <alar> ah, that was nonsence: I can construct a lot of words from one root, because not only nouns were counted in those 19 
11:56:37 <alar> :(
11:56:41 <alar> .  
11:56:44 <Maddas> alar: (:
11:56:44 <swiert> vincenz: \sim
11:56:46 * alar was fooled
11:57:00 <vincenz> swiert: does that even work inside \texttt ?
11:57:16 <bringert> shapr: thanks, fixed
11:57:30 <bringert> shapr: I forgot to pull that before moving halbum2 into hope
11:57:39 <Maddas> Which isn't to say that there aren't interesting differences, of course. In Japanese, for example, one doesn't distinguish between blue and green (AFAIK, of course).
11:57:44 <swiert> vincenz: do you want a tt ~? Maybe you should use verb/verbatim...
11:57:46 <bringert> http://en.wikipedia.org/wiki/Sapir-Whorf_hypothesis
11:57:46 <alar> Maddas: afaik german does not have limit on the length of a noun, and allows easy construction of them :)
11:57:59 <Maddas> alar: Yeah, that's why I could do it ;-)
11:58:02 <jmmv> biaf
11:58:18 <shapr> English has time for both tid (time) and gång (occasion). I think that's an interesting difference.
11:58:20 <bringert> see http://en.wikipedia.org/wiki/Sapir-Whorf_hypothesis#Linguistic_determinism for the eskimo snow thing
11:58:41 <monochrom> The Sapir-Whorf hypothesis does not apply to people with IQ > 150 :)
11:58:51 <vincenz> swiert: doesn't work
11:59:41 <shapr> Swedish has bär for "carry, wear" and "berry" where English has "berry" and "bear fruit". That leads me to think that berry was originally "beary" or something.
11:59:59 <shapr> bringert: It builds!
12:00:10 <Maddas> monochrom: please define the scale by which you are measuring :-)
12:00:25 <bringert> shapr: have you ever gotten it to run?
12:00:33 <shapr> In my experience, lojban is good for doing tests of the Sapir-Whorf hypothesis in your own head.
12:00:38 <shapr> bringert: Dunno, trying now...
12:00:47 <LPhas> Hi, i've a problem
12:01:07 <LPhas> i've two ghc threads wich are doying their buisness
12:01:19 <shapr> bringert: What should be in hopeBase?
12:01:35 <LPhas> i need that one of them can signal an event to the other
12:01:38 <norpan> shapr: you say "bära frukt" in swedish too
12:01:53 <bringert> the URL of the directory where you put hope.cgi / hope.fcgi
12:02:03 <LPhas> wich activate a callback
12:02:08 <shapr> norpan: Right, the similarities imply that English originally was the same.
12:02:08 <bringert> shape: i.e. the root url that you want for Hope
12:02:12 <LPhas> then go back to it's job
12:02:14 <shapr> bringert: ok
12:02:21 <swiert> vincenz: \begin{verbatim} ~ \end{verbatim} works for me
12:02:30 <monochrom> Maddas: That's easy.  One's IQ is 100/"average number of times one has to be told something before one listens".
12:02:40 <LPhas> pratically i need something like signals for thrads
12:02:51 <Maddas> monochrom: *laugh*
12:03:03 <norpan> shapr: more probable that both english words come from ancient nordic
12:03:10 <monochrom> It can be bigger than 100 because the smart people just need a hint.
12:03:21 <Maddas> monochrom: What if I give up after the second time, does that at least let me keep 50 or does my IQ instantly drop to 0?
12:03:32 <norpan> shapr: the "bär" present tense is probably more modern
12:03:45 <monochrom> Dunno.  Details details... :)
12:03:49 <Maddas> (:
12:05:01 <shapr> norpan: Like I said, they were the same. English is a mishmash, it's possible the words were borrowed hundreds of years apart.
12:05:16 <norpan> yes
12:06:14 <shapr> hm, hdbc must have different connection options.
12:06:44 <dmhouse> wow, ftp (the linux program) is really rubbish.
12:06:45 <esap> Maybe this linguistic determinism can be used to show that programming languages restrict the way people think.
12:06:56 <Maddas> esap: http://en.wikipedia.org/wiki/Sapir-Whorf_and_programming_languages
12:07:00 <dmhouse> it, err... doesn't support directories :)
12:07:06 * esap is reading it.
12:07:52 * esap finds it doesn't exist :-)
12:07:55 <Maddas> esap: Strikes me as a rather obvious observation, though (:
12:08:01 <stepcut> dmhouse: I think I used to use ncftp or something, back in the day
12:08:10 <dmhouse> stepcut: same problem with ncftp.
12:08:12 <monochrom> I wouldn't say programming languages restrict minds.  I would say minds are tempted to restrict themselves to programming languages.
12:08:19 <shapr> Yeah, true.
12:08:26 <shapr> But programming languages can force your mind to expand.
12:08:30 <shapr> Haskell is good example of that.
12:08:41 <Maddas> Only if you force yourself to learn them :-)
12:08:41 <esap> monochrom: True. People restrict their thinking based on programming languages.
12:08:57 <shapr> It's true that C programmers have a very hard time understanding continuations and coroutines, and only because they've never lived without a stack that unwinds.
12:08:59 <Maddas> To me, programming languages are just tools, albeit powerful ones
12:09:05 <Maddas> (e.g. ways of thinking)
12:09:35 * alar does not understand continuations and does not know what are coroutines
12:09:42 <Maddas> alar: Perfect time to learn!
12:09:57 <alar> Maddas: what's coroutine?
12:10:01 <monochrom> People like to be lazy in thinking.  People like presumptions.  What you do then is to bombard them with so many different languages that their presumptions are demolished.
12:10:07 <Maddas> shapr: Actually, our other professor introduced coroutines in the context of assembly programming. He said people don't use them anymore since one doesn't program that way in assembly anymore
12:10:29 <shapr> Coroutines make a lot of sense in asm.
12:10:35 <esap> alar: Coroutines are like subroutines, except that the routines are symmetric with respect to each other.
12:10:53 <alar> esap: do you mean mutul recursion?
12:10:59 <esap> alar: no
12:11:03 <shapr> alar: Consider a function that does not return, but instead calls another function.
12:11:18 <shapr> bringert: createdb: user error (SQL error: SqlError {seState = "", seNativeError = 1, seErrorMsg = "connectPostgreSQL: invalid connection option \"server\"\n"})
12:11:29 <bringert> grr
12:11:42 <esap> alar: think of two coroutines such that both have distinct stack. Coroutine jump can transfer control from one to the other.
12:11:45 <bringert> I don't have PostgreSQL handy
12:11:49 <shapr> I'm reading docs...
12:12:03 <esap> alar: the stack is not important in corouting jumps.
12:12:13 <alar> shapr: does that "does not return" means "return another function applied to something"?
12:12:33 <Maddas> alar: GOTO never returns, for example (:
12:12:41 <shapr> alar: No, I mean "Redefine 'function call' to mean GOTO as used in asm".
12:12:55 <shapr> In that case, functions don't have a stack to unwind.
12:13:08 <shapr> You never return, you only wind forward.
12:13:12 <alar> Maddas: but GOTO entry/exit points does not delimit "routines" most of the time
12:13:26 <alar> oh
12:13:30 <Maddas> alar: I merely used it as an example for a jump that doesn't return
12:13:46 <alar> then coroutines are explained in imperative way?
12:13:48 <shapr> So, coroutines are two functions that call each other in that way. It's the simplest form of threading.
12:14:03 <alar> is there functional wy to define them?
12:14:25 <shapr> The FP way would be the same except that you'd probably use CPS instead.
12:14:29 <Maddas> (Does CALL/CC count as something imperative?)
12:14:30 <esap> alar: There is a functional way, but it's pretty difficult stuff
12:14:31 <shapr> CPS is the next step.
12:14:41 <shapr> Instead of having the "next function to call" defined ahead of time...
12:14:42 <alar> shapr: what's so special about them if they are just form of threading
12:14:46 <alar> ?
12:14:54 <monochrom> If I have: xs = 1:ys; ys = 2:xs.  Can I call this a pair of coroutines?
12:14:57 <Maddas> alar: They aren't just a form of threading. You can use them to implement a form of threading
12:14:58 <shapr> Pass in the "next function to call" as an argument.
12:15:12 <shapr> At that point you can make any other form of control flow.
12:15:14 * monochrom likes the rewriting way of looking at execution.  No stack no PC no nothing.
12:15:27 <shapr> alar: Most C programmers can't get past the "no stack to unwind" part.
12:15:37 <shapr> At least, not quickly.
12:15:45 <alar> monochrom: I would call this lazy mutual recursion
12:15:52 <Maddas> shapr: To be fair, I think most programmers can't :-)
12:16:02 <alar> ah
12:16:11 * alar is happy of not being C programmer
12:16:20 <monochrom> Let's say we have xs = 1:ys; ys = 2:xs in an eager language.
12:16:24 * Maddas is happy to know some C
12:16:24 <shapr> Because of that, I suspect that laziness is just as easy to use as strictness, but has a similar cultural problem.
12:16:25 * alar is more asm programmer than anything else
12:16:35 <shapr> Same for monads.
12:16:49 <monochrom> YES!
12:16:52 <shapr> Well, monads are easier than OOP.
12:17:07 <Maddas> I think it's a cultural difference.
12:17:26 <alar> yes, lazyness was the problem for me, I'm not sure I can exploit full power of it even now
12:18:24 <shapr> I think the original thinkers are rare, those who can see how to use a new ability to do stuff. But once they write down best practices, the rest of us can use it too.
12:18:25 <alar> stack passing of data/flow control is just one of possible conventions for asm programmer :)
12:18:40 <shapr> Thus I wait for people like Cale to write about "Laziness for improved modularity" :-)
12:19:12 <monochrom> I am weary of the phrase "best practices".  It invariably refers to inferior practices.
12:19:28 <shapr> On the good side, we all have creative ideas, so if we distribute them to others the good discoveries catch on.
12:19:40 <Maddas> I think the problem isn't original thinking, but investing enough effort to popularize good ideas :)
12:19:45 <shapr> monochrom: Well, call it what you will, it just means getting the good discoveries popularized.
12:20:05 <Maddas> (Well, the combination of both)
12:20:45 <esap> "best practices" is to me like a contradiction in terms. Best and practice are mutually exclusive :-)
12:20:50 <monochrom> I suppose I just mean people outside abused the word.  It's now second to "technology".
12:21:22 * Maddas grins
12:21:33 <norpan> best practises is "make sure you can blame someone else"
12:21:47 <alar> :))
12:21:48 <esap> "Practice" means an average programmer can understand it. "Best" means the average programmer cannot.
12:22:08 <monochrom> You must have heard of "OOP techonology" or the like.  Have you also heard of "while-loop technology"?  http://www.vex.net/~trebla/humour/book_for_sale.html
12:22:36 <shapr> norpan: You know about Acceptable Ways of Failing ?
12:23:20 <shapr> US from Sweden is 001 yeah?
12:23:39 <Maddas> monochrom: haha!"inventor of (...) the dining philosopher problem" -- as if we didn't have enough already! (:
12:23:51 <monochrom> haha
12:24:34 <norpan> shapr: yes
12:25:04 <norpan> previously it was 0091 but if you dial that nowadays you get to india :)
12:25:10 <shapr> hah
12:25:29 <Maddas> norpan: so they didn't have to change tech support numbers (:
12:25:29 <monochrom> esap: I think for an average programmer to practice something, there is no precondition of understanding.
12:25:53 <norpan> i actually made that mistake once, because the caller id was set wrongly
12:26:00 <norpan> so it showed 0091
12:26:14 * shapr wonders if SyntaxNinja got his SMS
12:26:26 <norpan> Maddas: exactly what i thought too
12:26:37 <esap> monochrom: I don't mean any deep understanding, only understanding of what (as opposed to why)
12:26:41 <norpan> on a mobile phone you do +1 though
12:26:45 <monochrom> The ratio of "practice OOP":"understand OOP" is even larger than that of "Darjeeling sold":"Darjeeling grown"
12:26:49 <norpan> although 001 should work
12:27:18 <esap> I think very few people really understand OOP.
12:27:32 <shapr> It's not that hard though.
12:27:41 <shapr> It is picky, admittedly.
12:27:46 <shapr> Cardelli's work helps, imho.
12:28:18 <shapr> I prefer prototype oriented, it's easier.
12:28:52 <norpan> i have some stories about people using oop the completely wrong way
12:29:06 <shapr> me too
12:29:17 <norpan> and these are not stupid people
12:29:25 <esap> me too. Some people try to write application in OOP style. Bound to fail.
12:29:33 <esap> s/application/applications/
12:30:31 <esap> Because OOP cannot really be made to satisfy customer's requirements.
12:30:35 <MarcWeber> How can I specify an absolute path in an ant unzip target? <anzip src="relativ to base" dest="absolut"> ?
12:30:39 <shapr> bringert: aha: host, dbname, user
12:30:47 <bringert> heh
12:31:15 <shapr> Does createdb create the database if it doesn't exist?
12:31:24 <esap> What OOP does, it provides very general-purpose stuff, which is very good for your average platform. But it's not good for the application side of things.
12:31:25 <shapr> hm, seems so
12:31:25 <bringert> shapr: no, not the database
12:31:28 <shapr> oh?
12:31:38 <bringert> shapr: afaik
12:31:42 <bringert> maybe it does
12:32:49 <bringert> shapr: I'm looking at the code, it doesn't seem to create the database
12:32:58 <shapr> Seems to have worked anyway.
12:33:11 <shapr> That's cool... mysterious functionality.
12:33:24 <shapr> That's significantly less common than mysterious dysfunctionality.
12:33:28 <monochrom> Miraculous.
12:34:28 <norpan> unsafePerformMiracles
12:34:41 <monochrom> Err how is that unsafe...
12:34:51 <norpan> it may not always succeed?
12:35:12 <monochrom> Miracles always succeed.  Definition.
12:35:35 <monochrom> Perhaps it should be called unsafeAttemptMiracles ?
12:35:38 <norpan> noinstance MonadPlus Miracles
12:37:02 <norpan> *** Exception: Miracles can't fail
12:37:11 <monochrom> hahahaha
12:40:37 <shapr> wow, hope.cgi: internal error: update_fwd: unknown/strange object  57
12:41:25 <monochrom> 57 is a strange number
12:42:32 <norpan> i vaguely recall seeing 57 somewhere else
12:42:38 <norpan> so it's not completely strange
12:42:44 <dcoutts_> after 56?
12:42:54 <norpan> dcoutts_: yes, there somewhere
12:43:29 <norpan> also on my parent's mailbox
12:43:40 <bringert> shapr: hehe, nice. I've seen that before, when I have updated some library and not completely recompiled everything that uses it
12:43:43 <norpan> parents'
12:44:19 <bringert> ghc doesn't think that an updated library warrants recompiling code that uses it
12:45:28 * shapr rebuilds
12:47:20 <bringert> shapr: it could be that you have to rebuild hawl too, or newcgi, or one of the other 1000 dependencies
12:47:26 <shapr> oh yeah
12:47:26 <shapr> crap
12:47:37 <shapr> I really need cabal-get.
12:47:41 <bringert> it sucks, I know
12:47:53 <shapr> Now I have to remember all the deps...
12:48:06 <shapr> Or I could unregister all the packages and do it that way.
12:48:34 <bringert> remember that when you reinstall them, they may have to be recompiled from scratch
12:49:48 <shapr> right
12:53:54 <shapr> Now I wish I had HSH handy.
12:54:23 <shapr> I could map over rm -rf **/*.{o,hi} && darcs pull -a && runghc Setup.hs configure && runghc Setup.hs build
12:56:02 <CosmicRay> heh
13:00:50 <shapr> bringert: Same error :-(
13:01:03 <bringert> :-(
13:02:13 <shapr> I did sequence_ [darcs pull,build,install] [newcgi, gd, exif, hawl, parsedate, hope]
13:02:27 <shapr> oh, and rm -rf **/*.{o,hi} before that.
13:02:29 <shapr> Any ideas?
13:02:44 <LordBrain> Does anyone here use the experimental haskell debian repository?
13:02:45 <bringert> fps?
13:02:52 <shapr> oh, no...
13:02:56 <shapr> LordBrain: I use it
13:02:57 <bringert> do you have the latest version?
13:03:01 <LordBrain> at alioth.debian.org ?
13:03:13 <shapr> bringert: Um, several days back
13:03:20 <LordBrain> shapr.. what exactly do you enter in your sources.list.. i keep having trouble
13:03:46 <bringert> hmm, maybe try the latest, and rebuild newcgi, hawl and hope
13:03:47 <shapr> deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable
13:03:52 <LordBrain> ah
13:03:54 <LordBrain> thanks
13:03:56 <shapr> sure, np
13:04:00 <monochrom> hawl and hope? plug and pray?
13:04:10 <bringert> shapr: sorry about all this
13:04:21 <bringert> shapr: I'm off for lunch, good luck
13:04:41 <SyntaxNinja> shapr: I got your msg!
13:05:32 <shapr> SyntaxNinja: yay!
13:05:39 <shapr> bringert: have fun, I hope the latest fps fixes this.
13:06:45 * palomer has survived the upgrade
13:06:56 <dmhouse> palomer: congrats :)
13:08:29 <hyrax42> @hoogle (a -> m b) -> [a] -> m ()
13:08:30 <lambdabot> No matches, try a more general search
13:08:47 <monochrom> what did you upgrade, palomer ?
13:08:48 <hyrax42> @hoogle (a -> m b) -> [a] -> m [b]
13:08:49 <lambdabot> No matches, try a more general search
13:09:00 <hyrax42> oops
13:09:25 <monochrom> Yuck.  sequence_ and sequence are what you want, but they bear the (Monad m) constraints.
13:09:32 <hyrax42> yeah
13:09:42 <hyrax42> I thought it was sequence
13:09:44 <hyrax42> thanks
13:10:03 <monochrom> Still, a shortcoming of hoogle we are seeing.
13:10:15 <monochrom> Or at least a shortcoming of @hoogle
13:10:27 <hyrax42> well I was lazy
13:10:30 * monochrom > hoogle
13:10:31 <hyrax42> I thought it would pick up the m
13:10:57 <hyrax42> and assume (Monad m) =>
13:11:05 <monochrom> Next time try @human :)
13:11:08 <hyrax42> maybe that's a worthy addition to either hoogle or the plugin
13:11:13 <hyrax42> heh
13:11:27 <monochrom> Yah definition.  This has occured a million times.
13:12:07 <monochrom> err s/definition/definitely/   # reading too many math papers
13:12:14 <hyrax42> haha
13:12:32 <hyrax42> the channel was obscured up to the t
13:12:37 <hyrax42> I assumed definitely
13:12:39 <hyrax42> *channel window
13:12:45 <apfelmus> monochrom: it's a plugin issue, hoogle returns 293 entries... should need some clever sorting
13:12:54 <monochrom> interesting
13:13:55 <monochrom> In the meantime, wouldn't it make more sense to report "too many matches, try a more specific search"?
13:13:59 <hyrax42> ok I have a question
13:14:08 <hyrax42> I have read e.g. in the tim sweeny slides on next language
13:14:17 <hyrax42> of using type system to restrict ranges of values
13:14:30 <hyrax42> e.g. integers in a range
13:14:36 <hyrax42> or elements of a finite set
13:15:00 <apfelmus> hyrax42: you mean dependent types, right?
13:15:03 <hyrax42> but haven't seen anything like it
13:15:06 <shapr> bringert: same error :-(
13:15:11 <hyrax42> apfelmus: maybe
13:15:17 <hyrax42> @google haskell dependent types
13:15:19 <lambdabot> http://okmij.org/ftp/Haskell/types.html
13:15:41 * shapr grumbles
13:17:22 <araujo> hello
13:17:24 <apfelmus> hyrax42: so what's the question ? :-)
13:17:33 <hyrax42> oh
13:17:38 <hyrax42> woops
13:17:43 <LordBrain> shapr: you ever use this archive with debian stable?
13:17:49 <hyrax42> a) possible? b) how?
13:17:56 <hyrax42> (looking at wiki now
13:18:50 <LordBrain> shapr.. i changed your unstable to stable.. and it seemed to work fine.. but i'm under the impression that there is a more recent version of ghc backported to stable in this archive and yet it is not upgrading with the command "apt-get install ghc6"
13:19:15 <SM_ax> are there any darcs experts?
13:19:38 <dmhouse> SM_ax: you could Just Ask, or try #darcs.
13:19:45 <monochrom> Not very possible in Haskell.
13:20:33 <hyrax42> monochrom: to me?
13:20:47 <monochrom> Yes.
13:20:57 --- mode: ChanServ set +o vincenz
13:21:18 <hyrax42> oh
13:21:25 <hyrax42> are they coming?
13:21:43 <SM_ax> easy Q: darcs push reports conflicts and suggests usage of "--mark-conflicts", but there is no such option in darcs or darcs push...
13:22:58 <hyrax42> anyway, it was just to try and catch a type of error that it'd be nice to outsource to the type system
13:24:37 <apfelmus> hyrax42: well, one can do quite a lot by faking them with functional dependencies. besides that, GADTs offer even more. epigram is more radical, more info under http://haskell.org/haskellwiki/Research_papers/Type_systems#Dependent_Types
13:24:45 <monochrom> Definition.  "Impossible" means there is an impossibility proof, e.g., "Haskell program to detect non-termination - impossible".  "Not very possible" means: if there is a way, only Oleg knows it. :)
13:25:34 <monochrom> Thus there is a class of Oleg-complete problems.
13:25:44 <hyrax42> haha
13:25:52 <LordBrain> lol
13:26:04 <hyrax42> so judging by the state of things, it's not coming in haskell' either
13:26:33 <kosmikus> bringert: ping
13:26:40 <hyrax42> and there are currently no ghc (or other) extensions that do it
13:26:57 <tic> ja isch
13:28:02 <apfelmus> hyrax42: mh, fake them like in http://haskell.org/hawiki/SimulatingDependentTypes. it's very useful indeed
13:29:27 <kosmikus> hyrax42: it's easy to say "I want dependent types for Haskell", but quite difficult to come up with a good design.
13:29:57 <hyrax42> kosmikus: oh I absolutely believe it
13:30:16 <hyrax42> just not aware of the state of research etc.
13:30:19 <dcoutts_> hyrax42, ever tried coding in epigram?
13:30:22 <kosmikus> so, if you tell us how to do it, then maybe someone will go ahead and implement them ;)
13:30:34 <hyrax42> dcoutts_: nope
13:30:47 <dcoutts_> hyrax42, it might change your opinion ;-)
13:30:48 <kosmikus> hyrax42: ok, you should have a look at epigram, agda, and coq
13:31:05 <hyrax42> dcoutts_: as in, I won't want them anymore?
13:31:23 <apfelmus> hyrax42: i remember some slides from John Hughes regarding dep types in haskell
13:31:25 <kosmikus> hyrax42: three systems that have dependent types and allow programming
13:31:39 <apfelmus> @google Dependent Types in Haskell John Hughes
13:31:41 <lambdabot> http://www.haskell.org/haskellwiki/Dependent_type
13:31:47 <hyrax42> apfelmus: yeah, I just flicked through them
13:31:50 <dcoutts_> hyrax42, they're great for coding nifty stuff and being totally assured of their correctness, however hacking in these languages is very very hard.
13:32:09 <hyrax42> ok
13:32:20 <hyrax42> well I'll investigate later
13:32:20 <dcoutts_> precisely because you do have to prove everything
13:32:25 <hyrax42> hm
13:32:40 * hyrax42 not too big on type theory at all
13:32:41 <kzm_> anybody use nmergeIO?
13:32:47 * hyrax42 thinks that'd be hard
13:33:33 <apfelmus> dcoutts_: well, epigram is still in it's infancy. i find the interactivity more a pain than a gain (you don't have a plan what to start with...)
13:34:03 <kzm_> What is the idiomatic way to force evaluation of a list's elements to WHNF?
13:34:20 * kzm_ doesn't think "map seq" will quite work :-)
13:35:01 <monochrom> the list to WHNF, or every element to WHNF?
13:35:05 <norpan> you want each element to be whnf?
13:35:29 <kzm_> every element, yes.
13:35:39 <kzm_> foldr ((:).seq)?
13:35:40 <apfelmus> > foldl1 seq [1,2,3,undefined]
13:35:41 <lambdabot>  Undefined
13:36:06 <norpan> my standard way is seq (length (show x))
13:36:14 <dcoutts_> heh
13:36:14 <norpan> that will evaluate everything though
13:36:29 <apfelmus> > length $ foldl1 (uncurry snd) [1,2,3,undefined]
13:36:30 <lambdabot>  Couldn't match `(a, b)' against `[a1]'
13:36:45 <apfelmus> @type uncurry
13:36:46 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
13:36:59 <apfelmus> length $ foldl1 (curry snd) [1,2,3,undefined]
13:37:11 <apfelmus> > length $ foldl1 (uncurry snd) [1,2,3,undefined]
13:37:11 <lambdabot>  Couldn't match `(a, b)' against `[a1]'
13:37:27 <apfelmus> > length $ foldl1 (curry snd) [1,2,3,undefined] -- ahem
13:37:28 <lambdabot>  add an instance declaration for (Num [a])
13:37:28 <lambdabot>   In the list element: 3
13:37:58 <apfelmus> @type curry snd
13:37:59 <lambdabot> forall a b. a -> b -> b
13:38:19 <apfelmus> @type foldl1
13:38:19 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
13:38:46 <kzm_> I'm trying to split up a list to evaluate in parallel.  Everything works, except n-1 of the threads. :-)
13:39:24 <Maddas> heh :-)
13:39:33 <kzm_> I think it is due to laziness - the processing is essentially a map, so the worker threads only evaluate list spines to the main program - which then must do all the heavy lifting itself.
13:39:55 <kzm_> It's my first attempt at parallelism, so I may be wrong, of course.
13:40:27 <SamB> so, you need more strictness
13:40:35 <SamB> @hoogle deepSeq
13:40:36 <lambdabot> No matches found
13:40:39 <SamB> @hoogle seq
13:40:40 <lambdabot> Prelude.seq :: a -> b -> b
13:40:40 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
13:40:40 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
13:40:46 <SamB> @hoogle deepseq
13:40:47 <lambdabot> No matches found
13:41:08 <kzm_> I guess I can do something like "foldr1 seq list `seq` list", but I don't want the threads to generate the full list before returning anything.
13:41:15 <kzm_> I want them a *bit* lazy.
13:41:50 <dmhouse> je suis rentré.
13:42:33 <apfelmus> kzm_: you want a thread for every list element? (so you mean the elements are pretty expensive)
13:42:34 * dmhouse wishes konsole had better dumbass-detection. No, I didn't mean to close irssi.
13:42:50 <bringert> shapr, kosmikus: I'm back from lunch
13:42:53 <bringert> what's up
13:43:17 <shapr> Same error after rebuilding with the new bytesting
13:43:28 <bringert> grr
13:43:51 <shapr> That is, I rebuilt hawl, newcgi, and hope after BS
13:43:53 <bringert> I think I have seen that before, and I think rebuilding everything solved
13:44:22 <shapr> Maybe I should have done Setup clean instead of rm -rf **/*.{o,hi} ?
13:44:30 <bringert> yes
13:44:37 <shapr> Ok, I'll try it again.
13:44:42 <bringert> you need to re-run cabal configure too
13:44:44 <shapr> After some pyttipana
13:45:02 <bringert> kosmikus: pong
13:45:04 <shapr> I got this big black iron pan a few weeks ago and I've suddenly developed a love of frying stuff.
13:45:12 <shapr> I had no idea cooking could be so easy.
13:45:15 <kzm_> apfelmus, no, I've implemented machinery that splits the input into N lists, and assign a thread to each.
13:46:12 * kzm_ is just waiting for shapr to discover microwave ovens. :-)
13:46:13 <apfelmus> kzm_: so the input is? and you want the N lists completely done by the threads, right?
13:46:13 <shapr> Any advice for fun things to cook/fry?
13:46:23 <shapr> kzm_: Nah, that's not as much fun.
13:46:37 <bringert> shapr: hedgehogs
13:46:41 <kzm_> golf balls, CDs, grapes.  No wait, those are for MWs.
13:46:43 <shapr> Any Linux phones that are worthwhile? I'd like something totally OSS if possible.
13:46:43 <dmhouse> shapr, got any scandinavian recipes for the rest of us to try?
13:46:46 <shapr> bringert: Seriously?
13:46:52 <shapr> dmhouse: Pyttipanna! It rocks!
13:46:54 <bringert> shapr: no
13:46:57 <apfelmus> shapr: gum candy in microwave ovens (hehehe...)
13:47:00 <dmhouse> shapr: what's that?
13:47:10 <shapr> It's the fried equivalent of pizza, sort of.
13:47:24 <dmhouse> weird.
13:47:25 <kzm_> I don't think you should cook Linux phones in your microwave oven, shapr.
13:47:28 <shapr> :-P
13:47:59 * dmhouse wishes lambdabot's @remember was working
13:48:02 <dmhouse> @localtime dons
13:48:03 <shapr> dmhouse: http://en.wikipedia.org/wiki/Pyttipanna
13:48:04 <lambdabot> Local time for dons is Wed Jun  7 06:39:40 2006
13:48:22 <kzm_> apfelmus, I want the threads to deliver evaluated list elements.  But not evalulate all elements before starting to return stuff.
13:48:34 <kzm_> In a way, one thread per list element would be a lot easier :-)
13:48:43 <shapr> dmhouse: It's *way* tasty.
13:48:52 <shapr> dmhouse: I recommend the Findus brand of Pyttipanna.
13:49:00 <shapr> Dunno if they sell it in the USA though.
13:49:05 * shapr goes off to fry
13:49:12 <kzm_> isn't it just potatoes and sausage or something stir-fried?
13:50:18 <dmhouse> shapr, I'm England-based. Not that I've heard of it anyway :)
13:52:33 <kzm_> I think this is the solution:
13:52:36 <kzm_> foldr (\x xs -> x `seq` (x:xs)) []
13:52:46 <kzm_> To wit:
13:52:57 <bringert> dmhouse: try Ikea
13:53:06 <kzm_> let x = [1,2,undefined,4] in x!!3
13:53:09 <dmhouse> bringert: hmm... they sell food?
13:53:12 <kzm_> > let x = [1,2,undefined,4] in x!!3
13:53:14 <lambdabot>  4
13:53:17 <bringert> yes, Swedish food
13:53:22 <dmhouse> kzm_: 0-based.
13:53:28 <kzm_> > let x = foldr (\x xs -> x `seq` (x:xs)) [] [1,2,undefined,4] in x!!3
13:53:30 <lambdabot>  Undefined
13:53:30 <bringert> at least some of the Ikeas abroad do that
13:53:33 <kzm_> Hah!
13:54:23 <dmhouse> kzm_: that's deepSeq
13:54:32 <kzm_> Is it?
13:54:40 <kzm_> Isn't deepSeq...er, deeper?
13:54:46 <dmhouse> your strictifying fold, is, yeah.
13:54:48 <dmhouse> i think.
13:55:00 <kzm_> And more general?  In a class?
13:55:04 * kzm_ shrugs.
13:55:05 <apfelmus> @pl \x xs -> x `seq` (x:xs)
13:55:06 <lambdabot> liftM2 (.) seq (:)
13:55:09 <dmhouse> sure, but on lists, i think it's that.
13:55:15 <apfelmus> @type liftM2
13:55:16 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:55:23 <kzm_> I can reinvent wheels as round as the next guy, I guess :-)
13:55:41 <kzm_> ..as the next guy's wheel, that is.  Present company excepted, and all that :-)
13:56:18 <kzm_> @pl liftM2 (seq . (:))
13:56:20 <lambdabot> liftM2 (seq . (:))
13:56:33 <kzm_> Hmm..to quick there.
13:57:09 <apfelmus> kzm_: i looked for something freakier than \x xs -> x `seq` (x:xs) ;-)
14:00:10 <kzm_> So - where *is* deepSeq?
14:01:14 <dmhouse> kzm_, it's not in haskell 98
14:01:22 <dmhouse> http://hackage.haskell.org/trac/haskell-prime/ticket/106
14:02:26 <dmhouse> hmm... the Haskell Communities and Activities Report is a bit overdue, isn't it?
14:07:47 <int-e> kzm_: hmm, try http://urchin.earth.li/icfpcontest/2004/sub/tools/shared/DeepSeq.lhs ?
14:08:19 <Lemmih> @index rnf
14:08:20 <lambdabot> Control.Parallel.Strategies
14:08:52 <kzm_> I'm getting some...numbers here now, but they don't make much sense.  To me.  At this point.
14:09:20 <kzm_> I got some other stuff I must do before going to bed, perhaps it'll make sense in the morning.
14:09:23 <kzm_> Night everybody.
14:10:03 <int-e> Lemmih: interesting, thanks
14:28:38 <shapr> mmm, pyttipanna
14:30:25 <psi> I never eat that nowadays. It was served often in school, though.
14:33:06 <psi> I don't think I've eaten blodpudding since, either :)
14:35:39 <psi> shapr: have you eaten blodpudding? does it exist in the the U.S.?
14:37:03 <shapr> Yup, it exists. Haven't eaten it though.
14:37:43 <psi> do you know of a common food over there that we don't have here?
14:37:49 <shapr> Peanut butter.
14:37:54 <shapr> Marshmallows
14:38:03 <shapr> Those are both here now, but they're hard to find.
14:38:13 <Lemmih> here=sweden?
14:38:16 <psi> marshmallows are pretty common, aren't they?
14:38:16 <shapr> yup
14:38:24 <shapr> psi: You live in the big city :-P
14:38:26 <psi> I had many today :)
14:39:19 <psi> I've never tried peanut butter
14:40:38 <dmhouse> peanut butter is disgusting.
14:40:57 <shapr> I love it.
14:40:59 <dmhouse> worst sandwich filling ever. Closely followed by chocolate spread.
14:41:02 <Lemmih> So do I.
14:41:14 <dmhouse> Marmite, on the other hand, there's a real filling. :)
14:41:55 <psi> shapr: do you know messmr?
14:43:37 <hyrax42> yay my dfa works
14:43:56 <psi> normal butter is what's disgusting
14:44:05 <hyrax42> dmhouse: mmmm marmite
14:44:08 <psi> I'm always appaled by how much people put in their sandwiches
14:44:13 <psi> on*
14:44:58 <shapr> psi: No, what is it?
14:45:14 <hyrax42> next to try an nfa I suppose
14:45:15 <shapr> Mame thingy?
14:45:17 <dmhouse> psi, heretic!
14:45:18 <hyrax42> souldn't be too big a chnage
14:45:20 <Squeeg> Is there any soy-based replacement for peanut butter? 
14:45:29 <dmhouse> proper butter > *
14:45:57 <hyrax42> again, inclined to agree with you, dmhouse
14:46:13 <vincenz> aloha
14:46:23 <psi> shapr: maybe you've seen it: http://www.netextra.se/nx/images/products_medium/7311050070473.jpg
14:46:33 <psi> I read that the english translation was soft whey bytter
14:46:35 <psi> butter&
14:46:55 <hyrax42> vincenz: you have stumbled into #sandwich-fillings
14:47:13 <hyrax42> or
14:47:20 <hyrax42> #stuff-you-put-on-toast
14:47:36 <hyrax42> (ginger marmalade works quite well in the latter)
14:48:00 <shapr> psi: Never heard of it.
14:48:29 <psi> if someone has made me a sandwich I politely accept it, but they always put on way to much butter. I have to try hard not to vomit :)
14:48:45 <psi> I don't know what's wrong with me
14:48:53 <shapr> You don't like butter. That's not wrong.
14:49:00 <shapr> I don't like tomatoes.
14:49:01 <dmhouse> yeah it is.
14:49:21 <dmhouse> tomatoes are dislikeable, though. Butter, on the other hand...
14:49:44 * shapr shrugs
14:49:47 <shapr> People are different.
14:50:09 <vincenz> hyrax42: or rather: stuff never to be found in my fridge
14:50:28 <psi> could you eat plain butter and nothing else? the thought gives me nausea
14:50:29 <vincenz> shapr: that's rather funny
14:50:40 <monochrom> I can.
14:50:54 <shapr> vincenz: What's funny?
14:50:56 <vincenz> shapr: My parents told me that when I was young (younger than 4 years) I wouldn't eat anything except for tomatoes.  Then we moved to italy, and of course everything is made with tomatoes (pizza, pasta) so I ate a lot!
14:51:04 <shapr> cool
14:51:08 <monochrom> I can eat plain butter, plain tomatoes, or buttered tomatoes.
14:51:20 <dmhouse> buttered tomatoes?!
14:51:23 <shapr> When I was a kid, I would spit out anything with tomatoes in it, no matter how small the amount.
14:51:25 <psi> hehe
14:51:34 <vincenz> shapr: we're polar opposites
14:51:35 * shapr tries to rebuild hope
14:51:58 <vincenz> shapr: all hope is lost?
14:52:11 <shapr> Nah, it's building.
14:52:42 <vincenz> heh, I bet if appel rewrote his compiler construction book with haskell, the code samples would be much better.
14:52:59 * shapr agrees
14:53:08 <monochrom> Nice.
14:54:03 <psi> anything but java
14:54:14 <vincenz> I only have the C and ML version
14:54:32 <psi> oh, I have a java version
14:55:16 <vincenz> hmm
14:55:25 <vincenz> his type inferernce chapter is missing an issue which is important
14:55:47 <monochrom> Compiler Construction with Butter, Tomatoes, and Turing Machines.
14:55:58 <vincenz> Ensuring to treat corecursive declarations together
14:56:03 <vincenz> before generalizing
14:57:19 <sylvan> Anyone here who help me get a ACM paper?
14:57:39 <vincenz> sylvan: You mean someone with an ACM account?
14:57:43 <sylvan> yep
14:57:44 <hyrax42> sylvan: if noone else can, I might still have my uni vpn access
14:57:50 <shapr> Wouldn't that be illegal?
14:57:55 <vincenz> shapr: rather
14:58:21 <shapr> I just ignore the ACM & Springer-Verlag and read what I can legally access. But I don't do this for a living...
14:58:36 <vincenz> We have ACM and IEEE accounts at work
14:58:53 <sylvan> It's this... http://portal.acm.org/citation.cfm?id=126471 I could access it from school but I don't want to go there now...
14:59:09 <shapr> bringert: same thing :-(
14:59:12 <hyrax42> you don't have dialup or a vpn?
14:59:31 <shapr> sylvan: ssh -R
14:59:31 <sylvan> vpn is supposedly possible but it stopped working a few months ago...
14:59:47 <vincenz> sylvan: you can make a free ACM account
14:59:48 <sylvan> I'm on windows...
14:59:50 <tennin> I have a moral objection to pickles
14:59:51 <vincenz> limited albeit
14:59:54 <vincenz> sylvan: google for putty
15:00:06 <shapr> Or install linux
15:00:19 <vincenz> @google putty ssh
15:00:21 <lambdabot> http://www.chiark.greenend.org.uk/~sgtatham/putty/
15:00:41 <tennin> they are undead zombie cucumbers
15:00:43 * shapr should be more tolerant of windows users.
15:00:45 <sylvan> hmm... okay I'll try to ssh then..
15:01:16 <vincenz> tennin: nah, they're cucumbers after they went to the beauty farm for a special bath
15:01:38 <vincenz> although t.b.h cucumber!=pickle
15:01:43 <vincenz> same family, prolly
15:01:43 <shapr> bringert: I did Setup clean && configure && build on gd, exif, hawl, cgi, xhtml, and parsedate. Still I get the same error.
15:01:54 <shapr> Anyone else want to help me test Hope?
15:02:01 <bringert> shapr: grr
15:02:10 <shapr> Maybe it's a real bug in ghc-6.4.1 ?
15:02:45 <Lemmih> What error?
15:03:41 <shapr> hope.cgi: internal error: update_fwd: unknown/strange object  57
15:03:43 <bringert> shapr: I compiled it on Ubuntu with ghc-6.4.1
15:03:50 <bringert> and it worked fine
15:03:59 <bringert> hmm, that was the fcgi version though
15:04:02 <shapr> Dang, something's wrong with my installation then, right?
15:04:06 <shapr> Oh, I'll try fcgi
15:04:24 <bringert> but my guess is you'll have the same problem
15:04:37 <bringert> shapr: did you try running the cgi from the command line?
15:04:41 <shapr> yup
15:04:43 <shapr> same thing
15:07:46 <shapr> bringert: I'm building fastcgi, any ideas while I can pursue if that doesn't work?
15:07:52 * shapr is getting sleepy
15:08:10 <shapr> Three hours of exercise does that.
15:08:33 <bringert> shapr: fresh reinstall of everything, including ghc?
15:08:40 <shapr> hm
15:08:42 <bringert> sounds a it crazy
15:08:44 <bringert> bit
15:09:47 <shapr> Do the many deps include tests of any sort?
15:11:28 <shapr> huh, fcgi looks like it might work.
15:11:35 <bringert> shapr: eh, fps
15:11:50 <bringert> or do you mean just example code?
15:12:01 <bringert> if so, try the simple examples in haskell-cgi/examples
15:12:21 <shapr> Anything I can run. Wouldn't the demos also explode if one of their deps was broken?
15:15:18 <bringert> hopefully
15:15:46 <bringert> so the haskell-cgi/examples programs should at least test fps+newcgi
15:16:46 <bringert> and they're easy to compile and run
15:23:23 <bringert> shapr: maybe you could replace HopeCGI.main with just main = runCGI (output "Hello World!"), just to see if it's maybe in any of the init code, like the database connection
15:24:01 <bringert> shapr: I only tried it with HSQL SQLite3 and HSQL MySQL, never with HDBC, maybe that could be another thing to try
15:27:25 <shapr> argh, I tried to comment with //
15:27:27 * shapr shoots himself
15:27:44 * monochrom shoots shapr 
15:27:52 <bringert> shapr: did the newcgi examples work
15:28:22 <shapr> I got distracted into talking about STM on #plone
15:28:40 <shapr> People were whining about threading problems.
15:28:53 <shapr> So I mentioned that GHC has both SMP and STM nowadays.
15:29:20 * shapr tries the hello world test
15:29:38 <shapr> bringert: works!
15:30:01 <bringert> the hello world from newcgi, or hope which a replaced main?
15:30:06 <monochrom> What is there to whine about threading problems?  I mean as opposed to programmer problems?
15:30:19 <shapr> replaced main
15:30:52 <shapr> monochrom: Debugging thread locking is far more challenging than debugging laziness.
15:31:28 <shapr> bringert: haskell-cgi examples work
15:31:49 <monochrom> Yes.  But it is a programmer problem if debugging of locks is necessary.
15:31:52 <shapr> It's looking like an HDBC problem at this point.
15:32:04 <bringert> shapr: maybe you can try the same, but now replace Hope.cgiMain with cgiMain db = output "Hello"
15:32:07 <shapr> monochrom: Easier said than done when you have fifty programmers sending in patches.
15:32:24 <monochrom> Ah.
15:32:43 <shapr> Plone is a monstrous chunk of code, and has at least fifty major contributors.
15:32:51 <monochrom> One single Dijkstra >> 50 programmers.  Dijkstra used lots of locks but no problem.
15:33:08 <shapr> Yeah, but Plone doesn't have a Dijkstra. There's runyaga, but he can't do everything.
15:33:17 <bringert> shapr: with the original HopeCGI of course. that way it does the DB connection and exception handling, but nothing else
15:33:43 <shapr> right
15:34:14 <shapr> it works, huh
15:34:21 <bringert> if that works, try hopeMain = output "Something or other"
15:34:31 <shapr> cgiMain db = output "Hello" at the end of Hope.hs, right?
15:34:37 <bringert> shapr: maybe it bombs when it tries a query
15:34:40 <shapr> hm, could be
15:34:51 <bringert> shapr: you restored HopeCGI, right?
15:34:53 <shapr> yup
15:35:03 <bringert> ok, try hopeMain then
15:35:28 <bringert> runWebSession does some query stuff I think
15:35:30 <dmhouse> shapr, bringert: this _still_ isn't working? You guys have been at it hours :)
15:35:30 <shapr> yup, that one exploded.
15:35:42 <bringert> ok, good
15:35:47 <shapr> dmhouse: I have patience, especially where a Haskell Web App Server is concerned.
15:35:50 <shapr> I've been wishing for this for years.
15:35:59 <dmhouse> and HAppS?
15:36:28 <shapr> I haven't really gotten around to playing with HAppS lately.
15:36:34 <shapr> The early versions weren't to my taste.
15:36:41 <bringert> shapr: runWebSession does some queries for session stuff
15:36:45 <dmhouse> mmm, okay. :)
15:36:51 <shapr> musasabi did a lot of work on the recent versions, I need to check it out again.
15:36:52 <bringert> maybe you can strace it?
15:37:32 <xerox> strace musasabi?
15:37:52 * xerox heads to bed ~~ night
15:37:54 <dmhouse> right, I'm going to bed.
15:38:04 <dmhouse> need to get back into a regular sleep pattern
15:38:13 * dmhouse looks at his clock - should have done this an hour ago.
15:38:24 <dmhouse> night all.
15:39:08 <shapr> bringert: Not much help there - http://rafb.net/paste/results/MzgMFk98.html
15:39:33 <bringert> shapr: you could try "cgiMain db = getAllUsers db >>= output . show" (in Hope.hs). That will do a simple query but non of the crazy state and reader monad stuff in runWebSession
15:39:59 <bringert> shapr: oh, and you need to import Hawl.User
15:40:03 <monochrom> shapr: It suddenly occurs to me.  Why are fifty programmers sending in patches that directly uses locks?  Shouldn't the system be architected so that there is a small core done by one single genius and has locking etc but impeccable, and everyone else develops the outer shell of the system calling the well-behaved entry points?
15:40:04 <bringert> for that to work
15:40:42 <shapr> monochrom: Probably, yeah. But Plone grew too quickly imho.
15:41:11 <shapr> bringert: works
15:41:36 <shapr> Gives back an empty list at least.
15:41:56 <bringert> that's what it should do
15:42:09 <bringert> so it's not really HDBC then
15:42:23 <bringert> maybe you can try inserting something into the users table?
15:42:26 <shapr> Sure
15:42:27 <bringert> and run it again
15:42:46 <bringert> hmm, runWebSession actually writes session stuff to the DB, so maybe it's a write problem
15:43:28 <shapr> bringert: works fine
15:43:58 <bringert> shapr: I'll come up with a new test, hold on
15:44:29 <hyrax42> links for Hope?
15:44:50 <shapr> live Hope demo at http://hope.bringert.net/
15:44:59 <vincenz> aha
15:45:24 <bringert> shapr: try import Hawl.Session   +  cgiMain db = newSession db Nothing >>= output . show 
15:45:40 <bringert> that should write to the DB as well
15:45:58 <hyrax42> oh this is brand new?
15:46:04 <shapr> Yeah, bleeding edge
15:46:06 <shapr> My favorite :-)
15:46:21 <bringert> so new it doesn't even seem to work
15:46:34 <shapr> It builds on top of lots of other code bringert wrote like xhtml, NewCGI, etc
15:46:45 <shapr> bringert: yes, explosion!
15:46:54 <bringert> ok
15:47:12 <bringert> so newSession blows it up, huh
15:47:28 <shapr> Lemme grab the latest hdbc & hdbc-postgresql from the darcs repos and try again.
15:48:06 <bringert> remember to recompile haskelldb-hdbc, haskelldb-hdbc-postgresql and hawl
15:48:27 <shapr> will do
15:49:32 <bringert> shapr: you what it could also be? newSession uses randomRIO, which probably cases the /dev/urandom read in the trace
15:49:49 <shapr> How would that cause such a weird error?
15:49:54 <bringert> dunno
15:50:03 <bringert> but it's the second to last file opened
15:50:11 <bringert> the last is /etc/localtime
15:50:11 <shapr> hm
15:50:34 <shapr> strange
15:50:38 <bringert> but there's lots of stuff after it, so it was just a guess
15:50:49 <shapr> On the other hand, this box has a history of weird problems. I thought it was just a stick of bad ram, but it could be more.
15:51:10 <shapr> At one point this box was giving a different md5sum for each invocaton of the program.
15:51:29 <shapr> Via motherboards suck.
15:51:34 <shapr> I had to disable the IO-APIC
15:52:36 <shapr> I didn't buy this hardware, someone gave it to me when they couldn't get it working at all.
15:53:03 <shapr> Free 2.4GHz P4 with 1gb of ram was acceptable.
15:53:12 * shapr is beginning to wonder
15:53:42 <Maddas> shapr: Hurgh, strange people! :-)
15:53:50 <bringert> shapr: to makes sure it's not random number generation or getting the current time, try: cgiMain db = do sid <- liftIO $ (randomRIO (0,maxBound) :: IO Int)
15:53:54 <bringert>                 now <- liftIO $ timeNow
15:53:56 <bringert>                 output $ show (sid,now)
15:54:30 <bringert> oh, and import Hawl.Util.Time
15:54:30 <bringert> import System.Random
15:54:31 * shapr just built and installed hdbc and hdbc-postgresql
15:55:02 <psi> uh. my laptop emits a constant tone unless the screen brightness is maximum or nothing
15:55:18 <shapr> My LCD screen does that with some inputs.
15:55:21 <shapr> It's really irritating.
15:55:33 <psi> I was hoping to save some battery
15:57:25 <shapr> bringert: works
15:57:34 <vincenz> dmhouse left?
15:57:37 <shapr> bringert: That is, the RIO
15:58:20 <bringert> shapr: I just noticed some transaction stuff that I forgot to remove in Hawl, that has been giving me problems before
15:58:58 * shapr builds haskelldb-hdbc
15:59:36 <bringert> shapr: so you may way to pull hawl before you rebuild it
16:00:11 <shapr> bringert: I want to try it with the rebuilt hdbc first.
16:00:18 <bringert> sure
16:00:21 <shapr> If that fixes it, I know it's not the transactions.
16:00:26 <bringert> better to change one thing at a time
16:00:53 <shapr> yup
16:00:53 <bringert> I had a problem at some point where I was nesting transactions. SQLite3 didn't like that
16:01:10 <bringert> I seem to recall that the error message was really weird
16:01:59 <shapr> For some reason, only Haskellers seem to try to do higher order stuff with everything.
16:02:02 <bringert> HaskellDB's transaction function catches all exceptions, unrolls, and then re-throws, maybe that can cause weird errors if the exception means somthing really bad
16:02:33 <bringert> so now Hope is transation free until I figure out how to do it right
16:04:10 <shapr> I think it's only SQLite3 that has that problem.
16:04:42 <bringert> there were larger issues, I need to think through what things should be transactions
16:05:03 <bringert> and at what level I should but the transaction bracketing
16:05:55 <shapr> hi mwc 
16:06:05 <mwc> hey there
16:06:09 <mwc> what's new in Haskell land?
16:06:32 <shapr> There's Hope!
16:06:46 <mwc> Been too busy looking up grad programs to get around to the nifty stuff ahead of me
16:06:50 <mwc> What's Hope?
16:07:11 <shapr> live Hope demo at http://hope.bringert.net/
16:08:55 <shapr> Ok, I think I've built all the deps again.
16:09:10 * shapr waits for hope to build
16:09:39 <bringert> I hope it works
16:09:39 <mwc> anybody in industrial math looking for a grad student, by any chance?
16:09:52 <shapr> What's industrial math?
16:10:10 <mwc> well, it's really industrial or engineering applications of math
16:10:23 <shapr> gwahr, same error
16:10:28 <shapr> Ok, time to pull Hawl patches
16:12:04 <mwc> so Hope is the FP answer to RoR?
16:12:05 <shapr> er waitasec...
16:12:55 <shapr> I dunno yet, but I like it so far.
16:13:22 <bringert> shapr: if that doesn't help, we seem to have narrowed it down to inserts, since select, random number generation and getting current time all work, and that's all newSession does
16:13:50 <bringert> so maybe a small test program that does an insert with haskelldb-hdbc-postgresql would be in order
16:13:51 <shapr> Still sounds like something to do with HDBC.
16:13:54 <shapr> Yup
16:14:37 <shapr> Ok, Howl is updated, building hope
16:14:58 <shapr> Hawl*
16:15:04 * shapr is getting sleepier
16:15:26 <shapr> Maybe I could turn on the extra-internal-lint checks in GHC?
16:15:34 <shapr> Anyone remember those flags?
16:15:59 <bringert> the docs say something about checking ghc's sanity, not yours
16:16:03 <bringert> iirc
16:16:06 <shapr> heh
16:16:08 <bringert> funny stuff
16:16:52 <shapr> Hm, I don't see the -dcore-lint option there.
16:17:00 <shapr> Same error.. grr
16:17:25 <bringert> I'll build you a new test
16:18:15 <shapr> core-lint didn't say anything.
16:21:29 <bringert> shapr: http://rafb.net/paste/results/xMMwd642.html
16:21:44 <bringert> that's the insert that newSession does
16:21:50 * shapr runs make test in hdbc-postgresql
16:26:08 <shapr> bringert: Shouldn't createdb explode too?
16:26:20 <shapr> bringert: That test you created works fine.
16:26:31 <bringert> createdb only runs create statements
16:26:42 <bringert> and apparantely inserts aren't a problem either
16:26:48 <shapr> Now I'm really lost.
16:26:59 <bringert> I'm beginning to suspect genSessionID
16:27:15 <shapr> Why so?
16:27:18 <bringert> if you have a bad random number generator it can get stuck in an infinite loop
16:28:55 <shapr> How can I test it?
16:29:01 <bringert> coming up
16:31:49 <dcoutts> @localtime dons
16:31:50 <lambdabot> Local time for dons is Wed Jun  7 09:23:26 2006
16:32:16 <shapr> I want a bluetooth headset that offers quality stereo sound so I get music and voice chat. Anyone heard of such a thing?
16:33:47 <shapr> bringert: hdbc-postgresql tests work
16:34:35 <bringert> shape: pasted a whole replacement Hope.hs at http://rafb.net/paste/results/h3hCv240.html
16:35:04 <stepcut> shapr: http://www.bluetake.com/products/BT420EX.htm\
16:35:07 <bringert> most of the new code is unused ATM, but we'll work through it
16:35:14 <joelr1> good evening
16:35:18 <joelr1> musasabi: ping
16:35:19 <shapr> hola
16:35:24 <joelr1> :D
16:35:31 <vincenz> fuck
16:35:38 <vincenz> some guy is sending me like 20 the same spam messages
16:35:41 <vincenz> in 20 minues
16:35:55 <bringert> vincenz: I got 27000 over a weekend once
16:35:56 <shapr> I have privmsg turned off for unidentified users.
16:36:00 <shapr> Oh, you mean email
16:36:00 <stepcut> shapr: http://www.mobilefun.co.uk/product/5177.htm
16:36:07 <vincenz> shini@hotmail.com
16:36:07 <bringert> ah, you mean irc spam
16:36:19 <bringert> oh, you do mean email
16:36:27 <vincenz> yeah
16:36:31 <vincenz> I dn't get it
16:36:33 <vincenz> it's specifically to me
16:36:40 <vincenz> typically spam I get doesn't have my email in the actual To file
16:36:43 <vincenz> this one is targetted to me
16:36:46 <vincenz> 20 the same messages
16:36:53 <vincenz> is there some place to report spam?
16:37:02 <shapr> stepcut: nifty!
16:37:08 <shapr> vincenz: Yeah, several places
16:37:25 <vincenz> shapr: where?
16:37:27 <joelr1> so is anyone running a haskell web server?
16:37:50 <bringert> I got 27000 bounces because someone decided to send rape-porn spam with asxwdasd@bringert,net (random letters, can't remember which) as the From-address
16:38:20 <bringert> 27000 were just the out-of-office and mailbox full replies, plus some people who asked me to stop spamming them
16:38:32 <bringert> I wonder how many messages were sent out
16:38:47 <vincenz> ;/
16:39:02 <vincenz> There'es a need for a more traceable email system
16:39:10 <shapr> Seen im2000 ?
16:39:23 <vincenz> fortunately gmail has a good spam filter
16:39:27 <vincenz> I get 50 / day
16:39:28 <stepcut> shapr:  http://accessories.inphonic.com/pc-539-5-motorola-bluetooth-stereo-headset-ht820.aspx
16:39:28 <vincenz> by default
16:39:34 <shapr> bringert: I get the error from that Hope.hs
16:39:36 <vincenz> but this specific guy targetted me, don't know why
16:39:49 <shapr> vincenz: http://www.scannedinavian.com/~shae/antispamserver.html
16:39:58 <stepcut> shapr: that one claims to support connecting to a bluetooth phone and seperate bluetooth music player at the same time -- with auto-mute on incoming calls
16:40:15 <bringert> shapr: ok, then we're close
16:40:29 <shapr> stepcut: Longer play time too
16:40:46 <shapr> About the same price
16:41:27 <bringert> shapr: how about this: http://rafb.net/paste/results/xrZzpU27.html
16:41:28 * stepcut gets back to work
16:41:33 <shapr> stepcut: thanks!
16:42:15 <shapr> bringert: same error
16:43:32 <bringert> shapr: and this: http://rafb.net/paste/results/hTsbaF72.html
16:44:16 <shapr> same error
16:44:50 <shapr> Something to do with records and inserting?
16:45:03 * shapr is just guessing as the code flies by
16:45:09 <bringert> but insert work fine just before, right
16:45:16 * vincenz ahs as he finishes his report
16:45:25 <vincenz> Time to sleep so I can focus again on my compiler tomorrow
16:45:26 <vincenz> tatah
16:45:45 <shapr> bringert: Order problem in HDBC maybe?
16:46:47 <bringert> shapr: http://rafb.net/paste/results/icJN8g86.html
16:46:59 <bringert> tried making things more monomorphic
16:47:44 <shapr> still explodes
16:48:18 --- mode: ChanServ set +o Igloo
16:49:58 * shapr stuffs putStrLn debug statements into Hope.hs
16:50:12 <bringert> shapr: http://rafb.net/paste/results/03qJc497.html
16:50:21 <shapr> bringert: liftIO $ putStrLn "after insert" prints out before the explosion.
16:50:38 <bringert> what!
16:50:51 <shapr> yup
16:51:06 <bringert> what that the last paste?
16:51:12 <shapr> No, before
16:51:30 * shapr builds the last paste
16:51:37 <bringert> this is crazy
16:51:47 <shapr> yeah, something's just wrong
16:51:57 <shapr> same error with that most recent paste
16:51:58 <bringert> show can't really blow up
16:52:33 <shapr> Maybe one of the monads can blow up?
16:52:40 <bringert> ok, now you're down to a single function, with just an insert and output
16:52:47 <bringert> what if you ourput some constant?
16:52:56 <shapr> output $ show 1 ?
16:53:01 <bringert> yeah
16:53:07 <bringert> or output "foo"
16:53:23 <shapr> output $ show 1 works
16:53:38 <bringert> but output $ show s doesn't
16:53:40 <shapr> nope
16:53:52 <shapr> and putStrLn "after let" shows up before the crash.
16:53:56 <bringert> try keeping the show s but remove the insert
16:54:33 <bringert> hmm, maybe it's an fps problem
16:54:37 <shapr> it works
16:55:07 <shapr> removing the insert succeeds
16:55:07 <bringert> crazy
16:55:15 <shapr> Yeah, something is definitely whacked.
16:55:25 <bringert> this is starting to feel like C
16:55:27 <shapr> hah
16:55:34 <shapr> Well, bytestring is pretty low level
16:55:56 <bringert> yeah, and newCGI uses it internally
16:56:17 <shapr> But why would both the insert and the show crash?
16:56:19 <bringert> so maybe the insert messes with the stack or something, and then fps trips up when it gets a long string
16:56:30 <shapr> hm
16:56:44 <bringert> shapr: the insert doesn't crash on its own right?
16:56:45 <shapr> hdbc-postgresql does use some pointer stuff.
16:56:49 * shapr tries
16:56:59 <shapr> Well, we know it doesn't
16:57:06 <shapr> If I show a constant, everything works
16:57:16 <bringert> I mean, you tried the insert followed by output "foo", and that worked right?
16:57:19 <bringert> ok
16:57:20 <shapr> yup
16:57:35 <bringert> try some long string constant
16:58:45 <shapr> output $ show $ take 55 $ repeat 'a' --works
16:59:25 <bringert> shapr: try http://rafb.net/paste/results/1q4AJE59.html
16:59:28 <shapr> output $ show $ take 555 $ repeat 'a' -- fails!
16:59:36 <shapr> You're right!
16:59:37 <bringert> ah
16:59:51 <bringert> this is officially strange
16:59:59 <shapr> 355 fails
17:00:05 <bringert> no need to try my paste
17:00:17 <bringert> but if you remove the insert they all work?
17:00:21 <shapr> 155 works
17:00:25 <shapr> lemme see
17:00:44 <bringert> maybe something around the 256 limit?
17:00:49 <shapr> would make sense
17:00:56 <shapr> yup, 355 works without the insert
17:01:23 <shapr> 256 fails
17:01:35 <bringert> but Data.ByteString uses 4096-bute blocks
17:01:38 <bringert> byte
17:01:44 <shapr> 255 fails
17:02:07 <shapr> hm, so does 250
17:02:14 <bringert> does hope.fcgi fail too?
17:02:27 <shapr> I don't know yet, haven't setup fcgi correctly
17:02:31 <shapr> 200 works
17:02:52 <shapr> 240 fails
17:02:55 <shapr> this is weird
17:03:22 <bringert> this is all from the command line, right?
17:03:27 <shapr> yup
17:03:37 <shapr> 220 works
17:03:44 <shapr> 230 works
17:04:24 <shapr> whoa, 235 works *and* fails.
17:04:43 <shapr> It shows 235 chars and then explodes.
17:04:53 <bringert> !
17:05:18 <shapr> I think you're right, bytestring has at least one bug.
17:05:26 <shapr> Lemme setup fcgi
17:05:55 <_frederik_> hello
17:06:28 <shapr> hiya
17:06:30 <_frederik_> if i'm encapsulating a ForeignPtr in an object, and then the memory pointed to changes, and i want to encapsulate it in a new object to reflect that, how do i do it?
17:06:55 <_frederik_> it's a vector that contains an Int and a ForeignPtr
17:07:24 <_frederik_> and i want to incrementally change the data pointed to, while calling something that takes a vector
17:08:25 <dcoutts> shapr, found a ByteString bug?
17:08:39 <shapr> dcoutts: Found something weird
17:09:03 <bringert> shapr: here's a more stand-alone test: http://rafb.net/paste/results/rVHirq39.html
17:09:34 <bringert> shapr: you need to replace the dbConnect by your dbConnect
17:10:03 <shapr> fcgi seems to explode the same way
17:10:23 <_frederik_> what is fcgi?
17:10:31 <bringert> _frederik_: FastCGI
17:10:43 <bringert> http://www.fastcgi.com/
17:11:08 <bringert> there is a Haskell binding
17:11:15 <_frederik_> ah cool
17:12:09 <shapr> bringert: Um, that one works.
17:12:21 <bringert> ok, could be the exception handling
17:12:33 <dcoutts> shapr, what's the test case for take . repeat ?
17:12:53 <shapr> dcoutts: It appears that something is chewing on the stack.
17:13:27 <dcoutts> shapr, do you have an example that fails reliably?
17:13:39 <shapr> Yes, but I don't know if it'll fail on everyone's machine.
17:13:44 <_frederik_> (i got it nevermind)
17:13:45 <shapr> In short, build Hope
17:13:47 <bringert> shapr: added exception handling back in http://rafb.net/paste/results/vbGE5I26.html
17:14:19 <dcoutts> shapr, oh, I thought you had something small like show $ take 555 $ repeat 'a'
17:14:23 <shapr> Not yet
17:15:28 <shapr> bringert: works?
17:15:29 <bringert> maybe you need to compile with -O2 for it to crash
17:15:33 <shapr> oh, maybe so
17:15:52 <shapr> nope
17:16:11 <bringert> wtf
17:16:11 * shapr is highly confused
17:16:52 <shapr> Ok, hope.cgi still crashes, but Test.hs doesn't
17:16:59 <bringert> maybe it's affected by inlining or something
17:17:30 <shapr> Or GHC_RTS_OPTS ?
17:17:35 <shapr> Since I'm not using that to build Test.hs?
17:17:35 <bringert> ah
17:17:49 <bringert> try builing hope without
17:18:36 <bringert> of course other GC options can affect this sort of thing
17:18:56 <shapr> Works!
17:19:05 <bringert> haha
17:19:21 <bringert> so all you needed to do was to change an option in the makefile
17:19:27 <shapr> What does -M50m -c do?
17:19:50 <bringert> set the maximim heap size, and use a compacting garbage collector I think
17:20:12 <bringert> did you just set GHC_RTS_OPTS to the empty string and it worked?
17:20:22 <shapr> Nah, I commented out everything there
17:20:27 <shapr> I'm going to try removing -c 
17:20:55 <monochrom> Interesting
17:21:40 <shapr> Seems to work without -c
17:21:59 <shapr> I dunno what that means exactly.
17:22:19 <bringert> haha, I should have thought of that from the beginning. I'll set GHC_RTS_OPTS to the empty string in the repo
17:22:34 <bringert> anyone who needs other settings has to change themselves
17:22:45 <shapr> Lesson learned: when having mysterious problems, remove all unusual options first
17:22:54 <bringert> yes
17:23:04 <shapr> ooookay, I can finally test hope
17:23:33 <shapr> hm, fromSql: Cannot read "2006-06-07 02:21:47" as Integer.
17:23:50 <bringert> ah, HDBC has some problems with dates
17:24:03 <bringert> I thought it was only HDBC.Sqlite3
17:24:18 <shapr> Hope wants unix time, yeah?
17:24:32 <shapr> oj, it's 2:30
17:24:35 <bringert> yes, HaskellDB likes to use ISO8601 strings for dates, HDBC likes unix
17:25:09 <shapr> I'll look at this again tomorrow, thanks for all the time.
17:25:17 <bringert> but it runs now anyway?
17:25:31 <shapr> I see an internal server error with that fromSql error
17:25:41 <shapr> It doesn't crash at least
17:25:50 <shapr> That's a huge improvement.
17:26:11 <bringert> yeah, that's just a problem with HDBC - HaskellDB interaction with date formats
17:26:39 <bringert> I should look into that
17:27:13 <shapr> Otherwise I'll try to install HSQL tomorrow.
17:27:28 * shapr falls over asleep
17:27:35 <bringert> shapr: good night
17:29:55 <SamB> Ouch! SF.NET replaced the links to the actual files on the download servers with javascript!
17:31:09 <Spark> whats the lambda abstraction syntax in haskell?
17:31:20 <bringert> \x -> ...
17:31:23 <Spark> ah yes ->
17:31:28 <Spark> nice and ugly :)
17:31:59 <Spark> is . a special token in haskell?
17:32:41 <bringert> no, it's an operator
17:32:59 <bringert> and part of some tokens: qualified names
17:33:30 <Spark> by special token i mean keyword really
17:33:40 <Spark> but it doesnt make sense to be calling something a keyword when it isnt a word
17:33:59 <Spark> is there a reason why the abstraction syntax couldnt be \x.x
17:34:03 <bringert> I don't think it's special, it's just an operator name
17:34:36 <bringert> hmm, I guess because then . couldn't be used as an operator
17:35:01 <bringert> but maybe the real reason is that someone thought that -> would be easier to understand / look better
17:35:17 <SamB> well, we didn't have the tech for λx → ..., and it isn't all that easy to type either ;-)
17:35:21 <monochrom> In "Data.Map.!" it is a keyword :)
17:35:35 <Spark> -> is always used for types though, and . for the abstraction itself
17:35:55 <Spark> using an arrow is confusing there i think
17:36:03 <bringert> monochrom: it is? I thought "Data.Map.!" was a single token
17:36:10 <Cale> It's not so bad, it's in an entirely different sublanguage
17:36:14 <Spark> i dont really have a problem with \ vs λ or → vs ->
17:36:27 <SamB> and dots just don't make sense for that in programming...
17:36:27 <SamB> too confusing
17:36:32 <monochrom> yucky, I am not sure what is a token.
17:37:11 <Cale> I think we should have chosen some other character for the module path separator
17:37:19 <Cale> | works quite well.
17:37:57 <SamB> Cale: I don't think so
17:38:01 <monochrom> Like data Colour = Red|Blue ?
17:38:16 <Cale> monochrom: hm?
17:38:24 <Spark> . for module paths is like java
17:38:32 <Spark> people like consistency between languages
17:38:33 <Cale> Like Data|Map|empty
17:38:40 <monochrom> Nah Java stole from us
17:38:52 <Spark> arguably it should be /, like directory hierarchies
17:39:05 <Cale> Except that would steal / :)
17:39:35 <SamB> Spark: I thought of that too, but it just seems ugly
17:39:37 <monochrom> f x|Data|Map|lookup x == 1 = 10
17:39:41 <Spark> syntax like (\x->(\y->y:x)) is ugly though :)
17:40:10 <Spark> is there a better way of writing that?
17:40:12 <Cale> monochrom: okay, so it looks a bit odd in guards
17:40:16 <bringert> Spark : flip (:)
17:40:17 <Spark> reversing the arguments of a curried function
17:40:19 <Spark> ah cool
17:40:31 <bringert> @pl (\x->(\y->y:x))
17:40:31 <lambdabot> flip (:)
17:40:38 <Cale> Or you can merge the lambdas
17:40:44 <Cale> (\x y -> y:x)
17:40:48 * monochrom likes counterexamples
17:40:52 <Spark> ah, i was doing \x \y
17:40:53 <SamB> Spark: so don't use lambdas, duh!
17:41:00 <SamB> anyway, use spaces
17:41:35 <monochrom> I heard \x y and \x->\y are different in generated code, and \x y is the more efficient one.
17:41:35 <bringert> Spark: here's another: \x -> (:x)
17:41:52 <Spark> heh thats nice
17:41:57 <Spark> well its pretentious really
17:42:16 <bringert> monochrom: that sounds strange to me
17:42:30 <bringert> that should be an easy enough optimization
17:42:31 <Spark> surely \x y expands to the latter
17:42:38 <Cale> It seems plausible to me, but I bet the compiler actually merges them
17:42:54 <Pseudonym> Cale: Yes it does, most of the time.
17:43:03 <Pseudonym> There are circumstances, however, when it doesn't.
17:43:19 <Pseudonym> And there are circumstances where it would be better to split them and it doesn't.
17:46:07 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2006-May/015698.html
17:47:33 <SamB> monochrom: well, we have an inliner for that, so, it doesn't matter that much!
17:47:51 <SamB> except that \x y -> is nicer looking, of course
17:49:29 <Spark> > foldl (\list n -> if (n `mod` 2 == 0) then (list++[n]) else (if list == [] then [] else tail list)) [] [1,2,4,3,4,5,6]
17:49:30 <lambdabot>  [4,6]
17:50:01 <Spark> im gonna write a stack-based sort of arithmetic machine, and then a compiler from standard arithmetic expressions into bytecode for that machine
17:50:05 <Spark> good starter haskell project? :)
17:50:16 <monochrom> yah
17:50:58 <Spark> and try and make it small enough that it can be pasted into irc in one line
17:51:00 <Spark> heh
17:52:44 <bringert> Spark: you'd be surprised how small you can make it
17:52:56 <Spark> the biggest question is how can i make a list that has a mixture of numbers and symbols in it
17:52:59 <Spark> like [1,2,plus]
17:53:07 <Spark> @type [1,2,plus]
17:53:08 <lambdabot> Not in scope: `plus'
17:53:20 <Spark> some kind of type, presumably
17:53:24 <monochrom> Probably need a sum type.
17:54:02 <bringert> ludde and I were in a programming language semantics class where an assignment was to write a small byte code interpreter. after finishing our interpreters at around 5K each, we tried to get them as small as possible
17:54:18 <bringert> I think we gave up at around 860 characters
17:54:43 <monochrom> You are tokenizing, I think.  As you can see from Alex examples, the token type is usually a sum type, say one case for numbers, another for operators.
17:55:20 <Spark> something like data Instruction = Push (Int) | Plus
17:55:21 <Spark> ?
17:55:34 <monochrom> yes
17:55:40 <Spark> can i get rid of the Push ( )
17:56:03 <monochrom> You can get rid of ( and )
17:56:17 <Spark> but the number has to wrapped in the type constructor still
17:56:57 <monochrom> Yes.
17:57:06 <monochrom> Tagged sum/union type.
17:57:31 <Spark> so this is two things, first the encapsulation of the Int in a Push, and also the tagged union
17:57:45 <Spark> cant I just add the Plus to the Int type
17:58:15 <Spark> ERROR - Cannot infer instance
17:58:15 <Spark> *** Instance   : Num Instruction
17:58:15 <Spark> *** Expression : [10,14,Plus]
17:58:16 <Spark> :(
17:59:33 <lispy> [Push 10, Push 14, Plus]
18:00:26 <Spark> i always thought you could have a form of poor man's exception handling by augmenting the return type of your function with other type constructors
18:00:38 <Spark> so fact:: Int -> (Int | Error) or something like that
18:00:46 <Spark> is that a special case?
18:01:06 <lispy> fact :: Int -> Maybe Int or fact :: Int -> Either Int MyErrorType
18:01:07 <Pseudonym> Well, you could do this:
18:01:10 <Pseudonym> Right.
18:01:13 <Pseudonym> That's what Either is for.
18:01:17 <Pseudonym> Discriminated union.
18:01:26 <Pseudonym> [Left 10, Left 14, Right Plus]
18:01:29 <Pseudonym> However.
18:01:35 <mwc> I'm really surprised I haven't come across a real Exception monad
18:01:47 <mwc> the one in the MTL is pretty bad, considering how bind is implemented
18:01:50 <Pseudonym> 99.9% of the time when you're tempted to use Either, Maybe or Bool, you really should be defining your own type.
18:01:51 <Spark> its a bit annoying to have to write the constructor for the ints
18:03:07 <lispy> Spark: what do you mean?
18:03:14 <mwc> once you throw the exception, you continue to bind functions through it, even though it has no effect. So consider modelling a client-server dialogue using a stream, say by unfolding
18:04:01 <mwc> I'd think the proper way to do it would be to use continuations, trying that but having trouble working out exactly the types of various things
18:04:04 <Pseudonym> Spark: So make it shorter.
18:04:11 <Spark> lispy: i'd like to be able to write [1,2,Plus] for instance
18:04:14 <mwc> so I probably don't understand it tat all :P
18:04:32 <Pseudonym> data Thingy = I Int | Plus
18:04:36 <Pseudonym> That's not quite as bad.
18:04:39 <Spark> Pseudonym: hardly a solution though
18:04:50 <Pseudonym> Alternatively, you could make a smarter constructor.
18:04:54 <Spark> incidently, do the type constructors have to be unique per type?
18:04:55 <Pseudonym> Example:
18:05:07 <Pseudonym> Spark: Yes, but smart constructors don't.
18:05:30 <Pseudonym> data Thingy = I Int | Plus
18:05:38 <Pseudonym> class ThingyBuilder a where
18:06:22 <Pseudonym>     ($:) :: a -> [Thingy] -> [Thingy]
18:06:27 <Pseudonym> instance ThingyBuilder Int where
18:06:38 <Pseudonym>     n $: xs = I n : xs
18:06:44 <Pseudonym> instance ThingyBuilder Thingy where
18:06:49 <Pseudonym>     t $: xs = t : xs
18:06:52 <Pseudonym> Now you can write:
18:06:55 <Spark> defining a whole new list class?
18:07:07 <Pseudonym>     10 $: 14 $: Plus $: []
18:07:19 <Spark> oh right
18:07:25 <Pseudonym> After you suitably declare $: as a right-associative operator.
18:07:26 <Spark> yeah it is that, kinda
18:07:57 <Pseudonym> You could probably do some TH hackery to do this, too.
18:08:15 <Pseudonym> Actually, I think this idiom is underused.
18:08:25 <Pseudonym> I hereby call it "polymorphic smart constructor".
18:08:28 <Spark> you lose the nice [a,b,c] syntax though
18:08:38 <lispy> Pseudonym: yeah, it seems like a bit of work, but pretty cool at the same time
18:08:39 <Pseudonym> That's right, you do.
18:08:53 <Spark> it would be good if the type constructors were very heavyweight
18:09:12 <Spark> is there like a toString() function?
18:09:19 <Pseudonym> @type show
18:09:20 <lambdabot> forall a. (Show a) => a -> String
18:09:43 <Spark> so you could also define show for that class?
18:09:46 <lispy> Spark: for most stuff just do: data Foo = Foo deriving (Show)
18:09:47 <Pseudonym> You can put "deriving (Show)" at the end of your data declarations, even.
18:10:00 <Pseudonym> Generally speaking, that's the Show instance that you want.
18:10:14 <Pseudonym> If you want something different, you're better off making a custom pretty-printing class.
18:10:22 <Pseudonym> Or using Text.Pretty.
18:10:26 <Pseudonym> Or something.
18:10:50 <Pseudonym> "Show" isn't really for pretty printing.
18:11:21 <lispy> Show and Read are kinda sorta meant to be inverses (but that's not enforced any where)
18:11:41 <Spark> so what is show for, if not pretty printing?
18:12:04 <Pseudonym> Ugly printing, obviously.
18:12:06 <Pseudonym> :-)
18:12:20 <Spark> naive printing :)
18:12:26 <lispy> i use it a lot for debugging and working with the interpreter
18:12:29 <Pseudonym> The idea is that the output of Show should be valid Haskell, more or less.
18:12:54 <Spark> ah, so letting show print [...] for ThingyBuilder is not such a great plan
18:13:15 <Pseudonym> ThingyBuilder is a class, not a type.
18:13:15 <Spark> Main> foldl process [] [Push 3, Push 4, Plus, Push 9, Plus]
18:13:15 <Spark> [16]
18:13:19 <lispy> show doesn't print, it's just toString()
18:13:23 <Spark> ah right yeah
18:13:26 <Spark> s/print/return/
18:13:59 <lispy> @type print
18:14:00 <lambdabot> forall a. (Show a) => a -> IO ()
18:15:28 <Spark> right yeah, iirc classes are like java's interfaces in that they just say what can be done with data, but not how
18:15:47 <lispy> yup
18:15:57 <lispy> type classes are a very good idea
18:16:15 <lispy> i really like default method definitions
18:16:27 <Spark> thats more like an abstract class then (by the sounds of it)
18:16:35 <Spark> are there things like java's Comparable?
18:16:38 <lispy> they can be circular, so that an instance only needs to define a few key ones and the rest are just in terms of what you have
18:16:44 <Pseudonym> Spark: Yes, there's Ord.
18:16:52 <Spark> is that a type class?
18:16:58 <lispy> yup
18:16:59 <Pseudonym> Spark: Do you know any C++?
18:17:13 <Spark> lispy: thats interesting, how does the type system deal with that?
18:17:18 <Spark> Pseudonym: a little
18:17:24 <Spark> Pseudonym: i read a book on it, never actually coded any :)
18:17:29 <Spark> (the book was enough to put me off)
18:17:31 <Pseudonym> Spark: A typeclass is more or less analogous to a C++ "concept".
18:17:54 <lispy> Spark: not sure what you mean
18:17:56 <Spark> i dont think i ever read about those
18:17:58 <Pseudonym> It's like an interface, but it can be attached to a type AFTER the type is declared.
18:18:24 <Pseudonym> So there's no problem with adding class memberships to built-in types, for example.
18:18:35 <Spark> lispy: are the default methods typed under the assumption that certain other functions will be available with certain types, and then when instances are derived, it makes sure those functions exist (with compatible types)
18:18:36 <Pseudonym> You don't need to go in and edit the built-in type declaration.
18:19:02 <Spark> even though those "other functions" arent actually there for it to look at
18:19:07 <Pseudonym> The catch is that a type has no idea what interfaces it supports.
18:19:24 <lispy> Spark: check out this example of using type classes: http://www.haskell.org/hawiki/CodeExamples#head-c926349e876dca4d1324036fe67a6eb1fe7afb3c
18:19:37 <Pseudonym> In a pure OO system, you attach interfaces at the time the type is declared, so it is aware of what it supports.
18:19:48 * Pseudonym thinks
18:19:53 <Spark> Pseudonym: what about haskell?
18:19:58 <Pseudonym> No, I didn't mean to say "in a pure OO system".
18:20:01 <lispy> Spark: yeah, all the functions in a type class are assumed to exist with their given type signatures
18:20:20 <Pseudonym> In most realisations of OO, that's true.
18:20:34 <Pseudonym> Spark: In Haskell, you're quite able to declare your own class, then make Int an instance of it.
18:21:00 <Pseudonym> You can't do that in Java.
18:23:30 <Spark> i see
18:23:45 <Spark> in java you'd have to extend Int and also implement the interface in question
18:24:18 <Spark> but because there is the possibility of adding extra fields, you'd have to tell bits of the code to use the new subclass
18:24:33 <Pseudonym> Right.
18:24:57 <Pseudonym> The catch is that in Haskell, Int has no idea what interfaces it supports.
18:25:12 <Spark> ive never actually thought that you could weaken the subtype relation so much, when there is no additional state between classes and subclasses
18:25:22 <Pseudonym> In Java, java.lang.Integer can be downcasted to any of its interfaces.
18:25:36 <Pseudonym> But in Haskell, Int cannot.
18:25:43 <Spark> right, so how do you get to the extra Int functionality?
18:25:55 <Pseudonym> Ah, that's the cool part.
18:26:02 <Spark> MyClass Int =>  or something like that?
18:26:04 <Pseudonym> You just use it.
18:26:18 <Spark> so the definition has to be in scope presumably
18:26:21 <Pseudonym> @type show :: Int -> String
18:26:22 <lambdabot> Int -> String :: Int -> String
18:26:25 <Pseudonym> That just works.
18:26:34 <jer> Pseudonym, can you give me an example of a single pure oo language that doesn't allow what you describe? (java is not a pure oo language)
18:26:37 <Pseudonym> If you show an Int, and there's a Show instance for Int in scope, you can just use it.
18:26:47 <Pseudonym> jer: Yes, but they're all theoretical.
18:26:53 * jer doens't care about theory =]
18:26:56 <jer> but okay thanks
18:26:58 <Pseudonym> TaPL has one example langauge, for the moment.
18:27:03 <Pseudonym> Sorry, for example.
18:27:20 <Spark> what makes a pure OO language?
18:27:21 <Pseudonym> Spark: The trick comes if your function is polymorphic.
18:27:25 <Pseudonym> @type show
18:27:26 <lambdabot> forall a. (Show a) => a -> String
18:27:47 <Pseudonym> You read that type as: For all types a, if a is a member of Show, then this function has type a -> String.
18:27:49 <Spark> ah, once youve said Int is_a Show, then you can show ints
18:27:53 <Pseudonym> Right.
18:28:00 <piggybox> well, from some point of view, java isn't pure OO
18:28:00 <Spark> despite show only taking Shows
18:28:07 <jer> Spark, in a pure oo language, *everything* is a reprsentation of an object
18:28:18 <jer> i.e., Io is a great example of an absolutely pure oo language
18:28:19 <Pseudonym> You can think of => as a bit like ->
18:28:46 <Spark> at the moment i'm reading => as "constraints on the left, the actual thing on the right"
18:28:46 <Pseudonym> Operationally,  you're passing the type dictionary/vtable/call it what you will for (Show a) as a first argument.
18:29:01 <Spark> which is an arrow i guess, fair enough :)
18:29:42 <Pseudonym> You can read it as constraints, an implication or a concrete argument.
18:29:50 <Excedrin> jer: what about Smalltalk, Ruby, Eiffel...
18:30:02 <Pseudonym> The Girard-Reynolds isomorphism guarantees that you're right, no matter how you interpret it. :-)
18:30:15 <Spark> about the pure oo thing, is it actually possible to compile such languages into a form that use primitives for the... primitives
18:30:24 <Spark> presumably they must be final classes otherwise all hell would break lose
18:30:39 <Pseudonym> OO, in the Alan Kay sense, is actually a fairly weak idea.
18:30:43 <jer> Excedrin, i'm not familiar with eiffel, but ruby and smalltalk are really close (though neithers locals are objects, so in my views, that rules them out; but they are *very* close to being pure)
18:30:44 <Pseudonym> It doesn't refer to type systems at all.
18:30:47 <Spark> Pseudonym: can you change Int functionality as well as add to it?
18:30:47 <dons> @seen musasabi 
18:30:48 <lambdabot> musasabi is in #haskell, #haskell-blah and #haskell-overflow. I don't know when musasabi last spoke.
18:30:58 <Pseudonym> Spark: Kind of.
18:31:02 <jer> Excedrin, though there's nothing in ansi smalltalk that would prohibit you from making block locals a real object
18:31:02 <palomer> why are OO discussions so popular in #haskell?
18:31:13 <Pseudonym> You can fail to import a typeclass instance, and declare your own in scope instead.
18:31:34 <Spark> because #haskell is full of programming language theorists :)
18:31:53 <Pseudonym> People (think they) understand OO, so it's a good point of reference for explaining Haskell.
18:31:55 <Excedrin> and lots of OO programmers trying to figure out FP
18:32:03 <Excedrin> right, that
18:32:26 <Spark> there are basically only two camps these days
18:32:31 <Spark> structured programming has given way to OO
18:32:35 <Spark> so theres just OO and FP
18:32:40 <Pseudonym> What Alan Kay meant by OO is actually more like Erlang than Java.
18:32:42 <Spark> everything else is "fringe"
18:32:49 <Pseudonym> Which is interesting.
18:33:01 <Spark> alan kay was more about modelling the world i thought
18:33:05 <Pseudonym> Yeah.
18:33:08 <Spark> he wanted to make programs more intuitive
18:33:16 <Spark> instead, everyone used objects to generate lots of meaningless abstractions
18:33:17 <JKnecht> OO LP and FP mostly.
18:33:18 <Pseudonym> He saw software as a biological process, with communicating "cells".
18:33:29 <Spark> like BufferedLineReader or whatever :)
18:33:39 <Pseudonym> Well, what people use objects for is as a module system.
18:33:44 <Spark> yeah
18:33:48 <Pseudonym> Which isn't necessarily wrong.
18:33:52 <Pseudonym> Modularity is good.
18:34:04 <Spark> not just modularity, but associating data with function
18:34:13 <Spark> people have done that in C long before OO anyway
18:34:17 <Spark> with structs and function pointers
18:34:35 <Pseudonym> For programming in the large, people nowadays use "components", which is actually closer to what Alan Kay had in mind.
18:34:38 <JKnecht> not to forget the whole post OO-thing (Aspects, Mega, etc.)
18:35:06 <jer> post oo?
18:35:16 <jer> aspects are very much a part of a lot of modern oo languages
18:35:18 <Pseudonym> Component-oriented programming has, IMO, saved OO from a huge mess.
18:36:13 <Pseudonym> You know, I don't get aspect-oriented programming.
18:36:16 <Spark> me neither
18:36:19 <Spark> seems like a load of hype
18:36:20 <Pseudonym> I see the benefit, but I don't see the practicality.
18:36:28 <Pseudonym> It seems... fragile.
18:36:38 <Spark> its like shooting your code with a shot gun
18:37:04 <JKnecht> Demeter/Aspects, similar. It's a valid methodology, nothing more.
18:37:06 <Pseudonym> I'd go so far as to claim that AOP seems fundamentally incompatible with agile programming.
18:37:24 <Spark> yeah, with agile programming you'd just go in and hack the aspects into the code
18:37:28 <Spark> and then hack them out again after
18:37:51 <Spark> aspects would be useful for all those .class files where you've lost the original source and so on
18:38:06 <Spark> where the system is disorganised and you cant hope to do it by hand
18:38:16 <JKnecht> I guess it's in that sense that Agile meths are themselves a hack of a methodology.
18:38:24 <Pseudonym> Absolutely.
18:38:29 <JKnecht> in essence a reaction to a societal ill.
18:38:34 <Pseudonym> "Hack" in the good sense.
18:39:06 <Spark> agile is just "dont be afraid of the code" :)
18:39:15 <Spark> all that stuff about unit tests is just to give you security when making modifications
18:39:35 <Pseudonym> Right.
18:40:45 <Pseudonym> Agile programming is, to me, the embodiment of Larry Wall's programmer virtues: Laziness, impatience, hubris.
18:41:00 <Pseudonym> aka: "Do the smallest thing that could possibly work", "refactor aggressively".
18:41:33 <Pseudonym> One of the reasons I like Haskell is that the type system replaces a lot of unit tests.
18:41:37 <Pseudonym> Such as concept checks in C++.
18:42:22 <Spark> haskell's errors can be hard to understand though
18:42:26 <Spark> thats just type inference for you
18:42:33 <Spark> a typo can result in "blah blah infinite type"
18:42:37 <Pseudonym> Have you ever seen STL type errors in C++?
18:42:41 <Spark> nope
18:42:47 <Pseudonym> Haskell's are angelic by comparison.
18:42:51 <Spark> did you see the tim sweeney talk at popl'05 i think it was
18:42:55 <Pseudonym> Nope.
18:42:59 <Spark> he moans about haskell's error messages there
18:43:03 * Pseudonym nods
18:43:08 <Spark> although he is a fan of writing pure functions and so on
18:43:16 <Spark> (where it is nice to do so)
18:43:19 <Pseudonym> I definitely think there's more research to be done there.
18:43:35 <monochrom> I have seen STL type errors in C++.  I was thinking it was just gcc.
18:43:39 <Pseudonym> Peter Stuckey et al have done some good work on constraint-based type checking.
18:44:16 <Pseudonym> A type error is a disagreement between two parts of your code as to what the type should be.
18:44:33 <Excedrin> are there any haskell image manipulation libraries? I found the gd bindings, but they're not very complete
18:44:38 <Pseudonym> With constraint-based type checking, in theory, it should be possible to narrow down exactly where those two parts are.
18:44:57 <Pseudonym> And report them better.
18:45:58 <Spark> principal typings are good for that too
18:46:15 <dons> @seen CosmicRay
18:46:15 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 3 hours, 53 minutes and 13 seconds ago, and .
18:47:16 <Spark> Main> foldl process [] [Push 3, Push 4, Op (+), Push 9, Op (*)]
18:47:16 <Spark> [63]
18:47:18 <Spark> :)
18:48:02 <Spark> does haskell have arrays?
18:48:11 <Pseudonym> Yup.
18:48:15 <Spark> how do they work
18:48:25 <Pseudonym> It depends what you want to do.
18:48:36 <Pseudonym> If you need immutable arrays, then it's easy.
18:48:56 <Spark> right
18:49:00 <Spark> converting a list to an array?
18:49:00 <Pseudonym> Incidentally, immutable arrays are more useful in Haskell than in other languages.
18:49:05 <Pseudonym> Because of lazy evaluation.
18:49:18 <Pseudonym> You can store unevaluated values in an array, which get evaluated when you read them.
18:49:34 <Spark> there are two things i really need to understand about haskell, lazyness and monads
18:49:40 <Pseudonym> You can trivially implement dynamic programming that way.
18:49:41 <Spark> the rest i should (in theory) all ready know
18:49:45 <Spark> up to nuances and syntax
18:50:00 <Pseudonym> Mutating an immutable array means creating a new array.
18:50:05 <Pseudonym> More or less.
18:50:08 <Spark> sure
18:50:11 <Spark> its just a tuple is uppose
18:50:12 <Spark> suppose
18:50:17 <Spark> an indexable tuple
18:50:22 <Pseudonym> Yeah, kind of.
18:50:32 <Spark> but the size is not part of the type, presumably
18:50:43 <Pseudonym> Now of course you can have arrays which store the most recent versions, plus "diffs" back in history.
18:50:49 <Pseudonym> So it's not as simple as "new array".
18:50:57 <Pseudonym> But this is detail.
18:51:05 <Pseudonym> Anyway.
18:51:12 <Spark> so can you do let x = array [1,2,3] in x[2]
18:51:25 <Pseudonym> If you need an efficient mutable array, you embed it in a monad.
18:51:30 <Pseudonym> That ensures that it's used linearly.
18:51:40 <Pseudonym> Spark: More or less, yes.
18:51:57 <Pseudonym> > array (1,3) (zip [1..3] [1,2,3]) ! 2
18:51:58 <lambdabot>  2
18:52:10 <Pseudonym> > let a = array (1,3) (zip [1..3] [1,2,3]) in a ! 2
18:52:11 <lambdabot>  2
18:52:15 <Pseudonym> @type array
18:52:16 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
18:52:23 <Pseudonym> Ix is a typeclass, as you can see.
18:52:27 <Pseudonym> It's the class of indices.
18:52:29 <Spark> right
18:52:34 <Pseudonym> @type (!)
18:52:35 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
18:52:35 <Spark> weaker than Num?
18:52:48 <Spark> actually are they really keys rather than indexes
18:52:51 <Spark> like perl, etc
18:52:52 <Pseudonym> Sure, because Double as an index makes no sense.
18:52:54 <Spark> using hashtables for arrays
18:53:14 <Pseudonym> But it makes sense for any enumerated type to be an index, for example.
18:53:35 <Pseudonym> So Int, Char, Bool etc are all instances.
18:54:07 <Spark> right
18:55:11 <Pseudonym> BTW, yes, I think the type of "array" is a bit dumb.
18:55:26 <Pseudonym> Having to pass a list of pairs seems silly.
18:56:07 <Spark> yeah
18:56:14 <Spark> there should be a wrapper for that
18:56:40 <Spark> something that took an argument like [1,2,3] and foldred it into [(1,1)...]
18:57:08 <Spark> foldl + rev actually i think
19:00:14 <Spark> is there something like a typedef in haskell?
19:00:18 <Spark> to create aliases of types
19:00:24 <Korollary> type a ...
19:01:39 <Spark> type Fish = Int -> Int ?
19:03:40 <Pseudonym> Yup.
19:03:54 <Pseudonym> type Fish a = a -> Int
19:03:55 <Spark> ah yes i was confused by an error later on
19:04:03 <Pseudonym> Quite useful.
19:04:16 <Spark> how do i import that array library
19:04:24 <monochrom> import Array
19:04:32 <Spark> heh
19:05:19 <palomer> nah, too simple
19:05:53 <monochrom> myArray (lo,hi) xs = array (lo,hi) (zip [lo..hi] xs)   -- is this what you would like?
19:07:00 <Pseudonym> Or even: myArray xs = let l = length xs in (1,l) (zip [1..l] xs)
19:07:04 <Pseudonym> For the case of Int.
19:07:05 <Spark> > zip [1,2,3]
19:07:05 <lambdabot>  Add a type signature
19:07:08 <Spark> argh!
19:07:14 <Pseudonym> > zip [1,2,3] "ABC"
19:07:15 <lambdabot>  [(1,'A'),(2,'B'),(3,'C')]
19:07:19 <Spark> ahhh
19:07:23 <Spark> thats what zip does
19:07:27 <Spark> fair play
19:07:42 <Spark> Pseudonym: yeah that one
19:07:54 <Spark> to mirror the c syntax of just {1,2,3}
19:08:00 <Spark> although i'd go from 0, probably
19:09:01 <Excedrin> > zip [1..] "what"
19:09:02 <lambdabot>  [(1,'w'),(2,'h'),(3,'a'),(4,'t')]
19:10:07 <monochrom> myArray2 lo xs = array (lo, toEnum(fromEnum lo + length xs)) (zip [lo..] xs)
19:10:41 <Spark> only you forgot the "array" :)
19:11:11 <monochrom> I didn't. But Pseudonym did.
19:11:21 <Pseudonym> Indeed I did.
19:12:01 <monochrom> Eh, listArray is not too bad.
19:12:18 <monochrom> @type Data.Array.listArray
19:12:19 <lambdabot> forall e i. (Ix i) => (i, i) -> [e] -> Array i e
19:16:52 <Pseudonym> OK, that's not bad.
19:19:30 <Korollary> Pseudonym: Do you know of any papers that talk about algebra vs coalgebra with regards to OO? I vaguely remember reading something about it, but I don't recall where.
19:19:44 <Pseudonym> Nope.
19:20:07 <monochrom> Some Bart Jacob(s) stuff?
19:20:16 <Pseudonym> I seem to recall Erik Meijer once commenting on his blog about the similarity between Java iterators and catamorphisms.
19:20:40 <Pseudonym> And I seem to recall thinking at the time that he was completely missing the point.
19:20:57 <Pseudonym> A Java iterator is a codata representation of a stream.
19:21:08 <Pseudonym> And OO programmers like codata, not catamorphsims specifically.
19:21:30 <monochrom> Ja.
19:21:33 <palomer> miss lebanon looks like she came straight out of france
19:22:04 <monochrom> "A Tutorial on (Co)Algebras and (Co)Induction", Bart Jacobs and Jan Rutten. http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf
19:23:14 <Korollary> Oh, that looks relevant. Thanks guys.
19:24:23 <palomer> codata in the sense of infinite streams?
19:24:58 <Pseudonym> Codata is the dual of data.
19:25:05 <Pseudonym> You make data, but you read codata.
19:25:15 <Pseudonym> More or less.
19:25:29 <palomer> you can't make codata?
19:25:36 <Pseudonym> Nope.
19:25:37 <palomer> you can't read data?
19:25:45 * Pseudonym thinks about that
19:25:50 <Pseudonym> Unsure.
19:29:08 <audreyt> you write code, but you read de?
19:29:09 <palomer> because you can write to iterators
19:29:18 <Pseudonym> In C++ you can.
19:29:59 <Pseudonym> C++ iterators are slightly different than Java iterators.
19:30:15 <Pseudonym> Which is why C++ has iterator categories.
19:31:43 <Korollary> Is there a mailing list like category-theory-cafe?
19:32:16 <Pseudonym> We really should make one.
19:33:38 <Korollary> This dumb exercise question bugs me and I couldn't think of a better answer.
19:33:44 <Spark> is it possible to define a function e.g. f :: Array Int Fish -> Fish   f a=Array (l,u) xs = if 4>u then blah else a!4
19:33:44 <JKnecht> @version
19:33:56 <Pseudonym> Well, ask here.
19:34:00 <Spark> so you're pattern matching, but also giving the whole argument a name
19:34:09 <lambdabot> lambdabot 3.1p35, GHC 6.4.1 (Linux i686 3.20GHz)
19:34:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:34:26 <Spark> more clear if i write f (a is Array (l,u)) xs = if 4>u then blah else a!4
19:34:32 <Pseudonym> Spark, yes, though I think you're a bit confused there.
19:34:36 <Pseudonym> Array isn't a constructor.
19:34:42 <Spark> ah is it not
19:34:51 <Spark> i'm not sure how it works to be honest
19:35:02 <Pseudonym> More like this: merge xs'@(x:xs) ys'@(y:ys) = if x < y then x : merge xs ys' else y : merge xs' ys
19:35:12 <Pseudonym> It's called an at-pattern.
19:35:30 <Spark> heh, in sml i think @ was used for list concatenation
19:35:30 <Spark> but ok
19:35:39 <Spark> how can i get the bounds of a given array?
19:35:40 <Pseudonym> I thought that was @@.
19:35:43 <Korollary> I can make a category out of a monoid where there's a single object (A), arrows are elements of the monoid : A -> A, the identity element stands for the identity arrow. With a group, I additionally get inverses of elements, but I can't make use of that to define a different category.
19:35:44 <Spark> i may be wrong
19:35:48 <Pseudonym> It's been ages since I used SML,t hough.
19:35:57 <Pseudonym> @google site:haskell.org Data.Array
19:35:58 <Spark> maybe it was prolog
19:35:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
19:36:06 <Pseudonym> Read and enjoy.
19:36:13 <Pseudonym> No, in Prolog it's append/3
19:36:22 <Pseudonym> In Prolog, append/3 is Turing-complete.
19:36:29 <Pseudonym> You get that impression, anyway.
19:36:54 <Spark> ah yeah
19:37:01 <Spark> what is the prepend operator in prolog 
19:37:05 <Spark> [H|T] isnt it
19:37:09 <palomer> sml uses @
19:37:21 <Pseudonym> Korollary: A group is a monoid except that every arrow has an inverse.
19:37:48 <Pseudonym> [H|T] or H.T
19:37:57 <Pseudonym> [H|T] is shorthand for '.'(H, T)
19:38:10 <palomer> there are other categories with monoids
19:38:12 <Pseudonym> palomer: OK, I stand corrected.
19:38:19 <palomer> the graph is a category
19:40:11 <Pseudonym> You can also think of group invers as a contravariant endofunctor.
19:40:16 <Pseudonym> inverse
19:41:53 <Korollary> Pseudonym: I can sorta follow what you're saying, but I'm just looking for a different category definition.
19:44:54 <Pseudonym> I don't see why.  "A <mathematical object> is a category with <restrictions>."
19:45:28 <Pseudonym> s/<mathematical object>/monoid/  s/<restrictions>/one object/
19:45:41 <Pseudonym> And similarly for "group".
19:46:57 <Korollary> Well, the reason is that the monoid was an example in the book, and the group is an exercise question that refers to that example. It just looks like too trivial an exercise question, so I am thinking perhaps there's a different answer. There may not be.
19:47:21 <Pseudonym> Ah, I see.
19:47:40 <Pseudonym> Well, that really is the whole story./
19:47:52 <Pseudonym> s/monoid/group/  s/endomorphism/automorphism/
19:47:54 <Pseudonym> Really.
19:48:15 <Spark> i now have a stack machine that can do arithmetic on integers, and also gotos
19:48:22 <Spark> if i added branches in, i'd have a basic cpu
19:48:28 <Spark> well, vm
19:48:38 <Pseudonym> No, you need GOSUB to be a true BASIC CPU.
19:48:50 <Spark> head -> desk
19:49:12 <Pseudonym> Actually, there is a one instruction set computer model.
19:49:17 <Spark> i've been doing this though:
19:49:19 <Spark> data ArithmeticInstruction = Push Int | Op2 (Int->Int->Int) | Op1 (Int -> Int)
19:49:19 <Spark> data Instruction = Arith ArithmeticInstruction | Goto Int
19:49:22 <Spark> which isnt very nice
19:49:25 <Pseudonym> The instruction is something like "subtract and branch if less than zero".
19:49:31 <Spark> because i end up with Arith (Push 4) and so on
19:49:35 <Pseudonym> Right.
19:49:48 <Pseudonym> s/Push/Op0
19:49:52 <Pseudonym> Just commenting.
19:49:58 <Spark> heh :)
19:50:25 <Spark> i didnt notice that patern
19:50:40 <Spark> (pattern)
19:51:14 <Spark> is there a better way to do that subtyping
19:51:22 <Spark> i'll pastebin the whole lot, hang on
19:51:28 <Pseudonym> Something that may also aid debugging is:
19:51:34 <Pseudonym> OpIO (Int -> IO ())
19:51:51 <Pseudonym> Or something.
19:52:22 <Spark> http://rafb.net/paste/results/YCZuK645.html
19:52:24 <Pseudonym> Maybe OpIO ([Int] -> IO ())
19:52:29 <Pseudonym> Give it the whole stack.
19:52:33 <Pseudonym> Or even the whole machine state.
19:55:24 <Spark> can i improve on that code?
19:56:04 <Pseudonym> First comment.
19:56:09 <Pseudonym> Don't overload "show", overload "shows".
19:56:15 <Pseudonym> @type shows
19:56:16 <lambdabot> forall a. (Show a) => a -> ShowS
19:56:32 <Pseudonym> type ShowS = String -> String
19:56:42 <Spark> hmm?
19:56:51 <Pseudonym> Example:
19:57:03 <Pseudonym> > shows 1 ""
19:57:04 <lambdabot>  "1"
19:57:15 <Pseudonym> > shows 1 . showChar ' ' . shows 2 $ []
19:57:16 <lambdabot>  "1 2"
19:57:16 <Spark> ah
19:57:20 <Spark> shows is the "deeper" version
19:57:31 <Pseudonym> The reason is that it avoids lots of (++)s.
19:57:38 <Spark> oh ok
19:57:39 <Pseudonym> So: shows (Push n) = shows n
19:57:46 <Pseudonym> shows (Op2 o) = showString "binary op"
19:57:51 <palomer> > shows 1 "1"
19:57:52 <lambdabot>  "11"
19:58:03 <Pseudonym> shows (Goto n) = showString "goto " . shows n
19:58:21 <Pseudonym> Using composition is more efficient than (++).
19:58:25 <palomer> shows a b = show a ++ b?
19:58:34 <Pseudonym> Yup.
19:58:45 <Pseudonym> > shows 1 "hello"
19:58:45 <palomer> and shows is derivable I'm guessing
19:58:46 <lambdabot>  "1hello"
19:58:51 <Spark> what does the . do there?
19:58:55 <Pseudonym> shows is a member of Show.
19:59:05 <Pseudonym> Spark, . is function composition.
19:59:08 <Spark> ahh
19:59:09 <Korollary> You compose functions that produce the strings instead of concatenating the strings
19:59:10 <Spark> "o"
19:59:16 <Pseudonym> Right.
19:59:28 <palomer> is this simply for efficiency reasons?
19:59:33 <palomer> or syntactic reasons?
19:59:35 <Korollary> Quite a clever idea
19:59:38 <Pseudonym> palomer: Efficiency.
19:59:53 <Pseudonym> (++) can be quite inefficient.
20:00:06 <palomer> oh, so someone who doesn't care about efficiency can ignore this
20:00:08 <Pseudonym> Often it doesn't matter, but when it matters, it realy matters.
20:00:13 <palomer> or if the compiler is good enough, it doesn't make a difference
20:00:22 <Pseudonym> The compiler won't help.
20:00:27 <Pseudonym> Really.
20:00:49 <Spark> ERROR "helloworld.hs":8 - No member "shows" in class "Show"
20:00:51 <palomer> the compiler could be like "better use shows instead of ++ here!", etc...
20:00:55 <Spark> yes, its still called helloworld.hs :)
20:01:42 <Pseudonym> Using ShowS and (.) instead of String and (++) can actually decrease the algorithmic complexity of showing.
20:01:49 <Pseudonym> Spark: Hmmm.
20:01:59 <Pseudonym> Actually, I think it's showsPrec that you need to override.
20:02:14 <Pseudonym> showsPrec _ (Op o) = showString "binary op"
20:02:21 <Pseudonym> showsPrec p (Push n) = showsPrec p n
20:02:27 <Pseudonym> @type showsPrec
20:02:28 <lambdabot> forall a. (Show a) => Int -> a -> ShowS
20:02:37 <Pseudonym> The integer argument is the "precedence".
20:02:41 <palomer> what the blazes does that do?
20:02:51 <Pseudonym> It's used for correctly rendering infix operators.
20:02:57 <Korollary> lambdabot shall have a command that displays standard class declarations.
20:03:02 <Pseudonym> It inserts parentheses if necessary.
20:03:23 <Pseudonym> > show (Just 2)
20:03:24 <lambdabot>  "Just 2"
20:03:29 <Pseudonym> > show (Just (Just 2))
20:03:30 <lambdabot>  "Just (Just 2)"
20:03:46 <Pseudonym> Ask yourself how you'd get the parentheses in the second example but not in the first.
20:04:03 * palomer is confused
20:04:04 <Pseudonym> Incidentally, this shows that:
20:04:27 <Pseudonym> Well, palomer, you write a Show instance for Maybe.
20:04:40 <Pseudonym> First attempt:
20:04:46 <Pseudonym> instance (Show a) => Show (Maybe a) where
20:04:51 <Pseudonym>     show Nothing = "Nothing"
20:05:01 <Pseudonym>     show (Just a) = "Just " ++ show a
20:05:03 <Pseudonym> Which would be wrong.
20:05:10 <palomer> right
20:05:16 <Pseudonym> Second attempt:
20:05:16 <palomer> I usually create a helper function showParen
20:05:25 <Pseudonym>     show (Just a) = "Just (" ++ show a ++ ")"
20:05:32 <dons> @seen dmhouse
20:05:32 <lambdabot> I saw dmhouse leaving #haskell 4 hours, 26 minutes and 59 seconds ago, and .
20:05:33 <Pseudonym> Which would be right, but inelegant for show (Just 2)
20:05:49 <palomer> so how do you fix it?
20:05:57 <Pseudonym> You use showsPrec
20:06:05 <Spark> this is standard for pretty printing of infix operators
20:06:16 <Pseudonym> And decide whether or not to put in parentheses based on the current precedence level.
20:06:42 <palomer> so if you're printing something of higher precedence then the current precedence, you put parenthesis?
20:06:50 <Pseudonym> Yup.
20:07:02 <Pseudonym> Function application binds the most tightly.
20:07:22 <palomer> I see!
20:07:32 <palomer> application = prec 0
20:07:36 <palomer> right?
20:07:42 <Pseudonym> Errr... yes.
20:07:55 <Pseudonym> I can never remember which way is up.
20:08:08 <Spark> when you recurse showsPrec over the argument x of a function, you call showsPrec 0 x ?
20:08:21 <Pseudonym> If high precedence == high binding == high number in "infixl" or if it's the otehr way around.
20:08:42 <Pseudonym> The dromedary has one hump / The bactrian has two. / Or is it the other way around; / I can't recall, can you?
20:09:09 <Spark> any other comments on the code?
20:09:15 <cpatrick> Someone should put this stuff on the wiki, with examples of showsPrec
20:09:30 <Korollary> cpatrick: That man is you!
20:09:34 <cpatrick> because while I new what the concept behind it was, I was never sure exactly what to do with precendences
20:09:39 * cpatrick sighs
20:09:41 <Pseudonym> Spark: Take a look at the Haskell report.  It has the rules for automatically deriving Show from a data declaration.
20:09:53 <cpatrick> Korollary: yeah, probably
20:09:56 <Spark> mmk
20:10:04 <Spark> Pseudonym: any advice on the datastructures in the code itself though?
20:10:07 <Pseudonym> Oh, and take a look at the Prelude, too.  There are a couple of explicit instances, too.
20:10:15 <palomer> well, now I know how terms are pretty printed
20:10:18 <palomer> I've always half assed it
20:10:48 <Pseudonym> Spark, one more comment.
20:10:59 <Pseudonym> Actually, two comments.
20:11:07 <Pseudonym> 1. Don't overload the symbol "exec"!
20:11:26 <Pseudonym> Standard Haskell idiom is to call the wrapper "exec" and the worker "exec'"
20:11:38 <Pseudonym> exec instructions = exec' [] instructions 0
20:11:46 <Pseudonym> where
20:11:51 <Pseudonym>     exec' s instrs i = ...
20:11:58 <Spark> mmk
20:12:03 <Pseudonym> Second comment.
20:12:19 <Pseudonym> The if-then-else in what is now called exec' is better expressed with guards.
20:12:24 <Pseudonym> exec' s instrs i
20:12:30 <Pseudonym>     | i < lower || i > opper = s
20:12:50 <Pseudonym>     | otherwise = case instrs ! i of { ... etc ... }{
20:12:56 <Pseudonym> Sorry, stray { there.
20:13:20 <Spark> is that generally true of if then else blocks?
20:13:21 <scodil> is the source for the prelude somewhere on the web? Or do i have to download the source for ghc or hugs?
20:13:29 <Spark> (that are at the root of function bodies)
20:13:40 <Pseudonym> scodil: There's a reference implementation in the Haskell language report.
20:13:44 <Korollary> scodil: The report has it
20:13:48 <scodil> ah great. thanks
20:13:50 <Pseudonym> Spark: It depends on context.
20:14:06 <Pseudonym> Like every language, there's more than one way to express something.
20:14:19 <cpatrick> Pseudonym: except Python :P
20:14:22 <Pseudonym> :-)
20:14:29 <Pseudonym> You could even express it as:
20:14:37 <Pseudonym> case i < lower || i > upper of
20:14:44 <Pseudonym>     True -> s
20:14:47 <Pseudonym>     False -> ...
20:14:55 <Pseudonym> Which makes the most sense depends on context.
20:15:15 <cpatrick> Pseudonym: are guards just syntactic sugar for nested case statements?
20:15:18 <Pseudonym> I find guards more readable if either the "then" case or the "else" case are large expressions.
20:15:42 <Pseudonym> cpatrick: In GHC that's true.
20:15:45 <Pseudonym> > otherwise
20:15:46 <lambdabot>  True
20:15:47 <Korollary> cpatrick: That's in the report somewhere. I think s.
20:15:49 <Korollary> so.
20:16:03 <cpatrick> if there are several conditions to check, guards look prettier.
20:16:06 <Pseudonym> I'm not sure if if-then-else is sugar or core in the Haskell report.
20:16:13 <Pseudonym> But GHC translates it to case statements.
20:17:00 <Spark> mm
20:17:22 <Pseudonym> Oh, one other thing.
20:17:49 <Pseudonym> You don't actually need to pass the InstructionArray to what is now called exec'
20:18:07 <Pseudonym> (And you don't need to compute (lower,upper) in there either.)
20:18:08 <Korollary> Pseudonym: The report says it is equivalent to a case expression.
20:18:13 <Pseudonym> Korollary: Right.
20:18:32 <Spark> ah yes the instructions are immutable
20:18:39 <Spark> no point threading it through like that
20:19:03 <Spark> what about lower and upper?
20:19:16 <Spark> just put that clause in the scope of exec?
20:19:30 <Pseudonym> Yeah, move it up one level to the enclosing where clause.
20:19:38 <Pseudonym> That, by the way, is called "let floating".
20:19:45 <Pseudonym> A where clause is more or less a let-expression.
20:20:24 <Spark> yeah
20:20:31 <Spark> its just postfix rather than prefix
20:20:39 <Pseudonym> And you're "floating" the let expression to an outer level.
20:20:58 <Pseudonym> It's equivalent, more or less, to loop-invariant code motion in a conventional language.
20:21:22 <Pseudonym> While GHC would optimise it in practice, in theory you're computing "lower" and "upper" on every loop iteration in exec'.
20:21:29 <Pseudonym> Floating the let moves the code out of the loop.
20:21:44 <Pseudonym> Isn't that nice?
20:22:01 <Spark> surely thats optimised though
20:22:09 <Spark> ah yes you said that
20:22:24 <Spark> surely its best to keep the scope as minimal as possible
20:22:27 <Pseudonym> With some technical caveats, yes it is.
20:22:45 <Pseudonym> And it turns out that the code as you originally wrote it is precisely one of those technical caveats.
20:22:59 <Pseudonym> Because it depends on an _argument_ of exec'.
20:23:03 <Spark> yeah
20:23:07 <Spark> not being changed in the recursion
20:23:11 <Pseudonym> Right.
20:23:16 <Pseudonym> But the compiler can't spot that.
20:23:20 <Spark> can't it?
20:23:25 <Pseudonym> Uhm...
20:23:26 <Pseudonym> Well, it could.
20:23:28 <Pseudonym> But it doesn't.
20:23:39 <Pseudonym> Complicated to explain why.
20:23:41 <Spark> if it can spot tail recursion it should spot that :)
20:24:04 <Pseudonym> But it's to do with some technical stuff related to how GHC compiles lambdas.
20:24:13 <Spark> ah right
20:24:28 <Pseudonym> And it applies to specifics of the code you wrote.
20:24:37 <Pseudonym> In other circumstances, it would indeed be spotted.
20:24:45 <Pseudonym> Oh, one more thing.
20:25:05 <Pseudonym> And this doesn't relate to your code as it now looks since we've fiddled with it.
20:25:13 <Spark> yeah
20:25:18 <Spark> because we removed the argument in question
20:25:27 <Pseudonym> In general, it's a good principle to order your function arguments in rough order of "constancy".
20:25:40 <Pseudonym> The InstructionArray is constant, so it should go first.
20:25:54 <Pseudonym> Things which change more rapidly should go further to the right.
20:26:15 <Pseudonym> There's a precise technical definition of this, by the way.
20:26:21 * dons notes lambdabot has 73 .hs modules
20:26:31 <dons> [70 of 73] Compiling Plugin.System
20:26:32 <dons> ...
20:26:55 <Pseudonym> The details are unimportant right now.
20:27:06 <Pseudonym> But it's a good rule of thumb,.
20:27:13 <Spark> right
20:27:18 <Pseudonym> Something which changes every iteration should be on the right.
20:27:25 <Pseudonym> Something which changes more rarely should be on the left.
20:27:41 <Spark> that makes it easier to read, if anything
20:27:46 <Pseudonym> Sure,.
20:28:13 <Korollary> Pseudonym: It appears that the exact paper I'm looking for is titled "An Approach to Object Semantics based on Terminal Co-Algebras". I can't find it online, though.
20:29:35 <Spark> right, thanks for the advice
20:29:38 <Spark> i have to go to bed now
20:29:49 <Pseudonym> Night.
20:29:58 <scodil> anyone know of an simple example program that uses the ST monad?
20:39:28 <dons> scodil: perhaps check the /Lazy Functional State Threads/ paper? its linked on haskell.org's Research/monads page, iirc.
20:40:13 <scodil> thanks
21:17:52 <mathewm> :type world#
21:17:59 <mathewm> ?type world#
21:18:00 <lambdabot> Not in scope: `world#'
21:19:13 <Korollary> that doesn't look like an expression.
21:19:43 <mathewm> reading up on early monad's/IO
21:19:57 <Pseudonym> ?type RealWorld#
21:19:58 <lambdabot> Not in scope: data constructor `RealWorld#'
21:19:59 <Pseudonym> ?type RealWorld
21:20:00 <lambdabot> Not in scope: data constructor `RealWorld'
21:20:05 <Pseudonym> What's it called now?
21:20:17 * mathewm shrugs
21:21:41 <Lemmih> RealWorld isn't a data constructor.
21:22:21 <SamB> ?type GHC.IOBase.IO
21:22:22 <lambdabot> forall a. (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)) -> IO a
21:23:21 <mathewm> GHC.Prim.State# is an unboxed type?
21:24:16 <SamB> it is an unrepresented type - it not only has no box, it has no bytes
21:25:03 <mathewm> *something* has got to implement that abstract type at some point...
21:25:10 * mathewm doesn't beleive in ghosts
21:26:11 <mathewm> or spelling...
21:26:23 <SamB> it is implemented
21:26:29 <SamB> it is implemented as nothing at all
21:27:01 <dons> its primitive , wired into the compiler
21:27:08 <SamB> its no harder than implementing it as some typedefed type or other in C ;-)
21:27:11 <dons> just a magical ghostly symbol
21:27:27 <dons> if we had: data X :: #
21:27:33 <dons> we'd not need it to be magic
21:27:41 <dons> but we only can write: data (X :: *)
21:28:59 <dons> ooh, interesting, "Formal Model of an ARM Microprocessor in Isabelle/HOL"
21:29:23 <lispy> formal model?
21:29:35 <lispy> i sort of thought that the specification would count as a formal model already
21:29:52 <dons> you can't prove things on the spec.
21:30:03 <SamB> what sort of spec did you mean?
21:30:11 <SamB> if it was in Z, maybe it would count
21:30:12 <dons> This thesis provides two ARM version 5 architecture models in the theorem
21:30:12 <dons> prover Isabelle/HOL. The first is created by hand --- translating the
21:30:12 <dons> official ARM architecture specification into higher order logic (HOL),
21:30:12 <dons> while the second is mechanically generated from the processor specification
21:30:13 <dons> abstract syntax tree 
21:31:10 <SamB> oh, so the spec *does* count as a formal model (though maybe only if you also include the translator)
21:31:25 <dons> its the model. but not one you can mechanically reason on
21:31:36 <lispy> so formal model is one that can be verified by a computer?
21:31:59 <mathewm> formal as in formula
21:32:23 <lispy> so just remove the ul, aka user license? ;)
21:32:34 <lispy> (well and reorder)
21:32:51 * lispy just realized that didn't make sense
21:33:11 <lispy> if you did what i said you'd have forma at best
21:33:48 <mathewm> http://en.wikipedia.org/wiki/Formal_methods
21:34:44 <mathewm> i wonder if there are Isabelle/HOL ports to Haskell
21:34:58 <dons> there are some moves to model Haskell code in Isabelle.
21:35:08 <dons> i.e. the recent L4/Haskell microkernel spec
21:41:43 <Pegazus> hi, anyone familiar with lr parsers, specially the concepts of handle, valid prefixes, items, and all those things?
21:50:20 <sethk> Pegazus, somewhat, although it's been quite a while since I worked with parsers extensively.  Do you have specific questions?
21:50:31 <Pseudonym> Pegazus: Yes.
21:50:38 <Pseudonym> Go ahead and ask.
21:50:43 <scodil> how would I go about finding the type of an expression or function thats burried deep in my program? Its too big to feed into hugs or ghci. unless there's some special mode i'm not aware of
21:50:44 <sethk> Pegazus, it's always better to ask specific questions.  Then lot's of people will see the questions and some will answer
21:51:29 <Pseudonym> Especially since we like theory here.
21:51:35 <Pseudonym> And LR parsing is interesting theory.
21:57:43 <bringert> scodil: how is it too big to load into ghci? ghci can load compiled code (hi + o files) btw, just make sure that the function that you are interested in is exported
21:58:29 <scodil> bringert: ok, so if i load it up in ghci, what do I run at the top level to examine the type of a function?
21:58:43 <bringert> :t myFunction
21:58:47 <dons> bringert: you where having trouble with ByteString yesterday?
21:58:50 <scodil> ah cool. thanks
21:58:55 <dons> did it turn out to be a bug? or was something else?
21:58:55 <bringert> dons: I was?
21:59:05 <dons> or shapr was?
21:59:07 <bringert> ah
21:59:28 <bringert> it went away went we stopped using +RTS -c
21:59:38 <dons> ah! so a ghc bug! much better then ;)
21:59:40 <bringert> I don't know if it was ByteString's fault
21:59:47 <bringert> very obscure thing
22:00:02 <dons> well, hmm. the compacting collector had a bug fixed just yesterday, i think.
22:00:11 <dons> or could be something obscure, indeed
22:00:22 <dons> well, let me know if it ever turns up again.
22:00:58 <bringert> it happpend if you would pack a string larger than ~235 chars after doing an insert using HaskellDB's HDBC PostgreSQL backend, running with +RTS -c
22:01:27 <bringert> probably some other contributing factors too
22:02:54 <bringert> it took shapr and and me hours to figure out that the compacting garbage collection seemed to be the culprit
22:03:34 <bringert> I had tried to be clever and compiled in RTS options for reduced memory use, and forgot about that when we hunted for the bug
22:04:31 <Pegazus> i've some doubt about wich are those things (handles, items, and all that stuff) and how to recognize them given a grammar...
22:06:31 <dons> ah, i had a similar problem recently, i compiled in rts options that broke under 6.5
22:06:36 <dons> my app would just exit on start up
22:06:51 <dons> lesson, you can't use -threaded with -G0 anymore
22:06:58 <dons> or was it -G1
22:07:08 <bringert> it worked fine for me under ghc-6.5, and under 6.4.1, but for shapr it broke on 6.4.1
22:07:28 <dons> sigh. bugs. 
22:13:07 <goltrpoat> @pl \l n -> ((l !! n) !!)
22:13:07 <lambdabot> ((!!) .) . (!!)
22:14:43 <psi> can you not put guards on lambdas?
22:15:12 <dons> i don't believe so
22:15:24 <dons> ?type \x | x == 1 -> x
22:15:25 <lambdabot> parse error on input `|'
22:15:30 <dons> you must use case
22:15:42 <psi> ok
22:16:18 <goltrpoat> dons:  any plans for that in haskell'?
22:16:52 <Lemmih> goltrpoat: No.
22:16:59 <scodil> how do you run a function of type "a -> ST s a" in the IO monad? (ie, from main)
22:17:22 <scodil> there's stuff like unsafeIOToST, but how do I use that
22:17:55 <dons> don't you just want to runST
22:18:00 <dons> ?type runST
22:18:01 <lambdabot> Not in scope: `runST'
22:18:20 <dons> ?hoogle runST
22:18:20 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
22:18:20 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
22:18:20 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
22:18:33 <Lemmih> ?type Control.Monad.ST.stToIO
22:18:34 <lambdabot> forall a. GHC.ST.ST GHC.Prim.RealWorld a -> IO a
22:18:48 <dons> or that's better.
22:19:03 <Cale> @type Control.Monad.ST.runST
22:19:04 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
22:19:21 <Cale> You can run it in IO, but it's generally unnecessary
22:19:21 <sethk> does anyone else see a problem where using gvim (== vim -g) a newline is added to a .hs file each time it is saved?
22:19:24 <dons> ?type return (Control.Monad.ST.runST $ undefined) :: IO ()
22:19:24 <lambdabot>   Inferred type is less polymorphic than expected
22:19:25 <lambdabot>   Quantified type variable `s' escapes
22:19:30 <dons> oh, yeah.
22:19:42 <dons> sethk: there's some flag to switch off that behaviour, iirc
22:19:57 <sethk> dons, did you get a chance to think about my type question with making the compiler aware of the pairing of request with response in our client/server classes?
22:20:07 <Cale> sethk: does the file get longer and longer?
22:20:08 <dons> ah, still sitting in my inbox. sorry :/
22:20:14 <scodil> I'm just trying to run this thing at all. anywhere. main seemed like a good place to do it
22:20:23 <sethk> Cale, yes, it accumulates blank lines at the end
22:20:34 <Cale> scodil: let result = runST (mySTComputation ...)
22:20:48 <sethk> dons, not a big thing, really, but I suspect there is a clever solution that I'm not seeing.  :)
22:21:41 <sethk> dons, but I want, if possible, to keep the flexibility of having a request produce more than one response
22:21:50 <scodil> Cale: Inferred type is less polymorphic than expected
22:21:50 <scodil>       Quantified type variable `s' escapes
22:21:50 <scodil>     In the first argument of `runST', namely `(stdlList [1, 2, 3])'
22:21:59 <dons> right. with a functional dependency, you could force a 1:1 connection
22:22:02 <sethk> dons, (for example, in my database stuff, where I'm returning data that satisfies a query but I don't want to return all the data at once)
22:22:05 <scodil> thats for "let x = runST( stdlList [1,2,3] )
22:22:19 <sethk> dons, right, so I'm trying to find a cure that isn't worse than the disease  :)
22:23:11 <sethk> dons, I know there is a flag (getting back to vim) that says something like "make sure file ends with a newline"
22:23:21 <scodil> stdlList is of type " [a] -> ST s (STDList s a) "  so maybe that second s is whats cause the problem?
22:23:36 <sethk> dons, but that shouldn't be adding newlines to a file that already ends in newline.  could just be a vim bug
22:25:52 <dons> could be. it should't add more than 1 anyway
22:27:40 <sethk> dons,  on the request/response issue, perhaps I should do the simple thing of relating a request to a response, and then creating a new request; in my database example, I'd create a new request, something like "give me more data".
22:27:46 <sethk> dons, however, that's only one issue
22:28:12 <sethk> dons, is it important to allow a particular request to return one of a set of responses?
22:28:52 <sethk> dons, probably in general not.  You can always use an enumerated value in the response to do what you might instead do by chosing a response; I'm thinking of a request that has a normal response and an error response
22:29:07 <sethk> instead, you can have a response, and that response can have a field that says normal/error
22:29:18 <sethk> dons, but I think that makes the response type cluttered in general
22:29:50 <sethk> dons, If I have a normal response that includes some data, and an error response that does not, then I would be cluttering the error response with (presumably unpopulated) data
22:29:59 <sethk> dons, which is not conducive to clean code
22:30:10 <dons> right.
22:30:29 <sethk> dons, as I think about it, I can see good arguments for various ways of doing it.
22:31:08 <sethk> dons, now, if the response is just an ADT with different constructors, that sort of messes up our definition of a response class.
22:31:31 <sethk> dons, I don't quite see how to fit the concept of a class, like the response class, with a type that has constructors with different fields
22:31:58 <sethk> dons, anyway, I'll continue to think about it; if you have any brilliant suggestions I'll be happy to steal them.
22:32:50 <dons> right. you want to lift the constructors to types, perhaps.
22:33:02 <dons> the more info you encode in the type, the better
22:33:21 <sethk> dons, right.
22:42:43 <psi> anyone had c2hs get the types of a foreign import wrong? I must pass a Ptr TagList to a function but that argument is Ptr () in the import declaration.
22:43:19 <scodil> if my data type is parameterized on a state s, because say it contains STRefs, can I ever bring values of that type into another monad like IO? Is there a way to use IO as the state parameter?
22:44:39 <lispy> scodil: i think so....
22:44:50 <lispy> @type liftIO
22:44:51 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
22:45:19 <lispy> you can lift  your state monad code into the IO monad
22:45:26 <scodil> how do i do that?
22:46:52 * lispy points at liftIO
22:46:58 <lispy> @index liftIO
22:46:58 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:50:58 <scodil> so, this reference documentation, it tells me what all the types are, but where would I go to find an example usage of a given function?
22:51:51 <scodil> google is failing me
22:52:13 <Korollary> You probably can't find an example for every function. just like for other languages.
22:52:25 <SamB> @hoogle stToIO?
22:52:26 <lambdabot> Did you mean: StToIO?
22:52:26 <lambdabot> Prelude.undefined :: a
22:52:26 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
22:52:28 <SamB> @hoogle stToIO
22:52:29 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
22:52:44 <dons> use ?type to work out a template for which arguments you need. then fill in the blanks
22:52:48 <dons> or ?hoogle
22:53:14 <SamB> dons: stop ?that! it looks bad.
22:53:20 <scodil> Korollary: this is true.... but you've got to admit, the reference docs are a bit terse in places
22:53:31 <scodil> like, whole pages without any complete sentences
22:53:32 <dons> SamB :P
22:53:47 <adu> hi
22:53:49 <sethk> scodil, complete sentences are overrated
22:53:52 <dons> @ is much noisier. and ? is a question. its perfectly acceptable
22:54:07 <SamB> even PERL doesn't use ? as a sigil, does it?
22:54:14 <scodil> sethk: not if you don't speak the language fluenty
22:54:27 <sethk> scodil, I wasn't being serious
22:54:35 <scodil> i know 
22:54:38 <scodil> i was kidding 
22:55:09 <scodil> by language i meant haskell, not english
22:58:04 <palomer> someone remind me how to copy a repository somewhere
22:58:15 <SamB> rsync!
22:58:17 <lispy> scodil: look at the nomaware tutorial...is that right spelling?
22:58:22 <SamB> or darcs get, or darcs put
22:58:29 <lispy> palomer: put or get
22:59:35 <palomer> which one???!?
22:59:53 <SamB> the appropriate one
23:00:06 * palomer slaps samb
23:00:23 <SamB> well, if you want to copy it down from a server, you use get
23:00:31 <SamB> if you want to copy it up to a server, you use put
23:00:41 <palomer> the repo is local
23:00:48 <SamB> if you would like to push, but the repo isn't there yet, use put
23:01:28 <SamB> if you would like to pull into a repo that is not there yet, use get
23:02:21 <palomer> what's the difference between pull and push?
23:03:36 <SamB_XP_> pull merges patches into the working directory, push merges them into whatever other repository
23:05:32 <SamB_XP_> so, wherever you are hacking, you'll probably want to push from there to the other place
23:08:22 <SamB_XP_> (and pull to there, too)
23:09:37 <scodil> i give up. you've beaten me, haskell
23:21:01 <goltrpoat> http://www.rafb.net/paste/results/Ac11ZI47.html --> getPieceMoves is memoized, correct?  
23:21:43 <goltrpoat> or rather, the result of moves is
23:23:28 <goltrpoat> as in, i'm not calling map every time i call getPieceMoves ! blah
23:23:53 <Korollary> No
23:24:07 <goltrpoat> which? :)
23:24:26 <Korollary> Memoization applies to functions that take arguments, right?
23:25:20 <Korollary> getPieceMoves is a constant, so it shouldn't be computed more than once.
23:25:27 <goltrpoat> i assumed the affact that array is immutable meant the element gets constructed the first time i index it, and then it's just looked up afterwards
23:25:50 <goltrpoat> er.
23:25:59 <goltrpoat> i'm not sure how "affact" came about.  i meant fact.
23:26:21 <Korollary> Yes
23:26:31 <goltrpoat> k cool, thanks
23:51:08 <revision17_> @hoogle failWith
23:51:08 <lambdabot> System.Win32.Types.failWith :: String -> ErrCode -> IO a
23:51:21 <vincenz> re
23:51:37 <vincenz> Cale: ping
23:52:36 <revision17_> @hoogle LibSystem
23:52:37 <lambdabot> No matches found
23:53:51 <revision17_> @hoogle openChannel
23:53:51 <lambdabot> No matches found
