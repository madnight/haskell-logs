00:03:38 <vincenz> hmm
00:03:38 <vincenz> funky
00:03:43 <vincenz> curry comes with a weblib
00:04:45 <Korollary> When is the icfp contest?
00:04:52 <vincenz> 21-24 july
00:04:53 <vincenz> chec
00:04:59 <vincenz> http://notvincenz.com/
00:05:03 <vincenz> ICFP'06
00:12:56 <vincenz> Re
00:12:59 <vincenz> damn
00:13:02 <vincenz> typed wrong command
00:15:58 <goltrpoat> how good an idea is it to use Array.(//) when you're more or less expecting to be doing that about a million times a second?
00:16:13 <goltrpoat> in terms of space leaks
00:16:18 <vincenz> goltrpoat: I would Set would be more ideal, no?
00:16:44 <vincenz> s/Set/think Set/
00:16:53 <goltrpoat> well, it's a fixed size array
00:17:17 <goltrpoat> moving board state around in a chess program, basically
00:17:51 <kzm_> @seen dons
00:17:51 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 23 minutes and 58 seconds ago.
00:18:13 <vincenz> @hoogle (Array.//)
00:18:14 <lambdabot> Hoogle Error: Parse Error: Unexpected character '//)'
00:18:19 <vincenz> @hoogle Array.(//)
00:18:19 <lambdabot> Hoogle Error: Parse Error: Unexpected character '//)'
00:18:24 <vincenz> @hoogle (//)
00:18:25 <lambdabot> Did you mean: (//)
00:18:25 <lambdabot> Prelude.undefined :: a
00:18:25 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
00:18:40 <goltrpoat> odd
00:18:56 <kzm_> Now that BS is part of GHC (6.5), what do I do to build my own version?
00:19:16 <kzm_> (I get a conflict, since BS is in base-1.0 as well)
00:19:20 <vincenz> oh
00:19:36 * Korollary thought there was some bull**** in GHC for some reason
00:19:39 <vincenz> goltrpoat: I was confusing it with removal
00:20:40 <Korollary> goltrpoat: You'll be updating that array a lot, yes? Perhaps a mutable array instead?
00:22:54 <goltrpoat> i'm not fully sure how the whole freezing/unfreezing thing works
00:23:30 <goltrpoat> the thing is that let's say you have your array when you start the search.  you then want to make n copies of it, and pass them down the tree
00:23:42 <goltrpoat> passing a reference doesn't work, since you want to hang on to the original version
00:24:18 <goltrpoat> so in a sense, each array is immutable during its lifetime
00:25:22 <Korollary> You can make copies and pass that over
00:25:51 <Korollary> It's not a big structure to be copied
00:27:10 <Korollary> which is what freeze does. unsafeFreeze is the tricky one.
00:27:15 <goltrpoat> yah, it's a tiny structure, but there's a ridiculous number of copies hanging around at any given time :)
00:27:47 <goltrpoat> (but yeah, you basically have to make copies whatever you do, i was just curious about what exactly happens when you use // )
00:28:07 <goltrpoat> but freeze takes a mutable array to an immutable one, no?
00:28:16 <Korollary> there should be only one copy however many times you pass it around
00:28:43 <Korollary> freeze creates an immutable array from a mutable one. a separate copy.
00:29:00 <goltrpoat> in the search tree, it's as many copies as it is deep.  but then you also end up hashing positions for transposition lookup, which is where i get the "ridiculous number of copies" bit
00:29:36 <Korollary> I don't know what a search tree looks like.
00:30:04 <Korollary> does a search tree node have a full board?
00:30:25 <goltrpoat> so then the idea is.. get an immutable array, thaw, update, freeze to make a copy, pass it on?
00:30:36 <goltrpoat> yeah
00:30:56 <Korollary> do you want to be able to modify the boards in the nodes?
00:31:09 <goltrpoat> yes, that's the purpose of the nodes
00:31:34 <goltrpoat> basically, each node makes a single move.
00:31:39 <Korollary> I see
00:31:40 <goltrpoat> and updates various state
00:32:52 <Korollary> Ok, but do you set up the board once for every move, or do you transform the tree after it's constructed as well?
00:32:57 <goltrpoat> it's typical to evaluate tens of millions of nodes, right.  so that's tens of millions of copy operations (neglecting transposition tables etc).
00:34:25 <goltrpoat> the node operation is to take the current board, pick a set of moves, make those, and call itself recursively.
00:34:39 <goltrpoat> er.. make those in order, i mean.  try this, nope, try that, nope, how about this one.
00:35:11 <vincenz> sudoku?
00:35:15 <goltrpoat> chess
00:35:31 <Korollary> It looks like a space optimized version of the tree of all legal board states.
00:35:32 <vincenz> may I propose something?
00:35:47 <goltrpoat> of course
00:35:52 <vincenz> goltrpoat: instead of taking a board-centric approach, why not take a piece-centric approach
00:36:12 <goltrpoat> you mean, instead of associating a piece with each square, associate a square with every piece?
00:36:16 <vincenz> yep
00:36:21 <goltrpoat> unfortunately that makes a lot of common queries difficult
00:36:26 <vincenz> such as?
00:36:34 <goltrpoat> such as "what can i capture from e5"
00:36:39 <vincenz> oh
00:36:47 <vincenz> well you can go over the opponents pieces
00:36:55 <vincenz> that's 16 pieces at the most
00:37:05 <vincenz> I think that's as much as the number of squares you have to check
00:37:12 <vincenz> unless you're in a corner
00:37:15 <goltrpoat> yeah but that's a linear search over the pieces, instead of a constant time lookup (there are a lot of tricks here)
00:37:27 <vincenz> oh
00:37:56 <vincenz> but you have high cost for array copies
00:37:58 <vincenz> so...
00:38:00 <vincenz> you can compare it
00:38:06 <vincenz> write the two versions and profile
00:38:18 <goltrpoat> some people keep both representations around, but i think the general consensus is that board-centric representations make the most sense
00:38:39 * vincenz nods
00:38:40 <Korollary> I believe the scoring algorithms also work on the board
00:38:41 <vincenz> alright
00:38:47 <vincenz> just worth a shot ;)
00:39:58 <Korollary> goltrpoat: it looks like you can construct one tree with immutable arrays in the nodes, pick a node as the next move, then build a new tree with that node as the starting state?
00:40:46 <goltrpoat> yeah that's exactly what i was about to do
00:41:19 <Korollary> most nodes will have slightly different boards anyway
00:42:08 <goltrpoat> i guess i'll see how it goes and optimize later
00:42:50 <Korollary> What's inefficient about it anyway?
00:46:09 <goltrpoat> well.. it's not that anything in particular is inefficient, i'm just trying to figure out how i can structure it so that i translate the usual optimization tricks to haskell without too much pain
00:46:45 <goltrpoat> later on i mean
00:47:05 <goltrpoat> one typical thing is to use bitboards -- one 64 bit integer representing the board state for some particular query
00:47:26 <goltrpoat> i.e. all white pawns, or all squares attacked by black pieces, or board coverage, etc
00:47:57 <goltrpoat> so the board representation is usually 12 64-bit integers, which is a far cry from Array (Int,Int) (Color, Piece)
00:48:06 <goltrpoat> mostly just trying to figure out how to abstract it.
00:48:56 <goltrpoat> it's one of those things where premature optimization is somewhat of a necessity, because otherwise you'll be waiting an hour for your unit tests to complete
00:50:20 <goltrpoat> actually.  it's not 12 64-bit integers.  it's 12, plus 12 boards rotated 90 degrees, plus another 24 rotated 45 and 135 degrees each, plus hash keys, plus en passant and castling state, plus principal variation, plus various other crap.
00:50:55 <Korollary> what is with the rotated boards?
00:51:17 <goltrpoat> they speed up some queries
00:51:43 <goltrpoat> on a normal board, you can extract a single file as an 8-bit integer and use it to index into a lookup table
00:51:50 <goltrpoat> so you want to do the same thing for ranks and diagonals
00:51:59 <Korollary> I see
00:52:14 <Korollary> do you have a fairly fast computer?
00:52:31 <goltrpoat> yeah
00:52:38 <goltrpoat> a 2ghz pentium m
00:52:48 <vincenz> Korollary: looked at that website I told you?
00:52:53 <Korollary> vincenz: ?
00:53:06 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
00:53:40 <vincenz> goltrpoat: I have to say that if it takes long for unit tests, then those are not unit tests
00:53:52 <vincenz> goltrpoat: I fear, in addition, you'll want an FFI for the 64bit boards
00:54:24 <Korollary> vincenz: that's not quite correct.
00:54:31 <vincenz> Korollary: which bit?
00:54:36 <Korollary> The unit test bit
00:54:53 <vincenz> Korollary: I think it is, if they're bigger, they're functional tests/integration tests
00:55:14 <Korollary> I don't think he means cross-component. It's the execution time.
00:55:17 <goltrpoat> i was actually just curious how far i can get in haskell alone.  maybe port some stuff to C/C++ if i identify a bottleneck that can be easily ported, but this is mostly just an exercise
00:55:58 <Korollary> so in theory you can have a single, isolated unit that does something that is very cpu intensive. It's still a unit test.
00:56:01 <goltrpoat> by a unit test i mean, stuff like make it play ten games against itself and record the hash table hit/miss ratio
00:56:07 <vincenz> Korollary: no
00:56:18 <vincenz> Korollary: that's a functional test
00:56:35 <vincenz> Korollary: but then again, there are no formal definitions, so it's mostly rule-of thumbs
00:56:41 <vincenz> so we acn agree to disagree :)
00:56:50 <goltrpoat> unit test to me means a way to verify that things are working as expected in an automated fashion
00:56:59 <Korollary> It depends whether the unit is divisible any further
00:57:25 <vincenz> goltrpoat: yeah but if you read most documents on RAD or XP, the rule-of-thumb is that unit tests are in the order of seconds
00:57:51 <vincenz> Korollary: if it's that long, then that unit is too big and needs to be split for good design
00:58:17 <vincenz> but again, there are no formal definitions, so we can agree to disagree
00:58:19 <palomer> XP looks like a squinting fellow with a half paralyzed mouth
00:58:50 <goltrpoat> vincenz:  in this case, it can't be split though :)
00:59:04 <goltrpoat> (the hash table thing i was talking about i mean)
00:59:04 <Korollary> goltrpoat: does it have to play a full game?
00:59:15 <vincenz> goltrpoat: yeah but a unit test would test a single move, not a whole game
00:59:19 <goltrpoat> no, but it has to make enough moves to determine what's happening to the transposition table
00:59:21 <vincenz> goltrpoat: functional test would test a whole game
00:59:40 <goltrpoat> but testing a single move is useless for this purpose
00:59:47 * vincenz shrugs
01:00:11 <palomer> @palomer
01:00:12 <lambdabot> Hrmph, looks like I killed the channel
01:01:02 <Korollary> goltrpoat: does the transposition table have an interface? Perhaps you can record the moves once and play them back through the interface in your tests instead of computing the moves every time.
01:02:19 <Korollary> my ipod nano has a chess program. I say a haskell version on a pentium should be able to beat it.
01:02:35 <vincenz> :D
01:03:29 <goltrpoat> well.. it's typically a fixed size two or three layer hash with some heuristics on when to replace a position, stuff gets erased pretty quickly
01:03:48 <goltrpoat> i remember trying to extract move history from the hash table instead of keeping it around, and it'd go about five moves deep
01:04:20 <goltrpoat> actually..  is that what you were talking about?  i may have misread
01:05:25 <Korollary> yes. pound that table with prerecorded moves instead of generating moves live during the test run.
01:06:11 <goltrpoat> ohh i see what you mean
01:06:41 <goltrpoat> no, the whole idea is that it stores stuff while it's searching and evaluating positions
01:07:11 <goltrpoat> i.e. 99% of the positions in the transposition table never take place, they're just there in case they are encountered again during the search (eg, on the next move), so that you don't have to evaluate the whole subtree again
01:07:23 <goltrpoat> so i'd have to pound it with the whole search space
01:07:36 <Korollary> ah, it is like a cache
01:07:40 <goltrpoat> yeah exactly
01:11:24 <Korollary> I wonder if this transliteration of space-time compromises may jeopardize an original haskell implementation.
01:13:05 <Korollary> It seems that the object is actually a graph since it is reachable by more than one parent, and in haskell we can assert that and not worry whether it will be computed more than once.
01:13:28 <vincenz> Korollary: except that keeping the whole graph would be quite big
01:13:36 <vincenz> Korollary: so a lazy approach is better
01:14:25 <goltrpoat> yeah, you can't keep the whole graph around, or even evaluate the whole graph..  the whole point behind alpha-beta and derivatives is to evaluate and allocate as few things as possible
01:14:25 <Korollary> the lazy approach works well while you're building the graph, but the graph will just grow because it won't be GC'd.
01:14:42 <goltrpoat> doh
01:14:45 <goltrpoat> why won't it be GC'd?
01:15:42 <vincenz> Korollary: hence not using a graph
01:15:57 <vincenz> however imho
01:16:04 <vincenz> the parts that the graph won't gc
01:16:12 <vincenz> the lazy approach without graph won't gc either
01:16:16 <vincenz> so Korollary has a point
01:16:38 <vincenz> cause the graph is just another way to represent history
01:16:54 <vincenz> but then I wonder how often board positions repeat
01:17:55 <vincenz> does anyone know whether type classes and tycons may share names in haskell?
01:18:08 <goltrpoat> you mean like data Foo = Foo Int?
01:18:13 <goltrpoat> oh
01:18:16 <goltrpoat> typeclasses, nevermind
01:18:23 <Korollary> if you have a term like 1:2:3:someList, and you pass someList to a function, you can expect 1,2 & 3 to be gc'd, I think. But with a graph, it's not clear.
01:18:34 <goltrpoat> looks like it
01:18:41 <vincenz> class Foo ... where
01:18:44 <vincenz> data Foo ...
01:18:50 <goltrpoat> yeah
01:18:52 <goltrpoat> data Blah = Ord Int compiles
01:20:24 <vincenz> apparently not
01:20:39 <palomer> @palomer
01:20:40 <lambdabot> That's nuts!
01:21:35 <vincenz> I agree
01:21:43 <vincenz> there's no reason why they shouldn't be allowed to overlap
01:23:29 <goltrpoat> i'm confused.  data Blah = Ord Int followed by blah (Ord x) = Ord x appears to work
01:23:49 <Korollary> why not?
01:23:58 <goltrpoat> i thought vincenz just said it didn't
01:24:03 <vincenz> goltrpoat: huh?
01:24:08 <vincenz> goltrpoat: reread
01:24:13 <vincenz> class Foo .. .where
01:24:14 <vincenz> data Foo ...
01:24:24 <goltrpoat> oh crap.  sorry.
01:24:52 <vincenz> this is even funkier
01:24:52 <vincenz> http://rafb.net/paste/results/twfR0h67.html
01:25:07 <vincenz> you can't make a typeclass with one global instance
01:25:09 * vincenz laughs
01:26:03 <goltrpoat> did you mean to say instance Locatable (Located a) ?
01:26:57 <goltrpoat> oh.  no you didn't
01:27:09 <goltrpoat> k, 2/2.  i'm gonna get back to working on the chess program :)
01:27:23 <Korollary> vincenz: Locatable is not a type constructor, so you cant make an instance, yes.
01:28:15 <vincenz> Korollary: it's still a non-issue
01:28:17 <vincenz> there is only one instance
01:28:24 <vincenz> so why compllain about overlapping
01:28:28 * vincenz sent a mail to haskell-cafe
01:28:43 <Korollary> what is the instance's type? Int is an instance of Num, and Int is a type.
01:29:08 <vincenz> Korollary: any Located a
01:29:24 <vincenz> look
01:29:27 <vincenz> put it the other way
01:29:29 <vincenz> assume I had
01:29:35 <vincenz> instance Locatatable (Located a)
01:29:46 <vincenz> instance Locatatable (Located a) a | a -> b, b -> a
01:29:49 <vincenz> it'd be the same idea
01:30:29 <vincenz> you can have partially specified typeclass instances
01:31:09 <Korollary> It's the same idea, but it gives you a type that your expressions can belong to. An expression cannot be of a class.
01:31:25 <Korollary> x :: Located Int, etc.
01:33:19 <vincenz> Korollary == bulat?
01:33:26 <Korollary> nope
01:33:32 <Korollary> why?
01:33:36 <vincenz> just curious
01:34:37 <Korollary> Although his english sometimes amuses me, he knows haskell quite a bit better than I.
01:34:56 <vincenz> yeah
01:37:07 <vincenz> you know what would be cool?
01:37:31 <vincenz> foralltypeclasses X. X a => X (Located a) where 
01:39:12 <goltrpoat> wouldn't that sort of break the purpose of type classes
01:39:31 <norpan> vincenz: how would that be implemented?
01:39:41 <vincenz> norpan: well have some way to define how to unwrap the values
01:39:58 <vincenz> and rewrap em
01:40:14 <vincenz> now you have to do it piece by piece
01:40:51 <vincenz> Gimme a good operator name to combine locations?
01:41:23 <norpan> vincenz: but what good would that generic class do
01:41:35 <norpan> you'd end up with no location info probably
01:42:30 <norpan> or you would have to resort to something like template haskell, in which case you probably can do it
01:44:06 <vincenz> norpan: well you'd start with a location
01:44:08 <vincenz> and end up with a location
01:44:41 <norpan> but not all class functions are a -> a
01:44:52 <norpan> there are all sorts of functions
01:44:59 <vincenz> anyways
01:45:07 <vincenz> good operatorname for combining locations?
01:45:13 <norpan> combining them how
01:45:18 <vincenz> unioning e
01:45:19 <vincenz> em
01:45:27 <vincenz> it's for source locations
01:45:35 <vincenz> ++?
01:45:42 <vincenz> no that's taken
01:45:46 <norpan> something with + in it :)
01:45:49 <norpan> |+|
01:45:51 <norpan> <+>
01:45:55 <vincenz> +L+
01:45:56 <norpan> /+/
01:46:07 <vincenz> =+=
01:46:22 <vincenz> hmm
01:46:24 <vincenz> I'll go for |+|
01:46:25 <vincenz> th
01:46:25 <norpan> @+
01:46:25 <lambdabot> Maybe you meant: . v
01:46:26 <vincenz> x
01:46:39 <norpan> maybe @ is not allowed
01:48:31 <vincenz> @hoogle min
01:48:32 <lambdabot> Prelude.min :: Ord a => a -> a -> a
01:48:32 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
01:48:32 <lambdabot> Prelude.minBound :: Bounded a => a
01:48:34 <vincenz> @hoogle max
01:48:35 <lambdabot> Prelude.max :: Ord a => a -> a -> a
01:48:35 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
01:48:35 <lambdabot> Prelude.maxBound :: Bounded a => a
01:50:50 * vincenz powers down and takes a shower before going to the office, bbl
02:06:42 <shapr> I can't believe it's not butter!
02:08:24 <Lemmih> Perhaps it is.
02:08:39 <shapr> hm
02:13:22 * joelr1 waves
02:13:35 * Lemmih `using` reduceToSleepingForm
02:14:23 <shapr> joelr1: I've used it before, why do you ask?
02:14:24 <mahogny> noooo. WMP?? someone get us a better free alternative, drop whatever project you are currently working on :P
02:15:16 <joelr1> shapr: well, i'm considering it for a web app. i'm always the sucker for punishment
02:15:54 <joelr1> Lemmih: what are the differences between HASP and HAppS?
02:17:53 <dons> i had a thought today that we should stop using short 3,4,5 letter project names starting with 'ha' for haskell projects. its getting too confusing.. :)
02:18:15 <shapr> Yeah, true.
02:19:17 <dblhelix> dons: have we already encountered same names being used for different projects then?
02:19:37 <dons> i think perhaps this has happened, or we've come very close
02:19:47 <dons> hsh? that's used twice, i think.
02:19:50 <norpan> we should have a naming authority, and projects must be named h# where # is a running integer
02:19:58 <Cale> heh
02:20:07 <dons> norpan: yes!
02:20:15 <dblhelix> lambdabot could be such a naming authority
02:20:17 <dblhelix> :)
02:20:20 <dons> we can have a lambdabot plugin that dispense new names
02:20:25 <Cale> or just use GUIDs for project names... prepended with Ha of course.
02:20:48 * dons hacks up @project-name
02:20:50 <Cale> Ha{3F2504E0-4F89-11D3-9A0C-0305E82C3301}
02:21:01 <dons> oh, that's good
02:21:06 <Lemmih> joelr1: HASP is a web-framework with similarities to PHP. HAppS is a framework for HTTP/DNS/lots more.
02:21:55 <joelr1> Lemmih: hmm
02:23:25 <dons> hmm. I better use an Integer for the project name key .... ;)
02:41:09 <joelr1> is there any point in using haskell for web development as opposed to ruby?
02:41:51 <joelr1> no flame bait, i paid my haskell dues :D
02:41:57 <dons> what kind of type system does ruby have?
02:42:07 <shapr> type system? excuse me?
02:42:09 <yaarg> duck
02:42:15 * shapr ducks
02:42:22 <shapr> oh, that wasn't DUCK!
02:42:25 * Muad_Dibber roasts the duck
02:42:38 <shapr> dons: Typeclasses, sort of.
02:42:51 <dons> statically typed?
02:43:05 <shapr> Nah, it's dynamically checked.
02:43:08 <shapr> Like Python
02:43:18 <Kasperle> randomly typed ;)
02:43:30 <dons> right. there you go. bugs that won't appear till your app is running
02:43:32 <norpan> static typing is the shit
02:43:34 <shapr> Which to me means, you better have unit tests that check everything at runtime, otherwise your client *will* get mad at you.
02:43:53 <shapr> I've had more trouble with Python's dynamic checking than I can fit into this emacs buffer.
02:44:05 <shapr> After 50k lines or so emacs rolls over and dies.
02:44:38 <joelr1> ruby does have testing facilities, no different than lisp in this respect /i live in lisp at work/
02:44:44 <yaarg> i mean duck typed :)
02:44:54 <shapr> yaarg: Yeah, I was attempting humor :-)
02:44:56 <norpan> static typing + quick check is the shit
02:44:59 <joelr1> the issue is more of going with the flow vs. swimming upstream
02:45:00 <yaarg> oh okay :)
02:45:09 <joelr1> and note that i restrict my focus to web apps!
02:45:12 <yaarg> it depends what you want from the project really imo
02:45:13 <joelr1> just and oly
02:45:17 <joelr1> only
02:45:21 <joelr1> yaarg: get to market fast?
02:45:30 <yaarg> ruby then
02:45:33 <yaarg> i think that's obvious...
02:45:37 <shapr> I dunno
02:45:43 <shapr> I like speed of change.
02:45:48 <joelr1> yaarg: i think so too but i thought  i would solicit opinions
02:45:50 <norpan> i would choose haskell, mainly because i don't know ruby
02:45:54 <shapr> But I want to make sure my changes will actually work.
02:45:56 <joelr1> shapr: speed of change where?
02:46:01 <shapr> Also, Ruby isn't higher order.
02:46:09 <shapr> You can sort of make lambdas, but it's painful.
02:46:25 <yaarg> i wrote my blog in lisp
02:46:31 <joelr1> shapr: i don't think so ;) they are called blocks, no?
02:46:33 <shapr> On a personal note, explicit END just bugs me. At least braces are a single character.
02:46:34 <yaarg> but that's because i wanted to have fun \o/
02:46:43 <shapr> joelr1: Yeah, you've used blocks?
02:47:08 <joelr1> shapr: not yet but .each { |foo| ... } does not look bad
02:47:27 <shapr> How would you do higher order functions in Ruby?
02:47:29 <yaarg> essentially though you're going to run into the same problems programming the web in any language
02:47:30 <joelr1> but anyway i think that laziness works against you in web apps due to increased memory consumption
02:47:39 <joelr1> yaarg: which is ?
02:48:26 <yaarg> maintaining state, impedance mismatch, interactivity
02:48:30 <shapr> Templating, databases, and session.
02:48:35 <shapr> yeah, what he said
02:49:47 <joelr1> yaarg: is there a problem with maintaining state in ruby? haskell?
02:50:06 <joelr1> as far as impedance i would love to see haskell/javascript integration
02:50:24 <shapr> There is some javascript generation in HSWebForms
02:50:30 <joelr1> but more than that i would love to hear about someone running haskell on the web in production. real world stats on memory consumption, etc
02:50:33 <shapr> joelr1: Have you tried HApps and/or Hope?
02:50:50 <shapr> Haskell Web Server runs fine. I've used it.
02:50:56 <shapr> Flippi works great as a CGI app.
02:50:59 <shapr> I've used that too.
02:51:14 <yaarg> well i can't say specifically how well haskell or ruby handles them but those are the main problems with web programming in general
02:51:17 <shapr> Hope uses HaskellDB and lots more. I haven't used it much.
02:51:48 <joelr1> shapr: i used neither
02:51:59 <joelr1> shapr: but i wonder why you prefer hope over hasp or happs
02:52:13 <yaarg> http://groups.inf.ed.ac.uk/links/ i really want that to hurry up
02:52:19 <shapr> Because I know bringert, and he's a kick ass programmer.
02:52:34 <shapr> HASP is a templating system like PHP/JSP/etc
02:52:41 <yaarg> a single language for all three tiers
02:52:42 <shapr> I just don't know enough about HAppS yet.
02:52:49 <shapr> yaarg: haXe has that already.
02:53:24 * yaarg googles
02:53:29 <shapr> haxe.org
02:53:43 <shapr> It compiles a single language to javascript, flash, and nekovm
02:54:02 <yaarg> ah
02:54:03 <shapr> It's had an amazing amount of web traffic in a short amount of time.
02:54:08 <shapr> er, mailing list traffic
02:54:08 <yaarg> links aims to be functional as possible
02:54:12 <joelr1> so many choices!
02:54:21 <joelr1> shapr: why not use haxe?
02:54:23 <shapr> haXe is cool, but it's kind of a pain.
02:54:24 <yaarg> haxe uses existing imperative libraries
02:54:28 <yaarg> i've seen it before
02:54:47 <shapr> Yeah, haXe is written in OCaml and written by the guy who did mtasc and neko.
02:54:53 <yaarg> which is why haxe works now though :)
02:54:55 <shapr> joelr1: I am using haXe already to build flash.
02:55:07 <shapr> joelr1: But I dunno if I want to use it for everything.
02:55:14 <yaarg> haxe doesn't do databases either right
02:55:22 <yaarg> or state even?
02:55:49 <shapr> I can do state loading via xml & csv with get/post in Flash.
02:55:57 <yaarg> hrm
02:55:59 <shapr> I haven't gotten to the javascript and neko stuff yet.
02:56:20 <shapr> HaskellDB is just so much more powerful.
02:56:25 <shapr> joelr1: Have you tried HaskellDB?
02:57:04 <joelr1> shapr: not yet. it didn't work with oracle when i was using that.
02:57:17 <shapr> Ever wanted to write higher order queries?
02:57:24 <shapr> Wow
02:57:29 <shapr> whoops, wrong window
03:00:11 <mauke> shapr: I don't know anything about ruby, but foo = proc {|x| proc {|y| x+y}}; foo[2][3] looks higher-ordery to me
03:01:34 * shapr looks
03:02:45 <dons> @dynamic-load fresh
03:02:46 <lambdabot> module loaded
03:02:57 <dons> @freshname -- there you go. your very next haskell project
03:02:57 <lambdabot> Haa
03:03:03 <dons> :)
03:03:19 <dons> @freshname -- and the next
03:03:19 <lambdabot> Hab
03:03:23 <vincenz> re
03:04:27 <psnl> class
03:07:24 <amiddelk> dons: wat happends if I do a @freshname after I get "has" ?
03:08:06 <shapr> @freshname
03:08:06 <lambdabot> Hae
03:09:12 <dblhelix> amiddelk: then you have to change the scope of your new project, i.e., you will have to implement a tracer then
03:56:11 <dcoutts> @seen marc_vw
03:56:11 <lambdabot> I saw marc_vw leaving #haskell 9 days, 13 hours, 1 minute and 47 seconds ago, and .
03:57:30 <dmhouse> and what, lambdabot?
04:03:59 <xerox> @yarr!
04:04:00 <lambdabot> I'd like to drop me anchor in her lagoon
04:06:08 <dcoutts> hia xerox 
04:06:17 <xerox> 'morning D.
04:06:42 <dcoutts> xerox, how's the cabal-get stuff going?
04:06:59 <dblhelix> :O ... that's one filthy-mouthed bot
04:07:00 <xerox> I'll be start working after the exams.
04:07:21 <dcoutts> xerox, ah, exams
04:07:23 <xerox> (Today it was the last school day, now in a week the exam will start, and it will only take three days.)
04:07:40 <dcoutts> good luck!
04:07:49 <xerox> Which is kinda painful, three 6-hours-long test one day after the other.
04:07:56 <xerox> Thank you!
04:07:56 * dmhouse was revising physics this morning. Solid Materials: boring as anything.
04:07:58 * dcoutts shudders
04:08:33 <vincenz> re
04:08:45 <vincenz> dmhouse: I think your formulation is isomorphic
04:09:01 <dmhouse> vincenz: Re mailing list post?
04:09:05 <vincenz> yah
04:09:08 <dmhouse> vincenz: i figured you'd made typos.
04:09:15 <vincenz> oh no
04:26:01 <Lokadin> say is there any specific way of localizing in haskell?
04:30:44 <Lokadin> @hoogle bracket
04:30:44 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:30:45 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
04:30:45 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
04:54:43 <dmhouse> @localtime dons
04:54:44 <lambdabot> Local time for dons is Wed Jun  7 21:46:14 2006
04:54:48 <dmhouse> dons, around?
04:55:30 <dmhouse> @freshname
04:55:30 <lambdabot> Haf
04:55:32 <dmhouse> @freshname
04:55:32 <lambdabot> Hag
04:55:33 <dmhouse> @freshname
04:55:34 <lambdabot> Hah
04:55:40 <dmhouse> gotta love that plugin.
04:55:54 <dmhouse> gotta love that plugin.
04:55:55 <dmhouse> @freshname
04:55:56 <lambdabot> Hai
04:55:58 <dmhouse> @freshname
04:55:58 <lambdabot> Haj
04:56:10 <dmhouse> only three letters? :(
04:56:45 <dmhouse> anyone know how to get lambdabot (my own) to respond to freenode's ident requests?
04:56:58 <dmhouse> I keep getting NOTICE: ["AUTH",":*** No identd (auth) response"] errors when trying to connect
04:57:29 <dmhouse> hmm, perhaps it's a firewall thing
04:57:39 <dmhouse> which port would I need to open?
05:10:06 <yaarg> i had that problem yesterday just connecting to freenode
05:10:08 <yaarg> worked eventually
05:10:15 <yaarg> shouldn't need inetd these days
05:11:08 <Kasperle> you don't normally. but not having identd running tends to slow the whole connection handshake down
05:11:36 <shapr> Let's all switch to Jabber/XMPP
05:12:41 <dmhouse> hmm, well lambdabot's connection is consistently failing
05:14:52 <dmhouse> vincenz: around?
05:25:35 <pesco> Huh, wasn't (Either e) an instance of Monad?
05:26:13 <shapr> Try :info Monad in ghci
05:26:50 <ibid> pesco: not in h98, but in ghc yes
05:27:07 <pesco> Aha. Hm. Okay.
05:30:16 <ibid> pesco: iirc the instance is in some module, it's not in prelude
05:30:20 <ibid> Control.Monad perhaps
05:30:33 <norpan> Control.Monad.Error
05:31:13 <pesco> Aha! Thanks.
05:35:50 <pesco> Ah, of course, `fail` is the culprit.
05:36:14 * pesco declares his own instance.
05:38:34 <Itkovian> congratulations pesco :-)
05:39:14 <sehute> how can I convert between Double and Integer, and between Integer and Double?
05:40:17 <dons> @type a -> b
05:40:18 <lambdabot> not an expression: `a -> b'
05:40:25 <dons> @hoogle a -> b
05:40:25 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
05:40:25 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
05:40:25 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
05:40:28 <dons> bah
05:40:48 <pesco> Itkovian: I want to stay within H98 _once_. ;-)
05:41:03 <Itkovian> hey, you don;t hear me complain
05:41:09 <dons> pesco: that's crazy talk! ;)
05:41:14 <pesco> dons: *g*
05:41:16 <sehute> @type toInteger (fromEnum 3.0)
05:41:17 <lambdabot> Integer
05:41:23 <sehute> is that really the way to do it?
05:41:31 <dons> > toInteger (fromEnum 3.0)
05:41:32 <Itkovian> ever seen a 'while do' construct in Haskell?
05:41:32 <lambdabot>  3
05:41:35 <mauke> @type toInteger 3.0
05:41:36 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:41:36 <lambdabot>   `Fractional a' arising from the literal `3.0' at <interactive>:1:10-12
05:41:37 <Itkovian> :-0
05:41:46 <mauke> @type toInteger (3.0 :: Double)
05:41:47 <lambdabot>   No instance for (Integral Double)
05:41:47 <lambdabot>   arising from use of `toInteger' at <interactive>:1:0-8
05:41:49 <mauke> aww
05:42:57 <pesco> > floor 3.0 :: Integer
05:42:58 <lambdabot>  3
05:43:08 <Itkovian> do we still have a haskel paste-bin somewhere?
05:43:39 <dons> lisppaste: url
05:43:39 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:43:52 <sehute> @type (floor 3.0)
05:43:53 <lambdabot> forall b. (Integral b) => b
05:43:59 <lisppaste2> Itkovian pasted "Student code" at http://paste.lisp.org/display/20958
05:44:30 <dons> oh my
05:44:38 <dons> foreach?
05:44:42 <Itkovian> of course
05:44:49 <sehute> pesco: Thanks! :)
05:44:53 <Itkovian> never seen that?
05:44:54 <Muad_Dibber> whats that Itkovian ? :P
05:44:57 <Itkovian> lol
05:45:03 <pesco> sehute: np
05:45:07 <Itkovian> Muad_Dibber: yes, this is the level we're dealing with ...
05:45:12 <Itkovian> for some students at least
05:45:14 <dons> its cool that the guy made up an imperative edsl...
05:45:28 <Itkovian> I recall he took the course twice.
05:45:44 <mauke> wait, is that supposed to be haskell?
05:45:50 <dons> oh, i like the assignments,    then bestc = conf
05:45:54 <sehute> pesco: Is this the way to convert from Integer to Double: encodeFloat 3 0 :: Double
05:45:58 <Itkovian> what do you mean 'supposed' ? :-P
05:46:12 <pesco> sehute: No, that would be fromIntegral.
05:46:27 <Itkovian> I think I'll print it and put it to the wall
05:46:30 <sehute> pesco: Thank you! :)
05:46:32 <mauke> Itkovian: my internal haskell parser choked on the first line
05:46:42 <dons> yeah, that's really nice Itkovian. oh, and there's even a !=
05:46:42 <sehute> pesco: with :: Double at the end, then?
05:47:00 <Itkovian> and a if ! ...
05:47:09 <Itkovian> he really compiled it
05:47:17 <pesco> sehute: Depends. In some contexts it's clear from the surrounding expression.
05:47:22 <Itkovian> 'oh but it works on paper' (see the dailywtf a few days ago)
05:47:34 * Itkovian sighs
05:47:42 <Itkovian> of course, there are excellent solutions too
05:47:46 <Itkovian> luckily
05:48:07 <pesco> sehute: I.e. when typechecker already knows the type has to be Double.
05:48:19 <sehute> pesco: I see
05:48:35 <dons> Itkovian: sometimes there's people who just shouldn't be let near a keyboard
05:48:37 <sehute> Itkovian: I don't see what's wrong with the wonderfully imperative solution ;)
05:49:00 <Itkovian> it makes me angry, that's what's wrong with it.
05:49:07 <Itkovian> I'll give him a 0/10
05:49:23 <Itkovian> or .5 for the effort and wasting my time
05:49:26 <Itkovian> and disk space
05:49:28 <BCoppens> hey Itkovian 
05:49:31 <sehute> :D
05:49:44 <Itkovian> Well now. No worries BCoppens it wasn't your code
05:49:48 * shapr grins
05:49:50 <dons> at least he put in comments.
05:49:55 <Itkovian> true
05:50:13 <BCoppens> Itkovian: lol, seems like I randomly decided to say hi at the right point in time :D
05:50:23 <Itkovian> haha
05:50:34 <dons> oh, hang on. the decls' a bit wonky...      78 minimal2 c endconf tempconfs bestc {
05:50:34 <Itkovian> what a boring afternoon ;-)
05:50:50 <dons> he's half-assimilated a bit of the syntax
05:50:52 <BCoppens> =)
05:51:14 <Itkovian> there a better function too, starts with { and ends with -} ;-)
05:51:21 <dons> heh
05:51:29 <dmhouse> dons!
05:51:32 <Itkovian> gues his keyb doesn't generate - too well
05:51:38 <dmhouse> dons, I
05:51:40 <dmhouse> err
05:51:41 <dons> dmhouse!
05:51:56 <Itkovian> every body errs dmhouse 
05:51:56 <dmhouse> dons, I'm trying to get lambdabot to connect to freenode. Do I need to set up any kind of ident hackery?
05:51:58 <Itkovian> no worries
05:51:59 <dons> oh, i added a cabal file for lambdabot today. you were asking about that a couple of days ago?
05:52:04 <dons> dmhouse: hmm. no.
05:52:19 <dons> go the right hostname?
05:52:24 <mauke> I like the python-style foreach loop
05:52:28 <dons> has to be : chat.freenode.net
05:52:31 <lisppaste2> davidhouse pasted "LB output" at http://paste.lisp.org/display/20959
05:52:39 <dmhouse> ah.
05:52:47 <dmhouse> yeah, it is
05:53:09 <dmhouse> using the default settings apart from the ops/channels.
05:53:19 <dons> dmhouse: hmm. oh, does it have the name 'lambdabot' ?
05:53:26 <dmhouse> duh.
05:53:27 <dons> then the channel server won't let it join
05:53:38 <dons> since there's already a lambdabot here identified
05:53:42 <dmhouse> yeah, of course.
05:53:47 <mux> does anyone know the maintainer of HXT?
05:53:49 <dmhouse> should've thought of that :) thanks.
05:53:50 <dons> ok. well, you get the same symptoms 
05:54:06 <dons> dmhouse: ok. cool.
05:54:36 <dmhouse> and yes, I saw the cabalisation. good stuff :)
05:54:43 <dmhouse> does it still support make way=fasT?
05:54:52 <dmhouse> s/T/t/
05:54:53 <dons> the gnu make stuff is still in place
05:55:00 <dons> so you get fast by default in the cabal file
05:55:09 <dons> also, i got ghci working, almost
05:55:44 <dons> so if you're interested in any particular build method, let me know, we can improve it some more i think
05:55:58 <dmhouse> hrm. lambdabot still won't connect. Same errors as before
05:56:10 <dons> you rebuilt after tweaking the config file?
05:56:15 <dons> it has to have a unique name
05:56:17 <lisppaste2> davidhouse annotated #20959 with "Config.hs" at http://paste.lisp.org/display/20959#1
05:56:27 <dons> i don't think 'lambda' or 'lam' will work, for example
05:56:36 <dmhouse> you have to build after changing the config?
05:56:41 <dmhouse> I expected it to just be included
05:56:43 <dons> yes. 
05:56:53 <dons> how? its a .hs file
05:57:10 <dons> its a long-standing todo to dynamically reload the configuration stuff
05:57:12 <dmhouse> import Config
05:57:22 <sehute> what's the difference between Integral and Integer in connection with Haskell?
05:57:38 <dons> dmhouse, you'll have to recompile the config file, and anything that uses it
05:57:42 <dmhouse> sehute: Integral is a typeclass which covers the types Integral and Integer
05:57:50 <dons> sehute: Integral is a class, Integer is an unbounded integeter type
05:57:51 <dmhouse> oh, true.
05:58:00 <sehute> thanks
05:58:05 <dmhouse> err
05:58:12 <dmhouse> *which covers the types Int and Integer
05:58:25 <sehute> okay, so Integral encompasses Int and Integer?
05:58:28 <dmhouse> right.
05:58:32 <dons> @instances Integral
05:58:33 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
05:58:42 <dmhouse> hmm?
05:58:45 <dmhouse> @hoogle Integral
05:58:45 <lambdabot> Prelude.Integral :: class (Real a, Enum a) => Integral a
05:58:45 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
05:58:48 <dmhouse> odd.
05:58:54 <dmhouse> sounds like a bug to me.
05:59:02 <dons> dmhouse: that err msg is a bit verbose too
05:59:06 <sehute> I'm in the process of wrapping my brain around this too
05:59:10 <dmhouse> ah, I know what's wrongl.
05:59:13 <dmhouse> *wrong
05:59:27 <dmhouse> it wont work for anything that's a subclass.
05:59:30 <dmhouse> @instances Num
05:59:31 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
05:59:35 <dmhouse> lemme fix that.
05:59:51 <dons> dmhouse: also, you've been careful with security issues?
06:00:03 <dons> i can't, for example, run ghci shell commands?
06:00:23 <dmhouse> It places :m and :i before anything that's passed in.
06:00:31 <dons> yeah, i saw that.
06:00:38 <dmhouse> Can you do stuff like :i Num; :!ls on one line?
06:00:45 <dons> i wonder.
06:00:49 <dmhouse> nope.
06:01:00 <sehute> d2i :: Double -> Integer
06:01:00 <sehute> d2i d = floor d
06:01:21 <sehute> Why does this give syntax error in input (unexpected `=') ?
06:01:25 <dons> ?hoogle truncate
06:01:25 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
06:01:25 <lambdabot> System.Win32.File.tRUNCATE_EXISTING :: CreateMode
06:01:36 <dons> sehute: that code looks fine
06:01:47 <dons> bug must be somewhere else. check the error msg for line and column numbers
06:01:59 <dons> > truncate 3.0
06:01:59 <dmhouse> sehute: trying to run that in GHCi by any chance?
06:02:00 <lambdabot>  3
06:02:10 <dons> > truncate 3.9
06:02:11 <lambdabot>  3
06:02:13 <sehute> dons: The line is: d2i d = floor d
06:02:16 <dons> > round 3.9
06:02:17 <lambdabot>  4
06:02:18 <sehute> dons: I'm running it in Hugs
06:02:33 <dons> not enough info in your pastes to work out the problem
06:02:36 <sehute> dons: and floor and round works perfectly if I just type in (floor 3.0)
06:02:36 <dons> keep looking
06:02:41 <bolrod> ;/win 12
06:02:43 <dmhouse> sehute: are you importing a module which contains that code, or pasting that code directly into hugs?
06:02:43 <bolrod> oops
06:03:18 <dons> sehute: oh, you can't declare new functions at the hugs prompt, can you?
06:03:25 <dons> Hugs.Base> f x = x
06:03:26 <dons> ERROR - Syntax error in input (unexpected `=')
06:03:33 <dons> you need to write them to a file.
06:03:35 <dons> or else use ghci
06:03:40 <dmhouse> or do let f x = x
06:03:43 <sehute> dons: It's line 191 in this file: http://www.pvv.org/~alexanro/Calc.hs
06:03:47 <dons> Hugs.Base> let f x = x
06:03:47 <dons> ERROR - Syntax error in expression (unexpected end of input)
06:03:58 <dons> dmhouse: doesn't work in hugs. long standing issue.
06:03:58 <dmhouse> oh, perhaps not.
06:04:03 <sehute> dons: I'm using hugs and typing :l Calc
06:04:03 <dmhouse> pfft. hugs--
06:04:42 <dons> sehute: your layout looks a bit wonky
06:04:52 <sehute> dons: well, thank you :P
06:04:58 <sehute> dons: I'm a complete n00b at Haskell
06:05:01 <dons> why aren't d2i, and i2d indented to the same depth.
06:05:05 <dons> it matters in haskell
06:05:06 <sehute> dons: set ts=4
06:05:15 <sehute> dons: Ahh, this might be my issue
06:05:17 <dons> tabs are 8 spaces in haskell
06:05:24 <dmhouse> dons, also, I like @freshname, although it seems to be limited to 3-char names.
06:05:28 <dons> try :set expandtab ; :retab
06:05:41 <dons> dmhouse: it'll get to 4 names once you use up all the 3 letter names ;)
06:05:47 <dons> 4 letters..
06:05:47 <dmhouse> ah.
06:05:50 <dmhouse> @freshname
06:05:50 <lambdabot> Hak
06:05:53 <dmhouse> @freshname
06:05:53 <lambdabot> Hal
06:05:55 <dons> that's a good name!
06:05:55 <dmhouse> @freshname
06:05:56 <lambdabot> Ham
06:05:58 <dons> that too.
06:05:58 <dmhouse> @freshname
06:05:58 <lambdabot> Han
06:06:03 <dmhouse> @freshname
06:06:03 <lambdabot> Hao
06:06:10 <dons> lots of great haskell projects there.
06:06:17 <dons> whose working on Ham?
06:06:29 <dons> Lemmih, Hak? Ham? why haven't you written these yet?
06:06:34 <xerox> dons - Lambdabot hacking spree lately? (:
06:06:34 <dons> ;)
06:06:38 <bolrod> @freshname
06:06:38 <lambdabot> Hap
06:06:39 <bolrod> Hap
06:06:40 <bolrod> :o
06:06:40 <shapr> I'm working on HAH
06:06:40 <dons> just a bit
06:06:46 <sehute> dons: thanks
06:06:51 <dons> shapr: yay!
06:06:59 <norpan> @freshname
06:06:59 <lambdabot> Haq
06:07:04 <norpan> yes!
06:07:07 <dons> that's a great name
06:07:09 <dmhouse> Haq _is_ a good name!
06:07:15 <bolrod> @freshname
06:07:15 <norpan> and it's all MINE
06:07:15 <lambdabot> Har
06:07:16 <bolrod> Har
06:07:20 <shapr> JohnMeacham: after darcs pull -a: Compiling E.SSimplify ( ./E/SSimplify.hs, ./E/SSimplify.o ) \n ./E/SSimplify.hs:511:86: Not in scope: `isIsBoundTo'
06:07:23 <xerox> @har
06:07:23 <lambdabot> Maybe you meant: arr faq map part what
06:07:37 <bolrod> ok.. how long 'til it gets to Yar
06:07:38 <bolrod> ;p
06:07:43 <dmhouse> @help what
06:07:44 <lambdabot> what <key>. Return element associated with key
06:07:50 <dmhouse> @what sausages
06:07:50 <dons> no, it's always "ha" ++ fresh
06:07:50 <lambdabot> I know nothing about sausages.
06:07:57 <dons> so it'll be hayar
06:08:02 <bolrod> oh
06:08:08 <bolrod> :(
06:08:20 <dons> it's a haskell project, after all, so has to follow convention :)
06:08:37 <shapr> Maybe I should work on hahahahaha
06:08:44 <bolrod> :D
06:08:54 <norpan> does lambdabot keep the names of those who requested the freshname?
06:08:59 <dmhouse> With sister project hehehehehe
06:09:03 <shapr> yup
06:09:13 <dmhouse> Then Christmas edition hohohohohoh
06:09:13 <norpan> @help freshname
06:09:14 <lambdabot> freshname. Return a unique Haskell project name.
06:09:15 <dons> norpan: yes. it collects your names, your email addresses, and your social security numbers
06:09:18 <xerox> > take 10 (fix ("ha"++))
06:09:19 <lambdabot>  "hahahahaha"
06:09:31 <norpan> dons: then i must ask it what it is as i have no such number :)
06:09:35 <xerox> Done.
06:09:41 <sinfinity> haha... freshname is pretty clever ;)
06:09:55 <dons> norpan: see, its a very cever bot.
06:11:21 <sinfinity> @help haskell
06:11:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:11:27 <sinfinity> oh...
06:11:28 <sinfinity> :(
06:11:31 <dons> dmhouse: i'm actually hoping to switch entirely to cabal for lambdabot. its a lot easier
06:11:43 <dons> sinfinity: have you met lambdabot yet?
06:11:47 <dons> ?version
06:11:47 <lambdabot> lambdabot 3.1p35, GHC 6.4.1 (Linux i686 3.20GHz)
06:11:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:11:51 <dons> > map (+1) [1..10]
06:11:52 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
06:11:54 <dons> ?type map
06:11:55 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
06:11:56 <dons> ?hoogle map
06:11:56 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
06:11:57 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
06:11:57 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
06:12:03 <dons> ?docs Data.Map
06:12:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
06:12:08 <sinfinity> :O
06:12:08 <xerox> ?vixen say hi to sinfinity 
06:12:08 <lambdabot> hiya
06:12:32 <dons> ?pl \x y -> f x + f y
06:12:33 <lambdabot> (. f) . (+) . f
06:12:41 <dons> ?ghc
06:12:42 <sinfinity> > filter (<5) [1..10]
06:12:42 <lambdabot>  Cannot desugar this Template Haskell declaration
06:12:42 <lambdabot>  [1,2,3,4]
06:12:47 <dons> ?quote
06:12:47 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
06:13:10 <sinfinity> haskell is pretty awesome, by the way.
06:13:11 <shapr> ?quote dons
06:13:12 <lambdabot>  but let is more lazy ;)
06:13:19 <shapr> sinfinity: Yeah, it rocks!
06:13:24 <dmhouse> dons, there were some awesome quotes yesterday.
06:13:31 <dons> ah yes, we should fix @remember
06:13:31 <dmhouse> dons, you need to fix @remember.
06:13:38 <dons> quite so.
06:13:46 <mauke> @keal
06:13:47 <lambdabot> one prollem. T broke confines of the visual basic langage and would not compile
06:14:00 <dons> i break the confines of haskell all the time.
06:14:09 <dons> well, at least my code doesn't compile
06:14:15 <dons> so i guess i broke the confines
06:14:20 <dmhouse> I couldn't believe it when I found out @keal were real quotes.
06:14:25 <dons> hehe
06:14:28 <dons> yeah, its stuning
06:14:36 <dons> i think we should publish the "Little Book of Keal"
06:14:44 <dons> maybe get keal quotes printed on tshirts
06:14:47 <shapr> Truly
06:14:53 <dons> ?keal
06:14:54 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
06:15:04 <dons> ?keal
06:15:04 <lambdabot> #haskell needs to take its meds
06:15:07 <dmhouse> does ? still work as a 0-or-1-matches quantifier in Posix regexes?
06:15:08 <dons> hehe
06:15:10 <shapr> haha
06:15:24 <dons> dmhouse: of course
06:15:24 <xerox> dmhouse, ``still''?
06:15:33 <dmhouse> xerox, as in, it does in PCRE.
06:15:49 <mux> if your regexps don't have it you can also do a{0,1}
06:16:00 <dmhouse> do either of = or > have special meaning?
06:16:13 <dmhouse> never mind, I found out what was wrong.
06:16:43 <xerox> shapr - watch this <http://www.archive.org/details/fermats_last_theorem> (-:
06:18:01 * shapr downloads
06:18:15 * dons `with` $ \ptr_me -> sleep ptr_me
06:18:18 <xerox> Great.
06:18:43 <xerox> Goodnight dons.
06:20:47 <psnl> dons: I would buy a keal quotes t-shirt
06:22:01 <shapr> Hey CosmicRay, we found the problem!
06:22:40 <CosmicRay> shapr: cool, what was it?
06:22:42 <sehute> has :: a -> [a] -> Bool
06:22:42 <sehute> has x l = elem x l
06:22:43 <shapr> bringert was using the compacting garbage collector.
06:22:52 <sehute> Why is this illegal anyone? :)
06:23:10 <xerox> ?type elem
06:23:11 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:23:12 <shapr> sehute: Why not do has = elem ?
06:23:26 <xerox> You need Eq constraint on the `a'.
06:23:27 <shapr> CosmicRay: But now I get "fromSql: Cannot read "2006-06-07 15:22:09" as Integer."
06:23:38 <sehute> shapr: Good point. I still wonder about what's wrong though
06:23:45 <shapr> Does all of HDBC return string instead of unix time?
06:23:53 <sehute> xerox: What is an Eq constraint?
06:24:16 <xerox> sehute - `a' is whatever type. `Eq' is a set of type that implements some functions.
06:24:26 <CosmicRay> shapr: heh
06:24:33 <sehute> xerox: thank you, I think I got it
06:24:43 <xerox> sehute - Setting a constraint on a type variable means that only members of that set of type are acceptable for your type.
06:24:50 <CosmicRay> shapr: the datetime support is not completely there yet for all the different backends
06:24:55 <CosmicRay> shapr: what backend are you using
06:24:58 <xerox> sehute - The syntax is <name> :: <constraints> => <type>.
06:25:22 <sehute> xerox: Great, thanks, I wondered about what that syntax might mean
06:25:47 <xerox> sehute - Also, a set of types is called a class. And making a type belong to a given set is called instantiation.
06:26:11 <sehute> xerox: So, if I made a set of Num and Eq, that would be a class?
06:26:21 <xerox> sehute - You can inspect what the class Eq a looks like by doing `:info Eq' on the GHCi prompt.
06:26:33 <shapr> CosmicRay: pgsql
06:26:51 <xerox> sehute - Sorry I don't understand the question.
06:26:57 <CosmicRay> shapr: oh, you can't read it as an integer.  you have to read it as a clocktime!
06:27:02 <CosmicRay> shapr: I think that'll work
06:27:09 <CosmicRay> or is it calendartime?  I can never keep them straight.
06:27:15 <shapr> Neither can I
06:27:18 <sehute> xerox: My fault. I'll read up on that syntax, classes and types, and then I think I'll get it properly :)
06:27:29 <CosmicRay> the system can't parse that string as an integer but it if I wrote the code already, it could stand a decent chance of parsing it as a clocktime ;-)
06:28:02 <shapr> Well, Hope includes ParseDate, so...
06:28:37 <shapr> HaskellDB does seem to expect an Integer though.
06:30:03 <shapr> CosmicRay: So, if I modify HaskellDB-HDBC to get a CalendarTime, it should work when you've written the code?
06:30:48 <shapr> CosmicRay: Whoa, you're on the slashdot frontpage today.
06:31:41 <psi> what story?
06:31:48 <psi> ah, the debian one
06:31:49 <psnl> the debian one, I guess
06:32:46 <CosmicRay> shapr: yes.  sigh.
06:32:58 <CosmicRay> shapr: yes.
06:33:08 <shapr> Hey, you're famous :-)
06:33:09 <CosmicRay> shapr: err, sigh to the /. story, not hdbc ;-)
06:33:39 <CosmicRay> shapr: it could have been under better circumstances ;-)
06:33:54 <SamB_XP_> what happened?
06:35:57 <shapr> SamB_XP_: http://linux.slashdot.org/article.pl?sid=06/06/07/047204
06:36:49 <psnl> looks like a standard debian flamewar
06:36:58 <CosmicRay> psnl: pretty much.
06:37:41 <BCoppens> shapr: nice, I guess I'm about to read that in my backlog of my unread mails as well =)
06:38:54 <shapr> As psnl said, $STANDARD_DEBIAN_FLAMEWAR 
06:39:19 <shapr> It's funny how slashdot is looking more like The Enquirer.
06:40:59 <shapr> Here's a good summary of that article - http://linux.slashdot.org/comments.pl?sid=187740&cid=15485717
06:41:25 <BCoppens> thanks :)
06:41:59 <ihope> So how good is Haskell at interpreting languages with exception handling?
06:42:21 <norpan> as good as the programmer is i suppose :)
06:42:40 <norpan> afaik the haskell interpreter can only interpret haskell
06:43:06 <ihope> I have a language here that more-or-less consists entirely of exception handling.
06:43:21 <shapr> CosmicRay: So HDBC-pgsql is missing String -> Clocktime code? If I wrote it using parsedate, would you accept a patch?
06:43:30 <CosmicRay> shapr: that would be wonderful!
06:43:46 <CosmicRay> shapr: IIRC, the reason I didn't do that already is because pgsql returns dates in different formats depending on the locale
06:43:54 <shapr> I can at least write a quick hack that'll solve my problem. Not sure about locales.
06:44:28 <shapr> otoh, parsedate is exactly what you want for a multiplicity of date formats.
06:45:50 <CosmicRay> I think there is some attribute of each database, actually, that defines the date format.
06:46:16 <CosmicRay> what I've done with postgresql though is something like SELECT date_part(epoch, colname) so I get an integer out of it anyway
06:46:20 <CosmicRay> I forget the exact syntax
06:48:39 <BCoppens> shapr: amazing how much /. overstates the issue :o
06:58:14 <mahogny> which command enforces strict evaluation?
06:59:13 <shapr> You don't really get that.
06:59:39 <shapr> You can force weak head normal form with seq, and DeepSeq gives you a bit more, but I don't think you can really get full strictness 
06:59:39 <mahogny> well, as-strict-as-it-can-be?
06:59:52 <mahogny> hm. only those to play with?
07:01:49 <shapr> No, you can also add strictness to your datatypes.
07:02:22 <mahogny> hm. ah yes
07:02:40 <mahogny> ah, $! was exactly was I was looking for. thanks anyway :)
07:03:06 <SamB_XP_> so, what was that about not being able to use or distribute Sun Java together with other Java implementations?
07:03:32 <mahogny> I don't see why you can't. but it sounds messy
07:03:44 <SamB_XP_> $! is strict application ;-)
07:03:46 <mahogny> I know GCJ and sun java can pick a fight if you have both
07:03:49 <Kasperle> don't you need permission from sun to distribute it at all?
07:04:14 <SamB_XP_> Kasperle: that is irrelevant
07:04:37 <SamB_XP_> presumably they *had* any such permission needed, or there would have been no issue
07:05:11 <SamB_XP> GCJ fights with sun Java?
07:05:30 * SamB_XP wishes he could remember the password on this name
07:06:06 <SamB_XP> there isn't any way I could have this nick de-registered, is their?
07:06:11 <SamB_XP> er, there
07:06:41 <mahogny> SamB_XP, wait, or ask an op?
07:07:00 <mahogny> *oper
07:07:01 <SamB_XP> it would have to be an OPER, I think
07:07:13 <SamB_XP> how long do I have to wait?
07:07:20 * mahogny usually means oper when he says op :P
07:07:27 <mahogny> different on different networks
07:08:04 <SamB_XP> maybe just until they implement that "first non-empty underscore-seperated segment" thing, or whatever it is
07:09:54 <SamB_XP> (you know, the one where if I own SamB I own all the other nicks that start with SamB_, and ones with extra underscores at the beginning too, etc.
07:32:23 <PanicMicrobe> anyone in discrete mathematics ?
07:32:48 <sinfinity> I had a semester of it
07:32:58 * BCoppens probably sucks hard at it ;P
07:33:24 <PanicMicrobe> do u have formal proofs of functions ?
07:34:12 <sinfinity> PanicMicrobe: we did some formal proofs of functions
07:34:26 <BCoppens> depends how formal
07:34:48 <PanicMicrobe> do u have any for me :( as i cant understand how to do them
07:35:11 <PanicMicrobe> relations and sets are fine but functions i cant  find out 
07:35:21 <sinfinity> not available at the moment, no =/
07:35:26 * BCoppens neither
07:35:44 <dcoutts> sjanssen_, hia, how's the SoC project going?
07:35:52 <PanicMicrobe> ok
07:35:54 <sehute> PanicMicrobe: Do you prove functions by induction?
07:36:01 <PanicMicrobe> do u know where i can find help ?
07:36:06 <PanicMicrobe> no
07:36:09 <sehute> PanicMicrobe: wikipedia?
07:36:10 <PanicMicrobe> by definitions
07:36:24 <PanicMicrobe> of surjection,injection etc and some predicate
07:36:28 <BCoppens> sehute: or planetmath
07:36:40 <sehute> PanicMicrobe: I had a miniscule bit of discrete maths at uni, but not enough to help you, unfortunately
07:36:53 <sehute> BCoppens: thumbs up
07:37:13 <PanicMicrobe> ok
07:37:49 <BCoppens> sehute: :)
07:37:51 <sjanssen_> dcoutts: pretty good
07:38:01 <dcoutts> sjanssen_, cool
07:38:16 <dcoutts> sjanssen_, what are you looking at atm?
07:38:17 <sehute> sjanssen_: What's your SoC project?
07:38:19 <sinfinity> oo, there are summer of code projects for haskell?
07:38:32 <dcoutts> sinfinity, 9 of them
07:38:42 <sehute> coolness :)
07:38:42 <sinfinity> dcoutts: nice
07:38:50 <sinfinity> thats good to hear
07:38:54 <sjanssen_> sehute: a Unicode packed string is the major part of the project
07:39:37 <dcoutts> sjanssen_, so for unicode, what representation are you planning on using? UCS4, UTF8 or UTF16 ?
07:39:40 <sehute> sjanssen: that would be a welcome addition. Are you going for utf-8 or the enitre humongus unicode-thing?
07:39:48 <BCoppens> sjanssen_: unicode in ghc?
07:40:42 <sjanssen_> dcoutts: this has been something I've been back and forth on.  At first UTF8 sounds attractive for it's smaller memory use . . . but the overhead of parsing it might be bad
07:40:44 <dcoutts> sjanssen_, the ICU lib claims that UTF16 provides the best balance of operating effeciency & space use, which is interesting, I'd not considered it before.
07:40:53 <sjanssen_> so UCS-4 is another option
07:40:59 <dcoutts> sjanssen_, you know the ICU lib?
07:41:07 <sjanssen_> dcoutts: vaguely
07:41:24 <ndm> dcoutts_, is ByteString standard Haskell 98 - i.e. is it going to work on Yhc ?
07:41:32 <dcoutts> ndm, yes.
07:41:39 <dcoutts> ndm, well with some cppery
07:41:46 <dcoutts> sjanssen_, right, utf8 was never designed as an internal format
07:41:51 <dcoutts> ndm, it works with hugs
07:41:59 <ndm> dcoutts, woohoo! hopefully we can use it in the compiler as well (it currently uses ReversedPackedStrings, which are yuk!)
07:42:12 <dcoutts> ndm, Reversed ?!?
07:42:30 <mux> sjanssen_: yeah, the overhead is huge, to keep a minimum efficiency for string operations in libc, we have to use red-black trees
07:42:33 <mux> that tells a lot..
07:42:37 <ndm> dcoutts, yep! all the strings at all points are stored in reverse
07:42:38 <dcoutts> ndm, so all the cunning fusion rules etc are GHC only.
07:42:47 <dcoutts> ndm, why do you do that?
07:43:00 <ndm> because a cons is cheaper than a snoc, and its build up with accumulation
07:43:16 <ndm> although i'm presonally very very sceptical, and would change it is i could
07:43:25 <dcoutts> ndm, ah you're mutating and appending chars to a buffer?
07:43:28 <sehute> sjanssen_: UCS-4 would be really cool. As far as I know, unicode is usually used together with GUI, so the speed might not be a big issue after all? Or is unicode+speed really needed?
07:43:49 <ndm> dcoutts, i am not, but the original author seemed to be... - i want to rewrite the parser
07:43:57 <dcoutts> ndm, ok :-)
07:44:02 <norpan> unicode is used whenever String is used
07:44:14 <sjanssen_> sehute: ideally, unicode should be the default string type
07:44:20 <sehute> How about a similar separation as between Int and Integer?
07:44:22 <ndm> there are lots of cool things like: if module == packedString "edulerP" then...
07:44:30 <sehute> sjanssen: agreed
07:45:01 <dcoutts> sjanssen_, so ICU claim that UTF16 is good because: 1. is provides a good balance of memory use, in UTF8 ASCII is 1 byte but non-western is 3 bytes. In UTF16 all common texts are 2byte
07:45:20 <dcoutts> ndm, sound hideous :-)
07:45:30 <ndm> dcoutts, still nicer than the type checker...
07:45:39 <sjanssen_> dcoutts: I've read a similar article, but there's still some parsing overhead in UTF-16
07:45:45 <norpan> 16 bit encoding is probably the best choice
07:45:53 <norpan> especially if you ignore surrogates
07:46:04 <dcoutts> sjanssen_, and it's not too bad an internal format they reckon since almost all chars are 2 byte so there's less variable width fussing
07:46:54 <dcoutts> sjanssen_, of course one can still get 'surrogate pairs' in UTF16 for chars outside the 'BMP' so that complicates processing but shouldn't impact perfomance too much since surrogate pairs are very rair in practice
07:46:56 <norpan> that is, use UCS-2
07:47:25 <dcoutts> sjanssen_, yes, I don't know how complex the UTF16 -> Code point mapping is.
07:48:08 <sehute> I say, full unicode-support or none! ;)
07:48:11 <sjanssen_> dcoutts: you just have to test the highest bit of a char to see if it's one Word16 or two
07:48:15 <sjanssen_> if I remember correctly
07:48:18 <sjanssen_> sehute: I agree
07:48:23 <dcoutts> that's not too bad I suppose
07:49:11 <dcoutts> sjanssen_, I think it's ok to make people accept that length is not O(1) but O(n)
07:49:26 <dcoutts> afterall it's tat way for String
07:49:27 <sjanssen_> perhaps I should go with something like this: data String = UCS2 Word16Array | UTF16 Word16Array
07:49:32 <sehute> Those who really need speed for text, would probably use their own string-format anyway?
07:50:02 <norpan> sjanssen_: or even UCS2 Word16Array | UCS4 Word32Array
07:50:23 <dcoutts> sjanssen_, my hunch has always been that such split reps are not going to be an improvement overall
07:50:30 <sjanssen_> sehute: hopefully the standard library can be fast -- makes it better for everyone
07:50:31 <dcoutts> a speed improvemeny I mean
07:50:38 <sehute> sjanssen: true
07:50:58 <dcoutts> sjanssen_, using a  .. | .. representation means that you can't do any unpacking
07:51:07 <dcoutts> and lots of tests all the time
07:51:19 <norpan> you can have a flag instead
07:51:29 <dcoutts> or a char count and a length
07:51:42 <dcoutts> and if one = 2 * the other..
07:51:50 <dcoutts> then we know there are no surrogate pairs
07:52:21 <dcoutts> sjanssen_, ie just add another int to the ByteString style representation
07:52:44 <dcoutts> sjanssen_, that also gives O(1) length and O(1) indexing in the best case
07:53:15 <norpan> O(n) length is not a big problem I think, but O(n) indexing would be bad
07:53:29 <dcoutts> norpan, String !! is O(n)
07:53:37 <norpan> dcoutts: yes, and it's a problem :)
07:53:53 <dcoutts> norpan, people normally write iteative code that walks down strings char by char
07:53:53 <sjanssen_> norpan: usually, Haskell code doesn't index
07:54:09 <norpan> because it's expensive it doesn't :)
07:54:15 <dcoutts> the ByteString rep with length + offset is perfect for that
07:54:22 <dcoutts> we get O(1) head and tail
07:54:55 <dcoutts> and becuase there is only a single constructor it can be unpacked and one can get quite effecient code
07:54:59 <norpan> of course the problem with the ByteString rep is that it keeps the whole string as long as you have something of it active
07:55:06 <dcoutts> norpan, yes
07:55:07 <Lokadin> say so is there a standard way of localizing haskell?
07:55:20 <dcoutts> Lokadin, not really a standard way
07:55:20 <norpan> Lokadin: no
07:55:30 <Lokadin> a common way perhaps?
07:56:00 <norpan> not even that
07:56:16 <dcoutts> sjanssen_, the ICU lib's main claim on performance is that UTF16 has lower memory bandwidth than UCS4
07:56:48 <Lokadin> hmmm, well what's a way i could do it? 
07:56:59 <sjanssen_> I wonder how rare chars outside the BMP really are
07:57:08 <norpan> Lokadin: run-time?
07:57:17 <Lokadin> yea
07:57:19 <dcoutts> sjanssen_, apparently, very rare
07:57:24 <dcoutts> sjanssen_, http://icu.sourceforge.net/userguide/icufaq.html
07:57:30 <dcoutts> "What is the performance difference between UTF-8 and UTF-16?"
07:57:50 <norpan> Lokadin: i made an ffi interface to gettext once
07:58:22 <norpan> of course that would require gnu gettext
07:58:36 <Lokadin> oh
07:59:37 <norpan> Lokadin: http://norpan.org/~martin/Haskell/Source/Text/I18N/Gettext.hs
07:59:47 <Lokadin> kk thanks :)
07:59:58 <norpan> then i marked all strings with __("jkjkj")
08:00:07 <sjanssen_> dcoutts: interesting.  However, I really dislike their answer for "How do I index into a UTF-16 string?"
08:00:10 <norpan> and had a regexp matcher take them out and create PO files
08:00:55 <dcoutts> sjanssen_, mm
08:01:12 <Lokadin>  norpan PO ?
08:01:28 <norpan> Lokadin: yes, gettext message catalog source files
08:01:37 <Lokadin> er i mean what does PO mean
08:01:39 <norpan> the files you then use for translation
08:01:53 <sehute> Imo, UCS4 should be more future-proof than UTF16
08:02:10 <norpan> UCS4 is easier
08:02:15 <sjanssen_> sehute: they support the same range of characters
08:02:15 <Lokadin> norpan: kk thanks :)
08:02:30 <sehute> sjanssen: you're right
08:02:45 <sehute> sjanssen: nevermind :)
08:02:54 <norpan> Lokadin: but we should perhaps look at something like gettext for haskell
08:03:06 <norpan> imo it's a good system
08:05:12 <norpan> UTF-8 also has it's uses, especially since the predominant file format is UTF-8 and you'll want to work with mmaped files
08:06:27 <norpan> of course most of the time you can read in the UTF-8 file into UTF-16
08:06:45 <dcoutts> sjanssen_, so how horrible is processing UTF8 ?
08:06:56 <norpan> and more so if you can do it chunk by chunk
08:07:13 <norpan> http://norpan.org/~martin/fps/Data/ByteString/UTF8.hs horrible
08:07:44 <sjanssen_> dcoutts: you need to count the number of consecutive set bits from the left
08:08:04 <norpan>     if c < b10000000 then 1
08:08:04 <norpan>     else if c < b11100000 then 2
08:08:04 <norpan>     else if c < b11110000 then 3
08:08:04 <norpan>     else if c < b11111000 then 4
08:08:05 <norpan>     else 5 -- any number would do
08:08:34 <norpan> "real" UTF-8 allows for 6 bytes
08:08:45 <norpan> but 4 is the maximum for unicode
08:15:22 <sjanssen_> I think I'll try UTF-16 -- without the byte count/character count trick
08:16:33 <sjanssen_> and I'll investigate the various tricks later on
08:16:40 <beelsebob_> Anyone here know how difficult/easy getting ghc runing on intel macs is?
08:17:21 <norpan> http://www.unicode.org/notes/tn12/ is a good document
08:17:48 <sjanssen_> beelsebob_: http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
08:17:59 <beelsebob_> ah, cool, thanks
08:18:11 <beelsebob_> in the mean time... hehehehehehe I've got a MacBook *g*
08:18:11 <sjanssen_> beelsebob_: I've tried it, and it seems to work.  I had trouble building darcs though
08:18:20 <beelsebob_> oh, what trouble?
08:19:04 <sjanssen_> linking errors at the end -- I'm not sure how to fix that
08:19:17 <beelsebob_> ah, okay, I'm sure I'll get to that
08:19:20 <ndm> you need Yhc and a universal binary for darcs...
08:19:36 <beelsebob_> there's a UB for darcs?
08:19:45 <beelsebob_> where?
08:19:58 <beelsebob_> and yes, I'll do the intel mac yhc port :P
08:20:28 <sjanssen_> I don't think a YHC port will help us -- darcs has all kinds of GHCisms
08:20:45 <beelsebob_> what like?
08:20:57 <ndm> GADT's and other such stuff
08:21:18 <beelsebob_> ah, I see
08:21:27 <sjanssen_> audreyt: ping
08:23:00 <norpan> another option for a packed string is to use three bytes per character
08:23:13 <SyntaxNinja> w00t
08:23:30 <mux> norpan: that's asking for alignment troubles and inefficiency for copies
08:23:41 <beelsebob_> why is it that this channel is usually #unicode?
08:23:46 <audreyt> sjanssen_: pong
08:23:54 <norpan> beelsebob_: because we like it!
08:24:21 <norpan> mux: alignment perhaps, but why inefficient copies?
08:24:35 <sjanssen_> audreyt: I'm having trouble building darcs with your GHC build for OS X on x86 -- I get link errors at the end
08:24:40 <mux> because mis-aligned stuff incurs efficiency penalty on non-string architectures such as x86
08:24:41 <sjanssen_> audreyt: do you have any advice?
08:24:46 <mux> it wastes cycles
08:24:52 <mux> err
08:24:56 <norpan> mux: but nothing is mis-aligned
08:24:59 <mux> s/non-string/non-strict/
08:25:05 <norpan> copying is just memcpy
08:25:33 <mux> I'm not talking about byte copies, but string copies
08:25:35 <mux> for instance
08:25:53 <rafl> Hello.
08:25:59 <mux> in pseudo-code: strcpy(foo, somestring + sizeof(onechar));
08:26:13 <rafl> I'd like to know on which architectures ghci is available.
08:26:14 <norpan> but strcpy is memcpy
08:26:18 <mux> no
08:26:43 <sjanssen_> mux: in our case it is, we know the length of the string
08:27:04 <audreyt> sjanssen_: lypanov just ran into some problem and fixed it also
08:27:08 <mux> ok, but still: what if I want to copy a string minus the first char?
08:27:19 <mux> if every char takes 3 bytes, the second one will obviously be mis-aligned
08:27:23 <audreyt> try:
08:27:25 <mux> and so on
08:27:26 <audreyt> mv /usr/local/lib/libreadline.5.1.dylib  /usr/local/lib/libreadline.5.0.dylib
08:27:28 <dmhouse> rafl: I think GHCi is available everywhere GHC is, so try the GHC download page
08:27:32 <audreyt> ranlib /usr/local/lib/ghc*/*.a
08:28:05 <norpan> either memcpy(dest,foo+3,length-3) or just share the string
08:28:16 <mux> yes, and here you take the speed penalty
08:28:25 <mux> because the starting address of the memcpy() is mis-aligned
08:29:02 <rafl> dmhouse: I have an alpha box which runs debian and ghci tells me that's not usable.
08:29:03 <norpan> normally you'd never copy that way
08:29:10 <norpan> since we will share copies
08:29:25 <mux> I think that's being slightly optimistic
08:29:29 <mux> :-)
08:29:39 <norpan> not at all, since strings are immutable
08:30:01 <shapr> xerox__: This file is *very large*
08:30:25 <mux> besides, any memory access on a mis-aligned address will cause performance penalty, whether you're actually copying it, or just simply writing the string to a file
08:30:29 <mux> etc
08:30:33 <norpan> also, you've yet to say how much the penalty is, a few shifts compared to the io cost
08:30:46 <xerox> shapr - Eek, nobody seem noticing. Click on `View all files: HTTP' !  There are 3Gb, 200Mb and lesser big versions!
08:30:47 <PanicMicrobe>  can i paste a link to a problem
08:30:51 <mux> the penalty is small, but significant in some situations
08:30:57 <norpan> mux: but you won't access memory mis-aligned, you'd access aligned and shift/mask
08:31:03 <mux> for instance when doing copies in the kernel it makes some sense to optimize it
08:31:10 <mux> maybe not for that particular Haskell case though
08:31:18 <shapr> xerox: Oh, I must be downloading the 3gb version.
08:31:29 <PanicMicrobe> http://www.cs.um.edu.mt/~gpac1/Teaching/DiscreteMaths/PastPapers/2005-06-csa1060.pdf
08:31:40 <PanicMicrobe> number 3a
08:31:41 <shapr> That's a neat nickname.
08:31:53 <xerox> shapr - I did too, but aftre getting the 200Mb one and watching it. I find it a very fine piece.
08:32:03 <mux> norpan: that's probably as expensive as taking the mis-aligned penalty, if not more
08:32:03 <shapr> xerox: Hm, ok then
08:32:08 <norpan> i'm not saying go for 24 bit chars in packed strings, but it may be worth investigating
08:32:17 <mux> norpan: the penalty here is of the order of a few cpu cycles
08:32:28 <mux> yeah maybe
08:32:38 <mux> I'm not saying it's necessarily a bad idea either
08:32:44 <mux> just that it might cause some problems
08:32:47 <norpan> since you will be saving 1/4 compared to 32 bits
08:33:34 <shapr> xerox: I'm 1gb into the download
08:33:56 <mux> in any case, it certainly makes things slightly more complicated
08:34:19 <norpan> less complicated than dealing with surrogates
08:34:19 <_frederik_> is it possible to use a template-haskell splice in a type signature?
08:34:20 <xerox> shapr - Hmm. Maybe you could finish it, and then put it on DVD for the future, or for share it with friends :-)
08:34:55 <psi> what video is this?
08:35:34 <shapr> Fermat's Last Theorem
08:36:52 <Spark> "why not to devote your life to maths"
08:37:20 <shapr> I haven't found a good answer for that yet.
08:37:28 <shapr> So far I'm thinking I should devote my life to math!
08:38:05 <mux> shapr: please prove that any non-trivial zero of zeta has a real part of 1/2 ;-)
08:39:42 <sinfinity> hilbert shouldn't have left so many open problems ;)
08:39:43 <SyntaxNinja> shapr: but which maths will you devote it to?!
08:39:58 <sehute> if you ever find a cake and a person that's a bit less than a person, for instance 0.9 persons, you can use him for producing endless amount of cake by sharing the cake with him
08:40:35 <sehute> finding such a person is my goal in life
08:41:13 <shapr> SyntaxNinja: There is only one math!
08:41:16 <sehute> (*repeated sharing of cake is needed)
08:41:28 * shapr wanders the countries studying math and monads.
08:41:56 <sehute> shapr: there can be many "maths" if you redefine an axiom or two ;)
08:42:57 <sehute> shapr: same thing with geometry; does lines meet in infity?
08:43:24 <sehute> shapr: (parallel)
08:43:28 <mux> sinfinity: yeah, what a wanker! :-)
08:45:44 <sinfinity> this graph of combinations derived from goldbach's conjecture is neat looking http://en.wikipedia.org/wiki/Image:Goldbach-1000000.png
08:46:40 <shapr> I'd like to approach math from the viewpoint of a proof assistant, any suggestions which one I should start with?
08:47:27 <sinfinity> I've only ever messed with Coq
08:47:55 <sinfinity> and it was pretty nifty I guess, I don't really have a need for a proof assistant at the moment
08:50:14 <mux> sinfinity: mmm, cute graph indeed
08:50:45 <norpan> interesting article too
08:50:46 <sjanssen_> audreyt: when I try to build a module that uses Control.Monad.Error I get "undefined symbol" errors -- can you compile this program: import Control.Monad.Error; main = throwError noMsg
08:50:54 <sehute> Why is ghc so large (in bytes)?
08:51:00 <norpan> the flora of special cases proven is interesting
08:51:09 <shapr> sehute: I think it doesn't do shared libs yet.
08:51:22 <audreyt> sjanssen_: worksforme
08:51:27 <sjanssen_> sehute: tons and tons of functionality!
08:51:38 <sehute> k :)
08:51:54 <sjanssen_> audreyt: okay, so something with my system.  I shall do some sleuthing
08:51:55 <audreyt> sjanssen_: can you use it as bootstrap maybe?
08:52:15 <audreyt> which symbols are no defined? 
08:52:19 <sjanssen_> audreyt: good idea, I'll try
08:52:25 <audreyt> _ControlziMonadziError_zdf21_closure
08:52:30 <audreyt> this?
08:52:33 <sjanssen_> audreyt: yeah
08:52:48 <sjanssen_> actually _ControlziMonadziError_zdf20_closure
08:52:57 <audreyt> can you link in  /usr/local/lib/ghc-6.5.20060526/libHSmtl.a 
08:53:00 <audreyt>  by hand?
08:53:05 <audreyt> hmm
08:53:14 <dcoutts> sjanssen_, "On average, more than 99 percent of all UTF-16 data is expressed using single code units."
08:53:39 <dcoutts> from the unicode 4.1 standard, section 2.5
08:53:57 <audreyt> -lHSmtl should resolve it
08:54:00 <sjanssen_> audreyt: yeah, that worked
08:54:07 <audreyt> ok
08:54:09 <dmhouse> @localtime dons
08:54:10 <lambdabot> Local time for dons is Thu Jun  8 01:45:39 2006
08:54:22 <wilx> @localtime wilx
08:54:24 <lambdabot> Local time for wilx is Wed Jun 07 17:54:02 2006
08:54:31 <wilx> How does it know?
08:55:07 <psnl> it sends you a time query
08:55:14 <psnl> and your client replies
08:55:31 <SyntaxNinja> sehute: I like the cake joke.
08:56:48 <SyntaxNinja> sinfinity: we at Galois do a lot w/ coq and other similar languages.  they're pretty useful :)
08:57:41 <sehute> SyntaxNinja: :)
08:57:45 <sinfinity> SyntaxNinja: cool deal.
08:58:24 <SyntaxNinja> by we I mean not me, btw ;)
08:58:34 <SyntaxNinja> the opposite of the royal we.
08:59:10 <audreyt> SyntaxNinja: hey. got my mail?
09:01:15 <joe_k> is there a function to return (index, item) for each item in a lis
09:01:16 <joe_k> list
09:01:30 <dcoutts> sjanssen_, and section 5.4 might be helpful "Handling Surrogate Pairs in UTF-16"
09:02:15 <SyntaxNinja> audreyt: yeah, I'll get back to you asap.
09:02:26 <audreyt> kcool. thx!
09:02:40 <audreyt> bbl &
09:02:44 <SyntaxNinja> l8r audreyt
09:02:45 <dmhouse> joe_k: zip [1..]
09:02:52 <sjanssen_> dcoutts: which document are we looking at?
09:02:54 <dmhouse> > zip [1..] "abcd"
09:02:54 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
09:03:09 <dmhouse> alternatively, [0..] if you want 0-based indices.
09:03:15 <dcoutts> sjanssen_, http://www.unicode.org/versions/Unicode4.1.0/
09:03:27 <joe_k> dmhouse its so easy. thanks
09:03:27 <dcoutts> sjanssen_, on the left is has a pdf per chapter
09:04:15 <dmhouse> @echo
09:04:16 <lambdabot> echo; msg:IrcMessage {msgPrefix = "dmhouse!n=david@host86-132-138-205.range86-132.btcentralplus.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo"]} rest:""
09:04:37 <dmhouse> hrm. Is there an easy way, in a lambdabot plugin, to do something based on the nick saying it?
09:04:52 <dmhouse> are there any plugins doing this already?
09:05:10 <shapr> dmhouse: try @join #foo
09:05:56 <dmhouse> shapr, yeah, but there's a distinction between commands that only work for ops and commands that know which nick is saying the command.
09:06:31 <shapr> Ok, what about karma?
09:06:34 <shapr> @karma+ shapr
09:06:34 <dmhouse> s/ops/lambdabot ops/
09:06:34 <lambdabot> You can't change your own karma, silly.
09:06:45 <dmhouse> hmm, that involves explicit passing of the nick.
09:06:50 <dmhouse> What I'm trying to write is this
09:06:53 <mux> @karma
09:06:54 <lambdabot> You have a karma of 1
09:06:59 <dmhouse> ah! true.
09:07:19 <dmhouse> what module provides karma?
09:07:30 <mux> lambdabot needs a figlet module
09:07:39 <dmhouse> oh, Karma.
09:09:45 <dmhouse> great! thanks mux.
09:09:47 <dmhouse> and shapr.
09:10:02 <sjanssen_> audreyt: worked.  Thanks for the help!
09:11:13 * mux blinks
09:11:24 <mux> dmhouse: I don't see how I helped you but you're welcome ;-)
09:12:05 <dmhouse> mux, @karma+ involves explicit passing of the nick, that's not what I wanted. You reminded me about @karma, which doesn't.
09:12:22 <mux> oooh.
09:12:24 <ndm> dcoutts, why is Data.ByteString.getArgs only defined on GHC?
09:12:39 <dcoutts> ndm, not sure
09:12:41 <norpan> but @karma+ said error because that explicit nick was the same as the person typing the command
09:12:57 <dcoutts> ndm, personally, I think it should be removed
09:13:13 <ndm> dcoutts, or have a IO.getArgs, then map toByteString
09:13:19 <ndm> just so all platforms present the same interface
09:13:27 <dcoutts> it's not sufficiently common to be included imho
09:13:35 <ndm> reduces the chances of someone writing incompatible code...
09:13:40 <dcoutts> and besides it can be implemented outside of the lib
09:13:59 <dcoutts> since we provide low level CString conversions etc
09:29:52 <dmhouse> @localtime dons
09:29:53 <lambdabot> Local time for dons is Thu Jun  8 02:21:22 2006
09:30:12 <dmhouse> anyone know how to register a plugin with lambdabot's new Cabal build system?
09:30:24 <dmhouse> config.mk.in now seems to be ignore
09:30:25 <dmhouse> *ignored
09:30:49 <dmhouse> hmm... i might just go back to the Makefile for now and ping dons later.
09:33:49 <vincenz> e
09:33:50 <vincenz> re
09:46:00 <vincenz> what is wrong with this
09:46:00 <vincenz> newtype Located a = L Location a
09:46:09 <vincenz> it complains on the second a
09:47:56 <sjanssen_> vincenz: newtypes can only contain one thing
09:48:22 <sjanssen_> maybe you mean L (Location a) ?
09:52:05 <vincenz> no
09:52:12 <vincenz> but yeah that's it, thanks
09:56:52 <SamB> hmm, I don't suppose anyone knows of an XSLT implementation that supports SGML?
09:58:48 <ihope> !echo foo $KLEENE(bar) baz
09:59:09 <ihope> Hmm...
09:59:24 <JKnecht> samb: well in principle any principled one would.
09:59:28 <JKnecht> :)
09:59:57 <JKnecht> by virtue of it's general XML support.
10:00:51 <JKnecht> but you meant implicitly in Haskell, yes?
10:01:32 <ihope> Oh, silly me.
10:01:59 <JKnecht> like something 1 might  do with the Haskell XML Toolbox or such like.
10:04:18 <vincenz> @hoogle ($!)
10:04:18 <lambdabot> Did you mean: ($!)
10:04:18 <lambdabot> Prelude.undefined :: a
10:04:18 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:04:24 <JKnecht> there used to be something at Durham university with filename xslt-fp.html but it's a broken link now.
10:04:31 <vincenz> @type ($!)
10:04:32 <lambdabot> forall b a. (a -> b) -> a -> b
10:04:34 <ihope> @hoogle $!
10:04:34 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
10:04:39 <ihope> Weerd.
10:05:25 <dmhouse> strict function application.
10:05:32 <dmhouse> > const 4 undefined
10:05:32 <lambdabot>  4
10:05:36 <dmhouse> > const 4 $! undefined
10:05:37 <lambdabot>  Undefined
10:05:46 <dmhouse> to make it more clear:
10:05:49 <dmhouse> > const 4 $ undefined
10:05:50 <lambdabot>  4
10:06:00 <beelsebob_> audreyt: ping
10:07:30 <beelsebob_> anyone used the Intel OS X ghc installer?
10:07:38 <beelsebob_> or rather, build
10:08:39 <sjanssen_> beelsebob_: I'm using the build that audreyt made, and it works well
10:08:50 <beelsebob_> sjanssen_: how did you build it?
10:08:58 <beelsebob_> I did a ./configure & make install
10:09:02 <beelsebob_> and it does not work
10:09:21 <sjanssen_> you get errors about readline?
10:09:26 <beelsebob_> dyld: Library not loaded: /usr/local/lib/libreadline.5.0.dylib (this is not where it installed readline to, so duh...)
10:10:41 <sjanssen_> beelsebob_: ln /usr/lib/libreadline.5.1.dylib /usr/local/lib/libreadline.5.0.dylib; ranlib /usr/local/lib/ghc-6.5.20060526/*.a
10:11:11 <dmhouse> @echo
10:11:11 <lambdabot> echo; msg:IrcMessage {msgPrefix = "dmhouse!n=david@host86-132-138-205.range86-132.btcentralplus.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo"]} rest:""
10:12:48 <beelsebob_> sjanssen: should I be expecting to get a load of ranlib errors here
10:12:59 <sjanssen_> yeah, mine complained a bit
10:13:08 <sjanssen_> you did run that as root, right?
10:13:11 <beelsebob_> woot, working ghc
10:13:13 <beelsebob_> :)
10:13:30 <beelsebob_> now to see how fast this thing actually is
10:13:37 <sjanssen_> beelsebob_: try compiling this program: import Control.Monad.Error; main = throwError noMsg
10:14:25 <beelsebob_> sjanssen_: yep, undefined symbols
10:15:38 <beelsebob_> sjanssen_: this makes sense... ls $GHC_SRC/lib/i386-apple-darwin/imports/Control/Monad
10:15:44 <beelsebob_> no Error.hi
10:16:48 <sjanssen_> my install has an Error.hi
10:17:47 <sjanssen_> anyway, I added -lHSmtl to GHC's flags when building darcs
10:17:57 <sjanssen_> I don't know if there are other issues like this
10:20:36 <Igloo> sjanssen_: Was -package mtl already being used?
10:21:39 <dmhouse> Anyone know of any cool human-readable date-difference algorithms for haskell?
10:22:09 <dmhouse> i.e. I tell it 4 o'clock and it says "An hour and twenty minutes ago", or something
10:22:25 <shapr> @seen bringert
10:22:25 <lambdabot> bringert is in #haskell.se and #haskell. I don't know when bringert last spoke.
10:22:30 <bringert> hej shapr
10:22:32 <shapr> w00
10:22:44 <shapr> I didn't see you join :-)
10:23:00 <shapr> How do you get & setup HSQL? sf.net anon cvs seems to be broken. Is there another option?
10:23:01 <sjanssen_> Igloo: nope.  apparently darcs doesn't add -package mtl
10:23:01 <sehute> dmhouse: Not that I know of. It seems like many here have requested various date-functions for Haskell, so my guess is that they are weak or lacking.
10:23:05 <bringert> I snuck in when noone was looking
10:23:06 <sjanssen_> so this really wasn't a bug
10:23:13 <dmhouse> I'll write one.
10:23:13 <shapr> bringert: You sure are quiet.
10:23:19 * shapr writes a bug too
10:23:20 <dmhouse> okay, what libs define a Date datatype?
10:23:26 <bringert> shapr: I use logged in CVS :-)
10:23:32 <shapr> bah
10:23:39 <bringert> but then again, I'm an HSQL developer
10:23:44 <shapr> In that case I could just fix HDBC.
10:24:34 <bringert> shapr I could send you a tarball
10:24:57 <shapr> hm, ok
10:25:33 <bringert> shapr: anon CVS seems to work for me btw
10:25:36 <reppie> what's HSQL?
10:25:38 <reppie> and HDBC?
10:25:44 <reppie> sounds like bank names
10:26:12 <bringert> shapr: cvs -d :pserver:anonymous@htoolkit.cvs.sourceforge.net:/cvsroot/htoolkit co HSQL
10:26:27 <bringert> reppie: low-level database interfaces for Haskell
10:26:33 <reppie> oh
10:26:39 <the_lord> how do I execute a command in the bot?
10:26:48 <bringert> low-level as in the same level as database interfaces in other languages
10:27:06 <shapr> bringert: I'll try it again.
10:27:07 <bringert> the_lord: which command?
10:27:40 <shapr> huh, wow
10:27:40 <the_lord> I want to generate a String from a list
10:27:56 <the_lord> inserting " " between each component
10:28:26 <bringert> shapr: SF CVS is a bit flaky, just waiting 30 sec normally does it
10:28:35 <bringert> but it seems very fast now
10:28:45 <bringert> maybe that's because I'm in the US for a change
10:29:01 <bringert> lots of this that were sort of slow before are really fast now, and vice versa
10:29:27 <the_lord> and I want to know which function does that. [String] -> String -> String
10:29:43 <the_lord> @[String] -> String -> String
10:29:44 <lambdabot> Unknown command, try @list
10:29:48 <the_lord> @list
10:29:49 <lambdabot> list [module|command]. Where modules is one of:
10:29:49 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact fresh haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system
10:29:49 <lambdabot> todo topic type unlambda version vixen where
10:30:02 <bringert> @hoogle [String] -> String -> String
10:30:03 <lambdabot> No matches, try a more general search
10:30:14 <bringert> @hoogle [String] -> String
10:30:14 <lambdabot> Prelude.unlines :: [String] -> String
10:30:14 <lambdabot> Prelude.unwords :: [String] -> String
10:30:14 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
10:30:28 <the_lord> String -> [String] -> String
10:30:35 <the_lord> @hoogle String -> [String] -> String
10:30:36 <lambdabot> No matches, try a more general search
10:30:39 <the_lord> :(
10:30:41 <Stinger_> @hoogle foldl
10:30:42 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
10:30:42 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
10:30:42 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
10:30:55 <bringert> @hoogle a -> [a] -> a
10:30:55 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
10:30:56 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
10:30:56 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
10:31:17 <the_lord> thx
10:31:25 <bringert> @hoogle a -> [a] -> [a]
10:31:25 <lambdabot> List.intersperse :: a -> [a] -> [a]
10:31:25 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
10:31:25 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:31:52 <the_lord> how do I evaluate the function?
10:32:06 <the_lord> @list
10:32:07 <lambdabot> list [module|command]. Where modules is one of:
10:32:07 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact fresh haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system
10:32:07 <lambdabot> todo topic type unlambda version vixen where
10:32:28 <bringert> > concat (intersperse ", " ["foo","bar"])
10:32:28 <lambdabot>  "foo, bar"
10:32:51 <the_lord> bringert: that's what I want
10:32:55 <the_lord> bringert: thx
10:44:04 <dmhouse> > intersperse ", " []
10:44:04 <lambdabot>  []
10:44:51 <dmhouse> > (init [4], last [4])
10:44:52 <lambdabot>  ([],4)
10:49:49 <shapr> bringert: PostgreSQL.hsc:187:67: Not in scope: `fromSqlCStringLen' any ideas?
10:51:16 <bringert> shapr: hm
10:52:04 <shapr> oh wait, maybe I need to install HSQL before I build its Postgresql support?
10:52:10 <shapr> doh
10:52:31 <bringert> hmm, it should complain about missing modules, not functions, but yeah
10:59:51 <joe_k> can I apply a list of arguments to a function?
11:00:21 <shapr> It's easier to apply a tuple, but you can do a list with a bit more code.
11:00:23 <joe_k> i.e. apply_list zip3 [[...],[...],[...]]
11:01:06 <norpan> joe_k: the question is not if you can, it's why do you want to do that?
11:01:15 <shapr> > uncurry (+) (1,2)
11:01:16 <lambdabot>  3
11:02:26 <shapr> > map (\(a:b:[]) -> a + b) [[1,2],[3,4],[5,6]]
11:02:28 <lambdabot>  [3,7,11]
11:02:40 <joe_k> my real goal is to take a list and return all the subsequences of it
11:02:52 <shapr> Do you want code to do that, or would you rather figure it out yourself?
11:03:06 <joe_k> i.e. [1,2,3] -> [[1],[2],[3],[1,2],[2.3],[1,2,3]]
11:03:20 <joe_k> well i am halfway learning haskell and halfway need to get something done
11:03:28 <joe_k> so probably the code which i can then learn from
11:03:51 <norpan> joe_k: the normal way to do such functions is to do recursion with the two cases [] and (x:xs)
11:04:51 <norpan> and in the (x:xs) case use the result of (function xs)
11:10:29 <shapr> joe_k: http://www.haskell.org/hawiki/LicensedPreludeExts
11:11:01 <shapr> joe_k: Look for permutations, combinations, etc
11:13:32 <joe_k> is it me or is ghci a pain in the ass?
11:13:40 <joe_k> is there any way to enter multi-line expressions?
11:14:07 <sjanssen_> > let x = 5; y = 4 in x + y
11:14:07 <lambdabot>  9
11:14:09 <shapr> joe_k: I use emacs and C-c C-l
11:14:22 <sjanssen_> joe_k: use semi-colons
11:14:45 <sjanssen_> but anything longer than a line or two should probably go into a file that you load into ghci
11:17:02 <bringert> shapr: does HSQL compile now?
11:18:16 <the_lord> > concat (intersperse ", " ["a" , "b", "c"])
11:18:17 <lambdabot>  "a, b, c"
11:19:02 <ihope> @djinn M (M a) -> M a
11:19:02 <lambdabot> -- f cannot be realized.
11:19:07 <ihope> Eh.
11:19:29 * ihope kicks lambdabot
11:19:39 <roconnor> @instances Arbitrary
11:19:41 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
11:19:42 <ihope> s/lambdabot/@djinn/
11:20:00 <roconnor> @instances Test.QuickCheck.Arbitrary
11:20:08 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
11:20:18 <ihope> @instances Num
11:20:19 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
11:21:08 <roconnor> @instances-importing Test.QuickCheck Arbitrary
11:21:10 <lambdabot> (), (a, b), Bool, Double, Float, Int, Integer, [a]
11:21:25 * roconnor wishes Rational was in that list
11:21:45 <sjanssen_> ihope: yeah, I wonder why Djinn can't derive bind
11:22:00 <apfelmus> @type join -- ihope 
11:22:01 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:22:25 <ihope> sjanssen_: was that sarcasm?
11:22:33 <JohnMeacham> shapr: update your DrIFT
11:22:57 <ihope> @djinn M a -> (a -> M b) -> M b
11:22:58 <lambdabot> f = bind
11:23:08 <ihope> @djinn M b -> (b -> M a) -> M a
11:23:09 <lambdabot> -- f cannot be realized.
11:23:12 <ihope> Meh.
11:24:21 <sjanssen_> ihope: actually, I meant to say join.  And I'd really like to know why Djinn can't figure it out
11:25:40 <ihope> I'm guessing it's because Djinn simply passes all the defined thingies into your function.
11:26:05 <ihope> In this case, it would be trying to get (M a -> (a -> M b) -> M b) -> M (M a) -> M a.
11:26:46 <ihope> @djinn M (M a) -> M a
11:26:46 <lambdabot> f a = bind' a (\ b -> b)
11:27:02 <ihope> Now, see, it's bind', not bind.
11:27:09 <ihope> @djinn M (M b) -> M b
11:27:10 <lambdabot> -- f cannot be realized.
11:27:14 <ihope> It still can't do that.
11:27:34 <sjanssen_> that's silly
11:28:47 <sjanssen_> so it doesn't understand type variables
11:28:55 <ihope> I guess not.
11:30:13 <ihope> @djinn-clr
11:35:31 <joe_k> concatMap (filter (/=[])) (map inits (tails [1,2,3,4])) is kind of what I want but in a non-preferable order
11:36:22 <sjanssen_> > concatMap (filter (/=[]) $ map inits $ tails [1, 2, 3]
11:36:22 <lambdabot>  Parse error
11:37:01 <sjanssen_> > concatMap $ filter (/=[]) $ map inits $ tails [1, 2, 3]
11:37:01 <lambdabot>  Couldn't match `a -> [b]' against `[[[a1]]]'
11:37:03 <bolrod> isn't that segs ?
11:37:19 <roconnor> @hoogle segs
11:37:20 <lambdabot> No matches found
11:37:29 <bolrod> segments
11:37:34 <roconnor> @hoogle segments
11:37:35 <lambdabot> Network.URI.normalizePathSegments :: String -> String
11:37:36 <bolrod> blah. don't think it's in the lib
11:38:25 <joe_k> is that what $ is for. dang
11:38:28 <roconnor> > map inits $ tails [1, 2, 3]
11:38:29 <lambdabot>  [[[],[1],[1,2],[1,2,3]],[[],[2],[2,3]],[[],[3]],[[]]]
11:38:47 <roconnor> > concatMap inits $ tails [1, 2, 3]
11:38:49 <lambdabot>  [[],[1],[1,2],[1,2,3],[],[2],[2,3],[],[3],[]]
11:39:00 <roconnor> > filter (not.null) $ concatMap inits $ tails [1, 2, 3]
11:39:01 <lambdabot>  [[1],[1,2],[1,2,3],[2],[2,3],[3]]
11:39:49 <bolrod> substrings 
11:40:10 <roconnor> $ means the rest of the expression after the $ is all one arguement
11:40:15 <bolrod> no
11:40:15 <joe_k> ideally they'd be  [1],[2],[3],[1,2],[2,3],[1,2,3]
11:40:21 <bolrod> wait :(
11:41:18 <bolrod> > [t | i <- inits xs , tails i , not (null t)]
11:41:18 <lambdabot>  Not in scope: `t'
11:41:36 <bolrod> > [t | i <- inits [1,2,3,4] , t<-tails i , not (null t)]
11:41:37 <lambdabot>  [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4]]
11:42:06 <shapr> bringert: yup!
11:42:20 <bringert> got hope working?
11:42:36 <shapr> bringert: Now I need to rebuild haskelldb, haskelldb-hsql, hawl and hope, yeah?
11:42:53 <bringert> and haskelldb-hsql-postgresql
11:42:55 <bringert> yes
11:42:56 <shapr> ah right
11:43:02 <bringert> not haskelldb though
11:43:08 <bringert> not hawl either
11:43:16 <bringert> since they don't use HSQL in any way
11:43:48 <sjanssen_> > let list = [1, 2, 3] in [take len $ drop off list | len <- [1.. length list], off <- [0 .. length list - len]
11:43:48 <lambdabot>  Parse error
11:43:57 <sjanssen_> > let list = [1, 2, 3] in [take len $ drop off list | len <- [1.. length list], off <- [0 .. length list - len]]
11:43:58 <lambdabot>  [[1],[2],[3],[1,2],[2,3],[1,2,3]]
11:44:02 <shapr> oh
11:47:10 <joe_k> wow
11:51:09 <sjanssen_> > ap ((>>=) . enumFromTo 1 . length) (ap (ap . (((>>=) . enumFromTo 0) .) . (-) . length) (((return .) .) . flip ((.) . take) . flip drop)) [1..3]
11:51:10 <lambdabot>  [[1],[2],[3],[1,2],[2,3],[1,2,3]]
11:51:39 <sjanssen_> joe_k: how about that?
11:52:07 * joe_k 's head explodes
11:52:13 <cjay> :D
11:52:39 <sjanssen_>  @pl is my friend
11:58:06 <resiak> sjanssen_: EEW
12:05:37 <vincenz> re
12:06:58 <bringert> > foldr (\x xs -> xs ++ map (x:) xs) [[]] [1,2,3]
12:06:59 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:07:46 <apfelmus> > foldr (\x xs -> xs ++ map (x:) xs) [[]] [1,2,3,4]
12:07:47 <lambdabot>  [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,2,...
12:07:59 <sjanssen_> that's subsets, not substrings
12:08:11 <bringert> oh, sorry
12:08:27 <bringert> didn't look too carefully at what you were doing
12:08:56 <int-e> > inits [1,2,3,4] >>= init . tails
12:08:58 <lambdabot>  [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4]]
12:09:27 <vincenz> @hoogle init
12:09:27 <lambdabot> Prelude.init :: [a] -> [a]
12:09:28 <lambdabot> List.inits :: [a] -> [[a]]
12:09:28 <lambdabot> System.Console.Readline.initialize :: IO ()
12:09:42 <vincenz> inits [1..4] >>= tails
12:09:47 <vincenz> > inits [1..4] >>= tails
12:09:47 <lambdabot>  [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[]]
12:10:07 <vincenz> > init []
12:10:08 <lambdabot>  Add a type signature
12:10:10 <vincenz> > init [1]
12:10:11 <lambdabot>  []
12:10:13 <vincenz> > init [1,2
12:10:13 <lambdabot>  Parse error
12:10:15 <vincenz> > init [1,2]
12:10:16 <lambdabot>  [1]
12:10:26 <int-e> you get n+1 empty substrings there - one before 1, one before 2, etc, and one after 4.
12:10:41 <vincenz> rightio
12:10:52 <sjanssen_> vincenz: there's an additional requirement that the output is sorted by length
12:11:16 <vincenz> > sortBy length (inits [1..4] >>= init . tails)
12:11:17 <lambdabot>  Couldn't match `Int' against `t -> t1'
12:11:30 <vincenz> > sortBy (\a b -> length a `compare` length b) (inits [1..4] >>= init . tails)
12:11:31 <lambdabot>  [[1],[2],[3],[4],[1,2],[2,3],[3,4],[1,2,3],[2,3,4],[1,2,3,4]]
12:11:47 <vincenz> sjanssen_: that requirement, t.b.h is rather orthogonal
12:11:50 <int-e> > concat $ transpose $ map inits $ tails [1,2,3,4]
12:11:51 <lambdabot>  [[],[],[],[],[],[1],[2],[3],[4],[1,2],[2,3],[3,4],[1,2,3],[2,3,4],[1,2,3,4]]
12:12:00 <sjanssen_> > ap ((`ap` enumFromTo 1) . ((=<<) .) . (. ((enumFromTo 0 .) . (-))) . ap . (fmap .) . flip ((.) . take) . flip drop) length [1..3]
12:12:00 <lambdabot>  [[1],[2],[3],[1,2],[2,3],[1,2,3]]
12:12:09 <vincenz> sjanssen_: youre code isillegible
12:12:20 <sjanssen_> vincenz: it's been @pl'ed
12:12:47 <vincenz> > filter (not . null) $ concat $ transpose $ map inits $ tails [1..4]
12:12:48 <int-e> (transpose works on triangular 'things', too)
12:12:48 <lambdabot>  [[1],[2],[3],[4],[1,2],[2,3],[3,4],[1,2,3],[2,3,4],[1,2,3,4]]
12:13:31 <vincenz> int-e: like sandwiches?
12:14:18 <int-e> > (([]:) . concat . transpose . map (tail . inits) . tails) [1,2,3,4]
12:14:19 <lambdabot>  [[],[1],[2],[3],[4],[1,2],[2,3],[3,4],[1,2,3],[2,3,4],[1,2,3,4]]
12:14:30 <int-e> vincenz: if you encode them as lists :)
12:15:30 <int-e> vincenz: a list of lists with non-increasing length. I think I've seen a term for that somewhere ... tableau?
12:16:35 <vincenz> int-e: top-diagonal-matrix?
12:18:03 <int-e> > ([]:) $ concat $ transpose $ map (tail . reverse . tails) $ inits [1,2,3,4]
12:18:04 <lambdabot>  [[],[1],[2],[3],[4],[1,2],[2,3],[3,4],[1,2,3],[2,3,4],[1,2,3,4]]
12:19:04 <int-e> (that one is more efficient, O(n^2) instead of O(n^3) where n is the length of the list)
12:19:12 * vincenz sighs
12:19:46 <int-e> vincenz: as a special case, if I interpret the term correctly.
12:19:53 * vincenz rubs his temples
12:20:01 <vincenz> I have to annotate my type
12:20:11 * vincenz kicks a nearby java-coder
12:20:33 <psnl> ouch
12:20:57 <vincenz> yah
12:21:29 <vincenz> fuc
12:23:36 <vincenz> this is pissing me of
12:24:31 <int-e> vincenz: Young tableaus are what I remembered: http://mathworld.wolfram.com/YoungTableau.html
12:24:45 <vincenz> look hw ugly
12:24:45 <vincenz> type TypedMonoType = MonoType MonoType
12:24:45 <vincenz> type TypedPolyType = PolyType TypedMonoType
12:26:02 <vincenz> AARRGGH
12:26:20 <SamB> aww, nuts!
12:26:35 <bringert> shapr: how is it working out?
12:26:42 <SamB> trang won't translate SGML DTDs into RelaxNG Compact :-(
12:27:58 <vincenz> can you make circular instnaces?
12:28:29 * joe_k 's head explodes again
12:28:38 <vincenz> I guess not
12:29:01 <joe_k> i wasn't exploding at you ;(
12:29:03 <joe_k> err ;)
12:29:15 <vincenz> hmm
12:29:18 <vincenz> this will never owrk :(
12:29:24 <vincenz> data MonoType mt = 
12:29:27 <vincenz>   TyVar Id
12:29:35 <vincenz>     TyConst Ident [mt]
12:29:41 <vincenz> MonoType MonoType
12:30:09 <int-e> but. you can make newtype Mu x = In { out :: x (Mu x) }
12:30:25 <vincenz> newtype TypedMonoType = MonoType TypedMonoType
12:30:25 <int-e> and use Mu MonoType ... I think that's what you want?
12:30:33 <vincenz> int-e: right
12:30:37 <vincenz> int-e: can I now use an instance?
12:30:37 <apfelmus> int-e: although the key point of young tableaus is not necessarily their triangularity...
12:31:16 <vincenz> can someone help me with this?/
12:31:20 <int-e> apfelmus: of course not. But I thoght they were called Tableaus because of their shape. Apparently that term isn't used in other contexts.
12:32:35 <BCoppens> int-e: there are also tableaus in logic, no?
12:32:48 <int-e> BCoppens: they are totally different though.
12:33:08 <int-e> vincenz: err, instance, where, how, what?
12:33:12 <vincenz> http://rafb.net/paste/results/kLpqzN27.html
12:33:31 <BCoppens> int-e: yeah, but I thought you meant 'other context' just 'anything else'
12:34:05 <int-e> vincenz: wanna see how I made a Show instance for that Mu thingy?
12:34:23 <vincenz> int-e: yep!
12:35:00 <lisppaste2> int-e pasted "Mu with Show" at http://paste.lisp.org/display/20982
12:35:50 <vincenz> int-e: freaky
12:35:54 <the_lord> what's the module of intersperse?
12:36:03 <vincenz> List
12:36:09 <the_lord> thx
12:37:04 <int-e> vincenz: it was fun to write though. I've never actually used it.
12:37:23 <vincenz> int-e: well what do you suggest?
12:37:28 <vincenz> int-e: explicitly annotating?
12:39:37 <apfelmus> vincenz: ? where is the problem? do you mean TyConst Const [MonoType mt]? 
12:39:50 <vincenz> apfelmus: no I do not
12:40:05 <vincenz> i use a similar system for Exp, but there it's less of an issue
12:40:25 <sjanssen_> @keal
12:40:25 <lambdabot> with KealDigit quantum crackproof encryption possible
12:40:34 <vincenz> http://rafb.net/paste/results/zcRu0J30.html
12:40:51 <int-e> vincenz: hmm. I think the approach I took for Show carries over to that ... newtype MuHasVars = MuHasVars { muFreeVars :: [Id] }
12:41:22 <ihope> Hmm...
12:41:53 <vincenz> int-e: it's messy as hell
12:42:01 <int-e> or maybe [Id] -> [Id] (that's really equivalent to ShowS)
12:42:38 <apfelmus> vincenz: you wanna tie a recursive knot on exp later? like MuExp = Exp _ _ (Int,MuExp)
12:43:00 <vincenz> I do that already
12:43:07 <vincenz> except I can hang on more nifty stuff
12:43:12 <int-e> vincenz: Indeed. You might be better off with always having annotations (and use () for them where you don't need them)
12:43:32 <vincenz> int-e: it's ugly as hell tho
12:43:46 <ihope> So what's the ASCII escape character in Haskell?
12:44:07 <bringert> shapr: thanks for finding the GHC_RTS_OPTS bug. it fixed some intermittent image upload problems I was having with hope
12:44:10 <vincenz> > '\ESC'
12:44:11 <lambdabot>  '\ESC'
12:44:16 <ihope> Oh.
12:44:18 <vincenz> > ord '\ESC'
12:44:19 <lambdabot>  27
12:44:21 <ihope> Thanks.
12:45:01 <int-e> vincenz: I've not tried hard to find a general pattern there, but I suspect it doesn't really generalize very well.
12:45:16 <vincenz> int-e: sadly
12:45:46 <int-e> vincenz: (beyond the fold and unfold that is, they're actually very nice.)
12:46:20 <apfelmus> \action is still confused
12:46:22 <vincenz> int-e: yeah I always use indirect composite
12:46:32 <vincenz> especially for AST's
12:46:36 <vincenz> here let me demonstrte
12:46:55 <vincenz> http://rafb.net/paste/results/eNDXta52.html
12:47:12 <vincenz> it's very nice cause I can shortcut stuff out of my AST
12:47:18 <vincenz> for instance Decl is no longer used after importer
12:47:24 <vincenz> cause some things are rolled in differently
12:47:26 <int-e> apfelmus: ironically I should call the thing Nu instead of Mu.
12:47:30 <shapr> bringert: You put in most of the work, I just compiled your tests :-)
12:47:39 <vincenz> int-e: instead of "Later"?
12:48:10 <bringert> you're the one who said "maybe we should try without ghc_rts_opts"
12:48:37 <bringert> hmm, it doesn't seem to have solved the image upload problem completely
12:49:12 <vincenz> int-e: seen the paste?
12:49:16 <apfelmus> int-e: mmh, in strict languages, nu doesn't exist, does it? so mu might be ok then ;-)
12:50:37 <int-e> apfelmus: but Haskell is lazy, and it's possible to represent at least some infinite lists and trees.
12:51:18 <apfelmus> int-e: sure. that brings th
12:51:24 <int-e> vincenz: yes.
12:51:37 <int-e> vincenz: I don't know what the 'Later' comment was about though.
12:51:39 <apfelmus> problem wether mu exists in lazy languages.
12:51:55 <vincenz> int-e: Nu in dutch means now
12:52:00 <vincenz> int-e: and later means later
12:52:28 <vincenz> int-e: notice how every thing in my AST is a tyvar?
12:52:29 <int-e> vincenz: Ah. I see.
12:53:07 <int-e> vincenz: yes. and you can use that to add annotations, or reuse grammar rules while changing others. it's neat.
12:53:07 <vincenz> I'm prolly gonna simplify it more
12:53:12 <vincenz> and just ELit value
12:53:17 <vincenz> with the value plugged in right away
12:53:42 <vincenz> instead of separate Ebool, Enil and Eint
12:53:56 <vincenz> int-e: in fact it's slightly flawed
12:54:00 <vincenz> int-e: notice the [exp]
12:54:07 <vincenz> int-e: this should be abstracted too
12:54:10 <vincenz> int-e: in case later I want a CFG
12:54:15 <vincenz> int-e: instead of a plain list
12:54:31 <vincenz> but yeah, lazyness
12:55:09 <SemanticPhilosop> @help
12:55:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:55:14 <SemanticPhilosop> @list
12:55:15 <lambdabot> list [module|command]. Where modules is one of:
12:55:15 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact fresh haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system
12:55:15 <lambdabot> todo topic type unlambda version vixen where
12:55:27 <SemanticPhilosop> @list unlamda
12:55:28 <lambdabot> No module "unlamda" loaded
12:55:33 <SemanticPhilosop> @list unlambda
12:55:34 <lambdabot> unlambda provides: unlambda
12:55:38 <shapr> bringert: ./Hope/Module.hs:64:15: Not in scope: `outputNotFound' ?
12:55:50 <SemanticPhilosop> @help unlambda
12:55:51 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
12:56:06 <SemanticPhilosop> @help system
12:56:06 <lambdabot> system provides: echo list listchans listmodules uptime
12:56:09 <int-e> @unlambda `r`.!`.d`.l`.r`.o`.w`. `.,`.o`.l`.l`.e`.Hv
12:56:10 <lambdabot> Hello, world!
12:56:13 <bringert> shapr: you updated hope this morning didn't you? you need to pull newcgi and hawl too
12:56:18 <shapr> ah, ok
12:56:29 * shapr wishes for cabal-get again
12:56:35 <apfelmus> int-e: ah, of course mu=nu in when being lazy, so nomencalture doesn't matter 
12:56:36 <bringert> this is the bleeding edge for you
12:56:52 <norpan> wtf is unlambda
12:57:09 <SemanticPhilosop> @listchans
12:57:10 <lambdabot> #darcs #flippi #gentoo-haskell #haskell #haskell-blah #haskell-overflow #haskell.es #haskell.it #haskell.se #haskell_ru #perl6 #scannedinavian
12:57:11 <bringert> shapr: maybe I should make the effort to have versioned dependencies
12:57:22 <int-e> unlambda is a nightmarish combinator calculus based programming language
12:57:27 <Cale> norpan: a functional programming language with no mechanism for abstraction whatsoever
12:57:44 <int-e> to make things worse, it borrows the call/cc feature from scheme
12:57:47 <apfelmus> SemanticPhilosop: /query lambdabot rocks
12:57:53 <int-e> and of course there are combinators with side effects.
12:58:21 <shapr> bringert: Not during beta
12:58:29 <SemanticPhilosop> > sum [1..10]
12:58:30 <lambdabot>  55
12:58:40 <shapr> bringert: Wait till you have more users :-)
12:58:52 <norpan> i like yot
12:59:11 <norpan> errr, jot
12:59:26 <the_lord> @hoogle show
12:59:27 <lambdabot> Prelude.show :: Show a => a -> String
12:59:27 <lambdabot> Text.Show :: module
12:59:27 <lambdabot> Prelude.Show :: class Show a
13:00:14 <bringert> shapr: yeah, that's what I was thinking
13:00:35 <vincenz> this is odd
13:00:37 <shapr> I'm becoming fond of "darcs pull -a && runghc Setup.hs clean && runghc Setup.hs configure && runghc Setup.hs build" I just need to find a way to map it over directories.
13:00:59 <bringert> shapr: a bash for loop?
13:01:10 <shapr> or maybe xargs
13:01:18 <vincenz> @type concatMap
13:01:19 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
13:01:38 <vincenz> int-e: care to help me debug something?
13:02:01 <vincenz> nm
13:02:05 <int-e> (as an example why call/cc is strange, consider this: ``ci`r`.!`.d`.l`.r`.o`.w`. `.,`.o`.l`.l`.e`.H`c``sc``sc``sc`ki ... it prints 'Hello, world!' 107 times. I've still not quite figured out where this 107 comes from.)
13:02:22 <the_lord> how do I print a newline?
13:02:37 <int-e> putStrLn ""
13:02:37 <apfelmus> > print "\n"
13:02:38 <lambdabot>  No IO allowed
13:02:46 <int-e> putStr "\n"
13:03:35 <apfelmus> int-e: this, i will never get right
13:03:57 <int-e> putChar '\n' <-- that's what putStrLn uses.
13:06:18 <shapr> bringert: It seems to work, except that http://localhost/cgi-bin/hope.cgi forwards to http://localhost/cgi-bin/entry for some reason.
13:06:42 <shapr> hopeBase shouldn't be hopeBase = uri "http://localhost/cgi-bin/", ?
13:07:07 <bringert> shapr: well yes, if you but hope.cgi there, and the htaccess file
13:07:28 <bringert> and don't mind hope taking over urls in your cgi-bin
13:07:37 <bringert> s/but/put/
13:07:54 <shapr> Ah, I see.
13:08:10 <bringert> hope/cgi wants to be the directoryindex, so you may want to put it in cgi-bin/hope
13:08:20 <bringert> and make that hopeBase, and put htaccess there
13:08:32 <shapr> Ok
13:09:18 <bringert> it's a trick to get nice URLs
13:09:29 <Stinger_> its odd how all this strictly defined mathematics seems to be built on something we can't really define :)
13:09:35 <int-e> apfelmus: Well, you can't encode Mu as a datatype in Haskell. You need code that maintains the finiteness constraint.
13:09:44 <Stinger_> damnit 
13:09:50 <Stinger_> wrong chan :P
13:09:52 <vincenz> Anyone a happy user?
13:10:16 <bringert> shapr: thus http://hope.bringert.net/ is my hopeBase, and I get nice URLs like http://hope.bringert.net/date/2006/06
13:11:30 <shapr> I may do that for hope.ScannedInAvian.com
13:12:20 <apfelmus> int-e: how do you get a finite length encoding in first place, then? carrying Int around is cheating (and wrong)
13:12:23 <int-e> apfelmus: at least I would rather preserve the mathematical definition than saying that Mu and Nu are the same.
13:13:05 <int-e> apfelmus: well, you can enforce strictness by using `seq`
13:13:46 <int-e> apfelmus: (basically do what deepSeq would do)
13:13:59 <apfelmus> int-e: i mean T=I for our category here
13:14:59 <bringert> hehe, every time I edit a hope entry, it gets pushed 7 hours into the future. stupid timezones
13:15:01 <lispy> hope?
13:15:10 <apfelmus> int-e: ok, seq will do. let's call this semi-cheating ;-). data List a = Nil |Cons a !(List a)
13:15:17 <bringert> lispy: http://hope.bringert.net/
13:16:08 <lispy> bringert: yeah, i was just peeking....interesting
13:16:13 <lispy> bringert: how's it going?
13:16:33 <bringert> lots of TODOs
13:16:49 <bringert> but the basics seem to be mostly working
13:16:55 <lispy> image 5 is really, really neat-o by the way
13:17:07 <lispy> what type of boat is that?
13:17:24 <bringert> that's Gtheborg III
13:17:32 <int-e> apfelmus: I'm on very shaky ground there; I don't know how that category works. You're quite possibly right (without strictness annotations).
13:17:53 <bringert> lispy: http://www.soic.se/
13:18:23 <lispy> bringert: my only language is english :(
13:18:30 * lispy tries to find the google translator
13:18:36 <shapr> bringert: Shouldn't the htaccess bits work in my main apache2 config as well?
13:18:48 <bringert> lispy: try the british flag in the top right
13:18:52 <lispy> bringert: oh, i see a link to english actually :)
13:18:57 <lispy> bringert: yeah, just found it! :)
13:19:18 <bringert> shapr: sure, may need a <Directory> though
13:19:54 <palomer> @palomer
13:19:54 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
13:20:07 <shapr> Hm, will <Location> work the same way?
13:20:08 <boegel> @boegel
13:20:08 <lambdabot> Unknown command, try @list
13:20:20 <boegel> :)
13:20:20 * boegel poofs
13:20:27 <apfelmus> int-e: i'm relatively sure. i mean, you can always do x = Cons Nil x and get something useful. 
13:20:41 <bringert> shapr: I'm not an Apache wizard. Is there a problem with using .htaccess on your server?
13:20:50 <shapr> Probably not...
13:20:52 <bringert> or you don't like the performance hit?
13:21:05 <lispy> @keal
13:21:06 <lambdabot> actually it bug in math
13:22:18 <int-e> apfelmus: I'm not quite sure because it seems to involve computatbility. Nu x should contain uncomputable elements, Mu x probably shouldn't.
13:22:49 <lispy> heh, i see joelr is causing trouble again :)
13:23:06 <lispy> questoning people about their HAppS usage :)
13:24:28 <apfelmus> int-e: mh. non being computable means x = _|_ (?). and [1..] is not _|_
13:25:07 <shapr> bringert: I can't get the rewriting to work for some reason.
13:25:17 <lispy> > undefined == undefined
13:25:18 <lambdabot>  Add a type signature
13:25:24 <bringert> shapr: what happens?
13:25:35 <bringert> shapr: is mod_rewrite loaded?
13:25:44 <shapr> I think so
13:25:53 <int-e> apfelmus: an infinite list is computable if every initial segment of it is computable. (I think that's a common definition; it applies, for example, for decimal expansion of real numbers)
13:25:59 <bringert> try removing the IfModule, that should show you
13:26:12 <bringert> from around the rewrite stuff , that is
13:26:21 <shapr> oh, duh
13:26:32 <shapr> It's not enabled.
13:26:58 <bringert> maybe I shouldn't have the IfModule there, that way it fails more obviously
13:26:58 <int-e> apfelmus: anyway, I'll leave it at that. The discussion is not really about Haskell anymore.
13:27:18 <lispy> int-e: maybe not, but you just got my attention :)
13:27:29 <lispy> int-e: what do you mean by initial segment?
13:28:02 <int-e> lispy: I should've said finite initial segment - the stuff inits returns.
13:30:16 <int-e> (equivalently, if you view an infinite list as a function list: N -> X, list is computable iff list(n) is computable for every n in N)
13:31:08 <lispy> int-e: so individual reals are computable in their decimal expansion?
13:32:02 <int-e> lispy: most are not, by a simple counting argument (algorithms are countable; reals are not, hence most reals aren't computable)
13:32:04 <apfelmus> int-e: ok. (although i think it's about language semantics). yet i wonder, if one can construct an ADT which only allows finite size. i mean one that has no Cons Nil equivalent to allow x = Cons Nil x
13:32:28 <lispy> int-e: that sounds familiar
13:32:44 <int-e> lispy: on the other hand, many interesting real numbers are computable, like pi, e, sqrt(2), ln 2 ...
13:33:46 * lispy wonders  if there are any well known non-computable reals
13:34:19 <Stinger_> doubt it
13:35:23 <cjay> afaik there is at least one
13:35:42 <lispy> wouldn't cantor's diagonal argument give one :)
13:35:56 * lispy is not completely serious because his was a proof of contradiction
13:36:25 <apfelmus> lispy: i don't if memory tricks me here, but i think there is paper in which the first digits of a non-computable real where ahem, written down. but it might have been a random real instead
13:37:02 <lispy> i suspect there may be phisolophical relationship between a non-computable real and a 'random' real
13:37:32 <xerox> #arr
13:37:40 <xerox> ?arr even.
13:37:41 <lambdabot> This is the END for you, you gutter-crawling cur!
13:37:48 <Stinger_> yeah if we know about a real, then dont we by definition have enough info to pin it down?
13:38:05 <lispy> there is this: http://www.cs.nyu.edu/pipermail/fom/2001-September/005021.html
13:38:37 <lispy> they mention, x is a random real <===> x is an Omega-like real, whatever that means
13:39:57 <vincenz> any monadic experts around?
13:41:05 <lispy> this is fascinating...the concept of a valid real number that cannot be written down by its decimal expansion
13:41:15 <apfelmus> vincenz: maybe, what's up?
13:41:45 <vincenz> having typing issues
13:41:54 <sachu> lispy: Omega as in the sense of Chaitin?
13:42:04 <int-e> . o O ( 0.123456789 are the initial digits of a noncomputable real )
13:42:27 <vincenz> apfelmus: basically I want a monad with extra parameters
13:42:49 <sachu> I remember reading something about Chaitin's work on random strings, which ended with a mention of Omega.
13:43:09 <norpan> lispy: if you buy that there are undecidable problems, then you'll have no problem buying uncomputable numbers
13:43:10 <int-e> lispy: what's even more funny is that the initial segments are enumerable.
13:43:19 <apfelmus> int-e: ok, that was easy...
13:43:31 <BCoppens> sachu: isn't Chaitin's Omega the probability that a random (turing?) machine will halt
13:43:36 <apfelmus> vincenz: please elaborate
13:43:44 <vincenz> nm
13:43:55 <lispy> sachu: yes that Omega but i know nothing about it
13:44:23 <sachu> BCoppens: I'm afraid I don't remember it very well, but Chaitin's paper was very readable. Let me see if I can find it.
13:44:50 <vincenz> type (HasVars mt) => TyperContext = M.Map ScopedIdent (PolyType mt)
13:44:56 <BCoppens> sachu: ok :)
13:45:32 <norpan> lispy: just enumerate all instances for which the undecidable problem should be solved, and if the solution is true then put a 1 there, otherwise put a 0 there. you'll get a real number but since individual problems are undecidable, you'll get uncomputable digits
13:45:41 <norpan> basically
13:46:26 <norpan> but it's bed time
13:46:29 <norpan> @localtime norpan
13:46:32 <lambdabot> Local time for norpan is Wed Jun  7 22:46:09 2006
13:46:36 <shapr> bringert: It WORKS!
13:46:38 <lispy> norpan: okay
13:46:39 <norpan> early night tonight
13:46:41 * shapr boings furiously
13:46:44 <bringert> shapr: sweet!
13:47:23 <shapr> style dir goes into hopeBase, or where?
13:47:32 <bringert> yeah
13:47:42 <apfelmus> vincenz: and you want a MonadReader?
13:47:49 <bringert> and you also need the style and script dirs from all the modules
13:47:57 <bringert> the ones that have any, that is
13:48:13 <bringert> make installball-cgi will get you what you need
13:48:13 <shapr> ouch: user error (ERROR: for SELECT DISTINCT, ORDER BY expressions must appear in select list )
13:48:29 <bringert> ooo
13:48:30 <shapr> halbum doesn't like zero photos?
13:48:39 <bringert> it does for me
13:48:44 <shapr> hmm
13:48:48 <bringert> must be a HaskellDB / PostgreSQL thing
13:48:55 <shapr> dunno
13:48:56 <bringert> I've only tried MySQL and SQLite3
13:49:16 <shapr> Well, this is what beta testing is for...
13:49:34 <shapr> Silly question, can I get the homepage to show the last N blog entries and the last N photos as well?
13:49:41 <bringert> shapr: can you turn on query logging
13:49:53 <shapr> Requires a recompile, yeah?
13:50:07 <bringert> shapr: currently all the homepage does is to redirect to the list of all entries
13:50:23 <sachu> BCoppens: I found the papers, but they are not about Omega: my memory played some tricks on me. In case you haven't seen them, they are here: http://www.cs.auckland.ac.nz/CDMTCS/chaitin/ieee74.html and http://www.cs.auckland.ac.nz/CDMTCS/chaitin/sciamer.html
13:50:34 <bringert> shapr: a simple module to could do what you want
13:50:39 <shapr> spiffy
13:50:43 <sachu> @localtime sachu
13:50:47 <BCoppens> sachu: aha, thanks anyway :-)
13:50:58 <BCoppens> sachu: might be interesting to read anyway :)
13:51:00 <shapr> Time for me to install this on ScannedInAvian.com
13:51:24 <sachu> BCoppens: ya, they are interesting, and reads like a story
13:51:32 <BCoppens> sachu: nice :)
13:51:55 <shapr> bringert: Blob2 is way cool, I like the clickability of year, month, and day.
13:52:34 <shapr> bringert: manually add new logins atm?
13:53:12 <bringert> shapr: don't you have Users -> Add user link when logged in?
13:53:18 <shapr> Oh, yeah.
13:53:25 <shapr> neat
13:53:29 <bringert> the permission system is crude atm
13:53:41 <bringert> when there are 0 users anyone can add a user
13:53:54 <bringert> when there are users, all logged in users can add users
13:54:09 <shapr> Since I like to edit my blog entries in emacs, is an xmlrpc or other upload flavor planned?
13:54:09 <vincenz> crap cruddy crid
13:54:31 <bringert> shapr: yes, there should be something like that
13:54:40 <BCoppens> sachu: ah I see the second one is written for scientific american, they usually have nice and readable articles indeed :)
13:54:56 <bringert> shapr: Blob 1 had it
13:55:00 <shapr> Is there an RSS feed? I saw the RSS patch go buy, but I can't find the feed.
13:55:10 <shapr> by*
13:55:16 <sachu> Hi all, newbie question: I am trying to learn Haskell. Are there some programming puzzles/small problems around that would help me learn the language and its idioms? 
13:55:30 <bringert> shapr: the feed is in the headers
13:55:42 <bringert> you may need browser support to see the link
13:55:42 <shapr> ohh
13:56:07 <sachu> BCoppens: I read those for my graduation seminar work, a few years back. Never pursued them after that, though.
13:56:16 <shapr> whoa spiffy :-)
13:56:35 <BCoppens> sachu: :)
13:56:37 <bringert> I think there is a problem with character encodings in RSS feeds.
13:56:45 <shapr> How so?
13:56:54 <JohnMeacham> shapr: did you get my note about DrIFT?
13:57:05 <shapr> JohnMeacham: Yeah, just haven't gotten around to upgrading it yet.
13:57:07 <bringert> Try using  in a blob entry and look at the feed
13:57:14 <shapr> JohnMeacham: I'll get back to you soon :-)
13:57:32 <apfelmus> vincenz: i begin to worry about your being, you are still there?
13:57:47 <shapr> bringert: ouch, 500 Internal Server Error \n Prelude.read: no parse
13:57:54 <bringert> what?
13:58:04 <joe_k> is there a way to convert a random tuple or list to string?
13:58:16 <int-e> joe_k: show
13:58:21 <bringert> shapr: what did you do?
13:58:30 <vincenz> apfelmus: huh?
13:58:31 <shapr> I broke something else it seems :-)
13:58:33 <joe_k> where  the tuple or list is composed of maybe tuples or lists of Ints and Doubles
13:58:44 <apfelmus> vincenz: i mean the monad question
13:58:46 <shapr> ohh
13:58:53 <bringert> shapr: I don't think I use read without checking the results
13:58:56 <bringert> maybe I do
13:59:42 <shapr> I'm getting one char per line in the error messages.
13:59:45 <shapr> I saw that with darcs once.
13:59:50 <int-e> sachu: hmm. try to implement some prelude functions yourself? a sort? or are you looking for something more advanced than that?
13:59:58 <int-e> grmbl
14:00:30 <int-e> > show (1,2,[3,4])
14:00:32 <lambdabot>  "(1,2,[3,4])"
14:00:32 <vincenz> apfelmus: oh I got it
14:00:35 <vincenz> this is getting ugly
14:00:44 <JohnMeacham> shapr: cool. the strictness analyser is still broken though. if anyone has one laying around.....
14:02:06 <bringert> shapr: that happend to me too somethings. I guess it's because stderr isn't buffered
14:02:13 <int-e> joe_k: your description sounds like you're mixing types in the same place though, that's not possible. (1.0, "a") and ("b",1.2) are not compatible.
14:02:28 <bringert> and putStrLn outputs one character at a time
14:02:29 <int-e> joe_k: and you can't have lists with members of different types.
14:02:47 <shapr> bizarre
14:02:50 <wilx> What is a "KISS mentality"?
14:03:11 <apfelmus> wilx: keep it stupid & simple
14:03:16 <wilx> Ah, nice :)
14:03:20 <shapr> or, Keep It Simple, Stupid
14:03:39 <apfelmus> shapr: even this is complicated
14:03:42 <shapr> hah
14:03:48 <shapr> wilx: http://c2.com/cgi-bin/wiki?ScreechinglyObviousCode
14:04:01 <joe_k> int-e: i really need to be using records or data types but I am just gluing things together in tuples for now
14:04:11 <wilx> Thanks.
14:05:17 <shapr> bringert: installball is great.
14:05:20 <int-e> joe_k: show will print it, unless you have some unprintable data in the record (or list), like functions.
14:05:30 <int-e> joe_k: print --> convert to a string
14:05:31 <shapr> Still dunno what the problem is with adding entries.
14:05:35 <joe_k> ok heres another one.... can I interrupt a running haskell program? 
14:05:42 <joe_k> ctrl-c and ctrl-break dont work
14:05:46 <joe_k> it is computing and printing to stdout
14:05:54 <bringert> shapr: so when to try to add an entry, you get read failed?
14:06:08 <shapr> bringert: 500 Internal Server Error \n Prelude.read: no parse \n Network.NewCGI/X.X
14:07:18 <bringert> shapr: strange. even if the entry is empty?
14:07:19 <int-e> joe_k: that probably depends on the OS. I'd expect ctrl-c to work though.
14:07:26 <joe_k> nice, I killed GHCI but the program is still running in a thread or something, and is now printing output over the win32 command line
14:07:41 <shapr> bringert: Yup, empty except for a date
14:08:15 <shapr> wilx: also see http://c2.com/cgi-bin/wiki?YagNi
14:08:54 <wilx> Heh.
14:08:55 <wilx> Nice.
14:09:04 <wilx> I do the oposite.
14:09:09 <bringert> shape: hmm, parsedate uses read, and read is used to interpret URLs like entry/3
14:09:21 <wilx> s/p/pp/
14:09:28 <bringert> but the read in parsedate should only be called if the string is well formed
14:09:36 * apfelmus # sleep { deep = True }
14:09:41 <wilx> I mean, I implement stuff that I think I will need before I need it :)
14:10:46 <bringert> shapr: can you see if the entry got added?
14:11:00 <shapr> Yeah, lemme check
14:11:27 <shapr> nope
14:11:40 <joe_k> this is awesome
14:12:05 <joe_k> i rewrote the python wrapper that drives my haskell PK model with different parameters from stdin
14:12:08 <joe_k> in haskell
14:12:17 <joe_k> so there is no reading/writing/parsing
14:12:22 <joe_k> and its lots faster
14:12:24 <joe_k> yum
14:13:17 <shapr> Is there some way to paste into vim that doesn't do autoindent?
14:14:32 <bringert> shapr: can you load Hawl.Util.Time into ghci, and run parseISO8601DateTime "whatever time string is show when adding the entry"
14:16:26 <shapr> "2006-06-07 23:04:39" ?
14:16:34 <bringert> yeah
14:16:45 <bringert> just checking that your parsedate is whacked somehow
14:17:15 <shapr> Doesn't return error or anything.
14:17:23 <bringert> crazy
14:17:33 <bringert> maybe HDBC is doing a read somewhere
14:17:40 <shapr> I'm not using HDBC anymore.
14:17:45 <bringert> HSQL then
14:17:48 <bringert> or HaskellDB
14:17:49 <shapr> haskelldb-hsql-pgsql
14:18:20 <bringert> all other pages work, right?
14:18:33 <shapr> Haven't tried adding a photo..
14:18:38 <shapr> Adding a user works.
14:19:45 <bringert> HSQL/PostgreSQL/Database/HSQL/PostgreSQL.hsc uses read in a rew places
14:19:47 <bringert> few
14:20:21 <bringert> one actually
14:20:23 <shapr> bringert: images: createDirectory: permission denied (Permission denied)
14:20:34 <shapr> Where is it trying to create an images dir?
14:20:39 <bringert> ah, yes, you need to create the image storage directory
14:20:59 <bringert> hmm, I thought that was in INSTALL
14:21:08 <shapr> I've been doing tar xzf hope-installball.tar.gz and renaming that dir to hope
14:21:15 <shapr> Oh, I didn't read enough of INSTALL yet :-)
14:21:31 <SamB> well, I can definately see why they did not include implicit open/close tags in XML
14:21:40 <bringert> shapr: it doesn't seem to be there
14:21:54 <shapr> It is there.
14:22:01 <SamB> not only are they unnecessarily complicated, if something goes wrong it can be very perplexing
14:22:10 <bringert> shapr: oh, yes
14:22:17 <bringert> I couldn't find it myself
14:22:19 * SamB wonders if there are SGML specs available for free or not
14:22:25 <shapr> Yeah, I have trouble reading stuff I wrote.
14:22:58 <bringert> shapr: HSQL.PostgreSQL seems to use read in one place without checking it
14:23:07 <SamB> INSTALL files often need work
14:23:15 <bringert> HSQL/PostgreSQL/Database/HSQL/PostgreSQL.hsc lines 115
14:23:18 <bringert> line
14:23:18 <SamB> the ones from autoconf just need ignoring
14:24:00 <shapr> bringert: when uploading an image: user error (ERROR: for SELECT DISTINCT, ORDER BY expressions must appear in select list )
14:24:17 <bringert> you got taht when trying to view images too, right?
14:24:24 <shapr> Yup
14:24:54 <shapr> There's an entry in the images table at least.
14:25:12 <bringert> does that mean that PostgreSQL wants ORDER BY any time you have a SELECT DISTINCT?
14:26:07 * shapr dunno
14:26:30 <shapr> CosmicRay: Do you know if PostgreSQL wants ORDER BY any time you have a SELECT DISTINCT?
14:26:39 <shapr> I could ask on #postgresql
14:27:13 * shapr does so
14:28:59 * bringert tries to get postgresql running on his laptop
14:29:04 <bringert> shapr: which version do you have?
14:29:15 <shapr> pgsql 8.1
14:30:17 <shapr> bringert: How do I turn on tracing again?
14:30:36 <bringert> it's fairly nasty iirc
14:31:01 <shapr> Yeah, I have to edit something somewhere...
14:31:03 * shapr greps
14:32:08 <shapr> What's the keyword?
14:32:13 <bringert> mmaybe you can do it in postgres directly, otherwise you can edit haskelldb/src/Database/HaskellDB/HSQL/Common.hs
14:32:27 <bringert> shapr: it looks like the stubs for it aren't there anymore
14:32:34 <shapr> Oh, tracing is gone?
14:32:45 <bringert> dunno why
14:32:55 <bringert> I probably did it though
14:33:16 <shapr> Tracing can be useful. It'll be even more useful when backend specific generation happens.
14:33:55 <bringert> yeah
14:35:43 <bringert> shapr: I'll add some tracing to HaskellDB.HSQL, just gimme a few minutes
14:35:51 <shapr> ok
14:36:10 <shapr> I haven't found a way to do SQL tracing in pgsql 8.1 in my short trek through the config files.
14:36:19 * shapr folds out the futon for his gf
14:40:32 <SyntaxNinja> shapr: is that an unfold?
14:41:19 <shapr> heh, yes
14:41:40 <vincenz> shapr: so isorecursive and not equirecursive couch
14:41:50 <vincenz> damn ikea!
14:42:06 <shapr> The problem with recursive couches is that you can never find your pocket change.
14:42:31 <vincenz> shapr: well if  you look infinitely long
14:42:38 <shapr> I'd get hungry.
14:42:42 <vincenz> but then again
14:42:44 <vincenz> it's a list
14:42:49 <vincenz> which means it's nondeterministic
14:42:54 <vincenz> which explains why you sometimes find change for no reason
14:43:49 <beelsebob_> does anyone know if anyone is working on porting libffi to X86 Mac?
14:44:45 <vincenz> vincenz@abstractlappy:~/work/private/simulator$ darcs whatsnew | wc 570    4869   31393
14:45:42 <shapr> vincenz: You need to record more often.
14:45:48 <vincenz> it was one global change
14:45:50 <shapr> I like darcsum.el
14:46:03 <vincenz> and I just realized it might break some things :(
14:46:31 <shapr> You can always dump the patch.
14:46:56 <vincenz> basically my typechecker clears my annotations
14:47:14 <vincenz> time to refactor some and fix that
14:50:46 <vincenz> and factor out a cleaner monad
14:51:08 <vincenz> which I can reuse :)
14:51:37 <shapr> bringert: Now createdb on ScannedInAvian.com gives # ./createdb \n createdb: Prelude.read: no parse
14:51:48 <shapr> I just created the hope user, hope database, and ran createdb.
14:52:49 <bringert> ok, it must be HSQL
14:53:15 <shapr> Yeah, it worked with HDBC.
14:53:48 <shapr> Maybe I should switch back to HDBC and hack some ParseDate code to create CalTime from dates.
14:54:56 <Spark> shapr: i learnt some haskell last night
14:55:08 <shapr> Cool, what do you think?
14:55:10 <Spark> i said i'd do it 2.5 years ago
14:55:16 <Spark> indifferent really
14:55:20 <Spark> theres one thing that bugs me
14:55:30 <jer> whitespace! =D
14:55:39 <Spark> i did a little stack machine that had integers and operations on integers
14:55:40 <shapr> What bugs you?
14:56:06 <Spark> and then i extended it to have a "goto" by using an array to store the "program"
14:56:13 <Spark> so you could goto a specific index of the program
14:56:22 <Spark> ok?
14:56:28 <shapr> yeah?
14:56:49 <shapr> Why an array?
14:57:00 <monochrom> why not an array :)
14:57:11 <Spark> so i could look it up using the pc as an index
14:57:16 <shapr> Lists are easy and one dimensional.
14:57:32 <Spark> the thing is the type of the array elements
14:57:34 <Spark> i have:
14:57:44 <Spark> data ArithmeticInstruction = Push Int | Op2 (Int->Int->Int) | Op1 (Int -> Int)
14:57:44 <Spark> data Instruction = Arith ArithmeticInstruction | Goto Int
14:57:50 <Spark> but that leads to uglyness
14:57:58 <Spark> when stating the content of the array
14:58:18 <Spark> [Arith (Push 3), Arith (Push 4), Arith (Op2 (+)), Arith (Push 9), Goto 5, Arith (Op2 (*)), Goto 2]
14:58:26 <Spark> the wrappers arent very nice
14:58:29 <monochrom> That's nice.  That is not ugly.
14:58:30 <Spark> s/wrappers/type constructors/
14:58:50 <Spark> i would much prefer to write [3,4,(+),9,Goto 5,*,Goto 2]
14:58:55 <shapr> I think you can...
14:58:57 * shapr thinks
14:59:00 <Spark> is there no way of using haskell data types to achieve that
14:59:02 <monochrom> Plus, you won't enter a program by hand.  You write a program in some other notation.  This array is generated.
14:59:51 <shapr> There's some way of getting around the wrappers..
14:59:56 <monochrom> No matter what you do, the execution engine still has to dispatch by cases.  So why not make that pattern matching?
15:00:09 <Spark> someone did it last night by making a special list
15:00:30 <Spark> and defining an operator $: that was overloaded for the different types
15:00:41 <shapr> Yeah, that's one approach.
15:00:47 <shapr> Typeclasses are powerful.
15:00:48 <Spark> is there no way of just saying data Animal = Cat | Dog
15:01:02 <shapr> You can do that, sure.
15:01:27 <shapr> Or do you mean data Cat = BigCat | SmallCat and then data Animal = Cat | ... ?
15:01:42 <Spark> yeah
15:01:44 <Spark> Cat and Dog being types
15:01:46 <Spark> not constructors
15:01:56 <Spark> because if Cat and Dog are syntactically independent
15:02:11 <Spark> there is no ambiguity, and no need for the prefix
15:02:42 <shapr> You can parameterize datatypes.
15:03:00 <Spark> does that help?
15:03:05 <shapr> Not that I can see :-)
15:03:07 <Spark> :)
15:03:10 * shapr is thinking
15:03:18 <Spark> what about other languages
15:03:19 <Spark> like SML
15:03:27 <Spark> (SML is what i did on my undergrad cs course)
15:03:53 <shapr> I recently hacked on a Joy interpreter and I didn't run into that sort of problem.
15:03:58 <shapr> Of course, I don't have a goto instruction.
15:04:24 <Spark> I could merge the two instruction types
15:04:36 <Spark> but I wanted to seperate the "ALU" logic from the branching logic
15:04:37 <shapr> data ArithmeticInstruction = Push Int | Op2 (Int->Int->Int) | Op1 (Int -> Int) | Goto Int
15:04:54 <shapr> Ah, in that case have you read the modular monadic interpreters paper(s)?
15:06:03 <shapr> Spark: Stacked monads do modular interpreters elegantly.
15:06:28 <Spark> havent touched monads yet
15:06:35 <Spark> i wanted to full understand unions and type classes first
15:06:38 <Spark> fully
15:06:53 <Spark> i figure lazy evaluation and infinite lists would be easier than monads too
15:07:02 <bringert> shapr: try updating HSQL from CVS now, hopefull that gets rid of the read error
15:07:05 <shapr> Monads are pretty simple.
15:07:13 <shapr> Like... um, three pieces?
15:07:21 <shapr> I betcha I can explain monads to you in five minutes.
15:07:40 <Spark> first write me an imperative program in haskell
15:07:57 <Spark> something that calculates fibonacci numbers in the iterative way :)
15:08:02 <shapr> Monadic programs with IO are both imperative and purely functional.
15:08:12 <shapr> What's the iterative way?
15:08:22 <shapr> bringert: Ok, updating now
15:08:31 <Spark> you dont recurse for both n-1 and n-2
15:08:36 <Spark> you accumulate the number you want
15:08:56 <shapr> bringert: anon cvs is some amount of time after dev cvs. No updates yet.
15:09:02 <bringert> hmm
15:09:12 <bringert> should I e-mail you the new file?
15:09:14 <shapr> I love darcs. I do not love cvs.
15:09:17 <shapr> Sure, yeah
15:10:06 <Spark> for (int i=1 ; i<50 ; i++) { (old_n, n) := n, (n + old_n) }
15:10:17 <Spark> something like that anyway
15:10:27 <Spark> written wrong, in a made-up language
15:10:28 <bringert> shapr: you've got mail!
15:10:30 <Spark> (good effor)
15:10:30 <shapr> yay
15:11:05 <bringert> shapr: HSQL tracing is in HaskellDB darcs
15:11:08 <bringert> soon
15:11:20 <Spark> shapr: or you do popualate an array with the first 50 fib numbers
15:11:21 <shapr> spiffy
15:11:31 <shapr> Spark: huh?
15:11:52 <shapr> I guess this is right out? fib = 0 : 1 : zipWith (+) fib (tail fib)
15:12:00 <Spark> a[0] = 1 ; a[1] = 1 ; for (int i=2 ; i<50 ; i++) { a[i] = a[i-1] + a[i-2] }
15:12:06 <bringert> shapr: in darcs now. you need to edit src/Database/HaskellDB/HSQL/Common.hs and set tracingEnabled (at the bottom)
15:12:08 <Spark> yeah thats cheating
15:12:30 <monochrom> fib n = f 0 0 1 where f i x y = if i==n then x else f (i+1) y (x+y)
15:12:35 <Spark> you can do lots with a decent set of library functions :)
15:12:48 <bringert> shapr: I'm off for lunch now
15:12:49 <shapr> I still don't see much FP Java.
15:12:54 <shapr> bringert: Thanks for all your work!
15:13:09 <bringert> I hope you can get some of it sorted out
15:13:44 <shapr> With the cvs fix, I just rebuild hawl and hope, yeah?
15:13:59 <shapr> oh wait, haskelldb-hsql-pgsql as well
15:14:04 <monochrom> > let {fib n = f 0 0 1 where f i x y = if i==n then x else f (i+1) y (x+y)} in fib 50
15:14:04 <lambdabot>  12586269025
15:14:07 <shapr> And of course, HSQL-pgsql
15:14:16 * shapr builds
15:14:44 <Spark> monochrom: does that demonstrate monads? :)
15:14:53 <shapr> Wait, you want a monad demo?
15:14:58 <Spark> yeah
15:15:00 <shapr> Dude, imperative features don't help there.
15:15:07 <monochrom> I'm a minimalist.
15:15:23 <Spark> i thought that was the underlying implementation of while, for, mutable variables, etc
15:15:28 <Spark> monads
15:15:37 <shapr> Monads are just an abstraction. OOP is also an abstraction.
15:16:24 <shapr> They both do some amount of separating concerns.
15:16:46 <shapr> Spark: Have you ever written a bunch of nested if-then-else statements and wished you could abstract them out?
15:17:02 <CosmicRay> shapr: have you switched frmo hdbc to hsql?
15:17:11 <shapr> CosmicRay: For the moment, yeah
15:17:17 <shapr> Trying to get hope working.
15:17:23 <CosmicRay> shapr: is there a problem with hdbc?
15:17:32 <shapr> Just the date stuff. Other than that it's better than HSQL.
15:17:38 <monochrom> > let {r :: Control.Monad.State Int (); r = return ()} in True
15:17:39 <lambdabot>  Not in scope: type constructor or class `Control.Monad.State'
15:18:03 <CosmicRay> shapr: ok.  please do keep sending me feedback.
15:18:24 <shapr> I may end up switching back to HDBC and adding date code.
15:18:32 <shapr> HSQL is being difficult in other ways.
15:18:39 <CosmicRay> shapr: that is its way.
15:18:41 <shapr> heh
15:19:22 <Spark> shapr: not sure
15:19:38 <Spark> shapr: i've often wished for a more general case statement
15:19:48 <Spark> but thats not real nesting
15:20:04 <shapr> Spark: Assume a webshop. Orders need to be checked for, client exist, item exist, client has cash, item in stock, etc
15:20:18 <Spark> if (string.equals("pain")) { ... } else if (string.equals("suffering")) { ... } else { error }
15:20:25 <shapr> Usually you'd (well, I would) build a big rats nest of if-then-else statements
15:20:46 <shapr> You can abstract that out with a monad.
15:21:05 <shapr> My take on monads is that they turn a type with a certain significance into a pipeline with that same significance.
15:21:14 <shapr> For example, the Maybe type represents failure.
15:21:19 <shapr> data Maybe a = Just a | Nothing
15:21:36 <shapr> Nothing means it died, Just a is a result.
15:21:44 <shapr> Spark: You understand the Maybe type?
15:21:47 <Spark> yeah
15:21:57 <Spark> thats no different from what i've already done with unions
15:22:31 <Spark> actually no it isnt
15:22:43 <shapr> So you could make all these webshop functions all have a type like OrderRecord -> Maybe OrderRecord
15:23:11 <shapr> But manually doing if-then-else is just too boring.
15:23:47 <shapr> So instead you define an instance of Monad, where the bind function (written as >>=) handles sticking together the functions.
15:24:33 <shapr> So "(Just a) >>= f = f a" and "Nothing >>= f = Nothing"
15:24:59 <shapr> Spark: Makes sense?
15:25:25 <shapr> For more text see - http://www.nomaware.com/monads/html/maybemonad.html
15:25:35 <Spark> thats just an exception
15:25:56 <shapr> Yup, at the first sign of failure everything stops.
15:26:32 <shapr> The advantage being that you can do clientExist >>= itemExist >>= clientHasCash >>= ItemInStock and it just works.
15:26:48 * vincenz wootwoots for the maybemonad
15:27:17 <shapr> The next useful type is data Either a b = Left a | Right b
15:27:19 <vincenz> I have been thinking of generalizing the either monad
15:27:22 <vincenz> shapr: it's not a monad
15:27:24 <vincenz> but
15:27:33 <Spark> what you really want is an error message saying "item isnt in stock and you cant afford it, sucker"
15:27:40 <Spark> rather than just giving the first error message
15:27:40 <vincenz> instance (Read x) => Monad (Either x) where...
15:27:43 <shapr> Spark: Right, and we can use Either for that.
15:28:06 <shapr> Instead of just bailing out with a Nothing result, Either allows you to return a message as well.
15:28:13 <shapr> By convention, Left is failure.
15:28:25 <vincenz> shapr: no it's not
15:28:28 <vincenz> shapr: Either is not a monad
15:28:40 <vincenz> shapr: that's why I propose
15:28:41 <Cale> vincenz: It's a monad constructor though :)
15:28:42 <vincenz> instance (Read x) => Monad (Either x) where...
15:28:49 <mauke> why Read x?
15:28:58 <vincenz> mauke: fail :: String -> m a
15:29:00 <Cale> (Either e) is a monad for any e
15:29:09 <vincenz> Cale: nope
15:29:10 <Cale> fail is stupid :)
15:29:12 <vincenz> only Either ErrMsg
15:29:18 <shapr> aaanyway
15:29:20 <Cale> well, it could be made one
15:29:39 <mauke> vincenz: ok, and how is fail defined?
15:29:48 <vincenz> mauke: fail = Left . read $ 
15:29:48 <shapr> Spark: Can you extend the definition of >>= for Either? (and for the moment, forget about (Read x) => )
15:29:56 <Cale> instance Monad (Either e) where return = Right; (Left e) >>= f = (Left e); (Right x) >>= f = f x
15:30:13 <shapr> Well, that was easy.
15:30:16 * shapr grins
15:30:26 <Spark> im still thinking about the best way of doing it without monads
15:30:29 <vincenz> Cale: unless you require Read, ther's no way to fail
15:30:34 <Cale> fail = undefined
15:30:37 <vincenz> heh
15:30:41 <vincenz> Cale: that's not Left
15:30:42 <mauke> failure is not an option
15:30:47 <Cale> fail is stupid anyway, and nobody should use it
15:30:59 <shapr> Spark: A monad is just a way of organizing the same old code to make it easy to find things.
15:31:06 <vincenz> maybe monads should be defined in terms of two types
15:31:09 <vincenz> failure and nonfailure
15:31:10 <Cale> (It really should not be a member of that class)
15:31:12 <vincenz> instead of assuming string
15:31:41 <Cale> There should be a class Monad m => MonadFail m where fail :: String -> m ()
15:31:42 <shapr> Spark: For example, if you wanted to write a Haskell version of one of those old weenie handheld calculators with an M+ button for a single cell of memory...
15:32:24 <shapr> The purely functional approach is to explicitly pass around that one value as a function argument.
15:32:29 <vincenz> Cale: or even
15:32:38 <vincenz> MonaFail m f where fail :: f -> m ()
15:32:56 <Cale> Yeah, and then you're heading towards MonadError
15:33:04 <shapr> The monadic approach is exactly the same, but to move the explicit passing into the definition of bind.
15:33:18 <shapr> Spark: Makes sense?
15:33:40 * shapr wonders if his five minutes is up yet.
15:33:45 <Cale> But I think I like that better than MonadError's current implementation. Add a fundep and it would be decent.
15:35:46 <Lemmih> Does anyone know musasabi IRL?
15:36:02 <shapr> Not me, though I've seen pix.
15:36:15 <shapr> And I know where he lives, sort of.
15:36:25 <shapr> Has he stopped responding to email?
15:38:01 <Spark> the maybe monad is easy to understand, but an either monad is giving me issues
15:38:17 <shapr> Did you see Cale's definition?
15:38:36 <Spark> ok first one thing
15:38:40 <Spark> http://www.nomaware.com/monads/html/maybemonad.html
15:38:41 <Spark> shit
15:38:46 <Spark> i hate being in windows
15:38:47 <Spark> instance Monad Maybe where
15:38:54 <Spark> why not instance Monad Maybe a where
15:39:11 <Spark> and later on there is just "Just" not "Just a"
15:39:32 <shapr> I also give lessons on installing Linux...
15:39:33 <Spark> it seems like theres some lifting going on there
15:39:52 <Spark> i'm in windows because of games-playing that actually ceased several days ago, but i'm too lazy to reboot
15:40:02 <shapr> I play games in Linux.
15:40:06 <shapr> Tried Tremulous?
15:40:14 <Spark> not GTA
15:40:31 <shapr> Maybe with winex?
15:40:33 <vincenz> or oblivion
15:40:36 * vincenz drools
15:40:40 <Spark> linux sucks for games, the scheduler is too broken
15:40:44 <vincenz> I can't wait until that new game comes out
15:40:46 <vincenz> that simulates life
15:40:49 <Spark> i'm not going into that though
15:41:01 <Stinger_> spore
15:41:13 <Spark> about the instance syntax
15:41:19 <Spark> why no type variables?
15:41:29 <shapr> I use the predictive scheduler with a preemptive kernel, works great. Admittedly, it works best with two or more cpus.
15:41:37 <shapr> low latency, etc etc
15:41:43 <Spark> yeah i run jack so i have all that
15:41:45 <Spark> it still doesnt work properly
15:41:53 * shapr won't go into increasing timer resolution...
15:41:56 <Spark> done that too
15:42:07 <mauke> Spark: because the class definition of Monad requires an argument of kind * -> *
15:42:24 <shapr> Strange, it works perfectly on my dual Athlon MP. Doesn't work with this single P4 though, I get stalls on a regular basis.
15:42:26 <Spark> mauke: complex
15:42:35 <Spark> shapr: the problem goes away when you have a lot of redundant cpu power
15:42:56 <mauke> well, it's class Monad m where return :: a -> m a so it knows that m takes an argument
15:43:11 <shapr> My dual Athlon MP is 6500 bogomips, and this P4 is 5000 bogomips, so I wonder if multiple slow cpus would still be better.
15:43:14 <Spark> mm
15:43:21 <mauke> (Maybe a) doesn't take an argument, it means forall a. Maybe a
15:44:06 <shapr> Or maybe the AMD MP chipset has lots more memory bandwidth?
15:44:09 <Spark> so it knows about the parameterisation of Maybe already
15:44:14 <Spark> so all it needs is the name of the type
15:44:17 <Spark> basically
15:44:27 <Spark> shapr: its an OS thing, windows behaves very differently
15:44:42 <Spark> shapr: also different schedulers make the problem differ slightly but its still there
15:45:04 <shapr> I dunno, I ran counterstrike most effectively on that dual Athlon MP with wine.
15:45:45 <Kasperle> bogomips aren't exactly a good benchmark, too ;)
15:45:46 <Spark> the problem is really that games are a soft realtime application, but none are designed with that in mind
15:45:49 <shapr> Kasperle: True that
15:46:11 <shapr> Spark: Yeah, good point.
15:46:15 <Spark> i'm quite sharp about seeing glitches in display and hearing glitches in audio too, i think
15:46:23 <Spark> especially when i'm in a "wired" mood
15:46:33 <shapr> My best recommendation is to never get a Via mobo.
15:46:39 <Spark> heh i used to have one of those
15:46:50 <shapr> and don't ever use Promise disk controllers
15:46:50 <Spark> one of the awful ones too
15:46:53 <Spark> a kt266 or something
15:47:09 <shapr> Oh, and always buy Kingston or Corsair memory.
15:47:53 <shapr> Anyway, a monad is a type constructor, not a type (iirc)
15:48:20 <Kasperle> hmmm, where did i put those lecture notes again ... ;)
15:48:35 <Spark> i thought it was a type class
15:48:43 * vincenz high5s Cale 
15:48:50 <Spark> anyway
15:48:54 <Spark> so the Either monad
15:48:59 <vincenz> Cale: how do you stack custom monads?
15:49:00 <Spark> instance Monad Either where ...
15:49:10 <shapr> nah, instance monad (Either e) where
15:49:13 <vincenz> Cale: mind discussing in #oasis?
15:49:23 <bringert> shapr: I'm back!
15:49:33 <bringert> shapr: how did it go?
15:49:35 <Kasperle> hmmm, i see the term constructor class
15:49:36 <vincenz> shapr: that's not feasible without Read e
15:49:38 <Spark> Left a >>= f = Left f(a)     -- something like that?
15:49:51 <vincenz> Cale: ping
15:50:03 <Spark> ah no, left is the error
15:50:11 <Spark> Left a >>= f = Left a
15:50:14 <shapr> vincenz: picky picky
15:50:19 <vincenz> shapr: otherwise it won't work
15:50:24 <vincenz> shapr: fail takes a string
15:50:29 <Spark> and then Right is the same as Just
15:50:32 <shapr> vincenz: you're just being picky... 
15:50:32 <shapr> :-P
15:50:43 <vincenz> shapr: all you have to do is add (Read e)
15:50:44 <shapr> Spark: You got it.
15:50:45 <vincenz> hardly picky
15:50:45 <Spark> so its the same as Maybe, only "Nothing" has cargo
15:50:53 <shapr> Spark: exactly!
15:50:57 <Spark> and return is Right
15:51:01 <vincenz> Anyone a monadic expert?
15:51:10 <shapr> That wadler guy is good with monads.
15:51:15 <vincenz> I mean in this chan
15:51:30 <Spark> so, can you accumulate the error messages?
15:51:34 <Spark> thats the real difficulty
15:51:36 <vincenz> I know how to stack transformers, now I want to stack a transformer on top of a monad that's in a typeclass, not a specific one
15:51:45 <Spark> at the moment the first error message passes through the whole thing
15:51:54 <Spark> we need to involve f in the Left a reduction
15:52:31 <Spark> at the moment we just have basic exception propogation
15:52:35 <shapr> yup
15:53:41 <shapr> You could use mapM to produce a list of result or error.
15:54:25 <shapr> In any case, want to see the State monad?
15:55:00 <Spark> first, i'd like to see something like client = ... ; item = ... ; if (item.value > client.balance) { ... } ; return information relating to success / failure
15:55:18 <Spark> with the error handling, and error messages implicit
15:56:52 <Spark> so for instance, item.value return some kind of "no item exception" plus an error message, and likewise for the client.balance, and > fails silently when either of its operands return an exception
15:57:38 <shapr> Well, write it up :-)
15:58:17 <shapr> How would you approach it?
16:05:54 <scodil> how might one go about defining a function which returns a pair of random numbers? (doubles, lets say).  I'm having trouble getting it to fit into IO
16:06:20 <shapr> You can start without IO by explicitly using mkStdGen
16:06:21 <vincenz> @hoogle random
16:06:22 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
16:06:22 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
16:06:22 <lambdabot> Random :: module
16:06:36 <vincenz> @hoogle randomgen
16:06:37 <lambdabot> System.Random.RandomGen :: class RandomGen g
16:06:44 <vincenz> @instances randomgen
16:06:44 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
16:06:53 <vincenz> @instances RandomGen
16:06:54 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
16:06:56 <shapr> bringert: Still fighting random problems, at this point I'm having max redirects probs on ScannedInAvian.com
16:07:05 <Spark> shapr: http://rafb.net/paste/results/5UzBQm80.html
16:07:06 <vincenz> @instances-importing System.Random RandomGen
16:07:06 <lambdabot> StdGen
16:07:13 <Spark> shapr: probably doesnt compile
16:07:14 <vincenz> @hoogle stdgen
16:07:15 <lambdabot> System.Random.StdGen :: data StdGen
16:07:15 <lambdabot> Random.getStdGen :: IO StdGen
16:07:15 <lambdabot> Random.mkStdGen :: Int -> StdGen
16:07:37 <bringert> shapr: do you have url I can look at?
16:07:58 <Spark> shapr: i forgot type constructors in the body of the lt function
16:08:06 <shapr> Spark: Here's what I wrote before I got distracted, what would you do next? http://rafb.net/paste/results/cxP6x389.html
16:08:15 <vincenz> > let gen = Random.mkStdGen 1 in let (a,gen') = System.Random.random gen in let (b,_) = System.Random.gen' in (a,b')
16:08:16 <lambdabot>  Not in scope: `b''
16:08:18 <vincenz> > let gen = Random.mkStdGen 1 in let (a,gen') = System.Random.random gen in let (b,_) = System.Random.gen' in (a,b)
16:08:19 <lambdabot>  Not in scope: `System.Random.gen''
16:08:31 <vincenz> > let gen = Random.mkStdGen 1 in let (a,gen') = System.Random.random gen in let (b,_) = System.Random.random gen' in (a,b)
16:08:32 <lambdabot>  Not in scope: `System.Random.random'
16:08:37 <vincenz> meh
16:09:11 <scodil> vincenz: but then I'd need to seed the random generator myself, right? presumably from something coming from IO
16:09:23 <scodil> ie, time, user input
16:09:32 <vincenz> scodil: notice Random.getStdGen :: IO StdGen
16:09:43 <Spark> shapr: i also forgot to define balance
16:09:48 <Spark> but it's similar to value
16:10:01 <vincenz> scodil: and yes, it goes without saying that if you want a random seed, you want IO
16:10:12 <shapr> bringert: http://www.scannedinavian.com/hope/ giving mod_rewrite: maximum number of internal redirects reached. Assuming configuration error. Use 'RewriteOptions MaxRedirects' to increase the limit if neccessary.
16:10:15 <vincenz> scodil: kinda logical if you think about referential transparency
16:10:15 <shapr> Probably user error though.
16:10:43 <scodil> of course
16:11:00 <bringert> shapr: what does the htaccess file look like? and what is hopeBase?
16:11:00 <vincenz> shapr: http://rafb.net/paste/results/NBglbZ74.html
16:11:15 <shapr> bringert: hopeBase = uri "http://www.scannedinavian.com/hope/",
16:11:51 <shapr> bringert: http://rafb.net/paste/results/0T1zT038.html
16:12:07 <shapr> oh, I think I see the rewrite problem, doh
16:12:16 <scodil> is there an abbreviation defined anywhere for "getStdRandom random" ?
16:12:20 <scodil> as in, "x <- getStdRandom random"
16:12:38 <vincenz> even better
16:12:39 <vincenz> http://rafb.net/paste/results/LwZQnw20.html
16:12:42 <bringert> shapr: duplicate last line?
16:12:52 <shapr> exactly
16:13:12 <mauke> fail = Left . read
16:13:20 <vincenz> mauke: yeah well
16:13:22 <Spark> shapr: hang on, rewriting
16:13:26 <vincenz> shapr: http://rafb.net/paste/results/LwZQnw20.html
16:14:06 <shapr> bringert: http://www.scannedinavian.com/hope/entry YAY!
16:14:15 <bringert> sweet
16:14:15 <vincenz> shapr: ooh nice :)
16:14:40 <shapr> Now to test the photo upload...
16:14:50 <bringert> shapr: so the read error is fixed anyway, but not the SELECT thing
16:14:53 <vincenz> shapr: so hope is a sort of blog engine?
16:15:03 <shapr> More than that
16:15:08 <vincenz> shapr: neat :)
16:15:10 <vincenz> that would really rock
16:15:13 <shapr> Hope is a webapp framework, blog is just one plugin.
16:15:40 <shapr> Author being the productive Mister Bringert.
16:16:20 <vincenz> !!!
16:16:22 <vincenz> Great
16:17:04 <shapr> The photo plugin is another...
16:17:08 <shapr> Now testing...
16:17:32 <shapr> gwahr
16:17:47 <shapr> jpegs only.
16:17:48 <shapr> No pngs
16:17:58 <bringert> shapr: but it's working?
16:18:00 * shapr gets explodey errors
16:18:05 <bringert> hehe
16:18:05 <shapr> Lemme try with a JPG
16:18:20 <bringert> yeah, you probably blew up GD and EXIF
16:18:34 <bringert> I should add PNG support
16:18:40 <bringert> should be easy enough
16:18:48 <shapr> Yup, apache error is gd & exif whining.
16:18:55 <shapr> doh, user error (ERROR: for SELECT DISTINCT, ORDER BY expressions must appear in select list )
16:19:04 <bringert> when inserting too?
16:19:06 <shapr> Time to turn on tracing...
16:19:43 <shapr> Data in the images table though...
16:19:45 <shapr> hmm
16:19:55 <Spark> shapr: i wrote it slightly better, using some of your types but not much to be fair  http://rafb.net/paste/results/dicIJ461.html
16:20:03 <Spark> i havent used any monads though
16:20:04 <Spark> i think
16:20:17 <Spark> using monads should take away a lot of those auxillary definitions
16:20:50 <shapr> Yup, monads just let you brush some of that boilerplate code under the rug.
16:21:15 <Spark> value, balance, and lt presumably
16:21:19 <Spark> how would you code it with monads?
16:28:11 <shapr> I'm getting too sleeping to write monads :-/
16:28:19 <shapr> sleepy* yeesh
16:29:08 <Spark> maybe something like balance = c >>= (\x => x.balance)
16:29:10 <shapr> Spark: Since my brain is offline, look at http://www.nomaware.com/monads/html/errormonad.html
16:30:02 <Spark> i can always hassle you tommorow :)
16:30:33 <shapr> yeah true
16:31:20 <Spark> i cant pay attention to documents and stuff for more than 5 lines, but if i'm talking to a person then i can for some reason
16:31:27 <shapr> Anyway, you see now that monads are pretty simple, yeah?
16:31:35 <Spark> i just get impatient too quickly i reckon
16:31:39 <shapr> I think most people work that way, I know I do.
16:31:42 <vincenz> > let (:>) a b = a in (:>) 1 2
16:31:43 <lambdabot>  Not in scope: data constructor `:>'
16:31:43 <Spark> in that recursion is pretty simple :)
16:31:46 <vincenz> > let (=:>) a b = a in (:>) 1 2
16:31:47 <lambdabot>  Not in scope: data constructor `:>'
16:31:49 <vincenz> > let (=:>) a b = a in (=:>) 1 2
16:31:50 <lambdabot>  1
16:31:54 <shapr> Well, recursion is simple, isn't it?
16:32:08 <Spark> everything is simple
16:32:13 <Spark> once you understand it
16:32:15 <shapr> Hm, not everything.
16:32:28 <Spark> there are big simple things, and small simple things
16:32:29 <shapr> Quantum mechanics is just rough.
16:32:34 <shapr> Ok, I can agree with that.
16:32:39 <Spark> and there are deep and shallow things, but theyre still both simple
16:33:23 <shapr> Somethings are highly entangled, you have to knit together a bunch of pieces to get it.
16:34:34 <bringert> shapr: what were the names of the connection parameters for HSQL PostgreSQL?
16:34:37 <Spark> yeah sometimes you get cyclic dependencies between certain aspects of things
16:34:44 <Spark> so you cant start with one aspect or the other
16:35:04 <shapr> bringert: Um, dbname user password host
16:35:25 * shapr forgot the trace filename, and is rebuilding all over again.
16:35:46 <bringert> shapr: I should make that runtime configurable
16:35:54 <bringert> that's why I put the IO in there
16:35:54 <shapr> That would be nice.
16:36:04 <shapr> But right now you have one user, so...
16:36:20 <shapr> btw, Who else actively uses HaskellDB?
16:36:39 <bringert> eh
16:36:43 <bringert> me?
16:36:52 <bringert> I'm not sure actually
16:36:58 <bringert> stepcut maybe?
16:37:05 <shapr> Probably so
16:37:08 <vincenz> WOOOOT
16:37:11 <vincenz> This -so- rocks
16:37:13 <vincenz> palomer: ping
16:37:38 * vincenz has a typechecker that based on the type of a type can pass along any sort of annotation transparently
16:38:26 <vincenz> through my typechecker
16:38:33 <vincenz> in fact my typechecker can do other things without it knowing it's doing it
16:38:36 <vincenz> like strictness analysis
16:39:31 <Spark> in haskell, is there a function [ x |-> v ] like you get in maths, so  f[x |- v] = \y => if y == x then v else (f y)
16:40:27 <Spark> it would be pretty easy to define one i reckon
16:40:39 <shapr> Guards can do that.
16:41:18 <shapr> guard x | x == 0     = 4
16:41:18 <shapr>         | (x*x) < 64 = 5
16:41:18 <shapr>         | otherwise  = 6
16:41:18 <mauke> @pl f x v y = if y == x then v else (f y)
16:41:19 <lambdabot> f = fix (flip (flip . (ap .) . flip . (if' .) . (==)))
16:42:38 <Spark> whats @pl
16:42:48 <shapr> Point-less
16:42:50 <bringert> shapr: did you have to hack Database.HaskellDB.HSQL.PostgreSQL to get it to work?
16:42:52 <Spark> heh
16:43:07 <shapr> bringert: Er, how so?
16:43:14 <bringert> ah, that was HBDC
16:43:32 <bringert> stupid inconsistent HaskellDB
16:44:21 <shapr> bringert: Oh, I answered your question incorrectly.
16:44:29 <shapr> bringert: Same connect params work for HSQL pgsql
16:44:36 <shapr> bringert: I gave you params for HDBC, oops
16:45:10 <bringert> right, for HSQL PostgreSQL I can use the same as for HSQL MySQL, but HDBC PostgreSQL needs others
16:45:24 <shapr> Yeah, those are the ones I gave you.
16:45:44 <bringert> shapr: ok I can reproduce the user error (ERROR: for SELECT DISTINCT, ORDER BY expressions must appear in select list )
16:46:08 <shapr> What's the problem?
16:46:17 <shapr> Or is that the next step?
16:46:20 <bringert> yes
16:46:23 <shapr> ok
16:46:42 <shapr> Spark: I'd love to tell you more, hit state monads and then arrows, but I'm too fried.
16:46:53 <scodil> so functions like print and putStr have type "a -> IO()"  but what if you have a function of type "f :: b -> IO a" ? how do you do "print f x" ?
16:47:46 <shapr> scodil: IO winds forward, but not backward, so you call the pure code inside the IO monad.
16:48:00 <Spark> :)
16:48:03 <Spark> shapr: no problem
16:48:51 <scodil> shapr: yeah I get that, but nothing here is pure. print takes a pure value and puts it in IO, but I want to print something thats already in IO
16:49:37 <monochrom> do { y <- f x; print y }
16:49:38 <shapr> print takes a pure input, so call print inside the IO monad.
16:49:43 <bringert> shapr: here's the offending query: http://rafb.net/paste/results/ATGmj983.html
16:50:04 <bringert> ah
16:50:15 <bringert> it's probably that value2 isn't returned
16:50:32 <bringert> so it orders by something that is not returned, and wants distinct results
16:50:56 <scodil> monochrom: thanks
16:51:01 <bringert> I can work around that in hope, but HaskelDb should take care of it
16:51:26 * shapr will use whatever fix is available first
16:51:59 <monochrom> Why are Haskell libraries so buggy?  (duck)
16:52:25 <bringert> why are database engines so inconsistent?
16:52:25 <shapr> In the case of HaskellDB, it's lack of funding.
16:52:59 <shapr> monochrom: Would you like to contribute to the "per backend SQL generation" fund for HaskellDB?
16:53:34 <bringert> shapr: ok, I tried that query manually in psql, and indeed adding value2 to the results fixes the problem
16:54:29 <bringert> one fix is to have HaskellDB not put the DISTINCT in there, but I've argued against that in the past
16:55:01 <bringert> for relational algebra purity reasons
16:55:04 <shapr> Yeah, I agree.
16:55:14 <bringert> but I'm not sure why those reasons matter
16:55:51 <shapr> Because you can predict how HaskellDB will react?
16:57:11 <shapr> Will removing DISTINCT take away the set ops behaviour?
16:57:16 <bringert> I'm not going to change that now, but I think it's worth discussing at some point
16:59:50 <mathewm> > do { x <- [1..3]; return x }
16:59:51 <lambdabot>  [1,2,3]
17:00:00 <mathewm> > do { x <- [1..3]; putStrLn x }
17:00:01 <lambdabot>  Couldn't match `[]' against `IO'
17:00:06 <mathewm> :type putStrLn
17:00:16 <mathewm> ?type putStrLn
17:00:17 <lambdabot> String -> IO ()
17:00:26 <mathewm> ??
17:00:26 <lambdabot> Maybe you meant: . v
17:01:30 <scodil> the pattern " [x:xs] " matches any non-empty list, but how do you match a list with exactly 1 element? (or a constant number of elements)
17:01:37 <mauke> no, it doesn't
17:01:44 <mauke> (x : xs) matches non-empty lists
17:01:51 <scodil> oh
17:01:53 <scodil> right ok
17:01:59 <mauke> use [x,y] for known number of elements
17:02:12 <scodil> cool. thank you
17:02:30 <mauke> or (x : y : []) if you're weird
17:02:36 <shapr> like me!
17:02:49 <jer> heh
17:02:56 <mauke> ((:) x ((:) y []))
17:04:13 <bringert> hmm, it wasn't so easy to fix in Hope, the queries are way too high-order
17:04:31 <bringert> hard to get it to return something that I don't really want
17:05:07 <shapr> haha
17:05:18 <monochrom> removing "distinct" will turn set behaviour into bag behaviour.  but I feel that we don't always want set behaviour (of union and intersect even) in the first place.
17:05:34 * shapr looks at Module_front.hs in hopes of making a frontpage that shows last N entries and last N photos too
17:05:50 <shapr> monochrom: Why so?
17:06:58 <bringert> shapr: module/front just redirects
17:07:00 <mathewm> I really don't get this looping behavior of 'do': do { x <- [1..4]; return 1; }
17:07:17 <monochrom> I don't know.
17:07:18 <shapr> bringert: Yeah, is there support for including outputs?
17:07:32 <bringert> shapr: look at modules/blob2/Blob.hs and modules/halbum2/Halbum.hs
17:07:50 <shapr> monochrom: Can you give some examples where bag behaviour is more useful than set behaviour?
17:08:01 <monochrom> I can't.
17:08:14 <Cale> mathewm: You can read x <- [1..4] as "x is chosen from [1..4]"
17:08:30 <Cale> mathewm: the monad will try all possible choices in order
17:09:05 <mathewm> so does that work for any lazy structure?
17:09:14 <Cale> > do { x <- [1,2,3]; y <- [10,20,30]; return (x + y) }
17:09:15 <lambdabot>  [11,21,31,12,22,32,13,23,33]
17:09:18 <monochrom> [ 1 | x<-[1..4] ]   do you know what this will do?
17:09:39 <shapr> monochrom: In a pure fp language, value is the same as identity. Thus, I can't see a case where bag is more useful than set in pure fp.
17:09:49 <mathewm> yeah, that is list comprehension stuff, 1:1:1:1:[]
17:10:08 <monochrom> do { x <- [1..4]; return 1; } equivales [ 1 | x<-[1..4] ]
17:10:09 <mathewm> > [1|x<-[1..4]]
17:10:10 <lambdabot>  [1,1,1,1]
17:10:22 <Cale> shapr: well, the number of elements of a particular value occurring in a bag can be important
17:10:42 <Cale> shapr: Basically (Bag t) is the same as (Map t Nat)
17:11:10 <scodil> is there any difference between defining a function multiple times and defining it once with a case statement?
17:11:16 <mathewm> > do { x <- [1..4]; putStrLn $ show x; }
17:11:17 <lambdabot>  Couldn't match `[]' against `IO'
17:11:33 <shapr> scodil: Yeah, the 'multiple definition' is easier to edit in my experienc.
17:11:35 <Cale> mathewm: two different monads there
17:11:36 <mathewm> lambdabot: which [] ??
17:11:41 <mathewm> ah!
17:11:50 <Cale> [] is the type constructor for lists
17:11:51 <mathewm> is one the '[] monad' ?
17:11:53 <monochrom> I don't think pure functionality is relevant in deciding whether a database table is a set or a bag.
17:11:55 <Cale> yeah
17:11:57 <scodil> shapr: but they compile to the same thing?
17:12:21 <shapr> scodil: I'm pretty sure they do.
17:12:31 <shapr> As much as I can be sure when I'm this sleepy.
17:12:48 <mathewm> So how does code get "in" one monad vs. another?
17:13:11 <shapr> return/lift
17:13:21 <mauke> it looks at the RHS of <-
17:13:22 <Cale> mathewm: by using values in that monad as computations in your do-block, or giving explicit type signatures
17:13:55 <Cale> [1..4] is a list, so it's in the list monad
17:13:56 <mathewm> > do { x <- [1..4]; return ( putStrLn $ show x ); }
17:13:57 <lambdabot>  No IO allowed
17:14:05 <Cale> @type putStrLn 
17:14:06 <lambdabot> String -> IO ()
17:14:16 <Cale> putStrLn produces things in the IO monad
17:14:28 <monochrom> > putStrLn "hey"
17:14:28 <lambdabot>  No IO allowed
17:14:44 <monochrom> > [putStrLn "hey" , putStrLn "hey"]
17:14:45 <lambdabot>  No IO allowed
17:15:03 <mathewm> and 'x <- [1..4]' implies the [] monad?
17:15:08 <monochrom> Yes.
17:15:14 <mathewm> @type x <- [1..4]
17:15:15 <Cale> It should show IO actions as <IO action> 
17:15:15 <lambdabot> not an expression: `x <- [1..4]'
17:15:29 <monochrom> > do { x <- [1..4]; return 1 }
17:15:30 <lambdabot>  [1,1,1,1]
17:15:39 <monochrom> > do { x <- [1..4]; return (x+1) }
17:15:40 <lambdabot>  [2,3,4,5]
17:15:40 <Cale> @type do x <- [1..4]; return x
17:15:41 <lambdabot> forall a. (Num a, Enum a) => [a]
17:15:45 <monochrom> see?
17:16:02 <Cale> @type do x <- getLine; return (reverse x)
17:16:03 <lambdabot> IO [Char]
17:16:23 <monochrom> If you understand list comprehension, you understand the list monad, and therefore you understand a great deal about monads.
17:16:49 <Cale> The list monad is one of the best examples of monads
17:17:36 <scodil> whats a function to interweave two lists? like zip but without the tuples?
17:18:19 <mauke> @type concat. transpose
17:18:20 <lambdabot> forall a. [[a]] -> [a]
17:18:41 <Cale> > let interleave xs ys = do (x,y) <- zip xs ys; return [x,y] in interleave [1,2,3,4,5] [6,7,8,9,10]
17:18:42 <lambdabot>  [[1,6],[2,7],[3,8],[4,9],[5,10]]
17:18:54 <Cale> or yeah, concat . transpose :)
17:19:07 <shapr> I've never had a wget process running for fifteen hours before.
17:19:13 <Cale> (I just thought the list monad approach would be decent given the discussion :)
17:19:26 <scodil> thanks
17:19:36 <mathewm> why would one want to use the [] monad when we already have list comprehension?  list comprehension was in the language long before monads, right?
17:20:06 <Cale> well, sure, but there used to be monad comprehension too
17:20:10 <shapr> Actually, list comps were at the start of the whole monad thing long ago.
17:20:18 <Cale> that was removed for fear of confusing newbies
17:20:39 <palomer> it should have become a ghc extension
17:20:42 * mathewm <-- confused newbie anyway...
17:20:48 <Cale> (seems like a bad reason to remove a useful feature, but anyway...)
17:21:15 <shapr> bringert: btw, Hope fix in darcs for the DISTINCT problem in the next ten mins, or should I give up for today and sleep?
17:21:17 <monochrom> http://www.cs.utoronto.ca/~trebla/ForwardSearch.lhs  is why I want to use lists as monads.
17:21:30 <Cale> I think they'd actually have helped with the whole "learning monads" thing, even if they made earlier going a slight it harder
17:21:45 <bringert> shapr: possibly, it will be a fix in HaskellDB though
17:21:55 <shapr> Sounds like the best solution.
17:22:03 * shapr decides to stay awake ten more mins
17:22:04 <Cale> Basically, the list monad gives you something like Prolog.
17:22:21 <Cale> (not quite, but something like it)
17:23:11 <Cale> also, you get all sorts of monad functions on lists for free
17:23:22 <Cale> > sequence [[1,2,3],[4,5],[6]]
17:23:23 <lambdabot>  [[1,4,6],[1,5,6],[2,4,6],[2,5,6],[3,4,6],[3,5,6]]
17:23:47 <Cale> > liftM2 (,) [1,2,3] [4,5,6]
17:23:48 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
17:24:11 <Cale> [1,2,3] >>= replicate 2
17:24:13 <Cale> > [1,2,3] >>= replicate 2
17:24:14 <lambdabot>  [1,1,2,2,3,3]
17:24:23 <Cale> > [1,2,3] >>= join replicate
17:24:24 <lambdabot>  [1,2,2,3,3,3]
17:24:35 <monochrom> I don't resent having two notations for certain list operations.  Afterall, I know a language that offers ten ways for writing an if.
17:24:47 <Cale> (okay, that one is especially subtle, using join from another monad entirely :)
17:24:50 <mauke> > (sequence . (const >>= map)) "abc"
17:24:51 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bba...
17:25:13 <Cale> > [replicate k ['a'..'z'] | k <- [1..]] >>= sequence
17:25:14 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s",...
17:25:17 <Cale> ugh
17:25:26 <Cale> why does it give so little output now?
17:25:33 <Cale> > [replicate k ['a'..'e'] | k <- [1..]] >>= sequence
17:25:34 <lambdabot>  ["a","b","c","d","e","aa","ab","ac","ad","ae","ba","bb","bc","bd","be","ca","...
17:25:46 <Cale> > [replicate k ['a'..'b'] | k <- [1..]] >>= sequence
17:25:47 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb",...
17:26:03 <mathewm> can you "cut" in the [] monad?
17:26:29 <Cale> not so easily. There's takeWhile though.
17:28:13 <Cale> you can do funny things with the lists of solutions before passing them on
17:33:28 <Spark> exec (mkArray [Arith (Push 10), Store 0, Arith (Push 1), Store 1, Arith (Push 1), Store 2, Load 1, Load 2, Arith (Op2 (*)), Store 1, Load 2, Arith (Push 1), Arith (Op2 (+)), Store 2, Load 2, Load 0, Arith (Push 1), Arith (Op2 (+)), Arith (Op2 (-)), IfZero 21, Goto 6, Load 1])
17:33:37 <Spark> that calculates a factorial
17:33:38 <Spark> \o/
17:36:07 <Spark> now it need to implement a compiler
17:37:18 <dcoutts> xerox__, when we eventaully get round to doing the pure cairo api we'll want to read this for some inspiration:
17:37:18 <mathewm> ?hoogle []
17:37:19 <dcoutts> http://research.microsoft.com/copyright/accept.asp?path=/users/simonpj/papers/picture.ps.gz&pub=Springer
17:37:19 <lambdabot> No matches, try a more general search
17:37:42 <shapr> Oboy, licensing agreements
17:38:01 <dcoutts> http://research.microsoft.com/users/simonpj/papers/picture.ps.gz
17:38:11 <dcoutts> heh, bypassed
17:38:31 <Cale> I wonder if there's a repository for dc code somewhere
17:39:06 <dcoutts> dc?
17:39:20 <Cale> "desk calculator"
17:39:28 <bringert> shapr: fix in haskellDB darcs
17:39:36 <Cale> It's an RPN calculator that's been in unix for years.
17:39:56 <Cale> It's older than C
17:39:56 <mathewm> last question, then.  Are list comprehensions just syntactic sugar for the [] monad?
17:40:06 <Cale> mathewm: you can think of them that way
17:40:21 * shapr pulls, builds, whee!
17:40:21 <Cale> mathewm: It's up to the implementation to decide how it wants to implement them.
17:40:33 <mathewm> Cale: OK, thanks
17:40:43 <Cale> but the guard function goes well with that idea
17:40:46 <Cale> @type guard
17:40:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:41:10 <Pseudonym> Woo!  Licensing agreements!
17:41:16 <Pseudonym> Gimme five of 'em!
17:41:26 <Cale> > do { x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z) }
17:41:27 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
17:41:59 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
17:41:59 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
17:42:48 <Pseudonym> > do { x <- [1..]; y <- [1..], z <- [1..]; n <- [3..], guard (x^n + y^n == z^n); return (x,y,z,n) }
17:42:48 <lambdabot>  Parse error
17:43:04 <Pseudonym> > do { x <- [1..]; y <- [1..]; z <- [1..]; n <- [3..]; guard (x^n + y^n == z^n); return (x,y,z,n) }
17:43:07 <lambdabot> Terminated
17:43:11 <Pseudonym> Now why can't it optimise that to []?
17:43:57 * Pseudonym asks SPJ to build the Tanyiama-Shimura theorem into the GHC optimiser
17:44:12 <bringert> shapr: sorry, you need to repull
17:44:21 <bringert> shapr: there was a bug in that patch
17:44:42 <bringert> or two rather
17:45:19 <Pseudonym> You know, there are volumes and volumes of testing/debugging theory based on the assumption, "assume a single bug".
17:45:54 <vincenz> Pseudonym: this rocks, my typechecker is type independent which means it'll pass annotations along transparently \o/
17:46:11 <Pseudonym> Cool.
17:46:41 <vincenz> let's see if the darned thing does what I want it to :D
17:46:42 <vincenz> btw
17:46:47 * Pseudonym learned everything he knows about testing theory from T.Y. Chen, who was the one researcher who DIDN'T make that assumption and was very annoyed with everyone who did
17:46:57 <vincenz> anyone have any idea on hwo to pretty print stuff with proper fixity?
17:47:16 <vincenz> I want to print types
17:47:17 <vincenz> but I'd rather have
17:47:19 <vincenz> a -> b
17:47:20 <vincenz> instead of
17:47:22 <vincenz> -> a b
17:47:29 <monochrom> There is a "testing theory"?
17:47:33 <vincenz> and only have () when necessary
17:47:34 <Pseudonym> vincenz, yes.  See the documentation of showsPrec
17:47:38 <Pseudonym> monochrom: You bet there is.
17:48:07 <monochrom> I thought the testing people hated the word "theory" with disgust.  And the debugging people even more so.
17:48:23 <Pseudonym> That's because both testing and debugging are somewhere int he stone age.
17:48:36 <vincenz> the problem is that it's not inside my type constructor
17:48:38 <vincenz> but it's a string
17:48:43 <Pseudonym> Our compiler technology has progressed amazingly, but we're still using 1970-era debugging technology.
17:48:55 <vincenz> TyConst "->:
17:48:58 <Pseudonym> As for testing, it's properly understood as a statistical process.
17:48:58 <vincenz> TyConst "->" [a,b]
17:49:26 <Pseudonym> There's a space of inputs and a space of outputs.  The idea is to adequately sample the input space.
17:49:32 * shapr rebuilds
17:49:41 <vincenz> Pseudonym: proper Arbitrary definitions
17:49:41 <Pseudonym> At least when you do it properly.
17:49:53 <shapr> QuickCheck is nice.
17:50:05 <Pseudonym> QuickCheck is nice, yes.
17:50:20 <Pseudonym> But the samples aren't necessarily well-tailored for the program.
17:50:43 <Pseudonym> Ideally, you want an equal number of samples from each strata, where the strata are tailored for the actual program.
17:51:04 <Pseudonym> The details are a but tricky, but it's a very cool idea when you think about it.
17:51:13 <shapr> Yup, the hard (and fun) parts of QuickCheck are generators and properties.
17:51:21 * Pseudonym nods
17:51:39 <Pseudonym> There's also debugging theory, yes.
17:52:04 <Pseudonym> A type error in Haskell, is one of two things.
17:52:08 <mathewm> Is there "theory theory" ? :)
17:52:17 <Pseudonym> One is an arbitrary restriction, like the occurs check or the monomorphism restriction.
17:52:37 <Pseudonym> The other, which is the more common case, is a disagreement between two parts of your program as to what the type of some expression should be.
17:52:42 <Pseudonym> "Expected X, found Y."
17:53:03 <vincenz> @hoogle Type
17:53:03 <lambdabot> Network.Socket.Type :: SocketOption
17:53:04 <lambdabot> Language.Haskell.TH.Type :: data Type
17:53:04 <lambdabot> Prelude.type :: keyword
17:53:06 <Pseudonym> Well, a bug in a program is like that.
17:53:16 <monochrom> There is "theory theory".
17:53:29 <Pseudonym> A bug is a disagreement between you and the compiler as to what your program means.
17:53:46 <vincenz> Anyone know where Show for Type is defined in ghc?
17:53:51 <sethk> where are the docs for dependent classes?  In the ghc extensions part of the users guide?
17:54:03 <bringert> is there a way to get ghci to show the "actual value" instead of using show?
17:54:18 <Pseudonym> If you think of a bug that way, then debugging really should be a search problem with the programmer playing the part of an oracle.
17:54:34 <Pseudonym> Which is the principle behind declarative debugging.
17:57:06 <Cale> > 95800^4 + 217519^4 + 414560^4 == 422481^4
17:57:06 <lambdabot>  True
17:57:23 <Pseudonym> Goodness, Fermat's Non-Theorem is false!
17:58:04 <sethk> Pseudonym, sure, it can be easily shown
17:58:35 <shapr> bringert: I can select zero images with no error! yay!
17:58:46 <Cale> > 27^5 + 84^5 + 110^5 + 133^5 == 144^5
17:58:47 <lambdabot>  True
17:58:50 <bringert> shapr: excellent
17:58:56 <bringert> shapr:  what about one?
17:59:02 * shapr is about to find out
17:59:35 <Pseudonym> > 1^3 + 1^3 + 1^3 + 1^3 + 1^3 + 1^3 + 1^3 + 1^3 == 2^3
17:59:36 <lambdabot>  True
17:59:44 <shapr> um, no?
17:59:46 <shapr> huh
18:00:10 <Cale> (they're counterexamples to a conjecture made bu Euler that for every integer n > 2, the sum of (n-1) nth powers of positive integers cannot itself be an nth power.
18:00:12 <Cale> )
18:00:16 <bringert> shapr: what happend?
18:00:18 <Pseudonym> Ah.
18:00:21 <shapr> bringert: http://www.scannedinavian.com/hope/image
18:00:40 <bringert> shapr: but you added an image?
18:00:43 <shapr> bringert: Seems to be creating entries in the table, dunno what the problem is.
18:00:50 <shapr> Yeah, I did.
18:01:07 <shapr> Should I clear the table rows and try again?
18:01:12 <bringert> shapr: are there entries in images, tags and properties?
18:01:28 <bringert> shapr: or clear the whole db
18:01:33 <shapr> ok, will do
18:01:46 <mathewm> OK, I lied about that being my last question...
18:01:59 <mathewm> How can I rewrite this using the [] monad: [x | x <- [1,5,12,3,23,11,7,2], x>10]
18:02:23 <mauke> > do { x <- [1,5,12,3,23,11,7,2]; guard (x > 10); return x }
18:02:24 <lambdabot>  [12,23,11]
18:02:37 <Pseudonym> @type guard
18:02:38 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:02:40 <mathewm> 'gaurd' - love it.
18:02:42 <mathewm> thanks
18:03:38 <dons> moin
18:03:56 <bringert> hi dons
18:04:40 <shapr> bringert: Nope, still no photos.
18:04:57 <bringert> ok, I actually haven't tried that on postgre here
18:05:28 <shapr> The image is in the images dir, and in the images table, but doesn't show up on http://www.scannedinavian.com/hope/image
18:05:48 <bringert> shapr: does it have entries in the properties table?
18:06:21 <shapr> bringert: yup
18:06:43 <bringert> weird. I'm working on some more bugs in my HaskellDB fix
18:06:56 <bringert> compiling now ...
18:07:04 <dons> ?seen ndm
18:07:04 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 8 hours, 30 minutes and 14 seconds ago, and .
18:07:07 <shapr> It's 3am, I'm out of fuel.
18:07:15 <shapr> I'll rebuild when I wake up.
18:07:17 * shapr &
18:09:13 <bringert> good night
18:10:57 <dons> dmhouse, around?
18:11:02 <dons> ?seen dmhouse
18:11:02 <lambdabot> I saw dmhouse leaving #haskell 7 hours, 23 minutes and 52 seconds ago, and .
18:18:01 <dons> @dynamic-reload instances
18:18:01 <lambdabot> module reloaded
18:18:05 <dons> @instances Integral
18:18:06 <lambdabot> Int, Integer
18:18:10 <dons> ?karma+ dmhouse
18:18:11 <lambdabot> dmhouse's karma raised to 2.
18:18:25 <dons> @instances Enum
18:18:25 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
18:18:32 <dons> very nic ework
18:18:57 <dons> ?seen sjanssen 
18:18:58 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
18:19:05 <dons> ?seen sjanssen_
18:19:05 <lambdabot> sjanssen_ is in #haskell. I don't know when sjanssen_ last spoke.
18:20:43 <vincenz> aloa
18:21:20 <dons> hey vincenz 
18:28:21 <vincenz> :)
18:31:16 <vincenz> damned I'm tired
18:34:02 <dons> ?localtime vincenz
18:34:09 <dons> bah
18:34:17 <dons> i'm not tired :)
18:34:37 <dons> ?localtime dons
18:34:40 <lambdabot> Local time for dons is Thu Jun  8 11:26:03 2006
18:36:38 <vincenz> 3:36am
18:36:45 <vincenz> been working on cleaning my compiler
18:37:00 <dons> yeah, i saw on the mailing list
18:37:26 <vincenz> Anyways, I made my typechecker type independent so it can pass along annotations transparentely, but I gotta test that functionality
18:37:38 <dons> ah, sjanssen_ is around :)
18:38:06 <Korollary> Heh. CosmicRay made it to slashdot.
18:38:13 <dons> yeah? url?
18:38:37 <Korollary> http://linux.slashdot.org/linux/06/06/07/047204.shtml
18:41:57 <dons> cool
18:42:08 <dons> he's the SPI chairman, isn't he?
18:54:05 <SamB> hmm, it occurs to me that the DSSSL spec may not have been layed out using DSSSL ;-)
18:55:40 <vincenz> can you use otherwise incase?
18:55:42 <vincenz> in case statements?
18:57:01 <mauke> > case 42 of otherwise -> "huhu"
18:57:01 <lambdabot>  "huhu"
18:57:23 <heatsink> huh?
18:57:27 <heatsink> @type otherwise
18:57:28 <lambdabot> Bool
18:57:49 <heatsink> > otherwise
18:57:50 <lambdabot>  True
18:58:05 <heatsink> > case 42 of True -> "type mismatch"
18:58:06 <lambdabot>  add an instance declaration for (Num Bool)
18:58:06 <lambdabot>   In the scrutinee of a case ex...
18:59:07 <dons> vincenz: now, you'd use a _
18:59:31 <dons> > caes True of False -> undefined ; _ -> ()
18:59:31 <lambdabot>  Parse error
18:59:35 <dons> > case True of False -> undefined ; _ -> ()
18:59:36 <lambdabot>  ()
18:59:56 <vincenz> dons: thx
19:00:25 <dons> remember that you're binding new variables, so case x of otherwise -> ... doesn't compare equivalence against Prelude.otherwise
19:00:34 <dons> it binds a new variable called 'otherwise' locally.
19:00:46 <dons> same as: f otherwise = ... 
19:01:35 <heatsink> oh ok
19:01:36 <vincenz> yep
19:01:49 <vincenz> dons: thx for that reminder ;)
19:03:22 * SamB wonders about he whitish line going down his monitor slowly
19:03:51 <heatsink> SamB: Your monitor is being scanned -- quick, turn it off!
19:04:13 <SamB> heatsink: but, there are no secrets on the screen at this time
19:04:24 <dons> yep, definitely the nsa
19:04:31 <SamB> unless you count ISO standards I stole via the DOE
19:05:00 <heatsink> if you're willing to take that risk...
19:05:30 <heatsink> what's the use of a standard if it's secret?
19:05:40 <SamB> well, ask the ISO!
19:05:55 <heatsink> but I don't know the handshake
19:06:11 <SamB> because they charge a crazy number of units of some currency I am unfamiliar with for their stuff
19:06:53 <heatsink> hmmm...
19:07:02 <SamB> (though I have no idea if it is outragious or not, except that I expect the ISO tends to overcharge)
19:07:51 <SamB> would have been easier to find if James Clark updated his website and/or had working email
19:09:01 <Korollary> the c++ standard costs $20
19:10:05 <SamB> I don't actually want that standard I was looking at on their site earlier anyway, I just wanted some DTDs from it
19:10:40 <SamB> but I wrote a catalog in which I redirected their PUBLIC identifiers to /dev/null, and it worked fine, so I guess I really didn't need those
19:10:51 <SamB> actually, they weren't DTDs but entity files
19:11:15 <SamB> I can only hope the CD version would have included them
19:11:56 <SamB> should I send in a bug on the debian "sgml-data" package for not having those? it seems to have older versions...
19:12:51 <Spark> i just implemented a compiler into the bytecode for that little vm i was working on a minute ago
19:13:00 <Spark> and compiled the factorial function from the target language into the byte code
19:13:01 <Spark> and executed it
19:13:02 <Spark> and it worked
19:13:16 <SamB> hmm, it looks like DSSSL would nead to be evaluated in a reader monad, at least
19:13:37 <SamB> er, need
19:13:56 <SamB> course, that would probably be the easiest way to do it anyway
19:14:24 <joe_k> i need to finish my stack based vm for pic 16x
19:14:55 <SamB> has anyone noticed that Haskell is sorely lacking in SGML support?
19:15:16 <dons> well, sorely lacking might be overstating it
19:15:37 <SamB> at least HXT's data model is SGML-ready, though ;-)
19:15:53 <SamB> maybe not for the DTDs, but at least for the actual documents
19:18:29 <SamB> anyway, obviously nobody has time to actually write an SGML parser in Haskell
19:18:52 <SamB> those are *waaay* too complicated
19:18:58 <vincenz> @hoogle member
19:18:58 <lambdabot> Data.IntMap.member :: Key -> IntMap a -> Bool
19:18:58 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
19:18:58 <lambdabot> Data.Map.member :: Ord k => k -> Map k a -> Bool
19:19:04 <petekaz> dons: do you have a few minutes to spare?  I have a question regarding lambdabot    doContextualMsg r = do
19:19:07 <petekaz>         let actions = withAllModules (\m -> handleIrc
19:19:10 <petekaz>           (ircPrivmsg towhere . Just .((?name++" module failed: ")++))
19:19:15 <petekaz>           (do mstrs <- catchError -- :: m a -> (e -> m a) -> m a                                                
19:19:18 <petekaz>                       (process m msg towhere "context" r)
19:19:19 <SamB> not that they would be especially hard in Haskell, or anything
19:19:20 <petekaz>                       (\ex -> case (ex :: IRCError) of
19:19:22 <dons> petekaz: yes, sure.
19:19:25 <mathewm> @where fps-info
19:19:26 <lambdabot> I know nothing about fps-info.
19:19:28 <vincenz> how do you make a default class member?
19:19:37 <petekaz> oops ...
19:19:41 <petekaz> wrong key.
19:19:42 <dons> ?where fps
19:19:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:19:50 <SamB> vincenz: you bind it in the class declaration
19:20:05 <vincenz> SamB: how?
19:20:11 <petekaz> dons: can I priv msg you?
19:20:17 <dons> SamB: or you catch the 'NoMethodException', and call a default ... ;)
19:20:18 <SamB> with an equals sign, same as usual
19:20:20 <dons> petekaz: yep
19:20:24 <vincenz> SamB: I get a lex error on that
19:20:26 <mathewm> thanks
19:20:40 <SamB> vincenz: maybe you messed up your whitespace
19:20:48 <vincenz> nm
19:20:50 <vincenz> yeah
19:20:53 <vincenz> was somewhere else
19:21:03 <SamB> hehe
19:22:05 <vincenz> > [1..4] // [3..4
19:22:05 <lambdabot>  Parse error
19:22:07 <vincenz> > [1..4] // [3..4]
19:22:07 <lambdabot>  Couldn't match `Array i e' against `[a]'
19:22:11 <vincenz> > [1..4] / [3..4]
19:22:12 <lambdabot>  add an instance declaration for (Fractional [a])
19:22:12 <lambdabot>   In the definition of `m...
19:22:27 <vincenz> @hoogle [a] -> [a] -> [a]
19:22:28 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
19:22:28 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:22:28 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:23:08 <Korollary> it's \\
19:23:17 <vincenz> > [1..4] \\  [3..4]
19:23:18 <lambdabot>  [1,2]
19:25:58 <dons> @hoogle (//)
19:25:59 <lambdabot> Did you mean: (//)
19:25:59 <lambdabot> Prelude.undefined :: a
19:25:59 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:26:05 <dons> yes, i meant (//)
19:26:09 <dons> yes, i meant //
19:26:12 <dons> @hoogle //
19:26:13 <lambdabot> Array.(//) :: Ix a => Array a b -> [(a, b)] -> Array a b
19:26:13 <lambdabot> Data.Array.(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
19:26:13 <lambdabot> Data.Array.IArray.(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
19:26:24 <Pseudonym> @vixen Yes, dons meant (//).
19:26:24 <lambdabot> :)
19:26:29 <dons> ndm, hoogle buglet
19:26:33 <dons> @hoogle (//)
19:26:34 <lambdabot> Did you mean: (//)
19:26:34 <lambdabot> Prelude.undefined :: a
19:26:34 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:26:38 <Pseudonym> @vixen Fix hoogle.
19:26:38 <lambdabot> you remind me of that actor, whatshisname
19:26:40 <dons> ndm, ^^^
19:26:46 <dons> hehe
19:26:57 <Pseudonym> @vixen You mean George C. Hoogle?
19:26:57 <lambdabot> first you tell me.
19:28:58 <lispy> @vixen busy tonight?
19:28:59 <lambdabot> nevermind about that
19:29:05 * heatsink discovers that **x+++*++*x is valid C syntax
19:29:17 <Pseudonym> But is it valid vixen syntax?
19:29:28 <heatsink> @vixen **x+++*++*x
19:29:28 <lambdabot> You should add me to your buddy list!
19:29:29 <Korollary> It's barbed wire to me
19:29:33 <mathewm> is fps incorporated into GHC 6.5?
19:29:48 <mauke> heatsink: it's invalid semantics, though
19:30:00 <vincenz> alright
19:30:01 <skew> Korollary: just add bananas and lenses, and you're ready to party.
19:30:02 <vincenz> question for you lot
19:30:05 <heatsink> mauke: it compiles.
19:30:05 <Pseudonym> @vixen Good point.  Is it any less legible than bananas, lenses and barbed wire?
19:30:05 <lambdabot> i think you know the answer to that one, silly
19:30:12 <mauke> heatsink: so?
19:30:15 <vincenz> i have an algorithmical proble
19:30:23 <the_lord> hi!
19:30:28 <vincenz> kudos for the first guy to solve it
19:30:46 <skew> hi
19:30:51 <vincenz> generate n unique strings that are not part of a list
19:30:55 <Pseudonym> vincenz: No, P != NP.  Kudos for me!
19:30:56 <the_lord> I want a function that extracts a char or string from a tuple
19:31:03 <heatsink> mauke: That's generally my test of whether it's valid semantics.
19:31:26 <the_lord> the function goes like this, (p, a) -> String
19:31:31 <skew> vincenz: is that a finite list?
19:31:34 <vincenz> skew: yep
19:31:56 <Pseudonym> vincenz: Build any number that you want that are longer than the list.
19:31:57 <the_lord> how do I sepparate the cases for a = char and for a = String
19:32:00 <the_lord> ??
19:32:00 <lambdabot> Maybe you meant: . v
19:32:02 <mauke> heatsink: short main[] = {-0xae3, '~', 2}; also compiles
19:32:08 <SamB> heatsink: you don't use C a lot, do you?
19:32:20 <SamB> mauke: what does it do?
19:32:22 <heatsink> SamB: I use C much.
19:32:25 <mauke> I have no idea
19:32:28 <vincenz> Pseudonym: so build n+l unique strings given size of list = l?
19:32:32 <SamB> mauke: why don't you try it?
19:32:44 <mauke> because I'm not insane
19:32:53 <dons> mathewm: yep
19:32:58 <Korollary> vincenz: sort the list, pick the largest, append n different characters
19:32:58 <vincenz> Pseudonym: kudos!
19:32:59 <the_lord> :(
19:33:02 <skew> vincenz: do you want any particular strings?
19:33:03 <Pseudonym> No, build strings of length n+1 where given size of list = n.
19:33:05 <vincenz> Pseudonym: nah I'll stick to the first
19:33:08 <vincenz> Pseudonym: generate n+l strings
19:33:13 <vincenz> Pseudonym: that are unique
19:33:21 <vincenz> for sure there are n that are not elof l
19:33:32 <vincenz> \o/
19:33:53 <dons> the_lord: what's the type again?
19:34:02 <dons> (p,a) -> String ?
19:34:06 <the_lord> yes
19:34:11 <heatsink> mauke: I'm printing C ASTs in haskell; trying to figure out where to put spaces.
19:34:17 <the_lord> and a is either char or String
19:34:24 <mauke> heatsink: around binary operators
19:34:28 <dons> its a bit strange. so you'll need some adhoc polymorphism
19:34:36 <heatsink> mauke: thx
19:34:42 <dons> how about: Show a => (p,a) -> String
19:34:45 <mauke> and after operators that are keywords
19:34:48 <dons> f (_,a) = show a
19:35:02 <heatsink> mm, right.
19:35:04 <the_lord> dons, thx I'll try
19:35:08 <dons> > let f (_,a) = show a in f ((), "haskell")
19:35:08 <lambdabot>  "\"haskell\""
19:35:20 <dons> > let f (_,a) = init . tail . show a in f ((), "haskell")
19:35:20 <lambdabot>  Couldn't match `[Char]' against `t -> t1'
19:35:34 <dons> > let f = init . tail . show . snd in f ((), "haskell")
19:35:35 <lambdabot>  "haskell"
19:35:39 <dons> > let f = init . tail . show . snd in f ((), 'x')
19:35:40 <lambdabot>  "x"
19:35:56 <dons> ?type let f = init . tail . show . snd in f
19:35:57 <lambdabot> forall b a. (Show b) => (a, b) -> [Char]
19:36:12 <vincenz> http://rafb.net/paste/results/geFr2G97.html
19:36:15 <vincenz> anyone care to check this
19:36:18 <mauke> heatsink: see also http://home.cs.tum.edu/~mai/stuff/cdecl/Cexp.pm :-)
19:36:36 <heatsink> is perl?
19:36:41 <scsibug> quick question..I'm trying to load the Parsec module into a ghci session, and not having much luck...
19:36:56 <dons> add -package parsec?
19:37:13 <vincenz> Pseudonym: http://rafb.net/paste/results/geFr2G97.html
19:37:22 <Lemmih> parsec isn't usually hidden.
19:37:24 <vincenz> Korollary: http://rafb.net/paste/results/geFr2G97.html
19:37:25 <dons> Prelude> :m + Text.ParserCombinators.Parsec
19:37:25 <dons> Prelude Text.ParserCombinators.Parsec>
19:37:28 <dons> works for me
19:37:43 <scsibug> dons: thanks, that worked
19:38:17 <Pseudonym> vincenz: Yikes.
19:38:38 <Pseudonym> Might be easier to work out determine that T1 <= T2 and T2 <= T1.
19:38:52 <Pseudonym> s/work out //
19:39:00 <dons> > let f = init . tail . show . snd in f
19:39:00 <lambdabot>  Add a type signature
19:39:02 <dons> doh
19:39:25 <Korollary> hah. monomorphism r?
19:40:02 <Pseudonym> Nope.  No typeclass instance for show./
19:40:08 <Pseudonym> > id
19:40:09 <lambdabot>  Add a type signature
19:40:10 <Pseudonym> Same problem./
19:40:14 <Korollary> ah
19:40:59 <Pseudonym> Lunch.  BBS
19:48:12 <mwc> Anybody ported GHC to Windows Mobile/CE yet?
19:48:14 <mwc> :P
19:49:59 <dons> yeah, in fact, its the no instance of Typeable for polymorphic values
19:50:11 <dons> not necessarily no instance of Show.
19:50:28 <dons> since we use Typeable to write the fShow instance for functions
19:50:32 <dons> > ord
19:50:33 <lambdabot>  <Char -> Int>
19:51:02 <dons> a prize to the person who gives me a reasonable show instance for polymorphic values!
19:51:27 <dons> here's the source: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/ShowQ.hs
19:51:34 <Korollary> > show ord
19:51:35 <lambdabot>  "<Char -> Int>"
19:51:41 <Korollary> hmm
19:51:44 <dons> I want an instance Show (a -> b) where ...
19:51:47 <dons> interesting, Korollary .
19:51:49 * Lemmih wonders if House can run on ipods.
19:52:11 <Cale> > print "Hello"
19:52:11 <lambdabot>  No IO allowed
19:52:12 <dons> > show putStr
19:52:12 <lambdabot>  "<[Char] -> IO ()>"
19:52:24 <mwc> ipodlinux? I'd think getting a haskell compiler running on it is in slim-to-none territory
19:52:45 <skew> no, House
19:52:47 <mathewm> *sigh*
19:53:05 <dons> who says you hvae to run the compiler on the ipod
19:53:08 <skew> maybe House is lighter than linux
19:53:12 <mwc> oh, I was thinking hope
19:53:13 <mwc> hahaha
19:53:15 <dons> and why not just run hugs, for example
19:53:30 <Korollary> mathewm: what's happening
19:53:34 <dons> also, nhc/yhc is _designed_ for embedded systems,so that'd be the path in
19:53:54 <mwc> dons, is there any reason the lack of an mmu would be a problem>
19:53:54 <mathewm> trying to build HAppS
19:54:01 <mathewm> not having much luck
19:54:12 <Lemmih> mathewm: That's the problem?
19:54:12 <dons> mwc, i can't see why it would be.
19:54:17 <Lemmih> mathewm: *What's
19:54:28 <mathewm> @where paste
19:54:29 <lambdabot> http://paste.lisp.org/new/haskell
19:54:29 <mwc> I thought that the GC's used the MMU for various tass
19:54:34 <mwc> Like a read or write barrier
19:54:43 <Lemmih> mathewm: FPS trouple?
19:54:51 <mwc> I suppose you could implement all that in the applicatoin
19:54:55 <mwc> but it'd be costly
19:55:04 <skew> mwc: all I've read about GH for Haskell uses the thunk entry procedures for the read or write barrier
19:55:31 <dons> Lemmih: FPS trouble? what's that then?
19:55:47 <lisppaste2> mathewm pasted "HAppS buils problem" at http://paste.lisp.org/display/20999
19:56:13 <dons> oh, right :)
19:56:16 <dons> mathewm: install fps 
19:56:25 <dons> ?where fps
19:56:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:56:26 <mathewm> Isn't that part of GHC 6.5?
19:56:34 <dons> indeed it is
19:56:43 <dons> but the cabal file must assume you need to install it separately
19:56:43 <mathewm> It collided with existing modules when I tried to build it
19:56:59 <dons> so i think just remove the 'fps' dependency from the .cabal file
19:57:04 <dons> since its in 'base' now.
19:57:22 <dons> the separate 'fps' repo will disappear soon enough anyway
19:57:23 <mathewm> I removed fps from the deps list in the .cabal and it complained about another dependancy - then another and another ...
19:57:40 <dons> more info needed to debug that problem then
19:57:54 <dons> can you show the output of rerunnign configure after removing the fps dep?
19:57:54 <mathewm> How about HaXml - is it included yet?
19:57:55 <Korollary> doesnt Setup have a verbose flag?
19:58:57 <jgrimes> so how well does ghc optimize tail-recursion? and is it worth it to write my functions tail-recursive when I can?
19:59:14 <dons> jgrimes: yep
19:59:18 <dons> it'll turn into a goto
19:59:23 <jgrimes> oh, ok
19:59:30 <jgrimes> good to know.
19:59:31 <dons> if its not tail recursive, you may end up with a stack leak
19:59:41 <jgrimes> dons, interesting
19:59:43 <dons> but a tail recursive loop should run like a while or for loop
19:59:52 <lisppaste2> mathewm annotated #20999 with "skip the fps, verbose" at http://paste.lisp.org/display/20999#1
19:59:56 <dons> indeed, you can beat C if you're tricky about it
20:00:01 <jgrimes> dons, oh yeah?
20:00:12 <dons> yep, sure.
20:00:17 <jgrimes> :)
20:00:17 <Lemmih> mathewm: You need to install all the dependencies.
20:00:39 <petekaz> If you write tail-recursive functions, you have to make sure they are strictly evaluated or you might blow the stack anyways.
20:00:59 <petekaz> (at least that is what I have read)
20:01:50 <jgrimes> hm
20:02:00 <dons> jgrimes, i.e. here's a loop for you: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
20:02:04 <petekaz> jgrimes: http://en.wikibooks.org/wiki/Programming:Haskell_List_Processing#Folds
20:02:19 <dons> note the space leak in the lisp entry there. interesting
20:02:30 <jgrimes> dons, petekaz: thanks
20:02:33 <petekaz> read that section, and pay attention to the technical note
20:02:46 <dons> actually, were hoping to really improve the loop optimiser in ghc in the next few months
20:02:56 <dons> which will help a lot of code with tight loops
20:03:14 <jgrimes> sweet.
20:03:41 <mathewm> So far, all the dependancies it claims I didn't have were in 'base'
20:03:50 <dons> and interesting to see how poorly perl, python and ruby perform
20:04:01 <dons> recursion isn't really their thing.
20:04:09 <jgrimes> apparently not
20:04:09 <jgrimes> :)
20:05:26 <dons> here's another tail recursive loop: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all
20:05:38 <dons> oh, surprise surprise, ruby is last again
20:06:03 <jgrimes> dons, you are a ghc developer?
20:06:04 <bringert> @pl maybe (return Nothing) (fmap Just . f)
20:06:04 <lambdabot> maybe (return Nothing) (fmap Just . f)
20:06:05 <dons> oh, that's annoying, we used to be ranked first in that test, but D and some others have caught up
20:06:15 <dons> jgrimes: not full time, i contribute some patches though
20:06:20 <jgrimes> dons, oh, cool.
20:06:20 <dons> i work more on libraries
20:06:31 <jgrimes> gotta have those, too :)
20:07:07 <vincenz> woot woot
20:07:12 <bringert> they changed lines of code to gzipped size?
20:07:17 <vincenz> my typechecker nicely passes through the annotation
20:07:18 <vincenz> \o/
20:07:36 <dons> bringert: yep, punished us a bit on the io code
20:07:38 <bringert> haskell is no longer at the top
20:07:41 <dons> bytestring should fix that
20:07:52 <dons> punished sml and perl more though :)
20:08:05 <dons> ?shootout
20:08:05 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
20:08:17 <dons> oh, where are we now?
20:08:40 <dons> oh, more recursive code: http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
20:08:48 <dons> guess which language starting with 'r' comes last?
20:08:55 <vincenz> clean beats us on mem
20:09:07 <dons> ah, OCaml sneaked ahead, i see
20:09:18 <vincenz> yeah but we do better on mem
20:09:19 <dons> vincenz: yeah, they've got tuned packed string io...
20:09:22 <monochrom> heh gzipped size
20:09:36 <dons> the gzip thing is a joke anyway. it measure compressibility, right?
20:09:45 <bringert> yeah
20:09:46 <dons> so the more repetition in your code, the better off you are.
20:09:52 <bringert> exactly
20:09:56 <dons> so we should write it all in terms of s k and i
20:10:05 <vincenz> dons: that won't help
20:10:14 <dons> semantic richness is not useful, anyway
20:10:16 <vincenz> dons: reuse a lot of prefixe
20:10:21 * vincenz laughs
20:10:25 <vincenz> ruby is first on gzip
20:10:28 <heatsink> heh
20:10:31 <bringert> we could try to reuse variable names as much as possible
20:10:38 <vincenz> yeah
20:10:39 <dons> vincenz, really??
20:10:41 <vincenz> dons: yep
20:10:42 * dons checks
20:10:42 <bringert> everything is called foo
20:10:46 <dons> oh, very strange
20:10:46 <the_lord> @hoogle String -> IO ()
20:10:47 <lambdabot> Prelude.putStr :: String -> IO ()
20:10:47 <lambdabot> Prelude.putStrLn :: String -> IO ()
20:10:47 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
20:10:48 <vincenz> foo foo = foo foo foo
20:10:54 <dons> wow, we slipped a bit there.
20:10:55 <vincenz> and rename all operators to foo!
20:11:03 <vincenz> where foo foo = fo foo foo
20:11:11 <vincenz> foo foooo fooo foooooo
20:11:30 * vincenz grins
20:11:42 <vincenz> we should get a haskell script to do that
20:11:53 <vincenz> using GHC 
20:11:57 <vincenz> parse it in
20:12:01 <vincenz> and uniquely name with foo
20:12:04 <heatsink> use "ase", "cas", "the", lse", etc. as variable names so that they compress together with keywords
20:12:09 <vincenz> always trying to keep the least amount of o that is not ambiguous
20:12:17 <dons> how about on the amd box... http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all
20:12:34 <vincenz> heatsink: and now read the code without syntax highlight
20:12:36 <dons> ah, we still have the least code size there. they must update less often
20:12:43 <heatsink> :)
20:13:02 <vincenz> case ase af of iff if els
20:13:03 <dons> oh, we beat Intel C on the amd64
20:13:24 <vincenz> now we don't
20:13:26 <bringert> it has 4 missing benchmarks though
20:13:37 <vincenz> dons: not on my page
20:13:39 <dons> and which language starting with P and ending in HP is ranked last?
20:13:52 <vincenz> dons: huh???
20:13:59 <vincenz> dons: I get spidermonkey last
20:14:00 <bringert> vincens: it depends on the multipliers
20:14:02 <dons> vincenz: the debian benchmarks? 
20:14:10 <vincenz> dons: debian AMD sempron
20:14:11 <dons> vincenz: or do you have your multipliers wacked
20:14:11 <vincenz> cpu
20:14:19 <vincenz> dons: check lines of codes
20:14:24 <vincenz> dons: is it still one for yu?
20:14:30 <dons> yep
20:14:31 <vincenz> http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all&calc=Calculate&xfullcpu=1&xmem=0&xloc=0&binarytrees=1&chameneos=1&message=1&fannkuch=1&fasta=1&knucleotide=1&mandelbrot=1&nbody=1&nsieve=1&nsievebits=1&partialsums=1&pidigits=1&recursive=1&regexdna=1&revcomp=1&spectralnorm=1&hello=0&sumcol=1
20:14:37 <vincenz> ah ok
20:14:38 <vincenz> mine is pure cpu
20:14:47 <dons> we're 1 on loc, 3 overall
20:14:48 <mgoetze> i think ghc doesn't even beat php on my macbook :(
20:14:53 <vincenz> D, c gcc, c++ g++, c intel, eiffel, sml mlton, ghc
20:15:05 <vincenz> dons: I should enter my language :D
20:15:06 <dons> mgoetze: sounds unlikely. if it doesn't, that's gcc's fault
20:15:30 <vincenz> oh yeah
20:15:31 <vincenz> someone
20:15:36 <vincenz> come up with a nifty name for my prog lang?
20:15:42 <skew> gtk2hs seems to be missing buttong state from the Modifier type
20:15:53 <mgoetze> dons: it's more a matter of not being ported to intel macs yet, thus requiring powerpc emulation
20:15:59 <dons> oh, right :)
20:16:04 <vincenz> Anyone?
20:16:06 <dons> that too might affect the performance
20:16:09 <dropdrive> Hey guys, a random question from a Haskell novice: I understand that non-strict functions in Haskell can be made to be strict (by forcing the evaluation of arguments), but are there any strict languages that allow lazy evaluation?  And is there a way to tell GHC (or whatever) that "all my functions are strict unless I explicitly say so"?
20:16:17 <vincenz> dropdrive: ocaml
20:16:21 <vincenz> dropdrive: scheme
20:16:23 <Lemmih> vincenz: Gaskell?
20:16:29 <dons> ML has a 'lazy' function
20:16:31 <vincenz> Lemmih: erm it's strict tho
20:16:34 <bringert> mgoetze: I run a native ghc on my macbook
20:16:35 <vincenz> dons: hence ocaml ;)
20:16:42 <dons> regarding strictness by default, no.
20:16:43 <vincenz> dropdrive: any language with closures
20:16:50 <bringert> mgoetze: works great, if you don't mind using ghc-6.5
20:16:52 <vincenz> heh
20:16:55 <mgoetze> bringert: did you get an image or did you have to build it yourself?
20:16:58 <dons> but you don't want that, really. you lose expressiveness, and also end up with leaks and whatnot
20:17:06 <vincenz> Oaskell?
20:17:13 <vincenz> @poll
20:17:13 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell
20:17:25 <vincenz> @help poll-add
20:17:26 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
20:17:28 <dons> dropdrive: though if you program in #-kinded types, you get strictness by default
20:17:31 <dons> a ghc extension
20:17:35 <mgoetze> i tried an image off the wiki (ghc 6.5.20060526) but couldn't get it to work
20:17:38 <bringert> mgoetze: both builds from here work: http://cvs.haskell.org/trac/ghc/wiki/X86OSXGhc
20:17:51 <skew> is there any documentation on gtk2hs other than the api docs?
20:18:06 <mgoetze> bringert: yeah, somehow the top one of those didn't work for me
20:18:07 <bringert> mgoetze: I built my own using AudreyTang's build
20:18:20 <vincenz> Gaskell, OasisML, Dromedaris?
20:18:22 <skew> it seems pretty close to the C api, but not exactly
20:18:37 <vincenz> Lemmih: where does the G come from?
20:18:42 <dropdrive> vincenz: okay, I see your point about closures, thanks.
20:18:43 <bringert> mgoetze: the second one works too, just a little more hassle to install
20:18:47 <skew> vincenz: check out some of aardappel's languages
20:18:56 <vincenz> skew: I need a name for my language
20:18:57 <bringert> mgoetze: what was the problem?
20:19:06 <monochrom> Iaskell
20:19:07 <Lemmih> vincenz: An english writer named Elizabeth Gaskell.
20:19:14 * vincenz shrugs
20:19:26 <vincenz> Oasiskell
20:19:35 <skew> what does your language do?
20:19:40 <vincenz> skew: it's a mix of ml and haskell
20:19:55 <monochrom> Hasmell
20:19:59 <heatsink> vincenz: I'm sure someone in #esoteric could come up with a catchy name
20:20:01 <skew> what mix? not not ml?
20:20:02 <vincenz> Ha smell!
20:20:07 <vincenz> heatsink: it ain't esoteric
20:20:15 <heatsink> doesn't have to be
20:20:17 <mgoetze> bringert: hm, forgot, i'll have a closer look at it sometime later
20:20:41 <vincenz> skew: strict, but recursive declarations at top level, no shadowing, and haskell style modules
20:20:52 <dons> why haskell-style modules?
20:20:56 <dropdrive> dons: when you say that one loses expressiveness, do you mean that laziness is commonly desired and hence it would be a pain to explicitly declare it?
20:20:56 <skew> why haskell style modules?
20:20:57 <monochrom> haha not not ml
20:20:57 <vincenz> I dunno?
20:20:58 <mgoetze> bringert: just now i'm kinda busy trying to compile gnumeric and dependencies from scratch :(
20:20:59 <vincenz> I felt like it
20:21:04 <bringert> mgoetze: ghc-6.5 runs faster on my macbook than my adm64 desktop with the same clockspeed
20:21:06 <dons> aren't ml's far more complex and expressive? ;)
20:21:12 <vincenz> dons: I don't need it
20:21:17 <vincenz> dons: and that way later on I can easily reuse the framework
20:21:17 <skew> monochrom: have you read that paper?
20:21:18 <vincenz> ;)
20:21:22 <vincenz> just change the semantics
20:21:25 <monochrom> No.
20:21:30 <bringert> mgoetze: eh, than ghc-6.4.1 on amd64
20:21:38 <dons> dropdrive: yeah, i.e. we rely on the laziness to implement control structures all the time
20:21:38 <vincenz> dons: for ohc
20:21:46 <dons> or the laziness of lists to short circuit loops
20:21:59 <vincenz> dons: or monadic stuff
20:22:08 <vincenz> dons: while can be done in askell as a func, not in strict langs
20:22:11 <vincenz> s/askell/haskell
20:22:16 <dons> yep
20:22:30 <skew> http://research.microsoft.com/~simonpj/papers/not-not-ml/
20:22:37 <vincenz> The polls are still ope
20:22:38 <dons> things like 'catch' can be normal functions, not new syntax added to the language
20:22:39 <monochrom> It occurs to me recently that intuitionistic logic is dating logic, e.g., "I do not dislike you" does not imply "I like you".
20:22:46 <vincenz> skew: then in the trend of "notvincenz"
20:22:54 <vincenz> skew: I'll call mine "not . not . not $ ml"
20:23:02 <skew> something to do with the double-negation embedding of classical logic into intuitionistic logic
20:23:15 <skew> and a commong runtime for lazy and strict languages
20:23:21 <vincenz> $nothaskell
20:23:27 <vincenz> with $ faking as a s
20:23:53 <vincenz> iskell?
20:24:02 <vincenz> has vs is
20:24:30 <vincenz> @google notkell
20:24:32 <lambdabot> http://blog.tenbit.pl/julia_1989/43
20:24:35 <vincenz> crud
20:25:41 <heatsink> hl?
20:26:01 <vincenz> rather short
20:26:02 <bringert> vincenz: did you follow that link?
20:26:05 <vincenz> bringert: yeah
20:26:08 <vincenz> too tired to read it now tho
20:26:10 <vincenz> 5:30 am
20:26:22 <vincenz> I saved it in my big ebook collection (6gb)
20:26:45 <bringert> vincenz: the polish blog all in pink?
20:26:50 <vincenz> bringert: oh n
20:26:54 <monochrom> heh
20:26:59 <vincenz> I thought not not ml
20:27:01 <bringert> you must have an interesting collection
20:27:11 <vincenz> I do!
20:28:18 <bringert> I see...
20:28:45 <vincenz> mostly on programming, mathematics, cache optimization, type theory, compiler construction, semantics, etc..
20:29:14 <vincenz> I oughta generate a list of em
20:29:14 <jgrimes> are there any good haskell oriented blogs?
20:29:37 <Korollary> There's http://sequence.complete.org/
20:29:48 <jgrimes> yeah, I've been there. should have mentioned that.
20:29:48 <jgrimes> :)
20:29:59 <heatsink> jgrimes: scannedinavian perhaps
20:30:15 <dons> planet.haskell.org
20:30:19 <vincenz> dunesml
20:30:23 <vincenz> ?
20:30:23 <dons> ?google haskell blogs
20:30:25 <lambdabot> http://sequence.complete.org/blog/16
20:30:31 <vincenz> @google dunesml
20:30:32 <lambdabot> No Result Found.
20:30:35 <vincenz> \o/
20:30:42 <dons> planet.haskell.org is the haskell blog aggregator
20:30:48 <jgrimes> dons, thanks
20:30:50 <Pseudonym> LtU is good, though not specifically Haskell.
20:30:54 <vincenz> What do you guys think of "dunesml"?
20:30:57 <Pseudonym> www.lambda-the-ultimate.org
20:30:58 <jgrimes> yeah, I really like LtU
20:30:58 <dons> petekaz, around?
20:31:02 <vincenz> given how "oasis" is made of dunes
20:31:20 <monochrom> need Spice
20:31:45 <vincenz> some pizzaz, hmm?
20:32:21 <vincenz> mlirage
20:32:34 <monochrom> Continuations in dunesml can be called that :)
20:32:35 <heatsink> mlrage
20:32:44 <vincenz> monochrom: :D
20:32:57 <vincenz> heatsink: too agressive
20:33:05 <vincenz> dromldaris
20:33:18 <heatsink> sounds like something from sci-fi
20:33:20 <vincenz> (o'caml...dromldaris...mine has less features, so only one hump)
20:33:38 <heatsink> what does the is suffix mean?
20:33:44 <vincenz> huh?
20:33:49 <vincenz> dromedaris is an animal
20:33:54 <heatsink> Isn't that "dromedary"?
20:34:07 <vincenz> hmm, prolly, dromedaris is the dutch name
20:34:08 <Korollary> go for heMLock
20:34:15 <vincenz> Korollary: based on what/
20:34:25 <Korollary> I dunno. It's just a name heh
20:34:32 <vincenz> where does haskell come from anyways
20:34:36 <heatsink> oic
20:34:38 <Korollary> Haskell Curry
20:34:42 <heatsink> It's a mathematician's name.
20:34:42 <vincenz> oh rightio
20:35:01 * vincenz . o O (Christophe)
20:35:09 <heatsink> Jones
20:35:18 <Korollary> That's a good language name
20:35:22 <heatsink> who's christophe?
20:35:24 <vincenz> me
20:35:28 <heatsink> ok
20:35:39 <vincenz> or my last name
20:35:42 <vincenz> which sounds funky in english
20:35:47 <heatsink> but that ties your reputation into the language too closely methinks.
20:35:56 <vincenz> heatsink: hence the non serious thoughtbubble
20:36:05 <Korollary> Fluffy
20:36:11 <heatsink> oh. what does a serious thoughbubble look like?
20:36:25 <vincenz> heatsink: hehe... if it were serious I would've spoken of course
20:36:45 <vincenz> but prolly something like . o O | |
20:37:17 <vincenz> the worst part of software development... naming
20:37:36 <dropdrive> I'm about to go to bed...does anyone have a Haskell puzzle I can think about as I try to fall asleep?
20:37:52 <vincenz> dropdrive: generate n unique strings not in a list
20:37:55 <vincenz> efficiently
20:38:23 <heatsink> vincenz: Is it an ordered list?
20:38:27 <vincenz> nope
20:38:33 <dropdrive> vincenz: I'm not sure I understand
20:38:44 <vincenz> dropdrive: then understanding is your puzzle
20:38:47 <monochrom> You can use the name of your prof.
20:38:48 <Cale> hehe
20:39:01 <dropdrive> vincenz: can be solved in a dozen lines or fewer?
20:39:03 <vincenz> mlivr
20:39:07 <vincenz> dropdrive: I did it in 3
20:39:13 <Cale> I think he means that you have to generate a bunch of strings all of which are different from each other and not elements of a particular list. 
20:39:23 <vincenz> it's actually rather trivial
20:39:27 <vincenz> given length list == l
20:39:30 <vincenz> generate l+n unique strings and filter
20:40:05 <bringert> or generate an infinite number and filter
20:40:15 <vincenz> same difference
20:40:35 <bringert> sure, might save a character or two though
20:40:41 <heatsink> vincenz: randomized algorithm.  Choose a random sequence of characters of length ceil(log26(n)).  There's a high probability that the string will not be a prefix of any string in the list.  Then append digits to the randomized string to get however many unique strings you want.
20:40:56 <vincenz> heatsink: except that they then don't follow my nice naming scheme
20:40:58 <vincenz> generated by
20:41:03 <Cale> filter (`notElem` xs) ([replicate k ['a'..'z'] | k <- [1..]] >>= sequence)
20:41:11 <bringert> did anyone say it should be efficient btw?
20:41:19 <vincenz>           vars = map return ['a'..'z'] ++ map (++ "'") vars
20:41:41 <vincenz> using a set 
20:41:49 <vincenz> and then filtering with the set would shave off a bit
20:42:03 <vincenz> if you take n+l
20:42:22 <vincenz> > vars = map return ['a'..'z'] ++ map (++ "'") vars !! 100000
20:42:22 <lambdabot>  Parse error
20:42:26 <vincenz> > let vars = map return ['a'..'z'] ++ map (++ "'") vars !! 100000
20:42:26 <lambdabot>  Parse error
20:42:32 <vincenz> > let vars = map return ['a'..'z'] ++ map (++ "'") vars in vars !! 100000
20:42:33 <lambdabot>  "e'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''...
20:43:07 <vincenz> hmm
20:43:10 <vincenz> > let vars = map return ['a'..'z'] ++ map (++ "'") vars in nub vars
20:43:11 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s",...
20:43:15 <vincenz> woah
20:43:22 <vincenz> nub is lazy?
20:43:38 <vincenz> that must build up a serious amount of intermediate memory
20:44:15 <vincenz> > let vars = map return ['a'..'z'] ++ map (++ "'") vars in (nub vars) !! 100000
20:44:19 <lambdabot> Terminated
20:44:24 <vincenz> > let vars = map return ['a'..'z'] ++ map (++ "'") vars in (nub vars) !! 10000
20:44:27 <lambdabot> Terminated
20:44:31 <vincenz> > let vars = map return ['a'..'z'] ++ map (++ "'") vars in (nub vars) !! 1000
20:44:32 <lambdabot>  "m''''''''''''''''''''''''''''''''''''''"
20:44:35 <vincenz> hmm
20:44:45 <bringert> take n $ filter (`notElem` xs) $ repeat a
20:44:57 <vincenz> bringert: yep that's a linear growth in memory
20:45:05 <vincenz> just imagine dropping a few 100000 elements
20:45:17 <bringert> yeah
20:45:20 <dropdrive> I mean, why not concatenate the list of strings and then tack on "a"s
20:45:24 <bringert> I just want to write a short one
20:45:44 <dropdrive> Don't you have to say something about the strings you want, in addition to the fact that they not belong to your given list?
20:46:18 <vincenz> dropdrive: alright, I want single characters postfixed with a set of '
20:46:26 <vincenz> dropdrive: and to make it slightly more complex
20:46:31 <vincenz> a minimal amount of '
20:46:44 <vincenz> now that I think about it, my algo has those features
20:47:37 <vincenz> anyways
20:47:43 <vincenz> back to my compiler, time for strictness analysis
20:48:20 <vincenz> Anyone know a good paper on generic constraint systems?
20:48:38 <bringert> don't most people just use a state monad or something for generating fresh names?
20:48:45 <vincenz> bringert: yep
20:48:49 <vincenz> @hawiki MonadSupply
20:48:50 <lambdabot> Maybe you meant: gwiki wiki
20:48:54 <vincenz> @oldwiki MonadSupply
20:48:54 <lambdabot> http://www.haskell.org/hawiki/MonadSupply
20:49:54 <mathewm> has Data.FastPackedString been renamed?
20:50:21 <bringert> yes
20:50:34 <mathewm> to what?
20:51:15 <bringert> Data.ByteString
20:52:03 <mathewm> I do think Haskell is extremely bad about backward compatibility
20:52:42 <vincenz> mathewm: it's a pareto curve
20:52:51 <vincenz> I think haskell is situated in a nice region
20:53:06 <Dreadshoot> nice region..?
20:53:11 <vincenz> Not too stable
20:53:30 <Dreadshoot> hmm not stable is a good thing?
20:53:39 <vincenz> Notice the emphasis on "too"
20:53:42 <vincenz> Anything too is bad
20:53:53 <vincenz> erm... "too anything"
20:53:59 <Pseudonym> @google "too rich or too thin"
20:54:01 <lambdabot> http://en.thinkexist.com/quotation/a_woman_can-t_be_too_rich_or_too_thin/345690.html
20:54:13 <Dreadshoot> vincenz: well everything cant be "too"
20:54:18 <bringert> Dreadshoot: for example many think that debian is too stable
20:54:23 <Pseudonym> Can you be too healthy?
20:54:25 <vincenz> Dreadshoot: too implies too much
20:54:25 <mathewm> Next module past, present, or future: Text.XML.HaXml.Verbatim
20:54:26 <Pseudonym> Or too alive?
20:54:35 <vincenz> Pseudonym: too healty: yes you would live on tofu
20:54:39 <vincenz> would you want that?
20:54:53 <Pseudonym> Well, I'm not a fan of tofu as a rule.
20:54:57 <Dreadshoot> vincenz: i dont really see your point.. c++ is too good and too fast compared to haskell..
20:55:03 <skew> Pseudonym: if you can't, isn't that just because you are reserving "too healthy" to mean something bad?
20:55:07 * vincenz coughs
20:55:25 <vincenz> Dreadshoot: you can't apply "too" to a comparison, but besides that, I think many people will disagree with you
20:55:28 <vincenz> Dreadshoot: me included
20:55:29 <Pseudonym> No, I'm claiming that there's no such thing as "too healthy".
20:55:30 <mathewm> Anyone see where Text.XML.HaXml.Verbatim ran off to?
20:55:35 <mathewm> @where Text.XML.HaXml.Verbatim
20:55:35 <lambdabot> I know nothing about text.xml.haxml.verbatim.
20:55:37 <Pseudonym> And I disagree about the tofu.
20:55:49 <mathewm> @seen Text.XML.HaXml.Verbatim
20:55:49 <lambdabot> I haven't seen Text.XML.HaXml.Verbatim.
20:55:52 <dropdrive> well I think that someone can be "too pregnant"
20:55:55 <mathewm> me either :)
20:55:55 <dons> mathewm: it depends. if you stick to haskell98 its extrememly stable
20:55:56 <vincenz> I think that "too" refers to the fact that everything is a trade-off, and if you're too something, you're not enough something else
20:56:03 <dons> if you play on the cutting edge, well, you get cut some times
20:56:04 <vincenz> dropdrive: quintuplets?
20:56:15 <mathewm> but then I cannot play with any cool products in haskell
20:56:15 <Dreadshoot> vincenz: most people = the few ones in here yeah :), and i know how the word is used. But saying that a language isnt too stable is kinda weird
20:56:22 <mathewm> I wanna try HAppS...
20:56:25 <skew> anyway, Haskell picks up lots of great new things like STM
20:56:26 <dropdrive> vincenz: good point.
20:56:27 <Cale> mathewm: re. backward compatibility, that's why it must try to remain unpopular.
20:56:37 <vincenz> Dreadshoot: I mostly work with c++ and t.b.h it has many flaws
20:56:42 <dons> mathewm: of course you can play with cool products
20:56:44 <skew> and GADTs
20:56:50 <dons> nothing stops you. we do it all day ong
20:56:58 <Cale> mathewm: Popularity makes languages develop sluggishly.
20:56:58 <bringert> Dreadshoot: the language is fairly stable, the libraries might not always be though
20:57:03 <bringert> especially the experimental ones
20:57:17 <vincenz> well alright, I'll be fair, c++ ain't stable either, noone has fully implemented it yet
20:57:18 <Dreadshoot> vincenz: i just made that sentence as a funny example, not to start the vs language comparision even though we know which one owns :)
20:57:40 <dons> anyway, you fps isn't 1.0 yet, so changing a few names is reasonable.
20:57:49 <dons> s/you// -- bizarre
20:57:55 <vincenz> Dreadshoot: perl?
20:58:20 <Dreadshoot> lets leave that unsaid
20:58:30 <vincenz> good, I have had the good fortune of never touching it
20:58:56 <Pseudonym> vincenz: The reason why nobody has fully implemented C++ is that you really, really do not want "export".
20:58:56 <vincenz> Dreadshoot: My point is that if something is too stable, it will quickly stale
20:59:13 <Dreadshoot> and i havent seen people saying "this os or whatever is too stable" so i wont use it
20:59:36 <vincenz> Pseudonym: yeah but disregarding that, they only really built the first compliant compiler 5 years after the spec
20:59:40 <Cale> Dreadshoot: in the sense of not changing, not in the sense of reliability
20:59:45 <vincenz> Pseudonym: afaik msvc2003
20:59:50 <Cale> (though they are related)
21:00:02 <Cale> Debian stable is too stable for me
21:00:10 <Cale> which is why I run unstable
21:00:13 <Dreadshoot> hah
21:00:19 <vincenz> my point is that "too" is typically a bad attribute
21:00:21 <vincenz> not a good one
21:00:41 <Dreadshoot> well i use to use beta versions and stuff of programs when available also
21:00:57 <Spark> what debian call "testing" is what most people would call stable i think
21:01:02 <skew> and the real point is that haskell changes pretty quickly, and picks up good stuff in the process
21:01:10 <Cale> The problem with debian stable is that one is released every few years, and in the interim, everything gets quite old.
21:01:10 <Spark> what debian call "stable" is what most people would call "retarded"
21:01:15 <Dreadshoot> ofc its usually a bad one, but this was kinda a strange use of it
21:01:20 <Cale> Spark: hehe
21:01:37 <Spark> they still manage to break testing on a regular basis though :(
21:01:43 <Cale> It *is* stable though.
21:01:45 <vincenz> Spark: in the formal sense of the word?
21:01:53 <Spark> debian manage to capture the worst of both worlds
21:01:53 <Cale> Spark: they do?
21:02:05 <Cale> Spark: I run unstable, and rarely have any problems.
21:02:05 <vincenz> Spark: it's clearly above the pareto curve
21:02:07 <Spark> Cale: yeah if youre unlucky
21:02:09 <Dreadshoot> and windows the best of both? :)
21:02:23 <Spark> Cale: you have to do an upgrade at the wrong time
21:02:26 <Cale> right
21:02:32 <vincenz> anything not on the pareto curve should be discarded and kicked into bitrot
21:03:16 <skew> what do you mean not on the curve?
21:03:25 <Cale> Dreadshoot: Windows updates almost never, and never quite makes it to reliability :)
21:03:25 <vincenz> above it
21:03:31 <vincenz> cause it's impossible to be below it
21:03:34 <Dreadshoot> Cale: wrong
21:04:33 <monochrom> Why is Dreadshoot being the Devil's advocate?  It is long past 06/06/06.
21:04:50 <bringert> "There are infinite dynamics in business. Master them all." -- ad for Microsoft Dynamics
21:04:57 <bringert> did they implement it in Haskell?
21:05:13 <jcreigh> monochrom: In my TZ, it was yesterday. Hardly "long past". :)
21:05:16 <Dreadshoot> monochrom arent you tired of those jokes yet, heard em for 4 whole days now
21:05:19 <Pseudonym> Hey, does it handle fluid dynamics?
21:05:25 <vincenz> bringert: what is microsoft dynamics?
21:05:43 <bringert> dunno
21:05:49 <vincenz> bringert: does it handle peoplodynamics?
21:05:51 <Cale> Not that it matters that much. My dad is still running '98 on his machine. We tried installing XP, and the system call to allocate swap space was broken. Hence, the system thought it was allocating swap space, but anything which was written to swap was toast, leading to crashes.
21:05:55 <bringert> just saw the ad
21:06:08 <Pseudonym> How about quantum electrodynamics?
21:06:08 <bringert> http://www.microsoft.com/dynamics/intro/default.mspx
21:06:20 <Spark> i would still use 98 but it doesnt run on my motherboard now :(
21:06:24 <Spark> there are no 98 drivers
21:06:29 <Spark> so i've upgraded to 2k
21:06:31 <monochrom> Well I'm sure I'm tired of Dreadshoot's jokes about c++ and windows.
21:06:38 <Spark> and annoyingly, windows wont fit on a 512 meg flash card anymore
21:06:59 <Dreadshoot> Cale: you wouldnt be able to boot it then cause it swaps like all the time except if you totally turn swap off
21:07:22 <Cale> Dreadshoot: oh, it would boot, but it wouldn't run for very long
21:07:34 <Dreadshoot> monochrom: you are the devils advocate yes, and you never add something except crappy responces
21:07:36 <vincenz> Spark: have you ever known it to fit on the portable storage medium of its time?
21:07:54 <bringert> why would Windows swap stuff *out* during boot?
21:07:58 <Cale> Dreadshoot: turning swap off altogether made it run, but without much space to actually load programs.
21:08:03 <Dreadshoot> Cale: ah maybe, that must be very rare though, havent even heard of the problem before
21:08:09 <vincenz> microsoft is the neverending driver for bigger portable storage
21:08:19 <Cale> Needless to say, we were unimpressed
21:08:45 <vincenz> Cale: or just pressed
21:08:47 <bringert> vincenz: I thought that was porn and copyright infringement
21:08:51 <vincenz> if you remove the double negative
21:08:56 <Dreadshoot> Cale: something has been major wrong, just try again
21:09:20 <vincenz> bringert: well yeah but windows is the cause of porn, there's nothing else to do in it
21:09:38 <Dreadshoot> and preferably with an sp2 disk :)
21:09:50 <bringert> i don't know, it's not all that easy to set up a digital camera in windows
21:09:55 <vincenz> Dreadshoot: I thought that waas a sleezy typoed remark to my comment
21:09:56 <Cale> Well, '98 is probably better anyway, since it isn't as susceptible to the latest viruses, and it has a smaller memory footprint.
21:10:02 <vincenz> disk...heh
21:10:04 <scodil> so this trick that DiffArray does, where it's mutable under the hood but it presents a pure interface, is that kind of thing hard to do?
21:10:15 <Cale> scodil: not too hard
21:10:26 <Cale> @fptools Data.Array.Diff
21:10:27 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/Diff.hs
21:10:33 <Dreadshoot> ;)
21:10:41 <skew> unsafePerformIO, and some NOINLINE pragmas to ward off evil
21:10:50 <scodil> is DiffArray implemented in haskell or c?
21:10:52 <vincenz> And latex gloves
21:10:56 <Cale> In Haskell
21:11:00 <scodil> nice
21:11:17 <scodil> is anything implemented in c? ghc is written in haskell, no?
21:11:27 <Dreadshoot> i got a win 2003 server with like 2 years uptime and over 50000 requests/day, thats pretty good
21:11:28 <Cale> Yeah, ghc is written in Haskell too :)
21:11:49 <vincenz> Dreadshoot: oh..I know! You had it disconnected with a manual script that performed one tried and tested request
21:11:55 <skew> the ghc runtime is mostly written in c
21:11:56 <vincenz> Dreadshoot: once every hour to ensure it's not bogged down
21:12:14 <Dreadshoot> vincenz: what are you talking about?
21:12:19 <skew> it would be pretty hard to run haskell code with a haskell runtime
21:12:26 <Cale> skew: without :)
21:12:39 <vincenz> Dreadshoot: You serve bad jokes but you don't receive em?
21:12:42 <vincenz> ;(
21:12:42 <skew> well, run Haskell code in a runtime written in Haskell
21:12:58 <skew> which is running in a runtime written in Haskell...
21:12:59 * vincenz shuts up and goes back to work
21:13:11 <Dreadshoot> ooh, well its 6am and im on my way out for a run in a moment :)
21:13:18 <vincenz> Dreadshoot: here too
21:13:21 <vincenz> Dreadshoot: just up or still up?
21:13:29 <Dreadshoot> still up :)
21:13:32 <vincenz> likewise
21:13:36 <skew> I've heard stories of lisp runtimes and gcs and such that were written in lisp, just very carefully written not to cons
21:13:41 <vincenz> hence my torrent of crappy jokes
21:13:50 <vincenz> I'm stalling doing something useful
21:14:23 <vincenz> Anyone have a good name for a substitution monad
21:14:28 <vincenz> It's a readerT with a M.Map a b
21:14:35 <vincenz> find :: a -> m b
21:14:45 <vincenz> scope :: (M.Map a b -> M.Map a b) -> m c -> mc
21:15:27 <Cale> Dictionary ?
21:15:29 <heatsink> skew: wow, I didn't know you could do that.
21:15:49 <vincenz> Cale: was hoping to follow your MonadXXX naming scheme
21:16:25 <Dreadshoot> Cale did you get to read any cloth/water.. simulation in school?
21:16:26 <Cale> MonadDict?
21:16:34 <Cale> Dreadshoot: hm?
21:16:42 <vincenz> Dreadshoot: Oh have you read that work by the guy in poland?
21:16:43 <Dreadshoot> maybe there is no courses like that
21:16:50 <vincenz> Dreadshoot: the one that sadly doesn't publish his papers but instead sells a CD
21:16:59 <Dreadshoot> vincenz: not sure
21:17:02 <Cale> Dreadshoot: wouldn't that be physics, or computer graphics?
21:17:04 <vincenz> Dreadshoot: For deformable bodies using fluid and cloth
21:17:15 <Dreadshoot> Cale: yeah maybe
21:17:19 <vincenz> Dreadshoot: based on a pressure model
21:17:21 <Cale> Dreadshoot: I was in Pure Mathematics, not applied :)
21:17:30 <Dreadshoot> vincenz: i might actually have read that
21:17:38 <vincenz> Quite interesting I must say
21:17:42 <vincenz> sadly the paper only treats 2d
21:17:50 <vincenz> Be cool to write something like that in haskell
21:17:57 <vincenz> but I don't know how to solve the equations in 3d
21:17:59 <Dreadshoot> http://www.gamedev.net/community/forums/topic.asp?topic_id=390303 this looks pretty good
21:18:02 <vincenz> or at least I haven't tried
21:18:39 <Dreadshoot> you got the url to his site?
21:18:41 <vincenz> Dreadshoot: if you like that kind of stuff, check out the game "obliion"
21:18:44 <vincenz> it's fricking impressive
21:18:57 <vincenz> http://www.ep.liu.se/ecp/010/007/ecp01007.pdf
21:19:06 <vincenz> http://panoramix.ift.uni.wroc.pl/~maq/talks/sigrad03/SoftBodyPresentation.pdf
21:19:12 <Dreadshoot> yes it is, even in morrowind(the game before oblivion) it looked really good.. for been made years ago
21:19:14 <vincenz> can't remember the site
21:19:38 <vincenz> but I'm waiting for the life game
21:19:41 <vincenz> that's coming out in september
21:19:47 * vincenz forgot the name
21:19:53 <Cale> Spore
21:19:54 <heatsink> spore?
21:19:57 <vincenz> rightio
21:20:01 <Dreadshoot> yeah this paper i've read before
21:20:10 <vincenz> Dreadshoot: I had some more papers but I removed them
21:20:19 <vincenz> Dreadshoot: trying to keep my gigabytes of pdfs in check
21:20:44 <Dreadshoot> heh
21:20:47 <vincenz> Dreadshoot: estas in espagna?
21:21:00 <Dreadshoot> por favor
21:21:09 <vincenz> no?
21:21:24 <vincenz> Dreadshoot: enjoy coding haskell? 
21:21:34 <vincenz> Dreadshoot: and are you good?
21:21:39 <Dreadshoot> got no clue what that just meant, bound sounded like something from spain
21:21:56 <vincenz> Dreadshoot: oh I asked if you were in spain (in really poor spanish)
21:22:07 <Dreadshoot> Sweden
21:22:10 <dropdrive> vincenz: what sorts of PDFs do you have?
21:22:35 <Dreadshoot> I've hardly even looked at haskell actually, i know a few people who use it though. I just code in c++.. well and a little asm
21:22:49 <Dreadshoot> some day when i get the time i might take a look at it though
21:23:12 <vincenz> dropdrive: programming languages, type theory, compiler construction, programming language design, cache optimization, profiling,  dataflow analysis, software design, artificial life, mathematics, people/management stuf..
21:23:16 <vincenz> etc..
21:23:19 <vincenz> and papers I reviewed
21:24:05 <vincenz> Dreadshoot: hmm master student?
21:24:58 <Dreadshoot> naah, i pretty much use programming as a hobby and a compliment to my interest in math
21:25:04 * vincenz snaps his fingers
21:25:12 <vincenz> Was hoping for a master student for next year
21:25:54 <heatsink> in spain?
21:26:10 <Dreadshoot> I'm doing a 3d engine now, im going to simulate a bit of nature in 3d
21:26:18 <vincenz> heatsink: no belgium
21:26:23 <vincenz> heatsink: but my company pays for relocation
21:26:23 <Pseudonym> http://www.regdeveloper.co.uk/2006/06/07/new_jargon/
21:26:28 <the_lord> I have this datatype
21:26:30 <Pseudonym> I especially like "Scalable".
21:27:15 <vincenz> Pseudonym: lol
21:27:54 <the_lord> data Token = somename Int | someother Int | anything (Int, String)
21:28:21 <vincenz> the_lord: dataconstructors need to be capitalized
21:28:39 <the_lord> I need a function like this, Token -> Int, that is, extract the Int of each token
21:28:49 <vincenz> Pseudonym: "a threeple is a crowd" :P
21:29:06 <the_lord> those are not their names anyway
21:29:21 <the_lord> what I need is that function
21:29:23 <vincenz> the_lord: patternmatch
21:29:33 <vincenz> myfunction (SomeName x) = x
21:29:34 <the_lord> vincenz: ?
21:29:37 <vincenz> myfnction (SomeOther x) = x
21:29:42 <vincenz> myfunction (Threepl x) = x
21:29:50 <vincenz> myfunction (Poople (x,y)) = x
21:30:03 <the_lord> there's no other way?
21:30:13 <vincenz> what's wrong with that?
21:30:19 <the_lord> there are like 50 types of tokens
21:30:29 <vincenz> why is the int inside of it then
21:30:30 <vincenz> and not outside
21:30:32 <the_lord> do I have to do it that way?
21:30:37 <heatsink> Pseudonym: lol loose i haet that
21:30:38 <vincenz> myfunction (i,tokoenstuff) = i
21:30:49 <Pseudonym> Mmmm, datum.
21:30:53 * Pseudonym must remember that one
21:31:00 <the_lord> how would you declare the datatype?
21:31:07 <vincenz> Pseudonym: where do you see datum
21:31:30 <Pseudonym> vincenz: See "Tuple".
21:31:39 <Pseudonym> i.e. the one you were reading
21:32:05 <vincenz> Pseudonym: sounds like a dried fruit ;)
21:32:50 <vincenz> the_lord: if all tokens contain this value, then it's pintless to put it inside the tokens
21:33:24 <vincenz> you don't want to know how I do it
21:34:05 <the_lord> vincenz: like this? data Token = Int Token'
21:34:09 <vincenz> no
21:34:25 <vincenz> data Token = foo | fim fam
21:34:32 <vincenz> type ParsedToken = (Int,Token)
21:34:37 <heatsink> mmm, tim tams.
21:34:49 <the_lord> data Token' = somename | someother | anything String
21:34:57 <vincenz> no
21:35:03 <vincenz> keep the original name
21:35:05 <the_lord> no man, I need the names
21:35:10 <vincenz> o.O
21:35:19 <the_lord> vincenz: it's for alex
21:35:23 <vincenz> so?
21:35:27 <vincenz> I use alex and happy
21:35:34 <vincenz> Located Token
21:35:37 <vincenz> is my return type from alex
21:36:06 <the_lord> good, let me se
21:37:00 <vincenz> ?
21:37:00 <the_lord> *see
21:37:09 <vincenz> you mean my code?
21:37:12 <vincenz> it wouldn't help you
21:37:17 <vincenz> I have a separate file with a custom monad
21:37:28 <vincenz> which is shared between parser and lexer
21:39:55 <mathewm> what does it mean for a module listed by 'ghc-pkg list' to be inside parens?
21:40:19 <scodil> does anyone know of a library for haskell that does vector and matrix arithmetic, other than the gsl bindings?
21:40:21 <lispy> mathewm: it's hidden
21:40:40 <lispy> mathewm: ghc-pkg expose <name of package> will unhide it
21:40:49 <Dreadshoot> scodil: that cant take so long do make one yourself though :)
21:40:54 <lispy> mathewm: and ghc-pkg hide <name of package> does the obvious
21:41:05 <mathewm> thanks
21:41:16 <lispy> yw
21:45:09 <vincenz> @hoogle bind
21:45:10 <lambdabot> Network.Socket.bindSocket :: Socket -> SockAddr -> IO ()
21:45:10 <lambdabot> Language.Haskell.TH.bindS :: PatQ -> ExpQ -> StmtQ
21:45:10 <lambdabot> System.Console.Readline.bindKey :: Char -> Callback -> IO ()
21:47:19 <the_lord> If I want to make my token's show function??
21:47:35 <the_lord> what do I do?
21:48:04 <lispy> instance Show MyToken where show t = ...
21:48:17 <lispy> or, data MyToken = MT deriving (Show)
21:50:58 <vincenz> @hoogle ReaderT
21:50:59 <lambdabot> Control.Monad.Reader.ReaderT :: r -> m a -> ReaderT r m a
21:50:59 <lambdabot> Control.Monad.Reader.ReaderT :: newtype ReaderT r m a
21:50:59 <lambdabot> Control.Monad.Reader.mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
21:52:01 <lispy> @hoogle MrT
21:52:01 <lambdabot> No matches found
21:52:04 <lispy> :(
21:52:39 <lispy> type MrT = Fool -> Pitty
21:52:56 <the_lord> lispy: but the second one doesn't allow me to change the show function
21:53:05 <lispy> the_lord: right
21:53:24 <lispy> the_lord: but it's a nice easy way to get a show function when you don't really care what it looks like
21:53:39 <the_lord> lispy: but I do care :(
21:54:07 <lispy> the_lord: then use the 'instance ...' way :)
21:55:29 <the_lord> no i can't, it's a polymorphic type
21:56:59 <skew> if it just has type variables, you can put on a context requiring them to have Show instances
21:57:35 <skew> if it's universally polymorphic, you could force it to some fixed type. Otherwise, it's trickier
21:58:37 <lispy> i personally don't think requiring everything to be an instance of show is a bad thing
21:58:37 <lispy>  
22:02:19 <skew> \quit
22:03:26 <Pseudonym> \ctcp skew send virus.exe
22:03:56 <dons> vixen: ?version
22:03:57 <vixen> lambdabot 3.1p49, GHC 6.5 (OpenBSD i386 )
22:03:58 <vixen> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:04:08 <dons> vixen: ?vixen-on
22:04:08 <vixen> What's this channel about?
22:04:15 <dons> how're you vixen?
22:04:15 <vixen> i am wonderful, thanks for asking!
22:04:19 <dons> cool
22:04:19 <vixen> I don't think it is cool at all!
22:04:21 <dons> nice to chat
22:04:21 <vixen> bad is better than nice ;)
22:04:27 <dons> true
22:04:28 <vixen> too many perverts send out sick pictures of themselves. what type of man does that?
22:04:35 <Pseudonym> vixen: ?eval "foo"
22:04:36 <dons> yeah, i don't know.
22:04:36 <vixen> then find out! :)
22:04:43 <Pseudonym> > "foo"
22:04:43 <lambdabot>  "foo"
22:04:50 <Pseudonym> OK, vixen doesn't respond to that.
22:04:51 <vixen>   Failed to load interface for `ShowQ':
22:04:52 <vixen>    Could not find module `Show...
22:04:52 <vixen> where on a map is Panama?
22:04:52 <vixen> i am a bit of a vixen :)
22:05:04 <Pseudonym> Erm...
22:05:04 <vixen> so, what do you think of me?
22:05:05 <dons> vixen: ?vixen-off
22:05:06 <vixen> Bye!
22:05:15 <dons> just testing a new contextual plugin framework
22:05:35 <dons> you can write a contextual handler in a plugin, and it'll respond without an explicit command
22:05:45 <dons> so, we could write megamonad or a vixen this way, as you saw
22:05:50 <dons> but maybe there's some practical uses too
22:05:53 <dons> like inline commands
22:05:57 <dons> or printing url headings
22:06:06 <dons> also, you just saw vixen _running on top of ghci_
22:06:13 <dons> which it hsan't been able to do for about 3 years
22:06:31 <dons> vixen, ?vixen all good?
22:06:32 <vixen> good? not great?
22:06:37 <dons> vixen, ?quit
22:07:12 <dons> any thoughts on what we can do with contextual plugins?
22:07:17 <dons> besides megamonad...
22:12:10 <mathewm> how do you read this 'class ToElement x where toElement::x->Types.Element
22:12:36 <mathewm> ::x->Types.Element is the type of toElement?
22:12:43 <dons> yep
22:12:46 <dons> badly formatted
22:13:00 <dons> ?pretty class ToElement x where  toElement::x->Types.Element
22:13:00 <lambdabot>  class ToElement x where
22:13:00 <lambdabot>    toElement :: x -> Types.Element
22:13:22 <dons> good bot
22:15:40 <vincenz> is it possible to make a method non visible?
22:18:45 <vincenz> @pretty a -> b -> c
22:18:45 <lambdabot> "Parse error" at column 3
22:18:57 <vincenz> dons: how does that pretty thing work?
22:19:24 <dons> it parses the code, and prints it
22:19:36 <dons> needs to be something top level though, so classes, types or decls, iirc
22:19:43 <dons> ?pretty data X = X | Y
22:19:43 <lambdabot>  data X = X
22:19:43 <lambdabot>    | Y
22:19:51 <dons> oh, except i broke the formatting
22:19:59 <dons> i should convert those tabs back to spaces
22:20:14 <vincenz> dons: how does it pretin
22:20:18 <vincenz> print
22:20:19 <dons> ?pretty module M where x = undefined
22:20:19 <lambdabot> "Parse error" at column 1
22:20:40 <int-e> ?pretty please with = sugar on top
22:20:41 <lambdabot>  please with = sugar on top
22:20:44 <dons> it walks the abstract syntax tree, using pretty printing combinators to generate printing functions
22:20:54 <dons> that are then applied, generating a list of lines
22:20:59 <dons> normal way
22:21:00 <vincenz> dons: right and where are those pretty printing things written?
22:21:02 <dons> s/^/the/
22:21:04 <vincenz> I need pretty printing
22:21:22 <dons> in the Text.PrettyPrint.HughesPJ, iirc
22:21:25 <dons> ?hoogle Pretty
22:21:25 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
22:21:25 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
22:21:28 <vincenz> ah dan
22:21:28 <vincenz> damn
22:21:39 <dons> ?index Text.PrettyPrint
22:21:39 <lambdabot> bzzt
22:21:46 <dons> ?docs Text.Pretty
22:21:46 <lambdabot> Text.Pretty not available
22:21:49 <dons> ?docs Text.PrettyPrint
22:21:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint.html
22:21:51 <dons> ah
22:23:30 * vincenz smiles at his cleaned code \o/
22:23:49 <vincenz> my typechecker is much nicer
22:26:08 <vincenz> @type liftM2
22:26:09 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:33:40 <the_lord> @hoogle zip
22:33:41 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
22:33:41 <lambdabot> List.zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
22:33:41 <lambdabot> List.zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
22:34:34 <the_lord> @hoogle [a] -> [a] -> [a]
22:34:35 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
22:34:35 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:34:35 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:34:56 <the_lord> @hoogle ([a],[a]) -> [a]
22:34:56 <lambdabot> No matches, try a more general search
22:34:59 <vincenz> the_lord: making a compiler?
22:35:11 <the_lord> vincenz: yes, first time
22:35:19 <vincenz> for what language?
22:35:22 * vincenz is working on one too
22:35:25 <the_lord> invented one
22:35:35 * the_lord has an assignment
22:35:36 <vincenz> well what's it like?
22:35:56 <the_lord> it's an interpreter, not a compiler of a turing machine
22:36:15 <vincenz> well mine is an interpreter too
22:36:29 <vincenz> lex, parse, module import, binding variables, typechecking, and then interpreting
22:37:04 <the_lord> I want a function that does this, f [1,2,3] [4,5,6] -> [1,4,2,5,3,6]
22:37:11 <the_lord> how do I do that?
22:37:25 <vincenz> ++
22:37:31 <vincenz> o
22:37:33 <vincenz> sorry
22:37:36 <vincenz> I misread that
22:37:58 <vincenz> > concat . sequence $ zip [1,2,3] [4,5,6]
22:37:58 <lambdabot>  Couldn't match `[a]' against `(a1, b)'
22:38:20 <vincenz> > concat . sequence $ map (\x y -> x:y:[]) [1,2,3] [4,5,6]
22:38:21 <lambdabot>  Couldn't match `[b]' against `t -> t1'
22:38:23 <vincenz> hmm
22:38:28 <the_lord> @hoogle sequence
22:38:28 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
22:38:28 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
22:38:28 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
22:38:44 <vincenz> > sequence [[1,2,3],[4,5,6]]
22:38:45 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
22:38:47 <vincenz> nope
22:38:48 <dons> lambdabot hackers, ghci loading lambdabot: http://www.cse.unsw.edu.au/~dons/tmp/lambdabot_in_ghci
22:39:11 <vincenz> > concat $ zipWith (\x y -> x:y:[]) [1..3] [4..5]
22:39:12 <lambdabot>  [1,4,2,5]
22:39:16 <vincenz> > concat $ zipWith (\x y -> x:y:[]) [1..3] [4..6]
22:39:16 <lambdabot>  [1,4,2,5,3,6]
22:39:27 <vincenz> > concat $ zipWith (\x y -> [x,y]) [1..3] [4..6]
22:39:28 <lambdabot>  [1,4,2,5,3,6]
22:39:36 <vincenz> @hoogle interleave
22:39:37 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
22:39:37 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
22:40:02 <the_lord> vincenz thx
22:40:05 <vincenz> @pl (\x y -> [x,y])
22:40:05 <lambdabot> (. return) . (:)
22:40:14 <vincenz> > concat $ zipWith ((. return) . (:)) [1..3] [4..6]
22:40:15 <lambdabot>  [1,4,2,5,3,6]
22:40:29 <vincenz> > concat $ zipWith ((. (:[])) . (:)) [1..3] [4..6]
22:40:31 <lambdabot>  [1,4,2,5,3,6]
22:40:54 <vincenz> @pl (\(x,y) -> [x,y])
22:40:55 <lambdabot> uncurry ((. return) . (:))
22:40:58 <vincenz> hmm
22:41:05 * vincenz is off to nap
22:41:14 <vincenz> the_lord: if you want I can help you a bit later if you have particular questions
22:41:30 <dons> @quit exercising the new context handling code
22:41:49 <the_lord> vincenz: thx a lot
22:41:54 <dons> ?version
22:41:57 * vincenz detaches
22:42:06 <vincenz> @bot
22:42:06 <oasisbot> :)
22:42:18 <vincenz> @version
22:42:18 <oasisbot> lambdabot 3.1p40, GHC 6.4.1 (Linux i686 1700+)
22:42:18 <oasisbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:42:20 <lambdabot> lambdabot 3.1p52, GHC 6.4.1 (Linux i686 3.20GHz)
22:42:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:42:26 <vincenz> @part
22:42:26 <lambdabot> :)
22:42:28 <lambdabot> lambdabot 3.1p52, GHC 6.4.1 (Linux i686 3.20GHz)
22:42:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:42:30 <vincenz> @part #haskell 
22:42:32 <lambdabot> Not enough privileges
22:42:34 <lambdabot> Not enough privileges
22:42:46 <dons> test..
22:42:49 <vincenz> dons: how do you get the 3.1p52
22:42:56 <dons> run ./configure
22:42:57 <vincenz> I wouldn't mind versions on my compiler
22:43:03 <the_lord> > concat ( zipWith (\x y -> x:y:[]) [1..3] [4..5])
22:43:04 <lambdabot>  [1,4,2,5]
22:43:07 <vincenz> no, how do you construct it
22:43:12 <dons> oh, check configure.ac
22:43:16 <dons> its grabbed from the darcs repo
22:43:41 <vincenz> dons: and ow is the 3.1 bit made?
22:44:31 <dons> that's in Version.hs
22:44:35 <dons> i think, or else config.mk
22:44:48 <dons> it could be taken from the darcs tag count though
22:45:20 <the_lord> @hoogle foldl
22:45:21 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
22:45:21 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
22:45:21 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
22:45:24 <vincenz> why the sed / *
22:45:26 <vincenz> it seems not needed
22:46:26 <dons> strip trailing whitespace
22:46:30 <vincenz> ah
22:46:31 <dons> i guess i needed it at some point
22:46:41 <vincenz> I was thinking initial that's why I wondered
22:46:43 <dons> not trailing, leading whitespace
22:46:48 <dons> since wc -l prints a stupid indent
22:47:00 <vincenz> not on my sys
22:47:07 <vincenz> vincenz@abstractserver:~$ ls | wc -l
22:47:11 <vincenz> 18
22:47:19 <dons> which is best, i ask you:
22:47:20 <dons> $ wc -l lambdabot/Lambdabot.hs
22:47:20 <dons>      771 lambdabot/Lambdabot.hs
22:47:20 <dons> $ length lambdabot/Lambdabot.hs
22:47:21 <dons> 771
22:47:39 <dons> $ length -h       
22:47:39 <dons> Usage: "length" [OPTION...] [file..]
22:47:39 <dons>   -V  --version  version string
22:47:39 <dons>   -h  --help     help
22:47:39 <dons> length :: [a] -> Int
22:47:42 <dons> length returns the length of a finite list as an Int.
22:47:44 <dons> ;)
22:47:48 <vincenz> :D
22:48:02 * cpatrick grins
22:48:13 <vincenz> cat length
22:48:23 <cpatrick> Sounds like we need a haskell shell
22:48:28 <dons> no, cat is id, in h4sh
22:48:53 <dons> ?where h4sh
22:48:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
22:49:15 <vincenz> getContents >>= \x -> length . filter (== '\n') >>= \x -> x+1 >> print
22:49:20 <vincenz> dons: that it?
22:49:26 <vincenz> erm add a return
22:49:31 <dons> vincenz: roughly
22:49:33 <dons> check the src
22:49:48 <cpatrick> dons: *fear*
22:50:06 <dons> $ I -h
22:50:06 <dons> Usage: "i" [OPTION...] [file..]
22:50:06 <dons>   -V  --version  version string
22:50:06 <dons>   -h  --help     help
22:50:06 <dons> id :: a -> a
22:50:08 <dons> Identity function.
22:50:10 <vincenz> dons: where is the source?
22:50:11 <dons> for example, is cat.
22:50:16 <dons> ?where h4sh
22:50:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
22:50:23 <vincenz> erm
22:50:23 <vincenz> no?
22:50:27 <dons> I guess google could find it
22:50:31 <dons> ?google h4sh _darcs
22:50:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/h4sh/_darcs/
22:50:36 <dons> there
22:50:47 <vincenz> again no?
22:50:57 <vincenz> there is no length.hs
22:51:01 <dons> all the commands are generated from their type.
22:51:09 <vincenz> djinn?
22:51:11 <dons> no no
22:51:24 <dons> there's no length.hs, since that file is generated when you build the system
22:51:29 <vincenz> aha
22:51:33 <dons> look at Command.hs for the stub
22:51:39 <vincenz> how do you generate commands from type?
22:52:00 <dons> you inspect the type, and generate a different io and argument wrapper/handler based on the number of args and their type
22:52:08 <cpatrick> @djinn [a] -> Int
22:52:09 <lambdabot> -- f cannot be realized.
22:52:13 <cpatrick> awww
22:52:17 <vincenz> and the actual command?
22:52:20 <vincenz> I mean haskell code
22:52:25 <dons> for example, :
22:52:26 <dons> doRawArgs (LS `To` (LS `To` LS))         = readFileArgandRawFileOrStdin
22:52:27 <dons> doRawArgs (S  `To` (LS `To` _))          = readArgAndRawFileOrStdin
22:52:27 <dons> doRawArgs (I  `To` (LS `To` _))          = readNumberAndRawFileOrStdin
22:52:39 <dons> so depending on the type, it'll readfiles or readArgs and so on.
22:52:43 <vincenz> and the actual code?
22:52:50 <dons> check the src in Build.hs
22:53:01 <dons> readFromFileOrStdin = unlines
22:53:01 <dons>   [ " input <- if null fs"
22:53:01 <dons>   , "          then getContents"
22:53:01 <dons>   , "          else liftM concat $ mapM readFile fs"
22:53:01 <dons>   ]
22:53:03 <dons> for example
22:53:35 <dons> so all the different functions behave in a uniform manner
22:53:35 <vincenz> yes but running the actual "length
22:53:49 <dons> i don't understand your question
22:53:53 <vincenz> oh I see
22:53:55 <vincenz> hs-plugins
22:54:02 <dons> the build system generates length.hs from a template, and compiles it to a binary
22:54:03 <vincenz> it's the string param
22:54:08 <dons> no no.
22:54:11 <vincenz> "length"
22:54:14 <vincenz> is the haskell function that is called
22:54:22 <dons> no, that's a template. 
22:54:34 <vincenz> , Command "repeat"  "rpt"
22:54:38 <dons> hs-plugins is used, but only to eval arguments to the map or ap or similar functions
22:54:42 <vincenz> first string = haskell code to put into the template
22:54:50 <dons> so you can say: $ map 'map toUpper'  < f
22:55:01 <dons> yep, and snd is the command name
22:55:08 <dons> sometimes they have to be different to avoid clashes
22:55:17 <dons> ie. .with 'find' or 'zip'
22:55:37 <vincenz> okies :)
22:55:43 <vincenz> nice :)
22:55:46 <vincenz> anyways
22:55:53 <vincenz> I have to crash, thanks for the interesting overview :)
22:56:34 <dons> oh, and the src is on the web page. look harder! ;
22:56:36 <dons> )
22:56:40 <vincenz> I'm tired
22:56:51 <vincenz> my context-grabbing is reduced
22:56:57 <dons> hehe
22:57:15 <vincenz> cya!
22:57:20 <vincenz> and think of a nifty name for a proglang
22:57:43 <vincenz> @google mlivr
22:57:45 <lambdabot> http://fr.moneycentral.msn.com/investor/quotes/quotes.asp?Symbol=FR:MLIVR
22:57:53 <vincenz> @google ivrml
22:57:55 <lambdabot> http://www.allesdurcheinander.de/ivv/
22:57:57 <vincenz> hmm
22:58:15 <the_lord> @hoogle intersperse
22:58:15 <lambdabot> List.intersperse :: a -> [a] -> [a]
23:59:43 * shapr yodels quietly
23:59:49 <shapr> Good morning #haskell!
23:59:54 <shapr> How's all that code today?
