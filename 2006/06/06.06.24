00:15:06 <prizman> ?help
00:15:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:15:12 <prizman> ?list
00:15:13 <lambdabot> list [module|command]. Where modules is one of:
00:15:13 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
00:15:13 <lambdabot> topic type unlambda url version vixen where
00:15:55 <prizman> ?version
00:15:55 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
00:15:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:16:07 <prizman> ?uname 
00:16:07 <lambdabot> Unknown command, try @list
00:16:09 <prizman> :)
00:16:11 <prizman> hi all
00:16:40 <dcoutts> @seen dons
00:16:40 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 1 hour, 2 minutes and 26 seconds ago.
00:16:45 <dcoutts> dons, ping
00:16:48 <dons> hey prizman
00:16:48 <dons> hey dcoutts
00:16:53 <dcoutts> hi dons 
00:17:01 <dons> how's the south of france?
00:17:04 <dcoutts> I'm off to France for a week :-)
00:17:10 <dcoutts> leaving in an hour
00:17:56 <dcoutts> dons, are you likely to work on the streams fusion this week?
00:21:01 <dons> maybe a little. another project (this chem/polymer/graphic stuff) as come up. but i'd like to try to duplicate the streams stuff.
00:22:41 <dons> so i'll try to get that done this week, at least
00:22:44 <dons> using the tarball you setn me?
00:28:11 <dons> yeah, so i'll be looking to experiment with the streams stuff you sent me.
00:30:38 <dcoutts> dons, yep the tarball
00:30:45 <dcoutts> since my box will be off
00:31:24 <dcoutts> dons, main thing I think is to see if it's running at least as fast
00:31:41 <dons> ok.
00:32:58 <dons> ok, so i'll try to get it running with our bench suite.
00:52:11 <xerox> Ahoy mateys!
00:53:11 <dons> Ahoy there, Capn Xerox!
00:54:18 <xerox> Yarr dons, you son of a gun!
01:18:49 <dons> kosmikus, pong?
03:34:02 <dmhouse> Morning channel.
03:34:03 <lambdabot> dmhouse: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:34:09 <xerox> Morning you.
03:46:19 <dmhouse> What advantages does a Data.Map have over [(a, b)]?
03:46:28 <dmhouse> I've got 1) more library functions 2) speed. Anything else?
03:47:00 <dons> faster
03:47:03 <int-e> better space efficiency
03:47:07 <dons> larger api 
03:47:07 <dons> :)
03:47:18 <dmhouse> dons: faster == speed. larger api == more library functions
03:47:24 <dons> hence :)
03:47:26 <dons> :)
03:47:30 <int-e> (if we keep many versions with little differences around)
03:47:35 <dmhouse> int-e: Right.
03:50:37 <dmhouse> Hmm. Can you call 'main'? I.e. does main work just like any other function? It would save having a seperate main and mainLoop.
03:50:49 <xerox> Yup.
03:50:57 <dmhouse> Great.
03:52:34 <dons> sure. its just a function.
03:53:03 <dmhouse> Well there is some degree of specialness associated with it. I was wondering how much.
03:53:06 <dons> i wrote this today: main = handle (\_ -> main) $ do ...
03:53:17 <dons> coincidently
03:53:27 <dons> which is the dual of incidently
03:54:06 <johnnowak> hehe
03:55:08 <xerox> main = handle (const main) $ do
03:58:11 <dons> ?type (\(/\/\/\)->(/\/\/\))
03:58:12 <lambdabot> forall t. t -> t
03:58:44 <dmhouse> @type (/\/\/\)
03:58:45 <lambdabot> Not in scope: `/\/\/\'
03:59:07 <dmhouse> dons, just it just assume such a datatype exists, or something?
03:59:19 <dons> no, its just a variabe le name
03:59:21 <dons> but a fun one
03:59:39 <dons> i was trying to write \_\_ -> main
03:59:40 <dons> but you can't mix _ with symbols, iirc
04:00:16 * dmhouse uses C-x n n usefully for the first time ever
04:03:21 <Cale> what is that?
04:03:49 <dmhouse> (Emacs.) narrow-to-region. It essentially restricts the viewport to whatever's in the region.
04:04:17 <Cale> ah
04:04:25 <dmhouse> I'm writing a module for the Wikibook and I wanted to include an example. It was a pain writing haskell not in haskell-mode, so I C-x n n'd and then turned on haskell-mode.
04:04:33 <Cale> (I'd figured it was emacs, as no other program has key sequences like that)
04:10:57 <dmhouse> You know what would be great? If haskell-mode automagically turned on auto-fill-mode when you started typing a comment.
04:22:13 <dmhouse> Grr. Amazon is being uncharacteristically slow in delivery.
04:23:09 <lscd> same
04:23:13 <lscd> i ordered some books on the 5th
04:23:19 <defcon8> whoah
04:23:19 <lscd> they were supposed to dispatch within 24 hours
04:23:30 <lscd> the earliest estimated dispatch is the 4th of next month
04:23:31 <defcon8> my amazon comes way faster than that and i order from america to turkey1
04:23:40 <lscd> latest estimated one was the 18th of next month
04:23:41 <defcon8> lscd, comes way before the est date
04:23:41 <lscd> it's absurd
04:23:44 <defcon8> they come in like 9 days
04:23:52 <lscd> defcon8: my order before this came really quickly
04:24:01 <lscd> but this one was estimated to dispatch in 24 hours
04:24:07 <lscd> and amazon is now saying a MONTH
04:24:38 <defcon8> lol
04:24:39 <defcon8> sue them
04:24:41 <dmhouse> Ah, it seems they only dispatched yesterday. Should be okay then. :)
04:24:45 <lscd> i generally order from the usa or uk (and occasionally germany) to switzerland
04:25:02 <lscd> dmhouse: pfft. at least they're dispatching your books :D
04:25:03 <defcon8> uk is more expensive than us
04:25:04 <defcon8> seriously
04:25:08 <lscd> depends
04:25:14 <lscd> i compare the prices
04:25:18 <lscd> shipping is cheaper to me from the uk
04:25:32 <lscd> and my last batch of haskell books (the ones that are taking forever) were actually significantly cheaper from the uk
04:25:44 <defcon8> yeah but sometimes uk amazon is absurdly more expensive than us amazon
04:25:47 <lscd> whether the uk or us is cheaper isn't a given these days
04:25:51 <lscd> yes; and sometimes vice versa
04:26:01 <defcon8> well you check the prices i guess
04:26:02 <lscd> in general, the usa one has clasically been cheaper; but this seems to be changing
04:26:44 <defcon8> i guess with the dollar
04:26:51 <lscd> that's likely a factor
04:33:47 <dmhouse> @type foldr
04:33:48 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
04:36:17 <totu> hello, haskell noob here. im trying to make a function using partition to segregate list into lists, something like ...  [(a -> Bool)] -> [a] -> [[a]]this om ... but i cant to figure it out. all i want is for something like ... seg [isOne,isTwo,isThree] "abc1211333" ... to give this ... ["111","2","333","abc"]
04:37:17 <Cale> totu: you might be interested in Data.List.partition
04:37:46 <dmhouse> Cale, he said 'using partition'.
04:38:10 <Cale> oh
04:38:12 <dmhouse> totu, I think filter would do you well.
04:38:13 <Cale> yes
04:38:13 <totu> i tried reading the source but i cant seem to understand it
04:38:22 <totu> =)
04:38:37 <dmhouse> totu, filter will likely be a better function than partition in this case.
04:38:44 <Cale> partition takes a predicate and a list and returns a pair of lists -- those that match the predicate and those which don't
04:38:51 <Cale> no, partition is perfect
04:39:02 <Cale> partition just wraps filter anyway
04:39:14 <dmhouse> Hrm, I suppose you could do it with partition and unfoldr.
04:39:45 <totu> im trying to get the right part of the tuple to recursivly call it but the compiler errors are scaring me
04:39:55 <dmhouse> totu, well, what have you got so far?
04:41:27 <Cale> use let or where to pattern match the result of partition
04:42:09 <Cale> and return the first part consed to the recursive case on the second part
04:43:57 <totu> ic... will try to do that. im in a pc without hugs now. i guess i should have downloaded it first before asking.
04:44:13 <totu> anyways, thanks guys, im now taking notes =)
04:44:20 <int-e> they're lists, not tuples, btw.
04:44:39 <dmhouse> totu, what are? partition returns a pair.
04:44:59 <int-e> dmhouse: this is not about partition
04:45:26 <dmhouse> int-e, sure it is. He's recursing with partition.
04:45:48 <int-e> hmm. oh, I read it wrong.
04:45:51 <int-e> sorry.
04:46:05 <norpan> partition is the one to use
04:46:17 * int-e buries his solution with map and filter (and two flips)
04:46:17 <bolrod> @type partition
04:46:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:46:36 <dmhouse> int-e, partition and unfoldr :)
04:46:43 <int-e> dmhouse: I saw that.
04:47:20 <norpan> seg [] xs = [xs]; seg (f:fs) xs = let (a,b) = partition f xs in a:seg fs b
04:47:23 <norpan> or similar
04:47:43 <norpan> didn't check it though
04:49:39 <dmhouse> Yeah, that's what I'd do
04:50:45 <totu> norpan: finished dlling hugs and this worked! thanks!
04:51:03 <norpan> great
04:51:25 <norpan> the thing many people miss is that the base case is [xs]
04:51:33 <norpan> and then you'll get type errors from hell
04:52:15 <totu> i even made a function that makes (a,b) into [a,b]
04:52:33 <totu> i guess it will take more time for me to learn all of this
04:52:40 <totu> hehe, thanks again =)
04:55:03 <cjay> morning
04:55:36 <cjay> is there a script for vim that does the indentation right in do-blocks?
04:56:04 <dmhouse> unfoldr actually gets ugly because you have to thread the predicates through too.l
04:56:10 <dmhouse> s/l$//
04:56:19 <dmhouse> > let split ([], xs) = Nothing; split (p:ps, xs) = let (t, f) = partition p xs in Just (t, (ps, xs)) in unfoldr split ([(=='1'), (=='2'), (=='3')], "abc123abc123")
04:56:20 <lambdabot>  ["11","22","33"]
04:56:30 <dmhouse> That's the best I got, which doesn't even work properly :)
04:57:23 <Cale> unfoldr is usually unwieldy
04:57:36 <norpan> unfoldr is one function i rarely use
04:57:52 <dmhouse> It can work well.
04:58:19 <totu> wow... this place is a great place for noobs. nice examples :) 
04:58:21 <Cale> It's nice theoretically, but most of the decent uses of it can be replaced with iterate and takeWhile and be a lot clearer
04:59:06 <norpan> my advice is to write simple recursion until you yourself realize that there could be a pattern here :)
04:59:46 <dmhouse> Yeah, I tend to always go with the f [] = ... f (x:xs) = ..., then think about niceness later.
04:59:53 <dmhouse> Unless it's an obvious map or fold, that is.
05:00:22 <norpan> or list comprehension
05:01:24 <Cale> I'll often check foldr first
05:01:58 <Cale> but yeah, going down to the level of recursion is often the best way to start
05:03:13 <bolrod> > let seg ps list = zipWith ($) (map (\p list-> [x|x<-list , p])) (repeat list) in seg ([==1,==2]) [1,2,3,4]
05:03:13 <lambdabot>  Parse error
05:03:41 <dmhouse> That's a TH thing, I think.
05:03:53 <Cale> yeah
05:03:55 <dmhouse> > let seg ps list = zipWith ($) (map (\p list-> [ x | x <- list, p])) (repeat list) in seg ([==1,==2]) [1,2,3,4]
05:03:56 <lambdabot>  Parse error
05:04:11 <Cale> okay...
05:04:19 <lightstep> you need ==x in parens, so it will be section syntax
05:04:27 <Cale> right
05:04:29 <dmhouse> > let seg ps list = zipWith ($) (map (\p list -> [ x | x <- list, p])) (repeat list) in seg ([(==1),(==2)]) [1,2,3,4]
05:04:30 <lambdabot>    Expecting a function type, but found `[a]'
05:04:30 <lambdabot>    Expected type: [b1 -> b...
05:04:34 <dmhouse> There we go.
05:04:44 <Cale> now it's just a type error :)
05:04:57 <bolrod> > let seg ps list = zipWith ($) (map (\list p -> [ x | x <- list, p])) (repeat list) in seg ([(==1),(==2)]) [1,2,3,4]
05:04:57 <lambdabot>    Expecting a function type, but found `[a]'
05:04:58 <lambdabot>    Expected type: [b1 -> b...
05:05:05 <lightstep> you want p x in the comprehension, not p
05:05:16 <bolrod> > let seg ps list = zipWith ($) (map (\p list -> [ x | x <- list, p x])) (repeat list) in seg ([(==1),(==2)]) [1,2,3,4]
05:05:17 <lambdabot>    Expecting a function type, but found `[a]'
05:05:18 <lambdabot>    Expected type: [b1 -> b...
05:05:23 <dmhouse> Surely [ x | x <- list, p x ] = filter p list?
05:05:25 <bolrod> wel... whatever  :p
05:05:50 <bolrod> ;)
05:05:54 <dmhouse> > let seg ps list = zipWith ($) (map filter ps) (repeat list) in seg ([(==1),(==2)]) [1,2,3,4]
05:05:55 <lambdabot>  [[1],[2]]
05:06:20 <norpan> doesn't do it you also need to filter away the matches from the rest of the lists
05:06:32 <norpan> that's why partition is handy
05:07:02 <bolrod> depends if you want that or not
05:07:07 <dmhouse> > let seg ps list = zipWith ($) (map filter [ps, not . and ps) (repeat list) in seg ([(==1),(==2)]) [1,2,3,4]
05:07:08 <lambdabot>  Parse error
05:07:14 <dmhouse> > let seg ps list = zipWith ($) (map filter [ps, not . and ps]) (repeat list) in seg ([(==1),(==2)]) [1,2,3,4]
05:07:14 <lambdabot>    Expecting a function type, but found `Bool'
05:07:15 <lambdabot>    Expected type: a -> Bo...
05:07:24 <norpan> well, that was the original problem so i suppose you want that
05:07:24 <dmhouse> Oh, oops.
05:07:26 <xerox> and ps ?
05:07:41 <dmhouse> > let seg ps list = zipWith ($) (map filter $ (not . and ps) : ps) (repeat list) in seg ([(==1),(==2)]) [1,2,3,4]
05:07:42 <lambdabot>    Expecting a function type, but found `Bool'
05:07:42 <lambdabot>    Expected type: a -> Bo...
05:07:53 <dmhouse> @type and
05:07:54 <lambdabot> [Bool] -> Bool
05:08:01 <norpan> otherwize it's just zipWith filter fs (repeat xs)
05:08:01 <dmhouse> Ah.
05:08:14 <xerox> @type any
05:08:15 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:08:16 <dmhouse> > let seg ps list = zipWith ($) (map filter $ (not . any ps) : ps) (repeat list) in seg ([(==1),(==2)]) [1,2,3,4]
05:08:17 <lambdabot>  Couldn't match `[[a] -> Bool]' against `a -> Bool'
05:08:36 <xerox> What do you want to do?
05:08:41 <norpan> > zipWith filter [(==1),(==2)] (repeat [1,2,3,4])
05:08:42 <lambdabot>  [[1],[2]]
05:09:00 <norpan> but as i said, you want to remove the matches too
05:09:01 <dmhouse> That's neater.
05:09:12 <xerox> ?type zipWith filter
05:09:14 <lambdabot> forall a. [a -> Bool] -> [[a]] -> [[a]]
05:09:46 <xerox> ?type zipWith ((length .) . filter)
05:09:47 <lambdabot> forall a. [a -> Bool] -> [[a]] -> [Int]
05:10:33 <norpan> the practical haskeller is satisfied with the simple recursion solution though
05:10:35 <int-e> @type flip (map . flip filter)
05:10:37 <lambdabot> forall a. [a -> Bool] -> [a] -> [[a]]
05:10:46 <norpan> this is not obviously fitting a general pattern
05:12:33 <norpan> the theoretical haskeller ends up writing yet another paper
05:15:07 <dmhouse> > let swing f c a = (f ($ a)) c; seg ps xs = zipWith filter ((not . swing any ps) : ps) (repeat xs) in seg [(==1), (==2)] [1..4]
05:15:08 <lambdabot>  [[3,4],[1],[2]]
05:15:36 <dmhouse> > let swing f c a = (f ($ a)) c; seg ps xs = zipWith filter (ps ++ [not . swing any ps]) (repeat xs) in seg [(==1), (==2)] [1..4]
05:15:37 <lambdabot>  [[1],[2],[3,4]]
05:16:01 <xerox> !
05:16:10 <bolrod> Â¡
05:16:17 <dmhouse> 'not . swing any ps' is the predicate such that all of the ps are false.
05:16:58 <xerox> not . any predicate ?
05:17:11 <dmhouse> @type (not .) . any
05:17:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:17:23 <dmhouse> We have a list of predicates, not a single one.
05:17:26 <xerox> I see.
05:17:30 <dmhouse> So you swing it. :)
05:17:34 <xerox> hehe.
05:18:40 <int-e> > (curry (unfoldr (\(f,r) -> if null f then Nothing else Just . second ((,) (tail f)) $ partition (head f) r)) . (++[const True])) [(>2), (<4)] [1..5]
05:18:41 <lambdabot>  [[3,4,5],[1,2],[]]
05:19:00 <dmhouse> Ah, that's how you do tuple sections.
05:19:29 <dmhouse> I was thinking along those lines, but it just ended up being ugly :)
05:19:41 <int-e> me too.
05:19:43 <int-e> ;)
05:20:16 <dmhouse> I think we should have a '#haskell Alogrithm Tennis Archive'.
05:20:32 <int-e> #haskell-snippets ?
05:20:37 <int-e> oh
05:20:42 <int-e> a wiki page you mean
05:20:46 <dmhouse> Yeah.
05:20:56 <lightstep> haskell golf
05:21:01 <bolrod> :)
05:21:24 <bolrod> where was that page with contributed code to the wiki or something
05:21:38 <int-e> actually it's more like 'how many of the rarely used higher order functions can you fit on one line' :)
05:22:29 <dmhouse> :)
05:22:35 <int-e> curry for example - how often do you actually use it?
05:22:41 <dmhouse> @type curry
05:22:41 <totu> guys, its been great just lurking in this chan. the examples here just made my day. =) ive learned a lot here. thanks everyone! gtg. =)
05:22:42 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
05:23:00 <dmhouse> I use uncurry semi-frequently, but I can't say I've ever used curry.
05:23:17 <Cale> bonus points for using zipWithM with the (e->) monad
05:23:30 <int-e> @type zipWithM
05:23:31 <dmhouse> Hah. :)
05:23:32 <lambdabot> forall c (m :: * -> *) b a. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
05:23:49 <dmhouse> So it'd be (a -> b -> c -> d) -> [a] -> [b] -> d -> [c]
05:23:56 <Cale> or even better, mapAndUnzipM
05:24:01 <Cale> nobody uses that
05:24:06 <dmhouse> @type mapAndUnzipM
05:24:07 <lambdabot> forall c b (m :: * -> *) a. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
05:24:20 <int-e> shiny.
05:24:28 <dmhouse> (a -> d -> (m, c)) -> [a] -> d -> ([b], [c])
05:24:44 <dmhouse> s/m/b/
05:25:34 <dmhouse> > mapAndUnzipM (,) [1..4] 5
05:25:36 <lambdabot>  ([1,2,3,4],[5,5,5,5])
05:25:44 <dmhouse> Wow, how incredibly pointless.
05:26:12 <Cale> haha
05:27:54 <dmhouse> > mapAndUnzipM (\x y -> (x, x*y)) [1..4] 5
05:27:55 <lambdabot>  ([1,2,3,4],[5,10,15,20])
05:28:32 <bolrod> that's so cool!
05:28:37 <bolrod> what would you use it for though?
05:29:26 <int-e> @type unzipM
05:29:27 <lambdabot> Not in scope: `unzipM'
05:29:32 <int-e> hmm.
05:29:39 <dmhouse> > mapAndUnzipM (curry (fst &&& uncurry (*))) [1..4] 5
05:29:40 <lambdabot>  ([1,2,3,4],[5,10,15,20])
05:29:51 <dmhouse> There you go, I used curry.
05:31:31 <int-e> @type liftA2
05:31:32 <lambdabot> Not in scope: `liftA2'
05:31:43 <int-e> @type liftM2 (*)
05:31:44 <lambdabot> forall a2 (m :: * -> *). (Monad m, Num a2) => m a2 -> m a2 -> m a2
05:31:54 <lightstep> @type Control.Arrow.liftA2
05:31:55 <lambdabot> Not in scope: `Control.Arrow.liftA2'
05:32:03 <xerox> ?index liftA2
05:32:03 <lambdabot> bzzt
05:32:08 <xerox> ?hoogle liftA2
05:32:08 <lambdabot> No matches found
05:32:11 <xerox> ?hoogle liftA
05:32:12 <lambdabot> No matches found
05:32:16 <xerox> Hrmpf.
05:32:25 <int-e> @type pure
05:32:27 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
05:32:39 <xerox> ?type arr
05:32:41 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
05:32:43 <dmhouse> @type returnA
05:32:44 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
05:32:46 <bolrod> @index liftM2
05:32:47 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:33:01 <lightstep> there's no sense in liftA*
05:33:04 <dmhouse> @pl \x y -> (x, x*y)
05:33:05 <lambdabot> liftM2 (.) (,) (*)
05:33:10 <dmhouse> Ooh, pretty.
05:33:14 <lightstep> only with arrow transformers
05:33:24 <dmhouse> I'm sure there's a cute arrowic way of doing it, though.
05:34:56 <xerox> lightstep - There is sense in liftA* !
05:35:35 <lightstep> howcomes? you have pure
05:35:39 <lightstep> and app
05:35:47 <xerox> Hughes paper says `likewise we can do liftM*, we must be able to do liftA*' and then gives the definition :)
05:36:01 <lightstep> oh
05:36:40 <lightstep> then it must be useful :)
05:36:51 <Cale> hehe, arrowic
05:36:51 * xerox snickers
05:37:34 <int-e> @type get >>= \(x, xs) -> put xs >> return x
05:37:35 <lambdabot> 1:0-2
05:37:45 <xerox> EEEEK
05:37:47 <int-e> lambdabot: what?
05:38:00 <bolrod> O_O
05:38:03 <xerox> ?type get >>= \(x,xs) -> put xs >> return x
05:38:05 <lambdabot> 1:0-2
05:38:10 <bolrod> what the...
05:38:34 <bolrod> @type get
05:38:35 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
05:38:38 <int-e> @type get >>= \(x:xs) -> put xs >> return x
05:38:40 <lambdabot> forall a (m :: * -> *). (MonadState [a] m) => m a
05:38:48 <xerox> ?type get >>= \(x,xs) -> put xs >> return x
05:38:49 <lambdabot> 1:0-2
05:38:57 <bolrod> erhhhhhhhh
05:39:09 <xerox> ?type get >>= \(x,xs) -> put xs
05:39:10 <lambdabot> 1:0-2
05:39:21 <int-e> it's probably the position in the input?
05:39:29 <xerox> Seems likely
05:39:33 <bolrod> @type get >>= \(x,xs) -> _
05:39:34 <lambdabot> Pattern syntax in expression context: _
05:39:39 <bolrod> @type get >>= \(x,xs) -> undefined
05:39:39 <int-e> anyway, I meant the variant with : -- does this have a name?
05:39:40 <lambdabot> forall (m :: * -> *) a b b1. (MonadState (a, b) m) => m b1
05:39:50 <bolrod> @type get >>= \(x,xs) -> put x
05:39:51 <lambdabot> 1:0-2
05:40:13 <bolrod> @type get >>= \(x,xs) -> put 2
05:40:15 <lambdabot> forall a b (m :: * -> *). (Num (a, b), MonadState (a, b) m) => m ()
05:40:16 <xerox> ?type get >>= \(x:xs) -> put xs >> return x
05:40:17 <int-e> it works in a state monad, extracts the state, takes it head, puts back the tail and returns the head. i.e. it consumes one list element of input.
05:40:18 <lambdabot> forall a (m :: * -> *). (MonadState [a] m) => m a
05:40:50 <int-e> state-level pop.
05:40:53 <Igloo> Do you want (x:xs) rather than (x,xs)?
05:40:57 <bolrod> @index get
05:40:57 <lambdabot> Control.Monad.State, Control.Monad.RWS, Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Text.ParserCombinators.ReadP, Distribution.
05:40:58 <lambdabot> Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
05:41:02 <int-e> Igloo: I already corrected that
05:41:02 <xerox> You could do the Okasaki's queue this way.
05:41:12 <lightstep> what are hyperfunctions?
05:41:26 <int-e> Igloo: but lambdabot's message is curious :)
05:41:26 <bolrod> it's an error
05:41:39 <bolrod> :t get >>= \(x,xs) -> put x    
05:41:40 <bolrod> Top level: Occurs check: cannot construct the infinite type: a = (a, b)
05:42:12 <xerox> Indeed :)
05:42:14 <bolrod>       MonadState (a, b) m, arising from use of `get' at <interactive>:1:0-2
05:42:22 <bolrod> ;)
05:43:50 <bolrod> hahaha
05:47:21 <Dino_> question: I'm going through _All About Monads_ and just got through all the sheep business..
05:47:35 <Dino_> In order to use mplus in the exercises, I had to import Monad
05:47:53 <Dino_> But it looked like Maybe gets mplus from MonadPlus.
05:48:05 <Dino_> So, two questions, if Monad is part of the Prelude, why did I have to import it?
05:48:17 <Dino_> And why am I not importing the thingy that MonadPlus is in instead?
05:49:44 <int-e> type classes as modules are different things. You import modules. modules can define functions, types and type classes.
05:50:27 <int-e> (and export them. They don't have to export everything that they internally define)
05:50:31 <Dino_> Ok, but the docs show Monad and MonadPlus being in the Prelude. All of that isn't always imported?
05:50:41 <Dino_> ah, ok
05:50:53 <xerox> The class definition may be in the Prelude, but different instances reside in different modules, for one.
05:50:53 <int-e> Prelude happens to export the Monad type class and the basic Monad operations, mainly, I believe, because they're required for IO.
05:50:54 <Dino_> Some selected portions of the Prelude are exported by default.
05:51:06 <Dino_> And I can see that this makes sense for stuff to be 'held back' in the case of something like Maybe.
05:51:15 <Dino_> It's defined a bunch of different ways, looks like.
05:51:20 <int-e> Oh, instances can be exported, too.
05:51:31 <xerox> You will find the `instance Monad Type where ...' in the appropriate Control.Monad.Type module.
05:52:18 <Dino_> Wait, the Monad type class is different than what happened when I used 'import Monad' to get my Maybe to have mplus?
05:52:30 <int-e> yes.
05:52:45 <int-e> The monad type class is exported by the Prelude.
05:53:01 <Dino_> When I have 'import Monad', what is being brought in?
05:53:11 <int-e> everything that the Monad module exports
05:53:12 <xerox> A class is a set of types, an instance is the necessary definitions to put a given type in the set.
05:53:16 <Dino_> module
05:53:31 <xerox> You'd better do `import Control.Monad', by the way.
05:53:36 <Dino_> module /= type class
05:53:45 <xerox> True
05:53:52 <int-e> that's what I've been trying to say :)
05:54:03 <Dino_> Even with same name.  Ok, so why Control.Monad?
05:54:08 <xerox> ?docs
05:54:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
05:54:11 <xerox> Check this url.
05:54:23 <xerox> It is called the modules hierarchy (documentation).
05:54:32 <Dino_> I've been looking at that, yeah.
05:54:47 <xerox> So you see there are some common basenames, like Data, Control, and Text.
05:54:51 <Dino_> yes
05:54:57 <int-e> because people decided that a flat module namespace is bad so they introduced hierarchical libraries. Many base libraries got renamed.
05:54:59 <xerox> Naming conventions.
05:55:36 <Dino_> Sure, this happens everywhere. And I saw that it's similar to Perl and Java, in that these Foo.Bar.... things correspond to directories.
05:55:38 <int-e> IO became System.IO, Monad became Control.Monad, hmm.
05:55:45 <lightstep> the Control.Monad also contains some functions not in Monad
05:55:49 <lightstep> s/the//
05:55:53 <Dino_> Oh, so this was much flatter at one time?
05:56:32 <int-e> I'm sure there's a list in the hierarchical modules addendum.
05:57:38 <lightstep> if i have a simple record type, how can i derive an INI file parser for that type? i want to use reflection.
05:57:52 <xerox>  ... deriving (Show,Read)
05:58:10 <Dino_> Let me ask this, when I look at the above docs, there's nothing just called Monad in the hier list. To correspond to the import.
05:58:10 <lightstep> no, i want a real parser
05:58:43 <xerox> DrIFT? DUnno really.
05:58:50 <xerox> http://www.rense.com/general72/size.htm
05:58:52 <lightstep> for data Foo {bar::String, baz::String}, to expect a section [Foo] with fields bar=... and baz=...
05:58:54 <Dino_> So, how do you know it's available?
05:59:37 <lightstep> Dino_, it's a standard library, defined in the Haskell Report
05:59:56 <lightstep> @where report
05:59:57 <lambdabot> I know nothing about report.
06:00:05 <lightstep> @where haskell98
06:00:05 <lambdabot> http://haskell.org/onlinereport/
06:00:29 <Dino_> Ok, so all those libs, like where it says Part II: Libraries, those are also modules.
06:00:38 <lightstep> yes
06:03:08 <Dino_> Is there some duplication between what's in Monad and Control.Monad? It seems like they both have the class Monad m => MonadPlus m where ...
06:03:40 <SamB_XP_> Dino_: yeah, but it isn't a problem -- its the same class
06:03:41 <norpan> yes, Control.Monad subsumes Monad
06:04:22 <SamB_XP_> both of them just re export it anyway, generally...
06:06:30 <Dino_> Is that like an artifact of things being redesigned over time?
06:07:32 <SamB_XP_> yes!
06:07:51 <Dino_> Perhaps some backward-compatibility going on too, like with the Map stuff.
06:07:57 <dmhouse> Dino_: if you find a module which is simply one name long, i.e. Monad instead of Control.Monad, that refers to the old modules as defined with Haskell 98.
06:08:12 <dmhouse> Since then, the hierarchical modules have subsumed those, for reasons of convenience.
06:08:27 <dmhouse> So always use the modules like Control.Monad instead of Monad.
06:08:36 <Dino_> Ok. So basically nothing is supposed to be one name long except the Prelude, eventually?
06:08:41 <dmhouse> (The only exception to the one-name-long rule is Numeric and Prelude.)
06:08:46 <Dino_> ok
06:09:08 <norpan> Data.Numeric?
06:09:09 <dmhouse> http://haskell.org/ghc/docs/latest/html/libraries/index.html there are the hierarchical modules.
06:09:29 <dmhouse> norpan: It's Numeric in GHC.
06:09:41 <norpan> yes
06:10:39 <norpan> Foreign and Network are signel-name too
06:11:18 <dmhouse> Ah yes.
06:11:29 <Dino_> Ok, so this may be also why Module alone isn't in the HHL, becuase you're really supposed to write new code using Control.Monad (which IS there).
06:11:30 <dmhouse> Okay, we need a better rule.
06:11:48 <dmhouse> 'If it's on the GHC docs page for the hierarchical modules, use it."
06:11:54 <dmhouse> s/"/'/
06:12:02 <dmhouse> Dino_: right.
06:12:45 <Dino_> You know, in Java, they have a mechanism to mart APIs as deprecated. So that you can use them, but you could possibly get warnings at compile time that they are leaving someday.
06:12:50 <Dino_> s/mart/mark/
06:12:58 <norpan> the same thing exists for ghc
06:13:02 <SamB_XP> hmm, should we mark Haskell 98 deprecated?
06:13:36 <norpan> not until there is a new standard i don't think
06:13:58 <dmhouse> Dino_: try compiling with -Wall
06:14:03 <norpan> which you could say there almost is
06:14:23 <dmhouse> (I assume that'll trigger warnings about using the old modules, haven't actually tried it myself.)
06:14:33 <norpan> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
06:14:59 <norpan> those warnings are enabled by default
06:15:08 <Dino_> Ok, cool.
06:16:07 <SamB_XP> but I don't think there are any about the package with all those pre-heirarchical modules...
06:16:31 <norpan> no, the current standard shouldn't be deprecated i think
06:17:06 <norpan> otoh all compilers support the new libraries
06:17:23 <dmhouse> Hierarchical modules are really the de-facto standard.
06:17:29 <norpan> yes
06:17:39 <dmhouse> If you tell newbies that they're not H98, the response is often surprise.
06:17:48 <Dino_> Thanks for this help, you guys.
06:17:50 <SamB_XP> yah! defacto is a good mayor, too!
06:17:52 <norpan> i suppose it's up to the compiler to mark them as deprecated
06:17:53 <dmhouse> (Depending on whether they've followed an older tutorial or not.)
06:40:38 * SamB_XP wishes Volume Control didn't ping when you let go of the main slider...
06:41:25 <bolrod> :D
06:41:46 <bolrod> that's especially cool when you have the volume turned all the way up
06:42:11 <bolrod> C:
06:42:38 <SamB_XP> exactly!
06:43:01 <SamB_XP> it should make a more subdued noise, and maybe a continuous one, if it is going to make any noise at all...
06:43:05 <bolrod> so... don't use windows
06:43:24 <SamB_XP> oh, well, yeah. that would be the obvious solution ;-)
06:43:36 <bolrod> or just remove the .wav it plays
06:43:46 <bolrod> but then it may play the even more annoying error sound
06:44:02 <bolrod> but you could remove that one too
06:44:06 <bolrod> :D
06:44:20 <SamB_XP> well, what about when those sounds are used for legitimate purposes?
06:44:29 <SamB_XP> anyway, couldn't I just deconfigure them?
06:44:36 <bolrod> sure.. I guess
06:44:54 <bolrod> what about the sound config? :)
06:45:03 <joe_k> double click the speaker icon
06:45:06 <joe_k> then change it in the mixer panel
06:45:16 <joe_k> i dont think that dings like the mini volume slider
06:45:23 <bolrod> I think that makes the same noise...
06:45:30 <SamB_XP> joe_k: yes, it does
06:45:35 * SamB_XP was talking about that one
06:45:40 <joe_k> hmm, it doesnt on win2k
06:45:44 <dmhouse> @where yaht
06:45:45 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
06:45:51 <bolrod> yes.. but win2k sucks even more
06:45:52 <joe_k> dang improvements!
06:45:53 <dmhouse> joe_k: Got your speakers muted? :)
06:45:54 <SamB_XP> the mini slider dings in 2k?
06:45:59 <joe_k> yes
06:46:08 * SamB_XP doesn't recall noticing that
06:46:21 <SamB_XP> but then I don't usually use the mini slider
06:46:23 <bolrod> win2k doesn't even have tab completion in cmd
06:46:38 <SamB_XP> don't you have to enable that in the registry anyway?
06:46:43 <bolrod> you could buy a logitech keyboard with volume button
06:46:46 <bolrod> I think that doesn't ding
06:47:15 * SamB_XP thinks that nopping out the call in sndvol32.exe would be a more economic solution
06:47:36 <SamB_XP> er, economical
06:47:39 <bolrod> it's funny.. I guess it dings to let you know when you have turned the volume up too loud.. but exactly does what you don't want it to do when you have the volume way up
06:47:46 <bolrod> Windows is so cool!
06:47:52 <bolrod> so convenient
06:48:10 <SamB_XP> yeah, exactly what I was thinking
06:48:25 <SamB_XP> about it doing exactly what you *don't* want when the volume is up
06:48:49 <joe_k> click the mute button then turn it up
06:48:52 <joe_k> then unclick it
06:49:40 <bolrod> what about just removing the wav file
06:49:43 * SamB_XP turns up the default volume for Highly Advanced
06:49:46 <bolrod> or edit the sound config menu
06:50:35 * SamB_XP *would* like to tell XP to just use the PC speaker for that stuff... but doesn't think XP is smart enough to do that
06:51:13 <bolrod> it's like.. 'Hell.. you bougt me, I'm going to bombard you with every feature I have'
06:51:55 <bolrod> 'would you like some updates'
06:52:01 <bolrod> 'you don't seem to have a virus scanner'
06:52:09 <bolrod> 'should I turn on the firewall?'
06:52:11 <bolrod> :)
06:54:22 <joe_k> 'Hey look a wireless network!'
06:54:23 <joe_k> 'Hey look a wireless network!'
06:54:24 <joe_k> 'Hey look a wireless network!'
06:56:04 <dons> I wish Haskell did that 
06:56:23 <dons> "Hey, maybe you would like to use a GADT?"
06:56:29 <joe_k> heh
06:57:03 <Igloo> And thus the hIDE paperclip was born
06:57:15 <bolrod> oh noe!
06:57:22 <dons> heh
06:57:52 <dons> @seen shapr
06:57:52 <lambdabot> I saw shapr leaving #scannedinavian, #Haskell.se, #haskell and #ScannedInAvian 23 hours and 45 minutes ago, and .
06:58:45 <dmhouse> Hey dons.
06:58:58 <dons> heya dmhouse
06:59:00 <dons> how's code?
06:59:13 <dmhouse> Not too bad. Been writing a lot for the Wikibook.
06:59:30 * dmhouse is currently trying to get his head around CPS so he can write that chapter.
07:00:32 <dmhouse> dons, hows yours?
07:01:04 <dons> oh good. been hacking on this new wmii window manager, adding haskell configuration scripts
07:01:08 <dons> lots of fun
07:01:19 <dons> wmii is like ion, but smaller and more hackable
07:01:37 <dmhouse> Cool! :) Haskell configurations scripts?
07:02:03 <dons> yeah, wmii lets you write config scripts in any lang, they just need to be executable, so i rewrote the key handler and some other code in haskell
07:02:25 <dmhouse> Ah, nice.
07:10:29 <xerox> dons, shaper said he will be back in ~10 days, yesterday.
07:11:16 <dons> ah, right
07:12:57 <dmhouse> Is this his move?
07:15:22 <dmhouse> (As in moving house. I think he said he was moving to Stockholm or somewhere.)
07:22:05 <dmhouse> Anyone around with CPS skillz?
07:22:27 <dmhouse> I've been trying out the CPS section from YAHT, just wanted to check my answer to one of the exercises.
07:22:58 * SamB_XP thinks that hIDE would have a lambda rather than a paperclip
07:23:40 <ski> dmhouse : what was the exercise ?
07:23:48 <dmhouse> ski, just typing it out.
07:24:02 <dmhouse> First, an example is given:
07:24:09 <dmhouse> cfold _ z [] = x; cfold f z (x:xs) = f x z (\y -> cfold y z xs).
07:24:49 <dmhouse> That's a fold using continuations. Then we can recover foldr f z xs = cfold (\x t g -> f x (g t)) z xs
07:24:59 <dmhouse> The exercise is to write map using continuations.
07:25:22 <dmhouse> cmap _ [] = []; cmap f (x:xs) = f x (: cmap f xs) was my attempt.
07:25:29 <ski> '\y -> cfold y z xs' ?  not '\y -> cfold f y xs' then ?
07:25:42 <dmhouse> Then map f = cmap (\x g -> f (g x))
07:25:57 <dons> night all
07:26:02 <xerox> goodnight dosn
07:26:04 <dmhouse> ski: sorry, I meant the latter.
07:26:04 <xerox> *dons
07:26:37 <dmhouse> Does that look right, anyway?
07:27:00 <ski> cmap :: (a -> (b -> o) -> o) -> ([a] -> ([b] -> o) -> o)
07:27:01 <ski> ?
07:27:29 <ski> (i.e. effectful function argument, or not ?)
07:27:44 <dmhouse> Mine was 'cmap :: (a -> (a1 -> [a1]) -> [a1]) -> [a] -> [a1]'. It might be wrong though.
07:28:16 <ski> that would seem weird, i think
07:28:48 <ski> 'cmap' should take a continuation at least, i think
07:29:01 <ski> and possibly the argument function 'f', too
07:29:09 <dmhouse> Well cfold :: (a -> t -> (t -> t) -> t) -> t -> [a] -> t
07:29:31 <ski> hm
07:30:11 <ski> maybe i should read the full exercise (and possibly some more surrounding), so get an idea of what they're after :)
07:30:38 <dmhouse> @where YAHT
07:30:38 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
07:30:42 <dmhouse> Starting from page 53
07:30:59 <dmhouse> Actually, the relevant stuff starts page 55
07:31:04 <dmhouse> 'I realise this discussion...
07:47:12 <ski> hm cfold' seems a bit strange, i think
07:48:29 <ski> it seems a variant of a left-fold
07:49:30 <ski> the definition of cfold from that is not normal CPS
07:50:57 <ski> dmhouse : hm, what do they mean in exercise 4.11 ?
07:51:18 <dmhouse> ski, I think that means does cfold = foldl or foldr?
07:51:48 <ski> well obviously it's not exactly the same as either
07:52:09 <ski> i think it corresponds best to foldl
07:52:49 <dmhouse> ski, isn't it precisely foldl?
07:53:09 <dmhouse> I think they're refering to cfold as opposed to cfold'.
08:16:18 * roconnor is learning Haskell networking
08:16:25 <roconnor> @lisp-paste
08:16:25 <lambdabot> Unknown command, try @list
08:16:29 <roconnor> @lpaste
08:16:30 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:16:31 <roconnor> @paste
08:16:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:16:41 <roconnor> @lisp
08:16:42 <lambdabot> list [module|command]. Where modules is one of:
08:16:42 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
08:16:42 <lambdabot> topic type unlambda url version vixen where
08:16:59 * roconnor can never find the lisp-paste page
08:17:10 <ski> lisppaste2: url?
08:17:10 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:17:28 <dmhouse> roconnor: It's @where paste
08:17:37 <dmhouse> But it's not a hard URL to remember :)
08:17:52 <lisppaste2> roconnor pasted "My First Networking Code" at http://paste.lisp.org/display/21684
08:18:03 <dmhouse> If you have a decent browser, you probably just need to do 'past <down> <RET>'
08:18:18 <roconnor> ah yes
08:18:32 <dmhouse> Woah, what's with the ugly semicolons/curly brackets?
08:18:34 <roconnor> Anyway, do people have a nice layout when using bracket?
08:18:44 <roconnor> dmhouse: exactly my question.
08:19:04 <roconnor> bracket as in IO.bracket, or Control.Exception.bracket
08:19:36 <lisppaste2> dmhouse annotated #21684 with "alternative layout" at http://paste.lisp.org/display/21684#1
08:19:39 <dmhouse> Try that.
08:20:50 <roconnor> oh that's nicer.
08:21:06 <roconnor> Another question, am I making proper use of string handling here?
08:21:27 <roconnor> the ++ seems a bit unwieldly
08:21:43 <dmhouse> You could use printf.
08:21:56 <int-e> @type showString
08:21:57 <lambdabot> String -> ShowS
08:22:06 <roconnor> does printf have buffer overflows?
08:22:47 <dmhouse> roconnor: What's the type of host?
08:23:04 <dmhouse> @type accept
08:23:05 <lambdabot> Not in scope: `accept'
08:23:09 <dmhouse> @hoogle accept
08:23:10 <lambdabot> Network.accept :: Socket -> IO (Handle, HostName, PortNumber)
08:23:10 <lambdabot> Network.Socket.accept :: Socket -> IO (Socket, SockAddr)
08:23:17 <roconnor> type HostName = String
08:23:31 <lisppaste2> dmhouse annotated #21684 with "with Printf" at http://paste.lisp.org/display/21684#2
08:23:43 <dmhouse> I'm not sure about buffer overflows, but ^^ looks neater.
08:24:09 <int-e> buffer overflows aren't a problem
08:24:16 <int-e> run-time overhead might be
08:24:20 * roconnor is scared of printf
08:24:31 <int-e> roconnor: look at the module. it's instructive
08:25:01 <roconnor> is printf what people tend to use?
08:25:02 <dmhouse> roconnor: its usage is very simple. In terms of how it works, 'Typeclass hackery' about sums it up :)
08:25:07 * int-e doesn't
08:25:29 <dmhouse> int-e, why not?
08:25:40 <int-e> don't like it
08:25:54 <dmhouse> Why not? :)
08:26:02 <int-e> it's one of the few ways to get static run time errors into your code
08:26:08 <dmhouse> Ah.
08:26:09 <int-e> > printf "%s" 42
08:26:09 <lambdabot>  Add a type signature
08:26:16 <int-e> > printf "%s" (42 :: Int)
08:26:17 <lambdabot>  Add a type signature
08:26:22 <int-e> > printf "%s" (42 :: Int) :: String
08:26:24 <lambdabot>  Exception: Printf.printf: bad argument
08:26:28 <int-e> at runtime
08:26:29 <int-e> bad.
08:26:34 <dmhouse> That is an advantage that TH has.
08:27:04 <roconnor> another question, I test this program by running ``nc localhost 31337'', and I get a result like ``Host:"localhost.localdomain" Port:38336''
08:27:09 <roconnor> but nc doesn't exit?
08:27:17 <roconnor> even though (I assume) sClose is called.
08:27:55 <int-e> hmm. no. not until a garbage collection takes place anyway
08:27:56 <dmhouse> @index bracket
08:27:57 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
08:28:17 <int-e> hmm
08:28:35 <dmhouse> roconnor: By the way, System.IO is the hierarchical version of IO.
08:28:51 <int-e> wait, the program exits?
08:28:55 <roconnor> should I always use the hierarchical names?
08:29:09 <dmhouse> Yep.
08:29:20 <dmhouse> The old ones are deprecated.
08:29:34 <roconnor> Oh, I am running the haskell in GHCi.  Maybe that is my problem.
08:29:50 <roconnor> ah yes
08:29:52 <roconnor> but still
08:30:02 <roconnor> why can't I close the connection in GHCi.
08:30:11 <int-e> sClose won't close the accepted file handl (h)
08:30:24 <roconnor> oh?
08:30:24 <int-e> only the listening socket (s)
08:30:33 <int-e> you need to close h, too.
08:30:36 <roconnor> ahh
08:30:57 <roconnor> so two brackets are needed.
08:31:22 <int-e> hmm. a bracket around accept ... yes, that could work.
08:32:59 <roconnor> System.IO doesn't export bracket.  That's nice.
08:33:20 <dmhouse> If I have written, say, a Regex library, and I want it to work on extremely large inputs, what techniques would be useful?
08:33:35 <dmhouse> Well, not even 'extremely large'.
08:33:37 <int-e> bracket (accept s) (\(h, _, _) -> hClose h) (\(h, host, port) -> do ...)
08:33:51 <int-e> @type bracket
08:33:57 <lambdabot> Not in scope: `bracket'
08:34:03 <int-e> @type Control.Exception.bracket
08:34:04 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:34:10 <dmhouse> JRegex segfaults on a ~250KB input and I thought I'd have a go at hacking it to make it a bit more streamlined.
08:34:13 <lisppaste2> roconnor annotated #21684 with "nested brackets" at http://paste.lisp.org/display/21684#3
08:34:47 <ski> dmhouse : hm, i'd write a CPS variant of foldl like
08:34:50 <xerox> dmhouse - There exist a Lazy RegExp thing
08:34:53 <roconnor> it's a bit complicated, but still fair.
08:34:57 <dmhouse> xerox, PCREs?
08:35:09 <xerox> Can't remember, it was on sourceforge.
08:35:16 <ski> foldlK :: (r -> a -> (r -> o) -> o) -> r -> [a] -> (r -> o) -> o
08:35:26 <ski> foldlK f z [    ] k = k z
08:35:37 <xerox> http://sourceforge.net/projects/lazy-regex
08:35:44 <ski> foldlK f z (x:xs) k = f z x (\y -> foldlK f y xs k)
08:36:35 <dmhouse> @spell sausages
08:37:46 <bolrod> @spell sausage
08:37:56 <bolrod> ^.|
08:38:08 <madpickle> @spell bangers
08:38:09 <dmhouse> Dons apparently hasn't installed aspell yet.
08:38:14 <madpickle> =P
08:38:34 <bolrod> @wn sausages
08:38:36 <lambdabot> No match for "sausages".
08:39:45 <ski> dmhouse : it has worked previously
08:39:59 <dmhouse> ski, oh?
08:41:20 <ski> dmhouse : anyway, i'm not sure that YAHT part is a good intro to CPS at all
08:41:39 <dmhouse> ski, nope, I don't think it is either. :)
08:42:14 <ski> did you understand foldK ?
08:43:07 <ski> (btw, the fact that foldl is tail-recursive translates to the fact that 'k' in foldlK is just passed around, unchanged)
08:43:44 <roconnor> How do I say, do this forever?
08:43:55 <roconnor> do this IO () forever
08:43:56 <dmhouse> roconnor: recursion with no base case.
08:44:17 <dmhouse> loop = do whatever; loop
08:44:29 <ski> forever m = m >> forever m
08:44:56 <ski> @type \m -> fix (m >>)
08:44:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:47:34 <lisppaste2> roconnor annotated #21684 with "My First Haskell Server" at http://paste.lisp.org/display/21684#4
08:47:40 <roconnor> Weeeee!
08:48:04 <dmhouse> Very good. :)
08:48:30 <roconnor> that wasn't so difficult!
08:49:04 <roconnor> oh wait, this only handles one connection at a time.
08:49:15 <roconnor> I need some threads now. :)
08:59:40 <roconnor> hmm, can I not use a parent's handle in a child's thread?
09:00:11 * roconnor thought just adding forkIO $ to the begining of handleConnection would work.
09:03:59 <roconnor> <interactive>: <socket: 4>: hSetBuffering: illegal operation (handle is closed)
09:04:15 <roconnor> oh wait, I'm dumb
09:04:33 <roconnor> the handler of the bracket was called.
09:11:19 <lisppaste2> roconnor annotated #21684 with "My First Threaded Haskell Server" at http://paste.lisp.org/display/21684#5
09:12:57 <lisppaste2> dmhouse annotated #21684 with "@ patterns make you cooler" at http://paste.lisp.org/display/21684#6
09:13:03 <dmhouse> roconnor: ^^
09:14:01 <roconnor> dmhouse: Thanks, I was considering that
09:15:03 <lisppaste2> dmhouse annotated #21684 with "Don't forget about >>=" at http://paste.lisp.org/display/21684#7
09:15:09 <dmhouse> roconnor: Again :) ^^
09:15:57 <monochrom> This is a slippery slope.  Eventually you'll be just @pl-ing it :)
09:16:30 <dmhouse> Nah, there's a time and a place for pointsfree.
09:19:17 * roconnor boings
09:19:25 <roconnor> I'm happy this was relatively easy
09:20:32 * roconnor wonders how many connections my server can handle.
09:21:10 * roconnor wonders how many connections _his_ server can handle.
09:34:48 <bolrod> 65534 ?
09:34:59 <roconnor> > 2^32
09:35:01 <lambdabot>  4294967296
09:35:06 <roconnor> > 2^16
09:35:07 <lambdabot>  65536
09:35:08 <bolrod> there aren't that many ports
09:35:17 <bolrod> well.. one is reserved by the server
09:35:23 <bolrod> and probably one other as well
09:38:32 <dmhouse> Anyone hacked on haskell-mode?
09:39:42 <roconnor> Oops, I need to use `finally` instead of >>
09:40:04 <roconnor> :type (>>)
09:40:09 <roconnor> @type (>>)
09:40:10 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
09:40:27 <roconnor> @type (System.IO.finally)
09:40:28 <lambdabot> Not in scope: `System.IO.finally'
09:40:33 <roconnor> @hoogle finally
09:40:34 <lambdabot> Control.Exception.finally :: IO a -> IO b -> IO a
09:40:40 <roconnor> :)
09:42:48 * mahogny figures that writing high-level compilers is quite a mess as compared to just implementing a language
09:43:31 * roconnor tries to figure out how to add a timeout to his connections.
09:43:44 <mahogny> eew
09:44:01 <mahogny> I got an url earlier on how it could be done. want be to look around?
09:44:41 <roconnor> hmm, maybe setSocketOption will do what I want.
09:44:59 <mahogny> that is for polling
09:45:06 <neologism> Lemmih: hows the work on the ghci debuger going?
09:45:08 <roconnor> setSocketOption s RecvTimeOut 100
09:45:15 <roconnor> oh
09:45:16 <mahogny> hmm
09:45:17 <roconnor> hmm
09:45:27 <mahogny> maybe that could work
09:46:12 <mahogny> otherwise exceptions are worth trying. depends on the nastiness of the situation. if that's the case, you set up multiple threads to deal with it
09:46:29 <roconnor> I just want the connection to die if no one is using it.
09:46:46 <mahogny> well, whatever works :)
09:47:06 <bolrod> http://videos.dumphead.com/newatm.html
09:50:44 <lightstep> how can i get Graphics.Rendering.Cairo on ubuntu?
09:51:01 <dmhouse> Install Cairo?
09:51:01 <roconnor> hmm, but accept gave me a handle, not a socket
09:51:09 <roconnor> @hoogle Handle -> Socket
09:51:10 <lambdabot> No matches, try a more general search
09:51:11 <dmhouse> Then I think the bindings come with gtk2hs.
09:51:12 <xerox> you install GHC and Gtk2Hs dependencies, then you get Gtk2Hs darcs code.
09:52:08 <xerox> You can get the most of the dependencies out of apt-get, as well as ghc.
09:52:31 <mahogny> roconnor: IMO the haskell standard libraries for sockets/networking/etc is a mess when you try to do something serious. but that's just me
09:52:54 <roconnor> could be
09:53:08 <roconnor> I might be forced to use Network.Socket.accept
09:53:12 <xerox> lightstep - Anything else specific?
09:53:12 <roconnor> @hoogle accept
09:53:13 <lambdabot> Network.accept :: Socket -> IO (Handle, HostName, PortNumber)
09:53:14 <lambdabot> Network.Socket.accept :: Socket -> IO (Socket, SockAddr)
09:53:14 <lightstep> is there a not-official-debian repository with the gtk2hs package?
09:53:26 <dmhouse> lightstep: I think so.
09:53:50 <dmhouse> @google haskell debian repository
09:53:53 <lambdabot> http://www.haskell.org/hawiki/DebianUsers
09:53:54 <lambdabot> Title: "DebianUsers - The Haskell Wiki"
09:54:16 <xerox> I think you'd better go for the darcs code.
09:54:28 <lightstep> does it take long to compile?
09:54:36 <xerox> Not too much
09:54:53 <lightstep> @where gtk2hs
09:54:54 <lambdabot> http://haskell.org/gtk2hs/
09:55:38 <xerox> darcs get http://darcs.haskell.org/gtk2hs/
09:55:59 <lightstep> i'll just get the tarball
10:07:35 <dmhouse> Anyone hacked on haskell-mode?
10:08:03 <dmhouse> I want to enable auto-fill-mode when you start typing a comment.
10:08:20 <dmhouse> I'm not sure there are hooks available for this. Anyone happen to know?
10:08:28 <lispy> hmm...
10:09:00 <lispy> i dought there is a hook for that, iirc emacs just uses regular expressions to determine how to handle things
10:09:13 <lispy> er not dought but doubt
10:09:22 <dmhouse> Yep, that's what it seems.
10:09:33 <dmhouse> How would I go about doing something like this then?
10:09:53 <lispy> hack on eclipse-fp instead :)
10:10:05 <dmhouse> :P No thanks.
10:10:05 <lispy> or hide, or yi or ....
10:10:58 <lispy> dmhouse: if you really wanted to be cool, you'd hack on emacs so that it uses the ghc-api to do font-locking...but you'd have to hack some emacs infrastructure to get that working i bet
10:13:54 <SyntaxNinja> w00t
10:15:36 * lispy drops a spoon
10:16:05 * SyntaxNinja goes nuts
10:16:05 * lispy realizes a ninja is in the room and tries to pick it up quickly but discretely before the ninja notices
10:24:34 <roconnor> ugh: http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/3788
10:30:16 <roconnor> right, so much for haskell. ;)
10:34:45 * roconnor uses hWaitForInput instead.
10:36:38 <lispy> roconnor: that didn't look like the end of the world to me if what simon says is true
10:37:07 <roconnor> It means someone needs to fix Network.Sockets?
10:37:21 <roconnor> and that someone isn't me ;)
10:37:34 * roconnor doesn't know C style sockets
10:38:35 <lispy> that email is older than 6 months, it may be fixed by now :)
10:38:45 * lispy keeps trying to look at the positive ;)
10:40:16 <roconnor> wouldn't the documentation be changed?
10:40:48 * roconnor is reading ghc/docs/latest/
10:44:06 <Lemmih> neologism: Pepe is making great progress.
10:45:14 * roconnor learned a new trick
10:45:23 <roconnor> import System.IO hiding (hGetLine)
10:45:23 <roconnor> import qualified System.IO
10:45:35 <roconnor> This forces hGetLine to be fully qualtifed when used.
10:46:15 <norpan> indeed
10:46:21 <roconnor> and I can write my own local hGetLine (that calls hWaitForInput)
10:46:44 <roconnor> so I don't have to change all my calls to hGetLine
10:47:15 <norpan> well, that's just a replace operation, takes like five seconds :)
10:48:40 <roconnor> Well, it is mostly so I don't accidently call System.IO.hGetLine.  That would ruin my program.
10:49:07 <roconnor> :( hWaitForInput seems to be blocking all my threads.
10:50:49 <roconnor> (if t is non-zero, then all other concurrent threads are blocked until data is available)
10:50:53 * roconnor cries
10:53:13 <lispy> forkIO?
10:53:32 <roconnor> already done.
10:53:37 <lightstep> -threaded?
10:54:35 <xerox> I know waitPid will block all the threads
10:54:39 <xerox> Maybe the other IO does too
10:55:01 * xerox dances around franka 
10:55:17 <franka> Hi, xerox.
10:55:27 <xerox> Rice!
10:55:36 <franka> Rice?
10:55:51 <xerox> So they say, downstairs. TTYL.
10:56:16 <franka> ?
11:00:02 <franka> TTYL.  To Tell You a Limerick?
11:00:38 <monochrom> To Tell You Lies
11:01:05 <franka> Ah.
11:01:21 <int-e> talk to you later
11:01:24 <monochrom> I was lying.
11:01:34 <monochrom> torture you later.
11:05:41 * JKnecht thinks it was supposed to be TTTL
11:07:12 <franka> What is TTTL?
11:07:25 <JKnecht> oh, no agree with int-e.
11:07:50 <int-e> total time to live
11:07:52 * int-e giggles
11:09:49 <JKnecht> the minimalist program was at work: I read TT as Ta Ta instead of Talk To.
11:10:41 <int-e> tatatalklater?
11:10:55 <JKnecht> till
11:11:00 <monochrom> ta ta ya la  (truely minimalist)
11:11:33 <int-e> y could stand alone
11:23:21 * roconnor still crying
11:25:17 * lispy gives roconnor a tissue
11:25:27 <roconnor> *sniff* thanks.
11:31:20 <int-e> roconnor: for your new trick: you can import System.IO qualified as IO  to save some typing.
11:33:16 <roconnor> good idea
11:34:37 <roconnor> if anyone know how to do timeouts with sockets, leave me a message
11:34:45 <jgrimes> are any of you running ghc on hp-ux?
11:37:41 <jgrimes> I saw that debian has ghc for pa-risc, thats why I ask
11:39:14 <int-e> I don't know why Simon wrote what he wrote. I don't see the non-abstracted exports he's talking about.
11:40:29 <int-e> not for setSocketOption anyway
11:45:16 <dmhouse> @hoogle setSocketOption
11:45:17 <lambdabot> Network.Socket.setSocketOption :: Socket -> SocketOption -> Int -> IO ()
11:46:01 <dmhouse> int-e, I assume that just means the SocketOption datatype isn't abstract.
11:49:02 <lispy> br
11:49:05 <lispy> er...
12:12:19 <neologism> any hungarian here by a chance?
12:12:36 <madpickle> need help with hungarian notation? :P
12:13:13 <neologism> no... just a little translation :)
12:14:00 <vincenz> hi
12:14:18 <monochrom> I know Polish notation :)
12:14:31 <vincenz> monochrom: I know reverse polish notation
12:14:32 <madpickle> reverse?
12:14:43 <neologism> madpickle: prefix/postfix
12:15:13 <madpickle> yeah, but i spack leet
12:15:16 <madpickle> so take that!
12:15:56 <dmhouse> @elite me too!
12:15:57 <lambdabot> mE +O0!
12:16:05 <vincenz> @elite me 3
12:16:05 <lambdabot> Me 3
12:16:10 <madpickle> glad to see the haskell language being put to good use
12:16:31 <mauke> @keal
12:16:31 <lambdabot> perhaps i just genius and never tested
12:16:44 <ski> @keal
12:16:44 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
12:16:51 <lispy> @. elite keal
12:16:51 <lambdabot> MY \/3RY FIrz+ cOMpU7ER WaS An 80-0840
13:13:24 <lightstep> if i read a file with readFile, and handle the result with well-behaved consumers, will the file be read sequentially and closed early?
13:14:06 <xerox> Nothing is done early in Haskell, usually.
13:15:40 <Igloo> It will be read as needed and closed when you hit EOF
13:16:28 <Igloo> (buffering may mean it is actually read more quickly than that, and of course full laziness isn't actually required by the language semantics anyway)
13:39:01 <heatsink> @hoogle (Floating a, Floating b) -> a -> b
13:39:03 <lambdabot> No matches, try a more general search
13:39:12 <heatsink> @hoogle (Floating a, Num b) -> a -> b
13:39:14 <lambdabot> No matches, try a more general search
13:39:24 <heatsink> There must be a way to do it.
13:40:26 <heatsink> @hoogle (RealFloat a, RealFloat b) -> a -> b
13:40:27 <lambdabot> No matches, try a more general search
13:40:28 <dmhouse> @hoogle (Floating a, Num b) => a -> b
13:40:29 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
13:40:30 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
13:40:30 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
13:40:31 <mauke> @hoogle (Floating a, Floating b) => a -> b
13:40:32 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
13:40:34 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
13:40:36 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
13:40:46 <Korollary> Floating is a sub of Fractional
13:41:44 <heatsink> @hoogle (Fractional a, Fractional b) => a -> b
13:41:46 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
13:41:46 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
13:41:46 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
13:42:52 <heatsink> Is that a hoogle bug?
13:43:38 <heatsink> > realToFrac (3.1 :: Float) :: Double
13:43:40 <lambdabot>  3.0999999046325684
13:43:50 <heatsink> ok, found it :)
13:44:08 <madpickle> that's not a bug per se
13:44:25 <madpickle> (the number not equalling 3.1)
13:44:41 <jer> 6it's a lack of floating point precision
13:44:42 <heatsink> madpickle, I meant the results from hoogle.
13:44:46 <madpickle> oh
13:44:51 <madpickle> sorry
13:46:08 <jer> if you convert the other way (from the more precise Double, to the less precise Float) you'll get 3.1
13:46:15 <jer> or at least should anyway
13:46:23 <jer> > realToFrac (3.1 :: Double) :: Float
13:46:24 <lambdabot>  3.1
13:47:26 <heatsink> How can that be more accurate?
13:47:33 <zarvok> It's a rounding thing
13:48:06 <madpickle> gotta love computers.
13:48:24 <heatsink> But the conversion from a float to a double is exact.
13:48:52 <zarvok> well, in once sense, but also:
13:49:10 <zarvok> > realToFrac (3.0999999046325684 :: Double) :: Float
13:49:11 <lambdabot>  3.1
13:49:15 <zarvok> less accurate
13:50:06 <heatsink> So it rounds Float differently when printing.
13:50:11 <zarvok> consider reading up on floating point:
13:50:11 <zarvok> http://en.wikipedia.org/wiki/Floating_point
13:50:14 <zarvok> it's real magic
13:50:25 <heatsink> I was just there.
13:50:27 <zarvok> It's not printing
13:51:05 <heatsink> "show"ing
13:51:18 <zarvok> What I mean is, it's not the printing that forces the rounding
13:52:11 <zarvok> It probably just works out that 3.1 can be encoded exactly in float
13:52:15 <zarvok> I would do it out
13:52:16 <zarvok> but I am lazy
13:52:33 <zarvok> or at least, can be encoded exactly up to the appropriate precision
13:52:38 <heatsink> It can't, because 0.1 is 1/2 * 1/5
13:52:47 <heatsink> and 1/5 cannot be encoded exactly
13:53:08 <zarvok> well then I guess I'm just being dumb
13:53:16 <zarvok> let's see
13:56:17 <zarvok> well, it looks to me like in both cases we get 1.55000... up to the appropriate precisino for the mantissa
13:56:30 <zarvok> of course
13:58:01 <zarvok> yeah, I don't know
13:58:13 <zarvok> it may have to do with the strange rounding that happens on an intel floating point stack
13:58:20 <zarvok> do we know what type of box lambdabot lives on?
13:59:02 <wilx> OpenBSD Intel, maybe?
13:59:58 <zarvok> see, the intel floating point stack is 80 bits wide
14:00:29 <zarvok> so when you throw values in and out of there, all kinds of wonky rounding happens
14:00:38 <zarvok> because it does somethings at this higher precision
14:00:45 <zarvok> but then whenever it has to use registers
14:00:49 <zarvok> the precision gets cut back down
14:01:20 <jgrimes> @version
14:01:20 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
14:01:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:01:32 <heatsink> hmm.
14:01:47 <zarvok> but at this point I'm just thinking of random possible reasons
14:02:12 <zarvok> you were probably right at the start, the printing happens to more decimal places for doubles which allows it to show floating point error in this case
14:02:50 <zarvok> any time you want to waste a few mintes with completely wrong reasoning again, just let me know :)
14:04:08 <Korollary> heh
14:04:31 <monochrom> > show (3.1::Float)
14:04:32 <lambdabot>  "3.1"
14:04:56 <zarvok> > show (3.1::double)
14:04:56 <lambdabot>  add (Fractional double) to the expected type of an expression
14:04:57 <lambdabot>   In the ex...
14:05:04 <zarvok> > show (3.1::Double)
14:05:05 <lambdabot>  "3.1"
14:05:25 <zarvok> well, then maybe the printing isn't it?
14:05:28 <zarvok> heh, now I'm lost
14:05:49 <monochrom> > show (0.9999999::Float)
14:05:50 <lambdabot>  "0.9999999"
14:05:54 <monochrom> > show (0.9999999999::Float)
14:05:55 <lambdabot>  "1.0"
14:06:32 <monochrom> > realToFrac (0.99999999::Float) :: Double
14:06:33 <lambdabot>  1.0
14:07:35 <Korollary> show's probably representing it as 3.1 because it can be read back as the same number, and it's easier on the eyes than whatever it actually is.
14:07:56 <monochrom> > pi :: Float
14:07:57 <lambdabot>  3.1415927
14:08:02 <monochrom> > pi :: Double
14:08:03 <lambdabot>  3.141592653589793
14:08:45 <monochrom> Thus the show routine for Float displays fewer digits than that for Double, at the on start.
14:09:00 <zarvok> right, but if that were the whole thing
14:09:08 <zarvok> > show (3.1::Double)
14:09:09 <lambdabot>  "3.1"
14:09:11 <monochrom> (This, of course, makes a lot of sense; no point asking Float to display a million digits that are not really there.)
14:09:12 <zarvok> would show more digits, right?
14:10:02 <zarvok>  > realToFrac (3.1 :: Float) :: Double
14:10:16 <zarvok> > realToFrac (3.1 :: Float) :: Double
14:10:17 <lambdabot>  3.0999999046325684
14:10:25 <monochrom> 3.1::Double is inexact too, of course.  But insofar as displaying 18 digits, it still comes down to 3.1000...000.
14:10:25 <zarvok> > show (realToFrac (3.1 :: Float) :: Double)
14:10:27 <lambdabot>  "3.0999999046325684"
14:11:33 <bolrod> @type 3.1
14:11:34 <lambdabot> forall t. (Fractional t) => t
14:11:36 <zarvok> so, what is the reason for this, then?
14:11:45 <mwc> You could also have it display the interval of real numbers each double or float subsumes.
14:11:49 <bolrod> so a Real is precise?
14:12:00 <bolrod> @type 3.1::Real
14:12:02 <lambdabot>   Class `Real' used as a type
14:12:02 <lambdabot>   In the type `Real'
14:12:08 <mwc> [3.0099239112,3.009913242) for instance
14:12:16 <bolrod> ?..
14:12:17 <lambdabot> Not enough arguments to @.
14:12:33 <mwc> bolrod, real is a class of types that represent real numbers
14:12:34 <bolrod> how does one create a real in haskell?
14:12:36 <joe_k> i take it Real is a type class and not a type (but I am a newbie)
14:12:46 <zarvok> how does one display this range, mwc?
14:13:18 <mwc> zarvok, I'm just suggesting a different implementation for Show Float, Show Double
14:13:22 <monochrom> > Numeric.showFFloat (Just 3) (0.99999::Float)
14:13:23 <lambdabot>  <[Char] -> [Char]>
14:13:26 <zarvok> ah
14:13:26 <monochrom> > Numeric.showFFloat (Just 3) (0.99999::Float) ""
14:13:27 <lambdabot>  "1.000"
14:13:47 <monochrom> If insufficient digits are to be displayed, rounding must be done.
14:14:05 <bolrod> but when is something a Real ?
14:14:30 <mwc> bolrod, no piece of data is a real
14:14:47 <monochrom> If you understand why Numeric.showFFloat (Just 3) (0.99999::Float) "" gives you 1.000, you also understand why show (0.1::Double) gives you 0.1.
14:14:51 <mwc> Real is a class, basically, classes are to types as types are to data
14:15:14 <monochrom> Perhaps I should prove it in the concrete?
14:15:27 <monochrom> > Numeric.showFFloat (Just 33) (0.1::Double) ""
14:15:28 <lambdabot>  "0.100000000000000000000000000000000"
14:15:32 <zarvok> sure, sure, but I'm still wondering why we get the error when we do the type coercing then, since we're displaying to the same precision
14:15:43 <zarvok> Did we solve that definitively and I missed it?
14:16:13 <monochrom> The error is not in coercion.  The error is already there when you use a Float.
14:16:33 <zarvok> right
14:17:07 <monochrom> When you ask for 0.1 in Float, you already lose information.  Can't ask for restoring when converting from Float to Double.
14:17:15 <zarvok> but why does it show up when we use realToFrac?
14:17:20 <zarvok> I understand this
14:17:23 <palomer> float can encode 0.1 exactly, no?
14:17:30 <zarvok> What I'm curious about is why we have:
14:17:35 <zarvok> > realToFrac (3.1 :: Float) :: Double
14:17:36 <lambdabot>  3.0999999046325684
14:17:44 <monochrom> show for Double displays more digits and therefore reveals the error.
14:17:54 <zarvok> right, but:
14:18:02 <zarvok> > show (3.1::Double)
14:18:03 <lambdabot>  "3.1"
14:18:06 <zarvok> doesn't happen
14:18:11 <monochrom> > Numeric.showFFloat (Just 7) (realToFrac (3.1 :: Float) :: Double) ""
14:18:12 <lambdabot>  "3.0999999"
14:18:19 <monochrom> > Numeric.showFFloat (Just 6) (realToFrac (3.1 :: Float) :: Double) ""
14:18:20 <lambdabot>  "3.100000"
14:18:25 <monochrom> ok?
14:18:51 <mathewm> palomer: 0.1 -> Float -> 0.1, but 0.1000000000000000001 -> Float -> also 0.1; if you cannot confidently reverse an operation, isn't it lossy?
14:19:28 <monochrom> Float cannot encode 0.1 exactly, on IEEE 754.
14:19:43 <palomer> mathewm: my comment was on encoding 0.1 exactly
14:19:51 <zarvok> > Numeric.showFFloat (Just 16) (realToFrac (3.1 :: Float) :: Double) ""
14:19:52 <lambdabot>  "3.0999999046325684"
14:20:16 <zarvok> right, I'm not arguing with this
14:20:24 <mathewm> we just need to give computers 10 fingers...
14:20:34 <palomer> > Numeric.showFFloat (Just 16) (realToFrac (0.1 :: Float) :: Double) ""
14:20:35 <lambdabot>  "0.1000000014901161"
14:20:39 <palomer> ahh, righto
14:21:02 <palomer> did you guys know that perl didn't have integral types about 3 years ago?
14:21:11 <palomer> everything was encoded as a float
14:21:12 <palomer> crazy.
14:21:13 <monochrom> I need to find a way to show you that 0.1 is inexact in Double too.
14:21:17 <zarvok> So, the question I have is, why the show functino is printing more digits when I evaluate the realToFrac expression then when I just show 3.1
14:21:20 <mathewm> float, or double?
14:21:25 <zarvok> to rephrase
14:21:29 <palomer> > Numeric.showFFloat (Just 16) (realToFrac (0.1 :: Double)) ""
14:21:30 <lambdabot>  "0.1000000000000000"
14:21:36 <palomer> > Numeric.showFFloat (Just 40) (realToFrac (0.1 :: Double)) ""
14:21:37 <lambdabot>  "0.1000000000000000000000000000000000000000"
14:21:43 <palomer> looks exact to me!
14:21:49 <monochrom> Because "instance Show Float where ..." and "instance Show Double where ..."  are separate routines.
14:22:00 <zarvok> sure, but in both cases I'm showing a double
14:22:27 <monochrom> But then they are two different doubles.
14:22:45 <zarvok> But they aren't, at least not to the number of places that are displayed
14:23:06 <monochrom> Roughly speaking, you are comparing 0.999 with 0.999999999999999.  They have to look different.
14:23:12 <zarvok> what I'm saying is, the following two expressions display different things:
14:23:30 <zarvok> > realToFrac (3.1 :: Float) :: Double
14:23:31 <lambdabot>  3.0999999046325684
14:23:39 <zarvok> > show (3.1 :: Double)
14:23:40 <lambdabot>  "3.1"
14:23:43 <monochrom> Roughly speaking, you are comparing 0.999 with 0.999999999999999.  They have to look different.
14:23:58 <mathewm> not to change topics, but doesn't anyone know of a good paper that gives a compelling description of "Arrows" and where their killer application?
14:23:59 <zarvok> @type ( realToFrac (3.1 :: Float) :: Double )
14:24:01 <lambdabot> Double
14:24:14 <zarvok> they are both doubles, I don't understand what you're saying?
14:24:38 <lispy> mathewm: there is that paper about the robot...wampa or something that makes a big deal out of arrows but i have yet to read it
14:24:57 <mwc> mathewm, this is what drove the concept home for me: http://en.wikibooks.org/wiki/Programming:Haskell_arrows
14:24:58 <monochrom> They have different values.
14:25:19 <zarvok> > Numeric.showFFloat (Just 40) (realToFrac (3.1 :: Float) :: Double) ""
14:25:20 <lambdabot>  "3.0999999046325684000000000000000000000000"
14:25:27 <zarvok> > Numeric.showFFloat (Just 40) (3.1::Double) ""
14:25:27 <monochrom> > (3.1::Double) - (realToFrac (3.1 :: Float) :: Double)
14:25:28 <lambdabot>  "3.1000000000000000000000000000000000000000"
14:25:28 <lambdabot>  9.536743172944284e-8
14:25:46 <monochrom> Does that illuminate something?
14:26:14 <zarvok> Yes, I didn't realize they had different values
14:27:12 <zarvok> that clears it up, thank you
14:27:23 <zarvok> Somehow I thought we had seen earlier that they were the same
14:27:34 <zarvok> But I see now I had made a type in my PMs to lambdabot
14:27:39 <zarvok> *typo
14:28:35 <monochrom> There is a good reason to stick with base 2 and not base 10 or 8 or 16 for fixed precision.
14:29:17 <monochrom> Certain errors in operations are proportional to the base.  You want the smallest possible base.
14:30:06 <monochrom> Google for an article called "what every computer scientist should know about floating-point arithmetic"
14:30:24 <Korollary> that's a good one.
14:30:38 <zarvok> yeah, we read that in one of my courses
14:30:43 <dmhouse> Anyone remember the name of that wiki that just used svn as a back end?
14:33:06 <lispy> dmhouse: trac?
14:33:20 <dmhouse> lispy: Nah. That stores its data in a DB.
14:33:37 <dmhouse> I remember a wiki that just used the versioning from svn. I want to write a similar one for darcs.
14:33:49 <dmhouse> It'd be really easy:
14:34:02 <dmhouse> 1) Implement MarkDown in Haskell.
14:34:16 <dmhouse> 2) Write Emacs-/Web-based front ends.
14:34:25 <dmhouse> 3) Enjoy your new wiki.
14:34:46 <dmhouse> I remember that someone has already done something similar for SVN.
14:36:26 <lispy> i have an even easier route, 1) install mediawiki 2) enjoyr your new wiki :)
14:37:13 <dmhouse> But:
14:37:35 <dmhouse> 1) Can I interact totally, including recording new changes, viewing older revisions etc., with your wiki from inside Emacs?
14:37:53 <dmhouse> 2) Can you download your wiki and edit it in offline mode?
14:38:21 <dmhouse> 3) Can you _really_ be bothered to install something as heavyweight as MediaWiki? :)
14:38:50 <zarvok> heh, at my old job I installed/maintained four mediawiki wikis
14:38:52 <zarvok> it was not fun
14:39:20 <lispy> dmhouse: there is an emacs mode for mediawiki sothat should cover #1, when you use emacs mode it's pretty muche #2 (but not exactly) and #3 isn't that bad.
14:39:48 <lispy> zarvok: i admin 3 and i don't have a any problems, biggest hassle is updating them
14:39:54 <lispy> (i mean updating the source code)
14:39:54 <dmhouse> wikipedia-mode doesn't allow me to upload new versions or view older revisions.
14:40:06 <zarvok> lispy : yeah, the updates were always a pain
14:40:31 <zarvok> lispy : my worse problem was that the users would, from time to time, find these features that were only implemented in obscure plug ins
14:40:37 <zarvok> and expect me to install/maintain them
14:40:42 <zarvok> *worst
14:42:04 <zarvok> and often they wouldn't play nicely with whichever version of media wiki I had
14:42:21 <lispy> ah
14:42:41 <lispy> zarvok: did you happen to see a plugin that allowed spreadsheets?
14:43:18 <zarvok> nope, most of the plugins I dealt with were strange way to deal with uploading files that allowed them to use the wiki as a pretty repositories for papers on some topic
14:43:44 <zarvok> market based coordinatino in multi-robot scenarios
14:43:50 <zarvok> I have to admit, not my idea of a good time
14:44:01 <zarvok> Now I work for a type-theorist instead, much more fun :)
14:44:20 <lispy> heh
14:44:22 <Korollary> who?
14:44:25 <zarvok> Bob Harper
14:44:34 <Korollary> ah
14:44:39 <zarvok> The only real problem
14:44:43 <zarvok> is that I have to pretend to like SML
14:44:46 <zarvok> more than haskell
14:44:47 <zarvok> :)
14:45:22 <Korollary> It's just a tool. Do you mean Harper like sml better?
14:45:27 <Korollary> likes
14:45:40 <zarvok> yeah, he was on the team that designed the current standard
14:45:49 <zarvok> so he is partial to it
14:45:52 <zarvok> he's a great guy though
14:45:59 <zarvok> frighteningly good at what he does
14:46:27 <zarvok> Actually, the whole CS department at this school (CMU) is real big on SML
14:46:39 <Korollary> Schools tend to be like that
14:47:01 <zarvok> yeah, it's not really a problem
14:47:34 <Korollary> They could have been schemers (*snicker*)
14:47:56 <zarvok> heh, I escaped that fate, luckily enough
14:48:12 <zarvok> Last semester I TAed an intro level course on PL theory/functinoal programming which was taught in SML
14:48:14 <zarvok> it was a lot of fun
14:48:22 <zarvok> to teach the unwashed masses about functional programming
14:48:38 <zarvok> even if it wasn't may favorite one
14:48:41 <zarvok> *my
14:49:26 <Korollary> did they like it?
14:49:34 <zarvok> well, some did and some didn't
14:49:38 <zarvok> that's how it goes, I imagine
14:49:56 <zarvok> some people would rather do (gasp) systems work than type theory
14:50:07 <Korollary> what is systems work?
14:50:22 <zarvok> I mean like low-level programming, OS stuff, C hacking, etc.
14:50:28 <Korollary> ah
14:50:32 <zarvok> these people tend to not be fans of functional languages
14:50:55 <zarvok> and of course some people have a hard time getting their heads around things like first class functions and stateless programming
14:51:02 <Korollary> some OS stuff is interesting. No C stuff is interesting.
14:51:03 <x_> do you guys know about linux's overcommit_memory shit?
14:51:34 <koffein_> no?
14:51:52 <zarvok> It allows the allocation of more memory than actually exists, right?
14:51:54 <zarvok> that's all I know
14:51:59 <lisppaste2> int-e pasted "RFC: modified Network.Socket module that uses a proper ADT for setSocketOption and getSocketOption" at http://paste.lisp.org/display/21696
14:52:04 <x_> zarvok: yeah
14:52:17 <zarvok> seems like an obvious/necessary idea if we're going to use virtual memory, but I don't actually knowa nything about it
14:52:35 <x_> no, it actually doesn't really have anything to do with that
14:52:54 <lispy> okay, i read that page about arrows but i'm not sold on them
14:52:58 <zarvok> yeah, on second thought, I guess you're right
14:53:25 <mathewm> still reading the page on arrows... seems fairly compelling to me so far
14:53:45 <zarvok> I know when I took the OS course here, mine certainly didn't do anything like that, but had virtual memory
14:54:05 <zarvok> actually, if you tried to allocate more memory than there was available, everything went to shit real fast
14:54:17 <int-e> (re: the paste above) what I'm after is: a) is that a good idea (i.e. is the interface sound?) b) are there obvious things to simplify? c) where should the time_val struct handling go?
14:54:22 <x_> well that's exactly what happens with overcommit_memory
14:54:23 <lispy> i guess i haven't found that many uses of monads or limitations so i don't yet feel the need to reach for more power :)
14:54:24 <zarvok> What is linux's strategy?
14:54:29 <zarvok> heh
14:55:09 <x_> overcommit_memory is a hack that is supposed to boost performance at the expense of randomly nuking processes if memory actually does run out
14:55:12 <heatsink> int-e, Some socket options are not settable/gettable for some kinds of sockets.
14:55:23 <heatsink> They raise exceptions instead.
14:56:02 <heatsink> Oh, wait the {- -} made me think you had one big record type for some reason
14:56:03 <heatsink> nm
14:56:05 <zarvok> x:  I don't really understand though.  I mean, how do you actually "overcommit."  If you give out more virtual addresses than there is physical space, you've got overlap by pigeonhole, so now two people are writing on the same memory
14:56:48 <mathewm> yeah, why OOM-kill isntead of page-out?
14:57:58 <lispy> zarvok: sbcl (the common lisp compiler) uses overcommit
14:58:04 <lispy> it relies on it on linux
14:58:22 <zarvok> interesting, I guess I don't really understand how the idea makes sense
14:58:24 <x_> zarvok: well, with memory pages and stuff it's possible to move memory around
14:58:45 <zarvok> sure, I can keep it on disk
14:58:55 <int-e> it's convenient. allocate a big static array, never call sbrk()
14:58:56 <woggle> zarvok: Overcommitting means that there are a number of pages that aren't mapped yet, some of which could be mapped when they fault.
14:58:58 <mathewm> oh, it is overcommiting VM - if you don't have enough swap-space configured
14:59:09 <lispy> zarvok: when i heard the compiler writers talk about it, it seemed like a bad idea to me.  Made it really hard to port it to windows for example
14:59:32 <int-e> heatsink: na, they're all alternatives. the comments aren't from me either, just the values that got added to the constructors
14:59:59 <zarvok> woggle:  sounds a lot like copy-on-write, why is this exciting?
15:00:30 <zarvok> well, I guess, there they are mapped, just to space that is used by more than one proc, but still
15:00:43 <woggle> zarvok: It's similar. It's not copy-on-write so much as allocate-on-write which is typically how physical memory is allocated anyways. It's just that when you don't overcommit, you guarentee that the physical memory exists to handle any fault.
15:01:08 <zarvok> I see
15:01:40 <zarvok> So the basic idea is, tell everyone that they have enough memory always, and then sort it out when they actually try to use the pages?
15:01:45 <mathewm> so when does linux "commit" a portion of swap to a page?  As soon as it is used, or only when it is dirty and needs to be moved out of RAM?
15:01:54 <woggle> zarvok: Yes.
15:02:15 <woggle> zarvok: The theory is that 'usually' you won't have a problem.
15:02:21 <zarvok> heh
15:02:32 <x_> and the way linux "sorts it out" is that if there is a problem it kills your process :'(
15:03:06 <woggle> Well, it kills a process. I don't think it's neessairily yours. (;
15:03:13 <zarvok> lispy: so how did the lisp compiler use this idea?
15:03:22 <monochrom> Linux has learned from the airlines! XD
15:03:22 <int-e> and if you're unlucky, the process is some daemon that happens to need a few additional pages for a moment. (or has that been improved?)
15:04:33 <heatsink> int-e: I think the getSocketOption looks a little weird.
15:04:37 <lispy> zarvok: i don't remember a lot of the details, but it seems like they would over allocate and when a page fault was reported by the GC would be triggered
15:04:44 <heatsink> (Debug x) <- getSocketOption s (Debug undefined)
15:04:49 <lispy> s/by//
15:05:37 <heatsink> int-e: What does one usually do when a type is dependent on a value?
15:05:41 <zarvok> hmm, so the compiler is messing around with the page fault handler somehow?
15:06:17 <zarvok> don't you need, like, kernel ring permissions for that?
15:06:42 <heatsink> How does malloc() do it?
15:06:50 <zarvok> do what?
15:07:20 <x_> malloc uses system calls
15:07:21 <zarvok> I mean, malloc is a syscall, so you get thrown into kernel level
15:07:21 <int-e> heatsink: I don't know.
15:07:25 <heatsink> Oh, I guess it just keeps a pointe to the page boundary.
15:07:59 <heatsink> zarvok, malloc is user-level.  It can make the sbrk() syscall.
15:08:20 <int-e> heatsink: anyway, the template idea saves me the trouble of defining another set of labels. I guess I could have subsets of labels instead. Hmm. I don't like that.
15:08:29 <zarvok> yeah, I was imprecise
15:08:35 <zarvok> should have said uses a syscall
15:09:25 <zarvok> I still wonder how the lisp compiler generated code messes with the page fault handler.  I don't think there is a "mess with the page fault handler" syscall
15:09:38 <zarvok> But then, really you could fool me
15:09:47 <zarvok> my knowledge of systems level code is limited
15:10:12 <woggle> zarvok: Failed page faults often generate catchable signals.
15:10:30 <zarvok> ah, true
15:10:59 <zarvok> so the lisp binaries would check for a memory allocation failure and run GC, that makes sense
15:12:51 <zarvok> I guess I wasn't thinking, in the OS I wrote for class, a failed page fault killed your process :)
15:13:00 <heatsink> int-e, You could do it with associated types if they get implemented.
15:13:34 <int-e> let's pretend I want to stick to Haskell98 + FFI (and the stuff hsc2hs does)
15:14:19 <heatsink> Oh, I know.
15:14:21 <int-e> higher order types could probably help ...
15:14:29 <int-e> but they aren't H98 either.
15:14:47 <int-e> (they would allow one to write a more generic dispatcher)
15:14:51 <heatsink> getSockOption :: Socket -> (SocketOption -> a) -> IO (SocketOption a)
15:15:04 <heatsink> erm
15:15:09 <heatsink> getSockOption :: Socket -> (a -> SocketOption a) -> IO (SocketOption a)
15:15:27 <dmhouse> int-e, heatsink: what are you discussing?
15:15:40 <heatsink> Or is that a higher-order type?
15:15:48 <int-e> dmhouse: the thing I pasted above, http://paste.lisp.org/display/21696
15:16:25 <int-e> oh, hmm. that's actually a neat idea - pass the constructor in
15:16:38 <heatsink> yea... you could do that, and have it just return a instead of SocketOption a.
15:16:44 <int-e> the code can be left virtually unchanged, I can just apply it to 'undefined'.
15:16:49 <heatsink> yea
15:17:02 <int-e> yep, I like that.
15:17:24 <heatsink> yay :D
15:20:09 <int-e> Of course it's a bit more unsafe that way. But I guess that's acceptable.
15:21:23 <int-e> and we can do the same with setSocketOption - just let that thing take a constructor argument and a value.
15:21:24 <int-e> cool.
15:21:51 <roconnor> heatsink: there are a finite number of SocketOptions.  One just needs to write each function.
15:23:51 <roconnor> int-e: wouldn't that be simpler?
15:23:52 <heatsink> That's an option as well.
15:24:29 <int-e> roconnor: no. with heatsinks idea the whole case that I needed goes away.
15:25:43 <int-e> thanks heatsink :)
15:25:49 <heatsink> offtopic, is there an equivalent to the shell command 'which'?
15:26:29 <jer> heatsink, for... ?
15:27:04 <heatsink> determining what file would be executed if a filename were typed at the prompt.
15:27:25 <jer> what's wrong with which?
15:28:27 <jer> you might try "whereis" if your makewhatis db is up to date
15:28:32 <heatsink> I was hoping I could get the information without running a program.
15:28:38 <jer> oh
15:29:03 <lispy> heatsink: iirc which just searches the users $PATH
15:29:27 <jer> no there isn't.you could however, write your own; get the PATH environment variable, split it with a : delimiter, and then iterate over each item checking to see if a file exists in one of those locations
15:29:32 <jer> returning the first match (that's how which works)
15:29:34 <lispy> heatsink: so you could emulate it by grabbing $PATH, parsing it, and then searching the directiories listed
15:29:41 <int-e> heatsink: oh. there's a problem: I want to convert CInt <-> Int, CInt <-> Bool, etc. hmm.
15:29:44 <Korollary> what if it's aliased?
15:30:32 <lispy> Korollary: in bash, which doesn't seem to understand aliases
15:30:59 <int-e> heatsink: which can be done with a type class and functional dependencies, but not without them. I think.
15:31:58 <heatsink> int-e: You could do it with a big case statement.
15:32:33 <int-e> true.
15:32:41 <jer> lispy, that's a bash deficiency; other shells like zsh, tcsh, etc will tell you it's aliased
15:32:57 <jer> % alias z=ls; which z           [18:32:27]
15:32:57 <jer> z: aliased to ls
15:33:53 <lispy> this reminds me that i wish pathes in bash were regular expressions
15:36:08 <eivuokko> heatsink, System.Directory.findExecutable seeks through PATH, but iirc it doesn't actually check if file is executable (on all versions and platforms)
15:36:41 <heatsink> ok
15:36:57 <int-e> heatsink: ok, it's still an improvement in the interface because now it matches the old one.
15:38:30 <heatsink> int-e: Hmm, I'm not sure if that'll typecheck actually.
15:40:00 <heatsink> might want to make sure you can find a way to do it.
15:40:12 <lisppaste2> int-e annotated #21696 with "simple modified getSocketOption" at http://paste.lisp.org/display/21696#1
15:42:03 <heatsink> oh yea, that should work.
15:42:18 <heatsink> You just can't make it be an IO a, even though that would make sense.
15:42:48 <int-e> hmm. that seems to be hard, yes.
15:42:55 <heatsink> I'm going to ask about that on the mailinglist, I'm sure someone knows enough about type theory to explain why.
15:43:08 <int-e> well, impossible.
15:43:25 <int-e> you could always pass in a  \x -> undefined :: SocketType
15:43:41 <int-e> err. SocketOptions
15:44:56 <int-e> using functional dependencies, I'd make a class ConvertSO a b | a -> b where fromSO :: a -> b, toSO :: b -> a
15:45:48 <int-e> with instances ConvertSO Int CInt, ConvertSO Bool CInt, ConvertSO ClockTime ClockTime (with the current hack)
15:47:46 <heatsink> oh, I'm just being slow.  That probably means it's time to eat.
15:48:52 <int-e> I can, however, put the getSocketOption and setSocketOption themselves into a type class.
15:49:08 <int-e> wee.
20:04:36 <davidmccabe> Hi folks. I would like to integrate PHP and Haskell code. I know this is crazy, but has anybody done it? Googling turned up nothing.
20:07:01 <dons> in what way do you mean "integrate" ?
20:07:08 <dons> call php from hsakell, or call haskell from php?
20:07:17 <lispy> davidmccabe: can you make bindings for C code in php?
20:07:44 <lispy> davidmccabe: if so you could export haskell functions via the ffi and use them in php
20:07:57 <lispy> calling php from haskell might be trickier
20:09:05 <davidmccabe> Call haskell from PHP.
20:09:16 <dons> that's the harder path, i think
20:09:20 <davidmccabe> What I want to try is to gradually migrate a large application from PHP to Haskell.
20:09:21 <dons> but can be done if you can call C
20:09:33 <davidmccabe> Does that sound feasible at all?
20:09:52 <dons> perhaps you can just delimit the app into separate programs that communicate over pipes or some channel
20:10:00 <dons> avoiding the need for ffi issues
20:10:10 <davidmccabe> sure.
20:10:12 <dons> otherwise, you'll need to investigate how to bind to C code from php
20:10:27 <dons> and then write C code that calls into haskell, and call that C code from php
20:10:33 <davidmccabe> So then, I would need to bind Haskell to C, bind PHP to C, and create a little glue library between the two?
20:10:56 <dons> right
20:11:03 <dons> luckily binding Haskell to C is easy
20:11:25 <dons> its a good question to ask on haskell-cafe@haskell.org
20:11:33 <davidmccabe> ok. thanks!
20:11:33 <dons> maybe someone has asked or thought about this before
20:12:07 <davidmccabe> Well, the thing is, rewriting an app of this size all at once is infeasible. You know?
20:12:17 <dons> yep, fair enough
20:12:22 <dons> better to do it piece by piece
20:12:27 <davidmccabe> But it really would fit the functional model well, I think.
20:13:00 <lispy> does the php interpreter allow you to embed it in C?
20:13:13 <davidmccabe> So I'm thinking the plan will be to (1) factor parts of it into modules in PHP that are functional and then (2) rewrite those modules in haskell.
20:13:18 <lispy> if so you could have an easy route by making haskell a php interpreter
20:14:04 <davidmccabe> on the other hand, maybe step 1 will be enough. In any case, thanks for the pointers. 
20:17:33 * lispy was going to work on COM in haskell but was too lazy to go to work on a saturday
20:17:43 <lispy> if i had MS office at home i wouldn't even need to go to work :(
20:35:44 <petekaz> What's the best implementation for an OSX machine?
20:37:27 <lispy> petekaz: i'd go with Apple's :)
20:37:41 <lispy> petekaz: are you asking if intel or ppc is better?
20:37:54 <lispy> the ppc runs cooler from what i've heard...but i don't know if they are still selling them
20:38:27 <petekaz> No, I have both, I just want to know of a haskell implementation that I can run on any of my macs.
20:39:00 <petekaz> I use GHC on my linux box, but that's not available for the mac if I understand it correctly.
20:42:09 <petekaz> oh nevermind, I found a ghc for the mac.
20:44:05 <lispy> petekaz: yeah, i use the version in darwin ports, it tends to be updated but waiting for it to compile literally takes like 6 hours
20:53:25 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "Vote on a European #haskell get-together", "http://snappoll.com/poll/84228.php"]'
20:53:25 --- topic: set by kosmikus on [Mon Jun 12 09:18:44 2006]
20:57:55 <Cale`> ack
20:58:42 <Cale> stupid netsplits
20:59:35 <lispy> Cale: that wasn't just a net split
20:59:48 <lispy> more of a hostile take over really
21:00:00 <tessier> There is a compromised O line...again
21:00:21 <lispy> what is an o line?
21:05:27 <Spark> irc op
21:18:48 <lispy> heh, this is great: http://www.google.com/search?q=spelng%20erores
22:13:19 <wolverian> hm, does mkMapGraph in Data.Graph.Inductive.NodeMap only support nodes with only one edge in and out? it throws an exception when I try to add a new edge into an existing node. I would have expected it to simply add the edge.
22:20:16 <dons> ?vers
22:20:17 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
22:20:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:21:20 <dons> ?yow
22:21:21 <lambdabot> I know things about TROY DONAHUE that can't even be PRINTED!!
22:21:45 <wolverian> I guess I'll just have to make the contexts myself. grawr, at 8 am that feels like climbing a mountain :)
22:23:31 <dons> :)
22:44:50 <wolverian> oh, never mind. I just had to nub the nodelist before giving it to the mkGraph
22:48:01 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "Vote on a European #haskell get-together", "http://snappoll.com/poll/84228.php'
22:48:01 --- topic: set by kosmikus on [Mon Jun 12 09:18:44 2006]
22:51:03 <RyanT5000> how do i use the generic form of Data.Edison.Seq.null?
22:51:28 <RyanT5000> it won't let me import Data.Edison.Seq, and Data.Edison.Seq.SimpleQueue.null is specialized
22:51:42 <RyanT5000> and importing Data.Edison alone doesn't seem to do it either (although it seems like it should)
22:52:42 <RyanT5000> how does this work? Data.Edison.Sequence is defined, which is a class with the function null in it, but Data.Edison.null isn't
22:55:41 <RyanT5000> nevermind; it was a Cabal issue
23:48:15 <dons> well that's very good. got this week's HWN out in record time. yay for automation!!
23:54:07 <lorne> there seem to be odd spaces in HWN
23:54:49 <xerox> lambdabot: yow
23:54:59 <xerox> lambdabot: @yow
23:55:00 <lambdabot> Don't SANFORIZE me!!
23:56:04 <dons> which issue, lorner? .txt, .rss? .html?
23:56:15 <dons> lorne sorry. typing on the couch
23:56:38 <lorne> html, "making it easie r to", "are g oing"
23:56:43 <dons> .txt and .html look ok to me. but there could be bugs in my publishing script.
23:56:53 <dons> where are you reading that?
23:57:06 <lorne> http://sequence.complete.org/
23:57:08 <lambdabot> Title: "The Haskell Sequence - News about Haskell"
23:57:19 <dons> (hwn is published in multiple places)
23:57:39 <dons> hmm. weird. does haskell.org look ok?
23:57:54 <lorne> looking at the source, I note every line is of the same length
23:58:11 <dons> i think it must be the sequence.org publishing/font code
23:58:22 <dons> since the original source has now oddities
23:59:06 <xerox> You added them in? :P
23:59:26 <dons> "no" odditiies. i just upload a .html body
23:59:38 <dons> here's the content src: http://www.cse.unsw.edu.au/~dons/code/hwn/archives/20060625.html
23:59:39 <lambdabot> Title: "Haskell Weekly News: June 25, 2006"
