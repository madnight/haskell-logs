01:44:02 <atilaromero> data Matriz a = Matriz [[a]] deriving (Show, Eq)
01:44:03 <atilaromero> instance Num Matriz where
01:44:03 <atilaromero>     (+) c d = 1
01:44:40 <atilaromero> does not work, but 
01:44:42 <atilaromero> data  Matriz = Matriz [[Integer]] deriving (Show, Eq)
01:44:42 <atilaromero> instance Num Matriz where
01:44:43 <atilaromero>     (+) c d = 1
01:44:46 <atilaromero> does
01:44:59 <atilaromero> Any clue?
01:45:43 <Lemmih> instance Num (Matriz a) where?
01:46:15 <Lemmih> Perhaps even 'instance Num a => Num (Matriz a) where' if you want to do something sensible.
01:46:54 <atilaromero> Yes, it worked now!
01:47:00 <atilaromero> Thanks!
02:14:11 <dcoutts> @yarr!
02:14:12 <lambdabot> Get out of me way, yeh landlubber
02:49:40 --- mode: ChanServ set +o dmhouse
02:50:41 <ski> dmhouse : yes
02:51:06 <dmhouse> ski, Hehe. Cool. I'd always wondered that since learning about the SKI calculus.
03:00:32 <ski> i just took whatever nick came into my mind, when i started ircing ..
03:57:27 <vincenz> ahio
03:59:23 <dmhouse> Hey there vincenz.
03:59:48 <vincenz> que pasa?
04:00:00 * dmhouse is reading up on wget.
04:00:22 <dmhouse> I had a cool idea for an emacs script.
04:00:46 <dmhouse> It'd basically be a VC backend for wikipedia files so you could treat them as being under version control.
04:01:54 <sieni> dmhouse: dude, hey: scripting emacs is like masturbating to goatse
04:02:16 <dmhouse> True.
04:03:38 <vincenz> goatse?
04:03:49 <Pete_I> vincenz, don't ask
04:03:59 <Pete_I> you don't wanna know
04:04:01 <JKnecht> n' tubgirl.
04:04:14 <JKnecht> they're twins
04:04:16 <dmhouse> Oh, hang on.
04:04:24 <dmhouse> sieni: What did you mean, less colloquially?
04:06:01 <jn> ... was goatse and tubgirl just mentioend in #haskell?
04:06:13 <jn> do i have no refuge from idiocy?
04:06:29 <Pete_I> nope.
04:06:36 <jn> :(
04:06:59 <Pete_I> RL maybe, but probly not.
04:07:06 <Pete_I> plenty of idiots there too
04:07:09 <jn> Pete_I: In NYC? Hardly.
04:07:22 * resiak hands out overheardinnewyork ;)
04:07:31 <vincenz> gross
04:07:37 <jn> resiak: :)
04:07:45 <sieni> priceless: I was drying my juggling balls, since a friend of mine soaked one of them yesterday
04:07:48 <Pete_I> never heard of it, don't wanna know.
04:07:48 * resiak wonders if jn has featured on oiny
04:07:49 <sieni> in gas oven
04:08:00 <jn> resiak: no sir.
04:08:01 <sieni> result -> 7 completely destroyed beanbags
04:08:22 * vincenz shudders
04:08:30 <vincenz> DAMNN YOU sieni and jn 
04:08:31 <vincenz> DAMNN YOU sieni and JKnecht 
04:08:52 <vincenz> I can't believe they show such graphic things on wikipedia
04:09:19 <Pete_I> vincenz, i can.
04:09:35 <Pete_I> it's wiki-pedia
04:09:37 <sieni> vincenz: what did I do :-O
04:09:39 <Pete_I> duh :)
04:11:06 <resiak> Wikipedia are allowed to show it because they're taking a neutral point of view, or something?
04:11:16 <Pete_I> yes
04:11:33 <Pete_I> wikipedia's articles are supposed to all be neutral in view.
04:11:52 <Pete_I> displaying fact, not opinion. if they display opinion, they show both sides.
04:12:16 <Pete_I> or atleast, that's how it's supposed to work
04:12:43 <int-e> vincenz: well you sure learnt something today that you won't forget soon
04:12:44 <JKnecht> allowed? This is the intarweb, we don't need no stinkin permission! And anyway what global authority would grant it?
04:12:49 <vincenz> they could describe the phenomenon without attaching pictures
04:13:13 <vincenz> int-e: that and other things, like lemonsomething, and eel something
04:13:28 * int-e won't ask.
04:14:09 <jn> wikipedia is pretty decent i think.
04:14:25 <dmhouse> Wikipedia is the best thing on the internet.
04:14:31 <Pete_I> it is nice. lots of information.
04:15:28 <jn> some articles are quite bad, but most are good quality.
04:15:31 <jn> it's a good place to start.
04:23:02 * vincenz reboots and goes grocery shoppin
05:05:44 <Pete_I> is there a difference between Prelude.mod and Prelude.rem?
05:05:52 <Pete_I> @type Prelude.mod
05:05:54 <lambdabot> forall a. (Integral a) => a -> a -> a
05:05:58 <Pete_I> @type Prelude.rem
05:06:00 <lambdabot> forall a. (Integral a) => a -> a -> a
05:06:13 <Pete_I> they seem to be the same.
05:06:27 <BCoppens> isn't the difference in behaviour with negative numbers?
05:06:51 <dmhouse> Yep.
05:06:56 <dmhouse> > (-2) `mod` 2
05:06:57 <lambdabot>  0
05:07:00 <Pete_I> > rem -4 5
05:07:00 <lambdabot>  add an instance declaration for (Num (t -> a -> a -> a))
05:07:10 <dmhouse> > 2 `mod` (-2)
05:07:11 <lambdabot>  0
05:07:12 <Pete_I> > rem (-4) 5
05:07:13 <lambdabot>  -4
05:07:13 <dmhouse> Hang on
05:07:25 <dmhouse> > 7 `mod` (-3)
05:07:26 <lambdabot>  -2
05:07:29 <dmhouse> > 7 `rem` (-3)
05:07:30 <lambdabot>  1
05:07:33 <BCoppens> :)
05:07:57 <Pete_I> ...
05:08:18 <Pete_I> how's mod get -2 from that?
05:08:22 <Pete_I> oh, nvm
05:08:35 <Pete_I> how's rem get 1 from that?
05:09:01 <BCoppens> 1 == -2 (mod 3)
05:09:35 <dmhouse> 7 = k*(-3) + r. Both r = -2 and r = 1 work.
05:26:37 <dmhouse> Can any of the XML libs do XPath?
05:27:11 <dmhouse> Ah, both HaXml and HXT can. Which is the more lightweight?
05:49:52 <dmhouse> @type unzip
05:49:53 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
05:52:24 <dmhouse> Does HXT actually have any decent documentation anywhere?
05:58:15 <dcoutts> @type \p h t j f z s = (fold f z . map j . unfold p h t) s
05:58:16 <lambdabot> parse error on input `='
05:58:24 <dcoutts> @type \p h t j f z s -> (fold f z . map j . unfold p h t) s
05:58:25 <lambdabot> Not in scope: `fold'
05:58:25 <lambdabot>  
05:58:25 <lambdabot> <interactive>:1:38: Not in scope: `unfold'
05:58:40 <dcoutts> @type \p h t j f z s -> (foldr f z . map j . Data.List.unfold p h t) s
05:58:41 <lambdabot> Not in scope: `Data.List.unfold'
05:58:51 <dcoutts> @hoogle unfold
05:58:52 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
05:58:52 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:58:52 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
05:58:52 <jethr0> unfoldr?
05:58:57 <dcoutts> @type \p h t j f z s -> (foldr f z . map j . Data.List.unfoldr p h t) s
05:58:58 <lambdabot>   The function `unfoldr' is applied to three arguments,
05:58:59 <lambdabot>   but its type `(b -> Maybe (a, b)) -> b -> [a]' has only two
05:59:03 <dcoutts> bah
05:59:14 <dmhouse> dcoutts: what are you trying?
05:59:21 <dcoutts> different definition of unfold
05:59:29 <dcoutts> oh, it's a hylomorphism
06:00:29 <jethr0> dmhouse: do these help? http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/index.html http://www.fh-wedel.de/~si/HXmlToolbox/thesis/index.html
06:00:42 <jethr0> but i guess you had seen those already :)
06:00:57 <dmhouse> The Haddock docs are woefully incomplete.
06:01:14 <dmhouse> His thesis helped a little but didn't seem to explain, e.g., the HTTP feaures.
06:01:16 <jethr0> yes, i had gathered as much when i glanced over them some time ago
06:02:33 <dcoutts> @type let unfoldr p h t s = if p s then [] else h s : unfoldr p h t (t s) in  \p h t j f z s -> (foldr f z . map j . Data.List.unfoldr p h t) s
06:02:35 <lambdabot>   The function `unfoldr' is applied to three arguments,
06:02:35 <lambdabot>   but its type `(b -> Maybe (a, b)) -> b -> [a]' has only two
06:02:43 <dcoutts> @type let unfoldr p h t s = if p s then [] else h s : unfoldr p h t (t s) in  \p h t j f z s -> (foldr f z . map j . unfoldr p h t) s
06:02:44 <lambdabot> forall b b1 a a1. (a1 -> Bool) -> (a1 -> a) -> (a1 -> a1) -> (a -> b1) -> (b1 -> b -> b) -> b -> a1 -> b
06:03:40 <bolrod> O_O
06:05:29 <dmhouse> @hoogle Result
06:05:30 <lambdabot> Test.QuickCheck.Result :: Maybe Bool -> [String] -> [String] -> Result
06:05:30 <lambdabot> Test.QuickCheck.Result :: data Result
06:05:30 <lambdabot> Distribution.InstalledPackageInfo.ParseResult :: data ParseResult a
06:07:09 <dmhouse> @hoogle exitFailure
06:07:10 <lambdabot> System.exitFailure :: IO a
06:07:10 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
06:14:24 <petekaz> Anyone here use clean?  How does it compare to haskell?
06:14:53 <petekaz> Just reading about Brian Hulley's claim on the mailing list that lazyiness is more of a burden than a blessing.
06:15:20 <petekaz> He claims that more times than not, he fights laziness and wants strictness, and also claims laziness results in slower programs.
06:15:34 <petekaz> I think his point was basically, the language would be much better if it were by default strict, with the option to do laziness.
06:15:47 <petekaz> And I started wondering if others felt the same?
06:15:57 <petekaz> And then Bulat Ziganshin suggested Clean.
06:23:45 <dmhouse> Do POSIX regexes have lookaheads?
06:23:48 <dmhouse> Specifically negative ones?
06:24:55 <wolverian> man regex
06:25:06 <dmhouse> Alternatively formulated, how might I match <text>Lots of stuff, which might contain <...</text>?
06:25:19 <dmhouse> wolverian: Ah, nice.
06:26:02 <wolverian> dmhouse, with an XML/SGML parser.
06:26:22 <dmhouse> I don't want a full XML parser, as I only want the contents of this one tag.
06:26:31 <petekaz> dmhouse: just use non-greedy .*? no?
06:26:32 <dmhouse> That would be a massive dependency for a trivial task.
06:26:46 <dmhouse> petekaz: not in POSIX regexes.
06:26:48 <petekaz> <text>.*?</text>
06:26:54 <dmhouse> petekaz: which is _very annoying_.
06:27:31 <petekaz> I'm so used to perl and python and ruby.
06:27:40 <petekaz> POSIX who?
06:27:43 <petekaz> :-)
06:27:55 * dmhouse longs for JRegex to be bundled with GHC
06:28:24 <petekaz> I want to see a fps regex engine.
06:28:51 <petekaz> String processing without fps is just too slow.
06:28:52 <dmhouse> Grr. This should be so easy!
06:29:08 <wolverian> dmhouse, what about '<text>foo<text>bar</text>baz</text>'? what do you want to match?
06:29:28 <dmhouse> wolverian: There are no nested <text>s.
06:30:42 <vincenz> even if there are
06:30:45 <vincenz> .* is greedy
06:30:47 <wolverian> oh, POSIX doesn't have non-greedy modifier? weird.
06:31:13 <dmhouse> Nope.
06:31:41 <wolverian> is perl too big a dependency?
06:32:05 <dmhouse> :P
06:32:12 <petekaz> dmhouse: is this for a new lambdabot plugin?
06:32:30 <dmhouse> petekaz: Afraid not :)
06:32:48 <dmhouse> wolverian: throwing my input to perl would be senseless. I'd rather depend on JRegex
06:32:52 <wolverian> oh, well, I'm used to the CPAN mentality. just use a module! 
06:33:13 <wolverian> (it applies to haskell as well, I think, at least once there's a repository...) 
06:33:31 <dmhouse> Yeah. Once cabal-get works dependencies will be a lot less hassle.
06:33:55 <wolverian> right. :)
06:45:16 <vincenz> dmhouse: use ruby?
06:45:27 <petekaz> I do.
06:45:27 <dmhouse> vincenz: Why?
06:45:31 <vincenz> :P
06:45:35 <vincenz> dmhouse: for the regexp stuff
06:45:38 <vincenz> it's better than perl
06:45:49 <dmhouse> I'm not using perl either. I'm using JRegex.
06:45:51 <wolverian> let's start a holy war.
06:45:52 <petekaz> in what respect?
06:46:23 <wolverian> dmhouse, by the way, if you are depending on a library anyway, why not an XML one?
06:46:47 <dmhouse> JRegex is tiny.
06:46:47 <petekaz> are the haskell xml libraries any good?  
06:46:52 <vincenz> wolverian: yeah, I'll be the crusaders
06:47:05 <wolverian> dmhouse, that's always nice. :)
06:48:09 <petekaz> I have a haskell question, reading the paper on writing a memoization function in haskell (weak.pdf).
06:48:23 <vincenz> petekaz: link would be better
06:48:45 <petekaz> @google marlow weak memoization
06:48:47 <lambdabot> http://citeseer.ist.psu.edu/context/579922/58662
06:49:38 <vincenz> petekaz: what is the question
06:50:03 <petekaz> My question: if I have a function called memo :: (a -> b) -> (a -> b)
06:50:16 <petekaz> in the paper they then use it liek this:
06:50:45 <petekaz> memo (\b a c -> f a b c) to memoize on the 2nd arg of a 3 arg function f.
06:51:09 <petekaz> I don't understand that?  I thought memo took a 1 arg function, not a 3-arg.
06:51:53 <petekaz> I'm sure this is basic currying, but I still get a little confused.
06:53:25 <petekaz> \b a c -> f a b c is really just a one arg function of: \b -> \a -> \c -> f a b c right?
06:53:36 <petekaz> and this is why it works?
06:55:48 <ski__> yes
06:55:57 <petekaz> ok.
06:55:59 <petekaz> thanks.
06:56:31 <ski__> all haskell functions strictly speaking always take exactly one argument
06:57:38 <dmhouse> \a b c -> e is syntactic sugar for \a -> \b -> \c -> e (or it could be), and Foo -> Bar -> Baz is syntactic sugar for Foo -> (Bar -> Baz).
06:57:47 <petekaz> right. I'm used to the call a function with less args and you get the curried function, it was just seeing teh 3-arg function above passed to memo that *looked* different to me.
07:04:37 <ski__> hrm, i'd say the latter is just operator precedence
07:04:47 <ski__> same as 'x / y / z' means '(x / y) / z'
07:04:50 <ski__> so, the (->) operator (at type level) associates to the right
07:04:53 <ski__> i guess you could call this syntactic sugar, but then it's really operator precedence that is this sugar
07:10:54 <dmhouse> Right. The point I was trying to make was that a function Foo -> (Bar -> Baz) is actually a function in one argument which returns a function from Bar -> Baz.
07:12:09 <ski__> yes
07:28:52 <shapr> xerox: Wow, that's weird.
07:30:26 <shapr> petekaz: I think problems with laziness is a cultural problem.
07:31:08 <petekaz> I think I'm starting to realize this.
07:31:32 <petekaz> Lots of people complaining about things that they just haven't learned how to use correctly.
07:32:04 <dmhouse> shapr: The problems with laziness or the problems with strictness?
07:34:47 <dmhouse> That Haskell show-offs email to the mailing list was interesting. It'd be great to see some Haskell videos.
07:36:26 <petekaz> I stated this on this channel several months ago as well.
07:36:45 <petekaz> It would really help the newbies such as myself.
07:38:53 <shapr> dmhouse: I think laziness is just as powerful/fast as strictness, but it has a totally different balance.
07:39:57 <dmhouse> shapr, hmm. You're saying people who find speed benefits by strictifying everything just aren't writing lazy code in the right way?
07:41:06 <shapr> Yeah, I think they're trying to write strict algorithms in a lazy language.
07:42:22 <dmhouse> That's interesting.
07:43:21 <shapr> Lots of people don't agree with me, but that's still my conclusion so far.
07:43:38 <shapr> I'd like to read Cale's article on Laziness that he's considering writing.
07:43:55 <petekaz> considering?  
07:44:06 <petekaz> That sounds interesting!
07:46:06 <shapr> Have you read Okasaki's writings on amortized algorithms?
07:46:12 <apfelmus> hi there, i wonder what this strictness discussion is all about. i often exploit laziness to great profit and sometimes use a seq to keep the stack from exploding.
07:46:35 <apfelmus> i mean, does strictness matter that much in reality?
07:46:43 <shapr> Yeah, I've discovered big benefits to laziness myself. I like the lazy pipeline approach for incremental processing.
07:46:43 <dmhouse> apfelmus: Got an example of your explotations of laziness?
07:47:04 <apfelmus> dmhouse: dynamic programming?
07:47:06 <wolverian> hm, our CS dept has picked haskell as the language for the 'introduction to functional programming' course. they used to use scheme, I think. neat.
07:47:18 <dmhouse> wolverian: Yay! :)
07:47:26 <wolverian> it'll be my first experience of learning haskell in a real educational environment
07:47:37 <wolverian> looking forwards to the explanation of monads :)
07:48:16 <shapr> wolverian: Spiffy!
07:48:27 <wolverian> yeah, it's great. :) 
07:48:35 <dmhouse> I'll be teaching Haskell at my school next year, looking forward to that.
07:48:36 <shapr> Do you know who's teaching the course?
07:48:49 <shapr> dmhouse: Which uni?
07:49:03 <wolverian> shapr, prof Matti Nykänen.
07:49:12 <wolverian> (a local, I think :) )
07:49:29 <dmhouse> shapr, not a uni.
07:49:49 <shapr> Sinä oletko suomalainen?
07:49:56 <wolverian> olen. 
07:49:58 <shapr> whoops
07:50:08 <wolverian> (the word order was a bit strange, but understandable nevertheless. :)
07:50:12 * shapr grins
07:50:18 <shapr> I never was very good at Finnish.
07:50:36 <wolverian> very few are.
07:50:42 <shapr> Not even Finns?
07:50:57 <wolverian> are common english speakers good at english? 
07:51:03 <shapr> Oh, I see your point.
07:51:12 <shapr> dmhouse: What sort of school then?
07:51:15 <wolverian> so it comes to a matter of population. 
07:51:21 <wolverian> (less writers.)
07:51:26 <int-e> fewer :)
07:51:29 <wolverian> (I mean, literary authors)
07:51:34 <wolverian> int-e, thanks. :)
07:52:14 <dmhouse> shapr, the students will be between about 15 and 18.
07:52:57 <petekaz> dmhouse: have pity on them, start them with something easier!  I'm 32 and am finding haskel to be a difficult language to learn.
07:53:27 <ski__> i have this idea that a mixed strict and lazy language would be best .. and depending on which type you use, it becomes strict or lazy
07:53:43 <wolverian> ski__, that's what we're doing with pugs/perl6.
07:53:52 <wolverian> at least, planning to do...
07:54:04 <dmhouse> petekaz: what qualifications do you have?
07:54:16 <wolverian> (the whole typing affair is still somewhat underspecified. help is welcome.)
07:54:52 <ski__> wolverian : ok
07:55:23 <wolverian> ski__, http://dev.perl.org/perl6/doc/synopsis.html is the current specification, if you're interested.
07:55:26 <lambdabot> Title: "Synopses - perl6"
07:55:33 <ski__> so, one would have e.g. both strict and lazy records (or however one casts them in the actual language)
07:55:55 <wolverian> we're saying that lists are lazy and scalars are strict.
07:56:11 * apfelmus shakes his head lazily
07:56:14 <wolverian> (or rather, that list context is lazy and scalar context is strict - but you'd have to know what context means in this context.)
07:56:26 <petekaz> dmhouse: qualifications?  what languages do I already know?  python, ruby, java, c, some erlang, some CL, some Scheme.
07:57:01 <ski__> also, i'm trying to think about this from POV of linear logic, so (at least in work ideas) i think i want to have the "of-course" of linear logic (and it would be very cool if the rest could be integrated, too)
07:57:10 <dmhouse> petekaz: hmm. And what kind of educational background?
07:57:15 <petekaz> dmhouse: I know that I'm not alone in the opinion that haskell has a steep learning curve.
07:57:48 <dmhouse> petekaz: no, of course not. But, to quote Cale, 'It's about as difficult as learning to program again'.
07:57:49 <ski__> wolverian : context ?  like in what the surrounding program expects in that position ?
07:58:07 <petekaz> dmhouse: mis degree (half cs, half business)  I've taken the typcial data structure courses, OS courses, etc ...
07:58:15 <wolverian> ski__, right.
07:58:19 <ski__> ok
07:58:30 <wolverian> ski__, I guess there aren't many different contexts to use the word context in :)
07:58:41 <wolverian> (yeah, I'm having fun.)
07:58:55 <ski__> :)
08:00:17 <petekaz> dmhouse: no matter, no 15 year olds are going to have more qualifications than I have to start learning haskell.
08:00:36 <dmhouse> petekaz: Okay, thanks. :) I think it should be reasonably accessible to someone with some knowledge of mathematics. I think previous programming experience doens't help that much. It could even hinder, because you keep drawing false parallels.
08:02:01 <petekaz> probably.
08:02:13 <wolverian> ski__, the 'of-course' would encode laziness?
08:02:14 * ski__ remembers he couldn't put down his haskell book easily, when learning haskell :)
08:02:37 <int-e> Anyone could learn Lisp in one day, except that if they already knew Fortran, it would take three days. (Marvin Minsky)
08:02:37 <ski__> wolverian : not totally, but it's a bit related i think, yes
08:02:42 <petekaz> ski__: what book did you use?
08:03:43 <ski__> wolverian : records as used in OO is a typical example of lazy (module caching) structure
08:03:58 <ski__> petekaz : "Haskell : The Craft of Functional Programming"
08:04:14 <ski__> (arg, s/module/modulo/)
08:04:16 <wolverian> ski__, what is 'record' in OO?
08:04:29 <ski__> the record/struct of methods
08:04:39 <wolverian> right. 
08:04:41 <petekaz> I bought Bird's, will start reading it after I finish SICP.
08:04:52 <wolverian> you usually do want caching too. :) 
08:05:21 <ski__> yes, but that's an orthogonal feature
08:05:34 <wolverian> yeah.
08:05:48 <ski__> (which is more related with 'of-course')
08:06:11 <wolverian> is the record here mutable?
08:07:26 <ski__> which record ?
08:07:49 <ski__> i usually think in terms of immutable records
08:08:14 <wolverian> any record you want to use as an example. more to the point, is mutability relevant to the of-course
08:08:21 <wolverian> s/$/?/
08:08:45 <ski__> (one could model a mutable record as having fields containing some kind of references into the current state, where the real mutable cell is held)
08:09:10 <wolverian> weird. wikipedia's monads in fp page is actually helpful now. I wonder if it has been edited, because I remember it was incomprehensible a few months ago.
08:09:11 <ski__> no, i think it's not so relevant to of-course
08:09:39 <ski__> wolverian : i think i read on the discussion page that it has been edited, yes (but don't recall when)
08:09:58 <ski__> maybe i should explain what 'of-course' is about ?
08:10:21 <wolverian> sure.
08:10:52 <wolverian> it's useful if both parties of the discussion understand what they're discussing.. and I'm not very strong on linear logic. :)
08:11:06 <ski__> ok, in linear logic, proofs of propostions isn't always true, generally .. so to speak
08:12:09 <ski__> more specifically, when you use an assumption (i.e. the proof of an assumed proposition), it is *used*up*, so you can't later use it again (unless you happen to get hands on a new proof of it (possibly with same structure/value))
08:12:24 <ski__> ok ?
08:12:28 <ski__> example ?
08:12:41 <wolverian> I get that much, I think.
08:12:56 <wolverian> (the wikipedia page on linear logic has a few examples, I can check those.) 
08:13:09 <ski__> yes (possibly the pizza example is there :)
08:13:37 <wolverian> vending machine :)
08:13:57 <wolverian> well, the using up example uses butter and milk.
08:14:09 <ski__> now, according to Curry-Howard correspondance, propositions in a logic can correspond to types in a programming language, and proofs in that logic then corresponds to programs (i.e. expressions) in that programming language
08:14:48 <wolverian> yeah.
08:15:14 <ski__> so, this means that in such a programming language, corresponding (more or less closely to linear logic), values can't always be used freely
08:16:12 <ski__> e.g. if you have an array, you can pass it to an "update" function, which returns a new array value, but since one can't refer to the old array anymore, an implementation can use the update-in-place optimisation to get O(1) update of an array
08:16:21 <wolverian> ah! 
08:16:49 <ski__> so, from the point of the programming language, you're handling a succession of different array values, whose implementation share the same memory area
08:17:02 <ski__> this is e.g. being done in Clean and Mercury
08:17:30 <psykotic> ski: is there any substantial difference between uniqueness and linear types
08:17:38 * psykotic was never clear on that
08:18:49 <ski__> also, one can have a type 'RealWorld' that describes the current state of the world, and since one uses it linearly, one can use the update-in-place optimisation there, too (indeed, to not do this would be very expesive in many cases (keeping old logs of history), and impossible in other cases)
08:20:45 <ski__> psykotic : alas, i've not closely looked in detail at e.g. the uniqueness typeing system of Clean .. but at least one difference i think is that in Clean, a unique value is only prohibited from being used more than once .. i.e. you can still discard it implicitely, by just abstaining from using it
08:21:02 <psykotic> right
08:21:06 <ski__> anyway, 'of-course'
08:21:08 <psykotic> so, err, affine types? hehe
08:21:13 * psykotic can't remember all that terminology
08:21:18 <ski__> yes, is seems more or less that
08:21:59 <psykotic> i wonder if the reversible computing folks have looked at linear types
08:22:06 <ski__> 'of-course' is used to, in a controlled fashion, regain the possibility of using some values other number of times than one
08:22:33 <ski__> because, it's tedious to pass things to 'copy' functions, when one wants to reuse them
08:22:52 <ski__> (s/'copy' functions/type-sepcific 'copy' functions/)
08:23:00 <ski__> wolverian : hm, have i lost you ?
08:23:11 <wolverian> nah, I'm just thinking.
08:23:17 <wolverian> thanks for the explanation.
08:23:37 <psykotic> ski: ever looked at reversible computing?
08:23:52 <ski__> psykotic : just very briefly
08:24:05 <psykotic> then i'm sure you see the linear types relevance
08:24:33 <ski__> yes, but reversability is stronger than with linearity
08:24:48 <ski__> it's easy to have linear functions that still is not reversible
08:25:06 <ski__> (at least, that's my impression of reversability)
08:25:45 <psykotic> i was referring to how discarding values in a linearly typed system corresponds to resetting a memory cell to 0 in a typical reversible computing architecture
08:26:05 <ski__> mhm
08:26:15 <psykotic> conceptually resetting a memory cell to 0 actually puts the existing memory cell value on a "garbage stack"
08:26:41 <psykotic> so if you consider the total state of the system to be compromised by both the memory store and this garbage stack, you still have a reversible computer
08:26:48 <ski__> discard :: forall a. a -> ()
08:27:05 <psykotic> however, the garbage stack is not reified within the system and is mostly a conceptual construct.
08:27:13 <ski__> hm
08:27:20 <ski__> how about reusing, then ?
08:27:36 <psykotic> reusing?
08:27:40 <ski__> (er, 'discard :: forall a. !a -> ()' i meant)
08:27:44 <ski__> "copying"
08:27:57 <ski__> copy :: forall a. !a -> (!a,!a)
08:28:01 <psykotic> right. so, generally people use an EXCH kind of instruction.
08:28:05 <ski__> ('!' being 'of-course')
08:28:24 <psykotic> there is a COPY instruction but the dest has to be 0 (which is what the ERASE instruction typically does to a memory cell).
08:28:41 <psykotic> i'm speaking of a specific architecture in this case but it is fairly representative.
08:29:03 <ski__> hm .. reversability .. is supposed to be a bijection ?  or just having a left-inverse ?
08:29:10 <psykotic> neither
08:29:16 <psykotic> it just means that you can run the computer "backwards"
08:30:03 <psykotic> in this case you should of a von neumann computer.
08:30:07 <psykotic> err, should think of
08:30:45 <psykotic> if M denotes some memory cell then an instruction such as ADD M, 1 is reversible; after executing it you can run it backwards to recover the original state of the machine.
08:30:46 <ski__> hm, istr something about 'if' being slightly problematic
08:31:43 <psykotic> similarly EXCH is always reversible. and MUL is always reversible unless one of the operands is 0. COPY is reversible as long as the destination is 0; for then running COPY in reverse just means putting "0" into the destination.
08:32:17 <ski__> 'ADD E,V' would also be reversible .. assuming 'E' is overwritten with previous value, plus value of 'V'
08:32:20 <int-e> if v a b = if v then (v, b, a) else (v, a, b)
08:32:26 <int-e> is reversible
08:32:44 <ski__> hm .. yes
08:32:49 <psykotic> the ERASE instruction, which sets the operand to 0, doesn't seem reversible and that's where the garbage stack comes in. conceptually ERASE <mem> pushes the value at <mem> on top of the stack, and running ERASE <mem> in reverse pops the value on top of the garbage stack and places it at <mem>
08:33:23 <ski__> and how would implementations woork in this case ?
08:33:45 <ski__> (wolverian : i'm sorry, we seem to've gone off to a tangent .. :)
08:34:00 <psykotic> a physical computer implementation you mean? generally they aren't truly reversible; the whole purpose of building a reversible computer is to dissipate as little heat as possible.
08:34:01 <int-e> hmm. have a look at http://esoteric.sange.fi/essie2/download/kayak/kayak.html (almost reversible. there are some nasty tricks one can play with the bit bucket)
08:34:03 <lambdabot> Title: "Kayak"
08:34:04 <wolverian> ski__, that's okay, it's interesting. :)
08:34:09 <psykotic> basically whenever you throw away information you are generating heat
08:34:29 <psykotic> if you are being truly reversible then there is no thermodynamic reason why you should dissipate heat.
08:34:44 <ski__> yes
08:34:49 <ski__> i remember that
08:34:49 <shapr> petekaz: Hey, I started with Haskell when I turned 29.
08:35:08 <ski__> int-e : ty
08:35:26 <psykotic> so, the physical implementation of a garbage stack is usually a small buffer which is "dissipated" gradually.
08:35:54 <psykotic> so in a sense the whole point of reversible computing architectures is making the ERASE-ing as explicit as possible to allow programmers and compilers to minimize dissipation :)
08:36:10 <ski__> but what value would be reset into, when running 'ERASE' backwards ?
08:36:12 <psykotic> it turns out that a lot of algorithms (especially the referentially transparent ones) can be written reversibly in this kind of instruction set
08:36:24 <ski__> (if it has been thrown away, dissipated)
08:36:26 <psykotic> ski: well, a physical reversible computer doesn't actually run backwards :)
08:36:36 <ski__> hm
08:36:43 <psykotic> like i said the goal of trying to be as reversible as possible is to be as energy efficient as possible
08:36:55 <int-e> ski__: well, it is an esoteric language so it's more obfuscated then necessary. but it can give a fair idea what reversible computations mean.
08:37:15 <ski__> istr often algorithms would generate "garbage", so you'd copy the interesting results, and then run the computation backwards to get rid of the garbage
08:37:26 <psykotic> ski: right
08:37:41 <psykotic> that's another reason for physical implementations having a garbage "buffer"
08:37:56 <psykotic> they don't dissipitate ERASEd stuff immediately
08:38:13 <ski__> i just don't see how it could successfully run backwards if the garbage information has been dissipated
08:38:33 <ski__> hm
08:38:37 <psykotic> hang on
08:41:17 <psykotic> you never run ERASE in reverse in practice. maybe this is what you remembered:
08:41:36 <psykotic> suppose you have three registers A, B, C. A is initially 0 (the default value).
08:41:54 <psykotic> you now run ADD A, B, C so that we now have A = B + C
08:42:11 <psykotic> now we use A for something
08:42:21 <ski__> (A += B + C)
08:42:28 <psykotic> ski: A is initially 0 :)
08:42:37 <ski__> yes :)
08:42:45 <psykotic> so, suppose we now need to use a 0 value for something
08:42:51 <int-e> Hmm. Erase doesn't exist, does it? It's just an operation that conjures a known constant value out of thin air.
08:43:04 <psykotic> we _could_ do ERASE A, right? like i said ERASE puts 0 in its operand.
08:43:12 <int-e> it doesn't overwrite or change anything
08:43:26 <ski__> int-e : you mean it conjures up the empty tuple value ?
08:43:28 <psykotic> but conceptually we can just run the ADD backwards
08:43:39 <ski__> (which takes 0 bits in mem)
08:43:40 <psykotic> which we can do explicitly by writing SUB A, B, C (assuming B and C haven't changed in the mean time)
08:43:50 <psykotic> so that way we get a 0 without generating any garbage
08:43:54 <int-e> ski_: no, it creates a new variable.
08:44:22 <ski__> hm ?
08:44:24 <int-e> at least if it should be reversible.
08:45:13 <ski__> int-e : new var of which type ?
08:45:31 <vincenz> re
08:45:45 <psykotic> ski: did that example make sense? that's the way in which reversible coders sometimes run parts of a computation backwards explicitly to avoid generating garbage.
08:46:15 <ski__> hm
08:46:26 <ski__> in which cases would we want to use 'ERASE' ?
08:46:42 <psykotic> ski: well, we'd like to run in a bounded amount of memory :)
08:46:58 <int-e> ok, I'm confused between the reversible and nonreversible levels of this discussion.
08:47:31 <psykotic> ski: the idea is that the precondition of some instructions, like COPY, is that the destination register/memory location should be 0
08:47:37 <ski__> if you really erase info, you can't reverse that part of the computation (and probably most of what it depended on)
08:47:37 <psykotic> ERASE arranges for that to come true
08:48:03 <ski__> and what happens if that precondition is not true ?
08:48:15 <vincenz> hre!
08:48:16 <psykotic> it's Not Allowed :)
08:48:21 <ski__> or did you mean that that is impossible, by design ?
08:48:24 <psykotic> maybe an exception will be raised
08:48:48 <int-e> ok. so erase really drops information and computations with erase can not be reversed.
08:48:55 <psykotic> ski: what happens when you divide by 0? :)
08:48:59 <psykotic> it's the same kind of situation
08:49:10 <ski__> A *= 0
08:49:24 <ski__> so, sometimes multiplication is not reversible
08:49:27 <int-e> while you could get the effect by just creating a new variable of the desired value and keeping the old value around, without losing information.
08:49:40 <psykotic> ski: i mentioned the zero operand case earlier. so yeah you have a precondition on multiply too.
08:50:00 <ski__> but that is a precond on the forward run, not the backward run, yes ?
08:50:20 <int-e> (running that in reverse amounts to asserting that when the computation arrives there, the value is actually that constant we put there)
08:51:06 <psykotic> ski: the preconditions are written with regard to the forward run. in some sense the preconditions for the forward run are written such that the backward run won't have any problems, so you can think of the preconditions for the backward run as corresponding to the "inverse" ones of the forward run.
08:51:33 <psykotic> just because the instruction set is for a reversible computer doesn't mean you are writing your algorithms as if backwards :)
08:51:33 <ski__> ok
08:51:42 <ski__> :)
08:52:00 <ski__> (but the preconds have to be assured, somehow)
08:52:14 <psykotic> anyway like i said a major reason for having a reversible instruction set like this is that you can code a lot of referentially transparent functions that don't generate garbage
08:52:32 <ski__> m
08:52:39 <psykotic> ski: you can have the semantics of the machine be such that the machine halts when they are violated, for instance.
08:52:50 <psykotic> that's an easy way out and probably not the best approach, but :)
08:53:08 <psykotic> for instance you can code a functional sort that doesn't generate garbage
08:53:51 <psykotic> and by making it explicit how many garbage bits the different instructions generate it also means that for, say, an in-place sort (which has to generate garbage) you can analyze how many garbage bits are generated as a function of n, the number of items to be sorted
08:54:06 <psykotic> so, i mentioned ERASE, which generates as many garbage bits as are in a machine word
08:54:37 <psykotic> but there are also instructions like a right bit-shift that shifts right by one position, which generates only a single bit of garbage (i.e. the bit that got shifted out on the left).
08:55:18 <psykotic> bit rotations don't generate any garbage so you often end up doing hacks with rotates rather than shifts, where possible. for instance, if you have a 32-bit machine word and you have a function that takes a byte as input you can often use the 24 "free" bits as a buffer and use a rotate where you'd normally use a shift.
08:55:55 <psykotic> anyway this is very off topic for #haskell now, sorry :)
08:56:00 * psykotic finds this stuff very interesting
08:56:14 <vincenz> re!
08:56:25 <psykotic> this paper was a major eye opener for me, http://citeseer.ist.psu.edu/hall94reversible.html
08:56:29 <ski__> psykotic : :)
08:56:32 <ski__> danke
08:56:35 <psykotic> i coded up a vm for the instruction set he describes and wrote a bunch of programs, it was a lot of fun
08:57:00 <vincenz> oh god
08:57:29 * ski__ must run now, though
08:57:37 <vincenz> psykotic: wait, you built a VM?
08:57:44 <vincenz> psykotic: how much effort was it?
08:57:49 <psykotic> it was very simple
08:57:55 <vincenz> psykotic: open source?
08:57:56 <integral> vm's are easy
08:58:03 <psykotic> vincenz: unreleased
08:58:11 * vincenz wants to build an ISS
08:58:17 <vincenz> (instruction set simulator)
08:58:38 <vincenz> which is kinda like a vm
09:00:12 <psykotic> it was no harder than the vm for any other instruction set. the only difference is that the state of the machine includes the aforementioned garbage stack (which works at the bit granularity) and certain instructions push bits onto it when executing forward, and pop bits from it when executing backwards. other than that it was standard fare.
09:00:51 <vincenz> psykotic: mind giving me a brief walk through the design
09:00:59 <vincenz> psykotic: just some points you found important
09:01:13 <psykotic> don't think there was anything special about it
09:01:37 <vincenz> well you must have made some design choices
09:01:40 <psykotic> the development of the program was limited by my typing speed, it was not a challenging coding task
09:01:53 <vincenz> for instance how you modeled memory
09:01:59 <vincenz> did you use a monad for the memory or just the cpu
09:02:15 <vincenz> did you work with relocatable ocde
09:02:15 <psykotic> neither
09:02:25 <psykotic> this was just a toy architecture so it wasn't much of an issue
09:03:02 <vincenz> so what does it look like, designwise
09:03:06 <vincenz> from the toplevel
09:03:12 <psykotic> each instruction in the instruction sets ended up corresponding to a pair of functions, one for executing forward, the other for executing backward. each function takes the machine state and returns the modified machine state. the state is just a tuple consisting of the memory (a linear array) and the garbage stack.
09:03:32 <vincenz> hmm
09:03:34 * vincenz nods
09:03:36 <psykotic> what do you mean? really, there is nothing to it.
09:03:57 <vincenz> well that gave me some info
09:04:04 <vincenz> for instance, I know I won't need a garbage stack
09:04:13 <psykotic> for a reversible computer you will
09:04:21 <psykotic> read that paper i just referenced, it is fairly explicit
09:04:26 <vincenz> yeah but I don't want one
09:04:38 <vincenz> I want to simulate a real arch, like a simple risc
09:04:47 <psykotic> oh. well you obviously don't need a garbage stack for that :)
09:04:56 <vincenz> psykotic: yeah I can imagine then you'd have some kind of undo stack
09:05:02 <vincenz> is that what I should understand as garbage stack?
09:05:04 <psykotic> actually the state is larger than what i mentioned
09:05:14 <int-e> but you don't need reversible computations either
09:05:19 <vincenz> int-e: nope
09:05:20 <psykotic> it's a 3-tuple consisting of (1) the linear memory, (2) the register file (including the program counter), and (3) the garbage stack.
09:05:30 <vincenz> psykotic: ah so it is a register based system
09:05:32 <vincenz> was gonna ask that
09:05:58 <vincenz> my aim is to have a composable platform simulator
09:06:03 <vincenz> where you can swap in a different memory
09:06:06 <vincenz> or a different register file
09:06:08 <vincenz> or a different datapath
09:06:15 <vincenz> (at compile time of course)
09:06:21 <psykotic> ah. i'm not simulating things at that low a level (datapath, control, etc)
09:06:33 <vincenz> well I don't want to simulate the full control path
09:06:37 <vincenz> just the functional behaviour
09:07:03 <vincenz> to the level of pipelining I guess
09:07:15 <psykotic> right, that's way lower than i was interested in
09:07:26 <psykotic> all i care about is the externally observable behavior, not anything that low level
09:08:03 <psykotic> "the externally observable behavior" being the state of the machine between instruction executions
09:14:31 <vincenz> right
09:14:37 <vincenz> but if you simulate memory and cpu as separate entities
09:14:43 <vincenz> pipelining is externally observable
09:15:03 <psykotic> it depends on what you mean by simulating memory
09:15:30 <psykotic> if you mean some kind of timing-based, event-driven simulation then yeah
09:19:33 <dmhouse> Are there no libraries that define a 'replace' function?
09:20:17 <dmhouse> replace xs x y = map (\x' -> if x == x' then y else x) xs
09:20:20 <dmhouse> Something like that
09:20:52 <dmhouse> i.e. replace 'l' '\' "hello world" -> "hezzo worzd".
09:21:11 <dmhouse> (Yeah, I changed the order of parameters between the definition and example. :)
09:21:26 <int-e> and you wrote \ for z
09:21:29 <int-e> or z for \
09:21:36 <dmhouse> Yeah, sorry.
09:22:19 <dmhouse> Even better, do replace x y = concatMap (\x' -> if x == x' then y else [x])
09:22:49 <dmhouse> so you could do replace 'l' "zz" "hello world" -> "hezzzzo worzzd"
09:23:02 <dmhouse> Even better, allow the first parameter to be a list too.
09:24:08 <int-e> > map (\c -> maybe c id (lookup c [('l','z')])) "hello, world"
09:24:14 <lambdabot>  "hezzo, worzd"
09:24:42 <int-e> (I'm not quite serious)
09:25:02 <dmhouse> By the way, fromMaybe z = maybe z id
09:25:14 <int-e> oh right. thanks
09:25:26 <dmhouse> It's not preluded, though. But sure is handy :)
09:25:45 <int-e> @hoogle Bool -> Maybe a
09:25:46 <lambdabot> No matches, try a more general search
09:25:54 <dmhouse> I want that too.
09:25:58 <dmhouse> Bool -> a -> Maybe a, though.
09:26:05 <int-e> yep
09:26:12 <dmhouse> boolToMaybe False _ = Nothing; boolToMaybe x True = Just x
09:26:20 <mauke> @djinn Bool -> a -> Maybe a
09:26:21 <lambdabot> f a b =
09:26:21 <lambdabot>   case a of
09:26:21 <lambdabot>   False -> Nothing
09:26:21 <lambdabot>   True -> Just b
09:26:23 <wolverian> http://chneukirchen.org/blog/archive/2006/06/the-design-of-brne.html hmm.
09:26:25 <lambdabot> Title: "chris blogs: The Design of Brne"
09:26:27 <dmhouse> Nice :)
09:26:36 <dmhouse> petekaz: ping
09:26:45 <chris2> that was quick
09:26:49 <mauke> @karma+ lambdabot
09:26:49 <lambdabot> lambdabot's karma raised to 14.
09:27:01 <int-e> > (guard False >> Just 42, guard True >> Just 42)
09:27:02 <lambdabot>  (Nothing,Just 42)
09:27:19 <int-e> @pl \b x -> guard b >> Just x
09:27:19 <lambdabot> (. Just) . (>>) . guard
09:27:21 <dmhouse> Nice.
09:27:49 <mauke> @type \a -> if a then Just else const Nothing
09:27:51 <lambdabot> forall a. Bool -> a -> Maybe a
09:27:53 <wolverian> chris2, ;)
09:27:56 <dmhouse> @tell petekaz I thought it might be cool to integrate your "Title: " work into the Search plugin, so it tells you the title of a search result when you @google.
09:27:57 <lambdabot> Consider it noted.
09:28:05 <mauke> @pl \a -> if a then Just else const Nothing
09:28:05 <lambdabot> flip (flip if' Just) (const Nothing)
09:28:56 <int-e> @hoogle if'
09:28:56 <lambdabot> No matches found
09:29:17 <dmhouse> So @pl can deal with if statements.
09:29:27 <dmhouse> if' p t f = if p then t else f
09:29:29 <int-e> well, sort if
09:29:49 <dmhouse> It'd be really nice to have that defined in the Prelude, though.
09:31:42 <int-e> > let if' p t f = if p then t else f; (?) = uncurry . if' in False ? (23, 42)
09:31:43 <lambdabot>  42
09:32:23 <dmhouse> That'd be fun.
09:34:01 <dmhouse> wolverian: nice link.
09:34:13 <mauke> > let c ? [t, e] = if c then t else e in True ? "foo" : ["bar"]
09:34:14 <lambdabot>  Couldn't match `Char' against `[Char]'
09:35:05 <dmhouse> > let c ? [t, e] = if c then t else e in True ? ("foo" : ["bar"])
09:35:06 <lambdabot>  "foo"
09:51:41 <kpreid_> > let (::) = (,); c ? (t, e) = if c then t else e in True ? "foo" :: ["bar"]
09:51:41 <lambdabot>  Parse error
09:51:45 <kpreid_> > let (::) = (,); c ? (t, e) = if c then t else e in True ? ("foo" :: ["bar"])
09:51:45 <lambdabot>  Parse error
09:52:01 <kpreid_> > let (:::) = (,); c ? (t, e) = if c then t else e in True ? ("foo" ::: ["bar"])
09:52:01 <lambdabot>  Not in scope: data constructor `:::'
09:52:15 <kpreid_> > let (-:) = (,); c ? (t, e) = if c then t else e in True ? ("foo" -: ["bar"])
09:52:15 <lambdabot>  Couldn't match `Char' against `[Char]'
09:52:20 <kpreid_> > let (-:) = (,); c ? (t, e) = if c then t else e in True ? ("foo" -: "bar")
09:52:21 <lambdabot>  "foo"
09:56:30 <dmhouse> kpreid_: You could lose the bracketing with fixity adjustments.
09:56:39 <dmhouse> (Of course, lambabot doesn't do that.)
09:56:56 <dmhouse> But I quite like the pair version.
09:57:25 <vincenz> psykotic: not timing based, but I want proper cache behaviour
09:58:58 <jethr0> hola vincenz
09:59:31 <araujo> hello
09:59:58 <vincenz> hiya jethr0 
10:00:00 <vincenz> been a while
10:01:34 <jethr0> yup, been at home without computer or decent internet access
10:01:42 <jethr0> s/home/my parents/
10:02:30 --- mode: ChanServ set +o dmhouse
10:03:31 <dmhouse> So how does the browser convert a filled-in form to POST data?
10:03:48 <dmhouse> I.e. what does the rqBody of a POST Request look like?
10:04:13 <dmhouse> Something like "var1=val1&var2=val2", perhaps?
10:05:24 <vincenz> jethr0: my compiler and interpreter work
10:05:38 <dmhouse> Hmm. I think so. What if it was a textbox, containing line breaks? It just gets decomposed to "textboxname=line1\\nline2\\nline3"?
10:05:42 <woggle> dmhouse: http://www.w3.org/TR/html4/interact/forms.html#h-17.13
10:05:45 <lambdabot> Title: "Forms in HTML documents"
10:08:17 <dmhouse> woggle: Thanks! Very helpful. So, in summary, 'yes'?
10:08:46 <SamB> hmm, does anyone know the autoconf for finding curses?
10:08:53 <jethr0> vincenz: congratulations
10:09:07 <woggle> In summary, it depends on the enctype of the FORM, but most commonly, yes, and the contents are URL encoded.
10:09:53 <dmhouse> Cool.
10:10:46 <woggle> Note that handling multipart/form-data is important if you're going to support file uploads, however.
10:11:10 <dmhouse> I'm sending POST data myself (no user interaction).
10:11:29 <woggle> That doesn't effect whether you want to send a file upload.
10:12:18 <dmhouse> Okay, but the word 'support' connotes I'm going to allow the user to specify what data I send.
10:12:53 <woggle> I figured you would be allowing the user of your library to do so. (;
10:13:40 <dmhouse> Ah, okay. :) Nah, this is a standalone application. I take a single string from the user, fire off a GET request, skim that for some data, then fire off a POST request based on what I collected.
10:13:48 <dmhouse> So the POST is pretty far removed from what the user typed in.
10:14:00 <dmhouse> More concretely, I won't be touching file uploads :)
10:20:50 <vincenz> jethr0: thx
10:24:18 <dmhouse> > let xs !! (beg, end) = take (end - beg) (drop beg xs) in [1..10] !! (4, 6)
10:24:19 <lambdabot>  [5,6]
10:24:58 <dmhouse> Or perhaps
10:25:02 <vincenz> dmhouse: easier way
10:25:38 <dmhouse> > let xs !!! ixs = map (xs !!) ixs in [1..10] !!! [4..6]
10:25:39 <lambdabot>  [5,6,7]
10:25:40 <vincenz> > let xs !! a b = fst . splitAt a . fst . splitAt b xs
10:25:41 <lambdabot>  Parse error in pattern
10:25:49 <vincenz> > let xs !! a b = fst . splitAt a . fst . splitAt b xs in [1..10] !! 4 6
10:25:50 <lambdabot>  Parse error in pattern
10:26:13 <dmhouse> > let (xs !! a) b = fst . splitAt a . fst . splitAt b xs in [1..10] !! 4 6
10:26:13 <lambdabot>    Expecting a function type, but found `([a], [a])'
10:26:14 <lambdabot>    Expected type: a...
10:26:19 <vincenz> > let xs !!! (a, b) = fst . splitAt a . fst . splitAt b $ xs in [1..10] !!! (4, 6)
10:26:20 <lambdabot>  [1,2,3,4]
10:26:26 <vincenz> > let xs !!! (a, b) = snd . splitAt a . fst . splitAt b $ xs in [1..10] !!! (4, 6)
10:26:27 <lambdabot>  [5,6]
10:26:28 <dmhouse> > let xs !! a = \b -> fst . splitAt a . fst . splitAt b xs in [1..10] !! 4 6
10:26:29 <lambdabot>    Expecting a function type, but found `([a], [a])'
10:26:29 <lambdabot>    Expected type: a...
10:26:38 <dmhouse> Never mind.
10:26:50 <dmhouse> > [] !! 0
10:26:50 <lambdabot>  Add a type signature
10:26:55 <vincenz> @pl \xs (a, b) = snd . splitAt a . fst . splitAt b $ xs
10:26:55 <lambdabot> (line 1, column 12):
10:26:55 <lambdabot> unexpected "="
10:26:55 <lambdabot> expecting pattern or "->"
10:26:59 <vincenz> @pl \xs (a, b) -> snd . splitAt a . fst . splitAt b $ xs
10:26:59 <lambdabot> (`ap` snd) . (. fst) . flip (flip . ((snd .) .) . (. ((fst .) . splitAt)) . (.) . splitAt)
10:27:03 * vincenz coughs
10:27:18 <vincenz> @pl \xs a b -> snd . splitAt a . fst . splitAt b $ xs
10:27:18 <lambdabot> flip (flip . ((snd .) .) . (. ((fst .) . splitAt)) . (.) . splitAt)
10:27:21 <dropdrive> what are you guys trying to do?
10:27:48 <vincenz> dmhouse: I like my splitAt one
10:27:55 <vincenz> dmhouse: it's rather regular
10:28:11 <vincenz> \o/
10:28:34 <vincenz> dmhouse: and you might want to first take end, then drop beg
10:28:38 <vincenz> dmhouse: that way you don't have to substract
10:28:44 <int-e> hum ... take? drop?
10:28:45 <vincenz> dmhouse: same principle as I used with splitat
10:29:13 <vincenz> > let xs !! (a,b) = drop a . take b $ xs in [1..10] !! (4,6)
10:29:14 <lambdabot>  [5,6]
10:29:37 <vincenz> > let xs !! (a,b) = drop a . take (b+1) $ xs in [1..10] !! (4,6)
10:29:38 <lambdabot>  [5,6,7]
10:29:59 <vincenz> > take (-2) [1..10]
10:30:00 <lambdabot>  []
10:45:26 <dmhouse> vincenz, It'd be nice to have a (!!!) or (!!) which were properly flexible.
10:45:36 <dmhouse> Something like:
10:46:04 <dmhouse> Hmm, I wonder.
10:46:12 <dmhouse> > length [1..] > 3
10:46:16 <lambdabot> Terminated
10:46:21 <dmhouse> Aww, it's not that cleve.
10:46:23 <dmhouse> *clever
10:47:31 <int-e> > not . null . drop 3 $ [1..]
10:47:32 <lambdabot>  True
10:47:42 <petekaz> dmhouse: good idea.
10:47:42 <lambdabot> petekaz: You have 1 new message. '/msg lambdabot @messages' to read it.
10:48:01 <dmhouse> > let lengthComp (x:xs) (y:ys) = lengthComp xs ys; lengthComp [] [] = EQ; lengthComp _ [] = LT; lengthComp [] _ = GT in [1..] `lengthComp` [1..3]
10:48:02 <lambdabot>  LT
10:48:16 <dmhouse> > let lengthComp (x:xs) (y:ys) = lengthComp xs ys; lengthComp [] [] = EQ; lengthComp _ [] = GT; lengthComp [] _ = LT in [1..] `lengthComp` [1..3] -- gah
10:48:18 <lambdabot>  GT
10:48:33 <dmhouse> > let lengthComp (x:xs) (y:ys) = lengthComp xs ys; lengthComp [] [] = EQ; lengthComp _ [] = GT; lengthComp [] _ = LT in [1..3] `lengthComp` [10..13]
10:48:34 <lambdabot>  LT
10:48:35 <int-e> heh
10:48:40 <dmhouse> Hmm.
10:49:10 <int-e> > let lengthComp a b = compare (map (const ()) a) (map (const ()) b) in [1..3] `lengthComp` [10..13]
10:49:11 <lambdabot>  LT
10:49:23 <dmhouse> Ooh, counting in unary :)
10:49:58 <dmhouse> > let lengthComp (x:xs) (y:ys) = lengthComp xs ys; lengthComp [] [] = EQ; lengthComp _ [] = GT; lengthComp [] _ = LT in [1..3] `lengthComp` [11..13] -- D'oh!
10:49:59 <lambdabot>  EQ
10:50:20 <dmhouse> Right, now we have a length comparison that works with infinite lists:
10:51:20 <dmhouse> int-e, lengthComp = compare `attach` map (const ()), if you've got that defined :)
10:52:00 <int-e> dmhouse: actually, I'd prefer defining comparing and then use  comparing (map (const ()))
10:52:20 <dmhouse> Ah yeah. comparing = (compare `attach`).
10:52:34 <int-e> (comparing = attach compare  in terms of attach, but it has been proposed before I've seen attach)
10:52:50 <dmhouse> Sure. But attach is just generally useful :)
10:53:02 <int-e> comparing is the case I miss most often.
10:53:11 <vincenz> @echo dmhouse
10:53:11 <lambdabot> echo; msg:IrcMessage {msgPrefix = "vincenz!n=vincenz@d51A5999E.access.telenet.be", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo dmhouse"]} rest:"dmhouse"
10:54:39 <int-e> (comparing is also mentioned in http://www.haskell.org/hawiki/LicensedPreludeExts)
10:54:42 <lambdabot> Title: "LicensedPreludeExts - The Haskell Wiki"
10:55:35 <dmhouse> > let attach f g x y = g x `f` g y; lengthComp = compare `attach` map (const ()); xs !!! [] = []; xs !!! ixs | drop (head ixs) xs `compareLength` tail ixs /= GT = drop (head ixs) | otherwise = map (xs !!) ixs in [1..4] !!! [2..]
10:55:36 <lambdabot>  Not in scope: `compareLength'
10:55:45 <dmhouse> > let attach f g x y = g x `f` g y; lengthComp = compare `attach` map (const ()); xs !!! [] = []; xs !!! ixs | drop (head ixs) xs `lengthComp` tail ixs /= GT = drop (head ixs) | otherwise = map (xs !!) ixs in [1..4] !!! [2..]
10:55:46 <lambdabot>    Expecting a function type, but found `t_a1KH'
10:55:46 <lambdabot>    Expected type: [a]
10:55:46 <lambdabot>  ...
10:55:53 * dmhouse goes away to write that
10:56:03 <vincenz> you do that
10:56:51 <dmhouse> > let attach f g x y = g x `f` g y; lengthComp = compare `attach` map (const ()); xs !!! [] = []; xs !!! ixs | drop (head ixs) xs `lengthComp` tail ixs /= GT = drop (head ixs) xs | otherwise = map (xs !!) ixs in [1..4] !!! [2..]
10:56:53 <lambdabot>  [3,4]
10:56:56 <dmhouse> :)
10:57:01 <vincenz> all that crap for
10:57:05 <vincenz> > [3..4] 
10:57:06 <vincenz> ?
10:57:06 <lambdabot>  [3,4]
10:57:21 <dmhouse> A bit of fudging for 0-based indices needed
10:59:12 <int-e> lengthLE = attach (<=) (map (const ()))
10:59:28 <dmhouse> Actually, no there isn't. It works already
10:59:39 <dmhouse> int-e, fine, use the special case :)
11:00:29 * dmhouse adds it to his combinators wishlist
11:01:28 <dmhouse> Although it's not really a combinator, but still.
11:05:37 <vincenz> dmhouse: afraid I'd troll?
11:05:49 <dmhouse> vincenz: Sorry?
11:05:59 <vincenz> "although it's not really a combinator"
11:06:09 <vincenz> I thought maybe you added that out of fear I'd start a whole new discussion
11:06:11 <dmhouse> Haha :)
11:06:38 <vincenz> >:D
11:06:55 <lisppaste2> dmhouse pasted "combinator wishlist" at http://paste.lisp.org/display/21377
11:07:01 <dmhouse> ^^ That's it so far.
11:07:35 <jgrimes> dmhouse, nice :p
11:07:44 * vincenz thinks more should be typeclassed
11:08:49 <vincenz> dmhouse: what about
11:09:06 <vincenz> lallala `unless` is_smart dmhouse
11:09:14 <vincenz> in monad
11:09:20 <dmhouse> @hoogle unless
11:09:20 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
11:09:21 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
11:09:21 <lambdabot> System.Win32.Types.failUnlessSuccess :: String -> IO ErrCode -> IO ()
11:09:22 <dmhouse> ;)
11:09:42 * vincenz coughs
11:09:42 <dmhouse> Although the parameters are the other way round.
11:09:55 <vincenz> yeah :(
11:10:03 <vincenz> btw
11:10:08 <vincenz> dup == join (,)
11:10:11 <vincenz> > join (,) 1
11:10:12 <lambdabot>  (1,1)
11:10:12 <dmhouse> yeah, I know.
11:10:19 <vincenz> join looks neater!
11:10:22 <int-e> @type foldr (.) id
11:10:23 <lambdabot> forall a. [a -> a] -> a -> a
11:10:32 <dmhouse> Sometimes simplicity is prettier than conciseness.
11:10:45 <int-e> I'd use that for compose
11:10:46 <dmhouse> s/conciseness/brevity/, it's a better word..
11:10:55 <dmhouse> int-e, perhaps.
11:10:58 <vincenz> anyways
11:11:05 * vincenz off to a bday party
11:11:10 <vincenz> hasta luego!
11:11:12 <dmhouse> int-e, the idea was that you'd put a value in the top and get it out at the bottom.
11:11:46 <int-e> that one has the chance of being lazily executed and you get the other with an additional reverse
11:11:48 * int-e shrugs
11:12:17 <dmhouse> Hmm, you're probably right.
11:12:24 <dmhouse> But then compose = composeA.
11:12:35 <dmhouse> Oh, wait, no, never mind.
11:12:39 <int-e> then again I
11:12:40 <dmhouse> That's true at the moment.
11:12:48 <int-e> 'd just use foldr (.) id  directly
11:12:54 <int-e> don't need a name for it.
11:13:15 <dmhouse> It's nice to name. Just like and, or, concat and so on.
11:14:02 <dmhouse> In fact, any monoidial operation could be generalised to a folding version.
11:15:02 <dmhouse> And therefore and, or, concat, compose et al are all special cases of foldr mappend mempty :)
11:15:16 <dmhouse> Although as for how useful that is...
11:23:10 <SamB> you know how I said I was translating ZSNES's debugger from ASM into C?
11:23:30 <SamB> somehow it actually seems to be working ;-)
11:23:30 <SamB> though there is still much to implement
11:24:11 <dmhouse> Fun :) Why on earth was it originally written in ASM?
11:24:18 <dmhouse> And why aren't you translating it to Haskell?
11:25:31 <SamB> well, probably the same reason almost all of the rest of ZSNES was originally written in ASM?
11:26:28 <SamB> originally it only ran on DOS (though it has always been a 32-bit program, as far as I know)
11:27:02 <SamB> and I don't think that Haskell will work on DOS
11:27:33 <SamB> or that its FFI is so good that it would work well for interfacing with ASM code
11:27:35 <dmhouse> Aha. DOS.
11:28:20 <SamB> well, particularly because it is FFI and not FVPI
11:28:31 <SamB> or FVPCI
11:28:44 <SamB> (foreign variable/procedure/coroutine interface)
11:29:11 <SamB> anyway, I've got it running on Linux too now, but it just segfaulted...
11:30:29 <SamB> hmm, for some reason F1 isn't reading correctly on DOS :-(
11:45:51 <dmhouse> If I get an 'HTTP/1.1 411 Length Required' response from a manually built POST request, what am I doing wrong?
11:46:55 <kpreid_> dmhouse: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.12
11:46:57 <lambdabot> Title: "HTTP/1.1: Status Code Definitions"
11:47:28 <SamB> dmhouse: not sending a Length header?
11:47:35 <dmhouse> Thanks kpreid_.
11:47:58 <dmhouse> SamB: That's what I was thinking, but I expected Network.HTTP to automagically add the Content-Length header.
11:49:09 <SamB> dmhouse: maybe you can ask it to do that?
11:51:30 <dmhouse> @ask bringert whether Network.HTTP can automagically add the Content-Length header to simpleHTTP requests?
11:51:30 <lambdabot> Consider it noted.
11:53:04 <dmhouse> Hrm. If not, how would I work out the length of my content? I.e., given a random string, how do you find its length in bytes?
11:57:33 <dmhouse> Hmm. Odd. Seems like this kind of thing should be easy.
11:58:35 <int-e> dmhouse: length *shrugs*
11:58:54 <dmhouse> Yeah, but...
11:58:55 <dmhouse> Hrm.
11:59:07 <dmhouse> > length "äëïöü"
11:59:08 <lambdabot>  10
11:59:13 <dmhouse> Oh?
11:59:25 <int-e> utf8
11:59:39 <dmhouse> Yes, but how are those letters two characters long each?
11:59:40 <int-e> you sent utf8 that is
11:59:58 <dmhouse> That happens in GHC too.
12:00:14 <int-e> > map ord "äöü"
12:00:15 <lambdabot>  [195,164,195,182,195,188]
12:00:29 <int-e> see?
12:00:33 <dmhouse> > map (chr . ord) "äöü"
12:00:35 <lambdabot>  "\195\164\195\182\195\188"
12:00:41 <int-e> ghc still doesn't know anything about utf8
12:00:53 <int-e> > "äöü"
12:00:54 <lambdabot>  "\195\164\195\182\195\188"
12:01:01 <dmhouse> So they're stored internally as two characters?
12:01:23 <dmhouse> Oh, of course. It's going through the IO, which doesn't do UTF8.
12:01:32 <int-e> they arrive as 2 octets each and are interpreted as 1 character per octet.
12:01:35 <dmhouse> Strings, though, are UTF8-compliant, no?
12:02:18 <int-e> > chr 228
12:02:19 <lambdabot>  '\228'
12:02:50 <dmhouse> > (chr . ord . chr) 228
12:02:51 <lambdabot>  '\228'
12:03:07 <int-e> I don't know.
12:03:59 <dmhouse> Anyone else shed some light here?
12:07:01 <int-e> @hoogle String -> String
12:07:02 <lambdabot> Network.URI.normalizeCase :: String -> String
12:07:02 <lambdabot> Network.URI.normalizeEscape :: String -> String
12:07:02 <lambdabot> Network.URI.normalizePathSegments :: String -> String
12:07:32 <SamB> dmhouse: strings are not utf8-compliant 
12:07:53 <int-e> @hoogle utf8
12:07:54 <lambdabot> No matches found
12:08:01 <SamB> they are supposed to be Unicode characters, not octets
12:08:01 <int-e> @index utf
12:08:01 <lambdabot> bzzt
12:08:55 <dmhouse> SamB: you sure?
12:09:03 <mauke> > map chr [123,456,789]
12:09:04 <lambdabot>  "{\456\789"
12:09:21 <dmhouse> I'm sure I've read that Strings work with UTF8, but IO doesn't.
12:10:02 <SamB> dmhouse: you mean Unicode, not utf8
12:10:21 <dmhouse> Ah. What's the difference?
12:10:22 <int-e> Chars are big enough to store Unicode
12:10:55 <int-e> But there's no support for encoding or decoding them as utf8. I think.
12:13:10 <SamB> int-e: yup, thats the way it is
12:41:25 <dmhouse> > 0x7F
12:41:26 <lambdabot>  127
12:42:11 <dmhouse> Does ACSII only have 127 characters?
12:42:40 <mahogny> the first one?
12:42:42 <mahogny> yes
12:42:49 <dbremner> dmhouse - yes, the high bit is for parity. There are a lot of variants, though.
12:43:10 <mahogny> SMTP still has a mode for 7-bit text :P
12:43:16 <dmhouse> dbremner: What would the parity bit be used for? Consistenty checks?
12:43:19 <dmhouse> And what about Latin-1?
12:43:37 <mahogny> latin-1 has ascii for 1-127 and then adds the extra chaaracters
12:43:55 <dmhouse> Up to 256?
12:43:57 <dmhouse> *255
12:43:58 <mahogny> yes
12:44:00 <dbremner> mahogny - there's also UTF-7 for sending Unicode over SMTP.
12:44:06 <mahogny> yes, thank god :)
12:45:14 * mahogny wonders how long it will take to get rid of all non-UTF/unicode :/
12:45:21 <dbremner> mahogny- there's also Mark Crispin's UTF-9 and UTF-18.
12:45:33 <mahogny> hm. those I haven't heard of
12:45:47 <dbremner> mahogny - I'm expecting that Fieldata and EBCDIC will outlast me.
12:46:15 <mahogny> yeah. things ain't progressing fast standards wise
12:46:29 <mahogny> actually, not fast in any way
12:46:31 <dbremner> mahogny- joke RFC, http://www.ietf.org/rfc/rfc4042.txt
12:46:48 <dmhouse> > (0xC0, 0xFD)
12:46:49 <lambdabot>  (192,253)
12:47:05 <mahogny> dbremner, guess you've seen the monkey machine protocol RFC? :)
12:47:41 <dbremner> mahogny- probably. Last year I tried to implement the SNMP coffee machine.
12:48:06 <mahogny> :)
12:49:32 <dbremner> mahogny - got a link for it?
12:49:48 <mahogny> was such a long time ago. I barely know what to search for
12:51:40 <dbremner> mahogny- I think it's RFC 2795
12:51:43 <bringert> morning #haskell
12:51:44 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
12:52:09 <mahogny> dbremner, yup :)
12:52:48 <bringert> dmhouse: yes, I guess Network.HTTP should automagically add the Content-Length header to simpleHTTP requests
12:53:21 <dmhouse> bringert: right.
12:53:50 <bringert> xerox: you may way to upgrade haskelldb-flat, to current version doesn't dump all that stuff to the logs, and it fixes a race condition with the tmp file which gives intermittent Internal Server Errors with Hope
12:54:01 <bringert> s/to/the/
12:56:17 <bringert> dmhouse: patches are welcome :-)
12:56:30 <dmhouse> bringert: Hehe.
12:56:37 * dmhouse wonders how to get the length of a string in bytes
12:57:44 <mahogny> haskell strings?
12:57:50 <dmhouse> Yah.
12:57:59 <mahogny> as in, you want it corrected for UTF etc?
12:58:11 <dmhouse> Right.
12:58:23 <Lokadin> say, could we get lambdabot to generate faq's based on questions that were asked here, and it would simply group the replies/ filter out irrelevant information and post them up somewhere?
12:59:00 <mahogny> dmhouse, dunno if you can make it much faster then checking the length after conversion. might not have a terrible overhead if done lazily
12:59:22 <mahogny> maybe a new function should be added for this
12:59:28 <dmhouse> Lokadin: that would be hard. You talking about doing all this automatically? How would it filter out responses from general conversation?
12:59:39 <mahogny> of course you could write your own optimized on top, but that kind of breaks the levels of abstraction
12:59:40 <dmhouse> mahogny: length actually seemed to do some weird things:
12:59:52 <dmhouse> > length "äëïöü"
12:59:53 <lambdabot>  10
12:59:57 <Lokadin> a genetic/neural network algorithm, can just evolve by trail and error
13:00:07 <mahogny> dmhouse, hm. that I didn't expect to see
13:00:20 <dmhouse> mahogny: Especially as that's only Latin-1.
13:01:07 <mahogny> dmhouse, I had expected that Char hid away anything related to size so that length is completely indepedent of what you enter
13:01:13 <Lokadin> say on the website that it posts it up it could have buttons beside it for say, relevant, reduntant or irrelevant, and people that would actually search thorugh it would do the hard work of teaching it through this manner
13:01:25 <mauke> > length ""
13:01:26 <lambdabot>  1
13:01:35 <mahogny> dmhouse, however, it would be a different story if you input something already expanded from UTF of course. don't ask me how that happens though
13:01:44 <dmhouse> > length "ÿ"
13:01:45 <lambdabot>  2
13:01:49 <dmhouse> Ah. :)
13:01:50 <mauke> dmhouse: looks like your irc client sends utf-8
13:01:57 <mahogny> dmhouse, check the charset used in your client
13:02:20 <SamB> Lokadin: only if you figure out AI
13:02:33 <mahogny> irssi. can't help there :/
13:02:42 <mahogny> in xchat, just use /charset latin1
13:04:10 <dmhouse> Let's try this again
13:04:31 <dmhouse> > length "ÿ"
13:04:32 <lambdabot>  2
13:04:42 <dmhouse> Nah, I think I just changed the output charset
13:04:59 <dmhouse> Never mind.
13:05:19 <Lokadin> SamB: i'm sure i can, i'm working on my own for now, but i'm sure i'll get around to it
13:05:53 * mahogny goes back trying to get something done :(
13:07:47 <dmhouse> > length "∑ f(i) = ∏ g(i)"
13:07:47 <lambdabot>  lexical error in string/character literal
13:07:52 <goron> Lokadin: That would be fairly advanced. It's something which in theory possible, but I wonder about the amounts of data one would need to actually make it work.  
13:09:05 <dmhouse> > length "ὶ σὰν πρῶτ"
13:09:05 <lambdabot>  lexical error in string/character literal
13:09:05 <Lokadin> goron: i'm sure it' wouldn't be too bad, if we have a few dozen example cases, then we can just evolve an pattern matcher to identify the lines
13:09:28 <dbremner> goron- it might be interesting to search the logs for the first question uttered by a channel newbie. If a lot of them are similar, add the questions to the faq.
13:09:56 <goron> Lokadin: How much experience have you with building such a system with similar data? 
13:10:16 <mahogny> from my experience with AI... I would say that this is close to impossible unless you have done it before and know what you are getting into
13:10:36 <Lokadin> goron: er not much at all, i just have some theoretical background in evolutionary algorithms
13:10:53 <Lokadin> but it's my major
13:10:56 <goron> Lokadin: Then I would say you have very little chance of success. 
13:11:23 <goron> Lokadin: Still in Bachelor?
13:11:24 <mahogny> if you have a background in computer linguistics, then maybe it's worth a shot. ehr. as a master thesis :P
13:11:25 <SamB> Lokadin: you would need several people working round the clock to do that
13:11:53 <SamB> and evolutionary algorithms aren't very good at that kind of thing, I'll warrent
13:11:54 <Lokadin> have you attempted to do it?
13:11:57 <goron> There are people working on real AI *today*. 
13:12:18 <goron> But those people already had a $20M company learning the rough edges of it. 
13:12:41 <SamB> by AI, I meant that you would need to make lambdabot actually intelligent
13:12:46 <Lokadin> agreed, but they are paid, and their workers are paid, and it's very expensive
13:12:51 <goron> The company went bankrupt.
13:13:07 <mahogny> goron, thinking machines inc?
13:13:23 <goron> mahogny: That's their goal for 2019, yes.
13:13:44 <mahogny> goron, no no, the company that went bankcrupt :)
13:13:50 <dbremner> goron- there's also Cycorp.
13:13:53 <goron> mahogny: oh, no.
13:14:01 <goron> mahogny: Webmind
13:14:08 <Lokadin> yea, i agree, that making it for lambdabot would be ridiculously hard atm
13:14:32 <Lokadin> i plan on getting my plans for a uniform interface more underway before i do that
13:14:40 <goron> I think making something which has a positive value is good enough for lambdabot. 
13:14:48 <mahogny> Lokadin, if you want to make a contribution in that direction, then make a good general computer linguistic framework for haskell
13:15:00 <goron> Thus something that does something which costs less time to get a FAQ then doing it manually. 
13:15:29 <Lokadin> goron: will only happen a few years from now
13:15:30 <goron> That's actually a goal you _might_ reach if you cooperate with a few other people. 
13:16:02 <goron> Lokadin: In a few years from now, you have forgotten about this conversation.
13:16:18 <Lokadin> until developing these things becomes more accesible to mundane people i think a lot of ai and development period is unsustainable
13:16:37 <Lokadin> goron: no, i'm working on similar things right now
13:17:01 <mahogny> computer linguistics is *hard* :(
13:17:11 <Lokadin> i need to finish learning lojban and i'll start writing a lojban interpreter for at least basic things
13:17:19 <goron> mahogny: I think that's the wrong level to solve it. 
13:17:48 <Lokadin> yea, the computer dosen't need to understand what is being said to know whether it is relevant to the faq
13:17:53 <mahogny> goron, dunno how good the faq would be if you're unable to parse out what is relevant for a certain question
13:18:17 <Lokadin> all it needs is to find a pattern in the words/characters it sees on the screen to identify if the topic is the same
13:18:31 <mahogny> it's not always obvious
13:18:37 <goron> mahogny: Oh, for just this application, yes, you are right. I thought you were talking about "real" AI. 
13:18:40 <Lokadin> that's what genetic algorithms are for
13:19:19 <mahogny> Lokadin, I don't think you have enough parameters to toss at your GA for it to work out. but give it a try if you think otherwise
13:20:26 <Lokadin> hmmm, i dono i think if i a mere human can tell what lines of conversation belong to what lines of previous conversation then it can be taught to a computer
13:20:50 <SamB> Lokadin: but a pattern in the words is not
13:20:50 <SamB> a pattern in the ideas is
13:20:52 <mahogny> Lokadin, humans usually have a pretty good grasp of what a line mean :)
13:22:03 <Lokadin> i don't need to understand the meaning, the fact you put a word representing my name means your addressing me. if there are words that are repeated in one line and several others that are not "noise" like "a,be,to"
13:22:16 <mahogny> maybe a more interesting project that actually can work is a bot that can figure out what function you want from a description
13:22:27 <goron> Lokadin: You are right in theory, just not yet in practice. 
13:22:33 <Lokadin> thanks' thnk or silence represents the end of conversation
13:22:52 <Lokadin> mahogny: that's what i'm working on now actually :)
13:23:10 <mahogny> Lokadin, you will be in serious trouble if two discussions run at the same time
13:23:25 <Lokadin> or will be shortly, as part of the uniform interface, as soon as i learn lojban and all
13:23:45 <mahogny> lojban... what do you need it for?
13:23:55 <Lokadin> disambiguation of meaning
13:24:00 <Lokadin> it's a lot easier to work with
13:24:10 <mahogny> what do you need to disambigue?
13:24:26 <woggle> Lojban lacks syntatic ambiguity. (At least that's the theory.)
13:24:40 <Lokadin> i mean after learning it for a few days i already understand how i can make a computer understand at least some basic things
13:24:51 <mahogny> lojban = pile of shit :(
13:24:57 <dbremner> mahogny - that sounds like something the YHC project was working on.
13:25:05 <mahogny> dbremner, oh?
13:25:35 <dbremner> mahogny - identify functions that produce the same bytecode as a function in the prelude.
13:26:04 <mahogny> dbremner, hm. sounds almost like a waste of time to me. the work vs the gain that is
13:26:19 <mahogny> someone need to design a better language than esperanto btw
13:26:55 <goron> Goerzel (see http://www.novamente.net/) has written a couple of books and is actually implementing AI. He already has some nice applications running on a fairly general engine (genetic programming on combinatory logic + probabilistic networks). 
13:26:57 <lambdabot> Title: "Novamente LLC - Artificial General Intelligence"
13:27:18 <dbremner> mahogny- there were several attempts to reform Esperanto. AFAIK they were all ignored.
13:27:27 <Lokadin> yea, but the main thing i'm trying to work out now is how to identify users, as using labels and names is rather silly because i can say my name is mahogny and no one will know, unless they see me function differently, so i was thinking functional descriptions such that it would allow for a mini-turing test would be workable
13:27:32 <mahogny> dbremner, well, we already have too many languages
13:27:32 <goron> see is a command?
13:27:32 <dmhouse> esperanto has genders, doesn't it? Why on earth would you _create_ a language with such pointless constructs?
13:27:36 <goron> (see google.com)
13:27:47 <dmhouse> goron, nope.
13:27:58 <mahogny> esperanto is bad by design
13:28:02 <dmhouse> If you include any http://google.com URL, it finds the title.
13:28:02 <Lokadin> especially if say you kick out the gui, and bring it all back to text
13:28:04 <lambdabot> Title: "Google"
13:28:04 <mahogny> I barely consider it "nice try"
13:28:14 <goron> dmhouse: oh, ok. 
13:28:23 <mahogny> goron, hm. will look into this
13:28:27 <Lokadin> moonlite: esperanto is terrible by design, but lojban is wonderful by design, 
13:28:33 <Lokadin> er mahogny *
13:28:39 <Lokadin> mahogny: ^
13:28:47 <woggle> Lojban wasn't designed for nearly the same thing, though.
13:28:59 <mahogny> Lokadin, lojban is nice except they forgot about the target group :P
13:29:02 <Lokadin> why what do you think it was designed for?
13:29:18 <dbremner> mahogny - an awful lot of natural languages will be extinct soon but the diversity in programming languages will make up for it. It's the law of conservation of complexity in action.
13:29:30 <Lokadin> mahogny: what was the target group? and what is it now?
13:29:36 <mahogny> dbremner, that I have seen :P
13:29:39 <mahogny> Lokadin, humans?
13:29:59 <Lokadin> mahogny: it's easier than eseperanto to learn
13:30:00 <mahogny> lojban is nice for the computer, less nice for the human
13:30:14 <mahogny> that's probably true. but I'm not a fan of esperanto so.. :)
13:30:29 <Lokadin> mi na pensi ti
13:30:47 <Lokadin> mi nelci le lojban 
13:31:15 <woggle> Lokadin: Well, the inital design (for Loglan from which Lojban is heavily derived)  was to create a language based on formal logic.
13:31:34 <Lokadin> it's based on predicate logic
13:31:46 <woggle> Yes, I know.
13:31:49 <Lokadin> ...
13:31:50 * mahogny thinks agglutinated languages is the way to go if you want a really nice language (for humans that is)
13:31:53 <dbremner> mahogny - one thing that I found interesting about Esperanto is that children brought up speaking it naturally produce the same sort of contractions and slang found in natural languages. You can build an ivory tower but people will still carve initials in it.
13:32:13 <mahogny> dbremner, that's to be expected
13:32:29 <woggle> Lokadin: Esperanto was, on the other hand, designed as a international language.
13:32:43 <Lokadin> mahogny: lojban has that
13:32:54 <dmhouse> esperanto has genders, doesn't it? Why on earth would you _create_ a language with such pointless constructs?
13:32:57 <Lokadin> woggle: humans can speak it all they want
13:33:04 <dbremner> mahogny - almost every linguist attempts to recreate Heinlein's speedtalk at some point.
13:33:08 <mahogny> Lokadin, but it didn't allow you to leave out much, did it?
13:33:26 <Lokadin> mahogny: what you mean? i can leave plenty out
13:33:36 * mahogny has to recheck it
13:33:48 <Lokadin> i can say, mi nelci, it means i like, nothing more lol
13:34:03 <Lokadin> i don't have to use all the features of the language
13:34:10 <Lokadin> no one does
13:34:39 <Lokadin> they were never meant to, it's just that it's there if necessary
13:35:51 <Lokadin> so, yea what do you guys think of having functional descriptions (perhaps with history) instead of things like passwords to authenticate people and computers
13:36:32 <Lokadin> and functional descriptions for files(like a more advanced meta feature i guess)
13:36:46 <Lokadin> in lojban it's possible and practicalh
13:36:51 <AtnNn> why not use that to predict what hte user is going to do instead?
13:37:05 <Lokadin> that's eventually the plan as well
13:37:17 <Lokadin> so that the computer would guess what the user wants
13:37:27 <mahogny> arrest for future crimes. or kickban for future offences :)
13:37:40 <Lokadin> oh no, that's quite impossible
13:37:41 <Lokadin> lol
13:37:50 <Lokadin> i mean my laptop isn't going to turn me in
13:37:53 <Lokadin> no one will use it
13:38:01 <Lokadin> it needs to have a will to survive
13:38:04 <mahogny> Lokadin, it's a pun based on a movie
13:38:14 <AtnNn> authentication grants permission to do stuff, but if the user needs to do the "stuff" before he gets authenticated, there is a contradiction, no?
13:38:24 <Lokadin> mahogny: yea, i heard of that movie
13:38:58 <Lokadin> AtnNn: no, i was thinking they can start using the computer, and if the computer senses something amiss then it would start asking questions
13:39:36 <Lokadin> if say the routine is out of the ordinary, it could ask where you are, or why are you doing that all of a sudden, it's not like you
13:39:44 <AtnNn> k
13:40:12 <Lokadin> then if it is you, or seems reasonable, it would save it as an altered state of yourself
13:40:24 <AtnNn> ok
13:40:30 <AtnNn> lol haskell talk in ##c
13:41:05 <Lokadin> alright, well i guess i need to get back to learning lojban
13:41:36 * AtnNn is learning russian, it's imho a lot more practical
13:41:53 <Lokadin> i know russian already, and i say it's not :P
13:42:02 <Lokadin> but that's my opinion
13:42:14 <Lokadin> diversifing your mind is always good
13:42:16 <Lokadin> :)
13:42:32 <AtnNn> lol
13:42:52 <AtnNn> are you russian? or how many non-computer lagnuages do you know?
13:43:02 <Lokadin> .ui.uoro'a
13:43:10 <Lokadin> er i know english and russian
13:43:15 <AtnNn> ok
13:43:17 <Lokadin> i'm ukrainian though
13:43:32 <Lokadin> and i'm learning lojban, which i already know better than french
13:43:41 <AtnNn> oh, cool
13:43:59 <Lokadin> french i've been learning in canada since grade three, and got to the level of a grade 11 student
13:44:29 <Lokadin> but, i still know more in lojban, or at least can do more, after a week
13:44:47 <AtnNn> wow, i'll have to check it out then
13:45:29 <Lokadin> the website is pretty scary :S, but here's a good tutorial, http://ptolemy.tlg.uci.edu/~opoudjis/lojbanbrochure/lessons/book1.html
13:46:32 <Lokadin> teaches you all or most of the grammer, and people in #lojban are helpful if you get lost at all
13:50:02 <AtnNn> ok, thanks
13:50:11 <AtnNn> ill learn russian first, i like finishing what i start
13:50:38 <Lokadin> actually learning lojban gave me insight into russian
13:51:27 <Lokadin> you can express russian in lojban with barely any loss of meaning beacause all the nuances can be captured
13:52:41 <Lokadin> besides, i bet you heard, how they did a study where students would learn esperanto for a year and then french for a year did better than students that learned french for two years straight
13:53:23 <Lokadin> lojban grammer takes 2-3 weeks of sit down learning to understand, and the vocabulary is surprisingly simple and intuitive
13:53:35 <Lokadin> but, yea, this is really OT if you want we can talk in #lojban
13:53:51 <AtnNn> no, its ok
13:53:58 <AtnNn> haskell discussion moved to ##c
13:54:15 <Lokadin> lol, yea i guess it's only fair :)
13:55:18 <Lokadin> so i mean, the cost is small and the payoff is potentially quite large, as you might very well learn russian faster,
13:55:52 <Lokadin> there is quite a bit of similarity
13:55:53 <AtnNn> this is very tempting
13:56:06 <AtnNn> also, i guess i don't have to relearn how to type
13:56:20 <Lokadin> yea, that too :)
13:57:03 <AtnNn> or figure out what encoding to use all the time
13:57:28 <Lokadin> you know how in russian the placement of the words is irrelevant because the ending defines how what relates to what. well in lojban you can rearange the words around however you like as long as you signify their original places
13:57:58 <Lokadin> the main difference being that it's a lot simpler in lojban as you don't have to modify the actual words
13:58:17 <Lokadin> and techinical issues are always reduced :), less than in esperanto
13:58:23 <AtnNn> cool
13:58:58 <AtnNn> i was raised in french, and i've having a hard time with many russian language concepts
13:59:31 <Lokadin> alphabet is the same as english without h q and w, and only "punctuation" is ' . and , though they are used in a somewhat different manner
13:59:45 <Lokadin> AtnNn: yea, i'm certain it will help
14:00:32 <Lokadin> :)
14:02:32 <Lokadin> also if you ever want to learn chinese you'll be set, and you'll also understand why "yes" and "no" is inadecuate and leads to confusion, and it's amazing how easy it is to remedy
14:02:57 <AtnNn> interesting
14:03:04 <Lokadin> the goal of lojban is to be able to express at least as much as all other languages
14:03:40 <Lokadin> so it borrows from western languages, russian, chinese, and native american languages
14:03:51 <Lokadin> all while making it really simple to use
14:04:13 <Lokadin> but anyways, i'm using up time you could be learning lojban in :p
14:04:27 <AtnNn> ill check it out at my library, i've got other stuff to do atm :P
14:06:00 <Lokadin> well alright, :) but just so you know, i can with the help of a dictionary translate any lojban i've come across and understand it. and i'm on chapter 6 (though i could have done a large amount earlier as well0
14:07:09 <dmhouse> Hi there, swytch :)
14:07:40 <swytch> hi.  you are in this multiverse too..
14:08:14 <dmhouse> I am indeed.
14:08:20 <swytch> dmhouse: so your kidnapping people out of ##C and taking them into your Haskell group?!  heh
14:09:12 <dmhouse> swytch: Hehe, I just did a random /join because someone said there was Haskell discussion in ##c. I know very little C :)
14:09:21 * Lokadin wants to see the action
14:11:12 <dmhouse> swytch: The centre of the Haskell community is haskell.org, that has helpful links by the dozenful.
14:11:50 <swytch> i wander if its possible to link my gcc progg with Haskell binary so that i can call Haskell functions.
14:12:29 <swytch> im doing this in the wrong order as ive not RTFM or googled before dumping stuff here, but i see theres not hyper-much action here, so..
14:12:50 <dmhouse> We're quite quiet for a Saturday evening really.
14:13:07 <Lokadin> we've been rather quiet lately period
14:13:17 <dmhouse> swytch: An email to the mailing list would probably have good results.
14:13:21 <dmhouse> @google haskell mailing list
14:13:23 <lambdabot> http://www.haskell.org/haskellwiki/Mailing_Lists
14:13:23 <Lokadin> at 3 in the morning there is no one here
14:13:26 <Lokadin> EST
14:14:08 <swytch> im at UTC+2  (c8
14:14:21 <dmhouse> Aha, a European?
14:14:38 <Lokadin> i am awake whenever i'm not collapsed
14:14:54 <Lokadin> i try to average 4 hours a day
14:15:01 <swytch> yes.  actually im norwegian (not in E.Union) but living in france for 2 yars now.
14:15:13 <Lokadin> had 1.5 hours so far :)
14:15:20 <dmhouse> Nice. We have quite a lot of scandinavians in here.
14:15:38 <Lokadin> scannedinavian!
14:15:58 <Lokadin> that's very true, progressive people and ph.d.'s
14:16:21 <neologism> ph.d. != ph.d.
14:16:32 <Lokadin> :|?
14:16:32 <swytch> q.e.d.
14:16:33 <dmhouse> neologism: ?
14:16:39 <dfeuer> Anyone here understand pattern guards?
14:16:51 <dmhouse> dfeuer: I think so. What's up?
14:17:00 <neologism> dmhouse: czech saying.. meaning that ph.d. from oxford is not the same as ph.d. bought for $500 in zimbabwe
14:17:26 <dmhouse> neologism: Ah, fair enough. :)
14:17:51 <Lokadin> neologism: or for $300 in russian backwaters :)
14:17:52 <dfeuer> I'm trying to understand the decision to make matched variables be in scope for the following patterns, rather than for all of the patterns (as in let)
14:18:16 <neologism> the problem is when 70% of people have MSc degree what the average quiality of such a degree is
14:19:48 <Philippa_> dfeuer: "it's not let". In particular, there're conditions interspersed with the bindings, and this way round it's clear what work's done before a given condition
14:20:15 <dfeuer> hmm
14:20:45 <Philippa_> it's not far off list comprehensions
14:21:36 <dmhouse> > [ (a, b) | a <- [1..3], b <- [1..3] ]
14:21:37 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:21:47 <dmhouse> > [ (a, b) | b <- [1..3], a <- [1..3] ]
14:21:48 <lambdabot>  [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2),(1,3),(2,3),(3,3)]
14:22:19 <dmhouse> List comprehensions = list monad. Within monads, we have a concept of the order of evaluation.
14:22:30 <Lokadin> bah g2g to dinner
14:22:31 <Lokadin> cya
14:22:39 <dfeuer> It seems to me that the essential feature of guards is fall-through.
14:22:58 <dfeuer> Would it be possible to generalize fall-through?
14:25:23 <dfeuer> > [(a, b) | a<-[1..3], let b = 4]
14:25:24 <lambdabot>  [(1,4),(2,4),(3,4)]
14:26:02 <Philippa_> dfeuer: have you read the paper "Pattern Guards and Transformational Patterns"? It looks at that a little
14:26:08 <dfeuer> I'm reading it.
14:26:15 <Philippa_> OK. Get to the end :-)
14:26:18 <dfeuer> 'kay.
14:26:59 <dfeuer> Philippa_, which page?
14:29:03 <Philippa_> there's a section on "first class failure"
14:29:35 <dfeuer> found .
14:44:46 <astrolabe> randomised list = do {(extracted,remainder)<-getRandFromList list, randRem <- randomised remainder, return (extracted,randRem)}
14:45:45 <astrolabe> if this is in the IO monad because it uses a PRNG from there, is getting the head of (randomised list) efficient?
14:46:18 <astrolabe> oops mistake
14:46:27 <astrolabe> randomised list = do {(extracted,remainder)<-getRandFromList list, randRem <- randomised remainder, return (extracted:randRem)}
14:51:09 <dfeuer> Philippa_, ping
14:53:27 <dfeuer> > let f x | x==0 = 3 |otherwise = 4 in [f 0, f 1]
14:53:28 <lambdabot>  [3,4]
14:54:54 <astrolabe> is there a way to get lambdabot to use IO stuff?
14:55:48 <mathewm> I suspect if you run your own lambdabot with a tweek here or there...
14:56:12 <dfeuer> > let foo a b | Just x <- a, Just y <- b = Just (a*b) | otherwise = Nothing in [foo (Just 1) (Just 2), foo (Just 1) Nothing]
14:56:12 <lambdabot>  Parse error
14:56:24 <dfeuer> Guess lambdabot doesn't understand pattern guards?
14:56:40 <mathewm> astrolabe: you wouldn't happen to be from Cornell, would you?
14:56:56 <astrolabe> Not even close :)
14:58:24 <dfeuer> pattern guards seem so close to the Maybe monad...  Perhaps instead of making failure first-class failure should just be explicitly represented as Nothing?
14:59:05 <Philippa_> that's not well-defined
14:59:12 <dfeuer> ...
14:59:12 <dfeuer> ?
14:59:13 <mathewm> Is our lambdabot implemented in GHC?
14:59:25 <Philippa_> how do you deconstruct a Maybe? Pattern-matching
15:00:16 <stepcut> mathewm: yes
15:00:24 <stepcut> @whereis lambdabot
15:00:24 <lambdabot> Maybe you meant: where where+
15:00:38 <stepcut> @where lambdabot
15:00:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:03:31 <dfeuer> Philippa_, I guess what I meant is that I'm not sure making failure first-class is necessary, because a function that could fail can just be defined to return a Maybe, and used in roughly the same manner:
15:03:50 <dfeuer> their example becomes
15:04:24 <dfeuer> dfs (v:vs) (Just (c,g))!(match v) = v:dfs (suc c++vs) g
15:05:05 <dfeuer> ahhhhhhh
15:05:21 <dfeuer> I'm slowly figuring out just what I mean.
15:05:47 <dfeuer> Suppose there were new forms mlet and mcase, that returned Maybes
15:06:17 <dfeuer> Returning Nothing on pattern match failure.
15:07:07 * dfeuer keeps thinking.
15:07:09 <dfeuer> foo
15:07:15 <dfeuer> Not there yet.
15:07:21 <int-e> what's the ! doing there?
15:07:34 <dfeuer> It's proposed syntax.
15:09:59 <dfeuer> > [Just a <- [Just 1, Just 2, Nothing, Just 3]]
15:10:00 <lambdabot>  Parse error
15:10:50 <dfeuer> > [a | Just a <- [Just 1, Just 2, Nothing, Just 3]]
15:10:51 <lambdabot>  [1,2,3]
15:12:42 <dfeuer> > fail
15:12:43 <lambdabot>  Add a type signature
15:12:50 <dfeuer> > fail::Integer
15:12:51 <lambdabot>    Expecting a function type, but found `Integer'
15:12:52 <lambdabot>    Expected type: Inte...
15:13:02 <dfeuer> > fail::Integer->Maybe Integer
15:13:03 <lambdabot>  Couldn't match `String' against `Integer'
15:13:25 <dfeuer> > fail::String-> Maybe String
15:13:26 <lambdabot>  <[Char] -> Maybe [Char]>
15:13:56 <dfeuer> > fail "hello"
15:13:57 <lambdabot>  add an instance declaration for (Show (m a))
15:14:35 <dfeuer> I can't remember how fail works.
15:14:45 <Philippa_> short version: "it's a tricky one"
15:15:03 * dfeuer hasn't messed with haskell in a couple years
15:15:16 <Philippa_> in general, fail gets called on pattern-match failure in a do block, takes a string and returns a computation
15:15:40 <Philippa_> it's almost a generalisation of error
15:16:58 <dfeuer> do a-<Just (3::Integer); return a
15:17:00 <dfeuer> > do a-<Just (3::Integer); return a
15:17:01 <lambdabot>  Not in scope: `a'
15:17:09 <int-e> > fail "foo" :: Maybe ()
15:17:10 <lambdabot>  Nothing
15:17:13 <dfeuer> > do a<-Just (3::Integer); return a
15:17:14 <lambdabot>  Just 3
15:18:09 <dfeuer> > do a <- 3::Integer; return a
15:18:10 <lambdabot>  Couldn't match `t t1' against `Integer'
15:18:38 <dfeuer> > do a <- Nothing ; return a
15:18:39 <lambdabot>  Add a type signature
15:18:56 <dfeuer> > do (a::Integer) <- Nothing ; return a
15:18:56 <lambdabot>  Parse error in pattern
15:19:06 <dfeuer> > do a::Integer <- Nothing ; return a
15:19:06 <lambdabot>  Parse error
15:19:19 <dfeuer> > do a <- Nothing ; return a::Integer
15:19:19 <lambdabot>  Couldn't match `Integer' against `m a'
15:19:24 <dfeuer> > do a <- Nothing ; return (a::Integer)
15:19:25 <lambdabot>  Nothing
15:19:38 <int-e> > do 42 <- Nothing; return ()
15:19:39 <lambdabot>  Nothing
15:19:53 <dfeuer> yah
15:20:13 <int-e> > do 23 <- Just 42; return ()
15:20:15 <lambdabot>  Nothing
15:20:20 <int-e> that's the evil part of it.
15:20:25 <int-e> > do 42 <- Just 42; return ()
15:20:26 <lambdabot>  Just ()
15:20:47 <int-e> pattern match failures in Monads are mapped to fail, not to error.
15:21:00 <int-e> err, in monad comprehensions
15:21:10 <int-e> do notation
15:22:36 <dfeuer> > let f x y = do Just a <- Just x ; Just b <- Just y ; return (a*b) in f (Just 3) (Just 4)
15:22:38 <lambdabot>  Just 12
15:22:45 <dfeuer> > let f x y = do Just a <- Just x ; Just b <- Just y ; return (a*b) in f (Just 3) Nothing
15:22:46 <lambdabot>  Nothing
15:24:40 <int-e> > do 42 <- Right 42; return () :: Either String ()
15:24:41 <lambdabot>  add an instance declaration for (Monad (Either String))
15:24:41 <lambdabot>   In a 'do' expre...
15:25:06 <dfeuer> > let f x y = do a <- x ; b <- y ; return (a*b) in f (Just 3) Nothing
15:25:07 <lambdabot>  Nothing
15:25:12 <dfeuer> > let f x y = do a <- x ; b <- y ; return (a*b) in f (Just 3) (Just 4)
15:25:14 <lambdabot>  Just 12
15:26:36 <int-e> -> do 42 <- Right 42; return () :: Either String () --> Right ()
15:26:36 <int-e> -> do 23 <- Right 42; return () :: Either String () --> Left "Pattern match failure in do expression at <interactive>:1:3-4"
15:26:52 <int-e> (that Monad comes from Control.Monad.Error)
15:26:56 <dfeuer> ?
15:27:36 <int-e> Either String is a monad that returns either an error message on the left or a result on the right.
15:27:47 <swytch> Monad. is that from Leibnitz? cool
15:28:01 <int-e> (it defines  fail msg = Left msg)
15:28:20 <dfeuer> oh
15:28:40 <dfeuer> int-e, not necessarily an error message, right?
15:29:00 <int-e> well, fail is supposed to signal failures ...
15:30:03 <int-e> (The sad part of the story is that the module doesn't define   Either t   as a monad)
15:30:27 <dfeuer> module?
15:30:32 <dfeuer> sad?
15:31:21 <int-e> module: the Control.Monad.Error module.
15:31:48 <dfeuer> I don't know what that module is.
15:31:54 <int-e> The sad part is that Either t makes a nice monad for returning values of type t.
15:32:07 <int-e> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
15:32:32 <int-e> emphasis on values, it's a pity to limit it to just error messages.
15:34:06 <dfeuer> How is it limited that way?
15:34:21 <kpreid_> int-e: import and rename!
15:34:59 <swytch> is Haskell simpler to learn than Erlang?  (not to start a flame-war on langguages tho)
15:35:05 <kpreid_> int-e: (and 'instance Error ...')
15:35:57 <int-e> instance (Error e) => Monad (Either e) where ...
15:36:23 <int-e> kpreid_: don't import at all, make own Monad instance for Either. But it's sad.
15:36:39 <int-e> (for me at least)
15:38:18 <dfeuer> How do you avoid importing instance declarations?
15:40:03 <int-e> don't use the module at all.
15:41:24 <dfeuer> yuck
15:42:08 * dfeuer does not like the Haskell module system one bit, and would gladly give up the class system entirely if that would help make a better module system.
15:43:19 <dfeuer> > let f x y = liftM2 (*) (Just 3) (Just 4)
15:43:20 <lambdabot>  Parse error
15:43:35 <dfeuer> > liftM2 (*) (Just 3) (Just 4) 
15:43:36 <lambdabot>  Just 12
15:44:34 <dfeuer> > liftM2 (*) [1, 2, 3] [10, 100, 1000]
15:44:35 <lambdabot>  [10,100,1000,20,200,2000,30,300,3000]
15:45:05 <dfeuer> > liftM2 (*) (Nothing) (Just 4) 
15:45:06 <lambdabot>  Nothing
15:45:17 <dfeuer> > liftM2 (*) (Just 3) (Nothing) 
15:45:19 <lambdabot>  Nothing
15:45:53 <dfeuer> > liftM2 (*) (Nothing) (Just (error "whoa") )
15:45:54 <lambdabot>  Nothing
15:46:18 <dfeuer> > liftM2 (*) (Just (error "whaaa")) Nothing
15:46:19 <lambdabot>  Nothing
15:46:43 <dfeuer> > liftM2 (*) (Nothing) (error "whoa" :: Maybe Integer)
15:46:44 <lambdabot>  Nothing
15:47:06 <dfeuer> > liftM2 (*) (error "whoa"::Maybe Integer) Nothing
15:47:07 <lambdabot>  Exception: whoa
15:50:37 <dfeuer> > Just 3 `mplus` Just 4
15:50:38 <lambdabot>  Just 3
15:50:46 <dfeuer> > Just 4 `mplus` Just 3
15:50:47 <lambdabot>  Just 4
15:52:27 <dfeuer> > guard True :: List 
15:52:27 <lambdabot>  Not in scope: type constructor or class `List'
15:52:51 <dfeuer> > guard True :: (:)
15:52:52 <lambdabot>  Parse error
15:55:49 <bolrod> erh
16:02:33 <dfeuer> What is Monad.guard for?
16:08:42 <abrim> .............................................................................................................................................\
16:12:41 <dfeuer> I think I'm finally understanding pattern guards, pretty much.
16:14:42 <dfeuer> But I would want transformers in transformational patterns to return Maybes.
16:15:04 <dfeuer> To cleanly extend fall-through.
16:15:49 <dfeuer> p!(liftM f) would mean what is currently meant by p!f
16:15:57 <dfeuer> err....
16:15:58 <dfeuer> no.
16:18:23 <dfeuer> p!(return . f) would mean what is currently meant by p!f.
16:20:27 <dfeuer> Is this channel dead?
16:20:52 <Korollary> nein
16:20:56 <dfeuer> yay!
16:21:31 <dfeuer> What do you think, Korollary?  Should the transformers return Maybes?
16:22:53 <xerox> @tell shapr Wow, what's weird?
16:22:54 <lambdabot> Consider it noted.
16:23:07 <xerox> @tell bringert I will upgrade it, okay!
16:23:07 <lambdabot> Consider it noted.
16:25:36 <xerox> @tell shapr I hope it is not my hope XD
16:25:36 <lambdabot> Consider it noted.
18:18:56 <petekaz> What's the diff between [Char] and String types?
18:19:08 <SamB> the name
18:19:10 <petekaz> Can I convert between the two?
18:19:13 <SamB> they are the same tyep
18:19:15 <SamB> er, type
18:19:17 <petekaz> GHC complains.
18:19:20 <ulfdoz_> petekaz: There is none. String is an alias.
18:19:28 <SamB> @hoogle String
18:19:29 <lambdabot> Foreign.C.String :: module
18:19:29 <lambdabot> Prelude.String :: type String
18:19:29 <lambdabot> Text.Read.String :: String -> Lexeme
18:19:39 <petekaz>     Couldn't match `[]' against `Maybe'
18:19:43 <petekaz>       Expected type: IO [Maybe String]
18:19:46 <petekaz>       Inferred type: IO (Maybe [Char])
18:19:48 <SamB> petekaz: that is from something else
18:20:04 <petekaz> ok. thanks.
18:20:12 <petekaz> I'll keep looking then.
18:20:13 <SamB> oh, you are trying to match [Maybe String] against Maybe String
18:20:25 <petekaz> oh ..
18:20:28 <petekaz> I missed that.
18:20:47 <petekaz> thanks.
18:22:45 <SamB> you are welcome ;-)
18:38:43 <alec> @hoogle Maybe String -> String
18:38:44 <lambdabot> System.Locale.iso8601DateFormat :: Maybe String -> String
18:39:02 <AtnNn> that must be exactly what you were looking for
18:39:52 <alec> @hoogle IO ()
18:39:53 <lambdabot> Control.Concurrent.yield :: IO ()
18:39:53 <lambdabot> Distribution.Simple.defaultMain :: IO ()
18:39:53 <lambdabot> System.Mem.performGC :: IO ()
18:50:52 <dfeuer> Generalized algebraic data types look REALLY complicated.
20:12:35 <SamB> what is Coq?
20:13:35 <stepcut> Coq is some sort of mechanical theorem prover or something
20:13:51 <stepcut> http://coq.inria.fr/
20:13:52 <lambdabot> Title: "The Coq proof assistant"
20:28:33 <dons> moin
20:46:52 * SamB got commit access to ZSNES ;-)
21:48:36 <petekaz> dons: incoming lambdabot patch.
21:48:44 <petekaz> @seen dmhouse
21:48:44 <lambdabot> I saw dmhouse leaving #oasis and #haskell 7 hours, 7 minutes and 27 seconds ago, and .
21:49:09 <petekaz> @tell dmhouse I just added that functionality that you suggested to the Search plugin.
21:49:09 <lambdabot> Consider it noted.
21:49:18 <sieni> "and ." pretty much concudes the fact
22:02:26 <drbean> cabal?
22:03:12 <drbean> help cabal?
22:04:14 <drbean> @help cabal
22:04:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:04:33 <drbean> @help list
22:04:34 <lambdabot> list [module|command]
22:04:34 <lambdabot> show all commands or command for [module]
22:04:41 <drbean> @list
22:04:41 <lambdabot> list [module|command]. Where modules is one of:
22:04:42 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
22:04:42 <lambdabot> topic type unlambda url version vixen where
22:06:04 <drbean> @help hoogle
22:06:04 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
22:21:34 <thetallguy> @list pretty
22:21:35 <lambdabot> pretty provides: pretty
23:08:39 <drbean> Audrey's Data.Yaml.Syck package is giving me type errors, so I'm trying to install an earlier Fast Packed Strings.
23:09:08 <drbean> See if it works with fps-0.5 rather than fps-0.6.
23:09:40 <drbean> But I seem to have both registered and it looks like cabal won't unregister 0.6.
23:10:27 <drbean> Unregistering fps-0.6...
23:10:32 <drbean> ghc-pkg: package fps matches multiple packages: fps-0.6, fps-0.5
23:11:11 <cmarcelo> drbean: where did you get your version of HsSyck ? if it was in pugs svn repo, there's a version of fps there which should be compatible with HsSyck.
23:11:50 <drbean> I downloaded fps from dons's site. I will try from the pugs site.
23:13:58 <cmarcelo> drbean: http://svn.openfoundry.org/pugs/third-party/
23:14:00 <lambdabot> Title: "Revision 10731: /third-party"
23:17:11 <mwc> drbean, isn't YAML meant to present a model of heterogenous storage containers similar to what you'd find in dynamic scripting languages?
23:17:31 <mwc> I've always wondered how to effectively deal with that in Haskell, I was thinking you'd need to provide a union of possible types
23:18:04 <mwc> data YAML_Elem = YAMLDict | YAMLList ...
23:22:20 <drbean> I hadn't thought about that. How is XML handled?
23:31:14 <thetallguy> > pretty 3_2
23:31:15 <lambdabot>  Not in scope: `_2'
23:31:26 <thetallguy> >pretty 3+2
23:31:45 <thetallguy> > pretty 3+2
23:31:46 <lambdabot>  Not in scope: `pretty'
23:32:00 <drbean> cmarcelo: Audrey seems to be doing things to fps to support ghc-6.5.
23:32:14 <thetallguy> @pretty 3+2
23:32:14 <lambdabot> "Parse error" at column 4
23:32:42 <drbean> There is no fps.Cabal. there is a fps.Cabal.dummy and fps.Cabal.in.
23:33:06 <drbean> I wonder what do I have to do to make a fps.Cabal.
23:34:07 <cmarcelo> drbean: ops.. probably when configuring pugs, it generates cabal from cabal.in =|
23:35:31 <drbean> Ok. Perhaps I can figure out my own fps.cabal, or take it from fps-0.6
23:40:35 <aFlag> is there a function that will get (Right a) and return a?
23:46:38 <AtnNn> \(Right a) -> return a
