00:19:54 <a-normal-guy> how would one use haskel to create a website containing customer and sales information?
00:34:19 <therp> comming from common lisp, being a bit turned off by all the syntax sugar, I admit that some definition are a magnitude more appealing in beauty than anywhere else. for instance, permutations of list using a recursive list comprehension
00:34:45 <therp> ^^ context: I'm learning haskell
00:35:37 <neologism> lisp is like functional assembler :)
00:36:06 <skew> a-normal-guy: I don but if nobody else is making suggestions you could check out pass.net, implementing with the stuff from happs.org
00:36:12 <skew> blah, that's just messy
00:36:42 <skew> I don't follow that sort of library, but I don't think there's really a single standard comprehensive solution
00:37:04 <a-normal-guy> happs +pass
00:37:06 <therp> not really. lisp is a meta-language. there is no unique feature to haskell, that hasn't been cloned in lisp. lisp comprehension implementation is about 60 lines macro in lisp. partial function application shouldn't be particular hard either. 
00:37:20 <therp> that's of course "list comprehension" :)
00:37:22 <neologism> therp: no doubt there... but you can have macros in asm as well :)
00:37:52 <therp> neologism: sure
00:37:55 <skew> HAppS might be useful. The docs were confusing, but I only tried to look at it for a tiny bit
00:38:11 <neologism> xerox: have you received your suprise from google yet?
00:38:50 <skew> a-normal-guy: there's a big list of web stuff here http://www.haskell.org/haskellwiki/Libraries_and_tools/Web_programming
00:39:11 <bringert_> a-normal-guy: you could maybe write a few Hope modules. Hope: http://hope.bringert.net/
00:39:17 <skew> you probably want some database access too: http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
00:39:36 <bringert_> hope is very new and a moving target atm, and no docs
00:39:57 <Saulzar> Haskell doesn't really have a lot of special syntax, list comprehension and do-blocks I guess are the main ones, and they're really really useful
00:40:35 <skew> therp: the semantics has a lot to do with it too, pure+lazy helps.
00:41:39 <therp> skew: that's right, cl hasn't got lazy evaluation.. well it can be implemented and covered somewhat with macros and tricks however, not entirely
00:42:16 <therp> and what lazy evaluation is all about, I hope I'm going to find out soon in my haskell book.. only a few pages away from the infinite lists stuff..
00:42:23 <skew> Ultimately, the problem is that state and stuff is allowed everywhere in lisp
00:43:04 <skew> It's even starting to look like allowing nontermination everywhere in Haskell will turn out to be a problem
00:43:35 <skew> purity gives you a lot of freedom to reason about an manipulate code
00:43:35 <therp> skew: I know, I was only talking about syntax sugar (which is immediately suspicious to any lisper) and the beauty of simply definitions
00:44:14 <skew> and those advantages extend to code that's manipulaing other code (as higher order functions, or bits of monads)
00:44:35 <hyrax42_> I love the really clean partial application/composition personally
00:44:57 <therp> hyrax: that's definately neat, yes
00:44:59 <hyrax42_> nonttermination?
00:45:13 <hyrax42_> oh and the type system in general
00:45:28 <skew> therp: what are macros but sugar?
00:45:55 <therp> skew: as far as I understand the topic of program transformation, allowing non-terminating behaviour basically kills any meaningful program transformation, no?
00:45:57 <ski> maybe macros are othogonal sugar
00:46:22 <therp> skew: the syntax tree doesn't change, you don't have to learn operator precedences or left/right associativity rules. 
00:46:30 <ski> s/othogonal/orthogonal/
00:47:06 <skew> as far as I know, non-termination doesn't affect program transformation too much
00:47:07 <therp> skew: with "map foo . filter bar" it's was not clear to me what goes first.  
00:48:40 <hyrax42_> therp: :info (.)
00:48:43 <hyrax42_> in ghci
00:48:53 <skew> Maybe you need to put a few side conditions, but generally you can arrange to tranform terminating programs to terminating programs
00:48:54 <hyrax42_> tells you it's infixr
00:49:09 <hyrax42_> so it's read as map foo . (filter bar)
00:49:19 <skew> mostly it's the curry-howard isomorphism - inconsistent logics are not so useful for proving things
00:49:28 <hyrax42_> infixr = right-associative infix operator
00:49:29 <therp> hyrax: is there anything similar in hugs? 
00:49:53 <skew> the last time I looked, hugs didn't have nearly as many little conveniences
00:50:03 <ski> therp : the same, i think
00:50:06 <hyrax42_> and you can always put in parens to help yourself out
00:50:19 <hyrax42_> therp: I don't know... I just installed hugs last night
00:50:31 <hyrax42_> after seeing in haskell-cafe that it is much quicker on the :r
00:50:45 <ski> therp : actually, ':info .'
00:50:47 <skew> ASCII had the \circ glyph, it would have been that
00:50:54 <skew> if ASCII had that glyph
00:51:02 <therp> ski: thanks :)
00:51:20 <hyrax42_> actually on associativity
00:51:29 <hyrax42_> what is associativity of a `fun` infix?
00:51:30 <ski> (and s/info/i/, for short)
00:51:41 <hyrax42_> ski: cool
00:51:52 <ski> foo `fun` bar `fun` baz
00:51:57 <skew> whatever it was declared to be - you can say infixr `foo` 7
00:52:00 <therp> skew: hm, that last work I read about program transformation claimed that only very few transformations can be made when one wants to preserve program termination behaviour
00:52:27 <therp> skew: however, I've to admit I'm not an expert on this topic. I'm just reproducing other peoples conclusions
00:53:03 <ski> (skew : wrong order after 'infixr')
00:53:26 <skew> It seems that preserving it exactly can be pretty tricky, but mostly it works out okay
00:53:52 <skew> See "Fast and Loose Reasoning is Morally Correct"
00:54:13 <hyrax42_> skew: as in you put that on a separate line?
00:54:23 <hyrax42_> foo :: a -> a -> b
00:54:28 <hyrax42_> foo x y = ...
00:54:42 <hyrax42_> infixr `foo` 7?
00:54:57 <skew> well, "`foo`" is an infix operator symbol, just like "+" or "|+&*&&*^"
00:54:57 <ski> infixr 7 `foo`
00:55:23 <hyrax42_> so that is why you can't do `(f . g)`
00:55:33 <skew> It's in the lexical syntax, I think. Anyway, you can give it a fixity with exactly the same declaration syntax
00:55:39 <hyrax42_> I thought ` was syntactic
00:56:06 <hyrax42_> ok
00:56:14 <hyrax42_> and default fixity any ideas?
00:56:16 <hyrax42_> or hang on
00:56:38 <skew> now that people are around, has anybody here used Pango with gtk2hs?
00:56:41 <hyrax42_> nope, not given by :i
00:57:47 <skew> check the spec?
01:00:54 <hyrax42_> skew: when in doubt...
01:01:06 <hyrax42_> :)
01:01:06 <hyrax42_> ok I'm off to the beach
01:02:54 <skew> therp: so really, it's just infix operators that's an issue with the syntax?
01:04:03 <skew> I guess layout is confusing, until you've read the algorithm a few times
01:05:07 <a-normal-guy> is cgi programming good?
01:05:19 <a-normal-guy> I am looking at thttpd and it looks cool
01:06:24 <satan> what does the => mean?
01:07:31 <skew> satan: that's a class constraint
01:07:49 <skew> the instances to the left of it have to exist, for you to be able to use the thing
01:07:58 <satan> ah ok, thanks 
01:09:37 <therp> skew: lisp doesn't know infix operators, that makes the whole thing simpler to read (for someone how doesn't know the parsing rules) .. one can argue whether this is appropriate or not. haskell has a different aim than lisp. I think haskell was designed for mathematicians and theoretic works. (I don't know if it was deliberately designed for this audience, however it's quite successful among them because haskell syntax resembles s
01:09:37 <therp> o much formal syntax one finds in these fields)  
01:10:32 <skew> I think it was designed to resemble mathematics. It was explicitly designed to be one language reasearchers in lazy functional programming could all use
01:10:43 <therp> so, it's not a matter of right or wrong, but more like "best for the given task".
01:11:30 <skew> well, most of the syntax desugars into a very simple core, so it doesn't bother me too much
01:12:08 <ValarQ> skew: is that the reason for the n+k pattern?
01:12:09 <therp> skew: I knew the latter, but for me it doesn't imply the former .. it's good that it does, but actually they could have chosen a perl-like style :) .. of course, haskell wouldn't be as successful than
01:13:52 <therp> skew: one thing that bothers me is that I have little idea about the class and instance syntax. I simply don't know what are valid class and instance definitions. I really have to read the grammar I guess to find out. such a thing wouldn't happen to me in lisp.
01:14:17 <skew> oh, you didn't have to consult the manual to figure out what would be valid applications of loop?
01:14:58 <therp> skew: I personally try to ignore loop :) .. but yes, you have a point here
01:15:32 <skew> I guess I'm just being difficult because I don't think syntax is such a big deal
01:15:34 <therp> loop was made deliberately for non-lisp programmer, I think the reason was trying to pull over algo programmers
01:15:52 <skew> or perhaps, I should say syntax is the least of your worries ;)
01:16:35 <skew> This should cover it, I think http://haskell.org/onlinereport/decls.html
01:17:17 <therp> skew: well, lisp is strong because of syntax tree manipulations. such things are not that obvious to program, when you don't see the syntax tree clearly in your code, such as it happens in haskell
01:17:49 <therp> skew: thanks, I was about to read the haskell report anyway
01:18:05 <skew> If I recall correctly, I learned Haskell coming from Unlambda, by cross-referncing the "gentle" introduction and the language spec, so you might want to look elsewhere for suggestions of intro material
01:18:10 <therp> skew: as I have the feeling that my "haskell: the craft of functional programming" doesn't cover it entirely
01:19:01 <skew> I've picked up a fair bit from research papers too, thought I think STM was the only big thing actually introduced after I started the language
01:19:26 <skew> syntax tree manipulations sort of happen one level up in Haskell
01:20:33 <skew> that is, you build up some AST and eval it, rather than using macros or something to get at the AST of stuff that looks like ordinary code
01:21:10 <skew> partly this is becuase there are not very nice macros, partly because you can see where funny buisness is hapenning that way
01:23:51 <therp> skew: let's see if I make it that far :)
01:23:58 <therp> to see that stuff, I mean.
01:25:10 <skew> you should also see "A Gentle Introduction to Haskell": http://www.haskell.org/tutorial/
01:25:34 <skew> As they say, "Some knowledge of another functional programming language is expected."
01:26:20 <therp> hm, I'm not sure if I need gentle introduction. with such a learning approach, I always feel that everything is too slow :)
01:26:46 <therp> I need to see the cool things first, and then try to understand the basics, but the cool things are usually coming after the basics in such tutorials.
01:26:56 <therp> but, thanks, I'm not yet done with my book
01:27:27 <therp> and after that there is a lot of theory about type and type inference waiting for me, as I need them to implement that in my program transformation system
01:27:51 <skew> perhaps you do want the gentle introduction
01:30:02 <skew> It's a title in the same spirit as "Introduction to Lie Algebras and Representation Theory (Graduate Texts in Mathematics)	
01:30:05 <skew> 	
01:30:59 <skew> basically the spec, but in a conversational tone, and without some formal detail like BNF and explanations of desugaring
01:31:11 <therp> that sounds nice though
01:31:14 * Saulzar didn't find a Gentle Introduction very gentle having not seen a functional language.
01:32:02 <therp> the PDF of the gentle introduction seems to have a paper problem. the page headings are only a few millimeters below the top margin. that's not good.
01:32:17 <skew> oh, I've only ever looked at the HTML
01:32:17 <fluxx> I saw some quote along the lines "if you are trying to learn haskell, don't trust anything with 'gentle' in its topic" ;)
01:32:25 <therp> but I presume I can reTeX it myself with the document sources
01:32:29 <dcoutts> skew, yep, I've used Pango a little
01:32:59 <skew> It's quite possibly the densest introduction to Haskell.
01:33:15 <therp> oh only 64 pages.
01:33:25 <skew> dcoutts: well, I'm trying to put some backgrounds behind text drawn with Pango
01:34:13 <dcoutts> skew, so you want the layout extents or inked extents
01:34:52 <skew> passing some attributes to pangoItemize just seems to make the text render slightly larger and quite a bit uglier than usual, though not as bad as making glyph paths and stroking them
01:35:54 <dcoutts> skew, what kind of background?
01:36:20 <skew> going the other way and getting extents, the types say pangoItemize can split my string into several chunks, but I don't see any way of figuring out how many characters ended up in each chunk, short of using length with glyphItemGetLogicalExtents
01:36:25 <skew> just colors
01:36:40 <skew> though I would like a little rounding rather than hard rectangles
01:36:57 <dcoutts> just the same pattern for a span of text, or on a smaler granulatiry?
01:37:16 <skew> different colors letter-by-letter, perhaps
01:37:30 <dcoutts> ah, so you do need per-glyph info
01:37:53 <dcoutts> getting the extents of a whole span/layout is easier
01:37:58 <skew> yeah, I can get that with glyphItemGetLogicalExtends, I'm just not very happy with that
01:38:30 <dcoutts> the logical extents is bigger than the inked extents, you understand
01:39:05 <vegai> "Brutally cruel introduction to Haskell"
01:39:10 <skew> I'd like to be able to use glyphItemExtentsRange, but I don't see how you can be sure which GlyphItem has the text you like.
01:39:37 <vegai> start with monad transformers and then move to more difficult techniques
01:39:46 <skew> funny, in my test program the inked extents seemed to be larger
01:39:59 <skew> vegai: yeah, you only need two commutativity diagrams to explain monads
01:40:19 <skew> vegai: just write "Behold" underneath and move on.
01:40:52 <dcoutts> skew, actually, for a glyph that might be the case, since they can overlap slightly sometimes
01:41:02 <dcoutts> for a whole layout it's the other way around
01:41:07 <skew> dcoutts: well, the second element of the tuple was larger. the docs say "logical and inked", so I assumed that order.
01:41:22 <vegai> Task 1.1: Improve GHC's Monad implementation so that every monad-using program uses 50% less memory.
01:42:32 <skew> dcoutts: well, I'm just running a string through pangoItemize, and then using pangoShape on each item, not using Layout at all - do I need to be?
01:43:00 <dcoutts> skew, no, layout is a higher level thing, it's a whole paragraph
01:43:09 <skew> the larger rectangle extended above the text by what seemed to be a reasonable inter-line spacing
01:44:03 <dcoutts> skew, so a PangoItem is a sequence of chars, and a GlyphItem is a sequence of glyphs
01:44:32 <dcoutts> so then with glyphItemExtentsRange, the int's should just be offsets into the string I guess
01:44:57 <dcoutts> so that's for a whole (sub)sequence of chars
01:45:35 <skew> offsets into the string corresponding to that item, not the whole string passed to pangoItemize, right?
01:46:37 <skew> the problem I see is that pangoItemize is allowed to split up my string arbitrarily, and I don't see any way of figuring out where it was split
01:46:37 <dcoutts> skew, right, to that item
01:47:00 <dcoutts> skew, so itemise will split into items that have the same attributes
01:47:17 <dcoutts> so eg if you use the same attributes for the whole lot you get one PangoItem
01:48:02 <skew> is that all, I thought mixing in some rtl characters could start a new item too.
01:48:16 <dcoutts> skew, so my initial confusion was to think that a glyph item was a single glyph
01:48:40 <dcoutts> skew, yes, direction will cause a split too
01:48:52 <dcoutts> "itemize splits the input text into several chunks such that each chunk can be rendered with the same font, direction, slant, etc."
01:49:09 <dcoutts> though: "Some attributes such as the color, underline or strikethrough do not affect a break into several PangoItems."
01:49:25 <skew> and then on pangoItemize, 
01:49:29 <skew> "Partitions the input string into segments with the same text direction and shaping engine"
01:49:55 <skew> and my test program which is just setting background color does cause splits
01:50:13 <dcoutts> ok fair enough
01:50:27 <dcoutts> so remind me, what is the problem here?
01:50:42 <dcoutts> you get the extents of the GlyphItem and... ?
01:51:26 <skew> Say I want to render "Hello World", with "ello W" in green on blue, the rest black on grey
01:52:34 <dcoutts> so you'll get two PangoItems/GlyphItems
01:52:50 <dcoutts> then you get the extens to each
01:53:06 <dcoutts> draw the background, then render the GlyphItems on top
01:53:17 <skew> oh, are you responsible for rendering an item with a foreground and background color if you want one?
01:53:36 <skew> using attributes to force breaks just where I want them might work
01:53:36 <dcoutts> I don't think pango does background colours
01:53:45 <skew> doesn't seem to do foreground colors either
01:53:46 <dcoutts> but it does do text colours
01:54:16 <dcoutts> you use the atributes
01:54:23 <dcoutts> pangoItemize :: PangoContext -> String -> [PangoAttribute] -> IO [PangoItem]
01:54:31 <dcoutts> it's that [PangoAttribute]  bit
01:55:12 <dcoutts> oh, ok there is a AttrBackground, I didn't know about that
01:55:21 <dcoutts> never seen it in action
01:55:27 <skew> well, I'm pasing  AttrForeground 0 5 (Color 65535 0 0), and getting black text
01:56:27 <dcoutts> hmm
01:58:12 <lisppaste2> skew pasted "Pango" at http://paste.lisp.org/display/21519
01:59:25 <dcoutts> skew, I'l be back in a minute
02:00:20 <skew> therp: The GHC extensions are also pretty essential, but maybe a bit later : http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
02:21:30 <skew> If I use layout, I get some colors
02:24:06 <skew> green and blue don't behave like I expect, but that could just be how they are mixing onto the default grey
02:34:00 <skew> I have to go now
03:55:31 <shapr> @yow !
03:55:31 <lambdabot> Yow!  We're going to a new disco!
03:55:41 <shapr> It's oh so quiet...
03:55:52 <dfeuer> @yow?
03:55:52 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
03:57:12 <ndm> is there any way to get the directory that the executed program lives in?
03:57:24 <ndm> i.e. getProgName, but including the path name
04:03:02 <bolrod> pwd ?
04:04:10 <ndm> bolrod: the specific problem is when they have the program in their path, so pwd is wrong
04:04:11 <hyrax42_> working dir may not be same as bin dir
04:04:15 <ndm> thats what is currently used
04:05:30 <bolrod> I wouldn't know..
04:05:41 <bolrod> go up the tree until you're at the root.. ?
04:05:55 <bolrod> there must be some function that already does that for you I guess
04:06:01 <hyrax42_> ok
04:06:06 <hyrax42_> someone tell me...
04:06:15 <hyrax42_> is this guy's: http://foo.ewu.edu/jefu/other/software/sw.html
04:06:31 <hyrax42_> anagrams in haskell (search for anagram) stuff just way way way too complicated and messy?
04:07:18 <bolrod> yo.. that page is already way too messy
04:08:35 <hyrax42_> heh
04:09:03 <JKnecht> 'complicated' and 'messy' are value judgements you should make for yourself
04:09:14 <hyrax42_> he seems to be trying too hard
04:09:28 <JKnecht> how much did you pay to use provided stuff?
04:09:47 <hyrax42_> huh?
04:10:19 <JKnecht> value judgement fairness would seem to be best predicated on exchange analyis
04:11:15 <JKnecht> s/analyis/analysis/ unless materials provided have negative value, if you didn't pay you're ahead
04:11:48 <hyrax42_> um
04:11:55 * hyrax42_ confuse
04:12:31 <JKnecht> complaining that it doesn' meet your aesthetic standards seems, uh, ungenerous in these circumstances.
04:12:52 <hyrax42_> I was not complaining
04:13:13 <hyrax42_> I was perhaps judging, but there was no complaint
04:13:38 <hyrax42_> I was interested only because I wrote my own silly little anagrams thing, and it took not much more than 10 lines (I think)
04:13:45 <hyrax42_> then googled to see other approches
04:15:41 <JKnecht> sorry, a beef of mine. 
04:17:55 <hyrax42_> also his thing showed up in a google for "haskell trie", as I wanted to try improving mine wiht a trie
04:17:55 <hyrax42_> (currently using Map)
04:17:55 <hyrax42_> indeed
04:20:22 <ndm> bolrod: findExecutable does half of what i want, its not neat or pretty - since they might invoke it with path/filename, but it works some of the time
04:21:00 <ndm> @seen davidhouse
04:21:00 <lambdabot> davidhouse has changed nick to dmhouse.
04:21:01 <lambdabot> I saw dmhouse leaving #oasis and #haskell 14 hours, 8 minutes and 8 seconds ago, and .
04:21:17 <ndm> @help tell
04:21:18 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
04:22:12 <ndm> @tell dmhouse I have modified hoogle so it should find hoogle.txt in your PATH if thats where your copy of hoogle is - only tested on Windows so please have a go and let me know :)
04:22:13 <lambdabot> Consider it noted.
04:33:16 <dfeuer> @tell lambdabot you're dumb.
04:33:16 <lambdabot> Nice try ;)
04:33:41 * shapr laughs
04:33:55 <audreyt> orElse and retry comes to Pugs/Perl6 :D
04:33:59 <shapr> yay!
04:34:03 <audreyt> but we call orElse "retry_with"
04:34:13 <audreyt> because otherwise it sounds too much like a threat
04:34:14 <audreyt> ;)
04:34:44 <dfeuer> > 3^2
04:34:45 <lambdabot>  9
04:34:55 <dfeuer> >2^2^2^2
04:35:01 <dfeuer> > 2^2^2^2
04:35:02 <lambdabot>  65536
04:35:12 <dfeuer> > 2^2^2^2^2
04:35:14 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
04:35:23 <dfeuer> > 2^2^2^2^2^2^2
04:35:27 <lambdabot> Terminated
04:35:30 <dfeuer> > 2^2^2^2^2^2
04:35:34 <lambdabot> Terminated
04:35:36 <dfeuer> > 2^2^2^2^2
04:35:38 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
04:36:02 <dfeuer> > log (2^2^2^2^2)
04:36:03 <lambdabot>  Infinity
04:39:35 <sieni> > log 42
04:39:36 <lambdabot>  3.7376696182833684
04:39:40 <sieni> > log log 42
04:39:41 <lambdabot>  add an instance declaration for (Floating (a -> a))
04:39:41 <lambdabot>   In the definition o...
04:39:47 <sieni> > log $ log 42
04:39:48 <lambdabot>  1.3184623205053285
04:39:52 <sieni> > log $ log $ log 42
04:39:53 <lambdabot>  0.2764661488566533
04:40:00 <sieni> > log $ log $ log $ log 42
04:40:01 <lambdabot>  -1.2856668927961221
04:40:07 <sieni> > log $ log $ log $ log 1000000000000000000
04:40:09 <lambdabot>  0.27376585975743695
04:40:19 <sieni> > log $ log $ log $ log $ log 1000000000000000000
04:40:21 <lambdabot>  -1.2954820643426204
04:40:24 <sieni> > log $ log $ log $ log $ log 1000000000000000000000000000000000000000000
04:40:26 <lambdabot>  -0.8707557299419567
04:42:51 <dfeuer> > log 2
04:42:52 <lambdabot>  0.6931471805599453
04:42:56 <dfeuer> > log e
04:42:57 <lambdabot>  Not in scope: `e'
04:43:05 <dfeuer> > log 2.718281828
04:43:06 <lambdabot>  0.9999999998311266
04:44:05 <shapr> @yow !
04:44:05 <lambdabot> Boys, you have ALL been selected to LEAVE th' PLANET in 15 minutes!!
04:44:23 * shapr leaves the planet!
04:44:54 <sieni> > log $ sum $ takeWhile (/=0) (map (\n -> 1/(product [1..n])) [0..])
04:44:55 <lambdabot>  1.0
04:49:17 <dfeuer> sieni, what was that?
04:50:23 <dfeuer> oh....
04:50:31 <dfeuer> the MacLauren series.
04:52:14 <dfeuer> log $ sum $ takeWhile ((>=0.0000000000000000001) . abs) (map (\n -> 1%(product [1..n])) [0..])
04:52:19 <dfeuer> > log $ sum $ takeWhile ((>=0.0000000000000000001) . abs) (map (\n -> 1%(product [1..n])) [0..])
04:52:20 <lambdabot>  add an instance declaration for (Floating (Ratio a))
04:52:37 <dfeuer> > log $ sum $ takeWhile ((>=1%10000000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..])
04:52:38 <lambdabot>  add an instance declaration for (Floating (Ratio a))
04:52:51 <dfeuer> @type abs
04:52:53 <lambdabot> forall a. (Num a) => a -> a
04:52:59 <dfeuer> @type product
04:53:00 <lambdabot> forall a. (Num a) => [a] -> a
04:53:04 <dfeuer> I'm confused
04:53:13 <dfeuer> ah.... log
04:53:17 <dfeuer> @type log
04:53:19 <lambdabot> forall a. (Floating a) => a -> a
04:53:31 <dfeuer> > sum $ takeWhile ((>=1%10000000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..])
04:53:33 <lambdabot>  337310723185584470837549%124089680346647887872000
04:54:09 <dfeuer> sieni, what's the continued fraction expansion of e?
04:54:12 <dfeuer> I forget.
04:54:33 <dfeuer> > log $ toFloat $ sum $ takeWhile ((>=1%10000000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..])
04:54:34 <lambdabot>  Not in scope: `toFloat'
04:54:46 <dfeuer> > log $ toFloating $ sum $ takeWhile ((>=1%10000000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..])
04:54:47 <lambdabot>  Not in scope: `toFloating'
04:55:39 <dfeuer> > log $ toReal $ sum $ takeWhile ((>=1%10000000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..])
04:55:40 <lambdabot>  Not in scope: `toReal'
04:58:05 <lorne> > (fromIntegral 1 :: Floating a => a)
04:58:06 <lambdabot>  1.0
05:07:54 <ski> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 100 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:07:55 <lambdabot>  2.7182818284590455
05:07:58 <ski> dfeuer
05:10:20 <dfeuer> > fromNum
05:10:21 <lambdabot>  Not in scope: `fromNum'
05:10:39 <dfeuer> ski, thanks.
05:10:55 <dfeuer> > fromRational
05:10:56 <lambdabot>  Add a type signature
05:11:02 <ski> @type fromRational
05:11:04 <lambdabot> forall a. (Fractional a) => Rational -> a
05:11:46 <dfeuer> > log $ fromRational $ sum $ takeWhile ((>=1%10000000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..])
05:11:47 <lambdabot>  1.0
05:11:48 <reppie> http://en.wikipedia.org/wiki/List_of_problems_solved_by_MacGyver#Pilot_.281x01.29
05:12:14 <dfeuer> > 3::Float
05:12:15 <lambdabot>  3.0
05:12:19 <dfeuer> > 3::Double
05:12:20 <lambdabot>  3.0
05:12:43 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%10000000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]) :: Double)
05:12:44 <lambdabot>  1.0
05:12:53 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]) :: Double)
05:12:54 <lambdabot>  1.0
05:13:00 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]) :: Double)
05:13:01 <lambdabot>  1.0
05:13:04 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]) :: Double)
05:13:06 <lambdabot>  0.9999999999997
05:13:11 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]) :: Float)
05:13:13 <lambdabot>  0.99999994
05:13:48 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Float
05:13:49 <lambdabot>  0.99999994
05:13:57 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Float
05:13:58 <lambdabot>  0.99999994
05:14:03 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Double
05:14:04 <lambdabot>  1.0
05:14:14 <dfeuer> Now I'm a bit confused.
05:14:31 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%100000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Float
05:14:33 <lambdabot>  0.99999994
05:14:38 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%10000000000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Float
05:14:39 <lambdabot>  0.99999994
05:14:42 <dfeuer> ohhh....
05:14:50 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%100000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Double
05:14:51 <lambdabot>  1.0
05:14:54 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%10000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Double
05:14:55 <lambdabot>  1.0
05:14:59 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Double
05:15:00 <lambdabot>  1.0
05:15:03 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%100000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Double
05:15:04 <lambdabot>  1.0
05:15:07 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%10000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Double
05:15:08 <lambdabot>  1.0
05:15:10 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%1000000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Double
05:15:12 <lambdabot>  1.0
05:15:14 <dfeuer> > log (fromRational $ sum $ takeWhile ((>=1%100000000000000) . abs) (map (\n -> 1%(product [1..n])) [0..]))::Double
05:15:15 <lambdabot>  0.999999999999999
05:15:40 <ski> is there a problem ?
05:15:43 <dfeuer> No.
05:15:54 <dfeuer> I guess a double's not as long as I would've guessed.
05:17:47 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 100 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:17:48 <lambdabot>  2.7182818284590455
05:18:03 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 101 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:18:04 <lambdabot>  2.7182818284590455
05:18:10 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 20 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:18:11 <lambdabot>  2.718281828459046
05:18:17 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 25 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:18:18 <lambdabot>  2.7182818284590455
05:18:23 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 24 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:18:25 <lambdabot>  2.7182818284590455
05:18:32 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 23 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:18:33 <lambdabot>  2.7182818284590455
05:18:39 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 22 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:18:40 <lambdabot>  2.7182818284590455
05:18:47 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 21 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:18:48 <lambdabot>  2.718281828459045
05:19:05 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 % cont xs in cont . take 22 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:19:06 <lambdabot>    Occurs check: cannot construct the infinite type: a = Ratio a
05:19:07 <lambdabot>    Expe...
05:19:26 <dfeuer> > let cont [x] = x; cont (x:xs) = x + (1 % cont xs) in cont . take 21 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:19:27 <lambdabot>    Occurs check: cannot construct the infinite type: a = Ratio a
05:19:27 <lambdabot>    Expe...
05:20:50 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs::Ratio Integer in cont . take 21 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:20:51 <lambdabot>  410105312%150869313
05:20:59 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs::Ratio Integer in cont . take 25 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:21:00 <lambdabot>  14862109042%5467464369
05:21:07 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs::Ratio Integer in cont . take 100 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:21:09 <lambdabot>  6963524437876961749120273824619538346438023188214475670667%25617374787898587...
05:21:15 <dfeuer> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs::Ratio Integer in cont . take 50 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:21:16 <lambdabot>  1363322103204314826347779%501538173463478753560673
05:21:21 * dcoutts points at #haskell-overflow
05:21:23 <dfeuer> squee!
05:21:40 * dfeuer goes there.
05:22:48 <dcoutts> dons, ping
05:26:48 <dropdrive> let cont [x] = x::Ratio Integer; cont (x:xs) = x + 1 / cont xs in cont . take 21 $ 2 : concatMap (\x -> [1,2*x,1]) [1..]
05:27:14 <dropdrive> It seems like the "::Ratio Integer" can go either places.  Is there a "better" way of doing this (I hate making choices?)?
05:29:05 <ski> e.g.
05:29:07 <ski> > let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont . take 71 $ 2 : concatMap (\x -> [1,2*x,1]) [1..] :: Rational
05:29:08 <lambdabot>  32899961416752178009859175564060540001%12103219420556805047490636736113723601
05:29:31 <ski> @type let cont [x] = x; cont (x:xs) = x + 1 / cont xs in cont
05:29:33 <lambdabot> forall a. (Fractional a) => [a] -> a
05:30:23 <ndm> dcoutts, you are a Gtk2Hs person aren't you?
05:30:32 <dcoutts> ndm, aye
05:30:48 <ndm> is there any chance of having a one click windows installer?
05:31:05 <dcoutts> as opposed to the current installer?
05:31:06 <ndm> perhaps that even downloads the appropriate packages for you, having detected your Gtk setup and GHC setup
05:31:19 <ndm> its just the current instructions are a bit confusing....
05:31:45 <dcoutts> ndm, confusing?
05:32:05 <dcoutts> ndm, if you want to help imporve the win32 installer that'd be great :-)
05:32:23 <ndm> unfortunately i don't have enough time :(
05:32:36 <dcoutts> ndm, aye, always the problem for me too
05:32:57 <ndm> ah well, never mind - I'm trying to get a list of Haskell and Windows stuff
05:33:02 <dcoutts> ndm, so if we want binaries then we need to pick a ghc and gtk major version
05:33:04 <ndm> www.cs.york.ac.uk/~ndm/projects/windows.php
05:33:28 <dcoutts> ndm, we can build against an old gtk version and run with newer but then you don't get the features of the new one, eg cairo
05:33:29 <ndm> but unfortunately i can't reallyl add a "direct download" for Gtk2Hs because its not really that simple
05:33:47 <dcoutts> ndm, do you specify a ghc version then?
05:33:53 <ndm> no
05:33:55 <therp> excuse, how would I search in the documentation and in which when I would like to find a function for set-difference
05:34:13 <ndm> @hoogle Eq a => [a] -> [a] -> [a]
05:34:14 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
05:34:14 <lambdabot> List.intersect :: Eq a => [a] -> [a] -> [a]
05:34:14 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
05:34:17 <Cale> therp: on lists, or on sets?
05:34:21 <dcoutts> ndm, so you compile for multiple ghc versions?
05:34:23 <ndm> therp, \\ is the answer
05:34:25 <therp> cale: on lists.
05:34:37 <ndm> dcoutts, no, i don't compile, i just want to link to your versions
05:34:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
05:34:47 <dcoutts> ndm, I mean for you other win32 builds
05:34:51 <ndm> just as a central place to quickly and easily download win32
05:34:52 <dcoutts> you/your
05:34:55 <dcoutts> ah ok
05:35:08 <Cale> hoogle works well too, as demonstrated there :)
05:35:10 <ndm> for other win32 builds, it makes no difference - they are binaries, so don't depend on ghc
05:35:12 <therp> cale: thanks, but how would I search for such things? guessing the function types and ask lambdaboot?
05:35:19 <ndm> @where hoogle
05:35:20 <lambdabot> http://www.haskell.org/hoogle
05:35:24 <dcoutts> ndm, well you'd need two links, one for gtk and one for gtk2hs
05:35:48 <dcoutts> ndm, it's possible we could bundle gtk with gtk2hs, I've thought about that before.
05:35:55 <ndm> dcoutts, ok, will think about that - a bit more involved than i'd like, maybe 
05:36:04 <ndm> dcoutts, that would be good :)
05:36:18 <Cale> therp: well, that page has descriptions, it's fairly searchable, and you know you're looking for a list function, so in all likelihood it's there or the Prelude.
05:36:19 <dcoutts> ndm, do you have any other libs, since the ghc version thing is generic to libs
05:36:38 <ndm> dcoutts, how do you mean, any other libs?
05:36:47 <ndm> in that list, no, not yet
05:36:55 <dcoutts> ndm, so at the moment you've only got links to tools, not libs
05:37:02 <dcoutts> libs do depend on the ghc version
05:37:36 <ndm> yep, i realise that
05:37:39 <dcoutts> ndm, I mean you might like to start with a simpler lib to work out the lib issues
05:37:51 <ndm> dcoutts, probably a good idea - just gtk2hs is the one i use the most :)
05:37:58 <therp> hm hugs tells me \\ is an undefined variable, do I need to import stuff?
05:38:03 <dcoutts> ndm, the real problem I have with gtk2hs on win32 is dll search path issues
05:38:17 <therp> ah! got it :)
05:38:19 <kosmikus> therp: Data.List
05:38:38 <dcoutts> ndm, suppose you build a little prog with gtk2hs, how does that binary find the gtk dlls ?
05:38:48 <ndm> dcoutts, no idea - but it seems too
05:38:52 <dcoutts> ndm, so where should I install the gtk dlls
05:39:04 <dcoutts> ndm, that's because they get instaleld into the %PATH%
05:39:07 <ndm> dcoutts, does gtk2hs link in gtk on windows?
05:39:09 <dcoutts> which is very fargile
05:39:25 <ndm> i remember the binaries being quite large, so assumed they linked in
05:39:35 <dcoutts> ndm, it links the resulting progs to the gtk dlls, so it needs the gtk dlls at runtime
05:39:52 <dcoutts> ndm, the large binary size is something else (which is now fixed)
05:40:27 <dcoutts> ndm, the problem is that if you install a different zlib.dll somewhere on the %PATH% then it breaks the gtk dlls
05:40:32 <dcoutts> because we pickup the wrong one
05:41:15 <ndm> doh, ah well
05:41:16 <therp> I presume I have to create my own intersect function that can operate on infinite lists Ord [a] presuming both are sorted
05:41:31 <dcoutts> win32 seems to be setup to install apps fine (just bung everying into one dir) but it's useless for installing libs
05:41:47 <ndm> i think this has a lot of work behind it, so will probably start with an easier library
05:41:54 <dcoutts> there's now way to embed dll seach paths into a win32 binary
05:42:23 <dcoutts> and doing delayed loading seems very hard
05:43:16 <dcoutts> I know some apps cheat and use a wrapper prog that CD's to the gtk dll dir and then starts the real prog from there so that it'll always get the gtk dlls first on the dl search path
05:43:27 <ndm> that was just what i was going to suggest
05:43:33 <dcoutts> that's ok for an app to do, but we can't do that with ghc produced progs
05:43:58 <MarcWeber> Is it possible to clone a parser state? I want to "parse" directories. So the beginniing of the input stream is the same but will become different..
06:25:45 <dcoutts> dons, note that it seems possible to get good code with buildr/foldr if we change the definition slighltly
06:26:05 <dcoutts> essentialy we do the arity lifting manually
06:26:38 <dcoutts> so the fact that ghc is missing this analysis & transformation is no longer a problem
06:58:47 <shapr> MarcWeber: Parser state is probably something you can just grab and keep on using. Anytime you have a handle to something, it won't change.
07:00:55 <sieni> indeed, there's no state!!!1!1
07:05:20 <MarcWeber> shapr: You'll be right.. I had a look at the runParser function from parsec.. I want to write a small app which will make it much easier to get the file you want.. eg cd ea will take you to /etc/apache ... if there are more than one match you'll be asked which one to choose
07:06:21 <MarcWeber> My first prototype scans the filesystem before parsing.. And that is to slow because it will scan many directories it won't need.
07:06:29 <xerox> neologism: yes :-)
07:08:46 <shapr> MarcWeber: Do it lazy.
07:10:03 <shapr> MarcWeber: cd /e<tab> should look for files named /e* either when tab is pressed, or maybe you could run a separate thread that looks for tab completion stuff in the background?
07:10:50 <xerox> Or just use glob!
07:11:06 <MarcWeber> shapr: The problem is it also looks in /tmp and /usr and /lib .. before .
07:12:02 <MarcWeber> xerox: Then you have to type cd e*/a* and you'll be out of luch if there are two matches
07:12:33 <MarcWeber> Thats 3 additional characters 
07:15:11 <jgrimes_> xerox, shapr: I'm looking at Hope, and in modules/blob2/Text/RSS.hs, on line 107, I'm getting an error because CString only has two arguments
07:15:38 <jgrimes_> I've got the latest pull of HaXmL and Hope
07:16:45 <jgrimes_> ghc6.4.2, latest pulls of all referenced packages
07:17:58 <shapr> MarcWeber: I don't understand.
07:18:04 <xerox> I have not updated hope yet.
07:18:10 <xerox> Sorry :-|
07:18:24 <shapr> jgrimes_: Could be a bug, I know bringert did an RSS fix yesterday.
07:18:28 <xerox> Anybody has got a aip subscription?
07:19:05 <shapr> MarcWeber: What is looking in /tmp /usr and /lib first?
07:19:23 * shapr builds hope
07:19:33 <xerox> `APS Journals' that is.
07:19:36 <shapr> jgrimes_: Do you have the latest ByteString?
07:20:03 <jgrimes_> shapr: let me check
07:20:24 <jgrimes_> shapr: nope, updating it now
07:21:25 <shapr> A quick grep turns up ByteString.unsafeUseAsCStringLen in Data.ByteString.Base
07:22:01 <SamB> hmm, would anyone on osx86 like to test some (non Haskell) code that I've been working on?
07:22:43 <jgrimes_> shapr: hm, I looked at the HaXmL/Types.hs and this is the constructor for CString (for type Content i) in it: CString Bool CharData i
07:23:18 <shapr> Weird, I'll rebuild my hope.
07:23:31 <MarcWeber> man readable hash value ;)
07:23:36 <shapr> Strang, that's the error I'm getting...
07:23:51 <MarcWeber> Ah
07:23:55 <shapr> MarcWeber: Wha?
07:24:16 <MarcWeber> I tried to say:
07:26:55 <MarcWeber> Imagine I want to have this commandline : java -cp .: /usr/share/aspectj/lib/aspectjtools.jar myclass  I do not want to type <tab><tab> but some kind of human readable hash value. eg java -cp .:`myapp /usal/atooljar` Where / is root, usal = usr/share/aspectj/lib and atooljar should match the filename
07:27:30 <jgrimes_> shapr: I was also getting an error for ppContent for [CElem e], changed it to [CElem e _] since only e was being used. I was also getting a complaint on rssToXML because of a kind error on CFilter, fixed by changing it to CFilter a
07:31:00 <jgrimes_> shapr: ok... I think I might have found what the problem is
07:31:21 <jgrimes_> shapr: I forgot that the HaXmL darcs isn't up to date with the CVS
07:32:46 <jgrimes_> shapr: though I find it unlikely that they would forget to update darcs... so
07:32:55 <jgrimes_> I really have no idea at this point
07:32:55 <jgrimes_> :p
07:41:39 <jgrimes_> shapr: oh... INSTALL says it needs HaXmL 1.13, and the CString it has the right parameters
07:43:05 <ndm> jgrimes_, HaXml is kind of half cvs and half darcs, its entirely possible the darcs and cvs are out of sync
07:43:21 <ndm> and if you suspect that email the author
07:44:46 <jgrimes_> ndm: it also helps if I use the version of HaXmL the author says is required in the INSTALL file
07:44:49 <jgrimes_> :)
07:44:58 <jgrimes_> shapr: it is compiling now that rolled back to 1.13
07:47:18 <ADEpt> @seen shapr
07:47:18 <lambdabot> shapr is in #scannedinavian, #Haskell.se, #haskell and #ScannedInAvian. I last heard shapr speak 23 minutes and 22 seconds ago.
07:47:56 <shapr> @yow !
07:47:57 <lambdabot> It's NO USE ... I've gone to "CLUB MED"!!
07:57:09 <gds> query lambdabot 
07:57:16 * gds remembers the "/" this time...
08:03:12 <shapr> jgrimes_: HaXml 1.15 is way different, have you seen XmlContent?
08:08:54 * shapr boings
08:09:24 <jgrimes_> shapr: no I haven't
08:11:19 <shapr> It's sort of like deriving Read/Show but instead deriving Xml
08:11:43 <shapr> It's a lot like what dreamEye was talking about earlier, but in this case it's a mapping of value to Xml.
08:12:12 <jgrimes_> oh, cool.
08:13:05 <shapr> er, type to xml
08:13:09 <jgrimes_> right
08:13:10 <jgrimes_> :)
08:14:06 <shapr> I have a different Hope error...
08:14:41 <jgrimes_> oh?
08:14:51 <shapr> Not in scope: `P.unsafeUseAsCStringLen'
08:14:58 <shapr> It should be in scope though... 
08:15:09 <int-e> no, it's in ByteString.Base now
08:15:14 <int-e> (afaik)
08:15:39 <shapr> So, this won't work? import qualified Data.ByteString as P ; withBufferPtr b f = P.unsafeUseAsCStringLen b (\ (p,l) -> f (castPtr p, l))
08:16:13 <int-e> you can add import qualified Data.ByteString.Base as P ; ... and then it should work
08:16:16 <shapr> aha
08:16:20 <int-e> (you can reuse the same import name)
08:16:21 <jgrimes_> shapr: yep, after doing a make clean, I got the error too
08:17:48 <shapr> int-e: Thanks, that function moving was the problem.
08:19:06 <jgrimes_> yep.
08:21:36 * shapr sends a patch to bringert
08:21:58 <jgrimes_> :)
08:30:36 <shapr> Hi tom, long time no see.
08:30:46 <tmoertel> indeed -- work, work, work
08:30:52 <shapr> How's code treating you?
08:31:08 <tmoertel> right now, pretty good; you?
08:31:24 <shapr> I'm having fun with Hope - http://www.scannedinavian.com/hope/
08:32:18 <shapr> I'm hoping that Hope will turn out to be something like Zope in Haskell.
08:33:16 <tmoertel> That's a big target.  :)
08:33:24 <vegai> ah, that's where the name's from?
08:33:44 <shapr> Hope already runs on top of xhtml, newcgi, haskelldb, and other bits.
08:33:52 <vegai> is Zope that great?
08:33:54 <vegai> as an idea?
08:33:58 <shapr> It's useful.
08:34:05 <shapr> Nah, the ideas behind it aren't that special.
08:34:14 <shapr> But it includes a lot of functionality in a single package.
08:34:36 <vegai> right
08:34:55 <Philippa_> if there's one thing Haskell'll generally wail on Python for, it's well-factored functionality
08:35:39 <shapr> I would like to define a type and "derive DB" to get HaskellDB persistence and maybe "derive XHTML" to get a simple xhtml display for it.
08:36:38 <shapr> That and authentication and templating would solve most of my webdev needs.
08:37:16 <vegai> that'd sound a bit Railsy
08:37:36 <shapr> Yup, it'd be cool.
08:38:18 <vegai> Haskell-on-Maglev
08:38:18 <shapr> With the advantage that HaXml would allow you to typecheck the output. You could guarantee legal outputs.
08:38:25 <shapr> Oh I like it!
08:38:31 <vegai> ;)
08:38:34 <jgrimes_> :)
08:38:46 <vegai> I wish I was half as good with implementations as names
08:39:15 <shapr> We all start at the beginning. You get better with implementations by doing them.
08:39:44 <vegai> yes, well that's the problem
08:39:52 <vegai> getting to the "doing" phase
08:40:56 <shapr> Open editor, write code.
08:41:14 <vegai> gotta feed the kid first...
08:41:29 <vegai> or perhaps I should teach him to fish
08:42:05 <vegai> but you're right, of course.
08:42:17 <neologism> vegai: LOL
08:42:46 <vegai> whaat ;)
08:42:47 <shapr> Maglev is a great name, I gotta suggest that to bringert.
08:44:17 <vegai> sure
08:44:31 * shapr sends email
08:46:58 <shapr> Philippa_: Haskell naturally encourages well-factored functionality.
08:47:32 <shapr> Right now I'm looking at extending a forum plugin for Plone/Zope to add a view that does not have the top level navigation.
08:48:09 <Philippa_> shapr: there're a few ways that Haskell can outright factor better, too - mostly to do with controlling side-effects
08:49:06 <shapr> Yes... for example, this forum allows different views, but the user can only set one choice of view at a time.
08:49:22 <shapr> I need to display two flavors of views in different parts of the site for the same user without setting a global value.
08:50:01 <urz> my program issues an error:  "frpsdl: <<loop>>"
08:50:03 <urz> that's it.
08:50:07 <urz> runtime error
08:50:14 <shapr> Are you using Yampa?
08:50:18 <urz> yes
08:50:24 <shapr> Neat, what for?
08:50:34 <urz> to learn
08:50:44 <shapr> Can you simplify the program and get rid of the loop?
08:50:51 <urz> i wired it up to power a sdl video game
08:50:57 <urz> no
08:51:04 <shapr> That's nifty, any screenshots?
08:51:09 <urz> not yet
08:51:12 <urz> it doesnt work at all yet
08:51:22 <shapr> Can you get basic Yampa stuff to work?
08:51:27 <urz> well
08:51:33 <urz> I got a bouncing ball working
08:51:41 <shapr> Are you using the update Yampa distro with the GADT optimizations?
08:51:52 <urz> i dont think so
08:51:59 <urz> my yampa calls itself afrp
08:52:22 <urz> what's GADT?
08:52:30 <shapr> http://www.scannedinavian.com/hope/entry/17
08:52:53 <urz> so you know yampa pretty well
08:52:55 <urz> ?
08:53:01 <urz> can you help me?
08:53:02 <urz> heh
08:53:09 <shapr> No, I don't know Yampa well.
08:53:14 <shapr> I've used it a bit, that's all.
08:53:16 * joelr1 waves
08:53:20 <shapr> hola joelr1
08:53:28 <joelr1> folks, where can i find info on array comprehensions in haskell?
08:53:47 <shapr> urz: I seriously doubt that the loop problem is Yampa specific.
08:54:12 <shapr> It's more likely you built a loop into your code somewhere :-) Are you familiar with arrows?
08:54:21 <urz> im using arrows
08:54:26 <shapr> joelr1: Aren't those used in ChilliX's NDP parallel array?
08:54:49 <urz> well let me explain what i've done
08:54:53 <shapr> urz: Yeah, but do you understand them? I used arrows for a few weeks with no clue :-)
08:54:57 <urz> first, i converted a bouncing ball program to frp 
08:54:59 <shapr> ok
08:55:21 <urz> that was a successful endevour (eventually)
08:55:24 <shapr> cool
08:55:30 <joelr1> shapr: dunno. i found some old thread on clean vs. thread and spj was talking about how programming with haskell array comprehensions was different from using arrays in c
08:55:56 <shapr> joelr1: Oh, maybe array comps are in the manual then?
08:56:00 <urz> it worked by using the old updateBall function which transforms an old ball state to a new one.  But only on a frame pulse event that i made
08:56:19 <shapr> urz: That makes sense.
08:56:45 <urz> it's completely independent of the time.  if i ran at a higher frame rate, the ball would move faster
08:57:08 <dcoutts> joelr1, are you using array comprehensions then?
08:57:08 <shapr> There's probably a better way :-)
08:57:13 <urz> well
08:57:29 <joelr1> dcoutts: i'm just trying to learn what spj was talking about :D
08:57:30 <urz> I was trying to write a more signal function based ball 
08:57:35 <joelr1> dcoutts: do you know?
08:57:36 <shapr> urz: Seems like a 'heartbeat' would be better.
08:57:45 <dcoutts> joelr1, I've been looking at this recently yes
08:57:50 <urz> what's a heartbeat?
08:58:03 <shapr> Just something like a timer that pulses 20 times a second or so.
08:58:06 <dcoutts> joelr1, it means generating an array from a list combrehension but then deforestign the intermediate list
08:58:30 <dcoutts> so you (should) end up with good code that initialises the array in a loop
08:58:47 <joelr1> dcoutts: do you have an example by chance?
08:58:57 <urz> well
08:59:04 <joelr1> dcoutts: cause what you are saying (the deforesting part) is over my head
08:59:21 <dcoutts> joelr1, array (0,10) [ (n, 2^n) | n <- [0..10] ]
08:59:28 <urz> to make the signal function based version, I wanted to use a bounce event that it switches on
08:59:39 <shapr> urz: I ran sopwith on my 4.77MHz IBM XT and it was great. When the CPU fried (My first computer, I left the case off, doh) I got a new mobo with a turbo button. Suddenly sopwith was unplayable!
08:59:48 <dcoutts> joelr1, so that's creating an array using a list comprehension right?
09:00:09 <shapr> That's when I realized that simulations and games should work according to time rather than cpu speed :-)
09:00:15 <joelr1> dcoutts: yep
09:00:21 <dcoutts> joelr1, but as you can see, there's no real need to actually allocate list elements we could do a nice imperitive loop and that'd be quicker
09:00:39 <dcoutts> joelr1, so the point is that the list fusion should give us exactly that
09:00:53 <dcoutts> list fusion is the elimination of intermediate lists
09:00:54 <urz> shapr: my frames are coded to be 45 times per second on average provided the computer is fast enough and regardless of the speed of the computer
09:00:56 <shapr> urz: I'd love to see the code for your SF bounce.
09:00:57 <joelr1> dcoutts: what is list fusion? aha! thanks!
09:01:02 <dcoutts> by fusing a list produce and a list consumer
09:01:15 <dcoutts> the comprehension is the producer, the array builder is the list consumer
09:01:19 <joelr1> dcoutts: so you are saying that it's most efficient to initialize an array using a list comprehension since that eliminates intermediate lists?
09:01:42 <urz> my code is cluttered with experiments right now, shapr.  would you want it with all the garbage?
09:01:44 <dcoutts> joelr1, any good list producer would do, a list comprehension is just one example
09:01:54 <shapr> urz: Sure, it's okay with me.
09:02:11 <shapr> I may not have time to actually play with it for the next few weeks, but I'd like to get a copy to look at when I have time.
09:02:14 <shapr> Yampa is nifty.
09:02:19 <urz> so you'd help me track down my problem?
09:02:25 <shapr> Not immediately.
09:02:29 <joelr1> dcoutts: thanks. what is deforestation in this case?
09:02:33 <shapr> I'm moving to Stockholm in a few days.
09:02:58 <dcoutts> joelr1, deforestation is the general case of fusion, but for any data structure not just lits
09:02:58 <shapr> urz: If you want more immediate help, ask on the Yampa mailing list. Henrik and the other guys are very helpful.
09:03:06 <dcoutts> joelr1, if you really want to see what's going on you need to look at -ddump-simple-stats and sometimes also -ddump-simpl-ierations
09:03:15 <joelr1> dcoutts: ok, thanks
09:03:27 <shapr> urz: There's a recent thread on ghc-users about diagnosing <<loop>> problems.
09:03:31 <shapr> Maybe that would help?
09:03:34 <joelr1> dcoutts: i hope there will be good slides from the ghc hackathon :D
09:03:50 <dcoutts> joelr1, (-ddump-simpl-iterations) those show you what transformations the optimiser is doing
09:04:58 <joelr1> dcoutts: thanks!
09:05:08 <dcoutts> http://www.linuxjournal.com/article/9096
09:05:18 <dcoutts> an article on Haskell ^^
09:05:23 <shapr> yay!
09:05:51 <urz> do we have a Pastebin?
09:06:39 <shapr> I use rafb.net
09:06:57 <joelr1> dcoutts: a new one too!
09:07:22 <heatsink> In TH, one of the declaration constructors is DataD Cxt Name [Name] [Con] [Name]
09:07:33 <heatsink> What is the last [Name]?
09:08:38 <boliver_> Maybe the list of classes following "deriving"?
09:08:59 <heatsink> oh, that makes sense.
09:10:16 <satan> best way to compute the average of a list? I tried let f = \x -> sum x / length x but it says something about an instance of a Fractional Int
09:10:32 <dcoutts> @type (/)
09:10:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:10:50 <joelr1> does anyone have a macbook pro?
09:11:14 <dcoutts> satan, length returns an Int
09:11:18 <satan> ok
09:11:25 <dcoutts> > 1 / (2 :: Int)
09:11:27 <lambdabot>  add an instance declaration for (Fractional Int)
09:11:27 <lambdabot>   In the definition of `...
09:11:30 <urz> theres another length function
09:11:37 <urz> genericLength
09:11:38 <urz> or something
09:11:47 <urz> it will give a double
09:11:50 <urz> or whatever you need
09:11:56 <satan> how do I add this Instance Declaration its talking about?
09:11:59 <dcoutts> satan, so the solution is to convert the Int to the right type
09:12:04 <satan> ok, urz, i'll look into that too, thanks
09:12:12 <urz> http://rafb.net/paste/results/SHDZjr97.html
09:12:16 <satan> dcoutts: by casting it? or whatever thats called in haskell
09:12:19 <urz> there is the working bouncing ball signal function
09:12:28 <dcoutts> > let list = [1,2,3] in sum list / fromIntegral (length list)
09:12:29 <lambdabot>  2.0
09:12:37 <dcoutts> @type fromIntegral
09:12:39 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:13:17 <dcoutts> satan, right, though it's not casting, it's just applying a conversion function
09:13:23 <urz> @type genericLength
09:13:23 <satan> nice, thanks, dcoutts
09:13:25 <lambdabot> forall i b. (Num i) => [b] -> i
09:13:46 <satan> i see, how did you know about from Integral, ie. how would I find other similar stuff? in the Prelude?
09:13:51 <urz> why fromIntegral it when you have a direct route
09:14:27 <satan> hmm genericLength is not in scope
09:14:43 <urz> oh
09:15:22 <satan> perhaps there's a module I need to load?
09:15:22 <urz> import Data.List
09:15:28 <satan> ok
09:15:36 <urz> or use fromIntegral ;)
09:15:42 <satan> haha ok
09:24:23 <satan> what's the difference between fmap and map?
09:24:27 <satan> @type fmap
09:24:28 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
09:24:33 <satan> @type map
09:24:34 <SamB> fmap is overloaded
09:24:35 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
09:24:45 <satan> to handle any type?
09:24:52 <SamB> to handle any Functor
09:25:11 <SamB> @instances Functor
09:25:13 <lambdabot> ((, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:25:14 <satan> i guess that begs the question, what's a Functor?
09:25:17 <satan> sorry, new to this
09:25:31 <SamB> @blame instances
09:25:31 <lambdabot> Unknown command, try @list
09:26:06 <SamB> a functor is pretty much something you can fmap over
09:26:24 <SamB> all monads are functors, but not all Monads are necessarily Functors
09:26:49 <satan> so you mean, say a fucntion that's not necessarily mathematical applied to all elements of a list?
09:27:22 <SamB> what kind of a function isn't mathematical?
09:27:54 <satan> i dunno, i'm just trying to understand it better
09:28:02 <SamB> map is a special case of fmap, basically
09:28:20 <satan> ok
09:29:00 <SamB> a functor would typically be either a kind of datastructure or a monad
09:29:08 <SamB> or both, of course
09:29:31 <satan> ahh ok
09:29:41 <satan> ok got it :)
09:29:43 <satan> thanks buddy
09:40:16 <Wikipedia-Gast> life is a cookie
09:42:21 <kosmikus> @seen Lemmih
09:42:22 <lambdabot> I saw Lemmih leaving #haskell 19 hours, 46 minutes and 31 seconds ago, and .
09:42:29 <Wikipedia-Gast> why
09:44:43 <kosmikus> @seen JaffaCake
09:44:43 <lambdabot> I saw JaffaCake leaving #haskell 1 hour, 6 minutes and 13 seconds ago, and .
09:44:47 <Wikipedia-Gast> why
09:50:58 <monochrom> life is a function
09:51:06 <xerox> From what to what?
09:51:14 <monochrom> life is a function of environment to state
09:51:21 <Wikipedia-Gast> why
09:51:23 <xerox> Makes sense.
09:51:30 <monochrom> axiom :)
09:51:40 <Wikipedia-Gast> why
09:51:58 <xerox> 
09:52:19 <Wikipedia-Gast> why
09:52:23 <xerox> (That's a mu.)
09:52:45 <Wikipedia-Gast> why
09:52:50 --- mode: ChanServ set +o shapr
09:53:12 <shapr> Wikipedia-Gast: Hey, you sound like a bot. Are you real person or shall I remove you?
09:53:29 <xerox> `why'
09:53:50 <Wikipedia-Gast> whats a bot
09:53:51 <monochrom> I saw a Chinese character, meaning non-existence, pronouncing like "moo".
09:54:16 <shapr> Wikipedia-Gast: Are you learning the Haskell programming language?
09:54:17 <xerox> Pun!
09:54:28 <Wikipedia-Gast> yes
09:54:42 <shapr> Wikipedia-Gast: How do you like it so far?
09:55:01 <apfelmus> Wikipedia-Gast: so why is your realname "Java User" then?
09:55:02 <Wikipedia-Gast> why
09:55:08 <xerox> hehe.
09:55:08 <shapr> hmmm
09:55:28 <shapr> Wikipedia-Gast: Are you covered in purple spots?
09:55:40 <neologism> shapr: arent we all? :)
09:55:50 <Wikipedia-Gast> no
09:55:50 * shapr is attempting a turing test...
09:55:51 * xerox crosses finger in the hope we see a passing Turing Test.
09:56:04 <shapr> Wikipedia-Gast: Can you reply in more than one word?
09:56:26 <Wikipedia-Gast> yes, two
09:56:30 <shapr> hah
09:57:03 <neologism> Wikipedia-Gast: is shapr covered in purple spots?
09:57:03 <JKnecht> Wikipedia-Gast: who do you favor in the games?
09:57:08 <monochrom> I think it is coherent when conversing with ops.  To all other people it just says "why".
09:57:29 <Wikipedia-Gast> yes
09:57:32 <shapr> madpickle: Hiya, how's code?
09:57:44 <madpickle> hi
09:57:50 <apfelmus> Wikipedia-Gast is an interesting machine, we should study it. what language are you coded in, Wikipedia-Gast?
09:57:55 <madpickle> which code, shapr?
09:58:05 <neologism> Wikipedia-Gast: jhgs kjh kja guk atbnaky vnkytah?
09:58:06 <shapr> madpickle: Whatever code you're writing?
09:58:12 <madpickle> oh, it's pretty good.
09:58:20 <madpickle> i'm playing around with this Project Euler thing
09:58:24 <shapr> Wikipedia-Gast: ich habe keine ahnung... Sie?
09:58:41 <monochrom> I think it has crashed.
09:58:51 <Wikipedia-Gast> no
09:58:51 <xerox> ...pif.
09:59:00 <Wikipedia-Gast> it never crashes
09:59:07 <Wikipedia-Gast> it lives forever
09:59:18 <JKnecht> ur polyphasic?
09:59:26 <Wikipedia-Gast> whats that
09:59:27 <shapr> Wikipedia-Gast: spreuchen sie deutsche? talar du svenska? parlez vous francais? xu do tavla mi bau la lojban
09:59:35 <Wikipedia-Gast> I speak english
09:59:47 <jgrimes_> shapr: do you know lojban?
09:59:54 <shapr> jgrimes_: je'e
10:00:09 <jgrimes_> shapr: cool :p (I don't, by the way)
10:00:09 <Wikipedia-Gast> why
10:00:16 <xerox> Wikipedia-Gast - Why?
10:00:35 <shapr> madpickle: Oh that's cool
10:00:38 <Wikipedia-Gast> why what?
10:01:49 <JKnecht> polyphasic: short sleep cycles (i.e. 'crashes')
10:01:57 <Wikipedia-Gast> no
10:02:07 <shapr> They seem more like catnaps to me. I'd like to try polyphasic sleep sometime.
10:02:12 <Wikipedia-Gast> why
10:02:16 <jgrimes_> madpickle: Project Euler seems pretty nifty.
10:02:29 <madpickle> yeah, it is
10:02:31 <madpickle> it's good fun
10:02:39 <shapr> Do you know of anything else along those lines?
10:02:45 <Wikipedia-Gast> why
10:03:03 <madpickle> nah - only site i know of.
10:03:35 <vegai> has any worthwhile Haskell books come out recently?
10:03:52 <Wikipedia-Gast> why
10:04:01 <xerox> Noisy bo[yt].
10:04:14 <Wikipedia-Gast> no
10:04:59 <shapr> Wikipedia-Gast: Hey... lead, follow, or get out of the way.
10:05:19 <Wikipedia-Gast> why
10:05:33 --- kick: Wikipedia-Gast was kicked by shapr (Kicked by shapr)
10:05:47 <shapr> I promise, I'm usually a nice op.
10:05:50 <madpickle> heheh
10:05:59 <shapr> Wikipedia-Gast: That's why.
10:06:04 <SyntaxNinja> does anyone have advice on a document system? I kinda like docbook, but it isn't rendering nicely, and I can't have non-nerds work on the documents.  I'm thinking of just going w/ ooffice xml format.
10:06:06 <Wikipedia-Gast> why?
10:06:13 <dmhouse> Hey all.
10:06:14 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
10:06:18 <madpickle> SyntaxNinja: you could try LaTeX?
10:06:19 <jgrimes_> hey dmhouse 
10:06:20 <Wikipedia-Gast> why
10:06:23 <shapr> Wikipedia-Gast: Because, if you are unable to lead or follow, I'll get you out of the way of others.
10:06:33 <Wikipedia-Gast> thats boring
10:06:50 <SyntaxNinja> madpickle: same problem w/ non-nerds.
10:06:50 <dcoutts> SyntaxNinja, txt2tags it's quite simple too and generates latex,xhtml,etc
10:06:56 <Wikipedia-Gast> why
10:06:59 <madpickle> SyntaxNinja: doh, i missed that bit - sorry.
10:07:10 <SyntaxNinja> Wikipedia-Gast: knock it off
10:07:11 <Wikipedia-Gast> why
10:07:12 --- mode: shapr set +b *!JavaUser@*
10:07:16 --- kick: Wikipedia-Gast was kicked by shapr (Kicked by shapr)
10:07:16 <dcoutts> SyntaxNinja, http://txt2tags.sourceforge.net/markup.html
10:07:40 <madpickle> and thus endeth the reign of wikipedia-gast
10:07:47 <shapr> I notice that #opensolaris already kicked him.
10:07:50 <SyntaxNinja> yay shapr
10:07:54 <shapr> Now he's only on #apache and #debian.de
10:08:07 * shapr boings
10:08:10 <madpickle> some people are just inherently obnoxious
10:08:14 <madpickle> i blame food additives
10:08:25 <SyntaxNinja> dcoutts: I'll look at that.
10:08:32 <shapr> madpickle: I think you're just fascinated with pickles.
10:08:38 <madpickle> i'm mad about them
10:08:43 * shapr laughs
10:08:46 <jgrimes_> haha..
10:08:48 <dmhouse> Hi jgrimes_.
10:09:38 <monochrom> For documents, on a bad day I use a front-end to LaTeX, e.g., LyX, MathSPad.  On a good day I use LaTeX directly.  I don't believe in stereotypes.
10:10:13 <SyntaxNinja> monoc:yeah, maybe lyx would work. it always looks so klunky, so I'm not sure I can get the non-nerds to accept it (is that what you mean by steriotypes?)
10:10:31 <monochrom> Yes.
10:10:38 <madpickle> depending on what they need, MS Wordpad might suffice
10:10:44 <madpickle> it generates .RTF
10:10:51 <madpickle> which is a fairly documented standard
10:11:04 <dmhouse> SyntaxNinja: How about a wiki?
10:11:29 <dmhouse> Unless you need more complex layouts etc.
10:11:44 <monochrom> You can present LyX to an individual and let him decide whether he gets accustomed to it.  Presuming he's non-nerd therefore whatever is very wrong.
10:12:25 <SyntaxNinja> dmhouse: needs to print nice.
10:12:27 <madpickle> OpenOffice, heck, that'd probably suffice
10:12:33 <madpickle> never printed anything in OO tho
10:12:42 <SyntaxNinja> monochrom: presuming he's a he is also wrong :P
10:12:52 <monochrom> Yeah
10:13:24 <monochrom> The human brain is amazing, can learn almost anything.
10:13:32 <madpickle> but is it willing to?
10:13:36 <SyntaxNinja> monochrom: I have grounded reasons for believing that she won't like lyx, which I've chosen to express by saying that she's not a nerd, but I can see how you might think it came the other way.
10:13:36 <madpickle> "those darndest machines"
10:13:54 <madpickle> most people are luddities; esp. with regards to computers that "ought to operate like my TV"
10:14:13 <madpickle> cue blinking VCR timer
10:16:01 <Philippa_> SyntaxNinja: it took me a while to convince Damien that LaTeX isn't totally evil, I don't know he'll ever actually use it...
10:16:11 <shapr> I wish @remember were back in lambdabot and handled multiline quotes. That "mad about pickles" quote is cute.
10:16:19 <madpickle> heheh
10:16:21 <monochrom> Willingness can be induced by meta-means, such as personal persuasion and charm.
10:16:31 <madpickle> or grey goose
10:16:33 <Philippa_> monochrom: *hah*
10:16:45 <monochrom> But it comes down to this: if a brain can learn English, it can learn any arbitrary system.
10:16:54 * Philippa_ sniggers
10:17:00 <madpickle> indeed, but the concept of time figure into this
10:17:06 <Philippa_> depends how well you have in mind for learning english
10:17:15 <SyntaxNinja> monochrom: I'm not so much into bending people to my will.
10:17:15 <Philippa_> and I see a lot of people who can't cope with it nested too deep
10:17:21 <madpickle> ultimately one will have to determine how many resources (mental or otherwise) one wants to devote to learning something
10:17:44 <madpickle> like saying everybody ought to be a certified mechanic to drive a car, despite most people seeing them as a utility
10:17:51 <madpickle> (or at best, an extension of something...)
10:17:58 <Philippa_> make taxis cheaper and hey, works for me
10:18:00 <monochrom> Yes, do take note of time constraints, which is outside the scope of my claims.
10:20:16 <xerox> SyntaxNinja: some wikis have print-friendly CSS which is enabled when the page goes into a printing device.
10:21:01 <xerox> Via `media type' IIRC.
10:21:30 <xerox> <link rel="stylesheet" href="style.css" type="text/css" media="screen" />
10:21:35 <SyntaxNinja> xerox: that would actually be ideal.
10:21:36 <xerox> If I am not mistaken ?oldwiki did it.
10:21:43 <SyntaxNinja> if we could get it to look OK
10:21:48 <shapr> I think most computer users end up being 'taxi passengers'.
10:21:52 <xerox> (I discovered it printing The Monad.Reader.)
10:22:06 <shapr> Heck I feel like a passenger often enough and I study CS theory for both fun and profit.
10:22:49 <xerox> SyntaxNinja - Today was the first day, 6hrs of exam, two more days to come, yeep.
10:23:11 <xerox> They have also extracted my letter as the first one for the orals, so I am the first one. Next week, gurgle.
10:23:12 <SyntaxNinja> xerox: w0t
10:24:02 * xerox `ap` dinner `ap` specialRelativity
10:41:51 <dmhouse> Anyone implemented Markdown in Haskell?
10:43:31 <dmhouse> Hmm. Seems http://advogato.org/person/pesco/ that guy has.
10:43:34 <dmhouse> Or is.
10:45:54 <heatsink> hmm... can't run Q monads interactively
10:49:59 <int-e> > $a
10:50:00 <lambdabot>  Parse error
10:50:46 <int-e> heatsink: http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/ShowQ.hs might be useful.
10:50:52 <int-e> > \a -> a
10:50:53 <lambdabot>  Add a type signature
10:50:58 <int-e> > \a -> a :: Int -> Int
10:50:59 <lambdabot>  <(Int -> Int) -> Int -> Int>
10:52:32 <dmhouse> Is khjk.org working for anyone?
11:08:25 <dfeuer> I've never written an editor.  Does anyone here know of a simple demonstration editor written in Haskell?
11:08:49 <xerox> Pull yi, unpull a thousand patches, maybe.
11:09:03 <dfeuer> ?
11:09:07 <xerox> ?where yi
11:09:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
11:09:12 <dfeuer> oh.
11:10:15 <jgrimes_> hm, might have to take a look at that sometime
11:10:27 <dfeuer> I was wondering if one might be implemented using finger trees with an arbitrary number of fingers
11:14:46 <xerox> How does a Finger-Tree differ from a Tree?
11:26:19 <dfeuer> xerox, a finger tree is a tree, but it gives fast access to certain elements.
11:26:24 <dfeuer> Sort of.
11:26:27 <dfeuer> I don't know enough.
11:26:49 <dfeuer> It's a tree with a very strange shape, for sure.
11:26:52 <heatsink> int-e: thanks
11:44:37 <lscd> shapr: polyphasic is interesting to try...
11:56:32 <heatsink> @hoogle concatMaybes
11:56:33 <lambdabot> No matches found
11:56:39 <heatsink> @hoogle catMaybes
11:56:40 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
11:59:53 <dfeuer> xerox: yi uses a mutable buffer.
12:00:32 <xerox> No luck for your demonstrating code, then.
12:00:39 <dfeuer> Nope.
12:01:16 <dfeuer> I was thinking it'd be really cool if it used persistent data structures for undo/redo, but it doesn't.
12:01:26 <xerox> Cale wrote MonadUndo.
12:01:31 <dfeuer> ?
12:01:35 <dfeuer> show me?
12:01:56 <xerox> ?oldwiki MonadUndo
12:01:56 <lambdabot> http://www.haskell.org/hawiki/MonadUndo
12:14:24 <dfeuer> I think of undo/redo (including MonadUndo) as a very limited interface to the tree of edits.
12:16:32 <jgrimes_> dfeuer: the finger tree you mentioned, does it fit the definition of a tree in graph theory?
12:16:39 <sieni> naturally one should use the Darcs model with one character patches
12:17:13 <dfeuer> I'd like to have a nice, presumably graphical interface to navigate the tree (actually DAG), bookmark particular branches, and do nifty things like compare or merge two branches.
12:17:27 <dfeuer> jgrimes, yeah.
12:19:02 <dfeuer> The tricky thing, then, is to serialize the whole thing.  Tricky because the serialized version should use sharing, and that's not so easy in Haskell.
12:19:36 <dfeuer> (without an implementation-provided serialization primitive, that is)
12:22:15 <ptolomy_> Anyone played around with jhc?
12:22:55 <ptolomy_> (I'm curious regarding current status and overall impression.)
12:25:57 <ptolomy_> > (last . take 200) [1..]
12:25:58 <lambdabot>  200
12:26:12 * ptolomy_ hugs lambdabot.
12:27:34 <xerox> > [1..] !! 200
12:27:35 <lambdabot>  201
12:39:49 <heatsink> @hoogle Name -> Dynamic
12:39:50 <lambdabot> No matches, try a more general search
12:40:38 <heatsink> Is there a way to compile and evaulate TH code and compute something based on the result inside a splice?
12:43:25 <SamB> what do you mean?
12:43:37 <SamB> you mean directly nested splices?
12:43:39 <heatsink> I want to make a function :: Int -> Type -> Q [Dec] that takes a bounded integral type and raises a compile-time error if the integer is greater than the maxBound of the type.
12:44:19 <SamB> no, I don't think you can do that
12:45:09 <heatsink> alright, I'll just be careful not to cause that error :)
12:48:17 <lightstep> was there an answer to the wacky type classes question from yesterday?
12:50:12 <lightstep> perhaps i would try to read all the papers linked from jhc's website
13:02:36 <dfeuer> Grrr
13:03:20 <dfeuer> I'm not finding what I'm looking for.
13:03:43 <lightstep> what is it?
13:04:28 <dfeuer> A way to save values to disk (or similar), preserving sharing.
13:06:15 <heatsink> That would be useful.  But I think it would need some hooks into the GC to accomplish that.
13:06:33 <heatsink> or hacks into the GC :)
13:06:43 <lightstep> not necessarily
13:07:14 <lightstep> you only need lisp's EQ, or pointerValueOf::a->Addr
13:07:29 <dfeuer> Which obviously could only appear within the IO monad.
13:07:29 <heatsink> But the GC can move objects so their addresses can chagne.
13:08:18 <lightstep> not if you force everything before
13:08:37 <dfeuer> Even then, but doesn't the GC leave a forwarding address?
13:09:15 <xerox> Mount your hard disk as ram. =)
13:09:22 <heatsink> :)
13:10:25 <dfeuer> So is there a facility to do this?  Or a fundamental reason it can't be done?
13:12:29 <heatsink> dfeuer: There is currently no facility to do this.
13:12:44 <dfeuer> :
13:12:46 <dfeuer> :-/
13:13:11 <dfeuer> Is there a reason it can't be done?
13:13:27 <heatsink> It's difficult to do because a complete solution would need the capability to store unevaluated functions and to work around the GC's ability to move objects in memory at arbitrary times.
13:14:41 <dfeuer> For my purposes, at least, it would only be necessary to store fully evaluated objects that don't contain closures.
13:14:54 <dfeuer> (or at least, that would be enough to be very useful, I believe)
13:16:02 <dfeuer> Is there some feature of Lisp implementations that makes them capable of supporting eq? that Haskell implementations lack (for efficiency)?
13:16:30 <lightstep> object identity
13:16:41 <lightstep> in haskell, you only have equal?
13:16:44 <dfeuer> ...
13:16:54 <dfeuer> Object identity is a language feature.
13:17:07 <dfeuer> I'm talking about implementation features.
13:17:07 <lightstep> sure
13:17:11 <heatsink> dfeuer: I think Haskell doesn't have that kind of eq because it breaks referential transparency.
13:17:18 <heatsink> dfeuer: But it should be possible to implement.
13:17:22 <lightstep> http://okmij.org/ftp/Haskell/bothTrue.txt
13:17:22 <int-e> one of the results of referential transparency is that a copy is indistinguishable from the original
13:17:38 <lightstep> this says hugs has this feature
13:18:11 <dfeuer> heatsink, right, I know it breaks RT, but sometimes you want that anyway.  One example is to save a structure to disk and load it back in later.
13:18:34 <int-e> (it would come in handy sometimes though. Imagine a map implementation where map f applied to (repeat 1) would result in repeat (f 1))
13:18:56 <defcon8> does haskell have nice text processing features like list comprehensions, the same kind of list functions and so on?
13:18:59 * int-e feels redundant.
13:19:29 <lightstep> defcon8, it sure does
13:20:11 <defcon8> does it have things like for x in range(10): print x
13:20:36 <ptolomy_> > mapM_ print [1..10]
13:20:37 <lambdabot>  No IO allowed
13:20:40 <ptolomy_> aww.
13:21:00 <int-e> > mapM show [1..10]
13:21:01 <lambdabot>  ["1234567891","1234567890"]
13:21:05 <dfeuer> int-e, indeed...  
13:21:08 <defcon8> for x in [a,b,y,s,u]: print x
13:21:58 <defcon8> ?
13:22:25 <ptolomy_> defcon8: if a,b,y,s,u are the same type and implement 'show'.. sure.
13:22:59 <madpickle> say, regarding stuff like that
13:23:06 <madpickle> could someone point me to a good website covering string manipulation?
13:23:13 <defcon8> yes, me too
13:23:21 <ptolomy_> what sort?
13:23:24 <madpickle> basics.
13:23:31 <madpickle> or a list of functions
13:23:43 <lightstep> there was some sort of tutorial of the standard libraries a year or so ago
13:24:11 <ptolomy_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html <-- this seems rather unhelpful, but most string stuff is done using these.
13:24:27 <madpickle> that's a good start
13:24:29 <ptolomy_> also "words", "lines", "unwords", and "unlines".
13:24:55 <ptolomy_> I think that it would be nice to have a wiki page for "I have a string and I want ___.. how do I go about doing that?".
13:25:03 <defcon8> yes
13:25:10 <xerox> ?hoogle Parsec
13:25:11 <lambdabot> Text.ParserCombinators.Parsec :: module
13:25:11 <lambdabot> Distribution.Setup.parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
13:25:11 <lambdabot> Distribution.Setup.parseConfigureArgs :: ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
13:25:17 <xerox> ?docs Text.ParserCombinators.Parsec
13:25:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
13:25:23 <xerox> There!
13:25:25 <madpickle> all hail xerox
13:25:26 <madpickle> :D
13:25:42 <ptolomy_> http://pleac.sourceforge.net/pleac_haskell/strings.html <-- this is useful, too.
13:25:44 <lightstep> http://members.chello.nl/hjgtuyl/tourdemonad.html
13:25:48 <lightstep> that's one for monads
13:25:59 <madpickle> cheers
13:26:00 * ptolomy_ loves parsec.
13:26:31 <lightstep> http://www.haskell.org/haskellwiki/Reference_card
13:26:55 <lightstep> also http://zvon.org/other/haskell/Outputglobal/index.html
13:26:59 <defcon8> ptolomy: isn't it "ptolemy" ?
13:28:24 <ptolomy_> defcon8: Nope.
13:28:33 <ptolomy_> defcon8: Unless you happen to be talking about the historical figure. :-P
13:28:35 <defcon8> google tries to correct it as ptolemy aswell
13:28:38 <defcon8> yes, i am
13:28:46 <defcon8> what are you talking about?
13:30:03 <heatsink> GHC tells me that .&. is not in scope, though I've imported Data.Bits... http://www.rafb.net/paste/results/xQlKfy91.html
13:30:06 <dfeuer> int-e, is there a general graph fold that preserves sharing?
13:30:08 <ptolomy_> defcon8: Me.
13:30:14 <defcon8> is that your name?
13:31:35 <dfeuer> hmm
13:31:38 * dfeuer ponders.
13:31:57 <int-e> dfeuer: Maybe one of the Data.Graph.* modules implements such a thing.
13:32:12 <int-e> wait, fold?
13:32:21 * int-e ponders that.
13:32:22 <jgrimes_> ok, how could I speed up a list comprehension that uses 3 [1..] generators
13:32:30 <heatsink> Data.Graph.* use labeled graphs, so that node equality can always be determined.
13:33:35 <int-e> The term 'graph' is slightly ambiguous in this context.
13:33:51 <ptolomy_> defcon8: It is a handle I use on IRC and elsewhere.
13:34:03 <lightstep> jgrimes_, what do you want to achieve?
13:34:45 <jgrimes_> lightstep: [ (a, b, c) | a <- [1..], b <- [1..], c <- [1..], a^2 + b\
13:34:46 <jgrimes_> ^2 == c^2,a + b + c == 1000]
13:35:28 <int-e> well, c can be calculated from a and b. there are also nice generators for pythagorean triples.
13:35:33 <madpickle> will that work?
13:35:38 <dfeuer> int-e, probably not fold.
13:35:49 <int-e> and ... you need to specify upper bounds to make this work
13:35:54 <madpickle> you are using, essentially, infinity
13:35:55 <madpickle> yeah
13:36:11 <jgrimes_> right
13:36:13 <lightstep> you can also limit the ranges
13:36:20 <madpickle> pick a low number
13:36:40 <int-e> > [(a,b,c) | a <- [1..1000], b <- [1..1000-a], let c = 1000 - a - b, a^2 + b^2 == c^2]
13:36:43 <lambdabot>  [(200,375,425),(375,200,425)]
13:36:47 * shapr yodels
13:36:55 <shapr> stepcut: Hey, did you get the RSS fix?
13:37:44 <jgrimes_> int-e: looks good. I had upper bounds of 1000 on them, because... obviously they can't exceed 1000 for my little test
13:37:47 <int-e> jgrimes: anyway your best bet in such cases is to look at the underlying math.
13:38:02 <jgrimes_> but, I was wondering if using boundless would work
13:38:27 <int-e> jgrimes: you had a O(n^3) algorithm; this one is O(n^2) which is still much worse than possible, but good enough for n=1000.
13:38:34 <int-e> no. it doesn't.
13:38:39 <jgrimes_> ok
13:38:43 <jgrimes_> good to know
13:38:44 <jgrimes_> :)
13:38:56 <dfeuer> int-e, map at least should be able to preserve sharing, right?
13:40:55 <int-e> dfeuer: I believe so, yes.
13:41:17 <int-e> dfeuer: but it's potentially inefficient because you still need to detect cycles.
13:41:19 <dfeuer> I wonder if any implementations provide such a map (presumably by a different name)
13:41:35 <dfeuer> Well yes, it's inefficient, but sometimes that doesn't matter.
13:41:49 <int-e> and without modifying the original data that seems pretty hard.
13:42:15 <int-e> (well. not really. you'd create a separate auxillary map.)
13:42:20 <dfeuer> yah.
13:42:37 <int-e> or cheat in the implementation because it's single-threaded anyway.
13:42:56 <xerox> http://honeybrown.ca/Pubs/BumpTop.html
13:42:58 <xerox> That is cool!
13:44:32 <dfeuer> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
13:44:46 <stepcut> shapr: no :(
13:45:14 <stepcut> shapr: did you get my email about the URL monad transformer ?
13:46:24 <dfeuer> int-e, that seems to do some of it.
13:47:00 <dfeuer> What's the canonical way to implement objects with identity in Haskell?
13:47:42 <heatsink> dfeuer: Give them a field that holds a unique number, usable as an ID.
13:48:11 <dfeuer> And then implicitly pass around a number source?
13:48:57 <heatsink> dfeuer: yea
13:49:51 <dfeuer> heatsink, this sounds kind of yucky already.  Foo.  
13:50:40 <_coder_> Weee, functional languages are fun
13:51:15 <_coder_> I think the next language I develop for fun (C+bison+flex) will be functional.... 
13:51:19 * _coder_ is obsessed with languages
13:51:32 <_coder_> It is kind of interesting...
13:54:29 <xerox> class Hashable a where hash a -> Int -- :)
13:54:51 <heatsink> dfeuer: It is... making unique numbers in Haskell is annoying.
13:55:31 <dfeuer> heatsink, it seems the basic options are:  1. name everything (wasting space) or 2. hack the implementation (way beyond my abilities) to support dumping structures to disk (possibly missing opportunities for sharing).
13:57:02 <dfeuer> In the name everything category are: 1. pass around a name generator and 2. use makeStableName.  Since makeStableName is in the IO monad, I'm not really sure I see its purpose.
13:57:23 <heatsink> dfeuer: That's about right.  But I think you could make an eq function (a -> a -> Bool) without too much effort.
13:57:36 <dfeuer> (except maybe for incredibly nasty FFI hacks)
13:57:43 <dfeuer> heatsink, eh?
13:57:52 <stepcut> dfeuer: Data.Unique ?
13:58:01 <xerox> ?docs Data.Unique
13:58:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Unique.html
13:58:04 <stepcut> (but that is also in the IO monad)
13:58:15 <xerox> Nice one!
13:58:24 <dfeuer> What's nice?
13:58:36 <xerox> Finding that idea in the lib.
13:59:12 <shapr> I always remember numbers incorrectly, but maybe it's a set amount of drift? I wonder if I could apply a constant corrective factor to my number memory? I must test this!
13:59:24 <dfeuer> xerox, I don't think that's a very interesting idea.
13:59:43 <dfeuer> Useful, I guess, but not so interesting.
13:59:48 <xerox> Just nice to have.
13:59:52 <Azmo> is the 'Int' type faster than than 'Int32', 'Word32', 'Word16', etc.. or is there any other reason to use it? and why does it have such a strange size?
13:59:53 <stepcut> shapr: I didn't get RSS fix -- probably deleted accidently
14:00:48 <dfeuer> xerox, it can be implemented trivially on any system supporting mutable variables in IO, right?
14:01:09 <lightstep> Azmo, Int is standard and is guarenteed to be at least 29 bits. It's 32 or 64 bits in ghc. The other are non-standard extensions
14:01:10 <xerox> Agreed.
14:01:23 <heatsink> dfeuer: If you can figure out the syntax of -fvia-c code, then you should be able to hack a C file to do the pointer comparison and return the result.  It'll be a fifty-line file that you'll have to figure out.
14:01:29 <lightstep> Azmo, they should be equally fast
14:01:42 <Azmo> lightstep: ok, thanks.
14:02:27 <dfeuer> heatsink, uhhhhhh....
14:03:30 <heatsink> heh.
14:03:51 <heatsink> maybe not.
14:04:25 <dfeuer> Look, if I were daring enough to dig into -any- compiler, it -certainly- wouldn't be GHC.
14:04:44 <mux> not GCC either
14:04:48 <mux> I nearly went blind
14:05:20 <mux> or wear your peril-sensitive sunglasses at all times :-)
14:05:48 <dfeuer> Does GHC still have the Evil Mangler, or did that go away?
14:06:04 <heatsink> dfeuer: Well, the beauty of that is that you don't have to dig into the compiler, just the C files that it outputs.
14:06:35 <dfeuer> >shiver<
14:11:04 <dfeuer> Does GHC support a structural equality operator?  If so, does it use something like eq? to improve speed?
14:12:11 <shapr> GHC is a nice compiler actually.
14:12:17 <shapr> JHC is prettier but not as complete.
14:12:27 <shapr> stepcut: Yeah, I got it, but haven't thought about it yet.
14:12:51 <madpickle> how does hugs compare?
14:12:54 <madpickle> that's what i'm using.
14:16:30 <dfeuer> heatsink, would it be reasonable for a compiler to optimize == so that pointer equality implies equality?
14:16:49 <Philippa_> not on everything
14:16:56 <Philippa_> near-impossible to do for strings, for example
14:17:32 <dfeuer> ?
14:17:56 <dfeuer> I guess the tricky thing is that it's only an optimization sometimes.
14:18:12 <dfeuer> bah
14:18:27 <defcon8> i dont understand what polymorphic types are. can someone explain?
14:18:37 <lscd> dfeuer: that wouldn't work
14:18:45 <dfeuer> lscd, why?
14:19:01 <lscd> what about when you want to define equality in a way that only involves some of the fields in your data structure?
14:19:14 <dfeuer> lscd, then it's fine.
14:19:20 <dfeuer> identity -> equality
14:19:36 <dfeuer> equality -/> identity
14:19:37 <lscd> ah, but equality /-> identity
14:19:42 <dfeuer> right
14:19:48 <Philippa_> defcon8: in Haskell, they're types with type variables in them
14:20:01 <lscd> ehm.... doesn't identity already imply equality?
14:20:23 <dfeuer> It does if the Eq instance declaration isn't broken.
14:20:37 <lscd> ahh
14:21:54 <dfeuer> The other problem is that when applied to objects with little or no sharing, it'll make things slower.
14:22:31 <Dino_> Let me ask something, and in doing so perhaps help defcon8..
14:22:42 <dfeuer> There will be no helping defcon8 here.
14:22:52 <dfeuer> :-P
14:23:29 <Dino_> In Java, say, the String class is derived from Object. So anything that can operate on an Object (like a container) can take Strings. Is this basically the same in Haskell?
14:23:52 <dfeuer> no.
14:24:16 <dfeuer> well....
14:24:30 <dfeuer> It's true in the class system, but not in the type system.
14:24:31 <Dino_> Ok, so if I wrote a function that takes Num, I can send it Int, that's different?
14:24:44 <Dino_> mm, see I don't get this yet either.
14:24:46 <Philippa_> no
14:24:50 <Philippa_> no subtyping in Haskell
14:24:55 <Dino_> Perhaps muddied by ages of OO langs.
14:25:14 <dfeuer> I tend to think of classes as being much like interfaces and datatypes being implementations.
14:25:39 <dfeuer> There are subclasses, but no subtypes.
14:25:40 <Philippa_> Dino_: you don't write a function that takes Num. You write a function that takes an a, where a is in Num
14:25:51 <Dino_> :)
14:26:08 <Philippa_> this isn't a nitpick, a type can belong to multiple, unrelated classes
14:26:56 <xerox> Dino_ - In Haskell the function (+) does the sum of two numbers. If it had type a -> a -> a, `a' could have been whatever type. It instead has a constraint on the type (Num a) => a -> a -> a. The constraint limits the possible type `a' to be one of the member of the set of types `Num'. In Haskell we call a set of types `class' and putting a given element in that set `instance'.
14:27:02 <Dino_> As in two unrelated things that both implement the same interface. In the aforementioned language.
14:27:56 <SamB> ?
14:28:01 <dfeuer> defcon8, Haskell provides not only simple types, but also type constructors, which are functions from types to types.
14:28:03 <Philippa_> yup. What you can't do is have a list of "things that're in Num"
14:28:04 <Dino_> Oh, so this isn't just that each of the occurrances of 'a' has to be in Num, but that they all have to be the same.
14:28:09 <SamB> > (1 :: Int) + (2 :: Integer)
14:28:10 <lambdabot>  Couldn't match `Int' against `Integer'
14:28:11 <dfeuer> Dino_, you can have it both ways.  
14:28:14 <Philippa_> Dino_: right
14:28:24 <Philippa_> 'cos otherwise you don't know how to add them
14:28:37 <mauke> @type \x -> show (x + 1)
14:28:38 <lambdabot> forall a. (Num a) => a -> String
14:28:38 <SamB> @instances Num
14:28:39 <lambdabot> Double, Float, Int, Integer
14:28:40 <xerox> Dino_ - Yes. Can you imagine an useful implementation of the function whos type is a -> b ?
14:28:43 <Philippa_> if you wanted to extend it so they could be different types, you might use a "multi-parameter class"
14:28:51 <Philippa_> with the two input types and the output type as parameters
14:28:55 <Philippa_> but that's not Haskell 98
14:29:04 <Philippa_> xerox: define "useful" :-)
14:29:11 <lscd> xerox: sure - look at show
14:29:19 <Philippa_> lscd: show doesn't have that type
14:29:25 <xerox> lscd - No constraints allowed.
14:29:43 <lscd> Philippa_: well, it's a -> String
14:29:50 <Philippa_> lscd: no, it's not
14:29:54 <mauke> @type const undefined
14:29:55 <lambdabot> forall a b. b -> a
14:29:59 <SamB> @type show
14:30:01 <lscd> > :t show
14:30:01 <lscd> show :: (Show a) => a -> String
14:30:01 <lambdabot> forall a. (Show a) => a -> String
14:30:01 <lambdabot>  Parse error
14:30:10 <lscd> given that a is showable, it is
14:30:14 <Philippa_> although a -> String has an infinite number of inhabitants more than a -> b
14:30:23 <Philippa_> lscd: that "given" is part of the type
14:30:25 <Dino_> Not sure what you're asking. But it seems like even the cross-discussion about constructors is basically a -> b, where b is String
14:30:26 <dfeuer> xerox, the functions of type a -> b are _|_, \x->_|_, \x -> seq x _|_
14:30:28 <lscd> anyhow: map takes a function of (a->b)
14:30:30 <Philippa_> taking it out is cheating
14:30:52 <Philippa_> lscd: extended context. Write it out with foralls if you don't get my point
14:31:08 <xerox> lscd - The first argument of map, together with the second, construct the result type.
14:31:12 <mauke> @type show . succ
14:31:13 <lambdabot> forall a. (Show a, Enum a) => a -> String
14:31:20 <lscd> xerox: indeed. 
14:31:23 <mauke> can't do that in java
14:31:24 <Dino_> Do I ever have to re-read the YAHT chapters on Types and Advanced Types. :o
14:31:46 <Philippa_> Dino_: might help :-) Don't worry, it's not too horribly difficult
14:32:25 <Dino_> What is _|_ again?
14:32:31 <lscd> bottom
14:32:31 <Philippa_> "undefined"
14:32:38 <Philippa_> or the semantic 'bottom' value
14:33:02 <Philippa_> some contexts might also have a 'top', but there aren't any switches in this context
14:33:30 <dfeuer> The only difference between \x -> _|_ and \x -> seq x _|_ is that the latter could fail when evaluating x.
14:33:44 <Dino_> Does that interesting choice of symbology have some math behind it? I would have just expected a word like, oh I don't know, 'null'
14:33:56 <Dino_> 'undef' like Perl. :)
14:34:00 <dfeuer> Yeah.
14:34:04 <dfeuer> It does.
14:34:15 <Philippa_> Dino_: it does, yeah. 'bottom' is the bottom value in a complete partial order
14:34:36 <dfeuer> Philippa_, without subtypes, though, isn't that order trivial?
14:34:45 <Philippa_> if I've remembered my theory right, all computable functions are continuous functions in a CPO
14:34:53 <Philippa_> 'bottom' is the one with the least info - totally undefined
14:34:54 <SamB> WTH is a complete partial order -- make up your mind, is it a complete order or isnt't it?
14:35:18 <Philippa_> dfeuer: no, how far through the list do you get before you reach a bottom?
14:35:25 <Dino_> defcon8: I apologize if I pissed all over your question.
14:35:34 <Philippa_> the list that's only undefined after the 200th item contains more info than the one that's just outright undefined
14:36:09 <dfeuer> Philippa_, oh yeah.....
14:36:16 <dfeuer> I'm remembering this now.....
14:37:09 <dfeuer> So \x -> (1, _|_)  >  \x -> (_|_,_|_) > \x -> _|_ > _|_
14:37:23 <mauke> yay, 
14:38:30 <dfeuer> So what is top?  I guess there isn't one?
14:38:56 <mauke> U+22A4 (0xe2 0x8a 0xa4): DOWN TACK []
14:39:03 <dfeuer> ummm...
14:39:07 <dfeuer> I meant what _is_ it.
14:39:28 <SamB> some infinite data structure I suppose ;-)
14:39:30 * SamB kids
14:40:23 <dfeuer> Philippa_, what's the deal with top?
14:43:45 <Philippa_> dfeuer: other end of the chain
14:43:57 <dfeuer> And what might sit there, if anything?
14:44:33 <Philippa_> weeell, if you're following the pun then that'd be the person doing the dominating. There's an ordering on the booleans where true is top and false is bottom, for example
14:44:49 <Philippa_> most datatypes don't have a unique top
14:44:49 <dfeuer> uhhhh... what?
14:44:58 <dfeuer> <sigh>
14:45:23 <Philippa_> dfeuer: top and bottom are common bdsm terms, hence my comment about the lack of switches :-) If a datatype has one value that's clearly 'the most info', then that would be top
14:45:40 <dfeuer> I know they're BDSM terms.  I didn't know what "switches" referred to.
14:45:44 <dfeuer> Missed it.
14:45:47 <Philippa_> have a guess
14:45:55 <dfeuer> I have a couple.
14:45:57 <dfeuer> Whips?
14:46:00 <Philippa_> no
14:46:07 <Philippa_> far more obviously connected to the subject than that
14:46:12 <dfeuer> People who both dominate and submit?
14:46:25 <Philippa_> or more accurately, who both top and bottom (more general terms)
14:46:33 <dfeuer> yadda yadda.
14:46:49 <dfeuer> actually, I think those terms mean somewhat different things.
14:47:00 <defcon8> sorry guys for not replyinhg
14:47:05 <defcon8> i'm reading all the replies now
14:47:13 <dfeuer> Yeah.  Suuuure you are.
14:47:38 <defcon8> :@
14:47:56 * Philippa_ shrugs
14:48:03 <Philippa_> if you're going to use the language, use it right
14:48:18 <dfeuer> Whaaatever.
14:48:30 <Philippa_> english is, of course, capable of absorbing considerable punishment in the process :-)
14:48:48 <dfeuer> Someone could dominate while bottoming.
14:49:01 <Philippa_> anyway, did I give you a sufficient answer for cpo and domain theory purposes?
14:49:10 <dfeuer> mayyyyybe.
14:49:19 <Philippa_> "maybe"? I've done it
14:49:20 <dfeuer> I don't know much at all about these things.
14:49:53 <Philippa_> and you were possibly thinking of the related-but-separate meanings in the gay community that the bdsm usage derived from? :-)
14:50:00 <dfeuer> Yep.
14:50:37 <Philippa_> you can draw similar analogies for most sensation-based play, with no need for actual domination
14:50:59 <dfeuer> ?-
14:50:59 <lambdabot> Maybe you meant: . v
14:51:01 <Philippa_> but this convo belongs in #haskell-blah
14:51:06 <dfeuer> ????????????????????????????????????????????
14:51:07 <lambdabot> Unknown command, try @list
14:51:11 <dfeuer> ?list
14:51:12 <lambdabot> list [module|command]. Where modules is one of:
14:51:12 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
14:51:12 <lambdabot> topic type unlambda url version vixen where
14:51:21 <dfeuer> ?run foo
14:51:21 <lambdabot>  Not in scope: `foo'
14:51:37 <bolrod> ? let foo = foo in foo
14:51:46 <bolrod> > let foo = foo in foo
14:51:46 <lambdabot>  Add a type signature
14:51:51 <bolrod> > let foo = foo in foo :: v
14:51:52 <lambdabot>  Add a type signature
14:52:05 <dfeuer> > let foo = foo in foo::Int
14:52:06 <lambdabot>  Exception: <<loop>>
14:52:19 <mauke> > let foo = foo in show foo
14:52:20 <lambdabot>  Add a type signature
14:52:42 <Philippa_> the monomorphism restriction is not your friend :-)
14:53:11 * dfeuer doesn't understand the monomorphism restriction.
14:53:19 * dfeuer also doesn't see how it comes up here.
14:53:20 <mauke> > let foo = show foo in foo
14:53:21 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:53:34 <dfeuer> wtf?
14:53:39 <Philippa_> dfeuer: the type of foo is at this point still polymorphic
14:53:47 <dfeuer> yes.....
14:53:58 <Philippa_> and it's not allowed to be, hence the requirement for a signiature
14:54:20 <duality> The restriction is to enable a certain optimization.
14:54:32 <dfeuer> I thought the restriction was something a bit different.
14:54:49 <dfeuer> Preventing certain types from being generalized?
14:54:50 <Philippa_> duality: there're several reasons for it. That's not one, because the compiler can do the analysis anyway
14:54:57 <Philippa_> dfeuer: same difference
14:55:01 <duality> True
14:55:14 <Philippa_> just means it's not allowed to put the (implicit) forall on the type variable in foo's type
14:55:19 <dfeuer> Philippa_, that's the explanation given in the Haskell 98 report (efficiency)
14:55:22 <Philippa_> thus leaving it with an invalid type
14:55:28 <Philippa_> that's one explanation given in the report
14:55:35 <Philippa_> note that "enabling an optimisation" isn't the same thing
14:55:53 <dfeuer> I think it's the only one in the report, but others turned up later.
14:55:55 <Philippa_> the actual problem is that you occasionally get unintended blowups in time
14:56:08 <dfeuer> ...?
14:56:43 <Philippa_> there's also an ambiguity issue that it prevents
14:56:56 <dfeuer> Explain both?
14:56:58 <dfeuer> maybe?
14:57:18 <Philippa_> for the first one, I don't know the details but there's something fairly horrific that can occasionally happen with a dictionary-passing implementation of type classes
14:59:19 <Philippa_> the ambiguity's a matter of an overloaded type variable disappearing before it's unified with something useful, with the result that it's ambiguous which actual type should be used
14:59:36 <dfeuer> All sorts of fairly horrific things can happen to Haskell performance in any case...
14:59:45 <dfeuer> Philippa_, show?
14:59:47 <Philippa_> not the same way
14:59:50 <Philippa_> show would be an example, yeah
15:00:01 <dfeuer> I don't really understand even what the monomorphism restriction /is/ exactly.
15:00:33 <dfeuer> Ummm...
15:00:38 <dfeuer> I meant, show an example.
15:00:51 * dfeuer offers Cale some Kale.
15:00:53 <dfeuer> kale.
15:01:03 <Philippa_> it's stated in the report. I'm not sure I can give a better explanation
15:01:08 <dfeuer> foo
15:01:10 <Philippa_> I'm inclined to just say it's a PITA myself
15:01:27 <Philippa_> I'd rather see it dropped in haskell' and a generalised defaulting mechanism introduced to handle the ambiguity
15:01:40 <dfeuer> IIRC, GHC existential types depend on it in some fundamental way.
15:01:55 <Philippa_> dfeuer: if you removed the defaulting mechanism for a moment, show 42 would be an example
15:02:14 <dfeuer> No way to know its type
15:02:17 <Philippa_> (because it wouldn't know which instance of Num 42 should belong to)
15:02:18 <Philippa_> right
15:02:43 <Philippa_> we know the overall expression's type, but we don't know which actual code to run to evaluate it
15:02:47 <dfeuer> I'll have to re-read the monomorphism restriction after I do some work.
15:02:59 <ndm> @seen dmhouse
15:02:59 <lambdabot> I saw dmhouse leaving #oasis and #haskell 4 hours, 9 minutes and 25 seconds ago, and .
15:03:12 <dfeuer> I don't really like the defaulting mechanism.
15:03:23 <Philippa_> ICBW, but I think the only way existential constructors use it's the same issue again - which dictionary to apply
15:03:38 * dfeuer shrugs
15:03:43 <Philippa_> I don't like it as-is, I'd rather have it than having to annotate half my numeric literals
15:03:52 <dfeuer> With existential types, there's no way to use defaulting, right?
15:04:11 <Philippa_> not once you've built the value of existential type, no
15:04:25 <ndm> why not just remove "wrong" arithmetic, or Int as its also refered to, in place of "correct" arithmetic on Integer ?
15:04:28 <Philippa_> you still get defaulting when you pass 42 to a constructor that takes Num a => a
15:04:44 <Philippa_> ndm: it's not "wrong" for all systems
15:05:01 <dfeuer> Philippa_, the annotations necessary for Haskell numeric literals are far heavier than those necessary in other languages.
15:05:18 <ndm> Philippa_: not wrong then, but doesn't obey maths, unless you can prove a static range, which in haskell you can't
15:05:28 <dfeuer> Also, I wasn't talking about class constraints in existential types.
15:06:04 <dfeuer> but I don't really know what I am talking about,
15:06:06 <Philippa_> dfeuer: you might not have been, but you didn't provide significant reason to believe you weren't. Give me an example that falls apart without the monomorphism restriction and doesn't involve a class?
15:06:08 <dfeuer> so I'd better stop talking.
15:06:17 <Saulzar> ndm, In the interests of practicality it makes no sense to drop Int - what about float and double, get rid of those too?
15:06:27 <SamB> > return 1
15:06:28 <lambdabot>  add an instance declaration for (Show (m a))
15:06:41 <Philippa_> I can't think of many uses for existential constructors that don't involve a class constraint, I like being able to do more with my values than apply id :-)
15:06:48 <dfeuer> uhh....
15:07:04 <Philippa_> wait, I take that back. Functions as parms. Duh.
15:07:07 <dfeuer> yeah.
15:07:09 <SamB> Philippa_: the only one that comes to mind involves unsafeCoerce# ;-)
15:07:10 <ndm> Saulzar: no, just get rid of float
15:07:26 <Philippa_> ndm: float makes sense for some apps. Notably audio
15:07:40 <dfeuer> Getting rid of useful calculation capabilities is not the way to go.
15:07:41 <ndm> i meant get rid of float, but not double
15:07:48 <adu> > let e = (exp 1) in (e ** e)
15:07:50 <lambdabot>  15.154262241479259
15:07:53 <adu> :)
15:07:55 <ndm> i appreciate floating point is useful, i just don't see a need to have two abstractions for it
15:08:08 <dfeuer> abstractions?
15:08:09 <Philippa_> yes. Using doubles for audio is overkill and leads to slower code and more memory used
15:08:26 <adu> > let e = (exp 1) in (e ** e ** e)
15:08:27 <lambdabot>  3814279.1047601975
15:08:31 <Philippa_> dfeuer: yeah, I think the I-however-many-Es might be... amused to hear that
15:08:35 <ndm> Philippa_: maybe there should be one "floating point" type, and the compiler should pick the right precision, possibly with a pragma
15:08:38 <adu> > let e = (exp 1) in (e ** (e ** e))
15:08:39 <lambdabot>  3814279.1047601975
15:08:56 <dfeuer> I-however-many-Es????
15:09:01 <Philippa_> ndm: no, there shouldn't. There're really strong historical reasons for this
15:09:02 <dfeuer> oh.
15:09:03 <dfeuer> IEEE
15:09:10 <Philippa_> dfeuer: there's also an IEE :-)
15:09:16 <dfeuer> ugh
15:09:52 <dfeuer> Philippa_, the reasons are not only historical.
15:10:08 <Philippa_> ndm: if you want to do that, build a Real or a FloatReal type. In practice, if you're using floating point arithmetic you're likely to have reason to care about this
15:10:15 <dfeuer> It's very important in some applications to keep track of precision.
15:10:20 <Philippa_> dfeuer: true, although the current reasons have strong historical pressure
15:10:21 * Philippa_ nods
15:10:22 <ndm> to be honest, i never use floating point
15:10:29 <dfeuer> ?
15:10:47 <ndm> was just thinking that perhaps defaulting is unnecessary
15:10:53 <Philippa_> dfeuer: if you really want serious track of precision, you probably need more than just Float and Double types
15:10:55 <ndm> since its a bit ugly
15:11:14 <Philippa_> I'd rather see defaulting generalised
15:11:21 <dfeuer> Philippa_, what else would you need?
15:11:32 <Saulzar> Well there are a lot more than 2 types for most literals, if you include all the word types and whatnot
15:11:46 <Philippa_> dfeuer: arbitrary-as-in-keeps-track precision float?
15:11:55 <Philippa_> (!= arbitrary-as-in-built-on-integer)
15:12:06 <Philippa_> Saulzar: quite
15:12:11 <ndm> Philippa_: maybe floating point should be generalised as well, since most compilers now have bigger than double floating point as well
15:12:38 <dfeuer> Philippa_, that's great when available, but for a lot of purposes just being able to put a bound on the error is really important.
15:12:57 <Philippa_> dfeuer: agreed. You can do that with one well-specified type though
15:13:03 <Philippa_> ndm: generalised in what way?
15:13:10 <dfeuer> OTOH, Haskell Float and Double aren't fully specified anyway.
15:13:23 <dfeuer> Philippa_, yeah, but then there are the performance issues.
15:13:36 <ndm> Philippa_: add a treble maybe :)
15:13:39 <Philippa_> dfeuer: yep
15:13:56 <Philippa_> ndm: not quite the right thing. I suspect what most compilers support is an 80-bit "extended" float
15:14:11 <Philippa_> where extended is a standards-specified term for it
15:14:14 <ndm> would be nice to have Ada's numeric types, which say the precision and digits etc - but quite a way of haskell
15:14:29 <dfeuer> Philippa_, if you extend defaulting, make all the notation flexible.
15:14:30 <ndm> Philippa_: yes, i meant 80 bit for treble
15:14:44 <Philippa_> 80 bit wouldn't /be/ treble though. 32*3 = 96 :-)
15:14:58 <dfeuer> (bring back monad comprehensions, make [],: work for general Sequence types, etc.)
15:15:10 <dfeuer> err....
15:15:11 <dfeuer> grrr
15:15:18 <dfeuer> [] and : are troublesome.
15:15:33 <Philippa_> you can't quite make [] and : work for general sequence types atm
15:15:42 <dfeuer> You'd need views.
15:15:44 <Philippa_> pattern-matching'll bite you
15:15:50 <dfeuer> Which some people don't like, but I do.
15:15:56 <Philippa_> urgh. Views bad. Transformational patterns are your friend.
15:16:23 <dfeuer> Transformational patterns are great, but views are much nicer for some things.
15:16:32 <Philippa_> (oh look, did we just define Sequence as "has an s a -> [a] func"?)
15:16:44 <Philippa_> example?
15:16:58 <Philippa_> I'm somewhat skeptical about that
15:17:00 <dfeuer> Code's been written to use a certain type.
15:17:08 <dfeuer> You realize you want to change the type.
15:17:13 <dfeuer> Oh fuck, you're screwed.
15:17:40 <Philippa_> it's a straightforward refactoring either way, no?
15:17:40 <Philippa_> bah
15:17:42 <dfeuer> crap
15:17:50 <Philippa_> heh
15:17:54 <SamB> dfeuer: sure you can change the type
15:17:57 <Philippa_> it's a straightforward refactoring either way, no?
15:18:10 <dfeuer> Suppose you want to replace String with an implementation that supports fast concatenation, splitting, and deque operations.
15:18:28 <Philippa_> yup, carry on...
15:18:42 <dfeuer> With views, you can leave all the code that treats String as [Char] alone.
15:18:57 <Philippa_> I'm not sure I see this
15:18:57 <dfeuer> With transformational patterns,
15:19:04 <Philippa_> not with the descriptions of views I've read, at least
15:19:09 <dfeuer> you have to rewrite them all 
15:19:21 <Cale> ... and you'll end up with a program that runs even slower than the original
15:19:21 <Philippa_> for values of "rewrite" that amount to applying a well-specified refactoring, yes
15:19:45 * dfeuer ponders.
15:19:52 <dfeuer> Guess there are still problems.
15:19:54 <Philippa_> Cale: I'm not so sure about that, it depends how well your [Char] stuff gets optimised - you can use [Char] as the equivalent of an OO iterator
15:19:56 <dfeuer> dagnabbit.
15:20:02 <dfeuer> Ah.......
15:20:10 <Philippa_> but I strongly prefer the version where you convert to [Char] at the start
15:20:16 <dfeuer> Now I am beginning to see......
15:20:21 <Cale> Philippa_: yeah, I'm saying if you replace [Char] with some other type without actually rewriting the code
15:20:35 <Philippa_> I think you can make it work OK for read-only work
15:20:39 <Cale> Cons-matching on other types will be even slower
15:20:56 <Philippa_> at least, given a sufficiently smart compiler - JHC I suspect would be such
15:20:57 <dfeuer> It's still mad tricky.
15:21:07 <SamB> Cale: what about packed strings?
15:21:10 <SamB> is that slower?
15:21:27 <dfeuer> Because you need :,[] to act as both views (in patterns) and overloaded constructors.
15:21:41 <Philippa_> dfeuer: the overloaded constructor part will kick your arse, yes
15:21:51 <Cale> SamB: well, what does matching (x:xs) do there? We need to construct a new packed string for xs
15:21:56 <dfeuer> Philippa_, you don't seem to mind overloaded constructors!
15:22:02 <SamB> especially considering the fact that [] and : don't follow the scoping rules
15:22:16 <Cale> This will surely take longer than just following a pointer
15:22:16 <dfeuer> Don't follow the scoping rules???
15:22:21 <Cale> what?
15:22:30 <Philippa_> dfeuer: yeah, but usually I have a context in mind where you can resolve the overloading and thus specialise
15:22:40 <dfeuer> Cale, you wouldn't replace String with packed strings.  Those are waaaay too different.
15:22:48 <Philippa_> heh
15:22:55 <Cale> dfeuer: what type then?
15:22:58 <dfeuer> Philippa_, huh?
15:23:01 <SamB> Cale: you can't not import those from Prelude
15:23:13 <Cale> SamB: ah, right
15:23:17 <dfeuer> Cale, any type supporting efficient stack operations, actually.
15:23:39 <dfeuer> In real life, it'd most likely be a catenable, splittable, random-access list.
15:23:54 <dfeuer> (with fast deque operations)
15:24:13 <SamB> that isn't typically going to have a very fast un-consing
15:24:31 <dfeuer> O(1), but definitely not super-fast.
15:24:56 <Philippa_> dfeuer: overloaded generic-functions-as-constructors I don't mind, overloaded constructors-to-match-on get real icky in most current implementations
15:26:22 <dfeuer> Philippa_, how can you overload as constructors but not in patterns/
15:26:23 <dfeuer> ?
15:26:47 <dfeuer> f x 3 = x means what?
15:27:04 <bolrod> means the 2nd parameter gets discarded
15:27:06 <bolrod> ?
15:27:08 <Philippa_> dfeuer: ever built a module where you hid the datatype but exposed functions used to construct values of that type?
15:27:18 <dfeuer> > let f 3 = 2 in f 3
15:27:19 <lambdabot>  2
15:27:26 <Philippa_> functions that could be reasonably described as constructors, if not as Data Constructors?
15:27:26 <dfeuer> Philippa_, sure.
15:27:31 <dfeuer> sure.
15:27:34 <bolrod> > let f x _ = x  in f 4 undefined
15:27:35 <lambdabot>  4
15:27:38 <Philippa_> that would be how
15:27:51 <Philippa_> hell, one of the array typeclasses has a func like that in it
15:27:55 <Cale> Without some insane system of heuristics, you really need to write the generic sequence code at a higher level of abstraction than conses, or you'll end up with general code that only works well on lists
15:28:00 <dfeuer> >let f a@3 = 2 in f 3
15:28:05 <dfeuer> > let f a@3 = 2 in f 3
15:28:06 <lambdabot>  2
15:28:26 <bolrod> > let f (n+1) = n in f 4
15:28:26 <lambdabot>  Parse error in pattern
15:28:40 <bolrod> hrm?...
15:28:41 <dfeuer> Cale, you wouldn't write generic sequence code on lists.  
15:28:45 <Cale> (Or at best, gives you the same performance on fancier types as you get with regular lists)
15:28:47 <mauke> > let f 3@a = 3 in f 2
15:28:48 <lambdabot>  Parse error
15:28:57 <dfeuer> You'd use this to reuse rather less fancy code.
15:29:06 <dfeuer> > let f a@3 = 2 in f 3      means what?
15:29:06 <lambdabot>  Parse error
15:29:12 <bolrod> can't I match with n+1 ?
15:29:17 <dfeuer> > let f a@3 = 2 in f 3    --  means what?
15:29:18 <lambdabot>  2
15:29:35 <bolrod> my ghci does that fine :/
15:29:49 <dfeuer> > let f a@3 = undefined in f undefined    --  means what?
15:29:50 <lambdabot>  Add a type signature
15:29:55 <dfeuer> ah
15:29:59 <dfeuer> no.
15:30:14 <dfeuer> > let f a@3 = "zip" in f undefined
15:30:15 <lambdabot>  Undefined
15:30:32 <dfeuer> How'd it type that?
15:30:58 <bolrod> > let f (n+1) = n in f 5
15:30:58 <lambdabot>  Parse error in pattern
15:31:03 <bolrod> >:(  
15:31:17 <bolrod> @version
15:31:18 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
15:31:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:31:25 <dfeuer> > let f a@3 = a in f undefined
15:31:26 <lambdabot>  Undefined
15:31:29 <bolrod> is that pattern not allowed in 6.5 anymore?
15:31:42 <dfeuer> Philippa_, what type does a have?
15:32:06 <Cale> hm?
15:32:44 <dfeuer> @type let f a@3 = a in f undefined
15:32:45 <lambdabot> forall a. (Num a) => a
15:32:48 <Cale> bolrod: n+k patterns are evil
15:33:00 <bolrod> they are? :)  
15:33:07 <bolrod> well.. they are confusing..
15:33:09 <SamB> yes!
15:33:12 <bolrod> but evil?
15:33:31 <Cale> Yes. They eat babies.
15:33:37 <dfeuer> Philippa_, is it good or bad that it inferred Num a from the pattern 3?
15:33:39 <bolrod> oh my...  that is evil
15:33:43 <SamB> they do! they do!
15:34:11 <SamB> dfeuer: it is convenient
15:34:17 <bolrod> just say to yourself..  ghc knows best... and it'll be fine
15:34:20 <dfeuer> Philippa_, ping!
15:34:57 <dfeuer> SamB, yes, but why shouldn't complex constructors get the same benefit?
15:36:17 <SamB> dfeuer: constructors such as?
15:36:23 <palomer> shazam!
15:37:02 <bolrod> ?
15:37:03 <SamB> @type let f a@(x:xs) = a in f undefined
15:37:04 <lambdabot> forall a. [a]
15:37:07 <dfeuer> numeric literals are constructors that lie in a class, rather than a type.
15:37:15 <dfeuer> Why not allow lots of things like that?
15:37:24 <SamB> are they constructors?
15:37:28 * SamB doesn't know what they are
15:37:39 <bolrod> @type let f a@(3:xs) = a in f undefined
15:37:40 <lambdabot> forall a. (Num a) => [a]
15:37:49 <SamB> anyway, other things like that *would* be nice
15:38:27 <SamB> but at the moment we aren't even aloud to assign to constructor names, never mind doing it in an instance...
15:38:35 <dfeuer> ?
15:38:43 <heatsink> I think there was some proposal to generalize that; forgot what it was called.
15:38:45 <SamB> er, allowed
15:38:49 <dfeuer> assign?
15:38:51 * heatsink looks at the haskell prime page
15:38:58 <SamB> I mean "bind"
15:39:16 <SamB> you can't say "Foo = Just", for instance
15:39:38 <bolrod> > let Foo = Just in Foo 2
15:39:39 <lambdabot>  Not in scope: data constructor `Foo'
15:39:42 <dfeuer> Nod nod.  
15:39:50 <SamB> I think you'd want to incorporate something like that in a framework for views
15:39:58 <dfeuer> yes.
15:40:11 <dfeuer> Yes yes.
15:40:45 <dfeuer> There's a useful syntactic notion of a constructor and pattern.
15:41:03 <dfeuer> There's also a useful notion of an algebraic type with a constructor and a pattern.
15:41:04 <SamB> so, views should ideally be used for numeric literals, but aren't yet because we haven't got views yet
15:41:07 <heatsink> views, yea that was it.
15:41:18 <dfeuer> In Haskell and ML and such, these notions are stuck together.
15:41:26 <dfeuer> Even in systems with views.
15:41:38 <dfeuer> Maybe they should be unglued somehow?
15:41:52 * dfeuer runs
15:42:10 <SamB> but, even if we did have views, they probably wouldn't be used for numeric literals for a while
15:42:17 <SamB> at least a little while
15:42:37 <SamB> and the syntax would still be different
15:42:50 <Philippa_> dfeuer: congratulations, you just invented the not-always-initial algebra
15:43:23 <bolrod> does anybody get the latest post on the haskell-cafe?..
15:43:27 <Philippa_> pattern-matching works with algebraic datatypes for a reason. To sum it up, "no junk, no confusion"
15:45:47 <SamB> Philippa_: so how do *you* explain the fact that numeric literals are allowed in patterns?
15:46:20 <Philippa_> hackage
15:47:01 <SamB> don't change the subject!
15:47:04 <int-e> > [(f*a,f*b,f*c) | p<-[1..31], q<-[1..p-1], gcd p q == 1, let c=p^2+q^2; a=p^2-q^2; b=2*p*q; (f,r) = 1000 `divMod` (a+b+c), r==0]
15:47:05 <lambdabot>  [(375,200,425)]
15:47:06 <Philippa_> these days there's a not-so-crazy translation that uses pattern-guards
15:47:17 * SamB teases Philippa_ about the coincidental spelling of that package system
15:47:45 <Philippa_> (which obviously desugars into something more annoying, but hey)
15:48:18 <int-e> jgrimes: that's a more efficient version of your pythagorean triple problem
15:49:31 <jgrimes> int-e, oh, cool.
15:50:29 <int-e> > [(f*a,f*b,f*c) | p<-[1..31], q<-[1..p-1], odd (p+q), gcd p q == 1, let c=p^2+q^2; a=p^2-q^2; b=2*p*q; (f,r) = 1000 `divMod` (a+b+c), r==0]
15:50:30 <lambdabot>  [(375,200,425)]
15:56:48 <ihope> I guess it's tricky to create a Num class that isn't pretty arbitrary.
16:02:00 <int-e> arguably n-patterns should be restricted to the Integral class.
16:02:34 <ihope> n-patterns?
16:02:53 <int-e> hmm. k-patterns I guess.
16:03:03 <int-e> the constant integer patterns.
16:04:24 <ihope> Why?
16:06:08 <int-e> > let f 0 x = x; f _ x = let x' = (x+2/x)/2 in f (x-x') x' in f 1 1
16:06:10 <lambdabot>  1.414213562373095
16:06:25 <int-e> that's why
16:15:10 --- mode: irc.freenode.net set +o shapr
16:15:28 <ihope> > let f x = (x+2/x)/2 in (f.f.f.f.f.f.f.f.f.f.f.f.f.f) 1
16:16:00 <ihope> Um...
16:16:24 <shapr> The Numeric Haskell project has an improved Num class.
16:16:24 <ihope> > let f x = (x+2/x)/2 in (f.f.f.f.f.f.f.f.f.f.f.f.f.f) 1
16:16:38 * ihope pokes lambdabot
16:16:45 <madpickle> recent netsplit
16:16:48 <madpickle> it may not have caught up yet?
16:16:51 <lambdabot>  1.414213562373095
16:16:53 <lambdabot>  1.414213562373095
16:16:54 <madpickle> there =)
16:19:27 <ihope> > sqrt 2
16:19:28 <lambdabot>  1.4142135623730951
16:19:58 <ihope> I see.
16:38:45 <exa> hi there :)
16:39:09 <exa> can you tell me a pure functional language that has a really fast interpreter?
16:39:43 <heatsink> exa: What kind of task do you want to apply it to?
16:39:56 <exa> like solution of small math problems.
16:40:10 <madpickle> i think any of them would do
16:40:18 <zarvok> haskell interpreters should be fast enough for "small math problems"...
16:40:21 <madpickle> watch out for stack overflows
16:40:27 <madpickle> by that i don't mean in the interpreter
16:40:34 <exa> really simple stuff, and i'd like it to be as concise as possible, and fast, interpreted, and i want an eval function with a time limit.
16:41:02 <exa> i suppose haskell is a bit beyond what i want, but would be a good "host" language.
16:41:18 <zarvok> haskell is great for writing math
16:41:25 <exa> since it has some advanced features, the semantics of haskell is a little complicated, but i wonder maybe some ml dialect would do for me?
16:41:35 <exa> yes, i agree, it can also be slow :)
16:41:36 <zarvok> I don't think you're going to find a better "purely functional" language
16:41:49 <zarvok> well, no ml dialect is purely functional
16:41:53 <exa> i don't know man, have something like 'pure lisp' on my mind.
16:41:59 <exa> or a subset of ml, etc.
16:42:02 <zarvok> if you're willing to settle for kindof-sortof-notreally functional, they are much faster
16:42:33 <zarvok> It's certainly possible to write code that only uses the functional parts of ML
16:43:10 <exa> hmm, yes, but i wouldn't like the semantic loopholes that usually come with really-imperative features hmmm
16:43:41 <zarvok> I'm not sure what you mean, are you speaking about the value restriction?  Or maybe the lack of referential transparency?
16:44:19 <madpickle> quick question: given an arbitrary number n, how can i extract the i'th digit from it as a number (not a Char, string, whatever)
16:44:25 <zarvok> I mean, you're unlikely to encounter the value restriction and it's easy to program around, and ML code is referentially transparent so long as you don't write with any effects of infinite loops
16:44:25 <madpickle> i can do the old `div` and `mod` thing
16:44:29 <madpickle> but that's kinda hackish 
16:45:44 <zarvok> *or infinite loops
16:47:10 <dons> moin
16:47:42 <JKnecht> gday dons
16:48:27 <exa> zarvok: lack of referential transparency is disturbing.
16:48:37 <zarvok> oh, I agree
16:48:48 <madpickle> no suggestions?
16:48:52 <madpickle> :(
16:48:55 <madpickle> <- sadpickle
16:48:59 <zarvok> heh
16:49:29 <exa> so, just to enlighten me on one aspect. if i want to be able to cache the results of subprograms, should i use a strict evaluation or lazy evaluation? is the latter right?
16:49:47 <zarvok> exa: If you're coding in the functional fragment, though, the only way referential transparity can be violated is infinite loops
16:49:49 <lispy> madpickle: you could convert it to a string, select the string element you want and then turn it back into a number, but i'd say that's more hackish :)
16:49:56 <exa> i haven't done much functional programming in the last 6 months so i forgot a bit :)
16:50:05 <madpickle> lispy: yeah -that's what i'd like to avoid. hrm.
16:50:12 <exa> zarvok: yes that bit me quite a bit
16:50:22 <exa> zarvok: i wonder how often that happens. often enough to care about?
16:50:22 <madpickle> i suppose the div/mod thing will have to suffice
16:50:34 <zarvok> exa: depends on what you're doing
16:50:40 <exa> because in the codes that I wrote, it used to be a problem.
16:51:04 <madpickle> i suppose if i could convert it to a list i could do it that way
16:51:06 <zarvok> I TA'd a class in ML, and, to be honest, there were a fair number of infinite loops
16:51:10 <madpickle> i find that less hackish
16:51:11 <exa> i mean, is it really better in general to use this infinite graph etc. techniques in programming functional algorithms? i can't make up my mind on that.
16:51:30 <exa> i can do it, but i'm not sure i want to do it so often :)
16:51:43 <zarvok> heh
16:52:02 <exa> you feel like solving an instance of the halting problem on every symbol you type.
16:52:13 <zarvok> I find myself trying to emulate infinite data structures a lot when I program in SML though
16:52:21 <exa> and kinda makes it harder to put a cap on the performance.
16:52:38 <exa> maybe it's the natural and mathematical way, but what about all the memory overflows that you can get?
16:52:44 <exa> if you're careless.
16:52:46 <zarvok> sure, I mean, if you're super concerned with performance, then you're goign to have to go with a strict language or put strictness flags everywhere
16:52:58 <exa> hmm
16:53:02 <zarvok> But if you're just toying around with small math problems
16:53:13 <exa> well the problem is, there is finite memory  :)
16:53:18 <zarvok> heh
16:53:20 <exa> yes, toying around, definitely.
16:54:12 <exa> but i guess the point is, for haskell experts, there is always a concise and fast implementation :D
16:54:28 <exa> though i am sure i'm not one of them. i got bitten by haskell twice in terms of performance.
16:54:30 <zarvok> I guess it just depends on what you're doing.  I find it substantively easier to think about my math in terms of infinite data structures and list comprehensions.  If I need to really crunch numbers though, I'm going to write it in C or some ml variant
16:55:07 <exa> yea, lazy list eval. stuf in haskell, is, just like set theory!
16:55:15 <SamB> not quite
16:55:26 <lispy> mmm...set theory
16:55:33 <exa> omg
16:55:41 <exa> i didn't want to wake up the mathematicians hehehe
16:55:47 <zarvok> heh
16:55:59 <lispy> then don't chat here :)
16:56:14 <lispy> lots of math friendly denizens
16:56:30 <exa> well, an unordered sequence is a good representation for any computable set, so there you go mathmen :)
16:56:46 <exa> and i really couldn't care less about uncomputable sets in my code heheheh
16:57:05 * SamB not a mathematician
16:57:09 <exa> i just mean R isn't my concern
16:57:13 * SamB still can't do arithmatic, though
16:57:25 <exa> just give me PA and I'll do fine ;)
16:57:38 <exa> or better still just give me a universal computer.
16:58:29 <exa> there is one thing that interests me about haskell
16:58:30 <zarvok> I just finished a course in type theory from Peter Andrews, who was Church's student
16:58:37 <zarvok> It's so much prettier than set theory
16:58:37 <exa> wow
16:58:46 <exa> Church rocks :)
16:59:32 <zarvok> yes, I'm lucky, at CMU we have andrews and Dana Scott - both church students
17:00:01 <exa> cool
17:00:22 <exa> in haskell, how easy would it be to recycle thunks?
17:00:39 <exa> not sure if the correct term. how do i cache subprograms?
17:00:46 <Cale> exa: Using let
17:01:18 <zarvok> yeah, just name it, then it will be exected at most once no matter how many times you refer to the name
17:01:18 <Cale> Just pattern bind something monomorphically typed, and it will be computed only once
17:01:38 <exa> hmm, ok.
17:02:00 <SamB> exa: do you mean you want to memoize?
17:02:07 <exa> yes SamB
17:02:09 <duality> monomorphism is your friend  (duck)
17:02:19 <SamB> typically for dynamic programming you use a datastructure to hold all the sobproblem results
17:02:24 <exa> i had written some memoizing algorithm in haskell, but i forgot how i did it :)
17:02:27 <SamB> er, *subproblem
17:02:31 <exa> yes i know
17:02:44 <exa> i mean that's how you do it in imperative languages
17:02:49 <zarvok> exa: haskell is call by need, not call by name, so any variable will be evaluted at most once
17:02:50 <Cale> One nice way to compute the Fibonacci sequence is  fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:04:16 <duality> If you want the recurrence r(0) = 0, r(n) = r(n-1) + 1, here is how.  r = array (0, 10) [(n, r!!(n-1) + 1) | i <- [1..10] ]
17:04:30 <SamB> well, in haskell you might put all the values in the datastructure at the same time ;-)
17:04:31 <duality> err there is a mistake.
17:04:43 <duality> If you want the recurrence r(0) = 0, r(n) = r(n-1) + 1, here is how.  r = array (0, 10) ( (0,0) : [(n, r!!(n-1) + 1) | i <- [1..10] ] )
17:05:08 <duality> So that's how you do dynamic programming.
17:05:09 <zarvok> > array (0, 10) ( (0,0) : [(n, r!!(n-1) + 1) | i <- [1..10] ] )
17:05:10 <lambdabot>  Not in scope: `n'
17:05:23 <duality> err sorry, please change i to n
17:05:28 <SamB> only you use more than one line for the array
17:05:39 <exa> yea it's prettier sure, i remember that pattern of using lazy list comprehensions
17:05:43 <duality> > array (0, 10) ( (0,0) : [(n, r!!(n-1) + 1) | n <- [1..10] ] )
17:05:44 <lambdabot>  Not in scope: `r'
17:05:58 <duality> > let r = array (0, 10) ( (0,0) : [(n, r!!(n-1) + 1) | n <- [1..10] ] ) in r!!10
17:05:58 <lambdabot>  Couldn't match `[a]' against `Array i e'
17:06:15 <SamB> > let r = array (0, 10) ( (0,0) : [(n, r!!(n-1) + 1) | n <- [1..10] ] ) in r!10
17:06:16 <lambdabot>  Couldn't match `[a]' against `Array i e'
17:06:17 <zarvok> :)
17:06:21 <duality> listArray ?
17:06:24 <SamB> > let r = array (0, 10) ( (0,0) : [(n, r!(n-1) + 1) | n <- [1..10] ] ) in r!10
17:06:25 <lambdabot>  10
17:06:33 <SamB> wrong index operator
17:06:38 <duality> Oh!  !  not !!
17:06:42 <exa> interesting way to calculate 10 hehe
17:06:43 <SamB> ! is for arrays, !! is for lists ;-)
17:07:17 <duality> It is not just prettier, it is also just as efficient.
17:07:27 <exa> sure
17:07:48 <exa> and would be hard to write that in ocaml IIRC
17:09:07 <exa> good night thanks for the talk
17:10:42 <iron32> I am guessing this is not the room for Haskell noobs
17:11:06 <zarvok> heh, people here usually answer my noobish questions
17:11:08 <duality> This is the room for Haskell everyone.
17:11:41 <duality> But don't stereotype yourself as noob.  Your real ability always amazes you.
17:12:59 <iron32> Well I haven't written anything significant in Haskell yet so noob is an accurate description
17:13:53 <Philippa_> newbie might be. Last I heard, noob was counter-strike speak for "doesn't cheat" :-)
17:14:01 <zarvok> :)
17:14:38 <duality> In that sense, noob means "haven't unsafePerformIO'ed yet" :)
17:14:49 <SamB> actually, this is only the room for Haskell people who IRC
17:16:47 <iron32> Well I would say noob = hasn't learned how to use monads to make programs more useful that strict math computations 
17:17:29 <iron32> Which haskell gui toolkit is most useful ?
17:17:40 <jer> depends on your definition of useful i would imagine
17:17:43 <duality> gtk2hs.  I'm newly converted.
17:18:04 <Philippa_> duality: I dunno, I don't think there's a lot of people here who'd consider me a noob in that sense (I can write shockingly dirty code when I'm in the mood), but I don't think I've ever actually used it other than for constructing examples (I've seen a few cases where currently I'd use it if writing that code, but they're all lib implementation)
17:18:05 <jer> if you need portability and want it to look the same on all platforms; wx is probably your only option
17:18:50 <iron32> What about ObjectIO that comes with GHC ported from Clean
17:19:25 <Philippa_> iron32: I think "just" using monads probably isn't equivalent to an aimbot or wallhack :-)
17:19:47 <Philippa_> then again, I always used to piss people off by being that bit better at tracking people behind crates or walls than they expected
17:20:21 <duality> Having tried toy examples of unsafePerformIO is sufficient.
17:20:51 <Philippa_> don't think I ever actually ran one
17:21:01 <Philippa_> unless mental evaluation counts
17:21:16 <Philippa_> (oh okay, I know how to write Debug.Trace.trace and I've used it in anger, I guess that prolly counts)
17:21:23 <duality> There are always grey areas :)
17:21:51 <lispy> heh, that's a funny thought: using Debug.Trace.trace in anger :)
17:22:17 <iron32> Phil : Well I am an imperative programmer for most of my life, I am trying out decalrative programming so if I think to highly of monads it is probably my imperative bias
17:22:32 <iron32> :)
17:22:44 <lispy> monads are worth thinking highly of ;)
17:22:45 <SamB> well, Monads are quite lovely
17:22:49 <SamB> but hardly cheating
17:23:07 <SamB> so, they don't count under the counterstrike definition of "noob"
17:23:24 <SamB> er, that is, as disqualifying one from being a noob
17:23:55 <iron32> Sam :  Well maybe it is my extremely limited experience but I dont see how you can accomplish to much useful programming in Haskell without them
17:23:56 <SamB> that is like knowing how to aim and shoot manually
17:25:47 <iron32> Well I am reading up on arrows not sure what the realtionship between arrows and monads are anyone care to enlighten me
17:25:52 <lispy> iron32: depends on what you mean by useful.  Doing IO requires them so if useful includes IO then there yo are :)
17:26:49 <zarvok> iron32 : out of curiosity, what are you using to learn haskell?
17:27:17 <iron32> lispy : Can you define a useful program without IO ? Remeber interpreters and show is also IO.
17:27:24 <zarvok> (I tell everyone who asks me to read "a gentle introduction" to start - I wonder what other people use)
17:27:44 <stepcut> I keep trying to make Arrows but, after I get the Arrow working, I realize that I have just made another Monad disguised as an Arrow :)
17:28:11 <iron32> iron32: I am using the Video lectures and tutorials on www.haskell.org website
17:28:13 <Philippa_> iron32: no they're not. Printing to screen is IO, show is pure
17:28:45 <Philippa_> you can define useful programs without IO, but sooner or later either you execute them in your head or you let something else do IO to show you the result
17:29:33 <Philippa_> iron32: I prefer not being called Phil btw, I'll gender-bend when I choose to if that's alright :-)
17:29:38 <iron32> Phil: now I may not be a Haskell Guru but I am sure of one thing when I type 5 + 5 in hugs or ghc it definitely prints out 10 :)
17:29:53 <iron32> Sorry
17:30:14 <iron32> Philippa : Opps 
17:30:49 <Philippa_> that's because hugs and ghci do IO. The expression "5 + 5" doesn't
17:31:51 <Philippa_> in case you've not met it directly yet, show is a function that turns a value (belonging to a type in the class Show) into a string. Doesn't actually display it though
17:33:06 <iron32> Philippa : Yes I have even defined show for my own types so I understand how it works
17:33:28 <Philippa_> iron32: odds are if you type Phi<tab> your client'll fill the rest in anyway
17:33:48 <iron32> Philippa_: thanks I am an irc noob too
17:34:17 <lispy> iron32: so before haskell what languages did you use?
17:35:06 <Pseudonym> BBS.  Need to go to the lab.
17:35:27 <iron32> Philippa_: Actually quite a few Sadly I make a living desiging software in Java and C++
17:35:53 <iron32> I write my personal stuff in Smalltalk though
17:36:22 <iron32> oops sorr that was meant for Lispy
17:37:11 <iron32> Lispy : I guess your a Lisper ?
17:37:43 <Philippa_> I'm never sure which of Java or C++ I want to be nastier to. Java's the bigger mediocrity, but when C++ gets painful it gets *really* painful...
17:38:08 <iron32> I did use Lisp to write one piece of software which I enjoyed CLOS multiple dynamic inheritance was a great way to model my problem
17:38:41 <lispy> iron32: yeah, CLOS and smalltalk are really good examples of what OO can be
17:39:09 <lispy> iron32: if Java/C++ are your main languages, you'll probably have a lot of habbits to...erm...reform
17:39:13 <iron32> Philippa_: Well I have to disagree Java is a lot better then C++ but that isn't saying much since I think C++ is probably one of the all time worst langauges ever
17:43:01 <iron32> lispy: Well unfortunately my employers don't understand OO so they will always go with the safe mainstream choice and the best they can ever do is write good software. To write great software you have to use great languages 
17:43:02 <Philippa_> I used to muck around with gamedev. That gives you a certain appreciation for the things C++ can do
17:43:13 <Philippa_> at least, it does if you're aiming to do something fast and flashy
17:43:49 <jer> iron32, no you don't. to write "great" software (i'm not sure how you're defining it,  but anyway) ... oyu just need to use a language which best expresses the problems your program sets out to solve
17:43:53 <araujo> iron32, what Smalltalk implementation do you use?
17:44:01 <jer> which may be one of these so called 'crappy languages'
17:44:03 <Philippa_> While I'd resent having to do so, there're still things I'd go to C++ for first (though one of these years I should learn Ada)
17:44:12 <sh10151> be nastier to C++
17:44:14 <iron32> araujo: I use squeak and u
17:44:29 <araujo> iron32, i used to use gnu-st
17:44:32 <Philippa_> jer: in general, that needs a language that'll let you embed the one you want to be using
17:44:44 <Philippa_> at which point you're back to great languages again
17:45:44 <sh10151> Is Python no longer fashionable?
17:45:45 <sh10151> :)
17:46:14 <Philippa_> sh10151: over the weekend, my housemate asked what's so bad about C++ when it's so powerful. My ex-housemate from a few years back gave the sawn-off shotgun pointed at foot explanation. I expanded this to a tacnuke with a hair trigger...
17:46:37 <iron32> Philippa_: See the problem is with C++ programmers is they think C++ is great because they can program in C I have absolutely no problem with C it is a great low leve lanaguage very powerful but if you want to see a better OO system built on C you could use Objective C
17:46:47 <sh10151> C++ isn't even all that powerful
17:46:50 <Philippa_> iron32: who's using C++ for OO?
17:47:09 <sh10151> more of a kitchen sink language
17:47:14 <sh10151> and CL did that better
17:47:15 <iron32> Philippa_: No one the problem is they think they are
17:47:19 <jer> well C++ isn't OO anyway; it's a class language, not an object language
17:47:36 <Philippa_> not everyone using C++ does. Except for the times it can be reasonably argued that they are
17:47:47 <Philippa_> I've written my share of (admittedly small) simulations in it
17:47:51 <jer> just like simula wasn't an OO language (using alan kay's definition of OO)
17:48:12 * Philippa_ nods
17:48:22 <Philippa_> I'm normally fond of something close that definition in fairness
17:48:47 <Philippa_> but IMO if you're going to admit Java as OO then you're being pretty crass to claim an OO style isn't possible in C++
17:49:31 * araujo thinks java is by far worse than c++
17:49:35 <jer> Philippa_, sorry; i wasn't aware that the question was related to style, but rather i was under the impression based on the statement that C++ was being seen as an OO language, which it isn't. sorry if there was a breakdown
17:51:02 <Philippa_> jer: I took that as implicit in iron32's statement that people who think they're doing OO in C++ aren't
17:51:19 <jer> Philippa_, ah okay, i took it literally to mean that C++ was an OO language; my fault
17:51:26 <Philippa_> and don't worry about it, 'snot like there were flames traded
17:51:36 <sh10151> C++ would be nicer than Java if programmers were good
17:51:43 <sh10151> but they suck, so Java is nicer
17:51:45 <iron32> Philippa_: I am a bit lost too besides I don't I am being crass by statement my opinion about C++ I have been coding in imperative languages professionally for 10 years now I don't consider myself a noob in them
17:52:55 <Philippa_> iron32: I agree a lot of supposedly OO C++ code isn't, and to go a step further that OO is often used to just mean "sensible procedural coding" (and then to go a step further you get situations where a faux-OO solution gets shoved in place of the good procedural one because of it), but it's possible to write OO code in C++
17:53:06 <iron32> The inventor of C++ called his creation "A poor mans smalltak or a glorified C"
17:53:18 <Philippa_> sure, no argument there
17:53:23 <Philippa_> I tend to use it as the latter most of the time
17:54:01 <Philippa_> if I want a rather more pleasant poor man's smalltalk I'll go build the right monad and do it in Haskell. Especially if I'm in a concurrent kinda mood
17:54:14 <iron32> Philippa_: C is a great language because the people who made it made for themselves to use if you look at the best languages they all have this property
17:54:33 <jer> Philippa_, Io comes to mind =] (though it's more of a poor man's self at the moment)
17:54:33 <iron32> Java does not have this property
17:54:48 <Philippa_> jer: not used Io, don't know much about it
17:55:08 <araujo> Good languages are those written by programmers, to be used for programmers. In other words.
17:55:13 <jer> Philippa_, ah; it's a pure oo language mostly derived from smalltalk/self and newtonscript (based on prototypes not classes)
17:55:22 <jer> it's rather nice 
17:55:26 <Philippa_> whereas I've knowingly written code in Haskell that I thought of as having a somewhat OO nature, and if my interactions with the outside world're non-trivial I tend to model them in an OO-like manner
17:55:37 <Philippa_> iron32: yeah, I'm not a fan of Java
17:55:40 <araujo> jer, which languag?
17:55:58 <jer> (though i should note that i may not be un-biased as i contribute regularly to it, and have spent considerable time with it over the last 2 years)
17:56:02 <jer> araujo, io
17:56:08 <araujo> ok
17:56:37 <iron32> araujo:  Actually no good lanaguages as written by programmers for themselves tghey have a vested interest in making it good
17:57:21 <Philippa_> so how did Stroustrup screw up so badly? :-)
17:57:22 <iron32> Becuase they will be stuck working and thinking in it
17:57:32 <Philippa_> (answer: he doesn't think he did)
17:57:34 * araujo doesn't understand that sentence
17:57:49 <Philippa_> araujo: put a comma after the "no"
17:58:00 <jer> and a period after "themselves"
17:58:07 <sh10151> I think Stroustrup blames most shortcomings of C++ on AT&T and outside forces
17:58:09 <sh10151> politics
17:58:15 <iron32> Philippa_: Stroustroup was using C++ as an experiment I don't think he ever intended it for wodespread use thats my opinion from what I have read of his works
17:58:37 <Philippa_> iron32: as of C with Classes, yes. I don't think that remained true
17:59:48 <duality> It is a good time to point out that the ancient Chinese language had no punctuation. :)
18:00:00 <iron32> duality :)
18:00:45 <iron32> Besides I think that being here is a statment that we have all seen whats out there and are looking for different things
18:00:54 <iron32> Better things
18:00:57 <duality> Yes
18:01:54 <iron32> So anyone here can explain to me what the hell an arrow is and why I should care ?
18:03:10 <duality> One of the XML libaries, HXT, uses arrows heavily.
18:03:24 <duality> But otherwise, there is no urgency in knowing it.
18:04:24 <duality> I don't know how to say in a few words what arrows are.
18:05:50 <iron32> Ok so I should stick to learning about Monads for now seems like thats taking me quite a few reductions and cells as it is
18:07:52 <Philippa_> iron32: arrows're a bit like monads but the "shape" of the computations they can represent is a generalisation
18:07:53 <iron32> What editors do you all use to edit your haskell programs
18:07:56 <Philippa_> learn more about monads first either way
18:08:07 <stepcut> iron32: emacs
18:08:15 <Philippa_> currently I'm using textpad. Anything MDI with a windows-ish UI and syntax highlighting'd work for me though
18:08:38 <iron32> I use eclipse sigh my java background
18:08:44 <duality> I use emacs and eclipse.
18:08:51 <Cale> I use vim and emacs
18:09:26 <Cale> Any old text editor will do, so long as it will expand tabs to spaces
18:09:40 <Cale> You don't want tab characters going into your source files
18:09:54 <iron32> I haven't tried emacs Haskell mode any good can it do evaluations like the Lisp emacs mode ?
18:10:38 <Cale> I don't know about evaluating things. It will indent things mostly correctly (though personally, I recommend turning the 'smart' indenting off)
18:10:53 <Cale> It'll also tell you the types of prelude functions
18:10:55 <Philippa_> I just don't use the tab key at all
18:11:14 <AtnNn> iron32: c-c c-l will load the file in ghci running in another buffer
18:11:20 <Philippa_> then again, I seem to have a slightly different style to a lot of people when it comes to indentation and alignment
18:11:28 <AtnNn> and i personally love emacs indenting for haskell
18:11:31 <Philippa_> which probably has to do with the fact I'm using the spacebar anyway
18:11:37 <iron32> SamB_XP: You an XP fan ?
18:11:47 <SamB_XP> not exactly a fan
18:11:52 <Philippa_> yeah, he's into eXtreme Pogoing
18:12:10 <SamB_XP> but I can only fit so many firefox tabs in RAM on Debian
18:12:30 <duality> You must have many tabs.
18:12:59 <AtnNn> w3m tabs take a lot less ram than firefox tabs :)
18:13:10 <SamB_XP> I'm sure
18:13:16 <SamB_XP> but the images don't line up right
18:13:22 <iron32> SamB_XP: Well XP sounds promising can't eval it though since never tried anything beyond the test driving part
18:13:40 <SamB_XP> this is Windows XP, btw
18:14:05 <iron32> SamB: O my condolences to us  :)
18:14:25 <SamB_XP> it also does a good impression of being good for gaming
18:14:37 <iron32> SamB_XP: Actually I am gamer so I use it too
18:16:03 <SamB_XP> I probably don't play the same kind of game as you
18:16:07 <SamB_XP> though
18:16:18 <duality> Test-driven programming is not the extreme yet.  The test suite is a formal specification, though incomplete and verbose.  If you complete it and use a concise specification language, that is one step further, and I call it specification-driven programming, which is what Hoare, Dijkstra, ... advocate.
18:16:32 <Cale> I don't know how people end up with so many tabs, even when I'm lazy about closing them, getting over 10 or 15 of them under normal circumstances is uncommon. How many things can you read at the same time?
18:17:01 <SamB_XP> ADD!
18:17:12 <iron32> SamB_XP: Well I play Guild wars and anything else rpg'ish with no monthly fees
18:18:51 <iron32> SamB_XP: How about u what kind of gaming are you into ?
18:19:23 <SamB_XP> I'm not sure
18:19:34 <SamB_XP> I play classic stuff mostly I guess
18:19:45 <SamB_XP> haven't really got the hardware for modern games ;-)
18:21:15 <iron32> Is there a way to specify records in Haskell other that using tuples ?
18:22:05 <SamB_XP> record syntax, yes
18:22:25 <SamB_XP> or you could just do a normal positional constructor
18:22:34 <duality> data Yippee = { x::Int; y::Double; z::String }   -- this can be used like a record type.
18:23:13 <duality> y1 = {x=0; y=0.1; z="hello"}  -- this is one record
18:23:47 <duality> y2 = y1 { x=1 }   -- this is another record, differ from y1 in one field
18:24:01 <iron32> hmm thanks and how would I acess x of y1 ?
18:24:14 <duality> a = x y2   -- this is one way to get the x field of y2
18:24:49 <duality> If you write a function that takes a record as a parameter, there is also a pattern-matching way:
18:24:49 <iron32> is this the record syntax that Sam spoke off
18:24:55 <duality> Yes.
18:25:33 <iron32> Well thats what I have been doing up till now using tuples and pattern matching but I thought that there was probably a better way
18:25:36 <duality> Yuck, there is a mistake in my very first line, in the data type declaration.  Need a (not so useful) constructor tag.
18:26:14 <duality> data Yippee = Y { x::Int; y::Double; z::String}   -- or you can use any unused capitalized word instead of Y
18:27:12 <duality> f (Y {x=myx}) = myx + 1   -- this function extracts the x field of the input record, calls it myx, and computes myx+1.
18:27:26 <iron32> thanks duality this will definitely help me in my goal of writing a useful haskell program
18:28:12 <duality> If your record has a hundred fields, "f (Y {x=myx}) = ..." is very slick when you just need a few fields for that function.
18:28:43 <duality> Of course you can always write "f y = x y + 1" too.
18:29:02 <iron32> duality how long have you been coding in Haskell
18:29:13 <duality> six years
18:29:32 <iron32> Cool how did you discover haskell
18:30:09 <duality> I read the comp.lang.functional newsgroup.
18:30:25 <urz> anybody know how to run a resident mozilla daemon to make faster browser launch?  It can do that on linux as well as windows, right?  
18:30:30 <iron32> Oh so you are coming from FP background
18:31:09 <duality> Before Haskell I learned SML.
18:31:27 <duality> But before SML I was mainly imperative.
18:31:47 <urz> my c++ code for a full fledged video game uses 7% cpu and runs smooth.  my bouncing ball yampa program in haskell uses 98% and misses a lot of frames
18:31:50 <duality> Of course to-date I'm still half imperative half functional.
18:32:01 <urz> heh
18:33:49 <duality> I have not heard of the resident daemon for linux.  But here is what I do: I keep one mozilla/firefox window unclosed and minimized out of sight.
18:33:50 <iron32> Well it has to be purely FP I think since some side effects are desireable not sure how monads encapsulate this exactly but I guess when I figure that out I will have learned haskell
18:34:09 <iron32> has = hard
18:34:19 <qwr> urz: install opera, it starts quite fast :P
18:34:33 <iron32> sorry for typos I am coding and typing
18:34:56 <iron32> How do you make nested modules ?
18:35:06 <urz> i bet opera doesnt start as fast as links2 -g
18:35:10 <urz> or dillo
18:35:22 <duality> Simon Peyton Jones: "Haskell is the finest imperative language on Earth. :-)"
18:36:01 <duality> And me: "The best functional programs are written imperatively.  The best imperative programs are written functionally."
18:36:17 <lisppaste2> Dino_ pasted "IO Monad problem" at http://paste.lisp.org/display/21573
18:36:26 <Dino_> I need some help with this code.
18:37:26 <Dino_> What I have is one function that generates a random number. I want to use it from another (the generate in this example) that makes a [(a,a)] of random numbers.
18:37:49 <iron32> well I guess I have a lot of work to do to learn that for myself :)
18:38:02 <iron32> How do you make nested modules ?
18:38:12 <duality> Can't, unfortunately.
18:38:41 <iron32> I see but some Modules are called Concurrent.Control ?
18:38:49 <iron32> whats up with that
18:38:58 <iron32> they seem nested
18:39:12 <Dino_> That's not a module inside another, it's namespacing.
18:39:24 <Dino_> And corresponds to directory structure, IIRC.
18:39:39 <duality> Just hierarchial, in the same sense of java.util and java.util.zip etc.
18:39:40 <urz> I want to use profiling on my ghc-compiled program
18:40:04 <urz> the docs say i have to compile all modules with -prof
18:40:27 <iron32> So how do I use similar namesapacing then ?
18:40:35 <qwr> Dino_: what the generate type signature should be?
18:40:52 * qwr thinks it should return the list
18:40:57 <urz> using -prof on all modules would require me to rebuild libraries and crap.  I just want to profile this one file
18:41:02 <Dino_> iron32: You can name your module Foo.Bar and then put the file in Foo/Bar.hs
18:41:05 <urz> can ghc do what i want?
18:41:42 <iron32> ok Thanks
18:41:45 <Dino_> qwr: Yeah, I'm not sure what it should be. I'm very new to the big H yet.
18:41:46 <qwr> so it would be Int -> IO [Int, Int]
18:42:06 <Cale> hm?
18:42:12 <Cale> that's a syntax error
18:42:12 <Dino_> qwr: Oh, well, what I'd like is Int -> [(Int, Int)]
18:42:22 <Dino_> Create a list of pairs
18:42:46 <duality> Suppose you have modules A.B and X.Y, they clash because both have "f".  You can do this: import A.B as C; import X.Y as Z.  Then C.f refers to the former, Z.f refers to the latter.
18:42:47 <Dino_> And I don't know where the IO fits into it.
18:43:06 <Cale> Dino_: a list of random pairs
18:43:06 <Cale> ?
18:43:23 <heatsink> Well, this is interesting.
18:43:25 <Dino_> duality and iron32: There's actually some decent info on importing in Yet Another Haskell Tutorial, which I've been reading furiously lately.
18:43:29 <Dino_> Cale: yes
18:44:05 <heatsink> I have a polymorphic type escaping due to a call to seq.
18:44:27 * qwr thinks that you cannot take data out of the IO monad
18:45:03 <Dino_> qwr: That's fine, I'm ok with an IO [(Int, Int)] coming out of there.
18:45:06 <Cale> qwr: you can, sort of, but there's just no way to turn an IO action into a value
18:45:09 <Dino_> But can't even make that work.
18:45:13 <Cale> oh
18:45:24 <Cale> well, that's easy enough
18:45:33 <iron32> Dino_:  Thanks I have read that tutorial but will read it again can only absorb so much FP/Haskell in one pass have to do multipass to get it all
18:45:33 <Cale> @type randomsRIO
18:45:34 <lambdabot> Not in scope: `randomsRIO'
18:45:38 <Cale> @type randomRIO
18:45:40 <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:45:51 <Cale> how long of a list do you want?
18:45:57 <Dino_> iron32: I totally understand, I have to go back and read about types and classes for the third time later.
18:46:21 <Cale> and how should the random values be chosen?
18:46:25 <Dino_> Cale: I was trying to pass that into generate.
18:46:27 <Cale> what's that input parameter mean?
18:46:57 <Dino_> http://paste.lisp.org/display/21573
18:47:14 <Dino_> Just the total number of items in the list.
18:47:57 <Dino_> I realize this could be a bad way to do that, a finite list of something by decrementing.
18:48:03 <qwr> bind the list tail and use return to put the result list into IO ?
18:48:09 <Cale> Dino_: you're consing a pair with an IO action
18:48:20 <Cale> you need to run the action and cons the result instead
18:48:39 <Cale> (in generate)
18:48:42 <Cale> like
18:48:48 <Cale> generate index = do
18:48:56 <Cale>    first <- oneRandNum 0 2
18:49:00 <Cale>    second <- oneRandNum 0 2
18:49:10 <Cale>    rest <- generate (index - 1)
18:49:21 <Cale>    return ((first,second) : rest)
18:49:36 <Dino_> You know, a lot of problems I have seem to come from not being able to trust the lazy.
18:49:47 <Dino_> It's like The Force
18:49:54 <Cale> this isn't lazy though, it's in IO
18:50:08 <Dino_> Oh, so it all gets executed all the way to the end, in this case?
18:50:11 <Cale> right
18:50:19 <Dino_> Because it's a sequence.
18:50:25 <qwr> Dino_: http://www.nomaware.com/monads/html/
18:50:56 <Cale> @type randoms
18:50:57 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
18:51:04 <Cale> you might be interested in that though
18:51:16 <Cale> It'll give you an infinite list of pseudorandom values
18:51:39 <Cale> you can use the IO action newStdGen to get a random generator to pass it
18:51:40 <palomer> you're all nuts.
18:51:52 <Cale> @palomer
18:51:52 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
18:51:55 <Cale> @palomer
18:51:56 <lambdabot> That's a lie
18:52:14 <Dino_> Cale: As in, numbers between 0 and 1?
18:53:25 <lispy> Cale: i think those palomer quotes are funny when taken back to back :)
18:53:29 <Cale> Dino_: depends on the type
18:56:11 <Dino_> Cale: I see. Ok, thank you.
18:56:33 <Dino_> qwr: Thank you too. I'll read that.
18:56:57 <Cale> Dino_: if you need to control the range, randomRs
18:57:01 <Cale> @type randomRs
18:57:03 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
18:57:45 <Dino_> Ok, the R for range and the s for lists of them.
18:57:54 <Cale> yeah
18:59:40 <palomer> palomer quotes are _always_ funny
18:59:47 <palomer> don't _you_ forget that
19:00:08 <lispy> oh sorry, sir
19:00:12 <lispy> @palomer
19:00:13 <lambdabot> Blargh!
19:00:18 <lispy> scalliwags!
19:00:27 <Dino_> Hm. I'm getting the same error from that code even after executing.. rest <- generate (index - 1)
19:01:54 <Dino_> Ok, I think it may be the end condition that's a problem:  generate 0 = []
19:03:20 <Dino_> Ok, I see, I have to 'return []'
19:06:26 <Cale> right, think of the function as constructing an action to perform based on its parameter
19:10:38 <Dino_> I know you guys went over a lot of this just a week ago with me. I think I'm having problems with it 'sticking' yet.
19:10:59 <Cale> yeah, it takes practice
19:11:34 <Dino_> And the reason why this particular function has to be an action is that its data is coming from something monadic (the randomR stuff).
19:11:44 <Dino_> Is that sort-of right?
19:11:47 <Cale> yeah
19:11:56 <Cale> specifically that it's the IO monad
19:12:25 <Cale> if you need an IO action to get your job done, then you have no choice but to construct another IO action around it
19:12:33 <Cale> you can use pure functions too of course
19:12:53 <Cale> but the results of IO actions are only accessible from other IO actions
19:12:56 <Dino_> I can see already why the infinite list of randoms may be better. Presumably I can just pull them off as needed and not have to rack up a lot.
19:14:08 <Dino_> I see, and this is ok because you can isolate the IO stuff to main or something close to there and try to do much of the real work with pure functions.
19:14:16 <Cale> right
19:14:33 <Cale> generally, you only do actual I/O stuff in the IO monad
19:14:47 <lisppaste2> AtnNn pasted "instance of MonadStack?" at http://paste.lisp.org/display/21576
19:14:57 <AtnNn> can someone help me with that error?
19:15:20 <RyanT5000> any ideas as to why preservingMatrix would be taking 29% of my CPU and 20% of my allocation?
19:15:21 <Dino_> Ok, I have to split. Thanks again.
19:16:05 <Cale> AtnNn: flip the args to MonadState
19:16:06 <RyanT5000> i have code that looks like this: {-# SCC "preservingMatrix" #-} preservingMatrix $ {-# SCC "notPreservingMatrix" #-} (stuff)
19:16:14 <iron32> Well I am trying to to make my defined record be an instance of show I am having trouble pattern matching my fields so I can make them into a string for the function show
19:16:44 <AtnNn> Cale: Illegal instance declaration for `MonadState s (Stack s)'
19:16:56 <iron32> Any Haskell guru give me some guidance ?
19:17:21 <iron32> Here is my code
19:17:26 <iron32> module WFRP.Stat where
19:17:26 <iron32> data Stat = MakeStat 
19:17:26 <iron32> 	{ 
19:17:26 <iron32> 	name :: String,
19:17:26 <iron32> 	baseValue :: Int,
19:17:27 <iron32> 	totalAdvances :: Int,
19:17:29 <iron32> 	advancesTaken :: Int,
19:17:31 <iron32> 	totalValue :: Int
19:17:33 <iron32> 	}
19:17:35 <iron32> instance Show Stat where
19:17:37 <iron32> 	show MakeStat { n, bv, ta, at, tv } = "name: " 
19:17:39 <iron32> 		++ n ++ " bv: " ++ ( show bv ) ++ " ta: " ++ ( show ta )
19:17:41 <iron32> 		++ " at: " ++ ( show at ) ++ " tv: " ++ (show tv )
19:17:43 <iron32> 		
19:17:45 <RyanT5000> i can't understand any circumstance under which the most expensive operation in drawing 100 lines or something would be the preservingMatrix calls
19:20:26 <iron32> got quiet all of a sudden
19:20:46 <RyanT5000> what's your question, iron32?
19:21:00 <Cale> iron32: what's the error?
19:21:14 <iron32> I am trying to make my record an instance of Show so it will print out in the interpreter
19:21:20 <Cale> iron32: you may need to put the field names while matching
19:21:27 <Korollary> There shouldn't be curlies in the instance method pattern
19:21:29 <Cale> iron32: or else remove the braces and commas
19:21:35 <RyanT5000> also, did you try just throwing "deriving (Show)" after your datatype? do you actually care what it looks like?
19:21:37 <AtnNn> Cale: is MonadState s (Stack s) what you meant?
19:21:47 <Cale> AtnNn: yes
19:21:51 <iron32> My code I provided doesn't compile / interpret I am guessing I haven't got the pattern matching right
19:21:55 <Cale> AtnNn: It's MonadState s m
19:22:04 <Cale> iron32: yeah
19:22:22 <aFlag> why does Map lookup returns a monad?
19:22:24 <Cale> iron32: remove the curly braces and commas from your pattern and put parens around it
19:22:37 <aFlag> shouldn't it just return the value i have stored there?
19:22:43 <Cale> aFlag: that's so that it works with Maybe and List just as well
19:22:44 <AtnNn> Cale: that doesnt work either
19:22:52 <lorne> http://www.haskell.org/onlinereport/exps.html#sect3.15.3 might be of interest
19:23:12 <AtnNn> and all about monads says `class MonadState m s' :\
19:23:13 <Cale> aFlag: It should probably be returning a MonadZero
19:25:02 <Cale> AtnNn: What's the error?
19:25:07 <aFlag> what's the problem with Maybe and List? So always when i want to make a map lookup in a function that function should be a monad?
19:26:13 <AtnNn> Cale: Illegal instance declaration for `MonadState s (Stack s)' \ (The instance type must be of form (T a b c)
19:26:29 <Cale> aFlag: It's just a clever way to handle failure -- though monads don't generally support failure, so it's a little misguided. Still, if we assume every monad is a MonadZero, it's a good way to handle things
19:26:36 <Cale> AtnNn: -fglasgow-exts
19:26:37 <ihope> Yay, type fireworkd!
19:26:48 <ihope> Erm, fireworks!
19:26:59 <AtnNn> Cale: ah, ty
19:27:01 <RyanT5000> @where OpenGL
19:27:01 <lambdabot> I know nothing about opengl.
19:27:18 <RyanT5000> does anyone know where i can get the Graphics.Rendering.OpenGL source?
19:27:24 <RyanT5000> 2.0
19:27:24 <AtnNn> I've got fireworks outside to
19:27:48 <ihope> I made a function to overload two values into a single one that's used as one or the other depending on the types
19:28:21 <ihope> It hates polymorphism.
19:28:45 <RyanT5000> just like C++
19:29:08 <RyanT5000> "here is a page of rules on overload resolution; they almost kind of specify what actually happens"
19:29:40 <ihope> forall t a. (Coerce ([Char], a -> a) ([Char] -> t)) => t
19:30:00 <ihope> That's what happens when you mkWeirdPair "foo" id "bar"
19:30:28 <RyanT5000> ....  why would you do such a thing?
19:30:31 <iron32> Cale : Well now it only complains about my identation can't seem to figure out why though
19:30:40 <ihope> "foo" "bar" obviously doesn't work, so it chooses id "bar", but it doesn't work because id is polymorpic.
19:31:34 <ihope> It works if I add type signatures for id AND the entire expression.
19:33:06 <iron32> instance Show Stat where
19:33:06 <iron32> 	show MakeStat ( n bv ta at tv ) = 
19:33:06 <iron32> 		"name: " ++ n ++ " bv: "
19:33:06 <iron32> 		++ ( show bv )
19:33:06 <iron32> 		++ " ta: " ++ ( show ta )
19:33:07 <iron32> 		++ " at: " ++ ( show at )
19:33:09 <iron32> 		++ " tv: " ++ ( show tv )
19:33:17 <iron32> This gives me a parse error in the pattern
19:33:31 <RyanT5000> (MakeStat n bv ta at tv)
19:33:38 <iron32> thanks
19:33:40 <RyanT5000> np
19:34:20 <RyanT5000> however, if you don't really need your own special format, you can just put "deriving Show" after your data declaration and it'll make it for you
19:35:26 <ihope> Um, it seems that Haskell is ignoring my type synonym entirely.
19:35:34 <ihope> type WeirdPair a b = forall c. Coerce (a,b) c => c
19:36:21 <ihope> Then I have mkWeirdPair :: a -> b -> WeirdPair a b, but GHCi says mkWeirdPair has type forall c b a. (Coerce (a, b) c) => a -> b -> c.
19:38:52 <RyanT5000> oh man...
19:39:29 <RyanT5000> whose idea was it to have the choice be preservingMatrix, which is ridiculously slow, or unsafePreservingMatrix, which doesn't recover from exceptions?
19:39:45 <RyanT5000> (preservingMatrix is slow because it *also* preserves the matrix mode)
19:40:45 <Cale> ihope: hm?
19:41:11 <Cale> ihope: I don't see what's wrong about that
19:41:23 <ihope> Well, I wanted it to use the type signature.
19:41:32 <Cale> do you want it to produce a higher rank type?
19:41:45 <ihope> Um... I guess.
19:42:08 <Cale> oh, but it's on the right side of an arrow anyway
19:42:13 <Cale> nevermind :)
19:42:32 <ihope> Hmm, gotta go. Pretend it's an emergency.
19:50:19 <iron32> good night all thanks for all your help
20:05:53 <RyanT5000> woah; is bracket known to be extremely expensive?
20:07:48 <RyanT5000> does it make sense for bracket to be taking 15ms to run on a 1.7ghz chip?
20:09:00 <urz> I need help trying to use profiling
20:09:19 <urz> i use --make to get it to find all the libraries to link up my program
20:09:36 <urz> but -prof makes that not work anymore
20:09:38 <urz> aparently
20:09:52 <urz> i'm using ghc
20:09:55 <RyanT5000> your libraries need to be built with "configure -p"
20:10:10 <RyanT5000> that will make it produce .p_o files in addition to .o's
20:10:13 <urz> well i built one with --enable-executable profiling
20:10:24 <urz> er, --enable-executable-profiling
20:10:35 <RyanT5000> no, that's not for libraries
20:10:37 <urz> i tried -p but that doesnt seem to work
20:10:44 <urz> it doesnt recognize -p
20:10:52 <RyanT5000> what version of cabal do you have?
20:10:54 <urz> it's Lemmih's library
20:10:58 <urz> SDL bindings
20:11:12 <RyanT5000> yah, i'm using that with profiling right now
20:11:27 <RyanT5000> (that's why i'm complaining about bracket, lol)
20:11:42 <urz> oh
20:11:45 <urz> well what do i need to do
20:11:51 <urz> i dont know anything about cabal really
20:11:52 <RyanT5000> what version of Cabal do you have?
20:11:56 <urz> i dont know how to know what version
20:11:58 <RyanT5000> type ghc-pkg list
20:12:10 <RyanT5000> it should say Cabal-1.1.4 or some version number
20:12:23 <urz> Cabal-1.0
20:12:30 <RyanT5000> alright, you need to update cabal
20:12:33 <RyanT5000> that's what i had to do
20:12:39 <urz> oh
20:13:00 <urz> can i do it via apt-get ?
20:13:06 <RyanT5000> hm... not sure
20:13:13 <RyanT5000> i did it on windows
20:13:23 <RyanT5000> you probably can though
20:13:35 <urz> it must come with ghc
20:13:43 <urz> and its all packaged up in a ghc package
20:13:59 <RyanT5000> yeah, but 6.4.2 comes with 1.0
20:14:14 <RyanT5000> only 6.5 and future releases will come with 1.1.4 or better
20:14:18 <urz> i have 6.4.1
20:14:27 <RyanT5000> alright well either way
20:14:41 <RyanT5000> actually, perhaps 6.4.2 has 1.1.4, but i don't think so
20:14:50 <RyanT5000> either way, getting it out of darcs is really easy
20:14:55 <RyanT5000> you just build the new cabal with your current one
20:15:11 <jgrimes> 6.4.2 comes with 1.1.4
20:15:19 <RyanT5000> k
20:15:44 <urz> but 6.4.2 is not aparently packaged for debian
20:15:53 <alec> urz: check out the haskell-unsafe repository
20:16:02 <urz> what's that?
20:16:08 <alec> urz: 6.4.2 packages were put up the other dasy
20:16:22 <RyanT5000> isn't there  anyone who knows about exception handling here?
20:16:25 <alec> urz: unsafe/testing haskell packages for debian
20:16:30 <RyanT5000> specifically why bracket is so slow?
20:16:31 <urz> oh
20:16:34 <alec> urz: search for it, I don't have a link handy
20:16:43 <alec> urz: be warned, it's "unsafe"
20:16:56 <RyanT5000> lol
20:17:41 <alec> urz: you'll also probably need to be running unstable
20:17:50 <alec> urz: although I suppose you could backport it if you're desperate
20:18:06 <alec> urz: I think an upload to unstable is coming "real soon now"
20:18:17 <jgrimes> RyanT5000, are you sure it is bracket that is slow?
20:18:24 <RyanT5000> yep
20:18:29 <jgrimes> hm
20:18:34 <RyanT5000> {-# SCC "bracket" #-} bracket_ ({-# SCC "push" #-} glPushName name) ({-# SCC "pop" #-} glPopName)
20:18:37 <urz> thanks
20:18:59 <urz> i think getting cabal with darcs will be faster for me
20:19:00 <urz> heh
20:19:13 <urz> i'm running stable
20:19:22 <RyanT5000> oh maybe i'm not understanding that external SCC quite right
20:19:55 <RyanT5000> maybe it applies to the whole application of bracket_, even though the function it's in only partially applies bracket_?
20:22:24 <jgrimes> RyanT5000, the {-# SCC "bracket" #-} is just going to label that function as bracket, instead of bracket_, I believe.
20:22:44 <RyanT5000> yeah i know that
20:22:51 <RyanT5000> i don't care what it's labeled
20:22:54 <jgrimes> ok
20:22:59 <RyanT5000> (it wasn't labeled before)
20:23:15 <RyanT5000> yeah ok it's definitely bracket
20:23:23 <RyanT5000> because i wrote a version with and a version without bracket
20:23:33 <jgrimes> interesting
20:23:56 <RyanT5000> when i clock the actual application of the function (twice, actually), it takes 38% of my time when it's bracketed, and 0.0% when it's not
20:24:20 <RyanT5000> i'm on windows x86, but i have a hard time seeing how windows would matter in this case
20:26:19 <RyanT5000> i've obviously going profiling turned on, but i'm on -O2
20:27:10 <urz> what's bracket do?
20:27:23 <RyanT5000> @hoogle bracket
20:27:23 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:27:24 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
20:27:24 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
20:27:56 <RyanT5000> it does the first action, then takes the return value from that, passes it to the third function, and then passes it to the second one
20:28:05 <RyanT5000> the second is called even if the third throws an exception
20:28:18 <RyanT5000> and the exception is rethrown once the second completes
20:29:15 <urz> oh
20:29:27 <RyanT5000> an example is "withFile name = bracket (openFile name) (hClose)"
20:30:34 <urz> ok i see
20:30:59 <urz> and that answers my question on why the second argument is second instead of last
20:31:02 <urz> heh
20:31:19 <RyanT5000> yep
20:31:22 <RyanT5000> yay currying
20:31:38 <jgrimes> :)
20:31:50 <jgrimes> RyanT5000, yeah I have no idea why bracket is taking so long
20:32:48 <urz> upgraded cabal
20:32:51 <RyanT5000> to be honest i don't need it there - in the middle of my render function
20:33:00 <RyanT5000> however, there's no unsafeWithName in the standard OpenGL lib
20:33:11 <RyanT5000> so i'm going to have to use foreign imports
20:35:13 <urz> yep. it says it will do -p now and a lot of other stuff that wasnt there before in the --help listing
20:35:49 <RyanT5000> good, that's all you need if i remember correctly (well, that and to recompile some of your libs)
20:37:38 <urz> no
20:37:41 <urz> its choking
20:37:45 <RyanT5000> on?
20:38:21 <urz> keeps complaining about .setup-config and then how configure isnt executable
20:38:44 <urz> in hsSDL/src/Core
20:39:27 <RyanT5000> are you using setup.lhs or the config files that are already there?
20:39:40 <RyanT5000> i vaguely remember an error like that but i think i ended up sidestepping it
20:42:20 <urz> if i deleted a file, how do i get it back with darcs?
20:42:35 <urz> like cvs update
20:45:46 <urz> damn
20:46:14 <lorne> try revert
20:49:24 <urz> seems to have worked
20:50:24 <urz> thanks
20:50:45 <urz> revert -a
20:50:59 <urz> if i dont want to answer a lot of stressful y/n questions
20:51:04 <urz> heh
20:53:33 <mathewm> anyone here familiar with the recent HaXml changes?
20:53:42 <mathewm> I cannot find any papers/documentation on it
21:01:34 <mathewm> ?where haddoc
21:01:35 <lambdabot> I know nothing about haddoc.
21:02:00 <mathewm> ?where haddock
21:02:00 <lambdabot> http://www.haskell.org/haddock/
21:03:18 <kfish> ?where pants
21:03:19 <lambdabot> I know nothing about pants.
21:03:24 <kfish> damn
21:10:40 <RyanT5000> can you turn on optimization for ghci?
23:20:35 <Heffalump> can anyone show me a simple way of making WASH link to an external image?
23:20:43 * Heffalump is getting rather confused by all the types.
23:30:13 <urz> does threadDelay trigger garbage collection?
23:30:56 <urz> i figure that if all my threads are delayed, the run time system should collect all the garbage and if it still has time to kill yield it to the OS
23:31:15 <urz> is that what it does
23:31:16 <urz> ?
23:32:19 <Heffalump> I'm not aware of it making any guarantee about garbage collection
23:32:30 <Heffalump> I'm sure it'll yield to the OS if all are delayed
23:34:23 <urz> SDL's pollEvent interface seems poorly designed
23:34:54 <urz> I should be able to wait on events with a time out
23:35:57 <urz> i was thinking to add that
23:36:27 <urz> i figure its better to delay as long as possible rather than short increments just to check pollEvent
23:37:25 <urz> but if i wrote that in C, it'd delay all haskell threads i think, and I dont want it to hold up garbage collection.  Is gc counted as a haskell thread delayed by foreign calls?
23:38:40 <urz> actually foreign calls probably trigger a little gc action
23:39:04 <urz> but if this is a delay, it seems like a great time to do more than a little
23:39:12 <urz> if more than a little is required
23:46:59 <Stinger_> monads hurt my brain :(
23:47:13 <lispy> urz: if the haskell code is delayed, do you need gc?
23:47:46 <lispy> urz: and, afaik ghc has a synchronous gc meaning it runs with the thread of execution and triggers as needed
23:48:45 <urz> I have a bouncing ball program using Yampa
23:48:51 <urz> but the performance is awful
23:50:11 <urz> i want a consistent frame rate so I dont want it to decide to take a long time doing gc at some point
23:52:01 <urz> the profiler says most of the time is spent drawing a rectangle
23:52:18 <urz> which doesnt make too much sense to me, but its possible
23:52:39 <urz> i use SDL's fillRect function
23:53:17 <urz> I should only be doing it 45 times per second and judging by the animation quality i figure its less
23:53:48 <urz> the program consumes 90% cpu on a 1ghz computer 
23:54:16 <urz> it makes yampa and haskell look pretty bad
23:54:31 <urz> i dont even erase the ball
23:54:43 <urz> i let it leave a trail
23:54:57 <urz> bouncing square i should say
23:58:57 <urz> anybody got any SDL drawing primatives for things like circles and lines?
23:59:01 <urz> for haskell
