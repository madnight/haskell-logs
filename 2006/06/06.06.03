00:38:49 <dreamEye> Hello you, wise peope, that navigate the beatiful worrld of the algorithmical abstractions with the most beatiful ever language
00:39:12 <Cale> hi
00:39:19 <dreamEye> or something l
00:44:01 <dreamEye> aesthetic in a tool is the proximate effect in the mind of  the perception of utility, simplicity and powerfulness
00:44:56 <dreamEye> being the tool a house, a weapon or a programming language
00:50:39 <Cale> @fptools Parsec
00:50:39 <lambdabot> Parsec not available
00:51:03 <Cale> @fptools Text.ParserCombinators.Parsec.Combinator
00:51:03 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec/Combinator.hs
00:52:16 <dreamEye> @ftptools help
00:52:17 <lambdabot> help not available
00:52:26 <dreamEye> shit
00:53:17 <Cale> It takes a package name and gives the URL for the source
00:53:36 <dreamEye> ok
00:54:05 <Cale> (for the modules in the fptools repo, at least)
00:54:17 <dreamEye> thanks
00:57:05 <dons> audreyt: oh, hmm. my fault i think ....
00:57:57 <dons> audreyt: fixing...
01:04:51 <dons> @dynamic-reload dummy
01:04:51 <lambdabot> module reloaded
01:04:53 <dons> @eval
01:04:55 <dons> @eval
01:05:06 <dons> audreyt, you want to check that its fixed now? I think it should be
01:05:51 <dons> @seen sjanssen 
01:05:51 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
01:43:53 <apfelmus> the darwin port file for ghc-6.4.2 (rev 1) is unable to build ghc. seems to be a workpath problem. anybody knows?
01:45:32 <ulfdoz> apfelmus: dunno, if it helps you, the fink-build worked for me.
01:47:04 <dreamEye> @seen lambdabot
01:47:04 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #haskell.es, #Haskell.se, #haskell.it, #perl6, #darcs, #haskell_ru, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah, #haskell and #ScannedInAvian
01:47:53 <apfelmus> ulfdoz: mmh, that means i have to upgrade all dependencies over a 56k modem. no fun.
01:48:39 <ulfdoz> apfelmus: Yes, but unfortunately all package managers suffer from this problem.
01:51:38 <wolverian> ulfdoz, what about the ones that run over the post service? 
01:52:05 <apfelmus> ulfdoz: indeed. sometimes, i dream of a world where all package managers are written in |-|askell and thus eradicate these problems :-)
01:52:31 <ulfdoz> wolverian: I consider this not really suitable for regular updating.
01:53:08 <wolverian> apfelmus, haskell makes modems run at dsl speeds? :)
01:55:32 <apfelmus> wolverian: only the most pure hearts see wonders ;-) (we should silence about laziness here)
02:04:07 <ulfdoz> on the haskell-request ML someone proposed to write device driver for minix in haskell. Has anyone already written some lines?
02:09:44 <dons> yeah, i noticed they didn't mention the recent work on verifying kernels by writing them in haskell first
02:09:49 <dons> maybe i should have replied
02:09:59 <audreyt> dons: works, thanks
02:10:05 <audreyt> dons: with latets fps on darcs I get this
02:10:08 <audreyt> Compiling Data.ByteString.Lazy ( ./Data/ByteString/Lazy.hs, dist/build/./Data/ByteString/Lazy.o )Prologue junk?:         .type   sdEX_ret, @functionsdEX_ret:        xorl    %eax, %eax        movl    %eax, 4(%esp)
02:10:12 <audreyt> when compiling Lazy
02:10:22 <dons> oh, hmm. linux/6.4.2 bug?
02:10:27 <dons> add -fasm to the build flags
02:10:44 <dons> looks like typical mangler/gcc version/ghc version issue
02:11:11 <dons> you should be able to get away with adding -fasm to just the .Lazy file in a pragma
02:11:32 <audreyt> yes, and .Char8 too
02:11:34 <dons> though ideally, we should report this to ghc HQ, along with the ghc and gcc versions
02:11:38 <audreyt> should this be checked in upstream?
02:11:48 <dons> ghc should be fixed.
02:12:01 <dons> which gcc version?
02:12:39 <audreyt> 6.4.1
02:12:53 <audreyt> 4.0.4 debian
02:13:04 <dons> ok, i'm not seeing it with 4.0.3 20051201
02:13:07 <dons> debian
02:13:19 <dons> another option, tune down the gcc flags in the fps.cabal file
02:13:30 <dons> so -optc-O2 becomes -optc-O1
02:13:34 <dons> might just work
02:13:48 <audreyt> what's the downside of -fasm?
02:13:52 <dons> slower
02:14:05 <dons> and not portable (gcc works on more archs)
02:14:14 <dons> can you try recompiling with -optc-O1 in the .cabal file?
02:14:33 <dons> if that works, i'll set it as default.
02:15:10 <audreyt> that works.
02:15:15 <audreyt> I only pragmad it
02:15:17 <audreyt> on Lazy
02:15:24 <dons> ok. great.
02:15:40 <ulfdoz> dons: I'd be really interested in seeing drivers and other parts of OSes in language with less maintainance overhead the C and more intresting coding techniques.
02:15:48 <dons> audreyt, i'll run a benchmark, check it doesn't kill anything too badly, and then push it.
02:16:23 <dons> ulfdoz: there's a couple of projects to write device drivers in haskell (we did such a thing here at unsw last year)
02:16:44 <dons> though, that was using haskell as a dsl to generate the C code version
02:17:10 <audreyt> dons: I think per-file -optc-O1 is better
02:17:13 <audreyt> the default should still be -O2
02:17:18 <integral> dons: hmm, did you use some library to pretty print your C, or just write something yourselves?
02:17:18 <ulfdoz> so, I should found it when asking google. :)
02:17:23 * integral was thinking of trying that
02:17:33 <dons> audreyt: though i'm suspicious if it happened once, it'll happen again somewhere else (in particular, amd64)
02:18:07 <dons> integral: i didn't do the work. sean seefried did -- he's the local edsl guy.
02:18:21 <integral> ah. n/m then :)
02:18:21 <dons> i'd have to  check with him on the details. but i think it was something like how Pan does it.
02:18:26 <apfelmus> ulfdoz,dons: a dsl for writing device drivers would be nice. i mean: write driver once and get it free for a huge amount of different kernel (architectures).
02:20:30 <apfelmus> thus uncoupling kernel and device
02:22:25 <dons> audreyt: -O2 does make a good difference. I'll just add it to *.Lazy.*
02:22:43 <audreyt> k
02:25:03 <dons> commited the fix. cheers.
02:25:28 * dons -> dinner
02:25:40 <audreyt> danke
02:43:34 <dsacode> Hello! Is it possible to calculate sum of square of natural integers [1..n] effectively in Haskell?
02:44:22 <apfelmus> > let n = 5 in sum [k*k | k <- [1..n]]
02:44:23 <lambdabot>  55
02:45:45 <apfelmus> dsacode: there is an explicit formula, too.
02:46:02 <Cale> > let n = 5 in n * (1+n) (1+2*n) `div` 6
02:46:03 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
02:46:03 <lambdabot>   Expec...
02:46:06 <Cale> er
02:46:13 <Cale> > let n = 5 in n * (1+n) * (1+2*n) `div` 6
02:46:14 <lambdabot>  55
02:46:48 <Cale> > let n = 100000000 in n * (1+n) * (1+2*n) `div` 6
02:46:50 <lambdabot>  333333338333333350000000
02:46:51 <neologism> I think that in every turing-complete language its possible to "calculate anything" :)
02:47:26 <apfelmus> neologism: but only things which are calculable (computable)...
02:47:46 <neologism> sure... but you usually dont want to calcualte not computable things
02:48:36 <neologism> thats why I put it into " "
02:48:38 <johnnowak> neologism: i always want to calculate non-computable things.
02:49:08 <johnnowak> or at least declare them
02:49:48 <neologism> let oraculum x = answerQuestion x in oraculum "who will be the next president of the USA?"
02:50:07 <johnnowak> let breakfast n | n >= 4 = waffles * n
02:50:47 <Cale> > product [1,1..]
02:50:50 <lambdabot> Terminated
02:50:53 <resiak> =)
02:51:54 <Cale> (I've been bitten by that before :)
02:52:06 <apfelmus> neologism: well, program correctness unfortunately (?) is something not computable
02:52:13 <Cale> not so directly
02:53:40 <dsacode> Cale: i have Int -> Int type so I have problem with your formula. failed on: 1024 bad result: -357389483 expected: 358438400
02:53:53 <dsacode> Cale: may be it's possible to improve it?
02:54:16 <apfelmus> dsacode: Int is only 32 bit (or 64, something finite).
02:54:25 <apfelmus> > 2^^(32)-1 + 1
02:54:26 <lambdabot>  4.294967296e9
02:54:47 <apfelmus> > 2 **(32) - 1 + 1 `asTypeofÂ´ Int
02:54:47 <lambdabot>  Illegal character ''\180''
02:54:59 <apfelmus> > 2 **(32) - 1 + 1 `asTypeof` Int
02:54:59 <lambdabot>  Not in scope: data constructor `Int'
02:55:12 <dsacode> But.. 358438400 :: Int
02:55:12 <apfelmus> > 2 **(32) - 1 + 1 `asTypeof` (1 :: Int)
02:55:13 <lambdabot>  Not in scope: `asTypeof'
02:55:16 <johnnowak> apfelmus: not true -- i can prove that any program written in C is incorrect.
02:55:53 <apfelmus> > (2 ** (32)) :: Int
02:55:53 <lambdabot>  add an instance declaration for (Floating Int)
02:55:54 <lambdabot>   In the expression: (2 ** ...
02:56:02 <apfelmus> @info **
02:56:03 <lambdabot> Unknown command, try @list
02:56:08 <apfelmus> agrl
02:57:04 <apfelmus> johnnowak: ah, that's too easy ;-)
02:57:33 <johnnowak> apfelmus: more of a complaint about most C programmers than C really. :)
02:58:33 <apfelmus> > ((2^32) :: Int, 2^32)
02:58:34 <lambdabot>  (0,4294967296)
02:59:20 <apfelmus> > 358438400*6 `asTypeOf` (1 :: Int)
02:59:21 <lambdabot>  -2144336896
03:00:33 <apfelmus> dsacode: the number is too large before you divide by 6
03:03:01 <apfelmus> > let n = 1024 in (n * (1+n) `div`2) * ((1+2*n) `div` 3)
03:03:02 <lambdabot>  358438400
03:04:41 <apfelmus> dsacode: now, its smaller, but `div` 3 is no good as (1+2*n) is not necessarily divisble by 3
03:06:28 <davidhouse> hey all
03:10:07 * davidhouse wonders whether dons applied his latest patch yet
03:10:10 <davidhouse> @instances Monad
03:10:11 <lambdabot> [], ArrowMonad a, WriterT w m, Writer w, ReaderT r m, Reader r, StateT s m, State s, RWST r w s m, RWS r w s, ErrorT e m, Either e, ContT r m, Cont r, Maybe, ST s, IO
03:10:15 <davidhouse> nope.
03:14:31 * davidhouse wonders whether everyone else is asleep
03:21:56 <Azmo> is it possible to get the names of the fields of an arbitrary structure, or are the fields just generated functions that can not be aquired? the Show class knows the names though..
03:22:47 <davidhouse> that's because the compiler automatically generates the Show instance declaration
03:22:55 <davidhouse> the compiler does know which fields you have
03:22:58 <ADEpt> Azmo: imo, you can do this via Template Haskell
03:23:12 <davidhouse> ADEpt: hmmm... can you?
03:23:21 <davidhouse> TH offers reflection?
03:23:53 <ADEpt> davidhouse: i remember something from reading TH docs ...
03:24:02 <ADEpt> davidhouse: not 100% sure, though
03:26:19 <Azmo> thanks. i'm trying to print structures with '\n' between fields and integers in base16 instead of 10 for arbitrary structures. current i need an instance of show for each structure, which is horrible.
03:26:51 <davidhouse> Azmo, do investigate template haskell. it sounds like it might be able to do that
03:27:03 <Azmo> ok
03:47:47 <Pete_I> map toUpper "Hello World"
03:47:55 <Pete_I> is there something wrong with that?
03:48:22 <davidhouse> nope
03:48:30 <davidhouse> > map toUpper "Hello World"
03:48:31 <lambdabot>  "HELLO WORLD"
03:48:39 <Pete_I> hmm, WinHugs says toUpper is an undefined variable.
03:48:47 <davidhouse> brx, import Data.Char
03:48:57 <davidhouse> oops, forget the "brx"
03:49:43 <Pete_I> thanks much. that fixed it
03:50:46 <Daveman> Hi Pete_I :)
03:55:38 <Pete_I> hi daveman
03:55:52 <Daveman> Hi :)
03:56:58 <Pete_I> haskell seems quite fast.
03:57:02 <Pete_I> :)
03:58:18 <Pete_I> is there a limit to it's accuracy with numbers?
03:58:30 <Pete_I> large numbers i mean.
03:58:57 <davidhouse> not with Integer
03:59:13 <davidhouse> Int is somewhere between 28- and 32-bit.
03:59:18 <davidhouse> (it's 31-bit on GHC)
03:59:39 <davidhouse> but Integer is arbitrary precision
04:00:08 <davidhouse> > maxBound (5 :: Int)
04:00:09 <lambdabot>  add an instance declaration for (Bounded (Int -> a))
04:00:09 <lambdabot>   In the definition o...
04:00:16 <davidhouse> err
04:00:19 <davidhouse> @type maxBound
04:00:20 <lambdabot> forall a. (Bounded a) => a
04:00:32 <davidhouse> > maxBound :: Int
04:00:33 <lambdabot>  2147483647
04:00:35 <davidhouse> :)
04:01:00 <davidhouse> > maxBound :: Int + 1
04:01:00 <lambdabot>  Parse error
04:01:05 <davidhouse> > (maxBound :: Int) + 1
04:01:06 <lambdabot>  -2147483648
04:01:17 <Pete_I> wierd.
04:01:23 <davidhouse> > (fromIntegral (maxBound :: Int) :: Integer) + 1
04:01:24 <lambdabot>  2147483648
04:01:30 <davidhouse> Pete_I: it wraps round
04:01:41 <Pete_I> yeah, like in ASM
04:01:56 <Pete_I> FF wraps to 00
04:02:14 <Pete_I> :)
04:13:14 <davidhouse> now THIS is a find! http://web.engr.oregonstate.edu/~rende/wp/2006/04/24/emacs-with-xft-and-gtk/
04:13:45 <davidhouse> emacs with xft was possible before, but only if you got some patch from an arch repository (i'm still bearing the scars from when i did that on my old machine).
04:13:53 <davidhouse> that guy made it into a package! :))
04:15:17 <Dark-Side> AAHAHAHAH Have that Functional Programming exam!
04:15:40 <Dark-Side> you fail to make me fail!
04:15:58 <xerox> davidhouse - Some guy @freedesktop.org provides debs for emacs-xft too.
04:16:10 * Daveman waves to xerox
04:16:11 <xerox> Which are even handier :)
04:16:16 <xerox> Dave, read the query?
04:17:09 <xerox> AFK BBL
04:17:30 <Daveman> xerox, yeah :)
04:17:39 <Daveman> oh, gone to lunch now? :P
04:41:13 <yip> what is Data.Generics?
04:42:29 <integral> one library for generic programming
04:42:46 <integral> ie writing functions that examine the "structure" of a value/type
04:43:31 <integral> that one's part of _Scrap Your Boilerplate_ which has a website and papers.
04:43:50 <yip> hm...
04:44:15 * integral pops off to lunch &
04:44:54 <yip> i think i've read that page but i didn't really understand what it was supposed to be talking about
05:17:56 * vincenz does (lunch >>= cut grass)
05:22:20 <yip> the output of lunch is used as input for your grass cutting behvaiour? :o
05:22:45 <ibid> yip: it enriches the soil, i'd think? ;)
05:23:20 <apfelmus> ibid: but what if comes the other way out?  :) 
05:23:33 <Kasperle> maybe he meant ( lunch >> cut grass)?
05:24:23 <ibid> apfelmus: likely to contain more nutrients, although also acids :)
05:54:25 <dsacode> Isn't there some package that provides operations on logical propositional expressions ? I'm interested in converting expression to DNF (disjunctive normal form)
06:03:02 <dons> dsacode: all the math libs are listed on haskell.org under the "Libraries and tools" link
06:03:43 <apfelmus> dsacode: it seems not. but i guess you could steal from the various theorem provers http://haskell.org/haskellwiki/Libraries_and_tools/Theorem_provers 
06:04:12 <mauke> hmm, (lunch =<< cut) grass
06:04:16 <dons> did you look under 'mathematics' ?
06:08:14 <davidhouse> @instances Monad
06:08:15 <lambdabot> [], ArrowMonad a, WriterT w m, Writer w, ReaderT r m, Reader r, StateT s m, State s, RWST r w s m, RWS r w s, ErrorT e m, Either e, ContT r m, Cont r, Maybe, ST s, IO
06:08:23 <davidhouse> dons, get my latest patch? (sorting)
06:08:34 <xerox> Sorting by?
06:08:50 <davidhouse> alphabetification
06:48:40 <wamty> is it posible to build haskell compiler without haskell installed, gcc only?
06:48:57 <davidhouse> @google building guide site:haskell.org/ghc
06:48:59 <lambdabot> http://www.haskell.org/ghc/docs/4.08.2/building/building-guide.html
06:49:16 <davidhouse> wamty, GHC can bootstrap itself. which OS/arch are you on?
06:49:28 <wamty> Linux
06:49:34 <davidhouse> arch?
06:49:55 <davidhouse> and which linux/
06:50:06 <davidhouse> it's _definitely_ easier to install a binary :)
06:50:44 <wamty> i686
06:50:58 <mauke> isn't there a binary package for your distribution?
06:51:59 <dsacode_> Is it some good way to find tuples (a,b,c,d), so a^2 + b^2 == c^2 + d^2, 1 <= a < b <= c < d <= n, and GCD (a b c d) == 1 ?
06:52:14 <dsacode_> it's mathematical problem actually
06:52:27 <wamty> so?
06:52:30 <dsacode_> may be some solved something similar
06:53:06 <dsacode_> so == that :)
06:53:15 <davidhouse> dsacode_: what's n?
06:53:55 <dsacode_> davidhouse: some given natural constant
06:54:34 <ADEpt> dsacode_: solutions n = [ (a,b,c,d) | a^2 + b^2 == c^2 + d^2, a<-[0..n], b<-[a+1..n], c<-[b..n], d<-[c+1..n] ]
06:55:01 <ADEpt> dsacode_: it's very uneffective, time-consuming and dirty
06:55:03 <davidhouse> ADEpt: it's the four-parameter GCD i'm not sure aobut
06:55:09 <ADEpt> dsacode_: but neatly looking :)
06:55:12 <davidhouse> but a list-comp sieve would work
06:55:15 <ADEpt> davidhouse: ah.missed that.
06:55:19 <dsacode_> dsacode_: yeah, i had same.. and yes, it's very uneffective
06:55:35 <davidhouse> dsacode_: feeling recursive?
06:55:37 <dsacode_> ADEpt, i mean :)
06:55:40 <dsacode_> hehe :)
06:55:49 <dsacode_> davidhouse: what's that list-comp sieve?
06:56:03 <davidhouse> a list comprehension, which acts a sieve
06:56:21 <dsacode_> davidhouse: hmm.. can you give some reference or example?
06:56:22 <davidhouse> a sieve is something that basically takes all numbers and sieves out the ones that fit
06:56:36 <davidhouse> what ADEpt described is what i was refering to.
07:17:32 <davidhouse> is there a darcs-mode for emacs?
07:17:35 <davidhouse> @google darcs-mode
07:17:37 <lambdabot> http://www.abridgegame.org/pipermail/darcs-users/2004-July/002523.html
07:20:13 <ADEpt> Malcolm Wallace does not frequent irc, right?
07:21:45 <Igloo> I think I would say he occasions it
07:22:27 <ADEpt> and how is he known on irc?
07:22:39 <Igloo> malcolm or nhc98
07:39:58 <petekaz> @seen dons
07:39:59 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 35 minutes and 42 seconds ago.
08:01:26 <petekaz> Re: a comment made by Joel Reymont on the mailing list, "fighting laziness (and thus high memory usage)", is this really a struggle?  My impression, based on a previous post of reymont's, is that he doesn't understand how laziness works.  Up until recently (and perhaps still as it wasn't clear he "got" it), he was purposely writing tail-recursive functions.
08:02:19 <petekaz> So what he thought was optimized, he was just queuing up thunks to be evaluated at a later time.
08:02:43 <petekaz> And thus his constant comments about fighting high memory usage.
08:03:10 <SamB_XP> interesting!
08:03:49 <SamB_XP> and he never smashed the stack?
08:04:39 <petekaz> I don't know, but, judging from his comments, I just suspect he doesn't get it yet.  Or, and this is my question, is laziness something haskellers have to "fight" constantly.
08:04:47 <petekaz> I suspect its the former.
08:06:29 <SamB_XP> well, sometimes we have a choice of (a) fighting it or (b) getting rid of it with a well-placed strict datastructure
08:08:29 <SamB_XP> or (c) not worrying about the high memory usage from all the thunks
08:08:42 <petekaz> Right, but do you actually "fight" it often?  Don't you use it to your advantage more often than fighting it?
08:08:56 <SamB_XP> well, yes ;-)
08:09:44 <SamB_XP> assuming you don't take too long fighting the same lot of laziness
08:12:38 <Saulzar> I've really only had problems with memory use with yampa where there seem to be a number of fairly subtle ways to screw up, otherwise profiling + simple tricks and it's not too much bother.
08:15:16 <SamB> the new lazy bytestrings are a great example of the usefulness of lazyness ;-)
08:17:27 <SamB> hmm, anyone know how to get indented XML out of HXT?
08:20:24 <pitkali> hi there
08:20:46 <pitkali> is anybody aware of ghc development status?
08:21:17 <Lemmih> GHC is being actively developed.
08:21:39 <pitkali> I know
08:21:43 <pitkali> I mean something else
08:22:12 <pitkali> I'm wondering if utf8 source file reading is considered complete
08:22:19 <pitkali> in repository of course
08:22:33 <pitkali> because released stable versions don't handle utf8 input
08:23:09 <pitkali> I'm just hesitating to file a bug about it..
08:23:18 <Lemmih> Reading utf8 in ghci is missing so I guess it's not really complete.
08:23:45 <Lemmih> pitkali: ghc-6.5 does allow unicode in source files.
08:23:59 <pitkali> so it seems
08:24:02 <pitkali> I just compiled it
08:24:05 <pitkali> but!
08:24:09 <pitkali> it prints it wrong
08:24:20 <pitkali> I have file encoded in UTF-8 according to what file utility claims
08:24:31 <pitkali> which just prints a simple string in IO monad
08:24:37 <pitkali> it is read, no error reported
08:24:55 <pitkali> and then on output I get garbage in place of national characters...
08:25:04 <pitkali> only ASCII part gets out correctly
08:25:34 <Lemmih> Right, the standard IO system doesn't understand unicode.
08:25:49 <pitkali> aaa
08:25:53 <ihope> AHA!
08:26:06 <pitkali> that would, obviously explain everything
08:26:08 <ihope> I was connecting to brown.freenode.net on the wrong port!
08:26:44 <pitkali> So - any hints on how to print unicode string to a terminal?
08:27:03 <davidhouse> pitkali: putStrLn?
08:27:11 <pitkali> no
08:27:16 <pitkali> it doesn;t work
08:27:42 <pitkali> Lemmih just said standard IO doesn't handle it and he seems to be right
08:27:43 <lisppaste2> davidhouse pasted "does for me" at http://paste.lisp.org/display/20798
08:27:45 <Lemmih> pitkali: http://repetae.net/john/repos/jhc/UTF8.hs
08:28:52 <davidhouse> umlauts etc aren't ASCII, are they/
08:29:31 <ihope> Well, it seems telnet's my problem...
08:29:48 <pitkali> not ASCII
08:29:50 <pitkali> but latin1
08:29:54 <davidhouse> ah.
08:29:55 <pitkali> so it will be handled I guess
08:30:01 <davidhouse> this isn't my area of expertise
08:31:38 <pitkali> Lemmih: it works indeed, thanks
08:37:03 <pitkali> btw: anyone knows if standard IO is planned to be unicode capable?
08:39:35 <Lemmih> Different encoding options will most likely be provided once/if we move to streams.
08:42:31 <pitkali> that's more than necessary
08:42:47 <pitkali> after all I understand that internally the strings are encoded in unicode 
08:43:03 <davidhouse> yeah, Strings are unicode-capable.
08:43:08 <davidhouse> it's just the IO that isn't
08:43:09 <pitkali> it's odd not to be able to print them directly, isn't it?
08:43:11 <ADEpt> pitkali: yep. that's why you can do with formUTF8/toUTF8 for now :)
08:45:03 <pitkali> ah well - it's still better than preprocessing haskell source and replacing "unwanted" characters with numerical codes ;)
08:45:27 <pitkali> thanks for help, I'm leaving
08:57:38 <perspectival> is there a non-top-level where-type keyword that has scope over all guards?
08:58:09 <davidhouse> what level are the guards?
08:58:25 <perspectival> top-level
08:58:53 <davidhouse> hmm, haven't come across one
08:58:58 <davidhouse> you could use a let
08:59:22 <perspectival> it has scope over all guards? that would be useful...
08:59:27 <davidhouse> ... i think.
08:59:30 <davidhouse> don't quote me on that
08:59:31 <davidhouse> :)
08:59:32 <perspectival> ok, thx ;-)
08:59:34 <davidhouse> try the report
09:00:11 <Saulzar> Er, I thought where already scoped over the guards
09:00:34 * davidhouse can't remember these kind of things
09:01:18 <perspectival> so it appears it does, though I could swear I was getting errors about that earlier...
09:01:38 <Lemmih> > let x | False = n | True = n where n = () in x
09:01:39 <lambdabot>  ()
09:01:54 <perspectival> right, it works now...
09:02:38 <perspectival> maybe I was seeing an error not for the guarded equations, but for pattern-matching equations
09:03:07 <perspectival> and if i'm not wrong, there is no non-top-level construct that has scope over all pattern-matching equations (as well as guarded ones)
09:03:30 <petekaz> Anyone familiar with the lambdabot source?  In each plugin, near the top is a line of the form: PLUGIN Name
09:03:45 <petekaz> Where Name is the name of the plugin.  What kind of haskell statement is that?
09:03:52 <davidhouse> petekaz: not a normal one
09:03:57 <mauke> petekaz: scripts/dsl.hs
09:04:04 <davidhouse> i assume lambdabot/hs-plugins runs some kind of preprocessor
09:04:07 <Saulzar> Could be a cpp macro
09:04:08 <petekaz> is that preprocessing that is done?
09:04:16 <petekaz> ok. thanks.
09:04:36 <Saulzar> Look for a #define PLUGIN somewhere
09:04:50 <mauke> it's handled by ./dsl, not cpp
09:05:01 <Saulzar> Ah
09:05:38 <Saulzar> Hmm, source I have is out of date, no PLUGIN 
09:07:10 <petekaz> Can anyone tell me why I can't compile lambdabot? http://paste.lisp.org/display/20795
09:08:01 <petekaz> The first error is Data.ByteString.Base reference, but I have fps installed already.
09:08:15 <mauke> apparently not
09:08:33 <davidhouse> did you forget to run ./Setup.hs install?
09:08:38 <petekaz> ghc-pkg list tells me otherwise.
09:08:39 <davidhouse> or did you forget to run it as root/
09:08:45 <Saulzar> Maybe it's using a very new version
09:09:12 <petekaz> I'm a total newbie when it comes to haskell, so its got to be stupid user error.
09:09:40 <petekaz> I can compile code that uses fps, simple test program like 'wc'.
09:09:50 <mauke> weird, I had the same problem and it disappeared after installing fps
09:09:56 <petekaz> I just have to use --make option to ghc.  So that means I have fps working right?
09:10:06 <mauke> (I think it was the same)
09:10:19 <petekaz> mauke: so install fps again?
09:10:30 <mauke> no idea
09:11:07 <davidhouse> petekaz: what version did you install?
09:11:29 <petekaz> I've got 3 versions .4 .5 (are hidden), and then .7
09:12:31 <davidhouse> hmm
09:12:35 <davidhouse> i can compile it fine with 0.7
09:12:49 <petekaz> how do I remove cabal install packages?
09:13:01 <petekaz> I'll blow them all away, then install them again.
09:14:05 <davidhouse> @help eval
09:14:05 <lambdabot> eval. Do nothing (perversely)
09:15:02 <mauke> @. eval yow
09:16:59 <davidhouse> it literally does nothing.
09:34:15 <vincenz> davidhouse: you use emacs?
09:34:21 <davidhouse> vincenz: yep
09:34:27 <vincenz> davidhouse: any special plugins?
09:34:34 <davidhouse> plenty
09:34:43 <vincenz> blegh
09:34:51 <davidhouse> haskell-mode
09:34:54 <davidhouse> setnu-mode
09:34:59 <vincenz> senu?
09:35:00 <vincenz> setnu?
09:35:09 <davidhouse> cua-mode (already in CVS emacs, you won't need to download that seperately)
09:35:12 <davidhouse> line numbering
09:35:19 <vincenz> I just want to try emacs but I want a nicely setup system
09:35:37 <vincenz> tell you what
09:35:39 <xerox> vincenz - Do you know its basics?
09:35:41 <davidhouse> install haskell-mode
09:35:41 <vincenz> can I ask you for help later on?
09:35:55 <vincenz> davidhouse: I first wanna upgrade to dapper
09:35:55 <davidhouse> how much later on?
09:36:00 <vincenz> xerox: tried it once, but nope
09:36:02 <vincenz> davidhouse: few hours?
09:36:07 <davidhouse> hmm, perhaps
09:36:10 <vincenz> @localtime davidhouse 
09:36:11 <lambdabot> Local time for davidhouse is Sat Jun  3 17:35:51 2006
09:36:12 <davidhouse> if i'm online, ping me
09:36:17 <vincenz> sure, thanks
09:36:25 <xerox> vincenz - Then, my suggestion is to fire it up as it is, and press C-h t. `C-*' means ``hold down the control key while pressing the * key.''
09:36:43 <vincenz> xerox: what pissed me off then is you have all these functions... and you don't have a nice oversight... I know vim inside out, I barely know any of the elisp functions in emacs :(
09:37:02 <vincenz> xerox: I know the C-* stuff :)
09:37:04 <vincenz> and meta is alt
09:37:20 <xerox> That is a really good starting point, you'll be soon able to move and do editing.
09:37:30 <davidhouse> i have a tip-of-the-day script that shows me a different function every day
09:37:35 <vincenz> :)
09:37:43 <davidhouse> a few years and i will have covered them all!
09:37:45 <vincenz> xerox: it's gettnig past typing simple things
09:37:51 <vincenz> xerox: to the proficiency with which I do vim work
09:38:13 <vincenz> select here, copy there, lowercase, find all names and replace with this, but ensure it's full keywords and not partial words
09:38:21 <vincenz> stuffl ike that
09:38:29 <vincenz> record a macro
09:38:32 <vincenz> apply to every line
09:39:48 <xerox> vincenz - That will shortly come in the tutorial.
09:41:11 <xerox> Also, peek at:
09:41:16 <xerox> @google EmacsWiki
09:41:18 <lambdabot> http://www.emacswiki.org/cgi-bin/wiki
09:41:24 <xerox> It has *everything*
09:43:10 <Maddas> vincenz: I use and like Viper mode
09:44:46 <petekaz> mauke: after I installed fps again, compiling lambdabot worked.
09:44:50 <mauke> yay
09:45:16 <petekaz> thanks.
09:45:19 <vincenz> thx
09:45:28 <vincenz> xerox: what about block select and block insert
09:49:22 <davidhouse> vincenz: the rectangle functions
09:49:42 <davidhouse> set the mark (C-SPC) somewhere, then move the point
09:50:07 <davidhouse> then the family of functions accessed through C-x r something will act on the rectangular region between mark and point
09:50:14 <davidhouse> anway, /me <- food
09:50:48 <ADEpt> vincenz: C-x r k is the most useful (kill-rectangle) :)
09:52:07 <Maddas> Meh, there are always so many more potentially useful commands to learn :-)
10:09:15 * SamB wonders why his GHCi has to swap so much just to load an 8 or 9 line module containing nothing but imports
10:14:29 <ADEpt> question: how can I specify default email address that others will use while "darcs send"ing me patches?
10:26:56 * SamB wonders what the arrow syntax is
10:27:19 <SamB> ADEpt: lets see...
10:27:28 <davidhouse> ADEpt: i like C-x r t, replace-rectangle. useful for inserting characters are the beginning of lines, etc
10:27:33 <davidhouse> SamB: haskell.org/arrows
10:28:21 <ADEpt> SamB: it's _darcs/prefs/email, i found out already
10:28:26 <davidhouse> anyone use darcs with emacs?
10:28:54 <ADEpt> davidhouse: i use darcs and emacs, but no darcs-mode :(
10:29:11 <davidhouse> there are a few out there and was wondering if anyone has any preferences
10:29:16 <mauke> @pl \(s, c) -> tword s >> return c
10:29:16 <lambdabot> uncurry ((. return) . (>>) . tword)
10:32:08 <davidhouse> i think darcsum looks like a good optoin
10:32:09 <davidhouse> *option
10:33:33 <evergreen> I like vc-darcs for emacs integration.
10:34:23 <davidhouse> hmm
10:34:35 <evergreen> The vc family keeps my keybindings the same for darcs, svn and cvs which is handy because I work on projects that use all three.
10:34:37 <davidhouse> evergreen: can you record patches containing changes from more than one file with that?
10:35:20 <evergreen> davidhouse: Not that I know of.  For multi-file patches, I use the shell (eshell, of course).
10:36:45 <xerox> Hi monochrom.
10:36:52 <monochrom> Hi
10:37:09 <xerox> How's math? (:
10:37:35 <monochrom> math is happy today :)
11:14:43 <Skymarshal> How can I merge two strings in Haskell to a new string?
11:15:05 <int-e> > "hello, " ++ "world"
11:15:06 <apfelmus> > "str" ++ "ing"
11:15:06 <lambdabot>  "string"
11:15:07 <lambdabot>  "hello, world"
11:15:35 <apfelmus> > [1,2,3] ++ [4,5,6]
11:15:36 <lambdabot>  [1,2,3,4,5,6]
11:15:41 <apfelmus> @type ++
11:15:42 <lambdabot> parse error on input `++'
11:15:49 <apfelmus> @type (++)
11:15:50 <lambdabot> forall a. [a] -> [a] -> [a]
11:16:00 <Skymarshal> apfelmus: Thanks!
11:24:53 <SamB> @pl (x >>> pure y)
11:24:53 <lambdabot> x >>> pure y
11:24:58 <SamB> @pl (x >>> arr y)
11:24:58 <lambdabot> x >>> arr y
11:28:42 <davidhouse> @pl \x y -> x >>> pure y -- you have to use lambdas, SamB
11:28:43 <lambdabot> (. pure) . (>>>)
11:29:09 <SamB> not always, do you?
11:29:33 <MarcWebe1> What does this message mean? <no location info>: can't find file: fontinfo.hs
11:29:35 <SamB> @pl concat . map f 
11:29:35 <lambdabot> (f =<<)
11:29:40 <SamB> see!
11:29:43 <MarcWebe1> its from ghc
11:30:10 <SamB> I didn't want it to consider x and y as points, I just wanted to see if there was shorthand for that ;-)
11:30:12 <Saulzar> They're two different things, as well
11:30:47 <Saulzar> @pl f x y = x >>> pure y
11:30:47 <lambdabot> f = (. pure) . (>>>)
11:30:52 <davidhouse> SamB: if you don't use lambdas, you're already using points-free style, so it won't change anything you put into it
11:30:53 <SamB> MarcWebe1: well, it means that the error happened no place in particular, and that it coundn't find that file
11:31:16 <SamB> davidhouse: no, it also does simplification of already points-free input!
11:31:27 <ADEpt> MarcWebe1: probably means that code was supplied from stdin. Or ghc couldn't do such tricks?
11:32:19 <davidhouse> SamB, such as?
11:32:40 <SamB> @pl map f . map g
11:32:40 <lambdabot> map (f . g)
11:32:52 <davidhouse> mmm... fun.
11:32:55 <MarcWeber> Nshag: SamB This was the commandline from vim quickfix cycle.. !ghc --make -package gtk -package WashNGo -package parsec -package mwutil -package hsp -fglasgow-ex
11:33:01 <MarcWeber> ts -o fontinfo fontinfo.hs 2>&1| tee /tmp/v324301/34
11:33:02 <davidhouse> so it uses RULES?
11:33:04 <SamB> @pl concat . map f
11:33:04 <lambdabot> (f =<<)
11:33:13 <MarcWeber> But it's probably a vim problem.
11:33:16 <SamB> davidhouse: no
11:33:26 <Saulzar> Hmm, must have some knowledge about map in particular to do that
11:33:29 <davidhouse> it just knows a limited set of rewrites?
11:33:33 <xerox> @pl (concat .) . map
11:33:34 <lambdabot> (=<<)
11:33:37 <SamB> davidhouse: yes
11:33:42 <davidhouse> hmm
11:33:46 <xerox> @pl (concat .) . flip map
11:33:47 <lambdabot> (join .) . flip map
11:33:48 <davidhouse> it should use RULES :)
11:33:50 <xerox> Woops.
11:34:02 <davidhouse> join = concat for lists, xerox
11:34:04 <SamB> well, if it actually knew types, maybe it could ;-)
11:34:10 <davidhouse> > join [[1..4], [5..10]]
11:34:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:34:17 <Saulzar> @pl return x >>= return . id
11:34:17 <lambdabot> return x
11:35:32 <xerox> @pl (join .) . flip fmap
11:35:33 <lambdabot> (join .) . flip fmap
11:35:38 <xerox> @type (join .) . flip fmap
11:35:40 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
11:35:47 <xerox> That is (>>=).
11:36:22 <Saulzar> @pl (join .) . flip liftM
11:36:23 <lambdabot> (join .) . flip fmap
11:36:38 <Saulzar> Hmm, it has fmap = liftM
11:36:54 <xerox> That's right.
11:37:09 <Saulzar> Though not strictly nesescary :)
11:38:13 <xerox> The current design tastes bad.
11:39:48 <Saulzar> Funny, I pasted two sides of a monad law (m >>= f) >>= g  ---->  lambdabot m >>= f >>= g, and m >>= (\x -> f x >>= g)  it choses the other way around  g =<< f =<< m 
11:41:39 <MarcWeber> If the compiler says Chasing modules from: fontinfo.hs
11:41:49 <MarcWeber> does this mean it did find fontinfo.hs?
11:42:23 <ADEpt> yes
11:54:21 <vincenz> re
12:10:31 <ADEpt> vincenz: re.
12:10:47 <ADEpt> vincenz: haven't you tried to do "cow is an animal?" in haskell?
12:16:20 <vincenz> erm not yet no, why?
12:19:09 <vincenz> I have to get my scoper working :(
12:19:15 <vincenz> it's the crappiest part of writing a compiler
12:19:34 <ADEpt> vincenz: just curious. Since you shown me that link, I am going in circles around it. But since I am not type hacker like oleg, I stumble upon silly obstacles all the time.
12:19:59 <Saulzar> Hmm, OOHaskell stuff?
12:20:08 * vincenz is going nuts with doing a module syste
12:20:14 <vincenz> Saulzar: on the contrary
12:20:58 <Saulzar> Some of those name lookup systems you pasted looked pretty wacky.
12:21:58 <Saulzar> What was the link? Missed the context of the discussion..
12:23:18 <ADEpt> Saulzar: http://merd.sourceforge.net/pixel/language-study/various/is-a-cow-an-animal/
12:23:34 <ADEpt> Saulzar: be sure to also read "where the basic idea come from?"
12:23:43 <Saulzar> Ah, existential cows?
12:24:25 <Saulzar> Ah - something different, thought I'd seen it before
12:25:40 <ADEpt> Saulzar: i'm trying to do this with dependent types. Seems like they are able to solve the problem
12:29:02 * vincenz could use some help with designing the name lookup and module system of his language
12:32:49 <Saulzar> Hmm, even "meat can be eaten only once" ?
12:33:09 <ADEpt> Saulzar: that's the trickiest part
12:33:36 <ADEpt> Saulzar: i'm thinking about posting this to haskell m.l. in hope that oleg will pick this up :)
12:33:58 <Saulzar> I'm guessing none of the solutions achieve this one, so far?
12:35:18 <vincenz> grr
12:35:19 <vincenz> right
12:35:29 <vincenz> time to get frustrated at my compiler again
12:35:53 <ADEpt> Saulzar: right
12:40:13 <Saulzar> Just write the program in TH and be done with it :)
12:42:40 <ADEpt> Saulzar: hmmm... how will this help?
12:43:29 <Saulzar> Maybe you can do something like HList and encode your whole food collection in one with a "food" monad. I'm sure that wouldn't work since the type would have to change at each use. Somehow I can't comprehend how to start.
12:44:04 <ADEpt> Saulzar: look at existing code?
12:44:31 <ADEpt> Saulzar: there are 4 existing implementations in haskell?
12:44:39 <Saulzar> I can see how you could easily do such a thing at runtime
12:44:57 <Saulzar> (But I didn't think any of them approached the meat problem, which I was just thinking of)
12:45:30 <Rolling> > [1,2]
12:45:31 <lambdabot>  [1,2]
12:46:27 <Pete_I> what's the division sign in haskell?
12:46:49 <monochrom> > 5 `div` 3
12:46:49 <lambdabot>  1
12:46:51 <koala_man> it looks like a fuzzy bird with a hat
12:46:54 <monochrom> > 5 / 3
12:46:55 <lambdabot>  1.6666666666666667
12:48:12 <Pete_I> hmm....
12:48:40 <Pete_I> why is it always returned as a floating point number?
12:49:02 <monochrom> Because if you want an integer there is `div`
12:49:04 <Saulzar> div is integer types, / is floating point
12:49:20 <Saulzar> @type div
12:49:20 <lambdabot> forall a. (Integral a) => a -> a -> a
12:49:30 <Saulzar> @type (/)
12:49:31 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:49:38 <monochrom> And because it is the right thing to do.
12:49:38 <bringert> dons, dcoutts: any of you guys know how to install fps on current GHC snapshots? It conflicts with the Data.ByteString modules in the base package.
12:49:58 <dcoutts> bringert, build ghc-6.5 without those modules
12:50:09 <dcoutts> bringert, or delete them afterwards (hard)
12:51:08 <bringert> dcoutts: ok, thanks. I'm using a snapshot binary for OS X/i386, I'll try the second path.
12:51:22 <monochrom> So you want the result to be sometimes Int and sometimes Double depending on divisibility?
12:51:29 <bringert> doesn't ghc-6.5 use Data.ByteString though?
12:51:43 <dcoutts> bringert, no, it just inludes it in the base package
12:52:15 <dcoutts> bringert, that requires deleting all the right members from the libHSbase.a file and deleting the .hi files and re-registering the base package with those modules removed from the config
12:52:24 <bringert> ok. Does this mean that in the future, people won't really be able to upgrade their Data.ByteString? Wouldn't it be better t have it in a separate package?
12:53:00 <bringert> or is fps meant to be stable once ghc hits 6.6?
12:53:05 <dcoutts> bringert, deleting them from libHSbase.a is tricky because due to split-objs, there are hundeds of ByteString_xx.o & Char8_xx.o members
12:53:23 <monochrom> No problem!  (///) :: Int -> Int -> Either Int Double; x /// y = if x `mod` y == 0 then Left (x `div` y) else Right (fromIntegral x / fromIntegral y)
12:53:23 <dcoutts> bringert, it is indeed meant to be stable once ghc hits 6.6
12:54:17 <bringert> hmm, I'll try to build my own binary dist first, that'll be fun
12:58:38 <bringert> anyone: how long does it take to build GHC on your machine?
13:01:00 <Lemmih> stage[12] + the libraries?
13:04:39 <dcoutts> bringert, 1 hour, 35 minutes and 57 seconds (apparently)
13:05:47 <bringert> dcoutts: is that with the quick build settings from http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/ghc/HACKING or the defaults
13:06:03 <bringert> and what kind of machine?
13:06:19 <bringert> I just want to see how my macbook compares :-)
13:06:25 <dcoutts> bringert, defaults, 1.8GHz amd64
13:07:06 <dcoutts> well actually it's not exactly defaults, it's using the gentoo ghc-darcs ebuild
13:07:13 <bringert> ok, about the same as my work desktop, which seems to be comparable to the macbook in my other compilation tests
13:08:35 <khatar> hi all 
13:08:40 <bringert> dammit, I forgot to remove fps
13:08:45 <bringert> that was the whole reason
13:09:01 <bringert> anyone know how clean I have to make?
13:22:11 <bringert> does anyone know if you can build ghc with parallell make?
13:23:03 <bringert> guess it does: http://cvs.haskell.org/trac/ghc/ticket/600
13:23:13 <Skymarshal> How can I count the number of items in a list?
13:23:22 <Lemmih> > length [1,2,3]
13:23:23 <lambdabot>  3
13:23:51 <Skymarshal> Lemmih: That was fare to easy. ;-) Thanks!
13:28:41 <integral> @type mapM
13:28:42 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
13:28:55 <integral> it's a combinator over a monad, and some other types
13:32:56 <bringert> damm, it's maxing out both cores. make -j rocks
13:35:02 <bringert> huh, make[1]: execvp: rm: Cannot allocate memory
14:01:47 <waern_> bringert, how's it going?
14:03:01 * SamB wonders how to compare XML trees in a useful way
14:03:26 <davidhouse> (a -> b) -> [a] -> [b]
14:03:27 <davidhouse> (a -> a) -> [a] -> [a]
14:03:30 <davidhouse> err
14:03:31 <davidhouse> oops
14:04:19 <davidhouse> SamB: what kind of comparison do you need?
14:07:58 <SamB> something resembling diff would be nice...
14:08:23 <mathewm> how can I add code to handle the Nothing case of this: '                Just ci <- HashTable.lookup inInfos name
14:08:32 <mathewm> in a do
14:08:48 <Cale> x <- HashTable.lookup inInfos name
14:08:49 <ADEpt> SamB: i have something called "xmldiff" in my debian
14:08:51 <Cale> case x of
14:08:54 <Cale>    Nothing -> ...
14:09:00 <Cale>    Just ci -> ...
14:09:01 <davidhouse> SamB, how about actually diffing them? :)
14:09:18 <mathewm> hmm I tried that and got complaints 'Parse error in pattern'
14:09:26 <SamB> davidhouse: not a bad idea, I suppose
14:09:33 <Cale> mathewm: paste the code?
14:09:41 <SamB> but diff can only accept one standard input
14:09:43 <mathewm> @where paste
14:09:43 <lambdabot> http://paste.lisp.org/new/haskell
14:10:42 <lisppaste2> mathewm pasted "HOC -> 6.4.2" at http://paste.lisp.org/display/20809
14:11:54 <Cale> where does the error occur in that?
14:11:59 <davidhouse> mathewm: what's the type of lookup?
14:12:18 <mathewm> Maybe ?
14:12:24 <davidhouse> if it's a maybe you need to do "let doneInfo = ..."
14:12:55 <Cale> lookup :: HashTable key val -> key -> IO (Maybe val)
14:13:33 <lisppaste2> davidhouse annotated #20809 with "try this" at http://paste.lisp.org/display/20809#1
14:13:45 <davidhouse> oh, ignore that then.
14:14:10 <mathewm> so why the 'let' for a Maybe, but not an IO (Maybe x ) ?
14:14:47 <davidhouse> <- runs an action and gets the result of that action
14:15:10 <davidhouse> so when you do doneInfo <- ..., your running that action and binding doneInfo to the result of that action
14:15:11 <lisppaste2> mathewm annotated #20809 with "code with Nothing case added" at http://paste.lisp.org/display/20809#2
14:15:19 <davidhouse> so doneInfo :: Maybe a
14:15:41 <mathewm> the last annotation doesn't compile, error at the first letter of 'case'
14:15:50 <Cale> mathewm: yeah, that's definitely a syntax error
14:16:14 <Cale> what you put on the right side of the Just ci case is not an expression
14:16:31 <Cale> Just ci -> do (mbSuper, protocols, recheck) <- cleanSuper ci
14:16:43 <mathewm> Hmm OK
14:16:44 <Cale>               if recheck
14:16:57 <Cale> then put the rest of the do-block at that level
14:17:45 <mathewm> Cale: 'if recheck' and down needs to move over then?
14:17:53 <Cale> yeah
14:18:08 <Cale> and you have to add a 'do' there
14:21:19 <mathewm> Cale: thanks  - got it now
14:21:53 <lisppaste2> samx pasted "error" at http://paste.lisp.org/display/20810
14:22:21 <sam_> could someone take a look at that, and tell why it doesn't compile. Pretty please :-)
14:22:38 <Cale> indenting
14:22:48 <Cale> put the 'then' and the 'else' at the same level
14:22:57 <sam_> oh
14:23:20 <sam_> though it needed to be on the if level.. thank you :-)
14:23:33 <psi> that happens often, it seems
14:23:36 <Cale> It's common to lay it out like
14:23:39 <Cale> if foo
14:23:40 <vincenz> dumteedum
14:23:42 <Cale>    then bar
14:23:46 <Cale>    else quux
14:25:30 <yip> @karma jip
14:25:31 <lambdabot> jip has a karma of 4
14:25:36 <yip> @karma yip 
14:25:37 <lambdabot> You have a karma of 0
14:25:45 <yip> how can i transfer jip's karma over to me?
14:26:24 <davidhouse> @karma+ jip
14:26:24 <lambdabot> jip's karma raised to 5.
14:26:27 <davidhouse> @karma+ yip
14:26:28 <lambdabot> yip's karma raised to 1.
14:26:29 <davidhouse> @karma+ yip
14:26:29 <lambdabot> yip's karma raised to 2.
14:26:30 <davidhouse> @karma+ yip
14:26:30 <lambdabot> yip's karma raised to 3.
14:26:31 <davidhouse> @karma+ yip
14:26:31 <lambdabot> yip's karma raised to 4.
14:26:34 <davidhouse> there :)
14:26:51 <yip> cool thanks =]
14:27:10 <yip> it actually should even be a bit more since i have like 3 other nicks each with a bit of karma
14:27:13 <davidhouse> yip, you could thank me with karma :)
14:27:23 <rindolf> davidhouse: do you have admin privileges?
14:27:32 <yip> rindolf: wtf are you doing here?
14:27:32 <davidhouse> rindolf: nope. why?
14:27:56 <rindolf> yip: lurking mostly.
14:28:09 <rindolf> davidhouse: so anyone can increase anyone else's karma indefinitely?
14:28:15 <davidhouse> right.
14:28:21 <yip> rindolf: it's me.... i thought you were a perl guy
14:28:21 <rindolf> davidhouse: I see.
14:28:22 <davidhouse> you just can't increase your own
14:28:31 <rindolf> yip: who's "me"?
14:28:48 <rindolf> yip: I also know Haskell.
14:29:22 <yip> rindolf: i'm one of the linux dudes i guess
14:29:32 <yip> rindolf: any meetings coming up at tau?
14:29:33 <davidhouse> had a nice chat in #emacs about monads earlier.
14:29:36 <davidhouse> that was slightly surreal
14:29:56 <rindolf> yip: none planned for the time being.
14:30:10 <rindolf> yip: would you like to give any?
14:30:16 <yip> rindolf: you mean like a lightning talk?
14:31:05 <rindolf> yip: or a longer one.
14:32:31 <yip> hm... well i could make a talk out of an article i'm writing, "the 2007 l33t desktop"
14:33:06 <yip> i show how to configure the wmii window manager, vim, xterm, bash prompt, and more
14:33:43 <yip> 2007 style
14:34:14 <mathewm> Since there are a couple perl-y folk on the line, why no Inline::Haskell?
14:35:49 <Pete_I> mathewm, probly 'cause nobody's written it yet
14:36:07 <mathewm> for lack of interest, you think?
14:36:41 <Pete_I> not likely.
14:36:47 <rindolf> mathewm: there is one for Pugs...
14:36:50 <Cale> Perl 6 allows inline Haskell
14:36:51 <Pete_I> they probly like parsing haskell with haskell
14:36:56 <cmarcelo> does GHC creates two different StablePtrs for the same data if I call newStablePtr twice? isnt the second call supposed to get me the same value as the first?
14:37:24 <davidhouse> @hoogle newStablePtr
14:37:24 <lambdabot> Foreign.StablePtr.newStablePtr :: a -> IO (StablePtr a)
14:37:34 <davidhouse> it's monadic, so no, it doesn't have to
14:37:55 <davidhouse> e.g. readFile "foo" doesn't always give the same results; it depends on the contents of foo
14:38:08 <davidhouse> but it's monadic, so that's okay
14:38:59 <Cale> Except that the point of StablePtrs might make you think that they would
14:39:16 <Cale> Though I don't think you actually get this guarantee...
14:41:18 <Cale> The only guarantee that you get is that deRefStablePtr will give you back the original value. The representation of the StablePtr itself is "meaningless", and probably isn't required to be unique.
14:42:09 <Cale> (I bet it's something like an integer key into a table of values on the Haskell heap.)
14:42:18 <cmarcelo> hmm.. right.. I'm working on a "BitSet a" (mapping a haskell value into a bit) on top of Judy, and was thinking about using data's StablePtr as index in the hash. but this isnt going to work then... =P
14:42:36 <SamB> Cale: well, table of StablePtr values
14:42:47 <SamB> Cale: but yes ;-)
14:43:15 <rindolf> yip: are you using WindowMaker?
14:43:34 <Cale> cmarcelo: perhaps http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
14:44:37 <cmarcelo> will take a look. tks.
14:45:59 <davidhouse> is the popularity of impure data structures mostly to do with their speed?
14:46:12 <Cale> yes
14:47:32 <SamB> it occurs to me that diff won't work too well on data with no line breaks
14:47:41 <davidhouse> heh.
14:47:47 <davidhouse> SamB: pretty print it first, then
14:47:49 <Cale> Though I usually find that O(log n) is a good enough replacement for O(1)
14:48:05 * SamB looks for pretty printer
14:48:23 <blackdog> SamB: sure it will. either the two lines are different or they're not. :)
14:48:53 <SamB> blackdog: yes, but I could do that with ==!
14:48:59 <blackdog> :) yep
14:49:17 <blackdog> i'm curious now... anyone know the complexity of the diff algorithm?
14:49:57 <SamB> is there some diff algorithm that I can use without writing data to temp files?
14:50:48 <blackdog> afaict, it's just treating each line as a unit, then trying to match the lines up... you could move the granularity down to the character level, but i'm betting it'd be insanely slow
14:50:54 <blackdog> do pipes count?
14:51:16 <SamB> well, I only know how to pipe *one* thing to diff
14:51:50 <blackdog> good point
14:52:04 <davidhouse> the limitations of the shell.
14:52:38 <SamB> @where diff
14:52:38 <lambdabot> I know nothing about diff.
14:52:46 <SamB> @google haskell diff
14:52:48 <lambdabot> http://www.haskell.org/hawiki/RecentChanges
14:53:07 <Cale> I think it's on the order of the product of the lengths of the files.
14:53:34 <SamB> that is certainly in line with my naive idea of how to do it ;-)
14:53:44 <cmarcelo> Cale: StableNames doesnt has defRefStableName operation, and sometimes name1 /= name2 but obj1 == obj2.. =(
14:53:59 <Cale> cmarcelo: yeah
14:54:05 <SamB> @google haskell "diff algorithm"
14:54:07 <lambdabot> http://citeseer.ist.psu.edu/context/1113682/264711
14:54:26 <Cale> Or possibly O(n*d), where n is the total length, and d the number of differences
14:55:49 <Cale> If you want to do the best possible job, I don't think you're going to do much better.
14:56:09 <blackdog> http://en.wikipedia.org/wiki/Longest-common_subsequence_problem
14:56:24 <blackdog> complexity is the product of the two lengths
14:57:30 <int-e> SamB: does it need to be portable? otherwise you can do something like bash does with <(cmd) --> execute command, writing to a pipe and pass /proc/self/fd/<fdnum> to the program as a file name.
14:57:51 <lisppaste2> sam_ pasted "error2" at http://paste.lisp.org/display/20811
14:58:02 <int-e> hmm, /dev/fd/<fdnum> is what it uses.
14:58:15 <sam_> error monads seem to be really kicking my behind.. what's wrong with the above?
14:58:59 <Cale> what error do you get?
14:59:19 <sam_> Couldn't match `IOError' against `MyError' ....
14:59:33 <Cale> ah, riht
14:59:36 <Cale> right*
14:59:39 <Cale> makes sense
14:59:48 <Cale> you're running test in the IO monad
14:59:59 <sam_> I am?
15:00:07 <Cale> main = do res <- test
15:00:20 <sam_> oh
15:08:26 <SamB> int-e: would that be easier than writing to temp files?
15:08:35 <sam_> cale: that fixed it. thanks again :-)
15:09:13 <int-e> SamB: I don't know. I've not looked at how/if Haskell deals with pipes and stuff like that.
15:11:44 <reppie> hard rock halleluja
15:15:41 <SamB> @hoogle IO (Handle, Handle)
15:15:41 <lambdabot> No matches, try a more general search
15:16:01 <SamB> @hoogle IO (a, b)
15:16:01 <lambdabot> No matches, try a more general search
15:16:05 <SamB> @hoogle IO (a, b, c)
15:16:06 <lambdabot> No matches, try a more general search
15:16:10 <SamB> @hoogle IO (a, b, c, d)
15:16:10 <lambdabot> No matches, try a more general search
15:16:14 <davidhouse> SamB: what do you want?
15:16:22 <monochrom> Time to ask a human.
15:16:24 <davidhouse> @docs System.Process
15:16:24 <lambdabot> dummy module failed: /tmp/ghc22909.hspp:55:2-32: Non-exhaustive patterns in function process_
15:16:31 <davidhouse> wonderful.
15:16:31 <monochrom> @human IO (Handle, Handle)
15:16:31 <lambdabot> Unknown command, try @list
15:16:33 <SamB> oooooookkaaay....
15:16:40 <davidhouse> SamB: try System.Process
15:16:45 <davidhouse> @hoogle runInteractiveCommand
15:16:46 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
15:17:03 <vincenz> hi
15:17:11 <vincenz> what do native definitions look like in Haskell?
15:17:17 <davidhouse> (inHandle, outHandle, errHandle, pHandle) <- runInteractiveCommand "ls -la"
15:17:31 <vincenz> @fptools Prelude
15:17:31 <lambdabot> dummy module failed: /tmp/ghc22909.hspp:55:2-32: Non-exhaustive patterns in function process_
15:17:35 <vincenz> @fptools Prelude
15:17:35 <lambdabot> dummy module failed: /tmp/ghc22909.hspp:55:2-32: Non-exhaustive patterns in function process_
15:18:07 <monochrom> Bad sign.
15:19:34 <davidhouse> @localtime dons
15:19:35 <lambdabot> Local time for dons is Sun Jun  4 08:11:40 2006
15:19:45 <davidhouse> @id hello
15:19:46 <lambdabot> dummy module failed: /tmp/ghc22909.hspp:55:2-32: Non-exhaustive patterns in function process_
15:19:52 <davidhouse> everything be borked
15:20:00 <davidhouse> well, everything in Plugin/Dummy.hs
15:20:06 <davidhouse> @yarr
15:20:06 <lambdabot> Drink up, me 'earties
15:20:12 <davidhouse> ooh, maybe not
15:20:13 <blackdog> @vixen
15:20:13 <lambdabot> what are you
15:20:20 <davidhouse> perhaps those are in Quote, i don't remember
15:20:33 <blackdog> vixen isn't
15:20:49 <vincenz> anyone know how native functions are defined?
15:20:58 <davidhouse> vincenz: native as in...?
15:21:06 <davidhouse> @list dummy
15:21:06 <lambdabot> dummy provides: eval id dummy get-shapr faq paste learn map shootout botsnack eurohaskell wiki oldwiki docs libsrc fptools
15:21:16 <vincenz> native as in not written in haskel
15:21:23 <davidhouse> blackdog: vixen is in quote
15:21:26 <davidhouse> vincenz: FFI?
15:21:36 <davidhouse> vincenz: you mean like hGetChar and the other IO primitives?
15:21:37 <vincenz> yeah
15:21:40 <vincenz> yep
15:21:46 <davidhouse> yeah, they're FFI'd to C functions
15:21:58 <blackdog> davidhouse: I don't think so - it's got a different way of picking responses
15:22:08 <blackdog> unless don's changed it since i wrote it. :)
15:22:09 <davidhouse> @list
15:22:09 <lambdabot> list [module|command]. Where modules is one of:
15:22:09 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo
15:22:09 <lambdabot> topic type unlambda version vixen where
15:22:13 <davidhouse> @list vixen
15:22:13 <lambdabot> vixen provides: vixen
15:22:14 <davidhouse> aha.
15:22:16 <vincenz> foreign "name" name :: Type
15:22:17 <vincenz> :)
15:22:24 <davidhouse> well, the point is, it's not in dummy.
15:22:38 <blackdog> ah, gotcha. and dummy's the one that's borked.
15:23:17 <davidhouse> yep.
15:24:00 <int-e> @index createPipe
15:24:01 <lambdabot> System.Posix.IO, System.Posix
15:24:09 <int-e> @type System.Posix.createPipe
15:24:11 <lambdabot> IO (System.Posix.Types.Fd, System.Posix.Types.Fd)
15:40:48 <petekaz> anyone here familiar with the lambdabot code?
15:41:07 <rindolf> petekaz: URL?
15:41:09 <rindolf> lambdabot: source
15:41:16 <rindolf> lambdabot: guts?
15:41:20 <rindolf> @source
15:41:20 <lambdabot> lambdabot 3.1p35, GHC 6.4.1 (Linux i686 3.20GHz)
15:41:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:41:34 <petekaz> I'm a newbie so bear with me.
15:41:54 <petekaz> In Lambdabot.hs, scroll to the definition of 'withModule'.
15:41:56 <vincenz> @where haskell98
15:41:56 <lambdabot> http://haskell.org/onlinereport/
15:41:57 <davidhouse> petekaz: somewhat, what's up?
15:42:15 <petekaz> I want to add a function called: withAllModules
15:42:25 <petekaz> withAllModules :: (forall mod s. Module mod s => mod -> ModuleT s LB a)
15:42:25 <petekaz>                -> LB a
15:42:32 <petekaz> with that signature.
15:42:48 <SamB> @google "ghc -M"
15:42:50 <lambdabot> http://www.dcs.gla.ac.uk/mail-www/glasgow-haskell-bugs/msg01767.html
15:42:56 <petekaz> the full list of modules can be grabbed in the Map called 'ircModules'
15:43:15 <petekaz> I tried this:
15:43:32 <petekaz> withAllModules f = map f ircModules
15:43:47 <petekaz> but that returs a list of [b]s .. 
15:43:50 <SamB> @google site:haskell.org "ghc -M"
15:43:51 <lambdabot> http://www.haskell.org/pipermail/glasgow-haskell-users/2002-December/004534.html
15:43:57 <petekaz> I have to return a single LB a
15:44:36 <petekaz> which 'f m' will do where 'm' is a module from the map.
15:45:57 <davidhouse> petekaz: can't you map withModule? then sequence the results?
15:46:02 <davidhouse> or even, mapM withModule
15:46:42 <SamB> Pete_I: try mapM?
15:46:44 <petekaz> well, withModule takes a Map and a key.
15:46:46 <SamB> er, petekaz 
15:46:59 <petekaz> I just want to definitively map over all of the values.
15:47:10 <petekaz> SamB: I did: mapM f ircModules
15:47:42 <petekaz> but that doesn't work, I think I need to get the values out of ircModules for that to work
15:47:50 <petekaz> (total newbie sorry)
15:49:07 <petekaz> how do I get the list of values out from a Map?
15:49:30 <petekaz> then I could do: mapM f (getlistofvaluesfrommap ircModules) I think.
15:49:47 <SamB> @hoogle Data.Map.Map a b -> [a]
15:49:47 <lambdabot> No matches, try a more general search
15:49:52 <SamB> @hoogle Data.Map.Map a b -> [b]
15:49:53 <lambdabot> No matches, try a more general search
15:50:03 <SamB> @hoogle Ord a => Data.Map.Map a b -> [a]
15:50:04 <lambdabot> No matches, try a more general search
15:50:14 <SamB> @docs Data.Map
15:50:14 <lambdabot> dummy module failed: /tmp/ghc22909.hspp:55:2-32: Non-exhaustive patterns in function process_
15:50:17 <SamB> hmm.
15:51:18 <petekaz> damn lambdabot!
15:52:06 <int-e> > let pp p=and[p`mod`q/=0|q<-takeWhile(\q->q*q<=p)pl];pl=2:filter pp[3,5..];pr n=(let ps=dropWhile(<10^(n-1))$takeWhile(<10^n)pl in iterate(filter pp.map(\q->q`div`10+q`mod`10*10^(n-1)))ps!!n)in[1..5]>>=pr -- does this still work?
15:52:07 <lambdabot>  Couldn't match `[a]' against `t -> t1 -> t2'
15:52:08 <petekaz> I'm basically adding the ability for a Plugin to receive contextual messages instead of only receiving explicit commands.
15:53:00 <int-e> ah, template haskell again. that code needs a space after $.
15:53:17 <petekaz> That would give Plugins much more flexibilty if they wanted to trigger based on something in the middle of a sentence, or perhaps keep a running count of all tokens spoken in a channel, etc ..
15:54:51 <petekaz> My first haskell attempt.  I know how I want to do this, and have all the appropriate places stubbed in with comments now, but I'm failing on the implementation part :-)
16:09:25 <vincenz> regarding "foreign"
16:09:28 <vincenz> this is not part of haskell98
16:09:30 <vincenz> ?
16:10:44 <ithika> hello
16:11:37 <vincenz> hi
16:11:41 <ithika> any experts on 'runInteractiveProcess' around?
16:11:57 <eivuokko> vincenz, Yeah, it isn't.  It's in an addenum.
16:13:37 <vincenz> thx
16:15:49 <davidhouse> ithika: what do you need?
16:15:57 <davidhouse> i'm not an expert but i've used it
16:16:24 <ithika> i'm trying to download using wget and have the contents piped back to me
16:16:36 <ithika> but it just hangs
16:16:57 <ithika> might be something to do with threading, i'm not sure
16:17:40 <int-e> do you force (i.e. use) all of wget's output?
16:17:44 <davidhouse> i know very little about threading :)
16:17:53 <davidhouse> i _do_ know, however, that it's time for bed.
16:18:59 <ithika> int-e: i'm not sure if it all gets pulled in (to my program) or whether it stall before that point
16:21:25 <ithika> do you know a way to test where it get stuck?
16:23:55 <int-e> ithika: hmm. does your program use the output from wget in any way? try adding a line that prints the length of the result string.
16:24:34 <int-e> ithika: (I think wget gets blocked on your program because your program never actually reads that data)
16:24:49 <eivuokko> And read stderr if it's possible.
16:25:09 <ithika> okay; I shall try these suggestions.
16:31:24 <vincenz> @pl (\(a,b) -> (b,a))
16:31:24 <lambdabot> uncurry (flip (,))
16:37:24 <dreamEye_> @help
16:37:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:41:06 <dreamEye_> @fortune
16:41:07 <lambdabot> Said the cunt-lapping Bey of Algiers,
16:41:07 <lambdabot> In a cunt halfway up to his ears :
16:41:07 <lambdabot> 	"This nautch is delicious,
16:41:07 <lambdabot> 	 And without doubt nutritious.
16:41:07 <lambdabot> She's my best-tasting wife in ten years!"
16:42:17 <dreamEye_> @quote
16:42:18 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
16:46:43 <vincenz> dumteedu
16:46:44 <vincenz> \o/
16:47:53 <vincenz> Is there a function that checks for duplicates?
16:48:52 <ithika> mebbe, like nub without the destructive nature?
16:49:05 <vincenz> @hoogle scanl
16:49:05 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
16:49:05 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
16:49:42 <vincenz> > \l -> map (`elem` l ) l
16:49:43 <lambdabot>  Add a type signature
16:49:55 <vincenz> > let foo l = map (`elem` l ) l in foo [1..10]
16:49:56 <lambdabot>  [True,True,True,True,True,True,True,True,True,True]
16:51:50 <vincenz> > let foo l = fst $ foldr (\a (x,rst) -> ((a `elem` rst):x, a:rst)) ([],[]) l in foo [1..10]
16:51:51 <lambdabot>  [False,False,False,False,False,False,False,False,False,False]
16:51:55 <vincenz> > let foo l = fst $ foldr (\a (x,rst) -> ((a `elem` rst):x, a:rst)) ([],[]) l in foo (1:[1..10])
16:51:56 <lambdabot>  [True,False,False,False,False,False,False,False,False,False,False]
16:51:58 <vincenz> \o/
16:52:01 <sachu> Hi. I am trying to build yi, and I get the following error message on 'make':
16:52:29 <sachu> Boot.hs:54:0 -- Failed to load interface for 'Plugins'
16:52:47 <sachu> What does this mean, and how do I overcome this?
16:53:03 <sachu> (Is this the right place to ask?)
16:53:33 <monochrom> It's the right place to ask. But I don't know how to answer.
16:53:34 <vincenz> > let foo l = fst $ foldr (\a (x,rst) -> ((a `elem` rst):x, a:rst)) ([],[]) l in foo "vincenz"
16:53:35 <lambdabot>  [False,False,True,False,False,False,False]
16:53:39 <Lemmih> sachu: Could you paste your entire session somewhere?
16:53:51 <vincenz> > let foo l = fst $ foldr (\a (x,rst) -> ((a `elem` rst):x, a:rst)) ([],[]) l in any $ foo "vincenz"
16:53:52 <lambdabot>  Couldn't match `a -> Bool' against `[Bool]'
16:53:55 <vincenz> > let foo l = fst $ foldr (\a (x,rst) -> ((a `elem` rst):x, a:rst)) ([],[]) l in or $ foo "vincenz"
16:53:56 <lambdabot>  True
16:54:11 <sachu> Lemmih: Where can  I do that w/o cluttering this space?
16:54:14 <vincenz> @where paste
16:54:14 <lambdabot> http://paste.lisp.org/new/haskell
16:54:21 <Lemmih> lisppaste2: url
16:54:21 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:54:30 <vincenz> Lemmih: url
16:54:48 <sachu> thanks
16:55:41 <vincenz> @hoogle index
16:55:41 <lambdabot> Ix.index :: Ix a => (a, a) -> a -> Int
16:55:41 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
16:55:41 <lambdabot> Data.Generics.Basics.indexConstr :: DataType -> ConIndex -> Constr
16:55:51 <vincenz> is there a function to find the first occurence of something that is true
16:55:52 <vincenz> in a list
16:56:09 <Lemmih> @type find
16:56:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:56:21 <vincenz> I want an index
16:56:55 <Lemmih> @type elemIndex
16:56:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
16:57:01 <vincenz> > let foo l = fst $ foldr (\a (x,rst) -> ((a `elem` rst):x, a:rst)) ([],[]) l in "vincenz" !! (fromJust $ elemIndex True $ foo "vincenz")
16:57:02 <lambdabot>  'n'
16:57:16 <dreamEye_> let dup x set= length ( elemIndices  x set ) >1 in dup 3 [1,3,2,3]
16:57:43 <vincenz> dreamEye_: yours is o(N^2) tho
16:57:45 <vincenz> mine is O(N)
16:57:47 <vincenz> erm
16:57:48 <vincenz> no it's not
16:57:51 <vincenz> but it's faster
16:57:53 <vincenz> O(N^2/2)
16:57:54 <lisppaste2> sachu pasted "Error building yi" at http://paste.lisp.org/display/20822
16:58:15 <dreamEye_> but mine is faster to build
16:59:14 <sachu> Lemmih: done
16:59:53 <monochrom> windows? unix?  what is the \ doing in -DLIBDIR=\"/local/lib/yi\" ?
16:59:59 <Lemmih> sachu: That's not really a lot more information.
17:00:23 <Philippa> monochrom: looks like an escape to me?
17:00:28 <monochrom> Did you type in the ghc etc. command yourself?  Or was it what make did?
17:00:30 <sachu> monochrom:Linux. I don't know about the \ . 
17:00:43 <monochrom> v.odd
17:00:56 <sachu> monochrom: its what make did
17:01:14 <monochrom> doubleplusplusunnormal
17:01:51 <sachu> Lemmih: what else should i provide?
17:02:33 <Lemmih> sachu: The output of, say, configure.
17:02:55 <monochrom> I am now thinking the package "plugins" need to be installed separately.
17:03:07 <Lemmih> And yi is a Cabal package so you probably shouldn't use the makefile at all.
17:03:29 <sachu> Lemmih: ok, I'll paste that. I installed hs-plugins as suggested by the yi readme
17:03:48 <Lemmih> sachu: You're using yi-0.1.0?
17:04:07 <sachu> yes. yi-0.1.0
17:04:19 <monochrom> If you enter at a shell prompt "ghc-pkg describe plugins" do you get nice response?
17:04:38 <Lemmih> sachu: Get it from the darcs repo.
17:04:57 <lisppaste2> sachu annotated #20822 with "Output of configure --prefix=/local" at http://paste.lisp.org/display/20822#1
17:05:18 <Lemmih> yi-0.1.0 requires a way old version of hs-plugins.
17:05:32 <monochrom> ah
17:06:15 <lisppaste2> sachu annotated #20822 with "Output of ghc-pkg describe plugins" at http://paste.lisp.org/display/20822#2
17:06:52 <sachu> Lemmih: OK, i'll get yi with darcs and try. thanks for the help
17:07:20 <monochrom> If one goes into the source code of yi and systematically replace "import Plugins" by "import System.Plugins" will that suffice?
17:10:01 <Lemmih> monochrom: He'd probably have to change the rest of the code, too.
17:19:53 <sachu> Thanks all, getting yi from darcs worked.
17:25:29 <SamB> @where hxt
17:25:30 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
17:26:47 <vincenz> @hoogle foldm
17:26:48 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
17:26:48 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:26:48 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
17:28:55 <vincenz> @pl \f a b c -> f c a b
17:28:56 <lambdabot> (flip .) . flip
17:28:59 <vincenz> @pl \f a b c -> f c b a
17:28:59 <lambdabot> flip . (flip .) . flip
17:31:14 <vincenz> @type ((flip .) . flip foldM)
17:31:15 <lambdabot> forall b a b1. a -> (a -> b1 -> b -> a) -> b -> [b1] -> a
17:31:27 <vincenz> @type ((flip .) . flip $ foldM)
17:31:28 <lambdabot> forall a b (m :: * -> *). (Monad m) => a -> [b] -> (a -> b -> m a) -> m a
17:37:31 <vincenz> small golfing
17:37:43 <vincenz> Map x a -> Map x (x,Int) with Int being 1..number
17:37:48 <vincenz> erm 1.. size
17:43:30 <int-e> @pl (\n(k,v)->(k,(n,k)))
17:43:30 <lambdabot> (`ap` snd) . (. fst) . (const .) . ap (,) . (,)
17:43:43 <int-e> err
17:43:56 <int-e> @pl (\n(k,v)->(k,(v,n)))
17:43:57 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . flip (,)
17:44:53 <bringert> ok, compiling 6.5 sans ByteString on OS X/i386 worked fine (and it didn't take this long, I took a nap). thanks dcoutts
17:45:29 <int-e> I have fromList.zipWith(second.flip(,))[1..].toList
17:46:49 <int-e> wait, Map x (x,Int), not Map x (a,Int)?
17:47:43 <int-e> vincenz: ?
17:53:40 <vincenz> it's ok
17:53:45 * vincenz will post a cool algo soon
17:59:35 <vincenz> \o/
18:02:43 <vincenz> \o/
18:02:45 <vincenz> wanna see it?
18:02:57 <vincenz> this is the spec
18:02:58 <vincenz> calculateDeps :: (Ord a, Show a, Monad m) => (b -> [a]) -> [(a, b)] -> m [(a, b)]
18:03:22 <vincenz> it sorts the list by the dependencies generate by the first func
18:03:58 <SamB> hmm, it seems that HXT should have had an Arrow interface all along ;-)
18:06:13 <SamB> I wish I could get a hardcopy of this thesis :-(
18:06:46 <vincenz> btw
18:06:48 <bringert> SamB: what thesis is that?
18:06:52 <vincenz> Data.Graph is incorreectly documented
18:08:10 <SamB> HXT-5.x/doc/cookbook/doc/thesis.pdf | x > 2
18:08:36 <SamB> er, s/>/>=/
18:09:10 <SamB> also http://www.fh-wedel.de/~si/HXmlToolbox/cookbook/doc/thesis.pdf
18:10:49 <bringert> ask your university library (if you are a student or university employee), you'd be surprised at what they can dig out / order / print
18:11:29 <SamB> even though this has absolutely nothing to do with school?
18:11:49 <bringert> how would they know?
18:12:04 <bringert> besides, university is about the open pursuit of knowledge
18:12:07 <SamB> well, um, its a community college. there is no way they teach Haskell!
18:12:15 <bringert> doesn't matter
18:12:25 <bringert> imo
18:12:34 <vincenz> anyone use D.G?
18:12:42 <bringert> if they're good, that is
18:12:43 * SamB thinks it would be better if you didn't have to be signed up as a current student, either
18:13:33 <SamB> hmm, wait, it was only >= 3
18:17:22 * SamB thinks HXT should be the new XSLT
18:17:54 <vincenz> want to see my cool graph?
18:18:04 <SamB> sure!
18:18:12 * SamB isn't using Data.Graph, though
18:18:19 <ihope> Can '`' ever be at the start of a Haskell program?
18:18:35 <SamB> well...
18:18:50 <vincenz> SamB: well not graph but
18:18:58 <SamB> oh?
18:18:59 <vincenz> an algo to sort items by dependencies
18:19:07 <SamB> oh
18:19:11 <vincenz> calculateDeps :: (Ord a, Show a, Monad m) => (b -> [a]) -> [(a, b)] -> m [(a, b)]
18:19:13 <SamB> like make?
18:19:17 <vincenz> yeah
18:19:41 * vincenz adds in an extra check to ensure the lack of loops
18:19:49 <SamB> ooh, even more like make
18:20:02 <vincenz> it's great
18:20:07 <vincenz> and completely reusable
18:20:11 <SamB> earlier make broke some loops that I had no idea why I had
18:20:14 * vincenz uses it for his module dependency calculator
18:20:14 <int-e> ihope: I don't think so.
18:20:18 <vincenz> I have modules much like haskel
18:20:23 <SamB> I eventually managed to get them to go away
18:20:43 <int-e> vincenz: what's the purpose of the monad? if I choose [], will I get all possible dependency graphs?
18:20:56 <vincenz> int-e: failure
18:20:57 <int-e> vincenz: err, sorting orders?
18:21:03 <SamB> ihope: I don't think so!
18:21:04 <int-e> vincenz: why not use MonadPlus then?
18:21:09 <vincenz> int-e: hmm?
18:21:19 <SamB> ihope: because GHC says:
18:21:24 <int-e> @type mzero
18:21:25 <SamB> test.hs:1:0: parse error on input ``'
18:21:25 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
18:21:28 <vincenz> int-e: oh
18:21:35 <vincenz> int-e: not feasibly
18:21:38 <vincenz> int-e: not feasible
18:21:44 <vincenz> it's a total pass system
18:21:52 <vincenz> like if I have
18:22:00 <SamB> then again, I'm not looking at the grammar or anything
18:22:03 <vincenz> [("a", ["b"])]
18:22:06 <vincenz> b doesn't exist
18:22:07 <vincenz> which should fail
18:22:12 <vincenz> or
18:22:13 <SamB> certainly not the -i file for the GHC parser
18:22:22 <vincenz> [("a", ["b"]), ("a", [])]
18:22:26 <vincenz> multiple defs of "a"
18:22:40 <vincenz> second one could be cured by requiring a map input
18:23:17 <SamB> vincenz: or you could merge them into a map ;-)
18:23:21 <int-e> > fail "foo" :: Maybe Int
18:23:22 <lambdabot>  Nothing
18:24:03 <goltrpoat> i'm porting a huttonesque parser combinator library to an ocaml dialect that doesn't have type classes (or ml-style functors).  it's quickly getting unpleasant
18:24:37 <SamB> goltrpoat: well, yes. that is how it is. type classes increase pleasentness considerably in a language
18:24:49 <goltrpoat> indeed
18:24:58 <int-e> vincenz: would you mind showing us the code?
18:25:16 <vincenz> sure
18:25:19 <vincenz> lemme finish a last toch
18:27:30 <vincenz> bleg
18:27:32 <vincenz> Data.Graph is bugg
18:27:33 <vincenz> y
18:28:26 <SamB> indeed?
18:28:56 <vincenz> yep
18:29:00 <vincenz> topSort I bugged to haskell-cafe
18:29:04 <vincenz> but apparently components is buggy too
18:31:14 <vincenz> anyone any idea on how to check for cycles?
18:32:22 * vincenz switches to Data.Graph.Inductive
18:41:09 <vincenz> GRR
18:41:19 <SamB> what now?
18:41:21 <vincenz> why are all components for both D.G and D.G.I based on the undirected version of the graph
18:41:28 <vincenz> that's so lame
18:41:31 <SamB> oh
18:41:35 <vincenz> if I wanted to make it undirected, I'll say so!
18:42:53 <int-e> vincenz: what would be the definition of 'component' otherwise?
18:43:15 <vincenz> anything forming cycles
18:43:36 <int-e> well, according to the documentation it should do that - it says 'strongly connected'.
18:43:50 <vincenz> it's based on undirected graph
18:43:53 <vincenz> I have a directed graph
18:44:14 <int-e> oh
18:44:15 <int-e> -- | The strongly connected components of a directed graph, topologically
18:44:15 <int-e> -- sorted.
18:44:15 <int-e> stronglyConnComp
18:44:15 <int-e>  
18:44:26 <int-e> try that one then.
18:44:39 <vincenz> it's still based on undirected graph
18:44:43 <vincenz> just with fully connectivity
18:45:56 <vincenz> and D.G.I topsort has same bug as D.G topsort
18:46:46 <vincenz> \o/
18:46:53 <vincenz> G.hasLoop $ G.trc grapg
18:46:56 <int-e> Prelude Data.Graph> print . topSort $ buildG (1,4) [(1,2), (1,3), (2,4), (2,3)]
18:46:56 <int-e> [1,2,4,3]
18:47:05 <vincenz> int-e: that's incorrect if you look at the doc
18:47:06 <vincenz> it says
18:47:08 <vincenz> i will be before J
18:47:12 <vincenz> if j is reachable rom i
18:47:19 <ihope> Can one fold a tree?
18:47:35 <vincenz> basically it does topSort . map (\(a,b) -> (b,a))
18:47:54 <int-e> vincenz: so? 2 is reachable from 1 ... so 1 comes before 2
18:48:10 * vincenz dohs
18:48:18 <vincenz> no it's still wrong
18:48:36 <vincenz> maybe it's my version
18:49:07 <int-e> the result you posted on the mailing list is different. but you also wrote components there, instead of topSort.
18:49:31 * vincenz ponders
18:49:38 <vincenz> I don't get it
18:49:52 <int-e> and [1,3,2,4] would be wrong for the (2,3) edge.
18:50:41 * vincenz sighs
18:50:45 <vincenz> did I make a fool of myself on haskell-cafe?
18:50:51 <vincenz> yep
18:50:58 <int-e> possibly.
18:51:02 <vincenz> :/
18:51:04 <vincenz> anyways
18:51:07 <dons> moin
18:51:07 <vincenz> onto making 
18:51:22 <vincenz> findCycles :: (Graph gr) => gr a b -> [[Node]]
18:53:51 <int-e> I think stronglyConnComp does everything you want.
18:54:36 <int-e> map flattenSCC $ stronglyConnComp $ [(1,1,[2,3]),(2,2,[3,4]), (3,3,[4]), (4,4,[3])]
18:54:38 <int-e> [[3,4],[2],[1]]
18:55:03 <vincenz> hmm
18:55:03 <vincenz> odd
18:55:11 <dons> @dynamic-reload dummy
18:55:11 <lambdabot> module reloaded
18:55:16 <dons> @fptools foo
18:55:17 <lambdabot> foo not available
18:55:18 <vincenz> very odd
18:55:20 <int-e> (input: (key, key, f key); output: list of lists; if any list is not a singleton, there's a cycle; otherwise the singletons are topologically ordered (but strangely in reverse order)
18:55:23 <int-e> )
18:55:36 <vincenz> yeah but I just saw something else
18:55:41 <vincenz>   let l = [("A", ["B", "C"]), ("B", ["D"]), ("C", ["B"]), ("D",[])]
18:55:45 <vincenz> it says this thing has loops
18:56:14 <int-e> hmm.
18:56:55 <int-e> not here.
18:56:59 <int-e> Prelude Data.Graph> let l = [("A", ["B", "C"]), ("B", ["D"]), ("C", ["B"]), ("D",[])]; l' = [(a,a,b) | (a,b) <- l] in map flattenSCC $ stronglyConnComp l'
18:56:59 <int-e> [["D"],["B"],["C"],["A"]]
18:57:30 <vincenz> o.O
18:57:33 <vincenz> why triplets
18:57:46 <int-e> (value, key, [key])
18:58:22 <int-e> what it does do is ignore keys that correspond to nodes - so it doesn't quit do everything you want.
18:58:37 <SamB> what would be a good way to drop a portion of a string specified by a regular expression from the beginning...
18:58:44 <int-e> i.e. [("a",["b"])] return [["a"]]
19:00:12 * int-e makes too many typos. :/
19:01:32 <SamB> too many types?
19:03:21 <int-e> ha ha
19:10:11 <vincenz> int-e: thanks
19:10:16 <vincenz> that seriously cleans up my code
19:10:25 <vincenz> in fact I can throw pretty much all of it away o.O
19:11:02 <int-e> :)
19:11:15 <int-e> @index unsafeIndex
19:11:15 <lambdabot> bzzt
19:11:17 <int-e> :/
19:11:32 <Cale> SamB: Using which regex library?
19:12:06 <audreyt> is there a way to newUnique in STM?
19:12:07 <SamB> Cale: oh, well, I'm not. which is why I decided to use list/string functions instead...
19:12:15 <audreyt> (both conceptually, and if there's already code that doe sthis)
19:12:59 <Cale> audreyt: You could create a unique generator fairly easily...
19:13:37 <vincenz> @hoogle foldm
19:13:38 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
19:13:38 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:13:38 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
19:15:20 <Cale> Something like  createUniqueGen = do tv <- newTVar 0; let {getUnique = do v <- readTVar tv; writeTVar tv (v+1); return v}; return getUnique
19:16:47 <audreyt> but then I'll need to pass cuG around
19:17:04 <Cale> not createUniqueGen, but its result.
19:17:10 <audreyt> yeah, that.
19:17:21 <audreyt> the idea of Data.Unique is that it's global hidden state
19:17:26 <audreyt> can we get the same concept in STM?
19:17:42 <Cale> Another idea would be to monad transform STM
19:17:48 <SamB> uh...
19:17:50 <Cale> with, say, UniqueT.
19:17:54 <SamB> oh, oh.
19:18:18 <Cale> http://www.haskell.org/hawiki/MonadUnique
19:18:24 <audreyt> mmmhmm.
19:18:27 <SamB> but, you'd need to somehow keep things unique across threads, then...
19:18:58 <audreyt> well, you can suffix with threadid
19:19:22 <audreyt> i.e. an internal unique is a (generatedThreadId, threadLocalCout) tuple
19:19:24 <audreyt> would that work?
19:19:40 <Cale> sure
19:20:04 <Cale> or just use a newtype of ReaderT TVar STM
19:20:27 <vincenz> int-e: thanks!
19:20:29 <vincenz> \o/
19:20:37 <audreyt> but myThreadId is IO
19:20:49 <audreyt> otoh, that should be among the "saft" things to do with unsafeIOtoSTM
19:20:53 <Cale> with a run function which initialises the unique supply and something similar to what I wrote above which operates on it
19:20:55 <audreyt> s/saft/safe/
19:21:23 <Cale> I don't think there should be any real need to use anything remotely usafe to do this
19:21:31 <Cale> un*
19:22:21 <audreyt> er, if you don't do myThreadId
19:22:27 <Cale> Then again, I have the opinion that global mutable state is evil and to be avoided at all costs.
19:22:30 <audreyt> surely the unique monad can yield same numbers across threads?
19:22:59 <vincenz> \o/
19:22:59 <Cale> Well, depends on where you apply it.
19:23:22 <audreyt> I mean, it's StateT Integer underneath
19:23:38 <audreyt> unless you make it ReaderT ThreadId (StateT Integer)
19:23:46 <audreyt> that sounds a bit overkill
19:24:10 * vincenz hugs int-e 
19:24:16 <Cale> What about ReaderT TVar IO ?
19:24:25 <Cale> or ReaderT TVar STM, depending
19:24:38 <Cale> You just store the TVar which maintains the count
19:24:47 <int-e> vincenz: now let's not overdo it there.
19:24:54 <vincenz> :D
19:24:57 <vincenz> onto the next part
19:24:59 <Cale> Newtype the thing so nothing has access to it except for the 'fresh'.
19:25:02 <lisppaste2> sam_ pasted "error3" at http://paste.lisp.org/display/20825
19:25:06 <sam_> I'm trying to figure out, if I could use some more generic type signature for 'test' in the above program. Any ideas or recommendations?
19:25:07 <Cale> er 'fresh' action
19:25:51 <audreyt> mm.
19:25:57 <audreyt> yeah, that sounds sane.
19:26:00 <Cale> sam_: Perhaps  (MonadError MyError m) => m String
19:26:06 <audreyt> thanks a lot, Cale :)
19:26:09 <Cale> no problem
19:26:33 <vincenz> dumteedum
19:26:44 <vincenz> int-e: a nice side effect is that orders topologically
19:27:07 <vincenz> int-e: so I can completely reuse this both for modules as well as functions (where recursion is allowed, and the typechecker types sets of functions at once)
19:27:16 <Cale> sam_: You could just take the signature off (and kill the usage from main) and see what the compiler infers
19:28:09 <Cale> sam_: as long as the monomorphism restriction doesn't bite you (turn that off with -fno-monomorphism-restriction) you should get the most general type
19:28:10 <sam_> cale, I can make the compiler print out the inferred signature?
19:28:23 <Cale> sam_: yeah, just load the code in ghci and type :t test
19:29:22 <Cale> Since test is a pattern-binding and not a function binding, it'll probably try to give it a monomorphic type, which is annoying
19:30:50 <Cale> with  ghci -fno-monomorphism-restriction error.hs
19:30:53 <Cale> I get
19:30:57 <Cale> *Main> :t test
19:30:59 <Cale> test :: (Control.Monad.Error.MonadError MyError m) => m [Char]
19:31:12 <Cale> after removing the type sig from test, and commenting out main
19:32:45 <sam_> Ok, that type gives me a lot more headaches than 'Either MyError String'. I think I'll stick with the latter one for now :-)
19:33:23 <Cale> All the type says is that if m is a monad capable of throwing errors of type MyError, then it's of type m String
19:34:26 <int-e> hmm. type MyErrorM a = (MonadError MyError m) => m a ... does that work?
19:34:30 <Cale> You could give it that type explicitly without having to turn off the monomorphism restriction -- it's just a (stupid, imo) technicality that prevents the compiler from giving it the most general type because it doesn't look like a function.
19:34:57 <Cale> int-e: no, I don't think so
19:35:25 <Cale> well, I might be surprised, I'm not completely sure
19:36:06 <Cale> I think it's a syntax error though
19:37:47 <int-e> it's not Haskell98 (I'm not surprised), and works with -fglasgow-exts
19:38:08 <Cale> ah, okay
19:39:46 <sam_> ahh.. now the type signature is starting to make sense.. I was thinking of the 'm' on the left side as a type variable for the second parameter in the type constuctor.. but it's not.. 
19:40:29 <Cale> It's a variable for the constructor itself :)
19:41:41 <Cale> That's sort of the cool thing about monads, is that you can write code which works on many different "machines" which have different individual properties, but share an interface.
19:43:21 * Cale wonders if there's an emacs with a modern UI
19:43:44 <int-e> is there any way to get ghc print a trace of rules (as in {-# RULE ... #-}) that it applies?
19:44:05 <SamB> Try the option to trace inlining?
19:44:57 <sam_> yeah.. i think i've grogged what's cool about monad, which is why i'm trying to give this a general type.. ..now, if I was just able to write any real programs with them :-)
19:47:46 <SamB> hmm, the RELAX NG support in HXT isn't too useful without XML Schema Datatypes
19:48:27 <int-e> @index trace
19:48:27 <lambdabot> Debug.Trace
19:49:17 <dons> @seen bringert
19:49:18 <lambdabot> I saw bringert leaving #haskell.se and #haskell 1 hour, 34 minutes and 9 seconds ago, and .
19:51:15 <SamB> I don't suppose anyone knows of a darcs repo for HXT?
19:53:15 * SamB_XP stops working on his RNG Compact parser because he doesn't know what else can be done for it without hacking on HXT itself
19:53:18 <int-e> SamB: ah, my mistake was not adding -O to the compiler options.
19:53:43 <SamB_XP> int-e: ah, yeah, it tends not to give much helpful information about RULES that it doesn't apply ;-)
19:53:54 <dons> int-e, yeah you need -O and -ddump-simpl-stats
19:54:03 <dons> then you'll get counts of all rules fireing
19:54:16 <dons> more info, using -ddump-simpl-iterations, and you'll see in which phase each rules fires
19:54:33 <dons> int-e, what rules hacking are you up to?
19:55:01 <int-e> oh, just a quick hack to make (Int, Int)-based arrays fast: inline inRange and unsafeIndex for that type.
19:55:23 <dons> yeah. cool. also, did you ever see SPJ's comments on (Int,Int) arrays?
19:55:28 <dons> let me find it...
19:55:47 <int-e> GHC.Arr only specializes the (Int, Int) Ix instance, and that just doesn't cut it.
19:56:03 <dons> yep.
19:57:34 <dons> here's what spj wrote: http://www.cse.unsw.edu.au/~dons/tmp/mail.txt
19:58:09 <dons> looks like -fliberate-case-threshold=bignumber might be useful
19:59:06 <dons> ah, these were pairs of Bool arrays, which he first optimised to Int pairs, iirc
20:07:04 <int-e> yes. interesting stuff :)
20:42:00 <vincenz> @hoogle isJust
20:42:01 <lambdabot> Maybe.isJust :: Maybe a -> Bool
20:54:33 <vincenz> what's the fixity of `func`
20:55:42 <int-e> by default infix 5 (I think?). you can change it with  infix[lr] 0-9 `func`
20:55:45 <int-e> 1-9
20:56:00 <vincenz> cool :)
20:56:04 <int-e> oh. 0, too.
20:58:27 <vincenz> are you allowed to import a module multiple times with a different qual?
20:58:36 <int-e> sure
20:58:38 <vincenz> and on that same note, are you allowed to import two modules under the same qual
20:58:46 <int-e> that too
20:59:03 * vincenz disallows point 2 atm
20:59:09 <Cale> Hello, how are you doing?
20:59:29 <Cale> test, 1, 2, 3 :)
20:59:35 <vincenz> hiya Cale 
20:59:38 <vincenz> Cale: nearly done :)
20:59:40 <int-e> 5 8 13
20:59:44 <vincenz> just gotta scope my stuf
21:00:02 <vincenz> and fix my typechecker to do recursive funcs (should be easy 'nuff)
21:00:24 <vincenz> \o
21:00:29 <vincenz> o/
21:01:12 <Cale> heh
21:01:33 <Cale> like a little animation you have going there :)
21:01:50 <vincenz> /o/ \o/ \o\  - boogie!
21:02:07 <vincenz> ascii stick figures are cool
21:02:39 <vincenz> mind if I run something by you guys?
21:03:50 <vincenz> so I've done importer
21:03:58 <vincenz> which ensures my modules are not recursive and are properly sorted
21:04:08 <vincenz> it also declares the export list for eacch module
21:04:11 <vincenz> which si a list of [Ident]
21:04:25 <vincenz> and the import list which is a map NIdent QIDent
21:04:34 <lisppaste2> petekaz pasted "Need help with indentation" at http://paste.lisp.org/display/20827
21:04:36 <vincenz> import qualified QIDent as NIDent
21:04:58 <vincenz> now EIdent in my Exps is (Ident,NIdent) after importer
21:05:01 <vincenz> I'm gonna change it to
21:05:05 <vincenz> EIDent (QualIdent)
21:05:18 <vincenz> QualIdent = Local Ident | Imported IDent QIdent
21:05:26 <petekaz> Could someone help me with the indentation of that paste.  I can't get it to compile.
21:05:32 <vincenz> sound good?
21:08:17 <Cale> vincenz: I'd have to know how your program works better to understand that :)
21:08:32 <lambda_the_insig> @pl fromRoot offs note = map (flip transposeNote note) offs
21:08:32 <lambdabot> fromRoot = flip (map . flip transposeNote)
21:08:33 <vincenz> :)
21:08:48 <Cale> petekaz: "(process.." isn't indented quite enough, I don't think
21:08:53 * vincenz is going to make a nwe monad
21:08:55 <vincenz> CompilerMonad
21:08:59 <vincenz> so I can decide when to fully fail
21:09:02 <vincenz> and when to just print an error
21:09:08 <Cale> also, "(ircPrivmsg" and the line after
21:09:33 <Cale> they're indented less than "actions =" so they can't be inside that decl
21:09:46 <petekaz> catchError is a function, those 2 lines are args to it.
21:10:16 <Cale> I know
21:10:20 <petekaz> oh.
21:10:26 <Cale> but they're indented less than they should be
21:10:35 <petekaz> ok, I'll try ... thanks.
21:10:52 <Cale> they should be indented more than catchError to be parameters to it
21:11:26 <Cale> but I think the major problem is that "(ircPrivmsg" doesn't seem indented enough -- needs at least 3 more spaces
21:12:18 <Cale> well, what's the error that you get?
21:12:50 <petekaz> parse error (possibly incorrect indentation)
21:13:00 <Cale> at which line?
21:13:26 <petekaz> after the very last.
21:13:32 <lambda_the_insig> @pl invert c = drop 1 c ++ take 1 c
21:13:33 <lambdabot> invert = ap ((++) . drop 1) (take 1)
21:13:51 <lisppaste2> Cale annotated #20827 with "fixed?" at http://paste.lisp.org/display/20827#1
21:14:41 <Cale> the ) there needs to be indented a little more than the 'actions =' too
21:14:45 <petekaz> I basically copied this block, and in the original block, there was a comment inline -- Important.  I assumed that was referring to the thing before it, is it possible this is used to fool some rule?
21:15:13 <Cale> probably not
21:15:16 <petekaz> ah .. that fixed.
21:15:20 <petekaz> that fixed it.
21:15:35 <lambda_the_insig> @pl invert c = (drop 1 c) ++ (take 1 c)
21:15:36 <lambdabot> invert = ap ((++) . drop 1) (take 1)
21:16:14 <petekaz> Cale: so basically, if I have something not indented far enough, haskell thinks I just finished the previous do block right?
21:16:27 <Cale> yeah
21:16:33 <Cale> or let, or whatever
21:16:54 <Cale> things have to be indented more than whatever it is that they're a part of
21:17:05 <petekaz> ok, got it.
21:17:20 <petekaz> are you familiar with lambdabot's code?
21:17:25 <Cale> slightly
21:17:31 <Cale> I've written a couple of modules
21:17:41 <Cale> (which are in mbot)
21:18:43 <petekaz> maybe this would be a quick answer, could you look in Plugin/Base.hs, find the definition of 'docmd'.
21:19:37 <petekaz> In that function, you'll see 'let act = ...', then the action is acted upon with 'mapLB (timeout...) act'.
21:20:45 <Cale> yep
21:21:03 <petekaz> What if act (LB a) were a list of acts (LB [a]), how would I get all of those executed in the same way as the single version.
21:21:38 <petekaz> I'm basically adding the ability for a Plugin to receive contextual messages instead of only receiving explicit commands.
21:21:52 <petekaz> That would give Plugins much more flexibilty if they wanted to trigger based on something in the middle of a sentence, or perhaps keep a running count of all tokens spoken in a channel, etc ..
21:22:14 <Cale> interesting
21:22:47 <petekaz> so each message on a channel is sent to all modules ... via process _ _ _ "context" _ where "context" would be the command to implement if they want it.
21:22:50 <Cale> Do you mean [LB a] ?
21:23:09 <Cale> sequence :: [LB a] -> LB [a]
21:23:30 <petekaz> I don't think so ... I wrote a withAllModules (see withModule in Lambdabot.hs) that returns LB [a].
21:23:49 <Cale> okay
21:24:02 <Cale> and what do you want to do with that?
21:24:08 <audreyt> yay, STM is now fully exposed to Pugs
21:24:23 <audreyt> Cale++ # ReaderT for object space id worked like a charm
21:24:23 <petekaz> I'm so new, I don't know what to do with LB [a] now.  Basically in another language, I'd loop over it, and just do the same mapLB (timeout ..) act thing to each.
21:24:38 <Cale> cool :)
21:25:17 <int-e> dons: I think I was wrong about the unsafeIndex for (Int, Int) not being inlined; it's just a bit of a pain to tell the compiler to strictify the bounds in loops.
21:25:40 <SamB_XP> @karma+ Cale 
21:25:40 <lambdabot> Cale's karma raised to 13.
21:26:11 <SamB_XP> have to get your karma syntax right ;-)
21:27:14 <audreyt> I tend to think karma as a social function :)
21:27:18 <audreyt> but thanks :)
21:28:40 <SamB_XP> well, yeah. and the karma around here is spotty at best, anyway...
21:29:06 <Cale> @karma @karma
21:29:06 <lambdabot>  @karma has a karma of -1
21:29:19 * SamB_XP rarely thinks to use it, lots of others probably don't either
21:29:24 <SamB_XP> @karma-all
21:29:25 <lambdabot>  dons                   35
21:29:25 <lambdabot>  Lemmih                 17
21:29:25 <lambdabot>  shapr                  17
21:29:25 <lambdabot>  xerox                  15
21:29:25 <lambdabot>  dcoutts                14
21:29:26 <lambdabot> [157 @more lines]
21:29:42 <SamB_XP> @more
21:29:42 <lambdabot>  lambdabot              14
21:29:42 <lambdabot>  Cale                   13
21:29:42 <lambdabot>  QuickCheck             10
21:29:42 <lambdabot>  musasabi               10
21:29:42 <lambdabot>  SamB                    9
21:29:44 <lambdabot> [152 @more lines]
21:30:04 <audreyt> @yow
21:30:05 <lambdabot> I'm not available for comment..
21:31:08 <Cale> Comment Ã§a va?
21:31:18 * SamB_XP forgets who @karma-ed @karma, wonders if he did it himself?
21:31:34 <Cale> @karma @more
21:31:34 <lambdabot>  @more has a karma of 0
21:31:38 <Cale> @karma+ @more
21:31:38 <lambdabot>  @more's karma raised to 1.
21:31:48 <Cale> @karma @yow
21:31:48 <lambdabot>  @yow has a karma of 0
21:31:52 <Cale> @karma+ @yow
21:31:52 <lambdabot>  @yow's karma raised to 1.
21:31:53 <Cale> @karma+ @yow
21:31:53 <lambdabot>  @yow's karma raised to 2.
21:32:15 * SamB_XP has often thought his karma strangely high
21:32:21 <Cale> @karma+ @karma+
21:32:22 <lambdabot>  @karma+'s karma raised to 1.
21:32:43 <SamB_XP> @karma+ ADEpt
21:32:44 <lambdabot> ADEpt's karma raised to 4.
21:32:53 <SamB_XP> @karma adept
21:32:53 <lambdabot> adept has a karma of 0
21:33:05 <SamB_XP> huh
21:33:11 <Cale> case sensitive
21:33:26 <SamB_XP> bad, because adept keeps changing his case!
21:33:55 <Cale> yeah
21:34:20 <Cale> so one user could have 2^n karmas
21:34:36 <SamB_XP> @karma+++ ADEpt
21:34:36 <lambdabot> ADEpt's karma raised to 5.
21:34:43 <SamB_XP> aww
21:34:59 <Cale> @help @karma+
21:34:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:35:03 <Cale> @help karma+
21:35:03 <lambdabot> karma+ <nick>. Increment someone's karma
21:35:06 * SamB_XP knew that was going to happen, of course
21:35:26 <Cale> perhaps it should take an optional numeric parameter
21:36:01 <goltrpoat> doesn't make much sense for it to be case sensitive, since irc isn't case sensitive
21:36:14 <SamB_XP> definately implies that it should be case insensitive, because it says "someone's", not "some string of graphic characters'"
21:36:39 <SamB_XP> using irccase, of course
21:36:45 <SamB_XP> not the typical ASCII case
21:42:27 <audreyt> I wonder if the topic is better typed as [(String, String)]
21:43:01 --- topic: set to '[("Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/"), ("Submit a paper to the Haskell Workshop", "http://haskell.org/haskell-workshop/2006"), ("Logs","http://tunes.org/~nef/logs/haskell/"), ("Haskell is still the language of choice for discriminating hackers", "http://icfpc.plt-scheme.org/"), ("We put the Funk in Funktion", "http://www.haskell.org/learning.html"), ("Vote on a European #haskell get-together", "http://sna' by audreyt
21:43:28 <audreyt> hm, hit the cap
21:43:39 <Cale> well, also, they're not all pairs
21:43:53 <audreyt> only the funk one is arguably not-pair
21:45:28 <audreyt> but yeah.
21:45:30 --- topic: set to '["Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "Vote on a European #haskell get-together", "http://snappoll.com/poll/84228.php"]' by audreyt
21:50:49 * SamB_XP wishes x-chat would say what the topic had been, too
22:28:11 <pierre-> hello
23:21:46 <goltrpoat> > [1..10] >>= (\n -> [n*n])
23:21:48 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
23:22:40 <goltrpoat> note to self:  way #2983 of writing map discovered
23:23:09 <vincenz> > nub $ [1..10] ++ [1..10]
23:23:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:26:32 <bringert> did anyone consider hacing a parall
23:26:36 <bringert> dammit
23:26:41 <bringert> hit enter by mistake
23:26:57 <stepcut> :p
23:26:58 <bringert> did anyone consider hacking a parallel --make into ghc?
23:27:57 <Lemmih> Didn't JaffaCake add that to ghc-6.5 recently?
23:28:31 <bringert> stepcut: now that I see, I remembered that I wanted to ask you about your RSS module. do you have a repo / homepage for it somewhere?
23:29:38 <stepcut> not yet
23:30:17 <stepcut> I decided I have too many little libraries to make and update webpages for them. So I am messing around with some code to automate the process
23:31:04 <stepcut> I have seen rumors that there may be other modules out there now too
23:31:31 <bringert> Lemmih: cool, how a link or something? I could find anything in the HEAD docs
23:31:37 <bringert> eh, couldn't
23:31:45 <bringert> stepcut: yeah I had that problem too
23:32:01 <bringert> I generate homepages from cabal-files
23:32:19 <stepcut> bringert: excellent idea
23:33:01 <bringert> stepcut: here's the generated home page for the home page generator: http://www.cs.chalmers.se/~bringert/darcs/hask-home/doc/
23:33:04 <stepcut> bringert: the things I want at a minimum are: (1) show darcs changelog on webpage (2) easily create and manage release tarballs for stable releases
23:33:20 <bringert> mine only does the second
23:33:31 <bringert> but adding (1) should be easy enough
23:33:37 <stepcut> cool
23:34:48 <bringert> hmm, my ghc 6.5 build can't compile haddck
23:35:16 <stepcut> might be neat to also have a hask-home-latest.tar.gz that is a symlink to hask-home-2006.03.23.tar.gz so that other people can link to the latest version ... not sure if that is really a good idea or not
23:35:42 <bringert> I think it is a good idea
23:36:22 <stepcut> does your could keep old versions of the .tar.gz around if you do multiple releases ?
23:36:31 <bringert> though I'm not sure that it should be a symlink, I know many projects do that, but I don't like that the downloaded file is called hask-home-latest.tar.gz, it should have the version number. A 302 redirect would be better
23:36:49 <stepcut> bringert: yeah -- that was going to be my next suggestion :)
23:36:54 <bringert> stepcut: if you just uploadthe new one over the old, yes
23:37:27 <bringert> which the hask-home-upload.hs script does
23:37:41 <bringert> it could generate a .htaccess for the redirect
23:38:01 <vincenz> \o
23:38:03 <vincenz> o/
23:38:08 <vincenz> ~o~
23:38:26 <bringert> ah, haddock uses infix ! in patterns
23:38:28 <stepcut> bringert: cool stuff -- I will definately look into it
23:38:38 <bringert> HaskellDB broke on that too
23:39:02 <bringert> stepcut: you are welcome to contribute or fork
23:39:03 <goltrpoat> just curious, no particular question.. anyone here ever use F#?  looks like a .net-centric ocaml dialect, plus some .net-specific goodies like type reflection
23:39:37 <stepcut> goltrpoat: I am aware of it -- but never used it
23:40:23 <stepcut> bringert: currently it generates all static content, right ?
23:40:43 <goltrpoat> seems pretty nice, in certain aspects.  pisses me off to no end in other aspects, though
23:40:51 <goltrpoat> but that's more ocaml's fault than anything, probably
23:41:10 <bringert> stepcut: yes
23:42:05 <stepcut> bringert: I will probably look into it next weekend -- and hopefully put some stuff up
23:42:50 <stepcut> bringert: btw, did you need a copy of the RSS stuff ? I have not done anything new with it in ages
23:42:54 <vincenz> .o_ ~o_ ^o_ _o| _o~ _o^ (swimming crawl)
23:44:03 <bringert> stepcut: I've got an old one in one of my repos somewhere, I should be ok for now. I just figured that I ought to use the offcial one, now that installing cabal packages is so easy
23:44:16 <stepcut> bringert: cabal rocks
23:44:29 <stepcut> bringert: do you use debian ?
23:44:40 <bringert> ubuntu, when linux
23:44:46 <bringert> I recently bought a macbook
23:44:51 <stepcut> are you on the debian-haskell mailing list ?
23:45:00 <bringert> I run ubuntu in a virtual machine to build linux binaries
23:45:01 <vincenz> anyone know some monadic combinators for showing text?
23:45:05 <bringert> yes, I am
23:45:13 <bringert> since a few weeks
23:45:36 <stepcut> bringert: ok -- you probably saw I am trying to get a good reference package for debianizing cabal libraries then
23:45:48 <bringert> vincenz: you mean pretty printering? or something else?
23:45:57 <bringert> stepcut: yeah, I saw that
23:46:07 <stepcut> Arjan has some good feedback
23:46:09 <bringert> I haven't gotten into debian packaging yet
23:46:27 <vincenz> bringert: yeah
23:46:41 <vincenz> bringert: for indenting and such
23:46:50 <bringert> I don't know of any monadic ones
23:47:00 <bringert> why do they have to monadic?
23:47:01 * vincenz makes one
23:47:58 * stepcut goes to bed
