00:00:02 <Korollary> Imperative, sir!
00:00:24 <shapr> yikes!
00:01:33 <Korollary> It means nothing. I do it for the money.
00:02:16 <shapr> Sounds like me.
00:05:56 <alar> greetings
00:07:10 <Korollary> ?vixen
00:07:10 <lambdabot> I'm your huckleberry
00:07:12 <mauke> man, OOHaskell looks impressive
00:07:30 <Bobstopper> how might I detect cycles in a cyclic graph in haskell?
00:08:35 <mauke> write a recursive graph walker and a function halts :: (a -> b) -> a -> Bool
00:08:59 <Cale> Bobstopper: what sort of graph?
00:09:32 <Cale> Data.Graph?
00:10:29 <Bobstopper> I was thinking more arbitrary data constructs which may potentially have cycles in them...
00:10:35 <Cale> You can't
00:10:45 <Bobstopper> k
00:10:50 <Cale> In particular, you can't tell if lists are infinite
00:11:35 <mauke> isFinite list = halts length list  -- :-)
00:11:58 <Bobstopper> do any haskell compilers have any sort of extentions to be able to check if pointers are the same?
00:13:01 <Cale> well, if you're interested in low-level pointer equality, there are ways to get that, but it's not reliable
00:13:41 <Cale> (In GHC)
00:13:54 <Lemmih> @type GHC.Exts.reallyUnsafePtrEquality#
00:13:55 <lambdabot> forall a. a -> a -> GHC.Prim.Int#
00:15:09 <Bobstopper> hmm ok, thanks :)
00:19:55 <Cale> that doesn't really seem to work though...
00:20:25 <Cale> hmm, well, sometimes it does :)
00:20:45 <Cale> Prelude GHC.Exts> let a = 1 : a
00:20:45 <Cale> Prelude GHC.Exts> let (b:c) = a
00:20:45 <Cale> Prelude GHC.Exts> I# (reallyUnsafePtrEquality# a c)
00:20:45 <Cale> 0
00:20:51 <Cale> and sometimes it doesn't :)
00:21:09 <shapr> gwahr, halbum is still broken.
00:22:00 <Dreadshoot> if (ptra == ptrb)
00:22:37 <Cale> Of course, if you have actual Ptrs, then there's no problem comparing them
00:22:47 <Cale> They're in the class Eq
00:22:55 <Cale> so Dreadshoot's code will work there
00:24:37 <Dreadshoot> i ran into 2 wild boar kids when i was just out running :)
00:25:05 <Lokadin> is there anyway of writing types to file?
00:25:32 <shapr> Dreadshoot: You in norway?
00:25:39 <Dreadshoot> sweden
00:25:43 <shapr> What part of Sweden?
00:25:52 <Dreadshoot> abit south of stockholm
00:25:55 <shapr> Ah, ok
00:25:59 <shapr> I'm a bit north of Stockholm.
00:26:09 <Dreadshoot> uppsala?
00:26:12 <shapr> Boden ;-)
00:26:15 <Dreadshoot> :D
00:26:20 <Dreadshoot> yeah a bit
00:26:24 <shapr> But I'll be living in Stockholm end of the month.
00:26:37 <shapr> Bromma
00:27:00 <Dreadshoot> ah, im going to sthlm and shopping in about 2 hours or so
00:27:16 <shapr> I gotta organize some sort of regular #haskell gathering in Stockholm.
00:27:43 <Cale> Heh, http://thepiratebay.org/ is back online, and their logo is firing cannonballs at the Hollywood sign :)
00:27:44 <Dreadshoot> i hardly even know any haskell though, at least not yet
00:28:05 <shapr> Dreadshoot: It's worth learning.
00:28:08 <Dreadshoot> piratebay came up a few days ago
00:28:25 <Dreadshoot> like a day after it went down or so
00:28:29 <Cale> probably, I hadn't noticed
00:28:35 <shapr> Did the Swedish police file a case against them?
00:28:44 <Dreadshoot> dont know
00:29:11 <shapr> If the Swedish police file a case for hosting pointers to copyrighted content, then whether they win or not will make a big difference.
00:29:33 <shapr> If they lose, torrent sites can breathe easier, if they win, it's time for fascism.
00:29:42 <shapr> At least, that's my perception.
00:29:43 <Dreadshoot> mm, i almost only use c++ and i like it. I could see a use for haskell for some stuff though when you wanna fast develop something
00:30:40 <shapr> Seems to me that most commercial development is about speedy development and speedy change.
00:31:10 <Lokadin> so anyone know if data types can be saved to disk directly, so i can reinitiate the program later and just load the data types.
00:31:22 <Lokadin> er and info, or do i have to go through HaXml
00:31:26 <Korollary> Lokadin: What do you mean by loading data types?
00:31:33 <Dreadshoot> yes.. well i think you cant go out hunting single people at all for sharing when millions of people does it. Maybe whats torrentsites is legal but morally its a bit wrong, but they cant stop it this way anyway
00:32:11 <Dreadshoot> hunting single sites/people is just pathetic when there is so much
00:32:17 <Lokadin> Korollary: er well if i could write them to a file, then i want to also be able to load them, basically i'm making a mud, and i wanted to store the squares
00:32:34 <shapr> Someone estimated that more than 50% of the US uses something to download copyrighted mp3s. That implies to me that there's some serious split between the citizens and the law makers.
00:32:48 <Dreadshoot> heh yeah
00:33:09 <Korollary> Lokadin: I think you want to be able to load the data, not data types.
00:33:36 <Lokadin> and the squares would be data Map { description :: String }
00:34:03 <Cale> I find it amazing how many people on /. seem to assume that every country has the same laws as the US.
00:34:05 <Lokadin> oh okay, sorry, that's what i meant, it's  just i was unsure of wheter to call it data or types
00:34:11 <shapr> I think that's the real problem. The whole legal system was really designed to codify common practices in such a way that misbehaviour wouldn't disrupt the community. Right now common practices and the laws are pretty distant from each other.
00:35:25 <Dreadshoot> I have no problem with american laws in general, i think its a pretty good country(so is sweden) compare to many others. Though america got a few very strange laws and that is performed/used ever more odd in some states
00:35:45 <Cale> Lokadin: You could write matching instances of Read and Show for your datatypes, and then just print them. That can be inefficient though -- there are libraries for working with binary data if you need better.
00:36:10 <shapr> Yeah, I've lived in both countries for years, and they both have good points and bad points, like any other country.
00:36:51 * shapr laughs at this email: "To All Hope Users (that's you Shae),"
00:36:57 <Lokadin> Cale: well i just want to do something simple right now, so i could get a working example of the program
00:37:26 <Cale> Lokadin: usually the derived Read and Show are decent enough
00:37:50 <Pseudonym> Some countries have more bad points than good points.  Like, oh, countries with an actual civil war going on.
00:38:15 <Lokadin> Cale: kk
00:42:46 <Cale> Or countries that start needless wars.
00:45:10 <Lokadin> Cale: do you know anywhere i could find some example code or anything like that, maybe a reference of some kind?. i can't seem to find any examples of Read being used
00:46:37 <dons> yay, finaly squished a lambdabot bugs that's been bugging me for months
00:46:42 <dons> no, not the @remember bug though
00:47:10 <saintiss> hi
00:47:18 <saintiss> suppose I have this definition of a "drop" function:
00:47:18 <Lokadin> Cale: oh nm i found it in haddock
00:47:29 <saintiss> drp 0 l = l
00:47:29 <saintiss> drp n (x:xs) = drop (n-1) xs
00:47:38 <saintiss> how come drp 5 [1] doesn't yield an error then?
00:47:40 <Dreadshoot> dons: i wonder if someone will port lambdabot to win
00:47:47 <saintiss> it should call drp 4 [], and that should give an error
00:47:50 <dons> it's been done. should be fine.
00:47:53 <Korollary> saintiss: [1] == 1:[]
00:47:55 <dons> some plugins won'twork
00:48:11 <saintiss> ah, wait
00:48:12 <Dreadshoot> only plugin i need is eval :)
00:48:15 <saintiss> I made a mistake :)
00:48:32 <saintiss> nvm
00:48:43 <dons> Dreadshoot: that's probably moderately hard to port. you need hs-plugins. which has been ported.
00:48:44 <Dreadshoot> but i've hardly even used make files. I usually just code in VS
00:49:06 <dons> it has a cabal build system tnow
00:49:17 <dons> so no need for make
00:49:19 <Dreadshoot> aha
00:50:01 <dons> it'd be easier to install linux, than port lambdabot, though..
00:50:22 <dons> it runs in ghci too, which might be eveneasier
00:50:38 <Dreadshoot> well i got gentoo on a disk, but its not something i prefer to run
00:50:57 <dons> ?quit fixed @quit bug
00:51:16 <dons> ?version
00:51:33 <Dreadshoot> hmm, ghci exists for win i though, but how would you run it through that?
00:51:40 <Dreadshoot> though = think
00:51:41 <lambdabot> lambdabot 3.1p52, GHC 6.4.1 (Linux i686 3.20GHz)
00:51:43 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:52:10 <dons> with a little bit of work, you can jsut say: ghci Main.hs, with the right flags.
00:52:22 <dons> use the 'make way=ghci' target on linux to play with this mode
00:52:37 <dons> once you understand it, porting to windows wouldn't be too hard, i think
00:52:38 <Itkovian> @seen BCoppens
00:52:39 <lambdabot> I saw BCoppens leaving #haskell 7 hours, 47 minutes and 49 seconds ago, and .
00:53:24 <shapr> bringert: hiya!
00:53:32 <bringert> morning shapr
00:53:34 <shapr> bringert: photos still don't work, any ideas?
00:53:37 <bringert> you up already
00:53:52 <shapr> Yeah, stuff to do today.
00:53:57 <bringert> can upload, but not visible?
00:54:00 <shapr> yup
00:54:34 <bringert> weird
00:56:04 <bringert> shapr: I'm off to bed, I'll try to figure it out
00:56:10 <shapr> ok
00:57:36 <Lemmih> Cale: It always work. It's just _really_ unsafe (:
01:28:15 <Dulath> Hey folks. I'm trying to get my hypotenuse function to work, but it complains about scope, what am I doing wrong?
01:28:18 <Dulath> hypotenuse :: Num => Num -> Num
01:28:26 <Dulath> hypotenuse z = sqrt (x^2 + y^2)
01:28:38 <Itkovian> Dulath: that would be Num a => a -> a
01:28:47 <Dulath> Oh
01:30:18 <Dulath> Still getting the error
01:30:50 <Kasperle> that doesn't look quite right? where should x and why come from?
01:30:55 <Itkovian> obviously it doesn't know about x and y
01:31:12 <Dulath> Well, the arguments
01:31:14 <Itkovian> rather: hypothenuse x y = sqrt (x^2 + y^2)
01:31:25 <Itkovian> Dulath: you only provide z as argument
01:31:33 <Dulath> Oh, I see.
01:31:43 <Itkovian> Dulath: the syntax is: function-name arg1 arg2 ... argn = function-def
01:32:09 <Kasperle> hypothenuse :: Num a => a -> a -> a and then hypothenuse x y = sqrt( x^2 + y^2)
01:32:12 <Kasperle> how about that?
01:32:19 <Dulath> Yeah =/
01:38:31 <norpan> except sqrt requires a Floating
01:39:05 <Dulath> I figured that out pretty quick =)
01:42:02 <Cale> Lemmih: I meant for what he was trying to do
01:42:16 <Cale> (which was detect cycles in cyclic datastructures)
01:47:16 <Dulath> Any good tutorials/articles that cover Haskell type polymorphism and such? I'm supposed to use a Double as the type for my hypotenues function but now it's complaining that I'm using type constructor Double as a class.
01:48:37 <mauke> > let hypot :: Double -> Double -> Double; hypot x y = sqrt (x ^ 2 + y ^ 2) in hypot 3 4
01:48:38 <lambdabot>  5.0
01:48:51 <Cale> Classes and types are two separate things
01:48:59 <Cale> Num and Floating are classes of types
01:49:14 <Cale> (as are Show, Read, Eq, Ord, etc.)
01:49:42 <Cale> Integer, Int, Double, Float, [Integer], etc, are types.
01:50:19 <Cale> Types can have type variables in them, meaning that any type will work in place of the variable.
01:50:59 <Cale> Classes are used to restrict type variables, making it so that not just any type will work, only those for which there is an instance of the class.
01:51:03 <Dulath> So func :: Float a => a -> a -> a as opposed to func :: Double -> Double -> Double
01:51:13 <Cale> Floating
01:51:15 <Dulath> a is an instance of Float?
01:51:20 <falconair> has anyone been able to install GHC on osx intel through darwin ports?  I believe it can be done by forcing the ppc version, and letting rosetta translate it...i just don't know how
01:51:26 <mauke> Float is a type, not a class
01:51:41 <Cale> The class is called Floating
01:51:50 <Cale> Double and Float are instances
01:52:08 <Cale> func :: Floating a => a -> a -> a
01:52:20 <Cale> will specialise to  Float -> Float -> Float
01:52:28 <Cale> or to Double -> Double -> Double
01:52:41 <Cale> (or perhaps other types, if there are suitable instances)
01:53:05 <Dulath> Ok, I think I understand.
01:55:27 <dmhouse> dons: around?
01:59:21 <Lemmih> shapr: ping.
02:01:45 <beelsebob_> anyone tried to build hmake with ghc 6.5?
02:02:40 <beelsebob_> I'm getting ghc-6.5.20060526: unknown package: lang
02:05:36 <shapr> Lemmih: pong
02:05:45 * beelsebob_ pings shapr 
02:05:51 <dmhouse> beelsebob_: perhaps you need the lang package?
02:06:03 <beelsebob_> dmhouse: isn't it there by default?
02:06:05 <shapr> beelsebob_: pong?
02:06:09 * dmhouse wouldn't know
02:06:16 <beelsebob_> dmhouse: hmake will usually compile straight off the bat
02:06:21 <beelsebob_> first thing I build normally
02:06:31 <beelsebob_> shapr: just pinging you for pinging's sake :P
02:06:37 <Lokadin> is there a way of making a pointer to say one :: Cell to another? to indicate if they are connected
02:07:11 <shapr> Data.Graph.Inductive has one way connections, and you use two of them to denote a cycle.
02:07:26 <shapr> What sort of Cell are you talking about?
02:07:52 <Lokadin> er a Mud square
02:08:02 <Lokadin> so it needs to go to other Mud Cells
02:08:25 <Lokadin> so i need to have a way of showing that this Cell is related to that Cell
02:08:34 <shapr> Oh, why not Data.Graph.Inductive?
02:09:03 <shapr> Cale: Already seen it? -> http://us.metamath.org/mpegif/mmmusic.html
02:09:17 <Lokadin> .ui thanks i'll look into that 
02:09:51 <shapr> Inductive can be a pain sometimes, but in some ways it's very elegant.
02:12:45 <Lokadin> hmmm, what you think i should look into, graph tree or basic?
02:12:53 <Lokadin> or NodeMap?
02:13:29 <shapr> Not sure
02:13:53 <Lemmih> shapr: You have a cut-down version of the http package, right?
02:14:43 <shapr> It's standard now.
02:14:49 <shapr> pull the latest HTTP repo.
02:14:51 <Dulath> Ok, I'm writing an isEven function, and I want to determine even or oddness by doing something simple like if x `mod` 2 = 0 then even, if x `mod` 2 = 1 then odd, but I want to define the function peice-wise, so one version of the function for each of those two conditions. How do I go about doing that?
02:16:14 <mauke> huh? what two conditions? isEven x = x `mod` == 0
02:16:28 <mauke> er, `mod` 2
02:16:57 <dmhouse> Dulath: guard.
02:17:35 <dmhouse> > let isEven x | x `mod` 2 == 1 = false | otherwise = true in (isEven 4, isEven 5)
02:17:35 <lambdabot>  Not in scope: `true'
02:17:44 <dmhouse> > let isEven x | x `mod` 2 == 1 = False | otherwise = True in (isEven 4, isEven 5) -- oops :)
02:17:45 <lambdabot>  (True,False)
02:18:00 <dmhouse> Dulath: or, you use the simpler method that mauke mentioned.
02:18:08 <mauke> > map (not . toEnum . flip mod 2) [4,5]
02:18:08 <dmhouse> > let isEven x | x `mod` 2 == 0 in (isEven 4, isEven 5) -- oops :)
02:18:08 <lambdabot>  [True,False]
02:18:09 <lambdabot>  Parse error
02:18:21 <dmhouse> > let isEven x = x `mod` 2 == 0 in (isEven 4, isEven 5)
02:18:22 <lambdabot>  (True,False)
02:18:31 <dmhouse> mauke: show odd ;)
02:18:34 <dmhouse> *off
02:18:38 <dmhouse> gah, can't type this morning.
02:18:43 <Dulath> Uh
02:19:12 <Lokadin> shapr: hmmm, if i understand correctly you create a map from a list of nodes, but i need to be able to add nodes really fast.. so would i have to recreate the graph every time i add a node?
02:19:15 <Dulath> Ok, I haven't encountered == before.
02:19:20 <dmhouse> ? really?
02:19:25 <dmhouse> it's equality.
02:19:27 <dmhouse> > 4 == 4
02:19:27 <lambdabot>  True
02:20:07 <dmhouse> = is assignment, == is a test for equality
02:20:20 <Dulath> Huh, this is pretty nifty.
02:20:34 <dmhouse> e.g. let f x = x + 1. you're assigning the function x + 1 to the label f.
02:20:51 <dmhouse> but 4 == 4. This returns a Bool based on whether the two equate
02:21:36 <dmhouse> @hoogle catMaybes
02:21:36 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
02:21:58 <mauke> > toEnum 2 :: Bool
02:21:59 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
02:22:09 <shapr> Lokadin: No, you should be able to refer to the previously created graph and just add a node to it. That's much of the point of Inductive.
02:22:28 <Dulath> Sorry for my ignorance folks. I'm a wide-eyed Java/PHP coder in a strange land.
02:22:35 <dmhouse> hang on.
02:22:47 <dmhouse> You're a Java/PHP coder and you've _never_ used ==?
02:23:02 <mauke> module TDWTF where data Bool = True | False | FileNotFound deriving (Eq, Show, Enum)
02:23:07 <Dulath> No, I mean I havne't encountered in it Haskell yet
02:23:12 <dmhouse> ah, okay.
02:23:25 <dmhouse> yeah, well, roughly, (==) :: a -> a -> Bool.
02:23:30 <Dulath> I've just been fooling around with math functions so far
02:23:37 <mauke> bool isEven(int x) { return x % 2 == 0; } // Java
02:23:58 <dmhouse> function isEven($x) { return x % 2 == 0; } // PHP
02:24:03 <dmhouse> err
02:24:07 <dmhouse> function isEven($x) { return $x % 2 == 0; } // PHP
02:25:15 <dmhouse> Dulath: but note you can't use == on everything
02:25:33 <dmhouse> > let f x = (x+1)^2; g x = x^2 + 2x + 1 in f == g
02:25:34 <lambdabot>  add an instance declaration for (Num (a -> a))
02:25:48 <dmhouse> you can't compare functions, that means.
02:26:08 <mauke> [1&1-]e:  { False }
02:28:37 <Lokadin> shapr: oh okay
02:29:03 <dmhouse> mauke: ?
02:29:12 <dons> dmhouse: ?
02:29:16 <mauke> dmhouse: !
02:29:29 <dmhouse> dons, how do you get plugins enabled in this newfangled build system?
02:29:36 <dmhouse> config.mk.in is now ignored
02:29:53 <dmhouse> I'm using the Makefile for now, but as you say, I'd like to switch to Cabal
02:29:54 <mauke> False is a programming language
02:30:02 <dmhouse> mauke: aha.
02:31:22 <mauke> start-function push(1) bit-and push(1) sub end-function symbol(e) store comment(False)
02:32:15 <dmhouse> mauke: what's the 'e'? evaluate?
02:32:23 <mauke> no, just a symbol
02:32:51 <dmhouse> grm.
02:32:52 <dmhouse> *hrm
02:33:00 <dmhouse> and the sub?
02:33:22 <mauke> what about it?
02:33:34 <dmhouse> never mind.
02:40:59 <dmhouse> dons, ?
02:41:15 <dmhouse> I think I scared him off.
02:42:41 <dmhouse> > let f x = (x+1)^2; g x = x^2 + 2*x + 1 in f == g -- that's what my previous example should have been, and that's why it complained about Num and not Eq :)
02:42:41 <lambdabot>  add an instance declaration for (Eq (a -> a))
02:42:42 <lambdabot>   In the definition of `ojb'...
02:45:14 <norpan> dmhouse: you're trying to compare functions
02:45:25 <norpan> that's not generally possible
02:45:29 <bolrod> -.-
02:45:33 <dmhouse> norpan: yes, I know. I was giving an example to show that that wouldn't work.
02:45:41 <bolrod> norpan: you're trying to explain something he already knows
02:45:44 <norpan> ok
02:45:45 <bolrod> thats generaly useless
02:45:48 <bolrod> ;)
02:45:49 <dmhouse> hehe
02:46:16 <norpan> but dons knows that too?
02:46:22 <bolrod> who knows...
02:46:30 <norpan> nobody knows
02:46:35 <norpan> the troubles i see
02:46:37 <Dulath> I sure don't.
02:46:44 <norpan> nobody knows
02:46:57 <norpan> but lambdabot
02:47:06 <bolrod> ?vixen do you know?
02:47:06 <lambdabot> yeah, i know
02:47:11 <bolrod> yep
02:47:44 <norpan> ?vixen do you know the troubles i see?
02:47:44 <lambdabot> yeah, i know
02:49:04 <dmhouse> @instances Num
02:49:04 <lambdabot> Double, Float, Int, Integer
02:49:11 <dmhouse> good, patch has been applied.
02:53:01 <Lokadin> how do i retrieve a certain item out of a list?
02:53:42 <shapr> elemIndex ?
02:54:04 <dmhouse> (!!)
02:54:13 <dmhouse> > [1..5] !! 4
02:54:13 <lambdabot>  5
02:54:55 <Lokadin> cool thanks :)
02:55:59 <dmhouse> Lokadin: they're 0-based indices
02:56:02 <dmhouse> > [1..5] !! 0
02:56:03 <lambdabot>  1
02:56:16 <bolrod> last $ take 4 [1..10]
02:56:21 <bolrod> > last $ take 4 [1..10]
02:56:21 <lambdabot>  4
02:56:24 <bolrod> ;o
02:57:01 <Dulath> How does one get a cos^-1 in Haskell?
02:57:03 <dmhouse> > let listId xs = uncurry (!!) $ zip [0..length xs - 1] xs in listId "abcd"
02:57:04 <lambdabot>  Couldn't match `([a], Int)' against `[(a1, b)]'
02:57:07 <dmhouse> Dulath: acos
02:57:14 <Dulath> Ah, ok
02:57:19 <dmhouse> > let listId xs = uncurry (!!) $ zip (repeat xs) [0..length xs - 1] in listId "abcd"
02:57:19 <lambdabot>  Couldn't match `([a], Int)' against `[(a1, b)]'
02:57:23 <dmhouse> hrm.
02:57:32 <norpan> > acos 3.14
02:57:32 <lambdabot>  NaN
02:57:39 <bolrod> > acos 2
02:57:39 <lambdabot>  NaN
02:57:41 <bolrod> > acos 1
02:57:41 <lambdabot>  0.0
02:57:49 <norpan> > cos 3.14
02:57:50 <lambdabot>  -0.9999987317275395
02:57:55 <norpan> good bot
02:58:00 <dmhouse> > cos pi -- not that good
02:58:01 <lambdabot>  -1.0
02:58:04 <dmhouse> ooh
02:58:10 <dmhouse> > cos (2*pi) -- not that good
02:58:11 <lambdabot>  1.0
02:58:13 <dmhouse> ooh!
02:58:18 <dmhouse> it's normally rubbish with precision
02:58:30 <dmhouse> > sin (2*pi)
02:58:30 <norpan> > cos (12039801928398*pi)
02:58:30 <lambdabot>  -2.4492127076447545e-16
02:58:30 <lambdabot>  0.9999999832818307
02:58:32 <bolrod> :)
02:58:47 <bolrod> > sin (12*pi)
02:58:48 <lambdabot>  -1.4695276245868527e-15
02:58:59 <dmhouse> > let listId xs = uncurry (!!) $ zip (repeat xs) [0..(length xs - 1)] in listId "abcd"
02:58:59 <lambdabot>  Couldn't match `([a], Int)' against `[(a1, b)]'
02:59:03 <bolrod> > sin (pi)
02:59:03 <lambdabot>  1.2246063538223773e-16
02:59:07 <bolrod> > sin (pi::Float)
02:59:08 <lambdabot>  -8.742278e-8
02:59:14 <dmhouse> > let listId xs = map (uncurry (!!)) $ zip (repeat xs) [0..(length xs - 1)] in listId "abcd"
02:59:15 <lambdabot>  "abcd"
02:59:18 <dmhouse> finally :)
02:59:30 <bolrod> ?
02:59:37 <bolrod> and what does it do?
02:59:44 <dmhouse> it's the identity on lists.
02:59:53 <bolrod> aha!
02:59:56 <dmhouse> > let listId xs = map (uncurry (!!)) $ zip (repeat xs) [0..length xs - 1] in listId "abcd" -- parentheses aren't needed
02:59:57 <norpan> a very useful function indeed
02:59:57 <lambdabot>  "abcd"
02:59:58 <bolrod> > id "abcd"
02:59:59 <lambdabot>  "abcd"
03:00:33 <dmhouse> > let listId xs = zipWith (!!) $ zip (repeat xs) [0..length xs - 1] in listId "abcd"
03:00:34 <lambdabot>  Couldn't match `[a]' against `(a1, b)'
03:00:58 <dmhouse> > let listId xs = zipWith (!!) (repeat xs) [0..length xs - 1] in listId "abcd"
03:00:59 <lambdabot>  "abcd"
03:01:06 * roconnor wonders if he should allow undecidable instances
03:01:38 * dmhouse wonders if he should learn wget already
03:02:05 <bolrod> > let listId xs = zipWith ($) (inits xs)  (map (!!) [0..length xs])
03:02:06 <lambdabot>  Parse error
03:02:18 <bolrod> > let listId xs = zipWith ($) (inits xs)  (map (!!) [0..length xs]) in listId "abcd"
03:02:19 <lambdabot>  Couldn't match `b1 -> b' against `[a]'
03:03:12 <Dulath> flightDistance x y = 3963 acos (cos fst x cos fst y cos (snd x - snd y) + sin fst x sin fst y)
03:03:24 <Dulath> Does that look remotely like anything that will run?
03:03:34 <dmhouse> Dulath: looks like you're missing a few multiplication signs in there
03:03:50 <Dulath> Yeah, I guess I had my fingers crossed or something.
03:04:43 <roconnor> apparently undecidable instances lead to overlapping instances
03:05:26 <Dulath> flightDistance x y = 3963 * acos (cos fst x * cos fst y * cos (snd x - snd y) + sin fst x * sin fst y)
03:05:29 <Dulath> That look more realistic?
03:06:35 <dmhouse> almost
03:06:39 <dmhouse> cos (fst x) and so on
03:06:53 <Dulath> Ah, ok.
03:07:56 <roconnor> @pl flightDistance x y = 3963 * acos (cos fst x * cos fst y * cos (snd x - snd y) + sin fst x * sin fst y)
03:07:58 <lambdabot> flightDistance = (((3963 *) . acos) .) . ap (ap . ((+) .) . ap (ap . ((*) .) . (. cos fst) . (*) . cos fst) ((cos .) . (. snd) . (-) . snd)) ((. sin fst) . (*) . sin fst)
03:08:07 <dmhouse> haha, don't use that :)
03:08:13 <dmhouse> roconnor: especially as it's wrong.
03:08:56 <Dulath> flightDistance x y = 3963 * acos (cos (fst x) * cos (fst y) * cos (snd x - snd y) + sin (fst x) * sin (fst y))
03:09:17 <dmhouse> looks good
03:09:30 <dmhouse> Dulath: you could use some let bindings to make that more readable
03:09:48 <Dulath> Well, I'm defining functions in my module
03:11:07 <Dulath> Hehe, I don't think it works.
03:11:08 <dmhouse> also, you could do flightDifference (x1, y1) (x2, y2) = ... then use x1, y2, x2 and y2 instead of fst x, snd x, fst y and snd y respectively.
03:11:50 <Dulath> fightDistance (45.58,122.6) (44.12,123.22) => 5766.19etc
03:13:05 <shapr> aha!
03:13:07 <dons> dmhouse: around?
03:13:13 <dmhouse> dons, yep
03:13:14 * shapr figures out the markup
03:13:27 <dons> ok, just popped out for dinner. you have quetions?
03:13:33 <dons> like, adding a new plugin?
03:14:20 <dmhouse> yeah.
03:14:23 <dons> join #haskell-overflow, and we can chat about it
03:15:07 <shapr> Dang, bringert is sleeping.
03:16:54 <shapr> Yay! --> http://www.scannedinavian.com/hope/
03:17:18 <shapr> It even has an rss feed with full text, that'll make Itkovian happy.
03:20:49 <norpan> hey, proofs to music was funny
03:25:23 <Dulath> does haskell recognize the [ ( ) ] order of precedence brackets?
03:25:33 <Dulath> I know it does for ()
03:25:40 <Dulath> Not sure about [ ]
03:25:46 <norpan> what do you mean
03:26:09 <dons> > 3 * (4 + 2)
03:26:10 <lambdabot>  18
03:26:18 <dons> > 3 * 4 + 2
03:26:19 <lambdabot>  14
03:26:24 <norpan> each [ must be matched by ] so what's the precedence?
03:26:41 <dons> Dulath: can you explain more what you mean?
03:26:42 <Cale> [ ] are used to form lists
03:26:55 <Cale> > [1]
03:26:56 <lambdabot>  [1]
03:26:57 <Dulath> They're also used in math 
03:26:58 <Cale> > [1,2]
03:26:58 <lambdabot>  [1,2]
03:27:00 <Cale> > [1,2,3]
03:27:01 <lambdabot>  [1,2,3]
03:27:14 <Cale> > [1] + 5
03:27:15 <lambdabot>  add an instance declaration for (Num [a])
03:27:16 <Dulath> 8 * [ 5 + 6 * (2 +3) ]
03:27:23 <Cale> > 8 * [ 5 + 6 * (2 +3) ]
03:27:23 <lambdabot>  add an instance declaration for (Num [a])
03:27:28 <Cale> > 8 * ( 5 + 6 * (2 + 3) )
03:27:29 <norpan> no, you just use ( for everything
03:27:29 <lambdabot>  280
03:27:32 <dmhouse> Dulath: right, but in Haskell, they're used as lists, not as groupings.
03:27:53 <Dulath> Ok
03:28:09 <dons> are there really languages that use both [] and () for grouping? oh, i guess tex uses [] and {}
03:28:27 <norpan> [ and { are different things in tex
03:28:38 <Dulath> trying to mimic an equation and getting strange results
03:28:42 <norpan> i don't know any language that has that kind of redundancy
03:28:44 <dons> norpan, i can never tell when they're different, though ;)
03:29:08 <dmhouse> dons, [] arguments are optional.
03:29:26 <norpan> exactly, [] are used for optional arguments
03:29:39 <dons> interesting. i should read the tex book some day
03:31:04 <Lokadin> say is there any particular extension i should save haskell type data as?
03:31:35 <dons> Lokadin: ?
03:31:42 <dons> you mean, other than in a .hs file?
03:31:46 <shapr> .hsd ?
03:31:50 * shapr just made that up
03:31:55 <shapr> .lam ?
03:31:59 <shapr> .ski ?
03:32:00 <dons> type data? you mean type decarations?
03:32:12 <shapr> I think he means Read/Show persisted data.
03:32:14 <Lokadin> er the output of readsPerc
03:32:26 <dons> ah. anything is good :)
03:32:33 <dons> mine is in .hmp3db
03:32:33 <Dulath>  /join #fedora
03:32:37 <Dulath> Ack
03:32:38 <dons> so perhaps "db" is good :)
03:32:51 <Lokadin> lol kk :) thanks
03:34:59 * dons `map` dvds
03:37:21 <Lokadin> say, i want to make a type that is a list of another type i made. so i type data Map = Map {[Cell]} deriving Read Show
03:37:30 <Lokadin> but it tells me parse error on [
03:38:12 <Lokadin> i don't really understand why
03:38:45 <Lokadin> or what to do about it
03:39:05 <Lokadin> or could i just do
03:39:38 <Lokadin> type Map = [Cell] would it still derive Read and Show?
03:42:23 <beelsebob_> silly hmake Makefile
03:55:46 <Lokadin> say it's giving me error on <- for
03:56:23 <Lokadin> addCellToMap map = putStrLn "title = " title' <- getLine
03:56:53 <Lokadin> er oi nm
03:57:03 <Lokadin> .oiro'a
04:17:13 <Lokadin> can i do, read (show map ++ show $ Cell {title,info})
04:17:27 <Lokadin> cause it gives me error when parsing Cell
04:17:41 <Lokadin> do i have to make a let statement?
04:17:45 <Lokadin> hmm
04:18:28 <alar> what is Cell {title,info}? maybe you want Cell {title=_title, info=_info} ?
04:20:23 <Lokadin> oh, there is no way to shorten it?
04:20:42 <kosmikus> Cell title info
04:20:55 <alar> yes
04:20:56 <Lokadin> oh cool thanks :)
04:21:05 <Lokadin> er that's not it?
04:28:13 <dmhouse> @localtime dons
04:28:16 <lambdabot> Local time for dons is Thu Jun  8 21:19:34 2006
04:29:38 <JKnecht> @localtime JKnecht
04:29:41 <lambdabot> Local time for JKnecht is Thu Jun  8 06:35:29 2006
04:31:22 <dmhouse> Okay, would something like this be useful?
04:31:35 <dmhouse> (ignore lambdabot's error messages)
04:31:50 <Lokadin> No instance for (Read (IO t))
04:31:50 <Lokadin>       arising from use of `read' at Map.hs:58:3-6
04:31:50 <Lokadin>     Probable fix: add an instance declaration for (Read (IO t))
04:31:59 <dmhouse> @tell dmhouse I remembered something useful which I forgot to tell you. Never fear, lambdabot's here!
04:31:59 <hsbot> Consider it noted.
04:31:59 <lambdabot> Maybe you meant: help keal spell
04:32:07 <dmhouse> ... two hours later ...
04:32:09 <dmhouse> @messages
04:32:09 <lambdabot> Unknown command, try @list
04:32:09 <hsbot> dmhouse said, less than a minute ago: I remembered something useful which I forgot to tell you. Never fear, lambdabot's here!
04:32:27 <dmhouse> Obviously you wouldn't normally leave a message for yourself.
04:32:33 <alar> dmhouse: there is messaging in lambdabot
04:32:39 <alar> for privileged users
04:32:52 <dmhouse> alar, which command?
04:33:05 <Lokadin> er how do i make an instance declaration for Read (IO t)
04:33:10 <alar> @privmsg
04:33:10 <hsbot> Unknown command, try @list
04:33:10 <lambdabot> Unknown command, try @list
04:33:13 <dmhouse> Lokadin: you don't.
04:33:44 <dmhouse> Lokadin: you're doing something else wrong.
04:33:50 <dmhouse> @help privmsg
04:33:50 <hsbot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:33:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:33:56 <dmhouse> @help @privmsg
04:33:56 <hsbot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:33:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:33:57 <alar> err
04:33:58 <Lokadin> dmhouse: then how do i get it to work? i'm doing a read on raw text from a file
04:34:23 <dmhouse> Lokadin: pastebin some code
04:34:32 <Lokadin> @lisppaste
04:34:32 <dmhouse> pastebin what you've got so far.
04:34:32 <lambdabot> Unknown command, try @list
04:34:32 <hsbot> Unknown command, try @list
04:34:37 <dmhouse> @where paste
04:34:37 <lambdabot> http://paste.lisp.org/new/haskell
04:34:37 <hsbot> http://paste.lisp.org/new/haskell
04:34:46 <BCoppens> Itkovian: thanks for the mail :)
04:34:46 <dmhouse> @part
04:34:47 <lambdabot> Not enough privileges
04:34:57 <alar> @message
04:34:57 <hsbot> You don't have any new messages.
04:34:57 <lambdabot> Unknown command, try @list
04:35:11 <Itkovian> BCoppens: you are welcome
04:35:14 <BCoppens> :)
04:35:19 <dmhouse> @tell alar This is how it works.
04:35:19 <lambdabot> Maybe you meant: help keal spell
04:35:19 <hsbot> Consider it noted.
04:35:29 <dmhouse> alar, now you @mesages.
04:35:33 <dmhouse> *@messages
04:35:34 <lisppaste2> Lokadin pasted "Map" at http://paste.lisp.org/display/21012
04:35:59 <Lokadin> it's the loadMap function
04:36:18 <dmhouse> Lokadin: that should work
04:36:22 <dmhouse> oh
04:36:23 <dmhouse> almost.
04:36:26 <dmhouse> return (read raw)
04:36:34 <Lokadin> oh okay :) thanks
04:37:32 <Lokadin> Map.hs:58:11:
04:37:33 <Lokadin>     Ambiguous type variable `a' in the constraint:
04:37:33 <Lokadin>       `Read a' arising from use of `read' at Map.hs:58:11-14
04:37:33 <Lokadin>     Possible cause: the monomorphism restriction applied to the following:
04:37:33 <Lokadin>       loadMap :: IO a (bound at Map.hs:56:0)
04:37:35 <Lokadin>     Probable fix: give these definition(s) an explicit type signature
04:37:37 <Lokadin>                   or use -fno-monomorphism-restriction
04:37:40 <Lokadin> Failed, modules loaded: none.
04:38:00 <dmhouse> Lokadin: uncomment your type annotation for loadMap
04:38:21 <Lokadin> oh okay:) thanks, i did it just as you said it
04:38:29 <Lokadin> it works .uisai!
04:38:45 <dmhouse> Lokadin: what does that even mean?!
04:38:55 <Lokadin> very happy
04:38:55 <Lokadin> lol
04:39:04 <dmhouse> how?
04:39:12 <Lokadin> .ui = happy, sai = very
04:39:30 <dmhouse> In which language?
04:39:43 <Lokadin> .ui is the attitudinal for happiness, and sai can be added to say that you are feeling this emotion to the extreme in Lojban
04:39:58 <dmhouse> You've lost me.
04:40:32 <Lokadin> you can say .uinai meaning un happy as nai negates, or .uiro'a means happy socaially as ro'a means socially
04:41:06 <Lokadin> .ui pronounced "wee" is a vocalization of joy,
04:41:09 <alar> dmhouse: I forgat the name of command
04:41:13 <alar> but there is one
04:41:20 <alar> for messaging
04:41:26 <alar> @messages
04:41:26 <hsbot> You don't have any new messages.
04:41:26 <lambdabot> Unknown command, try @list
04:42:16 <shapr> coi Lokadin .i xu do tavla mi bau la lojban
04:42:27 <dmhouse> alar, well, does it message immediately?
04:42:59 <shapr> komodo
04:44:02 <Lokadin> why would you want to talk about languages in lojban?
04:44:44 <Lokadin> i guess if i was fluent i would have the capacity to, and it would give a unique perspective
04:44:55 <dmhouse> alar, the point of my plugin is to leave a message with lambdabot, which you then pick up at a later time.
04:45:01 <Lokadin> but at current it's a little too high level for me 
04:45:07 <shapr> It just means yes/no you speak to me in the language of lojban.
04:45:16 <dmhouse> alar, we have similar functionality in #wordpress and it gets used more than any other bot feature.
04:45:18 <psi> what does the dots mean?
04:45:25 <alar> dmhouse: I don't know, I don't have privilegies
04:45:28 <dmhouse> shapr, Lokadin: is this a real language?
04:45:30 <shapr> With tavla I could have used fo la lojban
04:45:34 <shapr> dmhouse: Yup, since 1956
04:45:42 <dmhouse> Ah. A conlang?
04:45:51 <shapr> James Cooke Brown started lojban for several reasons.
04:46:11 <shapr> pesco gave a presentation on lojban at the recent CCC meeting. You can get the video from datagalaxy.tk
04:46:16 * shapr gets url
04:46:37 <shapr> dmhouse: er, do you want the url to pesco's presentation?
04:46:59 <dmhouse> hehe
04:47:03 <dmhouse> What's special about it?
04:47:07 <dmhouse> briefly
04:47:09 <shapr> The presentation or the language?
04:47:19 <shapr> Lojban is based on predicates.
04:47:31 <shapr> It also has a yacc grammar.
04:47:41 <shapr> So it's completely computer parsable.
04:47:46 <dmhouse> hah :)
04:47:58 <shapr> lambdabot used to have a cilre plugin.
04:48:19 <shapr> It called jvocuhadju (lojbanic type of fish, aka babblefish)
04:48:39 <shapr> er wait, jvocuhadju is the root finder..
04:48:44 <shapr> jbofi'e is the fish
04:48:53 <dmhouse> hmm... shapr, you'd probably know. Where in lambdabot does it specify which characters it looks out for? As in, lambdabot currently looks out for @ and ?
04:49:26 <shapr> Even though I wrote that code originally, I don't remember.
04:49:38 <alar> what is #wordpress ? 
04:49:39 <dmhouse> would it be decodeMessage in IRC.hs?
04:49:43 <shapr> Maybe
04:49:59 <dmhouse> alar, WordPress is the dominant blog software, written in PHP. http://wordpress.org
04:50:01 <shapr> I know that I just stuffed the plugin calls into whatever function gets input from the server.
04:50:12 <shapr> But dons did a bunch of cleaning in lambdabot.
04:50:40 <Lokadin> lambabot is not GPL :(
04:50:59 <dmhouse> Lokadin: what do you want to do with it?
04:51:19 <shapr> What license is lambdabot?
04:51:21 <shapr> BSD3?
04:51:41 <Cale> shapr: didn't you write it originally?
04:51:54 <Lokadin> dmhouse: nothing, it's just a matter of principle
04:52:05 <shapr> What, lambdabot? No, Pseudonym did.
04:52:18 * shapr looks for logs...
04:52:20 <Cale> ah, okay
04:52:54 <roconnor> The stuff you can do with multi-parameter type classes is amazing
04:53:19 <Cale> roconnor: yeah :)
04:54:07 <shapr> First appearance of lambdabot: 09.16.2002
04:54:15 <Lokadin> dmhouse: besides, isn't it impossible to use BSD code in GPL code because of no sub-licensing? GPL is the only thing BSD protects against isn't it?
04:54:39 <shapr> lambdabot is nearly four years old!
04:54:47 <dmhouse> grr. stupid crashy emacs.
04:55:44 <Lokadin> dmhouse: but it's not too bad as yi is GPL and also has that nifty fully-dynamic thing going
04:55:44 <shapr> Oh, I didn't write the code for the command chars, Pseudonym did.
04:55:59 <dmhouse> shapr, ah. So you don't know where it is?
04:56:19 <shapr> I used to know where it is...
04:56:27 <shapr> Tried the basemodule?
04:56:48 * shapr darcs pulls lambdabot
04:56:57 <Cale> Lokadin: I was unaware of that restriction (regarding BSD and GPL code)
04:56:57 <dmhouse> ah, gotcha.
04:56:58 <dmhouse> thanks.
04:57:14 <dmhouse> @quit
04:57:14 <lambdabot> Not enough privileges
04:57:19 <shapr> Lokadin: What? Are you sure?
04:57:50 <Cale> From what I understood, it's possible to use BSD code from GPL code, but not vice versa (without slapping a GPL license on)
04:57:51 <pesco> Lokadin, shapr: There isn't anything stopping you from using BSD code in an otherwise GPL program. (AFAICT, IANAL, BIAPS)
04:58:19 <Cale> heh, that should all become one acronym
04:58:20 <pesco> Cale: That's true.
04:58:32 <Cale> afaictianalbiaps
04:58:33 <psi> @wtf BIAPS
04:58:35 <lambdabot> No match for "BIAPS".
04:58:46 <Cale> But I Am Pretty Sure, most likely
04:58:48 <pesco> "but I am pretty sure"
04:58:55 <psi> heh, ok
04:59:01 <shapr> BIAPSML
04:59:04 <Cale> I'd never seen that acronym before, but it was easily guessed :)
04:59:08 <dmhouse> @wtf+ BIAPS But I am Pretty Sure
04:59:08 <lambdabot> Unknown command, try @list
04:59:11 <dmhouse> :(
05:00:57 <Lokadin> well i know that when writing the linux kernel, the original packet system or what not had to be rewritten in a clean room, using a guide, with a person that had no previous exposure to the BSD code which was made for the exact same reason
05:01:32 <shapr> Can you give references for that?
05:01:59 <Lokadin> er hold on, i remmber it was in refernce to some code SCO had said was stolen from them
05:02:19 <Kasperle> maybe that was because of the old bsd license containing the advertising clause?
05:03:03 <Lokadin> http://perens.com/SCO/SCOSlideShow.html
05:03:22 <Lokadin> BPF is under the BSD license. That license allowed SCO to legally copy the code into Unix System V in 1996, but since SCO doesn't own the code, they have no right to prevent others from using it.
05:03:32 <Lokadin> The Linux version of BPF is not an obfuscation of the BPF code. It is a clean-room re-implementation of BPF by Jay Schulist of the Linux developers, sharing none of the original source code, but carefully following the documentation of the Lab's product. 
05:04:11 <Lokadin> Had Schulist chosen to directly use the Lab's code, it still would have been legal.
05:04:13 <alar> @help wtf
05:04:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:04:14 <Lokadin> oh nm
05:04:22 <dmhouse> @help @wtf
05:04:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:04:25 <dmhouse> hmm
05:04:27 <Lokadin> i guess i misread it the first time i read it 
05:04:28 <dmhouse> must not be documented.
05:04:57 <alar> there is no help for @put-shapr also
05:05:10 <Cale> @help quote
05:05:10 <lambdabot> quote <nick>
05:05:10 <lambdabot> remember <nick> <quote>
05:05:10 <lambdabot> Quote somebody, a random person, or save a memorable quote
05:05:18 <Cale> @help
05:05:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:05:22 <Cale> @help list
05:05:22 <lambdabot> list [module|command]
05:05:23 <lambdabot> show all commands or command for [module]
05:05:30 <Cale> @list modules
05:05:30 <lambdabot> No module "modules" loaded
05:05:32 <Cale> @list module
05:05:32 <lambdabot> No module "module" loaded
05:05:37 <dmhouse> @list
05:05:37 <lambdabot> list [module|command]. Where modules is one of:
05:05:37 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact fresh haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system
05:05:37 <lambdabot> todo topic type unlambda version vixen where
05:05:39 <shapr> @quote
05:05:40 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
05:05:40 <Cale> ah
05:05:47 <dmhouse> Cale, i think it's incorrect documentation.
05:06:00 <Lokadin> kk well i g2g to sleep, i have to go to my gf prom today, so i g2 get up in 4 hours
05:06:03 <Lokadin> co'o
05:06:12 <shapr> co'o
05:06:12 <pesco> Which module is @wtf from?
05:06:20 <shapr> @wtf wtf
05:06:21 <lambdabot> No match for "wtf".
05:06:23 <Cale> @list dict
05:06:23 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
05:06:26 <shapr> @wtf ianal
05:06:27 <lambdabot> No match for "ianal".
05:06:35 <shapr> @wtf help
05:06:35 <Cale> @dict-help
05:06:36 <lambdabot> *** "help" wn "WordNet (r) 2.0"
05:06:37 <lambdabot> help
05:06:37 <lambdabot>   n 1: the activity of contributing to the fulfillment of a need or
05:06:37 <lambdabot>     furtherance of an effort or purpose; "he gave me an
05:06:37 <lambdabot>     assist with the housework"; "could not walk without
05:06:38 <lambdabot> [28 @more lines]
05:06:40 <lambdabot> I perform dictionary lookups via the following 13 commands:
05:06:42 <lambdabot>  @all-dicts .. Query all databases on dict.org
05:06:44 <lambdabot>  @devils ..... The Devil's Dictionary
05:06:46 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
05:06:48 <lambdabot>  @elements ... Elements database
05:06:50 <lambdabot> [9 @more lines]
05:06:53 <shapr> Maybe it's matching wtf to wn?
05:07:09 <Cale> yes
05:07:10 <shapr> I think so.
05:07:13 <pesco> Ah. :(
05:07:35 <alar> @help wn
05:07:35 <lambdabot> I perform dictionary lookups via the following 13 commands:
05:07:35 <lambdabot>  @all-dicts .. Query all databases on dict.org
05:07:35 <lambdabot>  @devils ..... The Devil's Dictionary
05:07:35 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
05:07:35 <lambdabot>  @elements ... Elements database
05:07:37 <lambdabot> [9 @more lines]
05:07:44 <Cale> @more
05:07:45 <shapr> pesco: Hey! see my new blog! http://www.scannedinavian.com/hope/ 
05:07:45 <lambdabot>  @foldoc ..... The Free On-line Dictionary of Computing
05:07:45 <lambdabot>  @gazetteer .. U.S. Gazetteer (1990)
05:07:45 <lambdabot>  @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
05:07:45 <lambdabot>  @jargon ..... Jargon File
05:07:47 <lambdabot>  @lojban ..... Search lojban.org
05:07:49 <lambdabot> [4 @more lines]
05:07:50 <Cale> @more
05:07:53 <lambdabot>  @vera ....... V.E.R.A.: Virtual Entity of Relevant Acronyms
05:07:55 <lambdabot>  @web1913 .... Webster's Revised Unabridged Dictionary (1913)
05:07:57 <lambdabot>  @wn ......... WordNet (r) 1.7
05:07:59 <lambdabot>  @world02 .... CIA World Factbook 2002
05:08:09 <Cale> @vera BIAPS
05:08:10 <lambdabot> No match for "BIAPS".
05:08:15 <shapr> Notice that I'm not the only person posting on the blogroll though.
05:08:20 <shapr> That's not my cat.
05:08:21 <Cale> @vera IANAL
05:08:22 <lambdabot> *** "ianal" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
05:08:22 <lambdabot> IANAL
05:08:22 <lambdabot>   I Am Not A Lawyer (telecommunication-slang, Usenet, IRC)
05:08:22 <lambdabot>  
05:08:39 <pesco> shapr: Cool.
05:08:56 <Cale> @vera TNMC
05:08:58 <lambdabot> No match for "TNMC".
05:09:01 <Cale> aww
05:09:14 <shapr> Of course Hope is in Haskell.
05:09:49 <Cale> @vera YHBT YHL HAND
05:09:52 <lambdabot> No match for "YHBT".
05:09:52 <lambdabot> No match for "YHL".
05:09:52 <lambdabot>  
05:09:52 <lambdabot> *** "hand" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
05:09:52 <lambdabot> HAND
05:09:54 <lambdabot>   Have A Nice Day (telecommunication-slang, Usenet, IRC)
05:09:56 <lambdabot>  
05:13:00 <mauke> @jargon YHBT
05:13:01 <lambdabot> *** "YHBT" jargon "Jargon File (4.3.1, 29 Jun 2001)"
05:13:01 <lambdabot> YHBT // [Usenet: very common] Abbreviation: You Have Been Trolled (see
05:13:01 <lambdabot>  {troll}, sense 1). Especially used in "YHBT. YHL. HAND.", which is
05:13:01 <lambdabot>  widely understood to expand to "You Have Been Trolled. You Have Lost.
05:13:01 <lambdabot>  Have A Nice Day". You are quite likely to see this if you respond
05:13:03 <lambdabot> [3 @more lines]
05:13:41 <Cale> yep
05:14:19 <MarcWeber> What is wrong here? Packaging simplest .jar executable http://www.rafb.net/paste/results/YHCTmg86.html
05:14:27 <MarcWeber> oh sry
05:14:59 <shapr> MarcWeber: Use cabal?
05:15:01 * shapr grins evilly
05:16:11 <MarcWeber> I'd like to..
05:16:40 <alar> @more
05:16:40 <lambdabot>  incautiously to a flame-provoking post that was obviously floated as
05:16:40 <lambdabot>  sucker bait.
05:16:40 <lambdabot>  
05:21:41 <alar> is it hard to add, say, unix manpages to lambdabot?
05:21:59 <aleator> Hello. It's me with questions again. If I have function "do let foos = parMap rnf f bar; let bars = parMap rnf g foos; <something that uses foos but not bars>; return foos" does bars get evaluated?
05:22:23 <Cale> no
05:22:39 <Cale> If you don't use a definition, it won't be used.
05:22:55 <aleator> Ok. And rnf doesn't mess with this?
05:23:08 <dmhouse> > let f = error "Aaaargh!!!" in 4
05:23:09 <lambdabot>  4
05:23:11 <shapr> Haskell is sooo much fun to write.
05:23:13 * shapr boings happily
05:23:21 * shapr hacks on Hope, adding user limits to the blog display.
05:23:41 <dmhouse> mmm... blogging in Haskell :)
05:23:49 <Cale> oh, you're using Control.Parallel.Strategies?
05:23:50 <dmhouse> shapr, where is this? I may be forced to check it out
05:24:01 <shapr> http://hope.bringert.net/
05:24:04 <aleator> Cale: Yes. That's why I'm asking :)
05:24:14 <shapr> dmhouse: And now, http://www.scannedinavian.com/hope/
05:24:30 <Cale> well, it still shouldn't be
05:24:36 <Cale> since you never refer to it
05:24:58 <aleator> Ok.. I'll assume that. Thanks Cale.
05:24:59 <Cale> there's no way to put something inside a definition which will force that definition to be evaulated
05:25:10 <Cale> evaluated*
05:25:20 <aleator> Ah. That is good to know.
05:25:40 <Cale> (seq and friends just attach the evaluation of various expressions to that of others)
05:25:45 <kpreid_> shapr: are you awake? :)
05:25:54 <aleator> Paraller.Strategies, even as neat as it is does complicate some things..
05:26:05 <shapr> kpreid_: Sort of
05:26:29 <aleator> But hey. If i can change map to parMap rnf and make the thing run 5 times faster, I'm not complaining.. :)
05:27:07 <shapr> kpreid_: Wassup?
05:27:13 <Cale> Do you actually have that many processors?
05:27:25 <alar> can I use records in multi-constructor datatype?
05:27:28 <kpreid_> shapr: I've got a type system problem with trying to replace IO with ST in that bit-of-E-in-Haskell that I mentioned
05:27:45 <aleator> Cale: I've got eight.
05:27:57 <alar> e.g. data X = Ex1 {type::Int,value::Int} | Ex2 {label::String}
05:28:04 <shapr> kpreid_: I don't think I have the spare brain power to help you with that today.
05:28:12 <aleator> Cale: Or the university has.. But no one else is using them.
05:28:12 <Cale> cool :)
05:28:17 * shapr passes the buck to Cale or someone else smart.
05:28:19 <roconnor> alar: I beleive so, with some restrictions.
05:28:33 <kpreid_> I should have just asked here
05:28:46 <kpreid_> , I suppose, but I wanted to try someone with interest in the code first :)
05:28:47 <aleator> Hmm.. There is some java process hogging one core..
05:29:00 <shapr> I'm interested, just don't have the spare cycles.
05:29:22 <Cale> alar: yes, try it :)
05:30:02 <Cale> alar: applying the functions given by labels to values which don't have that label is a runtime error though
05:30:05 <alar> thanks, will try if I run into those restrictions occasionally
05:30:45 <roconnor> the restriction is something like, if two fields have the same name, they have to have the same type.
05:30:51 <alar> Cale: with pattern matching it is ok to have those errors
05:31:40 <Cale> aleator: Is it nachos? That's what ends up clogging all the machines at UWaterloo for a good portion of the year :)
05:32:52 <Cale> er, hmm... I thought it was written in Java...
05:33:07 <Cale> ah, yes
05:33:12 <shapr> Man I love this language. After years of web programming in Python, Haskell is like suddenly using a backhoe instead of a shovel.
05:33:16 <aleator> Cale: No. We're too boring. It is likely femlab.
05:33:16 <roconnor> oh!!!
05:33:26 <roconnor> ghc-6.4: panic! (the `impossible' happened, GHC version 6.4):
05:33:31 <roconnor> what do I do!
05:33:34 * roconnor panics
05:33:41 <shapr> That's impossible!
05:33:42 <dmhouse> I get that all the time.
05:33:58 <shapr> roconnor: Try rm -rf **/*.{o,hi} and rebuild.
05:34:01 <kpreid_> my code is at http://paste.lisp.org/display/20841#2 -- both the IO and ST versions
05:34:44 <roconnor> shapr: still panics.
05:34:46 <kpreid_> the problem, as you will see if you try to load the third one, is that the type of 'call' applied to one argument is somehow introducing two distinct 's'es
05:34:54 <kpreid_> Cale? :)
05:34:54 <dmhouse> shapr, that is a lot of dependencies for hope!
05:35:14 <Cale> kpreid_: I'll have a look :)
05:35:17 <dmhouse> We _really_ need cabal-get. :)
05:35:18 <roconnor> this is what I get for using multi-parameter type classes?
05:35:38 <dmhouse> roconnor: those that live by the bleeding edge... Although MPTCs aren't exactly bleeding edge.
05:36:22 <kpreid_> Cale: try commenting out demo*, loading the result, then compare the type of 'call 1' and 'call (ref 1)', which *should* be identical
05:36:28 <roconnor> anyhow, I was just trying to see if I could generalize the types of my code.  I'll just revert my work
05:36:41 <kpreid_> note that this is the first time I've used either existential types or the ST monad
05:40:09 <Cale> hmm
05:40:10 <shapr> dmhouse: Yeah, it has a bunch of deps, but it's worth it.
05:40:21 <shapr> dmhouse: Agreed, cabal-get would make my life so much easier.
05:40:28 <kpreid_> Cale: also, it works as I expect if use 'call2' instead of 'call'
05:41:12 <Cale> well, the types are pretty much the same
05:41:21 <kpreid_> but I don't see why using AnyRef s instead of (Ref s r) => r prevents the s from splitting
05:41:46 <Cale> it's just being more general, I think
05:41:54 <Cale> no?
05:42:12 <kpreid_> no
05:42:22 <kpreid_> ST needs all the s to be the same
05:42:32 <Cale> well, yes :)
05:42:44 <kpreid_> I get errors like "No instance for (Ref s (STRef s (AnyRef s1)))" (which is true)
05:43:03 <kpreid_> there is, however, one for Ref s (STRef s (AnyRef s))
05:43:05 <dons> shapr, petekaz had this nice idea to add 'contextual' plugins to lambdabot. we hacked over the last few hours, and now you can write plugins that inspect all channel input, not just ones with lambdabot commands, and then respond
05:43:22 <dons> so we should be able to do, say, inline commands, or looking up url titles when urls appear inline
05:43:28 <dons> statistics, a better log modules
05:43:32 <dons> probably other stuff too
05:43:41 <dons> for example:
05:43:44 <dons> ?vixen-on
05:43:44 <lambdabot> What's this channel about?
05:43:46 <dons> hey!
05:43:47 <lambdabot> hiya
05:43:48 * roconnor makes a minimal test case
05:43:48 <lambdabot> i find it hard to masturbate when the lights are on.
05:43:50 <dons> so what's new vixen
05:43:51 <lambdabot> being a vixen isn't as easy as it sounds
05:43:55 <dons> ?vixen-off
05:43:55 <lambdabot> Bye!
05:44:01 <dmhouse> dons, that'd be perfect.
05:44:07 <dons> shapr: whaddya think :)
05:44:22 <dmhouse> dons, I wrote another plugin, wanna see? :)
05:44:24 <dons> also, we could finally port megamonad
05:44:27 <dons> dmhouse: yes please!
05:44:37 <kpreid_> Cale: so, it may well be 'more general', but it doesn't work :)
05:44:37 <dons> make sure you pull with the latest patches, too.
05:44:37 <dmhouse> hang on, let me load my lambdabot.
05:44:46 <roconnor> @lisp-paste
05:44:47 <lambdabot> Unknown command, try @list
05:44:47 <dons> dmhouse: also, are you running in ghci? does it work nicely ?
05:44:54 <roconnor> @paste
05:44:54 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:44:56 <kpreid_> Cale: and I'd like to avoid having call and call2 around
05:45:03 <dmhouse> oh, hang on, I broke it a moment ago. Lemme fix first
05:45:50 <dons> here's my nice code snippet of the day:
05:45:51 <dons> forkLB f = (`liftLB` f) $ \g -> do
05:45:51 <dons>             forkIO $ do
05:45:51 <dons>                 timeout (15 * 1000 * 1000) g
05:46:05 <dons> lift a function from io into the LB monad, fork it, and also time it out
05:46:09 <dons> haskell rules :)
05:46:21 <dmhouse> you don't need that first do
05:46:25 <dmhouse> unless you didn't paste all of it
05:46:31 <dons> you do, there's a return () i'm leaving off ;)
05:46:39 <dons> forkLB :: LB a -> LB ()
05:46:42 <lisppaste2> roconnor pasted "can someone test this in the darcs version of GHC?" at http://paste.lisp.org/display/21014
05:46:53 <shapr> dons: It's awesome!
05:46:59 <dons> ?vixen-on
05:47:00 <lambdabot> What's this channel about?
05:47:06 <dons> vixen, you like shapr?
05:47:06 <lambdabot> i'd say i like
05:47:14 <dons> what about haskell in general?
05:47:15 <lambdabot> church is my favourite computer scientist.
05:47:23 <dons> well, that's cool. good karma for that
05:47:24 <lambdabot> i'm glad you think so
05:47:40 <dmhouse> dons, that's cool. Is that new?
05:47:40 <lambdabot> i'm glad you think so
05:47:43 <dmhouse> err
05:47:43 <lambdabot> eh?
05:47:48 <dons> ?vixen-off
05:47:49 <lambdabot> Bye!
05:47:56 <shapr> That's so cool :-)
05:47:59 <dons> dmhouse: yeah, petekaz and i hacked it up in the last few hours
05:48:04 <dmhouse> nice.
05:48:05 <dcoutts_> heh
05:48:05 <Cale> ah, I see...
05:48:07 <alar> vixen-mode! nice
05:48:07 <Cale> hmm
05:48:12 <dmhouse> anyway, welcome, hsbot.
05:48:13 <dmhouse> @karma
05:48:13 <lambdabot> You have a karma of 2
05:48:13 <hsbot> You have a karma of 0
05:48:19 <dons> roconnor: $ ghc-6.5 A.hs
05:48:19 <dons> A.hs:6:0: Class `Vector' used as a type
05:48:25 <dmhouse> @join #haskell-overflow
05:48:25 <lambdabot> Not enough privileges
05:48:33 <roconnor> dons: but no panic
05:48:41 <dmhouse> dons, I'll give you the sales pitch in #haskell-overflow
05:48:41 <dcoutts_> is "vixen-mode! nice" a command? like @vixen-mode bitch
05:49:03 <dons> roconnor: right.
05:49:10 <roconnor> dons: then I won't report a bug
05:49:22 <dons> dcoutts_: no, just plain old sociopathic vixen, i think
05:49:30 <dcoutts_> heh
05:49:38 <Cale> kpreid_: values of type (AnyRef a) are provably useless, since the s has been obliterated, and the reference inside can't be used in any ST monad.
05:49:59 <Cale> (in the context of any call to runST anyway)
05:50:12 <kpreid_> yes, so?
05:50:19 <shapr> I bet lambdabot can do lots of cool stuff with modal behaviour.
05:50:25 <Cale> er, so why are we defining that type at all?
05:50:42 <kpreid_> um, where are we defining it?
05:50:48 <dons> shapr: yeah, i reckon. it gets the whole channel to play with, so lots of tricky things can be done
05:50:51 <Cale> > data AnyRef s = forall a. (Ref s a) => AnyRef a deriving Typeable
05:50:51 <hsbot>  Parse error
05:50:51 <lambdabot>  Parse error
05:50:59 <Cale> sorry lambdabot :)
05:51:01 <dons> i'm don't think we've even scratched the surface
05:51:22 <kpreid_> as far as I know, AnyRef's parameter is never hidden
05:51:25 <kpreid_> oh
05:51:27 <kpreid_> hm
05:51:32 <kpreid_> Cale: Oh, I need to put s as a field of the AnyRef?
05:51:51 <Cale> oh, hang on, perhaps I have this backwards
05:51:59 <dons> hsbot, @part
05:51:59 <hsbot> Not enough privileges
05:52:12 <kpreid_> Cale: confusing type constructors and data constructors? :)
05:52:38 <dons> ?pretty data AnyRef s = forall a. (Ref s a) => AnyRef a deriving Typeable
05:52:38 <lambdabot> "Illegal data/newtype declaration" at column 25
05:52:39 <hsbot> "Illegal data/newtype declaration" at column 25
05:52:41 <Cale> the parameters to Ref
05:52:44 <dons> interesting.
05:53:14 <dmhouse> hsbot, @part
05:53:38 <dmhouse> huh.
05:53:40 <dmhouse> @part
05:53:40 <lambdabot> Not enough privileges
05:53:46 <shapr> Can I mix a guard and read :: Int at the same time? Like, try to read as Int and go to the next case if it fails?
05:53:48 <Cale> okay, so you are holding on to the ST monad's s parameter in the type, you're just throwing away all information about what the Ref refers to
05:54:05 <kpreid_> Cale: that's the idea
05:54:10 <Igloo> shapr: Use reads
05:54:14 <kpreid_> it's a dynamic message-passing system
05:54:15 <Cale> You'll never be able to meaningfully dereference the STRef again, but I suppose you don't care?
05:54:28 <shapr> Igloo: I'll try it, thanks.
05:54:31 <kpreid_> well, rDyn lets you extract it at runtime
05:55:23 <kpreid_> the instance of Ref for STRef is a bit of a pun; I need cells so I used STRef for it
05:55:27 <Cale> ah
05:58:05 <alar> can lambdabot tell me the list of names exported by a module?
05:59:09 <dons> alar, hmm. no. but @docs can
05:59:12 <dons> @docs Data.List
05:59:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
05:59:45 <kpreid_> Cale: so, I still don't see why 'call' once applied to an AnyRef has two s variables
06:01:22 <kpreid_> hmm
06:01:25 <kpreid_> it's not 'call' that does it, it's 'ref'
06:01:43 <kpreid_> e.g. ref $ ref (1::Integer) has type forall s s1. (Ref s (AnyRef s1), Ref s1 Integer) => AnyRef s
06:01:55 <Cale> why is s forced to be Typeable?
06:02:08 <kpreid_> solely because of the deriving Typeable in AnyRef
06:02:24 <Cale> hmm
06:02:31 <Cale> will that actually work?
06:02:33 <kpreid_> which is necessary because Ref instances must be Typeable and therefore STRef must be
06:02:39 <kpreid_> it hasn't failed yet :)
06:03:02 <Cale> have you managed to apply runST to something like that?
06:03:09 <kpreid_> sure
06:03:22 <Cale> where the s was constrained?
06:03:32 <kpreid_> oh, hm
06:03:45 <Cale> That's surely a bug in higher-rank polymorphism if it lets you :)
06:03:50 <SamB_XP> that would be cool ;-)
06:04:03 <kpreid_> I can use stToIO, but not runST
06:04:21 <dons> you can't mix $ and higher-rank stuff
06:04:25 <kpreid_> OK, so will my program misbehave if I write a non-derived Typeable for AnyRef which ignores the 's' parameter?
06:04:46 <kpreid_> dons: do I?
06:04:50 <Cale> I don't know, but it seems like something to try
06:05:01 <dons> kpreid_: oh, i just saw the ref $ ... above
06:05:18 <kpreid_> ref :: (Ref s a) => a -> AnyRef s
06:05:36 <dons> you'll get weird kind/escape/rigid tyvar errors if there's something higher-ranked on either side of a $, iirc
06:05:46 <dons> $ considered harmful
06:05:46 <kpreid_> yeah, I've hit one of those before
06:05:47 <SamB_XP> yes
06:05:53 <SamB_XP> very annoying errors!
06:06:04 <dons> though some of them at least go away in ghc 6.5
06:06:06 <dons> i've noticed
06:06:11 <SamB_XP> actually, higher-ranked types considered harmful ;-)
06:06:22 <kpreid_> but that doesn't seem to be related to the actual problem
06:06:23 <dons> the wonders of impredicativity, i suspect
06:06:25 <kpreid_> :)
06:07:01 * dons `fmap` sleep -- nytol!
06:08:19 <kpreid_> the problem seems to be that 'ref' or 'AnyRef' has a sufficiently flexible type that a second s is introduced
06:08:28 <kpreid_> but I don't see how anything can be done about that
06:14:02 <norpan> hard koncepts considered harmful
06:16:59 <Cale> hmm, maybe there's a way around all of this code? What is this actually trying to do?
06:18:15 <Cale> It sort of looks like it's trying to smush some mutable-OO idiom into Haskell :) (Which is generally the sort of thing which is doable but difficult/annoying)
06:19:38 <kpreid_> Cale: precisely
06:19:58 <kpreid_> the point is to describe the semantics of that system by way of implementing it in Haskell
06:21:26 <Cale> oh, if that's the point, then stay away from extensions -- the semantics of the interactions between various extensions to GHC have not been well-explored, let alone well-defined :)
06:21:54 <kpreid_> hurk
06:22:24 <shapr> Yay, userlimits work in Hope!
06:23:25 <kpreid_> Cale: what would you suggest using instead?
06:23:29 <Cale> what types of things will these references be referring to?
06:23:37 <Cale> Is it really unbounded?
06:23:41 <kpreid_> you mean Ref/AnyRef?
06:23:43 <kpreid_> conceptually, yes
06:23:47 <Cale> hmm
06:24:02 <kpreid_> user-defined lambda-style-objects and an arbitrary set of primitives
06:24:42 <Cale> hmm, okay
06:27:58 <kpreid_> the obvious simplification is to just use IO instead of ST, as I did before
06:29:16 <shapr> Igloo: Thanks, reads was perfect.
06:30:49 <Cale> okay
06:30:52 <Igloo> np
06:31:07 <Cale> ref :: forall s a. (Ref s a) => a -> AnyRef s
06:32:31 <Cale> hmm
06:33:16 <Cale> ah
06:33:22 <Cale> call :: forall s r.
06:33:22 <Cale>         (Ref s r) =>
06:33:22 <Cale>         r -> Verb -> [AnyRef s] -> Result s
06:33:25 <Cale> now,
06:33:42 <Cale> for which s does ref return an AnyRef s?
06:33:52 <Cale> the answer is that we don't know
06:34:23 <Cale> there's nothing there to say that it's the same one as the s in the Result s that call is returning
06:34:35 <kpreid_> aha
06:35:10 <kpreid_> er, it still doesn't make sense
06:35:18 <kpreid_> s appears in the type everywhere
06:35:31 <Cale> okay, let me rename some variables
06:35:42 <Cale> ref :: forall q a. (Ref q a) => a -> AnyRef q
06:36:16 <Cale> when you do  call (ref (1 :: Integer))
06:36:48 <Cale> first, which call is run?
06:37:03 <Cale> It depends on r
06:37:06 <Cale> but what's r?
06:37:09 <kpreid_> the one for instance Ref s (AnyRef s)
06:37:10 * shapr cackles happily after reading through Hawl/Session/SessionT.hs
06:37:36 <kpreid_> hmm
06:37:48 <Cale> there might be many instances of Ref for any given r too
06:37:54 <Cale> you need to know both s and r
06:39:00 <Cale> s is known
06:39:08 <Cale> at least, for call
06:40:51 <Cale> do you really need these instances for Integer, etc?
06:41:21 <Cale> the problem is much easier to fix without them
06:41:30 <kpreid_> you mean, box all the primitives?
06:41:43 <Cale> something like that, I suppose
06:41:57 <Cale> I'm not 100% sure what impact this will have :)
06:42:36 <Cale> but if we could insist that r in the definition of Ref was a type constructor taking s as a parameter, things get much easier
06:43:22 <kpreid_> ah
06:43:37 <kpreid_> hm, pushing it down one layer?
06:44:48 <Cale> well, that lets us mention which s we want in the types
06:44:48 <kpreid_> That would look like "=> Ref s (r s)", right?
06:44:57 <Cale> class (Typeable r, Show r) => Ref r where
06:45:02 <Cale>     call :: r s -> Verb -> [AnyRef s] -> Result s
06:45:19 <kpreid_> hm
06:46:05 <Cale> that possibly breaks the whole thing
06:46:44 <Cale> (to solve this problem)
06:46:48 <kpreid_> I suspect it does, because where, then, is s used in the definition of AnyRef?
06:47:32 <Cale> ah, that too
06:48:03 <Cale> well, let's leave the s as a typeclass parameter then...
06:48:17 <dmhouse> anyone know how to get the name of the currently running bot in lambdabot? E.g. for lambdabot it'd be "lambdabot"
06:49:26 * shapr has fun furiously hacking on Hope
06:49:30 <shapr> dmhouse: Config.nickname?
06:49:34 <shapr> Something like that.
06:49:49 <petekaz> I'm very excited about the contextual changes.
06:49:54 <kpreid_> Cale: please squash the vague notion that functional dependencies, another Haskell thing that I don't fully understand, are relevant to making s appropriately specific?
06:50:01 * shapr fails to add a userinfo layer to Hope
06:50:05 <dmhouse> shapr, 'Config.name config'?
06:50:06 <petekaz> I always felt that lambdabot felt crippled.
06:50:13 <dmhouse> petekaz: I'm already putting them to good use :)
06:50:27 <Cale> kpreid_: It's true, it seems like they'd help here, but they seem moderately incompatible with your instances.
06:50:36 <kpreid_> how so?
06:50:45 <kpreid_> (that's what the compiler told me, too :)
06:50:48 <petekaz> I want to write a plugin to print page titles of urls that appear in the channel.
06:50:50 <Cale> let me determine exactly how
06:51:05 <petekaz> But I'm very new so this will take me a while to figure out.
06:51:22 <shapr> petekaz: Oh cool, the bot on #swhack does that, it turns an url into a smaller name that the bot saves along with html title.
06:51:24 <petekaz> Is there some library that will fetch url's for me?
06:51:36 <shapr> petekaz: Yeah, you can use Network.HTTP or libcurl.
06:51:41 <petekaz> shapr: yeah, I wrote this feature for erbot as well.
06:51:41 <shapr> I think lambdabot already has something.
06:51:49 <shapr> spiffy!
06:51:54 <shapr> Is erbot the same as Oort?
06:52:09 * shapr has the urge to hack on some Erlang
06:52:11 <petekaz> no .. erbot is fsbot in #emacs
06:52:14 <shapr> ah, ok
06:52:30 <dmhouse> ah, I like fsbot.
06:52:40 <dmhouse> The ability to send it commands in the middle of normal text is nice.
06:52:43 <petekaz> I've added a few thigs to fsbot.
06:52:47 <shapr> fsbot started out as an automation hack for erc.
06:52:56 <shapr> dmhouse: Now lambdabot has that too!
06:53:04 <dmhouse> shapr: it does?
06:53:12 <petekaz> I have a weather hookup, amazon hookups using their REST api.
06:53:21 <shapr> Sure, petekaz & dons did the contextual thing.
06:53:31 <petekaz> dmhouse: that's the contextual thing that was just added.
06:53:41 <dmhouse> ah, I see.
06:53:51 <dmhouse> That's not quite what I mean.t
06:53:53 <dmhouse> *meant
06:54:07 <shapr> I think it is, you want @wiki Demo right?
06:54:13 <dmhouse> I mean, if I were to go ,,df next-line, then fsbot would reply
06:54:16 <dmhouse> Yeah.
06:54:21 <shapr> Yes, I think the contextual codedoes that.
06:54:23 <petekaz> yeah, that's what this is.
06:54:31 <dmhouse> Ah, it's more than what I thought then.
06:54:35 <dmhouse> I figured it was just:
06:54:39 <dmhouse> ?vixen-on
06:54:40 <lambdabot> Not enough privileges
06:54:43 <petekaz> you just implement 'contextual _ _ _ _ txt' and you have access to every message.
06:54:44 <dmhouse> meh. All that.
06:55:04 <petekaz> so you can do inline commands now.
06:55:12 <dmhouse> petekaz: right, that's what I'm doing now. But a lambdabot-level function to grab @stuff from inside messages would be good
06:55:20 <dmhouse> rather than every plugin having to implement contextual
06:55:41 <petekaz> oh, that's just a simple helper function.
06:55:46 <Cale> kpreid_: well, any instance where the type of r doesn't include an s
06:56:24 <kpreid_> OK, I'll see what I can do about that
06:56:41 <petekaz> the whole point is that you don't want to limit the contextual stuff to just inline commands.  With the current implementation, you could, for example, do the URL thing I was talking about, or perhaps keep stats on who talks the most, etc ...
06:57:01 <petekaz> where 'inline commands' are strings that start with '@'
06:57:49 <petekaz> It's much more flexible this way.
06:58:20 <dmhouse> right.
06:58:25 <dmhouse> What I'm doing is a @tell plugin
06:58:55 <Cale> kpreid_: Is there a particular reason why being able to runST is attractive?
06:58:58 <dmhouse> e.g. @tell petekaz this is what I'm telling you. Then later, you pop in the channel and say something, then lambdabot says "petekaz: you have 1 new message. /msg lambdabot @messages to read them"
06:59:16 <kpreid_> Cale: only that the desired semantics don't include IO
06:59:17 <petekaz> yeah, like sarahbot's memo function.
06:59:21 <dmhouse> right.
06:59:42 <petekaz> and now you can do that with this contextual stuff.
06:59:56 <Cale> kpreid_: It would be easy enough to create a monad which embedded in IO that had the equivalent of IORefs, but otherwise allowed no IO. Actually, ST RealWorld probably satisfies that
07:00:17 <SamB_XP> hmm, so, maybe you could wrap the ST and STRef types, so as to preserve their freshness?
07:00:18 * kpreid_ nods
07:00:56 <SamB_XP> I'm not actually sure you can do that
07:03:06 <Cale> If you could decide on the primitive types and type constructors which the system allowed it would also simplify the heck out of things.
07:03:37 <dmhouse> Argh! Lambdabot's build system is _really_ screwed.
07:04:22 <kpreid_> Cale: you mean because I could write data AnyRef = PrimInteger Integer | ...?
07:04:22 <dmhouse> It tells me I'm importing Config and not using anything from it (that's only a warning but seems enough to crash the build), so I comment out the import, then it tells me the Config.name and Config.config aren't in scope!?
07:04:28 <kpreid_> or is there something else?
07:04:53 <Cale> kpreid_: yeah, that or a GADT at worst.
07:05:23 <Cale> well, actually, you shouldn't need a GADT at that point either
07:05:35 <Cale> and you'd remove the need for dynamics
07:05:46 <dmhouse> hrm, removing the 'Config.' seems to fix it.
07:06:44 <Cale> what's the project?
07:07:12 <Cale> Is it something which will be extensible in Haskell at runtime?
07:07:23 <kpreid_> I don't know yet
07:07:30 <pharm> Q: where can I find samples of idiomatic haskell? Especially stuff that combines monads in useful ways.
07:07:38 <kpreid_> non-extensible is probably not necessary;
07:07:45 <kpreid_> er, not a problem
07:07:55 <kpreid_> but it seems conceptually wrong
07:08:39 <Cale> pharm http://www.haskell.org/haskellwiki/Category:Idioms has lots of links to various things
07:08:58 <Cale> http://www.haskell.org/haskellwiki/Sudoku in particular has a good example
07:09:42 <dmhouse> hmm, my lambdabot seems not to respond to PMs.
07:09:42 <Cale> (my sudoku solver is a good example of how to construct a monad which solves your problem for you :)
07:10:10 <Cale> dmhouse: is it identified to services?
07:10:29 <dmhouse> Cale: ah. hehe. I always forget about things like that.
07:10:45 <dmhouse> hmm. What's the easiest way of doing that? Through @id?
07:10:53 <pharm> Cale: fab. Thanks.
07:11:14 <Cale> dmhouse: iirc, you just have to add a password to State/passwd
07:11:26 <Cale> it should be 'read'able as a Haskell string
07:11:37 <Cale> (in particular, put it in quotes)
07:11:49 <dmhouse> i'll give it a shot, thanks.
07:11:59 <dmhouse> Cale: it'll automagically register and everything?
07:12:07 <Cale> I think so
07:12:11 <Cale> er
07:12:13 <Cale> register?
07:12:16 <Cale> I don't know
07:12:21 <dmhouse> hmm
07:12:23 <dmhouse> vincenz: ping
07:12:30 <Cale> But it will identify with just that
07:13:01 <Cale> you might have to make it an account first :)
07:13:21 <dmhouse> can you do that? Create accounts through proxy?
07:13:36 <dmhouse> (as in, can I create an account for my LB, not as in HTTP proxies)
07:13:38 <Cale> sure, you can have as many accounts on this network as you want
07:13:52 <dmhouse> aha.
07:14:08 <dmhouse> so I just /nick to my bot's nick, then register. Gotcha.
07:15:28 <dmhouse> Cale, it works! Thanks.
07:23:02 <dmhouse> yay! My lambdabot plugin works!
07:23:07 <dmhouse> Who wants to see?
07:23:15 <pharm> go on then
07:23:18 * dmhouse waits for the inevitable silence
07:23:23 <dmhouse> oh, wow, a punter :)
07:23:41 <dmhouse> hsbot, @tell pharm hello :)
07:23:41 <hsbot> Consider it noted.
07:23:47 <dmhouse> pharm: now type something
07:23:47 <hsbot> dmhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
07:23:53 <dmhouse> err
07:23:53 <hsbot> dmhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
07:23:58 <pharm> hello!
07:23:59 <hsbot> pharm: You have 1 new messages. '/msg hsbot @messages' to read them.
07:24:01 <petekaz> dmhouse: hah.
07:24:02 <hsbot> petekaz: You have 1 new messages. '/msg hsbot @messages' to read them.
07:24:05 <dmhouse> okay, it probably shouldn't say it more than once
07:24:05 <hsbot> dmhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
07:24:12 <dmhouse> @print-notices
07:24:13 <hsbot> {"dmhouse":=[Note {noteSender = "davidhouse", noteContents = "raarg", noteTime = Thu Jun  8 15:21:11 BST 2006}],"pharm":=[Note {noteSender = "dmhouse", noteContents = "hello :)", noteTime = Thu Jun
07:24:13 <lambdabot> Unknown command, try @list
07:24:13 <hsbot> 8 15:23:21 BST 2006}]}
07:24:13 <hsbot> lambdabot: You have 1 new messages. '/msg hsbot @messages' to read them.
07:24:22 <dmhouse> hah, okay it doesn't work
07:24:22 <hsbot> dmhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
07:24:26 <dmhouse> @part
07:24:26 <lambdabot> Not enough privileges
07:24:26 <hsbot> lambdabot: You have 1 new messages. '/msg hsbot @messages' to read them.
07:24:33 <dmhouse> hsbot, @quit
07:24:34 <pharm> <evil-thought> But can you make lambdabot message itself?
07:33:31 <norpan> Curry seems like an interesting language
07:50:33 <dmhouse> Okay, it really does work this time!
07:50:36 <dmhouse> :)
07:51:00 <dmhouse> hsbot, @tell pharm try it now
07:51:01 <hsbot> Consider it noted
07:51:27 <dmhouse> look, I can speak without hsbot telling me I have messages! :)
07:51:27 <hsbot> dmhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
07:51:29 <dmhouse> gah!
07:51:30 <hsbot> dmhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
07:51:44 <vincenz> re
07:51:54 <dmhouse> hsbot, @quit
07:51:54 <vincenz> @version
07:51:55 <lambdabot> lambdabot 3.1p52, GHC 6.4.1 (Linux i686 3.20GHz)
07:51:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:51:59 <vincenz> dmhouse: ack
07:52:01 <vincenz> dmhouse: what was that
07:52:38 <dmhouse> vincenz: my latest lambdabot plugin. Just trying it on my own lambdabot first.
07:52:43 <vincenz> kewl
07:52:43 <dmhouse> hold on, this is a one-line hix
07:52:45 <dmhouse> *fix
07:52:47 <vincenz> you pinged me?
07:53:55 <vincenz> dmhouse: pong
07:54:14 <dmhouse> vincenz: yeah, it was regarding getting a lambdabot to IDENTIFY, but Cale sorted me out.
07:57:25 <dmhouse> vincenz: feel like being a guinea pig? :)
07:57:46 <dmhouse> hsbot, @tell vincenz to type something
07:57:47 <hsbot> Consider it noted
07:57:56 <dmhouse> vincenz: just say anything
07:58:00 <dmhouse> (in the channel)
07:58:49 <dmhouse> Okay, fine, I'll talk with myself :)
07:58:57 <dmhouse> hsbot, @tell davidhouse this is how it'll work
07:58:58 <hsbot> Consider it noted
07:59:08 <davidhouse> hello :)
07:59:08 <hsbot> davidhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
07:59:11 <davidhouse> ta-da! :)
07:59:12 <hsbot> davidhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
07:59:23 <dmhouse> mmm... gotta put a timeout on that.
08:00:32 <vincenz> anything
08:00:32 <hsbot> vincenz: You have 1 new messages. '/msg hsbot @messages' to read them.
08:00:56 <vincenz> @tell dmhouse to woot
08:00:56 <lambdabot> Maybe you meant: help keal spell
08:00:56 <hsbot> Consider it noted
08:01:21 <dmhouse> vincenz: then /msg the bot
08:01:21 <hsbot> dmhouse: You have 1 new messages. '/msg hsbot @messages' to read them.
08:01:29 <vincenz> dmhouse: 1 new messages? pluralis majistails?
08:01:34 <dmhouse> ssh.
08:01:35 <dmhouse> :)
08:01:51 <vincenz> @version
08:01:51 <hsbot> lambdabot 3.1p65, GHC 6.4.1 (Linux i686 1.70GHz)
08:01:51 <lambdabot> lambdabot 3.1p52, GHC 6.4.1 (Linux i686 3.20GHz)
08:01:52 <hsbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:01:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:01:56 <vincenz> 65?
08:02:10 <alar> p is for "patch"?
08:02:14 <vincenz> I know
08:02:21 <vincenz> oh, you're asking, yes
08:02:24 <dmhouse> I'm running a more up-to-date version, that means.
08:02:33 <dmhouse> hsbot, @quit I've served my purpose.
08:02:33 <Stinger_> haha
08:02:34 <vincenz> dmhouse: yes but are you branched off of 52?
08:02:48 <dmhouse> vincenz: ?
08:02:56 * shapr boings
08:03:04 <vincenz> dmhouse: for all we know you're branched off of lambdabot p0 and added 65 nilpatches
08:03:22 <dmhouse> ah.
08:03:27 <dmhouse> Well, I haven't ;)
08:03:28 <vincenz> on your own comp
08:03:29 <shapr> Or maybe he's integrated House into lambdabot?
08:03:50 <dmhouse> hehe
08:03:54 <shapr> That would be cool, you could use libaa to display graphical programs over irc
08:04:40 <vincenz> House?
08:04:55 <shapr> ibid: seen http://www.cs.waikato.ac.nz/~marku/jaza/ ?
08:04:56 <dmhouse> The Haskell-based OS
08:04:58 <shapr> @where house
08:04:58 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
08:05:10 <vincenz> shapr: oh yeah we could flash dmhouse wiht zillions of windows
08:05:20 <vincenz> hsbot, @new-dialog Ping
08:05:45 <alar> what is haskell-based OS?
08:05:51 <shapr> House is
08:06:04 <alar> oh
08:06:06 <petekaz> dmhouse: nice
08:06:13 <alar> what architecture does it have?
08:06:14 <petekaz> dmhouse: re: @tell
08:06:27 <dmhouse> petekaz: thankyou. :) Almost finished.
08:06:59 <vincenz> dmhouse: been wanting this for a while :)
08:07:29 <petekaz> dmhouse: when did you start writing this?  It's funny that you were working on this when I was working on the contextual stuff.
08:07:39 <petekaz> (since @tell depends on it)
08:08:14 <dmhouse> petekaz: I started yesterday. I had it working where'd you say '@messages' and it'd print them out. I had the idea that I wanted to do it this way, and chatting with dons this morning brought up that nice coincidence :)
08:08:31 <petekaz> nice.
08:09:06 <shapr> I like Jared Updike's Website.
08:09:14 <shapr> Doesn't he hang out here sometimes?
08:09:42 * shapr is trying to remember his irc nick
08:10:32 <shapr> I want to steal the sources to his website and stash them into Hope somehow.
08:10:51 <shapr> oh
08:11:05 <shapr> "Code for this Haskell Web Framework (HWF) posted http://www.updike.org/~jared/files/hwf.tar.gz "
08:11:48 <yaarg> rm interesting
08:19:28 <lispy> @type Char.isLatin1
08:19:29 <lambdabot> Char -> Bool
08:19:35 <lispy> @hoogle isLatin1
08:19:35 <lambdabot> Char.isLatin1 :: a -> Bool
08:19:35 <lambdabot> Data.Char.isLatin1 :: Char -> Bool
08:19:59 <lispy> why does hoogle report Char.isLatin1 as a -> Bool
08:20:09 <lispy> > Char.isLatin1 4
08:20:10 <lambdabot>  add an instance declaration for (Num Char)
08:20:11 <shapr> Because you put in a Char, and get back a Bool?
08:20:15 <lispy> clearly it is not :)
08:20:22 <shapr> > Char.isLatin1 '4'
08:20:23 <lambdabot>  True
08:20:39 <vincenz> > and . map Char.isLatin1 . map chr $ [0..255]
08:20:40 <lambdabot>  True
08:20:41 <vincenz> > and . map Char.isLatin1 . map chr $ [0..256]
08:20:42 <lambdabot>  False
08:21:08 <lispy> shapr: but why does hoogle think it takes 'a' when it takes Char?
08:21:35 <vincenz> lispy: use properly named modules
08:21:38 <vincenz> lispy: which is Data.Char
08:21:40 <shapr> oh, I dunno.
08:21:46 <vincenz> Char must be an old remnant from somewhere
08:21:56 <vincenz> especially the docs
08:22:03 <vincenz> and hoogle works on haddock afaik
08:22:22 <shapr> But the typesigs are automatically generated, yeah?
08:22:31 <vincenz> no
08:22:36 <vincenz> they are based on haddock
08:22:39 <vincenz> @type Data.isLatin1
08:22:40 <lambdabot> Couldn't find qualified module.
08:22:40 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
08:22:50 <vincenz> @type Char.isLatin1
08:22:51 <lambdabot> Char -> Bool
08:22:53 <vincenz> see
08:22:55 <vincenz> old haddock stuff
08:23:00 <vincenz> Char is not even a valid module anymore
08:23:13 <vincenz> it's Data.Char. and I think noone cared to update it's docs
08:23:19 <vincenz> (the Char one)
08:23:25 <shapr> It still shouldn't show just an a in the type sig.
08:23:44 <vincenz> @type Char.isLatin1
08:23:46 <lambdabot> Char -> Bool
08:23:46 <vincenz> is correct
08:23:48 <shapr> @hoogle isLatin1
08:23:48 <lambdabot> Char.isLatin1 :: a -> Bool
08:23:49 <lambdabot> Data.Char.isLatin1 :: Char -> Bool
08:23:50 <shapr> is not
08:23:52 <vincenz> no
08:23:58 <vincenz> but it's haddock based
08:24:07 <shapr> so?
08:24:14 <vincenz> nm
08:24:24 <shapr> Haddock doesn't change the type signatures, does it?
08:24:29 * vincenz grumbles
08:24:34 <vincenz> Char is no longer in the hiercharchical modules
08:24:39 <vincenz> people should use Data.Char
08:24:46 <vincenz> prolly noone cared to update the docs of Char
08:24:47 <shapr> Right, but... it should still have the same type.
08:24:49 <vincenz> with a modern haddock generator
08:25:03 <vincenz> and it's not active
08:25:10 <vincenz> hoogle generates it's database once
08:25:11 <dmhouse> eurgh! Emacs keeps crashing.
08:25:17 <shapr> I thought ndm regenerated the docs every few months?
08:25:23 <dmhouse> damned buggy XFT.
08:25:30 <vincenz> then maybe hoogle db hasn't been updated
08:27:17 <vincenz> I'm not saying it's correct, I' pointing out the fact that @type is correct and therefore indicating at the probable cause of the error
08:29:09 <dmhouse> hi int-e.
08:29:29 <int-e> hi
08:30:02 <vincenz> hello int-e 
08:35:08 <lispy> oh, well haddock has buggy types
08:35:26 <dmhouse> if you derive Ord on a record, does it just `compare` all the fields of the two records together?
08:35:44 <dcoutts> yep
08:35:52 <dcoutts> in lexographic order
08:35:56 <dmhouse> wonderful, the the Ord derviation on TimeDiff is useless.
08:36:01 <dmhouse> *then the
08:36:46 <dmhouse> actualy, hmm.
08:37:24 <dmhouse> data R = R { a :: Int, b :: Int }. r1 = R 5 6; r2 = R 6 5; what's the value of r1 `compare` r2?
08:38:07 <dcoutts> > (5,6) `compare` (6,5)
08:38:08 <lambdabot>  LT
08:38:43 <dmhouse> right, okay.
08:38:53 <dmhouse> > (1, 2) `compare` (1, 3)
08:38:54 <lambdabot>  LT
08:38:58 <dmhouse> > (1, 2) `compare` (1, `)
08:38:58 <lambdabot>  Parse error
08:39:00 <dmhouse> > (1, 2) `compare` (1, 1)
08:39:00 <lambdabot>  GT
08:39:09 <dmhouse> cool. Thanks dcoutts.
08:54:48 <lispy> > 1 +: 2 `compare` 1 :+ 3
08:54:48 <lambdabot>  Not in scope: `+:'
08:54:56 <lispy> > 1 :+ 2 `compare` 1 :+ 3
08:54:56 <lambdabot>   precedence parsing error
08:54:56 <lambdabot>    cannot mix `(:+)' [infix 6] and `(:+)' [...
08:55:08 <lispy> > (1 :+ 2) `compare` (1 :+ 3)
08:55:08 <lambdabot>  add an instance declaration for (Ord (Complex a))
08:55:08 <lambdabot>   In the definition of `...
08:55:12 <lispy> ah good
08:56:23 <bolrod> ^.0
08:56:30 <bolrod> Complex doesn't have an instance Ord?
08:56:43 <dmhouse> bolrod: how would you compare them?
08:56:50 <bolrod> > (1:+2) > (2:+2)
08:56:50 <lambdabot>  add an instance declaration for (Ord (Complex a))
08:56:51 <lambdabot>   In the definition of `...
08:56:59 <bolrod> I dont know!
08:57:00 <bolrod> lenght?
08:57:21 <dmhouse> it could do. But then it could use arg as well.
08:57:32 <dmhouse> As there's more than one option with no sensible default, newtypes.
08:57:38 <Cale> Does anyone happen to know if there's a similarly nice algebraic characterisation of context-free languages as for regular ones? In particular, the definition of a regular language as the preimage of a subset of M under a monoid morphism A* -> M where M is a finite monoid.
08:57:43 <bolrod> you agree (-1:+0) is smaller then (1:+0) ? ;)
08:58:37 <bolrod> or something with  e^if  soomething? I forget :)
08:59:17 <Cale> The reason that Complex doesn't have an instance of Ord is that no ordering would make it an ordered-ring.
08:59:24 <Cale> (or ordered field)
09:00:18 <Cale> Ordered rings have to satisfy the properties that if a <= b, then a + c <= b + c, and if 0 <= a and 0 <= b, then 0 <= ab
09:01:02 <Cale> (and of course <= has to be a total order)
09:06:23 <lispy> well put
09:11:15 <dmhouse> Yay! I think I've finally finished my @tell plugin :)
09:11:19 * dmhouse beams proudly
09:12:41 <lispy> @tell
09:12:41 <lambdabot> Maybe you meant: help keal spell
09:12:45 <lispy> @keal
09:12:45 <lambdabot> i use an 8088
09:12:57 <psnl> @keal
09:12:57 <lambdabot> Keal was so happy with T, coded in basic so run on anything, and does lot
09:13:58 <dmhouse> lispy, it's not in yet.
09:15:44 <dropdrive> So I have a data type Blob that is an instance of Ord, but the actual computation of foo `compare` bar is expensive.  Is there a standard way to 'memoize' the comparisons?
09:19:24 <shapr> memoize' f range = ((map f range) !!)
09:19:35 <shapr> memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
09:19:44 <shapr> What about those?
09:20:28 <dropdrive> shapr: thanks...let me think about them for a while...I'm new to Haskell...
09:20:42 <dmhouse> Yay! :)
09:20:48 <prionic> hi everyone!
09:20:53 <dmhouse> @where paste
09:20:54 <lambdabot> http://paste.lisp.org/new/haskell
09:21:19 <lisppaste2> davidhouse pasted "@tell" at http://paste.lisp.org/display/21021
09:21:29 <dmhouse> How does ^^ look as a new lambdabot plugin, then?
09:21:56 <ibid> shapr: nope, thanks
09:22:01 <dmhouse> oops, it's missing a bit.
09:23:05 <lisppaste2> davidhouse annotated #21021 with "@tell, the whole story" at http://paste.lisp.org/display/21021#1
09:23:46 <prionic> 04ive got a problem with haddock, it doesnt like arrow notation
09:24:03 <dmhouse> was that red on anyone else's screen?
09:24:25 <ohub> yes
09:24:45 <dmhouse> good. /me was worrying there :)
09:25:06 <Igloo> prionic: Please don't use colours/bold etc here
09:25:15 <jcreigh> dmhouse: mIRC colors.
09:25:25 <prionic> 0202,00better
09:25:28 <prionic> 0202,00?
09:25:31 <dmhouse> :P no.
09:25:44 <prionic> im using trillian#0202,00
09:25:46 <dmhouse> prionic: just remove all superfluous formatting, if you would.
09:26:06 <prionic> now?
09:26:23 <blackhwkblade> hello guys
09:26:27 <jcreigh> prionic: great
09:26:30 <blackhwkblade> someone here u is from germany :-D
09:26:52 <dmhouse> blackhwkblade: there are one or two. Why?
09:26:59 <prionic> that wasnt on purpose, im sorry
09:26:59 <dmhouse> Oh, err
09:27:07 <dmhouse> I might have misunderstood what you just said. :)
09:27:24 <blackhwkblade> i have a question but my english is bad ^^
09:27:39 <prionic> try me
09:27:42 <dmhouse> blackhwkblade: Ask in both languages, then.
09:29:11 <prionic> so back to my problem with haddock, anyone tried it on source files which contained arrow notation? 
09:30:03 <prionic> it says "test = proc () -> do" is a "Parse error"
09:32:09 <dmhouse> prionic: it's possible it simply doesn't support arrows
09:32:36 <prionic> yeah, sigh...
09:33:23 <prionic> maybe i can use ghc to transform the syntactic sugar to plain haskell?
09:34:12 <dmhouse> FWIW, Haddock _will_ support that after the Summer of Code projects finish. :) (One of them is to port Haddock to use GHC's parser).
09:34:45 <prionic> ah, thats quite intersting
09:36:23 <dropdrive> shapr: does your code precompute a table of results, or is array creation lazy?
09:36:58 <palomer> almost all binary searches are broken!!
09:37:47 <dropdrive> shapr: and by array creation I mean array "population"...
09:38:56 <pharm> palomer: yes, some of us have read the google blog...
09:40:19 <dropdrive> Is there a Haskell equivalent of a memoization decorator like this? http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/466320
09:53:55 <int-e> dropdrive: Hmm. I think it could be implemented (with some limitations on the function's domain), but memoization is easily done explicitly; take fibonacci: you define fib as an infinite list, fib = [if n <2 then n else fib !! (n-1) + fib !! (n-2) | n <- [0..]] and then optimize that, which ends up with the common example fib = 0:1:zipWith (+) fib (tail fib)
09:54:49 <dropdrive> int-e: okay, I understand that, but my function's domain is kind of wacky...definitely not the integers
09:55:47 <dropdrive> int-e: it seems like a memoization decorator shouldn't have side-effects, so I was just wondering if it could be done...
09:57:41 <Cale> dropdrive: it can be done
09:57:44 <int-e> dropdrive: hmm, but implementing it for domains that aren't nice in some sense seems to require unsafePerformIO, even though it should be safe in that context.
09:58:10 <Cale> dropdrive: the reason that it hasn't is that there are many ways to do it, and almost every application is slightly different
09:58:16 <Cale> but there's a good paper
09:58:39 <Cale> http://research.microsoft.com/~simonpj/Papers/weak.htm
09:58:47 <dropdrive> int-e: okay, thanks.
09:59:49 <Cale> dropdrive: that paper shows four ways to do it :)
10:00:17 <Cale> and yeah, they use unsafePerformIO, but in a safe way
10:01:59 <int-e> Here's an example of a nice domain: if you have f : N -> x, and f(n) requires f(n-1) ... f(0) to be evaluated, a good data structure seems to be a list of arrays of exponentially increasing size - that allows efficient lookup, wastes only a constant factor of space and can be implemented in a pure way. (unlike the fibonacci example you really get efficient random access here)
10:02:25 <dropdrive> Cale: thanks for the link...I'm thinking about writing a package to perform computations with noncommutative Grobner bases...
10:03:32 <dropdrive> int-e: that's a good idea...will keep it in mind.
10:03:34 <kosmikus> unsafePerformIO isn't really needed, although it may be more convenient in some cases. see http://www.cs.uu.nl/~johanj/wgp2000/HinzeMemo.ps
10:07:40 <int-e> kosmikus: interesting
10:09:08 <psi> how do I convert between different instances of Fractional?
10:10:16 <dmhouse> @instances Fractional
10:10:17 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
10:10:30 <dmhouse> Silly buggy module :)
10:10:32 <int-e> fromRational
10:10:45 <dmhouse> @instances Num
10:10:46 <lambdabot> Double, Float, Int, Integer
10:11:13 <dmhouse> . in Posix regexes doesn't match \n, does it?
10:11:41 <int-e> or realToFrac?
10:11:53 <int-e> one of these should work.
10:11:57 <psi> let me try
10:12:32 <psi> realToFrac worked
10:12:46 <psi> thanks
10:13:00 <dmhouse> I still think Haskell's numeric classes are too complicated.
10:13:13 <dmhouse> Class aliases would likely really help here
10:17:41 <dropdrive> int-e: so with your fib example, if I were to, say, print fib!!1000000, will access to all earlier elements be O(1)?  Or will fib be discarded as memory is required, and recomputed later is necessary?
10:17:58 <pitkali> Hi, anybody using literate programming in tex mode under vim?
10:18:01 <int-e> fwiw, realToFrac = fromRational . toRational
10:18:24 <int-e> dropdrive: err, the stuff will be in memory but access to lists is O(n) (you traverse a linked list in memory)
10:18:40 <dropdrive> int-e: oops, of course
10:19:01 <dropdrive> int-e: so once I compute fib!!1000000, the list never dies?
10:19:09 <int-e> dropdrive: (at least if that fib is a toplevel declaration. lifetime of these bindings is a bit mysterious)
10:19:42 <int-e> dropdrive: yes.
10:20:18 <int-e> dropdrive: not that it couldn't be freed - but at least ghc won't, as far as I know.
10:20:30 <dropdrive> int-e: okay, thanks!
10:20:50 <int-e> dropdrive: (modulo a recent RTS change which - I think - allows fib to be freed if the GC can see that it'll never be used again)
10:25:40 <dmhouse> Lesson of the day: don't carelessly add regexes to your programs without _really testing them_.
10:25:43 <dmhouse> :)
10:26:25 * dmhouse sends a second patch to dons fixing the same regex as the last one
10:30:33 <int-e> dropdrive: (of course it'd be silly to calculate fib 1000000 that way anyway)
10:31:03 <dropdrive> int-e: haha, yes
10:31:29 <beelsebob_> dmhouse: other lesson: don't carelessly add regexes to your program without _really knowing what you're doing_
10:31:52 <dmhouse> tbh, it'd be silly to calculate the 1000000th fibonnaci number in the first place! :)
10:33:00 <int-e> *LinRec> length $ show (get [1,1] [0,1] 1000000)
10:33:00 <int-e> 208988
10:33:00 <int-e> (0.52 secs, 20102804 bytes)
10:33:21 <int-e> :)
10:36:17 <bolrod> @index get
10:36:17 <lambdabot> Control.Monad.State, Control.Monad.RWS, Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Text.ParserCombinators.ReadP, Distribution.
10:36:18 <lambdabot> Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
10:36:37 <int-e> that was LinRec.get and it's nowhere in the standard libs
10:37:03 <int-e> I can paste the module though if anyone is interested.
10:37:10 <bolrod> ;(
10:37:16 <bolrod> what should it do?
10:38:20 <int-e> evaluate linear recurrences. x_n = 1*x_(n-1) + 1*x_(n-2)  -> [1,1]  and  x_0=0, x_1=1 -> [0,1] define the fibonacci numbers.
10:38:45 <dmhouse> ooh, nice.
10:41:14 <psi> getting things to compile on the first try is a such a nice feeling :)
10:42:30 <psi> especially in haskell, because that means it usually works as well
10:43:18 <lisppaste2> int-e pasted "LinRec.hs" at http://paste.lisp.org/display/21024
10:44:42 <bolrod> O_o  ic
10:45:23 <dropdrive> one can also take a linear recurrence and figure out an explicit formula...
10:45:27 <dmhouse> psi, shows experience.
10:46:23 <int-e> dropdrive: yes, but only for algebraically complete fields; it involves taking roots of a polynomial.
10:48:07 <dmhouse> hey xerox.
10:48:17 <xerox> @yow!
10:48:17 <lambdabot> Yow!  Are we wet yet?
10:48:36 <dropdrive> int-e: well, if it's not algebraically closed, you can work in the algebraic closure ;-)
10:48:57 <dmhouse> xerox, http://paste.lisp.org/display/21021/raw
10:50:06 <dmhouse> xerox, err, http://paste.lisp.org/display/21021,1/raw
10:50:59 <xerox> Ah, makes sense. Nice one.
10:51:24 <dmhouse> Patch has been sent, should be in tomorrow.
10:52:16 <xerox> ?karma+ dmhouse
10:52:16 <lambdabot> dmhouse's karma raised to 3.
10:54:04 <dropdrive> int-e: what i said doesn't work for domains that have zero-divisors
10:54:11 <dropdrive> int-e: so just ignore me...
10:59:12 <lightstep> why is haskell so low level?
10:59:58 <astrolabe> low level ?!
11:00:09 <lightstep> it has memory, and execution.
11:00:25 <astrolabe> as an option
11:01:01 <xerox> Konnichiwa astrolabe!
11:01:02 <lightstep> don't you think that perhaps there might be something wrong with the entire concept of functions?
11:01:20 <astrolabe> wotcha xerox :)
11:01:58 <astrolabe> Um,  that has never occured to me.
11:02:28 <woggle> lightstep: There's something wrong with everything programming abstraction and with avoiding abstractions. (;
11:02:40 <woggle> s/everything/every/
11:03:59 <lightstep> i don't know what the best solution is. i just know that there *is* a solution
11:04:08 <dmhouse> lightstep: what do you mean by 'execution'? Every language executes.
11:04:38 <lightstep> I'm making an assertion that execution control is low level
11:05:08 <dmhouse> lightstep: for example?
11:05:16 <lightstep> and there is an execution model in haskell
11:05:38 <lightstep> that is, call by need
11:05:54 <lightstep> some expressions must diverge, and some must finish
11:05:59 <lightstep> to reduce
11:06:23 <dmhouse> anyone know if lassen (the german verb) takes the dative or the accusative?
11:06:24 <woggle> Could you give some examples of languages which don't have this 'problem' of having an execution model?
11:07:49 <lightstep> there are other ways of doing things. i'm not a language designer, yet *I* can fix these things
11:08:02 <lightstep> no, there has to be people who know what's going on and aren't talking. why?
11:08:09 <kosmikus> dmhouse: accusative, but a full sentence would help to confirm
11:08:15 <bolrod> yo.. who likes sequences?
11:08:45 <bringert> shapr: morning. you here?
11:09:53 <bolrod> 19:59:56 < nerd> Here is an interesting sequence..
11:09:53 <bolrod> 19:59:56 < nerd> 1 20 33 400 505 660 777 8000 9009 10100 11121
11:09:54 <bolrod> 19:59:56 < nerd> What are the next few numbers in the above sequence?
11:10:04 <xerox> It's a trap!
11:10:27 <kosmikus> lightstep: you don't have to use operational semantics to talk about Haskell
11:11:11 <lightstep> kosmikus, to answer this question i would have to diverge significantly from my eliza-like responses
11:11:27 <lightstep> (see http://lambda-the-ultimate.org/node/1546)
11:11:43 <kosmikus> I haven't asked a question
11:12:53 <lightstep> i know, but you implied one: "why did you still based your analysis on operational semantics?"
11:13:42 <xerox> bolrod - What was that sequence?
11:13:54 <bolrod> 1 20 33 400 505 660 777 8000 9009 10100 11121 ?
11:13:59 <bolrod> don't you see the connection?
11:14:06 <bolrod> it's not hard
11:14:42 <xerox> I see something.
11:14:45 <bolrod> Think xerox! think! :)  :D
11:14:57 <bolrod> ?vixen 1 20 33 400 505 660 777 8000 9009 10100 11121
11:14:57 <lambdabot> so you're no longer a teenie-bopper like me, huh?
11:15:10 <sehute> the first ones are just counting 1 2x 3x 4x 5x 6x 7x etc, still thinking about the other ones
11:15:53 <stepcut> ok, so apparently I showed my friend some 'perl-like haskell' code the other day and he wants to see it again -- but I have no idea what he is talking about. Anyone have any ideas what I might have shown him ?
11:16:08 <bolrod> slap him in the face
11:16:20 <bolrod> imperative like functional programming O_o?
11:16:32 <sehute> stepcut: print "hi"?
11:16:33 <xerox> stepcut - regexps, perhaphs?
11:16:40 <kosmikus> lightstep: I don't see a lot of content in that discussion.
11:16:56 <bolrod> xerox: getting any closer?
11:17:14 <stepcut> xerox: yeah, I was thinking it might have been JRegex or something...
11:17:33 <lightstep> kosmikus, the LtU discussion? i thought it was funny.
11:17:53 <bolrod> xerox: think easy... it's really not difficult :D
11:18:04 <bolrod> it's probably simpler then you think
11:18:15 <sehute> if the first digit is an odd number, then the last digit is the same number, otherwise it's 0
11:18:30 <bolrod> it's really simple you guys!
11:18:42 <xerox> It seems like binary sum, but with increasing naturals as simbols, bolrod.
11:18:45 <bolrod> look at all the numbers :)
11:18:54 <dmhouse> the last two seem to be show x ++ show (x^2), but that doesn't fit generally.
11:19:16 <bolrod> xerox: I don't know what you mean.. but it's probably close :)
11:19:27 <bolrod> or it is the answer ;)
11:19:32 <bolrod> what will be the next one then?
11:19:58 <sehute> (x:xs) | x > 10 = x ++ show (x^2)   , perhaps?
11:20:37 <bolrod> 1 10 11 101 110 111 ...
11:20:38 <bolrod> :)
11:20:47 <xerox> That's what I meant!
11:20:52 <bolrod> yeah
11:20:56 <bolrod> well. what's the next one then?
11:21:06 <sehute> xerox: I didn't mean to contradict you, but support you, if that was for me :)
11:21:19 <xerox> sehute - Err, no, I was referring to bolrod.
11:21:31 <sehute> xerox: oh, was hard to tell
11:21:41 <dmhouse> @hoogle base
11:21:41 <lambdabot> Text.Html.base :: String -> HtmlAttr
11:21:41 <lambdabot> Test.HUnit.Base :: module
11:21:41 <lambdabot> Text.Html.basefont :: Html
11:21:58 <xerox> bolrod, 11123, by any chance?
11:21:58 <dmhouse> @hoogle showIntAtBase
11:21:58 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
11:22:05 <bolrod> xerox: nope
11:22:19 <dmhouse> 12144, perhaps?
11:22:27 <bolrod> the last ones are   1001  (9009)  1010  1011  .. so then  1100
11:22:35 <xerox> 11132 ?
11:22:37 <lightstep> 13200?
11:22:41 <bolrod> 13200
11:22:42 <bolrod> :)
11:22:45 <xerox> Duh.
11:22:54 <lightstep> 14313?
11:23:01 <xerox> @karma+ lightstep 
11:23:02 <lambdabot> lightstep's karma raised to 2.
11:23:02 <bolrod> yes
11:23:15 <sehute> I still don't get it
11:23:20 <sehute> @karma- sehute
11:23:21 <lambdabot> You can't change your own karma, silly.
11:23:31 <sehute> ;)
11:23:38 <dmhouse> 1 20 33 400 505 660 777 8000 9009 10100 11121 -- avoid scrolling
11:23:55 <bolrod> its really simple ;)  just write the binary down.. and substitute it with the number
11:24:03 <sehute> ahhh :)
11:24:08 <sehute> got it :)
11:24:25 <bolrod> 1001 = 9  -> 9009
11:24:34 <dmhouse> bolrod: err, that's not that simple
11:24:41 <bolrod> 1010  = 10 ->  10100
11:24:46 <dmhouse> you had me looking for something much simpler than that
11:24:46 <bolrod> it's really simple!
11:24:54 <bolrod> bwah >_>
11:25:03 <bolrod> it's not like a 9th degree polynomal
11:25:04 <bolrod> ;)
11:25:48 <sehute> but, why is it 10100 instead of 100100, then? if you replace "1" with "10"?
11:25:52 <bolrod> how hard is it to write 9 in binary .. and substitute the 1's for 9's
11:26:11 <int-e> it's really n*as_decimal(binary(n))
11:26:16 <sehute> have to go, see you around :)
11:26:16 <stepcut> bolrod: is it substitution, or multiplication ?
11:26:17 <bolrod> 1010 = 10   so...  the first one becomes 10  then you get the 1 of the other ten
11:26:20 <bolrod> then 2 zero's
11:26:33 <stepcut> 1010*10 = 10100?
11:26:34 <bolrod> well.. add.. substitute.. you see how it works.. ;)
11:27:02 <xerox> int-e - Good catch.
11:27:17 <bolrod> yes :)
11:27:31 <lightstep> > [sum $ map (\i -> if Data.Bits.testBit n i then n*(10^i) else 0) [0..Data.Bits.bitSize n] | n <- [1..11]]
11:27:31 <lambdabot>  Add a type signature
11:27:35 * int-e wouldn't have seen that.
11:27:43 <lightstep> > [sum $ map (\i -> if Data.Bits.testBit n i then n*(10^i) else 0) [0..Data.Bits.bitSize n] | n::Int <- [1..11]]
11:27:44 <lambdabot>  Parse error
11:27:51 <lightstep> > [sum $ map (\i -> if Data.Bits.testBit n i then n*(10^i) else 0) [0..Data.Bits.bitSize n] | n <- [1..11]::[Int]]
11:27:51 <lambdabot>  [1,20,33,400,505,660,777,8000,9009,10100,11121]
11:27:58 <xerox> succ succ!
11:28:02 <bolrod> :D
11:28:12 <bolrod> 20:25:50 < int-e> it's really n*as_decimal(binary(n))
11:28:13 <dmhouse> @hoogle Int -> Char
11:28:13 <lambdabot> Char.chr :: Int -> Char
11:28:13 <bolrod> oops
11:28:13 <lambdabot> Char.intToDigit :: Int -> Char
11:28:13 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
11:28:50 <xerox> > [sum $ map (\i -> if Data.Bits.testBit n i then n*(10^i) else 0) [0..Data.Bits.bitSize n] | n <- [1..]::[Int]] !! 12
11:28:51 <lambdabot>  14313
11:29:07 <xerox> > take 10 $ drop 9 $ [sum $ map (\i -> if Data.Bits.testBit n i then n*(10^i) else 0) [0..Data.Bits.bitSize n] | n <- [1..]::[Int]]
11:29:08 <lambdabot>  [10100,11121,13200,14313,15540,16665,160000,170017,180180,190209]
11:29:22 <int-e> > take 10 $ [n * (read . showIntAtBase 2) | n <- [1..]]
11:29:23 <lambdabot>  Couldn't match `[Char]' against `t -> t1'
11:29:40 <bolrod> > showIntAtBase 2
11:29:41 <int-e> > take 10 $ [n * (read $ showIntAtBase 2 n "") | n <- [1..]]
11:29:41 <lambdabot>  Add a type signature
11:29:42 <lambdabot>  Couldn't match `[Char]' against `t -> t1'
11:29:43 <bolrod> > showIntAtBase 2 3
11:29:43 <lambdabot>  add an instance declaration for (Num (Int -> Char))
11:29:44 <int-e> :(
11:29:50 <bolrod> :t showIntAtBase 
11:29:51 <lightstep> > [n * read (Numeric.showIntAtBase n (head.show) 2) | n <- [1..11]]
11:29:51 <lambdabot>  Couldn't match `[Char]' against `t -> t1'
11:29:59 <bolrod> @t showIntAtBase 
11:29:59 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
11:30:04 <bolrod> @type showIntAtBase 
11:30:05 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> ShowS
11:30:15 <bolrod> O_o... ok
11:30:38 <lightstep> > [n * read (Numeric.showIntAtBase 2 (head.show) n) | n <- [1..11]::[Int]]
11:30:39 <lambdabot>  Couldn't match `[Char]' against `t -> t1'
11:31:01 <xerox> > [n * read (Numeric.showIntAtBase 2 (head.show) n "") | n <- [1..11]::[Int]]
11:31:03 <lambdabot>  [1,20,33,400,505,660,777,8000,9009,10100,11121]
11:31:05 <bolrod> whee :)
11:31:06 <xerox> ^_^
11:31:20 <int-e> showIntAtBase is more ugly than I remembered.
11:32:38 <dmhouse> let replace x ys = concatMap (\y -> if y == '1' then x else [y]) ys; bins = map (($ "") . showIntAtBase 2 intToDigit) [1..] in take 10 $ zipWith (\n b -> replace (show n) b) [1..] bins
11:32:42 <dmhouse> > let replace x ys = concatMap (\y -> if y == '1' then x else [y]) ys; bins = map (($ "") . showIntAtBase 2 intToDigit) [1..] in take 10 $ zipWith (\n b -> replace (show n) b) [1..] bins
11:32:43 <lambdabot>  ["1","20","33","400","505","660","777","8000","9009","100100"]
11:32:46 <dmhouse> That's what bolrod described.
11:33:58 <bolrod> welllllllllll
11:34:08 <dmhouse> > let replace x ys = concatMap (\y -> if y == '1' then x else [y]) ys; bins = map (($ "") . showIntAtBase 2 intToDigit) [1..] in take 13 $ zipWith (\n b -> replace (show n) b) [1..] bins
11:34:09 <lambdabot>  ["1","20","33","400","505","660","777","8000","9009","100100","1101111","1212...
11:34:20 <dmhouse> not quite the same :)
11:35:02 <bolrod> I didn't formulate it exactly that way -.-  but well.. maybe I might be a bit vague
11:35:28 <dmhouse> you said write it down in binary, then substitute the number. That's what my program does :)
11:36:17 <dmhouse> > let replace x ys = concatMap (\y -> if y == '1' then x else [y]) ys; bins = map (($ "") . showIntAtBase 2 intToDigit) [1..] in take 10 $ zipWith (replace . show) [1..] bins
11:36:18 <lambdabot>  ["1","20","33","400","505","660","777","8000","9009","100100"]
11:36:45 <bolrod> ok :)
11:40:49 <dmhouse> > let digits = [0..9] ++ ['a'..'z'] ++ ['A'..'Z']; showAtBase base n | base > length digits = error "Can't display such a high base" | otherwise = showIntAtBase base (!! digits) n ""
11:40:49 <lambdabot>  Parse error
11:41:34 <dmhouse> > let digits = [0..9] ++ ['a'..'z'] ++ ['A'..'Z']; showAtBase base n = showIntAtBase base (!! digits) n ""
11:41:34 <lambdabot>  Parse error
11:42:02 <dmhouse> > let digits = [0..9] ++ ['a'..'z'] ++ ['A'..'Z']; showAtBase base n = showIntAtBase base (digits !!) n "" in take 10 $ map (showAtBase 2) [1..]
11:42:03 <lambdabot>  add an instance declaration for (Num Char)
11:42:03 <lambdabot>   In an arithmetic sequence: [0...
11:42:54 <dmhouse> > let digits = ['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z']; showAtBase base n = showIntAtBase base (digits !!) n "" in take 10 $ map (showAtBase 2) [1..]
11:42:55 <lambdabot>  ["1","10","11","100","101","110","111","1000","1001","1010"]
11:43:03 <dmhouse> there we go. A better showIntAtBase.
11:43:06 <dmhouse> > let digits = ['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z']; showAtBase base n = showIntAtBase base (digits !!) n "" in take 10 $ map (showAtBase 3) [1..]
11:43:07 <lambdabot>  ["1","2","10","11","12","20","21","22","100","101"]
11:46:55 <sachu> > let add1 n = n + 1
11:46:55 <lambdabot>  Parse error
11:47:06 <sachu> > add1 5
11:47:07 <lambdabot>  Not in scope: `add1'
11:47:21 <sachu> :-(
11:47:21 <sachu> :-)))
11:47:41 <dmhouse> > let add1 = (+1) in add1 5
11:47:41 <lambdabot>  6
11:47:48 <sachu> > (\x = x + 1) 5
11:47:49 <lambdabot>  Parse error
11:47:55 <sachu> :-(
11:48:32 <sachu> dmhouse: thanks
11:48:35 <dmhouse> > (\x -> x + 1) 5
11:48:36 <lambdabot>  6
11:58:31 <sachu> I am trying to write a definition of a binary search tree. As a first step, I want to create a simple binary tree type, and a function that will take a sequence as input and create a binary tree (adding nodes in plain level-order). I can't seem to figure out how to keep track of the last parent in the tree so that I can add a new node there. How do I go about doing this?
11:59:44 <int-e> sachu: work from bottom up - build trees from pairs of trees
12:01:26 <sachu> int-e: I started out with the following definition : data Tree a = Empty | Tree {rootNode::a, left::Tree a, right::Tree a}
12:01:47 <stepcut> does any remember a bit of (joke?) haskell code that looks alot like perl? Lots of imperative constructions, punctuation, and one letter variable names, etc ?
12:01:51 <int-e> hmm
12:01:58 <sachu> which is intended to be the transliteration of A binary tree type: A binary tree is:
12:01:58 <sachu> 1. Either empty, or
12:01:58 <sachu> 2. Consists of a root node, a left subtree, and a right subtree.
12:02:55 <sachu> I want a function like : createTree :: [a] -> Tree a
12:03:18 <sachu> So I start out with : createTree [] = Empty
12:05:26 <int-e> hmm, with elements at the internal nodes it's more complicated.
12:06:13 <sachu> But I get stuck at the 'createTree (x:xs)' part: To make a tree out of, say, [1,2], I need to start on a tree made out of 1 alone, then add a 2 as its left child. For this, I need a handle to the last parent node in the existing tree. I cannot figure out how to get this. I also have a feeling that this is not the way to look at it :-(
12:06:40 <int-e> You could make a function [(Tree a, a)] -> [(Tree a, a)] that combines two such pairs into one.
12:09:52 <swiert> sachu: try defining how to insert an element into tree.
12:10:52 <sachu> But how do I figure out /where/ in the tree to fit the next element in the sequence? And assuming that I do figure this out, how do I actually fit in that element? AFAI could understand, objects in Haskell are not mutable, and this throws a spanner in my procedural works.
12:13:20 <int-e> that's why working from bottom up is the better method (I've just implemented that, it's 5 lines of code)
12:13:32 <swiert> sachu: it's really not a hard function to write: insert :: Int -> Tree Int -> Tree Int and pattern match on the argument tree.
12:14:31 <sachu> int-e, swiert: thanks, let me try a little more.
12:31:38 <dmhouse> huh. The type theorists are stealing all our words for describing groups of things!
12:32:02 <dmhouse> At first it was 'types' of things, then kinds, and the paper I'm reading talks about types of kinds, sorts!
12:35:42 <int-e> sachu: actually building a tree in level order is harder than building a balanced binary search tree from a sorted list (which amounts to inorder), when doing it bottom up.
12:35:57 <int-e> sachu: but it's still 5 lines of code.
12:42:46 <kzm_> Yo!
12:43:06 <kzm_> Anybody with Cabal experience?
12:47:35 <CosmicRay> somebody I think wrote a podcast client in haskell.  anyone know who that was?
12:47:54 <kzm_> Is it possible to have a library link with .a files using Cabal?
12:52:07 * dmhouse begins to understand the C-H isomorphism :)
12:52:53 <dmhouse> haha! I love it when papers use really down-to-Earth language. The one I'm reading uses the term "Squiggly brackets" :)
12:53:26 <integral> dmhouse: try entering that into Google Scholar, *lots* of hits :-)
12:54:53 <bringert> kzm_: yes, use the extra-libraries field
12:59:15 <kzm_> bringert, I tried that.  It complains about .so's not being available.
12:59:17 <jer> dmhouse, that's fantastic =]
12:59:28 <kzm_> I'm trying to interface to a library that only ships static libraries.
12:59:43 <kzm_> I could add dependencies for all the C files, but I'd rather not :-)
13:00:19 <jer> kzm_, you could perhaps write a shim library using libltdl which can make a shared library from a static library
13:00:34 <bringert> kzm_: does cabal complain, or ghc when you try to use the library?
13:00:38 <kzm_> ghc
13:00:52 <bringert> if you need static linking, use ghc -static -optl-static
13:00:57 <jer> kzm_, (bearing in mind that libltdl is written in c, not haskell)
13:01:08 <kzm_> Loading package fmi-0.0 ... can't load .so/.DLL for: fm_index.a (libfm_index.a.so: cannot open shared object file: No such file or directory)
13:01:25 * kzm_ wonders if that came out right?
13:01:39 <bringert> kzm_: -static -optl-static should fix that
13:01:46 <kzm_> Loading package fmi-0.0 ... can't load .so/.DLL for: fm_index.a
13:02:01 <bringert> is this ghc or ghci?
13:03:22 <kzm_> This was with ghci.
13:03:45 <kzm_> I can of course add the .a's to any executable's compilation.
13:03:54 <kzm_> But I'd really like them to be included in the lib-file
13:04:15 <bringert> an, now I understand
13:04:17 <bringert> ah
13:04:33 <kzm_> i.e. libHS(library-version).a
13:04:50 <kombinator> Has anyone written concurrent application that use network using haskell? I want to wait on a handle for data, but from time to time I want to send data to it, after getting an event from elsewhere. But, according to documentation the thread waiting on the handle may block it. Has anyone done something similar?
13:05:19 <bringert> kzm_: maybe you can play with ar?
13:05:39 <kzm_> maybe :-)
13:06:32 <kzm_> How do I do it the Cabal way?  (This is my first attempt at actually packaging anything with Cabal, so bear with me)
13:06:58 <bringert> with a hook somewhere I guess, but I've never used that
13:11:40 <kzm_> Tried adding the .a files to ld-options, but to no avail :-(
13:19:37 <kzm_> Did the --user switch change lately (6.4.1->20060607)?
13:19:50 <kzm_> I can't get Cabal to install in my home dir anymore.
13:21:55 <kzm_> kombinator, there was a web  server described in one of the concurrency papers?
13:22:43 <kombinator> kzm_: I'll take a look, but I guess you don't need this kind of concurrency in a web server
13:22:59 <kzm_> kombinator, how about STM?
13:23:04 <kombinator> kzm_: as it responds synchronously
13:23:14 <kzm_> (I just read more closely what you asked for :-)
13:23:16 <kombinator> kzm_: yes, I want to use it
13:23:51 <kzm_> or separate read and write handles/locks?
13:23:56 <kombinator> kzm_: but the problem is in read blocking a handle
13:24:11 <kombinator> kzm_: is it possible?
13:25:11 <kzm_> I'm no expert (just started playing with concurrency), but if the handle is a TVar, then a reader won't block it, I think.
13:25:48 <kzm_> Probably a SMOP :-)
13:28:34 <kombinator> kzm_: yes, a simple experiment I did showed that writes proceed even if another thread waits for a read, but this makes me worried (see bottom of the page): http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
13:29:03 <kombinator> "Only one thread may hold the lock on a Handle at any one time, so if a reschedule happens while a thread is holding the lock, the other thread won't be able to run."
13:31:03 <kombinator> kzm_: this probably means that, with bad luck, the writing thread could hang
13:31:05 <kzm_> can't you have a single thread managing the handle, and interface to it via a TVar?
13:31:51 <kombinator> kzm_: but it would need to wait both on the handle (reading) and on TVar
13:32:12 <kombinator> kzm_: and that's not possible afaik
13:33:52 <kzm_> No idea.  You should be able to interrupt the reading thread, though.  But it sounds needlessly complex.
13:34:39 <kombinator> kzm_: right, the only problem is too much locking of a handle
13:42:56 <SamB> hmm, Jade doesn't want me to use "ISO 8879:1986//ENTITIES Publishing//EN//XML", and the entities in the non-XML version don't seem to work
13:43:49 <SamB> (the key difference being that the XML one actually contains codepoints, and the SGML one mysterious things in [])
13:44:20 * SamB tries installing a newer version
13:52:12 <shapr> @yow !
13:52:13 <lambdabot> Now I think I just reached the state of HYPERTENSION that comes JUST
13:52:13 <lambdabot> BEFORE you see the TOTAL at the SAFEWAY CHECKOUT COUNTER!
13:52:21 <shapr> bringert: hiya!
13:52:24 <Lemmih> Good evening, shapr.
13:52:29 <bringert> hi shapr!
13:52:35 <bringert> thanks for all the suggests
13:52:41 <shapr> bringert: Any thoughts on my mail?
13:53:00 <bringert> shapr: I'm working on making the database stuff easier
13:53:06 * shapr rereads the part about urls referencing resources/collections.
13:53:19 <shapr> What about making that part of Session?
13:53:32 <bringert> basically I'll use MonadDatabase everywhere so that you don't have to worry about getting the Database
13:53:42 <shapr> I like it!
13:53:49 <bringert> shapr: it's like Session, but a separate monad transformer
13:53:59 <shapr> Even better!
13:54:00 * shapr boings
13:54:29 <shapr> Any ideas why some photos are listed and others aren't? I can still access the unlisted photos.
13:55:29 <bringert> shapr: getAllImages doesn't return them I guess?
13:55:40 <bringert> maybe something with the user ID which added them
13:55:46 <shapr> Hm, yeah.
13:56:13 <shapr> Oh, I told andrew cooke about Hope and sent him urls for the two installations I know of
13:56:51 <shapr> Does the menu on the left fold and unfold for you? I only see an unfolded version.
13:57:15 <bringert> shapr: I had some problems with that, so I left it constantly unfolded
13:57:22 <bringert> I should be on the TODO
13:57:26 * bringert adds it
13:57:50 <shapr> Do modules add themselves to the menu?
13:57:52 * shapr looks
13:57:56 <bringert> yes
13:58:02 <shapr> Ah, spiffy
13:58:20 <dmhouse> @localtime dons
13:58:21 <lambdabot> Local time for dons is Fri Jun  9 06:49:36 2006
13:58:37 <dmhouse> g'night all.
13:58:40 <shapr> Any thoughts about a post and/or photo to display along with the user info?
13:58:43 <shapr> g'night dmhouse 
13:58:56 <sachu_> dmhouse: g'night 
13:59:00 <bringert> shapr: yes, that would be nice
13:59:27 <shapr> I really like Hope :-)
13:59:30 <bringert> that should be dynamic so that modules can add stuff to user pages
13:59:50 <shapr> Yup, lots of that sort of stuff should be dynamic.
14:00:19 <shapr> For example, I'd like a separate tagging module that can be easily attached to any other module so that any new type can be tagged.
14:00:38 <bringert> yes
14:00:49 * shapr bounces happily
14:00:51 <shapr> This is fun!
14:01:11 <shapr> Especially since I posted a blog entry while at a social function a coupla hours ago.
14:02:21 <bringert> shapr: the TODO is getting long ...
14:02:22 <Lemmih> Hope the programming language?
14:02:23 <shapr> bringert: Do you think limiting display to a single user counts as range limiting?
14:02:38 <shapr> Lemmih: http://www.scannedinavian.com/hope/
14:02:56 <bringert> shapr: by range limiting I meant "get number 10-20 in this list"
14:03:00 <shapr> oh
14:03:21 <bringert> some general mechanism for offsets and lengths in collections
14:03:24 <shapr> I get serious weirdness with the CSS. I just reloaded and now it's extremely narrow. Sometimes it's really wide.
14:03:38 <bringert> halbum has range limiting, but no UI support for it
14:03:55 <bringert> shapr: feel free to figure out what's wrong
14:03:57 <shapr> So collection filter should be done by url, yeah?
14:04:02 <bringert> I did some weird stuff with width
14:04:10 <bringert> shapr: if possible, I think so
14:04:19 <shapr> I'll check it out, I have some nifty firefox plugins for debugging CSS problems.
14:04:35 <shapr> Yay, I get to use my web developer power for good instead of evil!
14:05:43 <shapr> bringert: Why not allow both /user/module and /module/user ? Do you think those two urls should mean different things?
14:05:55 <shapr> Hm, I guess they could/should.
14:05:57 <bringert> hmm, interesting
14:06:11 <kzm_> @localtime kzm_
14:06:12 <lambdabot> Local time for kzm_ is Thu Jun  8 23:05:50
14:06:19 <bringert> I think there should be a single url for each collection 
14:06:21 <shapr> Just thinking about how monad transformers don't always mean the same thing when stacked differently.
14:06:25 <kzm_> I guess that is good night :-)
14:06:43 <shapr> g'nite kzm_
14:06:53 <kzm_> (unless shapr knows how to link static .a's to a cabalized library, that is)
14:06:59 <shapr> Nope, sorry.
14:07:15 <kzm_> Okay.  I really need to catch up on my beauty sleep anyway.
14:07:27 <kzm_> :-)
14:07:40 <Dino__> Is the 'type' keyword just for type synonyms?
14:07:51 <shapr> kzm_: I bet you're beautiful already!
14:07:55 <noj> argh, trying to compile darcs with ghc-6.5.20060526 (OS X/Intel) but it dies when linking, undefined symbols: _ControlziMonadziError_zdf21_closure and _ControlziMonadziError_ZCDError_static_info. Any ideas?
14:08:04 <kzm_> I bet you say that to all the people on IRC.
14:08:07 * shapr laughs
14:08:18 <kzm_> Shit, my wife just came in.
14:08:24 * shapr looks innocent
14:08:42 <kzm_> Hehe.
14:09:08 <kzm_> see you later!
14:10:41 <int80_h> yay I'm back
14:12:40 <shapr> hiya int80_h
14:13:50 <int80_h> hello
14:14:01 <int80_h> there's been madness these last few weeks
14:14:26 <int80_h> schmong.org, the server I use for my haskell work, email and well everything, died
14:14:37 <int80_h> it's back, but I lost everything
14:14:44 <Dino__> Wow, that's rotten.
14:14:55 <int80_h> so we have to install the haskell enviroment again
14:14:58 <xerox> noj - add -package mtl, or something like that.
14:15:10 <int80_h> well I should have been backing stuff up
14:15:22 <int80_h> I didn't realize how much I depended on it until it was gone
14:16:01 <Dino__> That's how I ended up backing things up more seriously. Only after learning the hard way.
14:21:24 <noj> xerox, thanks! has this changed from 6.4 -> 6.5?
14:21:57 <xerox> noj - Beats me.
14:21:59 <ChilliX> http://www.cse.unsw.edu.au/~chak/haskell/VersionTool/
14:22:15 <noj> I mean, I expect darcs to compile out of the box
14:22:22 <shapr> ChilliX: oooh
14:22:39 <noj> oh, it works now so I'm happy. thanks!
14:22:48 <shapr> Maybe I should write a lambdafeed module for Hope.
14:22:56 <shapr> I think Hope is the next lambdabot.
14:22:58 <ChilliX> Hi shapr
14:23:24 <ChilliX> Hope?  (Sorry if I should now...)
14:23:38 <shapr> ChilliX: http://www.scannedinavian.com/hope/
14:23:51 <shapr> ChilliX: http://hope.bringert.net/ being the original installation.
14:23:55 <shapr> bringert wrote Hope.
14:24:09 <dcoutts> hia ChilliX 
14:24:22 <dcoutts> ChilliX, btw, I've not heard from marc_vw for a while
14:24:34 <dcoutts> @seen marc_vw
14:24:34 <lambdabot> I saw marc_vw leaving #haskell 10 days, 23 hours, 29 minutes and 55 seconds ago, and .
14:24:44 <dcoutts> unless he's changed his nick or something
14:25:04 <bringert> ChilliX: I was wishing for something like VersionTool yesterday!
14:25:12 <shapr> Me too!
14:25:38 <ChilliX> bringert: :)
14:28:18 <ChilliX> The version things been buggy me for a quite a while.
14:28:59 <kosmikus> I think I've written something similar for the lhs2TeX cabal stuff, but I've not separated it into a library
14:29:13 <kosmikus> is it like an AC_SUBST in configure?
14:33:17 <ChilliX> Yeah, it does a AC_SUBST kind of thing on the source
14:33:34 <ChilliX> but just for 6 fixed markers
14:33:38 <ChilliX> @VERSION@ etc
14:33:39 <lambdabot> Unknown command, try @list
14:33:49 <ChilliX> lol @ lambdabot
14:34:16 <kosmikus> why not expose the functionality as a Haskell library, that can be used from within Setup.hs ?
14:37:25 <ChilliX> I was briefly thinking about something like that, but didn't want to spent much time with figuring out how to best use if from Setup.hs
14:37:41 <ChilliX> (plus I wrote most of it last week on vacation without internet access and no docs to Cabal)
14:38:05 <ChilliX> but it might be good to have a look at whether it could be changed/adapted that way
14:39:10 <kpreid_> Does Haskell / GHC have something like printing to a string? That is, something that can capture partial outputs, like "... (catch (... (1 : error "x")) (...)) ..." yields "[1*** Exception: x"?
14:39:37 <monochrom> > show True
14:39:38 <lambdabot>  "True"
14:39:45 <monochrom> Is that what you mean?
14:40:26 <monochrom> Hmm looks like I don't understand.
14:47:34 <nomeata> hi. does John Goerzen hang out here from time to time?
14:47:38 <shapr> Often
14:47:44 <shapr> You just missed him.
14:48:15 <nomeata> too bad. what's his nickname?
14:50:17 <shapr> CosmicRay
14:52:57 <psi> dcoutts: ping
14:53:54 <dcoutts> psi, pong
14:54:25 <psi> dcoutts: in System.Glib.MainLoop, shouldn't the constructors of IOCondition be exported?
14:54:54 <dcoutts> psi, possibly
14:55:09 <dcoutts> I can't remember the code of the top of my head
14:55:14 <dcoutts> convince me :-)
14:55:25 <dcoutts> and then darcs send in a patch
14:55:33 <int-e> kpreid_: you mean something like collect (show (1,undefined)) >>= print --> "(1,Prelude.undefined"?
14:55:55 <psi> dcoutts: well, to use inputAdd, you give a list of IOConditions
14:56:09 <dcoutts> ah yes
14:56:26 <dcoutts> but they're not exported from the top level module
14:56:33 <dcoutts> only from some internal module
14:56:36 <kpreid_> @hoogle collect
14:56:37 <lambdabot> Test.QuickCheck.collect :: (Show a, Testable b) => a -> b -> Property
14:56:37 <lambdabot> Data.Graph.Inductive.Internal.Thread.Collect :: type Collect r c
14:56:47 <dcoutts> psi, fine, feel free to send in a patch
14:56:55 <int-e> kpreid_: nah, I just wrote one.
14:57:10 <psi> dcoutts: ok :)
14:57:26 <kpreid_> int-e: I mean that at GHCI, if I evaluate (1 : error "x") I get the output "[1*** Exception: x", and I'd like to reproduce that in a program.
14:57:36 <lisppaste2> int-e pasted "collect (for kpreid_)" at http://paste.lisp.org/display/21031
14:58:32 <int-e> kpreid_: yes, but that's never evaluated as a single string. it tries printing it, gets that far, then catches the exception and prints that.
14:58:40 <kpreid_> of course
14:59:10 <int-e> kpreid_: you can get that effect with Control.Exception.catch and print.
14:59:38 <kpreid_> yes, 'catch (print (1 : error "x")) (print)', but I want to examine the result
15:00:48 <kpreid_> I see how collect does what it does now
15:02:40 <psi> dcoutts: what I actually wanted to do was to call a function whenever I got input on stdin. inputAdd is what I want, right?
15:03:56 <dcoutts> psi, that, or threads and ordinary haskell IO
15:04:30 <dcoutts> psi, I only added inputAdd because someone refused to use haskell threads
15:05:10 <Cale> someone refused?
15:05:10 <dcoutts> psi, you may like to see the Gtk2Hs FAQ on mult-threading
15:06:20 <Cale> <someone> How do I call a function whenever I get input on stdin?  <dcoutts> You use an extra thread.  <someone> No.
15:06:48 <psi> ah yes, I've seen it. could use that, but the mainloop solution seems more elegant to me.
15:07:09 <psi> however, how did he use inputAdd without being able to specify the flags?
15:12:56 <monochrom> To response to both the GUI and the stdin, it is still easiest to use two threads, one for each respectively.
15:13:11 <monochrom> The alternative is select(), but you don't want to go there.
15:13:19 <monochrom> s/response/respond/
15:13:33 <int-e> I thought that's how the RTS implements forkIO and friends?
15:13:50 <monochrom> Yes.  But you don't want to do it yourself.
15:13:54 <int-e> (not forkOS though, because that creates a real OS thread)
15:13:58 <int-e> I agree
15:14:42 <monochrom> The RTS does all sorts of unsafePerformIO and C-level things because it wants to save you.
15:15:43 <palomer> only the Lord can save you
15:15:52 <xerox> ?palomer
15:15:53 <lambdabot> I think you're all nuts
15:16:57 <Cale> ?palomer
15:16:57 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
15:17:11 <Cale> ?palomer
15:17:11 <lambdabot> They're telling you lies!
15:17:25 <monochrom> Was the algorithm written in Ruby?  (Duck)
15:18:02 <Cale> Duck, Goose!
15:22:25 <Cale> @yow
15:22:25 <lambdabot> Hiccuping & trembling into the WASTE DUMPS of New Jersey like some
15:22:26 <lambdabot> drunken CABBAGE PATCH DOLL, coughing in line at FIORUCCI'S!!
15:25:45 <kpreid_> Cale: fyi, I've decided to stick with IO for now
15:28:36 <dcoutts> psi, I think it must be exported from some module just not re-exported from the top level one
15:28:40 <bringert> shapr: I've fixed the database handle thing now, and moved lots of modules around. there will probably br more moving around until I figure out a good structure
15:28:58 <dcoutts> Cale, yeah, it went almost exactly like that, someone just wasn't having it
15:29:25 * bringert goes for lunch
15:29:46 * dcoutts goes to bed
15:30:40 * saccade goes insane
15:32:08 <psi> dcoutts: but it's not exported in the module where it's created
15:40:47 <psi> dcoutts: do you want it exported at top-level or just System.Glib.MainLoop?
15:41:44 <kbrooks_> meta...
15:41:47 <kbrooks_> very meta
15:42:00 <kbrooks_> the haskell compiler is written in haskell
15:42:11 <Cale> yep
15:42:21 <Cale> gcc is written in C :)
15:42:41 <saccade> wait, I thought it was written in ancient hebrew
15:42:53 <kbrooks_> cale: crazy.
15:43:10 <kbrooks_> cal1e: must all compilers be written in teir target languages?
15:43:24 <saccade> compilers can be written in anything
15:43:36 <Cale> kbrooks_: It's good for them to be so, but of course they don't have to be
15:43:47 <psi> hugs (an haskell interpreter) in written in C (right?)
15:43:49 <saccade> you can write a program in python that compiles lisp into C if you want
15:43:52 <saccade> but it would hurt
15:44:05 <saccade> and not in that good way either
15:44:08 <kbrooks_> why.
15:44:12 <Cale> Might not even hurt that much
15:44:30 <Cale> Well, Common Lisp maybe...
15:44:43 <kbrooks_> does this "haskell compiler" bootstrap?
15:44:46 <Cale> yeah
15:44:59 <palomer> have you seen the size of the common lisp standard?
15:45:01 <kbrooks_> bootstrap meaning?
15:45:06 <kbrooks_> palomer: huge?
15:45:10 <palomer> huge is not the word
15:45:16 <saccade> palomer: it's a good footrest
15:45:21 <kbrooks_> palomer: enormous?
15:45:45 <palomer> yeah, enormous cuts it
15:45:47 <Cale> Gargantuan
15:45:49 <kbrooks_> is it this huge: |......................................................................................................................................................|
15:45:57 <palomer> you're going too far Cale.
15:46:14 <saccade> kbrooks_: and much less compressible
15:46:18 <kbrooks_> whats that [] thing in the topic
15:46:19 <psi> what's the biggest language?
15:46:28 <saccade> english
15:46:36 <psi> computer language
15:46:47 <saccade> pseudocode?
15:46:56 <monochrom> The real numbers in decimal notation
15:47:00 <saccade> maybe that doesn't count
15:47:08 <Cale> heh
15:47:17 <saccade> it really depends on what you count
15:47:30 <ptolomy> Am I correct in my conclusion that Data.ByteString.Lazy doesn't currently have a working 'sort'?
15:47:31 <psi> how about size of specification
15:47:52 <saccade> if you include all of cpan, perl is pretty huge
15:47:53 <kbrooks_> psi: python - not so enormous
15:48:13 <kbrooks_> saccade: but not as huge as the clisp standard
15:48:14 <saccade> likewise c# if you count all of the required frameworks and libraries and crap
15:48:16 <monochrom> Oh, written code?  cobol is the largest
15:48:19 <Cale> http://www.lispworks.com/documentation/HyperSpec/Front/index.htm
15:48:36 <int-e> the hyperspec is scary
15:48:39 <kbrooks_> i'd like totrwy and learn haskell. what will i have to drop
15:48:41 <saccade> monochrom: I guess, but most of that is govt code, right?
15:48:48 <monochrom> and banks
15:48:53 <saccade> kbrooks_: a bunch of assumptions?
15:49:05 <kbrooks_> saccade: such as?
15:49:11 <psi> I've never seen cobol in the wild
15:49:28 <kbrooks_> go, COBOL! :P 
15:49:33 <saccade> kbrooks_: depends -- what do you program in now?
15:49:33 <kbrooks_> j/k
15:49:35 <ptolomy> C++ seems to have a big core language to me, but I think that is just a result of the way it is organized.
15:49:35 <int-e> the c++ spec is big but awfully detailed. I can't say that of the hyperspec. That's just big.
15:49:43 <kbrooks_> saccade: OOP languages
15:50:13 <Cale> kbrooks_: Imperative OOP languages probably?
15:50:16 <psi> hyperspec = cl spec?
15:50:17 <saccade> you're going to have to learn new ways about how abstraction can work
15:50:20 <saccade> and flow control
15:50:38 <Cale> and you're going to have to learn to get along without mutable variables
15:50:40 <kbrooks_> well, i'l dive in. is there a free (online) book?
15:50:50 <Cale> @where yet another haskell tutorial
15:50:51 <lambdabot> I know nothing about yet.
15:50:54 <Cale> @where yaht
15:50:55 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
15:51:02 <palomer> it's as if the common lisp designers had been little kids in a language feature selling toys'r'us
15:51:14 <kosmikus> is yaht still the best tutorial out there?
15:51:16 <Cale> there's a decent one to start with -- it's incomplete, but what's written is mostly pretty good
15:51:34 <saccade> hal is pretty smart
15:51:41 <Cale> I kind of feel like writing a new one :)
15:51:47 <palomer> do it!
15:51:50 <saccade> though his ideas about discourse representation models are wack
15:52:39 <kosmikus> Cale: yes, please, write a new one
15:52:56 <saccade> that would be cool
15:53:19 <Cale> If you get to the part on continuations and it doesn't make sense, just skip it, it's something you can pick up later on (I think it's misplaced in that text)
15:53:25 <int-e> palomer: yet common lisp still doesn't have essential features like FFI.
15:53:35 <palomer> all in favour of cale writing a new tutorial, say ay
15:53:39 <Cale> heh
15:53:44 <kosmikus> how usable is http://en.wikibooks.org/wiki/Programming:Haskell ?
15:54:13 <Cale> last I looked at it, not as usable as it should be, but it includes some good snippets
15:54:37 <Cale> I wrote a good chunk of the section on List Processing
15:54:52 <kosmikus> :)
15:55:09 <kosmikus> well, if any new attempts are made, I'd appreciate them to be free
15:55:37 <ptolomy> Am I correct in my conclusion that Data.ByteString.Lazy doesn't currently have a working 'sort'? (I said this a few minutes ago, sorry for re-asking)
15:55:41 * palomer wants to hear mre ay's!
15:55:45 * Cale winces "if Statements"
15:55:46 <kosmikus> there are many good Haskell books (printed), so if something is to be really useful it should be fully open
15:56:31 <Cale> yeah
15:56:39 <kosmikus> I don't have a problem with "if statement". it's a phrase commonly used, even though it's slightly incorrect.
15:57:30 <kosmikus> in a book to teach a language, however, you might want to be precise ...
15:57:31 <psi> you want if expression?
15:57:36 * palomer doesn't like the print haskell books
15:57:40 <Cale> yes, I changed it already
15:58:06 <kosmikus> palomer: not a single one of them?
15:58:32 <palomer> nope
15:58:34 <saccade> int-e: to be fair, it can talk to the OS, though that's clearly not preferable
15:58:48 <palomer> I don't like the monad chapter in yaht either
16:00:07 <int-e> saccade: I remember seeing a GUI lib that consists of a clisp library talking to a C part through a socket. yuck.
16:00:09 <kosmikus> I don't like yaht very much, but that may be because of bad typography. I have the problem that I find it hard to read books with potential good content if they aren't aesthetically pleasing
16:00:16 <palomer> to learn monads, you need to write them, the chapter should be: write the following monads which have the following properties <describing Reader, Writer, State, List, Maybe, etc...>
16:02:53 <palomer> it would end with Cont
16:03:21 <monochrom> I agree.
16:19:23 <heatsink> > ([] ++ [] ++)
16:19:24 <lambdabot>   The operator `++' [infixr 5] of a section
16:19:24 <lambdabot>    must have lower precede...
16:20:00 <heatsink> Doesn't seem quite right to me, but okay...
16:29:22 <Cale> palomer: well, you do need at least some examples of how to do it first :)
16:29:47 <Cale> though I suppose with a good enough description, it wouldn't be so bad
16:30:10 <Cale> I'd at least include making some tree type a monad
16:34:53 <palomer> you and your containers
16:35:04 * palomer calls return on Cale and puts him in a box
16:47:39 * int-e hopes it's not a maybe monad that's about to fail.
17:01:21 * SamB thinks something is wrong with SP
17:03:20 <psi> @help tell
17:03:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:03:38 <psi> didn't someone add that command?
17:04:17 <palomer> @palomer
17:04:17 <lambdabot> I think vim is good for the rubbish bin
17:04:21 <psi> maybe just for testing
17:04:24 <palomer> @palomer is far more useful
17:04:25 <lambdabot> They're telling you lies!
17:04:29 <palomer> no I'm not
17:04:30 <psi> hehe
17:04:58 <Cale> that's such a great exclamation
17:05:19 <Cale> @palomer
17:05:19 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
17:05:22 <Cale> @palomer
17:05:22 <lambdabot> Category theory is the Paris Hilton of mathematics
17:05:25 <Cale> @palomer
17:05:25 <lambdabot> I think vim is good for the rubbish bin
17:05:34 <Cale> @palomer
17:05:35 <lambdabot> Category theory is the Paris Hilton of mathematics
17:06:40 <Cale> http://telefunkenusa.com/products/show_product.php?item=7&cat=mics -- a $7500 microphone
17:06:41 <palomer> actually, Paris Hilton is too good for category theory
17:08:54 <palomer> I wouldn't be surprised if she invented it, and threw it away in disgust
17:09:12 <dons> moin
17:10:10 <Cale> not to mention http://www.telefunkenusa.com/products/show_product.php?item=1&cat=mics which is a $16,000 microphone
17:10:23 <SamB> so apparantly even now that XML is SGML, SGML doesn't understand hex character references by default and I see no easy way to enable it without writing out a whole SGML declaration...
17:11:51 <palomer> how are these microphones better than the ones at best buy?
17:11:56 <dons> @seen petekaz
17:11:56 <lambdabot> petekaz is in #haskell. I last heard petekaz speak 9 hours, 3 minutes and 21 seconds ago.
17:13:49 <Cale> Um, they're meticulously handcrafted?
17:13:56 <Cale> Well, they're supposed to sound really good. Then again, they'd better, at that price.
17:25:58 <psi> I've installed a handler for sigINT, and in there I run exitWith, but it doesn't seem to actually exit the program
17:26:03 <psi> why might that be?
17:26:34 <dons> sigINT isn't being invoked?
17:26:48 <dons> you have an exception handler to ignore it?
17:26:52 <psi> yep, it is
17:27:00 <psi> I also print in the function so I can see it
17:27:25 <dons> try exitImmediately
17:27:29 <dons> ?hoogle exitImmediately
17:27:30 <lambdabot> No matches found
17:27:33 <dons> hmm...
17:27:58 <dons> System.Posix.Process.exitImmediately
17:28:05 <psi> alright
17:28:08 <stepcut> dons, I found a subtle but in fps.cabal
17:28:09 <dons> will often work in tricky situations ;)
17:28:14 <stepcut> s/but/bug/ :)
17:28:17 <dons> stepcut, ah yes?
17:28:26 <dons> there are bugs in cabal files now??
17:28:51 <stepcut> dons: 'include-dirs:        cbits'
17:29:29 <dons> right. ok. what's the subtle bug? should c-sources then not have a cbits prefix?
17:29:36 <dons> or is it missing a /
17:29:37 <stepcut> include-dirs gets copied into .installed-pkg-config, which is used by ghc-pkg when it adds the package
17:29:59 <psi> dons: it did indeed
17:30:02 <stepcut> but ghc-pkg can only find 'cbits' if you happen to be in the 'fps' directory
17:30:09 <psi> I wonder what's happening
17:30:18 <dons> stepcut, hmm. 
17:30:30 <stepcut> of course, when you run ./Setup.hs install, you are in the fps directory, so everything is happy :)
17:30:40 <dons> ah!
17:30:45 <stepcut> but, when I debianized the package, I could only install the .deb if I was in the fps directory
17:30:50 <dons> but when for example, i run it in a different dir...
17:31:06 <dons> there'll end up being errors about missing c objects?
17:31:38 <stepcut> no, it just prevents package installation, because ghc-pkg can not find the 'cbits' directory
17:31:51 <stepcut> cabal does not appear to actually install cbits anywhere
17:31:55 <dons> ah, ok. haven't seen that. good point. 
17:32:02 <dons> hmm, so what should the correct value be then?
17:32:05 <stepcut> it seems to only be needed when you are building fps
17:32:27 <stepcut> dons: not sure, I just added to ghc-options
17:32:28 <stepcut> ghc-options:         -Wall -fglasgow-exts -O -optc-O -funbox-strict-fields -Icbits
17:32:41 <stepcut> but, i am not sure how hugs, etc deal with that
17:32:43 <dons> yeah, ok. lets see. but then do the HSfps_cbits.o get installed?
17:33:11 <dons> maybe that's what the c-sources: line does
17:33:16 <dons> i'll try this out, cheers!
17:33:37 <stepcut> dons: I don't think I ever got a HSfps_cbits.o installed 
17:33:49 <dons> but then you'd never link properly, would you?
17:33:53 <dons> there'd be 5 missing symbols
17:34:08 <stepcut> I do get these:
17:34:08 <stepcut>     /usr/local/lib/fps-0.2/HSfps-0.2.o
17:34:09 <stepcut>     /usr/local/lib/fps-0.2/libHSfps-0.2.a
17:34:19 <dons> oh, hmm. neither do i.
17:34:25 <stepcut> :p
17:35:00 <dons> ah, but:
17:35:02 <dons> libHSfps-0.7.a:fpstring.o:
17:35:02 <dons> 000000af T count
17:35:02 <dons> 00000000 F fpstring.c
17:35:02 <dons> 00000021 T intersperse
17:35:04 <dons> 0000005f T maximum
17:35:07 <dons> 00000087 T minimum
17:35:09 <dons> 00000000 T reverse
17:35:14 <dons> so we don't need a separate cbits archive
17:35:35 <stepcut> yeah
17:35:43 <dons> ok, i'll remove the cbits line, add -Icbits, and see if ghc and hugs are ok with it
17:35:58 <stepcut> well, ghc needs you to put it somewhere (like on the ghc-options line)
17:36:02 <dons> this might explain some other build weirdness with the cbits i've seen
17:36:06 <dons> right.
17:36:12 <stepcut> not sure what hugs needs
17:36:28 <dons> yeah, we'll see...
17:37:02 <stepcut> :)
17:37:43 <dons> ok, builds fine without the iinclude-dirs under ghc
17:38:10 <dons> and seems to link ok.
17:38:36 <dons> right, hugs need some include flag
17:39:46 <dons> hmm, hugs runs: 'gcc -DNDEBUG=1 -g -I/usr/local/include -L/usr/local/lib -shared -fPIC -D__HUGS__ "-I/home/dons/lib/hugs/include" "dist/build/Data/ByteString/Base.c" -o "dist/build/Data/ByteString/Base.so" cbits/fpstring.c
17:39:54 <dons> which fails, due to missing include dirs, of course.
17:40:02 <dons> now, what's the hugs -I flag
17:40:36 <stepcut> no idea
17:49:52 <dons> stepcut, maybe its a cabal bug. i think i'm really supposed to use include-dirs for specifying include dirs
17:50:04 <dons> lets see what the cabal docs say on this matter
17:51:18 <dons> ah, maybe i'm missing install-includes: ..
17:53:20 <stepcut> dons: yeah, I was not quite sure what the right solution was either
17:53:53 <dons> are you able to test changes to the .cabal file now?
17:54:03 <dons> or any hints on how i could reproduce the error here?
17:56:34 <dons> oh, install-includes is only in the darcs version of cabal
18:07:22 <psi> dcoutts: I made inputAdd take a (IOCondition -> IO Bool) instead of a IO Bool. is that acceptable? I pass it the satisfied condition.
18:07:50 * psi sleep
18:09:18 <psi> oh, btw. anyone here played xjump? :D
18:11:35 <dons> ?quit bunch of new stuff added
18:30:52 <shitlog> is there no way to put a restriction on the contents of a generic container, i.e. require it to be of a specific class?
18:33:28 <dons> yeah, on the functoins that use it, or in the type class head or method type
18:33:54 <dons> instance C x => D x where ... ; f :: C x => x -> b ; ... and more so
18:34:21 <shitlog> I see
18:34:34 <dons> what do you mean by generic container? you mean polymorphic in the elements?
18:34:38 <ricebowl> yeah
18:34:54 <dons> then its just normal bounded polymorphism, as above. no tricks 
18:37:00 <ricebowl> right, but in my case it makes more sense to restrict the contents of the container
18:39:24 <ricebowl> I have a container which at present is fully specialized. It's part of an X86 disassembler.
18:39:42 <ricebowl> I have one case for each form of an instruction
18:39:52 <ricebowl> but generally it makes more sense to match all forms of add, etc.
18:39:55 <dons> orsomething like: data (Integral a) => D a = D [a]
18:40:09 <dons> there's a bunch of different ways to add class constraints, depending on how you use your container type
18:40:18 <ricebowl> well, it's not generic ATM.
18:40:29 <ricebowl> but in order to allow the mneumonic to be matched, I would make it generic
18:44:02 * stepcut wrote a game like xjump in assembly once
19:22:55 <Lemmih> @seen ADEpt
19:22:55 <lambdabot> I haven't seen ADEpt.
19:37:17 <heatsink> @pl foldr (.) id
19:37:17 <lambdabot> foldr (.) id
20:20:04 <lispy> @pl \x -> foldr (.) x
20:20:04 <lambdabot> foldr (.)
20:20:19 <lispy> @pl \x -> foldr (.) id x
20:20:19 <lambdabot> foldr (.) id
20:26:32 <heatsink> @fact
20:26:32 <lambdabot> I can not handle empty facts.
20:27:56 <lispy> heh, a meta-fact
20:28:02 <lispy> @fact of life
20:28:02 <lambdabot> I know nothing about of
20:28:06 <Korollary> @fact lambdabot cannot handle empty facts.
20:28:06 <lambdabot> I know nothing about lambdabot
20:28:07 <lispy> @fact haskell
20:28:08 <lambdabot> I know nothing about haskell
20:28:34 <lispy> @fact lispy's_secret_desires_to_take_over_the_world
20:28:34 <lambdabot> I know nothing about lispy's_secret_desires_to_take_over_the_world
20:28:43 <heatsink> @fact gibbardish
20:28:43 <lambdabot> I know nothing about gibbardish
20:28:45 <heatsink> @fact Gibbardish
20:28:45 <lambdabot> I know nothing about gibbardish
20:28:52 <Korollary> @fact fps
20:28:53 <lambdabot> I know nothing about fps
20:28:56 <heatsink> Hmm, I thought I set that one
20:28:57 <Korollary> @where fps
20:28:57 <lambdabot> I know nothing about fps.
20:29:08 <Korollary> @where dons
20:29:08 <lambdabot> I know nothing about dons.
20:29:11 <Korollary> heh
20:29:13 <lispy> @uptime
20:29:13 <lambdabot> uptime: 1 hour, 28 minutes and 42 seconds
20:29:16 <Korollary> blasphemy
20:29:24 <lispy> @keal
20:29:24 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
20:29:27 <Korollary> lol
20:29:28 <lispy> phew...
20:29:54 <Lemmih> @keal
20:29:55 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
20:30:08 <lispy> ah, the darkmanifold
20:30:35 <lispy> sounds like a ninjitsu technique
20:30:45 <Lemmih> @keal
20:30:46 <lambdabot> are you saying i am MegaMonad?
20:31:15 <heatsink> @girl19
20:31:16 <lambdabot> am I supposed to be frantic with terror and anxiety?
20:31:17 <lispy> that's one of the more fitting things keal said
20:31:28 * heatsink doesn't know MegaMonad
20:31:50 <lispy> as i understand it was/is a haskell implementation of megahal
20:32:13 <lispy> have you seen megahal?  i used to have a lisp bot (but it's broken) that bridged megahal to irc
20:32:43 <heatsink> noip
20:32:50 <heatsink> @seen megahal
20:32:50 <lambdabot> I haven't seen megahal.
20:34:16 <lispy> http://megahal.alioth.debian.org/Classic.html
20:34:16 <Korollary> woo world cup '06
20:34:22 <dons> i zapped the lambdabot state archive by mistake. i'm fixing this as we speak.
20:34:36 <dons> darcs record --all can be a bit overzealous at times ;)
20:35:14 <lispy> heh
20:35:25 <lispy> yeah use darcs re -a
20:35:33 <lispy> much shorter and still to zealous :)
20:35:47 <lispy> or maybe re is too short
20:35:51 <lispy> make that rec
20:36:15 <Dino__> I'm looking at Distribution.GetOpt and System.Console.GetOpt, they look the same.
20:36:53 <Dino__> Is one of them preferred? I suspect the GetOpt has migrated coreward from somewhere.
20:37:57 <dons> System.Console..
20:37:59 <dons> its in base/
20:38:23 <Dino__> And the other one is Cabal. Ok, I suspected. Thank you.
20:38:59 <Lemmih> Distribution.GetOpt is hidden.
20:39:28 <Dino__> What does that mean? import won't work?
20:39:49 <Lemmih> Hm, it's exposed in ghc-6.5.
20:41:20 <Lemmih> Dino__: Yes.
20:43:24 <Dino__> Is it something like scoping where only some modules can see the hidden things? Or maybe sort of like Java's deprecation mechanism for phasing out code.
20:44:13 <dons> a bit more like public/private on the module level
20:45:43 <Dino__> Ok. Thanks.
20:49:17 <dons> implicit parameters interact a little weirdly with the impredicativity in 6.5
20:49:22 <dons> maybe i shouldn't be mixing those two
20:49:33 <dons> clearMessages n = modifyMS (M.delete n) -- is fine
20:49:45 <dons> clearMessages = modifyMS . M.delete-- type error
20:50:06 <SamB> I don't think you are supposed to use them at all
20:50:19 <dons> quite so.
20:50:28 <dons> they will be purged. but we need a monad to replace them
20:50:39 <dons> so you know, more work.
20:51:08 <SamB> you know where to find ReaderT...
20:51:16 <SamB> and you know how to newtype
20:51:25 <SamB> I think you have all the tools you could possibly need ;-)
20:51:37 <dons> indeed.
20:52:26 <dons> it'll probably only happen if they break entirely, or a removed from the compiler though
20:52:47 <dons> maybe not, maybe i'll just get sick of them at some piont
20:55:15 <dons> $ darcs get /home/dons/code/lambdabot
20:55:15 <dons> Copying patch 982 of 982... done!
20:55:17 <dons> :)
20:55:22 <dons> getting close
20:56:24 <dons> ?quit rejigging
20:58:09 <SamB> @karma-all
21:00:16 <SamB> Imagine writing an SGML document... in which you don't put any tags!
21:00:53 <heatsink> It's easy if you try o/~
21:01:25 <SamB> well, what if it looked just like a scheme program except for the <!DOCTYPE ...> at the top?
21:02:13 <heatsink> That would be nicer-looking, and easier to parse.  What about the text that's not in tags, though?
21:03:17 <SamB> well, it turns out that DSSSL specs are generally just such SGML documents ;-)
21:04:11 <SamB> apparantly the DTD forces the code to be inside some implicit elements, if you don't put in any tags
21:04:24 <SamB> at least, if you use the one that comes with Jade ;-)
21:04:59 <SamB> unfortunatelely, the DTD can not be used to validate your code.
21:05:29 <SamB> but I did discover that you don't have to escape < or >
21:05:47 <SamB> at least, as long as you don't put letters after <, I think
21:06:26 * SamB is trying to write a DSSSL spec to translate the DSSSL spec from SGML to HTML
21:07:56 <palomer> sounds like...fun
21:09:47 <SamB> well, so far I've got it highlighting the elements I haven't written code for in RED, and printing out all their attributes, implicit or otherwise ;-)
21:10:59 <SamB> that is, it prints out opening and closing tags with the element name in red
21:11:15 <heatsink> personally, I'm intimidated by markup language standards.
21:11:49 <SamB> well, DSSSL isn't much of a markup language
21:11:55 <SamB> it is more of a Scheme variant
21:12:27 <SamB> which happens to keep its source code in valid SGML files
21:12:56 <heatsink> That sounds like quine material
21:14:12 <SamB> did I mention it has none of the imperative constructs?
21:14:29 <SamB> there are some context-dependant things, though
21:15:01 <SamB> so you'd at least need a reader monad to implement it properly
21:16:43 <SamB> hmm, fascinating, links doesn't care if LIs come inside lists or not
21:17:53 <SamB> hmm, what is a good way to format notes in HTML...
21:18:59 <heatsink> I generally write notes in an unstructured style.  Lots of gotos.  Doesn't work well with block-structured languages like html.
21:20:22 <SamB> I suppose the hip way these days is to use a div class of some kind
21:20:29 <SamB> er, a div with a class
21:21:39 <heatsink> You could get plenty of opinions on that in #web
21:23:46 <SamB> well, I'm too lazy to bother ;-)
21:24:11 <SamB> especially since I already have fairly-well structurally marked up SGML
21:24:24 <SamB> or at least, the parser seems mostly okay with it
21:24:34 <SamB> and it looks to have a nicely structured parse tree
21:35:05 <SamB> ... though the first few sections have special elements instead of using the normal elements for sections...
21:35:19 <mathewm> anyone ever hear of 'breakFirst' 
21:35:31 <mathewm> @hoogle breakFirst
21:35:32 <lambdabot> A Hoogle error occured.
21:37:58 <dons> oh, lambdabot's not supposed to be attached. hmm.
21:38:02 <dons> ?version
21:38:03 <lambdabot> lambdabot 3.1p73, GHC 6.4.1 (Linux i686 3.20GHz)
21:38:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:47:45 <mathewm> @pretty breakFirst c xs == let (x,y) = break (== c) xs in if null y then Nothing else Just (x, drop 1 y))
21:47:55 <mathewm> :( 
21:48:04 <mathewm> so lonely without the 'bot :(
21:49:43 <dons> yeah, i broke it badly somehow, and am debugging away like crazy
21:50:17 <Lemmih> mathewm: Try 'ghci -ddump-parsed'.
21:54:13 <dons> hmm, suddenly my packets aren't getting pushed in the Chan. bizarre
22:00:41 <lispy> dons: you have to stop drinking when you work on lambdabot :)
22:01:20 <dons> i rewrote the build system, and somewhere along the line something broke.sigh. i wish i had more clues 
22:01:42 * dons darcs unpulls
22:01:48 * sieni lends his clue bat to dons
22:14:37 <dons> is comforting tojust roll back a few patches, and things start working again. good darcs
22:14:52 <dons> ah ha! found the bad patch. very interesting
22:16:29 <Lemmih> What did it do?
22:17:27 <dons> not sure yet...
22:18:10 <dons> need to make clean, and build over to check i'm on the right path..
22:27:49 * SamB is happy -- he got hyper-references to work in his DSSSL sheet
22:29:47 <lisppaste2> Ronald Mai pasted "WWWDOT - GOOGLE = DOTCOM" at http://paste.lisp.org/display/21046
22:31:03 <Dulath> hey guys, is cos acos and sin returning stuff in radians?
22:31:32 <heatsink> Dulath: cos and sin return unitless values
22:31:45 <heatsink> Dulath: acos returns radians
22:32:15 <Dulath> Ah, ok.
22:34:33 <dons> bah, lisppaste spam? 
22:34:56 <dons> no, not quite. just badly titled?
22:35:08 <Dulath> Do they accept radians?
22:35:32 <heatsink> How could google stoop so low? ;)
22:36:07 <heatsink> It's some clever program.
22:36:23 <heatsink> > sin pi
22:36:26 <scodil> how do you hide definitions from modules you import? Like if do "import OpenGL as GL" and I want those definitions to only be availible under as GL.x
22:36:40 <dons> iport qualified ...
22:36:52 <scodil> thanks
22:41:03 <scodil> is there a way to hide certain symbols from imported modules? like "import OpenGL hiding Point" or something like that?
22:41:18 <scodil> or do you have to pick the ones you _do_ want to import
22:41:35 <dons> sure. you can hide things, or list explicit things
22:41:46 <scodil> how?
22:41:52 <dons> import qualified Data.Map    as M hiding (Map)
22:42:05 <dons> import Prelude hiding   (mod, catch)
22:42:15 <scodil> ah ok i was missing the parens. thanks
22:43:13 <SamB> hmm, mozilla doesn't like my not-quite-valid three-and-a-half megabyte HTML file very much :-(
22:43:31 <heatsink> :(
22:43:50 <SamB> well, it has gotten to the end.
22:44:31 <SamB> (At least Jade managed to process the entire SGML document, despite the fact that it was not quite valid!)
22:44:50 <SamB> (there was a close tag where there shouldn't have been, apparantly
22:45:56 <Dulath> I'm not having any luck with this function:
22:45:57 <Dulath> flightDistance x y = 3963 * acos (cos (fst x * pi/180) * cos (snd x * pi/180) * cos ((fst y - snd y) * pi/180) + sin (fst x * pi/180) * sin (snd x * pi/180))
22:46:16 <Dulath> flightDistance (45.58,122.6) (44.12, 123.22) should return something like 100
22:46:22 <Dulath> But I get 4009, any advice?
22:46:56 <heatsink> Dulath: write a function that computes part of flightDistance and see if it matches what you get by hand.
22:47:39 <SamB> (I suspect that mozilla might be slightly faster if the document was valid)
22:59:33 <Dulath> heatsink: why is acos returning radian * 100?
23:00:22 <heatsink> Dulath: I get radian results.
23:00:28 <Dulath> test = cos (45.58 * pi/180) * cos (44.12 * pi/180) * cos ((122.6 - 123.22) * pi/180) + sin (45.58 * pi/180) * sin (44.12 * pi/180)
23:00:30 <heatsink> acos 0 = 1.571
23:01:39 <Dulath> for some reason acos of (0.99964593910) is giving me 2.6611
23:02:12 <heatsink> I get 2.6611e-2
23:02:20 <heatsink> which is 0.026611
23:03:49 <heatsink> It should be the same for you, unless there's a bug in the runtime.
23:04:26 <Dulath> No, it's the same
23:04:43 <Dulath> but for some reason it isn't multiplying with 3968
23:05:21 <heatsink> 3963?
23:05:55 <Dulath> Doh, yeah
23:06:39 <Dulath> or 3963.00 to be more percise
23:09:53 <heatsink> I don't know what to say, try taking it apart until you find what's broken.
23:10:06 <heatsink> I'm due for bed.
23:10:46 <kzm> good morning!  Is there a way to get Cabal to link a library (libHS,,,.a) against other .a files?
23:11:16 <kzm> I'm FFIing to a C library, which by default only builds a static.
23:11:27 <dons> add ld-option: ?/
23:11:41 <dons> ld-options: .. I mean
23:12:10 <kzm> I tried ld-options: -lstatic foo.a bar.a
23:12:27 <Dulath> Doh
23:12:34 <Dulath> heatsink: The problem was caused by type casting
23:12:43 <kzm> and ghc-options -optl-static, for good measure :-)
23:13:11 <dons> Lemmih, oh. lambdabot might actually work if I load the Base plugin!! :/
23:13:39 <kzm> btw, dons, I streamed through 3.6Gb of FASTA file in about 8 minutes (10M EST sequences)
23:13:46 <dons> excellent!
23:14:00 <dons> what kind of operatoins did you apply to it.
23:14:04 <kzm> counting the # of sequences, and the # of nucleotides.
23:14:13 <dons> cool. sounds reasonable.
23:14:17 <dons> is that good enough performance?
23:14:30 <kzm> Using my own primitive hGetLines - possibly your "native" one is faster?
23:14:44 <dons> oh, not using Data.ByteString.Lazy? that should be the best
23:14:56 <kzm> Good enough for me.  Still a factor of 10 from grep and wc, I think.  Let me check...
23:15:43 <dons> Lazy.hs runs within 6% of tr. so i suspect you can do a lot lot better then
23:16:05 <dons> try Lazy.lines =<< Lazy.getContents, if you need lines-based stuff
23:16:11 <kzm> but on the bright side, we're using less memory than 'grep' :-)
23:16:24 <dons> kzm, any chance you could post the code? I wouldn't mind using it as a benchmark.
23:16:42 <kzm> Larger chunks will likely improve performance, yes.  Didn't you have a curve somewhere?
23:16:57 <dons> yeah, 32k size seems to be best (size of the L1 cache)
23:17:23 <kzm> That's with separate D and I caches (I guess nobody does unified L1 anymore)
23:17:25 <kzm> ?
23:17:37 <dons> oh, jus twhatever my PentiumM laptop has. ..
23:20:06 <kzm> Factor of 10 was a bit pessimistic (extrapolated from smaller benchmarks)...I got the sequence count in 20% of the time, and the nucleotide count in less than 30%.
23:20:40 <dons> i suspecy you can do better. post it somewhere, or mail me, if you'd like some hints
23:20:44 <dons> suspect
23:20:54 <kzm> But my Haskell program is CPU bound, while grep is IO bound (15-20% of the CPU).
23:21:28 <kzm> Yes.  Give me a second, I'll put the repo somewhere.
23:21:45 <dons> with a bit of attention to what operations are copying, and what will just take substrings, you might be able to improve the cpu-boundedness
23:23:32 <kzm> darcs get http://www.ii.uib.no/~ketil/bioinformatics/repos/fasta ?
23:24:04 * dons gets..
23:24:05 <kzm> That is true, likely I'm copying a lot more.  So it's not a fair comparison at all.
23:24:24 <dons> http 404?
23:24:30 <kzm> Ugh.
23:24:34 * kzm checks.
23:25:55 <kzm> Try again.
23:26:20 <kzm> (I had accidentally 'put' it directly in the repos/, not in a fasta/ subdir.)
23:26:45 <dons> works.
23:26:47 <kzm> Want a feature request, dons?
23:26:56 <dons> yeah, sure?
23:27:03 <dons> ?version
23:27:28 <lambdabot> lambdabot 3.1p90, GHC 6.5 (OpenBSD i386 )
23:27:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:28:14 <kzm> My specific problem: I would like to read a bunch of Sequences (cf. Fasta.hs) and store all of the sequence data parts (the second BS) concatenated in one large BS, so that the sequences just refer to slices of the concatenation.
23:29:09 <kzm> Using 'concat' would mean keeping a copy of everything in memory, so if I could specify the length in advance (which will be shorter than file size), it'd be nice to store them directly in the concatenation.
23:29:36 <kzm> I'm not sure this problem can be generalized sufficiently for it to make sense to have in the basic BS library.
23:30:35 <dons> hmm you might be able to approach it by using .Lazy, since then you wouldn't need to keep everything in memory , and concat has different complexity
23:30:53 <kzm> (The reason I want this, is to pass the concatenated string to a C library, so I don't think .Lazy will help)
23:31:10 <dons> ah, right. ok. i'll have to think.
23:31:23 <dons> you compiling with -funbox-strict-fields ?
23:31:29 <dons> and -O ?
23:31:48 <kzm> Not sure.  -O, certainly.  
23:31:57 <kzm> I'll recompile and check?
23:32:09 <dons> unbox-strict-fields should make a difference in any fps code
23:33:16 <dons> oh, my 10M fasta file is too small these days..
23:33:22 <kzm> :-)
23:33:22 * dons makes a bigger one
23:34:53 <dons> ok, i'm looking at the code, to see if i can work something out.
23:35:34 <kzm> Tried the half-gig file, doesn't seem to change much (presumably FPS itself is compiled with -funbox)
23:36:05 <dons> yeah. could be that.
23:36:07 <kzm> Right.  You do the hard work, I'll get some coffee.  How I love the internet!
23:36:11 <kzm> :_)
23:36:48 <dons> hehe
23:37:44 <kzm> (or, the way it's usually spelled: thanks!)
23:45:30 <dons> ok, readFile >>= lines is about twice as fast
23:45:39 <dons> lines takes substrings
23:52:31 <kzm> Twice as fast as my hGetLines, or yours?
23:52:47 <Dulath> Ok, I'm writing an isPrime function and I got something like test = 3963.00 * acos (cos (45.58 * pi/180) * cos (44.12 * pi/180) * cos ((122.6 - 123.22) * pi/180) + sin (45.58 * pi/180) * sin (44.12 * pi/180))
23:52:47 <Dulath> -- flightDistance x y = 3963 * acos (cos (fst x) * cos (snd x) * cos (fst y - snd y) + sin (fst x) * sin (snd x))
23:52:50 <Dulath> crap
23:52:58 <Dulath> Disregard that
23:53:23 <dons> kzm, some other questions, that filter (not.isSpace) is slow? are there some assumptions we can make?
23:53:32 <dons> like only ' ' chars appear/
23:53:43 <dons> or only the end of line '\n' needs to be removed?
23:54:07 <dons> the higher-order filter is going to do a copy, and be slow, so itd be good to avoid
23:54:51 <kzm> I'm a bit wary of making assumptions.  But yes, we need to merge the lines (removing \n), and possibly trailing whitespace.
23:55:13 <kzm> I don't think there will be any wsp in the middle, so perhaps it is only necessary to look at the end(s)?
23:55:18 <dons> oh, so stuff at the end of the line?
23:55:22 <dons> yeah, sounds better
23:55:47 <Dulath> Ok, I'm writing an isPrime function and I got something like isPrime x = x `mod` head([2..sqrt(x)]) == 0 but I need to recurse through that list and make sure none of them return 0, any ideas how to do this with finesse?
23:55:51 <kzm> I've never *seen* any Fasta file with spaces in the middle, but it's not exactly an ISO standard...
23:56:29 <kzm> Dulath, "head"?
23:56:50 <Korollary> Dulath: check this out
23:57:14 <Dulath> kzm: yeah, I need to get one element out of the list at a time
23:57:32 <Dulath> and I need to recursively call the function passing it the tail of it
23:57:46 <Dulath> I'm framilar with common lisp, but I have no idea how to do this in haskell
23:58:05 <Korollary> > map (\x -> x `mod` 5) [2..20]
23:58:06 <lambdabot>   Failed to load interface for `ShowQ':
23:58:07 <lambdabot>    Could not find module `Show...
23:58:18 <Korollary> er
23:58:20 <kzm> Dulath, something like: and [ x `mod` y == 0 | y <- primes ]
23:58:52 <Korollary> What ShowQ?
23:58:59 <Dulath> Err...
23:59:30 <Lemmih> ADEpt: Hi.
23:59:49 <Dulath> wow
