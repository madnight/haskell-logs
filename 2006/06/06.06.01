00:00:04 <flux__> there are gc's that are designed for realtime systems
00:00:08 <vincenz> especially on multicore systems
00:00:26 <eivuokko> vincenz, That also becomes less important all the time as processing speeds and energy sources evolve.
00:00:38 <vincenz> eivuokko: processing speeds are not the crucial factor
00:00:49 <flux__> but let's say you have a real operating system on an embedded device (say, linux) and you have many processes that use gc
00:00:50 <vincenz> eivuokko: and we'ere talking portable systems
00:00:53 * dons has fun writing: class Congruent' f g a v b u | f v -> a, g u -> b where
00:00:55 <vincenz> energy use IS the main concern
00:01:00 <flux__> you're probably wasting memory there, because all the gc spools are separate
00:01:45 <jewel> this company is trying to use Java for real-time systems, http://www.aicas.com/
00:01:53 <palomer> ugh, can't sleep
00:03:04 <Korollary> @palomer
00:03:04 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
00:03:39 <Cale> @palomer
00:03:39 <lambdabot> Scalliwags!
00:03:43 <Cale> @keal
00:03:43 <lambdabot> 99% of my book has been erased by faulty hdd's
00:03:45 <Cale> @keal
00:03:46 <lambdabot> nsa has all the profiling info you need to come up with the correct survey answers
00:03:50 <Cale> @keal
00:03:50 <lambdabot> bot seems useless
00:03:52 <Cale> @keal
00:03:53 <lambdabot> T seems to be haskell, except with a decent interface at this point
00:03:58 <Cale> heh
00:04:09 <Korollary> T sounds interesting
00:04:37 <palomer> wasn't keal that crazy guy?
00:05:01 <Cale> I'm willing to bet it's nonexistent or Keal's understanding of Haskell is incredibly limited.
00:05:33 <Korollary> I'd go for both
00:05:36 <Cale> yeah
00:05:37 <dons> me too.
00:05:58 <Cale> @keal
00:05:58 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
00:06:14 <Korollary> hmm
00:06:21 <palomer> didn't he have a break down and spazz out in #haskell?
00:06:30 <dons> its really stunning. do you think we own the copyright?
00:06:35 <dons> perhaps we could publish this stuff 
00:06:52 <dons> one of those funny, small books of life advice they sell near the bookshop counter
00:06:58 <dons> "The Little Book of Keal"
00:07:00 <vincenz> palomer: !
00:07:05 <skew> I think T is something like lisp plus a library for writing type checkers
00:07:27 <vincenz> palomer: feeling better?
00:07:28 <dons> skew, that's a good kealism. but is it a true keal?
00:07:29 <Korollary> It actually can be a real study. Perform the survey with a large group, and then perform the survey with another large group but determine their answers by how soon they picked it up. If the results correlate, an algorithm may exist.
00:07:34 <palomer> vincenz: worse
00:07:40 * vincenz pats palomer on the back
00:08:10 <dons> ?keal
00:08:10 <lambdabot> evaluating expressions is ALL haskell does?????
00:09:16 <eivuokko> Sort of hard to imagine response to that. :)
00:09:24 <Korollary> Why, yes?
00:09:43 <palomer> @keal
00:09:43 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
00:09:50 <Korollary> There you go
00:10:01 <Cale> I hate that one, because it always gets my attention :)
00:10:05 <dons> hehe
00:10:07 <palomer> @keal
00:10:07 <lambdabot> how do i search for someone saying 'Keal' in mirc
00:10:26 <palomer> whatever happened to keal?
00:10:46 <Korollary> The NSA hired him
00:11:03 <dons> or arrested him. 
00:11:23 <vincenz> or neutered him
00:11:26 <vincenz> who is keal
00:11:35 <pimaniac> The lambdabot sources imply that Keal was only here for 2 days.  The pure comedic gold to time ratio is astounding. 
00:11:52 <Korollary> He was indeed unstoppable
00:12:30 <Korollary> He was in #math, too, so the real ratio can be truly mind blowing
00:12:43 <dons> he's gone on to write monads in C++
00:12:53 <dons> (not really ;)
00:13:01 <vincenz> who is keal?
00:13:09 <dons> ?keal
00:13:10 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
00:13:11 <palomer> I'm so depressed I can't even favourably compare C++ to haskell
00:13:12 <Korollary> It can't be told
00:13:13 * palomer leaves
00:13:20 <vincenz> ...
00:13:40 <vincenz> Korollary: not perse his persona, just the history
00:15:09 <Korollary> The quick history is guy joins channel, rambles incomprehensible stuff non-stop, dons retaliates by adding @keal to lambdabot, guy disappears
00:15:19 <vincenz> heh :P
00:15:31 <vincenz> sounds like xahlee'
00:15:39 <Korollary> but he doesn't disappear
00:15:44 <vincenz> (sadly)
00:15:52 <Saulzar> So the solution is a @xahlee?
00:16:13 <vincenz> Saulzar: xahlee's reigh is more over NG's
00:16:21 <Korollary> scary thought. Doesn't the UN ban this sort of stuff?
00:16:27 <wilx> @keal
00:16:27 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
00:16:33 <vincenz> Korollary: ban wat?
00:16:56 <Korollary> a channel may not have so much firepower tied to a bot
00:17:24 <Korollary> Are there 1st, 2nd and 3rd laws of lambdabot?
00:17:25 * vincenz is off to do work
00:17:53 <vincenz> ignore me if I don't talk about technical stuff
00:19:18 <vincenz> dons: mind if I run something by you?
00:20:06 <vincenz> dons: it concerns modules
00:20:16 * vincenz can't decide between the following systems
00:20:17 <vincenz> http://rafb.net/paste/results/qvTxZF29.html
00:26:03 <skew> vincenz: why isn't Prelude just an implicit import in A and B, or do those systems completely lack import?
00:26:06 <kosmikus> vincenz: is that language supposed to be strict?
00:26:28 <vincenz> kosmikus: yes
00:26:37 <vincenz> skew: it will be an implicit export
00:26:38 <kosmikus> ok then
00:26:43 <vincenz> kosmikus: why?
00:26:54 <vincenz> it's quite close to sml
00:26:59 <vincenz> but i don't like sml's declarations
00:27:06 <vincenz> a) they're not globally recursive in a module
00:27:09 <vincenz> b) they allow shadowing
00:27:16 <kosmikus> vincenz: because otherwise I'd argue that plop should have access to bar2
00:27:26 <vincenz> kosmikus: for which system
00:27:44 <kosmikus> vincenz: 1
00:27:51 <vincenz> 1 is based on SML
00:27:53 <vincenz> aka shadowing
00:27:55 <vincenz> and it's not nice
00:28:04 <kosmikus> vincenz: no, I think I prefer 1
00:28:09 <vincenz> why
00:28:12 <vincenz> you realize that
00:28:16 <vincenz> let foo x =..
00:28:18 <vincenz> let bar x = ...
00:28:24 <vincenz> foo doesn't have access to bar
00:28:26 <skew> what shadowing are you talking about?
00:28:34 <vincenz> let foo x = ..
00:28:36 <vincenz> let foo x = ..
00:28:38 <vincenz> is perfectly valid in sml
00:28:42 <vincenz> second shadows first
00:28:49 <kosmikus> yes, why not
00:28:51 <vincenz> and even worse
00:28:54 <vincenz> let foo x = ..
00:28:55 <vincenz> module B
00:29:00 <vincenz>    ...can use foo unqualified
00:29:03 <skew> I mean in your proposed systems - that kind of shadowing seems orthogonal to the module system
00:29:06 <vincenz>    let foo x =..
00:29:14 <vincenz>    from now unqualified foo refers to B.foo, not main.foo
00:29:24 <vincenz> skew: no it does not
00:29:32 <vincenz> skew: it's either global corecursiveness or shadowing
00:29:38 <vincenz> one implies topdown scoping
00:29:47 <vincenz> let f1 = ... in let f2 = .. in ...
00:29:56 <vincenz> (the shadowing one)
00:30:04 <skew> where by global you mean module-wide?
00:30:06 <vincenz> the other uses haskell approach
00:30:11 * vincenz nods
00:30:18 <skew> what's wrong with that?
00:30:26 <vincenz> skew: which one?
00:30:53 <skew> in the example you just typed, making foo inside B refer to B.foo before the definition of B.foo as well as after
00:30:53 <vincenz> solution 3
00:30:54 <vincenz> er
00:31:00 <vincenz> solution 5:
00:31:03 <vincenz> don't allow nested modules
00:31:13 <flux__> let x = 4 in let x = x + 5 in .. is great in ocaml ;)
00:31:26 <vincenz> flux__: that's diferent
00:31:29 <skew> that's what I thought 1 was supposed to be anyway
00:31:30 <vincenz> for variable definitions I have shadowing
00:31:50 <vincenz> let foo x = 
00:31:52 <vincenz>     y = 1
00:31:53 <vincenz>     ...
00:31:54 <flux__> for global symbols it can be surprising, which I guess isn't nice
00:31:55 <vincenz>    y = 2...
00:31:58 <skew> stuff in the inner module shadows unqualified reference to stuff in the outer modules
00:32:04 <vincenz> but shadowing for toplevel decls is ugly
00:32:05 <vincenz> imho
00:32:21 <skew> what does "ugly lookup" mean?
00:32:23 <vincenz> skew: it's not that simple
00:32:38 <skew> I can only guess implementation of the enviroment stuff, but that's the least of your worries writing a compiler
00:32:54 <vincenz> skew: if I do that and still use global corecursive/module... I can get module corecursiveness which afaik is a Hard Problem (TM)
00:33:23 <vincenz> skew: it's important for type inference
00:33:25 <skew> mutual recursion between different submodules of a module?
00:33:39 <vincenz> skew: or possibly mutual recursion between module and it's submodule
00:33:44 <vincenz> skew: if I use what you said
00:33:55 <vincenz> which is bad (TM)
00:33:56 <skew> you can just punt on the problem
00:34:12 <vincenz> personally I like 4
00:34:24 <vincenz> except it can also lead to module corecursion
00:34:25 <skew> it's not like your only choices are making declaration visitiblity follow text order and completely solving mutual recursion
00:34:34 <vincenz> but... I think it's cleaner (more encapsulated
00:34:51 <vincenz> aak modules can't access their surrounding modules
00:34:56 <vincenz> s/aak/aka
00:35:06 <vincenz> unless they import
00:35:16 <vincenz> and if they don't import
00:35:22 <vincenz> it's just a bottom up typing issue
00:35:25 <skew> I don't get that - why allow nested modules at all if not to implicitly import stuff from the surrounding module?
00:35:25 <vincenz> start at innermost module
00:35:27 <vincenz> and move outwards
00:35:36 <vincenz> skew: encapsulation?
00:35:57 <vincenz> module SomeDataType
00:36:02 <vincenz>   module HelperForDataType
00:36:24 <skew> like the package stuff in many languages?
00:36:31 <vincenz> i guess yeah
00:36:44 <skew> I guess you could go for that too
00:36:56 <vincenz> it's a tough cookie to crack
00:37:02 <vincenz> or just go with haskell system
00:37:06 <vincenz> and oonly allow toplevel decls
00:37:33 <skew> why not do 1 but disallow shadowing?
00:37:45 * vincenz checks
00:37:50 <vincenz> oh right
00:37:51 <vincenz> that borks
00:37:57 <skew> I still think shadoing is orthogonal to other stuff
00:37:59 <vincenz> skew: I want global corecursion/module
00:38:03 <vincenz> skew:  no it's not
00:38:07 <vincenz> foo x = bar x
00:38:08 <vincenz> module A
00:38:13 <vincenz>    plop x = foo x
00:38:16 <vincenz> bar x = ...
00:38:18 <skew> if you have somthing like 4 with an "open" directive that puts stuff straight into your namespace, then how iw
00:38:21 <skew> module A
00:38:24 <skew>    module B
00:38:26 <skew>     open A
00:38:32 <vincenz> which imho is illegal
00:38:32 <skew> any different from something like 1 with
00:38:33 <skew> module A
00:38:34 <skew>   module B
00:38:52 <vincenz> skew: there is one big difference
00:39:03 <vincenz> first one does not allow recreating funcs with names equal to those in A
00:39:17 <vincenz> second one does not have access to A
00:39:22 <skew> you seem to be assuming you want a repl-type thing
00:39:29 <vincenz> ?
00:39:30 <skew> I'm thinking more batch processing
00:39:46 <RvGaTe> morning...
00:39:52 <vincenz> skew: I'm going towards repl atm tho
00:39:57 <vincenz> skew: it's for a simulator
00:40:00 <vincenz> which is gui-based
00:40:28 * vincenz ponders
00:40:29 <vincenz> I know
00:40:35 <vincenz> I think I have it figured out
00:40:40 <skew> not repl - one-pass compiler
00:41:00 <vincenz> alright this is the idea
00:41:08 <vincenz> only qualified access to inner modules
00:41:11 <vincenz> and import
00:41:17 <vincenz> then do a graph analysis of module dependency
00:41:21 <vincenz> and disallow recursiveness
00:41:22 <skew> my first example assumed a module system like 4, whoere B wouldn't usually see A, but 
00:41:39 <vincenz> skew: eitehr way.. it's illegal to import A from B
00:41:44 <vincenz> skew: that's impossible to type
00:41:44 <skew> "open" puts them into the namespace, the second example assumed a system like 1, where B by default has stuff from A in scope
00:41:57 <skew> no more impossible that mutual recursion in general
00:42:13 <vincenz> skew: no it's a known fact that recursive module are a problem
00:42:20 <vincenz> why do you think haskell disallows them?
00:42:32 <skew> Haskell implementations, rather
00:42:35 <vincenz> anyways I'm going for 4
00:42:45 <vincenz> skew: right and imo, haskell is pretty topnotch in the compiler world
00:42:47 <vincenz> ocaml is much simpler
00:42:51 <skew> it's recursive modules plus separate compilation that is a problem 
00:43:03 <vincenz> hmm
00:43:10 <skew> when it's all in one file you just take a fixpoint
00:43:16 <vincenz> true I guess
00:43:24 <vincenz> type monomorphically and then generalize at end
00:43:35 * vincenz ponders
00:43:46 <vincenz> I'll do non recursive modules at first
00:43:49 <skew> but I'll say again that you don't need to support mutual recursion of modules to make this work
00:43:52 <vincenz> I think that a graph analysis should be pretty simple
00:44:04 <vincenz> skew: yeah I go with 4 and reject recursivity
00:44:17 <vincenz> and possibly add open to import unqualified
00:44:36 <vincenz> alright
00:44:38 <vincenz> thx for the input
00:45:27 <vincenz> :)
00:45:28 <skew> you can do something like 1 without the meaning of foo changing, if you gather all the names that are going to be defined in B before deciding whether references to foo in B mean the foo from A or the foo from B
00:45:37 <vincenz> skew: I prefer fully qualified
00:45:48 <skew> that kind of conflicts with being able to give feedback line by line
00:46:09 <vincenz> skew: the problem with your system is that it's rather hard to predict for a user of a big module
00:46:31 <vincenz> skew: with qualified names and disallowing shadowing when open, it's much safer imo
00:46:56 <skew> yeah, I'm not sure it's a good idea for stuff involving nested scopes like this
00:47:22 * vincenz thinks he needs a two stage depanal for this tho
00:47:27 <vincenz> first a module depanal then a function depanal
00:47:31 <vincenz> I don't think I can roll it into one
00:47:39 <skew> but with open, disallowing the user from shading things is pretty restrictive
00:47:44 <vincenz> skew: not so
00:47:46 <vincenz> skew: look at haskell
00:47:46 <skew> that would really bug me working in an interpreter
00:48:20 <vincenz> skew: mind joining #oasis?
00:48:31 <vincenz> (don't feel like spamming #haskell)
00:48:42 <skew> we could use a better module system anyway
00:48:55 <vincenz> I still believe shadowing is dangerous
00:49:09 <vincenz> if anything, haskell should be typeclassed more
00:49:34 <skew> typeclasses being global can be annoying sometimes
00:49:42 <vincenz> yeah
00:49:50 <vincenz> I've been thinking if it' dbe possible to have module-bound typeclasses
00:50:00 <skew> there's a paper along those ideas
00:50:06 <vincenz> import qualified ModuleWithTypeClassInIt as Q
00:50:10 <vincenz> Q.typeclassmthod
00:50:37 <amiddelk> scoped instances
00:50:37 <vincenz> skew: another annoyance is the need to import files even if you don't use em, just to get the tyclass def
00:50:40 <skew> instances are quite a lot like (ML) functors, with automatically assembled to make things work
00:51:09 <vincenz> skew: but... join oasis?
00:52:30 <skew> ok, this is getting even more into things relevant to Haskell
00:52:42 <vincenz> well yeah
00:52:48 <vincenz> but I was hoping to discuss an algo
01:44:51 <Stinger_> is there a way to force a return type in an expression, say in 'fromRational(val)'
01:45:55 <kosmikus> expr :: type
01:46:19 <eivuokko> You can give an expression a signature.  foo :: Foo, the signature is very low-level, so you often need to add parentheses (foo :: Foo)
01:46:38 <eivuokko> signature precedence is*
01:46:42 <kzm> any ghc-6.5 .deb out there?
01:47:04 <Stinger_> oh ok, I thought those type "::" declarations had to be seperate 
01:47:35 <eivuokko> :: is used for both declarations and signatures.
01:48:13 <Stinger_> cool thanks
02:00:34 <Itkovian> BCoppens: hi
02:00:47 <shapr> @yow !
02:00:47 <lambdabot> ... I want a COLOR T.V. and a VIBRATING BED!!!
02:00:48 <BCoppens> Itkovian: hey
02:00:59 <Itkovian> hi shapr 
02:01:06 <Itkovian> how's the job thingie coming along?
02:01:23 <Itkovian> @seen bourbaki
02:01:24 <lambdabot> I saw bourbaki leaving #haskell-blah 16 days, 16 hours, 24 minutes and 22 seconds ago, and .
02:01:29 <Itkovian> hmm ...
02:01:40 <Itkovian> sounds dead
02:01:42 <shapr> No results so far, but I ended up focussing on Flash projects.
02:01:49 <Itkovian> flashy
02:01:51 <shapr> I think I need to switch to PHP & MySQL.
02:01:52 <vincenz> dumteedum
02:02:14 <Itkovian> what we need is a flickr for video
02:02:17 <shapr> PHP doesn't pay as well, but has a lot of jobs available.
02:02:26 <shapr> Isn't that google video?
02:02:30 <Itkovian> same principle, unlike youtube
02:02:43 <Itkovian> I thought all video stuff currently allows public view of your stuff
02:02:51 <shapr> Oh, I don't know.
02:03:19 <shapr> I got my box back from my ex-ISP! w00! Only took four months.
02:03:22 <Itkovian> anyway, did you explore the drupal rewrite in haskell any further?
02:03:38 <shapr> Not yet.
02:03:54 <Itkovian> btw, I'm currently enjoying pythonian code
02:03:56 <shapr> I really could rewrite drupal in a very much smaller amount of source.
02:04:10 <Itkovian> as extensible?
02:04:17 <shapr> It has at least six variations on the theme of the state monad that I spotted immediately.
02:04:25 <Itkovian> groovy
02:04:50 <shapr> The zillion callbacks could all be replaced with a few monads, possibly just one monad.
02:06:21 <ADEpt> davidhouse: ping
02:08:10 <ADEpt> shapr: could you expand on "replace callbacks with monad"?
02:11:33 <shapr> Drupal does a lot of defining of a command/name in a particular place/page and then later pointing that name to a function. It also does hooks for those so that other code can be called before (possibly after as well - not sure).
02:11:59 <shapr> It's done rather manually compared to the monadic approach.
02:12:16 <shapr> From one viewpoint, a monad is just a hook.
02:14:43 <shapr> ADEpt: A monad is sort of a parameterized function similarly to a parameterized datatype. That idea makes callbacks pretty simple, imho.
02:15:00 <shapr> Oh, now that I think of it, drupal's "callbacks" are really higher order functions.
02:15:08 <shapr> Maybe it's even simpler than I thought.
02:16:17 <ADEpt> shapr: maybe i'm just being dense today. how this idea makes callbacks simple? :)
02:16:56 <shapr> Because the monadic interface is a stricter form of continuation passing style.
02:17:24 <shapr> You just pass in the function to be called.
02:17:32 * shapr is suddenly not so sure of that...
02:19:01 <shapr> ADEpt: Does it make any sense to you?
02:20:56 <ADEpt> shapr: frankly, no, it is not
02:21:18 <ADEpt> shapr: i am thinking about lambdabot plugins (with callbacks) and dont see how to apply monads there
02:25:33 <skew> shapr: makes no sense to me - maybe you are thinking of building up a monadic action and passing that as a callback?
02:25:45 <Saulzar> Gtk2hs callbacks are pretty simple, if that is related somehow...
02:40:08 * wilx np: Tommy February6 - Dancin' Baby [04:18m/192Kbps/44KHz]
02:40:17 <wilx> Ooops. Wrong channel.
02:43:44 <davidhouse> @hoogle mapEither
02:43:44 <lambdabot> No matches found
02:44:12 <skew> @hoogle either
02:44:12 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
02:44:12 <lambdabot> Prelude.Either :: data Either a b
02:44:23 <davidhouse> Data.Either is a decidedly underfull module.
02:44:58 <davidhouse> all it defines is the Eithe datatype and the either function.
02:45:03 <skew> what do you want mapEither do to?
02:45:46 <davidhouse> splitEithers :: [Either a b] -> ([a], [b])
02:45:55 <davidhouse> and then mapEither = snd . splitEithers
02:46:15 <Jackson> Afternoon
02:46:16 <davidhouse> err, hang on
02:46:18 <davidhouse> no, not that.
02:46:50 <davidhouse> mapEither :: (a -> Either b c) -> [a] -> [c]. Like mapMaybe.
02:47:08 <norpan> where will the b's go?
02:47:15 <davidhouse> throw them away.
02:47:25 <norpan> so there would be at least two variants of it?
02:47:48 <davidhouse> Either is nearly always used with Left = errors, Right = sucesses, so keep the Rights.
02:47:57 <norpan> nearly always?
02:48:03 <davidhouse> yeah.
02:48:10 <davidhouse> i mean, you can do other things like dynamic typing with it
02:48:17 <davidhouse> > [ Left 5, Left 6, Right 'a' ]
02:48:18 <lambdabot>  [Left 5,Left 6,Right 'a']
02:48:31 <davidhouse> but when used as a monad, it's left for errors, right for successes.
02:49:03 <norpan> but when you use it as a monad you just use fmap?
02:49:12 <norpan> or mapM
02:49:25 <davidhouse> @type fmap
02:49:26 <lambdabot> forall (f :: * -> *) b a.
02:49:26 <lambdabot>    (Functor f) =>
02:49:26 <lambdabot>    (a -> b) -> f a -> f b
02:49:48 <davidhouse> in other words, fmap :: (b -> c) -> Either a b -> Either a c. not what i want.
02:49:51 <davidhouse> @type liftM
02:49:52 <lambdabot> forall r (m :: * -> *) a1.
02:49:52 <lambdabot>    (Monad m) =>
02:49:52 <lambdabot>    (a1 -> r) -> m a1 -> m r
02:49:55 <davidhouse> err
02:49:58 <davidhouse> @type mapM
02:49:59 <lambdabot> forall b (m :: * -> *) a.
02:49:59 <lambdabot>    (Monad m) =>
02:49:59 <lambdabot>    (a -> m b) -> [a] -> m [b]
02:50:22 <davidhouse> so here's it's mapM :: (a -> Either b c) -> [a] -> Either b [c]
02:50:29 <davidhouse> again, not what i want.
02:50:46 <norpan> but you have already defined the function so i don't see the problem actually
02:51:03 <davidhouse> i have?
02:51:27 <norpan> yes, you did above
02:51:29 <norpan> so use it
02:51:31 <norpan> and be happy :)
02:51:34 <davidhouse> incorrectly.
02:51:40 <davidhouse> and my point was i want this in Data.Either ;)
02:52:08 <norpan> you can't have every concievable function in the library it would be too much
02:52:36 <davidhouse> well, Data.Maybe exports a mapMaybe, why shouldn't Data.Either export a mapEither?
02:52:47 <norpan> because mapEither is not symmetrical
02:53:09 <norpan> you could have mapLeft and mapRight i suppose
02:53:09 <davidhouse> fine, define two versions of it. mapEitherl and mapEitherr
02:53:52 <davidhouse> > let eitherToMayebe = either (const Nothing) Just; mapEither xs = mapMaybe (eitherToMaybe . f) in mapEither (\x -> if x > 5 then Left x else Right (show x)) [1..10]
02:53:53 <lambdabot>  Not in scope: `f'
02:54:01 <davidhouse> > let eitherToMayebe = either (const Nothing) Just; mapEither f = mapMaybe (eitherToMaybe . f) in mapEither (\x -> if x > 5 then Left x else Right (show x)) [1..10]
02:54:02 <lambdabot>  Not in scope: `eitherToMaybe'
02:54:11 <davidhouse> > let eitherToMaybe = either (const Nothing) Just; mapEither f = mapMaybe (eitherToMaybe . f) in mapEither (\x -> if x > 5 then Left x else Right (show x)) [1..10]
02:54:12 <lambdabot>  ["1","2","3","4","5"]
02:54:37 <davidhouse> it would be more normal to do Left "error", but hey,
02:55:26 <Saulzar> @type \f g -> left f >>> right g
02:55:27 <lambdabot> forall b (a :: * -> * -> *) d b1 c.
02:55:27 <lambdabot>           (ArrowChoice a) =>
02:55:27 <lambdabot>           a b d -> a b1 c -> a (Either b b1) (Either d c)
02:55:55 <davidhouse> @type (|||)
02:55:56 <lambdabot> forall (a :: * -> * -> *) d c b.
02:55:56 <lambdabot>    (ArrowChoice a) =>
02:55:56 <lambdabot>    a b d -> a c d -> a (Either b c) d
02:56:07 <Saulzar> Just as people use arrows for tuple libs I suppose you could use it for an Either lib 
02:56:11 <davidhouse> Saulzar: that's a build-in, i'm sure.
02:56:28 <davidhouse> @type (+++(
02:56:29 <lambdabot> parse error (possibly incorrect indentation)
02:56:31 <davidhouse> @type (+++)
02:56:32 <Saulzar> Yep
02:56:32 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
02:56:32 <lambdabot>    (ArrowChoice a) =>
02:56:32 <lambdabot>    a b c -> a b' c' -> a (Either b b') (Either c c')
02:56:58 <davidhouse> how are you suggesting i use this?
02:57:15 <Saulzar> Don't know, haven't read what you're looking for :)
02:57:23 <davidhouse> ArrowChoice is all about using Either as indirection to enable runtime choice structures, like if.
02:57:43 <davidhouse> mine is more an collect-successes map like mapMaybe.
02:58:47 <Saulzar> msum ?
02:58:53 <norpan> there should be isRight, isLeft, catRights, catLefts, mapRight, mapLeft
02:59:39 <davidhouse> norpan, yeah.
02:59:59 <davidhouse> Saulzar: msum is different still.
03:00:02 <norpan> otoh they are not hard to define yourself
03:00:12 <davidhouse> > mapMaybe [ Just 4, Nothing, Just 5, Just 6, Nothing ]
03:00:13 <lambdabot>  Couldn't match `a -> Maybe b' against `[a1]'
03:00:14 <davidhouse> err
03:00:37 <Itkovian> #darcs is quiet, so ... how can I push a patch that conflicts? darcs advises to use --mark-conflicts, but I don't find anything about it when using --help
03:00:42 <dons> ?type mapMaybe
03:00:42 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
03:00:49 <Saulzar> Hmm
03:00:56 <Saulzar> Yes you're right
03:01:12 <davidhouse> > mapMaybe (\k -> lookup k [(1, "hello"), (2, "world")]) [1..3]
03:01:13 <lambdabot>  ["hello","world"]
03:01:18 <davidhouse> it collects the successes.
03:01:26 <davidhouse> > msum $ map (\k -> lookup k [(1, "hello"), (2, "world")]) [1..3]
03:01:27 <lambdabot>  Just "hello"
03:01:33 <davidhouse> that finds the first success.
03:01:38 <dons> > fmap (\k -> lookup k [(1, "hello"), (2, "world")]) [1..3]
03:01:39 <lambdabot>  [Just "hello",Just "world",Nothing]
03:01:53 <davidhouse> and that's pointless because fmap = map for lists ;)
03:01:59 <dons> :)
03:02:21 <dons> > map (\k -> lookup k [(1, "hello"), (2, "world")]) [1..3]
03:02:22 <lambdabot>  [Just "hello",Just "world",Nothing]
03:03:03 <dons> davidhouse: you were sending me a lambdabot plugin?
03:03:26 <davidhouse> dons, just finishing it.
03:04:09 <davidhouse> @localtime dons
03:04:10 <lambdabot> Local time for dons is Thu Jun  1 19:56:39 2006
03:04:38 <davidhouse> dons, i'll try to have it finished before you disappear for the evening.
03:04:51 <dons> :)
03:05:09 <dons> i usually check my email before bed, but i probably won't apply any more patches to lambdabot for today
03:05:32 <dons> unless its a really good patch, that is
03:05:41 <davidhouse> hehe, sure.
03:05:41 <dons> so tempt me... :)
03:06:46 <boegel> dons: you're from Australie, right?
03:06:48 <Saulzar> Just something like this maybe, mapEithers f xs = [y | Right y <- f xs]
03:06:52 <dons> boegel: yep.
03:07:00 <Saulzar> Sorry - map f xs
03:07:02 <boegel> dons -> pm
03:07:08 <dons> or, the land of the future, as i call it.
03:07:10 <dons> boegel: sure.
03:07:15 <Stinger_> hahaha
03:07:26 <norpan> australia is nice
03:07:29 <norpan> i've been there once
03:07:37 <Stinger_> is that just cause you saw madmax
03:07:41 <Saulzar> Or the land of the not--quite-so-distant-past as I call it :)
03:07:42 <davidhouse> gah, list comps. they're so useful.
03:07:43 <norpan> i got to celebrate new year's early
03:07:48 <dons> Saulzar: hehe
03:07:54 <dons> @localtime Saulzar
03:07:55 <lambdabot> Local time for Saulzar is Thu Jun  1 22:04:21
03:07:59 <dons> he's really future man
03:08:10 <ohub> @localtime ohub
03:08:12 <davidhouse> woah, Saulzar... where do you live?
03:08:14 <lambdabot> Local time for ohub is Thu Jun  1 13:07:50 2006
03:08:18 <norpan> hmmm, gmt+12
03:08:23 <norpan> that's steep
03:08:30 <resiak> > [y | Just y <-[Nothing, Just 3, Nothing]]
03:08:31 <lambdabot>  [3]
03:08:34 <resiak> Oh, that's really neat.
03:08:39 <ohub> oh, it uses CTCP TIME. Clever.
03:09:09 <Saulzar> New Zealand, just over the ditch and a small way south east of Aus
03:09:23 <norpan> > let mapRight f xs = [ f x | Right x <- xs ] in mapRight (+1) [Left 1, Right 2]
03:09:24 <lambdabot>  [3]
03:09:34 <norpan> it indeed works
03:10:13 <resiak> That's really cool.
03:10:38 <Saulzar> Probably easiest to just have gatherRights then they can map it as they like.. gatherRight . map f  vs. map f . gatherRight
03:10:51 <davidhouse> yeah.
03:11:03 <davidhouse> gatherRight :: [Either a b] -> [b]
03:11:12 <norpan> or just "rights"
03:11:29 <davidhouse> well, we need splitEithers :: [Either a b] -> ([a], [b]), then gatherRights = snd . splitEithers
03:11:54 <davidhouse> hmm... i wonder.
03:13:08 <davidhouse> > let splitEithers xs = unzip [ (l, r) | Left l <- xs, Right r <- xs ] in splitEithers [ Just 4, Just 5, Left 'a' ]
03:13:09 <lambdabot>  Couldn't match `Either a b' against `Maybe a1'
03:13:22 <davidhouse> > let splitEithers xs = unzip [ (l, r) | Left l <- xs, Right r <- xs ] in splitEithers [ Right 4, Right 5, Left 'a' ]
03:13:23 <lambdabot>  ("aa",[4,5])
03:13:28 <davidhouse> maybe not.
03:13:47 <davidhouse> we'll stick with the accumulating fold definition we came up with before then.
03:15:06 <davidhouse> > let splitEithers = foldr (either (first . (:)) (second . (:))) ([], []) in splitEithers [ Right 4, Right 5, Left 'a' ]
03:15:08 <lambdabot>  ("a",[4,5])
03:15:17 <davidhouse> pretty code :)
03:15:42 <dons> ?pl foldr (either (first . (:)) (second . (:))) ([], [])
03:15:42 <lambdabot> foldr (either (first . (:)) (second . (:))) ([], [])
03:15:51 <dons> ah, yes. of course
03:17:40 <davidhouse> dons, lambdabot provides a trim function that trims leading and trailing whitespace, right?
03:19:56 <davidhouse> ah, it's called dropSpace
03:21:09 <Jackson> David: Do you remember that Polynom stuff I was asking about before? Well I have that working and now need to define a evaluate function to create a sequence using a created polynom
03:21:15 <dons> though i think dropSpace only cleans from the end
03:21:21 <dons> davidhouse: feel free to implement trim
03:21:50 <davidhouse> dropSpace = let f = reverse . dropWhile isSpace in f . f
03:21:57 <davidhouse> it does both
03:22:06 <dons> ah, yes. that's it
03:22:13 <dons> maybe i was thinking of 'clean' ?
03:22:19 <dons> there's one that scrubs only the end.
03:22:30 <johnnowak> has anyone managed to get ghc working on os x x86?
03:22:41 * davidhouse pops out for a bit
03:38:44 * dcoutts yawns
03:39:08 <dcoutts> dons, good idea, I like it.
03:44:22 <dons> the nofib? yeah.
03:44:34 <dons> shouldn't be too hard, i think.
03:47:39 <dcoutts> dons, so what should I work on today? improving/automating benchmarks?
03:48:20 <dons> yeah, did you want to commit something on the repeated test run code? so we can produce better graphs?
03:49:37 <dons> or put in some notes in the paper about the rules stuff? do some background reading on the foldr/build deforestation?
03:49:59 <dons> oh, and i didn't get around to doing space profiling. doh.
03:50:04 * dons adds that to the todo 
03:50:56 <ProfTeggy> johnnowak, any particular problem?  What about the Darwin port?
03:51:43 <johnnowak> are there binaries for x86 darwin?
03:52:05 <ProfTeggy> port install ghc :-)
03:52:36 <johnnowak> bah, not ports on this system. just did a hd wipe. :)
03:52:56 <ProfTeggy> heh
03:53:04 <johnnowak> er
03:53:04 <johnnowak> platform darwin i386 {
03:53:04 <johnnowak> ui_msg "GHC is not supported on OS X i386 yet"
03:53:05 <johnnowak> exit 1
03:53:07 <johnnowak> }
03:53:23 <ProfTeggy> Ah, i386, you're on a MacBook?
03:53:46 <johnnowak> that's why i said x86 darwin. and os x x86.
03:53:59 <ProfTeggy> Yes.  More fool me.
03:54:02 <ProfTeggy> Sorry.
03:54:09 <johnnowak> my hopes! dashed!
03:54:14 <ProfTeggy> Uh oh
03:55:22 <eivuokko> johnnowak, Have you read http://cvs.haskell.org/trac/ghc/wiki/X86OSXGhc ?
03:55:48 <johnnowak> no i haven't -- thanks, i will give it a shot
04:14:25 <dcoutts_> dons, did you see Buglat's sums email today?
04:14:40 <dcoutts_> dons, I want to try a ByteString version of that...
04:19:47 <ADEpt> davidhouse: ping
04:20:08 <vincenz> how do you do haddock stuff?
04:20:15 <vincenz> -- ^
04:20:16 <vincenz> for params?
04:21:12 <maus> hello all
04:21:58 <maus> is there a binding to id3tag or another library for manipulating id3 tags?
04:21:59 <psnl> morning
04:24:03 <maus> i'm going to change encoding of my mp3s. I didn't find any tools for that. I'm thinking of writing small tool for it in Haskell
04:24:23 <Lokadin> say what's the best way to get html pages from the internet?
04:27:24 <apfelmus> maus: i'm not aware of any such thing for haskell, but you might change that. why not interfacing the id3tag library with the haskell ffi?
04:28:16 <maus> apfelmus: i've decided to ask at first ))
04:29:14 <Lokadin> anyone know a way?
04:29:23 <Lokadin> or should i just use curl?
04:30:12 <apfelmus> Lokadin: for haskell try http://www.haskell.org/http/, for your own hands any browser will do
04:30:30 <Lokadin> oh okay thanks :)
04:30:46 <Lokadin> .ui i needed haskell
04:35:17 <ADEpt> vincenz: haddock has quite a nice doc
04:35:45 <vincenz> @where haddock
04:35:45 <lambdabot> http://www.haskell.org/haddock/
04:35:52 <vincenz> ADEpt: running on sleep depriv (worked all last night)
04:36:12 <vincenz> ADEpt: so I hate checking for trivialities that others might knwo
04:36:58 <vincenz> -- ^
04:39:41 <ADEpt> yep, it is -- ^
04:39:47 <ADEpt> btw
04:40:16 <ADEpt> darcs question: when i do "darcs get ../local/repo", nothing is hardlinked to "../local/repo" to save space, right?
04:42:04 <shapr> No, but it can be.
04:42:16 <shapr> darcs optimize --help
04:44:21 <shapr> Will 6.4.2 be available in debian/unstable soon?
04:46:16 <Lokadin> is it stable?
04:46:33 <Lokadin> then i don't know
04:46:37 <Lokadin> it's on gentoo .ui
04:46:58 <yaarg> it's the current stable release
04:48:05 <Lokadin> cool .ui
04:48:50 <ADEpt> shapr: --relink ?
04:49:39 <Foobar> How can I refer in "class Foo a => SubFoo a where foobar = ..." on the place of the dots to a method called foobar which is defined in class Foo?
04:50:13 <ADEpt> shapr: cool! thanks a lot!
04:50:30 <alar> greetings
04:50:40 <yaarg> and it looks like there's some outstanding bugs for 6.4.1 before 6.4.2 gets into unstable
04:50:44 <alar> shapr: can you tell me what is "eliminator"
04:50:45 <alar> ?
04:50:50 <alar> in Epigram papers
04:51:15 <Foobar> That is I want to override a function using the function from its superclass.
04:53:03 <dcoutts_> dons, well I can get as fast as Buglat's version with a simpler looking program
04:53:10 <vincenz> Foobar: can't do
04:53:21 <vincenz> Foobar: methods must be unique
04:53:22 <dcoutts_> dons, but it's still way off the C version
04:53:40 <davidhouse> ADEpt: pong
04:54:11 <vincenz> hiya davidhouse 
04:54:21 <davidhouse> Foobar: is foobar a method in both classes?
04:54:29 <Foobar> davidhouse: It should be.
04:54:34 <davidhouse> nope, can't have that.
04:54:45 <davidhouse> they're just functions.
04:55:08 <davidhouse> e.g. class Show s where show :: s -> String. what that means is that show :: Show s => s -> String
04:55:37 <davidhouse> vincenz: hey
04:55:43 <Foobar> How should I create an undirected graph interface on top of Data.Graph.Inductive then?
04:56:04 <davidhouse> @localtime dons
04:56:06 <lambdabot> Local time for dons is Thu Jun  1 21:48:33 2006
04:56:21 <ADEpt> davidhouse: you pinged me first a while ago :) what's up?
04:57:22 <davidhouse> ADEpt: i thought your lambdabot patch wasn't typechecking, but then i realised it was. :) hence the "actually no, never mind" a few lines down from "ADEpt: ping". :)
04:58:32 <Foobar> It seems to me that the only solution is to build undirected graph in a new class hierarchy, totally loosing the relation ship with a directed graph.
04:58:59 <davidhouse> Foobar: you might try emailing the haskell-cafe mailing list. they're good at these types of questions.
05:00:41 <ADEpt> davidhouse: ah :)
05:02:52 <davidhouse> ADEpt: what exactly is XMPP?
05:04:08 <ADEpt> davidhouse: jabber
05:04:15 <vincenz> davidhouse: my thing is nearly finised
05:04:16 <davidhouse> ah, right.
05:04:18 <vincenz> davidhouse: just the last typing rules
05:04:21 <davidhouse> vincenz: which thing?
05:04:22 <vincenz> and then the interpreter
05:04:22 <ADEpt> davidhouse: xmpp - name from RFC, jabber - from real life :)
05:04:27 <vincenz> which should be rather easy
05:04:29 <vincenz> davidhouse: my compiler
05:04:37 <vincenz> davidhouse: starting with 0 knowledge on type inference
05:04:42 <vincenz> davidhouse: 50 hours to get a working compiler
05:04:47 <davidhouse> vincenz: hehe, congrats! :)
05:04:51 <davidhouse> what does it compile?
05:04:52 <vincenz> davidhouse: and the nice thing is
05:04:56 <vincenz> it's rather language indepedent
05:05:03 <vincenz> cause I use lookup tables in Compiler.Language
05:05:06 <davidhouse> ADEpt: should be fun
05:05:07 <vincenz> so we could possibly reuse for ICFPC
05:05:23 <vincenz> \o/
05:05:46 <vincenz> @karma+ palomer -- For the entire tutorial on type inference
05:05:46 <lambdabot> palomer's karma raised to 5.
05:06:00 <vincenz> @karma+ -- For the many q&a sessions to refine my knowledge on type inference
05:06:00 <lambdabot> --'s karma raised to 1.
05:06:05 <vincenz> @karma+ palomer -- For the many q&a sessions to refine my knowledge on type inference
05:06:05 <lambdabot> palomer's karma raised to 6.
05:06:23 <davidhouse> @karma+ -- everyone loves comments!
05:06:24 <lambdabot> --'s karma raised to 2.
05:06:35 <davidhouse> vincenz: so what kind of languages does it compile?
05:06:40 <vincenz> davidhouse: it's kinda like ml
05:07:12 <vincenz> semi functional, semi imperative syntax, with references, tuples, partially applied functions and type inference
05:08:03 <davidhouse> cool! :)
05:08:12 <davidhouse> be sure to write it up somewhere
05:08:32 <vincenz> :)
05:08:35 <vincenz> oh yeah
05:08:39 <vincenz> and parametric polymorphism
05:08:41 <vincenz> and nested modules
05:08:54 <vincenz> the only thin I don't have is vertical layout
05:09:02 <vincenz> cause it's hard to code (GHC lexer is unreadable)
05:09:23 <ADEpt> davidhouse: exactly, that's why i'm doing it
05:09:31 <davidhouse> i think we need to rewrite the haskell dogma.
05:09:40 <davidhouse> "It'll work once it typechecks, unless you're using Parsec"
05:10:05 <alar> what is manual on type inference? Does it tell exactly "how should GHC behave"?
05:10:31 <davidhouse> vincenz: i'd like to see your code
05:10:40 <davidhouse> vincenz: once it's fully working
05:10:45 <vincenz> nearly there
05:10:49 <vincenz> just the finishing touches on type inference
05:10:52 <vincenz> and then interpretation
05:10:58 <vincenz> but skew assures me that last isn't too difficult
05:21:00 <Lokadin> is there any way of making a "better" terminal? one with arrow keys, and back and forth motion, i don't mean to run bash or anything, just the normal haskell console, or if there is a way around it. 
05:21:48 <davidhouse> Lokadin: what do you mean, "the normal haskell console"?
05:21:57 <davidhouse> GHCi has history.
05:21:58 <Lokadin> er like getLine and such
05:22:05 <davidhouse> oh, right.
05:22:09 <davidhouse> you want to write one.
05:22:18 <Lokadin> well, preferably no
05:22:23 <davidhouse> hold on, i think this came up on the mailing lists.
05:22:28 <Lokadin> i just want to have line editing
05:22:33 <Lokadin> oh okay
05:22:45 <davidhouse> try http://www.eecs.tufts.edu/~rdocki01/shellac.html
05:22:53 <Lokadin> kk one sec .ui
05:23:13 <Lokadin> :)
05:23:35 <Foobar> LoganH: M-x shell in Emacs works too.
05:23:57 <Lokadin> alright!! :) that's exactly what i've been searching for!!! :) hurrah!
05:24:05 <Lokadin> .ui!!!
05:24:10 <Lokadin> or seems like it anyways
05:24:32 <yaarg> are you looking for a gnu readline wrapper program possibly?
05:24:49 <yaarg> oh nm
05:27:31 <Foobar> Lokadin: What are you so happy about?
05:30:35 <Lokadin> Foobar: shellac
05:31:08 <Lokadin> Foobar: it might also be sleep deprivation, it's 08:30 here
05:31:13 <Lokadin> @localtime lokadin
05:32:03 <alar> @localtime
05:33:18 <psnl> Lokadin: in the morning? thats nice and early
05:34:14 <apfelmus> @localtime Lokadin
05:34:22 <lambdabot> Local time for Lokadin is Thu Jun  1 08:33:19 2006
05:35:06 <yaarg> @localtime yaarg
05:35:36 <lambdabot> Local time for yaarg is Thu Jun  1 13:35:01 2006
05:36:07 <yaarg> 8-)
05:37:35 <ohub> @localtime ohub
05:37:58 <psnl> @localtime psnl 
05:38:10 <psnl> I assume it has to be set
05:38:22 <psnl> @localtime+ GMT
05:38:22 <ohub> nope, it uses CTCP TIME
05:38:23 <lambdabot> Local time for ohub is Thu Jun  1 15:37:54 2006
05:38:27 <lambdabot> Local time for psnl is Thu Jun  1 13:37:57 2006
05:38:31 <psnl> ah
05:38:50 <ohub> Do I live in the future or are you living in the past? :)
05:38:51 <shapr> eshell roxx
05:39:29 <roconnor> @roll 2d6
05:39:30 <lambdabot> Unknown command, try @list
05:39:44 <apfelmus> @dice 2d6
05:39:45 <lambdabot> 2d6 => 7
05:40:21 <psnl> ohub: there is a local ntpd, so I think you are a couple of seconds out
05:40:27 * Maddas investigates eshell
05:40:55 <Maddas> shapr: by the way, thanks for mentioning reversible logic, there's quite a lot of interesting stuff to read about it :-)
05:41:27 <ohub> psnl; hehe, I was trying to make a joke out of 2 hours difference :)
05:41:42 * vincenz mutters
05:43:52 <yaarg> any haskell podcasts?-)
05:44:39 <shapr> Maddas: Definitely
05:44:46 <roconnor> what would a haskell podcast be?
05:44:47 <shapr> I am a font of interesting things.
05:44:51 <yip> there are haskell "blogs"
05:44:51 <shapr> roconnor: Anything!
05:45:12 <shapr> I recorded some mp3s on my blog, but I didn't get any feedback about them.
05:45:23 <roconnor> Maddas: there seems to be some trade off between time, space, and heat (reverability)
05:45:27 <shapr> Has telia just started blocking all incoming connections?
05:46:11 <davidhouse> @type fail
05:46:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
05:46:50 <roconnor> > (fail "boom") :: (Either String String)
05:46:51 <lambdabot>  add an instance declaration for (Monad (Either String))
05:46:51 <lambdabot>   In the expressio...
05:47:32 <shapr> Maddas: Check out trinary logic - http://www.trinary.cc/
05:47:43 <Maddas> roconnor: Right. I've only just started to read about it, and I don't know much about the underlying electronical properties, so I can't say much about it yet, though :)
05:48:04 <shapr> Maddas: And investigate clockless logic, it has a bunch of advantages.
05:48:06 <roconnor> Maddas: who said anything about electronical properties ;)
05:48:14 <yip> is prolog good?
05:48:34 <shapr> yip: If you want to learn logic/constraint programming, I'd suggest Mozart/Oz.
05:49:17 <yip> so prolog is bad?
05:49:41 <roconnor> Even if you use lego logic, if your computation isn't reversable, you will generate heat.
05:50:01 <shapr> No, prolog is worth knowing.
05:50:21 <yaarg> definitely
05:50:28 <apfelmus> there is a simple prolog implementation shipping with hugs98
05:50:45 <Maddas> roconnor: I don't know much about the physical properties of entropy either ;-)
05:50:46 <vincenz> @hoogle fmap
05:50:46 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
05:50:46 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
05:50:46 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
05:50:47 <roconnor> http://goldfish.ikaruga.co.uk/legopics/orgate.jpg
05:50:48 <davidhouse> roconnor: that'd be Left "boom" in the standard monadic definition of Either a.
05:51:18 <Maddas> shapr: Heh. So little time... Thanks, though, I'll save some references to read up on.
05:51:25 <vincenz>     Can't make a derived instance of `Functor (TypedExp t)'
05:51:25 <vincenz>     (`Functor' is not a derivable class)
05:51:27 <roconnor> davidhouse: I figured (Either String) was a monad in the prelude
05:51:30 <vincenz> o.O
05:51:32 <dons> dcoutts_: I think i put a version of the sum program in tests/sum.hs
05:51:41 <dcoutts_> dons, oh right
05:51:42 <davidhouse> roconnor: yeah, sadly not. you'll need to import Control.Monad.Error
05:51:50 <dons> dcoutts_: it might be a bit bitrotted though
05:51:52 <vincenz> why can't I autoderive functorM or fucntor??
05:52:05 * alar recommends Curry for haskellers who want to try constraint programming
05:52:18 <vincenz> anyone?
05:52:48 <dons> dcoutts_: i seem to recall the bottleneck being the String -> Int
05:52:52 <davidhouse> vincenz: use newtype-deriving.
05:52:57 <dcoutts_> dons, yeah, seems so
05:52:59 <roconnor> http://goldfish.ikaruga.co.uk/legopics/FFb.jpg
05:53:07 <dcoutts_> dons, I've been looking at just that
05:53:09 <vincenz> davidhouse: oh thx
05:53:17 <dons> dcoutts_: I added Char8.unsafeReadInt, but calling via C is actually slower 
05:53:22 <dons> maybe you can tune it?
05:53:32 <dcoutts_> I'm writing a haskell version of readInt
05:53:38 <vincenz> davidhouse: newtype doesn't allow record syntax
05:53:38 <davidhouse> dons, in lambdabot, the "args" argument to process_, is that just one long string, everything that was passed in?
05:53:48 <dons> dcoutts_: ok. good. that was on my todo list.
05:53:53 <dons> davidhouse: yep.
05:53:57 <davidhouse> vincenz: then instantiate it yourself.
05:53:59 <dons> trying just printing them to get the idea
05:54:13 <dons> they're not broken up (though perhaps they should be)
05:54:23 <dcoutts_> dons, broken up?
05:54:34 <dons> oh, talking to davidhouse about lambdabot args.
05:54:40 <dcoutts_> ah
05:55:14 * roconnor wants to build a qubit out of lego
05:56:38 <dons> dcoutts_: it would be nice if we could do it in a one liner, with fusion .. :)
05:56:47 <dcoutts_> dons, I think we can
05:56:53 <davidhouse> dons, also, why do warnings from GHC cause a full stop to the building process? it's annoying; means i can't shadow bindings
05:56:59 <dcoutts_> dons, my current version is already nearly a one liner
05:57:05 <dons> dcoutts_: cool
05:57:16 <dcoutts_> main = do
05:57:16 <dcoutts_>    incoming <- B.getContents
05:57:16 <dcoutts_>    print $ sum $ map readInt $ B.lines incoming
05:57:16 <dcoutts_> readInt s = case B.unsafeReadInt s of Just (n,_) -> n
05:57:35 <dcoutts_> it's that readInt, grr
05:59:08 <davidhouse> readInt = fst . fromJust . B.unsafeReadInt
05:59:09 <dons> dcoutts_: readLines would be more efficient
05:59:19 <dons> print . sum . map readInt =<< B.readLiens ?
05:59:24 <davidhouse> if you wanted to make it a oneliner, that is.
05:59:25 <dcoutts_> dons, seems not
05:59:43 <dons> oh, that's interesting then.
05:59:49 <dcoutts_> dons, B.readLines does lots of buffering nonsense
05:59:55 <dons> yeah. true
06:00:05 <dcoutts_> and unsafeInterleaveIO and gubbins
06:00:47 <dons> possibly readFile would be better. or even Lazy.getContents (no reallocs)
06:00:58 <dons> maybe readfile isn't allowed under the rules :)
06:01:48 <dcoutts_> yes, I think the .Lazy version might be best here
06:01:59 <dcoutts_> but that needs a Haskell readInt
06:02:06 <dcoutts_> which is what I'm working on...
06:02:16 <dons> ok. looks like a good advertisement... ;)
06:02:44 <dons> compared to the streams verbosity.
06:02:47 <yip> does ST have something like a linked list where you can insert and delete elements?
06:02:53 <dcoutts_> dons, indeed
06:03:09 <dcoutts_> dons, and if we can do that optimised Lazy.hGetContents...
06:03:28 <dons> ah yes, removing the handle copy.
06:03:33 <dcoutts_> right
06:03:35 <Lemmih> yip: Nope.
06:04:04 <Lemmih> yip: Not in the standard libraries, at least.
06:05:32 <yip> Lemmih: is this something that would be useful or are there existing ways of doing this?
06:06:29 <Foobar> How to import foo from another module as bar?
06:07:13 <davidhouse> import OtherModule (foo); bar = foo
06:08:19 <yip> if "foo" is conflicts with something then you can do: import qualified OtherModule (foo); bar = OtherModule.foo
06:09:02 <davidhouse> yeah, importing qualified is probably better.
06:09:17 <davidhouse> but then you can't use anything else from OtherModule without using its qualified name
06:09:23 <Foobar> I thought there was a direct way. Well, this works too. Thanks
06:13:28 <vincenz> yip: hi
06:13:30 <vincenz> Lemmih: hi
06:13:37 <vincenz> yip: btw were you the one with the gameboy emu?
06:13:38 <yip> sup vincenz 
06:13:43 <yip> vincenz: yeah
06:13:51 <vincenz> what performance do you get out of it?
06:14:05 <vincenz> and how do you deal with "Memory"
06:14:38 <yip> a while ago i tried to optimize it as much as i could and i can almost get enough performance for realtime emulation
06:15:02 <vincenz> yip: more or less ops/s?
06:15:16 <vincenz> and do you happen to know the bottlenec?
06:15:20 <yip> in one attempt i've used Data.Array.Unboxed for memory, in another attempt i've used Data.Array.IO
06:15:36 * vincenz might be interested in reusing the ideas to maybe make an instruction-level simulator
06:15:45 <vincenz> for RISC
06:16:09 <yip> gameboy cpu is 4 mhz, most instructions are 4 clocks, so i guess one millions ops/s
06:16:29 <vincenz> quite impressive
06:16:43 <vincenz> afaik, topnotch instruction level simulators work at that rate
06:16:50 <vincenz> yip: does gameboy have pipelining?
06:17:04 <yip> no, it's a z80 cpu
06:17:10 <vincenz> yip: memory latency?
06:17:19 <alar> vincenz: what platform do you want simulate on what platform?
06:17:28 <vincenz> I don't know
06:17:31 <vincenz> maybe a RISC
06:17:44 <alar> RISC on RISC?
06:17:49 <yip> not sure what memory latency is, but i don't think it has it. the ops that read and write to memory are regular ops, but they usually take more then 4 clocks
06:17:58 <vincenz> like the ...ARM
06:18:05 <vincenz> yip: is your stuff opensource?
06:18:22 <yip> vincenz: the code is online, but it's not version controlled, and it's kind of messy
06:18:28 * vincenz nods
06:18:30 <vincenz> linky?/
06:18:44 <yip> http://www.mutantlemon.com/omegagb/devlog/snapshots/
06:19:00 <alar> yip: memory latency is probably the number of wait states which is added to instruction when it acceses the memory
06:19:05 <yip> the devlog itself actually explains quite a bit about the code itself
06:19:15 <vincenz> yip: thankks
06:19:32 <vincenz> alar: that's arch dependent
06:19:38 <vincenz> good thing I have henessy and patterson
06:19:42 <yip> i should update that devlog
06:19:55 <alar> vincenz: that's memory type dependent :)
06:20:06 <vincenz> alar: not quite
06:20:17 <vincenz> yip: can you give me an estimate on amount of time you spent on it?
06:20:30 <vincenz> to get a gross cost projection
06:20:37 <alar> e.g. on ADSP one instruction can access two memories with different number of waitstates
06:20:56 <alar> so exectution time = 1+WS1+WS2
06:21:40 <yip> vincenz: i was able a minimal emulator working that was able to just barely partially run some games with a development time of about 10 hours i guess. this was after spending several days reading through the gameboy specs
06:22:15 <yip> vincenz: you should read the devlog :D http://www.mutantlemon.com/omegagb/devlog/
06:22:28 * alar dreams of software that produces simulator from specs
06:22:55 <yip> a simulator *is* the specs :P
06:23:17 <vincenz> yip: thanks for the info
06:23:37 <davidhouse> argh.
06:23:41 <davidhouse> stupid tuples.
06:23:44 <vincenz> ?
06:23:57 <davidhouse> tuples just ruined my lambdabot plugin :)
06:24:10 <vincenz> they're anamorphic?
06:24:43 <davidhouse> it's a plugin to get a list of instances given a typeclass. it basically parses the output of sending :i TypeClass to GHCi.
06:25:18 <davidhouse> i previously filtered out the brackets to make things like instance (Monad m, Monoid w) => Monad (WriterT w m) easier to parse
06:25:25 <davidhouse> but i forgot about tuples.
06:25:43 <alar> oh
06:26:00 * alar wanted such plugin for a long time
06:26:07 <SamB_XP> ooh, yum
06:26:10 <davidhouse> alar, it's coming ;)
06:26:14 <davidhouse> hopefully have it finished by this evening.
06:26:16 <SamB_XP> fixorate!
06:26:23 <alar> great! even without tuples
06:30:04 <davidhouse> alar, you can currently get this behaviour by heading into GHCi and hitting :info (or :i for short) TypeClass, but i'm just transforming it into a LB-plugin.
06:30:30 <SamB_XP> davidhouse: but, is it going to have *all* the modules loaded?
06:30:40 <davidhouse> SamB_XP: no, it'll load a lot
06:30:53 <davidhouse> there's also another command, @instances-importing, which allows you to specify extra modules.
06:33:01 <alar> davidhouse: currently I get this behavior from Hugs, but if most of interactive functionality of haskell implementation could be get from lambdabot - wouldn't it be nice?
06:33:13 <SamB_XP> will there be another command, @instances-building-and-importing, for packages not yet built? ;-P
06:33:20 <davidhouse> alar, right.
06:33:26 <davidhouse> SamB_XP: hehe
06:33:50 <davidhouse> "@instances-building-and-importing Cabal Monad" ... 20 minutes later... "lots of stuff"
06:38:46 <SamB_XP> I was thinking more like you'd give the repo URL as the first arg, module as second, and class as third
06:41:20 <davidhouse> so it'd... 1) darcs get the repo. 2) parse the README for building instructions. 3) build it. 4) build a list of modules. 5) start a GHCi session, import those modules and make the request? :)
06:41:24 <davidhouse> use haddock ;)
06:43:09 <SamB_XP> haha
06:43:39 <SamB_XP> well, okay, so we should have a @instances-using-haddock-for-package command ;-D
06:44:16 <davidhouse> wow, the tuples problem was shockingly easy to fix
06:44:49 <davidhouse> haha! life is good. :)
06:45:19 <davidhouse> quick, i need a fairly obscure module which instantiates some typeclass!
06:45:59 <SamB_XP> Text.Xml.something-or-other?
06:46:17 <SamB_XP> er, + .HXT
06:46:21 <ADEpt> Text.Html
06:46:29 <SamB_XP> perhaps the arrows interface ;-)
06:46:38 <SamB_XP> ADEpt: that was my first choice
06:46:58 <SamB_XP> I guess it doesn't matter if it also *defines* the class...
06:47:04 <SamB_XP> yeah, Text.Html ;-)
06:47:14 <davidhouse> what does that instantiate?
06:47:22 <SamB_XP> Html
06:47:28 <SamB_XP> at least
06:47:43 <SamB_XP> @doc Text.Html
06:47:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html
06:48:45 <davidhouse> @localtime dons
06:48:47 <lambdabot> Local time for dons is Thu Jun  1 23:41:14 2006
06:49:10 <SamB_XP> he is not up yet
06:49:20 <SamB_XP> at least, I think he will be in bed by now
06:49:32 <SamB_XP> or at least off the computer
06:49:53 <SamB_XP> wait, class is actually HTML
06:50:27 <davidhouse> huh, @instance-importing Text.Html Html hangs. oops :)
06:50:32 <SamB_XP> Html is a newtype over [HtmlElement], apparantly
06:50:45 <roconnor> @type replicate
06:50:46 <lambdabot> forall a. Int -> a -> [a]
06:50:59 <SamB_XP> good thing I gave you the wrong name for the typeclass, eh?
06:51:09 <roconnor> > length $ replicate 5 (undefined::())
06:51:10 <lambdabot>  5
06:51:39 <davidhouse> http://pastebin.com/751294
06:51:45 <dons> davidhouse: ?
06:51:57 <SamB_XP> dons: what, still up!
06:52:01 <davidhouse> SamB_XP, alar, dons, anyone else that might be interested: ^^
06:52:03 <dons> on my way out.
06:52:20 <SamB_XP> davidhouse: you are supposed to make a darcs patch -- or is that one?
06:52:20 <davidhouse> dons, my instances patch is mostly finished. i'll let you apply it tomorrow ;)
06:52:41 <dons> yeah, looks cool, davidhouse 
06:52:43 <davidhouse> oops, it borks on (). reduces it to ""! :)
06:52:58 <SamB_XP> haha
06:53:19 <SamB_XP> oh, that is just a demo ;-)
06:53:23 <davidhouse> okay, that's fixed.
06:53:26 <davidhouse> SamB_XP: of course.
06:53:58 * roconnor tries to remember how to use darcs
06:54:07 * SamB_XP thought davidhouse had been pasting the source for the module all this time, because he hadn't looked before 
06:54:24 <SamB_XP> that is, you've pasted things about this before, haven't you?
06:54:35 <davidhouse> perhaps one similar to the above.
06:54:40 <davidhouse> no source.
06:56:16 * dons >> threadDelay 8 hrs -- night!
07:05:23 <davidhouse> *yawn*
07:05:28 <davidhouse> lambdabot takes _so long_ to link.
07:06:27 <ndm> davidhouse: use Yhc, instant linking :)
07:06:36 <SamB_XP> are you using the dynamic or the static build?
07:07:17 <davidhouse> dynamic.
07:07:21 <davidhouse> with make way=fast
07:07:33 <davidhouse> well, actually.
07:07:38 <davidhouse> hmm, it might be static.
07:07:48 <davidhouse> so make way=fast dynamic=yes should be quicker?
07:08:16 * SamB_XP chastises dons about not perenthesizing his "8 hrs"
07:08:33 * SamB_XP checks type just to be sure
07:08:43 <SamB_XP> @index threadDelay
07:08:43 <lambdabot> GHC.Conc, Control.Concurrent
07:08:51 <davidhouse> dynamic build took about the same length of time.
07:08:57 <SamB_XP> @type Control.Concurrent.threadDelay
07:08:58 <lambdabot> Int -> IO ()
07:09:01 <davidhouse> SamB_XP: @hoogle combines @index and @type into one command
07:09:06 <SamB_XP> davidhouse: well, you shouldn't need to link again as soon
07:09:17 <SamB_XP> davidhouse: point
07:09:19 <davidhouse> @hoogle threadDelay
07:09:20 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
07:09:20 * dons back. 
07:09:26 <davidhouse> dons, that wasn't 8 hrs!
07:09:26 <dons> davidhouse: try running in ghci...
07:09:28 <dons> to test things
07:09:45 <SamB_XP> okay, as I suspected, you need parentheses around the "8 hrs"
07:09:56 <davidhouse> why didn't i think of that?
07:10:19 * dons >> threadDelay (8*60*60*1000)
07:10:21 <davidhouse> i think i tried it once without -fglasgow-exts, found it errored, and gave up.
07:10:32 <SamB_XP> @type Control.Concurrent.threadDelay 8 hrs
07:10:33 <lambdabot> Not in scope: `hrs'
07:10:43 <SamB_XP> @type let hrs = undefined in Control.Concurrent.threadDelay 8 hrs
07:10:44 <lambdabot>   Couldn't match `IO ()' against `t -> t1'
07:10:45 <lambdabot>   Expected type: IO ()
07:11:03 <SamB_XP> @type let hrs = undefined in Control.Concurrent.threadDelay (8 hrs(
07:11:05 <lambdabot> parse error (possibly incorrect indentation)
07:11:06 <SamB_XP> @type let hrs = undefined in Control.Concurrent.threadDelay (8 hrs)
07:11:07 <lambdabot>   No instance for (Num (a -> Int))
07:11:08 <lambdabot>   arising from the literal `8' at <interactive>:1:55
07:11:19 <alar> =)
07:11:59 <alar> > let 8 = (\_-> undefined) in let hrs= undefined in  Control.Concurrent.threadDelay (8 hrs)
07:12:00 <lambdabot>  Not in scope: `Control.Concurrent.threadDelay'
07:13:03 <davidhouse> > let theseQuestions = (++" questions") . show in "Answer me " ++ theseQuestions 3
07:13:04 <lambdabot>  "Answer me 3 questions"
07:13:15 <SamB_XP> now you need a Num instance for (a -> Int), and an hrs which works with this instance to give the time in miliseconds...
07:14:11 <davidhouse> data PeriodOfTime = Hours | Minutes | Seconds | Milliseconds
07:14:43 <davidhouse> instance Num (PeriodOfTime -> Int) where ...
07:14:52 <davidhouse> although that wouldn't quite work because you don't have any information what number is calling.
07:15:02 <SamB_XP> what, undecidable instances is it?
07:15:48 * SamB_XP was actually thinking that you could have 8 :: (Int -> Int) or something
07:15:55 <davidhouse> i don't think so
07:16:19 <davidhouse> the problem is, we could do ^^ that and have something like 8 Hours, but then how do you convert that into an Int?
07:16:23 <vincenz> \o/
07:16:26 <davidhouse> you don't know what number is calling.
07:16:40 <vincenz> woot woot
07:16:45 <SamB_XP> e.g., instance Num a => Num (a -> a) where fromInteger = (*)
07:17:04 <davidhouse> then hrs = 60*60?
07:17:19 <SamB_XP> you forgot the 1000
07:17:19 <alar> hrs = 60*60*
07:18:56 <mux> @hoogle popen
07:18:57 <lambdabot> No matches found
07:19:50 <davidhouse> mux, if you're lambdabot-hacking, look in Lib.Process
07:20:05 <Lemmih> *Test> 8 hrs :: Integer
07:20:05 <Lemmih> 28800000
07:20:16 <mux> davidhouse: not touching lambdabot, but I suppose that can still be useful, thanks
07:20:42 <davidhouse> Lemmih: how?
07:21:09 <Lemmih> davidhouse: 'Num a => Num ((a -> b) -> b)'
07:24:52 <Foobar> @pointless (\x->f x y)
07:24:52 <lambdabot> flip f y
07:25:07 * SamB_XP did it wrong?
07:25:31 <SamB_XP> oh, oh
07:25:35 <SamB_XP> I see what you've done
07:27:37 <SamB_XP> is this really russian? " "   "    "
07:34:06 <davidhouse> anyone using the http://haskell-unsafe.alioth.debian.org/archive/i386 repo with ubuntu dapper?
07:47:13 <vincenz> hmm
07:48:10 * mux wonders why HaXml thinks this file isn't correct
07:49:00 <marencian> If i have a list of ints and a function f that modifies int lists, how could I make a list of int lists where each element is the result of applying f to the previous one?
07:51:11 <roconnor> @hoogle [a -> b] -> a -> [b]
07:51:11 <Stinger_> a = f list : [f x | x <- a] perhaps
07:51:12 <lambdabot> No matches, try a more general search
07:51:38 <roconnor> @hoogle [m b] -> m [b]
07:51:39 <lambdabot> Prelude.head :: [a] -> a
07:51:39 <lambdabot> Prelude.last :: [a] -> a
07:51:39 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
07:51:50 <roconnor> @hoogle (Monad m) => [m b] -> m [b]
07:51:50 <lambdabot> Prelude.head :: [a] -> a
07:51:50 <lambdabot> Prelude.last :: [a] -> a
07:52:00 <mux> ?djinn a -> [a]
07:52:01 <lambdabot> -- f cannot be realized.
07:52:40 <davidhouse> marencian:
07:53:14 <davidhouse> > map ($ [1..5]) [ length, length . (0:), maximum ]
07:53:15 <lambdabot>  [5,6,5]
07:53:17 <Saulzar> One of scanl / scanr 
07:53:20 <roconnor> @type sequence
07:53:22 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:53:36 <mux> @type mapM
07:53:36 <davidhouse> oh, sorry, i misread what you wrote.
07:53:37 <lambdabot> forall b (m :: * -> *) a.
07:53:37 <lambdabot>    (Monad m) =>
07:53:37 <lambdabot>    (a -> m b) -> [a] -> m [b]
07:53:53 <davidhouse> > foldl (flip (.)) id [ length, length . (0:), maximum ] $ [1..5]
07:53:54 <lambdabot>  Couldn't match `[a]' against `Int'
07:54:17 <roconnor> @pl sequence (map f l)
07:54:17 <lambdabot> sequence (map f l)
07:54:18 <davidhouse> > foldl (flip (.)) id [ (0:), (1:), (2:) ] $ [1..5]
07:54:19 <lambdabot>  [2,1,0,1,2,3,4,5]
07:54:38 <davidhouse> err, still not right.
07:54:46 <davidhouse> > scanl (flip (.)) id [ (0:), (1:), (2:) ] $ [1..5]
07:54:46 <lambdabot>  Couldn't match `[a]' against `t -> t1'
07:54:52 <davidhouse> @type scanl
07:54:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
07:55:08 <davidhouse> > (scanl (flip (.)) id [ (0:), (1:), (2:) ]) [1..5]
07:55:09 <lambdabot>  Couldn't match `[[a] -> [a]]' against `t -> t1'
07:55:18 <roconnor> I think mapM does what I want
07:55:26 <Saulzar> > scanr (:) [] [1,2,3,4]
07:55:27 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
07:55:43 <davidhouse> roconnor: what do you want?
07:55:57 <roconnor> sequence (map foo l)
07:56:04 <roconnor> ?= mapM foo l
07:56:05 <lambdabot> Maybe you meant: . v
07:56:06 <davidhouse> yep, mapM.
07:56:09 <mux> yeah, mapM = sequence . map
07:56:28 <marencian> Saulzar: that looks pretty close, I might be able to work from that thanks
07:56:39 <roconnor> I'm not used to thinking about the (a ->) monad.
07:57:35 <roconnor> @hoogle (Ord a) => [a] -> a
07:57:36 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
07:57:36 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
07:57:36 <lambdabot> Prelude.head :: [a] -> a
07:57:40 <mux> ?kind (->)
07:57:41 <lambdabot> ?? -> ? -> *
07:58:56 <palomer>  /me wonders how to find out how many people in the channel are from montreal
07:59:08 <roconnor> I was in montreal on Sunday
07:59:18 <mux> Parse error: in  file gamelist.xml  at line 18996 col 39
07:59:18 <mux>     missing attvalue
07:59:18 <mux>   Found ' or "
07:59:42 <mux> any idea what HaXml means here? the file looks clearly valid, and is generated automatically
07:59:59 <davidhouse> mux, paste the XML around that line
08:00:01 <mux>                         <dipvalue name="80%" default="yes"/>
08:00:02 <palomer> roconnor: doing what?
08:00:14 <mux> the column 39 is right after name=, the "
08:00:20 <roconnor> I was visiting friends after the ASL general meeting
08:00:31 <davidhouse> odd.
08:00:47 <roconnor> Association for Symbolic Logic
08:01:41 <mux> it's properly lower-case, properly quoted and the tag is correctly closed
08:01:44 <mux> wtf
08:02:02 <nnunley> mux: It might think you're attempting a system entity.
08:02:16 <mux> nnunley: can you please explain?
08:03:14 <roconnor> where is the ((->) a) monad defined?
08:03:26 <mux> Control.Monad.Reader
08:06:52 <nnunley> mux: % is another kind of entity marker in XML, but I only recall it working in DTD declarations.
08:07:15 <mux> mmm, that would be a bug in HaXml then
08:07:31 <nnunley> So if you escape the % it might work.
08:07:51 <mux> I don't think it will given it errors before the % column, but let me check
08:08:06 <mux> nah, same thing indeed
08:10:25 <roconnor> import Control.Monad.Reader hiding join
08:10:31 <roconnor> parse error on input `join'
08:10:40 <mux> try (join)
08:11:24 <roconnor> Hmmm, the Gentle Introduction to Haskell has led me astray
08:15:57 <roconnor> @pl \eps -> minimum (map (\x -> modulus x eps) l)
08:15:58 <lambdabot> minimum . flip map l . flip modulus
08:16:17 <roconnor> @pl minimum (map (\x -> modulus x eps) l)
08:16:18 <lambdabot> minimum (map (flip modulus eps) l)
08:16:43 <davidhouse> roconnor: what were you expecting?
08:16:53 <mux> hah, I'm cursed
08:17:13 <mux> I tried to use perl's XML::Parser to see if it could grok the XML file
08:17:23 <mux> Out of memory during "large" request for 134221824 bytes, total sbrk() is 465317888 bytes at /usr/local/lib/perl5/5.8.8/mach/Data/Dumper.pm line 179.
08:17:25 <roconnor> just pondering the most clear way to write this
08:17:45 <davidhouse> seems clear enough to me.
08:17:53 <mux> perl needs lazy evaluation..
08:18:55 <yaarg> Perl 6 
08:18:56 <yaarg> :)
08:19:04 <mux> heh
08:19:16 <mux> anyways, XML::Parser could successfully parse the xml file
08:19:33 * mux eyes HaXml suspiciously
08:19:57 <roconnor> davidhouse: yep. flip is usually confusing.
08:20:02 <roconnor> @type flip flip flip
08:20:04 <lambdabot> forall a c a1 b c1.
08:20:04 <lambdabot>       (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
08:20:34 <davidhouse> roconnor: i'm not a big objector to flip. i'll happily use a lambda here and a flip there.
08:20:38 <davidhouse> depends on the size of the function.
08:20:43 <davidhouse> and its arguments.
08:20:45 <mux> let flap = flip . flip
08:20:54 <mux> > let flap = flip . flip
08:20:54 <lambdabot>  Parse error
08:20:59 <mux> > let flap = flip flip
08:21:00 <lambdabot>  Parse error
08:21:08 <mux> grmbl
08:21:23 <davidhouse> > let flap = flip . flip in flap (+) 3 4
08:21:24 <lambdabot>  7
08:21:49 <mux> ah, I can't just have lambdabot remembers stuff?
08:21:49 <roconnor> that's a terrible example.
08:21:54 <davidhouse> mux, nope.
08:22:01 <davidhouse> roconnor: yes it is!
08:22:04 <davidhouse> > let flap = flip . flip in flap (-) 3 4
08:22:05 <lambdabot>  -1
08:22:09 <davidhouse> flap = id
08:22:28 <mux> > let flap = flip . flip in flip flap (-) 3 4
08:22:29 <lambdabot>  add an instance declaration for (Num ((a1 -> a1 -> a1) -> a -> c))
08:22:48 <roconnor> > let flap = flip . flip in flap asTypeOf [] "hello"
08:22:49 <lambdabot>  ""
08:23:26 <roconnor> > let flap = flip . flip in flap asTypeOf 1 undefined
08:23:27 <lambdabot>  1
08:24:45 <davidhouse> > 1 `asTypeOf` undefined
08:24:46 <lambdabot>  1
08:27:58 * vincenz screams
08:31:03 <vincenz> crap crap
08:31:10 <vincenz> :(
08:31:17 <vincenz> stupid name resolver
09:08:21 <davidhouse> okay.
09:08:24 <davidhouse> wish me luck
09:08:32 <davidhouse> i've just installed Dapper, going for reboot
09:08:55 <psi> I wish you luck
09:09:31 <davidhouse> thankyou. :)
09:10:08 <psi> god, I'm getting "foo multiply defined". Sure, but I'm using different patterns. I'm probably blind.
09:11:11 <psi> aha. I had another definition in between.
09:20:24 <davidhouse> did it work?
09:25:25 * SamB wonders how to get HXT to unparse XML...
09:31:12 <vincenz> :)
09:31:13 <vincenz> \o/
09:32:30 <RyanT5000> so i'm trying to build SerTH with -prof (configure -p) and i'm getting this error: unknown symbol `_era', inBSerDerive.p_o
09:32:56 <RyanT5000> anyone know what the deal with that is?
09:34:15 <Saulzar> I have heard ghci or TH with profiling are no go currently
09:34:29 <RyanT5000> ah ok
09:34:38 <Jackson> Evenin all
09:34:38 <RyanT5000> i'll just turn off profiling in that area
09:34:48 <davidhouse> hi Jackson 
09:35:08 * davidhouse is now running dapper! but it's back to konversation as irssi is _very_ buggy at the moment
09:36:06 <Jackson> almost finished all my stuff dave, one last , perturbing function that I am hoping you can give me a hand with
09:38:31 <Jackson> what is the lisp site again? :p
09:39:50 <Jackson> d/w found it
09:40:00 <vincenz> @where paste
09:40:00 <lambdabot> http://paste.lisp.org/new/haskell
09:43:18 <lisppaste2> Jackson pasted "displayPolynomial" at http://paste.lisp.org/display/20709
09:44:04 <Jackson> There we go, any ideas Oh great lords of Haskell? :p
09:45:13 <davidhouse> Jackson: when you need to call a function on each member of a list, think map.
09:46:01 <davidhouse> so you'd need to map across the list of terms, producing a string for each one which is that term displayed.
09:46:19 <Jackson> yep, didnt even think of that
09:46:21 <davidhouse> then you'd have a list of strings, and you need to join them all up to make one long string. for that, use concat.
09:49:01 <Jackson> think its working, now testing it
09:49:46 <dcoutts_> g'evening SyntaxNinja 
09:49:57 <Jackson> And think I should use a gate to get rid of the "+ " ?
09:50:34 <davidhouse> a gate? as in an if statement?
09:51:21 <Blicero> or you could use concatMap
09:51:32 <Jackson> sorry, meant a guard with a condition
09:51:38 <davidhouse> Blicero: that's essentially what i'm saying
09:52:15 <Blicero> yes just a tad more convenient
09:52:24 <SyntaxNinja> w00t
09:52:36 <davidhouse> Jackson: i would just do what you're doing currently in the term function.
09:53:14 <Jackson> yep, thats what I am trying now
09:53:17 <davidhouse> Jackson: i don't suppose you'd have the entire assessment in electronic form? it looks like quite a fun project.
09:53:52 <Stinger_> polynomials? fun?! ;)
09:54:32 <Jackson> sure, lemme see if I can dig it up. Is probaly fun for those with more that a couple of lectures worth of knowledge :p Although I must admit as I understand more and more it is getting more enjoyable
09:54:45 <davidhouse> hehe yeah.
10:01:17 <dcoutts_> dons, now twice as fast as Bulat's imperative version and still a one-liner
10:01:40 <lisppaste2> Jackson pasted "Polynomial Lab" at http://paste.lisp.org/display/20711
10:01:51 <Jackson> Thats what I had electronically
10:01:53 <Stinger_> what are you speeding up dcoutts ?
10:01:58 <davidhouse> Jackson: great :)
10:02:11 <dcoutts_> Stinger_, the sum-file test, using ByteString
10:02:13 <davidhouse> now, once i get emacs working, i'll give it a shot
10:02:22 <dcoutts_> dons, but still 3x slower than C
10:02:42 <Stinger_> ah, yes I remember you mentioning file io mumbo jumbo
10:03:15 <Mag1KaL> Does HOpenGL come with GHC 6.4+?
10:03:23 <dcoutts_> yes
10:13:10 <dcoutts_> dons, yes, fusing the sum . map read into a foldl improves things too
10:13:26 <dcoutts_> dons, interestingly foldl is faster than foldl'
10:15:02 <lisppaste2> Jackson pasted "Uno More Problemo" at http://paste.lisp.org/display/20713
10:15:44 <Jackson> I really dont love exact specifications...
10:16:05 <Stinger_> eh?
10:16:15 <Stinger_> foldl is faster than foldl?
10:17:25 <Blicero> foldl'
10:17:42 <Blicero> the ' is part of the function name
10:18:18 <Stinger_> ah rightyoh
10:18:38 <Stinger_> damn weirdo language ;)
10:19:05 <dcoutts_> Stinger_, the ' char is nice to have in variable names,  n  n'
10:19:14 <dcoutts_> let n' = next n in ...
10:19:56 <vincenz> why is Data.Map not a FunctorM?
10:19:58 <Stinger_> would've been good in my implementation of this multiplication algorithm I wrote
10:20:08 <Stinger_> instead of Mprime everywhere
10:20:20 <Stinger_> although then I couldnt have called it M either :P
10:29:32 <Jackson> davidhouse: any ideas on that specifications problem oh mine?
10:29:34 <davidhouse> what _is_ a FunctorM?
10:29:54 <davidhouse> Jackson: sorry, i've been a bit distracted. damned OS upgrade broke the emacs.
10:30:00 <davidhouse> Jackson: what was your question?
10:30:03 <davidhouse> @hoogle FunctorM
10:30:04 <lambdabot> Data.FunctorM :: module
10:30:04 <lambdabot> Data.FunctorM.FunctorM :: class FunctorM f
10:30:28 <davidhouse> oh... FunctorM is the module deprecated in favour of Control.Applicative, right?
10:30:51 <Jackson> David: ahh, ouch Feel sorry for you, problem is at: http://paste.lisp.org/display/20713
10:32:14 <davidhouse> Jackson: what's the second guard for?
10:32:51 <Jackson> it takes the "+ " out for those that have it
10:33:29 <davidhouse> i think that's backwards, isn't it?
10:33:38 <davidhouse> you need to check if it's > 0
10:34:25 <davidhouse> as only positive coefficients get a "+ " in front of them
10:34:46 <Cale> actually, it's only negative coefficients that have a "- " in front
10:34:52 <Jackson> once again I learn the implications of not reading my work :p
10:35:04 <Cale> (shouldn't it be)
10:35:22 <Cale> well, depends on what term does
10:35:30 <davidhouse> Cale, well, you render all the terms with an explicit sign, then chop the leading +s if necessary.
10:35:43 <Cale> ah, okay
10:36:45 <Cale> yeah, you probably want to use unwords unstead of concat
10:37:00 <Jackson> thanks for that David, I 'hopefully' would have picked it up before submitting
10:37:23 <davidhouse> okay.
10:38:03 <davidhouse> as for your question
10:38:11 <Jackson> unwords looks like a good idea
10:38:27 <davidhouse> yeah, unwords would do it.
10:38:43 <davidhouse> i was going to suggest something much more complex, but unwords would do great :)
10:39:04 <Jackson> thanks there cale
10:41:42 <Jackson> *sigh* have to edit term now, term (1,1) returns "+ 1 x" , not "+ 1"
10:41:45 <Jackson> :e
10:42:14 <Cale> shouldn't it?
10:42:38 <Jackson> wait it should
10:42:47 <Jackson> so the problem is in displayPoly then
10:43:05 <davidhouse> that should return "+ x", right?
10:43:19 <Jackson> yeah
10:43:32 <Jackson> as in example two
10:43:47 <davidhouse> treat cases with a coefficient of 1 specially.
10:43:59 <Cale> and 0 :)
10:44:09 <davidhouse> yeah
10:44:13 <davidhouse> and -1
10:44:17 <Cale> (actually, you probably want to delete all the terms with coefficient 0 beforehand
10:44:22 <Cale> )
10:44:29 <davidhouse> but then, as you're considering abs values, -1 corresponds to 1)
10:44:29 <Jackson> there is a precondition for that
10:44:35 <Jackson> thankfully
10:44:43 <davidhouse> aww, it'd be easy
10:44:49 <davidhouse> filter ((/=0) . fst)
10:45:36 <Jackson> yep, what I would have done
10:46:27 * davidhouse wants a "none" function: none = (not .) . any, or none = all . not
10:46:55 <Jackson> how would I go about writing a specific for cases of coefficient == 1 ?
10:47:07 <davidhouse> make a special case in term.
10:47:11 <davidhouse> (using a guard)
10:47:49 <Jackson> yeah, was able to create the guard
10:48:13 <Jackson> just not sure about modifying the tuple in the list
10:48:26 <Jackson> or the answer it would give
10:48:37 <davidhouse> i don't think you'd need to
10:49:32 <Saulzar> Arrowised fibs using stream processors must be the slowest fib sequence in existance which still uses Integer
10:50:07 <Saulzar> Compiled with 02 it barely gets above 100k I think something horrible must be happening :)
10:50:08 <davidhouse> hehe
10:50:26 <davidhouse> what exactly are stream transformers? i never did quite get that from Paterson's paper
10:52:28 <Saulzar> Some kind of function which operates on streams, eg. add something to the front, map the elems etc..
10:53:06 <davidhouse> where a stream is a kind of generalised list? one thing after another?
10:53:18 <davidhouse> + seeking
10:53:50 <Saulzar> Yeah, it seems a list is often used as a stream. 
10:54:16 <Stinger_> the way I learnt about streams seems they are just like lists in haskell, due to the lazy eval
10:54:28 <davidhouse> yeah.
10:54:44 <davidhouse> you'd probably need to pair it with an integer to represent the current position, or something.
10:54:47 <Saulzar> In this case I'm fidding with the Fudgets example, which doesn't operate directly on lists .. though I'm using it with a list through it (not quite sure how it should properly be used)
10:55:07 <Stinger_> learnt about them in scheme where they used some primative to specifically delay evaluation (delay mebbe? :P )
10:55:32 <Saulzar> I'm not sure they usually support seeking
10:55:58 <Saulzar> These examples certainly don't
10:56:09 <febuiles> Mmm, I'll bother you real quick if you permit me, if I implement a lamda-term like: data LTerm = Var String | App LTerm LTerm | Abs String LTerm
10:56:12 <Stinger_> dont think they would
10:56:21 <davidhouse> hm, okay.
10:56:29 <febuiles> and I have a print function like showLTerm:: LTerm -> String
10:56:39 <febuiles> would I have to do a pattern for Var App and Abs?
10:57:03 <davidhouse> febuiles: yeah
10:57:28 <Stinger_> damn, I hope me staying up all night doesnt reinvigorate my cold :(
10:57:50 <davidhouse> showLTerm (Var s) = s; showLTerm (App f x) = showLTerm f ++ " " ++ showLTerm x, ...
10:57:59 <davidhouse> @localtime Stinger_
10:58:01 <lambdabot> Local time for Stinger_ is Thu Jun  1 20:16:58
10:58:22 <febuiles> davidhouse, thank you! :D
10:58:40 <Stinger_> erm, well its 3:30 am here 
10:58:48 <davidhouse> mmm... lambda calcus :)
10:58:58 <febuiles> hehe
10:58:58 <davidhouse> Stinger_: then your client is wrong, lambdabot sends a CTCP request
10:59:05 <davidhouse> either that or your clock is.
10:59:09 <Stinger_> oh yeah that'd be right
10:59:18 <Stinger_> yeah ntpd not set up properly
10:59:31 <davidhouse> err, CTCP TIME thatis
10:59:36 <Stinger_> ok try now ;)
10:59:41 <davidhouse> @localtime Stinger_
10:59:42 <lambdabot> Local time for Stinger_ is Fri Jun  2 03:29:21
10:59:52 <davidhouse> wow, you're in tomorrow.
11:00:08 <Stinger_> Australia, land of the future, as dons says
11:00:22 <Saulzar> You're in yesterday :)
11:03:05 <Jackson> stinger is an hour ahead of me
11:03:15 <Jackson> hour and a half
11:03:36 <Jackson> hmm, wonder where that is.....
11:03:45 <davidhouse> ooh, Stinger_, you're in one of those weird transitional zones
11:04:16 <Stinger_> +9:30 you mean? we like to be different
11:04:57 <Jackson> Adelaide or Darwin
11:05:05 <Stinger_> Adel
11:05:13 <Jackson> pert here
11:05:28 <Stinger_> heh smartarse ;)
11:05:38 <Jackson> :p
11:06:05 <Stinger_> "you live in a shampoo factory?"
11:06:33 * davidhouse has very little clue what is going on
11:06:43 <davidhouse> this is why australians should be kept apart from each other...
11:06:55 <Jackson> I dont even know what that one means
11:07:20 <Stinger_> dont remember pert shampoo, oh well :)
11:07:24 <Jackson> But I will nod my head in the hope it doesnt agitate the beast
11:07:26 <Jackson> nope
11:07:34 <Jackson> is adel the city of churches?
11:07:42 <Jackson> or is that brisbane?
11:07:44 <Stinger_> apparently
11:07:48 <Jackson> i know one of them is a hole
11:07:55 <Stinger_> probably us too
11:08:06 <Jackson> ahh ok, brisbane must be the hole, but if you say so
11:08:30 <Jackson> adel - city of churches has now been overwritten by adel - city of hole
11:08:50 <Jackson> see Haskell even teaches you geography ;)
11:08:53 <Stinger_> the churches are in the hole
11:10:10 <Stinger_> Adel :: Hole => [Churches]
11:11:10 <Stinger_> enough, back to study :|
11:11:23 <Jackson> Pert :: Lost -> Beaches -> Tourists
11:11:27 <Jackson> have fun
11:13:17 <Jackson> hey david, decided to rewrite term in order to fix my problem
11:14:31 <Jackson> added -- | a == 1 || a == -1 = " " ++ sign a ++ " " ++ multiple n -- to it, yet it still returns "+ 1 x" for (1,1)
11:16:24 <davidhouse> could you pastebin the entire term function?
11:16:33 <Jackson> sure
11:16:45 <Jackson> wait, just thought of something
11:17:44 <lisppaste2> Jackson pasted "New Term" at http://paste.lisp.org/display/20716
11:17:52 <Jackson> ugly peice of code
11:18:45 <Jackson> thinking about placing another gate in it, but not sure
11:19:30 <davidhouse> odd. i would expect that to work.
11:19:39 <Jackson> it does
11:19:43 <davidhouse> oh. :)
11:19:49 <Jackson> but then ruins my term (1,0) :(
11:19:59 <davidhouse> ah, true.
11:20:07 <davidhouse> well, add another condition to your guard.
11:20:37 <Jackson> n /= 0 ?
11:21:39 <Jackson> i think that works
11:23:19 * Jackson feels empowered
11:23:42 <Cale> It might almost be easier to convert your polynomials to expression trees and simplify them slightly before converting those to strings.
11:24:40 <Jackson> it works perfectly as far as I can tell now
11:24:55 <Jackson> well good enough for me :p
11:25:00 <Cale> just leave it then :)
11:25:03 <pitecus> Hi. Is there in Parsec something like "parse" but which returns the unparsed rest of the string?
11:25:28 <SamB> hmm...
11:25:33 <SamB> Fail: /usr/lib/happy-1.15/HappyTemplate-ghc-debug: openFile: does not exist (No such file or directory)
11:25:39 <SamB> where can I grab this file...
11:26:38 <SamB> oh, I guess I could just flip another option...
11:27:25 <Cale> pitecus: you could just add  s <- many anyChar  to the end of your parser.
11:27:33 <SamB> pitecus: getInput?
11:27:35 <Cale> (and return s along wth the output)
11:28:17 <pitecus> thanks, Cale, SamB 
11:29:29 <SamB> Igloo: are you aware that there seems to be a templtate missing from the happy=1.15-1 package?
11:29:40 <SamB> er, without that extra t
11:31:10 * vincenz goes to sleep after > 24 hours of haskell coding
11:31:55 <Igloo> SamB: I don't think so. Any template in particular?  :-)
11:33:11 <Igloo> SamB: Actually, I do have a vague memory that a debug one doesn't exist or something. Is that what you're talking about?
11:33:18 <pitecus> Cale, your suggestion would cause all the remaining characters to be evaluated, no?
11:33:48 <Cale> pitecus: why should it?
11:34:12 <Cale> I suppose that it might if anyChar is strict, but it has no good reason to be.
11:34:41 <pitecus> OK, I'll try it
11:34:58 <Cale> hmm, it might actually force the list structure though
11:35:10 <Cale> so yeah, go with getInput if that works
11:35:47 <pitecus> Good, thanks guys
11:38:45 <Jackson> ok then, time for me to sleep
11:39:07 <SamB> Igloo: yeah, the one mentioned above
11:39:28 <Jackson> thanks all for the help, and hope to see you when I next have a couple of problems
11:39:33 <Jackson> :p
11:39:49 <SamB> Igloo: I noticed that if I just add the -a flag, though, I'm okay
11:43:05 <Igloo> SamB: OK, looks like the one I remember, but the presence of other debug templates is suspicious. I'll make a note to look into it
11:43:09 <Igloo> Thanks
11:43:30 <SamB> Igloo: I would have just guessed that one got overlooked somehow...
11:43:55 <SamB> or deleted or something
11:44:16 <Igloo> SamB: Not by me, I don't think
11:44:24 <SamB> well, yeah, it would have to be upstream
11:44:30 <mux> nnunley: oops, you were actually right about HaXml thinking the % is a parameter identity start; I don't know how I managed this but now that I remove the percent, it fails later :-)
11:44:33 <Igloo> Right
11:45:02 <febuiles> hehe
11:45:29 <mux> nnunley: the cool thing is that malcolm wallace nicely sent me a patch to fix the bug, so I'll commit it to the FreeBSD port
11:46:08 <SamB> mux: ooh, I think I've seen that before when trying to abuse it to parse some HTML ;-)
11:46:33 <SamB> or maybe it was someone else who did the abuse
11:58:59 <SamB> vincenz: can you look at my parser?
11:59:27 <SamB> it doesn't do what I think it should do, and I can't see why
12:01:34 <SamB> well, anyway, if anyone wants to look at it, darcs get http://naesten.dyndns.org:8080/repos/HXT-RelaxNG-Compact
12:02:14 <SamB> I'm wondering why it won't parse "start = foo"
12:03:29 <PupenoK> Hello.
12:04:07 <SamB> PupenoK: this is actually not #math, FYI
12:04:31 <SamB> PupenoK: however, we welcome your questions
12:04:36 <PupenoK> SamB: ok. :)
12:06:15 <PupenoK> SamB: I wasn't aware of #math, so I joined here before I was told to join #math
12:06:31 <SamB> PupenoK: ah ;-)
12:07:27 <PupenoK> It should be an honor (this is not quite the word I want, I want the spanish word "alago") to Haskell programers that I have chosen #haskell over the rest of the channels (including #list, #scheme, etc) to ask a math-related question.
12:07:44 <SamB> yes ;-)
12:07:53 * apfelmus now realizes that he isn't on #math. but where is he then?
12:10:08 <SamB> apfelmus: perhaps you are in #combinatorial_logic
12:10:55 <tennin> I usually ask category theory questions here
12:11:13 <apfelmus> SamB: can you *prove* this?
12:11:17 <tennin> generally more productive than asking in #math
12:11:54 * mux tries to parse and print a 25MB XML file with HaXml and sees the code running since 15 minutes and eating about 730MB of resident memory
12:12:07 <mux> wihtout any output yet :-P
12:13:53 <SamB> mux: tried it with HXT yet?
12:14:16 <mux> nope, didn't even know about HXT
12:14:22 <neologism> mux: 25MB xml file is scary
12:14:31 <SamB> I think HXT is the coolest of the three ;-)
12:14:33 <mux> neologism: the MAME gamelist :D
12:14:43 <mux> if that rings a bell
12:15:22 <SamB> mux: you may want to hold off until it uses packed strings!
12:15:26 <mux> ?hoogle HXT
12:15:27 <lambdabot> No matches found
12:15:33 <SamB> @google HXT
12:15:34 <lambdabot> http://filext.com/detaillist.php?extdetail=HXT
12:15:38 <SamB> @google HXT haskell
12:15:39 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
12:15:46 <mux> thanks
12:16:43 <SamB> you are welcome ;-)
12:19:13 <mwc> yikes, if you have a 25 mb xml document, I think you need an event-based parser, is HaXML tree based?
12:19:13 <mux> I had to stop that HaXml code, the process size reached 1.4GB and it was constantly busy swapping
12:19:26 <mux> :-)
12:19:43 <mux> mwc: probably yeah, HaXml is just the very first thing I heard about that handles XML in haskell
12:19:47 <mux> and it's included in GHC
12:19:50 <mux> so I gave it a try
12:19:53 <SamB> it is?
12:19:56 * SamB forgot
12:20:06 <mux> err, actually no it's not
12:20:07 <mux> brain-fart
12:20:12 <SamB> ah
12:20:23 <mux> I think I meant, "it's available in the FreeBSD ports tree" :-)
12:20:30 <SamB> haha
12:21:02 <mux> as an excuse, I'm up since about 30 hours now
12:22:12 <SamB> so, who are some Happy experts other than vincenz ?
12:22:34 <SamB> I suppose JaffaCake, but he isn't here
12:23:05 <apfelmus> i wonder wether any other xml toolbox eats 25 MB files (either haskell or those inferior languages)
12:23:41 <SamB> what is the flag to produce the gamelist?
12:24:36 <norpan> 25 MB, that's not much
12:24:36 <mux> SamB: -listxml
12:25:01 * SamB does so
12:25:05 <mux> looks sufficient to kill HaXml dead
12:27:03 * SamB looks for parsing module for HXT
12:27:11 <apfelmus> i'm not sure, but it might be possible to implement the HaXml filter combinators in an event based way. 
12:27:16 * SamB has not been parsing it lately ;-)
12:27:50 <apfelmus> those filters are some kind of non-deterministic computations
12:27:53 * SamB had misspelled XML as Xml
12:28:30 <apfelmus> and could be evaluated the prolog way (backtracking)
12:28:50 <hyrax42> are any of the xml parsers stream based?
12:29:44 <hyrax42> or not that it makes any diff to me, I guess... my files are all tiny
12:30:43 <apfelmus> hyrax42: you mean event based,  la sax?
12:30:51 <hyrax42> oops
12:30:53 <hyrax42> apfelmus: yeah
12:31:14 <Spark> there arent any that give you a bit of the tree at a time? :)
12:34:21 <apfelmus> hyrax24, Spark: no, HXML,HXT and HaXML need to get the whole tree before doing anything. but i don't know how lazy evaluation softens this
12:36:23 <hyrax42> scheme has ssax...
12:36:26 <hyrax42> *shrug*
12:36:30 * hyrax42 not aware of issues
12:36:31 <hyrax42> :/
12:40:26 <apfelmus> hyrax24: schemers ever wonder why xml exists: xml is just hyped S-expressions 
12:41:22 <SamB> not just hyped... also standardized
12:41:49 <SamB> it is to keep the CL-people and the scheme people from killing eachother
12:42:33 <apfelmus> SamB: xml or standardization? ;-)
12:43:22 <SamB> apfelmus: yes!
12:47:23 <SamB> mux: it looks rather as if HXT could benefit from packed strings
12:47:45 <SamB> though of course this would be a somewhat incompatible change
12:48:03 <mux> SamB: and it looks as if understanding arrows would be interesting for me if I want to use HXT
12:48:19 <SamB> mux: perhaps!
12:48:38 <SamB> I'm not using that part at the moment
12:49:57 <joe_k> does getLine return the newline?
12:50:08 <SamB> joe_k: try it and se!
12:50:29 <joe_k> hmm
12:50:32 <SamB> type "getLine >>= print" in GHCi
12:50:46 <SamB> if it prints a "\n" at the end, yes
12:51:55 <joe_k> it does not include the newline
12:53:02 <SamB> I'm sure it is documented somewhere, too, but sometimes it is just easier to try things ;-)
12:55:49 <apfelmus> @slap apfelmus
12:55:49 * lambdabot smacks apfelmus about with a large trout
12:56:04 * apfelmus vanishes from sight
12:56:30 <SamB> okay...
12:56:39 <mux> SamB: do you know of some good HXT tuto ?
12:56:43 <mux> or some sample source code ?
12:56:52 <SamB> well, it comes with some examples
12:57:02 <mux> ah, cool, will look at those then
12:57:12 <SamB> I think it is lacking in tutorials
12:59:00 <SamB> I think it may have rather more API than is good for it, too...
12:59:05 <SamB> but I'm not sure
13:01:26 <mux> bah, I need the HTTP-any package
13:02:29 <mux> ?hoogle http-any
13:02:29 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-any'
13:02:35 <mux> ?hoogle http any
13:02:36 <lambdabot> Did you mean: Http Any
13:02:36 <lambdabot> Prelude.undefined :: a
13:02:36 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
13:02:49 <mux> ?hoogle Http Any
13:02:50 <lambdabot> No matches, try a more general search
13:03:45 <SamB> hoogle doesn't find you modules
13:04:07 <SamB> @where http
13:04:07 <lambdabot> http://www.haskell.org/http/
13:04:12 <SamB> try that ;-)
13:04:33 <SamB> there are two different versions, with different dependencies, I think...
13:04:52 <mux> ok
13:05:47 <mux> yeah that's it
13:05:52 <SamB> oh, and it used up maybe 400 megabytes trying to parse the gamelist
13:06:01 <SamB> so I think we really need some packed string support soon!
13:06:07 <Dino_> Hello.
13:06:25 <Cale> hi
13:06:27 <SamB> maybe some interning
13:07:04 <Cale> SamB: this is the monopd client?
13:07:14 <SamB> Cale: no!
13:07:28 <SamB> mux is trying to parse the gamelist from MAME
13:07:28 <Cale> which game list?
13:07:31 <Cale> oh
13:07:37 * mux grins evilly
13:07:41 <SamB> which is *WAAAAAY* longer than any I will encounter
13:08:00 <Dino_> I'm having a lot of trouble as a Haskell beginner. In particular trying to, say, print a [IO Int] from inside main's do block.
13:08:02 <mux> if it ain't fun, it ain't worth it :-)
13:08:17 <SamB> Dino_: don't try to do that
13:08:22 <Cale> Dino_: well, actions aren't printable, but you could run them and print the results
13:08:25 <SamB> Dino_: how did you get a list like that?
13:08:36 <SamB> did you... use map?
13:08:37 <Dino_> Ok, so I need to go back further.
13:08:43 <Cale> Dino_: sequence :: [IO a] -> IO [a]
13:08:44 <SamB> try mapM instead ;-)
13:08:50 <mux> gah
13:09:05 <Cale> mapM :: (a -> IO b) -> [a] -> IO [b]
13:09:13 <mux> now HXT configured passed but the build fails cause it's not finding Network.Browser
13:09:15 <Cale> (Ignoring the more general monadic case :)
13:09:21 <Dino_> Spent 3 weeks with a lot of the docs and tutorials out there. And just to see how well I'm learning things, tried to write a program that will print out a list of 10 random numbers.
13:09:33 <SamB> mux: oh?
13:09:36 <Cale> ah, okay
13:09:44 <mux> SamB: yeah.
13:09:50 <mux> ?hoogle Network.Browser
13:09:51 <lambdabot> No matches, try a more general search
13:09:54 <mux> grr!
13:10:00 <mux> @karma-- lambdabot 
13:10:01 <lambdabot> lambdabot's karma lowered to 14.
13:10:05 <mux> :-)
13:10:21 <Cale> Dino_: sure, that's not so bad -- I take it you found the System.Random library?
13:10:28 <SamB> stoop trying to hoogle modules not included in fptools!
13:10:40 <SamB> @where Network.Browser
13:10:40 <lambdabot> I know nothing about network.browser.
13:10:48 <SamB> @google "Network.Browser"
13:10:50 <lambdabot> http://www.vmobilesoftware.com/NetworkBrowser.htm
13:10:53 <Cale> hehe
13:10:57 <SamB> @google "Network.Browser" haskell
13:10:58 <mux> SamB: the HTTP package you gave me provides Network.Stream, Network.TCP and Network.HTTP but not Network.Browser
13:10:59 <lambdabot> http://people.ubuntulinux.org/~scott/patches/haskell-http/haskell-http_0.4.20050430-1ubuntu2_unknown.patch
13:11:02 <xerox> @where http
13:11:03 <lambdabot> http://www.haskell.org/http/
13:11:06 <Dino_> Cale: Yes, and wrote something to generate a single number like: getStdRandom( randomR( 0, 9 ) )
13:11:06 <xerox> There.
13:11:15 <SamB> xerox: maybe he downloaded the wrong version?
13:11:17 <mux> hrm, people.ubuntulinux.org
13:11:21 <Cale> Dino_: one thing you could use is replicateM
13:11:26 <Cale> It's in Control.Monad
13:11:30 <mux> yeah, I used www.haskell.org/http
13:11:35 <mux> it doesn't provide Network.Browser
13:12:36 <Cale> If x is an action, and n is an integer, then (replicateM n x) is the action which runs x repeatedly n times, and collects a list of results.
13:12:55 <Cale> You could probably write it yourself as an exercise
13:13:09 <SamB> huh
13:13:49 <SamB> @google "network-bundle" haskell
13:13:50 <lambdabot> http://www.eternalinfantry.com/VideoGamesReviews/video-game-sale.html
13:13:53 <SamB> hmm
13:14:02 <SamB> @google "http-bundle" haskell
13:14:03 <lambdabot> http://wiki.loria.fr/wiki/GenI/ScratchPad
13:14:08 <Cale> google is not happening for SamB
13:14:14 <SamB> @google "http-bundle"
13:14:16 <lambdabot> http://oscar-osgi.sourceforge.net/repo/http/
13:14:21 <SamB> hmm
13:15:06 <SamB> supposedly, you can download it at http://haskell.org/http!
13:15:08 <Dino_> Now, are you saying replicateM for doing output back to the real world? Or to gather up the list of numbers?
13:15:20 <mux> supposedly :)
13:15:21 <SamB> or maybe not...
13:15:25 * SamB is confused.
13:15:26 <Cale> to get a list of numbers
13:15:45 <Cale> you could use it to do the output at the same time if you'd like
13:15:46 <Dino_> It seems like there's a difficult barrier when the IO stuff is involved. I guess this is really the thing that a lot of beginners experience.
13:15:52 <Cale> yeah
13:16:04 <Cale> It takes a little getting used to
13:16:05 <mux> @google "Network.Browser" haskell package
13:16:07 <lambdabot> http://packages.debian.org/cgi-bin/search_contents.pl?searchmode=filelist&word=libghc6-http-dev&version=unstable&arch=ia64
13:16:15 <Cale> once you know some of the library functions available, it's not so bad
13:16:17 <Dino_> And I get a lot of the theory from reading. Or I think I do. How IO isn't truly functional.
13:16:36 <Dino_> But I think I don't really get it in some zen-like sense yet.
13:16:44 <Cale> It's simultaneously purely functional and not, depending on how you look at it.
13:17:12 <Cale> If you think of >> and >>= as acting on IO actions, and think of IO actions as these inert values, then it's purely functional.
13:17:55 <SamB> but, it lets you write code that ends up doing some very impure kinds of things
13:18:18 <mux> @google "Network/Browser.hs"
13:18:20 <lambdabot> http://www.ninebynine.org/Software/HaskellUtils/Network/Browser.hs
13:18:24 <Cale> You're just combining these IO action values. randomRIO is a pure function which takes a pair, and gives the same IO action every time
13:18:25 <Dino_> Ok. But it seems like types mismatch is what I get out of things constantly. Which is maybe where the library functions come into this.
13:18:45 <Cale> but on the other hand, if you look inside those actions, they're doing plenty of imperative, impure things
13:18:51 <mux> yeah
13:19:04 <Cale> okay
13:19:05 <mux> type mismatches in Haskell are the sames as those pesky crashes fixed in 5s in C
13:19:10 <mux> :-)
13:19:25 <Cale> Dino_: Do you know how to use the do notation?
13:19:25 <mux> except of course they happen at build-time
13:19:28 <SamB> @google "http-bundle.tgz"
13:19:29 <lambdabot> No Result Found.
13:19:33 <SamB> aww!
13:19:40 <SamB> I definately have one!
13:19:44 <Cale> well, it seems you do, if you can print one random number :)
13:19:46 <Dino_> Hm, not sure what you mean about the randomRIO giving the same IO action everuy time.
13:20:04 <Dino_> Cale: Yes, I'm doing most of this from main's do block.
13:20:10 <Cale> Dino_: well, it takes a pair of type (a,a), and gives you an IO a
13:20:23 <Dino_> And I get what do is for, sequencing things.
13:20:25 <Cale> an IO a is like a program whose output is a value of type a
13:20:38 <SamB> Cale: is, in fact!
13:20:55 <mux> SamB: looks like Network.Browser is only in the  "old" version of the package
13:21:03 <Cale> so randomRIO gives you the same program for the same pair every time
13:21:03 <SamB> mux: interesting!
13:21:12 <Cale> so it's referentially transparent in that sense
13:21:14 <SamB> mux: and you downloaded HXT 5.5?
13:21:19 * SamB has 5.3
13:21:26 <mux> yes
13:21:31 <Cale> but the actual value of type a which the program gives you changes
13:21:34 <mux> I grabbed 5.5
13:21:39 <SamB> however, I do have Network.Browser
13:21:48 <SamB> and I suspect that 5.3 also uses it ;-)
13:21:54 <Dino_> But it's not the same actual value of type a every time, which is different than the strictly functional everywhere else.
13:21:59 <Cale> (but that's okay, because it's happening in IO, the effects are contained in this other language of sorts)
13:22:13 <mux> SamB: can you tell me from what package of your system this file comes from?
13:22:21 <Cale> The thing is, there's no function of type  IO a -> a
13:22:34 <SamB> Loading package HTTP-2005.5.5 ... linking ... done.
13:23:12 <Cale> (that's kind of a lie, there is a way to hack the runtime system, but that's for when you really know what you're doing :)
13:23:29 <Dino_> Yeah, I get that it works this way for good reason.
13:24:01 <Cale> so really, all you can do from Haskell is to form new IO programs from the ones you already have, and the combining functions
13:24:25 <Cale> >>= is the important one which is behind the do-syntax
13:24:52 <mux> hah!
13:25:08 <mux> SamB: the http tarball, has two setup files and two .cabal files :)
13:25:15 <SamB> ahaha
13:25:20 <SamB> er, ahah
13:25:32 <Cale> If x is an action, and f is a function from possible results of that action to future actions, x >>= f is the action which when run, will run x, then pass the result off to f, and then run the result of that.
13:25:42 <Dino_> From earlier, I'm not sure I get how IO [Int] and [IO Int] are different.
13:25:51 <mux> yet another port I'll need to add to FreeBSD
13:26:11 <Cale> a value of type IO [Int] is a single action which when run will produce a list of Ints
13:26:13 <SamB> well, you can't convert IO [Int] into [IO Int] very well...
13:26:32 <Cale> a value of type [IO Int] is a list of actions, each of which when run will produce an Int
13:26:39 <SamB> @djinn IO [Int] -> [IO Int]
13:26:39 <lambdabot> -- f cannot be realized.
13:26:42 <SamB> aww
13:26:55 <Cale> djinn doesn't know about IO anyway ;)
13:26:57 <SamB> I didn't want to have to do my *own* bad job of that
13:27:03 <Cale> (or lists for that matter :)
13:27:11 <SamB> well, okay, so...
13:27:14 <SamB> why would it have to?
13:27:17 <norpan> map return
13:27:20 <Cale> but you can convert
13:27:42 <norpan> fmap if you will
13:27:51 <SamB> I'
13:27:56 <Cale> er, no you can't quite
13:28:02 <SamB> m sure you can 
13:28:08 <Cale> [do vs <- x; return (vs !! k) | k <- [0..]]
13:28:15 <Cale> that's the best you can do in that direction
13:28:16 <SamB> but it wouldn't do anything particularly useful!
13:28:19 <int-e> @type liftM (map return)
13:28:20 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *).
13:28:20 <lambdabot>         (Monad m1, Monad m) =>
13:28:20 <lambdabot>         m1 [a] -> m1 [m a]
13:28:32 <Cale> but some of the actions you get will be unhelpful
13:28:49 <norpan> IO [Int] can't be converted to [IO Int] for obvious reasons (encapsulation)
13:29:03 <norpan> the other way around is possible
13:29:06 <Cale> It can be, and I just showed how, but not in the way you might like it to.
13:29:14 <int-e> yep. IO [Int] -> IO [IO Int] is possible (although not very useful)
13:29:19 <Dino_> Ok, but I think that me even trying to do anything with [IO Int] in this case is a barking up wrong tree situation.
13:29:36 <SamB> @type replicateM (liftM head)
13:29:37 <lambdabot>   Couldn't match `Int' against `t -> t1'
13:29:37 <lambdabot>   Expected type: Int
13:29:38 <Cale> sequence :: [IO Int] -> IO [Int]
13:29:52 <int-e> okay, the result list will have little to do with the list inside the IO.
13:29:53 <SamB> @type repeatM (liftM head)
13:29:53 <lambdabot> Not in scope: `repeatM'
13:29:56 <SamB> aww
13:30:03 <SamB> @type replicateM 10 (liftM head)
13:30:04 <lambdabot> forall (m :: * -> *) a.
13:30:04 <lambdabot>           (Monad m) =>
13:30:04 <lambdabot>           m [a] -> [m a]
13:30:05 <Cale> well, more specifically,  sequence :: (Monad m) => [m a] -> m [a]
13:30:24 <SamB> that is actually more general, silly
13:30:28 <Cale> Let's write sequence
13:30:40 <Cale> I think that will be illustrative
13:30:49 <Cale> sequence [] = ...
13:31:01 <Cale> what should we do if we have the empty list of actions?
13:31:09 <SamB> nothing!
13:31:28 <Dino_> Return IO () ?
13:31:36 <Dino_> Er, evaluate to IO ()
13:31:36 <norpan> look at the type
13:31:39 <davidhouse> Dino_: not quite
13:31:42 <SamB> that is a type
13:31:45 <davidhouse> we need to return a m [a]
13:31:45 <Cale> Well, we should give the action which returns an empty list of results.
13:32:01 <Cale> return :: a -> m a
13:32:10 <SamB> sequence [] = return []
13:32:27 <SamB> reasonable enough for you?
13:32:28 <Dino_> Actually the return statement has also been confusing.
13:32:34 <Cale> it's not a statement
13:32:37 <SamB> it isn't a statement, it is just a function
13:32:38 <Cale> just an ordinary function
13:32:41 <davidhouse> return throws a value into a monad.
13:32:51 <SamB> davidhouse: no,no,no
13:33:01 <SamB> that is MonadError you are thinking of!
13:33:04 <Cale> We're in action-speak :)
13:33:18 <Cale> It takes a value, and returns the action which does nothing, and returns that value every time.
13:33:31 <davidhouse> okay, action-speak.
13:33:42 <SamB> "injects", davidhouse 
13:33:49 <Cale> So, for instance,  return 5  is the IO action which does no IO, and returns 5.
13:34:02 <Cale> when it's run, that is
13:34:33 <Cale> so, return [] is the IO action, which does no IO and returns the empty list
13:34:38 <Dino_> Does that mean, in a do block, you could:  foo <- return 5
13:34:42 <Cale> yep
13:34:54 <davidhouse> Dino_: yep, and that's _precisely_ the same as let foo = 5
13:34:58 <SamB> but why bother, when you can write let foo = 5
13:35:01 <Dino_> Is it used for wrapping non-action things?
13:35:08 <SamB> yes!
13:35:09 <Cale> davidhouse: modulo some details about polymorphism
13:35:44 <Cale> okay
13:35:54 <Cale> so how about  sequence (x:xs)
13:36:02 <mux> bah, it seems crypto-1.2.2 is broken with current GHC
13:36:20 <Cale> we're thinking recursively here of course :)
13:36:27 <SamB> mux: probably not too hard to fix
13:36:35 <Cale> what should the resulting action do?
13:36:43 <SamB> well, first, it should do
13:36:45 <SamB> x
13:36:48 <Dino_> Wait, what Sam said, why not just use let?
13:37:13 <davidhouse> Dino_: he was refering to your foo <- return 5 thing
13:37:23 <SamB> Dino_: because usually you use return to return something back to something else
13:37:29 <davidhouse> as that's the same as let foo = 5, we tend to just use the let one.
13:38:01 <Dino_> Ok. I don't think I'm getting when you would use return, but that's ok for now.
13:38:02 <Cale> also, let allows for defining polymorphic values, and foo <- return ... doesn't.
13:38:10 <Cale> okay, consider this
13:38:20 <Cale> getTwoLines = do
13:38:23 <Cale>    x <- getLine
13:38:26 <Cale>    y <- getLine
13:38:29 <Cale>    return (x,y)
13:38:59 <Dino_> Ok, this hasn't come up yet with me stuffing everything into main's do block. I see now.
13:39:05 <Cale> right
13:39:11 <mux> SamB: I think the FreeBSD port is just being stupid
13:39:25 <Dino_> btw, is that returning a two-value tuple there?
13:39:29 <Cale> yeah
13:39:39 <Cale> It'll be a pair with two strings
13:39:48 <Cale> getTwoLines :: IO (String, String)
13:39:50 <norpan> gah, stupid am notation, 12 am, that's midnight, right?
13:39:54 <SamB> the best kind of tuple there is ;-)
13:40:02 <Dino_> Ok, so what's.. that's what I was just about to ask, the actual return type.
13:40:06 <SamB> yeah, 12 am is midnight...
13:40:10 <SamB> it *is* wierd
13:40:29 <Cale> 12 = 0 ;)
13:40:49 <SamB> only modulo 12!
13:41:13 <Cale> okay
13:41:36 <Cale> so back to sequence (x:xs), we want it to run all the actions in the list in turn, and return a list of all the results
13:41:50 <mux> SamB: actually, it seems the package.conf of crypto just needs to be changed
13:42:06 <Cale> so how to do this?
13:42:22 <Cale> Dino_: would you like to take a shot at it, or should I just give it away?
13:42:29 <Dino_> We had gone over the end condition: sequence [] = []
13:42:34 <Cale> right
13:42:34 <mux> right now, ghc-pkg -a complains about "no colon after field name"
13:42:41 <Cale> er
13:42:46 <Cale> sequence [] = return []
13:43:02 <Dino_> ok
13:43:41 <Dino_> I'm not sure of the notation for executing the action x and being able to call sequence with xs.
13:43:58 <Cale> this means that if we want to use sequence xs as an action when defining sequence (x:xs), we're okay
13:44:18 <Dino_> sequence (x:xs) = <magic occurs with x> sequence xs
13:44:33 <Cale> hehe, yeah, basically
13:44:37 <Cale> sequence (x:xs) = do
13:44:37 <SamB> how about we start with y <- x?
13:44:40 <Cale>    v <- x
13:44:52 <Cale> that's how it starts
13:45:15 <SamB>    vs <- sequence xs
13:45:39 <SamB> now, guess!
13:46:04 <SamB> what is the next line?
13:46:15 <Dino_> Ok, I get that part, drawn from <- to execute the first.
13:46:20 <Cale> right
13:46:48 <Cale> so now we have the result of x (which is a single value) and the result of sequence xs (which is a list)
13:47:11 <Dino_> Maybe return (v : sequence xs)
13:47:47 <Cale> return (v:vs)
13:48:02 <Cale> We had  vs <- sequence xs
13:48:05 <Dino_> Ok, I missed the vs line. Got it.
13:48:11 <Cale> (SamB wrote that, yeah)
13:48:29 <SamB> @type \v xs -> return (v : sequence xs)
13:48:30 <lambdabot> forall (m :: * -> *) a.
13:48:30 <lambdabot>              (Monad m) =>
13:48:30 <lambdabot>              [a] -> [[a]] -> m [[a]]
13:48:43 <Cale> sequence is used to build lots of good functions for working with actions
13:48:48 <Cale> for example,
13:48:48 <Dino_> Now, that >>= notation would also work for this, but perhaps less clear notation-wise for now.
13:48:54 <Cale> yeah
13:48:58 <Cale> to translate,
13:49:04 <Cale> sequence [] = return []
13:49:22 <SamB> next, we should maybe look at the definition for liftM2 ?
13:49:25 <Cale> sequence (x:xs) = x >>= \v -> sequence xs >>= \vs -> return (v:vs)
13:49:28 <SamB> or the naive version...
13:49:40 <Cale> what about just liftM?
13:49:57 <Cale> or I was thinking of mapM, actually, since we can use sequence :)
13:50:16 <SamB> well, I was thinking it might look nicer if we could say:
13:50:34 <mux> should I use Crypto 3.0.3 ?
13:50:42 <SamB> sequence (x:xs) = liftM2 (:) x (sequence xs)
13:51:01 <SamB> mux: I have no idea! my package included the needed cryto modules!
13:51:13 <Cale> okay
13:51:23 <SamB> it was the version for people who don't need all the other modules in Crypto and HTTP
13:51:50 <SamB> in fact, it might have been on the HXT site!
13:52:00 <mux> this one is actually more recent I should use it it seems
13:52:08 <mux> bah, NewBinary now
13:52:16 <mux> @google NewBinary haskell module
13:52:18 <lambdabot> http://www.haskell.org/http/
13:53:01 <mux> ah okay, that's the bundle you told me about
13:53:17 <Cale> Dino_: as you can perhaps reason from what SamB said, liftM2 f x y will run x and y, and then return the value of f applied to their results
13:53:24 <mux> but since I started, I'll finish by hand
13:54:13 <lispy> @type Control.Monad.join
13:54:14 <lambdabot> forall a (m :: * -> *).
13:54:14 <lambdabot>         (Monad m) =>
13:54:14 <lambdabot>         m (m a) -> m a
13:54:22 <lispy> @type Control.Monad.liftM2
13:54:22 <lambdabot> forall r (m :: * -> *) a2 a1.
13:54:23 <lambdabot>         (Monad m) =>
13:54:23 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:55:01 <bringert> mux: did you find Network.Browser?
13:55:06 <lispy> > join [[1]]
13:55:07 <lambdabot>  [1]
13:55:23 <bringert> mux: it's at http://haskell.org/http/ anyway
13:55:25 <mux> bringert: yup,
13:55:36 <mux> bringert: there are actually two packages in the http tarball, that's why
13:55:39 <davidhouse> lispy, for [], join = concat
13:55:41 <mux> I didn't see that browser subdir
13:55:45 <bringert> mux: ah, yes
13:55:59 <Dino_> Ok. Not sure what I could use it for.
13:56:06 <lispy> davidhouse: okay
13:56:11 <lispy> @type sequence
13:56:12 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:56:21 <bringert> mux: maybe the docs should be more clear about that
13:56:48 <Cale> Dino_: well, it makes writing the recursive case for sequence quite pretty
13:57:02 <Cale> Dino_: but let's go to a much more commonly used function, which is mapM
13:57:03 <Dino_> Shorter form of what we built? Can supply any function there, not just the (:) cons
13:57:07 <Cale> yeah
13:57:26 <Cale> liftM2 f x y = do
13:57:30 <Dino_> There's a mapM separate from map because of monads?
13:57:34 <Cale>    vx <- x
13:57:39 <Cale>    vy <- y
13:57:45 <Cale>    return (f vx vy)
13:57:59 <Cale> yeah, well, mapM is built from map and sequence
13:58:30 <Cale> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
13:58:56 <Cale> See if you can work out, just from the type, what it would have to do.
13:59:37 <Dino_> Hm. Having trouble reading that. But in the case of what we've been talking about, this guy could return our IO [b]
13:59:46 <Cale> yeah
13:59:47 <mux> bringert: I'd say the problem is that the HTTP module lacks an explicit dependency on Browser
13:59:57 <Cale> mapM f xs
14:00:07 <mux> bringert: the rest is okay
14:00:10 <Cale> first maps f over xs
14:00:20 <bringert> mux: there shouldn't be one. Browser depends on HTTP, not vice versa
14:00:22 <Cale> which results in a list of type [m b]
14:00:30 <Cale> then applies sequence
14:00:33 <mux> arrg, what the
14:00:36 <Cale> to get an m [b]
14:00:38 <mux> I still don't have Network.Browser
14:00:54 <Cale> to write that in code,  mapM f xs = sequence (map f xs)
14:01:05 <Cale> or,  mapM f = sequence . map f
14:01:14 <mux> bringert: HTTP wants Network.Browser.  but it seems Browser doesn't provide Network.Browser actually
14:01:17 <mux> so I'm lost now
14:01:54 <bringert> mux: i'm the maintainer, I'll have a look at it, maybe I messed up somewhere
14:01:55 <Dino_> Ok, so the f here is (a -> m b)
14:02:41 <Cale> yep
14:03:30 <Cale> mux: Network.Browser is in the http package. http://www.haskell.org/http/
14:03:34 <mux> bringert: apparently Network.Browser needs to be added to exwposed modules
14:03:41 <mux> Cale: yes, but it doesn't get installed :-)
14:03:44 <Cale> oh
14:03:47 <mux> bringert: in the cabal file
14:03:50 <mux> bringert: testing that now
14:04:46 <mux> bringert: heh, I have an error that it couldn't find Codec.Utils now that it's building Network.Browser
14:05:09 <bringert> mux: where did you get the code you're compiling?
14:05:18 <Cale> Dino_: so that makes sense?
14:05:24 <Dino_> It is making sense. yes.
14:05:32 <mux> www.haskell.org/http/, the http-20060423 tarball
14:05:40 <bringert> in the http://haskell.org/http/download/http-20060423.tar.gz tarball, browser.cabal has Network.Browser in Exposed-modules
14:05:49 <mux> uh
14:05:57 <bringert> at least in the copy I just downloaded :-)
14:06:07 <bringert> or did ou add it to http.cabal?
14:06:09 <mux> I was looking at http.cabal
14:06:11 <mux> yes
14:06:25 <bringert> ok, so install the HTTP package first, then the browser package
14:06:29 <mux> I see it indeed in browser.cabal
14:06:37 <mux> but I installed it
14:06:47 <mux> and in that order fwiw :-)
14:06:50 <mux> let me re-try it
14:07:04 <mux> ghc-pkg list shows Browser
14:08:13 <Cale> Dino_: the replicateM I mentioned ealier is similar
14:08:22 <bringert> mux: try removing the http and browser packages (ghc-pkg unregister), get a fresh code of the tarball and start over, following the instructions in the README
14:08:35 <bringert> just to be sure
14:08:44 <mux> bringert: just redid it, it didn't install Browser.hi in ghc-6.4.2/imports/Network
14:08:52 <Dino_> So, where I was having trouble so far with show not wanting to take things of IO *, these things can sort-of process them into something.
14:08:54 <mux> but did install the browser lib
14:08:57 <bringert> mux: weird
14:09:34 <mux> no
14:09:39 <mux> I have it in another directory
14:09:44 <mux> why can't GHC see it then
14:10:28 <mux> package.conf points to the correct directory
14:10:32 * mux scratches head
14:11:03 <bringert> mux: did you use "-package Browser"?
14:11:33 <mux> bringert: it's HXT, I was going to try to add it
14:11:39 <Dino_> This was very helpful. I will keep at it and look at these functions.
14:11:55 <Dino_> Thank you very much. I appreciate it.
14:12:19 <mux> cool! finally, that did the trick
14:12:28 <mux> I just added -package Browser in ghc-options of hxt.cabal
14:13:01 <bringert> shouldn't that be "Build-depends: Browser"?
14:13:19 <mux> I take your word on it
14:15:11 <mux> yes, that seems to work too, and is of course better
14:15:19 <Dino_> So, return exists entirely for monadic things?
14:15:19 <mux> I'll send a mail to the HXT maintainer then
14:16:03 <mux> and will update FreeBSD port hs-crypto to 3.0.3, and will add hs-newbinary, hs-http, hs-browser and hs-hxt!
14:16:14 <bringert> mux: great!
14:17:13 <Cale> Dino_: yep
14:17:47 <Cale> It just turns a value of type t to a value of type m t, for any given monad m.
14:24:44 <Dino_> It seems like there's something of a chicken-and-egg situation with this stuff. I need IO with the outside world to try things and learn, but doing that IO isn't trivial at first.
14:26:09 <ihope> If you just use IO enough, you'll think, "sheesh, why the heck didn't I understand it before?"
14:28:26 <Cale> Dino_: well, you can avoid doing a lot of IO by just using ghci as an interface for your programs, though eventually, it's good to polish them up.
14:29:04 <Cale> I suppose it depends on what sorts of programs you're writing
14:29:19 <SamB> readFile is also nice, of course ;-)
14:29:23 <SamB> @type readFile
14:29:24 <lambdabot> FilePath -> IO String
14:32:12 <Dino_> Thanks again. Great stuff.
14:32:47 <yip> ping dcoutts 
14:32:57 <dcoutts> @yarrr!
14:32:57 <lambdabot> Unknown command, try @list
14:32:59 <dcoutts> @yarr!
14:33:00 <lambdabot> Aye
14:33:14 <yip> dcoutts: i can use pango without cairo or gtk, right?
14:33:56 <SamB> dcoutts: are you a happy expert?
14:34:28 <dcoutts> yip, you can use one without the other but you can't build them seperately
14:34:59 <dcoutts> yip, and i'm not sure what othe surface you could draw pango text to appart from a gdk window or cairo surface
14:35:07 <dcoutts> yip, what are you trying to do?
14:35:13 <dcoutts> SamB, only somewhat
14:35:35 <SamB> well, I can't figure out why my parser isn't parsing "start = foo"
14:36:07 * SamB hits the beginning of his history
14:36:12 <dcoutts> ugg, debugging parsers is a pita
14:36:23 <SamB> darcs get http://naesten.dyndns.org:8080/repos/HXT-RelaxNG-Compact
14:36:34 <SamB> yes it is!
14:36:53 <SamB> I really don't understand the output from a -d parser! even with -i!
14:36:59 <yip> dcoutts: i mean like: giving pango a complicated unicode string with a mix of left-to-right and right-to-left, and finding out the physical order that the glyphs should be rendered in
14:37:03 * mux notes HXT doesn't seem much happier than HaXml with a 25MB XML file
14:37:09 <davidhouse> dcoutts, my comment earlier: we need to rewrite the haskell dogma: "it works once it typechecks, unless you're using Parsec"
14:37:11 <SamB> mux: yeah
14:37:20 <mux> 28738 mux           1 -20    0   847M   717M swread   0:45  1.56% ParseExample
14:37:24 <dcoutts> davidhouse, heh, same for happy
14:37:34 <dcoutts> yip, I see, yes that should be possible
14:37:55 <SamB> happy doesn't even give as good feedback!
14:40:11 <SamB> am I carelessly missing productions?
14:40:19 <SamB> have I recursed the wrong way?
14:41:28 <dcoutts> doesn't matter which way you recurse so much with a parser generator
14:41:35 <dcoutts> it only changes the effeciency
14:41:50 <yip> dcoutts: would it be possible to use pango with my own renderer?
14:41:52 <SamB> I tend to think of blowing the stack as a problem ;-)
14:42:01 <SamB> but, good point
14:42:08 <SamB> that won't cause a misparse so subtly
14:42:25 <SamB> it would just ... blow the stack!
14:42:30 <dcoutts> yip, possibly, pago will give you precise layout information for the font you tell it to use
14:42:51 <dcoutts> yip, but making pango do the rendering would be much easier, and it does most languages pretty well
14:43:45 <SamB> oh, looks like I forgot the base case in grammar_
14:43:49 <SamB> maybe that is the problem
14:44:25 <davidhouse> so what are the merits/drawbacks of happy compared to parsec?
14:44:34 <dcoutts> happy is faster
14:44:40 <SamB> it goes more nicely with Alex, as well
14:44:46 <dcoutts> happy tells you when your gramar is ambiguous
14:45:02 <SamB> oh, thats nice ;-)
14:45:04 <yip> String really works with unicode ok?
14:45:11 <SamB> String does fine
14:45:19 <SamB> IO functions...
14:45:19 <yip> what about "length" function?
14:45:22 <SamB> not so well
14:45:27 <SamB> yeah, length is fine.
14:45:32 <SamB> String = [Char]
14:45:46 <SamB> Char supports unicode
14:45:59 <SamB> (by virtue of having to be that big anyways)
14:46:08 <yip> a Char value can contain a multi-byte unicode character value?
14:46:15 <SamB> (due to alignment and such)
14:46:32 <SamB> it is typically 32-bits
14:46:46 <SamB> I'm not sure what the report says about it
14:47:09 <yip> hm... it's 32 bits? interesting
14:48:06 <SamB> well, you see, a Char is heap allocated anyway
14:49:20 <SamB> so it doesn't really take any more space to have it be 32-bit rather than 8-bit or 16-bit, on a 32-bit system
14:49:29 <SamB> and Haskell is a bit much for a 16-bit system ;-)
14:50:12 <yip> i guess this sort of makes sense, so String is definetly not implemented as an array then
14:50:18 <dcoutts> now Data.ByteString uses bytes, there's also a utf8 version in the works and I suppose someone should do a usc4 version
14:50:18 <SamB> no!
14:50:34 <SamB> ucs4, that is
14:51:34 <SamB> I think they just threw Unicode in because it wouldn't really cost anything ;-)
14:52:22 <yip> dcoutts: pango can't render justified paragraphs? :O
14:53:02 <SamB> yip: it can't"
14:53:06 <SamB> s/"/?/
14:53:35 <yip> that's what the docs say\
14:54:36 <dcoutts> yip, really? I thought it could.
14:55:01 <dcoutts> I'm sure it has that options somewhere, perhaps it's just not implemented even if its in the api
14:55:25 <yip> yeah it's in the api but the docs say that it's not implemented
14:56:10 <dcoutts> ho hum
14:57:23 <SamB> oh great!
14:57:32 <SamB> I've got a reduce/reduce conflict!
14:58:30 <davidhouse> SamB: a what now?
14:58:58 <SamB> something to do with Happy
15:02:18 <sethk> reduce/reduce conflict is a standard thing with lex/yacc parsers
15:02:29 <sethk> reduce/reduce represents an ambiguity that must be resolved
15:02:41 <sethk> shift/reduce is generally ok as long as the default (shift) is what you want
15:02:45 <syntaxfree> what is a lex/yacc parser?
15:03:11 <sethk> syntaxfree, more properly I guess is to say a parser using BNF input
15:03:26 <sethk> syntaxfree, of which the most common are UNIX lex/yacc (and the gnu equivs flex/bison)
15:03:48 <sethk> the input to happy is very similar to what is used as input to yacc
15:03:50 <syntaxfree> BNF is like a general language for describing languge syntax, right?
15:04:01 <syntaxfree> (or is it a general language for describing semantics?)
15:04:03 <SamB> but everyone still says "lex/yacc"
15:04:08 <mwc> yeah, but it's more a language in the sense that Pseudocode is a lang
15:04:19 <yaarg> context-free grammers yup
15:04:25 <SamB> well, it is more formal than psuedocode
15:04:31 <syntaxfree> not a compileable language. But does it specify semantics as well?
15:04:42 <SamB> but usually specs leave out the part that goes in {}
15:04:48 * SamB has a spec that does not
15:04:57 * SamB didn't write it, though
15:05:17 <sethk> syntaxfree, well, it is compilable.  yacc means "yet another compiler compiler"
15:05:46 <sethk> syntaxfree, but as the name suggests it is used to create parsers that are part of a more general language compiler
15:05:52 <SamB> most BNFs in specs don't specify semantics
15:06:27 <SamB> (or even ASTs!)
15:07:01 <sethk> SamB, that's mostly true, although there is usually semantic stuff hidden in the processing functions attached to the syntax constructs
15:07:10 <sethk> SamB, but they aren't part of the BNF input
15:08:00 <SamB> sethk: I said "in specs"
15:08:23 <sethk> SamB, true
15:08:37 <sethk> SamB, but not true
15:08:50 <sethk> SamB, because the processing functions appear interspersed with the syntax notation
15:09:06 * SamB didn't mean .y files...
15:09:08 <sethk> SamB, so, while it's not part of the BNF, exactly, it _is_ part of the yacc (or happy or whatever) input
15:09:29 <sethk> SamB, ok, then,
15:09:35 <sethk> SamB, what I was talking about is part of the .y file
15:09:44 <SamB> yes, I know ;-)
15:09:47 <sethk> SamB, but the .y file is the only input that yacc (or happy or whatever) has
15:09:55 <sethk> SamB, there is no other syntax specification
15:10:33 <SamB> I meant, a lot of specifications for programming languages and the like use BNF or a variant, but leave out the code snippets!
15:11:14 <SamB> this one doesn't, though: http://www.oasis-open.org/committees/relax-ng/compact-20021121.html#formal-syntax
15:11:21 <sethk> SamB, I suppose, but those aren't exactly real.  :)
15:11:51 <febuiles> Umm, in a quick explanation, what does the $ operator?
15:12:02 <febuiles> what does it do*
15:12:08 <SamB> I bet you could compile it if you were a very smart but very silly person...
15:12:32 <sethk> febuiles, essentially forces everything to the right of it to associate
15:12:45 <febuiles> sethk, thank you :D
15:12:45 <sethk> febuiles, if you have, say,  putStrLn "abc" ++ "def"   that's wrong
15:13:11 <sethk> febuiles, because what you mean is   putStrLn ("abc" ++ "def")   which you can also write as   putStrLn $ "abc" ++ "def"
15:13:41 <febuiles> sethk, why would you use it in: A (subst t1 v st) $ (subst t2 v st) then, its already associated, isnt it?
15:13:49 <febuiles> subst (A t1 t2) v st = A (subst t1 v st) $ (subst t2 v st) *
15:14:22 <sethk> febuiles, without the $ it is    (A (subst t1 v st)) (subst t2 v st)
15:14:50 <sethk> I think I did that right  :)
15:15:09 <sethk> I left out the *
15:15:16 <febuiles> no, that was mine :D
15:15:37 <sethk> febuiles, I think you get the idea even if I sort of fat fingered it  :)
15:15:52 <febuiles> haha, yes, thank you
15:16:35 <febuiles> actually, wouldnt it be  (A (subst t1 v st) (subst t2 v st)) if its a constructor?
15:17:03 <sethk> febuiles, yes, assuming the constructor takes two arguments
15:17:36 <febuiles> ok, thanks
15:17:51 <sethk> febuiles, putting in an unnecessary $ doesn't cause problems
15:18:57 <febuiles> sethk, I was just wondering, checking someone else's  source code and I hadnt come up with the $ yet.
15:29:22 <bolrod> /usr/lib/ghc-6.4.1/libHSrts.a(Main.o): In function `main': undefined reference to `__stginit_ZCMain'
15:29:25 <bolrod> /usr/lib/ghc-6.4.1/libHSrts.a(Main.o): In function `main': undefined reference to `ZCMain_main_closure'
15:29:28 <bolrod> collect2: ld returned 1 exit status
15:29:31 <bolrod> is this normal ?
15:29:46 <bolrod> (working with ByteString)
15:30:34 <davidhouse> bolrod: find -name '*.o' -o -name '*.hi' -exec rm {} \;
15:30:47 <davidhouse> then re-make.
15:31:08 <bolrod> already did that
15:31:57 <bolrod> meh >:/
15:32:11 <bolrod> I was trying that shootout program with ByteString just to practice.
15:34:43 <bolrod> ok :/
15:34:48 <bolrod> @pastebin
15:34:48 <lambdabot> Unknown command, try @list
15:34:52 <bolrod> @where paste
15:34:52 <lambdabot> http://paste.lisp.org/new/haskell
15:35:17 <lisppaste2> bolrod pasted "Weird!" at http://paste.lisp.org/display/20730
15:35:28 <bolrod> yo.. davidhouse .  Could you try it?
15:35:58 <SamB> hmm, its kind of a pain to have to list the keywords of a language in 3 different places, typing it in 5 times in all...
15:36:06 <davidhouse> bolrod, hold on
15:36:33 <Cale> bolrod: name your module Main
15:36:40 <bolrod> ;o
15:36:48 <Cale> (the Main module is always called Main)
15:37:00 <bolrod> that might work yes
15:37:15 <SamB> (nevermind where you actually *use* them!)
15:37:18 <davidhouse> Cale, unless you use -main-is
15:37:19 <bolrod> how could I forget -.-
15:37:34 * bolrod slaps bolrod around with a big large trout
15:50:12 <syntaxfree> bolrod: what does that code do?
15:52:26 <SamB> can happy say *what* reduce/reduce conflicts it encountered?
15:53:05 <SamB> oh, nevermind, I forgot to reload...
15:56:50 <dcoutts> @localtime dons
15:56:51 <lambdabot> Local time for dons is Fri Jun  2 08:49:15 2006
15:58:15 <davidhouse> i'm out. night all.
15:58:36 <Cale> haha, #nethack-idlerpg
15:58:59 <Cale> the entire game is seeing how long you can idle
16:03:29 <AtnNn> and you lose points everytime you part or quit
16:03:40 <Excedrin> or talk
16:03:40 <Cale> yeah
16:03:57 <yip> first rule of idlerpg: don't talk about idlerpg
16:04:05 <BCoppens> @localtime BCoppens
16:04:06 <lambdabot> Local time for BCoppens is Fri Jun 2 01:03:47 2006
16:04:09 <AtnNn> lol yip
16:04:12 <BCoppens> nice =)
16:16:44 <SamB> hmm, after I get my RELAX NG Compact parser to parse this schema for RELAX NG, I can try to validate the translated schema with itself ;-)
16:17:39 <SamB> (the spec includes a parser that parses RELAX NG Compact schemas and produces the equivalent RELAX NG schemas)
16:18:05 <SamB> unfortunately, though, it is written in a programming language that does not exist :-(
16:18:31 <SamB> a parser-generator language, in fact
16:21:08 <japple> Has anyone used EclipseFP?
16:21:35 <japple> I'd like to know if it can do auto-indent like the haskell emacs mode
16:21:52 <japple> but I'd rather not download and install the beast that is eclispe just to find out
16:22:01 <japple> and I cant find any documentation using google
16:31:08 <syntaxfree> isn't eclipse written in Java?
16:31:25 <Cale> yeah
16:31:37 <syntaxfree> so it uses those god-awful ugly Java GUIs?
16:32:23 <Muad_Dibber> Eclipse uses SWT, which is a custom GUI package
16:32:32 <syntaxfree> umm.
16:32:36 <Muad_Dibber> not the default Swing or AWT package you are used to
16:33:54 <syntaxfree> that nethack-idle game is kinda boring.
16:35:36 <bolrod> bleah
16:36:02 <Cale> syntaxfree: what do you expect for a game where all you do is idle?
16:37:44 <sethk> what's the name of the GTK GUI haskell thing?
16:38:51 <yip> gtk2hs
16:38:59 <yip> it rocks my socks
16:38:59 <sethk> yip, right, thank you
16:40:11 <Muad_Dibber> Theres currently 2 GUI haskell things, right? gtk2hs and wxhaskell?
16:40:19 <mwc> there are a lot of them
16:40:25 <mwc> some dead as far as I can tell
16:40:30 <mwc> fudgets?
16:40:53 <syntaxfree> wxwidgets looks much better than GTK imo.
16:41:02 <yip> gtk is a lot better then wx imo
16:41:06 <Muad_Dibber> hehe
16:41:11 <Muad_Dibber> nonetheless
16:41:19 <mwc> http://www.haskell.org/haskellwiki/Libraries_and_tools/GUI_libraries
16:41:21 <yip> gtk2hs and wxHaskell seem to be the only "production ready" toolkits
16:41:21 <syntaxfree> I haven't programmed in either. 
16:41:35 <syntaxfree> gtk looks foreign in Windows and just pointless in OS X.
16:41:37 <Muad_Dibber> how usefull will it be for a small language like haskell to put effort into maintaining 2 production ready toolkits?
16:41:54 <mwc> from what I've seen, wxHaskell has a lot of portability issues
16:41:59 <mwc> barely works on OS X
16:42:19 <syntaxfree> well, i don't know about that.
16:42:27 <Muad_Dibber> it had some problems
16:42:29 <syntaxfree> I'm comparing wxwidgets with gtk.
16:42:36 <mwc> Everything I've seen with mulitple frontends, I always use the GTK2 through X11 than the other toolkits
16:42:36 <syntaxfree> not wxhaskell with gtk2hs
16:42:38 <Muad_Dibber> but i though those were supposed to be resolved
16:42:44 <mwc> ie, say wxmac
16:43:03 <yip> gtk looks fine on windows http://gtk-wimp.sourceforge.net/screenshots/
16:43:08 <sethk> gtk or not gtk seems to be an emotional issue for many people.  Not for Haskell specifically, more in general.
16:43:17 <mwc> gtk has a native mac port now
16:43:22 <mwc> should be stable pretty shortly
16:43:23 <syntaxfree> gtk on windows breaks a lot of keyboard shortcuts.
16:43:37 <syntaxfree> i remember working with Gretl on windows. Gah.
16:43:57 <yip> what we really need is for someone to tear out the blender gui and package it as a seperate library. that gui is the shit
16:44:31 <syntaxfree> i played with blender for five minutes, and couldn't figure the first thing out.
16:45:21 <mwc> blender is a really good UI designed around a specialized task
16:45:30 <mwc> you do everything with one hand on the mouse, and one on the kb
16:45:34 <syntaxfree> whether that's a reflex of blender usability or mine own incompetence is left as an exercise to the reader.
16:45:43 <mwc> I'm not sure that UI would work for anything else
16:45:49 <mwc> it's too specialized
16:45:49 <sethk> what's blender?
16:45:53 <yip> guys check out a screenshot of my game prototype:
16:45:55 <yip> http://img486.imageshack.us/img486/1055/x0031oc.png
16:46:03 <mwc> sethk, opensource 3d package
16:46:07 <syntaxfree> blender is a free 3d program/.
16:46:09 <mwc> www.blender.org
16:46:13 <mwc> might be blender3d
16:46:19 <sethk> mwc, thanks.
16:46:53 <mwc> hmm, the native os x gtk is in CVS/head
16:47:04 <Muad_Dibber> yip: I hope not to be rude; but that game will not be commercial anytime soon...
16:47:12 <SamB> syntaxfree: I suspect the problem is that you only played with it for 5 minutes ;-)
16:47:51 <yip> Muad_Dibber: you would be surprised
16:47:58 <Muad_Dibber> same with the Gimp SamB, syntaxfree
16:48:09 <mwc> Muad_Dibber, needs textures, which needs artists
16:48:14 <mwc> that's why I have up trying to make a game
16:48:21 <Muad_Dibber> indeed mwc
16:48:27 <syntaxfree> in Gimp, everything can be found on the right-click menu.
16:48:35 <Muad_Dibber> a good game requires textures, images, music
16:48:37 <SamB> you should try making a retro-style game
16:48:38 <Muad_Dibber> story
16:48:55 <mwc> my art skills basically plateaued at about age 6
16:48:57 <SamB> with one of those you *might* be able to do decent tiles
16:49:01 <mwc> I was born tone deaf
16:49:06 <syntaxfree> of course, I knew Photoshop beforehand, so I pretty much had it easy.
16:49:07 <mwc> story is about the only thing I think I could do
16:49:10 <SamB> or even *steal* them
16:49:32 <Muad_Dibber> I'm a decent music player
16:49:35 <SamB> syntaxfree: yes, but being able to be found and being found are different things ;-)
16:49:43 <Muad_Dibber> but not enough to compose anything decent :)
16:49:54 <SamB> mwc: you could try interactive fiction ;-)
16:50:07 <mwc> Choose your own adventures?
16:50:11 <Muad_Dibber> or a mud :)
16:50:18 <SamB> more than that!
16:50:44 <mwc> Basically, last time I took an IQ test, I broke the test on verbal skills (>99.9th percentile), and scored a tenth percentile in auditory processing/listening skills
16:50:49 <SamB> have you tried any of the excelent (or not) titles available at the if-archive
16:51:09 <mwc> they gave me a list of numbers and asked me to repeat it, I got 5 forwards and 3 backwards
16:52:41 <Muad_Dibber> ..
16:52:50 <syntaxfree> IQ tests have "auditory processing" skills?
16:53:04 <syntaxfree> I should take a pro IQ test one day. I have perfect pitch.
16:53:16 <bolrod> HOHOHO ! you guys
16:53:21 <bolrod> >_<
16:53:32 <Muad_Dibber> ... bolrod
16:54:03 <bolrod> :D
16:54:20 <lisppaste2> bolrod pasted "da sheyats" at http://paste.lisp.org/display/20733
16:54:33 <bolrod> compare it to the C
16:54:42 <bolrod> http://shootout.alioth.debian.org/debian/benchmark.php?test=sumcol&lang=gcc&id=0
16:54:46 <bolrod> :]
16:55:52 <bolrod> the haskell one is faster on my computer :O!
16:55:59 <mwc> syntaxfree, the WISC IV has categories in spatial reasoning, abstract/verbal, and auditory sequencing
16:56:19 <mwc> there might be some more, but that was about 6 years ago
16:56:46 <bolrod> it's only a fraction.. but it still is faster
16:59:08 <bolrod> hrm
16:59:53 <bolrod> ok... for a very large file it is slower :o
17:02:39 <ihope> My cat's sleeping with her head on a power adapter thing...
17:04:00 <bolrod> haha
17:04:07 <bolrod> those could make nice buzzing sounds :P
17:04:14 <bolrod> and its warm
17:04:49 <ihope> What do you know, it does buzz.
17:05:01 <bolrod> :P
17:08:14 <ihope> ...Dang, I can still hear the buzzing.
17:08:37 <bolrod> :O?
17:08:43 <bolrod> maybe it's just your head
17:10:20 <dons> moin!
17:10:30 <dons> bolrod: you're hacking on the shootout?
17:10:44 <ihope> My head's buzzing?!
17:23:09 <syntaxfree> what's with dons?
17:23:16 <syntaxfree> it means something like post-cons?
17:23:16 <dons> hmm?
17:23:34 <dons> my name is Don.
17:25:12 <bolrod> dons: just trying
17:25:53 <bolrod> just trying what works fast.. and what doesn't :)
17:26:27 <palomer> dons is a pejorative term for a spaniard
17:26:50 <dons> ok. there's an example sum entry in the tests/ dir.  sum.hs
17:27:04 <mathewm> @hoogle appT
17:27:04 <lambdabot> Language.Haskell.TH.appT :: TypeQ -> TypeQ -> TypeQ
17:27:04 <lambdabot> Language.Haskell.TH.AppT :: Type -> Type -> Type
17:27:04 <lambdabot> Data.Typeable.mkAppTy :: TypeRep -> TypeRep -> TypeRep
17:28:55 <bolrod> ghc sum.hs -o sum.run -O3 -optc-O3
17:28:56 <bolrod> sum.hs:9:46: Module `Data.ByteString' does not export `unsafeIndexWord8'
17:28:58 <bolrod> :o
17:30:08 <ihope> Oormp.
17:30:40 <mathewm> @docs template
17:30:40 <lambdabot> template not available
17:30:45 <mathewm> @docs TH
17:30:46 <lambdabot> TH not available
17:42:27 <dons> bolrod: darcs pull
17:42:35 <dons> i updated that file last night
17:45:19 <bolrod> bwah.. other time :P
17:45:22 <bolrod> it's late now
17:48:20 <mathewm> @hoogle Pat -> PatQ
17:48:21 <lambdabot> No matches, try a more general search
17:50:37 <mathewm> @hoogle Pat -> Q Pat
17:50:38 <lambdabot> No matches, try a more general search
17:51:02 <ihope> @hoogle Pat -> QPat
17:51:03 <lambdabot> No matches, try a more general search
17:51:38 <mathewm> theres gotta be something with 'lift' in the name, no?
17:52:16 <ihope> @hoogle lift
17:52:17 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
17:52:17 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
17:52:17 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
17:53:36 <mathewm> :)
17:53:39 <mathewm> :(
17:53:54 <mathewm> @hoogle PatQ
17:53:54 <lambdabot> Language.Haskell.TH.PatQ :: type PatQ
17:53:54 <lambdabot> Language.Haskell.TH.FieldPatQ :: type FieldPatQ
17:53:59 <mathewm> @hoogle Q Pat
17:54:00 <lambdabot> No matches, try a more general search
17:54:17 <mathewm> @type PatQ
17:54:18 <lambdabot> Not in scope: data constructor `PatQ'
18:10:41 <dons> ?uptime
18:12:28 <Lemmih> ?wifi
18:12:28 <lambdabot> http://www.haskell.org/haskellwiki/
18:15:20 <dons> morning Lemmih, how's code?
18:15:27 <dons> @seen sjanssen 
18:15:27 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
18:15:32 <dons> sjanssen: around?
18:16:47 <dons> @quit new code
18:16:53 <bolrod> ^.0
18:16:56 <bolrod> what's new now?
18:17:06 <dons> davidhouse wrote some new plugins
18:17:16 <bolrod> weren't they already implemented?
18:17:17 <dons> ?help instances
18:17:30 <dons> hmm?
18:17:41 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
18:17:43 <bolrod> what kind of new things do we have then :]
18:17:49 <dons> ?instances Monad
18:17:50 <lambdabot> [], ArrowMonad a, WriterT w m, Writer w, ReaderT r m, Reader r, StateT s m, State s, RWST r w s m, RWS r w s, ErrorT e m, Either e, ContT r m, Cont r, Maybe, ST s, IO
18:17:52 <Lemmih> dons: Pretty good. Playing around with Ajax and payment methods while cursing Java.
18:17:55 <bolrod> ;o :D
18:18:11 <Lemmih> ?instances MonadPlus
18:18:12 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
18:18:23 <dons> Lemmih: Java! what's this part of? some working/pay-real-money job?
18:18:43 <dons> ?help instances-importing
18:18:43 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
18:18:49 <bolrod> JavaScript is much worse then java! :o
18:18:58 <Lemmih> dons: Nah, my netbank is using Java and it's a bitch to install.
18:19:06 <bolrod> plus.. it's mainly used for eyecandy I guess
18:19:16 <dons> Lemmih: ah, me too.
18:19:22 <dons> i had to write an faq about getting it to work
18:19:42 <dons> bolrod: though i'm vaguely interested in compiling haskell to javascript
18:19:58 <dons> now that java is dying its slow death
18:20:07 * dons makes a big claim there
18:20:38 <dons> i notice there is a nwe java->javascript compiler
18:20:43 <dons> so we should be able to do the same thing
18:20:55 <dons> its 6 months work though. or more.
18:21:18 <dons> ?version
18:21:18 <lambdabot> lambdabot 3.1p35, GHC 6.4.1 (Linux i686 3.20GHz)
18:21:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:22:52 <bolrod> :o
18:23:36 <Igloo> dons: Thought about just writing a yhc bytecode interpreter in J/JS?
18:24:41 <dons> yeah, actually. i thought yhc would be the easiest path
18:24:52 <dons> considering theres a pythong interpreter (yeah?)
18:25:28 <dons> that's not a bad honours student project, really.
18:26:04 <Igloo> honours student == undergraduate?
18:26:09 <dons> not sure if anyone's thought of the javascript path, in fact. i know of no papers
18:26:14 <dons> yeah, 4th year undergrad
18:26:36 <Igloo> Oh, I guess you'll have to write a garbage collector, so it's not quite as simple as it could be
18:26:56 <dons> javascript doesn't have a garbage collector?
18:27:09 <dons> (that's usually what you do in, e.g. java, reuse the existing infrastructure)
18:28:21 <Igloo> I was suggesting running a port of yhc as the J/JS program, in which case the GC wouldn't know what Haskell values could be GCed
18:28:29 <dons> ah, right
18:28:42 <dons> you port the yhc rts
18:29:54 * Igloo isn't convinced yhc would be significantly easier than GHC given the above, but I'm not too familiar with the appropriate bits of either code base
18:30:15 <dons> well, didn't ndm write a python interpreter for yhc bytecode in a couple of days?
18:30:47 <dons> ndm, around?
18:31:43 <Igloo> Well, if you're right then I'm probably wrong  :-)
18:37:34 <dons> hehe
18:41:15 <syntaxfree> what's yhc?
18:43:40 <int-e> @where yhc
18:43:41 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
18:45:04 <syntaxfree> what's with the scottish names?
18:45:08 <syntaxfree> Glasgow, York.
18:45:30 <hyrax42> york
18:45:31 <hyrax42> is not
18:45:34 <hyrax42> in scotland
18:45:52 * Pseudonym decides to write a compiler and call it "Hamish Ewan McDonald Haskell"
18:46:13 <syntaxfree> oh, it's bytecode!@
18:46:33 <syntaxfree> that is good, hackers, that is good.
18:46:49 <mathewm> @hoogle Name -> [Char]
18:46:50 <lambdabot> No matches, try a more general search
18:47:09 <syntaxfree> I wonder if I'm addicted to ghc-specific language extensions already.
18:48:15 <syntaxfree> in particular, yhc sounds like the ideal way to use haskell as a cgi language.
18:48:41 <syntaxfree> (As I don't have a linux box to compile to Linux, and running a VM is boring)
18:52:09 * bringert thinks running a VM is lots of fun
18:52:23 <bringert> but I started today, I guess I'll get bored
18:53:46 <Philippa> I'm running haskell CGIs under windows
18:53:59 <Philippa> not often, but I've never switched to a linux box for dev purposes
18:55:31 <bringert> I've switched to developing Haskell CGIs on OS X. I'll compile them on Linux running in a VM before deploying to my web host
18:55:36 <bringert> that's the plan anyway
18:58:28 <Philippa> I think kinda the point is it doesn't really matter which OS you develop on :-)
18:59:47 <bringert> sounds reasonable
19:00:24 <bringert> though I guess developing on Windows for deployment on Linux can cause problems with path names
19:03:20 <syntaxfree> bringert: that's my solution.
19:03:27 <syntaxfree> I develop on OS X. 
19:03:47 <syntaxfree> I'm too lazy to compile them on Linux to deploy to my web host, though.
19:03:57 <bringert> so what do you do?
19:04:02 <syntaxfree> I don't.
19:04:08 <syntaxfree> But I'm considering yhc.
19:06:31 <syntaxfree> bringert: maybe I can convince you to compile some stuff for me some day ;)
19:06:31 <bringert> With Apache+mod_fastcgi and MySQL running on my laptop, I can test everything right here on OS X. I figure that I'll be updating the live version seldom enough that it will be ok to do the extra step of compiling in a Linux VM. 
19:06:53 <bringert> syntaxfree: or you can install ghc on your webhost
19:07:21 <syntaxfree> bringert: that should be quite a hassle, given that I don't have shell access there.
19:07:30 <bringert> heh
19:07:31 <syntaxfree> It's one of those cheapie hosting packages.
19:08:14 <bringert> I've got a chepo package too, it gives me unlimited shell users and 20 GB, fastcgi etc.
19:08:25 <bringert> but I guess yours is even cheapier
19:08:29 <bringert> :-)
19:08:56 <lispy> i have a server in a datacenter and enough other people pay for space on it that it's free to me :)
19:08:59 <syntaxfree> I pay about $3 a month. In Brazil.
19:09:14 <bringert> lispy: sweet
19:09:23 <bringert> except you have to admin it I guess
19:09:43 <lispy> yeah, and i'm paranoid that the raid will do down and i won't be able to get it backup in a timely maney
19:09:45 <lispy> er maner
19:09:53 <lispy> plus, it's in a different city and i have no car :)
19:10:15 <lispy> fortunately my users are okay with taht
19:10:23 <Korollary> mom & dad?
19:10:38 <lispy> no friends
19:10:48 <lispy> er, there should be a comma in there
19:10:53 <syntaxfree> bringert: so, do you know if the Apache distribution shipping with Panther has mod_fastcgi already?
19:11:01 <bringert> syntaxfree: nope
19:11:06 <bringert> but it easy to install
19:11:10 <bringert> 's
19:11:14 <lispy> Korollary: i told them from the start they are incharge of their own backup :)
19:11:18 <syntaxfree> I see. And what do you do for MySQL connection from Haskell?
19:11:27 <bringert> HaskellDB + HSQL
19:11:44 <lisppaste2> ramza3 pasted "Correct Indentation" at http://paste.lisp.org/display/20738
19:12:09 <syntaxfree> I was considering using Haskell CGIs to handle the tricky logic and using a PHP layer to access DBs.
19:12:12 <ramza3___> what is wrong with my code there.  I am not familiar with the idents yet and I think my emacs-haskell mode is not working for me
19:12:33 <syntaxfree> bringert: you should consider writing a tutorial on web development with Haskell.
19:12:45 <lispy> ramza3___: don't trust emacs-haskell mode it's not as intelligent as it needs to be
19:12:45 <bringert> syntaxfree: yeah, I should
19:13:01 <ramza3___> lispy: yea I am figuring that out
19:13:25 * lispy takes a look at the pastebin
19:13:53 <lispy> 'if' should be at the same level as 'let'
19:13:55 <syntaxfree> bringert: any obvious pitfalls I should watch for?
19:14:26 <ramza3___> lispy: yep that was damn, I blame emacs
19:14:28 <Korollary> ramza3___: line 20. doGuessing should be aligned with putStrLn above
19:14:34 <lisppaste2> lispy annotated #20738 with "maybe this works?" at http://paste.lisp.org/display/20738#1
19:14:48 <bringert> syntaxfree: seeing how I maintain 6+ different packages that can be useful for web programming (HaskellDB, CGI, FastCGI, xhtml, http, xml-rpc, ...), I should write something up
19:15:07 <bringert> syntaxfree: hmm, you should watch out for my code
19:15:14 <bringert> i guess
19:17:42 <syntaxfree> Umm. HSQL is a database engine. I thought you used MySQL.
19:18:07 <syntaxfree> Convincing my cheapie hosting provider to support HSQL given that they have Mysql and Postgre already should be tiring.
19:20:47 <bringert> not that hsql
19:20:51 <bringert> phone
19:20:52 <lispy> haha
19:20:59 <lispy> yeah, hsql lets you talk to a database
19:25:05 <bringert> HSQL is part of the otherwise (I think) defunct htoolkit http://htoolkit.sourceforge.net/
19:26:00 <bringert> HDBC is a recent alternative to HSQL. HaskellDB supports both.
19:26:49 <lispy> is haskellDB the nice abstraction to sql based on haskell types? or am i thinking of something else?
19:27:02 <bringert> lispy: yes
19:27:08 <bringert> the former that is
19:27:18 <bringert> well, if it is nice is up to you
19:27:25 <lispy> heh
19:27:30 <bringert> I think it works pretty well once you know it
19:29:29 <bringert> though it has a few problems that need to be worked out
19:30:10 <lispy> i'd say that fits almost every api i've used
19:31:14 <bringert> ok, I should say bugs then :-)
19:31:49 <syntaxfree> HDBC is like, ODBC?
19:32:51 <syntaxfree> htoolkit is a gui thing, apparently.
19:34:34 <bringert> HDBC can use ODBC :-)
19:34:49 <bringert> HDBC and HSQL are fairly similar, at least in purpose
19:35:17 <syntaxfree> why do you use both?
19:35:39 <syntaxfree> oh, you don't.
19:35:45 <syntaxfree> you use HaskellDB and HSQL.
19:35:59 <syntaxfree> htoolkit is a gui thing, not related to hsql at all.
19:36:09 <bringert> syntaxfree: right
19:36:19 <bringert> same SourceForge project though
19:36:26 <syntaxfree> it doesn't quite seem defunct, too.
19:36:37 <syntaxfree> maybe they dropped the old htoolkit, and a new project took the name.
19:36:51 <syntaxfree> I like this htoolkit thing better than any haskell gui project I've seen before.
19:37:26 <bringert> syntaxfree: based on what? was htoolkit ever released?
19:37:52 <syntaxfree> based on what the code snippets look like, mostly.
19:39:21 * bringert should stop trying to cook and irc at the same time
19:39:24 <bringert> bbl
19:39:31 <dons> bringert: hehe
19:40:33 <syntaxfree> OH! The guy just dropped htoolkit, started developing HSQL and never changed the website or filed for a new project.
19:40:36 <syntaxfree> What an odd odd.
19:40:49 <lispy> odd odd?
19:40:54 <bolrod> odd odd = even?
19:40:58 <lispy> dons: how's code?
19:40:59 <dons> bringert: i always burn dinner when i try that trick
19:41:10 <syntaxfree> The second "odd" is a noun.
19:41:10 <dons> lispy: good, benchmarking some fps fusion stuff atm
19:41:18 <lispy> nice!
19:41:29 <lispy> fusion-ha! (in the voice of dbz characters)
19:41:42 <bolrod> which one :P
19:41:54 <syntaxfree> well, 
19:41:59 <lispy> *poof* gotenks appears from a huge lambda shaped cloud
19:42:08 <bolrod> hehe :)
19:42:12 <syntaxfree> what on earth has the Halifax Dartmouth Bridge Comission to do with Haskell or database connections?
19:42:12 <lispy> goten and trunks iirc
19:42:49 <bolrod> what on earth am I doing here on irc?
19:43:03 <bolrod> ;p
19:43:07 <lispy> syntaxfree: obvious answer, everything has to do with haskell...the world revolves around it :)
19:43:17 <syntaxfree> :)
19:43:36 * lispy has been bugging simonm about hdirect and visual haskell
19:43:55 <lispy> i want to use haskell at work for a particular project but com is 90% of what i'm going to be doing
19:44:06 <lispy> COM is the debil
19:44:09 <syntaxfree> what is visual haskell?
19:44:18 <lispy> visual studio plugin for haskell
19:44:52 <syntaxfree> I know COM stands for Corba Object Model, but not much more. It's like an API, right?
19:44:56 <Korollary> no
19:45:06 <lispy> also coincidentally the only way i know to get com working with recent ghcs
19:45:19 <lispy> component object model
19:45:30 <lispy> corba is a competing standard
19:45:46 <Pseudonym> @vera hdbc
19:45:48 <lambdabot> No match for "hdbc".
19:45:59 <syntaxfree> so what is COM, anyway?
19:46:08 <Pseudonym> COM is not the devil.
19:46:18 <Pseudonym> COM is a nice idea that ActiveX completely screwed up.
19:46:24 <Korollary> It's MS' cross-language obj tech
19:46:35 <lispy> syntaxfree: it's a way to transfer data between programs and also tangentially programming languages
19:46:45 <syntaxfree> isn't MS''s cross-language object technology .NET?
19:46:55 <Pseudonym> COM is something of an ancestor to .NET.
19:46:59 <Korollary> COM is olde
19:47:00 <Korollary> r
19:47:06 <Pseudonym> DDE -> OLE -> COM -> .NET
19:47:17 <Pseudonym> More or less.
19:47:42 <lispy> microsoft :: DDE -> OLE -> COM -> DOTNET -> IO ()
19:47:45 <syntaxfree> I remember OLE.
19:48:07 <syntaxfree> so DDE is like an older OLE and COM is like a newer OLE?
19:48:08 <Pseudonym> OLE2 is built on top of COM.
19:48:33 <Pseudonym> In each case, Microsoft is saying "oh, here's what we REALLY meant to make".
19:48:39 <lispy> you can think of COM as a bridge between VB and C++
19:48:50 <Pseudonym> COM is more than that.
19:48:52 <syntaxfree> I remember being 13 and thinking OLE was teh future of computing. 
19:48:56 <lispy> that's how it started, and now we have things like DCOM
19:49:01 <bringert> dons: it loks like 
19:49:13 <Pseudonym> COM is the glue that binds bits of Windows together.
19:49:18 <bringert> eh, it looks like I only burnt the good parts
19:49:20 <syntaxfree> like how programs weren't closed upon themselves, but were toolkits.
19:49:21 <lispy> yeah, and it's really slow too
19:49:28 <Korollary> It's not that slow
19:49:32 <Pseudonym> No, it's not.
19:49:48 <Pseudonym> The problem with COM is that it's a small, clean, simple and theoretically portable framework.
19:50:06 <lispy> i've used com to transfer large matrices between programs and i've used flat files, the flat files was something like 100x faster
19:50:07 <Korollary> It's a bit gnarly to write for, tho. I liked ATL much better
19:50:10 <Pseudonym> Which means, of course, that someone at Microsoft is going to screw up the layers on top of it.
19:50:29 <Pseudonym> OK, I'm not shocked about the large matrices.
19:50:38 <syntaxfree> Microsoft seems to consistently get the base technologies right and then screw it up.
19:50:38 <Pseudonym> That seems to me like a job for shared memory.
19:50:57 <Pseudonym> syntaxfree, that's not always the case.
19:51:00 <syntaxfree> I've read reams of praise for the general artchitecture of NT kernels.
19:51:05 <lispy> does windows have shared mem?  one program was fortran77, BTW
19:51:13 <Pseudonym> lispy: Sure does.
19:51:14 <Mag1KaL> Does anyone EclipseFP? If so, is it any good?
19:51:28 <Pseudonym> It has memory-mapped files, which does the job,
19:51:51 <Pseudonym> The implementation is a bit... uhm... idiosyncratic.
19:51:52 <lispy> Mag1KaL: it's not bad, but 1) you have to like eclipse 2) it's still alpha so the rough edges are very rough
19:52:04 <Pseudonym> Like it won't flush a mmaped file to disk while it's mapped.
19:52:10 <Pseudonym> Even if you ask for that to be done.
19:52:31 <syntaxfree> question: what's Linux's answer to OLE/COM/whatever?
19:52:32 <Pseudonym> Which is, I suppose, more accurately described as "stupid" rather than "idiosyncratic".
19:52:36 <lispy> we liked the file based approach because it was simple
19:52:47 <syntaxfree> Other than GNUStep, because that's not really Linux.
19:52:49 <lispy> syntaxfree: corba?
19:53:01 <Pseudonym> syntaxfree: Its answer is pretty much the same as its answer to everything else.  "We don't mandate a standard."
19:53:24 <syntaxfree> what popular Linux-based OS piece uses Corba?
19:53:31 <Korollary> gnome used corba iirc
19:53:35 <syntaxfree> I remember KDE having some kind of shared object system, but.
19:53:37 <Pseudonym> In practice, if you need middleware, you get CORBA.
19:54:05 <lispy> seems likke gnome build a lot ontop of corba
19:54:12 <Pseudonym> Unless you're talking application servers, in which case you use DAV, SOAP, AJAX or whatever takes your fancy.
19:54:33 <syntaxfree> um. middleware is like OLE, COM, CORBA?
19:54:57 <Pseudonym> But lots of Unix applications work with sunrpc, ASN.1 and various stuff like that.
19:55:24 <syntaxfree> what is sunrpc? or SOAP,for that matter?
19:55:33 <Pseudonym> @foldoc rpc
19:55:35 <lambdabot> *** "rpc" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
19:55:35 <lambdabot> RPC
19:55:35 <lambdabot>  
19:55:35 <lambdabot>    {Remote Procedure Call}
19:55:35 <lambdabot>  
19:55:42 <Pseudonym> @foldoc soap
19:55:43 <syntaxfree> And I thought that AJAX was for fancy web pages calling the server without reloading.
19:55:43 <lambdabot> *** "soap" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
19:55:43 <lambdabot> SOAP
19:55:43 <lambdabot>  
19:55:43 <lambdabot>    1. <protocol> {Simple Object Access Protocol}.
19:55:45 <lambdabot>  
19:55:47 <lambdabot> [4 @more lines]
19:56:31 <Pseudonym> syntaxfree: Sure.  But if you put it on an intranet, it's a fancy way to distribute an internal application without needing to install anything on the clients.
19:56:36 <lispy> i've heard the S in soap is a misnormer
19:56:43 <lispy> but i've yet to experience it
19:56:51 <Pseudonym> I'm told that SOAP is pretty expensive.
19:57:05 <Pseudonym> Compared with CORBA, DCOM, RPC and ASN.1.
19:57:07 * lispy holds his nose around Pseudonym ;)
19:57:19 <Pseudonym> BODYWASH is much better.
19:57:29 <syntaxfree> I'm starting to think that activex is a nice technology that got an irreversible bad rep because of the IE worm explosion.
19:57:31 <Pseudonym> And doesn't leave scum.
19:57:45 <Pseudonym> Well, stop that thought right now.
19:57:51 <palomer> I said STOP IT!
19:57:56 <Pseudonym> ActiveX is a nice idea that got screwed up in the implementation.
19:58:05 <lispy> @palomer
19:58:05 <lambdabot> I think vim is good for the rubbish bin
19:58:10 <lispy> ;)
19:58:28 <Pseudonym> ActiveX is actually a pretty good idea.
19:58:37 <Pseudonym> In essence, it's a way to embed a control in a container.
19:58:45 <syntaxfree> The samurai-hacker-unix-with-vim-and-shell-scripts seems like quite a step backwards, in this context.
19:58:48 <Pseudonym> Such that the container doesn't need to know what the control is.
19:59:09 <Pseudonym> Example: Your fancy dialog box editor can work with custom controls.
19:59:37 <Pseudonym> Or, your spreadsheet application can store anything even if it doesn't understand it natively.
19:59:45 <lispy> oh, right but that idea was already invented and they calledit polymorphism :)
19:59:57 <Pseudonym> Absolutely.
20:00:13 <Pseudonym> COM is an interface system which supports implementation polymorphism.
20:00:31 <Pseudonym> ActiveX is a bunch of interfaces and conventions which support embedding controls.
20:01:14 <palomer> @palomer
20:01:14 <lambdabot> I think vim is good for the rubbish bin
20:01:24 <Pseudonym> It's a fabulous idea.  It just so happens that the actual interfaces and conventions which Microsoft came up with were completely horrid.
20:01:43 <Philippa_> ITYM "typical for Microsoft at the time" :-)
20:01:57 <syntaxfree> wow.
20:02:08 <syntaxfree> Sometimes, it seems Microsoft really was the way of the future.
20:02:41 <Philippa_> I forget which of COM or CORBA came about first?
20:02:51 <Pseudonym> To understand Microsoft, you really only need to understand one thing:
20:03:00 <monochrom> COM was first
20:03:01 <Pseudonym> They innovate if and only if they are trying to kill a competitor.
20:03:02 <Philippa_> heck, IIRC COM's old enough it could be one of those things from back when OS/2 was supposed to have a future
20:03:21 <Pseudonym> So whenever they come up with something clever, you can bet hard money that they're trying to kill someone.
20:03:38 <syntaxfree> "In the movie The Gods Must Be Crazy, an African bushman comes upon an empty Coke bottle that a careless Westerner tossed from an airplane. The bushman believes the bottle is a gift from the gods, especially as he finds more and more uses for it: carrying water, digging holes, pounding stakes, making music, and so on. Are there any limits?"
20:03:46 <syntaxfree> "OLE is very much like the Coke bottle (except that at the end of the movie the bushman decides that the bottle has caused too much trouble, so he tosses it off the edge of a cliff. This paper is not suggesting the same for OLE!)."
20:04:10 <syntaxfree> I wonder if we're throwing away the coke bottle because of Microsoft security issues.
20:04:27 <Philippa_> OLE's ubiquitous on windows
20:04:34 <Pseudonym> OLE was an attempt to kill a superior technology.  (OpenDocument)
20:04:39 <Philippa_> MFC strongly encourages it, too
20:04:47 <monochrom> Heh it is causing too much trouble, it seems. :)
20:04:49 <Pseudonym> And it sort of worked.
20:04:59 <palomer> http://www.rafb.net/paste/results/t08okq88.html <-- I'm puzzled by this
20:05:17 * syntaxfree starts developing a pathological aversion for web 2.0 technologies.
20:05:38 <Pseudonym> DCOM was an attempt to kill CORBA, Win95 was an attempt to kill OS/2 Warp, .NET was an attempt to kill Java...
20:05:46 <Mag1KaL> Microsoft's biggest problem right now is trying to remain compatible with all the crap they did in the last 15 years.
20:05:55 <Pseudonym> NT was an attempt to kill Novell, more or less.
20:06:08 <syntaxfree> not Unix?
20:06:18 <Pseudonym> Not originally.
20:07:02 <Pseudonym> Unix was pretty much never used as a server for PC workstations.
20:07:12 <Pseudonym> Not before Linux, anyway.
20:07:14 <monochrom> Nitpicking: I don't think Win95 contains any innovation.
20:07:23 <Pseudonym> No, I'd disagree with that.
20:07:34 <Pseudonym> They rebuild the interface around COM.
20:07:50 <monochrom> Oops, forgot that.
20:07:59 <Pseudonym> And they wrote a new kernel.
20:08:31 <Pseudonym> You're right in the sense that Win95 wasn't especially innovative.
20:08:51 <palomer> it seems you guys have an acute case of "not helping palomer out", punishable by death by lasers
20:09:05 <monochrom> Haha I'm reading your paste.
20:09:06 <syntaxfree> Pseudonym: if Unix wasn't used as a server for PC workstations, neither in the big computer/mainframe space, where was it used?
20:09:27 <Pseudonym> As a server for thinner clients than PCs.
20:09:37 <Pseudonym> Xterms, TTYs etc.
20:10:17 <monochrom> Interesting.
20:10:33 <Pseudonym> I used Xterms and VT100s as an undergrad.
20:10:44 <Pseudonym> I wrote my honours thesis on an Esprit terminal.
20:10:52 <Pseudonym> Seriously retro.
20:11:05 <syntaxfree> I'm thinking that since I became computer-mature with Linux, I'm Unix-biased in what constitutes neat technologies.
20:11:08 <dons> too cold!
20:11:17 <syntaxfree> Maybe it's because Unix affords neat technologies to lower-level users.
20:11:21 <dons> Pseudonym: its around 12c here. what's it like down south?
20:11:35 <Mag1KaL> Perhaps but I don't understand how people think it can take over the desktop..
20:11:43 <syntaxfree> Not C++ programmers who have memorized MFC, but people with shell scripts, Python and awk.
20:12:01 <bringert> Mag1KaL: do you consider OS X to be Unix?
20:12:23 <Pseudonym> dons: Haven't been outside, but BOM reports 14C.
20:12:24 <lispy> i consider osx to be a nice blend of unix and apple
20:12:36 <syntaxfree> I consider OS X to incorporate Unix as a part of its technologies.
20:12:47 <monochrom> palomer: do { trace "SHOO" $ return (); trace "kabam" $ return () }   Do you think it will print out both SHOO and kabam?
20:12:51 <bringert> lispy: that sounds delicious
20:12:56 * bringert get some ice cream
20:13:05 <bringert> damm, no apples
20:13:11 * bringert gets a peach
20:13:18 <palomer> monochrom: yes
20:13:26 <syntaxfree> afaik the close-to-metal stuff is Unix, but there's a lot of nextstep-ish stuff happening.
20:13:30 <monochrom> Are they printed in practice?
20:13:39 <monochrom> (Could you try?)
20:13:42 <palomer> though it prints them in reverse order
20:13:46 <palomer> I tried
20:14:11 <dons> pretty graphs, http://www.cse.unsw.edu.au/~dons/tmp/comparative_mapfilter_fusion_strategies.png, the speed of bytestring operations using standard array fusion, and a three more specialised schemes dcoutts and i've been hacking on
20:14:11 <syntaxfree> Pseudonym: do you consider OS X to be Unix?
20:14:16 <monochrom> I think some code optimization is causing this.
20:14:27 <Mag1KaL> I'm actually thinking of getting a Mac
20:14:33 <palomer> it's optimizing out trace?
20:14:35 <palomer> that's nuts!
20:14:39 <dons> shorter is better (i.e. faster). red is conventional array fusion
20:14:42 <Pseudonym> syntaxfree: I don't know.  Did it pass Unix98 compliance?
20:14:45 <syntaxfree> It's been  about a year I've had a Mac.
20:14:48 <Pseudonym> If so, then yes.
20:14:53 <Mag1KaL> I just don't know which one or when... maybe with the new Core 2 chips.
20:14:55 <Pseudonym> If not, then I'd say "native POSIX" instead.
20:14:58 <syntaxfree> Pseudonym: well, philosophically, do you think it's one.
20:15:00 <syntaxfree> ?
20:15:05 <palomer> is it really possible to optimize out trace?
20:15:26 <syntaxfree> Mag1Kal: I pretty much got the last PPC Mac released, the original mini.
20:15:26 <Pseudonym> I think it's definitely in the tradition of.
20:15:27 <monochrom> Let me think again.
20:15:39 <Pseudonym> But I really don't know enough about it to comment.
20:15:54 <syntaxfree> ah. I see.
20:16:07 <bringert> I can really recommend the new dual core intel macs. just make sure you get more RAM
20:16:11 <syntaxfree> The way I see it, it's really NeXTStep.
20:16:39 <palomer> note that the last line of newTyVar is a trace which does get printed
20:17:00 <monochrom> Ok. First, the reader and the state monads are purely functional code in a non-strict language.  Evaluation order is going to be counterintuitive even with the dumbest interpreter.
20:17:17 <syntaxfree> it borrows a lot of closer-to-metal technologies from Unix (well, so does NeXTStep", but it's far from, say, a KDE desktop.
20:17:19 <palomer> righto, but some code simply doesn't get evaluated!
20:17:52 <monochrom> By "evaluation order" I also include what is never evaluated.
20:18:29 <monochrom> Ok, next, trace is essentially unsafePerformIO so there is very few guarantees.
20:18:44 * SamB_XP wonders if OS X passes Unix 2003 Server compliance
20:19:00 <monochrom> s/there is/there are/
20:19:02 <Mag1KaL> Uhh, haskell is hard to learn... :(
20:19:08 <palomer> and flags so that it doesn't get optimized out
20:19:28 <syntaxfree> Basic haskell (up to IO) is easier to learn than any other language I've ever seen.,
20:19:33 <syntaxfree> From monads on, it gets hairy.
20:19:38 <Spark> one does not learn programming, programming teaches one
20:19:46 <palomer> you have to learn about recursion to use basic haskell
20:19:53 <palomer> (which isn't true about other languages)
20:20:08 <SamB_XP> probably because you can't loop without it
20:20:16 <monochrom> recursion is very easy to learn (if you are not a control freak)
20:20:19 <Spark> to be honest, if you dont understand recursion, you need to go away and die in as undisruptive a way as possible
20:20:28 <SamB_XP> it basically takes the place of while, for, and goto all at once
20:20:43 <palomer> Spark: forgot your medication?
20:21:02 <palomer> oh, misread that statement
20:21:02 <palomer> twice
20:21:14 <monochrom> control freak = people who freak out when they don't know the control flow
20:21:15 <syntaxfree> palomer: recursion is often easier to understand than looping.
20:21:18 <palomer> someone who's new to programming may not find recursion intuitive
20:21:18 <Spark> caffiene would help me now
20:21:44 <syntaxfree> palomer: btw, learning about recursion with Scheme enabled me to understand how to do stuff I didn't know how to do before.
20:21:57 <palomer> syntaxfree: we'd need some quantitative stats for that
20:22:00 <monochrom> to learn recursion, you have to give up your grip on control flow. just think induction.
20:22:10 <palomer> ok, is it really possible to optimize out trace? raise of hands people
20:22:11 <syntaxfree> what monochrom just said.
20:22:14 <palomer> who's for "nay" ?
20:22:36 <syntaxfree> Most people arriving to Haskell have a "robot" analogy to programming that essentially equates programming to control flow.
20:22:41 <palomer> who's for "yeah" ?
20:22:52 <palomer> s/raise/show
20:22:55 <monochrom> Is the body of trace inlinable?
20:23:04 <bolrod> recursion is simple :)
20:23:22 <monochrom> I suppose every exported library function is inlinable.
20:23:40 <SamB_XP> I am for "yay!" because "yay!" is fun!
20:23:48 <Mag1KaL2> Hm, just had a brown out...
20:23:58 <Spark> i am for "nay" because i want to ruin everyones day
20:24:08 <monochrom> I'm going to take a look at the source code of trace.  Then I'll assume inlining and speculate what can be optimized away.
20:24:23 <dons> syntaxfree: that's a good analogy.
20:24:28 <SamB_XP> speculative optimization?
20:24:41 <monochrom> Haha
20:24:44 <syntaxfree> dons: that's a good analogy of how a computer works close to the metal, I guess. 
20:24:45 <dons> people see programmign in terms of control flow, but have to change to think of it in terms of equational thinking
20:25:09 <monochrom> You see why I like calling people "control freaks" :)
20:25:21 <dons> heeh
20:25:22 <syntaxfree> but changing programming to a human induction paradigm is worthy in terms of learning curves.
20:26:55 <mathewm> @type mkName
20:26:55 <lambdabot> Not in scope: `mkName'
20:27:08 <mathewm> @type Language.Haskell.TH.mkName
20:27:09 <lambdabot> String -> Language.Haskell.TH.Syntax.Name
20:27:31 <Mag1KaL2> Why don't the little demos from the HOpenGL site work with GHC? Did the api change or something?
20:27:49 <Spark> if you could think of programming in terms of equational reasoning, then f(x) = f(x) would not be a problem
20:27:53 <monochrom> So, two ways of looking at it.  Recursion is easier because you don't have to look at the control flow.  Recursion is harder because you have to give up control flow (at least for a moment).  Sometimes an easy thing is a hard thing because it is hard to give up.
20:28:22 <monochrom> (Same reason why it's easy to admit mistakes and it's hard to admit mistakes.)
20:28:58 <syntaxfree> Recursion is easier because it maps easierly into inductive thought.
20:29:08 <syntaxfree> and inductive thought is pretty much all we do.
20:29:12 <palomer> how do I look at the source corresponding to a module Foo?
20:29:13 <Spark> its not all i do
20:29:32 <syntaxfree> "easierly" is AWFUL.
20:29:49 <SamB_XP> I think it is easier not to have control flow as primitive as it is in most languages...
20:29:54 <SamB_XP> kinda makes it second-class...
20:30:07 <Spark> recursion is control flow
20:30:13 <Spark> if is control flow
20:30:17 <chessguy> it's so tempting for people who are new to recursion to look inside the black box
20:30:18 <Spark> the only thing you remove is while
20:30:23 <chessguy> that's the hard thing
20:30:35 <Spark> while is easy to understand though, you have an invariant and a condition
20:30:47 <Mag1KaL2> Does haskell of an IDE besides EclipseFP?
20:30:47 <syntaxfree> while, for, etc. can be simulated using scanl-like functions.
20:30:52 <Spark> just as you have an induction hypothesis
20:31:24 <syntaxfree> takeWhile and iterate make for a complete control flow system for numerical convergence algorithms, for instance.
20:31:24 <Spark> they both describe a half-finished computation
20:31:52 <Spark> i prefer recursion only being used in a non-tail-call situation like qsort
20:32:16 <mathewm> Mag1KaL2: I find emacs to work quite well
20:32:17 <Spark> so as to distinguish the simple iterations from the more complex algorithms
20:33:02 <monochrom> Ha, Debug.Trace.trace is explicitly marked as NOINLINE.
20:33:13 <monochrom> (source: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Debug/Trace.hs?rev=1.19 )
20:33:25 <palomer> so how is it being inlined?
20:33:27 <monochrom> Alright, so it is not code optimization.
20:34:25 <monochrom> No, it will never be inlined.  I will revise my assumptions.
20:35:19 <monochrom> But still, with lazy evaluation, there are fragments of code you are supposed to skip, and there are fragments you are supposed to reorder, even without optimization.
20:35:22 * palomer is super baffled
20:35:39 <palomer> reordering is fine, but here it doesn't get printed at all!
20:35:54 <monochrom> So now we have to look at ReaderT to see what >>= does and its consequences under lazy evaluation.
20:36:39 <monochrom> head ( 0 : trace "hey!" [] )   this will not print hey.
20:36:57 <monochrom> (Just to show what is possible in general.)
20:37:15 <palomer> oh my that sucks
20:38:17 <monochrom> It is good behaviour because the absence of hey tells you useful information: the tail of the list is never looked at.
20:39:49 <monochrom> I.e., I would write: head ( 0 : trace "if you see this, something is wrong" [] )
20:42:00 <palomer> oh, I think I get it then
20:42:04 <palomer> the code never gets evaluated
20:42:08 <palomer> because I never use the first argument
20:42:12 <palomer> the first ret
20:42:15 <palomer> I only use crap
20:42:22 <palomer> which is irrespective of the rest of the code
20:43:23 <palomer> since it only relies on newTyvar
20:46:16 <Bobstopper> Hey. I heard list comprehension notation used to be possible for any monad. Why was this feature removed?
20:48:25 <Mag1KaL> How would you represent the infinite list of integers in Haskell? Whole and natural numbers are easy, but what about a list that is infinite in both directions?
20:49:14 <monochrom> That depends on what operations you will apply to that list.
20:49:54 <monochrom> First off, normally we traverse the list in one direction only.  Without a "go back" operation, the integer list is moot.
20:50:42 <monochrom> If you do want to go back, it is no longer the standard list data type per se.  If you implement your own bidirectional list type, well, now you can do whatever you want.
20:51:03 <Spark> how do you do that in haskell
20:51:12 <Pegazus> list 0 = (0 : list 1); list n | n > 0 = (n : list (-n)); list n | n < 0 = (n : list(n + 1))
20:51:13 <Spark> a bidirectional list
20:51:24 <monochrom> You could use a pair of standard lists.
20:51:26 <dons> the usual way
20:52:41 <monochrom> Two analogies.  The two-sided infinite tape of a Turing machine.  Dedekind cuts.
20:53:29 <bolrod> @where paste
20:53:30 <lambdabot> http://paste.lisp.org/new/haskell
20:56:45 <bringert> heh, serving an ISO as text/html is sure to mess with your browser
20:57:11 <monochrom> hahahaha
20:57:57 <bringert> me is playing with ByteString.Lazy and CGI programs
20:58:49 <Mag1KaL> What does the "where" mean in "module Main where"
20:59:10 <monochrom> It separates the module name and the module body.
20:59:57 <SamB_XP> Mag1KaL: the same thing it means anywhere else
21:00:03 <monochrom> (Gosh what do you think " " means in "module Main where" ?!)
21:00:11 <SamB_XP> only for some reason with no need to indent your code
21:00:38 <SamB_XP> actually, I suspect it was deliberately put there just to trip me up!
21:00:38 <dons> bringert, hey. cool.
21:02:45 <mlh> how do you import in ghci?  it gives a parse rror
21:03:08 <SamB_XP> for some reason, instead of not indenting your things in the module, you can surround them with {} and seperate them with ;
21:03:42 <monochrom> :module +Debug.Trace
21:03:43 <SamB_XP> I have yet to figure out the reason for this, except that it means you can put two clauses on one line when you do it the normal way
21:05:05 <Cale> SamB_XP: all layout in Haskell is optional
21:05:15 <mlh> monochrom: was that to me?
21:05:26 <dons> ? SamB, its so its esier to generate things mechanically
21:05:30 <monochrom> Yes
21:05:31 <SamB_XP> yes, but even so! I mean, who could argue with *not* indenting?
21:05:47 <mlh> monochrom: ta
21:05:52 <bringert> dons: I'm downloading an ISO from localhost through a CGI programming using ByteString.Lazy. I got about 12 MB/s. Safari uses 32% CPU, httpd around 4.5% and my CGI program around 3.5%.
21:06:07 <dons> oh, very nice!
21:06:13 <bringert> I didn't have time to look at memory use before it was done with the 700 MB file
21:06:22 <dons> that's really cool
21:06:39 <dons> is it flusing to disk as it goes? in which case memory will probably be constant (I hope)
21:06:48 <monochrom> As long as the leecher does more work... :)
21:07:05 <dons> bringert: how does that compare against strict bytestrings?
21:07:11 <SamB_XP> well, well, what if there are a hundred leachers?
21:08:07 <bringert> heh, second time I'm getting 16-18 MB/s, I guess the file is in the block cache
21:08:31 <bringert> the CGI and httpd run in constant space, I didn't have time to look at Safari
21:09:14 <bringert> the CGI uses 2 MB och "real memory", not sure what that means
21:10:18 <bringert> Sam_XP: if you've got a hundred people leeching from you at 15 MB/s each, you've got some serious bandwidth
21:10:29 <SamB_XP> hmm, point!
21:11:02 <SamB_XP> probably get in the penalty box real quick that way!
21:11:13 <dons> bringert: it might be nice to use this cgi/network app as an example for a paper dcoutts and i are writing on this stuff
21:11:19 <bringert> not to many people have 10 Gb/s lines
21:11:25 <dons> let me know when the code's in the main repo.
21:11:37 <bringert> dons: since last night I think
21:12:07 <bringert> though I'm still adding stuff
21:12:15 <bringert> or changing rather
21:12:17 <SamB_XP> okay, okay, so you won't get that much throughput
21:12:21 <dons> yep, sure.
21:12:27 <SamB_XP> I don't even have that on the LAN ;-)
21:12:46 <SamB_XP> I'm on 100 base-T
21:13:32 <SamB_XP> and who has a harddrive with that much throughput, either?
21:13:41 <dons> bringert: any numbers on how improved space or timewise , due to using .Lazy?
21:13:52 <bringert> if we extrapolate, we could serve something 150 MB/s at 100% CPU, which will more than saturate a gigabit pipe
21:13:58 <dons> i'm giving a talk on .Lazy in a few days, and  this seems like a cool example
21:14:32 <bringert> dons: well, compared to a strict bytestring, you save pretty much the size of the file in RAM, since that would slurp in the whole file strictly, then serve it
21:15:03 <bringert> I haven't tried readFile >>= hPutStr, but that would be a nice comparison
21:15:25 <dons> yep. ok. good.
21:15:44 <bringert> so, if you just want to say that lazy i better than strict, this particular example gives you 350x better memory use
21:15:52 <bringert> but that's a bit silly
21:16:49 <bringert> I think the main point is that if you are serving static content, the CPU and memory use of a program using lazy bytestrings are far from the bottleneck
21:17:58 <bringert> dons: the example program I'm using is examples/download.hs, which will be in darcs within an hour 
21:18:08 <dons> url?
21:18:25 <bringert> for the code or, do you want to download isos from me?
21:18:55 <dons> no, just the code thanks :)
21:19:26 <bringert> it's in the main NewCGI repo http://www.cs.chalmers.se/~bringert/darcs/haskell-cgi/
21:19:41 <bringert> the example is not pushed yet though
21:19:50 <bringert> just some small things to fix
21:19:57 * palomer hates readerT!
21:21:20 <bringert> where is the library function for getting the size of a file?
21:21:28 <bringert> I can't believe I've never used that
21:21:36 * monochrom pats palomer
21:21:42 <bringert> @hoogle FilePath -> IO Int
21:21:42 <lambdabot> No matches, try a more general search
21:21:58 <bringert> isn't that how you do it?
21:22:02 * monochrom creates MisterT
21:22:12 <bringert> I also can't believe I haven't used hoogle
21:22:56 <hyrax42> lenght of hGetContents?
21:22:59 <SamB_XP> @hoogle FilePath -> a
21:23:01 <lambdabot> No matches, try a more general search
21:23:13 <bringert> hyrax42: that would slurp the whole file into memory
21:23:15 <bringert> ah
21:23:22 <bringert> @hoogle Handle -> IO Int
21:23:22 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
21:23:23 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
21:23:23 <lambdabot> System.IO.hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
21:23:27 <SamB_XP> @hoogle Int
21:23:27 <lambdabot> Data.Int :: module
21:23:28 <lambdabot> Prelude.Int :: data Int
21:23:28 <lambdabot> Text.Read.Int :: Integer -> Lexeme
21:23:42 <monochrom> instance (Monad m) => MonadMister x (MisterT x m) where ...
21:23:47 <bringert> @hoogle Handle -> IO Integer
21:23:48 <lambdabot> IO.hFileSize :: Handle -> IO Integer
21:23:48 <lambdabot> System.IO.hTell :: Handle -> IO Integer
21:24:03 <monochrom> Do you hate MisterT?  ;)
21:24:05 <hyrax42> @hoogle file size
21:24:05 <lambdabot> Did you mean: File Size
21:24:05 <lambdabot> Prelude.undefined :: a
21:24:05 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:24:20 <hyrax42> anyway, there's the answer
21:24:53 <hyrax42> is hGetContents not lazy?
21:25:01 <monochrom> It is lazy.
21:25:19 <hyrax42> so hGetContents h >>= return . length
21:25:21 <hyrax42> ought to work?
21:25:22 <dons> hFileSize, you want?
21:25:38 <dons> then you don't need to read the file unnecessarily, iirc
21:25:43 <dons> ?type System.IO.hFileSize
21:25:44 <lambdabot> GHC.IOBase.Handle -> IO Integer
21:25:52 <monochrom> length may be inefficient.
21:25:53 <hyrax42> yeah bringert found it eventually :)
21:25:57 <SamB_XP> ah
21:25:57 <dons> ah, yes, i see
21:26:01 <hyrax42> but it wouldn't put the whole file in ram
21:26:06 <hyrax42> as bringert was saying
21:26:16 <hyrax42> or would it
21:26:24 <monochrom> But put it this way.  If you don't actually use the return value, the file won't be read.
21:26:32 <SamB_XP> @hoogle FilePath -> IO Integer
21:26:33 <lambdabot> No matches, try a more general search
21:27:04 <palomer> oh my god
21:27:15 <monochrom> do { n <- hGetContents h >>= return . length; print (const 5 n) }   This will not read the file (yet).
21:27:21 <palomer> I just spent two days debugging an error which was in my parser
21:27:29 <dons> yeah, it calls fdFileSize, which calls fstat
21:27:43 <dons> so use hFileSize :)
21:28:14 <monochrom> yeah use hFileSize.  The OS knows the file size, why not do that.
21:28:30 <hyrax42> true enough
21:28:43 <hyrax42> I haven't been able to play with haskell in a while :/
21:29:00 <hyrax42> no worries, in a couple days
21:29:33 <bringert> thanks guys. I was on the phone while you sorted that one out :-)
21:29:51 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html  make your web browser display this by default on launch and upon pressing the "home" buttom.
21:30:03 <palomer> http://www.rafb.net/paste/results/gk7hsn87.html <--can you guys see how this code is constructing recursive types?
21:32:27 <monochrom> @type Control.Monad.liftM
21:32:28 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
21:32:42 <palomer> ahh, scratch that
21:32:52 <monochrom> hee hee
21:36:05 <monochrom> Actually I don't see what's wrong, assuming conid and arrow have the expected type.
21:36:15 <monochrom> (and varid)
21:36:20 <bringert> hmm hFileSize fails on non-regular files
21:36:29 <monochrom> That's right.
21:36:57 <dons> yep.
21:37:33 <palomer> monochrom: what's wrong?
21:38:17 <monochrom> I don't see what's wrong.  I can't see a recursive type occuring.
21:38:24 <palomer> congratulations haskell, you bring debugging to a new level of obtuseness!
21:40:09 <monochrom> We know about this "viral/bacterial resistance" phenomenon.  So a good language eliminates dumb bugs.  But the result is you get smarter bugs.
21:42:22 <Pseudonym> That's a good argument for not using Haskell everywhere.
21:42:33 <dons> hmm.  i'm not sure bugs breed or share resistance
21:42:33 <Pseudonym> Over-use might make bugs resistant.
21:42:53 <SamB_XP> well, but the bugs in your programs do not breed!
21:43:05 <SamB_XP> I'm pretty sure, anyway!
21:43:06 <dons> yeah. so you always reduce the number of bugs.
21:43:13 <dons> but the pool will consist of harder and harder bugs
21:43:24 <Pseudonym> A former boss of mine once commented that he was allergic to grass, and had to have injections every so often.  "But I haven't kept up with it this season."  I accused him of being responsible for an injection-resistant supergrass.
21:43:44 <Pseudonym> For some unknown reason, he didn't find that amusing.
21:43:49 <dons> lol
21:43:56 <SamB_XP> I don't think it works for allergies either
21:44:11 <Pseudonym> But that's the POINT of geek humour.
21:44:13 <SamB_XP> since allergies are about you being allergic, not about the allergin trying to make you allergic
21:44:33 <Pseudonym> You deliberately feign nonscientific thinking to get a laugh.
21:44:46 <Pseudonym> Sheesh, some people.
21:45:00 <SamB_XP> ah
21:45:32 <SamB_XP> it works better with the tone of voice, I think ;-)
21:46:53 <monochrom> SamB is Pseudonym's boss.
21:47:14 <SamB_XP> I wish!
21:47:18 <SamB_XP> I need a job!
21:47:27 <bringert> dons: the example code is in the repo now
21:47:30 <bringert> http://www.cs.chalmers.se/~bringert/darcs/haskell-cgi/examples/download.hs
21:47:33 * SamB_XP is not even through college yet!
21:47:52 <SamB_XP> I'm glad not to be allergic to grass, though ;-)
21:48:01 <bringert> and the library uses lazy bytestrings for input and output
21:48:13 <bringert> though I haven't stress tested the input
21:48:17 <dons> got it. cheers!
21:48:42 <bringert> I don't think input works lazily, since it has to parse it to find the different input variables
21:49:51 <SamB_XP> bringert: what about bodies?
21:50:20 <bringert> SamB_XP: for most CGI programs, the POST body contains name, value pairs
21:50:44 <bringert> though the library should be extended to allow the body to have any content-type
21:51:22 <bringert> that way it could be used to implement web services etc.
21:54:33 <bringert> dons: is there a regexp library that works with bytestrings yet?
21:54:56 <bringert> I just read the file editing stuff on the mailing list
21:55:36 <bringert> also, it would be cool to port alex to work with bytestrings
21:56:21 <dons> bringert: a) yeah, there is . its a bit raw tough. there's a version in lambdabot, and one in hmp3
21:56:33 <dons> b) simon m reckons that porting to alex is only a few lines
21:56:50 <bringert> nice
21:57:01 <dons> raw though
21:57:05 <dons> not raw tough :}
21:58:05 <bringert> dons: are you going to icfp / hw btw?
21:58:15 <dons> hmm. not sure at this stage
21:58:34 <dons> probably not 
21:58:48 * dons needs to write more papers
22:00:31 <bringert> the hw deadline is all of 36 h away or something (samoan time, funny stuff)
22:00:53 <dons> heh
22:07:42 <wimp> has anyone written a searhfc engine in haskell?
22:27:16 <_frederik_> 190 nicks?
22:27:28 <_frederik_> was this channel always so crowded?
22:28:46 <Lemmih> _frederik_: Nope.
22:32:09 <Cale> It's been up as high as 225.
22:32:44 <palomer> #haskell, the only channel that doesn't empty out on friday nights
22:32:57 <Cale> heh
22:32:58 <monochrom> oh it's friday night?
22:33:15 <Cale> What about #nethack-idlerpg?
22:33:38 <syntaxfree> it's friday morning, actually.
22:33:49 <Cale> It's like an MMO, without all the work.
22:33:56 <syntaxfree> most channels crowd out on weekends, anyway.
22:34:01 <syntaxfree> even the less geeky ones.
22:34:28 <palomer> Cale: any idea how to rotate a tex file?
22:34:53 <syntaxfree> \rotate{90}{text}
22:34:59 * monochrom thinks of all the wrong ideas
22:35:08 <Cale> \documentclass[landscape,...]{article}
22:37:04 <palomer> Cale: doesn't work
22:37:42 <palomer> both for pdflatex and latex
22:41:58 <Cale> hmm
22:42:02 <palomer> oh wait, it does!
22:42:05 <palomer> I just didn't notice it!
22:42:06 <palomer> cool!
22:43:09 <palomer> wait, it's not rotated
22:43:15 <palomer> I'm confused
22:43:19 <palomer> what does landscape do exactly?
22:43:51 <palomer> I want the page numbering to be perpendicular to the text
22:45:50 <palomer> hrmph
22:46:43 <palomer> Cale: I remember you showed me a cool graphics trick to stick all that I need on the page
22:46:44 <palomer> and shrink it
22:46:47 <palomer> what was it?
22:49:36 <Cale> um... hmm what was that?
22:54:16 <palomer> \\resizebox{5in}{4in}{
22:54:31 <palomer> does that only work with either pdflatex or latex?
22:54:44 <Cale> I think so
22:54:52 <palomer> doesn't seem to work with latex
22:55:08 <Cale> you need the graphics or graphicx package
22:55:46 <Cale> http://cnlart.web.cern.ch/cnlart/218/node83.html
22:57:11 <palomer> http://www.rafb.net/paste/results/ZFFAaj92.html <--here's my code
22:58:22 <palomer> http://www.rafb.net/paste/results/BpwVwF60.html <--updated code
22:59:55 <palomer> am I missing something?
23:00:45 <Cale> doesn't look like you are -- are you getting errors?
23:01:17 <palomer> ok, it only works with pdflatex
23:01:21 <palomer> kept trying with latex
23:01:57 <Cale> hm
23:02:03 <Cale> that's interesting
23:02:11 <Cale> and then dvips?
23:02:18 <Cale> or were you leaving it as dvi?
23:02:28 <Cale> It might be using postscript tricks to get those effects
23:02:54 <palomer> pdflatex is fine
23:03:01 <palomer> I was leaving it as dvi
23:03:15 <palomer> btw, what's the max width I can use in landscape?
23:05:13 <Cale> depends on your paper, I think letter is 8+1/2 by 11 in
23:06:36 <syntaxfree> it's interesting how #haskell  is more helpful on latex than #latex
23:07:03 <Cale> A4 is 210 by 297 mm
23:07:46 <syntaxfree> A5 is A4 folded in half.
23:07:57 <syntaxfree> > (297/210)^2
23:07:58 <lambdabot>  2.000204081632653
23:08:14 <syntaxfree> the proportions in the A series are always sqrt(2)
23:11:54 <palomer> Cale: right, but you have to remove the margin with 8.5 x 11
23:24:09 <Cale> yeah
23:24:56 <palomer> impossible to remove the margin completely:(
23:25:02 <palomer> you have to leave an inch!
23:26:11 <dcoutts> dons, mm, a web example would be nice.
23:26:27 <dons> yeah, i think bringert's cgi/download stuff might be good
23:26:31 <dons> or something similar
23:26:41 <dons> check out the graphs in #haskell-overflow
23:26:54 <dons> in particular, http://www.cse.unsw.edu.au/~dons/tmp/loopu_noacc_mapfilter.png
23:26:59 <dcoutts> dons, I had thought of Simon's HWS but something newer like bringert's is probably better
23:27:02 <syntaxfree> let pagesize 1 = (594, 840); pagesize n = ((max (fst ps) (snd ps))/2, min(fst ps) (snd ps)) where ps = pagesize (n-1) in pagesize 4
23:27:10 <dons> origingal, versus up/down, versus up/down/map/filter
23:27:14 <syntaxfree> > pagesize 1 = (594, 840); pagesize n = ((max (fst ps) (snd ps))/2, min(fst ps) (snd ps)) where ps = pagesize (n-1)
23:27:14 <lambdabot>  Parse error
23:27:16 <dons> yeah, or HWS
23:27:16 <syntaxfree> oops.
23:27:23 <syntaxfree> > let pagesize 1 = (594, 840); pagesize n = ((max (fst ps) (snd ps))/2, min(fst ps) (snd ps)) where ps = pagesize (n-1) in pagesize 4
23:27:24 <lambdabot>  (210.0,297.0)
23:27:35 <dcoutts> dons, ooh, so the specialised forms of fusion really are better
23:27:42 <syntaxfree> > let pagesize 1 = (594, 840); pagesize n = ((max (fst ps) (snd ps))/2, min(fst ps) (snd ps)) where ps = pagesize (n-1) in pagesize 5
23:27:43 <lambdabot>  (148.5,210.0)
23:27:45 <dons> whenever blue is lower than green, its better.
23:27:49 <dons> which is almost always
23:28:01 <dcoutts> dons, by a few % in many cases
23:28:07 <syntaxfree> @pl pagesize n = ((max (fst ps) (snd ps))/2, min(fst ps) (snd ps)) where ps = pagesize (n-1)
23:28:07 <lambdabot> (line 1, column 73):
23:28:07 <lambdabot> unexpected "="
23:28:07 <lambdabot> expecting variable, "(", operator or end of input
23:28:16 <dons> dcoutts: yeah, so that's a good result
23:28:20 <syntaxfree> @pl pagesize n = ((max (fst ps) (snd ps))/2, min(fst ps) (snd ps)) 
23:28:21 <lambdabot> pagesize = const (max (fst ps) (snd ps) / 2, min (fst ps) (snd ps))
23:28:35 <dons> i think maybe if we can get noArr loops working too, that'll be a similar benefit to adding noAcc 
23:28:40 <syntaxfree> @pl pagesize n = let ps = pagesize (n-1) in ((max (fst ps) (snd ps))/2, min(fst ps) (snd ps)) 
23:28:40 <lambdabot> pagesize = fix ((ap ((,) . (/ 2) . uncurry max) (uncurry min) .) . (. subtract 1))
23:28:44 <dcoutts> dons, right, yes
23:28:54 <syntaxfree> now, that's something.
23:29:12 <syntaxfree> @type uncurry
23:29:13 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
23:29:31 <syntaxfree> > uncurry max (3,5)
23:29:32 <lambdabot>  5
23:29:41 <dons> dcoutts: so beyond the orignal functional array fusion paper, we can show up/down fusion, up/down/noacc fusion, up/down/noacc/map/filter
23:29:55 <dons> which is a good story
23:30:15 <dcoutts> dons, do we know why loopUp is so much worse than loopU in many cases?
23:30:22 <syntaxfree> > let pagesize 1 = (594,480); pagesize n = ((uncurry max ps)/2, uncurry min ps) where ps = pagesize (n-1) in pagesize 4
23:30:23 <lambdabot>  (148.5,240.0)
23:30:31 <dcoutts> dons, yes, it is a good story
23:30:50 <syntaxfree> Umm. Wrong behaviour!
23:30:52 <syntaxfree> What happened?
23:31:54 <dons> dcoutts: oh, possibly its loopU is doing better than in reality, since i didn't disable it on down loops
23:32:02 <dons> do loopU/down is really loopU/loopDown
23:32:35 <dons> i'll need to #define some loopDown cases that aren't fuseable at all
23:32:57 <dons> so that loopU test on down loops accurately reflect their non-fuseability
23:33:03 <dcoutts> right yes
23:33:22 <syntaxfree> why? :~
23:33:22 <dons> good piont.
23:33:25 <dcoutts> are we still using a single run per benchmark?
23:33:29 <dons> yeah.
23:33:31 <dcoutts> ok
23:33:36 <dons> but perhaps we can just do several runs and combien them
23:33:50 <dons> even reordering the opertions?
23:33:59 <dcoutts> perhaps yes
23:34:26 <dcoutts> I'd like to output all the results from runs of the same test and include that in a spreadsheet
23:34:34 <dcoutts> so we can see what our error margins are
23:34:39 <dons> yep
23:35:02 <dcoutts> so we can tell in the cases where we're doing better/worse if that's beyound the error bars
23:35:12 <syntaxfree> > let pagesize 1 = (594,480); pagesize n = ((uncurry max ps)/2, uncurry min ps) where ps = pagesize (n-1) in fix pagesize
23:35:13 <lambdabot>  add an instance declaration for (Num (b, b))
23:35:17 <dons> yeah, good point.
23:35:35 <syntaxfree> > let pagesize 1 = (594,480); pagesize n = ((uncurry max ps)/2, uncurry min ps) where ps = pagesize (n-1) in fix (fst . pagesize)
23:35:36 <lambdabot>  Terminated
23:46:24 <Itkovian> meuning
