00:00:55 <ADEpt> Lemmih: hi
00:01:24 <Dulath> Korollary: How does that work?
00:02:32 <dons> kzm, so i have a patch for you: http://www.cse.unsw.edu.au/~dons/tmp/faster_fasta.dpatch
00:02:39 <Korollary> Dulath: That just gives you the modulo part. Similarly, you can compare the result to zero.
00:02:47 <Korollary> @type any
00:02:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:02:57 <dons> kzm, if we could avoid having to split the big fasta bodies into lines, and the reconcat them, that'd be a big win again
00:03:00 <Korollary> @type all
00:03:01 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:03:18 <Korollary> > all [True,True,False]
00:03:19 <lambdabot>   Failed to load interface for `ShowQ':
00:03:19 <lambdabot>    Could not find module `Show...
00:03:29 <Korollary> the bot is broken I believe
00:03:30 <dons> oh. my new build system
00:03:36 * dons hacks
00:03:56 <kzm> Fasta.hs:23:45: Not in scope: `B.breakEnd'
00:04:08 <dons> kzm, oh your fps is old
00:04:09 <kzm> I really need a newer BS.
00:04:26 <kzm> It's from ghc 6.5 a few days ago.  Blame Simon & co.
00:04:30 <kzm> :-)
00:04:32 <dons> > all [True,True,False]
00:04:33 <lambdabot>  Couldn't match `a -> Bool' against `[a1]'
00:04:42 <dons> kzm, no, you want the darcs repo
00:04:57 <xerox> > and [True,True,False]
00:04:58 <lambdabot>  False
00:05:00 <dons> we're about 100 patches ahead, at the moment.
00:05:34 <dons> kzm, breakend might be called breakLast in your versoin of ghc
00:05:47 <kzm> I guess I should just remove it from GHC and rebuild GHC without FPS?
00:05:50 <Dulath> Ok
00:05:58 <dons> kzm, yep.
00:06:15 <dons> i think getting the fps head into base should be something i do this weekend
00:06:37 <Dulath> So if any of my results from x `mod` head([2..sqrt(x)]) equal 0, then I know x is not prime
00:06:55 <Dulath> how can I do something like an escape condition from a recursive call?
00:07:30 <Stinger_> if cond then value else recurse?
00:07:34 <dons> a guard. how do you think we normally stop loops ? ;)
00:08:38 <kzm> dropSpaceEnd?
00:08:40 <xerox> > let prime n = all (\p -> n `mod` p =/= 0) [2..sqrt n]
00:08:40 <lambdabot>  Parse error
00:08:44 <xerox> > let prime n = all (\p -> n `mod` p =/= 0) [2..sqrt n] in prime 15
00:08:45 <lambdabot>  Not in scope: `=/='
00:08:48 <xerox> Wops.
00:09:15 <xerox> > let prime n = all (\p -> n `mod` p /= 0) [2..sqrt n] in prime 15
00:09:15 <lambdabot>  Add a type signature
00:09:21 <xerox> Pfft.
00:09:49 <dons> kzm, possibly.
00:09:57 <dons> try it in ghci, to check
00:10:14 <kzm> dons?  Much as I admire the speed of your patch - you are reading everything into memory, aren't you?  IOW:stats3: out of memory (requested 3774873600 bytes) 
00:10:48 <dons> oh, interesting.
00:10:54 <dons> so maybe I should have used .Lazy
00:11:02 <dons> not lazy enough..
00:11:13 <dons> its the strict readFile
00:11:21 <dons> i should replace it with readLines, as you had
00:11:44 <dons> fixing...
00:11:54 <Dulath> Having trouble finding explantion of "guards" in Yet Another Haskell Tutorial
00:12:03 <kzm> Yep.  I was about to say that in practice, I'll work on data sets < RAM, but...
00:12:25 <kzm> I think I want to build an index of some data (< RAM) and stream (possibly larger) datasets over this index.
00:13:16 <kzm> Perhaps we could have an arbitrary hGetDelimited :: Handle -> Char -> IO [ByteString]?
00:13:33 <kzm> hGetLines h = hGetDelimited h '\n' 
00:14:09 <dons> you should be using .Lazy for that :)
00:14:31 <kzm> I could possibly hGetDelimited '>' (but would then need to filter out whitespace - and anyway, it's really ">\n".
00:14:37 <dons> ah, much better. lot less space now
00:14:47 <dons> oh, and a bit faster?
00:14:55 <dons> kzm, you could use split?
00:15:32 <kzm> Okay.  I'll see if I can glue a new FPS onto GHC, and try things out.
00:15:45 <kzm> How does it compare speedwise for you?
00:16:11 <dons> kzm, http://www.cse.unsw.edu.au/~dons/tmp/lazy_fasta.dpatch
00:16:26 <dons> its running in 2s instead of 5.9 on a 30M fasta file
00:16:37 <dons> and using about 20M of heap, i think
00:16:46 <dons> let me see if a .Lazy version brings that down
00:16:49 <kzm> With the strict readFile, I got 60% CPU, so it seems to be IO bound now.  Which is fast enough :-)
00:17:53 <dons> we could still do better, if you avoid the concat
00:18:06 <dons> though maybe it can't be done.
00:18:14 <dons> since you still have to filter out those \ns somehow.
00:18:55 <kzm> I could delay it.  For my app, I'm going to concat them again, so I could have Sequence contain a [ByteString], and just concat it all.
00:19:27 <kzm> What time did strict readFile use on the 30M file?
00:19:45 <dons> 2.0->2.4s, but more memory
00:19:55 <dons> seems around the same as using hGetLines
00:20:03 <dons> the above patch, i mean, not the original hGetLines
00:20:15 <kzm> That's purty good.
00:20:16 <dons> i think it was the filter that was the problem though.
00:20:28 <dons> traversing the whole buffer just to get to the end.
00:24:02 <richcollins> Are there any precompiled haskell binaries for Intel OS X?
00:24:14 <kzm> You're right.  Replacing "filter (not . isSpace)" with "dropSpaceEnd" took it from 40s to 17s.
00:24:28 <kzm> Your strict readFile takes it further down to 14s.
00:24:38 <dons> on how much data?
00:24:48 <kzm> 1M sequence, about half a gig?
00:25:02 <pimaniac> richcollins: yes.  ghc and hugs
00:25:03 <kzm> Still running on the big data set.
00:25:23 <kzm> Seems IO bound now.
00:25:23 <richcollins> pimaniac: And I can use that to compile darcs?
00:26:12 <pimaniac> richcollins: most likely.  I use the static ppc binary, since I found that it worked long before i found a working ghc
00:27:52 <kzm> 10M sequences, 3.6GB, 3:33
00:28:06 <dons> cool, quite an improvement.
00:28:21 <dons> how's that compare to C?
00:28:21 <kzm> > map (/ (3+33/60)) [10000000,3.6*1024]
00:28:23 <lambdabot>  [2816901.4084507045,1038.4225352112676]
00:28:54 <kzm> > map (/ (60*3+33) [10000000,3.6*1024]
00:28:55 <lambdabot>  Parse error
00:29:06 <kzm> > map (/ (60*3+33)) [10000000,3.6*1024]
00:29:07 <lambdabot>  [46948.35680751174,17.30704225352113]
00:29:38 <kzm> 46K sequences/sec, 17MB/sec.
00:30:22 <kzm> I got 1.5-2 minutes streaming through with 'grep' and 'wc'.
00:30:42 <kzm> So a factor of 2, maybe, but we do a lot more work, so it's not directly comparable.
00:30:52 <dons> yeah.
00:31:18 <dons> probably i should tune hGetLines further
00:31:27 <kzm> I got quite a bit of interest from students in my SoC proposals, I wonder if I should arrange a BioHaskell repository.
00:32:01 <kzm> Apparently, there are a few lurkers in the no-mans-land between Haskell and Bioinformatics.
00:32:08 <dons> :)
00:32:23 <kzm> Even if none of *you* care (sniff).
00:32:24 <kzm> :-)
00:33:07 <kzm> BTW, the cabal ld-options; am I supposed to simply add (foreign) .a files that I need?
00:33:37 <dons> hmm. i'm not sure. perhaps check the Cabal user's guide?
00:34:37 <kzm> The docs I found didn't say much beyond using it for linker options (doh).
00:34:56 <kzm> Perhaps name the .a libfoo.a and pass -static -lfoo?
00:35:06 * kzm will try that.
00:35:18 <dons> kzm, is it fair to say that you couldn't write a 500M fasta-filtering program without fps, you think?
00:35:24 <dons> or did you have other tricks for doing it?
00:36:00 <kzm> I could write it all right.  I just couldn't run it. :-)
00:36:30 <dons> right, stack or heap exhaustion? or just too slow?
00:36:33 <kzm> It would take some time.  I think I measured speedup compared to using Char input.
00:37:09 <kzm> My old Fasta had a factor of 10, I think (very roughly).  Multiply by an additional factor of 3 for eliminating the filter?
00:37:16 <Dulath> Hey folks, what types would I need to set to get isPrime x = all (\p -> x `mod` p /= 0) [2..sqrt(x)] to work?
00:37:50 <kzm> Well, I generally read a sequence at a time, and store it (filtered/concatenated) in an array.
00:38:01 <norpan> you need an integer version of sqrt
00:38:13 <kzm> So space would, in the end, be the same, even if you need to keep everything around.
00:38:42 <dons> right.
00:40:17 <Dulath> I've been trying to use the solutions people have suggested for my problem but either I'm not implementing them correctly or I just don't understand how they work and don't know how to use them
00:40:27 <Dulath> incorrectly*
00:40:35 <kzm> And it's not entirely comparable anyway, the comparison used Parsec to do some header parsing :-(
00:40:53 <norpan> Dulath: something like floor (sqrt (fromInteger x :: Double))
00:41:38 <norpan> or fromIntegral
00:42:12 <Dulath> norpan: can I avoid doing that by having some kind of recursive function along the line of isPrime x = x `mod` head([2..sqrt(x)]) == 0?
00:42:33 <norpan> no, your problem is that sqrt works on floats
00:42:36 <norpan> not integers
00:42:42 <kzm> Main advantages of FPS: speed (factor of 10?), ease of use (no need for packing tricks, simpler code), perhaps easier (or at least more efficient) C FFIing?
00:44:35 <Dulath> Sweet!
00:44:39 <Dulath> it works! I just wish I knew how..
00:44:45 <sieni> and last but not least, first-person shooters are fun!!!1!
00:45:02 <norpan> Dulath: it's not optimal though, since you can get precision errors when using floats
00:45:21 <Dulath> I'm happy if it works for numbers 2 to 100
00:45:30 <norpan> then you'd have no problems :)
00:45:44 <norpan> but to be on the safe side, use ceiling instead of floor
00:46:28 <kzm> I can't get ./Setup configure/install --user to work.  It only installs in the system location.
00:46:36 <Dulath> norpan ceiling makes 2 not a prime =)
00:47:02 <norpan> indeed it does
00:47:16 <kzm> And: ld-options: -static -lfoo  still wants to link to foo.so, not foo.a
00:47:41 <norpan> Dulath: better to define an integer sqrt
00:48:18 <Dulath> how exactly does this thing work? 
00:48:57 <norpan> what thing?
00:49:26 <norpan> haskell? ;)
00:49:38 <Dulath> No, this function
00:49:46 <Dulath> But, yeah, haskell, don't get it =)
00:50:02 <norpan> do you mean mathematically or haskelly
00:50:26 <Dulath> the syntax, the haskelly business
00:50:42 <richcollins> Has anyone here successfully compiled darcs on an Intel Mac using ghc 6.4?
00:51:21 <Dulath> norpan: How would I define the types for it?
00:51:26 <norpan> Dulath: it defines a function isPrime, that takes an argument x, then uses the "all" function which takes a predicate and a list and returns True if all elements in the list makes the predicate true
00:51:38 <Dulath> Ahh ok
00:51:42 <Dulath> So that's all
00:51:56 * joelr1 waves
00:52:11 <joelr1> so... who hasn't sent their cv to the simons? :D
00:52:22 <dons> hhehe
00:52:43 <Dulath> norpan: is this some kind of type cast (floor (sqrt (fromInteger x :: Double)))
00:52:59 <norpan> yes, conversion between floating and integer types
00:53:21 <Dulath> Ok, I'll buy that for a dollar
00:54:12 <norpan> :: Double is a type specification, because fromInteger can convert to different kinds of floats
00:56:35 <Dulath> So I thought I'd be clever and do something like isPrime 2..100
00:56:41 <Dulath> But it doesn't like that. how do you get the effect?
00:57:51 <norpan> use the filter function
01:00:43 <Dulath> Aha
01:00:43 <Dulath> Nice
01:00:56 <Dulath> filter isPrime [2..100]
01:04:43 <richcollins> Could someone please help me with a ghc / darcs question:
01:04:44 <richcollins> http://guruza.com/question/92/reward-20.00
01:07:34 <Itkovian> @seen BCoppens
01:07:34 <lambdabot> I haven't seen BCoppens.
01:08:15 <Itkovian> Normally, when ghci infers a type, it should give the most general type possible, right? 
01:08:46 <Itkovian> Have you ever encountered a case where a type inference yields a type which doesn't seem general enough?
01:12:45 <dons> richcollins: perhaps ask on darcs-users@ ?
01:12:45 <richcollins> dons: Just signing up - thanks
01:12:45 <dons> or the #darcs channel. looks like a darcs configure bug.
01:12:45 <richcollins> sorry to bug you guys - but no one was home there
01:12:45 <dons> ah, no problems. just not enough to go on in the paste.
01:12:46 <dons> you should try to work out what line is failing (inspect config.log)
01:12:46 <dons> and then try to reproduce the failing test, outside of configure.
01:13:36 <Dulath> Ok, so I have [2..] and I want it to stop at n using list comprehension. How does one do that?
01:24:58 <dcoutts> wow, did you see that ghc HQ are hiring
01:25:08 <dcoutts> oh if only I didn't have a PhD to finnish...
01:25:11 <dons> yeah!
01:27:55 <dons> dcoutts: i'm thinking we should push all the .Lazy stuff into base this weekend
01:28:03 <dcoutts> dons, fair enough
01:28:22 <dcoutts> dons, and still use loopU ?
01:28:34 <dons> no, using the map/filter/noacc scheme
01:28:38 <dcoutts> ah ok
01:28:48 <dons> but we can then push any further improvements
01:28:53 <dcoutts> right
01:28:57 <dcoutts> so no [ByteString] fusion atm
01:29:20 <dons> well, theres loop/loop fusion, right? its more that .Lazy has settled down enough to be pushed in without fear of bugs
01:40:04 <dcoutts> dons, right
01:42:04 <alar> @hoogle String->(a,String)
01:42:05 <lambdabot> No matches, try a more general search
01:42:33 <dons> @hoogle String -> (a, String)
01:42:34 <lambdabot> No matches, try a more general search
01:42:47 <dons> @hoogle reads
01:42:48 <lambdabot> Prelude.reads :: Read a => ReadS a
01:42:48 <lambdabot> Prelude.ReadS :: type ReadS a
01:42:48 <lambdabot> Prelude.readsPrec :: Read a => Int -> ReadS a
02:53:14 <kzm> Anybody see my mail to hs-libs about the Cabal/static libraries issue?
02:55:30 <Lemmih> Aren't ld-options passed directly to ld?
02:58:51 <alar> has darcs haskell specificity or it can be used with any languages?
02:59:20 <sieni> alar: no, yes
02:59:29 <alar> thanks
02:59:55 <alar> so, darcs is as good as CVS, but somewhat better?
03:00:20 <sieni> alar: much better
03:02:00 * alar puts a memo to himself: study darcs and start using it!
03:02:01 <Lemmih> _WAY_ better.
03:02:45 <alar> well, for me the fact that it is written in haskell is serious advantage :)
03:03:12 <dcoutts> dons, I'm off for the weekend
03:04:12 <dons> ok. cool.
03:04:12 <dcoutts> dons, I shall ponder a build/fold style scheme for arrays
03:04:22 <dcoutts> I reckon it's possible...
03:04:31 <dons> yeah?
03:04:39 <dons> that'd be really cool
03:04:43 <sieni> anyway cvs is deprecated. if you _really_ want something cvs-like, then subversion is better in every respect and is similar in philosophy (basically just conservative extension of cvs)
03:05:20 <dons> darcs is about 20 years of software development better than cvs :)
03:05:38 <dons> first class patches! finally.
03:05:42 <sieni> alar: http://darcs.net/DarcsWiki/DifferencesFromCVS
03:05:43 <dons> how did we live without them?
03:05:47 <alar> sieni: I'm totally unaware of subversion, so if I shouldn't use CVS, I'll take darcs
03:05:55 <sieni> alar: http://darcs.net/DarcsWiki/DifferencesFromSubversion
03:06:06 <alar> thanks
03:06:20 <kzm> True.  And simple repo setup.  No more pserver or databases.
03:06:27 <alar> dons: how did you calculate those 20 years? :)
03:06:49 <dons> well, the first cvs was about 1985, yeah? and darcs around 2005.
03:06:56 <dons> a lot happened in those 20 years.
03:06:59 <kzm> count LOC, mulitply by ten (for C overhead), and divide by average programmer output?
03:07:21 <dons>        Walter  F.  Tichy,  RCS--A  System  for  Version  Control,
03:07:22 <dons>        Software--Practice   &   Experience  15,  7  (July  1985),
03:07:22 <dons>        637-654.
03:07:23 <dons> :)
03:08:11 <dons>  the  cvs shell script version posted to comp.sources.unix in the volume6  release of  December,  1986.
03:08:54 <alar> oh
03:09:13 <dons> so we're now at the point that we can actually consider writing an rcs where patch properties are encoded and checked statically by the type system.
03:09:30 <dons> that's an amazing improvement, i reckon :)
03:09:51 <alar> >In darcs, tags apply to the whole tree.
03:10:13 <alar> How many times I wantes this for some SF projects!!
03:10:17 <alar> wanted
03:10:26 <kzm> alar: you get that with SVN as well, don't you?
03:10:44 <alar> what is SVN?
03:10:49 <kzm> subversion. Sorry.
03:11:09 <alar> never used subversion
03:12:12 <kzm> CVS done right. :-)  But still relies on central server, and quite cumbersome to set up.  Or at least, it was a couple of years ago, when I last used it.
03:12:18 <alar> dons: patch properties checked by typesystem? Is it possible?? It would be amazing!
03:12:44 <dons> alar, using GADTs, there's been some attempt to add this to darcs since the Haskell Workshop last year
03:13:07 <dons> checking the theory of patches axioms
03:13:09 <flux__> what kind of properties are we talking about? that is, how much better is that to checking if it compiles with the patch?
03:13:23 <dons> things like commutability of patches
03:13:46 <alar> theory of patches? Never heard of one
03:13:58 <dons> so, the metalogic of darcs, checked by the compiler
03:14:00 <flux__> so it gives you information on the dependencies of the patch?
03:14:07 <dons> alar, check the darcs website
03:14:13 <dons> ?google darcs theory of patches
03:14:14 <lambdabot> http://abridgegame.org/darcs/manual/node7.html
03:14:25 <flux__> I've sometimes wondered if there could be a patching system that would survive renaming symbols..
03:14:50 <flux__> and reordering code, etc
03:14:55 <alar> > am a physicist, and think like a physicist. 
03:14:56 <lambdabot>  Parse error
03:14:56 <flux__> it would obviously need to be language-specific
03:14:58 <alar> =)))
03:16:15 <alar> flux: I think there is a way to transfer language-specificity from the system to patches
03:24:15 <kzm> flux__ doesn't darcs do it for renaming?
03:24:55 <kzm> (darcs replace)
03:25:21 <flux__> hmm.. I'm not all that familiar with darcs actually, I've just used darcs record, and not a lot of that ;)
03:26:42 <kzm> darcs replace replaces one token with another.  You get to specify the alowable characters making up the token, so each patch is lightly language specific, but the mechanism is general
03:27:48 <flux__> well I can imagine that actually works in those cases
03:28:09 <norpan> i can imagine a lot of "semantics-specific" patches but it's hard to fit in the patch-is-a-diff concept
03:33:10 <alar> @hoogle isPrefixOf
03:33:11 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
03:33:59 <sehute> > foldr (+) 0 (cycle [1,2,3,4,5])
03:34:01 <lambdabot>  Exception: stack overflow
03:34:14 <sehute> hugs segfaults at this
03:40:29 <dons> using the latest hugs?
03:41:27 <dons> sehute: you can perhaps report a hugs bug.
03:42:28 <alar> sehute: ERROR - C stack overflow
03:42:36 <alar> my hugs says this
03:42:42 <sehute> dons: on my way :)
03:43:20 <eivuokko> Is it maybe in Windows and gcc-built hugs?  I think gcc can't catch SEH-exception from stack overflow.
03:43:35 <sehute> It's 64-bit Linux and ubuntu's hugs
03:43:44 <eivuokko> nvm then :)
03:44:24 <dons> it might have been fixed in the latest hugs release. sehute, are you using the May 2006 hugs?
03:44:47 <sehute> dons: Version: 98.200503.08-4ubuntu1
03:45:45 <alar> is it Mar 2005?
03:46:32 <dons> yep. can you try again with hugs 200605?
03:46:53 <dons> i think this bug might have been fixed.
03:47:19 <sehute> dons: sure, I'll check it out
04:00:52 <kzm> With +RTS -N4, I can count seven threads with ps.  Is that expected?
04:26:04 <norpan> hey guys, before i google, does anyone know what the status is with ghc and creating .so files for use in Linux
04:26:55 <sieni> norpan: what about it? shouldn't it be supported just like that?
04:27:06 <norpan> it wasn't before
04:27:16 <norpan> something with position-independant code
04:27:39 <norpan> independent may be the spelling
04:27:50 <sieni> hmm...
04:28:10 <norpan> http://www.haskell.org/hawiki/DynamicLinkingInGhc was googled
04:29:34 <sieni> strange...
04:30:09 <norpan> although that page is about dynamically linked haskell libraries, but i want haskell callable from c in an .so file
04:31:59 <norpan> http://www.haskell.org/ghc/docs/latest/html/users_guide/win32-dlls.html but for Linux
04:45:56 <kzm> dons?  I need to do a map and a reverse on a BS -- will fusion help me here?
04:48:33 <Cale> kzm: probably
04:49:53 <kzm> Must I do something myself, of will happen by magic?
04:49:56 <roconnor> Does Cairo have an SVG backend?
04:49:59 <Cale> magic
04:50:31 <kzm> Nice.
04:50:52 <alar> magic deforestation =)
04:51:14 <Cale> roconnor: yes, but most of cairo's backends aren't supported by Gtk2Hs, at least last time I looked.
04:51:41 <roconnor> Cale: I want to make some diagrams.
04:51:53 <norpan> nope, just tried it, linking statically works, but linking dynamically produces strange segmentation faults
04:52:00 <norpan> so it is as it was before
04:52:26 <roconnor> ploting lines in finite files (F_11)^2
04:52:32 <roconnor> ploting lines in finite fields (F_11)^2
04:52:40 <Cale> actually, I think they got svg loading working at least...
04:52:47 <roconnor> :)
04:52:57 <Cale> roconnor: Isn't it possible to do that with an array of asterisks :)
04:53:02 <roconnor> ;)
04:53:10 <Cale> (go nethack-style graphics!)
04:53:25 <roconnor> Is there a ascii art backend for Cairo?
04:53:48 <roconnor> what do I need to do to be able to use Cairo?
04:54:32 <roconnor> as in what do I download?
04:54:33 <Cale> Get Gtk2Hs and compile it, and make sure Cairo support is enabled, which it will be if cairo is installed.
04:54:42 <Cale> @where gtk2hs
04:54:42 <lambdabot> http://haskell.org/gtk2hs/
04:55:38 <roconnor> oooh, Cairo syntax looks like logo
04:56:05 <norpan> weee turtle programming!
04:57:37 <Cale> yeah, it does
04:57:49 <Cale> in fact, it was basically ideal for generating l-systems :)
04:58:48 <roconnor> Is it good for teaching FP to Grade 4 students?
04:59:53 <Cale> well, if you wrote a reasonable wrapper around it, perhaps
05:00:02 <Cale> (like xerox did)
05:05:16 <noj> dons, hey. time to bug you again about the state of ghc/darcs/hugs in OpenBSD :)
05:05:41 <noj> re: update to ghc 6.4.2 and update of darcs and removal of runtime dep on ghc for darcs
05:09:16 <dmhouse> afternoon all
05:09:36 <dmhouse> Let's see, shall we?
05:09:38 <dmhouse> @help tell
05:09:39 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
05:09:43 <dmhouse> yay :)
05:10:13 <dmhouse> @tell dons Take it you got the patches then. Thanks for the speedy push :)
05:10:13 <lambdabot> Consider it noted
05:10:27 <roconnor> hmmmm, tricky
05:10:36 <roconnor>  libghc6-cairo-dev depends on ghc6 (>= 6.4.1); however:
05:10:36 <roconnor>   Version of ghc6 on system is 6.4-4.1ubuntu2.
05:10:39 <roconnor> ...
05:10:48 <roconnor> Maybe I should  build from sources.
05:11:00 <dmhouse> What version of GHC is that?
05:11:05 <norpan> @tell norpan i love you
05:11:06 <lambdabot> You can tell yourself!
05:11:09 <norpan> hehe
05:11:21 <alar> @tell dmhouse someone should probably start oasisbot again?
05:11:21 <lambdabot> Consider it noted
05:11:22 <norpan> shouldn't that be "can't"?
05:11:41 <alar> no
05:11:48 <dmhouse> norpan: It's meant as in "No, I'm not noting that for you, go tell yourself"
05:11:49 <lambdabot> dmhouse: You have 1 new messages. '/msg lambdabot @messages' to read them.
05:11:53 <alar> it should be "you can tell it yourself"
05:11:57 <norpan> yes
05:12:00 <norpan> either or
05:12:05 <dmhouse> hrm, gotta fix those plurals.
05:12:09 <dmhouse> alar, what's up with oasisbot?
05:12:10 <norpan> but the current reply doesn't grammar check
05:12:12 <dmhouse> @clear-messages
05:12:13 <lambdabot> Messages cleared.
05:12:29 <alar> dmhouse: no oasisbot
05:12:33 <alar> in channel
05:12:41 <dmhouse> Ah, cool
05:12:45 <dmhouse> I'll restart him then,.
05:12:47 <alar> don't know what happened
05:12:52 <dmhouse> While I'm at it I'll darcs pull
05:15:19 <dmhouse> alar, can you ssh to vincenz's computer? It just hangs for me.
05:15:41 <dmhouse> Perhaps his system's crashed (which would explain the lack of oasisbot).
05:15:54 <dmhouse> @instances Fractional
05:15:55 <lambdabot> Double, Float
05:15:58 <dmhouse> great, that's fixed too
05:17:50 <alar> dmhouse: I can't, not at home now
05:18:08 <dmhouse> Okay.
05:18:25 <dmhouse> @tell vincenz oasisbot has quit and I can't get ssh working to your comp. Something up?
05:18:25 <lambdabot> Consider it noted
05:20:16 <alar> =)
05:20:17 <alar> nice
05:21:23 <BCoppens> @help tell
05:21:23 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
05:21:24 <alar> dmhouse: does it handle 8-bit characters well?
05:26:24 <dmhouse> alar, don't see why it shouldn't, it's all Strings.
05:27:22 <norpan> räksmörgås
05:28:27 <dmhouse> @tell alar Gïve it æ try! @łe¶ŧ←↓→øþæßðđŋħjĸł«»¢“”nµ─·
05:28:28 <lambdabot> Consider it noted
05:29:25 <alar> .
05:29:25 <lambdabot> alar: You have 1 new messages. '/msg lambdabot @messages' to read them.
05:30:04 <alar> @messages
05:30:04 <lambdabot> You can only use @messages in a /msg
05:30:39 <dmhouse> Yeah, I'm removing that limitation as we speak. :)
05:31:11 <alar> :)
05:35:08 <kzm> More cabal issues: can't seem to link with my newly created library.
05:35:36 <norpan> well it should just store the bytes right?
05:35:49 <norpan> and String is by accident good at storing bytes
05:36:01 <kzm> Never mind - I modified the lib, obsoleting one of my source files :-)
05:36:14 <norpan> re @tell
05:37:33 <dmhouse> alar, did the unicode test work, though?
05:37:46 <dmhouse> it might not get through the IO untouched.
05:40:46 <norpan> big problem with irc that it doesn't have charset information
05:40:49 <wilx> Wow! GHC engeneer job position.
05:41:00 <norpan> although more and more realize that UTF-8 is the one, true way
05:41:09 <wilx> Sounds interesting.
05:41:13 <norpan> indeed
05:41:28 <norpan> to fix shared libraries in linux perhaps :)
05:43:04 <dmhouse> @where lambdabot
05:43:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:44:45 <dmhouse> @tell dons what did you mean by 'pointfree won't work with impredicativity (?)'?
05:44:45 <lambdabot> Consider it noted
05:47:09 <roconnor> ooooooooooh, I have lines!
05:48:12 <roconnor> anyone have some test code that generates SVG?
05:56:53 <roconnor> oh wait. I don't want to load SVG, I want to write SVG.
05:56:57 <roconnor> :(
06:02:49 <norpan> writing is always easier. my comment doesn't help you :)
06:04:34 <roconnor> so cairo has no SVG output backend?
06:06:19 <dons> noj, re the ports, i haven't been working on them much recently, as you know. but i've been patching ghc 6.5 cvs, the ghci issue that appeared should be solved now in ghc. 
06:06:20 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:06:27 <dons> oh, very nice!
06:06:31 <dons> ?karma+ lambdabot
06:06:32 <lambdabot> lambdabot's karma raised to 13.
06:06:59 <sieni> roconnor: http://cairographics.org/backends
06:07:38 <dons> dmhouse: regarding the impredicativity (i think) issue. i just noticed that in 6.5, a point free fragment failed, explicitly applying it worked. may be an interaction with implicit params though
06:08:04 <dmhouse> dons, ah, okay.
06:08:16 <dmhouse> At first I thought I'd accidentally pasted something from #haskell into the patch :)
06:08:36 <dons> oh. heh
06:08:43 <dmhouse> dons, version 2 is coming up.
06:08:53 <dons>  @tell worked very nicely just then. i was quite surprised. very useful!
06:09:10 <dons> ?karma+ petekaz -- contextual plugins rock
06:09:10 <lambdabot> petekaz's karma raised to 2.
06:09:27 <roconnor> ah svg!
06:09:46 <dmhouse> it features a better @messages? command (instead of just saying 'You have X new messages', it just prints the normal reminder messages). Also @messages will work in-channel if you explicitly use it.
06:09:55 <roconnor> but how do I use it?
06:10:07 <dons> dmhouse: ok. good
06:10:08 <dmhouse> And I added an @ask, which is just like @tell, but prints it as "foo asked 4 hours ago <message>".
06:10:22 <dmhouse> It's more natural in some situations.
06:10:35 <dons> ah. good. how's the new build system, have you been trying it?
06:10:41 <dmhouse> yep, seems to be working well :)
06:10:42 <dons> i totally removed make today, as you see
06:10:46 <dmhouse> yeah.
06:10:56 <kzm> Aargh.  How do I break a BS into equally-sized chunks?
06:11:05 <dmhouse> I'm now stuck wih a load of binaries in my lambdabot dir and no make clean to rm them :) Hehe.
06:11:13 <dmhouse> I'll pull an old Makefile.
06:11:16 <dons> kzm, oh, regarding 'reverse'. it won't fuse with map yet.. we've got schemes though.
06:11:24 <dons> the better solution is to write reverse in terms of foldr
06:11:31 <ndm> dons, what is thew new make system?
06:11:36 <dmhouse> ndm, Cabal.
06:11:42 <roconnor> oh wait, cairo has a svg backend, but it isn't available in haskell?
06:11:49 <dons> ndm, oh, i just ported lambdabot's byzantine build system to cabal
06:11:49 <ndm> dmhouse: thanks
06:11:58 <kzm> @hoogle Int -> ByteString -> [ByteString]
06:11:59 <lambdabot> No matches, try a more general search
06:12:09 <dons> kzm, drop/take ?
06:12:11 <ndm> kzm: no bytestring stuff in hoogle (yet)
06:12:11 <roconnor> @hoogle SVG
06:12:12 <lambdabot> No matches found
06:12:17 <dmhouse> ndm, Hoogle's been having some issues lately. Seems to dislike the hierarchial modules.
06:12:19 <ndm> or SVG stuff
06:12:20 <dmhouse> @hoogle isUpper
06:12:21 <lambdabot> Char.isUpper :: Char -> Bool
06:12:36 <ndm> dmhouse: thats deliberate, it chooses Haskell 98 functions over Data.Char stuff
06:12:51 <dons> ndm, btw, if you port hoogle to use the hierarchical modules, i can remove a haskell98 dep in the lambdabot build system ;)
06:12:55 <ndm> in the next release, i'll probably reverse that preference, to use new style modules
06:12:59 <dons> i.e. Data.List instead of List
06:13:06 <ndm> dons: i'll happily accept a patch
06:13:12 <dons> ok :)
06:13:15 <ndm> and if you don't patch it, i probably will sooner or later
06:13:16 <kzm> Isn't the break and split dichotomy a bit contrieved?
06:13:27 * dons tries to shrink the number of lambdabot deps
06:13:36 <dons> Build-Depends:       base, unix, network, parsec, mtl, haskell-src, haskell98, readline, plugins>=1.0, fps>=0.7
06:13:39 <ndm> actually, i could do with a bit of hacking
06:13:45 <ndm> i'll convert hoogle now :)
06:13:56 <dons> kzm?
06:15:08 <kzm> split, splitAt : -> (BS,BS), splitWith : -> [BS], break : -> (BS,BS)
06:15:24 <kzm> Guess it's inherited from the prelude...
06:15:33 <dons> ?type splitAt
06:15:34 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:15:41 <dons> ?type Data.ByteString.splitAt
06:15:42 <lambdabot> Int -> Data.ByteString.Base.ByteString -> (Data.ByteString.Base.ByteString, Data.ByteString.Base.ByteString)
06:15:48 <dons> yeah
06:15:53 <kzm> Right.
06:16:15 <petekaz> @messages
06:16:15 <lambdabot> You can only use @messages in a /msg
06:17:35 <kzm> Anyway - I'd like more functions of the splitWith kind, i.e. recursing over the whole string/list.
06:18:01 <kzm> And a pony.
06:18:02 <kzm> :-)
06:18:17 <dons> and a pony. have you been a good boy this year, little kzm?
06:18:34 <dons> or will you get coal. i should check my good/bad list
06:18:52 <dmhouse> petekaz: I'm changing that.
06:18:53 <lambdabot> dmhouse: You have 1 new messages. '/msg lambdabot @messages' to read them.
06:19:08 * kzm is trying to be good.  He's just a very bad wizard.
06:19:16 <dmhouse> petekaz: and thanks :)
06:19:35 <kzm> Hmm.. the prelude only defines break and splitAt?
06:19:52 <dons> yeah, split, splitWith are our extensions
06:20:00 <dons> taken from ideas in MissingH
06:22:11 * dmhouse tries to fathom Text.Printf
06:22:35 <dons> > printf "%d" (7::Int) :: String -- nothing to fathom, other than how it does it :)
06:22:35 <lambdabot>  "7"
06:23:02 <dmhouse> right, but I'm getting very weird typechecking errors.
06:23:12 <dmhouse> > printf "%d" 7 :: String
06:23:13 <lambdabot>  Add a type signature
06:23:18 <ndm> dons, hoogle patch now pushed, all using heirarchical modules - if i missed any just let me know
06:23:23 <dmhouse> hmm, why's that?
06:23:43 <dons> dmhouse: it needs to dispatch to a particular instance for the argument type
06:23:56 <dons> so they're constrained to monomorphic types
06:24:00 <dmhouse> ah, right.
06:24:16 <dmhouse> hrm
06:24:17 <dons> ndm, great. i'll resync.
06:24:19 <shapr> @yow !
06:24:20 <lambdabot> Couldn't find fortune file
06:24:23 <dmhouse> and what could cause a 'No instance for (Text.Printf.IsChar [Char])'?
06:24:39 <dons> @tell shapr lambdabot's doing some fun things these day
06:24:39 <lambdabot> Consider it noted
06:25:42 <lisppaste2> dmhouse pasted "Text.Printf error" at http://paste.lisp.org/display/21057
06:25:52 <dmhouse> dons, more specifically, ^^ is what I'm trying to fathom.
06:26:00 * dons looks
06:26:38 <dons> do you need to constrain the printf result type?
06:26:44 <dons> ie. .:: String, as I did above?
06:27:18 <dons> (length msgs) shouldn't need a type:
06:27:20 <dons> ?type length
06:27:21 <lambdabot> forall a. [a] -> Int
06:27:57 <dons> other than that, hmm, a confusing error, indeed
06:27:58 <Igloo> Are you using messages :: [String] as String?
06:28:03 <dmhouse> ah, constricting the result type worked :)
06:28:31 <dmhouse> Igloo: nope. that if statement expands to 'if length msgs > 1 then ("messages", "them") else ("message", "it")'
06:28:33 <dons> Igloo: ah yes. that's another one. yeah, i should think of that more often than i do
06:29:02 <dmhouse> dons, do I have to ./Setup.hs install to run a lambdabot?
06:29:03 <Igloo> Ah, I see
06:29:23 <dons> dmhouse: yep. and specifically, you need to install it back into the pwd
06:29:32 <dons> i.e configure --bindir=`pwd` ; build ; install
06:29:48 <dmhouse> ah.
06:29:50 <dons> lambdabot's never supported out-of-tree running :)
06:29:53 * dmhouse starts again :)
06:30:02 <dons> or, run it in ghci..
06:30:13 <dmhouse> Or do that.
06:30:20 <dons> 'sh make ghci' should be enough
06:30:33 <dons> sorry, 'sh ./ghci Main.hs'
06:31:47 <dmhouse> why the sh?
06:31:58 <SamB> Cabal ought to provide better support for in-tree running
06:32:01 <dmhouse> Would a chmod alleviate the need for that?
06:32:12 <dons> dmhouse: yep.
06:32:26 <dons> but remember darcs doesn't preserve chmods without a special flag
06:32:32 <dmhouse> right
06:33:08 <Dulath> Hey folks, any ideas to make this viable?
06:33:09 <Dulath> factorLogic 1 i = 1
06:33:09 <Dulath> factorLogic n i = if n `mod` i == 0 then i : factorLogic((div n i) i) else factorLogic(n i +1)
06:33:34 <dmhouse> Dulath: n i?
06:33:42 <dmhouse> oh, I know what you mean
06:33:48 <dmhouse> factorLogic n (i + 1)
06:33:50 <Dulath> prime factorization
06:34:11 <dmhouse> yeah, but at the end, factorLogic(n i+1) means factorLogic((n i) + 1)
06:34:20 <Dulath> Ooh
06:34:44 <dmhouse> Dulath: in general, you don't need parentheses for function application
06:34:51 <dmhouse> > let f x = x + 1 in f 5
06:34:53 <lambdabot>  6
06:35:25 <Dulath> Well I'm getting type mismatch errors
06:35:33 <norpan> of course you do
06:36:07 <Dulath> Any ideas why?
06:36:11 <norpan> the syntax if f (arg1) (arg2) and not f(arg1 arg2) and the parenthesis are optional
06:36:13 <dmhouse> Dulath: what's your current code?
06:36:25 <Dulath> factorLogic 1 i = 1
06:36:25 <Dulath> factorLogic n i = if n `mod` i == 0 then i : factorLogic((div n i) i) else factorLogic(n (i+1))
06:36:45 <norpan> so that should be factorLogic (div n i) i etc
06:36:55 <Dulath> ok
06:36:59 <kzm> I just finished converting a program to read data with FPS.
06:37:10 <dons> kzm, nice. how's it run?
06:37:18 <dmhouse> yeah, factorLogic(n (i+1)) means call the function n with parameter i+1, then feed that into factorLogic
06:37:23 <kzm> Well, the good news is that reading data is indeed a lot faster.
06:37:43 <kzm> The bad news is that the core of the program is still the same, and that's where most of the time is spent :-9
06:37:43 <Dulath> does the first definition make any sense? if n is 1 I want to return 1, regardless of what i is?
06:37:51 <dons> fair enough.
06:38:02 <dons> so you can populate your arrays faster
06:38:03 <kzm> But I got a 15% overall improvement, which was better than I expected.
06:38:17 <dons> what does the core do??
06:38:22 <dons> s/\?//
06:38:45 <kzm> stores word hashes in a Map, and then queries it.
06:38:49 <dons> i wonder if you can take advantage of more 0-copy substrings and such like.
06:38:56 <dons> ah. hmm.
06:39:20 <dons> what's the bottleneck?
06:39:25 <dons> looking up the Map?
06:39:34 <kzm> If there is a really really fast way to compare BSs, I could use substrings directly in the FM.
06:39:35 <noj> dons,    bin/ghc::lang/ghc
06:39:35 <noj> ~
06:39:35 <noj> ~
06:39:35 <noj> ~
06:39:40 <noj> oops, wrong paste
06:39:47 <dons> kzm, well, compare is a memcmp.
06:39:49 <kzm> building and lookup is about 50% each, I think.
06:39:52 <noj> dons, http://vexed.se/~jon/misc/darcs-1.0.7.patch
06:39:52 <norpan> Dulath: yes, it makes sense
06:40:15 <noj> initial patch (still building on my slow-ass i386 machine), it removes runtime dep on ghc for darcs
06:40:30 <dons> noj, looks good. cheers.
06:40:31 <kzm> but since I really only have a four letter alphabet, I can usually get by comparing Ints, or occasionally Int64.
06:40:44 <noj> dons, oops, should probably be "GHC_RUNTIME?= YES"
06:40:53 <noj> not "GHT_RUNTIME= YES"
06:40:55 <noj> :)
06:41:13 <dons> heh
06:41:20 <noj> rerolling diff
06:41:22 <kzm> If I could make a BS variant that stores two-bit values, it might be competitive?
06:41:44 <dmhouse> @localtime dons
06:41:45 <noj> dons, reload the url
06:41:46 <lambdabot> Local time for dons is Fri Jun  9 23:32:55 2006
06:41:56 <dmhouse> dons, is it too late to sneak in version two of @tell this evening?
06:42:00 <dons> noj. thanks
06:42:00 <SamB> kzm: sounds kinda crazy
06:42:08 <dons> dmhouse: nope. i'm staying up for the football
06:42:13 <dons> so send away
06:42:19 <dmhouse> Great.
06:42:20 <kzm> But I'm going to use an FMIndex -- if somebody can help me link with those static libraries, that is :-)
06:42:33 <kzm> SamB, crazy, moi?
06:42:53 <SamB> kzm: I mean, I'm sure you could do it, but I'm not sure how well it would perform with sub-byte slicing!
06:43:29 <kzm> Ah, that.  Right.  I may be able to get by with only byte slicing.
06:43:30 <dons> well, i can imagine some Data.Bit hacking on bytestrings. that would be useful
06:44:00 <kzm> At worst, you could make none-byte-boundary slices by copying the whole thing shifted a bit or two, and slicing that.
06:44:09 <kzm> Or just copying the slice, of course.
06:44:20 <dmhouse> dons, sent.
06:45:11 <SamB> kzm: indexing would probably be slightly less annoying than writing the memory read code for an MMIX simulator
06:45:43 <SamB> fortunately, you wouldn't have to do anything like the memory write code ;-)
06:45:51 <kzm> Hehe.
06:46:20 <kzm> I'm certainly not attempting any of those tasks - bitstrings or MMIX - until I run out of alternatives.
06:46:29 <SamB> (nor would you have to go anywhere near the crazy MMU that Knuth put on that thing)
06:47:43 <kzm> It should be possible to build GHC 6.5 with 6.0.1, right?  Even on Sparc/Solaris?
06:47:47 <SamB> well, you'll not likely run out of alternatives to writing an MMIX simulator
06:48:32 <SamB> I think Knuth is crazy to allow unaligned memory access
06:49:20 <SamB> especially so to round down the address to the nearest aligned one
06:51:53 <dmhouse> Anyone got a copy of Types and Programming Languages they don't want any more? :)
06:52:02 <dons> heh
06:53:06 <SamB> but the page map format is even crazier :-(
06:54:07 * shapr boings furiously upon reading the GHC contracting post.
06:54:07 <lambdabot> shapr: You have 1 new messages. '/msg lambdabot @messages' to read them.
06:54:11 <shapr> whoa cool
06:54:24 <shapr> That rocks
06:54:43 * shapr sends in blurb and resume
06:56:20 <dons> ?quit new code
06:56:52 <shapr> Are messages persistent across invocations?
06:56:57 <dmhouse> shapr, not yet.
06:57:01 <shapr> k, just curious
06:57:02 <dons> dmhouse: they're not?
06:57:15 <dons> oh, no serialiser?
06:57:16 <dmhouse> ClockTime doesn't instantiate Read, so I can't write a serialising function.
06:57:26 <dons> yeah, right. how do we do it in Seen?
06:57:26 <shapr> Make your own instance?
06:57:31 <dons> oh we use Alttime?
06:57:35 <dmhouse> hmm?
06:57:46 <dmhouse> I'll have a look.
06:57:48 <dons> Lib/AltTime.hs
06:58:01 <dons> we use clocktime (serialisable) in Plugin/Seen
06:58:04 <shapr> Anyway, I have to do some work and then go get my unicycle fixed, I'll be back online on Sunday.
06:58:21 <dmhouse> dons, great, I'll see if I can switch it over.
06:58:37 <dons> ?version
06:58:38 <lambdabot> lambdabot 3.1p90, GHC 6.5 (OpenBSD i386 )
06:58:38 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:58:53 <dons> ?tell dmhouse i applied your patch
06:58:53 <lambdabot> Consider it noted.
06:58:58 <dons> ?help tell
06:58:59 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
06:59:05 <dons> ?listcom tell
06:59:05 <lambdabot> Unknown command, try @list
06:59:09 <dons> ?listc tell
06:59:09 <dmhouse> @messages?
06:59:09 <lambdabot> #darcs #flippi #gentoo-haskell #haskell #haskell-blah #haskell-overflow #haskell.es #haskell.it #haskell.se #haskell_ru #perl6 #scannedinavian
06:59:10 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
06:59:14 <dmhouse> @messages
06:59:14 <lambdabot> dons said less than a minute ago: i applied your patch
06:59:26 <dons> coo
06:59:30 <dons> l
07:06:56 <dmhouse> dons, any reason why AltTime.ClockTime doesn't instantiate Eq?
07:07:09 <dons> no reason i'm aware of
07:07:14 <dmhouse> (System.Time.ClockTime doesn't either)
07:07:33 <dmhouse> But comparing seconds and picoseconds should work okay.
07:09:48 <dmhouse> dons, and for future reference, it's no longer necessary to reconfigure after adding a Plugin, right?
07:11:32 <dons> right. you just add it to Modules.hs
07:11:48 <dons> the preprocessor takes care of all the other magic
07:12:37 <dmhouse> dons, cool. One final thing :) Testing serialisation. Can I just @quit and rerun lambdabot and expect it to keep the state?
07:12:44 <dons> yep
07:12:58 <dons> hopefully i didn't break the serialiser. i've got a couple of doubts..
07:14:08 <dons> i'm a bit suspicious that @quit quits too quickly, and doesn't flush the state.
07:14:31 <dons> after i was hacking around the runIrc exception handler yesterday
07:14:54 <dmhouse> hmm. So it seems.
07:14:59 <dons> ah. right.
07:15:04 <dmhouse> moduleSerialize _ = Just mapSerial
07:15:14 <dmhouse> ^^ That's all I need to enable serialisation, yeah?
07:15:20 <dons> the bug's in runIrc. the main thread should really catch the exceptions and quit, but i don't think that's happening then.
07:15:23 <dons> i'll fix it tomorrow.
07:15:27 <dmhouse> Okay.
07:15:56 <dons> you can test the serialiser yourself though, by reading and writing the state file in moduleInit and moduleExit
07:16:11 <dons> rather than relying on the bot to do tha for you.
07:16:25 <dmhouse> How do I access it? readFile etc?
07:16:43 <dons> yeah, just read and write State/tell
07:17:11 <dmhouse> right, okay
07:17:20 <dmhouse> I'll try. It should be easy enough.
07:18:37 <dons> well, the exception handling is way too obfuscated and tricksy. but have a snoop
07:18:44 <dons> you can see how we are supposed to do it in runIrc'
07:19:10 <dons> and then look at IRC.hs:readerLoop/writerLoop to see where the exceptions are thrown
07:19:27 <dons> the key is that we need to catch an error call exception thrown back to main
07:19:56 <dmhouse> Err, I meant I'll try testing the serialisation ;) :)
07:20:03 <dons> ah, ok :)
07:20:07 <dmhouse> With module{Init,Exit}
07:20:08 <dons> i thought you were keen... ;)
07:20:24 <dmhouse> If I've got time later, I will.
07:20:35 <dmhouse> I do have something else I need to get done this afternoon.
07:20:49 <dons> another thing worth doing would be to port either @eval or the log plugin to use contextual
07:21:09 <dons> particualrly the log plugin, it uses these semi-hacky call backs, when it could just filter the contextual input now.
07:21:48 <lisppaste2> dmhouse pasted "Would this work as a serialiser test?" at http://paste.lisp.org/display/21060
07:22:29 <dons> won't moduleInit need to writeMS ?
07:22:40 <dons> oh, maybe deserialise does this.
07:22:54 <dons> no, you just print it, right?
07:23:01 <dons> you'll want to actually stick it in the state :)
07:23:04 <dmhouse> I suppose I could writeMS, too.
07:23:17 <dons> well, its not going to get restored otherwise
07:23:40 <olliej> gah
07:23:43 * olliej is going mad
07:23:44 <dmhouse> No, but print would suffice for testing.
07:23:56 <olliej> so many different definitions of what a damn thunk is
07:24:08 <dons> olliej: hehe
07:24:09 <dmhouse> bah, ByteStrings as well.
07:24:29 <olliej> dons: am trying to write thesis
07:24:54 <dmhouse> does ByteString have a {read,write}File?
07:25:00 <dons> sure
07:25:03 <olliej> dons: in my compiler thunk = special data typed subclass for non-strict eval
07:25:28 <olliej> dons: in my thesis thunk means the function + environment the the thunk class wraps
07:25:55 <olliej> dons: and instantly i have 'thunk' meaning two different things in same sentence
07:26:00 <olliej> *sigh*
07:26:21 <dons> hehe
07:26:24 <olliej> one of them now needs to become "proxy"
07:26:40 <olliej> and then i can cite GoF book
07:26:44 <olliej> yay!
07:26:59 <olliej> dons: incidentally have full support for higher ranked types
07:27:07 <dons> cool.
07:27:09 <olliej> dons: they can become ludicrously inefficient
07:27:32 <olliej> (it requires passing higher ranked type liberally between two modules)
07:27:42 <dons> in general? or just in your compiler's case?
07:27:49 <olliej> in general
07:28:06 <dons> oh, that's interesting. 
07:28:15 <olliej> there are optimisations but the (unavoidable) worst case requires wrappers to be applied over and over again
07:28:49 <alar> what tool is most simple for parsing primitive stupid formats?
07:28:56 <olliej> dons: take two modules compiled seperately, each using forall a . a->a as a parameter everywhere
07:29:29 <dons> alar, Data.List ?
07:29:31 <olliej> as they are copmiled seperately each needs to produce its own version of the interface for forall a.a->a
07:29:35 <dons> then parsec.
07:29:42 <norpan> alar: i always use parsek
07:29:55 <dons> really simple stuff i just roll my own parser
07:29:57 <olliej> we shall call them modules A and B
07:30:30 <dmhouse> I wish the Freenode connection/authentication handshake were quicker.
07:31:00 <dons> its so slow, isn't it.
07:31:05 <olliej> say module B uses module A and passes forall a. a->a to other functions (for various exciting reasons we can't trivially make module B use just module A's interface)
07:31:10 <dons> slashnet is practically instant.
07:31:38 <dmhouse> Perhaps I should connect to SlashNet for testing then
07:31:52 <dmhouse> I'm testing remotely at the moment because I need at least two different nicks interacting
07:31:58 <olliej> dons: particularly modules B passes something of type forall a . a->a to module A, in this case no wrapping is necessary (through the use of voodoo magic)
07:32:17 <dons> olliej: hmm,very interesting. what does ghc do now?
07:32:29 <olliej> dons: ghc isn't using a typed memory module
07:32:36 <olliej> dons: it basically uses void*
07:32:54 <olliej> the problem on .NET is you have a typed memory model
07:33:10 <olliej> even if two things have the same physical interface they are not the same
07:33:29 <olliej> and .net will have a fit at you if you try
07:33:35 <olliej> to treat this as the same thing
07:35:12 <olliej> anyhoo, if a function in A returns something of type forall a .a->a it will be using the interface defined for module A, which as i said above is not compatible with the version defined in module B, even though they have the same physical interface
07:35:46 <dons> ah yeah. right.
07:35:47 <olliej> which means module B has to put a wrapper class around the returned value
07:36:02 <olliej> which gives another level of indirection
07:36:03 <dons> yeah, tricky.
07:36:36 <olliej> so if you take one thing of type forall a. a->a and get it passed and returns across many modules
07:36:47 <olliej> you get an ever increasing level of stupidity
07:36:49 <olliej> ahem
07:36:53 <olliej> indirection
07:36:58 <dmhouse> dons, I think there are bigger problems with runIrc. I don't think moduleExit is being called.
07:37:32 <dons> dmhouse: feel free to rewrite it. its full of legacy stuff slowly rotting
07:37:54 <dons> the exception handling never really got ported to the async, multithreaded lambdabot model we use now
07:38:02 <olliej> dons: happily there are no performance problems with the mechanism i've worked out for higher kinded types (as opposed to the retarded solution currently in my compiler, which doesn't work completely)
07:38:44 <dons> dmhouse: you just have to be careful to check all the exit cases work properly in both online and offline mode
07:38:48 <olliej> dons: unfortunately it is impossible to generate statically type safe code with higher kinds on .net
07:38:53 <dons> i.e ?quit, eof and ^C
07:39:21 <dons> olliej: oh, that's an interesting result. was that known previously?
07:40:34 <alar> dons: probably
07:40:58 <dmhouse> dons, I'll try to have a hack later. I'm off for now. Enjoy the football :)
07:41:16 <dons> ciao.
07:41:18 <dmhouse> All the lowlevel syncing/threading might be a bit over my head, but we'll see :)
07:41:29 <dons> well, i might just rewrite it tomorrow anyway
07:41:42 <dmhouse> Okay, I might leave it to you then :)
07:41:46 <dons> i'm inclined to start over in that code. there's a lot of cruft
07:41:49 <dmhouse> I'll... fix @remember or something.
07:41:57 <dons> yeah, that's another.
07:42:01 <dmhouse> Happen to know what's wrong with it?
07:42:27 <dons> hmm. i suspect there's some race or lock to do with serialising the state
07:42:47 <dons> when using it, lambdabot would lock up. disabling that command made the problem go away.
07:42:52 <dmhouse> Hmm.
07:43:11 <dmhouse> Well maybe I'll hold off until you've finished refactoring, if it's something like that.
07:43:14 <dons> however, it has worked fine in the past. probably a bad fix to a problem that was fixed somewhere else
07:43:25 <dons> possibly, yeah
07:43:30 <dmhouse> As you say, logging and @run need attention.
07:43:53 <dons> and then there's also some fun new plugins we could write
07:44:03 <dons> using context data for all sorts of games
07:44:10 <dons> like multiline evals, perhaps
07:46:01 * dons -> tv
07:46:03 <dmhouse> Anyway, later.
07:46:46 <olliej> dons: sorry back again
07:47:16 <olliej> dons: i'm fairly sure i'm the first person to come up with a way to get higher kinded types going
07:48:02 <olliej> dons: i know there was someone also doing a masters on compiling haskell to .net in brazil, but as yet i don't have an english translation of there thesis
07:49:15 <olliej> dons: i know they haven't done higher ranked types, but i'm not sure about higher kinded types
07:49:15 <olliej> dons: if you resort to type erasure you can get it fairly easily (and higher ranked types)
07:49:15 <olliej> dons: i believe that's the approach taken by yhc
07:49:15 <olliej> (for their .net backend)
07:50:03 <olliej> dons: the solution i developed for higher kinded types gives you complete type safety when you make the call, assuming your type arguments are self consistent
07:50:29 <olliej> dons take f :: f a -> f b or something
07:51:17 <olliej> we actually have  f :: forall f::(*->*) a b . f a -> f b
07:51:59 <olliej> which becomes (somewhat brutally) f :: forall fa fb a b . fa -> fb
07:52:35 <olliej> which solves allows you to match semantics of higher kinds
07:52:41 <olliej> s/solves//
07:53:06 <norpan> this type stuff is sometimes confusing
07:53:23 <norpan> i propose we just scrap typing, it does no good when the program is type correct anyway!
07:53:44 <olliej> but there's no way on .net to statically enforce the relationship between fa, fb, a, b, and (the now gone) f
07:53:50 <olliej> hmm...
07:53:55 * olliej just had a thought
07:57:06 * olliej has frightened dons away... 
07:57:13 <olliej> which surprises me
08:07:06 <Dino__> I'm looking into using System.Console.GetOpt.  So far just trying to use the example at the bottom of the GetOpt docs.
08:07:27 <Dino__> I've noticed that, in the set of example options in that module, the -o and -c options (which are OptArg) only work like '-ofoo -cbar' and not like '-o foo -c bar'
08:07:46 <Dino__> What I mean by not work is the foo and bar strings end up in the [String] and not in the [Flag] alongside their switches.
08:08:41 <Dino__> Is this maybe just a quirk or am I needing something other than the Permute for ArgOrder passed to getOpt (I wonder).
08:29:11 <malcolm> dons: is the haddock documentation for FPS out-of-sync with the darcs repo?
08:29:42 <malcolm> dons: The version on the web claims that unsafeHead and unsafeTail are exported, but in the repo this is not the case.
08:32:53 <malcolm> olliej: talking of higher-kinded types, have you seen Omega from Tim Sheard?  I allows you to define kinds that live at any level - K0 (ordinary kinds) K1 (kinds of kinds), etc.  I've seen an example where he uses up to K2.  Pretty mind bending stuff.
08:33:13 <olliej> aieee
08:33:21 * olliej ignores
08:33:29 * olliej has 19 days to finish thesis
08:45:45 <nomeata> Hi CosmicRay
08:46:16 <nomeata> Just curious: Did you get my small patch for HSH? (It was my first shot at using darcs, so I'm wondering)
08:51:23 <CosmicRay> nomeata: yes, I was about to apply it, thanks!
08:52:00 <CosmicRay> nomeata: I'll be applying it.  I hadn't done that myself yet because a true parser needs some more work -- to handle spaces in filenames, quoting, etc.
08:52:09 <CosmicRay> nomeata: however passing the string to sh -c may be good enough
08:53:29 <nomeata> CosmicRay: cool, thanks. I like the idea of a HSH, although I think I'd rather have a "hp" (Haskell-Pipe) command, that takes a [String] -> [String] function on the command line
08:53:51 <nomeata> so one can call it from bash as part of a bash pipe.
08:53:53 <norpan> hashkellshell
08:54:15 <CosmicRay> nomeata: ah, that would be interesting too.
08:54:23 <CosmicRay> that's probably pretty trivial to write actually
08:56:05 <nomeata> I guess so, but still useful :-). Does haskell have something like eval?
08:56:14 <nomeata> hoogle: eval?
08:56:54 <nomeata> (in the perl or python sense of eval)
08:57:12 <norpan> no that doesn't fit
08:57:47 <norpan> there is template haskell
08:58:09 <norpan> which lets you build syntax at compile time
08:58:33 <xerox> kind Nat = Z | S Nat -- woohoo.
08:58:45 <norpan> "kind"?
08:58:59 <xerox> norpan - hs-plugins has an `eval' function, by the way.
08:59:23 <norpan> ah yes
08:59:33 <xerox> I am looking at Ωmega.
09:01:36 <norpan> Ωμεγα
09:01:59 <norpan> Ωμέγα actually
09:02:20 * nomeata has pitty with all thouse without unicode in this channel
09:02:36 <norpan> i only have pity
09:03:47 <norpan> evil Rat = Q Nat Nat
09:07:39 * JKnecht checks to see if irssi has a gui.
09:08:00 <norpan> it has a gui, it's called a terminal :)
09:08:23 <olliej> xterm: the gui to end all guis
09:09:18 <norpan> hmmm it seems there is some kind of sporting event going on involving a small inflated bladder or similar
09:09:19 <dmhouse> xerox, I read that paper yesterday
09:09:35 <dmhouse> xerox, couldn't get to sleep because my mind was buzzing about all the great applications it could have :)
09:09:35 <JKnecht> hmmm, there is but only a beta for Mac.
09:10:11 <norpan> what's with Ωμέγα then?
09:10:40 <dmhouse> Omega is like Haskell but features extensibility at the kind level.
09:11:02 <dmhouse> so you can do things like kind Nat = Z | S Nat as xerox said
09:11:25 <dmhouse> then you can say type ListWithLength a = LWL [a] Nat
09:11:33 <dmhouse> err, *newtype
09:11:36 <dmhouse> (I think)
09:11:48 <dmhouse> no, wait, that's not right.
09:11:56 <dmhouse> let me find the paper.
09:12:15 <dmhouse> basically it beefs up the type system so the Curry-Howard isomorphism actually becomes useful
09:12:37 <dmhouse> right
09:12:38 <malcolm> surely newtype ListWithLength :: * -> Nat
09:12:44 <norpan> what's the relationship with cayenne?
09:13:25 <malcolm> cayenne = dependent typing.  Omega gives you dependent types, but staged so that all the dependent stuff happens at compile time rather than runtime
09:13:26 <dmhouse> data Seq :: * -> Nat -> * where Nil :: Seq a Z; Cons :: a -> Seq a n -> Seq a (S n)
09:13:34 <dmhouse> then you can have things like:
09:13:55 <dmhouse> map :: (a -> b) -> Seq a n -> Seq b n and you've just proven that map doesn't alter the length of the list.
09:14:00 <JKnecht> dmhouse: is there an implemenation/URL (for Omega)?
09:14:21 <dmhouse> JKnecht: I think so. Google for 'Putting the Curry-Howard isomorphism to work'. That's the paper I'm refering to.
09:15:15 <JKnecht> yes saw in the google performed I think ...
09:15:57 <malcolm> http://web.cecs.pdx.edu/~sheard/Omega/index.html
09:16:27 <dmhouse> Just think: any kind of invariant a function supposedly has could be encoded and proven at the type leve.
09:16:30 <dmhouse> *level
09:16:48 <dmhouse> Like, length (concat xs) = sum (map length xs)
09:17:15 <dmhouse> Or all (`elem` xs) (filter p xs). Or length (filter p xs) <= length xs.
09:17:34 <JKnecht> malcom: thanks!
09:17:40 <malcolm> One of the weird things is that the expression of the /property/ is at the type level, but the /proof/ is constructive, i.e. if you can write a program that meets the type, then the program is the proof.
09:18:02 <dmhouse> Or elemIndex a xs < elemIndex b xs ==> elemIndex a (filter p xs) < elemIndex b (filter p xs)
09:34:00 <xerox> malcolm - That sounds way cool. And right.
09:42:46 * SamB wonders how to figure out what big packages (or groups of packages that are related, though dpkg wouldn't likely know it...) he isn't using and can uninstall
09:43:21 <roconnor> do you use aptitude?
09:46:57 <sehute> SamB: 1. use synaptic, sort all packages by size, 2. try deborphan
09:47:33 <sehute> SamB: see also the documentation, development and old-lib sections in synaptic
09:48:57 <sehute> SamB: In addition, I know there exists some solutions that lets you have a list of packages you wish to have installed, and keeps the other ones away from your system
09:49:14 <sehute> SamB: And you could always try out Linux from scratch ;)
09:49:27 <sehute> SamB: guess deborphan is really what you're looking for, though
09:50:30 <ptolomy> fyi, I've added a short Data.ByteString-dependent program to the Gallery page on the wiki. Feel free to pick it apart and/or improve it. 
09:51:10 <monochrom> You can take the GC algorithm of ghc, generalize to a typeclass monadic form, specialize to the debian package system, then run...   (duck)
09:55:01 <dons> malthe version of the haddocks on the web is for 0.6, but perhaps i should regenerate it for the latest darcs code
09:55:06 <dons> malcolm ^^
09:56:42 <dmhouse> @localtime dons
09:56:44 <lambdabot> Local time for dons is Sat Jun 10 02:47:52 2006
09:56:50 <dmhouse> You're still up?!
09:57:23 <dons> malcolm: i've updated the docs now. the web docs reflect the darcs code.
09:57:27 <dons> dmhouse: yep. on my way out though
09:59:28 <dons> ptolomy: you win a prize as the first person to write a bytestring program that will actually benefit from fusion :)
09:59:33 <dons> without it being a fusion benchmark 
09:59:39 <ptolomy> huzzah. :)
09:59:50 <LPhas> Anyone knows if getProcessStatus is blocking?
10:00:19 <ptolomy> All I know is that it runs pretty fast for something that was so easy to write.
10:00:30 <dons> that's good to know.
10:01:01 <dons> B.group is a bit inefficient, if you can avoid it, it might be a win
10:01:10 <dons> its one of the slowest functoins in the lib
10:01:42 <ptolomy> hmm. good to know. I haven't actually profiled it yet, so I haven't concerned myself with optimizing beyond the obvious.
10:01:48 <olliej> dons: wow, you're still up?
10:02:05 <SamB> > group (`mod`10) [1..20]
10:02:10 <lambdabot>   The function `group' is applied to two arguments,
10:02:10 <lambdabot>   but its type `[a] -...
10:02:11 <dons> there's this world cup thing in the _wrong timezone_
10:02:20 <dmhouse> haha :)
10:02:24 <xerox> ?type groupBy
10:02:26 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
10:02:39 <xerox> ?type partition
10:02:40 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:02:45 * dons `fmap` sleep
10:02:53 <dmhouse> ?type toEnum
10:02:55 <lambdabot> forall a. (Enum a) => Int -> a
10:02:57 <xerox> SamB, I suspect you want one of those.
10:04:24 <dmhouse> >  let attach f g x y = g x `f` g y in groupBy ((==) `attach` (`mod` 10)) [1..20]
10:04:26 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],...
10:04:32 <dmhouse> hrm.
10:04:47 <SamB> > group [1..20]
10:04:47 <olliej> dons: ah, soccer freak?
10:04:47 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],...
10:04:53 <SamB> dons: you probably shouldn't cut that error message so short, it is nigh useless
10:05:01 <dmhouse> > 11 `mod` 10
10:05:03 <lambdabot>  1
10:05:18 <dmhouse> Oh, I know.
10:05:28 <SamB> > group "baa baa"
10:05:29 <lambdabot>  ["b","aa"," ","b","aa"]
10:05:35 <olliej> dons: can you think of a simple "useful" function using higher kinded types, but no classes?
10:05:38 <xerox> It is probably easier to generate the equivalence class than use group to sieve it.
10:05:47 <dmhouse> group(By)? is a little limited in that it only compares adjacent items.
10:07:16 <SamB> xerox: I guess I just can't imagine group itself being useful for anything, and just assume that it *has* to take a function
10:08:05 <SamB> dons: B.partition would be worse :-P
10:08:12 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:) in splitBy ':' "foo:bar:baz:quux"
10:08:13 <lambdabot>  ["foo","bar","baz","quux"]
10:08:53 <dmhouse> > let attach f g x y = g x `f` g y; anagrams = (==) `attach` (group . sort) in anagrams "foobar", "rafobo"
10:08:54 <lambdabot>  Parse error
10:08:54 <xerox> Ah, _group_ ... it is useful on sorted list.
10:09:09 <dmhouse> > let attach f g x y = g x `f` g y; anagrams = (==) `attach` (group . sort) in anagrams "foobar" "rafobo"
10:09:10 <lambdabot>  True
10:09:17 * dmhouse <3 attach
10:09:35 <xerox> hah!
10:10:24 <SamB> xerox: so, basically group is to be used instead of partition on lists that you know are sorted?
10:10:50 <xerox> I think so.
10:10:51 <dmhouse> That's a nice little program I wrote for the British Informatics Olympiad. Everyone was struggling with their 40-line Visual Basic anagram algorithms, so I presented that lovely oneliner :)
10:11:07 <xerox> dmhouse - Do they accept entries in whatever language?
10:11:14 <dmhouse> xerox, yep. They look at output.
10:11:22 <xerox> dmhouse - You are so lucky.
10:11:29 <dmhouse> Heh. Yep :)
10:11:39 * xerox grumbles
10:11:54 <xerox> You won everything?
10:12:01 <dmhouse> Nah.
10:12:11 <xerox> Ack!
10:12:17 <dmhouse> It's a national competition, there were some Very Clever people entering.
10:12:18 <dmhouse> Syn!
10:12:31 <int-e> dmhouse: hmm, why the group?
10:12:48 <dmhouse> int-e, hrm, I don't remember.
10:12:55 <dmhouse> it's not needed.
10:13:15 <dmhouse> > let attach f g x y = g x `f` g y; anagrams = (==) `attach` sort in anagrams "foobar" "rafobo"
10:13:16 <lambdabot>  True
10:13:22 <int-e> dmhouse: anagrams x y = sort x == sort y
10:13:40 <int-e> dmhouse: you've obfuscated the program a bit :P
10:13:47 <dmhouse> xerox, this was also at the time when I was quite new to Haskell. I think I had learnt about State in the previous week
10:13:52 <dmhouse> int-e, attach is my favourite combinator.
10:14:01 <dmhouse> I want to show it off :)
10:15:27 <int-e> @pl \sort x y -> sort x == sort y
10:15:27 <lambdabot> flip =<< (((.) . (==)) .)
10:15:43 <dmhouse> Yes, quite.
10:15:56 <dmhouse> @pl attach f g x y = g x `f` g y
10:15:56 <lambdabot> attach = join . ((flip . ((.) .)) .) . (.)
10:19:02 <lscd> silly newbie question: what's a kind, exactly?
10:19:10 <xerox> The type of a type.
10:19:14 <dmhouse> lscd, do you understand the term 'type constructor
10:19:15 <lscd> ahhh, ok
10:19:23 <dmhouse> '
10:19:25 <lscd> dmhouse: hm.... i have an idea of what it is, but not a deep understanding
10:19:33 <dmhouse> lscd, how about 'data constructor'?
10:19:46 <lscd> to about the same degree, really
10:19:51 <dmhouse> okie doke.
10:20:08 <mauke> lscd: do you know Maybe?
10:20:10 <dmhouse> Well, a data constructor is in essence a function. You give it some values, and it gives you a different value back.
10:20:13 <lscd> mauke: yes
10:20:25 <mauke> Maybe is a "type function". it takes a type and returns a type.
10:20:30 <lscd> dmhouse: sure, and a type constructor is similar, but the value it gives you is a type?
10:20:44 <lscd> mauke: ahhh, ok, that makes sense
10:20:47 <dmhouse> lscd, yeah. You give a type constructor a type, it gives you back another.
10:20:49 <xerox> ?kind Int
10:20:50 <dmhouse> like Maybe.
10:20:50 <lambdabot> *
10:20:52 <xerox> ?kind Maybe
10:20:54 <lambdabot> * -> *
10:20:56 <xerox> ?kind Maybe Int
10:20:57 <lambdabot> *
10:21:12 <dmhouse> Maybe takes types to types wrapped in Maybes. e.g. you feed Int into Maybe, it gives you Maybe Int.
10:21:17 <lscd> ah.... this would explain why i've been seeing *'s in some stuff i've glanced at
10:21:21 <dmhouse> right. 
10:21:33 <dmhouse> * is the nullary type. That is, a type constructor with all type arguments applied.
10:21:34 <lscd> mm, ok
10:21:41 <lscd> ahhh
10:21:55 <lscd> so, Maybe Maybe would be misformed, i guess?
10:21:56 <dmhouse> err, nullary kind.
10:22:02 <lscd> ?kind Maybe Maybe
10:22:03 <lambdabot>   `Maybe' is not applied to enough type arguments
10:22:03 <lambdabot>   Expected kind `*', but `Maybe' has kind `* -> *'
10:22:05 <dmhouse> lscd, exactly.
10:22:14 <dmhouse> This kind of kind inference is important.
10:22:25 <lscd> while Maybe Maybe Int wouldn't be? (or Maybe $ Maybe Int?)
10:22:32 <xerox> The latter.
10:22:37 <dmhouse> sorry, I should say 'This sort of kind inference', to avoid loaded terms.
10:22:38 <int-e> Maybe (Maybe Int)
10:22:43 <int-e> there's no $ in the type level.
10:22:50 <lscd> dmhouse: well, it's still loaded, but not so strongly
10:22:51 <xerox> Yet!
10:22:59 <lscd> int-e: ahh, i was sort of wondering; thanks!
10:23:01 <dmhouse> Yeah, because we can't give type-level fixity declarations, we can't have a ($) at the type level.
10:23:12 <lscd> ok.. what's a type-level fixity declaration?
10:23:24 <dmhouse> f $ x = f x
10:23:33 <dmhouse> nothing magic. What makes it work is its very low fixity.
10:23:38 <int-e> you mean, type a :$ b = a b?
10:23:41 <int-e> freaky.
10:23:48 <lscd> ok, different question: what's fixity?
10:23:52 <dmhouse> int-e, nope, you're confusing data and type constructors.
10:23:55 <dmhouse> a $ b = a b
10:24:13 <xerox> lscd - Precedence.
10:24:13 <mauke> int-e: that would be cool
10:24:23 <dmhouse> lscd, I.e. in show $ x + 1, ($)'s low fixity lets the x + 1 be evaluated before ($).
10:24:25 <int-e> dmhouse: I think I'm not - they are lexicographically the same.
10:24:27 <lscd> xerox: ahh, ok; why the different term? 
10:24:32 <mauke> there's not even a type-level lambda :/
10:24:42 * xerox pats mauke 
10:24:44 <dmhouse> mauke: that's forall :)
10:24:47 <lscd> dmhouse: yeah - once xerox said 'precedence' it made perfect sense; thanks
10:24:55 <Cale> dmhouse: no it's not :)
10:25:18 <dmhouse> int-e, GHC allows infix type constructors. They don't need to begin with : because they're not first-class.
10:25:19 <Cale> type-level lambda makes things difficult, to say the least
10:25:34 <dmhouse> int-e, my point was that you could have a $ b, you don't need a :$ b
10:25:42 <lscd> why aren't they first class?
10:25:43 <dmhouse> Cale, there's a certain relationship, though.
10:25:47 <xerox> What do you get out of a type-level lambda, Cale?
10:26:01 <dmhouse> lscd, type constructors aren't. You can't return a type from a function.
10:26:11 <lscd> dmhouse: but why not?
10:26:20 <dmhouse> It doesn't make any sense
10:26:24 <dmhouse> f = Int
10:26:46 <lscd> so a type constructor isn't a sort of function?
10:26:55 <dmhouse> it is, but it's not a first class function.
10:26:59 <dmhouse> It deals with types, not values.
10:27:13 <dmhouse> Maybe Int, not Maybe 5.
10:27:28 <lscd> i can see why values aren't types, but why aren't types values?
10:27:48 <dmhouse> I don't really understand you.
10:28:00 <lscd> hm.... a function takes values and returns values, right?
10:28:05 <xerox> lscd - It is just a design decision not to have functions at type-leve.
10:28:09 <xerox> level, even.
10:28:18 <lscd> xerox: sure - i'm wondering why it was chosen though
10:28:29 <xerox> I am sure it makes a lot of things simpler.
10:28:46 <dmhouse> lscd, but there are new proposals to beef up the type system.
10:28:46 <int-e> Hmm, it makes things decidable.
10:28:48 <lscd> mm. likely, but i still wonder what
10:28:57 <lscd> int-e: they would be undecidable if types were first-class?
10:29:03 <dmhouse> E.g. the Curry-Howard paper myself and a few others were discussing earlier.
10:29:04 <norpan> you can use template haskell to create type functions
10:29:46 * dmhouse would love an extensible kind system :)
10:29:50 <mauke> type Id a = a -> a; type Inject a c = a -> c a; type Combine a = Inject a Id  -- doesn't work
10:30:02 <lscd> dmhouse: yeah - i found tim sheard's home page based on that; i think i'll try to blow my head up reading some stuff on it soon
10:30:34 <lscd> norpan: ahh, cool; i should start learning about template haskell
10:30:41 <dmhouse> mauke: it doesn't? Why not?
10:31:11 <int-e> dmhouse: it expands to a -> a -> a -> ...
10:31:17 <mauke> int-e: wha?
10:31:26 <mauke> dmhouse: Type synonym `Id' should have 1 argument, but has been given 0
10:31:37 <dmhouse> mauke: oh yeah.
10:31:42 <dmhouse> There's a Haskell' entry for this.
10:31:46 <dmhouse> Proper kind inference.
10:32:30 * SamB wants to vote for a Debian bug
10:32:35 <lscd> url? googling for 'proper kind inference' gives me 0 results
10:32:45 <dmhouse> I don't think that's what it's called. :) Hold on
10:32:56 <int-e> mauke: if you use ghc, have you tried with -fglasgow-exts? That ought to give you a different error.
10:33:03 <SamB> @google "kind inference"
10:33:05 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/KindInference
10:33:22 <mauke> w00t, seems to work
10:33:28 <SamB> interesting.
10:33:46 <SamB> I seem to have found what you were talking about ;-)
10:34:03 <dmhouse> Damn! I was about to paste that :)
10:34:16 <SamB> google is faster than you are!
10:34:36 <mauke> awesome, even TFlip works
10:35:21 <norpan> maybe you can't do type splicing in ghc yet
10:35:28 <norpan> haven't tried that actually
10:36:04 <dmhouse> Yeah, I think GHC actually has a kind inference algorithm. Rather than "Err, you missed an argument."
10:36:30 <int-e> mauke: now add: data Fix a = Fix (Inject a Fix)
10:36:33 <mauke> type (Foo :: * -> *) = TFlip Inject Id  -- is still a syntax error :/
10:37:28 <mauke> int-e: works
10:40:18 <xerox> Fix/Inject is what was called sometime Mu/Something ?
10:41:07 * ptolomy resists the urge to spend his workday pointlessly optimizing toy haskell code.
10:41:30 <int-e> xerox: no.
10:41:44 <xerox> int-e - Do you remember what was the Mu one?
10:42:03 <int-e> xerox: that Fix is just a silly example that allows writing  inf a = Fix inf
10:42:44 <int-e> xerox: newtype Mu x = In { out :: x (Mu x) }  is what I used.
10:43:04 <xerox> What is it useful for, instead?
10:43:45 <int-e> it finds a fixed point for a given functor. http://paste.lisp.org/display/20982
10:43:54 <xerox> Great. Thank you.
10:45:49 <dmhouse> type I a = a; type K a b = a; type S a b z = a z (b z). There we go, now we can encode anything in the type system! :)
10:46:21 <int-e> (S I I) (S I I)
10:46:51 <xerox> Yin-yang? (:
10:46:59 <dmhouse> int-e, well, that won't kindcheck.
10:47:02 <int-e> hmm. you'll get kind troubles.
10:47:03 <int-e> :)
10:47:19 <dmhouse> S :: (* -> * -> *) -> (* -> *) -> * -> *
10:47:39 <int-e> in fact you'll get kind troubles even for stuff that should be valid types.
10:47:52 <int-e> because there's no kind polymorphism.
10:47:55 <norpan> typed lambda calculus, is that really turing complete
10:48:02 <int-e> norpan: no
10:48:03 <norpan> don't you need recursion
10:48:38 <int-e> on the other hand it's powerful enough to calculate the ackermann function, iirc.
10:48:55 <xerox> What else do you need, in the end.
10:49:00 <dmhouse> Hmm... I'd love to see a prime-generating program at the type level :)
10:49:15 <Kasperle> typed lambda calculus? i think it is
10:49:15 <xerox> I bet ski has one (:
10:49:32 <Kasperle> but you can't have type-correct pure lambda calculus afaik
10:49:35 <dmhouse> type Y = S (K (S I I)) (S (S (K S) K) (K (S I I))). What's that about recursion?
10:49:58 <dmhouse> (That needs type-level partial application, but ssh :))
10:50:03 <dmhouse> *shh
10:50:08 <norpan> dmhouse: doesn't kind check
10:50:22 <xerox> ...if you ask kindly enough...
10:50:30 <dmhouse> Oh dear.
10:50:43 <xerox> Cough.
10:50:49 <dmhouse> *crickets chirping*
10:51:24 <dmhouse> Haha, the greatest fixpoint combinator ever:
10:51:35 <dmhouse> L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o
10:51:38 <dmhouse> Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L)
10:51:44 <dmhouse> Yk is a fixedpoint combinator :)
10:51:55 <dmhouse> Gah, that first line was meant to be L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
10:53:41 <int-e> > let zero = \f x -> x; one = succ zero; succ n = \f x -> n f (f x); ack x = x (\f y -> succ y f one) succ in ack one one (+1) 0
10:53:44 <lambdabot>  3
10:54:00 <int-e> there. that's the Ackermann function in typed lambda calculus :)
10:55:10 <xerox> ?karma+ int-e 
10:55:11 <lambdabot> int-e's karma raised to 6.
10:55:19 <int-e> So on one hand the typed lambda calculus is more powerful than the primitive recursive functions, on the other hand it's not Turing-complete. Fun :)
10:55:57 <lscd> ?karma+ int-e
10:55:58 <lambdabot> int-e's karma raised to 7.
10:56:00 <int-e> (it's not Turing-complete without a fixed point calculator because its strongly normalizing. I think that gives enough keywords to google for)
10:56:17 <int-e> calculator -> combinator.
10:56:32 * int-e doesn't pay enough attention to what his fingers are typing.
10:59:00 <dmhouse> int-e, do you need the Y-combinator to compute terminating programs?
10:59:05 <norpan> int-e: if i replace your first "one" by "succ one" then ghc complains about infinite type
10:59:16 <norpan> is it just a built in limit or is there something else
10:59:19 <dmhouse> or can all terminating programs be modelled with a strongly normalising calculus?
10:59:34 <int-e> norpan: of course. infinity has no type.
10:59:52 <xerox> Let's do a non-standard extension on the types.
10:59:58 <int-e> norpan: it'd be the fixed point combinator and that doesn't exist in the typed lambda calculus
11:00:08 <norpan> huh?
11:00:27 <norpan> i just replaced ack one one (+1) 0 with ack (succ one) one (+1) 0
11:00:37 <norpan> shouldn't that be possible
11:01:00 <JKnecht> dmhouse: I doubt it.
11:01:21 <int-e> > let zero = \f x -> x; one x = succ zero x; succ n = \f x -> n f (f x); ack x = x (\f y -> succ y f one) succ in ack one one (+1) 0
11:01:23 <lambdabot>  3
11:01:34 <int-e> > let zero = \f x -> x; one x = succ zero x; succ n = \f x -> n f (f x); ack x = x (\f y -> succ y f one) succ in ack (succ one) one (+1) 0
11:01:35 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t) -> t -> t
11:01:35 <lambdabot> ...
11:01:40 <dmhouse> > let zero = \f x -> x; one = succ zero; succ n = \f x -> n f (f x); ack x = x (\f y -> succ y f one) succ in ack (succ one) (succ one) (+1) 0
11:01:41 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t) -> t -> t
11:01:41 <lambdabot> ...
11:01:42 <int-e> hmm.
11:01:51 <dmhouse> int-e, what does that function do?
11:02:10 <int-e> interesting.
11:03:28 <int-e> oh. (succ one) doesn't type.
11:03:52 <norpan> that succs
11:04:11 <xerox> (t -> t) -> t -> t is fix!
11:04:27 <dmhouse> No, (t -> t) -> t is fix
11:04:35 <dmhouse> (t -> t) -> t -> t is iterate
11:04:38 <dmhouse> well, almost.
11:04:59 <norpan> int-e: you are obviously bluffing, that's not the ackerman function at all
11:05:49 <dmhouse> ack :: Nat -> Nat -> Nat. 
11:05:51 <norpan> the ackerman function is not primitively recursive
11:05:58 <dmhouse> int-e, so why did your function take four arguments?
11:06:08 <xerox> ?karma- int-e 
11:06:08 <lambdabot> int-e's karma lowered to 6.
11:06:44 * int-e ponders.
11:07:21 <norpan> how can you express anything but primitive recursion with simply typed lambda calculus and church numerals?
11:07:38 <norpan> since you exploit the primitive recursion built into the numerals
11:09:17 <int-e> norpan: *sigh*. I thought I had this work before. Give me some time to figure out if I really only tried it for 0 and 1 or if I'm missing something else.
11:09:18 <dmhouse> succ ≡ λn.λf.λx. f (n f x). But int-e's was succ = \n f x -> n f (f x).
11:09:35 <int-e> dmhouse: the two are equivalent.
11:09:39 <dmhouse> Ah, okay.
11:09:43 <int-e> (for church numerals)
11:09:46 <norpan> @type let zero = \f x -> x; succ = \n f x -> f (n f x)  in succ zero
11:09:48 <lambdabot> forall t t1. (t -> t1) -> t -> t1
11:10:02 <norpan> that's "one"
11:10:12 <norpan> @type let zero = \f x -> x; succ = \n f x -> f (n f x)  in succ (succ zero)
11:10:13 <lambdabot> forall t. (t -> t) -> t -> t
11:10:20 <norpan> hmmm
11:10:30 <dmhouse> all Church numerals are (t -> t) -> t -> t
11:10:52 <norpan> yes
11:10:57 <norpan> but why t and t1
11:11:09 <norpan> nm
11:11:35 <dmhouse> @type let zero = \f x -> x; succ = \n f x -> n f (f x) in (zero, succ zero, succ (succ zero))
11:11:36 <lambdabot> forall t t1 t2 t3 t4. (t -> t1 -> t1, (t2 -> t3) -> t2 -> t3, (t4 -> t4) -> t4 -> t4)
11:12:07 <dmhouse> so succ one _does_ typecheck.
11:12:17 <norpan> of course it does
11:12:32 <dmhouse> < int-e> oh. (succ one) doesn't type.
11:12:50 <norpan> he was obviously bluffing again :)
11:13:35 <norpan> @pl let zero = \f x -> x; succ = \n f x -> n f (f x) in succ (succ zero)
11:13:36 <lambdabot> (.) =<< (.) =<< const id
11:13:40 <norpan> weee
11:13:47 <norpan> @pl let zero = \f x -> x; succ = \n f x -> n f (f x) in succ (succ (succ zero))
11:13:48 <lambdabot> (.) =<< (.) =<< (.) =<< const id
11:13:51 <norpan> i see pattern
11:14:00 <int-e> norpan: I'm too stupid to read error messages. This is not my day.
11:14:15 <int-e> norpan: No instance for (Show ((t -> t) -> t -> t))  is not exactly a typing error.
11:14:23 <norpan> just count the (.)s
11:15:03 <norpan> visually pleasing
11:15:53 <norpan> but i don't see how you can get the ackerman function since it's not primitively recursive
11:16:11 <norpan> anyway
11:18:47 <int-e> norpan: I'll say I was wrong. The ack function I gave is indeed an ackermann function in the untyped lambda calculus; apparently I really never tried giving it arguments >1. :(
11:19:29 <norpan> okidoki
11:19:53 <int-e> @karma- int-e
11:19:54 <lambdabot> You can't change your own karma, silly.
11:24:20 <dmhouse> Anyone happen to know the german adjective ending for masculine nouns in the accusative?
11:24:26 <norpan> the ackerman function is primitively recursive for m=[0,1] :)
11:24:32 <dmhouse> With the indefinite article.
11:24:36 <dmhouse> Is it -en?
11:24:39 <norpan> dmhouse: n
11:24:46 <norpan> yes, -en
11:24:56 <dmhouse> Thanks norpan :)
11:25:42 <norpan> should also be for [2,3]
11:27:14 <dmhouse> How does everyone sign letters you're emailing to people? Scan in your signiture and keep a digital copy for thereafter?
11:27:27 <norpan> gpg of course
11:27:35 <norpan> pgp
11:28:01 <dmhouse> I meant signing with a signiture. Y'know, one of those things you put on cheques to guarentee they're from you.
11:28:11 <norpan> yes
11:28:14 <dmhouse> Your name written very roughly.
11:28:15 <sieni> dmhouse: who uses checks?
11:28:16 <norpan> a pgp signature
11:28:26 <int-e> norpan: ack(k,n) (as a function in n) is primitive recursive for all k.
11:28:36 <norpan> you can't sign an email with a handwritten signature
11:28:50 <norpan> int-e: are you sure
11:28:50 <dmhouse> It's not an email, it's a PDF which will be sent via email.
11:29:06 <dmhouse> But the point is it'll never see a non-digital existance
11:29:08 <sieni> it's like electronic era, and one can like, wire the money to the receiver or use a credit or debit card.
11:29:19 <sieni> dmhouse: well scan and add it then
11:29:25 <int-e> norpan: in this case, yes. just define separate functions for ack 0, ack 1, ... each is obviously primitive recursive.
11:29:28 <norpan> dmhouse: but what will a scanned signature be worth?
11:29:29 * dmhouse considers using emacs's artist-mode
11:29:45 <dmhouse> norpan: It's not a guarantee, more a politeness thing. It's a business letter.
11:29:47 <int-e> norpan: it's when you make k a variable that it breaks down.
11:29:48 <sieni> norpan: they are often used in promotional material for example
11:29:58 <norpan> bah
11:30:09 <norpan> that's uninteresting
11:30:10 <norpan> :)
11:30:13 <sieni> norpan: or a letter
11:30:43 <norpan> when i write a physical paper letter i sign by hand
11:30:53 <norpan> when i write a digital letter i sign by digits
11:31:05 <norpan> mixing the two seems silly
11:31:28 <sieni> norpan: you don't understand the logic of business (or lack thereof) 
11:32:05 <norpan> why is it more polite to paste in a digital scan of your signature than to simply write your name
11:32:26 <norpan> of course business logic doesn't follow normal laws of logic
11:32:41 <dmhouse> Social rules aren't governed by logic,
11:33:02 <norpan> is there really a social rule that you should scan your signature and paste it?
11:33:21 <norpan> i'd rather have a digitally signed document
11:33:21 <dmhouse> @seen jethr0
11:33:22 <lambdabot> I haven't seen jethr0.
11:33:23 <sieni> norpan: if it's a pdf which, when printed, looks like an actual letter
11:33:27 <dmhouse> lambdabot: what, ever?
11:33:42 <norpan> well whatever
11:33:46 <sieni> norpan: that's a different use case ;-)
11:34:04 <norpan> don't worget to watermark it with fingerprints and coffe spills
11:34:13 <norpan> then it will really look authentic
11:35:26 <norpan> and while you're at it, write the whole email by hand and scan it
11:35:40 <vincenz> hi
11:36:16 <dmhouse> hey vincenz 
11:36:50 <dmhouse> @tell vincenz I wrote a new lambdabot plugin!
11:36:51 <lambdabot> Consider it noted.
11:37:01 <vincenz> Consider it noted.
11:37:01 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
11:37:15 <dmhouse> @ask vincenz whether his SSH is borked or whether it's just me
11:37:16 <lambdabot> Consider it noted.
11:37:29 <vincenz> @tell dmhouse to talk to me directly and that my box is down
11:37:30 <lambdabot> Consider it noted.
11:37:30 <dmhouse> You can @messages in the channel if you want to.
11:37:30 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
11:37:36 <dmhouse> @clear-messages
11:37:37 <vincenz> @messages
11:37:37 <lambdabot> Messages cleared.
11:37:37 <lambdabot> dmhouse asked less than a minute ago: whether his SSH is borked or whether it's just me
11:38:12 <vincenz> dmhouse: you needed access?
11:38:25 <dmhouse> vincenz: oasisbot stopped, I was going to restart him.
11:38:32 <vincenz> oh yeah
11:38:34 <vincenz> turned my box of
11:38:42 <dmhouse> No problem.
11:38:54 <sieni> dmhouse: did you try with ssh -vvv or something?
11:39:10 <vincenz> sieni: again, my box is down
11:39:23 <sieni> vincenz: a-ha :-)
11:39:31 <vincenz> it makes a shitload of noise (cpu fan)
11:39:36 <vincenz> especially now tat it's hotter
11:39:39 <dmhouse> 'oasis.yi.org: Name or service not found'. No amount of verbosity is going to turn his computer on :)
11:39:41 <vincenz> activity has been nil anyways
11:39:51 <sieni> dmhouse: ahh ;-)
11:39:58 <vincenz> dmhouse: says who?
11:40:07 <vincenz> dmhouse: have you tried or do you have mathematical proof of this?
11:40:20 <sieni> dmhouse: you can also telnet to the ssh port to see if the ssh server is on and willing to serve your ip-address
11:40:39 <vincenz> sieni: actualyl I have a deal with all the major ISPs
11:40:49 <dmhouse> 'A warning to my readers: I have only proved this algorithm correct, not tested it.' Hehe, I love that quote.
11:40:49 <vincenz> sieni: they all fake my computer's existence whenever dmhouse is contacting my pc
11:40:59 <vincenz> dmhouse: knuth?
11:41:03 <dmhouse> Yep.
11:41:37 <vincenz> anyways
11:41:45 <vincenz> stuck on a small implementation issue regarding my interpreter
11:42:00 <dmhouse> Anyone speak german and have, say, ten minutes spare?
11:42:06 <vincenz> ich nict
11:42:08 <vincenz> ich nicht
11:43:13 <vincenz> blegh
11:43:23 <vincenz> they completely reformulated my original problem with typeclass hell
11:43:28 * vincenz doesn't feel like restating the problem
11:44:10 <vincenz> 4 different topics to haskell-cafe
11:44:12 <vincenz> none resolved :/
11:44:38 <dmhouse> That's because you're asking the wrong questions.
11:44:43 <vincenz> heh
11:44:46 <vincenz> no I'm not
11:45:42 <dmhouse> I have to say, though, you've shown me how flexible the class system can be.
11:46:03 <vincenz> where?
11:46:49 <dmhouse> Just with your general emails. You're twisting and coercing it into really weird ways :)
11:47:09 <dmhouse> I just figured typeclasses meant Show and Eq but with MPTCs and FDs, they can do an awful lot.
11:47:16 <dmhouse> And existentials.
11:53:50 <vincenz> :D
11:53:59 <vincenz> I haven't figured out existentials yet
11:54:02 <vincenz> at least not in code
12:06:01 <vincenz> hmm
12:10:51 <int-e> > (iterate (\f -> (iterate f 1 !!) . (1+)) (1+) !!) 3 3
12:10:53 <lambdabot>  61
12:13:19 <vincenz> @type (!!)
12:13:20 <lambdabot> forall a. [a] -> Int -> a
12:21:54 <vincenz> @sex
12:21:55 <lambdabot> Lately, I have seen int-e and vincenz.
12:22:00 <vincenz> LOL
12:22:26 <Kasperle> haha
12:22:37 <BCoppens> :D
12:22:42 <dmhouse> @help sex
12:22:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:22:57 <dmhouse> Oh dear, who's the immature lambdabot hacker?
12:23:02 <dmhouse> :)
12:23:51 <ulfdoz> dmhouse: Give me a try. Sex is putting the needle in the hole.
12:24:26 <vincenz> ulfdoz: your needle?
12:25:03 <ulfdoz> vincenz: Not necessarily, but I'll see, what I can do this evening.
12:26:56 <vincenz> ah put a needle in it
12:31:13 * vincenz sighs tired
12:38:14 <vincenz> @hoogle foldM
12:38:15 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
12:38:15 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:38:15 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
12:38:55 <vincenz> @type uncurry
12:38:56 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
12:39:31 <vincenz> @hoogle uncurry
12:39:32 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
12:39:48 <vincenz> @pl         ctxFromModule qid mod = concatMap (map (\f -> (Top (funcName f) qid, funcType f))) . functions $ mod
12:39:48 <lambdabot> ctxFromModule = (. functions) . (=<<) . map . (`ap` funcType) . ((,) .) . flip (Top . funcName)
12:40:09 <norpan> having fun?
12:40:17 <vincenz> (\f -> (Top (funcName f) qid, funcType f))
12:40:20 <vincenz> @pl (\f -> (Top (funcName f) qid, funcType f))
12:40:20 <lambdabot> ap ((,) . flip Top qid . funcName) funcType
12:40:22 <vincenz> norpan: ?
12:40:36 <vincenz> norpan: working on my compiler
12:40:52 <norpan> writing compiler in points-free style are we
12:41:16 <vincenz> no
12:41:18 <vincenz> just cleaning up a bit
12:43:30 <pesco> What exactly is the wisdown for Parsec wrt. line endings? newline doesn't accept "\r\f", so I suppose it is expected that the input string uses Unix line endings. Or is that platform-dependent, does anyone know?
12:43:41 <vincenz> \o/
12:43:52 <norpan> newline is \n
12:44:43 <norpan> ascii 10
12:44:57 <vincenz> octal 12
12:45:04 <vincenz> hexadecimal A
12:45:06 <pesco> Okay...
12:45:12 <vincenz> binary 1010
12:45:23 <norpan> \f is form feed which is page break right=
12:45:27 <norpan> ascii 12
12:45:33 <vincenz> octal 14
12:45:37 <vincenz> hexadecimal C
12:45:37 <pesco> Arr, mixed that up.
12:45:38 <norpan> something completely different
12:45:40 <vincenz> binary 1100
12:46:07 <pesco> I see, thanks.
12:46:15 <vincenz> welcome!
12:46:34 <norpan> vincenz: i suppose you're one of those who mix up christmas and halloween?
12:46:41 <vincenz> nope
12:46:52 <vincenz> my level of geekness is not that high
12:47:15 * vincenz makes another generic reusable monad
12:47:16 <vincenz> \o/
12:47:17 <vincenz> this rocks
12:47:24 <vincenz> my binder, typechecker and interpreter
12:47:29 <vincenz> are all built up of the same core moands
12:47:38 <norpan> good stuff
12:47:47 <norpan> state monads i suppose :)
12:47:57 <vincenz> not all
12:48:00 <vincenz> I need a good name
12:48:19 <norpan> how about "superdupermonad"
12:48:19 <vincenz> class Monad m => XXXX m where
12:48:23 <vincenz>    lookup :: a -> m b
12:48:29 <dmhouse> norpan: that'd be RWST
12:48:29 <vincenz>    substitue :: a -> b -> m ()
12:48:49 <dmhouse> ?kind RWST
12:48:50 <lambdabot> Not in scope: type constructor or class `RWST'
12:48:51 <vincenz> it's basically a StateT with a Map a b
12:48:51 <sieni> pesco if you want to accept both windows and sensible newlines, can't you just try to match (\r\n|\n) in regex-speak or something?
12:48:52 <xerox> vincenz - Environment ?
12:49:02 <vincenz> xerox: thx
12:49:06 <xerox> My duty.
12:49:06 <norpan> StateTWithMap
12:49:11 <vincenz> MonadEnvironment
12:49:13 <vincenz> I already have
12:49:15 <vincenz> MonadScope
12:49:18 <vincenz> and from CAle MonadSupply
12:49:27 <norpan> MonadDemand
12:49:27 <pesco> sieni: I suppose. The problem seems less severe, now that I know that NL = LF. :/
12:49:35 <xerox> What is MonadSupply?
12:49:39 <vincenz> xerox: new
12:49:42 <vincenz> new :: m a
12:49:46 <xerox> Wow.
12:49:49 <vincenz> class Monad m => MonadSupply a m where
12:49:51 <vincenz>   new :: m a
12:49:53 <xerox> Garbage collecting? :-)
12:49:58 <vincenz> no
12:49:59 <vincenz> just fresh names
12:50:09 <pesco> @fresh
12:50:09 <lambdabot> Haa
12:50:22 <norpan> I have Haq
12:50:25 <vincenz> but yeah my language is gc based
12:50:31 <vincenz> fortunately I can just reuse the haskell gc :D
12:51:30 <norpan> What does your language do
12:51:39 <vincenz> a language does nothing
12:51:43 <vincenz> what kind of question is that
12:51:57 <norpan> the wrong kind obviously :)
12:51:58 <vincenz> well that's not true
12:52:05 <vincenz> it allows me to tell the computer to do something
12:52:08 <vincenz> :D
12:52:15 <xerox> Is it an extension on Haskell?
12:52:19 <vincenz> no
12:52:33 <sieni> pesco: if you have a programming language whose syntax designers haven't been smoking crack you can just consider any whitespace as just a token separator
12:52:38 <norpan> <rephrase>What features does your language have that are superdupercool</rephrase>
12:52:47 <vincenz> norpan: it's simple
12:53:00 <sieni> pesco: of course this does not apply to Haskell and another language which-is-not-to-be-named :-)
12:53:17 <vincenz> sieni: the whitespace one?
12:53:19 <norpan> i think the haskell committe all have smoked crack
12:53:23 <xerox> I remember a language made only of whitespaces.
12:53:30 <vincenz> xerox: that's the one I meant
12:53:32 <int-e> norpan: thanks again for the correction about the ackermann function. I guess I must have jumped from 'this has a type
12:53:36 <norpan> xerox: yes, very good for printing, saves ink
12:53:56 <int-e> norpan: ' to 'this works when applied to any church numerals', which is wrong.
12:54:01 <vincenz> I need a better name for substitute
12:54:10 <vincenz> read|write?
12:54:14 <norpan> int-e: an easy-to-make mistake
12:54:29 <xerox> subs ?
12:54:40 <norpan> what does it do for magic
12:54:44 <norpan> substitute
12:54:53 <sieni> vincenz: no the one that only parseltongues use
12:54:56 <pesco> sieni: I'm dealing with something like (re)structured text/setext/atx/markdown/... so unfortunately, linebreaks are significant.
12:55:12 <vincenz> read and write it is
12:55:20 <xerox> It substitutes the element whose key have type a with a element of type b?
12:55:21 <sieni> or rather parseltongue speakers use
12:55:22 <pesco> sieni: Luckily, the whitespace in front of them isn't. >:-)
12:56:24 <norpan> so it's "replace"
12:56:34 <norpan> or "write"
12:56:41 <xerox> Just guessing.
12:56:51 <vincenz> read|write
12:56:56 <norpan> lookup=read
12:57:01 <vincenz> yes
12:57:01 <norpan> ?
12:57:04 <norpan> okidoki
12:57:06 <vincenz> but lookup is used by List
12:57:12 <norpan> indeed it is
12:57:13 <vincenz> and find Is already used by MonadScope
12:57:26 <xerox> give
12:57:29 <norpan> darn prelude
12:57:39 <norpan> too much cruft in it
12:57:44 <vincenz> xerox: give for which?
12:58:05 <xerox> Maybe for substitute, and something dual for lookup/read.
12:58:12 <vincenz> read - write
12:58:17 <vincenz> class (Ord k, Monad m) => MonadEnv k v m | m -> k, m -> v where
12:58:17 <vincenz>   read  :: k -> m v
12:58:17 <vincenz>   write :: k -> v -> m ()
12:58:17 <vincenz>     
12:58:33 <xerox> I don't know if hiding read is a good idea.
12:58:39 <vincenz> @hoogle read
12:58:40 <lambdabot> Prelude.read :: Read a => String -> a
12:58:40 <lambdabot> Text.Read :: module
12:58:40 <lambdabot> Prelude.Read :: class Read a
12:58:42 <vincenz> whoops
12:58:47 <vincenz> xerox: good point
12:59:22 <vincenz> alright ???|substitute
12:59:39 <xerox> make?
12:59:44 <vincenz> huh?
12:59:45 <vincenz> no
12:59:51 <xerox> make 'a' 2
12:59:55 <vincenz> nono
12:59:56 <vincenz> the finding
13:00:04 <vincenz> the 'read' method
13:00:20 <xerox> (It's shorter than substitute, just an idea.)
13:00:24 <SamB> vincenz: qualified names?
13:00:31 <vincenz> no
13:00:43 <xerox> whatis
13:00:46 <vincenz> @hoogle substitute
13:00:46 <xerox> apropos :-P
13:00:46 <lambdabot> No matches found
13:00:53 <vincenz> apropos
13:00:54 <vincenz> hmm
13:00:55 <xerox> gimme
13:01:00 <xerox> Wah, dunno.
13:01:11 * vincenz ponders of a very lewd one
13:01:18 <dmhouse> What is this the name for?
13:01:24 <norpan> whathas and nowhas
13:01:27 <vincenz> dmhouse: MonadEnv
13:01:36 <dmhouse> vincenz: what does it do?
13:01:38 <vincenz> xxx :: k -> m v
13:01:45 <vincenz> yyy :: k -> v -> m ()
13:01:49 <vincenz> it's a staty monadd
13:01:53 <norpan> get/put
13:02:02 <norpan> short good names
13:02:04 <vincenz> norpan: that's StateT
13:02:21 <xerox> wtf/remember
13:02:21 <norpan> gett/putt
13:02:23 <vincenz> update iso substitute
13:02:29 <vincenz> @hoogle update
13:02:29 <lambdabot> Data.HashTable.update :: HashTable key val -> key -> val -> IO Bool
13:02:29 <lambdabot> Data.IntMap.update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
13:02:29 <lambdabot> Data.Map.update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
13:02:36 <vincenz> good enough
13:03:04 <norpan> does update work even if there is no previous value
13:03:07 <dmhouse> vincenz: what you've described seems to be a special case of MonadState
13:03:12 <vincenz> dmhouse: yes
13:03:54 <vincenz> @hoogle lookup
13:03:54 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:03:55 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
13:03:55 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
13:04:07 <vincenz> whatis thisis?
13:04:16 <dmhouse> so why not class Env e k v | e -> k, e -> v where read :: k -> e k v -> v; write :: k -> v -> e k v -> e k v
13:04:24 <vincenz> dmhouse: I had that but
13:04:25 <vincenz> @hoogle read
13:04:26 <lambdabot> Prelude.read :: Read a => String -> a
13:04:26 <lambdabot> Text.Read :: module
13:04:26 <lambdabot> Prelude.Read :: class Read a
13:04:44 <vincenz> dmhouse: and what you describe is ReaderT
13:04:45 <vincenz> not a StateT
13:05:23 <int-e> @karma+ norpan 
13:05:24 <lambdabot> norpan's karma raised to 3.
13:05:27 <vincenz> getfor | substitute?
13:05:31 <vincenz> getfor putfor!
13:05:49 <pesco> strchr strrchr!
13:06:01 * pesco hides.
13:06:03 <vincenz> pescit pescat
13:06:20 <dmhouse> throw and fetch
13:06:26 <norpan> receive/deposit
13:08:25 <int-e> plant harvest?
13:08:52 <dmhouse> sow and reap?
13:09:37 <norpan> withdraw/deposit
13:13:32 <LordBrain> hey... i'm having trouble compiling this, http://www.haskell.org/hawiki/PhoneNumber
13:14:23 <vincenz> pescit pescat
13:14:26 <vincenz> ack
13:14:33 <dmhouse> LordBrain: what's the error?
13:14:46 <SyntaxNinja> hi malcolm
13:14:55 <LordBrain> its a parse error
13:14:58 <malcolm> Hi syntax
13:15:15 <dmhouse> LordBrain: on which line?
13:15:18 <LordBrain> there is some weirdness around line 61
13:15:28 <malcolm> SyntaxNinja: Mathieu is looking forward to working with galois
13:15:33 <dmhouse> LordBrain: which one is that?
13:15:54 <LordBrain>  newBranch (n:noutput left in -
13:16:05 <LordBrain> s) = newNode [] n $ newBranch ns
13:16:38 <dmhouse> Yeah, that appears to be screwed up.
13:16:54 <LordBrain> hmm
13:17:07 <LordBrain> do :'s in symbols have special meaning?
13:17:22 <dmhouse> > 4 : [1..3]
13:17:23 <lambdabot>  [4,1,2,3]
13:17:27 <dmhouse> that's what (:) does.
13:17:29 <LordBrain> oh yeah i knew that..
13:17:31 <LordBrain> hehehe
13:17:39 <dmhouse> > (\(x : xs) -> x) [1..4]
13:17:40 <lambdabot>  1
13:17:44 <dmhouse> > (\(x : xs) -> xs) [1..4]
13:17:45 <lambdabot>  [2,3,4]
13:17:54 <dmhouse> recall that [1..4] = 1:2:3:4:[].
13:18:19 <dmhouse> Then it pattern matches (x:xs) against that. x gets bound to 1, and xs to 2:3:4:[].
13:18:36 <LordBrain> yes, i recall now.. jeez i cant beleive i forgot that
13:19:08 <vincenz> LordBrain: I would call yourself KnightBrain until you don't forget that
13:19:25 <LordBrain> well i just always use this nick.. for recognizability
13:19:37 <vincenz> Yes but it places high expectations!
13:19:50 <LordBrain> oh well
13:20:03 <norpan> who said that you need to be smart to be a Lord
13:20:26 <vincenz> norpan: wrong semantics
13:20:42 <dmhouse> LordBrain: if you edit the page then copy the source from there, that should work better.
13:20:43 <xerox> > S.runState (fmap (+1) S.get) 1
13:20:44 <lambdabot>  Not in scope: `S.get'
13:21:00 <LordBrain> oh ok, i
13:21:03 <LordBrain> i'll try that
13:21:04 <vincenz> xerox: S = Data.Set
13:21:45 <dmhouse> > Control.Monad.State.runState (fmap (+1) Control.Monad.State.get) 1
13:21:46 <lambdabot>  (2,1)
13:21:57 <xerox> > runState (return ()) ()
13:21:59 <lambdabot>  ((),())
13:22:07 <dmhouse> > let in 4
13:22:08 <lambdabot>  4
13:22:30 <vincenz> > let out 8
13:22:31 <lambdabot>  Parse error
13:22:58 <vincenz> > let otherwise = not True in otherwise
13:22:59 <lambdabot>  False
13:24:11 <vincenz> pump it!
13:24:40 <vincenz> data Value m ref =
13:24:40 <vincenz>     VPrim Prim
13:24:40 <vincenz>   | VRef ref
13:24:40 <vincenz>   | VTuple [Value m ref]
13:24:40 <vincenz>   | VFunction (Value m ref -> m (Value m ref))
13:24:42 <vincenz>   | VThunk (Value m ref)
13:24:53 <vincenz> \o/
13:25:22 <vincenz> anyways
13:25:27 <vincenz> time to go out and have fun
13:25:33 <vincenz> hasta luego
13:25:44 <pesco> Eew, fun.
13:25:50 <vincenz> too tired to work
13:26:13 <vincenz> cy
13:26:14 <vincenz> a
13:26:18 * pesco waves.
13:29:17 <SyntaxNinja> malcolm: cool :)  I'm looking forward to having him.  we're going to put him to work fast :)
13:29:52 <dmhouse> What exactly _is_ Galois? I've heard the term thrown around a bit.
13:30:01 <norpan> a company
13:30:14 <SyntaxNinja> dmhouse: www.galois.com we do Haskell and formal methods work.
13:30:16 <malcolm> SyntaxNinja: it's such a shame that you stole him from my SoC project though... :-)
13:30:26 <SyntaxNinja> malcolm: I did my best, dude!
13:30:28 <xerox> Ah!
13:30:35 <SyntaxNinja> I mean... my best to let him work on both.
13:30:44 <xerox> Howdy Isaac.
13:30:56 <dmhouse> Ack! Lack of CSS :)
13:30:59 <SyntaxNinja> malcolm: in reality, we had him in the pipeline before SoC.
13:31:04 <SyntaxNinja> y0 xerox
13:31:06 <malcolm> SyntaxNinja: sure, no hard feelings.
13:31:23 <SyntaxNinja> malcolm: that's good. you're too fun to have mad at me.
13:31:35 <SyntaxNinja> I've got a bringert here right now.  he's just hanging out here today for fun.
13:31:43 <malcolm> SyntaxNinja: It just would have been good to have him, since he seems so bright
13:32:04 <dmhouse> Which SoC project are we losing?
13:32:22 <malcolm> dmhouse: we're not losing any.
13:32:42 <malcolm> dmhouse: the yhc typechecker got reassigned to a different student
13:32:49 <dmhouse> Ah, great.
13:32:57 <SyntaxNinja> everybody's happy ;)
13:33:03 <malcolm> dmhouse: who I'm confident will do a good job of it too
13:33:03 <dmhouse> Yeah. Good idea.
13:33:10 * SyntaxNinja feels like he's in high school or something... 
13:33:25 <norpan> hmmm, beaverton
13:33:31 <SyntaxNinja> near portland
13:33:42 * malcolm wonders why portland is like high school
13:34:45 <SyntaxNinja> I mean like, so-and-so was going to go to the prom with so-and-so, but now xyz is best friends with galois and malcolm is... ;)
13:35:16 * pesco giggles.
13:35:52 <SyntaxNinja> btw, that's not actually what high school was like for me, but I hear that's what it's supposed to be like.
13:36:06 <norpan> the thing you call high school, what age are you then
13:36:16 <monochrom> teen
13:36:18 <SyntaxNinja> like, 14-18 or so
13:36:52 <norpan> ok, long time ago :)
13:55:49 <BCoppens> anybody know of a nice overview of G Machine instructions or so?
13:59:00 <Igloo> If you want to know about them in theory then I think "Implementing Functional Languages", now available as a PS/PDF from Simon's web page, talks about them
13:59:30 <Igloo> I suspect the current GHC implementation has evolved somewhat since then, but there may be a more up-to-date paper hanging around
14:01:12 <BCoppens> Igloo: oh nice! Thanks :)
14:01:40 <BCoppens> I was rather looking for a concise overview of instructions, but this can be much more fun =)
14:42:26 <dmhouse> @seen jethr0
14:42:26 <lambdabot> I haven't seen jethr0.
14:42:33 <dmhouse> @tell jethr0 to ping me when he's around
14:42:34 <lambdabot> Consider it noted.
14:43:09 <dmhouse> hmm.
14:43:27 <dmhouse> I'm in one of those moods when I know i want to program, but I don't know _what_ I want to program.
14:46:31 <norpan> a SUDOKU SOLVER
14:47:19 <dmhouse> Anyone know of any scripts that convert literate Haskell into normal Haskell?
14:48:12 <mauke> perl -ne 'print if s/^>//'
14:48:24 <isaacd> ghc -E ?
14:48:39 <dmhouse> mauke: I'd like it to convert stuff that isn't code to comments, please
14:48:51 <dmhouse> isaacd: I'll check it out
14:49:20 <dmhouse> "Stop after preprocessing (.hspp file)". Hmm.
14:49:22 <mauke> perl -ne 'print s/^>// ? $_ : "-- $_"'
14:49:31 <SamB> /usr/lib/ghc-*/unlit  ?
14:49:38 <xerox> Duh.
14:50:17 <dmhouse> SamB: looks good
14:53:33 <dmhouse> mauke: how about don't bother doing anything to the line if it's empty? :)
14:54:21 <mauke> perl -ne 'print s/^>// || /^$/ ? $_ : "-- $_"'
14:54:44 <mauke> you might want to change that to ^\s*$
14:54:52 <dmhouse> right
14:55:16 <xerox> You might want to change that to something readable :)
14:55:29 <dmhouse> mauke: perfect. /me writes that one down
14:55:37 <mauke> it's readable if you know perl :-)
14:55:57 <dmhouse> I don't know much perl, but I can pretty much follow that
14:56:57 <xerox> main = interact unlit where unlit ('>':xs) = xs; unlit ys = "-- " ++ ys
14:57:15 <mauke> doesn't work
14:57:27 <xerox> Why?
14:57:45 <mauke> main = interact (unlines . foo . lines) where <- what I had in my input buffer when you said that
14:57:55 <dmhouse> main = fmap (map unlit . lines) (getArgs >>= hGetContents . head) where unlit = ...
14:58:09 <xerox> interact doesn't unlines.f.lines by itself?
14:58:17 <mauke> @type interact
14:58:18 <lambdabot> (String -> String) -> IO ()
14:58:34 <xerox> (The other cruft isn't needed because you can pipe to stdin and collect stout.)
14:58:38 <dmhouse> right
14:58:46 <mauke> the perl version is still more flexible
14:58:50 <dmhouse> I didn't know that's what interact did
14:58:52 <xerox> It is pretty simple anyway.
14:59:00 <xerox> I am not sure, mauke :-)
14:59:02 <mauke> it works with any number of arguments
14:59:35 <Cale> there's an unlit program which comes with ghc
14:59:43 <mauke> and if you add -i it does unline replacement
14:59:44 <dmhouse> Cale, yep, and it doesn't seem to be very good.
14:59:48 <mauke> er, inline
15:00:00 <dmhouse> Cale, I think it transforms it to be compiler-readable, not human readable :)
15:00:25 <Cale> It works, but it just strips out all the comments, without deleting space, by the looks of it
15:00:57 <lispy> has anyone here been working toward .NET or JVM inter-operability for haskell?
15:04:08 <lispy> it looks like GHC.NET was abandoned as were the other attempts to make haskell talk to .NET
15:04:29 <mauke> s/^>//||!/\S/||s/^/-- /
15:04:30 <saccade> lispy: is 'lispy' like 'scipy' or 'statpy'?
15:04:40 <mauke> perl -pe 's/^>//||!/\S/||s/^/-- /', I mean
15:04:47 <lispy> saccade: i have no idea :)
15:05:12 <saccade> lispy: didn't MS's flirtation with haskell stall out?
15:05:13 <dmhouse> mauke: what's that now?
15:05:13 <lispy> saccade: oh, wait, are those python libraries?
15:05:22 <saccade> yeah, those
15:05:26 <saccade> joke
15:05:28 <mauke> dmhouse: perl golf
15:05:28 <lispy> haha, no it's like lisp
15:05:34 <eivuokko> lispy, I think that the community doesn't take well into anything Microsofty, so such stuff die when authors don't need them anymore.
15:05:41 <dmhouse> mauke: what does the latest revision do?
15:05:50 <mauke> nothing new, it's just shorter
15:06:01 <lispy> eivuokko: yeah, that seems to be the case with H/Direct
15:06:50 <eivuokko> lispy, Well, with hdirect, there's also that lots of stuff is easy enough to do by hand that it doesn't make always so much sense to use it..
15:07:11 <lispy> but my paying job takes well to MS technologies...and i'm always trying to find ways fit in some haskell code :)
15:07:48 <lispy> i think if haskell was a .NET language i could use it inplace of VB or C# whenever :)
15:08:14 <eivuokko> Getting .net backend for yhc will make things easier.
15:08:16 * ptolomy likes F#.
15:08:48 <lispy> ptolomy: i looked atit, but ocaml is so forgein and i miss type classes
15:09:01 <ptolomy> yeah, type classes are mighty nice.
15:12:08 <lispy> heh, one professor tells me, 'maybe you could translate it to C# first."
15:13:22 <saccade> lispy: don't take programming advice from IT profs  ;)
15:13:50 <lispy> actually this prof is a language prof :)
15:14:19 <lispy> i think he's translated between languages in past research so he may actually have a valid point :)
15:14:49 <saccade> wait, computer language, or natural language?
15:15:00 <lispy> computer
15:15:33 <jer> lispy, did you tell him "icky" and then run away crying? =D
15:15:39 <lispy> heh
15:15:58 <saccade> translating between computer languages is a job for compilers, not people  :P
15:15:59 <lispy> but how is it different than -fvia-C?
15:16:15 <lispy> saccade: well, of course is research was to make the machine do ti :)
15:16:50 <lispy> it would just become -fvia-C#
15:17:35 <SamB> saccade: it depends on whether you want a literal translation or just a paraphrase
15:17:35 <eivuokko> No, it really wouldn't be the same.  ghc's uses gcc for c->asm and then modifies the asm.
15:17:47 <saccade> sure sure
15:18:10 <lispy> eivuokko: it modifies the asm?
15:18:11 <jer> eivuokko, that would explain partially why it's a lot slower than you would think it needs to be
15:18:33 <lispy> just for optimization or some other reason?
15:18:49 <SamB> well, some of each
15:18:57 <eivuokko> jer, lispy, it removes the function call epilogue and prologue, so it can use it's own calling convention that has proper tail calls
15:19:15 <jer> ah
15:19:36 <eivuokko> And RTS is in C, so you'd need to have that in .net too, which is no little undertaking either.
15:19:51 <Cale> That's what the Evil Mangler does.
15:20:07 <Cale> It's actually written in Perl :)
15:20:13 <lispy> eivuokko: hmm...about the RTS, isn't that what the CLR is?
15:20:33 <Cale> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/ghc/driver/mangler/ghc-asm.lprl?rev=1.122.2.13;content-type=text%2Fplain
15:20:37 <eivuokko> lispy, That doesn't cover it fully.
15:20:54 <lispy> Cale: is that link for me?
15:21:09 <Cale> that's for anyone who'd like to see the evil mangler :)
15:21:52 <norpan> that is very evil
15:22:15 <xerox> The Evil Mangler is ran against every GHC-compiled program? I thought it was used only for GHC itself, argh!
15:22:30 <Cale> xerox: with -fvia-C
15:22:31 <eivuokko> xerox, Every piece compiled with -fvia-C
15:23:34 <Cale> It's a tribute to the good modular design of gcc that such a thing is necessary.
15:23:53 <lispy> Cale: it's written in perl?
15:23:57 <Cale> yeah
15:24:16 <norpan> that doesn't make it less evil
15:24:20 <Cale> It's just a huge bunch of string rewriting on the assembly output of GCC.
15:24:21 <dmhouse> What exactly does it do?
15:24:23 <dmhouse> Oh.
15:24:38 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/mangler.html
15:24:43 <dmhouse> Cale's gotten so clever he can predict what questions I'm about to ask :)
15:24:47 <Cale> You can read about exactly what it does there
15:25:17 <norpan> but is it NEEDED?
15:26:08 <norpan> and why doesn't .so files work in Linux :)
15:26:25 <lispy> i thought the .so thing was a legal issue
15:26:40 <norpan> .so files are illegal? :)
15:26:43 <Cale> no, it's just an implementation thing
15:27:30 <Cale> Wolfgang Thaller only relatively recently wrote the dynamic linking code for Mac OS X, since that's what he uses.
15:28:00 <Cale> There hasn't been much push for dynamic linking otherwise, as far as I can tell.
15:28:07 <norpan> i don't need dynamic linking of haskell libraries
15:28:20 <norpan> i only need to put haskell code in a .so-file and call it from c
15:28:39 <eivuokko> That shouldn't be hard, just replace main with your own entry code
15:28:52 <norpan> it is hard as you get strange segmentation faults
15:29:06 <eivuokko> Oh, well.  It works in Windows in that way.
15:29:10 <Cale> Why not just take the object file and statically link it with whatever?
15:29:11 <norpan> because of something with position independent code
15:29:19 <eivuokko> Heh
15:29:30 <norpan> Cale: it's not possible, because the whole thing will be called from java
15:29:50 <Cale> I thought you said "from C"
15:29:53 <norpan> yes
15:29:59 <norpan> from C, via the jni :)
15:30:07 <lispy> yeah, i've looked into that too
15:30:10 <lispy> it's ugly
15:30:21 <lispy> but if you get it working let me know :)
15:31:10 <norpan> more relevant is to be able to make plugins to various programs
15:31:19 <norpan> they often are of .so form
15:32:00 <norpan> i would be glad to help fix it but i don't know where to start :)
15:32:17 <Cale> Apparently only some minor work is needed to get position independent code working on x86 ELF
15:32:44 <Cale> -fPIC is working on Darwin/PPC and Linux/PPC
15:32:48 <norpan> that sounds good but i'll believe it when i see it :)
15:33:30 <eivuokko> What's the problem?  dynamic ffi wrappers?
15:33:54 <Cale> http://www.haskell.org/hawiki/DynamicLinkingInGhc -- there's some info about the current(?) status of things here
15:35:15 <eivuokko> Ah.
15:35:45 <norpan> i wonder which column is the one i want
15:37:14 <norpan> i made a simple .hs-file that foreign exports a function. works fine when i link all .o-files, but when i build a dynamic library of the haskell .o file and links with that it segfaults
15:37:42 <Cale> right
15:37:56 <dmhouse> @localtime dons
15:37:57 <lambdabot> Local time for dons is Sat Jun 10 08:29:03 2006
15:39:15 <Cale> norpan: you might try compiling the java with gcj, and linking in the .o
15:41:23 <norpan> yeah, right
15:41:47 <norpan> a viable option though is to compile the java and load it in via jni
15:41:55 <norpan> but it takes massive restructuring
15:42:19 <norpan> and having the haskell stuff as shared objects would help keep size down as they really are sort-of plugins
15:42:45 <norpan> right now haskell parts are called by serializing data and running them as separate processes
15:43:22 <Cale> what are you doing on the java side?
15:43:30 <norpan> the whole application is in java
15:44:39 <norpan> and some parts are now written in haskell because we had them from another project
15:44:51 <norpan> and because haskell is good
15:45:31 <norpan> and they are separate enough so that it's just a minor pain to write serializing code
15:45:45 <norpan> and it's not all bad from a debugging perspective
15:51:51 <norpan> ideally you'd just want to do ghc --mk-dll
15:54:39 <dmhouse> @echo
15:54:39 <lambdabot> echo; msg:IrcMessage {msgPrefix = "dmhouse!n=david@host86-132-138-205.range86-132.btcentralplus.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo"]} rest:""
15:58:11 <palomer> > "hello"
15:58:12 <lambdabot>  "hello"
15:59:52 <mauke> @help echo
15:59:53 <lambdabot> echo <msg>. echo irc protocol string
16:02:54 <dmhouse> @type runState
16:02:55 <lambdabot> forall s a. State s a -> s -> (a, s)
16:06:41 <dmhouse> @localtime dons
16:06:43 <lambdabot> Local time for dons is Sat Jun 10 08:57:47 2006
16:43:24 <ptolomy> @hoogle filter
16:43:25 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
16:43:25 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
16:43:25 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
16:44:23 <clausen> does anyone here know Church numerals in lambda-calculus?
16:44:33 <clausen> I'm having some trouble with multiplication
16:45:31 <norpan> clausen: what do you want to know?
16:45:51 <clausen> well, I've been using a lambda calculus interpreter
16:45:56 <clausen> and it hasn't been working out
16:46:01 <RyanT5000> what's the deal with HaXml? I got the following error:     conflict: module `Text.PrettyPrint.HughesPJ' 
16:46:02 <RyanT5000>     belongs to the current program/library and also to package base-1.0
16:46:15 <clausen> eg: four = qtimes two two;
16:46:21 <RyanT5000> how do i deal with duplicate modules like that?
16:46:50 <clausen> if I then do "four psucc 0;"
16:46:59 <ptolomy> Anything in the GHC library work out well as a bag?
16:47:04 <clausen> it doesn't evaluate out properly
16:47:10 <clausen> (there are lots of lambdas etc.)
16:47:36 <RyanT5000> ptolomy: is there any time you'd use a bag over a Map a Integer?
16:47:37 <clausen> (I can paste details on #flood)
16:48:26 <clausen> conceptually, I'm not sure how you make sure that everything gets the right number of "successors" and "zeros" passed around
16:48:32 <RyanT5000> another question: is HaXml the best XML parser to use?
16:49:08 <lscd> 4 $B"a(B $B&K(Bf.$B&K(Bx. f (f (f (f x))) <-- it doesn't look like that, I guess?
16:49:10 <ptolomy> RyanT5000: Well, I assume that in cases when I want to do set-type operations on a bag without much extra code and with reasonable efficiency, I'd assume a bag of ordered elements to be better.
16:49:20 <sieni> RyanT5000: for what? 
16:49:29 * ptolomy is semi-sure that he meant to assume he'd assume.
16:49:40 <norpan> clausen: go ahead and paste somewhere
16:50:15 <RyanT5000> sieni: specifically: loading Collada 3d models; generally: i have no particular time or space constraints
16:50:33 <sieni> RyanT5000: Oleg's sxml tools are probably as close to perfect as anything oleg produces can be, but they are for scheme. for haskell he has has a project called hsxml, but I don't know about its situation.
16:51:34 * clausen tries to get his code as elegant as possible
16:51:42 <norpan> clausen: but you know how a church numeral works, right?
16:52:10 <sieni> RyanT5000: There are the scheme tools: http://okmij.org/ftp/Scheme/xml.html
16:53:08 <clausen> norpan, sort of :)
16:54:24 <norpan> conceptually, a church numeral takes a "successor" argument and a "zero" argument
16:54:49 <norpan> which corresponds to the two cases in primitive recursion
16:55:59 <clausen> http://ninethsense.com/pastebin/index.php?p=18
16:56:44 <norpan> hmmm what language is this
16:56:45 <sieni> norpan: wtf?
16:57:08 <norpan> sieni: ?
16:57:09 <clausen> norpan, it's basic variant of lambda calculus
16:57:24 <sieni> norpan: how is primitive recursion related to church numerals?
16:57:33 <norpan> it's build into them
16:57:35 <clausen> http://www.cis.upenn.edu/~bcpierce/tapl/checkers/fulluntyped.tar.gz
16:57:37 <norpan> built
16:58:09 <clausen> lambda calculus has challenged the way I look at recursion
16:58:35 <sieni> norpan: I thought that primitive recursion means that you have to give the number of computation steps required in advance
16:58:42 <clausen> I always thought you had to have a definition that referred to itself
16:58:42 <dfeuer> Anyone here know if it's possible to encode the balance invariants for any useful balanced tree data structure in the Haskell (or Glasgow Haskell) type system?
16:58:56 <norpan> instead of the number being the argument to the recursive function, the function is passed as an argument to the number
16:59:05 <norpan> or as arguments
16:59:33 <norpan> first argument is step case, second argument is base case
16:59:46 <clausen> the code didn't come out clearly on that paste site
16:59:51 <clausen> (no identing, etc.)
17:00:06 <clausen> sorry about that
17:00:11 <clausen> I was expecting to see
17:00:11 <clausen> 4
17:00:41 <sieni> clausen: there is a very precise definition of a recursive function, which you can find, e.g. from http://en.wikipedia.org/wiki/Recursive_function
17:00:45 <clausen> but I got (lambda s.  lambda z.  (lambda s'. lambda z'. s' (s' z')) s ((lambda s'.
17:00:45 <clausen> lambda z'.  (lambda s''. lambda z''. s'' (s'' z'')) s' (0 s' z')) s z))
17:00:45 <clausen>  instead
17:02:08 <norpan> for instance
17:02:14 <clausen> sieni, I wasn't thinking of recursion in that sense
17:02:23 <norpan> add 0 n = n, add (m+1) n = succ (add m n)
17:02:36 <sieni> clausen: o rly?
17:02:36 <clausen> sieni, the definition there is basically about semantics, not structure
17:03:06 <clausen> sieni, it's a set of mathematical functions, rather than syntatic
17:03:34 <norpan> so add' m n s z = m s (n s z)
17:03:40 <Cale> dfeuer: yes, you can encode quite sophisticated invariants actually
17:03:47 <norpan> (the step case is succ and the base case is n)
17:04:02 <norpan> sieni: do you see what i mean
17:04:06 <int-e> @type let add' m n s z = m s (n s z) in add'
17:04:07 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2) -> (t -> t3 -> t1) -> t -> t3 -> t2
17:04:09 <sieni> norpan: no
17:04:21 <clausen> norpan, I think I'm ok with add
17:04:28 <Cale> dfeuer: from what I recall, all of the invariants for a 2-3 tree
17:04:29 <norpan> ok, take mult
17:04:33 <dfeuer> Cale, can you point me to an article?
17:04:43 <clausen> norpan, yeah, mult I need help with :)
17:04:53 <dfeuer> A 2-3 tree is similar to a red-black tree?   or isomorphic?
17:05:01 <Cale> dfeuer: Let me find how to do that one :) I'm not sure about an article which really describes things in depth
17:05:16 <int-e> mult n m = n (add m) 0 ... then simplify.
17:05:34 <clausen> dfeuer, 2-3-4 tree
17:05:41 <dfeuer> clausen, hmm?
17:05:47 <norpan> mult 0 n = 0; mult (m+1) n = add n (mult m n)
17:05:53 <dfeuer> I haven't studied 2-3 or 2-3-4 trees yet.
17:06:01 <sieni> dfeuer: maybe... I thought that a 2-3-4 tree is isomorphic to a red-black-tree (trivially), but I might be wrong; it could be 2-3 -trees
17:06:02 <clausen> dfeuer, 234 trees are "the same" as red-black trees
17:06:09 <dfeuer> ah
17:06:09 <clausen> (2-3 trees aren't)
17:06:47 <Cale> dfeuer: a 2-3 tree is a B-tree which can contain only 2-nodes and 3-nodes, where 2-nodes have 1 element and 2 children and 3-nodes have 2 elements and 3 children, and also, all leaves occur at the same level.
17:07:13 <Cale> data Node a = Node2 a a | Node3 a a a
17:07:21 <dfeuer> all leaves occur at the same level in all B-trees, right?
17:07:29 <clausen> int-e, don't you need "s" and "z" on the left side?
17:07:31 <Cale> data Tree23 a = Zero a | Succ (Tree23 (Node a))
17:07:35 <clausen> (i.e. lambda s and lambda z)
17:07:49 <Cale> yeah
17:08:09 <clausen> Cale, huh?
17:08:29 <clausen> Cale, B-trees don't have any balancing invariants, right?
17:09:03 <int-e> clausen: I've eta-reduced them away. (they're hidden in 0 and add if you prefer that view)
17:09:26 <Cale> clausen: Usually you ensure that all leaves are at the same depth.
17:09:33 <norpan> mult 0 n = 0; mult (m+1) n = add n (mult m n)
17:09:35 <norpan> ::.
17:09:36 <norpan> 
17:09:48 <norpan> oops
17:09:59 <int-e> (eta-reduction: \x -> f x = f)
17:10:19 <sieni> clausen: the equal depth condition for 2-3-4-trees is the same as the red-black-treeness condition for red-black-trees
17:11:13 <clausen> sieni, you don't get equal depth in 234-trees, IIRC
17:11:28 <clausen> sieni, you just get that each leaf is roughly the same depth
17:11:29 <dfeuer> 2-3-4 trees collapse red nodes into their parents or something?
17:12:02 <clausen> sieni, (you get a bound on the depth of the tree as a function of the number of items)
17:12:13 <sieni> dfeuer: there are no red or black nodes in 2-3-4-trees
17:12:23 <clausen> int-e, what does "\x -> f x = f" mean?
17:12:29 <dfeuer> sieni, I meant to get a 2-3-4 tree from a red-black tree.
17:12:42 <int-e> clausen: \x -> f x  is the same as   f
17:12:58 <sieni> http://en.wikipedia.org/wiki/2-3-4_tree
17:13:06 <sieni> http://en.wikipedia.org/wiki/2-3-4_tree
17:13:10 <sieni> sorry
17:13:21 <sieni> http://en.wikipedia.org/wiki/Red-black_tree
17:14:20 <clausen> int-e, I guess that's just currying
17:14:32 <clausen> int-e, the thing is, you curried it, but still referred to 0
17:14:53 <int-e> clausen: 0 = \s z -> z
17:15:05 <sieni> so the isomorphism is (I think the following: if you have a red-black tree, then you just collapse all black nodes and its red children into a node in the corresponding 2-3-4 tree
17:15:05 <clausen> hmmm
17:15:19 <dfeuer> sieni, that's what I was guessing.
17:16:07 <dfeuer> Cale, are you sure the type definition you gave works? It looks kind of sketchy to me.
17:16:40 <sieni> well, the opposite isn't actually exact, since at a 3-node you have two choices
17:16:44 <Cale> dfeuer: it's a little awkward, but it does
17:16:51 <sieni> but I guess the end result is the same
17:17:05 <sieni> it's just Yet Another Theorem
17:19:16 <sieni> but the 2-3-4-tree is useful, since you can make it a 2-3-4-...-4094-4095-tree or something and optimize everything for disk access or something
17:21:18 <Cale> dfeuer: You sort of look at the types of Zero and Succ as a funny term-rewriting system
17:21:35 <Cale> Zero :: a -> Tree23 a
17:21:49 <Cale> Succ :: Tree23 (Node a) -> Tree23 a
17:22:26 <Cale> In the end, you're interested in getting (Tree23 a)'s
17:23:07 <clausen> int-e, well, it doesn't seem to evaluate correctly
17:23:10 <clausen> let's got back to add
17:23:10 <Cale> When you build things up with the Node2 and Node3 constructors, you'll get a pileup of Node type constructors, which applying Succ will eliminate afterward
17:23:28 <dfeuer> Cale, I'll have to think a bit, but I think I'm seeing it.
17:23:30 <clausen> int-e, is it possible to write add without directly using "s" and "z"?  (i.e. by currying away s and z)?
17:23:54 <dfeuer> Cale, you could do the same with 2-3-4 trees, right?
17:24:20 <int-e> it's not currying.
17:24:35 <Cale> dfeuer: yeah
17:25:33 <dfeuer> Could you do it for red-black trees, or would that just be too complicated?
17:26:09 <dfeuer> (or AVL trees?)
17:27:24 <int-e> clausen: you could write add n m = n succ m ... with succ = \n s z . s (n s z)
17:27:38 <int-e> (the . is the same as -> )
17:28:58 <int-e> clausen: you won't have any luck with simplifying succ though.
17:29:26 <norpan> but back to mult
17:29:40 <norpan> i had mult 0 n = 0; mult (m+1) n = add n (mult m n)
17:29:56 <norpan> so base case is 0 and step case is add n
17:30:15 <clausen> norpan, what does "mult (m+1) n = ..." mean?
17:30:35 <norpan> which gives mult m n s z = m (n s) z
17:30:38 <clausen> (also, does the two mult expressions really mean if ... then ... else?)
17:30:46 <norpan> it's haskell syntax
17:30:55 <norpan> or mathematics syntax
17:31:01 <norpan> it's the two cases of recursion
17:31:05 <clausen> norpan, I want to know how it relates to lambda calculus syntax
17:31:10 <clausen> (I'm familiar with the haskell notation)
17:31:18 <norpan> it doesn't
17:31:30 <norpan> it's pattern patching
17:31:46 <clausen> norpan, you can do an if...then...else construction?
17:32:11 <norpan> mult m n = if m == 0 then 0 else n + (mult (m-1) n)
17:33:02 <int-e> clausen: iszero n = n (const false) true; false x y = y; true x y = x; const a b = a. if a b c = a b c
17:33:41 <dfeuer> Anyone here know of work on ropes or similar structures since the Boehm et al. paper of 1995?
17:34:40 <norpan> anyway, time to sleep
17:37:11 <pejo> dfeuer, if you can find the paper on scholar.google there is a "Cited by <n> papers" link. 
17:37:27 <dfeuer> good thought...
17:37:32 <clausen> norpan, lambda calculus doesn't have recursion like that, AFAIK
17:38:22 <monochrom> lambda calculus has a Y combinator.  You can use it to code up any recursion.
17:39:02 <clausen> mokus, agreed
17:50:11 <clausen> (monochrom, sorry)
17:51:37 <clausen> hmmm, would you expect this to work:
17:51:51 <clausen> zero = lambda s. lambda z. z
17:51:51 <clausen> one = lambda s. lambda z. s zero
17:52:04 <int-e> no
17:52:35 <int-e> one = lambda s. lambda z. s z
17:52:43 <clausen> can you use zero, and make it work?
17:52:59 <clausen> I guess you need one = lambda s. lambda z. s (zero s z)
17:53:07 <int-e> yes, that'll work
17:53:19 <int-e> and also zero s (s z)
17:53:20 <clausen> so, I think the definition of mult you gave me above has the same problem
17:53:28 <int-e> no.
17:53:45 <int-e> I've tested it, actually, just to be on the safe side.
17:54:02 <int-e> it's akin to one = succ zero (with an appropriate definition of succ)
17:54:26 <clausen> int-e, you've got a complete machine-runnable program?
17:54:37 <clausen> could I see it please?
17:56:30 <int-e> > let zero s z = z; succ n s z = s (n s z); one = succ zero; two = succ one; add n m = n succ m; mul n m = n (add m) zero; asInt n = n (+1) 0 in (asInt two, asInt (add two one), asInt (mul two two))
17:56:31 <lambdabot>  (2,3,4)
18:00:14 <clausen> oh, lambdabot is yet another implementation :)
18:00:23 <clausen> I couldn't get it to work in haskell :/
18:00:45 <clausen> oops, I can
18:00:46 <clausen> thanks!
18:02:12 <int-e> There is a very short lambda term for multiplication but I think it's uninstructive.
18:02:21 <clausen> that's ok
18:02:23 <clausen> I'll look at this later
18:02:28 <clausen> time for me to socialize now!
18:02:44 <clausen> I just wanted to get some information I could look at later
18:02:50 <clausen> what you gave me is good!  thanks!
18:02:52 <clausen> bye!
18:04:06 <int-e> Hmm. Now I feel I've just solved a homework problem. Oh well :/
18:04:29 <aFlag> hi, is f :: forall a. a -> a; a haskell 98 thing, or is it a ghc thing?
18:06:13 <sieni> int-e: somebody is using haskell for homework? I thought they all were using Java or C#.net, since that's the industry standard
18:07:54 <aFlag> i mean, I couldn't find anything in the haskell report
18:08:02 <aFlag> so I'm guessing it's a ghc thing
18:08:39 <sieni> no
18:10:01 <aFlag> no what?
18:10:03 <sieni> <
18:10:08 <int-e> aFlag: the explicit forall a. is a ghc thing
18:10:11 <sieni> > @type 6
18:10:11 <lambdabot>  Parse error
18:10:17 <aFlag> ok, thanks
18:10:17 <sieni> oops
18:10:21 <sieni> @type 6
18:10:22 <lambdabot> forall t. (Num t) => t
18:10:41 <sieni> @type \x -> head [x]
18:10:43 <lambdabot> forall a. a -> a
18:10:46 <int-e> aFlag: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#universal-quantification
18:11:22 <sieni> I think such constructs like \x -> head [x] are valid Haskell 98
18:11:27 <int-e> aFlag: on the other hand, the type forall a. a -> a is the type of id.
18:11:50 <int-e> sieni: yes, but the forall a. a -> a  syntax is not valid in Haskell 98.
18:12:20 <int-e> sieni: the type is denoted as just  a -> a  instead
18:15:30 <aFlag> yeah, code that uses "forall a." doesn't work on hugs, so I was wondering if hugs was deviating from haskell 98 in that point.
18:16:21 <aFlag> But since I couldn't find anything on haskell 98 report I thought it might been a ghc thing or I didn't looked up the report enough
18:39:19 <dons> moin
19:23:26 <dons> ?uptime
19:23:26 <lambdabot> uptime: 12 hours, 27 minutes and 5 seconds
20:26:08 <JohnMeacham> must... resist.... urge.... to write own..... widget set.... in haskell.....
20:27:09 <dons> heh
20:27:19 <johnnowak> JohnMeacham: That's probably a good thing to resist. :)
20:27:26 * johnnowak thinks the world has enough already
20:30:02 <dfeuer> JohnMeacham, your name looks familiar.
20:32:15 <JohnMeacham> dfeuer, perhaps we have met. I live in Pasadena, CA
20:32:35 <JohnMeacham> (that's california, not canada)
20:32:39 <dfeuer> No...
20:33:12 <JohnMeacham> My namesake was on the colbert report the other day.
20:33:21 <dfeuer> Do you have a sort of chatroom/forum using no-longer-maintained software?
20:33:28 <JohnMeacham> gale.
20:33:41 <JohnMeacham> it is maintained, just not by the original author.
20:33:43 <JohnMeacham> gale.org
20:34:10 <JohnMeacham> my client is implemented in Haskell, it is called ginsu.
20:51:27 <petekaz> @seen dons
20:51:27 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 24 minutes and 17 seconds ago.
20:52:51 <petekaz> dons: how do I build lambdabot now?  I tried the instructions in the README, but after running the first ./Setup command, I get: *** Exception: Line 19: Unknown field 'hs-source-dirs'
20:56:39 <dons> yo
20:56:50 <dons> oh, looks like your cabal is too old
20:57:03 <dons> try with a 6.4.2 compiler, and its cabal. or else install the latest stable cabal
20:57:14 <petekaz> I see, I am just using debian packages so that's probably true.
20:57:22 <dons> hmm, though replacing "hs-source-dirs" with "hs-source-dir" might just work too
21:00:30 <petekaz> I'll go search for a newer ghc.
21:02:59 <mauke> mine says Setup.hs: cannot satisfy dependency plugins>=1.0
21:03:12 <dons> that's because you haven't instaled hs-plugins
21:03:17 <petekaz> that's what mine says after fixing the hs-source-dirs.
21:03:25 <dons> ?where hs-plugins
21:03:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
21:03:31 <dons> install the snapshot.
21:03:42 <petekaz> I thought I had installed hs-plugins ...
21:04:04 <dons> your other option is to remove the plugins dependency, and comment out 'runplugs' in the lambdabot.cabal file
21:04:10 <mauke> [ebuild   R   ] dev-haskell/hs-plugins-0.9.10-r1
21:04:26 <dons> yep, too old
21:04:30 <petekaz> yeah, I have .9.10 as well.
21:04:34 <dons> >=1.0 :)
21:04:41 <dons> thoguh, hmm, maybe it'll work.
21:04:47 <mauke> no ebuild available
21:04:52 <dons> maybe the 1.0 dep was a bit too strong.
21:05:01 <dons> try removing the >=1.0  constraing.t.
21:05:40 <mauke> from where?
21:06:00 <dons> from lambdabot.cabal
21:06:18 <mauke> ah, right
21:07:04 <mauke> ./Lib/Util.hs:439: warning: no newline at end of file
21:07:16 <dons> yeah. cpp.
21:07:19 <dons> harmless
21:08:47 <mauke> ./IRC.hs:33:57: Module `Data.ByteString.Char8' does not export `hPutStrLn'
21:09:05 <dons> your fps is too old.
21:09:11 <dons> install the darcs version
21:09:35 <mauke> heh, isn't that what version dependencies are for? :-)
21:10:03 <dons> oh, yes, it depends on 0.7, which is the darcs version, which changes
21:10:15 <dons> i don't tweak the 0.7 tag on each new patch
21:10:22 <dons> however, soon enough, 0.7 will be stable
21:11:13 <dons> well, it is stable.
21:12:11 <mauke> dist/build/BotPP/BotPP-tmp/Main.o:(.text+0x237): undefined reference to `DataziByteString_lvl_closure'
21:13:57 <mauke> removing all *.{o,hi} files worked
21:13:59 <dons> probably you need to ./Setup clean , since you installed a new fps half way through the build, right?
21:14:05 <mauke> yep
21:14:22 <mauke> this one's interesting: /usr/lib/gcc/i386-pc-linux-gnu/3.4.6/../../../../i386-pc-linux-gnu/bin/ld: cannot find -lHSCabal-1.1.3
21:14:55 <dons> your ghc-pkg doesn't know which cabal to use?
21:15:00 <mauke> it's interesting because I don't have cabal-1.1.3, only 1.1.4
21:16:34 <dons> did you ./Setup configure again? that might help
21:16:42 <mauke> can I just delete my user package.conf or will that break things?
21:17:51 <dons> hmm. that should be ok, i think. i  am not a lawyer though
21:18:15 <mauke> ghc-6.4.1: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
21:18:15 <mauke>         unknown exception
21:19:02 <dons> oh, that's a ghc 6.4.1 bug to do with messing up the cabal installations
21:19:30 <dons> you'll have to either check the mailing lists for this 'unknown exception' bug, or else install 6.4..2
21:22:31 <mauke> errors while building 6.4.2: http://rafb.net/paste/results/KRuh1z52.html
21:23:39 <dons> you can't install a binary snapshot?
21:23:55 <dons> oh, that's just haddock failing
21:24:13 <dons> perhaps you can just continue on (mke -k) ?
21:24:15 <dons> make -k
21:24:58 <mauke> no idea how to do that with emerge
21:27:33 <mauke> ok, another Setup clean and rebuild says scripts/RunPlugs.hs:1:0:ghc-6.4.1: unknown package:Cabal-1.1.3
21:28:09 <dons> ghc-pkg list ?
21:31:22 <mauke> w00t, re-emerging hs-plugins worked
21:32:09 <dons> cool
21:32:25 <dons> hopefully the pkg db is unscrambled now
21:33:26 <mauke> yay, lambdabot exits on ^D
21:34:00 <mauke> lambdabot> > 2+2
21:34:00 <mauke> IrcMessage {msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@run  2+2"]}
21:34:03 <mauke>   Failed to load interface for `ShowQ':
21:34:06 <mauke>    Could not find module `Show...
21:36:16 <dons> oh, I haven't fixed that. here's how to fix it:
21:36:38 <dons> cd scripts ; ghc -c ShowQ.hs ; mv ShowQ.hi ShowQ.o ..
21:36:54 <dons> its the new build system i wrote yesterday. Looks like I'm missing a dependency on runplugs
21:37:23 <dons> adding: Other-modules:       ShowQ
21:37:28 <mauke> yay!
21:37:32 <dons> to the runplugs stanza of lambdabot.cabal should help
21:39:08 <mauke> where is the EOF handling? I want it to print a newline before exiting
21:39:56 <dons> before exiting what? lambdabot?
21:40:05 <mauke> yes
21:40:16 <dons> I'm working on that now, actually. 
21:40:29 <dons> I've rewritten the signal and exception handling, so it'll be much easier
21:40:36 <dons> give me 30 mins to check in the patch and test
21:40:47 <mauke> ok. thanks :-)
21:42:20 <dons> I actually understand how signals and exceptions are dealt with in lambdabot now, mostly :)
21:42:25 * dons writes copious docs
21:44:23 <mauke> hmm, what's the best way to make lambdabot understand @quit in offline mode?
21:44:39 <mauke> currently it says not enough privileges
21:45:23 <dons> oh, add yourself to the Config.hs admin list.
21:45:32 <dons> or use ^D / eof to exit :)
21:45:47 <dons> hmm. hang on. in offline mode. hmm.
21:46:06 <dons> hmm, quit should just work in offline mode.
21:46:15 <dons> do you have the latest lambdabot code?
21:46:28 <mauke> I am an admin, but null!n=user@null isn't
21:46:35 <mauke> I think so
21:46:35 <dons> look in IRC.hs offlineReaderLoop
21:46:59 <dons> it just toses out an error "<quit>". there's no concept of nicks in the offline mode
21:47:07 <mauke> quit works, but @quit doesn't
21:47:13 <dons> $ ./lambdabot 
21:47:13 <dons> Initialising plugins ... .......................................done.
21:47:13 <dons> lambdabot> quit
21:47:13 <dons> Exception: <quit>
21:47:13 <dons> Unloading modules ... done.
21:47:15 <dons> Exiting: <quit>
21:47:21 <dons> yes. no commands work with @ prefixes in offline mode
21:47:25 <dons> they're redundant
21:47:36 <dons> so you don't add them. just use the unprefixed command name
21:48:33 <mauke> all commands work with @ prefixes here
21:48:52 <mauke> @@run 2+2
21:48:53 <lambdabot>  4
21:49:14 <dons> oh, that's just spell checking kick ing
21:49:38 <dons>  @run 2+2 should work in offline mode too.
21:50:39 <mauke> hmm, then why is @quit different?
21:50:49 <mauke> oh, I see
21:55:12 <mauke> why doesn't ircQuit exit lambdabot in offline mode?
21:56:20 <dons> ircQuit just diconnects from the server.
21:56:24 <dons> but "quit" should exit.
21:56:44 <dons> the quit/exiting/exception story is getting fixed atm :)
21:56:57 <dons> i.e. lambdabot> quit
21:56:57 <dons> Exception: <quit>
21:56:57 <dons> Unloading modules ... done.
21:56:57 <dons> Exiting: <quit>
22:00:51 <mauke> I changed it to let m  = IRC.IrcMessage { IRC.msgPrefix  = head (Config.admins Config.config) ++ "!n=user@null"
22:05:11 <dfeuer> @@run let x = 3 in x * x
22:05:12 <lambdabot>  9
22:06:19 <mauke> @pl let x = 3 in x * x
22:06:20 <lambdabot> 9
22:06:29 <mauke> lambdabot: you win!
22:06:44 <dons> ?
22:07:00 <dfeuer> pl?
22:07:05 <dons>  @pl is clever, isn't it.
22:07:11 <dons> ?pl \x -> f x + f x
22:07:11 <lambdabot> liftM2 (+) f f
22:07:33 <dfeuer> WTF is lambdabot?  It looks kinda smart...
22:07:46 <mauke> @vixen you look kinda smart
22:07:46 <lambdabot> yes
22:07:47 <dons> > map (+1) [1..10]
22:07:48 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:07:53 <dons> ?vixen-on
22:07:54 <lambdabot> What's this channel about?
22:08:00 <dons> you're smart, aren't you vixen?
22:08:00 <lambdabot> yes, i'm very much a vixen
22:08:07 <dons> and you like haskell?
22:08:07 <lambdabot> Ooh, functional programmers are so hot!
22:08:10 <dons> that's true.
22:08:10 <lambdabot> are you horny?
22:08:10 <dfeuer> lambdabot, will you come to bed with me?
22:08:13 <dfeuer> yes.
22:08:13 <lambdabot> that's what i figured
22:08:19 <dons> ?vixen-off
22:08:19 <lambdabot> Bye!
22:08:55 <dons> ?version
22:08:56 <lambdabot> lambdabot 3.1p90, GHC 6.5 (OpenBSD i386 )
22:08:56 <dfeuer> ?vixen-on
22:08:56 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:08:56 <lambdabot> Not enough privileges
22:09:11 <dons> dfeuer: its a large haskell irc bot develoepd in this channel over the last 5 years
22:09:18 <dons> some 11k lines of haskell now
22:09:20 <dfeuer> What sorts of priveleges does one need to turn on vixen mode?
22:09:24 <dfeuer> Wowzers.
22:09:34 <dons> you can install it locally, if you'd like to talk to her :)
22:09:43 <dons> or ask her explicitly:
22:09:46 <dons> ?vixen hey !
22:09:46 <lambdabot> hello
22:09:48 <dfeuer> I was somewhat impressed by sarahbot over in #scheme, but this one, so far, looks much smarter.
22:09:55 <dfeuer> ?vixen hey !
22:09:55 <lambdabot> hello
22:09:59 <dfeuer> ?vixen What?
22:09:59 <lambdabot> let me answer that later, okay?
22:09:59 <dons> ?type map
22:10:00 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:10:04 <dons> ?kind Maybe
22:10:05 <lambdabot> * -> *
22:10:10 <dons> ?docs Data.Maybe
22:10:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
22:10:15 <dfeuer> Who gives out priveleges for lambdabot?
22:10:20 <dons> ?hoogle (a -> b) -> [a] -> [b]
22:10:21 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
22:10:21 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
22:10:21 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
22:10:28 <dons> ?djinn a -> b -> (a,b)
22:10:28 <lambdabot> f a b = (a, b)
22:10:43 <dons> ?. type djinn a -> b -> (a,b)
22:10:45 <lambdabot> parse error on input `='
22:10:55 <dons> ?. djinn type id
22:10:56 <lambdabot> f a = a
22:11:02 <dfeuer> lambdabot, what can you do?
22:11:05 <mauke> @list
22:11:06 <lambdabot> list [module|command]. Where modules is one of:
22:11:06 <lambdabot> babel base compose dice dict djinn drhylo dummy elite fact fresh haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system tell
22:11:06 <lambdabot> todo topic type unlambda version vixen where
22:11:24 <dons> ?babel en de how do you like the soccer?
22:11:25 <lambdabot>  wie Sie mgen den Fuball?
22:11:37 <dons> ?instances Integral
22:11:38 <lambdabot> Int, Integer
22:11:43 <mauke> ?babel de en Dein deutsch ist furchtbar
22:11:44 <lambdabot>  Yours German is terrible
22:12:13 <dons> ?localtime dfeuer
22:12:13 <lambdabot> Local time for dfeuer is Sat Jun 10 01:11:34
22:12:38 <dons> ?quote 
22:12:39 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
22:12:39 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
22:13:40 <dfeuer> ?what do you think about FORTH
22:13:40 <lambdabot> I know nothing about do.
22:13:48 <dfeuer> ?what do you think about PostScript?
22:13:48 <lambdabot> I know nothing about do.
22:13:55 <dfeuer> lambdabot, what do you think about PostScript?
22:14:07 <dons> ?fact haskell
22:14:07 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
22:14:07 <dfeuer> ?vixen what do you think about PostScript?
22:14:07 <lambdabot> i dunno, what about?
22:14:16 <dons> ?where haskell
22:14:16 <lambdabot> http://haskell.org/
22:14:21 <dons> ?where ghc
22:14:21 <lambdabot> http://haskell.org/ghc
22:14:23 <dons> ?where lambdabot
22:14:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:14:39 <dons> we don't really have much of a fact/opinion data base. never really caught on
22:15:08 <mauke> ?keal
22:15:09 <lambdabot> intuitive != imperative
22:17:01 <Cale> hey, that's actually intelligent :)
22:17:40 <mauke> ?keal
22:17:40 <lambdabot> proofs are no longer sound
22:18:08 <mauke> ?kale
22:18:08 <lambdabot> i can explain why something is without knowing what the rules decided by man are
22:19:42 <dfeuer> The bot is confusing me.
22:19:54 <Cale> how?
22:20:29 <Cale> @keal is a command that prints quotes from this guy who came around here for a while and said lots of crazy stuff.
22:20:29 <lambdabot> bot defective
22:20:51 <Cale> @keal
22:20:51 <lambdabot> one prollem. T broke confines of the visual basic langage and would not compile
22:21:01 <Cale> @palomer
22:21:01 <lambdabot> Learning vim is pointless
22:21:18 <dfeuer> uhhh..
22:21:32 <Cale> @palomer
22:21:32 <lambdabot> Blargh!
22:21:34 <dfeuer> wow...
22:21:43 <Cale> @yow
22:21:43 <lambdabot> Couldn't find fortune file
22:21:46 <Cale> aww
22:21:48 <dfeuer> I don't know how to use the bot.  That's all.
22:21:51 <Cale> ah
22:21:56 <Cale> @list
22:21:56 <lambdabot> list [module|command]. Where modules is one of:
22:21:56 <lambdabot> babel base compose dice dict djinn drhylo dummy elite fact fresh haddock help hoogle instances karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system tell
22:21:56 <lambdabot> todo topic type unlambda version vixen where
22:22:07 <dfeuer> Who would say learning Vim is pointless?
22:22:13 <Cale> palomer did
22:22:22 <dfeuer> Crayzee
22:22:22 <Cale> I'm not sure if he was serious
22:22:26 <dfeuer> Is he gone now?
22:22:32 <dfeuer> list help
22:22:35 <dfeuer> @list help
22:22:35 <Cale> Well, he's in the channel
22:22:35 <lambdabot> help provides: help
22:22:43 <Cale> @list plugs
22:22:43 <lambdabot> plugs provides: run
22:22:47 <Cale> @help run
22:22:48 <lambdabot> run <expr>
22:22:48 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
22:22:51 <dfeuer> What's the deal with starting lines with ? or @
22:22:59 <Cale> Either works
22:23:08 <Cale> (they're equivalent)
22:23:23 <dfeuer> no IO?  That's no fair.
22:23:37 <Cale> > map (2^) [1..10]
22:23:37 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
22:23:38 <mauke> why do you need IO?
22:23:58 <Pete_I> ?run map (*) [1..10000]
22:23:59 <lambdabot>  Add a type signature
22:24:10 <Pete_I> >  map (*) [1..10000]
22:24:11 <lambdabot>  Add a type signature
22:24:22 <Cale>  > is a shorthand for @run -- it used to be called eval, but that conflicted with another bot somewhere I think, so dons renamed it
22:24:34 <dons> yep. in perl6
22:24:39 <dons> they run a lambdabot there as well
22:24:49 <dons> since we use > foo far more often, i removed the old @eval form
22:24:58 <dons> which the perl6 bot uses for perl, i presume
22:25:01 <dons> (is that safe??)
22:25:04 <Cale> > zipWith ($) (map (*) [1..]) [1..10]
22:25:06 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
22:25:10 <dfeuer> > foo
22:25:10 <lambdabot>  Not in scope: `foo'
22:25:39 <Cale> > liftM2 (,) [1,2,3] [4,5,6,7]
22:25:40 <lambdabot>  [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
22:26:20 <dfeuer> lambdabot, what is Haskell?
22:26:27 <dfeuer> @vixen what is haskell?
22:26:28 <lambdabot> church is my favourite computer scientist.
22:26:33 <Cale> @fact haskell
22:26:34 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
22:26:55 <Pete_I> really? i thought that was LISP
22:27:00 <dons> perhaps we could add a contextual handler to the Fact plugin to answer 'what is' questions
22:27:04 <dons> that might be useful
22:27:05 <Pete_I> or something else...
22:27:18 <Cale> nope, Haskell
22:27:29 <dfeuer> @fact factorial
22:27:29 <lambdabot> I know nothing about factorial
22:27:30 <Pete_I> how do you determine this?
22:27:36 <olliej> > let f=1:1:(zipWith (+) f (tail f) in take 10 f
22:27:36 <lambdabot>  Parse error
22:27:37 <dons> nope. this is the prize awarded by the icfp contest organisers, haskell's one twice in the last two years
22:27:38 <Pete_I> @fact haskell
22:27:38 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
22:27:39 <Cale> by winning the ICFP
22:27:42 <dons> and 3 in the last 6
22:27:50 <dons> s/won/
22:27:56 <dfeuer> How do I tell lambdabot that factorial is the classic Hello World for functional languages?
22:28:06 <dons> ?help fact
22:28:06 <lambdabot> fact <fact>, Retrieve a fact from the database
22:28:12 <dons> ?listcomm fact
22:28:12 <lambdabot> Unknown command, try @list
22:28:15 <dons> ?list fact
22:28:15 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-update
22:28:20 <dons> ?help fact-set
22:28:21 <lambdabot> Define a new fact, guard if exists
22:28:37 <dons> ?fact-set factorial factorial is the classic Hello World for functional languages
22:28:37 <lambdabot> Fact recorded.
22:28:41 <dons> ?fact factorial
22:28:42 <lambdabot> factorial: factorial is the classic Hello World for functional languages
22:29:08 <mauke> http://icfpc.plt-scheme.org/
22:29:55 <dons> ?fact-set ICFP A conference (and related contest) held yearly for the FP community. Haskell's had the distinction of winning the coveted "language of choice" award in 2000, 2004 and 2005
22:29:55 <lambdabot> Fact recorded.
22:30:11 <dons> actually, the icfp contest is an all comers event
22:30:32 <dons> other languages just seem to not do very well.
22:30:38 <dons> though C++ won in 2003, iirc
22:31:07 <Pete_I> what do they rate entrys based on?
22:31:25 <Cale> Whose program performs best on a difficult task
22:31:27 <stepcut> yeah, some grad student had been working on almost the same problem *and* had a bunch of empty labs full of machines to 'brute force' the answer with :(
22:31:35 <stepcut> atleast that is the rumor I heard ;)
22:32:07 <Pete_I> the machines won't get it.
22:32:14 <mauke> the first submission, received after about 18 hours, which when run on our simulator did not at first appear to move the car! Congratulations to TeamEngineRoom, whose lightning entry was almost 100 times slower than the final winner! Deliciously, this entry was produced using Haskell, SML, C, Java, and Perl, along with an Excel spreadsheet and "spline-o-matic"... one of history's great failures, truly.
22:32:19 <Pete_I> he might get it though
22:32:42 <Korollary> heh
22:33:01 <Pete_I> you've gotta be kidding...
22:33:17 <dfeuer> spline-o-matic?
22:33:21 <Pete_I> they submitted that? i'd have been to embarrased to show anybody.
22:33:43 <stepcut> hehe
22:33:50 * dfeuer steals an r and gives up an extra s.
22:35:09 <Cale> I think it would be funny to submit a Malbolge entry to ICFP.
22:35:21 <dfeuer> Malbolge?
22:35:30 <dfeuer> When is the ICFP?
22:35:30 <olliej> Cale: the *pain*
22:35:38 <Cale> Though even getting it to print valid output would probably be impossibly difficult, let alone good output.
22:35:38 <olliej> Cale: that would be sick
22:36:10 <dfeuer> Is that one of those languages that's easier to program by compiling machine code to it?
22:36:46 <mauke> malbolge and easier in the same sentence? I think not
22:36:46 <olliej> um... i believe malbolge was the one that required like a 30 page perl script using ai to generate the code for hello world
22:36:49 <Cale> Malbolge is nearly impossible to program in without a genetic algorithm
22:37:03 <olliej> Cale probably knows more correctly
22:37:10 <olliej> been ages since i looked at it
22:37:16 <Cale> I don't know too much about it
22:37:19 <Cale> http://www.antwon.com/other/malbolge/malbolge.txt
22:37:22 <Cale> that's the spec
22:37:28 <olliej> which is irrelevant
22:37:38 <olliej> because the vm doesn't match the spec exactly
22:37:52 <olliej> that's part of the fun
22:38:12 <dfeuer> Ooh... That's a good definition of whatever you call that class of programming language:  A language that is easier to read after it's compiled to machine code.
22:38:35 <Cale> http://www.99-bottles-of-beer.net/language-malbolge-995.html
22:39:02 <mauke> http://www.lscheffer.com/malbolge.shtml
22:39:18 <Pete_I> ugly...
22:42:32 <dons> ?unlambda `i.*
22:42:32 <lambdabot> Done.
22:42:56 <dons> i always forget my unlambda syntax
22:45:11 <mauke> ?unlambda `.*i
22:45:12 <lambdabot> *
22:45:40 <dons> ah, yes.
23:01:00 <palomer> learning vim IS pointless
23:01:19 <Pete_I> it isn't pointless....
23:01:29 <Pete_I> unless you're learning lisp. then it's pointless.
23:01:30 <mauke> why is it pointless?
23:02:01 <palomer> because there are far superior editors
23:02:40 <Pete_I> right...right....
23:02:46 <mauke> for example?
23:02:49 <Pete_I> vim and emacs.
23:02:56 <Pete_I> that's about it.
23:03:18 <palomer> emacs > vim
23:03:31 <mauke> emacs is not vim, therefore it sucks
23:03:39 <SamB> vim is *not* superior to vim. at least, not in general.
23:03:54 <Pete_I> no, emacs is not vim, thus it is different. it does not suck.
23:04:14 <palomer> I'm sorry, but noone is making sense right now
23:04:20 <mauke> emacs sucks, regardless of vim
23:04:26 <palomer> emacs rocks
23:04:31 <palomer> especially the latest snapshot
23:04:37 <SamB> mauke: of course emacs sucks, duh!
23:04:37 <Pete_I> emacs doesn't suck.
23:04:55 <SamB> it is so large, it is like a black hole that sucks in even light!
23:05:04 <Pete_I> no, that's windows.
23:05:06 <SamB> but it is still my favorite editor ;-)
23:05:15 <mauke> emacs messes with my terminal cursor. this is not acceptable.
23:05:28 <Pete_I> mauke, use xemacs then
23:05:30 <palomer> the problem lies in your cursor
23:05:31 <mauke> especially for something that's supposed to be fully customizable.
23:05:49 <mauke> Pete_I: does that run in a terminal?
23:06:02 <Pete_I> ....nope
23:06:07 <mauke> then what's the point?
23:06:09 <palomer> xemacs is...pointless
23:06:10 <SamB> mauke: so use it in X, derrr
23:06:13 <Pete_I> of course, you could always use ed.
23:06:20 <mauke> SamB: I want something that runs in screen
23:06:23 <mauke> like vim
23:06:55 <SamB> mauke: oh, well, fix screen
23:07:03 <mauke> SamB: huh?
23:07:05 <takuan> why bother discussing emacs vs vim
23:07:14 <palomer> no bother
23:07:16 <palomer> emacs is better
23:07:17 <takuan> it has been done since ages and all to no avail
23:07:21 <Pete_I> takuan, it is quite pointless. thus is the nature of a holy war.
23:07:29 <mauke> I'm discussing "emacs sucks"
23:07:29 <takuan> voila Pete_I 
23:07:31 <skew> heretics, you should be running yi
23:07:38 <skew> and if yi sucks, you should be fixing it.
23:07:40 <SamB> mauke: you say it has a broken cursor!
23:07:42 <takuan> you'd rather code some haskell instead of doing that
23:07:46 <palomer> yi currently sucks
23:07:50 <palomer> worse than both emacs and vim
23:07:59 <Pete_I> notepad ftw!
23:08:11 <palomer> if they fixed their character input speed, I'd consider improving it
23:08:17 <SamB> skew: why to be fixing an editor which must be recompiled so much?
23:08:21 <mauke> SamB: I say it insists on switching my cursor to VERY VISIBLE mode
23:08:37 <mauke> this happens in C code and is not fixable without recompiling emacs
23:08:38 <SamB> mauke: oh?
23:08:55 * SamB doesn't remember his cursor having modes
23:09:31 <dfeuer> All text editors suck.
23:09:31 <SamB> except maybe "terminal focused" and "terminal not focused" versions
23:09:39 <dfeuer> Vim is the best I've used so far.
23:09:40 <mauke> try a linux text console, normal cursor = blinking underscore, emacs cursor = huge freaky blinking block
23:09:49 <Pete_I> vi has cursor modes...
23:09:50 <dfeuer> It would be nice to see Edwin go somewhere.
23:10:03 <palomer> edwin is pure crap
23:10:07 <dfeuer> Edwin = Emacs written in Scheme instead of Elisp.
23:10:10 <SamB> no, no, you must be able to patch the instructions!
23:10:20 <mauke> palomer: another suck: emacs doesn't generate text files by default
23:10:27 <palomer> mauke: hrm?
23:10:32 <dfeuer> What?
23:10:42 <mauke> yeah, it doesn't terminate the last line
23:10:47 <mauke> you need (setq require-final-newline t) to fix it
23:10:49 <SamB> oh, well, if you would just run under X, your cursor would be a tiny, normal blinking block
23:11:02 <palomer> mauke: I'm pretty sure emacs21 does it by default
23:11:07 <palomer> though the newest snapshot doesn't
23:11:07 <SamB> dfeuer: isn't it written in CMU CL?
23:11:23 <dfeuer> MIT Scheme.
23:11:26 <palomer> and I've found that adding the newline is a huge pain sometimes
23:11:54 <dfeuer> Huge pain why?
23:12:02 <SamB> palomer: oh?
23:12:06 <mauke> this is not "adding" the newline, it's generating well-formed text files
23:12:08 <palomer> when I don't want there to be a newline at the end?
23:12:21 <mauke> then you use a binary editor, like vim
23:12:33 <dfeuer> hmm?
23:12:34 <SamB> mauke: I don't remember seeing a standard for text files
23:13:08 <mauke> SamB: I use the C definition of text files
23:13:25 <dfeuer> For reasons I don't know, text files conventionally end with a newline.
23:13:41 <SamB> mauke: next you are going to complain that emacs needs to validate the files it reads, too!
23:13:42 <dfeuer> palomer, adding the newline is a huge pain when you don't want a newline?
23:13:47 <dfeuer> THat sounds confusing.
23:13:58 * SamB would like to see schemas for plaintext files ;-)
23:14:11 <mauke> palomer: more suck: it displays a completely useless "menu bar", which wastes a line of my terminal
23:14:56 <dfeuer> Emacs, unlike Edwin, can be SLOW.
23:15:23 <mauke> maybe it's supposed to be user-friendly, but I have no idea what to do with "File Edit Options Buffers Tools Help"
23:15:24 <SamB_XP_> mauke: yeah, that is annoying!
23:15:33 <Pete_I> any editor is slow if you give it a big enough file.
23:15:34 <SamB_XP_> I'm wanting it to be fixed so you can actually use it!
23:15:37 <dfeuer> aye aye.
23:15:42 <SamB_XP_> by, like, clicking with the mouse!
23:15:43 <palomer> mauke: menu-bar-mode
23:15:50 <palomer> dfeuer: yes
23:15:57 <Pete_I> SamB_XP_, that'd be quite nice.
23:16:00 <mauke> palomer: I know. why does that option even exist if it isn't useful?
23:16:04 <palomer> emacs is never slow with me
23:16:08 <dfeuer> EMACS = Escape Meta Alt Control Shift.  And yes, that's a problem.
23:16:10 <palomer> the toolbar?
23:16:11 <palomer> is for newbs
23:16:22 <palomer> Alt = Meta
23:16:24 <dfeuer> palomer, newbs can't figure out how to use it.  Neither can anyone else.
23:16:25 <palomer> silly goose
23:16:26 <mauke> palomer: it doesn't do anything. how is it for newbs?
23:16:28 <dfeuer> palomer, Alt != Meta.
23:16:41 <palomer> mauke: ok, what are you talking about again?
23:16:47 <palomer> Alt == Meta
23:16:54 <dfeuer> Alt ~= Meta
23:17:00 <palomer> Alt === Meta
23:17:05 <dfeuer> palomer, you're WRONG.
23:17:08 <SamB_XP> palomer: fortunately, no attempt is made to display the toolbar in terminal mode ;-)
23:17:11 <mauke> palomer: the first line, which displays "File Edit Options Buffers Tools Help" in reverse video
23:17:12 <palomer> no, you
23:17:24 <SamB_XP> palomer: because it would not be very easy to see the icons on a terminal
23:17:29 <palomer> mauke: yeah, you can do copy/paste, etc...
23:17:33 <mauke> palomer: HOW?
23:17:40 <palomer> cleck on edit
23:17:43 <palomer> click copy
23:17:45 <mauke> doesn't do anything
23:17:50 <palomer> sure?
23:17:55 <mauke> yes
23:18:01 <SamB_XP> mauke: I heard screen doesn't have mouse support?
23:18:13 <palomer> I just did it.
23:18:18 <palomer> it does something.
23:18:26 <palomer> though I am using emacs-snapshot
23:18:27 <mauke> SamB_XP: this is outside of screen
23:18:44 <palomer> sam_: the no, you comment was for dfeuer
23:18:46 <mauke> palomer: what terminal?
23:18:47 <dfeuer> wtf?  I try to run emacs and it tries to open an X connection?
23:18:51 <SamB_XP> mauke: oh
23:18:54 <mauke> dfeuer: see?
23:19:03 <palomer> mauke: oh, I'm running in X
23:19:26 <dfeuer> I think someone set up emacs wrong.
23:19:39 <sethk> anyone know how to change the color for a widget in gtk2hs?  Specifically I want to change foreground and background colors in a GtkEntry widget.
23:19:45 <mauke> palomer: try DISPLAY= emacs
23:19:50 <SamB_XP> dfeuer: well, um, it doesn't know if you don't want it to run as a window, unless you tell it
23:20:03 <palomer> who the hell uses the console anymore, anyways
23:20:09 <mauke> palomer: I do
23:20:11 <palomer> you want to edit files remotely, use tramp
23:20:13 <palomer> mauke: why?
23:20:15 <dfeuer> s/console/terminal
23:20:20 <mauke> palomer: why not?
23:20:38 <palomer> because you lose features
23:20:39 <sethk> SamB_XP, You can cut and paste in a screen window (I start a konsole and then ssh to the box where screen is running, then screen -x screenId)
23:20:46 <palomer> certain packages are not available
23:20:49 <mauke> it's fine for irc, coding, news, etc
23:20:51 <palomer> the font is uglier
23:21:07 <palomer> I used erc for half a year
23:21:08 <SamB_XP> sethk: truly cut?
23:21:13 <dfeuer> Can someone else explain to palomer that Alt and Meta aren't the same?
23:21:15 <palomer> xchat is so much beter
23:21:17 <palomer> better
23:21:19 <palomer> I don't get gnus
23:21:30 <sethk> SamB_XP, I think so.  Definitely copy.  I'll check again for cut.
23:21:31 <palomer> dfeuer: no, because they are
23:21:42 <sethk> SamB_XP, but whatever works in a konsole also works in the screen
23:21:49 <mauke> palomer: they aren't
23:21:58 <palomer> they aren't what?
23:22:03 <sethk> dfeuer, whether Alt and Meta are the same (or not) is configurable
23:22:06 <mauke> the same
23:22:19 <dfeuer> sethk, yeah, configurable within each program.
23:22:22 <sethk> depends on the xmodmap level config
23:22:22 <mauke> alt is often mapped to meta, but not always
23:22:23 <dfeuer> maybe.
23:22:29 <palomer> @palomer
23:22:30 <lambdabot> Brump!
23:22:39 <sethk> mauke, right, and can be remapped also
23:22:40 <dfeuer> I try to have one alt key mapped to meta and one mapped to alt.
23:22:48 <palomer> mauke: emacs-snapshot doesn't have -nx
23:22:55 * SamB_XP finds alt and meta very very confusing
23:22:55 <palomer> mauke: so I'd be worried if I were you
23:23:01 <mauke> what is -nx?
23:23:06 <palomer> no x
23:23:15 <mauke> why should I be worried?
23:23:15 * dfeuer hands palomer a bucky bit.
23:23:15 <palomer> (ie console)
23:23:21 <mauke> I don't use emacs
23:23:22 <palomer> because you use it in the console
23:23:24 <sethk> I'm meta confused by alt, personally
23:23:26 <palomer> dfeuer: they're telling you lies!
23:23:28 <palomer> @palomer
23:23:28 <lambdabot> Hrmph
23:23:30 <palomer> @palomer
23:23:30 <lambdabot> That's a lie
23:23:33 <palomer> there you go.
23:24:00 <mauke> emacs feels so fragile when coming from vim
23:24:06 <palomer> fragile?
23:24:08 <mauke> any key combination can destroy your text
23:24:22 <palomer> try pressking kkk in vim
23:24:38 <mauke> yeah, there's no easy way out, like <esc><esc> in vim
23:24:39 <palomer> and undo can always save the day
23:24:45 <palomer> sure
23:24:46 <palomer> C-g
23:24:48 <sethk> mauke, leave caps lock on, and vim will feel fragile
23:25:12 * dfeuer remapped capslock to control,
23:25:15 <dfeuer> disabled control,
23:25:16 <mauke> <esc>:help, actually. I can never remember how emacs' help system works.
23:25:24 <dfeuer> and mapped a waaaay out of the way key to capslock.
23:25:42 <palomer> the emacs help system is wonderful
23:25:42 <mauke> palomer: but for that you have to remember the undo key combination
23:25:54 <palomer> or click edit->undo
23:26:00 <dfeuer> yeah.  In vim it's just 'u'
23:26:01 <mauke> not in a terminal
23:26:10 <mauke> dfeuer: <esc>:undo
23:26:11 <palomer> do you have mouse in terminal?
23:26:17 <mauke> usually, yes
23:26:27 <palomer> you can't click on edit?
23:26:54 <dfeuer> mauke, hmm?
23:26:54 <SamB_XP> dfeuer: why did you map something to capsloc *explicitly*?
23:27:13 <dfeuer> SamB_XP, because I like my control key where I can reach it?
23:27:18 <mauke> palomer: I can click on edit, but it doesn't do anything
23:27:26 <SamB_XP> I mean, I haven't bothered to remap capslock, but if I did, you can be sure I wouldn't map something else to it
23:27:29 <dons> i've mapped caps lock to ctrl as well. i think that's pretty common
23:27:43 <palomer> hrmph, weird
23:27:46 <mauke> dfeuer: <esc>:undo is easier to remember
23:27:47 <SamB_XP> (I mean, capslock is so useless!)
23:27:52 <dfeuer> SamB_XP, I'm not sure I understand.
23:28:11 <SamB_XP> (If I want caps, I can hold down shift -- I never need that many caps in a row!)
23:28:13 <dfeuer> SamB_XP, I think you misunderstood.  The key that reads "caps lock" is really control.  The key that reads "control" is dead.
23:28:37 <SamB_XP> oh
23:28:45 <mauke> palomer: I also think emacs' undo system sucks because it has no redo
23:29:15 <SamB_XP> but you said that you mapped some out-of-the way key to caplock?
23:29:41 <palomer> you can fake redo
23:29:46 <palomer> but yeah, that does kind of suck
23:29:54 <palomer> alot
23:30:04 <mauke> vim owns you
23:30:09 <SamB_XP> mauke: well, if you undo for long enough it starts redoing, but I do think it would be nice if you didn't have to do do that
23:30:25 <palomer> but vim is lacking so much
23:30:31 <mauke> palomer: like what?
23:30:37 <palomer> it doesn't have a turing complete scripting language
23:30:42 <mauke> hahaha
23:30:51 <mauke> how is vimscript not turing complete?
23:30:59 <dfeuer> SamB_XP, I do occasionally want capslock.
23:31:09 <palomer> vimscript is turing complete?
23:31:17 * SamB_XP doesn't know if he can reach capslock when he isn't trying to hit tab
23:31:18 <Pete_I> caps lock is a horrible invention.
23:31:18 <dfeuer> I don't currently have anything mapped to insert, however.
23:31:40 <mauke> palomer: why wouldn't it be?
23:31:43 <dfeuer> insert is currently mapped to right control (laptop has no right control)
23:31:51 <palomer> I thought I had heard that it wasn't
23:32:00 <palomer> anyways, emacs modes are always more complete
23:32:04 <palomer> they have more bells and whistles
23:32:11 <palomer> which are often very accomodating
23:32:18 <SamB_XP> palomer: if they are any good, yeah!
23:32:29 <mauke> you need infinite storage, of course, but you can get that with variable variables (symbol table access)
23:32:34 <palomer> I also like the emacs help system
23:32:41 <SamB_XP> has anyone else seen nxml-mode and rng-validate-mode?
23:32:45 <mauke> vim7 has real lists and dictionaries
23:33:00 <mauke> palomer: I like vim's help system better
23:33:02 <palomer> in emacs, functions are autodocumented
23:33:08 <palomer> so are variables
23:33:24 <palomer> so you can get help on: a function, a key, a variable, a mode
23:33:35 <palomer> and documenting your own functions is a breeze
23:33:40 <SamB_XP> just *try* and write a validating XML parser for VIM buffers. of course, it would help if you were James Clark's evil twin...
23:34:04 <palomer> right, a validating XML in elisp wouldn't be so hard
23:34:05 <mauke> SamB_XP: should be easy in perl
23:34:16 <mauke> 5 lines or something
23:34:36 * dfeuer wants something like emacs underneath with vim on top.  I hear there's viper, but doubt that goes far enough.
23:35:10 <SamB_XP> mauke: well, try out nxml-mode and you'll see exactly what I mean by "validating"
23:35:50 <SamB_XP> oh, but *please*, try it in X.
23:36:18 <mauke> how do I try it out?
23:36:27 <SamB_XP> your terminal might not support underlining well
23:36:54 <palomer> you can add redo to emacs!
23:36:55 <mauke> and where do I get an xml file?
23:37:03 <palomer> http://www.emacswiki.org/cgi-bin/wiki.pl?RedoMode
23:37:42 <mauke> argh, my internet is borken
23:37:58 <mauke> brb
23:38:22 <SamB_XP> mauke: well, you could make a file called "foo.rng"
23:39:17 <SamB_XP> it works best if the file is, in fact, not valid as-is ;-)
23:39:28 <SamB_XP> (though well-formedness is okay)
23:39:40 <palomer> http://www.youtube.com/watch?v=F5ky5ClIjL8 <--best thing, ever
23:40:03 * SamB_XP goes to bed
23:40:13 * SamB_XP hopes he can find something to read
23:42:12 <palomer> my graphics card make sound when it's working
23:42:14 <palomer> very strange
23:42:20 <mauke_> "edit A ... undo A ... edit B ... undo B ... redo A ...  With the new undo/redo system, the edit deletes the current redos, so when you undo A, there is no way to redo A later.
23:42:39 <mauke_> vim7 pwns j00
23:43:33 <palomer> isn't that the same behaviour as vim7?
23:43:44 <mauke_> no, vim7 has undo branches
23:43:57 <palomer> whoa
23:43:59 <palomer> that's nuts!
23:44:03 <palomer> must be confusing
23:44:33 <mauke_> http://vimdoc.sourceforge.net/htmldoc/usr_32.html
23:44:53 <mauke_> no, because the standard :undo and :redo commands work as expected
23:45:58 <dfeuer> undo branches????  I must upgrade!!!!!!!
23:46:25 <Pete_I> ....i've never needed undo branches....
23:46:28 <mauke_> heh, wait until you see :earlier 30m to restore the text from half an hour ago
23:46:29 <Pete_I> why would you need it?
23:46:48 <Pete_I> that'll be taking massive amounts of hd/ram space.
23:46:51 <dfeuer> Why???  WHY???
23:47:01 <palomer> it's so wrong, yet so right!
23:47:02 * dfeuer points at Boehm et al's ropes.
23:47:19 <palomer> emacs is still superior
23:47:31 <Pete_I> ......
23:47:31 <palomer> look at the emacs latex mode
23:47:37 <palomer> you can edit and view in realtime
23:47:40 <dfeuer> palomer, emacs is better at Lisp.-
23:47:54 <dfeuer> There is no doubt that Emacs is better at Lisp.
23:47:58 <palomer> emacs is better at everything!
23:48:05 <dfeuer> But Emacs is even harder to use than Vim.
23:48:05 <palomer> does vim even have an X mode?
23:48:08 <mauke_> Pete_I: you can restrict the amount of information it records
23:48:12 <dfeuer> palomer, yes.
23:48:14 <Pete_I> palomer, what about simplicity.
23:48:22 <palomer> go back to windows!
23:48:34 <palomer> if you're going to spend any sort of time editing
23:48:35 <dfeuer> Windows is not simple.
23:48:39 <palomer> you better learn to use the best tool out there
23:48:43 <Pete_I> palomer, with a few simple instructions of how esc/i work, you can use vi like nano. emacs is more complicated....
23:48:44 <mauke_> vim!
23:49:07 <dfeuer> But Vim makes so many things fast!
23:49:12 <palomer> and for anyone who had ever used an editor before
23:49:15 <palomer> emacs is more intuitive
23:49:19 <mauke_> palomer: wrong
23:49:20 <Pete_I> hell, i don't know where to start with emacs....
23:49:26 <dfeuer> Just type dfa, for example.
23:49:31 <palomer> mauke: right!
23:49:40 <mauke_> palomer: I'm a counterexample
23:49:48 <mauke_> therefore you're wrong
23:49:53 <dfeuer> Vim could use a better documentation system, but aside from that is easier to learn.
23:49:55 <palomer> lies!
23:50:16 <Pete_I> dfeuer, :help is pretty nice as-is.
23:50:48 <Pete_I> blast, how do you quit emacs?
23:50:58 <dfeuer> Pete_I, for some reason, I have a weird problem where I can't get ctrl-] to do what it should in :help.
23:50:59 <mauke_> I've remapped my help mode keys so q = quit, tab = go to next link, enter = follow link, backspace = go back
23:51:03 <mauke_> Pete_I: C-x C-c
23:51:17 <dfeuer> of course, it's easy to accidentally quit emacs.
23:51:23 * johnnowak finds vim more intuitive than emacs
23:52:21 <mauke_> palomer: how do I configure emacs to use 4-space indents for all the programming languages I use?
23:52:29 <Pete_I> mauke, it's not working :/
23:52:44 <mauke_> Pete_I: what does it do?
23:52:51 <Pete_I> nothing.
23:52:58 <johnnowak> Pete_I: control-x control-c does nothing?
23:53:07 <Pete_I> right.
23:53:09 <dfeuer> Try kill -9?
23:53:17 <johnnowak> Pete_I: Make it die!
23:53:32 <dfeuer> try c-g c-x c-c
23:53:34 <palomer> M-x indent-to <ret> 4<ret>
23:53:36 <Pete_I> hmm....how user-unfriendly
23:53:48 <palomer> oh wait, that's not it
23:53:48 <mauke_> palomer: I mean permanently
23:54:14 <palomer> ah, you can't
23:54:24 <palomer> but indentation is meaningless
23:54:30 <mauke_> oh, great
23:54:35 <palomer> a programming language may have different forms of indentation
23:54:45 <Pete_I> indentation isn't meaningless, or it wouldn't exist.
23:54:49 <palomer> for example, the haskell-mode indents differently depending on the context
23:55:02 <palomer> indentation length is meaningless
23:55:03 <palomer> sometimes
23:55:05 <mauke_> palomer: I want it to indent the way I want
23:55:22 <mauke_> (which is tabs only, displaying tabs as four spaces)
23:55:39 <palomer> but you may want to indent declaration differently than do-blocks
23:55:40 <palomer> you know?
23:55:48 <mauke_> this works fine for C, C++, Perl, PHP, Haskell
23:55:55 <mauke_> no, I don't
23:56:27 <palomer> some people do, and forcing all modes to have the same concept of indentation would be draconian
23:56:40 <dfeuer> not forcing.
23:56:46 <mauke_> allowing
23:56:46 <dfeuer> letting HUMAN force what HUMAN wantns.
23:57:08 <johnnowak> mauke_: I can tell you how to do it in vim :)
23:57:17 <palomer> anyways, I'm off to bed
23:57:19 <palomer> night wonkers
23:57:20 <mauke_> johnnowak: :set noet ts=4 sw=4
23:57:30 <johnnowak> mauke_: Er. Yes.
23:59:15 <dfeuer> ?[3,5]>>[5,6]
23:59:15 <lambdabot> Unknown command, try @list
23:59:29 <dfeuer> >[3,5]>>[5,6]
23:59:35 <dfeuer> > [3,5]>>[5,6]
23:59:37 <lambdabot> [5,6,5,6]
