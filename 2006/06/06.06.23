00:03:51 <wy> Cale:  I understand monads now. Thank you.
00:04:42 <wy> Can you give me some example of great projects using Haskell ?
00:06:19 <shapr> darcs!
00:46:47 <shapr> wy: Any particular flavor of projects?
00:48:43 <Cale> there are lots listed on the Haskell page
00:49:20 <Cale> http://www.haskell.org/haskellwiki/Libraries_and_tools
00:54:04 <xah> Hi Cale
00:54:40 <Cale> hi
00:55:11 <wy> shapr:  I'd like something like search engine or AI programs
00:55:41 <xah> hi Cale, could you lift the ban on me in #math please?
00:57:03 <Cale> sure
00:57:46 <Cale> there you go
00:58:04 <Cale> it was Chandra, he has a tendency of pointlessly banning people
00:58:54 <xah> Cale: thanks! yeah, i don't recall ever talked to him...
01:08:38 <eivuokko> Does MonadState really require the fundep it has?
01:08:48 <Cale> basically
01:08:58 <Cale> if you don't want it to be a total pain to use
01:09:01 <eivuokko> Hmmm
01:10:27 <eivuokko> Annoying - I don't see why ;)  I have to try out.  Thanks.
02:34:25 <Itkovian> do  the optimisations put in effect when running a tail-recursive function only apply when you don't drag along extra arguments that are changed in the recursion? 
02:34:43 <Itkovian> I'm still trying to understand why my parsing function causes the stack to overflow
02:36:33 <apfelmus> Itkovian: it may be that your (lazy) accumulating parameter explodes. use strictness with a `seq` or paste your code so we can check what's up
02:36:50 <Itkovian> @url paste
02:36:51 <lambdabot> http://paste.lisp.org/new/haskell
02:39:08 <lisppaste2> Itkovian pasted "tail recursion overflows the stack" at http://paste.lisp.org/display/21636
02:39:28 <Itkovian> basically it's the same as the paste I made yesterday, but cleaned up a bit
02:40:20 <Itkovian> basically, it takes a list of strings and determines which of the cases should be executed based on the first 'field' of the string
02:42:58 <Itkovian> at the end of each case, I call the same function, with the tail of the strings list and some updated arguments
02:44:16 <Stinger_> got omtimizations on?
02:46:00 <Itkovian> yeps -O2
02:46:26 <Itkovian> I think the issue lies with the fact that I'm altering the arguments passed along
02:46:49 <Itkovian> I think it keeps the previous calls alive because of that
02:46:57 <apfelmus> Itkovian: i wonder wether a heap profile helps. the first thing i would try is to make the +1 stuff strict.
02:47:30 <Itkovian> I am running a heap profilation atm
02:48:18 <Itkovian> what do you mean by +1 stuff?
02:48:54 <Stinger_> the fn parameters that are altered in each iteration, (or maybe just the simple cases of those)
02:50:10 <apfelmus> Itkovian: i mean replace pos+1 by (1+) $! pos making the addition strict
02:53:20 <Itkovian> sorry bout that
02:53:35 <Itkovian> Colloquy seems to fail regularly these days
02:53:58 <apfelmus> Itkovian: i know. it even crashes without exiting. very interesting...
03:00:11 <Itkovian> very annoying too
03:17:09 <apfelmus> Itkovian: did you get any way far with by introducing strictness?
03:18:01 <bolrod> what about rewriting from scratch?   :x
03:18:32 <Itkovian> I thik I'm getting somewhere
03:18:51 <Itkovian> I introduced seq between the updated maps and the recursive call
03:19:14 <Itkovian> bolrod: you don't seem to be in a very constructive mood, eh ;-)
03:19:38 <bolrod> hehe :)  oh man...   time flies when you have to get up in the morning
03:19:43 <bolrod> *Yawn*
03:22:38 <dcoutts> SamB, feel free to send us a patch to add a context menu to the mozembed example
03:24:16 <Itkovian> Next step would be to reduce the memory usage of this thing
03:24:54 <Itkovian> the trace is like 30MB - I refuse to believe it takes a 600MB+ heap to represent the data in Haskell
03:27:05 <Itkovian> Passed! Yeah!
03:27:07 <Itkovian> Thx!
03:29:28 <apfelmus> Itkovian: your algorithm uses the maps in a very single threaded way. i'd suggest writing a fold which uses the ST monad. in this, you plug the specific map-changing code.
03:30:32 <Itkovian> apfelmus: ok, I shall have to overcome my Monad fears then
03:30:44 <Itkovian> after lunch
03:31:07 <apfelmus> Itkovian: i don't understand your code to much, but maybe it fits into some kind of graph algorithm, so an underlying graph algorithm would be a nice abstraction to outsource in an ST monad then
03:31:59 <Itkovian> apfelmus: hmm, is it that crappy?
03:33:12 <int-e> Itkovian: hmm, you're storing 30 MB worth of text in Strings?
03:33:35 <Itkovian> int-e: nope, they should become Integers
03:34:28 <int-e> ok, because that would be crazy (and could well account for 600 MB of heap being used)
04:03:27 <int-e> Itkovian: hmm, that means you should be careful to actually force those lookups.
04:03:31 <vincenz> Hi
04:04:14 <Itkovian> careful, as in do, or as in don't?
04:04:19 <int-e> Itkovian: (but I guess that's what you've been doing all along)
04:04:26 <int-e> as in do.
04:04:48 <int-e> a thunk that holds on to a string to be looked up when needed will kill memory usage in your case I think.
04:06:20 <Itkovian> ok, so how do I force the conversion to an Integer at read time?
04:07:00 <norpan> today is party day
04:07:01 <dcoutts_> > (read "4" :: Integer )
04:07:03 <lambdabot>  4
04:07:42 <Itkovian> dcoutts_: but does it force this immediately? or at usage time?
04:07:59 <Itkovian> norpan: ah! got any interesting events to share?
04:08:04 <dcoutts_> nothing is evaluated unless it is demanded
04:08:04 <norpan> not yet
04:08:31 <int-e> > let x = read "4" in x `seq` something that is forced and uses x
04:08:32 <lambdabot>  Not in scope: `uses'
04:08:43 <int-e> lambdabot: sorry ;)
04:09:37 <norpan> midsummer's eve
04:15:42 <vincenz> Cale: ping
04:15:48 <vincenz> SamB: ping
04:16:02 <vincenz> Excedrin: idem
04:16:15 <vincenz> I sent the idea that we discussed last night to haskell-cafe regardng scoped data-declarations
04:19:24 <Itkovian> dcoutts_: true, but then the String would be kept around, no?
04:19:46 <dcoutts_> Itkovian, there's no such thing as immediate, there is only when it is demanded
04:19:47 <Lemmih> Korollary: You rang?
04:20:34 <dcoutts_> Itkovian, you can use seq to demand the result earlier
04:21:52 <Itkovian> dcoutts: i suppose (+0) $! (read x :: Integer) would do the trick, no?
04:22:34 <Igloo> Itkovian: That's no better than (read x :: Integer)
04:22:42 <dcoutts_> Itkovian, that will demand it at the same time as you demand that overall value
04:22:45 <dcoutts_> ie it does nothing
04:23:08 <norpan> remeber that the x string will not be created until you demand the value either
04:23:23 <Itkovian> dcoutts: I fail to see how to use `seq` if not in a let x = (read y :: Integer) in x `seq` f z y x
04:23:27 <norpan> so there is no large string just lying around
04:23:30 <dcoutts_> norpan, well it depends on where you get x from
04:23:48 <dcoutts_> Itkovian, yep, that'll do
04:23:58 <Itkovian> norpan: it comes from a [String] which comes from lines applied to a readFile thingie
04:24:12 <Itkovian> dcoutts_: kinda dirties the code, no?
04:24:25 <dcoutts_> Itkovian, of course if f is strict in its 3rd arg then you don't need to write that
04:24:39 <norpan> of course lazy IO can be trouble
04:24:55 <dcoutts_> or you can say: f z y $! (read y :: Integer)
04:25:01 <norpan> esp if you use getContents or similar
04:25:37 <Itkovian> dcoutts_: but not if it's f z x y ... I think
04:25:49 <Itkovian> (the moment I start babbling too much, tell me)
04:26:10 <JKnecht> talk to the <
04:26:24 <JKnecht> > even
04:26:24 <lambdabot>  Add a type signature
04:26:59 <dcoutts_> Itkovian, if f is strict in that arg then it's ok to just say f z (read y :: Integer) y
04:27:42 <dcoutts_> Itkovian, and even if it's not, I don't see that it'd cause any space issue, the string probably will not be forced 'til you read anyway
04:27:49 <Itkovian> f is e.g. Data.Map.insert, x is the key
04:27:59 <dcoutts_> which is strict
04:28:31 <dcoutts_> so just write it in the natural & obvious way and it'll be fine
04:28:50 <int-e> dcoutts: are you sure? the string is forced by words earlier, I'd think
04:29:14 <int-e> dcoutts: (in the code that Itkovian pasted)
04:29:14 <dcoutts_> int-e, but the read is going to be forced by Data.Map.insert
04:29:31 <int-e> dcoutts: ah. that's true
04:29:59 <Itkovian> all comments on how to improve my code are welcome :-)
04:32:50 <vincenz> I remember reading something about STG somewhere in the haskell communit
04:32:52 <vincenz> anyone remember the link
04:33:53 <dcoutts_> vincenz, the Spinless Tagless G-machine is the abstract machine/evaluation model that GHC uses
04:33:58 <vincenz> no
04:34:01 <vincenz> not that
04:34:04 <vincenz> it was thread-related
04:34:32 <vincenz> but maybe I'm wrong
04:34:44 <dcoutts_> try looking in spj's papers
04:34:49 <vincenz> something a la petri-nets
04:34:55 <dcoutts_> no idea about that
04:34:55 <vincenz> some tool or some paper on this graph representation of threads
04:45:49 <jewel> is haskell nearing its twentieth birthday?
04:52:44 <roconnor> happy birthday haskell
05:11:19 <Saulzar> Would I be mistaken in thinking STM would be quite bad for sharing a large block of memory?
05:17:09 <shapr> Saulzar: Try it?
05:19:15 <Saulzar> Well, from what I can see there'd be no way to write to such a block using STM - it would have to be in terms of TVars
05:20:54 <audreyt> and what's wrong with TVar (Map Key (TVar a))
05:20:55 <audreyt> ?
05:20:59 <Saulzar> I'm talking say, 128Mb block lookup table. The standard way to store search history for a chess program is via a massive hashtable
05:21:41 <audreyt> and also if it's readonly sharing
05:21:47 <audreyt> then you just use normal Reader
05:21:57 <audreyt> or its equivalent, implicit params
05:21:58 <Saulzar> Yes, read only would work fine
05:22:17 <audreyt> they just set up a ReaderT STM
05:22:21 <audreyt> s/they/then/
05:22:44 <audreyt> or implicit params if you must
05:22:52 <audreyt> or lift that table into a toplevel function
05:22:53 <Saulzar> But writing is required, I think it would have to be done the standard way with locks. Not sure if there's another data structure which is feasable
05:23:16 <audreyt> well, if you _know_ your data flow, then use a HashTable
05:23:19 <audreyt> plus unsafeIOtoSTM
05:23:25 <audreyt> can get what you want
05:23:35 <audreyt> just need to guarantee the rollbacks only happen at readonly regions
05:23:58 <Saulzar> Hmm. How can one tell where the rollbacks can occur?
05:24:06 <audreyt> anywhere inside "atomically"
05:24:15 <audreyt> so basically the unsafeIOtoSTM inside there can only read and never write
05:24:34 <audreyt> the writer itself must not retry
05:24:51 <Saulzar> Right, I see
05:27:37 <shapr> Life is too short to NOT spend it thinking about the kinds of things that motivate me to sit in front of a computer!
05:32:40 <Azmo> If I do "tryJust dynExceptions (return exp)" where exp is some expression that may throw dynamic exceptions, then the result becomes a 'Right', and then when I work with the result, the exception occures.. :/. How do I force the correct result?, i.e getting a 'Left', when an exception really is thrown.
05:36:00 <Saulzar> Azmo, You might want to force evaluation, eg. maybe "evaluate exp" instead of "return exp"
05:36:55 <Azmo> Tried that, didn't work.
05:37:58 <dcoutts_> Azmo, the exception will not be thrown unless it's value is demanded
05:38:27 <dcoutts_> so if you've got a lazy structure with values that may throw exceptions then you'd need to force them
05:38:36 <dcoutts_> usually by forcing the whole structure
05:39:35 <dcoutts_> ideally you could make it such that just evaluating exp would trigger any of the exceptions
05:39:54 <dcoutts_> then evaluate would work
05:40:11 <dcoutts_> evaluate exp >> return exp
05:40:52 <dcoutts_> but if forcing exp to head normal form doesn't force the exceptions then you'll have to do one of two things:
05:41:17 <dcoutts_> force all/enough of exp to get the exceptions
05:42:01 <dcoutts_> change exp so that forcing exp forces the excpetions to be thrown, by adding strictness in the places where you throw exceptions
05:42:39 <Azmo> hm... complicated :/
05:42:55 <dcoutts_> eg this will not force the exceptions: let x = if blah then throw ... else 3 in Just x
05:43:16 <dcoutts_> evaluating that to head normal form doesn't force the exception
05:43:31 <vincenz> re
05:43:32 <dcoutts_> since the head normal form is Just (...)
05:43:50 <dcoutts_> Azmo, but if I rewrote it: let x = if blah then throw ... else 3 in Just $! x
05:44:24 <dcoutts_> then now forcing that expression forces x which forces the conditional and we'll get the exception
05:44:39 <Azmo> I see.
05:45:29 <dcoutts_> Azmo, you could paste your example code and we could see if we could do something similar
05:45:31 <dcoutts_> @paste
05:45:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
05:45:43 <vincenz> @where paste
05:45:44 <lambdabot> http://paste.lisp.org/new/haskell
05:45:56 <dcoutts_> vincenz, someone should fix @paste
05:46:19 <Azmo> hm...  i am writing a disassembler, so the code is unfortunately quite big.
05:47:57 <dcoutts_> Azmo, sometimes a better way to do exceptions is to use Maybe, Either or some other error monad
05:49:14 <shapr> Azmo: http://www.scannedinavian.com/~shae/uncc--1.0--patch-4.tar.gz
05:49:27 <Azmo> hm... right, but i thought the exceptions would work better, since i would have have to "re-throw" the failures.
05:51:45 <shapr> Azmo: Have you already seen uncc?
05:52:10 <dcoutts_> Azmo, using an error monad does the "re-throw" for you
05:53:49 <shapr> psykotic: Did you come up with anything more about the until function?
05:53:53 <Azmo> nope, have not seen uncc, but just took a quick look at the code and.. it only handles ELF?. mine is only for win32PE :]
05:54:19 <shapr> Still, it might be interesting to see how uncc works.
05:55:36 <Azmo> yes, indeed. thanks.
05:55:45 <shapr> @seen musasabi
05:55:45 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. I don't know when musasabi last spoke.
06:08:26 <vincenz> dcoutts: I agree
06:08:42 <vincenz> Anyone know how to turn off all the join/leave messages for GAIM?
06:09:41 <neologism>  /ignore JOINS LEAVES
06:09:42 <neologism> ?
06:09:53 <vincenz> No such command
06:10:05 <Dino_> He's asking about Gaim, GUI IM client.
06:10:23 <Dino_> I don't see messages which probably means in the distant past I knew how to shut that off.
06:10:24 <neologism> maybe GUI programs dont ahve such advanced features :)
06:10:31 <vincenz> :/
06:10:33 <Dino_> I have not forgotten whatever it was and am looking in the Prefs dialog no.
06:10:38 <Dino_> s/not/now/
06:10:47 <Dino_> Also, need more coffee.
06:11:24 <vincenz> Yeah I need GAIM to bypass our http-proxy
06:11:52 <Dino_> Ah, you're using it for this. I never used it for IRC yet.
06:14:08 <vincenz> irssi, even if you set http_proxy, won't bypass proxy
06:14:22 <Dino_> So what happens? You have a window that's basically this channel? And then other windows are popping up?
06:14:26 <vincenz> possibly I could hack this a bit to send the right request, ut haven't figured that out yet
06:14:32 <vincenz> Dino_: yeah but tabbed
06:14:54 <Dino_> In Prefs, Buddy List, there's a Raise window on events that I have unchecked.
06:14:55 <vincenz> it's just annoying: no nickname highlighting, big fonts, few lines, lots of sporadic crap like joins/leaves
06:15:04 <Dino_> vincenz: Can you ssh out of there?
06:15:11 <vincenz> Dino_: yeah, just don't have a box
06:15:17 <vincenz> I'm moving, so my box at home is off
06:15:24 <Dino_> What I do when on the job is ssh to home or somewhere I have a shell account, and IRC from there.
06:15:29 <Dino_> ah, nevermind
06:16:14 <Dino_> You're not particularly thrilled to use Gaim for this, it's just a necessity at the moment.
06:17:06 <vincenz> yep
06:18:46 <Dino_> There's also another "Raise IM window on events" in the Conversations branch of the Prefs.
06:18:54 <Dino_> (mine also turned off there)
06:19:05 <vincenz> yeah, it's just removing the "xxx entered the room" "xxx has left the room"
06:19:11 <vincenz> cause I get few lines in my window
06:19:13 <Dino_> ok
06:19:19 <vincenz> can't find the option, however
06:19:29 <vincenz> Dino_: sei italiano?
06:19:58 <Dino_> vincenz: No, not me, grew up in the US. :)
06:20:12 <MarcWeber> What's wrong here?     <chmod perm="755" file="${eclipse.eclim_plugin_dir}/org.eclim_${eclim.version}/bin/eclim"/>
06:20:15 <MarcWeber>     <chmod perm="755" file="${eclipse.eclim_plugin_dir}/org.eclim_${eclim.version}/bin/eclimd"/>
06:20:21 <MarcWeber> Oh wrong clipboard..
06:20:28 <MarcWeber> http://www.rafb.net/paste/results/SNqcxH91.html
06:20:59 <MarcWeber> data HQTokenParser = GenParser HQToken () HQTokenParserResult
06:21:12 <MarcWeber> Couldn't match `HQTokenParser' against `GenParser tok st a'
06:22:33 <MarcWeber> Why can't it match () against st?
06:23:07 <xerox> Isn't GenParser defined elsewhere?
06:23:21 <SamB> MarcWeber: maybe you want to say "type" instead of "data"
06:23:51 <SamB> or maybe you want to put the stuff after the = in parens and add a new data constructor
06:27:01 <vincenz> SamB: I posted it
06:27:31 <MarcWeber> SamB: You're right.
06:31:10 * SamB doesn't understand vincenz's claim
06:32:34 <MarcWeber> xerox: It is in parsec...Prim
06:33:11 <vincenz> samb: our discussion yesternight?
06:33:27 <SamB> oh, right
06:33:59 * SamB thought vincenz was claiming to have posted MarcWeber's code for a bit there ;-)
06:36:47 --- mode: ChanServ set +o vincenz
06:37:01 <vincenz> @version
06:37:01 <lambdabot> lambdabot 4p7, GHC 6.5 (OpenBSD i386 )
06:37:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:37:13 <vincenz> dcoutts: let me push a patch to fiix @paste
06:38:47 <vincenz> @list-modules
06:38:48 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
06:38:48 <lambdabot> topic type unlambda url version vixen where
06:39:31 <vincenz> @where paste
06:39:32 <lambdabot> http://paste.lisp.org/new/haskell
06:40:39 <SamB> ouch -- gmane web interface down
06:42:07 <vincenz> anyone know dons' email?
06:42:15 <xerox> ?google dons 
06:42:25 <vincenz> @google dons
06:42:25 <lambdabot> http://www.wimbledon-fc.premiumtv.co.uk/
06:42:26 <lambdabot> Title: "Milton Keynes Dons | Home"
06:42:27 <lambdabot> http://www.wimbledon-fc.premiumtv.co.uk/
06:42:27 <lambdabot> Title: "Milton Keynes Dons | Home"
06:42:31 <xerox> ?google dons haskell
06:42:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
06:42:33 <lambdabot> Title: "hs-pluginsDynamically Loaded Haskell Modules"
06:42:38 <xerox> `Contact' page.
06:43:49 <vincenz> fixed
06:43:52 <vincenz> thx
06:52:42 <mahogny> ghc, command for getting the commandline arguments?
06:53:07 <mauke> @index getArgs
06:53:07 <lambdabot> System.Environment
06:53:16 <mahogny> ah. thanks
06:54:11 <mauke> I've just solved http://www.spoj.pl/problems/FOOL/ in haskell. I am happy.
06:55:06 <kzm_> Anybody use GHC on Solaris?
06:56:22 <vincenz> mauke: feel like sharing?
06:56:36 <mauke> .oO( structural sharing? )
06:57:16 <vincenz> mauke: code-sharing
06:57:28 <vincenz> and thought balloons are mine!
06:57:38 <lisppaste2> mauke pasted "FOOL" at http://paste.lisp.org/display/21640
06:58:13 <vincenz> mauke; yick
06:58:18 <vincenz> mauke: did you use an existing algo?
06:58:58 <mauke> yeah, more or less
07:00:26 <xerox> Isn't it silly to say that curly brackets can be used as chars of the set names?
07:01:05 <mauke> that's what makes it interesting
07:01:24 <int-e> so ... {,,,} is a set?
07:01:30 <xerox> Interesting you say (-:
07:01:30 <vincenz> int-e: no
07:01:38 <vincenz> int-e: it's not a set, it's an element cause its not a valid set
07:01:39 <int-e> vincenz: it adheres to the grammar
07:01:51 <vincenz> int-e: no it doesn't, can't have no-char elements
07:01:58 <vincenz> int-e: look at the last example on that webpage
07:02:05 <bolrod> {,,,}  is a set..
07:02:07 <int-e> vincenz: that's different
07:02:11 <bolrod> it's the set of two times ","  ?
07:02:18 <vincenz> oh
07:02:19 <vincenz> mhm
07:02:22 * vincenz shuts up
07:02:23 <vincenz> but then
07:02:27 <vincenz> {,,} is a set too!
07:02:30 <vincenz> of ",,"
07:02:36 <bolrod> erh...   
07:02:38 <mahogny> reminds me of how algol could use reserved keywords for variable names. this is similar :)
07:02:42 <vincenz> that page is flawed
07:02:46 <bolrod> I don't think so :P
07:02:49 <int-e> (I was after duplicate members, but the specification doesn't mention that anywhere)
07:02:53 <vincenz> oh wait
07:02:53 <vincenz> I misread
07:02:56 <vincenz> single-character elements
07:03:06 <vincenz> mauke: how do you do {} matching?
07:03:08 <bolrod> it's an  Atom  ,  lits
07:03:10 <vincenz> mauke: innermost or outermost?
07:03:28 <xerox> parse = between '{' '}' maukeTrickyParser
07:03:50 <mauke> outermost, see lines 17 and 32
07:04:32 <vincenz> mauke: erm, you don't recurse
07:04:42 <vincenz> so it's not really outermost, cause it's not iteratively inwards
07:05:17 <vincenz> this algo reeks of recursion tho
07:05:25 <mauke> d is a recursive array
07:05:41 <vincenz> recursive array?
07:05:43 <vincenz> o.O
07:05:52 <vincenz> btw, what possessed you to write this starting with an aray?
07:06:00 <mauke> d and f recurse through each other, building a cached data structure
07:06:02 <vincenz> you have a tweaked mind!
07:06:04 <xerox> The word `efficient'.
07:06:17 <vincenz> xerox: yeah ok but starting fresh, it's easier to first do it with lists
07:06:25 <vincenz> unless this is already an optimized versio
07:06:32 <vincenz> in which case I wouldn't mind seeing the original spike-solution
07:06:40 <mauke> my first approach used a non-deterministic parser
07:06:48 <mauke> it was very general and very slow
07:08:16 <vincenz> ah I see
07:08:30 * vincenz typically moves to maps iso lists when optimizing
07:08:35 <vincenz> not yet too familiar with using arrays in haskel
07:08:38 <vincenz> +l
07:11:56 <vincenz> mauke: mind explaining the algo
07:11:56 <vincenz> ?
07:12:31 <shapr> Right, I'll be back online... well, sometime in the next ten days.
07:12:32 <int-e> mauke: hmm. do you get better than O(n^2) complexity?
07:12:34 <vincenz> what does "f" determine
07:12:46 <mauke> ok, x is our "global" input string
07:13:00 <mauke> [a, b) is the current subrange
07:13:04 <vincenz> yep
07:13:12 <int-e> mauke: (I've not looked at the code)
07:13:18 <mauke> int-e: no idea
07:13:37 <vincenz> mauke: d is a mapping of f for all possible [a,b) subranges, lazily
07:13:49 <mauke> f checks whether [a,b) is an elementlist
07:13:57 <vincenz> ah
07:14:02 <mauke> the results are cached in d
07:14:09 <vincenz> that already gives me some more knowledge
07:14:15 * vincenz smacks mauke for not using meaningful names
07:14:52 <vincenz> mauke: out of curiousity, you use d laziliy initialized with f, and f uses d
07:14:58 <SamB_XP_> packrat can get you O(n), I think. but it is also O(m) in the number of productions, and you'd need some kind of a parser-generator too...
07:14:59 <vincenz> mauke: how do you ensure you don't get run-away recurson
07:15:17 <SamB_XP_> well, O(n) worst case anyway
07:15:53 <vincenz> mauke: btw, interesting idiom regarding using the array
07:15:59 <vincenz> mauke: it's quite easy to use in existing code
07:16:07 <vincenz> mauke: instead of f x y z, d !(x,y,z)
07:16:13 <vincenz> :)
07:16:37 <vincenz> mauke: one small point
07:16:49 <vincenz> mauke: I doubt that using the list-array gets you anything, you never repeat some computation
07:17:01 <vincenz> mauke: you always check smaller ranges, never the same one
07:17:44 <mauke> vincenz: doesn't [d ! (a, i) && d ! (succ i, b) | i <- [succ a .. pred b - 1], x ! i == ',']
07:17:56 <mauke> repeat stuff?
07:18:05 <vincenz> I'm not certain tbh
07:18:34 <vincenz> worth checking :)
07:18:44 <vincenz> mauke: but, very interesting idiom :) and quite easy to apply to existing code
07:18:45 <mauke> SamB_XP_: I don't know how to adapt packrat to ambiguous grammars
07:18:55 <vincenz> mauke: thanks for giving me a new tool
07:19:02 <SamB_XP_> mauke: very strange parser you have there
07:19:31 <yain> hi.
07:20:06 <SamB> mauke: how do you usually do ambiguous grammars?
07:20:48 <mauke> hmm, "usually" ...
07:21:02 <yain> I don't understand something. suppose I have something like: 'data Foo = FooFoo Bar Baz'. then I can write: 'getBaz (Foo _ baz) = baz' to get baz from Foo.
07:21:10 <yain> is there any other way of doing it?
07:21:11 * vincenz wonders if he's on everyone's ignore list on haskell-cafe, I never get any answers 
07:21:13 <SamB> hmm.
07:21:22 <vincenz> yain: no
07:21:23 <bolrod> true
07:21:26 <mauke> the first thing I'd try is a non-deterministic parser
07:21:30 <vincenz> yain: getBaz (FooFoo _ baz) = baz'
07:21:43 <vincenz> yain: have to use the data-constructor, not type-construtor
07:21:45 <bolrod> vincenz: which e-mail did you send?
07:21:48 <SamB> well, searching for packrat and ambiguous tells me that packrat is not good for ambiguous grammars...
07:22:00 <vincenz> bolrod: the one regarding scoped data decls
07:22:04 * SamB doesn't think mauke'
07:22:16 <SamB> s approach does better than O(n^2)
07:22:29 <yain> vincenz: ah, ok. but this is the right way of accomplishing such task?
07:22:35 <mauke> yeah, I actually wrote a packrat parser, replaced its internals with lists, and it was too slow
07:22:46 <mauke> lack of sharing between the "futures", I think
07:22:57 <vincenz> yain: yes
07:23:01 <vincenz> yain: there is a second option
07:23:04 <vincenz> yain: using record syntax
07:23:24 <vincenz> yain: data Foo = FooFoo { getBar :: Bar, getBaz :: Baz} 
07:23:31 <vincenz> yain: ths automatically defines the functions 
07:23:38 <vincenz> yain: plus allows you to do stuff like
07:23:52 <vincenz> let x = FooFoo {getBar = a, getBaz = b} in x{getBar=c}
07:24:26 <yain> vincenz: can I do this if Foo is already defined in module that I'm importing?
07:24:35 <SamB> hmm.
07:24:58 <SamB> yain: no, not really
07:24:58 <vincenz> yain: no
07:25:10 <yain> okay, thanks.
07:25:13 <SamB> what is Foo?
07:25:25 <yain> Foo is Document in HaXml.
07:25:44 <SamB> doesn't that already have accessors?
07:25:58 <yain> I don't see any. perhaps looking at wrong place.
07:26:30 * SamB isn't sure
07:28:49 <yain> I think it doesn't because some of it's code uses _ pattern and not anything else.
07:29:47 <SamB> anyway, you were doing fine ;-)
07:37:59 <vincenz> *mutters
07:46:56 <florenz> hi
07:47:29 <florenz> does somebody know if ghc-6.4.1 has to be compiled specially on solaris 10 sparc to support threads?
07:47:58 <florenz> if i compile with -threaded the linker cannot resolve sched_yield()
07:48:39 <SamB> probably the threaded RTS is messed up on that platform
07:49:33 <florenz> SamB, do you know if I have to enable thread support before compiling ghc or is it enabled by default?
07:50:09 <SamB> actually, sched_yield is apparantly supposed to be a syscall
07:51:16 <neologism> yes
07:51:22 <neologism> defined by posix
07:51:47 <florenz> is it possible that the compiler cannot find the apprpriate header file?
07:51:55 <florenz> sometimes header files are somewhere else on solaris?
07:53:26 <SamB> it isn't headers, though -- the linker is not what complains about headers
07:54:10 <SamB> hmm:
07:54:23 <SamB>        POSIX  systems  on  which sched_yield is available define _POSIX_PRIOR‐
07:54:23 <SamB>        ITY_SCHEDULING in <unistd.h>.
07:55:49 <florenz> well, that file is in /usr/include, pretty usual location.
07:56:19 <florenz> is it possible that i have to pass some other library to the linker which has sched_yield?
07:56:31 <SamB> possible!
07:56:43 <SamB> grep through /usr/lib or wherever
08:01:43 <vincenz> printing under linux sucks
08:03:17 <BCoppens> it sure does :(
08:03:50 <BCoppens> I never get the margins right when I print from konqueror :/
08:05:56 <florenz> ok, i have to add -lrt to the linker and then it compiles
08:06:35 <mux> typical solaris annoyance
08:06:43 <florenz> but not the waitForProcess command produces: waitForProcess: interrupted (Interrupted system call)
08:06:57 <florenz> under linux it is working. someone an idea?
08:07:23 <mux> read all the manpages carefully, you sometimes have to explicitely define some macros to get "standard" behaviour
08:07:31 <mux> such as for sigwait()
08:08:02 <mux> -D_REALLY_MAKES_THIS_FUNCTION_WORK_I_MEAN_IT
08:17:54 <dcoutts_> dons, ping
08:18:15 <dcoutts_> dons, I've got a Data.ByteString.Fusion impl using the streams framework
08:18:21 <dcoutts_> now testing
08:18:53 <dcoutts_> and extending it to fuse array transformers like map & filter that can fuse with up or down loops
08:19:11 <dcoutts_> oh and the lazy chunked representation
08:19:31 <florenz> mux, thanks. i haven't found the solution but i think i'll dig into this when i have more time.
08:20:08 <dcoutts_> dons, interestingly, the scans that have output 1 longer than input work ok in the streams framework
08:20:18 <dcoutts_> I expect we'll be able to do concatMap too
08:21:05 <dcoutts_> the write array should probably do reallocation if the stream overflows its stated length
08:21:45 <dcoutts_> so we can do fuse with lists more easily and things like concatMap or utf8 map where predicting the final length is hard 
08:22:16 <dcoutts_> so the length would not be the upper limit but just a best-guess for best average performance
08:29:08 <MarcWeber> How can I put do {a <- return 'a'; b<- return 'b'; ..;  return a:b:...:[]} into a list ?  I want  let abc...= map return "abc..." and then get the same result with using something like foldr?
08:29:40 <defcon8> afternoon
08:29:46 <RyanT5000> "abc" is a list of characters
08:30:04 <defcon8> > "a" : "n"
08:30:05 <lambdabot>  Couldn't match `[Char]' against `Char'
08:30:16 <defcon8> > "a" : ["n"]
08:30:17 <RyanT5000> > 'a' : "n"
08:30:17 <lambdabot>  ["a","n"]
08:30:19 <lambdabot>  "an"
08:30:23 <MarcWeber> > 'a':'b':[]
08:30:24 <lambdabot>  "ab"
08:30:57 <RyanT5000> MarcWeber, what are you trying to *accomplish*, in english
08:31:10 <RyanT5000> i can kind of tell what your code is doing, but if you just explain it that might be easier
08:32:53 <SamB> MarcWeber: try: return "abc..."
08:33:17 * SamB tries to coex MarcWeber to reveal his actual problem
08:33:23 <SamB> er, coax...
08:33:30 <RyanT5000> what monad are you working in? the list monad?
08:33:39 <SamB> GenParser?
08:33:39 <RyanT5000> in which case you just need "abc", rather than returning something
08:40:46 <MarcWeber> Here is an example what I've tried: http://www.rafb.net/paste/results/O5V5Vb15.html
08:40:59 <audreyt> interesting tidbit
08:41:00 <MarcWeber> And this is my project where I want to use it ;) line 46 http://www.rafb.net/paste/results/oTqrTa20.html
08:41:05 <audreyt> I was hacking with Danny most of yesterday
08:41:20 <MarcWeber> Now what I really want to do: Write a program which uses some kind of human readable hash code to find files.. The help is almost finished so I'll paste it, too: http://www.rafb.net/paste/results/U35kXn20.html (line 124 print_help)
08:41:26 <audreyt> and I said "so you are the co-author of first-generation HSP"
08:41:31 <MarcWeber> In short : just do cd /vtl to goto /var/tmp/local and let the program find the matching files. If there is also /variable/the/lol then print a list to choose from
08:41:44 <audreyt> and he's like "first-generation, you mean people actually use that thing now?" :-)
08:42:30 * SamB wonders why pure is in the Arrow class
08:42:49 <MarcWeber> Any comments, questions?
08:46:50 <petekaz> I just started learning about monad transformers from YAHT, and the first example they use is the State monad which wraps the IO monad.  Independently, I'm also reading 'The Awkward Squad' and just learned about IORefs in the IO monad.  If IORefs are available, why would anyone want to use StateT?
08:48:53 <xerox> For example for doing input/output (like printing) in a State conputation.
08:49:56 <SamB> petekaz: because with StateT, you wouldn't need to be on top of IO?
08:49:59 <SamB> I hope?
08:51:10 <MarcWeber> RyanT5000: In the parser monad from parsec
08:52:09 <SamB> MarcWeber: what are you trying to do in this particular part of your code?
08:54:15 <petekaz> SamB: But if I am using StateT with IO already, wouldn't an IORef in the IO monad just be easier?  You only have to deal with one?  I suspect that my understanding is a bit limited, I'll keep reading.  This stuff is complicated.
08:54:23 <MarcWeber> AI want to parse abc to return a parser which parses three 
08:54:58 <MarcWeber> tokens whose names must start with 'a', 'b'and 'c' to succeed
08:55:50 <MarcWeber> SamB: Then I want to scan the filesystem (every folder/ file will be a token) to feed this parser and only follow those subdirs on which the generated parser doesn't fail.
08:55:52 <SamB> petekaz: compositon!
08:55:56 <SamB> petekaz: libraries!
08:56:40 <SamB> MarcWeber: urgh, you sound to complicated for me
08:56:53 <SamB> I think you should play around with normal parsers first
08:57:04 <MarcWeber> SamB: Did you understand my goal?
08:57:20 <SamB> sort of
08:57:36 <MarcWeber> SamB: A normal parser is fead with one input file.
08:57:58 <MarcWeber> I have to feed the parser with a folder, then split to feed it with the one subdir and the next subdirectory..
08:58:39 <SamB> but two layers of parsers makes your questions more difficult to interpret
08:59:05 <MarcWeber> ;) That's why I'm asking
09:00:12 <MarcWeber> Now if I have the argumetn abc I want to get a parser which succeeds on the folders (=parserinput) [foldertoken a*, foldertoken b*, foldertoken c*] where * can be arbitrat
09:00:18 <MarcWeber> arbitrary characters
09:22:31 <MarcWeber> SamB, petekaz, xerox  RyanT5000 Thanks for listening.. I've found my problem.. ( I 've forgotten a return)
09:39:51 <vincenz> :(
09:42:51 <xerox> (lightstep 'lightstep) ==> #t
09:43:24 <lightstep> Eval $ lightstep `App` Lightstep ==> True
09:43:49 <xerox> I am not sure we are thinking of the same thing.
09:44:02 <lightstep> yeah, i guess so
09:45:43 <lightstep> i can't parse it as a verb
09:45:57 <lightstep> or as a predicate
09:46:03 <xerox> Dang!
09:46:27 <xerox> lightste`p'redicate.
09:46:42 <lightstep> oh
09:47:13 <lightstep> i'm so slow
09:50:41 <dmhouse> Game theory question of the day:
09:51:12 * xerox takes bets
09:51:30 <dmhouse> Mr Black, Mr Grey and Mr White decide to settle their differences by pistols at dawn. They have different levels of skill: Black only hits his target 1 out of 3 times, Grey 2 out 3. White is a perfect marksman.
09:51:50 <dmhouse> To account for this, they allow Black to go first, then Grey, then White, then repeating until only one remains.
09:52:01 <dmhouse> You are Black. At whom do you aim?
09:52:13 <xerox> Both!
09:52:17 <lightstep> none
09:52:19 * int-e wants an original problem.
09:52:20 <xerox> Mu?
09:52:32 <lightstep> we can overcome our differences
09:52:34 <int-e> 'Where do you aim' is better.
09:52:36 * xerox wants food.
09:52:36 <dfeuer> Why such odd answers, eh?
09:52:56 <dmhouse> xerox, this is from the FLT book you linked to the other day (which I'm reading).
09:53:19 <dfeuer> FLT?
09:53:27 <xerox> Let's not spoinl then fun then! (: Thank you for reminding me of it.
09:53:31 <fanopnaic> I'd aim at White. So what's the best solution?
09:53:31 <xerox> *spoil
09:53:46 <int-e> fanopnaic: let's say that's not it
09:53:55 <dmhouse> fanopnaic: That's kind of it.
09:54:10 <int-e> that's the in-box solution.
09:54:58 <dfeuer> The out of box solution is obviously not to show up, or not to follow the rules.
09:55:03 <dfeuer> But that's stupid.
09:55:20 <dmhouse> There's another out-of-box solution, which is not quite so out of box.
09:55:23 <fanopnaic> what is this FLT book?
09:55:31 <fanopnaic> shooting yourself? :)
09:55:47 <dmhouse> @google "Fermat's Last Therorem" "Simon Singh" site:amazon.com
09:55:49 <lambdabot> No Result Found.
09:55:52 <fanopnaic> ah
09:55:54 <dmhouse> @google "Fermat's Last Theorem" "Simon Singh" site:amazon.com
09:56:03 <lambdabot> http://www.amazon.com/exec/obidos/tg/detail/-/0385493622?v=glance
09:56:03 <lambdabot> Title: "Amazon.com: Fermat's Enigma : The Epic Quest to Solve the World's Greatest Mathe ..."
09:56:27 <dmhouse> Hrm, that's not the one.
09:57:02 <dmhouse> http://www.simonsingh.net/Fermat_Corner.html will do.
09:57:28 <dfeuer> http://idrewthis.org/2005/supportourtroops.html
09:58:13 <dmhouse> :)
09:58:56 <dfeuer> D.C. Simpson is amazing.
09:59:40 <dmhouse> Does John Meacham IRC?
09:59:46 <vincenz> dmhouse: from time to time
09:59:54 <dmhouse> vincenz: What's his nick?
09:59:58 <vincenz> dmhouse: can't remember :/
10:00:32 <lightstep> @seen JohnMeacham
10:00:32 <lambdabot> I saw JohnMeacham leaving #haskell-blah and #haskell 7 days, 23 hours, 15 minutes and 25 seconds ago, and .
10:00:55 <vincenz> lambdabot: prove it
10:00:56 <lightstep> i think that was him
10:01:03 <vincenz> lightstep: or an impersonator
10:01:15 <dmhouse> Could be. He needs to respond to my JRegex email! :(
10:01:29 <RyanT5000> are you allowed to not shoot at anyone?
10:01:33 * vincenz feels like he's on the ignore list of everyone in haskell-cafe
10:01:37 <dcoutts_> @seen JohnMeacham
10:01:37 <lambdabot> I saw JohnMeacham leaving #haskell-blah and #haskell 7 days, 23 hours, 16 minutes and 31 seconds ago, and .
10:01:42 <vincenz> I've posted like 5 messages, and each one was always ignored :(((
10:02:04 <dcoutts_> dmhouse, does that answer your question? :-)
10:02:13 <dcoutts_> doh
10:02:17 <dmhouse> dcoutts_: Yeah :)
10:02:19 <vincenz> dcoutts: lightstep just did that :P
10:02:23 * dcoutts_ sees lightstep did that already
10:02:43 <vincenz> lazy evaluation leads to recomputation
10:02:47 * dcoutts_ goes back to sit in his corner
10:03:24 * vincenz points out that this is a round room
10:03:37 <vincenz> dcoutts: what did you think of the idea?
10:03:44 <vincenz> dcoutts: that I posted on haskell-cafe
10:03:49 <dcoutts_> vincenz, not read it :-)
10:03:55 * dcoutts_ is fusing array computations
10:03:56 <vincenz> see, I really am on the ignore list :(
10:04:05 <dcoutts_> poor vincenz ;-)
10:04:10 <vincenz> my last posts concerning dynamic monad stacking were never answered either
10:04:15 <vincenz> nor the one regarding existentials
10:04:22 <dcoutts_> vincenz, that's because no-one understod :-)
10:04:33 <vincenz> hmm
10:04:36 <vincenz> it wasn't that difficult
10:04:42 <dcoutts_> dynamic monad stacking !?!
10:04:42 * vincenz must have poorcommunication skills
10:04:50 <vincenz> dcoutts_: yeah
10:04:55 <vincenz> assume a monad transformer t
10:05:09 <vincenz> enable the dynamic stacking of a runtime decided number of t's on top of eac other
10:05:09 <dcoutts_> I think people have a hard time comprehending that or when it'd be useful
10:05:11 <vincenz> on top of an m
10:05:19 <vincenz> t (t (t (t (t m))))
10:05:27 <vincenz> I think it should be feasible with some typeclass hacker
10:05:30 <dcoutts_> your monad transformer had better not change the type
10:05:43 <dcoutts_> or you can't stack dynamically
10:05:57 <dfeuer> Shouldn't be hard at all, I don't think.
10:05:59 <vincenz> dcoutts: not really, just take an existential-approach
10:06:03 <vincenz> dfeuer: Hh
10:06:07 <vincenz> dfeuer: Hah een
10:06:12 <vincenz> grr...crappy keyboard
10:06:12 <dcoutts_> vincenz, do you have an actual use case?
10:06:19 <vincenz> dcoutts_: yeah the one in tha tpost
10:06:23 <dfeuer> Why's it matter that it's a monad transformer?
10:06:31 <dfeuer> Isn't it just a function?
10:06:45 <vincenz> dfeuer: erm 
10:06:53 <vincenz> @where monad
10:06:54 <lambdabot> I know nothing about monad.
10:06:57 <vincenz> @where nomaware
10:06:57 <lambdabot> I know nothing about nomaware.
10:07:01 * vincenz peers at lambdabot
10:07:06 <vincenz> @where monads
10:07:07 <lambdabot> I know nothing about monads.
10:07:11 <vincenz> @google monads nomaware
10:07:15 <lambdabot> http://www.nomaware.com/monads/
10:07:15 <lambdabot> Title: "Nomaware | Monads"
10:07:18 <vincenz> Check that link
10:07:32 <dfeuer> A monad transformer is a function (Monad m) => m a -> m a, right?
10:07:38 <xerox> Nope.
10:07:46 <dcoutts_> vincenz, it's not a very concrete motivating example
10:07:47 <dmhouse> It's a type constructors.
10:07:50 <xerox> It is a type t m a.
10:07:55 <vincenz> dfeuer: that's an fmap and it's m a -> m b
10:08:03 <dmhouse> s/s\.//
10:08:06 <dfeuer> Remind me then.  What's a monad transformer?
10:08:06 <vincenz> dcoutts_: It was a simplistic example of something I needed at the time
10:08:15 <dmhouse> @type MaybeT
10:08:19 <dmhouse> Err
10:08:20 <lambdabot> Not in scope: data constructor `MaybeT'
10:08:23 <vincenz> dcoutts_: I have since chosen for a different design decision, but I still consider it to be an interesting idea
10:08:24 <dmhouse> @kind MaybeT
10:08:24 <dcoutts_> vincenz, it's sometimes hard to care if the example is too abstract
10:08:25 <lambdabot> Not in scope: type constructor or class `MaybeT'
10:08:40 <vincenz> dcoutts_: basically you define two different lifts, intra-transformer lift, and one that lifts all the way to the bottom m
10:08:52 <lightstep> dfeuer, it's a type constructor, that takes a monad and returns a new monad
10:08:59 <dmhouse> dfeuer: Okay, well MaybeT m a = Nothing | Just (m a).
10:09:01 <vincenz> dcoutts_: And the other post regarding existentials that people answered with wrong assumptions?
10:09:11 <dfeuer> oh
10:09:16 <xerox> dfeuer: when you are combining monads you can do it `The Hard Way', or use Monad Transformers.
10:09:17 <dcoutts_> vincenz, dunno, didn't read it :-0
10:09:21 <vincenz> yep
10:09:25 <lightstep> for each monad m, MaybeT m is also a monad
10:09:25 * vincenz is on haskell-cafe ignorelist
10:09:41 * dfeuer read a bit about monad transformers a long while back, and didn't understand any of it.
10:09:43 <xerox> dfeuer - http://www.nomaware.com/monads/html/hardway.html (and Next:)
10:09:46 <vincenz> dcoutts_: anyways, scoped data declaration is more practical/feasible and not as much pie-in-thesky
10:09:51 <lightstep> vincenz, take over HWN
10:10:04 <vincenz> lightstep: hmm?
10:10:04 <lightstep> it's less traffic, so people like me actually read it
10:10:18 <vincenz> lightstep: define the semantics of "take over"
10:10:22 <dmhouse> dfeuer: Say you want to write a function that produces a log output, but might also need to do some IO. Then it could have type WriterT [String] IO a.
10:10:31 <xerox> dmhouse: haha
10:10:37 * dcoutts_ goes out for a picnic :-)
10:10:42 <xerox> dmhouse - What a coincidence Writer provides `log'.
10:10:43 <dfeuer> I'm gonna read that page.
10:10:53 <xerox> (By the means of the function `tell'.)
10:10:55 <dmhouse> dfeuer: Then, whenever you needed to do IO, you'd wrap your IO statement in lift. (Or liftIO, which is optimised for IO.)
10:11:12 <vincenz> dmhouse: and if you have something like lift.lift.lift, you get an elevator :P
10:11:14 <lightstep> vincenz, send dons summaries to add to the discussion section
10:11:30 <vincenz> lightstep: ah, like that.  I thought you meant I did a hostile take over and took command over it iso dons
10:11:57 <lightstep> that's much harder. also requires really writing the whole issue
10:12:01 <vincenz> lightstep: the problem is that I don't do core-haskell-devel... they're more questions on howto/ideas
10:12:31 * vincenz is a sink in the community, not a source
10:13:08 <vincenz> on a sidenote, anyone ever considered using GIMPLE as backend language for haskell?
10:13:33 <vincenz> (gimple is the intermediate language that all the GCC-frontends map to)
10:19:10 <dfeuer> No proper program contains an indication which as an operator-applied
10:19:10 <dfeuer> occurrence identifies an operator-defining occurrence which as an
10:19:10 <dfeuer> indication-applied occurrence identifies an indication-defining occurrence
10:19:10 <dfeuer> different from the one identified by the given indication as an
10:19:10 <dfeuer> indication-applied occurrence.
10:19:11 <dfeuer> 		-- ALGOL 68 Report
10:20:06 <vincenz> o.O
10:26:13 <vincenz> dmhouse: ping
10:30:29 <xerox> dfeuer - My... !!
10:31:05 * vincenz can't even parse that
10:33:05 <dfeuer> :-)
10:33:13 <dfeuer> That came from the fortune file.
10:37:00 <norpan> vincenz: are there any advantages to using gimple instead of using simple c?
10:37:45 <vincenz> norpan: be right back to discuss that
10:37:47 <vincenz> afk for smoke
10:44:09 <dfeuer> eww
10:52:04 <vincenz> re
10:52:32 <vincenz> norpan: not perse saying it's advantageous, just curious. Cause if it exists then there's probably already some kind of data-declaration of the GIMPLE sat
10:52:34 <vincenz> s/sat/ast
10:53:13 <norpan> well gimple is interesting, but i've been more interested in parsing it than generating it :)
10:53:37 <vincenz> norpan: likewise
10:53:39 <norpan> the raw format that is
10:53:45 <vincenz> norpan: any efforts performed in that area?
10:53:53 <norpan> no
10:56:01 <norpan> couldn't find any decent documentation so i just did nothing
10:56:24 <vincenz> norpan: I could email you what I found after some brief asking around
10:56:35 <vincenz> norpan: what level of GIMPLE are you interested in?
10:56:46 <norpan> well it was some time ago
10:56:52 <norpan> atm it's no big concern
10:57:17 <norpan> i think it's a political issue not to generate an easy-to-use dump from gcc actually
10:57:42 <dfeuer> GNU doesn't like to document anything not intended for mortals (non-GNU programmers)
10:58:03 <dfeuer> So huge parts of glibc, say, are completely undocumented.
10:58:25 <vincenz> dfeuer: that's a red herring statement
10:58:34 <vincenz> glibc has little to do with GCC
10:58:51 <dfeuer> I think there's some shared philosophy there, maybe.
10:58:54 <vincenz> just like hierarchical libs have little to do with GHC
10:59:01 <vincenz> dfeuer: there's actually reports regarding GCC
10:59:07 <dfeuer> oh
10:59:11 <dfeuer> okay.
10:59:13 <vincenz> and yearly community reports
10:59:22 <vincenz> it just isn't very readable 
10:59:26 <vincenz> (500 page smacker)
10:59:46 <dfeuer> Sorry, I've only tried to understand some glibc stuff that turned out to be completely undocumented (the format of compiled locale files).
11:02:09 <norpan> anyway
11:02:17 <norpan> sorry i can't help you more
11:03:12 <vincenz> no worries
11:03:14 <vincenz> was just curious
11:04:02 <vincenz> norpan: why the interest in GIMPLE
11:04:40 <norpan> well i was getting some stuff from c files
11:04:49 <vincenz> what kind of stuff?
11:04:50 <norpan> but i ended up doing it much more simply
11:05:00 <vincenz> norpan: does this mean you have a full c parser?
11:05:06 <norpan> nope
11:05:25 <norpan> the c was generated so i got the information before the c was generated :)
11:06:02 <vincenz> ah lol
11:11:35 <SamB> oh good! I can type again. I wonder why WindowMaker does that sometimes...
11:12:06 <SamB> for some reason, it wasn't switching the keyboard focus correctly
11:14:12 <SamB> I had to restart it, and when I picked the menu item for that, it segfaulted
11:39:59 <xerox> http://fph.altervista.org/prog/bastet.shtml
11:40:57 <vincenz> xerox: questo weekend mi trasferisco :)
11:41:11 <xerox> Dove vai?
11:41:25 <vincenz> beh rimango nelle vicinanze, ma cambio appartamento
11:41:40 <vincenz> almeno avro un salotto piu bello e una terazza \o
11:43:55 <jdv79> http://sial.org/pbot/17928
11:43:58 <dmhouse> @babel it en what vincenz and xerox were just saying
11:44:00 <lambdabot>  what vincenz and xerox to were just saying
11:44:08 <jdv79> that look afamiliar to anyone?
11:44:25 <jdv79> i just want to compile ghc on RH 4:(
11:44:48 <xerox> (snd &&& fst) ("it","en")
11:45:27 <dmhouse> jdv79: Why not use a binary?
11:45:30 <vincenz> what's the correct work?
11:45:34 <vincenz> maturation or maturization
11:45:34 <jdv79> ok
11:45:44 <vincenz> and please, not the obvious joke
11:45:53 <vincenz> s/work/word
11:46:04 <vincenz> dmhouse: I pinged you!
11:46:18 <mauke> dict.leo.org can't find "maturization", so maturation wins
11:46:25 <vincenz> mauke: ah cool thx
11:47:24 <jdv79> dmhouse: cause i can't find one
11:47:31 <dmhouse> jdv79: Which arch?
11:48:17 <jdv79> i686 athlon looks like
11:48:45 <jdv79> well, uname snippet: "i686 athlon i386 GNU/Linux"
11:48:48 <dmhouse> @google download ghc site:haskell.org
11:48:51 <lambdabot> http://www.haskell.org/ghc/download_ghc_621.html
11:48:53 <lambdabot> Title: "GHC: Download version 6.2.1"
11:49:01 <dmhouse> Hold on.
11:49:25 <dmhouse> jdv79: http://haskell.org/ghc/download_ghc_642.html
11:49:42 <jdv79> i'll try that one
11:49:43 <jdv79> thanks
11:59:57 <heatsink> @hoogle Int -> (a -> m a) -> a -> m a
11:59:59 <lambdabot> No matches, try a more general search
12:00:08 <heatsink> @hoogle iterate
12:00:08 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
12:00:38 <heatsink> @hoogle replicate
12:00:39 <lambdabot> Prelude.replicate :: Int -> a -> [a]
12:00:39 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
12:00:39 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
12:06:08 <SyntaxNinja> audreyt: I have relabeled your door
12:06:41 <dcoutts_> g'evening SyntaxNinja 
12:08:16 <SyntaxNinja> heya dcoutts
12:08:24 * SyntaxNinja has audreyt encased in a small room nearby
12:08:34 <dcoutts_> eek, poor audreyt 
12:08:40 <dcoutts_> ghc RULES hacking is so much fun :-)
12:08:41 <xerox> hah!
12:08:48 <dcoutts_> there should be more tutorials on it
12:08:57 <xerox> All the fun is happening at Portland this summer :-)
12:08:58 <SyntaxNinja> dcoutts_: maybe you can do it at the hackathon!
12:09:03 <dcoutts_> there should be a tutorials on it
12:09:08 <heatsink> heh
12:09:14 <dcoutts_> SyntaxNinja, sadly I can't go that far :-(
12:09:30 <dcoutts_> and I'm doing other stuff in Sept
12:09:31 <SyntaxNinja> if bringert weren't so busy doing work for some CONFERENCE then he'd probably be here too to hear audreyt speak.
12:09:38 <audreyt> yo :)
12:09:49 <dcoutts_> he escapes!
12:10:21 <xerox> He wears a backslash? /me hides
12:10:37 <dcoutts_> SyntaxNinja, the other thing people should be more aware of is all the detailed info that ghc gives on what optimisations it's doing
12:10:47 <dcoutts_> -ddump-simpl-iterations
12:10:57 <dcoutts_> it's quite enlightening
12:12:39 <dcoutts_> ghc generates startlingly good code in many cases if you treat it right
12:13:00 <dcoutts_> the only let down is some of the low level bits in the last stages of code generation
12:13:19 <dcoutts_> mostly core -> cmm & cmm -> C/asm
12:14:08 <dcoutts_> the core output from some of this array/ByteString stuff is great
12:14:25 <dcoutts_> it translates right down to effecient loops
12:14:54 <dcoutts_> but then the final translations is where we loose out against C
12:15:24 <heatsink> GHC uses C-- already?
12:15:28 <dcoutts_> yes
12:15:31 <dcoutts_> but not well
12:15:58 <dcoutts_> it doesn't use C-- local vars, or C-- function calls
12:16:23 <dcoutts_> or the C-- stack
12:16:34 <heatsink> What, so all temporary variables are on the heap?
12:16:40 <dcoutts_> in STG registers
12:16:47 <dcoutts_> some of which map to real cpu registers
12:16:51 <heatsink> oh
12:16:59 <dcoutts_> you'll see lots of things like R1 = ...
12:17:31 <dcoutts_> many other temp vars are on the stack
12:17:34 <ihope_> @type Control.Monad.ap return
12:17:35 <lambdabot> forall a a1. (a1 -> a) -> a1 -> a1
12:17:42 <dcoutts_> which is an explicitly managed stack, not the C-- stack
12:17:45 <ihope_> ...?
12:17:56 <ihope_> @type Control.Monad.ap
12:17:57 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
12:18:04 <ihope_> I see.
12:18:57 <ihope_> @type Control.Monad.ap Control.Monad.Fix.fix
12:18:59 <lambdabot> forall a b. (((a -> b) -> a -> b) -> a) -> ((a -> b) -> a -> b) -> b
12:19:06 <ihope_> @type Control.Monad.ap return Control.Monad.Fix.fix
12:19:07 <lambdabot> forall a. (a -> a) -> a -> a
12:19:12 <ihope_> Hmm.
12:19:14 <mauke> @. djinn type Control.Monad.ap Control.Monad.Fix.fix
12:19:16 <lambdabot> -- f cannot be realized.
12:19:33 <ihope_> @djinn forall a b. (((a -> b) -> a -> b) -> a) -> ((a -> b) -> a -> b) -> b
12:19:34 <lambdabot> -- f cannot be realized.
12:19:36 <ihope_> :-)
12:19:39 <heatsink> So it sounds like something that takes work in the GHC-> cmm phase.
12:19:43 <ihope_> @djinn  (((a -> b) -> a -> b) -> a) -> ((a -> b) -> a -> b) -> b
12:19:44 <lambdabot> -- f cannot be realized.
12:19:52 <mnislaih> @seen Lemmih
12:19:52 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
12:19:52 <ihope_> Aww.
12:20:01 <mauke> @. djinn type Control.Monad.ap return
12:20:02 <lambdabot> f _ a = a
12:20:18 <mnislaih> by chance are you there Lemmih ?
12:20:26 <ihope_> @djinn forall a. a -> b
12:20:27 <lambdabot> -- f cannot be realized.
12:20:28 <ihope_> Erm.
12:20:30 <ihope_> @djinn forall a. a -> a
12:20:31 <lambdabot> f a = a
12:20:47 <ihope_> @djinn forall b. (forall a. a) -> b
12:20:47 <lambdabot> -- f cannot be realized.
12:20:50 <ihope_> :-)
12:21:35 <heatsink> heh
12:22:28 <ihope_> Hmm...
12:22:30 <ihope_> @type ego
12:22:31 <lambdabot> Not in scope: `ego'
12:22:33 <ihope_> Aww.
12:22:37 <mauke> unconst :: (a -> b) -> a -> b
12:23:02 <ihope_> Um... (a -> b) -> b?
12:23:03 <xerox> ?type (flip id)
12:23:05 <lambdabot> forall b c. b -> (b -> c) -> c
12:23:32 <ihope_> @type ($)
12:23:33 <lambdabot> forall b a. (a -> b) -> a -> b
12:23:37 <ihope_> @type (=<<)
12:23:38 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
12:34:28 <MarcWeber> Does anyone know how to feed parsec with single tokens to check wether the parssing has failed yet?
12:35:13 <heatsink> I think it's too lazy for that
12:35:40 <heatsink> Are you parsing strings?
12:36:39 <SamB_XP_> single tokens?
12:37:29 <Lemmih> mnislaih: Hiya.
12:38:40 <MarcWeber> No, the filesystem ;)
12:39:03 <MarcWeber> That's why I need to feed the first folder and the next and reuse the state.
12:39:22 <vincenz> re
12:39:40 <MarcWeber> I don't want to scan all folders before I knowing wether parsing suceeds
12:40:45 <heatsink> MarcWeber: Parsec reads input lazily.  It will only read as much of the input as necessary to determine whether parsing has failed.
12:42:22 <heatsink> MarcWeber: I've written a lexical analyzer in C and then used unsafePerformIO to marshal it as a lazy list for consumption by Parsec.  You can probably do a similar thing for reading the filesystem.
12:45:18 <MarcWeber>  heatsink And how can I feed it with the token /tmp, get the state (failed, need more tokens) feed the next token (now folder temp-mutt and temp-blah) ..?
12:45:31 <vincenz> heatsink: why?
12:45:44 <vincenz> heatsink: why did you implementn the lexanal n c?
12:46:01 <vincenz> s/n/in
12:46:34 <heatsink> vincenz, It was a state machine needing exactly one character of lookahead, easier to do in C.
12:46:54 <vincenz> heatsink: oh oic
12:46:55 <heatsink> MarcWeber: How do you create the list of tokens?
12:47:05 <vincenz> heatsink: ooc: did you consider alex?
12:47:42 * heatsink will be back in a few minutes
12:50:49 <heatsink> vincenz: I was busy learning happy at the time, didn't want to learn alex too.
12:51:03 <vincenz> heatsink: ah ok :)
12:51:21 <vincenz> heatsink: the nice thing is if you use a custom monad, you can use it as underlying basis for both alex and happy
12:51:23 <heatsink> That's right, I started in parsec but switched to happy.
12:51:24 <vincenz> that's what I do
12:51:28 <vincenz> heatsink: me too
12:54:29 <MarcWeber>  heatsink getFileMatches dir parser  = do {c <- getDirectoryContents; [(file,parserstate)] =  map runparser c ; goon = filter parserSucceeded; return $ map getFileMatches dir+goon ) ...
12:54:33 <MarcWeber> This way.
12:54:44 <MarcWeber> not exactly but you should get the idea.
12:55:55 <MarcWeber> The problem is that parsec doesn't expose runP which runs one step of the parser.. Perhaps I should contact the mantainer and ask him hwo to do it.. ;)
13:02:23 <heatsink> So you run the parser once per IO call, then inspect the results before doing any thing else?
13:03:01 <heatsink> There doesn't seem to be any superfluous IO in there.
13:04:16 <MarcWeber> heatsink: Correct.
13:05:53 <Kasperle> sorry if this is slightly off-topic, but this is about the only compsci related channel i know: do you know of a (LR(1)) parser that can output the LR(1) item sets for a simple EBNF grammar? I need to verify an example from some lecture notes.
13:08:25 <heatsink> So is there something you want to change about it?
13:10:33 <heatsink> It looks okay to me.
13:10:53 <MarcWeber> heatsink: Yeah perhaps.. Exposing runP wuold help me a great deal. I've send a mail to haskell-cafe cc to the mantainer. We'll see ;)
13:14:30 <RyanT5000> is there a doubly-linked list?
13:14:47 <RyanT5000> something where i can insert, delete, and retrieve from both ends efficiently
13:15:05 <heatsink> RyanT5000, maybe you want something from Edison?
13:15:29 <RyanT5000> well i was hoping it'd be in the standard library
13:18:13 <heatsink> RyanT5000, for most purposes you don't need all the things you can do with a mutable doubly linked list.
13:19:05 <RyanT5000> well what i have is a message queue, but i need to be able to be able to coalesce messages under certain conditions
13:19:28 <RyanT5000> e.g.: if the tail (most recently added) message is a MouseMoved message, and the next message to be added is a MouseMoved message, they should be coalesced
13:19:39 <heatsink> It sounds like you want a deque
13:19:47 <RyanT5000> yeah
13:20:05 <RyanT5000> that's what i'd use if i was in C++
13:20:11 <heatsink> There's one of those in the Edison libraries.
13:20:20 <RyanT5000> where are those?
13:20:27 <RyanT5000> @where Edison
13:20:28 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
13:21:22 <heatsink> RyanT5000, it's called BankersQueue
13:21:29 <RyanT5000> k
13:21:32 <RyanT5000> thanks
13:44:29 * vincenz applies more heat to heatsink 
13:45:08 <cjay> are BankersQueue and deque synonyms for doubly linked list?
13:45:16 <vincenz> cjay: no
13:45:24 <vincenz> cjay: you're confusing implementation and interface
13:45:47 <vincenz> cjay: doubly linked list (which is not really a good techinique in lazy functional pure languages) are an implementation choice for a deque
13:46:20 <dcoutts_> a doubly linked list is fine so long as you never want to modify it
13:46:37 <cjay> ok, and what is a bankers queue? google has very few information on this
13:46:53 <vincenz> dcoutts_: touche
13:46:57 <cjay> i never heared it before
13:47:05 <vincenz> cjay: I suggest reading the edison's author phd it's very informative
13:47:37 <vincenz> cjay: banker's queue is a queue that uses the banker's amortized complexity method to ensure certain complexities iirc
13:48:14 <cjay> thanks, I will take a look at it
13:48:31 <vincenz> it's a queue
13:48:37 <vincenz> just hte way it's implemented makes it a banker's queue
14:03:45 <vincenz> > drop 1000000 $ let mkVars i o = let vars = i ++ (map concat . sequence $ [vars, o]) in vars in mkVars (map return ['a'..'z']) (map return ['0'..'9'])
14:03:47 <lambdabot>  ["h11114","h11115","h11116","h11117","h11118","h11119","h11120","h11121","h1...
14:04:07 <zarvok> exit
14:11:42 <vincenz> crap
14:11:46 <vincenz> that method blows up
14:11:47 <vincenz> in space
14:21:09 <ricebowl> is there a way to debug Haskell expressions, i.e. see each atomic evaluation?
14:24:02 <dfeuer> ricebowl, sure.
14:24:23 <dfeuer> Don't be askin' me how.
14:26:23 <mwc> ricebowl, ghci?
14:37:08 <vincenz> Cale: ping
14:44:26 <dmhouse> ricebowl: GHCi is your best bet.
14:44:35 <dmhouse> Evening channel.
14:44:53 <dmhouse> ricebowl: That involves typing in each expression, though, so Hat might be more to your taste.
14:44:58 <dmhouse> @where hat
14:44:58 <lambdabot> http://www.cs.york.ac.uk/fp/hat
14:45:50 <Dino_> What about loading your code up in ghci and trying to eval individual functions to determine where the problem is?
14:46:13 <dmhouse> It's a pain to copy-paste each expression.
14:46:31 <dmhouse> Hat gives you evaluation traces.
14:47:31 <Dino_> Huh, this is cool. I was eventually going to get around to asking you guys about debugging tools.
14:47:32 <SamB> Dino_: that is workable
14:47:40 <SamB> Hat is sometimes not stable
15:02:08 <ricebowl> dmhouse - that's what I was hoping to avoid
15:02:16 <dmhouse> ricebowl: Hat then.
15:02:19 <ricebowl> it's very time-consuming to take a nested function and expand it by hand in the debugger
15:02:30 <dmhouse> Yeah.
15:03:03 <dmhouse> It'd be lovely for GHCi to make all local definitions in scope too.
15:03:07 <mwc> GHCI should have a mode where it dumps the value of subexpressions; when their type is a Show of course
15:03:16 <ricebowl> exactly what I was hoping for.
15:03:17 <dmhouse> (Assuming they have no free variables.)
15:03:56 <dmhouse> mwc, I think the guy working on the GHCi debugger was making a generic value viewer.
15:04:03 <ricebowl> ideally it would strictly evaluate each expression (with some extra glue to handle exceptions and infinite lists) and give the results at each stage
15:04:23 <ricebowl> that way you can see where things go wrong
15:04:28 <dmhouse> mwc, i.e. Show's not necessary.
15:04:44 * SamB doesn't think that would work very well -- it would make the evaluation too strict
15:04:45 <ricebowl> oh well
15:04:53 <ricebowl> why is that a problem?
15:05:01 <ricebowl> as long as you know that [1..] is still [1..]
15:05:10 <ricebowl> even partial expansion like lambdabot does is fine
15:05:12 <ricebowl> > [1..]
15:05:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:05:24 <dmhouse> ricebowl: How do you distinguish between [1..] and [1..1000000000]?
15:05:38 <mwc> fwiw, http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Tracing_.26_debugging
15:05:43 <ricebowl> real question is: do you need to?
15:05:44 <dmhouse> You can't do it in better than O(n) time.
15:05:57 <ricebowl> yes, unless you are smart about it
15:06:57 <ricebowl> well, even a half-ass solution is better than nothing
15:07:16 <ricebowl> in my case, I'm not using infinite lists, and strict eval would work just fine
15:07:28 <ricebowl> trying to debug lazy eval code would be too confusing
15:07:32 <dmhouse> ricebowl: Have you checked out Hat yet? :)
15:07:44 <ricebowl> no, but I opened up the webpage
15:07:48 <ricebowl> I'm about to leave work, so I'll look later
15:09:07 <ricebowl> only way to generate an infinite list is [1..] and such, no?
15:09:19 <dmhouse> Nope.
15:09:27 <dmhouse> ones = 1 : ones
15:09:37 <ricebowl> oh, and repeat, I forgot
15:09:40 <dmhouse> Which is [1,1..]
15:09:54 <dmhouse> repeat is basically what I typed there. repeat x = x : repeat x.
15:10:03 <ricebowl> yeah, I know
15:10:42 <dmhouse> But you could come up with other ways that are slightly varied.
15:11:39 <dmhouse> E.g. say you had ones _ _ _ = x `cons` ones 2 3 4 where cons = (:); x = 10 - 9.
15:12:43 <dmhouse> ricebowl: But infinite lists aren't the only place where laziness is necessary. E.g. co-recursive functions.
15:13:19 <dmhouse> odds (x:xs) = x : evens xs; evens (_:xs) = odds xs.
15:21:20 <vincenz> dmhouse: is co-recursive an official word or has my frequent usage led to it being used?
15:22:11 <dmhouse> vincenz: I was following the recent [Haskell] thread on laziness, that's where I picked it up.
15:22:20 <vincenz> kewl
15:22:23 <vincenz> so it is an official word
15:22:31 <vincenz> at least I'm not talking about frogmabingties
15:26:09 <vincenz> dmhouse: the discussion about corecursion of recursion?
15:26:28 <vincenz> here is another cool example of recursion
15:27:09 <vincenz> > drop 5000 $ let mkVars i o = let vars = i ++ (map concat . sequence $ [vars, o]) in vars in mkVars ["a", "b"] ["a", "b"]
15:27:10 <lambdabot>  ["aabbbaaababa","aabbbaaababb","aabbbaaabbaa","aabbbaaabbab","aabbbaaabbba",...
15:27:32 <dmhouse> Oh yeah.
15:27:42 <vincenz> damn
15:27:46 <vincenz> not quite binary arith
15:27:56 <vincenz> > let mkVars i o = let vars = i ++ (map concat . sequence $ [vars, o]) in vars in mkVars ["a", "b"] ["a", "b"]
15:27:57 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
15:28:13 <vincenz> unless you pick a given string-length
15:29:07 <dmhouse> > let mkVars' i o = let vars = i ++ (map concat . sequence $ [vars, o]) in vars; mkVars = join mkVars' in mkVars ["0", "1"]
15:29:08 <lambdabot>  ["0","1","00","01","10","11","000","001","010","011","100","101","110","111"...
15:30:15 <vincenz> dmhouse: sadly it grows in space
15:30:23 <vincenz> dmhouse: linearly with the amount of data dropped
15:30:36 <vincenz> but,  Iguess that makes sense
15:30:37 <vincenz> strings get longer
15:30:41 <dmhouse> Yeah.
15:30:59 <vincenz> dmhouse: it's just that you have to keep the entire vars in the second part
15:31:01 <vincenz> I think
15:31:03 * vincenz pondres
15:31:11 <vincenz> dmhouse: I don't like the (map concat . sequence $) tho
15:31:38 <vincenz> hm
15:32:43 <vincenz> aha
15:33:43 <vincenz> > let mkVars i o = let vars = i ++ (map (\h -> map (\t -> t:h) o) vars) in map reverse vars in mkVars ["a", "b"] ["a", "b"]
15:33:44 <lambdabot>  Couldn't match `[a]' against `Char'
15:34:11 <vincenz> >  let mkVars i o = let vars = i ++ (map (\h -> map (\t -> h++t) o) vars) in vars in mkVars ["a", "b"] ["a", "b"]
15:34:12 <lambdabot>  Couldn't match `[a]' against `Char'
15:34:27 <vincenz> >  let mkVars i o = let vars = i ++ concatMap (\h -> map (\t -> h++t) o) vars in vars in mkVars ["a", "b"] ["a", "b"]
15:34:28 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
15:35:17 <dmhouse> >  let mkVars i o = let vars = i ++ concatMap (\h -> map (h++) o) vars in vars in mkVars ["a", "b"] ["a", "b"]
15:35:18 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
15:35:22 <dmhouse> That's quite clear.
15:36:59 <vincenz> @pl concatMap (\h -> map (h++) o) 
15:37:00 <lambdabot> (flip map o . (++) =<<)
15:37:23 <vincenz> >  let mkVars i o = let vars = i ++ (flip map o . (++) =<<) vars in vars in mkVars ["a", "b"] ["a", "b"]
15:37:24 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
15:37:27 <dmhouse> ;)
15:37:29 <vincenz> that one's neater
15:37:32 <dmhouse> Nah.
15:37:43 <vincenz> specially =<< bit
15:37:46 <vincenz> @type (=<<)
15:37:48 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
15:38:33 <stepcut> @pl let mkVars i o = let vars = i ++ concatMap (\h -> map (h++) o) vars in vars in mkVars ["a", "b"] ["a", "b"]
15:38:33 <lambdabot> fix ((["a", "b"] ++) . (flip map ["a", "b"] . (++) =<<))
15:38:35 <stepcut> ;)
15:38:43 <dmhouse> >  let mkVars i o = let vars = i ++ (\h -> map (h++) o) =<< vars in vars in mkVars ["a", "b"] ["a", "b"]
15:38:44 <lambdabot>    The lambda expression `\ h -> ...' has one arguments,
15:38:44 <lambdabot>   but its type `...
15:38:58 <dmhouse> >  let mkVars i o = let vars = i ++ ((\h -> map (h++) o) =<< vars) in vars in mkVars ["a", "b"] ["a", "b"]
15:38:59 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
15:40:09 <dmhouse> I still prefer concatMap to >>= in the special case of the list.
15:40:21 <dmhouse> Perhaps not here, because we're doing monad-like choosing.
15:43:11 <vincenz> dmhouse: it's ==<
15:43:17 <vincenz> which I don't get
15:43:20 <vincenz> @type (>>=)
15:43:21 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
15:43:25 <vincenz> @type (=<<)
15:43:26 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
15:43:32 <vincenz> a
15:43:34 <dmhouse> vincenz: (=<<) = flip (>>=)
15:43:38 <vincenz> dmhouse: I just like the symmetry
15:43:50 <dmhouse> (=<<) reads more like function application.
15:43:59 <vincenz> (flip map o . (++) =<<) almost feels like a hieroglyph
15:44:18 <vincenz> @type \o -> (flip map o . (++) =<<)
15:44:19 <lambdabot> forall a. [[a]] -> [[a]] -> [[a]]
15:44:22 <vincenz> @pl \o -> (flip map o . (++) =<<)
15:44:23 <lambdabot> (=<<) . (. (++)) . flip map
15:44:27 <vincenz> oy
15:44:31 <vincenz> one level too far
15:45:08 <vincenz> > (flip map o . (++) =<<) [[1,2],[3,4]] [[5,6],[7,8]]
15:45:09 <lambdabot>  Not in scope: `o'
15:45:16 <dmhouse> Hrm
15:45:20 <vincenz> > (\o -> (flip map o . (++) =<<)) [[1,2],[3,4]] [[5,6],[7,8]]
15:45:21 <lambdabot>  [[5,6,1,2],[5,6,3,4],[7,8,1,2],[7,8,3,4]]
15:45:36 <vincenz> o.
15:45:38 <vincenz> odd
15:45:43 <dmhouse> How does ((++) =<<) type? (=<<) needs a function of arity 1 on its LHS.
15:45:51 <vincenz> dmhouse: hah
15:45:54 <vincenz> dmhouse: currying!
15:46:14 <vincenz> @type ((++) =<<)
15:46:15 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [a]
15:46:59 <dmhouse> It's concatMap (++), no?
15:47:04 <dmhouse> @type concatMap (++)
15:47:05 <lambdabot>   Expecting a function type, but found `[b]'
15:47:05 <lambdabot>    Expected type: [a] -> [b]
15:47:21 <dmhouse> @pl concatMap (++)
15:47:22 <lambdabot> ((++) =<<)
15:47:34 <dmhouse> Riiiight.
15:48:21 <vincenz> :D
15:48:34 <vincenz> dmhouse: don't forget that =<< is monadic
15:48:39 <vincenz> dmhouse: so it must be working on the function level
15:48:40 <vincenz> not the list
15:48:46 <dmhouse> Oh, right.
15:48:46 <vincenz> ala reader
15:49:01 <dmhouse> _That's_ why pointsfree is a waste of time.
15:49:48 <vincenz> dmhouse: well if you document the function well that uses it
15:49:54 <vincenz> internals matter less
15:50:02 <dmhouse> That's just not true.
15:50:05 <dmhouse> Refactoring, anyone?
15:51:50 <dmhouse> @spell defered
15:54:26 <dmhouse> @tell dons I think @spell is broken.
15:54:27 <lambdabot> Consider it noted.
15:56:49 <vincenz> dmhouse: still it's short, concise
15:56:53 <vincenz> dmhouse: nice little kernel
15:57:46 <dmhouse> vincenz: Don't obfuscate your code. Readability > Elegance.
15:58:01 <dmhouse> I prefer lambdas to flip, for example.
15:59:34 <vincenz> dmhouse: I don't
15:59:38 <vincenz> and to me it's not obfuscation
15:59:45 <vincenz> it removes lisp
16:00:20 <dmhouse> > let tab = zip [1..3] ['a'..'z'] in map (\k -> lookup k tab) [1..3]
16:00:21 <lambdabot>  [Just 'a',Just 'b',Just 'c']
16:00:30 <dmhouse> > let tab = zip [1..3] ['a'..'z'] in map (flip lookup tab) [1..3]
16:00:31 <lambdabot>  [Just 'a',Just 'b',Just 'c']
16:00:56 <dmhouse> I'd go for the former each time. It's instantly accessible without having to grope around your memory for the type of lookup.
16:01:27 <heatsink> dmhouse: what about curry/uncurry?
16:01:29 <vincenz> I guess it's preference
16:01:35 <dmhouse> vincenz: How is it not obfuscation? You've taken something that was perfectly clear, and made it unclear.
16:01:44 <dmhouse> heatsink: What about it?
16:02:10 <heatsink> I prefer (curry Map.lookup) to (\(k, v) -> Map.lookup k v)
16:02:18 <heatsink> More tokens -> harder to read.
16:02:37 <heatsink> s/curry/uncurry/
16:03:04 <vincenz> dmhouse: I guess clear is dependent on personality
16:03:04 <dmhouse> Sure.
16:03:35 <dmhouse> @type uncurry
16:03:36 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
16:03:53 <dmhouse> heatsink: Assuming you meant uncurry Map.lookup :) And yeah, I'd likely use that too.
16:04:33 <dmhouse> I guess I dislike flip because of mental argument swapping you have to do.
16:05:28 <heatsink> I can understand that.
16:05:52 <heatsink> I think there are certain ways of ordering things that we get good at reading.
16:06:01 <dmhouse> Yeah.
16:07:01 <dmhouse> '\(k, v) -> Map.lookup k v' seems to me like it could be reduced to a more pointsfree style, because the arguments come in and are dispatched in the same order.
16:07:02 <heatsink> Combinators like uncurry or flip can adjust things so they fit into a readable order.  I somtimes use flip so that I can write a larger expression with $ $ or . . instead of parentheses.
16:07:39 <dmhouse> I.e. if it were \k v -> Map.lookup k v you'd have no worries about eta-reducing that.
16:08:22 <dmhouse> So you use uncurry as the fudge factor.
16:08:30 <dmhouse> heatsink: That's true. If I have a big do-block, say, as the first argument to a binary function I'll often flip it so I can provide it as the last.
16:08:31 <heatsink> heh.
16:27:38 <mauke> flip trace False $ show (a, b)
16:45:33 <liyang> You know what's cool? Making fib n = fib (n - 1) + fib (n - 2) run in linear time *without* rewriting the program. (Mostly.)
16:46:18 <lscd> how, memoizing?
16:50:18 <liyang> lscd: a funny memoising fixpoint combinator. =)
16:50:28 <lscd> cool :)
16:50:46 <liyang> You get the original back if you use a/the trivial fixpoint combinator instead.
16:58:11 <vincenz> aloha
16:58:17 <lscd> aloha, vincenz 
16:58:24 <lscd> hawaiian today?
16:59:04 <vincenz> nah
16:59:07 <vincenz> always use aloha
16:59:08 <vincenz> or que pasa
16:59:15 <lscd> hm. is that spanish?
16:59:26 <vincenz> que pasa, yes
17:45:15 <vincenz> > let ones = 1:twos; twos = 2:threes; threes=3:remaining; remaining = map (+3) ones
17:45:15 <lambdabot>  Parse error
17:45:18 <vincenz> > let ones = 1:twos; twos = 2:threes; threes=3:remaining; remaining = map (+3) ones in ones
17:45:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:47:39 <vincenz> Woot cool
17:47:46 <vincenz> defined a function that works in finite time for infinite lists
17:47:50 <vincenz> but infinte time for finite lists
17:48:22 <lispy> hmm...i really don't have infinite time to wait and see it work :(
17:48:49 <vincenz> check it out
17:49:14 * lispy was teasing
17:49:14 <vincenz> > let funky l = take 1 l ++ (funky . drop 1 $ l) in funky [1..]
17:49:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:49:19 <vincenz> > let funky l = take 1 l ++ (funky . drop 1 $ l) in funky [1..3]
17:49:23 <lambdabot> Terminated
17:49:27 <lispy> whoa
17:49:30 <lispy> weird
17:49:33 <vincenz> not really
17:49:39 <vincenz> it constructs an infinte list
17:49:42 <vincenz> and for the last element
17:49:46 <vincenz> it just recurses infinitely with an empty list
17:49:50 <vincenz> so it can't get the 4 element
17:49:57 <lispy> ah
17:50:00 <lispy> gotcha
17:50:10 <vincenz> pretty cool tho
17:50:15 * lispy nods
17:50:28 <vincenz> @pl funky l = take 1 l ++ (funky . drop 1 $ l)
17:50:28 <lambdabot> funky = fix (ap ((++) . take 1) . (. drop 1))
17:50:32 * vincenz winces
17:51:18 <vincenz> @tell dmhouse Check out this cool function: finite time for infinite lists, infinite time for finite lists:  let funky l = take 1 l ++ (funky . drop 1 $ l) in funky [1..]   .... let funky l = take 1 l ++ (funky .  drop 1 $ l) [1..3]
17:51:19 <lambdabot> Consider it noted.
17:51:45 <vincenz> lispy: but yeah I noted it whe ntrying to build something else
17:52:22 <vincenz> even funkier
17:52:29 <vincenz> > let funky l = take 1 l ++ (funky . drop 1 $ l) in funky [1..20]
17:52:33 <lambdabot> Terminated
17:52:35 <vincenz> > let funky l = take 1 l ++ (funky . drop 1 $ l) in funky [1..40]
17:52:39 <lambdabot> Terminated
17:52:43 <vincenz> > let funky l = take 1 l ++ (funky . drop 1 $ l) in funky [1..1000]
17:52:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:52:47 <vincenz> ;)
17:53:06 <vincenz> odd that it requires many more elements than 30
17:53:57 <vincenz> and apparently it gets slower as you move down
17:54:02 <vincenz> the bigger the list, the faster it is
17:54:05 <vincenz> o.O
17:55:10 <vincenz> at least with lambdabot
17:55:17 <vincenz> smallest n seems to be 283 atm
17:55:26 <vincenz> not sure if it's a limitation of the printing, or if it's cpu-dependent
18:00:33 * vincenz considers writing a humourous post to haskell-cafe
18:00:36 <vincenz> not sure how well it'd be received tho
18:05:10 * Lemmih would receive it digitally, in most likelihood.
18:05:28 <lispy> heh
18:05:40 <lispy> knuth would have is receptionist print it and bring it to him
18:06:03 <lispy> knuth is a crazy old man though
18:06:10 <vincenz> Lemmih: :D
18:06:12 <vincenz> something like
18:06:56 <vincenz> "New development in the dual of the halting problem.  With haskell it is now possible to ensure that every list is infinite and that therefore any computation will take an infinite amount of time!"
18:07:21 <vincenz> Stop worrying about the halting problen and focus on the nonhalting problem today!
18:08:33 <lscd> hahaha
18:08:34 <vincenz> > let infinitize nl = take n l ++ (infinitize n .  drop n $ l) in take 1 $ infinitize 1000 [1..3]
18:08:35 <lambdabot>  Not in scope: `l'
18:08:41 <vincenz> > let infinitize n l = take n l ++ (infinitize n .  drop n $ l) in take 1 $ infinitize 1000 [1..3]
18:08:42 <lambdabot>  [1]
18:08:45 <vincenz> crud
18:09:39 <vincenz> > let infinitize l = take 1 l ++ (infinitize .  drop 1 $ l) in take 1 $ take 4 $ infinitize [1..3]
18:09:40 <lambdabot>  [1]
18:09:52 <vincenz> > let infinitize l = take 1 l ++ (infinitize .  drop 1 $ l) in take 4 $ infinitize [1..3]
18:09:56 <lambdabot> Terminated
18:10:39 <vincenz> > let infinitize l = reverse . reverse $ take 1 l ++ (infinitize .  drop 1 $ l) in take 4 $ infinitize [1..3]
18:10:41 <lambdabot>  Exception: stack overflow
18:10:43 <vincenz> > let infinitize l = reverse . reverse $ take 1 l ++ (infinitize .  drop 1 $ l) in take 1 $ infinitize [1..3]
18:10:46 <lambdabot>  Exception: stack overflow
18:11:05 <vincenz> better
18:11:49 <vincenz> anyways
18:11:50 <vincenz> enough spam from me
18:11:53 * vincenz is off to bed
18:11:53 <vincenz> cya
18:12:52 <lispy> see ya
18:12:56 <lispy> sleep well
18:13:23 <lispy> anyone else played with h/direct recently?
18:13:53 <lispy> i tried some stuff with com automation and office again but still banging my head against the wall
19:36:03 <dons> good morning
19:36:04 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:36:56 <audreyt> dons: hi
19:38:56 <dons> hey audreyt
19:39:33 <lispy> morning
19:39:42 <lispy> dons: did you winter just start this past week?
19:40:48 <dons> yep
19:40:57 <dons> if i parse that sentence correctly ;)
19:41:07 <lispy> s/you/your/
19:41:31 <lispy> heh, the earth is so odd with its hemispheres...
19:42:53 <iron32> lispy : odd ? how so 
19:47:21 <lispy> iron32: the seasons are reversed around the equator
19:47:26 <lispy> that's how!
19:47:35 * lispy frothes at the mouth with excitement
19:47:58 * lispy bounces off a wall, causing himself to fall down and bounces back up again
19:50:07 <gregarican> the axis tilts one way toward the sun for half the trip around the sun, then it tilts the other for the other half of the trip. Does that also cause water to cycle around the drain counterclockwise versus clockwise depending on the equator?
19:51:43 <lispy> gregarican: no, the effect that makes water spin differently is so minor that it's very hard to measure
19:52:11 <iron32> gregarcian : No that is a myth but it does effect the direction that Cyclones rotate
19:52:47 <lispy> i heard that in korean they have an urban legend that says sleeping in a closed room with an electric fan going causes you to suffocate
19:53:07 * lispy realizes this is a better topic for #haskell-blah
19:53:18 <iron32> sorry for the slow responses trying to figure out how to wrap my record in a monad
19:54:15 <iron32> gragarcian : Just for reference this effect is known as Coriolis effect
19:54:40 <iron32> have to remember to auto tab names
19:54:51 <gregarican> iron32: l have learned something new today :-)
19:56:04 <iron32> gregarican: any day in which that happens is always a good day :) Don't suppose your a monad guru are you ?
19:56:23 <lispy> iron32: what is your question/struggle?
19:56:29 <gregarican> nope. i have dabbled in haskell a bit. but am better versed in other langs
19:56:49 <dons> mm. wmii is quite nice these days. i thought i'd never find a replacement for ion, but maybe...
19:57:11 <iron32> gregarican: Me too I am actaully a very good imperative programming just pretty much suck at declarative programming
19:57:16 <dons> esp. once you replace all the scripts with haskell code
19:57:25 <lispy> dons: heh
19:57:42 <lispy> dons: i wish i had your ability for finding time to hack on things
19:58:08 <iron32> lispy: Well I need to wrap a record I have defined in a monad
19:58:16 <dons> i'll post my wmii haskell hacks
19:58:23 <gregarican> iron32: i spend most of my time coding in Python, Ruby, and Smalltalk. but am interested in functional langs to broaden my horizons.
19:58:54 <lispy> whenever i use python i miss type checking...haskell has spoiled me! ;)
19:59:03 <lispy> (otherwise, i'd say python is top notch)
19:59:38 <gregarican> python seems more mature than ruby and has more extensive libraries to add in. but ruby is more _fun_ for some reason for me
19:59:41 <iron32> gregarican: Smalltalk is my favorite language I don't know why python and ruby never grabed me that much
20:00:16 <iron32> gregarican: Ruby perl influence turned me off even though it has many great features
20:00:45 <gregarican> once you get into Smalltalk the other (lesser) OO langs pale in comparison and efficiency it seems
20:01:54 <iron32> gregarican: Well LISP CLOS has my total respect it is the most powerful OO sytem I have worked with but Smalltalk syntax is just so much more readable
20:02:26 <gregarican> although for quick regex text parsing, admin scriptingm etc, something like Ruby or Python is a snap for a small quick and dirty script.
20:02:26 <iron32> and often I don't need something as pwerful as CLOS
20:02:34 <SamB> I think slate is trying to do a mixture of both, to some extent
20:02:48 <SamB> at least, it has multiple dispatch...
20:05:21 <dons> kosmikus: pong?
20:05:26 <user317> is there a haskell implementation of the DEFLATE algorithm, i dont mean zlib bindings
20:05:40 <SamB> there could be
20:05:56 <SamB> but it wouldn't be as pretty as it ought to be, because of special cases...
20:06:04 <SamB> or something like that
20:06:15 <dons> user317: yeah, i think so. check Igloo's zlib code
20:06:45 <SamB> I mean, the tree isn't allowed to go past a certain depth, iirc
20:08:09 <user317> http://urchin.earth.li/~ian/systime/Inflate.lhs
20:08:11 <user317> cool
20:11:13 <iron32> Monads and Monads transforms are driving me nuts is there any decent material out there ? most of the standard stuff seems terse, trivial and not very useful
20:12:14 <Saulzar> iron32, Have you read "all about monads"? Or Cale's "monads as containers"?
20:13:00 <Cale> @wiki Monads_as_Containers
20:13:01 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
20:13:09 <Cale> @wiki Introduction_to_IO
20:13:09 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
20:13:24 <Cale> @where all about monads
20:13:25 <lambdabot> I know nothing about all.
20:13:28 <Cale> @where monads
20:13:29 <lambdabot> I know nothing about monads.
20:13:36 <Cale> @google All About Monads
20:13:37 <lambdabot> http://www.nomaware.com/monads/
20:13:38 <lambdabot> Title: "Nomaware | Monads"
20:13:38 <lispy> @where nothing
20:13:38 <lambdabot> I know nothing about nothing.
20:13:53 <Cale> @where everything
20:13:54 <lambdabot> I know nothing about everything.
20:14:00 <lispy> @where anything
20:14:00 <lambdabot> I know nothing about anything.
20:14:13 <Cale> @where myself
20:14:14 <lambdabot> I know nothing about myself.
20:14:15 <lispy> i could do this all day without getting bored :)
20:14:23 <lispy> @where haskell
20:14:24 <lambdabot> http://haskell.org/
20:14:25 <gregarican> @where gangsta rap
20:14:25 <lambdabot> I know nothing about gangsta.
20:16:58 <iron32> Saulzer: Well I have read those but I will try to re parse them hope I get something more out of them this time
20:19:27 <iron32> so times I am tempted just tp performUnsafeIO to rip those values out of the monads but I know that leads to the dark side
20:23:29 <audreyt> there is no dark side if you know what you are doing :)
20:24:10 <audreyt> if you don't need unsafePerformIO, then you can us unsafePerformIO :)
20:24:14 <audreyt> s/us/use/
20:24:23 <audreyt> s/if/iff/
20:24:45 <Cale> I think that unsafePerformIO shouldn't be used if there's any way at all around using it. It really harms one's ability to reason about code.
20:26:05 <iron32> Well I guess I am of the opinion if I have to use unsafePerformIO to make a useful program then I might as well be using an imperative language
20:26:43 <iron32> So meanwhile the struggle continues Monads: 1 Me : 0
20:27:48 <SamB> you might as well use Prolog
20:28:14 * SamB makes fun of prolog's IO
20:29:27 <iron32> Well I do eventually want to learn logic programming but I was thinking of Using Mercury instead of Prolog
20:30:03 <iron32> but thats only after I got a hang of this FP thing
20:30:43 <Saulzar> Pays to figure out one thing at a time
20:32:21 <iron32> Hmm I wonder if anyone has writting an entertaining song about monads
20:32:34 <Korollary> shizzle mah monad
20:32:49 <Cale> iron32: did you read my Monads As Containers and Introduction to IO articles?
20:33:52 <SamB> @google doctor suess parser
20:33:55 <lambdabot> http://www.worldwindcentral.com/chat/irclog/worldwind/2005-03-27.log
20:34:00 <Cale> seuss
20:34:02 <SamB> @google doctor seuss parser
20:34:04 <lambdabot> http://www.willamette.edu/~fruehr/haskell/seuss.html
20:34:04 <lambdabot> Title: "Dr. Seuss on Parser Monads"
20:34:08 <iron32> Yes I have and I undertand how to dosome things with monads just having a hard time figuriong out how to make a function that transfrom an IO Int into a Monad MyRecord
20:34:22 <Cale> iron32: Monad MyRecord?
20:34:46 <SamB> iron32: how about some poetry?
20:35:13 <iron32> I want to take an IO Int and stuff into a record and then rturn a that record wrap up in a MOnad
20:35:27 <iron32> SamB: well monad poetry sounds cool
20:35:30 <SamB> not exactly about monads, but it *is* entertaining
20:35:45 <iron32> or other poetry
20:36:13 <Cale> iron32: well, an IO Int is just a computation which when run, will give you an Int, you can treat it like any other value, pack it into a data structure or whatever, but it's not an Int
20:36:40 <SamB> actually, it is about a monad
20:37:00 <SamB> but for some reason it doesn't use a newtype the way it ought to these days -- what with the Monad class and all
20:37:10 <iron32> SamB: Well I am definitely like to read it then
20:37:26 <SamB> its not at all long ;-)
20:37:29 <Saulzar> iron32, x <- myIOInt; return (makeMyRecord x), or ... myIOInt >>= \x -> return (makeMyRecord x)
20:37:51 <Cale> "A parser for things is a function from strings to lists of pairs of things and strings"
20:38:11 <Saulzar> That's just great :)
20:38:28 <SamB> http://www.willamette.edu/~fruehr/haskell/seuss.html
20:38:42 * SamB wants to see if lambdabot did the title thing by filtering itself
20:39:42 <iron32> Cale : I will try your suggestion and see if it works thanks
20:39:44 <Cale> iron32: In order to get a result from an IO computation, you have to run it, and you can only do that from inside another IO computation
20:40:15 <Cale> So if you want to use your IO Int to get hold of an Int, you can do so, but only in the context of defining another IO action
20:40:40 <Cale> Let's say your IO Int is called getInt
20:40:49 <Cale> Then you could write something like:
20:40:59 <Cale> getSquare :: IO Int
20:41:01 <iron32> Cale: I should have taken the blue pill this rabbit hhole goes pretty deep
20:41:08 <Cale> getSquare = do
20:41:12 <Cale>    x <- getInt
20:41:16 <Cale>    return (x^2)
20:41:17 <SamB> iron32: yes, it does go pretty deep
20:41:24 <SamB> but, the white rabbit!
20:42:02 <SamB> gots to follow the white rabbit!
20:42:03 <Cale> It's not that hard, you just have to keep track of the difference between values, and computations which compute them
20:43:03 <iron32> ws :: Int -> IO Stat
20:43:12 <Cale> mhm
20:43:56 <Cale> so we can pass ws a parameter and it'll give us a computation which we can run in an IO do-block in order to get a Stat
20:44:05 <iron32> so I have this function that takes this integer and adds it to a random number which is in a monad IO Int is it posiible to add IO Int to Int
20:44:26 <Cale> fmap (+7) getInt
20:44:31 <Cale> for example
20:44:39 <Cale> which is the same as
20:44:46 <Cale> do x <- getInt
20:44:49 <Cale>   return (x + 7)
20:45:08 <Cale> (should be another space there, but you get the idea)
20:45:35 <iron32> but if I try to take an IO Int called x and an Int called n and do x + n will it work ?
20:46:21 <Cale> no
20:46:28 <Cale> they're not the same type, you can't add them
20:46:39 <Cale> but you can do fmap (+n) x
20:47:06 <Cale> which will form the computation which will run x, then return what x returns, plus n
20:47:15 <iron32> ok cool I am learning the error of my Monad ignorant ways :)
20:48:15 <iron32> will fmap (+7) x return an Int or an IO Int ?
20:48:28 <Cale> that'll be an IO Int
20:48:35 <iron32> doh!
20:48:36 <Cale> because it does IO
20:48:50 <Cale> There's no function of type IO a -> a
20:49:21 <iron32> so I cant use it to popluate an a field in my record which is of type Int 
20:49:46 <iron32> unless of course that field in my record is an IO Int
20:50:20 <Cale> but you can run that computation and use its result to do so
20:51:07 <iron32> so do y <- fmap (+7) x gives me y as an Int ?
20:51:15 <Cale> mhm
20:51:36 <Cale> of course, you're in the midst of defining an IO Something, so it's fine
20:54:58 <iron32> well I am putting me new understanding to work let you know how it goes
20:58:15 <iron32> well my code is still broken here it is
20:58:19 <iron32> ws :: Int -> IO Stat
20:58:19 <iron32> ws n = 
20:58:19 <iron32> 	do
20:58:19 <iron32> 	x <- twoD10
20:58:19 <iron32> 	y <- ( fmap (+n) x)
20:58:19 <iron32> 	return  
20:58:21 <iron32> 		MakeStat 
20:58:23 <iron32> 		{
20:58:25 <iron32> 		name = "WS", 
20:58:27 <iron32> 		bv = y,
20:58:29 <iron32> 		ta = 0,
20:58:31 <iron32> 		at = 0,
20:58:33 <iron32> 		tv = y
20:58:35 <iron32> 		} 
20:59:23 <iron32> it doesn't like y <- ( fmap (+n) x  )
21:04:26 <iron32> cool I think I fixed it
21:07:16 <Cale> what's the type of twoD10?
21:07:43 <Cale> If it's IO Int, then you've already run the IO Int, and you can just use let to define y
21:07:49 <Cale> let y = x + n
21:08:20 <Cale> If it's IO (IO Int), that's when you'd have to use what you have there, or you could apply join
21:09:11 <iron32> Well thanks a bunch Cale I fixed my problem and expanded my undertanding of monads
21:09:23 <iron32> twoD10 is type IO Int
21:10:17 <iron32> Cale you have been a buig help
21:11:06 <Cale> no problem
21:11:49 <iron32> Cale is the Monad master
21:12:06 <Cale> :)
21:12:56 <iron32> well I happy I can finally do something half useful now in haskell :)
21:13:23 <dons> i believe "Lord of the Monad" is the official term
21:13:35 <dons> or possibly, formerly "Monad Wrangler"
21:14:09 <dons> @seen sjannsen
21:14:09 <lambdabot> I haven't seen sjannsen.
21:14:11 <iron32> Hmm well I like MM for Monad Master best myself
21:14:17 <iron32> but the others apply too
21:15:00 <iron32> is it possible to register with lambdabot so it recognizes me ?
21:15:04 <SamB_XP_> is that anything like a Jedi Master?
21:15:12 <Cale> iron32: recognises you?
21:15:21 <Cale> in what way?
21:15:25 <SamB_XP_> @seen iron32 
21:15:26 <lambdabot> iron32 is in #haskell. I last heard iron32 speak 26 seconds ago.
21:15:47 <iron32> well I saw someone get messages for himself from the bot
21:15:55 <SamB_XP_> @tell iron32 he is doing well
21:15:56 <lambdabot> Consider it noted.
21:16:39 <Cale> iron32: talk now :)
21:16:53 <iron32> What should I say ?
21:16:53 <lambdabot> iron32: You have 1 new message. '/msg lambdabot @messages' to read it.
21:17:52 <iron32> cool
21:17:56 <SamB_XP_> nevermind the grammar ;-)
21:19:24 <iron32> well Monad tutorial from an MM and an iirc bot tutorial in one night I scored big tonight :)  
21:19:38 <Cale> hang around :)
21:20:05 <Cale> I learned most of what I know about haskell by hanging around here and absorbing things through osmosis :)
21:20:37 <iron32> Cale: How long you been doing doing FP and Haskell
21:20:55 <Cale> hmm, about 2 years now
21:24:02 <iron32> SamB_XP_:  how about you how long have you benn doing FP and haskell for
21:24:26 <SamB_XP_> iron32: oh, I dunno. a couple years at least...
21:25:14 <RyanT5000> is there a good analog of STL's deque in Haskell?
21:25:46 <RyanT5000> a mutable one, that is
21:26:08 <Cale> One could be written, but there aren't many mutable data structures in the Hierarchy
21:26:12 <iron32> yummy I am about to use my second Higher order function
21:26:13 <RyanT5000> i'm trying to write a message queue with coalescing
21:26:22 <Saulzar> Hmm, maybe Bulat's resizable arrays could suffice there
21:26:24 <SamB_XP_> iron32: only second?
21:26:33 <SamB_XP_> iron32: I find that difficult to believe!
21:26:41 <Cale> RyanT5000: there's Queue
21:26:51 <Cale> but not a double ended one
21:27:10 * SamB_XP_ goes to bed
21:27:29 <iron32> SamB_XP_: Well I mean write my second higher order function really I am just a babe in the woods less then 1 month old in terms of FP and Haskell
21:27:32 <RyanT5000> hm... i just thought of something: maybe i'm doing my coalescing at the wrong time
21:27:48 <RyanT5000> maybe i should be doing it when i dequeue rather than when i enqueue
21:29:33 <Cale> what do you mean by coalescing? Combining adjacent elements somehow?
21:31:20 <iron32> Well good night all, Thanks for all the help
21:31:26 <Cale> 'night
21:32:35 <RyanT5000> Cale, i want to get rid of redundant messages
21:32:47 <RyanT5000> e.g.: MouseMoved + MouseMoved
21:34:40 <RyanT5000> it's true they'll always be adjacent, though
21:35:16 <Saulzar> Maybe you could use a Set with an interesting Ord instance
21:35:19 <RyanT5000> i guess really there's no need for a queue at all: there's already a queue from SDL
21:35:37 <RyanT5000> i'm pulling my messages from some other queue, i can just keep a single lookahead slot
21:35:49 <RyanT5000> since i'll never coalesce more than two messages at once
21:36:16 <RyanT5000> ah, although, sometimes a single message actually expands
21:36:25 <Saulzar> What I've been doing with SDL is just use it to extract all the events and shove them in an immutable structure
21:36:49 <RyanT5000> i think i'm going to use the Edison SimpleQueue
21:38:23 <RyanT5000> although, is lazy (++) just as good as having an efficient rcons?
21:41:16 <Saulzar> I don't think so, but I don't think efficiency for input events is going to matter a jot even if you used an O(n^3) append :)
21:42:06 <RyanT5000> that's true, it's just that i'm thinking if it stalls for a while it'll freeze indefinitely
21:43:00 <RyanT5000> if your efficiency is worse than O(n), then there exists some point at which your message queue gets big enough that draining it of a message takes longer than it takes for a message to accumulate
21:43:12 <RyanT5000> (i worry about details, lol)
21:45:12 <Saulzar> Still, with something like SDL you're adding/removing these events synchronously right?
21:45:37 <RyanT5000> lol only synchronously with the minimum possible stuf
21:45:38 <RyanT5000> f
21:45:42 <RyanT5000> i bolted my own multithreading on
21:45:55 <RyanT5000> i currently have an update thread and a rendering thread
21:46:05 <RyanT5000> which may end up being good enough
21:46:08 <RyanT5000> (i hope)
21:46:08 <Saulzar> I see
21:46:30 <RyanT5000> (well, not counting IO worker threads and such, but they have nothing to do with SDL)
21:52:10 <RyanT5000> heh i'm starting to think that the best abstraction for a GUI is just IO ()
22:12:34 <Saulzar> Certainly seems the most tried and proven, at least.
22:14:39 <RyanT5000> hm... now i'm actually moving away from that idea again
22:14:49 <RyanT5000> pure IO () doesn't lend itself to nesting very well
22:15:19 <RyanT5000> i guess you can do it just by nesting or something
22:15:37 <RyanT5000> s/nesting/passing IO ()'s to run as child guis/
22:15:49 <RyanT5000> that's my cue to go to sleep
22:15:58 <RyanT5000> later all
23:14:14 <dons> ?uptime
23:14:14 <lambdabot> uptime: 5 days, 2 hours, 47 minutes and 52 seconds
