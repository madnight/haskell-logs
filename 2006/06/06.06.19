00:15:09 <cmarcelo> in latest GHC from darcs and the 20060615 snapshot Control.Monad.STM isn't being found by GHC/GHCi even if the .hi exists in the proper place (.. lib/ghc-6.5/imports).. anyone knows what could be happening?
00:29:25 <int-e> libraries/stm/package.conf.in seems to be lacking an entry for Control.Monad.STM
00:29:30 <satan> so, IF statements have to have an ELSE, right? what if you don't want the ELSE to do anything? what does one do?
00:30:15 <psykotic> satan: it has to assign a value to the if expression; what happens if the condition isn'
00:30:21 <psykotic> err, isn't matched
00:30:45 <satan> if i > 0, do this, else do nothing
00:30:46 <Korollary> satan: That's the thing. There is no if-statement; it's an if-expression.
00:31:03 <satan> i see, hmm
00:31:56 <satan> do compound if blocks exist? more than 1 action to be carried out if something is true?
00:32:17 <Lokadin> say, has anyone ever thought oh having a system based on darcs, so it would have an undo feature, where say you could record at a certain point, and then if you do something stupid like delete an assignment you could revert, and if you are certain you wont need anything in your patches you could optimize, i mean sure it would effectively double the space consumption of whichever files you want it to keep track of, but with the amount of hard driv
00:32:44 <Lokadin> er not based on i guess, but a backup system based on darcs
00:32:48 <Cale> satan: 'if-then-else' in Haskell isn't a statement, it's an expression
00:32:50 <Korollary> satan: You can have the branches as complicated as you like (as long as they are well-typed).
00:32:51 <psykotic> satan: you can use a cascade of let's
00:33:26 <satan> ah ok, i'll try something then, thanks guys :)
00:33:36 <Cale> satan: If you're composing actions, you use do, which allows for multiple actions to be carried out in a single block
00:34:01 <Cale> satan: and if you're not, then your question doesn't quite make sense :)
00:34:16 <satan> no, thats it, do eh, ok i'll look it up
00:36:16 <Lokadin> actually now that i think of it, i'm sure lots of people already do that
00:36:50 <Lokadin> it just makes too much sense not to at least do that for your documents lol
00:37:07 * Lokadin goes to set it up for his home directory
00:39:54 <Lokadin> can you add recursively in darcs?
00:40:37 <cmarcelo> int-e: indeed.. but only changing this, make clean;make; make install  in libraries/stm/package.conf.in wasn't enough .. is this something that "demands" a full re-./configure ?
00:41:10 <int-e> cmarcelo: making clean in stm and in driver/ was enough here.
00:41:25 <int-e> cmarcelo: (making clean in driver/ rebuilds the package config file)
00:42:58 <int-e> well, causes it to be rebuilt when you make a make install on the top level
00:44:37 <Itkovian> Lokadin: perhaps you will be better off asking on #darcs
00:45:03 <Itkovian> most of the time people there are responsive, sometimes they are not
00:46:24 <cmarcelo> int-e: worked. thank you. how could we warn ghc||stm people about this?
00:47:10 <Lokadin> Itkovian: thanks :)
00:47:19 <Itkovian> np
00:47:55 <int-e> I'll try sending a patch (it wants to send to libraries@haskell.org - should that worry me?)
00:50:35 <cmarcelo> int-e: ok.. sounds like the right place, probably a mailing list...
00:51:01 <int-e> it's a mailing list. I'm even subscribed to it but I can't remember seeing patches there.
00:51:14 <bringert> int-e: what is the patch for?
00:51:54 <int-e> bringert: solves cmarcelo's problem about Control.Monad.STM not being found (it wasn't exposed in package.conf)
00:54:18 <bringert> ah, hmm. if you can't find out who maintains that module, I guess sending it to libraries@haskell.org would be ok. maybe you can ask what if that's really the way to do it. I'm not sure anyone has thought about it.
00:56:15 <shapr> bringert: How can I make http://www.scannedinavian.com/hope/ forward to a range limited list of entries?
00:56:16 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
00:56:42 <bringert> shapr: for now, hack Module_front.hs
00:57:15 <bringert> shapr: Module_front should be changed so that the redirect is configurable
00:57:27 <bringert> shapr: I also want to add a module for static pages
00:58:18 <shapr> Yeah, I'd like to make static pages too. We need to have more markup first.
00:58:38 <int-e> I wonder where darcs took that email address from. (the module has Maintainer  :  libraries@haskell.org  but does darc look at that?)
00:59:18 <shapr> For dynamic pages, templating could do useful stuff like format a display for a single value and then map that over a collection to display them nicely.
01:03:13 <bringert> shapr: yeah, that's how it works internally now, just that the templates are haskell functions
01:03:40 <Itkovian> shapr: nice blog these days :-)
01:03:46 <Itkovian> is there a feed for it?
01:03:48 <shapr> yes!
01:04:17 <shapr> due to bringert's coding efforts..
01:04:26 <shapr> I just ask for new features :-)
01:05:37 <int-e> does darcs look at cabal files? hmm.
01:09:06 <int-e> because according to the darcs docs, it looks at _darcs/prefs/email (which isn't there) and then prompts for an address (which isn't happening)
01:10:05 <cmarcelo> int-e: change email in cabal and test again.. =)
01:11:23 <int-e> ah, it looks at the actual repository ... http://darcs.haskell.org//packages/stm/_darcs/prefs/email
01:40:07 <tato> anyone use vim for literate haskell? how can I make it so that vim adds a '>' automatically?
02:11:48 <boegel> tato: s/^/> ?
02:12:00 <boegel> that adds a > add the beginning of a line
02:48:17 <kzm> @seen cmarcelo 
02:48:17 <lambdabot> cmarcelo is in #haskell and #perl6. I last heard cmarcelo speak 1 hour, 38 minutes and 12 seconds ago.
02:55:22 <therp> excuse me, can someone give me a pointer how type inference is done in for instance hugs' :type?
02:55:39 <therp> I would be especially interested how these things work for primitive recursive function like foldr.
02:57:04 <roconnor> therp: ``Unification'' is the keyword.
02:57:33 <xerox> `Do you know prolog' is the question.
02:57:39 <therp> roconnor: I stumbled across that term already, but google doesn't give anything useful for type unification 
02:57:45 <therp> xerox: yes I know. 
02:58:12 <roconnor> hmmm
02:58:28 * roconnor looks up wikipedia
03:02:19 <alar> @type init
03:02:20 <lambdabot> forall a. [a] -> [a]
03:02:30 <alar> > init [1.2.3.4]
03:02:31 <lambdabot>  add an instance declaration for (Fractional (a -> b))
03:02:37 <alar> > init [1.2.3,4]
03:02:38 <lambdabot>  add an instance declaration for (Num (a -> c))
03:02:39 <lambdabot>   In the list element: 4
03:02:47 <alar> > init [1,2,3,4]
03:02:49 <lambdabot>  [1,2,3]
03:03:18 <alar> @karma+ lambdabot
03:03:19 <lambdabot> lambdabot's karma raised to 15.
03:16:14 <boegel> @karma boegel
03:16:14 <boegel> @vixen hey you!
03:16:15 <lambdabot> You have a karma of 2
03:16:15 <lambdabot> hiya
03:28:48 <shapr> @yow !
03:28:48 <lambdabot> I am deeply CONCERNED and I want something GOOD for BREAKFAST!
03:31:34 <xerox> Howdy musasabi!
03:33:59 <shapr> musasabi: Have you returned from your long silence?
03:37:00 <basti_> obviously not
04:10:45 * shapr throws lambdas
04:11:03 * dcoutts_ dives to catch
04:11:33 * vegai catches one with his EYE
04:11:37 <shapr> ouch!
04:12:32 <ndm> shapr, how come your blog is not on planet haskell?
04:16:00 <ndm> shapr, also you asked for other flavours of fusion - take a look at hylo fusion
04:16:22 <shapr> ndm: Probably because I haven't asked ibid to add it.
04:16:28 <shapr> ndm: I didn't have a decent rss feed until recently.
04:17:36 <shapr> Is there a one word tag I can use for referential transparency? Purity isn't really specific enough outside of the programming context.
04:18:03 <ndm> pure?
04:18:10 <ndm> thats the usual one...
04:18:50 <shapr> I guess I'll go for referential-transparency
04:19:58 <vegai> ndm: any news on yhc for the past 6 months?
04:20:17 <ndm> vegai: some small news, we have moved to scons, we have ffi, we have hat support
04:20:31 <ndm> but all in the "almost works" stage, none of it is polished and finished yet
04:20:48 <ndm> our lead developer has problems typing at the moment, which is slowing things down :(
04:21:01 <ndm> oh, and we have a google SOC project to rewrite the type checker, no idea how thats going
04:21:18 <vegai> problems typing?
04:21:24 <dcoutts_> ndm, how about that register-based bytecode? that sounded interesting.
04:21:53 <ndm> vegai: yes, medical things, should be temporary though
04:22:19 <ndm> dcoutts_, sadly the 2x speed up was because he was comparing gcc stack vs gcc -O2 register
04:22:27 <ndm> most of the difference coming from the -O2
04:22:34 <shapr> ndm: RSI?
04:22:36 <ndm> its a bit faster, but not massively
04:22:53 <ndm> shapr: no, but similar effect
04:22:56 <dcoutts_> ndm, ah, ok. Ho hum.
04:23:09 <dcoutts_> ndm, it might work better with a jit :-)
04:23:11 * boegel thinks he has RSI in his neck from sitting in a wrong position when working
04:23:14 <ndm> but it could be pushed further, which would probably give a better speed up
04:23:26 <ndm> ultimately, register probably beats stack, it seems
04:23:27 <dcoutts_> a jit would almost certainly prefer register based
04:23:33 <ndm> yes, if we jit, it would
04:23:52 <dcoutts_> why java uses stack based byte code I have no idea
04:23:57 <ndm> but the fact that the register version beat the stack version made tom go and improve the stack version
04:24:05 <ndm> so now they are about hte same
04:24:16 <dcoutts_> ndm, heh, yeah, that's always an interesting effect
04:24:23 <earthy> dcoutts: to facilitate interpretation on register-starved cpu's
04:24:45 <dcoutts_> an alternative makes people go squese more optimisations out of the existing impls
04:24:51 <ndm> it also makes function calls cheaper
04:25:00 <shapr> ibid: Could you add my rss feed to planet.haskell.org ?
04:25:27 <dcoutts_> I suppose so, but java relies on the vm's jit for performance
04:26:39 <ndm> there are also stack processors being designed
04:26:46 <dcoutts_> ndm, seen libjit ?
04:26:48 <dcoutts_> http://www.southern-storm.com.au/libjit.html
04:26:49 <lambdabot> Title: "Southern Storm Software, Pty Ltd"
04:26:55 <ndm> dcoutts_, yes, its bookmarked :)
04:26:59 <dcoutts_> good good
04:27:05 <dcoutts_> what did you think of it?
04:27:09 <ndm> not sure how much work it will be to use though
04:27:24 <ndm> not looked in detail, but it seems that the lazy/strict thing is going to be the hard bit
04:27:28 <dcoutts_> ah
04:30:24 <dcoutts_> ndm, or the alternative might be to improve the ghc ncg's to produce binary output rather than text assembler
04:30:33 <dcoutts_> so we could use them to generate code in memory
04:30:43 <dcoutts_> without needing an assembler
04:31:28 <dcoutts_> ndm, though I guess you'd want a jit in C rather than Haskell so you could put it in the runtime system ?
04:36:34 <hyrax42> hm
04:56:52 <inv> hi all
04:57:54 <inv> ---file c1.hs:
04:57:54 <inv> module Parser (parse) where ...
04:57:54 <inv> module Main (main) whete main = ....
04:57:54 <inv> ---
04:57:54 <inv> $ ghci c1.hs
04:57:54 <inv> c1.hs:99:0: parse error on input `module'
04:57:57 <inv> why ?
04:58:12 <dcoutts_> two modules in one file
04:58:23 <roconnor> rumour has it that ghc only accepts one module per file for some reason.
04:58:25 <inv> impossible ?
04:58:31 <inv> lol :) ok, thx
04:58:38 <dcoutts_> inv, use one file per module
04:58:49 <inv> ok
04:58:53 <inv> runhugs c1.hs
04:58:57 <inv> ERROR "c1.hs":99 - Syntax error in input (unexpected keyword "module"
04:59:01 <inv> the same problem ?
04:59:13 <dcoutts_> yes
04:59:16 <inv> ok, then will split
04:59:17 <inv> thx
04:59:17 <dcoutts_> hugs works the same
04:59:35 <dcoutts_> the Haskell98 standard doesn't specify how modules and files are related
04:59:46 <inv> is the name of the file is the name of the module ? like in ocaml, or not ?
04:59:49 <dcoutts_> but all the implementations take the one module == one file approach
04:59:53 <dcoutts_> yes
05:00:02 <inv> filename=module_name ok
05:00:21 <roconnor> I sometimes find it useful to have a different file name than the module if the module's name is Main.
05:00:27 <dcoutts_> yes, to be able to find the file for a module, they need to be named the same
05:00:50 <dcoutts_> which means that for Main it's ok to use any name, since it seldom needs to be imported
05:00:59 <roconnor> ;)
05:01:23 <inv> I mean, should I write module parser where ... in parser.hs file or not ?
05:01:31 <roconnor> in Parser.hs
05:01:36 <inv> y
05:01:44 <roconnor> with a captial P.
05:02:29 <inv> or does it mean if the fun1 a b = a+b in file Parser.hs. its in module Parser.hs ? there is no module Parser (fun1) where ... in Parser.hs
05:05:21 <waern> I think it would be nice to have several modules in one file
05:06:28 <shapr> Yeah, sometimes it would. It could also be confusing though.
05:09:31 * shapr quickly writes a blog entry about that...
05:09:48 <inv> :)
05:10:21 <shapr> privet inv, are you new to Haskell?
05:10:59 <inv> y, have been leaning it long week :)
05:12:08 <shapr> inv: How do you like it so far?
05:12:37 * shapr finds a long lost CD hiding in the wrong case under the cd that does fit in that case!
05:13:02 <inv> APL syntax is better :), but its not static typed, so I'd like to write smth like APL on haskell
05:13:49 <shapr> Hm, I'd like to read a longer document that supports that point.
05:14:06 <inv> :)
05:14:18 <inv> www.kx.com
05:19:36 <alar> inv: are you one of readers of "ru_declarative"?
05:20:15 <inv> y
05:20:40 <inv> how do you check it ? :)
05:20:41 <alar> :)
05:20:57 <alar> Kx is extremely popular there :)
05:21:28 <inv> h.m. I found that Kx is not popular there
05:21:36 <inv> like anythere
05:22:08 <alar> someone said there are ~20 people around the world that truely know it :)
05:22:20 <alar> more than half of them live in NY
05:22:23 <inv> 2 of them is the creators :)
05:22:59 <inv> but its really nice 
05:23:16 <ndm> dcoutts_, i'm not sure GHC's ncg would be that useful - i suspect its rather specliased for GHC - while libjit is designed to be reuseable
05:23:22 <inv> for example flip matrix: ,/
05:23:39 <shapr> inv: Kx.com doesn't say much about APL's syntax.
05:23:42 <beelsebob_> mornin all
05:23:56 <inv> kx.com/a/examples
05:23:57 <shapr> waern: What do you think? http://www.scannedinavian.com/hope/entry/36
05:24:11 <shapr> inv: 404
05:24:23 <inv> http://kx.com/a/k/examples/
05:24:25 <lambdabot> Title: "Index of /a/k/examples"
05:24:55 <inv> there is help inside Kx, just enter \
05:24:56 <shapr> Oh, is this the K language that's related to J, etc?
05:24:59 <dcoutts_> ndm, mm, yeah I guess so
05:25:04 <inv> shapr, y
05:25:11 <shapr> Ah yes, I'm somewhat familiar with K.
05:25:18 <inv> it splited from J
05:25:20 <shapr> iirc, I wanted to learn it, but it's commercial only.
05:25:24 <shapr> Or is that J?
05:25:45 <shapr> Stevan Apter does a lot of K, and I like his approach to programming.
05:25:50 <shapr> I like Joy myself.
05:26:07 <inv> J have more features from APL
05:26:23 <inv> but I found Kx is more simple to use
05:26:23 <shapr> I think this sort of syntax is great for input of code, but painful for reading.
05:26:29 <alar> Joy? Is it stack-functional language?
05:26:35 <shapr> alar: Yes it is.
05:26:40 <inv> shapr, I don't think so
05:26:50 <alar> then it is just restricted PostScript
05:26:52 <shapr> alar: DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
05:27:08 <shapr> Not really, Joy is a purely functional concatenative stack based language.
05:27:14 <inv> shapr, if smone see languages first time, it doesn't matter is it K ot pascal
05:27:24 <alar> PostScript can do anything Joy can
05:27:29 <alar> but not the reverse
05:27:34 <shapr> Well sure, turing completeness says they're equivalent.
05:27:35 <inv> alar, Kx is very close to scheme
05:27:48 <inv> PostScript is FORTH language
05:28:26 <shapr> inv: I've taught programming to a few newbies, and I do think that distinctions like whitespace and capitalization make it easier to pick up the language.
05:28:26 <alar> shapr: if you restrict some features of PostScript, you'll get Joy
05:28:50 <shapr> Let's discuss this sometime when I'm not about to move to another city.
05:28:57 <alar> =)
05:29:02 <inv> :)
05:29:19 <inv> there Joy realisation on Kx
05:29:36 <shapr> inv: http://www.nsl.com/
05:29:38 <lambdabot> Title: "no stinking loops"
05:29:47 <inv> Y :)
05:31:52 <inv> lists are suxx to. use data List a =  a List | End :)
05:32:21 <inv> ups Elem a List | End
05:35:21 <inv> bb all
05:41:07 <damg> hmm, let mean nums = (sum nums) / (length nums) << what's wrong with the function? ghc tells me  No instance for (Fractional Int)
05:41:25 <xerox> ?type sum
05:41:26 <lambdabot> forall a. (Num a) => [a] -> a
05:41:28 <xerox> ?type length
05:41:29 <lambdabot> forall a. [a] -> Int
05:41:31 <xerox> ?type (/)
05:41:33 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:41:49 <xerox> (/) takes two fractionals. length returns an Int, which is not a fractional.
05:41:54 <xerox> ?type genericLength
05:41:55 <lambdabot> forall i b. (Num i) => [b] -> i
05:42:00 <pejo> shapr, moving to stockholm?
05:42:21 <damg> is it possible to "cast" Int to Frac?
05:42:22 <xerox> This function, instead, will return a Num, which can be a Fractional so to fit your context.
05:42:22 <shapr> pejo: How did you guess?
05:42:30 <damg> xerox, ah, thanks :)
05:42:33 <int-e> @type fromIntegral . length
05:42:34 <xerox> You're welcome.
05:42:34 <lambdabot> forall b a. (Num b) => [a] -> b
05:43:14 <shapr> xerox: Wargh, your new css is striking.
05:43:24 <xerox> Hah.
05:43:35 <xerox> ?babel en it striking
05:43:37 <lambdabot>  colpire
05:43:38 <shapr> Hey, you need to upgrade your hope install so you can tag your blog entries.
05:43:45 <xerox> Yes, I should, I just saw yours.
05:43:50 <pejo> shapr, you talked about it a couple of weeks (months?) ago, asking about salary. :-)
05:44:22 <shapr> That didn't work out when migrationsverket told me I can only be employed by the company I own on an egen foretag permit.
05:45:11 <pejo> shapr, hm. You need citizenship to be employed?
05:54:04 <ibid> shapr: what's the uri?
06:08:08 <ndm> ibid: http://www.scannedinavian.com/hope/entry
06:08:49 <ibid> ndm: thanks, but this needs to be done without proxies :)
06:45:09 <shapr> ibid: http://www.scannedinavian.com/hope/entry?type=rss and you probably want to limit the number of entries displayed with by adding &count=10 or whatever number takes your fancy.
06:46:05 <shapr> pejo: Nah, I just need a permit type that allows me to be employed, and egen foretag isn't it.
06:47:38 <psykotic> shapr: do you have a degree?
06:47:51 <shapr> Nope
06:48:06 <shapr> Sadly, I was more interested in learning than in getting a degree.
06:48:28 <psykotic> i started working before i finished all of my degree so i've had to wrestle with immigration issues too.
06:48:30 <shapr> So I spent a bunch of years in college taking classes like archeology and stuff.
06:49:05 <shapr> How many times have you wrestled? I'd guess that US permits are challenging?
06:49:48 <psykotic> yeah. the south korean one was a little tough too and i think i only got it because our CEO apparently knows one of the heads of the IT ministry :)
06:49:51 <ibid> shapr: added
06:49:53 <shapr> ibid: In case that wasn't clear, the total uri would be http://www.scannedinavian.com/hope/entry?type=rss&count=10
06:50:21 <ibid> shapr: i don't think limiting makes sense, unless there are thousands or more entries
06:50:45 <shapr> Um, there will be hundreds soon enough.
06:51:18 <shapr> The feed should probably limit itself.
06:51:19 <ibid> i'd use count=100 rather :)
06:51:22 <ibid> yes
06:52:03 <ibid> or =30
06:52:40 <shapr> The planet.haskell aggregator seems to only grab entries from today. That's sensible.
06:54:10 <ibid> it has a limit for new feeds
06:54:15 <ibid> two, apparently :)
06:54:41 <shapr> Once again, sensible.
06:54:53 <xerox> It doesn't parse links :-\
06:55:18 <shapr> xerox: You mean hope doesn't do markup in the RSS feed yet?
06:55:35 <xerox> Ah, you mean it is a hope issue.
06:55:48 <shapr> Yup
06:56:58 <xerox> http://recycledknowledge.blogspot.com/2006/06/futbol-en-masse.html
06:57:00 <lambdabot> Title: "Recycled Knowledge: Futbol en masse"
06:57:40 <shapr> John Cowan is a cool guy :-)
06:58:23 <shapr> He shows up on #swhack sometimes.
06:58:30 <xerox> Yup. And #scheme.
07:22:19 <norpan> i wanna be a cool guy too
07:31:04 <hyrax42> ready to feel really stupid...
07:31:15 <hyrax42> but
07:31:36 <hyrax42> pairs x1:x2:xs = (x1,x2):pairs xs
07:31:44 <hyrax42> the pattern is apparentlyh  aparse error :/
07:32:00 <vegai> enclose in parentheses, hyrax42 
07:32:05 <dcoutts_> pairs (x1:x2:xs) = (x1,x2):pairs xs
07:32:07 <hyrax42> !!
07:32:18 <hyrax42> I tried (x1):(x2):(xs)
07:32:19 <hyrax42> ha
07:32:34 <dcoutts_> it's because it's one argument
07:32:35 <hyrax42> yup, there's that stupidity feeling
07:32:39 <hyrax42> thanks
07:32:41 <vegai> naah
07:33:04 <shapr> hyrax42: We all started at the beginning.
07:33:19 <hyrax42> fair enough
07:33:20 <hyrax42> :)
07:33:24 <hyrax42> oh and while I'm here
07:33:44 <hyrax42> are arrows other than a -> b used much?
07:34:00 <dcoutts_> hyrax42, not quite sure what you mean
07:34:17 <hyrax42> well aren't arrows more general than just the function type?
07:34:38 * hyrax42 might be confused
07:34:43 <dcoutts_> ah, you mean arrows as in the generalisation of monads etc
07:34:45 <shapr> Do you mean the two characters dash and greater than, or do you mean the arrows that are more general than monads?
07:34:52 <hyrax42> yeah
07:34:53 <hyrax42> oh sorry, the computation guys
07:35:02 <dcoutts_> they're not used that much I'd say
07:35:10 <hyrax42> ohh yeah that was disgustingly ambiguous
07:35:12 <shapr> They should be, imho :-)
07:35:35 <vegai> yeah, the first step isn't steep enough yet :P
07:35:36 <shapr> Arrow-style parsers can be significantly more efficient than monadic parsers.
07:35:54 <hyrax42> hmm
07:35:57 <Philippa> that reminds me: anyone else here think of do and mdo as generalisations of (ML-style) let and letrec?
07:36:23 <hyrax42> mdo?
07:36:24 <shapr> Rather than go off into a long description of where arrows would be better than monads, I shall instead unicycle and suggest that you read Paterson's "Fun of Programming" chapter.
07:36:45 <hyrax42> ok shapr, will bookmark it
07:37:01 <shapr> Philippa: I think the paper uses let and letrec to describe mdo.
07:37:07 <shapr> I was looking at that a coupla weeks ago.
07:37:51 <Philippa> hyrax42: an extension of do that allows recursive bindings (much as in haskell's let)
07:38:02 <shapr> It says something along the lines of "You can do all the same stuff without mdo, but it ends being ugly and painful."
07:38:13 * Philippa nods
07:38:23 <Philippa> it desugars into fixpoint stuff
07:38:35 <shapr> I've thought about writing a blog post comparing the tetration operator to the letrec, mdo, and proc sequence.
07:38:39 <hyrax42> hm
07:38:44 <alar> what are arrow-style parsers?
07:39:24 <dcoutts_> alar, parser combinator libs that use a combinator that is not >>=, but an arrow-style combinator
07:39:54 <shapr> Philippa: Do you think that letrec (value), mdo (monad), and proc (arrow) can usefully be compared to tetration?
07:39:55 <dcoutts_> @type (>>=)
07:39:57 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
07:40:03 <alar> dcoutts: where are they described?
07:40:44 <shapr> hei ohub 
07:40:57 <Philippa> shapr: tetration?
07:41:01 <shapr> Philippa: http://en.wikipedia.org/wiki/Tetration
07:41:03 <lambdabot> Title: "Tetration - Wikipedia, the free encyclopedia"
07:41:21 <dcoutts_> @google Deterministic error-correcting combinator parsers
07:41:29 <lambdabot> http://citeseer.ist.psu.edu/swierstra96deterministic.html
07:41:29 <lambdabot> Title: "Deterministic, Error-Correcting Combinator Parsers - Swierstra, Duponcheel (Rese ..."
07:41:31 <dcoutts_> alar, ^^
07:41:35 <alar> thanks
07:41:50 <Philippa> I don't think it's a particularly useful comparison compared to, say, the numeric tower
07:41:51 <shapr> Philippa: Seems to me that the sequence of add,mul,exp,tet is like letrec,mdo,proc
07:41:51 <dcoutts_> alar, also see the original arrows paper
07:42:03 <shapr> Philippa: What's the numeric tower?
07:42:12 <Philippa> Scheme's collection of numeric types
07:42:28 <dcoutts_> alar, "Generalising Monads to Arrows"
07:42:51 <norpan> i wonder what lambdabot will do if the title of an url is the url itself
07:42:56 <norpan> will it loop?
07:43:06 <shapr> alar: I wrote an unfinished introduction here - http://www.haskell.org/tmrwiki/ArrowsIntroduction
07:43:09 <lambdabot> Title: "ArrowsIntroduction - TmrWiki"
07:43:10 <hyrax42> dcoutts_: that is wadler, right?
07:43:11 <alar> norpan: test it :)
07:43:17 <int-e> norpan: no it won't loop
07:43:23 <dcoutts_> hyrax42, yep
07:43:32 <hyrax42> prolific man, it seems
07:43:35 <dcoutts_> hyrax42, oh, no, it's  John Hughes
07:43:38 <shapr> Hughes did that.
07:43:46 <norpan> http://norpan.org/~martin/test.html
07:43:48 <lambdabot> Title: "http://norpan.org/~martin/test.html"
07:43:53 <norpan> ok, good :)
07:43:57 <hyrax42> who wrote the original monads paper then
07:43:59 <shapr> Wadler got monads into Haskell.
07:44:03 <hyrax42> monads in fp, that is
07:44:06 <hyrax42> ok
07:44:14 <shapr> But arrows are a superset of monads.
07:44:54 <shapr> There was a cool arrows & category theory paper that Wouter Swierstra pointed at recently...
07:45:27 <shapr> Instead of using the weak freud categories explanation of arrows, it had something very much simpler. I think it was one step away from functor or something.
07:45:43 <shapr> Weak freyd categories?
07:45:46 * shapr doesn't remember.
07:45:51 <norpan> freydian slip
07:45:54 * shapr laughs
07:46:00 <shapr> Anyway, my unicycle calls...
07:46:32 <Philippa> shapr: sooner or later, the supersetting thing'll just lead you to categories and a sudden "ohshit, that doesn't really tell us much interesting, does it?"
07:46:53 <shapr> I think it just shows the fractal essence of nature.
07:46:59 <shapr> Group theory is everywhere.
07:47:16 <shapr> As someone once said "It's turtles all the way down."
07:47:28 <psykotic> s/turtles/sets/ :)
07:48:18 <psykotic> i remember an expository paper i read in high school called "it's set all the way down: building everything starting from the empty set" or something like that
07:48:25 <psykotic> err, sets all the way down
07:49:30 <Philippa> I guess here it's more that it's categories all the way up
07:49:34 <psykotic> i'm sure lawvere must have written a rebuttal with diagrams in place of sets, yes
07:57:59 <satan> @hoogle Eq
07:58:00 <lambdabot> Prelude.Eq :: class Eq a
07:58:00 <lambdabot> Prelude.EQ :: Ordering
07:58:00 <lambdabot> Text.PrettyPrint.HughesPJ.equals :: Doc
08:01:21 <satan> how do I add (Eq a) to a type signature so it can compile?
08:02:19 <gds> You mean something like:  f :: (Eq a) => a -> a  ?
08:02:58 * gds hopes he remembered the syntax right...
08:03:09 <mux> yeah that's it
08:03:15 <mux> though you could avoid the parenthesis there
08:03:31 <mux> they're only useful when you have several type classes to note
08:03:45 <satan> i'm not sure, i'm new to this :(
08:03:56 <satan> but let me try that
08:04:29 <mux> if you have, say, "a -> b" as a type signature and you need to say that a is in the Eq type class, you just change it to "Eq a => a -> b"
08:04:43 <mux> pretty straightforward
08:05:00 <beelsebob_> ye
08:05:12 <satan> ah i see, and what if it's a list? i'm writing a function that checks if one list is a subset of another, so i have isSubset :: [a] -> [a] -> Bool
08:05:23 <mux> satan: the same
08:05:33 <satan> followed by isSubset (x:xs) a = elem x a
08:05:38 <mux> here you want to tell that the a's contained in your list are in the Eq type class
08:05:42 <satan> and thats where it complains about the Eq
08:05:46 <mux> so: Eq a => [a] -> [a] -> Bool
08:05:48 <satan> oh i see
08:06:30 <satan> hmm i get a warning about Pattern matches overlapping when i do that
08:06:36 <beelsebob_> SamB: 
08:06:44 <beelsebob_> satan: by the sounds of it you want Data.Set
08:06:45 <mux> when you're not sure, it's often useful to just omit the type signature, and then load your file in hugs/ghci, and see what types it infers
08:07:01 <satan> ah good point, mux, thanks
08:07:17 <satan> Data.Set ? built in data type?
08:07:22 <beelsebob_> satan: yep
08:07:38 <satan> ok
08:08:11 <satan> so i have these 2 lines that give me the Pattern Math Overlapping error: isSubset (x:xs) a = elem x a and isSubset (x:xs) a = isSubset xs a
08:08:27 <satan> how do i put them on the same line, as one does in Prolog or whatever
08:08:32 <beelsebob_> yes... that's because the paterns are the same
08:08:37 <satan> right
08:09:05 <beelsebob_> isSubset [] a = True
08:09:05 <beelsebob_> isSubset (x:xs) a = x `elem a && isSubset xs a
08:09:10 <beelsebob_> oops, missed a `
08:09:30 <beelsebob_> isSubset (x:xs) a = x `elem` a && xs `isSubset` a
08:10:10 <satan> i see, and the backquotes do what exactly
08:10:21 <beelsebob_> they make a function infix
08:10:30 <beelsebob_> a `f` b == f a b
08:10:41 <satan> ah ok, thanks beelsebob_ :)
08:10:54 <satan> ok so is that necessary or did you just choose to write it that way?
08:11:40 <beelsebob_> no, I just chose to
08:11:46 <mux> it's not necessary, it's just that some functions look more intuitive written in infix mdoe
08:11:50 <beelsebob_> it makes more sense to read it as x is an element of a
08:11:54 <beelsebob_> x `elem` a
08:12:12 <satan> ahh gotcha, awesome
08:12:31 <mux> similarly, you can use operators in prefix mode by enclosing them in parenthesis
08:12:35 <mux> > (+) 2 2
08:12:36 <lambdabot>  4
08:12:48 <beelsebob_> > 'a' `elem` "jam"
08:12:49 <lambdabot>  True
08:12:52 <mux> useful for stuff such as:
08:13:01 <mux> > map (+1) [1..5]
08:13:02 <lambdabot>  [2,3,4,5,6]
08:13:27 <beelsebob_> mux: well, no, a section is different from writing something prefix
08:13:39 <beelsebob_> e.g. map (1+) [1..5] is valid
08:13:42 <mux> you mean (+1) is just partial application here?
08:13:48 <beelsebob_> yes
08:13:51 <mux> ah, okay
08:14:07 <mux> I thought it was also putting it in prefix mode because I assumed partial application wouldn't work this way
08:14:09 <Kasperle> mux: maybe you meant ((+) 1)?
08:14:25 <mux> Kasperle: I just need a better example :)
08:14:29 <satan> ok i'll remember that, thanks guys
08:14:33 <mux> it's not really useful in that case
08:14:36 <beelsebob_> > map ('a' `elem`) ["jam","bob","willies"]
08:14:38 <lambdabot>  [True,False,False]
08:15:11 <qwr> partial application works in both ways... :)
08:15:19 <qwr> > (++ "a") "b"
08:15:20 <lambdabot>  "ba"
08:15:27 <qwr> > ("a" ++) "b"
08:15:29 <lambdabot>  "ab"
08:17:40 <Dino_> @type elem
08:17:41 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:17:42 <norpan> > (-1) 2
08:17:43 <lambdabot>  add an instance declaration for (Num (t -> a))
08:17:43 <lambdabot>   In the definition of `cs...
08:17:53 <Dino_> @type (elem 'a')
08:17:53 <beelsebob_> > (~1) 2
08:17:54 <lambdabot>  Pattern syntax in expression context: ~1
08:17:54 <lambdabot> [Char] -> Bool
08:18:08 <beelsebob_> > ((-)1) 2
08:18:09 <lambdabot>  -1
08:18:13 <beelsebob_> negation is the exception
08:18:20 <beelsebob_> this will be fixed in Haskell'
08:18:31 <qwr> > (- (1)) 2
08:18:32 <lambdabot>  add an instance declaration for (Num (t -> a))
08:18:32 <lambdabot>   In the definition of `xw...
08:18:34 <beelsebob_> or so I'm lead to believe
08:18:59 <Stinger_> Haskell' is the next iteration of Haskell?
08:19:01 <qwr> it treats it like unary negation
08:19:09 <beelsebob_> Stinger_: yes
08:19:16 <Stinger_> whens that supposed to be coming out? 
08:19:26 <beelsebob_> uh... not sure... when they stop arguing
08:19:36 <beelsebob_> I'll ask Simon next time I see him
08:21:30 <satan> isn't := the assignment operator? as in, f x = if x > 0 then x := x + 5 else x := x + 20
08:21:37 <beelsebob_> no
08:21:45 <beelsebob_> there is no assignment in Haskell
08:21:50 <satan> oh
08:21:50 <beelsebob_> it's a functional longuage
08:21:53 <beelsebob_> language*
08:21:59 <dcoutts_> JaffaCake, I was wondering if I could find out the number of bytes of overhead in allocating a pinned MutableByteArray (via making a new ForeignPtr) so that we can pick our block size so we get exactly a page rather than a page + 1 bytes or something silly.
08:22:02 <int-e> Stinger_: There's a proposed timeline here: http://hackage.haskell.org/trac/haskell-prime/wiki/TimeLine
08:22:04 <lambdabot> Title: "TimeLine - Haskell Prime - Trac"
08:22:18 <dcoutts_> JaffaCake, so I'd expect it'd be something like 4k - n for some small n.
08:22:19 <Stinger_> better not be too soon
08:22:30 <Stinger_> still have to learn it all :P
08:22:53 <Stinger_> egads, end of the year? better get cracking : /
08:33:28 <crm-114> hello
08:35:32 <ndm> crm-114: hello
08:44:51 <shapr> @tell dons I think a wiki and a blog are the same thing, except that the wiki is darcs get --partial
08:44:52 <lambdabot> Consider it noted.
08:45:27 <shapr> Yay, haskell.org is getting an OS upgrade!
08:45:56 <shapr> I wonder if I can persuade them to use debian/unstable.
08:46:51 <alar> shapr: your arrow article is too incomplete
08:47:07 <alar> it says arrows are better than monads for parsing
08:47:24 <alar> but does not formulate what are they better in
08:48:53 <Philippa> yeah, that's important. I actually use the ArrowApply aspect of Parsec, and you don't get the same wins for ArrowApply
09:27:40 <TwigEther> 
10:02:58 <cmarcelo> kzm: pong
10:19:28 <mux> wow, darcs output for annotate is bad
10:53:51 <dmhouse> BOO!
10:53:56 <dmhouse> It's uncannily quiet in her.
10:53:57 <dmhouse> *here
10:54:13 <norpan> indeed
10:54:14 <sieni> typo of the week
10:54:17 <dcoutts_> @yarr!
10:54:17 <lambdabot> Aye
10:54:39 <dcoutts_> hmm, even lambdabot is being a little quiet
10:54:44 <dmhouse> Hehe.
10:54:46 <dcoutts_> @yarr!
10:54:46 <lambdabot> I'll crush ye barnacles!
10:54:47 <alar> @vixen on
10:54:47 <lambdabot> tell me more about yourself.
10:54:51 <dcoutts_> that's better
10:54:58 <alar> @vixen-on
10:54:58 <lambdabot> Not enough privileges
10:55:16 <dmhouse> That shouldn't be a priveleged command.
10:55:26 <dcoutts_> I think it probably should :-)
10:55:35 <dcoutts_> it can be a bit annoying
10:55:49 <dmhouse> Well, if anyone can turn it off...
10:55:52 <dcoutts_> @vixen wouldn't you agree?
10:55:53 <lambdabot> who's to say?
10:55:59 <dcoutts_> @vixen quite.
10:56:00 <lambdabot> are you being sincere?
10:56:11 <alar> @vixen yeah,really
10:56:11 <lambdabot> yup
10:56:16 <dmhouse> What time is the England game on, anyone?
10:56:23 * dcoutts_ has no idea
10:56:37 * dcoutts_ is glad he doesn't have a TV
10:56:41 * dmhouse likes something on the TV in the background while he Haskells.
10:58:16 * alar thinks he needs no TV while having PC
10:59:44 <dmhouse> @tell shapr very cool ideas re one-button unit tests with haskell-mode. Thanks!
10:59:44 <lambdabot> Consider it noted.
11:00:48 <apfelmus> so we're so bored to even bother discussing boring TV. does lambdabot like TV?
11:01:13 <alar> @vixen do you like TV?
11:01:14 <lambdabot> yah, i like
11:01:46 <apfelmus> @vixen TV is really boring, isn't it?
11:01:47 <lambdabot> really!
11:02:12 <apfelmus> @vixen so you really like boring stuff?
11:02:13 <lambdabot> yeah, i like
11:02:27 <dmhouse> Oh, it's on tomorrow.
11:02:36 * aik does not have a TV either
11:02:38 * dmhouse has to keep track of days better.
11:02:55 <aik> just to say something
11:03:09 <dmhouse> Hmm. Not sure I could do without a TV. I'd miss my Channel 5 dramas.
11:03:26 <dmhouse> And Friday night comedy.
11:07:33 <bringert_> @vixen why don't you ever misspell stuff?
11:07:39 <lambdabot> because i don't see the need to
11:08:18 <bringert> @vixen talar du svenska?
11:08:19 <lambdabot> isn't it obvious?
11:08:32 <koffein> what does this vixen-thing use at the back end?
11:08:38 <koffein> simple markov-chains?
11:08:42 <alar> swedish vixen
11:08:52 <bringert> koffein: a lot of regular expressions
11:09:08 <koffein> ugly :D
11:09:18 <bringert> it chooses a random one of all the regexps that match, and each regexp has a canned response
11:09:37 <koffein> ok
11:09:59 <dmhouse> @vixen What do you think about Visual Basic?
11:09:59 <lambdabot> Can you really catch syphilis from Visual Basic?
11:10:48 <alar> @vixen it demands on how hard you try
11:10:49 <lambdabot> tell me a joke.. I like men that makes me laugh
11:10:56 <bringert> koffein: here are the regexps: http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Vixen/VixenState.hs
11:11:23 <BCoppens> impressive :o
11:11:54 <koffein> umm
11:12:00 <koffein> lots of work
11:12:00 <LordBrain> hey... i have a line of code which is not acting the way i expect..
11:12:06 <LordBrain> liftM (take 4) (liftM repeat getLine)
11:12:40 <LordBrain> i'm expecting to have it ask for a line of input four times.
11:13:05 <LordBrain> instead..
11:13:10 <dfeuer> mmm....  that seems a bit off.  
11:13:11 <bringert> LordBrain: liftM repeat getLine will get one line, then repeat that infinitely
11:13:12 <LordBrain> it seems to only ask once
11:13:20 <LordBrain> ooooooh
11:13:20 <dmhouse> replicateM 4 getLine
11:13:50 <bringert> or sequence (take 4 $ repeat getLine)
11:13:51 <dmhouse> or sequence . take 4 $ repeat getLine
11:13:52 <LordBrain> yeah i knew about replicateM.. i just wanted to understand this
11:14:04 <dmhouse> or sequence (replicate 4 getLine)
11:14:09 <monochrom> sequence (replicate 4 getLine)
11:14:10 <LordBrain> i made a takeWhileM
11:14:16 <monochrom> darn
11:14:19 <monochrom> Is there replicateM ?
11:14:25 <dmhouse> monochrom: Yep.
11:14:26 <xerox__> ?type replicateM
11:14:32 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
11:14:44 <monochrom> @hoogle replicateM
11:14:45 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
11:14:45 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
11:14:48 <LordBrain> yeah, you need Control.Monad
11:15:00 <monochrom> Darn, has been looking for it for several years :)
11:15:02 <LordBrain> i dont think it is in the nonheirarchical version... 
11:15:18 <dmhouse> LordBrain: Why would you be using the nonhierarchial version?
11:15:23 <monochrom> No, certainly not, but ok.
11:15:26 <dmhouse> monochrom: make good friends with :b.
11:15:35 <LordBrain> well i'm just fiddling around
11:15:39 <dmhouse> (Being the GHCi command, not a smiley.)
11:16:16 <LordBrain> anyway
11:20:58 <LordBrain> i created a takeWhileM :: Monad a => (b -> a Bool) -> [b] -> a [b]  using recursion.. but when i use it on repeat getLine, i end up with twice as many getLines as i intended..
11:22:02 <LordBrain> i'm thinking this may be because its accessing the same element of the list twice.. thereby calling getLine twice..
11:22:59 <LordBrain> hmmm
11:25:48 <psykotic> heh. the wikipedia entry for graph reduction says "Outermost graph reduction is referred to as lazy evaluation and innermost graph reduction is referred to as eager evaluation."
11:26:00 <psykotic> isn't innermost graph reduction, uh, rather pointless?
11:26:12 <psykotic> not much of a general graph, is it
11:26:21 <LordBrain> here's takeWhileM code: http://pastebin.com/718994
11:27:17 <LordBrain> the test2 function there, always seems to run twice as many getLine's as i want
11:28:52 <LordBrain> there's two versions of takeWhile there.. you could just look at the remarked one.. they both have the same exact effect.
11:28:54 <dmhouse> LordBrain: could you paste it to paste.lisp.org, by any chance? pastebin.com is sloooow.
11:29:05 <LordBrain> sure
11:29:11 <yip> yip
11:30:31 <lisppaste2> LordBrain pasted "takeWhileM" at http://paste.lisp.org/display/21443
11:31:13 <dmhouse> LordBrain: And which one are we looking at?
11:31:51 <LordBrain> well, you can look at the one which is commented out, its simpler probably... 
11:32:10 <LordBrain> they both have the same bug
11:32:19 <LordBrain> actually... 
11:32:25 <LordBrain> test2 might be where the bug is
11:32:31 <dmhouse> Could you give an example of where you're using it?
11:32:37 <LordBrain> test2
11:32:39 <dmhouse> Oh, you did, sorry.
11:32:41 <LordBrain> i just run test2
11:33:27 <LordBrain> what i want to happen, is for it to keep asking for lines of input until i give it a "q"
11:33:30 <dmhouse> I wouldn't expect you to use >>= to throw it into sequence.
11:33:43 <dmhouse> Try sequence (takeWhileM ...) instead.
11:33:47 <dmhouse> @type sequence
11:33:49 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
11:34:05 <dmhouse> Oh, wait.
11:34:11 <LordBrain> yeah, but i have m [m a]
11:34:15 <LordBrain> hehe
11:34:16 <dmhouse> No, in fact you wouldn't need to sequence it at all.
11:34:22 <LordBrain> hmm
11:34:29 <LordBrain> show me what your test2 would look like
11:34:37 <dmhouse> @type join
11:34:38 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:34:50 <dmhouse> join stuff = stuff >>= id
11:34:55 <LordBrain> i just sequenced it to help me print it
11:35:02 <psykotic> @type unfoldM
11:35:03 <lambdabot> Not in scope: `unfoldM'
11:35:21 <LordBrain> hmm
11:35:40 <dmhouse> If you sequence it, that'll have the effect of evaluating every action again, I think.
11:35:59 <dmhouse> Oh, hang on.
11:36:13 <dmhouse> You're doing this in a really convulated fashion :)
11:36:14 <LordBrain> what i do is i give the hugs prompt: test2>>=print
11:36:30 <LordBrain> well
11:36:35 <nomeata> Hi. I get internal error: ASSERTION FAILED: file GC.c, line 1352
11:36:39 <nomeata> What can I do to debug this further?
11:36:40 <LordBrain> i wanted takeWhileM to be analogous to filterM
11:37:00 <dmhouse> Your takeWhileM looks fine.
11:37:06 <LordBrain> ok
11:37:14 <dmhouse> Hmm.
11:37:17 <LordBrain> its just i cant use it the way i want to with getLine?
11:37:30 <LordBrain> what happens is i get extra getLines
11:37:42 <dmhouse> Well, I'd probably do takeWhileM :: (a -> Bool) -> [m a] -> m [a] or something.
11:37:58 <LordBrain> if i give test2 four strings and then "q", it will ask me for four more before quitting, and disregarding the original four.
11:38:00 <dmhouse> @type takeWhile
11:38:01 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:38:26 <LordBrain> @type takeWhileM
11:38:27 <lambdabot> Not in scope: `takeWhileM'
11:38:36 <LordBrain> oops
11:38:37 <dmhouse> LordBrain: Yep, it's the use of sequence that's causing the problem.
11:38:40 <LordBrain> @type filterM
11:38:42 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:38:48 <LordBrain> ooooh
11:38:51 <LordBrain> hmmm
11:39:22 <dmhouse> takeWhileM :: (a -> m Bool) -> [a] -> m [a], then, and I wouldn't use it here.
11:39:42 <nomeata> I get this error only when using the binary compiled with ghc -debug. ghci works fine.
11:41:24 <dmhouse> LordBrain: I don't think takeWhileM is the right direction to generalise to.
11:41:53 <LordBrain> i just so wanted it to be analogous to filterM
11:43:50 <LordBrain> i got rid of sequence.. now i have test2:: IO [IO String].. it has the right number of getLines, but  i dont know how to print the returned values..
11:44:17 <dmhouse> LordBrain: perhaps write a sequenceWhile. Then it'd be sequenceWhile (/="q") (repeat getLine)
11:44:29 <dmhouse> That might be quite a useful function.
11:44:39 <LordBrain> hmmm good idea
11:44:48 <LordBrain> except
11:44:57 <LordBrain> hmmm
11:45:08 <LordBrain> nvm.. thats good
11:45:44 <LordBrain> that way i get over my hangup about having the same signature as filterM
11:45:52 <LordBrain> hehe
11:46:52 <LordBrain> still.. my test2 works.. it just returns IO [IO String]... how can I see the original strings without messing it up?
11:47:03 <LordBrain> is there no way?
11:47:34 <dmhouse> It wouldn't do that if you wrote sequenceWhile.
11:47:46 <dmhouse> sequenceWhile :: (a -> Bool) -> [m a] -> m [a]
11:52:09 <dmhouse> bringert: ping
11:52:20 <bringert> dmhouse: pong
11:53:04 <dmhouse> bringert: Sorry to be a pain, but I'm having great difficulties getting Network.HTTP to send a POST request and wondered if you've had any success doing anything like that?
11:53:25 <dmhouse> I'm pretty sure I've formulated the Requets properly, and included all the headers that the server would want.
11:54:01 <bringert> dmhouse: yes, the client in HaXR, my Haskell XML-RPC interface, does uses POST
11:54:13 <bringert> s/uses/use/
11:54:19 <dmhouse> Hrm, it's probably my code then.
11:54:44 <bringert> though I haven't used it for a while, maybe some patch broke it
11:54:55 <dmhouse> Could be.
11:55:18 <dmhouse> I'll perhaps try some simpler programs to see what's up.
11:55:43 <bringert> HaXR's post code is at the bottom of http://darcs.haskell.org/xmlrpc/Network/XmlRpc/Client.hs
11:58:25 <dmhouse> bringert: Do you assemble the POST content yourself?
11:59:11 <bringert> dmhouse: the request body is the second argument to 'post'
11:59:27 <bringert> it's some XML that HaXR generates
11:59:41 <dmhouse> bringert: that's what I'm looking at. It seems to come from renderCall which apparently spits out XML
11:59:44 <dmhouse> Righ.t
11:59:58 <dmhouse> So no var=val&foo=bar style POSTs?
12:00:09 <bringert> ah
12:00:15 <bringert> that's nothing to do with HTTP
12:01:05 <bringert> that's application/x-www-form-urlencoded
12:01:08 <dmhouse> True. But it _is_ the most common form of POST :) Well, if your stuff works, at least that means I'm definately at fault.
12:01:25 <bringert> right
12:01:28 <dmhouse> Yep, and I'm sending that as a ContentType.
12:01:31 <bringert> :-)
12:01:47 <bringert> so what's happening?
12:02:23 <dmhouse> I'll explain a bit more.
12:02:56 <dmhouse> I'm essentially writing a program to download an entire Wikibook.
12:03:47 <dmhouse> It needs to send a POST request to http://en.wikibooks.org/w/index.php?title=Special:Export&action=submit with a list of pages to export.
12:04:22 <dmhouse> What it seems to be doing is either sending a GET, or not sending enough data to convince the Wikibooks server to give me the exported pages.
12:04:33 <dmhouse> Using command line curl works fine.
12:09:04 <lisppaste2> dmhouse pasted "Network.HTTP problems" at http://paste.lisp.org/display/21447
12:09:20 <dmhouse> That's my source. The Request I'm sending is sourceRequest, near the top.
12:10:05 <bringert> dmhouse: hmm, can you capture the request with netcat?
12:10:25 <dmhouse> Sure. How do I do that?
12:10:28 <dmhouse> :)
12:11:13 <bringert> first make sure netcat is installed
12:11:18 <bringert> man nc
12:11:53 <dmhouse> Yep. It is.
12:12:28 <bringert> then run "nc -l -p 12345"
12:12:43 <bringert> this will listen to port 12345 and print whatever it receives to stdout
12:13:12 <bringert> then (in another terminal) run your program and have it use localhost:12345 as the server
12:14:56 <dmhouse> Woah! Hang on, it started working spontaneously.
12:15:10 <bringert> haha
12:15:14 <dmhouse> I think I made a change late last night in this area, perhaps that fixed it.
12:15:43 <dmhouse> bringert: Sorry for wasting your time! :( And thanks for the nc tip, I'll remember that for the future.
12:15:53 <dmhouse> I feel obliged so submit some Network.HTTP patches now.
12:16:02 <bringert> :-)
12:24:02 <dmhouse> Okay, generl question: What would be the best way of taking a 240KB XML input, and extracting all the contents of the <text /> tags?
12:24:07 <dmhouse> JRegex segfaults. :)
12:26:32 <bringert> maybe HaXML?
12:26:48 <bringert> if the input is well-formed XML
12:27:05 <dmhouse> Should be. Has it been tested on big inputs?
12:27:26 <bringert> I don't think 240 KB should be a problem
12:27:41 <dmhouse> Seems to be for JRegex, hence my question. :)
12:27:59 <bringert> true
12:28:38 <bringert> it's weird that it would crash on something that small
12:28:42 <norpan> any sax parser would do it
12:28:47 <norpan> there are plenty
12:28:52 <bringert> I'd report that to the maintainer
12:29:13 <bringert> dmhouse: do you want a haskell solution, or just any solution?
12:29:32 <dmhouse> Haskell.
12:29:48 <dmhouse> grep is cheating. :)
12:30:06 <bringert> norpan: are there any Haskell SAX implementations?
12:30:21 <dmhouse> Right, let's give HaXml a go
12:30:25 <dmhouse> @where HaXml
12:30:26 <lambdabot> http://haskell.org/HaXml
12:30:55 <norpan> bringert: not sure, but there are plenty in other languages
12:35:00 <Heffalump> which is the recommended SQL binding these days, hsql or hdbc?
12:36:35 <bringert> Heffalump: HSQL is more mature in some ways, and supports more RDBMSs, though I think HDBC has a cleaner interface and is easier to build
12:36:59 <norpan> i think the general answer is that you need to find out which one best suits your needs
12:37:12 <bringert> I don't think that HDBC has a mysql interface yet
12:37:51 <bringert> HDBC doesn't work that well as a HaskellDB back-end yet, because of some date-parsing issues
12:39:02 <Heffalump> ok, ta
12:42:01 <alar> @seeen shapr
12:42:02 <lambdabot> shapr is in #scannedinavian, #Haskell.se, #haskell and #ScannedInAvian. I last heard shapr speak 3 hours, 56 minutes and 5 seconds ago.
14:22:43 <Igloo> Any cabal people about?
14:23:04 * dcoutts puts his cabal release manager hat on
14:24:31 <Igloo> dcoutts: OK, http://urchin.cipe/~ian/cabal.txt contains a patch I had to apply to GHC 6.4.1 and the corresponding code in GHC 6.4.2
14:25:08 <Igloo> Oh, I've just noticed I misread an exeExtension as exeName, hang on a tick
14:26:26 <dcoutts> urchin.cipe is not accessable
14:26:38 <Igloo> dcoutts: OK, the code doesn't look insane now, but I'm still not sure if the problem that the patch fixed is fixed in the new code. Do you happen to know?
14:26:45 <Igloo> Sorry, http://urchin.cearth.li/~ian/cabal.txt
14:26:49 <Igloo> Gah
14:26:53 <Igloo> http://urchin.earth.li/~ian/cabal.txt
14:27:00 <dcoutts> yep
14:27:07 * dcoutts looks
14:27:56 <dcoutts> Igloo, so you're installing what into where?
14:29:36 <Igloo> dcoutts: I'm not familiar with this code
14:31:04 <dcoutts> Igloo, the current code is here: http://darcs.haskell.org/packages/Cabal/Distribution/Simple/GHC.hs
14:31:21 <dcoutts> it's using (buildPref `joinFileName` e `joinFileName` exeName)
14:31:34 <dcoutts> where exeName = e `joinFileExt` exeExtension
14:32:06 <dcoutts> and 'e' comes from the exe part of the pkg_descr
14:32:31 <dcoutts> so looks like the old code I think
14:33:05 <dcoutts> you're adding in an extra hsSourceDir
14:33:10 <Igloo> It's identical to the 6.4.2 code isn't it?
14:33:59 <dcoutts> Igloo, I reccomend you darcs send the patch with as much of an explanation as you know of
14:34:23 <Igloo> And I have a mail from Ross saying the HEAD code was fine (then) so presumably it's still OK
14:34:26 <Igloo> Thanks
14:34:55 <dcoutts> huh? ok as in you don't need the patch?
14:35:02 <bolrod> dons: ping
14:35:42 <Igloo> yes
14:36:20 * Igloo will double check the bug doesn't occur once I've built it, but all signs point to it having been fixed differently
14:36:58 <dcoutts> Igloo, ok
14:37:26 <dcoutts> Igloo, but in general feel free to just darcs send cabal patches with a brief explanation/justification
14:37:37 <dcoutts> they go to the cabal-devel list where we can review them
14:38:00 <Igloo> dcoutts: I already sent this one to libraries@ (before c-d existed)
14:38:06 <dcoutts> ah ok
14:47:43 <aFlag> Is there a implementation of a tree for haskell that will let me work with it like I was working with a dictionary? So I'm able to extract an item of a certain index and include a item on a certain index?
14:48:58 <norpan> Data.Map
14:49:18 <norpan> @doc data.map
14:49:19 <lambdabot> data.map not available
14:49:19 <aFlag> thanks
14:49:24 <norpan> @doc Data.Map
14:49:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
15:01:06 <damg> i wonder how I could simulate a while/do-while while working with monads ...
15:06:58 <aFlag> i've seen code that do that
15:09:44 <damg> well, my problem is that I need to work with hGetBuf to read binary file. As long as read_bytes is not 0, it should append read bytes into an array and proceed reading ;)
15:10:56 <Lemmih> damg: Recurse?
15:11:51 <damg> ah, dammit, ill never learn it to provide a state variable as parameter to simulate a while () :)
15:17:12 <Philippa> it's a shame there's no unfoldM, this'd be a good example of one
15:27:07 <beelsebob_> @hoogle Integral b => [a] -> b -> [a]
15:27:08 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
15:27:09 <lambdabot> List.genericTake :: Integral a => a -> [b] -> [b]
15:27:09 <lambdabot> Data.List.genericDrop :: Integral i => i -> [a] -> [a]
15:47:42 <dcoutts> anyone ever got helium running on x86-64 ?
15:50:33 <bringert> shapr: PING
15:50:58 <bringert> xerox__: PING
16:02:42 <urz> hello
16:03:05 <AtnNn> hi
16:03:18 <urz> i notice there are two SDL bindings.  Graphics.UI.SDL and Multimedia.SDL.  Not sure which i want to use
16:03:19 <aFlag> hell
16:03:19 <aFlag> o
16:03:26 <vincenz> :/
16:04:17 <urz> Multimedia.SDL seems to work with ghc-pkg.  Since i'm not using dpkg to install it on debian, i'd like it to use a /usr/local/ branch for its files.  I can't tell if it will or not.  
16:04:55 <urz> there is no package.conf in /usr/local/...
16:05:28 <urz> What do i need to do?
16:08:35 <urz> any advocates for either SDL binding?
16:09:27 <Lemmih> I like the Graphics.UI.SDL one. (:
16:10:18 <urz> it's documentation claims its not portable due to ghc extensions.  The Multimedia.SDL documentation claims portability
16:10:59 <urz> but then Multimedia.SDL's README seems very ghc centric and the author doesnt vouch for other systems
16:11:27 <Lemmih> I've tested hsSDL with both GHC and hugs.
16:12:23 <urz> Another difference i think is that Multimedia.SDL has some opengl support whereas that seems to be on the todo list for Graphics.UI.SDL.
16:12:45 <Lemmih> It's marked as portable: http://darcs.haskell.org/~lemmih/hsSDL/doc/Core/Graphics.UI.SDL.Video.html
16:13:21 <Lemmih> urz: Are you looking at some old version of hsSDL?
16:13:53 <urz> i was looking at a tarball on sourceforge
16:13:58 <Lemmih> Or perhaps it isn't the sdl binding that I authored.
16:14:28 <urz> hsdl-0.0.5
16:14:44 <urz> heh, that'd be something if you authored yet another distinct from those too
16:15:01 <urz> just make my decision harder why dont ya
16:15:51 <Lemmih> My binding is the newest.
16:16:19 <urz> http://sourceforge.net/project/showfiles.php?group_id=134056
16:16:20 <lambdabot> Title: "SourceForge.net: Files"
16:17:15 <urz> that link is the Graphics.UI.SDL that im talking about
16:17:50 <Lemmih> Mine's better, IMHO.
16:17:51 <urz> http://homepages.nildram.co.uk/~ahey/HLibs/Multimedia.SDL.Core/  -- and this one is the Multimedia.SDL
16:18:11 <urz> is the Graphics.UI.SDL one i posted yours?
16:18:34 <Lemmih> Nope.
16:18:40 <urz> neither are yours?
16:18:52 <Lemmih> Mine's at http://darcs.haskell.org/~lemmih/hsSDL/
16:18:54 <lambdabot> Title: "Index of /~lemmih/hsSDL"
16:19:49 <urz> did you know about all these others?
16:19:54 <Lemmih> Yes.
16:20:02 <Lemmih> (they suck, imho)
16:20:09 <urz> why's that?
16:20:38 <Lemmih> They're either incomplete, poorly documented or non-portable.
16:20:43 <urz> you dont happen to know of any GGI bindings btw?
16:20:59 <Lemmih> I don't even know what GGI is.
16:21:08 <urz> general graphics interface
16:21:19 <urz> an SDL-like library
16:21:32 <urz> older than sdl
16:21:47 <Lemmih> V.E.R.A. told me that much. Is it Windows specific?
16:21:52 <urz> no
16:21:57 <urz> its only recently supporting windows
16:22:15 <urz> its cross platform
16:22:42 <urz> just as portable as SDL and i've had better luck with it in using the framebuffer without x
16:22:59 <Lemmih> Is it written in C?
16:23:03 <urz> yes
16:23:55 <Lemmih> Great. Writing bindings to C libraries is a joy in Haskell.
16:24:02 <urz> it's backend targets are seperate modules that plug in to it.  So you can compile your program against GGI and then run it with either the x backend or the framebuffer backend or what have you without recompiling
16:24:30 <urz> is that sarcasm?
16:24:43 <urz> i've never looked at the ffi to haskell
16:25:00 <Lemmih> No, I mean it. Haskell's FFI is one of the best I've ever seen.
16:25:13 <urz> wow
16:25:47 <cayl> FFI?
16:25:55 <urz> i wrote bindings for some ocaml and for some schemes
16:26:02 <Lemmih> cayl: Foreign Function Interface.
16:26:33 <cayl> Lemmih, thanks.
16:27:01 <urz> i ask about ggi bindings because i want to port a program i wrote in c++ into haskell and it used ggi and i was going to use sdl as a substitute since ggi is apparently unavailable (i assumed the ffi would be hell of course also)
16:28:56 <bringert> what's with all the people asking homework-looking questions on haskell-cafe?
16:29:22 <bringert> anyone know what university that's from?
16:30:46 <urz> your SDL bindings share the same hierachicial name as that other.  Is the interface compatible?
16:30:50 <Lemmih> urz: I'd recommend using an SDL binding if you can. Tackling the FFI can be daunting.
16:31:10 <urz> ya
16:31:25 <urz> i dont want to get into the FFI
16:31:28 <urz> right now
16:31:29 <urz> heh
16:32:22 <Lemmih> urz: I don't think so. It would be purely by coincidence if it was.
16:32:53 <Excedrin> is there a way to pass CFLAGS into Cabal?
16:33:36 <dcoutts> Excedrin, what would you expect it to do?
16:34:07 <bringert> Excedrin: you mean other than setting the environment variable?
16:34:27 <dcoutts> is it for when compiling C files or extra options to pass to gcc when compiling haskell code?
16:34:35 <Excedrin> it doesn't find the includes (in /usr/include) which is kinda strange
16:35:47 <dcoutts> Excedrin, this is for compiling .hs files with ghc I presume
16:35:59 <urz> Lemmih: do you use ghc-pkg for installing the bindings?
16:36:36 <bringert> Excedrin: maybe you can try setting CPATH, it works for me
16:36:37 <Lemmih> urz: I use Cabal.
16:36:44 <bringert> export CPATH=/usr/include
16:36:45 <Excedrin> dcoutts: I guess it's cpphs, I'm just attempting to build Lemmih's SDL wrapper
16:36:57 <Excedrin> bringert: it apparently ignores that
16:37:21 <bringert> ah, cpphs
16:37:23 <vincenz> re
16:37:24 <dcoutts> Excedrin, ah, cpphs may not have the same default include dirs, ghc uses gcc -E which looks in /usr/include
16:37:39 <urz> hmm.  your darcs README says the bindings are for libSDL >= 1.2.8 where I have 1.2.7 installed. 
16:38:16 <Lemmih> urz: I've only tested it with 1.2.8.
16:38:31 <urz> shall i test with 1.2.7 then?
16:39:00 <Lemmih> That would be neat.
16:39:05 <Excedrin> so, how do you get cpphs to use a particular include directory?
16:41:27 <Excedrin> oic, SDL.cabal needed editing
16:42:01 <Lemmih> Excedrin: How so?
16:42:28 <Lemmih> Excedrin: The configure script should get the right flags from 'sdl-config'.
16:45:36 <urz> will it install for hugs?
16:45:43 <urz> as well as ghc
16:46:41 <Lemmih> Yes.
16:47:24 <Excedrin> I used the instructions from README, which doesn't say anything about running configure (as opposed to Setup.lhs configure)
16:48:05 <dcoutts> Setup.lhs configure will run configure so long as it exists and is executable
16:48:45 <dcoutts> the problem is usually that people use darcs get without --set-executable-scripts
16:49:10 <dcoutts> and so configure is not executable
16:51:43 <Pseudonym> Apparently they thought it sufficiently likely that someone would need it that they don't bother to wait for an ambulance.
16:51:51 <Pseudonym> Anyway.
16:52:54 <Pseudonym> I was sitting next to the national boxing coach, who is the customer for this project.
16:53:05 <Pseudonym> So I know him fairly well by nowe.
16:53:07 <Pseudonym> now
16:53:15 <Pseudonym> So I was getting some real expert commentary.
16:53:37 <Pseudonym> The thing I found the most interesting was you could see how "clean" a fight was.
16:53:57 <Pseudonym> The first fight was the least clean.  That was the one that took place in the foyer between two rival boxing clubs, but that one was broken up pretty quickly.
16:54:20 <Pseudonym> As for the official fights, they started off with beginners.
16:54:32 <Pseudonym> Boxers for whom it was, like, their first or second fight.
16:54:33 <bringert> Pseudonym: we're missing some context here
16:54:39 <Pseudonym> Sorry?
16:54:57 <Pseudonym> Errr... where did I come in?
16:54:57 <bringert> did you start this in another channel, or did I miss something?
16:55:00 <Pseudonym> I did.
16:55:02 <Pseudonym> Crap.
16:55:24 <Pseudonym> Sorry, I was telling my boxing story.
16:56:22 <Pseudonym> Those who were on #haskell-blah yesterday have heard this story.
16:56:41 <Pseudonym> But it's about my current career writing software for sport.
16:56:44 <urz> Lemmih: typo report.  
16:56:45 <urz> src/GFX/SDL-gfx.cabal:License-File: LISENCE
16:56:45 <urz> src/Mixer/SDL-mixer.cabal:License-File: LISENCE
16:57:02 <Lemmih> urz: Send a patch? (:
16:57:31 <urz> heh
17:02:30 <urz> ok
17:02:35 <urz> to your gmail?
17:03:44 <urz> does darcs automate that?
17:04:31 <urz> darcs should have a submit-patch command
17:04:44 <aFlag> it does, doesn't it?
17:04:48 <urz> i dont know
17:05:04 <urz> i mean as opposed to an authorized commit
17:05:19 <urz> a submit-patch will send in a patch to be aproved
17:06:16 <dons> darcs send ;)
17:06:53 <urz> really?
17:07:37 <urz> i've never used darcs
17:09:05 <urz> Creating patch to http://darcs.haskell.org/~lemmih/hsSDL/...
17:09:05 <urz> No recorded local changes to send!
17:09:07 <lambdabot> Title: "Index of /~lemmih"
17:09:13 <urz> it says that even though I made changes
17:09:27 <dons> you didn't record them
17:09:28 <dons> darcs whatsnew -s
17:10:31 <urz> ok i did that
17:10:38 <urz> are they recorded now?
17:11:28 <dons> darcs changes | less
17:11:40 <syntaxfree> have you heard about the Earth Sandwich yet?
17:12:49 <satan> is there a built in function in Haskell for calculating combinations of size N of a list, or would I have to do it myself?
17:13:09 <dons> oh, whatsnew just tells you what is new, urz. darcs record will record. darcs changes will list the recorded changes
17:13:16 <dons> chec the docs ;)
17:14:49 <urz> i've been checking the manpage
17:14:50 <satan> ok :)
17:17:45 <lscd> is there a standard haskell library / data type that allows O(1) access to value by keys?
17:17:55 <urz> array
17:18:21 <lscd> that's indexed
17:19:05 <lscd> afaik, I can't use a custom data type to index it (hm. or would implementing Ix allow me to?)
17:19:16 <urz> maybe you could make a hashfunction in order to make your keys instantiate Ix
17:19:36 <urz> im new so i dont really know what im talking about
17:19:39 <urz> heh
17:19:52 <lscd> ahhh; ok, like me then
17:20:05 <norpan> you don't want that, use Data.Map instead :)
17:20:17 <lscd> norpan: but that's O(log n) i thought?
17:20:22 <norpan> yes
17:20:24 <syntaxfree> there should be a Stochastic monad.
17:20:33 <norpan> but log n is not so bad
17:20:34 <urz> there should be a Data.Hashtable
17:20:41 <bringert> urz: there is
17:20:47 <urz> well thats what he wants then
17:20:57 <lscd> norpan: it's not so bad, but i'd really prefer o(1) for what i'm currently doing
17:20:59 <lscd> she
17:21:01 <bringert> it's called Data.HashTable
17:21:07 <norpan> there is Data.HashTable
17:21:13 <norpan> but you want map
17:21:20 <urz> how do you know she wants map?
17:21:42 <norpan> people are obsessed with O(1) but in reality O(log n) is not so bad
17:21:43 <bringert> because Data.HashTable is slow
17:21:52 <bringert> and it needs IO
17:21:57 <lscd> norpan: it depends on what you're doing
17:22:15 <lscd> right now, I'm wanting to cache some values and be able to look them up quickly
17:22:19 <bringert> if comparisons are expensive, Data.Map might not be so good
17:22:35 <norpan> O(log n) is quickly
17:22:39 <norpan> :)
17:22:44 <urz> heh
17:22:47 <lscd> one function, which is only being called from the function i'm wanting to cache the result of, is singlehandly responsible for > 60% of execution time
17:23:23 <norpan> use Data.Map first and if that's not sufficient, tr
17:23:29 <norpan> try something else
17:23:40 <lscd> i came here asking what something else would be
17:23:49 <urz> you dont want a map or hashtable
17:23:50 <norpan> oh, you tried Data.Map already?
17:23:59 <urz> instead you want to memoize the function by wrapping it
17:24:08 <norpan> memoizing the function is good
17:24:19 <bringert> lscd: before resorting to memoization, did you try to change the program so that the function is called fewer times? (I don't know what your program does, but that has helped me a lot of times)
17:24:42 <lscd> I haven't, because I wanted to find if there was a better alternative
17:25:13 <lscd> bringert: that's what caching the values would be for; the nature of the app is such that it needs to be called a lot though, or at least the value that it computes for inputs referenced frequently
17:25:21 <urz> there should be a MEMOIZE pragma
17:25:44 <norpan> and how would that pragma work exa
17:25:46 <norpan> ctl7
17:25:49 <norpan> exactly
17:25:56 <norpan> sorry for my writing
17:26:05 <norpan> my keyboard is pressing the wrong keys
17:26:11 <lscd> there are about 1500^2 inputs to that function with the largest data file i need to work with
17:26:42 <bringert> lscd: is this bioinformatics or something?
17:26:43 <syntaxfree> I still don't quite understand how the "algorithmics" unfolds in Haskell.
17:26:46 <norpan> if you know the function range you can cache them in an awway
17:26:47 <lscd> bringert: naw, AI
17:26:49 <norpan> array
17:26:54 <urz> it'd just give the compiler a hint that it ought to memoize a function or expression
17:27:03 <syntaxfree> I've seen it memoize, but I can't figure out how to predict when it will.
17:27:47 <lscd> norpan: i do; I was thinking of using arrays, but the thing is, with the way my app currently works, I'd need to compute the indexes of a data type in a list to feed those as input to the array, which is o(n); and at that point, i've gotten rid of the advantage of using an array
17:27:57 <syntaxfree> I'm moving most of my stuff to R, anyway.
17:28:40 <syntaxfree> R advertises itself as a statistical package but it's actually a competitor to Matlab, with more natural functional constructs.
17:28:45 <lscd> hm, why? 
17:29:56 <syntaxfree> lscd: was that directed at me?
17:29:58 <lscd> hm. so there's really no O(1) read-only, no-io, non-Ix-keyed standard library data structure for haskell atm?
17:30:01 <lscd> syntaxfree: yeah, sorry
17:30:04 <norpan> lscd: i don't know the specifics of your problem, but remember that haskell is lazy, so constructing things is not always O(n)
17:30:14 <lscd> norpan: sure, but `elem` is
17:30:23 <lscd> construction isn't the problem; that's a one-off
17:30:27 <syntaxfree> lscd: oh, because with Matlab's pseudo-fp constructs you pass function names as strings, which is very odd.
17:30:31 <norpan> `elem`?
17:30:46 <lscd> ehm. index. i'm very short on sleep
17:30:46 <syntaxfree> R just supports functions in the same namespace as variables.
17:30:55 <norpan> index in an array is O(1)
17:30:55 <lscd> syntaxfree: sounds like tcl
17:30:59 <syntaxfree> So you can have functions as arguments, functions that return functions, etc.
17:31:23 <norpan> and very fast too
17:31:31 <bringert> lscd: what would you like to use as keys? I guess only a pure hash table would match those requirements
17:31:35 <lscd> norpan: uhm. getting something by index is, but finding something's index is still o(n)
17:31:43 <lscd> bringert: tuples of a custom data structure
17:31:53 <lscd> and i think so, re: hashtable
17:32:02 <bringert> can't you derive Ix?
17:32:23 <norpan> hashtables are inherently using destructive updates
17:32:28 <norpan> that's why the IO
17:32:50 <lscd> yes, but something i could construct all at once and never update would be ideal here
17:32:56 <syntaxfree> lscd: what kind of data are you dealing with?
17:33:36 <bringert> lscd: do you have a good hash function for your keys?
17:33:46 <urz> you can be naughty and hide the IO with unsafePerformIO
17:33:48 <lscd> bringert: no, though I could write one I guess
17:34:11 * bringert is naughty with unsafePerformIO and Data.HashTable
17:34:19 <norpan> well, once you have constructed the hash table you should be able to wrap lookup in unsafePerformIO
17:34:41 <norpan> but I'd go for Map :)
17:34:55 <bringert> http://www.cs.chalmers.se/Cs/Research/Language-technology/darcs/GF/src/GF/Data/SharedString.hs
17:35:17 <bringert> that's for a different purpose, saving memory by sharing identical strings
17:35:26 <bringert> but it seems to work fine
17:35:27 <norpan> unless comparing elements is very expensive of course
17:36:19 <bringert> one quick and dirty hash function is hashString . show
17:37:14 <bringert> looks like you can derive Ix btw, though the requirements on what you can have in your type are pretty harsh
17:38:10 <lscd> hm. the data type i'm using is just a wrapper around a string and another wrapper around two ints
17:38:28 <bringert> so it's essentially (String,Int,Int)
17:38:30 <bringert> ?
17:38:32 <syntaxfree> so, what would you tell a complete idiot that wants to learn Parsec?
17:38:39 <lscd> be prepared for pain
17:38:48 <lscd> but after the pain, it's actually very nice
17:38:58 <lscd> the official docs are a good reference, and a -crappy- tutorial
17:38:59 <bringert> syntaxfree: it consumes input even when it fails
17:39:06 <lscd> unless you use try
17:39:12 <bringert> yes
17:39:13 <lscd> then it backtracks
17:41:23 <lscd> hm. the idea of mapping ("something" 3 -5.5) into indices seems pretty evil
17:42:26 <bringert> hmm, for the floating-point number you could convert to bytes and hash that
17:42:46 <lscd> no..... hashing it is easy
17:42:51 <lscd> the problem is the 'contiguous' part
17:42:55 <bringert> hehe
17:42:56 <bringert> yep
17:43:00 <lscd> there's no such concept in the data type
17:43:22 <bringert> but you said you had a limited number of them?
17:43:27 <lscd> sure
17:43:31 <bringert> can you change the encoding then?
17:43:46 <lscd> hm. 
17:43:46 <bringert> if there is a small number of them you shouldn't need a float
17:43:51 <urz> if you did make a contiguous index, it'd probably end up being very large and your array would consume a lot of memory
17:44:14 <lscd> hm.  i can go back to a previous idea and insist that they all also be indexed
17:44:16 <bringert> lscd: is the input set statically known?
17:44:29 <lscd> bringert: it's read in from data files at runtime
17:44:48 <bringert> ah, so you would memoize, not precompute?
17:46:06 <lscd> hm. i suppose even precomputing would be possible, since i'll be running the program against the same data more than once, but i think that would be overkill, since i'd need to store and re-read the precomputed stuff
17:46:22 <lscd> but yeah, the idea is to memoize
17:46:51 <lscd> i guess i'll assign ids and use array based on the ids
17:47:03 <bringert> if you can precompute, and you will run the thing lots of times, you could even use Template Haskell to compile the table into the program
17:47:15 <bringert> but that's a bit silly maybe
17:47:40 <lscd> compiling it in is silly, yeah -- i'd like to be able to run it against different data sets without recompiling
17:49:38 <syntaxfree> I'm thinking maybe I need to read some kind of introduction to parser theory.
17:49:54 <syntaxfree> I don't really know how a parser works -- at least beyond regexes.
17:52:26 <lscd> regexes aren't as powerful
17:52:47 <syntaxfree> I know.
17:52:56 <lscd> the basic theory is context free grammars (and equivalently, pushdown automata)
17:52:56 <syntaxfree> I need to munge text beyond regexes.
17:53:41 <lscd> lex and yacc are decent for getting started -- there's a ton of documentation, though they're both somewhat quirky
17:53:57 <lscd> and then there's parsec -- it's mind-exploding, but it works
17:54:17 <syntaxfree> Oh, I need to get past some CS first I guess.
17:54:34 <syntaxfree> my CS background is sorely lacking.
17:55:36 <Pseudonym> syntaxfree, do you want some book suggestions?
17:55:47 <Pseudonym> Harrison's "Introduction to Formal Language Theory" is the best, IMO.
17:56:06 <syntaxfree> Ok!
17:56:09 <syntaxfree> I'll try to get that.
17:56:20 <Pseudonym> Any decent university library will have it.
17:56:34 <Pseudonym> If you want to buy a book, Sudkamp's "Languages and Machines" might be a gentler introduction.
17:56:37 <Pseudonym> And cheaper.
17:56:40 <Pseudonym> And probaly still in print.
17:57:21 <lscd> Harrison's is available used from fairly cheaply on amazon, but i see your point
17:57:32 <Pseudonym> Yeah.
17:57:45 <Pseudonym> Actually, I'm tempted to pick up one of those cheap copies.
17:57:50 <Korollary> buy it
17:57:56 * Korollary snickers
17:58:05 <Pseudonym> It's a very good book.
17:58:12 <lscd> what's especially good about it?
17:58:23 <Pseudonym> It covers a lot of ground that other books don't.
17:58:40 <lscd> such as?
17:58:48 <Pseudonym> Almsot 600 pages.
17:58:58 <syntaxfree> For CS books, I have to take the bus and go to the other opposite of the town.
17:59:13 <lscd> uh-huh, but what's in those 600 pages?
17:59:15 <Pseudonym> BTW, it's been a while since I read it.
17:59:21 <Pseudonym> So I can't recall for sure.
17:59:42 <syntaxfree> the CS course is there. Economics department's best shot at computing books are manuals on statistical simulations.
17:59:43 <Pseudonym> Oh, lots of stuff.  Like in a standard text, you probably won't find out about van Dyck grammars.
17:59:57 <Pseudonym> Which are in a theoretical sense, "universal" context free grammars.
18:00:06 <Pseudonym> "Universal" in the category theory sense.
18:00:33 <Korollary> Pseudonym: speaking of this, how is space complexity defined for LC?
18:00:42 <Pseudonym> I don't know.
18:00:54 <Pseudonym> All the complexity classes I know are based on Turing Machines.
18:01:24 <Korollary> I googled to no avail myself
18:01:27 <Pseudonym> However, you can fairly directly emulate a TM on LC in the sense that the intermediate lambda expressions use space proportional to the TM tape size.
18:01:30 <bringert> syntaxfree: for a quick parsing intro, there are plenty of compiler course slide sets online. E.g. http://www.cs.chalmers.se/Cs/Grundutb/Kurser/komp/current/lectures/ccc03.html
18:01:38 <Pseudonym> Which of course you probably know, but I thoguht I'd point it out.l
18:01:52 <syntaxfree> bringert: thanks!
18:02:36 <bringert> syntaxfree: I'm the teaching assistant on that course, feel free to ask questions or point out problems so that we can fix them
18:02:43 <Pseudonym> Oh, one other very good book is "LR Parsing: Theory and Practice" by Nigel Chapman.
18:02:53 <Pseudonym> Whom I had a very interesting email conversation with once.
18:02:55 <syntaxfree> :)
18:02:56 <syntaxfree> thanks.
18:03:04 <Pseudonym> But that's specifically LR Parsing.
18:03:18 <Pseudonym> I'm not sure you'd need a copy of that, though.
18:03:31 <Pseudonym> Oh, the description in the dragon book isn't bad either.
18:03:49 <Pseudonym> But I never really understood LR parsing until I read Chapman's book.
18:04:11 <bringert> syntaxfree: those slides are somewhat specialized for our compilers course, for which you can find all the slides here: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/komp/current/lectures/lectures.html
18:04:50 <bringert> this course is rather back-end heavy, so there is not much focus on the front-end
18:05:24 <syntaxfree> bringert: nice.
18:05:36 * syntaxfree is an economist.
18:05:39 <bringert> syntaxfree: maybe this course is more appropriate for learning about parsing: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/progs/notes.html
18:05:42 <lambdabot> Title: "Programming Languages"
18:05:46 <Pseudonym> Another very useful thing to do is go to Google Groups, and search for all articles on comp.compilers by Mark Hopkins.
18:06:07 <Pseudonym> There's some pretty fascinating stuff there.
18:06:15 <Pseudonym> Including practical ways to construct LR(k) parsers by hand.
18:06:49 <bringert> syntaxfree: I f you want to learn about programming languages and compilers, you have two complete courses there, I'd recommend starting with the programming languages one
18:07:17 <bringert> complete except for the instructors, lab grading, exams etc.
18:07:24 <Korollary> For some reason, I was absolutely uninterested in parsing. I took the course, but didn't care about it at all.
18:07:25 <bringert> so really it's only lecture notes
18:07:55 <Pseudonym> I've always been fascinated by parsing.
18:08:11 <Pseudonym> One of the thing that fascinates me the most is that people are using such primitive tools.
18:09:03 <Pseudonym> Yacc is basically unchanged in the last 20 years.
18:09:14 <Korollary> Pseudonym: People that don't even use flex/bison etc. and write horrible parsers by hand fascinate me even more.
18:09:37 <Pseudonym> In fact, it's one of the few parts of a modern compiler that hasn't changed since the dragon book was written.
18:09:56 <Pseudonym> Nowadays compilers use SSA form, bottom-up code generation, colouring register allocation, cache-specific optimisations...
18:10:01 <Pseudonym> None of which is in the dragon book.
18:10:20 <Pseudonym> Oh, superscalar code scheduling.
18:10:24 <Pseudonym> Also not in the dragon book.
18:10:34 <Pseudonym> The lexer/parser are about the only things that haven't changed.
18:10:53 <Korollary> was the dragon book meant to have such an extensive coverage?
18:10:54 <bringert> and the x86 instruction set
18:11:08 <bringert> though I guess the dragon book doesn't use x86
18:11:14 <Pseudonym> Correct.
18:11:14 <bringert> can't remember
18:11:24 <Pseudonym> The dragon book was a pretty good introduction to the state of the art at the time.
18:11:34 <Pseudonym> No, it wasn't comprehensive.
18:11:40 <Pseudonym> But the stuff I'm talking about wasn't used then.
18:11:44 <Korollary> right
18:11:55 <Pseudonym> You have to remember, the dragon book is over twenty years old.
18:11:58 <Korollary> good ol' years of sucky compilers
18:12:17 <Pseudonym> That's a bit unfair.
18:12:26 <Pseudonym> Compilers have had to keep up with architecture changes.
18:12:45 <Pseudonym> A lot of the stuff is only important because of superscalar and RISC CPUs.
18:13:01 <Pseudonym> Or changes in cache design.
18:13:41 <Pseudonym> Even the x86 these days is really a RISC CPU which just happens to have a CISC API.
18:14:00 <Korollary> they've been like that for a decade iirc
18:14:05 <Pseudonym> Right.
18:14:10 <Pseudonym> But all since the dragon book.
18:14:11 <jer> more than a decade now
18:14:46 <Korollary> yes. the existence of the dragon book just proves how new the field is. All the then-state-of-the-art stuff fits into an intro course today.
18:14:58 <Pseudonym> When the dragon book came out, everyone was interested in creating fast code for the VAX or the M68k.
18:15:21 <jer> in the x86 line, the last cpu that was truely cisc at its core was the cyrix m2
18:15:35 <syntaxfree> I love ultranew fields. Lots of low-hanging fruit.
18:15:48 <Pseudonym> Nowadays its' SPARC or x86_64.  Maybe the IA64, I suppose.
18:15:58 <syntaxfree> I have to find me an ultra subethafield that I can actually manage to enjoy.
18:16:13 <jer> Pseudonym, vliw architectures are the next big thing (mostly embedded devices though)
18:16:18 <Pseudonym> There's still plenty of MIPS around, but that's usually for low-powered devices.
18:16:26 <jer> ia64 isn't exactly the best vliw architecture (infact, its one of the shittier ones)
18:16:30 <Korollary> Pseudonym: I suppose there ought to be people interested in getting performance out of embedded cpus, too
18:16:37 <Pseudonym> Yes, there are.
18:16:53 <Pseudonym> But really, embedded CPUs are either highly specialised or older instruction sets.
18:16:56 <Korollary> 3d gfx on your cellphone. Tee hee.
18:17:10 <Pseudonym> So a GPU might be highly specialised.
18:17:20 <Pseudonym> But a microcontroller will be an old-style instruction set.
18:17:32 <Korollary> That's right. There's also Cg, etc.
18:17:35 <Pseudonym> MIPS, PIC, AVR, something like that.
18:18:07 <syntaxfree> my cellphone has a version of Block Out.
18:18:10 <Pseudonym> Right.  The languages for these highly-specialised CPUs tend not to be general-purpose languages.
18:18:16 <syntaxfree> That's a form of 2.5D I guess though.
18:18:18 <Pseudonym> I say this as someone who wrote a RenderMan SL compiler once.
18:18:26 <Pseudonym> Actually, I wrote about 2.5 SL compilers.
18:18:29 <syntaxfree> http://en.wikipedia.org/wiki/Block_out
18:18:29 <dfeuer> Is there any way for a compiler to take advantage of the fact that x86 is implemented on RISC?
18:18:34 <Pseudonym> The 0.5 was in Haskell, oddly enough.
18:18:43 <Korollary> And there are those who wanna use gfx processors for general purpose stuff
18:18:53 <Pseudonym> No there aren't.
18:18:57 <Pseudonym> Well, there might be.
18:18:59 <Pseudonym> But they're insane.
18:19:14 <Pseudonym> Generally, they want to use GPUs for specific numeric algorithms.
18:19:27 <Pseudonym> Not for general purpose stuff.
18:19:55 <Pseudonym> dfeuer: Good question.  I believe the consensus is "no".
18:19:58 <SamB> well, its general compared to gaming ;-)
18:20:06 <Pseudonym> Better to understand x86 as superscalar rather than RISC.
18:20:06 <dfeuer> eww
18:20:10 <dfeuer> ...
18:20:16 <Pseudonym> Superscalar CISC.
18:20:30 <Pseudonym> The problems are much the same as they would be for RISC.
18:20:30 <dfeuer> Are modern RISCs also superscalar?
18:20:35 <Pseudonym> Sure.
18:21:03 <Korollary> The cisc instruction costs are known a priori, and the translation to risc microcode doesn't change the cost, afaik.
18:21:19 <Pseudonym> Actually, modern compilers often treat x86 CPUs as basically RISC machines with almsot no registers, but under the assumption of decent register renaming.
18:21:32 <dfeuer> register renaming?
18:21:36 <Pseudonym> Yeah.
18:21:39 <dfeuer> What is that?
18:21:54 <bringert> My girlfriend is a at a party at Bill Gates' house at the moment. Should I be afraid?
18:22:10 <Pseudonym> bringert: No, she won't contract polio there.
18:22:13 <Excedrin> bringert: no, tell her to steal stuff
18:22:33 <dfeuer> bringert: yes, she might come home with Windows.
18:22:38 * Pseudonym nods
18:22:40 <Pseudonym> That's true.
18:22:45 <dfeuer> Pseudonym, not polio, but maybe another virus.
18:22:47 <Excedrin> did she have to sign a NDA to enter?
18:23:05 <dfeuer> Pseudonym, what is register renaming?
18:23:08 <Pseudonym> OK.
18:23:10 <Pseudonym> Register renaming.
18:23:34 <Pseudonym> Code sequences often need registers for "temporary" values.
18:23:41 <Pseudonym> Example:
18:23:46 <Pseudonym> a <- b * c + d
18:23:52 <Pseudonym> e <- f * g + h
18:23:56 <Pseudonym> Might be rendered as:
18:23:59 <Pseudonym> t <- b * c
18:24:01 <Pseudonym> a <- t + d
18:24:04 <Pseudonym> t <- f * g
18:24:06 <bringert> I don't think there was an NDA involved, but apparently security is pretty tight. No cameras, bags or purses.
18:24:07 <Pseudonym> e <- t + h
18:24:20 <Pseudonym> Note I used "t" for both temporaries.
18:24:39 <Pseudonym> Modern superscalar CPUs are smart enough to know that the two uses of "t" don't overlap.
18:24:49 <dfeuer> uh-huh....
18:25:16 <Pseudonym> So to get more parallelism, you use different physical registers.
18:25:45 <Pseudonym> A register like eax in the x86 architecture, you see, doesn't necessarily map to a single physical set of latches on the chip.
18:25:51 <Pseudonym> It's just a name.
18:25:57 <dfeuer> So instead of exposing the registers where the compiler can be _really_ smart with them, it tries to make the best of things itself?  How very stupid.
18:26:06 <Pseudonym> Right.
18:26:14 <Korollary> it's not stupid.
18:26:28 <Pseudonym> What's stupid about having more registers than you expose to the programmer>?
18:26:38 <Pseudonym> It's quite smart, especially if you don't want to change the isntruction set.
18:26:58 <dfeuer> That seems to be the only reason.
18:27:04 <woggle> It also makes providing the parallelism much easier.
18:27:14 <Pseudonym> No, it's part of the modern philosophy that the instruction set is an interpreted language.
18:27:39 <dfeuer> Okay...  But it should be the language best suited for high performance, whatever that is.
18:28:04 <Pseudonym> There would also be a drawback to exposing more registers.
18:28:21 <Pseudonym> If there is a function call, or an interrupt/exception, then you would need to save more registers.
18:28:33 <Korollary> With more registers, you could implement the same ISA better than the base implementation.
18:29:10 <Excedrin> sweet, now my cpu is automatically parallelizing my "xchg eax,eax"s!!
18:29:12 <dfeuer> So don't expose them all.  But don't expose so very few.
18:29:25 <Pseudonym> Actually, xchg is another example.
18:29:31 <Pseudonym> That actually goes through a temporary register.
18:29:35 <Pseudonym> That doesn't have a name.
18:29:37 <Excedrin> not that one
18:30:03 <Pseudonym> Look, I agree that the x86 doesn't expose nearly enough registers.
18:30:05 * dfeuer looked just a drop at the x86 instruction set and saw loads of crazy instructions that someone in 198x must've wanted for something or other.
18:30:24 <Korollary> ISA's don't change often. The sad reality.
18:30:32 <Pseudonym> And the SPARC arguably exposes too many.
18:30:46 <dfeuer> How many does it expose?
18:30:55 <Pseudonym> 192, from memory.
18:31:01 <dfeuer> whoa.
18:31:13 <Pseudonym> You can't address them all at the same time.
18:31:18 <Excedrin> there's a lot of cool stuff that's possible in x86 asm that's rarely used by compiler generated code
18:31:22 <Pseudonym> You effecticely only get 24.
18:31:23 <dfeuer> Exactly.
18:31:28 <Pseudonym> Uhm... 32.
18:31:41 <dfeuer> So they're exposed confusingly?
18:31:46 <Pseudonym> The original SPARC designers didn't take massive multithreading into account.
18:31:52 <Pseudonym> And organised the registers in a stack.
18:31:55 <Pseudonym> But that's another rant.
18:31:58 <dfeuer> ..?
18:32:18 <Pseudonym> Anyway.
18:32:22 <woggle> dfeuer: There's an instruction to slide the register window. The intention was to make saving/restore registers for function calls very fast.
18:32:30 <Korollary> ah
18:32:42 <dfeuer> hmm
18:32:49 <Pseudonym> What they didn't count on was that it would make context switch more expensive.
18:33:06 <mwolak> anyone here have experience with Jane st. capital? Their ads on the haskell mailing lists finally got to me :P
18:33:08 <dfeuer> What's the deal with the stack?
18:33:19 <Pseudonym> Which actually isn't so bad in a modern SPARC, because it has a really fast path between L1 and L2 cache.
18:33:29 <Pseudonym> It can dump a register stack to cache very quickly.
18:33:42 <dfeuer> register stack?
18:33:42 <Pseudonym> It's still a strange design quirk.
18:33:46 <Pseudonym> Yup.;
18:33:49 <dfeuer> What is that?
18:33:59 <Pseudonym> OK, the SPARC has 32 registers that you can address.
18:34:14 <Pseudonym> 8 are global, 8 are "input", 8 are "local", and 8 are "output".
18:34:14 <dfeuer> yah
18:34:32 <dfeuer> uh-huh...
18:34:35 <Pseudonym> When you call a function, you shift the registers so that the "output" registers become the "input" registers.
18:34:49 <Pseudonym> So the 24 non-global registers are arranged as a stack.
18:35:05 <Pseudonym> i.e. the call stack takes place entirely within registers.
18:35:30 <Pseudonym> (Of course, you can call deeply; there are mechanisms for dumping the register stack to memory and getting it back again.)
18:35:40 <Pseudonym> (It's a bit confusing, but logically this is how it works.)
18:35:58 <dfeuer> It sounds like it'd be pretty good for writing assembly by hand, but pretty lousy for compilers.
18:36:13 <Pseudonym> Actually, it's a very, very clever design if you assume single-threadedness.
18:36:26 <Pseudonym> The call stack in most CPUs lie in cache most of the time.
18:36:30 <Pseudonym> At least, the top of it does.
18:36:37 <Pseudonym> The SPARC designers figured: Why not in registers?
18:36:57 <Pseudonym> It's just a faster cache, after all.
18:37:00 <dfeuer> yah.
18:37:02 <dfeuer> gotcha.
18:39:41 <Pseudonym> BTW, if you're at all interested in this stuff, you need to read Hennessy and Patterson.
18:40:31 <Pseudonym> Their credentials are impeccable, given that Hennessy designed SPARC and Patterson designed MIPS.
18:44:59 <dropdrive> Isn't Hennessy some sort of a paper-pusher now?
18:45:07 <Pseudonym> Probably.
18:45:40 <dfeuer> Hennessy and Patterson...
18:45:55 <Pseudonym> "Computer Architecture: A Quantative Approach"
18:45:58 <dfeuer> Most engineers become paper-pushers when they get old, I think.
18:46:50 <dropdrive> John LeRoy Hennessy, the founder of MIPS Computer Systems Inc., is currently serving as the 10th President of Stanford University.  (http://en.wikipedia.org/wiki/John_L._Hennessy)
18:47:08 <Pseudonym> There you go.
18:47:17 <dfeuer> yup.
19:04:39 <satan> i'm trying to write a function that returns all possible combinations of a list of a certain size, but i ran into some problems
19:04:54 <Lokadin> is it possible to send current process into the background and bring up a process that was earlier put into the background into the foreground?
19:05:25 <Korollary> Lokadin: like ctrl-z, bg, fg, etc. ?
19:05:30 <Lokadin> er no in haskell
19:05:37 <Lokadin> but that to actually
19:06:29 <Excedrin> man 7 signal, sigcont and sigstop in particular
19:06:44 <Lokadin> kk, and in haskell?
19:06:48 <Korollary> look at System.Posix, I suppose.
19:07:21 <Lokadin> kk
19:07:23 <Lokadin> :) thanks
19:41:07 <mathewm> One upon a time, did Data.ByteString.Char8 export a version of hPutStrLn?  if so, where did it move?
19:43:38 <Korollary> mathewm: I still seem to have it
19:43:56 <mathewm> I am on 6.5
19:44:05 <Korollary> ah
19:44:56 <Korollary> well, the darcs version of ByteString that I have has it
19:45:48 <mathewm> darcs of fps, or the one included in ghc-6.5/libraries/base ?
19:45:55 <Korollary> darcs of fps
19:46:24 <mathewm> I was under the impression that fps in getting rolled into base for 6.5
19:47:44 <Korollary> Yes. maybe that's an older version of fps.
19:48:21 <Korollary> I wonder if you can hide the ghc version and install fps separately
19:48:54 <mathewm> hmm, might be tricky because it isn't in its own cabal package
19:49:05 <Korollary> ghc-pkg unregister ?
19:49:23 <Korollary> hm
19:50:27 <Korollary> what are you using 6.5 for?
19:51:05 <mathewm> I knew that question was coming ;)
19:51:28 <mathewm> evidently, because I like pain ( and smp and STM ... )
19:52:28 <Korollary> you can use stm in 6.4.2. Are you anywhere near needing smp?
19:54:23 <mathewm> I installed 6.5 while I was exploring the threads-n-events paper
19:54:44 <mathewm> I also viewed patching up code to work with 6.5 as a learning opportunity
19:58:12 <Korollary> ah
20:06:24 <dons> mathewm: did you work out your fps problem?
20:06:51 <dons> seems to be exported from Char8, in the darcs repo. maybe not in the base lib currently bundled with ghc.
20:06:58 <dons> they'll be back in sync in the next week or so
20:07:30 <mwc> I'm really excited about SMP
20:07:35 <mathewm> dons: yeah, I think I got it - I just defined my own
20:08:06 <mwc> it's a true N-to-M model, right?
20:11:14 <jer> dons, sorry to bug, but trying to get fps via darcs, and two days now, it's stalled at patch 179 each time (about 6 grabs)... there something i'm missing? (get --partial)
20:11:42 <dons> let me see...
20:11:54 <mathewm> I just did a darcs pull without trouble
20:12:06 <jer> interesting
20:12:07 <dons> $ darcs get --partial http://www.cse.unsw.edu.au/~dons/code/fps
20:12:07 <dons> Copying patch 358 of 358... done!
20:12:07 <dons> Applying patch 357 of 357... done.
20:12:07 <dons> Finished getting.
20:12:08 <lambdabot> Title: "Index of /~dons/code/fps"
20:12:15 <Lokadin> say i have a problem, i want multiple functions to accept the output of one other function
20:12:30 <Lokadin> i guess i'd have to store the output
20:12:32 <Lokadin> hmmm
20:12:33 <Lokadin> nm
20:12:40 <mathewm> maybe try 'pl'
20:13:15 <mathewm> ?pl \l -> div ( sum l ) ( length l )
20:13:15 <lambdabot> liftM2 div sum length
20:15:20 <Lokadin> say if i have program a, store it's output in program b, and i need program c to get that output, would the best way of getting program c to get the output as soon as it arrives through a program d? or b
20:15:59 <Lokadin> it's just i don't want program b to have anything hard coded, and i'd prefer if all it did was store and retrieve information
20:18:28 <dfeuer> hmm???
20:18:35 <Lokadin> er and program a shouldn't even know of b's existance as c should not care about what program a is, as long as it can retrieve the information from b
20:18:40 <dfeuer> Lokadin, could you get a wee bit more concrete?
20:18:48 <Lokadin> a = sending , b = storage, c = recieving
20:18:54 <mathewm> > let avg = liftM2 div sum length in avg [1,2,3]
20:18:56 <lambdabot>  2
20:19:22 <Lokadin> so i need to probably have a program d, but would it be a scheuler? or what?
20:19:48 <dfeuer> Lokadin, CONCRETE
20:19:51 <Lokadin> i guess i would have to be more concrete
20:19:53 <dfeuer> Don't give me a b c.
20:20:06 <mathewm> what do you mean by program?
20:20:41 <Lokadin> er a and c would not be programs just functions
20:21:06 <Lokadin> so i want to make a program, that is just a composition of functions, 
20:21:24 <SamB> (.)
20:21:27 <Lokadin> however i don't want it to matter what language the functions are written in or how they came to be
20:21:56 <SamB> pipes!
20:22:09 <SamB> oh, and maybe tee
20:22:19 <Lokadin> but i want to also be able to give one output to more than one other function
20:22:25 <Lokadin> if more than one other function wants it
20:22:39 <mwc> Lokadin, that's what tee does
20:22:40 <Lokadin> but i have no idea how many functions there will be, as extendability is the point
20:22:43 <Lokadin> oh yea?
20:22:49 <Lokadin> kk i'll go look
20:23:05 <Lokadin> thanks :) 
20:23:28 * mathewm looks perplexed
20:23:40 <mathewm> This doesn't work for me in my GHCi session
20:23:42 <mathewm> > let avg = liftM2 div sum length in avg [1,2,3]
20:23:43 <lambdabot>  2
20:23:55 <mathewm>     No instance for (Monad ((->) [Int]))
20:24:17 <Lokadin> er, well how does the next function no that there is something in queue?
20:24:21 <Lokadin> know*
20:24:48 <Lokadin> and it simply writes to file, i mean that's not the issue, i want the function to know when to get from storage
20:25:03 <Lokadin> tee that is
20:25:14 <Lokadin> er *thinks*
20:25:37 <Lokadin> hmmm
20:25:50 <mathewm> use tee to feed bytes into processes that are constantly reading ( or waiting for something to read )
20:25:50 <Lokadin> i guess i could just have a program d that keeps track of the description
20:26:27 <Lokadin> mathewm: it's just i don't know which processes those are, if any
20:27:04 <mathewm> you mean you don't start the processes?
20:27:16 <mlh_> dons: Setup.hs: cannot satisfy dependency plugins>=1.0
20:27:30 <Lokadin> mathewm: i have to know to start them
20:27:40 <mlh_> (tell me if this channel is not appropriate for lambdabot build type questions)
20:27:59 <mathewm> mlh_: you need to install hs-plugins
20:28:14 <mlh_> mathewm: ta
20:28:14 <dfeuer> Lokadin, I think you're thinking too abstractly.  
20:28:16 <jer> mlh_, http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-1.0-rc0.tar.gz <-- download and build that
20:28:16 <dons> this is the home of lambdabot :)
20:28:17 <mathewm> mlh_: I just went through this about 30 minutes
20:28:20 <dfeuer> and too optimistically.
20:28:23 <mathewm> mlh_: I just went through this about 30 minutes ago
20:28:24 <dons> ?where hs-plugins
20:28:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:28:43 <Lokadin> dfeuer: why do you say that?
20:29:43 <dfeuer> Lokadin so i want to make a program, that is just a composition of functions, 
20:29:43 <dfeuer> SamB (.)
20:29:43 <dfeuer> Lokadin however i don't want it to matter what language the functions are written in or how they came to be
20:30:06 <Lokadin> oh i know, i can just have program d, as the initiator of a and c, just there will be a problem that i have no idea whether the information is properly stored, though i guess the output can be passed directly using d
20:30:08 <Korollary> @type liftM2 div sum
20:30:09 <dfeuer> Different languages have entirely different notions of "function", and don't usually share runtime systems
20:30:09 <lambdabot> forall a. (Integral a) => ([a] -> a) -> [a] -> a
20:30:15 <Korollary> @type length
20:30:17 <lambdabot> forall a. [a] -> Int
20:30:38 <Lokadin> dfeuer: i don't understand you
20:31:09 <dfeuer> Lokadin, you're talking about composing functions written in different languages.
20:31:14 <dfeuer> What is a function?
20:31:32 <Lokadin> dfeuer: something that takes arguments and has output
20:31:46 <Lokadin> these function will only take strings, and output strings
20:32:20 <Lokadin> and IO, and child processes aren't really relevant
20:32:35 <Lokadin> er as to the function of the program
20:32:49 <Lokadin> assuming the input and output is there
20:33:19 <dfeuer> Do they have state?
20:33:26 <Lokadin> state?
20:33:30 <dfeuer> and do they take strings or streams
20:33:31 <dfeuer> ?
20:33:35 <dfeuer> State.
20:33:46 <Lokadin> can you explain what tha means?
20:35:28 <dfeuer> uhhh....
20:35:34 <dfeuer> Well....
20:35:56 <Lokadin> sorry, i just am not very familiar with the concept
20:36:03 <dfeuer> mutable variables?
20:36:11 <psykotic> hmm, consider the functions which are essentially unfolds composed with a function that returns the last element--are there catamorphisms for the algebra corresponding to the identity functor?
20:36:23 <dfeuer> If you call them twice on the same input, do they give the same output?
20:36:26 <psykotic> *are these
20:36:49 * dfeuer wonders if psykotic thinks 'e's speaking English.
20:37:15 <Lokadin> dfeuer: well not necessarily, i mean they can get input from user or what not, and then output to next function
20:38:42 <dfeuer> Lokadin, so what is a function?
20:39:00 <Lokadin> dfeuer: but they wont use any information outside of the string they get, unless their purpose is to gather information
20:39:13 <Lokadin> dfeuer: a function is a function as it works in haskell
20:39:16 <dfeuer> Lokadin, define function.
20:39:30 <dfeuer> A function in haskell can't take input from a user.
20:39:38 <dfeuer> So you must be talking about something else.
20:39:47 <Lokadin> umm, something that manipulates the input, performs an action, and either terminates or gives output
20:40:00 <wolverian> heh, the haskell xml toolbox docs are in the form of a thesis and haddock. help, arrows :\
20:40:32 <Lokadin> dfeuer: what about IO functions ? i thought those were still considered functions
20:42:48 <Lokadin> in any case, i don't really see the problem
20:47:27 <Lokadin> in theory as long as the description allows for it then the output and input can be more complex then just a simple string
20:48:42 <Lokadin> i haven't really worked with streams before, but i'm sure if you make it like a server, where it waits for input, then you could also make it pass output to the description which would pass it to whatever else is necessary
21:01:18 <dons> fun: http://www.cse.unsw.edu.au/~dons/images/commits/community/
21:01:19 <lambdabot> Title: "Index of /~dons/images/commits/community"
21:42:26 <Korollary> @seen Lemmih
21:42:26 <lambdabot> Lemmih is in #oasis, #haskell-overflow, #haskell-blah and #haskell. I last heard Lemmih speak 4 hours, 45 minutes and 24 seconds ago.
21:42:56 <Korollary> @time Lemmih
21:42:58 <lambdabot> Local time for Lemmih is Tue Jun 20 06:43:15 2006
21:45:19 <aFlag> @time aFlag 
21:45:21 <lambdabot> Local time for aFlag is Tue Jun 20 01:45:27
21:45:46 <aFlag> i didn't know about that time ctcp
21:50:48 <dons> @seen sjannsen
21:50:49 <lambdabot> I haven't seen sjannsen.
21:50:52 <dons> @seen sjanssen
21:50:53 <lambdabot> I saw sjanssen leaving #haskell 9 days, 1 hour, 47 minutes and 57 seconds ago, and .
21:54:16 <wolverian> I'm parsing lists that can have many datatypes with parsec. how should I represent this in haskell?
21:54:34 <dons> define a new data type to represent that structure
21:54:40 <wolverian> right.
21:54:57 <wolverian> duh. :) thanks.
21:55:13 <dons> :)
21:56:26 <Korollary> darcs is neat.
21:57:24 <dons> true.
21:58:40 <wolverian> hm. I'm not sure how to describe this as a data type.
21:58:54 <wolverian> (I'm decoding bittorrent's bbencoding)
21:59:11 <Korollary> wolverian: hacking on conjure?
21:59:35 <wolverian> Korollary, no, just learning by doing it from scratch. insane but fun.
21:59:43 <wolverian> (I wanted to learn parsec)
21:59:55 <Korollary> ah
22:02:38 <wolverian> @where conjure
22:02:39 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
22:02:44 <wolverian> doesn't hurt to take a look.
22:03:34 <wolverian> _ah_. now I see.
22:11:47 <dons> ?uptime
22:11:47 <lambdabot> uptime: 1 day, 1 hour, 45 minutes and 20 seconds
22:36:57 <Korollary> What is the syntax for dependency version constraints in cabal?
22:37:54 <Korollary> What is the syntax for dependency version constraints in cabal?
22:37:55 <Korollary> er
22:45:19 <Korollary> ok, got it. It has to be "fps <=0.6". You can't have a space between <= and 0.6.
23:02:43 <satan> what does the $ sign do, in Haskell?
23:03:53 <Korollary> nothing interesting. f $ x = f x. It has low precedence and right associativity, so using it reduces number of parens that you would otherwise type.
23:04:27 <satan> so f $ x is not the same as f (x) ?
23:04:59 <ulfdoz> f (g x) = f $ g x
23:05:09 <Korollary> it is. What I mean is: f (g (h x)) = f $ g $ h x
23:05:46 <satan> hmm
23:06:02 <satan> is that way f x = sum . map (*2) $ x compiles but f x = sum . map (*2) (x) doesn't ?
23:06:03 <ulfdoz> function application is usually righ associativ.
23:06:06 <satan> why*
23:06:35 <satan> ok i think i got it now
23:06:38 <Korollary> no, function application is left-assoc
23:07:07 <ulfdoz> h, of course. Sorry. left and right is more complicated than 0 and 1. :)
23:07:33 <satan> and left-associative means f g x is f (g (x))
23:07:46 <satan> or is that right associative, sorry, i'm new to all of this :(
23:08:00 <bobthemonkey13> f g x = ((f g) x)
23:08:03 <Korollary> f g h = (f g) h
23:08:14 <bobthemonkey13> which matches with how you'd expect currying to work
23:08:24 <satan> ahh ok, thanks guys :)
