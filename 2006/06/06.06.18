00:14:54 <aFlag> how do I import something from a directory inside the current one (something like #include "dir/foo.h")
00:18:18 <mwc> import Dir.Foo 
00:18:27 <mwc> i think is what you want
00:23:27 <aFlag> but if i have, inside dir, two files. Foo.hs and Bar.hs. If I do "import Foo" inside Bar.hs, and "import dir.Bar" inside a module in dir's parent directory. It won't work, will it?
00:58:01 <vegai> aFlag: why not?
00:58:15 <shapr> @Yow!
00:58:15 <lambdabot> I'm wearing PAMPERS!!
00:58:23 <vegai> howdy
00:58:38 <sieni> lambdabot: thanks for the info!!!1!
00:58:47 <shapr> Wow, smallest number of irc clients I've seen on #haskell, is it because of summer, or because freenode is being flaky?
00:58:48 <lambdabot> shapr: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:59:18 <vegai> yeah, smart people have better things to do in the summer..
00:59:46 <vegai> like SoC
00:59:46 <shapr> @tell xerox Weird is the arm thing you mentioned for my most recent blog picture. I noticed it only after you mentioned it to me.
00:59:47 <lambdabot> Consider it noted.
01:00:03 <shapr> bringert: Did you have fun at Galois?
01:00:07 <jer> vegai, and on saturday nights =]
01:00:17 <bringert> shapr: good morning
01:00:17 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
01:00:25 <vegai> jer: it's my vacation, every night is saturday :P
01:00:29 <shapr> Good morning bringert!
01:00:30 <jer> =]
01:01:05 <ibid> vegai: good morning :)
01:01:07 <bringert> shapr: yeah, it was fun
01:01:19 <bringert> I gave a talk
01:01:29 <shapr> About what?
01:02:09 <sieni> shapr: how do you pronounce "shae"?
01:02:15 <shapr> bringert: This is my gf's mother and me: Do I have a huge head or what? http://www.flickr.com/photos/souwh/167685615/
01:02:16 <bringert> shapr: Almost Compositional Functions
01:02:17 <lambdabot> Title: "Mom and Shae on Flickr - Photo Sharing!"
01:03:09 <bringert> shapr: nice
01:03:19 <shapr> sieni: Lika som "tjej" i svenska. Jag var s√• f√∂rvanad att heta "girl" p√• Svenska.
01:03:34 <shapr> er, f√∂rv√•nad?
01:04:21 <bringert> shapr: yes, f√∂rv√•nad, though this is a mostly english language channel :-)
01:04:23 <shapr> sieni: Shae is short for shapr, and shapr is short for shaper, so it's just the first syllable shay.
01:04:39 <shapr> Oh right, I should take that sort of talk to #haskell.se :-)
01:04:45 <sieni> shapr: I guess that would be "shei" if that was written systematically in finnish
01:04:56 <shapr> That's a neat way to spell it.
01:05:07 <ibid> or tsei?
01:05:27 <ibid> depends on the variant of swedish, i guess
01:06:04 <shapr> bringert: Does your hope have the tag support installed?
01:06:11 <bringert> shapr: not yet
01:06:29 <shapr> I was just wondering if there was a demo I could look at while I do the upgrade bit.
01:06:41 <bringert> hope.bringert.net is still running a pretty old version
01:07:11 <shapr> Ok, the bleeding edge will be xerox and myself then :-)
01:07:12 <sieni> ibid: o.O I was more like asking how he pronounces the vowels... I guess sh- is never pronounced like tj- in swedish
01:07:15 <bringert> shapr: I'm working on importing images from local files (local on the server that is) atm
01:07:28 <ibid> sieni: ah
01:07:58 <JKnecht> do europeans with different native langs speak mostly English only in mixed groups or also in groups of those with same NL?
01:08:03 <shapr> bringert: I made my life easier by setting halbum to ../ and then I don't have to touch my images when I upgrade.
01:08:43 <ibid> JKnecht: generally a common language is used. english is usual but not the only one
01:08:46 <bringert> shapr: why would you have to touch them?
01:09:17 <ibid> JKnecht: and if everyone has the same native language, or most do and the others understand it well, then that language is often used
01:09:50 <shapr> Right now I do make installball-cgi && scp installball-cgi and then on the server I do tar xzf installball-cgi && mv hope hope.old && chown -R www-data installball-cgi && mv installball-cgi hope
01:10:16 <ibid> JKnecht: german is also used as the franks' language quite often
01:10:25 <ibid> (franks' language = lingua franca;)
01:10:28 <bringert> shapr: ah
01:10:30 <sieni> JKnecht: well, at least we use English exclusively at workplace meetings if there are non-Finns at the meeting (and often also even if all are Finns, since it's easy to forget that there are no non-Finns present)
01:10:41 <shapr> If the tables haven't changed that's the fast way to upgrade or try new code without having to worry about external data.
01:10:56 <mahogny> JKnecht, it happens that a group I'm in use english, even though we're all swedes. but I think that is rather uncommon
01:11:08 <ibid> (i get *such* a kick out of the fact that french is *not* the international franks' language:)
01:11:29 <shapr> I just use Swedish until I run out of words and ask if I can switch to English.
01:11:32 <ibid> (anymore, at least)
01:12:01 <bringert> shapr: that's the way to go. the halbum image storage dir should actually be completely outside the web directory if you want to be able to restrict access to images
01:12:02 * jer is lost unless i can speak english or canadian french =[
01:12:10 <sieni> finns don't care that much about how we communicate internationally, since all the choices (english, french, german, russian ...?) are indo-european languages anyway
01:12:22 <ibid> sieni: klingon is not:)
01:12:39 <bringert> the current darcs version has much more permissions checking, so you can disable even viewing image and blog entry for anonymous users
01:12:50 <ibid> nuqneH! Qapla'!
01:12:51 <ibid> ;)
01:12:51 <sieni> maybe mandarin would be an option ^_^
01:13:00 <shapr> Yesterday I totally forgot something simple like p√•se and switched to english in a store where I usually speak Swedish, and the woman behind the counter spoke with a 100% perfect Boston accent! I was amazed. Turned out she'd spent a year in Boston being an au pair.
01:13:32 <shapr> jer: Salut! Comment √ßa va?
01:13:34 <sieni> although I'd rather learn to speak Sindarin rather than Klingon, since the latter just sounds ugly
01:13:37 <mahogny> shapr, lol
01:13:45 <jer> shapr, bein, merci... et tu?
01:13:52 <shapr> Tres bien!
01:13:53 <ibid> (what i said was, alternatively, "how do you do! success!" or "what do you want! success!", depending)
01:14:08 <shapr> J'ai la langue fonctionelle!
01:14:14 <JKnecht> Finno-Urgic is indo-european isn't it?
01:14:14 <jer> ah
01:14:30 <sieni> shapr: the swede's are amazing anyway, since they are actually able to speak american english with no observable accent
01:14:36 <sieni> JKnecht: no
01:14:52 <JKnecht> oh it and Basque are the isolates.
01:14:55 <shapr> JKnecht: Not anymore than Apache is related to the Spanish of South America.
01:15:09 <jer> sieni, they'd have to speak with some sort of accent -- there are many regional accents to american english
01:15:13 <sieni> JKnecht: it's an uralic language
01:15:32 <neologism> JKnecht: in fact finnish language is closely connected to the ancient germanic vocabulary
01:15:38 <ibid> i hear stories of  who complain that they cannot practice finnish with their fiinnish friends as they insist on talking in english. not me. *my* foreigner friends tend to get annoyed when i talk finnish to them.  even though they admit they need to learn finnish...
01:15:46 <shapr> Most Swedes have some accent, but I do agree that I only notice those accents because I've been here for years.
01:16:04 <ibid> "of _foreigners_"
01:16:20 <shapr> Swedes do have an amazing ability to speak perfectly clear american or british.
01:16:22 <JKnecht> sieni: by ancient german you mean AltHochdeutsch or the Ursprache?
01:16:34 <shapr> I just gave up on being amazed after a few months though :-)
01:16:43 <neologism> JKnecht: proto-germanic thats what I mean :)
01:16:53 <jer> shapr, now if only the swedes could teach the scots how to speak clearly =D
01:16:53 <sieni> jer: I mean that many swedes are able to speak english so that at least I can't distinguish them from native american speakers even though I've been in the States for 18 months. The Finns are immediately obvious even they are fluent with their English
01:16:59 <neologism> finnish language is often used to study germanic languages (suprisingly)
01:17:36 * JKnecht has decided to give Plattdeutsch some play.
01:17:38 <shapr> sieni: Yeah, Finnish accents are easily noticed. I'm not sure if I've met any Finns who didn't have an accent.
01:17:40 <sieni> although I know an american math professor who can talk rikssvenska convincingly
01:17:44 <ibid> fenno-ugric languages are not related to anything else in europe. it just seems that way because we have loaned a lot of vocabulary from indoeuropean languages
01:18:42 <sieni> Map of Uralic languages: http://upload.wikimedia.org/wikipedia/en/8/87/Uralic-Yukaghir.png
01:18:52 <jer> sieni, i see; i think it'd probably be easier for a native like myself to pick out most swedes (that is, line up a bunch of 'em and blindfold a native and ask him to pick out the swede. i could probably do it =])
01:18:59 <shapr> I was still amazed to hear this cashier woman switch between somewhat a clear norbotten accent and a nasal Boston accent.
01:19:12 <shapr> jer: You'd be surprised.
01:19:17 <jer> shapr, possibly
01:19:18 <neologism> ibid: yes... loan words... but finnish preserved them while in germanic langauges they have changd
01:19:20 <shapr> jer: Seriously, they're *good*
01:19:31 <ibid> neologism: like kuningas? ;)
01:20:16 * neologism has no idea what kuningas is
01:20:20 <shapr> I think bringert has less of an accent in American than 75% of the people I knew in Alabama.
01:20:39 <sieni> jer: well, I'm not able to sound rikssvenskan, but fortunately I'm fluent enough with my Swedish that actually people reply to me in Swedish in Sweden (instead of English)
01:20:42 <ibid> neologism: 'king'. apparently also in ancient germanic or sommething
01:20:52 <jer> sieni, ah
01:20:56 <neologism> yes
01:21:02 <neologism> then yes ;)
01:21:05 <sieni> jer: 
01:21:22 <jer> sieni, i have a problem that my french accent isn't convincing enough and i tend to (outside of western montr√©al) get a sigh and then "sir, i speak english" when i go into a shop and start speaking french
01:21:28 <shapr> hah
01:21:53 <sieni> jer: I have actually observed that at a tunnelbana station in stockholm the clerk has replied in english to a native swedish (finlandssvenska) speaker ^_^
01:22:11 <jer> ah
01:22:15 <neologism> ibid: most of the genuine finno-ugric words in finnish are related to fishing and agriculture iirc
01:22:17 <shapr> That's funny
01:22:21 <JKnecht> pronounciations critical in French, Chinese, not so much in English
01:22:35 <jer> it's frustraiting, i'll tell you that.. your making the attempt and keeping up with them, but they don't wnat to talk to you because you don't speak with the right accent
01:22:37 <shapr> Yeah, like Kuusela means fir-tree or something.
01:23:09 <shapr> jer: I spent a week or so in Lille trying my college French, I bet you get a friendlier response than I did ;-)
01:23:15 <sieni> well, "Kuusela" would be something like "a place with firs/spruces"
01:23:16 <mahogny> sieni, it happens a lot, at least in the university here... you're unsure of the others nationality and you automatically switch to english...
01:23:16 <ibid> neologism: the funny thing is, the current finnish word for 'mother' *is* a loan word. the old, original word still exists but is only used of animals and for humor
01:23:24 <neologism> ibid: yes.. I know :)
01:23:42 <neologism> I am deeply interested in finno-ugric languages :)
01:23:47 <sieni> ibid: wtf? like "narttu" or what?
01:23:54 <ibid> sieni: emo
01:23:57 <jer> shapr, perhaps; most people in qu√©bec aren't too rude when it comes to speaking with a bad accent, most (at least that i've come across) tend to understand that you're trying, but would rather speak to you in english if your an anglo like myself
01:24:03 <sieni> ibid: ahh
01:24:38 <shapr> I like to do new things, and speaking a language that is not my first language is nifty.
01:24:43 <sieni> at least "emo" is not insulting, like "narttu" (bitch) is
01:24:50 <ibid> heh
01:25:02 <mahogny> lol
01:25:11 <jer> shapr, yeah
01:25:19 <neologism> ibid: I think its logical because the finns were hunters who "took" women from the natives
01:25:23 <shapr> Swearing in Finnish is just too much fun. It sounds awesome.
01:25:25 <neologism> so they took their word for it
01:25:27 <ibid> nartun penikka ('son of a bitch') is more humorous than a serious insult
01:25:46 * jer isn't a language aficionado myself though
01:25:54 <sieni> shapr: yes, we are good at it
01:26:09 <jer> don't have a hard time picking up programming languages =] but spoke languages i tend to not have the patience unless they were drilled into me from childhood
01:26:32 <shapr> Of course most people think "min√§ rakastan sinua" sounds like swearing.
01:26:32 <sieni> shapr: even though the most popular words are imported (besides "paska" and "kusi" and the latter isn't used that much for swearing)
01:27:00 <shapr> That is, most non-Finns.
01:27:16 <sieni> shapr: if you want to sound more modern, you can always use "s‰ oot pantavan n‰kˆne muidu"
01:27:22 <ibid> shapr: it does sound ... un-romantic ... to a finn too, sometimes
01:28:14 <sieni> shapr: as a second thought, don't use that ^_^
01:28:17 <shapr> Plus literal translations of insults like "suksi vittuun" are likely to end a fight before it ever starts.
01:28:37 <ibid> shapr: "m√§ lemmin sua" is much more sugary, almost comical
01:29:12 <ibid> shapr: does that sound like swearing?
01:29:18 <shapr> Random question, is there a way to get darcs to switch the return value depending on whether there are new patches to pull or not?
01:29:25 <shapr> ibid: No, it doesn't
01:30:23 <sieni> also the expression "vittujen kev‰t" (=="the spring of the cunts") is pretty weird
01:30:25 <ibid> hm, actually, strike the "almost"
01:30:43 <shapr> I still think that naming a spam filter Paskalle was a great idea.
01:31:05 <ibid> i think wikipedia has a list of these
01:31:16 <shapr> If I could switch on whether darcs had new patches or not I could automate my hope upgrades.
01:32:33 <ibid> what does it tell about the respective languages, when in english, having an intercourse is the teenage comma while in finnish the same function is given to the outer female reproductive organ
01:33:05 <shapr> Yeah, that's an interesting point.
01:33:18 <sieni> it would be nice that one could optionally ask for darcs to cache information, like changelogs for a file
01:33:44 <shapr> What do you mean?
01:33:46 <sieni> ibid: especially, when the latter word is an import from swedish
01:34:35 <sieni> shapr: I mean that it wouldn't take an eternity (I'm talking about the equivalent of cvs log foo.bar)
01:36:08 <ibid> http://en.wikipedia.org/wiki/Finnish_profanity
01:36:14 <sieni> (in case the repository is extremely large, of the order of the linux kernel)
01:38:36 <sieni> is "vittu" actually a finnish or swedish word? I've always thought that we have just imported "fittan", but maybe the swedes have started using the finnish term ^_^
01:39:27 <ibid> dunno
01:40:19 <sieni> the finnish profanity -page claims that it's of finnish origin, although the wikipedia pages are often really crappy
01:41:07 <sieni> Perse, literally "ass" (meaning buttocks, not donkey)
01:41:18 <sieni> Kyrp‰, literally "cock" (meaning penis, not a rooster)
01:41:31 <sieni> Pillu, literally "pussy" (meaning vagina, not a cat)
01:41:39 <sieni> very informative
01:41:55 <ibid> somebody's been having fun
01:44:59 <shapr> I wonder why Microsoft doesn't switch to Haskell - http://blogs.msdn.com/philipsu/archive/2006/06/14/631438.aspx
01:45:02 <lambdabot> Title: "The World As Best As I Remember It : Broken Windows Theory"
01:45:21 <sieni> only in the first case the explanation is somewhat defensible (and "buttocks" is equally band translation as it would be for the english word "ass")
01:45:44 <shapr> bringert: Any new pix of you in Seattle?
01:48:45 <sieni> shapr: are you planning of visiting finland in the near future?
01:50:19 <shapr> No, but it would be fun.
01:50:53 <sieni> we could have a fenno-swedish #haskell meeting on a short notice ^_^
01:50:55 <shapr> If I get some spare time & money I could drop by and organize HaskHel :-)
01:51:27 <shapr> That would be spiffy, I wonder how many #haskell people we could get.
01:51:40 <shapr> Maybe even some of the #debian.fi and #python people.
01:51:50 <bringert> shapr: not online, maybe when I update hope.bringert.net
01:52:02 <bringert> shapr: current darcs version now has local image file import
01:52:05 <shapr> Cool
01:52:13 <bringert> good for importing lots of images
01:52:19 <bringert> good night
01:52:36 <shapr> g'nite, thanks!
01:53:03 <bringert> shapr: you may need to update haskell-cgi btw
01:53:19 <shapr> Ok, I'll remember that.
01:54:07 <sieni> shapr: when franka visited finland we managed to get 3 #haskellers to join (me, musasabi and lor)
01:54:26 <shapr> Nifty
01:54:27 <bringert> ok, good night for real
01:54:29 <ibid> helsinki is so far away...
01:54:44 <ibid> basically spend 8 hours in a train for the round trip
01:55:13 <sieni> ibid: from oulu or what?
01:55:19 <shapr> Maybe we could organize a weekend of hacking. That might make it worth 8 hours.
01:55:31 <shapr> I think Oulu is much further away than 8 hours.
01:55:55 <ibid> shapr: jyv√§skyl√§
01:56:11 <sieni> shapr: 600 km
01:56:41 <ibid> hm, coud be even 6 hours roundtrip, depending on the trains
01:56:52 <sieni> ibid: ahh, round trip, not single :-)
01:56:55 <ibid> tampere is only 4 hours roundtrip
01:57:34 <shapr> Last time I was in Helsinki I met liiwi, Viiru, and a coupla other people.
01:57:44 <sieni> ibid: that sounds correct, 2 hours to tampere, 3h45 to jyv‰skyl‰
01:58:03 <sieni> shapr: viiru as in heikki or somebody else?
01:58:19 <ibid> sieni: yeah, 8 hours roundtrip tends to make a single-day event not very appealing. to have any sort of real fun, i'd have to come in the previous evening and leave the next morning, which means finding a place to sleep
01:59:01 <shapr> Viiru as in /whois Viiru
01:59:56 <sieni> shapr: ahh, ok, different viiru ^_^
02:00:26 <ibid> the last time i was in helsinki was during the 2005 debconf
02:00:41 <ibid> the university paid for the hotel :)
02:02:09 <sieni> jyv‰skyl‰ is a nice place
02:02:16 <ibid> sure :)
02:03:20 <sieni> one of the towns I'd actually be willing to move to from Helsinki
02:03:37 <sieni> Turku is nice as well, but Tampere sucks ass
02:13:30 <astrolabe> I'd like to have an infinite list type with ':',head,tail,map etc.
02:15:18 <ibid> the regular list type is not enough?
02:58:53 <_xX[ReP]Xx_> how do i define a custom show function for a datatype?
02:59:14 <shapr> make it an instance of Show
02:59:40 <_xX[ReP]Xx_> shapr yeah, but i also want it to have a custom show funciton
02:59:41 <_xX[ReP]Xx_> function
02:59:55 <shapr> ?
03:00:25 <_xX[ReP]Xx_> like i have data Blah = Blah { blah :: Int, bleh :: String }
03:01:02 <_xX[ReP]Xx_> and i want show (Blah 1 "a") to give me "1:a"
03:01:06 <_xX[ReP]Xx_> (for example)
03:01:21 <shapr> So you make an instance of Show that does that.
03:03:08 <_xX[ReP]Xx_> ok, thanks
03:05:31 <Kasperle> _xX[ReP]Xx_: here's some example code I had to do as an exercise once: http://pastebin.ca/66774
03:08:43 <_xX[ReP]Xx_> thanks
03:42:39 <Lokadin>  w bg 
03:47:43 <azuroth> yo yo
03:47:54 <mnislaih> @seen Lemmih
03:47:55 <lambdabot> Lemmih is in #oasis, #haskell-overflow, #haskell-blah and #haskell. I last heard Lemmih speak 1 day, 2 hours, 1 minute and 41 seconds ago.
03:49:24 <azuroth> is anything special necessary to use -prof? I tried it, but it whinges about not finding Text.Printf?
03:49:29 <azuroth> (in ghc)
03:50:05 <mnislaih> you are in Linux? Debian? You probably need to install the ghc-devel package or something like that
03:50:18 <azuroth> ahh, perfect. thanks
03:51:01 <azuroth> did you just guess I was on debian?
03:53:05 <mnislaih> I had the same problem when I started using ghc on debian
03:54:02 <Igloo> ghc6-prof
03:54:51 <azuroth> yeah, found it :-) I'm trying to fasten my submission for SPOJ/BSHEEP. I can't say I'm very hopeful, but it's worth trying
04:08:59 <good_boy> hi, im trying to define an instance of the class Num. when I finally run the program i get Missing binding for variable "-" in type signature
04:10:02 <good_boy> should i define how substraction works?
04:10:09 <good_boy> think of an algorithm?
04:10:52 <azuroth> hmm, I don't think it'll compile if you're saying instance num and not defining at least a stub (-) ?
04:13:32 <good_boy> all i do define is "(-) :: Num a => a -> a -> a"
04:13:54 <good_boy> same for (+), (*)
04:14:30 <azuroth> it'll be looking for a definition, but won't find one and whine
04:14:46 <good_boy> well... how can i define?
04:15:42 <int-e> azuroth: it will compile - the compile will give a warning (in ghc at least) and trying to use the function will fail.
04:16:07 <good_boy> is there a 'IntAdd'
04:16:08 <good_boy> ?
04:16:41 <good_boy> 'intAdd'
04:16:57 <azuroth> hmm, ok. that's interesting
04:17:43 <azuroth> good_boy: for now you could use "l + r = l" etc
04:18:15 <int-e> azuroth: (the compiler implicitely adds a (+) = error "some error message")
04:18:53 <int-e> good_boy: (+) works on Ints. what are you trying to do?
04:19:34 <good_boy> im trying to define an instance of the class Num
04:20:02 <azuroth> ghc's profiler seems to think a float subtraction is where half the time is being spent? I don't know better than it, but it seems pretty weird to me.
04:20:44 <azuroth> two float subs* maybe I should be using newtype..?
04:21:43 <azuroth> no, never mind newtype
04:22:11 <good_boy> with (+) worked fine
04:22:25 <good_boy> (-), (*) seem ok too
04:23:45 <good_boy> what about the function fromInteger?
04:24:18 <int-e> fromIntegral is more general
04:26:05 <good_boy> Ambiguous variable occurrence "+"
04:26:05 <good_boy> *** Could refer to: Main.+ Hugs.Prelude.+ 
04:26:31 <good_boy> (+) :: Num a => a -> a -> a
04:26:31 <good_boy> (+) a b = a (+) b
04:26:33 <good_boy> ??
04:26:33 <lambdabot> Maybe you meant: . v
04:26:46 <int-e> ok, you're definitely not defining a Num instance then.
04:27:07 <int-e> what you're doing is define a *new* (+) function
04:27:10 <good_boy> hm, instance Num Bit where, ?
04:27:31 <int-e> then the type signature is wrong, and you have an indentation problem
04:27:51 <int-e> (the type signature should be (+) :: Bit -> Bit -> Bit)
04:27:59 <good_boy> oh 
04:30:18 <good_boy> i corrected the type signature
04:30:47 <int-e> you need to indent that function deeper then the 'instance Num Bit where'
04:31:14 <int-e> otherwise the compiler will treat it as a top level declaration and define a new function (which will then clash with Prelude.+)
04:31:21 <good_boy> yes
04:31:23 <good_boy> it does that.
04:32:20 <good_boy> i dont know "how to indent the function", i dont know what does it mean.
04:33:24 <int-e> put spaces in front of it.
04:33:44 <int-e> |instance Num Bit where
04:33:52 <int-e> |  (+) a b = a + b
04:34:15 <int-e> (well, you'll want a different implementation probably)
04:34:47 <int-e> |  a + b = your code here
04:34:51 <int-e> will also work.
04:35:06 <int-e> (ignore the | characters)
04:36:45 <azuroth> just wondering... is Data.PackedString faster than String, or just less memory?
04:40:39 <wilx> Search the haskell mailing list.
04:40:46 <wilx> Banchmarks have been posted.
04:41:13 <neologism> azuroth: MUCH faster
04:53:41 --- mode: ChanServ set +o dmhouse
04:56:31 <good_boy> here is my code for defining an instance of Num. If anyone could help, that would be very appreciated.
04:56:34 <good_boy> http://pastebin.com/716272
04:57:11 <dmhouse> good_boy: What's wrong with it?
04:57:11 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
04:57:38 <good_boy> it says: addInt undefined variable
04:58:06 <dmhouse> Firstly, you need to indent everything that forms part of the instance declaration.
04:58:51 <azuroth> I've never seen a data definition like that before?
04:58:53 <dmhouse> Secondly, you shouldn't be using 'otherwise'. That's only for guards.
04:59:12 <dmhouse> Thirdly, 'Int == Int' doesn't make any sense. Int is a type, not a value.
04:59:25 <good_boy> hm
04:59:40 <good_boy> how should it be?
04:59:49 <dmhouse> Fourthly, you probably want type Bit = Int.
05:00:15 <dmhouse> type makes type synonyms. data makes a datatype, and you need a constructor for each one.
05:00:40 <dmhouse> Fifthly, if you're only doing a type synonym for Int, you don't need to have instance declarations for Eq and Num.
05:01:14 <dmhouse> As Int is already an instance of those classes, and you're making a type synonym, which is an exact interchangeable copy, Bit will be an instance of those classes as well.
05:01:36 <kombinator> has anyone tried building Yi?
05:01:41 <dmhouse> And the build in succ function will already work, you don't need to redefine it.
05:01:45 <dmhouse> kombinator: I did, once. Not recently.
05:02:00 <kombinator> dmhouse: successfully?
05:02:06 <dmhouse> kombinator: IIRC, yes.
05:02:45 <kombinator> dmhouse: I'm getting an error "Regex.hsc:67: error: ‚Äòregex_t‚Äô undeclared (first use in this function)", and a few others from that file
05:02:58 <kombinator> no idea what's wrong
05:03:04 <dmhouse> good_boy: Sixthly, where you've written 'fromInteger a = (fromIntegral a) : Int', that ':' needs to become '::'. (:) is a function which joins an element onto the front of a list, :: is special syntax for annotating types.
05:03:15 <good_boy> yes :)
05:03:25 <dmhouse> kombinator: Ah, I wouldn't be the one to ask about build errors :)
05:09:26 <apfelmus> good_boy: the posted correction compiles.
05:10:31 <good_boy> where?
05:10:55 <apfelmus> good_boy: http://pastebin.com/716284
05:11:45 <dmhouse> @ask bringert whether Network.HTTP follows robots.txt?
05:11:46 <lambdabot> Consider it noted.
05:11:56 <good_boy> oh, thanks apfelmus
05:16:49 <dmhouse> @hoogle nubBy
05:16:50 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
05:19:43 <roconnor> anyone know of an matrix inversion implementation?
05:19:51 <roconnor> (for Fractional)
05:21:40 <dmhouse> roconnor: The algorithm's quite simple, isn't it?
05:22:37 <apfelmus> roconnor: i don't remember exactly, but i think there is one in the hugs demo directory
05:24:22 <apfelmus> roconnor: how are your multinomials doing anyway? they might want a faster multiplication (karatsuba's algorithm)
05:26:34 <dropdrive> would List.nubBy be worst-case O(N^2), then?
05:26:48 <roconnor> the multinomials a great, but I'm not sure they will be large enough to warrent karatsuba.
05:27:17 <dropdrive> or is there some kind of internal hashing?
05:27:30 <dropdrive> (wait, last comment makes no sense)
05:29:46 <dmhouse> @hoogle (a -> a -> Bool)
05:29:47 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
05:29:47 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
05:29:47 <lambdabot> Prelude.(<=) :: Ord a => a -> a -> Bool
05:29:47 <mahogny> roconnor, just worth saying, You Don't Invert a Matrix
05:30:17 <roconnor> yeah, I know.  But my specific problem is to invert a matrix.
05:30:17 <dmhouse> Hoogle's partial matching seems to be broken. I'd expect that to match nubBy.
05:30:36 <dropdrive> mahogny, why doesn't one invert matrices?
05:30:57 <mahogny> dropdrive, it's slow and gives horrible precision (if it works at all)
05:31:09 <apfelmus> roconnor: if they don't become large, they don't grow up well in your lair :O ;) 
05:31:28 <dropdrive> mahogny, but roconnor wants it over Fractional
05:32:17 <mahogny> dropdrive, I guess it works. but if the final fast is to solve a matrix system, then you should do it right away without an explicit inversion
05:32:26 <mahogny> *fast=task
05:32:34 <roconnor> my inversion will be exact.
05:32:51 * mahogny is unsure about the speed
05:33:52 * apfelmus remembers horror storries of exploding denominators and numerators...
05:34:03 <roconnor> not Rational ... Factional
05:34:07 <roconnor> not Rational ... Fractional
05:35:12 <dropdrive> roconnor, not sure of this is relevant...I once did write a routine for matrix inversion over Q, and yes, denominators do explode when your matrices are rather dense and without structure.
05:35:41 <shapr> Tag support in the new hope code is way nifty.
05:35:52 <apfelmus> dropdrive: maybe he is calculating over finite fields ... ;)
05:35:56 <dmhouse> Hi there shapr.
05:36:13 <dropdrive> apfelmus: hey!  we can always hope.
05:36:19 <shapr> hiya dmhouse 
05:36:21 <roconnor> :)
05:36:35 <dropdrive> apfelmus: so perhaps he can calculate and enough primes and then use the chinese remainder theorem?
05:36:51 <dropdrive> *calculate at enough primes
05:37:08 <shapr> Wah this is cool - http://www.scannedinavian.com/hope/tag
05:37:14 <shapr> bringert writes great code.
05:39:24 <vegai> working on GHC, that'd be nice.
05:39:33 <apfelmus> dropdrive: huh, how does he get invertible things then?
05:39:45 <vegai> I suppose some wizards want that too...
05:40:10 <shapr> vegai: want what?
05:40:11 <beelsebob_> @hoogle Int -> String
05:40:12 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
05:40:17 <beelsebob_> ... fail
05:40:26 <vegai> shapr: work on GHC... for a living
05:40:41 <shapr> Oh, I'd love to do that.
05:40:59 <vegai> will you apply?
05:40:59 <shapr> I applied for that job, I hope I get it.
05:41:02 <beelsebob_> @hoogle Integral a => a -> String
05:41:03 <lambdabot> Prelude.show :: Show a => a -> String
05:41:03 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
05:41:03 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
05:41:20 <beelsebob_> anyone know how to write out an integer as hex?
05:41:23 <dropdrive> apfelmus: hmm.  well, I was just thinking Q.  so a vector in Q^N, after "clearing denominators", get something in Z^N...maybe that?
05:41:48 <vegai> ok, I won't waste time even fantasizing about it, then :) good luck to ya (and other applicants)
05:41:51 <shapr> vegai: I'd be especially happy as part of that job is interfacing with the community and knowing lots of details about GHC and Haskell.
05:42:11 <shapr> vegai: You should apply, you may have just the combination of skills and experience needed.
05:42:14 <int-e> > showHex 123 ""
05:42:14 <dropdrive> apfelmus: maybe...maybe not...
05:42:15 <lambdabot>  "7b"
05:42:37 <int-e> Beelsebob: (showHex in the Numeric module)
05:43:01 <beelsebob_> ah, cool :)
05:43:41 <int-e> > showHex 971746 " and then there comes some more text."
05:43:42 <lambdabot>  "ed3e2 and then there comes some more text."
05:44:30 <vegai> shapr: I suppose it would harm little.
05:45:44 <shapr> The more people that apply, the more likelihood the community gets the right person.
05:46:40 <lisppaste2> dmhouse pasted "erroneous haddock docstring" at http://paste.lisp.org/display/21399
05:46:49 <dmhouse> Any Haddock experts around to look at that?
05:46:54 <apfelmus> dropdrive: mh, inverting matrices over Q by resorting to inversion over N/pN seems to be doomed. the zero entries A*A^-1 modulo p are difficult to squeeze to zeros in N or Q. but perhaps, there is a very clever way
05:47:26 <shapr> dmhouse: What error do you get?
05:47:38 <dmhouse> 51:1: parse error in doc string: [TokBirdTrack " [1..10] !!! [5]      ==   [6]\n",TokBirdTrack " [1..10] !!! [5, 6]   ==   [6,7]\n",TokBirdTrack " [1..10] !!! [5..8]   ==   [6,7,8,9]\n"]
05:47:41 <roconnor> I'm inverting over CReal
05:48:34 <dropdrive> apfelmus: doomed, as in it won't work, or doomed, as in there'll still be huge numbers, and it won't be any faster?
05:48:45 <dmhouse> shapr, Ah, never mind. You need a blank line before and after any bird tracks, apparently.
05:48:55 <apfelmus> dropdrive: the first doom.
05:50:31 <dropdrive> apfelmus: what do you mean by squeezing to zero?
05:51:17 <dropdrive> roconnor: if you ever come across or write matrix manipulation code written in haskell, i'd like to see it.
05:52:10 <shapr> dropdrive: http://www.google.com/search?q=filetype%3Ahs%20matrix%20manipulation
05:52:11 <lambdabot> Title: "filetype:hs matrix manipulation - Google Search"
05:52:25 <apfelmus> dropdrive: just "making zero". a zero in Z/pZ is no zero in Z, only a multiple of p.
05:53:27 <apfelmus> dropdrive, roconnor: /usr/lib/hugs/demos/Matrix.hs
05:56:00 <dropdrive> thanks for the link, guys.
05:56:48 <dropdrive> right, so if I tell you x=0(mod 7), and x=1(mod 3), that's still okay, right?
06:02:14 * beelsebob_ wonders if there's a simple networking library for Haskell
06:02:34 <beelsebob_> I just need to be able to open a connection to server:port send some data and wait for a response
06:02:45 <BCoppens> @hoogle Network
06:02:46 <lambdabot> Network :: module
06:02:46 <lambdabot> Data.Graph.Inductive.Query.MaxFlow2.Network :: type Network
06:02:46 <lambdabot> Network.BSD.NetworkEntry :: NetworkName -> [NetworkName] -> Family -> NetworkAddr -> NetworkEntry
06:03:17 <BCoppens> it's really basic and really simple
06:03:17 <beelsebob_> ah, makes sense
06:03:22 <BCoppens> :)
06:03:28 * beelsebob_ wonders why he couldn't find it in the docs
06:04:31 <BCoppens> just don't forget to use no buffering ;)
06:05:48 <beelsebob_> hmm? why for?
06:05:52 <beelsebob_> I'm sending newlines
06:05:57 <beelsebob_> so buffering shouldn't matter
06:06:05 <apfelmus> dropdrive: then i know x /= 0. knowing that an off diagonal element in the identity matrix A*A^{-1} \in (Z/mZ)^(n \times n) corresponds to 0 in Z is a bit harder.
06:06:21 <BCoppens> I don't know, but when I tried it without explicitly switching it off, it didn't send my stuff to the irc server
06:06:36 <BCoppens> hence the irc server disconnected me because it thought the connection timed out ;)
06:07:31 <beelsebob_> I suspect all I need is sendTo and recvFrom
06:07:55 <beelsebob_> as all I'm doing is sending a POST to an HTTP server and getting back simple data
06:08:03 <BCoppens> I don't think that'll work out
06:08:13 <beelsebob_> hmmm?
06:08:13 <BCoppens> at least that's what I thought after reading
06:08:21 <beelsebob_> why for?
06:08:25 <BCoppens> I thought that was more UDP-like
06:09:00 <BCoppens> 'Their use is strongly discouraged except for small test-applications or invocations from the command line.'
06:09:00 <beelsebob_> possibly
06:09:12 <beelsebob_> well... this is gonna be a command line LJ client
06:09:13 <BCoppens> just use connectTo ;)
06:09:20 <beelsebob_> all it needs to do is send a login, and a message
06:09:24 <beelsebob_> and grab back an OX
06:09:25 <beelsebob_> OK*
06:09:50 <BCoppens> 'These should normally only be used where the socket will not be required for further calls' <- that's why I think you can't actually read back data after sending
06:10:05 <beelsebob_> possibly
06:10:17 <beelsebob_> yeh, connect to may be my best bet
06:10:21 <BCoppens> :)
06:10:25 * beelsebob_ reads the IO Handle docs
06:10:29 * apfelmus is eaten by a grue
06:13:25 * a_grue is eaten
06:13:54 * BCoppens notes that was the first time he was actually able to help someone with haskell =)
06:14:04 <Beelsebob|Lappy> :)
06:14:13 <BCoppens> :)
06:14:21 <Beelsebob|Lappy> first time I've done anything network based in any language
06:14:30 <BCoppens> :)
06:14:42 * BCoppens doesn't do much networking stuff either
06:14:52 <dropdrive> apfelmus: oh, i see.  well, that's always going to be a problem.  i was thinking that if one could get a bound on the size of the entries of A^-1 (if we did matrix inversion over Q), and we inverted at enough primes, then having x=0 (mod all those primes) would in fact say that x is 0 (in Z).
06:29:38 <koffein> hi
06:30:09 <koffein> is there a way to check for the type of a variable at runtime?
06:31:06 <good_boy> variable?
06:31:19 <koffein> eg. if I have used read on a stuff <- getLine and don't know what it is
06:31:30 <koffein> yes I know.. no destructive update
06:31:47 <koffein> didn't have a better word
06:31:59 <good_boy> getLine returns always String afaik
06:32:04 <koffein> yes
06:32:18 <koffein> but if I do a read getLine
06:32:29 <koffein> then it gives me an integer for "1234"
06:32:43 <koffein> and I want to check for it's type
06:32:45 <good_boy> isInteger
06:32:47 <good_boy> i guess
06:32:52 <koffein> ok
06:32:53 <koffein> thanks
06:33:07 <good_boy> isNumber
06:33:25 <koffein> I only know :t.. but that is for the interactive prompt
06:34:45 <koffein> and is there a fuction that just gives me the type so I can compare it with == ?
06:35:03 <koffein> like type() in python
06:35:39 <dmhouse> koffein: What do you want to do, more generally?
06:35:55 <dmhouse> There's no way to do exactly that, but I bet there's a way so solve your wider problem.
06:41:07 <Beelsebob|Lappy> win
06:41:24 <Beelsebob|Lappy> got sensible response from LJ servers :)
06:45:20 * dmhouse wonders why he can't make a successful POST request with Network.HTTP
06:45:31 <dmhouse> It just seems to send a GET, afaict.
06:47:48 <BCoppens> cool, Network.HTTP exists
06:47:59 <BCoppens> that would have saved me writing my own HTTP requests =)
06:48:12 <dmhouse> Well, it doesn't come with GHC.
06:48:14 <Beelsebob|Lappy> dmhouse: it seems to work for me
06:48:21 <Beelsebob|Lappy> I manually constructed the POST
06:48:28 <dmhouse> Beelsebob|Lappy: Can I see your Request?
06:48:30 <Beelsebob|Lappy> and sent it using connectTo
06:48:38 <Beelsebob|Lappy> dmhouse: give me two secs
06:48:43 <dmhouse> Hrm, I'm using simpleHTTP, but it should still work.
06:49:34 <Beelsebob|Lappy> dmhouse: http://www.cs.kent.ac.uk/people/rpg/tatd2/Networking.hs
06:49:43 <Beelsebob|Lappy> and http://www.cs.kent.ac.uk/people/rpg/tatd2/Backend.hs
06:49:55 <BCoppens> dmhouse: ahh
06:50:07 <dmhouse> BCoppens: haskell.org/http
06:50:30 <dmhouse> Beelsebob|Lappy: Ah, so you're not actually using Network.HTTP at all.
06:50:31 <BCoppens> dmhouse: cool, thanks :D
06:50:37 <Beelsebob|Lappy> dmhouse: nope
06:50:39 <Beelsebob|Lappy> not at all
06:59:05 <roconnor> What is echelon form of a Matrix?
06:59:11 <vincenz> koffein: ping
06:59:43 <vincenz> koffein: read reads an integer because you're using the output as an integer.... not because it decodes the integer in the string... types are not polymorphic
07:02:49 <roconnor> I'm not certain the Hugs Matrix demo implements matrix inverse.
07:04:11 <mahogny> roconnor, google. it's very basic linear algebra. you use for solving systems with gauss
07:07:36 * roconnor thinks of his numerical computing textbook back in Canada.
07:08:37 * Beelsebob|Lappy poiks TwigEther 
07:08:49 <TwigEther> heya o/
07:09:46 <Beelsebob|Lappy> TwigEther: sample code for networking at http://www.cs.kent.ac.uk/people/rpg/tatd2/Networking.hs
07:42:11 <dons> moin
07:42:26 <dons> ?uptime
07:42:26 <lambdabot> uptime: 2 days, 8 minutes and 13 seconds
07:54:13 <dons> ?quit new code
07:54:33 <shapr> g'day dons
07:55:07 <dons> hey shapr
07:55:57 <vegai> I've been away from the community for a while... has yhc progressed much?
07:56:14 <dons> i've just automated 70% of the work involved in preparing hwn, shapr, so hopefully it saves me more time, and i can get it out on time each week :)
07:56:29 * dons <- fan of automation
07:58:04 <shapr> awesome!
07:58:18 <shapr> I'm a fan of automation too. I need to automate my bill sending process....
07:58:23 <shapr> What else do you automate?
07:58:35 <shapr> I should automate my X startup, I always start the same apps in the same ion workspaces.
07:58:39 <dons> the trick was to define a custom type to represent an HWN edition, and the tools then generate the .txt , .html and .wiki versions, as well as archiving and spell checking
07:58:58 <dons> so hwn is now prepared by writing a Haskell file with a value of type :: HWN :)
07:58:59 <shapr> That's way cool.
07:59:03 <vegai> automating client/project gathering (without being evil) would be awesome
07:59:42 <dons> i automated submission of progress reports to my supervisor. involved similar tricks with archiving, html and mailing lists
08:00:14 <shapr> Oh hey, I've been thinking about darcs repos for distributed collaboration, any thoughts on the matter?
08:00:33 <dons> well, that's what is for, right?
08:00:43 <dons> or you mean wiki/document collaboratoin?
08:00:45 <shapr> Concretely, what about making a darcs repo the store for mailing list, wiki etc?
08:00:48 <shapr> yeah
08:01:04 <dons> it would be good if the haskell wiki was backed up to a darcs repo
08:01:15 <dons> i keep my wiki contributions in darcs, and just sync from that when uploading
08:01:30 <shapr> In which case the wiki becomes a view on your repo.
08:01:35 <dons> yeah
08:01:51 <dons> its a good structure. i'm kinda surprised wikis don't have this concept of 'repo'
08:01:54 <shapr> I was thinking about LtU in the same way... there's no threading of articles or searching by member.
08:02:20 <shapr> Also, wikirepos could be pull only so that spam is easily found and eradicated.
08:02:34 <shapr> This was one of the ideas behind FLM...
08:02:43 <dons> for serious contributors, working offline, having access to the entire src, is useful. the web interface is not good for some use cases.
08:02:46 <dons> yeah. that's a nice idea
08:03:15 <shapr> Do you think darcs could handle several hundred users making changes without exploding?
08:03:28 <resiak> ikiwiki is a wiki backed by SVN. A darcs backend is on my TODO for the summer =)
08:03:32 <dons> hmm. i _think_ so.
08:03:41 <dons> res	oh, cool.
08:03:43 * dons notes this down
08:03:45 <shapr> yeah, nifty
08:04:09 <dons> resiak, i mean. /me is slow on the tab
08:04:19 <resiak> If someone else wants to write the darcs backend before I do I won't complain ;)
08:04:35 <dons> well, there are svn to darcs tools, no?
08:04:35 <shapr> Is ikiwiki written in Haskell?
08:04:57 <resiak> No, in Perl
08:05:00 <dons> is it feasible to sync between svn and darcs regularly (on every patch?)
08:05:03 <dons> propbably not, i suppose.
08:05:24 <dons> shapr, a haskell wiki would be prettiwiki, not iki ;)
08:05:28 <Lemmih> dons, dcoutts: gour says hi.
08:05:40 <dons> hey gour. :}
08:06:07 <shapr> hah
08:06:15 <shapr> Is gour there in person with you?
08:06:19 <Lemmih> He'll be in India for two more weeks.
08:06:22 <shapr> bok gour!
08:06:25 <Lemmih> Nope.
08:06:39 <dons> ah, that's right. he's in india.
08:07:02 <dons> for a while now, it seems. (?)
08:09:40 <dons> @seen sjanssen
08:09:40 <lambdabot> I saw sjanssen leaving #haskell 7 days, 12 hours, 6 minutes and 43 seconds ago, and .
08:10:47 <zacch> @seen monochrome
08:10:47 <lambdabot> I haven't seen monochrome.
08:11:04 <zacch> @seen monochrom
08:11:04 <lambdabot> I saw monochrom leaving #haskell-blah and #haskell 1 day, 18 hours, 22 minutes and 57 seconds ago, and .
08:15:56 <shapr> That's weird.
08:16:50 * shapr wishes for SerDBTH
08:17:07 <shapr> It's a pain in the butt to write your own database table descriptions for value persistence.
08:19:01 <mnislaih> Lemmih: do you think I can bother you for a while with questions ?
08:23:26 <Lemmih> mnislaih: Yeah, sure.
08:36:59 <_xX[ReP]Xx_> hm
08:39:22 <pejo> shapr, there is an archive indexed by member for LtU
08:41:33 <shapr> Yeah, good pont.
08:41:34 <shapr> point
08:48:56 <Dino_> Sometimes I do need to see a file from way back in source control, like at a specific moment in time. Is that doable with darcs?
08:49:24 <lispy> Dino_: yes and no
08:49:38 <vincenz> damn
08:49:43 <vincenz> packing sucks
08:49:53 <lispy> Dino_: if you can find it using darcs trackdown then it's easy, otherwise i don't know an easy way.  Although, it is easy to look at a patch from way back
08:49:59 <lispy> vincenz: yes, it really does
08:51:11 <lispy> Dino_: one way to look at a file from a specific time might be accomplished by making a copy of the repo and then unrecording all patches created after a certain date, and that _i think_ can be automated
08:51:22 <vincenz> lispy: I'm moving
08:51:23 <Dino_> Sounds clunky.
08:52:03 <lispy> Dino_: darcs motto could easly be: hackers wanted :)
08:52:16 <lispy> vincenz: yay for moving! I just did that 2 months ago
08:52:34 <lispy> vincenz: and i assume i'll do it again in 7 months :)
08:52:36 <Dino_> Thanks for the information.
08:52:36 * vincenz is throwing away 5 mice and two old keyboards
08:52:43 <vincenz> Now.... powercables (computer ones)
08:52:48 <vincenz> how many shoudl one sanely keep
08:52:54 <vincenz> Same for usb-cables
08:53:05 * vincenz has like 4 usb-cables and >7 powercable
08:53:20 <lispy> i'd say keep one or two extra
08:53:39 <lispy> i had a job once where we had an entire bucket full of powercables
08:53:50 <lispy> more of a barrel really
08:54:06 <vincenz> just toss em?
08:54:43 <lispy> do you have a charitable organization that will accept them?  we tend to 'good will' them where i live
08:55:01 <vincenz> well I'm also tossing a 586
08:55:02 <vincenz> erm
08:55:04 <vincenz> 486
08:55:09 * vincenz has no means of transportation
08:55:10 <Dino_> lispy: I didn't know you can use a date to specify things, like for unrecord. Do you know which switch does that?
08:56:24 <lispy> Dino_: look at darcs unrecord --help, which shows you --from-match and then check the manual (I used from-match once but i forget the syntax for dates)
08:56:44 <Dino_> So it's the --*match switch.
08:56:56 <lispy> yeah
08:57:06 <lispy> ask in #darcs if you get stuck or on the darcs mail list
08:57:07 <Dino_> That wasn't at all clear from the -h
08:57:38 <lispy> what would have made it clearer?
08:58:15 <Dino_> --*patch means from a patch. --*tag means from a tag. But I didn't know what --*match was referring to. Just the log? The short desc?
08:58:47 <lispy> ah, yeah i think match covers the patch name and summary/log entry
08:58:51 <lispy> but i forget too
08:59:17 <lispy> actually i think there is a little query language that decides those details
08:59:44 <Dino_> I was initially very nervous at the idea of having no rev numbers. But being able to isolate things by date/time pretty much takes care of that when needed.
09:00:10 <lispy> yup, i had a similar experience
09:00:28 <Dino_> Of course, with distributedness, I certainly see the impossibility of maintaining consistent rev numbers.
09:00:56 <Dino_> Ok, thank you.
09:01:17 <lispy> yw
09:09:59 <vincenz> hmm
09:14:13 * vincenz tosses 3 nokia chargers
09:14:23 <vincenz> and a siemens charger as well
09:14:27 <vincenz> damn I have a lot of crap
09:30:40 <petekaz> @google nokia 770 tablet
09:30:44 <lambdabot> search module failed: IRCRaised Maybe.fromJust: Nothing
09:37:15 <wilx> A bug? :)
09:38:34 <petekaz> yeah, I must have goofed something on my last change.
09:38:43 <petekaz> @google haskell school of expression
09:38:45 <lambdabot> http://www.haskell.org/soe/
09:38:45 <lambdabot> Title: "Home Page"
09:39:06 <petekaz> at least it works sometimes ... I'll fix it.
09:49:23 <petekaz> I found my bug.
09:50:52 <petekaz> I had assumed that a Location header in an HTTP 3xx response was a fully qualified URL like 'http://www.example.com/blah', but sometimes it comes back as '/blah' only, and parseURI in Network.URI does not like that.
09:51:09 <petekaz> At least this is my theory so far.
10:55:14 <alec> :t many1
10:55:18 <alec> > :t many1
10:55:18 <lambdabot>  Parse error
11:08:19 <petekaz> @tell dons I just sent a patch for an issue with my url title chasing library.  It never manifested itself until today.  If anyone complains that @google fails sometimes, it's due to this issue.  Basically, some people violate the HTTP spec and do not send absolute URIs in Location headers (used for a redirect).  In any case, this should take care of the issue.
11:08:20 <lambdabot> Consider it noted.
11:37:44 <vincenz_> crap
11:37:49 <vincenz_> ordered a book twice from amazon
11:38:41 <koffein> what book?
11:39:54 <lispy> yeah, if it's a good book you have have them send one copy to my place instead ;)
11:43:17 <vincenz_> I'll return it
11:43:27 <vincenz_> Just pisses me off cause one of them was ordered as a separate item
11:43:35 <vincenz_> so I paid transportation costs :
11:43:35 <vincenz_> :/
11:47:34 <vincenz_> the book is "Small Worlds: The Dynamics of Networks Between Order and Randomness (Princeton Studies in Complexity)" from Duncan Watts
11:53:47 <RyanT5000> is there a "standard" way of making OS-specific build options?
12:01:23 <pejo> RyanT5000, configure scripts, but they test for existence/lack of features, not for operating systems.
12:02:08 <apfelmus> RyanT5000: gnu autoconf?
12:03:47 <RyanT5000> unfortunately my main target is windows, which makes all of that kind of annoying
12:04:06 <RyanT5000> maybe that's a job for TH some day
12:07:55 <pejo> Is different versions of Windows that different?
12:08:35 <RyanT5000> no - i want to be able to configure between windows and X
12:08:45 <RyanT5000> but configure scripts have a tendency to suck on windows
12:09:30 <RyanT5000> almost nothing compiles well on both windows and *nix
12:10:58 <shapr> OOP really makes life difficult sometimes.
12:13:35 <shapr> salut Purice 
12:14:00 <Purice> salut
12:15:10 <pejo> RyanT5000, isn't that becuase most people who write configure scripts don't run windows themselves, so there is a lack of testing?
12:16:10 <RyanT5000> yep
12:16:19 <ndm> RyanT5000: have you seen Scons?
12:16:30 <RyanT5000> also because most shell scripting stuff doesn't translate well to windows' command-line environment
12:16:33 <ndm> thats a Windows/Mac/Linux build environment
12:16:37 <ndm> based on python
12:16:42 <ndm> so works quite well portably
12:16:57 <RyanT5000> windows doesn't even have the most basic scripting constructs
12:16:59 <RyanT5000> hm i'll try it
12:17:09 <ndm> thats what Yhc has moved to, specifically to get easy windows/linux portability
12:21:33 <SamB> ick
12:22:02 <SamB> it doesn't seem to support build tools that need to be built so you can build things with them very well :-(
12:23:06 <ndm> SamB, example? we had success with Yhc, which requires the compiler to be built to build the libraries
12:23:27 <SamB> well, maybe it was more of an issue with the documentation
12:23:48 <SamB> if you explain how to do it, maybe I can fix ZSNES's SConsfile
12:25:04 <ndm> sorry, I don't even know python - its someone else who did it all
12:25:32 <ndm> but i have seen two projects with that requirement, and neither mentioned it as being a challenge
12:25:33 <SamB> oh well
12:25:40 <SamB> I have a debugger port to work on anyway
12:26:00 <ndm> maybe if you look at the scons files in the repo
12:26:42 * SamB is a bit aprehensive about what he might find if he did that
12:26:55 <SamB> because I *do* know python
12:27:18 <SamB> or at least I think I do, I'm not entirely sure I haven't forgotten
12:28:22 <ndm> from the york fp page, there is both Yam and Yhc, both of which use Scons
12:28:35 * SamB just got commit access to ZSNES because he is porting dos/debug.asm to C ;-)
12:28:45 <ndm> one might be easier than the other to understand, since they were done by different people
12:29:34 <ndm> cool, i can't believe there is much asm left out there, but I guess ZSNES woulld be the place for it
12:29:48 <SamB> there is plenty more
12:30:31 <SamB> from the TOPIC: "ZSNES - The Super Nintendo Emulator made of 79.4876% x86 assembly"
12:30:54 <SamB> though of course that does not account for shrinkage in porting
12:31:21 <RyanT5000> ew
12:31:23 <RyanT5000> why so much asm?
12:31:34 <RyanT5000> i understand some, especially if you're doing binary translation or something
12:31:37 <SamB> well, it was started a long time back
12:31:56 <SamB> originally it was just for DOS -- you should be glad it is 32-bit assembler!
12:31:56 <RyanT5000> does it use binary translation? because that would be really cool
12:32:03 <SamB> no, it doesn't
12:32:17 <SamB> I don't think anyone does that in ASM anymore ;-)
12:32:29 <RyanT5000> true, but you might need snippets of asm for it
12:32:38 <SamB> well, yeah
12:33:10 <SamB> you do need snippets of code in ASM or machine code, generally
12:33:26 <RyanT5000> don't get me wrong, i thoroughly enjoy programming in asm, but i wouldn't want to do anything that big in it
12:33:28 <SamB> but that does not account for 79%
12:33:32 <RyanT5000> right
12:33:50 <SamB> well, anyway, this was started years ago, on 486 or early early pentium
12:34:03 <RyanT5000> yeah, every cycle counts
12:35:52 <SamB> and for some reason they used ASM just about throughout. it has been said (by leading ZSNES developers) that it has been an example of how not to write [something]
12:36:03 * SamB forgets what it was an example of how not to write
12:38:20 <ndm> yeah, in the same way that Yhc is the perfect example of how not to write a Haskell program...
12:39:14 <SamB> its really appalling -- essentially none of the routines seem to document their calling conventions
12:39:25 <RyanT5000> lol
12:39:48 <RyanT5000> you mean "reverse-engineer it yourself" isn't an acceptable documentation format?
12:40:25 <RyanT5000> how much code is it?
12:40:29 <ndm> RyanT5000: reverse engineer a 12 element return tuple :)
12:40:47 <RyanT5000> ndm, i was being sarcastic :P
12:40:50 <ndm> without an explicit type signature, or course...
12:40:52 <ndm> i guessed :)
12:40:53 <SamB> anyway, as the fact that the percentage in the TOPIC might suggest, we are trying to lower it ;-)
12:46:27 <Beelsebob|Lappy> @hoogle [a] -> Bool
12:46:29 <lambdabot> Prelude.null :: [a] -> Bool
12:46:29 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
12:46:29 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
12:55:29 <ndm> Beelsebob|Lappy: what function were you after with that search?
12:55:51 <ndm> I can't believe you were searching for null by type!
12:56:21 <ndm> and theorems for free says that the only function with that type must be on the shape/length of the list
13:00:42 <jer> @hoogle flip
13:00:43 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
13:05:18 <vincenz> @all-dict rummaging
13:05:20 <lambdabot> *** "Rummaging" gcide "The Collaborative International Dictionary of English v.0.48"
13:05:21 <lambdabot> Rummage \Rum"mage\, v. t. [imp. & p. p. {Rummaged}; p. pr. & vb.
13:05:21 <lambdabot>   n. {Rummaging}.]
13:05:21 <lambdabot>   1. (Naut.) To make room in, as a ship, for the cargo; to move
13:05:21 <lambdabot>    about, as packages, ballast, so as to permit close
13:05:22 <lambdabot> [24 @more lines]
13:14:55 <dfeuer> I'm trying to understand what GADTs give that type classes + existential types don't.
13:15:13 <dfeuer> @vixen What's that?
13:15:13 <lambdabot> whoa whoa whoa, one question at a time!
13:15:21 <dfeuer> @vixen Who said that?
13:15:21 <lambdabot> why don't you guess?
13:15:38 <shapr> bringert: Hey, what about an upload dir for blog entries? I have this urge to import everything from PLog and my livejournal. Maybe I should just batch copy them instead?
13:15:52 <dfeuer> @"3"
13:15:52 <lambdabot> Unknown command, try @list
13:15:56 <dfeuer> > "3"
13:15:58 <lambdabot>  "3"
13:16:04 <dfeuer> > 3
13:16:06 <lambdabot>  3
13:16:14 <bringert> shapr: hmm, maybe an XML-RPC blog API would be the easiest way to do that?
13:16:14 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
13:16:50 <shapr> bringert: Yeah, probably so. But I'll need more html markup before everything will work right.
13:17:03 <bringert> right
13:17:08 <bringert> on the TODO
13:17:22 <shapr> Oh, I started hacking on a TODO module...
13:17:26 <bringert> :-)
13:17:55 <bringert> shapr: contributions to the markup, including rewriting the whole thing or importing something existing, are welcome
13:18:08 <shapr> I quickly realized that it's a pain in the butt to create my own DBDesc for types, I quickly wished for SerTHDB
13:18:34 <shapr> Flippi's markup might work.
13:19:14 <dfeuer> > >
13:19:15 <lambdabot>  Parse error
13:19:20 <dfeuer> > (>)
13:19:22 <lambdabot>  Add a type signature
13:19:32 <dfeuer> > (>) :: Int -> Int -> Bool
13:19:33 <lambdabot>  <Int -> Int -> Bool>
13:20:50 <bringert> shapr: yeah, there should be another abstraction layer on top of HaskellDB for serialization
13:21:12 <bringert> shapr: HwatDB could probably be extended to do most of it
13:21:58 <dfeuer> > module foo where a = "foofoo"
13:21:59 <lambdabot>  Parse error
13:22:00 <shapr> HwatDB?
13:22:12 <dfeuer> module Foo where a = "foofoo"
13:22:19 <dfeuer> >module Foo where a = "foofoo"
13:22:24 <dfeuer> > module Foo where a = "foofoo"
13:22:25 <lambdabot>  Parse error
13:22:28 <bringert> shapr: part of the Haskell webappsframework nibro and I  supervised
13:22:30 <bringert> http://csmisc14.cs.chalmers.se/haskellwebapps/darcs/hwatdb/
13:22:31 <lambdabot> Title: "Index of /haskellwebapps/darcs/hwatdb"
13:23:27 <shapr> Interesting
13:27:17 <bringert> shapr: the darcs version now has local image import, and it is fast
13:28:01 <shapr> spiffy
13:28:33 <dfeuer> @what kind of Haskell do you know?
13:28:34 <lambdabot> I know nothing about kind.
13:28:40 <dfeuer> @What haskell
13:28:41 <lambdabot> http://haskell.org/
13:30:26 <mathewm> @where paste
13:30:27 <lambdabot> http://paste.lisp.org/new/haskell
13:31:46 <lisppaste2> mathewm pasted "silly puzzle code review" at http://paste.lisp.org/display/21412
13:32:25 <mathewm> @pl purse' c v (d:ds) = [ s | i <- [0..c], r <- purse' (c-i) (v-i*d) ds, s <- [ ( replicate i d ) ++ r ], length s == c, foldl (+) 0 s == v ]
13:32:34 <lambdabot> purse' = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . ap ((.) . (.) . (.) . (:) . ((s | i) <-) . enumFromTo 0) . flip ap ((flip ((:) . (s <-) . return . (++ r)
13:32:34 <lambdabot> . replicate i) .) . (. (return . (foldl (+) 0 s ==))) . (:) . (length s ==)) . (ap .) . ((ap .) .) . (((flip .) .) .) . (((((:) .) .) .) .) . (((((r <-) .) .) .) .) . flip flip ((. (i *)) . (-)) . ((
13:32:34 <lambdabot> .) .) . ((.) .) . (. subtract i))
13:32:34 <lambdabot> optimization suspended, use @pl-resume to continue.
13:32:58 <Cale> mathewm: @pl doesn't know about list comprehensions
13:33:11 <mathewm> ok
13:33:59 <mwc> and WHAT a list comprehension!
13:34:32 <mathewm> it isn't very readable, I fear
13:34:34 <Korollary> mathewm: instead of reverse . sort, you can use sortBy
13:35:47 <mathewm> ?hoogle Ordering
13:35:48 <lambdabot> Prelude.Ordering :: data Ordering
13:36:06 <mathewm> ?hoogle a -> a -> Ordering
13:36:07 <lambdabot> Prelude.compare :: Ord a => a -> a -> Ordering
13:36:46 <bringert> shapr: I have been thinking about a general 'item' interface that blog entries, photos etc would implement. Tagging, RSS, per-user lists, range limiting (with next/prev page UI etc.) could all be implemented in terms of that
13:36:47 <xerox> > sortBy (\x y -> compare y x) [1..5]
13:36:48 <lambdabot>  [5,4,3,2,1]
13:37:24 <mathewm> thanks
13:39:08 <xerox> You're welcome.
13:39:32 <dfeuer> Someone tell me about GADTs?
13:40:26 <xerox> <http://haskell.org/ghc/docs/latest/html/users_guide/gadt.html>
13:40:26 <norpan> dfeuer: what about them
13:40:57 <dfeuer> What's the point exactly?
13:40:58 <ndm> > sortBy (flip compare) [1..5]
13:40:59 <lambdabot>  [5,4,3,2,1]
13:41:14 <norpan> dfeuer: the point is to have more flexible type constructors
13:41:16 <dfeuer> And how can a mere mortal understand what type signatures are necessary where/
13:41:17 <dfeuer> ?
13:41:52 <dfeuer> norpan, what might one do with them that couldn't be done with classes & existentials?
13:42:00 <norpan> pattern matching
13:42:07 <xerox> By reading a proper explanation of what problem do the GADT solve.
13:42:29 <mwc> Is there anything on the Wiki about making a haskell binding for a C lib using c2hs?
13:42:41 <dfeuer> Where would I find such a proper explanation?
13:42:54 <mwc> I haven't gotten the hang of searching on the new wiki yet
13:42:58 <xerox> mwc - c2hs has a very good documentation, and provides examples in a directory such as examples/.
13:43:03 <norpan> dfeuer: just look at the example in that page
13:43:41 <mwc> xerox, I had a question the docs didn't cover
13:43:51 <xerox> mwc - What question?
13:44:15 <dfeuer> norpan, couldn't you just make Lit, Succ, etc, be separate types, and make eval a class method?
13:44:17 <mwc> I have a set of API return codes #defined, is there a good way to handle those, or should I create my own Haskell type for the return values and map between the int vals on the C side and the haskell vals
13:44:32 <lisppaste2> mathewm annotated #21412 with "a little clean-up" at http://paste.lisp.org/display/21412#1
13:44:44 <mwc> data FooRet = FooNormal | FooOutOfMem | FooFileError; etc
13:45:10 <dcoutts> mwc, I think the c2hs enum hook was planned but not implemented
13:45:19 <xerox> mwc - I see. C2hs doesn't provide that translation yet, I believe you have to cope it yourself.
13:45:25 <dcoutts> err rather the #define enum hook style
13:45:31 <mwc> dcoutts, it's not really an enum; the functions all return ints
13:45:39 <mwc> dcoutts, yeah, that's what I have
13:45:56 <xerox> Well, it sounds like ERRNO, it would be an enum in the Haskell world.
13:45:57 <mwc> dcoutts, so my above strategy is a good one?
13:46:01 <dcoutts> mwc, yeah, there's no help for that atm
13:46:02 <dcoutts> mwc, yep
13:46:06 <mwc> gear.
13:46:09 <dcoutts> with an Enum instance
13:46:11 <xerox> Wroom.
13:46:12 <dfeuer> norpan?
13:47:25 <mwc> dcoutts, you've hacked on c2hs... any idea how much work it would be to ADD the enum-define hook?
13:47:49 <norpan> dfeuer: but they are not separate types, they are type constructors of the same type
13:48:19 <norpan> namely, the Term type
13:48:33 <dfeuer> Ultimate advantage?
13:49:06 <Korollary> mathewm: that looks about right
13:49:22 <norpan> dfeuer: do you know what a type constructor is
13:49:43 <norpan> GADT just lets you make more powerful type constructors
13:49:46 <dfeuer> norpan, pretty much.
13:51:53 <norpan> i don't know how you mean that you should use type classes, but they are a way to overload functions for DIFFERENT types
13:52:19 <dfeuer> mumble.
13:53:01 <mathewm> Korollary: It seems like my solution might have a "space-leak" - it doesn't crop bad solutions until the very end
13:55:01 <dcoutts> mwc, not really, since it's rather different from the normal stuff since an #define enum isn't represented in the C ast.
13:55:29 <dcoutts> mwc, ask on the c2hs list how hard it'd be
13:55:56 <xerox> It'll have to guess too much in my opinion.
13:58:17 <mwc> dcoutts, I see what you mean: at the very least, I'd need to write a preprocessor parser
13:58:31 <dcoutts> mwc, not necessarily
13:58:42 <dcoutts> mwc, but you'd need to specify all the names
13:59:04 <dcoutts> since there's now way to automatically pick then up, as there is with a real enum
13:59:08 <mwc> yeah, since you couldn't determine which constant belongs to which pseudo-enum
13:59:11 <dcoutts> right
13:59:25 <dcoutts> unless it was a regex or something dodgy
13:59:32 <xerox> That's what I meant by guessing, one could try checking for similar prefix, but well.
13:59:35 <dcoutts> FOOBAR_BLAH_*
14:00:11 <mwc> but I mean, what about something like #ifdef UNIX ; #define IOERR = 32; #elseif WINDOWS; #define IOERR = 22 #endif
14:00:45 <mwc> That's contrived, but I can see something similar in structure happening somewhere\
14:01:08 <mwc> you'd have to handle that by running a preprocessing pass and holding all the #define mappings
14:01:16 <dcoutts> so as long as you specify the name you're after I think we could get it's value easily enough
14:01:26 <mwc> then pass the preprocessed code through the regular c2hs processor, and those mapping as well
14:01:47 <mwc> I wonder if there's a way to get cpp to dump all its defines...
14:02:06 <dfeuer> norpan, how would you extend the basic interpreter in the GADT paper to deal with variables and abstractions?  What type do variables have?
14:02:15 <dcoutts> mwc, let foo = FOOBAR_BLAH
14:02:34 <dcoutts> mwc, if we know the name, then c2hs can do somthing to get the value
14:02:40 <norpan> dfeuer: what type they have? they would be Terms too i suppose
14:02:50 <dcoutts> we just generate some code and pass that through cpp too
14:02:51 <dfeuer> mm-hmm.....
14:02:55 <norpan> Term Whatevertypethevariable is
14:03:17 <dfeuer> So to construct a variable you have to infer its type?
14:03:55 <mwc> dcoutts, that's true, but where do you put those definitions? What if you get them between the wrong #ifdef #elseif pair?
14:03:59 <norpan> well, you need to know it's type anyway
14:04:03 <norpan> its
14:04:04 <dfeuer> Guess so.
14:04:15 <mwc> I'm gonna go think on that
14:04:19 <norpan> Term a means a term of type a
14:04:20 <dcoutts> mwc, #ifdef what?
14:04:44 <dcoutts> mwc, are you talking aobut preprocessing the .chs files ?
14:04:46 <mwc> Well, I thought you were talking about putting c declarations to capture the value of the define to a constant
14:04:51 <norpan> so Var :: String -> Term a
14:04:57 <mwc> apparently I misunderstood
14:04:57 <dfeuer> yah...
14:05:03 <dfeuer> sorta...
14:05:15 <mwc> the let didn't clue me in you were talking about the .chs file
14:05:20 <dfeuer> hmm
14:05:26 <mwc> I see what you're saying now
14:05:28 <dmhouse> Are (n+k) patterns the only case where you can pattern match using something that isn't a constructor?
14:05:54 <dfeuer> n+k patterns are EEEEEvil
14:06:13 <dcoutts> mwc, manuel had some plan for them, but I don't know it exactly
14:06:17 <dmhouse> Yes they are. Back to my question. :)
14:06:28 <dfeuer> I wonder if GHC has an option to disallow the things.
14:06:36 <dcoutts> mwc, c2hs already generates a .h file based on stuff in the .chs file
14:06:42 <dmhouse> dfeuer: Why would you want to? Just don't use them.
14:06:47 <dfeuer> dmhouse, someone mentioned ++ patterns.
14:06:56 <dmhouse> They don't exist.
14:06:57 <dcoutts> mwc, eg you can specify #c .. #endc and other simple #ifs
14:07:01 <dfeuer> eh
14:07:20 <dmhouse> > let dropTwo ([_,_]++xs) = xs in dropTwo [1..10]
14:07:20 <lambdabot>  Parse error in pattern
14:07:27 <dcoutts> mwc, so I'd imagine one could get the values of #defines in a similar way
14:07:42 <dmhouse> dfeuer: just that sometimes they'd be convenient.
14:07:46 <norpan> [_,_] is just syntactic sugar
14:07:55 <norpan> n+k patterns are a bit more than that
14:08:11 <dmhouse> norpan: I was illustrating the nonexistance of ++ patterns.
14:08:19 <dfeuer> > let dropTwo ([_1,_2] ++ xs) = xs in dropTwo [1..10]
14:08:20 <lambdabot>  Parse error in pattern
14:08:23 <Cale> f (x ++ y) = y ++ x
14:08:27 <Cale> what would that do?
14:08:33 <dfeuer> Maybe it's in some funk-ass implementation?
14:08:37 <norpan> dmhouse: well, yes, but the ++ pattern would be syntactic sugar there too
14:08:47 <norpan> you can do it in Curry :)
14:08:54 <norpan> almost
14:09:00 * dfeuer wants to eat curry.
14:09:37 <dmhouse> Cale, f (n+k) = k + n. What would that do? (Okay, nothing, because (+) is commutative, but you get the picture.)
14:11:00 <norpan> the k has to be constant, but it's still more than pure sugar
14:11:07 <dmhouse> norpan: Yep.
14:11:12 <norpan> it matches AND subtracts
14:11:34 <dmhouse> Oh, k is a literal. Didn't know that.
14:11:56 <norpan> yeah, literal, constant, whatever :)
14:12:12 <dmhouse> norpan: More to the point, you can't reduce (n+k) patterns to some equivalent pattern without changing the RHS of the equation.
14:12:57 <norpan> dmhouse: well, you can do f n' | n <- n' - k =
14:13:22 <norpan> not h98 but anyway
14:13:22 <dmhouse> Only if you cheat :)
14:13:37 * dfeuer thinks pattern guards are much nicer than n+k patterns.
14:13:48 <norpan> nicer = more powerful :)
14:14:01 <dmhouse> Or indeed, using transformation patterns, f n'!(subtract k) = ...
14:14:02 <dfeuer> nicer = not a wacko special case.
14:14:07 <dmhouse> (I think I got that right.)
14:14:07 * vincenz smacks a random person
14:14:21 <Cale> dmhouse: ++ isn't commutative
14:14:31 <dmhouse> Cale, I never said it was.
14:14:40 <Cale> dmhouse: ah, the x has to be fixed?
14:14:40 <xerox> > let f (n+1) = n in f 1
14:14:41 <lambdabot>  Parse error in pattern
14:14:51 <dfeuer> I think transformational patterns are a little iffier. Might be less iffy if the function returned a Maybe.
14:14:55 <dmhouse> Cale, ?
14:15:01 <Cale> why not just use a guard?
14:15:14 <dmhouse> Cale, I'm very confused.
14:15:31 <dmhouse> Cale, I wasn't countering your point about ++ patterns.
14:15:54 <vincenz> Cale: ++ is associative
14:16:03 <Cale> f y | x `isPrefixOf` y = ...
14:16:21 <vincenz> heh I don't think that should become a pure pattern
14:16:22 <dmhouse> Cale, but bindings...
14:16:27 <xerox> Because pattern matching ought to be powerful!
14:16:34 <dmhouse> Cale, but it could be done with pattern guards regardless.
14:16:51 * vincenz doesn't want a syntax feature that's O(n)
14:17:05 <Cale> dmhouse: well, since you know x, you know its length, and you can just drop that many elements from y
14:17:24 <vincenz> Cale: yeah except you iterate twice over the string
14:17:28 <vincenz> or list
14:17:28 <bringert> dmhouse: I don't think that Network.HTTP looks at robots.txt, nor that it should be default. But it could be a useful optional feature.
14:17:47 <dmhouse> bringert: Okay, thanks. Having difficulties getting a POST request to work with it.
14:18:02 <vincenz> > let x `isPrefixOf` y = or . zipWith (==) x y in [1..3] `isPrefixOf` [1..10]
14:18:02 <lambdabot>    Expecting a function type, but found `[c]'
14:18:02 <lambdabot>    Expected type: a -> [Bo...
14:18:09 <vincenz> > let x `isPrefixOf` y = or $ zipWith (==) x y in [1..3] `isPrefixOf` [1..10]
14:18:10 <lambdabot>  True
14:18:20 <vincenz> nice
14:18:25 <Cale> vincenz: you do?
14:18:34 <vincenz> Cale: oh yeah lazy...hmm duh
14:18:49 <vincenz> Cale: it's still mroe effort tho
14:19:02 <vincenz> Cale: cause internally you're passing along an int... wait you do... lenght goes over it once
14:19:22 <vincenz> my isPrefixOf is commutative \o.
14:19:24 <Cale> vincenz: the length is statically known
14:19:27 <xerox> Err, it should be `and' not `or', shoudn't it?
14:19:28 <dmhouse> > let isPrefixOf = (or .) . zipWith (==) in [3,3,3,4] `isPrefixOf` [1..10]
14:19:29 <lambdabot>  True
14:19:32 <dmhouse> vincenz: ^^ :)
14:19:43 * xerox bounces
14:19:45 <dmhouse> xerox: Right.
14:19:53 <vincenz> whoos
14:20:01 <vincenz> > let x `isPrefixOf` y = and $ zipWith (==) x y in [1..3] `isPrefixOf` [1..10]
14:20:02 <lambdabot>  True
14:20:05 <vincenz> hehe
14:20:10 <dmhouse> > let isPrefixOf = (and .) . zipWith (==) in [3,3,3,4] `isPrefixOf` [1..10]
14:20:11 <lambdabot>  False
14:20:43 <dcoutts> xerox, how's stuff? how's the cabal-get project going?
14:21:35 <xerox> Exams this week! Gurgle. I'll be coding for months after this.
14:21:49 * dfeuer doesn't get WTF the Haskell people were thinking when they said String = [Char]
14:22:07 <dmhouse> dfeuer: ... What?
14:22:08 <xerox> `A string is a list of chars,' more or less.
14:22:11 <dfeuer> > head "foo"
14:22:12 <lambdabot>  'f'
14:22:14 * xerox grins
14:22:16 <dfeuer> No no no!!!!
14:22:19 <SamB> dfeuer: it makes perfect sense
14:22:20 <vincenz> o.O
14:22:28 <SamB> if you aren't worried about performance, that is
14:22:32 <dmhouse> String = [Char] is one of the most useful things in Haskell, given the wealth of list manipulation functions.
14:22:43 <dfeuer> It /would/ make sense if a list weren't (:)|[]
14:23:03 <dmhouse> dfeuer: What on earth are you talking about?
14:23:10 <xerox> Data.Ropes will give some nice big-theta for common *string* functions, like concatenation.
14:23:11 <SamB> and they /are/ *lazy* strings.
14:23:20 <vincenz> xerox: I have my doubts about ropes
14:23:24 <vincenz> xerox: they easily degenerate to lists
14:23:31 <dfeuer> vincenz, ??
14:23:36 <SamB> oh, are ropes like lazy strings?
14:23:39 <dfeuer> nooooo
14:23:42 <vincenz> SamB: ropes are lists of arrays
14:23:53 <dfeuer> no....
14:24:00 <dfeuer> Ropes are trees.
14:24:09 <vincenz> no they're not
14:24:10 <dmhouse> dfeuer: Can you give a valid point as to why String = [Char] is evil?
14:24:19 <dfeuer> They can be concatenated, indexed, substringed.
14:24:28 <vincenz> dfeuer: don't mistake interface with implementation
14:24:34 <dfeuer> vincenz, go re-read the Boehm et al paper on ropes.
14:24:43 <SamB> so are ropes catenable sequences of packed strings?
14:24:52 <xerox> http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf
14:24:59 <vincenz> xerox: tx
14:25:14 <SamB> (in implementation, I mean)
14:25:22 <dfeuer> vincenz, two of the essential aspects of ropes are fast concatenation and fast substring operations.
14:25:30 <vincenz> dfeuer: fne...what I said is then a degneerate case
14:25:39 <vincenz> dfeuer: that is also achieveable with lists of arrays
14:25:41 <vincenz> lists are a degenerate of trees
14:25:50 <dfeuer> vincenz, you can write a bad implementation of anything.
14:26:01 <dfeuer> That doesn't mean the bad implementation should be in the firking standard.
14:26:10 <SamB> aren't they somewhat balanced trees?
14:26:13 <dfeuer> yes.
14:26:24 <vincenz> dfeuer: chil
14:26:37 <xerox> sjassens is implementing them for his Summer of Code project.
14:26:38 <SamB> so, they aren't like [] lists
14:26:43 <SamB> ever
14:26:47 <SamB> unless they are trivial
14:26:56 * dfeuer would've signed up for summer of code if he'd known about it in time.
14:27:01 <dfeuer> Right.
14:27:07 <xerox> SamB - They are meant to be an internal representation for strings.
14:27:13 <dfeuer> But they should support fast head and tail operations.
14:27:39 <xerox> Concatenation and access to i-th element too.
14:27:44 <SamB> you can't have everything!
14:27:50 * dfeuer doesn't quite trust Boehm et al's implementation (too complicated), but loves the idea.
14:27:52 <xerox> Well... and substring (-:
14:28:18 <vincenz> dfeuer: out of curiousity
14:28:28 <vincenz> dfeuer: what does a tree gain you over a list
14:28:38 <dmhouse> dfeuer: You still haven't explained your bones with [Char]. I don't really understand. Is it a performance thing?
14:28:40 <dfeuer> SamB, you kind of can.  Certainly, head, tail, and : are significantly slower than for haskell lists, but if you need flexibility it's there.
14:28:47 <dfeuer> yes.
14:28:51 <dfeuer> It's a performance thing.
14:28:56 <vincenz> Anyways, restating what I said about list.  A rope easily degenerates to a tree, with an array of 1 element at each node
14:29:05 <vincenz> unless you aggressively coalesce
14:29:11 <dfeuer> [Char] has shitty performance for many operations on long strings.
14:29:15 <xerox> Ropes do keep the length of the subtrees in the `concat' nodes. That's the trick.
14:29:20 <dmhouse> Right, okay.
14:29:22 <dfeuer> vincenz, ropes /are/ balanced.
14:29:23 <SamB> vincenz: it wouldn't have to be very aggressive
14:29:41 <vincenz> dfeuer: even if they're balanced, if coalescing is not done, you end up with a balanced tree
14:29:54 <SamB> dfeuer: now vincenz is talking about not lack of balance but too many pieces
14:30:06 <dfeuer> Well, coalescing is done.
14:30:09 <vincenz> yeah, my original statement of list still applies, I thought it was a list iso a tree
14:30:11 <SamB> good ;-)
14:30:17 <dfeuer> ??
14:30:17 <lambdabot> Maybe you meant: . v
14:30:25 <vincenz> dfeuer: that makes sharing more complicated tho
14:30:27 <dfeuer> There's a limit to how long the pieces are allowed to get.
14:30:27 <SamB> dons: please, make it stop!
14:30:40 <vincenz> dfeuer: it's ok in an imperative lang, but in a functional language, sharing is the main way of working with data
14:31:02 <xerox> SamB - Send in a patch that defines a command `?' in the Dummy.hs module which doesn't return anything.
14:31:06 <dfeuer> vincenz, ropes are better for sharing than lists, generally.
14:31:08 <SamB> it is annoying when someone says something consisting entirely of question marks and lambdabot tries to parse it as a command
14:31:14 <vincenz> dfeuer: not if you work with coalescing
14:31:31 <vincenz> unless you want to degenerate to a tree
14:31:39 <SamB> xerox: I have just installed a new GHC, it would take a while to get enough things compiled
14:31:45 <vincenz> at which point there's better trees, like fingertrees
14:31:56 <dfeuer> vincenz, have you read the ropes paper?
14:32:13 <vincenz> enough to grasp the gist
14:32:26 <vincenz> dfeuer: don't forget it's designed for imperative languages, where data structures are not permanent
14:32:47 <vincenz> as soon as ou coalesce in a functional langauge you lose most opportunities of sharing
14:32:49 <dfeuer> I'm not saying that /particular/ implementation is the one to use, but that the idea is a good one.
14:33:01 <vincenz> dfeuer: should take a look at fingertrees
14:33:03 <vincenz> @hoogle fingertree
14:33:04 <lambdabot> No matches found
14:33:05 <dmhouse> If Visual Haskell isn't available, what would people recommend as an editor/compiler combination for Windows?
14:33:18 <dmhouse> @google 2-3 finger trees "Ralf Hinze"
14:33:24 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/talks/Oxford.pdf
14:33:37 <dfeuer> vincenz, whether you do it with ropes, finger trees, Okasaki's catenable lists, or whatever, you could hardly do worse than Haskell does.
14:33:43 <dmhouse> Educational aspects are a bonus.
14:33:49 <SamB> oh, does anyone know if GCC can do tail-call-elimination with void functions?
14:34:21 <vincenz> dfeuer: well I thnk that most list operations should be typeclassed... such that generic algorithms can be ruesed for different implementations
14:34:32 <vincenz> dfeuer: in which case those could structures could be used iso lists
14:34:41 <vincenz> s/could/data/
14:34:47 <dfeuer> ah
14:35:05 <dfeuer> Not a bad thought.
14:35:21 <xerox> ?docs Data.Sequence
14:35:22 <lambdabot> Data.Sequence not available
14:35:24 <xerox> ?docs Data.Foldable
14:35:25 <lambdabot> Data.Foldable not available
14:35:26 <dfeuer> ????
14:35:27 <lambdabot> Unknown command, try @list
14:35:30 <dfeuer> ?!@
14:35:31 <lambdabot> Maybe you meant: . id pl v wn
14:35:33 <xerox> Hmmm.
14:35:34 <dmhouse> I'm off, but if anyone has any comments, @tell me.
14:35:46 <dfeuer> @tell @fish @to @die
14:35:46 <lambdabot> Consider it noted.
14:35:47 <xerox> dmhouse: ask ndm, and don't use hugs ;)
14:35:48 <dmhouse> xerox, linked to 6.4 docs, I would imagine.
14:35:59 <vincenz> dfeuer: researcher?
14:36:10 <dfeuer> vincenz, huh?
14:36:16 <vincenz> doing research?
14:36:19 <dfeuer> No.
14:36:27 <dfeuer> Reading lots.
14:36:31 <vincenz> what year are you in?
14:36:31 <dfeuer> programming some.
14:36:37 <dfeuer> Not currently in school.
14:36:42 * vincenz snaps
14:36:50 * dfeuer sings
14:36:55 <vincenz> Pity
14:37:00 <dfeuer> yah.
14:37:16 <norpan> [Char] rocks
14:37:21 <dfeuer> NOOOOOOO
14:37:23 <norpan> remember that haskell is a lazy language
14:37:30 <vincenz> norpan: so?
14:37:39 <dfeuer> If you want [Char], write [Char]
14:37:42 <vincenz> norpan: like dfeuer states, you lose all sharing on the head of a string
14:38:05 <norpan> but you share the tail
14:38:23 <dfeuer> But that's not a particularly interesting thing for strings.
14:38:42 <xerox> Found!
14:38:47 <xerox> http://haskell.org/ghc/dist/current/docs/libraries/base/Data-Sequence.html
14:38:52 <xerox> http://haskell.org/ghc/dist/current/docs/libraries/base/Data-Foldable.html
14:38:59 <dfeuer> hmm?
14:39:38 <vincenz> Does anyone have any experience with dataflow analysis?
14:39:57 <dfeuer> Nice.
14:40:18 <dfeuer> garbage in, garbage out is about all I know ;-/
14:40:26 <xerox> (><) :: Seq a -> Seq a -> Seq a
14:40:27 <xerox> O(log(min(n1,n2))). Concatenate two sequences.
14:41:09 * dfeuer should go read about cursors
14:41:32 <dcoutts> dfeuer, you're quite right, [Char] is a terrible representation for performance, but it is conveient and simple to teach
14:41:52 <dfeuer> Haskell is anything but simple to teach.
14:42:03 <dcoutts> Haskell98 was designed for simplicity and teaching, not large scale software eng or perf
14:42:11 <dcoutts> dfeuer, I don't think that's true
14:42:16 <xerox> Me neither.
14:42:24 <dfeuer> I sure as hell can't understand the type system.
14:42:32 <dcoutts> I teach Haskell and imperitive and OOP languages
14:42:41 <norpan> well, it's hard to teach what you don't understand of course
14:42:57 <dfeuer> I can make decent guesses, and add annotations when I'm wrong, but I can't really predict when exactly I'll need an annotation.
14:43:04 <dcoutts> dfeuer, perhaps you were familiar with another style first, that always colours one's perception
14:43:27 <Cale> Haskell is certainly no harder than C to learn
14:43:29 <dcoutts> dfeuer, you need to do pretty advanced things to need annotations
14:43:43 <dfeuer> Haskell has many nice features.  Simplicity is not one of them.
14:43:45 <Cale> (and a good deal more powerful)
14:43:57 <dcoutts> dfeuer, I disagree
14:44:19 <dfeuer> If not for call/cc and multiple-value return, Scheme would be extremely simple.
14:44:25 <vincenz> If I have to say one bad thing about haskell, is that so far I haven't found it to scale well yet.
14:44:34 <wolverian> oh, haskell is extremely simple. it's just simple in an utterly alien way to imperative programmers.
14:44:39 <dcoutts> vincenz, for large progs you mean?
14:44:43 <vincenz> dcoutts: yeah
14:44:46 <dfeuer> And it has no proper module system.
14:44:49 <vincenz> dcoutts: the design of my compiler is anything but perfect
14:44:58 <xerox> Once you have the substitution model in place, you're done with evaluation. I believe types make sense at first sight. Then it is just understanding the abstractions?
14:45:04 <dcoutts> dfeuer, yes, that was a flaw in Haskell98
14:45:08 <dfeuer> and there are plenty of non-orthogonal features.
14:45:14 <vincenz> dcoutts: for layered algorithms it's fine, but as soon as different parts share a datastructure it becomes rather annoying
14:45:17 <dfeuer> especially with the class system.
14:46:01 <dfeuer> I think space performance is very hard to understand in Haskell.
14:46:07 * dfeuer goes to do dishes.
14:46:18 <dfeuer> The type system is way fancy.
14:47:27 <vincenz> dfeuer: imagine an oo-syntaxy language without lazyness and that type system
14:48:11 <vincenz> dcoutts: I thnk that moduled typeclasses would be neat
14:48:19 <vincenz> dcoutts: where the methods are belonging to a module
14:48:45 <dcoutts> vincenz, you don't mean finer export/import control on class instances ?
14:49:00 <vincenz> dcoutts: hmm, no, I mean that methods would be namespaced instead of global
14:49:22 <vincenz> same for typeclasses
14:49:45 <dcoutts> vincenz, hmm, for records that makes sense, I don't think it does for class methods
14:49:54 <dcoutts> they should be like ordinary functions
14:50:08 <dcoutts> which we control with the module namespace system
14:50:28 <dcoutts> we should just get used to using more module-qualified names
14:51:34 <dcoutts> possibly allowing modules within a single file might help
14:51:52 <dcoutts> and/or nested modules
14:52:20 <vincenz> yeah
14:52:29 <vincenz> except that nested modules clashes with the file/directory system
14:52:41 <vincenz> and it becomes rather hard with respect to module-corecursion
14:52:46 <vincenz> I used to have module-nesting in my language
14:52:49 <vincenz> then finally dropped it
14:52:54 <vincenz> as it became rather complicated
14:53:08 <vincenz> if you don't allow inner modules to acccess outer modules, nested modules lose their usefulness
14:53:17 <vincenz> if you do allow them too, you easily get module-corecursion
14:53:21 <vincenz> s/too//
14:55:13 <dcoutts> vincenz, though recursive modules are fine of course
14:55:25 <dcoutts> so having them in one file would make it easier
14:55:29 <vincenz> dcoutts: Well only if you compile them in one file
14:55:32 <vincenz> or it gets complicated
14:55:36 <dcoutts> right
14:55:39 <vincenz> then you can just treat it as corecursive funcs
14:55:52 <dcoutts> but ghc already does recursive modules in seperate files (with a little help)
14:55:58 <vincenz> nifty
14:56:09 <dcoutts> h98 allows recursive modules
14:56:18 * vincenz needs typeclasses in his language :/
14:56:36 <dcoutts> vincenz, they do make the type inference much harder
14:56:45 <dcoutts> or rather more complex
14:56:46 <vincenz> recursive modules or typeclasses?
14:56:51 <dcoutts> type classes
14:56:54 <vincenz> yeah I know
14:57:00 <vincenz> THIH is rather big
14:57:02 <dcoutts> most of THIH is type classes
14:57:05 <vincenz> plus it gives no info on how to interpret it
14:57:20 <vincenz> I doo have the advantage that my typeclasses are predefined
14:57:32 <vincenz> there's only 5 of them
14:57:35 <vincenz> Eq and a few custom ones
14:57:50 <vincenz> but to use typeclasses I need data constructors, which I don't have atm and complicate things more than I want it too
14:57:58 <vincenz> (well except tuplification)
15:00:59 <vincenz> dcoutts: have an alternate option?
15:01:09 <dcoutts> alternate option to what?
15:01:15 <vincenz> typeclasses
15:01:19 <vincenz> at the moment I use modules
15:01:51 <vincenz> basically I have a given set of operations in a native data-type... And I overload these in diffrent modules...
15:02:08 <vincenz> well define these ini different modules
15:02:18 <vincenz> except that then I always need to prefix the functons by their module-name
15:02:43 <dcoutts> vincenz, ocaml uses a different system to type classes, you might look at that
15:02:50 <vincenz> functor
15:02:56 <dcoutts> it's more powerful and more complex again
15:03:11 <vincenz> I was hoping to do typeclasses without actually requiring data constructors
15:03:13 <dcoutts> the type extension it uses is 'rows' I think
15:03:35 <vincenz> by assuming that different methods in one module belong to one 'type'
15:03:41 <shapr> bringert: That would be cool.
15:06:08 <vincenz> dcoutts: I think rows are only used for the subtyping of records
15:06:17 <vincenz> dcoutts: not for the part that's supposed to replace type classes, which are functor modules
15:06:38 <dcoutts> vincenz, right
15:10:33 <Pegazus> hi, does anyone know by chance some smalltalk? (smalltalk channel is dead, sorry for asking here) :) i want to know how to define an infix + operator in a class...
15:11:14 <jer> Pegazus, just: + aVar \n \t doStuffWith: aVar \n ^ someValue
15:11:57 <Pegazus> mmm let me try
15:12:33 <Pegazus> thanks :)
15:12:54 <Pegazus> my problem was that i was declaring it as +:    :p
15:13:00 <jer> ah
15:13:10 <jer> nope, + is a binary message, no : (:'s are only for keyword messages)
15:13:20 <jer> i.e., alphanumeric messages with at least one argument
15:16:30 <Pegazus> :) i've just learn that
15:25:44 <clavis> hello everybody
15:26:11 <clavis> helloooooooooooo
15:27:45 <clavis> -NickServ
15:27:48 <Pegazus> another question, how do i "declare" a constructor for a type? i mean, how do i create the "first" time? so i can then modify it and use it?
15:28:09 <clavis> heloooooooo anybody here??
15:28:14 <Pegazus> so i do A := I_WANT_TO_CREATE_A_NEW_TYPE: 1 With: 2.
15:28:20 <Pegazus> (i'm talking in smalltalk)
15:29:13 <clavis> I have a question plz
15:30:26 <jer> Pegazus, here, let's do this in private
15:30:41 <Pegazus> ok! thanks
15:31:23 <clavis> no body wants to answer me or what??
15:31:31 <ndm> clavis: just ask the question
15:31:34 <jer> Pegazus, are you getting my private messages?
15:31:37 <Pegazus> yes
15:31:42 <ndm> we can't answer until we know what hte question is :)
15:31:43 <clavis> thanks
15:31:43 <jer> oh wait
15:31:50 <jer> you're not registered, oen sec; that's why i can't see yours
15:31:52 <clavis> ok ndm
15:31:55 <Pegazus> :(
15:32:18 <clavis> I am newbie in haskell
15:32:37 <clavis> I want to know something about parsing
15:32:38 <jer> clavis, don't ask to ask, if you ahve a question just ask it
15:33:08 <clavis> I have a little piece of haskell code that I want to understand
15:33:17 <ndm> @where paste
15:33:17 <lambdabot> http://paste.lisp.org/new/haskell
15:33:19 <clavis> whatis runIt ??
15:33:28 <ndm> probably easiest if you paste that code there, and we can see
15:33:34 <ndm> runIt is a function defined by the code
15:33:38 <clavis> ok ndm
15:33:44 <lispy> @hoogle runIt
15:33:44 <lambdabot> No matches found
15:33:47 <ndm> it has no "common" meaning
15:33:55 <clavis> I will paste it there
15:34:17 <ndm> lispy, imagine the Haskell designers had specified "runIt", "doThat", "goNow" etc :)
15:35:59 <lisppaste2> clavis pasted "haskell code parsing ?" at http://paste.lisp.org/display/21417
15:36:27 <clavis> ok guys
15:36:31 <clavis> here it is
15:36:44 <clavis> it is a broken code and I must fix it
15:36:58 <clavis> but I don't understand a lot
15:37:10 <clavis> the code is about to find a valid string
15:37:36 <clavis> actually I am participating in a game in internet
15:37:45 <ndm> who wrote that code?
15:37:56 <ndm> ParseLib is relatively old, most people use Parsec now, i think
15:38:10 <clavis> and I have a text file with 3500 strings and have to find the one corresponding to code
15:38:34 <clavis> I tried to compile it with hugs  
15:38:49 <ndm> does it complain it can't find ParseLib?
15:38:51 <clavis> I have parselib.hs
15:39:08 <clavis> but still can't fix the code or understand it well
15:39:33 <ndm> to be honest, i know very little about parser combinators
15:39:52 <clavis> what is "do" "many" ...
15:40:03 <ndm> do is all about monads
15:40:12 <ndm> many is a parser combinator, specifying how to parse something
15:40:12 <clavis> by the way i wish to learn haskell also
15:40:22 <ndm> its probably best to read up on parsec, which is a similar principle
15:40:25 <ndm> the tutorial is quite good
15:40:30 <ndm> @where parsec
15:40:31 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
15:40:36 <clavis> give me the adress plz
15:40:40 <clavis> ok
15:40:53 <clavis> thanks
15:42:33 <lscd> simple newbie question: I'm creating a bunch of data types, using 'data', and I'd like to provide accessors; for ones where I know the exact type in advance and can just say MyTypeConstructor {x::String, y::Int} or similar, it's easy, but I've got one a data type which has two parameters, which should be of the same type; they'll be of class Num (and probably class Fractional), but saying TC {x::Fractional} isn't valid, as Fractional i
15:42:34 <lscd> s a typeclass, not a type; how would people here approach writing an accessor to this? (I could switch to using views, I guess, but that seems like overkill)
15:43:12 <lscd> ndm: hm... i found the parsec tutorial fairly painful, as I couldn't get some of the code in it to run, due to type errors
15:43:23 <lscd> it's a good reference, but imho a poor tutorial if you're new to haskell
15:43:26 <clavis> @where parsec
15:43:26 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
15:43:31 <clavis> @where parselib
15:43:32 <lambdabot> I know nothing about parselib.
15:44:00 <clavis> @where check
15:44:01 <lambdabot> I know nothing about check.
15:44:06 <clavis> excuse me
15:44:12 <clavis> I use the bot
15:44:33 <ndm> lscd: data Num i => MyType i = MyTypeConstructor{x :: i}
15:44:49 <lscd> clavis: the hitchiker's guide to haskell -- http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell -- and http://halogen.note.amherst.edu/%7Ejdtang/scheme_in_48/tutorial/overview.html are useful for actually getting started with parsec, though that's not the main focus in either case
15:44:53 <lambdabot> Title: "Hitchhikers guide to Haskell - HaskellWiki"
15:45:12 <clavis> thanks
15:45:21 <ndm> lscd, I only did selected bits of parsec, knowing haskell alreayd, and it was quite helpful
15:45:50 <lscd> ndm: i find that daan's page is a great reference - but starting with it when you're shaky on basic haskell (as I am) is very painful
15:46:04 <Korollary> lscd: how about data (Fractional a) => YourDataType a = YourConstructor { x :: a, y :: a }. I don't get the bit about accessors.
15:47:00 <ndm> lscd, if you are thinking "views" - you can't be that shakey
15:47:18 <lscd> ndm: I can use google, but yes, I'm that shaky; I'm still learning the basics of monads, etc
15:47:34 <clavis> bye
15:47:38 <clavis> gotta go
15:47:42 <clavis> and thanks
15:48:19 <lscd> Korollary: it's a term more used in OO circles, I think - but basically, I have my data structure, which has named parts, and I want to be able to access one of those parts; 'x' and 'y' would be the accessors in your example
15:48:22 <ndm> lscd: i still don't understand monads, and as far as i am aware, Views are not in haskell, only a proposal
15:48:36 <lscd> ndm: yes, you're right
15:48:54 <lscd> monads are pretty central to haskell though; so I can hardly claim to know it when I don't understand them
15:49:05 <lscd> and more prosaically, I don't understand functors and fmap and so forth either yet
15:49:30 <Korollary> lscd: well, do x & y work for you then?
15:49:46 <ndm> monads are not central at all - you can do really cool, purely functional things without them
15:50:03 <ndm> monads are only useful for real world interaction, and that should be kept down to a minimum!
15:50:32 <lscd> Korollary: they seem to, but I need to figure out how to change the declaration of another type which contains an element of YourDataType
15:50:46 <lscd> ndm: yes, but that 'real world interaction' bit is the part that I need for my code to -do- anything
15:51:14 <lscd> and I think monads are useful for being able to build really flexible stuff too, but I don't understand that use of them yet
15:51:34 <ndm> in general "do something" can be as simple as "read in a file, write out a file"
15:51:45 <ndm> which is 3 monadic lines, and a String -> String function in the middle
15:52:51 <lscd> hm... I'm finding that I need to type fractional a in more places than I'd like
15:53:04 <SamB> lscd: thats the part where you combine them with either typeclasses or the ability to change their implementation over time
15:53:26 <lscd> and haskell doesn't have first-class types, so I'm guessing that I can't just declare "something = blah", where blah = fractional a, and just type "something" every time i'm typing it. meh
15:53:48 <lscd> SamB:  hmm. any pointers to docs on understanding that?
15:53:56 <SamB> docs?
15:54:18 <lscd> tutorials, general explanations, useful mailing list posts, sample code; anything
15:54:20 <wolverian> ooh. the hitchhikers guide to haskell is nice. could do with a bit less advocacy though :)
15:54:32 <SamB> I would rather point at programs and libraries. Such programs as Pugs and lambdabot, and such libraries as the MTL.
15:55:17 <SamB> Pugs and lambdabot have changed the implementation of some of their main monads.
15:55:25 <lscd> wolverian: yeah; i tried reading YAHT and the gentle introduction to haskell, but in the end it was "haskell for c programmers" and the hhg2h that got me started writing haskell code
15:56:12 <lscd> SamB: hm, ok; I'm not very comfortable reading non-trivial haskell code yet, and there's a lot of other stuff in those too, but thanks
15:56:40 <SamB> well, actually, you should probably write your own program based on monads ;-)
15:56:48 <SamB> there was a paper about an interpreter...
15:56:58 <lscd> I have; it's on the wiki; but it's trivial, and doesn't do anything Interesting with monads
15:57:11 <lscd> hmm. name/url? :)
15:57:14 <SamB> well, find a non-trivial task
15:57:23 <SamB> some kind of interpreter
15:57:32 <lscd> sure, i'm working on a scheme interpreter in haskell right now
15:57:42 <SamB> are you using monads?
15:58:28 <lscd> very lightly; i'm following the 48 hour scheme interpreter tutorial on haskell.org; i've got a week of classes left this term, so i haven't gotten to put as much time as i'd like into it yet
15:59:54 <Philippa> I guess I should get round to building a Neko AST now I've spare(ish) time
16:00:12 <lscd> Neko is a programming language?
16:00:32 * vincenz tickles Philippa 
16:01:02 <Philippa> lscd: yeah, designed as an IL for compilers to target
16:01:04 <Philippa> 'lo vincenz
16:01:10 <vincenz> Hi, how are you?
16:01:16 <Philippa> tired
16:01:21 <vincenz> Philippa: is neko stack or register based?
16:01:21 <SamB> lscd: well, you'll probably end up with a big ol stack of monad transformers in there somewhere
16:02:01 <Philippa> vincenz: higher-level than that
16:02:25 <Philippa> you could translate an ML into it pretty directly
16:02:44 <lscd> hm. to say that my data type is constrained to contain things which are Fractional, and to declare another type which uses this, and to declare show for both types, I've had to literally specify "Fractional a" 5 times, as well as change the types to be Type1 a and Type2 a; is there no better way to encapsulate this?
16:02:46 <vincenz> functional or imperative style?
16:02:47 <cmarcelo> lscd: have you ever read http://en.wikibooks.org/wiki/Haskell/Understanding_monads ? it's a nice intro on monads too.. the Haskell Wikibook has other interesting resources too (some on monad transforms) that may help you on your scheme project...
16:02:50 <vincenz> @hoogle neko
16:02:50 <lambdabot> No matches found
16:03:24 <lscd> cmarcelo: i've started to read it a few times, but I haven't gotten through it yet
16:03:27 <SamB> lscd: I wish that putting constraints in type declarations would do more :-(
16:03:54 <SamB> but apparantly the constraints are not the same as implication
16:04:11 <lscd> SamB: it's ok as it is - but it seems absurd to have to clutter every use of Type2, where Type2 is something like a string and a Type 1, with an extra a, when Type1 cares that it's only used with a
16:04:21 <lscd> i can live with it, but it's ugly
16:04:58 <SamB> because they are not "if one thing is true, another thing is true" but rather "if you can show me *how* one thing is true, another thing is true"
16:05:21 <lscd> ahh. hm. that sounds constructive?
16:05:33 <SamB> which is understandable given the way things like hugs and GHC implement typeclasses, but still a pain in the neck :-(
16:05:48 <lscd> yeah
16:06:53 <lscd> what really bothers me is having to clutter every type -using- this type with this data
16:07:08 <lscd> the show for my container type shouldn't need to know this. bleh
16:07:19 <lscd> hmm
16:08:41 <vincenz> Philippa: neko is apparently not strongly typed
16:08:41 <vincenz> ?
16:09:15 <SamB> yes, it bugs me too
16:09:32 <lscd> bleh. i tried kludging around it, but i couldn't find a way that worked
16:09:45 <SamB> I think some smart person should figure out something to do about it, and that the compiler shouldn't let you declare types like that if they won't buy you anything
16:09:53 <Philippa> vincenz: um. I'd have to look through - IIRC it's strongly-but-dynamically typed
16:10:10 <lscd> they buy me a mess, mainly. hm
16:10:47 <lscd> how precise is Double? arbitrary-precision, or fixed?
16:11:03 <SamB> it is usually a C double ;-)
16:11:11 <SamB> Float is sometimes, too
16:11:11 <lscd> ah-hah; i was worried you'd say that
16:11:18 <Philippa> it's a floating-point Double
16:11:42 <vincenz> Philippa: I think any dynamic language is implicitly strongly typed
16:11:44 <Philippa> as defined by the IEEEEEE-have-I-got-enough-E-yet? standard
16:11:48 <vincenz> Philippa: the only exception being c/c++
16:11:56 <lscd> i've already got a fun problem with the fact that some of the numbers this machine considers Int won't be considered Int on 32 bit machines
16:12:09 <vincenz> Philippa: otherwise you'd get illegal behaviour
16:12:11 <Philippa> C and C++ aren't dynamically typed, or did you mean something else by "dynamic language"?
16:12:31 <vincenz> Philippa: I meant the reference/pointer to class aspects
16:12:37 <vincenz> they're partially dynamically typed
16:13:31 <Philippa> unless you mean RTTI, no they're not
16:13:38 <vincenz> RTTI and virtual methods
16:13:47 <Philippa> virtual methods aren't dyntyping, they're indirection
16:14:04 <vincenz> well it depensd on how you classify dyntyping
16:14:09 <vincenz> it's not duccktyping, sure
16:14:16 <Philippa> it's not type checking, either
16:14:30 <Philippa> there's absolutely no validity check, just a branch
16:14:39 <Philippa> (OK, indirection in most implementations but YKWIM)
16:14:58 <lscd> so. I've got a data type that will either contain floats or ints.  it'll be used -really- heavily, so it's likely to be a speed issue if it's less efficient than it should be.  I want accessors, so I can't just let the type be inferred, afaik, as {x, y} seems to be a syntax error, while {x::Int, y::Int} isn't, unless I'm missing something. hm
16:15:04 <vincenz> Philippa: so it's weakly dyntyped
16:15:12 <vincenz> Philippa: that's what I meant... it's the only language with weakdyntyping
16:15:28 <vincenz> any other language with dyntyping is by defintion strongly typed to check where to call
16:16:44 <Philippa> that's just not dyntyped at all. There is no typechecking happening dynamically
16:17:13 <vincenz> erm
16:17:14 <vincenz> yes there is
16:17:19 <vincenz> virtual methods imply a lut
16:17:26 <vincenz> which could be classified as typechecking
16:17:34 <vincenz> the weakenss lies in the fact that you can pointercast however you want
16:17:37 <Philippa> they only imply a LUT the way records do
16:17:39 <lscd> vincenz: i don't think so; I don't see why you couldn't have a dynamically typed imperative language, where you've defined procedures, and where those procedures just give you garbage when called with invalid types
16:17:40 <vincenz> unless you use dynamic_cast
16:17:52 <vincenz> lscd: hardly useful
16:18:09 <lscd> i'm not saying it's a good idea. but it is a counterexample
16:18:13 <vincenz> tho perhaps perl classifies as that, but my knowledge of perl is veryl imited
16:18:53 <vincenz> Philippa: much of neko is my lang, except mine is strongly typed :)
16:18:53 <Philippa> in the absence of multiple inheritance, the usual implementation of virtual methods amounts to function pointers
16:19:26 <Philippa> the only lookup is in finding the field in the object that contains the pointer
16:19:33 <Philippa> so there's no lookup by type at all
16:19:40 <lscd> hm. I'll hardcode the type to double, and change it if I need to. ick
16:20:00 <Philippa> use a type synonym at least?
16:20:19 <lscd> how do I do that?
16:20:37 <Philippa> type Foo = Double
16:20:49 <ndm> lscd, have you seen the SPECIALISE pragma? then you can use Num, and have GHC generate a version for double and int automatically
16:21:06 <vincenz> Philippa: think it's hard to do typeclasses in the degenerate case where the typeclasses themselves are predefined?
16:21:11 <lscd> ndm: I hadn't; cool, thanks
16:21:41 <lscd> Philippa: is there anything like that for type classes?
16:21:43 <Philippa> vincenz: um, I'm not sure I'm following you (be warned: I'm tired and thus potentially braindead)
16:22:04 <vincenz> typechecking with typeclasses if typeclasses are predefined (user can't define new ones)
16:22:07 <Philippa> lscd: nope, though you can have a class with an instance that imports everything from another class
16:22:31 <vincenz> preferably without resorting to dataconstructors
16:22:32 <Philippa> vincenz: no harder than otherwise. In practice you read in all the typeclasses before you start checking terms anyway
16:22:41 <lscd> hm. ok
16:25:25 <lscd> so. If I wanted to make a type data Silly = Silly {desc::String, val::Maybe a}, I need to say Silly a {..}? 
16:25:59 <vincenz> data Silly a = Silly {desc::String, val :: Maybe a}
16:25:59 <Philippa> yeah
16:26:08 <vincenz> Silly{desc="foo", val = just 1}
16:26:12 <lscd> bleh. I was 99.9% sure of that, but it's not what I wanted to hear ;)
16:26:17 <Philippa> unless you're using GADTs and really don't intend for the type in val to ever be known
16:26:18 <lscd> alright, thanks
16:26:30 <Philippa> (and thus the value to never be usable for anything sensible)
16:26:31 <vincenz> that last one will type as Silly Int
16:27:08 <SamK> hi, can anyone recommend a good book for learning haskell? (given 10+ years of programming exp)
16:27:12 <vincenz> Philippa: I take it that newtypes are easier to implement than data
16:27:14 <lscd> eh, no, it'll be known; I just don't like having to clutter every use of Silly with it; I'd like to be able to declare the typeclass of a within silly, rather than pass it all the time
16:27:18 <vincenz> SamK: YAHT
16:27:21 <vincenz> @where yaht
16:27:21 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
16:27:54 <vincenz> lscd: like this:
16:28:06 <vincenz> data (Num a) => Silly a = {desc :: String, val :: Maybe a}
16:28:58 <lscd> well, what I'd like to do is actually more like data Silly = (Num a) => Silly {desc :: String, val :: Maybe a}
16:29:34 <lscd> i mean, the thing is, I'll always be making Silly out of a string and an already-fixed Maybe a
16:29:43 <vincenz> that makes no sense
16:29:44 <lscd> so having to paramaterise Silly with a is really irritating
16:29:47 <vincenz> unless you want existentials
16:29:53 <lscd> existentials?
16:30:43 <SamK> vincenz: thanks, I'll check that out
16:31:21 <lscd> vincenz: well, my point is, by the time i make a value of type Silly, I have two other values, each with a fixed type
16:31:54 <lscd> I don't need to say "Silly String", but I do need to say "Silly a", as it contains a Maybe a
16:32:09 <lscd> which in some ways makes sense. but still seems cluttered
16:32:32 <vincenz> lscd: think about it like this
16:32:34 <vincenz> if you hide the a
16:32:37 <vincenz> and just have "Silly"
16:32:45 <vincenz> then anywhere, it's impossible to discern the type of val
16:33:26 <lscd> i can see that that's the case in the current system; i'm not convinced that it has to be true in general though - but i am tired
16:35:23 <xerox> @tell shapr Gasp. I agree. (last hope)
16:35:24 <lambdabot> Consider it noted.
16:35:46 <lscd> hm. it's necessary to manually state the types of accessors, right?
16:37:04 <ndm> lscd: not necessary or possible
16:37:34 <lscd> ndm: given that stuff is in the form AType {a :: String ......}, it seems possible
16:37:56 <lscd> and given that {a, ..} doesn't seem to be valid syntax, it also seems necessary, unless i'm missing something
16:38:05 <ndm> lscd: oh, yes, you need to give the result type
16:38:09 <ndm> i.e. String
16:38:15 <ndm> else how would it know the type of a
16:38:19 <lscd> ok; that was my question
16:38:42 <lscd> it would be whatever type was used when it was created; but that can't be checked statically
16:41:53 <lscd> hm. If I have a variable which is of some type of Fractional, but I don't know which, I can't use read on it, apparently.
16:42:05 <Pseudonym> Nope.
16:42:14 <lscd> nope as in "nope, I can't"?
16:42:19 <Pseudonym> Correct.
16:42:21 <Pseudonym> Nope, you can't.
16:42:24 <lscd> okdokie
16:42:30 <lscd> back to the hardcoding double idea
16:42:40 <Pseudonym> (Read a, Fractional a) ?
16:42:56 <ndm> or data Number = NumFloat Float | NumInt Int
16:43:10 <lscd> the error I got started with "Could not deduce (Read a) from the context (Fractional a)
16:43:41 <lscd> ndm: ahh, good idea; thanks
16:43:52 <lscd> that's a much better approach
16:45:57 <lscd> I was trying to use a sledgehammer to tighten a screw by using a typeclass here, i guess
16:50:49 <lscd> declaring read and show for Number is a bit verbose the way I'm currently doing it - I'm basically saying show (NumFloat n) = show n; show (NumInt n) = show n -- is there a better way?
17:04:24 <ndm> that seems reasonable for show
17:04:28 <ndm> how do you read "1" ?
17:06:03 <lscd> that's what I'm currently beating my head against
17:06:54 <lscd> it looks like I need to define readsPrec and make Number an instance of Read, etc?
17:07:11 <lscd> [if there's a simple way to do this that I'm missing, I'd be very glad to hear of it]
17:12:25 <palomer> maple is borked
17:14:16 <vincenz> how so?
17:15:07 <lscd> hm. is there some way to just derive the definition of read?
17:15:47 <vincenz> you mean define
17:15:51 <vincenz> instance Read XXX where
17:15:54 <vincenz>   read s = ...
17:16:54 <vincenz> something like
17:16:57 <lscd> i don't mean define; i meant derive; http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#23 -- For example, given the declarations (...) the derived instance of Read is equivalent to (some code)
17:17:08 <lscd> something like?
17:17:14 <vincenz> read s = if '.' `elem` s then NumFloat (read s) else NumInt (read s)
17:17:34 <lscd> hm, ok; I started down that path, then started reading the documentation, and then got horribly confused
17:18:01 <vincenz> though perhaps reads is better
17:18:33 <lscd> yeah; I'm defining ReadS rather than read
17:19:18 <lscd> instance Read Number where ReadS = readNumber
17:19:38 <vincenz> instance Read Foo where readsPrec d s = -- ignore d
17:20:28 <vincenz> @help split
17:20:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:20:33 <vincenz> @hoogle splitBy
17:20:33 <lambdabot> No matches found
17:20:36 <vincenz> @hoogle splitWith
17:20:36 <lambdabot> Data.PackedString.splitWithPS :: (Char -> Bool) -> PackedString -> [PackedString]
17:20:40 <vincenz> @hoogle split
17:20:40 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
17:20:40 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
17:20:40 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
17:20:44 <vincenz> crud
17:21:48 <vincenz> > reads "1e2" :: Int
17:21:48 <lambdabot>  Couldn't match `Int' against `[(a, String)]'
17:21:53 <vincenz> > reads "1e2" :: [(Int, String)]
17:21:55 <lambdabot>  [(100,"")]
17:21:58 <vincenz> > reads "1e2" :: [(Float, String)]
17:21:59 <lambdabot>  [(100.0,"")]
17:22:05 <vincenz> > reads "1.2e2" :: [(Float, String)]
17:22:06 <lambdabot>  [(120.0,"")]
17:22:16 <vincenz> > reads "1.2e2" :: [(Int, String)]
17:22:17 <lambdabot>  []
17:24:05 <vincenz> something like this
17:24:20 <vincenz> http://rafb.net/paste/results/lchPOM99.html
17:24:26 <vincenz> ack
17:24:44 <vincenz> http://rafb.net/paste/results/wr6r5P87.html
17:25:24 <vincenz> add an 'in' after let intl = reads 
17:27:43 <vincenz> http://rafb.net/paste/results/K97EoY22.html
17:28:12 <vincenz> might want to add an extra null
17:28:19 <vincenz> > reads "a" :: [(Int, String)]
17:28:19 <lambdabot>  []
17:28:36 <lscd> hm, ok; why should I be using reads rather than read, though?
17:28:47 * vincenz is off
17:30:54 <lscd> d'oh... the derived instance of Read was sufficient, apparently, without any of that.
17:37:13 <palomer> man
17:37:19 <palomer> wrestling with maple is no fun
17:37:46 <lscd> neither is wrestling with parsing when I want to be writing a bunch of heuristics
17:38:12 <lscd> it's been a few weeks that I've been stuck on this in the little time I've been able to make to work on it
17:53:25 <mathewm> ?pl (\l -> ( sum l ) `div` ( length l ) )
17:53:25 <lambdabot> liftM2 div sum length
17:57:14 <mathewm> ?hoogle Int -> Float
17:57:15 <lambdabot> No matches, try a more general search
17:58:53 <lscd> (fromInteger 3)::Float might help, mathewm 
17:59:34 <lscd> vincenz: I ended up switching to hardcoded doubles - there was too much going on which I didn't understand
17:59:39 <lscd> but thanks for your code
17:59:41 <vincenz>     Illegal instance declaration for `Pretty e'
17:59:41 <vincenz>         (There must be at least one non-type-variable in the instance head
17:59:41 <vincenz>          Use -fallow-undecidable-instances to permit this)
17:59:41 <vincenz>     In the instance declaration for `Pretty e'
17:59:47 <vincenz> lscd: np
17:59:55 <mathewm> thanks
18:00:07 <lscd> np
18:07:28 <mathewm> let f l = div ( sum l ) ( length l ) in f [1,2,3]
18:07:41 <mathewm> > let f l = div ( sum l ) ( length l ) in f [1,2,3]
18:07:42 <lambdabot>  2
18:07:49 <mathewm> >let f l = (/) ( sum l ) ( length l ) in f [1,2,3]
18:08:00 <mathewm> > let f l = (/) ( sum l ) ( length l ) in f [1,2,3]
18:08:01 <lambdabot>  add an instance declaration for (Fractional Int)
18:08:01 <lambdabot>   In the definition of `...
18:08:12 <dfeuer> > let fuck="fuck" ; you = "you" in fuck ++ you
18:08:14 <lambdabot>  "fuckyou"
18:08:21 <dfeuer> > let fuck="fuck " ; you = "you" in fuck ++ you
18:08:22 <lambdabot>  "fuck you"
18:08:30 <mathewm> ?
18:09:04 * dfeuer plays
18:16:47 <lscd> @type (/)
18:16:49 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:48:09 <lscd> Parsec question: I have a simple file, which is in the form name : value \n anothername : anothervalue \n different_structure \n
18:48:37 <lscd> I can parse the different_structure part, or an infinite number of name : value parts
18:49:48 <lscd> but when I have the complete file, nothing parses.  I think it's reading the start of different_structure and finding that it's unable to make a name : value pair out of it; I've tried saying that the keyword starting different_structure is a reserved word, but this hasn't been sufficient, apparently - any suggestions on how I should approach this?
18:55:23 <lscd> Hm. I can find the first half by using manyTill, but the second is still eluding me.
18:57:13 <Philippa> are you using try?
18:57:55 <lscd> with the reserved word approach, I wasn't, as it's supposed to take care of that; with manyTill, yes, in the second argument to it; with parsing the second section of the file, no
18:58:53 <lscd> parsing the first half of the file is working, but parsing the second half isn't; is there an easy way to check how much of the input has been consumed at a given point?
18:59:20 <Philippa> there's an action in the primitives module that'll get the remaining input
18:59:58 <Philippa> getInput
19:00:40 <SamB> getInput, I think
19:00:45 <lscd> hm, ok; thanks
19:00:58 <lscd> i want to see where it is after the ManyTill; the docs are less than clear on this
19:08:18 <lscd> hm. that returns something of GenParser tok st [tok] -- short of writing a bunch of functions, how can I actually poke at what's in that? 
19:09:11 <Philippa> you're still in the monad, use it like the result of any other computation
19:09:31 <Philippa> if you're parsing ordinary strings then the result's still a string
19:10:49 <lscd> well, like you said, I'm in a monad
19:10:55 <lscd> and it's one that doesn't implement Show
19:11:07 <lscd> so, I can't just type "getInput" in ghci and get anything meaningful
19:11:19 <lscd> I also can't type var <- getInput since it's not IO ()
19:13:51 <lscd> if you wanted to see what was in it, what would you write?
19:18:42 <vincenz> \o/
19:18:44 <vincenz> woot
19:18:59 <vincenz> I can do roundtrip: parse -> typecheck -> pprint -> roundtrip
19:19:07 <lscd> congrats
19:20:52 <SimonRC> Since 0::(Num a) => a, 0 is polymorphic, so why can you pattern match on it?
19:21:29 <Philippa> because numeric literals are a special case
19:21:38 <dfeuer> Haskell has too many special cases.
19:21:40 <SimonRC> bah
19:22:34 <SimonRC> Now if we had a type Nat, which is an instance of num, we could get rid of almost dodgy numeric pattern-matching.
19:22:55 <SimonRC> most matches are on 0, 1, or *maybe* 2.
19:23:19 <SimonRC> i.e. Zero, Succ Zero, and Succ $ Succ Zero
19:23:41 <SimonRC> which are *proper* constructors.
19:23:44 * SimonRC goes to bed
19:24:38 * Philippa hands SimonRC a transformational pattern
19:24:46 <Philippa> Zero!toNat :-)
19:25:10 <Philippa> I'm not sure it's such a bad thing to want to write One for Succ Zero though
19:26:15 <SamB> type One = Succ Zero!
19:26:41 <vincenz> type Failure = Succ Ess
19:29:56 <vincenz> hmmhmm
19:32:33 <lscd> oh.....
19:32:51 <lscd> apparently, with manyTill, it's not consuming the input it parses
19:33:15 <lscd> hmm.
19:33:59 <lscd> ah, it is; hmm. it's just behaving in a non-intuitive way
19:42:52 <vincenz> Anyone know how to make graph-like things in Haskell?
19:43:12 <lscd> data structures or display?
19:43:17 <vincenz> data
19:43:51 <lscd> hmm. one obvious way would be a list of lists, though performance would suck
19:44:04 <vincenz> I'm thinking graphs with custom blocks
19:44:09 <lscd> blocks?
19:44:16 <vincenz> well I'm making a data flow analysis
19:44:23 <vincenz> so each of my basic semantic thingies
19:44:24 <vincenz> is a block
19:44:27 <vincenz> with several inputs
19:44:28 <vincenz> and an output
19:44:31 <vincenz> now I want to connect these
19:46:05 <Korollary> there is Data.Graph
19:47:31 <vincenz> yeah but it's not good
19:47:49 <vincenz> my graph has specific ports
19:47:54 <vincenz> Data.Graph does not reflect that
19:47:58 <Korollary> eh?
19:48:07 <vincenz> simple example
19:48:22 <vincenz> foo a b = if a==b then a else b
19:48:33 <vincenz> so you hve two input ports for foo
19:48:40 <vincenz> these connect at the == which then connects to the first port of
19:48:41 <vincenz> if
19:48:47 <vincenz> a connects to the second port of if
19:48:51 <vincenz> b connects to the third port of if
19:49:28 <Korollary> what's your point?
19:49:50 <Korollary> you can have multiple edges ending in a vertex with data.graph
19:50:05 <vincenz> yes but they're not ported
19:50:08 <vincenz> they just connect to that edge
19:50:12 <vincenz> erm vertex
19:50:15 <vincenz> not to a specific port on that vertex
19:59:55 <lscd> weeeeeeee. after literally weeks, I think the parser is done
20:07:36 <stepcut> lscd: what does it parse?
20:07:39 <vincenz> he left :/
20:07:50 <stepcut> oops :)
20:08:08 <stepcut> that would explain why tab completion was not working
20:09:20 <vincenz> hmm
20:11:26 <aFlag> hello, is there any article or something about implementing a lambda calculus parser using parsec?
20:11:59 <aFlag> i can't figure out how to make the function applications to be left-associative, as in haskell
20:12:52 <vincenz> easy
20:12:57 <stepcut> aFlag: you could check out lambdashell
20:13:14 <vincenz> expr = function arg
20:13:21 <vincenz> erm
20:13:24 <vincenz> expr = expr arg
20:13:26 <aFlag> so applying the functions (\x. x), (\y. y) and (\z. z) like this: "(\x. x) (\y. y) (\z. z)" would give me the associativity "((\x. x) (\y. y)) (\z. z)"
20:13:28 <vincenz> expr = expr arg | arg
20:13:38 <vincenz> arg = ...anything not being a function application
20:13:50 <aFlag> i got that far
20:14:09 <aFlag> but wait
20:14:12 <vincenz> then what's the issue?
20:14:15 <aFlag> i have to do it like
20:14:18 <dons> moin
20:14:18 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:14:20 <aFlag> expr = arg expr
20:14:31 <vincenz> aFlag: no
20:14:43 <vincenz> another solution
20:14:47 <aFlag> if i don't i'll get left recursion
20:14:47 <vincenz> expr = listof expr
20:14:49 <vincenz> then do it manually
20:14:57 <vincenz> ;)
20:15:07 <vincenz> I forgot the prasec name for it
20:15:09 <vincenz> oh yeah
20:15:13 <vincenz> expr = many1 expr'
20:15:18 <vincenz> where expr' != function
20:15:24 <vincenz> and then you can manually construct it
20:15:27 <vincenz> expr = do
20:15:31 <vincenz>   exps <- many1 expr'
20:15:38 <vincenz>   foldleft with propery ast node
20:15:47 <vincenz> or is it foldright
20:15:51 * vincenz ponders
20:15:53 <vincenz> I can never remember
20:15:56 <vincenz> but that should work
20:16:14 <aFlag> i was trying to do something like that, but I can't figure out what's wrong
20:16:26 <vincenz> nor can I without more info
20:16:27 <vincenz> o.O
20:16:32 <aFlag> my grammar is a little bit more complex than that
20:16:38 <aFlag> wait a second
20:16:54 * vincenz actually switched from parsec to alex/appy
20:16:57 <vincenz> s/appy/happy
20:18:36 <vincenz> dons: ping
20:18:39 <aFlag> this is what i have this far http://www.rafb.net/paste/results/a4LtMd81.html 
20:19:05 <vincenz> aFlag: you're doing ML?
20:19:07 <dons> vincenz: ?
20:19:21 <aFlag> i was trying to do use foldr and foldl with many in the function appl
20:19:24 <aFlag> vincenz, yes
20:19:39 <vincenz> dons: know of any way to represent a flow-graph in haskell.... where there are different node types, and diffeernet edges connect to specific ports
20:19:49 <vincenz> aFlag: heh... I made a miniML compiler
20:19:50 <aFlag> right now it's right associative
20:20:13 <aFlag> but I really can't figure out how to it left-associative
20:20:23 <aFlag> vincenz, i'm trying to write a type inferer for it
20:20:25 <vincenz> aFlag: wher is the function
20:20:29 <vincenz> aFlag: oh that's easy
20:20:35 <dons> vincenz: hmm. Data.Graph.Inductive? or arrows, actually. Arrows are designed for this kind of thing, aren't they?
20:20:41 <vincenz> aha the appl
20:20:50 <aFlag> yes appl is for the application
20:20:53 <vincenz> dons: problem with D.G and D.G.I is that the vertices are not ported
20:20:58 <vincenz> dons: if that makes sense
20:21:24 <vincenz> aFlag: do something like
20:21:31 <vincenz> coreMLParser = makefunction
20:21:58 <vincenz> makeFunction = do ; exps <- many1 coreMLParser'; fold...
20:22:23 <aFlag> hum
20:22:33 <aFlag> i was doing the many1 with coreMLParser
20:22:33 <vincenz> the problem is that parsec is LL
20:22:34 <vincenz> and you want LR
20:22:37 <aFlag> not coreMLParser'
20:22:46 <vincenz> no
20:22:48 <vincenz> yes
20:22:51 <aFlag> that's probably what i was doing wrong
20:22:51 <vincenz> with coreMLParser'
20:22:54 <vincenz> obviously
20:23:05 <vincenz> and then add
20:23:14 <vincenz> <|> parens coreMLParser
20:23:17 <vincenz> to coreMLParser'
20:23:22 <aFlag> hum, now i think about it i see why
20:23:35 <vincenz> except that you might have to add a try
20:23:42 <vincenz> cause lambda uses ( as start symbol too
20:24:00 <aFlag> i just which I hadn't erase the old appl function out of frustration hehe
20:24:17 <vincenz> anyways
20:24:21 <vincenz> I typically use alex and happy
20:24:32 * vincenz has other stuff in his grammar
20:24:32 <aFlag> what are those?
20:24:34 <vincenz> like import statements
20:24:40 <vincenz> and foreign function definitions
20:24:43 <vincenz> it gets yucky with parsec
20:24:48 <vincenz> aFlag: alex = lexer for haskell
20:24:55 <vincenz> happy = parser (ala bison/yacc) for haskell
20:24:59 <vincenz> happy can also do GLR if you want it to
20:25:02 <aFlag> oh, i see
20:25:14 <vincenz> you'll have to make your own monad to underly the lexer and parser if you want to do anything nifty tho
20:25:25 <aFlag> i thought the purpose of parsec was to make stuff simpler
20:25:35 <aFlag> isn't it?
20:25:39 <vincenz> sure for simple stuff
20:26:01 <aFlag> i see, when stuff start to gets more complicated it doesn't scale so good then, right?
20:26:08 <aFlag> i thought the only problem was performace
20:26:11 <vincenz> well maybe it does, just not n my experience
20:26:15 <vincenz> s/n/in
20:26:26 <dons> ?quit new code
20:26:35 <vincenz> in addition my custom monad does stuff like source-code position tracking
20:26:45 <vincenz> dons: any ideas regarding the graph stuff?
20:27:09 <SamB> well, the main problem with parsec scaling is that it is tricky to use it with lexers
20:27:28 <vincenz> SamB: and the uglyness of adding try everywhere and never knowing when to add it
20:27:30 <mauke> @pl \(a,b) -> (b,a)
20:27:39 <dons> well, perhaps look at arrows. they're a dsl for defining graphs, and often used for building circuits and other similar things
20:27:45 <lambdabot> uncurry (flip (,))
20:27:58 <vincenz> dons: right but more for actual computation than data-structure which is analyzed, no?
20:28:29 <dons> right
20:28:41 <SamB> so, Parsec performs wonderfully and is a beauty to behold when you have a simple enough grammar
20:29:29 <SamB> happy lets you avoid having to do it in C when it starts to get ugly in Parsec
20:29:49 <SamB> (C with yacc/bison, that is)
20:29:53 <vincenz> dons: allow me to demonstrate
20:30:01 <vincenz> anyone know a quick image hosting site?
20:30:09 <SamB> (and of course their perpertual sidecicsk, lex/flex)
20:30:13 <SamB> er, perpetual
20:30:13 <vincenz> like paste but for images?
20:30:25 <SamB> (happy's sidekick is of course alex)
20:30:43 <vincenz> dons: http://img240.imageshack.us/my.php?image=simple7sq.jpg
20:30:45 <lambdabot> Title: "ImageShack - Hosting :: simple7sq.jpg"
20:31:20 <aFlag> vincenz, looks like it worked. Thanks. I don't believe it was so simple! I have been trying to solve this for hours!
20:31:27 <vincenz> aFlag: np
20:31:54 <vincenz> dons: the red ones are inputs to the function (there's a green square around it all, but appparently it didn't render it)... and you can of course have function recursion
20:32:36 <vincenz> and obviously there's an arrow out of the bottom of if to the endpoint of the functio
20:32:59 <vincenz> which wasn't rendered either :(
20:33:01 <vincenz> but you get the picture
20:33:20 <vincenz> this represents: foo a b = if a == b then a else b
20:38:27 * vincenz deconnects and goes to work
20:38:34 <vincenz> Cya
20:39:00 <vincenz> dons: if you have any ideas, feel free to @tell
21:13:38 <tekki>  
21:32:08 <Lokadin> is there any way to get the current date/time as a string?
21:33:02 <SamB_XP_> only when there *is* one
21:33:10 <SamB_XP_> that is, you have to do it in the IO monad
21:33:28 <Lokadin> ?
21:33:54 <SamB_XP_> well, outside of the IO monad, everything is timeless
21:34:09 <SamB_XP_> so, if you need time, you need the IO monad
21:35:04 <Lokadin> hmmm, so can i just use system(date)
21:35:26 <Lokadin> er that's difficult lots of problems *sighs*
21:44:29 <Lokadin> hey if something has an instance of Monad and MonadIO
21:44:34 <Lokadin> if a type has
21:44:41 <Lokadin> how do i use that type
21:46:24 <audreyt> liftIO
21:46:39 <audreyt> printInYourMonad :: MonadIO m => m ()
21:46:52 <audreyt> printInYourMonad = liftIO (print 123)
21:47:35 <Lokadin> er well i'll be making a type :: String -> Sh
21:47:49 <Lokadin> but Sh has an instance of Monad and MonadIO
21:48:00 <Lokadin> so i was wondering how i would use it
21:48:09 <Lokadin> function :: String -> Sh
21:48:15 <Lokadin> function str = ?
21:48:27 <audreyt> function str = liftIO . print
21:48:29 <audreyt> something like that?
21:48:44 <Lokadin> what would liftIO . print do?
21:49:02 <audreyt> it will print the string in your Sh monad
21:49:05 <audreyt> but the type would be
21:49:12 <audreyt> function :: String -> Sh ()
21:49:21 <Lokadin> oh yea that's right
21:49:44 <Lokadin> so say i wanted the String -> Sh () to run system(str)
21:49:47 <Lokadin> how would i do that?
21:49:55 <audreyt> liftIO . system
21:50:10 <Lokadin> and if it was more than one line that i wanted it to do?
21:50:28 <audreyt> huh?
21:50:29 <Lokadin> .i'osai btw
21:50:40 <audreyt> function str = do
21:50:47 <audreyt>     liftIO $ system str
21:50:53 <Lokadin> oh okay
21:50:55 <audreyt>     ...some more Sh action...
21:51:03 <audreyt> if all the things you want are in IO:
21:51:08 <audreyt> function str = liftIO $ do
21:51:10 <audreyt>     system str
21:51:10 <Lokadin> soi would have to have liftIO infront of every IO function?
21:51:13 <audreyt>     print str
21:51:24 <audreyt> no, you just put it in front of each IO block
21:51:29 <audreyt> as shown abov
21:51:50 <Lokadin> but what if the only IO function that i call is system and the rest are not IO
21:51:53 <audreyt> also you can have prelifted version of common IO operations
21:52:01 <audreyt> then you define
21:52:09 <audreyt> systemIO :: String -> Sh ()
21:52:13 <audreyt> systemIO = liftIO . system
21:52:17 <audreyt> then in your code
21:52:19 <audreyt> function str = do
21:52:22 <audreyt>     ....blah
21:52:26 <audreyt>     systemIO str
21:52:29 <audreyt>     ....bleh
21:52:30 <audreyt> etc
21:53:02 <Lokadin> oh cool :) but it's systemIO str = liftIO . system str
21:53:03 <Lokadin> right?
21:53:07 <audreyt> no
21:53:11 <audreyt> systemIO = liftIO . system
21:53:11 <audreyt> or
21:53:18 <audreyt> systemIO str = (liftIO . system) str
21:53:18 <Lokadin> oh
21:53:18 <audreyt> or
21:53:24 <audreyt> systemIO str = liftIO (system str)
21:53:25 <Lokadin> cause of pointlessness
21:53:28 <audreyt> yes.
21:54:19 <Lokadin> i always thought that . reversed everything so if i did func1 $ func2 str, i would have to do (func2 . func1) str
21:54:27 <audreyt> nope.
21:54:32 <audreyt> the idea is that
21:54:37 <audreyt> f $ g $ h $ i $ j
21:54:40 <audreyt> can be laways written as
21:54:51 <audreyt> (f . g . h . i) j
21:55:05 <audreyt> it's one application of so-called equational reasoning
21:55:21 <int-e> Lokadin: the order of function composition isn't consistent in math.
21:55:22 <Lokadin> so what's the differnce between . and $
21:55:35 <audreyt> $ connects one function to its arg
21:55:41 <audreyt> . connects two functions
21:55:46 <int-e> (f . g) x = f (g x). f $ x = f x
21:56:21 * Lokadin thinks
21:56:31 <int-e> (f $ g) x = (f g) x
21:56:39 <int-e> maybe that makes it clearer.
21:57:39 <aFlag> does someone know about a good article or a text on the internet about type inference, unification, etc? Or some good book about it
21:57:40 <Lokadin> well wouldn't f $ g x = f (g x)
21:58:04 <audreyt> yup.
21:58:07 <Pseudonym> aFlag: What level are you after?
21:58:14 <audreyt> aFlag: TaPL :)
21:58:17 <Lokadin> so is . just used for pointlessness?
21:58:18 <Pseudonym> In-depth theory, or brief introduction giving the main ideas?
21:58:20 <aFlag> begining level
21:58:21 <int-e> (the point of $ is just that unlike function application (a b), $ has low precedence (so you can write (a b $ c d) for (a b) (c d) and is right-associative, so a $ b $ c becomes a (b c), not (a b) c)
21:58:31 <audreyt> http://www.cis.upenn.edu/~bcpierce/tapl/
21:58:32 <lambdabot> Title: "Types and Programming Languages"
21:58:37 <audreyt> guaranteed comprehension
21:58:42 <aFlag> the brief introduction first :)
21:58:47 <Pseudonym> aFlag: http://research.microsoft.com/~simonpj/Papers/pj-lester-book/
21:58:48 <lambdabot> Title: "Simon Peyton Jones: book"
21:59:01 <Pseudonym> There's a not bad brief intro there.
21:59:02 <aFlag> thanks guys
21:59:10 <Pseudonym> TaPL is definitely the book you want to read eventually, though.
21:59:20 <Pseudonym> It's very readable.
21:59:27 <Pseudonym> (A lot of theoretical books aren't.)
21:59:27 <int-e> Lokadin: but to achieve that with ., you need to write (f . g) x
21:59:48 <aFlag> oh, i once rented tapl, but i ended up not reading it
22:00:02 <Lokadin> see, what i don't understand is the point of '.' i use $ all the time
22:00:03 <aFlag> good to know it's good
22:00:10 <vincenz> re from AIM
22:00:25 <audreyt> Lokadin: you can't avoid the name of the arg if you use $
22:00:27 <audreyt> Lokadin: consider
22:00:32 <audreyt> f = liftIO . print
22:00:39 <audreyt> with $ you have to say
22:00:42 <int-e> Lokadin: it saves a lot of explicit lambdas. (\x -> f (g x)) becomes (f . g)
22:00:44 <audreyt> f x = liftIO $ print x
22:01:11 <Lokadin> oh alright, so it's just made for pointfree style function
22:01:17 <Pseudonym> No.
22:01:19 <vincenz> man IRC sucks from GAIM
22:01:23 <Pseudonym> Ot
22:01:29 <Pseudonym> It's made for a number of reasons.
22:01:37 <Lokadin> vincenz: i'o (agreed)
22:01:44 <Pseudonym> In general, its original rationale was to avoid parentheses.
22:01:50 <vincenz> Anyone know hwo to get GHC installed on a fedora box where I don't have root access
22:01:57 <Pseudonym> output (finalProcess (initialProcess (input x)))
22:02:18 <Pseudonym> But there's no reason why your code has to be point-free.
22:02:28 <Lokadin> but i use $ for that, it's simpler
22:02:36 <Lokadin> how would i put that with '.'
22:02:37 <Lokadin> ?
22:02:39 <Pseudonym> sum . map (\x xs -> map (*x) xs) . concat $ xss
22:02:46 <int-e> you don't have to ever use . ... but that still doesn
22:03:00 <Pseudonym> That's not strictly point-free.
22:03:04 <int-e> 't mean it's superfluous, because for people that use it, it improves readability.
22:03:05 <Lokadin> ( output . finalProcess . initialProcess . input ) x
22:03:35 <Pseudonym> Incidentally, I would avoid f $ g $ h $ x
22:03:42 <Pseudonym> Because IMO ($) has the wrong associativity.
22:03:53 <int-e> Unless they overdo it. using . in slices is ... err ... hard to follow (personal opinion).
22:03:54 <Pseudonym> f . g . h $ x is just as readable.
22:04:07 <int-e> s/slices/sections/ ?
22:04:27 <Pseudonym> Sure.  The main point here, which is generally true in programming, is that There's More Than One Way To Do It, and picking the best way is why they pay you the big bucks.
22:04:53 <int-e> @pl \f g x y -> (g y) (f x)
22:04:53 <lambdabot> flip ((.) . flip)
22:05:10 <Pseudonym> In that case, I'd argue that the lambda expression is cleaner.
22:05:14 <Pseudonym> Or even better: g y (f x)
22:05:20 <int-e> yes.
22:05:35 <Pseudonym> Or possibly: g y . f $ x
22:05:41 <Pseudonym> Depends what f and g are.
22:06:17 <int-e> or g y $ f x. right.
22:06:52 <Pseudonym> IMO, ($) should be left-associative, not right.
22:07:02 <int-e> I was looking for a bad example. @pl is good for that :)
22:07:11 <Pseudonym> In particular, ($!) should be left-associative, too.
22:07:27 <audreyt> # and #! perhaps
22:07:30 <Pseudonym> But that's an old argument and I know I'm flogging the proverbial dead horse here.
22:07:31 <int-e> maybe. but it's a bad idea to change it now.
22:07:33 <Pseudonym> Perhaps.
22:07:45 <vincenz> Pseudonym: not very smar
22:07:46 <vincenz> +t
22:07:53 <Pseudonym> vincenz: Sorry?
22:07:54 <audreyt> on perl6-language we used to have a term "horse necromancers"
22:07:56 <vincenz> Pseudonym: btw, maybe you can help me with something
22:08:03 <Pseudonym> audreyt: :-)
22:08:09 <Pseudonym> Perl has a great vocabulary.
22:08:13 <vincenz> Pseudonym: I need to represent value dependence graphs... not sure how to represent it in haskell
22:08:56 <Pseudonym> Oh, it's been a while since I read that paper.
22:08:57 <Pseudonym> Hang on.
22:09:04 <int-e> You can always try to establish some ... H++ language.
22:09:29 <Pseudonym> int-e: The problem with that is, my problems with Haskell are mostly cosmetic.
22:09:30 <vincenz> Pseudonym: that for me?/  In which case... what paper?/
22:10:21 <Pseudonym> @google "Value Dependence Graphs: Representation Without Taxation"
22:10:25 <lambdabot> http://citeseer.ist.psu.edu/weise94value.html
22:10:26 <lambdabot> Title: "Value Dependence Graphs: Representation Without Taxation - Weise, Crew, Ernst, S ..."
22:10:29 <Pseudonym> That paper.
22:10:30 <vincenz> Pseudonym: read it
22:10:35 <int-e> Pseudonym: or you could make your own Prelude, and start your programs with 'import qualified Prelude; import MyPrelude' ... and confuse every Haskell coder that ever tries to understand your code.
22:10:38 <vincenz> Pseudonym: doesn't give much implementation info 
22:10:48 <vincenz> Pseudonym: and it's aimed at SSA-ble languages
22:10:56 <vincenz> while my input is more functional
22:11:05 <vincenz> (I know I know...SSA and purely functional are isomorphic)
22:11:20 <int-e> Pseudonym: but I'll stop teasing now.
22:11:57 <Pseudonym> vincenz: You could always try using lots of indirection...
22:12:18 <vincenz> Pseudonym: well the whole idea is that I built a miniML to simplify the problem
22:12:34 <vincenz> going to purely recursive functions iso wihle loops and reference updates should be easay
22:12:38 <vincenz> just not sure how to represent the VDG
22:12:42 <vincenz> in haskell
22:13:04 <Pseudonym> Is there a specific reason you're using VDGs to represent a functional language?
22:13:13 <Pseudonym> I would have thought that VDGs were somewhat redundant.
22:14:15 <vincenz> Pseudonym: well atm I have a functional language that's more imperative (think ML.... while loops, if-statements and references)
22:14:25 <Pseudonym> Ah.
22:14:31 <vincenz> cause originally I'm coming from c++ (except that C++ is a monster and there is no good tool for it)
22:14:35 <vincenz> so I built a miniML compiler
22:14:45 <Pseudonym> Sounds good to me so far.
22:14:51 <vincenz> so now I need to get a VDG
22:14:58 <vincenz> to really see the semantics I want to analyze up close
22:15:05 <vincenz> c++ -> miniML = manual step
22:15:13 <Pseudonym> Right.
22:15:13 <vincenz> then of course miniML => VDg automatic
22:15:29 <vincenz> then VDG => analysis => more miniML generation
22:15:32 <vincenz> then miniML => C++
22:15:33 <Pseudonym> So... why the VDG specifically?
22:15:50 <vincenz> well the oter option is to make a smaller AST
22:15:53 <Pseudonym> What analyses do you want to do?
22:15:54 <vincenz> with all side-effects gone
22:16:39 <vincenz> I'm working on intermediate DDT removal (DDT = dynamic data structure... think STL-vectors).  So I built a miniML with STL-vector built in natiely (and these calls will be opaque for my analysis)
22:16:56 <Pseudonym> Aaah, okay.
22:17:05 <vincenz> deforestation for c++ code
22:17:07 * Pseudonym thinks
22:17:18 <vincenz> except that with stl-like containers, it's a bit more complex than pure deforestation
22:17:29 <Pseudonym> VDGs shouldn't be hard to implement if you have indirection.
22:17:30 <Pseudonym> But.
22:17:42 <Pseudonym> Sounds to me like you don't need the full VDG.
22:17:42 <vincenz> here let me show you a pdf
22:17:49 <vincenz> of what I'm envisioniing
22:17:54 <Pseudonym> OK
22:17:55 <vincenz> hmm....
22:17:59 <vincenz> how to send over IRC with gaim
22:18:16 <Pseudonym> Errr... can't you put it somewhere instead?
22:18:26 <vincenz> well I'm moving so my computer at home is off
22:18:30 <vincenz> and at work I'm firewalled
22:22:31 <palomer> hi ho
22:23:13 <lispy> anyone here use scala and have an opinion?
22:23:22 * lispy trolls for scala reviews ;)
22:24:08 <palomer> stop TROLLING
22:24:13 <lispy> hmm..they dont' have a language channel :(
22:24:17 <lispy> palomer: emacs!
22:24:21 <palomer> themacs!
22:24:26 <lispy> climacs!
22:24:45 <lispy> http://common-lisp.net/project/climacs/
22:24:47 <lambdabot> Title: "climacs"
22:24:49 <palomer> tictacs!
22:25:05 <lispy> you can't spell eVIl without vi!
22:25:26 <palomer> oh my
22:25:33 <palomer> another emacs clone?
22:26:00 <lispy> yeah, it's a lot cleaner than emacs internally, and frankly a lot more promising, but who's likely to actually use it?
22:26:02 <palomer> lispy: do you still common lisp?
22:26:13 <lispy> i haven't for at least 6 months
22:26:21 <palomer> do you miss it?
22:26:31 <lispy> still respect the language, but i'm on a 'must be type checked' kick
22:26:35 <lispy> yeah, in some ways
22:26:45 <lispy> FP + CLOS == noice
22:26:57 <vincenz> noise or nice?
22:27:10 <lispy> nice, but said with a funny voice
22:27:17 <vincenz> ah roight
22:27:28 <lispy> egg-zactly
22:27:36 <vincenz> lispy: Heh... don't know Remus do you?
22:27:45 <lispy> Remus?
22:27:50 <vincenz> nm
22:27:52 <lispy> from red dwarf?
22:27:57 <lispy> oh no that was rimmer
22:28:57 <vincenz> he was a dwarf
22:29:19 <lispy> python and CL have one thing in common for me: attractive to write code  in, but hard to maintain it
22:30:19 <satan> hello all
22:30:50 <lispy> hi
22:31:38 <satan> this the right place to ask a Haskell question? :P
22:31:50 <palomer> that would be #perl
22:31:54 <satan> haha
22:31:59 <palomer> we only discuss haskell the man
22:32:25 <satan> i just started learning haskell, so i'm a total neophyte
22:33:15 <palomer> you like it?
22:33:27 <satan> i've looked at some of the online tutorials and such, and they seem decent, but they're not giving me what I want
22:33:32 * palomer gets out the straight jacket
22:33:34 <lispy> satan: you can make lambdabot evaluate haskell expressions or search for functions by type
22:33:40 <satan> yeah i do, it's quite the change though
22:33:42 <lispy> > 1 + 2
22:33:44 <lambdabot>  3
22:33:52 <lispy> @type 1 + 2
22:33:54 <lambdabot> forall a. (Num a) => a
22:33:54 <satan> heh cool
22:34:01 <lispy> @hoogle a -> b
22:34:02 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
22:34:02 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
22:34:02 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
22:34:05 <palomer> lambdabot is good for one thing only
22:34:07 <palomer> @palomer
22:34:07 <lambdabot> Blargh!
22:34:10 <lispy> heh
22:34:17 <lispy> @. elite keal
22:34:18 <lambdabot> aNd YE$ t|-|4T WA5 \/\/iTh zeRO ph0RM4l +raINiN9 IN A|L REaL/\/\$
22:34:30 <palomer> yes! deign is a verb!
22:34:30 <satan> sweet, well i'll be lurking in here from now on too
22:34:34 <palomer> I knew it!
22:34:42 <satan> yup, i knew that :)
22:34:42 <lispy> palomer: lol
22:34:45 <lispy> @keal
22:34:45 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
22:34:56 * lispy <3 keal
22:35:06 <satan> what i don't know though, is how to declare a custom data type with a tuple and then use it in my program
22:35:06 <palomer> too bad he went nuts
22:35:33 <dfeuer> Hey.  Try googling "reachaty"
22:35:37 <palomer> satan: you'll have to be more precise
22:35:47 <lispy> @google reachaty
22:35:49 <lambdabot> http://techhouse.brown.edu/quotes0304.html
22:35:49 <lambdabot> Title: "Tech House Quotes... Run Away!"
22:35:51 <satan> ok will do
22:36:19 <palomer> what is this techhouse?
22:36:35 <satan> for example, if i say: data Tuple (a,b) = data (Char, Char) , is this even right?
22:36:39 <dfeuer> You can read the main page if you like....
22:36:55 <dfeuer> I just thought the first occurence of "reachaty" on it was pretty funny.
22:37:22 <dfeuer> (It's Technology House at Brown University.  Cool place, or at least it was.)
22:37:30 <dfeuer> (Don't know what it's like now)
22:38:07 <lispy> dfeuer: haha
22:38:36 <lispy> satan: data Tuple = Tuple (Char, Char)  is probably what you meant
22:38:52 <satan> right, right
22:38:58 <satan> my bad
22:39:15 <lispy> no prob
22:40:00 <lispy> so then the word on the left of the equals in the name of the type and the word on the right is a constructor to construct an instance of the type
22:40:04 <satan> but then ghci complains when I load the file, with "Type found where type variable expected" on that line
22:40:15 <lispy> data TypeName = TypeConstructor (Char, Char)
22:40:20 <satan> ok, name, constructor, got it
22:40:34 <lispy> hmm..really?
22:41:10 <satan> yeah the precise location is character 11, the e at the end of the Tuple
22:41:13 <palomer> lispy: if you want to learn a new language, go for mercury
22:41:29 <Pseudonym> Errr...
22:41:44 <Pseudonym> Well, yes. Mercury isn't a waste of time./
22:41:48 <satan> how do i declare a variable, if thats even possible? like you know, int i in C or whatever, how do I use Tuple later?
22:42:06 <lispy> palomer: i want to be able to use said language at work which means it has to integrate with certain other things...
22:42:07 <Pseudonym> It'll give you an idea which direction a practical logic programming language lies in.
22:42:11 <Pseudonym> The general direction, anyway.
22:42:57 <palomer> mercury is my next language
22:43:10 <lispy> satan: we need to teach you about monads before we can teach you about 'variables' in haskell.  But you can define functions and constants for now and never really feel the difference (look up the 'let' keyword)
22:43:58 <satan> ok, let, i'll look it up, thanks lispy :)
22:44:01 <palomer> don't worry about variables
22:44:13 <satan> no?
22:44:46 <Korollary> @palomer
22:44:46 <lambdabot> Scalliwags!
22:45:07 <Itkovian> meuning
22:45:09 <palomer> someone remind me if mercury is lazy
22:45:23 <lispy> someone remind me if palomer is lazy
22:45:24 <lispy> ;)
22:45:27 <palomer> satan: you can create bindings
22:45:31 <palomer> > let a = 2 in a + a
22:45:32 <lambdabot>  4
22:45:39 <palomer> palomer IS lazy
22:45:40 <Pseudonym> Mercury is a logic language.  "Lazy" doesn't make a lot of sense.
22:45:52 <lispy> > let 3 + 4 = 8 in (3 + 4)*2
22:45:52 <palomer> oh?
22:45:53 <lambdabot>  16
22:46:01 <palomer> they don't have a concept of evaluation?
22:46:13 <Pseudonym> You don't evaluate in a logic language, you infer.
22:46:21 <satan> oh i see palomer
22:46:48 <palomer> satan: think of bindings as syntactic sugar, something that helps you not write things over and over again
22:47:09 <satan> ok
22:47:21 <palomer> Pseudonym: surely there's a trivial morphism to an evaluating language, no?
22:47:34 <Pseudonym> palomer: Probably, yeah.
22:47:44 <Pseudonym> But that doesn't mean that "laziness" makes sense.
22:47:49 <satan> i just wanna make a list of tuples and add to them, or delete them or sort them, it's what I did to teach myself Prolog
22:48:16 <palomer> add the tuples?
22:48:24 <lispy> > [(x,y) | x <- [1..3], y <- [1..3]]
22:48:26 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
22:48:41 <lispy> satan: that's one way to make the list :)
22:48:46 <palomer> let a = zip [1..] [2..] in take 10 $ map (+) a
22:48:51 <palomer> > let a = zip [1..] [2..] in take 10 $ map (+) a
22:48:51 <lambdabot>  add an instance declaration for (Num (a, b))
22:49:11 <palomer> :/
22:49:15 <palomer> add an uncurry in there
22:49:16 <lispy> you forgot the 'in a'
22:49:25 <lispy> er oh
22:49:26 <lispy> i'm wrong
22:49:28 <satan> wow this is all a bit beyond me right now, i'm afraid
22:49:30 <palomer> you're nuts.
22:49:38 <palomer> > let a = zip [1..] [2..] in take 10 $ map (uncurry (+)) a
22:49:40 <lambdabot>  [3,5,7,9,11,13,15,17,19,21]
22:49:57 <palomer> satan: if you're more precise, we can help you
22:50:29 * palomer is off
22:50:34 <satan> ok say i have a list of tuples
22:50:58 <lispy> > foldl1 (\(x,y) (a, b) -> (x+a, y+b)) [(x,y) | x <- [1..3], y <- [1..3]]
22:50:59 <lambdabot>  (18,18)
22:51:02 <satan> [(a,b),(c,d),(e,f)], so thats a list of 3 elements, if i'm right
22:51:08 <lispy> right
22:51:39 <satan> i want to convert them to a list like [a,b,c,d,e,f] but see thats where i'm confused
22:51:42 * lispy scares away n00bs with cool folds ;)
22:52:00 <lispy> can you do it for a list with zero elements?
22:52:02 <satan> because i can't just have a,b,c, they have to be chars, right, 'a', 'b' etc.. ? because a,b are variables
22:52:13 <lispy> flatten [(a,b)] = ??
22:52:25 <satan> flatten? lemme look that up
22:52:26 <int-e> @pl \(x,y) (a, b) -> (x+a, y+b)
22:52:27 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
22:52:42 <lispy> int-e: heeh, that's nasty
22:52:52 <lispy> satan: i don't think flatten exists
22:53:13 <satan> yeah it says, Not in Scope
22:53:20 <lispy> satan: how about this, to get what you want how would you finish this definition?  flatten [] =
22:53:33 <satan> well if its empty, it just returns []
22:53:37 <lispy> right
22:53:45 <lispy> what if it has one tuple?
22:53:51 <lispy> flatten [(a,b)] =
22:54:13 <satan> a:b flatten []
22:54:24 <satan> a:b:flatten(the tail, however i get it)
22:54:32 <satan> or is it ++ ?
22:54:33 <lispy> @hoogle tail
22:54:34 <lambdabot> Prelude.tail :: [a] -> [a]
22:54:34 <lambdabot> List.tails :: [a] -> [[a]]
22:54:34 <lambdabot> Data.PackedString.tailPS :: PackedString -> PackedString
22:55:11 <lispy> well, you could write it more how you think about it, so flatten [(a,b)] = [a,b]
22:55:16 <vincenz> palomer: png
22:55:20 <vincenz> ping even
22:55:57 <satan> i see, lispy
22:56:05 <lispy> satan: then if i gave you a list with more than one element you can reduce to the easier case
22:56:19 <lispy> (and there you'll need ++)
22:56:22 <lispy> @type (++)
22:56:23 <lambdabot> forall a. [a] -> [a] -> [a]
22:56:34 <int-e> > ((first (+)) >>> (second (+)) >>> uncurry (***)) (1,2) (3,4)
22:56:35 <lambdabot>  (4,6)
22:56:49 <int-e> lispy: how about that?
22:57:06 <lispy> int-e: makes me want to study arrows :)
22:57:13 <int-e> > ((+) *** (+) >>> uncurry (***)) (1,2) (3,4)
22:57:15 <lambdabot>  (4,6)
22:57:17 <int-e> actually, that.
22:57:40 <vincenz> palomer: ping ping
22:58:22 <vincenz> Anyone a typing expert?
22:58:29 <satan> so i'd have something like flatten [h:tail] = flatten[h]++flatten[tail]
22:58:32 <vincenz> how much more difficult are MPTC w.r.t simple TCs?
22:58:39 <vincenz> to do inference
22:59:13 <lispy> satan: almost, the right hand side is right but the left hand side has a subtly wrong
22:59:31 <lispy> (the hint is to check your brakets)
22:59:36 <satan> no square brackets, eh
22:59:54 <lispy> well, you need some sort of brakets, but square ones are reseved for lists
23:00:09 <satan> right so just flatten (h:tail) 
23:00:21 <int-e> @pl \(a,b) (c,d) -> (a c, b d)
23:00:21 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
23:00:31 <lispy> and on a style note, the convention in haskell is to do (x:xs) which is read, x followed by exes (the plural of x)
23:00:32 <int-e> (that's uncurry (***))
23:01:07 <satan> x:xs, got it
23:01:48 <lispy> satan: so you have three lines in that define your function and each is really plain to read...pretty cool i'd say
23:02:05 <satan> k lemme type em in a file and load it in ghci
23:02:13 <satan> thanks btw, lispy
23:02:18 <lispy> and the final style note is that most people like to include an explicit type signatures with their functions
23:02:24 <lispy> yw
23:02:43 <satan> that's for the type signatures, right?
23:03:23 <lispy> writing down the type signatures serves as a sort of documentation when reading the source later
23:03:42 <lispy> do you know what the type of flatten is?
23:03:59 <satan> it takes a list?
23:04:04 <satan> and returns another, right?
23:04:16 <lispy> yeah, but the type checker wants to be more specific than that
23:04:24 <lispy> so you told me flatten :: [a] -> [b], right?
23:04:29 <satan> right
23:04:48 <lispy> well, the type checker can see the second line and replace a with (c, d)
23:04:57 <satan> ok
23:05:22 <satan> btw, it doesnt compile
23:05:31 <lispy> then it looks at the left and side and sees that c == d, so it has flatten :: [(c,c)] -> [b], but it also sees that the c's end up in the final list
23:05:52 <lispy> so it would say, flatten :: [(c,c)] -> [c]
23:06:11 <lispy> (and since the particular letter doesn't matter, most people use an 'a')
23:06:34 <lispy> @type let flatten [(a, b)] = [a,b] in flatten
23:06:36 <lambdabot> forall b. [(b, b)] -> [b]
23:07:12 <satan> ah i see, i was gonna type that but then thought it might be wrong
23:07:29 <satan> so its flatten:: [(a,b)] -> [a,b]
23:07:52 <lispy> the type inference wants the type which is *just* general enough to accomplish what you defined
23:08:00 <lispy> satan: nope
23:08:11 <lispy> satan: but you're close
23:08:14 <satan> ah ok
23:08:20 <satan> so its flatten:: [(a,b)] -> [a]
23:08:25 <lispy> even closer
23:08:32 <satan> so its flatten:: [(a,b)] -> [_]
23:08:36 <lispy> for that to work what do we know about the types of a and b?
23:08:49 <satan> they're the same
23:08:52 <lispy> we're putting a's and b's in the same list and getting [a]
23:08:54 <lispy> yeah
23:09:05 <lispy> so, that's why you get flatten :: [(a,a)] -> [a]
23:09:17 <satan> hmmm i see
23:09:45 <lispy> BTW, the wildcard, _, only works for bindings not for type variables
23:10:35 <lispy> does it compile now and give you the results you expect?
23:10:41 <satan> ah ok, gotcha
23:10:49 * lispy needs to leave soon for bed
23:10:50 <satan> nope, i get this http://pastebin.com/717833
23:11:19 <lispy> could you paste the code too?
23:11:28 <satan> sure
23:11:36 <lispy> In the first argument of `flatten', namely `[xs]'
23:11:50 <lispy> i'm pretty sure you have a typo on the left-hand side
23:12:07 <satan> http://pastebin.com/717836
23:12:07 <int-e> ah. I guess he's calling   flatten [xs]   instead of   flatten xs
23:12:11 <int-e> xs is already a list :)
23:13:02 <lispy> flatten[xs]
23:13:07 <satan> yes i do call it that way
23:13:31 <int-e> pattern matching can be nested - you can write this as   flatten [] = []; flatten ((a,b):xs) = a:b:flatten xs    (or  [a,b] ++ flatten xs)
23:13:33 <lispy> when you do (x:xs) you take x out of the list so to call flatten you need flatten [x], but xs is still a list
23:14:00 <lispy> so when you do the recursive call, you can just write flatten xs
23:14:26 <satan> ahh i see
23:15:05 <lispy> and int-e is right and it's what i was going to tell you next if i didn't go to bed :)
23:15:14 <satan> wow thats stupendous haha
23:15:19 <satan> thanks a ton, guys
23:15:29 <satan> ok lispy, i wont keep ya any longer, have a good night dude
23:15:40 <lispy> thanks and you're welcome
23:15:45 <satan> i have TONS of questions but i'll keep playing with it, see what i can manage
23:16:05 <lispy> yeah, don't forget that you can /msg lambdabot and gets all sorts of help
23:16:25 <lispy> for example, if you know need to change between two types, you can use hoogle to find a function to do it
23:16:29 <lispy> @hoogle Int -> Char
23:16:30 <lambdabot> Char.chr :: Int -> Char
23:16:31 <satan> yeah about custom data types
23:16:31 <lambdabot> Char.intToDigit :: Int -> Char
23:16:31 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
23:16:43 <satan> @hoogle type
23:16:44 <lambdabot> Prelude.type :: keyword
23:16:44 <lambdabot> Network.Socket.Type :: SocketOption
23:16:44 <lambdabot> Language.Haskell.TH.Type :: data Type
23:16:57 <lispy> hoogle searches for functions
23:17:18 <satan> got it
23:17:23 <lispy> satan: datatypes are pretty easy once you get the basics...but i should go
23:17:30 <lispy> good luck :)
23:17:34 <satan> thanks :)
23:17:49 <lispy> yw
23:26:52 <vincenz> re
23:28:28 <satan> ok so say I define type Tuple = (Char, Char); and type BiggerTuple = (String, String, Tuple), how do I reference these later in the program? or use them?
23:28:50 <vincenz> @join #oasis
23:29:30 <satan> whats in #oasis? :)
23:29:59 <vincenz> huh?
23:30:02 <vincenz> that was for lambdabot
23:30:21 <satan> oh ok
23:30:30 <Cale> satan: You declare the type of something as one of those, I suppose
23:30:36 <Cale> for example
23:30:44 <Cale> foo :: Tuple
23:30:45 <vincenz> Cale: any news regarding your participating in ICFPC
23:30:50 <Cale> foo = ('a', 'b')
23:31:09 <satan> ah ok, i'll try that Cale, thanks :)
23:31:11 <sieni> International Contest of Functional Programming Contest?
23:31:16 <vincenz> sieni: yep
23:31:25 <vincenz> sieni: we have a haskell tema
23:31:31 <vincenz> s/tema/team
23:31:31 <lispy> satan: oh, BTW, flatten = concatMap (\(x,y) -> [x,y])
23:31:40 <Cale> vincenz: It really kind of depends on how I'm feeling about it at the time
23:31:45 <vincenz> Cale: alrighty
23:31:53 <lispy> satan: last thing i wanted to say :)
23:32:03 <satan> oh, so flatten  exists under a diff name already?
23:32:27 <lispy> satan: no, i'm just giving you a valid haskell definition using functions from the standard library
23:32:56 <satan> ah ok, gotcha, wow i feel so newbie-ish, but its because i am heh
23:33:23 <lispy> > let flatten = concatMap (\(x,y) -> [x,y]) in flatten [(1,2),(3,4)]
23:33:24 <lambdabot>  [1,2,3,4]
23:33:37 <lispy> satan: no prob, just giving you lots of ways to thkn about it :)
23:33:49 <vincenz> @pl (\(x,y) -> [x,y])
23:33:50 <lambdabot> uncurry ((. return) . (:))
23:33:52 <satan> true, that lambda operator coming in handy there
23:34:10 <Cale> > let flatten xs = do (x,y) <- xs; return [x,y] in flatten [(1,2), (3,4)]
23:34:12 <lambdabot>  [[1,2],[3,4]]
23:34:20 <Cale> > let flatten xs = do (x,y) <- xs; [x,y] in flatten [(1,2), (3,4)]
23:34:21 <lambdabot>  [1,2,3,4]
23:34:29 <lispy> satan: map and foldl/foldr are great ways to solve common programming tasks
23:34:52 <satan> yeah i saw foldr and foldl, and the examples start off easy but get super complex in a bit, quite intimidating
23:35:08 <Cale> let flatten = (>>= \(x,y) -> [x,y]) in flatten [(1,2), (3,4)]
23:35:16 <Cale> > let flatten = (>>= \(x,y) -> [x,y]) in flatten [(1,2), (3,4)]
23:35:17 <lispy> satan: yup, but it becomes more natural
23:35:17 <lambdabot>  [1,2,3,4]
23:35:30 <Cale> heh, a section with a lambda
23:35:44 <lispy> section?
23:35:57 <lispy> *sigh* i need to sleep :)
23:36:07 <satan> ok i'll plug away at it hehe
23:36:15 <satan> yeah, what timezone are you in, lispy?
23:36:21 <lispy> @localtime lispy
23:36:22 <lambdabot> Local time for lispy is Sun Jun 18 23:35:58 2006
23:36:28 <int-e> > (head &&& head . tail) [1,2]
23:36:29 <lambdabot>  (1,2)
23:36:33 <satan> @localtime satan
23:36:35 <lambdabot> Local time for satan is Sun Jun  18 23:36:20 2006
23:36:39 <lispy> heh
23:36:41 <satan> same timezone dude
23:36:44 <satan> where are you?
23:36:49 <lispy> satan: i'm in seattle but i have to catch a trainin the morning
23:36:56 <satan> oh vancouver here heh
23:37:04 <lispy> cool
23:37:07 <satan> BC, not WA
23:37:16 <satan> though I have been there, it's cool, the WA one
23:37:33 <lispy> i've only been to WA about 3 times so i haven't been there yet
23:37:46 <lispy> i need to visit canada some time...
23:37:47 <Korollary> There's a Vancouver in Oregon, too, right?
23:37:50 <satan> Vancouver, WA, it was a field trip many years ago
23:38:05 <lispy> Korollary: maybe...oregon has a lot of copy cat names
23:38:07 <satan> no, this is it, its 2 mins from portland, oregon so people think it's in it
23:38:34 <satan> we crashed in Van, WA and drove to Portland every morning during our 4 day field trip
23:38:49 <satan> while our instructor got hammered every night in bars in Portland...man
23:38:50 * lispy waves
23:38:57 <Korollary> nite
23:38:59 <satan> night
23:39:44 <sieni> yeah, right
23:54:25 <vincenz> why can't record names not be shared accross different datacocnstructors of one type?/
23:54:33 <vincenz> s/not/
23:55:36 <Cale> field names can be
23:55:45 <Cale> they have to be consistently typed though
23:55:59 <vincenz> ah
23:56:01 <Cale> because they are also projection functions
23:56:03 <vincenz> I thought they weren't allowed to
