00:09:09 <dons> sieni, also, http://haskell.org/haskellwiki/GHC/Concurrency
00:09:22 <dons> Under "Multiprocessor GHC"
00:19:22 <neologism> when is ghc6.6 going to be released?
01:02:12 <bolrod_> dblhelix: could there be some problems with textEntry and drawText  on the mac?
01:04:30 <adu> are you talking about wxHaskell?
01:04:48 <bolrod_> yes
01:05:25 <adu> i should really get ghc running
01:05:52 <bolrod> heh
01:06:23 <adu> can't wait to use all the nifty libs
01:06:58 <bolrod> are you on windows or something?
01:07:04 <adu> no, macosx
01:07:35 <bolrod> oh...  just download the ghc for macosx from the site?
01:07:41 <adu> fink has a ghc package, but "fink install"ing it comes up with errors for some reason
01:07:51 <adu> oh theres a binary?
01:07:55 <bolrod> yes
01:07:59 <adu> cool
01:08:19 <bolrod> and create some links yourself.. and you can run it from the command line
01:08:30 <bolrod> (or add the ghc bin path to $PATH..)
01:08:35 <bolrod> but I guess creating links is easier
01:08:36 <bolrod> ;)
01:08:50 <liyang> Check out stow. :)
01:09:08 <liyang> http://www.gnu.org/software/stow/
01:10:46 <bolrod> thats when you're compiling a program right?
01:10:59 <bolrod> how about when you're installing a binary on macosx :)
01:11:18 <adu> i'm not worried about that
01:11:38 <adu> i'll probably just use it to build ghc :)
01:12:58 <adu> oh theres a .pkg
01:13:03 <bolrod> yeah
01:13:14 <adu> no worries, except where it will put everything...
01:13:33 <bolrod>  /usr/local/lib/ghc-<version>
01:13:36 <bolrod> andehh
01:13:51 <bolrod> in the applications
01:14:06 <bolrod> and some in /usr/local/bin/
01:14:16 <adu> i really like the sound of stow
01:14:33 <adu> i've been doing stuff kinda like that only on a source level
01:15:40 <bolrod> thats why I like packages on linux.. 
01:15:49 <adu> like i have a few opensource projects that i install inplace, so it acts like a normal installation, and so i know what to delete when i rebuild
01:15:58 <bolrod> only haven't found a good way to create one .. 
01:16:13 <adu> create a package?
01:16:18 <bolrod> .deb package
01:16:32 <bolrod> yeah.. checkinstall does it for you
01:16:34 <adu> theres gotta be tuts and howtos on that
01:16:39 <bolrod> but it doesn't seem to be a tidy package
01:16:59 <bolrod> and some other dh_make thing.. but didn't seem to work very well..
01:17:34 <bolrod> after that.. I couldn't be bothered :)
01:17:41 <adu> i've been trying to rethink the whole $PATH issue
01:17:52 <bolrod> how?
01:18:44 <dblhelix> bolrod: could be; I'm not using wxHaskell on a daily basis
01:19:48 <adu> like maybe have a Makefile rule that appends 'PATH="$PATH:..../"' to your shell startup script
01:21:05 <adu> or maybe keep it separate like a .shpath file and a ". .shpath" line in the shell startup script
01:22:33 <adu> i know it isn't standard practice, but i like to have my opensource stuff be all in one place
01:23:12 <adu> besides, most ./configure's these days have a -with-pkg=... options
01:23:28 <bolrod> dblhelix: the standard text appears when you select the textEntry
01:23:45 <dblhelix> bolrod: the standard text being?
01:24:07 <dblhelix> bolrod: what you have assigned to the text property?
01:24:14 <bolrod> the text you set with the  textEntry f [text:="some text"]
01:24:33 <dblhelix> bolrod: and you mean that it does not appear any sooner than upon first selection?
01:24:38 <bolrod> indeed
01:25:39 <dblhelix> bolrod: I've not experienced that yet, I think
01:26:03 <bolrod> I'll see if it has anything to do with  processEnter:=True
01:31:32 <bolrod> nope...  
01:32:16 <bolrod> heh..   macosx also requires processEnter?
01:32:44 <bolrod> blah
01:46:51 <como> i'm learning haskell.  trying to do 'data Point a = Point a a' in GHC, but it gives an error "parse error on input 'data'".  what am I doing wrong?
01:47:22 <xerox> Maybe you're writing it in the wrong place?
01:47:38 <como> it's GHC in interpreter mode
01:47:39 <kosmikus> have you been typing this in ghci?
01:47:40 <Saulzar_> como, You'll need to load that from a file rather than ghci
01:47:58 <Saulzar_> Er, rather you can use ghci to load the file - but not type it into ghci
01:48:09 <kosmikus> you can only evaluate expressions and statements in the interpreter. a "data" is a declaration ... that's an unfortunate restriction.
01:48:15 <xerox> Right.  You should think of GHCi as an interactive `doÂ´ block.
01:48:18 <como> ok, thanks
01:49:26 <xerox> Check out :help in GHCi, it provides convenience commands for reloading the modified file, for example.  Or if you're into Emacs, there's an haskell-mode that provides handy GHCi interaction keybindings.
01:49:50 <xerox> There's something for Vim too, but I don't exactly know.
01:51:13 <xerox> (You can also provide as much letter as it is enough for the interpreter to undoubtly recognize the command, i.e. :r is :reload, :t :type, and so on.)
01:52:37 <xerox> Maybe I made up a word, err.. `doubtlesslyÂ´.
01:53:50 <Saulzar_> undoubtedly?
01:54:17 <xerox> I corrected myself.
01:54:46 <Saulzar_> uniquely :)
01:54:55 <xerox> Dankel.
02:28:27 <adu> i think stow and depot are ok, but i just found Graft, and it sounds better
02:35:54 <robokop> i get an error when trying to start ghci -package wx
02:36:33 <boy> what error?
02:36:36 <shapr> good morning #haskell!
02:36:40 <boy> sup shapr 
02:36:48 <ohub> good morning shapr
02:37:32 <Muad_Dib> hi shapr
02:37:44 <Muad_Dib> ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
02:37:44 <Muad_Dib>         This compiler was built without a native code generator
02:37:44 <Muad_Dib>     Use -fvia-C instead
02:37:46 <Muad_Dib> arr
02:37:52 <Muad_Dib> that wasn't supposed to go in here , xcuse me
02:39:55 <boy> The `impossible' is possible at zombo com
02:40:56 <boy> The `impossible' is attainable at zombo com
02:41:53 <ibid> we here at acme take pride on our ability to deliver even the most difficult orders immediately. unfortunately, for impossible ones we must reserve two weeks for deliveryy.
02:43:48 <Muad_Dib> heh, i just want it fixed! :)
02:45:07 <bolrod> =)
02:45:12 <bolrod> compile it right then
02:45:13 <bolrod> ;)
02:45:22 <Taral> Hello!
02:45:29 <bolrod> or dont compile and use a binary
02:45:34 <bolrod> Hello Taral!
02:50:55 <Muad_Dibber> bolrod: it is a binary :)
02:52:01 <bolrod> then get a different one ;)
02:52:18 * shapr boings
02:52:43 <shapr> ohub: hyvÃ¤Ã¤ huomenta!
02:52:46 <Muad_Dibber> shapr! :P help me out ;)
02:52:47 <shapr> boy: shalom!
02:52:51 <boy> shapr: yo
02:53:10 <shapr> Muad_Dibber: goede middag!
02:53:21 <bolrod> goede middag!
02:53:23 <Muad_Dibber> shapr: bonjour :)
02:54:09 <bolrod> its stil morning.......
02:54:13 <bolrod> :)
02:54:17 <shapr> oh right
02:54:18 <araujo> morning
02:54:23 <bolrod> Tue Apr  4 11:54:01 CEST 2006
02:54:24 <bolrod> ;)
02:54:29 <shapr> Goede morgon!
02:54:35 <bolrod> goede morgen :)
02:55:01 <shapr> Dang, years of learning Swedish have confused my Dutch.
02:55:11 <Muad_Dibber> shapr: who where the guys using ghc on gentoo on a sparc?
02:55:38 <shapr> Hmm, I'd say dcoutts is your best bet.
02:55:47 <shapr> He uses gentoo and sparc.
02:56:14 <shapr> You may also want to ask on #gentoo-haskell
02:56:39 <bolrod> well.. you could compile the package with probably --with-something
02:56:59 <sethk> I'm converting the last gentoo systems here to another distro, but they aren't sparc.  I suppose with sparc you might have to suffer with gentoo
02:57:58 <bolrod> is gentoo a good distro ?
02:58:09 <Muad_Dibber> bolrod: mostly it is i think
02:58:16 <sethk> bolrod, that's controversial, but I would say, in general, no
02:58:25 <bolrod> I'm using ubuntu now
02:58:28 <Muad_Dibber> that is, depending on your requirements :)
02:58:30 <sethk> bolrod, if there is another alternative, use it
02:58:30 <bolrod> its really nice
02:58:37 <Muad_Dibber> for end users, I wouldn't recommend gentoo
02:58:45 <sethk> bolrod, I'm converting all my predecessor's gentoo boxes to ubuntu
02:58:57 <Muad_Dibber> sethk: any particular reason?
02:58:59 <sethk> bolrod, for x86 you have to be crazy to use gentoo
02:59:06 <bolrod> because?
02:59:21 <sethk> Muad_Dibber, why compile something for days and days only to get worse performance than slackware or ubuntu?
02:59:37 <Muad_Dibber> sethk: my performance was actually better so bleh :)
02:59:56 <Muad_Dibber> Besides, gentoo was the first to offer me x86_64
03:00:00 <sethk> Muad_Dibber, I've measured very, very carefully.
03:00:04 <Muad_Dibber> so I'm not on x86 :)
03:00:10 <sethk> Muad_Dibber, that's a different situation
03:00:23 <sethk> Muad_Dibber, that justifies the build times
03:00:31 <Muad_Dibber> Yeah
03:00:56 <Muad_Dibber> Anyway, probably someone here knows, is there any other ghc flag that breaks -fvia-C ?
03:01:02 <shapr> I use debian with apt-build. That lets me use binary packages and then hand-build any packages with my choice of optimizations ( -march=athlonmp in my case ).
03:01:38 <bolrod> :O
03:01:48 <boy> anyone here use archlinux?
03:01:49 <bolrod> apt-build takes the source and makes a .deb?
03:02:18 <shapr> bolrod: Yup.
03:02:25 <bolrod> oh dayum!  I needed that
03:02:28 <vincenz> be cool to reimplement the freenet thingy in haskell
03:02:29 <bolrod> lets see how it works :D
03:02:56 <shapr> bolrod: I don't like building my own packages for the most part, but for mozilla and firefox, Athlon MP optimizations make a big difference.
03:03:09 <bolrod> ;o
03:03:12 <shapr> vincenz: Wouldn't be too hard. You'd probably want to start with a Kademlia implementation on top of Conjure.
03:03:28 <vincenz> shapr: what is conjure or kademlia
03:03:29 <bolrod> damn.. I think this is exactly the thing I need =)
03:05:00 <bolrod> lets try to make a package for wxhaskell with this :)
03:05:52 <bolrod> hrm... apt-build upgrade does the same as  apt-get upgrade only it compiles from source?
03:06:27 <shapr> bolrod: I think so, but there is the possibility of weird results there.
03:06:32 <bolrod> hrm
03:06:43 <bolrod> I better not cancel it then
03:06:48 <shapr> bolrod: Just from the fact that if you choose untested optimizations, stuff may die.
03:06:49 <bolrod> who knows what will be left ;)
03:07:10 <bolrod> I dont care :)  I have a laptop =)
03:07:13 <shapr> vincenz: Conjure is the bittorrent implementation, kademlia is the distributed hash table algorithm used by any and all p2p implementations.
03:07:43 <vincenz> ah
03:07:57 <vincenz> yeah just found kademlia
03:08:01 <vincenz> conjure is a harder googleword
03:08:06 <vincenz> anyways
03:08:08 * vincenz 's off
03:23:55 <lome> is lambdabot alive?
03:24:05 <lome> > 2 + 3
03:24:06 <lambdabot> 5
03:24:07 <shapr> lambdabot: @hello 5
03:24:07 <lambdabot> Maybe you meant: help hylo
03:24:41 <lome> or! i just forget to register in nickserv
03:26:05 <lome> hmm... it dont answer me in private window
03:28:05 <shapr> It's possible that lambdabot forgot to identify itself.
03:28:19 <shapr> I get an answer.
03:28:21 * shapr shrugs
03:29:10 <sethk> what's the syntax with import to hide a particular function?
03:30:25 <boy> import X hiding y
03:31:04 <sethk> boy, thanks
03:32:41 <sethk> boy, that doesn't do it.  must need parens or something
03:33:25 <boy> it should work
03:33:30 <boy> import Prelude hiding length
03:33:38 <Saulzar_> hiding (x, y) probably
03:33:55 <bourbaki> hihiho
03:33:57 <sethk> Saulzar_, I'll try that.  It makes sense,
03:34:26 <bourbaki> quick question do you think its a good thing to base linear algebra operations on monads?
03:34:47 <bourbaki> where the numbers would maybe be constant functions
03:35:00 <sethk> Saulzar_, you are correct, with the parens it is happy.
03:35:12 <Saulzar_> bourbaki, In what way would you use them?
03:35:39 <bourbaki> well in may case it would be matrix and vector operations and tensors
03:36:19 <bourbaki> i just wonder how to punch that into monads cause i want to use stuff like random on them so im forced to get into the IO monad
03:36:57 <lome> sharp: thx!
03:37:32 <Saulzar_> Hmm, maybe it depends on the particular code rather than being specific to the matrix operations. Some may need state, random numbers 
03:37:32 <boy> guys, what do you think of this?
03:37:34 <boy> http://img515.imageshack.us/img515/698/coolshit1bi.png
03:38:16 <Saulzar_> I've seen it about 15 times, but it looks nice :)
03:38:22 <bourbaki> im a bit confused cause i dont know how i should return (lift) the vectors matrices and tensors in the same space to wirte the =>> operator
03:38:56 <bourbaki> though all vectors and matrices should be expressable as tensors ... but that will make it all quite ugly
03:39:45 <bourbaki> how hard is it to get haskell code that compiled to a .o file into c++? is there any example on the net?
03:40:08 <boy> bourbaki: i think there are a few different ways to do it
03:40:13 <Saulzar_> Hmm.. you mean something like Vector Vector Double is a matrix  for example? 
03:41:10 <Saulzar_> I'm not sure it makes sense for vectors matrices etc. to be a monad in itself ...
03:41:26 <bourbaki> no i mean something like how do you multiply a matrix with a vecotr and a matrix with a matrix if you just have one operator to join the two functions
03:41:49 <Saulzar_> Ahh
03:41:52 <Saulzar_> Cool..
03:41:54 <bourbaki> the matrix group offer me + and * but the monad just has one operator
03:42:13 <Saulzar_> You can have others, look at parsec for example
03:42:18 <Saulzar_> It has all kinds of operators
03:42:20 <bourbaki> so i thought to return all elements of the group to a constant function
03:42:45 <bourbaki> like a function without parameter
03:42:45 <bourbaki> s
03:43:09 <bourbaki> ok so more then one operator requires you a two step monad operation right?
03:43:10 <bourbaki> like
03:43:29 <bourbaki> bar >>= + >>= foo
03:43:32 <bourbaki> or such
03:44:41 <Saulzar_> bourbaki, I don't think so..
03:44:57 <Saulzar_> Depends how you design the thing
03:46:12 <boy> Saulzar_: so what do you think of it? :)
03:46:25 <sieni> @seen franka
03:46:26 <lambdabot> I haven't seen franka.
03:46:47 <Saulzar_> boy, It is a nice demo :P
03:47:15 <boy> Saulzar_: can you tell from the screenshot what it does?
03:47:55 <Saulzar_> You've said before, it uses hs plugins to load functions to process strings
03:48:23 <boy> Saulzar_: yeah, but the cool part is that you can interactively modify the haskell string proccessing functions
03:48:36 <boy> and see the result of applying the sample string in realtime
03:48:50 <Saulzar_> I see, nice..
03:49:03 <xerox> boy, cool, is it your work?
03:49:06 <Saulzar_> Isn't that slow?
03:49:08 <boy> if you modify the function and there is an error then it is shown in the "Build status" part
03:49:47 <boy> Saulzar_: code modifications aren't applied immediately after every small modification. you must push the "save" button
03:49:55 <boy> xerox: yeah, uses gtk2hs and hs-plugins
03:49:57 <xerox> @karma+ boy -- right on!
03:49:58 <lambdabot> boy's karma raised to 1.
03:50:00 <Saulzar_> hs-plugins seems to take a small while when I've used it
03:50:22 <boy> gui was designed with glade :)
03:50:55 <boy> Saulzar_: pushing the "Save" button causes about a 100 ms pause on my machine, during this time compilation and linking is done
03:51:15 <Saulzar_> Hmm, you using eval or make/load?
03:51:20 <boy> Saulzar_: make/load
03:51:34 <boy> i'm thinking of getting rid of the save button and having it automatically done when there is no modification for 1/2 a second or so
03:52:12 <boy> @karma boy
03:52:13 <lambdabot> You have a karma of 1
03:52:29 <boy> argh, i shouldn't change nicks so much... i lose my karma every time :\
03:52:41 <boy> @karma jip
03:52:41 <lambdabot> jip has a karma of 0
03:52:45 <boy> @karma jips
03:52:45 <lambdabot> jips has a karma of 0
03:52:46 * Saulzar_ knows of about 5 :)
03:53:03 <boy> @karma ape
03:53:03 <lambdabot> ape has a karma of 0
03:53:06 <boy> @karma pipe
03:53:07 <lambdabot> pipe has a karma of 0
03:55:05 <dons> the delay is the cost of compilation
03:55:16 <dons> if we used ghc-api (for hs-plugins 2.0) this should be a bit faster
03:55:21 <Saulzar> Bah, now I want to work on my project. But I'm meant to be writing a paper...
03:55:41 <boy> dons: there will be an hs-plugins 2.0? and it will use ghc-api?
03:56:01 <dons> yeah, i reckon
03:56:20 <boy> whoah that is totally awesome news
03:56:28 <dons> well. it's just a plan.
03:56:38 <dons> but I can see it happening
03:57:01 * boy hopes so
03:57:04 <dons> but not till ghc-api is released with standard ghc, i.e. after 6.6
03:57:27 <boy> ghc 6.6 will be the next version of ghc? when will they finally release the sucker?
03:57:40 <dons> about 2 months or so, I tihnk is the plan
03:57:46 <boy> cool, not bad
03:58:59 <robokop> Loading package wxcore-0.9.4 ... ghc-6.4.1: can't load .so/.DLL for: wxc-gtk2.4.2-0.9.4 (/usr/local/lib/libwxc-gtk2.4.2-0.9.4.so: undefined symbol: _Z7wxEntryRiPPc)
03:59:10 <robokop> how could i fix that
04:02:10 <dons> Lemmih, want to write a haskell version of indent(1) using ghc-api for the parsing and ppr?
04:03:27 <boy> dons: you mean for indenting c source code?
04:03:45 <dons> for indenting Haskell code.
04:03:50 <dons> but yes, like the C tool
04:04:07 <dons> since the best we have atm is ghc -fno-code -ddump-parsed B.hs | sed '/^===/d'
04:04:12 <boy> hm.... there exists no tool already for indenting haskell code?
04:04:17 <dons> (which does an ok job, but strips comments)
04:04:30 <dons> there are in programattica. but that's not a light-n-easy tool to get hold of
04:04:34 <dons> and we have:
04:04:42 <dons> ?pretty let f x = x + 1 in f 7
04:04:42 <lambdabot>  i = let f x = x + 1 in f 7
04:04:54 <dons> but i just want an 'indent'
04:05:03 <boy> what is ppr?
04:05:16 <dons> pretty-print
04:05:41 <dons> since that is all such a tool needs to do
04:06:02 <dons> parse a haskell file, build an ast. walk the tree printing it using our pretty printing combinators
04:06:16 <dons> you could use Language.Haskell, but reallyy you want to be able to preserve comments and handle all extensions
04:06:32 <boy> ghc-api would only be good for the parsing, and not for the ppr part, right?
04:07:13 <dons> ghc has a pretty printer already
04:07:17 <dons> but its probably not optimal
04:07:26 <dons> i'm writing a wiki page on it. gimme a sec.
04:10:37 <dons> ?wiki Indent
04:10:37 <lambdabot> http://www.haskell.org/haskellwiki/Indent
04:10:40 <dons> there
04:10:50 <dons> with my current solution using ghc
04:16:49 <Muad_Dibber> dons, lambdabot doesn't like me, or my ghc :(
04:16:53 <Muad_Dibber> *sniffsniff*
04:16:55 <dons> how so?
04:17:14 <Muad_Dibber> something about ghc not being able to produce native code so i should use -fvia-C
04:17:32 <dons> ok. so use -fvia-C. you on amd64 perhaps?
04:17:35 <Muad_Dibber> but I put -fvia-C in HC_OPTS in the config file, makes no difference though
04:17:39 <Muad_Dibber> (sparc)
04:17:53 <dons> oh, is it failing in Binary.hs ?
04:18:14 <dons> and you changed: HC_OPTS+=       -funbox-strict-fields -O -fasm
04:18:19 <dons> in config.mk?
04:18:42 <dons> note this at the top of Lib/Binary.hs : {-# OPTIONS -cpp -fasm #-}
04:18:53 <dons> due to a mangler bug on x86/linux
04:18:58 <dons> but maybe it'll work on the sparc
04:19:06 <dons> oooh. sparc lambdabot would be fun
04:19:21 <dons> I'll help if you need more assistance
04:19:34 <Muad_Dibber> thats why i wanted to try :)
04:20:05 <Muad_Dibber> But I'm certainly not good with the options, so I have to find out what each one is :) I'm still fiddling with it though so don't worry :)
04:20:12 <dons> so a) you'll need to remove the -fasm at the top of Lib/Binary.hs
04:20:33 <dons> and b) remove -fasm from config.mk (maybe even config.mk.in if you rerun ./configure )
04:20:39 <Muad_Dibber> and b) replace -fasm with -fvia-C in config.mk
04:20:43 <dons> yup
04:21:22 <dons> that's the only things that force -fasm
04:22:00 <Muad_Dibber> okay, I should've noticed before, cause I only added -fvia-C :) Now it seems to be building
04:23:17 <dons> excellent. I can't wait to see the @version
04:25:06 <Muad_Dibber> Is there not a WikiPage that lists all @versions and places where a lambdabot sits?
04:25:33 <dons> we will create one!
04:25:36 <dons> ?wiki Lambdabot
04:25:37 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
04:26:36 <dons> i'll add a section
04:28:03 <dons> ?versoin
04:28:04 <lambdabot> lambdabot 3p396, GHC 6.4.1 (Linux i686 3.20GHz)
04:28:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:29:50 <dons> added a section. add your sparc one when its running
04:29:59 <Muad_Dibber> yah :)
04:32:17 <dons> is it building?
04:32:26 <dons> (I know that lambdabot takes a while to build these days....)
04:34:21 <Muad_Dibber> yup
04:34:24 <Muad_Dibber> (Working at Vixen)
04:37:32 <shapr> How do you guys structure your directory of repositories? I have ~/build/{darcs,svn,cvs,debs} but that seems overly divided.
04:38:33 <dons> ~/src/* 
04:38:37 <Muad_Dibber> i structure them on the kind of project :)
04:38:43 <dons> ~/src/openbsd ~/src/ghc
04:38:50 <dons> ~/src/papers
04:39:11 <dons> yeah, so on the kind of project
04:39:16 <xerox> Maybe categorize it on other basis, and write some shellscript to recognize the kind of repository.
04:39:19 <Muad_Dibber> ~/cs (for uni stuff) ~/raymon (for private stuff) ~/projects (for unclassified projects)
04:39:37 <Muad_Dibber> should have a labelled filesystem (like gmail mail system)
04:42:03 <Lemmih> dons: GHC's pretty printer is a bit broken, iirc.
04:43:56 <dons> yeah
04:44:06 <Lemmih> Someone should add 'parsed == parse (ppr parsed)' to the QuickCheck set.
04:45:11 <dons> well, except for the forms that normalise. like 0xff -> 255. ppr isn't unparsing :)
04:45:53 <dons> for a class of programs that match the ppr, id == ppr . parse 
04:47:56 <Lemmih> 'parsed' is the AST, not text.
04:48:24 <Lemmih> There's no such thing as 0xff in the AST.
04:49:03 <dons> ah. ok. that could be checkeC[C[C[Cd then yes.
04:50:25 <xerox> Haskell's soul!
05:06:57 <dons> munging mail box archives is icksome
05:13:39 <neologism> new gmp released.. nice :)
05:13:50 <boy> that mouse shit?
05:14:00 <shapr> gnu multiprecision?
05:14:01 <dons> nope ;)
05:14:12 <dons> the backbone of Integer
05:14:17 <mauke> you're thinking of gpm
05:14:33 <boy> ghc uses this?
05:14:54 <dons> ah, much better. with a few tweaks I find an extra 2000 mails lost in the archives
05:15:12 <dons> funny how the mbox format changed 5 or 6 times between 1990 and 1995 :}
05:15:39 <neologism> gmp - A free library for arbitrary precision arithmetic
05:15:42 <neologism> ghc uses it
05:15:45 <metaperl> shapr: hello?
05:16:06 <neologism> promises faster computation
05:16:50 <dons> the best kind.
05:16:55 <neologism> http://www.swox.com/gmp/
05:23:59 <dons> this should matter on archs ike amd64
05:24:18 <dons> new gmp support always helps weird or new archs, usually
05:25:07 <neologism> the changelog talks about improved performance
05:25:09 <neologism> which is nice
05:28:13 <Igloo> I'd be surprised if it was perceptible for your average Haskell program
05:28:52 <dons> you'll only notiice that say, more tests will pass the testsuite on ia64
05:29:31 <Igloo> From performance improvements?
05:29:44 <dons> no. just fixes to weird archs
05:30:06 <Igloo> That makes more sense  :-)
05:30:07 <dons> performance-wise, there's probably 10 people in the world who'll care about the difference, I'd suspect
05:30:13 <twb> What's wrong with this?
05:30:13 <twb> type Atom = String
05:30:13 <twb> type Comb = [Expr]
05:30:13 <twb> type Expr = Either Atom Comb
05:30:54 <Igloo> It's an infinite type
05:31:08 <twb> I'm not allowed to have recursive types?
05:31:10 <Igloo> Expr = Either Atom [Either Atom [Either Atom ...]]
05:31:19 <dons> throw a data in there some where
05:31:21 <dons> or a newtype
05:31:22 <Igloo> You can, but you have to make them with newtype
05:31:27 <twb> Ah, OK.
05:32:13 <dons> it's more common to define: data E = A | C  ; data C = C [E] ; data A = A String  or so.
05:32:39 <dons> a new type would work here, and you'd get the zero cost I think you're chasing (?)
05:32:59 <twb> I'm just trying to define a datatype to hold Lisp-style symbolic expressions.
05:33:38 <dons> use 'data' then to define your data type :) rather than via type synonyms :)
05:34:04 <twb> dons: doing it the way you just suggested give "Multiple declarations of `Main.A'"
05:34:45 <dons> oh, because A | C  are constructors.
05:35:07 <twb> data Expr = A Atom | C Comb
05:35:33 <dons> jah. then newtype Atom and Comb
05:35:52 <twb> Seems a bit dodgy...
05:35:54 <dons> ?google data Exp Haskell
05:35:55 <lambdabot> http://www.haskell.org/tmrwiki/FpVsOo
05:35:57 <Philippa_> in practice it'll probably unbox Atom for you anyway
05:35:58 <Philippa_> how?
05:36:03 <Philippa_> (dodgyness, that is)
05:36:10 <twb> Dunno.
05:36:15 <dons> it's the susual way to do things.
05:36:19 <dons> let me quote ghc...
05:36:24 <vincenz> I got another person interested in haskell
05:36:37 <Philippa_> I very rarely use newtype, just data and type most of the time
05:36:49 <vincenz> what is the difference between newtype and data?
05:36:53 <dons> data HsExpr id
05:36:53 <dons>   = HsVar   id      -- variable
05:36:53 <dons>   | HsIPVar (IPName id) -- implicit parameter
05:36:55 <dons>   | HsOverLit   (HsOverLit id)  -- Overloaded literals
05:36:57 <dons>   | HsLit   HsLit       -- Simple (non-overloaded) literals
05:36:59 <Philippa_> vincenz: got you beat on that, there's a girl moving in with me who'd like to learn :-)
05:37:07 <vincenz> Philippa_: she cute?
05:37:24 <Philippa_> she's not quite my type physically. Am kinda fond of her though
05:37:27 <vincenz> and the person I got interested is a girl too
05:37:40 <twb> Ha, you won't fool me.
05:37:43 <Muad_Dibber> vincenz: is *she* cute? :)
05:37:46 <twb> Everyone knows that girls don't really exist.
05:37:57 <vincenz> Muad_Dibber: no comment, she's my colleagues girlfriend
05:38:49 <Philippa_> twb: that's quite some imagination you've got to dream me up then
05:39:07 <twb> Philippa_: when I close my eyes, the world ceases to exist ;-)
05:39:38 <Philippa_> ah, I'll have to come staple them open then
05:40:42 <vincenz> Philippa_: nailguns work better
05:44:38 <twb> Argh, what's intersperse called in Haskell?
05:44:53 <mauke> @index intersperse
05:44:54 <lambdabot> Data.List
05:45:16 <twb> Stupid REPL not having all the good stuff loaded by default.
05:45:32 <twb> ...not that I enjoy that in factor, o' course.
05:46:44 <Philippa_> I don't know, but you might be able to set it up to load more than the Prelude by default? Would be worth a quick RTFMing
05:46:59 <twb> Yeah.
05:47:43 <twb> C-u C-z ghci -package data RET
05:49:53 <vincenz> Philippa_: probably some .ghci file or something
05:49:56 <resiak> Do folks recommend RMSmacs or xemacs around here?
05:50:01 <xerox> Yes, one can setup its own Prelude and optionally load it by default.
05:50:41 <twb> resiak: GNU Emacs.
05:50:47 <resiak> twb: Why?
05:51:03 <twb> resiak: mainly because IME it has slightly more users and slightly better support for third-party packages.
05:51:17 <twb> resiak: as a user, it matters very little until you start writing elisp.
05:52:39 <twb> resiak: you are a new Emacs user?
05:53:12 <resiak> twb: I'm contemplating trying it again
05:54:48 <nametab> are there people using wxhaskell on Gentoo?
05:55:13 <twb> nametab: probably.
05:55:23 <vincenz> nametab: use gtk2hs
05:55:55 <twb> vincenz: wxhaskell is already deprecated?!
05:56:06 <shapr> resiak: I prefer xemacs.
05:56:27 <vincenz> twb: I love gtk2hs
05:56:28 <twb> resiak: you should definitely get Emacs 22, though.  Emacs 21 sucks.
05:56:31 <resiak> I guess it's all personal preference. :-)
05:56:34 <shapr> resiak: In my experience xemacs is friendlier to both newbies and experienced users.
05:56:37 <vincenz> shapr: vim 7.0 beta is out
05:56:40 <vincenz> \o/
05:56:46 <nametab> gtk2hs? right..
05:56:52 <vincenz> nametab: what?
05:56:55 <vincenz> nametab: it's a breeze to use
05:56:57 <vincenz> look at my code
05:56:57 <twb> shapr: well I say it doesn't matter much, so I guess resiak should get XEmacs, eh? ;-)
05:57:15 <twb> dons: http://twb.ath.cx/tmp/tmp.hs
05:57:19 <vincenz> nametab: http://www.notvincenz.com/wiki/pmwiki.php/Personal/Software
05:57:20 <shapr> twb: There are advantages to both, but I do think xemacs is easier for newbies.
05:57:32 <resiak> I'll have a play around with emacs22 and xemacs. Ta
05:57:52 <vincenz> twb: go with the first... it's more std
05:58:05 <shapr> resiak: I'd also suggest not using the default settings. I can suggest better startup settings.
05:58:54 <dons> twb, I like the second version better
05:59:01 <twb> dons: yay!
05:59:11 <shapr> I'd rather use Yi, but I haven't spent any time hacking on it lately.
05:59:22 <shapr> Maybe I should just switch to Yi and fix any problems I encounter...
05:59:35 <twb> shapr: I'll use Yi when it can replace w3m-el and emms and rcirc :-)
05:59:55 <twb> resiak: what OS?
06:00:00 <resiak> twb: Debian
06:00:12 <nametab> vincenz: the point is, I *have* to use wxhaskell :)
06:00:21 <twb> resiak: aptitude install emacs-snapshot-gtk/sid.
06:00:29 <resiak> twb: I'm a step ahead ;)
06:00:33 <twb> resiak: OK.
06:00:38 <dons> "People who sleep for only short durations raise their average 24-hour blood pressure and heart pressure"
06:00:44 <shapr> resiak: apt-get -uf install xemacs21-mule
06:00:50 <twb> resiak: also http://twb.ath.cx/~twb/doc/emacs.html is my little emacs newb FAQ 
06:00:58 <resiak> twb: It was noticing that a Gtk version existed that made me wonder about trying it.
06:01:09 <twb> resiak: it's not really GTK.
06:01:16 <twb> resiak: just the chrome is GTK.  No pango or anything.
06:01:29 <twb> resiak: but emacs22 supports CJK better than emacs21.
06:01:30 <resiak> shapr: xemacs21-gnome-mule !
06:01:31 <shapr> twb: My emacs newb FAQ is EmacsNiftyTricks on emacswiki. Some other people have added to it since I started that page though :-)
06:01:36 <vincenz> nametab: oh ok
06:01:46 <vincenz> nametab: well take a look at it nonetheless :)
06:01:55 <shapr> resiak: Sadly, the xemacs gnome support causes more problems than it solves.
06:02:00 <vincenz> and feel free to sign my guestbook :)
06:02:08 <twb> shapr: no surprise there.
06:02:11 * shapr reads twb's newb intro with avid interest!
06:02:13 <nametab> vincenz: heh, right :)
06:02:50 <vincenz> dcouts or xerox around?/
06:02:55 <resiak> shapr: I'll remove that one and try just -mule. I'll also check out EmacsNiftyTricks. Thanks.
06:02:57 <vincenz> dons: ping
06:02:59 <twb> vincenz: xerox is.
06:03:00 <vincenz> xerox: ping
06:03:00 * xerox looks around
06:03:01 <resiak> twb: Thanks also.
06:03:07 <vincenz> xerox: you wrote part of cairo, right?
06:03:19 <vincenz> (or all of it)
06:03:21 <xerox> Kinda.
06:03:25 <xerox> Right.
06:03:30 <vincenz> xerox: I'm trying to figure out how to work with a non-static rendering
06:03:36 <vincenz> xerox: like a pixel-based animation...
06:03:41 <vincenz> xerox: for instance game-of-life
06:03:44 <xerox> Check out duncan's example of Clock.hs
06:04:00 <xerox> It's the "best" way to do animations currently, I think.
06:04:27 <xerox> IIRC, there's an article on Gtk2Hs site too.
06:04:50 <shapr> twb: A coupla features I prefer in xemacs are near ubiquitous tab completion at prompts (load-library for example) and the ability to run a gnuserv from the console and attach with a graphical frame.
06:04:59 <vincenz> xerox: the issue is that you're constantly making a HUGE render (I mean an operation for each pixel)... and then throwing it away
06:05:15 <vincenz> xerox: I doubt clock is that intensive... it's just a few lines
06:05:18 <twb> shapr: I use pcomplete for that.
06:05:22 <shapr> twb: imho, gnumacs huge benefit is that more people write code for it.
06:05:24 <xerox> vincenz, right. One should redraw only needed parts (as clock does).
06:05:25 <vincenz> dcoutts: ping
06:05:31 <twb> shapr: exactly.
06:05:35 <vincenz> xerox: welll with the type of stuff I want to make... each pixel is active
06:05:44 <shapr> twb: Of course, I'm not using windows either :-)
06:05:54 <twb> shapr: btw, mtty emacs has multihead like xemacs.
06:06:01 <xerox> vincenz, does active means changing in every timetick?
06:06:05 <vincenz> xerox: which makes it inefficient cause you have a huge set of render-operations...that are thrown away each turn
06:06:07 <twb> shapr: but I just use screen, so I don't care :-)
06:06:08 <vincenz> xerox: yeap
06:06:13 <vincenz> xerox: imagine a game of life
06:06:17 <sethk> twb, what's mtty emacs?
06:06:28 <twb> sethk: http://lorentey.hu/project/emacs.html
06:06:35 <xerox> vincenz, in GoL every visible pixel changes in the worst case.
06:06:43 <vincenz> xerox: right
06:06:46 <xerox> Man I can't phrase today.
06:06:51 <twb> sethk: a branch of gnu emacs that supports multiple displays / terminals from a single emacs "daemon".
06:06:51 <vincenz> xerox: but you still have a huge set of render-ops
06:07:13 <vincenz> xerox: my issue is not the rendering but rebuilding a huge render from scratch each time
06:07:20 <xerox> vincenz, I don't see it as much heavy-load...
06:07:24 <sethk> twb, what's the main idea?  To simulate a multihead machine with several single head machines?
06:07:41 <vincenz> xerox: be nice if you could just do 'setPixel'
06:08:00 <twb> sethk: to avoid using screen.
06:08:03 <xerox> Say for example you have a grid, you could render it and save the result in an IORef until the next time it needs redraw (which is known via GTK signals)
06:08:28 <sethk> twb, that's interesting.  I have people running code over in Taiwan and using screen so I can see what they are doing wrong  :)
06:08:29 <twb> sethk: or rather, to use screen and still be able to have a graphical emacs when you're sitting in front an X terminal.
06:08:41 <xerox> Then, rendering the lil squares representing "life" isn't an heavy-load operation, I think...
06:08:50 <vincenz> xerox: hmm prerender into a bitmap
06:08:52 <vincenz> xerox: and blit?
06:08:56 <sethk> twb, why the restriction about GTK?
06:09:04 <twb> sethk: eh?
06:09:16 <xerox> vincenz, what do you mean?
06:09:18 <vincenz> xerox: what bugs me is the two stage process.... create a render, make the render draw
06:09:21 <shapr> twb: Still, I think both gnumacs and xemacs have problems that will never be solved.
06:09:32 <vincenz> xerox: and for that many pixels...it's gonna be a huge render with simple "set pixel" everywhere
06:09:34 <sethk> twb, it says "if you want to work on multiple X displays you have to compile without GTK"
06:09:39 <vincenz> so you build up a huge object you only use once
06:09:50 <twb> sethk: NFI.
06:09:55 <shapr> twb: Oh hey, speaking of irc, have you seen telepathy?
06:09:59 <twb> sethk: I don't use mtty emacs; I use screen instead.
06:10:03 <twb> shapr: nope.
06:10:19 <sethk> twb, ok ... I think I lost the thread of this conversation somewhere along the line  :)
06:10:33 <xerox> The rendering is quantized.  In theory you could reuse the Render action multiple times.
06:10:52 <vincenz> xerox: I'd rather just do a straight set-pixel
06:10:57 <vincenz> possibly on a background image
06:10:58 <shapr> twb: http://telepathy.freedesktop.org/wiki/ - unifies voip and instant messaging across d-bus. I've been wishing for a framework like this over the last several weeks.
06:11:04 <vincenz> and then when it's time to redraw... I blit it
06:11:12 <twb> shapr: dbus is totally non-working on my system.
06:11:15 <xerox> vincenz, you can render only a little part of the view.
06:11:20 <twb> shapr: and I don't use voip or im.
06:11:24 <shapr> I use irc, yahoo, icq, gale, jabber, and skype.
06:11:27 <vincenz> xerox: I don't see how that sovles my problem
06:11:30 <twb> shapr: bitlbee
06:11:42 <shapr> twb: irc counts as instant messaging. Bitlbee doesn't handle gale or skype.
06:11:59 <sethk> shapr, do you get acceptable voice with any of them?  I've been trying to use skype, which is fine for text but useless for voice, at least between here and Taiwan
06:12:03 <xerox> vincenz, if it's small enough, it resembles setPixel, if it's thoughtfully calculated, it could even optimize futher, couldn't it?
06:12:05 <twb> shapr: fair enough.
06:12:24 <vincenz> xerox: so basically a bunch of little renders
06:12:35 <vincenz> xerox: which means you then have to do something like (sequence [list of renders])
06:12:37 <xerox> Which aren't cpu-expensive, imo.
06:12:44 <vincenz> no, it's the sequencing 
06:12:52 <vincenz> sequencing them before issuing that large render
06:12:53 <shapr> sethk: Skype is very scary stuff. Have you seen the blackhat presentation about it?
06:13:13 <xerox> I think your code wouldn't certainly look like that... hmm.
06:13:16 <sethk> shapr, no.  I used it because that's what they have installed at the other end.
06:13:18 <shapr> sethk: Have you tried google talk? Tapioca is the linux client.
06:13:18 <xerox> There's GTK inbetween.
06:13:35 <vincenz> xerox: be nice if my actions directly altered some bitmap
06:13:41 <vincenz> xerox: then with redraw I just flush it to screen
06:13:45 <sethk> shapr, no, I'll give that a try
06:13:57 <twb> http://twb.ath.cx/tmp/tmp.hs 
06:14:05 <xerox> vincenz, GTK takes care of that, that's why I was suggesting to divide static and dynamic layers.
06:14:13 <sethk> shapr, I'm not really worried about security.  If somebody listens to one of these conversations with Taiwan, maybe they can tell me what they other people are saying.  :)
06:14:30 <vincenz> xerox: what are 'save' and 'restore'?
06:14:44 <shapr> sethk: No, I mean skype the application is scary. It's very nearly spyware.
06:14:55 <xerox> vincenz, save stacks the current cairo context on a pile, and restore sets them back.
06:15:02 <vincenz> oh
06:15:09 <twb> shapr: right.  We should all be using ASTERISK!
06:15:31 <xerox> I never got around fully understanding Asterisk.
06:15:39 <shapr> twb: Is asterisk cool? I haven't tried it.
06:15:40 <twb> *no one* understands asterisk.
06:15:47 <twb> shapr: nor me ;-)
06:15:55 <twb> voidNeed twb = []
06:15:57 <xerox> IIRC someone here did.
06:15:58 <vincenz> shapr: how is skype spyeware?
06:16:11 <shapr> CosmicRay understands asterisk.
06:16:13 <vincenz> and what is asterisk
06:16:21 <twb> asterisk is a free PBX.
06:16:26 <twb> Or PABX, if you prefer.
06:16:30 <vincenz> pBX =?
06:16:35 <twb> private branch exchange
06:16:40 <vincenz> ...
06:16:40 <twb> Like a mini telephone company.
06:16:43 <vincenz> ah
06:17:01 <twb> SMEs use them to do internal telephone routing.
06:17:23 <twb> e.g. having voicemail for each office, hold music, redirecting to other offices.
06:17:24 <vincenz> xerox: basically I want to have some random pixels float into my canvas.... and under certain conditions they get stuck... and once they're all stuck ore have walked back out, other pixels start walking over my canvas
06:17:26 <twb> That sort of stuff.
06:17:40 <vincenz> xerox: so it's a very time and pixelated process
06:17:41 <sethk> shapr, yes, I got that.  That's why I said I wasn't worried about security (I wasn't being serious; I understand why spyware is a bad thing)
06:17:51 <xerox> http://72.14.203.104/search?q=cache:Nkan3QMP89oJ:www.secdev.org/conf/skype_BHEU06.pdf+blackhat+skype&hl=it&ct=clnk&cd=1&client=safari
06:18:57 <sethk> what's asterisk about?
06:19:07 <shapr> vincenz: Google for the 'silver needle in the skype' presentation.
06:19:43 <xerox> vincenz, if you have state, you could try to tune up a rendering function which diffs states and builds an "economical" action.
06:19:46 <sethk> xerox,  thanks for the link.  interesting
06:19:54 <xerox> I'm reading it up atm.
06:20:05 <shapr> sethk: Look at the asterisk posts on http://changelog.complete.org/
06:20:12 <shapr> sethk: CosmicRay is using for home and at the office.
06:21:24 <shapr> Anyway, SCTP was designed to run voice phone services across TCP/IP, does anyone use it?
06:21:39 <flux__> it was?
06:21:57 <shapr> I'm pretty sure it was...
06:21:59 * shapr checks again.
06:22:14 <flux__> sctp is cool, though
06:22:34 <vincenz> xerox: perhaps... 
06:22:55 <vincenz> shapr: kinky
06:23:48 <shapr> flux__: from http://en.wikipedia.org/wiki/SCTP - "SCTP was originally intended for the transport of telephony (SS7) protocols over IP, with the goal of duplicating some of the reliability attributes of the SS7 signaling network in IP."
06:24:09 <sethk> shapr, that's only half right
06:24:40 <sethk> shapr, sctp is about payload (audio) traffic.  The 'net already has packet switched signalling
06:25:06 <sethk> shapr, I've done quite a bit of work on cell switches and gotten into these protocols much more than anyone should ever be required to  :)
06:26:23 <shapr> sethk: Ooh, gimme the gossip! How would you describe SCTP? Does this mean you already know Erlang?
06:26:57 <twb> This is too long.  Anyone care to suggest improvements?
06:26:58 <twb> show (Comb xs) = "(" ++ (foldl (++) "" (intersperse " " (map show xs))) ++ ")"
06:27:00 <sethk> shapr, erlang, no.  The SS7 code I've seen is all written in C
06:27:10 <vincenz> xerox: yeah interesting link
06:27:13 <vincenz> xerox: and interesting eggs
06:27:43 <twb> vincenz: this ain't #chicken ;-)
06:28:46 <shapr> sethk: I'm amazed that anyone wrote PSTN code in C.
06:29:06 <Philippa_> I'm not, unfortunately
06:29:14 <vincenz> twb: you'd be surprised
06:29:26 <Philippa_> for a long time the only sensible alternative would've been Ada
06:29:29 <sethk> shapr, almost everything was written in C at Bell labs when a lot of that code was produced
06:29:50 <twb> Philippa_: not forth? :-(
06:29:54 <vincenz> twb: there is a better way yes
06:30:37 <mauke> "(" ++ words (map show xs) ++ ")"
06:30:44 <twb> mauke: ugh, of course!
06:30:45 <vincenz> and use '(' : 
06:30:50 <twb> unwords, tho, right?
06:30:57 <vincenz> > words ["a", "b"]
06:30:57 <lambdabot> Couldn't match `Char' against `[Char]'
06:31:01 <vincenz> > unwords ["a", "b"]
06:31:01 <lambdabot> "a b"
06:31:16 <vincenz> twb: and use shows
06:31:21 <twb> shows?
06:32:01 <vincenz> shows (Comb xs) = '(' : (showString . words . map show $ xs) . showString ")"
06:32:09 <dons> oh. funy funny. it's 1991 all over again: http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg00124.html
06:32:18 <vincenz> shows (Comb xs) = ('(':) . (showString . words . map show $ xs) . showString ")"
06:32:31 <dons> "don't just sit there passively--join C.A.T.S.U.P., the Committee Advocating The Superstitious Use of Parentheses!"
06:33:04 <twb> dons: my old highschool had a Paren Club.
06:33:24 <vincenz> dons: LISP2.0?
06:33:25 <sethk> dons, yes but we're saved by $
06:33:50 <vincenz> twb: you mean Parent Club
06:33:54 <twb> vincenz: nope.
06:33:56 <vincenz> :D
06:34:11 <shapr> My highschool had farmers, jocks, band members, and druggies. I was the weirdo who kept talking about the internet and invisibility machines :-/
06:34:13 <twb> A club for people who enjoy using parentheses.
06:34:18 <vincenz> xerox: so... do you happen to have a short example?
06:34:27 <vincenz> xerox: of what you suggested... some sort of skeleton
06:35:01 <twb> http://patrick.wattle.id.au/cameron/brackets/
06:36:07 <Philippa_> <twb> Philippa_: not forth? :-( <- forth was mostly seeing use on microcomputers, no? I'm not sure that it would've been sufficiently on the radar in the right places, plus IIRC forth itself's not so easy to reason about (regardless of whether other concatenative langs are)?
06:36:23 <twb> Philippa_: shrug
06:36:40 <twb> Philippa_: perhaps I misunderstood the low-levelness requirements.
06:36:58 <twb> As an alternative to assembly, Forth is a lot nicer than C.
06:37:02 <vincenz> twb: forth gives you no guarantees
06:37:07 <vincenz> twb: no bondage like ada
06:37:58 <vincenz> twb: afaict... forth is only nice if you have a) write all the code yourself and reinvent the wheel, b) have a VERY coordinated system where there are a lot of agreements on how to pass parameters, name functions, whatnot
06:38:24 <twb> Meh, I refuse to get into *another* language... discussion.
06:38:25 <Philippa_> twb: I agree. But forth looks a lot scarier to a mangler than C does
06:38:27 <vincenz> the problem is that any function can seriously fuck up everything at a global level
06:38:35 <vincenz> cause they all work on the stack
06:39:02 <twb> vincenz: um, that statement is patently false.
06:39:02 <xerox> shapr, argh, now I'm scared of skype.
06:39:09 <vincenz> xerox: yeah me too
06:39:15 <twb> vincenz: local variables in C use a stack just as much as forth.
06:39:24 <xerox> vincenz, sorry I was reading that.  Clock.hs isn't short enough?
06:39:26 <vincenz> twb: yes but you don't have direct access unless you do nonos
06:39:33 <vincenz> xerox: it's not really targetted at such
06:39:36 <vincenz> xerox: pixel-nitting
06:39:48 <vincenz> twb: besides, c is a poor example
06:40:15 <twb> vincenz: no offense, but I'm not going to get into this discussion again.
06:40:19 <vincenz> twb: in forth you pop once too much ... but
06:40:23 <vincenz> twb: but yeah, you're right
06:40:28 <vincenz> onto other things :)
06:40:46 <twb> I didn't understand your shows comment.
06:40:53 <twb> Why should I use shows instead of show?
06:40:56 <sethk> it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
06:41:05 <vincenz> twb: because show is inefficient..
06:41:12 <vincenz> twb: you generate a string which you then need to use...
06:41:16 <vincenz> twb: shows gives you a String -> String
06:41:17 <twb> vincenz: I don't care about inefficiency yet.
06:41:26 <vincenz> twb: well show is implemented in terms of shows
06:41:50 <vincenz> show x = shows x ""
06:41:54 <twb> It seems silly to write more-complex code before you need to.
06:41:59 <vincenz> twb: it's not more complex
06:42:13 <twb> shows (Comb xs) = ('(':) . (showString . words . map show $ xs) . showString ")"
06:42:13 <twb> vs.
06:42:13 <twb> show (Comb xs) = '(' : unwords (map show xs) ++ ")"
06:43:25 <xerox> Doesn't the first one miss a trailing "$ xs" ?
06:43:42 <vincenz> @type mapM_
06:43:42 <lambdabot> forall (m :: * -> *) a b.
06:43:42 <lambdabot>    (Monad m) =>
06:43:42 <lambdabot>    (a -> m b) -> [a] -> m ()
06:43:45 <vincenz> @type mapM
06:43:46 <lambdabot> forall b (m :: * -> *) a.
06:43:46 <lambdabot>    (Monad m) =>
06:43:46 <lambdabot>    (a -> m b) -> [a] -> m [b]
06:43:54 <twb> xerox: I don't even understand the first one ;-)
06:44:08 <dons> it's the last line of each that matters ;)
06:44:24 <xerox> dons, then I don't understand the composition?
06:44:50 <dons> xerox, oh, I was talking about the @types
06:45:02 <xerox> Wops.
06:45:14 <dons> my fault
06:45:24 <xerox> Ah, I see, it's shows the first one.
06:45:28 <xerox> Nevermind.
06:45:38 <dons> ?remember sethk it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
06:45:38 <lambdabot> Done.
06:49:36 <dons> scary, looking like Miranda was a real worry early on: file:///home/dons/src/ml/haskell-1990-2000/msg00495.html
06:49:57 <dons> oh. hmm. that's not a portable url
06:50:18 <dons> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg00495.html
06:52:48 <bolrod> hrm..
06:54:25 <dons> thank RMS for where we are today :)
06:58:16 <robokop> @id test
06:58:17 <lambdabot> test
07:00:07 <robokop> when i try to run ghci with the wxhaskell package i get an error about libwxc-gtk2.4.2-0.9.4
07:00:41 <robokop> and the prob is that i can't find it at my entire pc
07:01:10 <twb> OMFG, that loaded.
07:01:45 <twb> http://twb.ath.cx/tmp/Main.hs
07:05:32 <robokop> could sb help me with setting up wxhaskell so that it works
07:06:02 <shapr> Anyone tried to write an xscreensaver module in Haskell? :-)
07:06:09 <shapr> I have this cool idea for a screensaver...
07:07:02 <JKnecht> twb: in a Haskell browser plug-in?
07:07:10 <xerox> How you must tell us shapr!
07:07:11 <twb> JKnecht: ?
07:07:16 * ulf_ just got a cool idea from his permutation routine
07:07:30 <ulf_> an anagram finder :)
07:07:49 <twb> JKnecht: no, I was just happy that I managed to trick parsec into working correctly.
07:07:58 <JKnecht> I see.
07:08:01 <Ulfalizer> that uses a dictionary, and that finds anagrams involving any number of words
07:08:07 <dons> hehe, 28 Nov 1991, SPJ asks Paul Hudak: "Paul, Are you seriously proposing removing n+k patterns?  I agree with the sentiment ...
07:08:16 <Philippa_> heh
07:08:24 <shapr> xerox: It's a simple idea, I want my screensaver to show my todo list, my calendar of upcoming appointments, my costs so far this month, and my billable income so far this month.
07:08:29 <twb> thinks: nod and smile
07:08:30 <Philippa_> see, when I get round to implementing a full-blown language *it will not have n+k patterns*
07:08:42 <Philippa_> it might, if you're lucky, have transformational patterns ala the pattern guards paper
07:08:46 <dons> seems like it didn't happen then becauuse the deadline for getting H 1.1 out was too close
07:09:06 <resiak> Bah, n+k patterns are useful.
07:09:10 <Ulfalizer> what are n+k patterns?
07:09:13 <twb> Philippa_: bah, you can just use define-syntax to create pattern matching languages :-)
07:09:13 <shapr> Ulfalizer: evil!
07:09:19 <Ulfalizer> shapr: oh :/
07:09:19 <shapr> Pure unadulterated evil!
07:09:21 <Philippa_> Ulfalizer: f (n+1) = n
07:09:39 <xerox> shapr, right, I'm loving dashboard for that.
07:09:41 <shapr> But seriously, lamdba cal is all about binding on the left, happenings on the right.
07:09:42 <dons> resiak, maybe youu'll like this: file:///home/dons/src/ml/haskell-1990-2000/msg00581.html   c*n+k patterns!
07:09:47 <shapr> xerox: dashboard does that?
07:09:52 <Ulfalizer> Philippa_: hmm, looks pretty nice. that's how i usually think about simple recursion.
07:09:59 <resiak> dons: I might like it if my / was your / ;)
07:10:05 <dons> grr. s,.*ml,http://www.cse.unsw.edu.au/~dons/
07:10:12 <resiak> yeah, I guessed
07:10:18 <Philippa_> Ulfalizer: it's a rather evil special case. Especially as you could just do f n = n-1
07:10:27 <robokop> could sb help me with setting up wxhaskell so that it works
07:10:29 <xerox> shapr, it does show up what interest me, yeah.  And has potential to show some of the information you just listed.
07:10:40 <dons> you could write: fib (2*n+1) = (fib(n+1))^2 + (fib n   )^2
07:10:54 <resiak> Heheh
07:11:11 <Ulfalizer> Philippa_: but does it have any serious problems, like ambigious syntax?
07:11:17 <twb> dons: it should be trivial to extend EVAL to handle such patterns, as long as they are reductive ;-)
07:11:38 <Philippa_> Ulfalizer: yes. It's overloaded
07:11:38 <Ulfalizer> *ambiguous
07:11:39 <twb> dons: you could base it off the symbolic differentiator in the second SICP lecture.
07:11:51 <Philippa_> (admittedly so're plain n-patterns)
07:12:01 <xerox> shapr, dashboards widgets are really html+css+javascript+images
07:12:06 <Ulfalizer> ok
07:12:14 <Ulfalizer> i don't know much haskell yet :)
07:12:18 <xerox> minus s...
07:12:20 <twb> xerox: they should be postscript :P
07:12:40 <shapr> xerox: So maybe cairo screensavers is what I want? :-)
07:12:55 <twb> shapr: xscreensaver can use anything as a display hack.
07:13:06 <twb> shapr: all the hack has to do is draw on the root window.
07:13:12 <dons> haskell-1990-2000/msg00750.html talks about how n+k are still causing trouble 2 years after Haskell 1
07:13:36 <Ulfalizer> would  fib (n + 2) = fib (n + 1) + fib (n)  together with base cases work with n+k patterns?
07:13:37 <twb> shapr: try invoking any of the hacks in /usr/lib/xscreensaver with/without the -root option.
07:13:44 <Ulfalizer> -(n) + n
07:13:57 <Philippa_> Ulfalizer: yup
07:14:05 <sethk> dons, that's like saying it should be trivial to extend EVAL as long as you extend it only to trivial cases  :)
07:14:10 <Ulfalizer> ok, that's a pretty nice syntax, imho
07:14:17 <dons> oh, whatever happened to Brisk, the Bristol Haskell System?
07:15:07 <dons> lets see if the ftp still works...
07:15:08 <Philippa_> Ulfalizer: the problem is that it can play silly buggers with typeclasses, defaulting and the monomorphism restriction
07:15:55 <Ulfalizer> Philippa_: yeah, i don't know enough haskell to determine how well it would play with exisiting language features
07:16:00 <dons> bah. the server's even there. but won't take anonymous logins
07:16:24 <robokop> could sb plz help me with setting up wxhaskell so that it works
07:17:20 <JKnecht> robokop: try offering a fee.
07:17:26 <shapr> dons: wayback machine?
07:18:21 <robokop> JKnecht: want a blowjob
07:18:25 <dons> here's a good anti-n+k one. http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg01192.html
07:18:25 <Philippa_> Ulfalizer: you can get some real "WTF?!" kind of results if you're not careful, it's a real newbie trap
07:18:28 <dons> shapr, no. I decoded spjs's ml archive into html.
07:18:50 <shapr> No, I mean, can you get the Bristol HS via the wayback machine?
07:18:56 <dons> ah. hmm.
07:20:48 <twb> Curse you, bidi!
07:21:00 <twb> Compose would be so much easier to read without you.
07:22:00 <twb> contemplates: (flip (.)) :: (a -> b) -> (b -> c) -> a -> c
07:22:27 <dons> ah, it's even supposed to be here http://www.cs.bris.ac.uk/~ian/Functional/brisk.tgz
07:22:39 <dons> yeah, downloading!
07:22:55 <twb> dons: better than sk8, eh?
07:23:14 <robokop> sb here using wxhaskell
07:23:26 <JKnecht> sorry robokop, native GUI thru Haskell is not a choice of mine, so could only give general, RTFM, common sense, experience and judgement kind of advice.
07:23:52 <dons> yay. a "lost" haskell impl: "Brisk is a compiler and interpreter for a subset of the Haskell language."
07:24:12 <twb> Ooh, cool!
07:24:21 <dons> error :: String -> a
07:24:29 <dons> error str = let {x=x;} in x   --- with a fun prelude!
07:24:34 <twb> If you remove a definition from your .hs then :reload, the it disappears from the REPL, too!
07:24:46 <Ulfalizer> Philippa_: ah, i never realized it was actually already in the language. my book hasn't mentioned it yet. perhaps the author agrees with you =)
07:25:26 <Igloo> dons: Isn't that more wrong than fun?
07:25:29 <dons> > let {x=x;} in x
07:25:30 <lambdabot> Add a type signature
07:25:34 <dons> > let {x=x;} in x :: ()
07:25:35 <lambdabot> Terminated
07:25:38 <dons> works for me!
07:25:53 <robokop> JKnecht: i have to use it for college and can't get it to work, followed different tactics and finally got it installed, but now it gives some error with libwxc-gtk2.4.2-0.9.4.so
07:26:15 <robokop> JKnecht: and after searching for the file i can't find it
07:26:28 <dons> reminds me of the gofer 'undefined': 
07:26:29 <dons> > undefined | False       = undefined :: ()0
07:26:30 <lambdabot>  parse error on input `|'
07:26:32 <dons> > undefined | False       = undefined :: ()0
07:26:32 <lambdabot>  parse error on input `|'
07:26:51 <dons> > undefined | False       = undefined :: ()
07:26:51 <lambdabot>  parse error on input `|'
07:26:56 <Ulfalizer> robokop: you probably need to install wxgtk first. any package management system should do that for you.
07:27:07 <xerox> @type let undefined | False = undefined :: () in undefined
07:27:08 <twb> robokop: aptitude install ~n^wx.*2.4
07:27:08 <lambdabot> () in undefined :: ()
07:27:09 <robokop> done that
07:27:18 <dons> oh silly me
07:27:18 <xerox> Duh.
07:27:19 <Ulfalizer> provided that you're using some *nix
07:27:27 <robokop> jup i do 
07:27:35 <robokop> ubuntu dapper drake
07:27:37 <Igloo> dons: but the report says "-- error stops execution and displays an error message"
07:27:41 <twb> robokop: just for me, run that aptitude line as root.
07:27:46 <dons> > let undefined | False = undefined :: () in undefined
07:27:47 <lambdabot>  Non-exhaustive patterns in function undefined
07:27:53 <Igloo> (hmm, wonder if that should be s/an/the/)
07:27:55 <xerox> Eh!
07:27:56 <dons> Igloo, which report ;) brisk is ooolld
07:27:58 <Ulfalizer> robokop: did you use ubuntu'
07:28:06 <Ulfalizer> s package management system to install wxhaskell?
07:28:29 <Igloo> I'm probably looking at the wrong one, true, but I doubt it was ever the intention that error be allowed to throw away its argument  :-)
07:28:36 <twb> Ulfalizer: if it's asking for 2.4, he should be OK using the ubuntu package.
07:28:51 <Ulfalizer> twb: yeah, i just want to make sure he did use it
07:28:56 <twb> Ulfalizer: IIRC the 2.6 wxhaskell packages for debian/ubuntu have utf-8 problems.
07:29:04 <twb> Hence: robokop: aptitude install ~n^wx.*2.4
07:29:09 <Ulfalizer> and not attempted to compile it on his own or something like that
07:29:14 <twb> Ulfalizer: but he seems to be ignoring me.
07:29:27 <dons> yeah. this is circ. 93. but true. looks like a primError never was written.
07:29:33 <Ulfalizer> ah, aptitude is the ubunto package system frontend?
07:29:43 <dons> or certainly no exception-style error like we have in ghc
07:29:43 <twb> Ulfalizer: one of them, yes.
07:29:49 <Ulfalizer> ok
07:30:03 <robokop> aptitude only installs some examples
07:30:11 <twb> robokop: hmm.
07:30:31 <robokop> The following NEW packages will be installed:
07:30:31 <robokop>   wx2.4-examples
07:30:35 <twb> robokop: oops.
07:30:44 <twb> aptitude install ~n^libwx.*2.4
07:31:06 <twb> robokop: sorry about that; I was trying to avoid you having to install python.
07:31:51 <robokop> np now it is installing some other things
07:32:02 <twb> robokop: also, add "deb http://haskell-unsafe.alioth.debian.org/archive/i386 unstable ." to your /etc/apt/sources.list file (as root)
07:32:33 <robokop> tried that before it said parse error
07:32:45 <twb> robokop: all on one line?
07:32:57 <robokop> yup
07:33:00 <robokop> ldconfig: Can't link /usr/lib//usr/lib/libwxc-gtk2.4.2-0.8.so to libwxc-gtk2.4.2-0.8.so
07:33:06 <robokop> it says now
07:33:19 <twb> robokop: the setup script is fucked.
07:33:41 <twb> robokop: If you're doing this for school, the lecturer presumably has some notes on how to install it?
07:33:55 <robokop> nope only for win and mac os x users
07:34:20 <robokop> and for that i think i should kick dblhelix
07:34:29 <robokop> cause he is my lecturer
07:34:55 <steevo`> hey all
07:35:02 <steevo`> do any of you know objective C?
07:35:03 <twb> robokop: do you have a file /etc/apt/preferences ?
07:35:05 <twb> steevo`: nope.
07:35:12 <twb> steevo`: try #objc ;-)
07:35:45 <steevo`> im in there, no action at all hehe
07:36:11 <robokop> twb: no don't have it (/etc/apt/preferences)
07:36:21 <twb> robokop: good.
07:36:56 <twb> steevo`: objc is a rather vendor-specific thing, these days.
07:37:17 <twb> At least, none of the damn code ever compiles under Linux with gobjc.
07:37:59 <twb> robokop: what architecture are you on?  x86, amd64 or ppc?
07:39:32 <robokop> twb: x86
07:39:37 <twb> robokop: OK.
07:40:12 <twb> robokop: you need to add the following line to your /etc/apt/sources.list file:
07:40:13 <twb> deb http://haskell-unsafe.alioth.debian.org/archive/i386 unstable .
07:42:09 <robokop> twb: done that
07:42:20 <xerox> Been there, done that.
07:42:29 <twb> robokop: now run "aptitude update"
07:43:32 <robokop> twb: roger
07:43:50 <twb> robokop: now run "aptitude install libghc6-wxhaskell0.8"
07:45:03 <twb> If that doesn't work, try "aptitude install libghc6-wxhaskell-dev"
07:45:38 <robokop> twb: first one says nothing to install
07:45:54 <xerox> search for the right name...
07:46:12 <twb> xerox: he's getting dependency errors because ubuntu /= debian :-|
07:46:28 <Igloo> What version of ghc6 do you have?
07:46:39 <robokop> 6.4.1
07:46:43 <twb> I don't wanna add the sid repo or it'll "upgrade" a whole heap of shit.
07:47:02 <robokop> comes with dapper drake
07:48:02 <Igloo> You aren't going to be able to use the WXHaskell debs in haskell-unsafe then
07:48:20 <xerox> Get the debs and hack them? :-)
07:48:44 <robokop> Igloo you are right depends on <6.2.3
07:49:08 <robokop> > 6.4.1 < 6.2.3
07:49:09 <lambdabot>  add an instance declaration for (Num (a -> b))
07:49:28 <robokop> > (6,4,1) < (6,2,3)
07:49:29 <lambdabot> False
07:50:47 <xerox> > (0,undefined) < (1,undefined)
07:50:47 <lambdabot> Add a type signature
07:50:54 <xerox> Err.
07:51:04 <robokop> so should i go dl older version of haskell and use that
07:51:11 <xerox> @type ((undefined,undefined) >)
07:51:12 <lambdabot> forall a a1.
07:51:12 <lambdabot>           (Ord (a, a1)) =>
07:51:12 <lambdabot>           (a, a1) -> Bool
07:51:18 <twb> When I tried to make wxhaskell go under debian, I gave up because it was too hard.
07:51:24 <twb> YMMV.
07:51:28 <xerox> Oh right.
07:51:42 <Igloo> You'd probably be better off building wxhaskell for 6.4.1
07:51:55 <xerox> > (0,undefined :: Int) < (1,undefined)
07:51:56 <lambdabot> True
07:51:57 <robokop> done that, but got that error
07:52:02 <xerox> Right.
07:52:11 <Igloo> What error?
07:52:38 <robokop> Loading package wxcore-0.9.4 ... ghc-6.4.1: can't load .so/.DLL for: wxc-gtk2.4.2-0.9.4 (/usr/local/lib/libwxc-gtk2.4.2-0.9.4.so: undefined symbol: _Z7wxEntryRiPPc)
07:53:04 <robokop> when i try to find it on my pc i can't find it
07:53:15 <twb> At this point, I advise you to start drinking heavily.
07:53:20 <Igloo> Is this trying to load it in ghci?
07:53:29 <moonlite> dons: here? (when did you release hs-plugins 1.0rc0?)
07:53:31 <robokop> yup
07:53:38 <Igloo> It's possible that just doesn't work
07:53:54 <Igloo> For C++ reasons *waves hands*
07:54:08 <Igloo> I'd suggest e-mailing the author to see if this is expected, and if not, how to fix it
07:54:26 <twb> Igloo: this is for school.
07:54:50 <twb> Igloo: apparently robokop's lecturer saw fit to give instructions for Windows and OS X, but not a real OS.
07:55:15 * shapr points accusingly at the value judgement.
07:55:48 <tic> I'd say OS X is a real OS. :)
07:56:05 <xerox> It worked nicely so far.
07:56:06 <tic> (if by "real OS" you mean "comes with coreutils, bash & vim")
07:56:18 <shapr> I think it's fairer to say that the lecturer did not give instructions for Linux.
07:56:45 <ValarQ> tic: the hardware support isn't very great thought
07:56:45 <twb> tic: it doesn't even have seq(1)!
07:57:00 <tic> Well, what'd I know. :)
07:57:06 <xerox> Then Hurd would be a real OS.  <giggle>
07:57:07 <shapr> I could say that a real OS has to have a hardware monad :-P
07:57:21 <shapr> Seriously though, it's better to not imply value judgements and stick to the facts.
07:57:29 <twb> A real OS's arrays start at 0.5
07:57:33 <tic> yes, dad.
07:57:49 <moonlite> dons: nm, i found it from the dates in the packages. :)
07:58:02 <shapr> tic: That's "Dad, Sir" to you!
07:58:05 * shapr grins
07:58:11 * vincenz slaps shapr 
07:58:19 <vincenz> shapr: that @ sign is rising to your haed
07:58:20 <tic> shapr, I'm sorry, sir! It won't be repeated, sir!
07:58:25 * shapr laughs
07:58:38 <ValarQ> hah :)
07:58:51 * tic is happy the Swedish language is completely informal in that sense
07:59:09 <robokop> dutch ftw
07:59:14 <tic> (altough I suppose it's still the case in the military that you have to use titles. I wouldn't know.)
07:59:20 <tic> robokop, bastardized english+swedish+german. :)
07:59:28 <shapr> vincenz: Nah, I'm just saying that implicit value judgements raise the 'emotional temperature' as some call it.
07:59:32 <ValarQ> tic: it sure is
07:59:42 * ValarQ used to work in the swedish navy
07:59:45 * tic agrees with shapr
07:59:47 <tic> ValarQ, fun?
08:00:01 <ValarQ> tic: not that fun...
08:00:19 <robokop> tic those languages you cal are bastard versions of the dutch language :P
08:00:22 <ValarQ> tic: to many NT4 systems for my taste...
08:00:28 <tic> ValarQ, *yuck*
08:00:48 <robokop> well in holland they are working with win 98se
08:00:57 <ValarQ> ow
08:01:11 <tic> robokop, there's an interesting article on germanic languages at Wikipedia, elaborating on how the base form of a word turned into various forms in the different languages.
08:01:41 <tic> Holland seems to be pretty cool. My supervisor is Dutch.
08:01:52 <robokop> tic i know that (ancient germanic)
08:02:29 <tic> robokop, I suppose that's more obvious to you.. To me, I'd feel more at home with Icelandic, I think.
08:03:26 <robokop> yes i guess so
08:03:32 <Ulfalizer> how is the climate in holland compared to sweden? a slightly warmer sweden-alike country is something i could seriously consider moving to :)
08:03:48 <Ulfalizer> it shouldn't be that different from the southern parts of sweden though, i guess..
08:04:14 <tic> Some 300 km?
08:04:15 <robokop> Ulfalizer na bit warmer but not much more
08:04:17 <tic> or 200 km?
08:04:36 <robokop> -4C in winter 25C in summer 
08:04:41 <robokop> and lots of rain
08:04:52 <tic> sweden in a nutshell. ;)
08:05:03 <tic> and not to forget, a lot more orange
08:05:22 <shapr> It's not much rain as compared to Seattle.
08:05:27 <Ulfalizer> where i live it usually gets a lot colder than -4c..
08:06:19 <twb> How would you write this without `do'?
08:06:19 <twb> main = do args <- getArgs
08:06:19 <twb>           putStrLn (readExpr (args !! 0))
08:06:46 <xerox> getArgs >>= putStrLn . readExpr . head
08:06:59 <xerox> putStrLn . readExpr . head =<< getArgs
08:07:04 <twb> Hmm, OK.
08:07:32 <twb> Can I replace `head' with (!!0) ?
08:08:02 <xerox> ?pl (!!0)
08:08:03 <lambdabot> (!! 0)
08:08:20 <xerox> (Yes, you can, but aren't the same?)
08:08:29 <xerox> Ah, ops, you're twb, nevermind :-D
08:09:46 <twb> xerox: I assume that's a compliment :-)
08:09:52 <xerox> Yup :-)
08:09:52 <Philippa> twb: you can, but you're making needless work for the compiler
08:10:00 <Philippa> (and/or for your program at runtime)
08:10:15 <twb> I'm not saying I *want* to.  I'm saying I want to know if I *can*.
08:10:25 <Philippa> yes. Why wouldn't you be able to?
08:10:36 <twb> I was checking my understanding.
08:21:27 <moonlite> is it possible to ghc-pkg hide a package that is installed system-wide for a normal user? (specifically i want to hide cabal-1.0 which was installed via apt-get while installing 1.1.4 and still keep 1.0 around.)
08:22:31 <kuvkir> hi
08:22:40 <kuvkir> how to print all elements of list?
08:22:55 <Lemmih> moonlite: Doesn't GHC pick local packages over global one?
08:23:22 <kuvkir> "map (putStrLn.show) [1,2,3]" doesn't work
08:23:26 <Lemmih> kuvkir: You can use 'print'.
08:23:39 <moonlite> Lemmih: it doesn't seem so
08:23:40 <moonlite> Cannot import `Distribution.Simple': it was found in multiple packages: Cabal-1.0 Cabal-1.1.4
08:24:08 <Lemmih> kuvkir: Or 'mapM_ print list'.
08:24:16 <moonlite> this is what i get when running "make install" when trying to install cabal 1.1.4.
08:25:27 <moonlite> oh well, since i have root on this mahcine it is ok, but iw would be troublesome installing a new cabal in school for instance
08:25:42 <kuvkir> Lemmih: thanks :)
08:34:30 <steevo`> anyone know of a good text editor for windows
08:34:38 <steevo`> that will let me save .h and .c etc
08:34:40 <Blicero> emacs
08:34:42 <steevo`> without farking appending .txt
08:34:43 <steevo`> lol
08:34:47 <qwr> vim
08:35:22 <steevo`> google - emacs?
08:36:08 <steevo`> ?
08:36:20 <Blicero> yeah first hit
08:37:24 <steevo`> i jsut want something as basic as notepad
08:37:26 <steevo`> you know?>
08:37:42 <Vendetta4v> try notepad++
08:38:28 <xerox> Try Emacs!
08:38:42 <steevo`> emacs looks like its complex
08:38:46 <steevo`> and i have to learn obj c
08:38:47 <steevo`> hehe
08:39:03 <xerox> No way.
08:39:39 <xerox> You just read its tutorial, and you're done for your notepad needs.  Now ready for the interesting bits :-)
08:41:06 <Vendetta4v> but I think its not convenient for new users
08:51:12 <Philippa> steevo`: not as simple as you're asking for (though you can ignore all but the MDIness for complexity at first), but Textpad's good
08:56:31 <BlurredWe> I was asking about compilers a couple of days ago, check out what I found: http://www.compsci.bristol.ac.uk/Teaching/Resources/COMS30122/haskell/calc/index.html
08:57:02 <BlurredWe> yay walkthrough of how he built his compiler (well, it has the pieces of a compiler at least)
08:58:32 <Philippa> it's not
08:58:43 <Philippa> it's an interpreter walkthrough, that's significantly different and a lot easier to write
08:59:16 <BlurredWe> it has the scanner + parser + tree building, all thats left is optimization (meh) and code gen
08:59:51 <Philippa> "all"!
08:59:56 <BlurredWe> instead of code gen, it does interpretation.  Still nice and helpful, just need to go decipher it now and figure out how it does some of it's stuff
09:00:10 <Philippa> really, all that's there is parsing in a slightly broader sense
09:00:25 <Philippa> plus a simple interpreter that doesn't even need to type check
09:00:45 <BlurredWe> heh, code gen isn't hard, you just need to walk the tree and output correct code.  Optimization is where compilers get really complicated.
09:00:46 <Philippa> I'm not saying it's useless, but it's much equivalent to a single parsec-based parser and an evaluation func
09:01:12 <Philippa> code gen can be surprisingly involved if your language doesn't directly fit the model of the one you're compiling to
09:01:38 <Philippa> compiling haskell to C would be an example
09:01:43 <BlurredWe> Really my goal is to rewrite my compilers project from this semester (compiling a subset of C, written in C) to haskell, and I'd like to do it by hand, and not use the various parser/scanner tools
09:02:57 <Philippa> how much "by hand"?
09:03:03 <Philippa> parsec's not a code generator, it's an ordinary library
09:03:12 <Muad_Dibber> dons: see lambdabot wikipage
09:03:30 <twb> BlurredWe: I would've thought writing a Scheme compiler in Scheme would be significantly easier than writing a Haskell compiler in Haskell.
09:03:50 <BlurredWe> I have all the theory, and I want to learn haskell well, so I'd like to learn to do things like handling strings and such, but I'
09:03:56 <BlurredWe> I'll take a look at the parsec library
09:04:17 <Philippa> twb: remind me, does scheme have a 'compile' primitive? If so that's cheating :-)
09:04:31 <twb> Philippa: not in r5rs.
09:04:33 <Philippa> Parsec's sweet. There's also a good paper describing how it works
09:04:37 <Philippa> fair enough
09:04:38 <twb> Philippa: it does have READ and EVAL, tho.
09:05:01 <Philippa> yeah, though eval's not much good for a compiler targetting something other than scheme as an object language
09:05:05 <twb> Parsec is pretty much a straight port of a Clean library, isn't it?
09:05:14 <Philippa> I suspect it's the other way round
09:05:47 <Philippa> monadic parsing was first done in haskell and gofer AFAIK, and Parsec had some reasonably specific design work go into it (see paper)
09:06:05 <twb> Another cool thing to do would be to compile everything down to SKI.
09:06:20 <twb> FSVO everything.
09:06:42 <xerox> You see, *down* to ski... australian fools.
09:06:56 <Philippa> that's been and done though. Not overly interesting IMO
09:07:16 <Philippa> I would like to build something GRIN-based targetting C (yeah, I know, been done too)
09:07:25 <twb> xerox: there's only one of me.
09:07:39 <BlurredWe> Parsec is very cool, I was just looking at how easy it is to create little test parses (like the parenthesis example)
09:07:53 <Philippa> by and large it scales too
09:08:19 <Philippa> and you can do some really impressive things with it: I've got an extensible wiki parser where extensions don't need to know about each other, for example
09:08:41 <Philippa> that is, the extensions are effectively data you pass in to the main parser
09:09:14 <Philippa> (if you consider what's involved in handling ```this``` correctly as an extension while allowing 'this' to contain further markup, you'll realise why that's impressive)
09:09:40 <BlurredWe> yeah, I'll certainly look into it, and might even use it, but the main motivation of my little project is just to learn haskell.  I need to actually write a real program in it, I've gone through tutorials, but need something real
09:10:14 <shapr> BlurredWe: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
09:10:27 <Philippa> fair enough
09:10:28 * Maddas found that a few days ago too
09:10:32 <vincenz> blah
09:10:35 * xerox found Maddas
09:10:37 <Philippa> start off with the evaluator part and write the parser second?
09:10:41 * Maddas hides again
09:10:45 <xerox> Oww.
09:10:46 * vincenz xeros Maddas
09:10:50 * vincenz xeroxs Maddas
09:10:51 <Philippa> ('cos it's tolerable to build some basic expressions with the AST by hand)
09:11:11 * xerox Maddases vincenz
09:11:15 <BlurredWe> yeah, unfortunatly, I don't know scheme, so writing a compiler for it in a language I dont' really know would be too many unknowns :)
09:11:23 <vincenz> xerox: should change that to asses and B instead of M
09:11:29 <Maddas> :-)
09:11:53 <xerox> Scheme is way simple, BlurredWe, maybe it's easy enough for you to poke at it for a sec.
09:11:56 * vincenz needs a new nickname
09:12:04 <vincenz> xerox: not if you have continuations
09:12:10 <bourbaki> moin
09:12:14 <vincenz> bourbaki: aloha
09:12:22 <xerox> vincenz, continuations are for later.
09:12:29 <vincenz> hmm
09:12:33 <vincenz> how do I get my thingy on planethaskell
09:12:48 <xerox> In fact, for me, continuations are yet-to-be-done.
09:12:49 <bourbaki> does anyone of you know an article on binding .o files from haskell into c++?
09:14:35 <Lemmih> bourbaki: Using Haskell from C++ is the same as using Haskell from C.
09:15:11 <twb> Lemmih: and the converse?
09:15:17 <bourbaki> ok and how do i do that :)
09:15:34 <tic> twb, the converse is probably not the same because of name mangling and sch.
09:15:35 <tic> such.
09:15:40 <twb> tic: yep.
09:15:42 <Lemmih> twb: Yes, actually.
09:15:47 <twb> Oh!
09:15:50 <Lemmih> Or well, kinda.
09:16:06 <Lemmih> You first make a C binding to the C++ and then a Haskell binding to the C.
09:16:21 <twb> I thought as much.
09:16:30 <twb> C++ sucks.
09:16:41 <tic> like SWIG does it.
09:17:06 <bourbaki> Lemmih isnt there an arcitle on the haskell c thingy?
09:18:15 <xerox> GHC documentation?
09:18:21 <xerox> @docs
09:18:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:18:28 <xerox> Strip "libraries.*"
09:20:07 <twb> xerox: just push the "up" button in your browser :-)
09:20:25 <xerox> Heh.
09:21:31 <twb> I wonder if we'll soon see the rephormed-style button bar replacing the traditional address bar in browser.
09:22:35 <vincenz> xerox: given how canvases are vectoric... instead of pixelbased...how do you draw pixxels?
09:23:20 <xerox> You don't draw pixels, you draw shapes.
09:23:28 <vincenz> xerox: what if I wanted pixels
09:23:53 <xerox> You scale the region to certain coordinate values, and then draw good enough shapes.
09:23:53 <Saulzar> Devide it into squares? :)
09:24:00 <twb> vincenz: you draw a rect of size (Px 1,Px 1) ?
09:24:12 <vincenz> twb: yeah and then if you mess up... some are 2 pixels and some are 0 pixels
09:24:14 <Maddas> Or a circle?
09:24:41 <vincenz> it's like trying to do exact math with doubles
09:24:50 <vincenz> if all you need are integrals
09:24:55 <twb> vincenz: why do you want pixels?
09:24:57 <Saulzar> What purpose are you wanting to individual pixels for?
09:25:13 <vincenz> because that is what I want to draw?
09:25:22 <vincenz> I have a grid...with things moving on it
09:25:29 <twb> Drawing pixels is an unusual end goal.
09:25:38 <Saulzar> You could draw pixels to a pixmap and draw that over the top
09:25:42 <twb> Why not define the grid in point or picas instead of pixels?
09:25:53 <twb> s/point/points/
09:25:58 <vincenz> twb: cause each pixel is significant so you want to be sure you see em
09:26:35 <vincenz> I define a grid to be my world
09:26:39 <vincenz> and movement is from one grid-cell to the next
09:26:43 <vincenz> and since I want to visualize a lot
09:26:45 <xerox> Eh
09:26:47 <vincenz> using pixels as gridcells is ideal
09:27:03 <xerox> You can.
09:27:08 <twb> I don't see why you can't use points instead of pixels.
09:27:22 <xerox> You justhave to build  the framework ontop of the vector graphics.  Dots as pixels.
09:27:29 <twb> Note that a Point is 1/72", not a mathematical point.
09:27:30 <vincenz> xerox: whic is counterintuitive
09:27:33 <Saulzar> I'd use a pixmap
09:27:36 <vincenz> xerox: cause the computer uses a gridbased system
09:27:57 <xerox> vincenz, You decide the scale, that is.
09:28:05 <twb> vincenz: not all pixels are square.
09:28:13 <vincenz> so I have to do exact math... to ensure that the math used underneath cairo which maps vectorials to pixels is counterbalanced
09:28:32 <vincenz> twb: I never said they have to be square...
09:28:37 * araujo back from univ.
09:28:40 <twb> vincenz: and you'd have to assume or detect the DPI, and so on.
09:28:41 <xerox> You scale it down to (0,0) (1,1), then you pick 0.1 wide columns, and you're more or less done.
09:28:59 <xerox> Then, scale it to whatever dimension, and it will look good nevertheless.
09:29:11 <xerox> (I ever get the terms right, I hope you get the idea.)
09:29:13 <vincenz> look it's not complex... a screen uses a grid... and now I have to go to vectors and hope the vector->grid is a perfect reverse of my math
09:29:21 <vincenz> why can't' I just access that grid in the first place
09:29:32 <xerox> Because of cairo design.
09:29:37 <twb> For the same reason that you can't program imperatively in haskell.
09:29:39 <vincenz> so are there alternatives?
09:29:42 <Saulzar> Abstraction for screen-independant drawing makes that hard :)
09:29:51 <xerox> twb, I don't think so.
09:29:58 <Saulzar> Yeah, you can draw a pixmap over cairo at the exact resolution of your window...
09:30:11 <vincenz> Saulzar: how do you draw on pixmaps?
09:30:20 <Saulzar> set/get pixel 
09:30:29 <vincenz> and how do I flush this pixmapto screen
09:30:29 <Saulzar> (Or the gtk shape drawing routines)
09:30:56 <Saulzar> You can draw it with cairo then draw other cairo shapes over the top
09:31:05 <vincenz> hmm
09:31:09 <xerox> I would rather do it in cairo than on a calculate-on-my-side-gtk-things basis.
09:31:27 <Saulzar> Or draw other shapes and draw your pixmap over the top (using alpha to mask everywhere except the pixels)
09:31:38 <vincenz> well I only realy need the pixels
09:32:09 <twb> I'm pretty sure that trying to do things in display pixels is Wrong, but I'm not well versed enough to say why.
09:32:14 <Saulzar> xerox, That sounds a good idea to me too... though if the shapes are very small then the anti-aliasing could be a pain
09:32:36 <vincenz> Saulzar: and lining the shapes up so there's no accidental gaps or stuff like that
09:32:46 <vincenz> twb: and I'm pretty sure it's not
09:33:09 <Saulzar> Hmm, if you draw two shapes connected in cairo I'm pretty sure the fill conventions are such that there will be no gap
09:33:21 <vincenz> Saulzar: well you assume they'll be connected...
09:33:28 <vincenz> basically I'm making random cells move over my grid
09:33:31 <vincenz> and if they hit, they stop moving
09:33:42 <xerox> Saluzar, then set a minimal size request for the GTK window.
09:33:59 <xerox> See the Clock.hs example for the details.
09:34:05 * vincenz nods
09:34:14 <Saulzar> What is this for? :)
09:34:19 <vincenz> Saulzar: me?
09:34:23 <Saulzar> Yeah.
09:34:33 <vincenz> Saulzar: well I'm trying to display structures resulting from the historical science
09:34:42 <vincenz> Saulzar: read my blog on ubiquity ... (plan to add more soon)
09:35:16 <vincenz> I want to see what kind of fractal-like shapes you get from different conditions
09:36:11 <Philippa> <twb> For the same reason that you can't program imperatively in haskell. <- somebody doesn't know haskell very well
09:36:28 <twb> Philippa: you can, but it's a pain.
09:36:33 <vincenz> twb: lol erm no?
09:36:52 <twb> Philippa: likewise, getting to the raw pixels in a vector api is also a pain.
09:37:31 <xerox> But I think they're two widely different things.
09:37:43 <Philippa> imperative code in Haskell is easy IME
09:37:45 <vincenz> @hoogle widgetGetDrawWindow
09:37:45 <lambdabot> No matches found
09:37:52 * twb gives up
09:38:03 <Philippa> considerably more so than getting raw pixels out of any vector API I've had to try to do it with and getting the exact results I want
09:38:13 <vincenz> gtk2hs REALLy needs an index or serach function
09:38:17 <Maddas> twb: I think I know what you mean, if that helps ;-)
09:38:31 <xerox> Next Haddock will spit out hoogle index
09:38:31 <dcoutts__> vincenz: it's going to be added to hoogle some time I believe
09:38:35 <Philippa> yeah. I know what twb /means/...
09:38:35 <vincenz> dcoutts__: cocol :)
09:38:48 <vincenz> widgetGetDrawWindow...where?
09:39:11 <dcoutts__> vincenz: in the widget module, but only in the devel version
09:39:14 <vincenz> ah
09:39:18 <vincenz> that explains :D
09:39:32 <dcoutts__> otherwise there is drawingAreaGetDrawWindow
09:39:39 <vincenz> dcoutts__: return type is DrawableWindow?
09:39:49 <dcoutts__> return type is DrawWindow
09:39:55 <dcoutts__> widgetGetDrawWindow is just a generalisation
09:40:03 <vincenz> perfect :)
09:40:15 <vincenz> so I can draw pixels ontop of it
09:40:23 <dcoutts__> right
09:40:28 <vincenz> \o/
09:40:44 <dcoutts__> and it is possible to get the pixels out of a cairo surface if that's what you were talking about
09:40:46 <vincenz> how do you set the color?
09:41:05 <dcoutts__> however they're in a slightly odd pixel format (pre-multiplied alpha)
09:41:30 <dcoutts__> vincenz: the background colour of a widget you mean? or current drawing colour in cairo?
09:41:51 <vincenz> dcoutts__: current drawing color for drawable's
09:41:53 <vincenz> gdk
09:42:05 <dcoutts__> oh, check the Gdk module
09:42:33 <vincenz> ah
09:42:34 <vincenz> thx
09:42:49 <xerox> dcoutts for the resque!
09:43:24 <dcoutts__> vincenz: http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Gdk-GC.html
09:43:33 <vincenz> yep :)
09:43:50 <dcoutts__> vincenz: gdk use 'GC's for drawing options
09:43:54 * vincenz hmms... should I use double-buffering?
09:44:00 <dcoutts__> yes
09:44:03 <dcoutts__> it's cheap
09:44:03 * xerox shouts WHAT I SAID
09:44:06 <xerox> :-)
09:44:14 <vincenz> dcoutts__: which implies the window can't resize
09:44:19 <dcoutts__> nope
09:44:30 <xerox> *evil laugh*
09:44:31 <dcoutts__> gtk+ does souble buffering by deault
09:44:35 <vincenz> so when do you draw on that other buffer?
09:44:36 <dcoutts__> souble/double
09:44:38 <vincenz> second thread?
09:45:04 <dcoutts__> when you draw in an expose event, gtk+ manages the double buffering automagically
09:45:20 <vincenz> oh
09:45:26 <dcoutts__> if you draw outside of an expose event (which is not a good idea) then it wont
09:45:31 <vincenz> so I don't need to make a pixmap mysefl
09:45:35 <dcoutts__> right
09:45:44 <vincenz> ok....hmm... what is faster?
09:45:48 <vincenz> drawing to pixmap or to screenmap?
09:46:14 <dcoutts__> direct to screen is marginally quicker, but risks tearing/flickering effects
09:46:16 <vincenz> would it be better to have a thread continually update a pixmap and have the main thread fish this and dump it to screen, or just put that entire thread as mainthread
09:46:31 <dcoutts__> depends on how complex the drawing operation is
09:46:47 <vincenz> dcoutts__: hmm.. dpeends on the exact application
09:46:57 <vincenz> I guess top complexity ~ complexity of GoL
09:47:17 <dcoutts__> if it can be done 'live' then do that, otherwise (eg a raytracer) you can draw to an offscreen pixmap
09:47:35 <vincenz> dcoutts__: well hopefully I'll have MANY iterations/second
09:47:43 <dcoutts__> ok then, do it live
09:47:48 <vincenz> okies :)
09:48:00 <vincenz> but won't the refresh-cycle slow me down then?
09:48:10 <dcoutts__> (gtk does double buffering by redirecting the window of the widget to a pixmap and then copying it to the screen at the end of the expose signal handler)
09:48:31 <dcoutts__> vincenz: double buffering is especially important for non-flickering when animating
09:48:37 <vincenz> yep
09:48:43 <dcoutts__> esepcially if your scene involves overlapping elements
09:48:56 <Philippa> I imagine that blitting between pixmaps is hardware-accelerated where possible too?
09:49:03 <dcoutts__> Philippa: yes
09:49:08 <vincenz> Philippa: in the sense of a DMA?
09:49:11 <Philippa> in which case, really don't worry about the cost
09:49:16 <dcoutts__> it's easy to turn on/off gtk's double buffering
09:49:34 <vincenz> dcoutts__: but what if I want to have many iterations... and only display at random intervals so the refresh-cycle doesn't slow down the actual simulation
09:49:42 <Philippa> vincenz: in the sense of usually it's on video memory and the card does it, or it's in AGP memory and the target buffer's in vidmem and it gets better-than-DMA performance
09:50:26 <vincenz> well start simple I guess
09:50:28 <dcoutts__> vincenz: then seperate the simulation from the displaying, it's not effecient to generate famres that will never be displayed
09:50:29 * vincenz hacks clock
09:50:31 <dcoutts__> widgetSetDoubleBuffered
09:50:52 <dcoutts__> eg for my ant sim I run 14 sim steps for each screen frame
09:50:58 <vincenz> what is 'widgetSetAppPaintable'
09:51:04 <vincenz> dcoutts__: in a separate thread?
09:51:12 <vincenz> dcoutts__: and then with a 'tell-refresh'
09:51:16 <vincenz> and an io-ref for the pixmap?
09:51:16 <dcoutts__> vincenz: no, in an idle handler
09:51:23 <vincenz> o.O
09:51:47 <dcoutts__> idle hander is great for interleaving animation with a responsive gui
09:52:24 <dcoutts__> vincenz:  'widgetSetAppPaintable' says you're going to draw the widget background yourself. So in particular gtk will not clear the widget to the background colour.
09:52:30 <vincenz> ah
09:52:32 * vincenz nods
09:52:41 <dcoutts__> vincenz: which is important if your window is going to be transparent :-)
09:52:44 <vincenz> dcoutts__: have any examples of the idle-handler?
09:52:58 <dcoutts__> vincenz: let me give you the code to my ant sim
09:53:01 <vincenz> dcoutts__: thx
09:53:31 <vincenz> btw... windowSetSize most likely sets the outer-box size... not the client area size
09:53:55 <dcoutts__> vincenz: yes
09:54:16 <dcoutts__> vincenz: well, but not including window decoration
09:54:32 <vincenz> anyway to force the client area to have a certain size (the part that you cna draw on)
09:54:49 <davidhouse> what do people recommend for haskell unit testing?
09:54:58 <vincenz> davidhouse: quickcheck
09:55:04 <davidhouse> @where quickcheck
09:55:05 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
09:55:25 <twb> @index Kons
09:55:26 <lambdabot> bzzt
09:55:29 <twb> @index Pair
09:55:30 <lambdabot> bzzt
09:55:36 <twb> Hmph.
09:55:42 <dcoutts__> vincenz: are you drawing directly onto the window, or to another widget inside (eg a DrawingArea)?
09:55:59 <davidhouse> @index (:)
09:56:00 <lambdabot> bzzt
09:56:08 <davidhouse> @index Just
09:56:09 <lambdabot> Data.Maybe, Prelude
09:56:13 <davidhouse> odd.
09:56:14 <vincenz> dcoutts__: whatever you sugeest
09:56:16 <vincenz> onRealize :: WidgetClass w => w -> IO () -> IO (ConnectId w)
09:56:17 <vincenz> This widget's drawing area is about to be destroyed.
09:56:24 <vincenz> (wouldn't it be created instead of destroyed?)
09:56:36 <dcoutts__> vincenz: yes
09:56:47 <dcoutts__> vincenz: drawing to a DrawingArea is most common
09:56:53 <vincenz> okies
09:57:05 <dcoutts__> in which case you just set a size for that and the window will get sized appropriately
09:57:15 <vincenz> dcoutts__: yep
09:57:28 <vincenz> and I set doublebuffered on it instead of the window
09:57:31 <dcoutts__> vincenz: http://haskell.org/~duncan/gtk2hs/ants/
09:57:47 <vincenz> dcoutts__: thx
09:57:52 <dcoutts__> vincenz: yes, if you're trying to turn it off (since it's double buffered by default)
09:58:08 <vincenz> oh
09:58:10 <vincenz> odd
09:58:12 <vincenz> clock sets it on
09:58:19 <vincenz>   widgetSetDoubleBuffered window
09:58:22 <vincenz> (Clock.hs)
09:59:11 <dcoutts__> really? I can't find that
09:59:18 <dcoutts__> vincenz: that ants app is not finnished, but it is optimised for speed :-)
09:59:39 <vincenz> okies :)
09:59:42 <dcoutts__> it pulls many tricks to be as fast as possible on redraw and on animation
09:59:53 <dcoutts__> and works well over remote X connections
10:00:13 <dcoutts__> the idle handler stuff is quite nice
10:00:58 <dcoutts__> oh, the current code is using timeoutAddFull to make it run not so fast, but as the comment suggest you can use idleAdd to run it at full speed
10:01:24 <davidhouse> vincenz: hmm... with quickcheck it doesn't look like you actually specify your test data. how does the program know about boundary conditions, and so on?
10:01:45 <dcoutts__> vincenz: I gotta go
10:02:23 <vincenz> dcoutts__: ok thx
10:02:53 <vincenz> davidhouse: it generates many samples... you can control how data is generated
10:03:29 <vincenz> davidhouse: by defining instances of Arbitrary for custom data-types
10:03:38 <davidhouse> hmm
10:04:01 <davidhouse> anyone played with HUnit and got any opinions?
10:04:07 <davidhouse> (just checking out the options)
10:04:34 <SyntaxNinja> davidhouse: I like them both for different things.
10:05:05 <davidhouse> SyntaxNinja: oh?
10:05:16 <SyntaxNinja> davidhouse: somewhere out there, I have a module which lets you buld lists of hunit and quickcheck tests :)
10:05:35 <davidhouse> SyntaxNinja: which different things?
10:06:43 <SyntaxNinja> davidhouse: quickcheck generates random test cases for you, and HUnit allows you to specifify exactly which test cases to run.  both are useful ways of testing.
10:07:03 <davidhouse> yes.
10:07:24 <davidhouse> i think i'll play with both.
10:08:11 <tony2> I started using quickcheck last night, and have so far had a very plesant experiance with it.
10:08:57 <tony2> the two papers on the site do give a very good intro.
10:10:23 <twb> The only problem I had with quickcheck was that my test functions were thrice the size of the functions they were testing! :-)
10:10:58 <xerox> It suggest improvements!
10:12:42 <tony2> three times as long...you should probably write quickCheck functions to test those.
10:12:54 <norpan> QuickCheck is good
10:14:23 <metaperl-> Craft is still the best Haskell book right?
10:15:11 <norpan> i don't like it
10:15:22 <metaperl-> norpan: what do you like?
10:15:50 <norpan> i like yet another haskell tutorial
10:16:07 <metaperl-> oh I didn't like that
10:16:15 <metaperl-> I liked Craft much better
10:19:07 <shapr> QuickCheck r0xx
10:19:18 <vincenz> yep
10:20:01 <vincenz> for all those people that are not 'L337' scriptkiddies, shapr said "QuickCheck rocks"
10:20:38 <vincenz> and for all those not knowledgeable of slang, this means "QuickCheck is very good"
10:22:20 <mauke> quick, check rocks!
10:22:25 <twb> f' being a valid identifier is very nice, but I wish p? was, too.
10:22:29 <Lemmih> And for all those not knowledgeable of English, this means "QuickCheck er virkelig sej".
10:22:59 <twb> Lemmih: what did you say before "quickcheck"?
10:23:13 <davidhouse> heh.
10:23:31 <Lemmih> twb: 'means'?
10:23:31 <davidhouse> twb can't read english, but can speak it perfectly.
10:23:34 <mauke> und für alle, die kein englisch sprechen, das heißt "QuickCheck ist toll"
10:23:39 <vincenz> davidhouse: odd ain't it
10:23:45 * shapr grins
10:23:52 <shapr> vincenz: I am s0 l33t
10:23:58 <vincenz> davidhouse: but it's like most coders
10:24:05 <vincenz> davidhouse: they can code...but noone can read what they wrote
10:24:12 <vincenz> even though they communicate in one programming language
10:24:18 <shapr> Ok, maybe I'm not 'leet, but I do like to pretend sometimes.
10:24:31 <vincenz> shapr: leet is bad tho
10:24:51 <vincenz> shapr: it implies you're a 13-yr old scriptkiddy who thinks he's 'L337' cause he downloaded a program that does stuff
10:24:53 <Philippa> 1337 15 84/)!
10:25:07 <Philippa> that, or that you have a well-developed sense of irony
10:25:20 <vincenz> Philippa: yeah
10:25:34 * vincenz mutters
10:25:37 <vincenz> my gnome-app bar crashed
10:25:40 <vincenz> it's not responding
10:25:43 <vincenz> :q
10:25:54 * vincenz reboos
10:26:09 <twb> Philippa: "_1984_ is leet"?
10:26:28 <Philippa> late, more like. It's happening in 2006 here
10:26:40 <vincenz> twb: well only if you give it a happy ending
10:26:43 <twb> Note the underscores.
10:28:45 <shapr> vincenz: I downloaded GHC. Couldn't build it though.
10:28:51 * shapr grins
10:30:56 <twb> Rather than returning "Either Error a", is there a standard way to just fail unrecoverably?
10:30:58 <Saulzar> There are a few people who have asked about this kind of thing, maybe give a link next time :)
10:31:25 <mauke> @type error
10:31:25 <lambdabot> forall a. [Char] -> a
10:31:39 <twb> Thanks.
10:33:18 <Blicero> why does the only implementation of hashtable in ghc use IO? couldnt a non-IO version be made on top of Array?
10:34:22 <twb> What's the match anything guard?  Should I just use True ?
10:34:27 <shapr> otherwise
10:34:34 <mauke> otherwise = True
10:34:36 <twb> Thank you.
10:35:23 <SyntaxNinja> > otherwise
10:35:24 <lambdabot> True
10:38:05 <ibid> Blicero: i suppose it'd make sense for perfect hashing. the reason: nobody has done the work :)
10:38:28 <Blicero> ahh
10:39:58 <ibid> Blicero: note that for normal uses of hashtables (updates and accesses interleaved), non-IO arrays destroy all the good things of a hashtable
10:40:31 <Blicero>  // is too computationally expensive?
10:40:51 <ibid> Blicero: update copies the arrow
10:40:57 <ibid> ... array
10:41:37 <Blicero> yeah its inefficient for memory but i was wondering how computationally expensive it was
10:41:45 <ibid> Blicero: O(n)
10:41:51 <Blicero> ah, thanks
10:41:55 <ibid> (where n is the number of buckets in an array)
10:42:04 <ibid> i think that's obvious :)
10:55:01 <punya> Has anyone written a Parsec parser for Java that is available under an OSS license?
11:01:12 <xerox> It would be cool to have something like SLIME/Swank remote interpreter mode.
11:09:39 <stepcut> @pointless (\i a -> print (i * a))
11:09:40 <lambdabot> (print .) . (*)
11:18:31 <stepcut> @pointless (\f l -> foldM (\i a -> f i a >> return (i + 1)) 0 l)
11:18:32 <lambdabot> flip foldM 0 . (`ap` (return . (1 +))) . ((flip . ((>>) .)) .)
11:18:38 <stepcut> heh
11:18:50 <stepcut> much clearer ;)
11:32:05 <lisppaste2> Tony_Sidaway pasted "ghc 6 (Ubuntu) gives "hello.hs:5:10: The last statement in a 'do' construct must be an expression"" at http://paste.lisp.org/display/18619
11:32:26 <Tony_Sidaway> Anybody care to help me with an extreme newbie question?
11:32:29 <Tony_Sidaway> See paste.
11:33:06 <Tony_Sidaway> I'm a schemer trying to get to know a little haskell.
11:33:16 <Igloo> You need to indent the last line more
11:33:22 <Tony_Sidaway> Thanks.
11:33:24 <Igloo> Su the p of putStrLn is below the a of args
11:33:43 <Tony_Sidaway> I was just hitting tab and assumed that was enough.
11:34:00 <astrolabe> I think it's better to use spaces in haskell
11:34:26 <Tony_Sidaway> yay compiles
11:34:27 <Tony_Sidaway> !
11:34:46 <Igloo> What does a thingy (shadow?) of wikipedia/Foo actually mean, out of interest?
11:34:52 <Muad_Dibber> dons, ping
11:34:54 <astrolabe> the report says a tab = 8 spaces, but editors may differ
11:35:12 <Igloo> Tony_Sidaway: args !! 0 is more normally written head args, incidentally
11:35:23 <Tony_Sidaway> It means that the mask was obtained by a Wikipedia editor as part of his participation in the Wikipedia project.
11:35:56 <Tony_Sidaway> Igloo, thanks.  I'm just typing in the example from the tutorial I'm following. This was my first Haskell program.
11:36:22 <Igloo> Oh, seems a curious thing for a tutorial to do
11:37:13 <Tony_Sidaway> It's an odd sort of tutorial.  He teaches Haskell by showing you how to write a Scheme interpreter in Haskell.
11:37:39 <Tony_Sidaway> Since I'm reasonably au fait with Scheme, it seemed like worth a go.
11:38:10 <Tony_Sidaway> http://halogen.note.amherst.edu/%7Ejdtang/scheme_in_48/tutorial/firststeps.html (Jonathan Tang)
11:49:49 <davidhouse> alritey, for all of you that said you liked quickcheck, here's a question:
11:50:14 <vincenz> lALALALALALA
11:50:45 <davidhouse> i want a generator for "passwords", which are essentially strings, but only containing the characters xud*?().
11:51:12 <shapr> davidhouse: make a String instance?
11:51:24 <davidhouse> huh? String isn't a class
11:52:14 <davidhouse> i've done what the manual says:
11:52:34 <davidhouse> newtype Password = Password String; instance Arbitrary Password where arbitrary = ...
11:52:42 <davidhouse> i'm just not sure what to use in the ...
11:54:43 <lisppaste2> Tony_Sidaway annotated #18619 with "Why is arg0 <- args !! 0 an error within the IO monad?" at http://paste.lisp.org/display/18619#1
11:55:22 <Igloo> Tony_Sidaway: things on the right of <- need to have type IO a, with the things on the left then having type a
11:55:30 <Igloo> But args !! 0 :: String
11:55:47 <shapr> davidhouse: oneof "xud*?()"
11:55:49 <Tony_Sidaway> thanks
11:55:57 <Igloo> davidhouse: Pick a random length in the range you want, then use something like oneOf that many times to make the password
11:56:02 <davidhouse> shapr, i want a list of that though.
11:56:19 <davidhouse> perhaps sequence $ replicate n $ oneOf "xud*?()"
11:56:35 <Igloo> sequence . replicate n == replicateM n
11:56:36 <shapr> I think there's already an Arbitrary instance for list.
11:56:37 <robokop> i'm currently compiling wxhaskell from source but get errors in during make
11:56:52 <shapr> Yes, there is.
11:57:02 <shapr> instance Arbitrary a => Arbitrary [a] where
11:57:04 <davidhouse> so my strategy is wrong?
11:57:21 <Igloo> Either way would work
11:57:37 <Igloo> shapr's way you'd need a PasswordChar type and instance
11:58:05 <shapr> Yeah, Igloo's way is easier to start with.
11:58:35 <shapr> I've used QuickCheck so much I always use the built-in instances :-)
11:58:58 <davidhouse> right. this is what i thought. but i'm still stuck with what to have my arbitrary function as 
11:59:15 <Igloo> You already have half of it
11:59:22 <shapr> davidhouse: Look at the Arbitrary instances in QuickCheck.hs
11:59:23 <davidhouse> unless it's replicateM n $ oneOf "xud*?()"
11:59:29 <Igloo> You just need something like n <- range (5, 8) or whatever the right functino is
11:59:52 * Igloo doesn't know the QC names off-hand
12:00:19 <shapr> choose :: Random a => (a, a) -> Gen a
12:00:31 <davidhouse> right. so:
12:00:45 <Igloo> You'll also need to liftM Password the result
12:00:54 <vincenz> choosShapr:: Random a => (a, a) -> Shaprr a
12:01:14 <davidhouse> arbitrary = liftM Password $ sized $ \n -> choose (0,n) $ replicateM $ oneOf "xud*?()"
12:01:16 <shapr> I wonder if I'm already an instance of Random.
12:01:21 <davidhouse> @shapr
12:01:21 <lambdabot> why on earth would I slap
12:01:28 <davidhouse> aww, it's gone.
12:01:34 <shapr> @get-shapr
12:01:34 <lambdabot> shapr!!
12:01:45 <vincenz> @put-shapr
12:01:45 <lambdabot> shapr!!
12:01:47 <shapr> oh no, I've made a RECURSIVE CALL!
12:01:49 <davidhouse> heh.
12:01:55 <vincenz> @get-vincenz
12:01:55 <lambdabot> Unknown command, try @list
12:02:02 <vincenz> > why only shapr
12:02:03 <lambdabot>  Not in scope: `shapr'
12:02:05 <vincenz> :D
12:02:11 <davidhouse> shapr has his own command.
12:02:15 * shapr phones his butt, wondering if that's a tail call.
12:02:29 * vincenz snickers
12:02:37 <vincenz> shapr: I think tail only applies to females
12:02:53 <flux__> is tail call in any relation to booty call?-o
12:03:00 <shapr> Heterosexual women can't chase tail?
12:03:12 <davidhouse> > show [1..5]
12:03:13 <lambdabot> "[1,2,3,4,5]"
12:03:15 <vincenz> shapr: I guess they don't recurse
12:03:30 <flux__> women don't curse?
12:03:33 <robokop> i'm currently compiling wxhaskell from source but get errors in during make could sb help me
12:03:33 <shapr> vincenz: I do not want to pursue that line of thought =)
12:03:38 <davidhouse> @hoogle Int -> Char
12:03:38 <lambdabot> Char.chr :: Int -> Char
12:03:38 <lambdabot> Char.intToDigit :: Int -> Char
12:03:38 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
12:03:46 <davidhouse> > map intToDigit [1..5]
12:03:47 <lambdabot> "12345"
12:04:02 <flux__> > intToDigit 42
12:04:03 <lambdabot> Exception: Char.intToDigit: not a digit 42
12:04:18 <Tony_Sidaway> astrolabe, Igloo thanks for the help.  See you.
12:04:23 <flux__> lousy runtime check
12:04:29 <robokop> > chr 42
12:04:30 <lambdabot> '*'
12:05:16 <davidhouse> > map (read.return) $ map intToDigit [1..5]
12:05:17 <lambdabot> Add a type signature
12:05:37 <davidhouse> > map (read.(:[])) $ map intToDigit [1..5]
12:05:38 <lambdabot> Add a type signature
12:06:03 <davidhouse> stupid lambabot. both work on my GHCi.
12:06:24 <davidhouse> > map (read.(:[])) $ map intToDigit ([1..5] :: [Int])
12:06:25 <lambdabot> Add a type signature
12:06:38 <davidhouse> > map (read.(:[])) $ map intToDigit [1..5] :: String
12:06:38 <lambdabot> Exception: Prelude.read: no parse
12:08:11 <vincenz> shapr: do you recurse?
12:08:29 <astrolabe> > map (read.return) $ (map intToDigit [1..5])::String
12:08:29 <lambdabot> Exception: Prelude.read: no parse
12:08:44 <davidhouse> > map (:[]) $ map intToDigit [1..5] :: String
12:08:44 <lambdabot> Couldn't match `Char' against `[Char]'
12:08:53 <davidhouse> > map (:[]) $ map intToDigit [1..5]
12:08:53 <lambdabot> ["1","2","3","4","5"]
12:09:01 <davidhouse> > map read ["1","2","3","4","5"]
12:09:01 <lambdabot> Add a type signature
12:09:07 <davidhouse> > map read ["1","2","3","4","5"] :: [Int]
12:09:08 <lambdabot> [1,2,3,4,5]
12:09:12 <davidhouse> :|
12:10:05 <davidhouse> where on my filesystem can i put a module so that i can just import Module in any haskell code i want?
12:10:32 <robokop> > let f a = (intToDigit (a `mod` 10) : f (a `div` 10)) in reverse.take 2 (f 42)
12:10:32 <lambdabot> Couldn't match `[a]' against `t -> t1'
12:10:48 <robokop> > let f a = (intToDigit (a `mod` 10) : f (a `div` 10)) in reverse $ take 2 (f 42)
12:10:48 <lambdabot> "42"
12:11:31 <robokop> > let f a = (intToDigit (a `mod` 10) : f (a `div` 10)) in reverse $ take 10 (f 42)
12:11:32 <lambdabot> "0000000042"
12:12:39 <robokop> > let f a = (intToDigit (a `mod` 10) : f (a `div` 10)) in reverse $ filter (==0) $ take 10 (f 42)
12:12:39 <lambdabot>  add an instance declaration for (Num Char)
12:12:49 <robokop> > let f a = (intToDigit (a `mod` 10) : f (a `div` 10)) in reverse $ filter (=='0') $ take 10 (f 42)
12:12:50 <lambdabot> "00000000"
12:12:59 <robokop> > let f a = (intToDigit (a `mod` 10) : f (a `div` 10)) in reverse $ filter (/='0') $ take 10 (f 42)
12:12:59 <lambdabot> "42"
12:14:07 <davidhouse> anyone?
12:15:41 <shapr> davidhouse: ./
12:15:58 <davidhouse> shapr, err, right, and what if i'm writing code in a different directory? ;)
12:16:02 * shapr grins
12:16:36 <shapr> I have ~/src/haskell/libraries and it's included in my .ghci
12:17:45 <davidhouse> shapr, what's the line you use to add it to the search path?
12:18:13 <davidhouse> :set -l~/src/haskell/libraries?
12:18:38 <davidhouse> s/-l/-i
12:22:01 <shapr> I use the explicit path, but yeah.
12:23:58 <xerox> shapr, do you know if one could instruct haskell-mode in order to use a remote GHCi?
12:24:01 * shapr has a hissy fit trying to read Oleg's RSS.hs
12:24:13 <shapr> xerox: What do you mean?
12:24:18 <ibid> off-topic: http://antti-juhani.kaijanaho.fi/kuvia/bicycles.jpg
12:24:18 <davidhouse> @index fromInt
12:24:19 <lambdabot> bzzt
12:24:23 <davidhouse> @hoogle fromInt
12:24:24 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
12:24:24 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
12:24:29 <xerox> shapr, something a-la swank
12:24:48 <shapr> What does swank do?
12:25:10 <shapr> Oh, you want to run ghci on a remote system?
12:25:28 <davidhouse> QuickCheck seems to refer to an imaginary fromInt function...
12:25:36 <shapr> davidhouse: try fromIntegral
12:25:37 <xerox> It's a communication protocol to be used between common lisps implementation and slime (Emacs' cl environment.)
12:25:48 <davidhouse> shapr, well, yeah, but it's not my code :)
12:26:44 <shapr> xerox: what about (setq haskell-ghci-program-name "ssh $HOSTNAME ghci") ?
12:26:53 * shapr tries...
12:27:02 <xerox> It would be great if it worked.
12:27:02 <tony2> fromInt is from old libs.
12:27:15 * xerox jumps furiously waiting for the result
12:28:00 <shapr> xerox: It'll only work if you're using sshfs to mount the remote dir in an equally named ...
12:28:00 <shapr> hmm
12:28:25 <xerox> Hmm?
12:29:16 <shapr> Working...
12:30:11 <shapr> "ssh $HOSTNAME ghci" will work fine as long as you can persuade the haskell-ghci-load-file defun to pass the correct path.
12:30:12 <Igloo> Did someone replace shapr with the computer from StarTrek:TOS?
12:30:24 <xerox> ohub, I see what you mean.
12:30:40 <shapr> I'm just reading the haskell-ghci.el sources and seeing if I can offer working code to xerox immediately :-)
12:30:56 * xerox hugs shapr
12:31:22 * shapr notes a few improvements
12:36:31 <shapr> xerox: The easy cheesy way is to do (setq haskell-ghci-program-name "ssh") (setq haskell-ghci-program-args (list "$HOSTNAME" "ghci")) and make sure your local filesystem matches your remote filesystem, at least for the directory that has your Haskell sources.
12:36:41 <shapr> I'm looking for a way to hack the directory finding function...
12:38:21 <robokop> i'm missing libwxc-gtk2.6.2-0.9.4.so on my x86 linux machine
12:38:38 <robokop> what should i do now
12:38:42 <mwc> is that something to do with wxwidgets?
12:38:46 <mwc> Try installing that package?
12:38:56 <robokop> have it installed
12:39:10 <mwc> wxwidgets-devel perhaps?
12:39:40 <robokop> i'll look after it but i tought i have it installed
12:39:54 <mwc> nvm, a .so should be in the main package anyways
12:40:00 <mwc> do you have another version of the same library?
12:40:02 <xerox> shapr, cool.  Unfortunately my directories will not match, but I'm with you--go shapr!  :-)
12:40:05 <mwc> maybe you can simlink?
12:40:35 <robokop> locate can't find anythin when i search for wxc-gtk
12:40:46 <sieni> simlink? it is related to sintax?
12:41:08 <mwc> it's my bastard appelation for ln -s
12:41:23 <robokop> from symbolic link
12:41:47 <mwc> indeed, and I didn't use a y for some reason
12:41:56 <shapr> xerox: How would you want to specify the directory for the remote files?
12:42:55 <xerox> shapr, good question.  Maybe I wouldn't care at all?  Like using dummy /tmp files to load in the remote interpreter?
12:43:03 <shapr> Huh?
12:43:24 <shapr> oh, hm.
12:43:40 <xerox> If I understand your question correctly, the problem is where to store a local file to be ran on the remote interpreter.
12:45:05 <davidhouse> any experienced unit test writers around? i've written a really small function, readList, which just turns a string into a list of digits. i.e. "123" -> [1,2,3].
12:45:17 <shapr> There is a solution... use tramp via ssh and haskell-ghci-command to change to the correct remote dir.
12:45:34 <davidhouse> i'm having trouble coming up with a unit test for it
12:45:35 <noj> how do I find out what package (for ghc -package cmdline option) a particular module belongs to?
12:45:36 <xerox> It could work!
12:45:53 <davidhouse> noj, look at the docs.
12:46:26 <noj> ah, found it. cheers
12:46:35 <davidhouse> noj, i.e. http://haskell.org/ghc/docs/6.4.1/html/libraries/index.html that page
12:46:54 <shapr> davidhouse: readList "12" == [1,2]
12:47:16 <mwc> shouldn't you call it "readString"
12:47:18 <davidhouse> shapr, okay, i'm having trouble coming up with a quickCheck unit test for it
12:47:29 <davidhouse> where i can't predict the data coming in
12:47:29 <mwc> just my two cents, that name is kinda confusing
12:47:33 <davidhouse> mwc, true
12:47:38 <davidhouse> its role has changed.
12:49:26 <shapr> davidhouse: Generate a list of digits 0 to 9, stuff that list through concatMap show, and see if readList gives you back the original input.
12:50:26 <davidhouse> argh. this is horrible. i'll have to declare _another_ type for digits
12:51:46 <davidhouse> or not, i suppose a guard will do
12:51:49 <xerox> > [0..9] >>= show
12:51:49 <lambdabot> "0123456789"
12:52:34 <Philippa> cute
12:54:00 <davidhouse> @where paste
12:54:00 <lambdabot> http://paste.lisp.org/new/haskell
12:54:20 <lisppaste2> davidhouse pasted "what's wrong with this indentation?" at http://paste.lisp.org/display/18623
12:54:31 <davidhouse> ^^ what's wrong with that indentation?
12:54:47 <davidhouse> it parse errors in the second guard
12:56:08 <mauke> can you use where like that?
12:56:17 <davidhouse> oh, wheres have to be at top-level
12:57:11 <davidhouse> hmm.
12:57:24 <davidhouse> how on earth do you use quickcheck to test a big function, like a parser?
12:57:44 <davidhouse> i'd need some kind of parsed output -> input function, perhaps
12:58:23 <mwc> I'd use a unit test on some examples chosen to work the grammer's dusty corners
12:58:43 <shapr> davidhouse: (parse . read input == input) works wonders.
12:59:31 <davidhouse> mwc, yeah, that's the way i'd do it normally. but QuickCheck seems pretty keen on not letting me use specific examples, but instead generating them programattically.
12:59:42 <davidhouse> which seems stupid, because i know the edge conditions, and QuickCheck doesn't.
12:59:53 <shapr> You'd be surprised.
13:00:38 <Cale> davidhouse: QC is for black box testing
13:00:53 <Cale> For white-box tests, you can use something like HUnit
13:01:20 <musasabi> CosmicRay: how much work would it be to add two-phase commit for the databases that support it to hdbc?
13:02:27 <CosmicRay> musasabi: I don't know what a two-phase commit is. could you explain?
13:02:56 <davidhouse> Cale, right.
13:03:06 * davidhouse thinks he prefers white-box tests at the moment
13:03:33 <shapr> davidhouse: QC is really good at testing *properties*.
13:03:49 <shapr> For example, commutative, associative, idempotent, etc.
13:04:35 <shapr> QC is particularly good at specifying AcceptanceTests http://c2.com/cgi-bin/wiki?AcceptanceTest
13:05:14 <davidhouse> interesting.
13:05:25 <shapr> I extended QC to do test driven development by saving failing test inputs and rerunning that test again the next time.
13:05:37 <davidhouse> so QC fits in quite nicely with design-by-contract, HUnit is for more traditional unit testing.
13:06:12 <davidhouse> if i write a big parser, it probably won't have too many interesting properties, so I'd probably want HUnit, yes?
13:06:21 <shapr> QC could be easily extended to do traditional unit testing as well, for any value that's an instance of Read.
13:06:26 <monochrom> traditional unit testing is also a kind of white box design-by-contract testing isn't it?  The contract is the test suite, ...
13:06:46 <musasabi> CosmicRay: instead of commit there are two phases: 1) PREPARE TRANSACTION; (prepare current transaction for commit and fail if it cannot be committed) and 2) COMMIT/ROLLBACK PREPARED <txid>; which commits/aborts a prepared transaction and will not fail.
13:06:57 <shapr> If you write a big parser, I predict that QC will find errors faster.
13:07:18 <davidhouse> (aside: why is it so difficult to instantiate Read? i just want to provide a function for turning my type into a string)
13:07:20 <Lemmih> (id == parse.pp) is a very interesting property for parsers and pretty printers.
13:07:36 <CosmicRay> musasabi: ahh.  which databases support that, to your knowledge?  (And does ODBC?)
13:07:48 <musasabi> CosmicRay: at least oracle and postgresql.
13:08:01 <CosmicRay> musasabi: what is the case in which a prepare transaction would fail and a commit would not?  disk full or something?
13:08:03 <davidhouse> Lemmih: functions are instances of Eq?
13:08:14 <xerox> No.
13:08:52 <Lemmih> davidhouse: No, one would write: \x -> x == parse (pp x)
13:09:00 <davidhouse> yeah. i was wondering.
13:09:27 <musasabi> CosmicRay: the idea is that if you have multiple sources for which you need to commit then one needs a way to check that everyone is willing to commit.
13:09:33 <davidhouse> (ignore my aside, i actually want to instantiate Show :))
13:10:00 <CosmicRay> musasabi: but still, a commit shouldn't ever fail, unless the disk is full I guess, right?
13:10:11 <CosmicRay> everything else should already be caught at the time the member queries are issued
13:10:20 <CosmicRay> anyway...
13:10:20 <musasabi> CosmicRay: of course it may fail. e.g. with deferred constraints.
13:10:28 <CosmicRay> ah.
13:10:45 <CosmicRay> if it is just another SQL command, that would be trivial to do.
13:10:51 <xerox> ?pl \f (x:xs) -> scanl f x xs
13:10:52 <lambdabot> (`ap` tail) . (. head) . scanl
13:10:54 <CosmicRay> in fact you could even do it now with "run"
13:11:00 <musasabi> CosmicRay: think of a situation with databases A and B. We need either to commit to both of them or neither. How would you implement this?
13:11:01 <xerox> ?pl \(x:xs) f -> scanl f x xs
13:11:01 <lambdabot> ap (flip . flip scanl . head) tail
13:11:07 <xerox> It's just scanl1, right?
13:11:23 <CosmicRay> musasabi: I would say it is impossible to get a proper guarantee on that.
13:11:29 <CosmicRay> even with this
13:12:04 <xerox> No more fptools on darcs.complete.org?
13:12:26 <CosmicRay> xerox: nope, because there are official darcs repos for it now
13:12:31 <CosmicRay> that one hadn't been updated in months anyway
13:12:48 <xerox> ?libsrc Data.List
13:12:49 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
13:12:50 <musasabi> CosmicRay: 1) PREPARE COMMIT with both A and B, 2) rollback if either fails, 3) log "starting commit txid<A>, txid<B)", 4) write COMMIT PREPARED to both, 5) log "commit done"
13:12:53 <xerox> Which is the url now?
13:13:06 <xerox> darcs.haskell.org?
13:13:13 <CosmicRay> xerox: exactly
13:13:30 <CosmicRay> ah, you have an external log.  that makes sense.
13:13:58 <xerox> Is fptools inside ghc/ ?
13:14:07 <CosmicRay> musasabi: it looks like only the PostgreSQL backend supports it for now.  would you be happy with being able to just: run dbh "PREPARE TRANSACTION" or do you think the API needs more?
13:14:12 <basti_> ghc is part of fptools isnt it?
13:14:15 <CosmicRay> xerox: well it depends on which part of fptools you are looking for.
13:14:17 <CosmicRay> basti_: correct.
13:14:26 <CosmicRay> or rather, it was.
13:14:28 <Lemmih> There still is an fptools?
13:14:30 <xerox> Data.List, Prelude, those kind of things.
13:14:34 <Lemmih> Ah.
13:14:40 <CosmicRay> Lemmih: not really.
13:14:47 <CosmicRay> there are "the things that were fptools"
13:15:02 <xerox> ...and now are...
13:15:16 <CosmicRay> xerox: most of the directories you see on darcs.haskell.org
13:15:17 <basti_> ...merely things.
13:15:23 <musasabi> CosmicRay: I think I can live with that. If I get time I will write a nice STM binding (database transactions bound to the STM transactions).
13:15:35 <xerox> How would you find Data.List ?
13:15:44 <CosmicRay> musasabi: that would be sweet.
13:15:52 <CosmicRay> musasabi: feel free to darcs send any patches to me
13:16:22 <CosmicRay> musasabi: it appears that ODBC's SqlEndTran function doesn't support this, and MySQL certainly doesn't at all, so PostgreSQL would be the only backend to support it natively anyway.
13:16:32 <CosmicRay> musasabi: thanks for teaching me something new today
13:17:22 <musasabi> MySQL rarely has the fancy features, but that is quite common in large commercial databases.
13:17:33 <musasabi> np :-)
13:17:58 <CosmicRay> heh
13:18:10 <CosmicRay> for MySQL, "transaction" is a fancy feature.
13:19:08 <sieni> depends, I've heard that the innodb tables work properly
13:19:44 <sieni> I wonder if one can disable other table types, when compiling mysql
13:19:45 <sieni> ?
13:19:55 <musasabi> do they support views?
13:20:18 <musasabi> (those make db programming so much more nicer)
13:20:27 <flux__> updateable view would be nice in postgresql, too
13:21:37 <mwc> Would it be correct to say the purpose of Control.Monad.State.State is merely to thread some common parameters/outputs through a series of nested functions, whereas the ST monad provides real imperative effects?
13:21:53 <sieni> musasabi: I don't know, maybe google helps on that?
13:23:56 <musasabi> sieni: well they implement a limited version of them, but I am not sure whether it is enough to be usefull.
13:24:49 <monochrom> mwc: Yes I think so.
13:25:44 <Philippa> mwc: it'd be easier to say State does a single variable and ST an entire heap
13:26:21 <Philippa> given a slightly more powerful type system (although I think it may be doable with GADTs now?) you could implement ST on top of State
13:27:02 <mwc> Philippa, since State is implemented entirely in Haskell, it seems to me that it merely drops the reference to the old state and gives you the new one (on put)
13:27:09 <mwc> whereas ST performs real in place updates
13:27:13 <mwc> ie: MutVar
13:27:32 <mwc> So it seems to be ST needs some voodoo behind the scenes
13:27:34 <Philippa> mwc: it seems to me that unless you're in the IO monad you couldn't tell the difference
13:27:48 <Philippa> ST doesn't /need/ voodoo. It just benefits from it
13:27:48 <mwc> true
13:27:53 <mwc> but one would be more efficient
13:28:40 <mwc> when you really need state
13:32:49 <Philippa> mwc: sure. But how do you know the State monad hasn't actually been implemented that way? :-)
13:32:55 <xerox> Anybody so sweet to hand me GHCi access for a lil while this night, since it's not available for my architecture yet?
13:32:58 <mwc> Good questoin
13:33:46 <mwc> I suppose since I peeked at the mtl src at darcs.haskell.org
13:33:58 <Philippa> :-)
13:34:40 <mwc> and since my STUArray is vastly faster than my State UArray implementation
13:34:50 <mwc> 40,000 doubles in there
13:35:03 * Philippa nods
13:35:25 * xerox has to test ten lines of code, but with lambdabot is starting to be a pain.
13:35:27 <Philippa> in current implementations, you're pretty much right
13:35:29 <Philippa> OTOH, if you really want "real imperative effects" that much, the IO monad has IORefs :-)
13:35:56 <mwc> yeah, but then I have to put all this in the IO Monad
13:36:08 <mwc> ST allows me to construct and freeze it
13:36:18 <Philippa> er?
13:36:34 <Philippa> oh, yeah. runST. You don't get to 'mix heaps' though
13:36:43 <mwc> fair enough
13:36:56 <mwc> all I need is a little corner where I can use destructive update
13:37:05 * Philippa nods
13:37:23 <mwc> I don't even really need the destructive update, but hte copying was killing me
13:37:44 <mwc> xerox, I'd help you out
13:37:53 <xerox> Would you?
13:38:09 <mwc> but my CPU is maxed out on this simulation and I can't afford to spare any cycles
13:38:18 <xerox> Thanks anyway.
13:38:32 <mwc> still tweaking parameters to get this damn thing ready for presentation on thursday and it takes about 200 minutes a run
13:38:35 * xerox thinks harder.
13:38:42 <mwc> hugs?
13:38:57 <xerox> Intel Core Duo (Yonah) :-|
13:39:06 <mwc> Won't hugs work on that?
13:39:12 <xerox> I don't think so.
13:39:16 <Philippa> you'll have a core free, no?
13:39:25 <xerox> Hmm.  Let me see.
13:39:30 <Philippa> it should do, it's just x86 isn't it?
13:39:35 <Philippa> which os're you running?
13:39:41 <xerox> OS X
13:39:47 <Philippa> ah
13:39:49 <Philippa> building hugs might be fun
13:40:11 <xerox> It seems it exists in darwinports.
13:40:12 <bolrod> you have the new mac book pro something ?
13:40:13 <mwc> I thought it was pretty easy
13:40:23 <xerox> Not that I have actually installed darwinports yet.
13:40:25 <mwc> back when I first picked up hsakell, I tried hugs
13:40:37 <bolrod> xerox: how is it?
13:40:38 <mwc> and I seem to remember it being just a ./configure && make affair
13:40:59 <xerox> bolrod, iMac 20" :-)  Very very very nice up to now.
13:41:05 <bolrod> oh
13:41:19 <xerox> The screen is just a pleasure.  Etc, etc..
13:41:26 <bolrod> nice :)
13:41:51 <mwc> xerox, how much ram?
13:42:16 <mwc> my gf's new macbook shipped with 512 and it was unusable. Swapping made it so lurchy my APril 2004 powerbook g4 ran circles around it
13:42:24 <xerox> The standard quantity as now, 512Mb.  It arrived 3 days ago, too :-)
13:42:26 <mwc> upgraded to 1 GB ram and that improved a lot
13:42:49 <bolrod> how is the macbook?
13:42:53 <bolrod> good battery life?
13:42:54 <mwc> seems okay
13:43:00 <mwc> Actually, mediocre battery life
13:43:06 <mwc> my pb g4 is much better
13:43:09 <bolrod> I took the iBook 12" because of the battery life
13:43:12 <xerox> In these last hours, when a big number of programs is adding up on the RAM, I can see some difference from initial clean usage.
13:43:13 <bolrod> :)
13:43:30 <bolrod> with minimal brightness without wifi.. I think you get 6 hours
13:43:47 <bolrod> 5 hours with wifi I think
13:43:52 <xerox> I swear I rebooted it one time for the updates some minutes after the very first run.
13:44:16 <xerox> Anyway, GHC, GHC, GHC!
13:44:21 <bolrod> :)
13:44:39 <xerox> Or hugs okay...
13:44:52 <mwc> xerox, could also be the slower laptop HD that made it more noticble
13:45:13 <xerox> mwc, right.  OTOH the computer is *very* silent.
13:45:16 <mwc> but that machine was EMACS slow :)
13:45:18 <bolrod> thrashing computers are 'not' useable ;)
13:45:30 <mwc> (Eighty megs and constantly swapping) :D
13:45:53 <bolrod> on my desktop Xorg wanted to take up 1200MB of RAM
13:46:03 <bolrod> well...  I had to kill it through ssh so I could resume normal use
13:46:06 <xerox> Hmpf, darwinports needs Xcode and I have no intention of rebooting now.
13:46:12 <bolrod> but logging in with ssh took about....... 10 minutes ? :P
13:47:35 <mwc> yuck, I really don't like how devtools are packaged on OS X
13:47:46 <mwc> can't get just the compiler, need to get all the appl eheaders and libs and tools
13:49:29 <bolrod> eh?
13:49:36 <bolrod> XCode has the gcc
13:49:42 <mwc> yeah
13:49:48 <mwc> XCode is an IDE
13:50:04 <bolrod> I dont really know all about it
13:50:09 <bolrod> I just used it to install gcc
13:50:11 <mwc> GUI for all the mac programmers so they don't have to use a CLI
13:50:12 <bolrod> ;)
13:50:21 <mwc> Oh, it already installed GCC then
13:50:32 <bolrod> you can run gcc from command line?
13:50:36 <mwc> yep
13:50:44 <bolrod> well.. what ya missing then ;)
13:50:44 <mwc> usr/bin/gcc-alphabet-soup
13:50:52 <bolrod> hehe
13:50:58 <xerox> shapr, have you eventually realized how to use tromp+ssh+ghci?
13:51:32 <bolrod> you could just create a link...
13:51:37 <shapr> Er, no, I got distracted.
13:51:45 <mwc> bolrod, links are already there
13:52:06 <xerox> I got a remote GHCi :-)
13:52:18 <sieni> what is tromp?
13:52:32 <mwc> ok, I better let this stupid thing have my CPU
13:52:40 <mwc> only got about 4000 iterations doen this hour
13:52:49 <mwc> goodnight, and good luck.
13:53:04 <shapr> sieni: tramp
13:53:15 <shapr> xerox: How did you do it?
13:53:24 <xerox> shapr, I asked a friend!
13:53:27 <shapr> oh, smart.
13:53:42 <xerox> I'll adapt myself to the remote Emacs too.
13:53:58 <sieni> shapr: like that: http://savannah.gnu.org/projects/tramp ?
13:54:42 <shapr> Yup, that's tramp.
13:55:10 <sieni> I don't quite understand how that, ssh and ghci would fit together
13:55:25 <shapr> tramp lets you edit over ssh/ftp/whatever.
13:55:39 <sieni> ?
13:56:03 <shapr> haskell-ghci.el throws a :load (dirname)/(buffername) into ghci.
13:56:12 <sieni> edit what? I can use vi on the remote machine to edit or emacs or whatever
13:56:26 <shapr> Nooo, I mean that tramp lets you edit remote files locally.
13:56:34 <MarcWeber> I want to get only stdout from a process. Do I have to call hClose on in-handle from runInteractiveCommand?
13:56:47 <shapr> It slurps the files from there to here, it does everything, even multi-hop.
13:57:46 <shapr> For example, tramp is really smooth with the scp method, since it just scps the file to a local tmp file, then scps it back over when you save.
13:58:31 <sieni> yes, it would probably be nice, but since it's part of the gnu project, it will be ruined eventually, like emacs or guile
13:58:34 <sieni> or gnome
13:58:43 <shapr> ???
13:58:43 <lambdabot> Maybe you meant: . id pl wn
13:59:01 <shapr> I disagree with any implicit value judgements.
13:59:23 <sieni> Ok, gcc is nice
14:00:18 <monochrom> how is emacs ruined?
14:00:25 <shapr> I think that's the discussion we didn't want to have.
14:00:52 <shapr> The implication is that "part of the gnu project" == "will be ruined eventually". I consider that an inflammatory statement.
14:01:25 <shapr> Like that aol guy who said that Europeans are (something insulting). I forget exactly what he said, but it doesn't really matter.
14:01:28 <sieni> well... many things. Undo doesn't work properly. If you have a buffer open in several windows and then switch to another buffer in one window, it forgets where it was in that buffer in that window
14:01:43 <sieni> the minibuffer context seems to be global
14:02:21 <shapr> I do agree that emacs contexts could be improved.
14:03:23 <sieni> it gets all the basic things wrong because of insistence of dynamic binding.
14:03:53 <xerox> tramp works like a charm.
14:04:11 <sieni> I don't thing they can improved. The only good thing that can be done for emacs is to just bury it, preferably torturing and burning it alive first
14:04:12 <xerox> If only I could haskell-load-remote-file... * points in shapr direction *
14:04:46 <pesco> sieni: Wow, you're disgruntled.
14:04:47 <shapr> xerox: The easy way is to modify haskell-ghci-command
14:05:58 <pesco> sieni: s/you're/you sound/
14:06:29 <monochrom> busy burning
14:06:30 <CosmicRay> Is there an easy way to write, essentially, if (doesDirectoryExist "foo" || doesFileExist "foo") without having to use do notation to split out the two calls?
14:06:37 <CosmicRay> it seems like there ought to be a shortcut but I'm not aware of one
14:06:51 <xerox> liftM (||) ?
14:06:58 <pesco> liftM2
14:07:09 <xerox> ?type Control.Monad.liftM2 (||)
14:07:09 <lambdabot> forall (m :: * -> *).
14:07:09 <lambdabot>           (Monad m) =>
14:07:09 <lambdabot>           m Bool -> m Bool -> m Bool
14:08:02 <Igloo> CosmicRay: If you don't mind using the posix stuff you can use the file statting function
14:08:24 <sieni> pesco: there are good things about emacs as well, I wouldn't be so disgruntled if it wasn't the best option currently
14:08:51 <CosmicRay> Igloo: yeah, that's what I plan to do in fact, but it just brought up this general case.
14:09:00 <CosmicRay> Igloo: it is a shame that we don't have a doesExist in the standard library.
14:09:36 <shapr> sieni: I have a long list of such incurable emacs warts myself.
14:10:05 <pesco> sieni: Hm, I've actually switched to ne, the "nice editor" after finding that I don't need syntax highlighting and will never make the effort to actually wade through the docs for either vim or emacs.
14:10:09 <Igloo> TBH it's probably rarely actually useful due to races
14:10:50 <sieni> well, I've been planning to just make a decision to just start using Yi and contributing all the missing features that I need to Yi codebase, but I haven't had the strong urge yet to do that
14:11:12 <shapr> sieni: I'm with you there :-)
14:11:16 <pesco> Right. I would've tried Yi if it ran on my platform...
14:11:38 <astrolabe> How much effort would it take to make Yi a useful editor?
14:11:45 <astrolabe> pesco: which platform?
14:11:51 <pesco> astrolabe: linux-ppc.
14:12:02 <CosmicRay> oh, and what is the representation for an octal literal in haskell? 0755?  0o755?
14:12:26 <shapr> astrolabe: For haskell only use, it's probably as simple as stuffing in Lemmih's ghc-api for syntax highlighting.
14:12:26 <pesco> astrolabe: no hs-plugins.
14:13:00 <shapr> > 0o77
14:13:01 <lambdabot> 63
14:13:12 <astrolabe> beat me :)
14:13:13 <sieni> astrolabe: I guess, what I would need, would be at least C/C++ and Scheme/Lisp syntax highlighting and reasonably configurable autoindentation
14:13:14 <shapr> CosmicRay: Looks like it's 0onn?
14:13:25 <CosmicRay> shapr: thanks
14:14:16 <shapr> Knit has a C parser, I think.
14:14:52 <astrolabe> pesco: shame.  I suspect people are too tempted by non-standard features (though I don't know in this case).
14:15:30 <Philippa> pesco: isn't there a yi-static? Can you build that?
14:15:37 <vincenz> dcoutts__: ping
14:15:44 <pesco> Philippa: I didn't think so...
14:15:51 <Philippa> astrolabe: hs-plugins is a fairly integral part of how yi's supposed to be used, though the static build exists
14:15:55 <pesco> Philippa: Will have to envestigate.
14:16:00 <Philippa> pesco: I remember it being there when I tried under windows ages ago
14:16:40 <pesco> Philippa: Hm. Okay... but no time to play now. I have to learn to make Debian packages...
14:18:07 * astrolabe looks up yi
14:18:16 <astrolabe> @where yi
14:18:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
14:18:29 <sieni> I think yi has quite a bit of potential
14:18:52 <steevo`> does anyone in here know objc?
14:18:57 <sieni> and it works perfectly well as a drop-in replacement for vi for basic editing tasks
14:22:42 <shapr> steevo`: This still isn't #objc
14:30:26 * shapr feels like a grumpy old man
14:32:23 <wolverian> sorry for a slightly ot question - but what is a negative cycle, in graphs?
14:32:29 * Philippa feels a gorgeous woman
14:32:51 <Philippa> wolverian: graphs or digraphs?
14:33:01 <gadolin> the cycle with negative sum of weight edges
14:33:03 <wolverian> Philippa, sorry, digraphs
14:33:06 <Philippa> oh, wait, do you mean "negative length cycle"?
14:33:21 <wolverian> these lecture notes say "negative cycle". gadolin's explanation seems likely
14:33:25 <wolverian> thanks to both of you :) 
14:34:35 <dcoutts__> vincenz: pong
14:36:45 <vincenz> dcoutts__: yeah I'm struggling to get things going
14:37:06 <vincenz> dcoutts__: btw..could your thing be done witout unsafe?
14:37:39 <dcoutts__> vincenz:  unsafe?
14:38:06 <vincenz> dcoutts__: yeah...you use unsafe
14:38:17 <dcoutts__> for what?
14:38:17 <vincenz> for the redrawInvalidatedCells
14:38:49 <vincenz> modified <- unsafeRead (Sim.w_modified (Sim.s_world simState)) (indexPos y x)
14:41:08 <dcoutts__> vincenz: that's only for indexing, it's not essential
14:41:37 <dcoutts__> you could use safe array indexing
14:42:34 <vincenz> and you use
14:42:37 <vincenz> region <- rects
14:42:38 <vincenz> btw
14:42:41 <vincenz> some code from clock doesn't compile
14:42:58 <vincenz> like getting the drawingwindow
14:43:01 <vincenz> in onExpose
14:43:03 <gadolin> wot is an example of an expressionh that contains two cocurence of the empy list
14:43:07 <gadolin>  the first occurence having type [Bool] and the seccond type [Char]
14:43:44 <gadolin> ?
14:45:57 <vincenz> dcoutts__: just not getting started :/
14:46:38 <vincenz> dcoutts__: idle-functions are still in the same thread, right?
14:48:43 <vincenz> dcoutts__: may I PM?
14:49:38 <gadolin> what about those these examples
14:50:00 <vincenz> gadolin: I fail to see te question
14:50:08 <vincenz> f [] []
14:50:15 <vincenz> f :: [Bool] -> [Char] -> ...
14:50:21 <gadolin> lol
14:50:37 <vincenz> gadolin: your question is rather vague
14:51:23 <gadolin> i just started with list,  ... ok i am going back to reading
14:52:43 <vincenz> gadolin: [] is a list of any type
14:52:47 <vincenz> depending on which context it's used
14:59:21 <xerox> ?index showFFloat
14:59:21 <lambdabot> Numeric
14:59:57 <vincenz> xerox: you know a lot bout gtk?
15:00:03 <vincenz> xerox: I use widgetSetAppPaintable True
15:00:06 <vincenz> and it still makes it grey
15:00:09 <vincenz> instead of leaving transparent
15:00:15 <stepcut> it would be nice is haskell-mode understood haddock better :-/
15:01:21 <dcoutts__> vincenz: that's because the window it's in has a background
15:01:33 <vincenz> dcoutts__: what if I did this for the window itself too?
15:01:40 <vincenz> dcoutts__: and. I can't get the canvas to keep a fixed size :(
15:01:53 <vincenz> dcoutts__: and I tested that with only the window and nothing else
15:01:56 <vincenz> it's still not transparent
15:01:57 <dcoutts__> vincenz: and probably because the colourmap has no alpha channel and you're not running a compositte manager
15:02:01 <vincenz>   canvas `onSizeRequest` return (Requisition initialSize initialSize)
15:02:06 <vincenz> dcoutts__: composite manager?
15:02:12 <dcoutts__> vincenz: getting transparent windows is non-trivial, read up on it
15:02:13 <vincenz> dcoutts__: and that used to fix the size of my canvas but not now
15:02:16 <vincenz> dcoutts__: where
15:02:19 <vincenz> FAQ?
15:02:42 <araujo> hiya!
15:03:08 <dcoutts__> vincenz: http://plan99.net/~mike/blog/?p=38
15:03:23 <vincenz> thx
15:03:36 <dcoutts__> vincenz: and it probably requires binding a couple more gtk+ functions in gtk2hs, feel free to send in a patch
15:04:24 <vincenz> dcoutts__: maybe later
15:04:28 <dcoutts__> vincenz: btw, yes idle functions are still in the main thread, they're callbacks from the main loop that happen when nothing of a higher priority is running
15:04:29 <vincenz> dcoutts__: first want to get this woring :D
15:04:45 <vincenz> dcoutts__: and fixing the window size (or canvassizE)?
15:05:03 <vincenz> ah
15:05:11 <vincenz> gotta do the onSizeRequest before widgetShowAll
15:05:27 <dcoutts__> if the canvas is child of the window and has a minimum size then it should size properly
15:07:02 <vincenz> so how do you do it for clock?
15:07:05 <vincenz> or isn't clock transparent
15:07:16 <dcoutts__> vincenz: actually I don't (yet)
15:07:21 <dcoutts__> since I couldn't test it
15:07:40 <dcoutts__> I'm not running a sufficiently new X server + composite manager
15:07:51 <dcoutts__> but I would use the code as in that article
15:08:14 <dcoutts__> which would require binding a couple colour map functions
15:08:57 * vincenz nods
15:10:10 * vincenz is writing a blog entry about his current thingy :)
15:10:15 <vincenz> I should prolly add my feed to planet haskell
15:12:48 <dcoutts__> vincenz: that'd be interesting
15:12:58 <dcoutts__> then more people will read it
15:14:32 <vincenz> on a side note
15:14:37 <vincenz> anyone have the geshi php file for haskell?
15:18:28 <vincenz> dcoutts__: how do I clear a gdk window/
15:20:11 <vincenz> or for that matter...get the colorspace of the main canvas so I can use it to make a pixbuf
15:21:14 <dcoutts__> vincenz: use ColorspaceRgb
15:21:14 <vincenz> nm
15:21:21 <vincenz> yeah just saw that :D
15:21:51 <dcoutts__> they might add a new one for the cairo pixel format (pre-multiplied alpha)
15:22:05 <dcoutts__> or YUV or whatever
15:24:06 <vincenz> how do I draw on a pixbuf/
15:24:16 <vincenz> sorry about all the questions
15:25:59 <vincenz> disregard
15:26:01 <vincenz> it's pixmap I need
15:26:49 <vincenz> last question... before I stop acting like a newb
15:26:57 <vincenz> is it better to redraw a LARgE area from a pixmap to screen
15:27:01 <vincenz> or keep all the small changes
15:27:08 <vincenz> and redraw those little squares one by one
15:27:55 <xerox> ?lookupBy
15:27:56 <lambdabot> Unknown command, try @list
15:28:00 <xerox> ?index lookupBy
15:28:01 <lambdabot> bzzt
15:28:03 <xerox> ?index lookup
15:28:03 <lambdabot> Data.HashTable, Data.IntMap, Data.Map, Data.List, Prelude
15:28:36 <xerox> ?docs Data.Map
15:28:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
15:29:14 <vincenz> xerox: know how to get my rss onto planet haskell/
15:33:33 <dcoutts__> vincenz: a pixbuf is a client side bitmap, not a drawable, so you use it in a raw raster/pixel style
15:33:50 <dcoutts__> yeah, you want pixmap since it's a drawable
15:34:15 * vincenz nods
15:34:20 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/BlogPages/2006-04-05-FiddlingWithGtk2hs
15:34:39 <dcoutts__> vincenz: as for the large pixmap vs small, well it depends. What were you thinking of more precisely
15:35:31 <vincenz> dcoutts__: well ... I have some pixels that move...
15:35:36 <vincenz> I could possibly have multiple move in one step
15:35:42 <vincenz> so make one bounding box and redraw the entire pixmap
15:35:47 <vincenz> or make a small bounding box around each moving pixel
15:37:10 <vincenz> the last paragraph before conclusion on the page I just mentioned
15:37:16 <dcoutts__> vincenz: well ifyou're drawing direct to the screen then making small bounding boxes is good
15:37:24 <vincenz> dcoutts__: well I can't do that
15:37:30 <vincenz> dcoutts__: cause as soon as the screen is hidden
15:37:31 <vincenz> I lose that part
15:37:33 <dcoutts__> if that means making lots of small pixbufs all the time then that incurrs overhead
15:37:34 <vincenz> and need to redraw it
15:37:38 <vincenz> hence an extra pixmap
15:37:45 <vincenz> which duplicates the screen
15:38:07 <dcoutts__> if you can keep one off-screen pixmap and blit small bits of that to the screen then that's great
15:38:07 <vincenz> just a matter of how much I want to copy from that pixmap (where all changes will occur) to the screen
15:38:17 <vincenz> so better many small parts instead of one really big one
15:38:34 <vincenz> like 10 of 10 pixels instead of 1 of 100*100 or so
15:38:49 <vincenz> (aka...call cost is negligible compared to execution cost of blit procedure)
15:39:01 <vincenz> and obviously execution O(number of pixels)
15:39:03 <dcoutts__> eg you saw my ants one, it maps backwards from exposed screen regions to cells and then redraws just those cells. It also redraws cells whenever they are modified by running the sim.
15:39:13 * vincenz nods
15:39:25 <vincenz> okies, perfect
15:39:30 <vincenz> expect to read article two soon
15:39:33 <vincenz> after I implement what I mention
15:39:36 <vincenz> and find problems
15:39:38 <vincenz> and plan more
15:39:57 <dcoutts__> ok :-)
15:42:01 <vincenz> Still have to find out how to get my rss onto planet haskell :D
15:42:25 <dcoutts__> vincenz: ask
15:42:32 * vincenz nods
16:00:37 <xerox> 'night.
16:03:29 <dcoutts__> g'night xerox 
16:03:42 <dcoutts__> xerox: btw we've got a cairo bug to fix :-)
16:03:57 <dcoutts__> and it's a design bug not a simple binding bug...
16:09:13 <ihope> Oh, how ironic...
16:09:15 <ihope> "The meaning of life is one or more of the following:"
16:13:03 <mux> 42?
16:13:22 <ihope> No, that's the *answer* to life, not the meaning of it.
16:13:30 <ihope> > meaning life == 42
16:13:31 <lambdabot>  Not in scope: `life'
16:13:32 <mux> bleh, nitpicker :-)
16:13:48 <mux> I like the final message from god to his creation
16:13:55 <mux> "Sorry for the inconvenience"
16:14:03 <ihope> "Haskell is a thriving farm community located near the work and shopping"
16:16:15 <ihope> "Dons is senior lhp jeremy kinney who is tied for the team lead" <- ?
16:32:38 <ihope> @babel en es doppleganger
16:32:40 <lambdabot>  doppleganger
16:33:15 <ihope> @babel en es doppelganger
16:33:16 <lambdabot>  doppelganger
16:37:16 <ihope> /mode +b *
17:19:15 <ihope> There is now enough join/part/quit to fill my screen, with no privmsg to balance it.
17:19:17 <ihope> Congrats.
17:19:23 <vincenz> @babel en es monad
17:19:24 <lambdabot>  mónada
17:19:29 <vincenz> @babel en fi monad
17:19:30 <lambdabot> babel module failed: Error: Language fi not supported
17:19:45 <vincenz> @babel en jp monad
17:19:45 <lambdabot> babel module failed: Error: Language jp not supported
17:22:58 <ihope> @babel en pt monad
17:22:59 <lambdabot>  mónada
17:23:03 <ihope> @babel en de monad
17:23:04 <lambdabot>  Monad
17:23:08 <ihope> @babel en it monad
17:23:09 <lambdabot>  monad
17:23:35 <ihope> @babel en es The spirit is willing but the flesh is weak.
17:23:36 <lambdabot>  El alcohol está dispuesto pero la carne es débil.
17:23:42 <ihope> @babel es en El alcohol estÃ¡ dispuesto pero la carne es dÃ©bil.
17:23:43 <lambdabot>  The alcohol estÃ arranged but the meat is dÃ©bil.
17:23:52 <ihope> Oh my.
17:23:59 <araujo> The english -> spanish trans waas quite good.
17:24:30 <ihope> @babel en es lol
17:24:32 <lambdabot>  lol
17:25:11 <ihope> @babel es en Ser o no ser: es la pregunta
17:25:12 <lambdabot>  To be or not to be: it is the question
17:25:26 <ihope> Close enough. I don't know the Spanish for "that" :-P
17:25:39 <ihope> @babel en es That is the question.
17:25:40 <lambdabot>  Ésa es la pregunta.
17:26:15 <ihope> @babel es en soy ser
17:26:16 <lambdabot>  I am to be
17:27:25 <ihope> @babel es en soy pregunta y gordo de la una tarde
17:27:26 <lambdabot>  I am fat question and of late
17:27:42 <ihope> Oh.
17:28:26 <ihope> @babel es en le es come
17:28:27 <lambdabot>  it is eats to him
17:30:41 <araujo> ihope, 'it' and 'that' are pretty much equivalents in spanish with 'eso' or 'es'
17:31:51 <araujo> @babel es en Ser o no ser: esa es la pregunta
17:31:52 <lambdabot>  To be or not to be: that is the question
17:32:02 <ihope> Ah.
17:32:40 <araujo> In this case, question is "pregunta", which is like female, so it's 'esa' instead of the male 'eso'
17:33:21 <ihope> I do not speak inglÃ©s very well. :-)
17:33:43 <araujo> what's your language?
17:34:02 <araujo> it's fine, mine is not perfect either :-]
17:37:47 <ihope> !lastascension
17:38:10 * ihope needs to learn what commands work in what channels
17:48:56 <Taral> @last ascension
17:49:03 <Taral> nope
17:56:08 <ihope> > last "ascension"
17:56:09 <lambdabot> 'n'
17:59:08 <Taral> oh, that last.
18:01:34 <ihope> > last (repeat 1)
18:01:38 <lambdabot> Terminated
18:02:24 <mauke> > take 6 [1, 1 .. ]
18:02:25 <lambdabot> [1,1,1,1,1,1]
18:06:15 <ihope> @babel es en Una Paloma Blanca
18:06:17 <lambdabot>  A White Dove
18:06:34 <ihope> @babel en es Out of sight, out of mind
18:06:35 <lambdabot>  Fuera de vista, fuera de la mente
18:06:42 <ihope> @babel es en Fuera de vista, fuera de la mente
18:06:44 <lambdabot>  Outside Vista, the mind
18:06:44 <araujo> "God is described as the Monad of Monads."
18:06:59 * araujo adds new quote to his notebook
18:07:10 <ihope> data Trivial a = Trivial -- the Monad of Monads: you can't do anything with it
18:10:16 <araujo> Now ive got an answer for ythose who ask "what/who is God" though :-]
18:10:38 <ihope> :-D
18:10:39 <mauke> god is real unless declared integer
18:10:53 <ihope> You mean God has rounding errors?
18:10:59 <araujo> hah
18:16:05 <rasfar> @keal
18:16:06 <lambdabot> nsa try kill me numerous times
18:16:21 <rasfar> @babel en es nsa try kill me numerous times
18:16:23 <lambdabot>  el intento del NSA me mata las épocas numerosas
18:16:35 <rasfar> @babel es en el intento del NSA me mata las pocas numerosas
18:16:36 <lambdabot>  the attempt of the NSA kills the few numerous ones to me
18:16:47 <rasfar> almost made more sense
18:17:40 <ihope> @keal
18:17:40 <lambdabot> bot seems useless
18:17:51 <ihope> @babel en es bot seems useless
18:17:52 <lambdabot>  el BOT se parece inútil
18:17:59 <ihope> @babel es en el BOT se parece inÃºtil
18:18:00 <lambdabot>  the BOT looks like inÃºtil
18:18:21 <rasfar> intil?
18:19:19 <rasfar> sweet irony that we enjoy using bot to quote keal saying bot is useless!
18:57:50 <Cale> @keal
18:57:51 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
18:58:37 <sjanssen> wtf?
18:59:08 <sjanssen> I've heard the guy is crazy, but that makes no sense at all
19:00:58 <psnl> ooh, I had forgotton how nuts keal was
19:02:50 <gzl> haha
19:02:54 <gzl> he has his own bot command
19:03:49 * psnl recalls that he thought keal was a bot for ages
19:04:40 <Cale> @keal
19:04:40 <sjanssen> hey, is HAC going to actually happen?
19:04:40 <lambdabot> my very first computer was an 80-0840
19:04:49 <Cale> @keal
19:04:49 <lambdabot> today's 24hour project was supposed to be logical overloading using plegm method
19:05:02 <Cale> haha
19:05:04 <Cale> @keal
19:05:05 <lambdabot> when i put what i dat recoved from that tile into a ti92. the damn thing blew up
19:05:48 <sjanssen> attempting to parse that sentence just makes me giggle
19:05:55 <Cale> I actually think the guy is schizophrenic
19:06:10 <Cale> @keal
19:06:10 <lambdabot> #haskell needs to take its meds
19:06:35 <rasfar> hmmm...
19:06:50 <sjanssen> Cale: apparently we're the schizophrenic ones (or something)
19:07:21 <Cale> hehe
19:08:06 <Cale> He is reasonably consistent in his own demented way, and he's been around on IRC for years.
19:27:56 <luke-jr_> http://paste.lisp.org/display/18640 -- any ideas?
19:47:10 <psnl> luke-jr_: what happens if you turn on -v?
19:47:31 <luke-jr_> psnl: no idea? where would I do that?
19:48:06 <dons> here's a fun game:
19:48:08 <dons> > filter (< 4) [1..10]
19:48:09 <lambdabot> [1,2,3]
19:48:14 <dons> > filter ((<) 4) [1..10]
19:48:15 <lambdabot> [5,6,7,8,9,10]
19:49:25 <dons> hehe. Haskell is fun.
19:49:26 <psnl> luke-jr_: in make
19:50:30 <psnl> assuming you are using make as your build system
19:51:52 <luke-jr_> make is a binary program
19:53:50 <psnl> yes, used to handle big compiles
19:54:54 <luke-jr_> anyhow, I can't get the same error by running make directly
19:55:06 <luke-jr_> nor by calling ghc directly with the same arguments
19:55:36 <luke-jr_> only via emerge
19:59:52 <psnl> ah
20:01:17 <psnl> are you emerging in ghc?
20:32:25 <luke-jr_> psnl: trying to
20:36:28 <rasfar> anyone know how I can find out the maximum size of an Int on my platform?
20:38:03 <luke-jr_> rasfar: printf("%d\n", 2 ^ (sizeof(Int) * 8));
20:38:09 <luke-jr_> oh wait... nm
20:38:17 <rasfar> cute
20:38:34 <Korollary> check out the *.h files in the include/sys dirs.
20:39:05 <rasfar> Well ... okay, but will that necessarily be the correct value for GHC Int?
20:39:31 <Korollary> oh
20:40:28 <rasfar> (I have a situation where one datatype uses Integer, another uses Int, I am to convert between them, and I'm not free to change their definitions.  My intention is to cast the Integer to Float if it is too big (this is the best I can do within the spedcifications).
20:40:35 <Korollary> the docs mention minBound & maxBound
20:41:31 <rasfar> Ah, right -- Int is an instance of Ix? ...
20:41:40 <sjanssen> yes
20:41:48 <Korollary> Bounded, in this case
20:47:26 <rasfar> Thanks Korollary; I can't test at the moment as we're in a cvs conflict crisis on a Java project :/
20:47:45 <Korollary> I blame cvs
20:48:22 <rasfar> Well, of the five of us I'm the only one not using Eclipse; otherwise ... darcs all the way!
20:48:42 <Korollary> what is this about?
20:58:25 <rasfar> Oh -- it's an assignment for an introductory A.I. course -- we're trying to use genetic algorithm (hybrid with Or-tree) to solve SisyphusI.
20:59:07 <rasfar> (Has nothing to do with Haskell unfortunately, except that it's keeping me from it!)
20:59:30 <Korollary> ah. I thought haskell was involved somehow.
20:59:44 <rasfar> Well, that's my Compilers course.  ;)
21:28:35 <rasfar> hi mwc
21:29:11 <mwc> Hello rasfar 
21:29:20 <mwc> How're things in my old hometown?
21:29:27 <rasfar> you're a grad student corrent?
21:29:34 <mwc> No
21:29:37 <mwc> Upper year undergrad
21:29:54 <rasfar> oh -- (same here) -- so this season is rather stressful no?
21:30:10 <rasfar> You mean Calgary?
21:31:08 <rasfar> Well, we've got robins, and had first rain shower of the year, but otherwise I've hardly had time to notice the town for the grind.
21:31:44 <mwc> oh, for some reason I thought you were from Saskatoon
21:31:54 <mwc> Actually, I'm looking to do my grad studies at U of Alberta
21:32:00 <mwc> good cluster out there, WestGrid
21:33:21 <rasfar> Oh.  Just browsing the logs, I was in Saskatoon last year when I first joined #haskell.
21:33:47 <mwc> Sad about Klein going
21:33:49 <rasfar> I remember our discussion now.  I imagine the town's about the same, except I hear it's getting a bit rougher (gangs).
21:34:09 <mwc> Yeah, I had a buddy there from back in grade school, we used to talk about that
21:34:17 <mwc> hung himself in february though
21:34:17 <rasfar> I'll be there in a couple weeks for a spell, if finals don't kill me...
21:34:23 <mwc> so no news since then
21:34:27 <mwc> Why do you visit
21:34:31 <rasfar> crap
21:35:01 <rasfar> parents (and brother will be in from Ottawa).  You still in London then?
21:35:27 <mwc> yep
21:35:37 <mwc> some snow squall had the gall to come and dump here
21:35:51 <rasfar> Not sure why I didn't go to U. of A. -- i was kinda messed at the time i made the decision, and made it in extreme haste.
21:36:47 <rasfar> I never go to blah, but I'm beginning to feel awkward on #haskell with the chat...
21:37:29 <mwc> I'm always on blah
21:37:40 <rasfar> besides, i'm procrastinating in the worst way -- must get this intermediate code working...
21:37:51 <mwc> project?
21:37:57 <rasfar> Well, i huess blah it is ... or not
21:38:00 <rasfar> yep
21:38:01 <mwc> I've got a simulation in haskell that takes abut 3 hours per run
21:38:08 <mwc> still tweaking paramters but i'm geting there
21:38:47 <rasfar> wow, 3 hours ... that's a long one!  even our Sudoku solvers, the worst was only minutes in hugs!
21:38:56 <rasfar> what are you simulating?
21:39:21 <mwc> It's a monte carlo optimization process
21:39:43 <mwc> I'm using simulated annealing to optimize sprinkler placement in a field for irrigation purposes
21:39:53 <rasfar> oh.  sounds like an A.I. course?
21:40:11 <rasfar> We have to use Java for that one unfortunately.
21:40:11 <mwc> nope, applied mathematics course in monte carlo methods
21:40:15 <rasfar> oh
21:41:02 <rasfar> I've always been partial to M.C. -- but we're using a genetic algorithm which is also nifty.
21:41:14 <mwc> Yeah, that's also a monte carlo method
21:41:22 <mwc> I would have liked to have applied it
21:41:30 <mwc> but I couldn't think of a sane way of combining solutions
21:41:39 <rasfar> uh huh
21:42:30 <rasfar> so your interested in grid computing for your grad project?
21:43:02 <mwc> yeah
21:43:17 <rasfar> think you'll be able to use FP?
21:43:22 <mwc> if I'd done more comp sci as an undergrad, I'd have liked to study using Haskell for Scientific computing\
21:44:16 <rasfar> Yeah -- it used to be the closest you could come was single-assignement languages like Sisal, but now I imagine Haskell could give Sisal a run for its money.
21:45:04 <mwc> absolutely. The potential for autoparallelization of your code seems to be very strong in Haskell
21:45:15 <mwc> Given that it's effect-freeness makes a lot of decisions trivial
21:45:37 <Pseudonym> OTOH, it still seems to be potential.
21:45:52 <Pseudonym> Choosing the granularity seems to be quite difficult.
21:45:59 <Pseudonym> As is parallelising lazy evaluation.
21:46:19 <rasfar> Yeah.  Maybe if they're not using Haskell on WestGrid -- hey, we have WestGrid in Calgary too, don't we?
21:46:28 <rasfar> (I guess that's why it's a grid.)
21:47:17 <mwc> http://sourceforge.net/projects/sisal
21:47:20 <mwc> if you're interested
21:47:24 <Korollary> Is there a reason why a lisp program can be faster than an ml/ocaml program?
21:47:38 <rasfar> I also find concurrency very interesting, esp. in connection with lazy functional languages.
21:47:43 <cpatrick> Korollary: well, "can be faster" becomes a matter of compilers at some point
21:47:44 <mwc> maybe some imperative voodoo?
21:48:04 <mwc> the ocaml/ml types could be purists and avoiding certail techniques
21:48:05 <cpatrick> That said, I thought ML compilers were usually pretty good
21:48:32 <cpatrick> and that lisp compilers were crap unless you spent a lot of money buying one
21:48:36 <Korollary> by faster I meant theoretically faster if both compilers gave it all they've got.
21:49:19 <dons> no. I don't think so
21:49:19 <cpatrick> Korollary: well, assuming you wrote in a straightforward imperative style and gave appropriate type annotations in both cases, it should be much of a muchness
21:49:28 <Pseudonym> http://c2.com/cgi/wiki?SufficientlySmartCompiler
21:49:32 <cpatrick> after that, it's all mind-reading compiler voodoo
21:49:36 <dons> I would assume it would be slower in practice (lisp). and this seems to be the result on the shootout
21:50:01 <dons> like Pseudonym says.
21:50:51 <cpatrick> Pseudonym :-)
21:50:56 <Korollary> aware of the sbclshootout
21:50:58 <Pseudonym> While I'm not knocking Haskell (hardly!), I'm not convinced that a smart Haskell compiler can beat a smart Sisal compiler on the kinds of problem that Sisal is designed for.
21:51:10 <Pseudonym> Sisal is meant to be a Fortran-killer.
21:51:32 <cpatrick> ooo
21:51:34 <Korollary> aware of the sbcl's shootout performance I told a lisp guy that lisp was nowhere near c/++. He was pretty convinced lisp was up there with c++.
21:51:58 <cpatrick> Korollary: it depends on what you mean by "up there" and what you're doing with it
21:52:01 <dons> C++ isn't the best thing in town though.
21:52:21 <Korollary> cpatrick: by up there we meant within a low percentage for a majority of common tasks.
21:52:25 <cpatrick> For straightforward numerical grunt work, it's hard to beat C/C++ or Fortran
21:52:46 <Pseudonym> It's easy to beat C.
21:53:04 <Pseudonym> It's also easy to beat C++ in the absence of a decent template library which is hard to write.
21:53:13 <Pseudonym> It's not so easy to beat Fortran.
21:53:21 <Pseudonym> But it's possible.
21:53:23 <mwc> C isn't good for that. Pointer aliasing issues make a lot of optimizations FORTAN compilers apply impossible
21:53:25 <Korollary> I don't follow that
21:53:51 <Pseudonym> Well... OK.  If you have a tuned BLAS library, the language is irrelevant from a speed point of view.
21:54:01 <Pseudonym> Or FFT library, or whatever you need.
21:54:09 <Pseudonym> However, BLAS libraries tend to be cryptic.
21:54:19 <Pseudonym> Can YOU guess what "saxpy" means?
21:54:28 <cpatrick> Pseudonym: hmm. I'll take you word for that, I don't really know enough to argue with it
21:54:36 <Korollary> I've looked at blas code
21:54:58 <Korollary> One of the reasons it's cryptic is that the authors didn't care about picking good variable names even.
21:54:59 <cpatrick> Pseudonym: a friend of mine reckoned that for some algorithms his straightforwardly-written-C could beat intel's BLAS library though
21:55:15 <Pseudonym> I don't know enough about Intel's library.
21:55:16 <cpatrick> Pseudonym: I think it depends a lot on what you're doing and how easily it maps onto what BLAS/FFT libraries will do for you
21:55:26 <Pseudonym> Yes, that's true.
21:55:34 <mwc> oh well, I bumped this up to 20000 iterations
21:55:38 <mwc> see you gents in the AM
21:56:01 <Pseudonym> The thing I like about Sisal is it was designed to make libraries like BLAS irrelevant.
21:56:18 <Korollary> How?
21:56:54 <Pseudonym> C has restrictions due to pointer aliasing etc.
21:57:02 <Pseudonym> Sisal does not have those restrictions.
21:57:10 <Korollary> and there are pragmas you can use, too.
21:57:19 <cpatrick> Pseudonym: I thought you could tell compilers to make those optimisations "unsafely"
21:57:32 * Pseudonym suspects it depends on the optimisation
21:57:56 <Pseudonym> At any rate, Sisal was designed not to have those restrictions, but in a high-level language.
21:58:11 <cpatrick> Pseudonym: that's kind of neat
21:58:18 * cpatrick makes a note to look at sisal at some point
21:58:19 <Pseudonym> I reckon more compiler writers/language designers should think like this.
21:58:20 <Korollary> With references?
21:58:24 <Pseudonym> 1. Here's the source code I want to write.
21:58:32 <Pseudonym> 2. Here's the generated code that I want to make.
21:58:38 <Pseudonym> Now how do I get from 1 to 2?
21:58:49 <Korollary> What's the generated code in?
21:59:14 <Pseudonym> http://www.llnl.gov/tid/lof/documents/pdf/217941.pdf
21:59:20 <cpatrick> Korollary: well, conceptually machine language
21:59:48 <Korollary> Then that sounds a lot like how compilers are written.
22:00:11 <cpatrick> Korollary: I think pseudonym's point was that languages should be designed like that
22:00:46 <Pseudonym> Actually, not many compilers are written like that.
22:00:51 <cpatrick> "I have a set of problems that I want to right high-level code that I can generate efficient binaries for; what should my language look like?"
22:00:55 <cpatrick> *write
22:01:20 <Pseudonym> Haskell compilers, for example, are invariably written by finding a fast abstract machine first.
22:01:32 * cpatrick -> lunch, then studying for a topology test
22:01:39 * Pseudonym is biassed on this point, BTW, being formerly of Mercury
22:02:14 <Pseudonym> Fergus and Zoltan used to sit down and decide what assembly code they wanted generated for various simple programs, like list reverse or list length.
22:02:35 <pastebin> I could swear, for that short time where my name was "the", i got 20 references
22:02:59 <Pseudonym> Once, they discovered that one program wasn't as fast as they predicted, and it turned out to be due to an unfilled Sparc delay slot.
22:03:07 <Pseudonym> So they added a new compiler pass to fill that one delay slot.
22:03:24 <Pseudonym> This is modifying the intermediate code, BTW.
22:03:41 <rasfar> did somebody say "intermediate code"??
22:03:55 <Korollary> I think it's fairly obvious.
22:04:18 <Korollary> Pseudonym: So they messed with the intermediate code until the int -> tgt generator produced what they wanted?
22:04:31 <Pseudonym> No, more than that.
22:04:41 <Pseudonym> But yes, in that case/
22:05:20 <Korollary> Well, I'm all for better intermediate code, but I don't see why that should affect the high level language.
22:06:00 <Pseudonym> It depends what you're trying to achieve.
22:06:23 <Pseudonym> Sisal was designed to beat Fortran in numeric code.
22:06:30 <Pseudonym> So the language was designed to make that possible.
22:07:56 <Pseudonym> I don't see a problem with this.
22:08:03 <Pseudonym> Admittedly, it probably works better for DSLs.
22:08:27 <Pseudonym> Come to think of it, you could probably argue that C# is a ".NET glue code" DSL.
22:09:40 <Korollary> I didn't realize that Sisal was a dsl.
22:09:46 <Pseudonym> It kind of is.
22:09:57 <Korollary> I can understand that.
22:10:09 <Pseudonym> In the sense that it's optimised for one domain.
22:10:33 <Korollary> In that case it also pays to pay close attention to the target instruction set.
22:11:06 <Pseudonym> Come to think of it, you could argue that C is a DSL for Unix system programming.
22:11:21 <Pseudonym> Or, to put it another way, Unix is a C virtual machine.
22:11:40 <Korollary> I've always considered C as typed assembly.
22:11:51 <Korollary> with calling conventions
22:19:23 <Korollary> A yucky entry: http://c2.com/cgi/wiki?AsFastAsCee 
22:20:20 <sieni> indeed, stupid spelling like "CeeLanguage" makes me want to vomit.
22:20:41 <Korollary> It's probably due to a wiki restriction
22:20:47 <Cale> yes, it is
22:21:02 <sieni> there might be something interesting in c2.com, but the sight hurts eyes so badly that it's completely unreadable
22:21:10 <Cale> Wikii pages on the original wiki are strictly in CamelCase
22:21:12 <Korollary> It's old.
22:21:28 <sieni> yes, I've heard about that
22:21:36 <Korollary> And it's got a lot of opinion-spam, in desperate need of editing.
22:22:33 <Pseudonym> Actually, this is a good point:
22:22:40 <Pseudonym> Functional languages can hardly beat C in terms of pure speed for very optimized functions. However, for common, unoptimized code, which makes the bulk of programs, the speed is comparable.
22:22:46 <Pseudonym> I hadn't realised that.
22:23:22 <Korollary> I'd say that's true for ml, but not for haskell.
22:23:30 <Pseudonym> Indeed.
22:23:41 <Pseudonym> I think they're talking about O'Caml or Lisp-like languages here.
22:24:01 <Korollary> and a lot of cheating
22:24:34 <ncalexan> Something implicit and often undiscussed wrt high-level language performance is that we've already, as a collective, decided that certain performance trade-offs are 'ok'.  By no means does C compile to assembly-like performance... and certainly not in many of the interesting cases (templating, for sure.)
22:24:52 <Pseudonym> Sure.
22:25:10 <Korollary> I believe C does compile to better assembly than you & I can write.
22:25:12 <ncalexan> It seems that the whole performance argument will be eclipsed by the 'acceptable trade-off' adaptation of time.
22:25:28 <ncalexan> At least, that's what I predict :)
22:25:38 <Pseudonym> A C programmer will always beat an assembly programmer, because a C programmer can choose which parts of the program get written in assembler.
22:25:51 <Pseudonym> An assembly programmer doesn't get that choice.
22:26:14 <sieni> it's not C if you use assembler
22:26:17 <sieni> it's cheating
22:26:45 <dons> so haskell programmers win, since they can code in both C and asm 
22:26:46 <Cale> Sufficiently smart code generation will always beat both C and hand-coded assembly.
22:26:52 <sieni> like saying that Haskell programmer will always beat C programmer, since a Haskell programmer can choose which parts of the program get written in C
22:27:07 <dons> which is probably true for large apps
22:27:11 <Pseudonym> Indeed.
22:27:26 <dons> you manage the large complexity with haskell. tune the few small, hot bits and you're done.
22:27:28 <ncalexan> Korollary: I can't back this up, but I believe that for a large program, that might be true.  But that seems a function of the task size, and I believe that reflects how painful large coding in ASM is, not that compilers are emitting much faster code.
22:27:32 <dons> the C guy has no recourse but to push on 
22:27:35 <Pseudonym> Because the large app might not be able to be written AT ALL in C, given a limitation on budget.
22:27:42 <dons> yep
22:28:18 <Pseudonym> I guess that's the bottom line.
22:28:20 <Pseudonym> Budgets are finite.
22:28:41 <Korollary> ncalexan: The common argument is that on the newer architectures, the cycle-count, pipeline-economy is quite difficult for a human programmer, and thus the c compiler prevails over most assembly programmers.
22:28:57 <Pseudonym> You're trying to get the best performance (measured by whatever metric is important to you) for a fixed or as-low-as-possible budget.
22:29:15 <sieni> Well, large applications can certainly be written in C, but the bigger problem is that in some corporate project, some idiots can screw up the code base pretty quickly to unmanageable state. Haskell doesn't have this problems since these same idiots are probably completely unable to write Haskell at all
22:29:17 <ncalexan> Korollary: I really have no reason to believe the machines are doing better than the humans, but I don't follow such movements.
22:29:26 <ncalexan> So I will lay down the gloves.
22:29:46 <Korollary> sieni: Yay for elitism! :)
22:30:05 <dons> am writing a paper at the moment about rewriting a chemistry program in haskell, such that it now runs faster and in constant space, whereas the large commerical C one uoftenn fills up memory after 2 or 3 days simulating. the C code must just be full of idiot junk.
22:30:43 <dons> so who cares how fast a tight loop can be compiled, when you get lost in the forest anyway.
22:30:52 <Pseudonym> Right.
22:30:55 <flux__> and you can bet it's a fraction of its size?-)
22:31:01 <ncalexan> dons: talk about the constant space guarantee for a moment?  Can you say a little of what that entailed?
22:31:12 <dons> using -prof
22:31:16 <Pseudonym> You want to get as much performance as possible for as little cost.
22:31:24 <Korollary> dons: Whoever wrote that junk could not have written it in haskell anyway, so there's no argument there.
22:31:26 <Pseudonym> Assembly language increases the performance, and Haskell lowers the cost.
22:31:28 <ncalexan> Do you actually prove constant space?  That seems hard.
22:31:31 <dons> there's just some bad memory managaement in the C monster somewhere (or many-where)
22:31:38 <flux__> in any case haskell's type system won't let you prove constant-spaceness
22:31:46 <dons> no no. not proved.
22:31:52 <dons> it just doesn't seem to leak.
22:32:01 <flux__> dons, well, it could simply be a small bug, one that would be fixed in the next revision
22:32:13 <ncalexan> dons: and how uglified do the space hacks make the code?  I think that's a worrying part of all this performance talk.
22:32:21 <dons> ah well. if only they didn't charge 60k for that code then ;)
22:32:32 <dons> no. it's normal code
22:32:37 <dons> not shootout-style code
22:32:40 <flux__> ;)
22:32:48 <dons> (the shootout has restrictions that force us into this style)
22:32:54 <dons> we can't use fps , for example
22:32:56 <dons> or any libs
22:32:57 <Pseudonym> And how long did it take to write this program in Haskell?
22:32:59 <ncalexan> I feel like shootout-style-code will soon become part of the lexicon.
22:33:01 <dons> about 2 weeks
22:33:04 <flux__> there should be atleast two categories for haskell (and why not other languages too) in the shoothout: idiomatic and optimized
22:33:25 <Pseudonym> So... what... less than $3000 of programmer time?
22:33:27 <ncalexan> I always cringe at these x `seq` y | False hacks.
22:33:34 <dons> if they let us install some libs on the shootout box, there would be no shootout style
22:33:58 <dons> Pseudonym, well, it certainly didn't cost us much :)
22:34:01 <Korollary> I think the strictness hacks go a little beyond fps
22:34:05 <Pseudonym> Sure.
22:34:06 <Saulzar> Hmm, still the numeric stuff would have a bit of it
22:34:10 <Pseudonym> How many programmers for 2 weeks?
22:34:16 <dons> 1.5
22:34:24 <Pseudonym> OK, so maybe $4000.
22:34:27 <Korollary> dons and a half
22:34:29 <flux__> dons, did you do it as a hobby or as an actual project?-)
22:34:37 <Pseudonym> Not bad.
22:34:39 <ncalexan> Hmm... how much is an olegweek worth/
22:34:40 <ncalexan> ?
22:34:43 <ncalexan> Unbounded?
22:34:45 <flux__> ;)
22:34:58 <Pseudonym> Oleg would write it all in the type system.
22:34:58 <Korollary> an olegweek is a complex entity with an imaginary part
22:35:05 <dons> no no. it's mostly written by my supervisor, and i'm working on it now. it's a proper funded project
22:35:17 <ncalexan> That's very good... I nominate that quote for HWN.
22:35:17 <Pseudonym> Who is your supervisor, BTW?
22:35:27 <ncalexan> quote?
22:35:31 <ncalexan> ?quote
22:35:31 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
22:35:38 <Pseudonym> @quote
22:35:39 <lambdabot> adept says: I think I need cobrain to understand coeffects
22:35:42 <ncalexan> @quote help
22:35:43 <lambdabot> help hasn't said anything memorable
22:35:47 <ncalexan> @help quote
22:35:48 <lambdabot> quote <nick>
22:35:48 <lambdabot> remember <nick> <quote>
22:35:48 <lambdabot> Quote somebody, a random person, or save a memorable quote
22:35:52 <Pseudonym> @quote
22:35:53 <dons> i have two, Manuel Chakravarty and Gabi Keller.  Gabi wrote this code
22:35:53 <lambdabot> xerox says: you know, befunge is probably the only language I've seen where you can run code pasted from IRC with the <nick> tags still in place ;-)
22:35:53 <Korollary> I think it's quote+
22:35:57 <Pseudonym> Right.
22:36:03 <ncalexan> @quote+ Korollary an olegweek is a complex entity with an imaginary part
22:36:03 <lambdabot> Korollary an olegweek is a complex entity with an imaginary part hasn't said anything memorable
22:36:10 <Korollary> lol
22:36:20 <dons>  @rememeber is better.
22:36:20 <Pseudonym> @remember Korollary an olegweek is a complex entity with an imaginary part
22:36:21 <lambdabot> Done.
22:36:27 <Pseudonym> @quote Korollary
22:36:27 <ncalexan> @remember Korollary an olegweek is a complex entity with an imaginary part
22:36:28 <lambdabot>  an olegweek is a complex entity with an imaginary part
22:36:28 <lambdabot> Done.
22:36:32 <Korollary> I believe @quote should do a head on its arg
22:36:41 <ncalexan> Fuck, lambdabot kills me sometimes.
22:36:43 <ncalexan> @quote
22:36:43 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
22:36:48 <ncalexan> @quote
22:36:49 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
22:36:53 <ncalexan> @quote
22:36:54 <lambdabot> Pseudonym says: Well, personally, I don't think dumb people should be let near a programming language.
22:36:57 <ncalexan> @quote
22:36:57 <lambdabot> ndm says: the only language i've seen which is ugly at a deeper level than syntax is perl
22:37:04 <ncalexan> @quote
22:37:04 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
22:37:07 <ncalexan> @quote
22:37:07 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
22:37:08 <ncalexan> FUn!
22:37:24 <dons> we should publish it!
22:37:34 <dons> "The little book of lambdabot"
22:37:47 <Korollary> geekness elevated.
22:38:41 <Korollary> Somehow tie lambdabot to D&D and progressive rock and we hit geekratosophere.
22:40:03 <Cale> @dice 3d6
22:40:04 <lambdabot> 3d6 => 10
22:40:27 <Pseudonym> @yes
22:40:28 <lambdabot> Make me look like LINDA RONSTADT again!!
22:40:34 <Pseudonym> There you go.
22:40:37 <Korollary> hah
22:40:46 <Korollary> What's @yes supposed to be?
22:40:50 <Cale> @yow
22:40:50 <lambdabot> Am I elected yet?
22:40:55 <Korollary> misinterpreted @yow?
22:41:12 <Korollary> @rush
22:41:12 <Pseudonym> Sadly, the Linda Ronstadt reference spoils the progressive rock reference.
22:41:12 <lambdabot> Unknown command, try @list
22:41:18 <Pseudonym> @king-crimson
22:41:19 <lambdabot> Unknown command, try @list
22:41:32 <Korollary> @pre-80's-genesis
22:41:33 <lambdabot> Unknown command, try @list
22:41:36 <Pseudonym> @genesis-but-only-when-peter-gabriel-was-still-a-member
22:41:37 <lambdabot> Unknown command, try @list
22:41:39 <Pseudonym> :-)
22:42:00 <dons> hehe
22:43:17 <tenni1> lambdabot probably only knows current acts featured on MTV
22:43:29 <Korollary> mtv has music?
22:43:49 <rasfar> @voivod
22:43:49 <lambdabot> Unknown command, try @list
22:44:08 <tennin> dunno, I don't get cable
22:44:44 <Korollary> something killed the video-star.
22:45:25 <dons> bah. wiki editing makes w3m cry
22:45:28 <tennin> actually I have no idea what if anything goes on outside this room anymore
22:45:30 <dons> s/cry/segfault/
22:45:53 <dons> if only it was written in ..
22:46:50 <tennin> top 40 radio today could be non-stop Schoenberg and Berg for all I know
22:46:58 <Korollary> tennin: So what are you in for?
22:48:23 <tennin> simulated chemical abuse 
22:49:22 <Korollary> tennin: Did you blow up your own condo and start an underground boxing club?
22:50:14 <tennin> I don't think I box, although that might help explain the chronic headaches.
22:52:31 * Cale wonders if that's simulated-chemical abuse, or simulated chemical-abuse :)
22:56:26 <tennin> the latter via the former.
22:57:13 <Korollary> Did you pretend to tell the molecules that their bonds would never be strong?
22:58:04 <tennin> something like that
22:58:22 <Pseudonym> "You'll always be inert!"
23:09:13 <Korollary>  /dev/null doesn't cut it, eh.
23:18:53 <BlurredWe> you know, the #beer channel is depressingly empty
23:21:44 <twb> ,bear BlurredWe
23:21:55 <Korollary> They're all in ###berr, #bbear, etc.
23:22:18 <adu> #beer?
23:25:31 <twb> What was the name of that icon theme for GNOME that was scalable before any of the others?
23:30:31 <adu> gScalable?
23:31:33 <adu> grow? gstretch? gexpanding?
23:32:06 <twb> gorilla
23:33:00 <twb> Oh hey, this is #haskell.  I thought I was still lookin' at #emacs.
23:34:33 <dons> hehe. 
23:37:37 <adu> i like emacs
23:37:43 <adu> emacs rocks!
23:38:02 <adu> but i like Gel-pens better
23:40:33 <adu> gel-pens, the only editor you need to refill! (unless you count M$ editors with licensing fees, btw, M$ is copywrong by the empire of doom, in all major contries, void where prohibited, all rights reserved by them, or else by other subsidiaties of other people...)
23:43:13 <adu> clear ^
23:43:18 <adu> gel-pens are cool
