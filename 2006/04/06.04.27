00:10:13 <Korollary> Hey JohnMeacham 
00:10:36 <shapr> Greetz mr JHC
00:17:41 <dons> hey John. do you think JHC could compile FPS these days? Now that I checked that hugs can...
00:18:47 <JohnMeacham> dons: I think so right after I add ForeignPtr support. not that it's difficult, I just havn't gotten around to it yet.
00:19:00 <dons> ah right. cool.
00:46:31 <shapr> whee
00:47:28 <dons> shapr, did I hear you correctly when you said we'd had 216 nicks the other day?
00:47:31 <shapr> yup
00:47:33 <shapr> Maybe more
00:47:46 <dons> I wish we had a graph of the nick count over time
00:48:23 <shapr> dons: Graph the logs
00:48:38 <shapr> Wouldn't be too hard.
00:48:51 <dons> i note that IRC_channel is one of the most popular haskell.org pages. that's gotta help
00:49:39 <shapr> Is there a decent graphing lib?
00:49:48 <shapr> Or.. what's the best graphing lib so far?
00:49:58 <shapr> Cairo? the Gnuplot binding?
00:50:58 <dons> gtk ahs this great scigraph thingy
00:55:03 <shapr> Maybe we should switch to xmpp
00:55:08 <shapr> Netsplits wouldn't be so bad then.
00:55:46 <dons> xmpp?
00:55:50 <shapr> jabber
00:55:57 <shapr> We'd get voice chat and file transfer for free too.
00:56:18 <dons> ah. that would be truly useful for the kinds of collaboration that goes on here.
00:56:30 <dons> but then, another technological barrier to entry
00:56:45 <shapr> Would be easy to put a jabber <-> irc repeater
00:57:37 <shapr> Would also make us interoperable with google talk, gaim, etc.
00:58:26 <dons> who maintains the infrastructure?
00:58:34 <dons> i'm pondering stability
00:58:44 <dons> then again.. netsplits..
00:58:48 <shapr> It's distributed.
00:58:57 <shapr> Jabber servers can connect to each other.
00:59:03 <shapr> clients connect to jabber servers.
00:59:14 <shapr> Google runs their own servers for google talk.
00:59:31 <dons> ah right. so there's already an existing net of jabber servers?
00:59:58 <shapr> yup
01:02:30 <ADEpt> shapr: want to participate in writing xmpp support for haskell? ;)
01:02:44 <shapr> That would be quite nifty.
01:02:52 <ADEpt> dons: btw, i'm here via irc->xmpp gateway 
01:03:04 <ADEpt> shapr: http://adept.linux.kiev.ua/repos/xmpp/
01:14:14 <JohnMeacham> I have put precompiled libraries for jhc online in case you don't have  2 gigs of ram to spare to build them :)
03:16:37 --- topic: '["Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]'
03:16:37 --- topic: set by xerox on [Tue Apr 25 18:17:10 2006]
03:16:38 --- names: list (clog reppie_ mux_ oNoX slipstream eno BCoppens _shawn eamelink boegel revision17_ Lokadin jewel spamsch JaffaCake tessier_ svens Pupeno_ neez eivuokko shawn ksandstr JohnMeacham Hmm_| pesco_ sieni_ icbt borism gzl integral_ swoolley Nioate xerox hyrax42 sellout ozone mokus LoganH moleris cpatrick rasterfar Narrenschiff aasmith olliej1 kolmodin morans emu cognominal Bobstopper Korollary Cale tessier petekaz CLxyz danly thedward shrimpx)
03:16:38 --- names: list (dons audreyt liyang SimonRC alec mlh rcameron Adamant NameTab kzm Beelsebob Paltas eyck nattfodd coumbes moonlite1 newsham adu Poeir vedm triplah lambdabot Oejet falconair kpreid_ Lemmih wilx xinming lisppaste2 genneth mathrick|sleep sdrac8 Saulzar Philippa_ permanente joe_k takuan GeniXPro dechunker Khisanth loud- noclouds khaladan Nomius ski pierre- ADEpt rjlwanro |metaper| amiddelk iblechbot Itkovian SubStack tizoc olliej turok` SamB)
03:16:38 --- names: list (perspectival shapr metaperl kuvkir sethk Muad_Dibber kosmikus Wallbraker sowhat tromp rashakil gdsx mahogny neologism ricebowl yaarg edwinb araujo AtnNn magagr ex__nor arguile Matt-W dcoutts scw lispy cods palomer Magical1_ nothingmuch resiak Spark musasabi bdash bolrod triple_ drbean bobwhoops johs greenrd nomeata gn WillKW cmeme ChilliX vincenz pitecus Igloo Lycurgus_ ohub ulfdoz noj ValarQ earthy kpk Yhtagiwt seafood mattam pejo qwr)
03:16:38 --- names: list (ibid isydor wolverian blb30364 orbitz psnl dfhaii norpan mornfall @juhp djw wli dcoutts_ Maddas flux__ Lunar^ rkeene dany2k)
03:17:15 <kzm> Last I measured, there is a ~10% performance penalty to "pack" compared to Char8, most other functions should be equally fast, some will be a lot faster in some cases.
03:18:29 <kzm> (Correction, each character set must implement four functions and two constants)
03:19:22 <dcoutts> kzm, so what's next? EBDIC? :-)
03:21:39 <kzm> Yes.
03:22:11 <kzm> And the Windows-12xx superset of Latin1, NS-646 (7-bit ASCII replacing some characters with national ones)
03:22:14 <kzm> KOI8
03:23:02 <kzm> I'll simplify by having a function to automatically generate everything from a table, so that you only need to define the character set as a lenght-256 list of Unicode code points.
03:23:50 <kzm> Win12xx = [0..0x7F,0x20nn,0x0Fnn,,,,,0xA0..0xFF]
03:24:04 <kzm> Easy.
03:24:36 <kzm> And an iconv replacement.
03:25:03 <kzm> ten lines of Haskell, a CPP macro for each charset, and close to the C version in speed.
03:25:31 <kzm> The hard part will be adding variable encodings, like the UTF family.
03:26:13 <musasabi> Does GHC set any CPP flags when compiling with profiling?
03:26:21 <kzm> and, ahem.  One more thing that is missing.  I don't actually test any of this :-)
03:27:46 <musasabi> -DPROFILING it seems.
03:28:54 <musasabi> kzm: there is no problem with "a<b" does not imply "pack a < pack b" ? ?
03:28:57 <musasabi> -?
03:33:52 <Lokadin> @where forkio
03:33:52 <lambdabot> I know nothing about forkio.
03:33:57 <Lokadin> hmmm
03:34:08 <Lokadin> say where do i get forkIO what's it a part of?
03:34:29 <eivuokko> Control.Concurren
03:34:33 <Lokadin> thanks :)
03:34:50 <eivuokko> @index forkIO
03:34:51 <lambdabot> Control.Concurrent
03:35:23 <kzm> musasabi hmm.
03:35:44 <kzm> I guess that may be a point.  Do you rely on that behaviour?
03:36:37 <kzm> musasabi, it will be true if you use Char8, Latin1, or ASCII.
03:36:51 <kzm> No wait, not for Char8
03:37:21 <kzm> "\1024" > "\100", but not if you pack them
03:37:42 <kzm> So that only works for my modules (but will not for more jumbled character sets, of course)
03:38:29 <kzm> unpack a < unpack b  implies a < b  for Char8, though.
03:38:36 <kzm> Perhaps that is what you meant?
03:39:10 <musasabi> kzm: yes, that is what I mean. (I don't have Chars > 256 so those are a non-issue for me)
03:41:45 <Lokadin> say when i do (inp,out,err,hdl) <- runInteractiveCommand "echo aoeu" forkIO (hPutStr inp out)
03:41:58 <Lokadin> it tells me out is a String :|
03:42:08 <Lokadin> and it expects IO in hPutStr inp Out
03:42:11 <Lokadin> out*
03:42:19 <kzm> musasabi, just keep using Char8, it won't go away.
03:42:53 <Lokadin> @type runInteractiveCommand
03:42:54 <kzm> It is faster, although if you care about properties on Chars, it will give you the wrong results sometimes.
03:42:55 <lambdabot> Not in scope: `runInteractiveCommand'
03:43:23 <Lokadin> @type System.Process.runInteractiveCommand
03:43:24 <lambdabot> String
03:43:24 <lambdabot>               -> IO (GHC.IOBase.Handle,
03:43:24 <lambdabot>                 GHC.IOBase.Handle,
03:43:24 <lambdabot>                 GHC.IOBase.Handle,
03:43:24 <lambdabot>                 System.Process.Internals.ProcessHandle)
03:43:55 <Lokadin> so isn't out supposed to be type IO?
03:44:04 <Lokadin> not String
03:44:35 <Lokadin> oh nm
03:44:38 <Lokadin> i'm sorry
03:44:41 <Lokadin> that was silly of me
03:45:41 <Lokadin> @type read
03:45:42 <lambdabot> forall a. (Read a) => String -> a
03:52:43 <Lokadin> say why is it that whenever i type backspace in console mode it types ^H
03:52:44 <Lokadin> ?
03:53:45 <jewel> because you aren't using an input library like curses?
03:54:11 <Lokadin> er, well i mean do shell's use curses?
03:54:44 <sieni> http://www.apostrophe.fsnet.co.uk/
03:55:10 <shapr> or do setty erase '(type backspace here)' 
03:55:38 <sieni> setty?
03:55:46 <sieni> stty?
03:55:51 <shapr> er, yeah
03:55:55 <shapr> sorry
03:56:10 <Lokadin> how do i do that? backspace works fine everywhere other than the interpreter
03:56:22 <shapr> Oh, sounds like readline problems.
03:56:23 <Lokadin> er programs in the interpreter
03:56:41 <Lokadin> yea?
03:56:49 <Lokadin> maybe the buffer? i'll go try change that
03:58:44 <Lokadin> bah er i forgot how
03:58:48 <Lokadin> hSetBuffer?
03:59:55 <Lokadin> @type hSetBuffering
03:59:57 <lambdabot> Not in scope: `hSetBuffering'
04:01:32 <Lokadin> what handle would i use?
04:05:01 <Lokadin> yay!!
04:05:19 <juhp> dcoutts: one more question: in my build of gtk2hs docs the index page is full of "show/hide" instead of some javescript link?
04:06:22 <shapr> dcoutts: Hey, a student might want to do language parsers for SoC, anything suggestions after C and PHP?
04:06:32 <shapr> I know we had this discussion before, but I forget what we said.
04:07:57 <dcoutts_> juhp, no idea, what's your haddock version?
04:08:02 <shapr> Anyone want to suggest language parsers that would be good for the Haskell community?
04:08:16 <dcoutts_> shapr, I said there are various C variants that'd be useful
04:08:29 <dcoutts_> and one reason it's not been included before is that people can't agree
04:08:38 <shapr> can't agree on what?
04:08:41 <Lokadin> say, so is there any way to get the output of bash interactivly or what not
04:08:42 <dcoutts_> so add them all! or make it parameterisable 
04:08:45 <dcoutts_> on the lang spec
04:08:54 <dcoutts_> some want strict C99/C89
04:09:02 <dcoutts_> some what what GNU C accepts
04:09:43 <dcoutts_> eg some people want to do analysis of strict C progs, some want to parse all the C code on your system
04:10:19 <shapr> What's simplest?
04:10:28 <dcoutts_> shapr, K&R :-)
04:10:37 <shapr> Seems like a good place to start.
04:10:48 <shapr> Knit already has a minimal C parser.
04:11:03 <Lokadin> so is there no way to get bash's output? like run anything between bash and the user?
04:11:08 <dcoutts_> shapr, c2hs's C parser does C89 + many common GNU extensions
04:11:20 <shapr> Is that better or worse that knit?
04:11:23 <dcoutts_> shapr, but it has one flaw in the C grammar
04:11:30 <shapr> What's the flaw?
04:11:33 <dcoutts_> shapr, I don't know anything about knit
04:11:57 <dcoutts_> shapr, the c2hs one is pretty good in that it really can parse the system headers on many unix systems
04:12:26 <dcoutts_> the flaw is in the handling of typedef'ed identifiers
04:12:50 <dcoutts_> the C grammar has this "context dependency" which makes it non LALR
04:13:10 <dcoutts_> an identifier is handeled differently depending on if it's a type name or not
04:13:18 <dcoutts_> and you can make new type names with typedef
04:13:47 <dcoutts_> so there's this feedback between the parser & lexer to distinguish typeids from normal ids
04:13:58 <dcoutts_> c2hs does this mostly but not fully
04:14:05 <adu> are you talking about standard C?
04:14:13 <dcoutts_> adu, yes
04:14:23 <dcoutts_> shapr, let me find the example...
04:14:36 <shapr> dcoutts_: Sounds like you should be the mentor if he chooses C :-)
04:15:05 <dcoutts_> heh
04:15:11 <juhp> dcoutts: 0.7
04:15:20 <resiak> It'd be lovely if c2hs would understand unnamed nested structs and unions  ;)
04:16:08 <dcoutts> resiak, probably not too hard, send in a patch to the happy grammar
04:16:23 <shapr> Ok, so I should mention C, PHP, and anything else?
04:16:26 <dcoutts> shapr:
04:16:27 <dcoutts> typedef struct path {
04:16:27 <dcoutts> } path;
04:16:27 <dcoutts> typedef struct Agedgeinfo_t {
04:16:27 <dcoutts>  int path;
04:16:28 <dcoutts> } Agedgeinfo_t;
04:16:43 <dcoutts> It's because the path has already been defined as a type identifer and
04:16:43 <dcoutts> the parser is looking for a non-type identifer. However since it is
04:16:43 <dcoutts> obviously allowed to name a variable the same as a typedef'ed name then
04:16:43 <dcoutts> the parser should instead be looking for a non-type or type identifer.
04:17:03 <dcoutts> The gcc grammar has a very complex way of partitioning the typedef and
04:17:03 <dcoutts> non-typedef cases to allow a typedefed name to be reused as an
04:17:03 <dcoutts> identifier in the right context.
04:17:08 <resiak> dcoutts: When I get a moment I will.
04:17:59 <dcoutts> shapr, I was tring to do the same with happy but couldn't eliminate the shift/reduce or reduce/reduce conflicts
04:19:05 <dcoutts_> juhp, I don't know what should be generating javascript
04:19:56 <juhp> dcoutts_: me neither but I guess show/hide should be a "plus" icon that expands/hides the submodules?
04:20:41 <dcoutts_> juhp, i'm not exactly sure what you're seeing
04:21:07 <Cale> dons: haha
04:21:12 <juhp> dcoutts_: hang on
04:21:21 <Cale> (laughing about the Bug monad)
04:21:31 <dcoutts_> shapr, then there's Haskell of course :-)
04:22:01 <dcoutts_> shapr, people don't seem to use the Language.Haskell module much
04:22:13 <dcoutts_> probably because it doesn't quite fit anyone's needs
04:22:42 <shapr> Yeah, most people want to parse their own sources, and almost nobody uses pure H98.
04:23:03 <neologism> any english speaker who can review my short text? (a friends bachelor thesis abstract)
04:23:47 <dcoutts_> shapr, python?
04:24:12 <dcoutts_> shapr, or Java
04:24:14 <juhp> dcoutts_: this http://juhp.dyndns.org/jens/tmp/gtk2hs.html
04:24:16 <shapr> Hm, yeah.
04:24:34 <dcoutts_> juhp, oh yes, I see
04:24:45 <juhp> dcoutts_: what do you get?
04:25:29 <dcoutts_> juhp, http://haskell.org/gtk2hs/docs/current/
04:25:47 <dcoutts_> using haddock 0.7
04:26:52 <dcoutts_> shapr, Java probably isn't that hard (much like C and not nearly as bad as C++) and there may be some existing code that one could start with
04:28:03 <dcoutts_> shapr, one thing that you'd want to do on such a project is build some propper testsuites and demonstrate that these parsers really do parse large quantities of existing real code at resonable speeds
04:28:12 <shapr> There's probably something in the Java to Haskell bridge(s).
04:28:17 <dcoutts_> that'd distinguish it from the various toy/special case parsers
04:28:18 <shapr> Yeah, true.
04:29:01 <dcoutts_> most of the existing parsers were not built to be very general (so may have cur corners in the AST for example)
04:29:18 <dcoutts_> eg the c2hs one parses but ignores most of the GNU extensions
04:30:28 <dcoutts_> shapr, eg you should be able to parse say glibc + the kernel with a GNU C parser
04:30:51 <dcoutts_> and eclipse with a Java parser
04:30:59 <dcoutts_> you know, something hard :-)
04:31:21 <kzm> Phew.  Okay, I rewrote dons' bench to do my modules too.
04:31:22 <dcoutts_> that might be a better goal than having loads of languages
04:31:59 <juhp> dcoutts_:  seem to be missing minus.gif and haddock.js...
04:32:11 <dcoutts_> juhp, ah, that'd explain it
04:32:17 <kzm> results at: http://www.ii.uib.no/~ketil/src/bench.txt
04:32:38 <kzm> source repo at: http://www.ii.uib.no/~ketil/src/fps-i18n
04:33:00 <juhp> dcoutts_: right, but this is just from "make install"...
04:33:26 <dcoutts_> juhp, oh you mean that gtk2hs build system is not installing those files?
04:33:35 <juhp> dcoutts_: afaict, yes
04:33:40 <kzm> map and split seem to be a bit faster, but I want to investigate closer before jumping to any conclusions :-)
04:33:45 <Lemmih> JaffaCake: Fixed mod77.
04:33:53 <JaffaCake> thanks!
04:34:06 <juhp> dcoutts: I could install them by hand for now I guess but it is a bit strange
04:34:22 <dcoutts_> juhp, ah ok. yeah whenever I've made copies of the docs I've just copied them from the dir where they were built
04:34:28 <dcoutts_> juhp, so I never noticed
04:34:32 <juhp> hehe
04:34:42 <juhp> well seems you did ;)
04:34:56 <juhp> ah I see
04:35:10 * dcoutts_ fixes it in Makefile.am
04:35:14 <juhp> :-)
04:35:16 <juhp> thanks
04:36:39 <dcoutts_> juhp, I think those two files were new in haddock 0.7 (I originally did the new build system with 0.6)
04:37:10 <juhp> dcoutts_: gemi started reviewing gtk2hs for fedora extras I think
04:37:13 <juhp> :)
04:37:34 <dcoutts_> juhp, great
04:37:39 <juhp> yeah
04:37:43 <dcoutts_> what does such a review involve?
04:39:31 <juhp> dcoutts_: well it is mainly just checking packaging sanity (packaging facism) and so on: http://fedoraproject.org/wiki/Packaging/ReviewGuidelines
04:39:48 <dcoutts_> juhp, ok ta, I'll take a look
04:39:53 <juhp> :)
04:40:45 <juhp> dcoutts_: https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=189197 if you're curious
04:40:58 <juhp> comments welcome
04:41:31 <dcoutts_> juhp, you might want one or two crasher bug fix patches from the current darcs version
04:42:13 <juhp> dcoutts_: ah ok - if you could send me details that would be cool
04:42:34 <juhp> (would like doc Makefile.am file too:)
04:42:42 <juhp> * patch
04:42:43 <dcoutts_> oh and feel free to send us a patch to update our .spec file (if you think it's worth us keeping a version in our build tree)
04:43:39 <juhp> dcoutts_: ok sure - mine is getting a bit heavy - dunno if it is overkill for upstream, let me compare them again...
04:44:17 <dcoutts_> juhp, I guess it's useful to have a 'generic' reference .spec for other rpm based distros
04:44:34 <dcoutts_> though I don't care if it has fedoraisms in it
04:45:04 <juhp> dcoutts: btw I'm considering to call the packages of the ghc-packages by their ghc-package names IYSWIM: eg ghc-gtk, ghc-glib etc
04:45:15 <dcoutts_> juhp, good idea
04:45:29 <juhp> ok good :)  glad you think so
04:45:36 <dcoutts_> juhp, we may split gtk2hs when we cabalise it (which won't be for a while however)
04:45:38 <juhp> seems kinda cleaner somehow
04:45:41 <dcoutts_> juhp, debian do the same btw
04:45:54 <dcoutts_> libghc6-gtk-dev or whatever
04:45:59 <juhp> oh really - that is reassuring then - thought of it myself afaicr :)
04:46:14 <juhp> aha
04:46:18 <juhp> goodie
04:46:25 <dcoutts_> and they want to have each of those install into a different dir - which the current build system didn't like without hacking
04:46:36 <dcoutts_> I'm planning to make that easier for the next real release
04:46:41 <juhp> ok, gotta go - thanks for helping and the chat
04:46:53 <dcoutts_> ok, ta
04:47:07 <juhp> dcoutts_: ok nice - i would like that for fedora too - as I asked earlier :)
04:47:15 <dcoutts_> yep
05:27:34 <Arucard> hello all
05:27:51 <Arucard> I have a question for you..
05:27:56 <Arucard> if you are so kind..
05:29:23 <olliej> Arucard: i could try to answer
05:29:31 <Arucard> k
05:29:35 <olliej> Arucard: by i'm really not that good at haskell
05:29:46 <Arucard> I'm new to haskell
05:29:53 <olliej> dcoutts: you around?
05:29:57 <olliej> Arucard: fire away
05:29:58 <dcoutts_> olliej, yarr!
05:30:13 <olliej> dcoutts_: i've got ghc.real and ghc.float compiling
05:30:16 <olliej> :)
05:30:35 <Arucard> could you tell me were can I find an opensource project using a GUI for Windows?
05:30:37 <dcoutts_> olliej, with what? (me is not remembering something)
05:30:39 <Arucard> because I can't figure out how to use this thing
05:30:42 <Arucard> :(
05:30:54 <Arucard> GUI
05:30:55 <olliej> dcoutts_: i always just a plain old text editor
05:31:00 <Arucard> Graphical User interface
05:31:04 <Arucard> no
05:31:06 <dcoutts_> Arucard, a windows GUI in Haskell? See gtk2hs
05:31:06 <olliej> Arucard: i know
05:31:22 <olliej> dcoutts_: my Haskell -> .NET compiler
05:31:31 <dcoutts_> olliej, ah, cool!
05:31:35 <Arucard> can I use WinHugs for this?
05:31:53 <olliej> Saulzar_: attack of the clones!
05:32:38 <olliej> Arucard: do you mean a gui for coding in, or do you want to write a gui?
05:32:41 <dcoutts_> olliej, so how do you represent closures, thunks etc in .NET bytecode?
05:32:51 <olliej> dcoutts_: with lots of pain
05:32:54 <dcoutts_> olliej, heh
05:33:03 <olliej> dcoutts_: actually i have a presentation lying around somewhere..
05:33:09 <dcoutts_> presumably you're not going for type interoperability?
05:33:09 <Arucard> no
05:33:14 <Arucard> I need to write a GUI
05:33:25 <dcoutts_> Arucard, gtk2hs
05:33:52 <dcoutts_> olliej, eg you're not having Haskell & .NET use the same basic types?
05:34:03 <olliej> dcoutts_: you have a ppt viewer?
05:34:07 <olliej> dcoutts_: http://research.microsoft.com/workshops/SSCLI2005/presentations/Perry-Hunt.ppt
05:34:10 <dcoutts_> olliej, one would still have to go via a FFI-style mechanism?
05:34:23 <olliej> dcoutts_: GHC.Prim.int#, etc map to int, etc
05:34:26 <dcoutts_> olliej, I can't get OpenOffice to work on amd64 :-(
05:34:32 <olliej> dcoutts_: :(
05:34:35 <olliej> just a moment
05:34:42 <olliej> i should have a pdf somewhere
05:34:59 <dcoutts_> olliej, ok right, so there's a low level interoperability, but not Haskell Int -> .Net Int
05:35:07 <ADEpt> i could convert to pdf
05:35:58 <ADEpt> dcoutts: ping me if needed
05:36:31 <olliej> ADEpt: http://research.microsoft.com/workshops/SSCLI2005/presentations/Perry-Hunt.ppt
05:36:40 <olliej> oh
05:36:43 <olliej> i'd already pasted
05:36:44 <olliej> oops
05:36:46 <olliej> :(
05:37:01 <dcoutts_> olliej, so you'd go via FFI? eg: foreign import ilx "CoreLib void Foo::Bar(int, int)"
05:37:21 <olliej> dcoutts_: it compiles completely to .NET
05:37:27 <dcoutts_> olliej, sure
05:37:29 <olliej> dcoutts_: currently there's no interoperability
05:37:32 <olliej> hehe
05:38:04 <dcoutts_> olliej, but to go from high level Haskell code to "foreign language .NET" you could have a special FFI form (not via C but still FFI)
05:38:04 <olliej> dcoutts_: at the moment the main fight is to ensure that all the types are mapped safely
05:38:44 <dcoutts_> olliej, right
05:38:45 <olliej> GlobalFunc.ffiFunctionName(blargh)
05:38:50 <ADEpt> done. you gmail addresses, gents? :)
05:39:20 <olliej> wow power point loads so fast... *sigh*
05:39:44 <olliej> ADEpt: you don't need to worry about me
05:40:01 <olliej> ADEpt: i have the presentation, and i'm sure i have a pdf version *somewhere*
05:40:13 <dcoutts_> olliej, so you generate "managed" bytecode right? how do you deal with casts (presumably you need casts where the .NET type system is less powerful than Haskell's)
05:40:20 <olliej> dcoutts_: nope
05:40:30 <olliej> dcoutts_: i have everything statically typed
05:40:33 <olliej> with one exception
05:40:38 <olliej> Higher Kinded types
05:40:46 <dcoutts_> interesting
05:40:53 <olliej> which i know how to deal with, but ahven't yet
05:40:58 <dcoutts_> nice
05:41:10 <olliej> dcoutts_: the problem is higher ranked+kinded types
05:41:31 <ADEpt> olliej: well then, I'll just read it myslef at least :)
05:41:33 <olliej> dcoutts_: i have come to the conclusion that they're not possible within the .NET type system
05:41:42 <dcoutts_> so did you base your implementation on anything else? eg borrowing bits of ghc?
05:42:05 <olliej> hehe
05:42:11 <olliej> it calls GHC
05:42:18 <olliej> telling it to produce Core
05:42:23 <olliej> then it works on Core
05:42:28 <dcoutts_> right, nice
05:42:32 <olliej> which is an awful, awful piece of badness
05:42:36 <dcoutts_> hah
05:42:39 <olliej> which i can now actually read
05:42:43 <olliej> without thinking
05:42:53 <dcoutts_> lobotomy?
05:42:56 <dcoutts_> ;-)
05:42:58 <olliej> including the damnable zcoding
05:43:03 <dcoutts_> ah yes
05:43:07 * dcoutts_ shudders
05:43:11 <olliej> heeh
05:43:31 <dcoutts_> I have a hard enought time reading Template Haskell output
05:43:36 <olliej> hehe
05:43:44 <dcoutts_> GHC.Num.+ all over the place
05:43:58 <dcoutts_> > (GHC.Num.+) 1 2
05:43:59 <olliej> dcoutts_: which is worse template haskell output, or a c++ template *error* message
05:43:59 <lambdabot>  Not in scope: `GHC.Num.+'
05:44:10 <dcoutts_> olliej, TH is better
05:44:14 <olliej> dcoutts_: nonono, GHC.Num.zp
05:44:26 <dcoutts_> heh, so core is worse :-)
05:44:31 <olliej> or is it ZP
05:44:33 <olliej> hmm
05:44:45 * olliej can't remember off the top of his head
05:45:03 <olliej> dcoutts_: oh, interestingly the one document describing Core is wrong
05:45:13 <Saulzar> TH isn't much like C++ templates, it's written in Haskell with extra syntax
05:45:18 <dcoutts_> out of date? or never fully implemented?
05:45:21 <olliej> dcoutts_: about a number of the primitive functions
05:45:40 <olliej> and slightly (5 minutes work) wrong about the grammar
05:46:53 <olliej> dcoutts_: i'd say out of date more than anything else
05:47:40 <olliej> Saulzar: power point for mac runs faster on my laptop than on the mini
05:48:14 <olliej> Saulzar: and have you made any pretty pictures?
05:48:27 <Saulzar> Nice, and not yet..
05:48:41 <dcoutts_> olliej, so is there any chance that C FFI will still work?
05:48:55 <olliej> dcoutts_: it's difficult to say
05:49:16 <olliej> certainly you'd need to produce either .NET bindings of the C functions
05:49:29 <olliej> dcoutts_: or implement them in .NET itself
05:49:44 <olliej> dcoutts_: but currently my goal is just to get everything going
05:49:48 <dcoutts_> right, I'm thinking about .NET's FFI capability
05:49:51 <olliej> dcoutts_: less higher ranked types
05:49:55 <dcoutts_> to call out to unmanaged code
05:50:03 <olliej> dcoutts_: technically it's much better than java's
05:50:13 <olliej> dcoutts_: but i haven't really played with it all that much
05:50:19 <dcoutts_> oh good (JNI?)
05:50:32 <olliej> JNI == awful 
05:50:38 <dcoutts_> olliej, so if you do really well then gtk2hs may still work ;-)
05:50:43 <olliej> hehe
05:50:58 <olliej> that's certainly something to do after i finished my masters
05:51:09 <dcoutts_> olliej, are you working with MS .NET or Mono?
05:51:26 <olliej> MS .NET last time i tried mono my code broke the compiler
05:51:33 <olliej> before it reached the vm
05:51:35 <dcoutts_> heh
05:51:38 <olliej> so i kind of lot heart
05:51:42 <olliej> s/lot/lost
05:51:50 <dcoutts_> olliej, did you send it in as a bug report/test case?
05:51:59 <dcoutts_> I get the feeling they're receptive to that kind of thing
05:52:02 <olliej> hehe
05:52:06 <olliej> i really should
05:52:12 <dcoutts_> they've got various other languages compiling with mono
05:52:17 <olliej> yeah
05:52:18 <dcoutts_> eg Java
05:52:26 <dcoutts_> and some version of Python
05:52:34 <olliej> but java is realtively easy as it's all .net 1
05:52:40 <dcoutts_> heh, right
05:52:47 <olliej> i abuse every bit of .NET2 there is
05:53:01 <olliej> although some of the code is hideously bad
05:53:01 <dcoutts_> they'll love you for providing some stress testing :-)
05:53:20 <olliej> and the higher ranked support still isn't complete
05:53:40 <dcoutts_> try getting in contact with their core devs and see what their attitude is
05:53:42 <olliej> i'm fairly sure it will burn when a function returns a higher ranked type
05:54:01 <olliej> dcoutts_: yes, but underlying problem is i have 9 weeks to go for my masters
05:54:21 <olliej> and a still not completely working compiler or dissertation
05:55:10 <dcoutts_> olliej, ah, fair enough
05:55:22 <dcoutts_> best of luck!
05:55:36 <olliej> dcoutts_: hehe
05:55:41 * dcoutts_ has to go teach
05:55:56 <olliej> dcoutts_: teach what? haskell? :)
05:56:24 <olliej> Saulzar: ooh, VS didn't like that
05:56:40 <olliej> Saulzar: just pasted 150KLOC into it
05:58:32 <dcoutts_> olliej, Digital Hardware (using Haskell to simulate combinitorial logic circuts like adders etc)
05:58:52 <olliej> dcoutts_: :)
05:59:03 <dcoutts_> olliej, since it's Haskell I can use QuickCheck to test students' answers :-)
05:59:11 <dcoutts_> which saves me loads of time
05:59:17 * dcoutts_ departs
06:02:40 <norpan> wee QuickCheck!
06:07:43 --- mode: ChanServ set -o juhp
06:31:36 <shapr> SHAZAM!
06:32:02 <shapr> dcoutts_: You using Lava, Hawk, bluespec, etc?
06:35:10 <kzm> Damn
06:35:21 <xerox_> Good morning, people.
06:35:23 <kzm> I can't find any decent information on the EBCDIC mappings.
06:35:35 <kzm> I did implement Windows-1252, though.
06:36:00 <earthy> http://www.natural-innovations.com/computing/asciiebcdic.html ?
06:36:26 <kzm> Adding a new character set is now easier: one function, four constants, one of the constants is the character table.
06:37:18 <ADEpt> kzm: stupid question - why not use iconv or something similar? 
06:37:19 <kzm> earthy, thanks.  I need the Unicode code points for them.
06:37:34 <kzm> iconv?  But, but, ...that's programmed in C!
06:37:48 <kzm> Sure, you can do that.
06:37:56 <earthy> ah, but now you have ASCII code points, and you already have Unicode code points corresponding to those ASCII code points, don't you?
06:38:07 <xerox_> Woohoo, a new student signed up.
06:38:22 <kzm> earthy, and all that is missing are the EBCDIC characters not in ASCII.
06:38:30 <kzm> (and a lot of work)
06:38:32 <earthy> http://www.unicode.org/reports/tr16/#Table%201 doesn't help?
06:38:35 <kzm> Oh well, that's a day for me.
06:38:37 <kzm> Must run.
06:39:07 <kzm> maybe it does.
06:41:01 * Cale_ reads monadic o'caml code
06:41:46 <Cale_> Sort of odd with no do-notation and no typeclasses.
06:44:08 <earthy> without typeclasses... ouch
06:44:25 <earthy> bind looking different for every type?
06:44:49 <Cale_> they open appropriate modules for the monad to me used
06:44:51 <Cale_> be*
06:45:25 <Cale_> so basically, you get one monad at a time, which in this case is okay, but it would be awkward in general
06:46:42 <earthy> hu, quite.
06:52:24 <toste> in f :: (a,b) -> c, would (curry f) be a high order function ?
06:52:47 <Cale_> toste: depends on how you define "higher order"
06:53:15 <Cale_> Normally you wouldn't consider it to be in a language like Haskell, since that's just the usual way to pass multiple parameters
06:53:42 <Cale_> It's more interesting with something like (a -> b) -> c
06:53:48 <toste> yer, but thats in a old exam... so i guess i need to understand high order functions :/
06:54:00 <Cale_> It would depend on the course's definition
06:54:13 <toste> logical programmation
06:54:28 <Cale_> (the course's definition of "higher order")
06:54:34 <toste> ahh ;p
06:54:43 <toste> well i think its a function who returns a function
06:55:08 <Cale_> well, all functions of multiple parameters do that in Haskell
06:55:17 <Cale_> so (+) would be higher-order if that's the case
06:55:35 <Cale_> a function which takes a function as a parameter would be a better definition
06:56:00 <pirroH> Hi
06:56:04 <Cale_> hi
06:56:10 <xerox> Hell√≤
06:56:20 <toste> f :: (a,b) ->c ; (a,b) is function, but it can be a pair
06:56:24 <toste> hum.. ;/
06:56:52 <Cale_> hm?
06:57:05 <Cale_> (a,b) is the type of pairs of elements of a and b
06:57:30 <Cale_> f :: (a -> b) -> c is quite different
06:57:40 <toste> so a high order def would be more of this type ::> f::(a->b)->c
06:57:50 <Cale_> yeah
06:58:05 <Cale_> Or at least, that's closer to what I'd consider to be higher order
06:58:49 <toste> if, g::Int->Char and f::[a]->FLoat; then is g.f possible ?
06:59:00 <Cale_> no
06:59:13 <Cale_> (.) :: (b -> c) -> (a -> b) -> (a -> c)
06:59:16 <toste> if, g::Float->Char and f::[a]->FLoat; then is g.f possible ?
06:59:18 <toste> :p
06:59:41 <Cale_> You should be able to work out if it's possible from the type I gave for (.)
07:00:04 <Cale_> (or just by thinking about it :)
07:00:31 <SamB> or, you could just try it ;-)
07:00:50 <toste> well, it's g(f x), so f return x::Float wich is compatible with g and then its possible
07:01:13 <yaarg> rt
07:02:18 <petekaz> Cale_: question on your tutorial (MonadsAsContainers) again? I got lost when it came to the Reader section. Can you show me a simple example of using the Reader monad?  I don't understand the purpose of it.  (->) is a function?  Is that -> the same -> in a lambda expression?
07:02:39 <toste> > Ord 'a'
07:02:40 <lambdabot>  Not in scope: data constructor `Ord'
07:02:54 <Cale_> petekaz: it's the -> in a type
07:02:56 <xerox> petekaz: that (->) is the same one that compares in the types of functions.  It is the function type constructor.
07:03:15 <toste> > ord 'a'
07:03:16 <lambdabot> 97
07:03:28 <xerox> (->) e = e -> ...
07:03:31 <Cale_> petekaz: note that we're applying it to a specific type here, so our monad really consists of all the functions from a specific type
07:03:32 <petekaz> Oh ... I thought it was something to do with -> in case statements and/or lambdaz.
07:03:36 <toste> > chr 'a'
07:03:37 <lambdabot> Couldn't match `Int' against `Char'
07:04:04 <olliej> >chr 97
07:04:14 <olliej> > chr 97
07:04:15 <lambdabot> 'a'
07:04:34 <toste> g x = intToDigit x
07:04:35 <xerox> Cale: I was reading `Composing Monads' lately.  So there *is* a way to define swap :: (Monad m, Monad n) => m (n a) -> n (m a), nice.
07:04:54 <xerox> Or was it m (n (m a)) .. hm, that, anyway.
07:04:55 <toste> doesnt work :/
07:05:04 <toste> hum, i need to include something ?
07:05:14 <xerox> toste: import Data.Char
07:05:23 <Cale_> xerox: for some specific pairs of monads
07:05:55 <Cale_> xerox: you obviously can't do it in general
07:05:59 <xerox> toste: do find where a certain function reside in the modules' hierarchy, just use lambdabot's @index <function>.  Or even @hoogle <type|function>.
07:06:23 <xerox> Cale_: sure. The paper doesn't talk about a specific typeclass for swappable Monads, though.
07:08:12 <Cale_> yeah, but that's definitely how you'd want to do it in Haskell.
07:08:36 * xerox nods
07:08:50 <SamB> can you maybe split up swapping into to parts that can be done seperately/
07:08:56 <SamB> s|/|?|
07:09:15 <SamB> and then put each of those in a typeclass?
07:09:39 <xerox> "You may call Oleg."
07:18:56 * shapr laughs
07:19:54 <earthy> hm.
07:20:01 <earthy> a typeclass for swappable monadsd
07:20:15 <earthy> I wonder how useful that'd be
07:20:31 <norpan> swappable monads?
07:20:38 <earthy> given the alternatives of monad transformers and monadic coproducts
07:20:44 <xerox> I've received a slick project idea without mentor, woot.  http://manta.univ.gda.pl/~asiekiel/jhypernets/
07:20:56 <xerox> ``I am thinking about writing a complete, fast model checker''
07:21:10 <xerox> He'll be adding the ticket.
07:21:19 <earthy> and he doesn't want to do spin or smv? :)
07:21:28 <shapr> Isn't there another petri nets tool in Haskell?
07:22:19 <ADEpt> shapr: btw, I've submitted 'xmpp bindings' as a project idea for SoC
07:22:26 <shapr> Cool!
07:22:42 <xerox> Ah, that's you!
07:23:24 <olliej> xmpp?
07:23:36 <xerox> ADEpt: why didn't you add yourself as an Interested Student?
07:23:45 <xerox> "'cos I'm not."
07:24:29 <xerox> Cale_: yesterday I was trying to do unPack :: (Monad m) => m (m (m (... a ...))) -> a
07:24:43 <Cale_> -> m a ?
07:24:43 <pitecus> What time complexity would the memoized version of this http://urchin.earth.li/darcs/ian/lcs/Data/List/LCS/Simple.hs have?
07:24:51 <xerox> Cale_: possibly.
07:25:09 <Cale_> you can't do m (...) -> a
07:25:20 <xerox> That's a good point.
07:25:22 <ADEpt> xerox: yep, that's me, and I'm not a student anymore. I'm slowly writing my postgrad, but that does not count, since i'm not doing it as my "primary occupation" (or how to say it?)
07:25:27 <Cale_> because then you could unPack getLine
07:25:34 <xerox> ADEpt: ah, okay.
07:25:37 <ADEpt> olliej: xmpp, as in "jabber"
07:25:43 <olliej> ah
07:25:45 <olliej> :)
07:25:47 <shapr> aka google talk
07:25:49 <xerox> ADEpt: not willing to mentor either? (-:
07:25:51 <Cale_> so really, you're just doing join over and over
07:25:52 <ADEpt> yep
07:25:53 <olliej> yup
07:26:04 <xerox> Cale_: right.
07:26:18 <ADEpt> xerox: i did a bookmark to read in evening whether I qualify
07:26:20 <xerox> Cale_: but without type (in)equality in typeclasses, it's difficult.
07:26:38 <xerox> ADEpt: ah, cool.  Ping me back with an answer :--)
07:26:45 <xerox> (Ops, long nose.)
07:26:53 <olliej> hehe
07:27:02 <shapr> xerox: Sounds like you want a hyperfunction.
07:27:10 <shapr> newtype Hyper b c = H (Hyper c b -> c)
07:27:11 <ADEpt> xerox: is there a shorted description of "mentoring" than 10km-long FAQ at google? :)
07:27:26 <xerox> ADEpt: let me explain to you, a sec
07:27:33 <shapr> Hyperfunctions are arrows rather than monads.
07:27:33 <SamB> pitecus: hmm?
07:27:57 <pitecus> Hmm what, SamB?
07:28:04 <xerox> shapr: what's the kind of c ?
07:28:34 <ADEpt> xerox: I'm all ears
07:28:36 <SamB> pitecus: memoized how?
07:28:41 <shapr> Hm, I'd guess it's *, but I'm not sure.
07:28:50 <Cale_> xerox: yeah
07:29:46 <xerox> ADEpt: basically a mentor has to privide guidance to the student, help him out with design and code problems, and give him the necessary mailing lists names, documentation links, whatever he may ask for.  He has *not* to code for the student, just that.
07:29:59 <pitecus> Oh, by storing the result of each call in a Map
07:30:08 <Cale_> shapr: it's not that he wants a hyperfunction -- he just wants a typeclass function which applies join an appropriate number of times
07:30:28 <xerox> shapr: I read it as `Cannot construct the infinite kind * = * -> *', but I'm just trying to guestimating it.
07:30:31 <ADEpt> xerox: so, basically, mentor has to have a knowledge in the "subject matter" of the project, right?
07:30:31 <SamB> pitecus: isn't that going to make it worse?
07:31:03 <shapr> Oh, I see.
07:31:35 <ADEpt> xerox: or mentor could get away with rather shallow knowledge of subject matter, but knowledge of broad spectrum of "all things related to the task"?
07:31:46 <pitecus> No, instead of a recursive call you check if the result has already been computed and only computed it if it is not there
07:31:59 <xerox> ADEpt: Haskell knowledge is surely needed, the particular project's topic one is good to have--but for example, I did ask the Cairo mailing list for cairo problems, not Duncan, last year.
07:32:26 <xerox> ADEpt: the role of the mentor is more providing guidance in the FOSS developement world, say.
07:32:48 <SamB> pitecus: but wouldn't it take too long to look it up?
07:33:04 <ADEpt> xerox: do you know how "large" is time commitment for this? 
07:33:34 <xerox> ADEpt: there is a detailed timeline in each FAQ.
07:34:08 <pitecus> well lookup is O(log n) whereas the original algo is exponential, I think. So I was wondering what complexity the memoized version would have but I'm too dumb to work it out.
07:35:44 <SamB> I dunno either.
07:35:58 <pitecus> :-(
07:36:18 <SamB> I think that this is perfect for dynamic programming, though
07:38:33 <pitecus> There is also a DP version there but its way too complex for me to understand, and I need to modifiy this thing to return also positions of each element of the LCS.
07:39:22 <Igloo> If you have the LCS then finding positions is easy: Just run through the two pairs of lists
07:39:43 <SamB> maybe you should write a simpler DP version ;-)
07:41:04 <pitecus> Igloo can you sketch the method? I can't figure it out.
07:42:03 <ADEpt> xerox: now you tricked me into reading Google's FAQ. Shame on you :)
07:42:21 <xerox> ADEpt: it's simple in fact!
07:43:42 <SamB> @index Array
07:43:42 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
07:46:39 <ADEpt> xerox: is there a mentorship on how to apply as a mentor? :)
07:46:54 <SamB> ADEpt: to your left?
07:47:28 <xerox> ADEpt: just ask me!
07:47:46 <Cale_> hmm, I might actually have use for a DAG monad :)
07:48:00 <xerox> ADEpt: it's very simple, you add your name on the People page, and the ideas as tickets in the system, following the other ones' style as a guideline.  I did an hard work getting them in the exact same shape :-)
07:56:21 <xerox> We need Iaac, he should tell mentors how to sign in.  It has to be done this days.
08:00:16 <ADEpt> xerox: hope I did that right
08:02:35 <xerox> ADEpt: perfect.  Thank you very much.
08:07:45 <dcoutts_> shapr, re: lava, etc: no, nothing that formal, it's just a first year course
08:08:26 <dcoutts_> shapr, type Bit = (Int, Int) -- 0/1, time bit becomes stable (for timing/depth)
08:18:37 <olliej> dcoutts_: i hate Core
08:27:13 <Lemmih> Wow, Haskell.org's SoC project #48 looks neat. If no students take it, I will.
08:32:40 <dcoutts_> @karma+ xerox
08:32:41 <lambdabot> xerox's karma raised to 13.
08:33:09 <norpan> @karma norpan
08:33:10 <lambdabot> You have a karma of 0
08:33:14 <norpan> :(
08:34:29 <ndm> xerox, malcolm is still away, so i haven't seen him yet
08:35:00 <norpan> Lemmih: looks interesting, but why are there spare bits in the pointers?
08:35:23 <shapr> Truly, that does look cool.
08:35:53 <Lemmih> norpan: I don't know. It acutally surprised me a bit.
08:35:55 <shapr> Do the spare bits have to do with the long ago DOS extra address lines?
08:36:17 <norpan> are these some kind of special pointers?
08:36:28 <norpan> i certainly have no bits to spare, especially in my 32 bit pointers
08:36:43 <norpan> or are all pointers word-aligned?
08:36:59 <norpan> that could be it
08:37:14 <Lemmih> Yeah, that sounds plausible.
08:37:17 <xerox> ndm: gotcha.
08:37:33 <xerox> dcoutts_: thank you very much :-D
08:37:43 <ndm> norpan, typically, yes, all pointers are word aligned
08:37:44 <norpan> but that would only give 3 bits on a 64-bit pointer if a word is 64 bits
08:37:53 <ndm> thats how Yhc steals out 2 bits
08:38:11 <norpan> but ok
08:38:14 <ndm> usually a 4 bvyte pointer is aligned on 4 byte boundaries, hence 2 free bits
08:38:42 <ndm> nhc used to steal the top bit as well, but that ended up going very very wrong...
08:38:49 <dcoutts_> heh, yeah
08:39:11 <dcoutts_> borked when the kernel started giving memory from the top half of the address space
08:41:06 <dcoutts_> juhp, gtk2hs/haddock-0.7 patch pushed
08:41:17 <xerox> Lemmih: I'm liking the #58 too!
08:41:17 <xerox> Likeing?
08:41:23 <SamB> what is a tcRule?
08:42:39 <Lemmih> xerox: Yeah.
08:43:56 <ndm> dcoutts_, ironically, they updated the distro on the York systems so it always gives memory in the top half, so its not run on York for ages
08:44:28 <mnislaih> what is the easiest way to get GHC 6.5 to build ? get it from darcs or a snapshot?
08:44:58 <Igloo> a snapshot might have autoreconf run already; other than that they'll be the same I imagine
08:45:44 <mnislaih> I've already autoreconfed the srcs from darcs, 
08:46:29 <mnislaih> I can't even get past 'make boot'. It tries to compile the lexer files from alex with some 'g' ?
08:46:47 <Igloo> Do you have alex installed?
08:46:51 <mnislaih> yep
08:47:02 <Igloo> Oh, the snapshot might have alex, happy etc pre-run actually
08:47:03 <mnislaih> ah wait
08:47:06 <Igloo> Did configure find alex?
08:47:10 <mnislaih> I didnt have it when I configured
08:47:12 <mnislaih> I will reconf
08:48:07 <xerox> Wops.
08:48:31 <xerox> I did say, "dcoutts, thank you very much", and "Lemmih: I'm liking the #58 too!".
08:48:33 <SamB> hmm, there ought to be a way to generate RULES pragmas from TH
08:49:11 <xerox> (mfix meta-) programming.
08:50:57 <Lemmih> SamB: TH based rules, hm. Sounds like a SoC project.
08:51:30 <dcoutts_> I think it's probably not possible except in narrow cases because of the matching problem
08:51:36 * SamB checks to make sure there isn't one
08:51:38 <Lemmih> It would be neat if core rules like 'n# +# m#' could be user defined.
08:51:48 <Igloo> Lemmih: Doesn't sound big enough to be a project to me
08:51:49 <mnislaih> Igloo: it's compiling now
08:51:51 <xerox> "Sounds like a SoC project" will be the usual answer to people's questions for the next four days at least.
08:51:52 <SamB> dcoutts: huh?
08:51:56 * xerox laughs
08:52:00 <edwinb> I don't suppose anyone knows of a Presburger arithmetic solver in Haskell do they?
08:52:12 * edwinb waits for someone to say "sound slike a SoC project"
08:52:27 <dcoutts_> SamB, ghc can only match a fairly restricted syntax to trigger a rule
08:52:53 <wchogg> xerox:  Well, even though there won't be remotely enough students to do all the proposed projects, at least we now have a giant wish list of things people should get together and hack on.
08:52:54 <dcoutts_> SamB, so it's much less general than TH
08:53:01 <SamB> dcoutts: oh, I know
08:53:07 <xerox> wchogg: pa-ching!
08:53:43 <Lemmih> Igloo: I actually think it would be quite difficult to write. Probably wouldn't require a lot of code in the end, though.
08:53:56 <dcoutts_> SamB, but GHC optimisation passes embeded in a module would be cool
08:54:07 <SamB> dcoutts: have you seen the "listArray/UArray/*" rules?
08:54:16 <dcoutts_> Lemmih, how about that? runtime loading by ghc of Core->Core optimisation passes?
08:54:40 <dcoutts_> SamB, I've seen some STUArray rules which are really ugly :-)
08:55:00 <Igloo> Lemmih: If you didn't have a mentor then I might agree...
08:55:02 <dcoutts_> Lemmih, so no need to recompile GHC to add a optimisation/transformation pass?
08:55:11 <SamB> dcoutts: there are like 17 of them, and the only differences are the name and the type signature
08:55:27 <dcoutts_> SamB, yes I know, that's a problem with the types
08:55:50 <dcoutts_> that type problem can actually show up in real programs too (it bit me)
08:56:25 <SamB> well, I was thinking it would be nice to be able to just mapM over a list of the types rather than have to do that sort of thing...
08:56:27 <dcoutts_> it's because there's nowhere to add the class context (because of a forall'ed type var iirc)
08:56:51 <SamB> I realize you can't do that in portable code...
08:58:39 <dcoutts_> Lemmih, so you could implement domain specific optimisations by writing a Core->Core transform and have ghc load it up and use it when compiling client modules
08:59:23 <dcoutts_> Lemmih, module MyDSL (foo,bar, module MyCoreOptimiser) where ...
08:59:52 <dcoutts_> so if you directly import MyDSL then your code will get optimised by the transform declared in module MyCoreOptimiser
09:00:28 <dcoutts_> {-# CORE_TRANSFORM myCoreTransform #-}
09:01:01 <dcoutts_> myCoreTransform :: Core -> TC Core
09:02:44 <Lemmih> (:
09:07:04 * dcoutts_ approves of ticket #44
09:07:20 <dcoutts_> to port haddock to use the ghc api
09:10:18 <araujo> Hello!
09:16:33 <olliej> night all
09:17:06 <olliej> dcoutts_: ghc.num, float, real, enum, st, and arr compile
09:17:13 <olliej> and iobase crashes and burns
09:17:38 <olliej> but that may due to it doing stuff with parsercombinators
09:17:47 <olliej> anyhoo, g'night
09:20:18 <dcoutts_> good work olliej 
09:22:07 <swiert> dcoutts_: You may want to know that gtk2hs has been added to darwinports.
09:22:13 <dcoutts_> woot!
09:22:22 <dcoutts_> nice
09:22:33 <xerox> Wow!
09:22:45 <xerox> If only GHC was... *grin*
09:22:46 <dcoutts_> swiert, I'll add a link from the gtk2hs download page, where should I point to?
09:23:21 <swiert> xerox: GHC is.
09:24:18 <swiert> dcoutts_: let me check.
09:24:35 <dcoutts_> ta
09:25:15 <swiert> It will be http://gtk2hs.darwinports.com/.
09:25:37 <ulfdoz> I c "Nuttenpunkte". :)
09:25:38 <araujo> that's cool
09:25:39 <swiert> But you can point to http://bugzilla.opendarwin.org/show_bug.cgi?id=7846 for now.
09:25:43 <araujo> hi CosmicRay 
09:27:07 * SamB wonders if smerdyakov is going to get himself banned from ##c
09:27:17 <CosmicRay> hi araujo
09:27:18 <ulfdoz> lol
09:27:27 <araujo> SamB, he will, if he continue like that
09:27:30 <CosmicRay> SamB: oh, he's going for yet another ban eh?
09:27:50 <SamB> dunno
09:28:06 <SamB> he's foaming at the mouth about ML...
09:28:22 <araujo> I don't understand why he has to do that in there
09:29:39 <swiert> bbl.
09:32:28 <araujo> xerox!
09:32:57 <araujo> No Smerdy action.
09:33:03 <xerox> Oops.
09:33:04 <xerox> I wonder why I keep getting disconnected *grumble*
09:33:10 <araujo> Lemmih, he stopped talking just when you got in :-)
09:33:22 <xerox> Talk where?
09:33:46 <araujo> xerox, smerdy action in ##c
09:36:02 <Lemmih> Smerdyakov is actually the one who got me interested in Haskell.
09:36:19 <Lemmih> SyntaxNinja: Hiya.
09:36:30 <araujo> Lemmih, really?, through ML?
09:36:37 <xerox> Howdy Isaac.
09:36:44 <araujo> Because it's the only thing i see him talking about
09:37:01 <araujo> In ##c :-/
09:40:34 <SyntaxNinja> y0
09:40:50 <araujo> SyntaxNinja, hola
09:41:13 <Lemmih> araujo: Well, he's just using ML as an example of how great FP is.
09:41:33 <araujo> Lemmih, That's great indeed.
09:43:43 <araujo> But doing that in such a way inside ##c usually gets thing out of control.
09:46:15 <DeliQ> what is the minimal implementation of the class Show ?
09:46:21 <DeliQ> the function show ?
09:46:29 <Cale_> DeliQ: yeah
09:46:37 <DeliQ> Cale: thank you!
09:47:14 <Cale_> DeliQ: In the rarer case that you can meaningfully do showsPrec, it's probably better to start there though.
09:47:17 <Lemmih> araujo: Yeah, he's a schizomaniac jerk who often takes issues to the extreme.
09:48:08 <Cale_> ...which is why he was banned from here
09:48:10 <araujo> Lemmih, ok, interesting definition :-P
09:50:28 <DeliQ> Cale_: won't be neccesary, i'm making a simple propositition shower :P
09:57:03 <SyntaxNinja> y0 araujo
09:59:30 <DeliQ> btw, can you give priorities to data constructors (binary operators) in haskell
09:59:42 <fons> hello
09:59:48 <Cale_> yep, there are fixity declarations
09:59:55 <fons> is there a way to translate DOubles to floats in haskell?
10:00:00 <DeliQ> say, infix 5 :->:
10:00:07 <Cale_> DeliQ: yes, exactly
10:00:07 <fons> The problem is that I'm using Parse
10:00:13 <DeliQ> aah ty!
10:00:14 <fons> Parsec
10:00:29 <fons> and it only gives a Double parsing function for free
10:00:31 <Cale_> fons: truncating?
10:00:56 <fons> Cale, truncate a Double into a float?
10:01:55 <Cale_> > (fromRational . toRational) (pi :: Double) :: Float
10:01:55 <lambdabot> 3.1415927
10:02:30 <Cale_> also known as realToFrac
10:02:41 <Cale_> > realToFrac (pi :: Double) :: Float
10:02:42 <lambdabot> 3.1415927
10:02:52 <Cale_> > realToFrac (pi :: Float) :: Double
10:02:52 <lambdabot> 3.1415927410125732
10:03:00 <Cale_> > pi :: Double
10:03:01 <lambdabot> 3.141592653589793
10:03:04 <fons> realToFrac
10:03:06 <fons> cool
10:03:24 <Cale_> > realToFrac (pi :: Float) :: Rational
10:03:25 <lambdabot> 13176795%4194304
10:03:31 <Cale_> > realToFrac (pi :: Double) :: Rational
10:03:32 <lambdabot> 884279719003555%281474976710656
10:03:35 <Cale_> :)
10:03:45 <davidhouse> nice :)
10:04:24 <davidhouse> @type pi
10:04:25 <lambdabot> forall a. (Floating a) => a
10:04:56 <davidhouse> is that how it is defined? that ratio?
10:05:17 <fons> Cale_, refering to what you were talking about before
10:05:17 <Cale_> It's defined separately for different instances of Floating
10:05:53 <fons> you can set the priority and associativiti of a constructor?
10:06:03 <fons> (If it's infix I mean)
10:06:04 <Cale_> fons: yep
10:06:09 <fons> nice
10:06:13 <Cale_> infix, infixl, infixr
10:06:24 <fons> so (:) is an infix constructor then
10:06:28 <Cale_> yeah
10:06:29 <fons> interesting
10:06:39 <Cale_> Infix constructors all start with : too
10:06:59 <Cale_> (other infix functions cannot start with : )
10:07:31 <Cale_> So I guess : is a capital symbol :)
10:08:08 <fons> cool
10:13:55 <Igloo> Cale_: Sounds more reasonable than [ and ] being letters  :-)
10:33:27 <sjanssen_> @yow
10:33:27 <lambdabot> Here we are in America ... when do we collect unemployment?
10:33:32 <shapr> @quote
10:33:32 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
10:33:42 <shapr> @quote
10:33:42 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from England just to kill me if I did that
10:33:55 <wchogg> Those are some nice ones.
10:34:01 <xerox> Heh, last time Lemmih was asking if someone remembered what was "that."
10:34:03 <sjanssen_> I wonder what SyntaxNinja was considering?
10:34:04 <shapr> What happened to @remembe?
10:34:43 <SyntaxNinja> hi spahr
10:34:44 <SyntaxNinja> er
10:34:46 <SyntaxNinja> shapr
10:35:06 <SyntaxNinja> sjanssen_: I think major modifications to cabal, which was at that point holding up all of the compiler releases
10:38:52 <dcoutts_> xerox, I've applied as a mentor
10:39:02 <xerox> dcoutts_: good.
10:39:29 <SyntaxNinja> danke
10:41:00 <toste> no more haskell !!
10:41:15 <toste> have a good life yall ;p
10:41:17 <sjanssen_> toste: no, more Haskell!!
10:41:32 <toste> ;D
10:44:15 <dcoutts_> SyntaxNinja, how would a used pass in extra library/header search paths with Cabal? eg if someone installes something to /usr/local
10:44:47 <dcoutts_> by default the header path will only be /usr/include and lib search path will be /usr/lib
10:44:50 <shapr> hiya SyntaxNinja 
10:45:15 <dcoutts_> or are there gcc env vars that control this?
10:45:22 <dcoutts_> used/user
10:46:07 <dcoutts_> SyntaxNinja, I mean if a user installed a C package to /usr/local/{lib,include} and now we're trying to build a Haskell bindings package
10:47:18 <CosmicRay> shapr!
10:47:55 <shapr> CosmicRay!
10:48:04 <davidhouse> @get-shapr
10:48:04 <lambdabot> shapr!!
10:48:11 <dcoutts_> CosmicRay, this Q to SyntaxNinja was a user tring to build hdbc-postgresql (having installed libpq to /usr/local)
10:48:33 <ValarQ> @annoy-shapr
10:48:34 * shapr boings
10:48:34 <lambdabot> Unknown command, try @list
10:48:37 <shapr> :-P
10:48:40 <ValarQ> aw :(
10:48:40 <shapr> CosmicRay: wassup?
10:49:09 <CosmicRay> shapr: hmm, not much haskell-wise.  lots real-life-wise ;-)
10:50:04 <shapr> Last time I saw an ant infestation like that I lived in CA.
10:51:02 <CosmicRay> shapr: haha
10:51:59 <shapr> Is Alson Kemp here?
10:53:13 <CosmicRay> shapr: for whatever reason, there weren't lots of ants elsewhere.  just in the switch.
10:53:57 <davidhouse> is there an equivalent unix var, like $PATH, but for includes? (i.e. /usr/include et al)
10:54:18 <CosmicRay> pkg-config is starting to be that
10:54:22 <CosmicRay> but other that that, not really.
10:54:34 <davidhouse> hmm. okay.
10:57:55 <CosmicRay> pkg-config is really a nice system imho
11:01:37 <DeliQ> @pl not . null . intersect (positives p) $ (negatives p)
11:01:37 <lambdabot> not (null (intersect (positives p) (negatives p)))
11:02:03 <DeliQ> @pl not (null (intersect (positives p) (negatives p)))
11:02:03 <lambdabot> not (null (intersect (positives p) (negatives p)))
11:04:53 <davidhouse> @pl \f g h i p -> not $ h $ (f p) `i` (g p)
11:04:54 <lambdabot> (((((not .) .) .) . flip ((.) . (.))) .) . flip . (ap .) . flip (.)
11:04:55 <sjanssen_> @pl False
11:04:55 <lambdabot> False
11:05:04 <davidhouse> DeliQ: you have to lambda.
11:05:40 <sjanssen_> @pl \p -> not . null . intersect (positives p) $ (negatives p)
11:05:41 <lambdabot> ap (((not . null) .) . intersect . positives) negatives
11:05:49 <davidhouse> @pl \f g h p -> not . null $ f p `h` g p
11:05:49 <lambdabot> ((((not . null) .) .) .) . flip . (ap .) . flip (.)
11:06:24 <davidhouse> @pl \p -> not . null $ positives p `intersect`negatives p
11:06:24 <lambdabot> not . null . liftM2 intersect positives negatives
11:11:08 <DeliQ> aah thanks!
11:26:20 <jlhamilton> @pl \x -> x + 1
11:26:20 <lambdabot> (1 +)
11:27:08 <Cale_> @pl \x -> x - 1
11:27:08 <lambdabot> subtract 1
11:27:13 <Cale_> @pl \x -> 1 - x
11:27:13 <lambdabot> (-) 1
11:27:25 <Cale_> @pl \x -> (x / 2)
11:27:25 <lambdabot> (/ 2)
11:27:31 <Cale_> @pl \x -> (2 / x)
11:27:31 <lambdabot> (2 /)
11:27:45 <Cale_> Interesting that it used the associativity of + in the first one
11:27:55 <Cale_> er
11:27:57 <tnks> Hi.  There's a Haskell extension I'm not familiar with:  How do I read "class TypeCast x y | x -> y, y -> x"?
11:27:58 <Cale_> commutativity
11:28:03 <mauke> @pl \x -> x * 2
11:28:03 <lambdabot> (2 *)
11:28:29 <sjanssen_> tnks: the | x -> y ... part is called a functional dependency.  fundep for short
11:28:29 <jcreigh> Hmm...
11:28:35 <jcreigh> @pl \a b -> a + b
11:28:36 <lambdabot> (+)
11:28:42 <Cale_> tnks: TypeCast is a class of two parameters x and y where x determines y uniquely, and y determines x uniquely
11:28:50 <jcreigh> So @pl translates to point-free style?
11:28:56 <Cale_> jcreigh: yeah
11:29:03 <mauke> pl == pointless
11:29:40 <Cale_> @pl \x -> 3 * x^2 + 5 * x + 7
11:29:41 <lambdabot> (7 +) . ap ((+) . (3 *) . (^ 2)) (5 *)
11:29:50 <Cale_> much clearer :)
11:30:17 <sjanssen_> @. pl djinn (a, b) -> b -> (d -> a) -> d -> (b, a)
11:30:17 <lambdabot> f = const ((.) . (,))
11:31:03 <jcreigh> Could *anything* be expressed that way? ie, is there any expression that cannot be expressed in a "pointless" style?
11:31:04 <sjanssen_> oops, that isn't too interesting
11:31:14 <xerox> Cale: the second one is a polynomial of functions, hehe.
11:31:25 <sjanssen_> jcreigh: yes anything can be expressed that way
11:31:35 <Cale_> @. pl djinn (c -> c -> d) -> (a -> c) -> (b -> c) -> d
11:31:35 <lambdabot> (line 1, column 1):
11:31:35 <lambdabot> unexpected "-"
11:31:35 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
11:31:45 <Cale_> @. djinn (c -> c -> d) -> (a -> c) -> (b -> c) -> d
11:31:45 <lambdabot> compose module failed: Parse error: "(c"
11:31:54 <Cale_> djinn (c -> c -> d) -> (a -> c) -> (b -> c) -> d
11:32:02 <Cale_> @djinn (c -> c -> d) -> (a -> c) -> (b -> c) -> d
11:32:02 <lambdabot> -- f cannot be realized.
11:32:06 <tnks> Cale: sjanssen_: thanks.  I think I just needed to know what to look up in Google.  I found a page that describes it nicely.
11:32:13 <Cale_> @djinn (c -> c -> d) -> (a -> c) -> (b -> c) -> a -> b -> d
11:32:13 <lambdabot> f a b c d e = a (b d) (c e)
11:32:19 <Cale_> @. pl djinn (c -> c -> d) -> (a -> c) -> (b -> c) -> a -> b -> d
11:32:20 <lambdabot> f = ((flip . ((.) .)) .) . (.)
11:33:09 <Cale_> @. pl djinn (a -> c) -> (b -> c) -> (c -> c -> d) -> a -> b -> d
11:33:09 <lambdabot> f = flip . ((flip . ((.) .)) .) . flip (.)
11:33:58 <xerox> shapr: may you link me again to Conway's proof?
11:36:02 <sjanssen_> does Djinn understand lists?
11:36:16 <sjanssen_> @djinn [a] -> a
11:36:17 <lambdabot> -- f cannot be realized.
11:36:26 <sjanssen_> @djinn a -> [a]
11:36:26 <lambdabot> -- f cannot be realized.
11:36:37 <davidhouse> @djinn [a] -> [a]
11:36:38 <lambdabot> f a = a
11:36:43 <davidhouse> @djinn [a] -> [b]
11:36:44 <lambdabot> -- f cannot be realized.
11:38:22 <shapr> xerox: http://en.wikipedia.org/wiki/Free_will_theorem
11:43:59 <shapr> I think I've seen Alson Kemp here before.
11:46:04 <DeliQ> can i use filter to filter out the Not's in this list [Not (Var 'B'),Not (Var 'C'),Not (Var 'D'),Not (Var 'A'),Var 'B',Var 'C'] ?
11:46:47 <int-e> filter (\a -> case a of Not _ -> False; otherwise -> True) <list>
11:47:00 <DeliQ> thanks!
11:47:19 <int-e> but you should probably make that predicate a separate function, say, isNot (Not _) = True; isNot _ = False
11:47:35 <DeliQ> i get it!
11:47:39 <int-e> because the code is hard to read otherwise.
11:48:31 <sjanssen_> > do { x@(Just _) <- [Nothing, Just 3, Just 2, Nothing]; return x }
11:48:32 <lambdabot> [Just 3,Just 2]
11:48:34 <xerox> DeliQ: deNot xs = [ x | Not x <- xs ]
11:49:44 <int-e> argh. I keep forgetting about the error handling of the list comprehension (and monad)
11:49:54 <xerox> (-:
11:51:43 <nomeata> dcoutts: I need a quick tipp with GConf:
11:51:51 <nomeata> I want to write "gconfNotifyAdd ?gconf (gconfRoot++"/host")     updateValues"
11:52:04 <xerox> Uh-oh, implicit parameters!
11:52:13 <dcoutts_> nomeata, ok
11:52:15 <nomeata> but not care about updateValues parameters, so I write updateValues _ _ = updateValues'
11:52:45 <nomeata> dcoutts: then ghc complains about ambigous types or something
11:53:01 <nomeata>     Ambiguous type variable `value' in the constraint:      `GConfValueClass value'
11:53:29 <nomeata> I tried adding 	let updateValues _ (GConfValueString _) = updateValues'
11:53:31 <nomeata> 	let updateValues _ (GConfValueBool _)   = updateValues'
11:53:33 <nomeata> 	let updateValues _ (GConfValueList _)   = updateValues' ...
11:54:01 <nomeata> for all GConvValue.... I could find, but when I then change an parameter from within gconf-editor, I get an "unexthausive pattern"
11:55:09 <dcoutts_> nomeata, nonexhaustive pattern in your code or elsewhere?
11:55:19 <dcoutts_> the ghci errro will tell you exactly the line number
11:55:38 <nomeata> dcoutts: in the last of the let updateValues _ (GConfValueList _)   = updateValues' lines
11:55:53 * nomeata has an idea
11:56:07 <dcoutts_> nomeata, of course if you don't care about the type of the value then don't do the pattern matching
11:56:33 <dcoutts_> oh, hmm
11:56:49 <dcoutts_> but you want to be notified of the change, just not get the actual value?
11:56:50 <nomeata> I found it: I should use only one "let" for all of them
11:56:59 <dcoutts_> yes
11:57:05 <nomeata> dcoutts: right, I just update all values anyways, for simplicitiy's sake
11:57:16 <nomeata> but using _ _ caused in unambigous type errors
11:57:26 <dcoutts_> you could disambiguate
11:57:40 <nomeata> how exactly?
11:58:00 <dcoutts_> (_ :: GConfValueDyn)
11:59:35 <nomeata> thx, that works
11:59:46 <dcoutts_> or if you know the key has some other value: (_ :: Maybe Int)
11:59:59 <nomeata> no, I'll used that for all types
12:00:02 <dcoutts_> or if you could use onValueChanged
12:00:17 <nomeata> Does that provide the same functionality?
12:00:21 <dcoutts_> if you're doing the same for every key you're watching
12:00:41 <nomeata> ok, nice. it wasn't documented, so I didn't use it, but that sounds good.
12:00:53 <dcoutts_> the gconfNotifyadd allows you to watch just one path (recursively)
12:00:54 <nomeata> (for any key in my watched directories, I guess)
12:01:14 <dcoutts_> the other gives you a notification for everying you're watching
12:02:35 <dcoutts_> nomeata, the gconf demo program demos both (I think)
12:02:47 <nomeata>     Ambiguous occurrence `onValueChanged'
12:02:48 <nomeata>     It could refer to either `Graphics.UI.Gtk.Misc.Adjustment.onValueChanged', imported from Graphics.UI.Gtk at tutdb.hs:4:0-58
12:02:48 <nomeata>                           or `System.Gnome.GConf.GConfClient.onValueChanged', imported from System.Gnome.GConf at tutdb.hs:6:0-24
12:03:20 <dcoutts_> mmm, you'll have to specify which one as we seem to have a name clash
12:03:28 <nomeata> how do I do that?
12:03:37 <dcoutts_> use the fully qualified name
12:03:51 <nomeata> System.Gnome.GConf.GConfClient.onValueChanged ?
12:03:54 <dcoutts_> yep
12:04:39 <nomeata> thanks, works
12:06:22 <nomeata> I'm having problems reading the bool value, though:
12:06:28 <nomeata> gconfGet ?gconf (gconfRoot++"/sql")      >>= (toggleButtonSetActive ssl).bool -- is how I read it
12:07:08 <nomeata> bool :: GConfValueDyn -> Bool
12:07:08 <nomeata> bool (GConfValueBool b) = b
12:07:18 <nomeata> ah, I guess you see it already
12:07:30 <nomeata> /sql /= ssl :-)
12:18:57 <nomeata> can I mark labeled fields as optional, to get around the     Warning: Fields of `SQL' not initialised: mpid    warning?
12:21:05 <norpan> if they are optional, maybe the type of them should reflect that?
12:21:50 <nomeata> are you suggesting to use Maybe? well, I just want to avid typing all of them. after all it works, I just want the warning to go away :-)
12:22:01 <nomeata> hmm. can I specify defaults?
12:22:04 <mauke> eh, just make a default value
12:22:36 <norpan> you can specify defaults by having a default value and updating it
12:23:37 <nomeata> where do I specify a default value? In the type definition?
12:23:53 <mauke> no, in the value definition
12:24:34 <norpan> just create a value
12:25:05 <norpan> data A = A { x: Int, y: String }; defaultA = A { x = 2, y = "hello }
12:25:18 <norpan> then use defaultA { x = 3 }
12:25:49 <nomeata> I see, I create a function that fills the object with defaults first
12:26:37 <mauke> function?
12:28:23 <nomeata> true, it's not a function.
12:29:42 <palomer> object?
12:30:15 <davidhouse> does that kind of record-updating syntax work?
12:32:45 <norpan> sure
12:33:45 <norpan> otherwise I wouldn't have written it
12:33:52 <norpan> :: for types though
12:53:43 <tibbe> is there a separate channel for GHC somewhere?
12:54:39 <davidhouse> @docs System.Console.GetOpt
12:54:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
12:58:50 <xerox> http://sketchup.google.com/3dwarehouse/
12:59:13 <shapr> akemp: hiya!
12:59:24 <shapr> akemp: do you have time to talk about cabal-get?
12:59:36 <shapr> xerox: If only it ran on linux :-/
12:59:51 <xerox> :-\
13:00:07 <shapr> Man, Findus makes the world's best frozen pyttipana
13:00:21 <xerox> Pyttipana you say...
13:00:34 <psi> :D
13:00:40 <sieni> what a hybrid name
13:00:56 <shapr> :-P
13:01:11 <sieni> I thought it was "pytt i panna" pÂ svenska och "pyttipannu" pÂ finska
13:01:30 * xerox stickes an Orwell note onto sketchup and goes on.
13:01:49 <shapr> sieni: I shuttled back and forth between the two countries!
13:01:58 <kolmodin> http://en.wikipedia.org/wiki/Pyttipanna
13:01:58 <xerox> p√• you say...
13:02:00 <kolmodin> :)
13:02:24 <shapr> p√•
13:02:26 <shapr> whee
13:02:55 <sieni> a.k.a. "spyd‰ri" in finnish slang
13:03:05 <shapr> I thought it was Finnish.
13:03:13 <sieni> and yes, it _is_ perfect for hangovers
13:03:14 <xerox> You did!
13:03:16 <ValarQ> pyttipanna is ok, in lack of kroppkakor :)
13:04:11 <sieni> shapr: well, pyttipanna, pea soup and glˆgg are clearly imports from sweden to finland :-)
13:04:12 <psi> palt ;)
13:04:31 <ValarQ> psi!
13:04:40 <shapr> What about salmiakki?
13:05:14 <ValarQ> psi: am i allowed to enter #unix.se yet?
13:05:24 <shapr> ValarQ: Did you get banned?
13:05:54 <ValarQ> shapr: yeah, i used UTF-8
13:06:04 <shapr> That's a funny reason to be banned.
13:06:13 <sieni> shapr: http://en.wikipedia.org/wiki/Salmiakki
13:06:29 <psi> if jagular kicked you out, he was only joking :)
13:06:30 <xerox> Wikipedia has everything.
13:06:57 <psi> were you really banned?
13:07:20 <jcreigh> xerox: Including: http://en.wikipedia.org/wiki/Kitchen_Sink
13:07:27 <sieni> ValarQ: that's funny, there have been lots of holy wars about The Proper Charset on Finnish channels on ircnet and the result has been inconclusive so far (i.e. many using iso 8859-1/8859-15 and others using utf-8)
13:07:38 <ValarQ> psi: dunno, i haven't entered #unix.se since he kicked me
13:08:00 <psi> sieni: most swedish channels have the same battle :)
13:08:21 <ValarQ> a bit calmer now that many clients handles recoding
13:08:58 <davidhouse> @index argv
13:08:59 <lambdabot> bzzt
13:09:02 <psi> I wonder if rcirc does it. iirc it doesn't.
13:09:06 <davidhouse> oh, it's getArgs :) oops
13:09:46 <monochrom> It is really a holy war on "I want to continue to use my 19th century irc client"
13:09:52 <monochrom> or xterm
13:09:59 <shapr> I think I'm going to create a finnish & swedish channel and enforce EBCDIC.
13:10:07 <dcoutts> hah
13:10:14 <xerox> jcreigh: o_O
13:14:05 <shapr> Am I a heretic for wanting to shoot down other planes in FlightGear?
13:14:29 <monochrom> No. Everyone wants to shoot down other planes.
13:14:29 <lispy> shapr: heh
13:14:54 <shapr> Is there some way to do that?
13:15:30 <monochrom> I don't know.
13:15:31 <davidhouse> @index liftM
13:15:31 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:15:42 <ChilliX> shapr: lol
13:16:55 <davidhouse> what's the shortcut function for \a -> find (==a)
13:17:13 <monochrom> @index find
13:17:14 <lambdabot> Data.List
13:17:20 <monochrom> @type find
13:17:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:17:34 <davidhouse> @hoogle a -> [a] -> Maybe a
13:17:34 <lambdabot> No matches, try a more general search
13:17:39 <shapr> ChilliX: Is that a yes? People are discouraged from adding code to shoot down others in multiplayer?
13:18:07 <lispy> @pl \a -> find (==a)
13:18:09 <lambdabot> find . (==)
13:18:25 <monochrom> Perhaps it is politically incorrect to suggest shooting down planes.
13:18:57 <ChilliX> shapr: I play CounterStrike, does that answer the question? ;)
13:19:10 <davidhouse> ah, i think i'm thinking of elemIndex, which is the equivalent to findIndex . (==)
13:19:12 <shapr> hah
13:19:17 <lispy> "Terrorists win."
13:19:18 <shapr> I used to play CS.
13:19:27 <ChilliX> I am all for peceful co-existance in meatspace.
13:19:34 <ChilliX> peaceful, even
13:19:41 <ChilliX> but games are games
13:20:00 <shapr> ChilliX: Tried America's Army?
13:20:13 <ChilliX> nope
13:20:18 <shapr> It's quite nifty.
13:20:20 <ChilliX> you?
13:20:22 <palomer> hrmph, looks like I have to give up ST for State
13:20:24 <palomer> shucks
13:20:35 <shapr> The special forces sniper rifle is the most addictive experience ever.
13:20:47 <palomer> or even Reader
13:20:57 <lispy> @palomer
13:20:58 <lambdabot> blargh!
13:21:03 <monochrom> haha
13:21:10 <ChilliX> shapr: haha - and you ask whether you should feel bad about wanting to shoot down some planes... ;)
13:21:11 <lispy> palomer: :)
13:21:18 <palomer> :(|)
13:21:28 <lispy> @type :(|)
13:21:30 <lambdabot> parse error on input `:'
13:21:47 <shapr> I just wonder because I can't find any info on how to fire the weapons on the P-51d, A-10 Warthog, etc.
13:21:49 <monochrom> not all emoticons are typable.
13:21:56 <lispy> heh, is parser error equivalent to _|_?
13:22:05 <jcreigh> @pl flip
13:22:05 <lambdabot> flip
13:22:10 <shapr> I *really* want to know how an A-10 reacts to firing the GAU-12 Avenger while flying.
13:22:14 <ChilliX> oh, ic - even google doesn't know?
13:22:25 <monochrom> I would lump all errors to ‚ä•
13:22:42 <jcreigh> @pl flip a b
13:22:42 <lambdabot> flip a b
13:22:46 <jcreigh> Hmm....
13:22:52 <shapr> I read somewhere that continuous firing can make the plane fly backwards.
13:22:59 <davidhouse> @pl \a b -> flip a b
13:22:59 <lambdabot> flip
13:23:00 <lispy> @pl \a -> flip a
13:23:01 <lambdabot> flip
13:23:12 <lispy> @pl \a b -> flip b a
13:23:13 <lambdabot> flip flip
13:23:38 <monochrom> In a simple flight simulator, possibly.
13:23:40 <shapr> ChilliX: It's hard to google for a game named 'flightgear'
13:24:08 <ChilliX> oh, yes, I guess so
13:24:39 <shapr> Hey, what's the likelihood of getting a Parr that does GHC-SMP?
13:25:08 <akemp_> shapr: hey ya
13:25:11 <jcreigh> @pl \f -> (\a b -> f b a)
13:25:12 <lambdabot> flip
13:25:15 <jcreigh> clever
13:25:16 <shapr> akemp_: greetings!
13:25:17 <dcoutts> shapr, Parr? you don't mean 'par'
13:25:23 <dcoutts> @type par
13:25:25 <lambdabot> Not in scope: `par'
13:25:27 <akemp_> Shapr: shhhh!  I'm at work.  
13:25:30 <dcoutts> @hoogle par
13:25:31 <shapr> @hoogle Parr
13:25:31 <lambdabot> Control.Parallel.par :: a -> b -> b
13:25:31 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
13:25:31 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
13:25:31 <lambdabot> Data.Array.MArray.mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
13:25:32 <ChilliX> That's what http://www.cse.unsw.edu.au/~chak/project/dph/ is all about.
13:25:52 <shapr> dcoutts: Nah, I mean ChilliX's nested data parallel arrays project.
13:25:57 <dcoutts> ah
13:25:59 <akemp_> shapr: I got cabal-get to build and install from the Cabal tree.
13:26:04 <shapr> Cool
13:26:11 <akemp_> It's a hack, but it works.
13:26:22 <ChilliX> We started last month
13:26:28 * lispy wonders why darcs doesn't build from cabal
13:26:41 <lispy> seems like that would be at least mildly useful
13:26:42 <akemp_> The source (unclean) is at http://alsonkemp.dyndns.org/Cabal 
13:26:45 <shapr> ChilliX: Anything new & interesting I can post to LtU?
13:26:53 <shapr> akemp_: I'll grab it.
13:27:23 <akemp_> Warning: it's unclean and un-darcized.  I'll fix that up this evening.  (It doesn't look good for BusDev people to code Haskell at work...)
13:27:36 <shapr> BusDev?
13:27:37 <ChilliX> shapr: Seen http://www.cse.unsw.edu.au/~chak/papers/SCP06.html ?
13:27:45 <akemp_> Business Development
13:28:02 <shapr> oh
13:28:15 <ChilliX> This is going to be the next GHC IL
13:28:30 <akemp_> shapr: enjoy.  I'd appreciate your comments.  Seeya on e-mail.
13:28:38 <shapr> akemp_: ok, seeya
13:29:09 <lispy> akemp_: yeah, i find haskell as a closet programming language for indusry types
13:29:13 <shapr> I'm gonna have to read this through a few times.
13:29:24 <jcreigh> shapr: Wikipedia says "no" on the A-10 flying backwards: http://en.wikipedia.org/wiki/A-10#Trivia
13:29:27 <shapr> My System Fu is low.
13:30:45 <ChilliX> The first two sections are completely Non-Scary.
13:31:17 <ChilliX> and give you all the important intuitions.
13:31:42 <davidhouse> hmm.
13:31:48 <davidhouse> i need a nicer function than this:
13:31:58 <davidhouse> any (\c -> case c of (Search _) -> True; _ -> False) flags
13:32:19 <gaal> hey, remind me. with parsec, how do I peek at the current char without consuming it?
13:32:22 <davidhouse> it's the stupid type of Search that makes it a pain. Search :: [String] -> Flag
13:33:22 <davidhouse> we could really do with a type of patterns in haskell.
13:33:34 <shapr> jcreigh: Nifty
13:33:35 <davidhouse> then i'd do something like mkPat (Search _) `elem` flags
13:33:56 <shapr> ChilliX: Ok, I'll read it. btw, have you read the recent Yong Luo draft paper?
13:33:57 <monochrom> I think any (\c -> case c of (Search _) -> True; _ -> False) flags is just fine.
13:34:13 <shapr> ChilliX: Is there some forum where type theorists hang around and chat?
13:34:29 <ChilliX> There is the types mailing list.
13:34:38 <lispy> @pl \c -> case c of (Search _) -> True; _ -> False
13:34:39 <lambdabot> (line 1, column 25):
13:34:39 <lambdabot> unexpected "_"
13:34:39 <lambdabot> expecting variable, "(", operator or ")"
13:34:46 <lispy> @pl (\c -> case c of (Search _) -> True; _ -> False)
13:34:47 <lambdabot> (line 1, column 26):
13:34:47 <lambdabot> unexpected "_"
13:34:47 <lambdabot> expecting variable, "(", operator or ")"
13:34:52 <shapr> Yeah, but that list is pretty quiet.
13:34:53 <lispy> hmm...
13:34:57 <ChilliX> http://lists.seas.upenn.edu/mailman/listinfo/types-list
13:35:01 <shapr> I want something more like the LtU website.
13:35:09 <shapr> But without all the C weenies.
13:35:12 <davidhouse> lispy: apparently, @pl can't do patterns.
13:35:24 <ChilliX> hmm, not that I know of
13:35:31 <ChilliX> would be cool, though
13:35:33 <shapr> Maybe I should create it.
13:35:39 <ChilliX> :)
13:35:49 <lispy> davidhouse: hm...i thought it was the semicolon
13:36:14 <davidhouse> @pl \c -> case c of { (Search _) -> True; _ -> False }
13:36:14 <lambdabot> (line 1, column 17):
13:36:14 <lambdabot> unexpected "{"
13:36:14 <lambdabot> expecting variable, "(", operator or end of input
13:36:21 <davidhouse> nope.
13:36:28 <ChilliX> sharpr: re Yong Luo has a brief look
13:36:55 <ChilliX> shapr: we are going towards having partial type functions anyway it seems
13:37:02 <shapr> Yeah, it seems so.
13:37:11 <shapr> At least it'll make type slicing easier.
13:38:09 <monochrom> gaal: lookAhead
13:38:31 <ChilliX> A nice thing about System FC (the paper I just gave you) is that you can translate full top-level type functions with it in a type-preserving compiler.
13:38:52 <ChilliX> Associated types are just a kind of special case.
13:39:11 <ChilliX> As are functional dependencies.
13:39:25 <ChilliX> and GADTs for that matter
13:39:26 <shapr> I like associated types.
13:39:33 <ChilliX> :)
13:39:35 <shapr> They allow for a zillion nifty tricks.
13:40:14 <ChilliX> Yep, and as soon as GHC has moved over to System FC, we'll get them in GHC, finally.
13:40:28 <lispy> associated types?
13:40:39 <dcoutts> xerox, how hard is it to set up new Trac instances? like you did for SoC?
13:40:52 <Cale_> wow, of the 15 "Expert" rated puzzles this book of nurikabe, only 4 are unique. Three are repeated 4 times, and the other is repeated three.
13:41:11 <ChilliX> lispy: type declarations in type classes
13:41:12 <xerox> dcoutts: SyntaxNinja is administering, in fact.  But I don't think it's very difficult.
13:41:26 <lispy> dcoutts: i tried to set it up on a debian AMD64 system and i had a lot of trouble...gave up actually.  Seems that maybe my python was broken and setting up svn repos is a pane
13:41:28 <lispy> er pain
13:41:28 <dcoutts> xerox, good, I was thinking of asking for one for gtk2hs
13:41:30 <gaal> monochrom: thanks!
13:41:32 <davidhouse> what's the library i would use to make a shell command, then collect its output?
13:41:40 <xerox> dcoutts: it works quite well.
13:42:18 <lispy> is anyone else following the thread on haskell-cafe about global io refs?
13:42:36 <tibbe> lispy, I've read some of it
13:42:55 <lispy> that's a hot little topic (as in flamey hot)
13:43:19 <monochrom> davidhouse: System.Posix.Process
13:43:31 <tibbe> I thought Lennart's comment about his usb drivers was funny (he was my teacher in an adv. func. prog. course)
13:43:46 <lispy> tibbe: heh
13:44:06 <monochrom> davidhouse: actually System.Process
13:44:16 <lispy> i always try to read John Meacham's responses.  They often contain gems
13:44:16 <davidhouse> yeah, System.Process is the one i remember. thanks.
13:44:31 <ChilliX> shapr: btw, re nested data parallelism, package ndp (http://darcs.haskell.org/packages/ndp/) already implements all the functionality the old parr library did, but uses GADTs to simulate associated types (instead of the old mess with functional dependecies)
13:45:42 <ChilliX> that's purely sequential atm, but the goal is to have that running with GHC-SMP within the next month or so
13:49:16 <xerox> http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf (from GHC-users ml.)
13:51:43 <xerox> A Language-based Approach to Unifying Events and Threads
13:52:06 <ChilliX> xerox: looks pretty cool
14:20:50 <ct16k> hy there! is anyone willing to provide some assistance? :)
14:22:10 <Lemmih> ct16k: Sure.
14:22:56 <ct16k> thx. I'm having a really hard time getting around the IO part :( (I'm pasting the code now)
14:22:58 <lisppaste2> ct16k annotated #18977 with "Type error in application" at http://paste.lisp.org/display/18977#3
14:23:26 <ct16k> I do know&understand what's causing the error, I just don't know how to avoid it
14:23:27 <ct16k> :">
14:24:23 <Lemmih> ct16k: '<-' is only used to bind monadic actions.
14:25:02 <davidhouse> ct16k: look at the types for your expressions. if they don't end in "IO something", then don't use <-.
14:25:04 <Lemmih> ct16k: So, 'hFile <- openFile ...' is OK, but 'strs <- words (hGetContents hFile)' isn't.
14:25:46 <davidhouse> basically, a <- takes an IO something and removes the IO part.
14:25:47 <ct16k> I don't remember that being mentioned in class....
14:25:58 <davidhouse> (you'll understand what it really does when you cover monads)
14:26:43 <davidhouse> @index FileName
14:26:43 <lambdabot> bzzt
14:26:44 <Lemmih> ct16k: How about something like: 'fileContents <- readFile name; let {strs = words fileContents}; ...'?
14:28:14 <ct16k> i'll try that
14:28:55 <davidhouse> ct16k: also, if you're doing IO actions in initWorld, you're going to have to make the type String -> IO World
14:29:24 <davidhouse> you can think of the IO bit as a tag that says "this function might have side effects".
14:34:32 <davidhouse> does Text.Regex deal with PCREs or unix regexs?
14:35:15 <ct16k> well, i replaced the <-s with lets, but how about the call to showWorld? winhugs expects it to be (Int,Int,Set (Int,Int)), but it finds (Int,[Int] -> [Int],Set (Int,Int))... where's the error in that?
14:37:25 <ct16k> oups... my bad... i was calling max instead of maximum...
14:50:36 <mahogny> xerox, will the application be pending for long? just filled in the first step
14:51:38 <xerox> Ah, I just send out an email asking to fill it, thanks.
14:51:44 <xerox> Answer: dunno.
14:52:15 <lispy> is it just me, or is there a problem with the 'managing multiple windows' example on this page: http://www.haskell.org/hawiki/WxHaskell
14:52:39 <lispy> basically they say, so you're doing x, but you should do y.  But, it appears that x == y
14:54:32 <mahogny> lispy, the solve it the way I solve it. I don't see a problem :)
14:54:33 <Igloo> lispy: One of them is almost certainly type incorrect
14:55:03 <mahogny> why?
14:55:23 <lispy> set paramsButton [ on command := do createParamsWindow updateMainWindow ] looks the same as the two line version to me.. What am I missing?
14:55:25 <Igloo> Because createParamsWindow takes a parameter in one and not the other
14:55:49 <mahogny> it's not the same type in the two examples
14:55:56 <mahogny> in the second case, they pass a callback function
14:56:04 <davidhouse> lispy: remember whitespace matters.
14:56:11 <Igloo> Oh, you mean there are two different createParamsWindow functions?
14:56:18 <mahogny> yes. the latter is the way to go
14:56:32 <davidhouse> Igloo: they're saying "redesign createParamsWindow so it takes a callback"
14:56:43 <Igloo> Ah, OK
14:57:00 <lispy> hmm...that's not easy to see :)
14:57:13 <mahogny> this is somewhat messy due to the monads. I'd like to see a more structured way to deal with this. maybe I code something one day :P
14:57:16 <lispy> i didn't even think about the whitespace mattering
15:00:13 <dcoutts> I hope everyone is reading this new paper "A Language Based Approach to Unifying Events and Threads"
15:00:14 <dcoutts> http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf
15:00:23 <dcoutts> it's quite good so far
15:00:55 <dcoutts> you always knew that events and threads were really the same thing, see how...
15:01:17 <xerox> dcoutts: I just pasted it too, yay (-:
15:01:24 <dcoutts> I'm hoping for some inspiration for coding with GUIs (which are event systems)
15:01:41 <dcoutts> xerox, oh good (sorry I missed that)
15:02:14 <dcoutts> and it gives a good motivating example for the CPS monad
15:08:47 <stepcut> dcoutts: interesting... I am reading that paper -- for the same reason :p
15:09:17 <dcoutts> stepcut, :-)
15:10:16 <mahogny> that paper doesn't add much. looks like something I already have implemented as a simple scripting language :P but I like their benchmarks. has really no one does this before? I remember going from "the lazy mans concurrency" or a similar article name
15:10:26 <mahogny> *done
15:11:20 <mahogny> think it was someone at chalmers who wrote it. Koen maybe
15:13:27 <mahogny> I wish they had made a benchmark on a multicored cpu vs several cpus
15:19:00 * SamB wonders what might use Xlib.h that he can use to see if it works for C programs.
15:20:03 <mahogny> what are you working on?
15:20:33 <sethk> SamB, about a million X programs and utilities
15:20:37 <SamB> nothing, really. Its just that the X11 package won't build
15:20:41 <lispy> mahogny: i read that as "multicolored cpu" and went off for a few minutes confused....
15:20:47 <mahogny> lol
15:20:51 <SamB> sethk: point.
15:21:29 <SamB> sethk: what is a nice small one?
15:22:00 <sethk> SamB, something like xev, perhaps
15:22:33 <sethk> SamB, xwininfo
15:22:40 <sethk> SamB, a small utility like that
15:26:51 <fons> hi
15:27:08 <fons> can anyone tell me where can I find information about records in haskell?
15:28:03 <fons> I never used them, but they do in a library I'm using
15:28:25 <lispy> fons: the haskell wiki has some records examples, let me see if i can find anything...
15:28:50 <lispy> fons: http://www.haskell.org/hawiki/UsingRecords
15:29:19 <fons> thanks
15:29:20 <fons> :)
15:29:24 <lispy> np
15:29:43 <lispy> although i might warn you that's the 'old' wiki
15:30:02 <lispy> so if you want to edit it, try to move the content first :)
15:30:15 <KydoC> how do you get around the porblem of records all sharing the same namespace?
15:31:01 <sjanssen> KydoC: you don't, they share the same namespace
15:31:34 <int-e> you can define the records in different modules
15:31:36 * int-e shrugs
15:32:02 <KydoC> sjanssen: so do you either not use them, or write a bunch of DogName PersonName XName type records?
15:32:06 <sjanssen> KydoC: yeah, what int-e said, use several modules for each data type then use qualified imports
15:32:33 <sjanssen> records are often called a deficiency of Haskell
15:33:25 <mahogny> the functions haskell generates from records are sometimes messy. you have to prefix them manually to make the names sane
15:33:49 <Cale_> Haskell doesn't really have proper records. Haskell's types are all algebraic data types, and there's a record-like sugar on top of that.
15:34:11 <mahogny> someone stole (.) for the wrong thing. they would have been excellent in this case :)
15:34:29 <Cale_> (.) for composition is great though
15:34:36 <mahogny> I never use it in practice
15:34:43 <Cale_> I use it all the time
15:34:43 <KydoC> why not o
15:34:54 <int-e> there are only 95 ASCII characters and most of them are letters and digits ...
15:34:54 <KydoC> or is that ML treason?
15:34:56 <mahogny> the few cases I need (.), I use my chain function instead
15:34:56 <int-e> o is a letter
15:35:12 <mahogny> o is a quite common name as well :P
15:35:14 <Cale_> o is not a valid name for an infix operator, you could use `o`, but that looks awkward
15:35:41 <mahogny> can haskell code be in unicode?
15:35:51 <mahogny> in that case, lets make some decent use of the windows key or something :)
15:36:30 <Cale_> the standard says yes, but so far, hugs' support is minimal, and the release GHC has no support for it
15:36:39 <Cale_> (though the CVS ghc does now)
15:37:25 <Cale_> It would be really nice to be able to use a proper circle operator for it.
15:37:43 <Cale_> Though if that was the only way to type it, I think it would be a shame.
15:37:45 <int-e> hmm. But I
15:37:53 <int-e> 'd still like being able to code in pure ASCII.
15:37:57 <Cale_> yeah
15:38:04 <davidmccabe> Hello.
15:38:15 <KydoC> otherwise you've got APL
15:38:20 <sjanssen> @id /me says hello
15:38:20 * lambdabot says hello
15:38:29 <Cale_> Using (.) as a hierarchy separator is overrated anyway 
15:38:37 <Cale_> there's lots of other reasonable things to use
15:38:50 <mahogny> better to use the most common ones though
15:38:57 <Philippa_> there aren't many that're similarly unobtrusive and aren't in use for other things
15:39:01 <davidmccabe> Concerning the Summer of Code, are beginners at Haskell welcome? Is there any chance for a proposal to first learn enough Haskell to do the project, and then do the project?
15:39:15 <Cale_> And we are using it as a module separator, though that's possibly unwise.
15:39:23 <Philippa_> ' might be an option if it weren't in use both for characters and to "prime" identifiers
15:39:59 <mahogny> davidmccabe, I think it is good if you have basic grasp of haskell at least before SoC. but you can always start now :)
15:40:09 <davidmccabe> mahogny: I started about a month ago.
15:40:19 <mahogny> well, xerox is the guy to ask
15:40:19 <Cale_> | with no whitespace allowed on either side is probably possible.
15:40:29 <sjanssen> I wonder if we could use -> ?
15:40:32 <mahogny> Cale, my I shoots you
15:40:33 <davidmccabe> mahogny: I have a basic grasp of it, but I haven't written any substantial code in it before.
15:40:42 <Cale_> mahogny: hm?
15:40:49 <mahogny> Cale, ie it looks like other letters
15:40:50 <Cale_> Data|Set|insert
15:40:58 <Cale_> looks good to me :)
15:41:11 <KydoC> DataISet
15:41:17 <mahogny> without whitespace, I think it would be suicidal
15:41:35 <mahogny> the same way the letter l is banned
15:41:37 <Cale_> Nobody should be coding in a font where I and | or l look anything alike.
15:41:43 <davidmccabe> How about: DataSepSetSepInsert, if we're going for inscrutability.
15:41:51 <int-e> | is good, unless your font has trouble distinguishing 1|l...
15:42:02 <mahogny> Cale, times new roman is no good? :(
15:42:08 <sethk> Cale_, in the library haddock docs, it is almost impossible to distinguish ! from |
15:42:11 <Cale_> mahogny: Andale Mono
15:42:13 <int-e> I, right.
15:42:19 <int-e> mahogny: no.
15:42:22 <Cale_> mahogny: Or Courier
15:42:32 <mahogny> anyhow. minor pixel differences aren't enough, and haskell should not make system requirements on fonts :P
15:42:34 <davidmccabe> Cale_: It's one thing to be able to see the separators. It's another thing to have the separate tokens look obviously visually separate.
15:42:39 <sjanssen> mahogny: variable width font for programming?
15:42:44 <mahogny> sjanssen, jk :)
15:42:48 <Cale_> Times New Roman is also variable width, which is awful.
15:43:04 <fons> anyone with experience using parsec?
15:43:18 * int-e thinks | is an interesting candidate
15:43:25 * mahogny is. but he is about to goto bed;
15:43:25 <int-e> -> probably appeals to C coders.
15:43:37 <mahogny> int-e, not the least :)
15:43:58 <davidmccabe> Oh, I had one other question. We have imperative languages and declarative languages, right? Well, my question is, is anyone doing research on an INTERROGATIVE programming language?
15:44:26 <KydoC> why would you do that
15:44:55 <sjanssen> Computer, would you please add these two numbers?
15:44:55 <KydoC> hrm?  why would you?  we have ways of making you talk . . 
15:44:57 <davidmccabe> KydoC: I should think the benefits of an interrogative language would be immediately obvious.
15:45:25 <KydoC> joke
15:46:17 <mahogny> davidmccabe, try smalltalk
15:46:31 <KydoC> prolog has a kinda interrogative feel
15:47:20 <davidmccabe> So, I hope you don't mind me reasking this question,
15:47:47 <davidmccabe> I have a very basic grasp of Haskell. I have not really done any coding in it. Would it be at all reasonable to try to learn more as I go along with a SoC project?
15:47:58 <davidmccabe> Is it even worth applying, or will you be swamped with PhD students?
15:48:13 <mahogny> I think the most interesting students are not phd's
15:48:25 <mahogny> anyhow. I think you have a chance
15:48:42 <davidmccabe> I hope you can understand my apprehension about all this.
15:49:18 <sjanssen> what about ~> for a namespace separator?
15:49:41 <sjanssen> ponder that, I've got to go
15:49:44 <davidmccabe> Data~>Set~>insert
15:49:54 <int-e> ~> looks ugly in many fonts
15:50:18 <davidmccabe> Well, we're prescribing official haskell-compatible fonts now; didn't you hear?
15:50:57 <int-e> no, all I want to prescribe is that the characters are easily distinguishable.
15:51:12 <int-e> hehe. well, maybe that is comparable.
16:10:51 <stepcut> Any idea why the mailing list software for Haskell-cafe does not include a link to the archived version of a specific message in the headers?
16:27:01 <SamB> stepcut: that sounds like a mailman question to me
16:31:39 <work_metaperl> stepcut: arent you a schemer?
16:34:41 <araujo> Hiya!
17:00:04 <SamB> hmm, the X11 package is not the only thing that will not build with this Xlib.h
17:00:26 <SamB> (X11 package in fptools, that is)
17:27:34 <dons> moin
17:35:03 <olliej> hiya dons
17:50:12 <dcoutts> oh yeah
17:51:18 <dcoutts> using kolmodin's new linux inotify bindings and gtk2hs's new custom tree model feature, I've written a custom tree model backed by a directory with live updates and all in less than 100 lines. :-)
17:51:25 <Lokadin> cls
17:51:54 <dcoutts> and it didn't take too long to write either :-)
17:52:06 <dcoutts> it uses a Data.Map for the cache
17:52:28 <dcoutts> and then updates it's cache whenever we get a file system change event via inotify
17:52:47 <dcoutts> (at which point we also notify the view that the model has changed)
17:53:21 <Lokadin> oops
17:53:37 <dcoutts> the inotify + cache update + view update notification bit is only 15 lines or so
17:53:55 * dcoutts goes to bed
17:56:16 <lispy> dcoutts: that sounds really nice
18:02:44 <sethk> dons, I had a sort of serious bug report today, but I just fixed it, it's in the device driver I wrote which is in C  :)
18:03:08 <sethk> dons, so the haskell code is still without a serious problem
18:12:37 <dons> that's good news. I'd really like to give you a tutorial on QuickCheck at some point too.
18:30:24 <sethk> any time you want to do it, I'm available
18:34:46 <Pawer> hi
18:35:49 <dons> sethk, probably if you had some code that needed testing. i.e. a library of pure functions perhaps? I could show you how to write down the invariants , and check against a model, using QC.
18:37:01 <sethk> dons, ok.  I don't have things separated out by pure vs. IO, but I'll take a look and see if there are enough pure functions to make a useful set.
18:37:57 <dons> we can also test impure stuff. its just easier to test pure functions. (
18:39:09 <dons> e.g. for my packed string code, I have: prop_sort2 xs = (not (null xs)) ==> (P.head . P.sort . pack $ xs) == minimum xs
18:39:50 <dons> so a property relating 'sort' to 'minimum'. this is obviously easier to specify for functions, than side effecting code.
18:40:27 <dons> in general I would say, if you have side effects, you need to do black box testing of the whole unit. individual properties are harder to specify.
18:42:27 <sethk> dons, my code with this current project is i/o intensive, as you know.
18:42:53 <sethk> dons, but let me look through it, I haven't really gone through it to see how much pure code there is.
18:44:08 <dons> right. this is harder then. I guess you have some kind of testsuite set up anyway?
18:44:54 <sethk> dons, no, not really, because to do that I would have had to build a hardware simulator
18:45:07 <sethk> dons, with the time constraints, there just wasn't time.  I test on the hardware
18:45:26 <sethk> dons, I've written programs to verify that the hardware is programmed correctly, and things of that sort
18:46:19 <sethk> dons, I have a pile of four port and eight port router/firewalls next to my desk  :)
18:46:32 <dons> ah right. hmm. just trying to think of more ways for you to avoid bugs before they happen.
18:47:28 <sethk> indeed, as am I
18:47:43 <sethk> it isn't a trivial problem, and working with new device drivers makes it much harder
18:47:57 <sethk> because you can't even assume that the infrastructure is correct
18:49:33 <araujo> Hi!
18:54:05 <dons> sethk: yeah, I see that. very interesting problem
18:56:50 <sethk> I'll have to look at house at some point, and see how they handled writing to memory mapped hardware and to i/o ports
18:57:09 <lispy> anyone up for a beer?
18:57:25 <sethk> lispy, sure, send it up
18:57:29 <lispy> hehe
18:57:42 <lispy> sethk: k, might be warm when it gets there, my modem is kinda slow :)
18:58:34 <sethk> lispy, warm beer and cold women, I'm used to it
18:58:39 <lispy> heh
18:58:42 <dons> hehe
18:58:58 <Korollary> That's how entropy works tho
19:03:29 <araujo> haha
19:05:23 <Philippa_> you mean, you give us beer and we warm up?
19:06:34 <lispy> most girls i know will drink just about any alcohol but beer
19:07:05 <lispy> even here in Oregon (probably the best place in the US to get mircrobrew)
19:07:52 <araujo> Philippa_, sounds like a good deal
19:07:59 * araujo hides
19:08:49 <Philippa_> yeah, I've been handing my new housemate a bit of the ales I'm drinking when we hit a pub but she's mostly sticking to other stuff. She likes cider though
19:09:24 <Philippa_> araujo: problem is enough beer means a need for the loo as well. You into watersports? ;-)
19:09:35 <araujo> Philippa_, haha
19:09:38 <lispy> hehe
19:09:52 * lispy can't swim
19:10:08 * araujo likes swimming ;-)
19:10:47 <lispy> my idea of swiming is to go to the river during the summer and splash around in torso deep water
19:11:07 <sethk> damn, I'm having machine problems here.  I don't need this.
19:11:08 <araujo> rivers are good, as long as they don't have _that_ many rocks
19:11:31 <lispy> araujo: a lot of rivers 'round here are gravel or sand
19:11:39 <araujo> lispy, cool
19:13:47 * araujo practiced swimming for a few years
20:09:56 <araujo> hi Lemmih !
20:25:19 <tautologico> hi, can anyone help with parsec?
20:26:28 <sjanssen> tautologico: let's see if I can
20:26:56 <tautologico> I built a parser for a simple language with buildExpressionParser... but I'm having trouble defining function application
20:27:21 <tautologico> it works if I define an application operator $
20:27:27 <tautologico> but not with simple juxtaposition
20:31:37 <sjanssen> tautologico: I don't think I'm the man to help you with that, but I'm sure somebody will notice your question shortly
20:31:53 <sjanssen> there are plenty of Parsec people 'round here
20:32:06 <tautologico> ok, thanks
20:32:49 <dons> you have a rule 'e1 e2' for application?
20:33:08 <dons> versus 'e1 '$' e2' ?
20:33:57 <dons> btw, I've put up a 'add ByteString support to Parsec' topic for the google Summoer of Code. for those interested in this.
20:34:07 <sjanssen> I wonder if applying for Unicode ByteString+Parsec ByteString+StorableVector for SoC is too much
20:34:16 <sjanssen> dons: yes, I was just reading it
20:34:28 <dons> its come up as a question a few times.
20:34:32 <dons> oh, you're interested??
20:34:49 <sjanssen> yes
20:35:00 <dons> i'd say either do the Unicode layer or the Storable a layer.
20:35:10 <dons> which depends on whether you're into the low level hacking, or unicode stuff.
20:35:15 <dons> sjanssen: excellent! :)
20:35:57 <tautologico> no, I don't have a rule "e1 e2"
20:36:06 <tautologico> I have
20:36:15 <sjanssen> everything seems so *easy* in Haskell, I feel like I can do a dozen projects
20:36:23 <tautologico> expr = buildExpressionParser table baseExp <?> "expression"
20:36:37 <tautologico> baseExp = letexpr <|> conditional <|> variable <|> numberLiteral <|> booleanLiteral
20:36:38 <dons> this may well be true, sjanssen . in which case you could just keep doing more ByteString stuff.
20:36:51 <tautologico> I have more cases to baseExp
20:37:15 <tautologico> but I tried to include a case expr expr to baseExp and it didn't work... 
20:37:29 <dons> I see in the parsec examples, they have:
20:37:32 <dons> appExpr 
20:37:33 <dons>     = do{ es <- many1 atomExpr
20:37:33 <dons>         ; return (foldl1 App es)
20:37:33 <dons>         }
20:38:12 <tautologico> hm
20:38:25 <tautologico> well, it's essentially what I had in mind
20:38:25 <dons> tautologico: perhaps have a look at the example of 'Henk' in parsec/examples/ in the fptools srouce.
20:38:49 <dons> Henk is a little fp language, so probably they have some ideas you can borrow
20:38:51 <tautologico> dons: thanks, will do
20:39:08 <tautologico> I surely wish I could work in the summer of code
20:40:06 <tautologico> the ghc projects are cool
20:40:09 <stepcut> heh
20:44:43 <dons> sjanssen: if you want to talk more an application or what can be done, feel free to mail me (dons@cse.unsw.edu.au).
20:45:12 <sjanssen> dons: I will probably do that in a couple days, thanks
20:48:45 * palomer is rooting for the yi project
20:49:07 <palomer> when are the SoC submissions due?
20:50:32 <dons> palomer: hmm. I think you can start applying from May 1.
20:50:51 <palomer> and when's the final date?
20:50:53 <dons> then they get routed back to the admins for haskell.org, or allocate them to mentors (or something along those lines).
20:50:56 <dons> not sure.
20:51:05 <dons> check the we b page.
20:51:50 <sjanssen> what is haskell.org going to do with the $500 per project?
20:53:10 * palomer is surprised that peyton-jones isn't a mentor
20:54:38 <dons> sjanssen: the plan, very preliminary, is to use it to fund further projects. or perhaps getting students to the haskell workshop. we'll know more once we see how many projects we get, I suspect.
20:56:08 <tautologico> dons: do you have any estimation of hours of work per week required by the projects
20:56:11 <tautologico> ?
20:56:21 * dons learns a new word: "denition"
20:56:47 <dons> tautologico: hmm. it depends on the project. I think it is supposed to be roughly full time.
20:56:59 <dons> but I might be wrong on that. check with xerox
20:58:19 <dons> US $4500 for a summer's work sounds like full time for a student imo.
20:58:23 <tautologico> as I expected
21:01:41 * araujo also particulary feels interested in most of the projects
21:03:19 <dons> well, I hope those who're interested do apply.
21:03:59 <tautologico> I'm interested, by I'll be swamped by work in this period
21:04:10 <olliej> dons: US4500 is more than i would make fulltime over the summer, without actually doing a currency exchange :(
21:05:37 <dons> right. a student scholarship in .au would be around 70% of that figure. for full time research on similar kinds of projects.
21:06:22 <dons> So I'd really hope for full time, hard core hacking, on the project I've proposed to mentor, anyway :)
21:06:41 <araujo> Though im already very happy because this is an excellent opportunity to the haskell community to get nice things done.
21:08:11 * araujo is aware that these are full time projects
21:08:31 <palomer> how much are you expected to work on the SoC?
21:08:33 <palomer> fulltime?
21:08:59 <araujo> palomer, asking me?
21:09:01 <tautologico> this money would be 4x more than my scolarshop
21:09:03 <palomer> the channel
21:09:17 <araujo> palomer, xerox could know better
21:09:53 * palomer slaps xerox
21:09:56 <araujo> But i would consider most of the haskell projects as full time
21:10:45 <palomer> a cmu student has signed up as interested!
21:10:51 <palomer> cmu is sml land
21:12:15 <dons> didn't we just have this conversation? i think it would have to be full time.
21:12:50 <araujo> ouch, nobody seems to be interested on the Dia and HDB projects _yet_
21:13:01 * araujo would like to see those 
21:13:40 <araujo> dons, not with me, though i suppose so
21:37:40 <hyrax42> palomer: I think it's meant to be full-time (i.e. more or less replace a summer job)
21:37:53 <hyrax42> but I do know of someone who finished his in 2 weeks
21:37:59 <hyrax42> last year
21:38:12 <hyrax42> but the "word" is they're being a bit more stringent this time around
21:41:35 <RyanT5000> who's in charge of deciding what projects are done under the SOC?
21:41:39 <RyanT5000> (for haskell.org)
21:43:26 <sieni> You only need to ask one question: What would Simon Peyton Jones do?
21:46:38 <dons> RyanT5000: the haskell.org SoC admins. See here: http://hackage.haskell.org/trac/summer-of-code/
21:46:49 <dons> and http://hackage.haskell.org/trac/summer-of-code/wiki/People
21:47:09 <hyrax42> sieni: is that right?
21:47:50 <hyrax42> actually yeah I've wondered about acceptance... google decides or orgs decide?
21:48:43 <dons> there's some 'filter' function inserted in there. Again, best to ask xerox. or read the FAQs
21:48:57 <sjanssen> hyrax42: in Haskellish notation "take n $ sortBy haskellOrgPreference $ filter googleLikes applications"
21:49:22 <hyrax42> where n is decided by?
21:49:25 <RyanT5000> would "An OpenGL windowing system" be a reasonable project to suggest?
21:49:31 <sjanssen> n is a Google secret number
21:50:00 <dons> Haskell/OpenGL perhaps. RyanT5000 . note there's already one to work on the 'ion' window manager. so perhaps, yes.
21:50:25 <RyanT5000> Ion window manager is an X window maanger right?
21:50:31 <dons> RyanT5000: you could write a more concrete idea. we can evaluate it. and put it up.
21:50:38 <RyanT5000> i'm referring to a 3d windowing system that runs within opengl
21:50:45 <RyanT5000> it'd be useful for games and maybe 3d modeling apps
21:50:59 <hyrax42> hmmm
21:51:27 <hyrax42> and n is a function of organisation
21:51:43 <hyrax42> well I hope haskel.org gets a few
21:52:08 <hyrax42> I might apply for one, but I don't think it's really fair to diminish the chance of peopel who're more likely to get something useful done
21:52:23 <dons> hehe
21:52:55 <hyrax42> but I'll work on being less of a haskell newb at least
21:53:03 <hyrax42> over the summer... just won't get 4500 for it
21:53:35 <hyrax42> anyway, 1am is too late
21:53:38 <hyrax42> good night
21:54:15 <RyanT5000> well i'm going to be hacking haskell 12 hours a day all summer anyway - might as well open-source some of it and get paid :P
21:54:45 <RyanT5000> also, what's the deal with this mentor stuff?
21:54:49 <dons> you're going to be hacking haskell all summer anyway??
21:54:49 <hyrax42> :p
21:55:02 <hyrax42> well good luck with it
21:55:07 <RyanT5000> dons: yes, i'm writing a game, which i need to finish before law school
21:55:09 <dons> mentors help focus and coordinate the student. and evaluate the final results.
21:55:13 <dons> ah right.
21:55:19 <RyanT5000> is there a mentor for each project?
21:55:23 <RyanT5000> like a real physical person
21:55:29 <RyanT5000> because, tbh, i could use one
21:55:40 <dons> one person for each student, yes.
21:55:55 <RyanT5000> hm pretty cool
21:55:55 <dons> not that students aren't persons.well. sometimes.
21:56:01 <RyanT5000> :P
22:00:20 <dons> ah, I see all student proposals are due on May 8, 17:00 Pacific Daylight Time
22:00:23 <dons> and open on May 1.
22:00:23 <tautologico> in parsec, what's the difference between <|> and choice?
22:00:40 <magnus--> I think no difference
22:01:42 <tautologico> I think so too, just wanting to confirm
22:01:46 <dons> p1 <|> p2           = mplus p1 p2
22:02:10 <dons> choice ps           = foldr (<|>) mzero ps
22:02:20 <tautologico> thanks
22:02:46 <dons> @type Text.ParserCombinators.Parsec.choice
22:02:47 <lambdabot> forall a st tok.
22:02:47 <lambdabot>               [Text.ParserCombinators.Parsec.Prim.GenParser tok st a]
22:02:47 <lambdabot>               -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
22:02:54 <dons> @type (Text.ParserCombinators.Parsec.<|>)
22:02:56 <lambdabot> forall a st tok.
22:02:56 <lambdabot>              Text.ParserCombinators.Parsec.Prim.GenParser tok st a
22:02:56 <lambdabot>              -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
22:02:56 <lambdabot>              -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
22:03:02 <dons> so there is a difference.
22:07:00 <magnus--> I don't see any difference except for being binary vs n-ary
22:08:54 <dons> well, if the types are difference. its different no? and choice is defined in terms of folding <|>. so you can't say they're the same thing :)
22:09:36 <magnus--> I guess it depends on how you interpret the question :)
22:09:46 <dons> yep.
22:10:04 <RyanT5000> they accomplish the same goal
22:10:17 <RyanT5000> chopsticks vs. silverware?
22:11:37 <dons> 2 chopsticks versus n chopsticks?
22:11:43 <RyanT5000> yeah maybe
22:12:12 <RyanT5000> it was a poorly constructed metaphor to begin with :P
22:12:38 <magnus--> Btw, a random thought/discovery I had today: Lisp macros can define new datastructures and functions, something that haskell hofs can't do
22:13:32 <dons> aren't lisp macros a meta programmign language?
22:14:23 <magnus--> yes they are
22:14:28 <dons> though it seems to me that map (+1) defines a new function, doesn't it?
22:14:51 <magnus--> yes it does, but consider this example:
22:14:58 <sjanssen> magnus--: you can definitely create new functions at runtime
22:15:32 <magnus--> sjanssen: I am not talking about functions as values... are you?
22:15:54 <Korollary> I think that's pretty well known about lisp 'macros'
22:16:33 <magnus--> Korollary: Yes, not a great discovery... though it helped me straighten out what the difference in expressiveness is
22:17:21 <Korollary> Most lisp hackers bring that out foremost when praising lisp/scheme
22:17:35 <dons> using a meta programming language is a big, dangerous hammer. in haskell you'd try to avoid stepping into staged computation (especially runtime-staged) as far as possible, since it opens up just about any evil you want to do. 
22:18:05 <Korollary> dons: it suits a dynamically typed language well, though.
22:18:17 <Korollary> I mean philosophically
22:18:19 <magnus--> example: You want to read, store in memory, and write a binary file format from/to disk. In lisp you'd create a macro that automatically creates your class, and methods to read/write from disk
22:18:22 <dons> whereas things aren't going to go wrong if you just stick to hofs. and then use something like compile time meta programming when needed to build custom data structures
22:18:27 <magnus--> in haskell I saw no other way than to manually write out all three
22:18:29 <dons> Kor	yes.
22:18:50 <dons> magnus--: that's the Binary class you're talking about, in Haskell.
22:19:01 <dons> you derive Binary.
22:19:05 <Korollary> magnus--: Well, macros are not the only abstraction facility available
22:19:18 <magnus--> dons: built into compiler?
22:19:36 <Korollary> You can create abstractions using macros, objects or hofs.
22:19:38 <dons> (which may involve using a  compile time meta programming macro, or the DrIFT preprocessor, or in some Haskell compilers, its built in)
22:20:02 <magnus--> Korollary: I know, I do use lisp :)
22:20:14 <dons> but yeah, that's a code generation problem, magnus-- . so its not surprising that hofs aren't the tool. meta programming is.
22:20:15 <Korollary> magnus--: I meant objects or hofs outside lisp
22:20:54 <magnus--> Korollary: Ah, gotcha.
22:21:01 <sjanssen> I don't think this binary example really needs code generation, with a good Binary class you can write the instances by hand
22:21:45 <lispy> @karam+ haskell
22:21:45 <lambdabot> Maybe you meant: karma karma+
22:21:54 <lispy> @karma+ haskell
22:21:55 <lambdabot> haskell's karma raised to 3.
22:22:00 <lispy> 3???!?!?
22:22:01 <dons> you would. in ghc for .hi files they use DrIFT on the syntax tree type. though.
22:22:13 <Korollary> You can certainly find some problems that are most elegantly solved by manipulating the AST.
22:22:18 <dons> lispy, well we already named the whol channel after Haskell :)
22:22:26 <lispy> dons: :)
22:22:28 <dons> so that's plenty good karma already.
22:22:40 * lispy has been at the pub and as such should not have access to irc :)
22:23:00 <Korollary> lispy: it's better than driving. You came back too early from the pub btw.
22:23:09 <sjanssen> @localtime lispy
22:23:11 <lambdabot> Local time for lispy is Thu Apr 27 22:22:47 2006
22:23:11 <lispy> Korollary: yeah, but all my friends had to go home
22:23:29 * lispy can't drink alone
22:23:36 <lispy> or at least i shouldn't...
22:23:37 <Korollary> well, pub is where you make new friends after the old ones go home
22:23:42 <lispy> ah
22:23:51 <lispy> i'll have to try that next time
22:24:24 <magnus--> actually now that I think of it, functions could do that job without macros, if the runtime is dynamic
22:25:20 <Korollary> magnus--: Yes, you can pass, say, a python object to a function that doesn't know what it is, but it just calls .write() on it, etc.
22:26:00 <lispy> i was just beginning to explore CL macros when i started learning haskell.  I've been meaning to learn about TH...I guess I just need to start playing with it.
22:26:23 <Korollary> lispy: I thought you knew lisp inside out before you found haskell
22:26:42 <lispy> i used it a lot, but there is still much to learn
22:26:53 <lispy> CL is a big language with a complicated spec
22:26:59 <lispy> overly so
22:27:21 <lispy> apparently it was a really hard spec to write because all the parties involved felt they had a better idea of what lisp should be
22:27:38 <lispy> but lucid mostly won, and then disappeared
22:27:40 <tautologico> CL is a monster
22:27:46 <lispy> yeah :(
22:28:05 <tautologico> I tend to prefer scheme nowadays
22:28:06 <lispy> it's more pragmatic than scheme but it's unbearable at times
22:28:15 <tautologico> yep
22:28:22 <tautologico> the problem with scheme is fragmentation
22:28:25 <Korollary> "I am contacting you as I have been exclusively mandated by one of the fasted growing Equity Volatility Business within a top tier US Bank to find a Senior Quantitative Developer Project Leader to join their London Team." Eh?
22:28:33 <tautologico> N module systems, object systems
22:28:37 <Korollary> Somebody seems to have misjudged me.
22:28:52 <lispy> Korollary: hehe
22:29:04 <lispy> tautologico: i have to confess, i know almost no scheme
22:30:25 <tautologico> CL is a case where you clearly see that there's an elegant language struggling to get out :)
22:30:39 <Korollary> Ooh. An ex-coworker of mine is about to be snatched by GOOG.
22:32:35 <magnus--> GOO or GOOG?
22:33:47 <dons> killer goo from the black lagoon.
22:34:37 <tautologico> the kind of syntactic abstraction that is possible with macros is something I would like to see in a type safe way in haskell
22:34:49 <tautologico> it may be dangerous, yes, but it has good uses
22:35:05 <dons> this is what TH is for, no?
22:35:06 <RyanT5000> tautologico: seen TH?
22:35:19 <tautologico> I know about it, never checked it out
22:35:47 <RyanT5000> it's pretty sweet; it was the last thing i read about Haskell before deciding to dive straight into it
22:37:38 <lispy> tautologico: i hear it's not as general but i would be willing to bet it's as useful
22:39:18 <lispy> heisenbug: nice nick
22:40:07 <lispy> i sometimes feel like "compile time programming" is an under explored aread
22:40:18 <lispy> area*
22:40:28 <RyanT5000> yeah, and it's ridiculously useful
22:40:45 <tautologico> I think the term is multi-staged
22:41:06 <RyanT5000> i wrote a (nonworking, but complete) parser for C++ using regex search-and-replace.... 25kloc
22:41:09 <magnus--> there are some code generators that are widely used though, like yacc/lex
22:41:24 <RyanT5000> then i turned it into a 1kloc generator and 1kloc input
22:41:45 <RyanT5000> interestingly enough, the 25kloc i just referred to was yacc code
22:42:06 <tautologico> is yacc a code generator or a DSL ? :)
22:42:14 <RyanT5000> DSL?
22:42:28 <tautologico> domain-specific language
22:42:45 <RyanT5000> hm...
22:42:59 <lispy> tautologico: i thought multi-staged was different, but i could see how it's related
22:43:07 <RyanT5000> well its output is a C file, or a C++ class
22:43:16 <magnus--> RyanT5000: is that 1kloc + 1kloc code online?
22:43:28 <RyanT5000> magnus--: no, but if you want it i could find it
22:43:37 <RyanT5000> it's essentially a translation of the C++ grammar
22:43:44 <RyanT5000> it's not LALR(1) though
22:43:48 <lispy> making a C++ parser is very difficult, it's a bear of a language to parse completely and correctly
22:43:53 <RyanT5000> so you need something better than yacc
22:44:05 <RyanT5000> there are better grammars for C++ freely available than mine :)
22:44:22 <RyanT5000> although mine keeps comments
22:44:38 <lispy> even gcc has bugs in it's c++ parser (although maybe not in very recent versions)
22:44:46 <magnus--> okay... I was just curious.. you don't need to dig it out
22:44:52 <RyanT5000> np :)
22:45:09 <RyanT5000> i'd make you wait a few days anyway, because it's on "some harddrive" of mine... i have no idea which
22:45:55 <magnus--> C++ is a love/hate language for me
22:46:20 <magnus--> hate for it's complexity, love for being useful without a garbage collector
22:46:33 <lispy> i think C++ got right a few things that java got wrong and vice versa, but other than that, i'm neutral to it.  It's pragmatic but not good.
22:46:59 <tautologico> java is becoming as idiosyncratic as C++
22:47:07 <RyanT5000> i hate java so much
22:47:13 <tautologico> the crud is accumulating
22:47:14 <RyanT5000> C++ i don't mind
22:47:24 <tautologico> I don't hate java... it's just... boring
22:47:25 <tautologico> so boring
22:47:36 <Cale> java is so incredibly verbose
22:47:52 <Korollary> Cale: It's meant to be written 'by' an IDE ;)
22:48:01 <RyanT5000> :)
22:48:18 <RyanT5000> i have no problem with long variable names, provided i have Intellisense or simmilar
22:48:19 <Cale> heh
22:48:36 <lispy> java is more type safe that C++ and easier to write code in, but C++ is more grounded in practice
22:48:54 <lispy> but C++ has weird rules that are hard to remember
22:48:57 <mahogny> hrm. what do you mean grounded in practice?
22:48:59 <RyanT5000> also, C++ has non-reference types
22:49:01 <Cale> It's not just variable names, it's the whole syntax.
22:49:02 <Korollary> Java has weird rules nowadays too
22:49:13 <dons> ah, the memories. /me starts building ghc
22:49:21 <lispy> mahogny: well, when variables go out of scope the constructor is called, always.  In java, meh, who knows
22:49:24 <tautologico> it's enlightening to see how to open and read a file in java :)
22:49:38 <dons> the memories. the hot laptop. the blinking harddisk light.
22:49:42 <RyanT5000> constructor/destructor is a really nice paradigm
22:49:46 <lispy> dons: heh
22:49:55 <tautologico> a lot of junk to get a file open... says a lot about the language
22:50:02 <RyanT5000> although i prefer haskell's use of "withX" to allocate resource X
22:50:05 <mahogny> lispy, is that a problem? you're using haskell and complaining about a gc? :)
22:50:30 <tautologico> non-deterministic finalization may be a problem 
22:50:36 <mahogny> ehr wait o_O
22:50:39 <tautologico> but mostly it isn't 
22:50:39 <lispy> mahogny: well, unpredictability is a problem in any language.  Sometimes i hate laziness (although, only in certain cases)
22:50:59 <RyanT5000> mahogny: when you have mutable variables it's much more of an issue
22:51:02 <mahogny> lispy, you can enforce termination of objects if you need it in java
22:51:25 <lispy> which reminds me, i think compile time programming should be explored more because sometimes the compile code matters more than the time spent figuring out how to generate it
22:51:41 <lispy> mahogny: how?  i would like to know, i use java at my job
22:52:04 <mahogny> lispy, finalize() or a similar command. check if Object has any such methods
22:52:21 <lispy> mahogny: ab so you have to call it at the right time?
22:52:30 <tautologico> finalize() doesn't solve it
22:52:33 <RyanT5000> finalize is callled by the gc
22:52:36 <lispy> mahogny: i was using JDBC recently and found out you have to call .close() explicitly
22:52:53 <RyanT5000> in C# you can force a collection, which also happens to force finalization... sometimes
22:53:15 <lispy> you have to call .close() at the right time AND it's hard to write exception handling code correctly because a lot of the cleanup functions can generate exceptions
22:53:15 <mahogny> hm. what puzzles me is, why would you explicitly need a termination? sounds like bad design
22:53:58 <lispy> fortunately, people have a low tolerance for buggy software :)
22:54:16 <mahogny> way too tolerant if you ask me :P
22:54:18 <lispy> i can write crap and they will just say, "Oh, that's java" ;)
22:54:22 <mahogny> lol
22:54:43 <lispy> but i'd rather not write crap because it's my reputation on the li ne
22:54:53 <mahogny> and javas reputation >_<
22:55:13 <lispy> i'm trying to convince them to let me write some haskell at work
22:55:31 <lispy> but i don't try very hard, i just mostly hint that it would be a good idea
22:55:37 <mahogny> :)
22:55:57 <mahogny> it is probably a good idea until someone else need to maintain your code
22:55:58 <lispy> problem is, i'm not long term so someone will have to know haskell when i leave
22:56:12 <lispy> and if i wrote a numarray binding for haskell it would go a long ways
22:57:34 <dons> mahogny: well, the company only has to post a 1 line email to haskell.org saying "Hiring Haskell programmers" and they can choose between 100 phd-qualified candidates :)
22:57:44 <lispy> hehe
22:57:48 <mahogny> dons, true that
22:58:11 <mahogny> salary comes after though :)
22:58:11 <lispy> i was telling a buddy tonight that haskell is such a nice language
22:58:43 <dons> its a myth that haskell people are hard to find. there's an over supply at the moment
22:58:55 <lispy> i've been talking about going into gamedev when i graduate, but haskell is so nice that maybe i'll apply at galois instead :)
22:59:28 <lispy> dons: yeah, and it's sort of underground too.  I mean if you actually did a survey you'd find a lot of people would like to use haskell at work but don't think they could get away with it.
23:00:08 <dons> we need to break this mental barrier. it would be extremely good for the community.
23:00:16 <RyanT5000> lispy: write a small module in it
23:00:29 <RyanT5000> something where it wouldn't kill you to write it in both java and haskell
23:00:32 <lispy> i think 1) haskell is really fun to program in 2) needs a bit of 'direction' before people feel comfortable using it in industry
23:00:34 <mahogny> for the community? heck. for the world economy
23:00:51 <RyanT5000> yes mahogny, but we only care about ourselves :P
23:01:00 <mahogny> RyanT5000, lol
23:01:14 <RyanT5000> i totally agree though
23:01:16 <mahogny> lispy, consider starting your own, and do haskell AND games :)
23:01:18 <lispy> yeah, i keep telling my manager that haskell helps me write code which is more reliable
23:01:27 <lispy> mahogny: god..yeah, that would be great
23:01:37 <RyanT5000> heh that's my goal, sort of
23:01:38 <lispy> mahogny: but how do you get ghc to target the xbox?
23:01:49 <RyanT5000> lispy: output C
23:02:02 <RyanT5000> ;)
23:02:04 <mahogny> yeah. I don't think that is a major problem
23:02:14 <lispy> yeah, RyanT5000 is probably right
23:02:15 <tautologico> or port the rts to the xbox
23:02:15 <mahogny> or try a few pc titles first
23:02:17 <dons> xbox has what inside it? an x86?
23:02:21 <mahogny> yes
23:02:23 <tautologico> x86
23:02:27 <lispy> mahogny: hehe true!
23:02:32 <mahogny> "windows is portable. it runs on intel"
23:02:36 <dons> and some weird linker? or normal windows.
23:02:45 * lispy has no clue
23:02:50 <RyanT5000> i'm pretty sure it's not normal windows
23:02:54 <mahogny> I would assume that they use as much stock windows stuff as possible
23:02:54 <tautologico> with a nvidia chip equivalent to GeForce 3
23:02:56 <RyanT5000> executables are signed, for one
23:02:57 <lispy> but what about nintendo systems? they like arm iirc
23:03:06 <dons> sounds like just some tool chain issues. not a big ghc rewrite. and library bindings
23:03:18 <RyanT5000> i'd guess it's PE with some "extensions"
23:03:18 <mahogny> ooh. haskell and nintendo ds. I think those would mix well
23:03:24 <tautologico> it'd be no big problem
23:03:31 <lispy> actually, how does haskell handle embedded stuff?
23:03:36 <RyanT5000> mahogny: that's because it has "haskell" as one of the mixants
23:03:45 <mahogny> lispy, depends on the level of "embedded"
23:03:59 <lispy> i would tihnk that [a] would be a hinderance to embedded stuff because of small resources
23:04:16 <mahogny> I think it depends on what you call embedded
23:04:16 <dons> you'd use nhc. it was designed for embedded systems
23:04:26 * lispy googles it
23:04:27 <RyanT5000> i hate "hungarian" notation so much
23:04:28 <dons> i've seen it running on arm credit-sized card boards.
23:04:35 <lispy> nice
23:04:43 <mahogny> feel free to port ghc though :)
23:04:53 <RyanT5000> cannot convert CUniStr to LPCWSTR
23:04:54 <RyanT5000> WTF
23:05:05 <tautologico> lol
23:05:05 <lispy> ghc is such a nice vehicle of research i could see it not being the best for constrained processors
23:05:16 <RyanT5000> now i have to spend 30 minutes hunting down the definition of those
23:05:43 <tautologico> LPCWSTR is a Long Pointer to a C Wide STRing
23:05:55 <RyanT5000> yeah i know that - so should be CUniStr
23:05:59 <RyanT5000> i have to find the subtle difference
23:06:03 <lispy> do you guys know of any languages for modeling relationships and behaviors?
23:06:09 <tautologico> though "long" pointers are from the days of windows 3.11
23:06:12 <mahogny> I don't really see the need for all these compilers except for testing out if the spec can be implemented from scratch using the available texts. IMO ghc should be the only "production" compiler
23:06:29 <lispy> a professor i know wants a language for modeling pedestrians...so if you guys have heard of any languages i'd love to know about them
23:06:32 <RyanT5000> GAH
23:06:43 <RyanT5000> UniChar is unsigned long
23:06:49 <RyanT5000> er, unsigned short
23:06:53 <mahogny> lispy, what properties does he want to model?
23:07:03 <RyanT5000> i hate people who do things like that
23:07:09 <dons> mahogny: in practice, ghc is the only production compiler. except for embedded systems, where people might try nhc.
23:07:26 <dons> anything else is research. or teaching.
23:07:39 <mahogny> yeah
23:07:40 <lispy> mahogny: i only know a little so bear with me....but modeling the relationships between the different parts of the simulation (like other pedestrians and the environment) plus the behaviors
23:07:42 * mahogny kicks hugs
23:07:56 <lispy> dons: how would you classify jhc?
23:08:06 <lispy> i think john has some really interesting ideas
23:08:08 <dons> currently its research 
23:08:16 <lispy> okay, thought so too
23:08:18 <dons> sure. ideas == research.
23:08:20 <mahogny> lispy, abstract, or with coordinates etc?
23:08:36 <lispy> mahogny: from the sonuds of it, abstract and as high level as possible
23:08:42 <RyanT5000> oh god, const-correctness
23:09:01 <RyanT5000> i love doing const correctness in haskell ;)
23:09:02 <mahogny> lispy, then I would prefer matlab, or haskell if it can be formalized with transition logic
23:09:16 <lispy> mahogny: what is transition logic?
23:09:22 <lispy> mahogny: like state machine stuff?
23:09:24 <mahogny> lispy, yes
23:09:38 <lispy> hmm...yeah, i should tihnk about state machines
23:09:54 <mahogny> if it's markov stuff, then I would go matlab
23:09:54 <lispy> this might became a masters topic for me
23:10:05 <lispy> mahogny: that's good to know
23:10:21 <lispy> i think they want a new language, but we can always borrow from matlab in that case
23:10:25 <akemp> dons: you working on cabal-get?
23:10:44 <mahogny> actually, matlab is one of my favourite languages, silly enough. there are few languages that are that efficient at hacking code
23:11:18 <dons> akemp: not at the moment.
23:11:19 <lispy> mahogny: i find 1) haskell 2) lisp 3) python 4) you name it
23:11:35 <lispy> mahogny: and 5) maple ;)
23:11:39 <akemp> Ah.  So my e-mails are falling upon deaf ears...
23:12:01 <mahogny> lispy, as soon as you get into serious vector manipulation and need good prewritten routines for math, 1-4 are wamped :)
23:12:07 <tautologico> matlab is a crappy language with a good library
23:12:12 <RyanT5000> maple burns my eyes
23:12:34 <mahogny> tautologico, the language is quite ok. I'd like to see some haskell extensions but it does what it should really well
23:12:47 <tautologico> yes it does
23:12:51 <RyanT5000> mahogny: also you can throw java into matlab code now
23:13:20 <mahogny> RyanT5000, yeah, for quite a while. but I prefer C over java if I have to mix something in
23:13:25 <tautologico> well, I don't know about the latest versions... w
23:14:03 <RyanT5000> me too, but that might be harder to do, seeing how matlab tends towards the "dynamic" side of things
23:14:23 <RyanT5000> there was a matlab-to-C compiler or something though
23:14:33 <RyanT5000> i wonder if that handles the java...
23:14:35 <mahogny> RyanT5000, it's really easy to mix C and matlab. just use Mex
23:14:51 <RyanT5000> yeah, that's what i'm talking about :)
23:15:04 <RyanT5000> but i mean throwing C directly into the matlab code doesn't seem quite as easy
23:15:53 <mahogny> inside a .m?
23:15:56 <RyanT5000> yeah
23:16:09 <mahogny> hm. semi-interesting idea
23:16:23 <RyanT5000> cause you can put java right in there
23:16:43 <mahogny> but I don't know if I see why one would want to mix matlab and c at that level
23:16:51 <RyanT5000> neither do i :P
23:16:58 <RyanT5000> wow... i find myself randomly altering C++ code and seeing if the error count drops
23:17:18 <mahogny> C++.... eew
23:17:30 <RyanT5000> (thank you, visual haskell people, for not making your code const-correct..... grrrr)
23:18:12 <RyanT5000> i'm trying to build vh on visual studio 2005, which is significantly more standards-conforming than 2003
23:18:40 <mahogny> why not upgrade to gcc? :)
23:18:42 <lispy> mahogny: i thought that was the purpose of the numarray haskell bindings :)
23:19:05 <RyanT5000> mahogny: because it uses MIDL, and has to link the result into visual studio :)
23:19:15 <RyanT5000> also, that's what they used and i'm not willing to figure out how to change it
23:19:20 <mahogny> RyanT5000, eeew. sounds very non-ISO
23:19:26 <RyanT5000> quite
23:19:51 <RyanT5000> keep in mind, though, that vh is an extension to visual studio
23:20:00 <RyanT5000> so some MS specific stuff is to be expected
23:20:02 <mahogny> lispy, haskell and C are too different to work well at that level. if you want to use their potential to the fullest, you must be prepared to switch computational domain entirelly
23:20:48 <RyanT5000> to haskell
23:20:50 <mahogny> I just wish the matlab-c bindings could be generated automatically
23:20:59 <lispy> mahogny: hmmm...the python numarray library make me believe that haskell numarray would work well too
23:21:37 <mahogny> lispy, probably, but it would probably suffer quite a bit from calling overhead
23:21:45 <mahogny> I would assume python already does
23:22:46 <lispy> i think the way python bindings work is that they just provide a viwe of the data and delay computations as long as they can to the C side
23:23:03 <mahogny> yes, that is the way to go
23:23:45 <mahogny> bbl
23:23:51 <lispy> although, as the great shoot out has proven, haskell can be quite performance friendly given the right programmers and time
23:25:37 <RyanT5000> lazy evaluation should be pretty conducive to efficiency when used properly
23:26:28 <lispy> and yet a lot of the shoot out entries rely an very precise use of seq
23:26:29 <dons> compiled, statically typed languages should always outperform compiled, dynamically typed languages and any interpreted code, I'd argue.
23:26:43 <dons> and the shootout entries show this.
23:26:47 <lispy> yeah
23:26:48 <kzm> Good morning
23:26:51 <RyanT5000> dons: you'd think so
23:26:57 <lispy> lisp sucks on the shoot out
23:27:11 <RyanT5000> lispy: it's not that lazy is faster, just that having the choice, if used well, is faster
23:28:19 <dons> laziness helps in the lazy benchmarks, like pidigits. other things  need strictness. so good thing clean and haskell are duel lazy and strict languages.
23:29:02 <lispy> i think if haskell were to be an industry 'approved' language it would have more syntax for specifying strictness
23:29:25 <dons> which is what bang patterns are for. 
23:29:32 <dons> and they came out of haskell's use in industry.
23:29:41 <dons> (at galois)
23:29:42 <lispy> bang patters? data Foo = Foo !Int ?
23:29:58 <dons> no, that's a data type strictness annotation.
23:30:10 <dons> bang patterns are: f !x = ... x ....
23:30:19 <dons> the opposite, sort of, of f ~x = ... x ...
23:30:20 <lispy> what does that do?  evaluate x?
23:30:30 <dons> f !x = x `seq` ... x ..., roughly.
23:30:47 <dons> use -fbang-patterns in ghc 6.5
23:30:56 <lispy> okay, i haven't seen those before although i've heard of f ~x and never used it
23:31:05 <RyanT5000> what exactly does f ~x do?
23:31:30 <dons> exactly, read the report :) inexactly, its a lazy pattern bind. so the pattern match failure won't occur till the values are used.
23:32:07 <dons> actually, John Hughes seems to use them a lot: in arrow.hs: (***) f g ~(x,y) = (f x, g y)
23:32:16 <dons> first (Kleisli f) = Kleisli (\ ~(b,d) -> f b >>= \c -> return (c,d))
23:32:38 <RyanT5000> interesting
23:32:43 * lispy struggles with monad transformers and has been afraid to learn about arrows yet
23:32:47 <dons> Data/List.hs:unzip4                     =  foldr (\(a,b,c,d) ~(as,bs,cs,ds) -> ...
23:33:10 <RyanT5000> what does it improve? cache locality?
23:33:11 <dons> that seems to be the only places in the std libs they're used. Control.Arrow, and Data.List.unzip*
23:33:24 <dons> cache locality?? this is haskell..
23:33:33 <RyanT5000> it's still running on a chip
23:33:41 <RyanT5000> it's a performance thing, right?
23:33:57 <dons> its a semantic thing. it changes the semantics of the code.
23:34:02 <RyanT5000> oh
23:34:10 <dons> just as with !
23:35:01 <RyanT5000> does ! change the semantics if you have a finite datastructure (i.e.: one that could be completely strict)?
23:35:11 <dons> my point about "this is haskell.." was that the language is defined in terms of translation to a core calculus. so there's not going to be references to cache locality when defining language features.
23:35:28 <RyanT5000> i see
23:35:58 <RyanT5000> i was just thinking it'd be faster to do all the checks at once than to do them at the beginning
23:36:13 <RyanT5000> ("at once" being when the lazy evaluator gets around to evaluating it)
23:38:21 <RyanT5000> i find low level stuff to be rather fun
23:38:35 <RyanT5000> it's not in my best interest as far as getting things done is concerned
23:40:15 <lispy> yeah it can be fun, it's like a game
23:41:42 <RyanT5000> yeah
23:41:59 <RyanT5000> yay, i built visual haskell
23:42:02 <RyanT5000> now wtf do i do with it
23:42:04 <RyanT5000> :-/
23:43:40 <RyanT5000> can ghc-pkg automatically get packages and build them and stuff?
23:43:58 <RyanT5000> (or is there any way to do that)
23:44:16 <lisppaste2> ct16k pasted "Can someone pls provide assistance with this? (I cannot log in the channel :()" at http://paste.lisp.org/display/19452
23:44:32 <dons> hmm.
23:45:03 <dons> homework problem?
23:45:13 <RyanT5000> i dunno, but he hasn't provided nearly enough context
23:45:21 <RyanT5000> e.g.: the error message, if any
23:45:35 <dons> automagically geting remote packages is for the future cabal-get
23:45:40 <lisppaste2> ct16k annotated #19452 with "World type (forgot to include it)" at http://paste.lisp.org/display/19452#1
23:45:43 <dons> building them is handled by Cabal, the haskell build system.
23:46:06 <RyanT5000> alright, i figured as much
23:46:09 <dons> hmm lispaste2 can be an annoying way to spam a channel.
23:46:14 <Korollary> heh
23:46:26 <lispy> yeah, i don't understand the problem/question
23:46:52 <RyanT5000> for some reason, i get  the following whenever i try to do pretty much anything with cabal:
23:46:53 <dons> I don't understand why ct16k can't join the channel.
23:47:00 <RyanT5000> This application has requested the Runtime to terminate it in an unusual way. 
23:47:00 <RyanT5000> Please contact the application's support team for more information.
23:47:02 <ADEpt> xerox-: done
23:47:21 <dons> RyanT5000: there's a bug in your operating system.
23:47:39 <Korollary> Oh man. Xahlee is at it again.
23:47:40 <RyanT5000> dons: i know - it's called "windows"
23:47:52 <dons> Korollary: oh, is ct16k xah lee?
23:48:13 <lispy> xahlee?
23:48:13 <RyanT5000> nonetheless that doesn't help me get stuff installed :-/
23:48:21 <lispy> is this a keal type?
23:48:32 <RyanT5000> well anyway, time to get 4 hours' sleep; cya all
23:48:46 <Korollary> dons: Oh, I don't know. I was reading comp.lang.functional
23:48:55 <dons> ah. you had me going for a minute there.
23:49:15 <RyanT5000_> that's the traditional thing to do when you're away, right?
23:49:20 <RyanT5000_> <-- irc noob
23:49:33 <dons> shrug. yeah. many don't bother.
23:49:41 <dons> @localtime RyanT5000_
23:49:42 <lambdabot> Local time for RyanT5000_ is Fri Apr 28 02:49:18 2006
23:49:44 <Korollary> most of this channel is away
23:49:45 <dons> often works just as well ;)
23:49:55 <RyanT5000_> yah but my client also doesn't have nickalert (i use trillian)
23:50:00 <RyanT5000_> i'll have to get mirc
23:50:29 <RyanT5000_> i figure either i should know when someone has tried to talk to me, or they should know i won't know
23:50:31 <lispy> or use mecas
23:50:33 <lispy> er emacs
23:50:39 <lisppaste2> ct16k annotated #19452 with "Why i can't join :">" at http://paste.lisp.org/display/19452#2
23:50:57 <lispy> so ct16k is reading the logs in real-time?
23:51:00 <Korollary> haha
23:51:07 <lispy> annotate once for yes and annotate twice for no
23:51:23 <RyanT5000_> lol
23:51:27 <dons> this is annoying. ct16k, ask on haskell-cafe@haskell.org, if you can't join.
23:51:37 <dons> visit haskell.org for details on the mailling lists.
23:52:00 <lispy> yeh, what dons said
23:52:14 <dons> oh, btw, this isn't legal haskell: then ch='*' else ch='.'
23:52:22 * lispy waits up for his ex (snif) gf to come home and feed her fish
23:52:23 <RyanT5000_> well his list comprehension is screwed up
23:52:35 <JohnMeacham> jhc is getting closer to being generally usable. partly because I have this new nokia 770 that I want to compile programs for :)
23:52:36 <dons> yeah, its all wrong.
23:52:44 <dons> JohnMeacham: cool cool!
23:52:53 <lispy> JohnMeacham: heh, you rock :)
23:55:58 <sieni> @karma+ JohnMeacham
23:55:58 <lambdabot> JohnMeacham's karma raised to 1.
23:56:07 <lispy> JohnMeacham: what types of programs are you writing for your nokia?
23:56:21 <sieni> 1? 1?!?!
23:58:12 <kzm> dons: did you see my benchmarks, btw?
23:58:18 <dons> kzm yeah. 
23:58:23 <kzm> any possible explanation for map and split?
23:58:31 <kzm> Or am I abusing your benchmark code?
23:58:36 <dons> the issue with the slower split and friends is an artifcat of the benchmarks.
23:58:37 <kzm> :-)
23:58:45 <kzm> Okay.  Laziness thing?
23:58:55 <dons> try swapping the order of the functions in the list, whichever runs first is always a bit slower
23:59:05 <kzm> I suspected something like that.
23:59:11 <dons> I should probably insert a warmup run prior to each list item
23:59:37 <kzm> Will it happen for any others?  I.e. is any slowness in my i18n modules hidden by this?
23:59:41 <dons> since there's something going on. (all the threadDelay and performGCs where to avoid this, btw)
