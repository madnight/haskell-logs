00:53:59 <vincenz> re
00:54:10 <vincenz> shapr: could you generate me a password when you have time
01:25:37 <newsham> so this House system uses ghc's runtime as a major component of their OS.
01:25:46 <newsham> seems like a cop out.
01:26:52 <Lemmih> cop out?
01:27:05 <ayrnieu> House system?
01:27:30 <newsham> lemmih: yes, because they dont get to design some fairly imnportant parts of the system.  such as the thread scheduler
01:27:56 <newsham> http://www.cse.ogi.edu/~hallgren/House/
01:28:17 <newsham> granted, its at least something.  a good first step.
01:28:29 <newsham> but i'd be intersted in seeing a more serious attempt at building an os in haskell
01:28:51 <Lemmih> newsham: But if they improve the code then all Haskell programs will benefit (:
01:29:09 <newsham> sure.  but they're different things.
01:29:13 <Lemmih> (where all = ghc compiled)
01:29:19 <newsham> runtime isnt an os, and vice versa.
01:36:35 <shapr> newsham: Thread priorities would need to be part of the RTS
01:37:28 <newsham> which is why it might be good for someone to design their own
01:37:37 <alar> @seen lambdabot
01:37:43 <audreyt> hm, JohnMeacham had a Judy binding sometime ago
01:37:45 <boegel> alar: heh :)
01:38:03 <boegel> alar: I'm afraid that won't work :D
01:38:06 <audreyt> anyone aware of where (if any) is the code?
01:38:29 <alar> no more lambdabot?
01:38:47 <alar> no mbot either
01:38:49 <newsham> (its also deceiving to give LoC for their OS when a large portion of the work is borrowed from ghc's rts)
01:39:20 <newsham> sleep,.. gnite
01:45:44 <dons> not sure its a cop out. unix comes with a C runtime after all..
01:45:51 <dons> lambdabot, ?yow
01:45:56 <dons> ?bot
01:47:58 <dons> hmm. more network weirdities. its been a strange day.
01:48:04 <dons> have to bring lambdabot back later.. :/
01:49:32 <araujo> Hello!
01:52:21 <vincenz> alar: password!
01:52:29 <vincenz> dons: oasisbot is still up
02:12:39 <davidhouse> you know what i hate? stupidly placed shortcuts.
02:13:02 <davidhouse> like when i try to ctrl+tab to switch windows in my IRC client and accidentally hit Ctrl+Q and it closes.
02:13:28 <boegel> :)
02:13:45 <davidhouse> or in windows, when i'm about to type "URL" but accidentally hit the windows key first. the 'u' opens the "shut down" dialogue, and the 'r' hits the "restart" button.
02:14:07 <flux__> yeah. maybe the windowing system should automatically optimize you a shortcut mapping that has maximized the error distance!
02:14:18 <davidhouse> or in emacs, when a slight misalignment of my fingers means i end up hitting c-x then slipping onto c-c, closing emacs.
02:14:30 <davidhouse> </rant>
02:15:06 <alar> windows key are EVIL
02:16:03 <davidhouse> maybe i should just use dvorak.
02:18:28 <flux__> I've added confirmation to that ^X^C..
02:18:36 <flux__> most other operations have easily be reversed
02:18:59 <flux__> if only there was a greater framework for unrolling operations, such as terminating a process ;)
02:19:19 <davidhouse> @pl \(C a b) f -> C (f a) b
02:19:46 <davidhouse> lambdabot's down again.
02:20:08 <mauke> it would probably give you a parse error for C
02:20:14 <davidhouse> it does indeed.
02:20:45 <davidhouse> okay, anyone care to guess at a function that would do this?
02:20:52 <mauke> depends on C
02:21:00 <davidhouse> if it was a tuple i could use Control.Arrow.first
02:21:08 <davidhouse> but for a generic record/ADT?
02:38:31 <musasabi> morning
02:38:47 <davidhouse> @type sequence . repeat
02:38:51 <davidhouse> grr.
02:39:17 <davidhouse> is there a shortcut function for that?
02:39:55 <davidhouse> i know of replicateM, but i want an infinite list
02:40:16 <hoan> poo!
02:40:21 <hoan> haxml won't compile
02:40:34 <hoan> src/Text/XML/HaXml.hs:35:16: Not in scope: data constructor `VERSION'
02:42:32 <musasabi> hoan: use the released version instead the darcs one?
02:42:56 <musasabi> + run appropriate scripts.
02:45:19 <hoan> i tried both, but now the scripts of the released one
02:46:27 <hoan> trying the ./configure && make && make install dance
02:47:20 <davidhouse> mmm. hot chocoloate + haskell = happy me.
02:47:27 <davidhouse> *chocolate
02:47:46 <hoan> i had one earlier today, yum yum
02:48:30 <hoan> musasabi: the dance seemed to work :]
02:48:49 <hoan> thanks
02:49:18 <hoan> up comes happs
02:54:48 <davidhouse> is there a monadic combinator that repeats an action until a boolean becomes false?
02:56:04 <davidhouse> xerox, realised there's something wrong with the top function in our zipper library
02:56:07 <mauke> what would be its type?
02:56:12 <musasabi> mplus + infinite list may work for MonadPlus ones.
02:56:20 <xerox> davidhouse: ah-ha!
02:56:21 <davidhouse> i need it for State.
02:56:32 <davidhouse> xerox, namely, it puts Top as a context, but doesn't update the structure.
02:56:38 <musasabi> or just "untilM act = act >>= \e -> if e then return () else untilM act"
02:56:57 <davidhouse> xerox, also i'm making great progress generalising.
02:57:21 <davidhouse> i've got a working library for trees where each node has an arbitrary number of branches.
02:57:28 <davidhouse> musasabi: it doesn't return a bool.
02:57:39 <xerox> davidhouse: slick!
02:57:42 <musasabi> davidhouse: how do you measure success then?
02:57:50 <aleator> musasabi: Wouldn't that be better with a separate test? And wouldn't it then be called a while-loop :)
02:57:53 <davidhouse> musasabi: a monadic bool :)
02:58:24 <musasabi> davidhouse: if you think of the type signature then writing it should be easy.
02:58:48 <davidhouse> whileM bool act = act >> bool >>= \p -> if p then return () else whileM bool act
02:58:51 <davidhouse> perhaps.
03:06:58 <xerox> guard bool, maybe?
03:07:13 <norpan> is anyone working on somtehing like visual haskell for something else than visual studio?
03:07:47 <davidhouse> xerox, guard takes a non-monadic bool.
03:07:53 <davidhouse> i believe.
03:08:04 <davidhouse> yes.
03:08:41 <xerox> Ah-uhm, okay.
03:09:45 <norpan> @hoogle while
03:09:56 <mauke> ENOBOT
03:10:05 <norpan> where is it
03:10:09 <hoan> lol, eveyone here has lambdabot withdrawals
03:10:20 <norpan> gimme gimme gimme a bot before midnight
03:10:34 <hoan> _|_
03:19:54 <norpan> while :: (Monad m) => m Bool -> m a -> m [a]
03:21:05 <mauke> while cond body = do { c <- cond; if c then liftM2 (:) body (while cond body) else return [] }
03:21:19 <yaarg> where's lambdabot? :(
03:23:40 <norpan> map -> fmap -> liftM
03:23:45 <norpan> zipWith -> ? -> liftM2
03:23:46 <davidhouse> norpan, is that an actual function?
03:23:57 <davidhouse> while, i mean.
03:24:02 <norpan> it is now, that mauke has implemented it
03:24:14 <davidhouse> okay, well, i'll stick with my whileM.
03:24:24 <davidhouse> (as i don't want a list returned)
03:24:31 <mauke> davidhouse: yours is do-while
03:24:33 <norpan> then just ignore it :)
03:24:42 <davidhouse> muake, that's true.
03:24:43 <norpan> yes, yours does the action always
03:24:57 <norpan> at least once
03:25:51 <norpan> it's no extra problem that it returns m [a] instead of m ()
03:26:00 <norpan> just ignore the return value
03:26:07 <davidhouse> yeah, true. okay, switching :)
03:27:02 <mauke> whatever :: (Monad m) => m (); whatever = return ()
03:27:16 <mauke> ignore :: (Monad m) => m a -> m (); ignore x = x >> whatever
04:00:12 <pitecus> Hi. Anyone know how I can convince GHC to read and write text files in UTF-8 instead of Latin1?
04:01:33 <xerox> ....files as in, sources?
04:01:41 <xerox> Or just something like readFile?
04:01:48 <pitecus> the latter
04:02:04 <xerox> Good.  Just go hunting for UTF8.hs then.
04:05:34 <pitecus> OK there is a function there which takes [Word8]. How do I read a file as [Word8]?
04:07:57 <xerox> hGetBuf?
04:09:42 <xerox> Does the module say anything about the preferred way to go?
04:20:48 <pitecus> No, it just does decoding and encoding of these Word8 lists. 
04:21:30 <pitecus> Shouldn't the compiler just look at your locale to determine file encoding rather than just assume latin1?
04:22:24 <wilx> The locale and the content of the files do not have to have anything in common, imho.
04:23:09 <xerox> I think so too.
04:23:11 <pitecus> If I use a UTF-8 locate that means I want programs to use that encoding as default, unless I specify a different one.
04:23:25 <xerox> How are you going to specify it?
04:24:26 <pitecus> xerox, I don't know in GHC, in other programming languages you can give an argument to whatever function opens an input steam.
04:40:16 <musasabi> pitecus: the various FastPackedString implementations support this.
05:43:52 <pitecus> Thanks musasabi 
05:53:08 <shapr> Man, I want a new drug (programming language)... and Joule looks so very tasty.
05:54:07 <tromp> try a taste of Curry...
05:56:33 <xerox> Concurrent dataflow...
05:56:42 * JKnecht struggles with the term "Onomasticon".
06:32:03 <metaperl> true or false: "Certain algorithms are easier to write in this programming style. Take for instance the computation of the product of two matrices. Even though it is certainly possible to translate it into a purely functional version, in which lists replace vectors, this is neither natural nor efficient compared to an imperative version."
06:32:17 <metaperl> this, being imperative
06:32:40 <dons> huh. weird
06:32:59 <dons> i guess umm imperative algorithms are better in iimperative languages
06:33:32 <dons> but mathematical functions are usually (always?) clearer in a _functional_ language
06:33:39 <dons> and who says you use listts?s?
06:34:19 <dons> its FUD, I say.
06:34:38 <JKnecht> no but something as contemptable.
06:35:11 <JKnecht> except inasmuch as it commands pity/compassion.
06:35:33 <JKnecht> if not class/worker solidarity.
06:35:57 <dons> metaperl, where'd you read that?
06:36:21 <metaperl> dons: http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora024.html
06:38:23 <JKnecht> that changes everything doesn't it :)
06:39:02 <dons> just makes it bizarre
06:39:29 <dons> i'm too tired to try to work out why they wrote that
06:39:37 <JKnecht> well, the best is never really the enemy of the good in any significant case, I'm thinking.
06:41:59 <shapr> the best?
06:43:31 <JKnecht> whichever.
06:43:43 <shapr> I don't understand what you were referring to.
06:44:05 <JKnecht> ocaml v. haskell.
06:45:44 <JKnecht> pragmatics can decide sometimes, for example needing to use .Net 2 sort of implies f# (ocaml).
06:50:07 <Smokey`> sigh, i wish i could get a hold of say... current generation video bios specs, for nvidia's cards.
06:50:49 <shapr> metaperl: It is at least possible that lambda calculus could have turned into graph reduction/rewriting CPUs instead of turing machines creating mutable CPUs. In this alternate timeline, the fringe languages would look like FORTRAN, and vilified as a useless technology because of their amazing waste heat.
06:52:44 <pitecus> dons, Is that webpage yours by any chance: www.cse.unsw.edu.au/~dons/fps.html? Someone recommended FastPackedString and I'm trying to download it but I'm getting a timeout
06:56:25 <norpan> hey, does anyone know what the status is on using haskell code in shared libraries on linux x86 from a c program?
07:05:13 <musasabi> norpan: that is possible iirc, but not very well documented.
07:05:45 <norpan> i know that i tried it a few years ago but it didn't work due to something with non-position-independent code
07:05:56 <norpan> just segfaulted
07:18:23 <vincenz> re
07:18:32 <vincenz> shapr: can I have a pw please :)
07:20:49 <vincenz> > 1
07:20:50 <oasisbot> 1
07:24:54 <shapr> vincenz: Er, what for?
07:25:00 <vincenz> shapr: wiki
07:25:04 <shapr> oh
07:25:14 <vincenz> and oasisbot is here only until lambdabot returns, no worries
07:26:52 <jip> morning
07:28:17 <vincenz> > 1
07:28:18 <oasisbot> 1
07:29:14 <boegel> @vixen are you vincenz' pet?
07:29:14 <oasisbot> i truely am
07:29:20 <boegel> alrighty then
07:29:31 <bolrod> :]
07:29:49 <bolrod> @vixen does vincenz know about greek grammar ?
07:29:50 <oasisbot> yes
07:29:54 <bolrod> wtf
07:30:11 * vincenz has plural greek colleagues
07:30:24 <bolrod> >_>
07:30:27 <vincenz> @vixen do you love me?
07:30:28 <oasisbot> i wouldn't say i do love...
07:30:32 * vincenz sniffs
07:30:39 <vincenz> the pet leaves the master...
07:30:45 <vincenz> no more snacks for you
07:31:02 <bolrod> @vixen do you like me?
07:31:02 <oasisbot> yah, i like you
07:31:09 <bolrod> @botsnack
07:31:09 <oasisbot> :)
07:31:11 <boegel> @vixen do you love me?
07:31:11 <oasisbot> i wouldn't say i do love...
07:31:19 <boegel> @vixen anyone?
07:31:19 <oasisbot> let me answer that later, okay?
07:31:26 <boegel> @vixen jackass
07:31:26 <oasisbot> what's worth more a flush or a full house?
07:31:30 <boegel> :)
07:32:47 <bolrod> @vixen do you hate vincenz ?
07:32:47 <oasisbot> no, i never hate
07:32:50 <bolrod> oh
07:33:34 <hoan> zzz
07:34:39 <vincenz> @vixen does bolrod waste hsi time with a lot of silly questions to a random bot?
07:34:39 <oasisbot> i can be random at times, i know
07:34:44 <vincenz> woah
07:35:29 <bolrod> @vixen can I ask more questions?
07:35:29 <oasisbot> is that really what you want to know?
07:35:34 <bolrod> :]
07:39:54 <bolrod> *Yawn*
07:41:55 <xerox> Anybody knows when is Duncan going to get back from his trip?
07:42:47 <vincenz> xerox: Exactly when the trip ends
07:43:06 <bolrod> That was rather obvious
07:43:48 <vincenz> obviously
07:43:50 <bolrod> maybe we can pinpoint it more exactly
07:43:51 <bolrod> like
07:44:07 <Saulzar> Sometime after two minutes ago?
07:44:09 <bolrod> exactly the time between the time he is still on his trip.. and the time he will be back again
07:44:15 <jip> if i get <<loop>> how can i find out what happened?
07:44:23 <bolrod> search the loop
07:45:00 <jip> eh?
07:45:04 <bolrod> Two days before the day after tomorrow  :)
07:46:17 <Igloo> Compiling with -prof -auto-all and running with +RTS -xc can sometimes help find the loop
07:47:31 <Saulzar> Look for direct value recursion by mistake... stuff like x = y * x + 3   where you meant x' or x1 or something
07:47:47 <jip> Igloo: can i also use -O?
07:48:01 <jip> Saulzar: yeah but i have a lot of code and i don't know where to look
07:48:12 <Igloo> Yes
07:48:59 <Igloo> Alternatively, using -Wall and fixing the warnings might highlight the problem
07:49:21 <jip> Igloo: when i try to compile with -prof i get "Could not find module `Graphics.UI.Gtk'
07:50:08 <Igloo> You'll need profiling versions of the Gtk libraries too
07:51:15 * vincenz explained equational reasoning today to a group of people that had never seen functional programming \o.
07:51:16 <jip> that kind of sucks... why?
07:57:50 <jip> well, i couldn't find any warnings that seem to indicate a problem
07:58:03 <jip> so i disabled Gtk support and now i'm compiling with -prof -auto-all
07:58:04 <Saulzar> jip, Agree, it is somewhat annoying... I have a build of my project which does not link Gtk, OpenGL etc. at all for that reason
07:58:32 <jip> Saulzar: cool, what kind of project are working on that uses Gtk and OpenGL?
07:59:35 <Saulzar> An AI game, using plugin loaded Yampa robots (kind of a robocode clone)
07:59:48 <jip> wow sounds awesome
08:01:34 <Saulzar> Seemed a fun idea, still working on it - hope to get something usable soonish.
08:02:51 <vincenz> Saulzar: keep me posted?
08:03:01 <jip> Saulzar: do you have a "blog" or something?
08:03:22 <jip> Igloo: when i run my program without Gtk support then i don't get the <<loop>> error... guess it must be something in my gui code
08:03:58 <Saulzar> vincenz, Sure - though just now I am meant to be writing...
08:04:52 <Saulzar> No blog/page, though it seems a good idea
08:05:40 <jip> Saulzar: have you seen my devlog? :]
08:05:50 <Saulzar> Yeah, it looked good.
08:06:03 <jip> gotta update that sucker again soon
08:10:37 <vincenz> jip is a gameboymachine
08:11:09 <bolrod> =)
08:17:18 <Cale-work> iirc, the profiling option -xc can help with that
08:17:27 <Cale-work> er, that was to jip
08:18:31 <Cale-work> http://www.haskell.org/ghc/docs/6.4/html/users_guide/prof-time-options.html
08:18:50 <jip> Cale: thanks, Igloo mentioned that :)
08:19:27 <Cale-work> ah, sorry I missed that
08:25:06 <vincenz> Cale-work: whatcha doing for work
08:25:28 <Cale-work> vincenz: working on DFT code generation
08:25:49 <vincenz> to beat fftw?
08:26:26 <vincenz> (in haskell?)
08:26:36 <Cale-work> vincenz: yeah
08:26:44 <vincenz> kewl
08:27:00 * vincenz assumes that yeah expresses the && of the yes's to both questions
08:27:12 <Cale-work> yes, it does
08:27:18 <Cale-work> hehe
08:27:55 <vincenz> ;)
08:40:50 <jip> this is strange: i get that <<loop>> error when i compile my program, but i don't get it(my program seems to run fine) when i run my program from within ghci, even when it's importing the compiled version
08:42:17 <Saulzar> Does it loop when it does not <<loop>> ?
08:44:07 <jip> actually i don't think i've run my program long enough for it to enouncter the <<loop>> error
08:44:22 <jip> although it's possible that it might be looping
08:44:27 <jip> i'm not exactly sure what's going on yet
09:00:02 <jip> bingo
09:00:50 <jip> i seem to indeed get a freeze at the same location where the <<loop>> happened
09:05:15 <jip> ok, this is the exact IO action where the error is happening:
09:05:31 <jip> reg_a `entrySetText` regastateshow
09:05:47 <jip> this is totally strange :|
09:07:19 <Saulzar> jip, I would guess because the value regastateshow when evaluated is the issue?
09:12:29 <MarcWeber> Sorry for asking again. Have you meat this error, too ? http://www.rafb.net/paste/results/cl6KGZ61.html
09:12:36 <MarcWeber> ghc-6.5 form cvs
09:13:22 <MarcWeber> I didn't find anything in ghc mailinglists..
09:16:36 <Igloo> MarcWeber: Put a space after the $
09:17:18 <MarcWeber> Igloo: wtf I've recompiled ghc 7 times... Thx a lot.. Strange error message.
09:18:33 <MarcWeber> Wow.. I should really start stopping reading error messages but start reading my code instead..
09:20:31 <jip> hm... Saulzar is probably right! how do i force evaluation again? something about seq?
09:41:49 <norpan> @hoogle Functor
09:41:49 <oasisbot> Prelude.Functor :: class Functor f
09:41:49 <oasisbot> Data.FunctorM :: module
09:41:49 <oasisbot> Data.FunctorM.FunctorM :: class FunctorM f
09:42:55 <SamB> @index concatMapM
09:42:55 <oasisbot> bzzt
09:47:26 <shapr> Does anyone have any sort of binding to inotify?
09:47:49 <shapr> Or famd, or any way to watch for when a file changes?
09:48:00 <araujo> Hi!
09:48:04 <shapr> hola araujo 
09:48:06 * araujo back from univ.
09:48:10 <araujo> hi shapr!
09:48:38 * araujo throws a sugar-lambda at shapr 
09:48:54 * shapr eats it!
09:49:00 <araujo> :-)
09:49:07 <shapr> Mmm, now I need to unicycle to work off that weight!
09:49:13 <araujo> haha
09:49:24 <vincenz> shapr: password!!
09:49:28 <vincenz> pm me
09:49:33 <vincenz> cause I have to deconnect from here
09:49:37 <vincenz> :)
09:53:43 <shapr> I can barely wait till there's a haskell section in the debian distro.
09:55:16 * araujo wonders if there is gonna be Haskell hacking for the SoC
09:55:55 <SyntaxNinja> araujo: yes!
09:56:03 <SyntaxNinja> wonder no further
09:56:09 <araujo> SyntaxNinja, cool!!!!
09:56:12 <araujo> :-)
09:56:50 <araujo> SyntaxNinja, are you involved on something?
09:57:18 <SyntaxNinja> maybe
09:57:48 <SyntaxNinja> ;)
09:58:11 <araujo> hah, ok, i'll keep an eye open ;-)
09:58:47 <norpan> i want to do
09:58:58 <norpan> instance (Monad m, Num a) => Num (m a)
09:59:51 <norpan> but I had to settle for
09:59:57 <norpan> instance Num a => Num (Maybe a)
10:00:27 <norpan> and
10:00:32 <norpan> instance Num a => Num [a]
10:00:33 <norpan> and so on
10:00:42 <norpan> repeating the definitions for each type
10:01:38 <palomer> my socks are a pristine white
10:01:52 <Cale-work> that's likely because of the Eq and Show constraints for Num.
10:02:05 <Igloo> You can do instance (Eq (m a), Show (m a), Monad m, Num a) => Num (m a) with ghc -fglasgow-exts -fallow-undecidable-instances
10:02:06 <norpan> no, it's because you're not allowed to do instances like that
10:02:19 <norpan> oh
10:02:19 <Cale-work> yeah, what Igloo said
10:02:21 <norpan> hehe
10:02:52 <norpan> and why does an instance of Num has to be an instance of Show
10:02:56 <norpan> that just sucks
10:03:04 <Cale-work> yeah, it does
10:03:24 <Cale-work> The instance of Eq thing also sucks.
10:03:52 <palomer> nums have to be showable?
10:03:54 <palomer> cale works?
10:03:59 <Cale-work> hehe
10:04:00 <Igloo> You need Eq for literal patterns don't you?
10:04:13 <Cale-work> Igloo: yes, of course
10:04:36 <norpan> hey, it worked
10:04:51 <Cale-work> They added Eq as a superclass to avoid having to type Eq constraints in types of functions which use literal numeric patterns.
10:05:01 <Cale-work> But I think it's silly :)
10:05:14 <norpan> Eq is understandable, but Show is silly
10:05:44 <alar> what's with lambdabot?
10:06:27 <Cale-work> It's bizarre that Num has all these superclasses, but Monad doesn't.
10:06:49 <Cale-work> (I'm referring to Monad not having Functor as a  superclass)
10:07:36 <norpan> Or a default Functor instance for all Monads
10:07:56 <Cale-work> well, yeah, but that's inexpressible
10:07:58 <Igloo> You can't do the default Functor instance in H98
10:09:06 <norpan> Functor and Monad could be the same class
10:10:00 <xerox> As the current situation poses the typeclassed functions, I think so too.  But it's probably a good idea to implement the right hierarchy.
10:10:28 <norpan> map,fmap,liftM but zipWith,?,liftM2
10:13:06 <Igloo> zipWith is related to zipWithM, not liftM2
10:13:18 <norpan> you say?
10:13:29 <Igloo> huh?
10:13:36 <norpan> i think the resemblance to liftM2 is more obvious
10:15:04 <norpan> or not
10:15:09 <norpan> well anyway
10:15:15 <norpan> where is the Functor version
10:18:15 <mnislaih> @pf \v1 i v2 -> return (MMap v1 i v2)
10:18:15 <oasisbot> ((return .) .) . MMap
10:19:30 <mnislaih> @pf \a b-> return (a : b)
10:19:30 <oasisbot> (return .) . (:)
10:19:49 <bolrod> ...
10:20:23 <mnislaih> excuse me :)
10:21:16 <mnislaih> or should I say .... ((excuse .) .) . me :)
10:22:15 <bolrod> O_o
10:22:49 <kpreid_> @pf \a b c -> return (a,b,c)
10:22:50 <oasisbot> ((return .) .) . (,,)
10:22:51 <alar> oasis bot here :)
10:23:08 <bolrod> seriously... what do you guys want with that ..,,.....
10:23:34 <alar> bolrod: that's pointless notation :)
10:23:40 <bolrod> indeed
10:26:37 <mnislaih> is there an inverse for the fp command? I.e. from pointfree to pointwise
10:27:29 <mnislaih> I hope so... in order to be able to understand my own code two months later
10:27:42 <xerox> No, there isn't, bwhaha!
10:27:57 <mnislaih> bjez!
10:31:14 <bolrod> mnislaih: don't write that stupid pointless code then
10:31:23 <bolrod> it doesn't make your code look nicer in any way
10:31:27 <mnislaih> what evil mind would create pf and not provide the inverse ...
10:31:40 <bolrod> what evil mind would use pf
10:31:44 <mnislaih> bolrod come on, in some cases it makes sense
10:31:56 <alar> yes, pl code violates FWIM principle most of the time
10:31:56 <bolrod> no it doesn't
10:32:06 <bolrod> FWIM?
10:32:14 * Philippa can only read that as "F**k What I Mean"
10:32:14 <alar> Figure What I Mean
10:32:22 <bolrod> :)
10:32:24 <Philippa> ah. More normally DWIM?
10:32:28 <alar> ?
10:32:32 <Philippa> Do
10:32:42 <alar> maybe Doubt? :)
10:32:47 <bolrod> :)
10:32:52 <bolrod> still
10:33:13 <bolrod> it's no use having more dots then functions in an expression
10:33:13 <alar> bolrod: in some rare cases pl code is not so ugly as it is in most of others
10:33:19 <mnislaih> anyway I've found it useful now when monadifying code
10:33:38 <bolrod> untill someone smacks you on the head
10:35:47 <bolrod> then you think its usefull?
10:35:48 <bolrod> ;)
10:35:54 <bolrod> @arr
10:35:54 <oasisbot> Arrr!
10:36:11 <bolrod> @vixen is pf a usefull function
10:36:12 <oasisbot> i love fun
10:36:24 <bolrod> riight
10:36:52 <mnislaih> well then the sensible thing would be to ditch pf and start to work in a pw tool ;)
10:39:45 <bolrod> ic
10:43:00 <Cale-work> sometimes @pl does a really nice job of simplifying code
10:43:06 <Cale-work> but it's hit and miss
10:43:33 <bolrod> give an example
10:44:15 <alar> @get-shapr
10:44:15 <oasisbot> shapr!!
10:44:28 <bolrod> hehe
10:44:39 <bolrod> @get-pie
10:44:39 <oasisbot> Unknown command, try @list
10:44:44 <bolrod> >:(
10:44:56 <alar> jsut wanted to ask him where had original lambdabot go
10:45:17 <alar> @seen shapr
10:45:17 <oasisbot> shapr is in #haskell. I last heard shapr speak 51 minutes and 33 seconds ago.
10:52:48 <jip> what's that trick with seq to force evaluation?
10:54:43 <bolrod> @type seq
10:54:44 <oasisbot> forall b a. a -> b -> b
10:55:08 <xerox> jip: either "a `seq` a" or use $!.
10:55:26 <bolrod> > (+1) $! 1
10:55:27 <oasisbot> 2
10:56:06 <xerox> > const 1 $ undefined
10:56:07 <oasisbot> 1
10:56:12 <xerox> > const 1 $! undefined
10:56:13 <oasisbot> Undefined
10:56:16 <jip> > let a = 1 + 1 in a
10:56:17 <oasisbot> 2
10:56:25 <jip> > let a = $! (1 + 1) in a
10:56:26 <oasisbot>  parse error on input `$!'
10:56:32 <bolrod> $! is infix
10:56:39 <xerox> jip: $! works exactly like $.
10:56:45 <jip> > let a = (1 + 1) `seq` (1 + 1) in a
10:56:46 <oasisbot> 2
10:56:50 <jip> is that how i use seq?
10:56:57 <bolrod> dont think so ;/
10:56:58 <shapr> alar: yes?
10:57:05 * shapr returns from unicycling.
10:57:13 <bolrod> :]
10:57:17 <bolrod> helleauw shapr 
10:57:27 <alar> where had original lambdabot go?
10:57:36 <xerox> jip: no.
10:57:45 <xerox> jip: GHC doesn't do CSE usually.
10:57:52 <jip> CSE?
10:58:00 <shapr> But ghc does cse with -O or -O2, right?
10:58:02 <xerox> jip: to enable sharing, you have to use let or where clauses, i.e. name things.
10:58:38 <xerox> shapr: it does some kind of optimistic CSE, iirc.
10:58:49 <xerox> shapr: the problem are deadlocks or something.
10:59:07 <jip> i don't understand. i have: do { putStrLn "1"; let a = foobar; putStrLn "2" } -- i want foobar to be evaluated, so if there is an error in it, it will happen before putStrLn "2" happens
10:59:09 <shapr> Oh, never heard of that.
11:00:04 <xerox> shapr: <http://haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F>
11:00:05 <bolrod> let a = foobar $! id 
11:00:05 <bolrod> ?
11:00:39 <xerox> jip: let a = foobar `seq` foobar.
11:00:43 <bolrod> jip: does that work?
11:00:47 <bolrod> erh
11:00:59 <xerox> jip: iff foobar is not an expression.
11:01:02 <bolrod> isn't foobar $! id   faster ?
11:01:36 <jip> xerox: if foobar is not an expression, then what else can it be?
11:01:45 <bolrod> :]
11:01:50 <bolrod> just try it
11:01:51 <xerox> jip: a binding.
11:02:28 <jip> what'st he difference between a binding and an expression?
11:02:49 <shapr> xerox: neat, thanks.
11:02:50 <xerox> <name> [<args>] = <expr> defines a binding.
11:02:58 <xerox> shapr: my duty! (-:
11:03:30 <xerox> Let and where clauses define local bindings.
11:03:38 <Cale-work> Well, that's a function binding
11:03:52 <Cale-work> <pat> = <expr> is also allowed
11:03:55 <jip> xerox: "foobar" is close to "f x 1" where f is a function
11:04:01 <Cale-work> which is a pattern binding
11:04:22 <xerox> I did enclose <args> in brackets because I meant to say that they're optional, in that sense.
11:04:25 <jip> bolrod: foobar $! id doesn't compile
11:04:36 <Cale-work> ah
11:05:00 <xerox> Cale: but in fact you're talking about a different thing, thanks for pointing out.  <name> prolly doesn't mean <pattern>.
11:05:31 <Cale-work> jip: you're trying to force evaluation to occur?
11:05:37 <xerox> let a = <expr>
11:05:44 <bolrod> oh
11:05:46 <bolrod> ;)
11:05:48 <xerox>     b = a `seq` a
11:05:59 <jip> Cale: yep, like i showed in that "do" block a few lines up
11:06:05 <Cale-work> If you're in the IO monad, one nice way to force evaluation is using Control.Exception.evaluate
11:06:17 <xerox> @type Control.Exception.evaluate
11:06:18 <oasisbot> forall a. a -> IO a
11:06:19 <bolrod> isn't there a strict version of  sequence_ ?
11:06:24 <xerox> Nice one.
11:07:03 <Cale-work> It forces the evaluation of its argument to WHNF, which basically means that the topmost constructor in it will be determined
11:07:37 <jip> Cale: so any error that could possibly happen later on will be found immediately with evaluate?
11:07:54 <musasabi> no
11:07:56 <Cale-work> Provided that the error occurs no deeper in the structure.
11:08:12 <Cale-work> It won't catch things like [1,2,undefined]
11:08:32 <jip> Cale: how do i catch things like that?
11:08:40 <xerox> I think using deepSeq.
11:08:51 <musasabi> or Just (1 `div` 0)
11:09:08 <Cale-work> deepSeq works, though if you'd rather use something already in GHC, I recommend Control.Parallel.Strategies
11:09:08 <musasabi> deepSeq is the answer. Or just don't construct such things.
11:09:21 <Cale-work> evaluate (x `using` rnf)
11:09:30 <xerox> Oh, that's how you use Strategies!
11:09:53 <jip> hm... well, evaluate found my problem!
11:09:58 <Cale-work> okay
11:10:10 <jip> not sure why it's a problem though :/
11:10:17 <Cale-work> what error is it?
11:10:22 <jip> <<loop>>
11:10:25 <Cale-work> okay
11:10:31 <jip> or just a freeze when run from ghci
11:10:43 <xerox> seq = evaluate . (`using` rwhnf)
11:10:43 <Cale-work> right, ghci doesn't catch infinite loops anymore
11:11:02 <Cale-work> xerox: forgot the unsafePerformIO :)
11:11:26 <xerox> Because it takes an 'a' ?
11:11:34 <jip> i really can't understand why this expression is causing an infinite loop though
11:11:35 <xerox> seq = evaluate . (`using` rwhnf) . unsafePerformIO
11:11:40 <Cale-work> other way around
11:11:53 <xerox> No wait, it's wrong anyway.
11:12:01 <Cale-work> jip: can I see?
11:12:19 <xerox> Ah, I see, right.
11:13:14 <jip> Cale: all i'm doing is pattern matching against a tuple to return a single element. this function works correctly millions of times, and then for some reason while the program is running it decides to get stuck in an infinte loop :/
11:13:37 <Cale-work> that's a very special kind of infinite loop
11:14:04 <Cale-work> <<loop>> means that a closure is entered while in the process of its own evaluation
11:14:32 <Cale-work> s/closure/thunk/
11:14:49 <jip> is it at all possible that there is a problem with something other then my code?
11:14:58 <Cale-work> which basically indicates that a value is dependent on itself
11:15:24 <Cale-work> It's possible, I suppose
11:15:38 <Cale-work> did you make a paste of the expression somewhere?
11:15:54 <jip> i'll paste it
11:16:14 <Cale-work> > let x = x + 1 in x
11:16:15 <oasisbot> Terminated
11:16:32 <Cale-work> that's the sort of thing which will get a <<loop>>
11:17:17 <Cale-work> of course, it's usually far more subtle :)
11:18:37 <jip> http://rafb.net/paste/results/wfW2Po70.html
11:19:45 <jip> hm... wait, there is obviously a problem with the actual element that's in the tuple, right?
11:20:09 * xerox snickers
11:20:11 <xerox> @pl \x y -> const y (unsafePerformIO . evaluate . (`using` rwhnf) $ x)
11:20:11 <oasisbot> const id
11:21:45 <araujo> i usually get <<loop>> when re-assigning a value to a local variable which the recursive steps depend upon.
11:22:48 <bolrod> xerox: I can see pl being usefull here
11:22:54 <bolrod> :}
11:23:20 <Cale-work> jip: how is regS defined?
11:24:17 <jip> Cale: it's read from an IORef
11:24:23 <goron> Is GHC API documented somewhere?
11:24:56 <Cale-work> jip: okay, it would probably be useful to look at when that IORef was assigned
11:25:10 <Cale-work> (if it was assigned with a looping expression)
11:25:50 <jip> Cale: yeah, problem is that the assignment to the IORef is a very complex process
11:26:36 <Cale-work> get rid of the computation of regastate for now, and C.evaluate regS and see if you have the same problem
11:27:18 <jip> Cale-work: thanks, i'll try that in a sec
11:27:52 <araujo> That evaluate might be doing something nasty behind the scene :-)
11:27:56 <Cale-work> that will tell you if it's the expression for the registers as a whole that's looping, or just the expression for the A register.
11:28:36 <Cale-work> which is obviously something nice to know :)
11:31:52 <jip> Cale: C.evaluate regS -- does not trigger <<loop>>
11:32:10 <jip> Cale-work: the really weird thing is that the program works when i run the command line version
11:32:19 <jip> Cale-work: only when i run it through the gui does the <<loop>> happen
11:32:35 <jip> Cale-work: and the gui code does not affect the regS at all
11:32:42 <Cale-work> jip: okay, so it's just the A component
11:33:20 <Cale-work> perhaps look at previous assignments to that register, and see what code would affect it.
11:33:50 <Cale-work> It's pretty likely to be something somewhat localised in your code.
11:34:36 <jip> Cale: no... i don't directly assign to A register in my code. it's assigned indirectly by interpreting the code of this mini-language
11:34:58 <Cale-work> right, so look at the code for instructions which update that register
11:35:36 <Cale-work> I suppose that could be almost anything unfortunately.
11:35:49 <Cale-work> (depending on the machine)
11:36:09 <jip> i actually know which code is executing just before the freeze happens because i can see it in the gui window :)
11:36:13 <Cale-work> ah, good
11:36:25 <Cale-work> so you can look for the last assignment to the A register
11:36:46 <Cale-work> actually, better yet
11:36:51 <jip> yeah, but that doesn't help since the error seems to be lazily carried around for quite a long time
11:36:55 <jip> but i think i've nailed it
11:36:56 <Cale-work> Let's replace that tuple with a strict data structure
11:37:07 <Cale-work> That will prevent this sort of mishap
11:37:10 <jip> no.... i've figured out the bug. it all makes sense now :)
11:37:15 <Cale-work> oh, okay
11:37:22 <Cale-work> but it's probably a good idea anyway
11:37:29 <jip> let v'' = v + v''
11:37:33 <Cale-work> yes
11:37:38 <Cale-work> that would be it :)
11:37:41 <sethk> the compiler is giving me warnings because I'm reusing a symbol.  In this case, though, reusing it makes sense for readability.  Is there a switch to turn only this warning off?  The compiler message is "conflicting definitions for ..." then Bound at, and line numbers
11:38:13 <Cale-work> sethk: you're sure that's not an error?
11:38:49 <sethk> Cale-work, in this case, yes.  I'm deliberately dividing the same number by 256 and doing a mod, to extract bytes from it
11:39:00 <jip> Cale-work: i recently implemented an ADD instruction(badly :P) using this. too bad it was difficult tracing the error all the way to it, since my debugging efforts didn't lead me to it
11:39:19 <sethk> Cale-work, maybe I should change it though, it probably isn't a good idea in general to turn this warning off
11:39:48 <Cale-work> sethk: The problem is that definitions for separate symbols are not ordered in the code in any way
11:39:57 <Cale-work> you're allowed to locally shadow bindings using let
11:40:00 <sethk> Cale-work, even in a let?
11:40:02 <Cale-work> (or where)
11:40:04 <Cale-work> yes
11:40:06 <sethk> this is in a let
11:40:19 <Cale-work> right, but if they're both in a let, then they're at the same level
11:40:24 <sethk> right
11:40:28 <Cale-work> both in the same let, of course :)
11:40:28 <sethk> ok, I'll change it
11:41:14 <Cale-work> > let {evens = 0 : map (1+) odds; odds = map (1+) evens} in take 10 evens
11:41:16 <oasisbot> [0,2,4,6,8,10,12,14,16,18]
11:41:32 <Cale-work> let bindings may be mutually recursive :)
11:42:04 <Cale-work> jip: Change that tuple to a data structure with strict fields, and the error will happen at the time of assignment
11:43:11 <Cale-work> hopefully, that just involves redefining the RegisterStates type and rewriting getRegState/setRegState
11:43:59 <jip> Cale: hm... i'm not sure i want to do this
11:44:05 <Cale-work> also, it'll mean that there's less potential for stack overflows if, say, there's a counter that gets updated 1000000 times before it's ever actually demanded.
11:46:34 <Cale-work> also, with -funbox-strict-fields, GHC should pack the fields so the whole structure will only take a little over 12 bytes
11:47:26 <jip> Cale: this sounds like good stuff, by my strategy is to optimize only after i get things working
11:48:08 <Cale-work> sure - I'
11:48:16 <Cale-work> I'm just a little wary of large tuples
11:48:55 <davidhouse> mutually recursive lets scare me.
11:49:24 <davidhouse> > let evens = map (*2) [0..] in take 10 evens -- ;)
11:49:26 <oasisbot> [0,2,4,6,8,10,12,14,16,18]
11:50:36 <jip> my question now is: why didn't ghc -Wall warn me about: let v'' = v + v''
11:52:01 <jip> what would be really useful, is an editor that does syntax highlighting and highlights when a let statement is self recursive
11:53:00 <davidhouse> > let v = 4; v'' = v + v'' in v''
11:53:01 <oasisbot> Terminated
11:53:26 <davidhouse> > let v = v'' + 2; v'' = v + 2 in v''
11:53:27 <oasisbot> Terminated
11:53:44 <davidhouse> > let v = v'' + 2; v'' = v - 2 in v''
11:53:45 <oasisbot> Terminated
11:56:35 <jip> anyway, it works! check it out, the tiles from the gameboy game, "Dropzone":
11:56:37 <jip> http://img143.imageshack.us/img143/920/dropzonetiles3rv.png
11:57:18 <Cale-work> jip: cool
11:57:32 <davidhouse> jip, what does your program do?
11:57:56 <jip> davidhouse: it will eventually be a game boy emulator
11:58:14 <davidhouse> nice.
11:58:20 <jip> it actually in theory is pretty close to working
11:58:25 <davidhouse> that extracts the sprites from a game boy game binary?
11:58:48 <jip> davidhouse: no, in the screenshots you are seeing a realtime view of game boy video ram as the game code executes
11:59:06 <davidhouse> ah.
12:00:58 <jip> hm... actually that screenshot is incorrect, my video-ram dumper code is incorrect! no wonder there are repeated tiles...
12:04:17 <jip> this is what it's supposed to look like:
12:04:51 <jip> http://img63.imageshack.us/img63/5337/dropzonetiles26qp.png
12:05:04 <jip> you can even see the "DROPZONE" title-screen graphic if you look hard enough :D
12:06:44 <xerox> @karma+ jip -- WOOOHOOO!
12:06:45 <oasisbot> jip's karma raised to 1.
12:08:23 <jip> hehe cool... for some reason my karma stays at 1 no matter how many times it is raised though :P
12:08:36 <xerox> Different bot, different karma.
12:09:00 <jip> anyway, this working confirms that i am very very close to having actual title screens of games being shown :D
12:09:36 <jip> implementing joypad support should be pretty easy, and then maybe a few games will even be playable :o
12:09:52 <jip> (without sprites at least, but those aren't *super critical* for gameplay :D)
12:10:14 <xerox> Very nice.
12:11:28 <jip> but there's still quite a bit of work to do so that most games will run. so far, only "Dropzone" has run far enough to load it's graphics into video ram
12:12:12 <jip> so my task right now is to implement the missing cpu instruction that all other roms will at least run without terminating :)
12:13:09 <Igloo> Do you interpret the instructions directly?
12:13:20 <Igloo> Or compile to something intermediate first?
12:13:52 <jip> you mean generate native machine code?
12:14:53 <Igloo> That sort of thing, yeah
12:16:14 <jip> well i don't do that. each instruction is converted to a haskell data structure, then this data structure is converted to yet another haskell data structure which is sort of a "language for describing the working of a gameboy cpu instruction"
12:16:21 <jip> Igloo: you can read the details in the first post to my devlog
12:16:28 <jip> Igloo: http://www.mutantlemon.com/omegagb/devlog/
12:25:28 <davidhouse> eurgh. getting a stupid error trying to instantiate Show.
12:25:36 <jorik> what, 43% votes for "not amsterdam" ??
12:25:51 <davidhouse> Illegal instance declaration for `Show (Travel (BTreeLoc a) (BTree a))'. (The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables)
12:26:02 <jorik> ftw, the things that are legal there it blows the mind
12:26:22 <davidhouse> what on earth does that mean? why would it require such a type?
12:26:39 <davidhouse> and it's clearly false, because there are such things as instance Show Int where...
12:26:44 <xerox> Cale-work: what's with this "-work" tag? :-)
12:26:52 <xerox> Howdy davidhouse!
12:27:18 <davidhouse> hey xerox :) throwing together unit tests. pretty much finished generalisation.
12:27:22 <Cale-work> xerox: I'm at McMaster
12:27:33 <xerox> davidhouse: what did you generalize?
12:28:06 <davidhouse> xerox, at the moment, just traverse, getTree, modifyTree and putTree.
12:28:12 <xerox> Cale-work: McMaster university?
12:28:18 <xerox> davidhouse: in what way?
12:28:23 <davidhouse> most of my work has been with the BTree lib.
12:28:25 <Cale-work> xerox: yeah
12:28:51 <xerox> Cale-work: cool, and you're working on something specific?
12:28:53 <davidhouse> xerox, you can pass in any data structure
12:29:10 <xerox> davidhouse: that's a good generalization :-)  How do you specify kind of movements?
12:29:37 <davidhouse> movements are still structure-specific, but i'm working on that.
12:29:45 <Cale-work> xerox: At the moment, optimising DFTs and other small linear maps. Generating code for the Cell SPU using Haskell :)
12:29:56 <xerox> Cale-work: O_O
12:30:06 <lisppaste2> davidhouse pasted "the new, generic zipper monad" at http://paste.lisp.org/display/19130
12:30:12 <davidhouse> xerox, ^^
12:30:20 <davidhouse> xerox, gotta dash.
12:30:24 <xerox> Later!
12:31:04 <xerox> Cale-work: I hope you're having fun :-)
12:31:43 <Cale-work> xerox: yep :)
12:32:25 <xerox> How does one get into a random university hacking technological beauties ? (-:
12:32:58 <alar> univercity hacking?
12:33:19 * alar supposes bank or govt hacking is more fun
12:33:38 <xerox> Imagine a ',' between those two words.
12:34:37 <monochrom> A random university does not have technological beauties.
13:02:39 <jip> how does "operator precedence" work with things like && and >
13:03:45 <Cale-work> jip: there are infix declarations in the prelude which set the precedence levels and associativity
13:05:56 <Cale-work> http://haskell.org/onlinereport/standard-prelude.html -- right at the top
13:12:13 <jip> Cale-work: thanks
13:16:32 <SamB> jip: you can just do :i on them in GHCi, iirc
13:19:41 <mauke> that reminds me
13:20:47 <mauke> does anyone here know about parsing algorithms and can tell me if my algorithm is widely known or if I really invented something new?
13:21:35 <SamB> mauke: no! I don't see your algorithm. not that I'm an expert or anything.
13:21:56 <mauke> code is at http://rafb.net/paste/results/MxikVP96.html
13:22:11 <mauke> it starts relatively sane
13:23:27 <davidhouse> mauke: doesn't look much like haskell to me...
13:24:42 <davidhouse> eurgh. getting a stupid error trying to instantiate Show.
13:24:45 <davidhouse> Illegal instance declaration for `Show (Travel (BTreeLoc a) (BTree a))'. (The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables)
13:24:50 <davidhouse> what on earth does that mean? why would it require such a type?
13:24:56 <davidhouse> and it's clearly false, because there are such things as instance Show Int where...
13:25:02 <mauke> it's about the algorithm
13:25:12 <mauke> and I didn't write it in haskell because it needs mutable tree nodes
13:25:34 <musasabi> davidhouse: -fglasgow-exts might help.
13:25:44 <davidhouse> musasabi: why?
13:25:46 <mauke> davidhouse: "a b c" is a variable number of arguments, 0 in the case of Int
13:25:47 <bolrod> yep
13:25:50 <bolrod> just do it :)
13:25:53 <musasabi> davidhouse: it is a limitation of the Haskelll98 standard.
13:26:07 <musasabi> all the compilers are more permissive.
13:26:08 <bolrod> probably doesn't like that Travel gets 2 parameters ?
13:26:19 <musasabi> and it should be in the next standard.
13:27:16 <davidhouse> -fglasgow-exts works.
13:29:22 <SamB> mauke: how can it be about the algorithm if it is written in C?
13:29:49 <mauke> hey, everyone knows C
13:31:45 <SamB> mauke: yeah, but parsers in C are hard to follow initially
13:31:54 <mauke> oh no, the indentation is broken
13:32:07 <SamB> especially with all those macros...
13:32:20 <mauke> the macros help to make the parser readable
13:35:05 <sethk> to me macros make things less readable, always
13:35:22 <mauke> properly indented, slightly simplified: http://rafb.net/paste/results/oqemC047.html
13:35:23 <sethk> because I'm not looking at the code, I'm looking at something else.  what is it?  who knows?
13:35:57 <mauke> sethk: that's like saying functions are evil because you have to look at the definition to know what's going on
13:36:04 <sethk> mauke, no, not at all
13:36:15 <davidhouse> > error "hello" == undefined
13:36:16 <oasisbot> Add a type signature
13:36:17 <sethk> mauke, that's like saying, you can look at the definitions and still have no idea what's going on
13:36:30 <davidhouse> > (error "hello" :: String) == (undefined :: String)
13:36:31 <oasisbot> Exception: hello
13:36:34 <davidhouse> grr.
13:36:46 <sethk> mauke, they are different cases, one has an extra layer of substitution
13:36:49 <davidhouse> with HUnit, how can i check my algorithm corrects errors?
13:36:50 <mauke> sethk: just as with functions
13:36:53 <sethk> no
13:36:58 <sethk> not like with functions
13:37:01 <sethk> you still have functions
13:37:08 <sethk> you just have macros on top of the functions
13:37:14 <sethk> that's hardly the same case.
13:37:27 <sethk> you have to preprocess the file to go from what you see to the real code.
13:37:39 <mauke> no, that would make it totally unreadable
13:37:46 <sethk> when I'm looking at functions, and function invocations, I can look at one and see what's happening
13:38:22 <sethk> whether the preprocessed code is ugly, or not, isn't the point
13:38:36 <sethk> the point is whether you have to look at two sources, or three, to see what's going on
13:38:39 <mauke> the only reason those aren't functions is that I'm using "return" to express failure, which can't be done in another function
13:38:59 <mauke> oh, and to save me from having to type the same function arguments each time
13:39:20 <sethk> mauke, that's not a problem for me, then
13:39:25 <mauke> you can understand the macros in isolation, then understand what the code that uses them does
13:39:26 <davidhouse> mauke, return check(args)
13:39:37 <mauke> davidhouse: if it doesn't fail, it doesn't return
13:39:52 <davidhouse> oh, right.
13:39:57 <sethk> mauke, yes, but it's an extra step.   In the general case it's much more difficult.
13:40:01 <davidhouse> mauke, then use haskell :)
13:40:13 <sethk> mauke, you can certainly use macros in a reasonable way, as you have here
13:40:29 <mauke> davidhouse: mutable tree nodes are much harder in haskell
13:40:34 <sethk> but macros are insidious  :)
13:40:48 <davidhouse> anyone got any ideas about my HUnit question/
13:41:59 <mauke> case '^': MAKE_BINOP(POW); NEXT(1); ... I mean, what's not to like?
13:42:15 <mauke> but yeah, the structure might benefit from a suitable monad
13:43:25 <xerox> Howdy Lemmih!
13:45:09 * SamB wonders why jhc is spending about 76% of its time in the garbage collector
13:46:00 * SamB does not wonder why it waits so much -- it is waiting for pages to come in from swap...
13:46:28 <SamB> actually it could be spending 90% of its time in the GC...
13:47:30 <xerox> Fetishist?
13:51:54 <NameTab> my haskell exam tomorrow is gonna be so tough :/
13:52:05 <xerox> NameTab: why so?
13:52:38 <NameTab> xerox: I find it hard and I think it's a lot of stuff I have to know by heart, not by computer :P
13:53:17 <xerox> I'd love to help you out understanding some bits, if you want.
13:53:34 <NameTab> have you got a clue where to start? :)
13:53:50 <wilx> Hehe, to study only a day before exam is just wrong.
13:53:58 <SamB> what, you mean they are having an exam with ... no lambdabot and no GHCi?
13:54:01 <xerox> NameTab: you're telling me.
13:54:13 <xerox> SamB: the ugly truth.
13:54:19 <NameTab> wilx: not only a day, I started studying a week and I've been using haskell for two months
13:54:31 <NameTab> SamB: I'm afraid so
13:54:34 <xerox> NameTab: good, then what's the problem, or the problems?
13:55:16 <NameTab> xerox: for one, wxHaskell is going to be a problem I'm afraid, I'm *really* bad at remembering stuff :P
13:55:31 <NameTab> and I'm not sure what parts of the exam I will not understand *yet*
13:55:35 <xerox> Urgh.  That doesn't sound fun.
13:55:44 <SamB> uh...
13:55:47 <SamB> wxHaskell???
13:55:50 <SamB> on an exam?
13:55:55 <SamB> the professor must be crazy!
13:56:19 <NameTab> because mostly things are very clear, but thinking it up myself without documenation..
13:56:29 <davidhouse> anyone got any ideas about my HUnit question? it's rather annoying.
13:56:34 <NameTab> SamB: heh, I'll tell him you said so :) he's used to that kind of talk I'm afraid
13:59:27 <SamB> I mean, even if you had been doing Haskell for much longer, it would be madness to expect you to learn to use a GUI library with no documentation.
13:59:55 <NameTab> heh, we don't have to know an the entire library, just some basics
14:00:05 <NameTab> but still, every bit we have to know is too much
14:00:24 <NameTab> if you ask me that is, but they didn't ask me so I don't think they'll listen tome either
14:00:27 <SamB> tell him he shoulda had you learn Parsec
14:01:21 <xerox> > 2 / (product $ take 30 v) where v = sqrt (1/2) : map (sqrt . (+(1/2)) . (/2)) v
14:01:22 <oasisbot> 3.1415926535897927
14:01:44 * SamB eats it
14:01:55 <NameTab> pi!
14:02:06 <xerox> pee!
14:02:16 <davidhouse> xerox, i wrote a cool spreadsheet once to calculate pi, e etc from various infinite series.
14:02:29 <xerox> Nice (-:
14:02:54 <davidhouse> some of the series are so much better than the others.
14:03:04 <NameTab> if ur able to calculate the next pi decimal u'll be rich :)
14:03:19 <davidhouse> e.g. for the simplest series for pi, even after tens of thousands of iterations it was only correct to a few sig figs.
14:03:21 <davidhouse> > pi
14:03:22 <oasisbot> 3.141592653589793
14:03:44 <davidhouse> > (pi - (2 / (product $ take 30 v) where v = sqrt (1/2) : map (sqrt . (+(1/2)) . (/2)) v)) * 100 / pi
14:03:44 <oasisbot>  parse error on input `where'
14:03:56 <davidhouse> > (pi - (2 / (product $ take 30 v)) * 100 / pi  where v = sqrt (1/2) : map (sqrt . (+(1/2)) . (/2)) v)
14:03:56 <oasisbot>  parse error on input `where'
14:04:07 <SamB> xerox: you are cheating!
14:04:16 <xerox> Uh-oh.
14:04:17 <davidhouse> > (pi - (2 / (product $ take 30 v))) * 100 / pi  where v = sqrt (1/2) : map (sqrt . (+(1/2)) . (/2)) v
14:04:18 <oasisbot> 1.4135798584282296e-14
14:04:23 <xerox> SamB: am I?
14:04:24 <davidhouse> that's the percentage difference.
14:04:38 <davidhouse> *error
14:04:49 <SamB> xerox: you are taking advantage of the way that gets substituted into the template
14:05:12 <SamB> (you aren't allowed to use where in an expression)
14:05:32 <xerox> Do you prefer let?
14:05:35 <SamB> > i; i = 1
14:05:36 <oasisbot> 1
14:05:42 <xerox> O_O
14:05:50 <xerox> That is cheating!
14:06:04 <davidhouse> > i; i = "sqrt(-1)"
14:06:05 <oasisbot> "sqrt(-1)"
14:06:22 <xerox> > 2 / (product $ take 30 v); v = sqrt (1/2) : map (sqrt . (+(1/2)) . (/2)) v
14:06:23 <oasisbot> 3.1415926535897927
14:06:31 <xerox> Whoa.
14:06:41 <davidhouse> things in lamdabot have module-level scope.
14:06:45 <davidhouse> so you can do that w/o lets.
14:06:49 <SamB> davidhouse: sortof
14:07:01 <xerox> Nice to know.  I wonder I see it for the first time just today.
14:07:07 <xerox> I wonder why, I mean.
14:07:30 <SamB> > Foo; data Foo = Foo deriving Show
14:07:31 <oasisbot>  parse error on input `data'
14:07:42 <SamB> no, not module level
14:07:51 <xerox> > data Foo = Foo deriving (Show); Foo
14:07:51 <oasisbot>  parse error on input `data'
14:07:57 <xerox> It would be fun, tho.
14:08:06 <SamB> must be in a let or where
14:09:01 <davidhouse> data/type etc in lambdabot would make it a lot more powerful.
14:09:15 <SamB> e.g. "main = print it where it = $EXPR"
14:10:43 <davidhouse> no-one knows much about HUnit, it seems.
14:12:41 <xerox> > (2 /) . product . take 30 . iterate (sqrt . (+ 1/2) . (/2)) $ sqrt (1/2)
14:12:42 <oasisbot> 3.1415926535897927
14:12:58 <davidhouse> > error "hello" :: String == error "hello" :: String
14:12:58 <oasisbot>  parse error on input `=='
14:13:03 <xerox> davidhouse: I'm sorry I don't .-(
14:13:06 <davidhouse> > (error "hello" :: String) == (error "hello" :: String)
14:13:07 <oasisbot> Exception: hello
14:13:11 * davidhouse emails the maintainer.
14:15:26 <SamB> davidhouse: you don't have time to wait for him to get up?
14:15:41 <davidhouse> i don't think he's a #haskell-er.
14:15:42 <SamB> oh, other maintainer
14:15:53 <SamB> what are you doing?
14:15:59 <SamB> to lambdabot, I mean...
14:16:30 <davidhouse> "with HUnit, how can i check my algorithm correctly errors?"
14:17:12 <davidhouse> my algorithm calls error on invalid input. i want to check it does so correctly.
14:17:21 <SamB> ah
14:17:25 <davidhouse> this would be possible if one could compare error calls.
14:17:50 <SamB> to do that requires Control.Exception, methinks
14:18:17 <davidhouse> perhaps.
14:18:21 <Igloo> davidhouse: an Assertion is an IO (), so you can catch errors
14:18:38 <davidhouse> Igloo: i guessed as much, how?
14:19:18 <Igloo> With try, catch, etc
14:19:32 <SamB> @index catch
14:19:33 <oasisbot> Control.Exception, System.IO.Error, Prelude
14:19:47 <Igloo> I think the Control.Exception functions catch more errors than the H98 ones
14:19:50 <SamB> @type Control.Exception.catch
14:19:52 <oasisbot> forall a.
14:19:52 <oasisbot>          IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
14:20:12 <SamB> Prelude.catch is for IO errors only
14:20:23 <SamB> @type catch
14:20:24 <davidhouse> @type System.IO.error
14:20:24 <oasisbot> forall a. IO a -> (IOError -> IO a) -> IO a
14:20:25 <oasisbot> Not in scope: `System.IO.error'
14:20:31 <davidhouse> @type System.IO.Error.error
14:20:32 <oasisbot> Not in scope: `System.IO.Error.error'
14:20:36 <davidhouse> @hoogle catch
14:20:37 <oasisbot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
14:20:37 <oasisbot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
14:20:37 <oasisbot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
14:20:46 <davidhouse> @type System.IO.Error.catch
14:20:47 <oasisbot> forall a.
14:20:47 <oasisbot>          IO a -> (IOError -> IO a) -> IO a
14:21:20 <bolrod> can you believe it >:/   I got a  6/10   because by program 'didn't compile'    
14:21:23 <bolrod> argh
14:21:30 <davidhouse> will any of these work without me having to change my calls to error?
14:22:14 <Cale-work> bolrod: it didn't, or did they somehow mess up the build?
14:22:30 <bolrod> well..  it required  -fglasgow-exts
14:22:40 <bolrod> and I was too lazy to put it in {- .... -}
14:22:45 <Cale-work> oh, I think you can contest that then
14:22:48 <bolrod> so they just compiled with  ghc -make I guess
14:22:52 <bolrod> I did
14:23:08 <bolrod> but it clearly said in the source code that it required -fglasgow-exts ;/
14:23:14 <bolrod> so I don't know why they didn't figure it out
14:23:29 <SamB> they never looked in there?
14:23:31 <davidhouse> you had time to write that it required -fglasgow-exts but not enough to put the pragma in?
14:23:55 <bolrod> blah.. I didn't know about it then.. or I did
14:24:01 <bolrod> but didn't know the exact syntax
14:24:07 <SamB> ah
14:24:13 <bolrod> anyway.. that's not the point
14:24:17 <bolrod> it does compile ;)
14:24:25 <SamB> {-# OPTIONS_GHC -fglasgow-exts #-} ?
14:24:30 <bolrod> yes I know 
14:24:32 <bolrod> now I do ;)
14:24:45 <bolrod> I just tried it also
14:24:57 <bolrod> hell.. next time I'll require the -cpp
14:25:05 <bolrod> and put in insanely macro's
14:25:08 <bolrod> >_>
14:25:17 <SamB> they evidently will not notice
14:25:32 <bolrod> probably not if I give them the make file
14:25:38 <bolrod> >_
14:25:39 <bolrod> >_>
14:25:39 <davidhouse> yeah, give a makefil.
14:25:42 <davidhouse> easiest way.
14:25:53 <bolrod> it were just 3 friggin' files! 
14:25:55 <bolrod> :P
14:26:07 <SamB> build.sh, I say!
14:26:10 <bolrod> should I include a ./configure script as well?!
14:26:19 <bolrod> SamB: they'll probably use windows *cough* *cough*
14:26:27 <SamB> um
14:26:29 <SamB> okay.
14:26:38 <bolrod> yah
14:26:46 <bolrod> or OS X
14:26:47 <SamB> why would they be using Haskell if they are that type?
14:26:53 <bolrod> but probably windows
14:27:04 <bolrod> because they just check the tests?
14:27:06 <SamB> OS X has a shell, doesn't it?
14:27:14 <bolrod> it does
14:27:14 <musasabi> yes.
14:27:22 <xerox> OS X is UNIX based yep.
14:27:28 <bolrod> with a MACH kernel
14:27:40 <xerox> And Mach-O binaries, grrrr.
14:27:45 <musasabi> Many people seem to use Haskell on windows.
14:27:51 <SamB> is that Mach Zero?
14:27:56 <bolrod> many people seem to use windows also
14:27:57 <SamB> as in, they don't go anywhere?
14:27:58 <bolrod> maybe that is the cause
14:28:17 <bolrod> I hate windows >_<
14:28:41 <bolrod> in the university.. I'll walk 50 meters extra to NOT use a windows computer
14:28:51 <xerox> GHC Interactive System (Haskell 98): Mach-O executable ppc
14:28:56 <Cale-work> musasabi: really? I was kind of thinking the opposite. Given the number of windows users, you'd expect more windows Haskell users.
14:28:59 <SamB> I'm planning to stop hating windows when I can use ReactOS
14:29:13 <yaarg> luckily at my university everybody hates windows :D
14:29:23 <bolrod> SamB: because?...
14:29:35 <musasabi> Cale-work: well if one thinks about the frequencies then *nix users are a much more common.
14:29:39 <SamB> then I can hate Microsoft's version instead
14:29:41 <alar> SamB: do you planto start hating ReactOS?
14:30:14 <musasabi> Cale-work: but quite regularly people send bug reports and questions about why some piece of Haskell code does not work on windows.
14:30:22 <SamB> have you considered that maybe windows could be good, but just doesn't try?
14:31:55 <wilx> Hating Windows is fashion.
14:32:10 <yaarg> heh
14:33:48 <SamB> anyway, I think the thing I dislike most about windows is the way it abuses programmers
14:34:14 <musasabi> *nix does it in countless ways too.
14:34:18 <alar>             
14:34:29 <xerox> Err... ?
14:34:41 <musasabi> and usually the gripes we have about windows is about it doing things differently from *nix.
14:34:46 <alar> I think the thing I dislike most about FreeBSd is the way it abuses admins
14:34:47 <musasabi> (from a programming pov)
14:34:49 <SamB> musasabi: I mean the way it makes it hard to compile things and stuff like that
14:35:05 <wilx> Hard? :)
14:35:21 <wilx> MSVC is pretty decent and works well.
14:35:23 <SamB> and navigate by non-GUI means
14:35:29 <alar> wilx: sometimes impossible
14:35:36 <alar> hard is mild word
14:35:38 <SamB> wilx: um. only if you, uh, *have* it
14:36:08 <davidhouse> the problem with windows is that 1) stuff isn't free 2) free stuff isn't available for it 3) free stuff that is available still does it the unix way (cmd prompt) 4) stuff isn't configurable enough (it's build for Average Joe not Power User)
14:36:16 <SamB> anyway, I guess the way the system is not really anywhere near as integrated as it tries to look
14:37:09 <SamB> and it doesn't have enough support for advanced users...
14:40:28 <SamB> presumably, ReactOS will want to support advanced users, seeing as, well, they are writing it... and no one is paying them to dumb it down.
14:44:16 <bolrod> sweet 8)
14:44:30 <bolrod> some other guy checked it with the -fglasgow-exts
14:44:32 <bolrod> and it worked
14:44:35 <bolrod> got 10/10  :D
14:44:46 <musasabi> Just getting automated testing for my libraries on windows would be enough for me.
14:45:03 <SamB> so what do you get if it compiles and segfaults?
14:47:13 <davidhouse> i've never actually seen a haskell segfault.
14:47:27 <davidhouse> i guess you get kudos for finding a bug in GHC :)
14:47:31 <sjanssen> davidhouse: would you like one?
14:47:50 <davidhouse> sjanssen: i'm not sure :S
14:47:56 <SamB> uh
14:48:15 <SamB> you could try dereferencing a nullPtr
14:48:41 <NameTab> just for clearance: when do I use a Let ... in ... and when do I use a where .. = ...
14:49:15 <sjanssen> let r = unsafePerformIO $ newIORef undefined in do writeIORef r 'x'; readIORef r >>= putStrLn
14:49:22 <davidhouse> NameTab: they're almost interchangeable.
14:49:32 <NameTab> davidhouse: "almost" ? :)
14:49:37 <davidhouse> NameTab: yeah.
14:49:43 <SamB> you can't use a where in an expression, despite xerox's code working before...
14:49:49 <NameTab> davidhouse: exactly my point
14:49:52 <davidhouse> there's some cases where you can't use where.
14:50:05 <davidhouse> where clauses have to be at the top function level.
14:50:13 <SamB> I mean, this is not allowed:
14:50:19 <SamB> > x where x = ()
14:50:20 <oasisbot> ()
14:50:26 <monochrom> hehehe!
14:50:39 <SamB> ... even though it seems to work
14:50:45 <SamB> > (x where x = ())
14:50:45 <oasisbot>  parse error on input `where'
14:50:45 <NameTab> heh lol :)
14:50:48 <davidhouse> you can't do foo = let foo' = (foo'' where foo'' = 5) in foo'
14:50:59 <bolrod> don't think oasisbot will accept any where
14:51:02 <bolrod> only let
14:51:05 <monochrom> There is an implicit let ... in  when you use the bot
14:51:20 <SamB> yeah, we already discussed this
14:51:22 <bolrod> you can't use where in the ghci either I think
14:51:23 <davidhouse> it'd have to be foo = let foo' = foo''; foo'' = 5 in foo'
14:51:26 <SamB> > x; x = 1
14:51:27 <oasisbot> 1
14:51:57 <SamB> see logs!
14:51:59 <monochrom> > (let {x = y} where y = () in x)
14:51:59 <oasisbot>  parse error on input `where'
14:52:24 <NameTab> tomorrow is gonna suck so hard :/
14:52:25 <monochrom> > (let x = y where y = () in x)
14:52:26 <oasisbot> ()
14:52:35 <NameTab> hmmk, something totally different
14:52:35 <monochrom> > (let {x = y where y = ()} in x)
14:52:36 <oasisbot> ()
14:52:42 <monochrom> those are allowed
14:52:48 <sjanssen> too bad we don't have 'v' to play around with anymore
14:53:01 <NameTab> I read a file, I add stuff and such and I want to overwrite the file again, save the new version or so
14:53:13 <SamB> 'v'?
14:53:23 <davidhouse> @hoogle unsafePerformIO
14:53:23 <oasisbot> Foreign.unsafePerformIO :: IO a -> a
14:53:28 <NameTab> I think lazy evaluation reads the file so late that when I try to overwrite, the file is still in use because it's only just been read
14:53:36 <davidhouse> @hoogle newIORef
14:53:37 <oasisbot> Data.IORef.newIORef :: a -> IO (IORef a)
14:53:41 <monochrom> > unsafePerformIO
14:53:42 <oasisbot>  Not in scope: `unsafePerformIO'
14:53:51 <SamB> NameTab: you mean it hasn't been read yet
14:53:58 <davidhouse> sjanssen: your segfaulter works fine in ghci ;)
14:53:58 <monochrom> > unsafePerformIO (putStrLn "")
14:53:59 <sjanssen> SamB: lambdabot used to change > E into "let v = show (E) in v", so if you referenced v, you could do silly tricks
14:53:59 <oasisbot>  Not in scope: `unsafePerformIO'
14:54:11 <monochrom> > unsafePerformIO (putStrLn " Not in scope: `unsafePerformIO'")
14:54:12 <oasisbot>  Not in scope: `unsafePerformIO'
14:54:16 <monochrom> Heh!
14:54:35 <NameTab> SamB: well, when I try to write it should have been read already, but I can't write because the file is "locked" 
14:54:35 <sjanssen> davidhouse: it did?  when I ran it, it didn't crash
14:54:48 <monochrom> > show it
14:54:48 <oasisbot>  Not in scope: `it'
14:54:50 <davidhouse> yes, that's what i said.
14:55:08 <davidhouse> it works.
14:55:09 <monochrom> > show v
14:55:10 <oasisbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:55:10 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:55:10 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:55:10 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:55:13 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:55:16 <oasisbot> [6 @more lines]
14:55:21 <SamB> NameTab: be glad it doesn't overwrite the file while it is still reading it!
14:55:24 <monochrom> I think v is still there.
14:55:26 <sjanssen> davidhouse: now try let r = unsafePerformIO $ newIORef undefined in do writeIORef r "x"; readIORef r >>= putChar
14:55:36 <davidhouse> ah, nice.
14:55:52 <sjanssen> ah, actually 'v' is an hs-plugins bug.  Whoever runs oasisbot probably doesn't have the fix
14:56:31 <SamB> @hoogle FilePath -> IO String
14:56:32 <oasisbot> Prelude.readFile :: FilePath -> IO String
14:56:43 <SamB> it might help if you don't use readFile
14:56:43 <monochrom> > '0':v
14:56:44 <oasisbot> "0\"0\\\"0\\\\\\\"0\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:56:44 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:56:44 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:56:44 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:56:47 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
14:56:50 <oasisbot> [6 @more lines]
14:57:02 <alar> what is v?
14:57:17 <davidhouse> > take 10 v
14:57:18 <oasisbot> "\"\\\"\\\\\\\"\\\\\\"
14:57:24 <sjanssen> v is the result of showing your expression
14:57:38 <davidhouse> let v = show EXPR in v
14:57:38 <sjanssen> > take 1 v
14:57:39 <oasisbot> "\""
14:57:42 <sjanssen> > head v
14:57:43 <NameTab> SamB: the point is, I want to have it read *before* I overwrite it, so that I *can* overwrite it safely
14:57:43 <oasisbot> Exception: <<loop>>
14:57:44 <SamB> > take 10 (map toInt v)
14:57:45 <oasisbot>  Not in scope: `toInt'
14:58:02 <sjanssen> > v !! 10
14:58:03 <oasisbot> Exception: <<loop>>
14:58:45 <SamB> NameTab: well, you could use an unlazy method to read it, or you could force it
14:59:01 <monochrom> '0':read v
14:59:07 <monochrom> > '0':read v
14:59:08 <oasisbot> Exception: <<loop>>
14:59:13 * monochrom cries
14:59:33 <alar> @type v
14:59:34 <oasisbot> Not in scope: `v'
14:59:40 <monochrom> Yes, read the whole read into memory.
14:59:43 <monochrom> err
14:59:48 <monochrom> Yes, read the whole file into memory.
14:59:51 <alar> 1:v
14:59:52 <sjanssen> > typeOf v
14:59:53 <NameTab> SamB: another way asking the same method: what's an easy&fast&rather useless way to have lazy evaluation read a file, while I'm actually only going to use it just before I'm going to write it
14:59:53 <oasisbot> [Char]
15:00:00 <alar> > 1:v
15:00:01 <oasisbot>  add an instance declaration for (Num Char)
15:00:11 <alar> ah
15:00:13 <alar> got it
15:00:53 <SamB> do {data <- readFile name; when (length data == 0) (fail "Empty file"); process data >>= writeFile name} would probably work
15:00:54 <NameTab> I think I understood that my teacher said it was possible to e.g. calculate the lenght of a file so that it is already read, while only later actually used but so that I can write it when I want to
15:01:05 <NameTab> damn, my english sucks
15:01:15 <bolrod> omg... oasisbot has the 'v' thing again?
15:01:21 <bolrod> > show v
15:01:22 <oasisbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:22 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:22 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:22 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:25 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:26 <bolrod> pfff
15:01:27 <SamB> > v
15:01:28 <monochrom> Yes, that will force "length data", which will force all of data.
15:01:28 <oasisbot> [6 @more lines]
15:01:30 <oasisbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:33 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:36 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:39 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:40 <bolrod> SamB: YESSS
15:01:42 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:01:42 * monochrom cries more
15:01:45 <oasisbot> [6 @more lines]
15:01:49 <SamB> > length v
15:01:49 <sjanssen> bolrod: oasisbot is running with an unfixed version of hs-plugins
15:01:50 <oasisbot> Exception: <<loop>>
15:01:56 <bolrod> yeah
15:02:04 <bolrod> STOP IT >_<
15:02:10 <monochrom> oasisbot = lambdabot ?
15:02:11 * bolrod throws a v to SamB's head
15:02:20 <bolrod> obviously not since lambdabot was fixed!
15:02:22 <davidhouse> > throw v
15:02:22 <oasisbot>  Not in scope: `throw'
15:02:29 <davidhouse> > Control.Exception.throw v
15:02:30 <oasisbot>  Not in scope: `Control.Exception.throw'
15:02:33 <davidhouse> :(
15:02:37 <davidhouse> @hoogle throw
15:02:37 <NameTab> lol
15:02:37 <oasisbot> Control.Exception.throw :: Exception -> a
15:02:37 <oasisbot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
15:02:37 <oasisbot> Control.Exception.throwDyn :: Typeable exception => exception -> b
15:02:40 <sjanssen> > error v
15:02:41 <oasisbot> Add a type signature
15:02:43 <monochrom> > unsafePerformIO (putStrLn " Not in scope: `unsafePerformIO'")
15:02:43 <SamB> oasisbot == lambdabot, but with a different binary
15:02:44 <oasisbot>  Not in scope: `unsafePerformIO'
15:02:46 <bolrod> argh
15:02:49 <sjanssen> > error v :: String
15:02:50 <monochrom> You can still do that :)
15:02:50 <oasisbot> Exception
15:03:08 <davidhouse> @id hello
15:03:08 <oasisbot> hello
15:03:14 <davidhouse> @id /me does this work?
15:03:14 * oasisbot does this work?
15:03:17 <davidhouse> hehe :)
15:03:20 <bolrod> jajaja
15:03:22 <bolrod> :D
15:03:30 <NameTab> @id /me has a bug
15:03:31 * oasisbot has a bug
15:03:33 <davidhouse> @id /quit
15:03:33 <oasisbot> /quit
15:03:36 <davidhouse> :(
15:03:36 <bolrod> oeh
15:03:40 <bolrod> lawl
15:03:41 <monochrom> @id Not in scope: `unsafePerformIO'
15:03:41 <oasisbot> Not in scope: `unsafePerformIO'
15:03:42 <SamB> special processing?
15:03:47 <NameTab> lol
15:03:49 <NameTab> how about
15:03:52 <NameTab> @id /hop
15:03:52 <oasisbot> /hop
15:03:53 <davidhouse> SamB: no
15:03:55 <SamB> @id /ping #haskell
15:03:55 <oasisbot> /ping #haskell
15:03:56 <bolrod> :]
15:04:05 <davidhouse> typing something into the channel doesn't send it to the server
15:04:15 <bolrod> so does /me
15:04:15 <davidhouse> your client does /* -> CTCP.
15:04:17 <sjanssen> @id @id
15:04:17 <oasisbot>  @id
15:04:30 <xerox> @id @yow
15:04:30 <oasisbot>  @yow
15:04:30 <bolrod> @id@id
15:04:31 <oasisbot> Unknown command, try @list
15:04:31 <SamB> @. id id foo
15:04:31 <oasisbot> foo
15:04:44 <davidhouse> @. id id arr
15:04:44 <oasisbot> arr
15:04:47 <SamB> @. l33t vixen foo
15:04:48 <oasisbot> compose module failed: Parse error: "l33t"
15:04:49 <davidhouse> @. id arr
15:04:49 <oasisbot> Get out of me way, yeh landlubber
15:04:52 <xerox> @state
15:04:52 <oasisbot> [(' ',0.0,0.1),('B',1.9999999999999997e-2,2.9999999999999992e-2),('I',6.999999999999998e-2,7.999999999999999e-2),('L',0.19,0.23000000000000004),('L',0.31000000000000005,0.3500000000000001),(' ',0.
15:04:52 <oasisbot> 31000000000000005,0.32000000000000006),('G',0.35000000000000003,0.36000000000000004),('A',0.36000000000000004,0.37000000000000005),('T',0.45,0.46),('E',0.48000000000000004,0.49000000000000005),('S',
15:04:52 <oasisbot> 0.56,0.5700000000000001)]
15:04:52 <oasisbot>  
15:04:54 <bolrod> @id /msg bolrod test
15:04:54 <oasisbot> /msg bolrod test
15:04:56 <xerox> ouch.
15:04:58 <stubert> ?
15:04:59 <xerox> @state
15:05:02 <xerox> Okay.
15:05:08 <monochrom> @church
15:05:08 <oasisbot> Unknown command, try @list
15:05:10 <stubert> whats with all the code
15:05:16 <SamB> @. vixen arr
15:05:16 <oasisbot> you're cute. :)
15:05:20 <stubert> thanks
15:05:21 <stubert> <3
15:05:23 <xerox> @. state . vixen
15:05:39 <xerox> No I'm missing something.
15:05:48 <bolrod> @. leet arr
15:05:48 <oasisbot> compose module failed: Parse error: "leet"
15:05:56 <bolrod> what was it again
15:05:57 <bolrod> :]
15:05:58 <stubert> @, hi there
15:05:58 <oasisbot> compose module failed: Parse error: "hi"
15:06:02 <xerox> @state
15:06:02 <oasisbot> Not enough arguments to @.
15:06:06 <stubert> @, quit
15:06:06 <oasisbot> Not enough arguments to @.
15:06:10 <stubert> @ quit
15:06:10 <xerox> @. arr . state vixen
15:06:10 <oasisbot> Well me 'earties, let's see what crawled out of the bung hole...
15:06:13 <SamB> is there no leet plugin?
15:06:13 <xerox> @state
15:06:14 <oasisbot> i really hate arabs!
15:06:18 <xerox> Okay, that as it.
15:06:18 <stubert> LOL
15:06:20 <SamB> @1337 foo
15:06:20 <oasisbot> Unknown command, try @list
15:06:25 <stubert> @list
15:06:25 <oasisbot> list [module|command]. Where modules is one of:
15:06:25 <oasisbot> babel base compose darcsPatchWatch dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo
15:06:25 <oasisbot> topic type unlambda version vixen where
15:06:34 <stubert> @dice
15:06:34 <oasisbot> "dice" (line 1, column 1):
15:06:34 <oasisbot> unexpected end of input
15:06:34 <oasisbot> expecting digit
15:06:41 <Cale-work> @. elite keal
15:06:41 <oasisbot> Kn0\/\/ joo knOw t|-|I$ 24 p3riodz0rz K3al zE(r37TM
15:06:42 <SamB> @list elite
15:06:42 <oasisbot> elite provides: elite
15:06:45 <stubert> i guess this bot is in development eh?
15:06:47 <davidhouse> @keel
15:06:47 <oasisbot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
15:06:50 <davidhouse> @keal
15:06:50 <oasisbot> can haskell pipe the raw irrational megaequation into an analog device
15:06:54 <monochrom> @unlambda (\x y -> y x)
15:06:54 <oasisbot> unlambda: Unknown operator '('
15:06:54 <davidhouse> @help keal
15:06:55 <oasisbot> keal. Talk like Keal
15:07:07 <Cale-work> @keal
15:07:07 <bolrod> :]
15:07:07 <oasisbot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
15:07:10 <davidhouse> @. elite . quote
15:07:11 <oasisbot> No+ En0UgH AR9u/\/\3NtS t0 @.
15:07:14 <SamB> @dice 2000
15:07:14 <oasisbot> 2000 => 2000
15:07:25 <xerox> @. elite quote
15:07:25 <oasisbot> kZM SaYS: /\/\Y PR0GrA/\/\ (0NT4Inz0rz A 8u9. How uN9RAtEFu1, AFtEr Al| I'\/3 done For iT.
15:07:29 <bolrod> @dice 10d10
15:07:30 <oasisbot> 10d10 => 56
15:07:30 <Cale-work> @dice 2000d6
15:07:30 <oasisbot> 2000d6 => 0
15:07:31 <davidhouse> @. elite . quote
15:07:31 <oasisbot> no7 3NOuG|-| Ar9UM3n+z 7o @.
15:07:36 <davidhouse> @. elite quote
15:07:36 <bolrod> lawl
15:07:36 <oasisbot> +\/\/b sAy$: But, i l0VE mY Job. it'$ |ikE 83iNG iN A Ro(K 84ND. i.E. no p4Y, Bu+ phuN.
15:07:40 <xerox> davidhouse: it's just one composition.
15:07:41 <NameTab> xerox: can I pm you?
15:07:46 <xerox> NameTab: yes sure.
15:07:53 <monochrom> > unsafePerformIO
15:07:54 <oasisbot>  Not in scope: `unsafePerformIO'
15:08:04 <Cale-work> hm, something must be wrong with dice. 
15:08:06 <davidhouse> xerox, so you use . to compose more than one command?
15:08:10 <Cale-work> @dice 2000d6
15:08:10 <oasisbot> 2000d6 => 0
15:08:11 <Cale-work> @dice 2000d6
15:08:11 <oasisbot> 2000d6 => 0
15:08:16 <monochrom> Can I get the bot to give error messages in leet notation?
15:08:16 <bolrod> @. elite unsafePerformIO
15:08:16 <oasisbot> compose module failed: Parse error: "unsafePerformIO"
15:08:17 <davidhouse> > Foreign.unsafePerformIO $ putStrLn "hi"
15:08:18 <oasisbot>  Not in scope: `Foreign.unsafePerformIO'
15:08:32 <Cale-work> well, at least with rather high probability, something is wrong :)
15:08:46 <bolrod> @id > id
15:08:46 <oasisbot> > id
15:09:15 <davidhouse> lambdabot doesn't intepret its own commands.
15:09:19 <davidhouse> @id > "hello"
15:09:19 <oasisbot> > "hello"
15:09:20 <bolrod> > putStrLn "test"
15:09:20 <oasisbot> No IO allowed
15:09:26 <bolrod> ;o
15:09:28 <SamB> @. elite eval Foreign.unsafePerformIO $ putStrLn "hi"
15:09:29 <oasisbot> NO7 In 5(OpE: `FOrEIgn.Un$afEp3rfoRMIo'
15:09:35 <monochrom> Yay!
15:09:37 <bolrod> :]
15:10:01 <sjanssen> @. elite eval head v
15:10:02 <oasisbot> eX(3P+IoN: <<Lo0P>>
15:10:04 <bolrod> @id /me is co00oo00ol
15:10:04 * oasisbot is co00oo00ol
15:10:05 <davidhouse> @. elite eval Foreign.unsafePerformIO $ putStrLn "hi"
15:10:06 <oasisbot> NOt IN zcop3: `FOR3IGN.Un5Aph3P3Rphormio'
15:10:08 <monochrom> @. elite eval 5+'4'
15:10:09 <oasisbot> ADD 4N In5T4nCE DEc1arAti0n FoR (NuM CH4r)
15:10:17 <bolrod> sjanssen: xD
15:10:32 <bolrod> @. elite eval id "TEZZTING"
15:10:34 <oasisbot> "+ezZTING"
15:10:36 <bolrod> xD
15:10:56 <xerox> davidhouse: exactly.
15:10:56 <bolrod> @. elite eval id /me rockorz you all
15:10:57 <monochrom> I want that in ghc!
15:10:57 <oasisbot> NOT IN 5COPE: `yOu'
15:11:06 <bolrod> @. elite eval id $ /me rockorz you all
15:11:07 <oasisbot> pars3 3rr0r ON INput `/'
15:11:24 <davidhouse> @. vixen . elite . eval head v
15:11:24 <oasisbot> compose module failed: Parse error: "head"
15:11:33 <davidhouse> @. vixen . elite . eval 5 + 4
15:11:33 <bolrod> ouch
15:11:33 <oasisbot> compose module failed: Parse error: "5"
15:11:38 <davidhouse> @. vixen . elite . (eval 5 + 4)
15:11:38 <oasisbot> compose module failed: Parse error: "(eval"
15:11:43 <SamB> @. elite id /me rockzorz you all
15:11:43 * oasisbot ro(Ks0rs YOU ALl
15:11:45 <davidhouse> @. vixen . elite . eval (5 + 4)
15:11:45 <oasisbot> compose module failed: Parse error: "(5"
15:11:50 <davidhouse> @. vixen . elite . quote
15:11:50 <oasisbot> :)
15:11:54 <davidhouse> @. vixen . elite . quote
15:11:54 <oasisbot> ?
15:11:56 <davidhouse> @. vixen . elite . quote
15:11:56 <oasisbot> and now that I have finished with you, you may go!
15:11:59 <davidhouse> heh.
15:12:07 <davidhouse> @. elite . vixen . quote
15:12:07 <oasisbot> h4HaHa
15:12:09 <davidhouse> @. elite . vixen . quote
15:12:10 <oasisbot> 9UY$ Wh0 cAn $peAx LaTIn r3A|Ly +urN m3 On.
15:12:11 <monochrom> I want to add that to ghc and use it to replace oleg's copy of ghc!  Imagine him seeing "overlapping undecidable ambiguous instances..." in leet notation...
15:12:28 <bolrod> :D
15:12:38 <xerox> davidhouse: the thing is that @compose vixen arr lost what the pirate said... forever.  Hence I came up with @compose vixen compose state arr, and @state afterwards, to see what's being said by the 'eartie.
15:12:41 <bolrod> how about 3 pages of errors in leet
15:12:58 <SamB> the tree snippets should probably be left alone, though
15:13:15 <monochrom> Yes, that "overlapping undecidable ambiguous instances..." is 3 pages long.
15:13:17 <davidhouse> @. elite . vixen . quote
15:13:17 <oasisbot> NO7|-|In9 gOod I$ on 7V
15:14:05 <bolrod> @. elite list
15:14:08 <bolrod> @. elite. list
15:14:13 <bolrod> @list
15:14:17 <bolrod> @listcommands
15:14:21 <bolrod> urh
15:14:24 <monochrom> it has died
15:14:27 <bolrod> @help
15:14:36 <bolrod> I PM'ed it ;/
15:14:41 <bolrod> does it die from that?
15:14:44 <sjanssen> oh no! we are botless again!
15:14:52 <oasisbot> |I$t [Module|coMm4Nd]. wHEre /\/\oDUL35 iz0rz 0ne 0f: BaBEL 8A53 (o/\/\pO$e daR(Sp4Tc|-|\/\/47ch DIcE DIC+ DJInn DrHYL0 du/\/\mY 31i+3 f4(t HAdDo(k HELp |-|0ogL3 xARMa |amBd4 Loc4L+iMe 109 /\/\OrE p|
15:14:53 <SamB> maybe it is just taking a while?
15:14:55 <oasisbot> plUgz P0L| PR37ty Quo+3 $E4RcH sEeN s|Ap 5p31l z+ate zySTeM 7oDo TOpIC TYpe Un|A/\/\8D4 VER$ion \/ixen \/\/|-|eR3
15:14:56 <SamB> ah, yes
15:14:58 <oasisbot> compose module failed: Parse error: "elite."
15:14:58 <bolrod> O_o
15:15:00 <oasisbot> list [module|command]. Where modules is one of:
15:15:02 <oasisbot> babel base compose darcsPatchWatch dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo
15:15:04 <sjanssen> apparently elite is rather slow
15:15:05 <oasisbot> topic type unlambda version vixen where
15:15:07 <oasisbot> Unknown command, try @list
15:15:09 <oasisbot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:15:22 <bolrod> @. vixen . list
15:15:22 <oasisbot> Math is hard. Let's go shopping.
15:15:27 <bolrod> hahaha
15:15:29 <davidhouse> :)
15:15:59 <bolrod> @. elite . elite "test"
15:15:59 <oasisbot> compose module failed: Parse error: "\"test\""
15:16:04 <bolrod> @. elite . elite list
15:16:04 <oasisbot> |is7 [mOdul3|C0MmAND]. \/\/|-|ErE M0dU1e5 I$ 0n3 OF: b4BEL 84$e Comp053 Dar($P47(h\/\/4+C|-| di(e DicT DJInn dr|-|ylo Du/\/\/\/\Y 31I7E ph4(T hadD0xX h31p |-|00G|e K4R/\/\4 l4/\/\8d4 1oc4lti/\/\3
15:16:04 <oasisbot> 10G MoR3 p1 P|U95 p0|| PREt7Y Qu0+E $3arch seen 5L4p sP31l $T4T3 zyS+3/\/\ 7Od0 tOPi( +yP3 uN14m8da \/3rSION \/ix3N w|-|3R3
15:16:07 <SamB> @. vixen google lambdabot
15:16:08 <oasisbot> website?
15:16:23 <bolrod> @search lambdabot
15:16:23 <oasisbot> Unknown command, try @list
15:16:46 <bolrod> @. elite. arr
15:16:46 <oasisbot> compose module failed: Parse error: "elite."
15:16:58 <bolrod> @. elite . arr
15:16:59 <oasisbot> NOT EN0u9H aRGU/\/\eN+5 t0 @.
15:17:06 <bolrod> augh
15:17:35 <monochrom> what is arr?
15:17:38 <NameTab> Muad_Dib: ur up late
15:17:38 <davidhouse> @arr
15:17:38 <oasisbot> I'll crush ye barnacles!
15:17:41 <davidhouse> @arr
15:17:41 <oasisbot> Aye
15:17:42 <davidhouse> @arr
15:17:42 <oasisbot> Shiver me timbers!
15:17:44 <bolrod> @id \076
15:17:44 <davidhouse> @arr
15:17:44 <oasisbot> \076
15:17:44 <oasisbot> Yeh scurvy dog...
15:17:46 <davidhouse> etc.
15:18:37 <bolrod> @. elite . elite . elite . id test
15:18:38 <oasisbot> compose module failed: Parse error: "test"
15:18:44 <bolrod> @. elite . elite . elite id test
15:18:44 <oasisbot> +3S+
15:18:48 <Muad_Dib> NameTab: I was visiting grandma, where I defended you ! :)
15:18:59 <bolrod> O-o?
15:18:59 <NameTab> thanx
15:19:05 <NameTab> but why did you need to defend me?
15:19:35 <Muad_Dib> NameTab: re-exam matters ;)
15:19:37 <NameTab> ahh
15:19:38 <NameTab> cool
15:19:40 <NameTab> pwnage :)
15:19:42 <bolrod> personal business? -.-
15:19:52 <bolrod> :)
15:19:53 <Muad_Dib> btw, when's the FP exam? was that today or?
15:19:59 <NameTab> FP is tomorrow
15:20:07 <bolrod> today actually -.-
15:20:11 <bolrod> >_<
15:20:16 <davidhouse> is grandma a lecturer?
15:20:32 <bolrod> grandma is the mother of one of their parents probably
15:20:33 <bolrod> :x
15:20:35 <Muad_Dib> davidhouse: she has wisdoms you wouldn't believe :)
15:20:55 <Muad_Dib> bolrod, NameTab, both gl with the exam (though you surely don't need any luck ;))
15:21:13 <bolrod> we don't?
15:21:17 <monochrom> yeah they need lambda
15:21:23 <bolrod> I guess not >_>
15:21:24 <NameTab> Muad_Dib: we don't need luck, we need more knowledge!
15:21:27 <NameTab> at least, I do
15:21:32 <bolrod> just got a 10 for my 2nd assignment =)
15:21:34 <bolrod> \o/
15:21:40 <Muad_Dib> congrats bolrod :)
15:21:43 <NameTab> nice, I got a 6,5
15:21:45 <bolrod> thx
15:22:01 <bolrod> 6.5 hm.. not bad :)
15:22:04 <monochrom> arrows will also be good
15:22:14 <bolrod> if you supply the bows
15:22:17 <bolrod> I'll get the arrows
15:23:21 * Muad_Dib puts a Monad on bolrod's head
15:23:30 <Muad_Dib> did you lot hand in the 3rd assignment yet?
15:23:32 * bolrod returns 
15:23:41 * monochrom joins
15:23:46 * bolrod hops
15:23:57 * Cale-work maps
15:24:07 <NameTab> Muad_Dib: nope, only slightly started even :S
15:24:17 * bolrod 2nds det
15:25:43 <bolrod> stubert?!
15:25:45 <bolrod> Schubert!
15:25:48 <bolrod> -.-
15:26:13 <Muad_Dib> Luckily shapr isn't alive or he would force us to move into #haskell-blah with this nonsense talk :P
15:26:34 <bolrod> or hit you over the head with a unicycle
15:26:35 <bolrod> :x
15:26:40 <bolrod> :]
15:27:28 <jip> didn't shapr resign?
15:27:54 <Muad_Dib> resign from what?
15:27:59 <jip> channel op
15:28:35 <bolrod> shall we ask?
15:28:38 <bolrod> @get-shapr
15:28:38 <oasisbot> shapr!!
15:28:40 <bolrod> :]
15:30:37 <monochrom> where is shapr?
15:31:45 <bolrod> sleeping?
15:31:55 <newsham> mmm sleep
15:33:08 <bolrod> hmmm sleeep
15:33:23 * bolrod thinks about polyphasic sleep
15:33:24 <bolrod> hmmmm
15:33:25 <bolrod> :)
15:34:00 <alar> polyphasci sheep
15:34:29 <bolrod> =)
15:34:44 <bolrod> @. elite eval [1..10]
15:34:45 <oasisbot> [1,2,3,4,5,6,7,8,9,10]
15:34:50 <bolrod> @. elite . eval [1..10]
15:34:50 <oasisbot> compose module failed: Parse error: "[1..10]"
15:35:57 <SyntaxNinja> what's the software running haskell.org's wiki?
15:36:19 <bolrod> php?
15:36:20 <Muad_Dib> apache?
15:37:05 <SyntaxNinja> you guys  are so helpful
15:37:07 <sethk> IIS  ?
15:37:17 <sjanssen> SyntaxNinja: MediaWiki
15:37:22 <sethk> gameboy?
15:37:30 * bolrod hits sethk 
15:37:36 <sethk> :)
15:37:56 <SyntaxNinja> sjanssen: thanks :)
15:43:10 <bolrod> does anybody have an idea for the SoC yet?
15:43:28 <Muad_Dib> the SoC?
15:43:54 <SamB> Summer of Code
15:44:00 <Muad_Dib> ah
15:44:58 <Muad_Dib> Bedtime for me though :) nini
15:45:32 <alar> what's SoC?
15:45:55 <alar> (if it is not system-on-chip)
15:46:21 <SamB> Summer of Code
15:46:21 <SamB> Summer of Code
15:46:22 <SamB> Summer of Code
15:46:32 <palomer> Summe of Code
15:46:33 <bolrod> Google
15:46:36 <bolrod> Summer of Code
15:46:45 <palomer> Summer of Cod
15:46:51 <alar> @google Summer of Code
15:46:51 <oasisbot> http://code.google.com/soc/
15:47:01 <SamB> palomer: going cod-fishing?
15:47:06 <shapr> People calling me?
15:47:16 <SamB> shapr: huh?
15:47:22 <palomer> huh!
15:47:25 <bolrod> huh?
15:47:33 <bolrod> and still no ubuntu in the soc
15:48:13 <araujo> it is already there
15:48:20 <alar> shapr: do you know what happened to the lambdabot?
15:49:32 <shapr> I assume that the process or host box died?
15:51:00 <alar> who's its owner?
15:52:12 <bolrod> O_o
15:52:15 <shapr> dons is the maintainer.
15:52:43 <alar> thanks
15:52:43 <bolrod> is Canonical  == Ubuntu ?
15:56:40 <shapr> Can rss have any xhtml embedded in the <description> tags?
15:58:05 <sethk> shapr, I don't believe so, but check me
16:02:29 <kpreid_> shapr: depends entirely on the version and who you listen to
16:02:36 <kpreid_> ...and what the readers actually do
16:03:34 <shapr> I'm trying to hack Oleg's RSS.hs into something that generates both xhtml and rss from the same input value.
16:04:06 <kpreid_> use Atom instead.
16:04:20 <kpreid_> or, generate <description>&lt;p&gt;...</description> because that's what gets done in practice
16:04:45 <shapr> Seems that's perfectly legal: http://blogs.law.harvard.edu/tech/encodingDescriptions
16:06:20 <sethk> hmm.  I wonder if rss tools would actually handle it.
16:09:23 <shapr> Liferea with mozilla renderer seems to handle it just fine.
16:25:28 <a_random_nick> Hello, I am new to haskell, could someone tell me where I could find information on how to create data types with specific bit lengths?
16:25:41 <a_random_nick> Ex. "Word9"
16:26:10 <palomer> like in mlton?
16:26:37 <Lemmih> a_random_nick: You can't.
16:26:39 <a_random_nick> mlton?  I don't know what that is.
16:27:22 <a_random_nick> I can't?  So if I have a network protocol that has these unusual bit fields then I need to make them a combination of current Words and 'Bool'?
16:27:53 <palomer> network protocol? sounds too functional for haskell
16:28:02 * palomer finds it ironic that haskell is called a "functional" programming language
16:28:28 <monochrom> It is really an imperative programming language.
16:28:32 <Lemmih> a_random_nick: A Word16 would do.
16:29:06 <a_random_nick> Are you saying that haskell is not advanced enough to do this?  I doubt that... but what do I know.
16:29:07 <Lemmih> a_random_nick: Or an arrow of Bools.
16:29:14 <Lemmih> *array
16:29:27 <a_random_nick> Ah - now that would work well.  Just clumsy to work with.
16:29:52 <Lemmih> a_random_nick: Arrays of Bools are compiled to bitfields in GHC.
16:30:41 <a_random_nick> palomer: I am interested that you seem to think I shouldn't be using Haskell for network programming.  I assume you have reasons, do you have experience trying this?
16:31:02 <palomer> from my experience, languages like haskell shouldn't be used for low level programming
16:31:13 <palomer> write it in C, then use the FFI 
16:31:29 * palomer remembers when he wrote a midi parser in scheme; what a pain
16:32:07 <a_random_nick> Lemmih: That is helpful knowledge.  If I try to do a data type of: Word8, bitarray 5, Word16, bit array 3 - would this end up as a 32 bit field?
16:33:20 <Lemmih> a_random_nick: No.
16:33:30 <a_random_nick> well, I can write a C preparse (receiver) and postparser (sender), but that seems to destroy the elegance of the solution.  
16:34:27 <palomer> there's nothing elegant about network protocols; they're too functional to be elegant
16:34:30 <Lemmih> a_random_nick: You shouldn't be too concerned with performance.
16:34:58 * Lemmih doesn't grok palomer's use of the word 'functional'.
16:35:25 <a_random_nick> Lemmih: I'm not too concerned with performance, but at each of these interconnections (net->C->haskell->C->net) I end up with a moderate chance for something to go wrong.
16:35:40 <palomer> functional as a synonym to useful
16:36:53 <SamB> and elegance is useless?
16:37:26 <Lemmih> palomer: I know lots of elegant things that are useful.
16:37:40 <monochrom> "functional" has many meanings.
16:38:44 <Lemmih> a_random_nick: Then why are you concerned that it's optimized to a Word32?
16:39:26 <a_random_nick> What I am getting right now is that I should write C functions to perform my recv/send operations and use FFI.  What about making these seperate processes (C Recv -> Unix socket -> haskell -> Unix socket -> C Send)?
16:39:58 <Lemmih> a_random_nick: I wouldn't use the FFI.
16:39:58 <SamB> uh
16:40:08 <a_random_nick> Lemmih: I am merely trying to make my program to meet the network protocol, which has some odd field lengths.
16:40:54 <Lemmih> a_random_nick: I'd make the Haskell data type as convenient as possible and then use a binary parser.
16:41:27 <a_random_nick> Certainly not something I know how to do in Haskell... so it is time for me to learn.
16:41:44 <sethk> a_random_nick, the actual send and receive could be done in haskell or c.  It's the bit manipulation that's less tedious in C
16:42:37 <Lemmih> Jumping to C would be a fair bit slower than just sending it from Haskell.
16:42:45 <SamB> and it wouldn't necessarily be so much less tedious if you only need to do it in a few places
16:43:06 <SamB> considering that you'd have to marshal the stuff in and out...
16:43:08 <Lemmih> And sending from Haskell is very easy and a lot more typed than from C.
16:44:10 <SamB> well, if the data has been smashed to bits, it arguably hasn't got a whole lot of type left to it...
16:45:32 <a_random_nick> So, it might be best if I make my data types use values that make sense in the "real world" (e.g. Integer, NetworkAddress, Bool) and then translate the needed field by a later function just before sending?
16:46:25 <Lemmih> a_random_nick: That's how I would do it, yes.
16:46:28 <vincenz> > 1
16:46:30 <oasisbot> 1
16:47:48 <palomer> Lemmih: name me one elegant thing which is useful
16:47:54 <cge> Err, so I just wrote a program to solve an initial value PDE with a recursive definition for the evolution (u ti xi = 0.5*(u (ti-1) (xi-1)+u (ti-1) (xi+1)) ...), but it is so slow as to be unusable, since it appears to constantly recalculate the u's in the definition. Is there any way to speed this up to a reasonable speed without something terribly imperative?
16:48:01 <palomer> and I mean really useful
16:48:34 <monochrom> replace the function by an array.
16:50:05 <a_random_nick> palomer: what is wrong with darcs?  Is it not 'useful' to you or not elegant?
16:50:53 <cge> monochrom: I can see how that would work, but is there a functional way of doing that? It seems to me I would have to have a main loop, and add the function results to the array as I go along.
16:52:09 <Lemmih> palomer: parsec.
16:53:02 <monochrom> > Array.array (0,1) [(0,0),(1,1)]
16:53:02 <oasisbot>  Not in scope: `Array.array'
16:54:00 <monochrom> http://rafb.net/paste/results/yokKy449.html   is an example.
16:54:23 <monochrom> (YES! You can do THAT!)
16:54:57 <cge> monochrom: I see! Thank you.
16:54:58 <adu> yey!
16:55:04 <adu> doing things is good
16:55:23 <monochrom> Haskell is the finest imperative language for doing dynamic programming!
16:56:25 <monochrom> dynamic programming :: useful, finest imperative language :: elegant.  There!
16:57:22 <adu> i thought haskell was not imperative?
16:57:34 <monochrom> Heh.
16:58:00 <adu> heh?
16:58:22 <monochrom> Simon Peyton Jones said Haskell is the finest imperative language in the world. :)
16:58:28 <monochrom> (Including the :) )
16:58:54 <jip> monochrom: that is also said on the recent post on this haskell devlog: http://www.mutantlemon.com/omegagb/devlog
17:01:24 <adu> heh
17:01:33 <adu> "it's not just a joke!"
17:01:40 <monochrom> perhaps I will learn gtk2hs.
17:01:53 <adu> maybe that means its a joke AND its funny too :)
17:02:00 <palomer> there is much C in darcs
17:02:18 <jip> http://img63.imageshack.us/img63/5337/dropzonetiles26qp.png
17:02:22 <palomer> parsec isn't terribly useful
17:02:31 <palomer> there are more useful parsers out there
17:02:32 <monochrom> You encountered "let bindwidget = ..." doesn't work, has to be "let bindwidget x y = ...".  I think you ran into something related to the monomorphism restriction.
17:02:54 <jip> monochrom: yeah, Lemmih told me about the ghc flag to disable the restriction
17:05:40 <adu> wow
17:05:44 <adu> gameboy emulation
17:06:34 <adu> ic
17:06:53 <adu> Haskell's type system keeps bugs to a minimum
17:06:56 <adu> that makes sense now
17:09:52 <SyntaxNinja> is there an rss module out there somewhere?
17:19:53 <cge> monochrom: yep, that certainly speeds it up :)
17:21:40 <tnks> Hi.  I'm doing a class project, and I've reached a problem in some Haskell code that's delving into some Haskell issues that are new to me -- in particular overlapping instances.  Can someone point me somewhere this issue is discussed nices?
17:21:49 <tnks> nicely.
17:22:16 <tnks> Or if someone's up to it, maybe you can talk me through what the issue is here.
17:22:31 <cge> tnks: Is the project supposed to be for learning Haskell, or are you like me and writing something in Haskell for a completely unrelated course just to be elegant.
17:22:32 <cge> ?
17:22:50 <tnks> Basically, I have some code that's complicated where these instances are overlapping, but it would really help to have a pedagolical example that small and illustrates how overlapping occurs.
17:23:31 <liyang> instance Foo a where { ... }
17:23:45 <liyang> instance Foo (Bar b) where { ... }
17:24:09 <monochrom> whee
17:24:26 <liyang> So the a in the first definition could be instantiated with Bar b, which raises the question: which definition do you go with?
17:26:17 <liyang> (One answer would be to go with the most specific instance. This isn't neccesarily always what you want, however.)
17:26:32 <dons> ah good. the weird network troubles seem to have disappeared mostly
17:26:34 <dons> ?bot
17:26:34 <oasisbot> :)
17:26:41 <lambdabot> :)
17:26:52 <dons> oasisbot: @part #haskell
17:26:53 <oasisbot> Not enough privileges
17:26:58 <dons> ah ok.
17:27:02 <tnks> liyang: hey thanks.
17:27:07 <tnks> I appreciate it.
17:27:24 <tnks> Actually... I was Googling and I just found the section in the GHC manual where it's discussed.
17:27:32 <tnks> Before I was looking through tutorials.
17:30:35 <liyang> ah good. I was about to post a link to that. :)
17:32:40 <tnks> cge it's a Programming Languages class.
17:33:42 <cge> tnks: Ah. I came here to ask about questions for a Numerical Relativity course :)
17:36:32 <mwc> cge, numerical relativity? as in scientific computing?
17:36:45 <cge> mwc: yes.
17:36:58 <mwc> had much experience using haskell for that type of work?
17:37:23 <wchogg> cge:  That's some pretty sexy stuff.  Where are you based?
17:37:36 <mwc> I've done about a semesters worth, learned some tricks, wondered if you had more
17:37:46 <cge> Not really. Hardly at all, in fact. But the course is for theoretical physics grad students who don't necessarily have much experience in programming.
17:37:52 <mwc> Cool
17:38:01 <mwc> cge, ST and MArray are your new best friends
17:38:12 <cge> wchogg: Caltech High Energy Theory Group
17:38:36 <mwc> cge, looking to do graduate work in that area myself in another year or so
17:38:51 <wchogg> cge:  Cool.  I'm at UW Madison.  I'm going to be trying to use Haskell for perturbative QCD this summer.
17:39:02 <cge> mwc: But MArray is EVIL! I wrote my PDE solver with Array.
17:39:15 <mwc> Yeah, lazy initialization can get you pretty far
17:39:53 <mwc> I used a finite difference method, initialized the array elements with either the BC or some computation that terminated on the boundaries
17:40:05 <cge> wchogg:  I actually am pursuing real theory work (non-numerical), but happen to be taking a numerical course.
17:40:33 <mwc> but I recently did some work in monte carlo simulations where I wasn't so lucky. 40,000 doubles, had to do actual modification to the array elements
17:40:59 <cge> mwc: Yes, MArray would be useful there.
17:41:01 <wchogg> mwc:  What kindof monte carlo stuff were you doing?  
17:41:05 <monochrom> gtk2hs is at about the same level of abstraction as Java AWT/Swing and IBM's SWT.  I still hope one day there is a higher level, but this will do for now.
17:41:28 <mwc> wchogg, simulated annealing project, had a project-course in monte carlo methdos
17:41:46 <mwc> I'm dubious if there could be such a higher level
17:41:55 <mwc> *er, I'm dubious OF if
17:42:08 <cge> monochrom: None of the higher level libraries seem to be very active.
17:42:14 <mwc> maybe a GUI combinator library :D
17:42:20 <wchogg> mwc:  Cool.  Did you encounter much in the way of speed issues using Haskell?
17:42:29 <mwc> wchogg, no, none I couldn't resolve
17:42:58 <mwc> I know it could have been done faster in C, which is what I'd have done if I needed to do bigger matrices or the like once I got everything else working
17:43:36 <monochrom> I don't think it is clear yet what the higher level should look like.  But if it is settled, we can wrap the higher level around gtk2hs.
17:43:53 <mwc> wchogg, early on, Cale helped me get a runtime down from 5 minutes to 10 seconds by teaching me how to use `seq` properly
17:44:05 <wchogg> mwc:  Cale is pretty damn helpful, isn't he?
17:44:32 <mwc> monochrom, that's why I think it's too difficult. GUI's are too app specific
17:45:31 <mwc> wchogg, yeah, he lives not too far up the road from me. I should take him a case of some good beer sometime
17:46:07 <monochrom> My first instinct is "process algebra" but a program would have more states than a typical process algebra assumes.
17:46:07 <wchogg> One of the things I'm trying to figure out on my own right now is if Haskell might be well suited towards Pythia type of work, or at the very least madgraph type functionality.
17:46:16 <mwc> monochrom, it seems to me that the GUI is in some way a reflection of the data and structure of the 'model' of the application
17:47:39 <mwc> so the desription of a general GUI combinated would need to be as open as any haskell program, what I mean is: you pretty much can't get more abstraction than something like GTK provides without losing generalization
17:48:02 <Pseudonym> You can optimise for common cases, though.
17:48:26 <Pseudonym> Most models make for good OO observer/subject relationships, for example.
17:48:30 <Pseudonym> (Though not all.)
17:48:43 <Pseudonym> So treating that case specially isn't so dumb.
17:49:09 <mwc> Gtk2Hs.Util?
17:49:21 <mwc> seems like you can implement some common structure and make it reusable
17:49:34 <Pseudonym> Another example which comes up often is the structured document model.
17:49:50 <Pseudonym> e.g. OpenDoc, KParts, ActiveX
17:50:14 <Pseudonym> XML/HTML DOM, I suppose.
17:50:30 <monochrom> I probably should build a lot of gui programs and find out what is going on.
17:51:11 <Pseudonym> Fact is, if you have a GUI problem which doesn't fit nicely with your GUI toolkit, then you have to do hard work anyway.
17:51:29 <Pseudonym> That's true regardless of whether or not your toolkit handles other common cases well.
17:53:06 <Pseudonym> The most you can ask of a library is that it makes common cases easy and difficult cases possible.
18:00:31 <sjanssen> > typeOf v
18:00:32 <lambdabot>  Not in scope: `v'
18:00:32 <oasisbot> [Char]
18:01:21 <wchogg> I think the bots should fight it out.
18:01:39 <Cale> @id @id
18:01:40 <oasisbot>  @id
18:01:40 <lambdabot>  @id
18:01:48 <Cale> hmm :)
18:02:07 <Cale> @id ?id
18:02:07 <oasisbot> ?id
18:02:07 <lambdabot> ?id
18:02:26 <Cale> ?id ?id ?id
18:02:26 <oasisbot> ?id ?id
18:02:26 <lambdabot> ?id ?id
18:02:26 <oasisbot> ?id
18:02:27 <lambdabot> ?id
18:03:01 <jorik> some write a quine, quick ;-)
18:03:21 <Pseudonym> Unfortunately, @id doesn't quote.
18:03:26 <Igloo> I'm pretty sure there's a simple one, but I think I'll pass on testing my theory  :-)
18:03:38 <Pseudonym> @help id
18:03:38 <oasisbot> id <arg>. The identiy plugin
18:03:39 <lambdabot> id <arg>. The identiy plugin
18:03:47 <Igloo> Pseudonym: It looks like it does protect, but only for /^@/
18:03:56 <sjanssen> typo in stereo
18:04:06 <sjanssen> "identiy"
18:04:21 <Pseudonym> ?id ?id
18:04:21 <oasisbot> ?id
18:04:21 <lambdabot> ?id
18:04:24 <Pseudonym> Right.
18:04:26 <Cale> ?id ?id ?id ?id ?id
18:04:26 <oasisbot> ?id ?id ?id ?id
18:04:26 <lambdabot> ?id ?id ?id ?id
18:04:27 <oasisbot> ?id ?id ?id
18:04:27 <lambdabot> ?id ?id ?id
18:04:27 <oasisbot> ?id ?id
18:04:27 <lambdabot> ?id ?id
18:04:27 <oasisbot> ?id
18:04:28 <lambdabot> ?id
18:04:35 <Pseudonym> ?id > "hello"
18:04:36 <oasisbot> > "hello"
18:04:36 <lambdabot> > "hello"
18:04:37 <lambdabot> "hello"
18:04:37 <oasisbot> "hello"
18:04:42 <Pseudonym> Hmmm
18:05:06 <Cale> > error "hello"
18:05:06 <lambdabot> Add a type signature
18:05:07 <oasisbot> Add a type signature
18:05:10 <Cale> > error "hello" :: ()
18:05:10 <Pseudonym> Ha.
18:05:11 <oasisbot> Exception: hello
18:05:11 <lambdabot> Exception: hello
18:05:18 <Cale> nope
18:05:41 <Pseudonym> If there was a bot named "Exception", we'd be in business.
18:05:45 <Pseudonym> lambdabot: ?id hello
18:05:45 <lambdabot> hello
18:05:49 <Cale> haha
18:06:21 <lambdabot> ?id ?id ?id ?id ?id
18:06:21 <oasisbot> ?id ?id ?id ?id
18:06:21 <lambdabot> ?id ?id ?id
18:06:22 <oasisbot> ?id ?id
18:06:22 <lambdabot> ?id
18:06:25 <Pseudonym> :-)
18:06:44 <Pseudonym> lambdabot: ?id ?id ?id ?id ?id
18:06:45 <lambdabot> ?id ?id ?id ?id
18:06:45 <oasisbot> ?id ?id ?id
18:06:46 <lambdabot> ?id ?id
18:06:46 <oasisbot> ?id
18:06:55 <Pseudonym> That makes the problem a bit more tractable.
18:06:56 <newsham> ?ego
18:06:56 <oasisbot> echo; msg:Message {msgPrefix = "newsham!i={ZDRdiSU@malasada.lava.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?ego"]} rest:""
18:06:56 <lambdabot> echo; msg:Message {msgPrefix = "newsham!i={ZDRdiSU@malasada.lava.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?ego"]} rest:""
18:07:06 <araujo> ?id
18:07:14 <araujo> ?id 
18:07:16 <Pseudonym> ?superego
18:07:16 <oasisbot> Unknown command, try @list
18:07:16 <lambdabot> Unknown command, try @list
18:07:33 <araujo> ?id ?id
18:07:33 <oasisbot> ?id
18:07:34 <lambdabot> ?id
18:07:38 <newsham> ?ego
18:07:38 <oasisbot> echo; msg:Message {msgPrefix = "newsham!i={ZDRdiSU@malasada.lava.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?ego"]} rest:""
18:07:38 <lambdabot> echo; msg:Message {msgPrefix = "newsham!i={ZDRdiSU@malasada.lava.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?ego"]} rest:""
18:07:42 <araujo> ?id ?id ?id
18:07:43 <oasisbot> ?id ?id
18:07:43 <lambdabot> ?id ?id
18:07:43 <oasisbot> ?id
18:07:43 <lambdabot> ?id
18:07:43 <Cale> ?echo
18:07:44 <oasisbot> echo; msg:Message {msgPrefix = "Cale!n=cale@69.156.155.124", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?echo"]} rest:""
18:07:44 <lambdabot> echo; msg:Message {msgPrefix = "Cale!n=cale@69.156.155.124", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?echo"]} rest:""
18:08:30 <Pseudonym> ?echo Test
18:08:30 <oasisbot> echo; msg:Message {msgPrefix = "Pseudonym!n=ajb@lindor.alicorna.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?echo Test"]} rest:"Test"
18:08:31 <lambdabot> echo; msg:Message {msgPrefix = "Pseudonym!n=ajb@lindor.alicorna.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?echo Test"]} rest:"Test"
18:08:38 <Cale> ?id > error (repeat 'a')
18:08:38 <oasisbot> > error (repeat 'a')
18:08:38 <lambdabot> > error (repeat 'a')
18:08:39 <lambdabot> Add a type signature
18:08:39 <oasisbot> Add a type signature
18:08:44 <Cale> ?id > error (repeat 'a') :: ()
18:08:45 <oasisbot> > error (repeat 'a') :: ()
18:08:45 <lambdabot> > error (repeat 'a') :: ()
18:09:14 <newsham> ?ego ?id 
18:09:31 <oasisbot> plugs module failed: thread killed
18:09:31 <oasisbot> echo; msg:Message {msgPrefix = "newsham!i={ZDRdiSU@malasada.lava.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?ego ?id "]} rest:"?id "
18:09:49 * shapr remembers adding @echo a few days after Pseudonym requested a plugin system for lambdabot.
18:09:53 <Cale> oasisbot wins!
18:09:58 <araujo> ?id ?id (2 + 3) + ?id ((*) 9 9)
18:09:58 <oasisbot> ?id (2 + 3) + ?id ((*) 9 9)
18:10:01 <Pseudonym> I did?
18:10:03 <Pseudonym> Ah, OK.
18:10:12 <jorik> ?id main = "test"; main
18:10:13 <oasisbot> main = "test"; main
18:10:17 <shapr> Pseudonym: Yeah, you challenged me to add a plugin system, remember?
18:10:21 <araujo> bah, it didn't work :-)
18:10:29 <jorik> ftw ?
18:10:35 <Pseudonym> Nope, sorry.  But my memory is very, very lossy.
18:10:42 <Pseudonym> I believe you, and it's probably in the logs.
18:11:02 <shapr> You wrote the Hello plugin, it just didn't have any way to talk to lambdabot.
18:11:08 <Pseudonym> Ah.
18:11:09 <Pseudonym> OK
18:11:14 <Pseudonym> ?hello
18:11:14 <oasisbot> Maybe you meant: help hylo
18:11:19 <lambdabot> Maybe you meant: help hylo
18:11:35 * shapr falls over asleep
18:11:52 <sjanssen> did lambdabot die?
18:12:02 <Pseudonym> ?id Night shapr.
18:12:02 <oasisbot> Night shapr.
18:12:17 * araujo should go sleep too
18:12:27 <sjanssen> @id has vanquished the enemy!
18:12:28 <oasisbot> has vanquished the enemy!
18:12:35 * araujo almost 24hrs. up
18:12:38 <Pseudonym> Aha.
18:12:41 <sjanssen> @id /me has vanquished the enemy!
18:12:42 * oasisbot has vanquished the enemy!
18:12:52 <Pseudonym> Oooh!
18:12:59 * lambdabot has vanquished the enemy!
18:13:03 <Pseudonym> @id /quit
18:13:03 <oasisbot> /quit
18:13:06 <Pseudonym> Damn.
18:13:11 <lambdabot> /quit
18:13:33 <Pseudonym> @id @id @id /me tests
18:13:34 <oasisbot>  @id @id /me tests
18:13:34 <lambdabot>  @id @id /me tests
18:13:48 <Pseudonym> ?id ?id ?id /me tests
18:13:48 <oasisbot> ?id ?id /me tests
18:14:38 <jorik> we need to get it to return excactly what we give it, so the bots go in an infite loop
18:14:52 <lambdabot> ?id ?id /me tests
18:14:52 <oasisbot> ?id /me tests
18:14:54 <lambdabot> ?id /me tests
18:14:54 * oasisbot tests
18:14:58 * lambdabot tests
18:16:19 <araujo> ?id ?id
18:16:19 <oasisbot> ?id
18:16:19 <lambdabot> ?id
18:16:22 <araujo> ?id ?id ?id
18:16:22 <oasisbot> ?id ?id
18:16:23 <lambdabot> ?id ?id
18:16:23 <oasisbot> ?id
18:16:23 <newsham> > putStrLn "> "
18:16:23 <lambdabot> ?id
18:16:24 <lambdabot> No IO allowed
18:16:30 <oasisbot> No IO allowed
18:16:42 <Pseudonym> @fact lambdabot
18:16:42 <oasisbot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
18:16:43 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
18:16:52 <Pseudonym> @help fact
18:16:52 <oasisbot> fact <fact>, Retrieve a fact from the database
18:16:53 <lambdabot> fact <fact>, Retrieve a fact from the database
18:16:59 <Pseudonym> @help
18:16:59 <oasisbot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:16:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:17:01 <newsham> ?seen oasisbot
18:17:01 <oasisbot> Yes, I'm here. I'm in #haskell, #haskell-blah and #oasis
18:17:02 <lambdabot> oasisbot is in #haskell-blah and #haskell. I last heard oasisbot speak 2 seconds ago.
18:17:03 <Pseudonym> @help list
18:17:03 <oasisbot> list [module|command]
18:17:03 <oasisbot> show all commands or command for [module]
18:17:04 <lambdabot> list [module|command]
18:17:04 <lambdabot> show all commands or command for [module]
18:17:10 <Pseudonym> @list fact
18:17:10 <oasisbot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-update
18:17:10 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-update
18:17:40 <Pseudonym> @fact-set recursiveFactoid: ?fact recursiveFactoid
18:17:40 <sjanssen> oh no . . .
18:17:40 <oasisbot> Fact recorded.
18:17:41 <lambdabot> Fact recorded.
18:17:49 --- mode: ChanServ set +o Igloo
18:17:55 <Pseudonym> lambdabot: @fact recursiveFactoid
18:17:56 <Cale> @fact @fact
18:17:56 <lambdabot> I know nothing about recursivefactoid
18:17:56 <oasisbot> I know nothing about @fact
18:17:56 <lambdabot> I know nothing about @fact
18:18:08 * araujo runs away
18:18:11 <Cale> @karma @karms
18:18:11 <oasisbot>  @karms has a karma of 0
18:18:12 <lambdabot>  @karms has a karma of 0
18:18:12 <Cale> @karma @karma
18:18:12 <oasisbot>  @karma has a karma of 0
18:18:13 <lambdabot>  @karma has a karma of 0
18:18:16 <Pseudonym> @fact-set recursiveFactoid ?fact recursiveFactoid
18:18:17 <oasisbot> Fact recorded.
18:18:17 <lambdabot> Fact recorded.
18:18:20 <Pseudonym> lambdabot: @fact recursiveFactoid
18:18:21 <lambdabot> recursivefactoid: ?fact recursiveFactoid
18:18:29 <Pseudonym> Aha!
18:18:41 <Pseudonym> @fact-set lambdabot ?fact oasisbot
18:18:41 <oasisbot> Fact already exists, not updating
18:18:42 <lambdabot> Fact already exists, not updating
18:18:56 <Pseudonym> ?fact-delete lambdabot
18:18:56 <oasisbot> Fact deleted.
18:18:57 <lambdabot> Fact deleted.
18:18:59 <Pseudonym> ?fact-delete oasisbot
18:18:59 <oasisbot> Fact deleted.
18:19:00 <lambdabot> Fact deleted.
18:19:01 <dons> hmm
18:19:03 <araujo> ?id ?id ?id
18:19:03 <oasisbot> ?id ?id
18:19:04 <lambdabot> ?id ?id
18:19:04 <oasisbot> ?id
18:19:04 <lambdabot> ?id
18:19:14 <dons> double hmm
18:19:16 <Pseudonym> lambdabot: ?fact-set oasisbot ?fact lambdabot
18:19:17 <lambdabot> Fact recorded.
18:19:24 <dons> haskell programmers have too much time on their hands
18:19:28 <Pseudonym> oasisbot: ?fact-set lambdabot ?fact oasisbot
18:19:28 <oasisbot> Fact recorded.
18:19:31 <Pseudonym> ?fact lambdabot
18:19:32 <oasisbot> lambdabot: ?fact oasisbot
18:19:32 <lambdabot> I know nothing about lambdabot
18:19:32 <lambdabot> oasisbot: ?fact lambdabot
18:19:33 <oasisbot> lambdabot: ?fact oasisbot
18:19:33 <lambdabot> oasisbot: ?fact lambdabot
18:19:34 <oasisbot> lambdabot: ?fact oasisbot
18:19:34 <lambdabot> oasisbot: ?fact lambdabot
18:19:34 <oasisbot> lambdabot: ?fact oasisbot
18:19:35 <Pseudonym> Yay!
18:19:36 <lambdabot> oasisbot: ?fact lambdabot
18:19:36 <oasisbot> lambdabot: ?fact oasisbot
18:19:37 <lambdabot> oasisbot: ?fact lambdabot
18:19:37 <oasisbot> lambdabot: ?fact oasisbot
18:19:37 <lambdabot> oasisbot: ?fact lambdabot
18:19:38 <oasisbot> lambdabot: ?fact oasisbot
18:19:38 --- kick: lambdabot was kicked by Igloo (Igloo)
18:19:39 * araujo should be sleeping
18:19:40 <dons> well done
18:19:55 <Igloo> Congratulations. Now send dons a patch as penance  :-)
18:19:56 <Pseudonym> I did it, after about a year of trying.
18:20:12 <dons> several years, it feels like
18:20:17 <Pseudonym> Now I need to find a way to do it using @quote.
18:21:07 <Pseudonym> Yeah, probably a couple of years.
18:21:14 <Pseudonym> My work here is done.
18:21:21 <dons> :)
18:22:13 <newsham> ?fact-set #haskell bored
18:22:13 <oasisbot> Fact recorded.
18:22:25 <Pseudonym> ?fact Pseudonym,
18:22:25 <oasisbot> I know nothing about pseudonym,
18:22:26 <Pseudonym> ?fact Pseudonym
18:22:26 <oasisbot> pseudonym: My initial creator.
18:22:38 <Pseudonym> Your tormentor, too.
18:22:41 <newsham> ?fact-set haskell lazy
18:22:41 <oasisbot> Fact already exists, not updating
18:22:48 <newsham> ?fact haskell
18:22:48 <oasisbot> haskell: Haskell is the language of choice for discriminating hackers.
18:22:58 <newsham> ?fact #haskell
18:22:58 <oasisbot> #haskell: bored
18:23:08 <newsham> ?fact newsham
18:23:08 <oasisbot> I know nothing about newsham
18:23:17 <Pseudonym> ?fact-set newsham bored
18:23:17 <oasisbot> Fact recorded.
18:23:22 <Igloo> ?fact-delete lambdabot
18:23:22 <oasisbot> Fact deleted.
18:23:24 <newsham> ?fact-set newsham lazy
18:23:24 <oasisbot> Fact already exists, not updating
18:25:37 --- mode: Igloo set -o Igloo
18:29:20 <palomer> @v
18:29:21 <oasisbot> Maybe you meant: vera version vixen vote .
18:29:24 <palomer> !v
18:29:28 <palomer> ?v
18:29:28 <oasisbot> Maybe you meant: vera version vixen vote .
18:29:31 <palomer> > v
18:29:33 <oasisbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:29:33 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:29:33 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:29:33 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:29:36 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:29:37 <palomer> what's v????
18:29:39 <oasisbot> [6 @more lines]
18:29:56 <newsham> ?fact-set facts change
18:29:56 <oasisbot> Fact recorded.
18:30:00 <newsham> ?fact facts
18:30:01 <oasisbot> facts: change
18:30:11 <sjanssen> palomer: when you type "> E" it is translated to something like "let v = show (E) in v"
18:30:45 <newsham> ?fact-set facts change often
18:30:46 <oasisbot> Fact already exists, not updating
18:31:36 <sjanssen> I think we need an @v command in lambdabot
18:31:48 <newsham> and better knowledge representation :)
18:32:22 <palomer> > E
18:32:23 <oasisbot>  Not in scope: data constructor `E'
18:32:37 <sjanssen> palomer: where E is an arbitrary Haskell expression
18:33:00 <sjanssen> > head v
18:33:01 <oasisbot> Exception: <<loop>>
18:33:05 <sjanssen> > take 1 v
18:33:06 <palomer> > let v = show v in v
18:33:06 <oasisbot> "\""
18:33:07 <oasisbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:07 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:07 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:08 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:11 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:14 <oasisbot> [6 @more lines]
18:33:26 <palomer> > let u = show u in u
18:33:27 <oasisbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:27 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:27 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:27 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:30 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:33 <oasisbot> [6 @more lines]
18:33:37 <palomer> why does it output this?
18:33:45 <Pseudonym> > v ++ v
18:33:46 <oasisbot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:46 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:46 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:46 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:49 <oasisbot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
18:33:52 <oasisbot> [6 @more lines]
18:33:52 <palomer> I don't see the point of the existence of v
18:34:07 <sjanssen> palomer: it's repeatedly quoting the screen
18:34:14 <newsham> > \x -> 5
18:34:15 <oasisbot>  add an instance declaration for (Show (t1 -> t))
18:34:18 <Pseudonym> Why doesn't it eval just show (E)?
18:34:42 <sjanssen> 'v' is a minor bug in hs-plugins.  dons fixed it so that the variable name is randomly generated, for his copy of lambdabot
18:34:59 <palomer> but is v even necessary?
18:35:08 <palomer> isn't there a cleaner way to do this?
18:35:16 <palomer> why not just evaluate "show E" ?
18:35:51 <sjanssen> who knows? I'm sure there is a subtle reason that hs-plugins does it this way
18:36:17 <dons> it has no reason. its fixed in newer lambdabots
18:36:29 <palomer> dons: so now it simply does "show E" ?
18:36:55 <dons> so as to insert a newline, to use LINE pragmas for accurate errors
18:37:00 <dons> > '
18:37:00 <oasisbot>  lexical error in string/character literal
18:37:04 <dons> > let of
18:37:04 <oasisbot>  parse error on input `of'
18:37:36 <perry> in fedora extras, anyone know what ghc, ghc64, and ghc641 are (if they are all version 6.4.1)?
18:37:43 <dons> well, we strip the line number out. but in general, you want the right line number reported
18:37:58 <dons> so there's a little: let v = \n {-# LINE #-} e
18:38:27 <dons> looks like oasisbot is a bit behind the times
18:38:27 <jip> ok so i mentioned "functional programming" to this c++ guy who was talking about OOP, and he thinks that functional programming is like, c. how should i explain what functional programming is?
18:38:47 <dons> like C? oh, so like everything that isn't C++
18:38:58 <newsham> jip: tell him to code in C without using side effects.
18:39:00 <Pseudonym> Tell him that C++ is more like C.
18:39:06 <Pseudonym> And watch his blood boil.
18:39:23 <dons> jip, maybe look at the Research page and the Introduction articles on haskell.org
18:39:25 <newsham> (actually, tell him to write a program in cpp)
18:39:25 <Pseudonym> I would suggest that he checks out FC++.
18:39:33 <Pseudonym> @google fc++
18:39:33 <oasisbot> http://www.cc.gatech.edu/~yannis/fc++/
18:39:43 <palomer> jip: tell him it's like the ocean is on fire
18:40:01 <Smokey`> http://www.newscientistspace.com/article/dn9012-black-holes-collide-in-the-best-simulation-yet.html
18:40:10 <Pseudonym> Functional programming is like Boost.Lambda only more so.
18:40:25 <newsham> jip: http://www.cc.gatech.edu/~yannis/fc++/fc++.main.pdf
18:41:13 <newsham> i was too slow
18:41:14 <jip> maybe there is like a wikipedia entry for functional programming? what's a good introduction?
18:41:14 <sjanssen> palomer: is that an old Aquaman cartoon reference?
18:41:38 <palomer> no, it came from the voices in my head
18:42:14 <Pseudonym> Really, the only way to understand functional programming is by doing.
18:42:27 <Pseudonym> FC++ isn't a bad alternative if this person already knows C++.
18:42:35 <perry> i have a talk on procedural accumulators somewhere
18:42:54 <Pseudonym> BTW, do make sure that this person knows that C++ isn't an OO language.
18:43:02 <Pseudonym> OO is but one style that C++ supports.
18:43:11 <Pseudonym> FC++ shows that it supports FP too, in a fashion.
18:43:17 <perry> oh C++ is to an OO language
18:43:42 <perry> ok..  haskell isnt pure functional
18:43:48 <palomer> it isn't!
18:43:49 <Pseudonym> Sure it is.
18:43:57 <palomer> they're telling you lies!
18:44:08 <Pseudonym> C++ isn't an OO language in the sense that Eiffel or Java is.
18:44:08 <sjanssen> @palomer
18:44:09 <oasisbot> blargh!
18:44:12 <jip> haskell is also multi paradigm :D it supports functional style and imperative style, and OOP style even :P
18:44:16 <Pseudonym> Right.
18:44:38 <perry> c++ might not be as OO as you might like, but it is OO
18:44:52 <Pseudonym> No, it supports OO style.
18:44:59 <Pseudonym> But the language isn't oriented towards objects.
18:45:22 <jip> Pseudonym: how is c++ more multi-paradigm then java is?
18:45:24 <palomer> haven't you guys learned that these conversations are as pointless as welfare?
18:45:32 <perry> split (//);
18:45:37 <Pseudonym> C++ suports all sorts of styles of programming that Java doesn't.
18:45:40 <Smokey`> fc++ makes me cry... :S
18:45:41 <sjanssen> perry: look at the standard libraries in C++ -- not a bit of inheritance in there
18:45:43 <Pseudonym> Generics is one example.
18:45:44 <palomer> I order you to stop this nonsense!
18:45:49 <Pseudonym> Metaprogramming is another.
18:45:56 <jip> Pseudonym: doesn't java also support this?
18:46:13 <Pseudonym> I guess Java supports generics now.  Or is that the next version?
18:46:19 <perry> 1.5
18:46:20 <Smokey`> Pseudonym: it supports them now.
18:46:21 <jip> i think it's now
18:46:24 <Pseudonym> Right.
18:46:26 <perry> now in 1.5
18:46:46 <palomer> sjanssen: the subset of the java standard library which is comparable to the C++ standard library doesn't make much use of virtual methods either, buddy
18:47:15 <Pseudonym> Not virtual methods, no.
18:47:30 <Pseudonym> But, for example, until very recently, Java containers required dynamic downcasting.
18:47:36 <Pseudonym> Everything was a container of objects.
18:47:38 <sjanssen> palomer: I'm going to disagree there.  the InputStream hierarchy and the collections interfaces are counterexamples
18:47:50 <Pseudonym> sjanssen: Also true of C++ iostreams.
18:48:08 <newsham> lets not discriminate on the basis of object orientation
18:48:10 <Pseudonym> There's inheritance under the hood there.
18:48:34 <palomer> the interface methods are not vtable inducing
18:49:45 <perry> ahhh..  ghc is installed..  my computer is real now
18:49:57 <Pseudonym> The main reason why C++ isn't object oriented is that it doesn't rely on objects as its only abstraction.
18:50:29 <newsham> some birds prefer to walk
18:50:43 <palomer> penguins
18:50:49 <newsham> they're still birds
18:50:58 <Pseudonym> Not being oriented around one paradigm is a strength of C++, not a weakness.
18:51:00 <Pseudonym> Ditto with Haskell.
18:51:12 <Pseudonym> This is something that Java is only just learning.
18:52:06 <perry> haskell's only abstraction is not functions
18:52:09 <Pseudonym> Though to be fair, Java's initial design criteria was for an execution model that was consistent and simple enough that you could prove safety formally at the bytecode level.
18:52:18 <Pseudonym> perry: That's true.
18:52:30 <Pseudonym> But it's functional in the same way that C++ is imperative.
18:52:38 <perry> so nothing is anything
18:52:41 <Pseudonym> Rather than function in the same way that C++ is object-oriented.
18:52:45 <Pseudonym> functional
18:52:51 <perry> oh well..  i quit
18:52:52 <palomer> haskell is the penguin of the bird kingdom
18:52:56 <jip> oy vey what have i done :\
18:53:04 <Pseudonym> I thought that was Linux.
18:53:06 <palomer> perry: quitting pointless arguments is quite pointless
18:53:13 <Pseudonym> @pl argument
18:53:14 <oasisbot> argument
18:53:20 <perry> palomer, darn
18:53:23 <Pseudonym> @pl ?id test
18:53:24 <oasisbot> (line 1, column 1):
18:53:24 <oasisbot> unexpected "?"
18:53:24 <oasisbot> expecting white space, natural, identifier, lambda abstraction or expression
18:53:29 <Pseudonym> Just checking.
18:54:12 <newsham> languages and philosophies are neither completely dependant or completely independant.
18:54:13 <Pseudonym> Actually, in the Alan Kay sense of the term, Java isn't really OO eitehr.
18:54:19 <Pseudonym> Because the objects don't communicate via messaging.
18:54:30 <Pseudonym> newsham: I agree.
18:54:47 <Pseudonym> These concepts are prototype classes, not boolean sets.
18:55:04 <Pseudonym> If Smalltalk is OO, then languages like it are OO too.
18:55:13 <jip> imperative: C. functional: ML. object-oriented: Smalltalk
18:55:15 <perry> Pseudonym, platonic ideals dont exist in the physical world
18:55:23 <newsham> also most languages are buzzword compliant.
18:55:45 <Pseudonym> If we could realise something, it wouldn't be an ideal.
18:56:14 <perry> ML has an imperative fragment..  haskell does too, but its minimally imperative
18:56:28 <perry> nothing is anything
18:56:29 <Pseudonym> Actually, Haskell's imperative part is only syntax.
18:56:40 <Pseudonym> It's really pure functional, but the syntax is imperative.
18:56:57 <jip> what is the most functional language then?
18:57:03 <palomer> I've got my crap-o-meter set on #haskell, and it's showing record levels
18:57:07 <perry> no..  my understanding is that some of the state monad stuff rewrites in place
18:57:16 <Pseudonym> Actually, it's not that nothing is anything.  It's that everything is everything.  It's just that some are more so than others.
18:57:22 * Pseudonym tries to parse that
18:57:28 <jip> palomer: heh
18:57:32 <Pseudonym> perry: implementation detail.
18:57:40 <jip> palomer: what about that time when... hm, nm
18:57:46 <Pseudonym> The semantics are pure even if the implemntation isn't.
18:58:02 <newsham> doesnt matter what really happens, as long as it behaves as the semantic model dictates
18:58:07 <newsham> the semantics are purely functional
18:58:16 * perry watches the balloon change shape as he squeezes one end
18:58:29 <palomer> sml semantics can be made pure, just STify everything; the morphism is stable and straight forward
18:58:47 <Pseudonym> But really, all this is unimportant.
18:59:05 <Pseudonym> The really important take-home lesson is that the more languages you know, the better your programming in any one language is.
18:59:29 <perry> i can write haskell in fortran..  
18:59:35 <palomer> and don't forget kids, never enter a pervert's car
18:59:49 <Pseudonym> I can write Fortran in Haskell, too.
19:00:07 <Pseudonym> But more to the point, I can write Erlang in C++.
19:00:15 <Pseudonym> Which makes for a much better C++ when it applies.
19:00:17 <palomer> I can write assembly in haskell
19:00:33 * jip *is* writing assembly in haskell :D
19:00:35 <perry> nm
19:00:38 * palomer high fives jip
19:01:06 <newsham> gameboy emulator?
19:01:11 <jip> newsham: yeah :D
19:01:32 <newsham> emulators are loads of fun
19:01:36 <jip> i convert gameboy machine code into a haskell assembly-language data structure :)
19:02:07 <newsham> we call that "disassembly"
19:02:31 <jip> no, i'm not disassebling
19:02:36 <jip> just "executing"
19:04:28 <palomer>  you're not "executing", you're "getting funky with the laydays"
19:05:30 <newsham> i'm guessing that writing emulators for old machines in an esoteric language is not helping with "the laydays"
19:05:47 <newsham> (but its still pretty cool :)
19:05:56 <palomer> well, let's ask the man himself
19:06:14 <palomer> jip: has your application helped you with "the laydays" ?
19:06:38 <newsham> last time I worked on an emulator i didnt talk to anybody for 1.5 weeks
19:07:39 <newsham> i probably didnt even leave the house
19:09:26 <palomer> I've talked to a few members of the opposite sex, and they've told me that that's _exactly_ what they're looking for in a man
19:12:46 <perry> the present king of france is bald?
19:13:20 <Smokey`> sigh, i'm being attacked in another channel for using haskell ^_^   and haivng the opinnion that an unhandled exception is just as bad as a program literally crashing
19:13:30 <Smokey`> *hides in #haskell for a while* :)
19:14:12 <perry> hey, i like pointing out that using Int is the same, and get the same treatment in haskell circles
19:14:45 <perry> Int wraps around (not necessarily expectedly)
19:15:09 <sethk> Smokey`, an unhandled exception _is_ a program crashing
19:15:26 <perry> triage
19:15:30 <Smokey`> sethk: that's what i keep saying...
19:15:52 <sethk> Smokey`, tell the customer Oh, it's ok, because we decided it should crash there
19:16:14 <Smokey`> lol
19:16:36 <perry> try {foo () } catch (e) exit (1);
19:16:52 <perry> there, see its handled
19:17:03 <Pseudonym> Well, there are legitimate situations where a core dump is more useful than recovery.
19:17:46 <perry> failstop is better than running corrupted
19:17:53 <perry> ?
19:17:55 <dons> not in many haskell programs though, I hope, Pseudonym 
19:18:07 <Pseudonym> It depends.
19:18:18 <sethk> Pseudonym, that may be true, but I very much doubt that this is the real reason for an significant number of unhandled exceptions
19:18:27 <dons> hehe. right.
19:18:42 <Pseudonym> If your database is corrupted on disk, it might be better to shut down the database server than continue and risk further lossage.
19:18:57 <perry> how many haskell programs handle exceptions?
19:19:07 <dons> hmm. most these days?
19:19:13 <sethk> Pseudonym, sure, but you don't have to do that by not handling an exception
19:19:16 <Pseudonym> OTOH in a web server, it's better to just kill the current request.
19:19:24 <Pseudonym> And keep going.
19:19:40 <Pseudonym> Well, true, yes. :-)
19:19:54 <dons> perry, catch/handle/bracket/finally and so on are very common
19:19:57 <Pseudonym> It's quite reasonable to only handle exceptions at the topmost level, though.
19:20:12 <Pseudonym> In many situations.
19:20:29 <perry> your haskell program is reading from disk.  do you handle the case where the disk dies halfway through?
19:20:45 <Pseudonym> You handle the case where a read fails.
19:20:52 <sethk> perry, yes
19:20:53 <Pseudonym> If only by reporting the error and aborting the program.
19:20:56 <perry> handle, how?
19:20:57 <dons> yeah, when your hGet throws something
19:21:16 <perry> by calling error?
19:21:22 <Pseudonym> A reported error is almost always better than nothing.
19:21:31 <dons> deal with some of the cases you know to be recoverable (i.e. permissions errors), others you then print some useful message and exti with some useful status
19:21:45 <Pseudonym> Garbage In, Diagnostics Out
19:22:16 <Pseudonym> As Plauger would say.
19:22:28 <perry> dont get me wrong, i belive fully in handling exceptions, i just dont see how to do it
19:22:44 <perry> ... handling ALL exceptions ...
19:22:50 <dons> you inspect the exception thrown using case analysis.
19:22:56 <sethk> perry, with a top level exception handler
19:22:59 <mrevelle> anyone know the status of ghc on intel macs?
19:23:04 <dons> the Exception type is richly structured
19:23:13 <Pseudonym> perry, exceptions were invented when writing the operational flight program for the A-7E aircraft.
19:23:15 <dons> so there's a lot of info you can use
19:23:17 <perry> what if you dont know what the exception means?
19:23:30 <Pseudonym> You can imagine that aborting the program was not an option there.
19:23:39 <Pseudonym> ALL exceptions were handled.
19:23:39 <dons> putStRLn "Unknown error: " ++ show e ?
19:23:55 <perry> yeah..  and they controlled ALL of the code
19:24:18 <Pseudonym> Not all of the embedded code in some of the peripherals.
19:24:19 <perry> putStrLn is not handling an exception
19:24:46 <dons> you asked how to deal with an exception you don't know anything about.
19:24:53 <dons> if you don't know anything about it, what can you do?
19:25:05 <dons> luckily, you usually do know. since the exception tells you
19:25:26 <perry> they had admission controll..  the peripheral code wouldnt be there if they didn't know precisely what it could do
19:25:39 <dons> I wonder how the galois guys do this. maybe they have some nice exception system.
19:25:50 <perry> dons: exactly, you cant do anything..  you cant handle it
19:26:12 <Pseudonym> http://home.comcast.net/~patrickdlogan/parnas.pdf <- If anyone is curious, that's the paper.
19:33:38 <perry> what year is that from?
19:34:03 <Pseudonym> 1976
19:38:23 <dons> "Two-dimensional monad theory" ??
19:38:49 <perry> directional binds, i would guess?
19:39:21 <perry> there is multi-dimensional modal logics, but i dont understand them
19:39:33 <perry> dons: ok..  context please
19:39:33 <dons> well, I'll find out if I ever find this paper online
19:39:40 <Pseudonym> Sounds like "dimension" is almost certainly the wrong word.
19:42:01 * Pseudonym apologises to lilo for putting lambdabot and oasisbot into a loop
19:42:25 <perry> a j power?
19:42:54 <dons> lilo became involved?
19:43:07 <Pseudonym> You didn't see the global notice?
19:43:11 * Pseudonym is kidding, BTW
19:43:25 <dons> ah.
19:43:26 <dons> hehe
19:43:37 <Pseudonym> Not as funny if you have to explain it thought.
19:43:38 <Pseudonym> though
19:43:41 <dons> yes, I see. but how do you _know_ he doesn't mean you.
19:43:48 <Pseudonym> Good point!
19:43:58 <palomer> > 2 + 2
19:43:59 <oasisbot> 4
19:44:15 <dons> lambdabot: global annoyance or friendly robot? who's to say??
19:44:16 <palomer> someone get another bot in here
19:44:33 <perry> eliza and parry!
19:44:37 <perry> classic!
19:47:25 <perry> ahh..  is an old john power paper
19:48:43 <palomer> what happened to lambdabot, anyways?
19:56:07 <dons> there were some severe network problems at unsw over night, such that she couldn't connect
19:56:21 <dons> but she can now. however, we can't get oasisbot to leave nicely
19:56:36 <Pseudonym> lambdabot is a she?
19:56:38 <perry> whats oasisbot?
19:57:04 --- mode: ChanServ set +o Pseudonym
19:57:13 <Pseudonym> Who said anything about "nicely"?
19:57:15 <dons> Pseudonym: www.cse.unsw.edu.au/~dons/lambdabot.html
19:57:18 <dons> true
19:57:44 <Pseudonym> Yeah, I saw the avatar.
19:58:08 <Pseudonym> But long hair is no guarantee of gender.
19:58:14 <Pseudonym> Not since the 60s, anyway./
19:58:19 <dons> ok. you can kick oasisbot, and lambdabot will rejoin momentarily
19:58:24 --- kick: oasisbot was kicked by Pseudonym (Pseudonym)
19:58:26 <Pseudonym> Gone.
19:58:41 <dons> ?version
19:58:45 <perry> what WAS oasisbot?
19:58:56 <lambdabot> lambdabot 3p414, GHC 6.4.1 (Linux i686 3.20GHz)
19:58:57 <palomer> > 2 + 2
19:58:58 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:59:00 <dons> a replacement running on xerox's box, iirc
19:59:00 <lambdabot> 4
19:59:07 --- mode: ChanServ set -o Pseudonym
19:59:10 <palomer> > v
19:59:11 <lambdabot>  Not in scope: `v'
19:59:18 * palomer will miss v
19:59:26 <dons> hehe
19:59:27 <Pseudonym> > let v = show v in v
19:59:28 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
19:59:28 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
19:59:28 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
19:59:28 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
19:59:31 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
19:59:33 <lambdabot> [6 @more lines]
19:59:38 <Pseudonym> It's still there if you need it.
19:59:42 <Korollary> hah
19:59:46 <perry> > u
19:59:46 <lambdabot>  Not in scope: `u'
19:59:58 <dons> bizarre idea, perry
19:59:59 * perry will miss u, too...
20:02:34 <palomer> worst. pun. ever
20:03:06 <perry> rofg
20:03:15 <RyanT5000> are there anonymous records?
20:03:37 <RyanT5000> (in haskell)
20:03:40 <dons> ?
20:03:49 <palomer> no, records in haskell were designed by an 8 year old with ADD
20:04:06 <dons> ?remember grumpy_palomer records in haskell were designed by an 8 year old with ADD
20:04:16 <RyanT5000> like is {x :: Int; y :: Int} a type
20:04:29 <dons> oh. don't tell me I broke lambdabot with this new patch. sigh.
20:04:38 <Korollary> a tuple could serve like that
20:04:50 <RyanT5000> yeah, but it's going to be "i don't know" large
20:04:56 <RyanT5000> it needs to support refactoring
20:04:58 <dons> RyanT5000: , ah I see. anonymous in that they're not tagged.
20:05:21 <RyanT5000> dons: yes
20:05:44 <dons> no such thing.
20:05:48 <RyanT5000> k
20:05:52 <perry> newtype StateT s m a = StateT { runStateT :: (s -> m (s, a)) }
20:06:02 <dons> newtypes almost do it. or a type synonym maybe
20:06:06 <RyanT5000> i'm not sure if it would be The Right Thing (tm) anyway
20:06:17 <dons> yeah. tags are good
20:06:39 <RyanT5000> in other news, is there a datastructure that essentially duplicates the functionality of a RDBMS Table?
20:06:47 <RyanT5000> i find myself duplicating that
20:07:13 <perry> hahah..  poor lambdabot
20:07:19 <RyanT5000> :(
20:07:37 <RyanT5000> soooo... functional RDBMS table representation?
20:07:57 <RyanT5000> right now i've got a class Container c key value, which is just like a class for the interface of Data.Map
20:08:09 <RyanT5000> and then i have a "table" object just implement that multiple times
20:08:27 <RyanT5000> (there are pretty obvious efficiency reasons to not just have a bunch of tables)
20:08:33 <RyanT5000> (also encapsulation issues)
20:09:11 <Pseudonym> BBL
20:13:25 <RyanT5000> can you make tuple kinds?
20:13:31 <RyanT5000> (*, *, *)?
20:13:46 <Korollary> What do you mean?
20:14:05 <perry> kind (*, *) -> *
20:14:08 <perry> ?
20:14:09 <RyanT5000> yeah
20:14:14 <RyanT5000> (i think)
20:14:25 <Korollary> Kinds don't work like that iirc
20:14:43 <perry> i think its only -> and *
20:14:56 <perry> but who know what can happen?
20:15:14 <Korollary> Anything's possible in a crazy typesystem!
20:16:00 <RyanT5000> heh could we make the type system be turing-complete?
20:16:20 <perry> there is something similar with the whatever the | stuff is called?
20:16:29 <RyanT5000> e.g.: have Type be a type, and let me call normal haskell functions on them, at compile-time?
20:16:40 <perry> type foo x y | x < y?
20:16:52 <dons> you can't declare new kinds or otherwise play with them. 
20:16:58 <RyanT5000> :(
20:17:05 <RyanT5000> here's why i want it
20:17:11 <RyanT5000> maybe there's a better solution someone can tell me
20:17:16 <dons> there are some pretty huge implications...
20:17:19 <RyanT5000> I have a type Board
20:17:24 <dons> mayeb in a couple of years.
20:17:26 <RyanT5000> which is basically a table
20:17:29 <perry> template haskell?
20:17:46 <RyanT5000> and so a Board contains BoardEntries, which are rows in the table
20:17:58 <RyanT5000> as i develop the app, i will be changing the values in BoardEntries
20:18:13 <RyanT5000> and possibly the types on which it depends
20:18:37 <RyanT5000> Board doesn't necessarily care about those types
20:18:43 <RyanT5000> (but it does care about some of them)
20:19:13 <RyanT5000> so i wanted to gather up those types, pass them to Board, which can then pass the whole thing as one to BoardEntry
20:19:20 <dons> so maybe use tyep synonyms, so that you then only replace a single line of code to change the types everywhere?
20:19:39 <dons> i.e. type X = A B C D (some More Big Tyeps -> Z)
20:19:42 <RyanT5000> yeah... that's what i've been doing, but it's kind of antithetical to functional programming IMO
20:19:49 <dons> yeah?
20:20:00 <dons> bindings are fairly usual...
20:20:20 <dons> if you want to paramaterise on the type, then typeclasses come in to play
20:20:21 <RyanT5000> no, i mean, having a constant value for something like that, which you could just as easily pass as an argument
20:20:36 <RyanT5000> yeah, i have to parameterize on some of them
20:20:39 <dons> so that: Boardable b => b -> IO ()
20:20:40 <dons> for example
20:20:46 <perry> i need a more concrete example
20:20:59 <dons> and then any future type 'b' would be a possible argument, if its a member of Boardable.
20:21:06 <Korollary> I dont see what that is that needs so much hackery
20:21:11 <perry> how might you propose the syntax to be?
20:21:14 <dons> (i think you jsut want bounded polymorphism, no?)
20:21:32 <dons> and no kinds anywhere at all
20:21:41 <perry> bounded poly!  thats what i was trying to remember
20:22:17 <RyanT5000> hm, how would i propose the syntax be...
20:22:20 <RyanT5000> i'll take a stab at that, brb
20:22:55 <dons> type classes to the rescue!
20:23:34 <jip> @type sum
20:23:35 <lambdabot> forall a. (Num a) => [a] -> a
20:24:28 <jip> dons: are type classes *really* necessary? can't they be simulated with high-order functions? like have sum :: (a -> a -> a) -> [a] -> a
20:25:05 <perry> its all turing complete
20:25:17 <RyanT5000> jip: i believe they're unnecessary in that kind of case
20:25:50 <jip> yeah, but isn't the transformation from typeclasses, to passing the functions of each type-class to the functions that use them straight-forward?
20:25:54 <dons> you can simulate them of course.
20:25:58 <dons> ?type sort
20:25:59 <lambdabot> forall a. (Ord a) => [a] -> [a]
20:26:00 <RyanT5000> however i think there are software engineering reasons for having them
20:26:00 <dons> ?type sortBy
20:26:01 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
20:26:05 <dons> same deally
20:26:17 <RyanT5000> it's a lot easier to add functions when you have a class (?)
20:26:23 <dons> but once you have large packages for functions to pass around, then a convenient syntax helps
20:26:31 <perry> @type foldr
20:26:32 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
20:26:32 <dons> rather than passing your own dictionaries by hand
20:26:44 <dons> jip, make sense? looking at sort and sortBy ?
20:27:09 <dons> the Ord a => is actually just compiled into an argument that passes in the compare function
20:27:10 <RyanT5000> hm, i think you'd need programming-by-contract support
20:27:13 <perry> @type foldr1
20:27:14 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:27:16 <dons> i.e. it compiles to the same code, roughly
20:27:23 <perry> there you go
20:27:32 <jip> dons: yeah, can't you do this for all type classes?
20:27:34 <dons> the typeclass mechanism imposes a discipline though
20:27:40 <RyanT5000> the syntax i think it would boil down to is having
20:27:46 <dons> so that you structure functions by type.
20:27:46 <sethk> perry, that doesn't mean you don't need it.  by that logic we would all program pure turing machines
20:27:53 <RyanT5000> (\x -> stuff) where x is a type rather than a value
20:27:55 <metaperl> ocaml might have some advantages when dealing with data best handled imperatively, but the syntax is too noisy for me. that and no insurance of referential integrity are big minus points for me
20:27:57 <perry> sethk, exactly
20:28:10 <dons> jip, yes. type classes are only _sugar_ for packages for higher order functions
20:28:42 <dons> metaperl: not sure anymroe if there's any data advantage. just don't us [a]
20:28:50 <jip> dons: ok makes sense thanks
20:30:02 <perry> forall a. Monad m => (a -> a -> a) -> m a -> a
20:30:38 <perry> hmm..  maybe only Functor m
20:31:03 <perry> how do you do that with higher order?
20:31:35 <perry> hmm..  sounds like join
20:31:40 <perry> @type join
20:31:41 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
20:31:58 <perry> ermmm
20:33:42 <perry> Id (List a) -> Id a    ?
20:34:37 <metaperl> dons: what do you mean "[a]" ?
20:35:23 <dons> I was assuming that you were referring to [Char] being the  reason for poor IO work in haskell. maybe you meant mutable data structures, though?
20:35:25 <perry> what has the type signature (Monad m, Monad n) => m (n a) -> m a  ?
20:36:00 <dons> which I agree are still not ideal. though Data.Array.Unboxed and Foreign.Ptr are enough to solve everything you need, I think (though sometimes more verbosely than I'd like)
20:36:21 <dons> see the shootout for examples. haskell is as fast as ocaml, except in concurrent benchmarks, where its 10-100x faster
20:36:37 <dons> over a wide number of mostly imperative problems
20:36:48 <perry> hahaha  cool
20:37:06 <dons> the other lazy language, clean, is faster still, as it has more libraries for mutable, packed data than us
20:37:40 <dons> not always faster, and not in concurrent code, btw.
20:37:56 <perry> i think thats being worked on for haskell (packed data, dunno about mutable)
20:38:00 <dons> sure is.
20:38:26 <dons> ?google fast packed strings haskell
20:38:28 <lambdabot> http://lists.debian.org/debian-devel/2005/08/msg01547.html
20:38:31 <dons> huh
20:38:41 <dons> ?where fps
20:38:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:38:42 <dons> i mean.
20:38:55 <dons> ah, its in debian? cool.
20:40:24 <perry> the stuff i was thinking of was more bit-twiddling, as in talking to devices from device drivers (so is mutable, i imagine)
20:40:38 <dons> oh, that's easy. Data.Bits
20:40:51 <dons> have a look at House, the OS in Haskell, they tweak device driver registers all day long
20:41:13 <dons> you mostly want to use Foreign.* stuff, I'd think
20:41:26 <perry> House might be using what I'm talking about
20:41:39 <dons> to get raw pointers to data and arrays in C
20:41:39 <perry> if its in the past year
20:41:55 <dons> there's also the various Binary libraries
20:42:00 <dons> have a look at:
20:42:05 <dons> ?wiki Libraries_and_tools
20:42:05 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools
20:42:16 <dons> under systems programming, and data structures
20:43:12 <jip> dons: you know what would be cool? if there was a haskell module that had a DSL that was very similar to c language, where you could define c-like functions that can be converted to IO actions
20:44:12 <perry> http://web.cecs.pdx.edu/~rebekah/pubs.html
20:44:43 <dons> ?docs Data.Bits
20:44:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
20:44:44 <dons> ?
20:44:55 <dons> gives you the bit ops, anyway.
20:45:02 <jip> dons: what do you think?
20:45:07 <dons> you just need some ForeignPtrs to hack on
20:45:18 <dons> hmm. maybe.
20:45:25 <dons> you mean like 'for' and 'while' loops?
20:45:27 <perry> dons, the first paper is what i was talking about
20:45:31 <jip> dons: yes, and local variables
20:45:33 <dons> and x[y]++ ?
20:45:35 <dons> right.
20:45:39 <dons> yeah, that'd be useful
20:45:45 <dons> local mutable variables
20:45:58 <jip> dons: i think it would be really cool, and it would eliminate the need for switching to c for routines that require performance
20:46:41 <dons> well, we already can do these things, but its not always convenient (fast mutable variables aren't convenient -- you use unboxed arrays instead)
20:46:52 <dons> however, switchign to C is usually not required.
20:47:19 <dons> jip, have a look at, e.g. alloca
20:47:22 <dons> in Foreign.*
20:47:28 <dons> for local variables
20:47:32 <jip> dons: doesn't that allocate memory on the heap though?
20:48:00 <dons> not sure. its immediately dealloced though. its not a bottleneck, anyway
20:48:07 <dons> local variables are never a problem, are they?
20:48:20 <dons> you get access to the real alloca and the real malloc, if you need them
20:48:40 <jip> dons: in high performance functions, you don't want to call malloc
20:48:45 <dons> sure. you'd use alloca
20:48:50 <dons> and people do
20:48:55 <perry> there's a "real malloc"?
20:49:07 <perry> the one true malloc?
20:49:17 <jip> dons: hm... ah, ok
20:49:20 <dons> the one true malloc
20:49:29 <dons> allocaBytes (I# size) action = IO $ \ s ->
20:49:29 <dons>      case newPinnedByteArray# size s      of { (# s, mbarr# #) ->
20:49:30 <dons>      case unsafeFreezeByteArray# mbarr# s of { (# s, barr#  #) ->
20:49:31 <dons>      let addr = Ptr (byteArrayContents# barr#) in
20:49:31 <dons>      case action addr    of { IO action ->
20:49:33 <dons>      case action s       of { (# s, r #) ->
20:49:35 <dons>      case touch# barr# s of { s ->
20:49:38 <dons>      (# s, r #)
20:49:41 <dons>   }}}}}
20:49:43 <dons> :)
20:49:46 <dons> in all its glory
20:49:47 <Lemmih> Not exactly pretty.
20:49:48 <dons> so that's faster than an alloca, since you don't need to step into C
20:49:58 <jip> dons: but alloca still might not be efficient enough in some cases, where in c if you were to use a local variable there's a good chance it would go into a cpu register
20:50:19 <dons> ah, those kind would go into arguments to functions, no?
20:50:25 <perry> doesnt it still need to be garbage collected?
20:50:34 <dons> such that they get unboxed and the compiler can go to town
20:51:35 <dons> jip, see here for the idea: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
20:51:48 <dons> and also for why local variables are no problem. and why you don't need to go into slow C for it :)
20:52:38 <jip> :)
20:52:51 <newsham> dons: how slow is "stepping into C"?  and is there no way to do an alloca in haskell (ie. adjust the stack pointer down and use the resulting space)?
20:53:26 <perry> whats the stack in haskell?
20:53:27 <dons> well, pass an unboxed argument. its on the stack no?
20:53:43 <dons> rather than a Ptr on the stack to a heap object
20:54:08 <newsham> perry: dunno, but if there's an alloca, there must be a stack :)
20:54:23 <Pseudonym> Or possibly a virtual one.
20:54:29 <perry> i'm wondering about calling that alloca
20:55:38 <newsham> jip: you dont normally alloca register-sized items (like ints)
20:55:43 <perry> i don't know how to reason about how all haskell compilers allocate memory for control structures
20:57:17 <perry> in C you just say how, you dont trust to the compiler to do it for you (and that you didnt mis-reason about what its behavior is going to be)
20:58:06 <sethk> what happens if you use a case construct, and none of the alternatives is true.
20:58:28 <dons> case doesn't match on bools. you mean, if the case doesn't cover all cases?
20:58:39 <perry> i like the idea of being about being able to trust the compiler to do such things for you, but none of this is assured as far as I can tell
20:58:42 <dons> its a non-exhaustive case error.
20:58:55 <dons> which you should also get if you have -Wall turned on, as a static error
20:59:15 <RyanT5000> hm... so i have a function addRow, that takes a Row and a Table and returns a new Table with that row added
20:59:31 <Pseudonym> I like the idea of being able to pre-empt the compiler too.  But I only like to do that when necessary.
20:59:37 <sethk> dons, yes, I do have it turned on.  if I didn't, it's a run time error?
20:59:41 <RyanT5000> but some of the columns are not settable by the user (e.g.: autonumber)
20:59:45 <Pseudonym> Because it's rarely necessary, but when it's necessary, it's REALLY necessary.
21:00:09 <dons> > case [] of (x:xs) -> True
21:00:10 <lambdabot>  Non-exhaustive patterns in case
21:00:16 <dons> runtime error
21:00:25 <RyanT5000> er, nevermind my question
21:00:30 <dons> I think (pretty sure -Wall wasn't turned on)
21:00:36 <Pseudonym> That's why pretty much every non-embedded high-level language has a foreign code feature.
21:00:41 <palomer> -Wall and -Werrer are essential
21:00:44 <Pseudonym> And many of the embedded ones do too.
21:00:46 <palomer> s/errer/error
21:00:49 <dons> yep, runtime: *** Exception: <interactive>:1:0-24: Non-exhaustive patterns in case
21:01:18 <Pseudonym> Even most C implementations have a way to get to assembler if it turns out that's what you need.
21:01:18 <sethk> it looks to me like swapMVar may be blocking.  is that possible?
21:01:44 <dons> hmm. is somethign else taking that MVar in another thread?
21:01:56 <sethk> dons, possibly, if I have a logic error
21:02:22 <perry> see..  default haskell lets unsafe programs execute </obretort>
21:02:55 <Pseudonym> Sure.
21:03:04 <sethk> perry, IRC let's unsafe people chat  :)
21:03:09 <Pseudonym> You have to cross a barrier to get there.
21:03:45 <Pseudonym> The point about safety is that it's not something that you want to compromise unconsciously.
21:03:56 <Pseudonym> It must be a deliberate decision.
21:04:00 <sethk> swapMVar probably does a takeMVar internally?  if so it could certainly block
21:04:02 <perry> i'm from the land of scheme in indiana, but now in the land of haskell in portland oregon..  i get razzed a lot about scheme
21:04:09 <Pseudonym> :-)
21:04:14 <Pseudonym> I'm sure it's good-natured.
21:04:24 <dons> perry, hehe :)
21:04:30 <Pseudonym> Scheme is not a bad language at all.
21:04:39 <dons> portland is haskell town these days, eh?
21:05:01 <perry> well, in terms of higher education
21:05:12 <dons> cool. 
21:05:15 <RyanT5000> i took my senior prog lang class in scheme
21:05:18 <RyanT5000> i wanted to stab myself in the eye
21:05:25 <metaperl> @seen Cale
21:05:25 <lambdabot> Cale is in #haskell. I don't know when Cale last spoke.
21:05:33 <Pseudonym> If you're even half decent at Haskell, you're almost guaranteed a job at Galois.
21:05:45 <metaperl> Pseudonym: not true. shapr was rejected
21:05:46 <RyanT5000> i think a knife would be less painful than scheme
21:05:49 <perry> scheme, like haskell, takes some mastery to make it productive to use
21:05:49 <Pseudonym> Like just about all refuges for smart people, they're always hiring if you're the right person.
21:05:57 <Pseudonym> Really?  I wonder why.
21:06:02 <Pseudonym> Relocation cost?
21:06:13 <metaperl> I dont think it went that far
21:06:19 <dons> Pseudonym: I think it might be a bit competitive. big pool of haskell hackers with PhDs, 1 company emplying them.
21:06:22 <metaperl> I havent seen SyntaxNinja in a long time
21:06:25 <Pseudonym> Right.
21:06:34 <Pseudonym> Though I happen to know that Fergus is a PhD dropout.
21:06:52 <perry> i saw syntaxninja (met him in person for the first time) a couple weeks ago
21:07:00 <dons> he was onlien yesterday, metaperl 
21:07:09 <dons> so he's not MIA anyway
21:07:09 <metaperl> oh
21:07:21 <olliej> anyone happen to know what a MutableArray# *is*?
21:07:39 <RyanT5000> the builtin type upon which arrays are built?
21:07:49 <metaperl> Aetion is another employment option, but galois seems widely preferred
21:07:52 <RyanT5000> i think anything with # is compiler-implementation
21:08:10 <sethk> the only thing that happens with this MVar (it's an MVar String) is it is initialized with an empty string, and readMVar and swapMVar.  so it shouldn't be able to block, correct?
21:08:14 <dons> olliej: its a chunk of GC managed bytes in the Haskell heap
21:08:27 <olliej> dons: righto
21:08:27 <sethk> I don't have to protect swapMVar from readMVar?  that wouldn't make much sense
21:08:29 <Pseudonym> I'd love to work at Galois, but I can't really relocate.
21:08:35 <dons> you get some mutable ops on such a structure, inside ST.
21:08:42 <olliej> dons: cheers
21:09:05 <olliej> dons: trying to work out if there was anything i needed to do aside from allocate memory
21:09:14 <dons> olliej: btw, my home page seems to be back up now, if you're still looking for hs-plugins.
21:09:24 <olliej> RyanT5000: yeah, i was trying to find out if there was any particular structure
21:09:25 <dons> apparenly an admin pulled the power cord on the server by mistake. oops
21:09:30 <olliej> hehe
21:10:01 <olliej> dons: last time our server went down it had 2 double disks failures in seperate drive arrays
21:10:21 <dons> huh.
21:10:34 <dons> all this talk of disk failures makes me nervous
21:10:36 <sethk> dons, I can assume that readMVar and swapMVar won't step on each other, can't I?
21:10:47 <RyanT5000> can you define types in the interpreter?
21:11:17 <dons> sethk, hmm. check the docs (or the src)
21:11:20 <jip> "Error in array index" how can i find out which array, and what the bad index was?
21:11:25 <dons> RyanT5000:  no.
21:11:33 <sethk> dons, the docs don't really say but it's a bizarre enough idea that they probably wouldn't
21:11:33 <RyanT5000> dons: k, just wondering
21:12:20 <sethk> dons, it would be a bug, and if there were that sort of major bug with it, I think it would be known
21:12:30 <dons> yep.
21:12:49 <dons> grr. PackedString in the base libs is just so useless. you can't load a file bigger than !M
21:12:53 <sethk> dons, good. 
21:12:58 <dons> 1M. makes benchmarking a pain
21:25:42 <sjanssen> will FPS be shipped with GHC any time soon?
21:26:10 * jip hopes so
21:27:18 <RyanT5000> >:-(
21:27:25 * RyanT5000 is frustrated
21:27:31 <RyanT5000> i have a design question
21:27:51 <RyanT5000> i have a Table, which is just like in a relational database
21:28:24 <RyanT5000> right now i have a "get" function for each column
21:28:50 <RyanT5000> gah, sorry, i still don't understand my question
21:28:57 <RyanT5000> i'll be back later with it (or not)
21:31:02 <Korollary> This is cute. I can't read one of those garbled images for a blog post that try to verify that I am a human being.
21:31:06 <Korollary> I guess I am not.
21:31:15 <RyanT5000> lol
21:31:30 <newsham> ?where fps
21:31:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:34:10 <dons> i'm hoping to release fps 0.2 today, btw :)
21:34:15 <dons> faster, more exciting, more fun!
21:34:22 <jip> i want to add some sort of logging to some things. the question is, should i redesign the code and the thread the loggin data through everywhere, or should i use something like Debug.trace?
21:34:27 <newsham> i dont need bleeding edge.  just wanted to look it over
21:34:27 <dons> preliminary results:
21:34:28 <dons>         FPS     SPS     PS      [a]
21:34:29 <dons> ++      0.008   0.711   0.781   0.172   
21:34:29 <dons> length  0.000   0.000   0.000   0.008 
21:34:46 <dons> comparing FPS, Simon Marlow's packed string, the old Data.PackedString and a [Char] 
21:34:51 <dons> on a 1M input string
21:37:08 <olliej> anyone know what GHC.Base.build does?
21:38:05 <dons> its usef for list fusion optimisations
21:38:25 <olliej> ...
21:38:28 <dons> functions are given rewrite rules in terms of 'build; which the compielr then uses to remove intermediate data structures
21:38:40 <olliej> aaah
21:38:47 <Korollary> jip: Did you check out the logging features of MissingH?
21:38:52 <dons> i.e. when doing f . g . h, if the funs are in terms of build rewrite rules, the compiler removes the intermediate lists
21:39:05 <jip> Korollary: i did, doesn't that work in the IO monad though?
21:39:08 <olliej> dons: :)
21:39:32 <olliej> dons: next step, working out how it's meant to work
21:39:45 <dons> have a look at some of the examples in the src, perhaps?
21:39:53 <olliej> yeah
21:39:55 <dons> or read the fusion papers on the Research page of haskell.org?
21:39:55 <olliej> digging them up
21:40:16 <olliej> for some reason the Core dump i have of ghc.base doesn't have it...
21:40:18 <olliej> :(
21:41:24 <Korollary> jip: Pure logging probably wouldn't work as you won't see anything until all the other IO actions in the program complete.
21:42:04 <jip> kolmodin: well, i could do something like Debug.trace
21:43:21 <Korollary> I don't think Debug.trace is meant to be relied on like that.
21:43:35 <sethk> definitely not
21:44:02 <jip> yeah, but it would sort of work for me
21:44:51 <jip> i could thread the logging data through my program. the thing is though, i want to be able to disable logging. and i'm afraid that all the threading will still affect performance
21:45:39 <newsham> dons: i had a question for you.  i'm using your plugins package.  i'm building a binary and several modules.  I want to automate the build with cabal.  building the binary is fairly straightforward.  Is there an easy way to automate te
21:45:50 <newsham> the building of the plugins, and installing all the .hs files somewhere?
21:45:59 <newsham> err  .hi files
21:48:25 <dons> build the lot as a single cabalised library? which will then install a libFoo.a and a tree of .hi files?
21:48:30 <dons> or write some gnu make
21:49:48 <newsham> if I make a libf.a, do I specify the path to libf.a while loading?  or to a .o within it?
21:50:54 <olliej> dons: why on earth does build take a higher ranked type?
21:53:50 <dons> you'll have to look up the papers
21:54:33 <olliej> gah
21:54:34 <olliej> :)
21:55:42 <sjanssen> dons: in the darcs version of fps, there's a typo in the comment for elems.  it says "o(n)" where it should say "O(n)"
21:58:13 <dons> ah, thanks
21:58:14 <dons> fixing..
22:45:20 * araujo can't sleep
22:47:54 <Korollary> I can, but I don't like it.
22:53:42 <araujo> hah, me neither, but i want to do it now :-P
22:54:52 <Korollary> trying to sleep never works for me. Trying not to sleep works wonders eventually.
23:02:06 <Korollary> rofl
23:03:43 <araujo> hah
23:11:41 <jip> does haskell have ncurses bindings?
23:12:06 <jip> actually i don't need ncurses
23:29:24 <dons> jip, several
23:29:29 <dons>  check the gui page of haskell.org libraries and tools
23:29:33 <dons> or steal the one from hmp3
23:29:34 <dons> ?where hmp3
23:29:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
23:29:54 <jip> dons: cool, but i actually think that i can just use terminal control codes manually since my needs are simple
23:35:48 <dons> I think there's even a module for that.
23:36:12 <dons> might have to google for "ansi codes haskell"
23:36:44 <ayrnieu> jip - linux has a useful 'console_codes' manpage.
23:37:01 <ulfdoz> EOF from client.
23:37:04 <ulfdoz> ECHAN, sorry
23:42:12 <jip> dons: i can just putStrLn :)
23:42:24 <jip> ayrnieu: yep
23:45:52 <dons> i think malcolm wrote a combinator lib for the ansi codes
23:45:58 <dons> but you know, whatever :)
23:46:56 <jip> i need this for ascii-art output of gameboy emulation :D
