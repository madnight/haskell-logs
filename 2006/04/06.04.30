00:03:29 <dons> cool. building 6.4.2 with -j2 seems to work for the whole system.
00:03:58 <lispy> -j2?
00:04:25 <dons> make -j2
00:04:30 <lispy> oh
00:04:42 <dons> though it isn't great for responisveness on my laptop
00:04:47 <lispy> heh
00:04:49 <lispy> i bet
00:05:19 <dons> its at times like this i need to jack it up on blocks to get enough air flow around the laptop
00:05:30 <dons> ghc is great for testing the laptop fan :)
00:07:11 <sjanssen> dons: in ByteString, what's the advantage of defining append in terms of concat?
00:07:40 <sjanssen> the comment refers to memory use, but won't the same amount of memory have to be allocated in any case?
00:08:22 <sethk> sjanssen, possibly avoiding the allocation for all data + new data, and doing allocation just for new data?
00:09:11 <dons> sjanssen: the concat allocates bit by bit, using realloc. whereas the other version tries one big alloc.  this seems to stress the system more, and i'd get exhausted memory errors far eearlier.
00:09:44 <dons> try the two version on your box. you can test the results with the tests/Bench.hs script
00:10:00 <dons> you'll need a big enough data file linked to tests/bigdata to stress things, though.
00:10:14 <dons> at least 20M
00:10:18 <dons> but more is better.
00:11:38 <dons> sjanssen: you just pondering the comment? or was the performance of append worrying you?
00:11:48 <sjanssen> just pondering
00:18:45 <sethk> How do I extract the IOError from an IO exception?
00:19:13 <dons> isIOError, I think. and pattern match
00:19:21 <dons> ?hoogle isIOErrro
00:19:32 <dons> oh, silly me.
00:19:36 <sethk> dons, I did that, but it is the second () of a catch, and the type is wrong
00:19:48 <sethk> dons, plus Error, not Errro  :)
00:20:26 <sethk> dons, so I've got \e ->  in the second () of catch
00:21:17 <sethk> hmm, the example does show isEOFError e, but I'm getting "couldn't match IOError against Exception"
00:21:32 <dons> let me find some code.
00:21:39 <sethk> do I need to :: IOError ?
00:22:18 <dons> you might need to import GHC.Exception(Excpetion(...)) to pattern match on the interiors
00:22:36 <sethk> I'm import Control.Exception, that's wrong?
00:23:07 <dons> no, but from memory you can't pattern match on individual exception constructors without going into GHC.Exception. maybe I'm misremembering
00:24:08 <RyanT5000> lambdabot offline?
00:24:43 <dons> ?bot
00:24:51 <sethk> dons, did you mean that I put a specific exception in (Exception(...)?  or ... ?
00:24:55 <lambdabot> :)
00:25:21 <RyanT5000> huh.... it appeared in my userlist only when it said that
00:25:25 <RyanT5000> and PMing it wasn't working
00:26:08 <dons> you're getting an exception in the catch handler, and what are you trying to do with it? work out if its from an io error?
00:26:34 <sethk> I need to use isEOFError
00:26:52 <sethk> if it's EOFError, that's a normal condition, other exceptions are genuine errors
00:27:24 <sethk> so I want to do   isEOFError e.  in the doc for IO.Error I see  if IO.isEOFError e, maybe that works...
00:29:08 <dons> ah, its the 'catch' that's the issue.
00:29:11 <dons> ?hoogle catch
00:29:12 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
00:29:12 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
00:29:12 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
00:29:25 <sethk> I need to use GHC.ConsoleHandler.Catch?
00:29:25 <dons> there's two catches.
00:29:31 <dons> Prelude.Catch, no?
00:29:37 <sethk> right.  It's not a console, though
00:29:40 <sethk> that would be three
00:29:43 <dons> you want to catch errors thrown from pure code only. jsut eof errors.
00:29:57 <dons> i..e catch g (\e -> if IO.isEOFError e then return [] else ioError e)
00:30:29 <dons> but you're using the more general catch, the Control.Exception one. and to get an EOFError out of that means taking apart the Exception 
00:30:41 <dons> which can be done if necessary
00:31:06 <sethk> Probably not necessary in this case
00:31:09 <dons> if you only want to catch the EOF exception, and nothing else, then Prelude.catch should be ok.
00:31:13 <dancor> i have no idea why this doesn't work: main = case (parse integer "" "2") of Right xs -> print xs
00:31:28 <dons> if there's other kinds of exceptions beyond IO and user exceptions, you need to use Control.Exception.catch
00:31:56 <sethk> right, that I know about
00:32:09 <sethk> when I take out the import of Control.Exception, the error goes away.
00:32:28 <dons> so usually we import Control.Exception qualified, to avoid confusing the two catches
00:32:49 <dons> or import Prelude hiding (catch) -- the other way around
00:32:55 <sethk> but something is strange.  when I have Control.Exception imported, I get an error saying catch can be GHC.Exception.catch or Control.Exception.catch.  But if I use GHC.Exception.catch, it says "no such thing"
00:33:10 <dons> no no. you just want 'catch'
00:33:13 <sethk> and, if I import GHC.Exception, it complains that I imported it but didn't use anything from it.
00:33:17 <dons> which is provided by the Prelude.
00:33:28 <sethk> dons, in this case, yes, but what if I need the more general catch?
00:33:31 <dons> no need for GHC.Exception -- that's when I thought you wanted to take apart an Exception to find its internals.
00:33:47 <dons> you'd import GHC.Exception to get the Exception data type. and Control.Exception.catch
00:34:03 <sethk> but regardless, if the compiler says it doesn't know if it is Control.Exception.catch or GHC.Exception.catch, why can't I use GHC.Exception.catch?  
00:34:06 <dons> then you could write: catch ... \e -> case e of FooException x -> x ...
00:34:16 <sethk> it says it's undefined, after complaining that it is a possible fit for catch
00:34:20 <sethk> both can't be true.
00:34:31 <sethk> plus, importing GHC.Exception doesn't make GHC.Exception.catch known
00:34:42 <dons> no no. there's no GHC.Exception.catch.
00:34:51 <sethk> then why does the compiler say there is?
00:35:05 <dons> oh, maybe it comes in there via GHC.Base? and via the Prelude?
00:35:13 <sethk> finalizeServer.hs:289:4:
00:35:13 <sethk>     Ambiguous occurrence `catch'
00:35:13 <sethk>     It could refer to either `GHC.Exception.catch', imported from System.IO.Error at finalizeSer
00:35:13 <sethk> ver.hs:12:0-21
00:35:13 <sethk>                           or `Control.Exception.catch', imported from Control.Exception at final
00:35:13 <sethk> iz
00:35:22 <dons> ah, there you go.
00:35:31 <sethk> but then I can't use GHC.Exception.catch
00:35:39 <sethk> if I use it, the compiler says it's undefined
00:35:45 <dons> so you either import Control.Exception qualified. or import System.IO.Error hiding (catch)
00:36:02 <sethk> yes, but you aren't answering my question
00:36:10 <sethk> I know how to fix it, I'm trying to figure out what the messages mean
00:36:32 <dons> there's two catches. the compiler can't figure out which oen you want, because two are in scope, right?
00:36:42 <sethk> you aren't understanding the question
00:36:48 <sethk> I understand that there are two catches
00:37:03 <dons> I know. so the problem is?
00:37:14 <sethk> I'm asking why I can use Control.Exception.catch, but I can't use GHC.Exception.catch,  the compiler says the latter is undefined
00:37:29 <sethk> even though, when I use catch unqualified, the compiler says it might be GHC.Exception.catch
00:37:32 <dons> oh, are you explicitly writing 'GHC.Exception.catch' ?
00:37:43 <sethk> I tried that, the compiler says there is no such thing
00:37:56 <sethk> but I pasted the error message claiming that my catch might be GHC.Exception.catch
00:38:02 <sethk> one of those two statements is wrong
00:38:04 <dons> hmm. let me write some code..
00:38:15 <lispy> the compiler just states where it was imported from right?
00:38:20 <sethk> just take your one liner, and import Control.Exception, and you'll see it.
00:38:29 <sethk> lispy, what difference does that make?
00:38:46 <lispy> sethk: not sure, this is over my head to be honest
00:38:48 <sethk> lispy, it says GHC.Exception.catch, imported from ...
00:39:04 <dons> I don't get the mystery:
00:39:07 <dons> this is fine: main = catch undefined undefined
00:39:14 <dons> as there's a single 'catch' in Prelude coming in.
00:39:22 <dons> this isn't: import Control.Exception
00:39:22 <dons> main = catch undefined undefined
00:39:27 <sethk> yes, the problem is not that I don't understand about the two catches
00:39:27 <dons> since now there's two in scope.
00:39:41 <sethk> the problem is I don't understand why I can't refer to one of them as GHC.Exception.catch
00:39:45 <dancor> is it possible to have a function, parsedOrDie :: Either ParseError a -> IO a, which prints the parse error and exits or returns the parse return value?
00:39:51 <sethk> when the compiler claims that catch might be GHC.Exception.catch
00:40:08 <sethk> it says that the other possibility is Control.Exception.catch, and I _can_ use Control.Exception.catch
00:40:20 <dancor> i'm not sure what i would 'return' in the first case, haskell doesn't like "return ()"
00:40:33 <sethk> dancor, return () is fine, I use it frequently
00:40:46 <dons> sethk, what do you mean by "refer to as GHC.Exception.catch" ?
00:40:48 <sethk> dancor, but the return type has to be IO ()   (or some monad () )
00:40:55 <dons> you mean, literally with that full qualfied name?
00:40:58 <sethk> dons, I pasted the error message from the compiler, right?
00:41:05 <sethk> dons, yes, the name the compiler uses in the message
00:41:11 <sethk> I think it must be the wrong name
00:41:17 <dons> ah, you can't do that. since GHC.Excepection isn't imported.
00:41:34 <dons> the compiler is just saying you're using a catch defined in GHC.Exception, imported through System.IO.Error, yeah?
00:41:35 <sethk> I imported it, it makes no difference
00:41:49 <dons> to refer to it as GHC.Exception explicitly, you'd write
00:41:52 <sethk> yes, but I added  import GHC.Exception, and the compiler still says it's undefined.
00:41:54 <dons> import qualified GHC.Exception
00:42:18 <dons> import qualified GHC.Exception
00:42:19 <dons> main = GHC.Exception.catch undefined undefined
00:42:36 <sethk> Or perhaps GHC.Exception doesn't export catch?  but then it shouldn't be an ambiguous reference
00:42:43 <dons> also works for me:
00:42:44 <dons> import GHC.Exception
00:42:44 <dons> main = catch undefined undefined
00:43:01 <dons> import Prelude hiding (catch)
00:43:01 <dons> import GHC.Exception
00:43:01 <dons> main = catch undefined undefined
00:43:03 <dons> and more.
00:43:52 <sethk> I can't import the same symbol from module X and module Y and use  X.symbol and Y.symbol in my code?
00:44:05 <dons> no. only if you import qualified.
00:44:25 <dons> <X> has to be imported qualified, to use X.foo
00:44:34 <dons> to use both X.foo and Y.foo, you'd import both qualified
00:44:37 <cmarcelo> dancor: about the integer problem... with digit or (many digit) parser it works. looking in Parsec docs seems like integer is defined for token parsers, so integer is a function that takes a TokenParser and returns a CharParser [what is needed by parse function]...
00:44:56 <dons> (this is different to ghci, where you can use full qualified names anywhere. but that's a property of the interactive environment)
00:45:03 <sethk> oh, I don't quite understand why, although maybe it is just to help the compiler.
00:45:14 <sethk> oh, ok, I thought I had done that
00:45:17 <Pawer> i want a haskell T-Shirt
00:45:19 <sethk> I didn't know it was ghci specific
00:45:27 <Pawer> with
00:45:47 <Pawer> We put the Funk in Funktion
00:46:00 <Pawer> XD
00:46:02 <dons> it would be a bit dangerous for some uses if you could use a symbol without a specific import.
00:46:26 <sethk> I don't see why   import X     and then   X.foo   is not an explicit import
00:46:34 <dons> yeah, that seems reasonable
00:46:51 <dons> i.e. import X  import X ; import qualified X 
00:46:56 <cmarcelo> dancor: http://www.cs.uu.nl/~daan/download/parsec/parsec.html#ParsecToken explains how to use these token parsers.. there is an example in makeTokenParser..
00:47:04 <dons> there's an arrow missing there.
00:47:10 <sethk> maybe it is just to make the compiler's life easier, or maybe there are situations I'm not thinking of where it would in fact still be ambiguous.
00:47:13 <dons> import X would be == to import X ; import qualified X
00:47:16 <dancor> cmarcelo: integer  :: CharParser st Integer
00:47:17 <dancor> This lexeme parser parses an integer (a whole number).
00:47:38 <dancor> perhaps there's another integer that is being imported..
00:47:46 <dons> sethk, hmm. possible. it does seem a reasonable thing. but we tend to not have any sugar on the module language at all. probably that's all.
00:47:56 <sethk> dons, ok
00:47:58 <cmarcelo> dancor: the author cheats in the docs =)
00:48:08 <dons> and this would just be sugar for writing two import lines. one qualified, and one not.
00:48:08 <dancor> s/cheats/lies/g ?
00:48:15 <dancor> s/../gc
00:48:33 <dancor> | update
00:49:11 <dancor> parsing is too hard
00:49:24 <cmarcelo> cheats... if you look in the example in makeTokenParser, he is defining "parens = P.parens lexer" .... doing the same for integer , ie, "integer = P.integer lexer" would result in the integer described by the docs..
00:49:36 <dancor> ah
00:53:00 <cmarcelo> dancor: i'll try to make an example...
00:55:12 <cmarcelo> dancor: in section "The members of TokenParser" the author explain "why he cheats".
00:59:19 <dancor> cmarcelo: cool, thanks
01:00:44 <sethk> dons, If in a function I catch an exception, and then return a value, that exception no longer exists, correct?
01:01:08 <cmarcelo> dancor: http://paste.lisp.org/display/19531
01:01:31 <cmarcelo> i'm using ghc...
01:03:13 <dons> sethk, yeah, you catch it and eliminate it somehow.
01:03:21 <dons> you could throw it again, if you wanted to.
01:03:45 <dons> but if you just catch .. (\e -> return 1), then its gone, yes.
01:03:53 <sethk> dons, ok, thanks.
01:04:30 <dons> the precise semantics for exceptions is described in the 'Awkward Squad', which is worth a read some time.
01:04:42 <dons> ?google Tackling the Awkward Squad
01:04:44 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
01:22:43 <sjanssen> dons: I just sent you a ByteString patch
01:23:49 <sjanssen> BS.foldr1 (flip const) (BS.pack [1, 2, 3]) -- fails when Data.List.foldr1 would return 3
01:24:09 <dons> ah! hmm, I wonder why the QuickChecks didn't catch that.
01:24:33 <sjanssen> also Char8's foldr1 was using ByteString's foldl1
01:24:46 <dons> oh. oops.
01:24:52 <dons> applied. thanks.
01:25:17 <dons> do you have some useful foldr1 foldl1 funs I can stick in the QC tests?
01:25:22 <xerox> Good morning
01:26:44 <sjanssen> foldr1 (flip const) == head and foldr1 const == tail, if you don't have those already
01:26:57 <sjanssen> wait, that's totally wrong
01:27:12 <dons> > foldr1 (flip const) "foo"
01:27:13 <lambdabot> 'o'
01:27:17 <sjanssen> foldr1 (flip const) == last, foldr1 const == head
01:27:19 <dons> :)
01:27:43 <dons> ok. good. that's useful, and would have caught the bugs above.
01:29:30 <dons> oh, I know why the QC tests didn't catch it. they're not in the testing list.
01:33:16 <RyanT5000> what does this mean? "A pattern type signature cannot bind scoped type variables `a'  unless the pattern has a rigid type context"
01:33:35 <RyanT5000> specifically, what is a "rigid type context"?
01:34:15 <dons> hmm, I think it means you've got a pattern type signature, (i.e. (x :: a) <- foo) and the 'a' you're binding isn't in scope.
01:34:35 <dons> or there's some other type issue related to 'a', like its an existenital
01:34:38 <sethk> RyanT5000, it has to be able to figure out what a is
01:34:50 <RyanT5000> hm, so a can't be in scope from the function definition?
01:35:04 <RyanT5000> this is in a let binding inside a function whose type signature includes a variable a
01:36:03 <sethk> RyanT5000, if you know the type, you can get rid of the message by annotating the foo in let foo, as in   let (foo :: X) = ....
01:36:36 <xerox> -fno-monomorphic-restriction and a forall wouldn't help right?
01:36:53 <RyanT5000> fixed it
01:37:10 <RyanT5000> i had
01:37:22 <RyanT5000> let func x :: a -> Word8
01:37:31 <RyanT5000> what i meant was (func x) :: a -> Word8
01:37:53 <RyanT5000> so instead i just annotated the RHS with Word8
01:38:15 <xerox> Right.
01:38:41 <xerox> ?version
01:38:41 <lambdabot> lambdabot 3p427, GHC 6.4.1 (Linux i686 3.20GHz)
01:38:41 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:39:40 <dons> RyanT5000: ah, yes. ambiguous. :: was binding to 'x'
01:40:23 <RyanT5000> yeah
01:40:40 <dons> RyanT5000 reaches level 2 type hacker :)
01:48:53 <RyanT5000> :)
01:54:12 <skew> hmm, I'm not sure how this aio_wait is supposed to work.
01:55:13 <skew> it looks like all the aio operations work on some particular request
02:05:59 <xerox> I received a mail from a student willing to implement Incremental GC in GHC !!!!
02:14:24 <vincenz> xerox: whaty does GHC use now? CC?
02:14:53 <xerox> Beats me.
02:15:39 <RyanT5000> wow; fun bug; my opengl textures only work when i print their data to the console prior to making them into textures
02:17:38 <mahogny> vincenz, backend compiler?
02:18:18 <RyanT5000> is there a wait milliseconds in haskell?
02:18:27 <vincenz> mahogny: ?
02:18:28 <RyanT5000> (rephrase: where is it)
02:18:37 <mahogny> vincenz, what did you want to know?
02:19:00 <vincenz> mahogny: xerox said someone wants to put incremental gc in ghc, so I wondered what it used now... Copying collector?
02:19:14 <vincenz> or good ol' refcounting :D
02:19:36 <mahogny> aha. I don't have insight in that sorry
02:19:38 <vincenz> you know what would be cool?  a hardware garbage collector
02:19:45 <mahogny> but I doubt it was refcounting
02:19:51 <mahogny> hmm
02:19:52 <vincenz> I know
02:19:54 <vincenz> it was a joke
02:19:54 <skew> vincenz: it's a generational scheme now
02:20:05 <vincenz> skew: so copying
02:20:30 <vincenz> heh, a hardware GC would rock, and wouldn't be too hard if you did copying... get a piece of ram, a dma and add some intelligence
02:20:45 <mahogny> hwgc doesn't sound bad, given that you are ready to put some extra logic in your memories for the task
02:20:56 <mahogny> then you don't even have to involve the cpu
02:21:02 <vincenz> yeah
02:21:15 <vincenz> all you have to do is make the dma slightly more intelligent
02:21:17 <skew> if you could hook relocation into cache coherency protocols
02:21:18 <mahogny> but then we have to agree on a scheme... ouch :)
02:21:38 <vincenz> mahogny: depends on how programmable the dma is
02:21:44 <mahogny> true
02:21:56 <mahogny> but flexibility costs, both $ and performance
02:21:58 <skew> vincenz: there are some papers about an incremental scheme
02:22:15 <skew> where entry procedures have some extra code to let the gc collect a few objects at a time
02:23:32 <dons> RyanT5000: threadDelay
02:23:37 <dons> ?hoogle threadDelay
02:23:38 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
02:24:09 <RyanT5000> dons: thanks
02:26:22 * vincenz sighs
02:26:28 <vincenz> nearly 7 days of downloading
02:26:32 <vincenz> 4.3 GB
02:26:39 <vincenz> and it's salling on the last few 100 kb
02:26:41 <vincenz> stalling
02:26:52 <RyanT5000> ouch
02:27:04 <RyanT5000> restartable?
02:27:09 <vincenz> it's bittorrent
02:27:11 <vincenz> so I just let it rip
02:27:38 <vincenz> but yeah .. 0kbs
02:33:55 <RyanT5000> ok guys i am totally confused
02:34:19 <RyanT5000> my code crashes on one line if i take out another line
02:34:38 <RyanT5000> the problem is, the line that gets taken out is significantly after the line that crashes
02:34:51 <vincenw> Grr
02:34:53 <RyanT5000> they both read the same array using FFI calls
02:34:55 <vincenw> I hate my provider
02:35:40 <RyanT5000> the first one gets 8kb in and  then craps out, unless the second one will eventually happen
02:35:47 <RyanT5000> i don't understand how that's even causal
02:39:32 <vincenz> who said computers have to be causal?
02:39:43 <RyanT5000> good question
02:40:16 <sethk> RyanT5000, when you track down the problem, you'll see
02:40:29 <RyanT5000> another excellent and helpful observation
02:40:38 <sethk> RyanT5000, I thought you would like it
02:40:40 <vincenz> zen
02:40:41 <RyanT5000> oh, interesting: if i do the first operation twice,  it works
02:40:44 <RyanT5000> WTF
02:40:54 <RyanT5000> so if i try to read from the array twice, it works
02:40:57 <RyanT5000> otherwise it crashes
02:40:58 <sethk> RyanT5000, well , now you should have enough to figure it out.  :)
02:41:13 <RyanT5000> i wish :P
02:41:18 <vincenz> RyanT5000: do not forget to see the computation through the data
02:41:40 <sethk> RyanT5000, put some extra do nothing lines between the two you've identified, see if the behavior changes
02:42:10 <RyanT5000> actually there were like 5  lines in between to begin with
02:42:24 <RyanT5000> including, e.g., taking the data the first thing gets out and turning it into a texture
02:42:40 <RyanT5000> this must be a GC issue
02:43:00 <RyanT5000> it must be that if i touch it later it doesn't  get GCed
02:43:05 <RyanT5000> if i don't, it does
02:43:09 <vincenz> > reverse "palsnez" ++ " RyanT5000"
02:43:10 <lambdabot> "zenslap RyanT5000"
02:43:44 <RyanT5000> lol i don't quite know how to take taht
02:45:38 <RyanT5000> fixed!
02:45:48 <RyanT5000> lock/unlock the datastructure prior to accessing it
02:46:20 <RyanT5000> of course, there isn't really any documentation
02:46:27 <RyanT5000> so it doesn't really say to do that
02:49:27 <vincenz> see it helped !
02:49:27 * vincenz sniffs
02:49:27 <vincenz> 700 kb out of 4.2 GB left and it's at 0 kb/S
02:49:27 <vincenz> I think that is a problem with how bittorrent and most download thingies work
02:49:27 <vincenz> see they download incrementally
02:49:31 <vincenz> which means they download the last part of the file last
02:49:48 <vincenz> obviously people that ahve that part will have the whole file and stop downloading, and therefore uploading
02:50:16 <vincenz> I think the order of download should be randomized per user
02:51:26 <dons> RyanT5000: you talking about freeze/unfreezeing pure arrays in haskell? or sis this some other language?
02:51:46 <vincenz> what datastructure has to be frozen?
02:51:53 <vincenz> seems odd that otherwise you'd get heisenbugs
02:53:06 <RyanT5000> dons: locking and unlocking an SDL surface
02:53:37 <RyanT5000> vincenz: bittorrent does download randomly
02:53:43 <vincenz> RyanT5000: it does?
02:53:48 <RyanT5000> yep
02:53:49 <vincenz> neat
02:53:56 <dcoutts> xerox, you've not accepted me as a mentor for haskell.org yet it seems
02:54:12 <dcoutts> xerox, either that or it got lost in the system and I'll try again
02:54:18 <RyanT5000> would anyone be interested in mentoring an OpenGL windowing system / graphics engine?
02:55:03 <mahogny> RyanT5000, what would the windowing system do?
02:55:17 <vincenz> mahogny: windows vista :D
02:55:23 <mahogny> lol
02:55:24 <RyanT5000> actually, pretty close
02:55:36 <RyanT5000> however it's intended for use in games and 3d modeling programs
02:55:50 <mahogny> actually, I have cooler plans but I don't think a student can pull it off in 3 months :)
02:55:54 * vincenz has been wanting to make a 3D game
02:55:57 <vincenz> mahogny: oh?
02:56:04 <mahogny> a replacement for X
02:56:07 <vincenz> mahogny: write hindows?
02:56:18 <mahogny> hindows? o_O
02:56:23 <vincenz> haskell windows
02:56:26 <mahogny> eew
02:56:46 <mahogny> one is bad enough :)
02:56:48 <vincenz> anyways I have to run, I'm expected for lunch at my grandparents
02:57:11 <vincenz> mahogny: or hac(k) os x
02:57:45 <mahogny> xerox, "Haskell.org     Your Mentoring Acceptance is Pending" <-- is it supposed to be like this? :(
02:58:04 <xerox> We're working it out now
02:58:06 <mahogny> RyanT5000, what would the windowing system do?
02:58:14 <mahogny> ehr
02:58:19 <vincenz> yeah would it be an app or the framework
02:58:20 <mahogny> I mean, what abstraction is it?
02:58:28 <mahogny> hmm
02:58:37 <RyanT5000> well, i haven't decided *completely*, but it won't be entirely yampa-based
02:58:38 <vincenz> anyways
02:58:39 <vincenz> really gotta run
02:58:43 <RyanT5000> i don't think yampa is flexible enough
02:58:45 <vincenz> later
02:58:45 <mahogny> RyanT5000, most games would want their own GUI from scratch so I dunno if there is much use in it
02:58:56 <RyanT5000> mahogny: why would they want it from scratch?
02:58:58 <vincenz> mahogny: well he could create something I've been wanting
02:59:05 <vincenz> mahogny: something like crystal space but for haskell
02:59:06 <mahogny> vincenz, shoot
02:59:08 <vincenz> or possibly a wrapper
02:59:09 <RyanT5000> it would basically be a combinator library
02:59:13 <mahogny> hmmm
02:59:17 <mahogny> not a bad idea (the port)
02:59:31 <vincenz> I mean crystal space is neat
02:59:35 <vincenz> but coding in c++ o.O
02:59:41 <vincenz> it should be feasible too
02:59:42 <mahogny> agree
02:59:43 <mahogny> eew
02:59:48 <vincenz> you can make c callbacks from haskell
02:59:52 <vincenz> and you can wrap c funcs from haskell
02:59:52 <mahogny> RyanT5000, most games want their own look and feel, so that essentially means new widget set etc
03:00:07 <RyanT5000> mahogny: but the way the widgets work doesn't change
03:00:11 <RyanT5000> it's just a skin
03:00:24 <vincenz> RyanT5000: but either you end up with something monstrous to be that flexible
03:00:32 <mahogny> yeah
03:00:36 <vincenz> RyanT5000: or something minimal where it's basically rol your own
03:00:46 <RyanT5000> i'm not sure that's the case
03:00:51 <mahogny> so I dunno how much point there is. game guis are usually small enough to be coded without a library
03:00:52 <vincenz> libraries can't be too flexible
03:01:05 <vincenz> after a certain amount of flexibility they either become monstrous or minimal
03:01:16 <RyanT5000> that's true
03:01:17 <vincenz> minimal== trivial
03:01:43 <mahogny> one could do the GUI stack without the widgets, but that's some 100 lines at most. not much work
03:01:45 * vincenz runs off
03:01:51 <vincenz> :
03:02:07 <RyanT5000> i don't really see why a 3d gui library would be any different from a 2d gui library and we certainly have plenty of those
03:02:36 <mahogny> even 2d games don't use 2d gui libraries. that might be a hint :)
03:02:46 <RyanT5000> i didn't say it had to be entirely for games
03:02:52 <RyanT5000> not to mention, look at the newer games
03:02:59 <RyanT5000> they're tending towards more and more complex windowing systems
03:03:22 <RyanT5000> e.g.: if you've played WoW, you know that the windowing system would benefit from having a bit more structure behind it
03:03:34 <RyanT5000> some windows move, some don't; some save their position when you close them, some don't
03:03:47 <RyanT5000> the skinning is flawless, but the mechanics basically suck
03:03:51 <RyanT5000> that's why you need a skinnable library
03:04:02 <RyanT5000> and i still don't see why it'd be hard
03:04:04 <mahogny> hm. ok, now I see what you want. but I don't know if it's worth the effort currently. we barely even have 3d games, making 3d guis is a bit too early :)
03:04:17 <mahogny> not hard. making a gui library is easy, but it's a darn lot of work
03:04:33 <RyanT5000> well i would like to do it anyway for a game i'm making
03:05:03 <RyanT5000> the choice is to either half-ass it like anyone else, or open-source it and try to make a real thing
03:05:35 <mahogny> I think you should do the library at the same time as you do the game, then fork it off in case it becomes good
03:05:56 <RyanT5000> yes, but... summer of code :)
03:06:16 <mahogny> how far have you come on the game?
03:06:27 <RyanT5000> i have a lot of C# code
03:06:33 <RyanT5000> server
03:06:43 <mahogny> you write the server first? o_O
03:06:46 <RyanT5000> mostly data-handling though
03:06:54 <RyanT5000> yeah, welll i wrote a crap client
03:06:56 <genneth> @pl \f x = x
03:06:56 <RyanT5000> with windows forms
03:06:57 <lambdabot> (line 1, column 6):
03:06:57 <lambdabot> unexpected "="
03:06:57 <lambdabot> expecting pattern or "->"
03:07:17 <RyanT5000> it's not a real-time game
03:07:41 <RyanT5000> and i'd like it to have a heavyweight windowing system, because it's relatively high complexity
03:08:00 <RyanT5000> anyway i'm just starting on the client in haskell
03:08:10 <tennin> turn-based strategy?
03:08:12 <RyanT5000> yeah
03:08:55 <mahogny> hm. dunno how much I would be able to contribute as a mentor. not much if you are gonna make it functional style
03:09:29 <RyanT5000> yeah i'm definitely going for functional style
03:10:23 <skew> my linux/aio.h won't even compile
03:10:37 <mahogny> linux in a nutshell
03:12:44 <RyanT5000> mahogny: do you have much experience with GUIs, without worrying about functional style?
03:13:13 <mahogny> RyanT5000, used them a lot, but mainly in other languages
03:15:32 * mahogny finally figures how he can make use of monads for his Z project o_O
03:15:34 <RyanT5000> so would you consider mentoring me on that anyway? i can try to find someone with more fp knowledge, but  to be honest i think i can do a pretty good job with it anyway
03:15:51 <RyanT5000> i'll just read every paper i can find on fp-related stuff (as i've already been doing)
03:16:26 <mahogny> well, I could. I have no problem with the 3d stuff
03:16:40 <RyanT5000> ah; yeah i don't have a ton of experience with that
03:16:45 <RyanT5000> one class, and some external work i did
03:16:49 <RyanT5000> and i wrote a couple shaders
03:17:12 <mahogny> hm. interesting idea. has anyone considered making a haskell shading language?
03:17:19 <RyanT5000> sounds very hard
03:17:22 <mahogny> one could use monads for that
03:17:23 <RyanT5000> it's basically assembler
03:18:01 <mahogny> just use do-notation to build up an abstract tree, pass it to a compiler written in haskell, and upload. then you can write shaders without switching language
03:18:21 <RyanT5000> oh you mean a domain specific language within haskell
03:18:32 <RyanT5000> yeah that'd be pretty cool
03:18:33 <mahogny> embedded language
03:18:38 <mahogny> think it would be nice
03:18:45 <RyanT5000> yeah that sounds really useful
03:19:04 <RyanT5000> alright, well, i have to get some sleep, now that it's broad daylight here
03:19:08 <RyanT5000> @localtime ryant5000
03:19:19 <mahogny> then one could also generate new shaders on demand, functional style ^_^
03:19:21 * mahogny adds project
03:19:22 <RyanT5000> yep :)
03:20:08 <RyanT5000> i might be willing to work on that if  i can't get anybody onboard for my GUI engine
03:20:38 <RyanT5000> do we have to get the projects in by the 1st or the 7th of next month?
03:21:05 <RyanT5000> (i.e.: before student applications start, or once they end)
03:21:45 <RyanT5000> nevermind; cya :)
03:21:59 <vincenz> RyanT5000: just popped in
03:22:05 <vincenz> RyanT5000: what kind of game is it?
03:22:16 <RyanT5000> it's a turn-based-strategy
03:22:26 <RyanT5000> totally transactional; everything resolves between turns
03:22:36 <vincenz> ah
03:22:39 <vincenz> :)
03:22:46 <vincenz> and server-based?
03:22:48 <RyanT5000> yeah
03:22:50 <vincenz> hmm
03:22:53 <vincenz> seems like an odd choice
03:22:58 <RyanT5000> how come?
03:22:58 <vincenz> server-based implies large user base
03:23:06 <RyanT5000> how so?
03:23:10 <vincenz> and I don't see people enjoying to wait for others to make a turn
03:23:15 <vincenz> RyanT5000: look at Age of Empires and co
03:23:22 <vincenz> RyanT5000: no server based up to 8-16 people
03:23:39 <RyanT5000> i can do "a lot" of people per game server-based
03:23:43 <RyanT5000> it's really cheap computationally
03:23:54 <RyanT5000> like 50, no problem
03:24:07 <RyanT5000> it's a relaxed gameplay style; a turn per day or something
03:24:13 <vincenz> ah, ok :)
03:24:15 <RyanT5000> it's not a huge market but it's completely unexploited
03:24:20 <vincenz> sort of like utopia
03:24:32 <RyanT5000> is that a web game?
03:24:35 <vincenz> isn't a web interface more amenable to once a day?
03:24:47 <mahogny> RyanT5000, googled around. seems like there already exist a functional shader language
03:24:48 <vincenz> RyanT5000: yep web based turn based strategy game
03:24:52 <vincenz> mahogny: yep
03:24:52 <RyanT5000> no, because our stuff is big and there's a board
03:24:57 <vincenz> alright
03:25:05 <vincenz> well I'd be interested to hare and talk more later
03:25:06 <vincenz> as it is
03:25:11 <vincenz> I'm late for lunch at my granparents
03:25:13 <vincenz> cya!Ã¨
03:25:17 <RyanT5000> alright, cya :)
03:25:20 <RyanT5000> (really leaving now)
03:52:32 <Heffalump> Has nhc98 disappeared from Debian post-sarge?
03:53:42 <ibid> yes
03:53:48 <Heffalump> why? unmaintained?
03:53:55 <ibid> it was discussed on the debian-haskell list
03:54:24 <Heffalump> oh, I must have missed that
03:54:26 * Heffalump --> look
03:54:36 <ibid> see http://urchin.earth.li/pipermail/debian-haskell/2005-September/000130.html
03:54:40 <Heffalump> unless the discussion was just after ICFP 2005, in which case I remember the conversation there about it
03:54:51 <Heffalump> but had thought the conclusion was different
03:55:40 <ibid> also http://urchin.earth.li/pipermail/debian-haskell/2005-October/000133.html
03:55:55 <Heffalump> ah, ok.
03:56:04 <Heffalump> my memory is just faulty then :-)
03:56:32 <ibid> and http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=331704&sourceid=mozilla-search
03:58:45 <dons> hey Heffalump, how's things?
03:58:52 <Heffalump> hiya
03:58:55 <Heffalump> not bad, rather busy
03:58:57 <Heffalump> just moved house
03:59:16 <Heffalump> been spending spare time trying to understand darcs stuff without too much success
03:59:31 <dons> cool.
04:00:01 <dons> I attempted to rewrite lambdabot's network layer to use byte strings today, without too much success :)
04:00:22 * dons -> dinner
04:00:39 <xerox> Dons bount itself to dinner, yay.
04:00:42 <xerox> *bound
04:00:52 <xerox> *himself
04:00:53 <xerox> agh.
04:01:17 <araujo> Good morning!
04:05:22 <xerox> Cale: ping
04:05:25 <xerox> Hi araujo.
04:11:33 <araujo> Hello xerox 
04:29:46 <skew> does anybody here know how to use aio and epoll?
04:31:29 <dcoutts> epoll, not aio
04:32:23 <dcoutts> epoll is just like select/poll (when epoll is in level triggered mode)
04:32:24 <skew> trying to follow this threading paper http://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf, but I don't know how to get aio working
04:32:57 <skew> I suppose I can just try a plain read for now
04:32:59 <dcoutts> aio only works on linux at the moment for O_DIRECT files
04:33:11 <dcoutts> ie not plain cached files
04:33:22 <dcoutts> aio on linux is a pain at the moment
04:33:28 <dcoutts> and not much faster
04:33:30 <skew> hmm
04:33:52 <skew> maybe I'll just use read on nonblocking files then
04:33:59 <dcoutts> yep, much easier
04:34:10 <dcoutts> it's also possible to use mmap + madvise
04:34:57 <dcoutts> of course, for files, nonblocking doesn't mean anything anyway
04:34:57 <skew> espeically a pain when the header for io_getevents doesn't even compile
04:35:05 <dcoutts> heh
04:35:27 <skew> I was trying to see if epoll could notify for aio completion
04:35:37 <dcoutts> the other thing is that I don't think aio can be easily integrated into a select/poll/epoll loop
04:35:53 <dcoutts> right, I don't think it can (yet)
04:36:03 <skew> that can run in a separate thread
04:36:10 <musasabi> AIO is painfull++
04:36:12 <dcoutts> because that's not the way that posix aio was specified
04:36:12 <skew> that's the implemention demonstrated in the apper
04:36:23 <musasabi> the standard interface is not very good.
04:36:27 <dcoutts> yep
05:56:27 <shapr> Good morning #Haskell!
05:57:37 <nnunley> Good afternoon, shapr.
05:58:05 <shapr> greetinz nnunley 
06:14:36 <mahogny> has anyone tried to do anything serious with Xen?
06:26:28 <morans> mahogny: Xen the system virtuaiser thingy?
06:26:42 <mahogny> yes
06:27:01 <morans> a friend/colleague of mine has worked with it a bunch
06:27:12 <morans> his comment on it is "don't use it for desktops, but its ok for servers"
06:27:27 <morans> his field is on dynamic allocation of system resources to remote users
06:27:44 <morans> so they're using it so that you can request a virtual host running OS of your choice
06:27:48 <morans> or something like that
06:28:22 <morans> http://workspace.globus.org/
06:28:34 <mahogny> well, I only considered it for early development of a new OS
06:29:02 <mahogny> saves time if you can abstract away the evil hardware for a while
06:29:47 <morans> yeah
06:29:57 <morans> i can't really make any comment on that
06:31:04 <morans> but I think the point of it is that it *doesn't* abstract the hardware...
06:31:53 <morans> dunno
06:32:50 <morans> mahogny: haskell-based OS?
06:32:55 <mahogny> it does half of it. you can use a few friendly C-calls instead of setting OS-specific CPU registers. and it sets up a lot of the memory for you
06:33:06 <mahogny> half C, half haskell. probably
06:33:11 <morans> ok
06:33:35 <xerox> Yaaaawn
06:33:43 <mahogny> agree
06:33:58 <morans> mahogny: ok
06:34:15 <mahogny> no. I meant, I agree with xerox :)
06:34:15 <morans> mahogny: its something thats half way down my 'play with this' list...
06:34:30 <morans> hehe
06:35:26 <morans> looks like tim's virtual workspaces stuff lets you shut down VMs and send them elsewhere...
06:35:45 <morans> http://workspace.globus.org/vm/index.html
06:38:26 <ghum> Hello
06:38:50 <ghum> test
06:39:01 <mahogny> omg. globus too. hypervisors are way overrated
06:39:09 <morans> ghum: ola
06:39:18 <morans> mahogny: you know globus?
06:39:41 <ghum> aaah! chakka. Sorry for flooding with tests, I just startet a new irc client ...
06:39:46 <mahogny> morans, yeah. heard about it many years ago. never used it myself though
06:41:09 <ghum> I am a TOTAL haskell noob. And working my way through the tutorial. I try toUpper and isUpper and Char.isUpper ... and fail, because of "undefinede Variable". I am on winhugs
06:41:45 <ghum> I am tooo challenged to find out how to activate which library :(
06:41:54 <shapr> > toUpper "fooby"
06:41:55 <lambdabot> Couldn't match `Char' against `[Char]'
06:41:59 <shapr> > map toUpper "fooby"
06:42:00 <lambdabot> "FOOBY"
06:42:17 <ghum> Fact> map toUpper "fooby"
06:42:18 <ghum> ERROR - Undefined variable "toUpper"
06:42:36 <shapr> @index toUpper
06:42:37 <lambdabot> Data.Char
06:42:43 <shapr> import Data.Char
06:43:12 <ghum> @index toUpper
06:43:12 <lambdabot> Data.Char
06:43:13 <ghum> ERROR - Syntax error in expression (unexpected `@')
06:43:33 <morans> ghum: type the import line, not the @index line
06:43:38 <shapr> If a line on irc starts with @ it's a command to lambdabot 
06:43:49 <shapr> lambdabot: has a bunch of tools that help with Haskell programming.
06:44:14 <ghum> import Data.Char
06:44:15 <ghum> ERROR - Syntax error in expression (unexpected keyword "import")
06:44:55 <shapr> ghum: 'import Data.Char' needs to be inside your source file that you load.
06:44:56 <morans> actually, I don't know how to do imports in hugs in interactive mode...
06:45:06 <ghum> aaaah!
06:45:08 <shapr> If you want to access a module interactively, try :m + Data.Char
06:45:45 <ghum> :m + Data.Char
06:45:47 <ghum> ERROR - Cannot find module "+"
06:46:10 <ghum> hmmm... manual tells me something that "toUpper" and alike has been included to Prelude.hs
06:46:38 <shapr> Ok, try :m Data.Char
06:47:08 <ghum> I did that allready , shapr :(  ERROR - Cannot find module "Data.Char"
06:47:30 <Lemmih> It's :l Data.Char
06:47:51 <xerox> :also Data.Char
06:47:52 <morans> ghum: as you can see, we are all experts.
06:48:02 <xerox> (in Hugs, that is.=)
06:48:13 <shapr> Oh maybe you're using a really old version of Hugs?
06:48:20 <ghum> okay, I startet ghc, and it is working
06:48:41 <ghum> :I Data.Char
06:48:42 <ghum> Unknown module `Data'
06:48:50 <ghum> back to winhugs...
06:49:08 <xerox> Isn't it :also Module, in Hugs?
06:49:30 <ghum> :also is good
06:49:42 <ghum> aaah!
06:50:00 <ghum>  map toUpper "Nasenbaer"
06:50:01 <ghum> "NASENBAER"
06:50:03 <ghum> Data.Char> 
06:50:52 <ghum> nice... haskell is a totally different language (coming from ABAP/4, C++, Java, Python, SQL) but the problems remain the same ... having the correct library loaded :)
06:50:54 * Lemmih wonders why ghum tried ':I'.
06:51:35 <xerox> Lemmih: because you said "It's :| Data.Char" :-)
06:51:53 <ghum> Lemmih, because you recommended it? maybe that char was a "l" like in "library" not a "I" like in "IRC" ???
06:52:12 <Lemmih> I said: : l (with out the same).
06:52:18 <ghum> I l
06:52:19 <Lemmih> s/same/space/
06:53:10 <ghum> Lemmih, so it is a little l like in head toLower "Lemmih" ??
06:53:28 <ghum> Lemmih, so it is a little l like in head map toLower "Lemmih" ?? of course
06:53:34 <xerox> toLower $ head "Lemmih" -- maybe
06:53:39 <Lemmih> Yes.
06:53:57 <shapr> Yay! Peng Li and Steve Zdancewic's unified thread & event framework will be released next tuesday!
06:54:19 <ghum> xerox, and now please give me a tipp what "$" is supposed to mean :)
06:55:12 <xerox> ghum: you put a '(' where you see the dollar sign, and a ')' at the end of the line.
06:56:03 <ghum> wow... $ is a shortcut for "put rest of line in braces" ... that is fine
06:56:33 <isaacd> a $ b = a b ; infixr $ 0
06:56:35 <xerox> f $ x = f x -- i.e. loose function application
06:57:33 <ghum> toLower $ head "Lemmih"  is the same as head $ map toLower "Lemmih"
06:57:59 <xerox> Thanks to lazy evaluation.
06:58:05 <ghum> is there any use in preferring the shorter one, or will haskell automagically reduce all effort to the same?
06:58:22 <xerox> Both.
06:59:01 <ghum> toLower $ head "Lemmih"
06:59:03 <ghum> 'l'
06:59:05 <ghum> (41 reductions, 57 cells)
06:59:06 <ghum> Data.Char> head $ map toLower "Lemmih"
06:59:08 <ghum> 'l'
06:59:09 <ghum> (43 reductions, 61 cells)
06:59:23 <ndm> @hoogle copy
06:59:24 <lambdabot> hoogle: BItem ::
06:59:24 <lambdabot>  
06:59:50 * ndm crashes hoogle
06:59:58 <ghum> so haskell reduces it, but has more to reduce and that takes more "cells", whatever "cells" may be?
07:00:23 <ndm> ghum: cells, think amount of memory
07:00:33 <ndm> reductions, think processor ticks
07:01:10 <ndm> or better, think instructions executed
07:02:41 <ghum> hmmmm... so it is not really "lazied" to the same amount ...
07:05:16 <ndm> ghum: whats your question?
07:05:22 <ndm> i joined part way though :)
07:06:04 <ghum> ndm, not really a question. I just got the impression from reading tutorials and articels, that haskell will do something like "automagically reduce functions to the least needed work"
07:06:21 <ghum> something like query optimization does in SQL
07:06:23 <ndm> ghum: it won't do more work than necessary
07:06:25 <morans> ghum: its only a *tiny* bit different...
07:06:27 <ndm> thats a different thing
07:07:53 <ndm> its not possible to reduce functions to the least work required, although GHC does do an impressive job
07:09:46 <goron> Those reductions... aren't those graph reductions?
07:11:29 <ghum> do you have a tipp how I can turn on the same statisitcs on ghc?
07:11:34 <ghum> (ghci)
07:11:59 <ghum> found it
07:13:20 <ghum> not exactly :)))) :set +s gives me 0.00 secs, 0 bytes :)
07:13:30 <mauke> error?
07:13:42 <ghum> not really an error
07:13:52 <ghum> I just wanted to see similiar statistcs like in hug
07:14:08 <ndm> ghum: ghc can't do that, beacuse they're very different
07:14:11 <ghum> and ghc gives me total runtime and total memory used ... which is 0 :)
07:14:26 <ghum> ndm, thanks... so no need in more searching :)
07:14:42 <ndm> indeed
07:15:55 <musasabi> My version of JHC just performend the first successful foreign export call ^_^
07:16:07 <ghum> hmmmm... hugs wants me to write   map isUpper "Laoka"; ghc wants me to write map Char.isUpper "Laoka"
07:16:25 <morans> mahogny: so I have a running joke with another colleage about interfacing Haskell to globus
07:16:36 <ayrnieu> ghum - import isUpper from Char , if that distresses you.
07:16:42 <morans> mahogny: we just keep looking for something where it actually makes sense
07:16:44 <norpan> not toUpper?
07:16:57 <morans> |hgm: waitForProcess: interrupted (Interrupted system call)
07:17:04 <morans> what does that error mean and how do I track it down?
07:17:13 <ghum> ayrnieu, not really distresses... just, wanted to learn the "best practive" for portable code
07:17:44 <ghum> because hug does not allow me to use qualified names 
07:18:10 <ayrnieu> ghum - does hugs mind it if you import isUpper from Char ?  Also: 'portable' in Haskell is 'hey, it works on ghc on all of the archs that ghc supports!'
07:19:07 <ayrnieu> (or it very quickly becomes that.)
07:19:32 <ghum> okay. So the message is "stick to ghc or stick to hugs"
07:20:12 <ayrnieu> you needn't apply this divisiveness to every line of your program :-)
07:42:37 <ndm> ghum, which version of hugs are you using?
07:42:52 <ndm> and the solution is to do "import Char" at the top of your file
07:43:02 <ndm> then both do map isUpper
07:43:04 <ellism> Has anyone here had any success cross compiling ghc 6.4.2?  I am running into a problem on the host machine building DynamicLinkler.hsc, ghc is complaining about RTLD_NEXT and RTLD_DEFAULT being undefined in include/HsUnix.h
07:43:21 <ghum> 20051031 @ md,
07:43:22 <ndm> ghum: i use Hugs and GHC all the time, on the same code, there are very few differences
07:45:16 <ndm> hugs does allow qualified names
07:45:58 <Igloo> ellism: What are the two OS/arches involved?
07:46:30 <ghum> ndm: i am coming from python. so big challenge is to learn that "some commands are not possible on interactive console"!
07:46:33 * Igloo drowns in packet loss
07:46:49 <ndm> ghum, they all are, you are just poking the interpetter wrong
07:47:00 <sieni> Igloo: that sounds absurd
07:47:01 <ndm> ghum: ":l Char", then do isUpper
07:47:02 <ghum> ndm: and in my tutorial there was sth like "hugs does not like qualified names"
07:47:04 <ayrnieu> the others aren't commands.
07:47:18 <ndm> ghum: which I bet applies to hugs from over 5 years ago, when i didn't :)
07:47:21 <ellism> lgloo: Host: i386-linux (using ghc 6.4.1 on a Gentoo machine) Tariget: i386-darwin (x86 mac mini)
07:47:27 <ndm> :l Char
07:47:33 <ndm> then Char.isUpper on Hugs works just fine
07:47:51 <ghum> :l Char
07:47:53 <ghum> Hugs session for:
07:47:54 <ghum> file:{Hugs}\libraries\Hugs\Prelude.hs
07:47:56 <ghum> file:{Hugs}\libraries\Prelude.hs
07:47:57 <ghum> file:{Hugs}\libraries\Hugs.hs
07:47:59 <ghum> file:{Hugs}\libraries\Hugs\Char.hs
07:48:01 <ghum> file:{Hugs}\libraries\Data\Char.hs
07:48:02 <ghum> file:{Hugs}\libraries\Char.hs
07:48:03 <ghum> Char> map Char.toUpper "Lala"
07:48:05 <ghum> ERROR - Undefined qualified variable "Char.toUpper"
07:48:06 <ghum> Char> 
07:48:24 <Igloo> ellism: IIRC RTLD_NEXT is a GNU extension, so that's probably the problem. I think wolfgang/xerox may be able to supply Darwin x86 binaries
07:48:43 <ndm> ghum: that looks like a bug...
07:48:43 <ghum> ndm, may be ... I just read "haskell" all the time in c.l.p. because in Python we "stole" some things from haskell .. so I am reading through tutorial and try my best :)
07:48:47 <ndm> i'll report it
07:48:59 <ndm> if you do Data.Char.toUpper it works
07:49:10 <ndm> i also notice you're using the new winhugs :)
07:49:19 <ellism> lgloo: Shouldn't the host (which is Gentoo) have access to RTLD_NEXT?
07:49:21 <xerox> ellism: I've got a "alpha" build of a GHC-6.5 snapshot of some days ago, let me find the url for you.
07:49:21 <ghum> wow
07:49:27 <ghum> 111 reductions
07:50:00 <ghum> Char> map Data.Char.toUpper "Lala"
07:50:01 <ghum> "LALA"
07:50:03 <ghum> (111 reductions, 171 cells)
07:50:04 <ghum> Char> map toUpper "Lala"
07:50:06 <ghum> "LALA"
07:50:08 <ghum> (107 reductions, 148 cells)
07:50:12 <ghum> something smells fishy :)
07:50:22 <ndm> 4 reductions is pretty much nothing
07:50:28 <Cale> that sounds reasonable
07:50:53 <ghum> aaah, okay, so these 4 reductions are what we call "dictionary lookups" in Python.
07:50:58 <Igloo> ellism: Oh, didn't read properly. I suspect in that case the header in which they are found on Darwin x86 is being included, so the Gentoo machine can't find them as it has them in a different header
07:51:00 <ghum> (in this case)
07:51:19 <ndm> ghum, no, probably not
07:51:21 <Igloo> ellism: Wolfgang Thaller is probably the best person to talk to, anyway
07:51:53 <ellism> lgloo: Okay, great thanks.  Do you know what RTLD_NEXT is a gnu extention to?
07:51:55 <ghum> ndm: looking in "data" for Char, looking in "char" for "toUpper" ... compared to "looking for toUpper in actual scope
07:52:18 <ndm> nope, its a static language, those lookups don't add to the reduction count
07:52:22 <ndm> toUpper is a primitive
07:52:33 <ndm> Data.Char.toUpper is defined as
07:52:44 <ndm> toUpper = toUpper_primitive (kind of, but not quite)
07:52:48 <Igloo> ellism: dlsym or similar
07:52:55 <ndm> those extra 4 reductions are the toUpper = toUpper
07:53:10 <xerox> ellism: http://www.uni-graz.at/imawww/haskell/ghc-6.5.20060409-i386-apple-darwin.tar.bz2
07:53:39 <ellism> xerox:  Thanks!
07:53:50 <xerox> ellism: hope it works for you
07:54:27 <Cale> I don't know the internals of hugs too well, but I'm willing to bet that reductions are essentially replacing some term using its definition.
07:55:29 <ndm> Cale, its the difference between calling the primitive toUpper (defined in Hugs.Char), and calling the indirect version
07:55:43 <Cale> ndm: yeah, that makes sense
07:59:37 <Cale> hmm, map in Hugs is defined as a list comprehension
08:00:20 <ndm> Cale, yep :)
08:00:23 <Cale> and concatMap f = concat . map f
08:00:40 <ndm> isn't that just hte obvious definition of concatMap ?
08:01:12 <ndm> list comprehensions are desugarred to folds, so I guess its not too bad to define map that way
08:01:17 <Cale> well, the reason for concatMap being its own function is that you can write it so as to be faster than that
08:01:38 <Igloo> It is?
08:01:40 <Cale> but if hugs does its own fusion transformations I suppose it wouldn't matter
08:01:44 <ndm> can you write it faster?
08:01:49 <ndm> hugs does no fusion
08:02:05 <ndm> and its only a constant factor quicker, which i guess isn't as important
08:02:12 <Cale> yeah
08:02:45 <ndm> i mean faster as in not just a small constant factor, but better by a big factor
08:02:49 <Cale> Igloo: it's 2 passes vs. 1 pass
08:03:01 <ndm> but with laziness, thats not so much of an issue
08:03:14 <Cale> right, it's not a huge deal
08:04:02 <ndm> hugs doesn't aim for speed in any way really
08:04:06 <Cale> but I can see where all those reductions are coming from now :)
08:04:07 <araujo> > let myUpper = chr . flip (-) (ord 'a' - ord 'A') . ord in myUpper 'f'
08:04:08 <lambdabot> 'F'
08:04:13 <araujo> Morning!
08:04:25 <ndm> its GC is also quite conservative
08:04:29 <Cale> > let myUpper = chr . flip (-) (ord 'a' - ord 'A') . ord in myUpper ','
08:04:30 <lambdabot> '\f'
08:04:34 <ndm> and it uses the C stack instead of a separate haskell one
08:05:22 <ndm> ghum: i have reported the Char.isUpper not working bug on the hugs mailing list
08:07:22 <araujo> > (\ s -> if isAlpha s then chr . flip (-) (ord 'a' - ord 'A') . ord $ s else s) ','
08:07:23 <lambdabot> ','
08:07:26 <araujo> > (\ s -> if isAlpha s then chr . flip (-) (ord 'a' - ord 'A') . ord $ s else s) '.'
08:07:27 <lambdabot> '.'
08:07:31 <araujo> > (\ s -> if isAlpha s then chr . flip (-) (ord 'a' - ord 'A') . ord $ s else s) 'c'
08:07:32 <lambdabot> 'C'
08:08:07 <araujo> > (\ s -> if isAlpha s then chr . flip (-) (ord 'a' - ord 'A') . ord $ s else s) 'C'
08:08:09 <lambdabot> '#'
08:08:11 <araujo> :-)
08:08:30 <ghum> thanks ndm
08:19:08 <dons> ndm, hey. I had a go a porting Data.ByteString to yhc. got quite far, till I couldn't find mallocArray stuff.
08:19:52 <dons> but just about everything else was there, it seemed. certainly some ForeingPtr stuff to get going.
08:20:26 <drakioned> isn't that a SoC project?
08:20:34 <ndm> dons, i've no idea about that - you'd probably have to ask tom
08:20:39 <ndm> or on the mailing list
08:20:52 <dons> ah, good idea.
08:20:55 <ndm> but thats good to hear
08:21:03 <ndm> i was considering ByteString for Hoogle 4
08:21:26 <dons> for sucking in all the weird data files. would be a good idea.
08:22:07 <dons> it runs very nicely on hugs and ghc. jhc needs ForeignPTr support, and yhc/nhc need malloc stuff, I think. 
08:30:00 <dons> sethk, ah, btw, the qualified names issue. reading the report you do in fact get F.x and x defined when importing F. so in the 'catch' case you can write this unambiguously:
08:30:03 <dons> import System.IO.Error
08:30:06 <dons> import Control.Exception
08:30:08 <dons> main = System.IO.Error.catch undefined undefined
08:30:18 <dons> but not GHC.Exception.catch, which isn't visible.
08:30:50 <dons> > Char.isUpper -- like this
08:30:51 <lambdabot> <Char -> Bool>
08:33:42 <xerox> mahogny: may you ask Michael Litchard to provide his contact details on the site?  People page and tickets.
08:34:17 <xerox> > subtract . (+(2::Int))
08:34:18 <lambdabot> <Int -> Int -> Int>
08:34:21 <xerox> Nice.
08:56:05 <ihope> Hmm... so is the "new v" bug fixed?
08:58:54 <ihope> > it
08:58:55 <lambdabot>  Not in scope: `it'
08:59:29 <ihope> > let v = show (map ord v) in v
08:59:30 <lambdabot> Exception: <<loop>>
08:59:49 <ihope> Hmm...
08:59:54 <ihope> > let v = show (1 : map ord v) in v
08:59:55 <lambdabot> "[1,91,49,44,57,49,44,52,57,44,52,52,44,53,55,44,52,57,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,
08:59:55 <lambdabot> 44,53,51,44,53,48,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,
08:59:55 <lambdabot> 44,53,51,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,
08:59:56 <lambdabot> 44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,52,56,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,53,51,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,
08:59:57 <lambdabot> 44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,52,56,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,52,56,44,52,52,44,53,50,
09:00:00 <lambdabot> [6 @more lines]
09:00:38 <ayrnieu> well, that list gets boring quickly.
09:02:33 <ihope> > let unSeqNonEmpty ~(x:xs) = x:xs; v = unSeqNonEmpty (show (map ord v)) in v
09:02:35 <lambdabot> "[91,57,49,44,53,55,44,52,57,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,53,51,44,52,52,44,53,50,44,53,50,44,52,
09:02:35 <lambdabot> 52,44,53,51,44,53,48,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,
09:02:35 <lambdabot> 51,44,52,57,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,
09:02:35 <lambdabot> 50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,52,56,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,53,51,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,
09:02:38 <lambdabot> 52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,52,56,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,49,44,52,52,44,53,51,44,52,56,44,52,52,44,53,
09:02:39 <ihope> There we go.
09:02:40 <lambdabot> [6 @more lines]
09:05:42 <DeliQ> ihope: what's that ~ ?
09:05:59 <ihope> Lazy patterns.
09:06:05 <ayrnieu> v = "[91" ++ loop where loop = ",57,49,44" ++ loop
09:06:28 <ayrnieu> > let v = "[91" ++ loop where loop = ",57,49,44" ++ loop
09:06:28 <lambdabot>  parse error on input `}'
09:06:45 <DeliQ> ihope: is there documentation on ~?
09:06:47 <ayrnieu> > "[91" ++ loop where loop = ",57,49,44" ++ loop
09:06:48 <lambdabot> "[91,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,
09:06:48 <lambdabot> 49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,
09:06:48 <lambdabot> 49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,
09:06:48 <lambdabot> 49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,
09:06:50 <lambdabot> 49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,49,44,57,
09:06:52 <ihope> Instead of trying to see whether or not it actually matched, it just assumes it does.
09:06:53 <lambdabot> [6 @more lines]
09:06:58 <ihope> ayrnieu: not the same :-)
09:07:04 <ihope> @google haskell lazy pattern
09:07:06 <lambdabot> http://www.haskell.org/tutorial/patterns.html
09:07:25 <DeliQ> thanks
09:07:43 <ayrnieu> oh, blast.
09:08:47 <ayrnieu> Erlang pointed out that [44,53,55,44,52,57,44,52,52] is represented as ",57,49,44" 
09:09:28 <ayrnieu> and thaht [91,57,49] is "[91" , similarly, which is amusing.
09:10:54 <ayrnieu> (but that's not yours anyway.  Carry on :-/)
09:19:36 <tsdh> Hi. I'm doing my first steps with haskell. In a tutorial I have definitions like this: `fib :: Num a, Num b => a -> b' which my GHCi doesn't like (parse error on `,').
09:20:01 <drakioned> try fib :: (Num a, Num b) => a -> b
09:20:52 <tsdh> Ah, yeah, that works. Thanks.
09:23:41 <petekaz> How do I sort a list of [('a', 10), ('b', 5), ('c', 15)] by the snd element of the pair in reverse?  So I want as a result [('c', 15), ('a', 10), ('b', 5)]
09:24:22 <ndm> petekaz: sortBy
09:24:43 <ndm> with a compare function that looks like: cmp a b = snd b `compare` snd a
09:24:45 <petekaz> what is the fun I pass to it though?
09:25:06 <ndm> petekaz: the line above
09:25:27 <petekaz> thx
09:25:43 <drakioned> weirdSort x = map (\(a,b) -> (b,a) $ reverse $ sort $ map (\(a,b) -> (b,a) x
09:25:43 <ndm> > sortBy (\a b -> snd b `compare` snd a) [('a', 10), ('b', 5), ('c', 15)]
09:25:44 <lambdabot> [('c',15),('a',10),('b',5)]
09:26:20 <drakioned> er.. I'm missing 2 closing )s
09:26:46 <drakioned> > map (\(a,b) -> (b,a)) $ reverse $ sort $ map (\(a,b) -> (b,a)) [('a', 10), ('b', 5), ('c', 15)]
09:26:47 <lambdabot> [('c',15),('a',10),('b',5)]
09:26:58 <ndm> drakioned: and it also sorts ('a',1) and ('b',1) differently
09:28:02 <drakioned> fair point.
09:34:01 <xerox> > let comparing f x y = f x `compare` f y in sortBy (flip $ comparing snd) [('a', 10), ('b', 5), ('c', 15)]
09:34:02 <lambdabot> [('c',15),('a',10),('b',5)]
09:34:18 <ihope> > sort "The quick brown fox"
09:34:19 <lambdabot> "   Tbcefhiknooqruwx"
09:34:19 <lisppaste2> petekaz pasted "My first haskell program" at http://paste.lisp.org/display/19540
09:34:46 <ihope> > let weirdSort x = map (\(a,b) -> (b,a) $ reverse $ sort $ map (\(a,b) -> (b,a) x)) in weirdSort "The quick brown fox"
09:34:47 <lambdabot> Couldn't match `a -> b' against `(a1, b1)'
09:35:06 <xerox> `comparing' should be standardized, hm.
09:35:19 <ihope> Meh.
09:35:30 <ihope> @type let weirdSort x = map (\(a,b) -> (b,a) $ reverse $ sort $ map (\(a,b) -> (b,a) x)) in weirdSort
09:35:31 <lambdabot>   Couldn't match `a -> b' against `(a1, b1)'
09:35:31 <lambdabot>   Expected type: a -> b
09:35:48 <xerox> petekaz: not bad as first Haskell program at all (-:
09:36:11 <ihope> What does it do?
09:36:29 <xerox> @type getContents
09:36:30 <lambdabot> IO String
09:36:40 <petekaz> counts the frequency of letters in the dictionary.
09:36:47 <ihope> Cool.
09:36:55 <petekaz> wanted to see what the most frequent letters are.
09:37:06 <petekaz> (from a conversation that was going on in #erlang)
09:37:15 <drakioned> does it not just return the 5 most frequently characters?
09:37:35 <petekaz> yeah, that was good enough for me.
09:37:55 <xerox> You can make it parametric using:
09:38:05 <xerox> ?type System.Environment.getArgs
09:38:06 <lambdabot> IO [String]
09:38:21 <drakioned> petekaz: yeah.. was just checking that I understood it.
09:38:31 <fons> hi
09:39:04 <xerox> Also, name important things help readability :-)
09:39:06 <xerox> *naming
09:39:30 <sjanssen> petekaz: have you run the program on a large dictionary?
09:39:43 <fons> got a question, the only exponentiation operators aviable in haskell are (^) and (^^) ?
09:39:46 <petekaz> just /usr/dict/words ... its terribly slow.
09:39:58 <fons> it is really limitet compared to expt in lisp
09:40:17 <petekaz> but I just wanted to whip something up in the least amount of time and my haskell is EXTREMELY limited.
09:40:28 <fons> operations such as 0.23242 ^^ 0.22332 aren't allowed
09:40:33 <sjanssen> petekaz: that is to be expected, really large linked lists can be bad
09:40:46 <petekaz> I suppose I should have just keep a map of the letter and a cound.
09:40:52 <sjanssen> this is a good first Haskell program though
09:40:59 <petekaz> But I was excited about the one-liner.
09:41:01 <fons> or let's say 3 ^ (1/3) which makes more sense
09:41:36 <sjanssen> fons: there is also (**)
09:41:43 <sjanssen> @type (^)
09:41:45 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:41:47 <sjanssen> @type (^^)
09:41:48 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
09:41:54 <sjanssen> @type (**)
09:41:55 <lambdabot> forall a. (Floating a) => a -> a -> a
09:42:18 <fons> ok, it has **
09:43:35 <sjanssen> they have to be separate for sane types.  For example, you can't raise an integer to a negative exponent, so that's why we have ^^
09:48:56 <fons> thanks sjanssen 
09:49:29 <fons> no exponentiation for ratio numbers though right?
09:49:58 <ihope> Hmm...
09:50:10 <ihope> @type (%)
09:50:11 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:50:23 <ihope> > 5 % 2
09:50:25 <lambdabot> 5%2
09:50:30 <ihope> > 5 % 5
09:50:32 <lambdabot> 1%1
09:52:47 <sjanssen> @pl let (xs, ys) = span (== x) zs in xs : group ys
09:52:48 <lambdabot> (line 1, column 5):
09:52:48 <lambdabot> unexpected "("
09:52:48 <lambdabot> expecting natural, identifier or "in"
09:53:10 <ihope> That's a new one.
09:53:29 <ihope> @pl let x = y in z
09:53:29 <lambdabot> z
09:53:37 <fons> maybe they can be transformed to FLoating first
09:53:40 <ihope> @pl let (x,y) = z in z
09:53:41 <lambdabot> (line 1, column 5):
09:53:41 <lambdabot> unexpected "("
09:53:41 <lambdabot> expecting natural, identifier or "in"
09:53:48 <fons> (NUmeric classes are a mess in my head)
09:53:49 <ihope> Aha.
09:54:08 <fons> how is a Ratio transformed to a floating?
09:55:13 <fons> fromRational
09:59:53 <ihope> @type fromRational
09:59:54 <lambdabot> forall a. (Fractional a) => Rational -> a
10:00:12 <ihope> @hoogle Ratio a -> Rational
10:00:13 <lambdabot> No matches, try a more general search
10:00:26 <ihope> @hoogle [Char] -> String
10:00:27 <lambdabot> No matches, try a more general search
10:00:31 <ihope> Hmm.
10:01:14 <sjanssen> ihope: type Rational = Ratio Integer
10:01:25 <ihope> Aha.
10:02:16 <fons> I'm doing a symbolic expression simplifier and I didn't know what type to use
10:02:21 <fons> for constants
10:02:30 <fons> at the end I think I'll use Rationals
10:02:59 <sjanssen> petekaz: do you have FPS/ByteString installed?
10:08:08 <palomer> http://www.projectiwear.org/~plasmahh/current.png <--we need something like this for #haskell
10:11:13 <hyrax42> waht determines the strength of edges
10:11:17 <hyrax42> sime-time chatting?
10:11:40 <SamB> okay so I get errors building the OpenAL bindings -- why am I building those anyways?
10:12:09 <SamB> I just wanted to build stage2...
10:12:34 <Igloo> You can tell configure to disable openal/openalut or similar
10:13:07 <sjanssen> palomer: that shouldn't be too hard.  for drawing and outputting the .png we have Cairo bindings
10:13:30 <sjanssen> lambdabot can already speak IRC
10:13:53 <sjanssen> we just need the algorithm that determines the strength of relations
10:14:12 <hyrax42> http://jibble.org/piespy/
10:14:20 <hyrax42> their heuristics ar listed about 2/5 down the page
10:14:30 <hyrax42> sorry
10:14:34 <hyrax42> less than 2/5
10:14:36 <hyrax42> maybe 2/7
10:17:22 <SamB> oh, and the error I get is:
10:17:37 <SamB>      error: void value not ignored as it ought to be
10:18:06 <Igloo> There are known problems building it
10:18:26 <SamB> okay...
10:20:41 * SamB wonders why configure is checking for windows.h
10:21:21 <ndm> SamB: cygwin/msys builds
10:22:14 <SamB> and if I had windows.h?
10:22:19 <sjanssen> the other tricky thing about the social network thing is the graph drawing algorithm, but that's also in the paper
10:24:17 * SamB dislikes recursive configure scripts
10:25:29 * SamB thinks GCC needs better error messages
10:26:58 <SamB> so how do I tell it not to build OpenAL bindings?
10:27:07 <ndm> --disable-openal
10:27:10 <ndm> i think
10:27:23 <palomer> where can I find all the functions in Control.Monad.Arrow ?
10:27:29 <palomer> hoogle doesn't seem to know about it
10:27:34 <xerox> ?docs Control.Monad.Arrow
10:27:34 <lambdabot> Control.Monad.Arrow not available
10:27:39 <xerox> haha
10:27:43 <xerox> ?docs Control.Arrow
10:27:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
10:27:49 <xerox> I showed you them, anyway.
10:27:56 <SamB> arg, I tried --without-openal
10:29:30 <Igloo> ISTR you need to turn something else off too, possibly openalut
10:32:39 <SimonRC> is there any theoretical reason why "do (value::Int) <- readStuffFromKeyboard" and such-like is not allowed in the standard?
10:32:52 <SimonRC> Or did no-one think of it?
10:32:58 <xerox> ?type readIO
10:32:59 <lambdabot> forall a. (Read a) => String -> IO a
10:33:19 <xerox> ?type readIO =<< getLine
10:33:21 <lambdabot> forall a. (Read a) => IO a
10:33:22 <palomer> why isn't filter a member of Functor?
10:33:39 <xerox> palomer: it is a member of Foldable/Traversable in GHC-6.5 IIRC.
10:33:51 <palomer> ooh, ghc-6.5 sounds sexy
10:33:59 <xerox> ^_^
10:34:05 <palomer> but you only need functor, don't you?
10:34:30 <xerox> Let me see where is it.
10:34:41 <sjanssen> you can't write filter with fmap
10:34:43 <xerox> Still list.
10:34:45 <palomer> haskell-unstable should be in debian
10:34:45 <xerox> :-(
10:35:21 <int-e> you can't even define filter for the Id functor.
10:36:00 <palomer> xerox: :((
10:36:09 <xerox> int-e is right.
10:36:13 <SimonRC> If multi-parameter type classes are not in Haskell-prime I will be annoyed.
10:36:45 <sjanssen> SimonRC: all indications point to MPTC being included
10:37:02 <SimonRC> phew
10:37:11 <SimonRC> no more -fglasgow-exts
10:37:26 <SimonRC> except for the 18-month delay before it gets into Debian Stable.
10:37:28 <SimonRC> bah
10:37:35 <SamB> haha
10:37:42 <woco> hi
10:38:04 <sjanssen> SimonRC: plus the time it will take to finish the standard, and the time for GHC to implement it
10:38:17 <SimonRC> ghc-6.4.1 is currently taking up most of my 1G quota
10:38:22 <sjanssen> you might be able to MPTCs in three years ;-)
10:38:35 <SimonRC> sjanssen: ghc already has MPTCs
10:39:32 <SamB> yeah, enabling MPTC by default won't be hard
10:39:46 <sjanssen> yes, but I imagine they'll implement the entire standard before making a haskell' mode, and definitely before that mode is the default
10:39:58 <SamB> you think?
10:40:10 <sjanssen> that seems sensible
10:40:12 <woco> whats wrong with "fib :: Num a, Num b => a -> b"? hugs says "Syntax error in input (unexpected comma)", but i just copied this code from "haskell for c programmers" :-?
10:40:13 * SamB doesn't see why
10:40:35 <SamB> woco: add parens around the Num a, Num b
10:40:45 <SamB> and report it as a bug
10:40:53 <SamB> in the tutorial, that is
10:40:57 <sjanssen> it isn't like it will take long for GHC to be H', the process is mostly "which GHC extensions would we like to make standard?"
10:40:57 <woco> works, thank you :)
10:41:33 <xerox> sjanssen: it is *completely* that.
10:41:53 <xerox> That is, no unimplemented features will get into Haskell'.
10:42:40 <SimonRC> descriptive standards are great!  You don't have to wait for them, and they never suggest anything really useless
10:42:56 <SamB> --disable-openal didn't stop the configure script from running either...
10:48:37 <pesco> xerox: Ah, just to give you an update, I've solidified my Yampa ideas. I've produced a prototype which _appears_ to be working, pending some further testing tomorrow. BTW, I ended up not basing (centrally) on STM, that thought was ill-conceived.
10:49:34 <pesco> xerox: So I'm in good hope that the project is possible. Should I add it to the trac?
10:50:19 <pesco> xerox: Or, maybe wait till tomorrow for the final testing.
10:57:04 <SimonRC> Argh!  I can't fit Control.Monad.Cont.ContT in my head!
11:01:38 <davidhouse> is there a parsec combinator to get the unconsumed remainder of the input?
11:01:50 <davidhouse> preferably without consuming it, but i suppose it doesn't really matter
11:02:14 <akemp> @seen SyntaxNinja
11:02:15 <lambdabot> I saw SyntaxNinja leaving #haskell 10 hours, 32 minutes and 4 seconds ago, and .
11:02:25 <SamB> davidhouse: it can be done
11:02:45 <SamB> see .Prim
11:02:50 <davidhouse> something like rest <- many anyChar would work, i suppose
11:02:54 <xerox> pesco: yes please, add it.  Good work!!
11:03:00 <pesco> :) Thanks.
11:03:03 <davidhouse> or rest <- anyChar `manyTill` eof
11:03:12 <SamB> davidhouse: you don't need to do that!
11:04:41 <davidhouse> ah, getInput
11:04:48 <fons> toRational sucks
11:04:53 * davidhouse wonders if that's the entire input or just the unconsumed input
11:04:59 <fons> > toRational 0.1
11:05:00 <lambdabot> 3602879701896397%36028797018963968
11:05:05 <SamB> just unconsumed, of course
11:05:11 <SamB> entire input would be a space leak!
11:05:30 <fons> > fromRational (1%10) :: Float
11:05:31 <lambdabot> 0.1
11:05:39 <davidhouse> > parse (char 'a' >> getInput) "" "abc"
11:05:40 <lambdabot>  Not in scope: `getInput'
11:05:58 <davidhouse> > parse (char 'a' >> Text.ParserCombinators.Parsec.Prim.getInput) "" "abc"
11:05:58 <fons> does anyone know whay does it chose such a horrible numerator and denominator?
11:05:58 <lambdabot>  Not in scope: `Text.ParserCombinators.Parsec.Prim.getInput'
11:06:08 <davidhouse> > parse (char 'a' >> Text.ParserCombinators.Parsec.getInput) "" "abc"
11:06:09 <lambdabot>  Not in scope: `Text.ParserCombinators.Parsec.getInput'
11:06:20 <davidhouse> @index getInput
11:06:20 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
11:06:49 <davidhouse> odd...
11:06:54 <SamB> fons: it is the floating point format
11:07:02 <SamB> it doesn't exactly represent decimals
11:07:23 <davidhouse> SamB, does it consume the input?
11:07:26 <fons> but something must be wrong
11:07:36 <SamB> davidhouse: don't think so
11:07:44 <SimonRC> hmm
11:07:44 <davidhouse> SamB, but why not toRational 0.1 = 1%10 ?
11:07:58 <SimonRC> I have a complicted game I am writing.
11:07:59 <davidhouse> > 1%10
11:08:00 <lambdabot> 1%10
11:08:08 <davidhouse> > show $ 1%10
11:08:09 <lambdabot> "1%10"
11:08:17 <fons> > fromRational 1%10 :: Double
11:08:18 <lambdabot> Couldn't match `Double' against `Ratio a'
11:08:20 <SamB> > toRational (0.1 :: Rational)
11:08:21 <lambdabot> 1%10
11:08:26 <fons> > (fromRational 1%10) :: Double
11:08:27 <lambdabot> Couldn't match `Double' against `Ratio a'
11:08:32 <fons> > (fromRational 1%10) :: FLoat
11:08:33 <lambdabot>  Not in scope: type constructor or class `FLoat'
11:08:37 <fons> > (fromRational 1%10) :: Float
11:08:38 <lambdabot> Couldn't match `Float' against `Ratio a'
11:08:45 <fons> damm, how did I do it before
11:08:54 <SamB> fons: parens around 1%10
11:09:00 <fons> > fromRational (1%10) :: Float
11:09:01 <lambdabot> 0.1
11:09:08 <fons> yep I'm quite stupid today
11:09:29 <SamB> stuff like that can be a pain...
11:09:42 <SimonRC> I wish to separate the game into interface and simulation parts.  Would emulating co-routines with Control.Monad.Cont be the right way to go about it?  Laziness just seems wrong here, as bad as the "Dialog" IO system.
11:16:52 <fons> does anyone have maple or mathematica?
11:17:15 <SamB> I have maple, though only for windows...
11:17:21 <fons> I think my haskell symbolic integrator doesn't work, but it has a really strage bug
11:17:26 <fons> strange bug
11:17:33 <fons> I want to know the integral of
11:17:43 <fons> (8 * x ^ 2 / (x ^ 3 + 2) ^ 3)
11:18:18 <fons> in Norvigs book the result is (-4/3 * (((X ^ 3) + 2) ^ -2)) )
11:18:35 <SamB_XP> what was it again?
11:18:44 <fons> (8 * x ^ 2 / (x ^ 3 + 2) ^ 3)
11:19:51 <SamB_XP> I get -4/3/(x^3+2)^2
11:19:59 <fons> f*ck
11:20:06 <fons> my integrator has a bug
11:20:12 <SamB_XP> well, not necessarily
11:20:15 <SamB_XP> what did you get?
11:20:26 <fons> -4/9 * (x ^ 3 + 2) ^ -2
11:20:32 <fons> okokok
11:20:44 <SamB_XP> okay, that is probably a bug ;-)
11:20:51 <SamB_XP> you are missing a factor of three?
11:21:00 <Oeje1> Paltas: ping
11:21:28 <fons> it's defenitively a strange bug
11:21:43 <SamB> how does your program work?
11:22:20 <fons> SamB, uhm, it implements the derivatives divides methods
11:22:22 <fons> method
11:22:33 <fons> exmplained in Norvigs book
11:22:43 <SamB> oh.
11:23:05 <SamB> so what do you get for the derivative of that?
11:23:36 <fons> -4/9 * (x ^ 3 + 2) ^ -2
11:23:46 <fons> it's the only example which fails
11:24:27 <garry_niger> how to websex???
11:24:28 <SamB> your program -- it takes the derivative of things, right?
11:24:50 <fons> yepi
11:25:06 <lispy> garry_niger: first you need webgenitals
11:25:18 <SamB> so, if you feed it the wrong answer, what does it give you for the derivative of that?
11:25:28 <garry_niger> lispy: ??? how to get it?
11:25:47 <lispy> garry_niger: if you have to ask you'll never know
11:25:52 <fons> uhm let's see
11:25:56 <garry_niger> lispy: come on
11:25:59 <fons> SamB, actually that's a good question
11:26:01 <garry_niger> lispy: asl?
11:26:13 <lispy> @vixen a/s/l?
11:26:14 <lambdabot> 19/f/California
11:26:45 <garry_niger> lambdabot: hallo
11:26:59 <fons> -4/9 * ((-2 * (x ^ 3 + 2)) ^ -3 * (3 * x) ^ 2)
11:27:02 <garry_niger> lambdabot: r u famale?
11:27:12 <garry_niger> lambdabot: i'am looking 4 sexxy girls
11:27:12 <fons> that's the derivative given by my program
11:28:28 <garry_niger> lambdabot: u speak hanyu???
11:28:41 <garry_niger> lambdabot: i speak w/ u?
11:28:49 <garry_niger> äE+h5`יx=Ak5´+hd^k_Uh3.#W
11:28:49 <garry_niger> zL,rrOuuO}FWUYmɔ18J$Da41pV(zh0ܘi~d
11:28:55 <garry_niger> Wxgzq,oթ]Lzv5&r
11:28:58 <garry_niger> 	p*"[:yקmj"Ӳ4Qiw\VMf.jv
11:29:01 <garry_niger> xPOj.0BR-)e;JCC%ui2bĺ{|r	dr~teg{+gV,SVDTXGB$C_*';@!7ZZoc;qLNUJ?e~Y~CQ>'Ge;parOA؎3~s0LWq(5Vׁsѧ/LH4Ū0=;bd凥u@A+
11:29:06 <garry_niger> MJux*MiA:H?>/=W7
11:29:08 <garry_niger> {QKy/O-Nb6;GbX
11:29:11 <garry_niger> JVi
11:29:13 <garry_niger> #*0 -/P(
11:29:15 <garry_niger> pL:]GKY#
11:29:18 <garry_niger>  Lr*ԉy
11:29:18 <SamB_XP> ack!
11:29:20 <garry_niger> V,2<tY/눕8X>
11:29:20 <SamB_XP> make it stop!
11:29:23 <garry_niger> a.}B5`B
11:29:26 <garry_niger> F{rW|<~x
11:29:26 <SamB_XP> someone kick him!
11:29:28 <garry_niger> ֆQt|S8.@"u /JRgtJYpŠsQcΉEUzQ2Rrkuݱ
11:29:31 <SamB_XP> quick!
11:29:32 <garry_niger> 䯸T
11:29:32 <sethk> please
11:29:35 <garry_niger> :T{BqrXx>k=O(p;88ܞ k%VʠR|܊(T1nx[wǑ'
11:29:37 <garry_niger> .b+/
11:29:42 <garry_niger> e<RA
11:29:43 <garry_niger> v=/XNyHY~$Bya{%AO`H<|ÓM/c톔D5T
11:29:47 <garry_niger> 	d~IPm[AP7$~t`r#}v*2é=޿(nȫ?̈x;{/φsfi]d
11:29:50 <Pawer> aoeu
11:29:51 <garry_niger> )XE.ՄS.'_Y8HSJQ~*vş@<6s[ zpyel361rCNcj8V#}Q
11:29:55 <garry_niger> ,)f[iD^o	'8|N~ThDBi*fH2&_}}
11:29:57 <SamB> lambdabot needs ops
11:30:00 <Pawer> what is happennig??
11:30:00 <garry_niger> aZ?kR?U!.zg)=u4PL(,
11:30:01 <lispy> yeah
11:30:03 <pierre-> ????
11:30:03 <garry_niger> m0-#,-A.C.m@gwh`2ѳbPgWε^H>S:$6smIha\6`.uBEC2 ޕ=ƈjwcTb)A\KH2RjizFP>] wpCd1K$l˖v]5n6Pɻ1u'KN!h/B6Cma".@`P|F}˅$
11:30:03 <lambdabot> Unknown command, try @list
11:30:07 <garry_niger> br6vIǵ.I\2VXR{8k̙(9SD=n:!$l	q2LpDq%w7F<2B\"0_Mqg$v{W*)έ%<˱p
11:30:11 <garry_niger> @8c4C@ߋZ?bƾq5iM\8K'xD8lΏOeټu~u
11:30:15 <garry_niger> xM"7qD]9&I釠IzٙA6~끓ib	ͦ~3 ق1.7SحyM@sw^YBx>PSogGjhus;6.?V3wT	RBV:;íY
11:30:19 <xerox> Hm.
11:30:20 <garry_niger> ]Y@&1WPl֧f͙nchr@p{F,2Z8%!U\gbj 	7#9vJ!FEvs4Ǐܭ1?iQ9ؐ:*	,B_1*_?.Zdɥwg1M]^[ʓOɝ0
11:30:23 <pierre-> plz ban him now...
11:30:23 <garry_niger> %nmPHMOdC{
11:30:24 <xerox> @get-shapr
11:30:24 <lambdabot> shapr!!
11:30:25 <garry_niger> <bUYGxWSϫTךm)yT,[a1_2nXa0׵e5}	/Hª]QP'o̐_?6KPT;ɧb̈jݦjJ69F&|0S;+"TҖpY"
11:30:28 <garry_niger> 頵Dw>"fdr7[/w"2B<kxX?.s~;F뵁PDޓPtm!u kZ<L:p!N4nȍicdQW0&
11:30:29 <garry_niger> \>cbQXhp/`6s쪬JVW%dKWH!C0GӋq[qr,'52=LYʖUϧwf!ÒN
11:30:32 <garry_niger> _R\dh5[Z7mJ&|23|BގAFCf!E}Q{U6^$RxS]!`DY=IU
11:30:35 <garry_niger> &3P$n~OU9n"0|BYM[J!*pmCEjrN)R«DS,>Rw̬14ꉄR|Nit(J걶eTH߻-PzUnX@m	1PznfDXȥΚ	 %RL~?jRCD5SӨ!iFPJT
11:30:39 <garry_niger> 7'ǷyRSc#B4EWl}:QJY?A+ȑWg
11:30:42 <garry_niger> R~XMGI!_ q.T,#|Aﱂ"q(7W..~͵>afq62u;D0$Gcxg3Tո}^ ].޻J(h|!~<?:mk=(9bJ;ð5<je.-P~4Q+{P3`|~1_H7y\s1<}[X`7Q"Yr
11:30:47 <garry_niger> +@#i٪+Ј
11:30:48 <lispy> why don't we have flood protection?
11:30:49 <garry_niger> ZX9
11:30:51 <jwp> his client accidentally cat'd /dev/urandom
11:30:51 <garry_niger> }QpZt'1E[O?̟N@B~Lw6i,Sƅ݇yZo"2sFeQ!˅՗̎[IVpֆP92ps@5঄c7{2UFpٞ<8ﵾ
11:30:58 <garry_niger> +eG3L*vYE
11:30:58 <garry_niger> 1
11:31:00 <garry_niger> 9|z,W'c'4?/ȥ1%͜YFIL̱WQ
11:31:00 <lispy> yeah, accidentally....
11:31:03 <garry_niger> {zzNڷ=0$V=g쎢
11:31:04 <jwp> hehe
11:31:05 <garry_niger> 5Uz1K(BXSrĂ^v:ikaÏrZ(廆4H*{ӲL\6(O~uik'^C|a9
11:31:09 <garry_niger> e`0xU/48>ӇKF]x+E
11:31:10 <ulfdoz> Wah, can someone kill the idiot?
11:31:13 <garry_niger> nmqe[
11:31:18 <garry_niger> {BQ7j/)Bw"fmnw;PdFaWIVJC-œrṕ	Ox:x6=8;hg@T)*Z3a9
11:31:18 <jyp> shapr
11:31:21 <garry_niger> l;Ǝ'lpHɨO~ᗓ`)ZK;B+-^6RE	.I6ՕDdcP>\uNv="mQBAT]YLF+iףKΰPKI)f!ef.nxrCq5N	%Jy]u	c6YbZ++xxU'.!8z
11:31:23 <Dark-Side> yes please that would be nice
11:31:24 <lispy> join #staff
11:31:26 <garry_niger> f
11:31:29 <lispy> gah
11:31:30 <garry_niger> ">m7w'G~ؙrQfˁʣY
11:31:34 <garry_niger> Hl?+H$ͿK
11:31:37 <garry_niger> 	IAӄ\\%FeGث.0r_/27t7-S7\i.!Р xЈd'4q0;𦵳jsc0T-:Ȉ>Cx.jQpAzO9G_JVO#|!xDZQo_@;˶rhLŚ=v`A1G9];Т*rFWm!gPv^ɉ#%z1
11:31:42 <garry_niger> ĩw;u!3v\Y19/{kX
11:31:43 <sethk> everybody do /ignore on him
11:31:45 <mahogny> gaaah. we need more ops in here
11:31:45 <garry_niger> c$RSӱeg#w%Y"~ϮE?8zZE~mUj
11:31:47 <lispy> damn, that's on the right channel
11:31:47 <garry_niger> ]2^+
11:31:50 <garry_niger> 0.AjȷzK}LR
11:31:52 <garry_niger> N#*:RZMMY?in뫴"[^VrLi8:誰ۨ~f9#8\5ܭR-P:ҫc*j*c&o>xL"	lwTVV.;Օ@d3Lc!CHj-c{nKV&]	nza22Hw]cǺ~?;0yy~2+7ogηRlݣcwܼ:_@:6ha^t'K⳹+?U+7,Zs#&d}ԛ9i2k i	O	5L\_km)J{XFeJOe#tWyQ	A\er0O<
11:31:59 <garry_niger> OijpVe@K)\A7.
11:32:02 <garry_niger> I,;W|/}:{ȜX
11:32:05 <garry_niger> %_)ZdIuA$~W~h8Tz_Vi7O>ΥF㾵}
11:32:08 <sethk> just add him to your ignore list, it's as if he's gone
11:32:08 <garry_niger> 
11:32:11 <garry_niger> (w39TZp(w{w!g{Rň^
11:32:11 --- mode: ChanServ set +o Igloo
11:32:15 <garry_niger> mW?xc
11:32:18 <garry_niger> Z"pbOJ:pJHNEI٧%~m7<fJQx<%+~M]nV8JiO%)[dn8}!(ß)^Gdn:#>XP1KA
11:32:25 <garry_niger> =o<Yf,Nɨ&a:.	oΎ"qiR1[;L,x4)a?5RW5Eؒ]&$	
11:32:26 <garry_niger> 8:v?0Dc~툑{◦sگZK_WAxrPLCܽ"YGLHEG(~
11:32:27 <garry_niger> ꍬf*Q!:R#((()c^U%B
11:32:30 <fons> Igloo, kick himmmm
11:32:31 <garry_niger> }lIO[sd~P1>z6b):q*&ogA6NzvH*pVh7ǼBzWy]F{0;T=8#ZYWVSP1
11:32:33 --- mode: Igloo set +b *!*@tor/session/external/x-885a0c9fc14ab93d
11:32:35 --- kick: garry_niger was kicked by Igloo (Igloo)
11:32:37 <lispy> sweet
11:32:40 <fons> thanks
11:32:41 <mahogny> thx
11:32:42 <Pawer> lol
11:32:42 <Korollary> hallelujah
11:32:45 <lispy> Igloo: many thanks
11:32:56 <jyp> @karma+ Igloo 
11:33:07 <Igloo> np
11:33:18 <Igloo> For future reference, saying ops' nicks generally helps them notice what's going on
11:33:20 <ulfdoz> thx, Igloo 
11:33:24 <lambdabot> Igloo's karma raised to 8.
11:33:38 * lispy doesn't really know who is an op here
11:33:49 <lispy> dons, maybe Cale and apparantly Igloo
11:33:58 <ndm> shapr as well
11:34:02 <lispy> ah right
11:34:02 <Korollary> shapr, Pseudonym
11:34:05 <SamB> yeah, well, that whole policy of having ops not opped makes it difficult to grab one in a hurry
11:34:16 <SamB> maybe lambdabot could have a command for that?
11:34:24 <sethk> in xchat they have a green dot next to their names, at least while they are in op mode
11:34:27 <Igloo> Doing /msg chanserv access #haskell list will give you them
11:34:35 <lispy> ah
11:34:36 <fons> SamB, I don't know where that stupid 9 comes from
11:34:39 <ndm> SamB, that would be good  @op msg, send a message to all the ops
11:35:11 <SamB> I was thinking more like just have lambdabot say all their names, but whatever
11:35:13 <mahogny> int-e, =int80h?
11:35:27 <Igloo> People in that list with level >= 10
11:35:55 <SamB> Igloo: I'm not going to remember how to use chanserv when someone is spewing garbage in the channel like that!
11:36:13 <sethk> I put it into my xchat as a saved command.  I won't remember it either
11:36:19 <Igloo> SamB: Send dons a patch then  :-)
11:36:59 <SamB> then I would have to build lambdabot...
11:37:21 <Igloo> Clearly false
11:37:27 <Igloo> You just need to write correct code
11:37:34 <lispy> heh
11:37:56 <lispy> just prove it correct, code it up, make sure your code matches your proof and bam, you're fine :)
11:38:15 <pierre-> Igloo: even in haskell it can be difficult without testing :-)
11:38:34 <Pawer> go to a channel and test
11:38:52 <lispy> why don't we have flood protection in this channel?
11:39:04 <lispy> something like > 6 lines, and you're gone
11:39:24 <lispy> and give lambdabot immunity :)
11:39:25 <mahogny> makes kind of sense since we have paste. no real excuse to write that much
11:39:25 <Pawer> why people attacks this channel
11:39:35 <SimonRC> What happened to him, anyway
11:39:37 <SamB> well, seeing as the only solution *I* would attempt would be a command that says the names of all the ops in a hardwired list...
11:39:44 <SamB> I don't think I'll need much of a proof.
11:39:48 <Igloo> Pawer: Because we have a large number of people
11:39:57 <SamB> but... how will I know my code is even valid?
11:40:10 <SimonRC> He comes on here, tries to chat up lambdabot, then spews garbage.  :-S
11:40:31 <Pawer> ?
11:40:37 <lispy> SimonRC: he was trouble from the start, he was looking for websex
11:40:41 <lispy> apparantly
11:40:43 <Pawer> ahh ok
11:40:53 <SimonRC> although "<lispy> @vixen a/s/l?" didn't help get rid of him.
11:41:15 <lispy> actualy that was the mistake that got him talking to lambdabot
11:41:17 <SimonRC> that must have been why he tried to chat up lispy 
11:41:20 <SimonRC> oops
11:41:22 <SimonRC> that must have been why he tried to chat up lambdabot 
11:42:17 <mahogny> drakioned, you don't happen to know int80h's email?
11:42:24 <SimonRC> anyway, the thing I wanted to ask:  What is the purpose of the first parameter to Control.Monad.Cont.Cont ?
11:42:29 <fons> is there a mode for ghci to debug code?
11:42:32 <woco> how can you have websex on irc, anyway? completely different protocol...
11:42:39 <drakioned> er.. I might have it somewhere
11:42:58 <lispy> fons: not really.  There is hat (for tracing) and there is buddha but neither are a traditional debugger
11:43:06 <Igloo> woco: Tunneling, of course
11:43:08 <SamB> woco: you start by being an ignoramus who doesn't know the web from the net?
11:43:08 <mahogny> xerox, confirming student interested in the haskell UML project
11:43:17 <drakioned> michael@schmong.org
11:43:18 <lispy> fons: buddha is probably as close to what you want so you'll get
11:43:21 <mahogny> drakioned, thanks
11:43:25 <Igloo> Someone should write an IP-over-netsex tunnel
11:43:33 <woco> both very good points. i'll contemplate them sufficiently
11:43:57 <lispy> yeah, i tried telling him he would need webgenitals
11:43:57 <fons> a trace would be enough, how does that work?
11:44:06 <drakioned> bbl, yell my name if you need me
11:44:23 <lispy> fons: http://www.haskell.org/hat/
11:44:26 <mahogny> xerox, ...and there I added int80's mailaddy to the page
11:44:51 <lispy> fons: and also http://www.cs.mu.oz.au/~bjpop/buddha/
11:45:09 <lispy> mahogny: hopefully obscured...
11:45:46 <fons> ok
11:46:03 <mahogny> lispy, of some reason, none of the addys on the SoC page are obscured. I have wondered why for a while :/
11:46:30 <lispy> i'm glad mine is not on the list :)
11:47:02 * lispy hopes to finish moving today
11:47:31 <davidhouse> @index putState
11:47:32 <lambdabot> bzzt
11:47:42 <davidhouse> @index modifyState
11:47:43 <lambdabot> bzzt
11:50:01 <fons> hat-ghc6 is broken in debian
11:50:03 <fons> shit
11:58:14 <ndm> fons, give us a few weeks, and there will be an even better hat-yhc :)
11:58:29 <ndm> but no, hat is pretty broken on ghc sadly
11:58:35 <fons> yhc?
11:58:50 <ndm> @where Yhc
11:58:50 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
11:58:51 <SamB> mahogny: well, I'm not worried about my email because I have gmail
11:58:55 <ndm> the York Haskell compiler
11:59:52 <davidhouse> @localtime dons
11:59:54 <lambdabot> Local time for dons is Mon May  1 05:01:02 2006
12:00:06 <davidhouse> dons, don't suppose you're awake?
12:00:19 * davidhouse can't darcs get fps
12:02:38 <SamB> do you need the latest?
12:04:31 <davidhouse> i don't think so
12:04:39 <davidhouse> just want to compile lambdabot.
12:05:48 <SamB> okay
12:06:06 <SamB> somebody have a copy that has a bettter connection than 56k?
12:07:58 <davidhouse> i might be able to checkout an earlier snapshot
12:08:04 <davidhouse> it appears one of the patchings it 404ing
12:08:07 <davidhouse> *patches
12:14:19 <davidhouse> (how would i do that?)
12:15:48 <petekaz> @seen sjanssen 
12:15:48 <lambdabot> sjanssen is in #haskell. I last heard sjanssen speak 1 hour, 21 minutes and 12 seconds ago.
12:16:05 <sjanssen> hey, whats up?
12:16:36 <petekaz> sjanssen: I ran to the supermarket ... what was that about the fast byte or packed something or other?
12:16:59 <sjanssen> it's a library that treats strings as arrays rather than lists
12:17:31 <petekaz> so I can still have a one-liner just swapping out for the packed string?
12:17:42 <sjanssen> just for kicks I changed your example to use ByteStrings and it runs in 2 seconds on my computer
12:17:49 <petekaz> cool.
12:18:07 <sjanssen> it's almost a one liner -- ByteString doesn't have group, so I had to write it myself
12:18:23 <petekaz> can you annotate my paste? http://paste.lisp.org/display/19540
12:19:33 <lisppaste2> sjanssen annotated #19540 with "ByteString is fast" at http://paste.lisp.org/display/19540#1
12:19:53 <petekaz> sjanssen: thanks!
12:24:32 <Pawer> hi sjanssen
12:24:42 <sjanssen> hello, Pawer
12:24:44 <Pawer> thanks for the help last day
12:24:54 <sjanssen> anytime
12:25:04 <Pawer> i passed the haskell test
12:25:06 <Pawer> !
12:25:12 <Pawer> thx you all
12:25:25 <lispy> congrats
12:25:38 <davidhouse> well done, Pawer :)
12:25:41 <Pawer> but i dont know haskell
12:25:42 <Pawer> lol
12:25:44 <davidhouse> what did it cover?
12:25:55 <Pawer> lists
12:26:00 <Pawer> mm
12:26:10 <Pawer> supepior order
12:26:15 <Pawer> IO
12:26:23 <Pawer> types
12:26:47 <Pawer> wel
12:27:03 <Pawer> and language paradigms concepts
12:27:07 <Pawer> in general
12:27:28 <Pawer> they use bird so
12:27:56 <Pawer> the first half of bird
12:28:01 <Pawer> redex
12:28:13 <davidhouse> mm?
12:28:15 <Pawer> strict functions
12:28:16 <lispy> sounds pretty comprehensive for an intro to haskell
12:28:26 <Pawer> is an intro
12:28:39 <Pawer> next year a will pick another
12:28:46 <Pawer> of haskell
12:28:51 <Pawer> only haskell
12:28:56 <davidhouse> Pawer: what are mm and wel?
12:29:02 <Pawer> mmmm
12:29:10 <Pawer> well is well
12:29:12 <Pawer> mmmmmmmmmmmmm
12:29:15 <davidhouse> ah.
12:29:23 <Pawer> is when you think and do mmm
12:29:24 <Pawer> XDD
12:29:27 <Pawer> hahahaa
12:29:31 <davidhouse> so neither of them are actual language concepts;)
12:29:40 <Pawer> actual not
12:30:25 <Pawer> nowadays
12:30:29 <Pawer> machines are
12:30:35 <Pawer> imperative
12:31:28 <Pawer> was there an effoht to make a functional processor
12:31:31 <Pawer> ?
12:31:38 <davidhouse> argh. having real trouble getting lambdabot to make.
12:31:40 <jyp> yes
12:31:42 <Pawer> an arquitechture
12:31:45 <jyp> there
12:31:47 <jyp> was
12:31:50 <lisppaste2> davidhouse pasted "lambdabot won't make" at http://paste.lisp.org/display/19543
12:31:58 <Pawer> aptimized for functionaal programming
12:32:07 <stepcut> Someday I would like to make a handheld 'lisp' machine...
12:32:18 <Pawer> jaja
12:32:21 <Pawer> maybe
12:32:32 <Pawer> a functional card
12:32:34 <Pawer> like
12:32:38 <sjanssen> davidhouse: did you change anything?
12:32:40 <Pawer> graphics card
12:32:41 <davidhouse> sjanssen: nope
12:32:42 <Pawer> jaja
12:33:06 <Pawer> or have an ALU
12:33:16 <Pawer> and the functional
12:33:22 <Pawer> module in CUs
12:33:24 <Pawer> CPUs
12:33:30 <Pawer> XD
12:33:47 <davidhouse> Pawer: use the enter key a little less often, if you please
12:34:00 <Pawer> ok
12:34:04 <davidhouse> thanks :)
12:34:07 <Pawer> lol
12:34:19 <lispy> jyp: what was that processor like?
12:34:38 <Pawer> > yes
12:34:39 <lispy> jyp: what was functional about it?
12:34:39 <lambdabot>  Not in scope: `yes'
12:34:46 <Pawer> tell
12:35:02 <Pawer> was started in japan?
12:35:10 <stepcut> http://en.wikipedia.org/wiki/Graph_reduction_machine
12:35:19 <Pawer> woooo
12:35:24 <stepcut> i know there are a number of 'graph reduction machine' out there 
12:35:47 <vincenz> re
12:35:48 <lispy> stepcut: oh cool
12:35:53 <stepcut> http://www.cse.ogi.edu/PacSoft/projects/Hawk/overview/
12:35:57 <lispy> so are they really efficient with haskell code?
12:36:20 <Pawer> functional code
12:37:08 <Pawer> wow nice
12:37:45 <stepcut> lispy: I think you would have to have a haskell -> graph machine compiler first -- I think there *may* have been a graph reduction machine that ran concurrent clean -- but maybe it was just talked about and never built
12:38:34 <lispy> stepcut: i thought thinks like the GHC rts was a graph reduction algorithm
12:38:52 <lispy> and hence it would be easy to 'port'
12:39:51 <stepcut> I would not be suprised
12:40:00 <Pawer> that is cutting the edge investigation
12:40:12 <stepcut> http://citeseer.ist.psu.edu/cache/papers/cs/760/http:zSzzSzcswww.essex.ac.ukzSzPACEzSzicpp.pdf/pace-a-prototype-design.pdf
12:41:17 <stepcut> A hand-held parallel graph reduction machine would be pretty sweet IMO :)
12:42:33 <Pawer> bye folks
12:44:06 <davidhouse> @hoogle putState
12:44:07 <lambdabot> No matches found
12:44:19 <lispy> @hoogle put
12:44:20 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
12:44:20 <lambdabot> Prelude.putChar :: Char -> IO ()
12:44:20 <lambdabot> Prelude.putStr :: String -> IO ()
12:44:39 <lispy> perhaps Control.Monad.State.put is what you want?
12:45:19 <vincenz_> ping
12:45:19 <vincenz_> anyone?
12:45:19 <vincenz_> or am I seriously lagged?
12:45:19 <vincenz_> ping?
12:45:27 <lispy> ping?
12:45:29 <davidhouse> lispy: nah, i want Parsec's state interface
12:45:35 <lispy> you said all that in less than a second :)
12:45:41 <lispy> davidhouse: ah
12:45:41 <davidhouse> vincenz_, those came through all at once
12:45:54 <vincenz_> sos
12:45:56 <vincenz_> wow
12:45:57 <davidhouse> lispy: and it turns out they're named getState, setState and updateState, oddly.
12:45:59 <vincenz_> 100 secs
12:46:04 <vincenz_> anyways
12:46:19 <vincenz_> Bittorrent status: 4285.2 of 4280.6 MN 
12:46:24 <vincenz_> ??
12:46:25 <lambdabot> Not enough arguments to @.
12:46:37 <lispy> ?@
12:46:38 <lambdabot> Not enough arguments to @.
12:46:44 <lispy> ?? foo
12:46:45 <lambdabot> Not enough arguments to @.
12:46:54 <lispy> weird
12:47:08 <sjanssen> lispy: it's spelling correction at work
12:47:18 <sjanssen> ?? elite keal
12:47:19 <lambdabot> ONe pRO||E/\/\. + brOxE c0NphInEs 0f TH3 vI5Ua1 8asIC L4N9a9E AnD \/\/0u1d nOT coMPile
12:48:30 <vincenz_> any knwanyways
12:48:33 <vincenz_> grr
12:48:34 <vincenz_> anyways
12:48:36 <vincenz_> Bittorrent status: 4285.2 of 4280.6 MN 
12:48:39 <vincenz_> anyone have any clues?
12:49:05 <sjanssen> maybe it means you received some bad chunks?
12:49:28 <vincenz_> hmm
12:49:34 <sjanssen> I'd say quit your client and do a resume
12:49:39 <vincenz_> how do you resume?
12:49:45 <vincenz_> I don't remember the torrent
12:49:52 <vincenz_> and for some stupid reason
12:49:56 <vincenz_> it doesn't keep the torrent
12:50:06 <ihope> > 1/7
12:50:06 <vincenz_> even though it says file:///tmp/...
12:50:07 <lambdabot> 0.14285714285714285
12:50:22 <lispy> > 31/7
12:50:24 <lambdabot> 4.428571428571429
12:50:28 <sjanssen> vincenz_: you're using the standard client?
12:50:33 <vincenz_> sjanssen: linux 
12:50:35 <vincenz_> sjanssen: yeah
12:50:41 <ihope> > take 8 $ iterate (+142857) 0
12:50:42 <vincenz_> sjanssen: gnome bittorrent
12:50:42 <lambdabot> [0,142857,285714,428571,571428,714285,857142,999999]
12:50:53 <lispy> > 22/7
12:50:55 <lambdabot> 3.142857142857143
12:50:57 <ihope> :-)
12:50:58 <ihope> > pi
12:51:00 <lambdabot> 3.141592653589793
12:51:04 <vincenz_> > pie
12:51:05 <lambdabot>  Not in scope: `pie'
12:51:10 <ihope> > pi e
12:51:10 <lambdabot>  Not in scope: `e'
12:51:13 <sjanssen> you'll need the original torrent to resume.  you just open the .torrent again and choose to save in the same location
12:51:13 <lispy> > pi - 22/7
12:51:15 <lambdabot> -1.2644892673496777e-3
12:51:22 <ihope> > pi - 3.14
12:51:23 <lambdabot> 1.5926535897929917e-3
12:51:32 <lispy> > pi - 56068/17847
12:51:33 <lambdabot> 2.2909267860526938e-7
12:51:46 <ihope> > take 256 (cycle "pipie")
12:51:47 <lambdabot> "pipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipi
12:51:47 <lambdabot> epipiepipiepipiepipiepipiepipiepipiepipiepipiepipiepipiep"
12:51:47 <vincenz_> sjanssen: heh the problem is that I do "open with gnome bittorrent" and it doesn't save the torrent file, even though it says file:///tmp/torrentname.torrent in bittorrent
12:51:55 <lispy> > pi - 1068966896/340262731
12:51:57 <lambdabot> 0.0
12:52:35 <ihope> Wow!
12:52:37 <sjanssen> > decodeFloat pi
12:52:39 <lambdabot> (7074237752028440,-51)
12:52:49 <ihope> ...Huh?
12:52:53 <lispy> @type decodeFloat
12:52:55 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
12:52:55 <ihope> @type decodeFloat
12:52:55 <vincenz_> sjanssen: does it do a check of some md5 when you do a resume to ensure the torrent is the same?
12:52:57 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
12:53:02 <ihope> @type encodeFloat
12:53:03 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
12:53:16 <ihope> > encodeFloat 3 14
12:53:17 <sjanssen> > 7074237752028440 / 2 ^ 51
12:53:17 <lambdabot> 49152.0
12:53:19 <lambdabot> 3.141592653589793
12:53:38 <ihope> > pi
12:53:39 <lambdabot> 3.141592653589793
12:53:47 <sjanssen> vincenz_: yeah, it uses a hash
12:53:51 <vincenz_> kewl
12:53:51 <ihope> You found the exact value of pi! :-P
12:54:21 * lispy always wanted a base-pi number system
12:54:31 <lispy> then you could write down the exact value of pi, 1
12:55:17 <Igloo> YM 10
12:56:04 <vincenz_> sjanssen: even per block?
12:56:15 <sjanssen> vincenz_: yes
12:57:00 <vincenz_> kewl
12:57:05 <vincenz_> so it'll rectify any possible mistakes
12:57:13 <sjanssen> the hashes of each block are in the .torrent, resume just iterates through each block and compares the hashes
12:57:33 <vincenz_> :)
12:57:40 <vincenz_> great \o/
12:58:32 <lispy> bittorrent is your friend
12:58:42 <vincenz_> heh
12:58:50 <vincenz_> sjanssen: for some reason I can't open it from the console
12:58:58 <drakioned> someone trying to write a Haskell torrent client or something?
12:59:24 <sjanssen> drakioned: there was some work on one, I think it fizzled out recently
12:59:24 <mahogny> something wrong with the existing clients? :)
12:59:39 <vincenz_> sjanssen: I can only open it from the web directly, not from console
12:59:44 <xerox> drakioned: sure!  See Conjure.
12:59:57 <xerox> @where Conjure
12:59:58 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
13:00:01 <xerox> Yeah.
13:00:16 <drakioned> madness.
13:00:58 <drakioned> I suppose I can't talk.. since I want to write a mud..
13:01:03 <vincenz_> sjanssen: how do you etll it to resume
13:01:06 <vincenz_> sjanssen: cause it's a folder
13:01:36 <mahogny> mistake #1 in trying to get haskell out in the public: rewriting an application in the language when there is little hope in writing a better one than the existing
13:01:42 <sjanssen> vincenz_: I always get confused with the folder ones . . . I think if you select the folder it will do the right thing
13:01:54 <vincenz_> sjanssen: no it then opens it and leaves me with an empty name
13:01:56 <vincenz_> so I can't safe
13:01:57 <vincenz_> save
13:02:08 <drakioned> mahogny: that with respect to a mud or a torrent client?
13:02:32 <mahogny> drakioned, torrent. there are really good ones out there. especially azureus
13:02:34 <sjanssen> vincenz_: then select the parent directory?
13:02:34 <lispy> mahogny: why is that a mitake?
13:02:47 <xerox> mahogny: no way.
13:02:58 <mahogny> lispy, it doesn't add value. if you want to bring it out, make sure it actually competes
13:02:58 <lispy> mahogny: i think it helps give feedback and helps haskell mature
13:03:00 <xerox> mahogny: Conjure do have some neat code, Azureus is a memory hog.
13:03:11 <vincenz_> sjanssen: it opens it
13:03:22 <mahogny> lispy, true that. but that mainly helps the haskell itself. it doesn't get us more users. not many at least
13:03:41 <drakioned> mahogny: I got in touch with someone that runs a mud.
13:03:49 <mahogny> xerox, have to agree about the memory. but you can reduce the memory it uses
13:03:50 <sjanssen> vincenz_: can't really remember.  I bet there's a FAQ on the bittorrent website
13:03:57 <mahogny> drakioned, that's a good thing
13:04:08 <drakioned> mahogny: they told me it took them a couple of years to write their code base.. I told them I got 3 months ;)
13:04:12 <mahogny> drakioned, in case you need a server to test it on, you can get an account on mine
13:04:13 <mahogny> lol
13:04:36 <mahogny> drakioned, if you want to have a look at a joke, look at mirc
13:04:51 <drakioned> I should ask them whether they wanted to port their MUD over when I'm done ;)
13:05:08 <mahogny> in that case I think you have to be careful about the design
13:05:31 <lispy> mahogny: have you read "Wearing the hair shirt"?
13:05:43 <lispy> iirc, they said, "avoid success at all costs"
13:05:44 <mahogny> lispy, hm. no bell ringing
13:05:49 <mahogny> lispy, lol
13:05:52 <drakioned> well, these guys have the most well thought out mud I've seen, and I was going to borrow a lot of ideas.
13:05:54 <mahogny> lispy, sounds like academia ;)
13:06:00 <lispy> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
13:06:22 <lispy> it's quite a worthwhile read
13:06:26 <mahogny> drakioned, good start. that makes writing the spec much easier
13:07:11 <drakioned> I think the type system will really help on this one.
13:07:47 <drakioned> well, rather, the ease of defining data structures
13:07:59 <vincenz_> sjanssen: got another proggie, much better
13:08:12 <mahogny> drakioned, that, parsec and partial application
13:08:27 <vincenz_> sjanssen: bittornado
13:08:34 <sjanssen> vincenz_: you might want to try Azureus, it's as good as they come
13:08:40 <drakioned> why parsec..?
13:08:40 <vincenz_> sjanssen: windows, no?
13:08:52 <skew> what do all these things offer over the reference implementation?
13:09:02 <sjanssen> vincenz_: it's in Java.  I use it on Linux all the time
13:09:07 <vincenz_> ah alright
13:09:14 <vincenz_> well this seems to go pretty well
13:09:16 <lispy> drakioned: you'll be doing a fair bit of parsing..you'll load a lot of data and you'll process the things people type
13:09:27 <vincenz_> another nasty thing of bittorrent gnome (written in python) is that the upload limit does not actually work
13:09:35 <vincenz_> and I have a fixed up and down bw/ month
13:09:43 <vincenz_> in fact I went over it and my connection is now freakishly slow
13:09:48 <vincenz_> that's why I was so laggy earlier
13:09:49 <mahogny> the original bittorrent client is a pile of crap
13:09:54 <vincenz_> (I briefly upped my account)
13:09:57 <drakioned> haven't ever used Parsec before.. have used Happy though.
13:10:10 <vincenz_> happy is neat
13:10:18 <lispy> drakioned: parsec is nice, but i haven't tried happy
13:10:30 <vincenz_> I used alex and happy with monadic integration
13:10:36 <vincenz_> they have options for that
13:10:47 <lispy> drakioned: the nice thing about parsec is that it's a parser combinator library...so you compose the parsing functions into your grammar
13:10:54 <vincenz_> (which allows you to do c-like things such as keeping up a symbol table)
13:11:23 <vincenz_> lispy: isn't parsec ll?
13:11:42 <lispy> that sounds right, but it has infinite looka head
13:11:45 <vincenz_> by definition
13:11:50 <jyp> ll1 + backtracking...
13:11:52 <vincenz_> lispy: only if you do some really ugly coding
13:12:02 <vincenz_> jyp: that's more powerful than lr1?
13:12:17 <vincenz_> ideally we'd have glr
13:12:18 <vincenz_> :)
13:12:20 <vincenz_> glr is great
13:12:39 <mahogny> drakioned, parsec and happy are quite different. parsec is better if you have a really bad syntax you need to read
13:12:44 <jyp> Backtracking allows to parse any CF language I believe
13:12:57 <jyp> I think happy does glr
13:13:03 <drakioned> I'll cross that bridge when I get to it.
13:13:04 <vincenz_> jyp: yeah but it's a mess
13:13:09 <vincenz_> jyp: and it's not wellsupported afaict
13:13:14 <vincenz_> I didn't look too far into it
13:13:16 <vincenz_> but anyways
13:13:20 <vincenz_> glr can do c++
13:13:22 <vincenz_> afaik
13:13:31 <vincenz_> elsa/elkhound uses glr for c++
13:13:34 <vincenz_> @ berkely
13:14:01 <lispy> is there something that would prevent parsec from doing C++?
13:14:23 <jyp> Have you read the formal spec of the C++ grammar? :)
13:14:26 <drakioned> I suspect that I'll not be able to write anything other than just a toy mud within the timeframe at any rate..
13:14:39 <lispy> drakioned: yup
13:15:05 <drakioned> mostly because to make anything bigger, it becomes as much a creative writing task as a coding one..
13:15:10 <lispy> drakioned: how will you handle multiple connections?
13:15:40 <lispy> jyp: i haven't read it per se, but i have a book by strostrupe that lists the grammar
13:15:57 <vincenz_> lispy: c++ is by definition ambiguous
13:15:58 <drakioned> well, I was going to see whether it was practical to use something similar to what was used in the Haskell web server
13:16:07 <vincenz_> lispy: glr allows ambiguity
13:16:17 <vincenz_> lispy: only after typechecking can you actually remove ambiguity
13:16:22 <vincenz_> typechecking and namespace look up
13:16:34 <vincenz_> minimal albeit, not full lookup nor full typecheck
13:16:40 <vincenz_> but still parse tree is inherently ambiguous
13:16:46 <jyp> lispy: Well, it's such a mess that I would advise against anyone to write a C++ parser.
13:17:09 * vincenz_ has done some research into it when he was looking for a frontend
13:17:09 <Lemmih> Hiya vincenz_.
13:17:14 <vincenz_> Lemmih: hi!
13:17:38 <lispy> but parsec can't handle the ambiguity huh?
13:17:49 <vincenz> lispy: it'd prolly be ugly
13:17:53 <vincenz> if it's possible
13:17:57 <drakioned> lispy: do you mean handling the network connections or handling concurrent access to the state of the mud?
13:18:04 <lispy> so you wouldn't even be able to correctly construct the parse tree for the next part stages where you remove the ambiguity?
13:18:08 <fons> SamB, got the error of the integrator
13:18:10 <vincenz> lispy: making a mud?
13:18:10 <fons> it now works
13:18:12 <lispy> drakioned: both
13:18:57 <vincenz> drakioned: should talk to jyp, he made quite a foundation of a mud in haskell
13:18:58 <lispy> vincenz: not me, i've thought about it, but never had the time when i had the energy or the energy when i had the time :)
13:19:08 <vincenz> lispy: I doubt haskell is the ideal language
13:19:13 <drakioned> the network connections.? I have no idea.. for the mud state, probably going to package everything together and store it in a MVar / TVar..
13:19:13 <vincenz> lispy: you want a flexible language
13:19:30 <vincenz> lispy: plus haskell has no inherent support for marshalling afaik
13:19:47 <lispy> why do you care about marshalling?
13:19:48 <vincenz> in addition as soon as you change types your marshalled data is borked, other languages have better support for this
13:19:55 <vincenz> lispy: erm.... dumping your database ?
13:20:01 <vincenz> your active objects,
13:20:07 <vincenz> players.... items...rooms...
13:20:13 <lispy> why not use a database or text files
13:20:24 <vincenz> lispy: cause then you have to do another level of coding
13:20:24 <lispy> why do you dump as binary? that seems foolish
13:20:34 <vincenz> well if you use a dyn language
13:20:45 <vincenz> you could prolly dump in code
13:20:49 <jyp> vincenz: In the mud I wrote, I put a dynamic layer on top of the haskell type system for such stuff.
13:21:01 <vincenz> jyp: yeah, dyn typing is ideal for muds
13:21:04 <vincenz> but imho
13:21:05 <vincenz> the best system
13:21:06 <vincenz> is cold
13:21:12 <vincenz> http://ice.cold.org
13:21:17 <vincenz> it's a live db
13:21:19 <vincenz> online codeable
13:21:24 <vincenz> very stable
13:22:23 <lispy> i can see why you'd want to use hs-plugins for a mud so you can patch components on the fly, but i don't really see why a dynamic language makes data manipulation easier.
13:22:52 <vincenz> lispy: cause dyn languages typically have much stronger marshalling support that allows loading data of old versions of a type
13:23:36 * drakioned is puzzled.
13:23:51 <vincenz> lispy: it's one thing less to do
13:24:02 <vincenz> lispy: or anytime you change your internal objects, you have to change the saver/reader
13:24:37 <lispy> just use a database :)
13:24:42 <vincenz> lispy: again
13:24:48 <vincenz> lispy: still coding
13:25:05 <vincenz> plus every time you change your objects
13:25:07 <skew> you have to explain how to translate an old object into a new object anyway
13:25:11 <vincenz> you now also ahve to change your database layout
13:25:28 <vincenz> skew: not really with dyn languages it typically uses field names and you can give other members or fields default values
13:25:36 <vincenz> skew: trust me, a lot less hassle
13:25:49 <vincenz> anyways
13:25:51 * vincenz off to get cigs
13:25:57 <vincenz> Lemmih: wanted to say something or just hi?
13:25:58 <drakioned> so I'm suppose to do what now?
13:26:04 <skew> it's not like it's a lot of marshalling code if you use something like SerTH, either
13:26:35 <vincenz> skn
13:26:40 <vincenz> skew: not familiar with th
13:26:55 <vincenz> skew: however I'd wnoder about version switching
13:27:02 <lispy> drakioned: i tried using forkIO and passing a handle to some state whenever i got a connection but it didn't work out for me
13:27:25 <lispy> drakioned: in C the most efficient solution tends to use select or poll
13:27:44 <lispy> i thought using haskell threads would be a nice way to go since they are soooo lightweight
13:27:52 <fons> I'm stuck with the toRational problem
13:27:54 <vincenz> lispy: except then you'd have to mutex your world
13:27:56 <skew> vincenz: I haven't worked with multtiple versions, but it seems like keepping around all the old versions of the serization module should pretty much do it
13:27:59 <fons> I understand why it's caused
13:28:07 <fons> but I don't find a good aorkaround
13:28:21 <vincenz> skew: I'd be interested to take a look at this SerTH thingy
13:28:30 <lispy> vincenz: but i had only one handle to the global state so i was going going to need to mutex it at one place
13:28:34 <skew> and if your dynamic language serialization thing works with you specifying default values and stuff, it seems like you'd need to update all the old versions if the default changed
13:28:38 <fons> toRational 0.9 is not 9%10 but a really weird fraction
13:28:58 <vincenz> lispy: not if you use select cause then it's single threaded
13:28:59 <skew> or write functions turning the old version into the new and chain them together
13:29:18 <lispy> vincenz: i know
13:29:38 <drakioned> lispy: I was sorta planning on that anyway.
13:29:42 <lispy> vincenz: but does haskell even have a select/poll interface?
13:29:51 * lispy never bothered to check
13:29:56 <lispy> drakioned: planned on what?
13:30:00 <drakioned> mutexing it.
13:30:03 <skew> vincenz: http://www.cs.helsinki.fi/u/ekarttun/SerTH/
13:30:27 <vincenz> thankees
13:30:33 <int-e> fons: does that surprise you? 0.9 is not representable as a Float (or Double)
13:30:35 <skew> vincenz: the serialization code in the examples comes from $(deriveSerializable ''Type) 
13:30:43 <drakioned> I wouldn't have thought the load would ever be enough that it would present a problem..
13:30:52 <vincenz> skew: what does one need to make th code compile?
13:31:29 <skew> vincenz: -fth flag with ghc
13:31:31 <vincenz> th = part of ghc?
13:31:38 <skew> Template Haskell
13:31:42 <vincenz> yeah I know
13:31:46 <vincenz> part of ghc?
13:31:48 <fons> int-e, ok, I understand but maybe ther is a way to find the best rational approximation cause fromRational prints 0.1 which is exactly 10%9
13:31:49 <skew> yeah
13:31:51 <vincenz> kewl
13:31:53 <vincenz> anyways
13:31:58 * vincenz off
13:32:02 <vincenz> bbl
13:32:03 <fons> 0.9 sorry
13:32:11 <skew> fons: maybe Data.Ratio.approxRational?
13:32:29 <fons> let me check
13:33:23 <int-e> > approxRational 0.9 0.00000000
13:33:25 <lambdabot> 8106479329266893%9007199254740992
13:33:26 <int-e> > approxRational 0.9 0.000000001
13:33:27 <lambdabot> 9%10
13:33:35 <int-e> neat
13:33:50 <lispy> int-e: i think peeps were looking for you because of the SoC
13:33:56 <lispy> but i can't remember who
13:34:14 <fons> > let ratio = toRational 0.9 in approxRational (numerator x) (denominator x)
13:34:15 <lambdabot>  Not in scope: `x'
13:34:33 <int-e> lispy: no, they're looking for int80h - if I understood correctly.
13:35:04 <lispy> int-e: ah, okay
13:35:04 <fons> OK got how the function works, cool
13:35:57 <lispy> @pl \x -> approxRational (numerator x) (denominator x)
13:35:57 <lambdabot> liftM2 approxRational numerator denominator
13:36:36 <fons> you don't have to use the denominator you have to add an epsilon
13:40:14 <hyrax42> @type numerator
13:40:15 <lambdabot> forall a. (Integral a) => Ratio a -> a
13:40:16 <lispy> @type liftM2 approxRational numerator denominator
13:40:17 <lambdabot> forall a.
13:40:17 <lambdabot>                 (RealFrac a, Integral a) =>
13:40:17 <lambdabot>                 Ratio a -> Rational
13:40:33 <lispy> why does litfM2 work there
13:40:44 <xerox> Because of the Reader Monad.
13:41:08 <ADEpt> xerox: oh! gotcha :)
13:41:23 <xerox> ^__^
13:41:38 <fons> cool!! my haskell integrator finally works!!!
13:41:49 * fons is really happy
13:42:01 <xerox> fons: show it up!
13:42:04 <hyrax42> cool
13:42:06 * fons begins to love haskell
13:42:07 <hyrax42> yeah
13:42:38 <fons> I just have some warnings to correct
13:42:45 <fons> and I don't really now how to
13:43:16 <xerox> Let's see if we can help you.
13:43:16 <fons> ghci complains about some Pattern match(es) are overlapped
13:43:28 <fons> but they are not really overlapped, they are different
13:43:36 <xerox> How much different?
13:43:39 <fons> It might be a bug I think
13:43:41 <xerox> (The order matters.)
13:44:11 <skew> there is no value that matches both patterns?
13:44:29 <ndm> xerox, the GHC manual notes that pattern match checking is wrong
13:44:49 <xerox> ndm: oh, what exactly?
13:44:50 <fons> xerox, really different
13:45:03 <xerox> Seems like we're going to need more details fons.
13:45:48 <fons> simpByRules (D ((CSym "e") :^: u) x)
13:45:52 <fons> this is one
13:46:12 <fons> (ghci cites it explicitly)
13:46:12 <ndm> There is a compile time flag which can be
13:46:14 <ndm> added and catches both, named -fwarn-incomplete-patterns. However,
13:46:15 <ndm> the Bugs (12.2.1) section of the manual notes that the checks are sometimes wrong,
13:46:17 <ndm> particularly with string patterns or guards, and that this part of the compiler “needs
13:46:18 <ndm> an overhaul really”
13:46:27 <fons> ndm, this are not incomplete patterns
13:46:40 <fons> ndm, actually it says they are overlapped
13:46:43 <ndm> it refers to both bits in the manual
13:46:50 <ndm> they are both the same analysis pass
13:47:18 <xerox> The derivative of e^f(x) wrt x? :-)
13:49:04 <fons> simpByRules (D (u :^: v) x)
13:49:15 <fons> simpByRules (D ((CSym "e") :^: u) x)
13:49:26 <xerox> Eh!
13:49:29 <xerox> I told you order matters.
13:49:31 <fons> uhm actually it is right
13:49:34 <kosmikus> looks overlapping to me
13:49:37 <ADEpt> they really are overlapping
13:49:40 <fons> it is overlapping
13:49:43 <fons> shit
13:49:43 <xerox> They're checked in order.
13:49:49 <fons> I know I know
13:50:20 <fons> Actually I took it from Norvigs book
13:50:26 <fons> and it might be wrong there as well
13:50:35 * ADEpt . o O (we need a "bash.org for haskell folk" for things like this :)))
13:50:39 <fons> because there order matters (he implemented pattern checking
13:52:23 <fons> yep it's a bug in his book as well
13:52:42 <fons> It's so easy to blame the interpreter
13:52:43 <fons> haha
13:52:45 <fons> ;)
13:55:10 <lispy> fons: can you confirm it in an errata?
13:55:19 <fons> let's see
13:55:27 <fons> lispy, do you have the book?
13:55:28 <lispy> PAIP has been out quite a while
13:55:30 <lispy> nope
13:56:51 <fons> it's not in the errata
13:58:04 <skew> is he using a strange pattern matching library?
13:58:36 <fons> skew, well, don't know is it's strange
13:58:41 <fons> if
13:58:54 <fons> fons, but I do think he uses an overlapped patern
13:59:08 <fons> ok, my code is ready
13:59:30 <ADEpt> show it!
13:59:33 <fons> xerox, how?
13:59:53 <fons> sorry
13:59:56 <fons> ADEpt, how
13:59:57 <ADEpt> lisppaste2: url
13:59:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:00:12 <ADEpt> here you are :)
14:00:23 <fons> actually we could add a simplification module to lambdabot 
14:00:32 <fons> uhm, it's not just one file
14:00:47 <ADEpt> oh
14:00:48 <fons> ADEpt, I'll paste all of them
14:01:47 <lisppaste2> fons pasted "Expr.hs" at http://paste.lisp.org/display/19545
14:02:38 <SimonRC> fons: would you have attacked this problem in any other language?
14:03:46 <SimonRC> How about writing an integrator in Java?  class Exponent implements Integrable { ... }  hehehe
14:04:03 <lispy> SimonRC: lisp is what it was written in in Norvig's book :)
14:04:22 <lispy> yeah in java you'd have an expression factory
14:04:29 <SimonRC> the only three other languages I would touch it in are Common LISP, Scheme, and Kaya.
14:04:33 <lisppaste2> fons pasted "Simplify.hs" at http://paste.lisp.org/display/19548
14:05:06 <lisppaste2> fons pasted "ExprParser.hs" at http://paste.lisp.org/display/19549
14:05:13 <xerox> fons: make a darcs repository!
14:05:46 <lisppaste2> fons pasted "Main.hs" at http://paste.lisp.org/display/19550
14:05:55 <fons> that's it
14:06:09 <fons> ups, I just folloed the suggestion
14:06:13 <fons> :S
14:06:17 <SimonRC> Kaya is basically a cross between imperative Haskell and some other stuff, ask edwinb for details.
14:06:21 <fons> xerox, how can I create that?
14:06:24 <skew> SimonRC: the core algorithm is easy in anything with algebraic data types, or a similar term language - Ocaml, Erlang, etc
14:06:30 <ADEpt> wow. lots of simplification rules!
14:06:37 <SimonRC> oh, wait I forgot about those too
14:06:41 <SimonRC> silly me
14:06:53 <xerox> fons: download and install darcs.  Then it's very simple.  It's a matter of two commands, see the manual, it explains how to do it very briefly.
14:06:58 <ADEpt> fons: 1)darcs init
14:06:58 <ADEpt> 2)darcs add *.hs
14:06:58 <ADEpt> 3)darcs record
14:06:58 <ADEpt> 4)profit!
14:07:02 <skew> the Num instance is just a Haskell thing
14:07:16 <xerox> Right.
14:07:24 <fons> ADEpt, it works pretty well, test it ;)
14:07:36 <fons> it even uses libreadline
14:07:55 <skew> there's a Num instance that does numerical differentiation pretty well too
14:07:58 <lispy> fons: how long did the project take?
14:08:04 <fons> it's a toy simplifier but it works well
14:08:16 <fons> lispy, uhm it's difficult to measure
14:08:31 <skew> make your numbers lazy tayor series
14:08:33 <fons> but 2 weeks at least cause I didn't know lisp and I had to translate it
14:08:41 <lispy> fons: heh
14:08:53 <lispy> lisp syntax is at least very consistent
14:09:39 <fons> ok I just installed darcs
14:10:03 <lispy> darcs init; darcs add *.hs; darcs record
14:10:20 <lispy> after that do you have a web accessible directory somewhere?
14:10:48 <fons> addfile ./Expr.hs
14:10:49 <fons> Shall I record this patch? (1/?) [ynWsfqadjkc], or ? for help:
14:11:01 <fons> what does that mean?
14:11:21 <lispy> it's asking if you want darcs to add that file (adding it means darcs watches it for changes)
14:11:38 <lispy> [ynWs..] are keys you can press
14:11:53 <lispy> (1/?) means this is the first of some number of changes darcs will ask you about
14:11:58 <fons> what is the patch name?
14:12:02 <lispy> hit c to have it calculate all the changes
14:12:18 <ADEpt> fons: name is free-form
14:12:22 <lispy> some descriptive name, like, "import of code" or  "creation of repo"
14:12:47 <fons> ok, I finished, now what?
14:12:54 <fons> I used CVS but this is new to me
14:13:00 <lispy> do you have a public_html directory somewhere?
14:13:08 <fons> no, not here
14:13:39 <lispy> well, when you get a chance copy the whole directory to a web accessible place, run 'chmod -R a+rX' on the repo and give us the url :)
14:14:02 <lispy> thne we can use darcs get <url> to get a copy
14:14:43 <lispy> if you have ssh access you'd be able to do darcs push ssh:<path on remote machine> to push your changes as you make updates
14:14:49 <jethr0> vincenz: ping
14:15:10 <fons> there are just a few files
14:15:26 <fons> so you can get it from the pastes if you want to play with it
14:15:33 <lispy> fons: oh and darcs dist will create a tar ball if you want to share it with people that don't have darcs
14:15:33 <fons> I accept suggestions of course :)
14:16:55 <fons> how do I go back to the previous version in darcs?
14:17:05 <fons> I removed the files
14:17:05 <ndm> fons, darcs revert
14:17:17 <ndm> or darcs unrecord, if you saved the patches
14:17:22 <ndm> and recorded them
14:17:33 <ndm> darcs is great, but requires darcsweb to be truely useable
14:17:57 <lispy> ndm: i've never needed darcsweb
14:18:05 <lispy> ndm: what does it add that you like so much?
14:18:10 <ndm> lispy: how do you look at old versions
14:18:28 <lispy> ndm: hmm...i usually don't need to
14:18:29 <ndm> thats the main thing, seeing how things have changed, and for browsing the repo without it being checked out
14:18:34 <ADEpt> fons: darcs revert == "rm *; cvs up", darcs unrecord == cvs uncommit :); darcs unpull = cvs unupdate :)
14:18:42 <ndm> when its useful, its really useful
14:18:46 <fons> Iok cool
14:19:00 <lispy> ndm: okay, yeah.  I guess when i've done that in the past i get a new copy and unpull things
14:20:47 <fons> well I have a tarball
14:20:51 <vincenz> jethr0: pong
14:20:59 <fons> no webserver
14:21:02 <fons> :(
14:21:05 <jethr0> hey, i'm back from italy :)
14:21:08 <xerox> Cool.
14:21:09 <vincenz> jethr0: great !
14:21:11 <xerox> Where have you been?
14:21:12 <vincenz> jethr0: where did you go?
14:21:14 <fons> and I really wanted some feedback from you guys
14:21:21 <fons> I've benn working quite a lot
14:21:33 <jethr0> vincenz: i've wanted to add myself to the team page, but as i've read you've write-protected the wiki...
14:21:37 <vincenz> jethr0: yes
14:21:40 <vincenz> jethr0: join #oasis
14:21:45 <vincenz> jethr0: and I'll detail
14:21:57 <jethr0> vincenz: i went to the lakes (logarno, como, maggiore) and bergamo and milano
14:22:00 <vincenz> cool
14:22:02 <vincenz> I live at maggiore
14:22:07 <xerox> Really?
14:22:08 <vincenz> jethr0: did you go to laveno at lago maggiore?
14:22:10 <jethr0> really??
14:22:16 <vincenz> or intra?
14:22:19 <xerox> vincenz: I come there n times a year!
14:22:26 <vincenz> xerox: well I'm in belgium now
14:22:31 <vincenz> xerox: but my parents live in cittiglio
14:22:34 <jethr0> vincenz: i didn't know that. i could've come visited you
14:22:37 <xerox> Ah.
14:22:38 <vincenz> 4 km from laveno
14:22:45 <jethr0> for some reason i thought you where from belgium *???*
14:22:53 <vincenz> jethr0: yeah but my parents live there
14:22:56 <vincenz> and I used to
14:23:00 <jethr0> ah
14:23:00 <ellism> I'm getting some weird gcc error when building ghc-6.4.2, when trying to build StgCRun.c in rts I get this error: Unknown pseudo-op: .global using gcc 4.0.1.  Anyone heard of this?
14:23:01 <vincenz> until I came to belgium to study
14:23:03 <xerox> I've relatives in Pallanza.
14:23:04 <vincenz> jethr0: join #oasis?
14:23:15 <vincenz> xerox: you're in torino?
14:23:17 <xerox> Right.
14:29:55 <mahogny> "our biggest mistake: using the scary term Monad instead of Warm fuzzy thing" :)
14:33:03 <petekaz> @seen sjanssen
14:33:04 <lambdabot> I saw sjanssen leaving #haskell 21 minutes and 31 seconds ago, and .
14:33:11 <int-e> Monads were scary before I realized that Monads don't actually do anything; the monad operations are all plumbing.
14:33:41 <jethr0> monads don't do, they describe ^_^
14:34:31 <ADEpt> my mental image is taken from Incredible Machine game: you build an incredible contraption, and then it magically performs everything :)
14:34:51 <int-e> but there is no magic!
14:38:03 <ihope> int-e: what do you mean about their not doing anything?
14:40:52 <int-e> ihope: have you ever tried to build anything interesting using only return and >>=?
14:41:22 <ihope> I can build a more complicated return...
14:41:39 <int-e> ihope: but you can do that without the monad, too
14:41:42 <ihope> @type \x -> (return x >>=)
14:41:43 <lambdabot> forall (m :: * -> *) a b.
14:41:43 <lambdabot>         (Monad m) =>
14:41:43 <lambdabot>         a -> (a -> m b) -> m b
14:41:49 <sjanssen> petekaz: you rang?
14:41:50 <ihope> Whee...
14:42:18 <petekaz> yeah ... went to the gym ... just trying to understand how your group function works.
14:42:48 <petekaz> it's the where clause that is throwing me.
14:43:07 <sjanssen> do you understand span?
14:43:18 <SimonRC> where is the pasting place?
14:43:19 <petekaz> Let me look up all the functions first (no re: span) so I don't waste your time.
14:43:49 <Korollary> lisppaste2: url
14:43:50 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:44:12 <int-e> ihope: the point is, every interesting monad comes with some associated operations that magically operate inside the monad in ways >>= and return can not. State comes with put and get (or some other similar pair of functions). The list monad comes with a funny fail function, and all lists as 'monadic operations'. Etc.
14:44:47 <ihope> Ah.
14:45:13 <ihope> And the Reader monad has ask...
14:45:20 <ihope> @type Control.Monad.Reader.ask
14:45:21 <lambdabot> forall r (m :: * -> *).
14:45:21 <lambdabot>           (MonadReader r m) =>
14:45:21 <lambdabot>           m r
14:45:30 <sjanssen> petekaz: I just noticed there's an error in groupBy
14:46:02 <lisppaste2> sjanssen annotated #19540 with "fixed groupBy" at http://paste.lisp.org/display/19540#2
14:46:24 <petekaz> Where do I find docs for ByteString?  I've been using the GHC doc page for stuff but can't seem to find it.
14:46:43 <sjanssen> ?where fps
14:46:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
14:47:08 <lisppaste2> SimonRC pasted "Infinite type problem" at http://paste.lisp.org/display/19553
14:47:09 <petekaz> ah .. that makes a little more sense.
14:47:17 <SimonRC> I am getting "infinite type" errors, and I am not sure if I can avoid them at all.
14:47:22 <Heffalump> has lambdabot acquired a new control character?
14:47:41 <sjanssen> Heffalump: several
14:47:49 <petekaz> I'm still confused by you referencing the 'x' in the where clause for PS.head.
14:47:51 <sjanssen> \where fps
14:48:03 <sjanssen> oh, maybe that isn't one, meh
14:48:07 <Heffalump> why, OOI?
14:48:14 <xerox> Yep!
14:48:26 <xerox> @ sucks.
14:48:56 <sjanssen> petekaz: ack! another error
14:49:34 <sjanssen> petekaz: (eq $ PS.head x) should be (eq $ PS.head xs)
14:49:44 <petekaz> ok.
14:50:15 <sjanssen> I renamed some variables in that function and forgot to test it again, apparently
14:50:25 <petekaz> Ok, now once I read about span and such, things will make more sense.  I was baffled by that use of x and non-use of xs'.
14:50:49 <sjanssen> heh, sorry about my baffling errors
14:51:39 <dcoutts> @seen SyntaxNinja
14:51:40 <lambdabot> I saw SyntaxNinja leaving #haskell 14 hours, 21 minutes and 27 seconds ago, and .
14:51:46 <petekaz> well thanks for the example ... my version was sooooo slow (which I expected), but it was the one-liner thing that really impressed me.
14:52:30 <petekaz> your version still keeps with the one-liner which impresses me so much for some reason.
14:53:15 <petekaz> ah .. span is like partition in erlang.
14:53:22 <SimonRC> No-one has an idea to solve my problem?
14:53:29 * SimonRC tries using newtypes
14:53:59 <sjanssen> > span (== 1) [1, 1, 2, 1]
14:54:00 <lambdabot> ([1,1],[2,1])
14:54:14 <sjanssen> > partition (== 1) [1, 1, 2, 1]
14:54:15 <lambdabot> ([1,1,1],[2])
14:54:36 <petekaz> hmm .. I guess I'm mistaken :-)
14:54:43 <sjanssen> SimonRC: where are you getting infinite types?
14:55:31 <sjanssen> SimonRC: newtypes probably can't solve your problem
14:56:35 <hyrax42> @type span
14:56:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:56:53 <hyrax42> what does span do?
14:56:57 <hyrax42> split a list into two parts
14:56:58 <SimonRC> sjanssen: see paste
14:57:17 <hyrax42> first is the part of list where predicate holds (from front)
14:57:20 <hyrax42> and then the rest?
14:57:23 <SimonRC> sjanssen: "22:46 < lisppaste2> SimonRC pasted "Infinite type problem" at http://paste.lisp.org/display/19553"
14:57:28 <sjanssen> hyrax42: exactly
14:57:53 <hyrax42> what is the command to find out where a function is defined
14:57:55 <hyrax42> for lambdabot
14:58:03 <hyrax42> or what module it's in
14:58:09 <int80_h> hello um haskelliers
14:58:14 <SimonRC> hi
14:58:17 <hyrax42> hi
14:58:18 <int80_h> haskelltiers?
14:58:28 <int80_h> erm..
14:58:36 <SimonRC> I believe the term is "loonies".
14:58:38 <int80_h> haskellators. Okay that's the one.
14:59:01 <int80_h> yes, judges would have also accepted "right loonies"
14:59:23 <hyrax42> @index span
14:59:24 <lambdabot> Data.List, Prelude
14:59:37 <sjanssen> SimonRC: one technique to use when you really want infinite types is "data Inf a = Inf (a -> (a, Inf))"
14:59:45 <sjanssen> the data makes it possible
15:00:00 <sjanssen> I don't understand the Cont monad, so that's probably as much help as I can give
15:00:50 <sjanssen> I guess my example isn't an infinite type, but perhaps you get my drift?
15:01:12 <SimonRC> yeah, except a data type with one constructor which is unary, is similar to a newtype
15:01:47 <SimonRC> data X = Foo Int  is like  newtype X = Foo Int  in many ways
15:01:57 <int80_h> is something going on with freenode, I keep getting disconnected
15:02:05 <sjanssen> newtypes can't be recursive
15:02:13 <SimonRC> maybe your shell account is dodgy
15:02:21 <SimonRC> sjanssen: ah, ok
15:02:37 <int80_h> well I don't always get disconnected, just sometimes
15:02:46 <petekaz> environment question ... I've got a debian system, and have loaded ghc, where is the "right" place to load libraries like fps?
15:03:09 <int80_h> I'm coming from sdf. Someone on the service may have been naughty. It's possible
15:03:39 <xerox> Hey int80_h!
15:03:47 <int80_h> hello :)
15:03:51 <xerox> int80_h: very nice to see you're taking part to the Soc!
15:04:02 <int80_h> well I hope to be. No one has put me on the project yet
15:04:15 <int80_h> but this is motivating me to get through my tutorial
15:04:36 <xerox> Do it yourself, write your name under the tickets talking of projects you are interested in.
15:04:37 <int80_h> I figure, even if it doesn't become a SoC project I can still connect with people to get this done
15:04:58 <hyrax42> which project
15:04:59 <ADEpt> xerox: btw, what's next with SoC?
15:05:10 <int80_h> hold on I'll get the ticket
15:05:11 <xerox> ADEpt: what do you mean?
15:05:14 <hyrax42> ADEpt: student applications start tomorrow
15:05:18 <hyrax42> deadline the 8th
15:05:24 <int80_h> http://hackage.haskell.org/trac/summer-of-code/ticket/56
15:05:29 <SimonRC> sjanssen: actually, recursive newtypes are fine, I tested it.  Recursive type synonyms sound less likely to work.
15:05:32 <hyrax42> goog makes decisions by 22nd I think
15:05:41 <xerox> ADEpt: there is a deadline on the site
15:05:45 <xerox> Ops, timeline-.
15:05:46 <int80_h> I sent mail to the one who agreed to be a mentor
15:05:56 <int80_h> hoping he can help me write up a proper proposal
15:06:07 <int80_h> I imagine google will want more than the paragraph I jotted down 
15:06:29 <xerox> int80_h: nah.
15:07:01 <ADEpt> xerox: well, there are tickets on trac, everybody put their names in, mentor registration is ongoing, student registration starts tomorrow. Maybe I'm dense but i still dont have a clear picture what happens after the 22nd. Could be that I just missed the appropriate part of the FAQ :(
15:07:03 <int80_h> Well, I need some way to pursuade don't I?
15:07:33 <Korollary> petekaz: You can install cabal-ized libraries system-wide, or for your user only.
15:07:34 <int-e> int80_h: yes, mahogny was looking for you earlier. (and confused our two nicks)
15:07:49 <ADEpt> petekaz: re libraries: I just use Cabal to install them under /usr/local -- i'm too lazy to do .debs, most of the time.
15:07:52 <int80_h> oooh  is that yohan?
15:07:58 <mahogny> int80_h, !
15:08:07 <int80_h> I mean johan. A guy named johan wants to be the mentor for the project
15:08:20 <int-e> int80_h: actually that's what it says in the ticket you linked to :)
15:08:24 <xerox> ADEpt: from tomorrow student proposals will begin to flow in.
15:09:11 <int80_h> yes I have. He wants to do a seperate project. He says only one person can be on each project. Is this true?
15:09:24 <int80_h> oops, sorry mahogny...that was for you
15:10:37 * ADEpt rereads the google's FAQ real slow
15:14:53 <int80_h>             can point out any texts I should study I'd appreciate it. Did you
15:14:55 <int80_h>             recieve my mail yet?
15:15:03 <int80_h> oops that wasn't right
15:15:13 <int80_h> mahogny did you make sense of that?
15:16:04 <int80_h> sweet, well I have these two books right now..hold on
15:17:19 <int80_h> I will need to get them from the library as needed
15:18:20 <mahogny> int80_h, it's also possible to set it up as an IRC bot if you want to try an alternative approach. it's a bit easier, but of course that medium adds some restrictions on the graphics you can output
15:18:42 <int80_h> Algorithms by rabhi and The craft of functional programming by thompson
15:19:08 <int80_h> oh there won't be any graphics. Just ascii
15:19:12 <mahogny> I'm not a major fan of the latter since it is very far from the real world. but you should go through it for a starter
15:19:14 <petekaz> so I have built and installed fps via the Setup.hs script, how do I tell my ghc about the location of the library?  It compiles my test program, but the linking step fails.  
15:19:42 <int80_h> yeah give me real world haskell please :)
15:20:11 <int80_h> I don't think the irc bot is general enough. I want to build an engine that will aloow people to write their own muds
15:20:12 <mahogny> int80_h, lemme check for an url
15:20:42 <int80_h> with a haskell subset for  an embedded language
15:20:56 <int80_h> hey could I use hugs to build the mud engine?
15:21:04 <int80_h> at least as a prototype?
15:21:22 <ADEpt> int80_h: why not? :)
15:21:25 <int80_h> I mean I think hugs has a server capability...
15:21:26 <Korollary> petekaz: are you using ghc --make ?
15:21:31 <mahogny> http://www.isi.edu/~hdaume/htut/  is a bit more hardcore than the craft of functional programming
15:21:39 <int80_h> well I don't know if it's the best way to go, is why I'm asking
15:21:44 <mahogny> I see no problem with hugs for a starter
15:22:00 <mahogny> I hate the error messages it spits out but that's not really my problem :)
15:22:02 <petekaz> Korollary: nope.  Thanks!
15:22:27 <ADEpt> int80_h: <shameless ad>http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell is even more hardcode</smaeless ad>
15:22:29 <int80_h> oh mahogny can you help me draft the proposal for google?
15:22:42 <mahogny> int80_h, I can have a look at it when you're done
15:24:08 <int80_h> well, exactly what level of detail do they want...can you point me to a template?
15:24:10 <ADEpt> xerox: question - "Students submit to Google proposals ...; Google routes to the mentor organization, and the proposals are ranked by mentors working with those organizations". Do you know what is this "ranking" process, how it will happen?
15:24:27 <xerox> ADEpt: not yet.
15:25:01 <xerox> I need to talk with SyntaxNinja but he did show up yesterday at 3AM and I was sleeping... sigh :-|
15:25:10 <xerox> I need a way to get me on the computer when he arrives.
15:25:25 <mahogny> sounds to me like we are supposed to make a priority list of all proposed projects
15:25:39 <mahogny> makes life easier for google
15:27:07 <int80_h> yeah I imagine mud engine is low on the list
15:27:11 <musasabi> I think it will make sense to look at the concrete proposals from students.
15:27:12 <ADEpt> xerox: it's magic :)
15:27:19 <ADEpt> xerox: here he is :)
15:27:23 <int80_h> but if it doesn't get accepted will you mentor the project anyway?
15:27:35 <xerox> SyntaxNinja, hi!
15:27:39 <mahogny> int80_h, just for the record, I am willing to mentor any project no matter if it is accepted or not
15:27:55 <drakioned> ahh, int80 is here!
15:28:08 <int80_h> oh sweet, then it will happen. I've been hesitating due to my newbieness.
15:28:14 <int80_h> hello drakioned.
15:28:26 <int80_h> can you tell me the ideas you have for your project?
15:28:38 <int80_h> mahogny says we are going in different directions.
15:28:45 <drakioned> sure, not had that many though..
15:28:47 <ADEpt> xerox: strage, but this "ranking" is not mentioned anywhere else on the google and it's not evident what purpose it serves, since it is after the acceptance of students
15:29:15 <mahogny> ehr. after? hm
15:29:31 <drakioned> we're heading in different directions? er.. what are you doing?
15:29:59 <ADEpt> mahogny: section 3, bullet 5 of the Mentor's FAQ
15:30:50 <SyntaxNinja> hiya xerox
15:31:14 <hyrax42> int80_h: how newbie are you?
15:31:17 <drakioned> I've just made a new rough ideas about implementation, nothing concrete, and some possible extensions to MUD concept, but nothing that's major..
15:31:31 * hyrax42 wonders if we're at similar newbness level
15:31:40 * drakioned is a newbie as well.
15:32:04 <dcoutts> SyntaxNinja, hia
15:32:12 <int80_h> hyrax as far as haskell goes I'm halfway through chapter 6 of Thompsons Craft of Functional Programming. But I am a C programmer as well as asm.
15:32:19 <xerox> dcoutts: any other infos?  He accepted everyone.
15:32:21 <SyntaxNinja> hey dcoutts
15:32:32 <mahogny> ADEpt, ehr. in no way am I able to read this as to make ranking come after acceptance
15:32:40 <dcoutts> xerox, oh, let me check the mentors page...
15:33:03 <hyrax42> ne'er heard of the book
15:33:06 <drakioned> hmm int80_h is probably less newbie than me
15:33:23 <int80_h> really?
15:33:44 <dcoutts> xerox, it still says nothing for me other than "This page won't be much help until an Organization accepts you as a mentor
15:33:44 <dcoutts> "
15:33:47 <int80_h> I don't think I know enough Haskell to outline implementation
15:34:03 <ADEpt> mahogny: I (wrongly) assumed that "google routes" comes after acceptance
15:34:19 <drakioned> I dabble a bit in Haskell, and written one GUI application, but I can't program in C or anything else
15:34:31 <mahogny> xerox, still no news on the "mentoring acceptance pending"?
15:35:08 <int80_h> I'm not a fresh C programmer. I've been doing it for years ;)
15:35:27 <int80_h> erm, I gues I'm not used to /msg
15:35:43 <drakioned> what are you studying anyway?
15:35:48 <int80_h> math
15:35:59 <drakioned> lol
15:36:06 <SimonRC> Does anyone here understand what the first parameter to the Cont type is for?
15:36:13 <drakioned> me too
15:36:29 <int80_h> heh I'm a horrible academic. But don't tell anyone.
15:36:34 <ADEpt> @index Cont
15:36:34 <lambdabot> Control.Monad.Cont, Control.Monad.Cont
15:36:41 <drakioned> ditto..
15:36:43 <SimonRC> I can't figure out what the point of it is.
15:36:44 <mahogny> int80_h, I have a feeling you're not alone in here
15:36:45 <int80_h> CS around here isn't abstract enough, they left me no choice but to go the math route
15:37:10 <drakioned> oh.. I'm not a fan of abstract CS at all
15:37:23 <int80_h> majoring in CS around these parts means being made into a java bot.
15:37:31 <SimonRC> yes, grr
15:37:53 <SimonRC> we did 1 term of 1 module on HAskell
15:38:08 <drakioned> heh, here, you don't need to learn C, but they force you to learn Haskell ;)
15:38:11 <mahogny> int80_h, lol. reminds me of an article where they complain about universities teaching java :)
15:38:23 <SimonRC> I aced it due to having studied Haskell in my free time the previous year
15:38:39 <SimonRC> mahogny: they = Paul Graham?
15:38:49 <mahogny> SimonRC, might be the one
15:39:06 <int80_h> well I suspect that in learning haskell one can pick up any given langaueg easily after that
15:39:27 <drakioned> I'd say not..
15:39:31 <mahogny> I doubt so. the transition from haskell to, say, C, is probably quite rough
15:39:55 <drakioned> mahogny: yeah, I had to write some java code the other day and I couldn't figure out how..
15:40:06 <mahogny> some thing translate of course. like data structures and algorithms
15:40:22 <mahogny> drakioned, I just almost did partial application on a function in php :P
15:40:55 * mahogny is broken. coding too many languages at the same time
15:41:43 <drakioned> I wrote a function that took a java array, and returned me a smaller array (one smaller) containing the latter elements in the array, god knows how inefficient that must be..
15:41:55 <mahogny> eeew
15:41:56 <SimonRC> mahogny: it's good for you
15:42:22 <int80_h> mahogny where can I find a temlate for project prposals?
15:42:30 <SimonRC> I wrote a recursive delete function on lists ... in C!
15:42:33 <drakioned> mahogny: well, if they just gave me a tail function in the language, I wouldn't have needed to do it
15:42:38 <int80_h> I expect you have a better idea of what google wants to read
15:42:41 <mahogny> SimonRC, I have nothing against knowing many (I do) but I prefer to put them on the shelf for longer times as to not mix them up all the time
15:42:50 <mahogny> int80_h, sorry, I don't know
15:42:51 <SimonRC> ah, ok
15:43:00 <int80_h> hmm I will put it to the mailing list then
15:43:06 <int80_h> or the channel here in general
15:43:14 <mahogny> SimonRC, I have written a java style main declaration in C way too many times ;)
15:43:16 <drakioned> mahogny: make use of the FFI ;)
15:43:25 <SimonRC> mahogny: yeah
15:43:26 <mahogny> I do. a lot :)
15:43:26 <int80_h> channel listen up. If yuo know of a url that will help me put my project prosal together please point it out :)
15:43:56 <mahogny> use what you learned in the english class :)
15:44:16 <int80_h> well what level do they want? 
15:44:19 <drakioned> mahogny: one of the guys on the course got fed up and started porting random Prelude functions to C
15:44:27 <mahogny> int80_h, dunno. make a good guess
15:44:28 <int80_h> Is the paragraph I put up on the wiki suffcient?
15:44:34 <mahogny> drakioned, :D
15:45:07 <mahogny> int80_h, you might want to add more details in your proposal
15:45:29 <int80_h> okay. I'm basing this off of LPMud anyway
15:45:36 <drakioned> mahogny: inefficient as hell, but we've always gone by the idea of "get the software right, if you need twice the speed, wait a year and the hardware'll to do it"
15:45:45 <int80_h> I can mention the parsing library you mentioned
15:46:02 <mahogny> drakioned, true that. although the C-coder in my brain wants to blow your head off :)
15:46:07 <int80_h> oh can you e-mail me yor estimate of what we can accomplish in a summer?
15:46:29 <mahogny> int80_h, I'd need to know more about what you want to do in that case
15:46:36 <mahogny> technical stuff
15:46:39 <ADEpt> SimonRC: about the first param to Cont -- i think it is there so that Cont could be used to build continuations of type a -> b, not just a -> a
15:46:54 <drakioned> mahogny: for sure, C & asm programmers are like that.. :P
15:47:34 <drakioned> mahogny: think like a mathematician: if it completes in finite time, that's alright ;)
15:47:36 <mahogny> drakioned, my style: write a trivial but working implementation. write a very fast implementation. use a theorem prover to show correctness of the latter :)
15:47:43 <mahogny> drakioned, what about induction? :)
15:48:22 <drakioned> well, with induction, you say that for any case, you can recurse down to the base case in finite time :P
15:48:44 <int80_h> okay I have to go for now. I'll send you mail mahogny :)
15:49:05 <mahogny> drakioned, if you are to write a proof on your next math exam, write some QuickCheck code :)
15:49:07 <mahogny> int80_h, ok
15:49:21 <int80_h> bye drakioned
15:49:26 <drakioned> cya int80_h 
15:49:33 <drakioned> mahogny: maths dept will blow my head off ;)
15:50:03 <drakioned> mahogny: am actually on a 50/50 split course between CS and maths
15:50:11 <mahogny> drakioned, consider the facial expression of the one correcting the exam... it's worth it ;)
15:50:59 <drakioned> I have to say, what one side of the course teaches me has no connection whatsoever to the other side
15:51:23 <mahogny> sounds like either you or the examiner is completely lost =)
15:52:42 <drakioned> well, despite being a joint course, the maths side consists of group, ring, field theory, and the CS side gets me to do things like write a noughts and crosses game in Haskell
15:53:38 <mahogny> LOL. ok :)
15:55:24 <drakioned> I saw some theoretical CS the week before last and it blew my mind.
15:56:05 <mahogny> nice stuff. programming is best done on paper :)
15:56:56 <drakioned> I should find someone to explain to me what all the turnstiles & other symbols mean
15:57:43 <mahogny> what kind of stuff is it? program reductions?
15:58:00 <drakioned> type systems I think
15:58:03 <mahogny> ah
15:58:09 <mahogny> sounds like a good course
15:58:12 <liyang> Naughts and crosses?
15:58:16 <liyang> Where are you, drakioned?
15:58:28 <mahogny> type theory for C/C++ programmers: void *
15:58:47 <drakioned> oh, Hi Liyang.
15:59:04 <drakioned> I'm where you are, we've been over this before :P
15:59:14 <liyang> oh, and you are who I think you are. Cool.
15:59:33 <Korollary> Look, two FBI agents!
16:08:12 <hyrax42> mahogny: for int80_h: http://www.perl.org/advocacy/summerofcode/proposals.html
16:08:20 <hyrax42> mahogny: and http://drupal.org/node/59037
16:08:31 <hyrax42> (also for soc applicants in general I guess)
16:09:11 <mahogny> thx. should forward it to the others
16:09:35 <hyrax42> or maybe even add it to the wiki/trac
16:10:11 <mahogny> xerox_, ping
16:10:15 <mahogny> xerox_, check above
16:11:11 <hyrax42> yeah, at least both of Perl and Python are pointing to the Drupal thing as advice
16:11:33 <hyrax42> http://drupal.org/node/59963 also
16:14:01 <Lemmih> SyntaxNinja: Woa, you've moved CabalGet to Cabal.
16:18:16 <SyntaxNinja> Lemmih: well, you'll see that I didn't do the leg work, but yeah.
16:18:27 <SyntaxNinja> Lemmih: next step is to trim back the dependencies.
16:19:04 <mahogny> are you doing the trim-down-cabal SoC stuff?
16:19:15 <Lemmih> SyntaxNinja: Didn't shapr do that?
16:19:34 <SyntaxNinja> Lemmih: shapr is working on it. I'm not sure his status at this moment. I emailed him last night to ask.
16:19:43 <SyntaxNinja> mahogny: no. that hasn't started yet.
16:19:51 <SyntaxNinja> Lemmih: you like? excited?
16:20:02 <SyntaxNinja> Lemmih: I think we're starting a cabal-devel mailing list, so you'll have to jump on there :)
16:21:21 <Lemmih> Neat.
16:26:59 <mahogny> bbl
16:29:30 <vincenz> Lemmih: hi
16:29:45 <vincenz> Lemmih: we decided on separate moderate channel for oasisbot repo notifies, to keep spam down in main cha
16:31:22 <paolo_> ARGH.
16:32:54 <paolo_> One reboots a computer, and it stops working...how nice.
16:39:13 <vincenz> dons: ping
16:39:56 <vincenz> > 1
16:39:57 <lambdabot> 1
16:39:58 <oasisbot> 1
16:40:03 <vincenz> @part #haskell 
16:40:04 <lambdabot> Not enough privileges
16:44:04 <xerox-> SyntaxNinja: any news?
16:44:31 * SimonRC goes
16:46:46 <vincenz> @where
16:46:47 <lambdabot>  @where <key>, return element associated with key
16:46:50 <vincenz> @version
16:46:51 <lambdabot> lambdabot 3p427, GHC 6.4.1 (Linux i686 3.20GHz)
16:46:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:48:17 <SyntaxNinja> xerox-: about what?
16:52:32 <palomer> @hoogle &&&
16:52:33 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
16:53:20 <palomer> > Control.Arrow.&&& (\x -> x) (\x -> x) 1
16:53:21 <lambdabot>  parse error on input `Control.Arrow.&&&'
16:53:31 <vincenz> palomer: long time no see
16:53:42 <palomer> oh! that's right!
16:53:42 <palomer> oasis
16:54:26 <palomer> how do I get ghci to tell me all the symbols exported by a module?
16:54:56 <palomer> wait, how can &&& have that type?
16:54:59 <palomer> unless I'm missing something
16:55:21 <vincenz> it's correct
16:55:22 <palomer> if you apply &&& to 3 things, it returns a pair
16:55:25 <vincenz> no
16:55:28 <vincenz> yeah
16:55:31 <int-e> palomer: :browse <module>
16:55:35 <vincenz> if you apply it to two functions
16:55:40 <palomer> (id &&& id) 1
16:55:41 <vincenz> it makes a fucntion taking the same input as the other two
16:55:44 <vincenz> and retunrs a pair
16:55:45 <palomer> (1,1)
16:55:51 <vincenz> right
16:55:57 <palomer> I applied it to 3 things
16:56:00 <palomer> and it returned a pair
16:56:00 <vincenz> -> a b (c,c')
16:56:04 <vincenz> it returns an arrow
16:56:07 <vincenz> of type a
16:56:09 <vincenz> taking type b
16:56:11 <vincenz> and returning pair c
16:56:22 <palomer> how do you apply an arrow?
16:56:26 <palomer> it doesn't have an arrow type
16:56:32 <int-e> palomer: (->) is an instance of Arrow
16:56:35 <vincenz> it's just like (b->c) -> (b->c') -> (b-> (c,c'))
16:56:37 <palomer> ahhh!
16:56:49 <palomer> so anything instantiating arrow can be applied
16:56:52 <palomer> is that it?
16:57:06 <vincenz> no
16:57:12 <vincenz> not all arrows might be functions
16:57:33 <int-e> palomer: &&& for that instance reads: (b -> c) -> (b -> c') -> (b -> (c, c'))
16:57:42 <int-e> palomer: err, its type does.
16:57:43 <palomer> if I see (a b), then I reason that a must have type alpha -> beta and b must have type alpha
16:58:26 <int-e> woops. vincenz already said it.
16:59:07 <palomer> where's the documentation for this module, explaining every symbol exported?
16:59:35 <int-e> @docs Control.Arrow
16:59:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
17:00:14 <palomer> ahh, it infers that the Arrow must be ->
17:00:25 <palomer> since it's applied
17:00:33 <palomer> right?
17:00:34 <vincenz> palomer: no
17:00:35 <vincenz> palomer: it infers it
17:00:39 <vincenz> palomer: cause it gets two functions as input
17:00:43 <vincenz> so the output must be another arrow
17:00:46 <vincenz> (same a)
17:00:47 <palomer> oh, that too
17:00:48 <vincenz> that is alos a function
17:01:37 <int-e> > (undefined &&& undefined) 1
17:01:38 <lambdabot> Add a type signature
17:01:44 <int-e> > (undefined &&& undefined) ()
17:01:45 <lambdabot> Add a type signature
17:10:31 <palomer> really, it could infer it either way
17:11:22 <palomer> if haskell sees an application, it will infer that the head is a -> b for some a b
17:12:13 * palomer has just found a major advantage of writing his own monad
17:12:25 <palomer> I can print out every reduction!
17:13:20 <vincenz> hey people
17:13:21 <vincenz> bit OT
17:13:22 <vincenz> but
17:13:28 <vincenz> do you guys recommend DVD + or -
17:13:38 <palomer> for discs?
17:13:42 <palomer> I don't think it makes a difference
17:13:44 <vincenz> burning drive
17:15:24 <palomer> aren't most drives DVD +-?
17:17:06 <vincenz> not for lappy
17:17:14 <hyrax42> yeah you'd be hard pressed to find a + or - onl...ah
17:17:28 <hyrax42> even there +/- exist
17:17:35 <hyrax42> and DL
17:20:12 <lispy> palomer: what do you mean?
17:20:32 <lispy> @palomer
17:20:32 <lambdabot> Scalliwags!
17:20:41 <lispy> haha, scalliwags...
17:20:44 <palomer> mean by what?
17:20:52 <lispy> <palomer> I can print out every reduction!
17:21:07 <palomer> I can insert an sTrace into >>=
17:21:47 <lispy> hmm..yeah i guess you can't do that with the list monad
17:21:54 <lispy> since it's already defined
17:23:10 <palomer> exactly
17:33:02 * palomer has decided to quickcheck ALL of his code
17:33:38 <dons> ?karma+ palomer 
17:33:39 <lambdabot> palomer's karma raised to 3.
17:33:46 <palomer> yes!
17:34:36 <RyanT5000> is there any way to make +RTS -p flush its buffers frequently?
17:34:47 <RyanT5000> i'm using SDL, and i can't keep it from crashing on exit
17:34:55 <RyanT5000> which causes the .prof to never get written
17:36:48 <dons> hmm. its an interesting idea.
17:37:08 <dons> but i'd try to work out why its crashing first. or is that what you're doing?
17:37:30 <RyanT5000> well, i'm trying to some degree, but it's not really worth my time, because it doesn't matter
17:37:42 <RyanT5000> it crashes as soon as i return from main, or when i call exitWith or SDL.quit
17:37:55 <paolo_> Goodnight
17:38:08 <RyanT5000> i.e.: i'd never release it that way, but i'd rather delay working on that until closer to release
17:38:21 <RyanT5000> (i've given it a try for maybe 30 minutes)
17:38:46 <Lemmih> RyanT5000: The profiling information isn't written untill the end of the program.
17:38:59 <RyanT5000> can i force it to be written in the program somewhere?
17:39:08 <RyanT5000> i.e.: GHC.RTS.writeProfInfo
17:39:10 <Lemmih> Not easily.
17:39:12 <RyanT5000> damn
17:39:35 <RyanT5000> well then, does anyone have any experience making SDL not crash on exit?
17:40:03 <Lemmih> How are you initializing SDL?
17:40:19 <Lemmih> And how does it crash?
17:40:28 <RyanT5000> SDL.init [SDL.InitVideo] >> TTF.init
17:40:38 <RyanT5000> then i use OpenGL
17:40:40 <RyanT5000> then i exit
17:41:30 <RyanT5000> i had been using InitNoParachute, but it didn't make any difference when i took it off (except it caught the segfault)
17:41:37 <Lemmih> RyanT5000: Have you tried SDL.withInit?
17:41:48 <RyanT5000> ah, i'll do that
17:41:57 <RyanT5000> can i do multiple subsystems with that?
17:42:03 <RyanT5000> i.e.: TTF as welll
17:45:01 <Lemmih> RyanT5000: Not yet with TTF. I should probably fix that.
17:45:47 <mwc> hahahahaha
17:45:53 <mwc> I just read about MORKt
17:45:57 <mwc> the mozilla DB from hell
17:46:07 <mwc> Effiecient: stores unicode at 6 bytes/char
17:46:18 <RyanT5000> ...
17:46:24 <mlh> utf-6?
17:46:27 <RyanT5000> how do you even do that?
17:46:38 <sjanssen_> mwc: where is this?
17:46:58 <sjanssen_> RyanT5000: I guess you do it by wasting more than two bytes for each character
17:47:13 <mwc> mlh, you write out wchar_t as hex values, prepending $ or something
17:47:20 <RyanT5000> GAH
17:47:34 <mlh> http://en.wikipedia.org/wiki/Mork_(file_format)
17:47:37 <mwc> http://jwz.livejournal.com/312657.html
17:47:38 <mwc> indeed
17:47:44 <RyanT5000> \DEAD;
17:47:45 <RyanT5000> i bet that's it
17:48:07 <mwc> I have to agree with the observation on the lj thread that this is the most hilariously stupid file format ever conceived
17:48:23 <RyanT5000> XML + database = retarded
17:48:35 <mwc> RyanT5000, this actually makes XML look friendly
17:48:40 <RyanT5000> well, database file format
17:49:17 <RyanT5000> Also, despite being plain text, Mork is generally regarded as unintelligible to humans and as a hard format to write parsers for.
17:49:23 <RyanT5000> ^ from that page
17:49:25 <mwc> yeah
17:49:34 <RyanT5000> so why do they bother?
17:49:40 <RyanT5000> i mean, it can't be efficient
17:51:14 <RyanT5000> lemmih: it's not working, although it is crashing differently
17:51:19 <RyanT5000> the parachute isn't working
17:51:24 <RyanT5000> which, i think, is probably better
17:51:44 <RyanT5000> it gets out of the withInit block "successfully"
17:51:49 <RyanT5000> it only crashes on exit
17:52:05 <RyanT5000> maybe if i deregister any "at_exit" stuff it has?
17:52:23 <RyanT5000> i'm not really interested in a good solution right now, just a quick one that lets me get profiling information
17:53:11 <Lemmih> How does it crash? Segfault?
17:53:15 <RyanT5000> yep
17:54:41 <Lemmih> Hm, that's very weird.
17:54:47 <RyanT5000> want the code?
17:55:13 <RyanT5000> i wouldn't rule out the possibility of it being the result of some interaction with OpenGL
17:55:53 <RyanT5000> also, i'm not explicitly deallocating anything, like the window or surface, for instance
17:59:23 <Lemmih> Sure, put it online.
17:59:31 <RyanT5000> @where paste
17:59:31 <lambdabot> http://paste.lisp.org/new/haskell
18:00:00 <lisppaste2> RyanT5000 pasted "crashesOnExit" at http://paste.lisp.org/display/19559
18:00:20 <RyanT5000> i can try to cull it down to minimal crashing code
18:01:00 <RyanT5000> (btw if you want to tell me why my bitmap-manipulation routines are so painfully slow, that wouldn't hurt either :P)
18:02:12 <mwc> RyanT5000, without looking at the code, I'd say Boxing off the top of my head
18:02:45 <RyanT5000> well what i do is turn it into a list of ((x, y), color) first thing, which should be a copy
18:02:56 <RyanT5000> but then everything else should be lazy operations on a list
18:03:00 <RyanT5000> until the next copy into a buffer
18:03:13 <mwc> you have a list, and do element by element processing?
18:03:16 <RyanT5000> yeah
18:03:29 <mwc> have you been sure to use good producer/consumers as much as possible?
18:03:31 <RyanT5000> i know it sucks, but it sucks more than i expected
18:03:43 <RyanT5000> i'm not really sure what you mean by that
18:03:48 <fons> Could not find module `Graphics.UI.SDL.TTF'
18:03:50 <RyanT5000> my haskell optimization knowledge is approximately nothing
18:04:00 <RyanT5000> fons: it's not in the standard libraries yet
18:04:09 <mwc> RyanT5000, http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3153234
18:04:23 <RyanT5000> mwc: thanks
18:04:36 <RyanT5000> as soon as i can get +RTS -p working i'll have some idea where to start
18:04:39 <mwc> some operations on the list, when changed, can be optimized to eliminate the intermediate lists
18:04:53 <mwc> you'll want a good producer producing a list fed into a good consumer
18:05:18 <Lemmih> RyanT5000: I can't see why it should crash.
18:05:34 <RyanT5000> neither can i
18:05:43 <RyanT5000> what i'd love is a way to say "don't call any atexit stuff"
18:05:55 <RyanT5000> presumably the OS can deallocate anything i allocated
18:06:17 <RyanT5000> (not necessarily a valid assumption, as i'm running on windows, but still)
18:08:57 <fons> RyanT5000, where did you get the haskell sdl from?
18:09:51 <Lemmih> fons: http://darcs.haskell.org/~lemmih/hsSDL, I think.
18:10:05 <RyanT5000> i think that's right
18:10:53 <RyanT5000> hm, is there a binding for abort()?
18:11:04 <RyanT5000> i guess that wouldn't work though
18:11:16 <RyanT5000> profiling info wouldn't get written either
18:12:48 <Lemmih> Try isolating what's causing the segfault.
18:15:12 <RyanT5000> yeah, that's what i'm working on
18:15:27 <RyanT5000> it's crashing during exitWith
18:15:42 <RyanT5000> i know that because all my putStrLns work
18:17:56 <Lemmih> I'm off to bed. Good luck.
18:18:00 <RyanT5000> thanks
18:22:02 <RyanT5000> soooo.... i've whittled the program down to "main = do SDL.withInit [SDL.InitVideo] $ do return ()"
18:22:09 <RyanT5000> and it still crashes in exactly the same way
18:26:12 <Lemmih> That's pretty weird.
18:27:34 <RyanT5000> i wonder if it's just because i'm on windows
18:28:11 <Lemmih> I didn't even know my bindings compiled on Windows.
18:28:18 <RyanT5000> they don't :)
18:28:26 <RyanT5000> cabal doesn't work on windows, afaik
18:28:35 <RyanT5000> well, it works in visual haskell
18:28:39 <Lemmih> urk.
18:28:40 <RyanT5000> but it crashes when i run it from the commandline
18:29:13 <RyanT5000> however, i just threw your whole source tree in mine
18:29:23 <RyanT5000> and ran the preprocessing stuff
18:29:27 <RyanT5000> so i have a bunch of .hs
18:29:31 <RyanT5000> which ghc can find when it builds
18:29:43 <RyanT5000> it seems to work
18:29:50 <RyanT5000> except the exiting part
18:30:05 <RyanT5000> otoh it's not like real games never crash on exit
18:30:10 * RyanT5000 glares at Oblivion
18:39:01 <araujo> Hello!
18:39:53 <RyanT5000> hey :)
18:56:36 <dons> sjanssen, petekaz, I just added group and groupBy to the fps darcs repo. cheers.
18:56:49 <araujo> dons, hiya!
18:57:10 <dons> also, the group I comitted is specialised, and runs about faster than groupBy ==
18:57:30 <dons> morning araujo 
18:57:53 <araujo> morning dons , how you doing?
18:58:04 <dons> about 40% faster.
18:58:11 <dons> good araujo . need some coffee though.
18:59:31 * Lemmih should finish his darn email and go to sleep.
19:00:09 <araujo> dons, :-)
19:02:18 <palomer> so there's quickcheck the program and quickcheck the library, right?
19:02:44 <stepcut> has ghc been ported to the arm ?
19:03:22 <palomer> what's the best way to learn how to use the quickcheck module?
19:03:51 <sjanssen_> dons: nice
19:04:36 * sjanssen_ run's darcs pull
19:11:19 <dons> palomer, hmm  have a look at an existing setup?
19:11:49 <dons> e.g. http://www.cse.unsw.edu.au/~dons/code/fps/tests/Quick.hs
19:12:42 <palomer> btw, how do I deal with coarbitrary?
19:14:48 <palomer> that's a pretty involved setup
19:17:02 <dons> it tests all of Data.ByteString, in such a way that I can quickly diff the results.
19:17:19 <dons> all you really care about is the properties, though, I suspect.
19:17:29 <dons> the driver details can be accomplisedh in a single line.
19:18:33 <dons> sjanssen_: does the new group code work on your test program?
19:19:59 <sjanssen_> dons: yes
19:20:12 <dons> any faster? 
19:20:28 <sjanssen_> apparently 'j' is only mentioned 3,075 times in my dictionary
19:20:48 <dons> also, can you post the code to me? i'll stick it in my test programs suite
19:20:50 <sjanssen_> dons: a bit
19:21:30 <dons> group is still fairly inefficient, I think. it could be improved in a number of ways
19:21:33 <sjanssen_> what's the most convenient way for it to work?  hardcode /usr/share/dict/words?  stdin?
19:21:36 <sjanssen_> or does it matter?
19:21:49 <dons> I have a Usr.Dict.Words file in the testsuiste already. so stdin is best.
19:22:02 <dons> or hardcode. no big deal.
19:23:30 <palomer> should I bother specifying coarbitrary?
19:23:46 <dons> only if you need to generate random functions, i think
19:23:53 <dons> as opposed to random data 
19:24:05 <dons> (the details are in the QC papers on the wiki)
19:28:05 <palomer> hrmph
19:29:51 <palomer> anyone have any example of creating arbitrary recursively defined datatype values?
19:30:11 <palomer> like random trees and such
19:32:35 <palomer> ah, use sized
19:32:36 <palomer> got it
19:34:32 <palomer> sized will only give me symmetric trees
19:34:34 <palomer> hrmph
19:37:40 <palomer> figured it out
19:37:42 <palomer> woot
19:43:02 <sjanssen_> lisppaste2: url
19:43:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:44:33 <lisppaste2> sjanssen pasted "for dons" at http://paste.lisp.org/display/19562
19:45:21 <dons> cheers
19:47:45 <newsham> ?fact lisppaste2
19:47:45 <lambdabot> I know nothing about lisppaste2
19:48:22 <sjanssen_> > groupBy (/=) [1, 2, 3]
19:48:23 <lambdabot> [[1,2,3]]
19:48:45 <sjanssen_> dons: bytestring's groupBy will loop forever on that
19:49:21 <sjanssen_> if you don't want to fix that, I'll take a look at it later
19:49:43 <dons> hmm
19:50:02 <sjanssen_> Data.List.groupBy always admits it's first element
19:50:16 <dons> ./sjanssen < /usr/share/dict/words  0.91s user 0.03s system 97% cpu 0.967 total
19:50:20 <dons> :)
19:50:51 <dons> sjanssen_: ah. right. yes, needs to be fixed.
19:51:29 <sethk> dons, I discovered something interesting, which you probably already know but I didn't.  If I do a ioError (userError "whatever") in a function where I'm using a socket, the socket is closed.
19:52:08 <dons> huh. didn't know that.
19:52:53 <sethk> dons, I have to read the rest of that tutorial you pointed me at a couple of days ago.
19:53:15 <dons> the awkward squad?
19:53:28 <sethk> right.  then maybe the socket closing will make sense to me.
19:53:35 <palomer> how do I turn an Arbitrary a => a -> Testable c into a Testable?
19:53:51 <palomer> oh wait, it's automatic
19:53:52 <palomer> sweet
19:53:57 <dons> sjanssen_: hmm. this is pretty fast. I'm pleased. ./sjanssen < 20M  6.29s user 0.20s system 86% cpu 7.492 total
19:54:38 <dons> seems to scale nicely: ./sjanssen < 50M2  11.95s user 0.40s system 84% cpu 14.588 total
19:54:47 <sethk> dons, I have another problem I'm working on, but it's a logic problem, not a haskell problem.  If you don't mind I might send you an email to see if you have any ideas about it.
19:55:00 <dons> yes, that's a good idea.
19:55:09 <dons> I find email better for thinking through tricksy problems
19:55:12 <sethk> dons, I have a solution, but it's ugly and I think there must be a less ugly solution.
19:55:16 <sethk> dons, thanks.
19:56:08 <dons> the curse of the haskell programmer: they always think there's a less ugly solution
19:58:00 <dons> sjanssen_: yeah, I spot that issue in the QuickChecks now.
19:58:33 <palomer>       Expected type: bool
19:58:33 <palomer>       Inferred type: Bool
19:58:38 <palomer> how is this even possible?
19:58:59 <dons> isn't bool an internal thingy in QC?
19:59:07 <dons> iirc
19:59:21 <palomer> but, erm, type variables have to begin with a capital letter, no?
19:59:30 <palomer> err, type names
19:59:42 <dons> its a tyvar
20:00:09 <dons> hmm. no, can't seem to find it.
20:00:14 <dons> maybe you've got a typo somewhere?
20:00:36 <dons> 'prop' was what I was thinking of, I suspect
20:00:49 <dons> (==>)         -- :: Bool -> prop -> prop
20:03:41 <dons> morning Lemmih :)
20:05:07 * araujo finishing proposal
20:05:42 <Lemmih> morning, dons.
20:06:30 * Lemmih heads to bed once again.
20:07:12 <araujo> Lemmih, can't sleep?
20:12:00 <palomer> whew
20:12:02 <palomer> quickcheck is cool
20:12:11 <palomer> is it possible to ask it to print out the testcases its tried out?
20:12:26 <palomer> (instead of ^H0^H1...
20:13:05 <dons> ?karma+ QuickCheck
20:13:05 <lambdabot> QuickCheck's karma raised to 4.
20:13:14 <dons> palomer, yeah, take the test harness rig from fps
20:13:32 <dons> with lots of tests, that's the only way to track down errors quickly
20:13:41 <dons> it prints out:
20:13:48 <dons> foldl          : OK, 100 tests.
20:13:48 <dons> foldr          : OK, 100 tests.
20:13:49 <dons> ..
20:15:52 <palomer> but, like, I want the test cases, not the test functions
20:16:02 <dons> ah, the actual strings?
20:16:05 <dons> add debug.
20:16:14 <dons> gimme sec.
20:17:12 <dons> to the TestOptions, you add  debug_tests =True
20:17:30 <palomer> ahh, thx
20:17:46 <dons> be warned. expect lots of output :)
20:17:47 <palomer> and is it possible to use other arbitrary functions?
20:18:32 <dons> what do you mean?
20:18:40 <palomer> I have a datatype Foo
20:18:47 <palomer> and I want to test a function bar
20:18:57 <palomer> Foo is generated by strings
20:19:16 <palomer> and I want two functions to generate arbitrary Foo
20:19:28 <palomer> each with exclusive string pool
20:20:04 <palomer> since my function bar assumes that the inputs are exclusively generated
20:22:08 <dons> you only get to write one arbitrary instance, but you could have prop_bar1 (x::Foo) (y::Foo) = ... perhaps ?
20:22:34 <dons> or you could newtype, and get two aribtrary instances?
20:22:45 <palomer> yeah, that's what I'll have to end up doing
20:22:52 <dons> so distinguish your separate pools on the type level
21:14:06 <dons> ?uptime
21:14:07 <lambdabot> uptime: 20 hours, 49 minutes and 39 seconds
21:14:12 <dons> ?version
21:14:12 <lambdabot> lambdabot 3p427, GHC 6.4.1 (Linux i686 3.20GHz)
21:14:12 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:15:03 <palomer> > v
21:15:04 <lambdabot>  Not in scope: `v'
21:15:09 <dons> v !!
21:15:20 <dons> I think we need a 'v' command that behaves like 'v', no?
21:15:34 <dons> @v
21:15:35 <lambdabot> Maybe you meant: vera version vixen vote .
21:15:39 <dons> <<loop>> or something
21:15:39 <palomer> agreed
21:15:45 <palomer> dons: what does your name mean?
21:15:49 <dons> dons?
21:15:51 <palomer> yes
21:15:55 <dons> DonStewart
21:16:10 <dons> ?google Don Stewart site:unsw.edu.au
21:16:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/
21:16:12 <palomer> you know it's an old pejorative term for a spaniard, right?
21:16:14 <dons> that's me!
21:16:37 <dons> oh, I've not heard that before.
21:17:20 <palomer> it was used by the english in the 17th century, I believe
21:17:26 <dons> there you go.
21:17:30 <palomer> I need not elucidate you on its origins
21:20:13 * monochrom has built gtk2hs and tried the "hello" demo :)
21:20:29 * araujo thinks dons got email
21:20:53 <palomer> weird, I haven't been getting much spam lately
21:22:33 * araujo can't sleep
21:22:41 <araujo> palomer, weird... me neither
21:22:44 <araujo> what is happening?
21:22:47 <dons> araujo: yep.
21:23:19 <araujo> i am probably not popular anymore
21:24:16 * Pseudonym shuns araujo
21:25:10 <araujo> :-(
21:25:45 * araujo gets more anti-depressive tea 
21:31:16 <sjanssen> dons: regarding @v, I actually wrote one and forgot about it
21:31:20 <sjanssen> I shall send the patch
21:33:56 <dons> ah! good good.
21:35:38 <sjanssen> sent
21:36:18 <dons> recv
21:51:58 <pitarou> Konnichiwa!
21:52:23 <pitarou> Quiet in here, isn't it?
21:53:14 * pitarou does a strip tease, in a desperate attempt to get somebody's attention.
21:54:56 <Korollary> @vixen
21:54:56 <lambdabot> what's the last book you read?
21:55:09 <pitarou> Huh?
21:55:15 <sjanssen> @. elite arr
21:55:16 <lambdabot> kEELHau1 +hE 5wabs!
21:56:02 <pitarou> @. elite vixen
21:56:03 <lambdabot> hA\/e u 3\/ER 5CU84diVED?
21:56:27 <pitarou> OIC.  Hello, folks.
21:56:40 <pitarou> @help
21:56:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:56:47 <pitarou> @list
21:56:48 <lambdabot> list [module|command]. Where modules is one of:
21:56:48 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
21:56:48 <lambdabot> version vixen where
21:56:57 <sjanssen> @id /me waves
21:56:58 * lambdabot waves
21:57:18 <Pseudonym> @id /msg #haskell Hello
21:57:18 <lambdabot> /msg #haskell Hello
21:57:37 <Pseudonym> @id ?id
21:57:37 <lambdabot> ?id
21:57:41 <dons> @id /me <- robot
21:57:41 * lambdabot <- robot
21:58:14 <pitarou> @id msg #haskell @id recursion
21:58:15 <lambdabot> msg #haskell @id recursion
21:58:24 <pitarou> @id /msg #haskell @id recursion
21:58:25 <lambdabot> /msg #haskell @id recursion
21:58:41 <dons> @id @id foo foo
21:58:41 <lambdabot>  @id foo foo
21:58:44 <Pseudonym> @id ?msg lambdabot ?quit
21:58:45 <lambdabot> ?msg lambdabot ?quit
21:58:45 <dons> no dice
21:58:57 <dons> ignores its own messages, iirc
21:59:02 <Pseudonym> Damn.
21:59:12 <pitarou> And it escapes slashes.
21:59:15 <dons> otherwise it would have been loopy a long time ago
21:59:35 <dons> and esacepes @, yeah.
22:00:22 <pitarou> @list
22:00:23 <lambdabot> list [module|command]. Where modules is one of:
22:00:23 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
22:00:23 <lambdabot> version vixen where
22:00:34 <pitarou> @help vixen
22:00:34 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
22:00:42 <pitarou> @help where
22:00:43 <lambdabot> where <key>. Return element associated with key
22:01:11 <pitarou> @help karma
22:01:12 <lambdabot> karma <nick>. Return a person's karma value
22:01:28 <pitarou> @karma pitarou
22:01:29 <lambdabot> You have a karma of 0
22:01:34 <pitarou> @karma shapr
22:01:34 <lambdabot> shapr has a karma of 16
22:01:44 <pitarou> @help dice
22:01:44 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
22:01:56 <pitarou> @dice 1412d423432
22:01:56 <lambdabot> 1412d423432 => 0
22:02:04 <Korollary> @pl \t r -> return $ ((null answer) == t) : r
22:02:05 <lambdabot> (return .) . (:) . (null answer ==)
22:02:07 <pitarou> Overflow!  Overflow!
22:02:18 <pitarou> @help pl
22:02:19 <lambdabot> pointless <expr>. Play with pointfree code.
22:02:31 <Pegazus> hi, does anyone knows where to get some help or info or tutorial about pcf language? and another thing, when haskell is compiled into c by ghc, does anyone knows how the "data structures" are represented? like Data Nat = Z | Suc Nat how is that represented?
22:02:56 <dons> pitarou: nop.e it truncates to zero dice above 1000, iirc.
22:03:03 <dons> to save stack space
22:03:18 <dons> since lambdabot knows anyone throwing that many dice is just jerking her around
22:04:36 <Korollary> Pegazus: Are you familiar with typed lambda calculi?
22:05:33 <Pegazus> emmm
22:05:37 <Pegazus> familiar not
22:05:40 <Pegazus> but i know a little...
22:06:07 <Pegazus> (i'm learning PCF / typed lambda calculi)
22:07:08 <Korollary> Do you have Types and Programming Languages?
22:07:22 <Pegazus> what's that?
22:07:30 <Korollary> Type theory textbook
22:07:46 <Pegazus> nope
22:08:21 <Korollary> I'm currently stuyding typed LC from that book
22:08:36 <Korollary> PCF is briefly mentioned
22:09:07 <Pegazus> ammm
22:09:07 -angLia(n=angLia@tor/session/external/x-91044492e4520215)- ATTENTION EVERYONE: http://yep.it/?at2whw
22:09:08 <Pegazus> oks
22:09:12 -angLia(n=angLia@tor/session/external/x-91044492e4520215)- ATTENTION EVERYONE: http://yep.it/?at2whw
22:09:18 <araujo> angLia is spam
22:09:46 <sjanssen> @karma- angLia
22:09:47 <lambdabot> angLia's karma lowered to -1.
22:09:49 <Korollary> hah
22:09:58 <Korollary> @ignore angLia
22:09:58 <lambdabot> Unknown command, try @list
22:11:18 -angLia(n=angLia@tor/session/external/x-91044492e4520215)- ATTENTION EVERYONE: http://yep.it/?at2whw
22:11:42 --- mode: ChanServ set +o dons
22:11:56 -angLia(n=angLia@tor/session/external/x-91044492e4520215)- ATTENTION EVERYONE: http://yep.it/?at2whw
22:12:05 <Korollary> Pegazus: Regarding ghc's internals, you'll need to read the papers here: http://hackage.haskell.org/trac/ghc/wiki/GhcPapers
22:12:14 --- mode: dons set +b *!*n=angLia@tor/session/external/x-91044492e4520215
22:12:14 --- kick: angLia was kicked by dons (dons)
22:12:26 <araujo> @yarr!
22:12:27 <lambdabot> I'll keel haul ya fer that!
22:12:30 <pitarou_> Sorry for disappearing like that.  Laptop crash.
22:12:37 <dons> too many spammers these days.
22:12:46 <pitarou_> @list
22:12:46 <lambdabot> list [module|command]. Where modules is one of:
22:12:46 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
22:12:46 <lambdabot> version vixen where
22:13:02 <pitarou_> @help base
22:13:03 <lambdabot> base is a module.
22:13:16 <pitarou_> What kind of module?
22:13:32 <pitarou_> @base all = belong to us
22:13:33 <lambdabot> Maybe you meant: babel last paste
22:13:57 <pitarou_> @babel help
22:13:58 <lambdabot>  usage: babel lang lang phrase
22:14:07 <pitarou_> @help fact
22:14:07 <lambdabot> fact <fact>, Retrieve a fact from the database
22:14:18 <pitarou_> @help localtime
22:14:19 <lambdabot> time <user>. Print a user's local time. User's client must support ctcp pings.
22:14:28 <pitarou_> @time pitarou
22:14:44 <pitarou_> @time araujo
22:14:46 <lambdabot> Local time for araujo is Mon May  1 01:13:18
22:14:52 <pitarou_> @time dons
22:14:54 <lambdabot> Local time for dons is Mon May  1 15:16:03 2006
22:15:10 <pitarou_> @help plugs
22:15:11 <araujo> yay, i should be sleeping
22:15:11 <lambdabot> plugs provides: eval
22:15:22 <pitarou_> @help state
22:15:22 <lambdabot> state [expr]. Get or set a state variable.
22:15:24 <pitarou_> @list
22:15:25 <lambdabot> list [module|command]. Where modules is one of:
22:15:25 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
22:15:25 <lambdabot> version vixen where
22:15:44 <pitarou_> @help log
22:15:44 <lambdabot> log provides: last log-email
22:15:54 <pitarou_> @help more
22:15:54 <lambdabot>  @more. Return more output from the bot buffer.
22:16:09 <pitarou_> @help pretty
22:16:10 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
22:16:17 <pitarou_> @help slap
22:16:18 <lambdabot> slap <nick>. Slap someone amusingly.
22:16:24 <pitarou_> @slap lambdabot
22:16:25 * lambdabot slaps lambdabot
22:16:30 <sjanssen> I didn't know we have a pretty printer!
22:16:32 <Korollary> That's very amusing.
22:16:39 <pitarou_> @slap Korollary
22:16:40 * lambdabot smacks Korollary about with a large trout
22:16:42 <sjanssen> @pretty (1) + 2
22:16:43 <lambdabot> "Parse error" at column 8
22:16:47 <araujo> sjanssen, we do!
22:17:03 <sjanssen> @pretty x = 1 + 2
22:17:04 <lambdabot>  x = 1 + 2
22:17:11 <sjanssen> @pretty x = (1) + 2
22:17:11 <lambdabot>  x = (1) + 2
22:17:17 <pitarou_> Hello,　everyone.  My name is Peter and I'm a Haskellholic.
22:17:24 <Korollary> interesting. x = 1 is not an expression per se.
22:17:42 <araujo> mmm.. not a valid one
22:17:50 <sjanssen> so it takes toplevel statements?
22:17:57 <dons> it takes decls
22:17:59 <dons> not exprs
22:18:09 <Korollary> @pretty do s <- getLine; putStrLn s
22:18:10 <lambdabot> "Parse error" at column 28
22:18:13 <Korollary> oink
22:18:15 <araujo> @pretty 2 + 3
22:18:15 <lambdabot> "Parse error" at column 6
22:18:17 <dons> @pretty f x = let {x y = y;} in x
22:18:18 <lambdabot>  f x = let x y = y in x
22:18:26 <Korollary> @pretty do { s <- getLine; putStrLn s}
22:18:26 <lambdabot> "Parse error" at column 31
22:18:29 <araujo> @pretty f = x = 2 + 3
22:18:30 <lambdabot> "Parse error" at column 7
22:18:38 <dons> you crazy haskell people
22:18:40 <Korollary> @pretty do { s <- getLine; putStrLn s; }
22:18:41 <lambdabot> "Parse error" at column 33
22:18:44 <Korollary> blah
22:18:47 <araujo> @pretty f = 2 + 3 + f
22:18:48 <lambdabot>  f = 2 + 3 + f
22:19:03 <dons> @pretty f x = do s <- getLine ; putStrLn x
22:19:04 <lambdabot>  f x  = do s <- getLine
22:19:04 <lambdabot>     putStrLn x
22:19:16 <dons> well, not so pretty since i munged the space-hack code.
22:19:21 <araujo> hah
22:19:22 <dons> but, you get the idea
22:19:22 <Korollary> I see
22:19:33 <Korollary> why two spaces before the = ?
22:19:42 <dons> no idea. that's a bit weird.
22:19:48 <araujo> @pretty f x = getLine >>= putStrLn
22:19:49 <lambdabot>  f x = getLine >>= putStrLn
22:19:51 <dons> ah, maybe it's a tab that's been spaceified
22:19:52 <pitarou_> @version
22:19:52 <lambdabot> lambdabot 3p427, GHC 6.4.1 (Linux i686 3.20GHz)
22:19:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:20:20 <Korollary> dons: I've met an unsw alumni from work.
22:20:34 <dons> oh yes? from cse? or some other faculty?
22:20:54 <Korollary> cse
22:21:28 <dons> who is it? someone I might know? or before my time.
22:21:30 <Korollary> I haven't had the opportunity to ask whether he knows the infamous Don S, tho
22:21:37 <sjanssen> @. pretty . pl djinn (a, b) -> (b -> c) -> d -> (a -> e) -> (a, e, b, d)
22:21:37 <pitarou_> @help poll
22:21:38 <lambdabot>  f = uncurry
22:21:38 <lambdabot>    (((const . flip) .) . flip . liftM2 (.) (,,,) (flip id))
22:21:38 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
22:21:53 <pitarou_> @poll-list
22:21:54 <lambdabot> []
22:22:08 <dons> sjanssen: nice.
22:22:28 <sjanssen> pretty-printed pointfree programs derived from types
22:22:34 <pitarou_> Very nice.
22:22:49 <dons> ?hylo f x = x
22:22:50 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
22:22:50 <lambdabot>  where g (x) = x
22:22:50 <lambdabot>    h x = (x)
22:22:50 <pitarou_> But wtf is (,,,)?
22:22:59 <dons> an alternative pointfree generator
22:23:09 <sjanssen> > (,,,,) 1 2 3 4
22:23:10 <lambdabot> Add a type signature
22:23:11 <dons> pitarou_: the 4-tuple constructor
22:23:15 <dons> (,,,) 1 2 3 4
22:23:55 <pitarou_> > (,,,,) 1 2 3 (4::Integer)
22:23:56 <lambdabot> Add a type signature
22:24:04 <sjanssen> > (,,,) 1 2 3 4
22:24:05 <lambdabot> (1,2,3,4)
22:24:13 <sjanssen> pitarou_: I typed to many commas
22:24:18 <pitarou_> > (,,,,) 1 2 3 4 :: (Integer, Integer, Integer, Integer)
22:24:19 <lambdabot> Couldn't match `(Integer, Integer, Integer, Integer)' against `t -> t1'
22:24:27 <pitarou_> > (,,,) 1 2 3 4 :: (Integer, Integer, Integer, Integer)
22:24:29 <lambdabot> (1,2,3,4)
22:24:54 <pitarou_> I see.  Thanks.  Is that part of the Haskell 98 Standard?
22:25:01 <sjanssen> yes
22:25:03 <dons> sure.
22:25:23 <dons> > 1:[] :: [] Int -- even works on the type level
22:25:25 <lambdabot> [1]
22:25:50 <dons> > (,) 1 2 :: (,) Int Int -- hmm, I wonder
22:25:51 <lambdabot> (1,2)
22:25:57 <dons> yes.
22:26:06 <dons> obfuscation, onwards!
22:26:39 <araujo> we should have our own Haskell obfuscated contest :-)
22:26:50 <pitarou_> OIC.  So (1, 2) is syntactic sugar for (,) 1 2.  Now I get it.
22:26:52 <dons> the S S Z'th contest
22:26:55 <dons> ?wiki Obfuscation
22:26:56 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
22:27:23 <dons> pitarou_: right, like all other kinds of applciation, for types, funs, and constructors
22:27:49 <araujo> dons, nice
22:28:22 <araujo> @type (,,,)
22:28:23 <lambdabot> forall d c b a. a -> b -> c -> d -> (a, b, c, d)
22:28:30 <lambdabot> Haskell Weekly News for May 1 out now: http://sequence.complete.org/
22:28:33 <sjanssen> @kind (,,,)
22:28:34 <lambdabot> * -> * -> * -> * -> *
22:28:54 * araujo checks what's new
22:32:29 <pitarou_> Ooh look!  More type-hackery from Oleg.
22:33:40 <sjanssen> pitarou_: I'm more surprised when HWN *doesn't* have type-hackery from Oleg
22:33:50 <pitarou_> hehe
22:34:08 <araujo> that hackathon thing looks nice
22:35:07 <lumi> Hi, I'm getting some flavour of weird ghc error
22:35:21 <sjanssen> araujo: yeah.  A long talk by the Simon's on GHC internals would be very interesting, IMO
22:35:34 <araujo> sjanssen, yes, i think so too
22:35:42 <dons> sometimes ndm scares me: "Hopefully, one day everyone will see the light and stop using Linux, move to Windows"
22:35:44 <pitarou_> As far as I can tell, Oleg looks like he's trying to reimplement XSLT in Haskell's type system.
22:35:58 <pierre-> //join #debian-russian
22:36:17 <monochrom> heh //
22:36:20 <lumi> It's asking me to report it as a compiler bug, I don't understand it well enough to know whether it's already in the tracker..
22:36:34 <araujo> sjanssen, they also probably could come up with some nice videos?
22:36:38 <monochrom> Is // russian for / ?  XD
22:36:38 <sjanssen> lumi: is the code small enough to paste
22:36:49 <araujo> For those who can't go to the event :-)
22:36:51 <sjanssen> araujo: that would be excellent!
22:36:58 <lumi> It's not even code, I got it once running ghci with no parameters
22:37:08 <lumi> ghc-6.4.2: internal error: scavenge_stack: weird activation record found on stack: 454
22:37:19 <dons> definitely a bug!
22:37:22 <lumi> But it seems to sometimes not happen
22:37:34 <dons> you need to make it reproducible somehow.
22:37:49 <dons> and especially details abotu the os you're using, how you built ghc and so on.
22:37:59 <dons> and anything weird about your system (like funny gcc version?)
22:38:59 <akemp> @seen dons
22:39:00 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 minute ago.
22:39:17 <akemp> @seen SyntaxNinja
22:39:18 <lambdabot> I saw SyntaxNinja leaving #haskell 3 hours and 31 minutes ago, and .
22:39:32 <lumi> MacOS X 10.4.5, gcc-4.0.0 (Apple-flavoured), anything else?
22:39:35 <lumi> "and ."?
22:40:21 <monochrom> I want orange-flavoured ice-cream :P
22:40:23 <dons> akemp, morning
22:40:45 <lumi> Ah, now I'm just getting a segfault. Super.
22:41:33 <lumi> I'm very confused by this: I'm doing the same thing (run ghci) and it randomly segfaults or gives that error
22:41:34 <dons> lumi, sounds like something broke in the ghc you're using. probably best to ask on glasgow-haskell-bugs@ for more insight from the mac guys
22:42:35 <araujo> lumi, i would try with other gcc version 
22:42:54 <lumi> You mean, rebuild ghc? With 3.3?
22:43:20 <araujo> or 3.4 
22:43:35 <araujo> If it isn't too much of a problem, you could give it a try.
22:45:02 <lumi> I dunno, is it more helpful to uncover what's happening? Would it very probably work the other way?
22:45:26 <lumi> Just that ghc takes half a day to build
22:45:36 <dons> you're using a ghc from haskell.org/ghc ?
22:45:42 <lumi> From ports
22:46:54 <araujo> mm.. that's the new ghc addition to darwings?
22:47:00 <araujo> darwins*
22:47:26 <lumi> New?
22:48:06 <araujo> yea, i thought they added a new version recently
22:48:12 <pitarou_> Wow!  What a cool list of Summer of Code projects.
22:49:22 <gzl> where?
22:49:56 <lumi> Well, it's 6.4.2
22:50:06 <araujo> @where SoC
22:50:07 <lambdabot> I know nothing about soc.
22:50:23 <pitarou_> http://hackage.haskell.org/trac/summer-of-code/
22:51:12 <dons> @where+ SoC http://hackage.haskell.org/trac/summer-of-code/
22:51:13 <lambdabot> Done.
22:51:56 * pitarou_ likes the look of the Jabber project.
23:01:41 * pitarou departs, in search of his dinner.
23:01:43 <pitarou> TTFN
23:11:12 <dons> hehehe. Data.ByteString gets a logo : http://www.cse.unsw.edu.au/~dons/fps.html
23:11:51 <dons> a 2cent logo, but still, that's a logo
23:11:53 <Cale> :)
23:12:24 <dons> since, as my father always says, red goes faster.
23:23:28 <kosmikus> good morning
23:41:01 <palomer> can't sleep
23:41:01 <palomer> ugh
23:41:05 <palomer> someone entertain me
23:43:48 <dons> ?slap palomer
23:43:49 * lambdabot slaps palomer
23:44:31 <palomer> I'm thinking of leaving my university
23:44:45 <dons> hmm :/
23:44:45 <palomer> dons: any space where you're at?
23:45:31 <dons> not till next year. our group is spread around the planet this year. (my supervisor's in NY for the year)
23:46:15 <dons> maybe you should apply for a SoC project?
23:46:31 <palomer> If I do, it'll be to incorporate my type system into ghc
23:46:58 <palomer> or, rather, my GADT type inference system into ghc
23:47:03 <dons> huh. big job..
23:47:27 <dons> sjanssen: doe the QC tests pass now?
23:47:46 * dons applies the patch anyway.
23:47:46 <palomer> however, I haven't proved type preservation nor progress, nor inference completeness and soundness
23:47:52 <palomer> not that I really care
23:48:06 <palomer> (all obviously true except the third one)
23:48:12 <palomer> to me anyways
23:48:28 <dons> proofs are good to convince other people that things work :)
23:48:49 <kosmikus> dons: oh, Manuel is in NY?
23:48:55 <palomer> yes, but to do these things would take much time
23:49:01 <palomer> and the deadline is approaching
23:49:19 <dons> yeah. Gabi's working in NYC for the year, so Manuel's writing papers and hacking on ATs
23:49:23 <palomer> all I can show for my work is an implementation and a paper describing the method
23:49:56 <Cale> palomer: did you do anything about the "there are no principal types for GADT programs" problem?
23:50:17 <kosmikus> dons: ok, thanks for the info. I'll try to keep the different timezone in mind ...
23:50:24 <dons> :)
23:50:35 <palomer> Cale: there aren't any principle types for my type inference system, either
23:50:45 <palomer> but there's a very good reason for not having principle types
23:50:58 <palomer> it's because GADTs and intersection types are very much related
23:51:25 <palomer> in fact, I can reduce GADT inference to inference with intersection types
23:51:27 <sjanssen> dons: does no output from "runghc Tests.hs" mean it's succeeded?
23:51:50 <palomer> so you end up trying to inject a type system with intersection into a type system without
23:51:55 <palomer> so you lose principle types
23:52:04 <dons> sjanssen: nope. :S try runghc Quick.hs
23:52:12 <dons> or try 'gmake' to get the full set of tests and benchmarks
23:52:13 <Cale> oh, I just realised something. I think I know why they're called principal types. :)
23:52:25 <palomer> Cale: you didn't?
23:52:48 <dons> group          : OK, 100 tests.
23:52:48 <dons> groupBy        : OK, 100 tests.
23:52:48 <dons> groupBy1       : OK, 100 tests.
23:52:49 <Cale> No, I don't think I've even read a proper definition of that term :)
23:52:53 <dons> sjanssen: :)
23:52:56 <dons> ?karma+ sjanssen 
23:52:57 <lambdabot> sjanssen's karma raised to 4.
23:53:02 <kosmikus> palomer: what about http://research.microsoft.com/~simonpj/papers/gadt/index.htm
23:53:09 <Cale> (but I have gleaned from context in a number of places what it means)
23:53:39 <palomer> kosmikus: they describe a method for finding a type, nothing more. the method isn't complete and, to me, unintuitive
23:54:20 <sjanssen> dons: when I get "83% False.\n17%True." does that mean there is an error?
23:54:33 <dons> that's just showing the distribution for a boolean test
23:54:44 <palomer> a term a has a principal type tau if the following statement is true: if sigma is a type of a, then you can instantiate tau to sigma
23:54:46 <dons> as long as the test itself isn't 'Falsifiable'
23:55:12 <Cale> palomer: I figured that
23:55:20 <dons> sjanssen: i'll build ghc 6.6 with the patch and see if the testsuite passes.
23:55:29 <palomer> you can also look at it another way:
23:55:50 <Cale> palomer: Am I right in assuming that the terminology comes from order ideals?
23:56:01 * dons gets a pleasant feeling when ghc takes around 30 seconds to compile ByteString -- you know that code must be doing something good.
23:56:02 <palomer> a type tau is said to subsume sigma, written tau <= sigma, if there exists a substitution theta such that theta[tau]=sigma
23:56:32 <palomer> let types(t) = {tau | tau types t}
23:56:37 <Cale> Basically, the principal type is the principal element of the order ideal of types for the term.
23:56:43 <palomer> if types(t) contains its own maximum, then its principally typed
23:56:48 <Cale> (under subsumption)
23:56:56 <palomer> order ideals?
23:56:57 <Cale> yes
23:57:01 <palomer> ideal as in a ring ideal?
23:57:12 <Cale> similar -- sort of a generalisation of that
23:57:15 <Cale> http://en.wikipedia.org/wiki/Order_ideal
23:57:39 <palomer> man, I wish I could simply publish my ideas without proving them
23:57:44 <palomer> the proofs are going to be quite hard
23:58:20 <Cale> It would be interesting to know that the valid types for a term really do form an ideal.
23:58:21 <sjanssen> palomer: how do you know your ideas are useful if they aren't proven?
23:58:42 <palomer> useful or true?
23:58:43 <Cale> (the lower set bit is easy, I'm not sure how to know that it will be a directed set)
23:59:17 <dons> sjanssen: looks good. ghc testsuite passes. i've checked in the patch. thanks.
23:59:41 <palomer> directed set?
