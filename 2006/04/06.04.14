00:01:07 <RyanT5000> ct16k: start by breaking up your program into multiple functions
00:01:15 <RyanT5000> then test each function
00:01:51 <ct16k> k
00:01:53 <RyanT5000> is it failing to compile or failing to work?
00:01:57 <RyanT5000> i should've asked that first
00:02:01 <ct16k> to compile
00:02:11 <ct16k> i get an error at ys<-ys++readSort
00:02:25 <ct16k> "Syntax error in expression (unexpected `<-')"
00:02:26 <Lemmih> metaperl: You're saying people aren't responding when no question is asked?
00:02:58 <RyanT5000> alright i think i know why: it expects the right-hand-side of <- to be an IO a, where a is the type of the left-hand-side
00:03:04 <metaperl> even with a well-titled post from paste.lisp.org/new/haskell, I have found that I get no response... even shapr agrees that pastes there are likely to be ignored
00:03:12 <RyanT5000> i don't think you can use <- to assign simple results; they have to be in-monad
00:03:24 <RyanT5000> but of course all of this begs the question why your function is in the IO monad at all
00:03:42 <araujo> metaperl, you might get no response if nobody knows the problem atm
00:04:02 <araujo> my experience has been totally different
00:04:05 <ct16k> well, i come form the world of ASM&C, so when it came to trying a little imperative programming in Haskell....
00:04:22 <Lemmih> metaperl: Well, yes of course. Asking a bad question gives you a bad answer at best, asking no question most likely gives you no answer.
00:04:48 <RyanT5000> ct16k: you should try to atone :) that's what i've been doing for the last week and a half
00:04:54 <RyanT5000> (since i learned haskell)
00:09:24 <RyanT5000> here's how i'd do it:
00:09:24 <Lemmih> metaperl: (a title is somewhere between a bad question and no question. imo)
00:09:24 <ct16k> well, i broke it down
00:09:24 <RyanT5000> er, lemme think a second
00:09:24 <ct16k> to just the reading part
00:09:24 <RyanT5000> i don't want to hand you something like readSort = sort . read
00:09:24 <lisppaste2> ct16k annotated #18977 with "Last generator in do {...} must be an expression" at http://paste.lisp.org/display/18977#1
00:09:24 <Cale> ct16k: that's usually caused by layout
00:09:24 <RyanT5000> also, you can just write your function like this:
00:09:24 <Cale> it just means that the last line in a do expression can't look like  x <- ...
00:09:24 <Lemmih> ct16k: You have to do: do line <- getLine; let xs = words (read line); ...
00:09:24 <RyanT5000> readStrs = words (read getLine)
00:09:24 <Cale> since that binding wouldn't be used anyway
00:09:24 <RyanT5000> er
00:09:24 <RyanT5000> my bad
00:09:24 <araujo> RyanT5000, :-/
00:09:24 <ct16k> the last line in my do is return (xs)
00:09:24 <RyanT5000> (sorry, newb helping newb is asking for trouble :P)
00:09:24 <araujo> getLine >>= return . words
00:09:24 <Cale> ct16k: then check that the indentation is sane -- ah just got it
00:09:24 <Cale> indent the  return xs  so that it aligns with the start of xs <- ..
00:09:34 <Cale> or just delete the return xs, and the "xs <-"
00:09:51 <RyanT5000> @hoogle sort
00:09:52 <lambdabot> List.sort :: Ord a => [a] -> [a]
00:09:52 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
00:09:52 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
00:09:56 <ct16k> and leav it just readStrs = do words (read getLine)?
00:09:58 <Cale> however, you'll still have a type error
00:10:05 <Cale> getLine is an action
00:10:10 <Cale> and read takes a string
00:10:31 <ct16k> read getLine is something found on google
00:10:32 <Cale> yeah, except that's wrong too :)
00:10:41 <ct16k> seemed to work in that example
00:10:46 <Cale> readStrs = do xs <- getLine; return (words xs)
00:11:03 <Cale> @type read getLine
00:11:05 <lambdabot>   Couldn't match `String' against `IO String'
00:11:05 <lambdabot>   Expected type: String
00:11:14 <int-e> @type fmap read getLine
00:11:15 <lambdabot> forall a. (Read a) => IO a
00:11:32 <Cale> getLine is an action
00:11:39 <Cale> read wants a string
00:12:21 <araujo> @type liftM words getLine
00:12:22 <lambdabot> IO [String]
00:13:21 <Pegazus> if i have addPRF_test = addPRF_test_1 & addPRF_test_2 & addPRF_test_3 how can i continue on the next line?
00:13:41 <ct16k> readStrs works seems to work that way, but there's no output. shouldn't the list be printed on the screen? (i haven't understood much of this chapter, obviously)
00:14:46 <RyanT5000> readSort = getLine >>= return . sort . Prelude.map read . words
00:14:49 <Cale> ct16k: well, that's probably just the behaviour of ghci or hugs
00:14:59 <RyanT5000> (i had other "map"s in scope)
00:15:03 <Cale> you can make it print the result of the action with print
00:15:10 <int-e> try: do x <- readStrs; print x  (or, shorter,  readStrs >>= x)
00:15:11 <newsham> we're not done peg's homework yet?
00:15:16 <Cale> readStrs >>= print
00:15:20 <int-e> sorry
00:15:23 <Cale> and see what you get :)
00:15:24 <int-e> readStrs >>= print
00:16:20 * Cale feels lagged... 14.2s :)
00:17:05 <Pegazus> newsham: O_o i'm just asking how to get to continue code on next line...
00:17:42 <Cale> Pegazus: easy, just make sure it's indented further
00:17:46 <araujo> Pegazus, indenting :-)
00:18:22 <Pegazus> i hate identing
00:18:30 <Pegazus> ident to what part?
00:19:12 <Cale> deeper than the addPRF_test_1
00:21:41 <Pegazus> k
00:21:44 <Pegazus> i hate haskell
00:21:57 <RyanT5000> @karma- Pegazua
00:21:58 <lambdabot> Pegazua's karma lowered to -1.
00:22:09 <Cale> why?
00:22:11 <RyanT5000> @karma+ Pegazua
00:22:12 <lambdabot> Pegazua's karma raised to 0.
00:22:17 <RyanT5000> typo :P
00:22:19 <RyanT5000> also
00:22:26 <RyanT5000> @karma- Pegazus
00:22:27 <lambdabot> Pegazus's karma lowered to -1.
00:22:41 <Cale> @karma @karma
00:22:42 <lambdabot>  @karma has a karma of 0
00:22:49 <RyanT5000> metakarma?
00:23:00 <roconnor> @fix karma
00:23:01 <lambdabot> Maybe you meant: faq id
00:23:05 <goltrpoat> karmonad.
00:23:24 <RyanT5000> @karma+ @karma
00:23:25 <lambdabot>  @karma's karma raised to 1.
00:23:35 <RyanT5000> i think karma deserves a little karma :)
00:24:01 <RyanT5000> does lambdabot know not to respond to itself?
00:24:10 <int-e> @karma lambdabot
00:24:11 <lambdabot> lambdabot has a karma of 11
00:24:28 <RyanT5000> @karma+ @karma+ @karma
00:24:29 <lambdabot>  @karma+'s karma raised to 1.
00:24:50 <RyanT5000> crap, i can't get a space after that + :(
00:24:55 <RyanT5000> @karma- @karma+
00:24:56 <lambdabot>  @karma+'s karma lowered to 0.
00:25:00 <RyanT5000> alright i'll stop playing now :P
00:27:24 <araujo> Pegazus, you from .ar?
00:27:36 <goltrpoat> pegazus:  the indentation rules are mostly common sense.  if you've ever written anything in any programming language, you're bound to be using similar indentation patterns anyway, and it saves on unnecessary code due to code block guards
00:28:32 <goltrpoat> or that's my take anyway.
00:29:08 <RyanT5000> imho, with a good editor it's basically the same idea
00:29:23 <RyanT5000> you either hit { or tab, } or backspace
00:29:26 <Pegazus> yes why?
00:29:36 <RyanT5000> i guess you save on semicolons
00:29:43 <Pegazus> i like {}
00:29:48 <Pegazus> and i always ident my code
00:29:55 <Pegazus> but using "just" identation sux in my opinion
00:30:11 <RyanT5000> well you can use {} in haskell
00:30:17 <ValarQ> you can use { ; } in Haskell
00:30:24 <Pegazus> i can't in pure functional haskell as far as i've tried
00:30:25 <RyanT5000> the only difference is you don't put a semicolon after the last thing, although you might be allowed to
00:30:38 <RyanT5000> when would you have occasion to in pure functional haskell?
00:30:49 <Pegazus> in my homework :)
00:30:55 <RyanT5000> you mean just to break over lines?
00:30:59 <Pegazus> yes
00:31:00 <goltrpoat> well, you save on a bit more than semicolons -- think about how you would implement a pure functional language with haskell style syntax, and replace indentation rules by, say, { }
00:31:05 <Pegazus> i just want to make code "clearer"
00:31:37 <goltrpoat> (minus semicolons, with, say, where, and let/in, etc, type syntax)
00:32:15 <RyanT5000> why do you need brackets *or* indentation rules with a pure-functional language? as long as you know where the expression ends
00:32:32 <RyanT5000> which could be a single ;
00:32:32 <Pegazus> just to make code clearer
00:32:44 <RyanT5000> right, but i mean from a parsing perspective you don't need it
00:32:56 <Pegazus> programs should be made first for human beings, and then for machines...
00:33:00 <Pegazus> not the other way around...
00:33:04 <RyanT5000> that's not what i was responding to
00:33:05 <ValarQ> Pegazus: could we see an example?
00:33:13 <Pegazus> an example of what?
00:33:32 <ValarQ> code that suffers from the indentation rules
00:33:47 <Pegazus> i can give you an example
00:33:53 <Pegazus> for any reason, you have a tab in your code
00:33:54 <Pegazus> :)
00:33:59 <Pegazus> all will break up
00:34:00 <goltrpoat> the FP bit came in just due to the fact that you have more dependent variables, in general.  you're not declaring a bunch of second-class things as you go, in other words.  imagine saying f x = { map { g } } where { g = { h x^2 } }
00:34:08 <Pegazus> (unless you realize and let 4 space for it)
00:34:10 <Pegazus> or something like that
00:34:23 <Pegazus> hugs at least, some time ago
00:34:36 <Pegazus> made that
00:34:40 <int-e> Pegazus: the standard tab size is still 8 on terminals. tabulators are evil.
00:34:40 <ValarQ> Pegazus: it is a problem, but in my experience it doesn't pop up very often
00:34:58 <ct16k> how exatcly can I do a conversion from IO String to String?
00:35:13 <RyanT5000> ct16k: you can't
00:35:22 <ValarQ> Pegazus: i was thinking exactly the same when i started of with python, but with a good editor it isn't a very big problem
00:35:22 <ct16k> lol
00:35:26 <RyanT5000> no i'm totally serious
00:35:44 <RyanT5000> if you threw away the IO, the IO would never get done, and you'd never get the string from teh user in the first place
00:36:04 <RyanT5000> but the good news is that you don't ever need to
00:36:12 <RyanT5000> what are you trying to do?
00:36:18 <ct16k> i know you're serious
00:36:31 <ct16k> but how do I link the two functions npow?
00:36:39 <RyanT5000> code?
00:36:40 <ct16k> i have readstrs form above
00:36:47 <ct16k> commin right up
00:36:50 <RyanT5000> k
00:36:56 <ct16k> just updating my firefox :)
00:37:02 <RyanT5000> alright :)
00:41:58 <lisppaste2> ct16k annotated #18977 with "Type error in application" at http://paste.lisp.org/display/18977#2
00:42:32 <Pegazus> how to make an "enter"
00:42:35 <ct16k> there it is :)
00:42:36 <Pegazus> on a haskell "string"?
00:42:47 <RyanT5000> "\n"?
00:42:56 <Pegazus> "Zero\nZero\nZero\n"
00:43:20 <RyanT5000> readSort needs to be an IO [Integer]
00:43:36 <RyanT5000> you can't do IO in a function - even indirectly - unless it returns an IO something
00:43:41 <Pegazus> what?
00:43:47 <RyanT5000> i'm talking to ct16k
00:44:01 <Korollary> ct16k: type mismatch: readStrs produces a value of type IO [String], while doInts expects a [String]
00:44:02 <int-e> "\n" - or, on output, by using putStrLn instead of putStr. There's also unlines, which takes a list of lines (without newlines) and concatenates them, interleaved with newlines.
00:44:07 <RyanT5000> i already answered your question, i think :)
00:44:49 <ct16k> and how do I get rid of this? putting IO String and IO Integer
00:45:00 <ct16k> get's me an error in read
00:45:17 <RyanT5000> doInts looks, on its face, to be OK
00:45:18 <ct16k> which expects a string, not an io string
00:46:01 <ct16k> i could really use something like conv::IO String->String
00:46:08 <ValarQ> haha :)
00:46:18 <int-e> you use readStr >>= sort . doInts or, probably easier to understand: do line <- readStr; return (sort (doInts line))
00:46:18 <ct16k> but have no ideea how to do that
00:46:44 <RyanT5000> ok so doInts should be written "doInts x = map read x"
00:46:56 <int-e> you can not simply use an IO foo in place of a foo - you need to execute the IO action first, then use the resulting value.
00:46:58 <RyanT5000> it's totally fine, though
00:47:08 <Korollary> ct16k: The IO monad intentionally does not provide a way to make the conversion so that the parts of a program that do I/O and the parts that don't are isolated from each other.
00:47:14 <int-e> RyanT5000: or, doInts = map read :)
00:47:26 <RyanT5000> yes, but i don't think point-free is as obvious to newbs :)
00:47:40 <ct16k> i understood preety well by now they're isolated... how do i get them to interact?
00:47:50 <ValarQ> ct16k: http://www.haskell.org/tutorial/io.html
00:47:51 <ct16k> :)
00:49:17 <RyanT5000> ct16k: your readSort needs to return IO [Integer]; once you do that, you can write it as follows (i think - i'm not checking this):
00:49:17 <RyanT5000> readSort = stringList <- readStrs ; return (sort (doInts stringList))
00:49:38 <RyanT5000> but read the tutorial anyway :)
00:50:24 <int-e> you're missing a 'do'. And I wrote something similar above :)
00:50:31 <RyanT5000> yes, i am :)
00:50:44 <RyanT5000> sorry - didn't see it :P
00:50:56 <ValarQ> ct16k: Haskell IO/State takes some time getting used to...
00:52:01 <RyanT5000> the main rules to follow are to use <- for the result of other IO stuff, and let for the result of pure functions
00:52:24 <RyanT5000> you can't "inline" calls to IO functions without using more complicated syntax
00:52:47 <ValarQ> question is if it's not better to start of without do-notation (just a thought)
00:52:50 <RyanT5000> (depending on your definition of "more complicated")
00:53:04 <RyanT5000> i think do notation is better for non programmers definitely
00:53:12 <RyanT5000> C++ programmers, ah, i dunno
00:53:21 <ValarQ> Haskell programmers non-programmers?
00:53:28 <RyanT5000> no i mean
00:53:32 <RyanT5000> if someone knows no programming at all
00:53:37 <RyanT5000> and you are teaching them haskell
00:53:43 <ValarQ> ah, ok
00:53:45 <RyanT5000> i think do notation is way easier than non-do-notation
00:54:03 <ValarQ> well, i don't think it does much difference
00:54:18 <goltrpoat> i think do notation tends to confuse imperative programmers whenever it's not introduced as syntactic sugar
00:54:19 <ValarQ> sooner or later you have to get under the do-notation
00:54:30 <RyanT5000> yeah
00:55:16 <ValarQ> it gets even better when 'do' is used for other things than IO :)
00:55:58 <RyanT5000> yah
01:00:19 <RyanT5000> if you don't have the constructor of a newtype, you can't convert back from it, right?
01:01:02 <ValarQ> not that i know of
01:01:26 <RyanT5000> yah i'm not including "hacks" that involve maybe TH or some other such stuff
01:01:46 <RyanT5000> i mean it in the same sense as "you can't read private variables"
01:09:46 <RyanT5000> what's the difference between ":m + My.Module" amd 
01:10:06 <RyanT5000> s/amd/and ":m + *My.Module"/
01:14:10 <ValarQ> "The syntax *module indicates that it is the full top-level scope of module that is contributing to the scope for expressions typed at the prompt. Without the *, just the exports of the module are visible."
01:15:03 <RyanT5000> ah ok
01:15:13 <RyanT5000> thanks; also, sorry for asking that; i should've just looked it up
01:15:34 <RyanT5000> it's late and for some reason that makes me prefer #haskell over google (not my normal tendency)
01:17:23 <ValarQ> noprob, i got curious myself actually :)
01:19:48 <RyanT5000> is there a class for "things which have defaults"?
01:20:00 <RyanT5000> i guess that wouldn't make much sense
01:20:06 <RyanT5000> but i was thinking like 0 for Integer
01:20:11 * araujo would like to see a networking multiplayer game written in Haskell someday
01:20:23 * RyanT5000 is writing one
01:20:45 <araujo> RyanT5000, that's cool
01:20:51 <RyanT5000> it's not real-time-networked, in case that makes it uncool, though
01:20:54 <araujo> RyanT5000, multiplayer?
01:21:00 <RyanT5000> so it technically doesn't even need to use sockets
01:21:16 <RyanT5000> (or any networking directly)
01:21:28 <RyanT5000> yeah, it's a multiplayer strategy game
01:21:32 <araujo> well, we need more haskell games :-)
01:21:34 <RyanT5000> it's like a board game with multiple boards
01:21:49 <ValarQ> is frag networked?
01:21:51 <araujo> nice
01:21:51 <RyanT5000> i've already got most of the server implemented in C#... which i will probably scrap
01:22:06 <araujo> ValarQ, i *think* it is not
01:22:09 <RyanT5000> i knew about haskell like a year ago... i wish i had known how kickass it was
01:22:19 <RyanT5000> you guys seriously need better marketing :P
01:22:26 <araujo> hah
01:22:49 <basti_> RyanT5000: you got to give "lambda calculus" a better sound
01:22:54 <ValarQ> RyanT5000: indeed :)
01:22:55 <RyanT5000> yah
01:23:07 <RyanT5000> the two things that sold me were monads and lazy evaluation
01:23:50 <RyanT5000> they where the things i was looking for when i left the religion of C++/C#/etc. and entered the desert of languages in search of the true one
01:24:16 * araujo has found pure languages like the most beautiful ones
01:24:37 <araujo> that's what brought me aboard 
01:24:42 <RyanT5000> is "referential transparency" what we mean by "functions don't get things you don't give them"?
01:24:55 <araujo> mmm...
01:25:01 <RyanT5000> yeah i think that's what it means
01:25:06 <araujo> fx = y for all x
01:25:19 <basti_> RyanT5000: exactly
01:25:31 <RyanT5000> that is such a powerful concept if you want to write code without bugs
01:26:00 <RyanT5000> before i knew about haskell i was putting together a requirements list for a language i was going to write
01:26:09 <RyanT5000> the top thing on the list was universal immutability
01:26:24 <RyanT5000> (which is equivalent to universal referential transparency)
01:26:52 <RyanT5000> that's how i found haskell :)
01:26:55 * basti_ nodnodnods
01:27:10 <basti_> do you know that there are people who can prove their code to be correct?
01:27:29 <basti_> (or even better, instatiate a proof without using the target language itself at all)
01:27:51 <RyanT5000> yah, i know a bit about proofs
01:28:15 <RyanT5000> all the proofs i've seen are about code with mutable variables though
01:28:18 <RyanT5000> which seems totally misguided
01:28:29 <basti_> There's a very interesting proofchecker called coq. It can extract proofs as (haskell or ocaml) programs.
01:28:30 <RyanT5000> i mean, obviously you have to do that at some point
01:28:40 <RyanT5000> that's pretty awesome
01:29:09 <basti_> in reality, you're forced to assume there is something like muteable variables.
01:29:21 <RyanT5000> yeah
01:29:25 <basti_> (at least the program's input is really and without doubt variable)
01:29:43 <RyanT5000> well, if you get all your input at once it isn't mutable
01:29:44 <basti_> but of course proof gets easier without muteables
01:29:50 <basti_> yep
01:29:51 <RyanT5000> but that's obviously not the case for any interesting systems
01:30:02 <basti_> ah i wouldn't say so
01:30:10 <basti_> lc-languages -have- one muteable variable.
01:30:16 <basti_> the evaluation state.
01:30:20 <basti_> (at least one)
01:30:34 <RyanT5000> isn't that an artifact of the implementation of the compiler?
01:30:37 <basti_> the invariant then is that your result is always the right one
01:30:41 <basti_> hmmm.
01:30:42 <Korollary> that's not considered a language variable
01:30:48 <basti_> no its not
01:30:55 <basti_> but the treatment is similar in a proof
01:30:58 <RyanT5000> hm
01:31:02 <RyanT5000> ah
01:31:09 <RyanT5000> if you want to prove your code halts you have to deal with it
01:31:16 <basti_> you got a function call "x y z" that is evaluated to "17" and you have to prove that this is correct.
01:31:37 <basti_> its like a degenerate invariant on a single muteable variable
01:31:42 <RyanT5000> do you have to think about that variable if you don't care about halting?
01:31:55 <basti_> hmm first, a correct program never halts.
01:32:00 <RyanT5000> wha?
01:32:03 <basti_> uhm
01:32:04 <basti_> always
01:32:06 <basti_> i'm sorry ^^
01:32:07 <RyanT5000> :D
01:32:14 <basti_> way too early lol
01:32:24 <RyanT5000> i would tend to disagree though
01:32:30 <RyanT5000> what if your program is "sum this infinite list"?
01:32:38 <Korollary> servers are not meant to halt
01:32:41 <RyanT5000> it can be correct in the limit, without halting
01:32:48 <basti_> hmm
01:32:59 <basti_> yea thats the question now.
01:33:01 <RyanT5000> tough crowd :)
01:33:10 <basti_> there's two ways of representing this
01:33:17 <basti_> first, lists. lists always end. (inductive)
01:33:28 <basti_> then, streams. streams don't have to end. (coinductive9
01:33:29 <RyanT5000> so do tapes :)
01:33:49 <basti_> you can prove a program to be correct on a stream, without it having to end.
01:34:01 <basti_> i'm not sure if that is a program that doesn't halt
01:34:08 <RyanT5000> ok so a stream is a list that doesn't have a terminator
01:34:14 <basti_> kinda, yes.
01:34:29 <RyanT5000> but can you express that as type information? (even if you had the perfect type language)
01:34:30 <basti_> I'd call it a program on streams a loop that runs as long as the user wishes.
01:34:40 <basti_> yes, even haskell can do it.
01:34:48 <RyanT5000> really? how?
01:34:50 <basti_> I'm not sure on the details, wait.
01:34:58 <RyanT5000> because that's the halting problem
01:35:11 <RyanT5000> (i think)
01:35:43 <RyanT5000> let's say i say [1..]; how can you tell me whether that's a list or a stream, by only examining its contents?
01:35:44 <basti_> I'd guess its like   data Stream a = a :< Stream a
01:35:57 <basti_> now we get to the messy bits ;)
01:36:15 <basti_> lazy evaluation can make streams.
01:36:52 <RyanT5000> ok so you're saying that a list has to be known to end
01:36:57 <RyanT5000> so you can't convert a stream into a list
01:37:02 <RyanT5000> even if the stream does end
01:37:11 <RyanT5000> (because you can't know that in advance)
01:37:15 <basti_> http://www.cs.helsinki.fi/u/ekarttun/comonad/ < thats musasabi's site
01:38:12 <basti_> thats what it ends up with yes.
01:38:12 <basti_> for example, you can always try and sort a list.
01:38:12 <basti_> with a stream that just doesn't make sense
01:38:12 <basti_> of course you'll have for your list to end to get the first element of the result list.
01:38:41 <basti_> I'm not sure at all how lists, streams and lazy evaluation relate exactly.
01:38:47 <RyanT5000> yeah
01:38:59 <basti_> i think its somewhat like: lazy eval can make lists that are iso to streams
01:39:07 <RyanT5000> yeah
01:39:42 <basti_> did i mention that a flatmate of a friend i was learning with recently thought we're completely nuts?
01:40:28 <RyanT5000> lol
01:40:43 <RyanT5000> but this is what makes stuff interesting!
01:41:56 <basti_> btw. another interesting aspect is that I/O is "somewhat like streams". so, combination of pure parts and I/O (which is what lazy eval aims at) makes a program "somewhat like streams"
01:42:21 <RyanT5000> yeah
01:42:36 <basti_> In my insanity i suspect that lazy eval is some sort of distributive operation over monads & comonads.
01:42:49 <Korollary> uh
01:43:04 <RyanT5000> hm, i haven't learned about comonads yet (i've heard about them; i'll read up on them some day soon)
01:43:05 <basti_> but I'll retract on any complaint.
01:43:07 <basti_> ^^
01:43:41 * basti_ marks the day on his calendar: "made Korollary go like 'uh'"
01:43:42 <RyanT5000> gah
01:44:01 <RyanT5000> Prelude Namespace> get n x
01:44:01 <RyanT5000> "
01:44:12 * RyanT5000 hits Ctrl-C
01:44:23 <RyanT5000> nothing happens
01:44:26 <RyanT5000> :(
01:44:35 <basti_> uhm
01:44:38 <basti_> what's get n x?
01:44:43 <RyanT5000> it's a function i wrote :)
01:44:46 <RyanT5000> it should return "Ryan"
01:44:58 <basti_> ah
01:44:59 <RyanT5000> because i earlier wrote "insert "Ryan" x"
01:45:10 <RyanT5000> basically i'm writing a Map, except it allocates keys for you
01:45:17 <RyanT5000> (i call it "Namespace")
01:45:18 <basti_> like, monadic?
01:45:21 <RyanT5000> no
01:45:22 <RyanT5000> pure
01:45:26 <basti_> i see
01:45:35 <basti_> with x as the pure thing being passed around?
01:45:42 <RyanT5000> insert :: a -> Namespace ix a -> (ix, Namespace ix a)
01:45:51 <RyanT5000> yeah
01:46:04 <RyanT5000> x :: Namespace Integer [Char]
01:46:30 <basti_> hmm. I don't know what makes the haskell runtime ignore C-c.
01:46:30 <RyanT5000> but why doesn't ctrl-c work?!
01:46:30 <basti_> curious
01:46:30 <Korollary> I dont think it does
01:46:30 <RyanT5000> yah maybe it's cause i'm on windows
01:46:35 <basti_> oh maybe yes.
01:46:44 <bolrod> ohhhh windows
01:46:45 <bolrod> :)
01:47:06 <RyanT5000> <- cries
01:47:15 <basti_> RyanT5000: killall ghci?
01:47:20 <RyanT5000> not quite
01:47:20 * basti_ ducks and runs
01:47:25 <bolrod> hahaha
01:47:27 <bolrod> :D
01:47:32 <bolrod> pkill -9 ghci
01:47:36 <bolrod> 8)
01:48:00 <RyanT5000> ctrl alt del -> t -> find "ghc" in the "processes" tab -> "End task" -> Yes
01:48:18 <bolrod> wow O_O
01:48:26 <RyanT5000> i swear to god that is the easiest way
01:48:31 <RyanT5000> granted it takes me like 4 seconds
01:48:38 <RyanT5000> but it's still way to complicated
01:48:41 <RyanT5000> *too
01:48:44 <basti_> you need to implement "kill" for windows
01:48:48 <RyanT5000> it exists
01:48:58 <RyanT5000> actually taskkill exists
01:48:59 <basti_> but the PID's are secret? ;)
01:49:02 <RyanT5000> i think i even have it...
01:49:03 * shapr burbles
01:49:06 <RyanT5000> no, pids are visible
01:49:16 <bolrod> sometimes.. it seems hitting the reset button is faster then the end task thing
01:49:16 * basti_ puts the lid on shapr again.
01:49:17 * Korollary tripls shapr with a lambda
01:49:20 <RyanT5000> lol
01:49:26 * shapr bounces!
01:49:36 <basti_> RyanT5000: i'm j/k btw. ;)
01:49:45 <RyanT5000> winxp is the first MS OS that almost never won't let you kill a process
01:49:57 <bolrod> true
01:50:05 <RyanT5000> and i also have a tool that exploits a bunch of security holes to kill a process
01:50:16 <basti_> :-O
01:50:21 <RyanT5000> so with the combination of those two, i've never had to restart because of not being able to kill a process
01:50:22 * bolrod 2nds that
01:50:53 <RyanT5000> but yeah
01:51:02 <RyanT5000> i, uh, hate windows with the burning passion of a thousand suns
01:51:03 <bolrod> seriously though.. in gnome. you have this icon
01:51:07 <bolrod> you click on it
01:51:12 <bolrod> then you click on the screen to kill
01:51:16 <bolrod> and POOF!  gone
01:51:18 <RyanT5000> actually i have this other tool, which makes the window manager almost not suck
01:51:19 <bolrod> :x
01:51:24 * basti_ laughs
01:51:25 <wolverian> bolrod, or click on the 'x'
01:51:35 <RyanT5000> you right-click on the "X", and it has a big menu
01:51:40 <RyanT5000> including like "hide" "always on top" etc.
01:51:42 <RyanT5000> but also "terminate"
01:51:46 <RyanT5000> very useful
01:51:47 <bolrod> yes.. but if it's like.. stuck somewhere
01:52:00 <RyanT5000> but doesn't work on GHC cause ghc's in a terminal window
01:52:04 <wolverian> bolrod, then gnome will ask you if you want to kill the process after five seconds
01:52:11 <RyanT5000> so it kills cmd.exe, but not ghci or ghc
01:52:21 <wolverian> bolrod, answer yes and the process is killed with extreme prejudice
01:52:29 <boegel> bolrod: there's a simple solution to that problem: use MacOSX :)
01:52:30 <bolrod> yeah yeah :P
01:52:47 <bolrod> I am using osx
01:52:50 <bolrod> and ubuntu
01:52:53 <boegel> oh, ok then :)
01:52:53 <bolrod> :)
01:52:54 <wolverian> (this actually works, unlike in windows, where it works _sometimes_)
01:53:06 <Korollary> RyanT5000: I remember it worked ok in cygwin.
01:53:08 <RyanT5000> (yeah,  i don't even use that "feature" of windows)
01:53:10 <bolrod> nah.. zombie processes are really hard to killl
01:53:34 <wolverian> zombie processes are already dead :)
01:53:43 <basti_> ^^
01:53:55 <bolrod> but they stay in the process list
01:54:05 <bolrod> don't know if they eat up memory though
01:54:16 <basti_> unused mem is harmless
01:54:17 <boegel> no, they eat up your BRAIN !
01:54:23 <bolrod> yeah
01:54:24 <basti_> it'll get swapped out one day
01:54:39 <bolrod> by a machine!
01:54:49 <bolrod> then you're being dropped in Iraq
01:54:50 <bolrod> or something
01:55:01 <basti_> tne
01:55:11 <basti_> they're bringing all the swapped-out ram to iraq?
01:55:20 <wolverian> bolrod, zombies eat only a place in the process table.
01:55:27 <basti_> that explains why they're not making advances over there
01:55:27 <wolverian> orphans are more dangerous.
01:55:28 <bolrod> ic
01:55:38 <wolverian> (confusing terminology :)
01:56:14 <RyanT5000> i have never understood why orphans are necessary
01:56:20 <bolrod> with that new PS3 .. they'll just buy a shitload of them, and they'll have more computing power then the IBM big computer thingy
01:56:23 <RyanT5000> (btw i know what they're used for)
01:56:34 <RyanT5000> i say, force a process to get adopted
01:56:36 <RyanT5000> say, by init
02:00:54 <RyanT5000> if you can't get your process adopted, it dies
02:00:55 <boegel> say, yeah, say, cool
02:00:55 <basti_> might we want to conduct that conversation on #haskell-blah? ;)
02:00:55 <bolrod> we do?
02:00:55 <basti_> i don't know, thats why i ask ;)
02:00:55 <bolrod> ask yourself
02:00:55 <bolrod> :)
02:00:55 <wolverian> RyanT5000, that's what happens on unices, generally.
02:00:55 <basti_> otherwise casual passer-by's will get the wrong impression of #haskell ;)
02:00:55 <RyanT5000> wolverian: how do you then ever have an orphan?
02:00:55 <RyanT5000> also, "cool" :)
02:00:55 <wolverian> RyanT5000, processes adopted by init are still called orphans
02:00:55 <RyanT5000> i see
02:00:55 <bolrod> just read the source code if you want to know what happens >_>   *cough* *cough*
02:00:55 <bolrod> thats what the kernel does
02:00:55 <bolrod> just talk sheyat... and the orphan dies
02:00:55 <bolrod> 8)
02:00:55 <RyanT5000> alright time to go to sleep; i just typed ":m +Prolog", meaning "Prologue", meaning "Prelude"
02:00:55 <basti_> ^^
02:00:57 <blackdog> sort of a weird question, but does anyone know how to represent a Haskell-style datatype disjunction in an SQL db?
02:01:02 <basti_> you're STILL awake, not ALREADY?!
02:01:16 <RyanT5000> lol yeah
02:01:21 <RyanT5000> i'm a night person, lol
02:01:25 <basti_> o.0
02:01:27 <RyanT5000> @localtime RyanT5000
02:01:27 <bolrod> @localtime RyanT5000 
02:01:32 <bolrod> xD
02:01:33 <RyanT5000> it's 5
02:01:40 <Korollary> >localtime
02:01:40 <bolrod> > 1+1
02:01:42 <lambdabot> 2
02:01:49 <bolrod> you have ctcp off?
02:01:52 <basti_> blackdog: i don't know.
02:01:57 <basti_> 11:00 CTCP TIME reply from RyanT5000: Fri Apr 14 05:00:24 2006
02:02:12 <RyanT5000> CTCP?
02:02:13 <bolrod> ahwell... its not THAT late
02:02:16 <bolrod> CTCP!
02:02:21 <ValarQ> RyanT5000: client to client protocol
02:02:30 <RyanT5000> an IRC thing i take it?
02:02:33 <ValarQ> @wikipedia ctcp
02:02:35 <lambdabot> No Result Found.
02:02:43 <RyanT5000> this is the only IRC channel i've ever spent significant time in
02:02:45 <RyanT5000> i use trillian
02:02:48 <bolrod> RyanT5000: type /ctcp bolrod version
02:03:01 * bolrod slaps RyanT5000 
02:03:07 <RyanT5000> ?
02:03:08 <bolrod> first windows.. now trillian  :x
02:03:17 <RyanT5000> i use it for AIM
02:03:19 <ValarQ> what the heck? is wikipedia case sensitive?
02:03:20 <RyanT5000> :)
02:03:27 <ValarQ> @wikipedia CTCP
02:03:28 <lambdabot> No Result Found.
02:03:31 <ValarQ> hmm
02:03:32 <RyanT5000> i think wikipedia is
02:03:38 <RyanT5000> although not for first-letters-of-words
02:03:43 <bolrod> @wikipedia wikipedia
02:03:45 <lambdabot> No Result Found.
02:03:46 <RyanT5000> or maybe it's first-letters-of-names
02:03:47 <bolrod> wow
02:03:48 <RyanT5000> something like that
02:03:57 <bolrod> @google ctcp
02:03:57 <RyanT5000> @wikipedia Ctcp
02:04:00 <lambdabot> http://www.irchelp.org/irchelp/rfc/ctcpspec.html
02:04:01 <lambdabot> No Result Found.
02:04:04 <RyanT5000> i dunno
02:04:15 <bolrod> @google mass of sun in kg
02:04:17 <lambdabot> mass of the sun = 1.98892 x 10^30 kilograms
02:04:19 <bolrod> :]
02:04:20 <RyanT5000> ahahahaha ok my previous halt (that caused the ctrl-c fiasco)
02:04:36 <RyanT5000> was because i said "let x = (some stuff)"
02:04:38 <RyanT5000> then i said
02:04:50 <RyanT5000> let x = (some stuff involving x)
02:04:56 <RyanT5000> ;)
02:05:03 <bolrod> see
02:05:06 <bolrod> it was doing something
02:05:09 * RyanT5000 is still in C++-mode
02:05:22 <Korollary> @google mass of kg in sun
02:05:24 <lambdabot> http://hypertextbook.com/facts/2000/LeonVaysburd.shtml
02:05:28 <RyanT5000> i think i'm doing ok for having been at it for 2 weeks though :)
02:05:33 <RyanT5000> not even 2 weeks yet
02:05:40 <RyanT5000> like a week and 2 days
02:05:42 <bolrod> @google mass of helium atom
02:05:45 <lambdabot> http://richardbowles.tripod.com/chemistry/moles/moles.htm
02:05:59 <RyanT5000> anyway, cya all
02:06:03 <bolrod> good night
02:09:15 <Muad_Dib> moin
02:09:51 <boegel> @google mass of shapr in kg
02:09:54 <lambdabot> http://www.crookedtimber.org/archives/001379.html
02:10:20 <bolrod> psh!
02:11:16 <bolrod> @google mass of sun in stones
02:11:18 <lambdabot> mass of the sun = 3.13201288 x 10^29 stones
02:12:43 <bolrod> @google mass of earth
02:12:46 <lambdabot> http://hypertextbook.com/facts/2002/SamanthaDong2.shtml
02:12:50 <bolrod> @google mass of moon
02:12:52 <lambdabot> http://hypertextbook.com/facts/2002/AdaLi.shtml
02:23:20 <shapr> boegel: Hey!
02:24:43 <shapr> boegel: Probably 94 kilos or so.
02:27:22 <boegel> shapr: hehe :)
02:28:58 <shapr> @google mass of boegel in stones
02:29:01 <lambdabot> http://www.stjosephmission.org/braun.htm
02:29:15 <blackdog> shapr: hey. :)
02:29:31 <shapr> g'day blackdog 
02:30:22 <blackdog> was going to ask you about representing haskell-style datatypes in sql, but i think i figured it out.
02:32:11 * juhp gets his hircules tree to build again
02:32:22 <juhp> it's been a while...
02:32:40 <juhp> I should make a darcs repo
02:33:34 <shapr> yeah, darcs!
02:35:06 <juhp> but better checkin my changes to sf cvs first...
02:35:33 <juhp> shapr: is there a cvs2darcs converter?
02:35:41 <juhp> or is that a dream?
02:36:32 * juhp ponders just doing a 2 line changelog: "fixes, improvements and update to modular gtk2hs"
02:36:59 <basti_> cvs and darcs are fundamentally different. I don't believe such a converter would be easy
02:37:40 <juhp> hircules% cvs diff | wc -l
02:37:41 <juhp> 3469
02:37:49 <juhp> hm
02:38:08 <juhp> basti_: was afraid that would be the answer ;)
02:38:29 <basti_> tbh it probably could be done, but it would be a real resource hug to do such a conversion
02:38:37 <basti_> (chekc out every version and chekc it into darcs?)
02:38:58 <juhp> basti_: yeah that 's probably what I'll do :)
02:40:08 <juhp> luckily there were only 3 releases so far...
02:40:29 <basti_> ;)
02:40:44 <basti_> probably you can even do it with a shell script and some awk and perl magic, but uuuuh!
02:41:52 <shapr> juhp: Yes there is
02:43:48 <basti_> like where?
02:44:17 <juhp> hmm, my current code doesn't seem to work though ;)
05:00:33 --- topic: '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]'
05:00:33 --- topic: set by franka on [Sun Mar 26 11:37:55 2006]
05:00:33 --- names: list (clog donghee nnunley roconnor Nomius__ xerox tennin mahogny waern Pupeno blackdog boegel Ulfalizer caribe Si\ Itkovian kombinator iblechbot Oejet BCoppens tessier_ Khisanth nothingmuch wobster chris2 MarcWeber mhfan jyp integral Saulzar tic basti_ kolmodin la tizoc araujo metaperl Pegazus coumbes scw gvdm int-e CLxyz Trixsey qwr borism slipstream Poeir spamsch ksandstr kpk llappala gzl cods glasser mattam arguile eno-away drbean sieni)
05:00:33 --- names: list (ramkrsna svens zamez SimonRC dechunker liyang Cale tessier emu audreyt eivuokko jgrimes dons spo0nman kaol kzm exnor Plareplane johs moleris WillKW LoganH lispy cbus cmeme mux mokus xX[ReP]Xx ozone lucca gdsx bolrod morans lisppaste2 lome mathrick olliej SamB sjanssen shrimpx binary42 thedward palomer petekaz mikezs wilx moonlite Nioate danly kpreid_ |metaper| Beelsebob rasterfar ibid slang kisu cpatrick earthy ulfdoz aleator genneth shawn)
05:00:33 --- names: list (tromp eyck xinming turok _shawn isydor_ wolverian blb30364 dbremner lambdabot astecp orbitz psnl Magical1 neologism cognominal Lor newsham Lokadin jip Bobstopper shapr magagr rashakil Lemmih dfhaii Adamant ayrnieu ChilliX norpan Igloo sethk Lycurgus Korollary musasabi mornfall vincenz astrolabe sowhat AtnNn Wallbraker juhp djw wli dcoutts_ pejo Maddas kosmikus greenrd xerox_ flux__ resiak Spark jks ohub ValarQ edwinb noj Lunar^ rkeene)
05:00:33 --- names: list (sellout dany2k)
05:01:08 <xerox> jip: did you make a darcs repo of the emulator yet?
05:01:24 <jip> Ulfalizer: yeah, i could, but i have a better idea. there is this debugger called no$gmb that i can play with that should help me figure things out. only problem is that no$gmb is dos/windows only :(
05:01:25 <xerox> shapr: ping me back when you get in!
05:01:46 <Ulfalizer> can't you run it in dosbox? :)
05:01:49 <jip> xerox: no
05:02:05 <jip> Ulfalizer: i'm just gonna find a windows machine somewhere :)
05:02:30 <xerox> If you had a macintel it would have been straightforward ;-)
05:03:30 <Ulfalizer> i wonder if bootcamp for os x uses the hardware virtualization support i've heard the duo cpu has..
05:03:48 <xerox> Nope, it's just a BIOS into the EFI
05:03:55 <Ulfalizer> ok
05:04:04 <xerox> The other one is the one I'm waiting furiously :-)
05:04:05 <Ulfalizer> so it's not really a virtualizer either?
05:04:28 <Ulfalizer> just something to allow you to boot windows separately
05:04:36 <xerox> Yep, a bootloader.
05:04:42 <Ulfalizer> ok :/
05:04:43 <xerox> (On steroids?)
05:05:02 <Ulfalizer> i thought it was similar to vmware
05:06:49 <xerox> Something called 'Parallel' is more similar to vmware, and uses the virtualization bogglery you were talking about.
05:06:49 <Ulfalizer> is it from apple?
05:06:49 <xerox> Nope.
05:06:49 <xerox> http://www.macrumors.com/pages/2006/04/20060410002601.shtml
05:06:49 <Ulfalizer> i hate having to reboot just to switch os
05:07:30 <xerox> http://www.parallels.com/en/products/workstation/mac/
05:07:32 <xerox> This one!
05:09:27 <Ulfalizer> it should be made easier to write a virtualizer by the fact that the duo has vanderpool (the hardware virtualization support)
05:10:28 <Ulfalizer> it would be cool if all hardware had such a feature, allowing you to save the entire system state in a big "os context switch", not needing to emulate anything in a virtualizer
05:12:30 <roconnor> @hoogle hex
05:12:31 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
05:12:31 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
05:12:31 <lambdabot> Numeric.readHex :: Integral a => ReadS a
05:13:02 <roconnor> > Numeric.readHex "2258"
05:13:04 <lambdabot> [(8792,"")]
05:21:34 <MarcWeber> When using int/word will overlows be dedected when using +/- and so on? I know there are some processor flags set if that happens. I don't need it but I'm interested how programs would terminate when feeding them with much more data than expected..
05:24:25 <musasabi> MarcWeber: they will overflow silently.
05:24:42 <musasabi> MarcWeber: use Integer if you need large numbers.
05:25:03 <musasabi> it will never overflow.
05:25:12 <musasabi> > 2^10240
05:25:13 <lambdabot> 35249714121083826571348148398002815464391421343966471060391382605731070276854749365048330296473663862456968155395298373973259049475943113619888338673116133666814706870765271907656205646018608369985558
05:25:13 <lambdabot> 72126767032173903193863383328188919262015842653180692314423926972687639995196119198034802329170347230576378241039458975893458563111107812043530303268881875144643529137135717175563277536293269479507631
05:25:13 <lambdabot> 34366874696380043276893902467353218558306108568659249137608267637760032658517165573342106422773434757577997804990215598224124342750870843172934551295704067075900020717046731355275335432173559875681076
05:25:13 <lambdabot> 97577946785796412456048360072965616871024866244650081059068183038134518514222987186837394598019859512993600379236190197576838905080733359989094687008999416247722020061992559931401872357379708488585003
05:25:16 <lambdabot> 66696593060973043077410740749401806536584507709432053470069235440016982413157838915365691675468225242556274289502682208611223618576893194043332407869238646364237802929158238455090401228426527712466745
05:25:19 <lambdabot> [6 @more lines]
05:25:50 <bolrod> you can overflow your memory
05:26:11 <musasabi> of course, but so can anything else.
05:26:19 <bolrod> ;)
05:26:23 <Ulfalizer> the only thing missing there was lambdabot getting kicked for spamming :)
05:26:59 <bolrod> why does lambdabot output 5 lines?
05:27:03 <bolrod> I mean... 2 ought to be enough
05:27:10 <sjanssen> > 2^30 + 2^30 :: Int
05:27:11 <bolrod> for expressions
05:27:11 <lambdabot> -2147483648
05:27:45 <bolrod> > 2^31 :: Int
05:27:46 <lambdabot> -2147483648
05:27:55 <bolrod> > 2^32 :: Int
05:27:56 <lambdabot> 0
05:28:16 <bolrod> > 2^31-1 :: Int
05:28:17 <lambdabot> 2147483647
05:31:02 <ayrnieu> @type fromIntegral
05:31:03 <lambdabot> forall b a. (Num b, Integral a) => a -> b
05:31:52 <ayrnieu> > fromIntegral(2^31 :: Int) - 1
05:31:53 <lambdabot> -2147483649
05:32:40 <Ulfalizer> heh, grandma just brought me 5 pounds of easter candy. being home rules.
05:33:01 <ayrnieu> eat all of it in one sitting.  You'll only gain 5 pounds!
05:33:23 <Ulfalizer> well, i could use some extra weight :)
05:33:46 <bolrod> O_o?
05:34:37 <bolrod> take some of my weight :)
05:34:46 <bolrod> j/k ;)
05:34:55 <Ulfalizer> i'm not really into that kind of stuff :/
05:35:08 <bolrod> ?
05:35:20 <Ulfalizer> never mind, i don't want to elaborate on that :)
05:36:15 <bolrod> ic
05:49:43 <Maddas> à‰
05:49:49 <Maddas> (Oops)
05:52:05 <jyp> > 37 ^ 43
05:52:06 <lambdabot> 27081588506598106040982953896258749653831334409506086433262944331453
05:56:37 <neologism> is there any howto how to turn program from String to FPS?
06:05:59 <xerox> ?where fps
06:05:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
06:06:18 <xerox> http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html
06:06:35 <xerox> pack :: String -> FastString
06:06:41 <xerox> unpack :: FastString -> Strin
06:06:42 <xerox> g
06:08:19 <neologism> ok, thnx
06:30:15 <wobster> Hello. I have a list like 'data NTree a = Node a [NTree a]'. In a function like 'dd :: NTree a -> Int -> Int' with 'dd (Node n (x:xs)) d' how would I check xs for emptynes? simply guarding with xs /= [] fails.
06:31:50 <sjanssen_> fails in what way?
06:34:00 <wobster> sjanssen: ERROR "one.hs":68 - Cannot justify constraints in explicitly typed binding
06:34:00 <wobster>  .. shall I pastebin the full snipet?
06:34:28 <sjanssen_> wobster: you probably don't want to use equals
06:34:58 <wobster> sjanssen: right ;). I'd prefer something that works, actually. 
06:35:25 <sjanssen_> perhaps: dd (Nod n (x:xs) d) = if null xs then foo else bar
06:36:27 <wobster> sjanssen: I'll try.
06:37:06 <wobster> sjanssen: solved. thank you.
06:37:39 <wobster> weird, I would've guessed that null and /= and equivalent.
06:38:07 <jyp>  /= requires Eq on the element type.
06:39:50 <jip> help! "Killed" what does this mean?
06:40:11 <jyp> @wn Killed
06:40:13 <lambdabot> No match for "Killed".
06:40:26 <jyp> @thesaurus killed
06:40:27 <lambdabot> Unknown command, try @list
06:40:53 <jyp> jip: I guess you got the SIGKILL signal ?
06:41:05 <BCoppens> maybe the kernel Out of Memory thingie kicked in?
06:41:12 <jip> BCoppens: that might be it
06:41:30 <BCoppens> usually dmesg lists that
06:42:08 <jip> hm... don't see it there
06:43:09 <jip> but apparently my program eats and eats memory as it runs. it shouldn't though :(
06:43:38 <jip> this is what i'm doing:
06:44:02 <jip> i have a AppState type, that is pretty big
06:44:11 <jip> then i have a step :: AppState -> AppState function
06:44:33 <jip> and then i have my main :: IO () that basicly does
06:44:57 <jip> let l = iterate step (initialAppState)
06:45:22 <sjanssen_> jip: try compiling with -O, and see if you run OOM again
06:45:22 <jip> let dis = map (\state -> show state) l
06:45:30 <jip> sjanssen_: ah, good point!
06:45:37 <jip> i was running from within ghci
06:46:02 <BCoppens> jip: (also check ulimit -a perhaps)
06:47:19 <jip> anyway, then i finally do: mapM_ (\s -> putStr s) dis
06:49:18 <sjanssen_> if -O doesn't help, you can try adding some strictness: "let l = iterate step (initialAppState $!)"
06:55:37 <jip> -O seems to help a bit, but for some reason it seems to pause in this one particular place for a long time. i have no idea why it's doing this. maybe it's doing gc? but why would it take so long?
06:56:24 <sjanssen_> it's probably getting rid of all those old AppStates
06:57:20 <jip> i was hoping that it would figure out that it only needs to contain one AppState in memory and then it can mutate that
06:57:21 <sjanssen_> your system could also be hitting swap
06:57:36 <jip> i don't think it's hitting swap because there is no hd activity
06:58:06 <sjanssen_> GHC won't do update in place
06:59:26 <jip> :'( there goes my architecture. i need this AppState to mutate. it's too big to be copied around all the time
07:00:31 <sjanssen_> how big is big?
07:01:37 <jip> it's a 32KByte array and another array sized 32KByte-2MByte
07:01:54 <jip> but the big array never changes
07:02:32 <jip> plus there's a handful of other small data
07:03:02 <sjanssen_> oh my, 32 KB is rather large
07:06:19 <wobster> what software do you use to include haskell programs into tex documents? lgrind doesn't support haskell, unfortunately.
07:06:43 <jip> sjanssen: so what should i do?
07:07:20 <sjanssen_> jip: well, there's the ST monad, that can give you mutable arrays
07:07:51 <sjanssen_> @where lhs2tex
07:07:52 <lambdabot> http://www.cs.uu.nl/~andres/lhs2tex
07:08:39 <shapr> xerox: ?
07:08:40 <jip> sjanssen: but isn't the ST monad implemented as regular pure haskell? or does ghc have builtin optimizations for ST?
07:09:06 <wobster> thanks again, sjanssen.
07:09:24 <jyp> ST is builtin.
07:09:27 <Philippa> jip: ST's not implementable in regular haskell
07:09:55 <Philippa> (FCVO regular: it's possible we've amassed enough type system extensions by now, and it'll be implementable in GHC's new core language once that's done)
07:12:07 <jip> hm...
07:12:27 <jip> maybe haskell isn't the best language for writing an emulator after all :\
07:12:32 <Philippa> ST /is/ pure-from-the-outside, but it needs compiler primitives to pull off
07:12:47 <Philippa> it would be easily implementable in an untyped language
07:13:21 <roconnor> It would?
07:13:45 <Philippa> yeah. Same as you can do a variant of ST with a monomorphic heap in H98+rank-n types
07:14:02 <roconnor> interesting
07:14:09 <Philippa> the monomorphic bit becomes irrelevant in an untyped language, you end up with the same (admittedly /slower/) implementation
07:14:35 <Philippa> in which you're effectively wrapping a state monad with a map and a unique number supply as the state
07:14:53 <Philippa> use the unique numbers as indices into the map, call them references
07:16:01 <sjanssen_> jip: oh, there's also DiffArray
07:17:49 <jip> sjanssen: do i have to change my whole app, or can i still use my step function?
07:18:26 <Philippa> all you need to do is write your monad-interpreter in monadic style on top of ST
07:18:44 <sjanssen_> jip: DiffArray looks like a normal array on the outside, but does update in place
07:18:46 <Philippa> ultimately you're going to be spitting out a series of IO actions to show the display and so forth anyway, right?
07:19:00 <jip> Philippa: yes
07:20:03 <Philippa> though I guess that can be driven from the outside anyway
07:20:25 <jip> yes, that was my plan
07:22:10 <Philippa> you'll probably get fast enough on a lot of hardware without mutable update anyway though
07:23:48 <jip> we'll see... but i'm not so sure. i still need to fix a few more cpu bugs and then some actual games should run
07:31:01 <Philippa> remember it's not copying the entire memory range
07:33:42 <cpatrick> GHC will optimise use of a UArray (and presumably a normal Array too) into in-place updates if you compile with -O
07:35:28 <jip> Philippa: does this explain why when i modify an index in the array that is in a far range from where recent updates have taken place, there is a very long pause?
07:35:47 <SamB> cpatrick: how do you mean?
07:38:16 <cpatrick> SamB: if you say 'let aa = a // [(1, 42)]' or whatever and then never refer to the original a again, ghc will optimise this to an in-place mutation
07:39:53 <mahogny> always wondered though, is that done with some compiler hacking (treating Array specially) or does it understand to do that as is?
07:40:50 <cpatrick> mahogny: no idea, I've just observed it in action but am certainly no ghc hacker!
07:41:16 <Philippa> jip: might do, yeah
07:41:41 * mahogny wish there was a smoother step between the old ghc implementation docs and in fact reading the source code
07:51:39 <jip> cpatrick: this is what i'm doing!
07:52:04 <cpatrick> jip: and you're compiling with -O?
07:52:09 <jip> cpatrick: yes
07:52:15 <cpatrick> hrm
07:53:29 <Cale> DiffArray will guarantee in-place updates for single-threaded usage, though accessing old versions of the array gets slow.
07:53:30 <jip> would you like to see my code?
07:54:09 <cpatrick> Cale: my tests had DiffArray being _slower_ than UArray (for simple arrays of integers)
07:54:18 <cpatrick> this is with whatever GHC is in Debian Sarge, btw
07:54:45 <lesshaste> hi
07:54:49 <vincenz> dons: ping
07:54:50 <Cale> cpatrick: how about DiffUArray vs. UArray?
07:54:52 <lesshaste> if I have
07:54:55 <vincenz> FastIO.hs:104:35: Not in scope: `P.copyCStringToFastString'
07:55:16 <Cale> and what was the access pattern?
07:55:22 <lesshaste> data Tree a = Nil|Node a (Tree a) (Tree a) deriving (Eq, Ord, Show, Read)
07:55:29 <lesshaste> what is the ordering that has been derived?
07:56:10 <Cale> lesshaste: Nil < Node x t1 t2, Nodes are compared lexicographically
07:56:49 <lesshaste> Cale: so two trees are compared in lexicographic order? Which order is the traversal to do this?
07:57:07 <Cale> i.e. Node x t1 t2 < Node y s1 s2 if x < y or if x == y, and t1 < s1, or if x == y, t1 == s1, and t2 < s2
07:57:21 <lesshaste> got you
07:57:22 <lesshaste> thanks!
07:57:37 <lesshaste> so basically preorder
07:57:42 <Cale> yes
07:57:59 <lesshaste> one step up the learning curve :)
07:59:09 <Cale> If you're curious, you can get specifications for derived instances in the Report. http://haskell.org/onlinereport/derived.html
08:00:05 <lesshaste> thanks
08:03:54 <jip> if anyone is interested i've put the code up. i'd be happy to hear suggestions:
08:03:55 <jip> http://www.mutantlemon.com/omegagb/snapshots/20060414/
08:05:00 <musasabi> What was the way to get a temporary pointer to the inside of an IOUArray in GHC ?
08:06:39 <roconnor> jip, looks pretty nice
08:07:36 <Cale> Using Philippa's abstract monads I see :)
08:07:47 <Philippa> "abstract"? :-)
08:08:36 <Cale> Philippa: well, hmm, perhaps I should say "formal" rather than abstract? :)
08:09:33 <Philippa> so they'd be 'more concrete' given the version where you fuse constructors and interpreter? :-)
08:09:46 <Philippa> aka the version that confuses the hell out of most readers who aren't used to that kind of code?
08:09:54 <Cale> The monad operations are part of the type anyway, so they have trivial implementations.
08:10:18 <xerox> Ah Cale, I had something to tell you...
08:10:57 <vincenz> ouch
08:11:04 <vincenz> I'm getting segfaults
08:11:49 <xerox> Cale: carefully thinking about the motto "Monads improve composability", it seems like that in fact it's a rip-off.
08:12:05 <Cale> xerox: hm?
08:12:29 <xerox> That is, it's just that monads are the "only" way to compose programs together, without a "whole program transformation" like that, you get values of incompatible types as "programs", no?
08:13:14 <Cale> xerox: er... I'm not completely sure I understand what you're saying
08:13:52 <xerox> Do you remember when we got into Nymphaea core the monadic code?
08:14:19 <Cale> yeah
08:14:42 <xerox> OK, what other ways to achieve *that* kind of composability could we have gone for?
08:15:36 <Cale> well, we could have used any other sort of typeclass which abstracted out the basic operations we were using
08:16:08 <Cale> almost certainly we could have used arrows
08:16:12 <xerox> Hmm.
08:16:28 <Cale> or made up our own
08:16:32 <xerox> Yes, that's not the point I was trying to make.
08:16:52 <Cale> or we could have taken the abstracted out operations as parameters
08:16:53 <Philippa> if you used monads you could've used arrows by definition, but hey :-)
08:17:15 <vincenz> xerox: you could've used c and assembly too
08:17:39 <Cale> vincenz: well, that would have been harder :)
08:17:49 <xerox> It seems to me that the boundary between "explicitly doing something" like using monads/arrows/whatever-you-roll-up-on-your-own and using a language where the "kind" of "things" are the same for everyone (like objects in a lisp context), is... 
08:18:20 <xerox> "isn't", maybe :-)
08:18:24 <vincenz> is it possible to let lambdabot give dons a message?
08:18:31 <xerox> Except that in the first case one has to do the work manually.
08:19:02 <vincenz> or should I email dons?
08:19:09 <xerox> Email.
08:19:23 <Philippa> xerox: it's damn useful if you have multiple explicitly-doing-something systems
08:19:31 <Cale> xerox: I suppose we could have used some other kind of polymorphism
08:19:41 <xerox> Philippa: I think so too.
08:19:55 <Philippa> though I agree if you write an entire program in the IO monad then modulo laziness you may as well've used an ML
08:19:59 <Cale> xerox: In OO, we would have used something like subtype polymorphism
08:20:08 <xerox> Cale: I agree that that one was very convenient.
08:20:21 <Cale> I think it would help for everyone to know the example we're talking about :)
08:20:23 <xerox> Philippa: ML as in, the language?
08:21:12 <Philippa> the family of languages, yeah
08:21:16 <xerox> Right, sorry.
08:21:31 <xerox> Philippa: but do you mean you can do "more" if you don't?
08:21:41 <Cale> basically, the application was expanding non-deterministic L-Systems
08:21:54 <Philippa> you can do more safely if you don't, certainly
08:22:00 <xerox> I see.
08:22:05 <Cale> We abstracted out the non-determinism into a monad, which let us do all sorts of neat tricks.
08:22:21 <Philippa> non-det and IO are an awkward mix, so forcibly keeping them separate is good
08:22:26 <xerox> For very high values of neatness.
08:22:47 <xerox> Philippa: my main concern in this moment is about composability.
08:23:05 <xerox> At any level, expecially between different programs.
08:23:22 * Igloo scrutinises http://icfpcontest.org/teaser.gif
08:23:30 <Cale> (such as choosing an appropriate monad for randomly selecting results with weighted probabilities, and the l-system expanding code didn't have to change, only the input to it)
08:23:43 <xerox> For example, how would you describe the kind of composability the lisp system give you using the same kind of objects everywhere?
08:23:48 <Philippa> I think it helps avoid misleading you about composability when underlying models're different. I don't know if that's really what you're after though
08:23:49 <vincenz> Igloo: they have a teaser?
08:23:50 <vincenz> oooh
08:23:55 <Philippa> "big f*ckin' mess" :-)
08:23:56 <vincenz> oh that..
08:23:59 <xerox> heh.
08:24:09 <xerox> Yes, that last sentence of Cale sums it up pretty nicely.
08:24:17 <xerox> That was enlightening.
08:24:38 <Philippa> although good for a first pass at 'generic' code?
08:24:40 * Philippa nods
08:24:47 <Philippa> interfaces-for-semantics good
08:25:04 <Cale> xerox: well, lispish things give you lots of composability, but also no guarantees of any kind
08:25:04 <xerox> So one could argue that having to explicitly do something isn't just added work, but added power.
08:25:06 <Philippa> monads get more powerful when you apply all the other sweng techniques we already have to them
08:25:23 <xerox> Cale, right, a compromise.
08:25:44 <Philippa> lisp = a bottomload of composability?
08:25:58 <Cale> However, one could say the same thing about string-rewriting systems. :)
08:26:11 <xerox> What do you mean?
08:26:39 <Cale> Composability isn't too impressive if you don't get some guarantees about correctness while you're at it
08:26:53 <xerox> I suppose that is a matter of taste.
08:27:43 <vincenz> it's a trade-off between flexibility and security
08:27:52 <Cale> Being allowed to compose programs is one thing, actually having it work is another :)
08:27:59 <vincenz> the same argument as dyn vs stat typing
08:28:15 <xerox> Hmm.  Well, apart from what I suppose, is there any objective "impressive" thing?
08:28:17 <Philippa> well duh, we're talking about a particularly interesting example of static typing
08:28:35 <Philippa> there's a feeling with haskell of being able to merge many universes sometimes
08:29:42 <Cale> Laziness gets you lots of (safe!) composability that you don't have even in (strict) languages which are untyped.
08:29:57 <xerox> But if you think from the perspective of the person who writes some code, and then wants to add debugging "prints" here and there, having to transform the whole program... where did the composability go?
08:30:02 <Philippa> you can do things that /couldn't possibly compose/ and know that you can avoid the impossible being expected
08:30:12 <Philippa> Debug.Trace. HTH HAND ;-)
08:30:35 * xerox stabs Philippa's acronyms
08:30:36 <Philippa> if you wanted to do something else, then that's what things like monad transformers're for. Typeclasses/interfaces are your friends. etc etc.
08:30:57 <vincenz> what is HTH HAND
08:30:58 <Philippa> xerox: "Hope That Helps, Have A Nice Day"
08:31:11 <xerox> Unfair :-P
08:31:23 <vincenz> be nice if everything was typeclassed
08:31:26 <xerox> Cale, right, laziness.
08:31:26 <vincenz> then you could define a 
08:31:32 <vincenz> DebugInt = Debug Int
08:31:38 <vincenz> and then overload all the operators to trace
08:31:44 <vincenz> or some other type
08:31:44 <Cale> debugging prints have less meaning in a non-strict language with undefined evaluation order anyway
08:31:55 <xerox> Cale, do laziness without strong types make any sense?
08:32:06 <vincenz> xerox: scheme streams
08:32:07 <Cale> strictly speaking, they're a cheap hack, even for debugging purposes :)
08:32:18 <Cale> xerox: sure, though it might get tough to understand :)
08:32:25 <xerox> vincenz: I know those, but I never used them when I was Scheme-ing.
08:32:53 <Philippa> it makes as much sense as anything else without strong types IMO
08:33:06 <mahogny> haskell without type checking = death wish
08:33:32 <Philippa> yeah, but I could say the same of ML when writing equivalently complex code
08:33:38 <Cale> When I wrote some code in lisp, I used macros in exactly two ways: constructing laziness, and something like do-notation for a monad.
08:34:53 <xerox> I think I'm now assured that metaprogramming isn't only academic masturbation now.
08:35:00 <xerox> Oops, too many nows.
08:35:03 <Cale> (but that's sort of off-topic)
08:35:37 <Cale> Metaprogramming is certainly useful, if it's sufficiently convenient :)
08:36:22 <Cale> Metaprogramming in something like C is likely not too useful :) (Unless you count writing a compiler for a better language for yourself :)
08:36:36 <xerox> It would be nice to try to think about how to superseed Haskell.
08:36:52 <xerox> Wait, I made up a word.
08:37:02 <Cale> supercede
08:37:07 <Cale> er
08:37:15 <xerox> Yes, that.
08:37:38 <xerox> Like "supplant", but with a "going further on" meaning :-)
08:38:00 <Philippa> Epigram's certainly one option
08:38:02 <Cale> sorry
08:38:06 <Cale> supersede
08:38:16 <Cale> hm?
08:38:24 <xerox> ops.
08:38:26 <Philippa> there's a structure I need to do some thinking about that's kind of a mesh-with-monads-as-edges
08:38:47 <Cale> I think that you don't necessarily need a revolution
08:38:49 <xerox> Oh-uhm.
08:38:51 <Philippa> (and thus with the langs described as nodes)
08:38:58 <Cale> Haskell is not just one language :)
08:38:59 <xerox> Cale: agreed!
08:39:11 <xerox> I'm not talking in marxist terms :-)
08:39:20 <Philippa> yeah, a haskell'' could do pretty well on sufficient staging, an improved enough type system and good module and record systems
08:39:50 <Cale> I really would like to see a real record system, if only to make interaction with the outside world easier
08:39:55 <xerox> Just say, practically, something in order to avoid explicit (>>=)... or dunno, thinking the future would be fun.
08:40:02 <Cale> It carries the problem that people might actually use it :)
08:40:26 <Cale> I wouldn't want implicit monads
08:40:39 <Philippa> I think if we could find a way to make Daan Leijen's lexically-scoped labels work in a way that can look like the current system that'd be cool
08:40:59 <xerox> Cale, I mean, (>>=) makes something implicit, right?  Let it be whatever simple thing you have in mind.
08:41:02 <Philippa> I'd want that in a language based around the structure I described, I think
08:41:13 <Philippa> *thinks longer*
08:41:17 <xerox> If we suppress (>>=) like the details it suppresses, maybe something new would appear... useful?
08:41:32 <Philippa> hrmm, crap. There's two uses of the "source language" in the standard signiature, the >>= one's harder to deal with than return I guess
08:41:59 <Philippa> heh, you might end up with a need for a 'transitive return' if you had the right/wrong set of instances, too
08:42:12 <Cale> xerox: I'm assuming you mean implicit in a deeper way than do-notation makes it implicit?
08:42:23 <xerox> Cale: your assumption is right.
08:42:27 <Cale> I really think that monadic code should look different from ordinary code
08:42:39 <Cale> (for some definition of ordinary code)
08:43:51 <xerox> Yes, I think it's fair.
08:44:19 <xerox> One way to see >>= is a series of lambdas stacked together to make sequentiality, right?
08:44:25 <robokop> how can i (in wxHaskell) set my statusbar text to its old value after i hover over a menu item
08:44:54 <xerox> I don't really know anything about wxWindows sorry :-(
08:45:22 <robokop> sb else who can give me a hand
08:45:27 <roconnor> @google haskell QT
08:45:29 <lambdabot> http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/18915
08:45:57 <xerox> ``Composing >>= to achieve... something new.''
08:46:11 <Cale> Philippa: ah, I was going to ask what you thought about that record system, having forgotten that it was Daan Leijen's and actually the one you were referring to
08:46:42 <Philippa> I like the look of it
08:46:47 <musasabi> The Daan's system looked very clean.
08:47:04 <Philippa> I suspect you can pull some fancy kinding stunt to allow algebraic datatypes to 'have fields', too
08:47:30 <Philippa> with the idea being that fields can be allowed to 'fall through' a data constructor
08:47:44 <Cale> yeah, I really think it ought to be the one we adopt, if we're going to have a record system at all
08:48:00 <Cale> records are a bit evil in a functional language
08:48:07 <Philippa> (the hacky solution being that if a data constructor has only one parm which is a record, the fields 'fall through')
08:48:11 <musasabi> It would be very nice for database and XML stuff.
08:48:19 <Cale> right
08:48:40 <Cale> it's nice for interfacing with the outside world, where most of the languages are taking the dual perspective on programming :)
08:48:41 <Philippa> though that obviously retains the old system's lack of safety
08:49:01 <Cale> (OO and relatives)
08:49:07 <xerox> Lemmih: are you left-handed? (-:
08:49:54 <musasabi> Philippa: I think data should keep things opaque. Just write type Foo = <insert-closed-record-type-here>
08:50:26 <Lemmih> xerox: huh?
08:50:57 <xerox> Lemmih: I was wondering about the reverse smiles :-)
08:51:32 <xerox> They're especially cool because they don't get caught, yet, in the smile-to-picture matching :-)
08:51:35 <Philippa> musasabi: I'd like to have all the common fields fall through sometimes, if we're breaking compatability
08:51:54 <Cale> I don't think that Daan's system should replace the current system
08:52:28 <Philippa> I think you can't truly do it all right 'til you've got a form of subtyping on algebraic datatypes too. I may be crazy though
08:53:25 <musasabi> letting the classic records slowly die and having real records on the side would be the easiest way.
08:53:34 <Lemmih> xerox: Oh. No, I'm right handed. Plus, it's the rest of the world that's reversed, not me (:
08:54:15 <xerox> Lemmih: Maybe you write bottom-to-top :-)
08:54:33 <Philippa> you can't do that /and/ keep some of the neat duality-exploiting tricks that could be pulled though, because the existing system hogs relevant points in the design space
08:54:45 <jyp> Philippa: Most record system have intrinsic structural subtyping 
08:54:49 <jyp> As I see it.
08:55:20 <Philippa> jyp: sure. Now consider what happens when you're working with a sum-of-records type
08:55:22 <xerox> Talking of ways of writing, I'm looking forward to implement a boustrophedon editor.
08:55:37 <xerox> Well, a reader would be enough atm.
08:55:43 <Philippa> suppose that's the natural structure for a problem: you need pattern-matching sometimes too
08:55:50 <xerox> Unicode has something for that, but I can't find a way to mirror glyphs properly!
08:56:07 <jyp> Philippa: Daan's paper mentions variants as well. Wouldn't that be what we need ?
08:56:25 <Philippa> not if you don't have a solution for nominal typing as well
08:56:45 <jyp> Though I guess replacing sum types is out of question :)
08:57:06 <jyp> I see.
08:57:14 <Philippa> Somewhat :-) Though having them with structural subtyping has its uses - event-driven systems in particular
08:57:38 <jyp> It looks like the mix of structural and named subtyping is the messy part.
08:57:40 <xerox> To read about boustrophedon <http://traevoli.com>.
08:58:38 <xerox> In fact HTML supports <p dir="rtl">..</p>, but it only changes, say, the "alignment", it doesn't mirror the paragraph :-\
09:02:41 <xerox> Unicode do have something for that, it seems <http://www.unicode.org/reports/tr9/>
09:03:12 <xerox> I don't know at what level of code one could implement the mirror-glyph algorithm.
09:03:42 <vincenz> @type mapN_
09:03:44 <lambdabot> Not in scope: `mapN_'
09:03:44 <vincenz> @type mapM_
09:03:46 <lambdabot> forall (m :: * -> *) a b.
09:03:46 <lambdabot>    (Monad m) =>
09:03:46 <lambdabot>    (a -> m b) -> [a] -> m ()
09:04:17 <xerox> They do provide a txt mapping the mirrorable glyphs to their mirrored counterparts...
09:04:30 <Lemmih> dons: ping.
09:08:50 <greenrd> Has anyone here used Chameleon (the Haskell-like language, not the Java-like language)?
09:16:15 <xerox> What's that?
09:20:54 <akemp> Lemmih: you around?
09:22:38 <Lemmih> akemp: Yes.
09:23:05 <akemp> I gave up on ghc-darcs and am noodling with cabal-get on 6.4.2.  Wanted to ask some build advice.
09:24:03 <akemp> I grabbed the cabal-get-bootstrap from hackage, but the source directories (gpg, cabal-get, hackage-client) don't contain any source, so can't compile.  What am I missing?
09:25:21 <Lemmih> Doesn't the bootstrap contain a build script?
09:26:04 <greenrd> xerox, it's like Haskell but it uses constraint handling rules instead of functional dependencies, I think
09:26:05 <akemp> Install.lhs?  that worked well until it got to gpg.  Since gpg doesn't have any source, Install.lhs fails at that point.
09:26:54 <akemp> check out http://hackage.haskell.org/darcs/cabal-get-bootstrap/GnuPG-0.1.1/System/.  There's nothing in that directory.
09:28:00 <Lemmih> akemp: That's weird.
09:28:31 <Lemmih> akemp: You can get the missing packages here: http://darcs.haskell.org/~lemmih/
09:29:01 <akemp> Ah...  I've been trying to get to scannedinavian.org/~lemmih.  
09:34:33 <robokop> how can i (in wxHaskell) set my statusbar text to its old value after i hover over a menu item
09:35:21 <Lemmih> Isn't the statusbar like a stack?
09:36:07 <robokop> nope it gets empty after i leave my menu item with my mouse
09:36:14 <mahogny> is it only me, or is wxhaskell draw performance horrible? (I draw 50x50 rects to screen, and I bet it takes 0.5s+)
09:36:33 <mahogny> what can I do to optimize?
09:36:59 <xerox> Cale, Philippa: Daan's records are lists on steroids, very nice (-:
09:37:15 <robokop> mahogny: is that compiled version or in ghci
09:38:00 <mahogny> robokop, both
09:38:23 <robokop> mahogny dunno then
09:38:32 <mahogny> actually, it seems to me that it calls repaint way too often. even when I shrink the window
09:39:14 <mahogny> would it be faster if I created my own drawing area and blitted to screen? ("manual" double buffer)
09:54:26 <xerox> shapr: p1ng
09:55:56 <lesshaste> If I have this function on trees
09:56:03 <lesshaste> isLeaf Nil = False
09:56:24 <lesshaste> isLeaf (Node _ t1 t2) = (isLeaf t1) & (isLeaf t2)
09:56:39 <lesshaste> it looks to me that it always returns False...I must be wrong
09:57:14 <lesshaste> isLeaf :: BinTree t -> Bool
09:57:16 <lesshaste> is the type
09:57:19 <Philippa> yeah, consider isLeaf (Node 1 (Node 2 Nil) Nil)
09:57:30 <mahogny> Lemmih, False, or it doesn't terminate :)
09:57:33 <Philippa> er, with an extra Nil
09:57:46 <xerox> Philippa: do we have an Haskell extension for Daan's records?
09:57:49 <lesshaste> so it's broken??
09:57:52 <Philippa> xerox: nope
09:57:55 <xerox> Awww.
09:58:21 <mahogny> anyone know how fast an FFI call is?
09:58:25 <xerox> What is Haskell out there for if we don't get the cool extensions!!! (-:
09:58:49 <Philippa> xerox: it's v.early days and it's not quite as trivial to implement as it could be either
09:58:50 <xerox> mahogny: I think the GHC manual says something about that.
09:58:55 <mahogny> hm
09:59:00 <mahogny> no one know from experience?
09:59:00 <bolrod> @type foldl'
09:59:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:59:08 <bolrod> @hoogle foldl'
09:59:09 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
09:59:11 <lesshaste> any idea what isLeaf should look like?
09:59:30 <xerox> It depends upon your Tree definition.
09:59:33 <lesshaste> mahogny: sorry.. I meant that for you :)
09:59:45 <lesshaste> data BinTree t = 
09:59:45 <lesshaste>      Nil | Node t (BinTree t) (BinTree t)
09:59:45 <lesshaste> 	deriving Show
09:59:55 <bolrod> Module `List' does not export `foldl''   << ?\
10:00:00 <bolrod> oh
10:00:01 <bolrod> sorry
10:00:01 <bolrod> -.-
10:00:04 <xerox> isLeaf Nil = True
10:00:07 <xerox> isLeaf _ = False
10:00:08 <xerox> maybe?
10:00:11 <mahogny> yeah
10:00:22 <lesshaste> hmm.. that looks simple  :)
10:00:31 <xerox> Well, those seem to be the leaves.
10:00:46 <xerox> There are also trees whose leaves carry values, but that doesn't seem to be your case.
10:01:04 <Lemmih> mahogny: A FFI call in GHC is pretty fast. Not nearly as fast as a call to a Haskell function, though.
10:01:20 <lesshaste> xerox: they will when they become binary search trees I suppose
10:01:21 <mahogny> Lemmih, well. would 2500 calls take half a sec?
10:01:34 <mahogny> Lemmih, is it in the right order of magnetude? :)
10:01:39 <xerox> Philippa: is it because the type system extension?
10:02:09 <lesshaste> xerox: but the bottom line is that there is no way isLeaf as set it out can return True right?
10:02:25 <xerox> lesshaste: nope.
10:02:37 <Philippa> xerox: not just that. Getting a fast implementation of the actual record ops is tricky
10:03:04 <xerox> lesshaste: isLeaf (Node undefined Nil Nil) ==> True
10:03:04 <Lemmih> mahogny: Maybe, I'm not sure.
10:03:08 <lesshaste> xerox: ok thanks... back to the drawing board.. I hate it when lecture notes have bugs :)
10:03:21 <mahogny> Lemmih, hm. ok. benchmarking time then
10:03:22 <xerox> lesshaste: drawing board sounds fun (-:
10:03:35 <lesshaste> xerox:  isLeaf (Node undefined Nil Nil) ==> True  that's interesting
10:04:01 <xerox> Also, it's (&&) not (&), but I suppose that was just a typing error ;-)
10:04:09 <lesshaste> xerox: sadly no...grrr
10:04:15 <xerox> ?type (&&)
10:04:17 <lambdabot> Bool -> Bool -> Bool
10:04:22 <lesshaste> xerox: why does  isLeaf (Node undefined Nil Nil) evaluate to true?
10:04:26 <vincenz> ?type (&)
10:04:27 <lambdabot> Not in scope: `&'
10:04:39 <xerox> lesshaste: try substituting the definitions into.
10:05:03 <lesshaste> xerox: I did :) I wasn't sure if _ matched undefined
10:05:16 <xerox> It's just that _ matches everything.
10:05:27 <xerox> But it doesn't bind it, so that it remains unevaluated.
10:05:43 <lesshaste> xerox: ok. so I get (IsNil Nil) && (isNil Nill)
10:05:49 <lesshaste> xerox: which is False && False
10:05:50 <xerox> Hence I chosen the undefined, I could have written everything, but I thought it was what fit better (-:
10:06:00 <lesshaste> xerox: which is False
10:06:02 <xerox> How is isNil Nil ==> False ?
10:06:21 <lesshaste> oops!
10:06:27 <xerox> I think ski could come up with a logic in which it would make sense, but... (-;
10:06:50 <Cale> what code are we talking about?
10:06:53 <lesshaste> ah.. so a leaf here is something with two Nil children!
10:06:58 <lesshaste> ok.. that's not broken
10:07:03 <xerox> lesshaste: exactly.
10:07:08 <Cale> In the code above, yes
10:07:24 <lesshaste> xerox: I got completely confused and read IsLeaf for IsNil...
10:07:25 <lesshaste> thx
10:07:39 <lesshaste> so it's just the & on that slide :)
10:08:10 <xerox> Maybe the typo is due to program-specific bogglery... dunno.
10:08:16 <lesshaste> ok
10:08:24 <xerox> Like in TeX you have to escape some sequences in order to get them displayed properly.
10:08:49 <xerox> Moin roconnor.
10:09:08 <lesshaste> understood
10:09:14 <xerox> Cale: it would be nice to have a Daan's records extension, woudln't it?
10:09:21 <xerox> wouldn't, rather.
10:10:25 <Rob|dishes> how can i (in wxHaskell) set my statusbar text to its old value after i hover over a menu item
10:10:49 <lesshaste> one more thing... 
10:10:50 <lesshaste> setKey t (getKey t) == t
10:10:50 <lesshaste>    IF isNil t == False
10:10:56 <lesshaste> is that in correct Haskell?
10:12:07 <lesshaste> the "IF" seems odd
10:12:17 <astrolabe> looks like funny capitalisation
10:12:33 <astrolabe> on 'if' and 'false'
10:13:03 <astrolabe> but I can't parse it anyway, so maybe I'm misunderstanding.
10:13:26 <vincenz> @hoogle Char8
10:13:28 <lambdabot> No matches found
10:13:29 <vincenz> @hoogle Word8
10:13:30 <lambdabot> Data.Word.Word8 :: data Word8
10:13:38 <vincenz> how do I convert Word8 to interger?
10:14:11 <astrolabe> @type fromInt
10:14:13 <lambdabot> Not in scope: `fromInt'
10:14:14 <astrolabe> I'm guessing
10:14:26 <Lemmih> > fromIntegral (10 :: Word8) :: Integer
10:14:27 <lambdabot> 10
10:14:32 <astrolabe> Ah :)
10:15:58 <Cale> xerox: yeah
10:23:42 <akemp> Lemmih: okay, I got cabal-get to build (the top level Install.lhs still crapped out on "missing Main").  Now cabal-get is returning "Unknown Compiler". 
10:26:09 <akemp> Lemmih: I'm using 6.4.2.  Any idea what "cabal-get: Unknown compiler" means when I do "./cabal-get info"
10:26:29 <Lemmih> akemp: Try running 'cabal-get update' first.
10:26:47 <akemp> Lemmih: same error code.
10:26:58 <palomer> oh no! I accidently deleted a file in darcs
10:27:06 <palomer> err, not in darcs
10:27:08 <palomer> in my repo
10:27:15 <palomer> how do I get darcs to reload it?
10:27:26 <jyp> darcs repair or something
10:27:41 <jyp> yup. darcs repair
10:28:06 <palomer> but it's not corrupted
10:28:11 <palomer> anyways, I just want to reload that one file
10:28:18 <jyp> darcs revert?
10:28:39 <palomer> but I don't want to lose all the work I've done
10:28:48 <jyp> darcs revert <file>
10:30:31 <Lemmih> akemp: Hm, did you copy dot-cabal-get to ~/.cabal-get?
10:30:42 <akemp> Lemmih: yessir
10:32:40 <akemp> Lemmih: Install.lhs failed at the last minute with "setup: Main doesn't exist"
10:33:14 <akemp> Lemmih: that is the cabal-get-bootstrap/Install.lhs failed.
10:34:18 <Lemmih> akemp: What does 'cabal-get -v update' say?
10:35:10 <akemp> Lemmih: ooops.  In cabal-get-0.3.0, "runghc Setup.lhs build" fails with "Main doesn't exist".
10:35:58 <akemp> Lemmih: any time I enter cabal-get with an argument, it fails.  cabal-get --help is the only thing that works.  
10:37:35 <Lemmih> akemp: Try --ghc or --with-compiler
10:44:30 <akemp> Lemmih: wacky.. .  Just did a clean build of cabal-get/Setup.lhs using "ghc --make".  That went fine.  "./setup configure" goes fine.  "./setup build" fails at the last minute with "setup: Main doesn't exist".
10:44:44 <palomer> my computer has gone nuts
10:45:32 <palomer> wow my computer is going bonkers
10:45:47 <palomer> it just replaced a source file with a binary file
10:45:52 <palomer> I think it's time to buy a new hard disk
10:46:32 <Saulzar> ghc foo.hs -o foo.hs is not the right syntax?
10:49:44 <Cale> Saulzar: hehe
10:49:51 <Cale> ghc foo.hs -o foo
10:51:59 <palomer> grr
10:52:04 * palomer hates it when his computer goes bonkers
10:52:34 <jyp> ghc-6.5: panic! (the 'impossible' happened)
10:52:47 <akemp> Lemmih: I think that the problem is in cabal-get.cabal.  "Main-is: Main" should be "Main-is: Main.hs".
10:52:51 <jyp> This brings my morale down :/
10:54:59 <Lemmih> jyp: What bug did you trigger?
10:55:27 <jyp> Fortunately I think I was just being stupid.
10:55:30 <jyp> ;p
10:56:01 <jyp> There seems to be a bug in the way package definition files are handled
10:56:19 <jyp> Fails instead of reporting the error correctly.
10:56:54 <Lemmih> Did you edit the package.conf file manually?
10:57:06 <jyp> package.conf.in
10:57:19 <jyp> Forgot a comma.
10:58:24 <Lemmih> What are you working on?
10:58:53 <jyp> Package of new collections types and class-hierarchy
10:59:21 <jyp> The missing comma was just a surface problem however.
10:59:45 <jyp> The thing is, I think I don't understand what the "exposed-modules" is supposed to specify
11:00:51 <jyp> <Lemmih> And we need to use the GHC api to verify that Exposed-modules +
11:00:51 <jyp> Other-modules actually cover all the needed modules.
11:01:01 <Lemmih> Wait, are you working on the standard libraries or GHC?
11:01:09 <jyp> standard libraries
11:02:11 <Lemmih> Then why are you modifying a config file? All the standard libraries are cabalized.
11:02:16 <Lemmih> (or so I thought)
11:02:34 <jyp> Well, that might be something else I missed
11:03:05 <jyp> But afaict, the build system currently uses package.conf.in
11:03:26 <Lemmih> The GHC build system, yes. You don't need to change that.
11:03:54 <Lemmih> You're working on base, right? Then you need to change libraries/base/base.cabal.
11:05:15 <jyp> Is libraries/base/package.conf.in supposed to be generated on the basis of libraries/base/base.cabal ?
11:06:07 <jyp> The contents differ...
11:06:41 <jyp> It looks like non-GHC modules are commented out in the cabal file.
11:06:56 <jyp> From that I deduced that both had to be maintained
11:08:51 <Lemmih> Hm, I'm confused.
11:09:06 <jyp> In any case Lemmih, is there a documentation that explains what exposed-modules, hidden modules and so on are for exactly?
11:09:23 <jyp> The cabal documentation seem to talk about exposed-modules only.
11:10:37 <Lemmih> Hidden modules can't be accessed from out side of the package.
11:12:14 <jyp> So, all the modules that I want linked-in have to be either in hidden or exposed, but hidden won't be visible outside.
11:12:19 <jyp> Ok, thanks :)
11:13:38 <jyp> I think that subtle bug remains that confused me.
11:46:07 <mahogny> I want C-style truncation of float to int. which command to use?
11:47:29 <musasabi> truncate 3.4
11:47:31 <musasabi> > truncate 3.4
11:47:32 <mahogny> ok
11:47:32 <lambdabot> 3
11:47:34 <mahogny> thx
11:47:48 <xerox> > showFFloat (Just 10) pi ""
11:47:49 <lambdabot> "3.1415926536"
11:47:55 <xerox> Ah, okay :-)
11:48:16 <musasabi> Text.Printf is nice if you have lots of float formatting.
11:51:03 <jip> > show pi
11:51:04 <lambdabot> "3.141592653589793"
11:51:18 <jip> > showFFloat (Just 100) pi ""
11:51:19 <lambdabot> "3.1415926535897930000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
11:55:12 <Rob|dishes> how can i (in wxHaskell) set my statusbar text to its old value after i hover over a menu item
12:00:16 <Lemmih> Rob|dishes: How about asking on the wxhaskell mailing list?
12:00:32 <Lemmih> Rob|dishes: Or look at a wxwidgets tutorial.
12:01:27 <Rob|dishes> looked in tutorial but couldn't find it there
12:17:33 <Cale> Rob|dishes: maybe just set the property again?
12:19:23 <jip> hm... turns out i'm gonna have to implement quite a bit more of of the IO registers i thought i would have to at first :\
12:21:11 <Rob|dishes> Cale: how should i check if the mouse entered and left a menu item
12:21:19 <jyp> jip: what are you emulating?
12:21:27 <jip> jyp: gameboy
12:22:08 <jyp> At least there's no hard disk... ;p
12:22:33 <jip> :D it's the simplest console that has good games
12:23:05 <jip> jyp: you can see my code at http://www.mutantlemon.com/omegagb/snapshots/20060414/ please tell me what you think
12:23:38 <jyp> Do you have a debugger?
12:23:52 <jip> jyp: what do you mean?
12:24:24 <jyp> Can you trace the execution inside the emulator? (put breakpoints, etc.)
12:24:47 <jyp> I found it's quite handy to debug and emulator.
12:24:54 <jyp> s/and/an
12:25:03 <xX[ReP]Xx> http://code.google.com/summerofcode.html
12:25:17 <jip> jyp: well, if you look at the code you can see that it's designed in such a way to make that kind of thing very easy to add
12:25:28 <jyp> jip: Ah, good
12:33:14 <jyp> jip: You'll probably have to emulate LCD + sound + buttons
12:33:27 <jyp> I guess the cartidge is memory mapped ?
12:36:36 <jip> jyp: yeah, but most cartridges have multiple banks
12:37:19 <jip> i'm trying to get the LCD interrupts working now but it's hard to understand the exact semantics from the scraps of info that is online :\
12:37:54 <jyp> There is a GPL'd emulator I think
12:38:56 <jip> yeah gnuboy
12:39:16 <jip> but i don't feel like reading c code :\
12:39:56 <jyp> Good C code is easier to read than bad docs :)
12:40:17 <jyp> I don't know the qualities of either, mind you.
12:40:35 <jip> i guess... what do you suppose "clks" means?
12:40:44 <jyp> clock ticks?
12:48:39 <Ulfalizer> hmm, i wonder why  0 ** x  gives an error even when x != 0
12:49:01 <jip> > 0 ** 3
12:49:02 <lambdabot> 0.0
12:49:09 <jip> > 0 ** 0
12:49:10 <lambdabot> 1.0
12:49:14 <Ulfalizer> with hugs it does
12:49:27 <Ulfalizer> Program error: argument out of range
12:49:31 <Cale> > 0^0
12:49:32 <roconnor> > 0 ** (-1.0)
12:49:32 <lambdabot> 1
12:49:34 <lambdabot> Infinity
12:49:43 <roconnor> > 0 ** (-pi)
12:49:44 <lambdabot> Infinity
12:49:57 <Ulfalizer> ah, i get it now
12:50:37 <Cale> hugs gives an incorrect result for 0 ** 0
12:51:08 <Ulfalizer> maybe 0 doesn't get treated like 0 but as a very small number, and so the result falls outside of what can be represented by the data type. that would be pretty wierd though, since the ieee standard can represent 0 exactly..
12:51:09 <Cale> actually, it doesn't seem able to do 0 ** x for any x.
12:51:45 <jyp> > 2.78 ** (0 :+ (-pi))
12:51:46 <bolrod> > 1 {-test-}
12:51:47 <lambdabot>  Not in scope: data constructor `:+'
12:51:47 <lambdabot> 1
12:51:59 <jyp> > 2.78 ** (0 Complex.:+ (-pi))
12:52:00 <lambdabot>  Not in scope: data constructor `Complex.:+'
12:52:08 <jyp> > 2.78 ** (0 Data.Complex.:+ (-pi))
12:52:09 <lambdabot>  Not in scope: data constructor `Data.Complex.:+'
12:52:18 * jyp grumbles
12:52:19 <bolrod> @hoogle :+
12:52:20 <lambdabot> Complex.(:+) :: RealFloat a => a -> a -> Complex a
12:52:20 <lambdabot> Data.Complex.(:+) :: a -> a -> Complex a
12:52:51 <bolrod> > 2.78 ** (0 `Data.Complex.(:+)` (-pi))
12:52:52 <lambdabot>  parse error on input `.'
12:53:00 <bolrod> hrm
12:53:10 <bolrod> > 2.78 ** (Data.Complex.(:+) 0 (-pi))
12:53:11 <lambdabot>  Not in scope: data constructor `:+'
12:53:14 <Cale> > 2.78 ** (0 Data.Complex.:+) (-pi))
12:53:15 <lambdabot>  parse error on input `)'
12:53:19 <bolrod> -.-
12:53:20 <Cale> > 2.78 ** (0 Data.Complex.:+) (-pi)
12:53:21 <lambdabot>  Not in scope: data constructor `Data.Complex.:+'
12:53:29 <Ulfalizer> yup,  1e-400 ** 2  gives the same error in hugs
12:53:30 <Cale> > 2.78 ** (0 Data.Complex.:+ (-pi))
12:53:31 <lambdabot>  Not in scope: data constructor `Data.Complex.:+'
12:53:56 <bolrod> > 2^317 ::Float
12:53:57 <lambdabot> Infinity
12:54:01 <bolrod> > 2^7 ::Float
12:54:02 <lambdabot> 128.0
12:54:13 <bolrod> > 10*10^100 ::Float
12:54:15 <lambdabot> Infinity
12:54:19 <bolrod> riight
12:54:22 <bolrod> -.-
12:54:44 <roconnor> > 10*10^100 ::Double
12:54:45 <lambdabot> 1.0000000000000003e101
12:54:55 <bolrod> ahyeah
12:55:02 <bolrod> that is the weird error
12:55:08 <Ulfalizer> > 1e-400 ** 2
12:55:09 <lambdabot> 0.0
12:55:13 <Ulfalizer> > 1e-800 ** 2
12:55:14 <lambdabot> 0.0
12:55:20 <bolrod> 0.0
12:55:34 <Cale> > 1e-100 ** 1e-100
12:55:35 <lambdabot> 1.0
12:55:54 <bolrod> duhhhhhhh
12:56:02 <bolrod> @type **
12:56:03 <lambdabot> parse error on input `**'
12:56:07 <bolrod> @type (**)
12:56:09 <lambdabot> forall a. (Floating a) => a -> a -> a
12:56:16 <bolrod> > 2**2
12:56:18 <lambdabot> 4.0
12:56:27 <jyp> > exp pi
12:56:28 <lambdabot> 23.140692632779267
12:57:26 <bolrod> > pi/1e-20
12:57:27 <lambdabot> 3.1415926535897933e20
12:57:34 <bolrod> > pi*1e-20
12:57:35 <lambdabot> 3.141592653589793e-20
12:59:07 <jyp> @type (Complex.:+)
12:59:08 <lambdabot> forall a.
12:59:08 <lambdabot>       (RealFloat a) =>
12:59:08 <lambdabot>       a -> a -> Data.Complex.Complex a
12:59:29 <jyp> > exp (0 Complex.:+ pi)
12:59:29 <lambdabot>  Not in scope: data constructor `Complex.:+'
12:59:35 <jyp> wtf
12:59:35 <bolrod> > 1 Complex.:+ 2
12:59:36 <lambdabot>  Not in scope: data constructor `Complex.:+'
12:59:39 <bolrod> >:{
12:59:56 <bolrod> data constructor
12:59:57 <bolrod> hrm
13:00:00 <bolrod> :]
13:00:18 <Cale> the module probably just isn't loaded
13:00:37 <jyp> @load Complex
13:00:37 <lambdabot> Unknown command, try @list
13:00:48 <jyp> He doesn't want to cooperate.
13:00:58 <jyp> Time for retaliation!
13:01:07 <jyp> ;)
13:01:22 <jyp> @girl19
13:01:23 <lambdabot> I'm in Moscow, Russia
13:01:27 <jyp> marf
13:02:07 <bolrod> ?
13:02:35 <jyp> @girl19 hello there
13:02:36 <lambdabot> am I supposed to be frantic with terror and anxiety?
13:02:55 <Cale> @help girl19
13:02:55 <lambdabot> girl19 wonders what "discriminating hackers" are.
13:03:14 <Cale> @keal
13:03:15 <lambdabot> Keal angry @ dons
13:03:18 <Cale> @keal
13:03:19 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
13:04:46 <bolrod> good!
13:04:50 <bolrod> I'm on it
13:05:20 <bolrod> that'd be cool
13:05:34 <Cale> @keal
13:05:34 <bolrod> make the osx text to speach thing answer your phone >:)
13:05:35 <lambdabot> and yes that was with zero formal training in all realms
13:05:47 <Cale> @keal
13:05:47 <lambdabot> all i know is i have experienced my own death unhappening...
13:05:55 <jyp> wow
13:06:34 <Cale> keal is the new yow
13:06:37 <Cale> @yow
13:06:37 <lambdabot> Could I have a drug overdose?
13:06:44 <bolrod> @arr
13:06:44 <lambdabot> I heard andersca is a pirate
13:06:48 <Cale> @yow
13:06:49 <lambdabot> PIZZA!!
13:07:04 <Cale> @. elite yow
13:07:04 <bolrod> @keal
13:07:05 <lambdabot> ThI5 i$ 4 No-FRiLLs fLIGh+ -- HO|D th' (ANAdian BaCON!!
13:07:05 <lambdabot> with KealDigit quantum crackproof encryption possible
13:07:19 <Cale> @. elite keal
13:07:20 <lambdabot> Pri/\/\ArY E|EMEnTal A$5UmPTion OF IN73gER cO3fphIcIen7z to r00ts In (0UntIN9 Sy+E/\/\ Is Wr0n9
13:08:00 <bolrod> :)
13:08:09 <bolrod> @. elite arr
13:08:10 <lambdabot> 3at /\/\aggotY |-|ARd+a(x, y3 Unk3/\/\Pt, JeNNy fREQuEN7In', soN Oph A gUn.
13:09:22 <bolrod> @vixen want to load :+ ?
13:09:22 <lambdabot> i'll hafta plead the fifth on that one.
13:14:15 <jyp> Trying to compile lambdabot leads to
13:14:17 <jyp> make: *** [Modules.hs] Segmentation fault
13:14:23 <jyp> anyone has a clue?
13:22:32 <bolrod> jyp: thats not good...
13:22:53 <jyp> I'll say
13:23:52 <jyp> ./genmodules seems completely broken
13:33:59 <astrolabe> I suppose you're restricted to using ghc?
13:35:12 <jyp> I fixed that one.
13:35:22 <jyp> -fasm is broken with AMD64 in 6.4.1
13:35:38 <jyp> I'm now getting
13:35:48 <jyp> hsc2hs Lib/Regex.hsc
13:35:51 <jyp> make: *** [Lib/Regex.hs] Error 127
13:36:09 <jyp> without any specific error message.
13:39:05 <jyp> hsc2hs -v Lib/Regex.hsc
13:39:05 <jyp> Executing: /usr/local/bin/ghc-6.5 -c Lib/Regex_hsc_make.c -o Lib/Regex_hsc_make.o
13:39:05 <jyp> m
13:39:16 <jyp> Why the hell did it pick that one?
13:51:58 <lisppaste2> BetaTEST pasted "tail recursion with accumulator kills GHCi" at http://paste.lisp.org/display/18998
13:57:20 * Cale looks
13:57:37 <JohnnyL> > [1..0]
13:57:39 <lambdabot> []
13:57:45 <JohnnyL> [10..1]
13:57:51 <JohnnyL> > [10..1]
13:57:52 <lambdabot> []
13:58:04 <JohnnyL> elipsys isn't so smart.
13:58:16 <Cale> > [10,9..1]
13:58:17 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
13:58:34 <JohnnyL> close, but not smart enough.
13:58:35 <JohnnyL> :)
13:58:39 <palomer> Cale: give me a crazy continuous function [0,1] ->[0,1]
13:58:50 <bolrod> f x = x
13:58:55 <bolrod> :]
13:59:07 <Cale> palomer: The Cantor function :)
13:59:15 <palomer> ok, easily computable
13:59:31 <Cale> abs(sin(1/x))?
13:59:43 <Cale> oh, but that's not quite continuous at 0 :)
13:59:46 <BetaTEST> Cale, so, any comments about the paste? :)
13:59:59 <palomer> and it's not very crazy
14:00:38 <Cale> BetaTEST: I don't have any problem with m (product [1..1000])
14:01:17 <Cale> palomer: it's sort of crazy
14:01:50 <BetaTEST> Cale, then you might experience a problem with m (product [1..10000])
14:02:08 <Cale> well, it's not exactly the cheapest computation
14:02:22 <bolrod> > product [1..10000]
14:02:23 <bolrod> well
14:02:23 <bolrod> lets see
14:02:25 <lambdabot> 28462596809170545189064132121198688901480514017027992307941799942744113400037644437729907867577847758158840621423175288300423399401535187390524211613827161748198241998275924182892597878981242531205946
14:02:25 <lambdabot> 59962598670656016157203603239792632873671705574197596209947972034615369811989709261127750048419884541047554464244213657330307670362882580354896746111709736957860367019107151273058728104115864056128116
14:02:25 <lambdabot> 53853259684258259955846881464304255898366493170592517172042765974074461334000541940524623034368691540594040662278282483715120383221786446271838229238996389928272218797024593876938030946273322925705554
14:02:25 <lambdabot> 59690027875282242544348021127559019169425429028916907219097083690539873747452483372899521802363282741217040268086769210451555840567172555372015852132829034279989818449313610640381489304499621599999359
14:02:27 <lambdabot> 67089298019033699848440466541923625842494716317896119204123310826865107135451684554093603300960721034694437798234943078062606942230268188522759205702923084312618849760656074258627944882715595683153344
14:02:28 <bolrod> :)
14:02:30 <lambdabot> [6 @more lines]
14:02:36 <BetaTEST> not cheapest, but not computable
14:02:39 <palomer> spam!
14:02:46 <BetaTEST> *incomputable
14:02:48 <bolrod> it only took some 3 seconds
14:03:17 <BetaTEST> Cale, major problem is death of mm
14:03:36 <Cale> It has to build an expression which has about 1.5 million operands
14:03:47 <jlhamilton> > product [-5 .. -1]
14:03:49 <lambdabot> -120
14:03:49 <Cale> log_2 (100000!)
14:03:54 <Cale> approximately
14:04:29 <BetaTEST> well, that's why i tried to solve problem with accumulator
14:04:45 <Cale> Well, you're just building up a large expression in the accumulator then :)
14:05:39 <Cale> You probably want to force the expression to be evaluated before recursing
14:05:40 <BetaTEST> both x and a are concrete - they can be calculated before calling f
14:05:44 <BetaTEST> how? :)
14:05:45 <Cale> can be
14:05:47 <Cale> but won't be
14:05:49 <palomer> wicked, if you look at the colour (t,1-t,sin(t*Pi/2)) where t = abs(sin(1/i)) then you get the pastel colours, if you look at t= abs(cos(1/i)) you get dark colours
14:06:00 <tony2> why aren't haskell lists implmented with a pointer to the first _and_ last element?
14:06:19 <tony2> It seems daft for (++) to have to be O(n)
14:06:39 <Cale> tony2: (++) is O(n) for another reason than you're thinking
14:06:47 <RyanT5000> so i want to define a type as follows: it has a number of "columns", each of which is either "indexed" or "unindexed"; given a datum from any indexed column, you can look up all the corresponding data in the other columns
14:06:56 <Cale> BetaTEST: seq
14:06:59 <RyanT5000> the columns are statically defined
14:07:00 <tony2> Cale, really? 
14:07:10 <Cale> seq a b  will force a to be evaluated before returning b
14:07:15 <palomer> putting a pointer to the last element seems like a compiler issue
14:08:15 <tony2> palomer, indeed, just their implmentation, I don't want to be able to traverse them backwards or anything.
14:08:37 <Cale> Well, (++) can't mutate its left parameter
14:08:38 <BetaTEST> Cale, how do i use it in the paste?
14:09:12 <stepcut> tony2: but that means you have to evaluate the list enough to find the last element, yes?
14:09:14 <Cale> You could implement lists as trees to get O(1) (++), but then they wouldn't e lists.
14:10:38 <tony2> I don't really understand, but I guess if (++) could be O(1) it would be.
14:11:01 <bolrod> you have to use (++) smart
14:11:10 <bolrod> not (a++b)++c
14:11:15 <bolrod> but a++(b++c)
14:11:27 <RyanT5000> tony2: if a "list" stored a pointer to its last entry, then you'd double the size of a list
14:11:48 <RyanT5000> remember, x :: [a] implies tail x :: [a]
14:12:06 <RyanT5000> lists are recursively defined, so you'd be storing a next and a last pointer in each node
14:12:14 <Cale> xs ++ ys is O(length xs), assuming that the entire resulting list is demanded
14:12:22 <tony2> RyanT500, point taken, and then you'd be able to traverse backwards.
14:12:25 <Cale> [] ++ ys = ys
14:12:34 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
14:12:37 <Cale> that's the definition
14:12:47 <Cale> so if you do something like [1,2,3] ++ ys
14:12:48 <RyanT5000> tony2: that's a totallly different datastructure, that should be used in different ways; you can define it yourself :)
14:12:52 <Cale> it evaluates as:
14:13:10 <RyanT5000> you're talking about a ring, then, i take it
14:13:10 <RyanT5000> ?
14:13:25 <RyanT5000> so the first node stores a "last" pointer and a next, and every other node stores a next and a prev
14:13:36 <Cale> [1,2,3] ++ ys -> 1 : ([2,3] ++ ys) -> 1 : (2 : ([3] ++ ys)) -> 1 : (2 : (3 : ([] ++ ys))) -> 1 : 2 : 3 : ys
14:13:36 <RyanT5000> and the last node stores a prev and a "first"
14:13:45 <tony2> RyanT500, no I was just annoyed at O(n) (++), but didn't think it through :)
14:13:51 <Cale> which is why it takes O(length xs) total
14:13:51 <RyanT5000> k :)
14:14:11 <Cale> but it really only takes O(1) for each element of xs that's demanded from the resulting list
14:14:17 <RyanT5000> tony2: if you want to look at an interesting datastructure in that same vein, look at fibonacci (sp?) heaps
14:14:28 <Cale> If you only use one element of the result, it's constant time.
14:14:28 <RyanT5000> they use rings to achieve O(1) amortized cost for practically every operation
14:14:49 <tony2> RyanT5000, sounds interesting.
14:14:58 <Cale> BetaTEST: hmm, the amount of work to be done still seems huge
14:15:02 <tony2> I'd like a good book on data structures.
14:15:12 <RyanT5000> try nist.gov/DADS
14:15:17 <RyanT5000> it's practicallly like a book :)
14:15:21 <jyp> FInger trees will be in standard libs soon enough, btw.
14:15:35 <tony2> RyanT5000, will do, thanks.
14:15:39 <RyanT5000> hm, that's the wrong URL
14:15:40 <RyanT5000> just a sec
14:15:50 <RyanT5000> http://www.nist.gov/dads/
14:15:54 <RyanT5000> it just needed the www
14:16:03 <tony2> ok cheers. 
14:16:13 <RyanT5000> k have fun :)
14:16:59 <RyanT5000> anyone: ideas on how to implement a type for a relational database table type in haskell?
14:17:16 <tony2> doesn't seem very readable :) I'll check out the fibonacci heaps though.
14:17:25 <RyanT5000> you have to know what you want
14:17:29 <RyanT5000> then it has lots of information
14:17:42 <RyanT5000> so i kind of lied about it being like a book :P although it does have a ton of info
14:18:04 <RyanT5000> and it's indexed nicely, imo
14:18:25 <xerox> dons: ping?
14:19:58 <BetaTEST> Cale, so, does usage of accumulator make any sense?
14:20:24 <BetaTEST> i thought it may be somewhat better than simple recursion :)
14:20:37 <Cale> well, what you have is a foldr, which isn't tail recursive, and - isn't associative, so I suspect you'll want to do something more interesting to transform it
14:20:52 <RyanT5000> what's your function doing?
14:21:35 <BetaTEST> it does something like: f 16 = 16 - 8 + 4 - 2 + 1
14:22:49 <BetaTEST> Cale, i intentionally used '-' :)
14:26:04 <Cale> okay, I think I can do it in relatively constant space
14:26:20 <Cale> still going to take ages on the example you want
14:26:47 <Cale> m' x = foldl' (+) 0 (zipWith (*) [(-1)^n | n <- [0..]] (takeWhile (/= 0) (iterate (`div` 2) x)))
14:27:12 <Cale> that has too many parens :)
14:27:49 <Cale> m' = foldl' (+) 0 . zipWith (*) [(-1)^n | n <- [0..]] . takeWhile (/= 0) . iterate (`div` 2)
14:27:53 <Cale> that's better :)
14:28:20 <Cale> m' = foldl' (+) 0 . zipWith (*) [(-1)^n | n <- [0..]] . takeWhile (/= 0) . iterate (`div` 2)
14:28:22 <Cale> oops
14:28:24 <JohnnyL> what's the diff between . and $, and where can I look to reference that information?
14:28:35 <Cale> their type
14:28:40 <BetaTEST> foldl' -> foldl?
14:28:41 <Cale> for one :)
14:28:51 <Cale> foldl' is a strict version of foldl
14:29:08 <Cale> m' = foldl' (+) 0 . zipWith (*) (cycle [1,-1]) . takeWhile (/= 0) . iterate (`div` 2)
14:29:12 <Cale> that also would work
14:29:17 <BetaTEST> it says it's not in scope
14:29:25 <Cale> import Data.List
14:30:08 <BetaTEST> oh, it works :)
14:30:30 <Cale> you just have to be a little more clever about how you construct the expression
14:30:33 <BetaTEST> just 12.3 sec
14:30:38 <Cale> and actually yeah
14:30:44 <akemp> Anyone using cabal-get?
14:30:50 <Cale> I can compute it too :)
14:31:52 <BetaTEST> i'm just learning haskell. in book they said that fac n = n * fac (n - 1)
14:31:57 <BetaTEST> is not tail recursive
14:32:06 <JohnnyL> @type .
14:32:08 <lambdabot> parse error on input `.'
14:32:13 <JohnnyL> @type '.'
14:32:14 <lambdabot> Char
14:32:19 <BetaTEST> and introduced example with accumulator
14:32:20 <JohnnyL> @type $
14:32:22 <lambdabot> parse error on input `$'
14:32:29 <JohnnyL> oh well, so much for that idea.
14:32:46 <BetaTEST> fac2 n = f n 1
14:33:05 <BetaTEST> where f 0 a = a \n f n a = f (n - 1) (n * a)
14:33:33 <BetaTEST> and said that such usage of accumulator can solve many problems
14:34:19 <BetaTEST> but it seems that original fac works quite good because interpreter converts 10 * (9 * fac 8) => (10 * 9) * fac 8 => 90 * fac 8
14:34:25 <BetaTEST> am i right?
14:37:23 <Lemmih> No, I doubt that. And why would that be good?
14:38:03 <BetaTEST> why would be usage of accumulator good? i doubt that also :)
14:38:25 <Cufisz> Is there a function like foldr except with type ((a -> b -> c) -> b -> [a] -> c) ?
14:38:33 <Lemmih> BetaTEST: Because then it's tail-recursive.
14:38:57 <integral> Cufisz: umm, how do you turn that c into a b to feed into the next application of the function?
14:39:08 <Cale> Tail recursive things can be implemented with a loop, but unless you're compiling with optimisations, won't solve the real problem
14:39:12 <BetaTEST> Lemmih, but n * a is not evaluated until the end anyway
14:39:30 <Cale> BetaTEST: With optimisations turned on, the compiler will catch lots of things like that
14:39:31 <Cufisz> integral: i'm new at this =) so let me think about it
14:39:54 <BetaTEST> can optimizations be turned on in ghci?
14:40:11 <Cale> BetaTEST: well, you can compile your module with ghc, and load it with ghci
14:40:14 <Cufisz> ahhh... i get it
14:42:32 <Cufisz> so let's say you have a list of vectors and you want to "kindof foldr" through them and take the dot product of all of them together
14:42:50 <Cufisz> is there some kindof built in function for that?
14:43:14 <Cufisz> so i guess something along the lines of: dot :: a -> a -> b
14:43:16 <astrolabe> @type foldr
14:43:18 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
14:43:18 <Cale> BetaTEST: Basically, when you're trying to get a 'small' result from 'large' input, you want strictness, and the correct fold to use is usually foldl', in any other case, you'll want laziness, and foldr is better
14:44:20 <astrolabe> @hoogle (a -> b -> c) -> b -> [a] -> c
14:44:21 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
14:44:59 <astrolabe> cufisz: what do you mean by 'the dot product of them together'?
14:45:26 <Cale> foldl f z [] = z; foldl f z (x:xs) = foldl f (f z x) xs
14:45:28 <Cufisz> astrolabe: so lets say you have [(1,2,3), (1,2,3), (1,2,3)]
14:46:02 <Cufisz> ojj, sorry guys, i guess i just need to think this through
14:46:08 <Cale> BetaTEST: which is tail recursive, but has the problem that unless the compiler is very smart, won't evaluate any of the f's until it's gone through the whole list
14:46:16 <Cufisz> hehe, dot producting multiple vectors is definately ill defined
14:47:34 <Cale> foldl' f z [] = z; foldl' f z (x:xs) = (foldl f $! f z x) xs
14:48:02 <BetaTEST> oh. mm compiled with optimization did the job :)
14:48:02 <Cufisz> well, or i guess i was thinking of something along the lines of [(1,2,3), (1,2,3), (1,2,3)] -> [(1*1*1 + 2*2*2 + 3*3*3)]
14:48:06 <Cale> or: foldl' f z [] = z; foldl' f z (x:xs) = let y = f z x in y `seq` foldl f y xs
14:48:15 <Cale> er
14:48:19 <Cale> or: foldl' f z [] = z; foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
14:48:40 <Cale> I forgot to put the ' on the recursive step
14:49:28 <Cale> But you can probably see why that helps
14:50:02 <xerox> > (\(x,y,z) -> x+y+z) $ foldl1 (\(a,b,c) (d,e,f) -> (a*d,b*e,c*f)) $ replicate 3 (1,2,3)
14:50:03 <lambdabot> 36
14:51:01 <Cale> > foldl (\x y -> concat ["(", show x, "+", show y, ")"]) "0" [1,2,3]
14:51:02 <lambdabot> "(\"(\\\"(\\\\\\\"0\\\\\\\"+1)\\\"+2)\"+3)"
14:51:05 <Cale> oops :)
14:51:18 <Cale> > foldl (\x y -> concat ["(", x, "+", show y, ")"]) "0" [1,2,3]
14:51:19 <lambdabot> "(((0+1)+2)+3)"
14:52:13 <BetaTEST> i still have to practice to understand such things as  m' = foldl' (+) 0 . zipWith (*) (cycle [1,-1]) . takeWhile (/= 0) . iterate (`div` 2). and... is that readable to experienced programmer?
14:52:13 <Cale> > foldr (\x y -> concat ["(", show x, "+", y, ")"]) "0" [1,2,3]
14:52:14 <lambdabot> "(1+(2+(3+0)))"
14:52:34 <Cale> BetaTEST: it's understandable -- you just have to read it one step at a time
14:52:59 <Cale> In a real application, you might want to break it up some, since those would probably have more specialised meanings
14:53:01 <xerox> Cale: hah, nice one.
14:53:07 <xerox> That's introspection!
14:54:06 <Cale> > iterate (`div` 2) 34
14:54:07 <lambdabot> [34,17,8,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:54:07 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:54:07 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:54:07 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:54:10 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:54:12 <Cale> hehe
14:54:13 <lambdabot> [6 @more lines]
14:54:26 <Cale> > takeWhile (/= 0) . iterate (`div` 2) $ 34
14:54:27 <lambdabot> [34,17,8,4,2,1]
14:55:06 <Cale> > take 20 (cycle [1, -1])
14:55:07 <lambdabot> [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1]
14:55:21 <Cale> > zipWith (*) (cycle [1,-1]) . takeWhile (/= 0) . iterate (`div` 2) $ 34
14:55:23 <lambdabot> [34,-17,8,-4,2,-1]
14:55:36 <Cale> > sum . zipWith (*) (cycle [1,-1]) . takeWhile (/= 0) . iterate (`div` 2) $ 34
14:55:38 <lambdabot> 22
14:55:55 <xerox> What's that exactly?
14:56:05 <norpan> :t cycle
14:56:11 <norpan> @type cycle
14:56:12 <lambdabot> forall a. [a] -> [a]
14:56:14 <xerox> cycle :: [a] -> [a]
14:56:28 <Cale> > take 20 (cycle [1,2,3,4])
14:56:29 <lambdabot> [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4]
14:56:39 <BetaTEST> nice bot :)
14:59:18 <ihope> > (\x -> [x] ++ "es" ++ [x] ++ "ing, " ++ tail (init (show ([1,2,3] :: [Int]))) ++ "!") 't'
14:59:20 <lambdabot> "testing, 1,2,3!"
15:00:17 <xerox> ([x]++) = (x:)
15:00:29 <ihope> > (\x -> x : "es" ++ [x] ++ "ing, " ++ tail (init (show ([1,2,3] :: [Int]))) ++ "!") 't'
15:00:31 <lambdabot> "testing, 1,2,3!"
15:00:47 <ihope> > (\x -> x : "es" ++ x : "ing, " ++ tail (init (show ([1,2,3] :: [Int]))) ++ "!") 't'
15:00:48 <lambdabot> "testing, 1,2,3!"
15:02:27 <ihope> @pl \x -> x :: Int
15:02:28 <lambdabot> (:: Int)
15:04:22 <mauke> haha
15:06:34 <palomer> that's nonsense!
15:07:23 <Cale> pl parsed :: as an infix operator
15:07:46 <Cale> It's not really a complete haskell parser :)
15:08:01 <palomer> what about the Int?
15:08:47 <mauke> data What = Int
15:18:12 <ihope> You know, (:: bar) should work.
15:18:22 <ihope> (::) and (foo ::) shouldn't, of course...
15:23:37 <tony2> what does deriving typeable mean?
15:23:58 <ihope> It lets you use typeOf on the type.
15:23:58 <tony2> rather what is the typeable class.
15:24:14 <tony2> :type typeOf
15:24:20 <ihope> @type Data.Typeable.typeOf
15:24:22 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:24:48 <tony2> what's a TypeRep?
15:25:05 <ihope> It's a value that represents the type of something.
15:25:06 <Cale> a data representation of a type
15:25:08 <ihope> > typeOf "foo"
15:25:10 <lambdabot> [Char]
15:25:25 <monochrom> See the doc of Data.Typeable
15:25:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
15:25:35 <tony2> like a first class type.
15:25:39 <tony2> will do.
15:25:58 <ihope> TypeReps can't be polymorphic, though.
15:26:16 <tony2> I'll check the docs, cheers.
15:26:19 <ihope> > typeOf id
15:26:20 <lambdabot> Add a type signature
15:26:28 <Cale> > splitTyConApp (typeOf "foo")
15:26:29 <lambdabot> ([],[Char])
15:26:39 <jip> femtosecond
15:26:41 <Cale> hehe
15:26:43 <ihope> ...Wuh...
15:26:50 <ihope> s/h.../h?.
15:26:58 <ihope> s/?./\//, ugh.
15:27:19 <Cale> > let (x,y) = splitTyConApp (typeOf "foo") in (show x, show y)
15:27:20 <lambdabot> ("[]","[Char]")
15:27:36 <Cale> > let (x,y) = splitTyConApp (typeOf "foo") in (show x, map show y)
15:27:37 <lambdabot> ("[]",["Char"])
15:27:55 <palomer> Cale: know anything about colour theory?
15:28:00 <palomer> I want to make a colour brighter
15:28:16 <ihope> Increase the saturation?
15:28:18 <Cale> what colour space are you working in?
15:28:30 <palomer> rgb
15:28:37 <palomer> ihope: how do I do that?
15:28:46 <ihope> Make the high values higher and the low values lower.
15:28:55 <Cale> Do you want to make the colour brighter or more saturated?
15:29:00 <palomer> but that doesn't make (255,0,0) any brighter
15:29:05 <palomer> brighter
15:29:24 <ihope> Well, I don't think it's possible to make that color any brighter.
15:29:28 <Cale> Then you could just do a linear interpolation with white
15:29:40 <xerox> I was about to say "cover with white"
15:29:44 <Cale> ihope: sure (255,1,1) is brighter
15:29:45 <xerox> But I thought it was "silly" .-)
15:30:05 <palomer> so (r,g,b) -> (255/2+r/2, 255/2+g/2, 255/2+b/2) ?
15:30:06 <ihope> Brighter /= lighter...
15:31:07 <Cale> brightness is just (r + g + b) / 3
15:31:18 <palomer> I didn't know that
15:31:27 <ihope> Terminology is confusing.
15:33:41 <Cale> Ah, I see what you mean :)
15:34:17 <Cale> You mean that in HSV, that colour already has maximum value.
15:34:37 <Cale> but in HSL, the lightness is only 1/2
15:34:56 <Cale> palomer: http://en.wikipedia.org/wiki/HSL_color_space
15:35:05 <JohnnyL> am i right in saying that roots2:: Polynom -> (Float, Float)      roots2 (Poly a b c) = ...   where ... is functional information (computations, whatnot)?
15:35:11 <Cale> Convert to that and adjust the L component
15:35:56 <Cale> JohnnyL: I suppose it depends on your definition of 'functional information', but probably yeah. :)
15:37:13 <Cale> palomer: also have a look at http://en.wikipedia.org/wiki/HSB_color_space
15:38:25 <JohnnyL> Cale, ok, cause i'm going against a tutorial.
15:39:04 <palomer> HSL?
15:39:22 <Cale> palomer: Hue, Saturation, Lightness (or luminance)
15:39:42 <palomer> but I'm interested in rgb!
15:39:58 <Cale> right, but it's more convenient to go via HSL
15:40:03 <Cale> for the transformation you want
15:40:08 <Cale> and then convert back
15:40:32 <palomer> does opengl have support for HSL?
15:41:23 <palomer> guess not:/
15:41:24 <palomer> I'm off!
15:42:04 <jip> in opengl, with shader programs you can implement pretty much any colorspace you want
15:42:28 <jip> er i mean fragment programs
15:45:10 <Lemmih> dons: ping.
15:46:07 <Oejet> Lemmih: Good evening.
15:48:29 <Lemmih> Hiya Oejet.
15:48:59 <Lemmih> Oejet: How's code?
15:49:21 <Lemmih> Oejet: Gonna apply for Google's SOC?
15:49:23 <lightstep> what does |- mean in typing rules, as in Gamma |-- x : T  ?
15:51:21 <ihope> Um.
15:53:33 <JohnnyL> In Data Bus = Start | Next (Bus) what exactly is (Bus)? what's the instatiation (calling , etc)?
15:53:59 <SyntaxNinja> w00t
15:54:38 <jip> JohnnyL: that looks like a list
15:54:56 <jip> oh no it doesn't
15:55:14 <ihope> JohnnyL: that means you can apply Next to a Bus to get a Bus.
15:55:15 <jip> looks like a nat
15:55:20 <heatsink> JohnnyL, it means the same thing if you just take off the parentheses.
15:55:32 <jip> it's a nat, right?
15:55:37 <heatsink> jip, yup
15:55:50 <heatsink> jup
15:56:06 <ihope> Yip.
15:56:28 <jip> jup?
15:58:32 <monochrom> lightstep: |- is a punctuation separating assumption and conclusion.  assumption |- conclusion.
15:59:06 <monochrom> Sometimes assumption is environment instead.
15:59:30 <ihope> What if there were no function operator and no parentheses in types?
15:59:43 <ihope> \x y z -> x z (y z) :: a b c a b a c
15:59:51 <hircules> ah hircules head works fine, realised in my sleep that need to press Ctrl-Return instead of Return with my current keybindings ;)
16:00:42 <lightstep> monochrom, so that reads as "given this environment, we know that type"?
16:00:50 <monochrom> Yes.
16:01:23 <lightstep> and later on, we just put that type into that environment? or does an environment contain only the types of variables?
16:01:41 <lightstep> (as opposed to also containing the types of terms)
16:02:39 <monochrom> I don't know the answer to either question.
16:02:43 <lightstep> in logic, there is no difference, because you have the deduction principle. is it the same in type theory?
16:03:59 <araujo> hello
16:05:39 <akemp> Lemmih: I found the "Unknown compiler" bug in cabal-get I was talking about earlier.  It was bug #52 in Trac.  Net/Hack/Cab/Setup.hs needed a default compiler.  Seems like a complete fix.
16:06:37 <monochrom> lightstep: I guess so, but I don't know for sure.
16:08:13 <ihope> Ah, yes. import Paths_haddock. I don't have Paths_haddock. What do I do?
16:08:17 <Oejet> Lemmih: Uh, perhaps.  Any good projects?  I know, I'll participate in ICFP.  Just have to brush up on my Haskell.
16:09:26 <jip> when is ICFP?
16:09:35 <Lemmih> Oejet: I'd work on hIDE or dynamic linking if I were a student.
16:10:21 <Lemmih> akemp: There aren't really any active cabal-get developers anymore.
16:10:35 <akemp> Lemmih: why's that?
16:10:40 <wchogg> Lemmih:  dynamic linking?
16:11:19 <Lemmih> wchogg: Type-safe, dynamic linking in Haskell, great fun.
16:12:05 <ihope> Dynamic linking?
16:12:07 <ihope> Typesafe?
16:12:28 <ihope> Just like Dynamic is unsafe, I suppose...
16:12:35 <ihope> s/unsafe/typesafe/
16:13:14 <jip> do any other languages have the type safe dynamic linking you are talking about? java?
16:15:04 <Lemmih> akemp: Because there are things more fun to hack.
16:15:37 <Lemmih> jip: I don't know.
16:20:59 <DeliQ> can somebody help me on a piece of code ? i get results i should not be getting... confused..
16:21:35 <rasterfar> I'll try if we can go quick
16:22:11 <ihope> DeliQ: pop us the code.
16:22:14 <DeliQ> i'll make a pastebin
16:22:17 <DeliQ> jsut a sec
16:23:01 <DeliQ> http://pastebin.com/660569
16:23:29 <DeliQ> as i type in this with ghci:    free (All "x" (Exi "y" (Rel ("P", ["y","z","x"]))))
16:23:31 <mux> what's a function to parse a string for an int?
16:23:36 <mux> readInt etc ?
16:23:37 <DeliQ> i get ["x", "y"]
16:23:52 <DeliQ> but i should get []
16:24:22 <DeliQ> ze instead of printing the free vars in the pred, it prints the bound ones
16:26:29 <rasterfar> DeliQ: isn't z free here ... wouldn't you expect ["z"]?
16:26:58 <DeliQ> uuhm  yes, but i have free _ = []
16:27:09 <DeliQ> so it's not quite implemented that way
16:27:18 <rasterfar> ah okay; still parsing...
16:29:08 <rasterfar> Well ... the line 22 requires that obj `elem` qobjs
16:29:17 <DeliQ> yes idd
16:29:26 <DeliQ> so... ??
16:29:27 <rasterfar> but you call bound with qobjs == []
16:29:33 <DeliQ> idd
16:29:51 <DeliQ> i start with a fresh "environment"
16:30:23 <DeliQ> so as the function bound sees a pred with All or Exi, that object is added to the qobjs
16:30:40 <rasterfar> hmm ... sorry, my observation still doesn't explain what you're seeing
16:30:44 <DeliQ> because it is then quantified over as of that moment
16:31:09 <DeliQ> i appreciate what you're doing!
16:31:19 <DeliQ> it's late also... :P
16:31:41 <DeliQ> let me explain my login on free
16:31:52 <jip> Lemmih: maybe it's worth checking out?
16:31:56 <rasterfar> actually it's not late here -- except late in the semester
16:32:25 <DeliQ> as an object does not get quantified (not bound) go on checking a level deeper in pred
16:32:50 <DeliQ> in the other case: (else) object is not bound so yield it
16:33:17 <DeliQ> en go searching for more free ones
16:33:42 <Lemmih> jip: Well, I would if google would pay me (:
16:34:11 <xerox> Hey!
16:34:37 <DeliQ> hmmm, i don't see where my logic fails
16:34:53 <DeliQ> hehe, frustrating..
16:39:09 <vincenz> dons: ping
16:41:08 <rasterfar> DeliQ: I think I see the trouble ... on the first call to bound, the second Exi predicate is passed, shouldn't it still be the first All predicate?
16:42:33 <rasterfar> Otherwise, after the one recursion of bound, when you match Rel, you have qobjs == ["y"] but obj is still "x".
16:42:34 <DeliQ> hmm, let me see
16:43:22 <DeliQ> qobjs is then ["x", "y"]
16:43:34 <DeliQ> y is cons'ed to ["x"]
16:43:54 <DeliQ> because bound matches with Exi
16:44:10 <lightstep> isn't buddha designed for this kind of debugging?
16:44:24 <DeliQ> hmm no i'm wrong
16:44:36 <DeliQ> you're right idd rasterfar
16:44:48 <rasterfar> Anyhow, I could very well be mistaken.  But I must go!  Thanks for letting me see your interesting code.
16:45:00 <DeliQ> hmm, thank you! :P
16:45:08 <rasterfar> :P
16:45:10 <DeliQ> bye bye!
16:45:10 <JohnnyL> RyanT5000, you from upstate ny?
16:47:11 <JohnnyL> in howFar (Next r) = 1 + howFar r        , what is the (Next r) considering? 'type {something}?"
16:48:29 <JohnnyL> also, what is the left side of the = called? while I'm at is, what is the right side called? and where can I get this information so I don't have to ask here?! :)
16:50:05 <lightstep> umm, i don't really know a good introduction to pattern matching, but you call the left hand side the "pattern", and it checks if the bus is Start or an instance of Next
16:50:24 <JohnnyL> ok
16:50:26 <JohnnyL> thats helps.
16:50:29 <JohnnyL> that helps
16:59:32 <ulfdoz> JohnnyL: (Next r) is a constructor pattern. It matches any value which was created using let foo = Next bar ...
17:00:17 <ulfdoz> the type depends on, what next constructs, that is another point in source code.
17:08:45 <mux> > PortNumber 42
17:08:46 <lambdabot>  Not in scope: data constructor `PortNumber'
17:08:52 <mux> > Network.PortNumber 42
17:08:53 <lambdabot>  Not in scope: data constructor `Network.PortNumber'
17:09:39 <mux> Prelude Network> :t PortNumber 42
17:09:39 <mux> PortNumber 42 :: PortID
17:09:39 <mux> Prelude Network> :t PortNumber 42::Integer
17:09:39 <mux> <interactive>:1:0:
17:09:39 <mux>     Couldn't match `Integer' against `PortID'
17:09:42 <mux>       Expected type: Integer
17:09:44 <mux>       Inferred type: PortID
17:09:48 <mux> can someone explain this to me?
17:10:07 <ulfdoz> tried parenthesis?
17:10:24 <mux> no this is not the problem
17:10:36 <mux> my code doesn't even have this cast, it's a test-case
17:11:03 <mux> I can use the PortNumber data constructor with literate integers, but not with an integer I got from, say, parsing a string
17:11:03 <Lemmih> mux: PortNumber (fromIntegral (42::Integer))
17:11:11 <ulfdoz> Prelude> :t Network.PortNumber 42
17:11:11 <ulfdoz> Network.PortNumber 42 :: Network.PortID
17:11:19 <ulfdoz> Works fine here.
17:11:27 * mux bangs head on desj
17:11:49 <mux> ulfdoz: you're way off track :)
17:11:51 <mux> Lemmih: thanks
17:33:20 <wchogg> Okay, I obviously don't understand where to put type annotations in relation to monadic actions.  For example, in the case of a function like echo = readLn >>= (\x -> print x) where do I put the type annotation saying that it's okay to require x to also be an instance of Show?
17:33:55 <Cale> @type readLn
17:33:57 <lambdabot> forall a. (Read a) => IO a
17:34:11 <Cale> the problem with that code is that the type to read is underspecified
17:34:25 <Cale> You could put a signature on x
17:34:28 <Cale> or on readLn
17:35:28 <wchogg> Cale:  Yeah, so where do I put the signature on x?  I tried it a few different ways that I thought worked, but ghci just spit up.  Shouldn't I be able to do something like x::(Show a => a)?
17:35:48 <Cale> readLn >>= (\x -> print (x :: Integer))
17:35:53 <Cale> ought to work
17:36:29 <Cale> (readLn :: IO Integer) >>= (\x -> print x)
17:36:33 <Cale> that'll also work
17:37:07 <wchogg> Yeah, that does work.  So I just can't have a general annotation like saying that's it's just an instance of Show?
17:37:47 <Cale> well, readLn = fmap read getLine
17:37:52 <Cale> @type read
17:37:53 <lambdabot> forall a. (Read a) => String -> a
17:37:59 <Cale> @type show
17:38:01 <lambdabot> forall a. (Show a) => a -> String
17:38:10 <Cale> @type show . read
17:38:12 <lambdabot> String -> String
17:38:23 <palomer> Cale: hrmph, is there an easy conversion from HSL back to RGB?
17:38:25 <Cale> however, which type 'a' does it go through?
17:39:28 <wchogg> ...Hrmm.  So you're saying that the intermediate step isn't really well defined?  That feels very counterintuitive to me, but I think I see your point.
17:39:44 <Cale> wchogg: well, you need to know which parser to invoke, right?
17:40:31 <Cale> how should it know if it's to parse an Integer, or a list of trees, or anything else?
17:41:47 <Cale> http://homepages.cwi.nl/~steven/css/hsl.html -- this has some reasonable code for it
17:41:50 <Cale> (palomer)
17:41:52 <wchogg> Cale:  I thought it chose all that at runtime anyway?
17:42:35 <wchogg> Oh crap.  It doesn't does it?
17:42:45 <Cale> no
17:43:02 <Cale> typeclasses are resolved at compile time
17:43:16 <wchogg> So the compiler *has* to be able to figure out at compile time which to use. D'oh!  That makes alot more sense.
17:43:19 <Cale> even if it chose it at runtime, it wouldn't be able to do so based on input
17:43:54 <palomer> got it
17:43:57 <Cale> since the instance of read for one type might overlap in what it accepts with the instance of read for another type
17:44:16 <wchogg> What do you mean, the instance might overlap?
17:44:41 <wchogg> Oh, you mean like 1 being read in as both a Double and an Integer?
17:44:42 <Cale> er, the languages which the parsers accept might overlap
17:44:45 <Cale> yes
17:44:58 <Cale> > show (read "1" :: Integer)
17:44:59 <lambdabot> "1"
17:45:03 <Cale> > show (read "1" :: Double)
17:45:04 <lambdabot> "1.0"
17:45:14 <Cale> > show (read "1")
17:45:15 <lambdabot> Add a type signature
17:46:03 <wchogg> Okay.  That makes alot more sense now.
17:46:38 <wchogg> I was thinking of readLn as being like cin in c++.
17:47:27 <Cale> well, in C++, you absolutely must declare the types of your variables, so it's unambiguous anyway
17:48:21 <Cale> here, things just have to be sufficiently constrained so that types can be inferred :)
17:49:13 <wchogg> Okay.  Thanks, that really does make more sense.
17:49:17 <jip> apparently the next version of C++ will have some form of type inference
17:49:51 <wchogg> jip: C++ or C#?
17:50:17 <jip> c++
17:50:27 <jip> c# 3.0 already has some form of type inference i think
17:50:30 <wchogg> Really?  That is rather surprising to me.
17:50:45 <jip> yeah, c++ will introduce the "auto" keyword
17:50:51 <wchogg> I'm not going to complain, but it just surprises me.  
17:50:59 <jip> auto a = f(); // type of a will be return type of f() function
17:51:18 <Cale> heh, you have to declare that you want it to be inferred?
17:52:10 <jip> yeah, i'm not even sure if it's worthy to be called "inference". it just looks at the type of the expression on the right hand side of an assignment
17:52:59 <jip> to save you typing... like std::vector<Foo::Bar>::iterator i = x.begin(); ===> auto i = x.begin();
17:53:08 <wchogg> Yeah, that's a little lame, but maybe it could be used for some tricks to make polymorphic code?
17:53:09 <metaperl> Cale: in your article (http://www.haskell.org/hawiki/MonadsAsContainers) you say "The second method, return, is specific to monads" -- but the question is, what is the first method you discussed?
17:53:29 <Cale> fmap
17:54:21 <metaperl> ah I see
17:56:29 <metaperl> another monad question: " If m is a monad, then return takes an element of type a, and gives a container of type (m a) with that element in it." --- does the returned container only have a in it?
17:56:29 <metaperl> @type return
17:56:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
17:56:42 <Cale> metaperl: yes
17:57:06 <Cale> metaperl: but the way in which it "contains" that value might be different depending on the given monad
17:57:29 <metaperl> for lists, it means a goes to [a]
17:57:34 <Cale> right
17:57:53 <Cale> and it does that by return x = [x]
17:58:13 <Cale> It would also work to have  return x = repeat x
17:58:14 <metaperl> ok I'm continuing the article
17:58:19 <Cale> but that's just not so useful :)
17:58:28 <metaperl> repeat?
17:58:38 <Cale> take 20 (repeat 1)
17:58:40 <Cale> > take 20 (repeat 1)
17:58:41 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
17:58:43 <metaperl> @type repeat
17:58:44 <lambdabot> forall a. a -> [a]
17:59:16 <metaperl> repeat 1 "a"
17:59:16 <metaperl> repeat "a"
17:59:16 <metaperl> take 1 (repeat "a")
17:59:47 <Cale> > take 1 (repeat "a")
17:59:48 <lambdabot> ["a"]
17:59:53 <Cale> > take 1 (repeat 'a')
17:59:54 <lambdabot> "a"
17:59:57 <Cale> > take 10 (repeat 'a')
17:59:58 <lambdabot> "aaaaaaaaaa"
18:00:28 <palomer> man these rgb to hsl conversations and ugly
18:00:39 <palomer> going back is pretty ugly tooo
18:05:19 <palomer> gah!
18:05:20 <wchogg> Are there any good tutorials on using STM?
18:05:24 <palomer> I copied them wrong
18:06:07 <metaperl> another monad question: "If I have a box of boxes of apples (m (m a)) then I can take the apples from each, and put them in a new box (m a)." --- the thing that confuses me is (m a) was just described as a box with just one a but not (m a) can represent several boxes, each of which has an a
18:09:32 <palomer> a value of (m b) contains many values of type b
18:10:33 <araujo> metaperl, it's not always true taht ytou will be able to take the apples from the box.
18:10:43 <araujo> For example, with the one way monads
18:11:25 <metaperl> palomer: but what does return do?
18:12:43 <palomer> it takes a value of type b and returns a value of type (m b)
18:12:56 <palomer> a value of type (m b) is a box with value of type b in it
18:14:40 <monochrom> wchogg: I read the STM paper and it was quite introductory.
18:15:16 <metaperl> palomer: but that's just my point: (m b) has _one_ element
18:15:40 <metaperl> therefore m (m a) is something where m has (m a) and (m a) has one element
18:16:00 <wchogg> monochrom:  then I'll have to read it, thanks.
18:16:21 <mux> I'm having tons of undefined references at linking stage with ghc. is "import" in the files not enough? do I need to pass some -l switches or something?
18:16:26 <adu> metaperl: interesting screen name, whats it mean?
18:16:45 <araujo> metaperl, 'a' is a data type 
18:17:30 <metaperl> adu: well, you know what meta means right?
18:17:34 <metaperl> instead of object-level perl development, I program perl at meta-level I suppose
18:17:42 <metaperl> haskell is the ultimate meta-language in my opinion
18:18:10 <Lemmih> mux: --make will take care of it all.
18:18:59 <adu> metaperl: so you don't program IN perl you program so that people may program in perl?
18:19:14 <mux> Lemmih: I'm building every .hs file independantly
18:19:25 <metaperl> "The third method, join, also specific to monads, takes a container of containers m (m a), and combines them into one m a in some sensible fashion." ---- why is this a container of containers instead of a container of one container?
18:19:31 <adu> metaperl: i'm still not sure what that means.... ?
18:19:44 <metaperl> adu: I wouldn't go that far. Have you seen the book "higher order perl" ?
18:19:51 <Lemmih> mux: Then you need explicit '-package pkg' flags.
18:19:53 <adu> nope
18:20:40 <mux> Lemmih: and how do I get the name of the packages? -package Network fails with unknown package
18:20:43 <Lemmih> mux: But why do it manually? --make is great.
18:20:53 <mux> to avoid unnecessary rebuilds
18:20:57 <mux> ie to really use a Makefile
18:21:14 <Lemmih> mux: --make will only rebuild needed files.
18:21:31 <Lemmih> mux: You can list all packages with 'ghc-pkg list'.
18:21:33 <mux> can you tell me how to get the package names?
18:21:35 <mux> thanks
18:22:21 <monochrom> @type [True, False, True]
18:22:23 <lambdabot> [Bool]
18:22:31 <monochrom> @type [[True, False, True], [False, True]]
18:22:33 <lambdabot> [[Bool]]
18:22:41 <monochrom> That's for metaperl .
18:23:40 <Lemmih> mux: I'd recommend --make for small programs and Cabal for libraries and larger applications.
18:23:48 <metaperl> monochrom: I'm studying it
18:24:04 <palomer> quite, someone give me an easily computable unpredictable permutation on Z_12
18:24:07 <metaperl> monochrom: ah! the second one is m (m a)
18:24:21 <monochrom> YES!
18:24:29 <adu> hmm interesting
18:24:46 <adu> they mention the Newton-Raphson method
18:24:48 <palomer> metaperl: it can contain more than one value
18:25:01 <metaperl> yes, I'm starting to see that
18:25:21 <adu> i implemented a specialization of Newton's method for a special function that i new the first derivative of
18:25:36 <adu> in perl actually
18:26:16 <palomer> s/new/knew
18:26:22 <adu> sorry ya
18:26:23 <palomer> s/that i/for which
18:26:32 <palomer> for which I
18:26:33 <adu> whatever
18:26:45 <palomer> s/of/
18:26:50 <adu> i speek good
18:26:57 <palomer> s/speek/speak
18:27:01 <adu> lol
18:27:09 <sethk> goodly
18:27:13 <adu> well
18:27:16 <palomer> gah, come on, someone here must have a permutation handy
18:27:40 <sjanssen> palomer: yes, [2, 1] is a permutation of [1, 2]
18:27:46 <palomer> permutation on Z_12
18:27:51 <monochrom> but not necessarily unpredictable (whatever that means)
18:28:11 <palomer> forget unpredictable
18:28:15 <palomer> make it non trivial
18:28:25 <palomer> ok, here's the condition
18:28:41 <palomer> such that no 2 succesive elements are mapped to successive elements
18:32:17 <palomer> ok, hand coded it
18:32:28 <palomer> a hue of 1 is equivalent to a hue of 0, right?
18:35:05 <metaperl> ok, so I think I understand something. 
18:35:10 <metaperl> @type return
18:35:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
18:36:42 <metaperl> return takes a single element and "containerizes it", yielding something of type m a... but that (m a) just so happens to be an (m a) where the container has one element. There is nothing about the notation (m a) which constrains (m a) to only contain one type as the input to join (as well as monochrom's example) shows
18:42:53 <metaperl> fmap is sorta like the STL container classes - you can go from a vector of objects to a queue of them to a list of them , etc, etc
18:42:57 <metaperl> right/
18:42:58 <metaperl> ?
18:44:03 <monochrom> No. fmap keeps the same container type. it transforms the elements.
18:45:55 <metaperl> oh that's right
18:46:27 <jip> i've found that a good technique for learning haskell is to forget everything i know about c++ :)
18:46:46 * araujo agrees with jip 
18:50:41 <vincenz> jip: :)
18:50:47 <vincenz> anyone here play go?
18:51:30 <jip> Ca1e does =]
18:53:50 <metaperl> vincenz: I'm interested
18:54:04 <metaperl> vincenz: I play at dragongoserver.net (username metaperl)... but I'm not very good
18:55:33 <metaperl> In the list monad, the bind function does not change the type of what is in the container... it only "de-containerizes" things
18:56:40 <metaperl> right?
18:57:33 <sjanssen> metaperl: that's not quite right
18:57:39 <sjanssen> @type (>>=)
18:57:41 <lambdabot> forall (m :: * -> *) b a.
18:57:41 <lambdabot>    (Monad m) =>
18:57:41 <lambdabot>    m a -> (a -> m b) -> m b
18:59:01 <sjanssen> it takes an original container of a's, and a way to turn a's into containers of b, and then flattens all those containers of b into one container
18:59:09 <metaperl> yes, that is what bind does
18:59:26 <metaperl> but the bind for lists (concat) does not change type of what is contained:
18:59:29 <metaperl> @type (++)
18:59:31 <lambdabot> forall a. [a] -> [a] -> [a]
18:59:39 <sjanssen> bind is actually concatMap
18:59:43 <metaperl> oh
18:59:45 <sjanssen> join is concat
18:59:55 <metaperl> oh
19:00:26 <metaperl> @type concatMap
19:00:27 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
19:00:40 <sjanssen> actually, flip concatMap
19:01:59 <sjanssen> also, note that concat is join, map is fmap.  concatMap as bind makes it pretty obvious that bind is the same as "join . fmap f"
19:02:36 <sjanssen> that's one insight into Monads that MonadsAsContainers drives home
19:03:32 <blackdog> any FFI hackers in the house?
19:04:13 <metaperl> that's what I'm reading (Monads as Containers)
19:04:23 <Lemmih> FFI hackers as authors of the FFI addendum?
19:04:26 <blackdog> i want to call haskell from ruby. is writing a c interface to a haskell function then calling that c function from ruby the sensible way to go about it?
19:04:36 <blackdog> no, just people whe know how to use it. :)
19:05:10 <metaperl> but get this: "If I have a box of boxes of apples (m (m a)) then I can take the apples from each, and put them in a new box (m a)." --- really "new" is inappropriate because the the "new" box is (m a). Had it been (p a) then the box would be new. As it stands the box is just the same box that they were in before. they are just not separately boxed
19:05:10 <rasterfar> palomer: should be simple in a language like Haskell to write a one-liner to swap two random elements of [0..n]; just apply that a bunch of times!
19:05:34 <Lemmih> blackdog: Yes, GHC can even generate the c interface for you.
19:05:50 <blackdog> cool. new adventures. 
19:06:05 <araujo> metaperl, geez, you better should find a better monad analogy, you are becoming a mess with this container thing :-)
19:06:11 <sjanssen> metaperl: it is a new box, but it's a box of the same type
19:06:36 <metaperl> yes, thats why I was calling "new" into question... it is not a new type ...
19:06:38 <sjanssen> you're right, the cardboard box stays a cardboard box.  it doesn't change into a woven basket or anything
19:06:45 <metaperl> :)
19:07:00 <metaperl> sjanssen: do you program in Haskell professionally?
19:07:29 <sjanssen> I don't do much professionally -- I'm a university student
19:08:08 <metaperl> oh what major and school?
19:08:23 <sjanssen> computer science, University of Nebraska
19:08:24 <palomer> rasterfar: yeah, just did it by hand though
19:08:44 <sjanssen> we don't learn Haskell or anything here, I just do it for personal enjoyment/enrichment
19:12:45 <metaperl> Haskell is definitely enjoyable and enriching
19:12:53 <metaperl> that is tornado country isn't it?
19:13:14 <metaperl> I'm here in Las Vegas for the first time. I am fearful of the triple-digit summer.
19:13:36 <metaperl> been a spoiled California brat for most of my recent years :)
19:13:44 <sjanssen> yeah, tornadoes occasionally
19:15:59 <metaperl> well I'm off to loot some grub
19:16:08 <sjanssen> have fun with that
19:24:21 <sethk> in a pattern, say (x:xs), can I refer to a length one list as (x:[])?  Is that the usual way?
19:25:03 <Cale> sethk: or [x]
19:25:20 <sethk> Cale, I didn't know if it was smart enough to interpret [x].  thanks
19:28:51 <blackdog> hm. what's the best way to do marshalling? I just want to be able to pass a couple of strings in and get one back
19:29:15 <blackdog> (sorry, get an IO String back)
19:29:30 <blackdog> Greencard, c2hs, handrolled? Total newb at this.
19:30:18 <Cale> Using the FFI directly isn't too hard
19:30:33 <Cale> and it's worth understanding even if you're going to use c2hs or greencard
19:33:06 <blackdog> ok. my needs are pretty basic anyway. will look for marshalling docs
19:35:38 <Cale> by marshalling, I assume you mean talking with C libraries
19:35:48 <mux> @pl foo x = ["bar", x]
19:35:49 <lambdabot> foo = ("bar" :) . return
19:35:55 <blackdog> no, i'm calling haskell from c.
19:36:11 <Cale> that should be okay too
19:38:07 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
19:38:09 <blackdog> so i suppose that i'm really passing two C strings in and passing a C string back?
19:39:18 <Cale> yeah, there are functions for dealing with that though
19:39:27 <Cale> (converting between C and Haskell strings)
19:51:36 <mux> @pl Just x = x
19:51:37 <lambdabot> Just = id
19:51:44 <mux> @pl foo Just x = x
19:51:44 <lambdabot> foo = const id
19:53:56 <kOxiNeLLe> xerox are you around?
19:54:10 <kOxiNeLLe> or Cale?
19:59:19 <mux> :t liftM
19:59:27 <mux> @type liftM
19:59:28 <lambdabot> forall r (m :: * -> *) a1.
19:59:28 <lambdabot>    (Monad m) =>
19:59:28 <lambdabot>    (a1 -> r) -> m a1 -> m r
20:02:08 <kOxiNeLLe> could anyone tell me where I can get the Mathematica interface plugin for lambdabot?
20:12:42 <lispy> someone at work asked me what was cool about haskell...in a 30 min intro to what i like about haskell i completely forgot to mention lazy evaluation...so many features...so little time
20:47:40 <lispy> mux: yeah, think @type should have :t as an alias :)
20:47:51 <lispy> mux: i've done that a few times in here too
20:55:45 <mwc> Quite channel tonight
20:55:48 <mwc> *quiet
20:56:08 <lispy> indeed
20:56:17 <lispy> or should i say, "ssssh"
20:57:57 * mwc has a violent flashback to a horrible highschool librarian
21:01:19 <lispy> mwc: heh, we went the same school!
21:02:10 <lispy> hmm..so i have some code i could go write and i'm in the mood to program, but i want to write something else :)
21:02:21 <lispy> does that make me an addict yet?
21:03:11 <wchogg> No, just indecisive. :-P
21:04:07 <sethk> lispy, if you like you can do my work.
21:04:18 <lispy> one thing that happens were i work is that we often need a way to interface different languages.  Anyone have suggestions?
21:04:26 <lispy> sethk: hm...perhaps i'll pass :)
21:04:35 <lispy> sethk: well...depends on what it is...
21:04:52 <sethk> lispy, I have all varieties  :)
21:05:17 <lispy> we often need Java <-> Python, Java <-> R, R <-> Python, or even R <-> VB
21:05:50 <sethk> I don't, thank god
21:06:01 <lispy> we looked at Jython but it doesn't support "native" python modules
21:06:19 <blackdog> lispy: R = Ruby?
21:06:20 <Cale> plain text files and unix pipes :)
21:06:28 <Cale> blackdog: no, R is R :)
21:06:33 <lispy> blackdog: no the statists language like S
21:06:36 <blackdog> oh, that maths language
21:07:02 <Cale> though unix pipes won't work too well with VB
21:07:05 <lispy> Cale: hehe, yeah, i do remember suggesting that at one point...although, if we go that route perhaps corba is simpler
21:07:56 <Cale> hmm, "corba" and "simpler" don't seem to belong in the same sentence, but maybe :)
21:08:12 <lispy> Cale: heh, obviously i've never used corba :)
21:09:16 <blackdog> ok. so how do i get the flags that ghc is using for linking the c file together with the haskell stubs?
21:09:32 <blackdog> or should i just make CC=ghc? :)
21:13:10 <lispy> heh, i just saw that a professor i know posted a comment on LtU...it's funny to see a professor i know interacting "in the wild"
21:13:20 <Cale> heh
21:15:15 <blackdog> *david attenborough voice*
21:15:48 <blackdog> these beautiful, shy creatures ... are very rarely seen, scurrying from lecture-room to office as quickly as possible
21:18:06 <blackdog> argh. linking make hulk angry!
21:33:58 <blackdog> ok, i've got it linking ok to ruby, but when i run it, i get the line "undefined symbol rts_lock". any ideas?
21:35:57 <lispy> no ideas
21:36:01 <lispy> sorry :(
21:36:55 <blackdog> it's weird, it works fine when i run the c file, but when i try to call the c function from ruby, it all goes blooey. <-- technical term.
22:16:54 <blackdog> anyone know how to get ghc to spit out a makefile?
22:17:06 <blackdog> hey sean, you lazy bastard.
22:17:33 <palomer> I'd rather ghc spit out a scons file, personally
22:17:45 <blackdog> i really just want the linking flags...
22:17:49 <palomer> but having a makefile would be useful too
22:17:55 <palomer> make is faster than ghc --make
22:18:44 <palomer> much faster
22:21:03 <sethk> how do I hide something in the prelude?  Do I explicitly import it with a hiding clause?
22:21:03 <seafood> blackdog: ghc -M?
22:21:23 <seafood> sethk: Yeah, it's annoying but I think that's the only way to do it.
22:23:10 <sethk> seafood, not terribly difficult, I just didn't know if that was the procedure
22:23:32 <seafood> It's annoying when you want to hide a lot though. 
22:23:37 <Lemmih> sethk: More annoying than hiding symbols from other modules?
22:24:01 <sethk> Lemmih, the same
22:24:56 <Lemmih> sethk: Sorry. I meant seafood. The tab-completion keeps biting me in the ass.
22:25:14 <sethk> Lemmih, yes, like .hi for .hs in the editor  :)
22:39:47 <newsham> i'm in .hi
22:42:38 <Lemmih> Anyone in .hs?
22:43:20 <seafood> Am I missing some sort of Haskell slang here?
22:47:28 <kOxiNeLLe> could anyone tell me where I can get the Mathematica interface plugin for lambdabot?
22:47:30 <kOxiNeLLe> pls?
22:49:52 <Lemmih> kOxiNeLLe: I don't think we know.
22:50:34 <kOxiNeLLe> Lemmih: thanks anyways, I was suggested to come here and ask Cale or people in here 
22:52:05 <newsham> dons alive?
22:52:08 <newsham> seen dons
22:52:13 <newsham> ?seen dons
22:52:14 <lambdabot> dons is in #haskell. I don't know when dons last spoke.
22:53:06 <newsham> anyone here hip to hs-plugins ?
23:00:36 <Lemmih> newsham: What's the problem?
23:01:04 <newsham> not sure if I'm using it right.  i'm not having success.
23:02:32 <newsham> http://udp110165uds.hawaiiantel.net:8888/x/Test.hs  here's my test program.
23:03:00 <newsham> a.out: /home/hws/plugins/UserDirPlugin.o: unknown symbol `ControlziMonadziTrans_zdfMonadIOIO_closure'
23:03:00 <newsham> a.out: Prelude.undefined
23:03:54 <newsham> does that look reasonable?  is there anything special I need to do to the .o when I'm making it?
23:05:27 <Cale> are you running ghc with --make?
23:05:34 <Cale> maybe -package mtl ?
23:05:48 <newsham> ghc -i../src --make -cpp  -package text -package concurrent -package lang -package net -package util -package data -package posix -package plugins Test.hs
23:05:51 <sethk> that looks almost like a c++ mangled name
23:05:54 <newsham> thats hwo I build the Test.hs 
23:06:02 <newsham> the .o was created differently
23:06:09 <Cale> add -package mtl
23:06:45 <Lemmih> hs-plugins should load the needed packages by it self.
23:06:52 <newsham> same error
23:07:22 <newsham> this is 1.0-rc0 of hs-plugins, btw.
23:07:45 <newsham> am I using the plugin api correctly?
23:11:36 <newsham> why does this build even when I dont -package plugins ?
23:13:01 <newsham> hmm.. ok, now I got rid of that error, but its reporting "nada" (ie. the module load failed)
23:13:21 <newsham> (no idea why the error went away.  i rebuilt my code, and move my test case in the same dir as the rest of the code)
23:18:30 <seafood> newsham: It may be building without -package plugins because the plugins package  has been exposed. You can check with ghc-pkg.
23:18:38 <seafood> newsham: ghc-pkg describe plugins
23:23:01 <newsham> hmm.. well i got one simple test to work, not sure why the other one isnt working..  but i guess i can grind this out
23:24:04 <sethk> which is the monad to use to eliminate passing a bunch of things around through function calls?  In this case I've got a Channel, and a Map, and an MVar that are arguments on a bunch of functions that mostly just pass them through.
23:24:11 <sethk> would that be the state monad?
23:24:22 <Cale> sethk: State or Reader
23:24:27 <int-e> reader if the value doesn't change
23:24:45 <sethk> Cale, int-e, ok.  what is the name "reader" intended to convey?
23:25:10 <Cale> computations which read values from an environment
23:25:11 <int-e> I don't know. Probably passing around a value that can be read but not written to.
23:25:19 <Cale> it's really a fancy name for "functions"
23:25:25 <Cale> :)
23:25:38 <sethk> and why do you (int-e) say that reader is better for values that don't change?
23:25:46 <Cale> well, I'd agree with that
23:25:49 <sethk> also, what precisely do you mean by don't change?
23:25:57 <int-e> ((+1) >>= (+)) 23
23:26:00 <int-e> > ((+1) >>= (+)) 23
23:26:01 <lambdabot> 47
23:26:03 <sethk> e.g., I'm passing a Map String Thing.  
23:26:04 <falconair> are there any mac users here?  I see that darwinports has darcs and ghc---fink doesn't seem to have either...any reason why i should keep fink? (info on the web is fairly old, and i'm new mac user)
23:26:21 <sethk> are we talking about the Map contents not changing?
23:26:28 <Cale> sethk: yes
23:26:46 <Cale> (at least, during your computation)
23:26:49 <sethk> Cale, ok, so if the map might be updated, I need to use the state monad rather than the reader?
23:26:55 <Cale> yeah
23:27:03 <sethk> what about a Chan?  Chan is not terribly useful if the contents never change  :)
23:27:03 <int-e> @type local
23:27:05 <lambdabot> forall r (m :: * -> *) a.
23:27:05 <lambdabot>    (MonadReader r m) =>
23:27:05 <lambdabot>    (r -> r) -> m a -> m a
23:27:10 <newsham> hmm..  this seems to work if I have the .hi and .o around, but if the .hi isnt around it fails.
23:27:14 <newsham> I guess thats a requirement?
23:27:31 <sethk> newsham, it uses the .hi to compute dependencies, I believe
23:27:54 <sethk> and to know the signatures.  signatures of foo.hs in foo.hi
23:28:00 <Cale> sethk: well, the Chan itself isn't going to change
23:28:15 <int-e> > ((+1) >>= \n -> local (-10) >> (n+)) 23
23:28:16 <lambdabot>  add an instance declaration for (Num (m a))
23:28:17 <newsham> good to know.
23:28:18 <Cale> (not likely)
23:28:19 <sethk> Cale, correct, that's why I asked about whether we're talking about the contents
23:28:28 <int-e> > ((+1) >>= \n -> local (+-10) >> (n+)) 23
23:28:29 <lambdabot>  Not in scope: `+-'
23:28:41 <sethk> map is different, as when you update a map it returns a new map?  
23:28:58 <sethk> so I can use a reader monad with a chan but not with a map that isn't updated?
23:29:19 <sethk> actually, my map is constructed at startup, and I might be able to defer the monad until after construction.
23:32:16 <newsham> hrm.. if the module relies on the stuff in the binary loading it..  I have to keep all the main systems' .hi files around too?
23:33:23 <Cale> sethk: well, if you're going to use a reader with a Chan, you should probably make that a ReaderT over IO
23:33:31 <Cale> else you won't be able to do anything with the Chan
23:33:48 <sethk> Cale, yes, even if it weren't a chan, many of the functions are in the IO monad.
23:34:14 <sethk> Cale, still, if anything is mutable, I should use StateT rather than ReaderT?
23:40:08 <newsham> well cool, the plugins are working but the program isnt ... 
23:42:15 <newsham> rho rho rho
23:50:25 <drrho> newsham: yes? yes? yes?
23:50:44 <newsham> merrily merrily merrily
23:51:04 <drrho> "ah!" x 3
23:51:37 <lispy> hmm...the ghc manual doesn't seem to talk about foreign types in the FFI section
23:51:55 <newsham> ffi.pdf has a decent section on foreign types
23:52:27 <lispy> i have: struct foo { char* field1; int field1len; char* field2, int field2len}; and i want to import a function which returns a foo struct
23:52:36 <lispy> ffi.pdf? okay, i'll google it
23:53:08 <lispy> actually, if i could convince the interface to import it with the type IO (String, String) it would be ideal
23:53:15 <sethk> also Alistair .. getting old, can't remember his last name .. 's website
23:53:45 <sethk> lispy, I'm not exactly an expert but I don't think you can get an IO anything with ffi
23:54:07 <lispy> i see examples that return IO CInt
23:54:08 <newsham> http://www.haskell.org/hawiki/FfiExample 
23:54:28 <lispy> newsham: ah the wiki, thanks
23:55:01 <newsham> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
23:55:11 <newsham> the latter has ffi.pdf
23:55:21 <drrho> has anyone experiences with using Haskell from Perl5?
23:55:55 <lispy> newsham: thanks
23:56:10 <drrho> Language::Haskell is 'only' version 0.01... (OTOH audreyt is the author)
23:56:12 <newsham> if you have some questions i might be able to help.. i goofed with ffi recently
23:58:22 <lispy> newsham: cool, i think this example may have everything i need (the wiki one)
23:59:15 <newsham> awesome.. i wrote it ;-)
