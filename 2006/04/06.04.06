00:01:09 <RyanT5000> thanks for the huge amount of help; you guys have been great; goodnight
00:01:24 <ncalexan> good luck.
00:01:39 <RyanT5000> thanks
00:01:48 <RyanT5000> first thing tomorrow: make a debug build of sdl :-/
00:44:27 <audreyt> @pl unfoldr (\x -> Just ("~Y"++x, x)) "~Y~"
00:44:27 <lambdabot> unfoldr (Just . ((,) =<< ("~Y" ++))) "~Y~"
00:56:04 <dons> ?pl (\x -> Just ("~Y"++x, x))
00:56:05 <lambdabot> Just . ((,) =<< ("~Y" ++))
00:56:11 <dons> yeeah, not much to do
00:56:55 <Lokadin> have any intelligent shells ever actually been made?
00:57:19 <Lokadin> or do they just all die in planning?
00:57:21 <Lokadin> lol
00:59:58 <shapr> I've heard good things about scsh
01:00:53 <shapr> After looking over the Software Development Conference & Expo... I realize that Haskell probably does look like an ivory tower language to many devleopers.
01:01:07 <LoganH> It does.
01:01:26 <Lokadin> what does that mean? as in what's an ivory tower language?
01:01:27 <wchogg> How so?
01:01:31 <shapr> On the other hand, it seems like a lot of them consider Python and Ruby in the same light.
01:01:42 <LoganH> shapr: As Haskell?
01:02:03 <wchogg> Okay, now I'm really confused.  How are Python or Ruby exotic or "academic"?
01:02:07 <shapr> LoganH: At least, "too cute for its own good"
01:02:32 <LoganH> I measure a language's ivory-towerness as inversely proportional to the number of programs developed in it a typical non-academic programmer knows of.
01:02:51 <pejo> Lokadin, what is an 'intelligent' shell?
01:02:57 <shapr> wchogg: It's likely that any person who has joined #haskell would not consider Ruby or Python exotic.
01:03:20 <shapr> wchogg: On the other hand, someone who's used only C and C++ for the last five years since they got out of college...
01:03:23 <LoganH> I consider exotic another dimension.
01:03:27 <Lokadin> pejo: one that knows that it's being used lol, or at least corrects spelling mistakes etc
01:03:38 <LoganH> Haskell is exotic and intellectual.
01:03:40 * Saulzar would have, about 6 months ago. Also Haskell ... 
01:04:23 <ValarQ> fortran is exotic
01:04:25 <shapr> LoganH: At least Haskell has darcs :-)
01:04:44 <shapr> And zamez' FactorCSS is popular.
01:04:48 <pejo> Lokadin, ah, ok. Sounds painful, considering we've all tried the autocorrect thing in tcsh.
01:04:49 <wchogg> Heh...we still use 80000 line programs of Fortran77.
01:05:06 <ValarQ> wchogg: ouch :)
01:05:09 <shapr> zsh autocorrect is nice.
01:05:24 <astrolabe> Fortran is a good language, for its purpose.
01:05:33 <shapr> Part of my .zshrc is: setopt dvorak # with spelling correction, assume dvorak kb
01:05:44 <wchogg> I've heard of zsh.  The german particle physics lab DESY is switching to it on their machines.
01:05:54 <ValarQ> astrolabe: it doesn't make it less exotic in my eyes i'm afraid
01:05:59 <shapr> I like zsh most out of all the shells I've tried.
01:06:24 <shapr> The only one that can compete is emacs' eshell, and that's only because I can do inline elisp and pipe to and from buffers.
01:06:26 <wchogg> Fortran is good in small doses.  Monolithic Fortran 77 programs are essentially unmaintable and unextendable.
01:06:38 <pejo> I'm using zsh too, but I don't trust it to correct my typing. Quite often I actually do want a unique filename, like whatever.conf.2, not corrected to whatever.conf.
01:06:43 <shapr> h4sh under Yi... that would be nice :-)
01:07:03 <shapr> pejo: I have zsh set to ask me if I want to correct x to y.
01:07:54 <wchogg> Wow...I didn't realize how long it takes for ghc to compile.
01:07:58 <pejo> shapr, don't you get annoyed by all the questions? :-)
01:08:25 <LoganH> shapr: That's probably the only program anyone could name. :P
01:09:10 <shapr> LoganH: Still, how many people can name a program they use that's written in Common Lisp?
01:12:01 <Lokadin> not me
01:12:14 <shapr> I bet Haskell would be nice for this new behaviour driven development buzzword.
01:13:00 <wchogg> What's that mean?
01:13:09 <LoganH> shapr: I consider lisp an ivory tower language too.
01:15:36 <shapr> http://behaviour-driven.org/ - obviously needs Haskell :-)
01:16:33 <wchogg> Oh for the love of...do they have to have a cute phrase for everything?
01:18:30 <wchogg> Okay...let's try mapping newspeak to english.  So are their Ubiquitous Languages just DSLs?
01:19:36 <shapr> I think so.
01:20:06 <shapr> Man, I gotta finish hacking Oleg's HSXML into a bloggy thing so I can write about this.
01:21:19 <wchogg> Huh...okay.  So I see what you mean.  The whole idea here seems to be that you build robust DSLs and build your applications around that?  That does sound pretty Haskell-y.
01:22:12 <shapr> Well, DSLs and test driven development.
01:22:24 <shapr> This is where I start waving the QuickCheck flag...
01:22:29 <wchogg> Exactly.
01:23:09 <wchogg> Although, I haven't really tried QuickCheck, just read some of the documentation.  I wish I could use it for a project I have, but it's in c++.
01:23:29 <shapr> You can still use QuickCheck for a C++ project.
01:23:53 <shapr> You could just generate test data or you could bind via the FFI.
01:24:23 <wchogg> Ah...but I'm not allowed to include anything that wasn't written in c++ as any part of the project.
01:24:38 <wchogg> Not even for testing or some other small task.
01:24:50 <shapr> Are you allowed to use anything non-C++?
01:25:03 <wchogg> ...no.
01:25:23 <shapr> suck
01:25:25 <wchogg> ...and that's why I'm such a fun happy person!
01:26:11 <sieni> no makefiles, nothing?
01:26:27 <shapr> Hm, do I send a long email to Dave Astels explaining why OO is not necessary for Behaviour Driven Development, and how BDD is an obvious sequel to the discovery of refactoring?
01:26:52 <sieni> shapr: perhaps
01:27:34 <shapr> I think the Blub Paradox is not about looking up the power scale, I think it's just psychology of learning... you have to almost already know something to learn it.
01:28:58 <ski> (have to already know much of the required background knowledge ..)
01:30:04 <wchogg> shapr:  Well also, the inertia against learning increases rapidly with the size of a collaboration.  In high energy physics, it's taken until basically now for us to start doing things in c++ rather than fortran 77.
01:30:21 <tennin> missed the last 15 minutes
01:30:49 <tennin> so is behavior-driven development like behavioral psychology?
01:31:45 <wchogg> That gives me an idea:  pavlovian development.  Train programmers to produce code when exposed to certain stimuli.
01:31:47 <tennin> and if so, who play the role of the rats in the box?  the computer, the users, the developers, or the business clients?
01:31:54 <tennin> haha beat me to it
01:32:42 <wchogg> I think mathematicians having being doing something like that with coffee for years.  
01:33:56 <pejo> wchagg, or as a professor here put it: In america, they only produce Lemmas.
01:36:28 <wchogg> Okay...so ghc has been compiling for an hour I think.
01:37:14 <NameTab> wchogg: it takes ages
01:37:21 <NameTab> it did on my gentoo box anyway
01:37:35 <NameTab> I did it twice even *sigh*
01:37:40 <wchogg> yeah, this is gentoo as well.  I didn't think it would take so long.
01:37:54 <NameTab> what kind of proc do you have?
01:38:11 <NameTab> ghc is *big*
01:38:26 <NameTab> my p3 800mhz did over 10 hours to compile
01:39:13 <wchogg> Shoot...now I can't remember the speed of this processor.  It's a pentium-m...1.6 I believe?  it's 3am so I'm hazy.
01:39:48 <Lokadin> wchogg: cat /proc/cpuinfo
01:40:18 <wchogg> yes!  I knew there was an easy way to do it.  Thanks.
01:40:30 <Lokadin> np, mine's the same
01:40:34 <wchogg> Pentium-m 1.86GHz.
01:40:42 <Lokadin> mines 1.6
01:40:43 <Lokadin> lol
01:40:52 <wchogg> I just bought this last month.
01:41:23 <NameTab> why not wait another month for a amd64bit dualcore? *grin*
01:41:52 <wchogg> How much would *that* cost?
01:42:18 <NameTab> my roommate bought one for 1000euro's
01:42:25 <NameTab> pretty heavy specs
01:42:53 <wchogg> That's not too bad, but still out of my price range.  Being married and a grad-student sucks out my income.
01:43:14 <Muad_Dibber> NameTab, stop bragging about!
01:43:18 <neologism> I dont think its so hard
01:43:21 <neologism> s/hard/expensive
01:44:01 <wchogg> Maybe I've got the conversion wrong.  What's the current euro->USD rate?
01:44:16 <neologism> 1 -> 1.2
01:44:19 <neologism> or so
01:44:47 <neologism> the cheapest dualcore amd is for about 300$
01:45:04 <wchogg> Ah.  I thought it was more like 1.4 or 1.5.  Not sure why I remembered that wrong.
01:46:00 <Lokadin> it's 1 - 1.4 if it's to canadian
01:48:06 <NameTab> Muad_Dibber: it's not bragging, it's being jealous :(
01:48:14 <Muad_Dibber> Hehe
01:48:34 <NameTab> the only thing I can brag about is my compile time for lengt ;)
01:48:41 <Muad_Dibber> Hehe
01:48:48 <NameTab> wxhaskell works btw
01:48:58 <Muad_Dibber> The only thing I can brag about is having a sparc box with ghc + lambdabot!! :)
01:49:02 <Muad_Dibber> (without wxHaskell)
01:49:25 <NameTab> sparc would pwn in my room, I've got some spare space.. :P
01:49:42 <Muad_Dibber> hehe
01:50:08 <wchogg> What's special about sparc?
01:50:20 <NameTab> the fact that its not x86
01:50:26 <x0rvoid> anyone here got lambabot compiled under win?
01:50:51 <earthy> I actually dumped my sparc
01:51:16 <earthy> as in dropped of at a garbage collection facility
01:51:41 <earthy> processor architecture is *not* interesting from a highlevel language design point of view
01:52:28 <pejo> earthy, and sparc is even less interesting considering that it is slow for most usage patterns for desktop usage.
01:53:59 <Muad_Dibber> however, sparc is interesting for me as in I got it for free, so it was nice to experiment with it while maintaining my working desktop computer ;)
01:54:28 <wchogg> Cool.  Did a business just want to dump it or something?
02:02:43 <earthy> muad: true enough
02:03:07 <earthy> and as a processor architecture, sparc isn't all bad
02:04:02 <dcoutts> mmm 32way on-a-chip sparc
02:05:29 <dcoutts> Muad_Dibber, we've got wxhaskell working on sparc using the gentoo package
02:05:48 <Muad_Dibber> dcoutts, yeah, but my sparc does not have a monitor or X installed...
02:06:11 <dcoutts> you want the Xlibs only, then you can use remote X
02:08:11 <Muad_Dibber> dcoutts, its burdened already by acting as svn + http + mysql + php + smb server; let me use X on my normal desktop pc only ;)
02:08:25 <dcoutts> heh, ok
02:08:45 * dcoutts uses his sparc as a desktop machine
02:09:25 <NameTab>  Muad_Dibber are you sure there's no wxhaskell for 64bit?
02:11:07 <Muad_Dibber> NameTab, I have no idea
02:15:03 <NameTab> well, time to do the dishes anyway *sigh*
02:47:03 <bolrod> robokop: need wxhaskell?
02:48:52 <dcoutts> NameTab, wxhaskell works on amd64
02:49:28 <dcoutts> pretty much all Haskell software does (except hs-plugins)
02:51:08 <robokop> bolrod: yes
02:53:03 <Muad_Dibber> and even hs-plugins works when working in a 32bit chroot ;)
02:54:22 <dcoutts> heh, yeah
02:55:57 <bolrod> ^.0
02:56:56 <Muad_Dibber> NameTab, bolrod, your 3rd lab assignment involves wxHaskell, doesn't it?
02:58:12 <bolrod> yes
02:58:21 <bolrod> robokop: does it work?
02:58:22 <NameTab>  why do you think I was trying to make it work? :)
02:59:37 <Muad_Dibber> For once, you could be interested in something you were not force to look at ;)
02:59:59 <bolrod> ?
03:00:20 <NameTab> bolrod: n/m dibber :P
03:00:24 <NameTab> I'm afk
03:00:26 <NameTab> or I'll be late
03:00:28 <NameTab> ttyl all
03:00:32 <Muad_Dibber> ciao NameTab 
03:00:34 <bolrod> cya
03:02:21 <dons> ?uptime
03:02:21 <lambdabot> uptime: 2 days, 7 hours, 1 minute and 12 seconds
03:05:00 <bolrod> robokop: does the .deb work?
03:06:20 <robokop> bolrod it install and gives some errors
03:06:33 <bolrod> yeah
03:06:36 <bolrod> about overwriting
03:06:41 <robokop> bolrod yes
03:06:45 <bolrod> dpkg --force-overwrite -i
03:08:08 <robokop> > let {comp = (<); othercomp = if 1 `comp` 0 then (<) else (>)} in 1 `othercomp` 0
03:08:08 <lambdabot> True
03:08:38 <robokop> w00tness
03:09:36 <robokop> bolrod: Loading package wxcore-0.9.4 ... ghc-6.4.1: /usr/local/lib/wxcore.o: no string tables, or too many
03:09:48 <robokop> says ghci
03:10:29 <bolrod> yes
03:10:32 <bolrod> thats with ghci
03:10:36 <bolrod> ghc works fine
03:11:16 <dcoutts> robokop, what arch is that on?
03:11:22 <bolrod> i386
03:11:30 <dcoutts> oh, ok odd
03:15:39 * robokop is out to lunch
03:26:25 <JaffaCake> hey Lemmih, are you there?
03:26:51 <Lemmih> Yeah.
03:27:05 <JaffaCake> GHCi on HEAD is doing this:
03:27:15 <JaffaCake> [3 of 4] Skipping  B                ( B.hs, interpreted )
03:27:24 <JaffaCake> even when using the object file for B (B.o)
03:27:32 <JaffaCake> i.e. it shouldnt' be saying "interpreted"
03:28:28 <JaffaCake> looks like the information about whether we have an object linkable or not isn't being passed into hscCompileInteractive?
03:29:12 <dcoutts> JaffaCake, long time no see!
03:29:13 <Lemmih> I've noticed that too. It thinks that it doesn't have an object file if it doesn't have an OldLinkable.
03:29:26 <JaffaCake> hi dcoutts :) yeah
03:29:55 <dcoutts> JaffaCake, sorry for pestering you with tiny patches, I'll just push them in future (unless they really need discussion/review)
03:30:04 <Lemmih> So if the src file is newer than the object file, GHC thinks it's interpreting.
03:30:13 <JaffaCake> dcoutts: sure, thanksl 
03:30:33 <JaffaCake> Lemmih: yes, I think we used to pass a have_object flag to hscMain
03:30:47 <Lemmih> JaffaCake: I want HscTypes.showModMsg to take a HscTarget instead of have_object.
03:31:06 <JaffaCake> ok, sounds reasonable
03:31:47 * Lemmih should record and push his changes to DriverPipeline.
03:38:06 <Lemmih> Oh wait. I'm was thinking about something else.
03:39:04 * shapr wishes for a way to use a Maybe monad in xml templating
03:40:04 <shapr> hiya insitu 
03:40:25 <shapr> insitu: Bonjour, comment ca va?
03:40:43 <insitu> je vois que votre franÃ§ais n'est pas trop rouillÃ©.
03:44:30 <earthy> ;)
03:44:41 <dons> ?version
03:44:48 <lambdabot> lambdabot 3p400, GHC 6.4.1 (Linux i686 3.20GHz)
03:44:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:44:50 <dons> 400!
03:45:00 <dons> ?brain
03:45:01 <lambdabot> Yeah, but I thought Madonna already had a steady bloke!
03:45:05 <dons> ?brain
03:45:06 <lambdabot> Uh, I think so Brain, but this time, you wear the tutu.
03:45:12 <dons> ?brain
03:45:12 <lambdabot> It is here that my cheap workforce of trained iguanas will work
03:45:12 <lambdabot> night and day to make our shoes to my exacting specifications!
03:45:19 <dons> ?help brain
03:45:20 <lambdabot> brain. Pinky and the Brain
03:45:38 <dcoutts> dons, @yarr! has gone all non-pirate :-(
03:45:42 <dcoutts> @yarr!
03:45:43 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
03:45:47 <dons> oh. hmm
03:45:51 <dons> ?arr
03:45:51 <lambdabot> know you know this 24 periods Keal SecretTM
03:45:57 <dons> weird
03:46:02 <ski> 2help arr
03:46:04 <dons> must be a copy-pasto
03:46:06 <ski> @help arr
03:46:06 <lambdabot> arr. Talk to a pirate
03:46:13 <dons> I just refactored that module
03:46:13 <shapr> insitu: Je pense que mon français est trop rouillé :-)
03:46:29 <shapr> @arr
03:46:29 <lambdabot> where can i find opensource schematics of Linus Torvalds' x86 clone?
03:46:29 <dons> ?keal
03:46:30 <lambdabot> Har de har har!
03:46:35 <dons> they got swapped
03:46:39 <dons> ?kkeal
03:46:40 <lambdabot> Har de har har!
03:46:56 <insitu> c'est ennuyeux
03:47:01 <Muad_Dibber> hihi
03:48:43 <dons> ?arr
03:48:43 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
03:48:48 <dons> dcoutts, fixed.
03:48:53 <dons> ?brain
03:48:54 <lambdabot> Brain! Brain! You aren't going to leave me!!!???You know what happened to Jerry Lewis after Dean Martin left him!!!
03:49:58 <shapr> "Are you thinking what I'm thinking Pinky?" "Yeah Brain, but where we gonna get rubber pants this time of night?"
03:50:20 <shapr> "What we gonna do today Brain?" "The same thing we do every day Pinky, TRY TO TAKE OVER THE WORLD!"
03:50:29 * shapr luvs Pinky & The Brain
03:50:32 <Muad_Dibber> hehe
03:50:36 <dcoutts> dons, thanks!
03:50:38 <dcoutts> @yarr!
03:50:38 <lambdabot> Smartly me lass
03:50:39 <Muad_Dibber> its been to long since I seen them on tv :P
03:50:41 <shapr> @brain
03:50:41 <lambdabot> I think so, Brain, but a codpiece made from a real fish would get smelly after a while, wouldn?t it?
03:50:46 * shapr laughs
03:52:09 <shapr> @listmodules
03:52:10 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
03:52:10 <lambdabot> unlambda version vixen where
03:52:17 <shapr> Yow, lotsa
03:52:37 --- mode: shapr set +o JaffaCake
03:52:42 --- mode: shapr set -o shapr
03:53:05 <shapr> LoganH: What are you research/language interests these days?
03:53:09 <shapr> s/you/your
03:54:15 <timbod> dcoutts: As i was discussing yesterday, I'm closer to making my simple chart lib public. Why did you choose LGPL over BSD for gtk2hs?
04:02:30 <dcoutts> timbod, because Gtk+ is LGPL
04:02:39 * shapr throws lambdas
04:02:44 <dcoutts> so BSD would have added nothing
04:03:47 <dcoutts> timbod, and yeah, we know that there is a potential problem for static linking. We'd be happy to add a static linking exception if anyone really cared.
04:04:34 <dcoutts> timbod, did you have any concerns or you were just wondering why we decided what we did?
04:08:29 <shapr> dons: Did you see Philippa's idea about an hs-plugins daemon for a webapp server?
04:09:03 <shapr> So, anyone read any cool research papers recently?
04:10:53 <Philippa> shapr: I've talked to dons about the idea before
04:11:01 <shapr> What did he say?
04:11:09 <Philippa> liked the idea
04:11:25 <Philippa> I suspect a bit of a case of "so show me code!" :-)
04:12:01 <shapr> I'd suggest the lambdabot approach, just make a big typeclass for each 'call' and a simple string based plugin system for easy use.
04:16:04 <musasabi> Didn't Niklas Bromberg have a hs-plugins daemon for a webapp server?
04:16:25 <shapr> Did he?
04:16:46 <shapr> hiya kep_ 
04:16:54 <musasabi> -m
04:17:43 <musasabi> "on-request compilation of pages (using hs-plugins)" from the HSP page.
04:18:22 <tic> yuck, M and V. :(
04:18:25 <tic> er, mixing those.
04:18:27 <shapr> oh neat
04:19:16 <kep_> shapr hi 
04:20:25 <kep_> people, somebody knows right ways to debug haskell programm ?  I mean debug like in Java ? 
04:22:23 <pejo> kep, www.haskell.org/hat might be what you're looking for. Shapr likes QuickCheck. 
04:22:54 <shapr> Lemmih's recent nifty GHC debug code might be nice too.
04:25:24 <shapr> Korollary: Celine Dion!
04:29:01 <kep_> pejo 10x :)
04:29:51 <shapr> I do like QuickCheck :-)
04:29:55 <kep_> shapr do you have a link to description ?
04:30:37 <shapr> @where QuickCheck
04:30:37 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
04:31:57 <kep_> shapr thank you :)
04:32:07 <timbod> dcoutts: No real concerns, I don't really follow license issues very much, but figured that I would use LGPL if I could see no stronger reason to use anything else.
04:32:32 <timbod> dcoutts: Is there plans to separate out cairo from gtk2hs?
04:34:59 <timbod> anyone know if there is a standard way to package up a web page and associated images in a single file? I've got some haskell code that calculates values for reports, and I'm trying to work out how to deliver them.
04:36:37 <kep_> timbod save it from firefox , as a variant
04:36:59 <twb> timbod: IE has used MIME for years.
04:37:17 <dcoutts> timbod, yeah, the plan is that eventually the various gtk2hs components will be seperate (inter-dependent) packages
04:38:03 <dcoutts> timbod, so yes, cairo could be distributed on its own. It already only depends on the glib package (for marshaling code)
04:38:19 <timbod> keb_: what do you mean by "variant" ?
04:38:49 <boegel> timbod: "save as" ?
04:39:13 <timbod> dcoutts: I'm keen to put some cairo code behind some web pages, and the whole gtk2hs seem like quite a lot of baggage. (but it does work well - thanks!)
04:42:07 <kep_> timbod I mean that I use the Firefox for saving html with images, as I remember was a plugin for the Firefox that support archives with html and pics , but I don't use it yet
04:43:19 <timbod>  save as in firefox generates a html file and a subdirectory of associated stuff - I was hoping for a cross browser single file solution, oh well.
04:44:13 <kep_> timbod it's hard task
04:44:18 <pejo> timbod, make a .pdf out of it?
04:45:17 <kep_> pejo pdf format will not resized, sometime reading from pdf more slowly than a html 
04:46:01 <kep_> timbod portable solution will be make a directory with pictures by hands 
04:48:42 <timbod> pdf would be good, but i'm not aware of any haskell code for that - any suggestions?
04:48:44 <shapr> privet kuvkir 
04:48:59 <kuvkir> shapr: privet
04:49:02 <shapr> timbod: script openoffice?
04:49:12 <kuvkir> shapr: do you know russian?
04:49:57 <shapr> kuvkir: No, just a few words.
04:51:19 <shapr> kuvkir: Do you know Russian? :-)
04:52:11 <kuvkir> shapr: russian is my native language:)
04:55:09 <kep_> kuvkir preved :)
04:55:37 <kuvkir> kep_: Ð¿Ñ€ÐµÐ²ÐµÐ´
04:55:45 <shapr> Was that koi-8?
04:55:57 <kep_> timbod will be good , if you make two versions of the doc , pdf and html 
04:55:57 <mauke> no, utf-8
04:56:00 <shapr> ah
04:56:04 * shapr switches encoding
04:56:04 <kuvkir> shapr: seems utf
04:56:19 <kep_> kuvkir write esperanto :) be happy :)))
04:56:21 <mauke> pe er ie ve ie de
04:56:30 <shapr> xu do tavla mi bau la lojban
04:56:52 <kep_> shapr why not loglan ? :)))) 
04:56:59 * kuvkir doesn't know esperanto at all
04:57:01 <shapr> kep_: James Cooke Brown :-)
04:58:59 <kep_> shapr :) yes, Dr. James Cooke Brown :)))))
04:59:36 <kep_> shapr but I don't know loglan/lojban :)))
04:59:47 <shapr> They're pretty easy.
05:00:27 <kep_> shapr may be :)
05:00:47 <shapr> Lojban taught me new ways of thinking about things, so it proved the Sapir-Whorf hypothesis for me.
05:01:11 <shapr> I originally wanted to learn it for spoken programming.
05:08:57 <kep_> shapr i know about it , and it's very intresting for me too :))) 
05:11:07 <kep_> shapr there is an intresting thing, people want to learn programming language to speed up his programming,  but not a lot of us want to learn a language to speed up our thinking :))) 
05:12:40 <shapr> That's a funny thought.
05:12:43 <shapr> True too.
05:17:05 <kep_> shapr :)
05:22:26 <kep_> shapr do you think on the lojban ? 
05:23:52 <shapr> As far as I can tell, I don't think in any language. But, some ideas and concepts are easier to express in lojban rather than any other language I can speak.
05:24:43 <shapr> mi djica lenu mi gunka
05:27:31 <kep_> shapr .i ki'e do
05:27:36 <kep_> shapr :)
05:28:32 <kep_> shapr something like this ? 
05:28:51 <pierre-> hello.
05:29:11 <kep_> pierre- hi
05:29:47 <shapr> I can't think of anything that's easier to say in lojban right now, but I'll get back to you when I'm done working :-)
05:52:25 <robokop> when compiling my program in ghc and then linking the 2 .o files i get loads of error messages about undefined references
05:54:01 <ibid> how are you linking?
05:54:15 <robokop> ld a.o b.o -o a.out
05:56:10 <qwr_> how should the ld know, what libraries should be linked, when none is given to it? ;)
05:58:02 <dozer> hum - just worked thorugh to type-classes in the "gentle introduction"
05:58:47 <qwr_> robokop: try ghc a.o b.o or ghc a.hs b.hs
05:58:57 <ibid> robokop: i recommend using the language's own compiler to perform the link
05:59:14 <ibid> robokop: it knows what libraries are needed for language support
05:59:26 <twb> Does haskell use exact rationals where possible?
05:59:58 <mauke> no, only where you tell it to
06:00:04 <twb> Hmm.
06:00:07 <twb> (2/3) :: Rational ==> 2%3
06:01:13 <robokop> ibid, qwr_: thanks
06:02:02 <robokop> but it gives still some errors
06:02:05 <dozer> so - type classes provide funcitonality sort of like a Java interface, or an ML signature?
06:02:38 <twb> Type classes provide similar functionality to generic functions.
06:02:42 <ibid> dozer: yes, but emphasizing the "sort of" part :)
06:03:38 <twb> For example, a type `Foo' is a member of the Show class if there exists an implementation of show :: Foo -> String.
06:03:41 <robokop>  /usr/lib/ghc-6.4.1/libHSrts.a(Main.o): In function `main': undefined reference to `__stginit_ZCMain'
06:04:07 <twb> By defining show :: Foo -> String, any function that uses show can suddenly operate on Foo values.
06:04:17 <twb> (end of fuzzy twb explanation)
06:04:49 <dozer> twb: fine - and I can take /any/ type that is an instance of the Foo class and call show, and it will resolve to the right implementation for that type?
06:05:13 <twb> dozer: yes.
06:05:18 <dozer> cool
06:05:30 <twb> It will dispatch to the correct definition of show.
06:06:09 <twb> Note that primitive haskell types are independent, tho.
06:06:30 <twb> e.g. '2 :: Integer' isn't a Rational.
06:07:07 <twb> Although there is magic to let constants work.
06:08:48 <robokop> @type fromInt
06:08:49 <lambdabot> Not in scope: `fromInt'
06:08:54 <robokop> @type fromInteger
06:08:55 <lambdabot> forall a. (Num a) => Integer -> a
06:10:42 <robokop> when i try to build an executable with ghc it gives me some errors like these
06:10:45 <robokop>  /usr/lib/ghc-6.4.1/libHSrts.a(Main.o): In function `main': undefined reference to `__stginit_ZCMain'
06:11:10 <twb> dozer: http://twb.ath.cx/tmp/tmp.hs <-- type class example
06:11:55 <dozer> sweet - got the idea now
06:13:18 <dozer> twb: "sort of" the inverse idea to cross-cuts in aspects
06:13:40 <twb> dozer: are you talking about aspectJ / AOP ?
06:13:47 <dozer> twb: yeah
06:13:52 <twb> dozer: I've seen that in lisp.
06:14:06 <twb> dozer: I'd have to think about how that relates to type classes, though.
06:14:11 * dozer shudders at the thought of seeing anything in lisp
06:14:34 <twb> dozer: AOP was in lisp for at least 10 years before Java got it.
06:14:42 <twb> dozer: probably for 10 years before Java existed.
06:14:47 <dozer> :)
06:15:10 <twb> It's been suggested that AOP is the MOP author's attempt to backport CLOS / MOP stuff to Java.
06:15:52 <twb> "We were not out to win over the Lisp programmers; we were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp."  -- Guy Steele, Java spec co-author, http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg04045.html
06:16:49 <robokop> could sb help me out with this
06:16:54 <robokop>  /usr/lib/ghc-6.4.1/libHSrts.a(Main.o): In function `main': undefined reference to `__stginit_ZCMain'
06:17:26 <twb> robokop: that's a linker error.
06:17:34 <twb> robokop: you're missing a function or library.
06:17:40 <bolrod> robokop: http://wiki.loria.fr/wiki/GenI/Getting_GenI/Instructions_for_Ubuntu_Linux
06:17:44 <bolrod> try compiling the wxwidgets
06:17:52 <twb> robokop: are you invoking ghc with --make ?
06:18:21 <robokop> nope first did that and recieved 2 .o files
06:18:36 <twb> robokop: you received object files because ghc failed.
06:18:44 <twb> robokop: it would have printed an error.
06:18:48 <robokop> and now i just do ghc a.o b.o
06:20:11 <robokop> retrying the ghc --make now and see if i get erroe
06:20:19 <robokop> *errors
06:21:25 <robokop> twb: no errors
06:21:43 <twb> robokop: does the .hs file you're compiling have a `make' definition?
06:21:43 <robokop> but just makeing two .o files
06:21:55 <robokop> no
06:21:59 <twb> Ah.
06:22:07 <twb> That's why.
06:22:12 <twb> Are you compiling a library?
06:22:18 <robokop> nop
06:22:31 <twb> What do you expect the compiled program to do?
06:23:03 <robokop> ask me some questions and then provoke a genetic algorithm
06:23:37 <twb> robokop: if there is no `main' definition, where do you expect execution to start?
06:24:16 <robokop> main is there
06:24:21 <robokop> but no make
06:24:26 <twb> ?
06:24:41 <robokop> (15:21:20) twb: robokop: does the .hs file you're compiling have a `make' definition?
06:24:42 <robokop> (15:21:31) robokop: no
06:24:50 <twb> Sorry, I misspelled `main'.
06:25:06 <robokop> ke
06:25:46 <twb> robokop: consider the example file http://twb.ath.cx/tmp/Main.hs
06:25:56 <twb> robokop: I compile it with "ghc -o Main --make Main"
06:26:30 <twb> After that one command, the binary "Main" exists, which I can run from my Unix shell.
06:28:14 <robokop> twb: think i found my mistake my module wasn't called Main
06:28:30 <robokop> twb: only had the function main
06:30:07 <robokop> now it works
06:30:38 <twb> robokop: twb is wise and powerful!  Tell your friends!
06:32:00 <davidhouse> @hoogle getArgs
06:32:00 <lambdabot> System.getArgs :: IO [String]
06:34:54 * robokop tells all his friends how powerfull and wise twb is (not a single word came out of my mouth)
06:37:30 <twb> @index fix
06:37:30 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
06:39:02 <bolrod> psh!
06:39:45 <bolrod> robokop: dont use the upx compression he sais in the paper
06:39:47 <bolrod> its SLOW 
06:39:51 <bolrod> use gzexe
06:39:58 <bolrod> faster and better :)
06:45:49 <davidhouse> any modules/functions floating about for interaction with the shell?
06:46:29 <xerox> ?index interact
06:46:29 <lambdabot> System.IO, Prelude
06:46:38 <xerox> ?type System.IO.interact
06:46:39 <lambdabot> (String -> String) -> IO ()
06:47:27 <davidhouse> String -> String?
06:47:37 <davidhouse> hmm, perhaps not what i want
06:47:50 <davidhouse> i want to send a command to the shell and collect the output
06:47:56 <davidhouse> @hoogle String -> IO String
06:47:56 <lambdabot> System.getEnv :: String -> IO String
06:47:56 <lambdabot> System.Console.Readline.quoteFilename :: String -> Bool -> Ptr CChar -> IO String
06:48:18 <bolrod> is that possible?
06:48:21 <xerox> Aaaah.
06:48:23 <xerox> Sure.
06:48:31 <xerox> ?docs System.Process
06:48:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
06:49:34 <davidhouse> does a FilePath have to be absolute?
06:49:58 <davidhouse> or, for example, can i call runProcess with a FilePath argument of something like "svn"
06:51:55 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#t%3AFilePath
06:52:52 <davidhouse> thanks. that tells me precisely nothing ;)
06:53:07 <Lemmih> It doesn't have to be absolute.
06:53:57 <xerox> Wops.  What I read.
06:54:24 <davidhouse> thanks, Lemmih
06:54:54 <davidhouse> so if i want to send a command to the shell and collect the output, the best function to use would be runInteractiveCommand?
06:54:57 <bolrod> dblhelix: in the slides there is   class Ord a => Enum a where
06:55:05 <bolrod> I dont see that in the report though..  
06:55:06 <davidhouse> then read from the out handle it gives me?
06:55:22 <bolrod> its just  Class Enum a where
06:55:33 <davidhouse> bolrod, Enum isn't a subclass of Ord.
06:55:44 <davidhouse> sorry, yes it is
06:55:46 <davidhouse> or should be.
06:56:10 <bolrod> eh?
06:56:39 <davidhouse> that's not what you're discussing?
06:57:04 <bolrod> well
06:57:15 <bolrod> you can have a class Enum something without it being in Ord something
06:57:16 <bolrod> right?
06:57:28 <bolrod> lets see.. I made an instance of Enum
06:59:03 <bolrod> yes.. and it compiles just fine even when I dont make it an instance of Ord
06:59:26 <bolrod> I also dont see Enum use any functions that have been defined in the class Ord
07:00:10 <davidhouse> i guess i'm thinking logically. if you can enumerate something, you should be able to order any two items
07:01:07 <bolrod> well...  but it doesn't have the restriction
07:01:47 <bolrod> sure you could order things if you can enumerate it
07:03:43 <davidhouse> @where paste
07:03:44 <lambdabot> http://paste.lisp.org/new/haskell
07:04:06 <lisppaste2> davidhouse pasted "why won't this run?" at http://paste.lisp.org/display/18687
07:04:15 <davidhouse> ^^ anyone see anything wrong with that/
07:04:42 <lisppaste2> davidhouse annotated #18687 with "what i get when i try to run it" at http://paste.lisp.org/display/18687#1
07:04:46 <dblhelix> bolrod: indeed, Enum is not a subclass of ord
07:04:49 <davidhouse> ^^ that's the error i get
07:05:04 <twb> Hee, ackermann's stack overflows pretty quick in ghci.
07:05:31 <bolrod> and  the minimal defenition is toEnum and fromEnum... 
07:05:32 <bolrod> right?
07:06:36 <dblhelix> bolrod: yes
07:07:30 <bolrod> the defenition in the prelude sure is a little bit more difficult to understand
07:10:42 <davidhouse> @hoogle getArgs
07:10:42 <lambdabot> System.getArgs :: IO [String]
07:14:53 <gadolin> mathrick hej
07:20:22 <twb> Can I express this more concisely with a comprehension?
07:20:22 <twb> fib' x = iter 1 0 x
07:20:22 <twb>     where iter _ b 0 = b
07:20:22 <twb>           iter a b n = iter (a + b) a (pred n)
07:28:52 <davidhouse> why not do it like this?
07:29:16 <davidhouse> fib 1 = 1; fib 2 = 1; fib n = (fib $ n - 1) + (fib $ n - 2)
07:29:33 <twb> davidhouse: because that doesn't memoize.
07:29:40 <xerox> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
07:29:57 <davidhouse> twb, memoize?
07:30:02 <xerox> (This one does.)
07:30:12 <twb> davidhouse: caching generated values for later use.
07:30:27 <davidhouse> oh, caching.
07:30:31 <xerox> Like it?
07:30:36 <davidhouse> (did you mean "memorize"?)
07:30:40 <twb> xerox: Yes, I've seen it before.
07:30:44 <twb> davidhouse: no, memoize.
07:30:48 <davidhouse> okay then.
07:30:53 <twb> davidhouse: it's an established term, at least in the Lisp community.
07:30:58 * xerox prepares tea
07:31:05 <davidhouse> fair enough.
07:31:16 <twb> davidhouse: Paul Graham's On Lisp features a macro to automatically memoize a normal function.
07:31:32 <mauke> perl features a module to do that :-)
07:31:57 <twb> In fact I'm kinda surprised that optimizing Haskell compilers don't already implicitly memoize as necessary.
07:35:47 <twb> Is there an internal time function like Common Lisp has?
07:36:24 <xerox> ?index getTime
07:36:25 <lambdabot> Graphics.HGL.Window, Graphics.HGL.Core, Graphics.HGL
07:36:39 <xerox> ?hoogle time
07:36:40 <lambdabot> System.Time :: module
07:36:40 <lambdabot> Time :: module
07:36:40 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
07:36:50 <xerox> ?docs System.Time
07:36:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
07:46:55 <robokop> @hoogle TimeLocale
07:46:56 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [(String, String)] -> String, String -> String -> String -> String -> String -> TimeLocale)
07:46:56 <lambdabot> System.Locale.TimeLocale :: data TimeLocale
07:46:56 <lambdabot> Locale.defaultTimeLocale :: TimeLocale
07:55:57 <robokop> i don't think it will speed up my pc if i run a genethicalgorithm and a make besides eachother
07:57:35 <twb> Hmm.
08:03:38 <araujo> morning
08:09:16 <robokop> w00t ghci is slow in comparance to a ghc compiled program
08:09:24 <robokop> 155 secs or 11 secs
08:09:53 <dcoutts> that's because it's an interpreter rather than a compiler
08:10:12 <robokop> i knew there was a difference but so much
08:10:30 <robokop> a factor 10
08:10:34 <robokop> and more
08:10:55 <bolrod> if you do ghc --make
08:11:06 <bolrod> it only compiles the files that need compiling
08:11:18 <bolrod> plus.. it seems to compile rather fast if you make small changes
08:11:50 <twb> Do you know, I can't think of an functional way to generate and solve a maze.
08:12:26 <robokop> bolrod it isn't the compile but the execute of my genetic algorithm (yes it was a verry easy test run)
08:12:49 <bolrod> aha
08:12:53 <bolrod> dont forget the -O2 :)
08:13:00 <robokop> i did that
08:13:08 <bolrod> -O3 is possible
08:13:26 <robokop> is that even better or not
08:13:34 <bolrod> yes
08:13:46 <bolrod> but possibly unstable
08:14:14 <robokop> hmm that unstablle is not nice
08:14:34 <robokop> cause i want it to run for about 48 hours
08:14:49 <bolrod> well.. thats what some configuration screen said when it asked for compile flags for apt-build :)
08:14:54 <bolrod> 48 hours!?
08:15:05 <robokop> yes
08:15:15 <robokop> something wrong with that
08:15:23 <bolrod> isn't it faster to make a good C program?
08:15:24 <bolrod> ;p
08:15:37 <bolrod> hmm... I'll reboot
08:15:39 <bolrod> brb
08:15:42 <robokop> well then i have to learn c in front
08:16:37 <davidhouse> twb, brute force?
08:18:20 <twb> davidhouse: you mean, mutate :: Maze -> Maze ?
08:18:57 <davidhouse> i mean, generate a list of all possible paths through the maze, then see which ones get you to the end
08:19:26 <twb> I was thinking about the generating part, to begin with.
08:19:46 <xerox> twb, maze = backtracking = List Monad.
08:20:10 <xerox> I think you could easily adapt Cale's Sudoku solver.
08:20:57 <xerox> (Which uses a backtracking monad which is a list monad in disguise (faster).)
08:22:39 <neologism> twb: I implemented dijkstra
08:22:45 <neologism> for going through a maze
08:22:50 <neologism> wanna see the code?
08:23:01 <twb> neologism: OK.
08:23:25 <neologism> hysteria.sk/~neologism/Search.hs
08:23:58 <twb> It should be observed that my dirty CLOS version can be generalized to arbitrarily-shaped cells.
08:24:05 <twb> e.g. tetrahedrons.
08:24:43 <xerox> If you travel the maze with something like a Zipper you can generalize the maze in Haskell too.
08:25:07 <twb> Well, I encoded the maze as a set of vectors and a set of arcs.
08:25:15 <xerox> You can make it as general as you want in fact.
08:25:26 <twb> And then create a mapping for the ordered set of vectors to e.g. a grid.
08:25:43 <xerox> Sounds doable?
08:25:47 <twb> I guess you could do that with zip.
08:26:15 * xerox has an impulsive need to code something now.
08:28:31 <twb> neologism: very interesting.
08:28:38 <twb> neologism: thank you.
08:28:56 <neologism> no problem
08:30:06 <twb> Heh, when I did this as my project last year, I delivered it on a bootable linux cd and did the demo from the linux console in emacs/slime :-)
08:30:40 <xerox> Yay!
08:30:59 <bolrod> pff
08:34:29 <twb> Everybody else wasted time doing gl or swing displays :-)
08:34:46 <neologism> twb: same attitude as I have ;)
08:35:10 <twb> neologism: did you write that code just now, or did you have it prepared?
08:35:30 <neologism> what do you mean just now?
08:35:35 <neologism> I wrote it 2 weeks ago or so
08:35:38 <twb> OK.
08:35:53 <twb> I'm used to #emacs where it's like
08:36:02 <twb> "waah, there's no package to do X!"
08:36:21 <xerox> "(...) this will do X."
08:36:25 <twb> Half an hour later: "here's the alpha version"
08:36:43 <twb> FSVO half and hour.
08:53:48 * davidhouse wants to write something
08:54:03 * davidhouse thinks he'll follow up that lambdabot plugin idea he had
08:59:27 <davidhouse> @type \n p a -> take n $ filter p $ repeat a
08:59:28 <lambdabot> forall a.
08:59:28 <lambdabot>               Int -> (a -> Bool) -> a -> [a]
08:59:34 <davidhouse> @hoogle Int -> (a -> Bool) -> a -> [a]
08:59:35 <lambdabot> No matches, try a more general search
08:59:41 <davidhouse> @hoogle (a -> Bool) -> a -> [a]
08:59:42 <lambdabot> No matches, try a more general search
08:59:48 <twb> How do I get the functionality of TRUNCATE in Haskell?
08:59:50 <davidhouse> there's no function to do that?
08:59:52 <twb> http://www.lispworks.com/documentation/HyperSpec/Body/f_floorc.htm
09:00:07 <twb> @type filter
09:00:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:00:16 <twb> @type member
09:00:17 <lambdabot> Not in scope: `member'
09:02:27 <pesco> @type elem
09:02:28 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:02:46 <Saulzar> twb, How about this one?
09:02:48 <Saulzar> @type truncate
09:02:49 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:03:38 <twb> That only returns one value.
09:03:57 <twb> Presumably rem or mod or something is the other half.
09:04:16 <twb> truncate 5 14 ==> (2, 4)
09:04:36 <Saulzar> Ah, I see..
09:04:43 <twb> Er, truncate 14 5 ==> (2, 4)
09:04:49 <Saulzar> > 14 `divMod` 5
09:04:50 <lambdabot> (2,4)
09:05:03 <twb> Saulzar: thank you.
09:05:26 <Saulzar> The other truncate was for things like 7.65433 -> 7.0
09:05:50 <twb> Does divMod round same way as TRUNCATE...
09:05:53 <davidhouse> @type \p l -> length $ filter p l
09:05:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
09:06:03 <davidhouse> @hoogle (a -> Bool) -> [a] -> Int
09:06:03 <lambdabot> No matches, try a more general search
09:06:08 <davidhouse> @hoogle (a -> Bool) -> [a]
09:06:09 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
09:06:09 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
09:06:09 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
09:06:14 <Saulzar> @type divMod
09:06:15 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:06:23 <Saulzar> Hmm
09:06:37 <Saulzar> > 5.0 `divMod` 2.6
09:06:38 <lambdabot> Add a type signature
09:06:42 <Saulzar> > 5.0 `divMod` 2.6 :: Double
09:06:43 <lambdabot> Couldn't match `Double' against `(a, a)'
09:06:49 <Saulzar> > 5.0 `divMod` 2.6 :: (Double, Double)
09:06:49 <lambdabot>  add an instance declaration for (Integral Double)
09:06:49 <lambdabot>   In the expression: 5.0 `divMod` 2.6 :: (Double, Double)
09:06:49 <lambdabot>   In the definition of `fjp': fjp = 5.0 `divMod` 2.6 :: (Double, Double)
09:06:59 <twb> Heh.
09:07:05 <Saulzar> Ah, right. It's only for integral types.. integers, ints
09:09:33 <bolrod> @type div
09:09:34 <lambdabot> forall a. (Integral a) => a -> a -> a
09:09:58 <bolrod> @type (/)
09:09:59 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:17:41 <davidhouse> anyone point me toward some literature on why using hard tabs is A Bad Idea?
09:17:50 <davidhouse> i've heard it criticised, but i don't know why.
09:18:16 <twb> ,tabsareevil
09:18:19 <Igloo> Because they aren't always displayed as aligning to the next multiple of 8 columns
09:18:29 <twb> http://www.emacswiki.org/cgi-bin/wiki.pl?TabsAreEvil
09:18:54 <davidhouse> twb, you're not in #emacs now :)
09:19:29 <RyanT5000> how hard is it to change your tab width when viewing a particular document?
09:19:54 <davidhouse> depends on the editor.
09:19:56 <RyanT5000> i understand spaces for lisp etc.
09:20:12 <RyanT5000> i was assuming emacs, since that's what the article is about :)
09:20:14 <davidhouse> M-x set-variable RET tab-width RET whatever RET is quite simple for emacs
09:20:35 <davidhouse> or even M-: (setq tab-width whatever) RET, to be a bit more concise
09:24:46 <davidhouse> twb, heh, someone put TabsAreEvil in CategoryHumor
09:26:59 <davidhouse> okay then, QuickCheck question coming up.
09:27:40 <davidhouse> i want to write a property for a parser that accepts input in the form of strings
09:28:06 <davidhouse> but these strings can only contain characters from xud*?(), and there are other rules too (like brackets have to be balanced).
09:29:13 <davidhouse> so far i've got a newtype Password = Password String, and my generator is currently genPassword = liftM Password $ sized (\n -> replicateM n $ oneof "xud()*?")
09:29:23 <davidhouse> where can i slot in my isValidPass predicate?
09:36:19 <davidhouse> i could do this at the property level, i suppose
09:37:20 <RyanT5000> ... how do i close a window in House?
09:38:08 <RyanT5000> let me rephrase that
09:38:17 <RyanT5000> how do i do anything in house?
09:42:02 <araujo> ?
09:42:19 <bolrod> what is House?
09:42:25 <RyanT5000> it's an OS written in haskell
09:42:28 <bolrod> ahh
09:42:49 <bolrod> written completely in haskell?
09:42:53 <bolrod> based on anything at all?
09:42:58 <RyanT5000> no idea
09:43:02 <RyanT5000> http://www.cse.ogi.edu/~hallgren/House/
09:43:04 <bolrod> cool
09:43:06 <RyanT5000> i think it's entirely haskell
09:43:09 <bolrod> you got it to start up even ?
09:43:10 <bolrod> :)
09:43:15 <RyanT5000> except i assume they'd need a bit of asm here and there
09:43:23 <RyanT5000> yeah i just now loaded it up in vmware
09:44:41 <bolrod> oh
09:44:47 <bolrod> well.. it doesn't really look stunning
09:44:54 <RyanT5000> lol its not
09:45:05 <RyanT5000> but i was at least expecting to be able to type some haskell into it somewhere
09:45:07 <RyanT5000> and have it like
09:45:09 <RyanT5000> do
09:45:14 <bolrod> :P
09:45:15 <RyanT5000> stuff
09:45:19 <araujo> House is a microkernel based on the ghc runtime
09:45:35 <araujo> last time i tried it, it wasn't possible to close windows and such
09:45:41 <RyanT5000> ah
09:45:44 <bolrod> hmm.. some OS that is.. :)
09:45:53 <araujo> but it worked very smoothly for me
09:45:56 <Muad_Dibber> bolrod: its a concept, not a production OS :)
09:45:59 <RyanT5000> well the window manager obviously sucks, but that doesn't mean the OS sucks
09:46:01 <bolrod> aha
09:46:13 <RyanT5000> but yeah, that too
09:46:13 <bolrod> well
09:46:17 <RyanT5000> i wasn't expecting to like
09:46:20 <RyanT5000> replace windows :P
09:46:21 <bolrod> I see closing an app as basic OS functions ;)
09:46:31 <araujo> mm.. i actually liked the wm very much
09:46:38 <araujo> considering the kind of OS is
09:46:42 <RyanT5000> how do i close the window though?
09:46:49 <RyanT5000> i have 2 of these "Escher" things open now
09:47:07 <RyanT5000> i can't even really figure out what Escher does, but that's beside the point
09:48:28 <bolrod> RyanT5000: linux makes for a good windows replacement ;)
09:48:34 <RyanT5000> true
09:49:10 <Saulzar> You get windows with linux too these days, KDE and Gnome both support windows
09:49:19 <RyanT5000> but for various reasons, including that i'm developing a game for windows and i don't know the first thing about linux development, i'm waiting a while to swithch to windows
09:49:26 <RyanT5000> er
09:49:28 <RyanT5000> *to linux
09:49:44 <Phyx-> hello, i'm having a bit of a problem installing wxHaskel, http://pastebin.com/644376
09:49:52 <bolrod> :)
09:49:55 <bolrod> Phyx-: linux?
09:49:57 <Phyx-> bolrod: :)
09:49:58 <Saulzar> RyanT5000, What kind of game are you making? :)
09:50:00 <Phyx-> nah, windows
09:50:08 <bolrod> then.. I can't help
09:50:10 <bolrod> or. I wont
09:50:11 <Phyx-> heheh
09:50:11 <bolrod> >:)
09:50:14 <bolrod> muwhahhahaa
09:50:14 <RyanT5000> a turn-based strategy game
09:50:16 <Phyx-> hahaha
09:50:23 * Phyx- pokes bolrod 
09:50:27 <bolrod> psh!
09:50:43 <bolrod> tryink to create .deb package now!
09:50:43 <RyanT5000> if you've played VGA Planets, it's very simmilar to that, except hopefully without all the "suck"
09:50:59 <RyanT5000> otherwise, the closest thing i know of is Civilization
09:51:09 <Saulzar> Hmm, I have played similar games.. Stars!
09:51:27 <Phyx-> can anyone help me with that wxHaskell problem? http://pastebin.com/644376
09:51:32 <RyanT5000> oh yeah also Master of Orion is simmilar
09:51:41 <RyanT5000> although i've only played MOO 1
09:52:00 <bolrod> Phyx-: you have the old version?
09:52:06 <Cale> Phyx-: compile with --make ?
09:52:12 <bolrod> its wxhaskell for ghc 6.4.0
09:52:15 <Cale> oh
09:52:16 <bolrod> and you have ghc 6.4.1
09:52:25 <bolrod> ?
09:52:28 <Cale> right, that's a more obvious problem :)
09:52:31 <Phyx-> bolrod: it's the lastest on their site
09:52:32 <ARous1984> So.........i want to print out what a function's returning
09:52:37 <ARous1984> is there any easy way to do that?
09:52:41 <ARous1984> (just for debugging purposeS)
09:52:47 <bolrod> then I dont know!
09:52:49 <Cale> ARous1984: print?
09:52:51 <bolrod> I had it on my mac
09:52:59 <Cale> @type print
09:52:59 <bolrod> and solved it with a newer version
09:53:00 <lambdabot> forall a. (Show a) => a -> IO ()
09:53:08 <bolrod> you could compile the wxhaskell ;)
09:53:14 <Phyx-> bolrod: i'm grabbing it from http://wxhaskell.sourceforge.net/download.html
09:53:30 <ARous1984> Yeah, but I get a type error when I do print
09:53:43 <Cale> ARous1984: or do you want the thing to print when the evaluation actually occurs?
09:53:44 <bolrod> Phyx-: http://www.cs.uu.nl/wiki/FP/Practicum
09:53:46 <ARous1984> and I cant do more than one thing after a guard...at least i dont know how.
09:53:53 <ARous1984> I want to see each step it makes.
09:53:57 <Cale> ARous1984: well, print makes an IO action
09:54:02 <Phyx-> bolrod: that one didn't even run the bat file correctly
09:54:08 <bolrod> oh
09:54:12 <Phyx-> it bombed throwing a fit
09:54:18 <bolrod> boy.. am I glad I'm not using windows
09:54:19 <bolrod> xD
09:54:21 <Phyx-> lol
09:54:22 <Cale> which you'd have to add into some other IO action which eventually becomes part of main somehow
09:54:22 <ARous1984> Yes, so I do force the type for IO?
09:54:23 <Phyx-> :|
09:54:37 <bolrod> fixing things on windows is a pain in the ass
09:54:54 <Cale> but if all you want is a quick trace for debugging purposes, you can use Debug.Trace
09:55:04 <Cale> @type Debug.Trace.trace
09:55:05 <lambdabot> forall a. String -> a -> a
09:55:17 <davidhouse> import Debug.Trace
09:55:17 <ihope> Hum de dum.
09:55:38 <davidhouse> then before any big computations do trace "message" $ do ...
09:55:48 <bolrod> ihope: tru det
09:55:58 <Cale> It causes a message to be printed when evaluation is forced. Don't rely on the messages being printed in any particular order, or any particular number of times though.
09:56:22 <ihope> @type \f -> Control.Monad.Cont.Cont \g -> f (g ())
09:56:23 <lambdabot> parse error on input `\'
09:56:29 <ihope> @type \f -> Control.Monad.Cont.Cont (\g -> f (g ()))
09:56:29 <lambdabot> forall r.
09:56:29 <lambdabot>                  (r -> r) -> Control.Monad.Cont.Cont r ()
09:56:37 <Phyx-> bolrod: running the UU one i get http://pastebin.com/644388
09:56:38 <ihope> Yay!
09:56:42 <vincenz> old cd's....with stuff that I backed upat the time, thinking it was crucial (damn I must have at least 4 different versions of vim lying around)...silly really
09:56:50 <vincenz> now they just form a good set of coasters
09:56:59 <ARous1984> i cant import Debug.Trace :(
09:57:13 <ihope> What's the error message?
09:57:31 <bolrod> :D
09:57:37 <Phyx-> hmm it can't read the path
09:57:38 <Cale> ARous1984: you're using GHC?
09:57:39 <Phyx-> lemme move it down
09:57:43 <bolrod> Phyx-: best throw the computer out of the window
09:57:45 <davidhouse> make sure the import is right at the top of the file.
09:57:53 <davidhouse> just after "module Whatever where"
09:57:55 <ARous1984> Cale: Hugs
09:58:07 <ihope> let import Debug.Trace in ... -- won't work
09:58:11 <Cale> ah, hugs may not have it
09:58:34 <davidhouse> does hugs have an unsafePerformIO?
09:58:38 <Phyx-> bolrod: been thinking that all morning
09:59:13 <ARous1984> Reading file "/lusr/lib/hugs/lib/Prelude.hs":
09:59:13 <ARous1984> Reading file "sudoku.hs":
09:59:13 <ARous1984> Reading file "Debug.Trace":
09:59:13 <ARous1984> ERROR "Debug.Trace" - Unable to open file "Debug.Trace"
09:59:15 <bolrod> or install linux >:/
09:59:19 <ARous1984> thats my error msg
09:59:25 <vincenz> @hoogle trace
09:59:26 <lambdabot> Debug.Trace.trace :: String -> a -> a
09:59:26 <lambdabot> Debug.Trace :: module
09:59:26 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
09:59:32 <bolrod> I dont think I can help with windows...  
09:59:38 <bolrod> I never really use windows anymore
09:59:45 <Phyx-> bolrod: wee worked
09:59:46 <Cale> ARous1984: right, I don't think hugs has that module
09:59:51 <vincenz> ARous1984: oh... might be that hugs does not use the module system?
09:59:51 <bolrod> what worked?
10:00:03 <Phyx-> it couldn't read the path
10:00:06 <Cale> ARous1984: so basically, you just want to write IO actions to test the functions
10:00:07 <davidhouse> ARous1984: use ghc instead. :)
10:00:08 <Phyx-> it has a thing with spaces
10:00:16 <bolrod> yes... sooo?
10:00:22 <Cale> (or use ghc :)
10:00:28 <ARous1984> @$
10:00:28 <lambdabot> Not enough arguments to @.
10:00:32 <bolrod> @type Food -> IO ()
10:00:32 <lambdabot> not an expression: `Food -> IO ()'
10:00:34 <Phyx-> bolrod: copied it to a path without space in it
10:00:35 <bolrod> ;)
10:00:44 <bolrod> ok...
10:00:49 <bolrod> stupid ..
10:00:55 <Phyx-> indeed
10:01:04 <ARous1984> okay, ill use ghc to test :)
10:01:13 <bolrod> see!!!   get rid of windows
10:01:17 <bolrod> its corrupting your mind!
10:01:18 <bolrod> ;)
10:01:32 <Phyx-> bolrod: no, windows paths need "" if they have spaces
10:01:38 <Phyx-> common knowledge :P
10:01:45 <bolrod> wellll yeah
10:01:53 <bolrod> windows is also very stupid
10:01:58 <Phyx-> the person who wrote the batch didn't know that
10:02:18 <Phyx-> nah, people are dump and panic to easily
10:02:22 <Phyx-> <---- person
10:02:30 <ARous1984> k
10:02:31 <bolrod> dump?
10:02:33 <bolrod> k
10:02:33 <ARous1984> i got it to work in ghc :)
10:03:06 <Phyx-> bolrod: how far along are you?
10:03:15 <bolrod> I dont know
10:03:22 <bolrod> I dont really like wxhaskell...  ;)
10:03:26 <bolrod> I like haskell though
10:03:35 <Phyx-> heheh
10:03:38 <bolrod> its so stupid.. I wanted to make a thing where you can select the day from the month
10:03:40 <Phyx-> i'm starting tomorow
10:03:42 <bolrod> so I made a panel
10:03:46 <bolrod> and drew some text on it
10:03:47 <Phyx-> today i work on inp
10:03:56 <bolrod> but on my mac... the same font size is like.. 4 times as small
10:03:57 <bolrod> ;/
10:04:02 <bolrod> which really annoys me
10:04:06 <Phyx-> jsp are so crummy :|
10:04:07 <Phyx-> heheh
10:04:12 <Phyx-> go windows :P
10:04:16 <bolrod> go windows?!
10:04:38 <Phyx-> yep
10:04:44 <Phyx-> and don't say when penguins fly
10:04:45 <bolrod> well... I'm thinking.. maybe I should just make bitmaps of the numbers
10:04:46 <Phyx-> cause they do
10:04:48 <bolrod> and make it paint those
10:04:56 <Phyx-> watch the simpsons and see my proof :)
10:05:02 <bolrod> tux can fly!
10:05:12 <bolrod> you obviously never played tuxracer >:)
10:05:17 <Phyx-> hahhaa
10:05:32 <Phyx-> played a nice game with tux in it though
10:05:36 <Phyx-> you had to shoot him
10:05:38 <Phyx-> :)
10:05:40 <bolrod> >:(
10:05:54 <Phyx-> :D
10:05:58 <bolrod> (x:)3
10:06:04 <bolrod> :)
10:06:06 <Phyx-> wtf?
10:06:14 <bolrod> -,-
10:06:23 <Phyx-> wow, strange nose
10:06:30 <bolrod> its a bunny
10:06:32 <Phyx-> =.=
10:06:37 <Phyx-> that's a bunny
10:06:41 <Phyx-> what bunny has 1 wisker?
10:06:49 <ARous1984> is it pretty easy to write a toString function that takes a list and represents it as a string?
10:07:06 <bolrod> show ?
10:07:06 <Cale> show
10:07:11 <Cale> > show [1,2,3]
10:07:12 <lambdabot> "[1,2,3]"
10:07:21 <Phyx-> lol
10:07:23 <ARous1984> sweet
10:07:27 <bolrod> > concat.map.show $ [1,2,3,4,5]
10:07:27 <lambdabot> Couldn't match `a -> b' against `String'
10:07:31 <Phyx-> heheh
10:07:35 <bolrod> > concat.map show $ [1,2,3,4,5]
10:07:36 <lambdabot> "12345"
10:07:48 <bolrod> =)
10:07:52 <Cale> > concatMap show [1,2,3,4,5]
10:07:53 <lambdabot> "12345"
10:07:59 <bolrod> >:/
10:07:59 <Cale> > [1,2,3,4,5] >>= show
10:07:59 <Phyx-> Cale: was just about to do that
10:08:00 <lambdabot> "12345"
10:08:00 <Phyx-> heheh
10:08:02 <Phyx-> beat me to it
10:08:28 * Phyx- thanx Cale again for showing him >>= the other day
10:08:29 <bolrod> hrmm.. how does that >>= work ;/
10:08:39 <Phyx-> or was it someone else?
10:08:40 <Cale> It's the bind from the list monad
10:08:49 <Cale> x >>= f = concat (map f x)
10:08:53 <Phyx-> @type (>>=)
10:08:54 <lambdabot> forall (m :: * -> *) b a.
10:08:54 <lambdabot>    (Monad m) =>
10:08:54 <lambdabot>    m a -> (a -> m b) -> m b
10:09:00 <bolrod> hrm....
10:09:07 <Cale> In this case, [a] -> (a -> [b]) -> [b]
10:09:07 <Phyx-> bolrod: were you asleep yesterday?
10:09:13 <Phyx-> or did you skip class? :P
10:09:17 <bolrod> no..
10:09:29 <bolrod> but dont get why it uses concat
10:09:30 <bolrod> blah
10:09:34 <bolrod> I'll read up on it later
10:09:49 <Phyx-> bolrod: how's inp?
10:09:51 <Cale> If it was just map f x, then the result type would be [[b]]
10:10:02 <Cale> you need to join the results together somehow
10:10:29 <bolrod> dont ask
10:10:39 <Cale> inp?
10:10:39 <Phyx-> bolrod: :|
10:10:40 <bolrod> aha
10:10:46 <Phyx-> why don't ask?
10:10:49 <bolrod> ;p
10:10:52 <Phyx-> Cale: internet programming
10:10:54 <Phyx-> another class
10:10:55 <Phyx-> hhehe
10:11:05 <bolrod> what did you have for lv ?
10:11:10 <Phyx-> bolrod: almost done with inp?
10:11:14 <Phyx-> lv?
10:11:16 <bolrod> I almost started
10:11:19 <bolrod> logica en verzamelinge
10:11:20 <bolrod> n
10:11:24 <Phyx-> he took the retest, no grades yet
10:11:26 <Phyx-> are there?
10:11:30 <bolrod> yes
10:11:33 <bolrod> there are
10:11:34 <bolrod> :)
10:11:35 <Phyx-> where?
10:11:37 <bolrod> on the news page
10:11:40 <Phyx-> ohh
10:11:44 <Phyx-> must be today
10:11:48 <Phyx-> did you pass?
10:11:51 <bolrod> http://www.cs.uu.nl/education/news/
10:12:01 <bolrod> what about you?
10:12:02 <_Lone_Wolf_> someone has some time to help me?
10:12:03 <bolrod> ;p
10:12:10 <Cale> _Lone_Wolf_: just ask :)
10:12:27 <Phyx-> bolrod: to nervious to look
10:12:27 <_Lone_Wolf_> i have some code here
10:12:33 <_Lone_Wolf_> and i cant put it working
10:12:46 <bolrod> Phyx-: why
10:12:59 <_Lone_Wolf_> http://pastebin.com/644412
10:13:03 <_Lone_Wolf_> can you help me?
10:13:06 <Phyx-> cauze, i prolly failed...
10:13:21 <Cale> ah, hehe, that code again :)
10:13:39 <bolrod> take a look and you will know
10:13:44 <Cale> It's horribly broken, iirc
10:13:52 <_Lone_Wolf_> i know
10:13:52 <Phyx-> bolrod: yep, failed
10:13:54 <Phyx-> 5.0
10:14:09 <bolrod> ;o
10:14:12 <bolrod> =)
10:14:15 <Cale> however, anyone who knows Haskell and monadic parser combinators knows what it's supposed to do
10:14:36 <Phyx-> bolrod: you?
10:14:41 <_Lone_Wolf_> the problem is, i tried to understand haskell
10:14:47 <bolrod> it sais 6.0 >:)
10:14:50 <_Lone_Wolf_> but i just cant
10:14:56 <_Lone_Wolf_> too weird for me
10:14:59 <Phyx-> congrats
10:15:02 <bolrod> thx :)
10:15:07 <Cale> which tutorials have you tried?
10:15:53 <Cale> (also, even if you could run the program, it wouldn't help too much, since it just verifies passwords, it doesn't construct one)
10:17:06 <Cale> @google yet another haskell tutorial
10:17:07 <lambdabot> http://www.isi.edu/~hdaume/htut/
10:17:13 <Cale> I recommend that tutorial
10:19:04 <vincenz> me too
10:19:23 <RyanT5000> yeah i read that 2 days ago as my first thing; it was awesome
10:20:42 <Cale> _Lone_Wolf_: if, after reading YAHT, you still care about understanding that code, you'll want to read about parser combinators -- the Parsec documentation is a good intro
10:20:54 <Cale> @google haskell parsec documentation
10:20:55 <lambdabot> http://www.cs.uu.nl/~daan/parsec.html
10:21:39 <_Lone_Wolf> Cale sry, my net went down
10:21:44 <Cale> ah
10:21:57 <Cale> I'll /msg you with what people've been saying
10:22:03 <_Lone_Wolf> k
10:23:09 <_Lone_Wolf> Cale tks
10:23:21 <RyanT5000> wow; installing visual studio .net 2003 is much quicker when you don't install any languages, frameworks, sdks, or add-ins
10:23:25 <_Lone_Wolf> one more thing wich compiler should I use?
10:23:50 <Cale> _Lone_Wolf: I recommend GHC/GHCi
10:23:54 <Cale> (they come together)
10:24:08 <_Lone_Wolf> ok
10:24:22 <_Lone_Wolf> just please tell me one thing about that
10:24:34 <Cale> GHC is a compiler, GHCi is an interactive environment (interpreter, and also loads compiled code)
10:24:44 <_Lone_Wolf> is the import parselib suposed do be used?
10:25:01 <Cale> oh, yes, you can find that library on the web somewhere
10:25:14 <_Lone_Wolf> ok
10:25:15 <_Lone_Wolf> tks a lot
10:25:38 <Cale> @google ParseLib
10:25:40 <lambdabot> http://www.fi.muni.cz/usr/skarvada/vyuka/IA014/ParseLib.hs
10:26:16 <Cale> the parsec documentation would be more helpful, I bet
10:26:56 <_Lone_Wolf> what is parsec exactly?
10:27:05 <Cale> A library of parser combinators
10:27:38 <Cale> There are basic parsers like char, which parses a particular character, and functions which combine parsers in various ways to parse bigger languages
10:29:03 <Cale> Such as the <|> (read as 'or') operator, which takes two parsers, and produces the parser which parses either one.
10:30:02 <bolrod> /win 15
10:30:04 <bolrod> oops -,-
10:30:47 <RyanT5000> a question about serialization: is the best way to serialize arbitrary datastructures to use TH, or is there some kind of trick you can use to do it without that?
10:30:49 <davidhouse> _Lone_Wolf_: so, for example, char 'x' <|> char 'y' produces a parser that parses either one 'x' character or one 'y' character.
10:31:18 <RyanT5000> the obvious constraint here being that i don't want to write pickle and unpickle functions for each type (or worse, each constructor of each type)
10:32:32 <Cale> RyanT5000: TH works okay. In lots of cases, you can just derive Show and Read
10:32:43 <RyanT5000> well i want a binary dataformat that supports cycles
10:33:30 <xerox> Howdy Cale.
10:33:35 <RyanT5000> i've looked at SerTH,  which is a TH lib that automatically generates instances of Serializable for your datatypes
10:33:39 <Cale> howdy xerox 
10:33:47 <Cale> RyanT5000: cycles?
10:33:57 <Cale> Can you even detect cycles?
10:34:23 <RyanT5000> hm you raise a good point
10:34:29 <RyanT5000> i haven't yet ported my datastructure
10:34:32 <RyanT5000> it's currently in C#
10:34:54 <ARous1984> i have a function that is removing the empty list from a list of lists.
10:35:01 <vincenz> @babel towel gourd en nl
10:35:01 <lambdabot> babel module failed: Error: Language towel not supported
10:35:03 <ARous1984> but i want that empty list to stay
10:35:07 <vincenz> @babel en nl towel gourd
10:35:09 <lambdabot>  handdoek pompoen
10:35:13 <Cale> If you do a direct translation, you might end up in ST with STRefs
10:35:34 <Cale> ARous1984: hm?
10:35:51 <RyanT5000> well i'm not sure i even like my old datastructure, lol
10:35:54 <RyanT5000> actually
10:36:16 <RyanT5000> is there a good way of representing relational databases in haskell?
10:36:23 <RyanT5000> i mean, without using a real RDBMS
10:37:26 <_Lone_Wolf> i hate this :/
10:37:38 <_Lone_Wolf> simply i cant get this
10:37:58 <Cale> _Lone_Wolf: how long have you been working on it?
10:38:06 <_Lone_Wolf> let me see
10:38:24 <_Lone_Wolf> more than 3 weeks
10:38:30 <_Lone_Wolf> then i got tired
10:38:40 <_Lone_Wolf> and a few months later i returned
10:38:45 <_Lone_Wolf> yesterday
10:38:50 <neologism> skarvada made some parsing combinators?
10:38:51 <neologism> nice :)
10:39:26 <davidhouse> _Lone_Wolf: do you know haskell?
10:39:32 <_Lone_Wolf> if i could understand what the code does it would be enough, so i would write a program in another language
10:40:04 <RyanT5000> do you have the grammar of the language you're trying to parse?
10:40:19 <_Lone_Wolf> most languages i can look at the code and say what it does, but this
10:40:35 <astrolabe> Is it haskell?
10:40:45 <Cale> It's mutilated Haskell
10:40:58 <Cale> It's intentionally obfuscated to some extent
10:41:13 <_Lone_Wolf> its something that i was suposed to get alone
10:41:36 <xerox> What are you all looking at, if I may ask?
10:41:46 <Cale> This is for some web game. Mod-X, I think
10:41:56 <_Lone_Wolf> yup its for mod-x
10:41:58 <Cale> We get people in here asking about that code all the time
10:42:03 <_Lone_Wolf> lol
10:42:20 <Cale> xerox: http://pastebin.com/644412
10:42:30 <_Lone_Wolf> they think the same as me
10:42:42 <_Lone_Wolf> (btw sry for some possible english errors)
10:42:45 <xerox> Dankel.
10:42:47 <Cale> xerox: the goal is to construct a password that this program would accept, if it ran at all.
10:42:55 <_Lone_Wolf> if
10:43:07 <_Lone_Wolf> there is allways a if
10:43:10 <neologism> _Lone_Wolf: I had some pdfs which describes this parser
10:43:12 <neologism> but its in czech :(
10:43:18 <Cale> I did this problem once in about 2 minutes :)
10:43:18 <_Lone_Wolf> :(
10:43:30 <RyanT5000> has anyone else used Visual Haskell?
10:43:38 <astrolabe> I hate trying to understand other peoples code.  Especially with no comments and crappy variable names.
10:43:41 <xerox> How was it called the standard way to do variadic functions in C.
10:43:48 <resiak> varargs?
10:43:51 <xerox> I knew the name of the lib... damn.
10:43:52 <Cale> If you've ever written a parser with one of these libraries for, you can basically read off the solution from the code.
10:43:53 <RyanT5000> yeah
10:43:57 <RyanT5000> varargs
10:44:12 <Cale> libraries before*
10:44:18 <xerox> Hmm_|, are you sure?
10:44:24 <resiak> Could be wrong.
10:44:39 <RyanT5000> it was platform-specific
10:44:40 <astrolabe> _Lone_Wolf: Have you looked at the parsec documentation?
10:44:54 <RyanT5000> but on unix i think it was a function _va_args() or something
10:45:33 <_Lone_Wolf> yup
10:45:36 <xerox> Yeah, those.  Thanks.
10:45:47 <Cale> The solution is highly non-unique
10:46:00 <Cale> In fact, there are infinitely many solutions :)
10:46:18 <RyanT5000> as with any programming problem :P
10:46:33 <Cale> RyanT5000: well, they could have made it unique
10:46:39 <xerox> I wonder if one could exploit something in order to get the result out of the parser somehow.
10:46:48 <neologism> _Lone_Wolf: there are examples if that helps
10:47:00 <astrolabe> _Lone_Wolf: So do you understand code3 for example?
10:47:13 <ihope> Whoa!
10:47:23 <_Lone_Wolf> no
10:47:33 <ihope> data [a] = [] | a : [a]
10:47:53 <astrolabe> _Lone_Wolf: What is the first line in code3 that you don't follow?
10:47:54 <Saulzar> If you're a newbie then that's not a good start to look at that code. Start with one of the tutorials, just forget that code until you have...
10:48:00 <ihope> <[a]> ::= [] | <a> : <[a]>
10:48:16 <_Lone_Wolf> astrolabe the do char thing
10:48:19 <pejo> Ryan, stdarg.h is C99 though, isn't it?
10:48:20 <_Lone_Wolf> (the begining)
10:48:34 <RyanT5000> sorry pejo, i don't know
10:48:35 * resiak looks at  return 'Suc'
10:48:47 <xerox> ihope, what are you .. ?!
10:49:06 <ihope> A person who changes his mind about leaving a channel...
10:49:34 <astrolabe> char '!'  trys to read an '!'.  it fails unless the next character is a '!', in which case it returns '!'
10:49:57 <ihope> ...and who changes his mind about re-joining it...
10:52:09 <_Lone_Wolf> astrolabe trys to read from where?
10:52:51 <astrolabe> when code3 is used, a string is supplied to it.
10:53:10 <RyanT5000> does read do any lookahead?
10:54:15 <astrolabe> @hoogle papply
10:54:16 <lambdabot> No matches found
10:54:19 <Saulzar> _Lone_Wolf, It's building a parser using an elegant parser library in a bastardised way
10:54:39 <_Lone_Wolf> bastardised ?
10:55:08 <Saulzar> bad, ugly, not proper
10:55:18 <_Lone_Wolf> ah
10:57:31 <astrolabe> where does 'papply' come from
10:57:53 <_Lone_Wolf> have no idea
10:58:02 <Cale> @google ParseLib
10:58:03 <lambdabot> http://www.fi.muni.cz/usr/skarvada/vyuka/IA014/ParseLib.hs
10:58:07 <Cale> from there
10:58:32 <Cale> It just applies the parser to a string
10:58:51 <astrolabe> _Lone_Wolf: I'm afraid haskell is quite different from most languages.  You can't expect to understand it properly without studying a tutorial.
10:58:54 <astrolabe> Cale: thanks.
10:59:04 <_Lone_Wolf> very different
10:59:16 <_Lone_Wolf> thats why im stuck
11:00:26 <_Lone_Wolf> i have read some tuts, but i cant apply anything to this code
11:00:33 <astrolabe> You need to read a general tutorial, then a tutorial about monads, and then the parsec documentation IMO>
11:01:14 <_Lone_Wolf> no more haskell for mr
11:01:22 <_Lone_Wolf> I give up
11:01:28 <_Lone_Wolf> thank you for the help
11:01:41 <_Lone_Wolf> *for me
11:01:43 <astrolabe> You're welcome.
11:02:13 <jyp> @quote
11:02:13 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
11:04:56 <RyanT5000> what is the best language to teach to people with 0 programming knowledge?
11:05:12 <Lemmih> Haskell!
11:05:13 <Lemmih> (:
11:05:27 <RyanT5000> for real?
11:05:27 <|metaper|> www.teach-scheme.org
11:05:28 <RyanT5000> that is of course
11:05:28 <wchogg> Hrmm...do you mean in terms of practical use or in terms of learning programming ideas?
11:05:30 <RyanT5000> why i asked
11:06:05 <RyanT5000> hm
11:06:12 <RyanT5000> not in terms of "to get a job"
11:06:12 <Lemmih> Yeah, I really think Haskell would be a good first programming language.
11:06:20 <RyanT5000> in terms of learning concepts
11:06:30 <davidhouse> there are lots of different concepts.
11:06:34 <metaperl_work> RyanT5000: age of student?
11:06:35 * dcoutts teaches Haskell as a first programming language for a university
11:06:40 <RyanT5000> college-age
11:06:40 <davidhouse> the concepts you learn in haskell are completely different to those of C.
11:06:43 <dcoutts> for/at
11:06:44 <metaperl_work> RyanT5000: how about logo?
11:06:54 <astrolabe> dcoutts: many dropouts?
11:07:02 <dcoutts> astrolabe, not many
11:07:08 <resiak> I'm glad that I knew other languages before learning Haskell at that university, because I appreciate how good it is.
11:07:32 <resiak> dcoutts: You fail to mention that it's compulsory for all undergrads
11:07:35 <RyanT5000> btw i don't have like a real person i'm referring to here
11:07:39 <davidhouse> what kind of combinator would i use for lookaheads in parsec? i.e. i'll say parse and consume X if it's followed by Y (which isn't consumed)
11:07:42 <RyanT5000> i'm just interested in the general discussion
11:07:43 <dcoutts> resiak, that's true
11:08:04 <dcoutts> astrolabe, probably fewer than other UK universities, but then you'd expect that with (ox|cam).ac.uk
11:08:17 <RyanT5000> lots of universities are switching to java
11:08:24 <RyanT5000> which i find abhorrent, tbh
11:08:33 <dcoutts> We do Java too in the second year
11:08:48 <davidhouse> dcoutts, it's one of the oxbridge unis that have the lowest dropout rate in the country, i believe
11:09:00 <dcoutts> yeah, probably
11:10:26 <davidhouse> is that even possible with an LL1 grammar?
11:10:47 <davidhouse> (refering to my parsec question as opposed to the universities discussion)
11:11:04 <dcoutts> parsec can do arbitrary lookahead
11:11:06 <RyanT5000> is it necessary for students to learn about pointers nowadays?
11:11:13 <davidhouse> RyanT5000: yes
11:11:18 <astrolabe> I think so too.
11:11:27 <RyanT5000> good; me too
11:11:38 <RyanT5000> that's what pisses me off about java :P
11:11:51 <dcoutts> I don't think we teach about pointers much, not in the C sense, just the restricted Pascal/Java sense
11:11:53 <astrolabe> Although if you just see education as being job oriented, maybe not.  But I don't.
11:12:20 <resiak> They're taught in procedural programming, using Oberon
11:12:30 <dcoutts> yes, linked lists etc
11:12:49 <astrolabe> Oberon the king of the faries?
11:12:50 <resiak> and linked lists are touched upon in OOP, but only with Java's references
11:12:52 <dcoutts> but we don't munge the concepts of pointers and arrays in the way C does
11:13:02 <dcoutts> astrolabe, that's right :-)
11:13:24 <xerox> Low-level programming being unavoidable?  Hmmm.
11:13:36 <RyanT5000> lol it should be 8 weeks of Haskell followed by 8 weeks of assembler
11:13:41 <ARous1984> im at a loss for why my program is repeating itself over and over with the same solution
11:13:57 <RyanT5000> the final project should be writing a program that uses both :)
11:14:02 <xerox> Hey dcoutts!
11:14:06 <dcoutts> hia xerox 
11:14:08 <RyanT5000> *without* ffi
11:14:12 <RyanT5000> you have to write a haskell binding for asm :P
11:14:18 <ARous1984> would anyone want to look at my source and give me advice on the problem areas...im pretty much blind by now :P
11:14:23 <xerox> dcoutts, I've installed GHC here.  It's running under Rosetta, but it runs great anyway.
11:14:33 <dcoutts> xerox, oh ok, good
11:15:05 <dcoutts> RyanT5000, if I had my way then we'd teach Haskell and C, high and low level.
11:15:09 <astrolabe> ARous1984: paste it up and see if anyone looks.
11:15:18 <dcoutts> Haskell & C is a good combo I think.
11:15:19 <RyanT5000> yeah that seems reasonable dcoutts
11:15:25 <ARous1984> its a lot
11:15:26 <ARous1984> :P
11:15:46 <astrolabe> Then it is less likely that anyone will.
11:16:06 <RyanT5000> the CS dept at my school is redesiging the 1st and 2nd semester curriculum
11:16:27 <RyanT5000> i'll suggest they look at haskell
11:16:30 <RyanT5000> they're looking at scheme
11:16:36 <RyanT5000> :(
11:16:56 <xerox> RyanT5000, cool.  Scheme is a great language to learn too.
11:17:15 <xerox> Have you ever seen the Sussman Video Lectures?
11:17:17 <integral> scheme isn't java, c++ or Pascal :-)
11:17:33 <RyanT5000> that's true, integral
11:17:35 <xerox> ...or, *cough*, Visual Basic.
11:17:44 <RyanT5000> i dunno though
11:17:54 <RyanT5000> my prog lang course was taught almost entirely in scheme
11:17:57 <RyanT5000> i hated it so much
11:17:59 <integral> xerox: don't they have cool toys like LINQ now though?
11:18:00 <ARous1984> http://www.cs.utexas.edu/users/arousset/sudoku.hs
11:18:02 <xerox> @google MIT Sussman SICP Video Lectures
11:18:03 <ARous1984> so thats my sudoku source
11:18:04 <lambdabot> http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/
11:18:17 <ARous1984> anyone care to take a look and point me in some direction? :)
11:18:38 <ARous1984> the problem is that it repeats a solution over and over when it guesses.
11:19:16 <xerox> integral, that is something worth a look, I agree.  But do you remember that VB 6.0 and its successor aren't compatible at any level? Result: VB 6.0 still being... aww.
11:19:32 <integral> that's a point.
11:19:52 <integral> *sigh* if one perl6 would finally ship
11:19:56 <davidhouse> is there a parsec combinator for "parse nothing"?
11:20:02 <xerox> *sigh* *nods*
11:20:10 <xerox> davidhouse, return ().
11:20:50 <xerox> ?pl (>> return ())
11:20:50 <davidhouse> but that won't work because my parser is of type CharParser st a, not CharParser st ().
11:20:50 <lambdabot> (>> return)
11:21:05 <integral> return undefined
11:21:08 <xerox> mute = (>> return ())
11:21:35 <mauke> whatever = return (); ignore = (>> whatever)
11:21:54 <xerox> integral, I recently realized that I started to use undefined everywhere... where things aren't defined.
11:22:12 <xerox> mauke, care to add to AlmostCode? :-)
11:22:24 * integral tends to use error for things like: error "not written yet"
11:22:39 <mauke> what's that?
11:22:40 <xerox> It looks so good.
11:22:44 <astrolabe> davidhouse () is a 'a'.
11:22:45 <xerox> ?wiki AlmostCode
11:22:45 <lambdabot> http://www.haskell.org/haskellwiki/AlmostCode
11:22:51 <xerox> ?type ()
11:22:52 <lambdabot> ()
11:22:57 <davidhouse> astrolabe: sure?
11:23:07 <xerox> davidhouse, yes, it's *a* 'a'.
11:23:11 <xerox> Hmm.
11:23:12 <mauke> (There is currently no text in this page)
11:23:15 <xerox> ?oldwiki AlmostCode
11:23:15 <lambdabot> http://www.haskell.org/hawiki/AlmostCode
11:23:40 <davidhouse> > f :: Int; let f = () in 4
11:23:41 <lambdabot>  parse error on input `}'
11:24:09 <xerox> davidhouse, it's *a* 'a' doesn't mean that it is the right one for *all* the situation, but for, possibly, *a* situation :-)
11:24:18 <davidhouse> > let f :: Int; f = () in f
11:24:19 <lambdabot> Couldn't match `Int' against `()'
11:24:28 <davidhouse> () is not an Int
11:24:32 <mauke> > fmap abs (* 2) (-3)
11:24:33 <lambdabot> 6
11:24:40 <mauke> huhu
11:24:53 <integral> @type (const 5, const 5 ())
11:24:54 <lambdabot> forall b a a1.
11:24:54 <lambdabot>          (Num a, Num a1) =>
11:24:54 <lambdabot>          (b -> a, a1)
11:25:01 <xerox> davidhouse, indeed.  Int is *a* 'a' too :-)
11:25:10 * xerox looks at mauke 
11:25:18 <davidhouse> ah, i see the confusion;
11:25:22 <integral> bleh, silly bot doesn't default.
11:25:30 <davidhouse> my parser isn't actually polymorphic.
11:25:47 <astrolabe> what type does it return?
11:25:47 <xerox> davidhouse, great.  Just return something appropriate then.
11:25:50 <davidhouse> it's a CharParser Patite Pattern, if you're interested.
11:26:00 <integral> davidhouse: and what do you do with it's return value?
11:26:15 <davidhouse> and Patite doesn't really have an identity
11:26:41 <xerox> mauke, aha, Reader in disguise again.
11:26:44 <davidhouse> i think i've solved it another way anyway.
11:27:01 <mauke> yep, (.) == liftM == fmap
11:27:15 <xerox> Right.
11:27:30 <xerox> Fool fool fool, fool the Haskeller!
11:29:13 <xerox> I wonder what does lambdabot has that GHCi hasn't.  I.e. where does it get ((->) a) instances from?
11:29:39 <Lemmih> Control.Monad.Reader, iirc.
11:30:07 <xerox> That's right Lemmih!  Onegaishimasu.
11:35:59 <LoganH> shawn: I've been mostly involved with Python for the past three years.
11:36:05 <LoganH> Oops, wrong sha prefix!
11:36:11 <LoganH> shapr: I've been mostly involved with Python for the past three years.
11:36:26 <kep> re all
11:45:23 <jyp> @quote
11:45:23 <lambdabot> skew says: I think blackdog is right
11:59:52 <chrisbrown> would any one be able to help me with using the GHC API?
11:59:57 <chrisbrown> or even with this ghc error?
12:01:04 <davidhouse> > return "Ask" :: Maybe String
12:01:05 <lambdabot> Just "Ask"
12:01:18 <chrisbrown> oh sorry - yeah that would help!
12:01:19 * xerox laughs
12:01:29 <chrisbrown> the error is Could not find module `SrcLoc':
12:01:29 <chrisbrown>     it is not a module in the current program, or in any known package.
12:01:29 <chrisbrown> Cannot continue after interface file error
12:01:36 <xerox> grep?
12:01:39 <chrisbrown> however if I compile the module on its own it complies
12:02:10 <chrisbrown> tried grepping for it
12:02:19 <chrisbrown> it doesn't seem to exist
12:02:38 <chrisbrown> which is odd - because the module complies on its own - but as soon as I import it in HaRe it gives me that error
12:03:23 <Lethalman> hello
12:04:13 <Lethalman> can someone explain me how to use asyncronous sockets? a sort of C select() function...
12:04:15 <davidhouse> chrisbrown: it's not in your search path then
12:04:46 <chrisbrown> is there anyway to get GHC to tell me where its looking?
12:04:52 <Lethalman> i tried to search on google and i found the Select module, but i can't find it as module neither in GHC nor in hoogle
12:04:56 <xerox> I know for sure someone did Socket work here...
12:05:13 <xerox> But Concurrency beats me atm.
12:05:30 <dcoutts> Lethalman, you just want to do non blocking read & writes on sockets?
12:05:33 <davidhouse> chrisbrown: http://haskell.org/ghc/docs/6.4.1/html/users_guide/separate-compilation.html#search-path
12:05:59 <sjanssen> don't most people just use threads for asynchronous stuff?
12:06:05 <Lethalman> dcoutts: yes something like that, also on generic handles if possibble
12:06:11 <dcoutts> Lethalman, the right thing to do is to use lightweight ghc threads
12:06:15 <Lethalman> sjanssen: async != thread
12:06:35 <Lethalman> dcoutts: why only threads?
12:06:39 <dcoutts> ghc does all the IO multiplexing for you
12:06:52 <chrisbrown> cheers
12:06:54 <Lethalman> ok but how on sockets?
12:06:58 <xerox> Seeya chris.
12:07:02 <chrisbrown> is there a way I can use grep to find a filename?
12:07:15 <Lethalman> i need to accept sockets and at the same time read from them
12:07:16 <xerox> Ops.
12:07:22 <sjanssen> chrisbown: find | grep
12:07:41 <chrisbrown> find | grep "SrcLoc*" ?
12:07:42 <sjanssen> also find -name can do wildcards an such
12:07:54 <dcoutts> Lethalman, use the Network module to open a socket and get a Handle, then you can do ordinary IO with that handle
12:08:01 <xerox> chrisbrown, find . -type f | grep ..
12:08:14 <sjanssen> I would do find -name 'SrcLoc*'
12:08:20 <davidhouse> is there a parsec primitive for the end of the input?
12:08:23 <Lethalman> dcoutts: isn't socket accept blocking?
12:08:24 <chrisbrown> i need it to be recursive
12:08:39 <xerox> BBL.
12:08:40 <Lethalman> ops.......... read i mea
12:08:53 <chrisbrown> oh found it 
12:08:57 <chrisbrown> its a .hi file
12:09:04 <chrisbrown> put that directory in my search path?
12:09:14 <xerox> -l ?
12:09:21 <davidhouse> -i.
12:09:29 <xerox> -laters :-)
12:09:31 <Lemmih> chrisbrown: It should be at ghc/compiler/basicTypes/SrcLoc.lhs
12:09:47 <Lemmih> chrisbrown: Are you at stage1 or stage2?
12:10:16 <chrisbrown> Lemmih: not sure - I have a working version of ghc 6.5 which I am using
12:10:31 <chrisbrown> ghc/hslibs-imports/ghc/SrcLoc.hi
12:10:43 <Lemmih> Great, then you don't need SrcLoc. ghci -package ghc should do.
12:10:48 <Lethalman> dcoutts: maybe i found a solution, the data BufferMode for handles
12:10:55 <Lemmih> (ghci-6.5, that is)
12:11:36 <chrisbrown> Lemmih: I am compiling with -package ghc. can i just add -v to ghc to let it tell me what it is doing?
12:12:23 <Lemmih> chrisbrown: What are you compiling?
12:12:31 <chrisbrown> Lemmih: HaRe
12:12:45 <chrisbrown> but in one file I am using the GHC API
12:13:28 <Lemmih> chrisbrown: Can you access SrcLoc from ghci?
12:13:44 <chrisbrown> I dont have ghci with 6.5 - i disabled it in the build
12:13:59 <chrisbrown> or actually perhaps i do
12:14:08 <RyanT5000> did they move GLUT in GHC 6.5?
12:14:20 <Lemmih> chrisbrown: Oh. Perhaps you should try compiling something simpler.
12:14:45 <chrisbrown> Lemmih: It compiles with no problems in a simple test case
12:14:58 <chrisbrown> I have done lots of experimentation with it
12:15:09 <chrisbrown> perhaps there is something in the HaRe makefile stopping it
12:15:26 <Lemmih> chrisbrown: Can you compile a file that imports SrcLoc?
12:15:30 <chrisbrown> yes
12:17:44 <Lemmih> Yeah, then it's probably the HaRe makefile.
12:18:01 <chrisbrown> ok cheers
12:18:27 <chrisbrown> is there anywhere if I compile it seperatley to just link it in with HaRe?
12:18:31 <chrisbrown> *anyway
12:18:43 <RyanT5000> i have GHC 6.4.1, with GLUT, and i have GHC 6.5 without GLUT
12:18:54 <RyanT5000> how can i get GLUT to work with 6.5 too?
12:19:01 <chrisbrown> what is GLUT?
12:19:06 <RyanT5000> Graphics.UI.GLUT
12:19:10 <chrisbrown> ah
12:19:31 <RyanT5000> it's an os abstraction layer for some input and OpenGL output
12:19:46 <RyanT5000> but i can't find a package or anything
12:19:52 <chrisbrown> should work with 6.5....are you getting errors?
12:19:58 <RyanT5000> it can't find it
12:20:14 <RyanT5000> in ghci 6.4.1 i type ":m +Graphics.UI.GLUT" and it works
12:20:17 <RyanT5000> doesn't work in 6.5
12:20:40 <davidhouse> @hoogle undefined
12:20:41 <lambdabot> Prelude.undefined :: a
12:20:41 <lambdabot> Control.Exception.UndefinedElement :: String -> ArrayException
12:20:57 <davidhouse> is there a function for determining whether something is undefined?
12:21:29 <davidhouse> @hoogle isUndefined
12:21:30 <lambdabot> No matches found
12:21:48 <RyanT5000> chrisbrown: is there some place where i can download the GHC libraries alone?
12:22:51 <chrisbrown> RyanT5000: I'm not sure. I think the openGL comes with 6.5 - perhaps they reside in a different place?
12:23:15 <RyanT5000> can i get GHC to output a tree of all its packages?
12:23:22 <ARous1984> is there a list of functions for the Debug module?
12:23:38 <chrisbrown> Lemmih: I now get  conflict: module `SrcLoc' belongs to the current program/library
12:23:38 <chrisbrown>     and also to package ghc-6.5.20060117
12:23:52 <chrisbrown> is there anyway to tell ghc to ignore the conflict?
12:27:00 <chrisbrown> actually I will just rename the SrcLoc module in programatica
12:34:26 <davidhouse> in parsec, do state modifications happen if the parser fails?
12:34:52 <davidhouse> for example if i have char 'x' >> setState Foo >> someParserThatFails, will the state get updated?
12:35:10 <Cale> oh, in that case, yes
12:35:17 <RyanT5000> ok
12:35:17 <Cale> I'm not sure how it interacts with try
12:35:18 <RyanT5000> so
12:35:27 <RyanT5000> what parts of the /ghc tree are the libraries?
12:35:55 <RyanT5000> i have a ghc 6.4.1 install and a ghc 6.5 install (for visual haskell)
12:36:22 <davidhouse> Cale, thanks
12:36:38 <RyanT5000> and i'd really like to transplant the libraries from 6.4.1 to 6.5
12:36:41 <RyanT5000> is that even possible?
12:37:52 <qtmstr> I'm not trolling. I want to know why those in academia seem to be very attracted to functional languages, especially the side-effect-free varieties, while the general community isn't.
12:38:18 <RyanT5000> that's interesting to me too
12:38:29 <RyanT5000> i find that side effects are a huge source of bugs
12:38:33 <Philippa> the general community can barely understand how anything useful can be done in such a radically different and seemingly restrictive environment
12:38:45 <Philippa> the academic side find all sorts of academically interesting things are easier to do
12:38:57 <qtmstr> I'm a college student, and I'm having a hard time wrapping my head around functional langauges; I just finished a project in Erlang.
12:39:00 <davidhouse> and more elegant./
12:39:09 <araujo> qtmstr, many reasons, one is that functional programms offer true mathematical properties.
12:39:15 <qtmstr> Programming useful things seems much more _natural_ in imperative languages.
12:39:28 <qtmstr> araujo: What do you mean?
12:39:34 <RyanT5000> imperative langauges are more obvious
12:39:43 <dcoutts> qtmstr, that's because it's the way you've been trained to think
12:39:56 <araujo> that's because imperative languages are closer to our current machine model, which is kind of a pity.
12:40:11 <Philippa> that, and because it's easy to see how there can be a "do the task I just explained to you" command than function
12:40:20 <qtmstr> araujo: Is it even possible to build a machine that natively functional?
12:40:20 <araujo> and yes, what dcoutts said too
12:40:38 <Philippa> qtmstr: yes
12:40:48 <RyanT5000> how would that work?
12:40:54 <qtmstr> err, that is
12:40:57 <Philippa> it's pretty easy to build a stack+environment machine that evaluates some variant of the lambda calculus
12:41:04 <Philippa> or you could build a pure variant of the lisp machine
12:41:11 <araujo> qtmstr, it is, just that there isn't too much eefor put into that nowadays saddly.
12:41:28 <araujo> effort*
12:41:28 <RyanT5000> do you know if pipelining and stuff would work out well?
12:41:49 <RyanT5000> also, what about resource allocation
12:42:04 <RyanT5000> you'd need to have a really complex and programmable GC engine built into the chip
12:42:20 <Philippa> no, you'd just need a collector, any collector
12:42:20 <araujo> qtmstr, nevertheless, purely FP can perfectly do whatever other imperative programms do, even in better ways.
12:42:37 <RyanT5000> i'm not sure how you'd do DMA, in particular
12:42:45 <Cale> qtmstr: the main reason that functional languages aren't more mainstream is the huge amount of inertia in language usage. It took what, 20, 30 years for OO to become mainstream?
12:43:02 <qtmstr> araujo: Oh, I know. Mathematically, they're all the same.
12:43:09 <Philippa> and OO was for a while impure FP's odd little brother
12:43:11 <RyanT5000> also i think functional languages have a higher barrier to entry
12:43:19 <araujo> qtmstr, about what i meant with the mathematical thing, well, for example, we deal with real functions here in the mathematical sense, so that helps you to reason about programms in a more mathematical way than an imperative one.
12:43:21 <qtmstr> Would it be possible to create a more "natural" functional languages, that, say, allowed the programmer to express natural loops?
12:43:25 <dcoutts> imperative languages are increaingly not the best way to program modern hardware
12:43:26 <RyanT5000> monads are harder to master than x = 5; x = 3
12:43:27 <Cale> I don't think they have a higher barrier to entry
12:43:31 <araujo> qtmstr, what are they the same?
12:43:32 <Philippa> what "natural" loops?
12:43:40 <Philippa> really, the for loop is horseshit most of the time
12:43:41 <dcoutts> loops == recursion
12:44:01 <Philippa> exactly. "Do the same thing again", BFD
12:44:07 <Cale> higher order functions are more natural than loops
12:44:09 <dcoutts> and it's usually some kind of structural induction
12:44:17 <RyanT5000> hm
12:44:27 <qtmstr> Philippa: Well, say I want to apply an operation to every pixel in an image; to me, the natural way to express that would be two loops, one nested inside the other; expressing it recursively isn't particularly hard, but it's more typing, and it's less clear, immediately, what's going on.
12:44:31 <Cale> Do you really number your dishes and increment a counter rather than just washing them all?
12:44:34 <RyanT5000> i have a hard time believing that it's purely inertia that's causing this problem
12:44:41 <Cale> map wash dishes
12:44:49 <araujo> qtmstr, that's not really natural
12:44:50 <Philippa> qtmstr: no, the natural way to do it is "map func pixels" or something analogous
12:44:54 <Philippa> you're adding detail
12:45:05 <araujo> qtmstr, that's just the way you are used to
12:45:06 <Cale> vs  for (i = 0; i < n; i++) { wash(dish[i]) }
12:45:07 <qtmstr> Cale: for(dish in dishes) wash(dish);
12:45:23 <Philippa> qtmstr: see what I just wrote
12:45:24 <dcoutts> qtmstr, you're over-serialising the comutation by using a loop
12:45:32 <dcoutts> comutation/computation
12:45:37 <qtmstr> Philippa: Hrm. Good point.
12:45:47 <RyanT5000> right: qtmstr: consider if you have one processor per pixel
12:45:58 <RyanT5000> if you have a for loop
12:46:03 <dcoutts> eg using a loop make it harder to make it clear that the operation parallelises perfectly
12:46:05 <RyanT5000> you're wasting N-1 cpus
12:46:32 <dcoutts> and the for loop doesn't take advantage of cacheing/tiling
12:46:35 <qtmstr> Do any functional interpreters actually _do_ that kind of parallelization, though? Is it algorithmically possible to do it automatically, correctly, in all cases?
12:46:40 <Cale> Not thinking about order of computation when it doesn't matter is quite natural. Imperative languages force you to think about it, so you get used to having to do so, and reverting to leaving it implicit becomes awkward.
12:46:57 <Philippa> qtmstr: it's a piece of piss to substitute in a parallelising map or similar
12:47:02 <RyanT5000> right
12:47:04 <Philippa> you don't /need/ all cases to be practically useful
12:47:21 <qtmstr> Cale: That's a very good point. I didn't think about that.
12:47:23 <RyanT5000> look up mapReduce
12:47:52 <RyanT5000> google uses it as their primary distributed computing mechanism
12:48:10 <RyanT5000> @google mapReduce
12:48:12 <lambdabot> http://labs.google.com/papers/mapreduce.html
12:48:49 * qtmstr reads
12:48:50 <tic> It's a great paper.
12:48:53 <tic> very inspiring.
12:49:02 <RyanT5000> yeah - although you'll notice that it's all C++
12:49:11 <tic> It gets the point across though.
12:49:15 <RyanT5000> yep
12:49:52 <Philippa> if you want a more demonstrable optimisation that's actually implemented, deforestation comes to mind
12:50:06 <Philippa> you couldn't do that in a language that didn't have some way of marking out pure operations
12:50:49 <xerox> What is deforestation?
12:50:50 <RyanT5000> the advantage of not having mutable variables is that if a change happens, it's becuase you accepted the return value of a function that made that change
12:50:59 <RyanT5000> nothing can happen behind your back
12:51:07 <Philippa> xerox: eliminating intermediate structures in big list computations
12:51:18 <RyanT5000> i consider setf etc. to be anti-features of lisp
12:51:21 <xerox> Oh-uhm, I see.
12:51:34 <qtmstr> RyanT5000: What about the inefficiency of copying an entire state data-structure when you only want to change one of its fields?
12:51:57 <Philippa> there's a bunch of fold/unfold/map/etc patterns you can do it for, can dramatically drop space complexity and get a speedup at the same time
12:52:01 <RyanT5000> well if you know datastructures never change, then you don't always need to copy it
12:52:02 <xerox> RyanT5000, I think it's illuminating to realize that since there are no side-effect, there are only *effects* !
12:52:26 <RyanT5000> i'll grant you that it's less efficient with, for example, arrays
12:52:28 <xerox> Philippa, any example comes to mind?
12:52:45 <RyanT5000> but with lists, trees, and other pointer-based datastructures
12:53:04 <Philippa> xerox: is probably easier to say read the papers. Unfold-then-fold'd be an example IIRC
12:53:17 <RyanT5000> most changes are only to small parts of the datastructure - the other parts can still be referred to normally
12:53:43 <xerox> Philippa, okay, danke!
12:53:50 <RyanT5000> whereas in C++ you would *always* have to copy the whole thing, because even if you're passed a const datastructure*, that doesn't mean that it can't be changed by someone else
12:53:59 <Philippa> and often you're using an older version of the structure too - sharing can be a big gain
12:54:07 <RyanT5000> in haskell you can define infinitely large datastructures too
12:54:07 <RyanT5000> like
12:54:09 <RyanT5000> [1..]
12:54:17 <RyanT5000> which is the list of all whole numbers
12:54:24 <xerox> (positive)
12:54:25 <RyanT5000> as long as you never try to find the end you're fine :)
12:54:33 <Philippa> sort-of
12:54:35 <metaperl_work> RyanT5000: those are all the naturals... whole numbers include 0
12:54:47 <RyanT5000> really? i thought it was the other way around
12:54:50 <Philippa> you often can't reclaim any of the memory, and space leaks suck
12:54:58 <dcoutts> in my book naturals include 0
12:55:01 <Philippa> metaperl: depends which mathmo you talk to
12:55:05 <Philippa> and yes, my book too
12:55:27 <dcoutts> if you ask someone who's studies set theory then natuals include 0
12:55:41 <metaperl_work> In mathematics, a natural number is either a positive integer (1, 2, 3, 4, ...) or a non-negative integer (0, 1, 2, 3, 4, ...). The former definition is generally used in number theory, while the latter is preferred in set theory and computer science.
12:55:49 <metaperl_work> http://en.wikipedia.org/wiki/Natural_number
12:55:53 <dcoutts> because of the way you define the naturals
12:56:01 <metaperl_work> so I guess it is arbitrary. you learn something new all the time :)
12:56:13 <RyanT5000> yah; i always thought of 0 as rather natural :)
12:56:18 <RyanT5000> whereas it doesn't seem very whole
12:56:25 <Philippa> RyanT5000: you never tried to put 0 of something in someone's hand?
12:56:26 <metaperl_work> wh0le
12:56:38 <RyanT5000> yah i do it all the time
12:56:38 <metaperl_work> see the zero? thought so :)
12:56:51 <metaperl_work> natura1
12:56:52 <RyanT5000> i put $0 in lots of peoples hands
12:56:57 <metaperl_work> see the one? thought so :)
12:56:57 <dcoutts> data Nat = Zero | Succ Nat
12:57:07 <RyanT5000> but yeah, wikipedia says Whole = nonnegative
12:57:10 <RyanT5000> then it says
12:57:20 <RyanT5000> "unfortunately it's also used to mean positive"
12:57:25 <RyanT5000> whatever
12:58:07 <RyanT5000> huh
12:58:31 <RyanT5000> is it possible for me to just get the whole bloody hierarchical library as source, and shove it in my source directory and use ghc --make?
12:58:31 <xerox> Anyone into nonstandard analysis?
12:58:55 <RyanT5000> i've heard it doesn't do much
12:59:29 <RyanT5000> but that's from the wikipedia page on it, which is obviously not written by a nonstandard analysis guy
12:59:38 <RyanT5000> cause it basically says "nonstandard analysis is totally redundant"
12:59:50 <palomer> @seen Philippa 
12:59:51 <lambdabot> Philippa is in #ScannedInAvian, #haskell-overflow, #haskell-blah and #haskell. Last spoke 3 minutes and 25 seconds ago.
12:59:57 <palomer> Philippa: you around?
13:00:04 <Philippa> ish, yeah
13:00:07 <Philippa> 'sup?
13:00:41 <palomer> Philippa: you were interested in subtying for datatypes, right?
13:00:49 <Philippa> yeah
13:00:53 <palomer> http://citeseer.ist.psu.edu/freeman94refinement.html
13:00:55 <palomer> have you seen this?
13:01:17 <Philippa> a long time ago and didn't have the background at the time. I should re-read it
13:02:02 <palomer> wait, I have a better paper...
13:04:56 <palomer> hrmph, can't find it
13:05:07 <palomer> but yeah, I think refinement types are exactly what you need
13:05:26 <palomer> like, zero and pos are both subtypes of nat
13:05:37 <palomer> since zero has one constructor of nat, and pos the other
13:05:44 <palomer> I think this is a _great_ idea, btw
13:16:05 <RyanT5000> i love windows... it's reboots so quickly
13:16:08 <RyanT5000> :-/
13:17:59 <ValarQ> RyanT5000: doesn't help it to spend less time rebooting compared to other systems :P
13:18:29 <RyanT5000> lol i was kidding anyway
13:18:35 <RyanT5000> it just took like 10 minutes
13:18:59 <ValarQ> ow, thats pretty long time
13:19:18 <RyanT5000> yeah; granted it's the server version, but when i first installed it it was only like 1 minute
13:19:31 <ValarQ> not even my most service loaded unixboxes can match that
13:19:46 <RyanT5000> yeah, and i  haven't turned on any meaningful services
13:19:51 <RyanT5000> i think i have apache, and, uh...
13:19:52 <RyanT5000> ?
13:19:54 <RyanT5000> nothing
13:20:02 <ValarQ> heh
13:20:07 <RyanT5000> yeah windows just sucks
13:20:21 <RyanT5000> if i weren't trying to develop a game that i want people to buy (= on windows)
13:20:26 <RyanT5000> i would be on linux so fast
13:21:21 * ValarQ whispers: libsdl
13:21:27 <ValarQ> ;)
13:21:30 <RyanT5000> lol welll right now i'm using C#
13:21:39 <ValarQ> ouch
13:21:41 <RyanT5000> yeah
13:21:55 <RyanT5000> anyway
13:22:08 <RyanT5000> as soon as that's out the door i'm switching
13:22:11 <ValarQ> i guess it's not easily ported to ANSI C then...
13:22:14 <RyanT5000> heh no
13:22:19 <RyanT5000> i'm using a lot of reflection and stuff
13:22:38 <RyanT5000> i'm very, very tempted to port the whole thing to haskell though
13:22:46 <ValarQ> :)
13:22:48 <RyanT5000> i learned haskell this weekend
13:22:55 <RyanT5000> i've yet to find anything i don't like
13:22:57 <RyanT5000> except right now
13:22:59 <RyanT5000> i can't figure out
13:23:07 <RyanT5000> how the hell to get opengl for ghc6.5
13:23:16 * ValarQ doesn't know much C++, objc, java or c# :(
13:23:24 <RyanT5000> heh it's better that way
13:23:48 <RyanT5000> i found haskell when i was searching for (what i now know are called) monads
13:24:08 <ValarQ> oh, usually it's the other way around
13:24:33 <RyanT5000> well i've been thinking about designing a language for a long time
13:24:36 <Philippa> I invented a similar idea as an extension to a Java-like language having learnt a little haskell but not what a monad was
13:24:47 <Lemmih> RyanT5000: Why do you want ghc-6.5?
13:24:49 <Philippa> but it wasn't fleshed out fully
13:24:57 <RyanT5000> i'm trying to use visual haskell
13:25:06 <RyanT5000> it's tightly bound to ghc-6.5
13:25:24 * ValarQ isn't very keen to extend C syntax languages
13:25:57 <ValarQ> maybe with the exception for C--
13:26:09 <ValarQ> C-- is actually a great idea
13:26:16 <dcoutts> indeed
13:26:25 <RyanT5000> what's the idea with it?
13:26:29 <RyanT5000> i've never heard of it
13:26:40 <ValarQ> higherlevel assembler
13:27:04 <RyanT5000> oh ok i know about that
13:27:11 <RyanT5000> never really liked it though
13:27:12 <ValarQ> should be some common language for compilers
13:27:13 <RyanT5000> i prefer nasm
13:27:29 <ValarQ> nasm can't generate code for that many platforms :)
13:27:35 <RyanT5000> true
13:27:44 <RyanT5000> but it also doesn't dick around with my assembly :P
13:27:50 <RyanT5000> unlike masm tasm etc.
13:27:53 <RyanT5000> if i'm going to write asm
13:27:57 <RyanT5000> i'd like to actually write the asm
13:28:24 <ValarQ> i also like nasm (or yasm now that i got myself an amd64)
13:29:01 <ValarQ> i even made a small network server in it once :)
13:29:12 <RyanT5000> gj :)
13:29:18 <RyanT5000> the biggest thing i wrote was an MD5 algorithm
13:29:21 <ValarQ> RyanT5000: http://arda.no-ip.org/server.asm
13:29:52 <RyanT5000> i ended up doing 2 million blocks/second on my 1.7ghz p4 mobile
13:30:00 <ValarQ> RyanT5000: and the same in haskell: http://arda.no-ip.org/server.hs
13:30:00 <RyanT5000> so it wasn't half bad
13:30:13 <ValarQ> better than the C tool?
13:30:15 <chrisbrown> @hoogle liftM
13:30:16 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
13:30:16 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
13:30:16 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
13:30:33 <chrisbrown> what does liftM do?
13:30:45 <RyanT5000> oh and technically speaking it was 2 million complete MD5s, each of one block
13:30:53 <RyanT5000> i was writing a password cracker ;)
13:31:23 <ARous1984> @map
13:31:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
13:31:33 <RyanT5000> i only found one thing faster, which used an algorithmic weakness in md5
13:31:38 <RyanT5000> and it was 2.5m/s
13:31:45 <norpan> chrisbrown: liftM takes a normal function and makes it a function in the monad
13:31:55 <chrisbrown> ah thats not what i want
13:32:17 <chrisbrown> i need to call an IO String monad within a IxStateMT.WithState monad
13:32:25 <chrisbrown> but its not having it
13:32:44 <norpan> never heard of IxStateMT
13:33:51 <Lemmih> chrisbrown: Is IxStateMT an instance of MonadIO?
13:33:52 <norpan> a quick google gives that it's not an IO monad so you can't do that
13:34:13 <chrisbrown> norpan: is there no way to make it so?
13:34:22 <xerox> IOT :-P
13:35:02 <norpan> chrisbrown: that's the point with IO
13:35:17 <norpan> IO String is probably that type for a reason
13:35:20 <chrisbrown> ok
13:35:28 <chrisbrown> is there a way I can take something out of a monad
13:35:36 <chrisbrown> so IO String -> String
13:35:38 <norpan> no
13:35:41 <chrisbrown> bummer
13:35:45 <norpan> no bummer
13:35:51 <RyanT5000> keep in mind you're returning a state transition
13:35:54 <RyanT5000> if you don't return that
13:35:56 <chrisbrown> well, bummer for me
13:35:59 <RyanT5000> it doesn't happen
13:35:59 <norpan> the whole point with IO is that you should not do that
13:36:07 <RyanT5000> no, not bummer - that's not what you're trying to do :)
13:36:28 <chrisbrown> i am trying to call IO!!! and it wont let me, so it IS a bummer for me. 
13:36:29 <norpan> the question you should ask is why do you have an IO String in the first place
13:36:38 <chrisbrown> because I am using GHC API
13:36:45 <chrisbrown> and that is in the IO monad
13:37:10 <Lemmih> chrisbrown: Make IxSateMT an instance of MonadIO.
13:37:11 <norpan> if you have the IO monad as container monad for your WithState then it's possible
13:37:47 <norpan> then you just use fmap
13:37:49 <Lemmih> (which may require modifying IxStateMT)
13:38:02 <norpan> what type does your WithState have
13:38:14 <chrisbrown> norpan: what do you mean?
13:38:27 <norpan> WithState takes a monad as parameter
13:38:44 <chrisbrown> the function is of this type http://haskell.org/ghc/docs/6.4.1/html/users_guide/separate-compilation.html#search-path
13:38:47 <norpan> if that's the IO monad then just fmap (your IO String)
13:38:47 <chrisbrown> whoops
13:38:54 <chrisbrown> not that... this filePath -> m (InScopes,Exports,HsModuleP,[PosToken]) 
13:39:13 <norpan> but what is m
13:39:28 <chrisbrown> IxStateMT.WithState (PFE0State PosName.Id
13:39:28 <chrisbrown>                                                    Names.QName
13:39:28 <chrisbrown>                                                    ds
13:39:28 <chrisbrown>                                                    (PFE2.PFE2Info PosName.Id, ext))
13:39:28 <chrisbrown>                                         m
13:39:30 <chrisbrown> ?
13:39:50 <norpan> huh
13:40:21 <chrisbrown> i have no idea what m is
13:40:22 <norpan> I think you are way out of your knowledge leage here
13:40:28 <chrisbrown> oh thanks
13:40:47 <norpan> are you doing some kind of assignment?
13:40:52 <chrisbrown> haha
13:41:06 <chrisbrown> no i am an the HaRe development team
13:41:46 <norpan> you are on the development team and don't know what the IO monad is?
13:42:39 <chrisbrown> i am doing my PhD - I am still learning
13:42:44 <norpan> ok
13:42:56 <chrisbrown> i didn't come here to be patronised
13:43:08 <norpan> what you should ask yourself is why to you have an IO String in the first place
13:43:23 <chrisbrown> well, i know that
13:44:02 <norpan> the idiom is that you do IO in a well isolated place and then pass just a String down to the pure functions
13:44:56 <norpan> but if your monad is on top of the IO monad then you can certainly do IO inside it
13:45:10 <norpan> so that's why I asked about the type of your monad
13:45:29 <RyanT5000> how can i rebuild the hierarchical libraries from source?
13:45:35 <chrisbrown> norpan: have you ever looked at the code for Programatica?
13:45:35 <RyanT5000> also, where can i get them?
13:45:57 <norpan> no I don't know what programatica is, i just googled up the code for IxStateMT.hs
13:46:04 <Lemmih> chrisbrown: I think it would be easiest to just copy how HaRe is doing IO in IxStateMT. If they aren't doing any IO then it's most likely because IO isn't allowed inside IxStateMT.
13:46:10 <chrisbrown> finding the type for 'm' is not easy - not just difficult for me but also others on the development team also
13:46:19 <norpan> the WithState has a parameter m
13:46:28 <norpan> if that is the IO monad, then use fmap
13:46:44 <Lemmih> chrisbrown: If that's so, you either need to rewrite IxStateMT or rethink your design.
13:46:51 <norpan> or lift
13:47:23 <norpan> actually, use lift
13:47:44 <norpan> if x is IO String, try to use lift x and see if it works :)
13:52:13 <norpan> chrisbrown: sorry for being a bit patronized, but "how can I get an IO String -> String" is a typical newbie question :)
13:55:43 <RyanT5000> how do i compile a .gc file?
13:57:14 <chrisbrown> norpan: thanks lift seems to work! :)
13:57:20 <norpan> freat
13:57:21 <norpan> great
14:00:40 <ARous1984> --This is the main function.
14:00:40 <ARous1984> sudoku n puzzle = sudokuHelper n (puzzle : []) 
14:00:40 <ARous1984> --Sudoku's helper
14:00:40 <ARous1984> sudokuHelper n [] = []
14:00:40 <ARous1984> sudokuHelper n (x:xss)
14:00:41 <ARous1984>  | x == [] = sudokuHelper n xss
14:00:43 <ARous1984>  -- | exhausted(candidatePuzzle) && not(solved x) = []
14:00:45 <ARous1984>  | not (solved x) = sudokuHelper n (solve (reduce(pickupPlacedTerms x n) x n) x n)
14:00:47 <ARous1984>  | solved x = x :  sudokuHelper n xss 
14:00:49 <ARous1984> --This is the solver
14:00:51 <ARous1984> solve candidatePuzzle puzzle n
14:00:53 <ARous1984>  | validMove candidatePuzzle = {-do trace(show puzzle) trace(show candidatePuzzle)-} (move candidatePuzzle puzzle 0) : []
14:00:56 <ARous1984>  | otherwise = {-do trace(show puzzle) trace(show candidatePuzzle)-} sudokuRecurse n (guess candidatePuzzle puzzle 0)
14:01:01 <ARous1984> --blah blah
14:01:02 <ARous1984> sudokuRecurse n [] = []
14:01:04 <ARous1984> sudokuRecurse n (x:xss) = (sudoku n x)  ++ (sudokuRecurse n xss)
14:01:06 <ARous1984> is that bad recursion? :)
14:01:30 <norpan> depends on what you mean by bad
14:01:36 <norpan> using an accumulator is better
14:01:46 <norpan> then you will get tail recursion
14:03:09 <ARous1984> guess returns a list of guessed puzzles on the first smallest list of possible guesses
14:03:21 <ARous1984> so then i want to run each puzzle back through sudoku to see if it'll solve that guess.
14:03:39 <ARous1984> but when it finds a solution, it keeps repeating itself. i was thinking the function sudokuRecurse is the problem.
14:04:06 <norpan> ah, you mean bad in that sense .)
14:06:07 <ARous1984> Yeah
14:06:08 <ARous1984> :)
14:10:13 <cinema> dcoutts, please don't forget to put the modified 'hsgclosure.c' (allowing to compile with ghc HEAD) in gtk2hs normal repository
14:10:54 <dcoutts> cinema, oh yeah. Hmm, remind me again in 10 days when I get back from Holiday.
14:11:09 <cinema> dcoutts, OK, I'll do it
14:11:58 <dcoutts> cinema, I'd do it now, but I need to merge the two files into one (6.4 & 6.5+)
14:12:32 <cinema> dcoutts, nothing urgent, but it'll be necessary one day, when HEAD becomes stable
14:12:38 <dcoutts> indeed
14:18:10 <franka> Indeed.
14:18:44 <franka> That IS a good word, isn't it?
14:19:27 <work_metaperl> indeed
14:26:27 <RyanT5000> could anyone help me out with using ghc-pkg? i got all the information on these packages, but i don't know how to find the files they refer to
14:27:21 <RyanT5000> i'm trying to get a package from one database and add it to another
14:27:25 * tennin is reading the thesis on Haskell XML Toolbox
14:28:37 <tennin> it makes me wonder if Haskell will be the first language where Unicode identifiers and symbols are commonly used, simply because people seem to be rapidly using up all the available ASCII infix operators
14:29:08 <RyanT5000> what are the rules for infix operators?
14:29:11 <mauke> no, you're thinking of perl6
14:29:30 <mauke> which already has unicode operators in the core
14:29:46 <benc_> it does?
14:30:44 <mauke> Â« Â» Â¥
14:30:48 <wolverian> mauke, it's not released yet, though.
14:31:01 <wolverian> (also, it has unicode set operators.)
14:31:09 <mauke> awesome
14:31:25 <tennin> what does Â¥ do?
14:31:30 <wolverian> didn't APL use unicode though?
14:31:36 <wolverian> tennin, infix zip
14:32:07 <benc_> neat
14:32:13 <benc_> can haskell do that?
14:32:22 <xerox> Do what? :-)
14:32:27 <wolverian> `zip` :)
14:32:35 <benc_> unicode ops
14:32:47 <SuperTails92> benc_: only if the compiler lets you
14:33:59 <tennin> they're in the standard though, aren't they?
14:34:31 <RyanT5000> WOOHOO
14:34:44 <RyanT5000> glut is now in my other database
14:34:51 <RyanT5000> that only took me like 4 hours
14:34:56 <xerox> There also is unzip.
14:34:59 <xerox> ?type unzip
14:34:59 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
14:45:43 <tennin> oh, right, APL obviously
14:45:57 <tennin> though not actually unicode
14:49:17 * tennin wonders if he's used up his quota of obviously wrong remarks for the day or if there's still more to come
14:55:31 <dcoutts> xerox, sad to miss you in .it :-(
14:55:44 <xerox> dcoutts, oh no :-(
14:55:49 * dcoutts is off to Italy for 12 days
14:55:57 <xerox> No stop in Milian, right?
14:56:02 <dcoutts> direct train from paris to rome
14:56:13 <xerox> Wroooom.
14:56:51 <dcoutts> indeed
14:57:40 <RyanT5000> is it ok to use a .hi file with the wrong version?
14:57:58 <xerox> dcoutts, well... next time :-)
14:58:07 <dcoutts> yeah
14:58:11 <dcoutts> that'd be fun
14:58:22 <dcoutts> or when you come to the UK
14:58:40 <xerox> I'd love to.
15:13:50 <gadolin> hey, i wrote buble sort and get error on bubbleSort ::  [Ord a] ->  [a]. Class `Ord' used as a type?
15:14:07 <RyanT5000> Ord a => [a] -> [a]
15:14:59 <gadolin> :) thx
15:15:02 <RyanT5000> np :)
15:36:24 <Lemmih> dcoutts: Happy holidays.
15:38:03 <xerox> dcoutts, oh, when are you leavin'?
15:41:30 <dcoutts> Lemmih, thanks
15:41:45 <dcoutts> xerox, tomorrow morning, early
15:41:55 <xerox> ohub, have big fun!
15:42:06 <dcoutts> Lemmih, btw, kolmodin_ has been working on inotify bindings
15:42:33 <dcoutts> I'll want to use that for a proper file browser that follows changes in the file system
15:43:26 <dcoutts> xerox, I'll eat lots of Naples pizza and climb vesuvius (maybe not at the same time)
15:43:36 <xerox> Take photos! :-)
15:44:25 <dcoutts> will do
15:44:32 <xerox> Goodnight!
15:44:37 <dcoutts> g'night
15:46:20 <ohub> xerox_; hmm?
15:56:10 <dons> ?brain!
15:56:10 <lambdabot> But where will we find an open tattoo parlor at this time of night?
15:59:44 <sieni> I really think that everybody that demonstrably gets the Haskell logo tattooed on themselves should get a honorable mention on haskell' report
16:00:17 <dons> oh!
16:00:59 <dons> @karma+ Lemmih -- implementing GHC.Base.breakpoint 
16:00:59 <lambdabot> Lemmih's karma raised to 14.
16:01:06 <sieni> I was planning of getting a haskell logo tattoo
16:01:09 <sieni> :-)
16:01:27 <dons> hehe
16:02:35 <sieni> (I've got a few tattoos already and going to get some 10 hours more of inking on my shoulder, so a Haskell logo wouldn't hurt so much (figuratively speaking)
16:03:35 <dons> well, depends on how big..
16:03:40 <dons> full back lambda
16:04:12 <dons> you could get the zipWith fibs too ;) 
16:04:26 <sieni> that would be an option although that would need the colours to be changed
16:04:50 <sieni> because the haskell logo colours are Unbelievably Fucking Ugly
16:04:55 <sieni> even pink would be better
16:05:00 <dons> maybe maybe
16:07:49 <sieni> I think that I have hard time imagining colours that I hate more that have been chosen to the Haskell logo
16:08:20 <sieni> aren't like the traditional heraldic colours enough for logo design?
16:09:27 <sieni> the logo itself is perfect
16:10:08 <RyanT5000> you should put some timeless and salient chunk of code too
16:10:27 <RyanT5000> in the spirit of t-shirts with decss :P
16:12:34 <RyanT5000> hm, is there a clustering library for haskell?
16:12:51 <RyanT5000> that seems really easy to write, given we already have a parallel computation library
16:12:57 <RyanT5000> easy to write, hard to optimize
16:14:27 <sieni> RyanT5000: if you have tough enough parallel computation problem you might be better off writing a program in a functional programming language that generates lower level code for you
16:14:42 <franka> What are the Haskell colors?
16:14:54 <franka> I only imagine the blue lambda.
16:15:00 <sieni> franka: http://www.haskell.org/haskellwiki_logo.png
16:15:20 <sieni> it's like purple lambda with turquoise circle or something
16:15:25 <sieni> *vomit*
16:15:51 <RyanT5000> sieni: do you mean generate C or something?
16:16:01 <sieni> RyanT5000: For example
16:16:01 <franka> I grant that I don't care much for that logo myself.
16:16:35 <franka> It is actually really bad as an example of logo design.
16:16:35 <sieni> RyanT5000: I think that FFTW uses OCaml to generate C code
16:16:46 <Cale> sieni: you're right
16:16:56 <sieni> Cale: about what?
16:16:59 <sieni> :-)
16:17:00 <franka> A logo should be legible at small sizes, not too complex, and not dependent on gradation.
16:17:06 <Cale> It does use OCaml to generate C
16:17:13 <franka> Also it should be evocative, but no one has a clue what those symbols mean but Haskellers.
16:17:13 <RyanT5000> but isn't that more about making a highly-optimized single thread than about making a multithreaded app?
16:17:31 <Cale> and yeah, custom code generation is the way to go if you want really fast code
16:17:43 <Cale> regardless of parallelisation
16:17:46 <RyanT5000> right i understand that
16:17:54 <RyanT5000> but for the sake of parallelization alone
16:18:14 <RyanT5000> let's say you don't care if it runs 2x slower, you just want to take advantage of your 2000-node cluster (man, i wish i had that)
16:18:28 <RyanT5000> then is there any advantage to generating C?
16:18:29 <sieni> RyanT5000: it depends what you are doing
16:19:06 <Cale> If you're willing to go to the trouble of generating C, you might also consider generating assembly
16:19:40 <SuperTails92> Cale, (well written) C is portable. assembler isn't
16:19:41 <RyanT5000> well C saves you the trouble of register allocation
16:19:45 <RyanT5000> and it can also be portable
16:19:46 <RyanT5000> yeah
16:19:49 <Cale> right
16:20:01 <RyanT5000> afaik C compilers do a damn good job with register allocation
16:20:15 <Cale> but the optimality of solutions will be affected by machine architecture
16:20:20 <RyanT5000> true
16:20:31 <dcoutts> C is actually suprisingly portable, in practice more so than haskell (well ghc at least)
16:21:04 <RyanT5000> well there are more platforms on which you can compile C
16:21:10 <dcoutts> indeed
16:21:17 * SuperTails92 wonders how portable hugs is
16:21:29 <dcoutts> it's pretty portable
16:21:42 <dcoutts> not so good on non-unix
16:21:45 <RyanT5000> but in my experience the actual porting from gcc to gcc can be very annoying (depending on how it was written - damn you unistd.h) 
16:22:14 <tennin> is C-- practical to use?
16:23:23 <sieni> RyanT5000: well, this is all well, but why don't you make your program generate nice code suited for the parallel architecture and the problem you are running. Surely it must be both easier and more interesting to dump in some PDE problem and a multiprocessor computer architecture as an input and get a program out to both solve the problem and generate efficient code
16:23:58 <RyanT5000> i'm only discussing this hypothetically, sieni
16:24:14 <RyanT5000> i don't have a particular project in mind (at least not one i'll be starting within the next 5 years)
16:24:31 <RyanT5000> however if i did, i would definitely be taking your advice
16:26:40 <dons> very 
16:26:51 <dons> s/.*/hugs is very portable/
16:27:17 <dons> its the most widely ported current impl.
16:27:30 <RyanT5000> can you compile ghc in hugs?
16:27:35 <RyanT5000> or does it compile at all
16:27:40 <dons> hugs is an interpreter
16:27:54 <RyanT5000> er let me put forth a better idea
16:27:55 <dons> but, no, ghc uses ghc extensions that hugss doesn't support
16:27:59 <RyanT5000> ah ok
16:28:10 <RyanT5000> i was going to say run ghc in hugs to compile ghc :P
16:28:17 <dons> so hopefully, after Haskell' is standardised. these things might again be possible
16:28:39 <dons> to compile ghc on a new arch you just port the C files it generates
16:28:51 <dons> its fairly easy as far as porting compilers goes
16:29:09 <dons> RyanT5000, so how's the haskell hacking going?
16:29:20 <RyanT5000> pretty good, although i gave up on SDL temporarily
16:29:30 <RyanT5000> also
16:29:34 <RyanT5000> i'm using visual haskell
16:29:48 <RyanT5000> which apparrently only includes half the packages of normal ghc
16:30:07 <RyanT5000> so i'm currently running configure on yesterday's snapshot of ghc 6.5
16:30:12 <RyanT5000> so that i can build the libraries
16:30:26 <RyanT5000> so that i can transplant them into visual haskell :-/
16:30:34 <dons> yep
16:30:55 <RyanT5000> other than that visual haskell looks pretty nice, though
16:31:13 <dons> yeah. a fair bit of work went in to it
16:31:30 <dons> have you read the visual haskell paper from last year's haskell workshop?
16:31:45 <RyanT5000> no; what's it about?
16:32:04 <RyanT5000> i guess that's sort of a dumb question
16:32:11 <dons> it's about visual haskell
16:32:13 <dons> ;)
16:32:19 <dons> the implementation
16:32:29 <RyanT5000> so like how they index the files and stuff
16:32:50 <dons> more about how they call ghc to do syntax highlighting, type checking and more
16:33:05 <RyanT5000> ah ok
16:33:26 <RyanT5000> i think haskell needs a bona fide IDE of its own :)
16:33:45 <RyanT5000> is hIDE actually going anywhere?
16:33:54 <sieni> RyanT5000: I think I was partly referring to that: http://ieeexplore.ieee.org/iel1/2/2260/00062091.pdf?tp=&arnumber=62091&isnumber=2260&arSt=25&ared=37&arAuthor=Berlin%2C+A.%3B+Weise%2C+D.%3B
16:33:56 <dons> yep. Lemmih's working on it a fair bit
16:34:11 <dons> and there's Yi too. which is fully Haskell.
16:34:25 <dons> but a lot of Haskell hackers don't use ides beyond vim and emacs
16:34:47 <dons> just like there's no (?) C ide
16:34:55 <dons> or is there. just one that no one uses
16:36:02 <RyanT5000> right
16:36:10 <RyanT5000> thanks sieni
16:36:19 <dons> mmm. espresso
16:39:28 <dons> hmm. now I have to ask myself: why did my book from amazon go via frankfurt?
16:39:57 <dons> seems kinda inefficient to double the distance
16:41:15 <sieni> dons: what do you mean?
16:41:37 <dons> aaaah, unless they thought "Australia" was "Austria"
16:41:57 <dons> the book seems to have flown the long way around the planet to get to .au
16:42:14 <Cale> hehe
16:42:18 <dons> i.e. it travelled 2/3 around the planet, rather than 1/3 across the pacific
16:42:22 <dons> very weird
16:42:41 <Cale> what carrier?
16:43:05 <sieni> dons: it's not as bad as when the postal people ruined some DNA samples that were supposed to go to Austria from Finland but took a detour through Australia
16:43:16 <dons> DHL
16:43:26 <dons> yikes!
16:44:34 <dons> I've heard of this kind of thing happening before
16:44:45 <dons> morning Cale.
16:44:55 <xahlee__> .seen xerox_ 
16:45:09 <dons> so, what exciting adventures in the world of Haskell will we have today, I wonder?
16:45:17 * dons is turning into a morning person
16:45:31 <xahlee__> can anyone show me a usage of -> ?
16:45:41 <dons> > (\x -> x + 1) 2
16:45:42 <lambdabot> 3
16:45:44 <sieni> xahlee__: yes
16:45:50 <xahlee__> that is, am looking for code snippets containing ->
16:46:00 <dons> > case 1 + 2 of x -> x + 1
16:46:01 <lambdabot> 4
16:46:21 <Igloo> xahlee__: There are at least 3 different ->s in Haskell
16:46:30 <dons> -> is syntax. not an operator. (well, except on the type level, its a funny constrctor)
16:46:49 <dons> > let f :: a -> a ; f x = x in f 8
16:46:49 <xahlee__> o, the -> is for pure function?
16:46:50 <lambdabot> 8
16:47:01 <JKnecht> Lemmihs working on a debugger in hIDE?
16:47:13 <dons> Lemmih's committed a debugger for ghci
16:47:21 <Igloo> \ patterns -> expression    is read  "the function that takes <patterns> and returns <expression>"
16:47:23 <dons> well, breakpoints anyway
16:47:36 <Cale> -> separates the parameters from the body of a lambda term, as well as the pattern from a branch of a case expression
16:47:46 <Cale> It also is the type constructor for function types
16:47:55 <xahlee__> Igloo: thanks and thanks all.
16:48:06 <dons> ah, there's one more ->
16:48:09 <dons> ?kind Either
16:48:10 <lambdabot> * -> * -> *
16:48:18 <Igloo> That's not Haskell
16:48:25 <dons> boo on Igloo
16:48:26 <JKnecht> if you can do BPs the rest of symbolic debugging should be mop up, albeit a bunch.
16:48:27 <Cale> It's GHC-Haskell :)
16:48:48 * dons is reading the Henk paper and loves it
16:48:53 <dons> lambda cube for all!
16:49:01 <JKnecht> Barendregt?
16:49:11 <dons> named after.
16:49:32 <dons> Igloo, would you want kind annotations in Haskell'?
16:50:27 <Igloo> I'm fairly sure I've never used them, or been anoyed by not having them, so I certainly wouldn't fight for them. I don't think I have any reason to oppose them, though.
16:50:50 <dons> fair enough
16:50:51 <Igloo> Tell you what, if you keep n+k patterns you can have kind annotations  :-)
16:51:01 <dons> I won't fight against n+k
16:51:06 <Igloo> Good man!
16:51:08 <dons> I think after 15 years we can live with it
16:51:21 <franka> I've needed kind annotations.
16:51:28 <Igloo> Do I correctly infer you want kind annotations in H'?
16:51:34 <dons> yeah.
16:51:45 <Igloo> Can you give me an example of why easily?
16:51:45 <dons> I think most do. so they'll probably happen
16:51:52 <dons> monad transformers?
16:52:03 <dons> just good documentation.
16:52:06 <dons> and there's GADTs and the like where you want them
16:52:06 <Igloo> For clarity?
16:52:17 <dons> I'd like them for clarity. sometimes they're needed though
16:52:19 <Cale> @type fmap
16:52:20 <lambdabot> forall (f :: * -> *) b a.
16:52:20 <lambdabot>    (Functor f) =>
16:52:20 <lambdabot>    (a -> b) -> f a -> f b
16:52:26 <Igloo> Right, yeah, I'm probably slightly in favour of them for clarity
16:52:40 <franka> Monad transformers as a type class in the prelude, you mean?
16:52:41 <Igloo> But I've used monad transformers a lot and not needed them
16:52:47 <dons> as we push the type system, they'll be needed more and more
16:52:57 <dons> and if we get kind polymorphism one day
16:53:23 <dons> which would be nice, so $ would work on unboxed thingies
16:53:39 <xahlee__> how about double angle bracket >> ?
16:54:07 <xahlee__> can anyone show me it's use or function?
16:54:10 <dons> putChar 'x' >> putChar 'y'
16:54:21 <franka> xahlee... is that from Wolfe?
16:54:23 <xahlee__> dons: what does that mean pleas?
16:54:25 <dons> do putChar 'x' ; putChar 'y'
16:54:28 <Igloo> How would that work from a code point of view?
16:54:38 <dons> kind polymorphism?
16:54:58 <Igloo> Yes
16:55:25 <Igloo> Oh, I guess you'd still use pointers?
16:55:29 <dons> not sure what you mean by 'code point of view' ?
16:55:46 <dons> oh, you mean, in the back end?
16:55:54 <Igloo> What would the (C) code for $ be if it were to work on unboxed thingies
16:55:59 <dons> well, you could write a polymorphic identity that worked on unboxed thingies
16:56:07 <xahlee__> > >>
16:56:08 <dons> not sure. 
16:56:08 <Igloo> (fear our technical terms!)
16:56:08 <lambdabot>  parse error on input `>>'
16:56:12 <dons> there was a recent thread on this
16:56:51 <mauke> @. djinn type (>>)
16:56:52 <lambdabot> Cannot parse command
16:57:58 <dons> I think "thingies" should be a good synonym for "terms"
16:58:04 <xahlee__> dons: what does >> in english?
16:58:29 <RyanT5000> what does ghc-inplace do? can i use ghc instead?
16:58:38 <mauke> a >> b = a >>= const b
16:58:55 <dons> it evalautes its first argument, throws away the result, and evaluates the second argument.
16:59:14 <RyanT5000> (i'm trying to build the libraries folder of ghc using a built copy of ghc, without compile all of ghc)
16:59:26 <dons> its definned in terms of 'bind' (>>=) as mauke poinnnts out
16:59:40 <dons> ghc-inplace is a ghc that works without having to install it
16:59:45 <dons> it works in tree
16:59:48 <RyanT5000> oh
16:59:58 <franka> It doesn't evaluate them; it just composes them.
17:00:09 <dons> yeah. i'm sloppy
17:00:29 <RyanT5000> so can i just substitute ghc for ghc-inplace, since i have a valid install anyway?
17:00:41 <dons> this isn't a strict language, after all.
17:00:51 <dons> if you've installed it, RyanT, then yep
17:00:57 <RyanT5000> yeah,  i have
17:01:14 <franka> If a is an action, and b is an action, then a >> b is the action of a followed by b, returning the result of b, but discarding the result of a.
17:01:16 <dons> (I can't keep typing "5000" over and over :S)
17:01:51 * Igloo hands dons a tab key
17:02:11 <dons> hmm. not sure if that works. let's see...
17:02:20 <dons> ah!
17:02:26 <dons> thanks Igloo
17:02:32 <dons> I've made a poinnt of not reading irssi man pages
17:02:44 <RyanT5000> (np)
17:03:05 <RyanT5000> (and i don't care about capitalization either ;))
17:03:40 <dons> now, does anyone know what happened to Sven Panne's Haskell wishlist?
17:03:49 <dons> it was a list of all the things that needed to be done
17:04:34 <Igloo> Did it have "Crush Java" listed?
17:04:49 <dons> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg05466.html
17:05:37 <dons> also, we have a missing libraries list somewhere..
17:05:50 <dons> oh, maybe on SimonM's page. hmm.
17:06:15 * Igloo giggles at the list
17:06:34 <Igloo> "Finished: * Missing select in Posix" -- unless I'm very much confused, that's now been removed  :-)
17:06:37 <dons> ?remember Igloo [dons: anyone know what happened to [the] Haskell wishlist?]  Igloo: Did it have "Crush Java" listed?
17:06:37 <lambdabot> Done.
17:06:45 <dons> hmm
17:06:51 <dons> and a mixfix library??
17:07:11 <dons> those guys were nutty back in 00 ;)
17:08:01 <Igloo> I think most of that is actually done in one way or other
17:08:13 <dons> yeah. hmm. maybe we need a new list!
17:08:18 <dons> to focus people
17:08:27 <dons> after Haskell' perhaps ...
17:08:41 <Igloo> We need something to top "Haskell Execution Platform"
17:09:13 <Igloo> "Enterprise-level Haskell middleware layer" or something
17:09:13 <dons> ah yes. the HEP. 
17:09:18 <dons> oh my
17:09:22 <Igloo> We need some buzzwords, people!
17:09:33 <xahlee__> dons: would it be right to say >> is pretty much like ; in imperative lang?
17:09:44 <xahlee__> dons: or perhaps elisp's progn?
17:09:51 <dons> I think that would be ok to say, yes.
17:09:53 <franka> xahlee__: Yes, basically.
17:10:12 <xahlee__> i see..
17:11:09 <xahlee__> but what's the alternative in haskell of not using >>?
17:11:21 <dons> using do notation?
17:11:34 <dons> writing your own monad without syntax support?
17:11:35 <Igloo> Or pure functions where the compiler works out the order for you
17:11:39 <dons> threading the state yourself?
17:11:47 <dons> using nested lets?
17:11:50 <xahlee__> ok i see!
17:12:03 <dons> using nested cases?
17:12:10 <dons> lots of fun things
17:12:22 <franka> arrows
17:12:26 <xahlee__> ah, the significance of >> is because one specifies a order of execution which normally isn't needed in hasell
17:12:29 <dons> arrows!
17:13:00 <dons> ah, here's the "missing libs list" http://www.cs.york.ac.uk/fp/libraries/layoutSM.html
17:13:15 <dons> oh, I have a Text.Regex.PackedString. hmm. should package that
17:13:32 <dons> and we don't seem to haave Text.Pretty.Wadler anymore?
17:13:43 <Igloo> That's not missing libs, just the proposed hierarchy?
17:13:55 <dons> yeah. of things that should exist, no?
17:14:15 <Igloo> No, just where things would go if they existed AfAIK
17:14:20 <dons> it can be read as a hierarchy for a haskell of tomorrow.
17:14:43 <dons> yes. but the things that don't exist, but appear here, should probably exist.
17:15:55 <xahlee__> ok one last one. :) can anyone give me a pointer to the use of => +
17:16:05 <xahlee__> + -> ?
17:16:50 <franka> a -> b is the type of functions from a to b
17:17:05 <Igloo> context => type    is read    "if <context> is true, then the type <type>"
17:17:21 <franka> In C a => b, a and b are types, while C is a type class.
17:17:40 <franka> And it means that the type a, appearing in b, is constrained to be of class C.
17:17:56 <dons> ?type List.sort
17:17:57 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:18:16 <dons> so, sort only operates on lists of 'a's, where that 'a' is a member of Ord
17:18:37 <dons> as opposed to:
17:18:42 <dons> ?type List.sortBy
17:18:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
17:18:48 <franka> Why is lambdabot responding to question marks now?
17:18:54 <dons> where you supply the comparison functoin explicitly
17:19:23 <dons> why not? It fits better in my head to use ? for queries
17:19:37 <dons> @id .
17:19:37 <lambdabot> .
17:19:38 <dons> still works
17:19:43 <franka> I see.
17:20:38 <Igloo> Does lambdabot respond in messages and on channel in the same way?
17:20:39 <xahlee__> which has more stickiness? => or ->
17:20:57 <Igloo> -> binds tighter
17:21:03 <xahlee__> k
17:21:05 <franka> C a => a -> b means C a => (a -> b).
17:21:10 <dons> it should, Igloo. unless i misunderstand your question
17:21:25 <Cale> there can only be one => in a type
17:21:35 <franka> (C a => a) -> b would be a syntax error.
17:21:47 <Igloo> dons: So if someone says "?" on channel they'll get a screenful from lambdabot?
17:21:56 <Cale> I suppose unless you're allowing for higher rank types :)
17:22:02 <Cale> ?
17:22:07 <Cale> nope :)
17:22:28 <dons> no. it restricts it to: (commands `arePrefixesOf` text) && length text > 1 && (text !! 1 /= ' ')
17:22:30 * Igloo was hoping to find out without risking a screenful, but thanks  :-)
17:22:45 <dons> ? what are you crazy?
17:22:49 <xahlee__> is there a proper section in the lang report explaining => ?
17:23:21 <franka> Hi, Pseudonym.
17:23:36 <dons> "Type classes and overloading" ? xahlee__ 
17:23:48 <dons> s4.3
17:24:02 <Pseudonym> G'day.
17:24:20 <franka> Pseudonym: I was wondering if the Pseudonym on /. is you.
17:24:30 <Pseudonym> Yes.
17:24:38 <Pseudonym> Uh oh, my reputation post-cedes me.
17:24:53 <franka> It has a tendency to do that.
17:25:02 <xahlee__> i don't quite understand "type class" or "context"
17:25:07 <franka> Mine circles around me and nips at my legs.
17:28:21 <xahlee__> Igloo: when you said Â«context => type    is read    "if <context> is true, then the type <type>"Â», what is the context of the statement? i mean, what is the purpose of â€œcontext => typeâ€?
17:28:33 <xahlee__> a definition of a type for a function?
17:28:40 <Igloo> Yes
17:29:12 <franka> xahlee__: You need to learn about "instance" and "class" declarations.
17:29:26 <franka> Then it will become clear.
17:29:47 <xahlee__> then, if the Context isn't true, then what is the type of the function?
17:29:58 <xahlee__> franka: any pointer to tutorials?
17:30:10 <franka> If context is false, it has no type.
17:30:30 <xahlee__> how can a fun have no type?
17:30:30 <franka> I think all the tutorials must mention them.
17:30:37 <franka> Exactly.
17:30:50 <xahlee__> ok
17:30:54 <tony2> Chaps, could someone explain to me what alignment is and is for in in Foreign.Storable?
17:30:59 <tony2> I appricate that's probably not such a bright q. but my low-level understanding isn't too good I'm afraid.
17:31:07 <franka> If it has no type, it is an invalid declaration.
17:31:39 <tony2> (sorry about the off-topic-ness)
17:31:48 <RyanT5000> i believe what alignment is referring to is the spacing between data in the structure
17:32:16 <RyanT5000> for instance, if you have a structure with a single-byte variable followed by a 4-byte variable
17:32:20 <RyanT5000> and you have alignment=4
17:32:24 <franka> xahlee__: Basically, C a is true if there is an instance declaration "instance C a where ..."
17:32:26 <RyanT5000> then it'll actually be an 8-byte structure
17:32:59 <RyanT5000> (becuase it's aligning the structure, and the second variable, to the nearest 4-byte boundary)
17:33:02 <franka> For example, instance Num Int where ...
17:33:27 <franka> So Num String will be false, but Num Int and Num Double will be true.
17:34:18 <tony2> RyanT5000, is it only necessary for variables of variable length type then?
17:34:40 <franka> The class declaration for Num says that there are operators like (+), (*) etc. that you can use on types Num a => a.
17:35:09 <franka> The instance declaration says what the particular definitions are for each type.
17:36:40 <xahlee__> franka: i think i got it
17:36:45 <xahlee__> letting it sit for a while
17:41:22 <bojohan> tony2: if you have a "struct foo {foo x; bar y}" you need to know how x and y are packed in memory
17:41:44 <bojohan> you can let some tool do the calculations for you
17:42:10 <tony2> bojohan, isn't sizeOf enough for that though?
17:42:32 <tony2> such that sizeOf x + sizeOf y == sizeOf foo
17:43:54 <tony2> I gather though there will be unused memory in between the two x and y.
17:44:53 <bojohan> http://en.wikipedia.org/wiki/Data_Structure_Alignment
17:45:11 <tony2> bojohan, thanks, I'll take a read.
17:47:26 <Igloo> hsc2hs can work out sizeOf for you, with "sizeOf _ = #size C_struct_name"
17:47:56 <Igloo> Sadly I don't think there's a portable way to do alignment easily. "alignment _ = #const __alignof__(C_struct_name)" works with gcc and hsc2hs
17:48:33 <RyanT5000> sorry about that tony, i was away; looks like bojohan filled you in well though
17:49:01 <bojohan> -- assuming typedef struct _PointInfo { double x, y; } PointInfo;
17:49:01 <bojohan> data PointInfo_ = PointInfo_ CDouble CDouble
17:49:01 <bojohan> instance Storable PointInfo_ where
17:49:01 <bojohan>   [...]
17:49:05 <bojohan>   sizeOf    _  = (#size PointInfo)
17:49:07 <bojohan>   alignment _  = (#const __alignof__(PointInfo))
17:49:49 <psnl> c
17:49:59 <mauke> #define ALIGNOF(T) offsetof(struct { char _dummy__; T (_elem__); }, _elem__)
17:51:20 <tony2> Thanks all, I understand now.
17:54:37 <xahlee__> i so love the haskell logo
17:57:33 <xahlee__> i have now just written up the significances of the haskell logo's symbols
17:57:50 <xahlee__> Haskell.org has a new logo, inargurated in 2003-05. (http://haskell.org/) Superb. It is made of 5 math symbols revolving around a big lambda. The symbols are: right arrow â†’, inverted A âˆ€, double right-pointing angle braket â‰«, double colon ::, double right arrow â‡’, and lamba Î».
17:57:54 <xahlee__>  The right arrow â†’ signifies transformation. The inverted A âˆ€ signifies â€œfor allâ€. The double angle â‰« signifies free from disorder. The double colon :: signifies exactitude. The double right arrow â‡’ signifies generality. Finally, the lambda Î» signifies functionality.
17:58:07 <xahlee__> thanks for all the help :>
17:58:43 <tenni1> don't they represent the "...static typing, higher-order functions, polymorphism, type classes and monadic effects" mentioned in the banner image copy?
18:00:11 <franka> I'm with tenni1.
18:00:57 <tennin> actually, I just now realized that
18:01:15 <tennin> before, I didn't like the logo because I thought it was just a bunch of random symbols found in the language
18:02:00 <franka> That's one reason why it's not such a hot logo.
18:02:26 <tennin> well, it makes sense now
18:03:47 <RyanT5000> it's way too busy
18:05:36 <dons> it's not 'the' logo anyway, it's just 'a' logo :)
18:05:57 <franka> This is true.
18:06:06 <franka> To me the blue lambda is the Haskell logo anyway.
18:06:25 <franka> OTOH, too many lambda's in FPL logos..
18:06:39 <dons> agreed.
18:06:42 <dons>  on both points.
18:09:10 <dons> we need a arrow with kind annotations :)
18:09:19 <dons> something like: C a => a -> a :: *  
18:09:22 <xahlee__> what?? i don't know what you guys talking about
18:09:36 <xahlee__> The Haskell Logo is the perfection of logos
18:09:51 <xahlee__> as far as functional programing lang logo goes
18:10:03 <dons> arrows of the various kinds => -> ~> and :: * are more haskellish these days than \
18:10:10 <xahlee__> it is extremely beautiful, and embodies the beauty of math.
18:10:19 <xahlee__> and it is The logo.
18:10:31 <dons> ?remember xahlee The Haskell Logo is the perfection of logos
18:10:32 <lambdabot> Done.
18:10:34 <franka> It embodies the beauty of math symbols, not of math.
18:10:37 <xahlee__> yeah, the symbols mean specific things in haskell lang, 
18:10:43 <xahlee__> but it doesn't mean those in a logo.
18:10:50 <tennin> we need Darren Aronofsky to make a sequel to "pi" called "lambda"
18:10:57 <dons> hehe
18:11:47 <dons> about a postgrad who uses haskell to solve some mystery about Go with fix points and combinators
18:11:56 <xahlee__> if there is one thing i didn't like about the haskell logo, it is the gradient coloring of the circle
18:12:17 <xahlee__> i rather like it flat.
18:12:18 <tennin> and give FP popular sex appeal
18:12:19 <dons> and ports ghhc to some crazy rig he has in his basement
18:12:53 <dons> I'm sure Pi made it easier to do all the math movies that are out there these days
18:13:18 <xahlee__> franka: what's FPL?
18:13:26 <franka> dons: That would be astrolabe.
18:13:35 <franka> xahlee__: Functional Programming Language
18:13:36 <dons> ooh. we're approaching 100,000 hits on haskell.org since it became a wiki a few weeks back
18:13:51 <dons> I'd like to see some stats as to whether the traffic is going up.
18:13:59 <dons> now that there's much more content
18:14:05 <dons> and more dynamic content
18:15:07 <xahlee__> btw, here's a new logo http://web.engr.oregonstate.edu/~erwig/pfp/
18:15:32 <xahlee__> view the image by itself, because it's much bigger
18:15:47 <xahlee__> http://web.engr.oregonstate.edu/~erwig/pfp/PFP-Logo.gif
18:16:09 <tennin> that's cute
18:16:10 <franka> Hm, searching for lambda pics, I found this: http://images.google.nl/imgres?imgurl=http://www.xahlee.org/UnixResource_dir/gki/lambda/bullfrog.gif&imgrefurl=http://www.xahlee.org/UnixResource_dir/lambda_logo.html&h=150&w=150&sz=2&tbnid=0FCk6_euGOWY8M:&tbnh=90&tbnw=90&hl=nl&start=116&prev=/images%3Fq%3Dlambda%26start%3D100%26svnum%3D10%26hl%3Dnl%26lr%3D%26sa%3DN
18:17:01 <Pseudonym> Woah.
18:17:07 <Pseudonym> That's a hell of a URL there.
18:17:10 <dons> that's an interesting one on erwigs page.
18:17:37 <dons> this new haskell book has an interesting cover:  http://images-jp.amazon.com/images/P/4839919623.01.LZZZZZZZ.jpg
18:18:23 <dons> can anyone translate the blurb on the front?
18:18:24 <Pseudonym> Oh, I like that.
18:18:34 <Pseudonym> Well, the bottom character is "door".
18:18:37 <xahlee__> dons: that's funny!
18:18:40 <Pseudonym> Is the top one a lambda?
18:18:48 <dons> is it the evil birds from Bird style lhs ?
18:18:58 <xahlee__> the top two read chars means: introduction
18:19:04 <Pseudonym> Right.
18:19:06 <xahlee__> or literally: into door
18:19:07 <dons> that leave bird tracks on your code?
18:19:07 <franka> Pseudonym: "Introductory"
18:19:14 <franka> enter-gate
18:19:39 <Pseudonym> Those birds look pretty mean.
18:19:46 <dons> yeah. evil haskell, eh?/
18:19:52 <xahlee__> å…¥é–€
18:19:58 <franka> dons: "Your first functional programming language"
18:20:12 <dons> I should add this book to the wiki list of books
18:20:33 <xahlee__> the bottom line's chinese means: learn functional lang
18:20:34 <franka> Or, literally, "the first functional programming language you learn".
18:21:43 <xahlee__> franka: you know japanese?
18:21:51 <dons> does anyone know why those birds would be used?
18:21:57 <franka> Yes...
18:22:05 <dons> do the red eyes mean something? (other than "evil")
18:22:27 <dons> is it some stylistic convention?
18:22:37 <franka> I have no clue why those birds are there or look like that.
18:22:59 <xahlee__> i â™¥ them
18:26:28 <franka> Check out Y0 (y-naught): http://www.eecs.harvard.edu/~greg/
18:27:35 <franka> Quite amazing the things you find searching for lambda images...
18:35:24 <xahlee__> Microsoft puts a lot support into FP
18:36:28 <franka> More like certain researchers at MS do.
18:38:27 <dons> ms puts a lot of money into research. it cares not what, as long as its name is in the title.
18:40:12 <xahlee__> what's the status of their F#?
18:42:57 <xahlee__> http://en.wikipedia.org/wiki/F_Sharp_programming_language
18:43:04 <franka> I think it's more Don Syme's than MS's.
18:45:17 <franka> We should be thankful, I suppose, that Erik Meijer is working on C#.
18:45:35 <franka> However, he seems to have gone batshit crazy in the last few months.
18:46:28 <xahlee__> http://research.microsoft.com/fsharp/fsharp.aspx
18:48:51 <franka> Well, I'm going to sleep.  'night, all.
19:03:24 <xahlee__> are there more users of O'Camel/ML or Haskell?
19:05:19 <dons> I think Haskell these days. Certainly more research is being done on Haskell.
19:05:28 <dons> I might be wrong about the number of users. it's hard to tell
19:05:43 <dons> OCaml and Haskell might be around the same. Though the Haskell community seems far more active
19:05:50 <dons> old skool ML seems much quieter.
19:06:55 <dons> I mean, how many people are there in #ocaml ?
19:07:06 <dons> whilst there's 6 haskell channels...
19:07:17 <wchogg> 6 channels?
19:07:22 <wchogg> I can only think of 3
19:07:25 <dons> and we're stealing #ocaml'ers and perl guys every day ;)
19:07:31 <dons> ?wiki IRC_channel
19:07:31 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
19:08:02 <dons> oh, 7. actually. if you count the haskell' channel.
19:08:22 <wchogg> I was counting haskell'.  I actually didn't know about the overflow channel.
19:09:47 <dons> I think, and I'm only basing this on conferences and news, that the trend over the last couple of years has been ocaml losing programmers to haskell.
19:09:51 <int-e> hmm, there aren't many people there anymore
19:10:10 <dons> and noticing more ocaml people turn up here.
19:10:14 <dons> ?quote mwc
19:10:15 <lambdabot>  I actually got away with running Haskell through a TeX pretty printer and handing it in as pseudocode
19:10:21 <dons> wrong one.
19:10:35 <dons> ?quote dcnstrct
19:10:35 <lambdabot>  even the #lisp people say go with haskell
19:10:38 <dons> ah, that''s it.
19:11:34 <dons> it helps that haskell was born as open source, way back in 1990, in response to closed source Miranda.
19:11:52 <xahlee__> yeah...i think so too
19:12:01 <dons> (unlike, say Clean, which was always going to struggle while it was closed src)
19:12:47 <dons> the big ML compilers are academic projects, not open source communities, which hampers their take up by non-academics, I think.
19:12:55 <dons> not sure about OCAml, though.
19:12:58 <dons> vincenz, you there?
19:13:13 <dons> vincenz came over from OCaml, so knows a bit more on the subject.
19:14:33 <xahlee__> mm
19:14:35 <dons> I think now that its well understood that lazy languages like clean and haskell can run just as fast as a strict fp lang, you'll see more people take up Haskell for its sophisticated aspects, like STM and such. they're no longer scared off by performance concerns of the early 90s.
19:15:11 <RyanT5000> i don't understand why closed-source languages are ever given much support
19:15:15 <dons> haskell's a lazy and strict language, after all. so you get the best of both worlds.
19:15:23 <RyanT5000> i can understand if it has a few closed-source compilers
19:15:38 <dons> yeah. it's crucial to gcc's success, for example. and for ghc and the rest of haskell.
19:15:41 <RyanT5000> but if the primary compiler for a language is closed-source, that just rubs me the wrong way
19:16:01 <RyanT5000> even moreso than the OS, you have to be able to trust the language
19:16:13 <dons> i remember I wanted to use Clean many years ago, but had to register to get hold of a copy. that was just enough incentive to not bother.
19:16:38 <dons> that kind of drop off percentage will affect the language in the long run.
19:16:54 <dons> its key to make the thing as easy to get hold of as possible.
19:17:04 <RyanT5000> yeah
19:17:42 <dons> this probably affected the "register first" Yale Haskell back in the early 90s. when it had to compete with the very open hbc and ghc
19:18:25 <dons> in fact, the first release of ghc, in 1991, has  a lovely message about it being "Free, as always!"
19:19:15 <dons> hmm, I wonder how much being born as a response to closed source alternatives affects projects like emacs, linux and haskell
19:19:23 <dons> or openssh
19:19:37 <dons> that incentive to replace a closed system seems to be very motivating.
19:20:00 <dons> or mozilla, say.
19:20:43 <xahlee__> the OPenSource is largely a lie
19:20:45 <dons> we should probably market the "Born free, and always will be" aspect of Haskell. It would appeal to some open source people, I think.
19:21:03 <xahlee__> the OpenSource is largely a lie
19:21:21 <xahlee__> ignoramuses lying thru their teeth
19:21:42 <xahlee__> mostly out of their ignorance and selfishness
19:21:46 <RyanT5000> wtf xahlee?
19:22:13 <xahlee__> the primary drive for the OpenSoure ideal and shit is because $Free$, like cigarette given to kids
19:22:25 <xahlee__> and every joe on earth want free things
19:22:33 <xahlee__> that is how OpenSource thrive
19:23:00 <xahlee__> the associated thought about how they have great minds about humanity are just latched-on lies
19:23:10 <dons> cigarettes, eh? good thing ghc doesn't give me cancer then.
19:23:25 <xahlee__> RyanT5000: i suppose you are young and student
19:23:45 <dons> i'm just glad I can hack and fix bugs in the systems I use.
19:23:46 <RyanT5000> yes and yes, but i'm not about to say that i like open source because it's good for the world
19:23:46 <xahlee__> your thoughts are basically the production of the current fashions and trends of the society you live in
19:24:01 <RyanT5000> actually, i can think for myself quite well, thank you very much
19:24:05 <dons> ah, xahlee. I remember you now!
19:24:18 <mauke> RyanT5000: don't bother. xah lee is a known troll and asshat.
19:24:30 <RyanT5000> alright; thanks for the heads up :)
19:24:42 <xahlee__> http://xahlee.org/UnixResource_dir/writ/responsible_license.html
19:24:50 <Korollary> @keal
19:24:50 <lambdabot> just seeing how offtopic i could get everyone
19:24:54 <xahlee__> respnosible software licensing and related artciles on the issue
19:25:42 <RyanT5000> hahaha xahlee why did you link that
19:25:52 <RyanT5000> now i think so much less highly of you
19:27:38 <dons> oh, that's a good keal you hit there, Korollary 
19:28:02 <xahlee__> on OS...folks.. as a lie it has great impact on society
19:28:15 <xahlee__> and one of them is impede progress and economy
19:28:39 <RyanT5000> what's your favorite OS xahlee?
19:29:00 <xahlee__> the OpenSource fuck is today like a juggernaut sucking in the young and spreading ignorance
19:29:15 <Korollary> @keal
19:29:15 <xahlee__> it is comparable to the Red Guards of the Mao or the Hitler Youth
19:29:15 <lambdabot> last day i was in my lab i had a diagram which might have removed pi
19:30:05 <dons> ?brain
19:30:05 <lambdabot> If I could reach you I would hurt you.
19:30:21 <dons> hehe
19:30:22 <araujo> Hello
19:30:26 <dons> that one makes me smile.
19:30:32 <dons> hey araujo.
19:30:34 <dons> how's uni?
19:30:35 <xahlee__> basically, throughout history it is the young who leads revolutions or mucking society, for good or bad, because they have nothing and have nothing to loose. As a consequence, it is they that makes trouble.
19:31:50 <xahlee__> well... that'll be all i have to say on this now. Folks, just keep it in mind.
19:34:38 <dons> shapr, did you know there was an irc.haskell.org? http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg07185.html
19:34:41 <araujo> hello dons , how you doing? :-)
19:34:41 <dons> back in 2000
19:34:57 <dons> good. nice sunny autumn day here. good for hacking and thinking
19:35:24 <araujo> :-)
19:36:39 <int-e> xahlee__: I think you should target people and companies who sell their software; demanding accountability from people who give away their stuff for free (and who said you had to use it?) isn't fair.
19:37:20 <xahlee__> int-e: yes i agree on this somewhat
19:37:53 <RyanT5000> any idea why when i type gcc -v it says "gcc.exe: no input files"?
19:38:03 <RyanT5000> i'm running mingw (sorry about it being off-topic)
19:38:11 <xahlee__> RyanT5000: --version
19:38:23 <RyanT5000> still says it
19:38:51 <RyanT5000> even if i supply a cpp file it still says the same thing
19:40:43 * araujo wonders if somebody with a darcs.haskell.org page can help him
19:56:03 <ihope> Ah, yes. In readsPrec, what's the Int argument supposed to mean?
19:56:14 <ihope> Something to do with operator precedence, right?
20:04:59 <Pegazus> What's a good site for use as a haskell reference? (like looking how to do something, or if there is a function or syntaxis to do something, etc...)? (For easy lookup if you don't know what you are looking for?)
20:05:14 <ihope> @where report
20:05:15 <lambdabot> I know nothing about report.
20:05:17 <araujo> haskell.org
20:05:22 <araujo> check the standard libs
20:05:31 <newsham> http://haskell.org/learning.html   see "references" columns
20:05:59 <dons> ?where h98
20:05:59 <Pegazus> thanks
20:05:59 <lambdabot> I know nothing about h98.
20:06:07 <dons> ?where haskell98
20:06:08 <lambdabot> http://haskell.org/onlinereport/
20:06:19 <dons> anyway, haskell.org is the centre of all things haskell
20:06:25 <Pegazus> i don't want to learn :p i just want to do hehehe
20:06:39 <dons> > Just "do it"
20:06:40 <lambdabot> Just "do it"
20:06:59 <dons> > do Just it where it = ()
20:06:59 <lambdabot> Just ()
20:07:03 <newsham> yet another haskell tutorial is a good starting point.  or two dozen short lessons if you want a more "pure" intro
20:07:04 <dons> almost
20:07:20 <newsham> tackling the awkward squad is a godo follow up
20:07:55 <Pegazus> i know some basics about the language :)
20:08:07 <Pegazus> i'm just doing a subject for with i'll need to do a "tp"
20:08:54 <ihope> > Just (do it) where it = []
20:08:54 <lambdabot> Add a type signature
20:09:02 <ihope> > Just (do it) where it = [] :: Maybe [Int]
20:09:02 <lambdabot> Couldn't match `Maybe [Int]' against `[a]'
20:09:25 <ihope> > Just (do it) :: Maybe [Int] where it = []
20:09:26 <lambdabot> Just []
20:09:53 <Pegazus> -_-
20:09:59 <Pegazus> anyway
20:10:46 <newsham> > Maybe Not
20:10:46 <araujo> mm...
20:10:47 <lambdabot>  Not in scope: data constructor `Not'
20:11:07 <araujo> Pegazus, haskell.org is the main language site
20:11:13 <Pegazus> thanks
20:11:21 <araujo> you will find pretty much what you need there
20:11:43 <Pegazus> is there anything
20:11:51 <Pegazus> that checks errors better than hugs?
20:12:02 <Pegazus> (because last time i used it, errors werent very informative...)
20:12:07 <wchogg> ghci has very helpful messages, I think.
20:12:09 <newsham> ghci's errors are better
20:12:24 <Pegazus> ghci is GHC?
20:12:32 <ihope> Pretty much.
20:12:38 <newsham> yah, part of the same package.  i for intearctive or interpretter or something
20:12:42 <wchogg> Yes, it's the repl version of ghc.
20:12:42 <dons> ghc --interactive   
20:12:44 <Pegazus> mmm good
20:12:56 <Pegazus> so you advise me to use ghci so?
20:13:00 <Pegazus> for developing haskell things?
20:13:07 <newsham> i started with hugs, i found ghci to be nicer in many ways.
20:13:14 <newsham> it has my vote
20:13:14 <dons> yes.
20:13:14 <dons> and use ghc to compile it 
20:13:22 <Pegazus> are all interpreters or compiler like hugs'
20:13:26 <Pegazus> that needs the spaces to be aligned?
20:13:27 <ihope> @index hPrint
20:13:28 <lambdabot> System.IO
20:13:29 <Pegazus> and all that shit?
20:13:46 <newsham> peg: you can use {}'s instead of using space formatting for layout
20:13:48 <mux> I found the ghci error messages to be slightly more helpful than hugs one in many cases
20:13:53 <Pegazus> good
20:13:55 <Pegazus> i didn't know that one
20:14:08 <mux> fwiw
20:14:10 <dons> ghci is what most of us use these days for trying things out
20:14:10 <moi_os> Anyone else tried "Write Yourself a Scheme in 48 hours" on Mac OS X running GHC from Darwinports? 
20:14:19 <newsham> > do { x <- "abc"; y <- "XY"; return (x,y) }
20:14:20 <lambdabot> [('a','X'),('a','Y'),('b','X'),('b','Y'),('c','X'),('c','Y')]
20:14:24 <moi_os> I've probably missed something, but I don't seem to have Parsec ... thoughts? 
20:14:36 <Pegazus> what the hell is Visual Haskell?
20:14:43 <newsham> visual studio plugin
20:14:46 <dons> spaces  are more readable. if you don't like them, you can use ; and { } as if it was 1972 all ovre again
20:14:54 <ihope> moi_os: stick "import Parsec" near the beginning of your Haskell source file
20:15:06 <newsham> dons: its always 1972 on irc :)
20:15:07 <Pegazus> what is visual haskell for?
20:15:20 <newsham> peg: go check out google.  it knows.
20:15:32 <moi_os> ihope; well I did "import Text.ParserCombinators.Parsec hiding (spaces)"
20:15:34 <Pegazus> what ide do you advise me to use?
20:15:42 <newsham> vi + ghci :)
20:15:44 <Pegazus> (i like syntaxis higlighting, auto completation and all those nice things)
20:15:44 <dons> emacs or vimm
20:15:46 <Pegazus> i hate vi
20:15:49 <Pegazus> with all my souls
20:15:50 <moi_os> I used the code that was included. IT gave me an error ... let me fetch
20:15:51 <Pegazus> soul
20:15:57 <newsham> use pico, or emacs or cat.  *shrug*
20:15:58 <araujo> Pegazus, you can check for helium
20:16:01 <araujo>  http://www.cs.uu.nl/helium
20:16:11 <dons> very few people use vi. most use emacs or vim.
20:16:22 <newsham> yah, by vi i mean vim.
20:16:28 <moi_os> It says: ___stginit_TextziParserCombinatorsziParsec_
20:16:35 <ihope> Hmm, I forgot about Helium.
20:16:41 <dons> -package parsec moi_os
20:16:56 <Pegazus> i generally dislike linux
20:17:15 <araujo> Pegazus, what do you use?
20:17:18 <Pegazus> windows :)
20:17:30 <araujo> ok, no comment ;-)
20:17:38 * mux tries to restrain from laughing
20:17:40 <Pegazus> why?
20:17:56 <dons> it's not a serious development environment. and can harm your grade average 
20:18:15 <dons> as you don't get a chance to explore the system internals, as you would on a BSD or linux
20:18:23 <Pegazus> ?
20:18:27 <newsham> i use vim + ghci in windows
20:18:33 <moi_os> dons: beautiful, I think that worked
20:18:33 <moi_os> Y'know, the docs even say to do that. Guess I just didn't read down far enough
20:18:34 <Pegazus> i really doubt that....
20:18:53 <dons> I teach perl, haskell and java, and I've noticed a correlation.
20:18:54 <newsham> dons: sure you can, its just a lot more challenging
20:19:01 <dons> yeah, you need to work harder
20:19:03 <Pegazus> it's not a serious development environment ---> and i definetly deny that
20:19:15 <mux> and how do you explore the system internals under windows without having the source?
20:19:18 <dons> its much nicer to use a system from the ground up designed for hacking
20:19:25 <Pegazus> i don't want to explore windows internals
20:19:25 <RyanT5000> mux: reverse engineering :P
20:19:31 <Pegazus> and i would never do that on linux
20:19:33 <dons> which would explain the massive adoption of unix-like systems by  developers
20:19:37 <Pegazus> most of it's code is really unreadable...
20:19:46 <newsham> mux: articles, tools, reverse engineering, books, reverse engineering, debuggers, did i mention reverse engineering?
20:19:48 <mux> yeah, well, try another open-source system
20:20:03 <Pegazus> i don't need to get the source of my operative system
20:20:03 <newsham> reading linux is sort of like reverse engineering sometimes :)
20:20:04 <dons> *shurg* use a BSD system then. beautiful inside and out
20:20:06 <Pegazus> i just want to use it
20:20:09 <mux> newsham: this is quite ridiculous :-)
20:20:11 <RyanT5000> Pegazus: I use windows, so i'm not going to knock you for using it, but it really is terrible
20:20:12 <newsham> netbsd and freebsd much more transparent :)
20:20:21 * mux nods
20:20:26 <Pegazus> <RyanT5000> --> but it really is terrible --> thats not true
20:20:31 <Pegazus> window is very good for some things
20:20:36 <RyanT5000> like...?
20:20:41 <Pegazus> is the easiest OS to use i know (i'vent tried mac ones)
20:20:51 <RyanT5000> oh yeah i don't mean overall
20:20:54 <RyanT5000> i mean for developing software
20:20:56 <mux> there are quite a few legitimate reasons to use windows, but "I dislike linux" is not a valid one in my book
20:21:02 <Pegazus> it's really easy to configure things, blah blah because you don't do it yourself
20:21:03 <wchogg> Oh, I think osx or ubuntu linux is easier to use than windows.
20:21:10 <dons> yeah, we're talking about developing software. since this is a programming language channell..
20:21:12 <Pegazus> for developing software is really nice and easy...
20:21:24 <araujo> Pegazus, are you a programmer?
20:21:26 <RyanT5000> windows is good for developing windows apps, if you have visual studio
20:21:27 <Pegazus> yes
20:21:28 <RyanT5000> that's why i use it
20:21:29 <Pegazus> i am
20:21:43 <dons> why , oh why, are good windows hackers so rare? there's some here, but not many.
20:21:57 <mux> dons: coincidence? :D
20:22:01 <RyanT5000> self-selection
20:22:01 <araujo> Pegazus, well, firs time i know a programmer who doesn't care about having the source code of the programs he uses :-)
20:22:04 <Pegazus> why , oh why, are good windows hackers so rare? --> not coincidence
20:22:08 <newsham> there are lots of windows hackers.  i imagine your sample space is biased since they run in a different crowd
20:22:08 <dons> must be, mux.
20:22:09 <RyanT5000> windows has a much lower bar of entry
20:22:21 <Pegazus> windows hackers are really good, so they never get catched and that's why you don't know about them
20:22:27 <Pegazus> linux are worst than the windows ones
20:22:28 <newsham> (there's also a natural lure to unix for many hacker types)
20:22:30 <RyanT5000> you have to be better just to know what you're missing
20:22:31 <Pegazus> so you get to know some of them :)
20:22:38 <Korollary> @keal
20:22:38 <mux> windows hackers sounds like a contradiction
20:22:38 <lambdabot> bot defective
20:22:44 <newsham> peg: i dont think he means that sort of "hacker"
20:22:47 <wchogg> Err, I don't think that's what he means by hacker.
20:22:48 <Pegazus> i 'd never use windows for a server
20:22:50 <dons> oh, you don't mean hackers in the usual sense Pegazus 
20:22:53 <Pegazus> or a pc that is supposed to be "secure"
20:22:57 <dons> you mean it in the keal sense
20:22:57 <Pegazus> but for private use
20:23:02 <Pegazus> just for developing things
20:23:05 <Pegazus> it's really nice
20:23:16 <RyanT5000> no man we're not using that form of the word "hackers"
20:23:18 <Pegazus> i was just hoiking dons
20:23:22 <newsham> i think dons meant more of a "can build a chair with a pile of lumber and an axe" sort of hacker
20:23:35 <araujo> Pegazus, Because it isn't only the fact of having or not the source code, but also of how many advantages that gives you about plenty of other things, mainly for developers of any kind, for example, better error messages, better opportunities to debug your applications, plenty of developer tools with source code available, easier to write application that fully interacts with the whol OS, and more
20:23:37 <wchogg> newsham: and nothing else?
20:24:21 <Pegazus> better error messages ---> comeau are the best ever
20:24:24 <dons> engineer sort of hacker. where are they? why do the good students use linux or bsd? something's going on. and if you want to improve your skills, picking up linux or bsd seems to be a good thing to do.
20:24:29 <Pegazus> the next ones i've seen are borland 
20:24:39 <Pegazus> (for debugging to, the best ide i've seen was a bcb6)
20:24:45 <Pegazus> the linux one i've seen sux
20:24:55 <araujo> Pegazus, linux got no debuggers :-)
20:24:56 <dons> similarly, the good students don't seem to use IDEs. why is that?
20:24:56 <mux> you know, many people don't believe in IDEs
20:24:56 <RyanT5000> i've heard XCode is really nice
20:25:00 <araujo> Pegazus, linux is a kernel
20:25:06 <mux> dons: heh, you read my mind.
20:25:09 <Pegazus> <dons> similarly, the good students don't seem to use IDEs. why is that? --> because they are really stupid
20:25:18 <mux> Pegazus: or so you think
20:25:27 <wchogg> dons:  Might it be simply because alot of students that are really enthusiastic don't like the idea of things being out of their control?
20:25:27 <Pegazus> i'm a good student and i use an IDE :)
20:25:41 <Pegazus> and i produce quite good code, really fast...
20:25:43 <araujo> Pegazus, no, because IDEs are just a wall in your way :-)
20:25:46 <mux> I can understand why people like IDEs at first
20:25:49 <dons> I think so. using windows shows a lack of motivation, perhaps.
20:25:57 <dons> and lack of an exploratory nature
20:26:00 <mux> but when you get to know that kind of stuff more, you realize that vim is all you need
20:26:08 <Pegazus> vim sux
20:26:12 <Pegazus> syntaxis highligthing
20:26:16 <Pegazus> autocompletition
20:26:17 <mux> hm?
20:26:21 <dons> hmm?
20:26:22 <Pegazus> and all that sort of things are really nice :)
20:26:24 <dons> vim has both.
20:26:26 <mux> hahaha.
20:26:26 <newsham> I dont use visual studio much, but the latest version has some pretty nifty wiz-bang features in the gui
20:26:27 <araujo> haha
20:26:32 <RyanT5000> i don't think there's any fundamental reason IDEs couldn't help even the most advanced programmer
20:26:34 * mux hands Pegazus :syntax on
20:26:40 <RyanT5000> it's just that most IDEs are not designed for advanced programmers
20:26:41 <dons> I think this is what I mean about 'curiosity'
20:26:44 <mux> want my ~/.vimrc ?
20:26:45 <wchogg> dons:  So is that inherently related to the qualities of linux or just the fact that smart people don't like being mainstream?
20:26:57 <dons> or they like to be able to take things apart
20:26:58 <mux> what use is an IDE when you can do :make in vim? :-)
20:27:09 <Pegazus> RyanT5000: most advanced programmers doesn't use them because they are generally big headed and I DON'T LIKE THIS THING ORI DON'T LIKE MIROSOFT SO I WON'T USE ANYTHING OF THIS
20:27:11 <dons> not necessarily mainstream. they resent being shackled perhaps?
20:27:16 <Pegazus> or ALL IS A SHIT, I CAN DO IT BETTER blah blah blah
20:27:31 <araujo> Pegazus, relax kid
20:27:36 <Pegazus> i am relax
20:27:36 <Pegazus> :)
20:27:41 <Pegazus> i was just an example
20:27:45 <RyanT5000> i don't think you're in any position to describe what "most advanced programmers think"
20:27:53 <dons> I encourage the good students I have to install linux, I've been known to hand out openbsd cds
20:28:00 <mux> I don't want to sound arrogant or anything, but you'll realize that you're wrong when you'll have more experience
20:28:09 <Pegazus> <mux> i doubt that :)
20:28:18 * mux shrugs
20:28:23 <RyanT5000> what's your favorite language pegazus?
20:28:29 <Pegazus> <RyanT5000> i don't think you're in any position to describe what "most advanced programmers think" --> and why are you in that position?
20:28:34 <Pegazus> RyanT5000: C++
20:28:35 <wchogg> Well.  Honestly, isn't the mark of a good hacker producing good things?  I mean, if they do it with windows and java that doesn't really matter.
20:28:36 <RyanT5000> i'm not
20:28:38 <RyanT5000> and i didn't
20:28:53 <Pegazus> what's yours?
20:28:53 <mux> Pegazus: how long have you been coding?
20:28:54 <dons> I should point out that ndm is a great hacker, who uses windows. I don't know why, but he does. 
20:28:58 <araujo> wchogg, the thing is that windows itself is not a good thing :-)
20:29:01 <Pegazus> wich language?
20:29:02 <RyanT5000> my favorite language was C++ for years, so i know how you feel
20:29:04 <dons> so its not a hard and fast rule. just a trend
20:29:16 <araujo> So that's why it is kind of contradictory to say that you can produce good software with it.
20:29:17 <mux> yeah
20:29:20 <Pegazus> RyanT5000: did you ever learn c++ correctly?
20:29:37 <dons> maybe if you get into the open source scene, you also get more help from these other smart hackers
20:29:52 <RyanT5000> what does that mean? I've read the whole standard, implemented a parser, i've read many books on oop, and i know template metaprogramming like the back of my hand
20:30:04 <Pegazus> implemented a parser for the full iso c++?
20:30:06 <RyanT5000> yes
20:30:20 <Pegazus> that's really a difficult thing to do it properly...
20:30:24 <wchogg> I've used c++ for a few years now, and sometimes it just seems ugly.  I guess getting really *good* at c++ just feels more like you're learning individual quirks rather than advanced ideas.
20:30:26 <RyanT5000> yeah, it wasn't bug-free
20:30:36 <RyanT5000> i discovered YACC is terrible
20:30:56 <newsham> yacc's pretty good.  its not really what you want to use for c++ though
20:30:58 <Pegazus> is c++ really a context free language?
20:31:03 <RyanT5000> hell no
20:31:06 <Pegazus> i am not so sure
20:31:12 <RyanT5000> C++ isn't even close
20:31:21 <Pegazus> because the symbols can change their meaning
20:31:23 <Pseudonym> C++ is ambiguous.
20:31:24 <Pegazus> depending on where they are
20:31:33 <Pseudonym> Valid C++ has multiple parses.
20:31:33 <Pegazus> <Pseudonym> C++ is ambiguous. --> it's not
20:31:40 <Pegazus> you wouldn't be able to compile it if it were...
20:31:45 <dons> yeah, Pseudonym , I was amazed when I found that out.
20:31:53 <dons> quite stunned.
20:31:53 <RyanT5000> he's referring to the grammar
20:31:57 <Pseudonym> Right.
20:32:08 <RyanT5000> obviously a single text either doesn't compile or produces a unique program
20:32:08 <Pegazus> anyway
20:32:19 <Pegazus> C++ is really nice :)
20:32:20 <newsham> there's a decent PCCTS based grammar for c++ by john lilly
20:32:21 <RyanT5000> but in terms of grammars, "ambiguous" has a different meaning
20:32:22 <Pseudonym> There's a rule in C++ which says, basically: If it looks like a declaration, it is.  Otherwise if it looks like an expression, it is.  Otherwise, it's an error.
20:32:23 <Pegazus> (it could be improved)
20:32:27 <Pegazus> but it's really nice
20:32:37 <mux> C++ has already been improved too much
20:32:39 <Pseudonym> I wouldn't call C++ "nice".
20:32:46 <mux> they should just leave it at that.
20:32:47 <Pseudonym> I'd call it "very, very useful".
20:32:47 <newsham> there's also something for gcc that makes it emit XML of its parse tree which you can use to avoid th eproblem
20:32:48 <Pegazus> C++ has a really much way to go still
20:32:53 <mux> let the old thing die
20:32:54 <Pegazus> metaprogramming is just starting to appear
20:33:07 <dons> now, who was writing a C++ parsre in Haskell recently? and having a hell of a time?
20:33:08 <wchogg> Pseudonym:  I'd agree with that.  It's not elegant, but it can get the job done.
20:33:09 <RyanT5000> if you want to write the kinds of programs that everyone was writing when C++ was invented
20:33:18 <RyanT5000> then C++ is a great language
20:33:26 <RyanT5000> if you want to write other kinds of programs, you are screwed
20:33:29 <Pseudonym> C++'s main drawback is also its main strength: C backwards compatibility.
20:33:38 <mux> this is not true since loooooooong
20:33:39 <Pegazus> c++ language is great because you can make very generic objects with lot's of chance to customize and rehuse them
20:33:50 <newsham> C++'s only redeeming quality is its C compatiblity ;-)
20:34:00 <mux> which it doesn't have snice ages...
20:34:08 <Pegazus> (and it's the only "real" compiled language that can do many generic things)
20:34:09 <mux> there are many nasty differences
20:34:12 <Pseudonym> If it wasn't for C backwards compatibility, C++ would have a much nicer grammar.
20:34:29 <mux> oh well
20:34:44 <newsham> I smell jihad
20:34:45 <Pseudonym> Sometimes, in my bored moments, I try to design a C++-alike which isn't C backwards compatible.
20:35:02 <wchogg> Pseudonym: You mean like D?
20:35:23 <Pseudonym> No, not like D.
20:35:24 <RyanT5000> pegazus, what do you mean it's the only "real" compiled language that can do that? what makes haskell, for instance, not a "real" compiled langauge
20:35:27 <RyanT5000> it can be interpreted or compiled
20:35:39 <dons> its traditionally been a compiled-only language
20:35:40 <Pegazus> RyanT5000: any language can be interpreted or compiled
20:35:40 <Pseudonym> I call it ISL: Ideal Stepanov Language.
20:35:41 <RyanT5000> it can be translated into C, and then compiled
20:35:47 <dons> it was only later that we got a couple of interpreters
20:35:53 <Pegazus> and i didn't say haskell wasn't a real compiled language
20:36:01 <dons> and its always been compilable to asm
20:36:09 <Pegazus> java is compilable to asm
20:36:13 <RyanT5000> so then you said that haskell doesn't support generic stuff?
20:36:22 <Pegazus> i didn't say anything about haskell
20:36:26 <Pegazus> i was talking in general
20:36:28 <Pseudonym> The way I'd express it, is that it has the most flexible and most sane abstraction mechanisms that you can find in what is basically a low-level language.
20:36:34 <RyanT5000> you said c++ is the only language that ____
20:36:38 <Pegazus> i don't know if i consider haskell generic or not
20:36:38 <RyanT5000> i say haskell also ____
20:36:43 <dons> ?docs Data.Generics
20:36:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
20:36:46 <Pegazus> if you answer me a little question i could tell you
20:36:54 <Pegazus> <RyanT5000> you said c++ is the only language that ____ --> some generic things
20:37:01 <RyanT5000> ok
20:37:08 <Pegazus> tell me with other languages
20:37:14 <Pegazus> provides you with the genericy of templates
20:37:15 <Pegazus> at compile time?
20:37:23 <Pegazus> (another compiled language)
20:37:24 <newsham> i coulda swore there are generic list functions in my libc
20:37:25 <RyanT5000> well there's Template Haskell
20:37:34 <wchogg> Although, here's a question.  What's the biggest weakness that haskell has at the moment?  It seems like everyone wants to change the record system, but what else?
20:37:38 <Pegazus> for me a compiled language is anny language that does not have an "Eval()" function or anything like that
20:37:38 <Pseudonym> Haskell is more generic, because it gives you what is basically template instantiation at run-time.
20:37:48 <Pseudonym> Real separate compilation for parametric polymorphism.
20:37:49 <mux> newsham: there is not any standard list functions in C
20:37:56 <dons> doesn't generics in C++ just mean boring polymorphism?
20:37:59 <mux> newsham: the closest being BSD sys/queue.h
20:37:59 <Pseudonym> Haskell doesn't really have eval().  It's an add-on at best.
20:38:02 <newsham> I didnt say "standard" (whatever that means)
20:38:04 <Pegazus> <dons> doesn't generics in C++ just mean boring polymorphism? --> no
20:38:04 <RyanT5000> pegazus: i can write Eval for C++
20:38:13 <Pegazus> but it doesn't have it on it
20:38:15 <mux> newsham: just trying to be helpful :-)
20:38:22 <Pegazus> you don't need to parse c++ code at runtime to do anything
20:38:23 <wchogg> Pegazus:  Huh?  If a language doesn't have an eval then it's not compiled?  How does that work?
20:38:36 <wchogg> (if it *does* have an eval it's not compiled)
20:38:40 <dons> ?type System.Eval.Haskell.eval
20:38:41 <lambdabot> forall a.
20:38:41 <lambdabot>           (AltData.Typeable.Typeable a) =>
20:38:41 <lambdabot>           String -> [System.Eval.Utils.Import] -> IO (Maybe a)
20:38:42 <Pegazus> with any language
20:38:44 <RyanT5000> you don't need to parse haskell at runtime to do anything
20:38:48 <Pseudonym> So Lisp is not compiled, apparently.
20:38:49 <Pegazus> that has an eval function
20:39:01 <Pegazus> you can do all generic things you want
20:39:06 <RyanT5000> pegazus: do you just mean that C++ throws away all the compile-time symbols?
20:39:07 <Pegazus> just writting all the program at runtime
20:39:07 <newsham> wchogg: I'm still a newbie, but I've found some things about the type system that I didnt like.  I also havent seen a good marshalling system and wasnt able to come up with a good way to write one without using TH (which is hackish)
20:39:13 <Pegazus> that's not "generics" for me
20:39:34 <Pegazus> i mean it's generic
20:39:35 <dons> c2hs is a good marhsalling system.
20:39:38 <Pegazus> but not compile time generic
20:39:39 <dons> Storable is ok too.
20:39:43 <newsham> I miss introspection, though I'm not sure how that would play w/ strong typing.
20:39:43 <Pseudonym> C++ doesn't have a good marshalling system.
20:39:45 <Pegazus> it's just been able to write your program at runtime
20:39:46 <dons> depends on what you need.
20:39:57 <Pseudonym> Boost serialisaion is DEFINITELY not good.
20:40:01 <Pseudonym> Which is surprising for a boost library
20:40:11 <newsham> dons: I read c2hs's marshalling stuff.  I think its adequate, but I dont terribly like it.
20:40:15 <wchogg> newsham:  What about the type system do you not like?
20:40:30 <newsham> wchogg: zip,zip3,zip4,zip5, ...
20:40:38 <RyanT5000> ok so pegazus: the template system in haskell is strictly more powerful than the template system in C++; also, haskell throws away just as much of the compile-time data as C++, making it, apparently, a "real" compiled language
20:40:45 <wchogg> newsham:  Ah...yeah, tuples can be kindof ugly.
20:40:46 <newsham> (had a long conversation about this last night, if you wanna check the logs)
20:41:06 <Pegazus> RyanT5000: i never said haskell was or was not compiled...
20:41:09 <dons> I think after reading Garcia et al. Haskell's clearly the common language with the mostsupport for "genericity" (whatever that means) out there
20:41:15 <Pegazus> i told you i don't know enought haskell to say that
20:41:30 <RyanT5000> right and i'm telling you i do, and it is :)
20:41:32 <newsham> dons: it basically describes the process of marshalling.  I would prefer something that didnt artificially specify marshalling order when its not necessary
20:41:59 <newsham> so that a marshalling spec could be (potentially, at least, if not in practice) lazily evaluated, evaluated partially when full data isnt available, etc..
20:42:10 <dons> yeah, I'd lovea Binary-ish marshalling lib. 
20:42:19 <dons> which is great for marshalling to disk and back
20:42:23 <RyanT5000> dons: i'll probably be writing one soon
20:42:23 <dons> and has lazy constructs and so on
20:42:37 <dons> such a thing for the FFI would be pretty cool.
20:42:41 <RyanT5000> depending on whether I end up porting my game to haskell
20:42:42 <Pegazus> RyanT5000: if it is, then i doub it has as much power as c++ does :)
20:42:47 <newsham> I've started messing with some ideas that let me cast marshallable objects back and forth with lazy evaluation, but its either tedious or requires TH
20:42:55 <dons> though we seem to be getting by ok with c2hs for the big libs, and other stuff for smaller projects
20:42:56 <newsham> I havent gotten around to writing the TH bits to do it
20:43:28 <RyanT5000> pegazus: look up "Template Haskell" on google; it has all the power of C++'s templates, except it's also type-safe and you can generate any haskell with it, unlike C++'s templates (which can only generate some c++)
20:43:39 <Pegazus> except it's also type-safe???
20:43:47 <Pegazus> templates on c++ are type safe....
20:43:55 <RyanT5000> no, they produce type-safe code
20:43:58 <Pegazus> (which can only generate some c++) ---> what do you mean by that?
20:44:09 <Pegazus> templates are turing complete...
20:44:19 <RyanT5000> right, they themselves are
20:44:25 <wchogg> Pegazus:  He means that TH *generates* Haskell code.
20:44:32 <Pegazus> so?
20:44:46 <RyanT5000> hm, lemme see if i can think of a template you can't write in C++
20:44:58 <RyanT5000> ok how about (to totally rip off the TH paper)
20:44:59 <moi_os> Hm. Isn't there something like Godwin's Law for saying something is "turing complete"?
20:45:07 <Pseudonym> Something like that.
20:45:14 <wchogg> moi_os, there should be.
20:45:14 <Pegazus> RyanT5000>: there are things you can't write in c++ templates
20:45:19 <Pseudonym> Personally, I write all my code in Turing Machine code.
20:45:34 <Pegazus> i can tell you lots if you want
20:45:35 <Pseudonym> It's got the most genericity of all!
20:45:37 <wchogg> Pseudonym:  yeah, but buying the infinitely long tape is a *pain*.
20:45:46 <Pseudonym> I found a cheap tape seller.
20:45:55 <Pseudonym> Occasionally the machine stops and I need to splice more on.
20:45:57 <RyanT5000> write me a type-safe version of printf in C++ with templates
20:46:23 <RyanT5000> on the other hand, any haskell you could have written can be generated by TH
20:46:24 <Pegazus> it's done
20:46:28 <Pegazus> boost::format
20:46:43 <RyanT5000> i have to be able to call it just like printf
20:46:48 <Pegazus> -_-
20:46:57 <RyanT5000> i didn't say "write me something that's functionally equivalent"
20:47:01 <Pegazus> that's a stupid thing to do
20:47:03 <Pegazus> i want to write
20:47:04 <RyanT5000> why?
20:47:14 <Pegazus> add two to this integer stupid haskell;
20:47:19 <Pegazus> and haskell adds 1 to that integer
20:47:25 <Pegazus> can do do that with templates?
20:47:27 <RyanT5000> yes
20:47:28 <Pegazus> (with more phrases)
20:47:36 <Pegazus> that should all be recognized
20:47:38 <Pegazus> by haskell
20:47:43 <RyanT5000> you can find all instances of (+2) in the code
20:47:45 <RyanT5000> and replace them with +1
20:47:47 <Pegazus> anyway...
20:47:53 <Pegazus> you can do what you want
20:48:00 <Pegazus> with BOOST_PP
20:48:07 <Pegazus> unlesss you are planning to call printf
20:48:11 <Pegazus> with more than 256 vars
20:49:32 <RyanT5000> alright man, i'm pretty much out of time to spend on this conversation, but in all seriousness, i know pretty much everything you can know about C++ templates, having read several books on it and broken gcc and visual studio with my template programs, and from the moment i read the paper on TH, i knew it was much, much better
20:49:49 <RyanT5000> so you can take it or leave it
20:49:56 <monochrom> I believe you.
20:50:10 <RyanT5000> good to hear :P
20:50:26 <Pegazus> i doubt it (but as i haven't read the paper i can't argue you)
20:50:33 <RyanT5000> read the paper, it's short
20:50:34 <araujo> How can i specify in Cabal to install a specific directory containing images into a location?
20:50:45 <Pegazus> RyanT5000: how much is short?
20:51:01 <RyanT5000> it took me about 4 hours to go from "what's haskell?" to "holy shit, haskell is awesome"
20:51:27 <RyanT5000> i dunno, 20 or 30 pages, but you can just skim it
20:51:28 <dons> "[It is] obvious to functional programmers what the [c++] committee did not realise till later: [C++] templates are a functional language evaluates at compile time.."
20:51:29 <Pegazus> haskell is awesome for lots of things
20:51:38 <Pegazus> but i prefer in general for programs to use c++
20:51:45 <dons> albeit an imperfect compile time metaprogramming language
20:52:05 <dons> it was just an accident how it developed.
20:52:06 <RyanT5000> and it's so breakable
20:52:16 <RyanT5000> the compiler support is terrible
20:52:25 <RyanT5000> i had to get the intel compiler
20:52:29 <newsham> btw, anyone know where to get HWS (web server)?  still havent gotten a copy
20:52:30 <Pseudonym> I don't prefer one or the other.
20:52:31 <wchogg> pegazus:  But the question is *why* do you prefer c++?  What qualities does it have that you can't find in anything else?
20:52:33 <Pegazus> get comeau :)
20:52:41 <RyanT5000> it was the only thing i could find taht would handle my templates
20:52:42 <Pseudonym> I have requirements that make me use C++, and I enjoy it most of the time.
20:52:44 <Pegazus> What qualities does it have that you can't find in anything else? ---> i like the syntaxis
20:52:45 <RyanT5000> yeah i bet comeau would too
20:52:51 <Pegazus> i like the power you have
20:53:00 <Pseudonym> I like the power you have in Haskell, too.
20:53:10 <Pegazus> and i think that with a proper  design you can do nearly everything you want really eassy...
20:53:11 <RyanT5000> my two favorite languages atm are haskell and assembly language
20:53:13 <Pseudonym> In Haskell, you can do a lot with very little code, and it's easy to write, and it's very flexible.
20:53:27 <Pegazus> <Pseudonym> In Haskell, you can do a lot with very little code, and it's easy to write, and it's very flexible. ---> i tell you the same about C++ :)
20:53:28 <wchogg> Pegazus:  That's a very illdefined statement.  You could say that about alot of things.
20:53:29 <Pseudonym> That's real power.
20:53:33 <araujo> Plus more free bugs :-]
20:53:34 <Pseudonym> No, I disagree.
20:53:36 <dons> meta programming is quite conceptually tricky. compile time is not as hard as multi-stagged runtime. but its still hard. so its not surprising that an accidental implementation would be weird/broken. the Pfenning (or was it Plotkin?) modal logic grounding for meta programming makes it clear
20:53:41 <Pseudonym> With C++ you don't have very little code.
20:53:55 <RyanT5000> pegazus: how do you do serialization with "very little code" in C++?
20:53:57 <Pegazus> <Pseudonym> With C++ you don't have very little code. --> yes, you have!
20:53:59 <RyanT5000> i would seriously love to know the answer to that
20:54:04 <araujo> dons, you know how to install a directory using Cabal by any chance?
20:54:09 <Pegazus> <RyanT5000> pegazus: how do you do serialization with "very little code" in C++? ---> boost::serialization isn't that bad :)
20:54:15 <RyanT5000> lol
20:54:16 <Pseudonym> Pegazus: I disagree!
20:54:19 <RyanT5000> yes, yes it is
20:54:20 <araujo> Pegazus, not less than with Haskell :-]
20:54:27 <newsham> write this in c++: http://lava.net/~newsham/x/machine/mand3.py
20:54:30 <Pseudonym> How much code do you use to set up a STL-compliant iterator?
20:54:38 <Pegazus> you just need to define the serializtion function
20:54:45 <RyanT5000> yes, pegazus
20:54:47 <dons> araujo, install a directory? hmm
20:54:47 <Pegazus> <Pseudonym> How much code do you use to set up a STL-compliant iterator? ---> like 5 lines?
20:54:50 <RyanT5000> that's O(n) code
20:54:51 <dons> nope. don't know.
20:55:00 <RyanT5000> where n is the number of classes
20:55:01 <Pseudonym> Pegzsus: They must be long lines.
20:55:02 <Pegazus> in fact i've done ton's of stl compilant iterators
20:55:06 <Pegazus> they don't
20:55:10 <Pegazus> boost::iterators
20:55:10 <araujo> dons, i mean, i got a directory full of images i want to install with the program
20:55:11 <Pegazus> :)
20:55:21 <Pseudonym> Yup, using boost.iterators.
20:55:24 <araujo> dons, though i don't know how to instruct Cabal to do that
20:55:25 <Pegazus> so?
20:55:26 <Pseudonym> OK, Pegazus, hang on.
20:55:30 <Pseudonym> I'll show you some of my code.
20:55:32 <dons> yeah, I pondered once how you'd install extras. let's see. maybe I can work it out...
20:55:34 <RyanT5000> actually it's O(n*m), where n is the number of classes and m is the number of variables per class
20:55:36 <mux> the number of lines of code it takes to do something in one language and another is quite irrelevant anyways, unless it goes to some extremes (asm)
20:55:41 <Pegazus> how much lines you'll need for doing something with haksell
20:55:43 <RyanT5000> in C# it's O(1)
20:55:43 <newsham> XDR?  NDR? ANS.1?  *ducks*
20:55:44 <Pegazus> if you couldn't use any library
20:55:45 <araujo> dons, can't find anything on the docs
20:55:47 <Pegazus> nor the prelude?
20:55:47 <mux> you don't waste time typing on your keyboard
20:55:49 <Pegazus> nor anything?
20:55:52 <RyanT5000> oh i'm sorry no it's O(n)
20:55:53 <mux> you waste time thinking about stuff
20:55:56 <RyanT5000> in C# and haskell
20:56:11 <mux> I so dislike comparisons based on the number of lines...
20:56:12 <moi_os> Is it a bad habit that whenever I see random code posted, I can't help but run it? 
20:56:22 <monochrom> I do not like the lack of type inference in C++.  Every time I write a for loop over an iterator it's like for(vector<map< XXX, list<YYY> > >::const_iterator i = ...) it's tiresome after a while.
20:56:35 <RyanT5000> heh mux that's why i'm talking about order of code :)
20:56:43 <RyanT5000> i don't mind typing twice as much code once
20:56:43 <Pegazus> <monochrom> ::next boost version
20:56:46 <Pegazus> you'll able to do
20:56:46 <Pseudonym> http://lambda-the-ultimate.org/node/608
20:56:50 <RyanT5000> i mind typing it every time i have to do something
20:56:53 <dons> araujo, you can always write a hook that installs the thing manually
20:56:55 <wchogg> mux:  I think it is a pretty bad metric unless you could somehow factor in readibility and the ease with which you can learn from code.
20:57:01 <Pegazus> BOOST_FOREACH(i, your thing) { the code here}
20:57:03 <Pseudonym> Pegazus, scroll down to my post.  (It's under the name "Pseudonym".)
20:57:03 <mux> wchogg: bingo
20:57:15 <RyanT5000> http://www.haskell.org/th/
20:57:32 <Pseudonym> The merge_iterator class is the equivalent of about 3 lines of Haskell, but it's something like 25 lines of C++
20:57:33 <monochrom> Not to mention the second-class status of the syntax of tuples and lists.
20:57:41 <Pegazus> merge_iterator?
20:57:43 <Pegazus> what does it do?
20:57:48 <Pseudonym> Take a look.
20:57:58 <araujo> dons, for example?
20:57:59 <Pseudonym> It basically does merge sort on two iterators.
20:58:01 <Pegazus> i do not know haskell
20:58:04 <Pegazus> merge sort?
20:58:06 <monochrom> So, sounds like BOOST is just Yet Another Haskell.
20:58:08 <Pseudonym> Yeah.
20:58:11 <RyanT5000> pegazus, i think you should learn haskell
20:58:20 <wchogg> CL is pretty verbose, but I actually find it easy to read.  Perl I think is the typical example of concise but hard to read.
20:58:21 <Pegazus> i've to
20:58:26 <Pegazus> that's why i'm here
20:58:26 <Pegazus> =P
20:58:28 <monochrom> But has BOOST got STM? XD
20:58:31 <RyanT5000> read a tutorial
20:58:37 <Pseudonym> It takes two iterators which output a sorted sequence, and outputs a merged sorted sequence.
20:58:37 <Pegazus> nah
20:58:40 <RyanT5000> then come back and argue with us :)
20:58:51 <RyanT5000> stop using "i don't know haskell" as an excuse
20:58:52 <Pegazus> Pseudonym: you can define a template
20:58:57 <monochrom> I think maybe next decade BOOST will also support monad and arrow notations.
20:58:57 <Pegazus> just once, and use it now and on
20:59:04 <Pseudonym> Bingo!
20:59:05 <RyanT5000> learn haskell, and figure out what you hate about it
20:59:07 <RyanT5000> and then come back and tell us
20:59:13 <Pegazus> i don't hate haskell
20:59:13 <Pseudonym> You're absolutely right, which is my main point.
20:59:17 <RyanT5000> and if we believe you that it's a problem, someone in here will change it
20:59:18 <Pegazus> i just like c++ more :)
20:59:23 <Pseudonym> It takes a lot of lines of code to write a good C++ library.
20:59:25 <RyanT5000> i didn't say you hated the whole thing
20:59:30 <Pseudonym> It doesn't take many to use it.
20:59:39 <Pegazus> <Pseudonym> It takes a lot of lines of code to write a good C++ library. --> but when you have written it you can use it now and forever
20:59:40 <Pegazus> :)
20:59:52 <RyanT5000> well that's true of any language
20:59:57 <monochrom> It takes a lot of lines of code to use a good C++ library.
21:00:00 <Pegazus> not really
21:00:08 <RyanT5000> ok any language that isn't crap
21:00:17 <Pegazus> c++ can make really customizable and extendable libraries
21:00:18 <RyanT5000> lots of languages have good library capabilities
21:00:21 <Pegazus> (haskell can too)
21:00:23 <Pegazus> but c++ can =P
21:00:34 <Pegazus> c++ has some of the best of the compiled languages
21:00:43 <monochrom> The type inference lackage problem I mentioned will be solved next year with BOOST.  But I have been doing that in SML since last century.
21:00:43 <Pseudonym> Pegazus, you said that it takes few lines of code to do stuff in C++.
21:00:48 <Pseudonym> That's what I took issue with.
21:01:01 <Pseudonym> It's untrue, because it takes a lot of lines of code to write a decent abstracted C++ library.
21:01:03 <wchogg> Pegazus:  I think people are mostly arguing with you because you've talked about how awesome c++ is, but haven't really narrowed it down to features that other languages don't have.
21:01:06 <RyanT5000> yeah i find C++ is very verbose and repetitive
21:01:09 <RyanT5000> that's why i hate it now :)
21:01:09 <Pseudonym> I'm not knocking C++, but it is verbose in that respect.
21:01:11 <newsham> that haskell merge looks less than ideal
21:01:13 <RyanT5000> DRY
21:01:14 <araujo> Functional languages tend to have better capabilities for extending libraries.
21:01:29 <Excedrin> I'm knocking C++, it sucks
21:01:40 <Pseudonym> BTW, I used to think C++ sucked too.
21:01:41 <newsham> why seperate cases for x == y and x < y ?
21:01:42 <monochrom> If C++ had type inference, I would actually agree it's tolerable.
21:01:46 <Pseudonym> Until I used it for something nontrivial.
21:02:03 <Pseudonym> Believe me, I know ALL the anti-C++ arguments well, because I used to make them.
21:02:28 <wchogg> I like c++ better than Java in alot ways.  I do think that it has alot of little gotchas though.
21:02:46 <araujo> That's why they use to tend a very small framework with a big amount of changeable parts, which is kind of the opposite thing in imperative ones.
21:03:02 <araujo> use to have*
21:03:06 <Pseudonym> Oh, I hate Java.
21:03:09 <Pseudonym> I used to like it.
21:03:20 <Pseudonym> And then I realised that multi-paradigm programming was far, far better.
21:03:23 <newsham> cant you just splitwhile <= head of the first list, then recurse with the two lists swapped?
21:03:28 <RyanT5000> imo, the 2 biggest problems with C++ are that it doesn't have good metaprogramming (compile-time OR runtime), and it has mutable variables
21:03:35 <Pseudonym> I used to have to shoehorn my thinking into Java.
21:03:35 <lisppaste2> Lokadin pasted "h4sh-0.2.ebuild" at http://paste.lisp.org/display/18714
21:03:46 <RyanT5000> i have nothing good to say about java
21:03:47 <Pseudonym> With C++ and Haskell, I can mold my program to my thinking.
21:03:48 <Lokadin> oops
21:03:52 <RyanT5000> oh wait yes i do
21:03:54 <Lokadin> wrong channel
21:04:08 <RyanT5000> it has a huge library, so if you're trying to whip up something that they've already solved for you
21:04:09 <RyanT5000> then it's good
21:04:11 <Excedrin> multi-paradigm programming is a made up C++ term
21:04:17 <wchogg> Pseudonym:  I think of Java as the overprotective mother of imperitive languages:  it makes you play nice, bundle up, and wear a helment even when you're not riding a bike.
21:04:31 <monochrom> OH! I suppose your IDE for C++ does type inference and fills in type declarations for you, that's why you don't feel my agony towards the verbose type signiture problem.
21:04:39 <moi_os> I thought the biggest problem with C++ was that it's ugly
21:04:43 <Pseudonym> Excedrin: Perhaps.  And I do think that James Coplien is one of the strongest arguments against C++. :-)
21:04:50 <Pseudonym> But I digress.
21:05:01 <Pseudonym> Multi-paradigm programming is a good idea, and Haskell does it.
21:05:13 <Pseudonym> Haskell even does imperative programming.
21:05:21 <Excedrin> so does Lisp, Scheme, C, Python, ....
21:05:24 <Pegazus> <Pseudonym> It's untrue, because it takes a lot of lines of code to write a decent abstracted C++ library. --> it doesn't if you have enought abstracted C++ library already
21:05:26 <moi_os> wchogg: I like that. 
21:05:28 <Pseudonym> And logic programming, which C++ can't really do.
21:05:35 <Pseudonym> Not nicely, anyway.
21:05:46 * araujo wonders where dons is
21:05:53 <RyanT5000> i think variables are a negative in a language
21:06:03 <Pseudonym> Pegazus: Well duh.  It takes few lines of Java to do anything if you already have a library.
21:06:08 <monochrom> When C++ or BOOST or whatever supports monad and arrow notations, I'll reconsider it.
21:06:09 <Pseudonym> Ditto with Perl.
21:06:14 <wchogg> Psuedonym:  How does haskell support multiparadigm programming?  I know you can do imperative stuff via monads, but what about the object oriented way of doing things?
21:06:26 <Pegazus> monad and arrow notations what's that?
21:06:30 <RyanT5000> monochrom: there's no point to that in C++
21:06:32 <Pseudonym> wchogg: Multi-paradigm doesn't mean omni-paradigm.
21:06:33 <monochrom> LEARN HASKELL
21:06:37 <RyanT5000> even if *you're* using them
21:06:49 <Pegazus> i told you ll learn soon
21:06:50 <wchogg> Pseudonym:  Okay, so you weren't claiming *everything*.  Gotcha.
21:06:50 <RyanT5000> the library, or something else, could be using global/static variables
21:06:51 <monochrom> monad and arrow notations are really nice
21:06:51 <dons> OO stuff s harder, but can be faked with existentials and type classes, to some extend
21:06:54 <Pegazus> (by monday i should know some)
21:07:09 <RyanT5000> in which case your monadic stuff is making invalid assumptions
21:07:10 <Pseudonym> There's only one thing that Haskell can't really simulate from OO, and that's dynamic upcasting,.
21:07:13 <dons> but why would you do it? closures are much nicer objects
21:07:33 <Pseudonym> Sorry, downcasting.
21:07:36 <monochrom> (I think I can get away with asserting "really nice" without justification, since everyone is doing that already.)
21:07:40 <Pseudonym> dynamic_cast in C++
21:07:40 <wchogg> dons:  What do you mean by closures in this sense?  I've seen people use it in a few different ways.
21:08:15 <RyanT5000> hm that's a good point pseudonym
21:08:53 <dons> closures, i.e. the things haskell values are underneath. roughly the same representation as a Java object, but with more magical powers
21:09:00 <Pseudonym> In fact, what you really want is extensible data types.
21:09:07 <Pseudonym> Which has been on the wish list for a long time.
21:09:25 <Pseudonym> I think we're waiting on a nice theory for it.
21:09:44 <dons> yeah. extensible data types are the thing we don't know how to do cleanly yet.
21:09:52 <dons> you can get them via the 'open' type class system
21:09:54 <dons> but its a lot of syntax
21:10:00 <Pseudonym> Right.
21:10:13 <dons> since you have to hoist all your data and intro/elim forms onto the typeclass level
21:10:24 <Pseudonym> Philippa's supertypes idea has the most promise, I think.
21:10:28 <Pseudonym> So if you want it, bug her. :-)
21:10:39 <dons> we'll probably get a break through and some nice notation, as we did with monads
21:10:50 <Pegazus> do you know co induction?
21:10:59 <monochrom> I believe I do.
21:11:08 <Pseudonym> This, BTW, is one of Haskell's REAL strengths.
21:11:17 <Pseudonym> It isn't willing to sell out.
21:11:29 <Pseudonym> If a feature doesn't have a nice theory, Haskell doesn't get the feature.
21:11:39 <RyanT5000> yeah, which is awesome
21:11:45 <Pegazus> what's coinduction?
21:11:51 <Pegazus> where can i get a nice introduction explanation etc...?
21:12:04 <RyanT5000> @google coinduction
21:12:06 <lambdabot> http://www-cse.ucsd.edu/groups/tatami/handdemos/doc/coind.htm
21:12:14 <RyanT5000> try that
21:12:40 <dons> unlike just about every other language. and most popular ones. that add features as they work out the details
21:12:40 <Pegazus> i didn't get a thing
21:12:56 <Pegazus> hidden equations? O_o what's that?
21:13:07 <newsham> most other languages dont work hard to formally define semantics.
21:14:34 <newsham> so nothing is lost by adding a new feature with poorly defined semantics
21:15:00 <dons> things just become slowly more cluttered and unsteady
21:15:08 <dons> or quickly, depending on the language
21:15:36 <dons> it should be a slogan: "Haskell, the language that won't sell out"
21:15:55 <wchogg> Haskell has indie-street cred?
21:16:02 <RyanT5000> lol :)
21:16:09 <RyanT5000> that's damn right
21:16:32 <dons> and "Haskell, 100% free, and kick ass"
21:16:53 <RyanT5000> 100% free and 100% kickass ;)
21:16:55 <wchogg> Yeah, and when Haskell.NET is in version 5 in 10 years, we can all say "I liked Haskell back when it was underground."
21:17:10 <RyanT5000> so true
21:17:24 <Pseudonym> Haskell's only real problem in this respect is that the syntax, particularly the lexical syntax, is getting a bit crowded.
21:17:45 <monochrom> Some articles by Bart Jacobs are on coinduction.
21:17:48 <Pseudonym> But when you talk about a new language feature, it's always the syntax that you argue about.
21:17:56 <RyanT5000> some day we'll all pull out our GHC 6.5 on dusty old vinyls, and try to figure out how to install it on our new 128-bit machines
21:17:57 <wchogg> Just like how my father loved C# back ten years ago when it was called Delphi...
21:18:09 <dons> I am always amazed that  the community spent the first 4 or so years just talking about the syntax. that was a real effort that payed off
21:18:14 <Pseudonym> I liked Delphi when it was called Algol.
21:18:19 <wchogg> Oh snap!
21:18:20 <Pseudonym> Actually, no I didn't.
21:18:39 <Pseudonym> I did like Delphi when it was called Turbo Pascal, though.
21:19:02 <Pseudonym> This is back in the day when Borland produced software tools instead of management jargon.
21:19:20 <wchogg> So is anyone here actually old enough or indie enough to have programmed in the original algol?
21:19:34 * RyanT5000 cries; wishes he had a multiprocessor/core machine
21:19:43 <RyanT5000> or linux
21:19:56 <RyanT5000> i don't understand how it's possible for windows' scheduler to be so bad
21:20:14 <RyanT5000> i set make to Low priority
21:20:25 <RyanT5000> i set my editor to Above Normal priority
21:20:43 <RyanT5000> and yet i still get interrupted for half a second every 10
21:20:58 <RyanT5000> >:-(
21:21:37 <Pseudonym> You need to edit the registry.  Set the "performance" key from "absolute crap" to "pretty good".
21:21:46 <RyanT5000> lol
21:21:56 <RyanT5000> you know, there may very well be a key for that
21:22:00 <Pseudonym> This is all in the windows source, available from a P2P server near you.
21:22:14 <RyanT5000> yeah... i tried to get that when it was going around
21:22:15 <jcreigh> HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\Suckage
21:22:19 <RyanT5000> it was effectively impossible
21:22:24 <Pegazus> hey what was the meanning off ::
21:22:29 <Pegazus> i don't recall correctly
21:22:36 <Pseudonym> expression :: type
21:22:43 <RyanT5000> a :: b means "a is of type b"
21:22:44 <Pegazus> thanks
21:23:14 <monochrom> I have programmed in Dijkstra's guarded command language.  I suppose that's close enough to Algol.
21:24:13 <RyanT5000> gah; i can't use this at all; could somone give me an idea of how long it takes to compile all of GHC?
21:24:55 <wchogg> Err...last night it took an hour to compile ghc on my 1.86GHz laptop
21:25:11 <RyanT5000> alright thanks
21:25:11 <newsham> shorter if you use the binary package
21:25:22 <RyanT5000> is there a binary package for windows of 6.5?
21:25:26 <Pegazus> another question
21:25:38 <dons> they''re built nightly, I think.
21:25:48 <dons> check the nightly snapshot page on haskell.org/ghc
21:25:56 <RyanT5000> i only saw linux builds and source
21:26:12 <dons> you might have to scoll back a bit to find the mingw builds
21:26:16 <Pegazus> flip :: (a -> b -> c) -> b -> a -> c  nextline:  (((flip f) x) y) = f y x    what does this function does'
21:26:56 <RyanT5000> ...
21:27:20 <dons> scroll?
21:27:35 <dons> do I have to go and look myself ? ;)
21:27:37 <RyanT5000> no, just blank stare
21:27:55 <RyanT5000> f takes a function of a and b, and returns a function of b and a
21:28:12 <newsham> > flip (\x y -> x-y) 5 3
21:28:13 <lambdabot> -2
21:28:18 <Pegazus> (a -> b -> c) means a function taking and a and a b and returning a c right?
21:28:23 <dons> http://www.haskell.org/ghc/dist/current/dist/ghc-6.5.20060328-i386-unknown-mingw32.tar.gz
21:28:29 <dons> http://www.haskell.org/ghc/dist/current/dist/
21:28:32 <dons> :}
21:28:43 <newsham> > (\x y -> x-y) 5 3
21:28:44 <lambdabot> 2
21:29:07 <RyanT5000> why would it be defined like that though?
21:29:15 <Pegazus> i'm just reading notes from a friend
21:29:16 <Pegazus> :)
21:29:28 <RyanT5000> sorry dons i wasnt' responding to you :)
21:29:28 <dons> mm. lunch time. gotta remember to eat lunch when the music's on and the haskell's flowing.
21:29:29 <RyanT5000> thanks though
21:29:50 <Pegazus> (((flip f) x) y) = f y x    ; is this right? all those ()() around flip? does it works if i remove it?
21:29:54 <monochrom> "flip f" takes arguments in the reverse order (this description is accurate for two arguments only)
21:30:08 <RyanT5000> yeah i think those parens are unnecessary
21:30:16 <Pegazus> but does it works with those paraens?
21:30:20 <Pegazus> i mean are they optional?
21:30:23 <monochrom> Yes
21:30:25 <Pegazus> they are "bad" or they are good?
21:30:29 <Pegazus> yes wich one? :)
21:30:35 <RyanT5000> they make it look like hell
21:30:40 <RyanT5000> and they dont' do anything
21:30:40 <monochrom> bad.  flip f x y = f y x
21:30:43 <monochrom> err
21:30:49 <Pegazus> bad what?
21:30:58 <monochrom> I mean "flip f x y = f y x" is good.
21:31:01 <Pegazus> k
21:31:04 <RyanT5000> is it possible to define flip point-free?
21:31:14 <Pegazus> what means point free?
21:31:20 <RyanT5000> don't worry about it
21:31:27 <Pegazus> i do worry :) i want ot know tell me
21:31:41 <Pegazus> thanks guys, i've just understood the function :)
21:31:42 <RyanT5000> i think you should read a tutorial, pegazus
21:31:45 <newsham> f x = 3 + x       === point free ===>    f = (3 +)
21:31:50 <monochrom> @pl \f x y -> f y x
21:31:51 <lambdabot> flip
21:31:51 <Pegazus> i know some haskell
21:31:54 <Pegazus> very basic
21:31:59 <Pegazus> but the very basic i do know it :)
21:32:05 <Pegazus> (very very very basic :p))
21:32:08 <monochrom> No, it seems impossible to define flip pointfree without having flip first.
21:32:30 <Pegazus> what the hell means "point free"?
21:32:32 <Pegazus> O_o
21:32:35 <newsham> f x = 3 + x       === point free ===>    f = (3 +)
21:32:41 <Pegazus> i still don't get it
21:32:56 <RyanT5000> it means instead of taking a function and a variable
21:32:59 <RyanT5000> you're just taking a function
21:33:01 <Pegazus> f = (3 +) means that f whateve you put here = (3 + ) whatever you put here?
21:33:02 <RyanT5000> and returning a new function
21:33:16 <Pegazus> and what are valid functions?
21:33:19 <monochrom> Unix pipelines are pointfree.
21:33:21 <magnus--> Haskell Go bot author here?
21:33:25 <Pegazus> g = (+ g) //is this valid?
21:33:29 <Pegazus> sorry
21:33:31 <Pegazus> g = (+ 3) //is this valid?
21:33:35 <newsham> yes
21:33:40 <RyanT5000> yes
21:33:41 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html
21:33:47 <Pegazus> mmm thanks
21:33:50 <Pegazus> i think i got it
21:33:56 <newsham> > map (- 3) [1,5,10]
21:33:56 <lambdabot>  add an instance declaration for (Num (a -> b))
21:33:57 <Pegazus> and why point free? i don't see the point anywhere
21:34:06 <RyanT5000> hey i got it *slightly* freeer of points :P
21:34:13 <Pegazus> <newsham> > map (- 3) [1,5,10] --> whats map for?
21:34:15 <Pegazus> what does it do?
21:34:20 <RyanT5000> flip f x = (`f` x)
21:34:34 <gzl> Pegazus: map f list applies f to every element of list.
21:34:39 <bojohan> newsham: that particular one doesn't work, though
21:34:42 <Pegazus> thanks
21:34:48 <araujo> Pegazus, it maps each value of the list as an argument of the function (- 3)
21:34:52 <gzl> > map (+1) [1..5]
21:34:53 <lambdabot> [2,3,4,5,6]
21:34:53 <newsham> > map (- 3) [1,5,10] :: [Int]
21:34:54 <lambdabot>  add an instance declaration for (Num (a -> Int))
21:34:55 <Pegazus> so map (- 3) [1,5,10] = [-2, 2, 7]
21:34:56 <Pegazus> ?
21:34:56 <newsham> heh
21:35:04 <Pseudonym> "Point-free" is also somethimes known as "pointless".
21:35:10 <Pegazus> O_o
21:35:26 <Pseudonym> Point-free code is easier to refactor, because there are no variables that you might have to rename.
21:35:27 <RyanT5000> yah :)
21:35:44 <magnus--> and it's really hard to read as a bonus :P
21:35:47 <Pseudonym> But it's sometimes harder to read and/or write.
21:35:55 <araujo> > map (+ (-3)) [1,5,10]
21:35:56 <lambdabot> [-2,2,7]
21:36:01 <Pegazus> so map f list is equal to { x <- list; f x} or something like this?
21:36:14 <Pseudonym> [ f x | x <- list ]
21:36:18 <Pegazus> thanks
21:36:18 <newsham> fac n = product [1..n]     ==== points free ====>   fac = foldr (*) 1 . enumFromTo 1
21:36:26 <newsham> (http://www.willamette.edu/~fruehr/haskell/evolution.html)
21:36:46 <moi_os> what about map (\x -> x - 3) [1,5,10] ?
21:36:46 <Pegazus> (+ (-3))   -3 there is a function or a constant?
21:36:52 <rasfar> @type `map`
21:36:53 <lambdabot> parse error on input ``'
21:37:01 <rasfar> @type flip map
21:37:01 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
21:37:05 <RyanT5000> dons: can i transplant my entire library system from one GHC install to another?
21:37:06 <Pseudonym> There is a subculture within Haskell that seems to just _adore_ point-free programming.
21:37:23 <Pseudonym> I personally don't get it.  Sometimes it's appropriate, sometimes not.
21:37:26 <RyanT5000> point-free programming sounds like fun to me
21:37:29 <RyanT5000> but not always useful
21:37:35 <araujo> Setup.hs: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly
21:37:41 <araujo> anybody would know what that error means?
21:37:44 <newsham> the most points wins
21:37:46 <Pseudonym> I'm from the software engineering school of "if it's important, give it a name".
21:37:54 <araujo> when doing "runhaskell Setup.hs configure"
21:39:15 <araujo> @type (-3)
21:39:16 <lambdabot> forall a. (Num a) => a
21:39:37 <dons> I like pointfree, but only since I've been using lambdabot to do it for me :)
21:39:47 <dons> !!pl is my friend.
21:39:58 <newsham> > concat (map (\a -> map (\b -> (a,b)) "abc") "XY")
21:39:59 <lambdabot> [('X','a'),('X','b'),('X','c'),('Y','a'),('Y','b'),('Y','c')]
21:40:12 <monochrom> I like pointfree when I'm expressing a pipeline.
21:40:15 <Pseudonym> @pl concat (map (\a -> map (\b -> (a,b)) "abc") "XY")
21:40:15 <lambdabot> flip map "abc" . (,) =<< "XY"
21:40:26 <moi_os> > map (\x -> x-3) [1,5,10]
21:40:27 <lambdabot> [-2,2,7]
21:40:29 <Pegazus> what does ?2a means?
21:40:30 <moi_os> Ooh, cool
21:40:37 <Pegazus> \a
21:40:42 <newsham> > do { x <- "abc"; y <- "XY"; return (x,y) }
21:40:42 <lambdabot> [('a','X'),('a','Y'),('b','X'),('b','Y'),('c','X'),('c','Y')]
21:40:51 <RyanT5000> is the conversion to pointfree solvable?
21:40:59 <newsham> > [(a,b) | x <- "abc", y <- "XY"]
21:41:00 <lambdabot>  Not in scope: `b'
21:41:10 <RyanT5000> (in all cases where there is a point-free solution)
21:41:10 <newsham> > [(x,y) | x <- "abc", y <- "XY"]
21:41:10 <lambdabot> [('a','X'),('a','Y'),('b','X'),('b','Y'),('c','X'),('c','Y')]
21:41:13 <Pseudonym> Yes, in the sense that lambda calculus can be converted to supercombinators.
21:41:25 <Pseudonym> However, Haskell doesn't have a good primitive for the S combinator.
21:41:36 <Pseudonym> @pl (\f g x -> f x (g x))
21:41:36 <lambdabot> ap
21:41:41 <RyanT5000> what is a supercombinator? (don't bother if it's too complicated to explain quickly)
21:41:44 <Pseudonym> "ap" isn't standard Haskell.
21:41:45 <monochrom> Of course I name my pipelines too.  spam = length . nub . sort . filter (isPrefixOf "X-Spam-Level")
21:42:06 <Pseudonym> Ryan, a combinator is basically a function which rearranges its arguments.
21:42:08 <monochrom> (The parameter is unimportant, don't name it!)
21:42:14 <Pseudonym> e.g. (.) f g x = f (g x)
21:42:36 <RyanT5000> ok
21:42:56 <Pseudonym> A supercombinator is a combinator all of whose subexpressions are also (super)combinators.
21:42:58 <RyanT5000> yeah i've read about combinators
21:42:59 <Pseudonym> So, for example:
21:43:11 <Pseudonym> f x y z = x (\w -> y w) z
21:43:18 <Pseudonym> That's a combinator, but it's not a supercombinator.
21:43:24 <Pseudonym> Because it has a lambda expression internally.
21:43:31 <Pseudonym> It can be converted into one, though:
21:43:40 <Pseudonym> f x y z = x (flip id y) z
21:43:56 <Pseudonym> flip and id are supercombinators.
21:44:02 <Pseudonym> Oh, hang on.
21:44:05 <Pseudonym> f x y z = x y z
21:44:10 <Pseudonym> That's it.
21:44:12 <Pseudonym> Duh.
21:44:14 <Pegazus> does this make sense: filter :: (    ) -> [a] -> [a] ???
21:44:22 <Pseudonym> @type filter
21:44:23 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:44:25 <RyanT5000> ok thanks pseudonym :)
21:44:50 <Pegazus> thanks
21:45:36 <Pegazus> @type foldr
21:45:36 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
21:46:28 <RyanT5000> what do you put for the "portability" field of a module if it's not platform-specific?
21:46:31 <araujo> dons, didn't find anything?
21:47:03 <Pegazus> is there any command for the bot
21:47:08 <Pegazus> to show me the definition of foldr?
21:47:26 <RyanT5000> (i'm just asking if there's some cannonical thing you'd put)
21:48:01 <jcreigh> Pegazus: http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
21:49:06 <RyanT5000> hm, i have a design question, which i'm not sure is haskell specific because i'm not sure i could give a satisfactory answer for any other language, but here it is:
21:49:19 <RyanT5000> let's say i have Board and Pawn
21:49:38 <RyanT5000> a board is a 2d array of Maybe Pawn
21:49:53 <Pegazus> can you give me an example on what foldr can be used for?
21:50:05 <Pseudonym> concat = foldr (++) []
21:50:06 <RyanT5000> sum = foldr (+)
21:50:13 <Pegazus> thanks
21:50:16 <Pseudonym> Actually, sum = foldl (+) 0
21:50:19 <Pseudonym> Not foldr.
21:50:20 <RyanT5000> oh yeah sory :P
21:50:35 <RyanT5000> you can foldr sum too!
21:50:39 <RyanT5000> right?
21:50:46 <Pseudonym> Yes, but it's probably less efficient.
21:50:48 <RyanT5000> yeah
21:51:18 <moi_os> Does anyone else find a line like: "mul :: Int -> Int -> Int" just slighly strange? 
21:51:43 <Pegazus> why's that?
21:51:47 <RyanT5000> anyway let's say i want a function render :: Skin -> Board -> IO ()
21:52:45 <Pseudonym> moi_os: Yes I do.  Why isn't that in a typeclass?!
21:52:58 <RyanT5000> i don't think i'm being very clear, though; does anyone have any idea what i'm asking?
21:53:14 <RyanT5000> Skin would be something that changes the way each type of thing is rendered
21:53:22 <Pseudonym> Ryan: No, you haven't actually asked a question yet.
21:53:33 <RyanT5000> yeah sorry i'm really incoherent
21:53:35 <Pseudonym> I understood the background, though.
21:53:40 * Pseudonym assumed you were building up to it
21:53:43 <RyanT5000> i was
21:53:54 <RyanT5000> i lost track of my train of thought though :-/
21:54:09 <RyanT5000> so the question is, how do you define Skin?
21:54:11 <RyanT5000> basically
21:54:16 <RyanT5000> i was at first thinking
21:54:21 <RyanT5000> have a class Renderable
21:54:29 <RyanT5000> which Board implements
21:54:36 <RyanT5000> but you can't implement a class twice can you?
21:54:39 <RyanT5000> that wouldn't even make sense
21:54:46 <RyanT5000> you'd have to implement it once for each skin
21:55:12 <RyanT5000> so anyway my question is: how do you design the skinning, if you want to have a render function like that
21:55:44 <RyanT5000> and actually i think more specifically it would be something like render :: (Skin a, Renderable b) a -> b -> IO ()
21:56:58 <RyanT5000> i think i'm kind of looking for "dynamic" dispatch based on types a and b
21:57:04 <RyanT5000> only it's reallly static dispatch
21:57:51 <Pseudonym> So what would the code for render look like?
21:58:58 <RyanT5000> well, i don't know HOpenGL well enough to just write it off the top of my head yet, but the "default skin" would do something like draw a black-and-white checkerboard , then call render on all the pawns that were present
21:59:15 <RyanT5000> before each sub-render call it would translate and scale appropriately
21:59:19 <Pseudonym> Right.
21:59:34 <Pseudonym> Hmmm.
21:59:54 <RyanT5000> although... maybe this is misguided
22:00:01 <Pseudonym> Perhaps, yes.
22:00:16 <RyanT5000> becuase if you are calling render from a skin, you know what skin you're calling it from
22:00:17 <Pseudonym> Are the pawns and the board separate skins?
22:00:35 <RyanT5000> right, i don't think they should be
22:00:39 <Pseudonym> Can they have separate skins?
22:00:58 <RyanT5000> hm... maybe
22:01:23 <RyanT5000> i'm not sure i know what that'd mean though
22:01:41 <RyanT5000> obviously they have to be the same skin in some respects, but they could certainly have different parameters of the skin
22:01:42 <Pseudonym> http://www.haskell.org/hawiki/TraitsTypeclass
22:01:49 <Pseudonym> That may or may not help.
22:01:58 <RyanT5000> thanks regardless :)
22:02:22 <Pseudonym> The last example may help especially.
22:03:09 <RyanT5000> huh, this stings of C++ template programming :P
22:03:38 <Pseudonym> Yup.
22:03:48 <Pseudonym> So it should be nice and familiar.
22:04:02 <RyanT5000> yeah, but you have to understand i'm running like a madman from C++ :P
22:04:13 <RyanT5000> it looks right though
22:04:50 <RyanT5000> i guess really a skin should be a Render function, and it might also have some sort of mapping (using traits) from type to data for that type
22:05:26 <Pseudonym> Let me put it this way.
22:05:28 <Smokey`> run from C++,  pffft.  <3 C++ :)
22:05:45 <Pseudonym> C++ makes your Haskell programming better, and Haskell makes your C++ programming better.
22:05:55 <RyanT5000> heh i loved C++ for like 7 years
22:05:55 <Pseudonym> Admittedly, the latter is more generally true than the former.
22:05:55 <Smokey`> I concur, 110%
22:06:10 <Smokey`> Pseudonym: I agree completely :)
22:06:15 <Pseudonym> But even so, the C++ heads have developed a lot of very cool tools.
22:06:26 <Pseudonym> And you'd be mad not to at least look at them.
22:06:27 <RyanT5000> yeah, i have a lot of respect for it
22:06:39 <Pseudonym> Traits classes are but one example.
22:06:42 <dons> it was C++ templates that pushed TH forward, no?
22:06:53 <RyanT5000> tbh, the biggest problem i have with it is that it is almost impossible to use "Don't Repeat Yourself" rigorously
22:06:57 <Pseudonym> Haskell already used them before I coined the term "traits typeclass", after all.
22:07:20 <RyanT5000> and i've found that lack of DRY (WET?) is the biggest cause of temporary bugs in my code
22:07:31 <newsham> dons: TH seems more like lisp macros to me
22:07:38 <RyanT5000> by temporary, i mean "i'll definitely find them eventually"
22:07:44 <newsham> set_text(str(row[0]))
22:08:04 <newsham> oops
22:08:09 <RyanT5000> for instance, i was writing some serialization stuff in C++
22:08:10 <dons> it just seems that in the TH papers they talk much about how C++ templates being a functional language, and how it changed C++ forever, was a big reason to work on TH
22:08:21 <RyanT5000> and it was really robust and stuff; i supported upversioning and everything
22:08:40 <RyanT5000> but about once in 10 times that i changed my datastructure, i didn't update the serialization quite right
22:11:02 <RyanT5000> and then i'd spend like an hour looking for my error
22:11:10 <newsham> c++ templates dont provide you with access to the syntax trees 
22:11:15 <RyanT5000> right
22:11:17 <newsham> lisp macros and TH do
22:11:22 <RyanT5000> it's infuriating!
22:11:35 <RyanT5000> TH is what made me fully embrace Haskell
22:12:01 <RyanT5000> even if haskell pisses me off some time, i can probably fix it
22:12:02 <newsham> although lisp syntax trees are much simpler :)
22:12:07 <RyanT5000> yeah
22:12:25 <Smokey`> what does TH stand for?
22:12:28 <RyanT5000> template haskell
22:12:46 <RyanT5000> basically it adds $( ) and [| |] to the language
22:12:57 <RyanT5000> the former being "evaluate this ExpQ at compile-time"
22:13:04 <Smokey`> ahh, sweet.
22:13:09 <RyanT5000> the latter being "take this haskell code and return it as an ExpQ"
22:13:28 <RyanT5000> and ExpQ is a monad which includes the IO monad
22:13:45 <newsham> with the ability to process syntax trees of the parameters
22:13:56 <RyanT5000> so you can actually ask for interactive information during compile :)
22:14:06 <RyanT5000> which is really sexy, but i can only think of one use for it
22:14:24 <RyanT5000> which is if you want some kind of signature stored in the executable
22:14:32 <dons> yep. you can run arbitrary haskell code inside the compiler to operate and tweak the syntax tree.
22:14:34 <RyanT5000> and you don't want to store it in the plain on your compilation server
22:14:45 <RyanT5000> hm...
22:14:47 <newsham> "interactive information" is deceptive.
22:14:58 <RyanT5000> how so?
22:15:09 <dons> so, write your own optimisations. generate your own code. and so on
22:15:13 <Smokey`> okay, hell of a way to confuse me, but i'm sure i'll get there soon enough :)
22:15:31 <ncalexan> dons: did you ever explore the hs-plugins Mac OS X linking problems?
22:15:33 <RyanT5000> lol yeah one of their examples replaces all the + with - and all the - with + in some code
22:15:52 <RyanT5000> you could write some ridiculous obfuscated code with TH
22:16:26 <newsham> ryan: you cant dynamically call things.  for example, if I have an argument that is a "foo", and I know its in a class that has a "sizeOf" function, I cant invoke the sizeOf x at compile time and use that as part of the compile-time manipulations
22:16:37 <dons> yes. the winner of the 3rd obfuscated haskell contest used TH
22:16:38 <newsham> I ran up against this when I was trying to generate marshalling code :(
22:16:52 <newsham> dons: preprocessor to obfuscate code seems like cheating
22:16:57 <dons> it's on my todo list newsham, but i haven't had access to a mac recently
22:17:12 <dons> well, it's in the compiler, so not exactly _pre_ processing ;)0
22:17:15 <RyanT5000> newsham: you can do that, just not within a single module, unless i'm misunderstanding you
22:17:32 <dons> ?wiki Obfuscation
22:17:32 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
22:17:39 <RyanT5000> and it's also on the bugs list
22:17:46 <RyanT5000> well, the "not yet supported" list
22:18:04 <RyanT5000> so the TH stuff in one module can't refer to the product of that module
22:18:22 <RyanT5000> and i can understand why
22:18:30 <dons> it's hard to stage it correctly
22:18:36 <RyanT5000> f = $(g) ; g = $(f)
22:18:40 <dons> to splice code into code that you are currently compiling
22:18:47 <RyanT5000> yah :)
22:19:07 <newsham> *nod*  I can understand why its difficult, but its a limitation none-the-less.
22:19:25 <newsham> when I want to do something, and I cant do it, I rarely care why :)
22:19:31 <dons> well. there's no law against writing another module 
22:19:35 <RyanT5000> well can't  you just make more modules?
22:19:37 <dons> wihch is what you do
22:19:43 <RyanT5000> can you make more modules in one file?
22:19:50 <RyanT5000> then import them all from the main module in that file
22:20:15 <dons> nope. you need 1 module per file
22:20:26 <RyanT5000> is there any reason for that restriction?
22:20:40 <RyanT5000> oh i guess finding modules would be really hard
22:21:02 <RyanT5000> how about submodules with static linkage
22:21:08 <dons> and modules aren't really like classes in Java or anything. so its not so much of a restrictoin. it only comes up with this TH issue
22:21:14 <RyanT5000> right
22:21:26 <dons> imagine being able to only define 1 data type per file. that would be bad 
22:21:34 <RyanT5000> lol yeah
22:21:42 <RyanT5000> although java classes are huge
22:22:00 <dons> yeah, like a type decl and all instances and anything that operates on it
22:22:10 <RyanT5000> true
22:24:29 <RyanT5000> hm
22:24:34 <RyanT5000> i just got the following error
22:24:54 <RyanT5000> oh nvm
22:24:58 <RyanT5000> it was just cached or something
22:25:29 <RyanT5000> oh wait yeah it was real
22:26:09 <RyanT5000> "Failed to load interface for `Graphics.Rendering.OpenGL': Bad interface file ... Something is amiss; requested module name ... differs from name found in interface file
22:26:16 <RyanT5000> (i hate when i can't copy and paste things)
22:26:25 <RyanT5000> is it possible that's just because it's 6.5?
22:26:33 <RyanT5000> and unstable
22:26:51 <dons> no. that's something weird
22:27:09 <RyanT5000> alright welll let me investigate it further
22:27:11 <dons> I've never seen a "Something is amiss" before
22:27:19 <RyanT5000> i have been messing around with my packages
22:27:21 <dons> you might need an earlier snapshot
22:28:19 <Smokey`> <3 ambiguous compiler errors... always fun
22:30:27 <RyanT5000> i think it might be a foible of visual haskell
22:30:52 <mwc> Is there any reason to think of Arrow transformers?
22:30:53 <RyanT5000> i think it might be reporting that error, but another error is causing my build to fail (which it isn't reporting)
22:30:57 <mwc> I'm playing around with the concept
22:31:07 <dons> hmm, what's this. I'm a bit sleepy. It looks like something:
22:31:08 <dons>         pipeline [] a = a
22:31:08 <dons>         pipeline (f:fs) a = pipeline fs $ f a 
22:31:45 <dons> ?pl pipeline (f:fs) a = pipeline fs (f a)
22:31:45 <lambdabot> pipeline = fix ((`ap` tail) . (. head) . flip . ((.) .))
22:31:48 <dons> hmm
22:32:02 <dons> fix and .
22:32:13 <RyanT5000> ?where Int32
22:32:14 <lambdabot> I know nothing about int32.
22:32:20 <RyanT5000> @index Int32
22:32:20 <lambdabot> Data.Int, Foreign
22:32:24 <dons> ?index Int32
22:32:25 <lambdabot> Data.Int, Foreign
22:32:26 <dons> yup
22:32:34 <RyanT5000> is there a difference between @ and ?
22:32:36 <RyanT5000> ?
22:32:38 <dons> where is a url db
22:32:41 <dons> no diff
22:32:50 <dons> i find it more intuitive
22:32:55 <RyanT5000> right
22:33:02 <RyanT5000> it seems pretty regular which people use
22:33:07 <dons> other seem to have @ burnt into their spinal memory
22:33:28 <Korollary> @yeahyeah
22:33:28 <lambdabot> Unknown command, try @list
22:33:37 <RyanT5000> @list
22:33:38 <lambdabot> list [module|command]. Where modules is one of:
22:33:38 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
22:33:38 <lambdabot> unlambda version vixen where
22:36:28 <dons> ?version
22:36:28 <lambdabot> lambdabot 3p400, GHC 6.4.1 (Linux i686 3.20GHz)
22:36:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:36:31 <dons> bot?
22:36:34 <dons> hmm. why so slow?
22:36:44 <dons> 400 patches though. /me is happy
22:38:59 <Korollary> @djinn was :: b -> a
22:38:59 <lambdabot> Cannot parse command
22:39:29 <dons> ?djinn b -> a
22:39:29 <lambdabot> -- f cannot be realized.
22:41:16 <araujo> http://www.haskell.org/~luisfaraujo/rhimerge.jpeg
22:41:34 <araujo> just uploaded, testers welcome ;-)
22:41:58 <dons> how can you test a jpeg?
22:42:08 <dons> oooooooh!
22:42:33 <dons> ?karma+ araujo
22:42:33 <lambdabot> araujo's karma raised to 4.
22:42:37 <dons> very nice
22:42:41 <araujo> :-)
22:43:00 <araujo> ooh, sorry
22:43:10 <araujo> http://www.haskell.org/~luisfaraujo/himerge
22:43:17 <dons> ?where+ himerge http://www.haskell.org/~luisfaraujo/himerge/
22:43:18 <lambdabot> Done.
22:43:25 <araujo> :-]
22:43:38 <araujo> still need some work, but it is very functional now
22:43:48 <dons> do you have a description somewhere, I'll mention it on the new wiki.
22:44:14 <dons> "Haskell Graphical User Interface for Emerge"'
22:44:15 <dons> :)
22:44:17 <araujo> dons, oh, im uploading one right now
22:44:21 <araujo> :-]
22:47:50 <dons> great stuff araujo. It's really nice to see apps that push the boundary of traditional haskell software.
22:48:07 * araujo wonders why the README file isn't show in the web
22:48:07 <dons> like John Meacham's debian installer (?)
22:48:23 <dons> I think webservers play funny gmes with files called "README"
22:48:24 <araujo> dons, Thanks! :-)
22:48:30 <dons> its happened to me too, with README files
22:48:41 <araujo> I hope other people might enjoy using/coding it too
22:49:45 <RyanT5000> ok so that error is only happening in the editor's check-as-you-type thing
22:49:47 <araujo> the apply offers the basic functionality for now
22:50:36 <araujo> you can practically use the main portage features with it now.
22:51:43 * araujo tries something else with the readme thing
22:52:11 <dons> readme.txt ?
22:52:22 <araujo> yup
22:52:24 <dons> I think that was the trick that worked for me.
22:52:30 <dons> you have to give it a 'type' ;)
22:55:05 <araujo> good, now it works
22:55:11 <araujo> haha
22:59:18 <RyanT5000> hm, another design question, only this time i think i know what i'm asking :P
22:59:26 <Pseudonym> :-)
22:59:42 <RyanT5000> i've got Ships, which are pieces on my board
22:59:43 <RyanT5000> Board
22:59:54 <RyanT5000> i need a way to refer to a Ship
22:59:59 <RyanT5000> without copying it
23:00:08 <RyanT5000> so i made a class ShipID
23:00:14 <Pseudonym> Hang on.
23:00:24 <Pseudonym> What is the "copy" of which you speak?
23:00:55 <RyanT5000> oh right :-/
23:01:03 <RyanT5000> well i think it still might be necessary
23:01:10 <Pseudonym> It may well be.
23:01:18 <Pseudonym> Anyway, go on.
23:01:28 <RyanT5000> actually i'm going to switch tracks for a second
23:01:34 <RyanT5000> the way i conceptualize this
23:01:48 <RyanT5000> is as a relational database
23:02:19 <RyanT5000> i have columns "(Location,Ordinal)", "Ship", and probably some others
23:02:27 <RyanT5000> both of those columns are unique and indexed
23:02:43 <RyanT5000> ah ok here's the deal, why i think i need Ship IDs
23:03:00 <dons> I've sometimes used Uniques to tag large data structuress 
23:03:11 <RyanT5000> the way the game works is that the server filters the game board and sends it to the client
23:03:35 <RyanT5000> the client then makes a map<ShipID, Command>
23:03:40 <RyanT5000> and sends it back to the server
23:04:21 <Pseudonym> Ah, OK.
23:04:26 <Pseudonym> That's a good reason to have IDs.
23:04:30 <sjanssen> araujo: I will try your package
23:04:40 <RyanT5000> right now, here's another trick
23:04:52 <RyanT5000> the IDs are not always "based" from the same datastructure
23:04:56 <RyanT5000> for ships they are, so that's a bad example
23:05:16 <RyanT5000> ah wait no it's an OK example
23:05:25 <RyanT5000> ships only have IDs if they exist within the game world
23:05:35 <araujo> sjanssen, ok, please, let me post a small file im writting right now before you use it.
23:05:47 <araujo> with some indications and recommendations*
23:05:56 <sjanssen> okay, it'll actually be tomorrow I guess
23:05:57 <RyanT5000> so if you have a window that's just editing a Ship, it has no ID
23:06:12 <sjanssen> I need to emerge gtk2hs with mozembed support
23:06:17 <RyanT5000> therefore the Ship datastructure shouldn't store the ID
23:06:47 <RyanT5000> god i totally don't know what i'm asking you to tell me at this point :P
23:07:06 <RyanT5000> my current datastructure is such a hack it's ridiculous
23:07:16 <RyanT5000> basically the IDs are generated at serialization-time
23:07:27 <RyanT5000> and i essentially have a linker
23:08:14 <RyanT5000> which works OK, but it's so off-the-cuff i'm worried about security concerns and such
23:08:41 <RyanT5000> well i guess it's a question of efficiency
23:08:56 <RyanT5000> i could have a function Board -> ShipID -> Ship
23:09:20 <RyanT5000> what's a good way to implement this without searching through the cells of the board?
23:09:32 <dons> araujo: http://haskell.org/haskellwiki/Libraries_and_tools/Operating_system#Package_Management
23:09:36 <dons> :)
23:10:03 <sjanssen> perhaps you keep a Map ShipID Ship ?
23:10:24 <RyanT5000> yeah, that's what I do in C#; is there a better way of abstracting this?
23:10:28 <dons> or Array ShipID Ship, if they're Ix-able
23:10:55 <RyanT5000> here's the reason i'm asking - and tbh i've been struggling with this for a while, before i learned haskell
23:11:05 <RyanT5000> the game state is composed of multiple boards
23:11:05 <sieni> morning
23:11:18 <RyanT5000> so i also need a function World -> ShipID -> Ship
23:11:25 <RyanT5000> and World -> ShipID -> Board
23:11:33 <RyanT5000> i think you can see where i'm going with this
23:11:46 <RyanT5000> it's just like indexed columns in a relational database
23:11:59 <RyanT5000> but i don't know how to express that without actually using an rdbms
23:12:10 <sjanssen> a world contains many boards?
23:12:25 <RyanT5000> er, 5 to a few hundred
23:12:30 <RyanT5000> roughly
23:13:16 <RyanT5000> (btw, you guys are the best programming language chatroom ever; let me know if i abuse you too much with questions like this :))
23:13:39 <sjanssen> do ships cross worlds?
23:13:41 <sieni> this is a channel, not a chatroom ;-)
23:13:44 <RyanT5000> er
23:13:45 <RyanT5000> yeah
23:13:48 <RyanT5000> channel
23:14:00 <dons> no. I think this is fine RyanT5000, your questions are poliite and sensible :)
23:14:04 <RyanT5000> i'm new to IRC too, with the exception of other programming language channels i've tried, unsuccessfully, to get anything useful out of
23:14:17 <RyanT5000> the current model is this:
23:14:30 <dons> lucky there's a few actual Haskell tutors in this channel ;)
23:14:56 <araujo> dons, coool!! :-)
23:15:03 <RyanT5000> a Game is a World and the user input for the turn of which that Game is a product
23:15:25 <RyanT5000> in other words, the simulation function is Game -> UserInput -> Game
23:15:39 <araujo> dons, im writting a small text that you might probably like to use for HWN too.
23:15:46 <RyanT5000> and data Game = Game World UserInput
23:16:04 <RyanT5000> the UserInput gets replaced each time the simulation is called
23:16:10 <dons> araujo: ah yes. please CC. me the announcment when you have one.
23:16:28 <dons> makes my job preparing HWN a bit easier
23:16:31 <RyanT5000> then, World = World [Board] [Player]
23:16:52 <RyanT5000> Board = Array (Int, Int) Cell
23:17:12 <araujo> dons, excellent
23:17:16 <RyanT5000> Cell = [Ship]
23:17:43 <RyanT5000> and unfortunately my datastructures can all pretty much cross anything
23:17:50 <RyanT5000> ships can't leave the World, though
23:18:05 <RyanT5000> so the ShipID should be unique wrt the containing World
23:18:31 <RyanT5000> however i have, for instance, Race (Player = Race GovernmentSystem OtherStuff)
23:19:44 <RyanT5000> so, back to the original thing, how do i efficiently represent the structure that relates Worlds, Ships, ShipIDs, etc.
23:20:20 <RyanT5000> oh yeah and also, one more constraint, i don't want to have any backreferences
23:20:26 <RyanT5000> like i don't want Boards to know that they're contained in Worlds
23:20:36 <RyanT5000> that makes it particularly tricky, i think
23:21:05 <RyanT5000> and that's just becuase every time i've made backreferences for convenience i've ended up screwing myself over
23:21:34 <RyanT5000> maybe i should have ShipPath instead of ShipID?
23:21:54 <sjanssen> perhaps
23:22:05 <RyanT5000> class ShipPath a b where find :: a -> b -> Ship
23:22:05 <sjanssen> you said that a ship can be on several boards?
23:22:14 <RyanT5000> no, a ship can only exist on one board at a time
23:22:35 <RyanT5000> however, a ship can be moved from board to board
23:22:41 <RyanT5000> and the ShipID needs to still refer to it
23:23:39 <RyanT5000> for instance if some effect goes off that teleport's a player's ship to a different board while that player is constructing his commands to that ship, it can't break
23:23:58 <sjanssen> I would say keep a Map ShipID (Board, Int, Int) -- the Ints  are x y coordinates
23:24:01 <RyanT5000> (and due to the way the system is distributed, you can't send him an update saying "the ship has moved")
23:24:08 <sjanssen> this map would be specific to a World
23:24:19 <RyanT5000> alright
23:24:29 <RyanT5000> now, to the haskell part
23:24:37 <RyanT5000> i am going to have a lot of things of that form
23:25:15 <dons> ?dynamic-reload search
23:25:15 <lambdabot> module reloaded
23:25:22 <dons> ?help gwiki
23:25:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:25:27 <dons> hmm
23:26:37 <dons> ?dynamic-reload search
23:26:38 <lambdabot> module reloaded
23:26:41 <dons> ?help gwiki
23:26:42 <lambdabot> wiki <expr>. Search (new) haskell.org wiki for <expr> using google.
23:26:50 <dons> ?gwiki obfuscation
23:26:52 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
23:26:58 <dons> good bot
23:27:07 <sjanssen> RyanT5000: also, do you realise that modifying an array a whole bunch will be very inefficient?
23:27:16 <RyanT5000> hm true
23:27:27 <RyanT5000> is there a better datastructure?
23:27:35 <RyanT5000> it is fixed in size, and i'd like the declaration to reflect taht
23:27:37 <dons> unless its a mutable array.... (evil grin)
23:27:49 <RyanT5000> i will never write mutable code by choice again
23:27:57 * RyanT5000 swears, hand over heart
23:28:03 <sjanssen> haha, the ST monad is fun sometimes
23:28:15 <dons> ?karma+ RyanT5000 -- 24 hours without mutating
23:28:15 <lambdabot> RyanT5000's karma raised to 1.
23:28:28 <sjanssen> you can try DiffArray
23:29:01 <RyanT5000> btw is there a way to put hoogle into firefox's search bar?
23:29:24 <dons> yeah, I think so
23:29:28 <dons> check the hoogle website
23:29:29 <sjanssen> DiffArray is O(1) update if you only update the "most recent" version of an array
23:29:35 <dons> ?google hoogle 
23:29:36 <lambdabot> http://www.haskell.org/hoogle/
23:29:46 <dons> ?hoogle google
23:29:46 <lambdabot> No matches found
23:29:49 <dons> hehe
23:29:49 <RyanT5000> that's awesome
23:31:42 <RyanT5000> in fact, i was at one point about to implement this exact datastructure in C++
23:31:48 <RyanT5000> because i was tired of mutable crap
23:33:44 <sjanssen> oh wow
23:34:15 <sjanssen> I just realized this: DiffArray would let us write an efficient, purely functional, depth first search
23:35:12 <RyanT5000> hm now let's say i want to store key versions of the DiffArray
23:35:39 <RyanT5000> i presume it'll just degenerate
23:35:50 <RyanT5000> it'll be the road-line-painter problem
23:36:40 <sjanssen> yes, it will get worse the older the array gets
23:37:31 <RyanT5000> i was hoping to get a very-easy version of Undo out of this :-/
23:38:52 <RyanT5000> is there any way i can cause it to slide back and forth?
23:39:13 <newsham> @hoogle ErrorLogger
23:39:14 <lambdabot> No matches found
23:39:19 <sjanssen> yes, you just do 'oldArray // []'
23:39:28 <RyanT5000> no that's not what i mean
23:39:54 <sjanssen> oh, you mean go back and forth in time without holding on to old copies?
23:39:54 <RyanT5000> i don't want it to make a whole new copy
23:40:00 <RyanT5000> right
23:40:07 <RyanT5000> i know it can't be done without changing the thing
23:40:16 <RyanT5000> thing = datatype
23:40:21 <sjanssen> no, you'd have to hold on to them explicitly
23:40:26 <RyanT5000> but could i define a new datatype?
23:41:37 <sjanssen> sure, but it would just be the current array and a list of old ones, about the same as holding the copies yourself
23:41:59 <malky> hi, i'm a beginner.  i have a question: which is good haskell for mac os x?
23:42:08 <xX[ReP]Xx> hc
23:42:09 <xX[ReP]Xx> ghc
23:42:17 <malky> does hc == ghc?
23:42:25 <RyanT5000> he mistyped
23:42:30 <malky> so ghc?
23:42:32 <RyanT5000> yes
23:42:39 <malky> okay -- thanks a lot.
23:42:44 <RyanT5000> np
23:45:17 <malky> Just one more question: you guys use emacs as programming environment?
23:45:26 <sjanssen> many people do
23:45:32 <sjanssen> I'm a vi guy myself
23:46:01 <Pseudonym> I use vim.
23:46:12 <malky> i think most people prefer vi -- i wanted to check if emacs was available.
23:46:17 <Pseudonym> My philosophy: Get a decent text editor, but more importantly, learn to use it well.
23:46:34 <Pseudonym> Many zealots on both sides fail on the second point.
23:46:38 <RyanT5000> ah ok sjanssen i don't think i'd get anything out of what i was saying
23:47:00 <sjanssen> yeah, seems like undo should be a global thing
23:47:16 <tennin> I use emacs w/ VIPER
23:47:38 <RyanT5000> well yeah i was thinking it'd store all states it's even been in, and then whenever it's evaluated in a particular state it puts itself in that state
23:47:46 <RyanT5000> sort of like a caching mechanism
23:49:41 <RyanT5000> hm actually i think this could work, only it'd need to store a tree of changes
23:49:51 <RyanT5000> i'm way out of my league
23:50:09 <RyanT5000> right where i want to be :)
