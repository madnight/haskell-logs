00:07:28 <Pegazus> O_o i didn't get a thing
00:07:50 <Cale> okay, let's say we wanted to represent the list [1,2,3,4,5]
00:08:13 <Cale> really, this is 1 : (2 : (3 : (4 : (5 : []))))
00:08:45 <Cale> In the lambda calculus, we don't have (:) or []
00:08:54 <Cale> all we have are functions
00:09:15 <Pegazus> yeah
00:09:18 <Pegazus> i've just understood that
00:09:25 <Pegazus> in lambda you replace each constructor with a function
00:09:34 <Pegazus> and each "base" thing with another function
00:09:41 <Cale> so we might represent that list with
00:10:12 <Pegazus> \f x i z .
00:10:14 <Cale> (\c n -> c 1 (c 2 (c 3 (c 4 (c 5 n)))))
00:10:21 <Pegazus> yes
00:10:32 <Pegazus> but you have to add 2 more parameters for the numbers
00:10:45 <Pegazus> null is = \f x i z . z
00:10:45 <Cale> well, the numbers themselves might be functions
00:10:52 <Cale> but they're defined elsewhere :)
00:11:02 <Cale> > (\c n -> c 1 (c 2 (c 3 (c 4 (c 5 n))))) (:) []
00:11:03 <lambdabot> [1,2,3,4,5]
00:11:27 <Cale> > (\c n -> foldr c n [1,2,3,4,5]) (:) []
00:11:28 <Pegazus> well i am still not able to make functions but i understand a little more :)
00:11:29 <lambdabot> [1,2,3,4,5]
00:11:30 <Pegazus> thanks you all all
00:12:02 <Pegazus> g2g bye bye!
00:12:12 <thetallguy> For example, a one-origin vector of length 10 has bounds (1,10),
00:12:26 <thetallguy> That's from the docs on arrays
00:12:36 <thetallguy> can anyone define ``one-origin''?
00:13:01 <Pegazus> one origin means one indexes i think
00:13:05 <Pegazus> (it starts on 1, not on 0)
00:13:36 <thetallguy> Ah.
00:13:46 <thetallguy> I was looking for something more esoteric.
00:15:30 <Korollary> wow, why is fortran so bad at n-body?
00:16:01 <PeterK> dons: I am using your new FPS, and it is now slightly faster (all subsecond for one 1MB text, but since I am dealing with more than one file, it helps).
00:16:10 <dons> why did the author write a bad version, might be a better question, Korollary :)
00:16:22 <dons> PeterK: cool.
00:18:17 <Korollary> dons: Is it a bad implementation? I don't know fortran.
00:18:34 <Korollary> I was just expecting better since numeric stuff has been its forte.
00:19:58 <dons> just a general remark that the shootout says amore about the author, often, than the language.
00:20:04 <dons> unless the langauge is javascript
00:22:06 <Korollary> For established languages I don't think so. Most of the c/java stuff I've seen is extremely typical.
00:25:04 <dons> good point
00:34:14 <musasabi> morning
00:35:06 <Korollary> how do you pronounce "sans" (fr) ?
00:35:40 <musasabi> dons: that is good, want to add "type FastString = ByteString" in addition there ?
00:35:48 <shapr> Korollary:  It's like "sohn" with the n barely heard.
00:35:52 <dons> ah, yes. good point :)
00:36:34 <Korollary> shapr: Interesting.
00:37:34 <dons> musasabi: done.
00:38:53 <musasabi> thanks
00:40:50 <dons> btw, if you ever want to give me another HAppS profile, I can ponder it to look for ways to improve FPS
00:43:04 <sieni> fps as in frag? :-)
00:43:40 <dons> ah, if only
00:43:46 <musasabi> I can give you some in 15min if you are interested.
00:43:57 <dons> yes please.
00:44:24 <dons> it gives me clues about what needs to be optimised. rather than just guessing from what goes slow in the benchmarks I run
00:45:19 <Cale> Depending on how you'd expect 'o' to sound in that, I'd probably say it's more like "sahn" (with the n just a nasal vowel sound)
00:46:05 <Korollary> the a like the a in 'farm'?
00:46:13 <musasabi> dons: {-# OPTIONS is missing from ByteString.
00:47:50 <dons> right. but you'll have to work around that. since its going into fptools. no?
00:48:09 <Cale> yeah, sort of, except that the n modifies it into a sound that doesn't occur often if at all in English.
00:48:10 <dons> i thought i better float the opts back out to the cabal file
00:51:07 <Cale> http://french.about.com/library/media/wavs/sans.wav
00:51:10 <Cale> :)
00:51:32 <sieni> haha
00:51:34 <musasabi> dons: when in fptools it won't be a problem since it will be prebuilt.
00:52:06 <dons> hm. ok. i'll put them back :)
00:52:17 <musasabi> dons: depending on N+1 libraries some wanting -cpp and some crashing if there is -cpp is not very much fun, thus {-# OPTIONS
00:52:37 <dons> fair enough
00:53:49 <dons> fixing ...
00:55:31 <dons> ok, I think that's it.
00:58:35 <dons> interesting note, yesterday QuickCheck found a bug for me in some code I'd written. but only after I asked it to do 1000 tests per function, instead of the default 100.
00:58:42 <dons> after 100, it said all was fine.
01:06:03 <musasabi> TH changed from 6.4 to 6.5 ?
01:09:46 <musasabi> I stumble upon an error that is generated by http://darcs.haskell.org/ghc/compiler/hsSyn/Convert.lhs cvtName, but the code worked fine with 6.4...
01:29:41 <hoan> haskell is a nice language
01:29:55 <ValarQ> indeed
01:37:26 <musasabi> Solved my TH issues.
01:38:03 <swoolley> that can only be done in haskell
01:38:18 <swoolley> lispers would just pronounce all THs as SSs.
01:38:29 <musasabi> dons: I have to run, but will do the profiles later today and point you to them, just had some issues with non-fps code and 6.5 that took time.
01:45:03 <musasabi> Anyone have got "unknown symbol `entering_PAP'" when linking with 6.5 and profiling?
01:46:33 <nomeata> Hi. Is here any gtk2hs hacker that can give me an ETA when TreModelFilter and TreeModel signals will be supported? (Just to know whether I should develop around that, or just wait)
01:46:56 <sieni> nomeata: yes
01:47:37 <hoan> holy crap
01:47:43 <hoan> you wouldn't believe this...
01:47:50 <nomeata> sieni: and? :-)
01:50:04 <sieni> nomeata: I guess dcoutts is the main developer.
01:50:30 <ValarQ> hoan: what? what?
01:50:34 <nomeata> sieni: thanks
01:50:45 <ValarQ> hoan: oh wait, it's no use, wont believe you...
01:52:44 <hoan> my ipod went through the wash two months ago...
01:53:01 <hoan> it was shameful, my wallet went through 3 days before
01:53:17 <hoan> so, i was waiting fo WASH to compile, and i plugged it in
01:53:23 <hoan> and it came alive
01:53:31 <hoan> haskell is magic...
01:53:42 <PeterK> indeed :)
01:54:19 <hoan> now my sister can have an ipod too, her birthday is in two days :]
01:55:44 <hoan> i must thank peter theimann
01:57:40 <hoan> i'm serious folks...
01:57:48 <Lokadin> say is there any standard way that haskell programs communicate to one another?
01:58:39 <Lokadin> hoan: ? i'm very confused by what you said
01:59:09 <Lokadin> oh i think i get it now
01:59:40 <hoan> oh, my ipod went through the wash (washing machine), and today i was compiling WASH (computer program) and plugged in my old ipod, and it worked!
01:59:41 <hoan> the mind BOGGLES
02:02:49 <hoan> Lokadin: i'm sorry i don't know much about Haskell, but do you mean is there a standard way for Haskell programs to serialize data?
02:02:54 <Lokadin> that's pretty crazy
02:03:05 <Lokadin> i don't know that's what i was asking
02:03:18 <Lokadin> dono about serializing was just wondering about communication
02:03:31 <Lokadin> but it's okay i'll look it up
02:03:37 <hoan> okay, like through sockets?
02:03:54 <hoan> you can use read/show to convert haskell values to strings
02:04:00 <hoan> and back
02:04:35 <Lokadin> cool thanks, i'll look it up :)
02:05:52 <hoan> okay, i'll tell my sister what she is getting for her bday :)
02:12:18 <mahogny> Lokadin, check out happs. not a standard, but a usable framework
02:14:19 <nomeata> the docs say that treeModelIterNext modifies it's argument. is that even possible in haskell?
02:14:52 <mahogny> if you use mutable variables, yes
02:15:55 <nomeata> ok. is there a way to use such an iterator function to create a list of all iters?
02:16:18 <mahogny> haven't used the API in question so I don't know
02:17:39 <nomeata> isn't that a general haskell function? roughly spoken, signature is  nextIter::  Iter -> IO Bool, and I want a [Iter]
02:20:06 <Lokadin> say what's an easy way of converting a [String] to a String
02:20:17 <mahogny> well, no. there's no general solution as it slays the old iter. had it been something like :: Iter -> IO Iter   then you could have done it easily
02:20:24 <mahogny> depends on what you mean with convert
02:20:29 <wilx> @type concatMap
02:20:30 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
02:20:55 <wilx> @type concat
02:20:56 <lambdabot> forall a. [[a]] -> [a]
02:21:10 <Lokadin> well i have arguments and i say just want them to be outputted as a string
02:21:25 <mahogny> well, unwords or concat then
02:21:36 <Lokadin> kk thanks :)
02:22:51 <Saulzar> nomeata, gtk2hs right? What I have been doing is running that through a loop and converting the iter to a Path
02:24:07 <Saulzar> Then converting the path back to an iter when I need to use it
02:25:11 <Saulzar> The gtk2hs people are also working on a new treeview API which is much cleaner than the old, so you don't have to muck around with TreeIters. I'm not sure what the status of that is. dcoutts? :)
02:25:46 <nomeata> hmm. when there are mutable variables, should there then not be a while construct in haskell? Something like (rough guess): while :: (-> IO Bool) -> [IO a] 
02:26:10 <Lokadin> say you guys generally just use make to deal with program compilation and the like right?
02:26:21 <nomeata> Saulzar: would be nice, especiall if it's ready within the next two weeks, along TreeModelFilter and TreeModel signals  :-)
02:26:31 <Saulzar> nomeata, Trouble is that it actually mutates the iter - so you can't copy it ... it's just a reference
02:26:59 <hoan> Lokadin: there is also Cabal, which is for packaging haskell programs and compiling them
02:27:08 <Saulzar> and as far as I know the only way I found to copy them was to convert to a path and back
02:27:08 <Lokadin> oh thanks :)
02:27:19 <Lokadin> i was wondering what that was
02:27:23 <nomeata> Saulzar: well, I don't really need the iter, I would happily pass an "Iter -> IO a" function to something, so I get a list of interesting values out of the iter
02:28:10 <nomeata> Basically I want the TreeModel values in a list
02:28:34 <Saulzar> lisppaste2, url
02:28:34 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:29:31 <lisppaste2> Saulzar pasted "Tree iter loop thingey" at http://paste.lisp.org/display/19270
02:30:48 <nomeata> thanks
02:31:20 <Saulzar> You can probably write a whileM or something to handle it better
02:41:57 <lisppaste2> nomeata pasted "second tree iter map thing" at http://paste.lisp.org/display/19271
02:42:06 <nomeata> Saulzar: could you comment on my try?
02:46:10 <nomeata> it seems to be working quite fine
02:46:58 <nomeata> Is there a substring (or sublist) matching function in haskell? (isIn :: [a] -> [a] -> Bool)?
02:49:39 <jyp> > any ("abc" `isPrefixOf`) (tails "asdfabcqwef")
02:49:40 <lambdabot> True
02:49:44 <jyp> > any ("abc" `isPrefixOf`) (tails "asdfacqwef")
02:49:45 <lambdabot> False
02:50:00 <nomeata> thax
02:50:16 <jyp> cheers
02:51:00 <nomeata> I guess performance must not be important in this case. :-)
02:51:23 <jyp> It's going to be pretty bad indeed.
02:51:23 <hoan> well, here is another slow one: let isIn a b = all (\c -> elem c b) a
02:51:27 <hoan> :-) hehe
02:51:42 <hoan> O(n^2) ishlike
02:51:58 <jyp> nomeata: You can pull a regexp library if you want something better.
02:52:24 <jyp> hoan: you isIn don't do a substring test.
02:52:51 <hoan> hmm okay, i'm probably wrong
02:52:56 <hoan> lets see
02:53:23 <hoan> oh okay, sure its subset
02:53:29 <hoan> my bad
02:56:25 <nomeata> why is or applied to too many arguments: (or [sublist (show . (matr tut)) text, sublist (vname tut) text, sublist (nname tut) text])
02:56:56 <flux__> hmm, why would the performance (of the tails-version) be _that_ bad, albeit it doesn't use a state machine?
02:57:43 <flux__> worst case is O(n*m), but in 'normal cases' would probably be near O(n)
02:58:20 <resiak> @type or
02:58:22 <lambdabot> [Bool] -> Bool
02:58:37 <resiak> nomeata: ^^
02:59:35 <flux__> wouldn't it be allowed for the compiler to actually construct a state machine out of that piece of code?-)
03:00:45 <nomeata> nevermind, problem was somewhere else
03:00:49 <nomeata> @type (.)
03:00:51 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
03:02:41 <nomeata> I thought "return(or [...])" is the same as "return.or [..]", but I seem to be wrong. why?
03:03:38 <lypie> um...
03:03:47 <lypie> is there an osx/intel/dmg available for ghc yet?
03:03:50 <lypie> if so... where? ;)
03:06:06 <hoan> lypie: there is a pkg installer
03:08:21 <lypie> hoan: that supports intel? the only ones i can find are for ppc :/
03:08:27 <hoan> weee http://www.haskell.org/ghc/dist/6.4.1/MacOSX/GHC-6.4.1.pkg.zip plonk
03:09:13 <lypie> hoan: afaiu ghc didn't actually even compile on x86 osx at that point
03:09:39 <lypie> hoan: and the header says "powerpc" so unfortunately i don't think this is the one :(
03:09:58 <xerox> Good morning.
03:10:21 <xerox> lypie: I'm also looking forward getting it to compile!
03:10:29 <hoan> sorry no...
03:11:15 <lypie> xerox: i'd imagine its possible to use the ppc version to compile the intel version
03:11:22 <lypie> s/compile/bootstrap
03:11:25 <lypie> s/$//
03:11:28 <lypie> but i'm really not sure :(
03:11:45 <xerox> lypie: I have the PPC one installed.  I'm trying to realize how to get the darcs repo without darcs.
03:12:00 <lypie> xerox: wget
03:12:21 <xerox> lypie: it puts a bunch of html and other files in each dir, argh.
03:12:49 <lypie> eep
03:21:37 <olliej> lypie: woah
03:21:45 <lypie> lol
03:21:48 <lypie> yoyo olliej
03:21:55 <lypie> olliej: does 6.5 work?
03:22:02 <olliej> no idea
03:22:09 <lypie> lame!
03:22:12 <xerox> Mumble.
03:22:20 <olliej> lypie: :)
03:22:27 <lypie> xerox: the last update was early march "we are working on it"
03:22:28 <olliej> dcoutts: around?
03:22:32 <lypie> olliej: wanted to build pugs
03:25:07 * xerox wants to give it a try.
03:26:19 <olliej> xerox: do you have any idea why the cairo test in gtk2hs would fail? 
03:26:30 <olliej> xerox: it can't find cairoCreatContext
03:26:36 <olliej> renderWithDrawable
03:26:42 <olliej> or showLayout
03:26:52 <xerox> It is *create*.
03:27:02 <xerox> Hmm, but what test are you talking about?
03:27:12 <olliej> gtk2hs sources
03:27:16 <olliej> demo/cairo
03:27:20 <xerox> Ah, the demos.
03:27:30 <olliej> sorry :-/
03:27:40 <olliej> what's create?
03:27:53 <xerox> cairoCreateContext.
03:28:20 <olliej> sorry, above was a typo
03:28:21 <xerox> But it doesn't make sense.
03:28:21 <olliej> that's what it can't find :(
03:28:21 <xerox> Do you have the latest darcs?
03:28:21 <olliej> nope
03:28:31 <olliej> will  try that
03:28:44 <olliej> well.. i'll get the most recent downloadable version
03:28:55 <xerox> Okay.
03:29:39 <xerox> cairoCreateContext is part of the internal API, it should be used for lowlevel things.  It expose a nicer API too, and I synched the demos sometime.
03:29:46 <olliej> xerox: most recent is .9.10?
03:30:01 <olliej> 0.9.10?
03:31:08 <xerox> 0.9.10.2
03:31:13 <nomeata> can I use utf8 in string literals in haskell?
03:31:23 <xerox> If only I had GHC.. *grmbl*
03:31:53 <olliej> xerox: just pulled of sourceforge
03:31:53 <nomeata> (when I try to use that with gtk2hs, it looks like somewhere the utf8 gets treated as latin1)
03:31:53 <olliej> what vversion is that likely to be?
03:32:43 <xerox> olliej: see configure.ac
03:32:45 <Lokadin> say, i'm trying to figure out cabal, and when i build it says it can't find module IO
03:33:30 <xerox> Lokadin: maybe System.IO ?
03:33:38 <olliej> xerox: it says 9.10
03:33:47 <olliej> xerox: i guess i'm download darcs
03:34:17 <Lokadin> Could not find module `System.IO'
03:34:20 <Lokadin> :(
03:34:32 <xerox> Lokadin: are you compiling Cabal itself?
03:34:46 <Lokadin> no, i'm compiling a really simple file with cabal
03:35:11 <xerox> Which file?
03:35:13 <Lokadin> it's just like a hello world executable
03:35:27 <xerox> Right.  Why do you need to import IO?
03:35:46 <Lemmih> Lokadin: Did you state your dependency on base?
03:36:00 <xerox> Howdy Lemmih!
03:36:07 <Lemmih> Morning, xerox.
03:36:30 <xerox> Lemmih: good work with the proposal page, dcoutts added his ideas.
03:36:52 <Lokadin> Lemmih: thanks :)
03:36:57 <Lokadin> it worked
03:37:39 * xerox grumbles at wget
03:37:44 <xerox> lypie: any luck?
03:37:49 <Lokadin> say can i change the src directory from . to src ?
03:38:03 <Lemmih> Lokadin: Hs-Source-Dir: src
03:38:14 <Lemmih> (or with newer Cabals: Hs-Source-Dirs:)
03:38:18 <Lokadin> per executable, or in main stanza?
03:38:44 <Lemmih> Per executable.
03:38:51 <Lokadin> kk thanks :)
03:42:47 <lypie> xe	alas not
03:43:14 <lypie> xerox: ^
03:48:49 <olliej> xerox: darcs version of gtk2hs depends on happy
03:49:00 <shapr> d00d
03:49:05 <xerox> olliej: the other didn't?
03:49:16 <shapr> Lemmih: Got a few mins to talk about cabal-get?
03:49:21 <olliej> xerox: nope
03:49:32 <xerox> olliej: I don't know.
03:49:37 <olliej> gah
03:49:44 <xerox> Happy is good to have anywy I presume?
03:49:50 <xerox> Many other Haskell packages depend on it.
03:51:28 <olliej> oh ffs
03:51:28 <olliej> can't configure happy, let alone build it
03:52:54 <olliej> hmmm
03:52:59 <olliej> can build but not configure
03:53:13 * olliej wonders what the readme says :)
03:53:54 <Lemmih> shapr: Yeah.
03:55:20 <Lemmih> lambda_boy: Are you by any chance a side-kick for haskell-man?
03:58:18 <shapr> Lemmih: hahaha
03:58:55 <basti_> lol
04:00:12 <shapr> I'm putting cabal-get on a diet so it'll be small enough to include in Cabal. I created http-min and xmlrpc-min that only have the modules required by hackage-client and xmlrpc-min. I haven't seen a good way to trim HaXml though. Do you think switching from xmlrpc to BEncode is worth considering?
04:00:45 <Lemmih> Yeah, that's exactly what I wanted to do.
04:01:12 <xerox> shapr: did you see the SoC projects proposal page?
04:01:19 <shapr> xerox: Not yet, where is it?
04:01:21 <xerox> http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
04:01:31 <xerox> Lemmih proposed cabal-get in fact :-)
04:01:31 <Lemmih> shapr: I planned to steal the fast and well tested code from Conjure.
04:02:06 <shapr> Excellent, that's what I've been staring at :-)
04:03:17 <shapr> I've also noticed that http-min would likely be used by a bunch of projects since only Network.Browser requires the Crypto lib.
04:03:31 <shapr> Does cabal already have some way to build meta-packages?
04:03:53 <shapr> I guess I could just build an empty package that only has dependencies like debian does?
04:04:09 <shapr> hola ^geekgirl^ 
04:04:26 * xerox stares at the page hoping it will not overflow due to shapr's ideas (-;
04:05:04 <lambda_boy> at lemmih: no i do not know haskell-man
04:05:09 <lambda_boy> ;)
04:08:00 <Lemmih> How old is GHCi?
04:08:05 <lambda_boy> im afraid there's no batman and robin of haskell :(
04:08:10 <shapr> Lemmih: 5.x?
04:08:31 <xerox> lypie: I'm wgetting GHC sources.
04:08:58 <^geekgirl^> my GPL codes at -> http://usuarios.lycos.es/sosweet19/
04:09:09 <shapr> ^geekgirl^: Is it Haskell?
04:10:23 <hoan> is geekgirl a boy or girl or neither?
04:10:48 <shapr> At this point I'm suspecting it's an innocuous name for a spammer :-/
04:11:29 <hoan> well, it just popped up in the lisp room
04:11:43 --- mode: ChanServ set +o shapr
04:11:53 --- kick: ^geekgirl^ was kicked by shapr (Kicked by shapr)
04:11:58 <shapr> No spam please.
04:13:25 <mahogny> that was a new type of spamming o_O
04:14:47 <Lemmih> shapr: Thanks.
04:15:15 <shapr> At least, I think so... it might have been 4.x, I'm not sure.
04:16:13 <Lemmih> shapr: I checked the manuals for 5.0 and 4.08, you were right.
04:18:48 <mahogny> omg. looking at the projects proposed at the haskell wiki, they are reaaaally small most of them. I have trouble seeing how any can be worth a 4500USD stipend
04:19:35 <olliej> mahogny: url?
04:19:42 <lambda_boy> i kinda think 4500 dollars i overkill for a summer project
04:20:02 <mahogny> http://code.google.com/soc/studentfaq.html
04:20:02 <shapr> Depends on the project.
04:20:03 <lambda_boy> they could split it up further and have more people on the program
04:20:10 <shapr> I'd like to see language specific parsers.
04:20:14 <mahogny> Google will provide a stipend of 5000 USD per accepted student developer, of which 4500 USD goes to the student and 500 USD goes to the mentoring organization. Youll be paid 500 USD upon acceptance of your application to the program, 2000 USD mid-program (assuming you've made sufficient progress on your project), and 2000 USD at close of program (assuming you've completed your project.) The mentoring organization will receive its sh
04:20:14 <mahogny> are upon completion of the project
04:20:34 <shapr> On the other hand, think of the number of hours that would fund for a professional programmer.
04:20:40 <shapr> > 4500 / 30
04:20:42 <lambdabot> 150.0
04:20:43 <olliej> mahogny: i mreant for the haskell suggestions
04:20:47 <mahogny> aha
04:20:56 <olliej> :)
04:20:58 <xerox> mahogny: feel free to add your suggestions!
04:21:02 * xerox <- lunch
04:21:05 <mahogny> xerox, I'm on it
04:21:11 <mahogny> http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
04:21:46 <mahogny> I just have trouble with this 500usd thing. sounds messy. I'd actually just prefer to mentor someone inofficially
04:21:59 <mahogny> like I always have :/
04:22:18 <Lemmih> Well, the organization get's the money.
04:22:34 <shapr> Yeah, it could be used to fund darcs.haskell.org if you don't want it.
04:22:36 <mahogny> and. uh. what is the organization? is there a registered haskell organization?
04:23:06 <shapr> There's at least a disorganization of motivated people.
04:23:27 <shapr> In any case, this collection of people continues to improve and explore Haskell.
04:23:27 <mahogny> yeah. that's what I mean
04:24:00 <mahogny> so will the mentor himself be the one who decides on how to distribute the money or what? just thinking formal details here
04:24:01 <Lemmih> Haskell.org will be our organization.
04:24:29 <shapr> I wish I could remember my password for the wiki.
04:24:37 <lambda_boy> \nick lambda_boy|lunch
04:27:27 <mahogny> oh well. added me to the wiki
04:29:24 <Lemmih> mahogny: Welcome (although I disagree with your opinion of what Haskell needs).
04:29:34 <mahogny> Lemmih, :)
04:30:16 <mahogny> Lemmih, I have seen the comment that "C++ is the language used in the real world" too often
04:30:48 <shapr> ?
04:31:25 <shapr> I've used Haskell for real world stuff already.
04:31:46 <mahogny> yeah. we have. but most people have not :)
04:32:16 <shapr> Most people don't change/learn/improve until their survival requires it.
04:32:23 <mahogny> indeed
04:32:45 <mahogny> so... make them be on edge of survival when we toss out better quality programs at a pace they can't hold :P
04:33:08 <shapr> Yes, my proposals are all about picking up the pace.
04:33:51 <mahogny> once more programmers start using haskell and up their pace, the <insert bad language here>-coders will be exterminated
04:34:23 <mahogny> someone just need to get that rock rollin
04:34:26 <mattam> that's not morally acceptable
04:34:38 <mattam> we have to convert the coders too
04:35:59 <shapr> mahogny: I think the rock is already rolling.
04:36:01 <mahogny> first we have to get them unemployed. that makes life much easier :)
04:36:07 <Saulzar> Wouldn't it be tough work to write a "serious application" or game in 2 months? Rather... there are a lot of programs but to top them all in 2 months sounds like a tough task
04:36:12 <mahogny> shapr, it can never be rolling fast enough :)
04:36:27 <mahogny> Saulzar, depends on what you mean by serious application
04:36:37 <Saulzar> What do you mean, then? :)
04:36:41 <mahogny> and also the student
04:37:01 <mahogny> Saulzar, some 5-10kloc
04:37:35 <mahogny> if they get 4500usd, they gotta make themselves worthy of it :)
04:38:08 <Saulzar> But it is not such a hard task to write bulk code, if it then rots in a corner...
04:38:40 <mahogny> I include lots of comments in that. I guess without comments you can get away with much less
04:38:47 <shapr> Also, 5kloc is a huge amount of Haskell code.
04:39:10 <mahogny> ah wait. gaah. I still think in measures of C
04:39:37 <mahogny> 5-10kloc C, convert that to haskell :)
04:40:12 <Saulzar> It's just that I'm sure a "complete application" is always going to be more beneficial than a "big application"
04:40:13 <shapr> There are some Haskell apps that large, but mostly because they've decided to reimplement chunks of the standard libraries. InForM comes to mind.
04:40:23 <mahogny> Saulzar, indeed
04:40:38 <mahogny> Saulzar, and also, the documentation should be top
04:40:46 <shapr> I think that a friendly and easily modified library is even more beneficial.
04:41:37 <mahogny> might be. but I usually see libraries as a byproduct if you write modular code
04:47:31 <olliej> xerox: so i have finally got a darcs version of gtk2hs built, but i still can't run any of the cairo demos
05:06:02 <xerox> olliej: as soon as I have GHC I'll try it out.
05:17:08 <lambda_boy> anybody ever come across a $= operator in haskell?
05:18:46 <dcoutts> nomeata, gtk2hs treats strings as genuine unicode
05:18:47 <mauke> no, but I've seen $= in perl
05:19:06 <Lemmih> lambda_boy: I've seen it in HOpenGL, I think.
05:19:22 <dcoutts> nomeata, a Haskell String is full unicode, you don't use a utf8 encoding (or it'll display as a utf8 encoding)
05:19:30 <dcoutts> olliej, pong
05:19:38 * xerox pokes dcoutts 
05:20:03 <lambda_boy> thanks lemmih sounds right in the context of the code im looking at
05:20:04 <dcoutts> Saulzar, the new tree view api is nearing usability, it's available to play with
05:21:26 <dcoutts> xerox?
05:21:55 <xerox> dcoutts: getting GHC sources via wget is slow as hell!  Do you know a better way if one can't have darcs?
05:21:59 <dcoutts> nomeata, as for the tree view signals, do you mean you want to emit them or connect/respond to them?
05:22:19 <dcoutts> xerox, get a nightly snapshot
05:22:32 <dcoutts> as one tarball
05:22:47 <xerox> dcoutts: snapshots are pre compiled or sources distribution?
05:23:12 <dcoutts> xerox, both
05:23:14 <dcoutts> http://haskell.org/ghc/dist/
05:23:46 <dcoutts> xerox, you'll want http://haskell.org/ghc/dist/current/dist/ I suppose
05:23:56 <xerox> Right.  Danke!
05:23:56 <dcoutts> latest: http://haskell.org/ghc/dist/current/dist/ghc-6.5.20060422-src.tar.bz2
05:25:00 <dcoutts> xerox, siete benvenuti
05:25:35 <xerox> heh.
05:29:21 <shapr> Lemmih: Would it be simpler for hackage to be able to pull the $PACKAGE.cabal file and do its own calculation of deps, location, description, etc?
05:33:05 <dcoutts> shapr, that might be a good way to go, since it'll also pass through any extensions fields in the .cabal file "x-foobar: baz"
05:34:09 <shapr> I guess using FGL for a graph of deps is unreasonable :-)
05:34:40 <olliej> dcoutts: i can't make the cairo bindings go
05:34:53 <dcoutts> olliej, on which OS ?
05:34:58 <olliej> dcoutts: linux
05:35:04 <dcoutts> and you've got gtk+ 2.8.x ?
05:35:12 <Lemmih> shapr: huh?
05:35:14 <olliej> erm how do i check?
05:36:32 <shapr> Lemmih: I was just looking at hackage-client and wondering how to replace xml-rpc with BEncode, and I wondered whether most of the calls to the server could be replaced with a memoizing call to the $PACKAGE.cabal file and a record accessor for the pieces of that file.
05:37:06 <dcoutts> olliej, run: pkg-config --modversion gtk+-2.0
05:37:42 <olliej> 2.6.7 great
05:38:01 <olliej> and i don't have admin rights
05:38:03 <olliej> hurrah
05:38:22 <dcoutts> olliej, yep, you can build the cairo bindings but you won't be able to use them with gtk+, just for writing .png/.ps/.pdf files
05:38:35 <olliej> *sigh*
05:38:37 <dcoutts> olliej, it is possible to do local user installs of gtk+
05:38:41 <dcoutts> I've done it before
05:38:53 <Lemmih> shapr: Well, isn't 'getPkgDescription' the only function querying the .cabal file?
05:38:57 <olliej> dcoutts: yes but they all fight that sort of thing
05:39:04 <shapr> listPackages, isCompatible and getServerVersion must be done on the server, but getPkgDescription, getPkgDescriptions, getDependencies, getPkgLocation can all work off of the $PACKAGE.cabal file, yeah?
05:39:40 <Lemmih> shapr: No, 'getDependencies' also calculates the dependencies of the dependencies.
05:40:06 <shapr> Which could be done by downloading the *.cabal files involved and calculating them locally, yeah?
05:40:06 <Lemmih> shapr: (otherwise the client would have to query the database several times)
05:40:56 <shapr> Yeah, it would require several queries, but the server/client interface would be simpler, and only the client would have to be 'smart'.
05:41:16 <Lemmih> shapr: You would download /all/ the .cabal files?
05:41:43 <Lemmih> shapr: How about just changing 'getDependencies' to return cabal files?
05:41:44 <shapr> I'd assume that you'd only download and cache the .cabal files that you want.
05:43:04 <shapr> With a more apt-get-like system, there'd be a static file cabal.listing or something that would give urls to the $PACKAGE.cabal files.
05:43:36 <shapr> Lemmih: I'm just exploring the solution space, looking for possible simplifications.
05:44:05 <shapr> Yeah, getDependencies could return the .cabal files you need.
05:44:17 * shapr boings happily
05:44:19 <shapr> This is fun!
05:44:29 <Lemmih> shapr: Btw, 'getDependencies' isn't used in cabal-get.
05:44:34 <dcoutts> one advantage to having more smarts on the server is that it might be possible to upgrade features on the server without having to change the client
05:45:30 <shapr> On the other hand, the whole point of this client is upgrading, so why shouldn't it upgrade itself?
05:45:59 <shapr> It's true though, changes always have some cost.
05:46:48 <Lemmih> shapr: Cabal-get is currently keeping a list of all known packages in /etc/cabal-get and ~/.cabal-get.
05:46:53 <shapr> ohh
05:48:01 <shapr> You think there would be any disadvantages to switching to an apt-get-like package listing so cabal-get can grab only the needed .cabal files?
05:48:43 <Lemmih> I don't follow...
05:49:15 <shapr> Actually, it's more likely I don't follow, I'll peruse the cabal-get sources more.
05:52:19 <dcoutts> shapr, the way our gentoo hackage tool works is to download a full cache and then work exclusively from that (except when it needs to download a tarball)
05:52:38 <dcoutts> shapr, http://haskell.org/~gentoo/gentoo-haskell/HackPort/
05:52:59 <dcoutts> it's our tool for generating ebuilds from cabal packages
05:53:15 <dcoutts> written mostly by der_eq and kolmodin 
05:59:25 <shapr> dcoutts: You cache the .cabal files?
06:04:52 <dcoutts> shapr, I think so
06:05:01 <dcoutts> I'd have to double check the code...
06:05:28 <dcoutts> shapr, ask kolmodin for details
06:06:29 <dcoutts> oh, hmm, mabe it's just package names & versions
06:06:48 <dcoutts> http://haskell.org/~gentoo/gentoo-haskell/HackPort/Cache.hs
06:07:40 <shapr> Yeah, that's the sort of thing I was considering.
06:08:49 <dcoutts> shapr, when was the last time we had >210 people in this channel?
06:08:55 <goron> One question: info $ unlines [
06:08:55 <goron> 	  	  "Your hackage cache is old!"
06:08:55 <goron> 		, "It's " ++ timeDiffToString diff ++ " old."
06:08:55 <goron> 		, "You may update it by 'hackport update', and then rerun this execution."
06:08:55 <goron> 		]
06:09:06 <goron> Why not just run it, and not bug the user?
06:09:09 <shapr> dcoutts: Yesterday we had 215 :-)
06:09:16 <bringert> hi guys
06:09:16 <shapr> hej bringert, I was just composing a mail to you...
06:09:22 <bringert> hej shapr
06:09:27 <bringert> what about?
06:09:30 <goron> "-- | Bug the user if his cache is old"
06:09:38 <bringert> or do you want to just send it?
06:09:53 <bringert> anyone know how to use ghc --make with --main-is?
06:10:05 <shapr> It's short, I want Network.Browser in a separate package so Network.HTTP won't require crypto.
06:10:14 <bringert> I keep getting "Warning: output was redirected with -o, but no output will be generated
06:10:14 <bringert> because there is no Main module."
06:10:18 <bringert> shapr: good point
06:10:27 <shapr> I'm trying trim cabal-get into something small enough to distributed in the next version of cabal.
06:10:32 <bringert> the crypto dep is annoying
06:10:40 <frevidar> hey, is there any GUI library for haskell that has a control to play movies?
06:10:59 <shapr> Yeah, the crypto dep is too much trouble for a cabal bootstrap.
06:11:03 <frevidar> something like wxmediactrl in wxwidgets?
06:11:08 <dcoutts> shapr, great!
06:11:25 <frevidar> from here: http://www.wxwidgets.org/manuals/2.6.3/wx_wxmediactrl.html
06:11:42 <dcoutts> shapr, have you told SyntaxNinja that you're looking at that? He asked dons and me to look at that issue.
06:11:49 <Lemmih> frevidar: Seen wxhaskell?
06:12:18 <shapr> dcoutts: Yeah, a coupla days ago I said I would investigate, but the changes were so simple I figured I'd just implement.
06:12:29 <frevidar> lemmih: yes. But I cant seem to find that control in it?
06:13:11 <waern> frevidar, it's probably not a part of wxhaskell. 
06:13:30 <shapr> bringert: I created http-min (get rid of crypto dep) and xmlrpc-min (get rid of TH dep for hugs/nhc/jhc/etc), but I think I'm going to switch to BEncode instead of xmlrpc.
06:14:07 <shapr> It did bring up the larger question of how to include accessories like THDeriveXmlRpcType.
06:14:20 <shapr> I don't have a good answer though.
06:14:22 <pejo> Does anyone happen to have the source to ghc 0.29 or 2.10 laying around? They don't seem to exist on haskell.org
06:14:50 <DeliQ> why would you want such old sources ??
06:15:05 <frevidar> waern: are there any other haskell libraries that have something similar to play movies?
06:15:06 <bringert> shapr: split-up HTTP package will be in darcs soon
06:15:12 <shapr> yay! thanks!
06:15:23 <vincenz> re
06:15:33 <pejo> DeliQ, I suspect they might contain an implementation of some deforestation algorithm.
06:15:40 <shapr> DeliQ: Reading Linux 0.01 sources is fun, try it!
06:15:41 <DeliQ> aha
06:15:53 <DeliQ> you know whats funny
06:15:57 <shapr> comedians?
06:15:58 <DeliQ> try grepping on nasty words :P
06:16:03 <mauke> http://toadking.com/6x9=42/duffy/straddlehorse.gif ?
06:16:09 <DeliQ> in de linux source
06:16:22 <waern> frevidar, I don't think so
06:16:24 <pejo> DeliQ, it's easy to get upset when you see how hardware "works".
06:16:41 <DeliQ> i think so, yes...
06:16:41 <shapr> Or doesn't...
06:17:39 <DeliQ> pejo: maybe can google help you ?
06:18:40 <DeliQ> pejo: i personally think that almost nobody has such old sources lying around
06:19:18 <dcoutts> I know my department used to have ghc 0.29 installed as the default until a couple years ago
06:19:40 <goron> It is possible to get a formal language definition of Haskell with all the extensions somewhere which is also entensible? E.g. one in Parsec?
06:20:03 <dcoutts> goron, try an attribute grammar
06:20:20 <dcoutts> goron, I think that's what EHC is tring to do/be
06:20:31 <goron> dcoutts: No, I don't mean that.
06:20:48 <goron> dcoutts: EHC just is an extensible compiler.
06:20:59 <goron> dcoutts: I would like to add something like a reader to Haskell.
06:21:07 <dcoutts> a reader?
06:21:12 <hoan> like lisp?
06:21:17 <goron> dcoutts: Like Lisp readers.
06:21:25 <shapr> You want to be able to extend the syntax at runtime?
06:21:27 <goron> dcoutts: Then you can get rid of TH also.
06:21:44 <goron> shapr: Well, I don't know about that.
06:21:54 <goron> shapr: Run-time extensions are not that useful.
06:22:03 <goron> shapr: and destroy all good things of Haskell, I think.
06:22:06 <shapr> They'd be handy for DSLs.
06:22:22 <xerox> http://video.google.com/videoplay?docid=908674814285543652&q=pirate+baby+cabana+battle&pl=true  <-- weird but very nice :-)
06:22:24 <shapr> In any case, wouldn't a reader have to deal with typesafety?
06:22:40 <goron> shapr: A reader only needs to compile to valid Haskell.
06:23:01 <dcoutts> TH certainly has to deal with typesafty
06:23:36 <goron> dcoutts: The reason is does is userfriendlyness.
06:23:56 <goron> dcoutts: Otherwise you just get generated code which has a type eror.
06:24:00 <goron> error that is
06:24:23 <goron> dcoutts: That's what attribute grammars give you now. 
06:24:25 <dcoutts> that's exactly what it does, it barfs when you generate code that has a type error
06:24:30 <dcoutts> it/TH
06:24:49 <goron> dcoutts: Ok, then I don't see the problem.
06:25:05 <mux> Prelude Data.Complex> let i = 0 :+ 1
06:25:05 <mux> Prelude Data.Complex> i * i
06:25:05 <mux> (-1.0) :+ 0.0
06:25:05 <mux> Prelude Data.Complex> i ** 2
06:25:05 <mux> (-1.0) :+ 1.2246063538223773e-16
06:25:20 <mux> weird
06:25:33 <dcoutts> goron, sure ,TH is typesafe in a dynamic sort of way
06:25:57 <goron> dcoutts: Only it does nothing with syntax.
06:26:05 <dcoutts> indeed
06:26:09 <pejo> DeliQ, I haven't found much. Seems like ftpsearch is dead nowdays. 
06:26:29 <DeliQ> i was also looking for it
06:26:33 <DeliQ> only dead ftp links
06:26:58 <pejo> Ok, just because I said I had already looked it seems like Chalmers has 0.29.
06:27:33 <DeliQ> i think i missed you saying that
06:27:59 <goron> dcoutts: I think it's the answer to all people who want to "extend" Haskell. You don't need commitees anymore, and just can have Haskell 98 as a core language. 
06:28:05 <pejo> http://www.cs.chalmers.se/pub/haskell/glasgow/ if anyone else is interested. :-)
06:28:37 <dcoutts> goron, except that making extensions coexist is not always trivial
06:28:39 <goron> dcoutts: But do you know of such a parser?
06:28:57 <goron> I heard of one, but forgot its name.
06:28:58 <bringert> shapr: split-up HTTP is in darcs now.
06:29:12 <dcoutts> goron, I think EHC uses a combinator based parser
06:29:27 <dcoutts> so should be more easily extensble than a happy grammar
06:29:49 <goron> dcoutts: Hmm, sounds plausible, since EHC was build in the "academic way".
06:30:16 <dcoutts> goron, right, and I think that their combinator language allows the possability to chage the gramar depending on input
06:30:33 <aufrank> goron: I started reading about packrat parsing recently, don't know exactly what you're looking for though
06:31:00 <dcoutts> goron, so you could have a file that has parser rules at the beginning which determine how to parse things later in the file - if that's what you're aiming for
06:31:21 <dcoutts> ie so you can define your own syntactic sugar
06:31:41 <goron> dcoutts: Well, I more thought like using an escape function.
06:31:51 <goron> dcoutts: That's what Common Lisp does.
06:32:05 <dcoutts> but of course that won't do for all extensions, some want extra semantics, not just syntactic fiddling
06:32:40 <goron> dcoutts: Semantics like?
06:32:53 <goron> dcoutts: e.g. putting stuff in registers?
06:33:03 <goron> dcoutts: when annotated like that.
06:33:28 <dcoutts> eg it's simple to add something like constructor-less data types syntactically but it doesn't translate down into H98
06:33:53 * tibbe wants to write a Haskell meets C language
06:34:12 <goron> dcoutts: Constructor-less datatypes? 
06:34:19 <dcoutts> data Foo;
06:34:36 <goron> dcoutts: doesn't that translate to data Foo=Foo?
06:34:49 <dcoutts> my Foo has no elements except _|_
06:35:29 <pejo> tibbe, why?
06:35:31 <tibbe> _|_ = bottom?
06:35:37 <dcoutts> tibbe, right
06:35:59 <tibbe> pejo, dunno really, perhaps beacuse I don't know of any such language
06:36:24 <tibbe> dcoutts, how would such a data type be useful?
06:36:58 <goron> dcoutts: Can't you add to every function acting on Foo to eval(Foo _) = undefined?
06:37:23 <goron> dcoutts: ah, well, that doesn't work with separate compilation.
06:37:56 <goron> dcoutts: or just substitute it with undefined?
06:39:24 <goron> dcoutts: I guess you are right. Everyone wanting such things just builds its own compiler. 
06:39:34 <Lemmih> tibbe: It can be useful when working with the FFI or hacks such as HLists.
06:40:26 <tibbe> I see
06:40:30 <shapr> bringert: thanks!
06:44:32 <bringert> does anyone know what the deal with ghc --make and --main-is? I can't get to work when the module name is something other than Main
06:45:00 <bringert> eh, add verbs and pronouns to the previous sentence as you see fit
06:45:53 <goron> bringert: --main-is means the main function name
06:45:58 <goron> bringert: not the module name
06:46:09 <eivuokko> Qualified name, iirc.  Like Foo.bar
06:46:32 <bringert> goron, eivuokko: GHC docs say that you can use a module name: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-linker
06:47:32 <bringert> anyway, both --main-is=Foo and --main-is=Foo-main give me "Warning: output was redirected with -o, but no output will be generated because there is no Main module."
06:47:33 <goron> bringert: An qualified name A.foo. GHC assumes that the main function is A.foo.
06:47:55 <bringert> goron: or "An module name A. GHC assumes that the main function is A.main."
06:47:55 <goron> bringert: Foo-main is not a valid name
06:47:55 <shapr> Yeah, isn't it Main.main or Foo.foo ?
06:48:13 <dcoutts> tibbe, it's useful for type level computations, especially with user-defined kinds
06:48:21 <goron> bringert: It must start with a non-uppercase symbol.
06:48:22 <bringert> goron: eh, sorry, irc typo, that should be --main-is=Foo.main
06:48:31 <eivuokko> (and flag is -main-is, no double dash, if that matters)
06:48:53 <dcoutts> goron, yeah, there are various ways you could hack it, but that's kind of the point, it's not a simple syntactic sugar that just translates locally.
06:49:20 <dcoutts> goron, but for DSLs syntactic sugar is probably all one needs
06:49:23 <eivuokko> But dunno, I do recall changing main working for me sometime in past, tho.
06:49:48 <bringert> eivuokko: yeah thanks, it should be -main-is= according to the docs, but it still gives the same error
06:50:11 <goron> bringert: I will test it here for you, because I almost can't believe it doesn't work.
06:50:19 <bringert> goron: thanks
06:50:29 <bringert> I've probably done something stupid
06:50:55 * Philippa reads up
06:51:25 <Philippa> tibbe: the problem with haskell-meets-C is you lose a lot of guarantees you'd have in C land by a) not being able to predict when thunks're forced and b) not knowing how big thunks are
06:51:56 <goron> ghc --make Test.hs -main-is=Foo.foo works
06:52:09 <bringert> goron: i'm using ghc 6.4, what do you have?
06:52:14 <goron> module contents: module Foo where
06:52:14 <goron> foo = putStrLn "foobar"
06:52:27 <goron> The Glorious Glasgow Haskell Compilation System, version 6.5
06:52:31 <bringert> ah
06:52:34 <bringert> that might be it
06:52:53 <Pegazus> hi, i'm continuing my "study" of lambda function if someone remembers from yesterday... and i wanted to ask, how do you guys "understand" that functions... (i mean if i make the replaces the functions works, but i "can't" understand in my mind how they do that, i mean, if i read a function, i have no idea what it might do if i don't execute it, and may be after that neither) can anyone help me understanding how to "read" or "think" in l
06:52:59 <goron> bringert: I also have 6.4
06:53:04 <goron> bringert: I will test it with that too
06:53:18 <DeliQ> what is going to be new in 6.5 ?
06:53:26 <hoan> Pegazus: the way i did it was to just practice some substitutions
06:53:47 <goron> /usr/bin/ghc-6.4.1 --make Test.hs -main-is=Foo.foo
06:53:48 <goron> Chasing modules from: Test.hs
06:53:48 <goron> Compiling Foo              ( Test.hs, Test.o )
06:53:50 <hoan> which is just executing it anyway ;}
06:53:57 <goron> bringert: It Just Works (TM)
06:54:02 <bringert> weird
06:54:05 <Pegazus> O_o
06:54:07 <Pegazus> thx
06:54:08 <Pegazus> any other idea?
06:54:12 <tibbe> Philippa, yes, there are probably a bunch of good reasons why nobody (to my knowledge) has done it. it's appealing to me none the less, I could skip on lazy evaluation though, I wan't aware of the second problem you mentioned (i.e. I have 
06:54:24 <bringert> ah, you have 6.4.1
06:54:26 <tibbe> Philippa, * I don't know how to implement such a language yet
06:54:31 <bringert> I'll install 6.4.1 then
06:54:48 <Pegazus> is executing lambda functions
06:54:58 <Pegazus> just do the "sintactical" replace of the "parameters"?
06:55:07 <Philippa> if you're happy to go with strict evaluation then the only hard question is whether you're happy with a garbage collector or not IMO
06:55:43 <pejo> DeliQ, Simon Peyton Jones has some recent paper describing some of the stuff they're working on putting in. ghclib is probably another one of those noticable things to the end user. (That isn't in 6.4, is it?).
06:56:03 <goron> pejo: Don't think so.
06:56:05 <Philippa> the thing I mentioned about thunk size was partly because it's the sort of thing that really needs to be specified to make a language usable as a C replacement
06:56:06 <DeliQ> hmm, don't know pejo
06:56:18 <DeliQ> pejo: you have a link for me ?
06:56:25 <DeliQ> to simons paper
06:56:47 <pejo> DeliQ, www.research.microsoft.com/~simonpj
06:57:01 <DeliQ> he's at microsoft ? :P
06:57:12 <goron> DeliQ: It's the only good software MS makes.
06:57:29 <pejo> DeliQ, so is Simon Marlow, and Luca Cardelli, and lots of other folks.
06:57:33 <Pegazus> <Philippa> the thing I mentioned about thunk size was partly because it's the sort of thing that really needs to be specified to make a language usable as a C replacement --> you want haskell to replace C? O_o
06:57:41 <isaacd> bringert: a simple test of -main-is for both 6.4.1 and 6.4 worked for me. 
06:58:08 <isaacd> Probably there's something slightly more unusual about your situation
06:58:08 <DeliQ> hmmm.. i'm going to read his paper..
06:58:17 <bringert> isaacd: was that with a different function name or a different module name?
06:58:53 <goron> Maybe it only forks for Foo ;)
06:58:58 <goron> er works
06:58:59 <isaacd> bringert: ghc --make -main-is Foo.foo Foo.hs
06:59:10 <bringert> wtf
06:59:19 <isaacd> module Foo where foo = putStrLn "foobar"
06:59:43 <bringert> weird, ok, I'll try to figure out what's wrong on my machine
06:59:52 <tibbe> Philippa, GC is darn nice but I'm not sure if it's acceptable at the C level
06:59:57 <Pegazus> if i have m n x in lambda is like (m n) x isn't it?
07:00:25 <tibbe> Philippa, but is it really possible to make the programmer responsible to free things captured in closures etc
07:00:55 <Pegazus> you are talking about a Garbage Collector for C?}
07:01:11 <Philippa> no, we're not
07:01:14 <Pegazus> k
07:01:44 <dcoutts> GC is pretty essential for compositional programming
07:01:48 <Philippa> tibbe: read up on region systems and region inference. You might find linear types and/or uniqueness types interesting too
07:02:07 <Philippa> I suspect region polymorphism could be good enough in a lot of cases
07:02:14 <dcoutts> f . g can't really be done if you have to free the intermediate value
07:02:41 <Philippa> depends - is the intermediate linear? :-)
07:03:49 <goron> Then you get something like Joy?
07:03:56 <tibbe> Philippa, I will, thanks
07:05:09 <Pegazus> why is the function MULT = \m n f. m (n f) and not MULT = \m n. m n or \m n f x. m n f x. If i do the "substitution" or "execution" it obviusly doesn't work (the ones i said), but i don't understand why the additional f there is needed in m (n f) can anyone help me a little with this?
07:05:40 <pejo> tibbe, is the unaccetable aspect of GC that it's not what C-programmers are used to, or is it that it is "unpredictable", or something else?
07:06:11 <Pegazus> what is GC?
07:06:13 <Philippa> laregly predictability
07:06:18 <Philippa> largely, even
07:06:21 <tibbe> pejo, I don't care much about what they are used to as long as it (the language) could occupy the same space as C
07:06:22 <Philippa> Pegazus: Garbage Collection
07:06:38 <Pegazus> what are you discussing so?
07:06:55 <Philippa> Pegazus: that sentance doesn't make sense
07:07:03 <Pegazus> what thing are you discussing?
07:07:11 <Pegazus> what's your "topic"?
07:07:13 <shapr> tibbe: Do you mean systems implementation? Like writing a kernel?
07:07:16 <Philippa> * tibbe wants to write a Haskell meets C language
07:07:23 <shapr> Or do you mean portable asm?
07:07:35 <Philippa> shapr: if you're going where I think you're going, being able to write the GC as well is important :-)
07:07:45 <shapr> Where was I going?
07:08:01 <shapr> House & C-- ?
07:08:03 <Pegazus>  tibbe wants to write a Haskell meets C language --> what does that means?
07:08:03 <pejo> Philippa, I believe you can make a predictable GC, if you have a sane language. For C, it's a lot harder, I bet.
07:08:04 <Philippa> I don't know for certain. But there was a certain housiness...
07:08:19 <goron> If you want predictability use Real time GC.
07:08:30 <Philippa> pejo: I suspect it's quite difficult to achieve sufficient values of predictable without also raising requirements for memory usage
07:08:40 <shapr> Wouldn't incremental GC improve predictability in GHC?
07:08:54 <shapr> That would be a nice SoC project.
07:09:07 <tibbe> shapr, actually I don't really know yet, I just found the idea appealing
07:09:09 <Philippa> also, *we're not talking about C*
07:09:27 <Philippa> we're talking about a language intended to take a C-like role, that doesn't necessarily mean suffering from C's all-but-lack-of type system
07:09:46 <Pegazus> O_o
07:09:47 <pejo> Phillippa, hm. Yeah, you get a scheduling problem instead then. "Do we have enough time to both run our tasks and garbage collect them".
07:09:50 <Pegazus> what about C++? :)
07:09:52 <tibbe> perhaps something that could work well together with C would also work,
07:10:05 <shapr> Yeah, but what facets of the C-like role? Systems implementation, bit level control of memory, or what?
07:10:21 <Philippa> all of them
07:10:41 <shapr> Hm, I'd probably go for something like Joy.
07:10:45 <shapr> As goron suggested.
07:10:56 <pejo> shapr, if your GC isn't incremental you need to have time to GC the entire heap, every time you trigger a gc. 
07:11:13 <Philippa> even if it is incremental you need to be able to GC "fast enough"
07:11:15 <shapr> Yeah, and that's just not realistic.
07:11:34 <pejo> Ph, or one could show that each increment is small and bounded. 
07:11:34 <Philippa> although what you've said's modulo generations I assume
07:11:41 <shapr> Ok, someone who remembers their login for the HaskellWiki, "add non-stop GC to GHC" ?
07:12:05 <shapr> pH ? Jan-Willem's parallel & strict Haskell?
07:12:10 <Philippa> pejo: You still have to be able to collect enough garbage to not run out of both heap and time to GC in
07:12:14 <pejo> shapr, no tab completion, heh.
07:12:17 <shapr> oh :-)
07:12:38 <pejo> shapr, and I think I keep mis-spelling her name, all the time. Boggle.
07:12:47 <shapr> That's one nice thing about region allocation, when you're done you can just free it all at once.
07:13:10 <Philippa> just about, yeah. In practice you'll often end up copying a value or two out first and it starts to feel a lot like localised GC...
07:13:12 <shapr> Has anyone tried hydrib systems that integrate region allocation chunks into a more standard top level GC?
07:13:23 <shapr> Well yeah, what's wrong with localised GC?
07:13:30 <Philippa> I think it's being done the other way round
07:13:37 <Philippa> John Meacham doesn't fancy implementing it :-)
07:14:02 <pejo> Philippa, didn't you include time twice in that statement? You need to have enough idle time to not run out of heap, yeah.
07:14:07 <shapr> Getting JHC up to H98 would be another thing for SoC.
07:14:16 <dcoutts> that'd be cool
07:14:18 <tibbe> I'm coming from: C is unsatisfactory, I want something better, is it possible or are we stuck with C forever for low level work
07:14:26 <mnislaih> shapr: that would be cool
07:14:41 <mnislaih> or what dcoutts said :P
07:14:45 <olliej> dcoutts: does H98 include higher ranked/kinded types?
07:14:48 <Philippa> pejo: being able to predict that without knowing your GC algorithm intimately strikes me as difficult
07:14:51 <pejo> tibbe, now you're talking industry though. The issue there isn't that there isn't anything better out there, it's that they are very conservative.
07:14:55 <Philippa> olliej: those aren't the same thing
07:15:03 <tibbe> + I'm curious
07:15:05 <shapr> Miasma(?) was a scheme assembler implemented for the Vapour OS.
07:15:05 <Philippa> it has higher-order kinds, it doesn't go beyond rank-n
07:15:15 <olliej> Philippa: i know :)
07:15:27 <Philippa> pejo: yes and no. There's not a lot of recognisable stuff that's significantly better enough...
07:15:40 <Philippa> er, rank-1 not rank-n
07:15:43 <Philippa> thinko!
07:15:46 <olliej> Philippa: perhaps better phrased are higher ranked or higher kinded types part of h98" :) 
07:16:01 <dcoutts> olliej, I think they are not
07:16:05 <tibbe> perhaps bit fiddling meets high-order functions would be a step in the "right" direction
07:16:08 <pejo> Philippa, oh, you certainly need to know your gc algorithm very well. And one can trivially construct a program which beats the shit out of any fix GC. 
07:16:19 <olliej> yeah, however i waws arguing with Saulzar over Monads
07:16:22 <Philippa> dcoutts: we have higher-order kinds. Type constructors that take type constructors as parms
07:16:39 <dons> ?kind Either
07:16:40 <olliej> because they seem to work in non-extensions mode in ghc
07:16:41 <lambdabot> * -> * -> *
07:16:41 <pejo> Philippa, and of course it won't work if the first thing you do is allocate more heap than there is available in total - no gc in the world can solve that problem. So it wont' work for all programs.
07:16:45 <Philippa> pejo: the latter doesn't count unless it can't be translated into one that doesn't :-)
07:16:59 <shapr> g'day dons 
07:17:08 <Philippa> ?kind StateT
07:17:09 <dcoutts> ok, yeah we have kinds a ::= *; a -> a
07:17:10 <lambdabot> * -> (* -> *) -> * -> *
07:17:20 * olliej waits for his compiler to explode
07:17:41 <Philippa> olliej: they're two very different things. You don't need rank-n types for monads
07:17:46 <dons> ?kind Control.Monad.RWS.RWS.RWST
07:17:47 <Philippa> anyway, I gotta go
07:17:47 <lambdabot> Couldn't find qualified module.
07:17:47 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
07:17:47 <pejo> Philippa, which was the latter? 
07:17:54 <dons> ?kind Control.Monad.RWS.RWST
07:17:56 <Philippa> "And one can trivially construct a program which beats the shit out of any fix GC. "
07:17:56 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
07:18:18 <Philippa> g2g, really. Got someone due here shortly and I'm neither showered nor dressed
07:18:21 <dons> heya shapr. 
07:18:30 <olliej> Philippa: yes, Monad uses higher kinded types
07:18:35 <pejo> Philippa, well, go. I have nothing but time. :-)
07:18:45 <olliej> rather than higher rank
07:19:38 <olliej> dcoutts: victory
07:19:44 <olliej> dcoutts: i have cairo goodness
07:19:57 <dcoutts> olliej, well done, what did you need to do?
07:20:10 <olliej> buld gtk2.8, glib, pango, atk :)
07:20:58 <dcoutts> all in your home dir
07:21:16 <dcoutts> and you've got gtk2hs built against those?
07:21:21 <olliej> dcoutts: /local
07:21:26 <dcoutts> ah right
07:21:27 <olliej> dcoutts: yeah
07:21:30 <dcoutts> nice
07:21:42 <bringert> goron,isaacd,eivuokko: I found the -main-is problem: I used "ghc --make -o test -main-is=Test.main Test.hs"
07:21:42 <olliej> dcoutts: homedir is on a 10mbit nfs link
07:21:47 <bringert> not the "="
07:21:48 <olliej> dcoutts: hurrah
07:22:05 <bringert> eh. note, stupid wireless keyboard
07:22:29 <dcoutts> olliej, ah, my dept has a similar setup of tiny nfs homedir, annoying sometimes
07:22:46 <olliej> dcoutts: i have a few gig i think
07:22:58 <olliej> dcoutts: but at 10mbit it becomes very painful
07:22:58 <bringert> -main-is Test.main works fine, -main-is=Test.main and --main-is=Test.main just fail with complaining about the option syntax
07:23:30 * olliej stabs compiler -- die dammit
07:24:07 * lypie stabs the planet, die damnnit
07:24:16 <olliej> lypie: :p
07:24:27 * shapr fstabs partitions, mount dammit
07:24:35 <olliej> shapr: :)
07:25:04 <lypie> hehe
07:25:10 <olliej> woot
07:25:12 <olliej> death
07:25:28 * olliej wanders through stack trace
07:26:23 * vincenz doesn't tell olliej that it's a recursive tailcall
07:27:06 <olliej> vincenz: it's .NET
07:27:20 <olliej> vincenz: nothing generates tailcalls as they're slower than a normal call
07:27:23 <olliej> :)
07:29:59 <vincenz> olliej: wtf
07:30:05 <vincenz> olliej: tailcalls aren't slower
07:34:41 <olliej> vincenz: on .NET they are
07:35:11 <vincenz> odd
07:35:19 <olliej> vincenz: it's apparently due to the way they have to deal with security info (as that's per frame on the CLR)
07:35:49 <olliej> i was talking to them a few months ago, they said they were indeed trying to improve the performance of them :)
07:36:39 <vincenz> but a call requires a stack push, while a tailcall modifies arguments in place, so you have better locality
07:36:46 <vincenz> besides it's just a goto then
07:36:49 <vincenz> instead of a call/ret
07:37:19 <olliej> vincenz: on .NET they have to rebuild the security info
07:37:36 <olliej> because each frame may have different levels of security
07:37:47 <vincenz> heh
07:38:13 <lypie> sounds like something that could be fixed if they just hired me
07:38:25 <olliej> it is technically much better than java's security model -- although we can see it has problems :)
07:38:55 <lypie> wtf is a security model?
07:38:59 <lypie> why would you want one of them? :)
07:39:00 <lypie> ;)
07:39:13 <olliej> as it is my compiler converts any directly recursive functions into iteration
07:39:31 <dcoutts> olliej, sounds good
07:39:38 <olliej> but it can't do that for tail recursion into a seperate function
07:39:52 <olliej> which means you can run out of stack space
07:39:58 <lypie> inline teh 'ucker!
07:40:01 <olliej> but i "solved" that problem :)
07:41:03 <olliej> lypie: but you can't inline a thunk's evaluation
07:41:08 <olliej> :p
07:41:37 <olliej> you catch the stack overflow, and then spawn a new thread, and carry on where you left off :)
07:43:24 <olliej> dcoutts: can i make a suggestion?
07:43:32 <dcoutts> olliej, sure
07:43:56 <olliej> dcoutts: in the cairo demos reorder the Makefile, so it creates the non-gtk demos first
07:44:35 <dcoutts> olliej, or make it only build the non-gtk ones if it hasn't built the cairo-gtk integration code
07:44:41 <olliej> yeah
07:44:46 <dcoutts> good idea
07:44:49 <olliej> the reordering one is probably easiest :)
07:45:27 <olliej> problems with .NEt #1: the debugger is slow as a dog when dealing with heavily recursive code
07:45:39 <olliej> a 20 year dog
07:45:47 <olliej> with 2 legs
07:45:55 <olliej> that's just been hit by a truck
07:46:48 <lypie> lol
07:47:00 <dcoutts> olliej, that's because "real" hackers don't use recursion
07:47:09 <olliej> hehe
07:47:20 * lypie always codes everything iteratively
07:47:23 <olliej> i use a delightful mix 
07:47:25 <Philippa> or languages higher-level than C
07:47:29 <Philippa> and that only when they have to
07:47:35 <olliej> i have iterative code that calls itself recursively
07:47:48 <lypie> Philippa: i code ruby, and never write recursive code
07:48:05 <olliej> i don't write code
07:48:15 <olliej> i design
07:48:17 <olliej> hahahahaa
07:48:18 <dcoutts> heh
07:48:41 <olliej> Saulzar: can vouch for the "quality" of some of my code
07:48:58 <olliej> s/: / /
07:49:00 <lypie> i don't write code
07:49:04 <lypie> but thats cus i've got too many dvds
07:49:21 <olliej> i don't write code, i swear at the computer until it works without me doing anything
07:49:23 <Saulzar> Hehe, when there are more * and ++ than letters you worry.
07:49:40 <olliej> Saulzar: :)
07:49:47 <lypie> Saulzar: nah, just indicates that olliej can do arith ;)
07:49:56 <olliej> Saulzar: i still have that code 
07:50:17 <olliej> lypie: he's referring to the dailywtf-worthy function i wrote
07:50:37 <lypie> olliej: the one you pointed me to and i grokked?
07:50:41 <lypie> 0x100 etc?
07:50:55 <olliej> yup
07:51:01 <lypie> wasn't dailywtf worthy
07:51:20 <lypie> noone thats been on dailywtf would understand it :)
07:51:27 <olliej> hehe
07:53:52 <Lemmih> wchogg: Hiya.
07:54:38 <wchogg> Lemmih:  That was fast.
07:56:32 <lypie> olliej: is it a bad sign that i use frontrow to change the current track more than i use itunes?
07:57:15 <olliej> no
07:57:19 <olliej> that's what i do
07:57:23 <olliej> hooray for remotes
07:57:45 * lypie grins
07:57:46 <lypie> good
07:57:49 * lypie fels beter
07:57:53 * lypie feels better also
07:58:05 <Lemmih> wchogg: C-- could use some more optimizations.
07:58:14 <lypie> poor beter, i feled him :(
07:58:37 <olliej> *sigh*
07:59:03 <Lemmih> wchogg: I'll find some info, one moment.
07:59:09 <wchogg> Lemmih:  Thanks.
07:59:50 <tibbe> what's the current state of C--?
08:00:32 <lypie> -1
08:01:29 <Lemmih> wchogg: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg09278.html
08:02:18 <Lemmih> wchogg: Specifically: A) Generate C-- with native calls, with an implicit C-- stack, and B) Perform CPS conversion, to eliminate all calls in favour of jumps.
08:03:44 <pejo> tibbe, Ramsey presented a paper on POPL that seemed related, so it looks like it's making progress. But the documentation 6 months ago seemed to claim that ia32 is the only architecture that is in good condition.
08:03:48 <wchogg> Lemmih:  Thanks, I appreciate it.  That sounds pretty interesting actually.
08:03:52 <Lemmih> wchogg: Were you thinking of the performance of the generated code or GHC itself?
08:04:27 <araujo> Hi!
08:04:28 * araujo back from trip
08:04:38 <Lemmih> Hiya araujo.
08:04:43 <dcoutts> where was that araujo?
08:04:57 <araujo> Hello Lemmih , dcoutts !
08:05:13 <araujo> dcoutts, went to another state :-)
08:05:14 <wchogg> Lemmih:  Y'know, I had originally been thinking of ghc but I suppose generated code could be an easier way to improve the performance.  Mostly I just want to make it easier to use haskell for science.
08:05:58 <olliej> Saulzar: !!!
08:06:08 <olliej> Saulzar: it compiled that damn instance def!
08:06:28 <wchogg> Lemmih:  Hrmm...there might have been two ways to parse your question, but I took it to mean whether the optimizations were at the high level or the intermediate language.
08:06:38 <Saulzar> Congrats :)
08:07:45 <olliej> it produces... inefficient.. code, but still
08:07:55 <olliej> it still dies in GHC.Real, but it's getting there
08:10:22 <olliej> Saulzar: at a guess it's trying to treat a datatype as a function
08:10:36 <olliej> and try to get the type arguments out
08:15:11 <Lemmih> wchogg: Note that improving the C-- situation would almost only benefit strict haskell code.
08:15:45 <greenrd> I am looking for a seminal old paper on referential transparency
08:16:05 <greenrd> I've read "Why Functional Programming Matters" - any other suggestions?
08:16:55 <greenrd> i.e. a paper which says "Here's why you should program in a referentially-transparent or pure programming language"
08:17:01 <shapr> I can't think of any papers that talk about the benefits of that specifically.
08:17:24 <greenrd> OK, papers that talk about that amongst other things?
08:17:25 <shapr> But I can tell you about my experiences with J2EE, and I can tell you my idea about 'abstractional complexity.'
08:17:29 <greenrd> heh
08:17:35 <greenrd> I'm afraid that's not applicable here
08:17:42 <shapr> I think it is, actually.
08:18:00 <greenrd> I have to talk about "two or three seminal papers" for a seminar on Tuesday, and provide citations
08:18:01 <shapr> When I'm writing a program I have to keep in mind all the moving pieces.
08:18:02 <shapr> Oh
08:18:34 <greenrd> One of my papers is going to be about pure functional programming, and the other one or two will be about transactions.
08:19:00 <shapr> In that case, why not do a google search for "why fp matters" +papers +(classic OR seminal OR ground breaking)
08:19:07 <greenrd> ok
08:19:30 <shapr> Sadly, that's the syntax for altavista, but I know you can do the same thing with google advanced search.
08:20:38 <greenrd> + is redundant on google because it always includes all terms
08:20:41 <shapr> You could also check out scholar.google.com and search for referential transparency. Scholar.g.c keeps track of references, so you could find the paper with the most backlinks to find 'seminal.'
08:20:53 <shapr> It doesn't if you use the advanced search.
08:21:03 <greenrd> oh, I didn't know that
08:21:18 <shapr> One of the fields in "One or more of these words:"
08:21:43 <shapr> s/in/is
08:24:07 <shapr> Hiya conal, how's code?
08:26:18 <dcoutts> anyone got any idea how to find out which snapshot of cabal ghc-6.4.2 is using?
08:26:44 <dcoutts> there's no obvious 1.1.4 tag as far as I can see
08:32:31 <conal> hey shapr.  pretty great these days. 
08:33:08 <conal> you?
08:33:17 <shapr> Hacking on cabal-get, it's fun!
08:33:59 <conal> cool.  i haven't cabal'd at all yet.  looks awfully useful.
08:37:34 * dcoutts grumbles at cabal versioning & releas numbering
08:37:58 <dcoutts> so ghc uses cabal-1.1.4 but there is no such thing - at least not as a release
08:38:08 <conal> i've been working on Pajama (http://conal.net/Pajama), which is a re-write of Pan with various improvements, especially running in web pages (via java).  also non-syntactic end-user gestural programming (http://conal.net/papers/icfp06-submission).
08:38:10 <dcoutts> 1.1.4 is a continuous ongoing dev version
08:38:27 <dcoutts> there are may different cabal versions all called 1.1.4 :-(
08:38:32 <dcoutts> may/many
08:39:41 <conal> I'd love to get some Pajama test driving and feedback from #haskell folks.  Anyone here willing to give it a try?  Just visit http://conal.net/Pajama and try out the applets.
08:41:00 <conal> Pajama applets used to require java 1.5, but now 1.4 is enough.
08:43:53 <wchogg> Lemmih:  If you're still there, sorry, I had to help my wife get ready for work.  I think perhaps I should take my questions and interests onto the ghc-users mailing list?
08:52:52 <Pegazus> shit
08:53:01 <Pegazus> fixed point operator cannot be used in haskell :(
08:53:26 <neologism> hows that?
08:53:27 <mnislaih> you sure? I thought it was indeed
08:53:34 <tromp> not explicitly
08:53:58 <tromp> @hoogle fix
08:53:59 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
08:53:59 <lambdabot> Control.Monad.Fix :: module
08:53:59 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
08:54:35 <isaacd> > take 20 $ fix (3:)
08:54:36 <lambdabot> [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]
08:55:22 <neologism> why cannot you just define it?
08:55:27 <musasabi> Cabal should support a version syntax like "1.0-<date>" or some way to use dates in version numbers automatically.
08:55:48 <isaacd> neologism: IIRC it would have an infinite type
08:55:58 <tromp> > let fix f = f (fix f)
08:55:59 <lambdabot>  parse error on input `}'
08:56:20 <tromp> you can define it only recursively
08:56:38 <neologism> isaacd: y f = f (y f)
08:56:38 <neologism> primes = y (\f (x:l) -> [x] ++ f (filter ((/= 0).(`mod` x)) l)) [2..]
08:56:42 <neologism> from working code
08:57:02 <dcoutts> grr, there are even API changes between ghc's cabal-1.1.4 and the current darcs version of cabal-1.1.4
08:57:13 <dcoutts> ghc's cabal-1.1.4 seems several months old
08:57:20 * dcoutts predicts havoc
08:58:03 <isaacd> a-ha  http://www.haskell.org/hawiki/FixedPointCombinator
08:58:29 <Pegazus> what means let and what means fix?
08:59:41 <neologism> > let foo = 1 in foo
08:59:42 <lambdabot> 1
09:00:40 <Pegazus> *Main> map (facRec $ undefined)  [0..]
09:00:41 <Pegazus> [1,*** Exception: Prelude.undefined
09:00:41 <Pegazus> *Main> map (facRec . facRec $ undefined)  [0..]
09:00:41 <Pegazus> [1,1,*** Exception: Prelude.undefined
09:00:41 <Pegazus> *Main> map (facRec . facRec . facRec $ undefined)  [0..]
09:00:41 <Pegazus> [1,1,2,*** Exception: Prelude.undefined
09:00:43 <Pegazus> *Main> map (facRec . facRec . facRec . facRec $ undefined)  [0..]
09:00:45 <Pegazus> [1,1,2,6,*** Exception: Prelude.undefined
09:00:47 <Pegazus> that's really nice O_o
09:03:51 <bolrod> because?
09:04:04 <bolrod> @type facRec
09:04:05 <lambdabot> Not in scope: `facRec'
09:04:22 <bolrod> @hoogle facRec
09:04:23 <lambdabot> No matches found
09:04:49 <bolrod> guess you have to find a better defenition then
09:05:03 <isaacd> bolrod: from http://www.haskell.org/hawiki/FixedPointCombinator
09:05:07 <isaacd> I assume
09:05:36 <isaacd> facRec :: (Integer -> Integer) -> (Integer -> Integer)
09:05:37 <isaacd> facRec f n | n == 0    = 1
09:05:37 <isaacd>            | n  > 0    = n * (f $ n-1)
09:05:37 <isaacd>            | otherwise = error "Negative Index"
09:06:26 <Pegazus> what is let used for?
09:06:54 <isaacd> Pegazus: for local bindings
09:07:20 <Pegazus> what's a local binding?
09:07:22 <bolrod> Pegazus: well.. that is obvious since you map it to 0, n==0  thus 1
09:08:09 <SamB> > let x = 3 in x * 2
09:08:10 <lambdabot> 6
09:08:27 <isaacd> f x y z = let sumz = x + y + z in sumz / (sumz + z)  -- stupid example
09:08:44 <bolrod> yeah
09:08:48 <SamB> > (let x = 3 in (), x)
09:08:49 <lambdabot>  Not in scope: `x'
09:09:08 <isaacd> > (let x = 3 in ((), x))
09:09:09 <lambdabot> ((),3)
09:10:12 <isaacd> A local binding is like a definition that you can only use within a single part of a function.
09:11:07 <Pegazus> a single part of a function? how's that?
09:11:27 <Pegazus> and what is the in keyword for?
09:11:28 <isaacd> Its definition usually uses e.g. the function's arguments, so it couldn't trivially be defined at top level.
09:11:51 <Pegazus> what's the difference with where?
09:12:09 <isaacd> Pegazus: 'in' denotes the end of the local definitions and the beginning of the scope where the expression's value is computed.
09:12:25 <Pegazus> k
09:12:28 <SamB> Pegazus: the definitions in a where scope over the entire function/case
09:12:32 <alec> > (3, let x = 3 in x)
09:12:33 <lambdabot> (3,3)
09:12:45 <Pegazus> so i can put let anywhere i want?
09:12:46 <isaacd> Pegazus: let can be used in mostly the same places as where, it's just syntactically in a different place
09:12:54 <Pegazus> mm
09:12:58 <Pegazus> but can'y i replace
09:13:14 <SamB> > (case 3 of 3 -> x; _ -> y where x = 1, y = 2)
09:13:15 <lambdabot>  parse error on input `='
09:13:22 <Pegazus> let Blah in Blah2 with \all vars used in let -> Blah     and then Blah2
09:13:23 <Pegazus> ?
09:13:25 <SamB> > (case 3 of 3 -> x; _ -> y where x = 1; y = 2)
09:13:27 <lambdabot>  Not in scope: `x'
09:13:57 <isaacd> > (case 3 of 3 -> x where x = 1; _ -> y where y = 2)
09:13:57 <lambdabot>  parse error on input `->'
09:14:18 <SamB> huh
09:14:27 <isaacd> > (case 3 of { 3 -> x where { x = 1 }; _ -> y where {y = 2} } )
09:14:29 <lambdabot> 1
09:14:44 <SamB> okay, I'm confused ;-)
09:14:50 <isaacd> oh, ambiguity of semicolon.
09:14:56 <SamB> let is much more predictable!
09:15:06 <isaacd> Normally layout would probably clear things up.
09:15:27 <SamB> for instance, this isn't allowed (though it works with lambdabot):
09:15:33 <SamB> > x where x = 1
09:15:34 <lambdabot> 1
09:15:44 <Pegazus> let x = 1 in x
09:15:47 <Pegazus> is valid?
09:15:56 <SamB> yes
09:15:56 <isaacd> Pegazus: yes
09:16:06 <SamB> though kind of silly ;-)
09:16:29 <Pegazus> but why not use instead: (\x -> 1) x
09:16:33 <Pegazus> (\x -> 1) x
09:16:35 <Pegazus> > (\x -> 1) x
09:16:36 <lambdabot>  Not in scope: `x'
09:16:38 <Pegazus> mm
09:16:56 <mwc> > (\x -> 1) ()
09:16:57 <SamB> > (\x -> x) 1
09:16:57 <isaacd> 'where' is attached to a single clause of a function definition or a case (but to all of its guards, if it uses them)
09:16:57 <lambdabot> 1
09:16:58 <lambdabot> 1
09:17:10 <Pegazus> > (\ -> 1) ()
09:17:11 <lambdabot>  parse error on input `->'
09:17:14 <SamB> isaacd: oh, is that what it was ;-)
09:17:20 <isaacd> *its -> the clause's
09:17:20 <SamB> isaacd: I'm so relieved ;-)
09:17:20 <Pegazus> > (\x -> 1) (something defined)
09:17:22 <lambdabot>  Not in scope: `defined'
09:18:03 <mwc> @type (\x -> 1)
09:18:05 <lambdabot> forall t t1. (Num t) => t1 -> t
09:18:31 <isaacd> let defs... in expr   simply is part of any expression
09:25:20 <bolrod> does haskell have some library for an arbitrary precision float?
09:26:50 <neologism> bolrod: I dont think that makes sense
09:27:03 <neologism> there are irrational numbers so you'd end up pretty soon
09:28:43 <bolrod> urh
09:28:46 <bolrod> how does it not make sense
09:28:57 <bolrod> there sure are libraries for other languages I guess
09:28:59 <bolrod> BigNum ?
09:29:07 <Pegazus> you can have irrational numbers in haskell
09:29:08 <neologism> PI would take infinite memory etc.
09:29:13 <Pegazus> or in any computer language
09:29:18 <Pegazus> <neologism> PI would take infinite memory etc. --> it wouldn't
09:29:30 <neologism> hows that?
09:29:36 <Pegazus> you can save in the computer
09:29:42 <Pegazus> any Finite number of irrational numbers
09:29:42 <Saulzar> Hmm, what is Data.Ratio?
09:29:42 <Pegazus> :)
09:29:48 <Pegazus> numering them
09:30:11 <neologism> ?
09:30:16 <bolrod> urh  you can't get an irrational number by deviding 2 natural numbers
09:30:16 <neologism> I somewhat dont understand
09:30:27 <Pegazus> <bolrod> urh  you can't get an irrational number by deviding 2 natural numbers --> youu can save it like
09:30:28 <Pegazus> "PI"
09:30:33 <Pegazus> and you know that number is "PI"
09:30:39 <bolrod> I just want a float with an arbitrary amount of decimals
09:30:40 <neologism> :)
09:30:47 <Pegazus> and 3 * "PI" = "3PI"
09:31:05 <mahogny> arbitrary precision real numbers are possible to implement, but not as floats
09:31:12 <Pegazus> hehe
09:31:15 <neologism> bolrod: I think you can use fractions...
09:31:41 <bolrod> that may be possible.. I'll have to check
09:31:43 <neologism> 123/1000 -> precision upto 0.001 etc.
09:31:45 <Saulzar> > 55555555555555555555555555555555 % 10000000000000000000000000000
09:31:46 <mahogny> tibbe, a local? gothenburg? :)
09:31:46 <lambdabot> 11111111111111111111111111111111%2000000000000000000000000000
09:32:00 <bolrod> still.. if you do a search on it,  you'll find libraries for C
09:32:02 <tibbe> mahogny, aye ;)
09:32:34 <mahogny> tibbe, chalmers?
09:33:24 <Saulzar> Data.Ratio does fractions, at least
09:33:30 <tibbe> yup
09:33:47 <tibbe> at least for 4 more weeks, although I'll be back in december to present my thesis
09:33:55 <tibbe> then google :D
09:34:00 <mahogny> ooh
09:34:16 <SamB> infinite precision numbers are doable too, but equality is totally undecidable
09:34:22 <tibbe> m.sc. thesis that is, not phd
09:35:23 <vincenz> tibbe: what's your thesis on?
09:35:25 <mahogny> SamB, that problem is not unique for arbitrary precision :)
09:35:55 <tic> tibbe, do you have a younger brother named Tobias?
09:36:06 <bolrod> arbitrary precision doesn't mean infinite precision?
09:36:43 <tibbe> vincenz, actually I don't know yet, I'll be doing at a company (which is customary for "engineering" degrees in sweden), probably something on OO since I'll be writing OO software, although I'd like to bring in comparisons with other things (i.e. FPL)
09:36:49 <tic> tibbe, or actually just a brother, '82
09:37:01 <vincenz> tibbe: I thought you said, 4 more weeks to te end
09:37:06 <tibbe> tic, nope, what program/year?
09:37:22 <kep> re all
09:37:23 <vincenz> tibbe: OO java or c++?
09:37:30 <tibbe> vincenz, 4 more weeks until I start
09:37:32 * vincenz always needs a m.sc. student
09:37:43 <tic> tibbe, nah, went to school w/ a guy called who's nickname's Tibbe, back in 7th grade. :)
09:37:48 <tibbe> vincenz, I have to spew out Java :/
09:37:50 <tic> tibbe, Kunglv.
09:37:52 <vincenz> tibbe: ah
09:38:10 <tibbe> tic, wasn't me then
09:38:16 <mnislaih> tibbe: what program are you taking ?
09:38:18 <tic> tibbe, probably not. are you D student?
09:38:18 * vincenz is looking for a master student with a strong background in c++ and cs, with a timeframe of 5-6 months to do a thesis with him
09:38:34 <tibbe> tic, SE (i.e. IT program in Swedish)
09:38:35 * tic started working on his thesis three weeks ago.
09:38:45 <SamB> bolrod: arbitrary means finite, but not fixed
09:38:58 <tic> tibbe, aha, an IT stud. ;)
09:38:58 <tibbe> mnislaih, IT-program
09:39:06 <tibbe> tic exactly!
09:39:06 <bolrod> so.. and irrational numbers require infinite precision
09:39:15 <tic> tibbe, 02?
09:39:19 <heof> @pl \i -> let (o,m) = g i in (o, m >>= f)
09:39:20 <bolrod> so equality wouldn't be a problem
09:39:20 <lambdabot> (line 1, column 11):
09:39:20 <lambdabot> unexpected "("
09:39:20 <lambdabot> expecting natural, identifier or "in"
09:39:29 <SamB> so you can't represent irrationals with arbitrary-precision arithmatic
09:39:30 * tibbe thinks the person who decided we should have @itstud email address should be shot
09:39:36 <heof> @pl \i -> (let (o,m) = g i in (o, m >>= f))
09:39:37 <lambdabot> (line 1, column 12):
09:39:37 <lambdabot> unexpected "("
09:39:37 <lambdabot> expecting natural, identifier or "in"
09:39:56 <tibbe> tic, yes
09:40:08 <mnislaih> I got accepted at the 'Dependable Software' Master there at Chalmers
09:40:29 <mnislaih> but I will probably not go. That's why I was asking, I'm still in doubt
09:40:31 <tic> bunch of foreign students taking that program.
09:40:31 <SamB> @pl let fun i = let (o,m) = g i in (o, m >>= f)
09:40:32 <lambdabot> (line 1, column 17):
09:40:32 <lambdabot> unexpected "("
09:40:32 <lambdabot> expecting natural, identifier or "in"
09:40:33 <tic> mnislaih, why?
09:40:34 <metaperl> I have a question about typeclasses. When a type is an instance of class, it must implement the methods of that class, but when it derives a class, then it gets the default implementations of those methods?
09:40:50 <mnislaih> because I got a seriously good scholarship a few weeks ago
09:40:55 <SamB> @pl fun i = let (o,m) = g i in (o, m >>= f)
09:40:56 <lambdabot> (line 1, column 7):
09:40:56 <lambdabot> unexpected "="
09:40:56 <lambdabot> expecting variable, "(", operator or end of input
09:40:57 <tibbe> mnislaih, I've taken some courses together with students from that master program
09:41:03 <basti_> uhm. "deriving" is not a normal operation in haskell, it's just allowed for some special classes.
09:41:06 <mnislaih> so I'll be staying at Valencia and just do a PhD
09:41:20 <mnislaih> and how good is the program in your opiniion tibbe? job expectatives ?
09:41:42 <basti_> it's a helper, not more. instantiating is the normal case and the only one you'll need to understand (you'll use "deriving", but that is rather simple)
09:41:57 <mnislaih> what I don't like about taking on a PhD is that it's 4 years at least, and that it almost forces one to stay in the academia. I think a Master doesn't have those problems
09:42:13 <SamB> metaperl: the Report tells all about the default implementations of those classes. that is, of the standard ones...
09:42:19 <tibbe> mnislaih, I'm not sure, I think Chalmers are seriously lacking in it's below Ph.D. education when it comes to software development teaching (except for some excellent people in the FP sphere)
09:42:45 <mnislaih> tibbe: all I want to know is if I'll get a job in the FP sphere afterwards :)
09:42:47 <tic> I'm curious about the "Agile Development" course in fall.
09:42:58 <mnislaih> Chalmers is big so that's where my hope lies
09:43:00 <tibbe> mnislaih, in academia?
09:43:00 <tic> mnislaih, probably not from DCS.
09:43:09 <mnislaih> not necesarily in academia
09:43:13 <mnislaih> i.e. preferablily not
09:43:34 <tibbe> tic, me too, although I won't be taking it. the people giving it are RUP damaged for life though, or at least so they seem
09:43:38 <mnislaih> tic: you mean, there are other programs more appropiate ?
09:43:51 <tic> mnislaih, for functional programming, I think so.. But I'm not sure, it might be.
09:44:08 <tic> *looks up the Agile course at studentportalen*
09:44:17 <tibbe> mnislaih, Chalmers does have a good name, your particular program will probably be less important
09:44:40 <waern> hmm.. tibbe: we live in the same house :)
09:44:47 <mnislaih> tibbe: What do you mean
09:44:47 <tibbe> oh?
09:44:53 <tibbe> waern, what floor?
09:45:14 <waern> 5
09:45:56 <tibbe> mnislaih, my experience (which is very limited, the only real interview I've had was for Google) is that school and skills (i.e. that you can show on an interview) matters more than your degree
09:46:04 <tibbe> waern, 3
09:46:18 <tibbe> waern, I'll be moving out in 5 weeks though
09:47:06 <waern> oh
09:47:14 <tibbe> mnislaih, the functional programming, advanced functional programming and programming languages are course you would want to take
09:48:38 <tibbe> that sentence didn't come out right
09:48:52 <mnislaih> nah, I understood you
09:49:02 <palomer> oh boy, looks like I'll be doing some haskell programming soon
09:49:22 * tibbe congratulates palomer 
09:50:09 <tic> tja davve!
09:50:13 * tic kicks firefox in the nuts
09:50:20 <waern> tibbe, what is RUP damage? :)
09:50:39 <waern> tic, hey
09:50:51 <tibbe> waern, used to much Rational Unified Process
09:51:01 <tibbe> death by documentation
09:51:09 <tic> hehe
09:51:21 <tic> like: "Java -- death by classes."
09:51:39 <tic> waern, feeling un-sick now?
09:51:47 <waern> okay, I don't know what Rational Unified Process is by I guess it involves too much documentation?
09:51:57 <waern> I took an Agile course by Object Mentor at work however
09:52:00 <tic> you don't need to drink that much RUP Kool-aid though.
09:52:03 <tibbe> I believe Peter hman will either be giving the course or be in charge of it, he's a nice guy but a bit too focused on heavy weight processes, I don't know if he'll do the topic justice
09:52:27 <tic> tibbe, let's hope he does, I'm taking it in fall.
09:52:28 <tibbe> tic, what's wrong with: MySingletonIsGood.getMethodExecuter().doIt()?
09:52:38 * tibbe hopes
09:52:39 <sethk> waern, the rational thing is OO only
09:52:45 <tic> Ml: "Arbeta utan detaljplan och frberedande studier" :D
09:52:55 <tic> tibbe, *argh*
09:53:55 <tibbe> title of a new article: Singleton considered stupid
09:54:05 <dcoutts> heh
09:54:10 <dcoutts> I'd read that
09:54:18 <vincenz> tibbe: ?
09:54:20 <tic> Yeah, singleton's stupid. All hail the Borg pattern.
09:54:29 <vincenz> tibbe: how's that?
09:54:39 <dcoutts> it might have something to say about top level IORefs in Haskell
09:54:42 <mnislaih> how is singleton stupid ? I don't really think so
09:54:47 <tibbe> vincenz, why it's stupid you mean?
09:54:50 <dcoutts> which are much the same thing
09:54:51 <kep> waern as I know RUP is very have whight process, personally I prefer use the XP :)
09:54:53 <tic> Singleton? We don't need no stinkin' singleton : http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66531
09:55:19 <tic> kep, there's a course at Chalmers on Agile development, and tibbe fears it'll be on RUP more than XP.  But it actually says explicitly in the course description that it will be on XP.
09:55:32 <tibbe> it's just that people read the GoF book and the only thing they take with them is an escape to procedural programming
09:56:00 <vincenz> tibbe: yep
09:56:00 <tic> tibbe, do you think GoF is worth buying?
09:56:11 * aufrank hopes to take programming lanuage design and implementation with Michael Scott within the next year or two
09:56:16 <tibbe> tic, it will be on XP, I'm just not sure if the lecturer will do the subject justice but by all means take it
09:56:18 <tic> I'm thinking about buying a book, been oggling _Practical Common Lisp_ for a while now..
09:56:27 <tibbe> tic, it's worth having read
09:56:46 <tic> tibbe, thanks for the warning. I'm actually swamped LP1 so it's good to know what I *could* drop in case things get too crowded. 
09:57:06 <mnislaih> If you are going to do OO, you should read GoF by all means. Actually it's not that bad
09:57:07 <tibbe> tic, I bought Paul Graham's book on Lisp a year ago, ANSI Common Lisp was the title I believe
09:57:23 <tic> tibbe, got it borrowed from a friend, didn't think it was too helpful though.
09:57:43 <tic> tibbe, I started reading PCL online, and liked it because it had some real-world examples.
09:57:46 <tibbe> tic, it probably not that difficult though, you should take it, I'm just talking out of my ass here, I really don't know, I just happen to know the guys behind it
09:57:59 <vincenz> tibbe: ?
09:58:00 <tic> tibbe, in what classes have you had hman?
09:58:06 <vincenz> tibbe: what's bad with singleton/
09:58:25 <tibbe> people should have read GoF, it's one of the more important books in software development, even if everything in it isn't new anymore
09:58:51 <kep> tic ok :)
09:59:06 <tibbe> tic, Systemutveckling i Team, Software Engineering Fundamentals and I'm the IT-program board together with him as a student representativ
09:59:57 <tic> tibbe, aight. I've heard SUIT to suck completely (friends are taking it right now), and I'm taking the "grundlggande software engineering" as a prerequisite to OOP in LP1.  Hope I don't get too much of that guy then. :)
10:00:26 <palomer> GoF is good
10:00:28 <tibbe> vincenz, there are some valid uses for (although the one with the PrintSpooler given in GoF isn't a good one). worse is that people almost always use it as an escape to procedural programming
10:00:41 <tibbe> tic, it sucks completly
10:00:52 <palomer> I use the singleton all the time for IO
10:00:57 <tic> tibbe, gathered as much from reading the course description :/
10:01:15 <palomer> (be it painting on the screen or interacting with my midi devices)
10:01:21 <vincenz> tibbe: Well it if's just a replacement for globaldata, I agree
10:01:37 <vincenz> tibbe: however... I have used in the cases where it's impossible to do it otherwise, except when using something ugly as a global pointer 
10:01:44 <tibbe> there's a rant with the title I gave before on it, just a sec
10:01:56 <tibbe> http://www.cabochon.com/~stevey/blog-rants/singleton-stupid.html
10:02:11 <palomer> but yeah, factory subsumes singleton
10:02:16 <tibbe> there are uses, they are few
10:02:21 <vincenz> palomer: not always
10:02:27 <vincenz> for this DMM library I had, singletons were the only option
10:02:39 <gadolin> i have two functions a returns [LPoint String PointType VRange Float] and b takes as an argument [LPoint String PointType VRange Float]
10:02:54 <gadolin> when i try run a(b)  i get error
10:03:01 <tibbe> factory is much better
10:03:13 <palomer> vincenz: have your factory return the singleton
10:03:33 <palomer> then, if it turns out that singleton wasn't the right option, change it only in your factory
10:03:48 <Korollary> gadolin: looks like you are after "b a"
10:04:14 <vincenz> palomer: you only need one DMM
10:04:17 <vincenz> so factory = overkill
10:04:31 <palomer> oh, yes, factory can be overkill
10:04:32 <vincenz> basically I use a singleton/type
10:04:34 <vincenz> by using templates
10:04:41 <palomer> but nonetheless subsumes singletons
10:04:53 <vincenz> class something : public allocated<somedmm>
10:04:56 <palomer> template<class T> class singleton ?
10:04:57 <vincenz> alocated overrides new
10:05:02 <vincenz> and delete
10:05:12 <vincenz> this means that somedmm needs to be decideable purely on type
10:05:13 <tic> hrm, maybe I should grab the GoF book on patterns.
10:05:14 <vincenz> so needs to be a singleotn
10:05:29 <gadolin> Korollary: yeap i have. intersections h v = findIntersections (createPointList h v)
10:05:44 <gadolin> Korollary: and get error No instance for (Num String)
10:05:51 <metaperl> where is it discussed exactly how (==) is created for a class deriving Eq here: http://www.haskell.org/onlinereport/derived.html
10:05:53 <vincenz> and factories don't subsume singletons, they're singletons themselves
10:06:00 <tibbe> they should ban singleton from beginner OO courses in my opinion
10:06:16 <tibbe> vincenz, are you talking about factory methods?
10:06:31 <tibbe> (i.e. static methods that create objects)
10:06:56 <vincenz> hmm
10:07:07 <vincenz> in that view singleton = factory creating just one object
10:07:26 <tibbe> yes
10:07:39 <Pegazus> well, now that i've understood something about lamda calculus, what's the difference with typed lambda calculus? :p
10:07:40 <Korollary> gadolin: I don't know the types of those functions, but the error message means that you are trying to perform a numeric operation on a String.
10:07:46 <tibbe> I just thought you had a singleton factory (i.e you do getFactory().getInstance() )
10:08:00 <gadolin> Korollary:  createPointList [HSegment] -> [VSegment]
10:08:00 <gadolin>  -> [LPoint String PointType VRange Float] 
10:08:26 <gadolin> Korollary: findIntersections :: (Num b,
10:08:26 <gadolin> Ord b,Ord (Assoc.Assoc Float b1),
10:08:26 <gadolin> Num b1) => [LPoint b1 PointType VRange Float] -> [(b1, b)]
10:08:31 <Korollary> Pegazus: In typed LC, you assign types to terms so that you can do typechecking. That's all.
10:08:36 <tibbe> vincenz, factories doesn't have to be singletons, you can switch factores (ala abstract factories) during run time
10:08:37 <vincenz> tibbe: well basically I hade a template like palomer said
10:08:47 <vincenz> template <class T> class singleton
10:08:58 <vincenz> tibbe: not in the application I was using
10:09:08 <tibbe> alright
10:09:12 <vincenz> dmmr
10:09:18 <vincenz> dynamic memory managers
10:09:18 <tibbe> anyway, read Yegge's rant I posted
10:09:23 <vincenz> will do
10:10:02 <Korollary> gadolin: You said "LPoint String ..." earlier. findIntersection requires a numeric type, like "LPoint Float ..." etc.
10:10:06 <tibbe> they don't play well in multithreaded environments either
10:11:14 <vincenz> either way
10:11:24 <vincenz> many GoF patterns dissapear in less bondagy languages than java
10:11:34 <vincenz> or rather, are inate
10:12:15 <tibbe> sure
10:12:29 <tibbe> it's an old book and java isn't a good language
10:12:52 <tibbe> it's more of a reflection on what people take with them from studying design patterns
10:15:01 <Pegazus> <Korollary> mmm there should be something more
10:15:12 <Pegazus> anyway, g2g soon
10:15:16 <Pegazus> i'll ask again later :p
10:16:04 <shapr> tibbe: Did you post the url?
10:16:16 <tibbe> shapr, yes
10:17:15 <humasect> what is GoF?
10:17:24 <shapr> Gang of Four, "Design Patterns"
10:17:41 <tibbe> http://www.cabochon.com/~stevey/blog-rants/singleton-stupid.html
10:17:49 <humasect> ohh very interesting, thanks
10:18:06 <tibbe> be warned, it's a rant (my link that is)
10:18:31 <humasect> hm, reading that too. =)
10:18:32 <shapr> I've been meaning to write a blog post that maps the original list of Design Patterns into Haskell equivalents.
10:18:48 <tibbe> I would read that
10:18:50 <Korollary> many of them are stateful
10:18:59 <metaperl> I'm getting a compilation error on a simple program to find the middle of a list: http://rafb.net/paste/results/DKuz1h69.html   ... I'd appreciate some help
10:19:15 <tibbe> I read a paper about modeling foreach in FP
10:19:17 <metaperl> Oleg et al created OOHaskell which might be of some help in the translation
10:19:41 <tibbe> if I remember correctly it used unfold or something
10:19:47 <tibbe> @hoogle unfold
10:19:48 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
10:19:48 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
10:19:48 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
10:20:12 <tibbe> anyway the tried to capture Iterator/Visitor using FP
10:20:24 <shapr> Why not use Functor?
10:20:36 <isaacd> metaperl: error takes a string argument
10:20:43 <isaacd> describing the error
10:20:59 <shapr> Visitor is a bit different, but wouldn't fmap cover iterator?
10:21:00 <bolrod> @hoogle (:%)
10:21:01 <isaacd> e.g. "mdl: empty list"
10:21:01 <lambdabot> No matches found
10:21:02 <metaperl> isaacd: is there a better response for an empty list than error?
10:21:04 <bolrod> hrm!
10:21:20 <bolrod> why does the haskell report use :% for ratio's
10:21:28 <shapr> > 5 :% 9
10:21:29 <lambdabot>  Not in scope: data constructor `:%'
10:21:32 <shapr> > 5 % 9
10:21:33 <lambdabot> 5%9
10:21:39 <shapr> I dunno, it should be %
10:21:54 <bolrod> http://www.haskell.org/onlinereport/ratio.html  << it does have the %
10:22:00 <vincenz> tibbe: to be honest
10:22:06 <isaacd> metaperl: what's the function supposed to do?
10:22:07 <vincenz> tibbe: that criticism article is ... rather shallow
10:22:16 <bolrod> maybe I'm missing something
10:22:29 <vincenz> tibbe: it only addresses mistakes made by newbies, but does not observe the usefulness of the patterns in places where they are useful
10:22:33 <metaperl> isaacd: I have a chess match now... it works.. thanks for your help
10:22:38 <vincenz> tibbe: basically it's bashing on a pattern cause newbies use it the wrong way
10:22:47 <vincenz> and rather weak argumentation
10:22:56 <shapr> Yegge sure is fun to read though.
10:23:08 <Korollary> He's almost a troll
10:23:13 <shapr> I agree with vincenz, though I'd have probably put it more strongly.
10:23:31 <shapr> Korollary: Not quite that strongly though ;-)
10:23:40 <vincenz> shapr: what? That he's a bashing troll without real argments?
10:23:56 <vincenz> and just appealing to the common programmer out there who likes to have some fake fuel for some flamewar
10:23:57 <shapr> One of the best things about reading Yegge is that you can see his understanding develop as his blog posts get more recent.
10:24:01 <Korollary> shapr: Let me explain succinctly in 18 paragraphs why every language on the planet sucks.
10:24:05 * shapr grins
10:24:07 <shapr> Yegge really does that!
10:24:23 <vincenz> It's pretty sad to be honest
10:24:28 <tibbe> vincenz, I think the point I was originally trying to make was that a) it's overused, other options should be considered first, it's sometimes too easy to say, "but of course there's only one ApplacationSettings, then you try to do unit testing and discover unnecesary coupling" and b) people take away the wrong things from the GoF book
10:24:31 <shapr> In fact, one of his most recent posts is about how all languages suck, and the only good languages still suck because no one uses them.
10:24:41 <vincenz> tibbe: I agree that it's oversused, but overused != useless
10:24:49 <vincenz> tibbe: this article targets newbie coders
10:24:55 <jyp> Anyway, Robert Dockins did a better argumentation against the Singleton on the Haskell mailing list.
10:25:17 <vincenz> tibbe: Its much like the "I met OO and it's great" java coder who thinks all else sucks
10:25:27 <shapr> The steps to learning are imitation, understanding and .. trancendence? Whatever you call the ability to write your own.
10:25:29 <tibbe> vincenz, I don't think he even goes as far as to say that
10:25:37 <shapr> The GoF book is good for step one, imho.
10:25:51 <vincenz> shapr: yeah
10:26:38 <vincenz> tibbe: I just find his article... well I guess it's a great article for the newbie coders, or those wishing for extra flame material, but it offers little of substantial value
10:26:42 <shapr> I think the GoF book was a great thing for the professional programming world, people starting realizing they could factor out these sorts of patterns into separate libs.
10:26:56 <Korollary> shapr: they have not been, though.
10:27:05 <shapr> Have not been?
10:27:08 <vincenz> shapr: yeah but some shops apparently decompose stuff into patterns instead of letting it emerge, I think that patterns are useful, but aren't set in stone
10:27:10 <humasect> tibbe, good  rant, brings back memories.
10:27:21 <Korollary> no. They haven't been made into libs at all.
10:27:38 <vincenz> Korollary: patterns are things that transcend libraries
10:27:42 <vincenz> Korollary: they're metalibraries
10:27:44 <shapr> vincenz: At some level, decomposing into patterns is the same as letting it emerge.
10:27:56 <vincenz> shapr: true but pigeonholing everycode can be detrimental
10:28:01 <vincenz> s/everycode/every code
10:28:02 <shapr> Yeah, that's true.
10:28:24 <shapr> I'd argue that the most basic patterns are fold, unfold, map, etc.
10:28:32 <vincenz> :D
10:28:38 <shapr> Basically, the bananas, lenses, barbed wire, etc stuff.
10:28:41 <vincenz> I can argue all patterns are 0 and 1
10:29:02 <Korollary> all patterns are lambda terms!
10:29:14 <vincenz> all patterns consist of S K and I
10:29:22 <shapr> Seriously though, Yegge is worth reading at a miminum for his ability to show things in a new light.
10:29:24 <tibbe> *shrugs*
10:29:36 <vincenz> shapr: I guess his other posts are better then, I didn't like this particular one
10:29:53 <vincenz> rants often are ... what's the word... unilateral and not constructive
10:30:04 <shapr> Some of his posts are really great. I don't always agree, but I like what he writes.
10:30:14 <tibbe> it's was in the context of: tic like: "Java -- death by classes." and mine: tibbe tic, what's wrong with: MySingletonIsGood.getMethodExecuter().doIt()?
10:30:29 <shapr> I like it :-)
10:30:54 <tibbe> not an carefully disecting arguments for and against OO/singleton
10:31:01 <wchogg> shapr:  Yegge can be rather convincing when he wants to be.  You kindof get the "Yeah, yeah he's right!!  ...wait" reaction.
10:31:02 <tibbe> and it came with a rant warning!
10:31:04 <shapr> Java gets on my nerves. They need to hire a professional refactorer and sic him onto their libs.
10:31:18 <vincenz> shapr: It's just that it's easy to rant, it's harder to take a feature and say "it is useful then"
10:31:29 <vincenz> without getting ... 
10:31:32 <vincenz> grr what is that word
10:31:39 <vincenz> people who worship a god obsessively are...
10:31:43 <vincenz> fanatic!
10:31:44 <Korollary> zealots
10:31:47 <tibbe> programmers?
10:31:48 <vincenz> or yeah zealot
10:31:48 <vincenz> thanks
10:31:50 <shapr> wchogg: I've already come up with most of his arguments on my own (maybe cause I'm older?) so I just get "Cool, someone else thinks in this direction too!" feelings.
10:31:51 <wchogg> fanatical, zealous?
10:31:58 <vincenz> was on the tip of my tongue
10:31:59 <shapr> @quote hakko
10:32:00 <lambdabot>  most programmers have a lot of religious issues about their work, yes.
10:32:03 <tic> shapr, [refactor] agreed.
10:32:11 <vincenz> tibbe: seen the icfp team page?
10:32:14 <vincenz> tic: idem?
10:32:29 <tibbe> vincenz, um, no I don't think so
10:32:33 <wchogg> shapr:  I've been only really programming for less than a year, so I'm pretty easily influenced. ;)
10:33:12 <shapr> Believe it or not, I don't consider myself "A Haskell Guy". I am instead an equal opportunity coder. I'll take the most powerful tools I can find, and I don't think Haskell will be the best tool for my entire life.
10:33:26 <vincenz> shapr: aha, wchogg places a nice attention point.  That's my issue with rants, they're unilateral and target newbies who will then take said things to be the absolute truth, for instance assuming singletons are always bad... .Rants should contain weigh-offs and constructive arguments
10:33:34 <vincenz> tibbe: http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
10:34:07 <shapr> I think everything input should be regarded with a healthy dose of skepticism.
10:34:15 <shapr> s/everything/every
10:34:32 <wchogg> shapr:  I'm still in the phase where I get fanatical about new things I learn...for about two weeks.  I can't quite shake the notion that there's a perfect tool.
10:34:33 <tibbe> arguments don't get that objective when people need to went some steam, I take it for what it is
10:34:41 <shapr> I hear people say that X is good for Y. So I try it and make up my own mind.
10:34:58 <shapr> wchogg: There probably is... tell me if you find it :-)
10:35:13 <vincenz> wchogg: I know the feeling :)
10:35:13 <jyp> vincenz: Aren't we in GMT+2 ?
10:35:17 <vincenz> jyp: erm
10:35:20 <shapr> I'm just not convinced this perfect tool is available yet.
10:35:25 <tibbe> it struck a cord with me since I used to assist teaching introductionary OO programming
10:35:29 <vincenz> jyp: hmm...nope?/
10:35:39 <vincenz> jyp: btw, wanna join?
10:35:50 <tibbe> shapr, well perfect is a subjective word so there probably never will be such a tool
10:36:08 <vincenz> shapr: I doubt the perfect tool will ever exist unless you nichify
10:36:16 <shapr> Yeah, but there are 'sweet spots' that are hard to find but easy to use.
10:36:18 <Saulzar> Everyone likes to be right, especially about the latest great thing :)
10:36:33 <tibbe> vincenz, I'll be in Nice working by then :/
10:36:34 <shapr> For example, higher order functions is a good feature.
10:36:42 <shapr> Monads are another sweet spot.
10:36:43 <vincenz> tibbe: well it's during the weekend
10:36:59 <tibbe> ah
10:37:01 <jyp> vincenz: The teams looks kinda crowded already :) But why not.
10:37:06 <tibbe> weekends, I've heard of those
10:37:09 <Korollary> form a second team then
10:37:18 <vincenz> jyp: the team hasn't settled yet
10:37:20 <mathrick> hey, a question (related to earlier gadolin's question): is there a way to construct "any value"? The thing is, we operate on a tree that keeps pairs of values, and when querying the tree we need to construct such pair, we do that with (MkAssoc key 0), where key is the key passed to the function. However, it breaks things, because now haskell concludes that the second value in the pair should be Num, which is not the case
10:37:28 <shapr> The part that really bothers me is that the best sweet spots somehow match up to mathematical structures. So either math is totally arbitrary, or sweet spots are not.
10:37:37 <mathrick> what we reall want is "any value without meaning"
10:37:38 <wchogg> Although, I honestly feel like the fact that we need things like monad transformers means that monads perhaps aren't the perfect fit.
10:38:05 <tibbe> vincenz, I'm not a very good Haskell programmer, more of an overall CS guy, I don't mind bringing out some pen and paper, a cup of tea and think some though
10:38:05 <shapr> wchogg: Oh sure, I agree with you. But I do think that monads are a lot closer than the customary meaning behind 'objects'.
10:38:19 <vincenz> Talk on #oasis?
10:38:30 <Korollary> mathrick: That's a bit backwards in a statically checked language.
10:38:36 <shapr> mathrick: undefined :: (whatever type you want) ?
10:38:52 <mathrick> shapr: umm, but I want it to have any type
10:39:02 <mathrick> because that value is not going to be used anywa
10:39:03 <mathrick> y
10:39:15 <shapr> Why not partially apply your type then?
10:39:19 <Korollary> mathrick: why does it exist then?
10:39:25 <mathrick> shapr: what do you mean?
10:39:38 <mathrick> Korollary: umm, because that's how the tree looks like
10:39:48 <tibbe> shapr, well (some) mathematical areas tend to be well explored and with good understanding of an area comes the abillity to put it to good use
10:40:10 <mathrick> Korollary: because we keep pairs in it, we need to pass in pairs in order for == to be meaningful
10:40:14 <Saulzar> Can't you query the tree by just key rather than a pair?
10:40:15 <tibbe> vs thinking, this is probably a neat thing to have
10:40:37 <shapr> tibbe: Yeah, but how do you explain the connection between useful programming abstractions and math? How the heck can it even exist? Is it some distant equivalent to the Curry-Howard isomorphism?
10:40:41 <tibbe> if math is consistent then having a math based language helps that language being consistent
10:40:43 <mathrick> Saulzar: I wanted to abstract that away and keep the tree oblivious to what is kept inside
10:41:04 <shapr> Does it mean that at some point in the future we'll be able to generate an infinite set of abstractions and just choose the combination of features we like best?
10:41:08 <mathrick> Saulzar: all that pairs construction is defined on top and outside the actual tree structure
10:41:11 <Saulzar> mathrick, You can use some other function which just compares equality on the key
10:41:22 <mathrick> Saulzar: eh?
10:41:30 <Korollary> mathrick: You can construct a custom pair datatype that defines equality only in terms of the first element.
10:41:45 <shapr> In any case, said isomorphism has motivated me to study proof theory. Maybe I should apply for a PhD program and get paid to do this.
10:41:54 <Saulzar> But that has the same issue, you don't want to query by pair, it's only the key which matters
10:42:02 <mathrick> Korollary: that's exactly what I've done
10:42:23 <shapr> Lemmih: awake?
10:42:26 <tibbe> shapr, me and a friend of mine has been chatting a bit on basing a language on set theory and set relations, only talk up to this point though
10:42:34 <shapr> I think it's been done.
10:42:42 <mathrick> and again, haskell concludes that the second value in that pair needs to be of type Num because query function constructs fake pairs of (MkAssoc key 0)
10:42:50 <mathrick> s/type/class/
10:43:00 <shapr> Everytime I think I've come up with a new basis for a programming language, some googling turns up an implementation.
10:43:15 <Korollary> mathrick: your custom pair type needs to be parametric then
10:43:27 <wchogg> shapr:  I hate that!  Everytime I've ever had something I thought was a good idea, someone else thought of it at least a year or two before.
10:43:38 <shapr> Pure Categories, found it... Thunks with built-in capability security, found it... 
10:43:43 <Lemmih> shapr: Somewhat.
10:44:19 <Saulzar> > let compareKey (key, val) key' = (key == key') in compareKey (5, "foo") 5  -- Why can't you use something like this?
10:44:21 <lambdabot> True
10:44:31 <shapr> Lemmih: The apt-get idea still appeals to me, but I want your thoughts on the matter.
10:44:42 <mathrick> Korollary: uh, it already is
10:44:48 * shapr moves to #haskell-overflow
10:44:58 <mathrick> data Assoc a b = MkAssoc a b
10:45:25 <tibbe> shapr, probably has
10:45:50 <wchogg> What is #haskell-overflow? 
10:46:01 <shapr> It's for lengthy discussions that would otherwise flood #haskell.
10:46:07 <Korollary> a second lane
10:46:07 <wchogg> Ah, gotcha.
10:46:21 <shapr> Like when Cale goes off into deep theory and we all get scared ;-)
10:47:55 <Korollary> mathrick: you're right. You must pass a value of a concrete type for that query.
10:48:11 <mathrick> someone was mentioning partial type application?
10:48:33 <shapr> Yeah, I did, but I'm not sure if I was just confused.. 
10:48:43 <shapr> Anyway, I gotta focus on cabal-get right now, so cannot pursue the idea.
10:48:45 <mathrick> instance Eq a => Eq (Assoc a b) where
10:48:45 <mathrick> 	(MkAssoc a _) == (MkAssoc b _) = a == b
10:48:45 <mathrick> <-- should I say Eq (Assoc a) where .. here?\
10:49:40 <mathrick> shapr: how exactly does that look?
10:49:55 <Saulzar> Yeah - but I stil don't see why you can't query by key rather than query by another pair :)
10:50:22 * tibbe wishes he had taken more math courses
10:50:35 <mathrick> Saulzar: because that pollutes my tree implementation
10:52:33 <Saulzar> But you can try as shapr mentioned and use (MkAssoc value undefined), provided you never touch the undefined
10:53:44 <mathrick> okay
10:56:38 <tibbe> what is good size bite of theory to take on after having grasped the basics of monads (actually I have no idea how much "basic" is but I assume that is about as much as I know)?
10:56:51 <DeliQ> is lambdabot case sensitive ?
10:57:17 <xerox> @ViXeN are you sensitive?
10:57:18 <lambdabot> Unknown command, try @list
10:57:26 <DeliQ> lol
10:57:37 <DeliQ> @seen Phyx
10:57:38 <lambdabot> I haven't seen Phyx.
10:58:29 <DeliQ> @list
10:58:30 <lambdabot> list [module|command]. Where modules is one of:
10:58:30 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
10:58:30 <lambdabot> unlambda version vixen where
10:58:59 <DeliQ> @karma
10:59:00 <lambdabot> You have a karma of 0
10:59:06 <DeliQ> hmm bad karma :P
10:59:19 <musasabi> @seen SyntaxNinja
10:59:19 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 2 days, 16 hours, 40 minutes and 34 seconds ago, and .
10:59:41 <palomer> grrr, working with unifiers is no fun
10:59:53 <Korollary> tibbe: You can then learn about monads in CT and see how the two match.
10:59:58 <DeliQ> palomer: what are you coding ?
11:00:08 <mathrick> okay, it seems that undefined does the trick, at least as far as compile goes
11:00:10 <palomer> a type checker
11:00:19 <DeliQ> palomer: just for fun ?
11:00:34 <palomer> oh no, it's part of my masters thesis
11:00:41 <DeliQ> hmm, interesting
11:00:52 <palomer> this isn't standard HM though
11:00:55 <palomer> HM + GADTs
11:00:57 <tibbe> Korollary, could you link some introductionary material?
11:01:04 <DeliQ> which study ?
11:01:07 <DeliQ> CS ?
11:01:11 <palomer> yup
11:01:16 <tibbe> palomer, what kind? for what?
11:01:34 <tibbe> oh
11:01:37 <palomer> for dealing with generalised algebraic datatypes
11:02:11 <Korollary> tibbe: This paper should be a good intro: http://lambda-the-ultimate.org/node/1183 . But eventually a real CT book would be needed.
11:02:22 * palomer is off
11:03:43 <tibbe> Korollary, thanks
11:04:21 <tibbe> I was planning to catch up on math this summer if I have time, although I think I'll start with statistics
11:04:55 <Korollary> I've been thinking of statistics myself, but nowadays my job has no numerical data that I can use.
11:05:42 <tibbe> I've do some macro economics on my spare time and it's useful there
11:05:50 <tibbe> s/I've/I
11:09:38 <tibbe> I'd like to participate in SoC this year but I don't think I have the time :/
11:09:58 <DeliQ> where is this SoC taking place ?
11:10:30 <tibbe> in your room ;)
11:10:43 <tibbe> you'll write code for an open source project
11:11:00 <DeliQ> aha, i thought it was a community event
11:11:02 <tibbe> http://code.google.com/summerofcode.html
11:11:15 <tibbe> you can get $4500
11:11:27 <tibbe> and it looks nice on your resume
11:11:32 <DeliQ> that's pretty much
11:11:33 <tibbe> and it's fun!
11:11:43 <DeliQ> when do you get money ?
11:11:46 * tibbe really got his priorities right...
11:11:50 <DeliQ> if you deliver working code ?
11:12:10 <tibbe> $500 up front, $2000 in the middle if things are going well, $2000 if you finish
11:12:14 <tibbe> yes
11:12:27 <xerox> Is it right to say that programs that pass type-checking are correct?
11:12:29 <DeliQ> hmm, sounds attractive :P
11:12:46 <tibbe> xerox, ?
11:12:47 <xerox> DeliQ: did you see the mailing list thread?
11:12:51 <xerox> Hey tibbe!
11:12:53 <DeliQ> yep i did see it
11:13:05 <DeliQ> but haven't replied to it yet
11:13:24 <DeliQ> dunno if i'm actually of much use in the SoC
11:13:30 <DeliQ> ;)
11:13:44 <xerox> I think you would do great :-)
11:14:02 <DeliQ> you only say that to get more people :P
11:14:05 <DeliQ> hehehe
11:14:28 <xerox> I'll tell ski to not explain you any other monads then!  prrr.
11:14:34 <DeliQ> lol
11:14:35 <tibbe> DeliQ, I want to do something research oriented for Google if I participate
11:15:02 <DeliQ> hmm, there is so many to research
11:15:13 <tibbe> or for someone that would support a research project anyway
11:15:24 <tibbe> I don't want to write C all summer
11:15:26 <swoolley> let's not forget that google is an abomination
11:15:37 <tibbe> ?
11:15:38 <swoolley> worse than microsoft -- at least microsoft admits its evil
11:15:43 <sieni> tibbe: please tell us more
11:15:55 <tibbe> swoolley, I read that somewhere
11:15:59 <DeliQ> i've neevr seen anyone at ms admitting it was evil :P
11:16:14 <DeliQ> don't buy windows, it's evil 666 :P
11:16:19 <tibbe> can abstract things such as companies be evil?
11:16:19 <swoolley> DeliQ: lived in Redmond?
11:16:34 <DeliQ> nope, i'm just from holland :P
11:16:41 <swoolley> My dad was a redmond school teacher for 30 years.
11:16:42 <DeliQ> that little spot on the world map
11:17:06 <swoolley> there's enough ADHD there to kill a moose.
11:17:24 <DeliQ> hmm, you mean hyperactivity ?
11:17:46 <swoolley> mostly the attention deficit
11:17:51 <DeliQ> hehe
11:18:09 <xerox> tibbe: do you have ideas for Haskell projects?
11:18:28 <DeliQ> a haskell IDE would eb great right ?
11:18:32 <swoolley> google is ultra secretive
11:18:41 <swoolley> files patents just like microsoft
11:18:47 <swoolley> gives into china
11:18:51 <swoolley> for money
11:18:52 <tibbe> swoolley, that's a tad bit long to stretch the definition of evil isn't it?
11:19:13 <DeliQ> swoolley: google manipulates search results right ?
11:19:14 <tibbe> tell me your secrets or you're evil! :D
11:19:16 <swoolley> they've set the soundstage for a play of evil
11:19:27 <swoolley> DeliQ: of course they do
11:19:36 <swoolley> tibbe: corporations are not people
11:19:37 <tibbe> xerox, I don't have any concrete ideas yet, just know I don't want to write C
11:19:37 <DeliQ> they would be mad if they didn't
11:20:08 <xerox> tibbe: good.  Maybe poke at the mailing list saying so, we're looking for consensus!
11:20:09 <isaacd> Operating in a capitalist society, power is what google is amassing, and it will be used evilly
11:20:12 <DeliQ> i heard on the radio that googles marketshare has grown with another 50 percent or something
11:20:28 <tibbe> gawd
11:20:40 * tibbe hides under a rock for a while
11:20:42 * swoolley watches the closet socialists come out of the woodwork
11:21:03 <DeliQ> but are there haskell projects involved in the SoC ?
11:21:29 <tibbe> I've read on the mailing lists that Haskell (.org?) would be a mentor org
11:22:19 <tibbe> xerox, Alright, but I'm not sure if I'll have the time yet, I have another project for a company and need to write my thesis as well
11:22:31 <tibbe> are the socialists gone? can I come out?
11:22:43 <swoolley> yes, but the capitalists are back, you have to keep hiding
11:22:43 <xerox> I doesn't make sense to have Haskell.org as a mentoring organization if students don't want to do Haskell.
11:22:50 * tibbe crawls back up from under his rock
11:23:09 <isaacd> tibbe: don't be afraid of political arguments, just kick them out of #haskell :-P
11:23:11 * SamB thinks he does
11:23:15 <tibbe> xerox, I understand, I'm just not sure that I'll do a project justice
11:23:16 <xerox> I don't know if I will be up for it again this year, even if so, I couldn't do all the projects by myself.
11:23:31 <DeliQ> xerox: who says there is nobody wanting to code haskell ?
11:23:32 <tibbe> isaacd, I'm not, I'm afraid that I'll be drawn into them
11:23:38 <xerox> DeliQ: the mailing list.
11:23:49 <isaacd> tibbe: is that bad?
11:24:07 <DeliQ> xerox: i've seen some people saying they would be interested
11:24:13 <xerox> Consensus should be directed there, if any.  So that SyntaxNinja know if go on with the project or not.
11:24:14 <tibbe> nope just that I rather not do it here and I need to do some washing up so I don't have the time
11:24:23 * SamB jumps up and down, waving his hands in the air
11:24:24 <xerox> DeliQ: interesting, it would help if you could direct them to the mailing list.
11:24:48 <SamB> which list?
11:24:53 <xerox> haskell@haskell.org
11:24:56 <DeliQ> hmm, yes, i would be interested maybe if there was a concrete target
11:25:12 <xerox> There also is the wikipage with project proposals.
11:25:15 <DeliQ> but i think there is nothing concrete yet ?
11:25:24 <xerox> Feel free to scribble every ideas on that.
11:25:25 <kep> DeliQ do you mean an eclipse plugin ? 
11:25:27 <SamB> gmane.comp.lang.haskell.general, here I come...
11:25:33 <tibbe> is there something interesting that needs doing?
11:25:39 <xerox> DeliQ: if you read the thread you would know for sure that it *is* concrete.
11:25:51 <DeliQ> i know there exists a haskell plugin voor eclipse
11:25:55 <DeliQ> iirc
11:26:07 <xerox> tibbe: find the url of the wikipage on the mailing list thread and read.  And possibly write.
11:26:11 * davidhouse_ sighs
11:26:24 <kep> DeliQ :) I use it
11:26:29 <davidhouse_> i wish M-x centre-line was an alias for M-x center-line
11:26:34 <DeliQ> kep: is it any good ?
11:26:34 <tibbe> xerox ok
11:26:43 <Korollary> davidhouse_: You could make it
11:26:59 <DeliQ> xerox: does writing docu also count ? :P
11:27:24 <xerox> I was jumping up and down for days when I got Haskell Open Source paid work for the year, last summer!
11:27:25 <palomer> Philippa: ping?
11:27:33 <palomer> @seen Philippa 
11:27:33 <lambdabot> Philippa is in #scannedinavian, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa speak 3 hours, 40 minutes and 3 seconds ago.
11:27:34 <davidhouse_> Korollary: true.
11:27:38 <xerox> DeliQ: as part of the project, I think so.  I did write it.
11:27:52 <kep> DeliQ I think it's good
11:28:01 <DeliQ> i could write documentation
11:28:17 <davidhouse_> writing docs should be a compulsary part of any programming jov.
11:28:18 <davidhouse_> *job
11:28:19 <xerox> DeliQ: documentation in Haskell is a particular matter.  Haddock makes it _very_ easy.
11:28:25 <davidhouse_> the same as writing tests.
11:28:49 <kep> DeliQ :))) I can write eclipse plugins and eclipse RCP :))) 
11:28:51 <DeliQ> yup, but it is underestimated in open source software
11:28:58 <Korollary> haskell's typesystem makes documentation easy too
11:29:16 <DeliQ> kep: i like eclipse, but it is slow... :P
11:29:25 <DeliQ> kep: you know what i mean, java and stuff
11:29:39 * tibbe says wise things such as "if it was hard to write it should ..." etc
11:30:43 <isaacd> > inits (1:2:3:undefined)
11:30:45 <lambdabot> Undefined
11:30:52 <isaacd> :/
11:31:15 <DeliQ> is inits in Prelude or List ?
11:31:28 <xerox> Anyway, I'm organizing this for students.  I hope students would reply, the Old Sage Ones volunteered for them too (and for getting some code finally done, heh.)
11:31:28 <isaacd> List
11:31:41 <isaacd> inits (1:2:3:undefined) ---> [[],[1],[1,2]*** Exception: Prelude.undefined
11:32:07 <isaacd> let inits l = [[]] ++ case l of [] -> []; (x:xs) -> map (x:) (inits xs) in inits (1:2:3:undefined) ---> [[],[1],[1,2],[1,2,3]*** Exception: Prelude.undefined
11:32:12 <tibbe> xerox, I really would apply if I could
11:32:28 <Cale> > take 3 (inits [1,2,3,undefined])
11:32:29 <lambdabot> [[],[1],[1,2]]
11:32:30 <xerox> tibbe: spread the word!
11:32:30 <isaacd> Data.List.inits is stricter than it needs to be
11:32:36 <tibbe> sure
11:32:45 <Cale> > take 4 (inits [1,2,3,undefined])
11:32:46 <lambdabot> [[],[1],[1,2],[1,2,3]]
11:32:50 <isaacd> ?
11:33:02 <DeliQ> xerox: i'm a little affraid if a apply then i am of little use
11:33:11 <Korollary> that exception message seems early
11:33:11 <isaacd> don't put them in a list, have undefined by part of the list
11:33:14 <DeliQ> excuse the bad english :P
11:33:28 <kep> DeliQ :) may be
11:33:30 <isaacd> > take 3 (inits 1:2:3:undefined)
11:33:30 <Cale> isaacd: hm?
11:33:31 <lambdabot>  add an instance declaration for (Num [[a]])
11:33:37 <isaacd> > take 3 (inits (1:2:3:undefined))
11:33:38 <lambdabot> [[],[1],[1,2]]
11:33:41 <Cale> ah, undefined instead of nil
11:33:42 <isaacd> > take 4 (inits (1:2:3:undefined))
11:33:43 <lambdabot> Undefined
11:33:49 <xerox> DeliQ: I'm not going to push people anyway.
11:34:13 <Cale> yeah, this was brought up earlier
11:34:26 <DeliQ> xerox: there are much more knowledgable people then me, considering i am just a first year cs student :P
11:34:38 <xerox> DeliQ: I am not a CS student.
11:34:40 <Cale> on the haskell-libraries list
11:34:48 <wchogg> DeliQ:  You never learn as fast or as well than when you dive into a project.
11:34:58 <DeliQ> that's true...
11:35:11 <Cale> > let inits xs = [] : (zipWith take [1..] $ map (const xs) xs) in take 4 (inits (1:2:3:undefined))
11:35:13 <lambdabot> [[],[1],[1,2],[1,2,3]]
11:35:21 <DeliQ> completely agree with that
11:35:32 <wchogg> I'm a grad student in physics who has been writing code for less than a year, but I still think I'm going to apply.
11:35:53 <xerox> wchogg: cool, maybe you could discuss your ideas on the wikipage.
11:35:53 <DeliQ> are all languages involved ?
11:36:10 <NameTab> bolrod: 'n 5! :]
11:36:12 <DeliQ> like c, or c++, haskell
11:36:21 <tibbe> yes
11:36:27 <tibbe> for SoC that is
11:36:30 <isaacd> Cale: ah, that's also much clearer definition of inits, IMO, than http://haskell.org/onlinereport/list.html
11:36:33 <wchogg> xerox:  Well, I did e-mail out to h-cafe yesterday.  I hadn't really heard back on whether anyone could mentor on the numerics stuff.
11:36:46 <xerox> wchogg: the thread is on haskell@haskell.org
11:36:50 <isaacd> s/much//
11:37:14 <tibbe> why are S and K important in LC?
11:37:29 <Cale> tibbe: because every combinator can be built from them
11:37:59 <DeliQ> @type const
11:38:01 <lambdabot> forall a b. a -> b -> a
11:38:09 <Cale> > const 3 5
11:38:11 <lambdabot> 3
11:38:15 <tibbe> Cale, how come? is there some way to intuitively understand that?
11:38:22 <DeliQ> so const just ignores it second argument ?
11:38:35 <xerox> > map (const '*') "password"
11:38:36 <lambdabot> "********"
11:38:45 <wchogg> xerox:  Earlier I was asking Lemmih about doing some ghc work as an SoC project, but I don't know how feasible it would be.  I still wonder if maybe something good would be to take some of the bindings to the GSL people have started and flesh them out.
11:38:49 <DeliQ> ;)
11:39:19 <xerox> wchogg: I see.  What kind of GHC work?  What is GSL?
11:40:20 <wchogg> xerox:  GSL => Gnu Scientific Library 
11:40:31 <SamB> okay, what is this about people thinking SoC was a bad idea?
11:40:37 <Cale> tibbe: iirc, there's an algorithm which takes a lambda term with no free variables and rewrites it into an SK term.
11:40:46 <wchogg> SamB:  Eh, who said that?
11:41:04 <SamB> wchogg: well, someone made it sound like people on a mailing list thought that
11:41:31 <xerox> SamB: I think the point is "which people?"
11:41:48 <Cale> tibbe: \x. x = I = SKK
11:42:05 <Cale> \x. M = KM, when x is not free in M
11:42:16 <tibbe> I see
11:42:17 <Cale> \x.M N = S (\x.M) (\x.N)
11:42:21 <wchogg> There hasn't been much traffic about it, which is kindof a shame, but I didn't get the impression anyone was opposed.
11:42:32 <Cale> you can use those 3 rules to eliminate lambdas
11:42:43 <DeliQ> xerox: yesterday you mentioned eta-reduction, what is that ??
11:42:59 <SamB> okay, maybe more that it seemed like nobody was voicing interest
11:43:04 <xerox> ?pl \x -> f x
11:43:05 <lambdabot> f
11:43:19 <xerox> SamB: right.
11:43:36 <davidhouse_> DeliQ, aka partial application
11:43:40 <DeliQ> aah i get it
11:43:42 <DeliQ> ty
11:43:44 <davidhouse_> not providing all the arguments to a function
11:43:53 <davidhouse_> @oldwiki Currying
11:43:53 <lambdabot> http://www.haskell.org/hawiki/Currying
11:43:58 <xerox> SamB: I mean, SPJ thinks is a good thing, for one.
11:44:03 <wchogg> Yeah, like I said I haven't heard much back over some of my ideas but I'm not surprised.
11:44:06 <DeliQ> i know currying
11:44:08 <DeliQ> ty
11:44:15 <DeliQ> like (+1)
11:44:22 <DeliQ> its curried, right ?
11:44:31 <davidhouse_> yeah, kind of.
11:44:33 <SamB> xerox: so do I need to voice interest or not?
11:44:35 <xerox> SamB: I was hoping for more consensus, but I don't know if it's either that the students don't poke at the ml, or it passed too short time.  But the deadline is... tomorrow, for Isaac.
11:44:35 <davidhouse_> but it's more powerful than that.
11:44:44 <xerox> SamB: you indeed do.  Thanks for caring.
11:45:01 <davidhouse_> DeliQ: imagine you want to write a function that adds one to each element in a list.
11:45:02 <xerox> I should've made it clearer, maybe.
11:45:07 <DeliQ> yup...
11:45:08 <Cale> eta reduction is specifically the transformation from (\x -> f x) to f.
11:45:15 <SamB> its just that the thread that I see looks totally positive
11:45:16 <davidhouse_> you could go addOneList = map (+1)
11:45:18 <wchogg> xerox:  So what needs to be done for this deadline tommorow?  You don't actually need project proposals do you?
11:45:29 <DeliQ> that could be a solution idd
11:45:31 <Cale> eta equivalence is the notion that (\x -> f x) and f are the same function
11:45:46 <davidhouse_> now, map needs two arguments, so normally you'd write addOneList l = map (+1) l, but we eta-reduce and remove the l from both sides
11:45:50 <xerox> wchogg: the mentoring organization is required to have them published.  I thought it would be better for us to have them online for the moment Isaac was going to apply.
11:45:53 * palomer hugs haskell
11:45:58 <palomer> ok, I'm back in love with haskell
11:46:02 <Cale> hehe
11:46:07 * haskell hugs palomer
11:46:10 <DeliQ> but what is the use of leaving out parameters ?
11:46:11 <xerox> wchogg: nobody can really say, but  more projects  more slots  I hope.
11:46:16 <Cale> palomer: any specific reason?
11:46:28 <palomer> yeah, I just wrote a unifier library in 20 minutes
11:46:47 <davidhouse> @palomer
11:46:48 <lambdabot> hrmph
11:46:48 <xerox> (And the equality goes on, more slots, more students, more fun...)
11:46:53 <tibbe> xerox, I've been in #haskell for 6 months or so without every reading the ML
11:47:04 <palomer> wrote and tested, no less
11:47:06 <davidhouse> DeliQ, elegance, brevity mostly.
11:47:07 <xerox> tibbe: I can understand, I didn't either.
11:47:18 <xerox> #haskell works :-)
11:47:19 <DeliQ> it's clear now, ty
11:47:31 <palomer> however, I've parted ways with ST
11:47:36 <wchogg> Heh...I didn't even know about #haskell for a long time.
11:47:43 <Cale> tibbe: http://www.cwi.nl/~tromp/cl/LC.pdf might interest you
11:47:45 <DeliQ> but eta-reduction implies there was also alpha, beta ??
11:47:51 <DeliQ> and so on, and so on
11:47:53 <davidhouse> any time you eta-reduce you could use the full version (sometimes you need a lambda, but that's okay), but it's nicer to use the eta-reduced form.
11:48:27 <xerox> DeliQ: I think it has as high theoretical value as the other LC transformations have, you can use it in proof and whatsoever.
11:48:51 <DeliQ> i see...
11:49:08 <xerox> proofs, either
11:49:12 <tibbe> Cale, thanks
11:49:29 <tibbe> great, now I have 10^100 open tabs in my browser with thing to read, again
11:49:49 * SamB goes to find an HTTP url for the relevant post
11:52:06 <SamB> Voice your Summer of Code feeliongs at http://thread.gmane.org/gmane.comp.lang.haskell.general/13590/focus=13605
11:52:17 <wchogg> xerox:  Should there be somewhere where all students interested in doing SoC can list themselves?
11:53:05 <xerox> wchogg: the organization is required to publish ideas, I think it's fair to discuss projects on the wiki.
11:53:13 <tibbe> there might be students who never read the ML and never been to #haskell that will show interest as soon as it's posted on the Google SoC page
11:53:19 <mnislaih> SamB I am going to apply as a student, so what should I post?
11:53:31 <wchogg> tibbe:  That's a point.
11:53:32 <DeliQ> @type (***)
11:53:34 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
11:53:34 <lambdabot>    (Arrow a) =>
11:53:34 <lambdabot>    a b c -> a b' c' -> a (b, b') (c, c')
11:53:39 <xerox> mnislaih: anything you like.
11:53:43 <mnislaih> I still don't know what will be my project proposal, so I probably have nothing to say..
11:53:43 <palomer> is there a shorter way of writing join (a ++ b) ?
11:53:56 <xerox> palomer: (join .) . (++)
11:54:02 <tibbe> :D
11:54:18 <xerox> mnislaih: "hello, good work" would be *SO* welcome.
11:54:35 <xerox> Again, I should have stated it better that we were looking for consensus.
11:58:45 <davidhouse> @pl \a b -> join (a ++ b)
11:58:45 <lambdabot> (join .) . (++)
11:59:01 <xerox> I told you! :-)
11:59:05 <SamB> where is the list-tender (Simon Marlow?), btw?
11:59:18 <tibbe> what does @pl do?
11:59:18 <xerox> -tender ?
11:59:25 <davidhouse> tibbe, points-free code.
11:59:27 <xerox> tibbe: it gets code to its points-free form.
11:59:34 <tibbe> what's that?
11:59:39 <davidhouse> or point-less form, as i like to call it.
11:59:46 <tibbe> haha
11:59:49 <davidhouse> tibbe, without lambda.
11:59:57 <tibbe> oh
11:59:58 <davidhouse> tibbe, it doesn't involve any of its argument
12:00:02 <xerox> tibbe: i.e. no bound variables.
12:00:20 <xerox> tibbe: I think it's okay to call points-free code combinators.
12:00:23 <tibbe> is it actually useful?
12:00:23 <davidhouse> e.g. here \a b -> join (a ++ b) is the same as (join .) . (++)
12:00:30 <davidhouse> tibbe, occasionally
12:00:36 <davidhouse> sometimes it produces nice results.
12:00:38 <davidhouse> but sometimes:
12:00:40 <xerox> When it does improve readability.
12:00:52 <xerox> (And when one does do theoretical mumblage too, maybe.)
12:01:00 <davidhouse> @pl \f g x y -> f (g x) (g y)
12:01:00 <lambdabot> join . ((flip . ((.) .)) .) . (.)
12:01:05 <SamB> xerox: person who lets posts from non-members onto the list
12:01:08 <tibbe> I guess I do it without thinking mostly, I don't like explicit lambdas
12:01:26 <davidhouse> when things get more complex, @pl is nice.
12:01:28 <SamB> oh yes, moderator is the term
12:01:30 <xerox> SamB: woops, I don't exactly know.  SPJ suggested me to mail the Haskell list.
12:01:40 <xerox> I did register in order to do it anyway.
12:01:41 <tibbe> I see, it doubles as a code obfuscator 
12:01:49 <DeliQ> @pl \x y -> (x, y)
12:01:50 <lambdabot> (,)
12:01:52 <davidhouse> heh. quite.
12:01:54 <DeliQ> hehe
12:02:04 <davidhouse> DeliQ: that actually works
12:02:09 <davidhouse> > (,) 1 2
12:02:10 <lambdabot> (1,2)
12:02:18 <SamB> xerox: so maybe you could just convey our approval, considering Haskell is a Lazy language...
12:02:20 <davidhouse> > (,,) 1 2 3
12:02:21 <lambdabot> (1,2,3)
12:02:22 <DeliQ> never knew it was a function
12:02:23 <tibbe> > (,,) 1 2 3
12:02:24 <lambdabot> (1,2,3)
12:02:25 <tibbe> dah!
12:02:29 <xerox> SamB: slacker!!!!11
12:02:46 <DeliQ> i thought something with zip
12:02:48 <SamB> xerox: if I subscribed, I'd have to unsubscribe again after!
12:03:04 <xerox> SamB: if you say so.  I'll be doing it.
12:03:08 <wchogg> SamB:  Why is that?
12:03:18 <tibbe> SamB, just make sure your subscription goes out of scope
12:03:21 <SamB> wchogg: so that my inbox wouldn't get to 4000 unread messages
12:03:24 <tibbe> and it gets GCed
12:03:32 <mahogny> hm. question, google SoC, who registered haskell? are they just really slow at adding haskell.org to the list of projects?
12:03:44 <xerox> mahogny: sigh.
12:03:47 <SamB> mahogny: hasn't happened yet!
12:03:54 <mahogny> :o
12:03:58 <xerox> mahogny: it has to happen as soon as we receive consensus!
12:04:04 <xerox> Wasn't it clear on the mail?
12:04:09 <mahogny> ...mail? :o
12:04:13 * mahogny looks in the mailbok
12:04:15 * SamB hands consensus to xerox
12:04:18 <xerox> Sigh :-(
12:04:31 <SamB> I haven't heard any objections!
12:04:35 <xerox> http://www.haskell.org//pipermail/haskell/2006-April/017872.html
12:04:36 <tibbe> why does the word consensus remind me of totalitarianism? :p
12:05:03 <SamB> it reminds me of selonians, who take forever to decide most things. rather like ents, only without the long names.
12:05:07 <DeliQ> @pl \[x] [y] -> [(x, y)]
12:05:08 <lambdabot> (line 1, column 2):
12:05:08 <lambdabot> unexpected "["
12:05:08 <lambdabot> expecting pattern
12:05:15 * xerox <- dinner; sendMail =<< collectedThoughtsOnIRC
12:05:36 <xerox> (Yes, that's a do action.)
12:05:44 <wchogg> Wait, so xerox is the result of dinner?
12:05:46 <tibbe> I picture a man with dark mustaches hitting his fist on his podium yelling: "We will have consensus!"
12:05:52 <SamB> wchogg: I was going to say that
12:05:58 <tibbe> and shoot everybody who disagrees
12:06:13 <DeliQ> @pl \x y -> [(x, y)]
12:06:14 <wchogg> tibbe:  Does another guy take his shoe off and pound the table?
12:06:14 <lambdabot> flip flip [] . ((:) .) . (,)
12:06:15 * SamB dyes his moustache
12:06:30 <wchogg> SamB:  You have a 'stache to dye?
12:06:31 <tibbe> wchogg, I'm not sure, the vision is a bit dim
12:06:44 <SamB> wchogg: not much of one, I guess
12:08:04 <davidhouse> DeliQ, or return . (,)
12:08:13 <davidhouse> > return . (,) $ 1 2
12:08:15 <lambdabot>  add an instance declaration for (Show (m (b -> (a, b))))
12:08:25 <DeliQ> hehe
12:08:27 <guywithmustache> we will have consensus!
12:08:31 <mahogny> xerox, well uh I give my concensus to anyone as long as we make the deadline of sending in our interest, which is tomorrow :)
12:08:36 <davidhouse> > (return . (,)) 1 2 :: [(Int, Int)]
12:08:37 <lambdabot> Couldn't match `[(Int, Int)]' against `b -> (a, b)'
12:08:48 <davidhouse> oh, right.
12:08:54 <davidhouse> > ((return .) . (,)) 1 2 :: [(Int, Int)]
12:08:56 <lambdabot> [(1,2)]
12:09:03 <davidhouse> > (return .) . (,) $ 1 2 :: [(Int, Int)]
12:09:04 <lambdabot> Couldn't match `[(Int, Int)]' against `a -> m (a1, a)'
12:09:21 <davidhouse> > ((return .) . (,) $ 1 2) :: [(Int, Int)]
12:09:22 <lambdabot> Couldn't match `[(Int, Int)]' against `a -> m (a1, a)'
12:09:32 <davidhouse> > ((return .) . (,)) 1 2 :: [(Int, Int)] -- just use this one :)
12:09:34 <lambdabot> [(1,2)]
12:09:35 <DeliQ> > zipWith (,) [1..5] [6..10]
12:09:36 <lambdabot> [(1,6),(2,7),(3,8),(4,9),(5,10)]
12:09:54 <davidhouse> > zip [1..5] [6..10] -- zip == zipWith (,)
12:09:57 <lambdabot> [(1,6),(2,7),(3,8),(4,9),(5,10)]
12:10:12 <DeliQ> yep kinda funny
12:10:23 <tibbe> @pl (.)(.)
12:10:23 <lambdabot> ((.) .)
12:10:24 <DeliQ> how is zip defined in prelude ?
12:10:32 <SamB> anyway, I will use my phenominal predictive powers to determine the consensus in advance of the consentors getting together to say so: Haskell.org should be a mentoring org.
12:10:35 <DeliQ> not with zipWith (,) right ?
12:11:09 <mahogny> SamB, right on :)
12:11:21 <DeliQ> > zipWith (\x y -> (x, y)) [1..5] [6..10]
12:11:22 <lambdabot> [(1,6),(2,7),(3,8),(4,9),(5,10)]
12:11:36 <davidhouse> DeliQ: i guess so
12:11:42 <davidhouse> @fptools Prelude
12:11:43 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
12:11:44 <SamB> actually, my predictive powers are usually bad, but I just seem to not see anyone saying otherwise ;-)
12:12:04 <davidhouse> @fptools Data.List
12:12:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:12:24 <SamB> I don't suppose ParsecT is a big enough project?
12:12:50 <wchogg> SamB:  ParsecT?  By name I'm guessing a transformer library for using parsec?
12:12:59 <reppie> How are you gentlemen
12:13:43 <SamB> wchogg: pretty much
12:14:03 <SamB> I'm not sure I'd want to do it, but I'd like to see it happen ;-)
12:14:30 <davidhouse> @fptools GHC.List
12:14:30 <lambdabot> GHC.List not available
12:14:38 <mnislaih> xerox: I don't know how consensus works here, but I sent an email anyway
12:14:49 <DeliQ> @type wrap
12:14:50 <lambdabot> Not in scope: `wrap'
12:14:56 <DeliQ> @type Data.List.wrap
12:14:57 <lambdabot> Not in scope: `Data.List.wrap'
12:14:59 <SamB> mnislaih: it may or may not reach the list
12:15:00 <DeliQ> hmm
12:15:12 <SamB> (in time)
12:15:13 <mnislaih> hmm
12:15:18 <mnislaih> why ?
12:15:25 <DeliQ> not exported i guess
12:15:32 <SamB> are you a listmember?
12:15:34 * SamB is not
12:15:37 <davidhouse> DeliQ: actually it appears zip is defined thusly: zip (a:as) (b:bs) = (a,b) : zip as bs
12:15:45 <mnislaih> a list member?
12:15:50 <davidhouse> (at least in GHC)
12:16:05 <SamB> or did you just send it direct?
12:16:05 <mnislaih> ok, I thought it was possible to send things, but maybe only haskell-cafe is open, right ?
12:16:13 <DeliQ> i think zipWith (,) is way more elegant
12:16:27 <DeliQ> and more readable if you ask me
12:16:28 <davidhouse> yeah.
12:16:29 <SamB> oh, you can send things, but the list moderator has to pass them on to the list before they reach it
12:16:45 <SamB> so, basically, it might be too late when that happens
12:17:09 <mnislaih> all the messages are moderated ? that's excessive
12:17:31 * DeliQ <- (cup of tee)
12:17:36 <SamB> well, do you know how much spam hits that list?
12:17:37 <mnislaih> but spam is worse I guess
12:17:38 * SamB doesn't
12:17:51 <SamB> yeah, usually!
12:18:02 * mahogny suddenly figures that the haskell.org mailing list is also a list he should be on :P
12:18:22 <SamB> I would be happy to join the list if I didn't have to recieve the mail ;-)
12:18:39 <DeliQ> SamB: you can get a daily digest
12:18:40 <mahogny> SamB, receieve batches?
12:18:47 <petekaz> I love gmane :-)
12:18:51 <mnislaih> SamB I just learnt that my message has been automatically rejected
12:18:53 <wchogg> SamB:  Then join and just filter everything from @haskell.org? :-P
12:18:54 <SamB> that is still one per day
12:19:01 <SamB> mnislaih: rejected?
12:19:07 <Korollary> I think there's an option for that
12:19:12 * tibbe joins DeliQ with a cup of tee
12:19:12 <mnislaih> You are not allowed to post to this mailing list, and your message has been automatically rejected. If you .....
12:19:23 <SamB> Korollary: I don't know if mere users can set it, though
12:19:35 <DeliQ> tibbe: ;)
12:19:44 <Korollary> SamB: I did send messages to haskell-cafe but I dont get any mail.
12:20:11 <mahogny> SamB, one per day? I get one mail per minute :(
12:20:25 <tibbe> I get one digest per day
12:20:29 <SamB> mahogny: I don't envy you!
12:20:47 * tibbe <- dishes
12:21:02 <vincenz> how do I know what versions of stuff I have in cabal?
12:21:03 <SamB> tibbe: that is worse than what xerox said
12:21:18 <SamB> you come from the dishes?
12:21:20 <DeliQ> tibbe: how's your tee ? :P
12:21:23 <wchogg> mahogny:  So you said you're willing to mentor just about any app that's not a toy?
12:21:37 <mahogny> wchogg, more or less. it should have some decent content
12:22:07 <mahogny> wchogg, and at the other hand the poor bastard should be able to pull it off during the time :)
12:22:21 <wchogg> mahogny:  That latter point is more the one I'm debating.
12:22:40 <tibbe> DeliQ, good, a red tee
12:22:46 <tibbe> how's yours?
12:23:09 <wchogg> Red tee?
12:23:19 <mahogny> wchogg, well, I'll just wait and see what comes in. I usually have a good grasp of how long things take to code. just a bit worried that I'll have to give an estimate for someone I don't have prior experience woring with
12:23:20 <DeliQ> hmm, i'm having strawberry
12:23:25 <DeliQ> quite nice!
12:24:35 <DeliQ> i'm always experimenting with different tee flavors :P
12:25:01 * lispy had home grown green tea recently and it was great
12:25:29 <DeliQ> there is one kind i really don't like
12:25:30 <wchogg> mahogny:  Well if I did ask you to be the mentor it'd be because I wanted to write a event generator in haskell for particle physics.  It'd be pretty damn awesome if it worked, but I have no idea how long it could actually take.  A limited one *might* take the summer.
12:25:37 <DeliQ> here in holland they call it "rooibos"
12:25:44 <DeliQ> bus i don't know the english word for it
12:26:07 <wchogg> I can't stand coffee, but I love tea.  I have no idea why.
12:26:19 <lispy> wchogg: same here
12:26:36 <mahogny> wchogg, the simple solution is to know how to use the word "no" :)
12:26:39 <lispy> wchogg: i enjoy the smell of coffee tho, so if my friends go to a coffee shop i come along ;)
12:27:02 <DeliQ> i think you're a tea or a coffee person :P
12:27:08 * mahogny hates coffee
12:27:33 * mahogny loves tea when adding more sugar is hopeless because it won't dilute
12:27:41 <Korollary> lol
12:27:45 <wchogg> mahogny:  Sorry, I didn't understand the "no" comment.
12:28:08 <mahogny> wchogg, in that case, I think it's a chain reaction. what was your point? :/
12:28:28 <DeliQ> one time i had vanilla tea, was also quite nice!
12:29:21 <lispy> wchogg: no vs. know, "I have no idea why"  easy mistake to make in written english ;)
12:29:27 <lispy> er wait
12:29:37 <lispy> i don't understatd it either
12:29:47 <Saulzar> mahogny, I believe that is called sugar with tea :)
12:29:49 <lispy> hehe, /me was trying to hard to make sense of it and confused himself
12:30:03 <mahogny> Saulzar, yeah. and the tea can be approximated away :)
12:30:28 <DeliQ> approximated ??
12:30:29 <wchogg> I don't actually add much to my tea if it's green tea.  Black tea I think needs some sugar though.
12:30:34 <DeliQ> how can you approximate tea ?
12:30:36 <DeliQ> :P
12:30:49 <mahogny> DeliQ, with one very theoretic mind :)
12:31:01 <DeliQ> hehehe
12:31:14 <wchogg> DeliQ:  Well, you can make variations in the type of tea just be a perturbative correction to the taste.
12:31:55 <DeliQ> i guess so :P
12:32:43 <wchogg> ...this channel is so much less uptight than #lisp.  Wow.
12:34:29 <DeliQ> talking about lisp, how would you compare the power of lisp to haskell ??
12:34:38 * tibbe doesn't put anything in his tea
12:35:01 <DeliQ> considering lisp is in the running for say 20 years now
12:35:10 <Korollary> 30+
12:35:17 <DeliQ> 30+ even :P
12:35:44 <wchogg> DeliQ:  They're pretty apples and oranges I think.  They both have the goal of powerful expressiveness but with entirely different techniques.  Lisp allows you to easily screw with the ast via macros, but Haskell attempts to increase expressiveness with a very powerful type system.
12:36:02 <wchogg> Haskell code is "safer" though because of its type system.
12:36:06 <DeliQ> true...
12:36:17 <DeliQ> lisp does runtime checking right ?
12:36:22 <DeliQ> type checking
12:37:11 <wchogg> Yeah, both Scheme and CL are dynamically typed.
12:37:35 <mahogny> are there any compilers for lisp? I can imagine it being hell to make an efficient one
12:37:43 <Korollary> there are
12:37:50 <mahogny> is it fast?
12:38:08 <wchogg> mahogny:  CMUCL and SBCL are pretty fast yes.
12:38:10 <Korollary> yeah as long as it can infer types.
12:38:20 <mahogny> ok, makes sense
12:38:22 <wchogg> Korollary:  Well, you can just add type annotations.
12:38:22 <lisppaste2> Saulzar pasted "Existential badness" at http://paste.lisp.org/display/19292
12:38:41 <lispy> wchogg: yeah, the uptight SBCL culture in #lisp kinda drove me out of that channel
12:39:45 <lispy> but look at the SBCL entries of the great programming language shootout and you'll see that efficient lisp is no match for efficient haskell...which might blow you away when you think about the 'tricks' you can do in lisp for performance
12:40:07 <lispy> it surprised me at least
12:40:27 <Saulzar> I have a (fairly dodgy) experiment to try and pause/resume ST, however GHC is denying me the right to get my variable out with various excuses such as "brain exploding" :)
12:40:32 <wchogg> lispy:  I don't know though if all the tricks you could use for optimizing lisp were used in those entries though.
12:41:04 <wchogg> lispy:  The difference in memory usage is pretty staggering though if I remember correctly.
12:41:35 <Saulzar> If anyone knows a little more about such crazy types - if I'm doing something impossible maybe, seems unlikely that it should work?
12:42:35 <lispy> wchogg: yeah for one thing, in lisp you have to add the compiler to the overhead of any program you run
12:42:58 <DeliQ> i only know some very basic scheme
12:43:29 <DeliQ> but i am not attracted to counting ( and )
12:43:34 <DeliQ> ;)
12:43:52 <lispy> well, that's an editor/coding style issue
12:44:13 <DeliQ> true, but haskell is still way more elegant
12:44:23 <DeliQ> it's personal i think
12:44:31 <wchogg> emacs handles the parenthesis for you pretty well.  Honestly I think Haskell vs. CL or Scheme comes down to how you feel about type systems and metaprogramming.
12:44:56 <lispy> yup
12:45:20 <lispy> i really like both haskell and lisp, but i've been using haskell recently because i feel that the compiler does a lot more for me
12:45:28 <lispy> and i like what it's doing :)
12:45:33 <nomeata> Hi. I'm trying to use GConf from within gtk2hs, but I fail to see how to detect if an gconf key is set. When I get an unset key, I get *** Exception: user error (GConf: cannot get value of key, key is unset)
12:45:56 <wchogg> lispy:  I've been using haskell more lately because I feel like the haskell community is more willing to try new and experimental things.
12:46:27 <wchogg> lispy:...and because I'll always be a mathematician at heart.
12:46:48 <davidhouse> @karma+ maths
12:46:49 <lambdabot> maths's karma raised to 1.
12:47:00 <DeliQ> lol
12:47:07 <lispy> wchogg: right on
12:47:10 <DeliQ> @karma+ DeliQ
12:47:11 <lambdabot> You can't change your own karma, silly.
12:47:14 <DeliQ> hehehe
12:47:18 <DeliQ> i could use some karma :P
12:47:31 <davidhouse> argh. i've got type systems on the brain. someone just said "my connection go boom", and i read it as "my connection go bottom" :S
12:47:38 <wchogg> Hrmm...that'd make for an interesting slogan.  "Haskell:  we're not hackers, we're lazy mathematicians".
12:47:50 <mahogny> nice one :)
12:48:12 <wchogg> davidhouse:  They evaluated their connection strictly?
12:48:24 <lispy> "Haskell: Viagra for the mind."
12:48:25 <davidhouse> if it wasn't for maths, i wouldn't be here right now. (Cale introduced me via 
12:48:28 <davidhouse> #math)
12:49:08 * davidhouse tries to imagine a lazy connection protocol
12:49:34 <mahogny> davidhouse, what would be the use? o_O
12:49:43 <wchogg> davidhouse:  Your system says "eh, if you've got data then I'll think about connecting".
12:49:44 <int-e> don't bother, we can't deliver the packets reliable anyway <-- is that lazy enough?
12:49:51 <Cale> nomeata: probably an exception is thrown which you can catch
12:49:59 <int-e> *reliably
12:50:22 <davidhouse> int-e, heh.
12:50:49 <davidhouse> "transport that package to NS501? you're kidding, that's all the way across the other side of the network."
12:51:08 <nomeata> Cale: can you give me a pointer on how I do that?
12:51:34 <davidhouse> @hoogle catch
12:51:35 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
12:51:35 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
12:51:35 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
12:51:40 <norpan> is there a predefined strictness monad
12:51:42 <norpan> ?
12:52:14 <Cale> nomeata: what davidhouse/lambdabot said :)
12:52:51 <Cale> norpan: strictness monad?
12:53:01 <davidhouse> norpan, how would that work? do { expr1; expr2 } -> expr1 `seq` expr2, perhaps?
12:53:06 <norpan> yes
12:53:08 <norpan> or deepSeq
12:53:34 <davidhouse> @hoogle deepSeq
12:53:35 <lambdabot> No matches found
12:53:48 <lispy> huh, that's an interesting idea
12:53:53 <nomeata> Cale: thanks
12:54:19 <DeliQ> @hoogle DeepSeq
12:54:20 <lambdabot> No matches found
12:54:23 <norpan> it's not a new idea, just wondering if there was one
12:54:27 <DeliQ> hmm case insensitive :P
12:55:20 <davidhouse> what's deepSeq?
12:55:34 <davidhouse> norpan, how would >>= work?
12:55:36 <_SamB_> @hoogle deepSeq
12:55:37 <lambdabot> No matches found
12:56:00 <SamB> @index deepSeq
12:56:00 <lambdabot> bzzt
12:56:10 <davidhouse> norpan, keeping in mind that you have to engineer it such that (>>= const) == seq
12:56:10 <norpan> davidhouse: it would apply seq to the argument before passing it on
12:57:06 <SamB> what is being discussed? a strictness monad?
12:57:17 <norpan> i'm just wondering if there is one
12:57:27 <davidhouse> what is deepSeq/
12:57:44 <norpan> deepSeq will evaluate the expression fully
12:57:46 <int-e> davidhouse: http://www.haskell.org/pipermail/haskell/2001-August/007712.html
12:58:33 <dcoutts> nomeata, use a Maybe type
12:58:34 <ihope_> Does GHC optimize x^2 to x*x?
12:58:37 <wchogg> I can't really see how strictness would fit into the idea of a monad.  What would a type like Strict () mean?
12:58:59 <davidhouse> a strict computation that evaluates to ()?
12:59:03 <norpan> wchogg: it would be like the Id monad
12:59:19 <goron> I made a circular tree implementation (at least I think it is): http://pastebin.com/677463
12:59:34 <ihope_> And x^3 to x*x*x, and x^4 to xx*xx where xx = x*x...
12:59:36 <norpan> just that bind would ensure that the previous expression is evaluated
12:59:45 <dcoutts> nomeata, see the gconf demo
12:59:47 <lispy> ihope_: i don't think so
12:59:58 <SamB> how about StrictT?
13:00:05 <lispy> ihope_: but i think you could that with rewrite rules or maybe attribute grammars
13:00:23 <lispy> ihope_: of which you can get support for in ghc
13:00:26 <goron> Could someone with more experience check whether it really is one? When I evaluate takeTree, I get some unexpected results.
13:00:34 <ihope_> Or by using multiplication instead of exponentiation :-P
13:00:43 <goron> *CircularTree> takeTree 6 (getTree [1..100])
13:00:44 <goron> [1,1,1,1,1,1,4,7,7,10,13,13,13,16,19,19,22,26,26,26,26,29,32,32,35,38,38,38,41,44,44,47,51,51,51,51,51,54,57,57,60,63,63,63,66,69,69,72,76,76,76,76,79,82,82,85,88,88,88,91,94,94,97]
13:00:48 <lispy> ihope_: yeah, but you want it to be automated :)
13:01:15 <goron> I don't see where those 6 1's come from, other than that the first argument is 6.
13:01:53 <lispy> ihope_: you could look at the prelude definition of ^ and see if it is specialized for Integral exponents
13:02:08 <ihope_> @type (^)
13:02:10 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:02:18 <lispy> ihope_: but i'm guessing it uses a loop
13:02:19 <ihope_> I wouldn't say that it is. ;-)
13:02:37 <ihope_> lispy: what sort of loop?
13:02:58 <norpan> Strict m >>= f = Strict $ seq m (m >>= f)
13:03:01 <norpan> or something
13:03:32 <lispy> ihope_: i dunno...if your exponent is a Int greater than 0 you can just loop multiplying by x
13:03:37 <norpan> but not quite
13:03:42 <lispy> ihope_: but that's different than what you want right?
13:03:44 <goron> norpan: Could you have a look at my circular tree?
13:03:49 <xerox> norpan: you'd better define a Transformer I think.
13:04:08 <norpan> i need to find out what i want first
13:04:40 <norpan> i want deepseq because i want to use this to avoid memory leaks when i know stuff can be evaluated strictly more efficiently
13:05:26 <ihope_> (^) = power' 1 where power' r b 0 = r; power' r b e | even e = power' r (b*b) (e `div` 2); power' r b e | odd e = power' (r*b) (b*b) (e `div` 2)
13:06:24 <norpan> why does your circular tree take three type arguments?
13:07:21 <goron> norpan: Well, I want one for the value types. 
13:07:37 <goron> norpan: And I could indeed have used two.
13:07:44 <norpan> you could have used one
13:08:05 <norpan> but your paste looks strange
13:08:14 <ihope_> Then if you have a function like \b -> b^2, GHC would change this to power' 1 b 2, then to power' 1 (b*b) 1, then to power' (b*b) ((b*b)*(b*b)) 0, then to (b*b).
13:08:14 <norpan> strange half lines
13:08:27 <goron> norpan: oh, yes, 1 is possible too.
13:08:53 <ihope_> > (3 `div` 2)
13:08:54 <lambdabot> 1
13:09:04 <ihope_> Yeah, that's right.
13:09:34 <norpan> and what is a circular tree anyway?
13:09:35 <ihope_> Ideally it'd optimize b^e `mod` m as well.
13:09:53 <goron> norpan: Well, it's a useless datastructure.
13:10:11 <goron> norpan: I wanted to connect the leafs to the root.
13:10:32 <int-e> ihope_: the default implementation of ^ is a multiply-and-square; the question is if the compiler would inline it often enough to eliminate the recursion completely. I don't know that.
13:10:36 <goron> norpan: as a kind of generalization of circular doubly  linked lists.
13:10:53 <norpan> i see
13:10:53 <ihope_> > 218374628375621983648237428347621980^123978235129369838749 `mod` 10
13:10:57 <lambdabot> Terminated
13:11:08 <ihope_> It doesn't look like that's optimized.
13:11:17 <norpan> goron: you need to fix the paste though, i get broken lines
13:11:35 <lisppaste2> goron pasted "Circular tree" at http://paste.lisp.org/display/19294
13:11:35 <int-e> uhm, that's running out of memory :)
13:11:53 <goron> norpan: The paste was ok, the software on that server just sucks.
13:11:58 <norpan> ok
13:12:02 <norpan> ah \
13:12:04 <goron> norpan: But I pasted it somewhere else, and now it's ok.
13:12:08 <norpan> i see
13:13:45 <norpan> the first ones are the six first levels in your tree when you go down the left branch
13:13:57 <norpan> which is a leaf and so, points to the root again, which is 1
13:14:21 <int-e> > (0 :+ (-1)) ^ 123978235129369838749
13:14:22 <lambdabot>  Not in scope: data constructor `:+'
13:14:44 <norpan> or?
13:15:17 <ihope_> int-e: well, first it should take both the exponent and the base modulo 10, to get 0^9 `mod` 10.
13:15:39 <ihope_> The base of 0 could abort the exponent immediately.
13:15:41 <goron> norpan: My intention was that the tree consists of the numbers given in the list.
13:15:42 <int-e> ihope_: but that's beyond the scope of ghc's optimizer
13:15:58 <ihope_> int-e: what do you mean?
13:16:00 <int-e> ihope_: you can make a Num instance for numbers modulo 10 though
13:16:15 <goron> norpan: I do expect |leafs| 1's though.
13:16:16 <norpan> goron: ah i see
13:16:37 <norpan> goron: you put the first element in the list in to many places
13:16:46 <norpan> you use both head xs and take l xs
13:16:56 <goron> norpan: Oh, that's it.
13:16:59 <goron> norpan: great
13:17:06 <int-e> ihope_: and taking the exponent mod 10 is wrong. you to take it mod 4.
13:17:18 <norpan> you should pattern match (x:xs) in your function
13:17:24 <ihope_> int-e: why mod 4?
13:17:27 <goron> (take l xs) -> (take l (tail xs))
13:17:27 <norpan> and then use x instead of head xs
13:17:46 <int-e> ihope_: because phi(10)=4.
13:17:48 <goron> norpan: it's equavalent, isn't it?
13:17:55 <goron> er equivalent
13:17:58 <norpan> it may be, but it's better design
13:17:59 <int-e> ihope_: and you need to be careful with small exponents.
13:18:06 <norpan> [] and x:xs as cases for lists
13:18:10 <ihope_> Ah, so it's the totient we need...
13:19:29 <int-e> ihope_: using a Num instance that defines multiplication mod 10 will take you a long way though, even without factoring the 10.
13:21:23 <int-e> ihope_: if you have a ghci around: (sin 2 Data.Complex.:+ cos 2) ^ 12391444212141211 is evaluated instantly (and the result suffers from rounding errors)
13:21:35 <norpan> goron: also, have a look at splitAt
13:31:11 <kombinator> how do I easily parse sequence of numbers in haskell (like for (..) scanf ("%d", ..) in C)?
13:31:41 <resiak> > (read "153") :: Int
13:31:43 <lambdabot> 153
13:31:53 <SamB> > map read $ words "1 5 3"
13:31:54 <lambdabot> Add a type signature
13:31:56 <ihope_> > (read "3.0") :: Float
13:31:57 <lambdabot> 3.0
13:32:01 <SamB> > map read $ words "1 5 3" :: [Int]
13:32:02 <lambdabot> [1,5,3]
13:32:13 <ihope_> > read "[1,5,3]" :: [Int]
13:32:14 <lambdabot> [1,5,3]
13:33:33 <kombinator> is there any IO action that works like scanf ("%d", ..)?
13:34:00 <ihope_> Well, I don't know what scanf does.
13:34:04 <ihope_> What does it do?
13:34:19 <norpan> readIO
13:34:28 <kombinator> scanf ("%d") discards leading whitespace and parses an int from stdio
13:34:31 <kombinator> stdin
13:34:44 <ihope_> @index readIO
13:34:45 <lambdabot> System.IO, Prelude
13:34:49 <SamB> > read "    1" :: Int
13:34:50 <ihope_> @type readIO
13:34:50 <norpan> no, not readIO
13:34:50 <lambdabot> 1
13:34:51 <lambdabot> forall a. (Read a) => String -> IO a
13:34:59 <ihope_> readLine?
13:35:12 <ihope_> @type readLine
13:35:13 <lambdabot> Not in scope: `readLine'
13:35:16 <SamB> > read "    1        " :: Int
13:35:17 <lambdabot> 1
13:35:23 <ihope_> @type System.IO.readLine
13:35:23 <SamB> > read "    1        1" :: Int
13:35:24 <lambdabot> Not in scope: `System.IO.readLine'
13:35:24 <lambdabot> Exception: Prelude.read: no parse
13:35:30 <ihope_> @index readLine
13:35:31 <lambdabot> bzzt
13:35:33 <kombinator> something like readWord would be ok
13:35:44 <kombinator> I want to read one token at a time
13:35:48 <SamB> @index readLn
13:35:49 <lambdabot> System.IO, Prelude
13:35:53 <ihope_> Aha.
13:35:55 <norpan> jsut use getContents and work on the String
13:36:08 <SamB> norpan's idea is probably best
13:36:19 <Lokadin> say how would i test if a program with sockets works?
13:36:30 <resiak> Can't "     1     1     1" be handled with map read $ words ?
13:36:33 <ihope_> Lokadin: run it?
13:36:38 <resiak> s/$/./ I guess
13:36:41 <SamB> Lokadin: with much hair-pulling!
13:36:46 <Lokadin> well it runs but i don't know how to connect to it
13:36:56 <SamB> nc, maybe
13:37:00 <Lokadin> it's supposed to be an echo server that quits with :quit
13:37:05 <Lokadin> on port 2323
13:37:13 <SamB> nc should work, I think
13:37:24 <Lokadin> nc?
13:37:26 <SamB> nc localhost 2323
13:37:40 <Lokadin> oh okay one sec
13:37:52 <Lokadin> command not found nc
13:37:55 <dcoutts> wchogg, did you get xerox to note down your project idea?
13:37:56 <Lokadin> maybe netcat?
13:38:05 <SamB> that is the name of the package ;-)
13:38:05 <xerox> Please tell me.
13:38:15 <SamB> the executable is called nc, though
13:38:22 <sethk> the netcat command is (ordinarily) nc
13:38:36 <dcoutts> xerox, see the email from yesterday on haskell-cafe
13:39:06 <Lokadin> hmm, it doesn't seem to work :(
13:39:22 <ihope_> @index phi
13:39:23 <lambdabot> bzzt
13:39:27 <ihope_> @index eulerphi
13:39:28 <lambdabot> bzzt
13:39:32 <ihope_> @index eulerPhi
13:39:33 <lambdabot> bzzt
13:39:48 <SamB> ihope_: what are you looking for?
13:39:55 <ihope_> The totient function.
13:41:18 <wchogg> dcoutts:  Oh sorry, I was doing the dishes.
13:41:50 <dcoutts> wchogg, np, I just wanted to make sure your idea didn't get lost
13:42:41 <SamB> did anyone say whether ParsecT was big enough?
13:42:58 <wchogg> xerox:  It's the stuff I had mentioned earlier about wanting to either put together a numerics library for Haskell or to expand the bindings to existing libraries.
13:43:05 <Lokadin> so wait, when i do netcat localhost 2323, i get nothing, so do i just type, hello, see if the server echo's back, or do i have to do anything special?
13:43:13 <xerox> wchogg: yes, I remember now.
13:43:21 <SamB> Lokadin: try "hello"
13:43:39 <Lokadin> SamB: nope :(
13:43:44 <kombinator> working on an String would be imprectical for me - I want to parse an int 'n' and then n other integers and repeat that. I would have to pass continuations (rest of the string) everywhere
13:43:59 <SamB> Lokadin: hmm, hit enter a bunch of times?
13:44:37 <Lokadin> i did :(
13:44:38 <Lokadin> lol
13:44:52 <wchogg> Oh I saw Lemmih added a new entry to the SoC project ideas.  Debugging tools would be pretty cool I imagine.
13:45:05 <nomeata> dcoutts: just curious: can I expect TreeModelFilter and TreeModel signals to be supported in the near future, or should I try to get along without these features?
13:45:24 <Lokadin> netstat shows there is indeed a server listening on port 2323
13:45:49 <kombinator> I guess I'll resort to Parsec (again)
13:46:24 <SamB> kombinator: so?
13:46:28 <SamB> Parsec is nice!
13:47:06 <newsham> question: is there a clean way to do this?  http://udp110165uds.hawaiiantel.net:8888/x/ser.lhs
13:47:25 <kombinator> but it seems like a too advanded tool for the job
13:47:30 <newsham> basically the series [1,3,7,12,18,26,35,45,56,69]
13:47:44 <newsham> where the diff bewteen elemetns is the next integer not in the series
13:47:46 <dcoutts> nomeata, what do you need exactly?
13:48:24 <Lokadin> say how do i tell my cabal, that i need ghc to compile with -package network? just put it into the ghc options?
13:48:58 <nomeata> dcoutts: well, I'd like to have a TreeView that displays just a certain selection of the rows in my ListStore.
13:49:04 <dcoutts> Lokadin, depends: network
13:49:20 <nomeata> dcoutts: but more important are the TreeModel signals, so I can write changes to the underlying SQL database
13:49:57 <dcoutts> nomeata, we've got better ways of doing that now, you'll be able to make your own model rather than mirroring changes to another model
13:50:05 <Lokadin> dcoutts: thanks :)
13:50:29 <dcoutts> nomeata, an recordset model would be quite interesting
13:50:35 <dcoutts> and useful
13:50:55 <dcoutts> it's the kind of thing we were thinking of when we designed the new api
13:51:06 <nomeata> dcoutts: hmm, sounds interesting, but assuming the SQL database is slow, and I _want_ to use the ListStore, then I'd like to have the TreeModel singals :-)
13:51:26 <dcoutts> nomeata, do you want to emit them or monitor them?
13:51:38 <nomeata> dcoutts: monitor
13:51:45 <dcoutts> nomeata, ok, we've not done that
13:51:50 <nomeata> dcoutts: anyways, I'd like to have that code running in the next week or two. Should I wait for new stuff, or try to get along with what I have?
13:52:12 <dcoutts> nomeata, and I don't think we're planning to bind them because we didn't anticipate writing views in Haskell
13:52:24 <newsham> anyone?  recursive math problem?  seems like the kidn of thing people here get all giddy about.
13:53:12 <dcoutts> nomeata, with the new api, the right way to go would be to write an adapter so that your SQL model can be presented as a TreeModel (and you can do your own caching if it's slow)
13:53:24 <nomeata> dcoutts: sounds good, too
13:53:54 <nomeata> dcoutts: but I don't think only views need the signals. What if I want to update other parts of the UI on changes
13:53:59 <alec> newsham: I can't get through to the server, put it up on the channel pastebin?
13:54:04 <nomeata> dcoutts: or do any weird stuff, for that matter :-)
13:54:12 <alec> newsham: http://paste.lisp.org/new/haskell
13:54:24 <alec> newsham: I'm still learning, can't promise to be of any help :)
13:54:36 <newsham> http://www.lava.net/~newsham/x/ser.lhs  this should work
13:54:51 <dcoutts> nomeata, can't you do that on the Haskell side, eg you make some abstraction so that when you change your model you update others things that need it?
13:55:40 <nomeata> dcoutts: that's what I plan, but I thought signals would be cleaner, as then I don't have to worry where I write to the model
13:56:35 <dcoutts> nomeata, well if you really want them you can bind them, I don't expect they're that tricky, but I think it might be cleaner not to go via the C signals
13:57:01 <dcoutts> nomeata, I'm sure there's an idea for a more general mid-level api in there somewhere - that is you want to have some program state and share it with GUI widgets for display/update
13:57:08 <norpan> newsham: something like invseries n (s:ss) = if n == s = invseries (n+1) ss else n:invseries n (s:ss)
13:57:13 <alec> newsham: what don't you like about the first definition?
13:57:24 <dcoutts> and you want to be able to link/sync these states via functions
13:57:36 <norpan> and then call it with invseries 1 series
13:58:01 <dcoutts> I started writing an abstraction like that, but other work got in the way
13:58:12 <goron> norpan: It works like a charm. splitAt splits a list into two parts, but I need a function which gives me three things: an element, and the rest of the list divided into two things, although, I suppose using (x:xs) solved that part. 
13:58:21 <nomeata> dcoutts: ok, thanks so far. I will bug you with further gtk2hs inquiries later :-). and I'm looking forward to the model creating code
13:58:34 <norpan> goron: yes, exactly
13:58:43 <dcoutts> nomeata, ok, np. You can try it out, it's all in darcs
13:58:57 * nomeata is lazy and waits for debian packages
13:58:58 <kombinator> SamB: does Parsec contain a predefined combinator for parsing integers?
13:59:24 <dcoutts> nomeata, it's probably still a bit too hard to make your own models, but it's something we'd like to improve
13:59:44 <norpan> newsham: but my function will probably not work, because it can't deduce that 2 is not in the series until it has computed 3
13:59:50 <dcoutts> we've got two simple model implementations - updatable lists & trees
14:00:06 <goron> norpan: are you a student at Chalmers?
14:00:11 <norpan> goron: was
14:00:22 <SamB> kombinator: sorta
14:00:25 <goron> norpan: Sweden and Haskell, can't miss ;)
14:00:30 <newsham> alec: the first definition has to artificially produce the first few values of invseries
14:00:33 <newsham> instead fo computing them
14:00:51 <norpan> you would probably get away with series = 1:3:... though
14:01:03 <newsham> true, but that is also artificial
14:01:03 <SamB> kombinator: I mean, you can steal one from TokenParser or whereever
14:01:50 <newsham> actually you'd need to do 1:3:7  
14:02:07 <norpan> yes
14:02:08 <lisppaste2> Lokadin pasted "stolen echo server" at http://paste.lisp.org/display/19295
14:02:23 <newsham> problem is that you cant search for 2 in    1:???
14:02:24 <Lokadin> say, so any way i can find out if it works?
14:02:30 <norpan> it can't know that 2 is not in the series until it has already computed it to be 3
14:02:46 <Lokadin> other than netstat, because netcat doesn't work :(
14:02:48 <norpan> similar for 4 and 7
14:02:56 <norpan> so you need to specify 1:3:7
14:03:34 <newsham> but thats not inherent in the problem as demonstrated in series2
14:03:45 <newsham> which does not seed the series with any values other than 1
14:03:58 <alec> Lokadin: does telnet not work?
14:04:11 <Lokadin> er one sec let my try it again
14:04:29 <newsham> it feels like there should be a more elegant solution in haskell
14:05:15 <norpan> there may be
14:06:04 <Lokadin> alec: well nothing really happens it connects but it doesn't visible do anything
14:06:57 <norpan> but series2 looks strange
14:07:19 <newsham> yah, i agree.  series2 is how you'd write it in something like scheme
14:07:23 <newsham> (w/o lazy evaluation)
14:07:35 <goron> norpan: Interesting how much bugs can go into such a piece of code. There was also a symmetric error in the drop part (symmetric to the take).
14:07:50 <Lokadin> alec: and if i connect to things that don't exist it does the same things
14:08:01 <newsham> series2 also builds up the series twice, once forward and once in reverse
14:09:22 <Lokadin> alec: did you try running it?
14:09:29 <alec> Lokadin: it doesn't look like it echos back, but just prints whatever you say to the terminal that's running the program
14:09:39 <norpan> but initing the series is not that bad
14:09:43 <alec> Lokadin: or, rather, hugs, since that's what I'm running it in
14:09:47 <newsham> (series2 coudl be more efficient by pruning the low values in seq at each iteration, since its an ordered list and you're searching for a higher value than last time)
14:10:09 <Lokadin> alec: oh cool alright thanks :)
14:10:13 <norpan> and you will get a pretty effective functino
14:10:13 <alec> Lokadin: I assume you're trying to write a "real" echo server
14:10:23 <alec> Lokadin: when you connected with telnet, you did specify the port?
14:12:07 <Lokadin> yep
14:12:08 <Lokadin> 2323
14:12:28 <Lokadin> but it just says trying never says anything else
14:13:07 <Lokadin> and yes i did want a real echo server
14:13:59 <nomeata> dcoutts: is the TreeSortable API available?
14:14:25 <dcoutts> nomeata, not yet
14:15:04 <nomeata> dcoutts: ok
14:15:20 <dcoutts> nomeata, if you want to help us hack on it then just say :-)
14:16:21 <nomeata> dcoutts: maybe later. currently I'm spending my time to getting used to imperative haskell :-)
14:16:32 <dcoutts> nomeata, heh, ok :-)
14:17:34 <nomeata> dcoutts: it is kind of unrewarding: the product does not look and feel any different than a gtk app created with python or C... :-)
14:18:03 <jlhamilton> newsham:  i'm looking at your code and one small change is to have the first line be series = 1 : zipWith (+) series invseries
14:18:19 <dcoutts> the code can often be shorter in Haskell than C or even python because we can use first class closures to good effect
14:18:36 <dcoutts> that and Haskell just has less cluttered syntax than C or python
14:19:03 <dcoutts> nomeata, or perhaps you were referring to the look of the GUI itself
14:19:24 <nomeata> dcoutts: the latter :-)
14:19:57 <dcoutts> nomeata, and for the latter of course that's rather the point :-)
14:20:25 <nomeata> dcoutts: you are right about the syntax, but one thing I don't like is the need to save anything to a variable first, (to get rid of the IO) before it can be used, even if only used once.
14:20:45 <nomeata> dcoutts: (unless it's the last argument to the next function, in which case >>= can be used)
14:21:00 <Lokadin> alec: say, it doesn't seem to work for me when i load it in ghc
14:21:12 <dcoutts> nomeata, right, or you can use liftM sometimes
14:21:22 <Lokadin> alec: ghci that is
14:21:54 <dcoutts> noj, or ap
14:21:57 <Lokadin> can anyone point me to a good sockets tutorial?
14:21:57 <dcoutts> @type Monad.ap
14:21:58 <lambdabot> forall b (m :: * -> *) a.
14:21:58 <lambdabot>     (Monad m) =>
14:21:58 <lambdabot>     m (a -> b) -> m a -> m b
14:22:10 <Lokadin> or even an okay one..
14:22:12 <xerox> Anybody knows about the incremental GC for GHC idea?
14:22:30 <dcoutts> xerox, there's already a paper on it, but it was never implemented
14:22:43 <nomeata> @type liftM
14:22:44 <lambdabot> forall r (m :: * -> *) a1.
14:22:44 <lambdabot>    (Monad m) =>
14:22:44 <lambdabot>    (a1 -> r) -> m a1 -> m r
14:22:44 <xerox> dcoutts: may you point me at it?  I need to write out a brief description
14:22:48 <dcoutts> see the papers section of the GHC dev site
14:22:56 <dcoutts> "non-stop Haskell"
14:23:26 <xerox> Thanks,.
14:23:37 <Lokadin> kk well g2g easter dinner :(
14:23:39 <xerox> (Nice site!!)
14:24:41 <davidhouse> woah. http://hackage.haskell.org/trac/haskell-prime/wiki/CompositionAsDot
14:25:35 <davidhouse> really hope that doesn't go in.
14:25:43 <xerox> dcoutts: do you also know what could I point people to wrt the handling of recursive modules in GHC ?
14:26:25 <dcoutts> xerox, hmm, I can't think of anything immediately
14:26:47 <dcoutts> xerox, I think that's probably a hard project, ask Simon M
14:27:01 <norpan> davidhouse: breaks quite a lot of code is an understatement
14:27:16 <xerox> I need students to propose ideas, the Sages' ideas are heavy :-D
14:27:30 <dcoutts> davidhouse, it really really can't go it, it's total crack
14:27:39 <dcoutts> (.) is used everywhere
14:27:39 <goron> That proposal is actually pretty funny :)
14:27:47 <xerox> goron: yay :-)
14:28:00 <davidhouse> norpan, quite
14:28:03 <goron> Still, breakage of code is not an argument, since you can write translators for that.
14:28:12 <xerox> goron: if you get around to read about it feel free to write a decent description on the wiki.
14:28:20 <dcoutts> goron, yeah, it's clearly proposed by someone who doesn't code Haskell the way the rest of us do
14:28:22 <xerox> Or ping me and I'll do with more informations.
14:28:42 <goron> xerox: what are you talking about?
14:28:54 <dcoutts> goron, but the alternatives are silly too `o` !?!!
14:28:55 <xerox> Are we talking about two different things?  Recursive modules.
14:29:17 <goron> xerox: I was talking about composition.
14:29:20 <davidhouse> xerox, removing (.) as composition
14:29:21 <xerox> Woops, sorry.
14:29:45 <xerox> What's the problem with (.) or even  or  ? :-)
14:29:59 <vincenz> xerox: the last one is a question mark in a white diamond
14:30:00 <davidhouse> qualified modules.
14:30:01 <goron> dcoutts: well, if someone would come up with a very accessible way to create a cool unicode character, that would be good too.
14:30:05 <dcoutts> davidhouse, actually it could easily been an april fools proposal, just on the wrong day
14:30:08 <davidhouse> s/qualified/hierarchial
14:30:22 <goron> dcoutts: Something like "put this in that file" and have it working.
14:30:31 <mauke> U+00B7 (0xc2 0xb7): MIDDLE DOT []
14:30:48 <davidhouse> what about the actual composition character?
14:30:49 <dcoutts> but my keyboard doesn't have that char :-(
14:30:57 <vincenz> my irc doesn't show that char!
14:30:59 <mauke> it's compose . . here
14:31:04 <goron> mauke: but you need either application support, or do it in X.
14:31:40 <nomeata> dcoutts: last question for tonight: can I somehow tell gtk2hs that the string literals in the source are utf8, not latin1?
14:31:51 <Korollary> I guess it doesn't have to be a single keypress
14:31:53 <goron> mauke: Or use a combination of keys, and the point(not intended) is that . is easy too use.
14:31:56 <dcoutts> nomeata, the Strings are Unicode
14:32:03 <dcoutts> String in Haskell is Unicode
14:32:15 <vincenz> > maxBound :: Char
14:32:16 <lambdabot> '\1114111'
14:32:23 <dcoutts> it jsut works, don't add an extra utf8 encoding on top or that's what you'll see on screen
14:32:30 <goron> > maxBound::Int
14:32:31 <xerox> mauke: do you know what's the compose key on OS X ?
14:32:32 <lambdabot> 2147483647
14:32:39 <mauke> xerox: no idea
14:32:39 <vincenz> > '\0xc2b7'
14:32:40 <nomeata> dcoutts: hmm, but when I used labelSetText, the result looks like utf8 treated like latin1
14:32:40 <lambdabot>  lexical error in string/character literal
14:32:44 <vincenz> > '\xc2b7'
14:32:45 <norpan> > ord (maxBound :: Char)
14:32:45 <lambdabot> '\49847'
14:32:46 <lambdabot> 1114111
14:32:53 <vincenz> > show '\xc2b7'
14:32:54 <lambdabot> "'\\49847'"
14:32:56 <vincenz> hmmm
14:33:03 <vincenz> why doesn't it display unicode?
14:33:11 <norpan> how could it
14:33:15 <vincenz> erm
14:33:17 <vincenz> output unicode
14:33:19 <goron> vincenz: putStrLn
14:33:20 <dcoutts> nomeata, that's probably because your [Char] was in an extra utf8 encoding
14:33:24 <vincenz> like 23:29 < mauke> U+00B7 (0xc2 0xb7): MIDDLE DOT []
14:33:30 <norpan> vincenz: what kind of unicode?
14:33:39 <vincenz> norpan: unicode, period
14:33:41 <vincenz> UNI-code
14:33:44 <mauke> vincenz: huhu, double utf-8
14:33:49 <mauke> a.k.a wtf-8
14:33:52 <nomeata> dcoutts: I did not set anything like that anywhere
14:33:59 <norpan> vincenz: i'm sorry, but it needs to convert the unicode to bytes to output it
14:34:02 <dcoutts> nomeata, where did the string come from?
14:34:10 <goron> vincenz: putStrLn "\xc2b7" works on terminal
14:34:13 <dcoutts> nomeata, a file containing utf8?
14:34:13 <mauke> vincenz: unicode isn't an encoding
14:34:18 <vincenz> so how come U+00b7 is a given character?
14:34:26 <norpan> so it needs to convert to something, UTF-8 for instance
14:34:28 <nomeata> dcoutts: the source itself
14:34:31 <mauke> unicode maps characters to numbers
14:34:32 * vincenz scratches his head
14:34:41 <mauke> you still have to store the numbers somehow
14:34:42 <nomeata> dcoutts: labelSetText label "Unicder"
14:34:45 <vincenz> right and isn't each unicode character unique
14:34:47 <goron> mauke: encodings to that too ;)
14:34:57 <goron> er do that too
14:35:00 <dcoutts> nomeata, ghc doesn't currently accept Unicode String literals
14:35:01 <norpan> yes, but number /= byte
14:35:09 <vincenz> so what is this U+00B7 (0xc2 0xb7): MIDDLE DOT []
14:35:21 <vincenz> (and that shows up as a ? in my irssi)
14:35:24 <norpan> that's UTF-8
14:35:26 <newsham> utf8
14:35:29 <mauke> no, that's WTF-8
14:35:30 * vincenz ponders
14:35:31 <nomeata> dcoutts: ok, thanks, I'll keep my source files in latin1 then
14:35:35 <newsham> unicode packed into 8-byte characters
14:35:36 <vincenz> isnt unicode uniquely defined?
14:35:41 <newsham> 8-bit characters
14:35:55 <norpan> the mapping between characters and numbers is
14:36:14 <vincenz> well each character = unique => must have a printable version
14:36:21 <goron> Who created all these characters anyway? 
14:36:21 <vincenz> why won't it print the <?> 
14:36:22 <norpan> sure
14:36:28 <newsham> goron: people
14:36:31 <norpan> because you have a bad terminal or bad font
14:36:33 <palomer>  evil people
14:36:35 <vincenz> but '\49847'
14:36:39 <palomer> man I'm rusty
14:36:43 <vincenz> hmm?
14:36:48 <norpan> vincenz: oh that you mean
14:36:52 <vincenz> yeah
14:36:53 <newsham> palomer: by definition.  if they werent evil then they would all speak american and use roman letters
14:37:01 <dcoutts> nomeata, so what's going on is that your text editor is saving in utf8 and ghc is taking that as a latin1 string which gives you the raw encoding
14:37:09 <norpan> it won't print it because it doesn't know which serialization to bytes to use
14:37:16 <vincenz> norpan: unicode = unique!
14:37:22 <norpan> you are not listening
14:37:29 <norpan> output is in bytes
14:37:29 <vincenz> or you're not communicating it clearly
14:37:31 <vincenz> yes
14:37:34 <dcoutts> nomeata, I think the next ghc version will accept utf8 encoded source files for at least things like comments and string literals
14:37:35 <norpan> bytes /= numbers
14:37:37 <vincenz> and each character = unique
14:37:44 <vincenz> so each character should have a unique encoding
14:37:55 <xerox> vincenz: the key is the interpretation when it comes to multiple bytes.
14:37:56 <norpan> it has, a number
14:38:11 <mauke> no, it doesn't
14:38:12 <dcoutts> nomeata, so what GUI are you building then?
14:38:14 <vincenz> ..
14:38:15 <mauke> numbers != encoding
14:38:16 <goron> norpan: are you saying that GHC interpretets source files as latin-1?
14:38:24 <goron> norpan: or just on his configuration?
14:38:32 <dcoutts> goron, that's exactly what ghc does
14:38:36 <norpan> i haven't said anything about ghci interpretatio, but it does :)
14:38:36 <goron> er interprets
14:38:41 <mauke> vincenz: you need a serialization format for numbers
14:38:53 <norpan> the most common is UTF-8, but there are others
14:39:37 <dcoutts> noteably UTF-16 which is used on win32
14:39:51 <goron> dcoutts: but shouldn't it use the default locale, as set by setlocale?
14:39:55 <newsham> sure, but you hardly hear someone say "this number is represented by 8-bits, active high 5volts = 1 0volts = 0, where numbers are built up using unsigned binary
14:40:05 <dcoutts> goron, perhaps it should but it doesn't
14:40:06 <norpan> goron: what it should and what it does are two different things
14:40:45 <dcoutts> goron, what it should do is use unicode exclusively (in some encoding(s))
14:40:46 <goron> Offtopic: I am actually somewhat impressed with UTF-8 characters on my terminal. 
14:40:54 <palomer> http://www.rafb.net/paste/results/bHT96r48.html
14:40:59 <norpan> but the problem here is exactly that to output to the terminal it needs to make bytes out of 21 bit integers
14:41:06 <palomer> @type do {(a,b) <- get; put (a+1,b); return a}
14:41:08 <lambdabot> forall a
14:41:08 <lambdabot>                  b
14:41:08 <lambdabot>                  (m :: * -> *).
14:41:08 <lambdabot>                (Num a, MonadState (a, b) m) =>
14:41:08 <lambdabot>                m a
14:41:12 <dcoutts> all other modern languages use unicode, and not just the user locale (since that makes the code totally unportable)
14:41:18 <palomer> why is my ghc being all strange?
14:41:45 <norpan> the only sane thing would be to say haskell source is always UTF-8
14:42:00 <dcoutts> norpan, indeed
14:42:18 <dcoutts> the H98 standard only mandates Unicode in an unspecified encoding
14:42:32 <norpan> since there is no encoding metadata on files
14:42:38 <dcoutts> right
14:42:47 <Philippa> or rather, since you don't know if there is or isn't
14:42:59 <norpan> or require a BOM as first character if not UTF-8
14:43:02 <norpan> or something
14:43:20 <goron> BOM? Some identifier bits?
14:43:44 <norpan> yes, U+FEFF
14:43:54 <goron> Byte Order Mark
14:44:00 <norpan> exactly
14:44:00 <goron> ty, wikipedia
14:44:13 <goron> I have looked that up before but I tend to forget such details.
14:44:26 <palomer> http://www.rafb.net/paste/results/cfV0HL12.html <--I don't see why I should be getting a type error here
14:44:30 <goron> I will remember when it costs me hours of work :P
14:45:08 <dcoutts> the BOM is an aBOMination iirc, I don't think the Unicode people reccomend it any more
14:45:12 <metaperl> I need some help getting something written using a list comprehension. I have it working using plain recursion but cant figure out how to do it with a list comprehension: http://rafb.net/paste/results/ZxJBHl48.html
14:45:29 <lispy> palomer: shouldn'tit be something like a <- get; put (a+1) ?
14:45:46 <palomer> lispy: I want it to return too
14:45:50 <xerox> kosmikus: ping
14:45:52 <palomer> lispy: besides, it types here!
14:45:54 <Philippa> lispy: not if he wants a tuple for state
14:46:14 <bolrod> put (a+1,b)  will put ((),(a+1,b))  if I read it correctly
14:46:30 <palomer> oh, it's the monomorphism restriction
14:46:46 * palomer kicks the monomorphism restriction
14:47:07 <bolrod> but I guesss   put 2  =>   ((),2)  
14:47:15 <bolrod> then return 4 =>  (4,2)
14:47:29 <norpan> how would it know which MonadState to use?
14:47:30 <bolrod> I still need to read through it carefully again though
14:47:31 <lispy> metaperl: i see your recursive definition, how far have you made it with the list comp. definition?
14:48:24 <lispy> @replicate
14:48:25 <lambdabot> Unknown command, try @list
14:48:29 <lispy> @hoogle replicate
14:48:30 <lambdabot> Prelude.replicate :: Int -> a -> [a]
14:48:30 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
14:48:30 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
14:48:52 <dcoutts> > (\n -> [ n | _ <- [1..n]]) 6
14:48:53 <lambdabot> [6,6,6,6,6,6]
14:49:07 <dcoutts> but it's a bit of a odd use of a list comp
14:49:08 <xerox> norpan: MonadState is a class with get/put methods, it is used in order to give transformer the opportunity of lifting automagically those operations.
14:49:11 <metaperl> lispy: nowhere
14:49:27 <xerox> > join replicate $ 6
14:49:28 <lambdabot> [6,6,6,6,6,6]
14:49:31 <xerox> ^__^
14:49:46 <lispy> metaperl: well..have you used list comps at all before?
14:50:01 <dcoutts> @type join
14:50:02 <metaperl> dcoutts: oh no, we have to create all numbers from 1 to n
14:50:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
14:50:10 <xerox> metaperl: enumFromTo 1
14:50:19 <xerox> > (enumFromTo 1) 6
14:50:19 <metaperl> rep 4 yields [1, 2,2, 3,3,3,4,4,4,4]
14:50:21 <lambdabot> [1,2,3,4,5,6]
14:50:21 <dcoutts> metaperl, well that can't be done with a list comp (I think)
14:50:25 <metaperl> I left that out
14:50:28 <mauke> > foo 6; foo 0 = []; foo n = [1 .. n] ++ foo (n - 1)
14:50:29 <lambdabot> [1,2,3,4,5,6,1,2,3,4,5,1,2,3,4,1,2,3,1,2,1]
14:50:37 <mauke> hmm, no
14:50:57 <xerox> mauke: those ';' are disturbing :-D
14:51:43 <dcoutts> metaperl, my proof: a list comp is just a bunch of filter & maps, and neither of those functions can increase the length of an input list
14:52:37 <metaperl> rep n = concat [ nn x | x <- [1..n] ]
14:53:30 <dcoutts> > unfoldr (\n -> if n <= 4 then Just (n,n+1) else Nothing) 0
14:53:32 <lambdabot> [0,1,2,3,4]
14:53:45 <lispy> > rep n = [ [1..n'] | n' <- [1..n]]; rep 3
14:53:46 <lambdabot>  parse error on input `='
14:53:49 <mauke> > foo 6; foo n = bar 1; bar x = [x .. n] ++ (if x < n then bar (x + 1) else [])
14:53:50 <lambdabot>  Not in scope: `n'
14:54:07 <mauke> > foo 6; foo n = bar 1 n; bar x n= [x .. n] ++ (if x < n then bar (x + 1) else [])
14:54:08 <lambdabot> Couldn't match `[a]' against `t -> t1'
14:54:15 <mauke> you win this round
14:54:25 <metaperl> where nn and nn' are in the paste: 
14:54:32 <lispy> > let rep n = [ [1..n'] | n' <- [1..n]] in rep 3
14:54:33 <lambdabot> [[1],[1,2],[1,2,3]]
14:54:40 <lispy> oh...silly me
14:54:40 <norpan> xerox: i know, but his code had no type, so how to know which instance of MonadState to use?
14:54:58 <xerox> norpan: infer by the context?
14:55:06 <norpan> there was no context
14:55:27 <palomer> is there a function for turning a commutative binary operation into an n-ary operation (where n >= 1) ?
14:55:42 <mauke> fold?
14:56:03 <lispy> > rep n = [ n' | n' <- [1..n], n'' <- [1..n'] ]; rep 3
14:56:03 <lambdabot>  parse error on input `='
14:56:04 <newsham> @type sum
14:56:06 <lambdabot> forall a. (Num a) => [a] -> a
14:56:13 <norpan> xerox: i was commenting on http://www.rafb.net/paste/results/cfV0HL12.html
14:56:14 <mauke> > rep 6; rep n = [ o | m <- [1..n], o <- [m..n] ]
14:56:15 <lambdabot> [1,2,3,4,5,6,2,3,4,5,6,3,4,5,6,4,5,6,5,6,6]
14:56:16 <lispy> > let rep n = [ n' | n' <- [1..n], n'' <- [1..n'] ] in rep 3
14:56:18 <lambdabot> [1,2,2,3,3,3]
14:56:38 <mauke> whoa
14:56:41 <vincenz> ?
14:56:53 <newsham> > sum' [1,2,3,4,5] where sum' = foldl (+) 0
14:56:54 <lambdabot> 15
14:57:03 <vincenz> @type join
14:57:04 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
14:57:08 <metaperl> what does n'' do in that lisp comp lispy?
14:57:14 <newsham> > prod' [1,2,3,4,5] where prod' = foldl (*) 1
14:57:15 <lambdabot> 120
14:57:18 <vincenz> > concatMap (join replicate) [1..3]
14:57:19 <lambdabot> [1,2,2,3,3,3]
14:57:33 <metaperl> @type replicate
14:57:34 <lambdabot> forall a. Int -> a -> [a]
14:57:38 <vincenz> > replicate 1 'a'
14:57:40 <lambdabot> "a"
14:57:42 <newsham> palomer: like such?
14:57:46 <vincenz> join f x = f x x
14:57:46 <lispy> vincenz: very nice monadic definition
14:57:50 <resiak> @type join
14:57:52 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
14:58:06 <vincenz> lispy: thanks!
14:58:07 <goron> That is one cool listcomprehension :)
14:58:16 <vincenz> > concatMap (join replicate) [1..5]
14:58:17 <lambdabot> [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
14:58:26 <metaperl> I dont see how vincenz's works a t all
14:58:32 <vincenz> metaperl: easy
14:58:34 <lispy> vincenz: now just replace concatMap with oh what was it... (>=) ?
14:58:37 <metaperl> and I dont understand the n'' part of yorurs lispy
14:58:38 <resiak> >>=
14:58:39 <vincenz> join replicate n = n n's
14:58:49 <vincenz> > [1..5] >>= join replicate
14:58:50 <lambdabot> [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
14:58:52 <lispy> metaperl: n'' is just a dummy variable, i could leave it out
14:58:57 <metaperl> @type join
14:58:59 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
14:58:59 <lispy> > let rep n = [ n' | n' <- [1..n], _ <- [1..n'] ] in rep 3
14:59:01 <lambdabot> [1,2,2,3,3,3]
14:59:04 <vincenz> > join (+) 2
14:59:06 <lambdabot> 4
14:59:12 <vincenz> join f x = f x x
14:59:24 <vincenz> join is one cool operator
14:59:37 <resiak> I don't understand the type of join. (+) isn't a monad!
14:59:42 <lispy> metaperl: this is a great exercise to teach you about 1) the list monad 2) how a list comprehension is transformed into the list monad
15:00:03 <xerox> > concat . takeWhile (not . null) . (iterate tail) . (enumFromTo 1) $ 6
15:00:04 <lambdabot> [1,2,3,4,5,6,2,3,4,5,6,3,4,5,6,4,5,6,5,6,6]
15:00:06 <palomer> newsham: yeah, foldl1 is the combinator I was looking for
15:00:09 <vincenz> > [1..5] >>= \x -> [x..5]
15:00:10 <lambdabot> [1,2,3,4,5,2,3,4,5,3,4,5,4,5,5]
15:00:18 <xerox> vincenz: nice shot.
15:00:30 <xerox> Great one, I was trying to use >>=.
15:00:31 <vincenz> > [1..5] >>= flip enumFromTo 5
15:00:32 <lambdabot> [1,2,3,4,5,2,3,4,5,3,4,5,4,5,5]
15:00:37 <metaperl> join is concat for non-lists I believe
15:00:45 <xerox> metaperl: that's right.
15:00:54 <xerox> @karma+ vincenz -- oof!
15:00:55 <lambdabot> vincenz's karma raised to 3.
15:01:03 <vincenz> :)
15:01:08 <vincenz> gotta love golfig
15:01:10 <vincenz> golfing
15:01:17 <lispy> heh
15:01:35 <goron> I thought every variable had to be used in a list comprehension. But that's completely not true :)
15:01:39 <vincenz> @pl \n -> [1..n] >>= flip enumFromTo n
15:01:39 <lambdabot> ap ((>>=) . enumFromTo 1) (flip enumFromTo)
15:01:46 <vincenz> o.O
15:01:49 <vincenz> @type ap
15:01:51 <lambdabot> forall b (m :: * -> *) a.
15:01:51 <lambdabot> (Monad m) =>
15:01:51 <lambdabot> m (a -> b) -> m a -> m b
15:01:51 <xerox> hehe.
15:01:58 <xerox> vincenz: m = Reader.
15:02:13 * vincenz nods
15:02:36 <vincenz> > ((>>=) . enumFromTo 1) .  (flip enumFromTo) 10
15:02:37 <lambdabot>  add an instance declaration for (Show (a -> ([a] -> [b]) -> [b]))
15:02:47 <xerox> add $
15:02:51 <vincenz> > ((>>=) . enumFromTo 1) .  (flip enumFromTo) $ 10
15:02:52 <lambdabot>   add an instance declaration for (Show (((a -> [a]) -> [b]) -> [b]))
15:02:55 <vincenz> nope
15:02:57 <vincenz> need ap
15:03:01 <xerox> add an instance declaration for.. :-P
15:03:03 <metaperl> lispy: I dont get yours - let rep n = [ n' | n' <- [1..n], _ <- [1..n'] ] in rep 3
15:03:05 <xerox> You missed the ap, in fact.
15:03:13 <vincenz> metaperl: basically it says this
15:03:15 <metaperl> n' <- [1..n] I get
15:03:24 <metaperl> but the second guard I dont get
15:03:28 <vincenz> > [1..5] >>= flip enumFromTo 5
15:03:29 <lambdabot> [1,2,3,4,5,2,3,4,5,3,4,5,4,5,5]
15:03:39 <vincenz> > let rep n = [1..n] >>= flip enumFromTo n in rep 3
15:03:40 <lambdabot> [1,2,3,2,3,3]
15:03:46 <mauke> for my $n' (1 .. $n) { for (1 .. $n') { yield $n' } }
15:03:57 <vincenz> ah that one
15:04:02 <vincenz> > let rep n = [1..n] >>= join replicate in rep 3
15:04:03 <lambdabot> [1,2,2,3,3,3]
15:04:14 <metaperl> vincenz: are you going to explain it to me?
15:04:18 <vincenz> yes
15:04:22 <vincenz> I replicate x x times
15:04:28 <vincenz> so I replicate 1 1 time
15:04:30 <vincenz> 2 2 times
15:04:32 <vincenz> 3 rimtes
15:04:37 <vincenz> join replicate n = replicate n n
15:04:38 <metaperl> oh no not that
15:04:40 <metaperl> this: ] /vincenz/ > let rep n = [1..n] >>= join replicate in rep 3
15:04:46 <metaperl> no not that, sorry
15:04:47 <vincenz> that's what I just said
15:04:52 <goron> lol
15:04:53 <metaperl> let rep n = [ n' | n' <- [1..n], _ <- [1..n'] ] in rep 3
15:04:55 <metaperl> that
15:05:05 <vincenz> metaperl: mauke explained it
15:05:08 <mauke> ok, let's rewrite it in perl
15:05:27 <metaperl> I think I get it
15:05:36 <mauke> map { my $m = shift; map { $m } 1 .. $m } 1 .. $n
15:05:37 * vincenz smacks mauke for introducing perl
15:05:53 <vincenz> mauke use this: > let rep n = [1..n] >>= join replicate in rep 3
15:05:57 <mauke> of course in perl you'd write ($m) x $m instead of map $m, 1 ., $m
15:05:59 <metaperl> ah, that is really beautiful lispy
15:06:17 <vincenz> or
15:06:38 <vincenz> > let rep n = join [[1..n'] | n' <- [1..n]] in rep 3
15:06:39 <lambdabot> [1,1,2,1,2,3]
15:06:47 <vincenz> ooh
15:06:51 <xerox> o_O
15:07:00 <vincenz> xerox: join = concat
15:07:02 <vincenz> for lists
15:07:16 <xerox> I really know that.
15:07:20 <vincenz> ?
15:07:26 <vincenz> so why the o_O
15:07:34 <xerox> What are you aiming at?
15:07:38 <vincenz> > let rep n = join [replicate n' | n' <- [1..n]] in rep 3
15:07:39 <lambdabot> Couldn't match `[a]' against `t -> t1'
15:07:44 <vincenz> > let rep n = join [replicate n' n' | n' <- [1..n]] in rep 3
15:07:45 <lambdabot> [1,2,2,3,3,3]
15:07:54 <vincenz> > let rep n = join [join replicate n' | n' <- [1..n]] in rep 3
15:07:55 <lambdabot> [1,2,2,3,3,3]
15:08:02 <vincenz> xerox: I'm golfing
15:08:08 <vincenz> btw
15:08:11 <vincenz> if anyone wants it
15:08:16 <vincenz> I have a list permutator
15:08:22 <vincenz> O(n^2)
15:08:30 <mauke> map ($_) x $_, 1 .. $n
15:08:34 <mauke> hah, trivial
15:08:47 <mauke> (that's a perl rewrite of [1..n] >>= join replicate)
15:09:01 <vincenz> http://oasis.yi.org:8080/repos/haskell/RandomPerm.hs
15:09:02 <xerox> Nice :-)
15:09:22 <goron> Why do we use Haskell again when we can have Perl?
15:09:26 <vincenz> and they should put removeAt in Data.List
15:09:31 <vincenz> goron: static typing
15:11:06 <goron> I was not being serious. Still, it's nice that you can do that in Perl. 
15:11:32 <vincenz> well if you want dynamic typing
15:11:35 <vincenz> at least take a sane lang
15:11:37 <vincenz> like python or ruby
15:12:05 <goron> vincenz: Why didn't you implement it in an array?
15:12:18 <goron> vincenz: This really should run in O(n)
15:12:52 <vincenz> I dunno
15:12:56 <vincenz> cause I wanted a random list
15:13:33 <goron> vincenz: and you wanted to have one really slow :)
15:13:42 * vincenz shrugs
15:14:08 <vincenz> I have never used *Array
15:14:20 <vincenz> either way
15:14:26 <vincenz> that performance is really
15:14:30 <vincenz> O(n^2/2)
15:14:36 <vincenz> cause it's triangular
15:14:53 <newsham> O(n^2/2) == O(n^2)
15:14:56 <goron> vincenz: that is O(n^2), by definition of O
15:14:57 <vincenz> yeah eah
15:14:58 <vincenz> I know
15:15:03 <vincenz> let's not get started on O
15:15:10 <vincenz> or I can rant about it for half an hour
15:15:11 <goron> Why not, it's fun :)
15:15:16 <vincenz> cause the O-notation is useless
15:15:40 <Korollary> eh
15:15:43 <goron> Well, what do you suggest P(n)?
15:15:47 <newsham> *hits vincenz with a big logn)
15:15:48 <goron> For P of Practical
15:15:52 <vincenz> I am being serious
15:15:58 <vincenz> O notation is one of the worst
15:16:11 <vincenz> it's not even ordered
15:16:20 <goron> I know, but I am sure you can find for every thing you come up with something that's retarded about it.
15:16:22 <newsham> "is useless" seems to be an exageration
15:16:27 <goron> Just with O
15:16:29 <vincenz> listen
15:16:34 <newsham> not lsitening!
15:16:40 <vincenz> I have to work on algorithm transformations
15:16:43 <vincenz> and guestimate the payoff
15:16:46 <vincenz> I mean ballpark
15:16:50 <vincenz> x is better than y
15:16:55 <vincenz> the O notation is totally useless
15:17:03 <vincenz> cause as soon as you have more than one N
15:17:08 <vincenz> it becomes uncomparable
15:17:09 <vincenz> add to that
15:17:16 <goron> vincenz: Uhm, when is an algorithm better than another?
15:17:19 <vincenz> that O(n^2) might much faster in practive than O(nlogn)
15:17:23 <goron> vincenz: that's arbitrary. 
15:17:29 <vincenz> goron: lower computation and better energy-efficiency
15:17:35 <vincenz> well it's a pareto curve
15:17:41 <Korollary> you realize that the O notation is for large n?
15:17:43 <goron> vincenz: indeed
15:17:44 <sethk> goron, that's off topic
15:17:52 <vincenz> Korollary: which makes it useless for all practical purposes
15:17:58 <sethk> goron, that's irrelevant to the characteristics of 0 notation
15:17:58 <Korollary> vincenz: not true
15:17:59 <goron> sethk: ?
15:18:04 <vincenz> Korollary: and even for large n's
15:18:13 <vincenz> it doesn't give any comparative knowledge between two algos
15:18:21 <sethk> goron, the question of what makes an algorithm better than another is not related to the problems with the o notation
15:18:36 <sethk> goron, the problem with the o notation is, given the fact that we want to compare running times, the o notation has problems
15:18:41 <goron> sethk: vincenz came with the notion of being "better".
15:18:43 * vincenz nods at sethk 
15:18:51 <sethk> whether or not running times is the correct thing to compare is a separate question altogether
15:18:52 <vincenz> goron: comparative analysis
15:19:04 <vincenz> goron: be it accesses, runtime or minibits
15:19:39 <goron> vincenz: well, for those purposes you need to come up with your own definitions.
15:19:44 <vincenz> and yes, better is arbitrary
15:19:48 <goron> vincenz: your goals are obviously different.
15:19:49 <vincenz> but you can define a pareto curve or sufracee
15:19:54 <vincenz> and in that case
15:19:56 <vincenz> better is absolute
15:20:00 <vincenz> it either lies on that surface
15:20:01 <vincenz> or does not
15:20:02 <goron> vincenz: true
15:20:19 <vincenz> which is unpossible to do with O notation
15:21:04 <goron> vincenz: There are a lot of curves one can draw. 
15:21:08 <vincenz> I mean you have three classes
15:21:11 <vincenz> realisticall
15:21:14 <vincenz> errm 4
15:21:15 <lisppaste2> jlhamilton pasted "series problem" at http://paste.lisp.org/display/19297
15:21:21 <vincenz> N, log N, N log N, n^2
15:21:26 <vincenz> they fall in the same class: uncomparable
15:21:35 <vincenz> they fall in different class: uncomparable due to factors
15:21:39 <vincenz> you have more than one N, uncomparable
15:21:42 <goron> vincenz: which one should be analysed?
15:22:22 <vincenz> ?
15:22:31 <xerox> jlhamilton: what's the problem?
15:22:42 <goron> vincenz: You can analyze by energy used, or by time used. 
15:23:01 <vincenz> goron: I'mtelling you
15:23:03 <vincenz> pareto curve
15:23:08 <vincenz> make an access for each metric
15:23:22 <vincenz> erm
15:23:22 <vincenz> axis
15:23:50 <Korollary> jlhamilton: "1 : (zipWith something)" ?
15:24:05 <MarcWeber> When I want to fill a datatype (eg  data a=Record Word8 Word8 Word16 Int32) from a file do I use readFile and some reader classes?
15:24:08 <vincenz> why is he dropping 2
15:24:13 <vincenz> when he has 3 elements
15:24:15 <vincenz> 1, 2, 4
15:24:18 <jlhamilton> xerox: i think newham wanted to generate the sequence http://www.research.att.com/~njas/sequences/A005228 but i guess he left
15:24:20 <vincenz> and wat does complement' do
15:24:28 <xerox> jlhamilton: ah, I see :-/
15:24:53 <vincenz> what is that sequence?
15:24:53 <Korollary> ah I get it
15:25:17 <vincenz> oh
15:25:21 <vincenz> you basically add n+1
15:25:25 <vincenz> unless n+1 is in the series
15:25:28 <goron> vincenz: yes, you can analyze for different metrics, but the theoretical algorithm designers don't care for those. 
15:25:46 <goron> vincenz: so, in your domain it makes sense to define it. 
15:26:02 <vincenz> goron: right which seriously reduces the use of O
15:26:12 <vincenz> to me it's almost reduced to 'completely useless'
15:26:15 <goron> vincenz: for you, yes
15:26:24 <goron> vincenz: for me it's very useful. 
15:26:31 <vincenz> how's that
15:26:40 <vincenz> if you have more than one datastructure in your code
15:26:42 <vincenz> with M and N
15:26:45 <vincenz> it's uncomparable
15:26:50 <vincenz> if both algos are the same class
15:26:51 <vincenz> it's uncomparable
15:27:05 <vincenz> and in many cases, even different classes have no reflection on actual difference
15:27:24 <goron> vincenz: Theoretically you could run them in parallel, and you would never be of more than a factor of 2. 
15:27:25 <Korollary> vincenz: What are you talking about? How did you define the abstract machine that runs these algorithms?
15:27:49 <vincenz> Korollary: the abstract machien worldview is in all honest a big piece of bullshit if you want to compare performances or whatever it is you're trying to do with O
15:28:02 <Korollary> tone it down please
15:28:03 <vincenz> 1 access to main memory = 1000 accesses to local memory
15:28:05 <goron> vincenz: it's pretty much a non-issue. 
15:28:11 <vincenz> so please
15:28:15 <vincenz> if you want to be a pure cs er
15:28:27 <vincenz> don't use the O notation cause at that moment it's useless
15:28:31 <goron> vincenz: for databases the analysis is different, sure. 
15:29:01 <vincenz> at the stage of abstract machine, performance is completely unpredictable, so why stic ka measure on it
15:29:16 <Korollary> unpredictable?
15:29:18 <vincenz> yes
15:29:22 <Korollary> says who?
15:29:26 <vincenz> an abstract machine has NO correlation to realtity
15:29:27 <ForgeAus> hey all :)
15:29:37 <vincenz> not even close
15:30:01 <sethk> vincenz, well, though, what's required is that something that takes longer on the abstract machine also takes longer on the real machine
15:30:11 <goron> In theory O notation is completely useles, in practice it's not. 
15:30:12 <vincenz> sethk: but this ordering is completely untrue
15:30:17 <vincenz> goron: other way around
15:30:20 <goron> vincenz: nope
15:30:21 <sethk> vincenz, yes, it can be, I know
15:30:27 <vincenz> sethk: it's not 'it can be'
15:30:31 <vincenz> sethk: it's 'it usually is'
15:30:50 <sethk> vincenz, there you get into the whole issue of predicting cache hits
15:30:56 <goron> vincenz: In theory an algorithm which runs in O(n) can take O(10^100000 n) steps
15:30:58 <sethk> vincenz, which is not a simple one
15:31:07 <Korollary> If you don't know the penalty associated with cache misses, pipeline stalls, etc. it's "your" problem.
15:31:09 <vincenz> sethk: yea
15:31:16 <vincenz> sethk: my point is simple, the O notation is too simplistic
15:31:27 <shapr> I haven't found anything better.
15:31:30 <vincenz> Korollary: and the O notation has no formalism for this
15:31:38 <vincenz> Korollary: so even if you did know, the O notation won't help you
15:31:46 <vincenz> nor does it have any formalism
15:31:47 <vincenz> to compare
15:31:53 <vincenz> A^2 + B log B vs
15:31:58 <vincenz> A log A + B^2
15:32:04 <vincenz> O(A^2 + B log B vs)
15:32:09 <vincenz> O(A log A + B^2)
15:32:09 <Korollary> vincenz: Yes it does. You need to be able to describe your machine better. For some reason you can't, and you're taking it to a theory that has been tremendously useful and meaningful.
15:32:41 <vincenz> Korollary: Personal attacks aren't going to help you win an argument
15:32:56 <shapr> C'mon, chill out guys.
15:32:57 <Korollary> Did I attack you?
15:33:00 <goron> vincenz: for data base algorithms the analysis also takes into account the number of disk accesses. 
15:33:07 <vincenz> "For some reason you can't"
15:33:12 <sethk> vincenz, I don't see a personal attack there
15:33:23 <goron> vincenz: Still in O notation, but I don't see a problem with that.
15:33:26 <sethk> vincenz, I don't believe it was intended in that way, so don't take it that way
15:33:32 <vincenz> the O notation does away with all constants
15:33:38 <shapr> It doesn't always.
15:33:44 <vincenz> which play a big matter in real systems, cause the constant of a cache access != the constant of a main mem access
15:33:44 <goron> vincenz: and most of the time they are small. 
15:34:00 <goron> vincenz: implementors know the constants.
15:34:26 <dcoutts> vincenz, I guess you're saying that the cache misses are very big constants and it's a bit unreasonable to strip them out with the O
15:34:29 <sethk> goron, I would say that, in my experience in the real world, implementers not only don't know the constants, they don't even know about the constants
15:34:38 <Korollary> vincenz: You obviously can't or don't want to, otherwise you wouldnt have a problem.
15:34:41 <vincenz> dcoutts: I'm saying that many factors are being stripped out of the O notation for sakes of abstraction
15:34:48 <dcoutts> vincenz, yeah, sure
15:34:51 <vincenz> too many
15:35:10 <dcoutts> it's a particular level of complexity of analysis
15:35:11 <goron> sethk: Ok, well, then I thought to high of the implementors.
15:35:28 <goron> er too
15:35:31 <wchogg> I thought the whole point of O notation was just be a rough rule of thumb for obvious cases.  Y'know, to show students that bubble sort is worse than quicksort.
15:35:34 <sethk> the fact that an On doesn't necessary run faster than, say, an O n^2 is a well known problem
15:35:46 <vincenz> dcoutts: all I'm claiming is that because it abstracts away too much, there is no clear correlation at all with reality and this severely restricts the use
15:35:50 <sethk> wchogg, what vincenz is saying is that the conclusion may be incorrect
15:35:54 <dcoutts> and it's useful in many cases, as you say in other circumastances it might be better to take as your unit page reads or something
15:35:55 <goron> wchogg: well, not only students use it :)
15:35:58 <sethk> wchogg, that you may get the wrong answer
15:35:59 <vincenz> you may say in O X > Y
15:36:03 <vincenz> but often this will not translate to reality
15:36:10 <vincenz> and often X and Y are not comparable
15:36:11 <shapr> Yeah, but it's a rough simulation.
15:36:24 <dcoutts> vincenz, eg in a DB algo you would probably only count disk reads and not cpu time
15:36:29 <vincenz> shapr: rough simulation implies correlation
15:36:41 <vincenz> dcoutts: right, but I don't care which metric you specify
15:36:51 <vincenz> dcoutts: you have X metrics for all I care and have a pareto curve in X dimensions
15:36:54 <shapr> Yeah, but Big O constants aren't the same as incomparables.
15:37:05 <dcoutts> or in a data structure analysis it might be best to count memory reads & writes
15:37:28 <vincenz> dcoutts: right but because O discards constants
15:37:35 <shapr> It doesn't have to... 
15:37:37 <vincenz> dcoutts: all you can say is N, log N, N^2 or N log 
15:38:03 <dcoutts> vincenz, but if you're picking say memory reads, then N^2 memory reads is a meaningful thing
15:38:04 <shapr> If you want to, you can include all the details, including constants. It's just that most people don't.
15:38:05 <vincenz> dcoutts: now wat if your data structure is defined in terms of two types of data 
15:38:06 <wchogg> sethk:  Oh I know.  I just meant that it's supposed to be a rough guess in the first place.  The *dependence* is on the *order* of some function of n.  So I'm not sure if the fact that it's not so accurate is a surprise.
15:38:08 <vincenz> dcoutts: M an N
15:38:11 <goron> vincenz: what about n* log * n?
15:38:17 <vincenz> goron: that's what I meant by N log
15:38:20 <vincenz> typed ENTER too soon
15:38:39 <vincenz> dcoutts: what si better:  M^2 + N LOG N or M log N or M^@?
15:38:40 <goron> vincenz: No, I meant a special function with * being star.
15:38:41 <vincenz> dcoutts: what si better:  M^2 + N LOG N or M log N or M^2?
15:38:44 <sethk> wchogg, no, it isn't a surprise, and I would say to vincenz that, the fact that the theory may be misused doesn't imply that the theory is always useless
15:39:05 <sethk> with _any_ model, you _must_ specify the bounds of its applicability
15:39:07 <shapr> Personally, I wish the constants were included more often, but I do understand why they aren't and I do think Big O notation even without constants is useful.
15:39:12 <Korollary> wchogg: We assume that the translated program's behavior is similar. This is a computer "engineering" problem once you cross that line. That doesn't disallow formal tools, tho.
15:39:24 <vincenz> sethk: I'm saying the theory is rahter limited and in those cases where it is useful (read abstract cs) it becomes useless because at that point any algo you have has no monotonic correlation to reality
15:39:35 <dcoutts> vincenz, yeah, sure it can get complicated if you end up with many vars, but it's still useful if you know something about the relative sizes of M & N
15:39:47 <vincenz> dcoutts: right but this information is not state in the O model
15:39:52 <dcoutts> vincenz, true
15:39:53 <vincenz> dcoutts: now you're adding features onto an existing model
15:39:58 <dcoutts> sounds good
15:40:08 <wchogg> It sounds like the only disagreement here is a moral one about how much value a rule of thumb can be.
15:40:16 <shapr> I think so.
15:40:18 <dcoutts> yeah
15:40:30 <vincenz> wchogg: my issue is that many cs'rs throw around with the O notation like it were the 10 commandments
15:40:30 <shapr> My thumb has a very high value... at least the rest of my hand thinks os.
15:40:43 <dcoutts> heh
15:40:44 <sethk> vincenz, what's missing is an accurate interpretation of the O results.  But is that impossible?  Or is it simply that the step of mapping the model to reality is frequently left out?
15:40:47 <lispy> metaperl: you can often think of list comprehensions as a way to express (possibly) nested loops
15:41:05 <metaperl> hmm
15:41:13 <sethk> vincenz, well, there you are correct, without the mapping of the model to some real coordinate system, it can be misleading
15:41:22 <goron> vincenz: lol
15:41:42 <vincenz> sethk: I mean just go to any prog language channel and say O(n^2/2)
15:41:50 <vincenz> and they'll shoot you downw for using constants
15:41:56 <shapr> Not here :-)
15:42:02 <goron> "Fire at will"
15:42:03 * vincenz cougs
15:42:04 <vincenz> shapr: read up
15:42:09 <sethk> vincenz, I can't be worried about that
15:42:18 <vincenz> shapr: that's what started my rather poignant position ;)
15:42:26 <wchogg> vincenz:  Sure, I understand.  I just am not sure if anyone here is really treating O notation religiously.
15:42:29 <Korollary> That's just improper notation. It can still be more accurate.
15:42:35 <vincenz> sethk: anyways I was trying to figure out a way to do comparative analysis...
15:42:43 <goron> vincenz: nobody cares about that, we were just correcting you.
15:42:46 <vincenz> sethk: for the case where you have multiple data structures
15:43:06 <vincenz> sethk: and I found the model really lacking, even though the modelling and reasoning was done at a rather high and abstract level
15:43:20 <sethk> vincenz, I'm not a strong as others here, probably, at modeling.  My training was in hardware engineering before software existing.
15:43:26 <sethk> s/existing/existed/
15:43:28 <vincenz> sethk: same here
15:43:30 <vincenz> sethk: EE by formation
15:43:45 <lispy> Korollary: i don't know that's it's improper notation.  Isn't it the cas that O(n^2) = O(n^2/2) ?
15:44:04 <sethk> vincenz, and I do scratch my head at what sometimes passes for engineering in software, but I don't think that applies to this channel.  In fact it is one of the reasons I like this channel
15:44:18 <vincenz> lispy: yes, you have REALLY large equivalence classes which are supposed to be ordered but this ordering is not monotonically mapped to reality
15:44:26 <toast> @where
15:44:27 <lambdabot>  @where <key>, return element associated with key
15:44:40 <shapr> @here!
15:44:41 <lambdabot> Maybe you meant: where where+
15:44:50 <vincenz> sethk: Oh I love this channel too
15:44:58 <toste> @where paste
15:44:59 <lambdabot> http://paste.lisp.org/new/haskell
15:45:02 <vincenz> sethk: just ask shapr, I became a resident here months before I knew haskell
15:45:15 <goron> vincenz: your point is that it's possible that O(n) < O(log n) in practice?
15:45:23 <vincenz> goron: yes
15:45:29 <vincenz> goron: or the fact that you have only one constant 
15:45:29 <vincenz> N
15:45:31 <vincenz> not multiple
15:45:34 <vincenz> or the fact that
15:45:38 <shapr> It's also entirely possible that vincenz got started with FP because I whined at him on the Original Wiki.
15:45:38 <vincenz> O(2N) == O(N)
15:45:45 <vincenz> shapr: could be very true
15:45:47 <Korollary> lispy: Saying f is O(2n) doesn't actually mean that f's running time is close to 2n. So it doesn't 'technically' tell you more.
15:45:51 <vincenz> shapr: except I started with scheme, then ocaml
15:45:58 <shapr> Yeah, I remember.
15:45:58 <goron> vincenz: uhm, well, that's why they teach you that in the first class about Big Oh notation.
15:46:10 <lisppaste2> toste pasted "code" at http://paste.lisp.org/display/19299
15:46:18 <shapr> I never took a CS class!
15:46:22 <goron> vincenz: I know algorithms which only perform better for sizes >10^9 or something like that in practice.
15:46:30 * vincenz never took a CS class either, besides compiler construction
15:46:36 <xerox> shapr: even Sussman ones? (-;
15:46:43 <vincenz> xerox: I have those on my ipod :D
15:46:49 <toste> thats why u think haskell is good ;p
15:46:52 <goron> vincenz: those algorithms are almost never used.
15:47:33 <goron> vincenz: that's why efficient sorting algorithms also use algorithms with lower constants but bad O complexity for small inputs.
15:47:38 <lispy> Korollary: okay, i agree there.  improper notation is not the way i would describe that...i'd maybe say...misleading notation?
15:47:50 <vincenz> goron: you're hardly arguing against me
15:48:08 <shapr> I do like to see the constants involved in a Big O measurement, mostly because I really 'got' Big O from Rabhi & Lapalme's 'Algorithms : A Functional Programming Approach' book.
15:48:16 <goron> vincenz: I argue that O notation is very useful to some people.,
15:48:47 <Korollary> lispy: It's not misleading. It's still correct.
15:48:51 <goron> vincenz: why do you care about constants anyway? Constants only matter in game development, I guess.
15:48:51 * vincenz still has to read his new "Introduction to Algoriths" by Cormen et al
15:48:59 <vincenz> goron:  no they don't
15:49:04 <Korollary> constants do matter
15:49:07 <vincenz> take N^2 and N log N
15:49:10 <vincenz> add in two constants
15:49:11 <sethk> goron, only in game development?  where did that come from?
15:49:17 <vincenz> A * N^2 and B* N log N
15:49:18 <goron> vincenz: and some scientific applications.
15:49:20 <vincenz> depending on your constant
15:49:25 <vincenz> you'll have a different threshold for N
15:49:28 <vincenz> goron: not really
15:49:39 <vincenz> goron: 90% of software is in embedded systems
15:49:59 <vincenz> where there are footprint, energy and performance constraints
15:50:15 <vincenz> and I'm not talking small stuff like what you put in a carwindow
15:50:22 <goron> vincenz: But embedded stuff gets better hardware all the time.
15:50:32 <vincenz> goron: so you want to wait for 5 years
15:50:34 <sethk> goron, there you argue against yourself
15:50:36 <vincenz> and run MPEG 2 in 2010
15:50:41 <vincenz> instead of mapping it now?
15:50:52 <sethk> goron, it is the better hardware with larger caches where the accuracy becomes lower
15:51:14 <toste> so hummm nyone looked at my paste ? :p
15:51:25 <vincenz> sethk: seen the pentium cpu/
15:51:29 <vincenz> sethk: 26MB L3
15:51:35 <vincenz> first time I see L3 mentioned
15:51:40 <vincenz> erm
15:51:42 <vincenz> intel cpu
15:51:43 <vincenz> not pentium
15:52:02 <goron> vincenz: ok, so it matters for those systems too. But I think CS people don't need to spell out everything for engineers. 
15:52:13 <toste> <lisppaste2> toste pasted "code" at http://paste.lisp.org/display/19299
15:52:17 <vincenz> goron: then why make a model to model performance
15:52:27 <goron> vincenz: it's not a model for performance.
15:52:31 <vincenz> ...
15:52:37 <goron> vincenz: it's about the complexity of the problem.
15:52:39 <vincenz> I dn't mean cpu performance
15:52:41 <vincenz> fine complexity
15:52:49 <vincenz> same diff
15:52:50 <vincenz> cost
15:52:53 <vincenz> for some definition of cost
15:53:25 <goron> vincenz: uhm, well, you do want to have an idea of how long it will take on a real computer. 
15:53:34 <vincenz> argh
15:53:36 <goron> vincenz: if you have tons of cache misses, the model still works.
15:53:40 <sethk> toste, it is saying that the second argument of the Action constructor is not a type that can be represented as (x:xs)
15:53:40 <vincenz> goron: O notation even without cache
15:53:51 <vincenz> has no homomorphic mapping to real cost
15:54:35 <vincenz> and besides that
15:54:36 <goron> vincenz: what does not work out then?
15:54:45 <vincenz> basically reduces all complexities to four equivalence classes
15:54:47 <dechunker> If you guys are arguing about "Big O notation is useful for helping people think about X," then you're talking about psychology.  You could argue either way for different people.
15:55:01 <vincenz> anyways
15:55:03 <vincenz> it's too late
15:55:05 <vincenz> I should go sleep
15:55:07 <vincenz> gotta work tomorrow
15:55:25 <dechunker> Maybe my brain is structured in such a way that Big O notation actually informs me not at all.  And maybe the opposite is true for someone else.
15:56:35 <toste> hum i made it work
15:56:43 <sethk> toste, good
15:56:50 <goron> I have analyzed constants for some problems, but man did that bore me. I guess that's why we don't do it :-)
15:57:06 <toste> read (show x)
15:57:16 <toste> wich made it the right type
15:57:38 <sethk> toste, you probably needed fromIntegral
15:57:52 <toste> nah, its a DATA 
15:58:00 <shapr> Me too, must sleep!
15:58:05 <toste> nite ;p
15:58:15 <sethk> toste, ordinarily show and read would cancel out
15:58:33 <Korollary> read (show x) is doing a conversion for you. You can do it directly
15:59:58 <toste> hum your right
16:01:34 <toste> it works for the first item, but the its boggus
16:02:20 <toste> then*
16:03:05 <palomer> > catMaybes [Just 3, Just 4, Nothing]
16:03:07 <lambdabot> [3,4]
16:06:47 <toste> hum, my xs is read as a [a], but its a [ATTRIBUT]
16:06:50 <toste> thats the problem
16:07:00 <toste> or the other way around
16:08:16 <vincenz> > join [Just 3, Just 4, Nothing]
16:08:17 <lambdabot> Couldn't match `[a]' against `Maybe a1'
16:11:37 <jlhamilton> here is a more efficient way to generate that sequence http://paste.lisp.org/display/19302
16:21:08 <gadolin> what should i import to get EQ, GT,LT constructors ?
16:22:07 <sjanssen_> gadolin: they should be in the Prelude (implicitly imported)
16:27:22 <toste> @where paste
16:27:22 <lambdabot> http://paste.lisp.org/new/haskell
16:27:41 <lisppaste2> toste pasted "code" at http://paste.lisp.org/display/19303
16:28:07 <toste> *** Type           : ATTRIBUT
16:28:07 <toste> *** Does not match : [a]      
16:28:12 <gadolin> yeap, i have silly error
16:28:29 <toste> Eq
16:36:35 <sethk> toste, it would be easier if you pasted the error messages with the code and had line numbers
16:38:44 <toste> i fixed it for good now :)
16:39:26 <toste> in a list, how can i test if the value of the field match the a param ?
16:39:52 <sethk> toste, I'm not sure what you are asking
16:40:09 <toste> i.e. [int, float, string, char] i fallow the list and at the right value, i test x== (:t xs)
16:40:48 <toste> because, when i input the rong value in this problem i get : Program error: Prelude.read: no parse   
16:40:59 <Korollary> a list can contain only one type of values.
16:41:39 <sethk> toste, to get the behavior you want, you'll need a type like:    data X = Xfloat | Xint | Xstring ...
16:41:50 <sethk> toste, if I understand what you are trying to do, which I may or may not
16:42:08 <toste> yeah, thats exactly the case
16:42:48 <toste> Data ATTRIBUT = ... and my "list" is [ATTRIBUT]
16:44:21 <sethk> toste, when you get the "no parse" error, you've tried to interpret a value as a type, and the value is not of that type.
16:44:51 <sethk> toste, using my X example, you have to parse all the values into a value of type X
16:45:08 <sethk> toste, by making a data statement that way, you can make a type for which all the values are possible
16:45:34 <sethk> toste, but, again, I'm not sure if I'm thinking about the same thing you are thinking about
16:46:36 <toste> am looking for a condition like this : { if (isJust(find((==att).typeAttribut) l) && (:t find((==att).valeurAttribut) l == :t val) }
16:47:31 <sjanssen_> toste: you're trying to compare types of values?
16:47:36 <toste> yes
16:47:38 <sethk> toste, all the values on a list are of the same type.  You can distinguish one value from another based on their type
16:47:43 <sethk> s/can/cannot/
16:47:51 <sjanssen_> toste: :t isn't actually Haskell, it's just a little convenience you can use in GHCi
16:48:07 <toste> k lol
16:48:41 <toste> bah well, i guess i won't loose much points on this error
16:52:16 <toste>  maybe 999.99 id (fmap read (valeurAttribut "Changement" a) :: Maybe Float) >= 2.0
16:52:28 <toste> i don't get the sens of this line of code ;/
16:53:55 <sjanssen_> @type maybe
16:53:55 <sethk> toste, where did it come from?  It isn't your code?
16:53:56 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:54:04 <toste> nah :p
16:54:20 <palomer> -10 points for flagrant use of french
16:54:58 <toste> ^O
16:55:20 <toste> well, it test if (a >= 2.0)
16:55:31 <toste> but what does maybe 999.99 have to do in this ?
16:56:15 <monochrom> take a look at what "maybe" does
16:57:09 <palomer> @hoogle maybe
16:57:10 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
16:57:10 <lambdabot> Maybe :: module
16:57:10 <lambdabot> Prelude.Maybe :: data Maybe a
16:57:50 <toste> yeah i know what it does, if its valid return Just(..) if not, Nothing
16:58:02 <sjanssen_> toste: that is not what it does
16:58:42 <toste> http://www.zvon.org/other/haskell/Outputprelude/Maybe_d.html
16:58:43 <toste> :/
16:58:47 <palomer> :\
16:59:21 <monochrom> You are so case-insensitive like COBOL.
16:59:26 <sjanssen_> it takes a Maybe, if that Maybe contains Nothing, then return a default value (this is the first argument).  otherwise, use the given function to transform the value that the Maybe contains and return that
17:00:10 <toste> http://www.zvon.org/other/haskell/Outputprelude/maybe_f.html
17:00:12 <toste> ^^
17:00:46 <sjanssen_> @type let maybe default f Nothing = default; maybe default f (Just value) = f value in maybe
17:00:47 <lambdabot> parse error on input `default'
17:01:14 <toste> @type let maybe 5 f Nothing = default; maybe default f (Just value) = f value in maybe
17:01:16 <lambdabot> parse error on input `default'
17:01:24 <toste> @type let maybe 5 f Nothing = default; maybe 5 f (Just value) = f value in maybe
17:01:26 <lambdabot> parse error on input `default'
17:01:31 <toste> grr
17:01:38 <toste> @type let maybe 5 f Nothing = 5; maybe 5 f (Just value) = f value in maybe
17:01:40 <lambdabot> forall t
17:01:40 <lambdabot>                            a
17:01:40 <lambdabot>                            t1.
17:01:40 <lambdabot>                         (Num t1, Num t) =>
17:01:40 <lambdabot>                         -> (a -> t1)
17:01:42 <lambdabot>                         -> Maybe a
17:01:44 <lambdabot>                         -> t1
17:01:51 <monochrom> > (maybe "hello" show (Nothing), maybe "hello" show (Just True))
17:01:52 <lambdabot> Add a type signature
17:02:01 <monochrom> > (maybe "hello" show (Nothing), maybe "hello" show (Just True)) :: (Bool,Bool)
17:02:02 <lambdabot> Couldn't match `Bool' against `[Char]'
17:02:17 <monochrom> > (maybe "hello" show (Nothing :: Maybe Boll), maybe "hello" show (Just True))
17:02:18 <lambdabot>  Not in scope: type constructor or class `Boll'
17:02:21 <monochrom> > (maybe "hello" show (Nothing :: Maybe Bool), maybe "hello" show (Just True))
17:02:23 <lambdabot> ("hello","True")
17:02:30 <sjanssen_> ah yes, I forgot that default is a reserved word
17:02:31 <monochrom> Sorry for the scrolling
17:02:31 <toste> thx :)
17:19:19 <skew> is there a simple monad for escape-only continuations/setjmp+longjmp?
17:20:20 <SamB> escape-only?
17:20:24 <SamB> is that like C--?
17:21:57 <skew> like setjmp+longjump, or tagbody in lisp, or exceptions
17:22:35 <skew> the tricky part seems to be making it fail outside the dynamic extent
17:27:58 <RyanT5000> @where hssdl
17:27:59 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
17:28:19 <RyanT5000> @where darcs
17:28:20 <lambdabot> http://darcs.net/
17:37:31 <araujo> Hi!
17:37:36 <xerox> Goodnight.
17:38:54 <dons> morning
17:45:47 <dons> so, what's new in the haskell world today peoples?
17:48:09 <dons> @seen joelr
17:48:10 <lambdabot> I haven't seen joelr.
17:49:12 <dons> amazing. joelr's come back to haskell. 
17:49:28 <dcoutts> dons, well today I've been grumbling about the cabal-1.1.4 version number and playing with the ghc 6.4.2 testsuite
17:49:35 <Korollary> you mean he has not
17:50:16 <dcoutts> dons, that and getting on with PhD work, how about you?
17:50:58 * dcoutts is applying advanced optimisation techniques to trivial functions with some success :-)
17:51:45 <dons> dcoutts: yeah, I saw you Cabal issue. I agree with you. multiple weird Cabal versions will be a problem till Cabal is sufficiently stable and widely distributed
17:51:56 <dcoutts> yeah
17:51:56 <dons> I imagine the GNU make people had similar issues 20 years ago
17:52:15 <lispy> dons: i never got the impression he wanted to leave...i thought he just couldn't shoe horn his notions of how to make a poker server into haskell
17:52:17 <dcoutts> but at least having distinct versions for releases would help
17:52:24 <dons> lispy: yeah. that's true.
17:52:25 <dcoutts> dons, lambdabot doesn't allow TH, presumably because of the IO hole, can't we just ban the IO -> Q function and make it safe.
17:52:34 <dons> hmm..
17:52:43 <dons> it also doesn't allow it because you can splcie inside @type
17:52:55 <dons> which TheHunter famously (imo) exploiter
17:52:57 <dons> d
17:53:00 <dcoutts> that's ok isn't it? so long as there is no IO 
17:53:07 <dons> thinking...
17:53:16 <dcoutts> I was trying to show off my generating extensions
17:53:39 <dons> I think you're right. That sounds like the right restriction. Now, how to enforce it?
17:53:46 <dcoutts> generating extension == output of my partial evaluator
17:53:56 <dcoutts> dons, import TH hiding (unsafeThing)
17:54:13 <dcoutts> dons, or add a new local module SafeTH which does the same
17:54:14 <musasabi> TH has many things for crashing GHC at least.
17:54:33 <dons> dcoutts: hmm. sorry. maybe I misunderstand.
17:54:40 <dons> where do you want the TH? in @eval ?
17:54:45 <dcoutts> dons, right
17:55:03 <dcoutts> in type too if it's possible, but that's less important
17:55:11 <dcoutts> type/@type
17:55:22 <dons> how does import TH (anything) restrict what fragments of TH code the user writes?
17:55:34 <dons>  @eval $( something evil in IO )
17:55:52 <dcoutts> dons, $(  ) take something in the Q monad, not the IO monad
17:56:13 <dcoutts> so if you stop the IO -> Q bit then everything else should be safe
17:56:24 <dcoutts> there's only one (?) func which does that
17:56:27 * dcoutts double checks
17:56:33 <dons> ah!
17:56:47 <dons> (it's been a while since I pondered TH safety issues, sorry)
17:56:57 <dcoutts> runIO :: forall a. IO a -> Q a
17:57:10 <dons> qRunIO , right.
17:57:31 <dons> and runIO.
17:57:57 <dons> hmm. can we think of any other possible issues?
17:58:21 * dcoutts studies TH module again
17:58:31 <dons> what about the dynamic scope trick?
17:58:53 <dons> the "swap" example in the TH paper that binds to whatever 'swap' is in scope.
17:59:03 <dons> hmm. but I guess type safety is still preserved
17:59:07 <dcoutts> dons, hmm good point
17:59:21 <dcoutts> dons, but it'd allow you to produce a splice of type IO
17:59:29 <dcoutts> but that should still be ok...
17:59:38 <dons> ah. yes. as long as there's no runIO
17:59:51 <dcoutts> since the only way to run that IO is to get it to the top level where it's banned
18:00:18 <dons> ok. i'll turn it on with *runIO hiddnen gimme a couple of minutes
18:00:31 <dcoutts> cool
18:00:38 * palomer is going to dump his supervisor on monday
18:00:49 <palomer> do you guys think flowers would help?
18:00:53 <dcoutts> dons, ask Igloo if he can think of any other security risks
18:01:00 <lispy> palomer: why are you dumping them?
18:01:03 <dons> Igloo, ping ?
18:01:09 <palomer> her
18:01:20 <palomer> because I'm very displeased with her
18:01:26 <dons> palomer: well, you've complained an awful lot about her. do you have someone new in mind?
18:01:35 <palomer> well, she only payed me
18:01:46 <palomer> technically I have an official supervisor
18:01:56 <palomer> so I'll stick with him, and I'll finish her project without her input
18:02:07 <palomer> which means that I won't be funded anymore
18:02:26 <lispy> ah, yeah that's what happened to me back in november
18:02:38 * lispy is doing an internship until funding appears
18:02:49 <palomer> you dumped your supervisor?
18:02:57 <lispy> yup, she was a pain in the ass
18:03:04 * palomer high fives lispy
18:03:04 <lispy> well advisor at my school
18:03:12 <palomer> mine is genuinely inept
18:03:24 <lispy> and then my girl friend dumped me last week...so the cycle of life continues...
18:03:32 <Korollary> ow
18:03:39 <palomer> I'm sure a dump truck is going to fall on her
18:03:47 <lispy> i hope not
18:03:50 <palomer> and then a homeless guy is going to take a dump in the truck
18:04:30 <palomer> and then humpty dumpty is going to trip the homeless guy
18:04:52 <palomer> that's where the cycle ends
18:05:01 * lispy wonders if, with the new advisor, @palomer will have to be updated
18:05:13 <palomer> I'll start saying nice, sweet things
18:05:21 <dcoutts> @palomer
18:05:22 <lambdabot> hrmph
18:05:30 <araujo> Hi!
18:05:33 * araujo sort of back
18:05:36 <dcoutts> hia araujo 
18:05:39 <dcoutts> @palomer
18:05:39 <dons> dcoutts, you think this is safe: Language.Haskell.TH hiding (runIO, qRunIO) )
18:05:39 <lambdabot> hrmph
18:05:41 * palomer is trying to figure out how to compile his c++ program on 4 different platforms
18:05:44 <araujo> dcoutts, hiya!
18:05:50 <dons> or is qRunIO going to get back in through the Quasi(..) class import
18:06:05 <dcoutts> dons, let me think..
18:06:23 <dons> I think I need to write a test file to check that.
18:07:10 <dons> ah, good: odule `Language.Haskell.TH' does not export `qRunIO'
18:07:23 <dons> would be kidn of insance for 'hidden' directives to be ignored like that.
18:07:27 <araujo> How things go over here?
18:07:32 * araujo been away lately
18:07:34 <dons> urgh. insane. 
18:07:48 <dons> morning araujo 
18:08:17 <araujo> hi hi dons 
18:08:20 <araujo> hah
18:08:37 <araujo> why's that?
18:08:51 <dcoutts> dons, right, so the Quasi class is not exported at all from the top level module
18:09:03 <dons> right.
18:09:27 <dons> but from *.Syntax.
18:09:29 <dcoutts> yes
18:09:32 <dons> but you only want the top level?
18:09:36 <dcoutts> right
18:09:39 <dons> ok.
18:16:49 <dons> $ echo '$([|1+2|])' | ./runplugs
18:16:49 <dons> 3
18:17:22 <dons> seems to work :)
18:17:29 <dons> i'll push the patch now.
18:22:13 * palomer is scared that the supervisor he'll dump will continue his research just to spite him
18:30:19 <dons> ?dynamic-reload where
18:30:20 <lambdabot> module reloaded
18:30:25 <dons> ?help url
18:30:25 <lambdabot> url <key>. Return element associated with key
18:30:41 <dons> > $( [| 1+ 2 |] )
18:30:42 <lambdabot> 3
18:30:48 <dons> dcoutts ^^
18:31:00 <dons> > $( [| putStrLn "foo" |] )
18:31:02 <lambdabot> No IO allowed
18:31:04 <dcoutts> cool!
18:31:06 <dons> good good.
18:32:29 <sethk> dons, I just caught the tail end of that.  what's that about?
18:32:49 <sethk> I forget what [| and |] do.  I'll look it up ....
18:32:59 <Korollary> Template haskell quasi quote
18:33:42 <sethk> Korollary, that's why I forgot, I only looked at TH for a short time
18:33:55 <sethk> Korollary, I decided it looked too much like c++ templates, which kind of scared me away  :)
18:34:01 <Korollary> no no
18:34:13 <sethk> Korollary, not the syntax, the paper describing it
18:34:13 <Korollary> They actually do look cool
18:34:36 <sethk> part of my macrophobia
18:35:16 <dons> yeah, I've just turned on the hopefully-safe bits of Template Haskell inside @eval
18:35:20 * Korollary blames c
18:36:51 <dons> hmm. do C programmers use cpp macros to manually inline pure computations?
18:37:14 <Pseudonym> They have been known to.
18:37:24 <Pseudonym> No self-respecting C9X or C++ programmer would.
18:37:26 <dons> I can't help but think so: http://www.cse.unsw.edu.au/~dons/tmp/tester.c
18:37:42 <Pseudonym> or GCC-onlyist, I guess.
18:38:26 <dons> and people say that optimised haskell looks ugly. huh!
18:38:45 <sethk> when a macro has four backslash continuation lines ...
18:39:03 <dcoutts> dons, one problem we have is that we can't get anything pure out of the Q monad :-(
18:39:06 <Korollary> That macro is a manual attempt at forcing the compiler to inline that function
18:39:22 <sethk> hmm, there's another one with 14
18:39:40 <dons> dcoutts: ah , right. othern than by splicing across stages.
18:39:42 <sethk> Korollary, it doesn't listen to the inline directive?
18:39:48 <dons> you want , umm, unsafeWhatsIt?
18:39:55 <Korollary> sethk: well, the inline directive is pretty new, right?
18:40:01 <dcoutts> dons, something like Q a -> a
18:40:04 <Pseudonym> unsafeExpandCStyleMacro
18:40:15 <sethk> Korollary, relatively, I guess, but not all that new
18:40:18 <dcoutts> dons, but it's only needed at the top level
18:40:39 <Korollary> Arent there cpp directives in GHC sources? Why isnt TH used instead?
18:40:42 <dcoutts> dons, or showQ :: Show a => Q a -> String
18:40:57 <dons> can't you insert that?
18:41:06 <dons> > showQ [| 1 + 2 |]
18:41:06 <lambdabot>  Not in scope: `showQ'
18:41:09 <dons> ahd
18:41:16 <dons> > show [| 1 + 2 |]
18:41:17 <lambdabot>  add an instance declaration for (Show ExpQ)
18:41:17 <lambdabot>   In the definition of `tfe': tfe = show [| 1 + 2 |]
18:41:17 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
18:41:50 <dons> is that what you want? a Show instance?
18:42:12 <dcoutts> dons, yeah, or equiv
18:42:45 <dons> something from the Ppr lib?
18:43:20 <dcoutts> if we defined showQ :: Ppr a => Q a -> String
18:43:41 <dcoutts> dons, you see normally we'd say:
18:43:42 <dcoutts> printExpQ :: ExpQ -> IO ()
18:43:42 <dcoutts> printExpQ expQ = do exp <- runQ expQ
18:43:42 <dcoutts>                     print (pprExp 0 exp)
18:43:52 <dcoutts> but of course we can't do IO, so..
18:44:01 <dcoutts> we need a safe wrapper
18:44:31 <dons> which is ok. we can insert a safe wrapper for users of TH
18:45:01 <dons> i'll add a showQ now
18:45:23 <dcoutts> I think it may need unsafePerformIO to define...
18:45:55 <dons> sure. but as long as the arg is a ExpQ, should be safe. no?
18:46:03 <dcoutts> right
18:49:59 <dcoutts> > showExpQ $ let genex_power n = let genex_power' n x = if n == 0 then [| 1 |] else [| $x * $(genex_power' (n-1) x) |] in [| \x -> $(genex_power' n [| x |]) |] in genex_power 3
18:50:00 <lambdabot>  Not in scope: `showExpQ'
18:50:12 <dcoutts> dons, there's a test case
18:50:46 <dcoutts> should give: "\x_0 -> x_0 GHC.Num.* (x_0 GHC.Num.* (x_0 GHC.Num.* 1))"
18:51:12 <dons> showQ eQ = unsafePerformIO $ do e <- runQ eQ ; return (pprint e) ?
18:51:52 <dcoutts> looks ok
18:52:13 <dons> gives us "\\x_0 -> x_0 GHC.Num.* (x_0 GHC.Num.* (x_0 GHC.Num.* 1))"
18:52:28 <dcoutts> good
18:52:35 <dons> ok. i'll add it to runplugs
18:52:42 <dcoutts> cool :-)
18:54:12 <dons> and a Show instance will then handle the printing automagically
18:54:19 <dcoutts> a, nice
18:54:21 <Igloo> dons: It's only safe if you hide qIO (or whatever it's called)
18:54:37 <dcoutts> Igloo, runQ
18:54:58 <dons> Igloo: right. that's what we suspected.
18:55:00 <dcoutts> err runIO
18:55:09 <dcoutts> runQ is to convert back to IO
18:55:34 <dons> and qRunIO
18:56:08 <RyanT5000> is there a way to change the gcc that ghc uses?
18:56:23 <RyanT5000> it's failing with -cpp because it's using the wrong one
18:56:32 <Igloo> Hmm, I wonder if you can cirumvent the protection by reifying things and splicing a name you find in
18:56:46 <dcoutts> Igloo, yeah, we were wondering that
18:56:50 <dons> hmm. building your own name?
18:57:03 <Igloo> Building your own name won't work as it won't be in scope still
18:57:14 <dons> right. so it still depends on what's in scope, no? 
18:57:21 <Igloo> Is qRunIO/runIO used in a class anywhere?
18:57:24 <dons> and you can't generate module imports here. jsut an expr.
18:57:33 <Igloo> Not if you get the name from the compiler
18:57:35 <dons> huh. hmm
18:57:53 <lispy> RyanT5000: -pgcm iirc
18:58:27 <lispy> RyanT5000: oh actually -pgmc makes more sense
18:58:47 <lispy> because it think it's short for program C
18:58:55 <Igloo> Oh, you can reify the IO type and get the IO constructor etc I suspect
18:58:55 <RyanT5000> ah
18:59:15 <RyanT5000> thanks :)
18:59:19 <Igloo> Or is the IO type not in scope either?
18:59:39 <dcoutts> Igloo, but does that allow us to run code we've constructed that has type IO ()
18:59:47 <Igloo> Ah, you can just hide reify, of course
18:59:55 <Igloo> dcoutts: What doesn't?
19:00:30 <dcoutts> so how would we exploit it?
19:00:37 <Igloo> Oh, right, you still need to get useful primitives
19:00:49 <dcoutts> $( generateNastyIOCode )
19:01:03 <dcoutts> generateNastyIOCode :: Exp (IO ())
19:01:10 <dons> hmm. stepping inside the IO constructor would be bad, since you coudl write unIO
19:01:10 <dcoutts> $( generateNastyIOCode ) :: IO ()
19:01:15 <dons> or your own unsafePerformIO
19:02:07 <Igloo> Oh, yes, the primitives are all in scope, it's just the result type you restrict
19:02:15 <dons> so, $( .. magic to write unsafePerformIO by hand ... $ print "x" )
19:02:40 <Igloo> I think you have to disallow reify
19:02:50 <dcoutts> and that'd have type ()
19:03:30 <dons> Igloo, but does that rule out [| |] ? or just 'reify'?
19:03:54 <Igloo> Just reify
19:03:55 <dcoutts> just reify I think
19:04:20 <dons> you'd just have to generate: $( (\(IO m) -> case m realWorld# of (# _, r #)   -> r) $ print "x" )
19:04:31 <dons> ok. i'll disable reify.
19:05:17 <RyanT5000> how about if you do something like $( [| $( changeNameToIO [| name |] ) |] )
19:05:24 <RyanT5000> could you end up with an equivalent of reify?
19:09:19 <lispy> heh, the lambda for template haskell rocks
19:09:55 * dcoutts goes to bed
19:11:21 <dons> almost finished ....
19:12:01 <dons> $ echo "[| 1 + 2 |]" | ./runplugs 
19:12:01 <dons> 1 GHC.Num.+ 2
19:12:23 <dons> $ echo "reify (1+2)" | ./runplugs
19:12:24 <dons> <irc>:1:0: Not in scope: `reify'
19:16:17 <dons> > [| 1 + 2 |]
19:16:18 <lambdabot> 1 GHC.Num.+ 2
19:17:30 <dons> let genex_power n = let genex_power' n x = if n == 0 then [| 1 |] else [| $x * $(genex_power' (n-1) x) |] in [| \x -> $(genex_power' n [| x |]) |] in genex_power 3
19:17:44 <dons> > let genex_power n = let genex_power' n x = if n == 0 then [| 1 |] else [| $x * $(genex_power' (n-1) x) |] in [| \x -> $(genex_power' n [| x |]) |] in genex_power 3
19:17:45 <lambdabot> \x_0 -> x_0 GHC.Num.* (x_0 GHC.Num.* (x_0 GHC.Num.* 1))
19:17:49 <dons> cool!
19:18:16 <dons> dcoutts: ^^
19:19:47 <lispy> oh, shiny
19:20:30 <dons> and we can only ponder how many holes in lambdabot we've just opened up... :}
19:20:59 <olliej> dons: what have you added?
19:21:45 <dons> the ability to splice and reify code inside TH. and the ability to show Q a data.
19:22:02 <dons> previously no TH was allowed in @eval since we considered it too unsafe.
19:22:11 <dons> hopefully this is safe. its' fairly restricted.
19:22:48 <dons> but it depends on what GHC allows you access to inside the compiler, which is hard to reason about :/
19:22:49 <lispy> @keal
19:22:49 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
19:24:22 <sjanssen_> @. elite ghc
19:24:23 <lambdabot> NO P4RaMe+er$ 4 C|4$z
19:28:01 <sethk> sytem?
19:28:33 <lispy> dons: from the sounds of it, it will take someone with a lot of haskell, TH and ghc knowledge.  Not many people like that are interested in 'hacking' lambdabot 
19:28:59 <lispy> dons: so even if it's exploitable, it's very likely completely safe :)
19:29:50 <sethk> lispy, the script kiddies aren't doing TH?
19:30:03 <sethk> how disappointing  :)
19:30:40 * lispy studies up to make the
19:30:46 <lispy> @elite lambdabot  root kit
19:30:47 <lambdabot> |am8d4bot roo+ kIt
19:31:27 <dons> lispy: I agree.
19:31:32 <RyanT5000> > Prelude Language.Haskell.TH> $( [| $( global $ mkName "System.IO.Unsafe.unsafePerformIO" ) |] ) (print "Hello")
19:31:33 <lambdabot>  Not in scope: data constructor `Language.Haskell.TH'
19:31:36 <RyanT5000> er
19:31:45 <RyanT5000> $( [| $( global $ mkName "System.IO.Unsafe.unsafePerformIO" ) |] ) (print "Hello")
19:31:51 <RyanT5000> > $( [| $( global $ mkName "System.IO.Unsafe.unsafePerformIO" ) |] ) (print "Hello")
19:31:52 <lambdabot>  Not in scope: `System.IO.Unsafe.unsafePerformIO'
19:31:58 <dons> not going to work.
19:32:01 <RyanT5000> right
19:32:04 <dons> it does in ghci, but @eval is different
19:32:10 <RyanT5000> yeah
19:32:13 <dons> it has to obey normal haskell import rules, thankfully
19:32:25 <RyanT5000> so what modules do i have to work with?
19:32:42 <RyanT5000> System.IO?
19:32:56 <dons> you can see them all in http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/RunPlugs.hs
19:33:10 <dons> nothing in System.
19:33:12 <SamB> are you sure there isn't another way to make a name that will be a problem?
19:33:15 <dons> except what comes in via the Prelude
19:33:23 <dons> SamB, no. I'm not sure.
19:33:42 <dons> but, what you can make should already be in scope.
19:33:45 <SamB> > [| Prelude.id |]
19:33:46 <lambdabot> GHC.Base.id
19:34:04 <dons> and what is in scope is supposed to be a trusted base
19:34:37 <dons> anyway, it'll be fun to see if there are holes.
19:34:51 * SamB waits for dons to leave before looking
19:34:52 <dons> karma points for anyone who successfully evaluates an IO action!
19:35:07 <dons> and you get a write up in the lambdabot src too :)
19:35:20 * SamB doesn't want to be written up :-(
19:35:41 <dons> "SamB famously found a hole using .... "
19:36:10 <dons> > 1#
19:36:11 <lambdabot>  parse error on input `}'
19:36:20 <dons> just checking that -fth didn't turn on anything else
19:38:29 <SamB> if I segfault it do I get points for that too?
19:38:34 <dons> yes.
19:39:01 <SamB> oh, but I could probably only do that at the top level
19:39:33 <SamB> well, with FFI anyway
19:39:52 <dons> no ffi allowed
19:40:05 <dons> its just H98 + TH.
19:40:10 <dons> that TH is a big deal though.
19:40:32 <sethk> dons, in the ClientServer class that we did, I'm finding that every time I call putRequest I immediately call getResponse.  I was thinking of combining them into one function, keeping the name putRequest(), but having that function also do the getResponse and then return the response value
19:40:36 <SamB> well, if I could inject FFI constructs...
19:41:07 <dons> sethk, how about 'runRequest' or similar?
19:41:10 <lispy> dons: @eval is such a nice learning tool, i've been happy so many times that we have lambdabot
19:41:13 <dons> sounds like a good idea though.
19:41:20 <sethk> dons, yes, that's better
19:41:34 <sethk> dons, ok, I'll use that name.
19:41:58 <sethk> dons, another name is a better idea, in case I want to switch current code over a bit at a time
19:42:02 <dons> lispy, thanks. i think its a good tool too :) this channel has benefited, it helps automate much teaching of haskell, many faq stuff, such that we can concentrate on the hard issues.
19:43:21 <SamB> > $(dyn "hello")
19:43:23 <lambdabot>  Not in scope: `hello'
19:44:12 <dons> yeah, dyn stuff is scary. but still it should be restricted to stuff in the trusted base. and it gets type checked anyway
19:44:24 <SamB> I don't recall what dyn does
19:44:27 <sethk> dons, I'm also finding that the only need for my status value is to detect errors that are really contained within the communications layer, such as other end of connection no longer exists, etc.  So I was thinking of removing status from the Response class, and making it something that only putRequest/getResponse and now runRequest know about.  Does that sound sensible?
19:44:53 <dons> soudns reasonable. abstract by all means!
19:45:05 <sethk> dons, runRequest becomes a method in the Server class, right?
19:45:19 <sethk> dons, should I post the most recent C/S code?
19:45:33 <SamB> > $(let x = dyn "dyn x" in x)
19:45:34 <lambdabot>  Not in scope: `dyn x'
19:45:38 <SamB> okay
19:45:40 <SamB> ...
19:45:45 <SamB> you can have spaces in symbols?
19:46:13 <dons> sethk, sure. i can have a look
19:46:17 <sethk> dons, runRequest knows about both the Request class and the Response class, so it belongs in Server along with runServer, I think
19:46:20 <sethk> dons, ok, I'll post
19:48:11 <sethk> dons, http://paste.ubuntu-nl.org/12816
19:49:30 <sethk> dons, there is a bit more typing then I would like to create a new Server, but it is all boiler plate and I've created a file that I can just do a find/replace on the three types (Request, Response, and Server), so as a practical matter it isn't a problem
19:50:15 <sethk> dons, I created a new server today, and moved another server to a different process, and it took about 20 minutes
19:51:58 <dons> cool. i'm just a bit busy atm, i'll look at the code in aroudn 30 mins.
19:53:46 <SamB> > $(do n <- mkName "Foo"; letE [newtypeD (return []) [] (normalC n) []] (conE (normalC n)))
19:53:47 <lambdabot> Couldn't match `Q t' against `Name'
19:53:55 <SamB> hmm...
19:54:35 <SamB> > $(let n = mkName "Foo" in letE [newtypeD (return []) [] (normalC n) []] (conE (normalC n)))
19:54:36 <lambdabot> Couldn't match `Q Dec' against `t -> t1'
19:55:12 <dons> newtype eh?
19:55:27 <SamB> I'm grasping at straws here
19:56:03 <dons> you won't be able to splice it inside an expression, anyway.
19:56:10 <SamB> I know
19:56:26 <SamB> but if I at least crash the compiler, that will be fun ;-)
19:56:41 <sethk> dons, no hurry at all, I appreciate it whenever you might find a moment
19:57:07 <SamB> > $(let n = mkName "Foo" in letE [newtypeD (return []) n [] (normalC n) []] (conE (normalC n)))
19:57:08 <lambdabot> Couldn't match `Q Con' against `t -> t1'
19:58:10 <SamB> > $(let n = mkName "Foo" in letE [newtypeD (return []) n [] (normalC n []) []] (conE n))
19:58:11 <lambdabot> ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
19:58:11 <lambdabot>    Illegal kind of declaration in where clause
19:58:11 <lambdabot>   newtype Foo = Foo
19:58:21 <SamB> there, wasn't that fun?
19:58:36 * SamB got a longish eror message ;-)
19:59:41 <SamB> you realize of course that the only reason it didn't work was that GHC doesn't support that, right?
19:59:52 <SamB> well, and it would have been a type error
20:00:11 <dons> panic!
20:00:56 <SamB> where by "work" I mean finally let me use a type of my own definition in lambdabot's @eval
20:01:02 <dons> well, Haskell has never supported local type decls, right? but its a conceivable extensions, I guess.
20:01:21 <SamB> no, haskell hasn't
20:01:38 <SamB> but that got right past GHC's sanity-checking
20:02:17 <dons> hmm. I mean, I can imagine local type synonyms. but local newtypes I think would never be needed.
20:02:31 <dons> unless the type language gets severly more complex at some point :}
20:02:44 <SamB> well, that isn't any reason why they shouldn't be allowed or couldn't be useful
20:02:45 <dons> I wonder what ghc 6.6 says? 
20:02:46 <dons> let's see.
20:02:49 <SamB> as long as you don't return them
20:03:27 <SamB> I'm figuring it would be like...
20:03:51 <SamB> that error you get when one of those dratted esses escapes
20:04:01 <dons> ah, its not a panic in 6.6
20:04:09 <dons>     Illegal kind of declaration in where clause newtype Foo = Foo
20:04:09 <dons>     When splicing generated code into the program
20:04:10 <SamB> aww
20:04:12 <dons>     In the expression:
20:04:12 <dons>         $[splice](let n = mkName "Foo"
20:04:12 <dons>                   in letE [newtypeD (return []) n [] (normalC n []) []] (conE n))
20:04:15 <dons>     In the definition of `it':
20:04:18 <dons>         it = $[splice](let n = mkName "Foo"
20:04:20 <dons>                        in letE [newtypeD (return []) n [] (normalC n []) []] (conE n))
20:04:23 <dons> :)
20:04:28 <SamB> the funny thing is, it was supposed to be a let clause
20:04:30 <dons> the word 'kind' is overloaded here.
20:04:52 <dons> they shouldn't use it in error messages except when refering to kinds
20:05:07 <SamB> would you prefer the term "type"?
20:05:10 <dons> (I first parsed it as : Illegal kind declaration ... )
20:05:20 <SamB> "sort"?
20:05:28 <seba> hi.... i am having some problem with a parser... i am using a module ParseLib.lhs developed by Simon Thompson, somebody know it?
20:05:34 <dons> Illegal type declaration in ...
20:06:12 <SamB> well, we don't have a keyword called "sort", at least
20:08:48 <SamB> hmm, what does recover do?
20:09:38 <SamB> > unsafe
20:09:39 <lambdabot> Unsafe
20:11:10 <dons> hmm, what's that then?
20:11:18 <SamB> not much
20:11:24 <sethk> seba, a bit, but you'll have better luck if you paste some code on the paste bot and point us at it
20:11:33 <SamB> I just couldn't resist doing it because of the word "unsafe" in the name ;-)
20:11:36 <dons> ah, hehe. got it :)
20:11:46 <dons> nice joke :)
20:12:09 <dons> it even looks like lambdabot is some super-smart safety-checking bot
20:12:18 <dons> > undefined
20:12:19 <lambdabot> Add a type signature
20:12:23 <dons> > undefined :: ()
20:12:25 <lambdabot> Undefined
20:12:26 <dons> > unsafe
20:12:27 <lambdabot> Unsafe
20:12:40 <sethk> > unanything
20:12:40 <lambdabot>  Not in scope: `unanything'
20:12:43 <SamB> @hoogle a -> Name
20:12:44 <lambdabot> No matches, try a more general search
20:12:53 <SamB> what?
20:13:01 <SamB> @hoogle mkName
20:13:01 <lambdabot> Language.Haskell.TH.mkName :: String -> Name
20:13:01 <lambdabot> Language.Haskell.TH.Syntax.mkNameG_d :: String -> String -> Name
20:13:01 <lambdabot> Language.Haskell.TH.Syntax.mkNameG_tc :: String -> String -> Name
20:13:11 <mauke> > undefined :: Unsafe
20:13:12 <lambdabot>  Not in scope: type constructor or class `Unsafe'
20:13:15 <SamB> why didn't i give me that before
20:13:35 <SamB> @type unsafe
20:13:36 <lambdabot> Not in scope: `unsafe'
20:13:42 <SamB> good one ;-)
20:13:47 <sethk> you mean searching for Name should have produced mkName ?
20:13:59 <SamB> sethk: searching for "a -> Name", yes
20:14:18 <sethk> SamB, does it treat TH differently?
20:14:31 <sethk> no, I guess not, since you didn't do anything special to get mkName
20:14:58 <sethk> @hoogle Line
20:14:59 <lambdabot> Text.ParserCombinators.Parsec.Line :: type Line
20:14:59 <lambdabot> Distribution.PackageDescription.LineNo :: type LineNo
20:14:59 <lambdabot> System.IO.LineBuffering :: BufferMode
20:15:29 <sethk> that didn't bring up getLine
20:15:37 <sethk> @hoogle getLine
20:15:38 <lambdabot> Prelude.getLine :: IO String
20:15:38 <lambdabot> System.Console.Readline.getLineBuffer :: IO String
20:15:38 <lambdabot> System.Console.SimpleLineEditor.getLineEdited :: String -> IO (Maybe String)
20:15:41 <dons> @hoogle+
20:15:42 <lambdabot> IO.hGetLine :: Handle -> IO String
20:15:58 <SamB> @hoogle m String
20:16:02 <dons> @hoogle Line
20:16:04 <lambdabot> Prelude.undefined :: a
20:16:04 <lambdabot> Test.QuickCheck.Batch.bottom :: a
20:16:04 <lambdabot> Prelude.id :: a -> a
20:16:05 <lambdabot> Text.ParserCombinators.Parsec.Line :: type Line
20:16:05 <lambdabot> Distribution.PackageDescription.LineNo :: type LineNo
20:16:05 <lambdabot> System.IO.LineBuffering :: BufferMode
20:16:10 <dons> @hoogle+
20:16:11 <lambdabot> Prelude.lines :: String -> [String]
20:16:11 <lambdabot> Data.PackedString.linesPS :: PackedString -> [PackedString]
20:16:13 <lambdabot> Text.Html.lineToHtml :: String -> Html
20:16:18 <dons> bah too many
20:16:35 <sethk> Line probably wasn't a great choice
20:17:18 <sethk> but, SamB, it did the same thing with getLine vs Line as it did with Name vs mkName
20:18:49 <SamB> sethk: but getLine doesn't return a Line
20:18:57 <sethk> urd. yjsy
20:19:00 <sethk> yes, that's true
20:19:05 <dons> file a hoogle bug report on the wiki page?
20:19:10 <SamB> @hoogle a -> Line
20:19:11 <lambdabot> No matches, try a more general search
20:19:22 <dons> ah, but Line looks like a constructor. that's why search for Line didn't work
20:19:23 <dons> @hoogle line
20:19:24 <lambdabot> Text.ParserCombinators.Parsec.Line :: type Line
20:19:24 <lambdabot> Prelude.lines :: String -> [String]
20:19:24 <lambdabot> Data.PackedString.linesPS :: PackedString -> [PackedString]
20:19:28 <dons> @hoogle+
20:19:29 <lambdabot> Text.Html.lineToHtml :: String -> Html
20:19:29 <lambdabot> Text.Html.linesToHtml :: [String] -> Html
20:19:29 <lambdabot> Text.PrettyPrint.HughesPJ.lineLength :: Style -> Int
20:19:39 <dons> should be case insense.
20:19:41 <dons> @hoogle+
20:19:42 <lambdabot> Distribution.PackageDescription.LineNo :: type LineNo
20:19:42 <lambdabot> System.IO.LineBuffering :: BufferMode
20:19:42 <lambdabot> System.Console.Readline :: module
20:19:45 <SamB> hmm...
20:19:49 <dons> getting there
20:19:51 <dons> @hoogle+
20:19:52 <lambdabot> IO.hGetLine :: Handle -> IO String
20:19:52 <lambdabot> Prelude.getLine :: IO String
20:19:52 <lambdabot> Network.Socket.OOBInline :: SocketOption
20:19:55 <dons> yay!
20:20:05 <dons> Prelude should be put at the top
20:20:11 <dons> that's a legit bug.
20:25:52 <SamB> very odd
20:26:00 <SamB> try running this
20:26:03 <SamB> $(do DataConI {} <- reify ''Name; [|1|])
20:33:10 <SamB> hmm
20:33:25 <SamB> what was the way you were using reify for ill?
20:34:03 <SamB> I suppose using it to construct the Name of unsafePerformIO is a bit long-winded
20:34:13 <dons> apparently you can get access to all sorts of weird things once you can reify the IO type
20:34:22 <dons> > [| IO |]
20:34:23 <lambdabot>  Not in scope: data constructor `IO'
20:34:27 <dons> good good
20:34:35 <dons> > [|t IO |]
20:34:36 <lambdabot>  Not in scope: data constructor `IO'
20:34:45 <SamB> > [t| IO |]
20:34:46 <dons> > [t| IO |]
20:34:47 <lambdabot>   Kind error: `IO' is not applied to enough type arguments
20:34:47 <lambdabot>   In an expression type signature: IO
20:34:47 <lambdabot>   In the definition of `vkv': vkv = [t| IO |]
20:34:47 <lambdabot>   Kind error: `IO' is not applied to enough type arguments
20:34:47 <lambdabot>   In an expression type signature: IO
20:34:48 <lambdabot>   In the definition of `dbz': dbz = [t| IO |]
20:34:55 <dons> > [t| IO () |]
20:34:56 <SamB> I hate that!
20:34:56 <lambdabot> GHC.IOBase.IO GHC.Base.()
20:35:08 <SamB> kind-checking shouldn't be done on those
20:35:29 <dons> hmm. but there we  have it. IOBase abstract syn in scope.
20:35:33 <dons> so what can then be done?
20:35:53 <dons> can you lookup its defns?
20:36:04 <dons> and then write unsafePerformIO?
20:36:12 <dons> \(IO a) -> ... a
20:36:36 <SamB> I don't think you can reify a module
20:36:57 <dons> no, but we've refified the type IO, no?
20:37:00 <SamB> oh, that
20:37:12 <dons> then there's ways to lookup infor about the IO type, isn't there?
20:37:33 <SamB> ah, yes
20:39:17 <sethk> can invoking show cause a bad parse message?
20:39:56 <sethk> I don't see how
20:40:31 <sethk> I think I see it, the show must have forced a value that in turn caused read to be called
20:48:09 <SamB> okay, so where would I get a RealWorld, and how?
20:48:39 <sethk> to me, the real world is where people pay you to do things
20:48:39 <dons> its' jsut a token, should you name the variable, no?
20:48:51 <sethk> :)
20:49:10 <SamB> Prelude Language.Haskell.TH> $(do TyConI (NewtypeD _ _ _ (NormalC cn _) _) <- reify ''IO; n <- newName "x"; lamE [conP cn [varP n]] (varE n))
20:49:10 <SamB> Top level:
20:49:10 <SamB>     No instance for (Show (IO a
20:49:10 <SamB>                            -> GHC.Prim.State# GHC.Prim.RealWorld
20:49:10 <SamB>                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)))
20:49:14 <SamB>       arising from use of `print' at Top level
20:49:27 <sethk> what does reify mean?
20:49:41 <dons> it converts code into an abstract syntax tree representing that code
20:50:05 <sethk> is that in the library somewhere?
20:50:08 <SamB> actually, it tells you about a type or variable name
20:50:13 <dons> its part of template haskell
20:50:16 <SamB> er, type or data
20:50:22 <SamB> constructor or variable
20:50:23 <dons> SamB? tells you about?
20:50:37 <dons> ?type Language.Haskell.TH.reify
20:50:38 <lambdabot> Language.Haskell.TH.Syntax.Name
20:50:38 <lambdabot>           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Info
20:50:45 <dons> ah, Q Info!
20:50:51 <dons> ?type Language.Haskell.TH.lift
20:50:53 <lambdabot> Not in scope: `Language.Haskell.TH.lift'
20:50:55 <sethk> I'll have to look at TH again, see if I'm ready to get the general idea of what it is doing
20:50:57 <dons> ?type Language.Haskell.TH.Syntax.lift
20:50:59 <lambdabot> forall t.
20:50:59 <lambdabot>             (Language.Haskell.TH.Syntax.Lift t) =>
20:50:59 <lambdabot>             t -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
20:51:06 <dons> that's what I was thinking of
20:51:14 <dons> well, refiy is kind of misnamed, isn't it?
20:51:23 <SamB> maybe!
20:51:35 <SamB> but it is certainly the one you don't want people using!
20:51:37 <dons> it should be called 'info'. and lift should be called 'reify'
20:51:45 <dons> yep
20:51:53 <SamB> well, lift is called that because its more obvious what it does that way
20:53:07 <SamB> anyway, how am I supposed to get a GHC.Prim.RealWorld to feed this thing?
20:53:55 <dons> yeah. hmm. you need the magic realWord# right?
20:54:06 <SamB> @hoogle RealWorld
20:54:07 <lambdabot> Control.Monad.ST.RealWorld :: data RealWorld
20:54:14 <dons> unsafePerformIO (IO m) = case m realWorld# of (# _, r #)   -> r
20:54:33 <SamB> oh, sure, I guess...
20:54:35 <dons> coudl you apply it to 'undefined' ?
20:54:49 <dons> since its jsut a token which is thrown away at compile time..
20:54:49 <SamB> of course not
20:54:55 <SamB> undefined is of type a
20:55:10 <SamB> @kind (forall a. a)
20:55:12 <lambdabot> *
20:55:28 <SamB> @type GHC.IOBase.IO
20:55:30 <lambdabot> forall a.
20:55:30 <lambdabot>       (GHC.Prim.State# GHC.Prim.RealWorld
20:55:30 <lambdabot>       -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
20:55:30 <lambdabot>       -> IO a
20:55:31 <dons> @type GHC.Prim.realWorld#
20:55:32 <lambdabot> GHC.Prim.State# GHC.Prim.RealWorld
20:55:44 <dons> @kind GHC.Prim.RealWorld
20:55:46 <lambdabot> *
20:55:50 <SamB> @kind GHC.Prim.RealWorld
20:55:52 <lambdabot> *
20:55:54 <dons> @type undefined :: GHC.Prim.RealWorld
20:55:55 <lambdabot> GHC.Prim.RealWorld :: GHC.Prim.RealWorld
20:55:59 <dons> of course yes!
20:55:59 <SamB> @kind GHC.Prim.State#
20:56:01 <lambdabot> * -> #
20:56:04 <SamB> ah!
20:56:07 <SamB> there we go.
20:56:12 <SamB> that won't fit.
20:57:10 <dons> State# is kind of magic, eh? * -> #
20:57:21 <SamB> @type undefined :: GHC.Prim.State# a
20:57:22 <dons> we thought previously there was no such function
20:57:22 <lambdabot>   Kind error: Expecting a lifted type, but `GHC.Prim.State# a' is unlifted
20:57:22 <lambdabot>   In an expression type signature: GHC.Prim.State# a
20:57:40 <SamB> dons: that isn't a function, its a type constructor ;-)
20:57:52 <dons> @type undefined :: GHC.Prim.State# GHC.Prim.RealWorld
20:57:53 <lambdabot>   Couldn't match kind `#' against `*'
20:57:53 <lambdabot>   When matching the kinds of `GHC.Prim.State# GHC.Prim.RealWorld :: #' and
20:58:18 <dons> ah, what's the State# constr?
20:58:46 <SamB> data State# a   -- <wired into compiler>
20:59:07 <dons> ah, a magic token. hmm
20:59:53 <dons> so we can't fake it in user code? (/me remembers Awkward Squad paper details..)
21:00:41 <SamB> @hoogle State#
21:00:42 <lambdabot> No matches found
21:00:45 <SamB> @hoogle State
21:00:46 <lambdabot> Control.Monad.State :: module
21:00:46 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
21:00:46 <lambdabot> Control.Monad.State.State :: newtype State s a
21:00:56 <SamB> @hoogle+
21:00:57 <lambdabot> Test.HUnit.Base.State :: Path -> Counts -> State
21:00:57 <lambdabot> Test.HUnit.Base.State :: data State
21:00:57 <lambdabot> Text.ParserCombinators.Parsec.Prim.State :: [tok] -> SourcePos -> st -> State tok st
21:01:00 <SamB> @hoogle+
21:01:01 <lambdabot> Text.ParserCombinators.Parsec.Prim.State :: data State tok st
21:01:01 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
21:01:01 <lambdabot> Control.Monad.State.StateT :: newtype StateT s m a
21:01:03 <SamB> @hoogle+
21:01:03 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateInput :: State tok st -> [tok]
21:01:03 <lambdabot> Text.ParserCombinators.Parsec.Prim.statePos :: State tok st -> SourcePos
21:01:05 <lambdabot> Text.ParserCombinators.Parsec.Prim.stateUser :: State tok st -> st
21:01:05 <SamB> @hoogle+
21:01:07 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
21:01:08 <SamB> @hoogle+
21:01:09 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
21:01:09 <SamB> @hoogle+
21:01:11 <SamB> @hoogle+
21:01:11 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
21:01:13 <SamB> @hoogle+
21:01:13 <lambdabot> Control.Monad.State.mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
21:01:15 <SamB> @hoogle+
21:01:15 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
21:01:17 <SamB> @hoogle+
21:01:17 <lambdabot> Control.Monad.State.withState :: (s -> s) -> State s a -> State s a
21:01:19 <SamB> @hoogle+
21:01:19 <lambdabot> System.Console.Readline.resetLineState :: IO ()
21:01:21 <SamB> @hoogle+
21:01:21 <lambdabot> Text.ParserCombinators.Parsec.Prim.getParserState :: GenParser tok st (State tok st)
21:01:23 <SamB> @hoogle+
21:01:30 <SamB> @hoogle+
21:01:35 <SamB> ...
21:01:44 <SamB> okay, I guess nothing re-exports State#
21:01:48 <SamB> so I can't even reify it
21:02:02 <SamB> well, without doing that Name thing...
21:02:19 <dons> they've locked it down by a) making it an empty type, and b) making it kind # so bottom isn't an element either. good trick
21:02:56 <SamB> and it wasn't even for lambdabots benefit!
21:02:57 <dons> seems like a useful thing to have, types where bottom isn't an element.
21:03:09 <dons> good for not subverting IO. and probably lots of other things
21:03:30 <SamB> like taking no cells of memory
21:06:54 <SamB> whoa, this exploit would be *long*
21:07:29 <SamB> I don't think it can fit in a freenode message ;-)
21:07:56 <SamB> even if you *did* enable reify
21:09:44 <SamB> actually, I'm not sure it can be done
21:09:52 <SamB> you definately would need packedstring...
21:11:53 <dons> hehe :S
21:12:46 <SamB> Prelude Language.Haskell.TH> putStrLn $(do TyConI (DataD _ _ _ [NormalC named _] _) <- reify ''Name; reify named >>= (stringE . show . ppr))
21:12:46 <SamB> Constructor from Language.Haskell.TH.Syntax.Name: Language.Haskell.TH.Syntax.Name :: Data.PackedString.PackedString ->
21:12:46 <SamB>                                                                                      Language.Haskell.TH.Syntax.NameFlavour ->
21:12:46 <SamB>                                                                                      Language.Haskell.TH.Syntax.Name
21:13:38 <dons> ah, the Names are PackedStrings??
23:08:26 <pierre-> @where fudgets
23:08:26 <lambdabot> I know nothing about fudgets.
23:10:02 <Pegazus> @where indonesia
23:10:02 <lambdabot> I know nothing about indonesia.
23:10:16 <Pegazus> @where canada
23:10:16 <Pegazus> ?
23:10:17 <lambdabot> I know nothing about canada.
23:10:39 <PeterK> @where fps
23:10:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
23:11:38 <Pseudonym> @where anything
23:11:39 <lambdabot> I know nothing about anything.
23:13:09 <olliej> @where am i
23:13:09 <lambdabot> I know nothing about am.
23:13:15 <olliej> :(
23:13:21 <PeterK> @where+ anything http://www.google.com/
23:13:22 <lambdabot> Done.
23:13:31 <PeterK> @where anything
23:13:32 <lambdabot> http://www.google.com/
23:14:22 <dons> a little tutorial I just wrote on using fps/Data.ByteString to improve some string hacking code: http://haskell.org/haskellwiki/Wc
23:14:28 <dons> some people might be interested
23:19:58 <Korollary> Good one
23:20:02 <Korollary> @karma+ dons
23:20:02 <lambdabot> dons's karma raised to 31.
23:20:04 <olliej> does anyone know if ghc builds on osx/intel?
23:21:05 <mahogny> heard nothing, but I don't see why it shouldn't
23:22:00 <dons> olliej: it must be the most faq on the lists these days :)
23:22:06 <dons> WolfgangT is working on it.
23:22:12 <olliej> dons :)
23:22:16 <dons> you'll hear news when it is done.
23:23:42 <dons> useful tut, Korollary ? any suggestions?
23:24:13 <shapr> Speaking of WolfgangT, is PIC available for all GHC platforms?
23:25:28 <Korollary> dons: No suggestions, but a question: why do we use C macros instead of TH?
23:25:41 <boegel> does anyone know how hard it would be to code a cycle-accurate performance simulator in Haskell ?
23:25:58 <boegel> @karma boegel
23:25:59 <lambdabot> You have a karma of -1
23:26:00 <dons> TH is too heavy
23:26:03 <boegel> euh :(
23:26:39 <dons> cycle-accurate, how hard? hmm. moderately easy, perhaps?
23:26:53 <Korollary> boegel: You would have to keep a ton of state around. Other than that, I don't know.
23:27:00 <dons> implementing operational semantics in interpreters is something we do in haskell all the time.
23:27:08 <boegel> dons: really? are you familair with tools like SimpleScalar?
23:27:10 <dons> so as long as you know what each instruction is supposed to do.
23:27:30 <dons> easy to do, but lots of code to write... 
23:27:36 <dons> vaguely, boegel 
23:27:44 <Korollary> Ironically, I did write a cycle-accurate simulator for my thesis.
23:27:49 <boegel> dons: that shouldn't be a problem I think... probably using Monads is the way to go then?
23:27:56 <boegel> Korollary: you did?
23:28:03 <boegel> Korollary: in Haskell?
23:28:16 <dons> for sure. you'd have an Env monad carrying around registers, memory and such.
23:28:17 <Korollary> boegel: Yes, in C++ for an esoteric research cpu.
23:28:32 <boegel> Korollary: cool
23:29:00 <boegel> dons: we (me and Itkovian) have had such a project in our minds for a long time, but we just don't have the time :(
23:29:12 <Korollary> boegel: which cpu are you trying to simulate?
23:29:16 <dons> jip wrote his game boy emulator in a couple of days. so I'd imagine its something along those lines to get a basic prototype, no?
23:29:34 <dons> then , to get all the instrumentation, more work..
23:30:09 <shapr> @karma+ boegel 
23:30:10 <lambdabot> boegel's karma raised to 0.
23:30:12 <shapr> @karma+ boegel 
23:30:13 <lambdabot> boegel's karma raised to 1.
23:30:19 <shapr> Lotsa karma for writing TMR articles.
23:30:22 <shapr> @karma+ boegel 
23:30:23 <lambdabot> boegel's karma raised to 2.
23:30:23 <pierre-> @karma
23:30:24 <lambdabot> You have a karma of 0
23:31:03 <Itkovian> The idea would be that you'd have plugins for almost anything
23:31:08 <PeterK> @karma
23:31:09 <lambdabot> You have a karma of 0
23:31:16 <Itkovian> so you could alter cache size, branch predictions etc
23:31:21 <Korollary> we need a @karmarankings
23:32:14 <boegel> Itkovian: exactly
23:32:26 <dons> I was thinking about @karma-rank this mornign, in fact.
23:32:33 <boegel> problem is neither me or Itkovia is into Monads :(
23:32:42 <Korollary> which cpu?
23:32:57 <boegel> Korollary: several in fact, as Itkovian said
23:33:15 <boegel> Korollary: starting with a standard one, and allowing to change all possible parameters
23:33:19 <Korollary> if it's a modern intel/amd, I'd be more concerned about the amount of detail than the implementation language.
23:33:20 <Itkovian> But I'm not sure about the cycle accuracy with such a model
23:33:36 <boegel> (i.e. issue width, cache sizes, # functional units, branch predictor, ...)
23:33:57 <boegel> Korollary: you'd have to start somehwere
23:34:00 <boegel> *somewhere
23:34:04 <tibbe> what's the meaning of angle brackets in math?
23:34:28 <boegel> Korollary: getting a standard thing to work would be great, then we'd have something to start from
23:34:28 <Korollary> tibbe: They're used to describe sequences iirc
23:34:35 <boegel> tibbe: vector product
23:34:39 <tibbe> alright
23:34:52 <boegel> Korollary: :)
23:34:57 <tibbe> \z. z P Q ... R
23:35:07 <shapr> Itkovian: Sounds like you want valgrind
23:35:13 <tibbe> that's a lambda term for a sequence right?
23:35:27 <tibbe> for the sequence P,Q,...,R
23:35:58 <dons> hmm. valgrind was written to benchmark ghc's native codegen. --little known fact.
23:36:06 <boegel> shapr: valgrind is for debugging, our simulator would be used for architectural research
23:36:21 <boegel> dons: cool :)
23:36:25 <Korollary> tibbe: The list(?) encoding I remember from untyped LC looked a bit different.
23:36:26 <Itkovian> afaik valgrind does debugging - memory stuff that's not freed etc.
23:37:06 <tibbe> hmm
23:37:20 <shapr> Sure it does debugging, but it's actually a cpu simulator, iirc.
23:37:51 <Itkovian> I don't think so, it's a binary instrumentation toolkit, no?
23:37:54 <Itkovian> brb
23:37:59 <Itkovian> the little fellar is awakening
23:38:47 <shapr> "Valgrind consists of the Valgrind core, which provides a synthetic software CPU, and Valgrind tools, which plug into the core, and instrument and analyse the running program. Anyone can write powerful new tools that add arbitrary instrumentation to programs. This is much easier than writing such tools from scratch. This makes Valgrind ideal for experimenting with new kinds of debuggers, profilers, and similar tools." http://va
23:38:47 <shapr> lgrind.org/info/about.html
23:39:21 <boegel> coolness
23:40:06 <sethk> shapr, I didn't know it's implementation either.  It's a very effective memory debugger
23:40:43 <shapr> It does much more than that, memory debugging is just its most popular feature.
23:41:18 <boegel> shapr: but valgrind is C, rigth?
23:41:27 <shapr> huh?
23:41:34 <sethk> shapr, yes, I saw what you pasted.  I wasn't aware of that
23:41:48 <shapr> "Valgrind works with programs written in any language. Because Valgrind works directly with program binaries, it works with programs written in any programming language, be they compiled, just-in-time compiled, or interpreted."
23:42:07 <shapr> "But it can, for example, be used to debug and profile systems written in a mixture of languages. Valgrind has been used on programs written partly or entirely in C, C++, Java, Perl, Python, assembly code, Fortran, Ada, and many others."
23:42:10 <Korollary> it's writtten in C
23:42:10 <boegel> shapr: I mean it's coded in C?
23:42:35 <boegel> ah okay, we want a Haskell simulator :) just for the fun of it
23:42:48 <shapr> The original version of Valgrind might be in Haskell.
23:42:58 <dons> i think it was always in C. i might be wrong though
23:43:02 <shapr> As dons said, valgrind was written by Julian Seward while trying to debug GHC.
23:45:38 <mahogny> why would they rewrite it in C? what a waste -_-
23:46:49 <shapr> mahogny: http://valgrind.org/docs/manual/mc-tech-docs.html#mc-tech-docs.history
23:46:58 <dons> it was the early 90s? writing cpu simulators seemed infeasible? there was no ffi?
23:47:25 <shapr> That whole 1.1 section is worth reading.
23:48:31 <Korollary> speed matters very much here
23:51:05 <shapr> Maybe Julian Seward would know why Urban Boquist was in favor of SSA-style machine code.
23:51:25 <shapr> hej Lemmih 
23:51:34 <Lemmih> Hiya.
23:53:08 <Oeje1> Lemmih: Hej.
23:53:36 <mahogny> way too many swedes in here :)
23:54:09 <Oeje1> mahogny: *cough*.
23:54:14 <mahogny> :)
23:54:35 <Korollary> It's due to @localtime
23:54:47 <shapr> mahogny: I'm not a Swede!
23:55:01 <mahogny> shapr, and that makes you feel special? ;)
23:55:18 <shapr> Well, it makes me feel confused sometimes... I've been living in Boden too long.
23:55:29 <mahogny> omg. sounds cold
23:55:36 <Korollary> shapr: your name looks swedish tho
23:55:37 <shapr> Happily, I am moving to Stockholm, and will be visiting Chalmers regularly after that.
23:55:46 <shapr> Korollary: Yeah, but I've only had this name for a few years.
23:56:00 <shapr> Only about seven years even.
23:56:09 <Korollary> If I get a new name, I'm picking Morbo or Megatron.
23:56:11 <mahogny> shapr, chalmers is that big huh?
23:56:39 <shapr> Chalmers is the best place in Sweden for both Haskell and Unicycling :-)
23:56:48 <mahogny> ...unicycling :)
23:56:57 * sjanssen looks on in dismay as the global mutable variable debate starts on haskell-cafe
23:57:09 <shapr> Yes, unicycling.
23:57:19 <shapr> mahogny: You've never tried unicycling?
23:57:28 <mahogny> no, I'm quite happy with two wheels :)
23:57:41 <mahogny> have you seen the segway version of a unicycle btw?
23:57:46 <shapr> C'mon, get rid of the training wheels!
23:57:48 <shapr> Yup, seen it.
23:57:49 <mahogny> lol
23:58:05 <mahogny> I'd like to see you doing an emergency break at 50km/h with a unicycle :)
23:58:18 <Korollary> sjanssen: Arent there many similar threads in the archives as well?
23:58:22 <shapr> Hey, I have hydraulic brakes.
23:58:30 <mahogny> o_O
23:58:40 <shapr> Seriously, I do.
23:58:44 <mahogny> and what holds you back when you go full out? :)
23:58:45 <Saulzar> They'll stop your bike...
23:58:47 <sjanssen> Korollary: there was a huge debate around a year ago
23:58:53 <Oeje1> mahogny: I'd like to see _you_ make an emergency break at 50 km/h.
23:58:55 <shapr> Holds me back?
23:59:11 <shapr> What do you mean?
23:59:22 <mahogny> what stops you from tilting over if you do a full stop?
23:59:32 <mahogny> Oeje1, that's ok, I got a front wheel that keeps me up straight :P
23:59:33 <shapr> You lean back.
23:59:43 <mahogny> sounds really nasty. how do you do in winter?
23:59:48 <shapr> Same thing.
23:59:58 <mahogny> ..you unicycle in winter as well? :o
