00:09:15 <RyanT5000> how do i define // for my array type?
00:09:34 <Korollary> @index (//)
00:09:34 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
00:09:42 <RyanT5000> so i just define it?
00:09:44 <Korollary> @type Data.Array.(//)
00:09:45 <lambdabot> Couldn't find qualified module.
00:09:45 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
00:09:47 <Korollary> err
00:09:54 <Korollary> @type (Data.Array.//)
00:09:55 <lambdabot> forall e i.
00:09:55 <lambdabot>        (GHC.Arr.Ix i) =>
00:09:55 <lambdabot>        GHC.Arr.Array i e -> [(i, e)] -> GHC.Arr.Array i e
00:10:09 <RyanT5000> ok i was just expecting it to be in a class
00:10:18 <RyanT5000> (class Array - until i realized Array wasn't a class)
00:10:46 <sjanssen> umm // is definitely in a class
00:11:08 <RyanT5000> it is?
00:11:34 <RyanT5000> what class?
00:11:38 <sjanssen> erm
00:12:09 <astrolabe> hoogle (//)
00:12:18 <astrolabe> @hoogle (//)
00:12:19 <lambdabot> Array.(//) :: Ix a => Array a b -> [(a, b)] -> Array a b
00:12:19 <lambdabot> Data.Array.(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
00:12:19 <lambdabot> Data.Array.IArray.(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
00:12:42 <sjanssen> the documentation lists // as a plain old function, but I don't see how that is possible
00:12:54 <RyanT5000> maybe because it's always in a different module?
00:12:55 <astrolabe> why not?
00:13:03 <RyanT5000> it's like C overloading, it looks
00:13:08 <sjanssen> @type (//)
00:13:08 <RyanT5000> er
00:13:09 <lambdabot> Not in scope: `//'
00:13:10 <RyanT5000> C++
00:13:58 <astrolabe> Oh I see.  Yes, but haskell functions often have parametric polymorphism.  Here it has ad-hoc polymorphism too.
00:14:10 <sjanssen> astrolabe: because (//) works for all instances of the IArray class, but nothing in the IArray gives this functionality
00:14:25 <sjanssen> Haskell absolutely does not have ad-hoc polymorphism
00:14:59 <astrolabe> I thought classes gave ad-hoc polymorphism
00:16:09 <sjanssen> classes aren't really ad-hoc, they can provide similar functionality sometimes I suppose
00:16:55 <astrolabe> hello
00:17:06 <astrolabe> hmmm my client is playing up
00:17:43 <astrolabe> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html defines (/)
00:17:50 <astrolabe> er (//)
00:18:40 <RyanT5000> OIC
00:18:45 <RyanT5000> if you import Data.Array
00:18:48 <RyanT5000> that's the only Array you can import
00:18:54 <RyanT5000> otherwise you need to import Data.Array.IArray
00:18:58 <sjanssen> yes, but look at the interface for the IArray class . . . it doesn't have any functions in it?  how does one write (//) in terms of nothing?
00:19:02 <RyanT5000> which provides a class version
00:20:17 <astrolabe> The report says '...and permits not only parametric polymorphism (using a traditional Hindley-Milner type structure) but also ad-hoc polymorphism, or overloading (using type classes).
00:21:09 <sjanssen> astrolabe: I probably have a poor definition of ad-hoc polymorphism then, sorry
00:21:22 <astrolabe> no problem
00:21:49 <RyanT5000> this is what i have so far
00:21:50 <RyanT5000> data ArrayStateTransition i e = ArrayStateTransition (ArrayStateNode i e) (i, e) 
00:21:50 <RyanT5000> data ArrayStateNode i e = ArrayStateNode (Maybe (ArrayStateNode i e)) [ArrayStateNode i e] (Maybe (ArrayStateNode i e)) 
00:21:50 <RyanT5000> data SlidingArray i e = SlidingArray (IOArray i e) (ArrayStateNode i e) 
00:22:05 <RyanT5000> not that anyone can read that crap
00:22:55 <RyanT5000> crap and its not even write
00:22:56 <RyanT5000> *right
00:23:02 <RyanT5000> lol my mind isn't working anymore
00:24:15 <sjanssen> I think you're over engineering this
00:24:23 <RyanT5000> yeah but it's just for fun :P
00:24:26 <RyanT5000> and to learn better haskell
00:24:33 <RyanT5000> also i think it *could* be useful
00:24:43 <RyanT5000> i don't think those datastructures are overengineered though
00:25:17 <sjanssen> data SlidingArray i e = SA [DiffArray i e] (DiffArray i e) [DiffArray i e]
00:25:35 <RyanT5000> that won't cut it
00:25:36 <dons> I think  everyone learning Haskell should implement an interpreter for an as-yet unimplemented language, like perl 6
00:25:41 <RyanT5000> it has to be a tree
00:25:44 <dons> oh, wait, someone already implemented a perl 6 in haskell..
00:26:21 <RyanT5000> what if you simultaneously have an old version and a new version, and then you update the old version
00:26:26 <RyanT5000> that's why it's a tree
00:26:38 <RyanT5000> but don't worry; there's no performance penalty for it being a tree :)
00:26:59 <astrolabe> Maybe it would be clearer if you labelled some fields.
00:27:04 <RyanT5000> yeah, definitely
00:27:11 <sjanssen> RyanT5000: that doesn't make sense unless this data structure is mutable
00:27:28 <RyanT5000> how come?
00:27:36 <RyanT5000> what if i have
00:27:42 <RyanT5000> x = buildTheOriginalArray
00:27:44 <sjanssen> ah, actually I catch your drift now
00:27:48 <RyanT5000> yeah
00:27:58 <sjanssen> you're saying you modify, go back in time, modify
00:28:05 <RyanT5000> right
00:28:54 <RyanT5000> ooh i think my list in the ArrayStateNode structure is unnecessary
00:30:15 <RyanT5000> ah yes!
00:30:22 <RyanT5000> it is unnecessary
00:30:41 <RyanT5000> so it boils down to being a doubly-linked list instead of a singly-linked list
00:33:04 <newsham> hmm.. found HWS, but it doesnt compile, and there are warnings of deprecated modules
00:33:21 <newsham> (its in cvs on haskell.org under fptools)
00:34:07 <RyanT5000> data T i e = T { 
00:34:08 <RyanT5000>      nextOrPrev :: (N i e), 
00:34:08 <RyanT5000>      diff :: (i, e) 
00:34:08 <RyanT5000>      } 
00:34:08 <RyanT5000> data N i e = N { 
00:34:08 <RyanT5000>      parent :: (Maybe (T i e)),
00:34:10 <RyanT5000>      currentChild :: (Maybe (T i e))
00:34:12 <RyanT5000>      }
00:34:14 <RyanT5000> data A i e = A (IOArray i e) (N i e)
00:35:54 <RyanT5000> you can traverse this structure to recover any state
00:36:02 <RyanT5000> i'm not sure if my definition of A is right here, though
00:36:33 <RyanT5000> it might need another Node, the one the user *thinks* it's at
00:37:54 <RyanT5000> and of course there could be a different version of this where it had multiple cached versions of the array
00:38:12 <RyanT5000> and it had some heuristic for determining which one it would use at any given time
00:38:31 <RyanT5000> (not useful for my game, though)
00:40:00 <RyanT5000> well.... i need to get some sleep (it's almost 4 here, east coast USA); i really can't thank you guys enough for the help
00:40:14 <dons> :)
00:42:52 <dons> newsham, re. HWS not compiling. most likely library interfaces that've changed since 2000, when it was written.
00:42:59 <dons> (and it was run on haskell.org back then too!)
00:43:41 <dons> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg06833.html 
00:43:47 <dons> ^^ originnal release msg
00:43:57 <dons> "anyone who crashes it gets a gold star"
00:56:33 <newsham> anyone expert in ghc feel like reviving the build? :)
00:58:32 <Pegazus> @type map (+) [1,2,3] :: [Float]
00:58:33 <lambdabot>   Couldn't match `Float' against `t -> t1'
00:58:33 <lambdabot>   Expected type: Float
00:58:36 <dons> it should just be a matter of changing the library imports to match the new ones. and replacing some library functions
00:58:40 <Pegazus> @type map (+) [1,2,3]
00:58:41 <lambdabot> forall a. (Num a) => [a -> a]
00:58:52 <dons> lambdabot?
00:59:03 <Pegazus> @type (map (+) [1,2,3])
00:59:04 <lambdabot> forall a. (Num a) => [a -> a]
00:59:05 <dons> oh.
01:00:02 <newsham> the makefile seems hosed too.. but i'll work around that
01:09:05 <newsham> blah, i'm such a noob.  how do I make it search the current dir for other modules when doing seperate compilation?
01:09:25 <dons> ghc --make
01:09:28 <dons> ?
01:09:39 <dons> otherwise its single module, one shot compilation
01:09:48 <dons> or use hmake, which does much  like --make
01:10:45 <dons> ?wiki Research_papers
01:10:47 <lambdabot> No Result Found.
01:10:54 <dons> ?quit silly bot
01:11:13 <dons> ?wiki Research_papers
01:11:25 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers
01:11:30 <bolrod> O_o
01:11:45 <bolrod> it has a will of its own
01:12:02 <dons> no. it still was running old code that had a command removed.
01:12:07 <dons> sorry, aliased to google
01:12:18 <dons> I could have just reloaded @dummy  I guess
01:12:40 <dons> anyway, new wiki page: http://www.haskell.org/haskellwiki/Research_papers
01:12:54 <dons> if you've written Hsakell papers, or know of some good'ns. add them
01:13:12 <dons> I don't want to do the whole literature review myself ;)
01:13:55 <dons> research papers are our language''s main documentation, and they're just not as available as they should be.
01:14:05 <dons> I think.
01:14:31 <RyanT5000> can't... sleep... haskell will eat me....
01:14:41 <RyanT5000> well maybe not physically, but it's consuming me mentally
01:14:42 <bolrod> its will!
01:14:59 <RyanT5000> in any case, i optimized the hell out of my datastructure
01:15:14 <RyanT5000> data T i e = T { 
01:15:14 <bolrod> and it still works just as slow?
01:15:14 <RyanT5000>      closerToCached :: (T i e), 
01:15:14 <RyanT5000>      diff :: (i, e),
01:15:14 <RyanT5000>      cachedState :: Maybe (IOArray i e)
01:15:14 <RyanT5000>      }
01:15:15 <RyanT5000> data A i e = A (T i e)
01:15:18 <RyanT5000> lol
01:15:26 <RyanT5000> no it's not in what you'd calll the "implementation" phase yet
01:15:34 <dons> bad bolrod ;)
01:15:34 <RyanT5000> (i'm still learning haskell to a large degree)
01:15:51 <bolrod> :o!?
01:15:53 <RyanT5000> but i determined i didn't need to actually store the nodes of the tree
01:15:58 <RyanT5000> just the transitions
01:16:38 <bolrod> I dont get this.. you're putting functions in a data ?
01:16:45 <RyanT5000> hm?
01:16:56 <RyanT5000> records
01:16:56 <bolrod> blah
01:17:00 <RyanT5000> just naming my variables
01:17:03 <RyanT5000> i can do that right?
01:17:06 <bolrod> I dont know!
01:17:07 <bolrod> :)
01:17:10 <RyanT5000> :P
01:19:06 <bolrod> damn.. I'm tired
01:20:14 <dons> records are just labels for the various fields of the data type
01:21:00 <dons> it just so happens that the label can be used as a function that selects that field from the data type enclosing it, but you can't tell that from the above 
01:21:23 <RyanT5000> ah
01:21:32 <RyanT5000> so now all i need to figure out
01:21:42 <RyanT5000> is how to make those T's mutable within my monad
01:22:51 <dons> so you need a state monad? or you mean truly mutate (in-place destrctively update?)
01:23:02 <RyanT5000> hm, i'm not sure
01:23:09 <dons> I think a state monad maybe.
01:23:19 <RyanT5000> probably
01:23:26 <dons> which looks like muutability, but isn't.
01:23:32 <RyanT5000> right, which is how i want it :)
01:23:38 <dons> do s <- get  ; s' = s + 1 ; put s
01:23:42 <dons> put s' I mean
01:24:05 <mauke> update (1 +)
01:24:13 <dons> RyanT5000: weren't you hacking this when I woke up this morning?
01:24:25 <dons> and now I'm knocking off work.
01:24:25 <RyanT5000> i don't think this exact thing
01:24:27 <dons> good stuff!
01:24:38 <RyanT5000> but haskell in general yeah
01:24:49 <RyanT5000> i woke up at about noon and i've been working on haskell since
01:24:54 <RyanT5000> i mean, except eating and stuff
01:24:56 <dons> cool :)
01:25:06 <dons> me too
01:25:55 <RyanT5000> are state variables going to be efficient?
01:25:55 <newsham>     Couldn't match `IOException' against `Exception'
01:25:55 <newsham>       Expected type: IOException
01:25:55 <newsham>       Inferred type: Exception
01:26:00 <RyanT5000> i need an arbitrary number of them
01:26:17 <newsham> (old hws code.  know how this has evolved?)
01:26:30 <newsham> I've got msot of the code building.. just down to Main.hs now
01:26:47 <RyanT5000> basically i have a tree, and one node contains the cached state (the actual IOArray that's storing non-diff data)
01:27:37 <RyanT5000> each T is an edge of the tree
01:27:54 <RyanT5000> with a link to the next-closest T
01:28:33 <RyanT5000> (next-closest to the cached state)
01:28:45 <RyanT5000> so if you keep traversing edges, you end up at the cached state
01:29:53 <RyanT5000> but each time you apply a diff, you need to flip that transition's sense
01:29:59 <RyanT5000> that's the part i don't know how to do efficiently
01:33:54 <RyanT5000> well, time to try sleep again
01:39:08 <newsham> whats the Data.Map equiv of Data.FiniteMap.listToFM ?
01:39:48 <newsham> ahh, fromList
01:49:03 <newsham> anyone wanna help with something?  http://lava.net/~newsham/x/hws.tgz
01:49:21 <newsham> I got rid of most of the deprecated stuff.  Main.hs is still missing some stuff
01:50:16 <newsham> there's still some warnings, a fwe deprecated stuff I couldnt figure out how to replace, and a build error in one last file
01:51:56 <ValarQ> newsham: what is it?
01:53:11 <newsham> Haskell Web Server.  old code
02:05:57 <newsham> anyone?
02:09:48 <Lemmih> newsham: I'll take a look if you post the source file in question and the build error on some paste site.
02:10:14 <newsham> http://lava.net/~newsham/x/hws.tgz  its a large project, nto just 1 pastebuf
02:10:57 <Lemmih> Well, then you're a lot less likely to get help, unfortunately.
02:11:04 <newsham> *nod*
02:12:07 <Muad_Dibber> (hint for newsham: put the error into the pastebin quick!)
02:12:21 <newsham> its a little disappointing that a real world haskell program from 2000 doesnt build in 2006 :(
02:12:41 <newsham> muad: there are several, and without context it wouldnt be that useful.
02:20:05 <tennin> yeah, Haskell still seems pretty unstable
02:21:40 <Lemmih> Haskell is stable, Glasgow Haskell is fun/unstable.
02:22:07 <newsham> sure, but if you want to do real-world coding, ghc is mandatory
02:23:18 <tennin> even the standard monad libraries use features that aren't in the H98 standard (and apparently won't be in/won't be replaced in H' either)
02:29:10 <newsham> ok sleep.  bbl.
02:30:53 <tennin> but I guess instability is sort of encouraging in a language that hasn't yet been widely adopted
02:37:05 <Lemmih> @remember JaffaCake gcc is getting smarter, so we need to hit it with a bigger stick
02:37:26 <Lemmih> @bot
02:37:45 <shapr> newsham: Why not just use Peter Thiemann's Haskell Web Server version with hs-plugins built in?
02:38:54 <shapr> dons: Yeah, irc.haskell.org was pointed to irc.freenode.net for awhile. I dunno if it still is.
02:39:18 <musasabi> Is there a way to get a list of thread states inside GHC?
02:41:29 <JaffaCake> musasabi: you mean in GHCi?
02:41:39 <JaffaCake> or programmatically?
02:42:09 <musasabi> programmatically
02:42:26 <JaffaCake> no, but it would be a useful addition
02:42:56 <JaffaCake> data ThreadStatus; getThreadStatus :: ThreadId -> IO ThreadStatus
02:43:15 <JaffaCake> getAllThreads :: IO [ThreadId]
02:43:33 <musasabi> yes, something like that.
02:44:08 <JaffaCake> submit is as a task, if you like
02:45:10 <musasabi> ok
02:45:49 <musasabi> btw is anyone working on STM? Somekind of commit/rollback hooks would be nice for implementing 2PC.
02:48:36 <musasabi> The printing typeof dynamic exceptions is nice :-)
02:54:25 <pitecus> Is it possible to apply a function and if there is a pattern matching failure, return a value of the same type as the function's return type?
02:54:59 <Muad_Dibber> what is a pattern matching failure?
02:55:44 <pitecus> Non-exhaustive pattern
02:56:01 <Muad_Dibber> You know about the use of "_" ?
02:56:02 <Lemmih> pitecus: Add 'fn _ = ...' to the function?
02:56:16 <shapr> pitecus: myfunction x = error $ "I don't handle" ++ show x
02:56:22 <pitecus> Lemmih, without touching the function
02:57:03 <Lemmih> pitecus: That can't be done without entering the IO monad.
02:57:18 <shapr> I think you need full-on kosmikus-thesis-quality Generic Haskell to add new matches to a function after the fact.
02:58:31 <pitecus> I see
02:59:20 <pitecus> So the only thing you can do with exceptions in haskell is rethrow them?
03:01:54 <Lemmih> pitecus: No, you can catch them.
03:03:32 <araujo> morning
03:04:05 <pitecus> Can you catch an exception in a pure function?
03:04:55 <Lemmih> pitecus: No.
03:06:40 <shapr> pitecus: When it's my code, I just add that fallthrough case that whines about not handling the input.
03:06:58 <shapr> pitecus: Having a default pattern match failure for every function would be a nifty benefit of GH.
03:07:56 <mauke> is there something like class Default a where default :: a ?
03:09:23 <pitecus> Thanks
03:09:43 * blackdog sighs theatrically
03:09:56 <pitecus> Where can I read about Generic Haskell? I never heard of it.
03:10:14 <blackdog> if i google my email address, one of the top links is still a couple of people on here poking vixen. three years of grad school for this?
03:11:15 <blackdog> generic-haskell.org?
03:11:40 <blackdog> @google "generic haskell"
03:12:23 <blackdog> hm, lambdabot not there?
03:12:29 <blackdog> @vixen anything running?
03:12:30 <pitecus> thanks
03:12:45 <blackdog> wow, DOA.
03:12:48 <blackdog> no probs.
03:12:59 <mauke> ?lambdabot?
03:16:55 <Muad_Dibber> @list
03:19:50 <shapr> blackdog: Vixen loves you.
03:28:42 <JaffaCake> Lemmih: ping?
03:29:02 <Lemmih> JaffaCake: pong.
03:29:14 <Lemmih> What did I break this time?
03:29:18 <JaffaCake> Lemmih: did you have a patch to libraries/base to go with the breakpoint patch?
03:29:37 <Lemmih> Oh right.
03:34:05 <Lemmih> JaffaCake: Btw, I'm having trouble compiling GHC after your flattening.
03:34:25 <JaffaCake> what's gone wrong?
03:34:34 <JaffaCake> I'm running nightly builds right now to shake out the bugs
03:36:37 <Lemmih> libraries/base/GHC/PrimopWrappers.hs is empty. I ran 'autoreconf && ./configure && make' from the top-level. Do I need to 'make clean' in libraries/base?
03:37:16 <JaffaCake> there was a subsequent patch to libraries/base, just pull again in there
03:37:27 <blackdog> Cheers shapr.
03:37:29 <JaffaCake> actually do a ./darcs-all pull -a from the top
03:38:23 <tic> JaffaCake, does your nick originate from the refreshing orange beverage, or is it related to Stargate?
03:39:16 <JaffaCake> tic: http://en.wikipedia.org/wiki/Jaffa_Cake
03:39:35 <JaffaCake> they give them out free at Microsoft, I became an addict for a while :)
03:39:39 <tic> JaffaCake, ahhh. Thanks!
03:40:06 <tic> haha
03:45:56 <pejo> JaffaCake, free biscuits for coffee breaks at MS?
03:46:07 <JaffaCake> yup
03:46:15 <JaffaCake> lots of free caffeine, too
03:47:39 <pejo> Hm. In Sweden I can't imagine any job without free coffee, but the sweets aren't that common I think.
03:48:10 <JaffaCake> pejo: here's our coffee machine http://www.flickr.com/photos/sensecam/81975399/
03:50:31 <pejo> JaffaCake, ok, I'm a tad jealous now. :P
03:51:05 <JaffaCake> pejo: we have 3 of those :)
03:52:07 <pejo> JaffaCake, hm, lots of employes in the same division?
03:52:34 <JaffaCake> about 100 or so in this building
03:53:05 <tic> off-topic coreutils question: is there some general-purpose "-exec foo {} bar \;"-style (like find, but not find) application?
03:53:48 <JaffaCake> tic: zsh
03:54:06 <tic> JaffaCake, I don't have zsh lying around, and I heard it's complicated to port. Any other suggestion? :)
03:54:12 <shapr> My coffee machine is not quite as cool as yours - http://www.kaffe.no/traktertest/311002/MelittaAromaboy.htm
03:54:40 <JaffaCake> shapr: nice ;)
03:54:43 <pejo> shapr, sorry, I'd go with MSR if I had to choose. 
03:54:46 * shapr laughs
03:55:17 <tic> maybe xargs takes a -. Hm.
03:55:22 <JaffaCake> maybe it's time for a "haskeller's coffee machines" wiki page
03:55:26 <shapr> The 0.3 liter pot is ... I guess it's enough for a self employed person who lives alone.
03:55:38 <shapr> Yeah, totally.
03:55:43 <pesco> "Aromaboy" souds so... appealing. ;-)
03:56:11 <tic> oh, nm.
03:56:15 <shapr> Well, it's cute and it's small. But when I have visitors I pretty much need to make one pot per visitor.
03:57:01 <shapr> That Cimbali looks like it could be running an embedded GHC :-)
03:57:17 <pesco> shapr: Good Morning btw. What are you up to today?
03:57:25 <shapr> About five foot ten, what about you?
03:57:46 <pesco> shapr: Same as usual. Six I think.
03:57:57 <pesco> shapr: 182cm, iirc.
03:58:12 <shapr> Ah, I'm 170 something.
03:58:42 <pesco> Anyway, on with the coffee machine contest! Sorry for interrupting. ;)
03:59:12 <shapr> pesco: Want to get started on karma-billma?
03:59:16 <shapr> Do you have a darcs repo?
04:00:06 <pesco> shapr: Yeah! I have a darcs repo, but only locally. And the Atomzentrale died last night.
04:00:51 <shapr> Use kakapo?
04:01:31 <pesco> Yup.
04:01:56 <maus> Hello guys
04:02:09 <pesco> shapr: I've already sent email to The Locals, but might be a few hours before they're up.
04:02:42 <maus> is where a way to lift
04:02:44 <maus> Foreign.allocaBytes :: Int -> (GHC.Ptr.Ptr a -> IO b) -> IO b
04:02:51 <maus> into something like
04:03:08 <maus> :: Int ->  (GHC.Ptr a -> ReaderT Env IO b) -> ReaderT Env IO b
04:03:13 <maus> ?
04:03:42 <maus> or maybe i'm doing something wrong?
04:04:33 <shapr> pejo: Any suggestions for a Swedish tech company with a good PE value for stock investing?
04:05:33 <ProfTeggy> google.se
04:06:02 <shapr> Is that a separate company?
04:06:07 <ProfTeggy> Hehe, dunno
04:09:15 <Lemmih> maus: \i fn -> Control.Monad.Reader.ReaderT $ \env -> let fn' ptr = Control.Monad.Reader.runReaderT (fn ptr) env in Foreign.allocaBytes i fn'
04:12:31 <maus> Lemmih: thanks, that helps
04:13:55 <Lemmih> JaffaCake: Now it fails on "forkOn#". GHC/Conc.lhs:152:9: Not in scope: `forkOn#'
04:14:22 <JaffaCake> Lemmih: is it a while since you pulled?
04:14:53 <Lemmih> I just did a './darcs-all pull' a couple of minutes ago.
04:15:14 <JaffaCake> Lemmih: I mean it looks like your build is out of date somewhere
04:15:28 <JaffaCake> the forkOn# primitive was added a couple of weeks ago
04:16:03 <JaffaCake> you might need to make clean in libraries/base
04:16:13 <Lemmih> Okay.
06:08:04 <dozer> hi
06:08:10 <Lemmih> Hiya dozer.
06:10:28 <dozer> time to write my first haskell program...
06:10:58 <dozer> Lemmih: is thre an IDE you use? or you just use emacs or vi?
06:11:52 <Lemmih> I'm using emacs to work on a Haskell IDE (:
06:12:07 <dozer> oh the irony
06:12:57 <neologism> dozer: dont waste time with hello world, its useless :)
06:13:22 <dozer> neologism: lol - I was going to try to write a PI-calculus interpreter
06:13:50 <neologism> what is PI calculus?
06:14:01 <dozer> http://en.wikipedia.org/wiki/Pi_calculus
06:14:11 <dozer> a language for expressing concurrent communications
06:14:16 * neologism wonders if tehre's a calculus for each character of greeks alphabet
06:14:34 * dozer thinks there probably are, and that some are overloaded
06:14:52 <neologism> shit... I recall I studied this calculus last semestr :(
06:15:02 <neologism> obviously not hard enough ;)
06:15:11 <dozer> oh - you're a cs student?
06:15:22 <neologism> jesus.. not last.. THIS semestr
06:15:28 * neologism gives up
06:17:04 <neologism> dozer: most of the people here either study or teach cs I think :)
06:18:08 <dozer> I'm a bioinformatics researcher
06:18:28 <dozer> but getting more into cs theory, 'cause it's fun and lets us tackle much bigger biological questions
06:19:13 <neologism> Iam going to study some bioinformatics next year
06:19:47 <dozer> sweet
06:20:21 <neologism> just to get some basic info.. nothing fancy
06:22:43 <dozer> in bioinformatics, we get to play with very big toys and quite large data-sets
06:22:52 <dozer> not as large as the high-energy physics guys,
06:23:02 <dozer> but we have 1000x the data-types they do
06:29:10 <bolrod> weird
06:29:10 <ProfTeggy> XML!
06:29:21 <bolrod> > inits [1..10]
06:29:33 <bolrod> Yo!
06:29:37 <bolrod> > show "test"
06:29:41 <bolrod> O_o?
06:29:43 <bolrod> @type map
06:29:50 <bolrod> oh noe!  its dead
06:29:51 <bolrod> !
06:33:14 <bolrod> why does  length (inits [1..100000]) take so long!! 
06:34:13 <bolrod> hahaha .. did I just find a better way to write inits?
06:34:14 <bolrod> xD
06:34:18 <bolrod> >:)
06:37:23 <bolrod> ahahahahaha
06:37:25 <bolrod> lawl!
06:40:26 <xerox> Hiya.
06:44:13 <bolrod> yo
06:44:21 <bolrod> why is the inits in the List module so SLOOOOWw
06:46:41 <bolrod> well?
06:46:44 <bolrod> =)
06:46:51 <bolrod> what happened to lambdabot 
06:46:54 <bolrod> @type map
06:46:59 <bolrod> can someone restart it?
06:47:20 <xerox> dons can
06:47:58 <bolrod> aha
06:48:11 <bolrod> xerox: I think I found a better definition for inits....   I guess
06:48:15 <bolrod> not sure though
06:48:32 <bolrod> but the one in the List module that comes with the ghc is AWWWWFully slow
06:48:35 <xerox> ohub, what do you mean?
06:48:40 <bolrod> well.. its slwo
06:48:41 <bolrod> slow
06:48:44 <bolrod> and uses tons of memory
06:50:17 <bolrod> dont you think?
06:51:28 <xerox> Dunno.  Maybe add some details :-)
06:51:56 <bolrod> so.. lets see
06:52:08 <bolrod> length (inits [1..5000])
06:52:08 <bolrod> 5001
06:52:08 <bolrod> (0.56 secs, 451865796 bytes)
06:52:30 <xerox> I mean, the definitions.
06:52:39 <bolrod> the report has
06:52:45 <bolrod> inits                   :: [a] -> [[a]]
06:52:45 <bolrod> inits []                =  [[]]
06:52:46 <bolrod> inits (x:xs)            =  [[]] ++ map (x:) (inits xs)
06:52:59 <bolrod> inits' xn = zipWith (\t l-> t$l) (map take [0..(length xn)]) (repeat xn)
06:53:06 <bolrod> the last one is my definition
06:53:21 <bolrod> and its about 5 times faster
06:53:54 <xerox> inits xs = zipWith ($) (map take [0..length xs]) (repeat xs)
06:54:01 <xerox> It resembles transpose.
06:54:10 <bolrod> the last one doesn't really work
06:54:12 <bolrod> or
06:54:20 <bolrod> you have to switch the map take...  and repeat
06:54:59 <Lemmih> How do you messure its performance?
06:55:03 <bolrod> for one
06:55:10 <flux__> the original version is lazy
06:55:24 <bolrod> it finishes the length in about a fraction of the time
06:55:25 <Lemmih> *measure
06:55:41 <bolrod> and the sum of the sum of the inits is about 4 times faster
06:58:07 <bolrod> length (inits [1..10000])
06:58:07 <bolrod> 10001
06:58:07 <bolrod> (3.35 secs, 1815171412 bytes)
06:58:12 <bolrod> length (inits' [1..10000])
06:58:12 <bolrod> 10001
06:58:12 <bolrod> (0.00 secs, 2914848 bytes)
06:58:26 <bolrod> who doens't agree the 2nd one seems better ?
06:58:52 <sjanssen_> bolrod: how long does "take 10 (inits' [1..])" take?
06:58:53 <xerox> You shouldn't rely on those values I think.
06:59:22 <ProfTeggy> sjanssen ;-)
06:59:23 <bolrod> ohh4
06:59:26 <bolrod> well\
06:59:51 <bolrod> yes
06:59:55 <bolrod> that doesn't work
06:59:56 <bolrod> :)
07:00:10 <sjanssen_> and that is why we use our slower version
07:00:15 <bolrod> I See
07:00:55 <bolrod> but thats because length xn   isn't lazy
07:01:58 <bolrod> lets see if I can fix that then
07:03:30 <bolrod> Ah! 
07:03:34 <bolrod> I think I know a solution
07:06:20 <Lemmih> JaffaCake: How's that nightly build coming along?
07:06:42 <JaffaCake> fixed a couple of problems with the nightly build scripts, and it seems ok now
07:06:47 <dozer> yay! I just printed "Hello World"
07:07:05 <JaffaCake> up to stage 3
07:07:29 <sjanssen_> bolrod: GHC's inits does seem slow
07:08:25 <bolrod> ok...   solved it
07:08:32 <bolrod> almost
07:08:43 <sjanssen_> bolrod: I have a working solution
07:09:24 <bolrod>  take 10 (inits' [1..])
07:09:24 <bolrod> [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8,9]] take 10 (inits' [1..])
07:09:30 <bolrod> yes
07:09:30 <bolrod> me too
07:10:03 <bolrod> length (inits' [1..5000])
07:10:03 <bolrod> 5001
07:10:04 <bolrod> (0.01 secs, 2424344 bytes)
07:10:11 <bolrod> I just made the repeat lazy
07:10:17 <bolrod> well
07:10:18 <bolrod> erh
07:10:37 <bolrod> a repeat that only repeats the list the amount of times the list is long
07:10:56 <bolrod> and then removed the length xn  from the take [1..]
07:10:58 <bolrod> :)
07:11:22 <bolrod> length (inits' [1..5000000])
07:11:22 <bolrod> 5000001
07:11:23 <bolrod> (5.23 secs, 962337168 bytes)
07:11:29 <bolrod> does yours do any better ? ;)
07:13:37 <sjanssen_> mine took longer, but I'll have a better one in a second
07:13:40 <bolrod> sum$ map sum (inits' [1..5000])
07:13:40 <bolrod> 20845835000
07:13:40 <bolrod> (3.26 secs, 603990312 bytes)
07:13:40 <bolrod> *Lists List> sum$ map sum (inits [1..5000])
07:13:40 <bolrod> 20845835000
07:13:42 <bolrod> (16.41 secs, 905450520 bytes)
07:13:45 <bolrod> this seems like a pretty good improvement
07:18:13 <bolrod> haha...  and to think that I thought my implementation would be way slower probably
07:18:19 <bolrod> :)
07:18:29 <dozer> what is inits meant to do?
07:18:43 <bolrod> urh
07:18:45 <bolrod> I dunno
07:18:47 <bolrod> xD
07:18:48 <bolrod> ;)
07:19:03 <bolrod> inits [1,2,3,4,5]
07:19:03 <bolrod> [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
07:19:04 <sjanssen_> > inits [1..4]
07:19:04 <bolrod> that
07:19:19 <bolrod> sjanssen_: lambdabot seems to be having a hangover or something\
07:19:39 <sjanssen_> can I see your latest version of inits?
07:19:45 <xerox> NDA.
07:19:51 <bolrod> hrmm... :)
07:20:02 <bolrod> let me think ;)
07:20:13 <bolrod> inits' xn = zipWith (\t l-> t$l) (map take [0..]) (until' xn xn) where until' list repeat = case list of [] -> [repeat] ; (_:xs) ->  repeat : until' xs repeat
07:20:41 <bolrod> trick is... until' wont search to the end of an infinite list
07:20:47 <bolrod> but just repeats it when its asked to..
07:21:05 <sjanssen_> yeah, that's exactly my first attempt
07:21:06 <bolrod> hello robokop :)
07:21:11 <bolrod> cool =)
07:21:28 <bolrod> so there we have the next version of inits :D!
07:21:33 <bolrod> >:)
07:23:10 <bolrod> damn... I didn't expect my definition to be better then the one in the prelude O_O!
07:23:17 <bolrod> I was just practicing some haskell
07:23:18 <bolrod> haha
07:24:37 <bolrod> I hope they are going to ask to write a version of inits on my test >:)\
07:24:39 <bolrod> MUAHAHAHA
07:24:44 <bolrod> -.-
07:25:52 <bolrod> sjanssen_: so.. can it be implemented in the prelude?
07:26:09 <bolrod> who maintains the prelude?
07:26:17 <bolrod> or.. the standard modules
07:26:26 <sjanssen_> well, in GHC inits is found in Data.List
07:27:07 <bolrod> yes
07:27:28 <bolrod> I noticed I wrote prelude after I hit enter :)
07:28:02 <sjanssen_> the maintainer is listed as libraries@haskell.org, so you should just send your definition to the libraries mailing list
07:30:52 <bolrod> hmm
07:30:53 <bolrod> weird
07:31:01 <bolrod> my implementation does use more reductions and cells in hugs
07:31:21 <sjanssen_> how is the wall clock time?
07:31:27 <bolrod> ?
07:31:41 <bolrod> what does that mean?
07:32:03 <sjanssen_> I've heard that reductions is a bad measurement.  I meant measure the actual time it takes as a benchmark
07:32:12 <bolrod> oh
07:32:25 <bolrod> in ghc its WAY faster
07:32:37 <bolrod> I posted it somewhat more above
07:33:32 <bolrod> *Lists> sum $ map sum (inits [1..2000])
07:33:34 <bolrod> 1335334000
07:33:34 <bolrod> (1.90 secs, 149004344 bytes)
07:33:34 <bolrod> *Lists> sum $ map sum (inits' [1..2000])
07:33:34 <bolrod> 1335334000
07:33:36 <bolrod> (0.55 secs, 97579184 bytes)
07:33:43 <bolrod> so... about.. 4 times faster
07:34:10 <bolrod> seems the bigger the lists get
07:34:17 <bolrod> the slower the inits in List get
07:34:20 <bolrod> gets*
07:34:43 <bolrod> what do the bytes mean?
07:34:46 <bolrod> the amount of RAM used?
07:34:53 <bolrod> I guess not eh
07:35:00 <sjanssen_> I have no idea
07:35:01 <bolrod> or the amount of data processed?
07:35:10 <sjanssen_> probably bytes garbage collected
07:36:38 <bolrod> *Lists> sum $ map sum (inits [1..6000])
07:36:38 <bolrod> 36018002000
07:36:38 <bolrod> (29.56 secs, 1302732768 bytes)
07:36:38 <bolrod> *Lists> sum $ map sum (inits' [1..6000])
07:36:38 <bolrod> 36018002000
07:36:40 <bolrod> (6.63 secs, 869197348 bytes)
07:36:43 <bolrod> (last time) ;)
07:36:58 <bolrod> 1.3GB of garbage collecting.. is signifficant!
07:37:12 <cmarcelo> bolrod, how are you getting this timings in ghci?
07:37:16 <bolrod>  :set +s
07:39:00 <bolrod> well... how hard can it be to find more functions that are awfully slow :)
07:39:01 <bolrod> hehe
07:40:33 <bolrod> ohyeah... the inits in the List module isn't really lazy
07:40:44 <bolrod> since its going to build an awful lot
07:40:49 <bolrod> so when you ask the length
07:40:57 <bolrod> its going to build a HUGE expression
07:41:14 <CosmicRay> shaaaaaaapr.........
07:41:22 <xerox> @get-shapr
07:41:22 <CosmicRay> scannedinavian.org is down
07:41:46 <bolrod> since its going to use map an awfull lot of times :)
07:42:12 <CosmicRay> JaffaCake: how has darcs been working out for fptools, btw?
07:42:42 <JaffaCake> I like it a lot, I think Simon PJ still has some coming around to do :)
07:43:10 <CosmicRay> that's good to hear.  is there anything I can do to help him?
07:43:15 <JaffaCake> our #1 problem is the performance problems with 'darcs changes <file>'
07:43:40 <CosmicRay> ah.  are you using -s with changes?
07:43:49 <CosmicRay> actually that probably doesn't matter when you're working on a single file.
07:43:59 <JaffaCake> yeah, doesn't make any difference
07:43:59 <CosmicRay> have you mentioned that to the darcs folks?
07:44:19 <JaffaCake> yep, got a feature request open on it - I think they regard it as a fairly high priority
07:44:26 <CosmicRay> the problem is that it'll be opening up each individual patch, which are stored in individual files, to figure out which ones apply to a file.
07:44:34 <JaffaCake> yes
07:44:43 <JaffaCake> hang on, I'll dig up the ticket
07:45:10 <sjanssen_> bolrod: inits' xn = zipWith take [0..] $ map (const xn) xn
07:45:22 <shapr> xerox: ?
07:45:30 <bolrod> sjanssen_: faster still?
07:45:35 <shapr> CosmicRay: What do you want from ScannedInAvian.org?
07:45:40 <sjanssen_> bolrod: on my machine
07:45:42 <xerox> shapr, dunno, CosmicRay was shouting at you
07:45:43 <CosmicRay> shapr: lemmih's FilePath repo
07:46:37 <CosmicRay> JaffaCake: otoh looking at changes over the entire repo should be many times faster than CVS.  might not mean much with your usage patterns, but I like it.
07:46:45 <Lemmih> CosmicRay: darcs.haskell.org/~lemmih/FilePath
07:46:51 <shapr> CosmicRay: Try http://darcs.haskell.org/~lemmih/
07:46:58 <bolrod> sjanssen_: it dont work
07:47:02 <bolrod> length (inits2' [1..10000])
07:47:02 <bolrod> 10000
07:47:02 <bolrod> (0.00 secs, 0 bytes)
07:47:02 <CosmicRay> ah, thanks Lemmih/shapr
07:47:07 <bolrod> one is missing
07:47:08 <bolrod> ;)
07:47:09 <JaffaCake> CosmicRay: yes
07:47:16 <CosmicRay> Lemmih: is that code the same that's in Distribution.Cabal?
07:47:21 <sjanssen_> bolrod: bah!
07:47:22 <Lemmih> CosmicRay: Yes.
07:47:41 <bolrod> but yes
07:47:43 <bolrod> its a bit faster
07:48:11 <bolrod> not alot though
07:48:13 <bolrod> oh
07:48:15 <bolrod> it is alot
07:48:16 <bolrod> haha
07:48:34 <JaffaCake> CosmicRay:  http://bugs.darcs.net/issue124
07:49:10 <sjanssen_> bolrod: hacky fix inits' xn = zipWith take [0..] $ map (const xn) $ undefined:xn
07:49:30 <CosmicRay> Lemmih: I had also integrated FilePath into MissingH awhile back, before Cabal was part of fptools.  Do you believe that FilePath is now a standard part of every Haskell environment, and thus I ought to remove it from MissingH, or is there some reason I ought to keep it in MissingH as well?
07:49:37 <bolrod> what does const xn do ?
07:50:04 <CosmicRay> JaffaCake: out of curiosity, are you running darcs changes on a linux or a windows box?
07:50:15 <JaffaCake> either
07:50:24 <sjanssen_> const :: a -> b -> a -- a function that always returns it's first argument
07:50:36 <CosmicRay> the other thing that could be slowing things is that the patches are gzipped
07:51:00 <CosmicRay> I wonder if you run darcs optimize --uncompress, and then run your darcs changes again, if it would be any faster.
07:51:08 <bolrod> oeh
07:51:36 <bolrod> oeh with the sum  mine is about just as fast as yours
07:51:36 <bolrod> :)
07:52:53 <bolrod> with calculating the length.. yours is Definately faster
07:53:05 <sjanssen_> they should perform nearly the same, I just pruned some things out of yours
07:53:14 <bolrod> ah :)
07:53:37 <bolrod> yeah... I didn't know the const function :)
07:54:21 <bolrod> and ofcourse.. some other things 
07:54:36 <bolrod> but its also ALOT cleaner then the one in the List module
07:54:42 <Lemmih> CosmicRay: Standard part of every Haskell environment?
07:55:12 <CosmicRay> Lemmih: as in, ships with ghc, hugs, and nhc98 and will do so for the forseeable future?
07:57:42 <JaffaCake> FilePath isn't available as standard anywhere, AFAIK
07:57:48 <Lemmih> CosmicRay: It doesn't now and I hope it never will. I'm not a fan of a large set of standard libraries.
07:59:13 <JaffaCake> I disagree
08:01:32 <CosmicRay> JaffaCake: it may not be a standard, but http://www.haskell.org/ghc/docs/latest/html/libraries/index.html lists it
08:01:38 <CosmicRay> and it's available in ghc and hugs at least.
08:02:17 <JaffaCake> hmm, that's unintentional
08:02:21 <Lemmih> Maybe it should be included in 'base' but wouldn't want to see it as an independent package.
08:02:22 <CosmicRay> Lemmih: well there are some really important things that are missing from the haskell standard libraries (and some that are even missing from filepath).  functions such as abspath, basename, etc.
08:02:53 <bolrod> sjanssen_: k cool :)  your function was exactly what I wanted to do.. only didn't know how
08:03:06 <bolrod> sjanssen_: do you also know a function like..   iterate
08:03:17 <CosmicRay> 90% of the stuff in FilePath is really very useful to have
08:03:19 <bolrod> only stops when the next answer it produces is the same as the last one?
08:03:25 <CosmicRay> for general-purpose coding
08:03:37 <JaffaCake> CosmicRay: please don't rely on Distribution.Compat.FIlePath, it should be private to Cabal
08:03:44 <CosmicRay> JaffaCake: understood
08:03:49 <bolrod> basically.. take that stops when the next element is the same as the last one
08:04:01 <JaffaCake> in fact it's hidden in GHC 6.5
08:04:19 <CosmicRay> JaffaCake: I just sent you a reply regarding exceptions...  does that make sense or am I missing something blindingly obvious?
08:04:37 * JaffaCake checks
08:06:37 <JaffaCake> CosmicRay: I don't understand what you want to do - if you could extend the ArithException type, then exsting handlers for ArithException wouldn't understand your new exception, would they?
08:07:33 <CosmicRay> they wouldn't understand the special new properties of it
08:07:43 <CosmicRay> but they would be able to handle it just the same as they could handle an ArithException
08:08:04 <CosmicRay> for instance, in Python, I could just "class MulByZeroException(ArithException)" and define my new exception
08:08:09 <CosmicRay> I can raise that exception
08:08:14 <sjanssen_> bolrod: there's Data.List.iterate that does [x, f x, f (f x), ...].  but you have to write the termination yourself
08:08:21 <CosmicRay> any handler that can handle an ArithException could also, automatically, handle my new exception.
08:08:36 <CosmicRay> but I could also write a handler that specifically checks for a MulByZeroEXception.
08:08:49 <bolrod> sjanssen_: ah.. I know iterate.. I just wanted the termination :)
08:08:57 <JaffaCake> ok, so actually you want to add extra information to an ArithException, make a subtype of ArithException in other words
08:09:02 <bolrod> I'll think of something
08:09:04 <CosmicRay> it may not actually have new data fields or methods over ArithException, but could be useful to categorize it separately for code that groks it, and have it handled as a ArithException more generally
08:09:10 <CosmicRay> JaffaCake: yes
08:09:17 <CosmicRay> Java works the same way, BTW.
08:09:25 <CosmicRay> one of the few things that Java does in a useful fashion, IMHO :-)
08:09:48 * Philippa nods
08:10:29 <JaffaCake> I'm not sure this case is terribly useful... how many times do you catch ArithException and don't look at it?
08:10:56 <CosmicRay> JaffaCake: so to sum it up... the great advantage of this is that existing code (mine or 3rd-party) can handle this exception in a sane way given its general "type".  Or it can catch a more specific type.
08:11:07 <CosmicRay> JaffaCake: well the exception itself may, for instance, have a String for an error message.
08:11:28 <CosmicRay> but there are plenty of times when I catch exceptions without looking at them.
08:11:35 <JaffaCake> all exceptions can be converted to String
08:11:51 <JaffaCake> yes, but don't you just re-throw them?
08:11:52 <CosmicRay> for instance I sometimes want to just ignore any I/O error over something, but not ignore any other errors.
08:12:01 <CosmicRay> nope, sometimes I just eat them.
08:12:41 <JaffaCake> ok, there *is* a way to do it
08:13:20 <JaffaCake> but it means adding a type parameter to ArithException, IOException etc., so you can subtype them
08:13:52 <CosmicRay> right, that could do most of what I want if designed well.
08:14:11 <CosmicRay> but what if, say, HSQL didn't add that type parameter and I wanted to subtype SqlException?
08:14:21 <CosmicRay> perhaps there is just no way to do that with Haskell's type system, which is fine.
08:14:30 <JaffaCake> well Haskell doesn't have subtyping in general, sorry :)
08:14:33 <CosmicRay> but it's the one thing I miss from Python all the time.
08:14:51 <CosmicRay> JaffaCake: pfft, what have you been working on all these years? ;-)
08:15:11 <CosmicRay> but yeah, I understand that.
08:15:27 <JaffaCake> with classes you can get something similar to subtyping over sum types, which is what the ExtensibleExceptinos proposal does.  What you're after is subtyping over product types too, which you can usually mimic with parameterised types
08:17:03 <JaffaCake> hmm, I suppose we could make ArithException a class too, that probably fixes is
08:17:07 <JaffaCake> s/is/it
08:17:27 <CosmicRay> could all exceptions be classes?
08:18:12 <JaffaCake> well, you need actual types at the leaves, but all the 'categories' of exceptions could be classes, yeah
08:18:26 <CosmicRay> hmm. hmm....
08:18:34 <CosmicRay> that would be an improvement.
08:18:53 <CosmicRay> in java and python, any exception could effectively be a leaf or a branch (category)
08:19:14 <JaffaCake> urk, I'm not sure it works
08:19:34 <JaffaCake> because you'd have instance IOException a => Exception a
08:19:48 <JaffaCake> which overlaps
08:24:39 <Igloo> Couldn't you have class Exception a => IOException a instead?
09:00:17 <Pegazus> what's currification? to do a -> b -> c     (a, b) -> c or what?
09:01:06 <zellyn> Pegazus: a -> b -> c     ==    a -> (b -> c)
09:01:06 <sjanssen_> @type curry
09:01:21 <sjanssen_> zellyn: that isn't right
09:01:32 <zellyn> no?
09:01:40 <sjanssen_> curry means to change (a, b) -> c into a -> b -> c
09:01:47 <zellyn> aah
09:02:07 <zellyn> Whereas 'everything in haskell is automatically curried' means what I said?
09:02:20 <Cale> a -> b -> c means a -> (b -> c) since -> is right associative
09:03:16 <Pegazus> thanks :)
09:03:31 <palomer> refinement types rock!
09:03:34 <sjanssen_> as a historical note, we get the term from the mathematician Haskell Curry
09:03:44 <Pegazus> i knew that
09:03:55 <Pegazus> so
09:04:02 <Pegazus> how to curry a function?
09:04:21 <zellyn> Just leave off right-hand arguments.
09:04:25 <Cale> Everything in Haskell is automatically curried is something like saying that a function definition of the form "f x1 x2 ... xn = ..." defines a function f :: t1 -> t2 -> ... -> tn -> s, where xi :: ti.
09:04:32 <sjanssen_> well, Curried functions are the standard in Haskell
09:04:38 <Pegazus> but how it would be non curried?
09:04:48 <Cale> To get uncurried functions, you have to use tuples
09:05:06 <Cale> f (x,y) = x + y is an uncurried function
09:05:08 <palomer> tuples are evil
09:05:15 <palomer> generalized tuples are great
09:05:17 <Cale> and yes, tuples are evil :)
09:05:27 <Cale> generalised tuples?
09:05:41 <Pegazus> so
09:05:51 <palomer> Cale: tuples faked with GADTs
09:06:25 <Pegazus> a -> b -> c -> d is the curry form of (a, b, c) -> d ? or of (a -> b -> c) -> d ?
09:07:03 <Cale> the former
09:07:43 <Pegazus> thanks :)
09:09:44 <Pegazus> does anyone has a syntaxis highlighting definition for textpad?
09:10:31 <palomer> http://www.rafb.net/paste/results/Q7xiGi62.html <--generalized tuples, if anyone cares
09:11:09 <palomer> GADTs are cool if only for the fact that tuples become more powerful and are purely syntactic sugar
09:11:27 <palomer> you can, for example, write a function which converts any tuple to a list
09:12:19 <palomer> but wait, palomer, you used pairs in there!
09:12:48 <palomer> data Pair a b = Pair a b
09:12:53 <Pegazus> what was the option for haskell to show any type with the way it's constructed?
09:13:18 <Cale> deriving (Show)
09:13:33 <Pegazus> there was an option in hugs
09:14:02 <Pegazus> @type map (+) [1.0, 2.0, 3.0]
09:14:07 <Pegazus> @type (map (+) [1.0, 2.0, 3.0])
09:14:20 <zellyn> Anyone familiar enough with "The Haskell Programmer's Guide to the IO Monad" to answer a specific question?
09:14:22 <Pegazus> why's the type of that [Double -> Double]
09:14:23 <Pegazus> ??
09:14:46 <sjanssen_> palomer: why do you need GADTs for this?
09:14:52 <Cale> Pegazus: why wouldn't it be?
09:15:00 <palomer> sjanssen: notice the definition of TupleCons
09:15:06 <Cale> Pegazus: you're applying (+) to each of the Doubles
09:15:22 <sjanssen_> oh, I see, to enforce that there isn't garbage in the right half
09:15:32 <Pegazus> shouldnt (+) add them?
09:16:02 <palomer> rather, to keep all type information pertaining to the elements of the generalized tuple
09:16:08 <Cale> Pegazus: map (+) [1.0, 2.0, 3.0] = [(+) 1.0, (+) 2.0, (+) 3.0]
09:16:19 <Pegazus> thanks Cale
09:16:22 <sjanssen_> zellyn: go ahead and ask
09:16:30 <palomer> with gadts you could also write a function from any generalized tuple to a tuple of one size less!
09:16:38 <Cale> zellyn: I don't know that book, but yeah, ask away :)
09:16:45 <palomer> (it's a one liner)
09:17:07 <Cale> palomer: hehe, what if it's a GTuple () ?
09:17:19 <sjanssen_> palomer: a simple data type does the same
09:17:22 <zellyn> On the first page of the "Monads" chapter, they make the observation that the inverse natural transformation for a Monad maps from F2 to F.
09:17:40 <palomer> Cale: well, it depends on the type system
09:17:47 <zellyn> And that requiring it to map from F to I would be "too restrictive"
09:17:47 <Cale> zellyn: the join, yes
09:17:54 <Pegazus> nice
09:17:57 <zellyn> That makes sense, in a sort of intuitive way.
09:18:08 <sjanssen_> your GTuples are just like HLists, but with an extra requirement that the tail is a valid tuple
09:18:08 <palomer> Cale: you could encode that this is not possible with my type system
09:18:09 <Pegazus> head(map (+) [1.0, 2.0, 3.0]) 0 is of type double :p
09:18:15 <palomer> but you can't in haskell's type system
09:18:16 <palomer> :(
09:18:39 <palomer> sjanssen: got a link?
09:18:41 <zellyn> But in their example, for which they use the "set" category, they suddenly make a jump from talking about sets to talking about elements of sets, and I can't follow that one step.
09:18:53 <Cale> zellyn: can you quote it?
09:18:57 <palomer> HLists = [] ?
09:19:01 <sjanssen_> http://homepages.cwi.nl/~ralf/HList/
09:19:03 <Cale> Join in the set monad is just union
09:19:13 <zellyn> Let's see.
09:19:28 <Cale> e.g. join {{1,2},{2,3,4},{1,3},{5}} = {1,2,3,4,5}
09:19:35 <sjanssen_> basic idea behind HList: data HCons a b = HCons a b; data HNil = HNil
09:20:37 <Cale> I should perhaps say 'Powerset monad', since it's really the powerset functor.
09:21:17 <Cale> er, hmm...
09:21:19 <Cale> :)
09:21:46 <zellyn> "Consider the set category S and the list endofunctor L.  Any transformation e from L to Is (I sub S) has to map every object A to a morphism e-sub-A, which in turn maps the empty list to some element in A."
09:21:57 <palomer> sjanssen: try writing a function which transforms any HList into a normal list with that
09:22:22 <palomer> oh wait, it would work
09:22:31 <palomer> so how is this different from my generalized tuples?
09:22:33 <sjanssen_> I could, with a typeclass
09:22:43 <palomer> ah, righto, you need a type class
09:22:52 <palomer> (whereas with GADTs you don't)
09:23:08 <sjanssen_> palomer: I can construct this: HCons 'a' "this is bad because there should be a HNil here"
09:23:17 <Pegazus> map (+) [1.0, 2.0, 3.0] == [(+) x | x <- [1.0, 2.0, 3.0] ] why does it ends beeing 1 + 2 + 3  +something more?
09:23:36 <Cale> Pegazus: hm?
09:23:48 <Cale> Pegazus: you're not folding here, just mapping
09:23:56 <palomer> se the GADTed version is strictly more powerful
09:24:11 <Cale> zellyn: hmm...
09:24:18 <sjanssen_> however, the HList encoding can be made just as powerful
09:24:20 <Pegazus> how to make comments on haskell?
09:24:22 <Cale> zellyn: I'm not completely sure about their notation
09:24:27 <zellyn> yeah.
09:24:45 <CrewdenX> Pegazus: -- ?
09:24:55 <palomer> sjanssen: but you can put garbage in hlists!
09:24:59 <sjanssen_> you can make the HCons constructor abstract, and then provide a cons function, that uses classes to enforce the structure
09:25:43 <Pegazus> ahhhh got it
09:25:45 <Pegazus> sorry :)
09:26:16 <zellyn> Cale: they're basically explaining why join for lists maps from [[a]] to [a] instead of from [a] to a.
09:26:36 <Pegazus> f (g x) == f.g x isn't it?
09:26:41 <Cale> zellyn: but I think what they're trying to say is that if A is some set, then LA is the set of lists of elements of A, and if we applied some natural transformation L -> I, where I is the identity functor, then LA would get mapped to A somehow. But [] is an element of LA, and it has to be sent to some element of A
09:26:41 <zellyn> Cale: but I don't follow their logic exactly.
09:27:13 <Cale> But there's no natural way to do this
09:27:17 <Cale> what's worse...
09:27:22 <Cale> Choose A to be the empty set
09:27:24 <palomer> sjanssen: what would be the type of HTail?
09:27:27 <zellyn> Cale: I think that makes sense.
09:27:31 <Cale> then LA still has [] as an element
09:27:37 <Cale> but there's nothing to send it to in A
09:27:40 <palomer> HList -> HList ?
09:27:51 <sjanssen_> HList is a class, not a type
09:28:05 <sjanssen_> htail :: HList a b -> b
09:28:28 <palomer> hrmph, interesting
09:28:34 <sjanssen_> oops, error there: htail :: HCons a b -> b
09:28:42 <Pegazus> what's wrong about ej2b = map (2+).(8*) [1,2,3] ?
09:29:16 <palomer> and the type of the function which takes any tuple to the corresponding list?
09:29:23 <palomer> err, any HList
09:29:27 <Cale> you'd want  map ((2 +) . (8 *)) [1,2,3]
09:29:31 <Pegazus> oh
09:29:35 <Pegazus> thanks Cale :)
09:29:38 <zellyn> Cale: that makes sense.  I think I misunderstood, and took it to mean that the category we were dealing with was a category where each object was a set.
09:29:47 <Pegazus> is the "white space" neccesary?
09:29:51 <Pegazus> or optional?
09:29:54 <zellyn> Cale: rather than the category where each object is a member of a set.
09:29:54 <sjanssen_> palomer: it'd be in a type class, I can write it quick if you'd like
09:30:01 <Cale> zellyn: well, that's true -- they're working in the category of sets
09:30:12 <Cale> and set functions
09:30:25 <palomer> sjanssen: you don't know the type off-hand?
09:30:43 <Cale> Those sets have elements which may be considered when deciding whether there are functions between them
09:30:49 <Pegazus> how do you put comments on the haskell source code?
09:31:20 <boy> is there a haskell gollosary page?
09:31:21 <palomer> and what would be the type of append? 
09:31:22 <zellyn> Cale: that makes sense.
09:31:32 <zellyn> Cale: thanks.
09:31:37 <Cale> Pegazus: -- followed by a non-symbol character, or between {- and -}
09:32:07 <Cale> With -- I recommend putting a space after
09:32:23 <Cale> Note that --> is an infix operator.
09:32:27 <astrolabe> spaces cost money you know
09:32:39 <Pegazus> infix operator?
09:32:41 <Pegazus> thanks
09:33:01 <Cale> Yeah, you can define any infix operators you like, composed entirely of symbol characters
09:33:14 <Cale> For example
09:33:43 <Cale> > let xs .+. ys = zipWith (+) x y in [1,2,3] .+. [3,2,1]
09:33:56 <Cale> oh, lambdabot seems dead
09:34:01 <Pegazus> no idea what that means
09:34:11 <Cale> > let xs .+. ys = zipWith (+) x y in [1,2,3] .+. [3,2,1]
09:34:14 <mbot>  Not in scope: `y'
09:34:18 <Cale> > let xs .+. ys = zipWith (+) xs ys in [1,2,3] .+. [3,2,1]
09:34:21 <mbot> [4,4,4]
09:34:48 <palomer> brb
09:35:04 <astrolabe> I think they should let infix operators be anything as long as it starts with a  symbol, and allow symbols in other things as long as they aren't the first element.  It would be more orthogonal and more flexible.
09:35:08 <Cale> > let x @#! y = x ++ y in "Hello, " @#! "World"
09:35:13 <mbot> "Hello, World"
09:35:36 <Cale> astrolabe: infix operators would then have to be separated from their arguments by spaces
09:35:46 <astrolabe> good point
09:36:04 <Cale> which may be the right thing to do, and I wouldn't mind it too much, except with ^
09:36:30 <astrolabe> I wonder which scheme has the highest information rate.
09:36:48 <Cale> Having to type x ^ 2 + 1 rather than x^2 + 1 would get irritating :)
09:37:12 <astrolabe> true
09:39:18 <pierre-> hello. 
09:40:04 <palomer> I don't think x ^ 2 is that annoying, really
09:40:49 <ndm> i do mind
09:41:01 <ndm> x*3 + 2
09:41:13 <Cale> 3*x + 2
09:41:14 <ndm> there teh spacing shows the evaluation order better, which helps
09:41:27 <Cale> yeah
09:41:28 <CosmicRay> how can I use the null character (\000) in a regex pattern in Haskell?
09:41:48 <Igloo> Like that
09:41:50 <ndm> of course, x+2 * 3, is very handy for persuading people the wrong thing for hidden meanings
09:41:51 <Igloo> of \NUL
09:42:02 <CosmicRay> mkRegex says "error in pattern" when the null chracter is in the pattern literally
09:42:04 <Cale> CosmicRay: I think the Regex library uses C strings at some point, so perhaps there's a problem there
09:42:07 <palomer> sjanssen: ping?
09:42:11 <CosmicRay> that is, (mkRegex "\000") is invalid
09:42:23 <Cale> Perhaps try \\0
09:42:24 <Igloo> Oh, it might not be allowed bue to it being passed as a C string
09:42:29 <CosmicRay> and (mkRegex "\\000") -- which uses a four-character string passed to it -- also doesn't help.
09:42:41 <sjanssen_> palomer: I wrote it, but you have to give an explicit type signature, "toList (HCons 'a' HNil) :: [Char]"
09:43:08 <sjanssen_> there's probably some fundep trick I can do here, but I'm not that clever with classes
09:43:18 <Cale> CosmicRay: Perhaps consider switching to a Parsec-based regex library?
09:43:34 <Cale> There are mostly interface-compatible ones
09:43:35 <palomer> sjanssen: so what's the type?
09:43:37 <Pegazus> what does (\x -> (x+1)/2) means?
09:43:56 <Cale> > (\x -> (x+1)/2) 5
09:43:57 <sjanssen_> class ToList container typ where toList :: container -> [typ]
09:43:58 <Igloo> "the function that takes an argument x and returns (x+1)/2"
09:43:58 <mbot> 3.0
09:43:59 <CosmicRay> Cale: yeah, I might, I'm just writing some regexp utilities here.
09:44:30 <Cale> http://sourceforge.net/projects/lazy-regex
09:44:35 <palomer> toList is a class?
09:44:44 <palomer> oh, nevermind
09:44:53 <sjanssen_> ToList is the class, toList is a member thereof
09:44:57 <palomer> sjanssen: don't you think this encoding is a little...awkward?
09:45:07 <Pegazus> Igloo thanks
09:45:09 <sjanssen_> yeah, it is
09:45:16 <palomer> sjanssen: what about append?
09:45:19 <Pegazus> and what does the \x means?
09:45:32 <sjanssen_> append is in the HList paper
09:46:31 <palomer> class ToList container typ where toList :: container -> [typ] <---what's the instance for HList?
09:47:17 <sjanssen_> there is no instance for HList (it's a class), the instance for HCons is:
09:47:19 <zellyn> Pegazus: it's the closest you can get to a "lambda" character on a normal keyboard.
09:47:33 <boy> Data.Array is a real array?
09:47:34 <sjanssen_> instance (ToList tail typ) => ToList (HCons typ tail) typ where toList (HCons x xs) = x : toList xs
09:48:39 <palomer> ahh, gotcha
09:48:41 <sjanssen_> palomer: can you write the toList function with GADTs?
09:48:47 <palomer> oh, easily
09:49:06 <zellyn> Pegazus: http://en.wikipedia.org/wiki/Lambda_function
09:49:37 <zellyn> Pegazus: oops
09:49:37 <palomer> toList TupleNil = [] ; toList TupleCons a b = a : (tupleCons b)
09:49:48 <zellyn> Pegazus: wrong page.  That's a different function.
09:49:54 <palomer> you can't write an append function, though
09:50:05 <Pegazus> k
09:50:33 <palomer> well, you can if you extend the GADT a little
09:50:57 <palomer> but things start to get a little awkward
09:51:00 <zellyn> Pegazus: have you used lambda functions in scheme or lisp or python, or anonymous functions in C#?
09:51:37 <zellyn> Pegazus: here's the page I meant: http://en.wikipedia.org/wiki/Lambda_calculus
09:51:42 <sjanssen_> palomer: that code doesn't work over here
09:52:02 <boy> if i have a Data.Array with Maybe Word8, how many bytes will each element of the array be?
09:52:25 <palomer> sjanssen: type error?
09:52:59 <sjanssen_> yeah, "Inferred type is less polymorphic than expected"
09:52:59 <pitecus> How do I import modules in ghci?
09:53:17 <palomer> ah, right, you need polymorphic recursion
09:53:23 <xerox> pitecus, :module + Name
09:53:29 <xerox> pitecus, or :m + ..
09:53:34 <palomer> sjanssen: explicitly add the type
09:53:40 <pitecus> thanks xerox 
09:53:46 <xerox> You're welcome.
09:53:48 <palomer> which ghc?
09:53:54 <sjanssen_> umm, what type should toList have?
09:53:54 <xerox> pitecus, :help for insights
09:54:14 <palomer> sjanssen: GTuple (a,b) -> [a]
09:54:15 <sjanssen_> I have the latest stable version
09:54:21 <pitecus> :-)
09:54:25 <Pegazus> what's the function that takes 2 arguments and returns a (a, b) with both arguments?
09:54:37 <xerox> Pegazus, (,)
09:54:41 <Pegazus> thanks
09:54:54 <Pegazus> and the other way around?
09:55:09 <sjanssen_> palomer: still doesn't work.  the type you gave me doesn't express that b must be a tuple filled with type a.
09:55:26 <palomer> yeah, I guess you can't have a toList function without a typeclass
09:55:28 <palomer> bummer
09:55:54 <palomer> well, you could define a heterogeneous typeclass
09:56:24 <palomer> the append function in the paper boggles my mind
09:57:05 <sjanssen_> right, some of this is serious type hackery (Oleg is listed as coauthor, so that's a given)
09:57:26 <palomer> bah, who'd want to convert a GTuple to a list anyhow?
09:57:33 <palomer> I'd rather convert a GList !
09:59:04 <sjanssen_> GTuple already is a GList
09:59:21 <palomer> GList would be heterogeneous
09:59:29 <palomer> HList looks more like a tuple to me
09:59:52 <sjanssen_> oh
10:00:10 <palomer> http://www.rafb.net/paste/results/YHWdYC66.html <--GList
10:00:32 <palomer> GList is much safer than any old list
10:00:48 <palomer> (it should be called CList)
10:00:53 <palomer> in fact, I think I'll call it CList
10:01:37 <Pegazus> i'm trying to make a function that takes a non curried functions and returns the equivalent curried
10:01:38 <Pegazus> ((a, b) -> c) -> (a -> b -> c)
10:01:38 <Pegazus> curry f = (f . (,))
10:01:52 <xerox> ?type uncurry
10:01:56 <Pegazus>  ((a, b) -> c) -> (a -> b -> c) is giving me error:  Syntax error in input (unexpected `->')
10:02:02 <xerox> Hm?
10:02:08 <Pegazus> what?
10:02:09 <xerox> It should be
10:02:15 <xerox> (f .) . (,)
10:02:25 <Pegazus> why (f .) ?
10:02:36 <xerox> Try unrolling the expression applying the args
10:02:49 <Pegazus> i don't understand this "Try unrolling the expression applying the args"
10:02:53 <Pegazus> can you rephrase it please? :)
10:03:05 <xerox> \f -> (f .) . (,)
10:03:20 <xerox> And you know that: f . g = \x -> f (g x)
10:03:34 <Pegazus> what's the \ for?
10:03:36 <xerox> (f .) is our 'f', (,) our 'g'
10:03:51 <xerox> It's just a way to emphasize the x argument
10:04:11 <xerox> f . g = \x -> f (g x)  is equal to  (f . g) x = f (g x)
10:04:20 <sjanssen_> palomer: umm, that GList doesn't work
10:04:21 <xerox> But I always think the latter is harder to read.
10:04:23 <sjanssen_> anyway, I have to go
10:04:29 <xerox> Are you still with me?
10:04:34 <Pegazus> emmm
10:04:39 <Pegazus> more or less :p
10:04:52 <Pegazus> i don't understand that (f .) is for, and why f alone does not work
10:04:53 <xerox> Do you understand one or the other form?
10:05:00 <xerox> Step by step we'll get there.
10:05:05 <Pegazus> understand in what sense you mean?
10:05:11 <Pegazus> (f . g) x = f (g x) yes, that's function composition
10:05:15 <Pegazus> fog and gof :)
10:05:15 <xerox> OK great.
10:05:26 <palomer> sjanssen: cya
10:05:33 <Pegazus> f . g = \x -> f (g x) i think i get that too   
10:05:34 <xerox> Let's try to apply that definition to '(f .) . (,)'
10:05:39 <Pegazus> k
10:05:45 <xerox> What do you get?
10:05:53 <Pegazus> i don't know how to apply (f .)
10:06:00 <xerox> (f .) ((,) x)
10:06:05 <xerox> Just substitute
10:06:12 <xerox> Which in turn is:
10:06:13 <Pegazus> ah the othr way you mean, true :p
10:06:32 <xerox> (f .) (x,) = f . (x,)
10:06:44 <Pegazus> mmm i don't get that one
10:06:50 <xerox> Wait, I missed details.
10:06:51 <Pegazus> (f .) ((,) x) -->  (f .) (x,) = f . (x,)
10:06:57 <Pegazus> why that one?
10:06:58 <xerox> Right.
10:07:10 <xerox> It's just the same.
10:07:20 <Pegazus> imm
10:07:37 <Pegazus> yeah i got it know
10:07:47 <xerox> It's the same thing as (1 +) 2 = 1 + 2
10:07:50 <Pegazus> yes yes
10:07:53 <xerox> OK.
10:07:55 <xerox> So now you have
10:07:58 <Pegazus> f(x,)
10:08:04 <xerox> \f x -> f . (x,)
10:08:08 <xerox> Expanding that what you get?
10:08:17 <Pegazus> f(x,) ?
10:08:25 <xerox> Err, \x f -> f . (x,)
10:08:29 <xerox> Just use the definition.
10:08:32 <Pegazus> mm
10:08:42 <xerox> \y -> \x f -> f ((x,) y)
10:08:50 <xerox> \y x f -> f (x,y)
10:09:50 <Pegazus> mmm
10:09:52 <Pegazus> thanks O_o
10:09:57 <xerox> You're welcome.
10:10:05 <Pegazus> and what would have happened if it didn't had the .?
10:10:05 <xerox> There's a pattern behind it, anyway.
10:10:18 <xerox> (.) composes two unary functions.
10:10:22 <Pegazus> k
10:10:29 <xerox> (.) . (.) composes a binary function with a unary function.
10:10:40 <Pegazus> O_o
10:10:42 <xerox> (.) . (.) . (.) composes a ternary function with a unary function.
10:10:48 <Pegazus> omg
10:10:49 <xerox> ...and so on.
10:11:00 <Pegazus> thanks :)
10:11:05 <xerox> Do you see why?  Every (.) eats one argument.
10:11:19 <Pegazus> emm
10:11:20 <Pegazus> kind of
10:11:23 <Pegazus> not 100% really :p
10:11:35 <xerox> Try yourself expanding the definition, have fun :-)
10:11:38 <Pegazus> buy you helped me much :)
10:11:43 <Pegazus> just another question
10:11:45 <zellyn> xerox: thanks here too.
10:11:46 * xerox tips his hat
10:11:49 <Pegazus> ((a, b) -> c) -> (a -> b -> c)
10:11:53 <xerox> zellyn, you're welcome!
10:11:55 <Pegazus> why's that wrong?
10:12:03 <xerox> What do you mean by wrong?
10:12:10 <Pegazus> Syntax error in input (unexpected `->')
10:12:21 <zellyn> xerox: those repeated applications are still warping my brain a little.  Like x `ap` y `ap` z.
10:12:35 <xerox> That's a valid type, the problem is the context, I fear.
10:12:47 <xerox> zellyn, `ap` for the masses!
10:12:49 <Pegazus> i want that to be the type
10:12:55 <Pegazus> of ((f .) . (,))
10:13:14 <pierre-> how can i use hPutBuf and hGetBuf functions? They need "Ptr a" for data, how can i get it?
10:14:16 <xerox> (\f -> (f .) . (,)) :: ((a,b) -> c) -> a -> b -> c
10:14:33 <xerox> It is indeed right, Pegazus.
10:15:35 <Pegazus> thanks
10:16:59 <xerox> Pegazus, (->) is right-associative.  It means that a -> b -> c == a -> (b -> c) and so on.  (It is called automatic currying, which in turn means that all the Haskell functions are really unary, possibly returning functions.) 
10:17:40 <Pegazus> k
10:18:14 <Pegazus> that explains much :)
10:18:30 <Pegazus> thanks you very much for your help xerox
10:18:48 <xerox> http://video.google.com/videoplay?docid=-7746601538612901199&pl=true
10:18:51 <xerox> You're welcome.
10:19:08 <xerox> (That video is ... weird?  But worksafe.)
10:19:15 <Pegazus> :)
10:20:20 <xerox> Do you believe that? :-D
10:20:32 <Pegazus> belive what?
10:20:42 <xerox> The video.
10:20:50 <Pegazus> i couldn't see it
10:21:11 <Pegazus> wait a sec
10:23:35 <work_metaperl> http://haskell.org/onlinereport/basic.html says "Tuples are algebraic datatypes with special syntax" -- what is an algebraic datatype? I suppose it contrasts with a recursive one.
10:24:42 <ski> no
10:25:14 <xerox> <http://en.wikipedia.org/wiki/Algebraic_data_type>
10:25:19 <ski> an algebraic datatypes is a datatype with 0 or more constructors, each which can have zero or more arguments
10:25:58 <ski> data Foo = F0  |  F1 Int  |  F2 [Foo]  -- this is an algebraic type
10:26:49 <ski> data Pair a b = P a b   -- this is also one. this happens to be isomorphic to the type '(a,b)' .. the value 'P x y' corresponds to '(a,b)'
10:27:06 <xerox> Algebraic Datatypes are Linear Combinations of Types?
10:27:32 <ski> data (a,b) = (a,b)  -- this is pseudo-code for how we think the pair type could've been defined, given some extensions in syntax
10:28:01 <ski> xerox : no
10:28:19 <ski> data Bar a = B0  |  B1 a a  -- this is not linear
10:28:19 <xerox> '...sums of product types...', so I thought.
10:28:26 <xerox> Ah, okay.
10:28:34 <ski> that corresponds to '1 + a * a'
10:28:40 <xerox> Right.
10:29:21 <ski> (s/the value 'P x y' corresponds to '(a,b)'/the value 'P x y' corresponds to '(x,y)'/ of course)
10:31:40 <ski> (and 'Baz a' with 'data Baz a = B ([a] -> a)' corresponds to 'a^(sum{i <- 0..} a^i)' etc, so simple polynoms aren't sufficient either)
10:32:44 <boy> is it possible to have a datatype with 2 constructors that have the same name, but a different 'signature'?
10:32:55 <ski> no
10:32:56 <boy> like data Foo = Bar Int | Bar String
10:33:22 <boy> but wouldn't this work? wouldn't haskell be able to figure out which usage based on the types?
10:34:15 <SimonRC> I think you can do that with one of the Haskell extensions.
10:34:34 <SimonRC> But conventional Haskell does not offer that.
10:34:43 <boy> maybe this could be something for haskell'? :D
10:35:06 <RyanT5000> i generally dislike overloading in that style
10:35:14 <ski> boy, if you did 'hey = Bar', how would it know which type 'hey' should get ?
10:35:32 <SimonRC> Oh, you could create a class that String and Integer were both instances of, and do the GHC polymorphic data thingy.
10:35:35 * SimonRC goes.
10:35:44 <boy> ski: dissallow doing that
10:35:53 <SimonRC> ski: polymorphic function
10:35:57 * SimonRC goes.
10:36:05 <ski> or, '\s -> read s'
10:36:06 <RyanT5000> even if it can be done, technically speaking, imagine someone writes a module M, with data Foo = Bar Int | Bar String
10:36:07 <Pegazus> curry (\x y -> x + y) with curry f = ((f .) . (,)) gives error: Cannot infer instance
10:36:26 <boy> ski: hm.... actually you can't dissallow that since you could just do hey x = Bar x
10:36:28 <ski> SimonRC : how ?
10:36:51 <ski> boy : as with my lambda :)
10:36:54 <RyanT5000> and you use it with Bar (5 :: Int32)
10:36:58 <Pegazus> help anyone?
10:37:00 <boy> ski: yeah...
10:37:06 <boy> anyway i gotta go eat! think about this everyone!
10:37:11 <RyanT5000> well i guess i'm probably not being very clear
10:37:45 <RyanT5000> if they then change it so that there's a separate Bar Int32, the meaning of your code changes
10:37:53 <RyanT5000> but i'm not sure that thing above is legal anyway
10:37:59 <ski> @type \f -> ((f .) . (,))
10:38:02 <mbot> forall c a a1.
10:38:02 <mbot>         ((a1, a) -> c) -> a1 -> a -> c
10:38:35 <ski> Pegazus : did you put that 'curry (\x y -> x + y)' in a variable like 'foo = curry (\x y -> x + y)' ?
10:38:42 <Pegazus> emm
10:38:47 <Pegazus> i don't get what you mean
10:38:49 <RyanT5000> the point is, C++-style overloading with implicit variable conversion means that if someone else writes an identically-named function, it can change which function your call ends up calling
10:39:03 <Pegazus> i wrote curry f = ((f .) . (,)) on the .hs
10:39:27 <ski> Pegazus : i mean for the call to 'curry', not the definition
10:39:28 <Pegazus> and when i do curry (\x y -> x + y) it gives that erorr
10:39:44 <Pegazus> i am doing it on hugs
10:39:45 <xerox> instance Show
10:39:48 <xerox> perchance?
10:40:03 <xerox> I mean, "... cannot infer instance Show ..." is the error?
10:40:06 <Pegazus> ERROR - Cannot infer instance
10:40:07 <Pegazus> *** Instance   : Num (a,b)
10:40:07 <Pegazus> *** Expression : curry (\x y -> x + y)
10:40:21 <ski> @type let curry f = ((f .) . (,)) in curry (\x y -> x + y)
10:40:23 <mbot> forall a
10:40:23 <mbot> [3 @more lines]
10:40:25 <xerox> Indeed.
10:40:27 <ski> @more
10:40:28 <mbot>                      a1.
10:40:28 <mbot>                    (Num (a, a1)) =>
10:40:28 <mbot>                    a -> a1 -> (a, a1) -> (a, a1)
10:40:39 <xerox> Pegazus, you want to pass 'curry' a function which gets a tuple as argument.
10:40:48 <ski> @type let curry f = ((f .) . (,)) in curry
10:40:49 <mbot> forall a a1 c.
10:40:49 <mbot>               ((a, a1) -> c) -> a -> a1 -> c
10:40:50 <Pegazus> hehe
10:40:53 <Pegazus> you are right :p
10:40:55 <Pegazus> sorry!
10:41:00 <xerox> :-)
10:41:09 <int-e> @type uncurry (+)
10:41:11 <mbot> forall b. (Num b) => (b, b) -> b
10:42:36 * ski wonders if nominial types is basically just existentially quantified packages of structural types with operations, which have been opened as an abstract type (i.e. skolem)
10:53:34 <palomer> ok
10:53:44 <palomer> someone explain to me how to typecheck with recursive types?
10:53:47 <palomer> s/?/!
10:53:48 <palomer> go!
10:53:52 <Pegazus> how can you comppose f(x) = h(g(), k()) ?
10:54:30 <Pegazus> how can you comppose f(x1, ..., xn) = h(g(x1, ..., xn), k((x1, ..., xn)) ? or f(x1, ..., xn, ... xm) = h(g(x1, ..., xn), k((xn, ..., xm))
10:55:18 <xerox> Sorry?
10:55:27 <Pegazus> . composes two unnary functions
10:55:43 <Pegazus> suppose i have h and f1, ..., fn
10:55:51 <xerox> Could you emphasize what are the arguments, and in which order they have to be points-freed out?
10:56:19 <Pegazus> and i want to do g(x1, ..., xn) h(f1(x1, ..., xn), ..., fn(x1, ..., xn))
10:56:20 <Pegazus> i mean
10:56:24 <Pegazus> to compose multiple functions
10:56:32 <Pegazus> (i'm talking in general, not "A specific function"
10:56:33 <Pegazus> )
10:57:18 <Pegazus> is there any tutorial about composing things? :p
11:00:24 <Pegazus> :(
11:00:29 <Pegazus> how would you write the uncurry function?
11:00:54 <RyanT5000> uncurry f (x, y) = f x y
11:01:14 <Pegazus> mmm nope
11:01:22 <Pegazus> i should return a function, not evaluaate it
11:01:28 <RyanT5000> ...
11:01:31 <Pegazus> uncurry f = something here
11:01:31 <xerox> Heh.
11:01:39 <RyanT5000> mine does, pegazus
11:01:40 <Pegazus> the other way is too much easy :)
11:01:42 <xerox> Pegazus, that *does* return the function.
11:01:48 <Pegazus> mmm
11:01:51 <xerox> HAH
11:01:59 <xerox> Yes, Haskell *is* too much easy :)
11:02:09 <Pegazus> kind of
11:02:32 <Pegazus> mm
11:02:36 <xerox> If you apply the first functional argument to the 'uncurry' function, what does it return?
11:02:41 <Pegazus> yes i know
11:02:42 <xerox> I.e. what's its type?
11:02:45 <Pegazus> how would you define it
11:02:52 <Pegazus> like uncurry f = something ?
11:03:00 <Pegazus> (i accept that the other works, but now for curioisity)
11:03:02 <xerox> uncurry f x y = f (x,y)
11:03:05 <Pegazus> how would you define that one
11:03:19 <xerox> uncurry f = \x y -> f (x,y)
11:03:43 <Pegazus> without using lambda functions (if that are how they are called =P
11:03:50 <RyanT5000> you probably can't
11:03:53 <Pegazus> i want to know how the "real" definition of the 1 var function looks like
11:03:54 <RyanT5000> well
11:03:54 <xerox> Yes you can.
11:04:00 <RyanT5000> you could use fst and snd
11:04:07 <Pegazus> how would you?
11:04:08 <xerox> uncurry f = (f .) . (,)
11:04:18 <Pegazus> what was for curry
11:04:26 <xerox> Nope.
11:04:33 <Pegazus> O_o
11:04:50 <RyanT5000> ooh
11:04:53 <RyanT5000> i didn't realize , was an operator
11:04:57 <RyanT5000> i thought it was syntax
11:04:59 <xerox> curry :: ((a,b) -> c) -> a -> b -> c
11:05:09 <xerox> uncurry :: (a -> b -> c) -> (a,b) -> c
11:05:37 <xerox> curry f x y = f (x,y)
11:05:45 <xerox> uncurry f (x,y) = f x y
11:05:48 <Pegazus> my current curry function is curry f = ((f .) . (,)) and it seems ot work
11:06:14 <RyanT5000> yah i believe it
11:06:25 <xerox> No.
11:06:32 <RyanT5000> oh
11:06:33 <RyanT5000> wait
11:06:37 <RyanT5000> i misread; i thought you said uncurry
11:06:38 <ski> palomer : iso-recursive ?
11:07:06 <xerox> Pegazus, fire up hugs and ask it for curry and uncurry types.
11:07:21 <xerox> Pegazus, then match your definition's type with the right function.
11:07:54 <Pegazus> but i tried it
11:07:57 <Pegazus> and it worked O_o
11:08:05 <Pegazus> this is strange
11:08:07 <palomer> ski: nevermind, I understand it (kind of)
11:08:10 <palomer> Cale: you around?
11:08:17 <palomer> I understand it as much as I need to:O)
11:08:42 <xerox> Pegazus, what's your test?
11:09:27 <Pegazus> sum (x, y) = x + y
11:09:36 <Pegazus> (curry sum) 3 5
11:09:39 <Pegazus> and it gave me 8
11:10:00 <xerox> Right.
11:10:05 <xerox> Now do :type curry
11:10:21 <palomer> http://www.rafb.net/paste/results/oEUVKj72.html <--ok, someone explain to me how this could _possibly_ type check
11:10:33 <ski> 'sum (x, y) = x + y' is (almost,but not quite) syntactic sugar for 'sum = \(x, y) -> x + y'
11:10:50 <Pegazus> (a,b) -> c) -> a -> b -> c
11:10:55 <xerox> Pegazus, right!!
11:11:08 <Pegazus> so?
11:11:09 <palomer> I'm very confused how that could possibly type check
11:11:15 * xerox is now confused
11:11:30 <Pegazus> @type \f -> (f .) . (,)
11:11:33 <mbot> forall c a a1. ((a1, a) -> c) -> a1 -> a -> c
11:12:16 <Pegazus> @type \f (x,y) = f x y
11:12:17 <mbot> parse error on input `='
11:12:30 <Pegazus> @type \f (x,y) = (f x y)
11:12:32 <mbot> parse error on input `='
11:12:35 <Pegazus> can't you do thatone?
11:12:42 <Pegazus> @type \f (x,y) -> (f x y)
11:12:44 <mbot> forall a b t. (a -> b -> t) -> (a, b) -> t
11:12:46 <Pegazus> there
11:13:04 <Pegazus> mm
11:13:38 <palomer> ski: when typechecking, t : mu X . T, we simply type check t : T [mu X.T/X], right?
11:16:37 <ski> you could add to environment that 'X' is bound to 'mu X.T' and typecheck 't : T'
11:16:50 <ski> possibly the unfolding version will work too, though
11:17:39 <ski> palomer : palomer, re the GADT code, i think i see why it typechecks
11:17:54 <palomer> why?
11:17:56 <ski> s/palomer, //
11:18:29 <ski> first i rename slightly
11:18:34 <ski> toList :: GList (c,d) -> [c]
11:19:01 <ski> so, we match on a value of type 'GList (c,d)'
11:19:29 <mathrick> how can I specify that a type is to be of two classes, namely Eq and Ord?
11:19:45 <mathrick> instance Eq a => Ord a => Ord (Pair a b) where
11:19:52 <mathrick> ^---- this didn't work
11:19:53 <Igloo> (Eq a, Ord a) =>
11:19:55 <mathrick> aha
11:19:57 <mathrick> thanks
11:20:03 <ski> mathrick : 'Ord' subclasses 'Eq',  so in this case it isn't needed
11:20:14 <mathrick> ski: well, ghc seems to disagree :)
11:21:15 <mathrick> http://pastebin.com/646533
11:21:15 <ski> if the pattern 'ListNil' matches, then the type 'GList (c,d)' is unified with the type of the pattern, which is 'GList a' (for a fresh 'a'), so we get 'a = (c,d)'
11:22:02 <palomer> you can ignore the existence of that branch
11:22:14 <palomer> only the second branch is interesting
11:22:48 <Igloo> mathrick: You need to define an Eq (Pair a b) instance
11:23:00 <mathrick> can I do it with no definitions?
11:23:04 <ski> mathrick : you still need to make 'Pair a b' an instance to 'Eq', (provided that 'a' and 'b' are instances of 'Eq') (this can be done with a 'deriving Eq' on the datatype, .. which incidentally can also work with 'Ord')
11:23:23 <mathrick> ski: but for ord that won't DTRT, no?
11:23:48 <ski> palomer : then '[]' has type '[e]' for any 'e', here 'e = [c]', so that branch typechecks
11:23:59 <ski> mathrick : 'DTRT' means ?
11:24:25 <resiak> do the right thing
11:25:13 <mathrick> ski: Do The Right Thing
11:25:28 <ski> mathrick : right (didn't read the code very closely :)
11:26:14 <ski> mathrick : btw, can't you do 'MkPair x _ `compare` MkPair y _ = x `compare` y' ?
11:26:29 <Pegazus> how is a tuple defined recursivly?
11:26:41 <ski> Pegazus : it isn't
11:26:45 <Pegazus> i mean how do i get 3rd element?
11:26:46 <mathrick> ski: right :)
11:26:59 <ski> thr3 (_,_,z) = z
11:27:08 <ski> s/thr/trd/
11:27:12 <Pegazus> the 16th element?
11:27:23 <ski> mutatis mutandis
11:27:31 <ski> (or TH, i hear, iirc)
11:27:31 <palomer> ski: what about the other branch?
11:27:34 <Pegazus> the fst element of a "tuple" but you don't know of how many elements?
11:27:41 <ski> palomer : coming .. :)
11:27:53 <palomer> oh, right it does check
11:28:03 <palomer> nevermind, I'm being an idiot
11:28:12 <ski> palomer : if the pattern 'ListCons a b' matches, then the type 'GList (c,d)' is unified with the type of the pattern, which is 'GList (a,(a,b))' (for a fresh 'a' and 'b'), so we get 'a = c' and 'b = (c,d)'
11:28:15 <palomer> however, it is polymorphically recursive, right?
11:28:19 <ski> yes
11:28:29 <ski> (this kind of GADT recursion usually is)
11:28:35 <Pegazus> how to get the fst of a tuple
11:28:42 <Pegazus> of any tuple not only 2 sized tuples
11:28:51 <ski> why do you want this ?
11:29:52 <Pegazus> i want to make a general curry function
11:30:04 <Pegazus> that curryes a function with a tuple of any size
11:30:16 <palomer> you can't without generalized tuples
11:30:22 <ski> this is possible with dependent types (which haskell doesn't have)
11:30:24 <Pegazus> what's that thing?
11:30:31 <palomer> ski: GADTs are enough
11:30:36 <Pegazus> <palomer> you can't without generalized tuples ?
11:30:51 <palomer> Pegazus: don't worry about it. as far as you're concerned, you can't
11:30:57 <palomer> you can't with haskell tuples
11:31:05 <ski> palomer : enough for what ?
11:31:27 <palomer> ski: for what he wants to do
11:31:32 <ski> ah, ok
11:32:08 <ski> (i believe it might be possible with multi-arg classes + fun-deps, too)
11:32:30 <palomer> oh, right
11:32:37 <RyanT5000> you can do it with TH ;0
11:32:38 <RyanT5000> ;)
11:32:43 <ski> palomer : how to extract first type out of a general tuple-type with GADTs ?
11:32:44 <palomer> yeah, HList
11:33:37 <palomer> ski: http://www.rafb.net/paste/results/Q7xiGi62.html
11:34:13 <palomer> you can also do it with recursive types
11:34:59 <palomer> (though for currying, I'm not sure)
11:35:18 <ski> ah, yes, but that's nested
11:35:24 <newsham> anyone wanna help with something?  http://lava.net/~newsham/x/hws.tgz   I got most of it to compile but having problems with a few things.
11:35:39 <ski> (hm, prolly the type class solution would use nested, too)
11:35:50 <palomer> non nested tuples are simply a convenience
11:36:07 <palomer> actually, I don't know if you could write a general currying function
11:36:10 <palomer> what type would it have?
11:36:43 <ski> curry :: Curry a b ab -> (a -> b) -> ab
11:36:51 <palomer> with gadts/recursive types/dependent types
11:36:56 <ski> s/ab ->/ab =>/
11:37:16 <palomer> are you sure you can do it with dependent types?
11:37:41 <franka> What is the problem, newsham?
11:37:42 <ski> no, but i think i see how to do with with multi-arg classes + fun.-dep.s
11:38:12 <RyanT5000> is there a standard haskell way of doing the following without multiparameter classes?:
11:38:13 <RyanT5000> class Diff m d where
11:38:13 <RyanT5000>      mutate :: d -> m -> m
11:38:15 <palomer> ski: has there been a proof theoretic interpretation of typeclasses?
11:38:22 <newsham> franka: several.   a few deprecated warnings I couldnt figure out how to get rid of.  one place I had to hack (see XXX in comment), and a few problems in Main.hs where functions no longr exist that I dont know replacements for
11:39:05 <ski> palomer : dunno :)
11:39:50 <ski> palomer : i think there was some trickiness in converting fun.-dep.s to extended (more or less) system F inside GHC
11:40:14 <palomer> it seems that you can do most dependently typed things with typeclasses+fundeps
11:40:40 <franka> Your Main file says it is copyrighted by Simon M.
11:40:50 <newsham> its not my code.  it's simons code.
11:41:02 <newsham> i just want to get it to build :)
11:41:19 <newsham> if you cvs diff you'll see that I had to update a lot of stuff
11:42:01 <RyanT5000> how can i define a Diff class that provides a function from an instance of that class and an "m", and returns an updated "m"?
11:42:10 <RyanT5000> do i need to use multiple parameters?
11:42:20 <franka> Hm, I don't think I am the right person to help you with these kinds of problems.
11:42:44 <RyanT5000> (the compiler told me to use -fglasgow-exts, but this seems pretty simple to require extensions)
11:42:48 <newsham> thanks for looking.
11:43:01 * franka doesn't know much about differences between GHC versions.
11:43:18 <newsham> me either.  i'm getting a crash course :)
11:43:57 <franka> Oh, this is Simon's web server.
11:44:22 <newsham> Haskell Web Server
11:47:07 <dozer> hum - if I define a data type Tree a, but want to make sure that a is an Ord type, do I say Tree (Ord a)?
11:47:45 <mathrick> http://pastebin.com/646588
11:48:03 <mathrick> could someone tell my why it complains about (Ord a)?
11:48:09 <franka> Ord a => Tree a
11:48:23 <mathrick> ah
11:48:26 <dozer> ah thx.
11:48:59 <franka> But you would not use it in the data declaration, rather the functions manipulating Tree.
11:49:05 <mathrick> wait, it wasn't for me
11:50:46 <mathrick> but still
11:51:08 <ski> mathrick : 'instance Eq (Pair a b)' should be 'instance Eq a => instance Eq (Pair a b)', mutatis mutandis for 'Ord'
11:51:32 <mathrick> ski: hmm
11:51:34 <mathrick> lemme try
11:52:25 <mathrick> instance Eq a => Eq (Pair a b)
11:52:25 <mathrick> instance Ord a => Ord (Pair a b) where
11:52:28 <mathrick> gives now
11:52:29 <mathrick> /home/mathrick/dm22/dicttree.hs:8:26:
11:52:29 <mathrick>     Could not deduce (Num b) from the context (Ord (Pair a b), Ord a, Eq (Pair a b))
11:52:45 <ski> ah
11:53:04 <ski> you had 'Num b' on the 'data' definition, so you need this in the 'instance' declarations' too
11:53:26 <ski> 'instance (Eq a,Num b) => Eq ...'
11:53:31 <ski> 'instance (Ord a,Num b) => Ord ...'
11:53:58 <mathrick> uh, why?
11:54:06 <mathrick> shouldn't that be obvious?
11:54:07 <ski> the only thing the '(Eq a,Num b) =>' in the data definition does is to make so that the constructor has type
11:54:24 <franka> I think you want: instance (Eq a, Eq b) => Eq (Pair a b) where...
11:54:30 <ski> MkPair :: (Eq a,Ord b) => a -> b -> Pair a b
11:54:31 <mathrick> franka: no
11:54:32 <ski> instead of
11:54:36 <ski> MkPair :: a -> b -> Pair a b
11:54:38 <mathrick> franka: why would I care about b?
11:55:02 <franka> To define termwise equality.
11:55:09 <bolrod> sjanssen: yo,  do you submit your definition of inits to the mailing list or something?
11:55:12 <franka> If data Pair a b = Pair a b, at least.
11:55:13 <ski> it still doesn't know that if something has type 'Pair x y' then it must follow that 'Eq x' and 'Num y' holds
11:55:16 <mathrick> franka: but b does not participate in equality
11:55:18 <ski> s/Ord b/Num b/
11:55:21 <mathrick> I only care about a
11:55:58 <ski> franka : he only wants to compare first parts in 'Ord', so i'd assume same goes for 'Eq'
11:56:13 <franka> OK.  Unusual.
11:56:21 <mathrick> that's the only reason I bother with pair
11:56:27 <mathrick> otherwise I'd simply use tuples
11:56:28 <sjanssen> bolrod: no I haven't
11:56:39 <mathrick> franka: it's (key, value)
11:56:43 <bolrod> will you?.. 
11:56:51 <mathrick> I specifically don't want value to be taken into account
11:56:58 <bolrod> will I ? :)
11:57:16 <mathrick> ski: I still don't really know what exactly I should write there
11:57:23 <sjanssen> bolrod: I can if you'd like, I'm already subscribed to the list
11:57:29 <ski> mathrick : maybe it would be better if you renamed your type like 'data (Eq key,Num value) => Assoc key value = ...'
11:57:41 <mathrick> okay
11:57:46 <mathrick> Assoc is good enough
11:57:56 <bolrod> which list is it anyway?
11:58:03 <sjanssen> libraries@haskell.org
11:58:05 <bolrod> is there an archive ?
11:58:32 <mathrick> ski: done that, now what about my errors? :)
11:58:47 <ski> (mathrick : or possibly even leaving out 'Num value', if you don't want to enforce this for general 'Assoc's .. since having an expression with type 'Assoc key value' won't anyway determine that 'Num value' holds ..)
11:59:04 <RyanT5000> why is it that Uniques operate within the IO monad
11:59:15 <RyanT5000> wouldn't it be more sensible to have a separate monad?
11:59:18 <Pegazus> hi! how to do g xs ys [ y ++ reverse x | x <- xs, y <- ys ] that function without comprenhensive list nor explicit recursion, and only using map, filter, foldr, even, odd, length reverse and (++). (What i don't know is how to get all 
11:59:18 <ski> mathrick : and what are these errors of which you speak, then ?
11:59:29 <RyanT5000> that way you coul have multiple domains of Uniques
11:59:30 <newsham> ryan: as a guess - IO imposes ordering?
11:59:38 <mathrick> ski: yeah, but it was done to not have to declare it later in a number of functions where it is Num. I didn't want to have Num value, but my partner wanted and I gave in :>
11:59:38 <RyanT5000> right, but don't all monads?
11:59:42 <newsham> no
11:59:48 <franka> There ought to be a class Eqv for such equivalence relations.
11:59:53 <mathrick> ski: http://pastebin.com/646588
11:59:55 <ndm> Pegazus: compile it with a compiler with the right flags, and it will do the translation for you
12:00:05 <ndm> Pegazus: yhc File -core will do that
12:00:23 <Pegazus> i don't know how to make the like "cartesian product"
12:00:26 <sjanssen> bolrod: I would think so, but I can't seem to find it
12:00:40 <newsham> in the "comprehending monads" paper they talk about a monad (and comprehension) which does not specify an ordering
12:00:44 <bolrod> hmm.. I'll subscribe anyway
12:00:56 <Pegazus> ahhh forget it, i got it
12:00:57 <RyanT5000> hm
12:01:02 <Pegazus> with map i can od it
12:01:12 <Pegazus> thx
12:01:13 <Pegazus> bye
12:01:25 <RyanT5000> well i guess what i'm getting at is that Unique doesn't really change the computer's state, it just has a bit of its own state
12:01:45 <mathrick> ski: I still don't know why it thinks (Ord a) and (Num b) aren't apparent from the context
12:01:59 <mathrick> if I explicitly defined that Assoc takes Ord and Num
12:02:00 <RyanT5000> so does it really *have* to use the whole IO monad
12:02:26 <newsham> i'm not familiar with unique.   is that an updatable data type thats implemented efficiently by ensuring that old values are never reused after updates create new ones?
12:02:30 <ski> mathrick : putting the '(Ord a,Num b) =>' in the 'data' declaration still don't allow you to omit that in later type signatures
12:02:41 <ski> mathrick : basically, this isn't possible, in the current type system
12:02:51 <mathrick> buh
12:02:53 <mathrick> that sucks
12:03:06 <RyanT5000> i don't know what you mean by "updatatable datatype", but it's basically a value that's guaranteed to be unique; you can hash it etc.
12:03:07 <ski> mathrick : John Hughes sketched on a solution that could make it work, but i don't think it was implemented
12:03:07 <sjanssen> bolrod: maybe I'll just send it to the list now.  do you have a name that I can credit?
12:03:12 <mathrick> ski: so I will always have to state that explicitly?
12:03:18 <ski> (it's not fully clear how it would work, in general)
12:03:19 <mathrick> in every single function?
12:03:22 <ski> mathrick : yes
12:03:27 <mathrick> *sucks*
12:03:30 <newsham> ryan: ahh, probably not what I'm thinking of.  *shrug* dunno.
12:03:43 <RyanT5000> k
12:03:46 <ski> mathrick : ask Cale about this, it's one thing he'd very much like to see a solution of :)
12:04:00 <bolrod> sjanssen: ok cool.. hmm..  name.. bolrod(Tim Toorop)  :)
12:04:03 <ski> (mathrick : it would allow making 'Set' an instance of 'Monad', e.g. :)
12:04:17 <mathrick> ski: and why exactly doesn't it work? If I state that Ord a, then Ord a, no?
12:04:44 <ski> mathrick : as i already said, it *only* constrains the type of the constructors of the type ..
12:05:05 <mathrick> but the type itself isn't constrained?
12:05:08 <mathrick> wierd
12:05:11 <mathrick> very much so
12:05:14 <ski> mathrick : .. it does *not* make the system realize that if an expression has type 'Assoc a b' then 'Ord a' must have been true
12:05:18 <mathrick> *weird
12:05:37 <franka> It is not the case that a value of type a need be built of constructors for a.
12:05:43 <ski> making this work would probably require an extension to the kind system, i think
12:05:50 <mathrick> hrmpf
12:05:50 <franka> For example bottom.
12:06:08 <mathrick> well, okay, I'll add all that by hand
12:06:27 <mathrick> but it basically means pushing all the responsibility to the end user
12:06:30 <mathrick> which is silly
12:08:09 <ski> franka : hmm .. you mean if you have e.g. 'class Foo a where foo :: a', and 'data Foo a => F a = MkF {unF :: a}' and then 'foo `asTypeOf` unF (MkF (undefined :: X))' with no 'Foo X' in scope ?
12:10:01 <franka> ski: Hm, that is not what I had in mind, but perhaps that also.
12:10:45 <CosmicRay> is there any nice way to insert multiline literals in a Haskell program?
12:11:04 <ski> CosmicRay : string literals ?
12:11:26 <CosmicRay> a string literal is something line "line1\nline2"
12:11:33 <CosmicRay> I want to be able to write something like:
12:11:35 <CosmicRay> "line1
12:11:36 <CosmicRay> line2"
12:11:40 <ski> foo = "line1\
12:11:45 <ski>     \line2"
12:12:02 <ski> add an '\n' manually, if you want one
12:12:15 <ski> (this is called string gaps)
12:12:32 <CosmicRay> ah
12:13:22 <ski> > "abc\  \def"
12:13:27 <mbot> "abcdef"
12:13:52 <ski> so, whitespace in between is removed (as are the backslashes)
12:13:59 <flux__> fun feature
12:14:25 <flux__> somebody actually gave it some thought instead of doing what everybody else is doing :)
12:14:29 <CosmicRay> ski: can I use it without removing the whitespace in between?  (like C)
12:14:49 <flux__> just use \ at the eol and bol?
12:15:01 <CosmicRay> well then it removes the \n
12:15:06 <flux__> oh, right
12:15:14 <flux__> you can do that in C?
12:15:24 <flux__> I've always just written "Foo"(nextline)"bar"
12:15:45 <ski> > "foo\n\   \bar"
12:15:47 <flux__> meaning I've had to add the \n's there myself
12:15:48 <mbot> "foo\nbar"
12:15:50 <franka> ski: I just mean that, if data contexts only constrain constructors, then you can always write undefined :: F a rather than whatever :: Foo a => F a.
12:16:06 <CosmicRay> flux__: I think if you but a backslash as the last character on a line, you can
12:16:27 <mauke> CosmicRay: it still removes the newline
12:16:28 <flux__> it makes sense, though, if that works
12:16:38 <flux__> time for a test!
12:16:42 <ski> franka : yes .. but with a feature, like i think we may want here, implemented, first of those type signatures would imply the second, i think
12:16:47 <mauke> however, that's not a string feature
12:16:50 <mauke> int ma\
12:16:53 <mauke> in() also works
12:16:58 <flux__> yes, it removes newline
12:17:21 <franka> ski: Yes, I am reasoning based on your comment that contexts only constrain constructors.
12:17:30 <ski> franka : right
12:17:53 <sjanssen> bolrod: sent
12:17:58 <franka> However, that would be sufficient in some languages.
12:18:10 <franka> For example an eager language without subtyping.
12:18:28 <franka> Because then every value is constructed.
12:19:18 <ski> data Foo a => F a = MkF (() -> a)
12:19:18 <ski> ?
12:19:37 <bolrod> sjanssen: lets see if I got one :)
12:20:03 <boy> is it possible to make "anonymous types"? like this:
12:20:20 <boy> data Foo = Bar {A | B}
12:20:30 <sjanssen> boy: no
12:21:00 <ski> boy : otoh, 'data Foo = Bar (Either A B)' is of course possible
12:21:00 <boy> i have to have an explicit data Shit = A | B ?
12:21:28 <franka> ski: Hm, yeah, I had forgotten about head-normal form and the lack of eta laws.
12:21:59 <boy> ski: is there something like Either that allows me to have 4 different options?
12:22:13 <ski> Either (Either A B) (Either C D)
12:22:13 <bolrod> sjanssen: cool =)
12:22:15 <ski> or
12:22:28 <ski> data Either4 a b c d = ....
12:23:26 <boy> hm.... is this allowed: data Foo = Either 5 String
12:23:35 <ski> (boy : light-weight variant types (which would be an extension) would possibly also satisfy you i think (OCaml e.g. has this as 'polymorphic variants'))
12:23:37 <ski> no
12:23:42 <ski> '5' is not a typew
12:23:45 <ski> s/w//
12:24:55 <boy> ski: so what should i do, if i want a value to either be the number 5, or a string?
12:26:15 <franka> Either () String
12:26:23 <franka> And define inl () = 5
12:26:32 <franka> Er, not.
12:26:48 <franka> When you do a case, you map the () to 5.
12:27:38 <boy> franka: ok, what if i want: data Digits = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
12:27:45 <franka> However, you can't ensure the Left takes 5 as input, so it's not much use.
12:27:55 <ski> # let frob x = match x with
12:27:55 <ski>     `A a -> `D (a + 1)
12:27:55 <ski>   | `B b -> `A (List.rev b)
12:27:55 <ski>   | `C (c0,c1) -> `C (c1 :: c0)
12:27:55 <ski>   | `D d -> `B d
12:27:56 <ski>   ;;
12:27:58 <ski> val frob :
12:28:00 <ski>   [< `A of int | `B of 'a list | `C of 'b list * 'b | `D of 'c ] ->
12:28:02 <ski>   [> `A of 'a list | `B of 'c | `C of 'b list | `D of int ] = <fun>
12:28:22 <franka> boy: What about it?
12:28:22 <sjanssen> boy: put a capital letter in front of each digit, like D1 | D2 ...
12:28:35 <ski> data Digits = D0 | D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9
12:28:40 <ski> (bah !)
12:29:23 <boy> ski: yeah, but then can't use (b::Digits) in integer expression b + 1
12:29:26 <franka> Frankly, though, you are treading on thin ice with these things.
12:29:44 <bolrod> sjanssen: did you profile the functions.. to output a nice graph?
12:30:04 <sjanssen> bolrod: nah, I'm way too lazy for that
12:30:09 <bolrod> haha
12:30:11 <bolrod> I'll try :)
12:30:11 <boy> ok, here's something really close to what i'm doing:
12:30:29 <boy> data Colors = Red | Purple | Blue | Green | Black | White | Yellow
12:30:40 <boy> and then i want a PrimaryColors = Red | Blue | Yellow
12:30:49 <boy> PrimaryColors is a subset of the Colors
12:31:02 <ski> digit2num :: Num a => Digit -> a
12:31:09 <ski> digit2num D0 = 0
12:31:09 <ski> ...
12:31:21 <ski> then 'digit2num b + 1'
12:31:37 <franka> You can do: PrimaryColors a = R | G | B | Other a
12:31:51 <bolrod> or you can do
12:31:55 <franka> And then slip in other possibilities via the a.
12:31:57 <ski> boy : O'Haskell can do that, with subtyping
12:32:06 <bolrod>  PrimaryColors = Red | Blue | Yellow
12:32:13 <bolrod> data Colors = Red | Purple | Blue | Green | Black | White | Yellow
12:32:15 <bolrod> urh
12:32:37 <bolrod> hmm
12:32:38 <bolrod> nah
12:33:10 <franka> Or Either PrimaryColors OtherColors, as ski suggested.
12:33:45 <ski> (data Colors > PrimaryColors = Purple | Black | White | Yellow)
12:33:51 <franka> However, you would do best to avoid this sort of thing altogether.
12:34:22 <franka> Trust me.
12:34:43 <boy> so what is the best thing to do, if i have some functions that work with all colors, and some that work only with primary colors?
12:34:48 <bolrod> you could make a class ?
12:34:49 <ski> (franka : because you don't like subtyping ?)
12:35:07 <franka> ski: I am talking about Haskell, not O'Haskell.
12:35:12 <ski> foo :: PrimaryColor -> ...
12:35:16 <franka> ski: But, yeah, that too.
12:35:26 <ski> bar :: Either PrimaryColor OtherColor -> ...
12:35:46 <franka> boy: Define two color types, with different constructor names.
12:36:01 <franka> PrimaryColor = PrimaryRed | PrimaryGreen | PrimaryBlue
12:36:21 <boy> ski: what if in addition to PrimaryColors, i have more subsets, possibly with overlapping elements?
12:36:22 <franka> OtherColors = OtherRed | OtherGreen | OtherBlue | OtherYellow
12:36:36 <franka> That is the easiest thing.
12:37:06 <ski> franka : i've wondered .. since math othen uses implicit inclusions (monos), is there also implicit projections (epis) to equivalence classes (/representants thereof) in use ?
12:37:49 <boy> argh, i'm totally stuck :'(
12:38:02 <palomer> s/othen/often
12:38:10 <ski> ty
12:38:14 <palomer> np
12:38:38 <ski> boy : you can try to factor out the common parts into a new type ..
12:39:06 <franka> ski: There is nothing implicit about monos.  But, yeah, it is common to use some epis implicitly.
12:39:12 <boy> maybe i will just have a single Color type, and have runtime errors whenever a color is used in a place where it is not allowed :\
12:40:02 <palomer> hrmph
12:40:03 <dozer> if I have a data type that is an instance of Show, and I've got a value of that data type x, how would I print x out to the terminal?
12:40:12 * palomer wonders about the standard way of doing type checking with polymorphic recursion
12:40:21 <ski> (franka : of course that parenthetical comment only referred to 'inclusions' alone, not including 'implicit' :)
12:40:25 <dozer> perhaps: putStrLn (show x)
12:40:26 <franka> ski: For example, the usually way to define a quotient is as a set of partitions, but these are often identified with a choice of representation (e.g. a normalization) in each class.
12:41:00 <sjanssen> dozer: print == putStrLn . show
12:41:28 <franka> should be "), so an element in each class."
12:41:58 <ski> franka : yes, but isn't then things usually explicitly canonicalized ?
12:42:41 <franka> ski: CS people usually make the canon explicit, but mathematicians use Choice.
12:42:58 <ski> hm, is choice related to this ?
12:43:07 <ski> ah, of course
12:43:16 <franka> Yes, Choice lets you take an element from each member of a set of sets.
12:43:30 <ski> every epi is an retraction
12:44:10 <ski> (in ZFC-Set)
12:44:19 <franka> Every epi induces a retraction, yes.
12:44:37 <palomer> the canon?
12:44:48 <ski> canonicalizer
12:44:57 <palomer> it's unique?
12:45:10 <ski> of course not (generally)
12:45:14 <franka> By "canon" I just mean a uniform set of choices.
12:45:22 <palomer> ahh, a canon
12:45:36 <palomer> inria is down:(
12:46:17 <ski> hm .. reminds me of an idea i've got
12:47:19 <ski> retract Rational = Divide {numDenom :: (Integer,Integer)}
12:47:22 <ski>   where
12:47:27 <ski>   numDenom (Divide (n,d)) = (n `div` o,d `div o)
12:47:29 <ski>     where
12:47:31 <ski>     o = n `gcd` d
12:47:59 <ski> this would define a type as a retract of the given type, with a given idempotent
12:48:03 <dozer> http://pastebin.com/646695
12:48:07 <palomer> what's the definition of Divide?
12:48:08 <dozer> this compiles
12:48:12 <dozer> but doesn't print anything out
12:48:18 <ski> palomer : it's a constructor (sortof)
12:48:37 <ski> and 'numDenom' is a deconstructor (still sortof)
12:48:55 <palomer> data Divide = Divide {NumDenom:: (a,a)} ?
12:49:05 <palomer> give me the haskell, man!
12:49:42 <ski> dozer : you can replace '(putStrLn . show)' with 'print'
12:50:09 <ski> palomer : compare with
12:50:24 <bolrod> sjanssen: http://bolrod.homelinux.org/inits/
12:50:24 <ski> data Foo = MkF {unF :: Bar}
12:50:28 <ski> meaning same as
12:50:31 <bolrod> hehe.. the one in the module is very eratic
12:50:35 <ski> data Foo = MkF Bar
12:50:41 <ski> unF :: Foo -> Bar
12:50:50 <ski> unF (MkF bar) = bar
12:50:52 <Cale> mathrick: what was it that ski wanted you to show me?
12:51:19 <ski> Cale : the 'data Ord a => Baz a = ...' problem ..
12:51:30 <Cale> ah, yeah
12:51:30 <dozer> ski: ok - but it still prints nothing out when I run the prog :(
12:51:40 <ski> (Cale : and, rather, explain more, than, show)
12:51:55 <palomer> ski: I know about deconstructors, but I was asking about _your_ definition of Divide
12:52:30 <franka> ski: That looks like a view.
12:52:38 <sjanssen> bolrod: the new version gets a really nice curve
12:52:52 <ski> dozer : have you made a 'Show' instance of the datatype of the 'Null' constructor ?
12:53:07 <ski> franka : yes, i guess it has some similarities
12:53:08 <sjanssen> even space behavior is way better than old inits
12:53:29 <franka> A retract is sort of half an iso.
12:53:32 <bolrod> the old one probably has alot of eratic garbage collection
12:53:42 <mathrick> Cale: I was complaining that data (Ord a) => Foo a = ... doesn't imply a being instance of Ord in all occurences of Foo
12:53:48 <Cale> ski: I've been wondering if some mechanism could be devised to add parameters to (constructor) classes behind the scenes, so as to allow for restricted cases automatically.
12:54:00 <franka> The difficulty with those things is that for them to behave well, you need to be able to check arbitrary equational conditions.
12:54:15 <ski> franka : we get problems if we try to use the 'representant'-implementation, and don't use the canonicalizer ( = idempotent) directly when pattern-matching ..
12:54:16 <palomer> sjanssen: http://www.rafb.net/paste/results/oEUVKj72.html <--corrected version
12:54:18 <franka> OBJ has a system of retracts, which they use for subtyping.
12:54:34 <Cale> You can, by a bit of an abomination, get the desired behaviour from Functor and Monad for Set
12:54:35 <palomer> I don't understand the type for append in the HList paper:(
12:54:48 <Cale> but it involves adding extra parameters to those classes
12:54:48 <dozer> ski: no - this is day 2 of me and haskell - how do I go about making a Show instance of Null?
12:54:51 <ski> palomer : my 'Divide' was not a type, 'twas a constructor
12:54:58 <palomer> ah, righto
12:55:00 <Cale> such that they can be restricted later
12:55:04 <ndm> bolrod: what about other functions?
12:55:05 <palomer> what was the definition of the constructor
12:55:14 <bolrod> ndm: what other functions?
12:55:15 <ndm> i.e. other examples
12:55:22 <sjanssen> palomer: it's neat that GADTs can describe that so easily
12:55:24 <ndm> other than your test of inits
12:55:34 <bolrod> what other tests :)
12:55:35 <Cale> mathrick: I've had lots of trouble with that myself, specifically in the desire for Functor and Monad instances for things like Set
12:55:40 <bolrod> I just made those ...
12:55:47 <ndm> bolrod: which tests do you have?
12:55:56 <ski> palomer : with 'MkF' and 'unF' we get 'MkF . unF = id' and 'unF . MkF = id' (i.e. this is an iso)
12:56:05 <bolrod> urh.. I just run the profiler 
12:56:07 <ndm> the one thing is that your sum is strict, which might mean GHC is doing better than it should
12:56:08 <bolrod> :)
12:56:12 <dozer> ski: my data type deffinition for this is at: http://pastebin.com/646711
12:56:24 <ski> (palomer : this isn't strictly true actually, unless s/data Foo/newtype Foo/)
12:56:25 <bolrod> what do you mean strict?
12:56:26 <Cale> mathrick: The details of the problem are pretty tricky.
12:56:43 <ndm> your code invokes sum
12:56:47 <ndm> which makes it trivially strict
12:56:54 <ndm> and gets GHC to invoke the strictness and other tricks
12:57:01 <bolrod> yes..
12:57:06 <ndm> i was just wondering if your inits was better even in a lazy context?
12:57:08 <bolrod> so.. what do you want more?
12:57:12 <bolrod> like
12:57:14 <bolrod> take 10000
12:57:15 <bolrod> ?
12:57:21 <ski> palomer : anyway, for 'Divide' and 'numDenom' we still get 'Divide . numDenom = id' (taking numerator and denominator of a rational, and then dividing, we get back same rational)
12:57:27 <Cale> hmm
12:57:28 <ndm> perhaps, i was just wondering if you have tried any other tests
12:58:00 <sjanssen> ndm: the new function is actually lazier than the old one
12:58:04 <palomer> ski: I'm probably missing too much of the context to understand what you're saying
12:58:08 <ski> palomer : but, for the other we get 'numDenom . Divide = \(n,d) -> let o = n `gcd` d in (n `div` o,d `div` o)'
12:58:08 <sjanssen> or rather, more friendly to lazy use
12:58:11 <Cale> I wonder if an existential tactic could be employed to ensure that the dictionaries were available in any context.
12:58:21 <ski> (palomer : since it was defined to be that)
12:58:34 <Cale> data (Ord a) => Set a = S [a]
12:58:38 <ndm> sjanssen: yes, it looks well cool :) just as the number of examples gets bigger, people get more convinced
12:58:45 <bolrod> sjanssen: I think so to.. but what do you think makes it lazier?
12:58:54 <palomer> Cale: is that haskell syntax?
12:59:01 <Cale> palomer: yes, it already is
12:59:30 <ski> palomer : so, dividing a numerator with a denominator together into a rational, and then extracting the numerator and denominator again from that, will have reduced them, dividing both by greatest common divisor
12:59:34 <Cale> I'd change the meaning so that it would result in a constructor S which carried in addition to the usual stuff, a pointer to an Ord dictionary for a
12:59:38 <palomer> Cale: so why don't we use this to make a typeclass with lookup, etc...
12:59:47 <sjanssen> bolrod: these things are hard to explain
12:59:52 <bolrod> I think when you ask the length of the inits.. its just going to build a list with take ... from .. expressions.. and gets the length of that list..   instead of a list with alot of  x:x':x'':x''''   
12:59:54 <Cale> palomer: It currently doesn't mean what you think it does
12:59:56 <ndm> and have you looked at tails?
12:59:58 <sjanssen> it has to do with the map (x:) in the old version, that's bad
13:00:01 <ski> dozer : you don't, you make a 'Show' instance for whatever datatype 'Null' belongs to
13:00:05 <bolrod> yeah
13:00:08 <ndm> or any other functions
13:00:15 <palomer> ski: you wouldn't happen to have all your datatype/constructor definitions around, would you?
13:00:16 <Cale> palomer: It only restricts the types of the data constructors
13:00:21 <bolrod> map (x:) makes more and more junk the longer the list gets
13:00:27 <ARous1984> Newbs :)
13:00:32 <palomer> Cale: and thus of the types that set can take
13:00:38 <ARous1984> which, wrong channel, my bad.
13:00:38 <Cale> no
13:00:50 <dozer> ski: oh - I thought that if I ended the data declaration for it with "deriving (Show)" that it would be taken care of for me?
13:00:52 <bolrod> now making profile of length (inits [1..500000])
13:01:02 <bolrod> lets see how that performs :)
13:01:03 <Cale> It doesn't restrict the type parameters which you're allowed to apply the Set type constructor to
13:01:08 <sjanssen> oh, length will be even more favorable for the new one
13:01:17 <bolrod> the memory usage is considerably more with length though
13:01:25 <bolrod> probably because of the strictness
13:01:25 <palomer> Cale: but the a is restrited in Set a
13:01:31 <Cale> You can still have the type Set (a -> b)
13:01:39 <palomer> how?
13:01:40 <bolrod> sjanssen: yeah.. I doubt the old one is even going to finish ;/
13:01:41 <Cale> even though there's no instance Ord (a -> b)
13:01:45 <bolrod> I mean... it runs for some time now
13:01:53 <Cale> it's just that it has no elements in it
13:02:12 <Cale> because you're not allowed to apply the S constructor to anything not in Ord
13:02:13 <palomer> data (Ord a) => Set a = S [a] <--to me, this says that a must be an instance of Ord for any Set a
13:02:19 <ndm> i could actually believe that GHC even collapsed length to a direct length xs
13:02:26 <Cale> but it doesn't mean that, if you look at the report
13:02:32 <Cale> it means something substantially weaker
13:02:33 <ndm> i can imagine a set of RULE pragmas that did that :)
13:02:39 <bolrod> sjanssen: I dont think the old function can even handle the length of such a big list ;/
13:02:39 <palomer> Cale: oh, but why don't we extend it to mean that?
13:02:53 <sjanssen> ndm: that wouldn't be too surprising, lists are heavily optimised
13:02:53 <Cale> palomer: because the semantics are tricky
13:02:59 <ndm> indeed
13:03:08 <ndm> i'd like to see a "lazy" function on inits
13:03:13 <Cale> palomer: I'm thinking about an existential-type trick
13:03:17 <ndm> which GHC can't strictify
13:03:42 <bolrod> hahah I think I need to alter the test!    since the other one can't even finish the expression ;/
13:03:43 <Cale> palomer: where each constructor is forced to carry around a dictionary for Ord a as well.
13:03:44 <sjanssen> bolrod: when you're testing, remember to include "module Main where" at the top, this will keep GHC from inlining inits
13:03:45 <bolrod> haha
13:03:57 <ski> dozer : yes, in most cases
13:04:02 <ski> franka : ok, interesting
13:04:06 <ski> Cale : 'data Set a = Ord a => S [a]' ?
13:04:06 <bolrod> urh.. how would I test otherwise :)
13:04:07 <ski> palomer : which datatype/constructor definitions ?
13:04:27 <Cale> ski: yes, something like that
13:04:32 <sjanssen> it will still compile without the module junk, I was just checking
13:04:33 <bolrod> dang.. its definately not going to finish
13:04:43 <palomer> ski: Divide, etc.. so I can get the context of what you're talking about
13:04:49 <palomer> I joined in the conversation quite late
13:04:50 <bolrod> I think this quite proves the point
13:04:53 <franka> ski: What is interesting?
13:05:03 <ski> Cale : this is supported if the constraint mentions an existentially quantified tyvar, but not otherwise, currently, i think
13:05:03 <bolrod> the new inits finishes a calculation in .4 seconds
13:05:09 <bolrod> that the other one doesn't even finish!!!!
13:05:10 <bolrod> hahaha
13:05:15 <ndm> bolrod: they are both strict - you need a lazy one to prove it
13:05:18 <palomer> Cale: you're thinking of an existential trick where each constructor is forced to carry a dictionary?
13:05:25 <Cale> palomer: right
13:05:35 <ndm> and inits can actually optimise length inits to just lengths in your case (which is a nice property!)
13:05:37 <ski> franka : (arbitrary equational constraints and) OBJ
13:05:38 <palomer> btw, did you guys know that existentialism is syntactic sugar in system F ?
13:05:52 <bolrod> ndm: you think of a lazy implementation
13:05:55 <bolrod> and I'll test it in a moment
13:05:56 <bolrod> :)
13:06:03 <ndm> bolrod: am trying... :)
13:06:16 <palomer> Cale: is ghc thinking of extending the constructors to apply to the type constructor?
13:06:30 <palomer> s/constructors/constraints
13:06:31 <Cale> palomer: the problem is that you need to be able to pass values of type (Set a) to functions which don't necessarily receive a dictionary for (Ord a), but may need operations from Ord (think typeclass methods)
13:06:36 <franka> ski: Ah.  That is why I don't like views.  You cannot ensure automatically that they behave well.
13:06:47 <Cale> palomer: Lots of people have wanted that
13:07:02 <bolrod> http://bolrod.homelinux.org/inits/inits-length.pdf  <<   lenght of inits [1..500000]  
13:07:03 <sjanssen> bolrod: something like "last (last (inits [1..n]))" might be good. or "(inits [1..]) !! 50000 !! 40000"
13:07:06 <Cale> There are various tricky problems with ti
13:07:07 <Cale> it*
13:07:10 <bolrod> last last ?
13:07:12 <bolrod> oh yeah
13:07:15 <palomer> Cale: like?
13:07:16 <ski> franka : i've been pondering the two obvious implementations of retracts, a) canonical representatives, constructor operationally is the idempotent, deconstructor operationally is identity, b) any representative in equvalence class, constructor operationally is identity, deconstructor operationally is idempotent
13:07:16 <bolrod> haha
13:07:33 <ndm> bolrod: last $ map last $ tail $ inits [1..10000]
13:07:43 <ski> franka : also, how'd this work with recursive such types, in semantics (least and greatest fixedpoints, etc) ?
13:07:45 <ndm> > last $ map last $ tail $ inits [1..1000]
13:07:50 <mbot> 1000
13:08:10 <bolrod> seriously now
13:08:17 <Cale> palomer: mostly in interactions with the class system and generic instances, I think
13:08:19 <bolrod> > length (inits [1..10000])
13:08:24 <mbot> Terminated
13:08:27 <bolrod> see!!
13:08:40 <Cale> let me find the paprr
13:08:42 <Cale> paper*
13:08:56 <bolrod> > let inits' xn = zipWith take [0..] $ map (const xn) $ undefined:xn in length (inits' [1..50000])
13:08:59 <mbot> 50001
13:09:01 <bolrod> easy!
13:09:19 <bolrod> if this doesn't prove the point ;)
13:09:33 <aufrank> hello hello!
13:09:40 <Cale> http://citeseer.ist.psu.edu/hughes99restricted.html
13:10:30 <Cale> there's a bit of a wart to it though
13:10:34 <franka> ski: It is hard for me to answer such a general question.
13:10:40 <aufrank> I'm pretty new to haskell and am quite sure that I'm attempting to do something the wrong way-- it's dreadfully inefficient
13:10:45 <bolrod> is the old version of inits exponential or something... ?
13:10:47 <Cale> you end up having to type lots of wft constraints
13:10:59 <bolrod> I mean...  its like its NEVER going to finish counting the length of [1..50000]
13:11:05 <ski> (franka : i guessed .. i just wondered if maybe you had some idea or knew something related ..)
13:11:16 <palomer> Cale: so it hasn't all been figured out?
13:11:22 <aufrank> given a list of strings, I'd like the list of all unique combinations of four members of the list
13:11:33 <ndm> bolrod: with my example, testing with Hugs, your version is _massively_ faster for my example
13:11:47 <Cale> palomer: well, I'd like to see a cleaner solution than that paper offers, though I'm not sure if it's entirely possible
13:11:50 <ndm> i am totally convinced now :)
13:12:27 <bolrod> cool :D
13:12:39 <bolrod> I found a list the old version can actually count!!!
13:12:40 <bolrod> :D
13:12:49 <ski> (Cale : i always read that as 'wtf' constraints :)
13:13:13 <aufrank> I was passing four copies of the same list into a list comprehension where I make sure none of them are the same, and then doing Data.Set.fromList on the result of the list comprehension
13:13:34 <bolrod> ndm: to think that when I wrote my function... I thought it was going to be MASSIVELY slower then the current one.. but I just wanted to test if my idea worked ;)
13:13:37 <bolrod> haha
13:13:57 <ndm> bolrod: yours is much nicer, now fix the other functions :)
13:14:25 <bolrod> :D
13:14:26 <bolrod> dang!
13:14:32 <aufrank> which means it's at least O(n^5 log n), I think
13:14:33 <sjanssen> hmm, maybe it would be worth it to pick through the source for Data.List
13:14:34 <Cale> aufrank: there's a nice recursive solution
13:14:41 <Cale> combs 0 _      = [[]]
13:14:41 <Cale> combs k []     = []
13:14:41 <Cale> combs k (x:xs) = map (x:) (combs (k-1) xs) ++ combs k xs
13:14:48 <bolrod> now I made it test a list of 10000 long... and now my version doesn't even show up on the graph >:(
13:14:51 <bolrod> its too fasT!!!!
13:14:52 <bolrod> :D
13:15:20 <bolrod> and the old function takes 16 seconds >:/
13:15:21 * dozer not happy
13:15:24 <Cale> aufrank: supposing that's what you mean at all :)
13:15:27 <bolrod> :)
13:15:45 <dozer> I've manually done instance Show (Process name) but my program is still not printing out any text
13:16:35 <ndm> bolrod: i could write a compiler that compiled length $ inits [1..1000] to a constant, its not that hard
13:16:43 <ndm> yours is much more suited to analysis
13:16:48 <Lemmih> dozer: Did you call 'print' or 'putStrLn'?
13:17:01 <ski> Cale : that can be written nicely in list-monad, i think
13:17:02 <aufrank> Cale: thanks-- took me a second to get my head around that
13:17:25 <bolrod> ndm: yes.. length of inits something is length something+1
13:17:29 <bolrod> everybody sees that ;)
13:17:45 <dozer> Lemmih: print
13:17:54 <dozer> here's the full code: http://pastebin.com/646748
13:18:02 <ndm> bolrod: with your definition, yes, with the original definition its non-trivial
13:18:40 <bolrod> it does build quite a large expression.. but it removes it right after it reaches the top
13:19:01 <aufrank> Cale:  that is Int -> [a] -> [[a]]?
13:19:09 <Cale> aufrank: yeah
13:19:17 * aufrank begins to get things
13:19:30 <bolrod> I'll just put it in a graph and see how the old version of inits works ;/
13:19:35 <Lemmih> dozer: And you get no output at all?
13:19:37 <Cale> :)
13:19:54 <dozer> Lemmih: nothing at all
13:19:57 <dozer> nada
13:20:16 <bolrod> but seriously... try to calculate length (inits [1..100000])  with the one in the library
13:20:27 <bolrod> I guess your computer will be at 100% CPU for a week ;)
13:20:39 <ndm> nub looks like it might be a candidate for work
13:20:40 <bolrod> well.. maybe less
13:20:50 <ndm> there are two ways to define it, not sure
13:20:53 <bolrod> well.. lets see then :)
13:21:06 <bolrod> I made my own for my 1st assignment in school
13:21:15 <bolrod> since I was too lazy to search the one in the library ;)
13:21:16 <bolrod> haha
13:21:49 <ndm> (\\) as well, that looks a bit easier even
13:21:54 <Lemmih> dozer: Works for me.
13:22:00 <ndm> i think you could eliminate at least one traverse of the list per time
13:22:04 <ndm> bolrod: hoogle :)
13:22:09 <ski> combs 0 _      = do return []
13:22:10 <ski> combs k []     = do mzero
13:22:10 <ski> combs k (x:xs) = do ys <- combs (k-1) xs
13:22:10 <ski>                     return (x:ys)
13:22:10 <ski>          `mplus` do ys <- combs k xs
13:22:10 <ski>                     return ys
13:22:13 <dozer> Lemmih: that's frustrating
13:22:15 <ski> (not tested)
13:22:16 <bolrod> deleteDouble :: Eq a=>[a] -> [a]
13:22:17 <bolrod> deleteDouble [] = []deleteDouble (x:xs) | x `elem` xs =    deleteDouble xs | otherwise   = x: deleteDouble xs
13:22:20 <dozer> could you pastebin the output?
13:22:24 <bolrod> oh.. well. and some enters
13:22:32 <Cale> ski: yeah
13:22:33 <ndm> bolrod: thats what they've got
13:22:43 <Cale> ski: minus the excessive do's even :)
13:22:44 <bolrod> hmm
13:22:46 <bolrod> they do?
13:22:51 <ndm> you can do an accumulation version as well, which has different properties
13:23:01 <ndm> (\\) looks more easy to improve
13:23:02 <JohnnyL> anyone making web apps with haskell?
13:23:04 <ski> dozer : what do you think about that version ?  (you have to 'import Control.Monad (mzero,mplus)')
13:23:22 <Cale> combs 0 _      = return []
13:23:22 <Cale> combs k []     = mzero
13:23:22 <Cale> combs k (x:xs) = fmap (x:) (combs (k-1) xs) `mplus` combs k xs
13:23:25 <ski> Cale : just trying to make it correspond more to the prolog version :)
13:23:56 <ndm> JohnnyL: yes, hoogle
13:24:00 <ndm> @where hoogle
13:24:01 <mbot> http://www.haskell.org/hoogle
13:24:05 <ski> (Cale : and also stir up his sense of side-effects ;)
13:24:06 <aufrank> what's the advantage of the monad version over the normal list version?
13:24:20 <ndm> and there are better libaries/examples than that...
13:24:26 <ski> aufrank : you may (or may not) find it clearer
13:24:30 <Cale> aufrank: well, not so much :)
13:24:33 <Cale> yeah
13:24:36 <aufrank> "or not" in this case ;)
13:25:04 <Cale> there's a function  option :: (MonadPlus m) => [a] -> m a
13:25:14 <ski> aufrank : think of 'ys <- combs (k-1) xs' as nondeterministically selecting some way of getting 'k-1' elements out of 'xs' calling them 'ys'
13:25:18 <aufrank> (which probably makes it worth getting)
13:25:26 <Cale> so there's no real need to code things like this
13:25:57 <Cale> however, there are alternatives to the list monad which do the same thing, but are faster
13:26:05 <ski> Cale : usually i'd have added 'combs :: Int -> [a] -> [[a]]' anyway :)
13:26:33 <Cale> Like the Nondet monad
13:26:44 <Cale> I wonder how well Nondet Char works for strings :)
13:27:15 <Cale> I think it would get irritating, as it's a good deal harder to write lots of the more complex manipulations.
13:29:10 <ski> Cale : i think oleg had some hackery way of making a 'case' (not 'fold') function on such representations of lists
13:29:35 <ski> (aufrank : btw, have you seen prolog ?)
13:29:56 <aufrank> yes, it's actually what I tried first for this particular project
13:30:10 <bolrod> well
13:30:15 <bolrod> I did some extensive testing!!!
13:30:16 <franka> Hm, another Frank?
13:30:21 <aufrank> but I had been attempting haskell tutorials for longer, and so certain things seemed more familiar in haskell
13:30:25 <bolrod> and came up with the following conclusion ;/
13:30:34 <aufrank> franka: last name, here
13:30:43 <bolrod> http://bolrod.homelinux.org/inits/inits-old-length-20000.pdf <<< old inits  calculating the length of [1..20000]
13:30:52 <ski> audreyt : list monad is like backtracking in prolog, if that helps ..
13:31:00 <bolrod> http://bolrod.homelinux.org/inits/inits-new-length-20000.pdf  << my version.. doing exactly the same :/
13:31:06 <bolrod> O_o
13:31:15 <aufrank> wow, what a compliment!  I've never been mistaken for audreyt before!
13:31:17 <ski> s/audreyt :/aufrank :/
13:31:23 <ski> :)
13:31:23 <bolrod> :)
13:31:40 <franka> There are too many smiley faces in this window...
13:31:44 <palomer> bbl
13:31:48 <palomer> :)
13:31:53 <ski> aufrank : 'mzero' corresponds to 'fail', and '`mplus`' corresponds to ';'
13:32:01 <franka> I am of the opinion that people should be somber and depressive.
13:32:06 <aufrank> ok, that makes a lot more sense
13:32:18 <Cale> :|
13:32:24 <franka> Thanks, Cale.
13:36:00 <robokop> bolrod: you there
13:36:59 <Muad_Dib> franka: true, the majority of people should be somber and depressive. Not us though; we are of the rare species that have Haskell!
13:38:25 <sjanssen> I am of the opinion that people should have moustaches: :-{
13:39:02 <ski> Muad_Dib : but shouldn't we be somber and depressive, since we realize that most programming languages used today sucks ?
13:40:04 <Muad_Dib> ski: I think it is just plain dumb to be somber and depressive over other peoples sorrow! Be content with what you have, do everything you can to help them, just do not take their problems into your own soul.
13:40:04 <Maddas> No, since that means that there's plenty of space for improvement left!
13:40:12 <tennin> you should be serene 
13:40:37 <araujo> Haskell is bad, it makes you hate other programming languages.
13:40:40 <Maddas> ...oh, sorry, I wasn't being serious ;-)
13:40:59 <aufrank> ok, now I've gone and got myself screwed up again
13:41:17 <tennin> it should make you serenely confident that things will improve in the fullness of time
13:41:28 <aufrank> what's going on here:
13:41:43 <aufrank> combs 0 [] [] = [[]]
13:41:51 <aufrank> combs _ [] _ = []
13:42:00 <aufrank> combs _ _ [] = []
13:42:04 <work_metaperl> .
13:42:09 <bolrod> rob|afk: yes
13:42:57 <araujo> > let combs 0 [] [] = [[]] ; combs _ [] _ = [] ; combs _ _ [] = [] in combs 1223 ["hello"] []
13:43:01 <mbot> Add a type signature
13:43:35 <aufrank> combs k (c:cs) (v:vs) = List.map ((c:v):) (combs (k-2) cs vs) ++ combs k cs vs
13:44:30 <aufrank> sorry it took so long to get the last bit out
13:44:41 <araujo> > let combs 0 [] [] = [[]] ; combs _ [] _ = [] ; combs _ _ [] = [] in combs 1223 ["hello"] [] :: [[Int]]
13:44:44 <mbot> []
13:46:27 <bolrod> omg...     is this real ?
13:46:30 <bolrod> http://video.google.com/videoplay?docid=4653448813733199771&pl=true
13:46:35 <bolrod> meteor impact!
13:47:16 <aufrank> what's the type of :  ?
13:47:29 <aufrank> and how do I check it with :type?
13:48:02 <RyanT5000> @type (?)
13:48:04 <mbot> Not in scope: `?'
13:48:17 <aufrank> no no, the type of :
13:48:18 <aufrank> sorry
13:48:23 <aufrank> @type(:)
13:48:24 <mbot> Unknown command, try @listcommands.
13:48:32 <RyanT5000> @type (:)
13:48:33 <aufrank> @type (:)
13:48:34 <mbot> forall a. a -> [a] -> [a]
13:48:40 <mbot> forall a. a -> [a] -> [a]
13:52:04 <JohnnyL> how does hoogle serve? 
13:53:37 <ndm> JohnnyL: raw Haskell, the source is available
13:53:48 <ndm> it has a very small CGI module
13:53:58 <ndm> and is compiled to a binary
13:54:37 <aufrank> Cale: in my version of the combs, where I'm trying to draw from two lists in an alternating way, what's the right function to use in the map?  I can't get the ((c:v):) portion right.
13:54:50 <JohnnyL> i am stuck in xml-java configurations hell and are looking for alternatives.
13:54:53 <aufrank> combs k (c:cs) (v:vs) = List.map ((c:v):) (combs (k-2) cs vs) ++ combs k cs vs
13:55:51 <xerox> ((c:v):) === (c:v:)
13:59:01 <aufrank> so if I pass in combs 4 "abc" "def", why do I get an error "Couldn't match `[Char]' against `Char'"
13:59:32 <aufrank> about the ((c:v):) section?
14:04:12 <ARous1984> whats a quick and dirty way to check if a list of lists has any equal elements in it?
14:06:06 <aufrank> you could remove them by turning it into a set:  Data.Set.fromList(lol)
14:06:19 <aufrank> (but I largely don't know what I'm talking about ;))
14:08:23 <int-e> I guess Data.List.nub l == l  works quite well (but not perfectly, it fails on [1,1..])
14:08:25 <bolrod> sjanssen: are you good at analyzing a set of points ? ;)
14:08:40 <sjanssen> bolrod: not really
14:08:48 <bolrod> hehe
14:08:54 <bolrod> I ran that inits a few tims
14:08:55 <bolrod> times
14:08:56 <ski> @type \c v -> (c:v:)
14:08:59 <bolrod> asking the length
14:09:00 <mbot>   The operator `:' [infixr 5] of a section
14:09:00 <mbot>    must have lower precedence than the operand `(:)' [infixr 5]
14:09:20 <bolrod> and it went relatively ok to [1..20000]
14:09:24 <bolrod> taking 24 seconds
14:09:26 <aufrank> ski-- I've seen that one!  what does it mean?
14:09:31 <ski> @type \c v -> List.map (\foo -> c:v:foo)
14:09:31 <bolrod> though to 21000 it takes 44
14:09:33 <mbot> forall a.
14:09:33 <mbot>              a -> a -> [[a]] -> [[a]]
14:09:36 <bolrod> and to 22000 it takes 88
14:09:37 <bolrod> :D
14:09:42 <ski> aufrank : use 'List.map (\foo -> c:v:foo)'
14:09:58 <ski> aufrank : it means that that was a parse error
14:10:08 <sjanssen> bolrod: doing length of inits?
14:10:25 <bolrod> yes
14:10:46 <sjanssen> I'd say that's allocation overhead
14:11:00 <bolrod> I dont see it using any swap.. so I dont think its that
14:11:02 <aufrank> ski:  thanks!  it also worked to do map ([c,v] ++)
14:11:27 <bolrod> nah.. because when I restarted the ghci. it took about just as long to 8000 as from first 1000 to 8000 
14:11:39 <bolrod> does ghci allocate things even after it closes down?!
14:11:39 <bolrod> :)
14:11:54 <ski> aufrank : yes, that could be clearer, in this case
14:11:54 <bolrod> I guess 23000 is going to take 190 seconds 
14:12:23 <bolrod> so length(inits [1..100000])  could indeed take a week :D
14:12:31 <bolrod> no...  its 96 ;/
14:12:47 <ski> aufrank : also 'List.map cons_c_and_v' with 'where cons_c_and_v foo = c:v:foo' added after the body, will work
14:12:50 <sjanssen> I would think we'd get a pretty nice linear trend going
14:13:06 <aufrank> ski, I get that
14:13:10 <aufrank> thank you!
14:13:20 <bolrod> this is the inits in the lib I'm talking about ofcourse
14:14:07 <int-e> > let has_dups l = and $ map (\l -> null l || not (head l `elem` tail l)) $ tails l in map has_dups [[1,2,3], [1,2,3,2], [1,1..]]
14:14:11 <aufrank> ok, gotta head home
14:14:13 <mbot> [True,False,False]
14:14:16 <aufrank> thanks for the help folks
14:14:27 <int-e> that version is clean.
14:14:28 <sjanssen> bolrod: oh, in that case, who knows how space behavior will be!
14:14:47 <bolrod> this behaviour is really weird ;/
14:15:02 <int-e> (and it'd be shorter if there'd be a version of tails that doesn't return the empty list - is there?)
14:15:35 <bolrod> with length (inits [1..20000]) its 24 seconds
14:15:41 <bolrod> with length (inits [1..21000]) its 44 seconds
14:15:49 <sjanssen> I imagine GHC only cleans up all the map (x:) thunks every once in a while, so you get different rsults when GC kicks in?
14:15:49 <bolrod> with length (inits [1..23000]) its 88 seconds
14:16:00 <bolrod> then it seams to get liniair again
14:16:16 <ARous1984> How expensive is the ++ operator?
14:16:24 <bolrod> depends on how you use it
14:16:50 <bolrod> n++x  is probably (length n * (:))
14:16:53 <bolrod> no?
14:17:27 <ARous1984> And the : operator is less expensive, right?
14:17:33 <ARous1984> Since it just inserts an item at the front?
14:17:44 <sjanssen> yeah, (:) is O(1)
14:18:34 <bolrod> either way....  if that bytes thing with the :set +s  is the garbage collection...
14:18:49 <bolrod> then its collecting 10GB of garbage for length (inits [1..24000])
14:18:50 <bolrod> haha
14:19:07 <bolrod> 10GB ... man.. I never thought it would process THAT much 
14:19:45 <sjanssen> it's possible that bytes is lying in some way
14:20:22 <ARous1984> What's the order of !! operator? N?
14:20:28 <ARous1984> or 1?
14:20:33 <int-e> (!!n) is O(n)
14:20:42 <ARous1984> say (list !! 0) ?
14:21:27 <int-e> well, that's O(1) because 0 is constant - it's rather cheap too.
14:21:37 <ARous1984> cheap as in cost?
14:21:45 <ARous1984> =)
14:21:54 <int-e> yes
14:21:57 <bolrod> sjanssen: first lets see what that bytes really counts
14:22:16 <int-e> it's a cheap O(1) operation. There are expensive O(1) operations, too. (!! 1000000) would be one.
14:23:49 <jyp> > [0..1000000] !! 1000000
14:23:53 <mbot> 1000000
14:23:58 <ARous1984> im doing a lot recursion, and it involves ++
14:24:09 <ARous1984> It's rather slow...damn ++ operator =p
14:24:12 <jyp> > [0..] !! 1000000
14:24:15 <mbot> Exception: stack overflow
14:24:35 <jyp> > [0..] !! 1000000::Int
14:24:37 <mbot> 1000000
14:25:03 <sjanssen> ARous1984: there are ways to avoid ++, checkout ShowS
14:25:12 <ARous1984> so it better to implement a counter and have that count each iteration until a counter equals an index
14:25:15 <bolrod> The memory use statistics do odd things, such as reporting zero use and varying a lot. What should I do? 
14:25:18 <bolrod> This is because memory use statistics are calculated on garbage collections. For quick / small functions this may not happen, hence the zero; in other cases the GC doesn't happen at fixed points in the code, so the numbers vary. The simple answer is to ignore memory use, or at least only consider the numbers in very broad terms averaged over multiple runs of your code.
14:25:22 <ARous1984> rather than doing (list !! index) ?
14:25:57 <sjanssen> I'd say average, or use very large inputs such that GC will happen at some point
14:26:03 <ARous1984> and instead list becomes (x:xs) and just pickoff x until it reaches the right count.
14:26:22 <bolrod> I think.. if you first get  list!!n
14:26:25 <bolrod> and then list!!n+1
14:26:26 <sjanssen> Arous1984: that is exactly what you should do
14:26:38 <bolrod> the 2nd time it only takes !!1  times more
14:26:49 <bolrod> dont know for sure though
14:27:02 <bolrod> > [0..] !! 10000 ::Int
14:27:02 <sjanssen> bolrod: you can't usually rely on the compiler optimising that
14:27:04 <mbot> 10000
14:27:08 <bolrod> > [0..] !! 10001 ::Int
14:27:10 <mbot> 10001
14:27:14 <bolrod> hmm
14:27:16 <int-e> > let inits' xs = [[]] ++ inits'zip' xs (inits' (tail xs)); inits'zip' [] _ = []; inits'zip' (x:xs) ~(y:ys) = (x:y) : inits'zip' xs ys in length $ inits' [1..200000]
14:27:19 <mbot> 200001
14:27:39 <int-e> there's a lazier inits function.
14:27:57 <ARous1984> so
14:27:57 <ARous1984> let f n = replicate (n^4)[1..n^2] in f n
14:28:02 <ARous1984> is that a bad thing to do over and over?
14:28:10 <bolrod> int-e: is it faster?
14:28:21 <ARous1984> it just builds a list of lists size n^4, each with a list of 1..n^2
14:28:41 <ARous1984> sjannssen: What is ShowS?
14:28:48 <sjanssen> Arous1984: the lists will be shared, so it will only take n^2 + n^4 memory
14:29:03 <int-e> bolrod: for your use case, where you never look at the actual lists produced, it is; if you use the lists, as in map length $ inits [1..2000], it's slower
14:29:16 <bolrod> sjanssen: ok... I dont know whats going on...    all of a sudden.. it took just 37 seconds to complete length(inits [1..27000])
14:30:01 <int-e> bolrod:  err, sum $ map length $ inits [1..2000]
14:30:19 <ARous1984> ah, n is at most 4
14:30:21 <ARous1984> so i dont think its that bad.
14:30:25 <sethk> hello, all.  I've created a class and made an instance of it, and I'm trying to invoke the class implementation of a function
14:30:37 <sethk> but I'm coding something wrong as the compiler doesn't understand me
14:30:38 <sjanssen> ShowS is a bit of an advanced technique, the idea is you keep a function :: [a] -> [a] rather than actual lists.  this way you can append a bunch of lists together cheaply
14:30:56 <sethk> I have a function "get".  but the compiler is saying "not in scope:  get"
14:30:59 <ARous1984> sjannsen: Is this explained anywhere?
14:31:15 <ARous1984> sjansen: Perhaps a wiki?
14:31:19 <sethk> I'll put it on a paste bot...
14:31:21 <ARous1984> err, i cant spell :P
14:31:32 <cinema> shapr, I tried to take the 'haskell.eu' domain today, but my registrar was too slow and I missed it
14:31:45 <cinema> shapr, do you know who took it ?
14:31:55 <bolrod> damn... I dont know what the hell the ghci thinks its doing!
14:32:20 <wchogg> What's ghci doing wrong?
14:32:35 <bolrod> length(inits[1..26000])  takes 130 seconds...   then length(inits[1..27000])  takes 37 seconds!
14:32:42 <bolrod> then I try again .. takes 39 seconds
14:32:58 <bolrod> length (inits [1..28000]) takes 61 seconds! :/
14:33:03 <wchogg> What do you get if you actually compile it?
14:33:04 <bolrod> eH?!
14:33:25 <bolrod> dont know... but is ghci getting faster at some more complex arguments?
14:33:28 <bolrod> or bigger arguments
14:33:29 <int-e> bolrod: simple, it constructs n*(n-1)/2 list nodes. And from time to time, it does a garbage collection.
14:33:39 <sjanssen> Arous1984: can't find anything, sorry
14:33:48 <bolrod> yeah.. but why does the bigger argument take less time then?
14:33:54 <sjanssen> bolrod: this makes no sense
14:33:59 <bolrod> indeed it doesn't
14:34:00 <int-e> bolrod: did you try 26000 again?
14:34:09 <bolrod> lets see then
14:34:11 <sethk> http://paste.ubuntu-nl.org/11709
14:34:31 <sethk> I've pasted my attempt to use a class.  What have I coded incorrectly?
14:34:51 <bolrod> int-e: its taking awfully long
14:34:58 <bolrod> ok ;)
14:35:00 <bolrod> can't really say yet
14:35:18 <bolrod> this makes no sense!
14:35:52 <bolrod> so hey.. I want to calculate the length of inits [1..26000]... but [1..27000]  which is obviously WAY more work
14:35:55 <bolrod> takes less time
14:36:02 * int-e ponders doing map reverse $ tails $ reverse [1..n]
14:36:28 <bolrod> int-e: [1..26000] takes 128 seconds
14:36:31 <bolrod> you explain
14:36:38 <bolrod> after I did the 27000 and 28000
14:36:40 <bolrod> doing those again
14:36:55 <bolrod> sjanssen: do you have any reasonable explanation for this?
14:37:08 <sjanssen> bolrod: I am testing on my computer
14:37:50 <bolrod> maybe its taking more time now.. I really dont know O_o
14:37:56 <bolrod> its weird
14:38:10 <bolrod> lets label that as 'failed measurements'
14:38:13 <bolrod> hehe
14:38:30 <int-e> bolrod: anyway, it's silly. why don't you just use (+1)? ;)
14:38:39 <bolrod> hehe
14:38:53 <bolrod> I'm just testing to see what O(..)   the inits function has
14:38:58 <int-e> try ghci +RTS -H32m
14:39:00 <int-e> O(n^2)
14:39:02 <bolrod> but I guess it has O(quiteRandom)
14:39:18 <bolrod> it doesn't seem to be like that!
14:39:20 <int-e> operationally. it creates n*(n-1)/2 list conses.
14:39:36 <sjanssen> int-e: only if you look at all of them, of course
14:39:41 <int-e> sjanssen: no
14:39:48 <int-e> sjanssen: always, look at the definition :)
14:40:03 <bolrod> I'll just put it in the pastebin
14:40:16 <sjanssen> ack! you're right
14:40:26 <sethk> anyone want to look at this post?  http://paste.ubuntu-nl.org/11709
14:40:54 <sjanssen> sethk: what kind of error do you receive?
14:40:59 <int-e> sjanssen: (which is why I posted the lazier version of inits a few minutes ago)
14:41:03 <bolrod> http://pastebin.com/646904 <<
14:41:09 <sethk> sjanssen, "not in scope  'get'"
14:41:19 <sethk> sjanssen, get has a default implementation in the class
14:42:03 <sjanssen> sethk: try importing ClientServer in your Main module
14:42:06 <lisppaste2> wchogg pasted "Is this stupid?" at http://paste.lisp.org/display/18756
14:42:17 <sethk> sjanssen, k, hold on...
14:42:17 <int-e> bolrod: I'm serious about using ghci +RTS -H32m btw. This should make the garbage collector much less erratic.
14:42:22 <sjanssen> int-e: have you seen the inits bolrod and I have written?
14:42:29 <int-e> sjanssen: no
14:42:46 <bolrod> int-e: yours isn't too bad
14:42:46 <sethk> sjanssen, ok, now I get a different error.  thanks, I'll see if I can figure this out...
14:42:48 <bolrod> still.. its a tad slower
14:42:55 <bolrod> and WAY more complicated to understand
14:43:00 <sjanssen> int-e: inits xs = [] : (zipWith take [1..] $ map (const xs) xs)
14:43:14 <sethk> sjanssen, thanks, got it.
14:43:22 <sjanssen> I love the map (const xs) trick
14:43:31 <bolrod> int-e: and yours isn't too lazy 
14:44:01 <bolrod> *Main> length (inits' [1..1000000])
14:44:01 <bolrod> 1000001
14:44:01 <bolrod> (0.67 secs, 156766620 bytes)
14:44:01 <bolrod> *Main> length (inits2' [1..1000000])
14:44:01 <bolrod> 1000001
14:44:04 <bolrod> (1.74 secs, 140603548 bytes)
14:44:07 <int-e> sjanssen: oh. right, but why not zipWith take [0..] $ repeat xs ?
14:44:10 <bolrod> see... ours is lazier
14:44:11 <bolrod> :D
14:44:13 <int-e> sjanssen: on
14:44:17 <bolrod> int-e: then it wont stop
14:44:19 <bolrod> ;)
14:44:27 <int-e> bolrod: right. sorry.
14:44:42 <bolrod> my first attempt had that problem
14:44:46 <ARous1984> so, if im doing list !! index, where index is at most going to be at most 255, do i really need to worry about time complexity for that?
14:44:58 <ARous1984> take on of those at mosts out ;)
14:45:09 <bolrod> or.. well.. it couldn't handle infinite lists
14:45:21 <bolrod> 255 isn't much
14:45:41 <bolrod> unless you're going to use it an awfull lot of times
14:46:18 <ARous1984> and then instead, i should write another function that takes the list, a counter, and then get x from xss that way?
14:46:23 <ARous1984> xs, that is.
14:47:07 <bolrod> *Main> sum (take 100000 (map (!!255) (repeat [1..])))
14:47:07 <bolrod> 25600000
14:47:07 <bolrod> (0.25 secs, 9984896 bytes)
14:47:12 <bolrod> I dont think its a big deal..
14:47:18 <bolrod> you better write your whole program first
14:47:25 <bolrod> then look where the time problems are
14:47:35 <bolrod> you optimize after you wrote the code
14:47:36 <bolrod> not before
14:47:37 <bolrod> ;)
14:47:53 <ARous1984> my code is written
14:48:00 <bolrod> 90% of the time is in 10% of the code
14:48:00 <ARous1984> im looking for where its slowing down now :)
14:48:06 <bolrod> use some profiler
14:48:08 <bolrod> or something
14:48:08 <int-e> bolrod: mine evolved from inits' xs = [[]] ++ zipWith (:) xs (inits' (tail xs)) - which is simple enough, but not lazy as I wanted, because zip keeps forcing the second argument.
14:48:10 <bolrod> to look
14:48:19 <int-e> bolrod: at that point it was still quite simple :)
14:48:33 <bolrod> ah :)
14:48:38 <ARous1984> could you recommend a profiler or a point in the direction of where to find out about profilers? ive never profiled haskell code before.
14:49:00 <bolrod> dont know... is next lecture I guess for me :)
14:49:01 <bolrod> hehe
14:49:03 <wchogg> Doesn't the ghc manual have a good bit about doing profiling?
14:50:05 <bolrod> or try some basic things yourself if your code isn't too big
14:50:13 <bolrod> look for the loops 
14:50:21 <bolrod> recursive functions etc.
14:50:47 <bolrod> maybe its doing things twice that can be done in one time
14:51:13 <bolrod> or force some things to not be lazy
14:51:28 <bolrod> I thought the $! was the forcing to not be lazy eh ?
14:51:41 <boy> i'm having a really hard time getting the types right for describing the instructions in an assembly language
14:51:47 <bolrod> so it doesn't build huge expressions where it doesn't need to
14:52:52 <ARous1984> Well, I'm using the ++ operator a lot.
14:53:03 <ARous1984> so I need to figure out another way to compose my lists in those cases :)
14:53:06 <bolrod> then look if its building the lists from the right side up
14:53:09 <bolrod> and not from the left side
14:53:54 <bolrod> (xs++ys)++zs  takes more time then  xs ++ (ys++zs)
14:55:32 <tennin> what's the purpose of this max-256 list?
14:55:55 <bolrod> something to do with bitmaps?
15:00:05 <ARous1984> sudoku puzzle solver
15:00:13 <ARous1984> up to order 4 puzzles
15:00:18 <ARous1984> an order 4 puzzle has 256 entries
15:00:26 <ARous1984> order 3 has 81
15:00:28 <ARous1984> etc.
15:00:38 <bolrod> whats order 4 puzzle?
15:00:42 <RyanT5000> i've designed a datastructure to provide copyless access to multiple versions of a usually-immutable object
15:00:45 <ARous1984> 16x16 sudoku puzzle
15:00:47 <bolrod> you get a 12x12 sudoku?
15:00:56 <RyanT5000> but i'm not quite sure how to implement it
15:01:02 <bolrod> hrmmmm
15:01:06 <int-e> 3x4 boxes of 4x3 size - why not
15:01:41 <lisppaste2> RyanT5000 pasted "Code so far" at http://paste.lisp.org/display/18757
15:01:46 <Cale> I've seen Sudoku puzzles with completely irregular regions
15:02:25 <Cale> http://www.menneske.no/sudoku/irr/3/eng/
15:03:03 <Cale> not to mention http://www.menneske.no/sudoku/irrdg/3x3/eng/
15:03:23 <tennin> is sudoku the new 8 queens?
15:03:35 <Cale> Somewhat, yeah
15:03:56 <ARous1984> Our project stipulates only nxn blocks
15:04:02 <ARous1984> and a n^2 x n^2 overall puzzle
15:04:10 <int-e> hmm. it's a bit harder to solve efficiently (even the standard 3^2x3^2 one)
15:04:22 <Cale> One thing I'd really like to see is a decent generator for nurikabe puzzles.
15:04:47 <Cale> The best generator I've managed to find on the web only generates 5x5 puzzles which are far too easy
15:05:11 <bolrod> now my computer is thrashing
15:05:11 <bolrod> 8)
15:05:17 <ARous1984> i love boot camp
15:05:25 <ARous1984> now i can play PC games on my G5 desktop, wewt :D
15:05:26 <bolrod> ok that was NOT! good
15:05:30 <RyanT5000> haha 9x9
15:07:03 <bolrod> :)
15:07:37 <bolrod> solving sudoku's is quite fun :)
15:07:45 <bolrod> just read up on the tricks to solve them quickly
15:07:59 <RyanT5000> i don't reallly enjoy doing them by hand
15:08:03 <bolrod> its not hard
15:08:13 <bolrod> there are just some methods you need to use
15:08:16 <RyanT5000> i feel like a prolog interpreter
15:08:17 <bolrod> and you can solve most of them
15:08:18 <sjanssen> writing programs to do it is more fun for me
15:08:34 <bolrod> writing them so they can solve it in 0.01 seconds is ok yes
15:08:35 <bolrod> ;)
15:08:46 <bolrod> writing a program that can MAKE a sudoku puzzly
15:08:48 <bolrod> puzzle
15:08:57 <bolrod> and prove it has only 1 solution 
15:08:58 <bolrod> ;)
15:09:14 <sjanssen> I haven't come across any good algorithms to do that
15:09:25 <RyanT5000> how do people store sudoku puzzles?
15:09:32 <sjanssen> dancing links could be adapted, I suppose
15:09:41 <RyanT5000> they seem like they shouldn't be stored as an array
15:09:49 <RyanT5000> (i.e.: as layed out on the page)
15:10:01 <Cale> An array isn't so bad, at least at the sizes which people normally use
15:10:19 <Cale> Unless you're going to implement DLX.
15:10:35 <Cale> (Dancing Links implementation of Knuth's Algorithm X)
15:12:14 <bolrod> dang.. the Times had a great sudoku :D
15:12:20 <bolrod> but hard to solve on a computer though...
15:12:28 <bolrod> well.. the implementing part might be a bit difficult
15:13:00 <sjanssen> bolrod: why is it hard to solve on a computer?
15:13:29 <sjanssen> just a tough example?
15:13:45 <bolrod> I'm searching it
15:14:15 <bolrod> http://mmdownload.interoutemediaservices.com/%7Bbc1915ab-648e-4fb8-94ef-12f9747146a7%7D/%7Bbf3a3d24-d044-4785-8abd-38bb18442cea%7D/shogun4.pdf
15:14:19 <bolrod> :]
15:14:32 <bolrod> aye
15:14:39 <sjanssen> cool
15:14:40 <Cale> Someone should construct a ternary determination puzzle which incorporates the life-death status of go groups as part of the clues.
15:14:52 <int-e> fun.
15:15:00 <sjanssen> a dancing links solver could be adapted to that one, pretty easily
15:15:40 <Cale> That would pretty much make it brutal to solve on a computer :)
15:16:20 <bolrod> I think the trick is you need to solve the thing as a whole....
15:16:42 <bolrod> so.. in order to get for instance.. 1 number.. you need to be working from half way across the field to get to that number
15:16:48 <bolrod> I've solved a bit of it already
15:17:09 <Cale> What I don't understand is why people like sudoku so much, but don't seem too interested in other Japanese puzzles.
15:18:05 <mathrick> flatten Leaf = []
15:18:06 <mathrick> flatten (Node left (MkAssoc val size) right) = flatten left `seq` flatten right `seq` val `seq` flatten right ++ [val] ++ flatten left
15:18:06 <mathrick> does this do what I mean, assuming that (Leaf) and (Node Tree val Tree) are trees?
15:18:34 <mathrick> by do what I mean, I mean I want to force full evaluation of the flattened list
15:18:36 <bolrod> holy crap!
15:18:37 <bolrod> http://mmdownload.interoutemediaservices.com/%7Bbc1915ab-648e-4fb8-94ef-12f9747146a7%7D/%7Bbf3a3d24-d044-4785-8abd-38bb18442cea%7D/shogun5.pdf
15:18:41 <bolrod> check the killer ones
15:18:41 <bolrod> :D
15:19:40 <bolrod> man.. where do you start !O_o
15:19:43 <sjanssen> that is just ridiculous
15:20:06 <bolrod> you said it!
15:20:09 <Cale> there was a really nice puzzle I found the other day, ah, here it is: http://zotmeister.livejournal.com/2977.html
15:20:22 <Cale> Smullyanic Dynasty :)
15:21:05 <Cale> Each of the squares is a knight or a knave, and answers the question "how many knaves are in your (3x3) domain?"
15:21:08 <bolrod> sjanssen: who made those puzzles O_o!!
15:21:09 <bolrod> :D
15:21:19 <Cale> and it's up to you to determine which are knaves and which are knights
15:21:45 <Cale> it's pretty easy once you get the hang of it, but nice :)
15:21:48 <mathrick> so, any takers?
15:22:20 <sjanssen> Cale: reminds me of minesweeper
15:22:25 <Cale> mathrick: seems fine
15:22:28 <Cale> sjanssen: yes
15:22:56 <Cale> sjanssen: http://zotmeister.livejournal.com/2812.html -- another really nice one, quite a lot like slither-link
15:22:59 <bolrod> just cross out every field that can't be a knave ?
15:23:09 <bolrod> starting at the field with 0 knaves around it
15:23:40 <mathrick> Cale: aha, because it doesn't seem to work fine. Another function which operates on that list later crashes in different places depending on whether I return left or right subtree or value first, and the only explanation of that I can see is lazy eval
15:23:48 <mathrick> which is not supposed to happen
15:24:06 <bolrod> I guess I really need to eat something! >:/
15:24:07 <Cale> mathrick: oh
15:24:13 <bolrod> hmm... which reminds me
15:24:20 <bolrod> I didn't really eat anything this evening
15:24:23 <bolrod> not alot anyway
15:24:25 <Cale> mathrick: actually, you shouldn't leave it up to CSE
15:24:50 <mathrick> CSE?
15:25:04 <Cale> flatten (Node left (MkAssoc val size) right) = let l = flatten left; r = flatten right in l `seq` r `seq` val `seq` r ++ [val] ++ l
15:25:16 <Cale> are you sure you want the list in reverse order like that?
15:25:33 <mathrick> Cale: yes, I'm trying to shotgun debug one algorithm :)
15:26:01 <Cale> why so much strictness?
15:26:05 <mathrick> Cale: now, why does it looke like it does?
15:26:10 <Cale> for debugging?
15:26:14 <mathrick> Cale: yes
15:26:27 <mathrick> I need the following function to always complete, not die with empty list
15:26:49 <mathrick> and it damn shouldn't depend on how exactly I build my list, IMHO
15:27:00 <Cale> which function?
15:27:11 <mathrick> Cale: to build a btree from a list
15:27:24 <Cale> if something dies completely, there ought to be a glaring reason :)
15:27:39 <Cale> How exactly does it die?
15:27:53 <mathrick> Cale: yes, like someone not exactly understanding how it works ;)
15:28:06 <mathrick> *DictTree> flatten (mkDTree (flatten (Node (Node (Node Leaf (MkAssoc 1 20) Leaf) (MkAssoc 2 30) (Node Leaf (MkAssoc 3 23) Leaf)) (MkAssoc 4 10) (Node (Node (Node Leaf (MkAssoc 5 20) Leaf) (MkAssoc 6 20) Leaf) (MkAssoc 7 30) (Node Leaf (MkAssoc 8 23) Leaf)))))
15:28:06 <mathrick> *** Exception: Prelude.head: empty list
15:29:27 <Cale> well, where are you calling head?
15:29:51 <Cale> probably in mkDTree?
15:30:34 <Cale> you should probably use a case there instead, and have it at least return a more informative error
15:32:11 <mathrick> Cale: case?
15:32:47 <mathrick> Cale: the thing is, mkDTree is copy-pasted from a book, and I'm trying to tweak it into doing what I want :)
15:33:01 <Cale> okay, well, can I see it?
15:33:04 <mathrick> sure
15:34:14 <mathrick> Cale: the interesting line I'm tweaking is | otherwise = (Node xt (MkAssoc (head zs) 20) yt, tail zs)
15:34:19 <Cale> seq is a really difficult way to debug. Debug.Trace is better if you really need it, and actually understanding your code is better still (often by trying to break it into its constituent parts)
15:34:27 <mathrick> oops
15:34:28 <mathrick> http://pastebin.com/646984
15:35:02 <mathrick> Cale: nah, I don't fully understand the algorithm, not the haskell code
15:35:08 <Cale> okay, so eventually, either xs = [], or zs = []
15:35:13 <mathrick> yeah
15:35:21 <Cale> let's figure out which
15:36:53 <Cale> http://pastebin.com/646994
15:37:00 <mathrick> Cale: if I play around with flatten enough, I can also get tail to throw exception
15:37:20 <Cale> head and tail are really unsafe
15:37:31 <ndm> I'd also like to see what n is in the otherwise
15:37:38 <Cale> actually, let me rewrite that code some more
15:38:59 <Cale> there, refresh
15:39:32 <mathrick> Cale: it's not actually refresh in pastebin
15:39:35 <mathrick> the link changes
15:39:40 <mathrick> but I got it
15:39:45 <Cale> I'm amending it
15:39:51 <Cale> So the id is the same
15:40:11 <Cale> hmm, perhaps not :)
15:40:19 <Cale> maybe that was some other pastebin
15:41:56 <mathrick> okay, so xs is null
15:46:10 <Cale> okay
15:46:25 <Cale> ah
15:46:54 <Cale> if n == 1, then presumably xs has 1 element left
15:47:19 <Cale> (or it's supposed to)
15:47:55 <mathrick> yeah
15:48:12 <mathrick> it worked before we starting playing with it, too :>
15:48:18 <mathrick> there's only one slight problem
15:48:35 <mathrick> the btree the algorithm constructs has values only in leaves
15:48:41 <mathrick> which is kinda useless
15:48:59 <mathrick> so the plan is to make it insert useful values into nodes
15:49:14 <Cale> this would be much better served by a state monad
15:49:48 <Cale> or even better would be a supply monad, but that's just a state monad in disguise :)
15:49:53 <mathrick> humm?
15:50:26 <mathrick> Cale: well, the root problem is to build a bsearch tree in a linear time from a sorted list
15:50:55 <Cale> yeah
15:51:01 <mathrick> because we thought of it as a clever and easy way to escape the need of thinking up a perfect balancing algorithm
15:51:22 <Cale> You're doing this fiddly state manipulation, which should really be abstracted a little
15:51:30 <mathrick> okay
15:51:37 <mathrick> I have no exp with state monad
15:55:05 <Cale> let me just write something :)
15:57:44 <newsham> hi
15:57:58 <RyanT5000> how do you decide what order parameters of a function should be in?
15:58:46 <Cale> RyanT5000: fastest changing last
15:58:55 <RyanT5000> alright
15:58:59 <newsham> try an order and change it if you have to?  :)
15:59:03 <RyanT5000> so find :: Container -> Slot -> Object
15:59:15 <RyanT5000> that'd obey fastest changing last
15:59:28 <RyanT5000> in C++ it was usually "has a default last"
16:03:08 <RyanT5000> what does !! mean before a type constructor parameter?
16:03:19 <RyanT5000> as in
16:03:20 <RyanT5000> data Map k a = Tip | Bin !!Data.Map.Size !k a !(Map k a) !(Map k a)
16:03:48 <ncalexan> dons: did you ever look at the hs-plugins on Mac OS X issues?
16:05:39 <Cale> dinner -- let me just paste what I have (has a similar problem -- stack overflows)
16:06:05 <Cale> http://pastebin.com/647034
16:06:11 <Cale> I'll help fix it after :)
16:06:43 <RyanT5000> what's the difference between a FiniteMap and a Map?
16:06:53 <newsham> FiniteMap is deprecated, apparently
16:06:56 <ncalexan> FiniteMap has been deprecated.
16:07:00 <RyanT5000> oh
16:07:02 <RyanT5000> that's a good difference :)
16:14:12 <newsham> what happened to unBlockSignals and getErrorCode.  what supercedes those?
16:14:37 <Cale> okay
16:14:38 <Cale> back
16:15:45 <Cale> now, let me look at what this is actually doing :)
16:16:12 <Cale> ah, I see
16:17:04 <Cale> oh, that's a little odd :)
16:20:49 <newsham> where can I find src code to the ghc libraries?
16:21:51 <sethk> what does this message mean?
16:21:58 <sethk> Ambiguous constraint `Request request'
16:21:58 <sethk>         At least one of the forall'd type variables mentioned by the constraint
16:21:58 <sethk>         must be reachable from the type after the '=>'
16:22:27 <Lemmih> newsham: darcs.haskell.org/packages/
16:23:33 <Lemmih> > undefined :: Ord a =>  Bool
16:23:34 <mbot>   Ambiguous constraint `Ord a'
16:23:34 <mbot>    At least one of the forall'd type variables mentioned by the constraint
16:23:34 <mbot>    must be reachable from the type after the '=>'
16:23:36 <araujo> Hello around here
16:23:58 <sethk> Lemmih, what does "reachable" mean here?
16:24:03 <sethk> araujo, hello
16:24:08 <araujo> oh hi sethk !
16:24:08 <newsham> there's no "a" in "Bool"
16:24:17 <Lemmih> sethk: It means that you're not using 'request' after the '=>'
16:24:27 <araujo> sethk, you are the guy who develops bussiness appli on haskell? :-)
16:24:35 <sethk> araujo, yes
16:24:44 <sethk> Lemmih, but I am.  at least it looks to me as if I am  :)
16:24:45 <araujo> sethk, may privmsg?
16:24:49 <araujo> may i*
16:24:52 <sethk> araujo, sure
16:25:12 <Lemmih> sethk: You probably typo'ed it.
16:25:18 <sethk> Lemmih, I'm looking 
16:26:01 <newsham> sethk: what types of apps?
16:26:11 <Lemmih> RyanT5000: !! means that the argument is unboxed, btw.
16:26:36 <sethk> newsham, I've got to take a phone call (otherwise it will be no kinds of apps  :)  ).  I'll be back shortly
16:26:48 <RyanT5000> ah ok thanks
16:26:51 <newsham> ryan/lemmih: someone should put that on the wiki (http://www.haskell.org/hawiki/Keywords)
16:35:06 <vincenz> anyone can explain me something simple
16:35:12 <vincenz> what determines how much a price goes up when stocks are sold?
16:35:24 <newsham> i thought you said "simple"
16:35:32 <vincenz> :D
16:35:43 <vincenz> I'd like to make a realistic agent simulation in haskell
16:35:46 <newsham> what causes weather?
16:35:48 <vincenz> just can't find any good litearture
16:35:51 <vincenz> nono
16:35:54 <vincenz> when a specific stock goes up
16:35:58 <vincenz> I mean is bought 
16:35:59 <vincenz> it goes up
16:36:03 <vincenz> I'm not asking for predictive laws
16:36:04 <vincenz> just
16:36:08 <vincenz> a buys X
16:36:10 <vincenz> X goes up
16:36:14 <newsham> the market is a double auction.
16:36:15 <ncalexan> Look for a counterexample.  It does _not_ always go up!
16:36:24 <newsham> there are bidders bidding on buying and bidders bidding on selling
16:36:55 <vincenz> I'm trying to decide the causal factor that makes it go up
16:37:14 <irc> theres a list of prices that different people are willing to pay
16:37:16 <Lemmih> vincenz: Like the guy in Pi?
16:37:16 <newsham> supply and demand 
16:37:19 <int-e> vincenz: it could go down, too, I think.
16:37:26 <vincenz> Lemmih: not quite
16:37:32 <Cale> aha
16:37:34 <vincenz> I'd just like to make a nice social simulation system
16:37:36 <irc> like I will sell at $1 and person B will sell at $2
16:37:38 <vincenz> have little agents run around
16:37:39 <vincenz> they need food
16:37:47 <vincenz> and eventually I want to get a little economy going
16:37:48 <irc> if you buy, you're gonna buy the $1 one.
16:37:54 <irc> which takes me off the liist
16:37:55 <Cale> mathrick: okay, I think I have some idea where the problem is
16:38:00 <vincenz> but it's insane to expect an economy to emerge by pure alifing
16:38:02 <irc> and the next person to come along picks the best price, which is $2
16:38:07 <Cale> mathrick: this only works for specific sized lists
16:38:08 <vincenz> so I want to have some low-level bound of abstraction
16:38:09 <int-e> vincenz: imagine there's a single buyer who's highly interested in the stock. once he's bought the stuff noone seems to be interested in it anymore - will the price grow or fall?
16:38:13 <irc> thus the price has gone "up"
16:38:35 <vincenz> irc: define "picks the best price"
16:38:55 <irc> int-e: well, there's at least three prices really... "i'll buy some at this price", "I'll sell some at this price" and the "last trade" price
16:39:02 <irc> dude
16:39:05 <irc> is my nick irc?
16:39:09 <vincenz> int-e: yeah
16:39:12 <morans> lame
16:39:12 <Cale> also, the length calculations seem off to me
16:39:13 <vincenz> irc: yea
16:39:20 * vincenz hmms
16:39:28 <int-e> benc: the last trade price should be irrelevant - but people aren't rational beings.
16:39:29 <vincenz> I just want to get a nice little social system going and get it in a critical state
16:39:32 <morans> vincenz: best price for buying something is cheapest
16:39:42 <vincenz> morans: best price for selling?
16:40:07 <newsham> vincenz: maybe this will help clarify: http://www.biz.uiowa.edu/iem/trmanual/
16:40:14 <vincenz> th
16:40:21 <morans> vincenz: if you want to buy some crack, and dealer A has it for $1 and dealer B has it for $2, then as far as you (the buyer) are concerned, $1 is the best price
16:40:25 <newsham> IEM is an academic market trading in various futures.
16:40:44 <mathrick> Cale: hmm
16:40:51 <morans> it works the otehr way round, say I am trying to sell crack, and someone is willing to buy for $1, and someone is willing to buy for $2, then the best price as far as I'm concerned is $2
16:40:53 <vincenz> ok let me simplify my aims: I want to have a "simple" variant of spore, not the entire game but I'd like to fiddle around a bit with at least some, it's hard to find good material... I figured an economic system in the game would be inteesting
16:41:01 <Cale> mathrick: the version which I now have works for a list of length 7, I think in general for lengths 2^n -1
16:41:06 <vincenz> morans: yeah but then you lack two important factors
16:41:10 <vincenz> morans: the drive to buy and the drive to sell
16:41:43 <morans> vincenz: something external is what causes people to trade
16:41:56 <morans> vincenz: like "i have some crack but i need pies to eat"
16:42:00 <mathrick> Cale: yeah, it's a bit problematic to cope with non-ideal cases
16:42:04 <Cale> http://pastebin.com/647082
16:42:09 <vincenz> morans: right which means you need cost of labr
16:42:15 <Cale> what do you want to do in the other cases?
16:42:30 <newsham> people trade when its mutually beneficial.  one person values something less than the price and another values it more than the price
16:42:34 <Cale> I should probably have simplified the calculations there :)
16:42:42 <newsham> so they exchange money and the item and bother are happy
16:42:43 * morans nods
16:42:48 <mathrick> Cale: whatever, as long as it stays perfectly balanced
16:42:48 <vincenz> newsham: that's a nonstatement, or whatever the latin word is for that
16:43:25 * vincenz wishes he could find some good reference papeers
16:43:34 <vincenz> not perse on economics, just on simulating a social system
16:43:56 <Cale> mathrick: but only trees with 2^n - 1 nodes can be perfectly balanced
16:44:07 <newsham> see the "executing trades" part of that manual I pasted the url for
16:44:12 <mathrick> Cale: perfectly balanced == diff <= 1
16:44:16 <newsham> it shows concrete examples of ask and bid prices
16:44:17 <Cale> ah, okay
16:45:14 <vincenz> newsham: thx
16:45:25 <newsham> the market just matches up asks and bids
16:45:37 <vincenz> newsham: the sad thing that the drive to sell/buy isn't in there
16:45:55 <morans> vincenz: the reasons why people trade are outside of the market
16:46:02 <newsham> the drive to buy and sell is the mismatch in value placed on an item between trading individuals
16:46:05 <vincenz> well I want a closed social system
16:46:11 <vincenz> and evolve it to a critical state
16:46:13 <morans> vincenz: so you need more than just the market
16:46:14 <vincenz> and see how it behaves
16:46:24 <morans> vincenz: you need to put some kind of valuation stuff inside your agents
16:46:24 <newsham> (just like the engine of weather is the mismatch in temperature, humidity, salinity, etc, between nearby regions)
16:46:41 <vincenz> maybe I should drop the concept of economics, and go for more basics things
16:46:43 <morans> vincenz: not just implement a market
16:46:50 <vincenz> vegetation, herbivores and carnivores
16:47:35 <newsham> I'm good at growing food.  I can do it better than I can do anything else.  I grow lots of food, I have lots of the stuff.   someone else is good at making swords.  I dont have any swords, he doesnt have any food.
16:47:39 <newsham> we trade.  we're both happy.
16:48:03 <newsham> if he was good at growing stuff (or perhaps not as good at the more lucrative sword making business) he would grow stuff himself
16:48:06 <vincenz> newsham: I know but that kind of intelligence requires a lot already
16:48:11 <vincenz> unless you fix personas
16:48:13 <morans> newsham: add a statement that "we both desire swords and we both desire food"
16:48:26 <newsham> morans: well, duh!  his swords are fucking good! :)
16:48:30 <morans> heh
16:48:35 <vincenz> newsham, morans: seen spore?
16:48:41 <morans> spore?
16:48:41 <newsham> nope.
16:48:46 <vincenz> video google for spore
16:48:48 <vincenz> and be amazed
16:48:50 <RyanT5000> it's the latest game from wil wright
16:49:01 <RyanT5000> not out yet
16:49:03 <vincenz> I want a simpler version, not the whole thing, just at the tribal level
16:49:56 <morans> vincenz: so I guess you need a bunch of people, with "desires" to eat and have swords, and you need them to have different skills/specialisations
16:50:10 <vincenz> morans: right, but I don't want to fix those skills but have them evolve
16:50:19 <morans> ok
16:50:34 <morans> based on the number of swords you've made the better quality they are?
16:50:46 <vincenz> well that would be 2.0
16:51:11 <vincenz> based on: I need to learn that if I don't kill an animal and burn it and eat it, I die
16:51:27 <morans> hmm
16:51:42 <morans> most people learn that from social group rather than through personal experience.
16:52:10 <vincenz> maybe the idea is too grand
16:52:23 <Cale> mathrick: okay, I think I have something :)
16:52:43 <mathrick> yay
16:52:57 <Cale> http://pastebin.com/647097
16:53:08 <vincenz> morans: to give you a bit of context, I've been reading the book "ubiquity" by mark buchanan (I like it quite a bit), they hint towards a critical state in systems such as market economy, forest fires, social behaviour, etc...
16:53:33 <vincenz> morans: I think that simulating such an environment, and getting it to a critical state and then placing players in it could be a fun experience
16:53:56 <mathrick> Cale: bah, I'm sleepy, can't read it
16:54:29 <vincenz> morans: the concept of a critical state is basically that you can not foresee your actions (think butterfly flapping wings..)
16:54:39 <Cale> mathrick: If it was still written the old way, it'd be a good deal harder to read :)
16:54:54 <mathrick> I suspect so :)
16:55:05 <Cale> mathrick: I'm not sure what the magic 20 and (-1) constants were supposed to be, so I left them alone
16:55:40 <mathrick> Cale: ah, basically they were junk with no meaning
16:55:45 <Cale> ah, okay
16:55:45 <newsham> size = length . flatten ?
16:55:47 <vincenz> morans: most muds/mmorpgs have a system purely defined by players, I think the experience would be much funner if you have a world that 'turns', and only then drop in players, as agents just like the computer simulated ones
16:55:56 <Cale> sure, same thing :)
16:55:58 <mathrick> stemming from what the original algo looked like
16:56:17 <vincenz> > magic 20
16:56:20 <mbot>  Not in scope: `magic'
16:56:29 <vincenz> > let f x = x+2 in f 3
16:56:31 <mbot> 5
16:56:34 <vincenz> @version
16:56:34 <mbot> lambdabot 3p287, GHC 6.4.1 (Linux i686 )
16:56:34 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:56:38 <vincenz> where is lambdabot
16:56:58 <Cale> > let 0 = 1 in 0
16:57:01 <mbot> 0
16:57:18 <vincenz> > let 1 = 0 in 1
16:57:20 <mbot> 1
16:57:31 <Cale> > let 0 + 0 = 1 in 0 + 0
16:57:33 <mbot> 1
16:57:36 <int-e> > let l = 0 in l
16:57:37 <vincenz> odd
16:57:37 <mbot> 0
16:57:42 <vincenz> Cale: ah yeah, you're redefining + there
16:57:47 <Cale> vincenz: right :)
16:57:51 <vincenz> > let f 0 0 = 1 in f 0 0
16:57:52 <mbot> 1
16:58:02 <mauke> > let () = "what" in ()
16:58:04 <vincenz> funky that let 0 = 1 doesn't give parsing errors
16:58:04 <mbot> Couldn't match `()' against `[Char]'
16:58:06 <Cale> It's just disconcerting because it's +
16:58:21 <vincenz> > let f () = "what" in f ()
16:58:23 <mbot> "what"
16:58:39 <vincenz> > let 'a' = 1 in 'a'
16:58:41 <mbot>  add an instance declaration for (Num Char)
16:58:41 <mbot>   In a pattern binding: 'a' = 1
16:58:41 <mbot>   In the definition of `npi': npi = let 'a' = 1 in 'a'
16:58:43 <vincenz> only complains on the type level
16:58:45 <Cale> > let "huh?" = "what" in ()
16:58:46 <vincenz> not on the syntax level
16:58:47 <mbot> ()
16:58:53 <vincenz> which is wrong imho
16:59:09 <Cale> ah, lazy pattern bindings :)
16:59:17 <vincenz> > let huh = "what" in `huh`
16:59:18 <mbot>  parse error on input ``'
16:59:37 <vincenz> Cale: not really
16:59:44 <vincenz> > let "huh" = "what" in "huh"
16:59:45 <mbot> "huh"
16:59:59 <newsham> > let 0 = 1 in lookup 0 [(0,"stop")]
17:00:01 <mbot> Just "stop"
17:00:10 <vincenz> that should be a syntax error
17:00:12 <Cale> vincenz: well, it's a pattern binding, but it doesn't bind any variables
17:00:17 <vincenz> 0 is not a valid varid
17:00:27 <Cale> It's a valid pattern
17:00:30 <vincenz> Cale: hmmm...good point
17:00:43 <vincenz> it's weird tho
17:00:47 <Cale> > let (x:"huh") = "what" in x
17:00:50 <mbot>  Irrefutable pattern failed for pattern (x : "huh")
17:01:02 <vincenz> > let (x:"hat") = "what" in x
17:01:04 <mbot> 'w'
17:01:15 * vincenz ponders
17:01:23 <vincenz> > let y = 1:y in let (x:y) = y in x
17:01:25 <mbot> Add a type signature
17:01:28 <Cale> > let (x : ~"huh") = "what" in x
17:01:31 <vincenz> > let y = 1:y in let (x:y) = y in x::[Int]
17:01:31 <mbot> 'w'
17:01:33 <mbot> <stdout>: hPutStr: illegal operation (handle is finalized)
17:01:38 <vincenz> woo
17:01:45 <vincenz> that's a new one
17:02:04 <Cale> > let y = 1:y in let (x:y) = y in x::[Int]
17:02:06 <mbot> <stdout>: hPutStr: illegal operation (handle is finalized)
17:02:17 <vincenz> you're redefining y in the second let
17:02:21 <vincenz> for that func
17:02:29 <vincenz> > let (x:y) = y in x::[Int]
17:02:31 <mbot> <stdout>: hPutStr: illegal operation (handle is finalized)
17:02:36 <Cale> > 1 + 1
17:02:38 <mbot> 2
17:02:56 <vincenz> > let (x:y) = 1:x in x::[Int]
17:02:58 <mbot>   Occurs check: cannot construct the infinite type: a = [a]
17:02:58 <mbot>   Expected type: [[a]]
17:02:58 <mbot>   Inferred type: [a]
17:03:15 <vincenz> > let (x:y) = 1:(repeat x) in x::[Int]
17:03:16 <mbot>  add an instance declaration for (Num [Int])
17:03:18 <vincenz> > let (x:y) = 1:(repeat x) in x
17:03:20 <mbot> 1
17:03:22 <vincenz> funky
17:03:30 <vincenz> lazy evaluation :)
17:03:37 <vincenz> > let (x:y) = 1:(repeat x) in y
17:03:39 <mbot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:03:39 <mbot> [5 @more lines]
17:03:54 <vincenz> even with non infinite lists
17:03:59 <vincenz> that would never work with strict eval
17:04:10 <vincenz> > let (x:y) = 1:(replicate 10 x) in y
17:04:12 <mbot> [1,1,1,1,1,1,1,1,1,1]
17:04:19 <vincenz> that would never work in a strict lang
17:04:44 <vincenz> it's bouncing back and forth between left and right side of =
17:04:59 <vincenz> > let (x:(replicate 10 x)) = 1:(replicate 10 x) in y
17:05:00 <mbot>  Parse error in pattern
17:05:02 <vincenz> > let (x:(replicate 10 x)) = 1:(replicate 10 x) in x
17:05:03 <mbot>  Parse error in pattern
17:05:11 <vincenz> > let (x:(replicate 10 1)) = 1:(replicate 10 x) in x
17:05:12 <mbot>  Parse error in pattern
17:05:20 <vincenz> pity
17:05:36 <vincenz> > let (x:x:x:x:[][) = 1:(replicate 3 x) in x
17:05:37 <mbot>  parse error on input `)'
17:05:39 <vincenz> > let (x:x:x:x:[]) = 1:(replicate 3 x) in x
17:05:40 <mbot>   Conflicting definitions for `x'
17:05:40 <mbot>   In the binding group for: x, x, x, x
17:06:09 <vincenz> morans: ping
17:06:28 <morans> vincenz: I'm here.
17:06:41 <vincenz> morans: any thoughts on what I said earlier?
17:07:10 <morans> well, its not entirely clear what you want to do, but it sounds fun...
17:08:04 <vincenz> morans: well some time ago I wanted to build a mud
17:08:11 <vincenz> morans: where npcs and pcs were interchangeable
17:08:16 <vincenz> however muds are too room based
17:08:29 <vincenz> and have a whole set of paraphernalia that are irrelevant to the core issue
17:09:42 <morans> so what do you want your characters to be doing?
17:10:14 <morans> trading and stuff?
17:10:19 <morans> building things?
17:11:00 <vincenz> right now I'm open to any amenable system that displays criticality
17:11:11 <vincenz> either look at trading, or just plain survival on a more basic level
17:12:48 <morans> trading would be pretty easy to build up incrementally, i would have thought...
17:13:02 <morans> build a simple market, stick your actors in
17:13:13 <morans> gradually build up the actor code to be more and more interesting
17:13:55 <vincenz> yeah
17:14:00 <vincenz> I'm just stuck on what drives prices up
17:14:14 <vincenz> once you have those, you can define actors that either bargain with optimism or pessimism
17:14:26 <morans> vincenz: its the actors that define the prices.
17:14:37 <morans> prices always come from some computation in the actor's head.
17:15:29 <morans> its not a case of the market setting prices and then the actors looking at the prices and deciding what to do.
17:16:43 <morans> heres a simple alg.
17:16:52 <morans> goal is to ensure that i have one pie per day
17:17:16 <morans> goto the market and try to buy a pie for 1 coin. if tehre is no trade for an hour, try at 2 coins, and if no trade for an hour, try at 3 coins
17:17:24 <morans> do that every day
17:18:02 <morans> of course, you need another actor with a stash of pies and some goal, like "charge more than 1.4 coins for the pie"
17:18:17 <morans> a price will emerge for pies.
17:18:30 <vincenz> yeah but I read of simple systems with a single stock
17:18:31 <int-e> and some other actors who also want to buy pies, probably following different algorithms
17:18:41 <newsham> hunger should factor in.  if you havent eaten in 3 days, you will buy stale bread for whatever you have
17:18:58 <morans> and loansharks
17:19:14 <newsham> future value of money might be a bit more than you wanna deal with :)
17:19:20 <morans> heh
17:19:48 <int-e> another simplifying assumption is that sellers don't care about who they sell their stuff to.
17:20:20 <vincenz> blegh
17:20:25 <vincenz> that's what I hate with game programming sites
17:20:31 <vincenz> they focus too much on the technical details
17:20:34 <vincenz> how to render nurbs
17:20:40 <vincenz> how to do socket communication in c
17:20:55 <morans> this isn't the technical details
17:21:01 <morans> this is implementing real people
17:21:05 <vincenz> I know
17:21:09 <vincenz> I was talking about gamedev.net
17:21:15 <morans> oh
17:21:41 <vincenz> ok
17:21:44 <vincenz> to complete the game
17:21:48 <vincenz> you need something extra
17:21:50 <vincenz> a) a pie source
17:21:53 <vincenz> b) a money source
17:22:04 <vincenz> cause a is the money drain, and the people are the pie drain
17:22:45 <morans> no sources/sinks
17:22:50 <morans> it all just flows round
17:23:02 <morans> something needs to make the pieman spend his money in ways such that it flows back to some of the other people
17:23:10 <morans> and you just let the people who have nothing to offer die
17:23:13 <morans> like in the real world
17:23:19 <newsham> make another kind of "pie" and have different people be the src/sink
17:23:40 * vincenz starts roughcoding something
17:23:55 <morans> but all of this should be pretty easy to build up incremementally like i said
17:24:26 * vincenz nods
17:24:31 <vincenz> I'll tinker with it a bit
17:24:33 <vincenz> and then put the repo online
17:29:17 <RyanT5000> is there a good online haskell software design text?
17:35:30 <newsham> HTTP/1.1 200 OK
17:35:30 <newsham> Server: HWS/0.1
17:35:30 <newsham> Date: Sat, 08 Apr 2006 00:33:17 GMT
17:39:16 <newsham> http://udp110165uds.hawaiiantel.net:8888/   <- HWS
17:39:57 <morans> classy domain name
17:40:06 <newsham> not much I can do about it
17:41:39 <morans> easy to set up HWS?
17:42:00 <newsham> normal httpd.conf format (only recognizes a subset of the directives).  pretty trivial.
17:46:24 <vincenz> newsham: many of your links don't work
17:46:34 <newsham> yah, I just copied my home page from my isp
17:50:17 <morans> anyone have opinions on WASH?
17:50:32 <newsham> havent looked at it yet, but thinking about it
17:55:17 <newsham> I added a link to the src code for HWS on the page.
17:57:22 <newsham> hmm.. its really chewing cpu
17:57:32 <newsham> 8305 newsham   25   0  140m 137m 3032 R 97.4 54.8  22:12.74 a.out
17:58:33 <bolrod> @hoogle permutations
17:58:35 <mbot> http://mathforum.org/dr.math/faq/faq.comb.perm.html
17:58:42 <bolrod> hrm.. what was it again
17:58:44 <bolrod> @help
17:58:44 <mbot>  @help <command> - ask for help for <command>
18:11:51 <dons> lambdabot: ?version
18:12:00 <lambdabot> lambdabot 3p400, GHC 6.4.1 (Linux i686 3.20GHz)
18:12:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:12:26 <dons> mbot, @part #haskell
18:17:29 <bolrod> @listcommands
18:17:30 <lambdabot> Unknown command, try @list
18:17:34 <bolrod> @list
18:17:35 <lambdabot> list [module|command]. Where modules is one of:
18:17:35 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
18:17:35 <lambdabot> unlambda version vixen where
18:17:41 <bolrod> ic
18:17:49 <bolrod> @search permutations
18:17:49 <lambdabot> Unknown command, try @list
18:18:15 <bolrod> why isn't lambdabot answering in msg screen ?
18:18:35 <bolrod> @help pl
18:18:38 <bolrod> @pl
18:18:42 <sethk> dons, if you have a minute, take a look at http://paste.ubuntu-nl.org/11722
18:18:48 <bolrod> > 1+1
18:18:55 <bolrod> >:/
18:19:00 <sethk> dons, I've done most of what I wanted to do, but I can't figure out how to do the last thing
18:19:12 <lambdabot> pointless <expr>. Play with pointfree code.
18:19:13 <lambdabot> (line 1, column 1):
18:19:15 <sethk> dons, look at the function at the end, commented out; I think you'll see what I'm trying to do
18:19:15 <lambdabot> unexpected end of input
18:19:17 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
18:19:20 <lambdabot> 2
18:19:30 <bolrod> wow
18:19:48 <sethk> dons, I wanted class methods for put and get, and that worked out nicely
18:20:06 <sethk> dons, the class just before the commented out function isn't used for anything yet.
18:20:12 <bolrod> @hoogle test
18:20:20 <sethk> dons, I'll also paste one where I used these classes:
18:20:26 <bolrod> bah >:/
18:20:44 <dons> sethk, looking
18:20:48 <dons> lambdabot, what's wrong?
18:20:55 <dons> ?bot
18:20:55 <lambdabot> Test.QuickCheck.test :: Testable a => a -> IO ()
18:20:57 <lambdabot> Test.HUnit.Base.test :: Testable t => t -> Test
18:20:59 <lambdabot> Test.HUnit.Base.Test :: data Test
18:21:01 <lambdabot> :)
18:21:02 <dons> very slow?
18:21:09 <bolrod> VERY slow
18:21:20 <dons> network issues somewhere then.
18:21:21 <sethk> dons:  second part   http://paste.ubuntu-nl.org/11723
18:21:33 <bolrod> @hoogle subsequences
18:21:33 <lambdabot> No matches found
18:21:42 <bolrod> @hoogle permutations
18:21:42 <lambdabot> No matches found
18:21:47 <bolrod> hmm.. thats faster
18:21:50 <dons> its not lambdabot: up 8 days, 18:37,  1 user,  load average: 0.00, 0.00, 0.00
18:21:59 <bolrod> why doesn't it find anything when it is in the haskell report?
18:22:12 <dons> sethk, I just woke up. I'll grab some coffee and be back in 5 mins
18:22:20 <dons> ?hoogle map
18:22:20 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
18:22:20 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
18:22:20 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
18:22:22 <sethk> dons, no hurry.  :)
18:22:50 <bolrod> @hoogle union
18:22:50 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
18:22:50 <lambdabot> Data.IntMap.union :: IntMap a -> IntMap a -> IntMap a
18:22:50 <lambdabot> Data.IntSet.union :: IntSet -> IntSet -> IntSet
18:23:11 <bolrod> @hoogle unio
18:23:11 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
18:23:11 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
18:23:11 <lambdabot> Data.IntMap.union :: IntMap a -> IntMap a -> IntMap a
18:23:28 <bolrod> @hoogle perm
18:23:28 <lambdabot> Text.ParserCombinators.Parsec.Perm :: module
18:23:28 <lambdabot> System.IO.Error.permissionErrorType :: IOErrorType
18:23:28 <lambdabot> Text.ParserCombinators.Parsec.Perm.permute :: PermParser tok st a -> GenParser tok st a
18:23:34 <bolrod> >://
18:26:08 <newsham> subsequences?
18:26:17 <bolrod> yes
18:32:51 <newsham> nice nick, erlang
18:33:20 <Erlang> anyone knows why I'm a having a ton of undefined references compiling an Haskell program that uses MissingH?
18:34:32 <ncalexan> dons: back?
18:35:57 <dons> yes.
18:36:11 <dons> Erlang, maybe you need to add -package missingh (or something like it?)
18:36:13 <ncalexan> can you give me some help debugging hs-plugins on Mac OS X?
18:36:18 <dons> ok. I can try.
18:36:42 <ncalexan> I've built a debug hs-plugins but the error looks to be in ghc/Linker.c.
18:36:56 <ncalexan> And building a debug build of GHC is a very long process, fraught with peril.
18:37:23 <dons> sethk, can I ask why you use explicit lamdbas and >>= instead of do-notation?
18:37:49 <Erlang> I see a -lHSMissingH-0.13.1 in verbose build output.  It tries to link but fails in some way.
18:45:59 <sethk> dons, I mostly use the do notation.  but when I'm doing something I'm less familiar with, I find it easier to learn it first without the do.
18:46:34 <sethk> dons, actually I was a bit surprised that you used it the other day when we were talking about the function to read the configuration
18:46:43 <sethk> dons, because you don't typically use it
18:46:52 <sethk> dons, does it matter?
18:47:48 <Erlang> well gosh darn it.  I've rebuilt the missingh package and it works.
18:51:30 <dons> I sometimes use >>= and friends for one liners
18:53:00 <dons> sethk, ok. so I'm debugging the type error
18:53:30 <sethk> dons, ok.  the put/get, which was my initial goal, work fine
18:53:49 <sethk> dons, it's the function to send a request and then get a response that I didn't figure out
18:54:16 <Erlang> thank you, good night.
18:54:21 <dons> right. I'm pondering that.
18:54:42 <sethk> ok, thanks
18:54:46 <dons> for one, there's a missing argument: let response = handleRequest handle request
18:54:53 <dons> you'd only applied it to 'request'
18:56:00 <dons> dooes it really need a Handle argument too?
18:56:17 <sethk> dons, yes, it's the handle to the network socket
18:56:31 <sethk> dons, although we could bury that in the type of request/response, I guess
18:56:34 <dons> oh, it sends a request, and getsa reponse?
18:56:42 <sethk> right
18:56:43 <dons> so it should be in IO, then?
18:56:51 <sethk> it is
18:56:59 <dons> handleRequest :: Handle -> request -> response
18:57:03 <dons> is pure
18:57:11 <dons> should be ... -> IO response , no?
18:57:16 <sethk> yes
18:57:31 <sethk> putRequest is IO () and getRequest is IO Response
18:57:46 <sethk> so yes, handleRequest has to be .... Request -> IO Response
18:58:13 <dons>     handleRequest  :: Handle -> request -> IO response
18:58:14 <dons>     handleResponse :: Handle -> IO response
18:58:25 <dons> so then I have:
18:58:26 <dons>     request  <- getRequest handle
18:58:26 <dons>     response <- handleRequest handle request
18:58:26 <dons>     putResponse handle response
18:58:39 <dons> but would getRequest and handleRequest really read from the same handle?
18:58:51 <dons> or do I misunderstand what getRequest odes.
18:58:54 <sethk> I have to treat the type variable the same way I treat a type in a function signature (talking to myself )
18:59:15 <sethk> dons, yes, the server side reads requests on a handle, and writes the response back to the same handle
18:59:28 <sethk> dons, so the client side sends a request on the handle and reads the response on the same handle
18:59:41 <sethk> dons, which works nicely and sequences everything
18:59:52 <dons> ok.
18:59:54 <sethk> as long as you don't want parallelism here, which at the moment I don't
19:00:18 <sethk> once it's working I'll probably add more asynchronous processing
19:00:21 <sethk> if I need it
19:00:23 <dons> yep. 
19:00:53 <sethk> at the network level a tcp/ip connection is really two separate connections, and this coding style takes advantage of that fact
19:02:34 <dons> ah, there's a missing HasStatus constraint.
19:02:57 <dons> maybe. hmm. 
19:03:26 <dons> ok. only 1 type error now.
19:03:44 <newsham> seth: what kinda apps do you write?
19:05:22 <sethk> dons, I wasn't sure if what I did with HasStatus was the right way to handle that, or not.
19:08:01 <dons> ah, you need phantom type arguments to resolve which instances you're talkking about:
19:08:04 <dons> runServer :: (Server a b) => a -> b -> Handle -> IO ()
19:08:07 <dons> runServer (_ :: a) (_ :: b) handle = do
19:08:09 <dons>     (request :: a)  <- getRequest handle
19:08:12 <dons>     (response :: b) <- handleRequest handle request
19:08:14 <dons>     putResponse handle response
19:08:17 <dons>     runServer (undefined::a) (undefined::b) handle
19:08:19 <dons> type checks
19:08:41 <dons> that way the type checker can tell that each time round the loop you're still talking about the same Server a b types
19:09:06 <dons> then, when you call runServer , you fix the type of Server it is
19:09:07 <sethk> dons, "a" and "b" are what you refer to as phantom types?
19:09:14 <dons> yep.
19:09:33 <dons> they're type arguments only (they disappear during compilation)
19:09:53 <dons> we can probably simplify this code a bit. gimme a sec
19:10:21 <sethk> ok.
19:10:39 <sethk> xchat sometimes crashes when I save a buffer, so if I disappear, I'll be back.  :)
19:10:56 <dons> runServer :: (Server a b) => a -> b -> Handle -> IO ()
19:10:56 <dons> runServer (_ :: a) (_ :: b) handle = run
19:10:56 <dons>     where
19:10:56 <dons>         run = do (request  :: a) <- getRequest handle
19:10:56 <dons>                  (response :: b) <- handleRequest handle request
19:10:58 <dons>                  putResponse handle response
19:11:01 <dons>                  run
19:11:20 <dons> that way we fix it once. no need to loop with the type arguments
19:11:37 <ski> hm .. wouldn't it be better to pass say an 'Ignore a' if 'data Ignore a = Ignored' ?, instead of an actual value ?
19:11:55 <dons> instead of (undefined::a) ?
19:11:59 <sethk> dons, that's interesting.
19:12:01 <ski> yes
19:12:08 <dons> yeah, maybe: data Ignore a
19:12:16 <dons> or data Phantom a
19:12:35 <dons> then you don't need to rely on the client not evaluating the argument by accident
19:12:44 <ski> (so GC (or static analyser) won't think data is alive longer that it is)
19:12:49 <ski> that too, yes
19:12:59 <dons> yeah that's a nice idea. Let's see
19:13:03 <sethk> dons, that's interesting.  I've made progress in thinking about these things, but I rarely think of using a where clause for an abstract computation like that.
19:13:52 <dons> where is rather nice. I recommennd it :)
19:14:00 <dons> it's a nice declarative style
19:14:05 <ski> 'repeatM' ?
19:14:19 <dons> I was thinking fix. but repeatM would be good too
19:14:19 <ski> er s/M/M_/
19:14:22 <dons> yup
19:14:30 <dons> pity we have to write it .
19:14:59 <sethk> dons, this is a very useful class.
19:15:08 <Cale> yeah, it's kind of ridiculous if that still isn't in Control.Monad
19:15:12 <sethk> dons, even my poor implementation saved a lot of lines of code
19:15:18 <Cale> (I don't know what's in CVS though)
19:15:27 <ski> repeatM_ :: Monad m => m a -> m ()
19:15:31 <ski> er
19:15:34 <ski> repeatM_ :: Monad m => m a -> m b
19:15:38 <ski> actually
19:15:51 <Korollary> seriously?
19:15:51 <sethk> I'm going to have to study the ignore and repeatM thing you just used.
19:16:02 <Cale> The first type is more consistent with the other functions in the library
19:16:16 <dons> repeatM_ a = a >> repeatM_ a
19:16:17 <dons> runServer :: (Server a b) => a -> b -> Handle -> IO ()
19:16:17 <ski> and the second is more general ..
19:16:18 <dons> runServer (_ :: a) (_ :: b) handle = repeatM_ run
19:16:18 <dons>     where
19:16:20 <dons>         run = do (request  :: a) <- getRequest handle
19:16:23 <dons>                  (response :: b) <- handleRequest handle request
19:16:25 <dons>                  putResponse handle response
19:16:32 <dons> saves remembering to loop, sethk
19:16:46 <ski> dons : 'repeatM_ $ do' could be used
19:16:49 <dons> (i.e. repeatM_ is a hiigher order for(;;)
19:17:01 <sethk> dons.  nice.  I'll have to shred my implementation before anyone else sees it.  :)
19:17:06 <dons> ski, :) ok
19:21:29 <dons> sethk, ok.: http://www.cse.unsw.edu.au/~dons/tmp/Server.hs
19:21:54 <sethk> dons, thanks.  I'll fold that into my code and let you know how it goes.
19:21:57 <dons> I think there are ways this code can be shrunk still further
19:22:21 <dons> i.e. getRequest and getResponse are identical functions.
19:22:35 <sethk> dons, yes, in fact, originally they were the same function
19:22:43 <dons> it the handleRequest/Response that differ, no?
19:22:51 <sethk> dons, but I decided that it is probably more typical to have differences
19:23:00 <dons> yeah. ok
19:23:02 <sethk> dons, as constituted, they are identical.
19:23:18 <sethk> dons, but suppose we do want one way functions (asynchronous responses)
19:23:22 <dons> yep.
19:23:23 <sethk> dons, then they would diverge
19:24:09 <sethk> but maybe that's one of those cases of refactoring before the fact that I always say isn't a good idea.  :)
19:29:32 <dons> this uses ski's idea to avoid undefines:
19:29:33 <dons> runServer :: (Server a b) => Handle -> S a b -> IO ()
19:29:33 <dons> runServer handle (_ :: S a b) = repeatM_ run
19:29:33 <dons>     where
19:29:36 <dons>         run = do (request  :: a) <- getRequest handle
19:29:38 <dons>                  (response :: b) <- handleRequest handle request
19:29:41 <dons>                  putResponse handle response
19:29:43 <dons> data S a b = S
19:29:46 <dons> main = runServer stdin (S :: S LoadtestRequest LoadtestResponse)
19:29:48 <dons> and also combines the request/response type pair
19:29:54 <dons> making it a little more concise
19:30:06 <dons> ski, that's what you meant, no?
19:31:23 <dons> sethk, that code is at http://www.cse.unsw.edu.au/~dons/tmp/Server.hs, as I think it's a better version of the earlier one.
19:31:42 <sethk> thanks.
19:31:45 <sethk> looking now
19:32:26 <sethk> stupid xchat copied the comma with the URL and the server said "duh"   :)
19:32:49 <dons> I notice some extraa code in their (like the Fix import) I'll clean it up some more
19:33:03 <sethk> ok
19:33:37 <ski> dons : yes, that would work
19:34:02 <ski> (but i stil feel that 'run' is unneccesary to name, here)
19:34:10 <Korollary> how about @pl?
19:34:35 <dons> I thought that 'run' made the code a bit cleaner on the eye. purely cosmetic
19:34:39 <dons> often I'd just use $  do as well
19:34:41 <sethk> ski, what's the objection to run?  just that it can be coded without it?
19:34:56 <ski> runServer handle (_ :: S a b) = repeatM_ $ do
19:34:57 <dons> yes, that you can inline the body of run after the call to repeatM_ with $
19:35:02 <ski>   (request  :: a) <- getRequest handle
19:35:05 <ski>   ...
19:35:25 <sethk> dons, it's definitely easier to read with the run, but maybe that's because I'm still learning.
19:35:59 <dons> it's a bit nicer now that we have no undefs. perhaps ski is right:
19:36:00 <dons> runServer handle (_ :: S a b) = repeatM_ $ do
19:36:00 <dons>     (request  :: a) <- getRequest handle
19:36:00 <dons>     (response :: b) <- handleRequest handle request
19:36:00 <dons>     putResponse handle response
19:36:12 <ski> i think it reads more like a loop (think EDSL if you want), without the separate naming
19:36:15 <dons> which seems ok.
19:36:21 <dons> yes. like a control structure
19:36:37 <dons> its a small matter
19:36:38 <ski> which is basically how we're using it, here
19:36:45 <ski> i agree
19:37:04 <sethk> dons, what in that last URL are you calling an "undef"?
19:37:35 <dons> oh, in the very first code, we used 'undefines' in place of proper phantom type arguments
19:37:50 <dons> and I thought the code lined up in a slightly confusing manner, so I prefered the 'where'
19:37:50 <ski> sethk : 'runServer (undefined::a) (undefined::b) handle' in the original .. or for that matter, the initial call to 'runServer'
19:37:55 <dons> purely a stylistic code.
19:37:59 <dons> /smatter/
19:38:01 <sethk> dons, yes, I saw that, I just didn't see it in the last URL and I thought I misunderstood something
19:38:58 <sethk> you tend to put do at the end of a line and I tend to put it on the following line (I do the same thing with { in C or Java).  Can the do be at the same column as the line before?
19:39:09 <sethk> or does the do have to be indented if it is on the following line?
19:39:30 <sethk> I can try it, of course, but I'm lazy  :)
19:40:41 <dons> the do can't line up with the start of 'runServer'. it has to be indented some.
19:41:08 <dons> if i understand the question
19:41:13 <sethk> dons, thought so.
19:41:19 <sethk> dons, yes, you did understand
19:41:40 <sethk> I guess I can indent is one space to get the effect I want
19:41:53 <sethk> (or I can always use {} and ;)
19:42:04 <dons> so this is really what you wanted in the end, no? a runServer that was polymorphic over all your server types?
19:42:21 <sethk> dons, yes, exactly
19:42:25 <dons> and you just instantiate each one with: runServer stdin (S :: S LoadtestRequest LoadtestResponse)
19:42:30 <dons> to get a new server.
19:42:34 <dons> cool
19:42:59 <dons> abstractions are Haskell's forte 
19:43:45 <ski> (sethk : i use both indentation styles of 'do' ..)
19:44:37 <sethk> ski, it's less ugly (to me) in Haskell than in C like languages, because there is no closing brace
19:44:56 <sethk> ski, I like begin/end type stuff to be at the same indentation level
19:44:59 <Korollary> curlies are ugly wherever I put them.
19:45:01 <dons> you could use a closing brace though. do { ... ; ... ; } is valid :)
19:45:10 <sethk> dons, right
19:45:18 <ski> sethk : if you want, you could rename the types 'a' and 'b' to request' and 'response' (or 'requestT' and 'responseT' if you want different names than the value variables)
19:45:22 <sethk> dons, I do that sometimes when I don't feel like unravelling
19:45:33 <sethk> ski, I always prefer meaningful names
19:45:34 <dons> making: forever $ do { ... }  really look like syntax
19:46:18 * ski leaves
19:46:40 * dons is a paid up member of the Type Variables Should Be Single Letters (TVSBSL) society
19:46:44 <dons> ;)
19:48:30 <dons> hmm. I wish vim had 'wiki' syntax highlighting
19:48:33 <dons> for writing wiki pages
19:48:56 <Korollary> wiki syntax differs from wiki to wiki, tho.
19:49:11 <dons> true. but you could have a couple of  the big ones
19:49:44 <dons> in 5 years they'll be a standard syntax I tihnk
19:49:50 <dons> based on whatever wikipedia uses
19:50:11 <dons> unfortunately, since its butt ugly
19:50:38 <dons> (and this despite the number of wikis that've been written by students doing language design )
19:50:43 <sethk> dons, write a translater from something nice to wiki  :)
19:50:52 <dons> ah!
19:50:55 <dons> good point
19:51:11 <dons> a haskell, type checked , edsl to wiki
19:51:24 <dons> like oleg's typed html combinators
19:53:40 <sethk> dons, you imported Control.Monad.Fix, but I don't see fix in the code, and the doc page for control.monad.fix shows only fix
19:53:57 <sethk> dons, mfix, thigns with fix in them
19:54:49 <dons> yes. you can removee it. it was an idea that I gave up on.
19:55:53 <dons> here's a cleaned up version: http://www.cse.unsw.edu.au/~dons/tmp/Server1.hs
19:56:29 <dons> though I'm thinking the code could be shrunk by removing the Request and Response classes, and merging their methods into a single Server class
19:56:46 <sethk> dons, yes, I thought about that
19:56:53 <dons> unless there are actual cases where you want to recombine various Request methods with different Responses
19:57:11 <dons> (you might reuse a stdin Response, or something)
19:57:18 <sethk> dons, so far, no, I haven't had any reason to do it that way
19:57:25 <dons> so, depends on how fine-grained the modularity is
19:57:55 <sethk> repeatM_ takes the place of a recursive call to runServer?
19:58:04 <dons> yep.
19:58:14 <dons> it's a higher order function that takes care of the recursive call for you
19:58:42 <sethk> dons, is there any difference, or is it a coding style?
19:58:58 <dons> (anothe case of higher order, lazy languages not needing the dozens of control-flow keywords of strict langugages)
19:59:25 <dons> well, it abstracts over the common pattern of a tailcall recursive function.
19:59:31 <dons> which is convenient.
19:59:31 <sethk> k
19:59:48 <dons> as its not uncommon to forget the recursive call 
19:59:50 <dons> and then have to debug that.
19:59:55 <dons> (at least i've done that)
19:59:59 <sethk> dons, I did that twice this week, actually
20:00:15 <dons> so we let repeatM_ do it for us. sometimes 'repeatM_' is called 'forver'
20:00:24 <dons> 'forever', at least in the Awkward Squad paper
20:00:35 <dons> i.e. forver $ do .... 
20:00:44 <sethk> dons, if Server is running in a thread, and I put a   return ()    in the body of run, would the thread terminate?
20:01:23 <dons> it'll keep looping. whether its in a thread or not.
20:01:34 <dons> you'd throw an exception to the outer level to break out of the loop
20:01:43 <sethk> dons, ok.
20:01:52 <dons> or change repeatM_ to take a Left or Right value, to decide whether to keep looping
20:01:58 <sethk> dons, right
20:02:09 <dons> I think I've done both in the past
20:02:32 <dons> ah yes, here: 
20:02:33 <sethk> I typically do   if whatever then return () else recursiveCall
20:02:33 <dons> forever :: IO () -> IO ()
20:02:33 <dons> forever fn = catch (repeatM_ fn) handler
20:02:33 <dons>     where
20:02:33 <dons>         handler :: Exception -> IO ()
20:02:35 <dons>         handler e =
20:02:38 <dons>             when (not.exitTime $ e) $
20:02:41 <dons>                 (warnA . show) e >> (forever fn)        -- reopen the catch
20:02:58 <dons> so that implements an exception-handler to catch the exit out of repeatM
20:03:11 <dons> but which optoinally continues looping if its not a serious exception
20:03:15 <dons> (when not.exitTime)
20:03:32 <sethk> nice
20:03:43 <dons> exitTime e | isJust . ioErrors $ e   = False -- ignore
20:03:45 <dons>            | isJust . errorCalls $ e = False -- ignore
20:04:00 <dons> which just matches the various error connditions we actually consider fatal
20:04:33 <dons> so, yes, as you want to make runServer more robust, you can think about variations on repeatM_ for dealing with exceptions
20:05:08 <dons> I run serveral threads in my mp3 player inside forever () blocks
20:05:49 <sethk> dons, I have a lot of perpetual servers in this app.
20:06:11 <sethk> dons, I have one that provides MAC addresses, one that accepts and saves test results, etc.
20:06:46 <dons> right. so with all that io you'll want to think abotu error condtions that get thrown out, and make sure they keep running where appropriate.
20:07:43 <sethk> dons, yes.  The person who coded this stuff in C, several years ago, has a program running to look for processes that crashed, so he could restart them.  :)
20:07:50 <sethk> dons, seriously ugly stuff
20:08:09 <sethk> good for filling a disk with core files  :)
20:08:13 <newsham> where on the new wiki is the "fun" stuff (like sudoku solver)
20:08:19 <newsham> <- still not used to the new wiki 
20:08:41 <dons> under 'Idioms'
20:08:42 <dons> from the front page
20:08:46 <dons> or Category:Idioms
20:08:58 <dons> ?wiki Category:Idioms
20:08:59 <lambdabot> http://www.haskell.org/haskellwiki/Category:Idioms
20:09:02 <dons> does that work. I think.
20:09:36 <dons> newsham, or look at Special:Recentchanges to find out what people are working on
20:10:27 <newsham> would this be appropriate under idioms?  http://www.haskell.org/hawiki/Mandelbrot
20:10:51 <dons> I think we should probably add a Category:Code page, in fact
20:10:58 <dons> and Sudoku should go under it.
20:11:04 <Cale> On the old wiki, there's a Gallert
20:11:05 <newsham> yah, seems more of a code thing than idiom :)
20:11:08 <Cale> Gallery*
20:11:08 <dons> hmm. maybe I'll just create this new category now.
20:11:16 <dons> Gallery.  maybe even better
20:11:38 <sethk> dons, I'm confused by this line:  msg <- hGetLine handle >>= readIO
20:11:52 <sethk> dons, it binds to the right?
20:12:00 <Cale> perhaps  msg <- readIO =<< hGetLine handle  is clearer
20:12:02 <dons> same as: hGetLine handle >>= \s -> readIO s >>= \msg -> ...
20:12:05 <sethk> dons, so msg gets the output of hGetLine passed through readIO?
20:12:10 <dons> yeah, Cale makes a good point
20:12:18 <dons> yep
20:12:31 <dons> msg _is_ the output of hGetLine monadically composed with readIO
20:12:50 <dons> 'gets' makes me feel weird :S
20:12:56 <dons> likes its a storage locatoin ;)
20:12:57 <sethk> Cale, dons ok.  I thought so.  I definitely prefer Cale's with the flow going in the same direction  :)
20:13:16 <dons> yeah. it's a good case for =<<
20:13:35 <sethk> dons, well, the docs all say that do is essentially a small imperative language within Haskell
20:13:47 <dons> alternatively, you could write, I suppose: msg <= return . read =<< hGetLine h
20:14:01 <sethk> dons, if you don't want it to look like a storage location, why didn't you like it when I used >>=  ?
20:14:06 <Cale> sethk: well, sort of, and not just one small imperative language :)
20:14:11 <dons> yep. its a way of codiing in an imperative style.
20:14:16 <dons> with explcitly sequecing
20:14:32 <Cale> I'd say that the ST monad pretty much captures all imperative pure algorithms
20:14:56 <sethk> dons, did you mean msg <= return . read =<< ..., or msg =<< ?
20:15:04 <dons> hehe, sethk. I guess I think of Haskell variiables as things that "are" and "are" for all time. not things that have a before-being-initialise, and then getting a value.
20:15:21 <dons> no, I meant:   msg <- return . read =<< hGetLine h
20:15:31 <sethk> right
20:15:40 <dons> same as   :   msg <- readIO =<< hGetLine h, but 'pureer'
20:15:50 <dons> (not really. just a joke)
20:16:07 <sethk> =<< is just >>= with the arguments reversed?
20:16:11 <dons> yup
20:16:16 <int-e> liftM read $ hGetLine h ?
20:16:27 <dons> ?pl return . read =<< hGetLine h
20:16:27 <lambdabot> read `fmap` hGetLine h
20:16:30 <dons> ah!
20:16:53 <sethk> what's ?pl do?
20:16:57 <dons> I only ever think of fmap when @pl suggests  it
20:17:03 <dons> code refactoring
20:17:06 <dons> to pointfree style
20:17:08 <dons> ?wiki Pointfree
20:17:09 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
20:17:24 <sethk> thanks.
20:17:29 <dons> TheHunter wrote it, and its rather brilliant
20:18:37 <dons> I've often thought `fmap` should be something like: >>.
20:19:11 <int-e> looking at the usage, <<. seems more appropriate
20:19:36 <dons> so you could write, maybe, read .<< hGetLin
20:19:59 <sethk> dons, pointfree is about eliminating unnecessary dummy variables, essentially?
20:20:19 <dons> and then flip fmap could be >>.
20:20:36 <dons> sethk, yeah, basically. there's a lot of theory behind it.
20:20:41 <dons> but I use it for that purpose
20:21:12 <dons> in fact, if you install lambdabot, there are vim bindings to @pl you can call from inside the editor. :)
20:21:51 * int-e has been using flip mapM_ [...] $ \var -> ... lately.
20:22:07 <dons> yes, flip mapM_ should have a name
20:22:10 <dons> for ?
20:22:24 <dons> foreachM_ ?
20:22:27 <dons> to be a bit perlish
20:23:48 <sethk> fmap is still confusing to me.  in your example (pl's example, actually) it used:   fmap read 
20:23:53 <sethk> sorry,
20:23:58 <sethk> hit return prematurely
20:24:16 <sethk> fmap is still confusing to me.  in your example (pl's example, actually) it used:   fmap read hGetLine h
20:24:25 <dons> ?type fmap
20:24:26 <lambdabot> forall (f :: * -> *) b a.
20:24:26 <lambdabot>    (Functor f) =>
20:24:26 <lambdabot>    (a -> b) -> f a -> f b
20:24:33 <sethk> the signature of fmap is (a-b) -> f a -> f b
20:24:38 <int-e> *infix* uses of fmap confuse me. sethk: fmap read (hGetLine h)
20:24:50 <sethk> int-e, yes, that part I got (the infix part)
20:24:52 <dons> takes a function, and a value in a Functor (of which monads are functors) and maps the function over that value, producing a new value in that functor
20:25:13 <Cale> (+1) `map` [1,2,3]
20:25:15 <Cale> > (+1) `map` [1,2,3]
20:25:16 <lambdabot> [2,3,4]
20:25:18 <int-e> sethk: in the context of monads, fmap equals liftM. maybe that helps?
20:25:26 <sethk> but it seems like (from the signature) it should produce a function that operates on b, but it doesn't
20:25:37 <sethk> int-e, no, I'm equally confused by both  :)
20:26:01 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
20:26:05 <Cale> which is the same as
20:26:06 <dons> fmap read (x :: IO a) will give you a result of type IO b .
20:26:08 <Cale> fmap :: (Functor f) => (a -> b) -> (f a -> f b)
20:26:37 <sethk> Cale, oh, yes, that second set of () was what I am missing
20:27:48 <dons> Cale, btw, I've created:
20:27:50 <dons> ?wiki Research_papers
20:27:50 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers
20:27:57 <dons> so feel free to add things
20:28:00 <dons> ski, you too.
20:28:05 <dons> and int-e
20:28:10 <dons> and anyone who reads haskell papers
20:28:21 <araujo> hiya!
20:28:38 <dons> it occcurs to me that Haskell must be one of the best documented languages ever written. probably the best.
20:28:41 <Korollary> man, it's been a long week. I can't focus on haskell code.
20:28:47 <dons> every single feature has 3 papers or more written on it
20:29:19 <dons> so its just a matter of collecting and sorting those papers, for a 10,000 page guide to Haskell ;)
20:30:02 <newsham> dons: wow, very nice (papers page)
20:30:08 <Cale> Java must be the most redundantly documented language :)
20:30:26 <Korollary> Cale: redundantly how?
20:30:30 <newsham> quickcheck missing.
20:30:32 <dons> yes. so each feature of Java has 30 subtyping rules, and 100 papaers
20:30:52 <dons> newsham, adding John Hughes' papers now.
20:31:07 <Cale> If you don't like the first 10 Java books you come across, there will be another 50 just like them ;)
20:31:24 <dons> but , i mean, go through the mailing list. there's a couple of 100 authors (or more) who've published on haskell in the last 15 years.
20:31:34 <dons> and no where are those papers collected
20:31:54 <Cale> Even mailing list articles by the right people are often pretty decent quality reading.
20:32:01 <Cale> (oleg comes to mind)
20:32:27 <dons> so what i'm doing is going to people's home pages, and checking the www.informatik.uni-trier.de data base for bibtexs. and trying to sort these papers
20:32:37 <sethk> dons, in that getRequest function, things are piped along until the  case status of    so would it be better to have something like   status <-  ....    (everything before case lined up as a pipe)
20:32:39 <dons> and then, yeah, we need to add some things that appear on the mailing list
20:32:48 <dons> (like lennart's suggestion that [] and () be conids)
20:32:57 <dons> way back in 91, I think, which changed the language 
20:33:05 <newsham> what did hGetBufBA/hPutBufBA do?  what replaces those?
20:33:20 <Cale> oh, he's responsible for that?
20:33:37 <dons> yeah. I spotted the mail in the archives I've hosted.
20:34:20 <dons> here: http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg01373.html
20:34:48 <dons> sethk, yeah, its reasonable to line things up.
20:35:01 <dons> but its pure, so getStatus would need a 'let'
20:35:08 <dons> let status = getStatus msg ?
20:36:18 <sethk> dons, or a return?
20:36:33 <sethk> dons, how do I load a package module in ghci? 
20:36:44 <sethk> @type hGetLine
20:36:45 <lambdabot> Not in scope: `hGetLine'
20:36:53 <dons> :m
20:37:05 <dons> possibly with -package foo on the command line
20:37:25 <dons> i.e. Prelude> :m Control.Monad.Writer
20:37:45 <sethk> :m works
20:41:58 <Cale> hehe, Spineless Tagless Boxless G-machine
20:42:19 <dons> hehe
20:43:06 <malig> whoa, when did it get "boxless" too?
20:43:22 <sethk> dons, why did you use _ rather than "otherwise"?  Just less typing?
20:43:30 <newsham> soon it wont even need a computer
20:43:58 <dons> yeah. and I think it takes just a little longer to parse in your head that 'otherwise' means 'dont care'
20:44:12 <dons> in boolean conditions, I prefer 'otherwise'
20:44:23 <dons> in patterns, I prefer the wildcard pattern, _
20:44:52 <dons> since 'othewise' in a pattern isn't really otherwise...
20:44:53 <Cale> Disclaimer: C.A.T.S.U.P. does not necessarily represent the views of
20:44:54 <Cale> either the Yale Haskell Project or any of its members or management.
20:44:54 <Cale> Please don't tell Paul Hudak that I'm spending his grant money this
20:44:54 <Cale> way.  
20:44:56 <Cale> haha
20:45:11 <dons> its binding a new variable, sethk, which matches everything, and is called 'otherwise'
20:45:27 <dons> its not the same as the 'otherwise' function, which returns True.
20:45:42 <sethk> dons, I was talking about otherwise as a case
20:46:17 <dons> but you know that 'otherwise' as a case is the same as writing 'atherwose' as a case?
20:46:21 <dons> or 'x'
20:46:29 <dons> or _
20:46:33 <sethk> dons, no, I didn't
20:46:39 <dons> ah, that's what I was chceking
20:46:43 <dons> ?type otherwise
20:46:44 <lambdabot> Bool
20:46:46 <sethk> dons, the same as a function pattern?
20:46:57 <sethk> if I do   foo x
20:47:02 <sethk>    |  whatever
20:47:08 <sethk>      | otherwise
20:47:14 <sethk> that's just an arbitrary name as well?
20:47:15 <dons> no the same.
20:47:18 <int-e> @type _
20:47:19 <lambdabot> Pattern syntax in expression context: _
20:47:20 <dons> not the same
20:47:24 <int-e> hehe :)
20:47:35 <sethk> well, close, I guess :)
20:47:37 <dons> in a guard, it evaluates to True. which is True, so that branch is taken
20:47:59 <int-e> > otherwise
20:47:59 <dons> but in a case, which is a pattern matching construct, a variable name binds to the pattern it matches
20:47:59 <lambdabot> True
20:48:16 <dons> so 'otherwise' in a case is just a new variable name that you bind to the pattern that matches it 
20:48:16 <int-e> @index otherwise
20:48:16 <lambdabot> Data.Bool, Prelude
20:48:26 <dons> which is the entire expression you're scrutinising
20:48:45 <dons> > case 1+2 of  7 -> 7; otherwise -> otherwise
20:48:46 <lambdabot> 3
20:49:00 <dons> see what I mean? that''s a new 'otherwise' you've got there. not the Prelude one.
20:49:09 <dons> unlike this:
20:49:26 <dons> > case 1+2 of  7-> 7; x   | x == otherwise -> x
20:49:27 <lambdabot>  add an instance declaration for (Num Bool)
20:49:27 <lambdabot>   In a case alternative: 7 -> 7
20:49:27 <lambdabot>   In the case expression:
20:49:54 <dons> > case True of False -> 7; x | x == otherwise -> True
20:49:55 <lambdabot>  add an instance declaration for (Num Bool)
20:49:55 <lambdabot>   In a case alternative: False -> 7
20:49:55 <lambdabot>   In the case expression:
20:50:03 <dons> > case True of False -> False; x | x == otherwise -> True
20:50:04 <lambdabot> True
20:50:12 * int-e had not realized that 'otherwise' is not a special syntax (ok, I never thought about it either)
20:50:27 <Cale> > otherwise
20:50:28 <lambdabot> True
20:50:30 <dons> its just : otherwise = True, defined in the prelude.
20:51:01 <dons> > if otherwise then 1 else 2
20:51:02 <lambdabot> 1
20:51:29 <Cale> > let wise = False in wise || otherwise
20:51:29 <lambdabot> True
20:51:41 <dons> > case () of wise -> otherwise
20:51:42 <lambdabot> True
20:51:48 <dons> > case () of wise -> wise
20:51:49 <lambdabot> ()
20:51:56 <dons> > case False of wise -> not wise
20:51:57 <lambdabot> True
20:52:01 <dons> ;)
20:52:17 <Cale> hehe
20:52:34 <sethk> dons, on that server code, the compiler will barf unless I provide implementations for handleRequest and handleResponse, right?
20:52:50 <dons> it will emit a warning about no default instance
20:53:05 <sethk> ok, that's what I thought
20:53:21 <dons> and when you run runServer with a particular Server instance, youu better have such an instance
20:53:24 <dons> or it won't compile
20:54:32 <dons> you could provide a default instance of 'id' .. the empty handler.
20:55:07 <sethk> dons, no, better for it to barf on compile.
20:55:22 <sethk> O
20:55:35 <sethk> I'll just put the instances declarations in the file where I define the handlers
20:56:57 <dons> yeah, it's this that leads to the warning: instance Server LoadtestRequest LoadtestResponse
20:57:00 <dons> where there's no body.
20:57:16 <dons> if you use -Wall -Werror, it will be a fatal compile error to leave off the body
20:57:21 <dons> since there's no default
20:57:36 <sethk> dons, even with an empty handler there would be an error?
20:57:51 <dons> no. if you provide a default handler. then that's ok.
20:58:09 <sethk> dons, then I won't.  I'd rather find out I screwed up at compile time  :)
20:58:14 <dons> but with no default, the warning about no default becomes fatal, when you write an instance that suggests there is a default
20:58:38 <dons> so, I say, have no default, and add -Wall -Werror, so it really does screw up, and not just warn you
20:58:57 <sethk> dons, yes, that's sensible
20:59:35 <dons> it's a bit unhaskellish that writing an instance to a class with no default leads to a runtime error
20:59:42 <dons> an empty instance
20:59:50 <dons> Cale, ski, whaddya thing?
20:59:52 <dons> k.
21:00:19 <dons> you shouldn't need -Werror to make such a thing fatal.
21:00:26 <Cale> hm?
21:00:36 <Cale> (sorry, haven't been watching)
21:00:58 <Cale> oh
21:01:08 <sethk> dons, if I use -Wall, I have to provide a signature for every function.
21:01:18 <dons> a class with no default methods, and then you write an empty instance, you only get a warning that there's missing code
21:01:34 <dons> sethk, unless you turn off that particuar warning. let me find the flag
21:01:43 <Cale> Yeah, so long as the class itself isn't devoid of methods, I'd want leaving anything without a default out to be an error
21:02:10 <Cale> However, it would just make the presence of 'fail' in Monad even more annoying. :)
21:02:17 <dons> or turn on, sethk, -fwarn-missing-methods
21:02:38 <dons> so, you can have: -Wall -fno-warn-missing-signatures
21:02:40 <sethk> dons, the warning is on by default, I think just -Werror gets the combination we want
21:02:47 <dons> or have just -fwarn-missing-methods
21:02:54 <dons> oh. hmm. but how to make it fatal.
21:02:55 <sethk> oh, that way I can have the other -Wall stuff, you mean
21:03:10 <sethk> Werror makes all warnings fatal, I thought
21:03:18 <dons> yeah, I usually have -Wall -Werror, and then use -fno-warn .... to turn off things i don't care about
21:03:44 <dons> oh, -Werror -fwarn-missing-methods would make just the missing method error fatal
21:04:11 <dons> or, -Wall -Werror -fno-warn-missing-signatures, would give you all fatal errors, but for missing signatures
21:08:26 <malig> I have to admit I'm still stunned when "tying the knot" actually works
21:09:07 <malig> it's like I just performed the kind of magic that normally requires a lot more goat's blood
21:10:13 <dons> ?remember malig I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
21:10:13 <lambdabot> Done.
21:10:16 <dons> :)
21:10:19 <dons> ?quote malig
21:10:19 <lambdabot>  I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
21:10:28 <malig> :)
21:12:23 <Korollary> http://sites.gizoogle.com/index2.php?url=http%3A%2F%2Fwww.haskell.org%2Fhawiki%2FTyingTheKnot
21:13:07 <newsham> hmm.. Control.Exception.bracket is nifty
21:13:37 <malig> I've now got a rudimentary quantum computer simulator where you don't need to know how many qbits to run, it zips through the state monad to figgure that out for you, then runs through again to actually do the work :)
21:17:51 <newsham> i'll get heisenberg's cats
21:19:14 <malig> quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes
21:19:30 <malig> at least it disallows time travel
21:19:42 <dons> ?remember malig quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes. at least it disallows time travel
21:19:43 <lambdabot> Done.
21:19:45 <dons> this is all gold!
21:20:17 <newsham> I have a good intuition about lazy evaluation since I grew up lazy
21:20:25 <malig> heh
21:20:38 <newsham> I didn't grow up wavey, and quantum computing hurts my head
21:20:46 <newsham> s/computing/mechanics/
21:20:57 <malig> I'm just good at trusting the math
21:21:13 <newsham> eh, bad scientist!  be suspicious of everything!
21:22:42 <Korollary> I wonder if a type system makes sense for a quantum computer if the output is probabilistic anyway.
21:23:27 <malig> The final output is probabalistic, but internally, it's all vectors+matricees
21:23:59 <newsham> dont you just get a set of superimposed answers?
21:24:41 <Korollary> what is considered the final output? I suppose it can be modeled by taking the value out of a monad.
21:25:13 <malig> you get [(Complex Double,QState)]
21:26:00 <malig> where QState is just how you decided to represent the state of the system
21:27:40 <Korollary> Then what does reading the output correspond to ? [(Complex Double, QState)] -> IO [Complex Double] ?
21:28:21 <malig> [(Complex Double, QState)] -> IO QState
21:28:29 <Korollary> ah
21:34:03 <Korollary> quantum computers will make unit testing pretty interesting.
21:34:38 <Korollary> oops. The test failed. The odds were 1 in 20. Tee hee.
21:35:42 * araujo hacks a bit
22:08:08 * araujo looks around
22:10:41 <newsham> heh.. great.  HWS allows you to get ../../ urls
22:19:16 <sethk> dons, et. all, I'm having a bit of trouble with the code to run the server class we created earlier
22:20:07 <sethk> it wants a constructor or a class, and we're giving it a type
22:22:43 <dons> can you post the code/
22:23:07 <sethk> dons, yes
22:23:10 <dons> do you mean:  runServer stdin (S :: S LoadtestRequest LoadtestResponse)
22:23:16 <sethk> dons, right
22:23:22 <sethk> I have to construct those arguments
22:23:26 <dons> where LoadtestRequest and Response are in Server, Request and Response classes
22:24:02 <sethk> yes, right
22:24:13 <sethk> it is also giving me "ambiguous occurance handleRequest"
22:24:20 <sethk> where I put the handleRequest implementations
22:25:13 <dons> can you post the code. And i'll have a look.
22:26:17 <sethk> dons, ok. I must have a detail wrong.  Posting it now.
22:34:42 <sethk> dons, http://paste.ubuntu-nl.org/11736
22:34:51 <sethk> dons, sorry it's somewhat long.
22:34:51 <dons> ok. looking
22:35:13 <sethk> dons, I did change a type slightly, which might be part of the cause (although I think I did it correctly)
22:35:34 <sethk> dons, handleRequest is Handle -> request -> IO Response
22:35:41 <sethk> dons, and handleResponse no longer exists
22:36:19 <sethk> dons, there is a commented out function in the last file, lrunServer, which is what I would code specifically for the types, in case that helps you see what I'm thinking
22:36:44 <sethk> but the main problem is I'm invoking runServer incorrectly
22:36:49 <dons> ok. gimme me a few mins to read the code and think about it.
22:37:38 <sethk> possibly runServer is commented out, but you see what I mean  :)
22:37:45 <sethk> thanks for looking
22:38:50 <sethk> dons, don't look at handleRequest yet, the arguments are backwards  :)
22:39:33 <dons> ok..
22:40:51 <sethk> also an argument is missing from putRequest in lrunServer, so ignore that also
22:47:25 <sethk> dons, the third file with all the errors fixed:  http://paste.ubuntu-nl.org/11737
22:48:03 <dons> ok.
22:48:06 <dons> grabbing it
22:48:40 <sethk> it compiles now, with the real runServer commented out.  With the read runServer in, it says "not in scope: type constructor or class FinalizeRequest"
22:48:51 <sethk> which is sensible, since FinalizeRequest is a type, not a class or a constructor
22:48:57 <sethk> but I don't know how to make the compiler happy
22:49:16 <dons> ok. lets see if i can compile it
22:49:39 <dons> oh, i don't have WTrace. 
22:49:49 <sethk> I'll paste it
22:49:50 <dons> yeah. hmm. ok. I'll just have too look at it.
22:50:06 <dons> yeah, but I'd need about 5 modules more to type check it.
22:50:09 <dons> all the stuff in Main.
22:50:26 <sethk> I can strip it down, or I can paste all those files
22:50:27 <dons> I might be able to get by. hang on.
22:50:32 <sethk> ok
22:50:43 <dons> ok, so ClientServer is fine.
22:50:54 <sethk> yes, the compiler likes it
22:51:05 <sethk> it's only the runServer invocation that it is upset about
22:51:37 <dons> the  call to runServer in FinalizeCommand.hs?
22:51:47 <sethk> no, in finalizeServer.hs
22:51:54 <dons> or the weird lrunServer thing?
22:52:03 <sethk> the lrunServer the compiler likes
22:52:13 <sethk> lrunServer is what I would have coded without a polymorphic runServer
22:52:23 <dons> hmm. finalizeServer.hs am I missing that file?
22:52:40 <sethk> I pasted all three files into one paste.  Then the corrected paste is only finalizeServer.hs
22:52:55 <dons> ahh ok.
22:53:03 <dons> but its the module Main?
22:53:42 <sethk> right
22:54:00 <sethk> sorry, I forgot you don't have file names
22:54:07 <dons> so you want to replace the lrunServer with a call to runServer?
22:54:12 <sethk> right
22:54:32 <dons> i see a typo. 
22:54:35 <sethk> all it does is call getRequest, then handleRequest, then putResponse, and then starts all over again
22:54:39 <sethk> ok, where
22:54:40 <dons> FinalzeRequest
22:54:48 <dons> should be Final_i_zeRequest
22:55:06 <dons> in the call to runServer
22:55:28 <sethk> that's a dumb mistake
22:55:31 <sethk> let me compile it
22:55:48 <dons> otherwise, looks like everything should be fine.
22:56:08 <sethk> dons, thanks.  I was looking for something difficult
22:56:14 <dons> :)
22:56:16 <sethk> It's 1 am here  ...
22:56:35 <sethk> wait, I didn't really compile it yet...
22:56:46 <dons> dang, ghc error. must be something to do with existential, polymorphic whatsits ;)
22:57:14 <sethk> now I'm getting No instance for (Server FinalizeRequest FinalizeResponse) arising from use of runServer ...
22:57:27 <sethk> maybe I mispelled the instance statement
22:57:28 <dons> ok. lets see 
22:57:51 <dons> oh. because there's no instance.
22:57:57 <dons> i can't find the instance of Server for those
22:58:02 <sethk> I guess that could cause a no instance message
22:58:12 <dons> its not in FinalizeCommand.hs
22:58:15 <dons> could be
22:58:23 <sethk> right, I see.  let me try putting one in
22:58:57 <sethk> ok, now "no explicit method nor default method for handleRequest"
22:59:04 <sethk> there is a method, but it's in a different file
22:59:13 <sethk> should I move the instance declaration after the method?
22:59:19 <dons> ah. and its not part of the Server instance decl
22:59:22 <dons> yes.
22:59:38 <dons> it should be : iinstance Server .... where handleRequest = this handle request
22:59:47 <dons> the one you have but in another file.
22:59:53 <dons> just import it
23:00:06 <sethk> but I have a bunch of handleRequest signatures.
23:00:17 <sethk> do I put them all after the where?
23:00:38 <dons> no. you should just declare your Server instance in the same file as the data type 
23:01:08 <dons> what do you mean you have a bunch of handleRequest signatures?
23:01:18 <sethk> dons, the same signature, different constructors
23:01:24 <dons> right.
23:01:29 <sethk> handleRequest handle (FirstConstructor whatever)
23:01:37 <sethk> handleRequest handle (SecondConstructor whatever ...)
23:01:41 <dons> oh sure. 
23:01:45 <sethk> ok, I'll try moving everything into the same file
23:02:24 <dons> I'd just rename that function "handleRequest'" and import it into FinalizerCommand. then write: instance Server.... where handleRequest = handleRequest'
23:02:52 <sethk> it's already called handleRequest
23:03:20 <dons> but its not declared as the handleRequest instance for the Server class
23:03:26 <dons> it just happens to use the same name
23:03:31 <sethk> ok, I see
23:03:46 <dons> I guess you could: import qualified F (handleRequest)
23:03:47 <sethk> so I just put in that instance statement to tell it where to find handleRequest
23:03:55 <dons> then write: instance Server .. where handleRequest = F.handleRequest
23:04:00 <sethk> and handleRequest can actually have any name, it isn't restricted to the name in the signature
23:04:15 <dons> no not at all.
23:04:38 <dons> you just have to write an instance somewhere, where the class method 'handleRequest' is bound to your actual implementation 
23:04:59 <dons> i.e. it could be foo, and you still need to write: handleRequest = foo
23:05:05 <dons> in your Server instance
23:05:09 <sethk> I must have done something wrong.  I didn't import it, just used the instance statement, and the compiler accepted it
23:05:27 <sethk> or is it smart enough to say "ok, he declared it, I'll let the linker find it"?
23:05:36 <dons> what do you mean "just used the instance statement"
23:05:44 <dons> i hope it doesn't rely on the linker..
23:05:49 <dons> kinda bad for type safety
23:06:02 <sethk> dons, I added the line   instance Server FinalizeRequest FinalizeResponse where
23:06:09 <sethk>     handleRequest = handleRequest
23:06:18 <dons> hmm. that's a recursive call
23:06:20 <sethk> but the handleRequest implementation is still in the other file
23:06:33 <sethk> wait, if the name spaces are separate, it can't be a recursive call
23:06:34 <dons> it'll say, ok, he's now got a valid instance
23:06:40 <dons> (just so happens that'll diverge...)
23:07:01 <dons> so you should: import qualified Foo (handleRequest)
23:07:03 <dons> from the other file
23:07:05 <sethk> ok
23:07:16 <sethk> let me change the implementation name to make sure it is really working.
23:07:18 <dons> then write instance Server FinalizeRequest FinalizeResponse where handleRequest =  Foo.handleRequest
23:07:52 <sethk> I guess if the name is qualified I don't have to rename it
23:08:05 <dons> yep. or if you rename it , you don't need to import it qualified
23:08:09 <dons> either is fine
23:08:15 <sethk> ug, now I have a module cycle
23:08:29 <sethk> I think I'll just merge FinalizeCommand and finalizeServer into a single file
23:08:40 <dons> hmm. then you could move the instance Server into the other file?
23:08:48 <dons> you can have instances all over the place
23:08:51 <sethk> yes, I can try that
23:08:54 <sethk> let me try that first
23:09:37 <dons> it'll need to import ClientServer so it knows about the Server class
23:09:48 <sethk> that's already happening
23:10:03 <sethk> I needed it for the Successful enum definition
23:10:10 <sethk> ok, the compiler is happy.
23:10:25 <dons> good.
23:10:29 <sethk> I think I'll use a different name, just to be sure
23:10:45 <sethk> it's already qualified, though, as handleRequest = Main.handleRequest
23:10:55 <dons> hmm.
23:11:09 <dons> I _think_ that will then use the non-class handleRequest
23:11:15 <dons> but renaming is probably safer
23:11:32 <dons> or moving the body of the code into the instance decl, so the'res only one function
23:12:19 <sethk> did I do it backwards?  It says "realhandleRequest is not a (visible) method of class Server"
23:12:28 <sethk> wait, never mind
23:12:33 <sethk> I must have changed one too many
23:12:50 <sethk> yes, it is happy with the name change
23:13:17 <dons> yeah, sounds like you did it backwards
23:13:47 <sethk> actually I did a search and replace and made it say  realhandleRequest = realhandleRequest  :)
23:14:01 <dons> ah
23:14:24 <sethk> ok, now it builds and it's checked into version control for eternity  :)
23:14:31 <dons> hooray!
23:15:06 <dons> and you have a pretty nice class for building modular client/server code.
23:15:09 <dons> so its all good
23:15:15 <sethk> yes.
23:15:36 <sethk> If we made handle a parameter I can write to Control.Current.Chan for multithreaded programs that act like client/server
23:15:58 <sethk> or maybe I just use a less concrete type for handle?
23:16:43 <sethk> that's not the right terminology, less restricted?
23:17:12 <dons> yeah, you could paramaterise over the handle type
23:17:38 <dons> let me see what that would look like
23:17:42 <magiUserL1> hello
23:17:49 <magiUserL1> is haskell an ok first language?
23:18:15 <dons> yes. it's often used at universities as a first language to learn
23:18:31 <sethk> magiUserL1, well, maybe English first, then Haskell
23:18:36 <dons> since it provides the foundations of features used in a wide number of languages
23:18:52 <dons> magiUserL1: check the haskell.org site for an introductionn, and lots of tutorials
23:19:37 <dons> sethk: you'd probably need to make (yet another) class, IsHandle, 
23:20:02 <sethk> ok.  I'll look at that
23:20:06 <dons> so that putRequest :: IsHandel h => h -> -> request -> IO ()
23:20:21 <sethk> and the same for getRequest?
23:20:29 <sethk> with the correct args, of course
23:20:32 <dons> yep. anywhere you have an explicit Handle
23:20:37 <dons> yeah
23:21:18 <dons> your IsHandle class might provide: read/write methods
23:21:38 <dons> so you can abstract over the calls to hPut... and so on
23:23:04 <sethk> dons, yes
23:24:01 <sethk> this is really very powerful
23:24:19 <sethk> and you answered a question I was just about to ask, which is how to get inheritence like behavior
23:25:02 <sethk> now all I have to do is finish three programs and deliver them debugged by monday
23:25:12 <dons> ah, ok :)
23:25:27 <newsham> dons: dont forget to invoice
23:25:33 <dons> hopefully once they type check that should be it.
23:25:47 <sethk> dons, by and large they've been working well
23:25:51 <dons> otherwise, I hope you get a chance to look into QuickCheck
23:25:55 <dons> at some point, anyway
23:26:13 <sethk> I will, definitely.  maybe next week.
23:28:01 <dons> I just think its so crazy academic authors have agreed to hand over copyright to the publisher, considering we do thhe research, write and typeset the paper, organise the conference its announced it and so on.
23:28:25 <sethk> why hand over the copyright?
23:28:39 <dons> and then in return you often need to put disclaimers on your own website, saying the work is copyright ACM and so on
23:28:49 <sethk> sounds like it's time to start a new haskell software company
23:29:23 <sethk> I may not be smart enough to teach in a university, but I'm smart enough not to give away copyrights  :)
23:29:31 <dons> yeah, there aren't enough such companies. and I know phd students who need jobs!
23:29:54 <newsham> dons: and pay to attend the conf you present at
23:30:00 <newsham> and sometimes pay to ahve the paper published
23:30:07 <dons> I'm pretty sure its some historical thing, going back to when the publishers did more and meant more than they do now
23:30:30 <dons> newsham, right.
23:30:33 <sethk> More likely they've been getting away with it for so long everybody thinks of it as normal.  :)
23:30:39 <dons> yeah
23:32:16 <newsham> its the gubmints money.. just another way to channel federal dollars
23:33:33 <magiUserL1> hello
23:33:52 <magiUserL1> is haskell ok for a first language?
23:34:08 <newsham> if you want to do functional programming, yah.
23:34:21 <magiUserL1> does it allow one to sort and do reports?
23:34:27 <magiUserL1> based on data
23:34:39 <dons> sure. transforming data is a good use
23:34:40 <moi_g> Is there any language that isn't okay for a first language?
23:34:41 <newsham> for doing reports, you will probably find other langauges a better starting point
23:34:47 <dons> moi_g, epigram?
23:34:55 <newsham> moi: french?
23:34:59 <dons> moi_g: C++?
23:35:03 <dons> perl
23:35:18 <magiUserL1> I would like to build an app that has data but can be used to sort and produce reports?
23:35:39 <magiUserL1> Am i best off learning a programming language or using a datbase or?
23:35:55 <newsham> there are some pre-made systems and small languages that might be useful
23:36:13 <magiUserL1> I heard tcl and postgresql are good
23:36:19 <newsham> like excel, or awk or a db
23:36:28 <magiUserL1> I just dont know that much and wantt o take advantag of the network to share information
23:36:36 <newsham> i personally would recommend python over tcl, but thats a personal preference
23:36:54 <magiUserL1> python?
23:37:20 <newsham> if you intend to do web stuff, ruby might be a good start (because of their rails system)
23:37:33 <newsham> www.python.org
23:37:53 <magiUserL1> hmm
23:38:03 <magiUserL1> why python over haskell
23:38:13 <magiUserL1> is haskell not suited to doing things as python?
23:38:29 <newsham> if you intend to do a bit of file i/o and you've never programmed before, you might find haskell's IO stuff complicated
23:40:24 <newsham> also more stuff aimed at beginner programmers (haskell has lots of academic stuff which is well thought out, but better suited for philosophers and advanced programers :)
23:40:44 <dons> for philosophers, eh ;)
23:41:11 <newsham> I would put tcl and ruby in the same bin with python, though tcl's time seems to have come and gone.
23:41:38 <moi_g> Python is a good place to start
23:41:46 <newsham> dons: people who wish to spend 3 days writing 3 lines of code (but be the best darned 3 lines anyone has ever written)
23:43:45 <magiUserL1> hmm
23:43:47 <newsham> if you're still interested in haskell.  I would recommend a non-programmer start with:  http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
23:51:10 <MarcWeber> Have you heard of ghumake? do you know where I can get it?
23:51:24 <newsham> gnumake?
23:54:24 <newsham> gnumake is the standard make (ie. /usr/bin/make) on many systems.  some have it as "gmake", you can find it at www.gnu.org if you dont have it yet
23:55:02 <newsham> if you have gnu make, it will say so when you run it as "make -v" (or "gmake -v")
