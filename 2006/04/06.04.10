00:44:31 <Vsajanas> hello to all
00:48:22 <neologism> any expert with parallel algorithms here?
00:49:00 <Vsajanas> Download my games -------->    http://www.thricesoft.com/download.php?list.5
00:51:43 <JohnMeacham> DrIFT-2.2.0 is out.
00:52:39 <newsham> Hi John.  I had some problems with DrIFT earlier and you said it was likely that the parser was failing.
00:52:53 <newsham> is the 2.2.0 parser more robust?
00:53:04 <JohnMeacham> I fixed a bug where it would fail if you used the newtype deriving extension.
00:53:19 <JohnMeacham> so it is a bit more robust, but still pretty cruddy.
00:53:25 <newsham> the code I was using was for processing records
00:54:13 <JohnMeacham> ah. I don't know of any changes that specifically fixed that. I really need to just rewrite the thing.
00:54:25 <JohnMeacham> here is the changelog http://repetae.net/john/repos/DrIFT/Changelog
02:34:18 <__phas> Hi at all
02:34:31 <__phas> anyone knows how to install gtk2hs on macosx?
02:56:47 <mnislaih> I got some code I need to optimize
02:56:55 <mnislaih> any one willing to have a look at it ?
02:57:03 <mnislaih> http://pastebin.com/650970
02:57:28 <mnislaih> terms of the CNF datatype can get very big and the thing will just run out of memory
02:57:41 <mnislaih> I need to make the code more strict or change the data structure
02:58:19 <basti_> uhm
02:58:34 <basti_> like how big?
02:58:48 <mnislaih> huge
02:58:53 <mnislaih> really huge...
02:58:58 <basti_> I'd assume reasonable use of any CNF term would not need all the memory of a normal computer.
02:59:11 <basti_> what are you trying to do?
02:59:24 <mnislaih> this is a basic algorithm to put a logical proposition into Conjunctive Normal form
02:59:40 <mnislaih> the basic algorithm can produce an exponential growth in the number of clauses
02:59:46 <basti_> yes.
03:00:00 <basti_> so?
03:00:00 <basti_> ;)
03:00:01 <mnislaih> but I prefer to use an external optimizer and keep my haskell code simple
03:00:14 <mnislaih> I just need it to run in 1 second or so
03:00:30 <mnislaih> the propositions I use 'should work'
03:01:07 <basti_> hmm i don't see any way to make the data more terse in haskell
03:01:20 <basti_> there's a way to "unbox" stuff, but i don't think that works for own datatypes
03:01:23 <mnislaih> the problem is in the sortCNF function
03:01:39 <basti_> why do you put the term into CNF at all?
03:01:41 <mnislaih> I think it makes too many copies of terms, and the recursivity hurts the memory
03:01:46 <basti_> can't you evaluate it how it is?
03:01:52 <mnislaih> because I need to interface with an external SAT solver
03:02:00 <basti_> hmm
03:02:00 <mnislaih> which needs the input term to be in CNF
03:02:21 <basti_> isn't SAT DNF?
03:02:26 <mnislaih> I've been profiling it, but I'm not very experienced with heap profiling
03:02:27 <mnislaih> nope
03:02:32 <basti_> (since CNF solving is trivial?!)
03:02:50 <basti_> (you just pick out one term?)
03:02:57 <mnislaih> I'm no expert in SAT solving, but I am positive that all SAT solvers out there demand CNF
03:03:16 <basti_> hmm
03:03:40 <basti_> ah yes
03:03:47 * basti_ got it the wrong way around
03:03:50 <basti_> hmm ok
03:04:15 <basti_> did you try profiling your program?
03:04:48 <mnislaih> I did some cost profiling
03:04:51 <ndm_> if you are going for DNF/CNF, you might want to look at clausify
03:05:02 <mnislaih> but the heap profiling is something alien to me
03:05:09 <ndm_> thats a very well optimised convertor
03:05:19 <ndm_> which was the subject of several heap profiling papers
03:05:42 <ndm_> it went from minutes to milliseconds
03:05:45 <mnislaih> where can I find info about it
03:06:04 <mnislaih> @google clausify
03:06:05 <lambdabot> http://www.poplog.org/docs/popdocs/prolog/teach/clausify
03:06:38 <mnislaih> ndm_ oh, in the nofib suite ?
03:06:59 <ndm_> mnislaih: there are more up to date versions, the clausify one is slower than the last paper
03:07:13 <ndm_> but its probably a reasonable start
03:07:49 <ndm_> http://scholar.google.com/scholar?q=clausify+author%3Arunciman&ie=UTF-8&oe=UTF-8&hl=en&btnG=Search
03:08:17 <mnislaih> this looks great, gonna give it a view
03:08:24 <mnislaih> thanks !
04:00:10 <JohnMeacham> where do the ghc developers roam?
04:01:25 <liyang> On the green grassy knolls of West Cambridge.
04:08:28 <JohnMeacham> I am glad to say that jhc has ~3500 less lines of code than it did last week. I feel much more productive ripping out code than writing new stuff.
04:11:14 <ADEpt> @where unsafeInterleaveIO
04:11:15 <lambdabot> I know nothing about unsafeinterleaveio.
04:11:38 <ADEpt> @index unsafeInterleaveIO
04:11:39 <lambdabot> System.IO.Unsafe
04:28:24 <ndm_> anyone any good with Parsec?
04:28:30 <ndm_> Program error: Left "hoogle.txt" (line 6, column 8):
04:28:32 <ndm_> unexpected "I"
04:28:34 <ndm_> expecting space, letter or "_"
04:28:40 <ndm_> why is "I" not a letter?
04:33:03 <basbom> hi
04:33:50 <basbom> can you send command line arguments to a haskell program? (I am using hugs)
04:34:41 <liyang> @index getArgs
04:34:42 <lambdabot> System.Environment
04:35:03 <basbom> thx bro
04:47:06 <basbom> how to use getArgs? What I want to achieve is to be able to run e.g. "hugs.exe script.hs 1323.3"
04:48:05 <Lemmih> basbom: Got 'runhugs'?
04:48:50 <basbom> Lemmih: no, I need to install another program?
04:49:43 <basbom> Lemmih: ok, I found it, it's in the hugs directory
04:50:20 <lennart> good morning
04:50:59 <basbom> invalid module....
04:51:35 <basbom> it needs some tweaking i guess.
05:23:26 <blackdog> is there a web interface to #haskell?
05:23:51 <integral> the logs are online...
05:23:54 <dons> ?
05:24:09 <dons> blackdog is more and more kooky every day ;)
05:24:46 <blackdog> not quite what i mean - i want to set up a webpage to talk to vixen so i won't ever be lonely again.
05:24:49 <dons> who was askign about a web interface to lambdabot yesterday?
05:25:02 <integral> blackdog: you can download lambdabot's source and turn it into a CGI...
05:25:05 <dons> lambdabot has an offline mode now. no irc required.
05:25:34 <blackdog> already integrated into CGI, or just stdin/stdio?
05:25:39 <dons> so that could be wrapped with a little bit of cgi
05:25:43 <dons> just stdin
05:26:10 <blackdog> i actually already have a web interface on, i just wanted to see if i could do it more easily. CGI798 is mine
05:26:27 <blackdog> i'm not sure if i have haskell on the webhost, y'see...
05:26:37 <kaol> what's the state of the art with haskell web servers and/or dynamic content?
05:27:04 <blackdog> little bitty.
05:27:22 <blackdog> it'/d be a good niche for a killer app
05:30:54 <dons> $ ./lambdabot 
05:30:54 <dons> lambdabot> vixen who's your daddy?
05:30:54 <dons> i dunno, who?
05:30:54 <dons> lambdabot> quit
05:41:27 <JohnnyL> haskell should have a summit meetings in new york. :)
05:47:47 * astecp is trying to find a crash course in the type theory used by Haskell.
05:49:09 <astecp> as in, the basics of how to manipulate type signatures with lots of arrows in them :) .. I don't even know what this is called formally
05:51:35 <JohnnyL> astecp, i am new too. isn't haskell a beautiful language. once you can master it, it's so easy to write haskell 'scripts' to do stuff in minutes thats make take an hour or two with c (having too much administration).
05:52:01 <Saulzar> astecp, They're functions, eg. Int -> String   takes an int and returns a string. I recomend the yast tutorial for an introduction
05:52:04 <Saulzar> @where yast
05:52:05 <lambdabot> I know nothing about yast.
05:52:12 <Saulzar> @where yaht
05:52:13 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
05:55:03 <Lemmih> dons: Have you thought about serialising CompiledByteCode or perhaps just ProtoBCO's? I think it's necessary for the kind of plugins I'm using in hIDE.
05:57:05 <astecp> thanks. I'm actually working not in haskell but on paper, looking for something to help me understand how to write type signatures for lambda-calculus expressions :). That book looks good though
05:58:04 <blackdog> don, you still around? I think i'm getting hit by the ld problem you posted a few years ago, but EXTRA_CC_OPTS doesn't seem to help
06:52:14 <JohnnyL> how can I stick an if into a fibonacci foruma (the following doesn't work): fibs = 1 : 1: if fibs > 2600 then error "done" else zipWith (+) fibs (tail fibs)
06:52:56 <blackdog> don't.
06:53:24 <blackdog> you want to create the list of fibs, then takeWhile some condition.
06:53:35 <blackdog> stop thinking imperatively :)
06:54:47 <Philippa> that's not an imperative thought per se, it's a strict one
06:55:09 <blackdog> mea culpa, you're quite right
06:57:10 <ski> 'fibs' is not a number, hence can't be compared to '2600'
07:02:43 <JohnnyL> takeWhile, ok, now where is the reference manual that lists all of haskells Prelude functions?
07:03:18 <blackdog> @hoogle prelude
07:03:19 <lambdabot> Prelude :: module
07:03:19 <lambdabot> Language.Haskell.Syntax.prelude_mod :: Module
07:03:19 <lambdabot> Distribution.Extension.NoImplicitPrelude :: Extension
07:03:54 <blackdog> if you google haskell prelude, you should get it.
07:04:17 <JohnnyL> k
07:04:46 <mauke> http://www.haskell.org/onlinereport/standard-prelude.html
07:06:25 <JohnnyL> sweet
07:06:31 <JohnnyL> thx
07:07:43 <JohnnyL> What's | do? where can I get the information on haskell symols like '|' bar
07:07:44 <JohnnyL> ?
07:08:17 <Philippa> | does different things in different places
07:08:19 <mauke> read the rest of the report :-)
07:10:21 <Philippa> it does one thing in types and another in patterns. I *think* that's the lot...
07:11:01 <JohnnyL> what's a pattern? like ming _ _ ?
07:11:14 <Philippa> yeah
07:11:21 <Philippa> (RTFReport, it'll help)
07:11:33 <JohnnyL> k
07:11:41 <Igloo> It's in list comprehensions too
07:12:03 <blackdog> also in the || operator :{
07:12:13 <blackdog> hm. don't know where that moustache came from
07:12:15 * Igloo fails to think what it does in types
07:12:33 <blackdog> data Foo = Bar | Baz
07:12:35 <Igloo> blackdog: If you don't shave then they just appear, as if by magic
07:13:03 <Igloo> Oh, that's data declarations, not types  :-)
07:13:11 <blackdog> mine doesn't. if i don't shave, i look amish. :( it's ok for you hairy types.
07:13:31 <blackdog> pedant. :)
07:13:56 <JohnnyL> to return muliple values/functions in haskell it would be through a tuple (func 1 func 2) ?
07:15:09 <Saulzar> JohnnyL, Yeah, usually - a tuple or matching against a data type
07:47:54 <kowey> hi all... i notice that Data.Hashtable stuff are in IO... is it impossible to have "pure" hashtables somehow (that presumably would be more efficient than Data.Map on the average case?)
07:48:10 <xerox> Data.IntMap?
07:49:26 <kowey> oh! i was just looking at that and got confused; somehow i thought that i'd have to implement hashtables on top of that, but those are hashtables
07:49:29 <kowey> silly me
07:49:51 <lispy> kowey: stop being silly ;)
07:51:02 <kowey> :-) (*tsk* all this time i was trying to replace foldr with foldl' when I could have been thinking about more efficient data structures)
07:52:10 <kowey> oh, and thanks, xerox
07:52:37 <xerox> You're welcome.
08:15:52 <JohnnyL> as far as show is concerned it appears to be in each primitive, is this true? like how does zip width know to space between each fibonacci series?
08:16:02 <JohnnyL> zipwith
08:16:09 <xerox> Err... ?
08:16:39 <xerox> Do you mean that the output is pretty-printed?
08:19:12 <davidhouse> yeah, i understood pretty much none of that
08:24:03 <bolrod> sjanssen: yo!  someone actually did post a better version of inits I think
08:25:35 <JohnnyL> xerox, precisely.
08:26:24 <xerox> JohnnyL, that's not a property of the individual functions.
08:27:02 <xerox> JohnnyL, OTOH there is a quantity of libraries and licterature concerning Pretty Printing.
08:28:53 <JohnnyL> ok
09:05:15 <heatsink> @pl \x y -> y x
09:05:15 <lambdabot> flip id
09:05:20 <heatsink> ah
09:05:26 <xerox> a -> (a -> b) -> b
09:05:45 <heatsink> @pl \y -> y x
09:05:45 <lambdabot> ($ x)
09:06:09 <xerox> Eh, x is unbound.
09:08:36 <davidhouse> which is why it appeard in the answer
09:09:05 <davidhouse> > let x = "hello" in (\y -> y x) (map toUpper)
09:09:07 <lambdabot> "HELLO"
09:09:16 <davidhouse> > let x = "hello" in ($ x) (map toUpper)
09:09:17 <lambdabot> "HELLO"
09:09:31 <xerox> HELLO.
09:09:45 <davidhouse> hi xerox.
09:10:02 <ayrnieu> > map toUpper x where x = "hello"
09:10:03 <lambdabot> "HELLO"
09:11:28 <bolrod> !!
09:11:40 <bolrod> yo.. I'm trying to recompile the List lib
09:11:47 <bolrod> now I get syntax error
09:11:56 <bolrod> because of:
09:11:56 <bolrod> #ifdef __NHC__
09:11:56 <bolrod>      [] (..)
09:11:56 <bolrod>    ,
09:11:57 <bolrod> #endif
09:12:03 <bolrod> can the ghc handle that?
09:12:12 <heatsink> It's supposed to go through cpp first.
09:12:14 <xerox> Yes.
09:12:17 <bolrod> aha
09:12:19 <bolrod> ok
09:12:22 <xerox> Run ghc with -cpp flag.
09:12:26 <bolrod> thx
09:12:52 <xerox> There also is a standalone utility for that.  I think it's called hscpp/cpphs, or something similar.
09:13:09 <bolrod> ok.. now its bothering me that its already in the standard lib
09:13:12 <bolrod> should I remove it first?
09:13:14 <bolrod> or can I force it
09:13:25 <xerox> Err... what?
09:13:34 <bolrod> I'm compiling Data.List
09:13:41 <bolrod> without that stupid old inits
09:14:02 <xerox> Oh-uhm.
09:14:07 <bolrod> 8)
09:14:39 <bolrod> oh  and what is   List.p_hi  ?
09:15:26 <davidhouse> bolrod: what's wrong with "stupid old inits"?
09:15:30 <bolrod> its slow
09:15:35 <bolrod> mighty slow
09:15:37 <davidhouse> ah
09:15:55 <bolrod> yap
09:17:10 <bolrod> well...  I'll go eat first if nobody knows it :)
09:24:29 <dozer> afternoon
09:28:52 <Quinthius> afternoon :)
09:29:25 <dozer> is it quiet in here today?
09:30:22 <davidhouse> dozer, seems so ;)
09:30:31 <davidhouse> unless you've got everyone on /ignore
09:31:02 <dozer> na - haven't got /that/ anoyed with anybody here yet
09:31:28 <davidhouse> heh :)
09:34:11 <xerox> ohub, you made Muad_Dib go away!
09:34:21 <ohub> what?
09:34:37 <ohub> who are you? and why are you talking to me every day? :)
09:34:46 <xerox> ARGH.
09:35:04 <xerox> YOU're why I'm not able to write "Oh" from a week!
09:35:11 <xerox> ....sorry.
09:35:16 <ohub> don't use tab complete ;)
09:35:40 <xerox> I don't, it's very strange.  I couldn't replicate this strange behavior when I was thoughtfully trying to...
09:36:07 <xerox> You made me try to spread a new kind of "Oh" :-)
09:36:18 <ohub> hehe
09:36:27 <xerox> Actually I was beginning to like it.
09:36:59 <ohub> hopefully you are the only one. It wouldn't be nice to have my nick as regular slang word :)
09:37:25 * xerox will rather keep, *evil laugh*
09:39:21 <dozer> is an sml Option the same as a Haskell Mabey?
09:39:35 <ski> yes
09:40:50 <vincenz> Maybe
09:40:55 <vincenz> > Nothing
09:40:55 <lambdabot> Add a type signature
09:40:59 <vincenz> > Just "a"
09:41:00 <lambdabot> Just "a"
09:41:04 <vincenz> > Nothing :: (Maybe String)
09:41:05 <lambdabot> Nothing
09:41:46 <vincenz> lambdabot not responding to pm's?
09:41:52 <vincenz> > take 10 $ 'a':v
09:41:52 <lambdabot>  Not in scope: `v'
09:41:55 <xerox> YEs he is.
09:41:56 <vincenz> dog
09:41:58 <vincenz> doh even
09:42:00 <xerox> she even
09:42:30 <dozer> gha! I wish kde let you tie windows together so that focus on one caused visual focus on the others
09:43:03 <xerox> dozer, MDIs?
09:43:24 <dozer> xerox_: ad-hoc ones - like tieing my editor, a shell and a particular kde together
09:45:23 <dozer> oh - can I not have two field labels the same in a single module?
09:47:07 <ski> nope
09:47:24 <CosmicRay> whee.
09:47:29 <CosmicRay> my new globbing module works.
09:47:29 <dozer> can I have data type constructors of the same name on different data-types in a single module?
09:47:43 <ski> (well, you can have two fields (with same type) in different constructors in same 'data' type ..)
09:47:56 <ski> nope
09:48:13 <dozer> ah - ok thx
09:48:34 <ski> (submodules would be handy for this)
09:48:42 <dozer> ski: that kind of puts the kybosh on me using "id" to systematically name parameters throughout a load of declarations then
09:49:31 <ski> you can use same parameter name in different functions, yes
09:50:44 <dozer> > pastebin
09:50:44 <lambdabot>  Not in scope: `pastebin'
09:50:54 <dozer> pants
09:51:08 <dozer> @pastebin
09:51:09 <lambdabot> Unknown command, try @list
09:51:12 <ski> lisppaste2 : url
09:51:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:51:48 <lisppaste2> dozer pasted "trouble with id" at http://paste.lisp.org/display/18821
09:52:01 <dozer> ok - so there's loads of junk in there
09:52:29 <dozer> but the productions Directive.Ontology_annotation and Individual.Individual both use id - this gets complained at
09:52:37 <dozer> is there a way to re-write this which is both legal and easy to read?
09:53:22 <ski> 'ann_prop_id' is ok
09:54:14 <dozer> well, yeah - but that will go wrong when later on I introduce something that uses that ID
09:54:16 <ski> 'Mabey' should be 'Maybe'
09:54:26 <dozer> not to mention the million places that will want to be called "value"
09:54:29 <dozer> thx
09:55:23 <ski> either rename the different 'id's to e.g. 'ontPropID' 'individID' .. or put them in different modules
09:55:47 <dozer> the declarations are all mutually recursive, so modules won't work :(
09:55:57 <ski> oh, didn't notice ..
09:56:11 * dozer has found 1st thing that sml did nicely in comparrison
09:56:34 <ski> 'value' -> 'uriRef' 'dataLit' 'indiv'
09:56:37 <ski> or something
09:57:42 <ski> dozer : sml has real records .. also they are somewhat more similar to light-weight ones, since one can reuse the field names in same scope ..
09:58:02 <ski> .. otoh, by using '#fieldname' it doesn't always know which record is meant
09:58:18 <dozer> ski: yeah - I am porting this over from working sml, hence the issue
09:58:48 <JohnnyL> woah, thats pretty wierd, i fixed a module, reloaded, it came 1) back with the errors of the unfixed change AND 2) worked fine (with the new change) and printed the fibonacci series. is this a result of lazy evaluation?
09:59:22 <dozer> JohnnyL: sounds more like lazy compilation
09:59:45 <JohnnyL> dozer, is that a joke, or?
10:00:28 <ski> @vixen are you lazy?
10:00:28 <lambdabot> yes, i am
10:01:13 <dozer> JohnnyL: a bad one - sure you where looking in the right terminal(s)?
10:02:23 <svens> mhm, anyone compiled a ghc for HP-UX?
10:02:56 <JohnnyL> http://pastebin.com/651709
10:04:21 <Igloo> flip (<) 2600 == (< 2600)
10:04:26 <Igloo> That paste looks inconsistent
10:04:45 <JohnnyL> fibs = 1 : 1: takeWhile (<2600) ( zipWith (+) fibs $tail fibs) ------ the one that works ------- fibs = 1 : 1: takeWhile (<2600) $ zipWith (+) fibs $tail fibs) --- the one that doesn't work.
10:04:57 <JohnnyL> i know, but I just grabbed in from winhugs as is.
10:05:00 <JohnnyL> s/in/it
10:05:25 <Igloo> Yes, the second one parses like this:
10:05:57 <Igloo> (1 : 1 : takeWhile (< 2600)) $ (zipWith (+) fibs $ tail fibs)
10:05:58 <JohnnyL> Igloo, the point is though, that i reloaded over the second one and that error string came up.
10:06:37 <JohnnyL> alignment of the moon perhaps. :)
10:06:53 <JohnnyL> there is a glitch in the matrix.
10:07:09 <araujo> hello!
10:08:19 <dozer> is there a datatype that is natural numbers (0, 1, ...)? I assume Int is n-bits signed?
10:08:30 <xerox> data Nat = Zero | Succ Nat
10:08:34 <xerox> ...if you will.
10:09:13 <Igloo> There are Word, Word{8,16,32,64}, but nothing with infinite range
10:09:24 <Igloo> Int is guaranteed to be at least 29-bit signed
10:09:35 <davidhouse> then make that an instance of Num and write a fromIntegral function, and you're done
10:10:02 <davidhouse> *fromInteger
10:10:33 <dozer> ok - I get the idea
10:11:24 <davidhouse> instance Num Nat where Zero + n = n; n + Zero = n; (Succ n) + (Succ m) = Succ $ Succ $ n + m; ...
10:16:31 <JohnnyL> what's the reason or calling zipwith, zipwith?
10:16:41 <JohnnyL> it's just another map function, afacs.
10:16:52 <xerox> ?type zip
10:16:53 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
10:17:09 <JohnnyL> oh, it reverses too?
10:17:10 <xerox> zipWith generalizes the zipping function of zip.
10:17:23 <xerox> ?type unzip -- this reverses a zip, if that's what you mean.
10:17:24 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
10:19:02 * JohnnyL has yet to return a tuple.
10:19:14 <xerox> Sorry?
10:19:30 <JohnnyL> i am so new, not sure of how to return a tuple.
10:19:46 <resiak> > let f x = (x,x) in f 3
10:19:47 <lambdabot> (3,3)
10:20:04 <JohnnyL> thx.
10:20:06 <JohnnyL> like magic.
10:20:07 <resiak> :-)
10:20:23 <mauke> @pl \x -> (x, x)
10:20:25 <lambdabot> join (,)
10:21:16 <JohnnyL> thats funny. winhugs allow for let in the interpreter, but linux/hugs does not.
10:21:48 <xerox> > (id &&& id) 1
10:21:49 <lambdabot> (1,1)
10:21:50 <bolrod> so.. someone know yet how to recompile a base library?
10:30:54 <JohnnyL> http://pastebin.com/651758
10:31:49 <JohnnyL> let me see.
10:31:57 <JohnnyL> smart bot!
10:32:06 <JohnnyL> > let me see.
10:32:07 <lambdabot>  parse error (possibly incorrect indentation)
10:32:42 <davidhouse> JohnnyL: you can't do that in a file
10:32:44 <bolrod> :)
10:32:57 <bolrod> yes you can
10:33:04 <bolrod> only in a function definition
10:33:10 <davidhouse> try something like "func = let f x = (x,x) in f 3"
10:33:10 <bolrod> so
10:33:21 <davidhouse> then load the file, then type "func" and hit enter
10:33:39 <bolrod> does the GHC have # as operator?
10:33:50 <bolrod> findIndices p ls = loop 0# ls
10:33:55 <bolrod> List2.hs:253:59: Not in scope: `#'
10:33:57 <davidhouse> that's unboxed types
10:34:03 <davidhouse> :t 0#
10:34:04 <bolrod> yes
10:34:07 <davidhouse> err
10:34:10 <davidhouse> @type 0#
10:34:10 <lambdabot> GHC.Prim.Int#
10:35:31 <conal> @pl \ h f d (a',b)  -> h (\ a  -> f (a,b)) d a'
10:35:32 <lambdabot> flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . flip) .) . flip) .) . (. ((. flip (,)) . (.))) . (.)
10:35:41 <bolrod> >:/
10:36:03 <resiak>  > :/
10:36:11 <resiak> > :/ -- even
10:36:12 <lambdabot>  parse error on input `:/'
10:36:23 <mauke_> @type \ h f d (a',b)  -> h (\ a  -> f (a,b)) d a'
10:36:24 <lambdabot> forall a
10:36:24 <lambdabot>                   b
10:36:24 <lambdabot>                   t
10:36:24 <lambdabot>                   t1
10:36:24 <lambdabot>                   t2
10:36:26 <lambdabot> [6 @more lines]
10:36:29 <mauke_> oh shi
10:36:57 <davidhouse> @more
10:36:58 <lambdabot>                   a1.
10:36:58 <lambdabot>                 ((a1 -> t2) -> t -> a -> t1)
10:36:58 <lambdabot>                 -> ((a1, b) -> t2)
10:36:58 <lambdabot>                 -> t
10:36:58 <lambdabot>                 -> (a, b)
10:37:00 <lambdabot>                 -> t1
10:37:09 <davidhouse> mauke_: what in the hell is that?
10:37:22 <mauke_> I have no idea
10:38:01 <bolrod> well how do I compile a Lib that is already in the base libs >:/
10:39:11 <conal> mauke: it's a function from my icfp submission: http://conal.net/papers/icfp06-submission
10:40:32 <conal> This type: ((a->c) -> (d -> (a'->c))) ->  (((a,b)->c) -> (d -> ((a',b)->c)))
10:41:24 <mauke> @djinn ((a->c) -> (d -> (a'->c))) ->  (((a,b)->c) -> (d -> ((a',b)->c)))
10:41:25 <lambdabot> f a b c (d, e) = a (\ f -> b (f, e)) c d
10:41:27 <xerox> conal, WOW.
10:42:01 <conal> xerox: you like the type??
10:42:11 <xerox> noj, the paper.
10:42:25 <xerox> Sorry noj.  I meant 'No'.
10:42:28 <conal> oh. thanks.  :)
10:42:41 <xerox> How did you make the native windows GUI?
10:42:52 <mauke> xerox: looks like you should disable automatic nick expansion
10:42:58 <conal> i'm pretty excited about this work.  i'd love comments from folks.  please check it out.
10:43:10 <conal> xerox: i used wxHaskell
10:43:16 <xerox> Ah-ha.
10:50:35 <ski> conal : "deep" function application ?
10:51:41 <conal> ski: yeah.  applying a function deeply within a value
10:52:25 <conal> and then also yanking out a function from deep within a value and applying it (possibly deeply)
10:52:39 <ski> any simple example ? (or should i just RTFP ? :)
10:54:23 <conal> ski: easiest would be looking at section 4.1 of the paper.  See xp1 on page 4
10:55:18 <conal> it's something i hadn't noticed before and haven't heard of: one can compose (.), first, and second to make very useful things
10:55:48 <conal> fmap is another that works the same way, which i didn't mention in the paper
10:56:15 <xX[ReP]Xx> this is my haskell httpd. there are many like it, but this one is mine. my haskell httpd is my best friend. it is my life. i must master it as i master my life. without me my haskell httpd is useless. without my haskell httpd i am useless.
10:58:43 <davidhouse> @type (.) . (.)
10:58:44 <lambdabot> forall a b c a1.
10:58:44 <lambdabot>      (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:59:29 <ski> conal : interesting ..
10:59:44 <ski> (xerox : you might like to see that ..)
11:01:05 <davidhouse> conal, in section 4.1, the definition of xp_1, why do you need the calls to result in the chain?
11:01:40 <conal> (oops.  back)
11:01:50 <davidhouse> did you get my question?
11:01:59 <xerox> ski, I know that pattern, yes :-)
11:02:40 <conal> davidhouse: nope, but i got it off the channel log
11:02:51 <davidhouse> oh good :)
11:03:14 * palomer wishes bussproofs.sty had \QuadInfC
11:03:35 <conal> davidhouse: result (aka (.)) goes into the range type of a function, i.e., the "result"
11:04:16 <davidhouse> yes.
11:04:17 <conal> the targeted "c" is in the first part, then the result, then the second, then result, then first.
11:05:12 <conal> oh dear.  i hadn't noticed that xp1 is a palindrome.  lousy choice, since it doesn't make clear which way to the composition order is interpreted.
11:05:17 <conal> w.r.t the type
11:06:50 <ski> conal : left-to-right reading of body corresponds to out-to-in reading of the result type, yes ?
11:07:03 <conal> exactly.  thanks.
11:07:07 <ski> s/type/types/
11:08:29 <conal> i stumbled across this trick last year and mentioned it on haskell-cafe: http://www.haskell.org/pipermail/haskell-cafe/2005-April/009679.html
11:10:17 <RyanT5000> i'm pretty proficient with OOP in C++; could anyone suggest a good tutorial on learning Haskell software engineering techniques?
11:11:01 <palomer> hint: they don't exist
11:11:08 <conal> it's so very simple, i'm surprised i hadn't heard of the idea before.  has anyone else noticed or been told about using composition chains of first, second, (.), fmap to "edit" values?
11:11:42 <RyanT5000> palomer: was that in response to my question, and, if so, how do you mean?
11:11:58 <palomer> I'm being sardonic
11:12:00 <palomer> don't mind me
11:12:03 <RyanT5000> ok :P
11:12:06 <palomer> in fact, disregard everything I say
11:12:28 <RyanT5000> nice statement ;)
11:12:36 <palomer> you see, haskell isn't for real programming, it's for getting together with your buddies on a friday night and discuss monads
11:12:37 <Saulzar> I would say the techniques are the same between languages.
11:12:55 <RyanT5000> yeah but C++ classes, e.g., don't map onto haskell classes all that well
11:13:17 <RyanT5000> from what i can tell, a haskell class is sort of like an interface in C++-style languages
11:13:19 <Saulzar> Well, no.. but the same mechanisms exist, abstraction, encapsulation etc.
11:13:41 <RyanT5000> right; i just want to read something that is sort of an overview of the mapping between C++'s structures and Haskells
11:13:43 <RyanT5000> nothing heavy
11:14:00 <RyanT5000> i already have a good grasp on software engineering, just not on haskell ;)
11:14:18 <RyanT5000> (i got ghc about a week ago)
11:14:28 <araujo> RyanT5000, you won't find too many "software engineering" stuff on Haskell 
11:14:32 <Saulzar> Don't think there is any comprehensive writeup on that kind of thing. Though there are some pages demonstrating "OO" in Haskell
11:14:46 <RyanT5000> hm, well i don't really want to do OO :P
11:14:52 <RyanT5000> that's why i'm trying to leave C++
11:14:58 <sieni> there's a nice paper by Oleg and friends about OO in haskell
11:14:58 <xerox> RyanT5000, Haskell classes are sets of types.
11:15:03 <RyanT5000> right
11:15:16 <RyanT5000> maybe i should just go read some haskell code
11:15:41 <sieni> Also type classes do similar things in haskell as templates in c++ (in addition to abstract classes)
11:15:50 <RyanT5000> right, i was sort of seeing that
11:15:53 <Saulzar> But I suppose the main difference is that with C++ there is one type of abstraction (well 2 with templates), but haskell there are quite a few - but the main one is a function
11:16:00 <RyanT5000> right
11:16:02 <RyanT5000> i like that
11:16:08 <RyanT5000> i've decided i don't like C++-style classes
11:16:09 <sieni> RyanT5000: http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf
11:16:10 <ski> conal : can you arrow-ize your application paths, too ?
11:16:59 <conal> ski: "application paths"?
11:17:27 <RyanT5000> thanks sieni
11:17:40 <ski> conal : er, i.e. 'applyF' and 'applyX'
11:18:03 <RyanT5000> is there a small OSS project i might be able to understand the general design of in, i dunno, a few hours?
11:18:22 <RyanT5000> (not any kind of deep understanding; just "oh, they're using this sort of like a class")
11:18:33 <basti_> RyanT5000: you're new to haskell?
11:18:36 <RyanT5000> s/class/C++ class/
11:18:38 <ski> conal : hm .. i don't see typed for those .... am i supposed to infer them in head ?
11:18:39 <RyanT5000> yeah i learned a week ago
11:18:48 <ski> (s/typed/type signatures/)
11:18:57 <conal> ski: thanks.  i didn't figure out how to do that.  instead i got the same benefit with "function extraction paths".  and then extended the usefulness with "input extraction paths"
11:19:21 <ayrnieu> ryan - write an IRC client in Haskell... and then try to get not any deep understanding, but just an understanding of its general design.
11:19:23 <basti_> RyanT5000: great... if you have questions don't hesitate to ask
11:19:42 <RyanT5000> thanks basti :P
11:20:19 <RyanT5000> ayrnieu well i'm planning on writing an OpenGL scene compositor, because it doesn't seem that challenging and i've done it in C++ before, in a very functional style
11:20:39 <basti_> the first thing you'll trip over is monads.
11:20:45 <RyanT5000> nah i love monads :P
11:20:50 <ski> conal : well, i guess i was hoping to see type sigs. and/or generalization to arrows to be able to understand exactly what those did :)  (now i guess i'll have to read it more carefully, instead of skimming :)
11:20:50 <RyanT5000> they're how i found haskell
11:21:00 <basti_> that's good.
11:21:10 <basti_> then you're aware that monads are a CT version of monoids?
11:21:27 <RyanT5000> i've only read a bit about monoids
11:21:29 <RyanT5000> so no
11:21:41 <basti_> a monoid is a set and an accociative operation
11:21:57 <ski> basti_ : bad, don't scare thw newbie :P
11:22:02 <RyanT5000> nah i'm ok with this
11:22:06 <basti_> ^^
11:22:07 <basti_> ;)
11:22:18 <RyanT5000> i much prefer theory to "here is how you do it"
11:23:02 <basti_> i think, monoids are a good way to memorize monads because of that
11:23:15 <RyanT5000> why are monoids M x M -> M
11:23:19 <RyanT5000> why not just M -> M?
11:23:33 <basti_> hmm because M->M wouldn't have a parameter
11:23:40 <basti_> and thus be quite boring
11:23:47 <RyanT5000> hm
11:24:27 <ski> monoids have a "zero" and a "plus"
11:24:36 <RyanT5000> right
11:24:41 <ski> (or a "one" and a "times" if you like)
11:24:50 <RyanT5000> associativity and a closed operation on a set
11:25:24 <RyanT5000> so what's in the set of IO ()
11:25:31 <RyanT5000> every state of the computer and the network?
11:25:35 <ski> no
11:25:53 <basti_> not really no.
11:25:56 <basti_> but, similar.
11:26:07 <ski> IO a  ~=  World -> (World,a)   -- more or less
11:26:18 <RyanT5000> ok
11:26:37 <basti_> think of "IO a" as of "scripts with a return value of type a"
11:26:40 <RyanT5000> right, because you take a World and return a new world with possibly a return type
11:26:56 <ski> e.g. values of type 'IO Char' (called "monadic actions (returning a char)") is more or less a function from the state of the world, to the new state of the world, plus the returned char
11:27:02 <RyanT5000> ok so World is the state of the computer
11:27:03 <ski> RyanT5000 : exactly
11:27:13 <RyanT5000> IO a is an action on the state of the computer with an additional return "a"
11:27:14 <ski> World is the state of the universe :)
11:27:17 <RyanT5000> right
11:27:20 <basti_> yep
11:27:28 <basti_> the cool thing about monads is that haskell can compose them
11:27:32 <ski> (at least so much as is accessible from the computer)
11:27:32 <RyanT5000> right
11:27:38 <RyanT5000> (right)
11:28:01 <RyanT5000> and then an Arrow is essentially just a Monad except that you compose its actions in a graph rather than a list
11:28:18 <ski> hrm
11:28:18 <RyanT5000> does "Monad" refer to the action (IO a) or the thing which the action operates on?
11:28:22 <basti_> arrows are trippy.
11:28:34 <basti_> monad is the general term for "scripts" like (IO a)
11:29:20 <ski> "Monad" refers to the type constructor 'IO' together with the monad operations that goes with that ('return','(>>=)')
11:29:31 <RyanT5000> ok
11:29:44 <basti_> ("Monad" is a "class" in haskell, these are different to C++ classes though)
11:29:49 <ski> a value of type 'IO a' is called a monadic action .. in this case an IO-action
11:29:53 <RyanT5000> so the Monad is the state machine, and IO is the actions within that state machine
11:30:06 <basti_> hmm
11:30:10 <wchogg> Huh...I hadn't thought of it this way before.  So IO () is the set of all mappings between states of the World?
11:30:20 <basti_> wchogg: no, IO a would be.
11:30:32 <basti_> IO () would be the type of all mappings between states which give no result
11:30:49 <ski> basti_ : isn't that what wchogg said ?
11:31:01 <basti_> hmm.
11:31:11 <wchogg> basti_:  That's what I mean.  Purely between states of the World.  IO a would be mappings between World x (set of all a) right?
11:31:11 <RyanT5000> yeah i don't think the ancillary result is relevant
11:31:28 <basti_> ski: yes you're right, i misunderstood that
11:31:37 <RyanT5000> well technically it's a mapping between states of World and (states of world, ())
11:31:38 <ski> RyanT5000 : with somewhat sloppy speaking, one says 'IO' is a monad (really it includes the operations, too ..)
11:31:56 <RyanT5000> yah
11:32:03 <ski> RyanT5000 : right, and that is isomorphic to 'World -> World'
11:32:05 <RyanT5000> right
11:32:18 <basti_> luckily haskell cares about what exact operations to use (they're named ">>=" and "return" in every monad)
11:32:29 <RyanT5000> yeah
11:32:35 <wchogg> See *now* this makes sense to me.  I should try to think of this in terms of basic math more often.
11:32:36 <RyanT5000> also i'm glad there's no overloading in haskell
11:32:43 <basti_> .)
11:32:48 <RyanT5000> as in
11:32:52 <RyanT5000> the kind that C++ has
11:33:03 <RyanT5000> where someone can add a function in one package
11:33:10 <RyanT5000> which happens to have the same name as a function in another package
11:33:10 <ski> RyanT5000 : there are overloading .. but more disciplined one .. based on the type class system
11:33:14 <RyanT5000> right
11:33:15 <Saulzar> Type classes can give you something similar, of course that requires you to be more explicit about it
11:33:41 <RyanT5000> overloading + using namespace directives + implicit casts = evil
11:33:42 <wchogg> Yeah, I think he means that you can't have foo(int x, int y) be a completely different function than foo(int z).
11:33:55 <RyanT5000> yeah
11:34:04 <RyanT5000> but it's even worse when you have foo(float)
11:34:11 <RyanT5000> and someone comes along and writes foo(double) without telling you
11:34:26 <wchogg> Ouch.  I've never actually had that happen.
11:34:45 <RyanT5000> tbh i've never had a *big* problem with that
11:34:46 <wchogg> I believe the technical term for that is "teh suck".
11:34:51 <ski> RyanT5000 : i think the main problem there is techincally called "loss of coherence"
11:34:53 <RyanT5000> it just pisses me off that it's possible
11:34:54 <Saulzar> Hmm, implicit casts and templates with overloading are a joy... :)
11:35:00 <RyanT5000> :)
11:35:13 <ski> RyanT5000 : i.e. result depends on where you happen to insert explicit coercions
11:35:51 <RyanT5000> yep
11:36:17 <ski> e.g. if you have 'float foo(float);' and 'double foo(double);'
11:36:48 <RyanT5000> right
11:37:55 <ski> then 'float x; ... double y = foo(x);' if we rename to 'foo_float' and 'foo_double', then that call to 'foo' could either expand to 'y = (double)foo_float(x)' or to 'y = foo_double((double)y)'
11:38:15 <ski> and nothing guarrantees that these two possible expansions gives same result
11:38:30 <ski> (does C++ even warn about the ambiguity ?)
11:38:31 <RyanT5000> yeah
11:38:34 <RyanT5000> er
11:38:46 <RyanT5000> (that wasn't a response to the warning question)
11:38:49 <RyanT5000> i don't know if it warns
11:39:18 <RyanT5000> i know the C++ standard pretty well and i don't know which it would pick
11:39:25 <RyanT5000> or if it is even standardized
11:39:58 <wchogg> Hrmm...so is the motivation for applying real mathematics to CS for the sake of the compiler or is it allow us to have higher abstraction?
11:40:00 <RyanT5000> oh wait
11:40:08 <RyanT5000> yeah it'd definitely choose foo_double
11:40:14 <RyanT5000> it doesn't overload based on return value
11:40:18 <ski> wchogg : why not both ?
11:40:28 <ski> oh, right
11:40:39 <RyanT5000> i thought it was so we could write things that weren't buggy as hell
11:40:40 * ski 'd forgotten that
11:40:40 <RyanT5000> :-/
11:40:58 <ski> Ada and Haskell can overload on result type
11:41:15 <RyanT5000> yeah, which is awesome
11:41:22 <ski> (if i don't recall worng, then Ada refuses to compile if there's ambiguity)
11:41:33 <ski> > 1 + (2 :: Int)
11:41:36 <RyanT5000> and when it's strongly typed and doesn't have ad-hoc overloading, you don't get screwed over
11:42:02 <ski> bah, lambdabot died ..
11:42:16 <ski> yah
11:42:28 <RyanT5000> you can't name two class functions the same thing right?
11:42:31 <RyanT5000> like
11:42:37 <ski> not in same class
11:42:47 <RyanT5000> class Foo a where bar :: a->a
11:42:48 <ski> in different modules, it works
11:43:02 <RyanT5000> class Foo2 a where bar :: a->a
11:43:12 <RyanT5000> i presume you can't do that
11:43:16 <RyanT5000> regardless of the signatures of bar
11:43:28 <ski> you can, if you put them in different modules
11:43:35 <RyanT5000> ok
11:43:48 <ski> of course you need to import them qualified (at least one of them) to disambiguate
11:43:58 <RyanT5000> why don't they just make it so that class creates a module scope which is implicitly imported?
11:44:12 <RyanT5000> that's how C++ is to some degree, and i think it works well
11:44:17 <ski> orthogonality, i think
11:44:38 <ski> module system handles non-lexical scopings
11:44:40 <RyanT5000> so if you have two identically-named class functions you'd always have to disambiguate (even if the arguments also disambiguated)
11:44:52 <RyanT5000> hm
11:45:09 <ski> i think so (but not fully sure)
11:45:34 <ski> i think it wants to know what identifiers refer to before type-checking
11:45:52 <RyanT5000> right, it could do that
11:46:02 <RyanT5000> i'm not saying that you do any overloading or anything
11:46:13 <RyanT5000> i'm saying you essentially transform each class into a submodule
11:46:18 <RyanT5000> it'd only change naming
11:46:43 <RyanT5000> prefixing all class functions with the classname (Foo::bar, Foo2::bar) would be eqivalent
11:47:00 <ski> haskell's module system isn't actually very advanced
11:47:04 <RyanT5000> yeah, i noticed
11:47:09 <RyanT5000> that's one thing C++ seems to have on it
11:47:15 <sethk> RyanT5000, that wouldn't fit in well with the way instance declarations are used
11:47:15 <RyanT5000> but that's ok :)
11:47:22 <eivuokko> It might also be that instead of solving just this problem, people are waiting for cool module and record system that solves naming problems.
11:47:31 <sethk> RyanT5000, there are better module systems than haskell, but c++ certainly isn't one of them
11:47:36 <RyanT5000> good point eivuokoo
11:47:44 <RyanT5000> *eivoukko
11:47:48 <ski> the MLs' module system are more powerful (you may want to check them out, to get an idea of what power they give, if you haven't already)
11:48:00 <RyanT5000> hm i will
11:48:10 <RyanT5000> (for the record, i wasn't saying C++'s was good)
11:48:20 <RyanT5000> (just that it seemed - marginally - better than haskell's)
11:49:05 <jyp> I thought C++ had no module system
11:49:11 <RyanT5000> namespace
11:49:19 <RyanT5000> also, classes create new scopes
11:49:20 <eivuokko> I think you confuse module system and C++'s name scoping, which are a bit diffrent thing.
11:49:32 <sethk> jyp, it doesn't have a module system in this sense, no
11:49:32 <RyanT5000> true, i was being rather ambiguous
11:49:37 <eivuokko> C++ name scoping has features that make it more convient than haskell's
11:49:39 <RyanT5000> i was talking about naming class functions
11:49:51 <ayrnieu> eivuokko - how are they different things?
11:49:59 <RyanT5000> so in C++ you'd have Foo::bar, in haskell you'd just have bar
11:50:50 * araujo thinks it's an atrocity to compare C++ with Haskell
11:51:03 <RyanT5000> :)
11:51:13 * palomer disagrees
11:51:21 <ayrnieu> araujo - don't be so emotional.
11:51:25 <palomer> you guys are just jealous that you can write real programs in C++
11:51:28 <ayrnieu> about this.
11:51:41 <RyanT5000> what's the point of not having classes introduce a new scope?
11:51:58 <RyanT5000> i don't really see any advantage
11:51:59 <ayrnieu> ryan - Haskell doesn't have 'classes'.
11:52:07 <RyanT5000> er...
11:52:10 <palomer> RyanT5000: I've thought about it, and it would be hard to do
11:52:18 <RyanT5000> i'm referring to the thing you introduce with the class keyword
11:52:20 <jyp> Actually, the class/module system prevents you atrocities like having the same operator to shift bits and output to streams
11:52:33 <araujo> RyanT5000, those are type classes
11:52:38 <RyanT5000> i know they're type classes
11:52:49 <ayrnieu> ryan - which is to say, 'not classes'.
11:52:52 <RyanT5000> they seem simmilar in function to java's Interfaces, or C++'s abstract base classes
11:52:55 <ayrnieu> ryan - you started this conversation by wanting to be able to say "oh, X is used sort of like a C++ class".  Stop wanting that.
11:52:55 <eivuokko> ayrnieu, Module system in haskell is very loosely way to construct hierarchy in a program and strongly to distribute libraries.  C++ name scoping is just...well what it says.
11:53:16 <palomer> I agree with RyanT5000, classes should introduce a new scope
11:53:25 <wchogg> palomer:  Why?
11:53:28 <palomer> why not?
11:53:37 <RyanT5000> no ayrnieu, you didn't quite get my point
11:53:40 <ayrnieu> If Haskell had classes, then that might be sensible.
11:53:41 <eivuokko> palomer, unfortunately there isn't "scope" in haskell, so.. ;)
11:53:41 <palomer> the why is simple: clean up the namespace
11:53:41 <RyanT5000> i wasn't saying i want things like classes
11:53:52 <palomer> eivuokko: sure there is, there's module scope
11:53:53 <eivuokko> palomer, you'd need to invent up some terminology etc
11:53:54 <RyanT5000> i just wanted to adapt myself quickly to haskell's terminology
11:54:19 <palomer> anyways, I'm off
11:54:23 <RyanT5000> and learning isomorphisms, or near-isomorphisms, to c++ would help me learn that quickly
11:54:24 <jyp> A flat namespace encourages a coherent naming scheme throughout.
11:54:25 <palomer> though listen to RyanT5000, he raises some good points
11:54:36 <RyanT5000> thanks palomer
11:54:37 <ayrnieu> jyp - well, no.
11:54:39 <palomer> jyp: it can also confuse the programmer
11:54:46 <jyp> well, yes! :)
11:54:53 <RyanT5000> yeah how about homonyms?
11:54:57 <RyanT5000> Lottery::draw
11:55:00 <ayrnieu> jyp - a coherent naming scheme encourages a coherent naming scheme.  There is not cause-effect here in langugae design, as PHP shows.
11:55:01 <RyanT5000> Screen::draw
11:55:11 <ayrnieu> "There is no".
11:55:12 <RyanT5000> if english didn't have homonyms this might work out better
11:55:40 <jyp> As I pointed before, it prevents you atrocities like having the same operator to shift bits and output to streams
11:55:43 <eivuokko> jyp, But is that an argument in haskell?  Is Haskell really made so that it enforces good practices and makes hard or impossible the bad practices?  I don't think that's really the spirit in the language.
11:55:49 <RyanT5000> i don't see how that's such an atrocity jyp
11:56:00 <jyp> Then I'm off :)
11:56:03 <RyanT5000> as long as it's clearly unambiguous
11:56:23 <RyanT5000> i don't agree on argument-type-based overloading
11:56:28 <jyp> Imagine combining that with type inference, and you'll clearly see the problem
11:56:32 <RyanT5000> right
11:56:36 <RyanT5000> i'm not saying that
11:56:38 <RyanT5000> i'm saying
11:56:43 <RyanT5000> let me define two classes with <<
11:56:44 <RyanT5000> but if i do so
11:56:47 <ayrnieu> For those fortunate souls unaware of PHP: it has A) thousands of functions in 'core', without namespaces, and B) shockingly incoherently named functions.
11:56:48 <sethk> RyanT5000, argument type overloading is completely antithetical to haskell
11:56:49 <RyanT5000> force me to qualify with the class names
11:56:57 <RyanT5000> yes sethk
11:56:59 <RyanT5000> that's what i just said :)
11:57:07 <RyanT5000> i am very anti-argument-type-overloading
11:57:11 <sethk> RyanT5000, ok
11:57:12 <RyanT5000> i'm not arguing for that
11:57:12 <sethk> :)
11:57:14 <RyanT5000> i'm just saying
11:57:17 <mauke> "thousands" is true; it's about 3000
11:57:17 <RyanT5000> let me define two <<
11:57:33 <RyanT5000> put them in two namespaces
11:57:36 <RyanT5000> force me to qualify
11:57:39 <RyanT5000> is someone only imports one of them
11:57:44 <RyanT5000> they don't have to qualify
11:57:50 <ayrnieu> mauke - B) is also true.
11:57:51 <sethk> that's exactly what haskell does
11:57:52 <jyp> You can just put them in two different modules then.
11:57:53 <wchogg> It sounds like what Ryan is saying isn't much different than what you have to do if you want to use fundeps, right?  Where you have to explicitly give the type because you've made it too complicated for inference.
11:57:55 <RyanT5000> yeah i know
11:57:59 <RyanT5000> i can put them in different modules
11:58:03 <JohnnyL> RyanT5000, when is the next Haskell meeting in New York? :)
11:58:06 <mauke> and it lacks any form of namespaces or proper scoping, so what you have is effectively a language with 3000 reserved words (case insensitive!)
11:58:06 <RyanT5000> that's why what i'm saying isn't such a big deal
11:58:11 <RyanT5000> i dunno JohnnyL
11:58:15 <RyanT5000> i'm new to haskell
11:58:25 <RyanT5000> i've been here for about 1 week
11:58:41 <RyanT5000> er, s/here/hacking haskell/
11:58:42 <jyp> I think we agree then :)
11:58:44 <sethk> JohnnyL, there are meetings in NY?
11:58:57 <JohnnyL> sethk, not yet. :)
11:59:16 <JohnnyL> RyanT5000 i'm sorta new too.
11:59:37 <RyanT5000> i've been telling every programmer i know to go try haskell, lol
11:59:43 <RyanT5000> you guys should work on your marketing
11:59:50 <RyanT5000> you could've saved me years of frustration :P
12:00:09 <jyp> ayrnieu: It at least prevents you having the same name allocated to wildly different things and overloading being resolved behind the scenes.
12:00:25 <wchogg> RyanT5000:  Are you planning to use Haskell for actual work or just as a hobby?
12:00:28 <RyanT5000> work
12:00:36 <RyanT5000> i'm currently trying to write a game client in it
12:00:42 <RyanT5000> i have the game engine nearly done in C#
12:00:47 <wchogg> Cool.
12:00:52 <RyanT5000> but i'm basically tearing my eyes out every minute of the programming
12:00:57 <RyanT5000> --> haskell
12:01:08 <bolrod> ?.
12:01:11 <Cufisz> any ideas on how to change tab size to 4 instead of 8 in GHC?
12:01:24 <bolrod> why use tab?
12:01:33 <bolrod> use spaces!
12:01:36 <Cufisz> easier to indent?
12:01:36 <jyp> sed is your friend :)
12:01:38 <ski> Cufisz : don't use tabs in source
12:01:45 <RyanT5000> i like tabs :)
12:01:46 <Cufisz> ahh! why not?
12:01:55 <davidhouse> Cufisz: the haskell report defines a tab to be 8 spaces, iirc.
12:02:01 <sethk> JohnnyL, if you set something up, let me know.  I'm in Manhattan, although I've been traveling a lot lately
12:02:04 <bolrod> tab distance is different in every editor
12:02:07 <Quinthius> what do you guys do instead of tabs? just small numbers of spaces? like 2? putting in 4-8 spaces for each indent would get kind of annoying
12:02:13 <ski> Cufisz : posibly you can configure your editor to emit spaces when you hit tab ..
12:02:20 <Cufisz> well good editors let you set them up, no?
12:02:21 <bolrod> indeed
12:02:26 <bolrod> gedit has it in the preferences
12:02:30 <bolrod> vim is :set expandtab
12:02:30 <ayrnieu> quinthius - we use good editors.
12:02:33 <davidhouse> tabs a great, for languages with a consistent identation profile like C or python.
12:02:37 <Cufisz> ski: yes that's an option with vim, however it's still nicer to delete one tab instead of 4 spaces.
12:02:44 <davidhouse> for something more like haskell, spaces are Just Easier.
12:02:45 <ayrnieu> quinth - Emacs has an excellent mode for Haskell.
12:02:49 <RyanT5000> hm
12:02:49 <sieni> Cufisz: that would be like asking how to shoot yourself in the foot so that you lose the other foot as well with a single shot (see davidhouse's comment about Haskell report)
12:02:59 <RyanT5000> i know spaces are mandatory in LISP
12:03:00 <ayrnieu> cufisz - vim can delete four spaces as easily as it can one tab.
12:03:05 <Quinthius> what about backing out of the indent? do you just backspace over all the spaces? or is there some way to "jump" over them as if they were tabs?
12:03:10 <ayrnieu> ryan - no, they aren't.
12:03:13 <bolrod> and 8 spaces of indent is alot!
12:03:22 <RyanT5000> i don't mean technically mandatory
12:03:42 <Cufisz> sieni: care to elaborate?
12:03:46 <RyanT5000> i mean, it'd burn your eyes even more if you only aligned it to the nearest space
12:03:50 <ski> Cufisz : the reason is, space (indentation) is significant, so mixing tabs and spaces for indentation can screw up if your editor and your haskell implementation disagrees about size of tabs
12:03:56 <ayrnieu> quinth - Emacs has an excellent mode for Haskell.  "backing out of indent" is an operation that never happens.  "re-indentation" may happen.
12:04:11 <davidhouse> Quinthius: haskell-mode for emacs is great. it guesses at where you might want to indent a given line to (based on the lines before it). as this is very difficult and there's quite a few options per line, pressing tab again cycles through the options.
12:04:31 <ski> (Cufisz : you can, though use '{' , '; ' ,'}' instead of indenting ..)
12:04:39 <Quinthius> hehe, i'll check it out. just been using gedit for now
12:05:02 <sethk> remember everyone that significant indentation is optional.  If you like you can use { } and ; and indent however you like
12:05:06 <sieni> Cufisz: Haskell report defines that a tab is 8 spaces, so if you want different tab width, you had better just use spaces
12:05:26 <davidhouse> to be honest, you can write haskell code with tabs and it will work fine.
12:05:30 <Cufisz> fair enough...
12:05:33 <davidhouse> i have done so, and it's very possible.
12:05:39 <bolrod> davidhouse: untill someone else likes to edit it
12:05:43 <bolrod> with a different tab space
12:05:45 <Cufisz> ski: thanks, i'll try spaces first (less clutered code)
12:05:46 <Quinthius> i've been using normal tabs, just have to position things a little differently than some of the example code i'm seeing
12:05:54 <davidhouse> bolrod: no, even then it still works.
12:05:59 <sethk> davidhouse, just tabs works fine.  just spaces works fine.  mixed tabs/spaces can be a problem
12:06:07 <davidhouse> sethk: yep, that's it.
12:06:26 <davidhouse> you want nice pretty indented code, you have to stick with spaces. or, if, like me, you want emacs, you have to stick with spaces.
12:06:33 <davidhouse> and spaces aren't all that bad, actually :)
12:06:36 <bolrod> ofcourse.. because if you use only tabs.. you can easilly switch every tab to 1 space
12:06:39 <bolrod> and it'll be the same
12:06:59 <sethk> bolrod, you can switch tabs to one space, or four spaces, or eight spaces, or whatever
12:07:15 <sethk> bolrod, that's why I prefer tabs, I like to be able to expand/contract
12:07:26 <davidhouse> bolrod: you do have to adopt a funky indentation style.
12:07:35 <bolrod> :)
12:07:48 <bolrod> bwah... I used gedit.. and it's ok
12:08:13 <bolrod> it replaces tabs with the amount of spaces you set in preferences
12:08:16 <davidhouse> e.g. http://pastebin.com/651949
12:08:26 <bolrod> and then te next line.. it automatically goes to the indentation you were on the line before
12:08:34 <davidhouse> you can't put the first statement on the same line as the 'do'.
12:08:34 <bolrod> could be better ofcourse
12:08:36 <bolrod> but its ok
12:08:43 <bolrod> you can
12:09:03 <bolrod> or with tabs?
12:09:15 <davidhouse> you can't with tabs
12:09:18 <bolrod> ah
12:09:27 <bolrod> because with spaces you can perfectly
12:09:37 <Quinthius> davidhouse: what if you add in a tab after the do? like do<tab>blahblah?
12:10:05 <davidhouse> Quinthius: that would work, but look as ugly as sin. i'd prefer just to start a new line
12:10:14 <bolrod> http://pastebin.com/651952  << thats also nice
12:10:21 <Quinthius> hehe yeah, i've been putting in new lines also
12:10:27 <Quinthius> but was just wondering about that
12:10:36 <davidhouse> bolrod, no, that's not nice ;)
12:10:43 <bolrod> shatup.. it is ;p
12:10:43 <davidhouse> the big place tabs fall down, i've found, is with lists.
12:10:57 <sethk> Quinthius, tabs (white space, more properly) to the right of anything is insignificant
12:11:39 <davidhouse> e.g. http://pastebin.com/651958
12:14:51 <SyntaxNinja> gar haddock doesn't do mutually recursive modules.
12:16:25 <bolrod> @vixen you like tabs?
12:16:33 <bolrod> ey! >:/
12:16:37 <bolrod> where is that thing
12:17:16 <davidhouse> :O lambdabot has left
12:17:19 <bolrod> 08:12:42 -!- lambdabot [n=lambdabo@shodan.cse.unsw.EDU.AU] has quit ["killed by SIGHUP"]
12:17:24 <bolrod> who did that O_o?
12:17:28 <bolrod> reboot or something?
12:17:53 <wchogg> He was arrested for transforming underage monads.
12:18:02 <bolrod> pff >;\
12:18:38 <davidhouse> it means that the computer he was on shut down, i guess.
12:18:47 <davidhouse> SIGHUPs are sent on halt, right?
12:19:32 * davidhouse pretends he knows what he's talking about
12:19:57 <jyp> I thought it was SIGTERM
12:20:07 <sethk> davidhouse, SIGHUP means the controlling terminal disconnected
12:20:07 <bolrod> yeah
12:20:09 <bolrod> possibly
12:20:17 <jyp> maybe when X goes down before
12:20:30 <bolrod> who has lambdabot running in a terminal >:/
12:20:37 <bolrod> you dont run that in a terminal right?
12:21:41 <bolrod> someone just rudely did a kill or something >:/
12:22:19 <sethk> bolrod, he just needs to start it with nohup
12:22:24 <RyanT5000> is House being actively developed?
12:22:55 <xerox> FSVO actively :-)
12:23:13 <RyanT5000> fsvo?
12:23:32 <bolrod> sethk: he just needs the lambdabot in the init.d >;/
12:23:39 <jyp> RyanT5000: for Some Value Of
12:23:53 <RyanT5000> ah
12:23:59 <jyp> apparently :) http://acronyms.thefreedictionary.com/FSVO
12:24:19 <davidhouse> RyanT5000: no i'm not
12:24:45 <RyanT5000> oh that's your project?
12:24:49 <RyanT5000> oh
12:24:51 <RyanT5000> heh
12:24:52 <RyanT5000> nvm
12:25:07 <RyanT5000> it's a Haskell OS
12:27:44 <JohnnyL> sethk, cool dude, i'm out on the island. suffolk.. i'm at johnnylutz@gmail.com.
12:28:24 <bolrod> you're going to the Island?!  OMG! cool :)
12:28:56 <JohnnyL> sethk, there is something in this room from upstate albany too.
12:29:13 <RyanT5000> that'd be me
12:29:16 <sethk> JohnnyL, that's a bit far for a meeting  :)
12:29:46 <RyanT5000> actually i'll be on long island probably some time in may
12:29:48 <bolrod> where is the Haskell HQ? 8)
12:29:53 <JohnnyL> nyc or near it is prolly the best.
12:30:08 <sethk> JohnnyL, there are three states closer to me than Albany  :)
12:30:11 <JohnnyL> RyanT5000, cool whatcha doing?
12:30:15 <sethk> RyanT5000, if you are around, that would be ok
12:30:33 <RyanT5000> visiting my girlfriend; she goes to school up here in troy, but she'll be at home over the summer
12:30:55 <RyanT5000> (home = long island, obviously)
12:31:17 <JohnnyL> I'm still a haskell newbie, so it won't be much fun for you guys. i'll be asking all of the right questions, at the wrong time! hahaha
12:31:27 <RyanT5000> yah me too
12:31:41 <RyanT5000> although i don't plan on being a newb for too long :P
12:31:44 <ayrnieu> if we stop having fun, we can just stop playing for a while.
12:32:24 <JohnnyL> what's interesting about haskell, it's been designed from the ground up, just like c.. lot's of small very effective functions.
12:32:32 <lightstep> how do i gain write access to haskell.org/hawiki?
12:33:35 <bolrod> by being very cool
12:33:43 <bolrod> (I don't know)
12:35:17 <lightstep> @seen SamB
12:35:47 <sethk> lightstep, you just create a user
12:35:49 <bolrod> @seen lambdabot
12:35:50 <ayrnieu> lightstep - look at that page, "http://www.haskell.org/hawiki", and then click on the "How it works" at the top, which directs you to the "How it works" section at the bottom of that page, which answers your question.
12:35:53 <bolrod> 8)
12:36:00 <lightstep> thanks
12:36:10 <ayrnieu> lightstep - which is to say, "you gain write access by being moderately observant"
12:37:22 <RyanT5000> in other words you just cheated
12:37:39 <lightstep> well, i never looked at the front page. i access the wiki through RecentChanges
12:37:46 <RyanT5000> yah i'm just kidding :P
12:38:11 <bolrod> :)
12:38:16 <bolrod> hmm... why do I smell food ;/
12:39:05 <ayrnieu> bolrod - first, determine if you actually smell food or if you imagine that you do.  If you imagine that you do, investigate your mind.  If you actually do, investigate your physical vicinity.
12:39:18 <bolrod> true
12:39:26 <bolrod> but I monitored the clock
12:39:32 <bolrod> and the fact that I already had my dinner
12:39:37 <integral> case smell_origin of { Real -> ...; Imaginary -> ... }
12:39:41 <bolrod> so I'm wondering... is this from my house
12:39:47 <bolrod> or some bastard next door
12:39:55 <ayrnieu> We cannot answer this for you.
12:40:06 <bolrod> I cannot answer this for me
12:40:15 <bolrod> I'd have to check!
12:40:26 <ayrnieu> That would be a manner of answering.
12:40:31 <bolrod> ok..
12:40:55 <RyanT5000> does hoogle support the hierarchical libs?
12:40:57 <bolrod> smells like an awfull lot of bacon
12:40:58 <bolrod> ;/
12:41:29 <bolrod> > Just Bacon
12:41:32 <bolrod> probably
12:41:34 <bolrod> ohyeha
12:41:45 <bolrod> dang! I need to get my mind clear or something
12:41:47 <davidhouse> RyanT5000: support to what extent?
12:41:53 <ayrnieu> you can use your own local area lore to determine if this identification of the smell suggests its source.
12:42:03 <RyanT5000> to the extent that i can search for stuff within Graphics.UI.GLUT ;)
12:42:09 <lightstep> RyanT5000, it contains an arbitrary subset of them
12:42:11 <RyanT5000> i tried searching for that itself
12:42:13 <RyanT5000> ok
12:42:17 <bolrod> ayrnieu: very well
12:42:18 <RyanT5000> thanks, good to know
12:42:32 <bolrod> I'll take on this quest to search the source of this particular odor
12:42:38 <bolrod> or something
12:42:38 <bolrod> BLAH
12:42:39 <RyanT5000> bolrod: roll 1d20 + Knowledge (local) + int
12:42:57 <ayrnieu> intelligence shouldn't be a factor, here.
12:43:07 <RyanT5000> it is in 3.5ed :P
12:43:22 <RyanT5000> INT includes knowledge in d&d
12:43:52 <ayrnieu> silly of 3.5ed, then, to simulate player characters stupider than any scent-detecting animal.
12:44:09 <RyanT5000> well really it wouldn't be a Knowledge (local) check
12:44:12 <RyanT5000> someone else implied that :P
12:44:14 <RyanT5000> it would be a Spot check
12:44:29 <RyanT5000> i think
12:44:35 <RyanT5000> there's no Smell check
12:44:37 <RyanT5000> afaik
12:44:38 <ayrnieu> a spot check to notice the smell, I think you mean.
12:44:42 <RyanT5000> right
12:44:50 <RyanT5000> and that's, er, dex i think?
12:44:54 <ayrnieu> tracing it doesn't take great cleverness.
12:45:05 <ayrnieu> dex?!
12:45:08 <RyanT5000> wis?
12:45:09 <RyanT5000> i dunno
12:45:18 <ayrnieu> You'll notice the smell if you aren't afflicted.
12:45:24 <RyanT5000> right :P
12:45:33 <RyanT5000> there's not a great game mechanic for scent
12:45:38 <ayrnieu> afflicted in a way that destroys your smell, or in a way that channels your attention away from the smell.
12:45:45 <RyanT5000> even though with all the cloud-area-of-effect spells you'd think there would be
12:54:28 <petekaz> What is the haskell one liner to take a list of elements ["a", "b", "c", "a", "b"] and produce a list like: [("a", 2), ("b", 2), ("c", 1)]  Basically counting the number of times an element appeared in a list.
12:54:41 <petekaz> (I'm a haskell newb)
12:54:46 <davidhouse> group
12:54:53 <davidhouse> > ["a", "b", "c", "a", "b"]
12:55:02 <davidhouse> oh, lambabot's not in town.
12:55:05 <davidhouse> something like:
12:55:58 <davidhouse> give me some time to experiment :)
12:56:01 <petekaz> ok :-)
12:56:43 <davidhouse> map (\a -> (head a, length a)) . group . sort -- should work
12:56:44 <mauke> map (\xs@(x : _) -> (x, length xs)) $ List.group $ List.sort x
12:56:55 <mauke> huhu
12:56:58 <davidhouse> snap! :)
12:57:02 <jyp> map (length &&& head) . group . sort
12:57:18 <ski> :)
12:57:18 <davidhouse> ...and i KNEW there was going to be an elegant Arrow solution :)
12:57:30 <jyp> untested ;p
12:57:34 <petekaz> I haven't seen &&& yet.e
12:57:42 <ski> in this case
12:57:49 <petekaz> But that looks the "nicest"
12:57:56 <ski> (&&&) :: (a -> b) -> (a -> c) -> (a -> (b,c))
12:58:30 <davidhouse> jyp, gives "Couldn't match `Integer' against `[Char]'"
12:58:36 <ski> jyp : though, petekaz wanted the other order, in the pairs
12:58:44 <jyp> oops
12:58:52 <jyp> close enough ;)
12:59:03 <jyp> > map (head &&& length) . group . sort $ "aabbccdde"
12:59:07 <ski> s/length &&& head/head && length/
12:59:08 <mauke> ENOBOT
12:59:09 <jyp> [('a',2),('b',2),('c',2),('d',2),('e',1)]
12:59:56 <petekaz> cool!
12:59:59 <petekaz> Thanks.
13:00:12 <davidhouse> (that gives you a [(Char, Int)], not [(String, Int)], be careful)
13:00:19 <mauke> sub { my %h; ++$h{$_} for @_; %h }->("a", "b", "c", "a", "b")
13:00:25 <davidhouse> but then [(Char,Int)] is probably what you want.
13:00:39 <davidhouse> or in general [a] -> [(a, Int)]
13:02:16 <davidhouse> very odd GHCi behaviour: http://pastebin.com/652085
13:03:03 <mauke> is this the monomorphism restriction?
13:03:29 <petekaz> I've got a data file (it's a CSV file) that is supposed to have a sample every 5 minutes in the form of: 2006-04-08,21:30:06.618,4007 and I want to ensure that I do not have more than one entry per 5 minute interval.  So I thought I would try my first haskell program to see if I could group them and filter out any with the same timestamp.
13:03:56 <davidhouse> @pl \a -> (head a, length a)
13:04:04 <davidhouse> argh. stupid lack of lambdabot.
13:04:17 <davidhouse> dons, sort it out!
13:05:48 <jyp> You can always run your own.
13:05:48 <ski> liftM2 (,) head length
13:05:53 * davidhouse runs his own
13:06:16 <jyp> then make it join #haskell ;)
13:06:22 <davidhouse> oh, wait, that doesn't work. it gets stuck on "loading plugins" :S
13:06:47 <JohnnyL> has anyone here made comparison on how small haskell code is for the functional equivilant of c?
13:06:56 <davidhouse> ski, ah, the ber-useful (a->) monad :)
13:07:24 <davidhouse> jyp, does lambdabot in offline mode have some kind of terminal?
13:07:34 <jyp> JohnnyL: You can have a look at the shootout.
13:07:44 <jyp> davidhouse: iirc yes
13:07:56 <jyp> davidhouse: but I never tested it myself.
13:08:05 <davidhouse> ski, same question (i assume you just used it to get that liftM2 result)
13:08:17 <ski> davidhouse : but the arrow-phrasing that jyp used is arguably simpler, in this case
13:08:28 <ski> davidhouse : i did it in head, actually :)
13:08:48 <davidhouse> ski, agreed.
13:09:31 <jyp> make: *** [Modules.hs] Segmentation fault
13:09:41 <jyp> compiling lambdabot ;(
13:09:42 <Saulzar> JohnnyL, Well there is the language shootout but I'm not sure how good the comparison is there
13:09:48 <Saulzar> @where shootout
13:10:39 <davidhouse> eww. segfaults.
13:10:53 <jyp> JohnnyL: I say typically a haskell program is 10 times smaller or more that the C counterpart
13:11:27 <jyp> On the shootout you'll have figures for extremely optimized haskell
13:11:34 <jyp> (ie. not typical)
13:13:06 <JohnnyL> k
13:14:23 <jyp> I wonder: how long would be gcc if it was re-written in haskell ?
13:14:45 <jyp> maybe 1/100 ;p
13:20:14 <davidhouse> i wish arrows were more useful.
13:20:16 <davidhouse> they're so pretty.
13:20:37 <wchogg> Why do you think they're pretty?
13:21:36 <davidhouse> they produce some really elegant solutions sometimes. and the general concept sounds like it has huge potential
13:21:47 <adu> arrows as in the Monadic alternative?
13:21:54 <davidhouse> but then, there's little application at the moment
13:21:58 <jyp> I never used them outside #haskell ;p
13:22:07 <davidhouse> adu, they're more an extension and generalisation of monads
13:22:37 <adu> davidhouse: how much more?
13:22:59 <davidhouse> adu, ?
13:23:13 <adu> n/m
13:23:21 <adu> i read "an" as "than"
13:23:55 <davidhouse> ah
13:26:26 <JohnnyL> wow, ruby really sucks cpu.
13:27:17 <jyp> Ruby is to Haskell as Perl is to C.
13:27:48 <jyp> I wish one of those makes it to the HWN quotes ;p
13:32:37 <vincenz> gotta love non-equilibrium physics
13:32:48 <davidhouse> what's the difference between newtype and data?
13:32:55 <vincenz> davidhouse: none afaik
13:33:01 <jyp> strictness
13:33:02 <davidhouse> other than the limitations that newtype can only have a single constructor
13:33:04 <vincenz> jyp: oh/
13:33:28 <jyp> newtype is stricter
13:33:42 <davidhouse> jyp, could you exemplify?
13:34:15 * jyp works on it
13:35:04 <xerox> davidhouse, data defines a new full-fledged datatype with its own (possibly many) constructors.  newtype defines a type isomorphic to the starting one, adding a label.  It has the advantage of being lightweight and letting you use 'deriving' clauses.  It also makes error messages more readable.
13:35:33 <davidhouse> ah, so you can derive anything with newtype?
13:35:44 <davidhouse> if the original type was an instance
13:35:46 <ski> 'newtype' constructors doesn't exist at run-time
13:36:01 <ski> newtype Foo = MkF Bar
13:36:18 <ski> unF (MkF bar) = bar
13:36:22 <xerox> newtype Foo = MkFoo { unFoo :: Bar }
13:36:28 <mauke> unF unF
13:36:33 <ski> 'unF' is not a strict function, even though it pattern-matches
13:37:20 <ski> hrm
13:37:32 <jyp> newtype T x = T x
13:37:32 <jyp> data U x = U x
13:37:32 <jyp> f (T x) = "ok"
13:37:32 <jyp> g (U x) = "ok"
13:37:32 <jyp> t = T undefined
13:37:32 <jyp> u = U undefined
13:37:42 * ski speaks garbage
13:37:51 <jyp> f t prints "ok"
13:37:57 <jyp> g u crashes
13:38:00 <ski> of  course 'unF' *is* strict
13:38:13 <ski> (as opposed to when you s/newtype/data/)
13:38:23 <ski> unF _|_ = _|_
13:38:27 <ski> MkF _|_ = _|_
13:38:32 <norpan> jyp: both of those will print "ok" surely?
13:38:55 <ski> data Foo' = MkF' Bar
13:38:56 <jyp> Try it out; g u crashes.
13:39:06 <MokuskerekHarc> hi. i am not at all familiar with linux and wonder whether it is possible to compile haskell to some sort of lib, so not as a standalone executable?
13:39:07 <ski> not (MkF' _|_ = _|_)
13:39:34 <ski> so, Foo' has one more value than Bar, hence they are not iso
13:40:52 <davidhouse> i think i need to read up on strictness. i never really covered it.
13:41:04 <jyp> A tough subject.
13:41:06 <norpan> jyp: you probably mean to define t = undefined and u = undefined
13:41:26 <norpan> without the constructor
13:41:39 <jyp> norpan: I meant what I typed
13:41:52 <norpan> no
13:41:55 <norpan> both work
13:42:02 <norpan> i think you meant what i typed
13:42:26 <jyp> norpan: I copy & pasted from my editor, and tested in ghci... So I see little possibility of failure :)
13:42:27 <ski> strict f  <=>  f _|_ = _|_
13:42:41 <davidhouse> ski, ah.
13:42:50 <davidhouse> that wasn't that tough ;)
13:43:00 <JohnnyL> jyp, open the bad bay doors please.
13:43:07 <JohnnyL> jyp, open the pod bay doors please.
13:43:08 <ski> so if it forces arg, then it is strict
13:43:33 * jyp opens the doors.
13:43:38 <norpan> jyp: i am certain you mean t = undefined and not t = T undefined
13:43:54 <davidhouse> jyp, yeah, g u works.
13:43:59 <norpan> the point being that f succeeds because the T pattern is not a real pattern
13:44:24 <norpan> not a real constructor
13:44:50 <jyp> I just tested with hugs, and it works.
13:44:59 <jyp> but it still crashes under ghci
13:45:10 <davidhouse> *Newtype> f t
13:45:10 <davidhouse> "ok"
13:45:10 <davidhouse> *Newtype> g u
13:45:10 <davidhouse> "ok"
13:46:07 <jyp> I must have something screwed up.
13:46:09 <norpan> the point is that let x = undefined; f (T x) = "ok" in f x will give you "ok"
13:46:38 <norpan> and bad example of me using x twice
13:47:04 <norpan> let t = undefined; f (T x) = "ok" in f t
13:47:40 <jyp> I guess it must be time to sleep for me ;p
13:47:44 <davidhouse> norpan: that works
13:47:48 <norpan> yes
13:47:49 <xerox> ?localtime jyp 
13:47:59 <norpan> but if you replace T by U it doesnt
13:48:09 <norpan> and there lies the difference between data and newtype
13:48:10 <davidhouse> ... but g u fails, indeed.
13:48:23 <jyp> I wonder what's up with ghci
13:50:40 <jyp> Ok, I give up
13:58:15 <heatsink> +karma ihope
13:58:26 <heatsink> @karma +ihope
13:58:45 <heatsink> hmm
13:59:16 <heatsink> lambdabot isn't here
14:03:17 <davidhouse> dons, around yet?
14:12:14 <SyntaxNinja> is there any way to work around the fact that haddock doesn't work on mutually recursive modules? like with #hide or something?
14:14:58 <int80_h> hi I just install newcgi, have the examples in my public_html. How do I get them to work?
14:15:08 <int80_h> I set the executable bit. what am I missing?
14:16:43 <SyntaxNinja> int80_h: usually you need to put them in cgi-bin
14:17:19 <int80_h> oooh...in var?
14:17:37 <int80_h> that's root access only at the moment I htink
14:18:44 <int80_h> is it possible to have my own cgi-bin in my home directory?
14:18:52 <SyntaxNinja> int80_h: depends on your sysadmin
14:18:59 <int80_h> does it need to be refered to in a conf file or can I just make one
14:19:06 <int80_h> ah better ask then
14:19:24 <SyntaxNinja> int80_h: a lot of sysadmins don't allow it due to security reasons
14:24:17 <int80_h> hmm I can run php scripts from public_html
14:24:37 <int80_h> can't he just make it so for my haskell scripts?
14:25:42 <int80_h> I'm very close to having a haskell blog :)
14:25:45 <ulfdoz> php is  an apache mod, there isn't executed anything, just parsed and interpreted.
14:25:52 <int80_h> oooh
14:31:19 <SyntaxNinja> int80_h: get your sysadmin to install mod_haskell ;)
14:31:25 <int80_h> well I would just cry if he said no. I've been bugging him to open up permissions here and there, install this and that. For him to say no now would make all of that work pointless
14:31:36 <int80_h> mod_haskell!!!
14:31:51 <int80_h> I didn't see anything about that on the haskell site
14:32:02 <ulfdoz> At least it is possible to really execute scripts. I did this for a webfrontend rebooting and shutting down a router.
14:32:06 <SyntaxNinja> int80_h: in order to test this, you can just write a quick shell script that generates an HTML page.  if you can get that to work, you'll be able to run haskell programs
14:32:26 <int80_h> test what, mod_haskell?
14:32:27 <ulfdoz> What das ghci with the shebang?
14:33:16 <int80_h> why isn't mod_haskell mentioned on haskell.org?
14:33:23 <int80_h> you'd think it would be a big deal
14:33:30 <int80_h> or maybe I missed it
14:33:37 <SyntaxNinja> ulfdoz: you can use runghc or runhugs
14:33:41 <SyntaxNinja> Lemmih: alive?
14:33:52 <ulfdoz> ah.
14:35:01 <int80_h> so you are sayig if I was able to get a shell script to generate some html, then I should be able to get haskell to work?
14:35:05 <SyntaxNinja> int80_h: it looks like it's from 2002, but revived recently by lemmih? I see a darcs repo, but unfortunitely, the web site it lives on looks down. lemmy see if I have a copy anywahere.
14:35:39 <int80_h> oooh if it's super experimental I don't want to bug my admin about it
14:36:17 <SyntaxNinja> int80_h: read the introduction and primer here: http://hoohoo.ncsa.uiuc.edu/cgi/overview.html
14:36:29 <SyntaxNinja> int80_h: yeah, you're much more likely to get them to allow you to run cgi
14:37:26 <int80_h> although my ultimate goal is to get a mewa framework in haskell written. seems to me we need a mod_haskell in order for that to happen
14:37:42 <int80_h> so once I get these toys going maybe I can tool around with this project
14:40:18 <int80_h> SN if you have a copy of mod_haskell I'd like to have it
14:40:30 <int80_h> I can always run it at home and play with it
14:42:55 <SyntaxNinja> int80_h: ask lemmih when he reappears.  he knows more than me.
14:49:36 <int80_h> what if I say his name three times
14:49:55 <int80_h> hastur hastur!! I mean lemmih lemmih lemmih!
14:50:14 <SyntaxNinja> int80_h: google might also help
14:50:34 <int80_h> i'm trying to get this bash script to work...
14:54:19 <int80_h> bah, that script didn't wok..okay I have reading to do
14:55:14 <SyntaxNinja> yes
15:03:26 <Mavrick> can someone explain to me how this example of a function that computes the fib sequence, how and why it works the way it does?
15:04:27 <Mavrick> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
15:04:49 <xerox> Mavrick, that function defines an infinite list, do you see how?
15:05:30 <musasabi> int80_h: what do you need exactly?
15:05:46 <xerox> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
15:06:08 <xerox> fibs = 0 : 1 : zipWith (+) (0 : 1 : _|_) (1 : _|_)
15:06:36 <xerox> fibs = 0 : 1 : 1 : zipWith (+) (1 : 1 : _|_) (1 : _|_)
15:06:37 <Mavrick> xerox: I knew it did but I dont know why
15:06:58 <xerox> fibs = 0 : 1 : 1 : 2 : zipWith (+) (1 : 2 : _|_) (2 : _|_)
15:07:07 <Mavrick> When I was sittin in class, I came up with my own equation for the fibonacci sequence (not in haskell, more psuedo code though)
15:07:15 <xerox> fibs = 0 : 1 : 1 : 2 : 3 : zipWith (+) (2 : 3 : _|_) (3 : _|_)
15:07:38 <xerox> fibs = 0 : 1 : 1 : 2 : 3 : 5 : zipWith (+) (3 : 5 : _|_) (5 : _|_)
15:07:44 <xerox> ...and so on...
15:08:02 <Mavrick> I know what the sequence is but I dont know why the code works like it does.  
15:08:35 <xerox> I'm showing you the expansion of 'fibs' and 'tail fibs' in the right hand side of the definition step by step.
15:08:49 <xerox> Which is how the recursive definition work.
15:08:52 <Mavrick> ahhh
15:09:59 <Mavrick> because in class I came up with an equation like: f(x,y) = f(y,x+y)  as a simple way of doing it, infinitely.  The code just threw me off since I was expecting something similar to my way
15:10:17 <Mavrick> (note, that isnt haskell code, just psuedo)
15:11:34 <xerox> Haskell syntax shares much with Mathematical notation.  The conversion between the two systems is usually quite straightforward.
15:12:11 <Mavrick> ah well im new to haskell, so its probaly just me
15:12:12 <xerox> If you care to write down the mathematics, I could try to transpose it in Haskell.
15:13:11 <Mavrick> No thats fine.  I just need to go read a haskell tutorial.  Ive been getting interested in recursion latly so I looked into haskell since i heard it has a lot to do with recursion
15:13:23 <musasabi> Serving Haskell pages is quite easy, but doing it in a safe fashion is much harder.
15:13:35 <xerox> "Yet Another Haskell Tutorial" is a pretty nice one, if you are still wondering which to pick up.
15:13:38 <musasabi> (that is in a multiuser setting)
15:13:57 <Mavrick> alright ill check that out
15:14:00 <Mavrick> thanks
15:14:06 <xerox> You're welcome.
15:21:39 <lennart> yo!
15:23:02 <xerox> Yow!!
15:28:16 <tic> lennart!
15:43:48 <jelmer> 'evening
15:44:04 <xerox> 'night
15:44:36 <jelmer> If I have "foo :: Int", will Haskell evaluate it more then once?
15:44:57 <jelmer> Similarly, if I have "foo : Int -> Int", will it evaluate it more then once for a particular value of the first int?
15:46:58 <Igloo> The language doesn't say. Probably not and probably in practice.
15:51:23 <jelmer> Is there any way to force particular behaviour?
15:52:23 <jelmer> I'm profiling some code which spends 90% of its time and circulates a few gig of RAM running a particular function which has only 32 possible input values (tuples)
15:54:00 <dons> anyone know anythign about silc? the "Secure Internet Live Conferencing"? I'm trying to work out if my irc page got spammed, or whether there really could be a legititmate haskell silc channel?
15:54:58 <jelmer> There really is something called SILC
15:55:09 <Igloo> jelmer: An array might be the best answer
15:55:12 <Igloo> dons: It's not impossible
15:55:24 <jelmer> it was originally meant to be the improved version of IRC, but never really took off
15:55:29 <dons> yeah, I know. but is it a free alternative to irc?
15:55:39 <Igloo> I believe so
15:55:42 <jelmer> dons: It is
15:55:45 <dons> someone edited the IRC_channel page on the wiki, putting silc references everywhere
15:55:51 <dons> i.e. the first paragraph
15:55:54 <dons> which is spammish
15:56:02 <dons> but you know, it mentions haskell.. so hmm..
15:56:06 <Igloo> The Haskell wiki?
15:56:17 <dons> ?wiki IRC_channel
15:56:41 <dons> i have to edit it. but do I remove all references? or just put a little silc ref right at the bottom.
15:57:03 <Igloo> It certainly should be listed first as it's not what most people will be looking for
15:57:17 <dons> should be?
15:57:22 <dons> or should not be?
15:57:23 <Igloo> Sorry, shouldn't be
15:57:43 <dons> yeah. yeah, its the _irc_ channel page, after all.
15:57:45 <Igloo> I might even lean towards: "See also: SILC_channel" at the bottom
15:57:50 <int80_h> be back later fiends
15:57:54 <dons> but coudl a haskell channel really appear withotu us knowing about it?
15:57:57 <int80_h> I mean, friends, of course
15:58:09 <int80_h> no offense to those of you residing in the lower planes
15:58:13 <Igloo> History is wrong, BTW. #haskell existed before shapr.
15:58:18 <dons> yep, I know.
15:58:32 <dons> it mentions irc.haskell.org
15:58:37 <dons> but you know earlier still?
15:58:43 <Igloo> shapr might have started the silc one. He's mentioned it a few times in the past
15:58:48 <dons> hmm.
15:58:51 <Igloo> #haskell here existed pre-shapr
15:59:26 <dons> do you have some text for me that I can add to the page while I'm there? :)
15:59:28 <SyntaxNinja> hm. how is the ghc documentation main index page generated? is the entire source tree parsed in one go, or is there a separate "make haddock" command (or something) for each package, and they're tied together somehow?
15:59:38 <dons> i.e. how far back do you know #haskell goes, Igloo?
15:59:45 <Igloo> I dropped in occasionally, and it was wli and someone else idling IIRC. I don't know any more details.
16:00:06 <dons> what year?
16:00:35 <Igloo> No a clue. I think it was discussed here not long ago if you're bored, or wli might remember more
16:01:42 <dons> ok. cheers
16:01:53 <dons> SyntaxNinja: I think its once per package and then glued.
16:02:51 <dons> there seems to be per-package build details for haddock in fptools/mk/package.mk
16:07:30 <dons> grr. server split. lambdabot won't join.
16:07:34 <dons> ?bot
16:08:18 <SyntaxNinja> I can't quite figure out how to do that w/ haddock.
16:08:36 <sethk> are people compiling from with vim and getting automatic parsing of errors the way you can do with emacs?
16:09:17 <dons> SyntaxNinja, can you update an index file with haddock?
16:09:41 <dons> sethk, hmm. I just grab the line number. but not automagically.
16:09:48 <dons> we should hack such code up if it doesn't yet exist
16:10:03 <sethk> dons, yes.  can you get the compilation in another window?
16:10:23 <dons> I usually get the compilation in a shell window that replaces the current window
16:10:28 <dons> nto in split buffers, though
16:10:38 <dons> !make
16:10:41 <dons> or such
16:11:03 <sethk> dons, there is a make on the tools menu in the gui version, and there is a find next error that seems to work
16:11:12 <sethk> dons, I just can't figure out how to see the error window
16:11:19 <sethk> which must exist since it is being parsed
16:11:26 <dons> is it in the buffer list?
16:11:35 <SyntaxNinja> dons: yeah, I can see how to generate a combined index (I think) if that's what you mean.
16:11:36 <sethk> dons, hm, let me check
16:11:47 <dons> :ls
16:13:50 <sethk> dons, yes, you can list them.  It shows the error on the status line, which isn't too bad
16:23:22 <dons> cool, spj added his sudoku solver to the wiki :)
16:23:58 <bolrod> dere!   zum ztuupid test in inits 8)
16:24:44 <Igloo> dons: So has anyone written one for GHC's type system yet?
16:24:50 <lennart> hmmm, i should add my solver too
16:25:30 <lennart> but maybe mine doesn't count.  I've never solved a sudoku puzzle
16:26:50 <dons> Igloo, a sudoku solver for the type system? is this a new type inference technique you're proposing?
16:27:33 <bolrod> sjanssen: you here?
16:27:39 <bolrod> someone here on the libraries mailing list?
16:28:03 <SyntaxNinja> bolrod: I am
16:28:24 <bolrod> oh.. nvm..  ;/    its ok
16:28:38 <bolrod> my post didn't show up or something .. does now
16:28:41 <bolrod> dunno what happened
16:28:44 <RyanT5000> type X = { _ _ 5    _ _ _     _ 3 2 ;  4 _ 3    5 9 8    .....
16:28:51 <dons> ah, a solution to the mysterious "why are the haskell birds so evil?" question <http://images-jp.amazon.com/images/P/4839919623.01.LZZZZZZZ.jpg>. the stern face means strength and health -- genki. consider this sushi restaurant: http://www.genkisushi.co.jp/. more evil faces, meanign strength and vigour :)
16:29:19 <bolrod> :)
16:29:22 <dons> so, an interesting stylistic convention
16:29:25 <Pseudonym> "Strength" I'll buy, but "vigour"?  Haskell?
16:29:28 <Pseudonym> Maybe jhc...
16:30:00 <Pseudonym> OK, "health".
16:30:02 <dons> well, haskell helps keep your healthy, perhaps.
16:30:04 <Pseudonym> Yeah, that works.
16:30:12 <Pseudonym> It certainly helps keep your mental health.
16:30:34 <Pseudonym> Java almost encourages acquired brain injury./
16:30:38 <dons> yep. and there's all that discipline too. very strong.
16:30:41 <dons> hehe
16:30:58 <dons> ?remember Pseudonym Java almost encourages acquired brain injury.
16:31:02 <dons> grr.
16:31:04 <dons> netsplit.
16:31:15 <Pseudonym> Thanks for not including the spurious slash.
16:31:43 <dons> I reserve the right to edit for style and brevity
16:31:53 <RyanT5000> what are the limits for pattern matching stuff?
16:32:01 <Pseudonym> If you wanted it more brief, you could just have said "Java bad".
16:32:08 <dons> deep otuer space, RyanT5000 
16:32:18 <dons> RyanT5000:  what do you mean by limits?
16:32:23 <RyanT5000> can i say func (sqrt 2) = 5
16:32:34 <dons> you match the structure of data 
16:32:35 <RyanT5000> i.e.: can i just throw in anything that's evaluable at compile-time
16:32:37 <dons> so no. you can't match on variables
16:32:39 <RyanT5000> ok
16:32:50 <dons> except for n+k patterns...
16:32:56 <dons> which are considered weacky
16:32:57 <RyanT5000> lol alright
16:33:11 <Pseudonym> You can match on data types.
16:33:12 <dons> then gofer has c*n + k patterns. so even more so.
16:33:20 <RyanT5000> hm
16:33:20 <Pseudonym> And constants, which is a limiting case of data types.
16:33:28 <dons> ah yes. constants too.
16:33:30 <dons> k patterns
16:33:37 <RyanT5000> right, well that's why i was wondering
16:33:42 <Pseudonym> f (Succ Zero) vs f 1
16:33:44 <RyanT5000> sqrt 2 is a constant
16:33:50 <Pseudonym> Limiting case.
16:33:52 <dons> but in general, youre matching the structure of the data.
16:33:52 <RyanT5000> it's just not a manifest constant
16:34:03 <dons> no float patterns
16:34:14 <RyanT5000> alright just wondering
16:34:19 <RyanT5000> yeah float patterns don't make much sense
16:34:31 <dons> > 1.1 + 2.2
16:34:32 <RyanT5000> it was just hte first thing that came to mind
16:34:37 <Pseudonym> Well, the kinda make sense.
16:34:38 <dons> hehe
16:34:41 <RyanT5000> your bot is broken :P
16:34:46 <Pseudonym> But they kinda don't.
16:34:56 <RyanT5000> well you generally can't compare floats for equality
16:35:02 <Pseudonym> Of course you can.
16:35:04 <RyanT5000> which would kind of inhibit the "matching" part
16:35:06 <Pseudonym> They're finite types.
16:35:09 <RyanT5000> yeah you can
16:35:09 <Pseudonym> So you can.
16:35:13 <RyanT5000> but you almost never want to
16:35:17 <Pseudonym> Right.
16:35:36 <RyanT5000> yeah i guess by that logic i would say you should be allowed to
16:35:39 <RyanT5000> meh
16:35:41 <Pseudonym> > let nan = read "Nan" :: Float in nan == nan
16:35:52 <dons> netsplti.
16:35:52 <Pseudonym> Should be NaN, of course.
16:36:34 <RyanT5000> right
16:36:56 <bolrod> dons: not a netsplit?!
16:37:04 <bolrod> 08:12:42 -!- lambdabot [n=lambdabo@shodan.cse.unsw.EDU.AU] has quit ["killed by SIGHUP"]
16:37:07 <bolrod> >:/
16:37:57 <dons> sure. but when I connect, it  says "*** Notice -- Server is currently split, channel modes are limited"
16:38:02 <dons> and won't join
16:38:13 <bolrod> -,-
16:38:26 <dons> i'm sitting here trying to get it to join as we speak. but no luck.
16:38:34 <bolrod> dang!
16:38:58 <bolrod> you also know about the mysteries of 'v' now? :)
16:39:14 <dons> fixed
16:39:21 <bolrod> what did you do?
16:39:22 <dons> that was fun. you guys jsut went nuts exploring it.
16:39:32 <bolrod> we did find it though
16:39:33 <dons> it jsut generates a logn random symbol name now.
16:39:46 <bolrod> ;o
16:40:10 <bolrod> where is the actual code in the lambdabot though
16:40:19 <dons> any attempt to touch 'v' would prdocuce a blackhole anyway.
16:40:23 <dons> its in hs-plugins
16:40:38 <dons> its the symbol we bind the expr you type in to.
16:40:57 <sjanssen> wow, this whole inits thing is getting controversial
16:41:08 <bolrod> sjanssen: ?
16:41:22 <bolrod> yeah.. someoneactually came up with a faster one
16:41:23 <bolrod> 8)
16:41:28 <dons> so unsurprisingly, referencing it is just going to diverge.
16:41:40 <bolrod> where is hs-plugins? :)
16:41:42 <bolrod> in the lambdabot?
16:41:59 <dons> its a library.
16:42:05 <bolrod> :o
16:42:10 <sjanssen> I expected maybe one or two responses when I sent the mail, not this many
16:42:21 <bolrod> hehe :D
16:42:22 <dons> sjanssen:  :) the thread is huge.
16:42:39 * bolrod grinns
16:42:43 <sjanssen> the funny thing is . . . who actually uses inits?
16:42:49 <dons> right.
16:42:50 <bolrod> erh
16:42:55 <bolrod> doesn't matter!
16:43:08 <bolrod> subsequences uses it
16:43:21 <dons> what's  this function, subsequences?
16:43:30 <dons> its not in any prelude I know of.
16:43:38 <dons> but its been mentioned twice this week..
16:43:54 <bolrod> its in the List Utils
16:44:07 <dons> in, what, MissingH?
16:44:26 <bolrod> -- subsequences xs returns the list of all subsequences of xs.
16:44:26 <bolrod> -- e.g., subsequences "abc" == ["","c","b","bc","a","ac","ab","abc"]
16:44:35 <bolrod> I don't know ;/
16:44:38 <bolrod> where it is..
16:44:45 <bolrod> http://www.haskell.org/haskell-report/List.html  << its here
16:44:52 <bolrod> though not in  the List module
16:45:04 <RyanT5000> does anyone know the cannonical way to exit a Graphics.UI.GLUT program?
16:45:05 <dons> its not in Data.List, 
16:45:12 <bolrod> ohhh
16:45:15 <bolrod> no.. wait
16:45:15 <sjanssen> oh, so subsequences is inits combined with tails
16:45:32 <bolrod> yes. it is in subsequences :)\]
16:45:52 <RyanT5000> i could throw an exception or some such bullshit, or i could pop out of the glutMainLoop, but it seems like there should be a "real" api
16:45:54 <bolrod> again... that's a bad version of subsequences ;)
16:46:01 <bolrod> I have a WAY better one here (didn't make meself)
16:46:23 <dons> RyanT5000: does it mention anything in the GLUT docs?
16:46:27 <sjanssen> out of lambdabot, GHC, FPS, Cabal, and any other Haskell sources I have on my computer, not one uses inits
16:46:28 <RyanT5000> couldn't find anything
16:46:39 <RyanT5000> there is a way to pop out of the glutMainLoop function, though
16:46:47 <dons> its used in beginner-programmer courses, I'm sure.
16:46:48 <RyanT5000> but it has ill-defined semantics
16:47:10 <RyanT5000> (i.e.: if you have two nested glutMainLoops it doesn't work right and stuff)
16:47:15 <RyanT5000> (which i won't, but still)
16:47:22 <RyanT5000> i guess i'll just use that
16:47:35 <RyanT5000> i don't plan to keep this program glut once i've got some stuff written
16:48:09 <dons> or just : exitWith ExitSuccess ?
16:48:20 <RyanT5000> that could work :)
16:48:27 <bolrod> seems like map (x:) is a VERY bad way to do things!
16:48:31 <RyanT5000> is that a prelude function?
16:49:01 <dons> RyanT5000:  in System.Exit
16:49:08 <RyanT5000> ah ok
16:49:13 <RyanT5000> that's exactly what i'm looking for
16:49:14 <RyanT5000> thanks
16:49:34 <bolrod> sjanssen: man...  I guess I could suggest the better version of subsequences... but hey..
16:49:52 <bolrod> subsequences1 xs = [ ] : [t | i<-inits2 xs, t<-tails i, not (null t) ] 
16:49:56 <RyanT5000> would it be useful to have a datatype for an unordered set?
16:49:58 <bolrod> thats REALLY fast
16:50:05 <sjanssen> @hoogle subsequences
16:50:15 <bolrod> not be here lambdabot is
16:50:15 <RyanT5000> where there's literally no way to get the ordering out of the set
16:50:16 <sjanssen> oh right, no lambdabot
16:51:05 <tennin> what's inits2?
16:51:25 <bolrod> its the same as inits
16:51:38 <bolrod> only in my post its to seperate the different definitions
16:51:53 <sjanssen> it seems subsequences didn't make it into Data.List, I wonder why?
16:51:59 <bolrod> sjanssen: man...  seriously.. if you don't have to use    'map (x:)'
16:52:02 <bolrod> 'never' use it
16:52:11 <bolrod> *Main> length $ subsequences [1..20]
16:52:11 <bolrod> 1048576
16:52:11 <bolrod> (4.00 secs, 715470880 bytes)
16:52:14 <tennin> doesn't your definition only get you the substrings?
16:52:15 <bolrod> thats why?
16:52:18 <bolrod> O_o
16:52:20 <RyanT5000> how do you make a 'global' state variable?
16:52:26 <bolrod> hm lets see
16:52:26 <RyanT5000> (w00t for quick hacks)
16:52:41 <RyanT5000> can you just make an IORef at the toplevel and it'll work in your other functions?
16:52:47 <bolrod> sjanssen: ahyes
16:52:50 <bolrod> its a bit different
16:52:52 <tennin> it looks like "subsequences" above gets you the "power set"
16:53:03 <bolrod> I see now
16:53:07 <bolrod> sorry
16:53:38 <bolrod> scotty! give me the power set of R   8)
16:53:52 <bolrod> or something
16:53:53 <bolrod> blah..
16:54:55 <bolrod> dang!  I should download the whole haskell report
16:55:00 <bolrod> and when I'm bored in the train
16:55:21 <bolrod> try to write slow functions out of my head and see if they turn out to be faster then the ones in the report :D
16:55:26 <sjanssen> another problem with the inits I proposed is that [1..] is a CAF, and will stay in memory after inits is finished
16:55:33 <tennin> so you'd want something like subsequences (x:xs) = subsequences xs >>= \ys -> [x:ys, ys]
16:56:02 <bolrod> sjanssen: is that a problem?.. or a good thing?
16:56:16 <bolrod> since the next function that will use the list will be mighty faster  right?
16:56:16 <bolrod> ;p
16:56:36 <sjanssen> bolrod: it can't be all that much faster, doing addition is not a big deal
16:57:04 <bolrod> still... a lost [1..]  isn't as bad as the inits now in the List module
16:57:05 <bolrod> ;p
16:57:14 <sjanssen> right
16:57:42 <bolrod> and what to use inits for..
16:57:57 <bolrod> you could possibly use it for some weird things
16:58:04 <tennin> er, except that gets me an error =\
16:58:18 <bolrod> what gets you an error?
16:58:25 <tennin> subsequences (x:xs) = subsequences xs >>= \ys -> [x:ys, ys]
16:58:37 <bolrod> ur.. I dont really get that anyway ;p
16:58:45 <bolrod> or.. I dont want to now
16:58:46 <bolrod> its
16:58:48 <bolrod> Tue Apr 11 01:58:26 CEST 2006
16:58:51 <bolrod> :)
16:59:28 <bolrod> I'm quite done with thinking for this night
16:59:38 <bolrod> maybe even for tomorrow...
16:59:47 <bolrod> (or today)
17:00:04 <bolrod> I'll just play some nice piano when I wake up :D
17:00:10 <bolrod> and some horrible
17:01:46 <dons> RyanT5000: you can, it needs unsafePerformIO and a NOINLINE pragma. its better to use a state monad though..
17:01:55 <RyanT5000> alright thanks
17:02:03 <bolrod> hmmmmmmmmmm   can I get access to /dev/dsp  through nfs? :D
17:02:15 <RyanT5000> that's sort of what i wanted to hear, although in this particular case it would've been slightly easier
17:02:34 <RyanT5000> how much stuff is really benefitted by using the unsafe functions anyway?
17:02:39 <RyanT5000> can you really make stuff that much faster?
17:03:56 <dons> not faster. no.
17:04:08 <RyanT5000> so then why?
17:04:09 <dons> they're unsafe because they rquire extra checks on the part of the programmer
17:04:15 <RyanT5000> no i know that's why they're unsafe
17:04:19 <RyanT5000> i'm asking why they exist
17:04:35 <dons> sometimes they're useful. if you're too lazy to use a monad. 
17:04:41 <dons> unsafePerorform IO is used to csat pure foreign functions
17:04:52 <RyanT5000> ah ok
17:04:53 <dons> so that, say, sin(3) could be pure
17:04:58 <sjanssen> it's also used in the case of DiffArray
17:05:12 <dons> there are other uses.
17:05:12 <dons> the stdin Handle
17:05:16 <RyanT5000> alright
17:05:23 <RyanT5000> sounds reasonable
17:05:31 <RyanT5000> i just don't like how it taints the surface of the language :P
17:05:44 <RyanT5000> can you disable unsafe operations for a particular chunk of code?
17:06:08 <RyanT5000> it seems like if you could, then you could have a relatively safe vm environment
17:06:36 <RyanT5000> something like "import safe CodeIDon'tTrust"
17:06:55 <sjanssen> there isn't anything like that right now
17:06:56 <RyanT5000> then as long as you never take an action in a monad from that code, you're OK
17:07:35 <RyanT5000> so it's not possible to sandbox code right now?
17:07:40 <sjanssen> plus, unsafePerformIO isn't the only hole
17:07:45 <RyanT5000> :(
17:07:55 <RyanT5000> is anything that isn't unsafe a hole?
17:08:11 <sjanssen> not that I know of
17:08:34 <RyanT5000> so if the compiler/interpreter/vm had all the unsafe functions flagged
17:08:37 <RyanT5000> and choked them off
17:08:42 <RyanT5000> to "import safe" code
17:08:49 <RyanT5000> you might have a provably secure environment
17:09:07 <RyanT5000> (assuming no implementation bugs, of course)
17:09:08 <sjanssen> even if you can prevent a library from doing IO, it can always suck CPU and memory
17:09:42 <RyanT5000> true, but if the preemptive multitasking was strengthened a bit you could have a watcher thread
17:10:28 <RyanT5000> it doesn't seem like adding separate heap size limits to different parts of the program would be hideously complicated (of course, i say this without knowing anything about how ghc works)
17:11:37 <Pseudonym> Actually, Ryan, you might like to look at Mercury's purity system.
17:11:40 <dons> you get safe code if you use only H98. this is  how lambdabot's @eval works. only a trusted core is available.
17:11:58 <dons> then we can sit back and let the type system rule out thee  evil hackers
17:12:08 <RyanT5000> ah ok
17:12:11 <RyanT5000> sounds good
17:12:12 <sjanssen> dons: how exactly is this implemented?  selective imports?
17:12:17 <dons> yep
17:12:26 <dons> and then posix rlimits for cpu and heap
17:12:40 <sjanssen> well, there's you answer RyanT5000
17:12:44 <RyanT5000> couldn't this be the basis for an OS?
17:12:51 <Pseudonym> http://www.cs.mu.oz.au/research/mercury/information/papers/purity.ps.gz
17:12:55 <Pseudonym> That's a really interesting paper.
17:12:57 <RyanT5000> then only use task switching for convenience/performance
17:13:21 <sjanssen> just don't give "naughty" modules a slightly modified interface that doesn't have unsafePerformIO and friends
17:13:34 <sjanssen> erm, remove that don't
17:13:44 <Pseudonym> A purity system in Haskell might be interesting, but I'm not sure how it would interact with lazy evaluate,
17:13:47 <Pseudonym> evaluation
17:14:42 <dons> grr. the server is still split. what's up with freenode?
17:16:03 <dons> ah. don't connect to the .au node. apparently we're cut off from the universe today.
17:16:30 <Pseudonym> No, the universe is cut off from us.
17:16:34 <Pseudonym> Their problem.
17:16:40 <dons> true true
17:17:07 <dons> there we go
17:17:17 <dons> ?vixen welcome back, baby.
17:17:29 <lambdabot> what is pron?
17:17:30 <Pseudonym> > let nan = read "NaN" :: Float in nan == nan
17:17:31 <lambdabot> False
17:17:34 <Pseudonym> Cool.
17:17:44 <dons> that's cool.
17:19:20 <Pseudonym> Actually, reading this purity paper again, it strikes me how much it's like the semantics of SMP memory models.
17:19:45 <Pseudonym> A call to impure code is like a memory barrier.
17:20:16 <Pseudonym> Pure code is like code that only accesses thread-local storage.
17:20:40 <RyanT5000> i guess i'll be installing ghostscript ;-/
17:20:41 <RyanT5000> :-/
17:20:52 <Pseudonym> That's no coincidence, of course.  The thing that stuffs up multithreaded programming is the same thing that stuffs up impure programs: global state.
17:21:13 <Pseudonym> Ryan, there may be a PDF copy on citeseer.
17:21:20 <RyanT5000> ooh gp
17:22:23 <RyanT5000> so another security-related issue about IO
17:22:30 <RyanT5000> the monad, that is
17:22:41 <RyanT5000> wouldn't you theoretically be able to partition it?
17:22:47 <RyanT5000> i.e.: make different containers
17:22:52 <RyanT5000> whose state doesn't impact each other
17:23:09 <dons> you can do it practically, not jsut theoretically. this sounds like ST?
17:23:19 <dons> have a look at the ST monad.
17:23:32 <RyanT5000> cool :)
17:23:41 <RyanT5000> i find that 99% of what i say "wouldn't it be cool if" has been implemented already
17:23:52 <RyanT5000> and the remaining 1% is not really all that cool anyway
17:24:13 <dons> lots of smart researchers have been thinking about this stuff for the last 20 years, once they got a hold of monads :)
17:24:13 <Pseudonym> Clean has a similar concept.
17:24:13 <RyanT5000> (i.e.: i think class functions should create a new scope, just like they do in C++/java/etc.)
17:24:20 <Pseudonym> You can split off parts of the world type.
17:24:30 <RyanT5000> yah, that seems useful to an OS
17:24:35 <Pseudonym> So, for example, file I/O can be done separately from GUI stuff.
17:24:45 <RyanT5000> yeah
17:24:51 <Pseudonym> There's always multithreading, too.
17:24:52 <RyanT5000> i've been interested in high-security OSes for a long time
17:26:03 <sjanssen> it would be neat if we could pitch monads and a strong type system as the solutions to security
17:26:11 <RyanT5000> i think they are
17:26:14 <sjanssen> security seems to be fashionable lately
17:26:18 <RyanT5000> so yes, it's a mater of pitching
17:26:20 <RyanT5000> *matter
17:26:27 <sjanssen> well, nothing is a silver bullet, but they could go a long way
17:26:38 <RyanT5000> of course; you'll always have the security-usability tension
17:27:08 <RyanT5000> but imo, the way to approach that is to nail down the security, then make reasoned concessions to usability
17:27:12 <RyanT5000> not the other way around
17:27:56 <mux> @pl l2a x = listArray (1, length x) x
17:27:58 <lambdabot> l2a = listArray =<< (,) 1 . length
17:28:13 <mux> mmmm
17:28:28 <mux> looks bogus, isn't it?
17:31:33 <sjanssen> listArray on the LHS of the (=<<) doesn't seem right
17:31:56 <sjanssen> oh wait, it's using the (a->) monad
17:35:57 <RyanT5000> do people pretty much always use "a" in "class Class __ where..."?
17:36:02 <RyanT5000> when it's only one variable, that is
17:37:37 <sjanssen> not always
17:37:48 <sjanssen> class Monad m where ...
17:37:55 <sjanssen> class Functor f where ...
17:37:55 <RyanT5000> alright
17:39:44 <dons> sometimes you see 't' and 'u' for type 
17:40:23 <dons> not as often as 'a' ... though.
17:41:41 <RyanT5000> hm, can classes be curried?
17:42:01 <RyanT5000> so if you have classes A and B
17:42:10 <RyanT5000> and you require that all members of B are also members of A
17:42:15 <RyanT5000> (you can do that, right?)
17:42:26 <RyanT5000> then is that eqivalent to a class C of two parameters?
17:42:38 <RyanT5000> oh no sorry i was confused
17:45:28 <dons> ?seen vincenz
17:45:29 <lambdabot> I saw vincenz leaving #haskell 4 days, 3 hours, 16 minutes and 56 seconds ago, and I have missed 3 days, 16 hours, 5 minutes and 27 seconds since then.
17:46:07 <palomer> blargh!
17:46:58 <dons> ah, another good palomer-ism :)
17:47:02 * dons updates lambdabot
17:50:52 <palomer> @palomer
17:50:53 <lambdabot> hrmph
17:54:47 <mux> @pl swapArray x y xs        = (//) xs [(x, xs ! y), (y, xs ! x)]
17:54:49 <lambdabot> swapArray = (ap (//) .) . ap (ap . (liftM2 (:) .) . (. flip (!)) . (.) . (,)) (flip flip [] . ((flip . ((:) .)) .) . flip ((.) . (,)) . flip (!))
17:54:55 * mux gasps
17:55:01 <dons> good  bot
17:55:08 <RyanT5000> lol
17:55:33 <mux> I thought point-less programming was not possbile when the variables are referenced several times in the expression of the function
17:55:37 <mux> read that in some tuto
17:55:45 <dons> sure. join
17:55:49 <mux> is lambdabot just being silly or has this a chance of working?
17:55:51 <dons> @pl \x -> x * x
17:55:52 <lambdabot> join (*)
17:55:56 <mux> ah.
17:56:17 <dons> it probably does have a chance, if you get the monad instances right
17:56:24 <dons> its sometimes hard to tell which monad its using
17:56:34 <dons> and a -> is in a hard to find place
17:56:42 <mux> needless to say, I like my version better :-)
17:56:57 <mux> it's not that it's more readable, it's that it's readable
17:57:18 <Excedrin> is there a, "why point free programming is interesting, an explanation for idiots" somewhere?
17:57:29 <RyanT5000> it's fun ;)
17:57:40 <RyanT5000> and sometimes useful
17:57:49 <RyanT5000> (i think)
17:57:55 <RyanT5000> (can't say i have any examples)
17:58:25 <dons> ?wiki Pointfree
17:58:26 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
17:59:41 <mux> I think the best example is when you just want to alias a function
17:59:51 <mux> foo = map
18:01:40 <RyanT5000> oooh
18:01:49 <RyanT5000> i get to write my own monad!
18:01:51 <RyanT5000> ... or should it be an arrow
18:02:05 <RyanT5000> question:
18:02:31 <RyanT5000> i'm writing a Skin class, as such: Skin a where render :: a -> b -> Scene
18:02:37 <RyanT5000> but i want to change that
18:02:43 <palomer> writing a monad is like taking your girlfriend out when she's on the rag: no matter how hard you try, you'll never get what you want
18:02:56 <dons> its particularly useful in mechanical derivation and refaactoring of code.
18:03:09 <RyanT5000> well, here's the deal
18:03:12 <RyanT5000> there's two bits of state
18:03:18 <RyanT5000> first of all a Skin might create something like a Window
18:03:19 <dons> (pointfree, that is)
18:03:33 <RyanT5000> which the user might move
18:03:34 <RyanT5000> so it has some state
18:04:03 <RyanT5000> but also i want the Skin, when rendering the next frame, to be able to use the previous frame's Scene to its advantage
18:04:15 <RyanT5000> in case there's something it can reuse
18:04:27 <palomer> rule number one: before making a monad, make sure the mtl doesn't suffice
18:04:39 <RyanT5000> that sounds like a good rule; now to figure out what MTL is
18:04:42 <dons> and it almost always does
18:05:01 <dons> look up the monad transformer library on the haskell.org std libs docs
18:05:07 <dons> you probably just want a State monad
18:05:11 <RyanT5000> cool
18:05:25 <dons> if threading these values around becomes tedious, then State is always an option
18:05:36 <RyanT5000> well it's not an issue of it becoming tedius
18:05:39 <RyanT5000> *tedious
18:05:40 <dons> so you magically get them threaded, and index them only when required.
18:05:47 <RyanT5000> a skin won't know what state a Window keeps, for instance
18:06:07 <palomer> do it the palomerway: STify everything
18:06:22 <dons> ?quit palomer goes into the quotes module
18:07:00 <dons> hmm. I seem to have broken @quit some how.
18:07:23 <palomer> it is a lie! I did not go into the quotes module
18:07:27 <dons> ?help palomer
18:07:43 <lambdabot> palomer. Sound a bit like palomer on a good day.
18:07:48 <dons> ?palomer
18:07:49 <lambdabot> blargh!
18:07:53 <dons> ah, always a classic
18:07:54 <dons> :)
18:08:29 <dons> palomer, now you're truly famous :)
18:08:42 <palomer> ?help help
18:08:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:08:57 <palomer> how do I add a quote?
18:09:40 <dons> you can't add quotes for yourself.
18:10:04 <palomer> ?palomer
18:10:04 <lambdabot> hrmph
18:10:43 <palomer> dons: how do I add quotes to other people?
18:10:51 <dons> there's the usual, @remember mechanism. but that's not the same as @palomer.  
18:11:00 <dons> i.e. there is no @<nick> magic command.
18:11:20 <RyanT5000> lol
18:11:53 <palomer> @remember palomer curry kicked my dog
18:11:58 <palomer> @remember palomer
18:12:08 * palomer gives up
18:12:21 <araujo> hiya!
18:13:06 <palomer> yo
18:13:50 <RyanT5000> hm...
18:14:10 <RyanT5000> maybe i shouldn't store state between frames
18:14:18 <RyanT5000> i.e.: give the previous scene
18:14:33 <araujo> how you lambda hackers go today?
18:14:43 <palomer> sideways
18:15:32 <RyanT5000> if i evaluate "render mySkin myObject" twice, that will be really fast the second time unless the results got GCed, right?
18:16:20 <dons> @palomer is just privledged. its one of the few first-class @<nick>s
18:16:50 <palomer> I'm glad _somebody_ recognizes the value of my constructive input
18:17:33 <RyanT5000> oh trust me we all do
18:17:42 <dons> ?bot
18:17:53 <dons> hmm. bot plays monkey tricks
18:27:56 <mux> @pl list2map xs = fromAscList (zip [0..] xs)
18:28:12 <mux> damn
18:28:30 <mux> it left!
18:29:20 <araujo> list2map = fromAscList . zip [0..] 
18:30:04 <mux> yeah, that's what I did, but I had an error
18:30:09 <mux> it turns out it was my type signature
18:30:23 <metaperl> dons: ping?
18:30:29 <dons> ?bot
18:30:29 <lambdabot> :)
18:30:30 <mux> GHCi tells the type is list2map :: [b] -> Map Integer b
18:30:47 <metaperl> are you on the ghc bugs list? I submitted a bug report this morning about building under cygwin and no response yet
18:30:52 <dons> @pl list2map xs = fromAscList (zip [0..] xs)
18:30:53 <lambdabot> list2map = fromAscList . zip [0..]
18:30:56 <mux> and I had list2map :: Eq k => [a] -> Map k a
18:31:02 <dons> metaperl, saw that. should get response in due course..
18:31:10 <metaperl> ok
18:31:26 <mux> @type fromAscList . zip [0..]
18:31:26 <lambdabot> Not in scope: `fromAscList'
18:31:45 <araujo> mux, can you paste code?
18:31:48 <dons> in Map
18:31:58 <dons> @type Data.Map.fromAscList . zip [0..]
18:31:59 <lambdabot> forall b a.
18:31:59 <lambdabot>             (Num a, Enum a) =>
18:31:59 <lambdabot>             [b] -> Data.Map.Map a b
18:32:09 <dons> we should add some more modules to ghci's scope when doing @type
18:32:12 <dons> its often requested.
18:32:23 <araujo> dons, that'd be nice (hi!)
18:32:24 <mux> well it's only that
18:32:26 <mux> list2map                :: Eq k => [a] -> Map k a
18:32:26 <mux> list2map                = fromAscList . zip [0..]
18:32:38 <dons> heya araujo 
18:32:46 <mux> somehow it didn't like it because [0..] forces Integers or something
18:33:09 <araujo> mux, you are working with Integer numbers
18:33:20 <mux> yes
18:33:27 <araujo> kind of an implicit type constraints
18:34:09 <mux> I have just that now
18:34:10 <mux> list2map                :: [a] -> Map Integer a
18:34:28 <mux> and it satisfies the constraint put by the [0..]
18:34:35 <mux> (thanks GHCi!)
18:37:01 <sjanssen_> I've been thinking about sandboxing.  Newtype deriving could make it very easy
18:38:01 <RyanT5000> how?
18:38:24 <sjanssen_> let's say we're just sandboxing Handles
18:38:51 <sjanssen_> we partition the operations on them into separate classes: HandleWrite, HandleRead, HandleCreate
18:39:07 <sjanssen_> each with the obvious functions in them
18:39:18 <sjanssen_> we make IO an instance of each
18:39:58 <RyanT5000> then you make a newtype?
18:40:02 <RyanT5000> of IO?
18:40:13 <sjanssen_> then say we want a monad that can read from handles, but not get them from the outside world: newtype ReadingOnly a = ReadingOnly (IO a) deriving (Monad, HandleRead)
18:40:38 <RyanT5000> ah
18:40:53 <RyanT5000> how do you make it so your own classes work with "deriving"?
18:41:24 <sjanssen_> I think newtypes can derive anything their base instances
18:41:29 <sjanssen_> it's probably a GHC extension
18:41:32 <RyanT5000> ok
18:41:58 <RyanT5000> yeah that seems like it'd work
18:42:11 <sjanssen_> so the only real boilerplate you have to write is the initial "Prelude", containing the classes, and instances for the IO monad
18:42:23 <RyanT5000> hm
18:42:52 <sjanssen_> oh, and of course you have to not export the constructors for the newtypes like ReadingOnly, etc.
18:42:58 <RyanT5000> right
18:44:13 <sjanssen_> oh, you'd also make a class like "RunIO" which lifts the actions stored in a newtype to the normal IO monad
18:44:33 <RyanT5000> yeah
18:44:45 <RyanT5000> and then restrict unsafe functions
18:44:51 <RyanT5000> that seems pretty cool
18:44:56 <sjanssen_> yes
18:45:17 <RyanT5000> i think you could make a really safe OS based on this stuff
18:45:20 <sjanssen_> yeah, I think a person could implement this "Prelude" with basic stuff in a day or so
18:45:37 <RyanT5000> yeah, so long as person != me :P
18:45:50 <RyanT5000> i'll work on this kind of thing after i finish my game
18:46:45 <dons> ?dynamic-load type
18:46:45 <lambdabot> module loaded
18:46:51 <dons> ?kind Word8
18:46:52 <lambdabot> Not in scope: type constructor or class `Word8'
18:47:12 <dons> ?dynamic-load type
18:47:12 <lambdabot> module loaded
18:47:15 <dons> ?kind Word8
18:47:15 <lambdabot> Not in scope: type constructor or class `Word8'
18:47:18 <dons> hmm
18:48:00 <dons> ?quit what's that then?
18:48:08 <dons> ?version
18:48:24 <sjanssen_> actually, rather than restrict unsafe*, I'd just not allow untrusted modules to import the IO datatype
18:48:25 <lambdabot> lambdabot 3p409, GHC 6.4.1 (Linux i686 3.20GHz)
18:48:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:48:32 <dons> ?kind Word8
18:48:35 <lambdabot> *
18:48:47 <dons> ah, there we go. araujo : context for all!
18:48:49 <RyanT5000> you'd actually have to do more than that i think
18:49:11 <RyanT5000> well
18:49:11 <dons> ?type intersperse
18:49:12 <RyanT5000> maybe not
18:49:13 <lambdabot> forall a. a -> [a] -> [a]
18:49:27 <RyanT5000> don't some unsafe operations not use IO?
18:49:37 <RyanT5000> like unsafeUpdate or whatever for MArrays
18:49:39 <dons> sure. TH is pretty unsafe
18:49:45 <RyanT5000> it is?
18:49:48 <dons> unsafeAt, and other array updates
18:49:50 <RyanT5000> how is TH unsafe?
18:50:04 <RyanT5000> if you already don't trust the code, why do you care if it's generating more untrusted code?
18:50:04 <dons> you can call gcc, or arbitrary code, from inside ghc during compilation
18:50:10 <dons> inserting anything you want
18:50:17 <sjanssen_> yeah, outlawing the unsafe's would be necessary
18:50:18 <RyanT5000> no you have to sandbox the TH splice code too
18:50:26 <dons> don't use TH.
18:50:33 <RyanT5000> but i like th :P
18:50:39 <dons> polymorphic IORefs can be used to write  unsafeCoerce#
18:50:44 <dons> so that's another one.
18:50:51 <dons> oh, but that's in IO.
18:50:58 <dons> hmm. polymoprhic STRefs probably have the same.
18:51:01 <dons> hmm...
18:51:10 <RyanT5000> if you mark every unsafe function as unsafe somehow
18:51:12 <mux> @pl update' x k map         = update (\y -> Just x) k map
18:51:13 <lambdabot> update' = update . const . Just
18:51:21 <mux> beautiful.
18:51:25 <RyanT5000> and don't allow their symbols to be resolved by untrusted code
18:51:35 * mux hearts lambdabot 
18:51:39 <RyanT5000> (which includes splice code as well as what it generates)
18:51:42 <RyanT5000> i don't see a problem
18:52:11 <RyanT5000> and besides, anything that could call gcc would already be either IO or unsafe
18:52:31 <RyanT5000> and even if you could call it, you could only modify the file system, because linking (dynamically or otherwise) with C code is definitely unsafe
18:52:32 <sjanssen_> anything that can call another executable is unsafe
18:53:08 <RyanT5000> if you mean binary executable yeah
18:53:27 <dons> @docs STRef
18:53:28 <lambdabot> STRef not available
18:53:31 <RyanT5000> although theoretically you could have some system for using the sandboxing system on other Haskell executables
18:53:40 <RyanT5000> also, what if you seamlessly sandboxed the binary?
18:53:48 <RyanT5000> that'd be really hard
18:54:12 <dons> oh, good thing I removed STRef and IORef from lambdabot's @eval..
18:54:22 <RyanT5000> but if you believed that chroot/jail/etc. actually worked, you could probably write a system(const char *) that would be safe
18:54:30 <dons> otherwise we would have had a unsafeCoerce# hole. 
18:54:37 <sjanssen_> dons: is this unsafeCoerce# via IORef documented?
18:55:00 <dons> yep. its well known that polymoprhic refs can break type safety. let me find a link
18:55:17 <heatsink> oh, you brought lambdabot back
18:55:21 <heatsink> @karma +ihope
18:55:22 <lambdabot> +ihope has a karma of 0
18:55:28 <heatsink> +karma ihope
18:55:34 <heatsink> @help karma
18:55:35 <lambdabot> karma <nick>. Return a person's karma value
18:55:46 <heatsink> @+karma ihope
18:55:47 <lambdabot> ihope has a karma of 2
18:56:03 <heatsink> that's for mentioning unSeq, which I needed today.
18:59:34 <Revision17> Do any of you have any experiences with HToolkit ( http://htoolkit.sourceforge.net/ )?
18:59:37 <Smokey`> @karma Smokey`
18:59:38 <lambdabot> You have a karma of 0
18:59:41 * Smokey` cries
18:59:53 <RyanT5000> how do i do pattern matching with "anything of type A"
18:59:59 <Revision17> the GUI library part I mean
19:00:01 <RyanT5000> like i have a function
19:00:16 <RyanT5000> composite :: Skin a => a -> obj -> state -> Scene
19:00:25 <RyanT5000> (actually it's in class Skin)
19:00:33 <audreyt> @pl \x -> let ref = unsafePerformIO (newIORef undefined) in unsafePerformIO (writeIORef ref x >> readIORef ref)
19:00:35 <lambdabot> flip (unsafePerformIO .) (unsafePerformIO (newIORef undefined)) . (`ap` readIORef) . ((>>) .) . flip writeIORef
19:00:58 <RyanT5000> it takes obj (the document to be composited into a Scene), and its own state (window positions, etc.), and returns the Scene
19:01:14 <sjanssen_> audreyt: do you need unsafePerformIO to do that?
19:01:26 <audreyt> sjanssen_: I'm afraid so
19:01:34 <RyanT5000> now if i want to implement this function, how do i write a pattern so that it'll match as obj "any Scene"
19:01:59 <RyanT5000> so the type of that particular pattern-matching version of the function would be a -> Scene -> state -> Scene
19:02:05 <Pseudonym> audreyt: You almost never need unsafePerformIO
19:02:15 <Pseudonym> And you realy, really never need it twice in the same expression.
19:02:26 <audreyt> Pseudonym: er, I was giving a definition of unsafeCoerce.
19:02:31 <Pseudonym> Ah.
19:02:36 <audreyt> since sjanssen_ asked for it :)
19:02:41 <Pseudonym> Which you also almost never need. :-)
19:02:45 <dons> oh, I didn't realise it need unsafePerformIO.
19:03:00 <dons> that's semi-obivously evil.
19:03:06 <dons> but I thought there was a sneakier way
19:03:14 <RyanT5000> isn't unsafePerformIO the root of all evil?
19:03:15 <sjanssen_> woo hoo!  one less hole to deal with to make a sandbox
19:03:48 <dons> I guess  its a bit surprising. there's no clear changing of types. and unsafePerformIO is superficially like a runST
19:04:20 <audreyt> dons: the key is the "ref" is used twice
19:04:24 <audreyt> but performed once
19:04:41 <audreyt> can't do that without unsafePerformIO
19:05:17 <Pseudonym> unsafePerformIO is evil, but it's a necessary evil.
19:05:25 <Pseudonym> Much like the monomorphism restriction.
19:05:39 <Pseudonym> Although precisely how necessary that is is still up for debate.
19:05:50 <RyanT5000> is there a stronger version of "import Module as M"?
19:05:54 <wchogg> Why is unsafePerformIO a necessary evil? I was wondering about that earlier?
19:06:00 <Pseudonym> It's necessary for FFI.
19:06:07 <dons> ah, you do need unsafePerformIO for the trick: from the hier docs:
19:06:09 <dons>      test :: IORef [a]
19:06:09 <dons>      test = unsafePerformIO $ newIORef []
19:06:09 <dons>      main = do
19:06:09 <dons>               writeIORef test [42]
19:06:10 <audreyt> and for "trace"
19:06:12 <dons>               bang <- readIORef test
19:06:14 <dons>               print (bang :: [Char])
19:06:15 <sjanssen_> RyanT5000: import qualified Module as M
19:06:19 <RyanT5000> thanks
19:06:23 <Pseudonym> "trace" could be considered part of the RTS.
19:06:29 <dons> will actually segfault
19:06:52 <Pseudonym> Yes, the other place where you need it is to define top-level IORefs/Uniques/whatever.
19:07:03 <Pseudonym> And related libraries.
19:07:15 <RyanT5000> here's a question
19:07:24 <dons> so its a bit surprising nonetheless that a well typed function can break the type system
19:07:26 <Pseudonym> I once needed IORef-like objects which were members of Ord, for example.
19:07:27 <RyanT5000> is defining top-level IORefs/Uniques/whatever actually sane?
19:07:38 <RyanT5000> i've been grappling with this question and i'm pretty sure the answer is no
19:07:56 <RyanT5000> you're always making some evil assumption, in my experience, when you define top-level names like that
19:08:02 <audreyt> well, it is useful for e.g. end-of-program finalizers
19:08:04 <wchogg> Why will it segfault, dons?  I guess I'm being dense.  Is it because of the attempted conversion from an Int to Char?
19:08:20 <dons> its not an attempted conversion. its an actual type cast.
19:08:27 <RyanT5000> i think it's an unterminated C string?
19:08:37 <dons> which doesn't work, yet the type checker says its ok
19:08:51 <audreyt> dons: but if you had 42::Int, that probably would work
19:08:55 <RyanT5000> char x = 42; printf( &x )
19:08:58 <dons> yep. twould
19:09:05 <RyanT5000> oh
19:09:06 <RyanT5000> ic
19:09:34 <dons> so, non monadic references are evil!
19:09:46 <RyanT5000> absolutely
19:09:50 <audreyt> s/references/mutability/
19:09:51 <dons> how do the ML guys live with themselvers?
19:10:15 <sjanssen_> I imagine they cry themselves to sleep each night
19:10:37 <wchogg> Harsh, yo.
19:10:42 <CosmicRay> sjanssen: oh, I'd imagine you're talking about the java folks.
19:10:55 <sjanssen_> CosmicRay: them too
19:11:13 <sjanssen_> at least, that's what I did until I found Haskell.  ;-)
19:11:22 <CosmicRay> didn't we all ;-)
19:11:37 <dons> wchogg: aren't refs very common in ML code? they get introduced very early in the ML books I've seen. non-monadically.
19:11:44 <Pseudonym> Creating top-level IORefs is sane if they're not polymorphic.
19:11:57 <Pseudonym> It's the polymorphism that's a problem.
19:12:01 <CosmicRay> dons: they are, and they are nothing special in ml since ml isn't pure
19:12:46 <dons> ah , good point CosmicRay. but they 'd still have the polymorphic ref leads to segfault. at least we have to explicitly break things with unsafePerformIO for our refs to go evil
19:13:48 <dons> so that's one extra barrier to evil that you have to jump in Haskell, while the ML guys can walk straight in.
19:14:09 <CosmicRay> dons: that is a lovely quote of the week.  sjanssen's comment too. ;-)
19:14:24 <dons> hehe
19:14:29 <int-e> @type Control.Monad.ST.runST (Data.STRef.newSTRef undefined)
19:14:30 <lambdabot>   Inferred type is less polymorphic than expected
19:14:30 <lambdabot>   Quantified type variable `s' escapes
19:14:46 <RyanT5000> @where ($=)
19:14:47 <lambdabot> I know nothing about ($=).
19:14:53 <RyanT5000> where is $= defined?
19:14:55 <CosmicRay> dons: I'm porting some ocaml code to Haskell right now.  it's a very interesting experience.
19:15:03 <int-e> @index ($=)
19:15:04 <RyanT5000> @index ($=)
19:15:04 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
19:15:05 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
19:15:09 <RyanT5000> ... wait
19:15:12 <CosmicRay> dons: I find that my Haskell code is longer sometimes because I can't just use the result of I/O inline
19:15:13 <RyanT5000> it's a glut-only thing?
19:15:31 <CosmicRay> dons: otoh, I feel this strange twinge when reading the OCaml code of "oh my, that was so UNSAFE!"
19:15:39 <dons> hehe :)
19:15:43 <RyanT5000> that's true CosmicRay
19:16:12 <RyanT5000> is there any way to improve that syntax?
19:16:12 <dons> I found similar things when porting OCaml code to haskell in the shootout
19:16:12 <CosmicRay> dons: and the even stranger thing is that I didn't have the same feeling when porting Python code over.
19:16:27 <CosmicRay> dons: maybe it's because ocaml is so similar to haskell in some ways
19:16:35 <dons> things like: let x = f(); g(); h(); in 7 just scare me
19:16:53 <dons> its clearly the evil twin
19:16:53 <CosmicRay> heh
19:17:04 <CosmicRay> dons: just wait till you start using objects in ocaml.
19:17:10 <wchogg> I've tried doing the book modern compilers in ml book in Haskell, and right off the bat in chapter 1 you hit the stark differences Haskell and ML.
19:17:13 <CosmicRay> things that look like comments at first are really code.
19:17:27 <CosmicRay> wchogg: I bet.  haskell is so much nicer for compilers, imho.
19:17:30 <dons> wchogg: its a real pity we dont' have a modern compilers in haskell book yet.
19:17:33 <CosmicRay> I don't know why everyone things ocaml is.
19:17:53 <wchogg> dons:  Maybe it could be a wiki project?  Something to build a piece at a time?
19:18:16 <dons> possibly. there's an awful lot of peopel writing compilers in haskell for it to possibly work.
19:18:32 <dons> or someone could just write the book and $$ profit!
19:18:50 <wchogg> CosmicRay:  Actually at first it's just frustrating because they use impurity from the get go.
19:19:12 <CosmicRay> really, parsing in ocaml is hideous.  You have non-lazy lists, which everyone uses, but which suck for reading large amounts of data and transforming it.  Then you have streams, which are essentially like Haskell's lists, but they are poorly-supported and the only even halfway sane syntax to use with them is a camlp4 extension.
19:19:36 <CosmicRay> and then you have its fundamentally broken I/O system, which supports neither fseek() nor open files read-write out of the box.
19:19:45 <CosmicRay> that's the thing that really ticked me off about ocaml, over and over.
19:19:56 <araujo> CosmicRay, really?
19:19:59 <CosmicRay> really.
19:20:01 * araujo didn't know that
19:20:07 <wchogg> I'm still learning to let go of alot of my c++ prejudices.  It doesn't help that I've really only been programming for 1 1/2 years.  I've had to pick up *alot* fairly quickly.
19:20:09 <dons> there's always spj's tutorials on fp compiler implementation. but they're 15 years old now, and don't use type checking monads.
19:20:13 <CosmicRay> an input handle is a different type than an output handle in ocaml.
19:20:14 <dons> so a little bit obsolete.
19:20:24 <araujo> CosmicRay, how's that?
19:20:42 <CosmicRay> araujo: you have functions like open_in and open_out.  Think of it as if haskell had an InputHandle and an OutputHandle.
19:20:52 <CosmicRay> then there would be close_in and close_out.
19:20:58 <araujo> ooh.. i see now
19:20:59 <RyanT5000> wchogg be glad you're getting into haskell after 1.5 years of C++; i'm getting into it after about 7
19:21:23 <palomer> I think lyx is losing my files
19:21:31 <CosmicRay> araujo: there is no just Handle, unless you go to the unix exntension module, which is not portable to windows, and which uses a third handle type that is incompatible with all the regular handle-using code.
19:21:47 <araujo> CosmicRay, sounds messy
19:21:49 <CosmicRay> it is.
19:21:53 <wchogg> RyanT5000:  Oh probably, but I'm still getting used to alot of the fundamental ideas of programming and learning the skills.  
19:22:02 <RyanT5000> yeah
19:22:07 <araujo> CosmicRay, i looked at O'Caml time ago, thoughi never went into too much details.
19:22:28 <araujo> CosmicRay, but i did notice it's kind of a "big" language.
19:22:36 <palomer> araujo: that's the complaint I had!
19:22:39 <palomer> but noone listened to me
19:22:42 <wchogg> The thing that looked cool in o'caml was meta-o'caml, the multistage meta programming system.  I read some lectures on it that were pretty cool.
19:22:57 <CosmicRay> araujo: I dunno, its syntax seemed 70s-ish and hackish
19:23:13 <CosmicRay> wchogg: camlp4 you mean, right?
19:24:49 <wchogg> CosmicRay:  Maybe.  Let me try and find those notes I read.  I might be thinking of that and metaml and just combining them.
19:25:37 <wchogg> I mean this project: http://www.metaocaml.org/
19:25:58 <CosmicRay> ah, I have not heard of that one.
19:26:55 <Pegazus> hi, what does \[x]->x+1 means? i mean i know lambda function but what is the [] around x? list? how does it works?
19:27:43 <sjanssen_> Pegazus: it's pattern matching.  It means that x is the element in a list of length 1
19:27:57 <sjanssen_> it will fail if you pass it any other kind of list
19:27:59 <wchogg> Yeah, try it with a two element list.
19:28:12 <sjanssen_> > (\[x] -> x + 1) [2]
19:28:13 <lambdabot> 3
19:28:24 <sjanssen_> > (\[x] -> x + 1) [2, 3]
19:28:25 <lambdabot>  Non-exhaustive patterns in lambda
19:28:26 <Pegazus> can you do any kind of pattern matching on lambda expressions?
19:28:46 <Pegazus> can you use recursion on lambda expressions? what can't you do in lambda expressions that you can on normal functions?
19:29:07 <sjanssen_> Pegazus: functions translate into lambda's
19:29:21 <Pegazus> mmmm how's that sjanssen_?
19:29:49 <sjanssen_> "f x y = x + y" actually means "f = \x y -> x + y"
19:31:23 <mux> yay, I achieve doing wicked things in Haskell now
19:31:42 <mux> at least wicked to me
19:31:49 <mux> updateMany              = foldl (flip (uncurry update'))
19:32:26 <Oeje1> Hi, fellow Haskellers.  I'm a bit confused by the Haskell nsieve-bits entry over at the shootout.  It fills an array of Bool, but the specification says array of bits.  What's the connection?
19:33:18 <CosmicRay> a bool has two states.
19:33:20 <CosmicRay> so does a bit.
19:33:31 <CosmicRay> a bool can be represented by a bit, and vice-versa.
19:34:00 <dons> its a bit field in the library
19:34:14 <mux> @pl updateMany              = foldl (flip (uncurry update'))
19:34:15 <lambdabot> updateMany = foldl (flip (uncurry update'))
19:34:15 <Oeje1> Aha, neat.
19:34:18 <mux> mm
19:34:19 <dons> since Bool is the best type for a bit
19:34:20 <morans> where's the code in lambdabot that evaluates haskell code?
19:34:25 <mux> I wanted this in . notation
19:34:26 <dons> in scripts/runplugs.hs
19:34:36 <dons> morans ^^
19:34:50 <sjanssen_> so a UArray of Bool packs the bools into bytes?
19:34:50 <newsham> question: if you define a function with pattern matching and not all patterns are covered, calling the function can result in a runtime error.
19:34:59 <newsham> is there any way to ensure that this doesnt happen with static checking?
19:35:26 <audreyt> newsham: compile with -Wall ;)
19:35:30 <wchogg> newsham:  I thought that was part of what dependent types were all about?
19:35:32 <Oeje1> I'm reading over http://haskell.org/haskellwiki/Performance .  It's very educational!
19:35:36 <lispy> -Wall and -Werror
19:35:36 <audreyt> or, always supply a _ case
19:35:36 <newsham> -Wall will warn when patterns arent complete?
19:35:42 <audreyt> newsham: yeah.
19:35:46 <newsham> perfect.
19:36:04 <newsham> wchogg: dependent types?
19:36:28 <dons> sjanssen_: yeah, boosl in UArrays become bits in Words.
19:36:43 <sjanssen_> that's neat
19:36:50 <lispy> boosl? that sounds neat
19:36:59 <newsham> i need some boosl.  out of beer :(
19:37:29 <dons> here's the UArray Bool instance:
19:37:31 <dons>     unsafeAt (UArray _ _ arr#) (I# i#) =
19:37:31 <dons>         (indexWordArray# arr# (bOOL_INDEX i#) `and#` bOOL_BIT i#)
19:37:32 <Oeje1> It's great with a wiki page about arrays!  Good stuff, high quality wiki contributers!
19:37:32 <dons>         `neWord#` int2Word# 0#
19:37:50 <mux> @pl swapMap x y map         = updateMany [((map ! y), x),((map ! x), y)] map
19:37:53 <lambdabot> swapMap = flip flip id . (liftM2 updateMany .) . ap (ap . (liftM2 (:) .) . flip (flip . ((,) .) . flip (!))) (flip flip [] . ((flip . ((:) .)) .) . flip . ((,) .) . flip (!))
19:37:59 <mux> arg
19:38:11 <audreyt> too flippy
19:38:14 <mux> yes
19:38:18 <lispy> oh, does @pl understand = notation now?
19:38:24 <dons> it always did, iirc
19:38:31 <dons> @pl f x = x
19:38:32 <lambdabot> f = id
19:38:37 <audreyt> @pl f = f
19:38:38 <lambdabot> f = fix id
19:38:42 <lispy> ah, for some reason i thought you had to put everything in \x -> foo notation
19:38:52 <dons> though it goes a bit overboard with the recursive bindings, imo
19:38:58 <cyrup> Related to rewriting O'Caml literature into Haskell:  Has anyone considered porting TAPL to Tim Sheard's Omega
19:39:03 <audreyt> @pl f = f f
19:39:04 <lambdabot> f = fix (join id)
19:39:17 <audreyt> what's the monadic definition of (->) lambdabot uses?
19:39:43 <lispy> hmm...thought i could switch to x.org but i'm having no luck...now my video drivers are all hosed
19:40:26 <dons> audreyt: it often uses the a-> monad, found in Control.Monad.Reader, iirc
19:40:53 <audreyt> ah k.
19:40:57 <dons> (but it should be in Control.Monad, since its so foundationalish)
19:41:29 <audreyt> indeed
19:42:04 <Oeje1> Does GHC have an mmap()?
19:42:13 <dons> yep. its supplied by the fps librariy
19:42:16 <dons> ?where fps
19:42:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:42:38 <dons> ?type Data.FastPackedString.mmapFile
19:42:40 <lambdabot> FilePath
19:42:40 <lambdabot>             -> IO Data.FastPackedString.FastString
19:42:44 <dons> :)
19:43:03 <RyanT5000> can you pattern match against the type of a parameter?
19:43:10 <RyanT5000> or just against possible constructors of that type
19:43:28 <dons> RyanT5000: does not compute (part a). part b, yes, you can match against constructors.
19:43:41 <dons> example will be hepful
19:43:46 <Oeje1> dons: Just noticed. :-)  Sweet.  You guys never seize to amaze me.
19:44:22 <RyanT5000> well basically i want a function "composite" that turns a document into a Scene, and the document's type could be anything
19:44:47 <RyanT5000> i want it to pick a function based on the type and constructor of the document
19:45:02 <RyanT5000> in essence, C++ style overloading, which i was just bashing a few hours ago
19:45:11 <RyanT5000> however i'm totally open to better ways of doing it
19:45:40 <RyanT5000> i'll paste my current code
19:46:25 <lisppaste2> RyanT5000 pasted "Skin class" at http://paste.lisp.org/display/18846
19:46:26 <audreyt> sure you can pattern match against type of parameters using Data.Typeable
19:46:29 <audreyt> that's what it's for
19:46:34 <RyanT5000> oh
19:46:36 <RyanT5000> thanks :)
19:46:40 <RyanT5000> that's probably what i want
19:46:55 <audreyt> but! it's much saner to use typeclasses
19:47:05 <audreyt> and factor out each overloaded parts into its own method
19:47:10 <RyanT5000> k, but i'm not sure how to do that
19:47:20 <RyanT5000> i want a Skin class that can potentially take any object as input
19:47:28 <RyanT5000> and it does its own stylized rendering of that object
19:47:52 <audreyt> well, instead of 
19:47:53 <audreyt> composite :: a -> obj -> state -> Scene b
19:47:55 <audreyt> you need either
19:47:57 <audreyt> composite :: a -> obj -> state -> Scene a
19:47:58 <audreyt> or
19:48:01 <audreyt> composite :: a -> obj -> state -> Scene
19:48:03 <audreyt> or
19:48:12 <audreyt> class Skin a b | a -> b where
19:48:14 <RyanT5000> i want to overload on the type of obj
19:48:17 <audreyt>     composite :: a -> obj -> state -> Scene b
19:48:31 <audreyt> in that case you need a multiparameter class
19:48:38 <audreyt> class Composable a obj where
19:48:43 <audreyt>     composite :: a -> obj -> state -> Scene
19:48:44 <audreyt> or
19:48:47 <RyanT5000> ah ok
19:48:56 <RyanT5000> thanks :)
19:49:24 <audreyt> class Composable a obj b | a obj -> b where
19:49:28 <audreyt>     composite :: a -> obj -> state -> Scene b
19:49:29 <audreyt> etc
19:49:30 <audreyt> np :)
19:50:03 <audreyt> if you find static typechecking too painful, you can always go back to Data.Typeable and Data.Dynamic :)
19:50:09 <audreyt> there is no shame in hybrid typechecking :)
19:50:13 <RyanT5000> no actually i really wanted this to be static
19:50:18 <audreyt> cool then
19:50:24 <RyanT5000> because then i know if i forget to finish my skin implementations :)
19:50:33 <audreyt> ahh right :)
19:50:42 <audreyt> like C++, not ObjC, I see
19:50:53 <RyanT5000> which? the overloading?
19:50:56 <audreyt> yeah
19:50:58 <RyanT5000> yeah
19:51:00 <audreyt> early instead of late bound
19:51:08 <RyanT5000> yep
19:52:30 <RyanT5000> btw, does this look like a reasonably sane way to start a graphics engine?
19:52:39 <RyanT5000> i've never written one before and i would prefer minimal rewrites
19:52:46 <dons> stanamic typing, audreyt. not hybrid :)
19:53:04 <dons> at least that's what oleg says.
19:53:14 <RyanT5000> it doesn't need to be blazing fast (it's a turn based strat, not an FPS), but it does need to not totally suck
19:54:34 <wchogg> stanamic?  I like that word.  It sounds like an insult.
19:54:43 <RyanT5000> also sounds like "satanic"
19:55:08 <Oeje1> ?type Data.FastPackedString.hash
19:55:09 <lambdabot> Data.FastPackedString.FastString
19:55:09 <lambdabot>           -> Int32
19:55:19 <Oeje1> What kind of hash function is this?
19:57:34 <RyanT5000> audreyt comments on the suckiness of the basic idea of this engine?
19:58:08 <RyanT5000> (obviously not much to go on right now, but the basic thrust should be somewhat obvious)
19:58:39 <skew> looks like you are making some kind of graphics library?
19:58:45 <RyanT5000> yeah
19:58:51 <RyanT5000> basically i need to write a windowing system in 3d for a game
19:59:04 <skew> you don't like existing ones?
19:59:12 <RyanT5000> most game windowing systems, particular the free ones, suck, because most games don't use windows very heavily
19:59:28 <RyanT5000> my game is heavy on the windowing, and so i want to write that bit myself
19:59:31 <RyanT5000> also, i want to get the experience
19:59:39 <RyanT5000> and i don't like mutable variables
19:59:46 <RyanT5000> i haven't found a game engine that uses only monadic processing :P
19:59:53 <skew> Frag?
19:59:59 <RyanT5000> how's its windowing system?
20:00:03 <skew> nonexistent
20:00:09 <RyanT5000> and therein lies the problem
20:00:10 <RyanT5000> however
20:00:13 <RyanT5000> i will look at its code
20:00:17 <dons> Frag, its all FRP and arrows
20:00:18 <skew> but it's built on arrows
20:00:26 <RyanT5000> arrows are cool with me :)
20:00:29 <dons> the yampa space invaders is similar
20:00:41 <RyanT5000> @where frag
20:00:42 <lambdabot> http://www.cse.unsw.edu.au/~pls/repos/frag
20:00:44 <skew> I'm mentioning it for the control over state, not the windowing
20:00:50 <dons> ?wiki Frag
20:00:51 <lambdabot> http://www.haskell.org/haskellwiki/Frag
20:00:57 <RyanT5000> ah ok i see
20:01:04 <dons> check the research papers on functional reactive programming
20:01:05 <RyanT5000> yeah that skin thing
20:01:07 <skew> you're working over GL?
20:01:09 <dons> ?wiki Research_papers
20:01:10 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers
20:01:12 <RyanT5000> the update function is totally retarded
20:01:15 <RyanT5000> yeah i'm using OpenGL
20:01:25 <RyanT5000> i already refactored the update function :P
20:03:03 <RyanT5000> i don't think i'll get too much out of frag in terms of reuse, since my engine doesn't need maps, etc.
20:03:13 <RyanT5000> (it's essentially a board game setup)
20:03:39 <RyanT5000> are you familiar with its design though?
20:03:55 <RyanT5000> because i'd love to see how they improved on ModelViewController
20:05:47 <Pegazus> is it possible to use recurrsion in lambda functions? (on itself)?
20:06:00 <sjanssen_> @type Control.Monad.Fix.fix
20:06:01 <lambdabot> forall a. (a -> a) -> a
20:06:59 <sjanssen_> > fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) $ 6
20:07:00 <lambdabot> 720
20:07:33 <skew> are there any plans to implement impredicative polymorphism in GHC?
20:09:11 <Pegazus> sjanssen_ i didn't understood what you did...
20:09:42 <wchogg> Hrmm...I just tried frag for the first time.  I was getting 60fps on my laptop, so I'm pretty impressed.
20:10:00 <sjanssen_> Pegazus: it's a bit of an advanced example.  usually, if you want recursion, just use "let" or a top level name
20:10:19 <sjanssen_> that was the factorial function, btw
20:10:24 <Pegazus> what is let for?
20:10:30 <Pegazus> and what is fix for?
20:10:38 <Pegazus> and $ 6?
20:11:17 <sjanssen_> "let" is to give something a temporary name
20:11:56 <Pegazus> how do you use it?
20:11:56 <sjanssen_> f $ x = f x -- it's just a trick to reduce the number of parentheses you need to type
20:12:04 <sjanssen_> > let foo = 42 in foo * foo
20:12:06 <lambdabot> 1764
20:12:35 <Pegazus> does [x] in \[x]->0 stands for any list or just lists with one element?
20:12:54 <sjanssen_> one element
20:13:31 <Pegazus> ammm thanks
20:14:00 <Pegazus> zero = \[x]->0 is this valid?
20:14:22 <Pegazus> i mean, shouldn't that function take an argument?
20:14:26 <sjanssen_> that is syntactically valid
20:14:39 <int-e> > let zero = \[x] -> 0 in zero [42]
20:14:40 <lambdabot> 0
20:15:11 <Pegazus> what does "in zero [42]" means?
20:15:34 <int-e> that belongs to the let ... let <declarations> in <term>
20:16:11 <int-e> in that case, there's one declaration, zero = \[x] -> 0, and the term is zero [42] - which uses the zero function.
20:16:43 <Pegazus> ah
20:24:32 <RyanT5000> why doesn't this code work?
20:24:32 <RyanT5000> class ModelView view model where 
20:24:32 <RyanT5000>      composite :: view -> model -> Scene a 
20:24:32 <RyanT5000> data (ModelView childView model) => Rotator a = Rotator a (Vector a) childView
20:24:55 <RyanT5000> it says "Not in scope: type variable 'childView'"
20:25:06 <RyanT5000> and twice more, with 'model' and 'childView'
20:25:18 <RyanT5000> ah crap i'm retarded
20:25:20 <RyanT5000> :(
20:29:29 <Pegazus> (map ($ e) nf) is equal to ((map e) nf) isn't it?
20:30:28 <RyanT5000> > map ($ (+1)) [5, 4, 3]
20:30:30 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
20:30:30 <lambdabot>   In the list element: 3
20:30:57 <RyanT5000> er, i guess i won't be of much help :-/
20:31:35 <RyanT5000> > map ((+1) $) [5, 4, 3]
20:31:37 <lambdabot> [6,5,4]
20:31:52 <RyanT5000> ((map (+1)) [5, 4, 3])
20:31:58 <RyanT5000> > ((map (+1)) [5, 4, 3])
20:31:59 <lambdabot> [6,5,4]
20:32:04 <skew> map ($ e) nf = map (\f -> f e) nf
20:32:07 <Pegazus> so?
20:32:09 <Pegazus> mm
20:32:19 <Pegazus> what does $ does exactly?
20:32:25 <RyanT5000> i think yours is backwards Pegazus
20:32:26 <skew> f $ x = f x
20:32:36 <RyanT5000> all $ does is make it so you don't need parens
20:32:41 <Pegazus> mm
20:32:47 <skew> and something like infixr 2 ($)
20:33:28 <Pseudonym> foldr ($) id
20:33:33 <Pseudonym> That's occasionally useful.
20:33:46 <Pegazus> i still don't get it :/
20:33:54 <Quinthius>  head (tail [1,2,3]) = head $ tail [1,2,3]
20:34:03 <Pseudonym> foldr ($) id [(+1),(*2)] 4
20:34:06 <Quinthius> passes the value on the right to the function on the left
20:34:08 <Pseudonym> > foldr ($) id [(+1),(*2)] 4
20:34:09 <lambdabot>  add an instance declaration for (Num (a -> a))
20:34:26 <Pseudonym> Errr...
20:34:42 <Pseudonym> No, I'm thinking of (.).  Never mind!
20:35:12 <skew> > map ($ 2) [(+1),(*3)]
20:35:14 <lambdabot> [3,6]
20:35:35 <Quinthius> hehe cool
20:35:42 <Pseudonym> > foldr ($) 4 [(+1),(*2)]
20:35:43 <lambdabot> 9
20:35:45 <Pseudonym> > foldl ($) 4 [(+1),(*2)]
20:35:47 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
20:35:47 <lambdabot>   Expected type: (b1 -> b) -> b1 -> b1 -> b
20:35:47 <lambdabot>   Inferred type: (b1 -> b) -> b1 -> b
20:35:50 <Pseudonym> Damn.
20:36:02 <Pseudonym> > foldl (flip ($)) 4 [(+1),(*2)]
20:36:03 <lambdabot> 10
20:39:40 <palomer> ugh, my end of semester report is only 6 pages
20:39:43 <palomer> I suck at making crap up
20:40:08 <palomer> it's really, really packed with stuff though
20:40:13 <Pegazus> mmm
20:40:48 <Pegazus> what's the equivalent of this: compose n nf e = n (map ($ e) nf) with parentethiss?
20:40:50 <lisppaste2> RyanT5000 pasted "Typing error" at http://paste.lisp.org/display/18848
20:41:02 <RyanT5000> could someone give me a hand with that real quick? i'm sure it's pretty simple
20:42:34 <Quinthius> Pegazus: i'm still pretty new, and i dunno about the compose part, but the map section i think basically results in something like: nf $ e, which is equal to nf (e)
20:43:00 <Pegazus> k
20:44:14 <sjanssen_> RyanT5000: what is the defn. of Rotator ?
20:44:34 <RyanT5000> sry, forgot to paste
20:44:34 <RyanT5000> data (ModelView childView model) => Rotator a childView model = Rotator a (Vector a) childView
20:44:49 <lisppaste2> RyanT5000 annotated #18848 with "rotator" at http://paste.lisp.org/display/18848#1
20:45:28 <sjanssen_> I think your class decl. is bad
20:45:42 <RyanT5000> how so?
20:45:46 <sjanssen_> do you really mean "take a view and a model and make a scene of any type
20:45:49 <sjanssen_> ?
20:46:15 <RyanT5000> pretty much; the scene type is basically just going to be Float or Double or something
20:46:27 <RyanT5000> it's not what you'd call "important"
20:46:42 <RyanT5000> but since i didn't know what it should be, i didn't specify it
20:47:14 <RyanT5000> also, if i end up implementing an OpenGL renderer, it might want Float, whereas DirectX might want Double (i just totally made that up, but i think you know what i mean)
20:47:36 <skew> you should  check out some existing libraries
20:47:52 <sjanssen_> this kind of ultra generic thing is tough to model
20:47:57 <RyanT5000> yeah but why should i specify the datatype?
20:48:01 <sjanssen_> I think you're getting abstraction happy
20:48:08 <RyanT5000> maybe i should specify Floating a or something
20:48:20 <RyanT5000> that's true
20:48:39 <RyanT5000> but i'm more concerned right now with why i can't make it work
20:48:51 <skew> like, look at how the cairo bindings handle this stuff
20:48:53 <RyanT5000> it's my understanding of haskell not of OpenGL that i'm worrying about this for
20:51:07 <skew> you are expecting the context on data Rotator to let you use the methods of ModelView?
20:51:28 <RyanT5000> not alone
20:51:38 <sjanssen_> data class contexts are nearly useless in Haskell
20:51:47 <sjanssen_> but that's beside the point
20:52:28 <skew> you are also building up a "
20:52:31 <RyanT5000> well i basically want Rotator to be an instance of ModelView for every kind of model
20:52:39 <skew> a rotated with the same type "a" as the argument
20:52:52 <skew> but the definition of ModelView leaves "a" free
20:53:03 <RyanT5000> oh, that's not allowed?
20:53:03 <skew> so you have to end up with a type like "forall a . Scene a"
20:53:18 <RyanT5000> i can't have that get bound when i call composite?
20:53:44 <skew> composite promises that if you give it a view and model, you will get something that's a Scene a for every possible a
20:53:49 <sjanssen_> you'll also need a "ModelView childView" constraint on your instance
20:54:17 <skew> unless I'm just totally confused
20:54:23 <RyanT5000> hm
20:54:32 <sjanssen_> skew: that was what I wanted to say, but couldn't find the words
20:54:37 <skew> in any case, it doesn't say that a depends on the choice of the type view
20:54:57 <RyanT5000> it doesn't
20:55:20 <skew> ah, but in your instance it does
20:55:28 <skew> Rotated (angle 
20:55:38 <skew> Rotated (angle :: t1) ... is a Scene t1
20:55:52 <RyanT5000> oooooh
20:55:56 <RyanT5000> ok i see now, thanks
20:56:26 <skew> I'm pretty sure view should be able to determine the a
20:56:32 <RyanT5000> yeah
20:56:44 <RyanT5000> it should
20:57:00 <RyanT5000> i love it when my language understands my datatype better than i do :-/
20:57:12 <skew> then you probably need to promote it up to the class - ModelView view model a | view -> a
20:57:57 <RyanT5000> hm, but what if i later determine that i have other parameters of the type Scene?
20:58:00 <skew> the Haskell type system is actually smart enough that it's usually worth the bother of explaining stuff to it
20:58:03 <RyanT5000> do i need to keep adding things to the class?
20:58:23 <skew> if they need to be determined by the view, then probably
20:58:27 <RyanT5000> hm
20:58:42 <skew> or you could require that view take the same parameters
20:58:54 <RyanT5000> yeah, what if i rearranged them
20:58:57 <RyanT5000> and curried Rotator?
20:59:00 <skew> declare composite :: view a -> model -> Scene a
20:59:08 <skew> I think that can work
20:59:48 <skew> yeah, rotator would have to take the arguments in a different order then
21:00:00 <RyanT5000> that can happen
21:01:55 <RyanT5000> is there any way i can make sort of a data structure of types, to pass to "Scene"?
21:04:03 <RyanT5000> hey, it works
21:04:07 <RyanT5000> yay for kind annotations
21:04:21 <skew> I thought you wouldn't need one
21:04:59 <lisppaste2> RyanT5000 annotated #18848 with "Compiles" at http://paste.lisp.org/display/18848#2
21:05:37 <RyanT5000> i'm not sure if it's sane but it compiles
21:10:20 <Pegazus> can i put new lines in the middle of a haskell function?
21:10:44 <sethk> Pegazus, sure
21:10:59 <sethk> Pegazus, but it must be to the right of the function start
21:11:22 <sethk> Pegazus, if you are using the layout format (which you most likely are)
21:11:36 <sethk> foo x y =
21:11:38 <sethk>     abc
21:11:39 <sethk>     def
21:11:48 <sethk> this is the start of the next function because it is in column 1
21:14:34 <Pegazus> primRec g_base h_rec = \params -> if ((last params) == 0) then (g_base) else h_rec ParamsRecursivos ++ [primRec g_base h_rec ParamsRecursivos] where ParamsRecursivos = (init params) ++ [(last params) - 1]
21:14:41 <Pegazus> how can you format that in a "nicer" way? :p
21:14:46 <Pegazus> where can i put newlines? etc...
21:15:05 <Pegazus> and is there any way to not do need to use the tab / spacing of haskell? i hate it
21:15:20 <Girl-19> hi
21:15:28 <sethk> Pegazus, you can put them anywhere, and to not use spacing, do this:
21:15:28 <Pseudonym> G'day.
21:15:41 <sethk> Pegazus, foo whatever = { whatever; whatever; whatever }
21:15:48 <Pegazus> thanks
21:15:50 <sethk> Pegazus, similar to what you are used to in other languages
21:16:01 <Pegazus> where do i put the ; ?
21:16:12 <skew> Parsec makes some pretty good error messages on its own
21:16:16 <sethk> Pegazus, at the end of every expression that isn't followed by }
21:16:19 <Pegazus> and can i use nested braces?
21:16:21 <skew> I like it.
21:16:23 <Girl-19> is this a help channel for hackers-beginners? can I ask a question?
21:16:24 <sethk> Pegazus, and using extra ones isn't a problem
21:16:28 <Pegazus> good
21:16:29 <sethk> Pegazus, yes, nested braces
21:16:39 <sethk> Pegazus, I often use braces within one level of indentation
21:16:40 <RyanT5000> go ahead Girl-19
21:16:43 <skew> Girl-19: along with many other thing
21:17:03 <sethk> Pegazus, you need { after certain keywords, including do, where
21:17:06 <skew> Girl-19: we're happy to help people beginning
21:17:23 <sethk> Girl-19, then, when they are hooked, we charge by the hour
21:17:32 <Girl-19> well.. I have been into not actually hacking, but social engineering  
21:17:49 <Girl-19> I have stolen about 50 msn and yahoo accounts 
21:17:56 <skew> oh, that kind of hacking is not really our area
21:18:04 <araujo> 0_o
21:18:05 <skew> we mean hacking like writing programs
21:18:10 <Girl-19> and now I've made a web-site 
21:18:41 <Girl-19> I know, but I still have a question 
21:18:56 <Girl-19> I've made a web-site listing those guys I hacked 
21:18:58 <Pseudonym> You want the phone number of your local police so you can turn yourself in, right?
21:19:11 <Girl-19> lol no! wait 
21:19:54 <Girl-19> I have a web-site displaying the way I hacked those guys and had fun at their expense 
21:20:12 <RyanT5000> i think you should get to the programming question, and forgo telling us all the illegal stuff you did :)
21:20:50 <Girl-19> the question is: what if I paste the link to this web-site on a forum? 
21:21:13 <Girl-19> is it really so illegal?!   
21:21:19 <Girl-19> I'm in Moscow, Russia 
21:21:26 <Pseudonym> I have no idea about Russian law.
21:21:30 <Girl-19> nobody can catch me I guess 
21:21:37 <Girl-19> well.. I never hacked Russians 
21:21:38 <Pseudonym> I know that in Brazil it's kinda legal if you don't do any damage.
21:21:39 <skew> that is not so certain
21:21:52 <skew> it's more a question whether anybody cares to catch you
21:22:15 <RyanT5000> the real question is
21:22:22 <RyanT5000> why do you want to post your website?
21:22:33 <RyanT5000> just to brag? (i'm not anti-bragging)
21:22:37 <Pseudonym> And whether posting the information is legal or illegal, is admitting what you did such a smart idea?
21:22:39 <Girl-19> that's what I'm talking about! this web-site is only about Pakistani victim's of mine 
21:23:05 <skew> you know, russian law is not our specialty either
21:23:11 <araujo> mm...
21:23:13 <sjanssen_> Girl-19: you aren't so great at this hacking thing.  Did you know this channel is logged?
21:23:15 <RyanT5000> IANARL, so to speak
21:23:15 <Girl-19> and I want to paste it on Paki forum.. just for fun LOL 
21:23:22 <sjanssen_> did you know that your IP address is logged?
21:23:31 <Pseudonym> Look, we're all white hats here, AFAIK.
21:23:31 <RyanT5000> yeah you're pretty much on tape
21:23:34 <Girl-19> lol I'm sure it is 
21:23:49 <Pseudonym> If you want to point out security flaws in MSN and Yahoo, then that's one thing.
21:23:54 <RyanT5000> i've done black-hat stuff on my friends, but that's it (and i told them all about it, and they didn't care)
21:24:04 <sethk> skew, Pakistan is not in Russia
21:24:17 <Girl-19> well, am I supposed to be frantic with terror and anxiety?
21:24:34 <RyanT5000> not really, but it just doesn't seem smart to go around broadcasting it
21:24:34 <Pseudonym> sethk, assuming that Girl-19 is not in Pakistan, what s/he did is almost certainly covered by Russian law, not Pakistani.
21:24:50 <Girl-19> the truth is.. those paki cunts were real bastards 
21:24:51 <Pseudonym> That includes any treaties between Russia and Pakistan.
21:24:53 <sethk> Girl-19, absolutely.  even now helicopters are streaking towards your location
21:24:54 <sjanssen_> Girl-19: you should talk about this stuff somewhere else
21:24:57 <RyanT5000> well, Pseudonym, if it's like interstate american law, she could be subject to either, or both
21:24:59 <sethk> Pseudonym, true
21:25:01 <Girl-19> LOL 
21:25:16 <sjanssen_> can we get an op to kick Girl-19?
21:25:19 <Pseudonym> Interstate US law is bizarre.
21:25:26 <RyanT5000> generally you are tried in the state you committed the crime in
21:25:36 <Girl-19> it's the first time I broadcast my web-site 
21:25:42 <Girl-19> it's very decent actually 
21:25:58 <RyanT5000> i don't know whether the crime of digital trespass is based on the location of the target or the computer you use to hack it
21:26:04 <Girl-19> I've even decorated it with hearts and cupids
21:26:12 <Pseudonym> Aw, lovely.
21:26:34 <skew> did you describe how referential transparency was critical to your exploits?
21:26:41 <RyanT5000> :P
21:26:47 <Pegazus> what's wrong in primRec g_base h_rec =  \params -> if ((last params) == 0) then (g_base) else h_rec ParamsRecursivos ++ [primRec g_base h_rec ParamsRecursivos] where ParamsRecursivos = (init params) ++ [(last params) - 1]?
21:26:51 --- mode: ChanServ set +o Pseudonym
21:27:01 <skew> otherwise, sjanssen is right that you are pretty off topic...
21:27:08 <Pseudonym> Yeah.
21:27:21 <Pseudonym> We do tolerate some of that, but what you did is against the true hacker ethic.
21:27:42 <skew> Pseudonym: well, Capitalized words are reserved for type names
21:27:44 <Pseudonym> By "some of that", I refer to off-topicness.
21:28:03 <Pseudonym> skew: You mean Pegazus, right?
21:28:12 <skew> yeah
21:28:16 <Pegazus> thanks
21:28:55 <skew> I'm not sure how the types are supposed to work out there
21:28:57 <RyanT5000> while you're here, Girl-19, you should reform, change your ways, and learn programming in haskell
21:29:03 <RyanT5000> ;)
21:29:11 <Pseudonym> Haskell is very nice, and it would teach you social habits.
21:29:42 <cpatrick> It also cures world peace, prevents poverty and causes cancer
21:30:01 <Girl-19> I've always found myself unequal to the intellectual pressure of programming 
21:30:02 <Girl-19> it
21:30:08 <Girl-19> 's just over my head
21:30:13 <skew> cpatrick, that doesn't sound so good
21:30:33 <RyanT5000> cure world peace ftw
21:30:35 <cpatrick> skew :-P
21:30:45 <Pseudonym> Well, you'll never get anywhere if you don't challenge yourself.
21:30:49 <skew> preventing poverty is good, but at what price?
21:31:28 <RyanT5000> well, causing cancer isn't so good, but you could do worse things than cure world peace
21:31:48 <sethk> RyanT5000, I don't think you have to worry, it isn't going to be cured
21:32:09 <RyanT5000> it doesn't need to be, it already doesn't exist :P
21:33:02 <dons> wchogg: btw, Frag is _unoptimised_. 
21:33:12 <dons> anyone with some -prof knowledge could really crank the speed up.
21:33:18 <Korollary> @keal
21:33:19 <lambdabot> i changed my user od
21:33:24 <dons> and also, its currently _imited_ to 60 fps. you won't get higher.
21:33:35 <dons> but I guess you could up that arbitrary limit
21:33:47 <palomer> how do you imitate 60 fps?
21:34:05 <skew> isn't the time mostly in rendering anyway?
21:34:36 <wchogg> dons:  Huh.  I'm even more impressed then.  The student did a rather nice job for an "academic" language, eh?
21:34:39 <Korollary> it should be. a modern cow should be able to pull 60fps on the q3 engine
21:35:17 <dons> yeah, he did a pretty good job, he was learning haskell as he went
21:35:37 <dons> palomer, not imitate :P. "l" ++ "imited"
21:36:00 <Pegazus> Syntax error in expression (unexpected `;', possibly due to bad layout)
21:36:02 <wchogg> Wasn't frag a demonstration of his phd work, or was it his masters?
21:36:11 <Pegazus> i'm getting that error while trying to use {}
21:36:15 <dons> it was an undergrad project
21:36:22 <dons> his honours thesis.
21:36:26 <Pseudonym> Pegazus: Got an example?
21:36:32 <wchogg> You're kidding.  I thought he was a grad student working on reactive programming.
21:36:41 <dons> nope. we have undergrads for that :)
21:36:57 <wchogg> Cool.
21:37:09 <Pegazus> primRec :: NumF -> NumF -> NumF
21:37:10 <Pegazus> primRec g_base h_rec = { if 0 == 0 then g_base else h_rec; }
21:37:13 <Pegazus> how to write that properly?
21:37:40 <skew> if 0 == 0?
21:37:45 <Pegazus> i'm just trying
21:37:50 <cpatrick> Pegazus: take out the curly brackets and the semicolon
21:37:52 <Pegazus> (i needed something there)
21:37:57 <Pegazus> but i want to write it
21:38:00 <Pegazus> using multiple lines
21:38:09 <skew> semicolons separate statements
21:38:15 <cpatrick> Pegazus: let layout take care of it?
21:38:37 <skew> what's NumF?
21:38:53 <Pegazus> i don't get what you mean
21:39:01 <Pegazus> what are statements?
21:39:03 <skew> what is that type?
21:39:22 <Pegazus> a custom type of mine
21:41:03 <skew> statements are the things in a do block
21:41:21 <Pegazus> i am using pure functional
21:41:25 <skew> the { <stuff> ; <stuff> ; <stuff> } syntax also applies to the bindings in a let expression
21:41:28 <Pegazus> so i don't think i'll have statements
21:41:36 <Pegazus> i want a way to like
21:41:39 <Pegazus> if something then \n
21:41:41 <skew> otherwise, I don't think you need it
21:41:48 <Pegazus> then_part \n
21:41:52 <Pegazus> else do other thing\n
21:41:56 <cpatrick> > if something
21:41:57 <lambdabot>  parse error on input `}'
21:41:58 <cpatrick> >  then something
21:41:59 <lambdabot>  parse error on input `then'
21:42:00 <cpatrick> >  else something
21:42:01 <lambdabot>  parse error on input `else'
21:42:07 <cpatrick> shoosh lambdabot
21:42:31 <cpatrick> note that the 'then' and the 'else' have to be more indented than the 'if'
21:42:40 <RyanT5000> > if True
21:42:40 <RyanT5000>      then 5
21:42:40 <RyanT5000>      else 3
21:42:41 <lambdabot>  parse error on input `}'
21:43:24 <Pegazus> will that work Ryann?
21:43:43 <RyanT5000> yeah, it would work if it was real
21:43:52 <RyanT5000> lambdabot doesn't seem to like it though
21:44:04 <dons> ?pretty if True then 5 else 3
21:44:07 <lambdabot> "Parse error" at column 1
21:44:12 <dons> ?pretty x = if True then 5 else 3
21:44:13 <lambdabot>  x = if True then 5 else 3
21:44:17 <dons> hehe. ok.
21:45:21 <dons> ?quit new command
21:45:28 <dons> ?help girl19
21:45:46 <lambdabot> girl19 wonders what "discriminating hackers" are.
21:45:50 <dons> ?girl19
21:45:54 <lambdabot> well.. I never hacked Russians
21:46:00 <dons> i should finish my phd one day.
21:46:07 <Pseudonym> That was quick.
21:46:11 <palomer> god, I hate preparing slides
21:46:16 <palomer> that's it, I'm not becoming a professor
21:46:16 <Pseudonym> Maybe you should change your topic.
21:46:26 <cpatrick> It's just not the same quality as keal, though
21:46:28 <cpatrick> @keal
21:46:28 <lambdabot> evaluating expressions is ALL haskell does?????
21:46:31 <palomer> I'll become batman instead
21:46:34 <sjanssen_> ah, that's why Girl-19 came here
21:46:35 <morans> '
21:46:39 <dons> keal is stunning.
21:46:42 <dons> ?girl19
21:46:42 <lambdabot> am I supposed to be frantic with terror and anxiety?
21:46:49 <dons> is just fun in a kitchy way
21:46:56 <palomer> lambdabot: no, it also excellent for annoying whoever uses it
21:47:06 <Pseudonym> "Towards the Next 700 Lambdabot Plugins Considered Harmful"
21:47:10 <dons> hehe
21:47:57 <palomer> the best plugin is palomer
21:47:59 <palomer> @palomer
21:47:59 <dons> can't you squeeze "lambdabot the ultimate .. " in there?
21:47:59 <lambdabot> hrmph
21:48:17 <palomer> @palomer
21:48:18 <lambdabot> hrmph
21:48:24 <Pegazus> so how do i write? i just put enteres so?
21:48:28 <Pseudonym> I was about to say "I want a vanity plugin too", but then I realised dons might actually do it.
21:48:36 <dons> hmm...
21:48:39 * Pseudonym does not want to be responsible for dons' non-submission
21:48:47 <dons> really, I'd like @<nick> run via megamonad. for all nicks
21:48:47 <Pseudonym> So please don't.
21:49:06 <dons> or say, all nicks with more than 1000 statements
21:49:17 <Pseudonym> Except keal.
21:49:24 <Pseudonym> Less than 1000 statements, but pure gold.
21:49:25 <dons> no. it can stay verbatim
21:49:36 <Pseudonym> @lambdabot
21:49:36 <lambdabot> Unknown command, try @list
21:49:38 <Pseudonym> Recursive fun.
21:49:39 <sjanssen_> a @soundlike <nick> plugin would be way cool
21:49:51 <dons> yep. just needs megamonad, and the logs, I reckon
21:49:57 <dons> lambdabot even keeps its own logs these days.
21:49:57 <palomer> all nicks belonging to sex machines
21:50:10 <dons> palomer scares me again
21:50:18 <palomer> megamonad? is that like megaman?
21:50:40 <dons> no. it was the megamonad, god of the logs. evil brother of vixen.
21:50:49 <sjanssen_> palomer: yes, except without the megabuster
21:52:13 <wchogg> megamonad sounds intimidating in a porn-star kindof way.  Just sayin'.
21:52:29 <Pseudonym> @vixen Do you like megamonad?
21:52:30 <lambdabot> yeah, i like
21:53:05 <wchogg> What does vixen do, in principle?
21:53:22 <Pseudonym> @vixen who are you?
21:53:23 <lambdabot> i'm just me :)
21:53:35 <Pseudonym> Vixen is like eliza, only jailbait.
21:53:46 <wchogg> ...
21:53:55 <Pseudonym> @vixen Where do you live?
21:53:55 <lambdabot> i do occassionally, i guess
21:54:01 <Pseudonym> Errr...
21:54:08 <wchogg> That's an awesome answer.
21:54:12 <RyanT5000> lol
21:54:42 <jcreigh> wchogg: Yeah, well, the Turing test almost says more about the tester than the testee.
21:55:06 <cpatrick> @vixen What do you think of monads?
21:55:06 <lambdabot> maybe. do you?
21:55:20 <wchogg> Given that maybe is a monad, that almost made sense.
22:08:13 <Pegazus> can someone explain me why this works: compose:: NumF -> [NumF] -> NumF
22:08:15 <Pegazus> compose n nf e = n (map ($ e) nf)
22:08:26 <Pegazus> (type NumF = [Int]->Int)
22:12:07 <Korollary> @type \n nf e -> n (map ($ e) nf)
22:12:08 <lambdabot> forall t a b.
22:12:08 <lambdabot>            ([b] -> t) -> [a -> b] -> a -> t
22:13:02 <Pegazus> but it takes 3 arguments
22:13:16 <Pegazus> n nf and e
22:13:19 <Pegazus> and the signature just 2
22:13:41 <int-e> Pegazus: the signature is equivalent to NumF -> [NumF] -> [Int] -> Int
22:13:47 <Pegazus> mmm
22:13:52 <Pegazus> you are right
22:13:54 <Pegazus> :)
22:14:00 <Pegazus> that solves a mistery
22:14:12 <Pegazus> thanks you int e
22:15:55 <Pegazus> how would you write (map ($ e) nf) but without using $?
22:16:17 <int-e> ($ e) = \x -> x $ e = \x -> x e
22:19:12 <Pegazus> so?
22:19:25 <Pegazus> is (map ($ e) nf) equal to ((map e) nf) ?
22:19:41 <Pegazus> or (map (e nf)) or what?
22:20:34 <int-e> no.
22:21:04 <int-e> ($ e) is a function that applies a given function to e.
22:23:36 <Pegazus> k
22:43:32 <araujo> h0la tic 
22:44:53 <RyanT5000> is there a mod function for doubles?
22:44:58 <RyanT5000> er, Floatings?
22:46:26 <araujo> @index mod
22:46:26 <lambdabot> Prelude
22:46:34 <araujo> > mod 4.0
22:46:34 <lambdabot>  add an instance declaration for (Show (a -> a))
22:46:37 <RyanT5000> :t mod
22:46:40 <RyanT5000> @type mod
22:46:42 <lambdabot> forall a. (Integral a) => a -> a -> a
22:47:06 <araujo> > mod 4 3
22:47:07 <lambdabot> 1
22:47:23 <RyanT5000> > mod 50 pi
22:47:24 <lambdabot> Add a type signature
22:47:31 <RyanT5000> > mod (50 :: Double) pi
22:47:32 <lambdabot>  add an instance declaration for (Integral Double)
22:47:32 <lambdabot>   In the definition of `gmk': gmk = mod (50 :: Double) pi
22:47:32 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
22:48:08 <RyanT5000> oh well i don't really need it
22:48:25 <RyanT5000> OpenGL does it for me
22:48:31 <RyanT5000> but i lose precision as time goes by
22:48:59 <RyanT5000> i could just do if value > 2*pi then value-2*pi else value
22:49:24 <int-e> > let fmod a b = a - fromIntegral (truncate (a/b)) * b in fmod 100 pi
22:49:25 <lambdabot> 2.610627738716417
22:49:43 <Pegazus> i'm getting the error Program error: pattern match failure: zero_v1573 []
22:49:48 <RyanT5000> thanks int-e
22:49:49 <Pegazus> how to find what caused it?
22:50:29 <sjanssen> I'm guessing your program doesn't have a function called "zero_v1573" ?
22:50:33 <int-e> Pegazus: it means that you used the zero function with an empty list - it only works for single-element lists if it's the one you mentioned above
22:50:38 <Pegazus> it does not
22:50:48 <Pegazus> thanks int e
22:51:04 <int-e> sjanssen: it's a lambda expression
22:51:26 <sjanssen> ah, that explains the nasty error
22:51:56 <Pegazus> is there any way to tell hugs
22:52:00 <Pegazus> to show the reductions it is doing?
22:52:02 <Pegazus> one by one?
22:52:04 <palomer> zero_v1573 is my favourite combinator, far superior to zero_v1572
22:52:13 <Pegazus> (because it's giving the error with a high level thing)
22:52:18 <palomer> Pegazus: you need hat for that, pat
22:52:32 <Pegazus> hat?
22:52:57 <palomer> true dat
22:55:05 <Pegazus> true dat?
22:55:09 <Pegazus> what the hell is that?
22:55:40 <RyanT5000> lol
22:55:46 <RyanT5000> hat is a haskell debugging tool
22:55:51 <palomer> you killed a running rhyme
22:55:52 <RyanT5000> i don't know what he meant by pat
22:55:58 <RyanT5000> and "true dat" means "that's right"
22:56:02 <palomer> pat is short for patrick
22:56:08 <RyanT5000> yeah i know that
22:56:16 <palomer> contrary to popular belief, lol does not rhyme with that
22:56:27 <RyanT5000> :(
22:56:44 <RyanT5000> tbh i didn't even notice that "that" was still rhyming
22:57:12 <RyanT5000> and i was feeling sorry for the potentially non-english-slang-speaking among us
22:57:20 <palomer> http://www.encyclopediadramatica.com/index.php/Lollerskates
22:58:17 <palomer> I love you guys, have I ever said that?
22:58:58 <newsham> hi
22:59:25 <Pegazus> any easy to use debugger for windows?
22:59:29 <Pegazus> preferable to use with hugs?
22:59:37 <Pegazus> (winhugs)
23:00:32 <RyanT5000> real men debug with printfs
23:01:55 <Pegazus> i want to debug a reduction
23:02:43 <RyanT5000> i'm kidding
23:04:15 <Pegazus> so wich debugger do you recommend me for windows?
23:04:24 <RyanT5000> i haven't gotten set up on one yet
23:04:31 <RyanT5000> so far ghci has been sufficient
23:04:33 <Pegazus> anyone that is easy to install and use
23:04:48 <RyanT5000> did you try HAT?
23:04:53 <RyanT5000> that's the one i found when i was searching for one
23:04:55 <Pegazus> HAt isn't for windows i think
23:05:05 <RyanT5000> i thought it was written in haskell...
23:05:29 <Pegazus> a Haskell'98 compiler that supports the standard FFI (i.e. nhc98 or ghc) 
23:05:29 <Pegazus> the hmake compilation manager 
23:05:29 <Pegazus> GNU make 
23:05:29 <Pegazus> a C compiler (usually gcc) 
23:05:29 <Pegazus> at least 128Mb of memory (256Mb with ghc -O) 
23:05:30 <Pegazus> disk space: 30Mb (nhc98), 50Mb (ghc)
23:05:51 <Pegazus> how to debug in ghci?
23:05:59 <RyanT5000> break your expression down
23:06:01 <RyanT5000> see what it says
23:06:06 <RyanT5000> i.e.: try each part of it
23:06:10 <RyanT5000> make sure that part works
23:06:20 <Pegazus> but i want the debugger to do that for me
23:06:20 <Pegazus> :)
23:06:35 <RyanT5000> yah me too, but i'm not the person to ask, cause i haven't bothered yet :)
23:07:10 <sjanssen> I don't think many people use Haskell debuggers
23:07:28 <Pegazus> :(
23:07:49 <ValarQ> better to write correct programs the first time :)
23:08:25 <newsham> http://haskell.org/haskellwiki/Libraries_and_tools/Program_development#Tracing_.26_debugging
23:08:46 <newsham> QuickCheck might be useful
23:19:09 <mwc> heyyyyyyyyyyyyyyyy
23:24:16 <blackdog> am getting this error on linking:
23:24:18 <blackdog> /usr/local/lib/ghc-6.4/libHSbase.a: could not read symbols: Memory exhausted
23:25:17 <blackdog> don mentioned something about EXTRA_CC_OPTS, but adding the arguments he mentioned to -optl and -optc didn't hel at all.
23:25:22 <blackdog> any ideas?
23:25:47 <vincenz_> someone call for me?
23:26:13 <vincenz> dons: ping?
23:26:15 <vincenz> @seen dons
23:26:16 <lambdabot> dons is in #haskell. I last heard dons speak 1 hour, 35 minutes and 34 seconds ago, but .
23:26:17 <Pseudonym> Sure, who do you want me to call?
23:26:22 <vincenz> dons: you called?
23:26:27 --- mode: Pseudonym set -o Pseudonym
23:26:55 <vincenz> s/call/called
23:27:01 <Pseudonym> Ah.
23:27:19 <vincenz> dons left?
23:27:27 <newsham> @seen anything
23:27:27 <lambdabot> I haven't seen anything.
23:27:39 <sethk> blackdog, first question is, could you in fact be running out of memory?
23:27:53 <vincenz> > hello newsham
23:27:54 <lambdabot>  Not in scope: `newsham'
23:27:59 <blackdog> it seems unlikely...
23:28:37 <vincenz> holy cow elections are hot in italy
23:28:38 <blackdog> the machine has 3 gigs
23:28:54 <blackdog> with 10g of swap :)
23:28:54 <vincenz> 0.7 % difference in lower house, and everything is still viable in senate and congress
23:30:06 <mwc> Nero Lives!
23:30:08 <vincenz> 49.81% vs 49.74%  
23:30:15 <vincenz> o.O
23:30:21 <vincenz> I always wonder why such figures never add up to 100
23:30:25 <flux__> vincenz, which one's ahead?
23:30:29 <RyanT5000> there are other candidates
23:30:31 <vincenz> flux__: prodi by .7%
23:30:38 <blackdog> doesn't the party in power own the TV stations?
23:30:39 <RyanT5000> (?)
23:30:53 <vincenz> flux__: but he could lose in senate or congress (can't remember) which basically means that there's a draw (congress and senate have equal power), meaning reelections
23:30:56 <flux__> maybe a small amount of the votes are blank or otherwise nonqualifying
23:30:58 <vincenz> but jesus.... 0.6%
23:31:01 <vincenz> I mean 7
23:31:03 <vincenz> that's SMALL
23:31:28 <mwc> Yeah, really
23:31:30 <vincenz> > 0.7 /100 * 70000000
23:31:31 <lambdabot> 489999.99999999994
23:31:41 <vincenz> hmm
23:31:43 <mwc> does that actually correspond to a seat?
23:32:01 <sethk> just don't get your money's worth these days when you buy votes
23:32:18 <vincenz> anyone know the population size of italy?
23:32:37 <flux__> cia factbook on web does?
23:32:43 <vincenz> > 58103033 * 0.7/100
23:32:44 <lambdabot> 406721.2309999999
23:33:04 <mwc> sethk, doesn't matter. they'll be like any old italian men: make passes at women 40 years younger than them and otherwise live it up
23:33:22 <sethk> :)
23:33:23 <vincenz> hey now
23:33:26 <vincenz> mwc: it's the reverse!
23:33:34 <vincenz> I heard tales of these termes, where old people would relax
23:33:45 <vincenz> and you'd have these 20-30 year old young women pass by them and prance
23:34:02 <vincenz> the old powerfulman icon is very sexy in italy
23:34:12 <vincenz> don't ask me why, but Im retiring there :D
23:34:16 <mwc> hahahah
23:34:27 <mwc> nice. all you need is some power to abuse
23:34:52 <vincenz> not like the rest of europe who has settled in what is basically becoming the retirement home of europe
23:35:25 <mwc> Hmmm, that's Italy's fault. It went and became a south-eastern peninsula to western europe
23:35:29 <mwc> basically, it's your florida
23:35:34 <vincenz> I think spain is the retirement home of europe
23:35:37 <vincenz> mwc: I meant spain
23:35:47 <mwc> I have a suspicion that old people are drawn south and eastward
23:35:53 <vincenz> spain is known for a lot of elderly immigration
23:36:22 <vincenz> but yeah the east will be soon too
23:36:28 <vincenz> like croatia or so
23:36:34 <mwc> you're kidding?
23:36:35 <vincenz> south, at the sea, and cheap
23:36:51 <mwc> I understood croatia to be somewhat... volatile
23:36:52 <sethk> spain is on the other side of that mediteranean thing (or however you spell it)
23:37:04 <vincenz> sethk: straight of gibraltar?
23:37:06 <mwc> sethk, you mean Gibraltar?
23:37:18 <vincenz> sethk: us'er?
23:37:25 <sethk> no, vincenz said italy then said he meant spain
23:37:32 <vincenz> sethk: no
23:37:32 <sethk> so I was pointing out that he got the wrong side of the ocean
23:37:36 <vincenz> sethk: I said I want to settle in italy
23:37:41 <vincenz> UNLIKE the rest who settles... in spain
23:37:47 <sethk> vincenz, good food in Northern italy
23:37:53 <vincenz> sethk: mediterranean sea, it['s not an ocean
23:37:59 <vincenz> sethk: I know my parents live there
23:38:20 <mwc> sethk, Straight of Gibraltar separates the Mediterranean Sea (literally: Middle-Earth Sea!) from the atlantic proper
23:38:30 <vincenz> mwc: he meant the name of the sea itself
23:38:33 <mwc> ahh
23:38:34 <mwc> ok
23:38:39 <vincenz> but!
23:38:48 <vincenz> it's on the other side of the ... let me remember the name
23:38:51 <vincenz> not adriatic but...grr
23:38:57 <mwc> blackdog, I believe there's a way to increase the stack size of a haskell prog
23:39:29 <blackdog> i don't think that's the problem. I'm not blowing the haskell stack, it's happening when ld is called
23:39:31 <mwc> off hand, try adding +RTS -K 16000000 -RTS to your GHC invocation?
23:39:38 <mwc> gnu ld?
23:39:50 <blackdog> yeah
23:39:54 <vincenz> tyrenean sea!
23:39:57 <RyanT5000> does anyone know how to integrate freeglut with Graphics.UI.GLUT?
23:40:23 <mwc> I think you just need to build the GLUT libs to link against whatever glut you want
23:40:33 <RyanT5000> :(
23:40:47 <RyanT5000> i've had a hell of a time trying to build GHC
23:40:53 <RyanT5000> also, it takes forever
23:41:01 <mwc> yes, it's barely fun on linux
23:41:06 <RyanT5000> oh well i'll work on it tomorrow
23:41:09 <RyanT5000> or never
23:41:11 <RyanT5000> probably never
23:41:21 <mwc> RyanT5000, I have many projects like that
23:41:29 <RyanT5000> yep
23:41:56 <RyanT5000> it's just annoying because, for instance, Graphics.UI.GLUT.closeCallback doesn't work on non-freeglut
23:42:24 <RyanT5000> otoh, i'm not actually going to keep glut for my final implementation anyway
23:42:36 <RyanT5000> i'm abstracting away all its IO stuff and everything
23:44:00 <Pegazus> waef
23:44:01 <Pegazus> wef
23:44:11 <sethk> wef waef?
23:44:23 <RyanT5000> sounds like Blue Man Group
23:44:23 <blackdog> think slowly and hit one key after the other.
23:45:48 <sethk> actually, he said waef wef, not wef waef
