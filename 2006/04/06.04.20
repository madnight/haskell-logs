00:12:26 <davidmccabe> Good night and thanks again everybody.
00:25:35 <lispy> dons: grr...i just replied to you and the list but i forgot to change the "send-from" address so i bounced off the list
00:25:51 <lispy> oh well, keep up the good work
00:25:59 * lispy goes to sleep
00:26:28 <robokop> @hoogle Maybe a -> Bool
00:26:29 <lambdabot> Maybe.isJust :: Maybe a -> Bool
00:26:29 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
00:29:59 <Muad_Dibber> morning
00:36:58 <newsham> is there anything between .hs and -ddump-stg ?
00:37:42 <Lemmih> -ddump-rn -ddump-cmm -ddump-ds?
00:37:57 <Lemmih> -ddump-simpl
00:38:22 <newsham> hmm.. why -ddump-cmm isnt in the user guide?
00:38:22 <Lemmih> Oh wait, cmm comes after stg.
00:39:27 <newsham> is ds before stg?  it looks pretty bizarre :)
00:40:21 <Lemmih> hs -> rn -> ds -> stg -> cmm -> {C|asm|bytecode}, iirc.
00:40:53 <Lemmih> (tc is done together with rn)
00:41:16 <Muad_Dibber> dons? are the results of your 1G Strings benchmarking in yet?
00:42:13 <robokop> @hoogle IO (a) -> IO ()
00:42:14 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
00:42:14 <lambdabot> Foreign.C.Error.throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
00:42:14 <lambdabot> Foreign.C.Error.throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
00:53:42 <dons> Muad_Dibber: yep, here: http://www.cse.unsw.edu.au/~dons/code/fps/README
00:53:47 <dons> scroll to the bottom
00:53:54 <dons> (I also posted to haskell-cafe@ )
00:54:55 <Muad_Dibber> (I'm not subscribed to any haskell mailing list)
00:55:16 <dons> well, then you're missing out! :)
00:56:22 <Muad_Dibber> Surely I am :)
00:58:15 <musasabi> morning
01:22:12 <musasabi> dons: good work on fps :-)
01:23:36 <musasabi> dons: Actually the Word8 vs Char is not a major issue for many apps. As it is often enough to split things by ascii chars and check things for equivalence. Thus one does not really care whether something is multibyte character or not.
01:47:25 <norpan> are there any plans to typeclassify strings?
01:59:30 <dons> musasabi: yeah, I agree. I just don't want to offend the unicode acolytes :)
02:18:54 <robokop> when i have (in wxHaskell) a dialog window with tho buttons how can i set that both buttons will close it (like a ok and a cancel button)
02:42:12 <araujo> morning!
02:47:47 <unicron> good morning
02:52:24 <robokop> when i have (in wxHaskell) a dialog window with tho buttons how can i set that both buttons will close it (like a ok and a cancel button)
02:55:19 <goldie22> hey whats a good website for like the basic haskell syntax?
02:57:00 <Muad_Dibber> goldie22, http://www.haskell.org/haskellwiki/Learning look there
02:57:12 <goldie22> cheers
02:57:58 <Muad_Dibber> Are you learning, or just want a reference?
02:58:42 <NameTab> robokop: set buttons [on command := close framethebuttonsarein]
02:58:44 <NameTab> ?
03:00:19 <robokop> nameTab it isn't a frame but a dialog and dialog is not closable
03:01:06 <robokop> maybe i should just rewite my code so it is a frame
03:01:20 <NameTab> oh right, misread your question
03:01:56 <NameTab> I'm really bad @ wxHaskell *sigh* :P
03:05:21 <NameTab> btw, is it possible to login @ school through ssh? anybody of UU? 
03:06:04 <Muad_Dibber> Yes it is
03:06:07 <Muad_Dibber> If you set your keys that is
03:22:59 <Ulfalizer> what's wrong with this? it's supposed to be a general function for finding the maximum value in a tree, http://rafb.net/paste/results/kHvNh249.html
03:23:59 <int-e> minBound :: a <-- this a is a new, fresh type variable
03:24:16 <int-e> leave out the :: a and let the type checker derive the type for you.
03:24:53 <Ulfalizer> ok, but is there some way to refer to the a in the function declaration?
03:25:16 <int-e> maxTree (Nil :: Tree a) = minBound :: a   probably works, too.
03:25:38 <Ulfalizer> ok
03:25:54 <int-e> there's no way to refer to the signature, as far as I know. It's completely separate from the function definition.
03:31:36 <vincenz> there is no need for minBound :: a
03:31:42 <vincenz> maxTree knows he's returning a
03:31:45 <vincenz> otoh
03:31:49 <vincenz> a should be Bounded
03:32:12 <vincenz> which it is
03:33:31 <norpan> just remove the :: a
03:33:34 <norpan> and you will be fine
03:33:40 <vincenz> indeed
03:33:56 <vincenz> > minBound :: Char
03:33:57 <lambdabot> '\NUL'
03:34:00 <vincenz> hmm
03:34:06 <vincenz> > ord '\SOH!
03:34:07 <lambdabot>  lexical error in string/character literal
03:34:07 <vincenz> > ord '\SOH'
03:34:09 <lambdabot> 1
03:34:57 <Ulfalizer> vincenz: yeah, i just wanted to see how much i could tell the type checker myself to check up on my understanding
03:38:19 <NameTab> why do I get a segmentation fault if I start a main function from ghci, close it and run it again?
03:42:27 <dons> NameTab: very strange. are you on a funny operating system? what version of ghci?
03:44:17 <NameTab> gentoo, 6.4.1
03:48:55 <vincenz> anyone used daan's server?
03:49:07 <Lemmih> NameTab: Got kinky with unsafeCoerce#, eh?
03:49:42 <NameTab> not that I know of ...
04:09:06 <vincenz> Lemmih: ping
04:14:25 <vincenz> any darcss users around?
04:14:56 <Jerub> yeah
04:15:02 <Jerub> there's also #darcs
04:15:23 <vincenz> thx
04:15:53 <Jerub> shapr: :)
04:15:57 <robokop> hmm ghci sux with wx haskell (for me it does)
04:16:18 <shapr> yow!
04:16:28 <shapr> hey Jerub, ltns... wassup?
04:16:41 <shapr> I just saw the massive channel spam in the logs.
04:16:53 <shapr> How many people here are not identified to nickserv?
04:17:02 <davidhouse> we're still +R?
04:17:16 <shapr> yup
04:17:41 <NameTab> somebody else who uses the same code as I do doens't get this segmentation fault (on winxp I think)
04:17:47 <NameTab> what can it be? :/
04:17:50 <Jerub> shapr: darcs has me mewing like a kitten. it is so awesome.
04:18:11 <shapr> Jerub: yup it roxx :-)
04:18:52 <Jerub> shapr: I heard about it ages ago and I was like, "a VCS in haskell? how quaint"
04:19:24 <shapr> The decentralization of darcs totally kicks butt.
04:19:28 <Jerub> yeah
04:19:28 <shapr> But there's more!
04:19:42 <davidhouse> NameTab: what code?
04:19:44 <shapr> Have you seen Daan Leijen's darcs-server?
04:20:06 <robokop> NameTab: i have the same problem here with ghci, i can only run one time a gui function, after that a seg fault
04:20:07 <NameTab> davidhouse: a very small useless piece of code
04:20:15 <NameTab> robokop: yes, exactly
04:20:35 <shapr> Anyway, darcs can be used exclusively via http, and does not require creating user accounts for committers.
04:20:54 <NameTab> it isn't a lot of trouble, but its more trouble
04:20:56 <robokop> NameTab: i now just compile it with ghc and run the prog and well not much a problem now
04:21:04 <Muad_Dibber> what has Daan written then shapr ?
04:21:10 <Jerub> shapr: no, I haven't.
04:21:17 <Muad_Dibber> A standalone version that doesn't need a "real" webserver?
04:21:22 <shapr> Here's darcs-server http://www.equational.org/darcs-server/
04:21:27 <Jerub> shapr: is it useful? 'darcs send' has me in a tiz already.
04:21:30 <shapr> Nah, it's a cgi-program.
04:21:52 <Muad_Dibber> aah
04:22:10 <shapr> Jerub: yeah, but that requires that the server and client both have email configured correctly. Since darcs already includes libcurl bindings, the pure http approach is extrasmooth.
04:22:13 <Jerub> right, I see. removes the need for shell accounts.
04:22:23 <Jerub> yeah, makes lotsa sense.
04:22:32 <robokop> NameTab: what wm do you use
04:22:52 <shapr> Also, since every checkout is a full repo, you can save your changes, fork easily for exploring new approaches, and do all this on a disconnected laptop on a plane.
04:23:11 <NameTab> robokop: xfce4
04:23:45 --- mode: ChanServ set +o shapr
04:23:51 <Jerub> shapr: yeah, the multiple commits to local repo rocks. having done both svn and darcs recently (turbogears, sqlobject are svn, twill is darcs) being able to commit changes is so extracool.
04:23:52 --- mode: shapr set -R
04:23:59 <robokop> NameTab: maybe try gtk because it is a gtk program you use
04:24:01 <Jerub> shapr: I hate preparing patches where I've made multiple changes to a repo.
04:24:09 <Jerub> so much work.
04:24:22 <robokop> NameTab: *gnome
04:24:32 <shapr> Yeah, I agree. It's worst with CVS though, since you can't turn an anon CVS repo into a logged in repo.
04:24:36 <Jerub> shapr: so, darcs-client, that's something extra to install, right?
04:24:43 <Jerub> sure you can
04:24:48 <Jerub> just requires find / sed
04:25:10 <shapr> That's true... easy to screw up though.
04:25:12 <NameTab> robokop: I don't use gnome :)
04:25:16 <NameTab> fluxbox has it too btw
04:25:27 <robokop> NameTab: kde too 
04:25:35 <NameTab> gentoo?
04:25:42 <robokop> NameTab: and i don't use gnome too
04:25:49 <robokop> NameTab: nu ubuntu dapper
04:25:54 <NameTab> ahh k
04:25:58 <NameTab> very strange
04:26:03 <Jerub> shapr: darcs-client doesn't come with darcs does it? and requires configuration?
04:26:10 <shapr> No, darcs-client doesn't come with darcs.
04:26:11 <NameTab> strange :(
04:26:38 <Jerub> shapr: I'd probably prefer people do 'darcs send -a -o here_you_go_mr_jerub_sir.patch' and email me that .patch as an attachment.
04:26:55 <robokop> NameTab: do you get som X errors when running the app you made
04:27:07 <Jerub> shapr: I guess darcs-server makes lots of sense for when you want to set people up with traditional style commit access.
04:28:04 <NameTab> robokop: not that I know of
04:28:11 <NameTab> well, using ghc will work too I guess
04:28:22 <robokop> NameTab: for me it does
04:28:26 <shapr> Yeah, if you want to approve patches, email is nice.
04:28:37 <NameTab> a.out is always the standard output isnt it?
04:28:59 <vincenz> shapr: I have decided in the ened the easiest solution is one shs account with multiple public keys
04:29:05 <vincenz> ssh even
04:29:41 <Jerub> you mean multiple keys in ~/.ssh/authorized_keys?
04:29:45 <vincenz> indeed
04:29:53 <Lemmih> vincenz: pong
04:30:15 <shapr> vincenz: I can dig it.
04:30:25 <vincenz> shapr: easiest solution
04:30:42 <robokop> NameTab: yes and with -o <your name here> you have another output file
04:30:44 <vincenz> hmm
04:30:53 <vincenz> now how to figure out to make ssh use the proper key
04:31:00 <vincenz> Host oasis.yi.org Port 2222 IdentityFile $HOME/.ssh/id_darcs
04:31:15 <Jerub> vincenz: multiple lines, I'm assuming.
04:31:20 <vincenz> Jerub: yep
04:31:26 <vincenz> but that doesn't do it for me
04:31:27 <Jerub> maybe ~ instead of $HOME
04:31:30 <vincenz> it still asks my password
04:31:34 <vincenz> Jerub: I used fullpath now
04:31:36 <Jerub> use -vvv
04:31:37 <vincenz> still asks password
04:32:10 <shapr> Are you using ssh-agent?
04:32:14 <vincenz> nope
04:32:15 * shapr checks the simple stuff first...
04:32:16 <vincenz> hmm
04:32:18 <vincenz> it does send the key
04:32:24 <shapr> I use keychain
04:32:29 <Jerub> vincenz: check permissions in authorized_keys
04:32:39 <Jerub> chmod 700 ~/.ssh; chmod 600 ~/.ssh/authorized_keys
04:32:40 <vincenz> Jerub: I just copied my pub key
04:32:52 <shapr> Yeah, it has to be go-rw doesn't it?
04:33:05 <shapr> hei ohub
04:33:12 <ohub> hello
04:33:15 <Jerub> yeah, otherwise ssh will say, "whoops, you're insecure, I'm not even going to read those"
04:33:19 <shapr> hyv‰‰ huomenta
04:33:23 <Jerub> that happened with my .procmailrc once.
04:33:27 <Jerub> that was ... vexxing.
04:33:42 <vincenz> Jerub: odd
04:33:45 <vincenz> it does send the pub key
04:33:46 <vincenz> err
04:33:47 <vincenz> key
04:33:55 <Jerub> vincenz: also, check logs on the server
04:34:44 <vincenz> Jerub: do you know where exactly?
04:34:55 <Jerub> different depending on the operating system.
04:35:05 <vincenz> linux/ubuntu
04:35:07 <Jerub> check /var/log/auth.log /var/log/secure.log etc
04:35:52 <Jerub> yaay. I finally have the first revision of a subdirectory of a cvs module completely imported into darcs.
04:35:53 <vincenz> odd
04:35:59 <Jerub> :p
04:36:18 <Jerub> and make sure the permissions are correct. see above for my chmod commands.
04:36:51 <vincenz> Jerub: done
04:37:23 <vincenz> it's funky cause it owrks for my other user
04:37:34 <vincenz> Jerub: mind if I pm?
04:37:48 <shapr> I guess charles stewart doesn't show up here?
04:38:00 * vincenz bows to the @
04:38:14 <mauke> @shapr
04:38:15 * lambdabot slaps
04:38:15 <Jerub> hm? no, keep talking in channel.
04:38:15 <vincenz> Jerub: or join #oasis otherwise?
04:38:16 <Jerub> :)
04:38:21 <mauke> haha
04:38:22 <vincenz> Jerub: just don't want to spam people
04:38:24 <Jerub> or #darcs
04:38:24 <shapr> hiya mauke 
04:38:33 <vincenz> Jerub: #oasis is the channel of our icfp team ;)
04:38:33 <shapr> or #haskell-overflow
04:38:41 <mauke> @shapr mauke
04:38:42 <lambdabot> why on earth would I slap mauke
04:38:48 <vincenz> that's what this account is being made for
04:38:49 <shapr> @shapr shapr
04:38:50 <lambdabot> why on earth would I slap shapr
04:38:59 <shapr> It's tough love, that's why!
04:39:00 <vincenz> @shapr @shapr
04:39:01 <lambdabot> why on earth would I slap @shapr
04:39:01 <Jerub> hey, when's icfp?
04:39:04 <shapr> aanyway...
04:39:05 <vincenz> end of july
04:39:11 <Jerub> okay.
04:39:50 <vincenz> ok
04:39:54 <vincenz> so my host has two dyndns names
04:39:57 <vincenz> I'm on my laptop
04:39:58 <vincenz> and have this in config
04:40:04 <vincenz> http://rafb.net/paste/results/8RH2DI20.html
04:40:08 <vincenz> it uses the correct identity
04:40:15 <vincenz> when I just do ssh vincenz@abstractoasis...
04:40:16 <vincenz> it works fine
04:40:20 <vincenz> cause it has an auth key
04:40:26 <vincenz> then I try ssh icfp@oasis.yi.org
04:40:29 <vincenz> where I put the new identiy
04:40:31 <vincenz> and it asks for pw
04:40:36 <shapr> Is there any direct connection between dialectic logic and either of intuitionistic logic or classical propositional logic?
04:41:08 <shapr> I have this crazy idea, you see...
04:41:16 <alar> IMHO classical logic is stricter than intuitionistic one
04:41:39 <alar> so classical domain is subdomain of intuitionistic
04:42:09 <alar> and what's dialectic logic?
04:42:50 <shapr> I'm actually trying to figure out if there's some possibility of a formal connection between the Curry-Howard correspondenc and Teoriya Resheniya Izobretatelskikh Zadatch.
04:43:36 <vincenz> DOH
04:43:37 <shapr> I guess my question is really whether some of the principles of TRIZ could be applied to a system like Burstall & Darlington.
04:43:40 <vincenz> Jerub: I think I figured it out
04:44:08 <bolrod> moin
04:44:22 <shapr> hoi bolrod 
04:44:23 <alar> what is TRIZ? never heard of something useful with this name
04:44:31 <shapr> alar: http://en.wikipedia.org/wiki/TRIZ
04:44:35 <vincenz> Jerub: wrong public key
04:45:03 <shapr> alar: I'm wondering if there's some possible connection here - http://www.linearity.org/cas/thesis/
04:45:09 <Jerub> I both love and hate having an incredibly fast internet link.
04:45:22 <Jerub> I hate it because I have a 10gig/month quota
04:45:51 <shapr> I have a flat rate and a DSL modem that's stuck at 256k.
04:47:09 <bolrod> O_o
04:47:11 <bolrod> wow!
04:47:37 <Jerub> shapr: I'm on 8mbit/128kbit
04:47:43 <bolrod> EH!?!?!?!?!
04:48:02 <bolrod> holy crap!   thats just enough upload to actually download at 8mbit
04:48:39 * bolrod is happy with 5Mbit/1Mbit with FUP quota
04:48:53 <shapr> alar: I'm convinced that the extension of the curry-howard correspondence will allow some mental tools to be 'ported' from philosophical proofs to 'computer science' and vice versa. So I wonder what tools might be ported, and if there are other fields where tools might be available for stealing.
04:49:06 <shapr> hoi doaitse, hoe gaat het met jou?
04:50:17 <vincenz> Alright
04:50:22 <vincenz> techical details are updated
04:50:26 <vincenz> anyone care to test
04:51:01 <doaitse> marking exams ;-}
04:51:47 * alar doesn't think TRIZ is of any use to anyone
04:51:57 <shapr> alar: Why so?
04:52:29 <alar> there are no strict methods. just sparse words
04:52:45 <Jerub> I like richard feynmans problem solving algorith.
04:52:46 <Jerub> m
04:52:50 <shapr> Hm, true.
04:52:55 <shapr> Jerub: Yeah, don't we all :-P
04:53:09 * alar agrees that Curry-Howard isomorphism can somewhat be extended from CS to RL
04:54:10 <shapr> I just wonder if there are other formalisms that can be mapped onto the CH iso and thus allow problem solving strategies to be spread.
04:55:44 <tromp> TRIZ doesn't strike me as a formalism
04:55:58 <shapr> It's not... as alar just pointed out.
04:56:26 <shapr> I was just wondering if it could be formalized on top of dialectic logic, and then connected to CH.
04:56:34 <shapr> But it sounds unlikely...
04:56:43 <alar> funny that today I have come to similar thought: what methods of proof are used in maths (calculus, logic,etc)? Sillogism and induction come to mind first and they map onto CH pretty well, what about the others?
04:59:24 <shapr> Seems to me that methods of proof and compiler optimizations are obviously the same thing.
04:59:56 <shapr> But I wonder if compiler optimizations have been explicitly examined with the purpose of improving solution searches by proof assistants?
05:00:01 <shapr> Anyway, unicycle time... bbl
05:00:06 <Muad_Dibber> hf shapr 
05:00:55 <bolrod> cycling aye...  good plan...  I'll start next week again :D
05:01:29 <bolrod> woah!   its getting warmer :D
05:01:49 <Muad_Dibber> I once said I'd bicycle to uni before I graduated..doubt if i'm going to make it though.
05:02:18 <RHE123> Muad_Dibber: how much kilometers? :)
05:03:24 <alar> shapr: I'm convinced they have not
05:04:20 <Muad_Dibber> Just about 70 I guess
05:04:30 <bolrod> thats one way ?
05:04:35 <RHE123> hmm, that's a lot
05:04:38 <vincenz> my professor does like 210 km on a day
05:04:46 <vincenz> and he's thin as a nail
05:04:57 <bolrod> haha.. dang.. I still want to do that :). My max is about 110 / day now
05:05:08 <vincenz> and he's not particularly young
05:05:11 <vincenz> must be around 45 or so
05:06:19 <Paltas> vincenz, hmm.. 210 kilometers is kinda mad.. :) 17 is enough for me. :)
05:06:59 <RHE123> for me it's about 16km, so when it's good weather i will give it a try :)
05:07:01 <bolrod> 210 is ALOT...  150 is quite ok though I guess.. nice weather.. some food .. stop once for drinks
05:08:04 <Paltas> bolrod, and maybe scanning for some open wifi access points ;)
05:08:20 <alar> 210 km/day? seems you unicyclists are twice faster than bicyclists
05:08:24 <bolrod> you wouldn't have time for that if you want to make it back before dark
05:08:52 <bolrod> (at least.. if you start at the time I would start cycling)
05:09:17 <zahnrad> Hello! I'm experimenting with Peano numbers at the type-level. Is it possible to define a function ordinaryint2peano :: (Peano a) => Integer -> a? I tried (several times), but failed. See http://rafb.net/paste/results/tl2aqL27.html for more context. Thank you very much! :)
05:10:02 <alar> zahnrad: that's dynamic typing
05:10:28 <alar> it won't work without hacks such as Typeable.coerce
05:10:37 <vincenz> Paltas: yeah well he leaves like in the morning, only takes some powerbars and water with him and he goes until like 11pm
05:11:46 <bolrod> man your rear hurts after that time :p
05:11:52 <Paltas> vincenz, Kinda mad! 
05:12:10 <Paltas> But definately healfy. :)
05:12:18 <bolrod> bwah.. you know whats mad?.. cycling 200 km within 6 hours ;/
05:12:29 <bolrod> like they do in the Tour de France
05:12:31 <zahnrad> alar: Ah, ok, thanks. That's what I suspected. (FYI, exercise 2 of http://www.ittc.ku.edu/~kimmell/notes/beginningfakingit.pdf (page 3) wants me to define that...)
05:12:34 <bolrod> with mountains and all
05:12:34 <Paltas> Yeah but 210 kilometers in one day.. 
05:12:45 <Paltas> if you're not a professionel.
05:12:52 <Paltas> and it's even a computer science professor?
05:13:17 <Muad_Dibber> Does he have his laptop mounted on it so he can work things out while cycling? :)
05:13:50 <bolrod> you can't actually think about difficult things while cycling... ;p
05:14:15 <tromp> 210 is doable, but preferably on a recumbent
05:14:15 <yaarg> sure you can
05:14:26 <bolrod> then you're not cycling fast enough
05:14:29 <bolrod> haha ;)
05:14:34 <yaarg> believe me i've nearly been hit by a car many a time
05:14:55 <vincenz> tromp: this was in spain
05:14:57 <vincenz> tromp: in madrid
05:15:02 <vincenz> tromp: during the summer
05:15:10 <vincenz> well may..
05:15:17 <vincenz> and not a recumbnet
05:16:58 <zahnrad> Next question :) I've read (quite often), that Haskell missed lambda at the type-level. How would "lambda at the type-level" look like? What are the things I can't do without lambda at the type-level? Thanks! :) (Links to articles very much appreciated.)
05:23:09 <xerox> @seen dons
05:23:10 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 40 minutes and 41 seconds ago.
05:24:54 <robokop> > log $ exp 1
05:24:55 <lambdabot> 1.0
05:25:04 <}ElectrowolF{> :)
05:27:09 <amiddelk> zahnrad: you can see a type synonym as a non-anonymous version of a lambda at the type level
05:28:40 <eivuokko> Uhm, it lacks the often-used ability of named functions : recursion.
05:31:40 <zahnrad> <not really grokking>Couldn't the Y combinator (allowing anonymous recursion) be implemented at the type level, thus fixing this limitation?
05:32:28 <eivuokko> Yes, but there's been (more or less) an objective to keep haskelll typesystem...ehm what's the word..so it finishes.
05:32:58 <NameTab> doaitse: make it something beautiful :]
05:34:38 <zahnrad> eivuokko: You mean, that typechecking always halts? There are already cases where the typechecking does not terminate, eg. http://www.haskell.org/haskellwiki/Type_arithmetic (last example)
05:36:10 <eivuokko> That uses glasgow-exts
05:37:53 <eivuokko> I'm not expert and I can't spot which extension is the problem in that case.
05:38:18 <eivuokko> But multi-param typeclasses and function dependencies aren't haskell 98.
05:38:46 <eivuokko> There's plenty of discussion about those in haskell-prime mailing list :)
05:38:58 <zahnrad> Ah. Makes sense.
05:38:59 <zahnrad> :)
05:39:09 <eivuokko> Probably easiest is to go and dig haskell weekly news that have links to those haskell-rpime threads
05:39:20 <eivuokko> Warning: not for the weak of heart.
05:39:33 <eivuokko> It's slightly complex stuff ;)
05:39:50 <zahnrad> Yeah, guessed so ;)
05:40:34 <eivuokko> Mhm, haskell-prime trac might also help, dunno, I haven't read it, I just browsed those threads.
05:40:56 <alar> zahnrad: maybe you can express your type-coercion fn with singleton types?
05:41:58 <alar> e.g. class Peanoable a where
05:41:58 <alar> get:: Int-> a
05:41:58 <alar> intsance Peanoable Zero where get 0 = Zero, etc.
05:42:31 <alar> but I don't understand how this can trick typechecker
05:42:45 <alar> to guess the result type of dynamic Int
05:43:12 <zahnrad> eivuokko: Thanks much for the pointer to HWN, didn't know about it before :)
05:43:16 <vincenz> alar: try ?
05:43:54 <alar> vincenz: what? dynamic typing? IMHO f::Int-> Peano is impossible
05:44:00 <alar> without unsafe
05:45:48 <kzm> Any good example of passing strings to FFI'ed C functions?
05:45:56 <vincenz> alar: no
05:46:16 <kzm> I can't seem to get it to work...printf("%s") in the C code emits garbage.  
05:46:23 <kzm> Probably something trivial...but
05:46:45 <eivuokko> zahnrad, Np, but aren't you subscribed to the haskell mailing lists?
05:47:34 <eivuokko> printf is ellipsis function...how can you ffi that?
05:47:42 <zahnrad> eivuokko: I read those via gmane, but not regularly.
05:49:06 <ibid> i don't think you can, at least not portably
05:49:18 <eivuokko> Yeah
05:50:15 <eivuokko> It seems likely to me it breaks when normal functions might use registers, but ellipsis in practice probably uses jsut stack.
05:50:26 <kzm> eivuokko, I didn't ffi printf, but I inserted printfs in the C code FFIed to.
05:50:46 * alar has just finished reading "Why dependent types matter"
05:50:57 <kzm> I.e. my haskell code calles count(string) via ffi, and count(s){printf("%s",s;...}
05:51:07 <neologism> alar: where can I get that?
05:51:10 <eivuokko> kzm, Ah.
05:51:22 <alar> www.e-pig.org
05:51:24 <kzm> ..and that printf only prints nonsense.
05:51:32 <alar> under "research papers"
05:52:01 <eivuokko> kzm, Well, I know I have used some of the marshalling functions in Foreign succesfully.  Dunno anything else about that.
05:52:22 <ibid> kzm: you need to use CString in the foreign import, iirc
05:53:06 <eivuokko> Hmh.  I have have had either CString or CWString in ffi import, and used withCString or withCWSTring (or the forwarders in win32 package)
05:56:42 <kzm> ibid: that's what I do.
05:57:50 <kzm> The C function takes *uchar, and is imported as CString.
05:58:01 <ibid> *uchar is not a valid C type
05:58:07 <ibid> you mean uchar*?
05:58:13 <ibid> how is uchar defined?
05:58:13 <kzm> I use withCString(Len, to be exact), and pass it the CString.
05:58:15 <kzm> SOrry.
05:58:16 <kzm> Yes
05:59:22 <kzm> typedef unsigned char uchar;
06:00:34 <ibid> ok, that should not break it then
06:01:39 <kzm> I thought perhaps I was missing one level of indirection somewhere (i.e. replace CString with Ptr CString or something) but I don't get it to make much sense.
06:03:25 <dozer_> where would I look for information about how the haskell compilers work?
06:03:46 <ibid> dozer_: on what level? usage instructions or behind the hood?
06:03:48 <dozer_> in particular, what the intermediate representations look like and how that is turned into native code?
06:04:29 <vincenz> for some reason I can't run lambdabot in background process
06:04:37 <dozer_> ibid: I'm sereously considering writing a JVM haskell interpreter/jit/compiler but would prefer not to start from scratch
06:04:45 <ibid> dozer_: ok, then you'd have to read the code. some compilers have also papers that discuss parts of that
06:05:25 <ibid> dozer_: for a primer on functional language compilation, look for simon peyton jones's (out of print) book on the topic. it should be on the web somewhere
06:06:50 <kzm> Damn.  I just typed up a quick hack to check, and it works beautifully.
06:07:04 * kzm will try some more.
06:07:12 <ibid> dozer_: the ghc site links to articles on intermediate formats used (or used to be used?) by ghc. you'll need the background from the book to understand it, probably
06:07:31 <ibid> dozer_: does that help?
06:07:54 <dozer_> ibid: yeah - looks like that simon guy has loads of interesting papers & stuff
06:07:59 <ibid> yeah
06:08:32 <dozer_> I realy need to visit ms research again some time - they have loads of good people in that one building in cambridge
06:18:09 * dcoutts is back from .it
06:18:23 <xerox> DUNCAN!
06:18:30 <dcoutts> xerox, did you get to vote?
06:18:39 <xerox> Man, I got some pleasant news for you :-)
06:18:45 <dcoutts> oh yeah?
06:18:48 <xerox> Heh, yeah.
06:19:59 <kzm> Hmm...isn't withCStringLen supposed to produce NULL-terminated strings?
06:21:17 <Lemmih> Hey dcoutts!
06:21:23 <dcoutts> hia Lemmih 
06:24:21 <__phas> Hi dcoutts!!
06:24:34 <__phas> wellcome back
06:24:35 <dcoutts> hia
06:24:36 <dcoutts> ta
06:25:45 <vincenz> dcoutts: hi!
06:25:59 <vincenz> dcoutts: http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
06:26:02 * dcoutts says hia to all of #haskell
06:26:20 <xerox> Welcome back! (-:
06:26:41 <dcoutts> vincenz, cool
06:26:45 <musasabi> nice to have you back :-)
06:26:51 <dcoutts> vincenz, good luck for this year
06:27:20 <vincenz> thx
06:28:01 <dcoutts> Lemmih, musasabi, I hear from xerox that you're mentoring for this year's SOC
06:28:14 * xerox jumps all excited
06:28:40 <dcoutts> I think it's a great idea
06:28:54 <dcoutts> and good publicity for haskell.org
06:29:00 <vincenz> I agree
06:32:56 <xerox> :-)
06:33:08 <Lemmih> Yeah, it's gonna be great.
06:41:17 <DeliQ> @seen Phyx
06:41:18 <lambdabot> I haven't seen Phyx.
06:41:30 <vincenz> DeliQ: @seen is crosschannel
06:41:47 <davidhouse> @seen davidhouse
06:41:47 <lambdabot> You are in #haskell. I last heard you speak just now.
06:41:53 <davidhouse> clever bot.
06:42:12 <vincenz> davidhouse: repo is up
06:42:34 <davidhouse> vincenz: url?
06:42:34 <DeliQ> vincenz: sorry, didn't know :P
06:43:06 <vincenz> davidhouse: details are in technical details ;)
06:43:11 <vincenz> DeliQ: no worries
06:43:18 <shapr> Ya know, when I just cannot stomach another token's worth of commercial programming, I go write it in Haskell and make that code talk to whatever my client wants to use for a server.
06:43:51 <dcoutts> shapr, can you sell that to the client?
06:44:21 <vincenz> shapr: haskell is ubiquitous
06:44:31 <shapr> It's funny, my clients want to dictate the language and framework I use, but none of them actually know this language and/or framework.
06:44:52 <vincenz> shapr: who does maintenance?
06:44:56 <shapr> Me
06:45:01 <vincenz> then wtf do they care
06:45:12 <dcoutts> they think they care
06:45:16 <Muad_Dibber> vincenz, if they break the contract with shapr  :)
06:45:18 <ProfTeggy> shapr, that's probably all about "warm fuzzy feelings"
06:45:21 <dozer_> vincenz: the feeling of power and security they get from believinng they can swap the monkeys
06:45:33 <shapr> Yeah, monkey swapping is high in their list of priorities.
06:45:40 <ProfTeggy> dozer, exactly
06:46:26 <dons> ah yes, monkey swapping.
06:46:34 <vincenz> shapr: my suggestion, write a haskell->mostcommonmonkeylanaguage
06:46:37 <vincenz> dons: !
06:46:44 <vincenz> dons: I have seen hmp3 crash and hang until I kill -9 it
06:46:57 <dons> yes, you said.
06:47:00 <vincenz> I did?
06:47:02 <dons> but then no further details?
06:47:05 <vincenz> no no, when it is running
06:47:05 <shapr> This is the same client who tells me to do the twenty minute hack instead of the multihour real fix, and then later complain when small changes become time intensive.. (since they require doing the 'real fix' as well as implementing the new feature(s)).
06:47:05 <xerox> dons!
06:47:09 <dozer_> vincenz: yeah - I need haskell -> jvm
06:47:16 <dons> vincenz: is it repeatable?
06:47:22 <xerox> dons: did you get my email?  I think I messed up the "To:" part.
06:47:25 <vincenz> dons: it plays songs... and then I guess some illegal mp3... it gives an error about hSomething...
06:47:28 * shapr hugs dons 
06:47:32 <vincenz> dons: at that time it completely hangs
06:47:43 * astecp wants to open a franchise enterprise development business called mcjava
06:47:44 <dons> xerox, doesn't look like i got anything.
06:47:54 <shapr> dozer_: Haskell jvmbridge already exists.
06:47:59 <dons> vincenz: can you work out how to reproduce it exactly?
06:48:09 <xerox> dons: okay, a sec.
06:48:15 <vincenz> dons: he....2800 songs
06:48:19 <dons> that would really help. sounds like a thread might throw an exception an exit, but the res of the app then blocks.
06:48:21 <vincenz> dons: gonna take a while to find the one that caused it
06:48:31 <dozer_> shapr: yeah - doesn't seem to do quite what I want though
06:48:44 <dons> vincenz: ok. let me know when you do, so I can try to repeat here.
06:48:47 <dozer_> shapr: it looked like it didn't do both-way call-backs
06:48:48 <vincenz> willdo
06:49:16 <musasabi> grah @ web formats and escaping. "this element should contain escaped html", "this one raw html", "this element may not contain whitespace", "no we won't provide a real DTD". Why do we insist on semi human and machine readable formats that neither one can handle very well :-(
06:49:41 <shapr> musasabi: Seen microformats?
06:49:45 <xerox> dons: sent!
06:50:29 <dons> got it xerox.
06:50:39 <xerox> dons: great, tell me what you think.
06:51:03 <vincenz> shapr: send me your pubkey by mail?
06:51:18 <dons> ok. its late now. can I send my reply in the morning? i.e. about 10 hours or so.
06:51:34 <dons> it looks good though. i might have some comments.
06:51:54 <xerox> dons: sure, no problem :-)
06:52:04 <xerox> dons: I mailed them, Isaac reviewed it last night
06:52:13 <xerox> dons: SPJ is out until tomorrow, tho
06:52:19 <dons> ok.
06:52:34 <dons> sorry, who did you mail?
06:52:45 <dons> who "them" ?
06:52:49 <dons> SPJ already?
06:54:03 <musasabi> shapr: yes, seem to contain all kinds of exceptions and optimizations "if this attribute is not present it takes the default from that attribute except if ..." as well.
06:54:37 <xerox> dons: SPJ and Peterson
06:54:50 <dons> ah, any reply?
06:54:55 <vincenz> dons: also often getting Junk at the beginning 49443303  at bottom in red, for all mp3s
06:55:12 <dons> vincenz: for all mp3s eh? hmm
06:55:17 <dons> you using mpg321 ?
06:55:19 <dons> or mpg123
06:55:21 <vincenz> 123
06:55:27 <dons> ah, use mpg321 !
06:55:30 <dons> its much much more stable
06:55:46 <vincenz> will do
06:55:52 <vincenz> how do I tell it to use that?
06:55:55 <dons> I'm almost certain then that your problems are from mpg123
06:56:01 <xerox> dons: no reply yet, apart the SPJ's auto-response
06:56:19 <Igloo> dons: Ah, if you're using inputs that small then Haskell code starts to win (presumably because of FFI call overheads). IIRC it's larger inputs where C shows a x2 speed advantage
06:56:39 <dons> vincenz: ah, have to check. I think you need to rebuild.
06:56:45 * vincenz nods
06:56:49 * mux uses mplayer to read mp3s in the console
06:57:03 <dons> Igloo: that sounds about right.
06:57:27 <dons> on the really big strings , the Haskell was around 1.8 x or so.
06:58:23 <Igloo> OK, that makes more sense then
06:58:40 <dons> Igloo: for the particular C fns, like dropspace and friends, i'd suspect they usually only need to search very small amounts forward. so switching back to haskell as i've done should inpact noone
06:59:08 <dons> I doubt there's anyone using dropSpace on 100M's of whitespace :)
07:00:47 <dons> Igloo, if you look here, there's only a tiny amount of C code left: http://www.cse.unsw.edu.au/~dons/code/fps/cbits/fpstring.c
07:01:11 <dons> just sort, intersperse and reverse. which get hammered fairly hard.
07:01:14 <dons> (maybe not sort)
07:02:13 <dons> night all!
07:02:23 <Muad_Dibber> night doaitse 
07:02:24 <Muad_Dibber> err
07:02:26 <Muad_Dibber> night dons
07:04:57 <shapr> g'nite dons 
07:05:03 <bolrod> :)  gnite dons 
07:05:03 <vincenz> dons: night
07:05:58 <Lemmih> @time dons 
07:06:01 <lambdabot> Local time for dons is Fri Apr 21 00:06:55 2006
07:06:09 <vincenz> @time me
07:06:15 <bolrod> Thu Apr 20 16:05:54 CEST 2006
07:06:31 <bolrod> ;)
07:12:42 <pirroH> Hi
07:12:47 <xerox> Yow!
07:13:07 <pirroH> xerox: :)
07:15:47 <mauke> @type ( . ) ( . )
07:15:48 <lambdabot> forall b c a a1.
07:15:48 <lambdabot>      (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
07:16:52 <davidhouse> (.) (.) (+) 1 (-2) 3
07:16:54 * resiak wonders why lambdabot used a1 not d
07:16:57 <davidhouse> > (.) (.) (+) 1 (-2) 3
07:16:58 <lambdabot>  add an instance declaration for (Num (a -> b))
07:17:12 <davidhouse> > ((.) (.)) (+) 1 (-2) 3
07:17:13 <lambdabot>  add an instance declaration for (Num (a -> b))
07:17:45 <musasabi> davidhouse: you can /msg lambdabot too.
07:17:49 <mauke> > (.) (.) (+) 1 (2-) 3
07:17:50 <lambdabot> 0
07:17:58 <davidhouse> > (-2) 3
07:17:59 <lambdabot>  add an instance declaration for (Num (t -> a))
07:18:10 <davidhouse> oh, right.
07:18:16 <davidhouse> @type (-2)
07:18:18 <franka> Hi, musasabi.
07:18:18 <lambdabot> forall a. (Num a) => a
07:18:25 <davidhouse> it's actually negative two.
07:18:30 <davidhouse> > ((.) (.)) (+) 1 (subtract 2) 3
07:18:32 <lambdabot> 2
07:19:50 <bolrod> you can leave lambdabot alone too....  ;)
07:20:35 <bolrod> :x
07:21:43 <kpreid_> davidhouse: yesterday you said "i thought it might be possible to do swap = uncurry . flip curry"
07:21:46 <kpreid_> davidhouse: how about "uncurry $ flip $ curry id"
07:22:06 <Cale> > ((.) (.)) (\x y -> concat ["(", x, " + ", y, ")"]) "1" (\x -> concat ["(", x, " - 2)"]) "3"
07:22:07 <lambdabot> "(1 + (3 - 2))"
07:22:25 <vincenz> Cale: the repo is up
07:22:33 <Cale> which one?
07:22:35 <vincenz> icfp one
07:22:40 <Cale> okay
07:22:49 <Cale> sounds good
07:22:52 <vincenz> adding test programs so everyone has the proper libs
07:32:48 <DeliQ> does the bot also have a function to warn you when a specific person joins ?
07:33:40 <xerox> Cale: you should write some combinator to get the expression out like that!
07:34:06 <vincenz>  stop playing with ((.) (.))
07:34:37 <dcoutts> xerox, your proposal looks fine, send it!
07:34:46 <dcoutts> xerox, and CC some of the rest of us
07:37:16 <DeliQ> @type (( . ) ( . ))
07:37:17 <lambdabot> forall b c a a1.
07:37:17 <lambdabot>       (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
07:45:31 <ihope> So when writing to an IRC connection, will LineBuffer do what I want?
07:50:12 <ihope> @docs System.IO
07:50:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
07:54:16 <ihope> @index withSocketsDo
07:54:17 <lambdabot> Network.Socket, Network
07:57:14 <davidhouse> @where cairo
07:57:15 <lambdabot> http://haskell.org/gtk2hs/
08:13:07 <ihope> @hoogle IO Handle
08:13:08 <lambdabot> System.Console.Readline.getInStream :: IO Handle
08:13:08 <lambdabot> System.Console.Readline.getOutStream :: IO Handle
08:13:08 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
08:35:44 <liyang> Pondering: the composition of two monad transformers is another monad transformer, right?
08:36:22 <Lemmih> Hey SyntaxNinja.
08:38:48 <tromp> sort of
08:41:11 <liyang> So is it just the Haskell syntax prohibiting me from writing this as an instance of MonadTrans?
08:42:06 <tromp> you need a proper type to make it an instance
08:42:20 <liyang> okay, that too. :(
08:42:30 <tromp> i mean a class
08:44:49 <Philippa_> you'll most likely have one. Although then you'll have fun with overlapping instances
08:45:12 <Philippa_> OuterTrans m a vs OuterTrans (InnerTrans m) a
08:45:27 <SyntaxNinja> heya Lemmih
08:47:57 <bolrod> what about putting instances in a different file, so you can hide them ?
08:48:22 <bolrod> hm.. maybe thats not possible
08:51:46 <ihope> No instance hiding.
08:52:30 <vincenz> instances are like big dirty secrets, can't hide em
08:54:49 <Lemmih> SyntaxNinja: Would it be difficult to install a new trac wiki for Haskell's SoC?
08:57:13 <ihope> @babel es en casi no
08:57:15 <lambdabot>  almost no
08:59:58 <Philippa_> what does make sense is to equate instances with ML-style modules
09:00:22 <Philippa_> Manuel Chakravarty et al have a draft paper about that
09:00:36 <Philippa_> (and I'd been playing with the same idea before I saw it, but hey)
09:02:01 <vincenz> it doesn't to me, you can only have one instance, you can have multiple modules implementing one interface
09:02:28 <vincenz> .../type
09:06:52 <SyntaxNinja> bah, does C have something like System.cmd.system? :)
09:07:03 <vincenz> C doesn't
09:07:05 <vincenz> posix does
09:07:16 <SyntaxNinja> posix is fine w/ me
09:07:25 <mauke> C has system()
09:07:29 <SyntaxNinja> why is shapr ops
09:07:29 <vincenz> mauke: no it doesn't
09:07:42 <vincenz> mauke: posix has system()
09:07:43 <mauke> vincenz: sure it does
09:08:13 <vincenz> mauke: that's not C it's posix
09:08:13 <SyntaxNinja> oh, maybe I wasn't actually managing to recompile this
09:08:32 <mauke> vincenz: ISO 9899:1999 - 7.20.4.6 The system function
09:09:26 * vincenz boggles
09:11:06 <NameTab> I've got this examplecode using wxHaskell with "caption", but caption is not in scope, what do I need to get caption working? That of course *isn't* in the example 
09:12:10 <bolrod> which example?
09:12:24 <NameTab> 7.4 in the book
09:12:28 <NameTab> layoutDemo
09:12:37 <bolrod> book is old
09:12:39 <bolrod> don't look at it
09:12:41 <SyntaxNinja> NameTab: do you have access to this: http://wxhaskell.sourceforge.net/doc/
09:12:50 <SyntaxNinja> although I don't see anything called caption in there
09:12:54 <vincenz> mauke: no wonder c is such a cruddy language, they try to target too many things at once
09:13:06 <bolrod> same as 'label'   changed to 'staticText'
09:13:08 <vincenz> mauke: system and getenv and all that has no meaning on many platforms supporting c
09:13:09 <bolrod> and some other things
09:13:21 <NameTab> SyntaxNinja: of course I have, but bolrod is probably right, guess that's why I couldn't find it :)
09:13:23 <xerox> Yow.
09:13:27 <mauke> vincenz: yeah, their descriptions are pretty vague
09:13:37 <bolrod> Yow. xerox 
09:13:38 <integral> I thought the C standard had provision for embedded platforms, ie without libc (called something like "freestanding")
09:13:55 <SyntaxNinja> NameTab: well, if you click on the index, then click on 'c', you'll see there's no such thing as caption.
09:14:22 <xerox> SyntaxNinja: hey there!
09:14:32 <SyntaxNinja> hiya xerox
09:14:46 <xerox> SyntaxNinja: http://groups.google.com/group/Summer-Discuss-2006/browse_thread/thread/28d3ece6861de524/1e1f00b5bfc5d560#1e1f00b5bfc5d560
09:14:51 <SyntaxNinja> now the next question is why the heck my call to system seems to have no effect.
09:14:57 <xerox> This doesn't look good, might we have to hurry up? :-(
09:15:41 <SyntaxNinja> xerox: got replies from anyone?
09:15:51 <SyntaxNinja> xerox: I'll reply to that email...
09:15:51 <xerox> SyntaxNinja: just checking
09:15:59 <xerox> Nope.
09:17:41 --- mode: shapr set +o SyntaxNinja
09:17:56 --- mode: shapr set -o shapr
09:24:00 <bolrod> xerox: who's 'we'
09:24:02 <bolrod> ;0
09:24:22 <SyntaxNinja> why am I ops?
09:24:23 <SyntaxNinja> ;)
09:27:05 <vincenz> to kick people
09:27:40 <Lemmih> bolrod: We're we.
09:27:52 <bolrod> ok
09:28:01 --- kick: vincenz was kicked by SyntaxNinja (SyntaxNinja)
09:28:06 <bolrod> nice shot
09:28:27 <xerox> haha.
09:28:33 <SyntaxNinja> I hope he comes back
09:28:47 <Philippa_> you can always /invite?
09:29:14 <bolrod> :)
09:29:25 <bolrod> maybe he has auto join on invite on
09:29:41 <bolrod> then you can /invite vincenz #stupidChannel possibly? ;)
09:29:54 <arjanoosting> SyntaxNinja: will I be kicked if I ask when you are going to upload the new package of DrIFT? :-D
09:30:04 <SyntaxNinja> vincenz:  whew
09:30:11 * vincenz grumbles
09:30:19 <vincenz> @slap SyntaxNinja 
09:30:19 <oasisbot> why on earth would I slap SyntaxNinja
09:30:20 * lambdabot smacks SyntaxNinja  about with a large trout
09:30:20 <SyntaxNinja> arjanoosting: no. I'll get to it asap.
09:30:34 <vincenz> oasisbot: I'm your owner, do as told
09:30:37 <SyntaxNinja> sorry vincenz, couldn't resist.   shapr should take the power away from me
09:30:43 <vincenz> :D
09:30:55 <bolrod> @id Just (I'm just better)
09:30:56 <lambdabot> Just (I'm just better)
09:30:57 <vincenz> SyntaxNinja: you competing in icfp?
09:31:00 <bolrod> oh..
09:31:13 <SyntaxNinja> vincenz: nah, no time.
09:31:19 <SyntaxNinja> I've already got too many projects
09:31:25 <vincenz> SyntaxNinja: got a site?
09:31:47 <SyntaxNinja> vincenz: are you going to hax0r me in retaliation?
09:31:51 <vincenz> erm
09:31:51 <vincenz> no
09:31:56 <vincenz> I was curious in what you're researching in
09:32:31 * Lemmih heads to bed. 'Night all.
09:32:38 <SyntaxNinja> vincenz: I'm not a researcher, but i'm leading the Haskell' process and the Cabal projects, as well as doing Debian work and now I just released a filesystem.
09:32:42 <SyntaxNinja> www.syntaxpolice.org
09:32:51 <xerox> Goodnight Lemmih!
09:32:53 * davidhouse installs gtk2hs
09:32:59 <vincenz> davidhouse: woo
09:33:25 <SyntaxNinja> the blog has the latest: http://blog.syntaxpolice.org/
09:33:30 <xerox> davidhouse: nice going.
09:33:49 * davidhouse wonders why he's getting congratulated for installing a library :S
09:33:56 * davidhouse shuts up and accepts the praise :)
09:34:03 <vincenz> davidhouse: xerox wrote it
09:34:06 * davidhouse will stop talking in the third person eventually.
09:34:19 <vincenz> Isaac Jones.. I've seen that name before
09:34:32 <xerox> arjanoosting: new package of DriFT, as in, cabal-get package?
09:34:35 <davidhouse> xerox, you did? nice :)
09:34:43 <xerox> davidhouse: did what?
09:34:58 <davidhouse> <vincenz> davidhouse: xerox wrote it
09:35:18 <xerox> That's right if with 'it' you mean the cairo bindings and the integration bits into Gtk2 :-)
09:35:52 <vincenz> xerox: learn how to handwave better
09:35:57 <xerox> Gtk2Hs is huge.  And the buildsystem is dcoutts' top-level hackery, he's the only who knows the archane secrets.
09:36:03 * xerox waves to vincenz 
09:36:08 <dcoutts> heh
09:36:20 <vincenz> xerox: not like that
09:36:32 <davidhouse> @where cairo
09:36:33 <lambdabot> http://haskell.org/gtk2hs/
09:36:55 <davidhouse> "Optional support for cairo requires cairo 1.0 or later" from that site. so where do i get cairo?
09:37:10 <dcoutts> your distro should have it
09:37:27 <davidhouse> we'll see.
09:37:33 <SyntaxNinja> vincenz: that's gratifying ;)
09:37:34 <arjanoosting> xerox: new Debian package of version 2.2.0, so more as in apt-get DrIFT
09:38:04 <vincenz> SyntaxNinja: gratifying?
09:38:42 <SyntaxNinja> (09:33:58) vincenz: Isaac Jones.. I've seen that name before
09:38:45 <vincenz> oh
09:38:50 <vincenz> yeah must be the mailing list
09:39:03 <vincenz> SyntaxNinja: in case you fear me hacking your site, here is my stie
09:39:06 <vincenz> http://notvincenz.com
09:39:26 * vincenz autogratifies
09:39:40 <Philippa_> eww. Take that to #haskell-blah!
09:39:48 * SyntaxNinja haxors
09:40:07 <SyntaxNinja> Philippa_: I thought this was myspace
09:40:32 <Philippa_> lilo might beg to differ?
09:43:17 <davidhouse> grr. my current repo setup on yast doesn't have gtk2.8
09:43:58 <davidhouse> thankfully i just found a repo that does have it :)
09:44:20 <davidhouse> i'm going to have to repeat all this on saturday. ah well.
09:52:00 <NameTab> what can be a cause of a segmentation fault? 
09:52:32 <ulfdoz> hardly everything.
09:52:49 <dozer_> NameTab: in haskell or in c?
09:52:52 <NameTab> haskell
09:53:18 <SyntaxNinja> NameTab: c
09:53:19 <SyntaxNinja> ;)
09:53:28 <NameTab> SyntaxNinja: what c?
09:53:34 <earthy> that is: FFI, or compilation bugs
09:53:44 <NameTab> FFI?
09:53:51 <earthy> foreign function interface
09:54:00 <earthy> that is: bindings to libraries written in other languages
09:54:02 <vincenz> @pl \x -> x - 1
09:54:02 <lambdabot> subtract 1
09:54:25 <NameTab> ahh, well, wxHaskell uses c++ doesn't it/
09:54:27 <davidhouse> > 3 `subtract` 1 -- NEVER use subtract infix.
09:54:29 <lambdabot> -2
09:54:35 <earthy> nametab: no, not directly
09:54:44 <earthy> it links to a C++ library through a C layer
09:55:02 <NameTab> well, I still find it very strange that when I add the line 
09:55:04 <NameTab> set f [layout := column 5 [halignLeft $ widget ok]]
09:55:10 <NameTab> it doesn't crash
09:55:32 <NameTab> but when I add the layout part to the next set f (there's no use of having two set f's, though I have that now)
09:55:35 <NameTab> it does work
10:18:04 <lesshaste> Hi. I am writing notes on 2-3 trees etc. in haskell... it always says on the web that they are wasteful compared to red-black trees.. anyone know why this is?
10:19:55 <dozer_> lesshaste: well - what is the trade-off between the stoorage neede for each tree type and the code for operations upon them?
10:21:35 <lesshaste> dozer_, ok.. so you say 2-3 trees need more storage space?
10:22:10 <dozer_> lesshaste: do you have a deffinition of 2-3 trees and of red-black trees infront of you?
10:23:59 <Oejet> I'm trying to match LaTeX formulas. matchRegex (mkRegex "\\$([^\\$]*)\\$") "$f(x)=x^2$" => Just ["f(x)=x^2"], but why is matchRegex (mkRegex "\\$([^\\$]*)\\$") "$f(x)=\\pi^2$" => Nothing?
10:24:44 <xerox> Considered using Parsec at this level?
10:24:49 <bolrod> [^\\$]  ??
10:25:14 <palomer> some days one simply should not code
10:25:42 <Oejet> bolrod: A Char which is not '$'.
10:26:01 <lesshaste> dozer_, yep
10:26:10 <bolrod> bwah...  I don't get it anyway ..
10:26:17 <bolrod> I just wondered why you put the \\
10:26:24 <Oejet> xerox: I just need to match the outer $.  I have Parsec for the guts. ;-)
10:27:06 <kpreid_> Oejet: looks like it ought to work, but $ is usually not special in character classes, so maybe the extraneous \\ affects it. I don't know that regex library in particular.
10:27:21 <xerox> I usually take the route of escaping more and more until the regexps blarf.
10:27:28 <bolrod> isn't \\ => \
10:27:41 <kpreid_> Oejet: Oh, that's it in fact. It is not matching because there is a \ in the text to be matched, and your character class excludes \.
10:27:48 <Oejet> bolrod: Aha, you got it. :-)
10:28:01 <bolrod> and $ is special in regexp
10:28:11 <xerox> (Hence the escape.)
10:28:18 <bolrod> $ behind a regexp sais it has to end in that
10:28:20 <kpreid_> $ is special in a regex *except in a character class*
10:28:29 <bolrod> don't know what it is inside the ]
10:28:30 <bolrod> []
10:28:37 <kpreid_> it is literal, as is \
10:29:16 <Oejet> kpreid_: Got it.  Thanks all.
10:29:25 <bolrod> regexp is fun  ;)
10:30:24 <davidhouse> Oejet: why bother with matching the $s with regexes if you're using Parsec anyway?
10:30:39 <davidhouse> between (char '$') (char '$' >> eof) $ do ...
10:31:24 <davidhouse> @where pango
10:31:24 <lambdabot> I know nothing about pango.
10:31:56 <Oejet> davidhouse: Good question.  This is just a quick and dirty prototype wiki-like parser, which produces XTHML+MathML.
10:32:53 <davidhouse> eurgh. yast won't start. bbl.
10:40:54 <bolrod> yast?
10:40:54 <bolrod> xD
10:42:49 <NameTab> robbertkop!
10:45:48 <bolrod> man my wxhaskell code feels dirty
10:46:01 <bolrod> especially the function types
10:46:02 <bolrod> > makeFileMenu        :: Frame () -> Var (Maybe Calendar) -> StatusField -> Var (Maybe FilePath) -> IO (Menu ())
10:46:04 <lambdabot>  Not in scope: type constructor or class `Menu'
10:46:06 <bolrod> O_o
10:51:26 <gfhj> http://www.ilove-movies.com/main.html http://cool-porn.biz/welivetogether/galleries/dyke1010/vp.html
10:52:09 <Oejet> Hm the \[ \] pair is causing me yet more trouble.  I have this: "\\[([^\{\\]\}]*)\\]".  What is the notation for "not this string".
10:54:54 <Oejet> Ah, perhaps [^\\][^\]].
10:56:37 <int-e> oh. you want ([^\\]|\\[^\]])* I think. I.e. not a \ or \ not followed by ].
10:56:56 * Philippa_ sighs
10:57:00 <Philippa_> I think I'm being too cynical
10:57:22 <wchogg> Howso?
10:57:28 <Philippa_> I just started reading the "Down with lambda lifting!" paper linked to on LtU, and right at the start of the exposition there's something to which my immediate response was "I don't believe you!"
10:58:17 <Philippa_> to paraphrase: "we'll start with pure lambda calculus - adding pattern-matching would pose no fundamental problems and would only obscure needlessly"
10:58:49 <Philippa_> most of the other abstract machines I've seen for lazy languages make a big deal of their case analysis...
11:00:40 <wchogg> Gah...unfortunately I think that paper might be over my head right now.
11:04:20 <mahogny> Philippa_, well. do they have a point in making it a big deal?
11:05:22 <Philippa_> mahogny: yes, they do. It's closely tied up with how they do thunk updates
11:05:58 <bolrod> Oejet: why the hell do you create those difficult regexp's
11:05:59 <Jhoa> http://g.pantywash.com/galleries/rackandblack/051024carmen/vp.html http://hornystarlet.com/yt/135/vdpst.htm
11:06:28 <mahogny> Philippa_, "would only obscure nedlessly" => "we are too lazy to do this in detail" :)
11:09:19 <Ulfalizer> yay, my macbook pro should arrive any day now
11:09:28 <bolrod> cool
11:09:54 <bolrod> apple still doesn't have the battery life on the site eh?
11:09:56 <Ulfalizer> got it for half the prie through a work deal at my dads work-place :)
11:10:01 <Ulfalizer> +c
11:10:08 <bolrod> :O
11:10:34 <bolrod> I wonder if it gets past 3.5 hours of use
11:10:49 <Ulfalizer> i haven't seen any figures on the battery life. i assume it's comparable to the battery life of the powerbook.
11:11:07 <bolrod> I guess so..
11:11:26 <bolrod> battery life on the powerbook is probably 'ok'
11:12:21 <Ulfalizer> i've heard fuel cells should hit the market in a year or so, and that they should be compatible with the macbook
11:12:27 <Oejet> int-e: Thanks, that's good.  Does this look good in GHCI? putStrLn "\\\\\\[(([^\\\\]|\\\\[^\\]])*)\\\\\\]"
11:12:38 <mahogny> fuel cells? sounds expensive
11:13:13 <Ulfalizer> i don't know about price. it's supposed to bring battery life up to 6-8 hours at least.
11:13:35 <Oejet> bolrod: I'm writing a wiki-engine, which can read TeX formula syntax.
11:13:36 <mahogny> I bet, but they still use really expensive materials
11:13:41 <Ulfalizer> Oejet: ugh, that looks pretty nasty. i thought regexp in java was bad..
11:14:13 <Ulfalizer> mahogny: ok, i don't really know much about them
11:15:45 <mahogny> Ulfalizer, there's a lot of research going on but I believe price will drop a lot if you wait a bit. when enough quantities are being produced, I think they will be able to cut the price
11:16:28 <int-e> Oejet: \\\[(([^\\]|\\[^\]])*)\\\] ... looks ok.
11:16:43 <Ulfalizer> i hadn't planned to buy one for a while. i just noted that they will be available soon :)
11:18:01 <bolrod> Oejet: but why have THAT many \\\\\ etc
11:18:06 <Ulfalizer> i wonder if there will be refillable versions.. pay by-the-gallon :)
11:18:24 <Oejet> int-e: Well, for some reason it's not matching: abe \[x\pi^2\].
11:18:35 <bolrod> at least in perl..  [^ab]   is not  'does not match "ab"  '
11:18:42 <bolrod> but is 'does not match 'a' or 'b''
11:19:29 <bolrod> if you want to not match a sequence of chars you [^(something you want to NOT match)]
11:19:40 <bolrod> at least... thats what I thought
11:20:00 <bolrod> I don't know how they implemented this in haskell
11:20:11 <Ulfalizer> that's how it works  [^abc] will match a single character that's not 'a', 'b' or 'c'
11:20:15 <Ulfalizer> +.
11:20:20 <bolrod> indeed
11:20:27 <bolrod> and the * thing can cause alot of funky things
11:20:32 <bolrod> since it will match  ZERO  or more 
11:20:44 <bolrod> if you want to match it ONCE or more . use +
11:20:53 <Ulfalizer> you need to remember * is greedy by default. that can cause a lot of trouble if you don't keep it in midn.
11:21:08 <bolrod> that too
11:21:23 <bolrod> but if you put something behind *  it will try to match for that as well right?
11:21:29 <bolrod> especially if you also use the $
11:21:46 <bolrod> * can cause alot of things you didn't expect
11:21:53 <bolrod> expecially   .*   
11:22:16 <int-e> Oejet: Hrm. I'd try it with some innocent characters instead of \ [ first, then get the number of levels of quotings correct.
11:23:30 <Ulfalizer> yes, if you match with  .*b  against aabaabaa, .* will match aabaa, and b will match the b after that. many people make the mistake of thinking .* will stop before the first b in that case.
11:24:26 <Ulfalizer> is there a regexp library for haskell by the way? :)
11:24:34 <bolrod> seems there is
11:24:52 <Ulfalizer> any information on it?
11:25:06 <bolrod> Oejet uses it
11:25:19 <bolrod> how would you make it stop on the first  b  in aaabaaaabbaaaa
11:25:31 <Ulfalizer> the ghc regexp library?
11:26:19 <Ulfalizer> bolrod: many regexp implementations let you make a quantifier non-greedy by putting ? after it. so .*?b should make it stop at the first b.
11:26:26 * int-e notes that @<([^@]|@[^>])*@> doesn't match @<@@> (using @ for \, < for [, > for ])
11:26:30 <bolrod> aha
11:26:48 <Ulfalizer> otherwise you'd have to do [^b]*b
11:27:04 <bolrod> yep
11:27:07 <Ulfalizer> "any number of characters that are not b's, followed by a b"
11:27:31 <bolrod> if you know how many times to match a certain char
11:27:36 <bolrod> you could do    b{2}
11:27:41 <bolrod> if you want to match b twice
11:27:47 <Ulfalizer> yeah
11:27:56 <bolrod> or   b{1,3}  to match it between 1 and 3 times
11:28:04 <bolrod> can be alot clearer
11:28:49 <Ulfalizer> * is just {0,} , and + is {1,}
11:29:20 <bolrod> and  ? is {0,1}  right?
11:29:24 <Ulfalizer> yup
11:29:54 <Ulfalizer> except when it appears after a quantifier. then it serves to make it non-greedy.
11:30:05 <Ulfalizer> but not all regexp implementations have that
11:30:13 <bolrod> I didn't know it actually
11:30:15 <int-e> ah. @<(([^@]|@+[^>])*@*)@> should work for matching @<(string not containing @>)@>. This is ugly.
11:30:29 <bolrod> O_o
11:30:42 <bolrod> what does the   |  thing do?
11:30:47 <bolrod> just a char?
11:30:53 <int-e> (x|y) matches x or y
11:30:58 <bolrod> aha
11:31:07 <Ulfalizer> is <> for capturing?
11:31:08 <neologism> btw: any lisp programmer here?
11:31:24 <int-e> no, <> are my replacement symbols for [] - to avoid the quoting issue
11:31:29 <Ulfalizer> ok
11:31:56 <int-e> so they're just normal characters.
11:31:57 <bolrod> matching between  @<   ...  >@   might be easier with the quantifier
11:32:20 <bolrod> @< (.*?) >@
11:32:21 <lambdabot> compose module failed: Parse error: "(.*?)"
11:32:34 <bolrod> @regex
11:32:35 <lambdabot> Unknown command, try @list
11:32:38 <bolrod> @hoogle regex
11:32:39 <lambdabot> Text.Regex :: module
11:32:39 <lambdabot> Text.Regex.Regex :: data Regex
11:32:39 <lambdabot> Text.Regex.Posix.regexec :: Regex -> String -> IO (Maybe (String, String, String, [String]))
11:32:58 <bolrod> @hoogle regexp
11:32:59 <lambdabot> No matches found
11:33:08 <bolrod> @type regex
11:33:09 <lambdabot> Not in scope: `regex'
11:33:14 <bolrod> @type regexec
11:33:16 <lambdabot> Not in scope: `regexec'
11:33:20 <wilx> @hoogle match
11:33:21 <lambdabot> Language.Haskell.TH.match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
11:33:21 <lambdabot> Data.Graph.Inductive.Graph.match :: Graph gr => Node -> gr a b -> Decomp gr a b
11:33:21 <lambdabot> Language.Haskell.TH.Match :: Pat -> Body -> [Dec] -> Match
11:33:38 <Ulfalizer> @([^@]*)@ should capture a text delimited by @'s, if () are capturing parenthesis
11:33:39 <lambdabot> Unknown command, try @list
11:34:25 <int-e> doesn't match @(@)@
11:34:33 <int-e> ah
11:34:35 <int-e> sorry
11:34:40 <int-e> yes, it does.
11:35:04 <Ulfalizer> if the text has @ in it, then you're into trouble of course :)
11:36:03 <bolrod> ofcourse
11:36:16 <Ulfalizer> -to
11:36:36 <bolrod> but then you could use   @< ([(>@)]* ) >@
11:36:49 <kolmodin> Lemmih: would it be possible to get an url to your ghci debugger thingie? thanks
11:36:50 <bolrod> you have to know where to stop at least
11:37:48 <Ulfalizer> i haven't seen the [(>@)] syntax before. in ordinary regexp, that would mean any of the characters (,>,@,)
11:38:22 <int-e> Ulfalizer: as for *? ... PCRE implements that, following Perl, do you know of other libraries that follow that use that convention? (Of course all languages whose regexp libraries use PCRE have that feature, too)
11:40:13 <Ulfalizer> int-e: i haven't heard of pcre. i know python's and tcl's regexp engines support it as well.
11:40:53 <Ulfalizer> i think boost does it too
11:44:29 <int-e> Ulfalizer: seems you're right. thanks.
11:49:01 <int-e> Ulfalizer: pcre is just a library that implements 'perl compatible regular expressions' - hence the name.
11:49:39 <bolrod> ppcre might be good
11:49:47 <bolrod> possibly perl compatible regular expressions
11:50:00 <bolrod> you never know what they'll do to it ;)
11:53:39 <Ulfalizer> pcre looks nice. i've missed a good freestanding regexp lib.
11:53:50 <Ulfalizer> i can't have looked very hard though, as it seems to have been around for a while :)
12:04:26 <Cale> Ulfalizer: Mostly just using Parsec or a similar parser combinator library is pretty decent, so long as you don't require that it actually be regexp syntax
12:04:45 <Cale> there's also a regexp library or two written using parsec
12:10:22 <Ulfalizer> Cale: haven't heard of parsec either, and i don't have any experience with parser combinators
12:10:24 * vincenz kicks the nearest person
12:10:29 <Ulfalizer> ouch
12:10:45 <mahogny> parsec owns
12:11:14 <Philippa_> parsec's good
12:11:16 <mahogny> used it for a mirc script parser and it even managed to handle that fucked up syntax
12:11:20 * roconnor @ TYPES
12:11:21 <Philippa_> heh
12:11:42 <Philippa_> mirc script's not that screwed up, is it? It seemed fairly sane, albeit a TCL-style hack
12:12:11 <Philippa_> roconnor: 'lo - don't suppose you were in the bar in newark hall tuesday night?
12:12:22 <Philippa_> (beelsebob and I were for a bit)
12:12:24 <vincenz> fucking hell I'm pissed off
12:12:24 <vincenz> l
12:12:33 <mahogny> Philippa_, there are lots of things in it that would have been made different if it had actually been designed and not just tossed together over the years
12:12:36 <bolrod> vincenz: cool
12:12:40 <bolrod> why?
12:12:43 <Philippa_> mahogny: that figures
12:12:46 <vincenz> bolrod: some guy just plagiarised a list I wrote
12:12:49 <vincenz> bolrod: and send it to a company
12:12:59 <vincenz> a technical details question list I compiled without so much as referring to my name
12:13:14 <bolrod> so ?.. now?
12:13:17 <vincenz> so?
12:13:23 <vincenz> they 'll think he's the expert
12:13:27 <vincenz> while I'm the one that did the work
12:13:36 <Oejet> Hm, there must be some quoting problem.  This is the printed pattern: \\\[(([^\\]|\\[^\]])*)\\\] .  It should match the first bracket in: abe \[x\pi^2\]\[x/2\].
12:13:43 <vincenz> I'm off to get cigarettes
12:13:47 <bolrod> send one yourself too
12:13:48 <vincenz> before I throw my laptop through the window
12:13:51 <bolrod> explaining it
12:13:53 <mahogny> Philippa_, I think the guy has no clue whatsoever about compilers and just wrote something. while it works for him, it makes it damn hard to parse it using common tools. I think I read on his web page that the code is > 100 000 lines (mirc) which considering I managed to do most of it with some 2000 lines of haskell
12:13:57 <bolrod> and some more details
12:14:00 <mahogny> Philippa_, ...really sucks
12:14:08 <vincenz> bolrod: that'll hardly be appropriate in the given circumstances
12:14:55 <roconnor> Philippa_: I was only in the bar once in the late, when there were only two people playing pool.
12:15:10 <Philippa_> fair enough. I left maybe quarter to 11ish?
12:15:46 <Philippa_> mahogny: it's interpreted rather than compiled anyway. Don't forget to allow for things like being C-based and dealing with MS's APIs directly
12:16:07 <Philippa_> 100KLoC isn't so hard to do in a windows app
12:16:12 <mahogny> Philippa_, it runs under linux so I have a bit of a problem with that part
12:16:57 <Philippa_> that'll've been done the hard way, no? mIRC certainly used to be windows-only
12:17:14 <roconnor> Philippa_: Anyhow, I gave the talk on using monads to implement real numbers
12:17:26 <mahogny> Philippa_, yeah. I'm working on a port kind of
12:17:34 <Philippa_> 'fraid I'm not at the conference per se. I'm a lowly undergrad and broke while I'm at it
12:17:58 <roconnor> Philippa_: oh, that's too bad :'(
12:18:20 <Philippa_> should be free from 6 onwards tomorrow if you and/or anyone else is still around and fancies a chat though?
12:18:34 <Philippa_> Plus there're better watering holes around here than the bar in wanker hall :-)
12:19:00 <roconnor> I'll be around.
12:19:37 <Philippa_> guess I'll see if I catch you on here and figure out somewhere to go?
12:20:29 <Oejet> Philippa_: Wanker Hall?
12:20:33 <pitecus> Hello. Is there a way to pickle haskell datastructures? 
12:20:54 <Philippa_> Oejet: Newark Hall. Newark is an anagram summing up most of the inhabitants :-) (used to live there)
12:21:18 <tic> mm cPickle...
12:21:34 <roconnor> pitecus: show ?
12:21:48 <tic> or Foreign.Marshall?
12:23:02 <pitecus> roconnor, can I always read it back using read?
12:23:13 <Philippa_> if there're both show and read instances, yes
12:23:23 <ihope> So how can I spawn a terminal window?
12:23:24 <pitecus> tic, I don't want to do anything foreign
12:24:54 <roconnor> pitecus: I think ``deriving (Read,Show)'' ought to have this effect.
12:26:30 <pitecus> roconnor, I want to pickle HashTables so I guess I need to define instances of Read and Show myself, no?
12:27:12 <roconnor> that would be one way to go I suppose.
12:31:05 <franka> ihope: You need to have sex with a parent process.
12:32:20 * vincenz snips franka's words and accidentally forgets the last word
12:33:20 <ihope> Oh dear.
12:52:41 <Ulfalizer> heh, i've just had a bag of peanuts, and now something's wrong with the water faucet
12:52:51 <Ulfalizer> someone musy really hate me..
12:52:56 <Ulfalizer> -y+t
12:54:07 <Ulfalizer> there.. had some milk in the fridge
12:54:24 * Ulfalizer likes to share his interesting life
12:59:03 <aufrank> I've got a type/data structure question
12:59:36 <xerox> Go on!
12:59:37 <aufrank> in a neural network setting, I want to define a bunch of nodes (each of which has a numerical activation level)
12:59:44 <aufrank> and then connections between those nodes
13:00:03 <aufrank> and then to write a function that sends activation between connected nodes
13:00:21 <aufrank> so something like
13:00:33 <xerox> I.e. a graph?
13:00:40 <aufrank> yes :)
13:00:41 <xerox> @docs Data.Graph
13:00:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
13:00:46 <xerox> Maybe investigate that?
13:01:11 <aufrank> definitely investigate that ;)
13:01:22 <aufrank> you folks do so many things before I even get there!
13:02:10 <bolrod> someone familiar with wxhaskell?
13:02:21 <bolrod> what exactly does  'container'  do?
13:08:02 <tibbe> what's the importance of fix points? is it related to recursion?
13:08:23 <tibbe> It's used here in 2.1: http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/iterator.pdf
13:08:50 <tibbe> (or rather I think it's fixed point something=
13:11:59 <norpan> yes, you can implement recursion using the fixpoint operator
13:12:16 <norpan> if that's what you mean
13:12:38 <Cale> Philippa_: from what I recall mIRCScript is insane. There were functions which behaved in two different valid ways based on the presence or absence of commas in their parameter lists, for instance
13:13:09 <Cale> I'm not sure if that's quite right, but I remember there being things at least as stupid as that :)
13:14:04 <tibbe> norpan, so what is the fixpoint operator, a function that evaluates to itself somehow?
13:14:18 <Cale> y f = f (y f)
13:14:36 <Cale> tibbe: that's the least fixed point operator
13:15:28 <Cale> > let y f = f (y f) in y (\f n -> if n == 0 then 1 else n * f (n - 1))
13:15:29 <lambdabot>  add an instance declaration for (Show (a -> a))
13:15:37 <Cale> > let y f = f (y f) in y (\f n -> if n == 0 then 1 else n * f (n - 1)) 5
13:15:38 <lambdabot> 120
13:16:53 <tibbe> I'll have to stare at that one for a while
13:17:08 <vincenz> tromp: ping
13:17:12 <Cale> > let y f = f (y f) in map (y (\f n -> if n == 0 then 1 else n * f (n - 1))) [1..10]
13:17:13 <lambdabot> [1,2,6,24,120,720,5040,40320,362880,3628800]
13:17:57 <Cale> > scanl (*) 1 [2..10]
13:17:58 <lambdabot> [1,2,6,24,120,720,5040,40320,362880,3628800]
13:18:22 <Cale> > [product [1..n] | n <- [1..10]]
13:18:24 <lambdabot> [1,2,6,24,120,720,5040,40320,362880,3628800]
13:18:44 <bolrod> >  [1,2,6,24,120,720,5040,40320,362880,3628800]
13:18:45 <lambdabot> [1,2,6,24,120,720,5040,40320,362880,3628800]
13:18:48 <tibbe> I think I
13:19:02 <tibbe> I think I'll never completly "get" functional programming
13:19:21 <Cale> give it a few years :)
13:19:43 <tibbe> problem is that there's little material to study once I leave univesity
13:19:49 <tibbe> university*
13:20:06 <bolrod> O_O
13:20:09 <Cale> not true -- there's plenty of stuff online if you're looking in the right places
13:20:22 <Cale> The Haskell and Haskell-cafe lists are pretty good
13:20:41 <tibbe> there's a gap between beginner -> advanced that somehow have to be jumped over since there seems to be no intermediate (sp?) level material around
13:20:56 <norpan> you can always ask questions here
13:21:15 <norpan> but there are quite a few intermediate papers
13:21:19 <tibbe> so I have some clue about monads, have written a let-polymorphism type checker, now what?
13:21:36 <bolrod> there is always an intermediate
13:21:41 <tibbe> perhaps I should look at some different papers
13:21:42 <bolrod> just take little steps at a time
13:22:28 <bolrod> hello shapr 
13:23:00 <Cale> well, if you'd like to know more about fixpoints and recursion, perhaps playing around with the lambda calculus some more would be a good idea
13:23:13 <bolrod> 12
13:23:17 <bolrod> oops
13:23:18 <shapr> hiya bolrod 
13:23:30 <tibbe> Cale, agreed, I probably brushed over it too quickly
13:23:37 <bolrod> shapr: do you know doaitse ?
13:24:40 <shapr> bolrod: I've read some of his publications, and I met him at ICFP2003. He probably doesn't remember me though.
13:24:48 <bolrod> ah
13:24:51 <bolrod> cool
13:25:20 <bolrod> he is/was my teacher :)
13:26:14 * aufrank is confused about Data.Graph
13:26:36 <aufrank> in the graph constructor, graphFromEdges, it takes a list of tuples
13:26:51 <aufrank> where the elements of the tuple are (node, key, [key])
13:27:09 <aufrank> and node and key are ord
13:28:32 <aufrank> whoops, I just got it
13:28:50 <norpan> it helps just to explain your problem sometimes
13:29:39 <tibbe> cardboard programmer
13:30:05 <shapr> Yeah, Rubber Ducking
13:30:15 <shapr> bolrod: Doaitse is a smart guy.
13:30:22 <bolrod> he is :)
13:30:28 <aufrank> cardboard programmer?  rubber ducking?
13:30:34 <bolrod> nice guy too
13:31:24 <shapr> aufrank: http://c2.com/cgi-bin/wiki?RubberDucking
13:31:29 <vincenz> rubber ducking rocks
13:31:40 <tibbe> aufrank, as norpan said it sometimes helps explaining your problem to someone even if he doesn't respond -> cardboard (paper) programmer
13:32:48 <tibbe> is type inference for OO languages still an open research question?
13:33:39 <shapr> Self et al came up with the Cartesian Product Algorithm.
13:33:52 <shapr> Check out Starkiller for example.
13:34:03 <norpan> i read an article about a man that had his brain internally disconnected but he had developed a way of getting data from one half to the other by speaking it and listening to himself
13:35:22 <shapr> The Self vm would compile and cache type specialized versions of polymorphic calls each time a method was called with a particular combination of types.
13:35:31 <tibbe> "Welcome to STARKILLER -The Jedi Bendu Script Page"
13:35:39 <tibbe> :D
13:35:45 <mahogny> norpan, like doing thread message passing on an SMP using the harddrive? :)
13:35:48 <shapr> Sun turned the Self vm tech into the HotSpot JVM, now standard.
13:36:46 <shapr> tibbe: http://salib.com/
13:37:33 <lispy> shapr: thanks for taking care of the darcs wiki
13:37:37 <aufrank> thanks for the pointer to Data.Graph
13:37:46 <aufrank> I'll see you folks soon
13:38:21 <shapr> lispy: I just compressed the log, I dunno what's using the rest of the space.
13:38:31 <tibbe> shapr, the question I'm currently asking myself is that if it's possible to have OO languages like Ruby, Python with type inference to avoid the cost of manifest typing
13:38:36 <shapr> lispy: I stil haven't fixed the badly translated front page, I never did figure out what was wrong with it.
13:39:05 <shapr> tibbe: salib.com links to Starkiller, the type inferencer and compiler for Python.
13:39:29 <lispy> shapr: badly translated front page
13:39:35 <lispy> what do you mean?
13:39:54 <petekaz> Newbie question: if assignment is not possible in haskell, then why do the hash table operations not return a new hash table?  In erlang, each time I update/insert/remove an entry, I get back a new reference to the hash table.
13:40:02 <shapr> If your browser isn't asking for english first, you get nasty output from DarcsWiki.
13:40:23 <lispy> shapr: oh, well switch to mediawiki ;)
13:40:29 <tibbe> shapr, just read that :) so how come python doesn't use something like that? what's the cost?
13:40:43 <shapr> tibbe: Just a lot of implementation detail really.
13:40:54 <tibbe> shapr, I see
13:40:59 <shapr> I've been trying to get Michael to reimplement Starkiller in Haskell.
13:41:14 <shapr> It'd be a lot simpler to do in Haskell.
13:41:19 <tibbe> are there any unresolved (and important issues) in type inference for OO?
13:41:41 * tibbe sound like he's a big fan of OO which he really isn't
13:41:45 <tibbe> sounds*
13:41:45 <shapr> Yeah, how to make it work around eval?
13:41:57 <mahogny> tibbe, what's wrong with OO?
13:42:29 <lispy> mahogny: it's just one way to think, multi-paradigm is better :)
13:42:33 * shapr agrees
13:42:42 <tibbe> *nods*
13:42:51 <mahogny> lispy, no one stops you from mixing in other styles at need :)
13:42:51 <tibbe> I type too slowly
13:43:26 <shapr> Same for FP.. 
13:43:36 <mahogny> indeed
13:43:40 <tibbe> MyClassThatIsReallyAFunction.getInstance().doIt() ;)
13:43:42 <shapr> I use closures to build weenie objects.
13:43:47 <shapr> hiya Jeremy
13:43:52 <mahogny> tibbe, :D
13:43:53 <stepcut> hello
13:44:12 <lispy> i find that it's harder to prototype in OO
13:44:22 <ihope> norpan: my hypothetical bot acts like that, sorta.
13:44:25 <lispy> and often i'm exploring the problem space before i know how i want to solve it
13:44:31 <tibbe> I miss partial application when I leave haskell
13:44:32 <shapr> I find it harder to come back to OO code years later.
13:44:34 <lispy> so, that's a weakness to OO
13:45:08 <lispy> yeah the more you decouple OO code (to make it flexible and more robust) the harder it is to figure it out later
13:45:09 <xerox> @karma+ musasabi -- Enlightening Arrows-fu.
13:45:09 <lambdabot> musasabi's karma raised to 10.
13:45:43 <shapr> I find it easy to come back to higher order functions and partial application.
13:46:16 <tibbe> I can't abuse foldls as much when I do OO
13:46:18 <shapr> mahogny: Hey, what did you think of my lazy eval email?
13:46:32 <mahogny> shapr, aah. yeah, checked it. now I just gotta remember my comment on that one lol
13:46:33 <tibbe> folds*
13:47:06 <lispy> i find that haskell encourages me to think  about data flow and that tends to give me a better implemenation
13:47:11 <shapr> Well, Python has reduce, and I abuse it heavily.
13:47:29 <lispy> ah, so they stole from CL
13:47:43 <lispy> at least in the name
13:47:54 <shapr> Wow, 205 users on #haskell, what's up with that?
13:47:58 <lispy> i've been finding that R is at least conceptually based on lisp
13:48:05 <bolrod> shapr: you worked with wxhaskell?
13:48:25 <tibbe> shapr, yes so discussing OO-languages is a bit hard since few are *pure* (whatever that means) OO
13:48:39 <tibbe> i.e. where objects are the only first class citizens
13:48:40 <shapr> bolrod: nope, sorry.
13:49:14 <bolrod> dang... I have to make this assignment.. and they want me to represent appointments in a calendar in some way
13:49:18 <bolrod> I just don't know how yet
13:49:30 <mahogny> shapr, ah yeah. now I remember what my comment was; I do think that lazyness is useful, but I don't see a motivation to as to why it should be on by default. if the user knows that it is a requirement, then they can easily tell the compiler to use it
13:50:04 <lispy> bolrod: well, a one time appointment is a date, an extent, and some metadata like where, who, name, etc
13:50:26 <lispy> bolrod: shouldn't be hard to model that with haskell's type system
13:50:33 <NameTab> bolrod: I'm trying to use a ListCtrl
13:50:37 <NameTab> and I know some others who do
13:50:43 <mahogny> shapr, that said, I think having eager execution as default would be even worse
13:50:45 <bolrod> NameTab: I think that's ugly
13:50:55 <bolrod> I want to draw it possibly
13:50:57 <lispy> oh, you want to represent it in wxWidgets?
13:51:02 <tibbe> CPA doesn't work for abstract types?
13:51:04 <NameTab> draw what?
13:51:12 <bolrod> lispy: oh not in a data type
13:51:20 <bolrod> we have the data type.. we need to display it on screen
13:51:50 <bolrod> draw each appointment
13:51:51 <lispy> bolrod: you should be able to use the table control (i forget the name) they are often very powerful and allow you to provide a specialized data model
13:52:07 <bolrod> so you just get a list?
13:52:19 <bolrod> with the looks of an excell document >:/
13:52:25 <NameTab> hehe
13:52:29 <bolrod> thats just downright ugly
13:52:42 <shapr> mahogny: I like non-strict speculative evaluation.
13:52:45 <bolrod> though it does make for sorting on date etc.
13:52:47 <NameTab> but what else do you suggest? I cant imagine anything else which "lists" the appointments
13:52:55 <mahogny> shapr, I like undefined execution :)
13:53:03 <bolrod> NameTab: drawing them in a panel
13:53:17 <shapr> Hiya simon.
13:53:20 <lispy> bolrod: have you seen ical on osx?  it's just a big table
13:53:20 <shapr> How's code?
13:53:22 <bolrod> and then put a list of the panels inside a scrolling window
13:53:32 <sm> hey shapr.. good thx!
13:53:32 <bolrod> lispy: yes.. but it looks better
13:53:39 <bolrod> since it draws things.. ?
13:54:04 <lispy> i can't speak for wxwidgets but other gui apis let you specify custom cell renderers and such
13:54:19 <bolrod> ;o
13:54:24 <tibbe> sloppy evaluation is the way of the future (tm)
13:54:25 <lispy> you just want a widget that is close and customizable
13:54:36 <bolrod> wxhaskell possibly has the worst documentation ever
13:55:25 <mahogny> bolrod, indeed. I really wish someone voluntered to write something better
13:55:41 <lispy> can you fall back to the wxwidgets documentation?  i've been pleased with it when using the wxpython bindings
13:55:55 <mahogny> well, you have to more or less
13:56:15 <mahogny> but I would rather see that the wxhaskell docs were self-containing
13:56:17 <bolrod> hell.. I don't know what they call certain things in wxhaskell
13:56:27 <bolrod> mind you.. it hasn't been properly updated for a long time
13:56:31 <lispy> oh, yeah i had that problem with HOpenGL
13:56:49 <lispy> i knew the opengl function i needed, but couldn't find the HOpenGL function
13:57:24 <musasabi> shapr: much growth :-)
13:57:29 <SamB> how come GHC's -T RTS flag isn't listed in the manual?
13:58:10 <lispy> SamB: maybe you have the wrong manual for your GHC version?
13:58:15 * lispy really has no clue here
13:58:57 <SamB> lispy: I checked latest/, I checked 6.4/, it isn't in either of them.
13:59:35 <SamB> it is in +RTS -?, though
14:00:19 * mahogny suddenly remembers why he switched to haskell as he squashes a wild pointer in his C code
14:00:33 <bolrod> :)
14:00:51 <bolrod> if only haskell had a propperly documented GUI environment
14:01:02 <SamB> oh well, I'll just assume it is the number of collections for a node to survive before it gets moved to the next generation
14:01:54 <mahogny> I guess if a few of us got together, we could fix some documentation for wxhaskell. it's a bit too much work for one person though
14:02:03 <lispy> bolrod: yeah, gtk-hs might be better?
14:02:09 <bolrod> dont know
14:02:18 <bolrod> does OSX have gtk ?
14:02:22 <mahogny> problem with gtkhs though: it is gtk...
14:02:25 <SamB> eh. you still need to look at GTK docs for a lot, I Think
14:02:26 <norpan> gtk2hs, that's well-documented at least
14:02:27 <bolrod> you can install it on windows..
14:02:31 <SamB> er,s/Think/think/
14:02:31 <xerox> bolrod: yes it does.
14:02:50 <shapr> musasabi: growth?
14:02:56 <dcoutts> norpan, and we're trying to simplify it too
14:03:05 <mahogny> I think it is a good habit to use the native GUI of whatever OS you are working with...
14:03:16 <SamB> I could be forgetting...
14:03:16 <norpan> simplify what? the interface or the documentation?
14:03:17 <dcoutts> the main problem with the gtk2hs docs are that they're too large
14:03:29 <SamB> mahogny: even on windows?
14:03:33 <shapr> mahogny: But, my clients all use win32, and I only use Linux.
14:03:34 <dcoutts> that, and that the intro/tutorial docs are rather thin
14:03:57 <SamB> windows native gui is uggh to code
14:03:58 <mahogny> SamB, wxwindows uses the native gui on windows. but I don't have to touch it myself. fair deal :)
14:04:08 <SamB> mahogny: point
14:04:14 <dcoutts> mahogny, win32 has several native guis, most of them written my MS.
14:04:22 <SamB> that is probably why BT used to use wx.
14:04:28 <shapr> GeoWorks was neat.
14:04:45 <SamB> for some reason it doesn't anymore, and now I can't get it to run!
14:04:46 <mahogny> but I don't think one should use a native gui directly if possible. one should always consider portability
14:05:24 <lispy> mahogny: i exactly agree with you, which is why i've used wxwidgets and liked them :)
14:05:30 <dcoutts> win32 & OSX have rather less gui toolkit consistency than most people realise
14:05:48 <mahogny> dcoutts, as long as it looks the same...
14:05:56 <dcoutts> mahogny, ah but it doesn't
14:06:12 <tic> mostly it does..?
14:06:23 <mahogny> in win32? unless we are talking old win16 apps, I can't say I noticed anything worth mentioning
14:06:41 <dcoutts> OSX has 2 looks, win32 has one for each version of Office
14:06:50 <mahogny> lol
14:06:58 <mahogny> I know about OSX. and I agree, office is one hack
14:06:59 <dcoutts> and the win200 vs. xp themeing stuff
14:07:05 <norpan> i can't tell the difference between a gtk app and a "native" windows app
14:07:12 <mahogny> norpan, ...wow
14:07:30 <norpan> that depends on what gtk theme you use of course
14:07:39 <dcoutts> there are still some differences between gtk+ & native, espcicially on win2k theme
14:07:46 <dcoutts> the xp theme is rather better
14:07:55 <dcoutts> since it uses the native theming api for that
14:07:57 <mahogny> ah. newer gtk looks more alike?
14:07:58 <norpan> i use windows xp
14:08:15 * xerox is so happy to see Duncan around again :-)
14:08:19 <dcoutts> :-)
14:08:35 <norpan> i want something like visual haskell for, say, eclipse
14:08:44 <mahogny> for GUIs?
14:08:56 <dcoutts> when I worked for a company and was developing a win32 gui for our product I noticed that even a vanilla version of winXP has two themes
14:08:59 <norpan> no, for general haskell coding :)
14:09:01 <lispy> norpan: there is a haskell plugin for eclipse
14:09:19 <norpan> i know
14:09:27 <lispy> norpan: but it's just for haskell code and you have to write haskell98
14:09:31 <norpan> i know
14:09:33 <lispy> pretty much no ghc extensions
14:09:35 <lispy> :)
14:09:49 * mahogny finally got the result he wanted ^_^
14:09:58 <norpan> i'm thinking maybe you should do a whole new ide concept for haskell
14:10:07 <dcoutts> most XP utils & dialogs use the new XP theme but there are several that use the clasic theme, it's a bit odd. It's all because they're not using a single toolkit so they have to make theming changes all over the place.
14:10:17 <lispy> norpan: have you followed the hide discussions?
14:10:23 <norpan> not really
14:10:33 <mahogny> well, if there is something we need, then it is an automatic GUI generator for haskell that outputs something fairly OO that is easy to use
14:10:37 <norpan> checked it out three years ago
14:10:47 <dcoutts> mahogny, what do you mean?
14:10:53 <lispy> norpan: oh, there have been recent works to it
14:10:54 <mahogny> dcoutts, a gui builder
14:10:55 <norpan> glade works well
14:11:00 <dcoutts> mahogny, like glade?
14:11:02 <mahogny> yeah
14:11:03 <xerox> We need tuomov :-)
14:11:10 <dcoutts> xerox, heh
14:11:33 <dcoutts> mahogny, you mean like glade only better?
14:11:40 <mahogny> dcoutts, for haskell
14:11:53 <dcoutts> glade is language independent
14:12:01 <dcoutts> what would the advantage be?
14:12:02 <xerox> isn't, I'd say.
14:12:06 <resiak> I think mahogny may be talking about glade's code-generation fgu
14:12:06 <Cale> You can use glade with Haskell
14:12:10 <resiak> s/fgu/fu
14:12:18 <norpan> code generation is out
14:12:26 <dcoutts> gui code generation is not a good idea
14:12:27 <mahogny> well. right. unless it outputs in haskell, I don't really care if it is language dependent :)
14:12:28 <norpan> glade xml files works well
14:12:36 <dcoutts> it's better to load it at runtime from the xml
14:12:43 <lispy> honestly, i find gui builders always seems like a good idea until you get half way through the project
14:12:54 <lispy> then they become in the way
14:13:07 <SamB> well, glade shouldn't be too bad
14:13:27 <SamB> if worst comes to worst, you can write your GUIs in XSLT
14:13:53 <dcoutts> mahogny, the problem with generating gui code is that people will then try to use the generated code :-)
14:13:54 <lispy> hehe, that's definitely the worst ;)
14:13:58 <mahogny> dcoutts, the problem I see is that there is no good foundation. you get a set of dialogs you can load, but then what? I'd prefer if it also generated stubs to easily add the control stuff
14:14:03 <Cale> lispy: well, the nice thing about using glade is that it basically lets you load the controls etc, but doesn't prevent you from manipulating the interface you've loaded in code afterward
14:14:06 <mahogny> dcoutts, lol
14:14:30 <lispy> Cale: i've look at glade but never really used it
14:14:39 <norpan> mahogny: what kind of stubs are you thinking of?
14:14:42 <dcoutts> mahogny, right, the thing to do is get refs to the widgets you want and then add the control logic
14:14:45 <lispy> Cale: it did seem a bit more thought out than some of the other gui builders
14:14:51 <SamB> though I'm thinking that loading widgets from Glade and then replacing subtrees as needed would be a real solution
14:15:07 <xerox> The more I think about it, the more I accept that the means of communications between GUIs and code should be some kind of language which doesn't reside ad language level.
14:15:11 <dcoutts> SamB, I think that's possible
14:15:22 <SamB> dcoutts: I know it is
14:15:33 <SamB> you can find them by name, right?
14:15:41 <dcoutts> SamB, yes
14:15:46 <xerox> I.e. think about GUIs as different programs, and do IPC with them </metaphor>
14:15:46 <mahogny> norpan, something that easily lets you link everything together codewise. since haskell lacks classes, which are quite easy to base GUI code on, you have to invent your own stuff all the time
14:16:02 <dozer_> i've never found a gui builder that I like which lets me hook in the app logic, gui interaction and gui display cleanly
14:16:37 <dozer_> I guess I keep finding that the model of the mvc is never quite 1:1 with the data-structures that the app is manipulating
14:16:39 <mahogny> dozer_, I think that's quite true. I remember the horror of C generated from glade in the past
14:16:44 <norpan> i have found it works well to use glade+haskell
14:16:49 <xerox> I'd rather like to have a quite fixed, but stable, subsyste to talk to in order to get my ideas displayed than mess with GUI building on my own.
14:16:52 <dcoutts> dozer_, yeah, there are certainly improvements that could be made in that area
14:16:55 <NameTab> bolrod: we don't have the choice between wxHaskell and gtk-hs ;)
14:17:05 <bolrod> indeed we not
14:17:32 <SamB> so you find the place to stick your subtree by name, and stick in the subtree...
14:17:35 <norpan> but then i havent made very complicated guis
14:18:10 <norpan> otoh you should strive to keep your gui simple
14:18:22 <dcoutts> SamB, I think it's more like you just put a container in the place where you'll put your subtree and then add your things to that container
14:18:40 <bolrod> argh... I'll just try to draw the damn appointments into the panel >:/
14:19:00 <SamB> *draw*?
14:19:24 <norpan> cairo is nice too
14:19:59 * xerox hops cheerfully
14:20:23 <bolrod> NameTab: look at the event filters -> mouse filters
14:20:27 <dcoutts> xerox, so when will we find some time to study a pure cairo layer?
14:20:28 <bolrod> do you have any idea how to use them?
14:20:42 <xerox> dcoutts: I was exactly writing that question too.
14:20:43 <NameTab> I have few ideas of how to use anything
14:20:48 <dcoutts> xerox, heh
14:20:55 <bolrod> great
14:21:15 <xerox> dcoutts: do you think the paper idea is still a good one, along with the code?
14:21:38 <NameTab> no, it sucks
14:21:41 <dcoutts> xerox, not sure what the original idea is exactly, or what journal we'd submit it to
14:21:52 <xerox> dcoutts: alright
14:21:57 <mwc> I'd like to express my disgust and irritation at the GHC developers
14:22:06 <mwc> for releasing 6.4.2 while I still have one exam left
14:22:12 <dcoutts> hah
14:22:13 * xerox pats mwc 
14:22:15 <mahogny> lol
14:22:21 <dcoutts> xerox, but it's certainly a cool idea
14:22:39 <xerox> dcoutts: I'd say let's do it, soonish :-)
14:23:15 <dcoutts> xerox, I guess the key contribution is the approach to extracting a pure typed api from an imperitive statefull api
14:23:30 <dcoutts> and with minimal overhead
14:24:17 <xerox> I.e. hide the Render in *that* way
14:25:44 <xerox> dcoutts: do we ought to make some kind of optimization to the stacked pure computation we're going to make?
14:26:08 <dcoutts> xerox, not sure what you mean
14:26:19 * resiak suggests that dcoutts run "imperitive statefull" through a spellchucker before using it in the abstract ;)
14:26:50 * dcoutts thanks resiak for the wise advice
14:27:04 <xerox> dcoutts: wondering wether we're going to get huge computation blocks or not
14:27:07 <dcoutts> bad spellers of the world untie!
14:27:23 <mahogny> lol
14:27:50 <xerox> dcoutts: e.g. if the Render takes care of unrolling the operations out in a sort of "eager" way, or not
14:28:11 <mahogny> anyone got a good pattern for how to write wxhaskell code in an easy to manage OOP way?
14:29:01 <xerox> C++ guys, maybe ;-)
14:29:10 <mahogny> ouch. hate that language
14:29:33 <norpan> where can i read about the latest hide stuff?
14:29:46 <xerox> <http://haskell.org/hide>
14:32:00 <norpan> thanks, just found the sourceforge page
14:34:47 <bolrod> NameTab: Damn!  I think I'm beginning to get this
14:34:55 <gadolin> @index isSorted
14:34:56 <lambdabot> bzzt
14:35:05 <gadolin> @doc sort
14:35:06 <lambdabot> sort not available
14:35:13 <gadolin> @index sort
14:35:14 <lambdabot> Data.List
14:36:13 <NameTab> bolrod: right, /me is understanding more too
14:36:16 <NameTab> but by far not enough
14:36:38 <bolrod> set p [on doubleClick := something f]
14:36:49 <bolrod> does  something f (pt)    on double click :)
14:38:35 <NameTab> (pt) ?
14:39:25 <NameTab> somehow my box makes screens smaller than other boxes
14:39:33 <mahogny> the problem IMO is the monadic mess when making GUIs in wx; it would look incredibly if you could just write it in a declarative style
14:39:38 <NameTab> ehh, my screen makes boxes smaller than..
14:42:09 <bolrod> dayum!  I have it all planned now :D
14:42:18 <bolrod> I'll just paint the damn appointments
14:42:30 <bolrod> if only I could make widgets  out of them
14:42:32 <bolrod> ;(
14:42:39 <NameTab> congrats
14:42:50 <bolrod> then it would be like slapping them on the panel like buttons
14:42:51 <bolrod> :D
14:43:07 <mahogny> well. you can make widgets if you really really want to you know
14:43:18 <bolrod> its not easy
14:43:33 <mahogny> the example was messy IIRC
14:44:04 <bolrod> well.. I could look in the wxhaskell source how they created the button widget
14:44:37 <mahogny> but you have checked the example that comes with where they make a widget of some sort?
14:49:11 <norpan> that hide page didn't say much
14:49:27 <NameTab> bolrod: vcal == simply a String ?
14:49:28 <xerox> You should all be pretty excited.  Excite now!  (-:
14:49:34 <bolrod> O_o
14:49:36 <bolrod> no way
14:49:43 <bolrod> vcal = Var (Maybe Calendar)
14:49:55 <bolrod> you can see it in the types
14:50:01 <NameTab> couldn't find it 
14:50:04 <NameTab> thought so already
14:50:30 <bolrod> > makeFileMenu        :: Frame () -> Var (Maybe Calendar) -> StatusField -> Var (Maybe FilePath) -> IO (Menu ())
14:50:31 <lambdabot>  Not in scope: type constructor or class `Menu'
14:50:46 <bolrod> ok.. that statusfield and filepath I wrote myself
14:58:17 <gadolin> hmm, what was that keyword to not import given symbol?
14:58:24 <gadolin> 'hiding' ?
14:58:43 <bolrod> wow.. I actually managed to create a widget by using the example
15:00:20 <lispy> when you guys author papers, what do you use? word? latex? something else?
15:00:33 <lispy> and why do you use it?
15:01:22 <yaarg> never typesetting math in word have you? :)_
15:01:38 <yaarg> eugh s/typesetting/typesetted/
15:01:44 <mahogny> open office, but only because I am too lazy to set up a good layout in latex (which has good support for haskell btw)
15:01:58 <lispy> yaarg: never have, but i've done it in latex many times
15:02:04 <yaarg> :)
15:02:26 <lispy> i was wondering how useful a latex based wiki would be
15:02:38 <mahogny> well. latex IS used on wikis :)
15:02:44 <mahogny> for math stuff mostly I guess
15:02:52 <lispy> mahogny: <math> in mediawiki?
15:02:58 <lispy> mahogny: it's very limited...
15:03:09 <SamB> lispy: well yeah!
15:03:10 <mahogny> haven't used mediawiki
15:03:16 <mahogny> ...much
15:03:21 <SamB> they don't want you to hack the server!
15:03:28 <lispy> but basically i was thinking you'd be able to view the pages as pdf and the markup would be direct latex
15:03:47 <mahogny> lispy, arxiv? ;)
15:03:51 <lispy> (you'd also be able to view as html)
15:03:55 <lispy> arxiv?
15:03:58 * lispy googles
15:04:31 <mahogny> www.arxiv.org, the most serious "wiki" you ever find ;)
15:05:18 <SamB> @google arxiv
15:05:19 <lambdabot> http://front.math.ucdavis.edu/
15:05:27 <SamB> huh
15:05:38 <lispy> hmm...i don't see how you edit the content
15:05:50 <lispy> actually it just looks like a collection of math research papers
15:06:22 <mahogny> lispy, it's an archive for scientific papers. you can upload as many as you want, and you normally do it in latex format. you can view them as pdf or html
15:06:30 <mahogny> hence that is why I said "wiki" :)
15:06:40 <sm> http://mcelrath.org/Notes/LatexWiki is another
15:06:48 <SamB> how do you link to other papers?
15:06:54 <lispy> hmm...yeah i was thinking of something to make collaboration and co-authoring easier
15:06:56 <SamB> or update papers?
15:07:10 <mahogny> SamB, they have some standardized system for references
15:07:28 <mahogny> updates, they have some special rules for how to do that
15:07:59 <lispy> sm: hmm...judging by that webpage i would guess that it's limited in the same way <math> is limited with mediawki
15:08:22 <sm> lispy, in what sense ?
15:09:29 <lispy> i wanted to have full access to latex so that you'd just run pdflatex on the wiki source and submit the result to your editor :)
15:10:17 <mahogny> well. is it that hard to write a wiki->latex compiler?
15:10:50 <sm> http://wiki.axiom-developer.org/SandBoxPamphlet seems to generate pdf etc.
15:11:23 <sm> perhaps you also mean to generate a full document or book from multiple wiki pages at once
15:14:48 <lispy> i don't really know what i want until i've used it and it was better than what i do now :)
15:15:00 <lispy> and it's just something i think about from time to time
15:18:07 <aufrank> lispy: have you seen planetmath.org ?
15:20:43 <lispy> aufrank: yeah i used to be a page maintainer ;)
15:20:49 <lispy> forgot all about it thought
15:28:52 <aufrank> well, there's your "wiki in LaTex", right?
15:54:16 <waern> Doesn anyone know: when building ghc HEAD, why is it using my /usr/local/lib/ghc/include dir instead of the /includes directory in the repository?
15:56:11 <waern> ...since it seems to depend on a recent version of this dir
16:03:37 <gadolin> can I refer to, say, Data.List.sort without importing Data.List first?
16:03:51 <gadolin> the thing is, I want to import sort and only sort
16:04:02 <gadolin> s/import/use/
16:04:25 <gadolin> > Data.List.sort [1 .. 10]
16:04:26 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
16:04:32 <gadolin> > sort [1 .. 10]
16:04:33 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
16:09:09 <gadolin> aha, import qualified
16:15:29 <mux> if you just want sort you can write import Data.List (sort)
16:17:18 <bolrod> > sort [10..1]
16:17:19 <lambdabot> []
16:17:26 <bolrod> > sort [10,9..1]
16:17:27 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
16:19:16 <BCoppens> > [2,4..8]
16:19:17 <lambdabot> [2,4,6,8]
16:19:26 <BCoppens> heh, cool :)
16:20:58 <mux> > reverse [1..]
16:21:02 <lambdabot> Terminated
16:21:19 <mux> good bot :)
16:21:48 <ihope> Hmm, meh, unboxed types gurmble (sic).
16:22:26 <bolrod> > [1..] \\ [1..]
16:22:31 <lambdabot> Terminated
16:22:35 <ihope> @type (\\)
16:22:37 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
16:22:42 <ihope> What does it?
16:22:48 <bolrod> > head $ [1..] \\ [2..]
16:22:51 <bolrod> hrm
16:22:51 <elk> is it possible to generate Generics.Data with DrIFT ?
16:22:52 <lambdabot> Terminated
16:22:58 <ihope> And what does it do, and why?
16:23:01 <bolrod> > [1,2,3] \\ [2,4,5]
16:23:02 <lambdabot> [1,3]
16:23:13 <ihope> s/nd what does it do, a//
16:23:29 <bolrod> don't you see/
16:23:34 <ihope> Ah, yes.
16:23:46 <ihope> Subtraction...
16:23:54 <ihope> mminus :-)
16:24:12 <bolrod> something like that
16:25:39 * ihope attempts to think
16:25:45 <ihope> Ah yes.
16:25:48 <Muad_Dibber> just like the mathematical "\" on sets
16:26:02 <bolrod> the difference
16:26:15 <bolrod> blah.. does it have a name?
16:26:20 <ihope> Can an unboxed tuple be passed to unsafeCoerce# or returned from it?
16:27:56 <elk> any SYB experts around ?
16:33:15 <ihope> @docs GHC.Prim
16:33:16 <lambdabot> GHC.Prim not available
16:33:21 <ihope> Ow.
16:33:48 <ihope> Okay, who named this function: mulIntMayOflo#
16:34:24 <lispy> looks like, multiply int but may overflow
16:35:08 <ihope> Ah.
16:35:25 <ihope> Why not mulIntMayOver?
16:36:09 <lispy> O-flow has a sort of musical sound to it? ;)
16:36:19 <ihope> :-)
16:36:26 <ihope> So why Oflo and not Oflow?
16:36:37 <Muad_Dibber> ooo-flow, you smell so bad (on the tune of "hey jude"
16:36:44 <lispy> seriously, i have no idea, it looks like a bad name to me :)
16:37:09 <lispy> ihope: what are you working on?
16:37:16 <lispy> why do you need ghc primitives...
16:37:22 <ihope> >:-D
16:37:38 <ihope> I'm trying to implement an efficient natural number thingy.
16:37:41 <lispy> one day you need haddock to compile, the next you're hacking ghc primitives...i'm worried :)
16:37:47 <lispy> ah
16:38:17 * SamB thinks GHC could use a GC monitor panel like the panel in Self...
16:38:53 <lispy> oh yeah, i think NetBeans IDE has one of those in debug mode
16:39:16 <ihope> Okay. Are there any Word# literals, or will I have to use intToWord#?
16:39:24 <lispy> SamB: but you were playing with the RTS options, so surely you found the profiler options to at least get that info?
16:39:30 <ihope> int2Word#. Close enough.
16:39:48 <SamB> of course, there would be the issue of needlessly loading libX11 when it wasn't turned on...
16:40:06 <lispy> SamB: naw, the linking would be lazy ;)
16:40:10 <SamB> lispy: -S is not the same thing
16:40:16 <SamB> or needlessly depending on libX11
16:40:38 <ptolomy> Wow, I think I've just written one of the most useless pieces of software ever: an optimizing compiler for BrainFuck.
16:41:04 <ihope> :-D
16:41:17 <SamB> then again, I suppose in this day and age nobody is going to much mind having to install libX11 to use prepackaged GHC binaries...
16:41:22 <ihope> Somebody tell me how to pop quotes into lambdabot, quick!...
16:41:36 <lispy> hehe
16:41:37 <lispy> totally
16:41:39 <SamB> @remember ihope Somebody tell me how to pop quotes into lambdabot, quick!...
16:41:40 <lambdabot> Unknown command, try @list
16:41:46 <SamB> huh
16:41:54 <SamB> @list quote
16:41:54 <lambdabot> quote provides: quote ghc fortune yow arr keal b52s brain palomer girl19
16:42:05 <lispy> @brain
16:42:06 <lambdabot> Well, I think so, but Kevin Costner with an English accent?
16:42:09 <SamB> @help quote
16:42:10 <lambdabot> quote <nick>
16:42:10 <lambdabot> remember <nick> <quote>
16:42:10 <lambdabot> Quote somebody, a random person, or save a memorable quote
16:42:13 <lispy> @palomer
16:42:14 <lambdabot> blargh!
16:42:21 <lispy> @palomer
16:42:21 <lambdabot> hrmph
16:42:22 <SamB> okay....
16:42:33 <SamB> @remember ihope Somebody tell me how to pop quotes into lambdabot, quick!...
16:42:34 <lambdabot> Unknown command, try @list
16:42:41 <SamB> okay, its officially broken!
16:42:48 <SamB> I copied and pasted from the help text
16:42:53 <lispy> @keal
16:42:54 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
16:43:10 <SamB> @. leet keel for best enjoyment
16:43:11 <lambdabot> compose module failed: Parse error: "leet"
16:43:15 <SamB> @. leet keal for best enjoyment
16:43:16 <lambdabot> compose module failed: Parse error: "leet"
16:43:22 <SamB> oh, right...
16:43:26 <SamB> @. elite keal for best enjoyment
16:43:27 <lambdabot> 4cTuA|lY I+ bUG IN /\/\A+H
16:43:42 <lispy> awesome
16:44:01 <lispy> @. elite keal
16:44:01 <lambdabot> keA| An9rY @ doNS
16:44:34 <SamB> the crazy thing is, keal is apparantly actually a person! either that, or a *very* good bot...
16:44:39 <lispy> brings a new meaning to the phrase, "Go away before I replace you with a very small script"
16:45:01 <PeterK> what's a good way to read in a 10MB text file in Haskell?
16:45:03 <lispy> yeah, i was here for the keal episode
16:45:10 <SamB> well, its not exactly a replacement, just a memento
16:45:14 <lispy> PeterK: FPS
16:45:17 <ihope> PeterK: getContents?
16:45:24 <SamB> ihope: you crazy
16:45:26 <ihope> Or FPS.
16:45:36 <SamB> that would take like, oh...
16:45:51 <lispy> PeterK: will it always be 10MB? if so, mmap would work quite well.  If the file can vary is size, don't use mmap
16:45:54 <ihope> Haskell's lazy!
16:46:13 <SamB> well, at three words a (:), and two a C#, that would take...
16:46:40 <PeterK> can FPS be compiled with GHC 6.4.1?
16:46:58 <lispy> yup, at least darcs uses an older version that can
16:46:59 <SamB> > (3 + 2)*4 * 10*(1024*1024)
16:47:01 <lambdabot> 209715200
16:47:28 <lispy> about 200MB?
16:47:33 <SamB> apparantly
16:48:10 <SamB> of course, that is assuming that it would all be in memory at once
16:48:14 <lispy> well, hope that you're consuming the file lazily
16:49:22 <SamB> so it depensd on what kind of file it is and what you want to do with it...
16:49:48 <PeterK> I want to read the individual characters sequentially. all of them, but probably load the whole thing into memory first.
16:51:03 <PeterK> I want to calculate the frequency of each character bigram in the text (the frequency that B comes after I, that a space comes after S, that T comes after G, etc)
16:51:18 <lispy> PeterK: to show yourself that lazily reading it is an option you could try using getContents and running "words" on the file since that has to look at every character
16:51:30 <lispy> oh hmmm
16:51:51 <ihope> Laziness sounds like it'd work.
16:51:54 <lispy> i'd say a combination of mmap and FPS would be what youw ant
16:52:14 <SamB> bigrams?
16:52:16 <lispy> ihope: i think laziness might cause too much data sharing here
16:52:22 <PeterK> yes SamB
16:52:35 <SamB> hmm...
16:52:38 <lispy> bi -> 2, gram -> characters?
16:52:55 <PeterK> in this case, yes. though perhaps bigraphs is the right word
16:53:18 <lispy> i hear the term ngrams sometimes
16:54:24 <PeterK> http://en.wikipedia.org/wiki/Bigram]
16:54:50 <PeterK> without the typo: http://en.wikipedia.org/wiki/Bigram
16:54:53 <SamB> > let bigrams (x:xs@(x':_)) = (x,x'):bigrams xs; bigrams [_] = [], bigrams [] = [] in "text" -- ?
16:54:54 <lambdabot>  parse error on input `,'
16:55:07 <SamB> > let bigrams (x:xs@(x':_)) = (x,x'):bigrams xs; bigrams [_] = []; bigrams [] = [] in "text" -- ?
16:55:08 <lambdabot> "text"
16:55:13 <SamB> hmm...
16:55:24 <SamB> > let bigrams (x:xs@(x':_)) = (x,x'):bigrams xs; bigrams [_] = []; bigrams [] = [] in bigrams "text" -- ?
16:55:25 <lambdabot> [('t','e'),('e','x'),('x','t')]
16:55:32 <SamB> like those?
16:55:53 <PeterK> yes, though i'd want to count the number of ('t', 'e') bigrams
16:56:09 <PeterK> and all of the 27*27 bigrams
16:56:16 <lispy> @hoogle occurs
16:56:17 <lambdabot> No matches found
16:56:26 <SamB> well, getting a (lazy) list of bigrams is a good start to counting each kind
16:56:36 <lispy> yeah, then you could nub the list
16:56:48 <ihope> Nub is... no.
16:56:54 <lispy> no nub?
16:57:02 <ihope> That'll remove duplicates.
16:57:16 <lispy> right, you'd want a copy of the unique bigrams
16:57:22 <ihope> Removing duplicates is not good when you want to count how many of each thing there is...
16:57:22 <lispy> oh, but you could just make that manually
16:57:25 <SamB> you could do something with an array or a map, then
16:57:35 <PeterK> I want to know whether some are 0 too. (e.g., no occurences of ('x','x'))
16:57:47 <SamB> so maybe an array?
16:57:57 <PeterK> I want a matrix of sorts.
16:58:08 <lispy> what about sorting the list of bigrams?
16:58:18 <lispy> that's nlogn
16:58:18 <SamB> sorting? crazy?
16:58:39 <lispy> well it would make counting easier
16:58:54 <lispy> and you could sort the list on inserting an element
16:59:14 <SamB> > ['a'..' ']
16:59:15 <lambdabot> ""
16:59:20 <SamB> > [' '..'z']
16:59:21 <lambdabot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
16:59:28 <SamB> hmm.
16:59:30 <PeterK> it should be done in n time, where n is the number of characters in the text
16:59:52 <ihope> So be there Word# literals?
17:00:01 <SamB> guess you'll need to do some sort of conversion, or you could use a 256x256 array
17:00:08 <SamB> um
17:00:12 <lispy> i don't know the asymptotic complexity of inserting n times into a sorted list, but that sounds like O(n) to me
17:00:21 <SamB> hmm.
17:00:21 <PeterK> I'm reducing the text to the 26 letters (case insensitive) and 'other'.
17:00:37 <SamB> ihope: just use the conversion primitive on an Int#?
17:01:36 <SamB> PeterK: well, it would help if you had an alphabet that was consecutive
17:01:52 <PeterK> the letters 'A'..'Z' plus the 'space' (other)
17:02:15 <SamB> well, if you notice, the space is nowhere near the 'A'..'Z'
17:02:34 <PeterK> ok
17:02:47 <SamB> if you used an @ symbol, that would work nicely ;-)
17:03:06 <SamB> you could transform it back in the end, of course
17:03:16 <lispy> so replace @ with ' ' and vice versa?
17:03:35 <PeterK> I am dealing with natural language texts (books), which have multiple symbols other than letters; I am simply ignoring the diversity of symbols other than the 26 letters, lumping them together with the space.
17:05:18 <lispy> so i guess everything in the set "space and other" could be replaced by a single symbol
17:07:59 <SamB> > array
17:08:00 <lambdabot>   add an instance declaration for (Show ((i, i) -> [(i, e)] -> Array i e))
17:09:06 <SamB> erm, well, we'd probably want to use STArray or something, but...
17:09:23 <gadolin> is there a standard function that would return Bool signifying if a Maybe value is Nothing or Just?
17:09:53 <SamB> @hoogle Maybe a -> Bool
17:09:54 <lambdabot> Maybe.isJust :: Maybe a -> Bool
17:09:54 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
17:09:56 <lispy> i find that in haskell an array is usually the wrong data structure unless you're caching something there that you don't really want to update...ever
17:10:36 <gadolin> @hoogle Maybe a -> a
17:10:37 <lambdabot> Maybe.fromJust :: Maybe a -> a
17:10:37 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
17:10:37 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:10:39 <SamB> actually, an STUArray would do fine
17:30:02 <ihope> @type quot
17:30:03 <lambdabot> forall a. (Integral a) => a -> a -> a
17:30:10 <ihope> @index quot
17:30:10 <lambdabot> Prelude
17:30:17 <ihope> @docs Prelude
17:30:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:30:36 <ihope> > 8 `quot` 2
17:30:37 <lambdabot> 4
17:34:07 <ihope> Hmm...
17:34:18 <ihope> > case 5 of 2+3 -> ":-)"
17:34:19 <lambdabot>  Parse error in pattern
17:34:23 <ihope> Aww.
17:37:37 <dons> > case 5 of n+3 -> n -- ?
17:37:39 <lambdabot> 2
17:37:45 <dons> its all very magic
17:38:15 <araujo> dons!
17:38:26 <dons> morning araujo  :)
17:38:55 <araujo> dons, :-)
17:40:43 <PeterK> I'm having a hard time figuring out how to install the FPS library on this Windows XP machine (ya, I know, upgrade the OS...other than that...). Are there instructions for doing this?
17:40:47 <ihope> So it only works if you actually have a variable there?
17:41:07 <ihope> > case "foo" of read "\"foo\"" -> "bar"
17:41:08 <lambdabot>  Parse error in pattern
17:41:28 <ihope> > case "foo" of read x -> x -- not that I expect this to work
17:41:29 <lambdabot>  Parse error in pattern
17:42:55 <dons> PeterK, you follow the normal Cabal build procedure.
17:43:05 <dons> its in the README, or is that not working?
17:43:28 <dons> you have ghc 6.4.* installed?
17:43:35 <PeterK> i am reading the readme, it appears to require me to run the haskell script setup.hs ... i have ghc 6.4.1
17:43:44 <dons> yep.
17:43:50 <dons> you can also just compile the script, if you like
17:43:58 <PeterK> i'll do that
17:44:01 <dons> ghc -o setup Setup.hs -package Cabal, iirc
17:44:31 <dons> I'm not sure if FPS has been used on windows yet. I think it's ok, but we'll see.
17:46:54 <ihope> Okay. Don't tell me nobody's ever tried to open a terminal window using Haskell before...
17:47:20 <dons> ihope, I saw your question. there's no library I know of for doing this.
17:47:29 <dons> but by 'terminal' do you just mean 'xterm' ?
17:48:52 <aufrank> @doc instance
17:48:53 <lambdabot> instance not available
17:49:37 <aufrank> how do I make sure one of my types implements Ord?
17:50:27 <dons> deriving Ord
17:50:37 <aufrank> @doc deriving
17:50:37 <lambdabot> deriving not available
17:50:53 <aufrank> am I doing this documentation thing wrong?  help me out here bot!
17:50:58 <dons> you add 'derivign (Eq,Ord) ' yo the end of your type decl. 
17:51:11 <dons> yeah, @doc is for lookign up functions, not language features
17:51:15 <aufrank> oh
17:51:16 <aufrank> ok
17:51:19 <dons> you'll have to check the report for the details
17:51:22 <aufrank> :)
17:51:23 <dons> @where haskell98
17:51:24 <lambdabot> http://haskell.org/onlinereport/
17:51:44 <dons> vincenz, ping
17:52:07 <ihope> dons: what's xterm? :-)
17:52:13 <ihope> s/)/P/ once again
17:52:21 <dons> :P
17:52:37 <dons> you'll have to code up this function yourself. but it does sound very useful
17:52:57 <ihope> Where would I start, then?
17:53:04 <dons> maybe you could stick it in a cabalised System.Term module?
17:53:07 <dons> so others can use it.
17:53:22 <dons> ihope, i don't know exactly what you're trying to do...
17:53:42 <dons> can't you talk to terminals over /dev/* something*
17:53:56 <ihope> What if I'm not using a Unix thingy?
17:54:04 <dons> no idea then
17:55:15 <SamB> what else is there?
17:55:23 <dons> perhaps look for a python or perl or C library that does this , and bind to it, or follow their impl.
17:55:40 <ihope> SamB: windows
17:55:58 <dons> i'm thinking that it might be very simple, in fact. just a couple of lines.
17:56:01 <SamB> and windows supports the use of text?
17:56:11 <ihope> Yes...
17:56:17 <ihope> It has terminal windows...
17:56:21 <dons> ? no. you have to send everything in matrix-style encoded glyphs
17:56:39 <ihope> Um...
17:56:55 <dons> this design decision is phase 1 of the MS uber-plan for enslavign humanity
17:56:59 <SamB> ask ReactOS peoples how that stuff works?
17:57:00 <dons> *little known fact
17:57:03 <SamB> they probably know ;-)
17:57:41 <ihope> You're saying that I have to pretty much grab a font and do all the scary stuff myself?
17:57:48 <dons> no no.
17:57:55 <dons> *I* was joking.
17:58:04 <SamB> the terminal windows are handled out of process ;-)
17:58:05 <ihope> Oh.
17:58:06 <SamB> more I know not
17:58:15 <SamB> or at least, in another thread
17:58:15 <dons> i'm almsot certain its jsut a matter of calling the terminal program, and talkign over whatever handle it uses
17:58:29 <dons> via a pipe
17:58:34 <SamB> again, #reactos probably has people who know this stuff ;-)
17:58:40 <ihope> So where's the Haskell Win32 stuff?
17:58:42 <dons> and google, ihope.
17:59:04 <dons> libraries/Win32/
17:59:22 <ihope> @docs Win32
17:59:22 <lambdabot> Win32 not available
17:59:43 <dons> go to haskell.org, click on 'standard libraries', then Win32, I think
18:00:09 <dons> @docs System.Win32
18:00:09 <lambdabot> System.Win32 not available
18:00:16 <dons> bah bah. 
18:00:23 <ihope> I don't see any Win32.
18:00:47 <dons> its in the src, at least. you can always read the src.
18:01:11 <dons> yeah, its not on haskell.org. weird
18:01:25 <dons> docs msut have been generated on linux..
18:02:04 <SamB> yeah! they must've been...
18:02:08 <bolrod> @hoogle [IO a] -> IO [a]
18:02:09 <lambdabot> No matches, try a more general search
18:02:13 <bolrod> is that possible?
18:02:22 <dons> @type sequence
18:02:24 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
18:02:24 <mux> @type sequence
18:02:26 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
18:02:31 <mux> too slow :)
18:02:35 <gadolin> is it possible to have where clause for only one guard in function definition?
18:02:38 <dons> you're dead, brother.
18:02:49 * dons blows smoke from his typechecker
18:02:51 <ihope> dons was first!
18:02:57 <bolrod> :p
18:02:58 <PeterK> when trying to install FPS, I get the message '"Could not find module 'System.Posix'"
18:03:07 <mux> *BANG *BANG* *BANG* *CLICK* *CLICK*
18:03:13 <dons> PeterK, urgh. :(
18:03:18 <dons> gimme a sec to consider this.
18:03:34 <ihope> So why's the Group Health Cooperative stealing all Google's... stuff?
18:03:59 <dons> PeterK, ah, no problem. remove the -DUSE_MMAP from fps.cabal
18:04:13 <PeterK> k
18:04:46 <dons> and also ", unix" from the line Build-depends: in fps.cabal too.
18:05:07 <dons> (better is to use the no-mmap .cabal file. are you using fps 0.2 ?) 
18:05:16 <PeterK> yes, fps 0.2
18:05:29 <dons> but you picked the mmap cabal file first?
18:05:37 <PeterK> yes
18:05:51 <dons> ok. bad choice for windows :)
18:05:58 <dons> won't matter much, though.
18:06:09 <dons> just use the other .cabal file
18:06:10 <SamB> bbbbut, Windows has mmap!
18:06:15 <dons> I know.
18:06:21 * SamB teases dons
18:06:25 <dons> #if defined(USE_MMAP)
18:06:25 <dons> import System.Posix             (handleToFd)
18:06:26 <dons> #endif
18:06:32 <dons> that's the only thing
18:06:41 <dons> probably I could write a portable version, hmm.
18:06:42 <SamB> oh, they don't have one of those for windows?
18:06:50 <dons> I wonder.
18:07:10 <dons> I see : Types.hs:handleToWord = castPtrToUINT
18:07:18 <dons> so maybe.
18:07:27 <dons> unsafeCoerce# might work too.
18:09:13 <dons> oh, actually, handleToFd is non trivial
18:09:53 <dons> PeterK: is it built?
18:09:57 <SamB> well, lets see. you can't just use fileno...
18:10:33 <PeterK> not yet...i get errors when i remove -DUSE_MMAP, on line 37, 'PROT_READ' undeclared, 'MAP_READ' undeclared
18:10:50 <dons> hmm.
18:10:55 <dons> did you rerun ./configure ?
18:11:00 <dons> sorry, setup configure ?
18:11:03 <PeterK> yes
18:11:44 <dons> ah, my fault. you can edit cbits/fpstring.c and wrap my_mmap in a #if defined(USE_MMAP)
18:12:01 <PeterK> ok
18:12:13 <aufrank> alright, I've got a record type with a field named "rest" of type Double
18:12:24 <aufrank> and I try to assign a default to it
18:12:48 <aufrank> data MyNode = MyNode { rest :: Double } -- and so on
18:13:01 <aufrank> aNode = MyNode { rest = -.1 }
18:13:10 <aufrank> and I get an error that - is not in scope
18:13:18 <dons> -1 should do it.
18:13:23 <dons> you made up some syntax there :)
18:13:28 <dons> > -1 :: Double
18:13:30 <lambdabot> -1.0
18:13:40 <dons> > -0.1 :: Double
18:13:42 <lambdabot> -0.1
18:13:42 <aufrank> > -0.1 Double
18:13:43 <lambdabot>  Not in scope: data constructor `Double'
18:13:50 <aufrank> man, dons got me too
18:14:28 <aufrank> :P
18:14:34 <aufrank> thanks dons
18:15:13 <dons> PeterK: I've jsut pushed a patch to handle the cbits mmap issue. 
18:15:28 <dons> you could pull that, rather than hacking around (though you're probably already done?)
18:16:10 <PeterK> dons: not done yet
18:16:35 <dons> maybe just 'darcs pull' then?
18:16:48 <aufrank> > 0 :: Double
18:16:49 <lambdabot> 0.0
18:17:56 <PeterK> ok, i might have installed it now
18:18:06 <dons> it built?
18:18:09 <PeterK> yes
18:18:34 <dons> you can check the install with: cd tests ; runhaskell Quick.hs
18:18:46 <dons> will run a few 10s of thousand  tests :)
18:19:01 <PeterK> #include <sys/mman.h> and char *my_mmap(int len, int fd) {} were put in #if's
18:19:11 <aufrank> does the guy who maintains haskell-mode ever show up in channel?
18:19:22 <SamB> maintains?
18:19:23 <dons> PeterK: ok . good.
18:19:37 <SamB> you are implying that it does not gradually get worse and worse?
18:20:00 <aufrank> SamB: I don't know much about that, I've just started in on this whole haskell thing
18:20:14 <PeterK> the output is ...... (16800) from running that
18:20:21 <aufrank> but I did want to talk to that guy and wondered if I might find him here
18:20:22 <SamB> or perhaps simply stay as-is
18:20:29 <aufrank> otherwise I'll email him :)
18:20:39 <SamB> probably you need to email him
18:20:44 <aufrank> thanks :)
18:20:55 <dons> good :) though I get  (17200). any failures? (i.e. non '.') ?
18:20:59 <SamB> because you probably wouldn't know what his nick was if he *did* IRC
18:21:05 <PeterK> no reported failures
18:21:19 <aufrank> no, but I could ask and hope for you community-types to let me in on the secret ;)
18:21:24 <SamB> dons: are there mmap-related tests?
18:21:31 <dons> there are if you install mmap
18:21:53 <dons> PeterK: you could also try: make run, if you've got m4 and make installed.
18:22:00 <dons> will run a few extra tests.
18:22:04 <SamB> also, he might not want to admit that he is responsible for it here, or we'd deluge him with requests that he improve the indentation
18:22:20 <dons> but if  the QC test s pass, then its almsot certainly ok.
18:22:22 <aufrank> SamB: are you him?  is that what's going on here?
18:22:31 <SamB> no!!
18:22:41 <aufrank> :P
18:22:43 <SamB> why, what is his name ;-)?
18:22:51 <dons> SamB, finally revealed! the maintainer of haskell-mode!!
18:22:59 <dons> we have *you* to blame.
18:24:18 <aufrank> alright, /me has to go play frisbee anyway
18:24:34 <SamB> I meant his IRC nick might be a secret identity, with no proper realname
18:25:02 <aufrank> well, his email address is right there on the download page
18:25:09 <aufrank> so I reckon I'll try that ;)
18:25:25 <SamB> yeah, we are too lazy to bother emailing him, you see ;-)
18:25:48 <aufrank> he responded quickly last time I did it :)
18:25:52 <SamB> something to do with the full laziness transformation, perhaps
18:26:39 <aufrank> have a good evening folks
18:27:55 <SamB> you play frisbee in dark?
18:28:25 <SamB> in fact, I am too lazy to even download haskell-mode myself
18:38:44 * bolrod smashes wxhaskell into oblivion and goes to sleep
18:41:03 * SamB thinks GHC's garbage collector should pay more attention to the amount of RAM available and stuff like that...
18:42:15 <bolrod> nah
18:42:27 <bolrod> it should be attatched to a webcam
18:42:44 <SamB> which it uses to detect when the user is angry?
18:42:47 <bolrod> and define garbage collection on the messieness of the room
18:42:58 <bolrod> haha
18:42:59 <bolrod> :p
18:43:04 <bolrod> that too
18:43:14 <bolrod> like you try to compile.. and after 10 times
18:43:18 <bolrod> "OK OK!! You win"
18:43:20 <bolrod> and it compiles
18:43:29 <bolrod> that would be neat
18:43:45 <greenrd> Cool: liftM in the reader monad is (.), liftM2 is (.) . (.), liftM3 is (.) . (.) . (.), etc.
18:44:02 <SamB> more like you try to compile something, and it is taking so long... so GHC decides to turn down the optimization level?
18:44:37 <SamB> would be especially nice if it could also remind GCC that it isn't a C++ compiler
18:44:48 <greenrd> And return is const (the K combinator from lambda calculus), and ap is the S combinator from lambda calculus
18:45:15 <bolrod> SamB: because? :)
18:45:27 <greenrd> would be fun to try and define the basic functions such as const and (.) in terms of the reader monad
18:45:40 <SamB> bolrod: because it might not try so many crazy optimizations on C code then?
18:45:57 <ihope> greenrd: I'd call it combinator calculus.
18:46:01 <greenrd> heh
18:47:21 <bolrod> :)
18:47:25 <SamB> ‚ï∞‚ï¥Specialize
18:47:35 <SamB> oooh look, I can paste from jhc's output now!
18:48:31 <greenrd> So, using Conor McBride's suggested syntax from his Applicative Functors paper, it's possible to write compositions without the . operator
18:48:47 <greenrd> i.e. you can do FORTH in Haskell! ;)
18:49:03 <ihope> What's ‚ï∞‚ï¥?
18:49:20 <ihope> > map fromEnum "‚ï∞‚ï¥"
18:49:21 <lambdabot>  lexical error in string/character literal
18:50:01 <greenrd> (he claims his syntax can be hacked on using typeclasses, without extending the language)
18:50:25 <SamB> ihope: well, it is used in drawing statistics trees
18:50:35 <bolrod> > fromEnum 'c'
18:50:37 <lambdabot> 99
18:50:44 <greenrd> I just think that's really fun. I might have to try it myself.
18:50:47 <SamB> PostProcess
18:50:47 <SamB> ‚ï∞‚ï¥E
18:50:47 <SamB>   ‚ï∞‚ï¥LetFloat
18:50:47 <SamB>     ‚îú‚ï¥atomizeAp: 45
18:50:47 <SamB>     ‚ï∞‚ï¥coalesce.fromCase: 1
18:50:57 * ihope claps
18:52:33 <bolrod> someone know if I can put a button on a scrolled window in wxhaskell?
18:52:50 <bolrod> its so stupid.. I can put it right there.. and then WHAM  it removes the scrollbars
18:52:55 <bolrod> ;/   that is NOT! what I want 
18:53:55 <SamB> is there more content than will fit in the window?
18:54:37 <bolrod> yes
19:59:49 <DukeDave> bolrod, what does the button do?  if it's just an OK then you could replace it with a textbox and "type 'ok' to continue" and blag that it's an extra level of confirmation :)
20:20:11 <newsham> hi
20:20:36 <mwc> good day newsham 
20:21:20 <newsham> here's something thats bothering me.  IO a operations define order of operation.  what if you have something like   a <- getByte; b <- getByte; dostuff a b
20:21:32 <lispy> > let mylines s = fst (break (=='\n') s) ++ mylines (snd (break (=='\n') s)) "aoeuaou"
20:21:33 <lambdabot>  parse error on input `}'
20:21:38 <newsham> in actuality the ordering of a and b might be completely independant of each other
20:22:00 <newsham> but using the IO monad forced the programmer (thats me) to specify an order artificially
20:22:09 <SamB> newsham: yeah, it would be nice if there was a way to express that
20:22:14 <lispy> > let mylines s = fst (break (=='\n') s) ++ mylines (snd (break (=='\n') s)); mylines "aoeuaoeu"
20:22:15 <lambdabot>  parse error (possibly incorrect indentation)
20:22:25 <Cale> well, IO tends to be noncommutative
20:22:30 <lispy> hmm...i'm not doing that tright
20:22:31 <SamB> however, that wasn't much of an example
20:22:47 <newsham> its nice when IO ordering specifies an ordering that is necesssary
20:22:52 <newsham> but not when its not :)
20:22:55 <dons> newsham, its all for sequencing. if you want things done in parallel, but with side effects, you'll need forkIO, perhaps?
20:22:58 <Cale> do a <- getByte; b <- getByte; dostuff a b  is very rarely equivalent to  do b <- getByte; a <- getByte; dostuff a b
20:22:59 <dons> or just have pure code.
20:23:01 <SamB> lispy: need in
20:23:11 <lispy> oh right
20:23:27 <lispy> my next question is: whatam i missing as a base case
20:23:39 <lispy> > let mylines s = fst (break (=='\n') s) ++ mylines (snd (break (=='\n') s)) in mylines "aoeuaoeu"
20:23:43 <lambdabot> Terminated
20:23:50 <dons> take that!
20:23:50 <newsham> I dont necessarily want them done in parallel.  but i would like it to be known that they are not dependent :)
20:24:12 <dons> if they're really independent, stick them in ST instead
20:24:12 <SamB> mylines [] = []?
20:24:21 <dons> and use runST
20:24:30 <dons> in separate STs
20:24:30 <lispy> SamB: i tried that, i think my mistake is using s again in the recursive part
20:24:33 <newsham> dons: i dont understand.
20:24:46 <Cale> There's no way to know if two IO actions are independent, since they can do anything.
20:25:01 <newsham> cale: right.  thats what i am disliking.
20:25:06 <Bobstopper> how is forall used in type declarations?
20:25:14 <SamB> if they are independant, they had bettre be unsafePerformIO'd if you care!
20:25:15 <Cale> You can construct smaller monads with restricted operations
20:25:15 <newsham> IO's this big bad bag of tricks, and when i have to use it, i have to use it all
20:25:20 <dons> so use the ST monad to force a bit more discipline.
20:25:20 <mwc> yes
20:25:29 <mwc> that's why the IO monad can guarantee all the safety it does
20:25:31 <lispy> > let {mylines [] = []; mylines s = fst (break (=='\n') s) : mylines (snd (break (=='\n') s))} in mylines "aoeuaoeu"
20:25:32 <lambdabot> ["aoeuaoeu"]
20:25:39 <lispy> oh it worked...then i was wrong before
20:25:40 <mwc> an IO computation is exposed to the full ugly world
20:25:42 <Cale> ST is for pure computations though
20:25:47 <dons> or otherwise, use normal concurrency methods, like MVars and forkIO, to program safe, non-sequencial code
20:25:56 <SamB> Cale: well duh
20:26:05 <SamB> it lets you use mutable state in a pure way
20:26:06 <lispy> > let {mylines [] = []; mylines s = fst (break (=='\n') s) : mylines (snd (break (=='\n') s))} in mylines "aoeuaoeu\nsthst"
20:26:07 <lambdabot> ["aoeuaoeu","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","
20:26:07 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
20:26:07 <lambdabot> ,"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",
20:26:07 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","
20:26:10 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
20:26:11 <Cale> If you want, you can construct smaller monads from IO which are still allowed to do *some* IO.
20:26:11 <dons> yeah, it seems unlikedly that getChar or whatever is going to be ever safe to swap the order of.
20:26:12 <newsham> dons: seems like all that heavy machinery will obfuscate rather than clarify
20:26:13 <lambdabot> [6 @more lines]
20:26:20 <dons> heavy?
20:26:28 <dons> certainly for forkIO and such
20:26:29 <lispy> SamB: so that's the case i need a basecase for :)
20:26:42 <newsham> mvars?  forkio?  new monads?
20:26:52 <dons> new monads is not so heavy.
20:27:05 <dons> you want the full power of IO, but not the safety guarantees of sequencing?
20:27:05 <mwc> newsham, if the order was truly independent, you could write it as : do { let { a = foo; b = bar }; doStuff a b}
20:27:09 <Cale> You just newtype IO, and only lift operations that you want.
20:27:37 <mwc> the fact that the computation of the values of a and b are IN the IO monad to begin with is a reflection of them not necissarily being sequence independent
20:27:47 <lispy> oh, if fst (break ...) is "" then i should stop
20:27:51 <lispy> that's what i must be missing
20:27:51 <SamB> if you want no safety guarantees, than you want unsafe* ty
20:28:03 <newsham> mwc: yes.  true.  but I may know better (sure, i could unsafeperformio to flaunt it)
20:28:09 <mwc> you may
20:28:12 <mwc> but does it matter/
20:29:00 <SamB> if you must have the burden of proof, you must have unsafe*
20:29:09 <dons> anyway, so there's lots of techniques, the best being a separate monad, to allow safe subsections of IO to be partitioned and made non-sequential.
20:29:13 <newsham> i dunno.  i'm not writing code at the moment, but i'm thinking about it, and i think this io stuff is giong to make what is almost a fairly simple and elegant design look really horrid (and overly constrained) due to the rare occasionally IO
20:29:21 <Cale> basically, if you're allowed to write to things and then read from them again in one monad, then you can't commute actions in the monad.
20:30:12 <dons> newsham, maybe if its very rare, you can use an unsafe mechanism (i.e. just print statements)?
20:30:26 <dons> or as we usually do, have a monadic wrapper do the small sequential parts
20:30:36 <Cale> What IO are you doing, and why does its rarity make it awkward?
20:30:38 <newsham> but if i later change something to not be rare, then i have to redo the rest.
20:30:45 <dons> its a matter of working out the structure, I think.
20:30:46 <newsham> i'm thinking of web servers again
20:31:03 <newsham> at its core you have output = f url
20:31:06 <dons> hmm. I'd suspect you might need a monad ofver IO there.
20:31:17 <dons> since there's umm a lot of IO
20:31:32 <dons> similar to lambdabot, probably
20:31:34 <newsham> if the web content was completely static (ie. you preread all of the content and did all your IO up front) the rest would be very elegant
20:31:41 <Cale> Ideally, you move all IO to the "top" of your program, and write the computations which are actually doing something with the data as pure functions.
20:32:14 <newsham> but then you'd bascally have your entire web content mirrored in your server process
20:32:35 <Cale> If you're afraid about performance, unsafePerformIO has a slightly more cautious cousin called unsafeInterleaveIO
20:32:37 <dons> don't understand that last point? can you elaborate
20:32:57 <dons> (about the entire web content mirrored..)
20:32:59 <Cale> unsafeInterleaveIO :: IO a -> IO a
20:33:24 <newsham> content <- readAllWebPages '/web/root'
20:34:03 <Cale> but it's not the identity map -- the returned action will return a value immediately when executed, and defer the real execution of the IO to when that value is forced.
20:34:04 <newsham> req <- readReq; writeResp $ calcContent req
20:34:16 <newsham> calcContent req content
20:34:25 <RyanT5000> is there a version of Map, Set, etc. that uses classes?
20:35:06 <mwc> I thought that Set a required (Ord a)
20:35:12 <mwc> is that what you mean?
20:35:12 <Cale> RyanT5000: not yet, everyone wants one, nobody can agree on anything
20:35:20 <RyanT5000> i want to define a class MyClass c where someFunc :: (Set s) => c -> s
20:35:25 <Cale> oh
20:35:39 <Cale> Well, Set itself isn't a class of course :)
20:35:41 <RyanT5000> right
20:35:46 <RyanT5000> but i mean, something analogous to that
20:36:02 <Cale> yeah, there's no generic container classes in GHC yet.
20:36:08 <RyanT5000> i see
20:36:15 <Cale> there are some libraries out there
20:36:16 <RyanT5000> well they won't be too hard to make
20:36:48 <Cale> What will be in the Set class?
20:36:58 <RyanT5000> a minimal set of operations
20:37:11 <RyanT5000> probably empty, add, remove, isMember
20:37:19 <dons> "nobody can agree on anything" -- a bit like the Sequence stuff
20:37:28 <RyanT5000> i know this leaves something to be desired in terms of optimization
20:37:32 <newsham> dons: i disagree
20:38:18 <RyanT5000> although i'm not actually sure this is the right approach at all
20:38:24 <sjanssen> dons: there is controversy over Data.Sequence?
20:38:25 <dons> I guess at least we do have Data.Sequence now in cvs. which is good.
20:38:33 <dons> well, there was for ages. :)
20:38:36 <RyanT5000> essentially what i have is a Cell class, which has several Sets, which represent certain properties of a cell on a game board
20:38:49 <dons> people have been asking for it for years, and it just wouldn't appear for some reason
20:38:50 <RyanT5000> e.g.: the models on that square, the field effects (area-of-effect spells) affecting it
20:39:06 <PeterK> D&D in Haskell?
20:39:12 <RyanT5000> nah, my own game
20:39:28 <RyanT5000> simmilar to galciv, civ, and master of orion
20:39:40 <RyanT5000> (with, of course, substantial differences as well)
20:39:46 <PeterK> oh...turn based strategery
20:39:49 <RyanT5000> yah
20:40:38 <RyanT5000> in any case, i could have a function on Cells which returns a new Cell with a model added, e.g.:: Model -> Cell -> Cell
20:40:51 <RyanT5000> but i'd really rather expose the interface of a Set
20:41:25 <RyanT5000> the problem is that i possibly want to receive updates from the set
20:41:46 <SamB> dons: CVS?
20:42:07 <dons> you know what I mean :)
20:42:17 <RyanT5000> i.e.: maybe adding that ship to that cell changes some other property of the cell, or maybe the cell keeps an index of the models in it
20:42:32 <newsham> which repository?  darcs on haskell.org?
20:42:45 <dons> yep.
20:43:11 <RyanT5000> so, am i forced to reproduce the interface of a Set, or to reparse the whole Set once it is changed?
20:43:21 <RyanT5000> i think this is a pretty general problem
20:44:08 <RyanT5000> in OOP languages i dealt with it by, e.g., returning a polymorphic object whose accessors notified the master object as well as changing the hidden object
20:50:05 <newsham> data Mycell a  = Mycell { items :: Set a, weight :: Int };    instance Set (Myset a) where  add (Set s n) a = Set { add s n, n+1 } 
20:50:06 <newsham> ?
20:50:08 <newsham> like so?
20:50:35 <newsham> err.. Mycell instead of Set {}
20:50:44 <newsham> and (Mycell s n)
20:51:15 <newsham> seems analogous to how you'd do it in OO --  do your update by calling the superclass's method and adding on whatever new semantics you need
20:52:06 <RyanT5000> yeah, i'm not even sure, at this point, that my "problem" is well-formed
20:52:42 <RyanT5000> especially with immutable objects
20:53:08 <RyanT5000> you necessarily have to go through the master object to access the child object when they're immutable
20:53:14 <newsham> eh, how different is    foo.add(x)  vs.   foo' = add foo x  ?
20:53:33 <RyanT5000> no, that's not what i'm talking about
20:53:50 <RyanT5000> the difference is between ship.Models.add(x) and ship.addModel(x)
20:54:22 <newsham> you lost me.
20:54:26 <newsham> but i gotta go anyway..  have fun
20:54:33 <RyanT5000> you have to assume mutable objects
20:54:35 <RyanT5000> thanks :)
20:58:00 <mwc> Anybody tried to rewrite the shootout benches for concurrency with the new 6.4.2 STM?
20:58:17 <dons> yeah, there's been a couple of attemtps
20:58:29 <dons> slightly slower, iirc
20:59:31 <mwc> too bad
21:02:05 <dons> I'm looking forward to rewriting k-nucleotide, regex-dna, reverse-complement and sum-file in FPS.
21:04:13 <Korollar1> I'm more interested in mandelbrot
21:05:46 <goltrpoat> dons:  didn't they have all four of those in the ultimate programming language showdown or whatever it was called?
21:06:03 <dons> hmm. you mean the great language shootout?
21:06:06 <dons> ?shootout
21:06:07 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
21:06:09 <goltrpoat> yes that.
21:06:21 <goltrpoat> sorry, bit out of it right now.
21:06:22 <dons> yes. theyre' in there. and we had to code up our own copy of fps, basically.
21:06:30 <dons> it would be better to use FPS for the task
21:06:44 <goltrpoat> ok i thought by FPS you meant FPs
21:06:45 <goltrpoat> FPS?
21:06:48 <dons> much much shorter code. and probably faster too.
21:06:50 <dons> ?where fps
21:06:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:07:13 <dons> right. should be known as Data.ByteSequence or something.
21:07:15 <goltrpoat> oh, rock.
21:09:59 <dbrock> I can see why there are only countably many expressions of type [Bool], but why do uncountably many values inhabit the same type?
21:10:57 <dbrock> (SPJ et al. say so in the introduction to ``Haskell is Not Not ML'')
21:11:05 <dons> due to bottom?
21:11:26 <goltrpoat> ive been looking for stuff like that..  basically, ive been thinking about how i'd write a chess program in haskell for a couple of months now.  there are some difficulties in the sense that chess engines have to be very fast at what they do (even if they are doing something dumb) -- because at millions of positions per move, basically every cycle counts.  there's a stupid amount of fairly silly-looking optimizations that go a lon
21:12:05 <dons> goltrpoat: wouldn't the chess board do very little IO though? and not use many strings at all?
21:12:16 <dons> it'd all be abstract data 
21:12:32 <Korollary> dbrock: I don
21:12:33 <dons> (I think haskell woudl be good for chess, btw. lots of symbolic manipulation)
21:12:43 <Korollary> dbrock: I don't understand the 'uncountably many values' bit
21:12:57 <goltrpoat> no, it's not the board.  one example is the principal-variation search, and/or iterative deepening:  you keep around the "best" line so far, and you use it to do a zero-window search in the first case, or use it to sort the candidate moves in the second case
21:13:07 <dbrock> dons: oh.  Can you explain just a little further?  I'm afraid I'm not actually very familiar with Haskell
21:13:34 <dons> well, the 'bottom' value, 'undefined' is an element of every type. And this is not the case for strict languages, like ML.
21:13:38 <dons> so I guess that's the clue.
21:13:51 <goltrpoat> yes, haskell is borderline perfect for chess, in theory, i just know how performance can make a perfectly well-coded engine completely useless
21:14:18 <dons> for symbolic stuff, should be plenty fine. possibly you'd just drop down to bit ops, I guess.
21:14:26 <dons> couldn't be slower than a C++ version.
21:14:51 <goltrpoat> at the same time, i want to make it pluggable enough to be able to test out random stuff at will, so there are some constraints.  i think something like that could be competitive if done properly, but there is a lot of up front work that is not generally the type of work you'd want to do (eg, as in this case, you don't want to optimize up front, but you more or less have to, to an extent)
21:18:28 <Lemmih> kolmodin: pong.
21:19:10 <dbrock> dons: okay, but that's just one value.  How does that actually make the range of values uncountable?  Are there multiple bottom values that count as distinct?  If not, then why is _|_, [_|_], [True], [False], [_|_, _|_], [_|_, True], ... not an enumeration of [Bool]?
21:19:51 * dbrock is obviously confused
21:19:57 <dons> yeah, I'm not sure why there's even a distinction between 'expressions' and 'values'.
21:20:02 <dons> I'd have to read the article
21:20:12 <dons> but I'm sure bottom has something to do with it :)
21:20:18 <dbrock> okay :-)
21:22:58 <dbrock> this is the relevant paragraph:  ``Rather than attempt to distinguish between inductive types (a la ML) and coinductive types (a la Haskell), we make all types coinductive, with the caveat that types may contain values which have no representation as terms in the language.
21:22:58 <dbrock> ``This is already true of recursive datatypes in Haskell (for example, uncountably many values inhabit the Haskell list type [Bool], but there are only countably many expressions of type [Bool]) and it is true of functions in both ML and Haskell (if S is infinite then S -> Bool is uncountable).''
21:25:21 <goltrpoat> all types are coinductive?  what language
21:25:26 <goltrpoat> sorry, haven't been reading
21:25:58 <dons> perhaps, there's a lot of ways to diverge.
21:26:09 <goltrpoat> or is that just a hypothetical "we make all types *in this paper* coinductive"
21:26:14 <dons> > let f = f in f :: [Bool]
21:26:15 <lambdabot> Terminated
21:26:38 <dons> > let f () = f () in f () :: [Bool]
21:26:42 <lambdabot> Terminated
21:26:43 <dons> > undefined :: [Bool]
21:26:44 <lambdabot> Undefined
21:27:03 <dons> > error "bool " :: [Bool]
21:27:04 <lambdabot>  lexical error in string/character literal
21:27:31 <dons> ah, they're talking about infinite structures aren't they?
21:27:59 <goltrpoat> coinductive is infinite by definition, no?
21:42:06 * aufrank feels like he's making progress!
21:47:43 <dons> cool :)
21:49:30 * lispy is making progress on a new hunk format for darcs
21:49:38 <lispy> "progress"
21:49:44 <lispy> the test suite is broken :)
21:50:12 * dons just tagged fps 0.3 
21:50:25 <dons> some bits faster, some bits cleaner, better docs
21:50:37 <dons> clear statement that you can only use latin-1
21:50:38 <lispy> new format will be hunk <filename> <line#> <length in bytes of old data> <length in bytes of new data> followed by a blob of old and new data
21:50:40 <dons> :}
21:50:41 <aufrank> nice work dons!
21:51:01 <aufrank> I would say dons++ in my usual perl channels
21:51:03 <lispy> dons: awesome
21:51:05 <dons> lispy, ah, that sounds like an easier job to parse.
21:51:20 <lispy> dons: i hope so
21:51:21 <aufrank> but I guess that would be a partial application of list concatenation in these parts?
21:51:27 <dons> hehe
21:51:45 <lispy> dons: but, it won't be as pretty to read, so interactively things need to be fixed
21:52:06 <lispy> friend of mine asked why there is no $DARCS_PAGER env variable
21:52:29 <lispy> makse a lot of sense to have one, then hunks that are interactively dispaled could automatically use a pager
21:53:01 <Korollary> aufrank: here we say
21:53:04 <Korollary> @karma+ dons
21:53:05 <lambdabot> dons's karma raised to 29.
21:53:28 <aufrank> fun fun
21:53:35 <dons> :)
21:53:47 <dons> lispy, sounds like a good idea.
21:54:03 <dons> instead of always piping | less as I do now
21:54:22 <lispy> dons: but how does that work when darcs prompts you?
21:54:40 <lispy> i mean for example, if you are doing a darcs record
21:54:58 <dons> oh, I don't do it then. just on darcs changes,  mostly
21:55:10 <Korollary> Which other apps use a $PAGER env variable?
21:55:13 <lispy> yeah, i use it there too
21:55:20 <dons> Korollary: mailx ?
21:55:23 <lispy> Korollary: um...man? that's the only one i can think of
21:55:41 <dons> yep. 'mail' does.
21:55:49 <dons> and mailx
21:56:16 <lispy> grr...i hate that the darcs test suite is written in perl and i can't read perl :)
21:56:25 <dons> its a bit irksome.
21:56:27 <Korollary> nobody can
21:56:30 * Korollary chuckles
21:56:41 <dons> i've written a huge testsuite for fps now , all in haskell. so its definitely doable..
21:56:53 <dons> there's a lot of QuickCheck parts to the darcs suite, no?
21:56:59 <dons> and then this blackbox testing stuff
21:57:06 <aufrank> implementation question: I've got a data type that has a bunch of fields in a record
21:57:09 <dons> which is a bit harder in haskell. you'd use HUnit for that.
21:57:20 <lispy> a lot of these tests are excuting darcs instead of just testing functions so using a shell scriptng language makes some sense
21:57:20 <aufrank> and I want to run a function over a list of things of this type
21:57:31 <aufrank> I'm only updating one of the fields with the function, though
21:57:32 <dons> hmm, haven't the perl parts of the testsuite been very bug prone themselves...
21:57:36 <dons> due to being in perl?
21:57:48 <lispy> yeah
21:58:01 <dons> aufrank, yep. using a map or such?
21:58:01 <aufrank> is there a convention for whether I should return a list of the values of the field that was updated, or whether I should a return a list of the record type?
21:58:04 <lispy> well, they are very brittle anyway
21:58:07 <aufrank> yeah, that
21:58:28 <lispy> they only want the right answer...sometimes you change the format of some output and the answer doesn't match anymore
21:58:39 <aufrank> so is it spread :: Graph -> [Node] or spread :: Graph -> [Float]
21:58:41 <Saulzar> aufrank, You'd have to use record update syntax at some point ..   foo { bar = "newbar" }
21:58:46 <Korollary> There shouldnt be substantially more tests that probe the app. Most tests should focus on individual modules or funcs.
21:58:54 <dons> aufrank, the former, I would think
21:59:22 <aufrank> so I should update the records (create new records) in place, but only return the result of the computation?
21:59:23 <dons> afternoon Saulzar 
21:59:29 <lispy> Korollary: i won't disagree, but...no one seems to want to cleanup this test suite :)
21:59:39 <dons> aufrank: , how do you propose to update them in place... ?
21:59:51 <dons> variables don't vary, unless you really really try hard.
21:59:57 <aufrank> I corrected myself in parentheses
22:00:05 <aufrank> I thought
22:00:06 <Saulzar> Hi dons.
22:00:26 <aufrank> the record updaet syntax that Saulzar showed creates new records, right?
22:00:29 <Saulzar> Well, if you don't return them they'll be garbage collected never to be seen again :)
22:00:35 <aufrank> oh, but I guess that doesn't matter if I don
22:00:39 <aufrank> t return them
22:00:44 <aufrank> right
22:01:36 <aufrank> any chance there's enough perl -> haskell work to be done in the darcs test suite to justify a google SoC submission?
22:01:54 <aufrank> I could actually answer "why are you a good person for this job" in that case
22:02:05 <dons> hmm. a new patch format perhaps.
22:02:07 <aufrank> the answer being "no one else wants to do it" ;)
22:02:14 <Jerub> I like my tests in python, because it's more readable and the changes can be reflected instantly.
22:02:19 <dons> or, lots lots lots more tests.
22:02:50 <lispy> aufrank: there is plenty of work to be done in darcs to justify a SoC i'm sure
22:02:58 <dons> yeah, not a bad idea really.
22:03:21 <dons> provign some things about it (darcs) would be good.
22:03:22 <lispy> aufrank: for example, ironing out patch theory, fixing bugs in the bug database, improving performance, fixing corner cases, etc
22:03:39 <aufrank> definitely appeals to me
22:03:47 * Korollary is dual-booting rockbox & original ipod firmware
22:03:47 <dons> we should certainly have a couple of darcs things on the list of projects.
22:04:53 <lispy> well, one test suite bug fixed
22:04:58 <lispy> er, not test suite
22:05:06 <lispy> but one bug detected by the test suite is fixed
22:14:29 <aufrank> is there any trick to searching hoogle for .\  ?
22:15:07 <lispy> @hooge (.\)
22:15:08 <lambdabot> No matches found
22:15:26 <Korollary> what is .\ ?
22:15:31 <lispy> maybe hoogle doesn't know about it
22:16:18 <aufrank> am I misremembering that it is the syntax for introducing a lambda expression
22:16:22 <aufrank> yes, I am
22:16:23 <aufrank> oop
22:16:24 <aufrank> s
22:16:49 <Korollary> \ is. I don't know what you are planning to search for, tho.
22:17:47 <aufrank> when I don't know if I'm using something correctly, I start by trying a search :)
22:18:11 <sieni> aufrank: use lambadabot:
22:18:29 <sieni> > (\x y z -> x + y * z) 5 4 3
22:18:31 <lambdabot> 17
22:22:55 <dons> hoogle also only lets you search for types, not syntactic thingies :)
22:23:07 <dons> types and identifiers, i should clairfy
22:23:17 <aufrank> thanks, that's good to know
22:23:29 <dons> ?help docs
22:23:30 <lambdabot> docs <lib>. Lookup the url for this library's documentation
22:23:36 <dons> ?help hoogle
22:23:37 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
22:23:42 <dons> ?help help
22:23:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:23:56 <dons> interactive super-happy fun fun!
22:24:20 <dons> lambdabot, the mega-cool super-bot from happy land!
22:24:40 <aufrank> very nice
22:24:59 <aufrank> what's the difference between the @ prefix and the > prefix on commands to lambdabot?
22:25:17 <dons>  @ is for generic commands, > is shorthand for @eval
22:25:19 <dons> @eval 1 + 2
22:25:21 <lambdabot> 3
22:25:21 <dons> > 1+ 2
22:25:23 <lambdabot> 3
22:25:29 <aufrank> gotcha
22:25:31 <dons> its reminiscent of literate haskell 'Bird style'
22:25:34 <lispy> dons: oh did you see that @remember wasn't working?
22:25:48 <dons> yep. there's some weird sin^h^h^h bug that i need to track down
22:25:59 <sieni> literate programming *vomit*
22:26:05 <dons> poor sieni.
22:26:42 <dons> let me quote wadler... ( this may take some time to find )
22:27:30 <Korollary> I did some litP. It was ok, but not earth-shattering.
22:27:44 <dons> www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg00717.html
22:28:08 <dons> it seems to work nicely in high comment to code situations like irc, anyway :)
22:29:28 <sieni> if it was hard to write, it should be hard to read as well!
22:29:42 <dons> I like that argument!
22:29:52 <dons> More pointfree for all!
22:29:55 <Korollary> heh
22:30:19 <Korollary> or pure lambda calculus
22:30:23 <dons> hmm. the problem with pointfree is that now with @pl, pointfree is _easy_ to write, but still just as hard to raead
22:30:25 <Saulzar> With @pl you get the benefits of both worlds
22:30:31 <Saulzar> Exactly :)
22:30:57 <dons> so literate pointfree is really sieni's dream world, I guess.
22:31:32 <Korollary> I think pointfree sucks for non-unary stuff. I feel like reading de bruijn indices.
22:33:08 <Korollary> (How do you pronounce de bruijn anyway?)
22:33:14 <aufrank> @docs @pl
22:33:15 <lambdabot>  @pl not available
22:33:34 <aufrank> @hooge @pl
22:33:35 <lambdabot> No matches found
22:33:47 <dons> like brown (broo-in) with a scottish accent?
22:34:10 <aufrank> ok, I tried to ask the bot, now I'll ask you guys:  @pl?
22:34:17 <dons> @help pl
22:34:18 <lambdabot> pointless <expr>. Play with pointfree code.
22:34:33 <dons> @pl \x y -> x + y
22:34:34 <lambdabot> (+)
22:34:46 <aufrank> apparently I keep asking the wrong questions =[
22:34:47 <dons> ?wiki Pointfree
22:34:48 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
22:34:50 <dons> lots of examples.
22:34:58 <aufrank> yeah, I've read through a lot of that
22:35:14 <aufrank> don't know that I've grokked it, but I've read through it ;)
22:35:15 <dons> pl is a lambdabot command, not a haskell function :)
22:35:24 <dons> well, its also a haskell functin too, I guess
22:35:24 <aufrank> oh oh oh
22:35:37 <dons> if you install lambdabot, that is.
22:36:27 <sieni> pl is also an euphemism for basic quality hashish in Finnish (PerusL‰tk‰)
22:36:42 <Korollary> .pl is portugal I believe
22:36:46 <Korollary> err poland
22:36:57 <aufrank> finnish and haskell, eh?  you're a glutton for punishment, language-wise ;)
22:37:15 <Korollary> what's wrong with finnish?
22:37:33 <aufrank> isn't that the one where they have a different inflectional morpheme for each member of the Beatles?
22:37:36 <aufrank> :P
22:37:39 <dons> sieni, ah, very interesting.
22:38:27 <olliej> if i have a strict function, say foo#, the entirety of the function is evaluated strictly isn't it? 
22:39:05 <lispy> it's too soon to know for sure, but i think i might pass all the tests with my new patch format
22:39:40 <lispy> huh, maybe not, unrevert may be brken...never used that before...
22:39:44 <dons> entirety? depends on what its strict in, olliej. just on argument? all arguments? result? is it deeply strict, or just shallow (i.e. length versus deepSeq)
22:40:01 <aufrank> sorry, that passes for humor in the psycholinguistics lab I work in
22:40:16 <dons> a primop is strict in the ML sense though (I guess that 's what you mean with # )
22:40:20 <dons> it s goign to evaluate al
22:40:26 <olliej> right
22:40:26 <lispy> aufrank: psycho just means crasy where i'm from
22:40:28 <Korollary> aufrank: I had to look that up
22:40:36 <dons> l arguments before, and then produce a result in normal form, al la deepSeq
22:40:45 <sieni> I saw a Mercedes Benz yesterday which hade plate with "OBI-1". I found it hilarious.
22:40:53 * olliej wishes Core would have strictness annotations
22:41:05 <dons> it does, no? on the function bindings
22:41:12 <dons> USL and so on
22:41:22 <olliej> usl?
22:41:35 <Korollary> aufrank: What is your job that keeps you in a psycho-linguistics lab?
22:41:38 <olliej> sorry
22:41:44 <olliej> it has info on the types themselves
22:42:02 <olliej> so i know if an argument is strict or not
22:42:16 <aufrank> I'm a grad student studying human language production and processing
22:42:16 <olliej> but not whether the function itself is strict
22:42:59 <Korollary> aufrank: Interesting. Are you interested in haskell for your thesis?
22:43:00 <Lemmih> How can a function be strict?
22:43:10 <Lemmih> (or lazy, for that matter)
22:43:21 <aufrank> Korollary: one branch of the field is interested in computational models of cognitive processes
22:43:29 <olliej> i'm trying to work out what say read# actually should be doing
22:43:39 <olliej> Lemmih: prev. sentence was to you :)
22:43:42 <aufrank> I should say "one area of research is in" rather than "one branch of the field is interested in"
22:44:05 <olliej> Lemmih: rather readArray#, etc
22:44:18 <aufrank> Korollary: I'm just looking for good tools to do my computational work with
22:44:38 <aufrank> ideally I'd like to write a DSL for dealing with the kinds of models that we often use
22:44:54 <Korollary> aufrank: I see.
22:44:59 <Lemmih> olliej: It should take a mutable array, an int, a state and then return a new state and a value.
22:45:32 <Korollary> aufrank: May I urge you to figure it all out very soon so that I can converse with my iPod? Thanks :)
22:46:01 <Lemmih> olliej: Plus, the arguments and the result should be unboxed.
22:46:07 <Lemmih> (ie. strict)
22:46:09 <olliej> Lemmih: yes
22:46:22 <olliej> ah yes, of course, there are no unboxed type at all
22:46:28 <olliej> it can't be nonstrict
22:46:31 <aufrank> Korollary: my friend who's preparing to dissertate works on applying cognitive science research to spoken human computer interfaces
22:46:42 <aufrank> we've got a man on the job ;)
22:47:56 <dons> olliej: right. the # kind separates this strict strange world from the rest of haskell.
22:48:18 <dons> importantly, since all kinds of rules don't apply to types in the # kind.
22:48:46 <olliej> dons: yes, i was getting confused by the #'s on function names in GHC.Prim :)
22:48:59 <Korollary> It could be a convention
22:49:32 <dons> its a conventoin, for functions over types of kind #
22:49:37 <dons> but also sometimes it means other things.
22:49:45 <dons> like 'primitive' ( a la unsafeCoerce# )
22:49:54 <olliej> right
22:49:55 <dons> @tyep GHC.Prim.unsafeCoerce#
22:49:56 <lambdabot> forall b a. a -> b
22:50:06 * olliej hates many of the primops
22:53:45 <aufrank> ok, /me has got to hit the hay
22:54:05 <aufrank> thanks for the help, you lot
23:25:35 <goltrpoat> if you say G is a suitable group, H is a suitable normal subgroup, and g h g^-1 -> k is the action g on state h, resulting in output k, does this describe every FSM?  can't think of a counterexample, just thought i'd make sure
23:27:05 <goltrpoat> the statement allows for homomorphisms on state machines, which might be semi-interesting.
23:27:44 <goltrpoat> (obviously actions come from the complement of whatever set H is over, in G)
23:29:10 <kowey> any intel mac users want to see if darcs now compiles natively with ghc 6.4.2 from darwinports?
23:29:34 <kowey> (just random curiosity, it was one of things a handful of users were wishing fervently for)
23:32:02 <sieni> goltrpoat: how are you planning to represent separate states that end up in the same state?
23:32:12 <goltrpoat> more specifically, if we have a set of states S, we go to construct an abelian group H over S, and then pick a set of actions A, and construct a group G over T such that A and S are disjoint, (A \cup S) \subset T
23:33:00 <goltrpoat> (and H is normal in G)
23:33:40 <goltrpoat> sieni:  crap, that breaks it.  different states that go to the same state under different actions?
23:34:00 <sieni> I don't immediately see, how groups are going to help with state machines, since a state diagram is basically an arbitrary finite graph
23:34:35 <goltrpoat> yeah, i just had the random idea that it might be interesting to look at state machine homomorphisms
23:34:42 <goltrpoat> in a group sense
23:35:01 <goltrpoat> but yeah that example screws it.
23:40:19 <sieni> goltrpoat: well, the transition table gives you a semigroup in the dynamical systems sense
23:42:02 <sieni> if you want to go that road, you should check out dynamical systtems literature
23:45:17 <goltrpoat> i think what i might have a different definition of dynamical systems than what you're talking about.. i was associating it with control theory and such
23:45:25 <goltrpoat> -what
23:45:48 <goltrpoat> any links?
23:49:48 <goltrpoat> oh wait.. are you talking about IFS type stuff?
23:49:59 <goltrpoat> if so, i have no idea what a semigroup might mean in that context
23:51:29 <toki2_0> howdy
23:51:38 <Korollary> hallo
23:51:52 <toki2_0> oh a german
23:51:56 <toki2_0> me too
23:52:12 <Korollary> No, I am not.
23:52:18 <toki2_0> but ?
23:52:27 <Korollary> I realized you were, so hallo.
23:52:28 <lispy> oh, there goes the rug
23:52:45 <lispy> right from under you...
23:52:50 <toki2_0> how do you know ?
23:53:01 <lispy> .versanet.de
23:53:14 <toki2_0> right
23:53:21 <lispy>  try /whois toki2_0 
23:53:22 <toki2_0> where're you from ?
23:53:34 <lispy> US, west coast
23:54:13 <lispy> hmm..this new patch format doesn't seem to improve record times at all
23:54:16 <lispy> what a bummer
23:58:05 <lispy> aparently gzReadPatchFileLazily is very stubborn about being slow
