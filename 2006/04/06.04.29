00:02:09 <Korollary> How ugly is that "w" anyways
00:02:17 <newsham> not very
00:02:18 <Korollary> even c++ dropped it
00:02:31 <newsham> WRITE = "w" if you prefer
00:03:54 <lispy> whate are those examples?  python?
00:04:01 <newsham> yup
00:06:22 <Korollary> I prefer "wrong"[0] heh
00:06:54 <newsham> "how"[-1] ?
00:07:02 <Korollary> that's better
00:08:07 <Korollary> or chr(119)
00:08:38 <newsham> chr(fact(5)-1)
00:11:42 <lispy> > [1, 2, ]
00:11:42 <lambdabot>  parse error on input `]'
00:12:03 <lispy> so some of the haskell syntax allows the tailing comma but not all
00:12:17 <lispy> is it module imports that allow it?
00:12:41 <newsham> apparently that changed in ghc, too.   I had to remove a trailing comma from HWS, which apparently used to compile
00:12:49 <newsham> (in a record decl)
00:12:51 <Cale> I was unaware that trailing commas were ever allowed.
00:13:00 <newsham> want cvs diffs? :)
00:14:17 <Cale> Where was it that trailing commas were allowed?
00:16:24 <Oeje1> Good morning!
00:16:27 <newsham>  cvs -d :pserver:anoncvs@cvs.haskell.org:/cvs get fptools/hws/src/Config.hs
00:16:39 <newsham> see line 118.
00:17:32 <Korollary> Hah. John C Mitchell, 1988, to the Types list: "For example, why is it that so many prefer call-by-value in
00:17:35 <Korollary> practice? The usual reason is "efficiency," but what does this mean?"
00:17:36 <newsham> modern ghc doesnt like the comma.
00:20:27 <Oeje1> Korollary: Is it an interesting thread?
00:20:58 <lispy> newsham: what is hws?
00:21:02 <lispy> haskell work sheet?
00:21:27 <juhp> lispy: a webserver
00:21:42 <lispy> oh, haskell web server
00:21:51 <lispy> that probably makes more sense ;0
00:22:02 <juhp> yup :)
00:22:06 <Korollary> Oeje1: It kind of is. I can't appreciate most of the threads in that list, tho. Way over my noggin.
00:22:29 <juhp> lispy: originally by simonm
00:23:51 <newsham> lispy: http://udp110165uds.hawaiiantel.net:8888/
00:25:27 <Korollary> Oeje1: http://thread.gmane.org/gmane.comp.science.types/364/focus=364 and its neighborhood. The emails are too old and you need to poke around manually a bit.
00:26:38 <Oeje1> It seems, Matplotlib[1] is a really nice embeded plotting language.  Could it be done as naturally in Haskell?  [1] http://matplotlib.sourceforge.net/screenshots.html
00:26:50 <lispy> newsham: you're into plan9?
00:27:07 <newsham> lispy: its a very nice design.
00:27:09 <Oeje1> Korollary: Thanks.
00:27:14 <lispy> i have a unix geek buddy in RL that saw a plan9 demo and thought it was really cool but i never got it
00:27:20 <newsham> i havent worked with it in a while.
00:27:44 <newsham> you can qemu it
00:28:06 <newsham> I ported the code to ultrasparc for some kicks.
00:28:07 <lispy> i went all the way to the download site once, but didn't want to regiter
00:28:15 <lispy> newsham: cool
00:28:29 <newsham> lispy: bugmenot.com ?
00:29:03 <newsham> there's a fairly active #plan9 channel on this irc network
00:29:27 <lispy> my days of os exploring are mostly over
00:29:45 <lispy> these days i'm more interested in keeping them running than trying them out :)
00:30:23 <newsham> maybe some day some real OS's will be written in a high level functional language
00:30:32 <lispy> newsham: have you seen house?
00:30:49 <newsham> yup.  havent played with it, but saw the paper and ran it briefly in vmware
00:31:02 <newsham> its a start, but long way to go
00:31:27 <lispy> and don't forget the lispM
00:31:34 <lispy> never seen one myself, but i guess they were nice
00:32:07 <newsham> lispy: http://www.unlambda.com/cadr/index.html
00:32:37 <Korollary> Oeje1: Yeah. You'd need to be a bit more explicit, tho, i.e. no global "x" for the show function, etc.
00:32:43 <lispy> but more importantly, i think the language needs to allow precise control over the code generation and the predictablity of the execution profile
00:32:59 <lispy> newsham: oh cool
00:35:39 <lispy> also, there seem to be huge hurdles in terms of politics and drivers
00:36:37 <newsham> a partial solution to the driver problem is a hypervisor.
00:37:13 <newsham> but languages such as haskell claim to make programming easier.  if that is truely the case (and I'm a believer) then it should be less of a problem for a haskell kernel than for a C kerenl.
00:38:28 <Korollary> what is a hypervisor?
00:38:29 <lispy> otoh, C was invented for writing the kernel and some applications whereas haskell seems to be just for writing applications
00:38:56 <newsham> korollary: like a microkernel sort of but more in fashion at the moment ;-)
00:39:02 <lispy> a kernel seems like a very specialized application to me, one with unusual needs
00:39:20 <Korollary> newsham: Cool name nonetheless.
00:39:47 * lispy goes to bed
00:39:49 <lispy> night all
00:40:20 <newsham> kor: basically hypervisors let you run multiple OS's on the same hardware, with some cooperation (such as sharing dev drivers)
00:40:28 <newsham> xen being an example
00:40:29 <Korollary> lispy nite
00:40:37 <Korollary> ah
00:41:12 <Korollary> I don't wanna run multiple OS' tho
00:41:50 <newsham> my point was if you have an OS project that cant support dev driver development, you can host it along side a system like linux that is rich in dev driver support, and borrow device driver support
00:41:54 <Korollary> I can't find one good OS to run let alone two or more.
00:41:57 <newsham> (sort of like OSKit in the past)
00:42:01 <Korollary> ah I see
00:42:38 <newsham> soon you'll be able to buy hardware that supports virtual machines and let you run unmodified OS's side by side on the same ahrdware
00:42:51 <newsham> which could be useful for windows + osx for example
00:52:06 <Korollary> Talk on object oriented types from 1991: http://article.gmane.org/gmane.comp.science.types/567/match=black+object+oriented+types+harvard
02:01:20 <JohnMeacham> http://repetae.net/john/primes.ps here is a graph of the call structure (all direct calls) in the final grin code for the primes nofib test. the dark lines are tail-calls that are turned into while loops. looking at it this way is great for figuring out what to optimize next. see the (++) operator and the 'map' application. there is something wacking going on there.
02:04:15 <musasabi> morning
02:05:37 <JohnMeacham> morning. I mean evening. I mean... friday evening.
02:05:58 <Oeje1> JohnMeacham: It's saturday day!
02:09:45 <JohnMeacham> it is 2am. last call. last call for al-co-hol. time to program. time to read papers about garbage collection.
02:10:00 <JohnMeacham> while my booty calls percolate.
02:10:03 <JohnMeacham> I didn't say that.
02:10:41 <JohnMeacham> maybe I did. I should stick to #haskell-blah.
02:12:57 <JohnMeacham> but I really like my call graph. graphs have always been a fascinating subject. this is an awesome book on the subject. and a GTM to boot. http://www.math.uni-hamburg.de/home/diestel/books/graph.theory/  and available free online! probably my most read springer-verlag GTM.
02:12:59 <Pupeno_> Hello.
02:13:56 <JohnMeacham> Hello!
02:14:50 <Pupeno_> [OT] I am having an interview for a position of Software Quality Assurance... any recomendations on a book in that subject to get to know it better ?
02:15:48 <JohnMeacham> Pupeno_: dealing with haskell? 
02:16:19 <JohnMeacham> Oh. [OT]. no. I know no books... now.. if you wanted to know graph theory....
02:16:31 <Pupeno_> JohnMeacham: not really, (that's why the OT, Off Topic)... but, I'd like it to be as language agnostic as possible.
02:17:17 <mahogny> Pupeno_, what level are we talking here? normal end-user requirements (ie none) or NASA?
02:17:38 <Pupeno_> mahogny: closer to NASA.
02:18:00 <mahogny> Pupeno_, then you might want to dive into formal verification. read any about it?
02:19:49 <Pupeno_> mahogny: not so close I'd say. The company is really serious but I don't think they are interesting in formal verification. I think it is more about testing, black-box testing, etc.
02:21:46 <mahogny> Pupeno_, ok. then if you want to stay away from language specifics, you should read on good software development management. I don't have good books on it though. I still think it would be good if you mastered the most common tools for testing though (such as JUnit for java)
02:22:50 <Pupeno_> mahogny: I have some understanding of unit testing (PyUnit, EUnit and unit testing on Haskell, can't remember the name as well as QuickCheck on Haskell).
02:22:59 <mahogny> I don't think it is really possible to write a good book either. this is a field when experience and pickiness about following protocols is what really counts
02:23:37 <Oeje1> Pupeno_: You are going to a job interview for a position of SQA, and you don't know any good litterature about it?  I find that a bit odd.
02:24:06 <mahogny> Oeje1, you always have to start somewhere :)
02:25:57 <pejo> Pupeno, MS has a bunch of books on software quality. "Code complete" (?) is the only one I remember, but there should be others.
02:25:59 <mahogny> Pupeno_, hm. I dunno how much control you have, but it's worth saying; 90% of the bugs are indirectly caused by specification so there is really where one should start
02:26:04 <Pupeno_> Oeje1: I didn't asked for this interview specifically, I didn't even contact the company directly, a recruiter contacted me; they may have a reason.
02:27:58 <mahogny> hm. someone should create a tool to test programs on the GUI level. I find that a bit messy currently
02:28:32 <Pupeno_> mahogny: there are some programs to do that, but it is always tricky.
02:28:54 <mahogny> know any good?
02:31:37 <Pupeno_> no.
02:31:55 <Pupeno_> I haven't even try them. I remember there was one written with Qt.
02:31:57 <mahogny> then thanks for the idea. I will add it to the SoC page :)
03:31:58 <morans> pondering making a photo-of-the-day webpage/RSS feed
03:32:08 <morans> in haskell, to learn how to do webserver stuff in haskell
03:32:14 <morans> any recommendations on what to use? WASH?
03:33:59 <musasabi> HAppS ;) (I am not neutral)
03:34:21 * morans looks
03:34:23 <mahogny> well, happs is indeed high performance
03:35:13 <morans> this isn't going to need to be high performance, if my existing blog is any predictor
03:35:20 <morans> like 5..10 hits per day ;-)
03:52:04 <xerox> ?Yow.
03:52:05 <lambdabot> I'm afraid! I need something in a heavy cream sauce.
03:52:17 <xerox> Yum.
03:52:24 <mahogny> o_O
03:53:29 * xerox 's stomach groans
03:54:22 * mahogny wants something that is better than an LQ-regulator, yet is extremely easy to code. hints? :/
04:07:27 <morans> anyone know i should be expecting a runhaskell command to be installed with GHC?
04:07:40 <morans> i just put debian on a host yesterday and used their GHC pkg
04:07:55 <morans> now one of the modules I'm trying to install wants to run runhaskell
04:08:33 <musasabi> use runghc instead.
04:08:48 <morans> should be ok to symlink those two together?
04:09:58 <morans> oof
04:10:03 <morans> old version of GHC on debian stable anyway
04:30:31 <musasabi> Are the library docs for 6.5 somewhere_
04:30:32 <musasabi> ?
04:38:56 <araujo> morning!
04:40:56 <musasabi> morning araujo 
04:41:20 * musasabi needs a queue with good 1) head/tail O(1), 2) adding new elements to the end O(1), 3) deleting elements from the middle by key. O(log n), 4) no persistence. Any suggestions?
04:42:29 <araujo> musasabi, hello!
04:43:08 <psnl> musasabi: I could write you one in C, but would have no idea how to do it in haskell
04:43:15 <ulfdoz> musasabi: Sounds like search tree with strange ordering.
04:44:30 <musasabi> of course if I can just delete 3) from the requirements it becomes trivial.
04:45:00 <astrolabe> I saw a paper once that had something along those lines.  It was complicated.
04:46:12 <astrolabe> I don't know if it has all that you want http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
04:46:38 <musasabi> thanks
04:46:45 <musasabi> reading that.
04:50:28 <astrolabe> Failing that, could you make a doubly linked list using mutable arrays to hold the links?
05:09:13 * morans growls at the WASH installer
05:44:01 <morans> hmm
05:44:13 <morans> no instHook in this GHC/debian install
05:44:14 <morans> frrr
05:48:23 <reppie> http://shelleytherepublican.com/2006/04/linux-european-threat-to-our-computers.html
05:48:39 <olliej> dcoutts: i have bowed to the inevitable, and am implementing higher kinded types, albeit with type erasure, as i don't have time to implmenet it using expansion :(
05:50:06 <dcoutts_> how does that work then?
05:50:11 <dcoutts_> using erasure?
05:50:38 <dcoutts_> btw, you're compiling to C# or .net byte code?
05:50:57 <Igloo> morans: Is that a cabal thing?
05:51:27 <morans> Igloo: yeah
05:51:43 <morans> Igloo: looks like its a new hook that was added more recently than the Cabal that came with my GHC
05:51:59 <olliej> dcoutts_: basically higher ranked types get turned into the all encompassing 'object'
05:52:20 <dcoutts_> olliej, ah right
05:52:26 <olliej> and (hopefully) get bludgeoned into the right type when they're used
05:52:34 <dcoutts_> by runtime casting
05:52:51 <olliej> dcoutts_: yup
05:52:58 <olliej> which means it's still type safe
05:53:01 <dcoutts_> sounds like a perfectly good solution
05:53:23 <olliej> yeah, but not statically verifable
05:53:30 <olliej> but a) simplifies impl no end
05:53:46 <dcoutts_> statically verifiable from the Haskell side
05:53:47 <olliej> and b) reduces the amount of code emitted
05:53:51 <olliej> yup
05:53:58 <dcoutts_> both of those things are good
05:54:07 <morans> Igloo: I guess I could install my own ghc from source
05:54:09 <olliej> dcoutts_: however everything else, including higher ranked types is statically typed on.net as well
05:54:21 <dcoutts_> olliej, that's impressive
05:54:54 <dcoutts_> olliej, so you're emitting C# right?
05:55:00 <olliej> dcoutts_: yup
05:55:13 <olliej> dcoutts_: damn it's invariant return types
05:55:28 <dcoutts_> ?
05:55:41 <olliej> take Monad
05:55:43 <olliej> dcoutts_: 
05:56:19 <olliej> you end up with a class ZCTMonad { ... M<A> blarg(...){...}}
05:56:21 <olliej> right?
05:56:37 <olliej> except M<A> is higher kinded so becomes object
05:57:07 <olliej> dcoutts_: the instance Monad [] however gives blargh the type List<A> blargh(...)
05:57:37 <olliej> dcoutts_: it would be nice if i could retain that, but noooo, instead i have to make it return object
05:58:09 <olliej> so there's no way the >NET jit can optimise the any cast on the result away :(
06:00:01 <dcoutts_> I see (I think!)
06:00:55 <olliej> dcoutts_: vs Java's allowance of convariant return types
06:01:18 <olliej> (i still get screwed on the paramters, but meh)
06:02:05 <olliej> s/convariant/covariant
06:17:07 <morans> upgrade of Cabal seems to have fixed the instHook problem... now onto |ghc-6.4.1: flag `' is incompatible with source file `configure'
06:17:11 <morans> man, i love getting a new PC
06:28:25 * xerox beholds his new native GHC power
06:28:50 <basti_> o.0
06:29:13 <dcoutts_> xerox, oh that's on OSX x86?
06:29:18 <xerox> Right!
06:29:18 <dcoutts_> dual core too right?
06:29:20 <Pawer> hello
06:29:41 <dcoutts_> xerox, you should try ghc-6.5 with it's new SMP goodness :-)
06:29:50 <xerox> Yep, I have GHC-6.5 :-)
06:29:55 <dcoutts_> a, nice
06:32:04 <xerox> Prelude> let primes = 2 : 3 : [ n | n <- [5,7..], all ((/=0) . (n `mod`)) (takeWhile (\p -> p*p <= n) primes)]
06:32:04 <xerox> Prelude> primes !! 100000
06:32:05 <xerox> 1299721
06:32:05 <xerox> (17.03 secs, 1201679176 bytes)
06:32:19 <xerox> o_0
06:34:36 <Oeje1> xerox: What is wrong?
06:35:23 <xerox> > 1201679176 / 1024^3
06:35:24 <lambdabot> 1.1191509440541267
06:40:25 <dcoutts_> xerox, hah, on my 500Mhz sparc it takes: (251.23 secs, 2957979544 bytes)
06:40:34 <xerox> Yay :-)
06:41:46 * xerox giggles
06:44:50 <dcoutts_> xerox, wow that is a fast machine, my amd64 takes 49 sec for that
06:45:02 <xerox> Oh yeah!
06:45:35 <xerox> Cool.  I want to do some thread-intensive test too :-)
07:03:57 <Oeje1> Another data point: (35.61 secs, 1639947484 bytes)  AMD Athlon(tm) 64 Processor 4000+
07:04:01 * SamB wonders why jhc has been stalled at the same point in the middle of outputting a statistics tree for over 24 hours
07:04:07 <xerox> Oeje1: danke!
07:04:59 <musasabi> SamB: you are not running out of memory are you?
07:05:42 <SamB> at least, I think it is the same point
07:06:16 <musasabi> + which version do you have?
07:06:16 <SamB> it might have outputted three items since yesterday morning...
07:06:38 <SamB> musasabi: RAM or virtual memory?
07:06:59 <musasabi> well running out of RAM will make things very slow...
07:07:16 <musasabi> SamB: is this trying to compile a base-1.0.hl ?
07:07:36 <SamB> really, my question is basically: shouldn't it have already done the work before it started outputting the statistics tree?
07:08:36 <SamB> yes
07:08:41 <musasabi> well it outputs statistics and work in an interleaved fashion. (i.e. information about passes while it does them/has done them)
07:08:55 <musasabi> SamB: if I were you I would just wget them.
07:10:07 <SamB> well, it seems like it must have figured out what was to be done before it could know what to put in the tree
07:10:45 <SamB> and of course I realize that it prints a tree for each pass, but I had assumed that it finished the pass first.
07:11:09 <SamB> I get the distinct impression that there is missing strictness...
07:11:35 <musasabi> rather there is missing a very fast Set implementation.
07:11:56 <SamB> oh?
07:12:27 <musasabi> + JHC got so quick that some very expensive global optimizations were added when it started looking like compiling programs didn't take ages.
07:13:45 <SamB> still... hours and hours and hours should not be needed to figure out what the next line in the statistics is!
07:29:21 <Pawer> hi
07:29:32 <Pawer> an starting tutorial?
07:29:43 <Pawer> for haskell
07:29:52 <SamB> hmm...
07:30:01 <Pawer> not from zero
07:30:08 <SamB> not from zero?
07:30:14 <Pawer> yes
07:30:18 <SamB> meaning?
07:30:28 <astrolabe> @learn
07:30:28 <lambdabot> http://www.haskell.org/learning.html
07:30:33 <Pawer> i know the language
07:31:14 <SamB> what do you want to learn?
07:31:38 <Pawer> needi have bird
07:31:47 <Pawer> richard bird
07:31:49 <astrolabe> http://www.isi.edu/~hdaume/htut/ is popular
07:32:19 <Pawer> i want something with the full language specification
07:32:31 <astrolabe> ug
07:32:47 <astrolabe> you need the report for that
07:32:51 <kosmikus> Pawer: just read the Haskell Report then
07:32:53 <astrolabe> but it isn't so good to learn from
07:32:59 <Pawer> no
07:33:17 <Pawer> i learn from "Introduction to Functional Programming using Haskell"
07:33:28 <Pawer> Richard Bird
07:33:35 <petekaz> Pawer: is that a good book? I'm considering buying it.
07:33:39 <kosmikus> that's ok
07:33:45 <kosmikus> petekaz: I like it very much
07:33:57 <astrolabe> http://www.haskell.org/onlinereport/
07:34:01 <Pawer> it does not teach haskell very weel
07:34:06 <Pawer> well
07:34:10 * dcoutts_ learned from Bird's book
07:34:20 <Pawer> only the strange things
07:34:28 <petekaz> why the discrepancy in reviews here?
07:34:29 <dcoutts_> though actually I was taught by Richard Bird too, so that helped :-)
07:34:44 <Pawer> is an aproach to functional programming
07:34:59 <Pawer> a VERY GOOD APROACH
07:35:05 <petekaz> dcoutts_: lucky you
07:35:37 <Pawer> but does not describe haskell features
07:35:42 <dcoutts_> now I'm teaching the practicals for Richard Bird who is still lecturing for first year FP from that book
07:35:56 * ibid learned haskell from bird's first edition
07:36:03 <Pawer> uses haskell to teach functional programming
07:36:24 <petekaz> I am looking for a book that is similiar to SICP for Haskell.
07:36:46 <Pawer> but bird is very good
07:36:47 <ibid> (bird's book is also one of the textbooks that i consulted when teaching fp)
07:36:53 <petekaz> Teaches how to program functionally while leveraging the features of the language.
07:37:16 <petekaz> Sounds like the experts here agree the book is good.
07:37:35 <kosmikus> could you give an example of what you're missing from Bird? I think it teaches all important features of Haskell.
07:37:37 <Pawer> for example i dont find in Bird an explanation of where, let in ...
07:37:49 <Pawer> statements
07:38:57 <kosmikus> oh, that's surprising. I'll have to check -- I just see that I have my copy at work, so I can't look at it right now.
07:39:22 <Pawer> or other
07:39:35 <Pawer> things appear in the examples
07:39:54 <Pawer> but ...
07:40:05 <Igloo> It's trying to show how to program, not be a syntax reference
07:40:13 <Pawer> the book explains
07:40:27 * Igloo doesn't have a copy to hand to see what it says either, though
07:40:28 <Pawer> Igloo: that's it
07:41:06 <Pawer> it lacks a full sintax reference
07:41:11 <Pawer> so the title
07:41:18 <Pawer> "Introduction to Functional Programming using Haskell"
07:41:23 <Pawer> USING
07:41:35 <Igloo> But if you want a syntax reference then the report already has one
07:41:47 <Pawer> that was my question
07:42:00 <Pawer> i think Bird rules
07:42:52 <kosmikus> yes, there's no textbook on Haskell that contains a full language specification; but I think the Report is readable enough to use it without further explanation.
07:42:53 <Pawer> it goes to the concepts and to the strange or difficult to understand of haskell
07:43:29 <kosmikus> I basically used the Report to learn Haskell ...
07:44:10 <drakioned> er.. are we discussings book to learn Haskell?
07:44:10 <Pawer> haskell98 is the last?
07:44:30 <drakioned> books*
07:44:40 <Igloo> Haskell 98 revised or something
07:44:47 <Pawer> Richard Bird + Haskell report
07:44:50 <Igloo> But what's on the webpage is up-to-date
07:45:02 <Pawer> a pdf version?
07:45:47 <Pawer> there is pdf version of haskell report?
07:45:52 <kosmikus> sure
07:47:02 <Pawer> www.haskell.org/definition/haskell98-report.pdf
07:48:14 * Igloo shoots whoever decided subtype shouldn't have a meaning analogous to subexpression
07:49:32 <dcoutts_> it's in the semantic sense rather than syntactic sense I guess
07:50:07 <dcoutts_> it's like subset
07:51:30 <edwinb> To be fair, type and expression aren't analogous either...
07:51:51 <Igloo> Sure they are, they're both just trees
07:52:02 <edwinb> Types are semantic, expressions syntactic
07:52:08 <edwinb> you can have type expressions and value expressions
07:52:49 <dcoutts_> type expressions are representations of types, value expressions are representations of values
07:53:16 <dcoutts_> it's just that the types map back to type expressions directly (for many type systems)
07:55:34 * xerox tries to compile darcs
08:04:08 <bdash> xerox: what does it take to get GHC working on an intel mac?
08:04:29 <xerox> Sigh.
08:04:33 <xerox> Linking errors.
08:08:27 <xerox> Trying something...
08:08:32 <xerox> No way, argh.
08:10:51 <Pawer> install linux
08:10:57 <Pawer> in your mac
08:12:00 <xerox> I should probably do, though it would have been fun to get it working here.
08:12:12 <xerox> _ControlziMonadziError_zdf22_closure
08:12:13 <xerox> _ControlziMonadziError_ZCDError_static_info
08:12:13 <xerox> _ControlziMonadziReader_polyzufail_closure
08:12:13 <xerox> _ControlziMonadziReader_polyzufail_info
08:12:35 <musasabi> xerox: -package mtl
08:12:36 <xerox> Maybe it has something to do with the fact that I only did `make in-place'.
08:12:37 <Pawer> bye
08:12:43 <xerox> musasabi: let me try!
08:12:45 <Pawer> people
08:13:03 <xerox> musasabi: I can't find darcs Makefile but I'll be hacking it in
08:16:17 <xerox> It's weird, configure seem to create no Makefile file, but make works.
08:16:37 <musasabi> see GNUMakefile
08:16:55 <xerox> Ah-ha!
08:17:24 <xerox> Compiled.
08:17:27 * xerox hugs musasabi 
08:17:48 <xerox> $ ./darcs --version
08:17:48 <xerox> 1.0.7pre1 (prerelease 1)
08:24:42 <palomer> STM?
08:25:56 <palomer> I'm looking for many solutions though
08:39:45 <pierre-> hello
08:44:08 <bdash> xerox: what does it take to get GHC working on an intel mac, given you need a working GHC to build from source?
08:44:24 <xerox> bdash: hmm, I got a wolfgang build for testing.
08:44:44 <bdash> xerox: do you have a URL for that?
08:45:01 <xerox> Yup.  A sec.
08:45:45 <audreyt> xerox: hey
08:46:01 * audreyt begins importing Pugs project items to summer-of-code/
08:46:14 <xerox> http://www.uni-graz.at/imawww/haskell/ghc-6.5.20060409-i386-apple-darwin.tar.bz2
08:46:16 <audreyt> xerox: I applied for SoC mentorship at the google site as you instructed
08:46:23 <xerox> audreyt: Good!
08:46:35 <bdash> xerox: thanks :)
08:46:41 <xerox> bdash: np
08:46:51 <audreyt> xerox: it says "acceptance is pending"
08:46:56 <xerox> audreyt: I think that's normal.
08:47:10 <audreyt> cool
09:13:45 <jip> "Error in array index" how can i find out where this is happening?
09:14:12 <audreyt> use a stack trace
09:14:20 <jip> please tell me how
09:14:25 <audreyt> compile your program with -prof
09:14:28 <audreyt> ghc --make -prof
09:14:29 <audreyt> then
09:14:34 <audreyt> ./your_program +RTS -xc -RTS
09:14:36 <audreyt> that's it
09:15:14 <audreyt> it's one of those hidden folklores...
09:15:35 <jip> i can also use -O, right?
09:15:44 <audreyt> sure
09:15:47 <audreyt> -O -prof works just fine
09:16:15 <audreyt> many programs have different profiling behaviours under -O0 and -O
09:16:29 <audreyt> so -O -prof is useful if you will end up compile yourprogram with -O
09:18:38 * SimonRC has just found out how subtyping + parameterised types + mutable variables = evil.
09:18:57 <SimonRC> or rather, impossible
09:19:24 <SimonRC> (subtyping with strong types, of course)
09:20:27 <jip> audreyt: ok i did that and i see output: "<GHC.Arr.CAF>"
09:21:10 <audreyt> maybe you should try without -O then...
09:21:14 <audreyt> mm.
09:21:39 <SimonRC> In profiling, at least, CAF means "internal stuff".
09:21:51 <Philippa> SimonRC: in what context? IIRC there're things you can do to make it reasonably sane
09:21:59 <Philippa> (but Java's screwed already)
09:22:51 <audreyt> jip: if your code is hs98
09:22:58 <audreyt> running Hat on it can help
09:23:01 <audreyt> http://www.haskell.org/hat/
09:23:11 <palomer> ok, someone tell me how I can add global state to a StateT ([s,s]) List
09:23:12 <jip> audreyt: i tried without -O and i get the same thing
09:23:18 <jip> audreyt: i think i use GADT extension
09:24:15 <SimonRC> Philippa: I will explain...
09:24:29 <audreyt> jip: aw. well, then, hm, you just find out first-hand that Haskell development sucks in times :/
09:24:31 <SimonRC> Suppose you have an array of cats, and you pass it to a routine expexting an array of animals...
09:24:36 <audreyt> s/in/at/
09:24:46 <SimonRC> if the array is immutable, that's fine, but if it is mutable, that routine might unwittingly store a dog in it, because it is an "array of animals".
09:24:47 <audreyt> jip: redefining (!) or something, maybe
09:25:00 <audreyt> oh. contravariance.
09:25:09 <audreyt> you can "fix" this with runtime typechecking.
09:25:25 <jip> i'm using immutable array
09:25:26 <audreyt> which is also strongly typed, just not statically typed.
09:25:52 <audreyt> jip: you can redefine (!) to trace out all the indexes your code use in it, with Debug.Trace
09:25:54 <SimonRC> oops, I meant "static"
09:26:03 <audreyt> heh. :)
09:26:25 <audreyt> static typing is fine...
09:26:32 <SimonRC> The solution I came up with while doing the washing machine is the same as the solution that Ten15 uses: give a mutable varible two types...
09:26:37 <audreyt> having to statically type everywhere, however, can be a pain ;)
09:27:20 <jip> hm...
09:27:20 <SimonRC> One can argue that static typing is just a special case of dynamic typing...
09:27:54 <SimonRC> (Ten15's solution to the problem, BTW:  http://www.mca-ltd.com/martin/Ten15/updateable_type.html)
09:28:04 <SimonRC> and vice-versa.  :-)
09:28:04 <audreyt> one can also argue that typechecking is just a special case of evaluation...
09:28:08 <palomer> one is crazy in doing so
09:28:35 <palomer> you can define an operational semantics on types which is similar to that of terms
09:28:47 <palomer> (think dependent types)
09:28:58 <palomer> in which case the type checker will apply some reductions
09:29:20 * SimonRC was introduced to Epigram by edwinb.
09:32:41 <SimonRC> If a program typechecks statically, then it will clearly run just fine with dynamic typechecking.  And if a program typechecks dynamically, either (a) it will typecheck statically too, or (b) it does different things to variables of different types, so you can mechanically replace unknown types with algebraic data types that could be any of the allowed types, then switch on constructor rather than type, with explicit conversions occasionally.
09:32:48 <SimonRC> I *think*.
09:32:54 <tuxplorer> hi kzm
09:34:40 <SimonRC> data LispData = LCons LispData LispData | Nil | LString String | LInt Integer | ...
09:34:54 <SimonRC> that sort of thing
09:35:13 <audreyt> "you can defer typechecking if you write an evaluator."
09:35:13 <audreyt> yes.
09:35:35 <audreyt> or, even easier, use Data.Dynamic :)
09:37:00 <SimonRC> Well, I wouldn't create a type that could represent *anything*.
09:37:52 <drakioned> has anyone written an terminal emulator in Haskell?
09:38:04 <jip> drakioned: sounds like fun :)
09:38:40 <drakioned> er.. I'd have no idea where to start, just wondered whether there was one
09:38:53 <xerox> audreyt: where's the pugs darcs repo, if any?
09:39:08 <SimonRC> It's more for those situations where dynamically-typed langs have: "if the parameter is an integer, a square centred on the origin is produced, if the parameter is a pair, a rectangle centred on the origin is produced, if the parameter is a list, the first four elements are used a thw two corners of a rectangle."
09:41:45 <audreyt> xerox: http://perlcabal.org/~autrijus/darcs/pugs/
09:41:59 <audreyt> xerox: but, readonly
09:42:08 <audreyt> like the one in svn.perl.org, it's one-way mirror
09:42:15 <audreyt> master copy is http://svn.openfoundry.org/pugs/
09:42:37 <audreyt> (WebDAV/SVN)
09:44:31 <xerox> Read only is okay for now, I think.
09:46:15 <lispy> drakioned: not that i'm aware of.  Just wondering, what functionality counts as a terminal emulator?
09:46:23 <lispy> drakioned: something like screen or something like xterm?
09:47:20 <drakioned> well, for me at the moment? something that prints stuff to screen properly if I feed it a stream from the net expecting an ansi terminal
09:48:09 <lispy> drakioned: huh...okay so not screen-like features
09:48:59 <drakioned> er.. yeah, more like xterm
09:52:13 <drakioned> bbl.
10:00:45 <palomer> @seen cale
10:00:46 <lambdabot> cale is in #haskell. I last heard cale speak 9 hours, 46 minutes and 25 seconds ago.
10:01:14 <Cale> hello
10:01:19 <palomer> yes!
10:01:48 <palomer> Cale: ok, I'm desperately trying to find how to add global state to my StateT s [] s
10:02:15 <palomer> and I have to admit, I'm a little over my head
10:03:09 <palomer> do I have to use StateT s' (StateT s []) s ?
10:03:47 <lispy> what does it mean for the state to be global?
10:04:16 <xerox> Apply (s',) to s ? (-:
10:04:20 <palomer> if I do a mplus b, and a changes the state, the change will be reflected in b
10:04:38 <Igloo> It's not global state, it's just state
10:04:42 <palomer> (which is not the case for StateT s [] s)
10:04:59 <Igloo> Yes it is
10:05:04 <palomer> no, it isn't.
10:05:23 <audreyt> well, if you insist, then put an IORef into the State.
10:05:27 <lispy> sounds like it's time for examples :)
10:05:37 <palomer> audreyt: you're nuts
10:05:44 <lispy> palomer: you want dynamical scope?
10:05:44 <audreyt> yes I am ;)
10:05:51 <Igloo> Yes, give us an example of the state not being updated how you'd like
10:06:27 * lispy wonders if Cale sometimes gets sick of helping palomer with everytihng :)
10:06:36 <Cale> palomer: well, you could have a State computation which returns a value of type StateT s [] a
10:06:40 <palomer> > evalStateT (do x <- option [1..10]; u <- get; put (u + 1); return u) 0 :: [Integer]
10:06:41 <lambdabot>  Not in scope: `option'
10:06:50 <Cale> that would amount to 'global' state
10:07:02 <palomer> > Prelude Control.Monad.State> evalStateT (do x <- option [1..10]; u <- get; put (u + 1); return u) 0 :: [Integer]
10:07:03 <lambdabot>  Not in scope: `option'
10:07:10 <xerox> audreyt: darcs get --partial hangs on 'Getting the inventory...' :-|
10:07:12 <Cale> > let option xs = msum (map return xs) in evalStateT (do x <- option [1..10]; u <- get; put (u + 1); return u) 0 :: [Integer]
10:07:13 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
10:07:23 <lispy> xerox: how long does it hang?
10:07:29 <audreyt> xerox: wow :/
10:07:46 <xerox> lispy: since I asked audreyt for the url
10:07:47 <audreyt> it has but 10129 records in it
10:07:57 <palomer> Cale: how would I update the local state? lift get and lift put?
10:08:01 <Cale> Or you could construct a new monad, something like  t -> s -> (t, [(a,s)])
10:08:12 <xerox> It has nearly finished to compile svn with all its dependencies in the meanwhile.
10:08:15 <lispy> xerox: maybe just give it more time, if an hour goes by and no progress then we probably have a problem
10:08:25 <Cale> Well, you'd be returning an action which would act on the local state
10:08:25 <audreyt> and I did tag things
10:08:26 <lispy> xerox: also, what version of darcs do you have locally?
10:08:31 <audreyt> as suggested by droundy
10:08:43 <audreyt> the server darcs is 1.0.6
10:08:52 <xerox> lispy: 1.0.7pre1 (prerelease 1)
10:09:09 <lispy> xerox: hmm...you could try it again with --verbose but that doesn't add much verbosity
10:09:16 <palomer> ah, righto
10:09:17 <palomer> hrmph
10:10:19 <palomer> so the syntax would be completely different
10:10:33 <Cale> now, unfortunately, something can't be a MonadState in more than one way at once
10:10:37 <xerox> lispy: I'm using -v
10:10:38 <skew> palomer: what kind of monad are you trying to make?
10:10:57 <Cale> so you might have to come up with a nicer interface for it.
10:11:12 <palomer> skew: a monad that represents branching computation, with a global shared state
10:11:14 <xerox> I've got svn anyway.
10:11:21 <Cale> skew, I think it's basically,  t -> s -> (t,[(a,s)])
10:11:23 <xerox> Monad Tree ?
10:11:30 <palomer> skew: which computes a set of solutions
10:11:31 <lispy> xerox: :( wish i could be more helpful.  I guess if you really get stuck you could try to wget the whole archive and run darcs check on it to make sure it's okay
10:11:32 <Cale> and local state
10:11:42 <Cale> palomer: or do you not need the local state?
10:11:47 <palomer> I need local state
10:11:55 <xerox> lispy: I'm retrying with --verbose
10:11:58 <skew> state that gets backtracked?
10:11:59 <palomer> some things will be true in some branches which are not in others
10:12:03 <lispy> xerox: that would be the same as -v
10:12:05 <palomer> skew: no backtracking needed
10:12:19 <Cale> skew: yeah, he needs both state that gets backtracked and state which doesn't
10:12:24 <skew> did you see my note about STM?
10:12:25 <xerox> lispy: it only downloaded:  16K    pugs/
10:12:37 <palomer> skew: yeah, but I don't see how it could help
10:12:42 <lispy> xerox: it?  meaning darcs?
10:12:53 <xerox> lispy: yes.
10:13:03 <lispy> xerox: i wish i could help more, but i'm supposed to be packing
10:13:11 <Cale> palomer: "state which gets backtracked" is "local state" here.
10:13:17 <palomer> ah, gotcha
10:13:26 <xerox> lispy: on ^C it did say: Invalid repository:  /Users/Paolo/pugs  darcs: /Users/Paolo/pugs/_darcs/inventory: openBinaryFile: does not exist (No such file or directory)
10:13:27 <lispy> xerox: good luck, and if you find a bug please submit to bugs.darcs.net
10:13:43 <xerox> Woop, kay.
10:13:47 <lispy> xerox: perhaps the permissions are not set correctly on the repo repo
10:13:53 <lispy> remote repo*
10:14:08 <neologism> @where liftM2
10:14:09 <lambdabot> I know nothing about liftm2.
10:14:10 <skew> I'm not sure what you are trying to do, but you can do things like do writeTVar v "hi"; writeTVar v "bye" >> retry `orElse` return (); readTVar v --gives "Hi"
10:14:25 <skew> without the magic capitalization, of course
10:14:33 <lispy> xerox: also, submit a request if you think darcs could handle this situation better :)
10:14:46 <xerox> lispy: are you a darcs dev?
10:14:54 <newsham> hmm.. hasktags creates a tags file that vim doesnt care for.
10:14:58 <newsham> E432: Tags file not sorted: tags
10:14:58 <newsham> E431: Format error in tags file "TAGS"
10:15:00 <lispy> xerox: not officialy, i just hack on it from time to time (small stuff)
10:15:13 <neologism> @type Monad.liftM2
10:15:14 <lambdabot> forall r (m :: * -> *) a2 a1.
10:15:14 <lambdabot>       (Monad m) =>
10:15:14 <lambdabot>       (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:15:19 <xerox> lispy: oh, do you have ideas for possible darcs projects for SoC?  The ml wasn't much responsive in that regard.
10:15:39 <lispy> xerox: yeah i do, the problem is finding a metor
10:16:22 <lispy> xerox: let's take this to #darcs
10:16:45 <xerox> lispy: it is not *much* a problem.  I mean, it would surely be the good to have a darcs dev mentoring, but if the mailing list is responsive enough a general Haskell knowledge would work for some possible projects.
10:16:52 <newsham> anyone use hasktags with vim?
10:17:00 <neologism> > liftM2 (+1) (Just 1) (Just 2)
10:17:01 <lambdabot>  add an instance declaration for (Num (a -> r))
10:17:08 <neologism> > liftM2 (+) (Just 1) (Just 2)
10:17:09 <lambdabot> Just 3
10:17:17 <palomer> hrmphrmphrm
10:17:27 <palomer> Cale: will writing this monad from scratch be that hard?
10:17:57 <goron> "Hopefully, one day everyone will see the light and stop using Linux, move to Windows, and we can all have nice user interfaces and nice programming languages in one package."
10:18:08 <palomer> amen
10:18:08 <goron> <- Joke of the century 
10:18:43 <mahogny> I hope they see the light and stop using linux and code something better :P
10:19:21 <newsham> as if all the world is linux and windows
10:19:32 <goron> mahogny: Are you serious?
10:19:35 <mahogny> goron, yes
10:19:55 <goron> mahogny: I know Linux is not perfect, but what is wrong with Linux?
10:20:04 <skew> It's not perfect.
10:20:12 <goron> skew: ...
10:20:35 <mahogny> goron, the implementation of the specification is great, but the specification is from around 1980 and isn't in any way made to cope with modern demands
10:21:13 <mahogny> well. bsd is a better implementation, but it lacks drivers :(
10:21:19 <newsham> i wouldnt say great.   a lot of the code is of poor quality (and there's a lot of high quality code too)
10:21:37 <newsham> bsd drivers generally work, when available :)
10:21:56 <newsham> (the same cannot always be said of linux drivers, and reading the code quickly tells you why.. *sigh*)
10:21:59 <skew> There are plenty of promising things to try in operating sysems
10:22:10 <goron> mahogny: BSD support (both in software and drivers) is worse, that's the only reason I switched back to Linux.
10:22:22 <lispy> xerox: you can also check the mail list archives for "my darcs wish list" i sent in an email quite a while ago stating things i wish darcs did/had
10:22:52 <goron> mahogny: And Windows does meet those demands?
10:23:00 <mahogny> goron, windows is a toy
10:23:13 <goron> mahogny: Oh, then we agree :)
10:23:34 <goron> mahogny: A nightmare would be better phrased though.
10:23:45 <skew> goron: he said stop using linux and *code* something better, not switch to something better
10:24:02 <skew> I should get House running
10:24:04 <goron> skew: You can parse that in at least two ways.
10:24:26 <mahogny> linux is maintainable when your fs has around 1000 files. considering my disto has just 2800 *executables*, it's way above the limit. also, linux can be trashed by just entering a bad cd (the mount system is outdated). there are too few standards. X sucks horribly in all ways I can imagine. configuration is a mess. autoconfigure is pure evil. etc etc. there aren't good enough security policies
10:24:53 <mahogny> nothing bad with the implementation. but as I said, the specification doesn't meet modern demands
10:25:17 <lispy> mahogny: unix is flawed sort of argument?
10:25:18 <goron> mahogny: I don't see a problem with having a lot of binaries. 
10:25:42 <goron> mahogny: Especially when they run as user.
10:25:45 <lispy> mahogny: debian has done a lot to standardize little things.  I think their organization is a good start
10:25:49 <mahogny> goron, if a program is 20 files spread out all over the system, you have a major maintainability problem
10:25:55 <mahogny> lispy, yes
10:26:15 <goron> mahogny: I think Debian has a great system. Well, it's QA is one of the best.
10:26:20 <goron> er its
10:26:40 <goron> It's all a matter of attention and polishing, fixing bugs, etc.
10:26:48 <lispy> mahogny: i think unix was meant to be simple and yet functional.  The fact that people have been able to carry it this far is sometime amazing.
10:26:49 <goron> Project management in short.
10:26:55 <mahogny> however, there are only two things that are really fatal for unix; that is the permission system and X. other than those, it is a great system
10:27:06 <mahogny> lispy, right
10:27:45 <lispy> but i'm having sound problems in linux this morning and about to boot into windows just so i can listen to music :(
10:27:48 <goron> mahogny: I agree with you on the permission systems.
10:27:55 <lispy> i usually listen from my ibook but that's not here today
10:28:21 <goron> lispy: yep, sound systems suck on Linux too when you don't have a special supported hardware card.
10:29:25 <mahogny> bsd/linux would be much nicer if they moved all config files and files belonging to programs to better places. if a simple rm -Rf was all you needed to remove a program, it would be much easier to work with the system
10:29:36 <ihope_> @unlambda `ri
10:30:08 <ihope_> @unlambda ``.H.ii
10:30:08 <lambdabot> Hi
10:30:13 <basti_> :-O
10:30:14 <ihope_> Aha!
10:30:23 <basti_> lambdabot has an unlambda interpreter now?
10:30:32 <mahogny> omg
10:30:34 <ihope_> It's had one for a while.
10:30:38 <goron> mahogny: Doesn't Klik already do that?
10:30:46 <basti_> o.m.f.g. >_<
10:30:52 <mahogny> goron, a distro?
10:30:57 <ihope_> @unlambda ````````````.H.e.l.l.or.w.o.r.l.d.!i
10:30:57 <lambdabot> Hello
10:30:57 <lambdabot> world!
10:30:58 <basti_> now we'll also need an extension to p
10:30:58 <goron> mahogny: no
10:30:59 <basti_> pl
10:31:10 <basti_> so that we can pl and then unlambda programs.
10:31:25 <goron> mahogny: Program which you can use to install programs, and I think it runs everything in a chroot.
10:31:34 <lispy> mahogny: you'd have to fix shells to do something more intelligent than $PATH if you really wanted to do that
10:31:40 <ihope_> A @turn-into-unlambda command?
10:31:50 <lispy> unlambdabot?
10:32:03 <mahogny> lispy, yes. but I rather see a more intelligent shell than a stupid file hierarchy :)
10:32:06 <ihope_> Yeah!
10:32:15 <mahogny> goron, sounds like it should be standard
10:32:30 <goron> mahogny: Yes, it is a good idea. 
10:32:41 <ihope_> @unlambda ````c`scicr
10:32:46 <goron> mahogny: What OS are you using?
10:32:48 <ihope_> Oops.
10:32:52 <ihope_> @unlambda ````c`sc.icr
10:32:52 <lambdabot> iii
10:32:57 <mahogny> goron, linux on desktop systems, netbsd on servers
10:33:52 <ihope_> @unlambda ````cc`sc.ir
10:33:53 <goron> mahogny: what are the biggest advantages for using netbsd? 
10:34:04 <goron> mahogny: (I know netbsd.org exists)
10:34:06 <lambdabot> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
10:34:06 <lambdabot> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
10:34:06 <lambdabot> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
10:34:06 <lambdabot> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
10:34:07 <mahogny> goron, next thing that really is needed; all .-files must go, and config files should be in a directory in the home. not in the root
10:34:09 <lambdabot> iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
10:34:29 <ihope_> Uh oh.
10:34:33 <goron> mahogny: No system wide configuration?
10:34:34 <mahogny> goron, netbsd is much more stable in my experience. it is gentoo style, but actually usable
10:34:51 <goron> mahogny: Define stable
10:34:57 <mahogny> goron, should exist as well, with userdefinable override
10:35:00 <roboko1> mahogny: why wouldn't gentoo be usable
10:35:01 <mahogny> goron, no crashes
10:35:14 <mahogny> roboko1, just from experience, linux has a worse uptime record than netbsd
10:35:20 <ohub> mahogny; I would say Gentoo is NetBSD style. Not another way around :)
10:35:33 <mahogny> ohub, right
10:35:36 <goron> mahogny: I never had Linux crash either (besides nvidia fuckups)
10:35:52 <mahogny> goron, I have had several
10:36:09 <goron> mahogny: Hmm, I have had FreeBSD 5.3 crash on my keyboard.
10:36:24 <goron> mahogny: But that was fixed pretty soon. 
10:36:25 <mahogny> goron, but usually not the kernel but rather stuff around it
10:36:40 <akemp> @seen dons
10:36:41 <goron> mahogny: oh, ok. 
10:36:59 <jip> i would love to use freebsd but i need linux for valgrind :(
10:37:15 <mahogny> goron, my guess is that due to linux rapid development lots of bugs sneak in. netbsd is old and stable, nothing more has to be added really
10:37:17 <akemp> @list
10:38:08 <goron> mahogny: I think Linux is more used in applications, and therefor gets adaptations. 
10:38:16 <ohub> I myself use NetBSD in workstations and servers. The good things really are: stable and working userland with good kernel, and pkgsrc.
10:38:51 <mahogny> goron, obviously. of all *nix, it is the most hyped one
10:38:56 <robokop> shit forgot router pass
10:38:59 <goron> mahogny: very true
10:39:03 <robokop> going down for a bit
10:39:12 <akemp> @listcommands
10:39:15 <akemp> @version
10:39:26 <robokop> @id test
10:39:37 <palomer> @hoogle scanl
10:39:39 <goron> I really like quality up to date binary packages. I don't find those in *BSD systems. 
10:39:56 <ohub> goron; how hard have you tried to look?
10:39:56 <akemp> lambdabot, how we will miss thee
10:39:59 <robokop> lambdabot: you there?
10:40:13 <ihope_> @bot
10:40:14 <palomer> I think it died
10:40:14 <goron> ohub: hard, and the probability of you giving me an URL with one is low. 
10:40:23 <mahogny> goron, pkgsrc?
10:40:41 <goron> mahogny: Doesn't that work the same as the FreeBSD one?
10:40:56 <goron> mahogny: I said "up to date". 
10:40:56 <mahogny> haven't played around much with freebsd
10:41:13 <goron> mahogny: IIRC with every release binary packages are build. 
10:41:23 <goron> mahogny: I.e. not "up to date".
10:41:33 <mahogny> aha. netbsd doesn't give you binaries
10:41:39 <ohub> mahogny; it doesn't?
10:41:46 <mahogny> it downloads the source and compiles on demand
10:41:48 <mahogny> like gentoo
10:42:01 <mahogny> gentoo is a netbsd ripoff essentially. just very userunfriendly
10:42:04 <ohub> mahogny; ftp://ftp.netbsd.org/pub/pkgsrc/packages/NetBSD-<version>/<platform>/All/
10:42:13 <sethk> NetBSD uses the bsd ports package that gentoo copied (only without the gentoo bugs)
10:42:53 <palomer> ack! lambdabot is dead!
10:43:10 <musasabi> There are also additional binary packages for those who want them.
10:43:11 <goron> ohub: And how often those packages are updated?
10:43:11 <mahogny> with netbsd, I see few reasons why one would like gentoo. it is the C++ of linux distros
10:43:31 <ohub> The Things with pkgsrc really is that you build your own packages with your own customizations and optimizations.
10:43:45 <goron> Considering the gigantic amount of software I have...  that would be impossible for me.
10:44:10 <ohub> What's your gigantic?
10:44:15 <akemp> @version
10:44:21 <mahogny> you normally use binaries for most of your OS. then pkgsrc if you want smaller upgrades
10:44:31 <mahogny> so it's not really gentoo in that way
10:44:34 <akemp> Oh my god!  They killed [lambdabot]!
10:44:54 <ohub> mahogny; No, I think most users use pkgsrc to do everything. without binaries.
10:44:57 <goron> ohub: 1998 packages
10:45:09 <ihope_> Yay, I found a Haskell datatype that represents a triangular number of something.
10:45:17 <mahogny> ohub, I feel sorry for them in that case
10:45:34 <lispy> ihope_: triangular number?  that's familar but i can't recall the definition
10:45:42 <ihope_> 0, 1, 3, 6, 10, 15...
10:45:52 <lispy> that's based on pascal's triangleL
10:45:53 <lispy> ?
10:45:56 <ihope_> Note the differences between those: 1, 2, 3, 4, 5.
10:45:57 <goron> ohub: You do not want to compile that many packages. I did run Gentoo, but there were to many compile errors.
10:46:00 <goron> er too
10:46:06 <lispy> ihope_: oh, yeah
10:46:15 <ihope_> It's the second "column" of Pascal's triangle.
10:46:32 <lispy> right
10:46:34 <lispy> cool
10:46:37 <ohub> goron; Well, why not? Pkgsrc hardly ever has any compiler errors. Only exception is ghc which is troublesome sometimes :(
10:46:45 <mahogny> goron, I don't think I have ever run into a compile error with netbsd. I don't think comparing gentoo with netbsd is a good idea; gentoo is the most hyped, worst linux distro you can find out there right now
10:46:49 <tromp_> it's map (!!2) pascal
10:46:55 <ihope_> s/second/third/
10:47:18 <ihope_> Say, I wonder if Pascal's triangle could be expressed in this datatype...
10:47:21 <goron> ohub: You have used it on the desktop >2 years?
10:47:34 <ohub> goron; like 7 years for workstations and servers :)
10:47:35 <tromp_> anyone see this?
10:47:45 <goron> ohub: Ok, that is impressive. 
10:47:47 <mahogny> goron, my university has used freebsd on all their desktops for a long time
10:47:57 <goron> I don't mind compilation that much, as long as it works.
10:48:00 <ihope_> ...No, it can't. This is only for finite triangles, I guess.
10:48:04 <palomer> Cale: I think this is what we want: http://www.rafb.net/paste/results/2PvOpm46.html
10:48:10 <ohub> And I have been tracking both NetBSD-current and pkgsrc-current all that time also.
10:48:28 <goron> Debian maintains copies of packages that are known to compile and therefor "Just Work". 
10:48:36 <goron> Does NetBSD do a similar thing?
10:49:01 <mahogny> AFAIK netbsd only release binaries with major releases. you compile all upgrades
10:49:12 <ihope_> Now, something that would be very ugly: a datatype representing a prime number of something.
10:49:26 <ohub> goron; http://www.netbsd.org/Goals/
10:49:58 <ohub> mahogny; Wrong! ftp://ftp.netbsd.org/pub/NetBSD-daily/
10:50:04 <mahogny> ohub, ooh
10:50:35 <tromp_> g'evening
10:50:50 <skew> shapr: have you tried that thread library?
10:51:17 <goron> ohub: I only see the kernel there. 
10:51:23 <goron> ohub: Point me to the packages.
10:51:46 <lambdabot> [24899 @more lines]
10:51:50 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 13 hours, 13 minutes and 22 seconds ago.
10:51:54 <lambdabot> list [module|command]. Where modules is one of:
10:51:55 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
10:51:58 <lambdabot> unlambda version vixen where
10:52:01 <ihope_> Whee.
10:52:06 <lambdabot> Unknown command, try @list
10:52:08 <lambdabot> lambdabot 3p424, GHC 6.4.1 (Linux i686 3.20GHz)
10:52:10 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:52:12 <lambdabot> test
10:52:23 <ohub> goron; Releng server is only for NetBSD releases. Pkgsrc is living its own life.
10:52:36 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
10:52:38 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
10:52:44 <lambdabot> :)
10:52:46 <lambdabot> lambdabot 3p424, GHC 6.4.1 (Linux i686 3.20GHz)
10:52:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:53:12 <ihope_> I think @unlambda needs to be threaded!
10:53:17 <tromp_> > 0+0
10:53:17 <ohub> goron; pkgsrc is a packaking system usable in many different operating system. It works in Linux, Solaris, HP-UX, IRIX, Windows (yes..), Free/Open/NetBSD
10:53:22 <lambdabot> 0
10:54:03 <ohub> There are some Linux distributions using pkgsrc as a package management system. DragonflyBSD is using it also.
10:54:44 <goron> ohub: I thought I had my point quite clear.
10:54:59 <goron> ohub: The point is that I need up to date binary packages. 
10:55:08 <goron> ohub: You said NetBSD provides those. 
10:55:22 <goron> ohub: I just want to see where. 
10:55:27 <ohub> goron; yes, NetBSD binary packages are in releng.netbsd.org
10:55:34 <akemp> @list
10:55:34 <lambdabot> list [module|command]. Where modules is one of:
10:55:34 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
10:55:34 <lambdabot> unlambda version vixen where
10:55:37 <akemp> @seen dons
10:55:38 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 13 hours, 17 minutes and 13 seconds ago.
10:55:45 <akemp> @seen shapr
10:55:46 <lambdabot> shapr is in #haskell, #haskell-blah, #haskell-overflow and #scannedinavian. I last heard shapr speak 1 day, 2 hours, 39 minutes and 51 seconds ago.
10:56:03 <goron> ohub: But those are only for releases....
10:56:10 <skew> 24899 more lines?
10:56:16 <ohub> goron; Yeah?
10:56:25 <skew> hmm, I guess the unlambda interpreter ran out of stack or something after a while
10:56:50 <ohub> goron; Well, if you want the latest binaries, then you want -current: ftp://ftp.netbsd.org/pub/NetBSD-daily/HEAD/200604290000Z/i386/binary/sets/
10:57:11 <goron> ohub: Uh, well, that only contains the kernel, right?
10:57:17 <ohub> goron; Nope
10:57:24 <ohub> goron; Fully working operating system.
10:57:33 <mahogny> goron, he means all programs
10:57:46 <goron> ohub: Yes, and the standard userland...
10:57:54 <goron> ohub: Of course that is *not* what I mean.
10:58:12 <ohub> Well, that is NetBSD. And you wanted NetBSD.
10:58:20 <mahogny> duh
10:58:23 <goron> ohub: No... when did I say that?
10:58:43 <mahogny> goron,  I don't see why it is a problem to compile upgrades. doesn't take long compared to compiling *the whole system*
10:58:44 <goron> ohub: You obviously do not want to have a conversation.
10:58:59 <ohub> goron; So, what you really want is binaries compiled from pkgsrc?
10:59:08 <goron> mahogny: When it all Just Works, I don't see a problem either.
10:59:15 <goron> mahogny: At least not a big problem.
10:59:20 <ohub> goron; I think I gave you a link there already.
10:59:27 <mahogny> goron, pkgsrc usually just work
10:59:29 <goron> ohub: I think you didn't.
10:59:55 <sethk> the netbsd package system is one of the most stable
11:00:11 <sethk> binary package managers don't always "just work" either
11:00:15 <ohub> goron; ftp://ftp.netbsd.org/pub/pkgsrc/packages/
11:00:59 <mahogny> ohub, but those aren't as up to date as the pkgsrc sources right?
11:01:25 <ohub> mahogny; I'm not sure about the state of automatic bulk builds of pkgsrc system.
11:01:43 <goron> ohub: FYI that was the whole point of the discussion...
11:02:26 <ohub> But of course the big problem here is money.
11:02:26 <musasabi> It depends on what you want.
11:02:54 <musasabi> If you want the latest CVS HEAD versions of everything you should compile them yourself since they change daily.
11:03:03 <ohub> It's hard to build all packages every day for every supported operating system and platform.
11:03:06 <mahogny> goron, still, I think day-fresh upgrades are overrated. what you want are stable binaries and then you can usually live happily with even two months-half a year old copies without lacking features.
11:04:04 <goron> ohub: Debian builds packages often, I think daily. They really did something good.
11:04:13 <ohub> goron; But only for Debian.
11:04:27 <resiak> goron: I don't think they build the whole archive daily.
11:04:27 <goron> ohub: Any idea on how many platform Debian runs?
11:04:28 <mahogny> debian packages are buggy
11:04:34 <ohub> goron; They don't build packages for Solaris, HP-UX, Linux in general or all NetBSD's supported platforms.
11:04:45 <mahogny> ohub, you are missing the point
11:04:45 <ohub> goron; fewer that NetBSD and pkgsrc :)
11:04:56 <ohub> mahogny; No, I'm not. The point is money. :)
11:04:58 <Igloo> Debian doesn't build packages daily
11:05:05 <Igloo> mahogny: IWW?
11:05:13 <Igloo> mahogny: IWW buggy, that is
11:05:21 <mahogny> IWW??
11:05:25 <Igloo> In What Way
11:05:28 <goron> Igloo: Every week?
11:05:31 <mahogny> Igloo, crashes
11:05:45 <Igloo> mahogny: When? On what arch?
11:05:56 <mahogny> Igloo, when I use them, on i386
11:06:05 <Igloo> goron: There is no automatic periodic build of Debian packages
11:06:35 <Igloo> mahogny: If you don't give any useful informatino then I can't fix the problem
11:06:37 <goron> Igloo: Oh, I thought you had this nice automatic build system, as said some FTP Debian maintainer
11:06:55 <Igloo> goron: Packages are automatically built by all arches when they are uploaded
11:07:08 <goron> Igloo: Isn't that the same?
11:07:20 <goron> Igloo: oh, I see the difference
11:07:31 <goron> Igloo: well, no need to rebuild when there is nothing new.
11:07:35 <mahogny> Igloo, I usually don't bother. I just install a different program or a different version. takes much less time
11:08:33 <musasabi> goron: are you after the bleeding edge stuff or stable binaries or something entirely else?
11:08:39 <skew> mahogny: Igloo is a Debian developer, if you missed that.
11:08:49 <mahogny> skew, I kind of noticed :)
11:09:02 <skew> yay, I'm not totally confused
11:09:30 <goron> musasabi: Some things stable, other things bleeding edge, which I get myself via darcs/svn/cvs.
11:10:43 <musasabi> goron: so what problem is there with stable binary packages (as you wouldn't be using them for the bleeding edge stuff in any case) ?
11:10:46 <skew> I don't remember too many problems, except where I've manually overwritten bits of installed packages
11:11:23 <skew> although, after  much reading of docs, I still can't see how to downgrade packages with apt
11:11:32 <goron> musasabi: Well, I remember that on FreeBSD, when I wanted to compile some software, the packages were too old. I basically had to get everything from source. 
11:11:36 <resiak> skew: I think the canonical answer is "you don't downgrade"
11:11:54 <goron> musasabi: Debian Unstable doesn't lag that much. 
11:12:00 <skew> seeing as I've wandered into #unix-distro-discussion, mgith as well join the fun
11:12:10 <mahogny> lol
11:12:15 <musasabi> goron: isn't that the same situation as when debian has too old packages? happens all the time.
11:12:27 <goron> musasabi: yes, same situation.
11:12:41 <mahogny> I still find it silly to fight over distros, considering all unix are broken, which is a very common problem :)
11:12:45 <skew> resiak: that's what it seemed like. I solved the problem by waiting till ATI came out with drivers for the newer XOrg too.
11:12:46 <mahogny> *takes on the war*
11:12:55 <palomer> get   = State $ \s -> ((),s)  <--could this be an alternative definition of get?
11:13:08 <goron> mahogny: Plan 9 is better?
11:13:14 <skew> palomer: that looks more like getAndTrashState
11:13:30 <mahogny> goron, never heard about it *googles*
11:13:47 <musasabi> Plan9 lacks useful apps.
11:13:49 <goron> Or Hurd ;)
11:14:07 <goron> You can run KDE on Hurd, IIRC.
11:14:09 <skew> has anyone seen Haskell AIO, epoll bindings?
11:14:48 <goron> skew: indeed
11:14:58 <musasabi> epoll bindings exist, e.g. in network-alt.
11:15:20 <skew> ok. I'm reading this http://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf
11:15:35 <mahogny> goron, it seems way too unix to be good
11:15:43 <Igloo> skew: You can do apt-get install foo=version. I'm not sure if apt-get install foo -t stable would work too.
11:15:46 <jip> is there a compile flag to disable all Debug.Trace calls?
11:16:02 <skew> mahogny: plan 9 has some interesting stuff
11:16:09 <skew> like complete network transparency
11:16:38 <musasabi> jip: have your own module called Debug with #ifdef DEBUG debug = trace #else debug = const #endif
11:17:03 <skew> if you don't mind rebuilding everything to toggle your flag
11:17:33 <mahogny> skew, I think network transparency would be a minimal requirement if you design a new OS. that's not enough to impress
11:17:46 <palomer> skew: what would it do?
11:18:40 <palomer> newtype State s a = State { runState :: (s -> (a,s)) }  <---notice that this is the definition of State
11:18:52 <goron> mahogny: If we only restrict to the kernel, and ignore X, and the FS, then what remains broken in Linux?
11:19:04 <skew> palomer: what would what do?
11:19:07 <musasabi> The Coyotos people are moving into a nice direction, but there is not yet much code.
11:19:24 <mahogny> goron, nothing really broken. it just lack features
11:19:26 <palomer> get   = State $ \s -> ((),s)
11:19:41 <skew> palomer: your get funciton looks like it either returns () as the value, or returns the state as the value and makes () the new state
11:19:44 <musasabi> goron: macrokernel which makes hard to reason about permissions.
11:19:57 <mahogny> goron, and I would really like to see a proof of correctness, but that is asking for a lot
11:20:17 <skew> mahogny: transparency in an OS that's actually out there running is more impressive
11:21:17 <mahogny> skew, well. as I usually say, OS design is still at the level "whoaa! it compiles" but maybe one day we might have an OS that actually also can do something. that's some light of hope at least
11:22:19 <skew> musasabi: microkernel design without hardware protection sounds good, though
11:22:30 <palomer> skew: yes, I see it now
11:22:47 <newsham> without hardware protection?
11:22:51 <skew> palomer: get for a trivial state monad is usually just s -> (s,s)
11:23:04 <newsham> you mean relying on type-safety to ensure security?
11:23:09 <mahogny> I think the microkernel vs macrokernel discussion indeed shows that we are still at the "it compiles!!"-state :) we should be talking about what the kernel should be able to do, not how to implement it
11:23:15 <skew> newsham: yeah, something like that
11:23:39 <newsham> http://www-spin.cs.washington.edu/
11:23:59 <newsham> (there's nothing new under the sun)
11:24:00 <goron> mahogny: Proofs would be nice, but there are too little developers with such skills. 
11:24:15 <mahogny> goron, yeah
11:24:16 <skew> goron: that's why we need to work on the skills of our compilers
11:24:31 <goron> skew: Compilers need types.
11:24:42 <newsham> house is using formal statements in their source code.
11:25:04 <newsham> (using the p-logic system)
11:25:08 <mahogny> what we need is an army of mathematicians. teach them all to code and then let them go loose on writing an OS
11:25:09 <goron> skew: And types that do something useful are not created by people with 1337 skillz.
11:25:11 <skew> yeah, and you can sumugle in safety properties on the types of library functions
11:25:52 <newsham> i think there have been some attempts at a formally proved "high assurance" operating systems
11:25:54 <skew> if type checking is close enough to proof checking, getting the code to compile is as close to a proof as the developer needs to get
11:26:07 <skew> newsham: I think Galois has something like that
11:26:13 <mahogny> newsham, A1 class surely. but they don't come cheap
11:26:35 <newsham> has anything ever been assigned A1?
11:26:58 <mahogny> IMO types are overrated in the FP-community and underrated in the imperative community :(
11:27:07 <mahogny> newsham, that would be something military/governmental I guess
11:27:46 <newsham> "trusted mach" is one attempt
11:28:02 <newsham> designed for B3 though, not A1.
11:29:00 <mahogny> someone should code something like OSkit, but industrial performance and only bare minimum ie drivers. then we could write lots of actually usable OS on top of it
11:29:34 <newsham> mahogny: it seems that tinkerers are moving away from the oskit approach and towards hypervisors (since they are the buzzword of the day)
11:29:48 <newsham> load your os next to an os that has lots of drivers (ie. linux) and use their drivers
11:30:17 <mahogny> newsham, I barely see any advantage with hypervisors. just an extra layer slowing things down
11:30:37 <newsham> dev drivers :)
11:30:50 <mahogny> you don't need a full hypervisor for that :)
11:31:15 <skew> mahogny: that point of a hypervisor system is to avoid an extra layer slowing things down
11:31:16 <newsham> cool.  you want to point me to another practical solution that I can actually use today?
11:31:21 <newsham> (dont say oskit, its dated)
11:31:37 <SimonRC> drakioned: If you're going to make anything like screen, *please* make it emulate an xterm or something like it, as screen emulates an extended vt100 and looses all those wonderful mouse control codes.
11:32:07 <mahogny> skew, to some extent. two OS can't possibly run at the same time accessing the same hardware
11:32:08 <SimonRC> drakioned: Just becuase it is text mode doesn't mean it has to be primitive.
11:32:12 <newsham> simonrc: 2006 and still emulating teletypewriters :)
11:32:31 <skew> mahogny: certainly compared to complete virtualization of an x86 system, which requires emulation or jit recomplication on protected instructions
11:32:32 <palomer> @paste
11:32:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:32:49 <palomer> @lisppaste
11:32:49 <lambdabot> Unknown command, try @list
11:32:52 <mahogny> skew, either you have to 1.partition the hardware or 2.you have to put in a layer protecting it. 1 is almost meaningless, 2 is an extra unavoidable layer 
11:32:57 <mahogny> skew, of course
11:33:02 <SimonRC> newsham: have you used w3m *directly* under an xterm ever?
11:33:11 <newsham> the hypervisor is (at least in theory) a very thin layer.
11:33:13 <skew> mahogny: do you know much about these systems?
11:33:18 <palomer> skew: http://www.rafb.net/paste/results/stDQGe86.html  <--this is what I'm going for (but it's incredibly broken at the moment)
11:33:21 <SimonRC> newsham: the mouse is so cool
11:33:21 <newsham> w3m?
11:33:28 <SimonRC> a web browser
11:33:31 <SimonRC> good one, too
11:33:33 <mahogny> skew, haven't used hypervisors. but the design implications are clear
11:33:37 <newsham> nope.
11:33:42 <SimonRC> has tabs, though not background loading
11:33:49 <akemp> @seen shapr
11:33:55 <lambdabot> shapr is in #scannedinavian, #haskell-overflow, #haskell-blah, #haskell and #ScannedInAvian. I last heard shapr speak 17 days, 19 hours, 57 minutes and 14 seconds ago.
11:34:00 <SimonRC> and mouse support in xterm, of course
11:34:05 <mahogny> skew, they are probably very good for OS implementation, but I think that really thin layer it leaves is enough to rule it out for industrial use
11:34:31 <skew> mahogny: well, the thing is that x86 already provides protection levels, and ring 1 gives you direct access to most stuff an OS would want to do anyway
11:34:41 <newsham> I thought we were talking about providing dev driver support for projects that cant afford to invest in rewriting them all.
11:34:54 <palomer> someone remind me what the definition of >> is 
11:35:02 <newsham> "industrial use" can pick a small set of drivers and fix the target platform.
11:35:13 <skew> mahogny: people run vmware for industrial use
11:35:15 <mahogny> skew, yes. but the burning question is what happens if both OS wants to use the same harddrive?
11:35:25 <skew> mahogny: unless you mean embedded
11:35:25 <mahogny> skew, yes. *that* is a sad state :(
11:35:30 <xerox> amb >> f = amb >>= \_ -> f
11:35:41 <newsham> mahogny: works fine as longas they're not using the same parts of the same hard drive
11:35:56 <newsham> hypervisor has a queue for hard drive tasks.  you put your request in the queue and get a reply out of it
11:36:05 <xerox> palomer: seen?
11:36:14 <skew> mahogny: you seem to be claiming a minimum standard for "industrial usability" a few orders of magnitude better than things actually used industrially
11:36:27 <newsham> as long as you're not both trying to share the same filesystem storage there's no conflict
11:36:29 <mahogny> newsham, exactly. so there comes the extra layer that you would avoid otherwise
11:36:39 <newsham> as I mentioned, its a very thin layer.
11:36:39 <skew> huh?
11:36:49 <newsham> (not to mention its a layer of code that you would normally have rwitten into yoru OS anyway)
11:37:01 <mahogny> skew, indeed. unlike todays very immature industry, I actually put some demands on the software
11:37:19 <mahogny> newsham, true that
11:37:27 <newsham> ie. in xen they use a lock-free shared queue.
11:37:32 <skew> you are not going to avoid something like that if you are running several operating systems side by side
11:37:35 <newsham> intentionally designed for high perf
11:37:44 <mahogny> skew, of course
11:37:55 <palomer> xerox: seen?
11:38:06 <skew> and a tiny bit of inter-domain communication on top of the disk IO costs is not a big deal
11:38:11 <mahogny> newsham, question is, would the performance be the same if you run a single OS on that as if you implemented it directly into the OS?
11:38:17 <newsham> intel and amd are shipping cpus soon with VM support.
11:38:25 <skew> mahogny: read their papers
11:38:28 <skew> mahogny: pretty much yes
11:38:43 <mahogny> well, it's a step in the right direction anyhow
11:38:51 <newsham> mahogny: nope.  if you hand code your own os in assembly using cutting edge techniques you can get an order of magnitude better performance.
11:38:53 <newsham> thats life.
11:39:04 <skew> newsham: for disk IO?
11:39:16 <SamB> um
11:39:21 <skew> I think the CPU could probable compute disk offsets in unary without affecting disk performance too much
11:39:22 <SamB> uh
11:39:23 <newsham> but in practice real system on real hardware vs. real system on xen, the performance diff is within a few percent (quite impressive)
11:39:24 <musasabi> newsham: isn't that mostly only for critical paths.
11:39:43 <SamB> cutting edge techniques and hand-code OS in ASM, in the same sentence?
11:39:51 <mahogny> lol
11:40:02 <newsham> samb: http://citeseer.ist.psu.edu/22153.html
11:40:10 <skew> where by "hand-code" he means let ghc generate the code, obviously
11:40:11 <musasabi> e.g. fast path of IPC not needing to switch to kernel page tables.
11:40:27 <newsham> grad student wrote custom os for 68k that was an order of magnitude faster than anye xisting system
11:40:27 <SamB> you *can't* hand-code your own OS in ASM using cutting-edge techniques
11:40:42 <skew> an army of grad students works too
11:40:59 <SamB> the cutting edge would pass you by before you were half done!
11:41:12 <newsham> i dont believe in armies (of grad students or otherwise)
11:41:30 <palomer> ok, how do I add a page to the haskell wiki?
11:41:52 <mahogny> it is not hard to write a language that is faster than assembly
11:41:54 <palomer> (there should really be an easier way to do this)
11:42:08 <palomer> btw, has anyone thought of making the haskell wiki wikipedia style?
11:42:35 <SamB> palomer: that isn't the default?
11:42:53 <SamB> palomer: I was assuming the style was deliberately different
11:43:05 <skew> mahogny: how does that work?
11:43:15 <skew> mahogny: quicker to write, sure.
11:43:15 <SamB> skew: easy!
11:43:33 <newsham> samb: i assume you're reading the citeseer ref.
11:43:42 <palomer> SamB: I mean convert it to a wikipedia based wiki
11:43:49 <SamB> newsham: um, sure!
11:43:53 <SamB> palomer: we are already doing that!
11:44:01 <palomer> what's the address?
11:44:04 <palomer> I'm using hawiki right now
11:44:06 <palomer> (huge pain)
11:44:12 <SamB> @google haskellwiki
11:44:14 <lambdabot> http://www.haskell.org/haskellwiki/Haskell
11:44:16 <mahogny> skew, easy. just take into account that assembly is messy and has to be manually upgraded as soon as the CPU comes with newer features and new benchmarks. so unless you are really dead keen on keeping your assembly up to date, compilers will soon or later swamp your assembly
11:44:18 <SamB> yeah, thats it
11:44:19 <newsham> after all, you seemed so sure that advanced techniques cannot be applied to assembly, you must be dying to hear about it
11:44:52 <palomer> but it doesn't look anything like wikipedia!
11:44:55 <SamB> palomer: also, the software is called mediawiki
11:45:12 <palomer> oh, we're using mediawiki?
11:45:13 <SamB> and it has templates, you know!
11:45:21 <palomer> ok, how do I add a page?
11:45:27 <newsham> typical irc.
11:46:02 <skew> mahogny: so you are really saying that you can make a language that's faster to develop in in assembly, and that translates to performance as architectures change
11:46:08 <SamB> well, you could go to a page that doesn't exist, probably
11:46:24 <SamB> I have *no* idea why all the links are hidden at the bottom...
11:46:33 <mahogny> skew, yes. as soon as you take reality into account, assembly loses
11:47:27 <SamB> ASM sucks for anything but inner loops or quick ways to do certain things
11:48:01 <mahogny> well, if one can avoid it, one should
11:48:26 <skew> mahogny: that's different from saying your language is faster before you make some assumptions about reality
11:48:32 <SamB> and one should only use it for the things that could really benefit from it
11:49:28 <skew> mahogny: there are some more interesting cases like FPGAs
11:49:45 <palomer> SamB: how do I go to a page that doesn't exist?
11:49:46 <mahogny> skew, of course. that comment is actually a quote from before, especially meant to piss off people during the years assembly was really hyped ;)
11:49:57 <SamB> palomer: that box at the bottom, which should be at the top.
11:50:08 <SamB> and click the Go button.
11:50:21 <skew> although, I guess programming in the native assembly isn't so reasonable on ordinary CPUs either, but FPGAs have no remotely usable form of assembly
11:50:38 <SamB> skew: well duh ;-)
11:50:43 <jip> you guys recommended making my own (!) function to overwrite the array (!) in order to find the array out of bounds. how do i make sure that my (!) function is being used and not the array one?
11:50:58 <mahogny> skew, don't give anyone strange ideas. I'd like to keep it that way :)
11:51:01 <skew> I don't see epoll stuff in network-alt
11:51:14 <SamB> jip: don't import (!) unqualified
11:51:17 <palomer> SamB: it simply says it can't find it
11:51:34 <SamB> jip: and note that the compiler will not compile if you import two different (!)s
11:51:48 <SamB> well, assuming you try to use one
11:52:48 <jip> SamB: yeah it says Ambiguous occurrence
11:53:01 <jip> SamB: but now i must modify all of my .hs source files that use arrays!
11:53:16 <SamB> jip: I suppose
11:53:38 <SamB> you could make a convenience module that exports most of the stuff most of your modules use
11:53:52 <skew> what are you trying to do?
11:54:04 <skew> ! is raising an error and you are trying to track it down?
11:54:14 * palomer gives up trying to add a page to the wiki
11:54:39 <jip> skew: yes! but i'm not actually sure if it's (!) or (//), i get "Error in array index"
11:55:21 <skew> fortunately for you, I just read bits of the user's guide
11:55:36 <skew> try building for profiling and running with the -xc option
11:55:40 <skew> supposedly that does good things
11:56:16 <SamB> skew: well, that would be great if jip had the profiling libraries installed
11:56:19 <jip> skew: tried that, got only a cryptic message
11:56:34 <Cale> jip: the most common problem causing that is making a mistake in the indices when creating the array
11:56:35 <jip> something <GHC.CAF> or something like that
11:56:37 <SamB> which cryptic message?
11:56:50 <Cale> remember that it's ((xmin, ymin), (xmax, ymax))
11:56:55 <SamB> oh, so you do have the profiling libs installed?
11:57:12 <jip> Cale: yeah, i did that once, but that's definitely not my problem now
11:57:16 <jip> SamB: which profiling libs?
11:57:41 <skew> jip: that means it's a top level value, I think
11:59:48 <skew> hmm
12:00:21 <jip> what i don't get is, it seems that the (!) and (//) already have bounds checking and are giving an "Error in array index" error, why don't they just go all the way and also print out the bounds of the array and the invalid index that was tried?
12:01:08 <SamB> jip: well, Show isn't a superclass of Ix
12:01:42 <SamB> it would be nice if there was a way around that!
12:01:46 <jip> hm... i guess you are right
12:01:48 <SamB> open research problem ;-)
12:02:07 <jip> would be cool if there was some way of doing a test if the Ix that is in use happens to be also showable then show it
12:02:31 <SamB> yes!
12:02:33 <SamB> exactly
12:03:02 <jip> some sort of optinial type constraint
12:04:48 <xerox> palomer: xerox: amb >> f = amb >>= \_ -> f
12:04:58 <skew> man, none of these profiling options seem to help
12:05:05 <skew> -caf-all, -auto-all, -auto
12:05:35 <SamB> skew: delete .o file first?
12:05:49 <SamB> or .p_o or whatever
12:06:38 <skew> I've been doing that
12:07:01 <skew> apparently the head [] error always gets assigned to GHC.List.CAF
12:07:17 <skew> no matter what you do the function where you are causing the error
12:07:40 <SamB> hmm. isn't there a way to get it to show the cost center stack?
12:08:10 <skew> that's what it shows for the stack
12:08:35 <SamB> oh, and it doesn't show anything further down than GHC.List.CAF?
12:08:40 <SamB> or up
12:08:42 <SamB> whichever
12:09:02 <skew> neither
12:10:51 <skew> seems to work better with throw
12:10:59 <palomer> Cale: here's the monad: http://www.rafb.net/paste/results/wVrfAB30.html
12:11:14 <palomer> Cale: could you clean it up and add it to the wiki? (I don't know how:/)
12:12:56 <skew> I like this threads paper
12:13:39 <SamB> speaking of which, the stuff at the bottom of the haskellwiki template shouldn't be there...
12:15:45 <skew> They say "with threads, application code is straighforward but the scheduler is tricky"
12:16:11 <skew> They say "with events, the scheduler is straightforward, but the application code is tricky"
12:16:19 <mahogny> xerox, ok, got another student on my list. writing haskell bindings for ATLAS
12:16:38 <skew> "So, we'll write a tricky library that lets application code look like threads, and scheduler code look like an event loop"
12:16:53 <skew> an then it turns out that the library is just a little CPS thing
12:17:50 <xerox> mahogny: haha, you've got many :-)
12:18:00 <xerox> mahogny: find some fot the orphaned projects :-)
12:18:02 <mahogny> it's quite obvious that CPS can be used for this. but I find CPS to be a bit messy to use. for obvious reasons, you have a monad running around which is hard to get rid of
12:18:14 <mahogny> xerox, find more? I almost think I have too many lol
12:18:37 <mahogny> aha. for :)
12:18:38 <xerox> mahogny: I mean, for other projects, some mentors doesn't have pupils yet
12:18:44 <mahogny> let me check around
12:18:47 <skew> mahogny: why do you want to get rid of a monad?
12:19:08 <mahogny> skew, because I find monadic code ugly in many cases. it clutters
12:19:20 <skew> a monad expresses the language semantics you are providing
12:19:48 * xerox got again into pugs, couldn't resist
12:20:12 <mahogny> xerox, I believe the problem with the other projects is that those are really deep down into haskell. that's why so few are applying
12:20:20 <palomer> @pl (\y -> map Just  $ catMaybes lst)
12:20:21 <lambdabot> const (map Just (catMaybes lst))
12:20:31 <palomer> @pl (\y -> map Just  $ catMaybes y)
12:20:32 <lambdabot> map Just . catMaybes
12:20:53 <xerox> mahogny: I should add some not on the StartPage in which I tell students to ask mentors about projects before deciding that "they're too heavy" or something.
12:20:54 <SamB> hmm, theres a lot of interested students...
12:20:59 <xerox> Projects can be adjusted.
12:21:12 * SamB is kind of intimidated
12:21:19 <rasterfar> skew, that paper sounds good -- did you post a link?  (Just got here; not seeing it in scrollback.)
12:21:28 <SamB> also, seriously find a mentor for ParsecT
12:21:36 <xerox> SamB: try yourself too.
12:21:46 <skew> http://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf
12:21:48 <SamB> what, me?
12:21:49 <mahogny> xerox, alberto ruiz could probably handle the ATLAS student I just got in case I end up having two. he has a similar project
12:21:53 <SamB> I don't know anybody!
12:22:19 <Cale> CPS monads are a bit messy to use because they tend to give you things like first-class generalised goto labels with the ability to pass values back into various points in the computation -- which tends to be a really hard thing to work with.
12:22:35 <mahogny> xerox, I'm really surprised no one has jumped at the bioinformatics project. it's not like the bioinfo community is small or anything :)
12:22:42 <skew> they didn't expose any of that stuff
12:22:54 <xerox> SamB: mail the Interested Mentors of the projects you like!
12:23:00 <palomer> how do I get the first element of a list satisfying a predicate, or Nothing if no member exists?
12:23:08 <xerox> Oh, hmm, sorry your situation is different.
12:23:22 <jip> palomer: firstElem
12:23:28 <Cale> palomer: find
12:23:30 <int80_h> greetings
12:23:30 <Cale> @type find
12:23:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:23:35 <mahogny> Cale, hm. why would one design the CPS to do something like that?
12:23:38 <SamB> xerox: I could decide I like other projects too
12:23:47 <skew> pretty much, they just made a CPS monad that hides the transformation you do to turn threaded code into event-based code
12:23:50 <xerox> SamB: Cale maybe would be up for mentoring on ParsecT? Cale?
12:23:59 <palomer> Cale: did you get my msg about the monad?
12:24:00 * xerox thinks he's the man
12:24:02 <Cale> mahogny: there's no way to suppress that -- continuation monads give you that
12:24:14 * int80_h thought he was the man all this time.
12:24:15 <skew> Cale: no, only if you expose thtat
12:24:20 <SamB> so did anyone get in touch with daan?
12:24:28 <mahogny> Cale, hm. ah. now I see what you mean
12:24:29 <skew> just because your monad does CPS, doesn't mean you need to expose continuations
12:24:32 * Korollary greetz int80_h violently
12:24:35 <mahogny> Cale, why are they so hard to work with?
12:24:38 <Cale> skew: callCC is enough, and without it, you might as well not use Cont
12:24:51 <skew> Cale: check the paper
12:25:05 <Cale> xerox: I suppose I could.
12:25:44 <xerox> Nice.  Time to add yourself on the trac? (link is in the topic=
12:26:10 <Cale> there are various things like delimited continuations which you can use to try to limit the confusion
12:26:29 <xerox> Cale: is there any other implementation than TheHunter's one of them?
12:26:29 <mahogny> xerox, I have one (unconfirmed) student that wishes to write an IDE. I need to thin it down if he goes that way but it sounds like someone should convince him to hack on hIDE instead. they just need to find something that fits him
12:26:43 <xerox> mahogny: hIDE doesn't really "work" at the moment
12:27:02 <mahogny> xerox, sounds like there is a lot to hack on then :)
12:27:05 <waern> won't it be hard to define something rigid enough to constitute a 'project' when working on hide?
12:27:11 <xerox> mahogny: dunno if it's the case, but there are a bunch of projects that need to be done in order to get along with hIDE again
12:27:28 <skew> is there a poll binding in the GHC libraries?
12:27:28 <xerox> See http://haskell.org/hide
12:27:43 <skew> I thought I had seen one, but I'm not seeing it any more
12:27:47 <mahogny> xerox, well. you can tell them that if they come up with something solid, I can pass the information
12:28:01 <xerox> mahogny: mind to Cc: the mail to me too?
12:28:03 <lispy> skew: if not, that sounds pretty easy to do with the ffi
12:28:10 <newsham> projects?  why not someone make hws better?
12:28:54 <skew> lispy: yeah, I just wanted some inspiration for the Haskell interface
12:29:19 <palomer> whew, my unification algorithm is 15 lines long
12:29:20 <skew> I'm actually trying to do epoll and aio, to fill out the missing bits of code from that paper
12:29:29 <skew> palomer: does it use your new monad?
12:29:48 <xerox> mahogny: I added a note on the StartPage
12:30:07 <lispy> skew: i think the hardest part would be converting haskell lists of handles into C list of file descriptors
12:30:36 <lispy> skew: oh wait, i might be thinking of a different function
12:30:49 <SamB> so, hmm, what should I do to prepare for the first?
12:30:59 <lispy> skew: oh, i'm thinking of select
12:31:07 <mahogny> xerox, ok
12:31:11 <xerox> mahogny: danke.
12:31:12 <skew> I'm not quite sure I quite believe the paper that stm actions can be considered nonblocking
12:31:22 <mahogny> xerox, which was your addy?
12:31:23 <lispy> skew: poll is probably even easier than i was thinking
12:31:27 <xerox> mahogny: paolo at nemail it
12:31:29 <skew> lispy: epoll avoids you making any lists to pass in
12:31:50 <palomer> skew: yup
12:31:54 <skew> for poll you do need to make a list of everything to wait on
12:32:08 <palomer> skew: but that only shortens the code for failure (to mzero, no less)
12:32:11 <skew> you need an array to get events out, but you can just fix some size
12:32:33 <skew> palomer: are you backtracking in the unification algorithm?
12:33:03 <palomer> skew: oh no, it doesn't use the backtracking
12:33:08 <palomer> unification can easily be done with State
12:33:16 <palomer> (or, as I was doing before, ST)
12:33:27 <palomer> it uses the fact that my monad is an instance of MonadPlus
12:33:40 <musasabi> STM can block.
12:33:50 <palomer> but STM injects into IO
12:34:02 <palomer> and it doesn't have other nice properties which I need
12:34:41 <musasabi> Think about "maybe retry return =<< takeTVar" for pure STM.
12:36:08 <lispy> @type maybe
12:36:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:36:25 <Cale> skew: ah, the monad uses CPS internally, but doesn't expose it in any major way. That's a little different than what I was thinking. 
12:37:09 <mahogny> xerox, oh yes, drakioned wants to write a MUD as well. I think it can be handled in the time, but I want to talk with him before I make it definitive
12:38:14 <SamB> What can I do to prepare for applying to SoC on monday?
12:38:36 <palomer> do you have to apply on monday?
12:38:38 <joelr1> good afternoon
12:38:45 <skew> musasabi: yeah, I think the idea was that you only pass things that don't block themselves, and then with a fixed number of worker threads stuff gets through
12:38:47 <lispy> good noon
12:39:07 <joelr1> is there any blogging software written in haskell?
12:39:15 <skew> joelr1: I think you will like this paper: http://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf
12:40:01 <joelr1> skew: thanks, i picked that up off of LtU a day or two ago
12:40:13 <joelr1> they should have a software release next week
12:40:22 <musasabi> skew: that breaks if your loops are longer than the number of worker threads.
12:40:51 <skew> what loops?
12:41:21 <musasabi> skew: transactions blocking depending on each other.
12:41:40 <skew> ah, that's not what I'm talking about
12:41:59 <skew> if your transactions don't explicitly call retry, they can't block
12:42:06 <skew> and can only be delayed by interference
12:42:30 <skew> but the implementation guarantess that at least one will finish in that case, if you just have a fixed number running
12:42:44 <musasabi> yes, then again e.g. Control.Concurrent.STM.TMVar uses retry I think.
12:43:02 <skew> yeah, so if you use blocking stuff like TMVar there is trouble
12:43:11 <skew> that's why I'm suspicious
12:43:30 <palomer> omg my monad rocks!!
12:43:41 <xerox> :-)
12:44:30 <skew> palomer: throw a quarter in Moggi's tip jar
12:44:41 <palomer> eh?
12:44:42 <palomer> why?
12:44:55 <xerox> He's the godfather.
12:45:12 * mahogny wonders if Xen could be hacked enough to run almost-stand-alone
12:45:19 <Cale> He's one of the first people to consider using monads in programming
12:45:21 <xerox> Man, he teaches 100km south of me, and they don't do Haskell there.
12:45:49 <xerox> They do some "functional programming" in OCaml and that's all :-|
12:46:00 <SamB> Cale: so do you think ParsecT is a large enough project?
12:47:48 <Cale> SamB: yeah, actually, quite possibly
12:48:04 <skew> wow, these epoll, aio worker threads each fit in 80 chars
12:48:14 <SamB> "quite possibly"?
12:48:31 <Cale> The tricky parts will be figuring out what the typeclass should look like, and potentially, maintaining performance.
12:48:46 <SamB> so you think I should use a typeclass?
12:49:04 <Cale> The idea is to create a monad transformer isn't it?
12:49:08 <SamB> yes
12:49:15 <Cale> Then yes :)
12:49:29 <xerox> MonadParsec ...
12:49:43 <SamB> but I hadn't decided whether I wanted to create a typeclass or just replace the basic type entirely
12:49:58 <Cale> Monad transformers are effective because their operations are in a typeclass.
12:50:04 <skew> are there any plans to make a Haskell based on qmlf?
12:50:29 <Cale> Also, you'll be able to strip out the user-state completely
12:50:40 <SamB> True!
12:51:02 <SamB> but that will be for sure an incompatible change :-(. fortunately it probably doesn't see a lot of use ;-)
12:52:25 * morans wants to get a day number as an int
12:52:33 <morans> eg number of days since 1970 or something
12:52:35 <morans> howto?
12:52:42 <Cale> Well, you'll be able to create a GenParser type which is entirely compatible by either State transforming Parsec, or Parsec transforming State, depending on exactly how user state interacts with parsing.
12:52:53 <sethk> morans, get the #seconds, and divide
12:53:02 <sethk> morans, the #seconds is available
12:53:04 <morans> how to get seconds?
12:53:14 <sethk> morans, I think System.Time, let me check
12:53:22 <Cale> yeah
12:53:25 <Cale> getClockTime
12:53:31 <sethk> right  
12:53:34 <Cale> returns a structure  TOD x y
12:53:35 * SamB wonders what his application should look like
12:53:49 <morans> OH
12:53:50 <morans> oh
12:53:54 <Cale> where x is the number of seconds since 00:00:00 (UTC) on 1 January 1970
12:53:55 <morans> yeah, I thought that was more abstract
12:53:58 <morans> yeah i see
12:54:05 <Cale> and y is an additional number of picoseconds
12:54:16 <Cale> It was abstract in the standard iirc.
12:54:19 <skew> this paper is the coolest thing I've read since the LCLS plans yesterday
12:54:30 <morans> cale: maybe thats why then
12:55:24 <sethk> skew, that sounds like a tepid endorsement
12:55:28 <skew> atomic resolution holograms of living cells beat out nice threading libraries :)
12:56:15 <SamB> Cale: so are you going to add yourself to ticket 4?
12:56:41 <skew> living till you blast them with an x-ray laser, anyway.
12:57:21 <SamB> skew: but can you reconstruct them from the holograms?
12:58:30 <skew> I'm not sure they are planning on doing whole cells, but it sounds like it
12:58:31 <newsham> what is the reason behind "let .. in" vs "let .."  (ie. no "in")?
12:58:41 <skew> I mean, you can extract the positional information
12:58:54 <Cale> newsham: the latter is only permitted as part of the do-notation
12:59:14 <skew> newsham: do always sort of implies "in the rest of the do block"
12:59:17 <Cale> do {let ...; stmts} = let ... in do {stmts}
12:59:22 <skew> like the <- bindings too
12:59:39 <Cale> SamB: okay :)
12:59:49 <newsham> cale: i understand when they are used.  I was wondering what the reasoning for having two similar but different syntaxes?
13:00:04 <newsham> (seems like everyting has a well thought out reason)
13:00:44 <Cale> well, it's awkward to break up your do-blocks with let all the time
13:00:55 <Cale> If that syntax wasn't there, you'd end up with lots more nesting
13:01:11 <sethk> absolutely
13:01:28 <sethk> or my solution:   abc <- return (what should have been a let expression)     which is ugly
13:01:33 <Cale> hmm
13:01:43 * Cale wonders if he even has an account on the SoC trac
13:01:50 <sethk> I imagine the compiler does the same thing with both forms
13:02:30 <Cale> sethk: yeah, that's also different in that it's monomorphically binding and won't allow for mutual recursion like let will.
13:02:41 <newsham> cale: but why not have "in" in the syntax in do blocks?
13:02:59 <Cale> newsham: you can use let ... in ... still
13:03:04 <palomer> @pl (\(a,b) -> not (a==b))
13:03:04 <lambdabot> uncurry (/=)
13:03:22 <Cale> (let ... in ...) is part of the top-level expression syntax
13:03:47 <Cale> "let ..." is only part of the do-block syntax
13:04:02 * tuxplorer says goognite to every1 and leaves
13:04:19 <SamB> Cale: you are sure it wouldn't be more efficient to just change the base parser type to be a monad transformer (keeping in mind that GHC's approach to type classes is not very amenable to optimization?)
13:04:21 <Cale> > do x <- [1..4]; let { y = x^2 } in return y
13:04:22 <lambdabot> [1,4,9,16]
13:04:39 <newsham> still.. my question is "why did they make a "let ..." for do-blocks but give it a slitely different syntax?  couldnt they ahve used the same syntax"?
13:04:43 <Cale> SamB: hm?
13:04:50 <SamB> I am thinking particularly of the many combinators
13:05:03 <Cale> SamB: The whole idea of monad transformers requires a typeclass.
13:05:31 <SamB> hmm.
13:05:38 <SamB> okay, then!
13:05:41 <Cale> Look at StateT
13:05:49 <sethk> newsham, you can use the same syntax also if you want to
13:05:51 <SamB> I know...
13:05:58 <Cale> It has MonadState with the operations that StateT conveys on the monad.
13:05:59 <SamB> I thought that was optional
13:06:04 <sethk> newsham, but you avoid having to do   let .... in  indent    let ... in  indent again ... etc
13:06:13 <SamB> so that you could use the same names for StateT and State
13:06:22 <sethk> newsham, but that makes no sense outside the do construct
13:07:07 <newsham> i see.  so the "in" syntax requires nesting while the do variant doesnt, and they have different syntaxes to differentiate the two cases.
13:07:20 <Cale> > do x <- [1..4]; let { y = x^2 } in return y
13:07:21 <lambdabot> [1,4,9,16]
13:07:31 <Cale> > do x <- [1..4]; let y = x^2; return y
13:07:31 <lambdabot>  parse error (possibly incorrect indentation)
13:07:37 <Cale> hehe
13:07:41 <Cale> > do x <- [1..4]; let {y = x^2}; return y
13:07:42 <newsham> thank you
13:07:42 <lambdabot> [1,4,9,16]
13:07:51 <sethk> newsham, yes; of course you can avoid indenting by using { } and ; but I think the motivation is to avoid indenting repeatedly
13:08:11 <Cale> (of course, compressed onto one line like that, you need the braces to avoid ambiguity)
13:08:44 <Cale> Without that, you'd end up having blocks like:
13:08:46 <sethk> right
13:08:50 <Cale> do x <- foo
13:09:00 <Cale>    let y = bar x
13:09:14 <Cale>    in do z <- quux y
13:09:35 <Cale>          return ...
13:09:48 <Cale> and if you need multiple lets, it gets worse
13:10:13 <sethk> you can also have more than one x = y clause in the let part:
13:10:17 <mahogny> let... always feels so old-school basic. maybe just me
13:10:18 <sethk> do x <- foo
13:10:19 <Cale> right
13:10:21 <sethk>     let x = 1
13:10:23 <sethk>         y = 2
13:10:24 <SamB> hmm, what is a good webpage about monad transformers?
13:10:27 <sethk>        whatever ...
13:10:44 <xerox> SamB: all about monads covers most of them
13:10:54 <Cale> SamB: well, there's the All About Monads tutorial, but the examples there are slightly rutal
13:10:58 <Cale> b*
13:11:02 <mahogny> SamB, I have seen pages but the "motivating" examples leave a lot to wish for :P
13:11:05 <palomer> http://www.rafb.net/paste/results/e3mArp75.html <---anyone have any idea where the error is here?
13:11:14 <SamB> who reads SoC apps again?
13:11:23 <Cale> You should look at my example monad transformers on the wiki
13:12:22 <lispy> SamB: i think google screens them and then sends them to mentors
13:12:43 <SamB> so I don't need to give urls for Parsec or monad transformers?
13:13:18 <lispy> i'm not sure, but i would think you'd need to because the google employees that do the screening might not know which mentor to send it to
13:13:23 <Cale> SamB: http://www.haskell.org/hawiki/MonadUnique is almost certainly the simplest of them
13:13:45 <Cale> http://www.haskell.org/hawiki/MonadSupply generalises that
13:13:53 <mahogny> xerox, ok. seems I'll handle the darcs GUI unless someone else feels like taking it on
13:14:04 <Cale> http://www.haskell.org/hawiki/MonadRandom -- a monad transformer for working with a random number generator
13:14:27 <xerox> mahogny: add yourself, I think dcoutts liked it too, but he wasn't his main concern
13:14:34 <Cale> http://www.haskell.org/hawiki/MonadUndo -- a generalised state monad which is able to undo and redo changes.
13:14:54 <SamB> @docs Control.Monad.State
13:14:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
13:14:56 <mahogny> xerox, too lazy. I let araujo do it for me ;)
13:14:57 <lispy> mahogny: did you know there are at least two efforts already for a darcs gui?  both external and internal to darcs?  you should read up on them.  I think it would help you make a stronger case
13:15:09 <mahogny> lispy, ok. thanks
13:15:18 <Cale> SamB: I suggest you read them in about that order
13:15:25 * araujo handles mahogny some tea
13:15:28 <RyanT5000_> what is wrong with this statement?
13:15:29 <RyanT5000_> let textureSize@(OpenGL.TextureSize2D textureWidth textureHeight) = (OpenGL.TextureSize2D 16 16) in
13:15:30 * xerox starts with the Gtk2Hs, Gtk2Hs, Gtk2Hs mantra
13:15:33 <mahogny> araujo, lol
13:15:40 <RyanT5000_> it says "parse error in pattern"
13:15:41 * palomer has used monadsupply
13:15:47 <mahogny> xerox, what's wrong with wxhaskell? ;)
13:16:14 <araujo> lispy, none with gtk2hs afaik
13:16:16 <palomer> ok, I have a type foo which instantiates class bar, how do I make all pairs and lists involving foo also instantiate class bar?
13:16:48 <SamB> what is the real name of the mtl package?
13:17:14 <lispy> araujo: i don't care what they are written with as long as i can install them :)
13:17:45 <mahogny> lispy got a point lol
13:17:57 <araujo> lispy, And can you?, afaik the current wxhaskell gui is incomplete.
13:18:11 <araujo> And nobody seems working on it.
13:18:19 <mahogny> hmm. I don't think much is lacking. at least nothing I have run into yet
13:18:29 <RyanT5000_> can you not have an @ pattern in a let statement?
13:18:35 <mahogny> but some calls are slow. I dunno if gtk2hs is faster
13:18:36 <lispy> araujo: i've never gotten darcs gui or gtkhs to work on my system
13:18:39 <araujo> lispy, Plus that kind of arguments aren't so common here in #haskell ;-)
13:19:23 <lispy> araujo: the wxdarcs code was recently patched so that i should be functional again, but i've not tried it
13:19:33 <RyanT5000> what's an @ pattern called?
13:19:37 <RyanT5000> (as in, so i can google it)
13:19:39 <xerox> Synonym?
13:19:48 <araujo> RyanT5000, pseudonym
13:19:53 <xerox> mahogny: Gtk2Hs has Cairo!
13:20:01 <RyanT5000> araujo: thanks
13:20:06 <xerox> mahogny: and there is that meld widget which looks WAY cool.
13:20:09 <araujo> welcome RyanT5000 
13:20:09 <RyanT5000> also, are they not allowed in let statements or something?
13:20:15 <RyanT5000> hi :)
13:20:16 <SamB> Cale: so where should I link to about monad transformers?
13:20:24 <xerox> mahogny: every tried it?
13:20:29 <mahogny> xerox, lol. and you writing the cairo bindings leaves no bias? ;)
13:20:30 <xerox> mahogny: meld.sf.net
13:20:45 <Cale> SamB: you need a link? I suppose All About Monads would do it
13:20:47 <mahogny> xerox, no. only used wxwidgets for haskell. I used gtk when I coded C
13:20:57 <Cale> or to the mtl documentation
13:21:02 <xerox> mahogny: it's a program per-se
13:21:14 <ihope_> > let x -! f = f x; f !- y = f y in 10 -! div !- 2
13:21:16 <lambdabot> 5
13:21:19 <SamB> mtl documentation may be a better idea
13:21:23 <ihope_> > let x -! f = f x; f !- y = f y in (-! div !-) 10 2
13:21:24 <lambdabot>  parse error on input `)'
13:21:33 <ihope_> Why is that a parse error and not a fixity error?
13:21:47 <RyanT5000> araujo: is there a restriction on using @ in let statements?
13:21:49 <SamB> maybe the Control.Monad.State documentation?
13:22:02 <mahogny> xerox, hm. meld suddenly makes diff useful. nice
13:22:07 <lispy> ihope_: i think you need parens around the operators
13:22:28 <xerox> mahogny: indeed, try it out and you'll understand why I call its widget "WAY cool!" :-)
13:22:29 <ihope_> lispy: I wanted to make a section out of this.
13:22:38 <lispy> ihope_: section?
13:22:44 <Igloo> Only left and right sections exist, not both
13:22:44 <SamB> Cale: hmm?
13:22:47 <ihope_> Like (+ 3) and such.
13:23:09 <mahogny> xerox, omg not animations? :o
13:23:10 <ihope_> Igloo: what about (+)? :-)
13:23:22 <Igloo> That's not a section
13:23:27 <araujo> > let f c@(x:y:xs) = (x + x + y, xs,c) in f [1 .. 5]-- RyanT5000 if this what you mean
13:23:28 <lambdabot> (4,[3,4,5],[1,2,3,4,5])
13:23:29 <SamB> Cale: or should I just link to the toc for mtl?
13:23:30 <Igloo> And it only has an operator inside, not an expression
13:23:41 <jlhamilton> what's a good way to create raster images in png format?
13:23:52 <mahogny> bbl
13:23:56 <SamB> wait, it doesn't even have a toc
13:24:11 <RyanT5000> araujo yeah, that's what i'm talking about; i'm not sure what's going on exactly yet though
13:24:20 <RyanT5000> i hate the "parse error" error
13:24:28 <RyanT5000> gives you no information
13:25:50 <sethk> RyanT5000, sometimes I split things onto more than one line, and use the line number to narrow things down
13:26:02 <sethk> RyanT5000, doesn't always work, and I'm not sure about that situation, but it's worth a try
13:26:14 <RyanT5000> sethk: thanks, i'll try it
13:27:14 <RyanT5000> ...
13:27:17 <RyanT5000> i just cut and paste it into ghci
13:27:20 <RyanT5000> now it works
13:27:28 <RyanT5000> indentation issue?
13:27:35 <araujo> probably
13:27:59 <RyanT5000> also, i'm using import qualified as
13:28:07 <RyanT5000> those are the only differences
13:30:04 <sethk> if it was all on one line before, it can't be indentation
13:30:18 <RyanT5000> yeah
13:30:24 <RyanT5000> i'm totally confused
13:30:26 <RyanT5000> here's the line
13:30:32 <RyanT5000>      let textureSize@(Graphics.Rendering.OpenGL.TextureSize2D textureWidth textureHeight) = Graphics.Rendering.OpenGL.TextureSize2D 16 16 in 
13:30:35 <ihope_> > let x = let in 3 where in x
13:30:36 <lambdabot> 3
13:30:43 <RyanT5000> >      let textureSize@(Graphics.Rendering.OpenGL.TextureSize2D textureWidth textureHeight) = Graphics.Rendering.OpenGL.TextureSize2D 16 16 in 
13:30:43 <RyanT5000> textureSize
13:30:44 <lambdabot>  parse error on input `}'
13:31:07 <ihope_> You got it in two lines there.
13:31:25 <RyanT5000> true
13:31:30 <sethk> RyanT5000, try putting in on a line by itself
13:31:38 <RyanT5000> accidentally copy-and-pasted the linefeed
13:31:47 <RyanT5000> > let textureSize@(Graphics.Rendering.OpenGL.TextureSize2D textureWidth textureHeight) = Graphics.Rendering.OpenGL.TextureSize2D 16 16 in textureSize
13:31:48 <lambdabot>   Not in scope: data constructor `Graphics.Rendering.OpenGL.TextureSize2D'
13:31:54 <RyanT5000> gah ok fine lambdabot
13:33:19 <RyanT5000> ok it's not a problem with that code
13:33:44 <RyanT5000> replaced with "let x = 10 in" and got the same error
13:34:03 <sethk> RyanT5000, "in" on a separate line?  what happens?
13:34:24 <sethk> certainly let x = 10 is ok
13:34:37 <RyanT5000> figured it out :)
13:34:42 <RyanT5000> i had a <- on the next line
13:34:47 <RyanT5000> i forgot the "do" following "in"
13:35:06 <RyanT5000> although isn't that a bug in ghc to flag the let line?
13:35:10 <sethk> and you got the error message on that line?  that can happen, yes
13:35:26 <sethk> I wouldn't exactly refer to it as a bug
13:35:48 <sethk> probably there is an interpretation which makes the <- correct if there is a change on the flagged line
13:36:26 <RyanT5000> hm that's true
13:36:31 <RyanT5000> that's why i hate parsing :P
13:37:38 * SamB tries to describe why he wants to do ParsecT
13:37:56 <SamB> Cale: what kind of thing do you think I should say about why I want to do it?
13:40:32 <SamB> xerox: maybe you can help?
13:40:51 <xerox> SamB: that's up to you :-)
13:41:16 <xerox> Last year they chosed the 10~15 lines long divided in sublists proposal instead of the n-pages long one, for me :-)
13:41:39 <SamB> do you think I need to talk seperately about why I want to do it and why I think I am best?
13:42:05 <xerox> Sure, it's important to say that, imo.
13:42:32 <SamB> Well, I would like to say that the reason I want to do it is:
13:43:11 <SamB> That I want it done, that nobody else seems to want to do it, and that I think I can do it.
13:44:18 <SamB> Then, the reasons that I'm the best person might look like:
13:44:36 <SamB> Nobody else wants to do it.
13:45:20 <jip> well, i found out where the array out of bounds is happening
13:45:21 <xerox> They're not asking for proofs I think :-P
13:45:24 <jip> quite unexpected
13:45:36 <SamB> hehe. 
13:45:41 <cmarcelo> SamB: maybe giving some examples of how ParsecT could help you and others, i.e., explain why do you want it done..
13:45:58 <SamB> cmarcelo: the trouble is that I don't remember what I wanted to use it for!
13:48:16 <cmarcelo> SamB: if google people will filter the projects before sending them to Haskell.org People, then they may not know a lot about monad transformation and they wont realise what one could do with ParsecT and your proposal maybe filtered out.. =|
13:48:35 <mux> it's the mentoring organization that filters the projects
13:48:43 <SamB> mux: oh?
13:48:46 <mux> and then the mentoring organization sends the list of selected projects to google
13:48:53 <mux> yeah, I was a mentor for a FreeBSD project last year
13:48:56 <mux> and it worked like this
13:49:22 <xerox> Hey cmarcelo!  I see you've recently added yourself on the trac.  Nice to meet you.
13:49:39 <mux> google will give you guys an access to some CGI app to rate the applications
13:50:46 <xerox> mux: ah, thanks for the informations.
13:50:59 <mux> welcome
13:51:29 <cmarcelo> mux: hmm.. thanks. =) i thought that google filtered out the proposals first..
13:51:29 <mux> now, someone please explain how ParsecT could help :-)
13:51:57 <reppie> cmarcelo Yes, they do a first screening to remove trivial entries
13:52:03 <reppie> But it's very minimal
13:52:08 * xerox was about to say that too
13:52:24 <xerox> mux: the proposals go to the admins or the mentors directly?
13:52:32 <reppie> xerox To both.
13:52:34 <cmarcelo> xerox: yep! =) i'm thinking about doing the xmpp (jabber) bindings.. are you going to be a mentor this time?
13:52:38 <mux> yeah, to both
13:52:39 <SamB> hmm, which details of my experience should I mention...
13:52:39 <reppie> They remove stuff like proposals with only a few words.
13:52:44 <xerox> cmarcelo: I don't think so.
13:52:59 <mux> it all went very smoothly last year
13:53:05 <mux> reppie: are you mentoring a project this year ?
13:53:09 <xerox> mux: in brief, when you're doing parsing, you usually want to do *something else* too.
13:53:25 <palomer>  @pl \x -> x >> return ()
13:53:26 <reppie> mux I'd like to, yes.
13:53:29 <palomer> @pl \x -> x >> return ()
13:53:30 <lambdabot> (>> return)
13:53:37 <reppie> mux http://people.freebsd.org/~ssouhlal/testing/soc-20060429.diff
13:53:44 <xerox> mux: the most immediate type is ParsecT IO ...
13:55:27 <mux> reppie: I especially like the first one
13:55:42 <reppie> mux Yeah.
13:55:44 <cmarcelo> xerox: but if this something else also has a monad trans I could use the other way (ex.: MonadT Parsec) right? what would be the difference?
13:55:53 <reppie> mux I'm afraid the last one is a bit too easy.
13:56:06 <SamB> anyway, if Google doesn't really care what it says, as long as it seems to say something relevant, I don't need to be too particular about that part, do I?
13:56:14 <sjanssen> cmarcelo: certain monads can't be transformers (IO for example)
13:56:21 <xerox> Right.
13:56:29 <mux> xerox: I don't get it entirely, can't you already do some stuff in the IO Monad while using Parsec?
13:56:37 <xerox> mux: nope.
13:56:52 <reppie> mux You always need a monad combinator to mix monads
13:56:55 <SamB> mux: not without feeling dirty inside, now
13:56:56 <xerox> mux: well, it depends on what you mean by "while using."
13:57:05 <mux> so if I try, say a putStrLn in a do construct of Parsec, it'll fail?
13:57:13 <xerox> mux: yup.
13:57:18 <mux> ok
13:57:24 <SamB> it won't fail... it won't even compile!
13:57:29 <reppie> Unless you cheat!
13:57:33 <mux> yeah, that's what I meant
13:57:40 <xerox> SamB: *that's* what we mean by failing! :-)
13:58:04 <SamB> xerox: sorry, sorry, just teasing
13:58:19 * mux will give this a look more closely
13:58:55 <xerox> You can interleave parsing in an IO computation, but you can't interleave anything else than parsing during the parsing computation.
13:59:11 <xerox> (Unless you cheat.)
13:59:13 * mux nods
13:59:29 <akemp> @seen dons
13:59:30 <lambdabot> dons is in #haskell-overflow and #haskell. I don't know when dons last spoke.
13:59:32 <cmarcelo> what do you guys mean by cheating? unsafePerform... ?
13:59:39 <mux> reppie: not sure if the last one is too hard, I didn't found the average applicant to be particularly skilled
13:59:42 <xerox> Yep. unsafe* functions in general.
14:00:28 <reppie> mux *shrug*
14:00:58 <mux> in any case, it would be good to at least have the gettimeofday() optimization
14:01:07 <jip> about unsafeFreeze, can anyone please give me an example of unsafe usage?
14:01:12 <mux> so that we can stop being abused by Linux-centric applications
14:01:37 <reppie> mux Yes, but I'm not convinced we can get someone who is good enough to do it :P
14:01:42 <xerox> Haskell code is usually quite straightforwardly cross-platform.
14:01:43 <mux> heh
14:01:48 <sjanssen> jip: anytime you modify the array after you've frozen it
14:02:07 <nnunley> What's haskell-overflow for?  Avoidance of the perl6 hordes?
14:02:20 <SamB> xerox: or straightforwardly platform-dependant
14:02:28 <xerox> nnunley: no, it's for discussions that overlaps leading to miscomprehension or difficulties.
14:02:48 <xerox> SamB: cpp to the rescue!
14:02:55 * xerox hides
14:03:59 <nnunley> xerox: Gotcha.
14:04:04 <nnunley> xerox: Thanks.
14:04:06 <jip> sjanssen: so if i haver an f :: IO UArray, that that creates an IOUArray, does shit with it and then finally unsafeFreezes it and returns it, this should be safe?
14:04:07 <xerox> np
14:05:56 <sjanssen> jip: yes.  the best thing to do is just throw away the reference to the IOUArray, that way nothing bad can happen
14:07:34 <jip> sjanssen: seems logical enough... what about thaw?
14:08:16 <sjanssen> unsafeThaw is more unsafe than freeze, it's a little harder to reason about
14:08:45 <sjanssen> you have to be sure that any computations working with the pure Array have to be finished before you thaw it and write to it
14:09:06 <jip> sjanssen: it doesn't seem like it's possible to ever be sure
14:10:06 <sjanssen> if you know exactly how the pure code works, and evaluate it strictly (with seq or some such), then it can be okay
14:12:15 <jip> so seq must be used?
14:13:22 <dcoutts> mahogny, are you a darcs expert?
14:13:27 <sjanssen> jip: something that makes sure there is no more pure code reading the array.  Also, seq isn't always enough
14:14:05 <mahogny> dcoutts, not at all. I'll have to do my homework the coming days unless someone more suited as a mentor is willing to have a go
14:14:18 <sjanssen> for example, a function returning a list would need to seq each cell of the list
14:14:39 <dcoutts> mahogny, I was happy to do it but I think we need a darcs expert really, I can certainly advise on gui stuff
14:14:47 <mahogny> dcoutts, same here
14:14:59 <dcoutts> mahogny, you're a wx person?
14:15:24 <sjanssen> jip: basically, avoid unsafeThaw like the plague
14:15:26 <mahogny> dcoutts, wx, but it seems gtk might be the choice here so that is on my ToLearn
14:15:59 <jip> sjanssen: hm... ok thanks :D i wonder how one avoids the plague...
14:16:20 <dcoutts> mahogny, I think once we've got the new tree list api, that gtk is the obvious choice
14:16:32 <dcoutts> a darcs gui is going to nees lots of lists & trees
14:16:56 <mahogny> dcoutts, indeed. either that or one steals some code from Meld and do some FFI
14:16:58 <jip> you guys *still* haven't finished that api yet? :P
14:17:14 <dcoutts> mahogny, meld is in python
14:17:29 <mahogny> ouch. major FFI:ing in that case
14:17:31 <dcoutts> mahogny, and that's only part of the solution, there's more to it than a diff/merge thing
14:17:38 <mahogny> yes
14:17:38 <dcoutts> I think a port is better
14:17:45 <mahogny> probably
14:17:48 <dcoutts> and it'd want to be using the darcs match system
14:17:55 <dcoutts> rather than python's difflib
14:18:02 <dcoutts> match/patch
14:18:08 <mahogny> well, the more native it is, the better
14:18:28 <dcoutts> and in particular it'd match exactly what darcs does with patches/diffs
14:18:50 <mahogny> even better
14:19:03 <sjanssen> jip: still wrestling with whether to use mutable state in your GB emulator?
14:19:27 <jip> sjanssen: i pretty much decided that i must use mutable state for performance
14:19:38 <jip> sjanssen: would you like to hear my planned strategy?
14:19:50 <sjanssen> jip: sure
14:21:00 <jip> sjanssen: the idea was to use STRefs and STUArrays for all of the state. problem is there doesn't seem to be a way to run an ST thread, pause it to grab the state from the IO monad in order to do IO, and then continue the ST thread
14:21:27 <jip> sjanssen: so i am going to need to use IORefs and IOArrays for all of the state so that i can directly access it from IO
14:21:37 <mahogny> well. why the need for ST?
14:21:38 <sjanssen> jip: not necessarily
14:22:03 <jip> sjanssen: problem is i don't want all of my code in IO monad, so i will make my own MYRef and MYArray that will generalize STRef and IORef
14:22:15 <sjanssen> @hoogle stToIO
14:22:16 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
14:22:32 <sjanssen> jip: this will help you solve your problem
14:22:41 <jip> sjanssen: yeah stToIO seems to be problematic though. i forgot what the exact problem is :O
14:22:51 <SamB> @hoogle unsafeStToIO
14:22:52 <lambdabot> No matches found
14:22:53 <jip> mahogny: i need mutable state for speed
14:22:55 <SamB> @hoogle unsafe
14:22:56 <lambdabot> Language.Haskell.TH.unsafe :: Safety
14:22:56 <lambdabot> System.IO.Unsafe :: module
14:22:56 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
14:23:07 <SamB> @hoogle unsafeI
14:23:08 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
14:23:08 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
14:23:08 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
14:23:19 <SamB> oh...
14:23:24 <sjanssen> any ST action may be promoted to an IO action, because GHC defines something like: data IO a = IO (ST RealWorld a)
14:23:45 <SamB> what do you suppose they mean by "An explanation of your development methodology"
14:24:10 <jip> sjanssen: yeah but i think that i discovered that it's impossible to read an STRef from IO monad
14:24:36 <SamB> xerox, Cale: ?
14:24:39 <musasabi> @index unsafeSTToIO
14:24:40 <skew> jip: you can read the var in a trivial transaction
14:24:40 <lambdabot> bzzt
14:24:55 <skew> jip: oh, nm, I was thinking of STM
14:25:16 <sjanssen> jip: "stToIO (readRef myref)" ?
14:25:26 <sjanssen> make that readSTRef
14:25:30 <musasabi> it is unsafe, but can be done.
14:25:37 <musasabi> with GHC.
14:25:38 <SamB> of course, you can't get the STRef out of the ST
14:26:01 <sjanssen> jip: the trick is, never use runST, always use stToIO
14:26:18 <SamB> sjanssen: so what was the point of using ST?
14:26:34 <skew> you can use usafeIOToST if you really think it's a good idea to do IO in the middle of ST
14:26:54 <skew> but the point of ST is to ensure that some code using state internally is referentially transparent after all
14:27:18 <sjanssen> SamB: all of his non-IO code can be written with "ST s a", so jip can be sure that actual IO doesn't happen in those computations
14:27:44 <SamB> So, they say that it is a good idea to talk about your development methodology in your SoC application
14:27:48 <jip> skew: if only there was a way to keep this referential transparency, but allow some method to inject input and extract output, during the execution of the state thread
14:27:51 <SamB> what do you suppose they mean?
14:27:57 <jip> skew: by doing the injection and extraction in a purely functional way
14:28:15 <sjanssen> jip: can we get a concrete example?
14:29:07 <jip> well, let's say i have "updateSimulation :: Input -> State -> State"
14:29:31 <jip> i basicly need to call updateSimulation each step with the current input, and then output the current state
14:29:49 <jip> i want to use a bunch of STRefs and STArrays for the state for performance reasons
14:30:05 <jip> since copying it around through the updateSimulation function is too slow
14:30:23 <skew> why no updateSimulation -> Input -> State -> IO ()?
14:30:29 <skew> it sounds like you want mutable state
14:30:42 <jip> skew: yep, but then all of my code is impure :'(
14:30:49 <SamB> nobody has any clue what they mean by "development methodology"?
14:31:00 <skew> if you use mutable stat it's impure anyway
14:31:01 <sjanssen> skew: IO is *more* than mutable state, it's reading and writing to files, etc.
14:31:21 <skew> well, you could use ST as your monad
14:31:29 <monochrom> Nobody has any clue what they mean by "development methodology". :)
14:31:33 <jip> skew: right i would like to use ST. you agree that ST is pure, right?
14:31:33 <skew> or, maybe immutable arrays work for you
14:31:41 <jip> skew: nope, those are too slow
14:31:54 <sjanssen> SamB: I was confused by the "development methodology" part also
14:32:15 <jip> anyway, i think my idea of being able to switch between IO and ST will work
14:32:17 <sjanssen> jip: this can be done with ST + IO
14:32:19 <skew> jip: running a whole thing with runST gives a pure computation
14:33:16 <sjanssen> jip: are there any cases where updateSimulation needs to make an IO request?
14:33:26 <jip> yeah, actually just implementing updateSimulation internally with a "top level" runST and keeping it's type as it is might be fast enough. the state would still have to be copied once every update, but not thousands of times during the update
14:33:59 <sjanssen> jip: using stToIO means zero copies, that sounds like a better option to me
14:33:59 <SamB> jip: what does this state consist of?
14:33:59 <jip> sjanssen: no. IO requests happen between each call to updateSimulation, to gather the input for the next update(keyboard presses) and to display the output of the previous update
14:34:09 <skew> sjanssen: you could type the state-only parts in ST and use stToIO so you can pass vars along, that sounds good
14:34:22 <jip> sjanssen: i'll look deeper at stToIO, maybe it can help me after all
14:34:39 <skew> jip: a function with pure type that mutates a variable is just a bad idea
14:34:52 <jip> SamB: state is basicly internal state of a simple computer. an array of memory, a bunch of cpu registers, and some state of hardware devices
14:34:55 <skew> like, what happens if you saved a reference to the state before you passed it in and use that somewhere else
14:35:20 <sjanssen> skew: I don't think anyone is advocating mutation in pure code.  did I miss something?
14:35:31 <SamB> jip: you've looked at DiffUArray already then...?
14:36:20 <jip> SamB: i have, it didn't seem to help me, hm.... i'm actually gonna try that again now
14:36:21 <skew> sjanssen: jib was talking about Input -> State -> State for something that mutated STRefs in the State
14:36:48 <sjanssen> skew: that was jip's old code that didn't use mutable state
14:36:56 <skew> ok
14:37:17 <jip> right
14:43:10 <RyanT5000> how do you write a lambda expression with multiple pattern matches?
14:43:30 <dcoutts> \(Foo a) (Bar b) -> ...
14:43:37 <sjanssen> RyanT5000: no syntax for that directly, you have to use case
14:43:47 <RyanT5000> sjanssen: thanks
14:43:57 <dcoutts> ah, that kind of multiple patterm matches
14:44:03 <RyanT5000> yeah
14:44:07 <dcoutts> yep, case
14:45:57 <RyanT5000> is there any way to do the equivalent of let ... in do
14:46:00 <RyanT5000> without indenting further?
14:46:04 <RyanT5000> (i don't count using {})
14:46:24 <SimonRC> actually, Shakell has synatx for multiple-pattern-match anonymous functions
14:46:33 <SamB> do let ...
14:46:55 <SimonRC> but the monad let is not the same as the let in an expression
14:47:13 <SamB> SimonRC: in what ways does it differ?
14:47:22 <SimonRC> it's more like the assignments you make at the interactive prompt
14:47:41 <SimonRC> monadic let has no "in" for a start
14:47:49 <SimonRC> indentations is different
14:47:52 <SamB> thats because it is *sugar*!
14:48:06 <SamB> and avoiding indentation is what RyanT5000 wants!
14:48:36 <drakioned> ahh. SimonRC is back.
14:48:42 <SimonRC> yeah
14:48:55 <sjanssen> SimonRC: what is the syntax for multiple pattern match anonymous functions?
14:49:12 <SimonRC> sjanssen: in shakell?
14:49:17 <drakioned> did you say something to me earlier about terminals whilst I was away?
14:49:24 <SimonRC> drakioned: er, yeha...
14:49:36 <sjanssen> SimonRC: ah, I though Shakell was a typo.  what is Shakell?
14:49:36 <SimonRC> screen has one deficiency...
14:49:36 <drakioned> ok.
14:50:05 <SimonRC> drakioned: it emulates a vt100, not an xterm, so it doesn;t support mouse commands
14:50:58 <drakioned> ahh, I think screen's one of those random programs I've never used.
14:51:00 <SimonRC> sjanssen: a sorta cross between Unlambda and SADOL, with the typing of LISP and the laziness of Haskell.
14:51:07 <SimonRC> drakioned: what!
14:51:29 <drakioned> er.. I just never used it..
14:51:32 <SimonRC> You run a unix and you don't use screen?!
14:51:44 <SimonRC> I recommend doing so.
14:51:54 <drakioned> I'm hardly ever on unix..
14:52:19 <SamB> I don't use screen either, though I'm probably going to regret mentioning it...
14:52:21 <SimonRC> Do you ever log into a unix box remotely?
14:52:35 <drakioned> yes.
14:52:59 <SimonRC> do you ever use more than one program at once on said box?
14:53:08 <drakioned> yes.
14:53:16 <SimonRC> well, you need screen, then
14:53:22 <SimonRC> it's like having multiple terminals
14:53:39 <drakioned> er.. I generally just open another terminal session.
14:53:44 <SimonRC> also, you can disconnect and reconnect without the tasks konwing
14:53:58 <SimonRC> drakioned: oh, wait, did you mean via X?
14:54:03 <drakioned> yes.
14:54:07 <SimonRC> ah, ok
14:54:11 <SamB> Xscreen would be cool
14:54:14 <gzl> screen is so good.
14:54:29 <SimonRC> but do you ever want to have a task not die when you log off?
14:54:37 <SimonRC> SamB: see ratpoison
14:54:45 <drakioned> haven't so far..
14:54:47 <skew> or ion
14:54:47 <SamB> but I think you have to use vnc instead
14:55:02 <skew> unless you're saying ratpoison does some screen-type stuff
14:55:16 <SimonRC> SamB: along with some kinda special X server if you want to disconnect
14:55:20 <SamB> SimonRC: I was thinking in terms of the other functionality rather than the WM-nature
14:55:26 <drakioned> I only usually log in a unix box to use happy or to check my mail
14:55:30 <SimonRC> skew: all except the disconnecting bit
14:55:36 <SimonRC> drakioned: ah, ok
14:56:02 <SimonRC> SamB: intimidation of newbies?  :-D
14:56:16 <SamB> SimonRC: no, the detachability
14:56:48 <SimonRC> SamB: yeah, I know
14:57:05 <SimonRC> SamB: technical reasons make this difficult
14:57:11 <SamB> so, what in the world is a development methodology?
14:57:32 <cmarcelo> SamB: where is this mentioned?
14:57:38 <SimonRC> things like waterfall or XP, I assume
14:57:52 <SamB> http://code.google.com/soc/studentfaq.html#24
14:58:17 <RyanT5000> @where shootout
14:58:17 <lambdabot> I know nothing about shootout.
14:58:38 <SamB> @google shootout
14:58:40 <lambdabot> http://www.miniclip.com/bushshootout.htm
14:58:51 <SamB> @google shootout site:debian.org
14:58:53 <lambdabot> http://shootout.alioth.debian.org/
15:03:24 <SamB> cmarcelo: any idea?
15:07:49 <cmarcelo> SamB: not exactly =P.. maybe describing how would you code, like: will write first the tests and then code for making them pass (TDD), or will make a lot of use cases, sort them by priority and try to make them work... 
15:07:51 * SamB checks his SoC app so far into RCS
15:08:01 <SamB> cmarcelo: hmm.
15:08:17 <SamB> does Parsec have tests?
15:09:20 <sjanssen> it'd be neat if there was a big repository of last year's accepted applications
15:09:34 <cmarcelo> are you guys doing the proposals/applications in ascii-text or something else?
15:09:52 <SamB> cmarcelo: presumably not in EBCDIC
15:09:58 <sjanssen> cmarcelo: I think that is the only accepted format
15:10:20 <SamB> you were expecting ZSCII?
15:13:39 <cmarcelo> hmm.. looks like it is text-only. I said ascii-text meaning text/plain, instead of sending a PDF or something like.. =)
15:13:55 <palomer>  /me is using (map fst) everywhere in his code
15:14:52 <sjanssen> palomer: map snd is better!
15:15:18 <SamB> of course they want plaintext!
15:16:15 <sjanssen> @quote
15:16:16 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
15:16:53 <jip> well, it's official! DiffUArray is a lot slower then UArray
15:17:18 <SamB> jip: in what respect?
15:18:37 <jip> switched my UArray with DiffUArray and i get 1/5th the speed
15:20:17 <SamB> hmm
15:20:21 <xerox> palomer: use Arrows
15:20:23 <SamB> maybe you are leaving closures about
15:20:40 <SamB> that refer to old versions of the array
15:20:57 <jip> nope, i've checked. i am sure that i am not
15:21:34 <isaacd> Diff*Array uses MVars (which are slow), IIRC, such that only a really large array will benefit
15:21:54 <isaacd> from using the Diff*Array
15:23:30 <SamB> how big is really large?
15:23:46 <SamB> also, why are MVars slow?
15:23:59 <jip> isaacd: i am using 2 arrays, one is 64KB the other is 23kb
15:24:21 * SamB wonders how big his arrays are in his zmachine interpreter
15:24:57 * SamB is pretty sure the mutable array is less than 64KB
15:25:33 <SamB> considering it is addressed with 16-bit words...
15:26:13 <jip> 16-bit address means 64KB :)
15:26:47 <SamB> well, it may be smaller
15:26:49 <SamB> depends on the file
15:27:00 <SamB> in fact, probably won't ever be quite that big
15:27:01 <jip> i suppose
15:27:10 <SamB> its in the spec
15:27:43 <SamB> and I suppose keeping several different versions isn't too big a deal...
15:28:00 <SamB> still, it is sad that MVars are more expensive than 64KB copies!
15:28:18 <SamB> SoC project, anyone?
15:28:18 <isaacd> SamB: MVars are slow because they have to use synchronization/locking
15:28:35 <isaacd> SamB: I don't think they're slower than 64KB copies though...
15:28:41 <isaacd> hmm
15:29:44 <jip> i'm actually using a 32KB array, not 64KB
15:29:58 <SimonRC> SamB: *whoosh* did-you-say-z-machine?
15:29:59 <SamB> oh
15:30:06 <SamB> SimonRC: I did indeed!
15:30:10 <SamB> @where ZMachine
15:30:11 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
15:30:20 <SimonRC> z machine arrays can be up to 2^16 element long
15:30:31 <SimonRC> i.e. 2^17 bytes.
15:30:54 <SimonRC> memory can be up to 512k IIRC for version 8 machines
15:31:10 <SamB> SimonRC: but the mutable region has to be 16-bit addressable!
15:31:11 <SimonRC> plus stack and screen and some misc stuff
15:31:33 <SamB> and stack and screen aren't in Z-machine memory at all, of course
15:31:58 <SimonRC> are we talking about an array to hold the memory or an array inside the machine?
15:32:17 <SamB> an array to hold the mutable region of memory
15:32:39 <SimonRC> ok, it's 16-bit, yes
15:33:11 <SamB> I figure a constant UArray is good enough for constant data ;-)
15:33:29 <SimonRC> what happens if you do "65535-->32767=42" isn't specified, though
15:34:00 <SimonRC> i.e. you could use an array de-ref to get a fair way beyond 64k
15:34:21 <SamB> well, I don't worry about what that does myself.
15:34:29 <SimonRC> I *think* writing outside of that isn't allowed, though
15:34:31 <SamB> I honestly don't know if that would wrap or not
15:35:27 * SimonRC thinks the best way is either (a) read ok, write bad, or (b) emulate original 'terp bugs
15:35:56 <SamB> original bugs being what?
15:37:32 <ihope> So just how do I access the Windows API with FFI and all that?
15:37:49 <SamB> same as others, only without the nice type names
15:39:08 <palomer> xerox: how does Arrows help?
15:39:36 <xerox> palomer: with the Arrow (->) instance.
15:39:51 <xerox> (f &&& g) x = (f x,g x)
15:39:59 <xerox> (f *** g) (x,y) = (f x,g y)
15:39:59 <palomer> how would it stop me from writing map snd everywhere?
15:40:06 <xerox> first f (x,y) = (f x,y)
15:40:13 <xerox> second f (x,y) = (x,f y)
15:40:19 <xerox> (>>>) = flip (.)
15:40:48 <palomer> but, like, I actually need what's returned by map fst
15:40:53 <palomer> see, I'm dealing with maps
15:40:57 <palomer> (which are [(a,b)]
15:41:04 <palomer> and I constantly need to extract the domain and image
15:41:11 <xerox> You can do your computation in parallel, for example.
15:41:53 <xerox> map (f *** g) will apply f to the elements of the domain and g to those of the image.
15:43:28 <palomer> hrm, that could be useful
15:44:13 <palomer> @hoogle Arrows
15:44:14 <lambdabot> Distribution.Extension.Arrows :: Extension
15:44:15 <xerox> first and second operates on them distinctly, leaving the other set unchanged.
15:44:26 <palomer> hoogle doesn't seem to know about Arrows
15:44:34 <xerox> What should it know?
15:44:44 <sjanssen> @hoogle (>>>)
15:44:45 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
15:45:09 <xerox> Also GHC lets you use a cuter syntax for Arrow types.
15:45:44 <xerox> (>>>) :: (Arrow (~>)) => (a ~> b) -> (b ~> c) -> (a ~> c) -- which looks nice with the right font.
15:48:16 <palomer> oh crap, I'm already using the ~> operator
15:48:34 <xerox> Goodnight.
15:48:41 <palomer> night
15:49:00 <xerox> @where Arrows
15:49:01 <lambdabot> http://www.haskell.org/arrows/
15:49:10 <sjanssen> palomer: I believe you can replace ~> in xerox's example with another operator
15:49:20 <xerox> Try to roll up your own ArrowState :-)  'night for real.
15:50:04 <sjanssen> palomer: though, you probably don't have to -- functions and type constructors are in a separate namespace
15:53:22 <lisppaste2> int80_h pasted "assignment 6.22 from Haskell:The Craft of Functional Programming" at http://paste.lisp.org/display/19521
15:55:09 <palomer> ah, it's a type constructor
15:55:11 <mauke> int80_h: I don't understand your code, but [x] matches lists with a single element
15:55:58 <SamB> int80_h: is that related to DOS 6.22?
15:56:09 <int80_h> ???\
15:56:09 <lambdabot> Unknown command, try @list
15:56:30 <int80_h> I think I mentioned I was throughly confused
15:57:02 <mauke> do you understand what I said?
15:57:26 <int80_h> I don't know what you mean by [x]
15:57:27 <sjanssen> int80_h: how about "formatLines xs = concat (map formatLine xs)" ?
15:57:40 <int80_h> I can't use map yet. I wish I could
15:57:47 <sjanssen> ah
15:57:48 <mauke> int80_h: [ (n,p) ] then
15:57:54 <mauke> sjanssen: concatMap
15:58:11 <sjanssen> mauke: yeah, trying not to introduce unfamiliar names
15:58:31 <int80_h> but map hasn't been introduced yet and I don't want to cheat
15:58:44 <sjanssen> though I suppose anybody would realize concatMap f == concat . map f
15:58:57 <mauke> sjanssen: that's wrong
15:59:07 <mauke> er, no
15:59:27 <sjanssen> int80_h: as mauke alluded to, the problem is with your [(name, price)] pattern match
15:59:29 <mauke> concaMap = concat . map would be wrong :-)
15:59:51 <int80_h> mauke: what I want to do is "map" formatline to each element but I can't use map.
16:00:05 <mauke> so write map first?
16:00:10 <palomer> !
16:00:17 <mauke> mymap f list = [ f x | x <- list ]
16:00:20 <int80_h> well, the assignment says to just write one function
16:00:34 <int80_h> ooh I could include that in the function!
16:00:35 <sjanssen> mauke: yep, I started to write concat . map, then tried to pointfree it in my head.  I finally gave up and added f ;)
16:00:45 <mauke> sjanssen: (concat .) . map
16:01:00 <int80_h> oh wait I can't pass functions as values yet
16:01:03 <sjanssen> int80_h: if map is considered cheating, I would consider list comprehensions cheating also
16:01:06 <int80_h> okay I need a different approach
16:01:21 <SamB> int80_h: are you just doing this for yourself?
16:01:27 <int80_h> list comprehensions have been introduced in the text, not cheating. map hasn't, cheating.
16:01:37 <int80_h> Yes. I am teaching myself haskell.
16:01:45 <mauke> having just written adjustWithKey = updateWithKey . ((return .) .), concatMap is easy :-)
16:01:53 <SamB> because you probably are allowed to skip to where you feel like you should be...
16:02:04 <palomer> map f (a: lst) = f a : (map f lst) ; map f [] = []
16:02:23 <adu> hi
16:02:24 <int80_h> I don't want to have any gaps. I know map from lisp.
16:02:37 <SamB> okay...
16:02:38 <int80_h> I should be right where I am, because this is where I'm stuck.
16:02:44 <sjanssen> int80_h: the problem is when you pattern match with [(n, p)], you're only matching lists containing one pair
16:02:47 <SamB> oh
16:03:00 <int80_h> ahh
16:03:10 <int80_h> I'm confused on syntax then
16:03:14 <adu> i've actually never used map in lisp
16:03:15 <sjanssen> yes
16:03:25 <adu> the only language i ever use map in is Python
16:03:46 <SamB> Python's map is closer to Haskell's than CL's is, I think...
16:03:52 <sjanssen> int80_h: I'll give you a starting point: formatLines ((name, price):theRest) = ...
16:04:26 <int80_h> ah good
16:04:30 <mauke> @type \f -> foldr (flip ((. f) . (:))) []
16:04:31 <lambdabot>   Occurs check: cannot construct the infinite type: c = [c]
16:04:31 <lambdabot>   Expected type: c -> a -> c
16:04:44 <int80_h> now when I return it will be with brand new problems :)
16:04:54 <int80_h> \thanks sjanssen
16:05:54 <sjanssen> @type \f -> (flip ((. f) . (:)))
16:05:56 <lambdabot> forall a b.
16:05:56 <lambdabot>           (b -> [a]) -> b -> a -> [a]
16:09:35 <palomer> hrmph
16:09:42 <palomer> there should be a Sequence typeclass
16:09:43 <palomer> seriously
16:10:03 <mauke> ok, I was doing it wrong
16:10:07 <mauke> @type flip foldr [] . ((:) .)
16:10:07 <sjanssen> palomer: containing things like head, tail?
16:10:08 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:10:14 <lispy> @type unfoldr
16:10:15 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
16:11:33 <palomer> it would contain most containers, really
16:11:43 <palomer> as well as tuples
16:12:10 <sjanssen> palomer: if you include tuples, making such a class becomes hairier
16:13:38 <palomer> well, that's really the whole point
16:13:43 <sjanssen> class Sequence c a where head :: c -> a; tail :: c -> c -- the simple case
16:14:08 <palomer> oh, I was thinking of Sequence as containing a single member
16:14:09 <palomer> sequence
16:14:12 <sjanssen> class Sequence c a tailType where head :: c -> a; tail :: c -> tailType
16:14:52 <sjanssen> oh, what would sequence do?
16:15:01 <palomer> @type sequence
16:15:03 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
16:15:19 <sjanssen> ah
16:16:31 <sjanssen> a ToList class would be more general
16:17:02 <lispy> palomer: functor?
16:17:02 <palomer> well, sequence would have type
16:17:10 <palomer> @type fmap
16:17:11 <lambdabot> forall (f :: * -> *) b a.
16:17:11 <lambdabot>    (Functor f) =>
16:17:11 <lambdabot>    (a -> b) -> f a -> f b
16:17:18 <palomer> sequence would have type
16:17:23 <sjanssen> @hoogle fmapM
16:17:24 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
16:17:24 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
16:17:44 <palomer> Sequenceable s => forall a (m :: * -> *). (Monad m) => s (m a)-> m (s a)
16:18:14 <sjanssen> @type Data.FunctorM.fmapM const
16:18:15 <lambdabot> forall (f :: * -> *) a b.
16:18:15 <lambdabot>           (Data.FunctorM.FunctorM f) =>
16:18:15 <lambdabot>           f a -> b -> f a
16:18:18 <lispy> > fmap id (1,2)
16:18:19 <lambdabot>  add an instance declaration for (Functor ((,) a))
16:18:19 <lambdabot>   In the definition of `sun': sun = fmap id (1, 2)
16:18:19 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
16:19:02 <lispy> wait, what the crap?
16:19:04 <lispy> > fmap id (1,2)
16:19:05 <lambdabot>  add an instance declaration for (Functor ((,) a))
16:19:05 <lambdabot>   In the definition of `hnu': hnu = fmap id (1, 2)
16:19:05 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
16:19:19 <lispy>    In the definition of `yhjulwwiefzojcbxybbruweejw':
16:19:21 <sjanssen> palomer: functorM can do that
16:19:23 <lispy> what is lambdabot smoking?
16:19:55 <sjanssen> lispy: you're wondering about the weird names?
16:20:01 <lispy> yeah, that's weird
16:20:55 <sjanssen> > typeOf yhjulwwiefzojcbxybbruweejw
16:20:56 <lambdabot> [Char]
16:21:02 <sjanssen> V returns!!!!
16:21:09 <sjanssen> > head yhjulwwiefzojcbxybbruweejw
16:21:10 <lambdabot> Exception: <<loop>>
16:21:15 <lispy> ??
16:21:15 <lambdabot> Not enough arguments to @.
16:21:18 <sjanssen> > take 10 yhjulwwiefzojcbxybbruweejw
16:21:19 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:21:22 <sjanssen> YES!!!!
16:21:27 <palomer> OH NO
16:21:32 <mauke> you may call me v
16:21:37 <palomer> HES BACK
16:21:40 <lispy> what is going on?
16:21:43 <sjanssen> I though dons said he fixed it
16:21:53 <palomer> he just renamed it
16:21:53 <sjanssen> @seen dons
16:21:54 <lambdabot> dons is in #haskell-overflow and #haskell. I don't know when dons last spoke.
16:22:00 <lispy> @type sun
16:22:01 <lambdabot> Not in scope: `sun'
16:22:03 <palomer> to something less conspicuous
16:22:08 <lispy> @type hnu
16:22:10 <lambdabot> Not in scope: `hnu'
16:22:21 <sjanssen> I though he said he'd make it randomly generated
16:23:03 <lispy> palomer: so why do you require a monad for sequenceable instead of a functor?
16:23:23 <lispy> every monad is a functor but not the other way
16:23:38 <sjanssen> lispy: Functor can't express what palomer wants
16:23:48 <lispy> @palomer
16:23:49 <lambdabot> blargh!
16:23:59 <lispy> ah
16:24:05 <lispy> why not?
16:24:11 <sjanssen> > take 50 yhjulwwiefzojcbxybbruweejw
16:24:13 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
16:24:33 <lispy> sjanssen: what is that?
16:24:59 <lispy> > filter isUpper yhjulwwiefzojcbxybbruweejw
16:25:00 <lambdabot> Terminated
16:25:08 <lispy> it seems to be really long
16:25:27 <sjanssen> it's an artifact of the translation lambdabot applies to "> E" requests, basically it's evaluating "let v = show E", when E references v, you get weird stuff
16:25:55 <sjanssen> and when I say v, I really mean yhjulwwiefzojcbxybbruweejw
16:26:01 <sjanssen> > length yhjulwwiefzojcbxybbruweejw
16:26:02 <lambdabot> Exception: <<loop>>
16:26:04 <Cale> > length yhjulwwiefzojcbxybbruweejw
16:26:05 <lambdabot> Exception: <<loop>>
16:26:06 <Cale> heh
16:26:06 <lispy> huh
16:26:11 <sjanssen> WHEEEE!
16:26:23 <Cale> > length (take 5 yhjulwwiefzojcbxybbruweejw)
16:26:24 <hyrax42> ha
16:26:24 <lambdabot> Exception: <<loop>>
16:26:29 <sjanssen> I can't believe we're going through the v thing again
16:26:50 <lispy> sjanssen: they just added TH support maybe that brought it back
16:27:14 <Cale> > map succ yhjulwwiefzojcbxybbruweejw
16:27:16 <lambdabot> "#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]]^^__``aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~\DEL\DEL]EFM]EFM^FGN^FGN_GHO_GHO`HIP`HIPaIJQaIJQbJKRbJKRcKLScKLSdLMTdLMT
16:27:16 <lambdabot> eMNUeMNUfNOVfNOVgOPWgOPWhPQXhPQXiQRYiQRYjRSZjRSZkST[kST[lTU\\lTU\\mUV]]mUV]]nVW^^nVW^^oWX__oWX__pXY``pXY``qYZaaqYZaarZ[bbrZ[bbs[\\ccs[\\cct\\]]ddt\\]]ddu]]^^eeu]]^^eev^^__ffv^^__ffw__``ggw__``ggx``
16:27:16 <lambdabot> aahhx``aahhyaabbiiyaabbiizbbccjjzbbccjj{ccddkk{ccddkk|ddeell|ddeell}eeffmm}eeffmm~ffggnn~ffggnn\DELgghhoo\DELgghhoo]EFMhhiipp]EFMhhiipp^FGNiijjqq^FGNiijjqq_GHOjjkkrr_GHOjjkkrr`HIPkkllss`HIPkkllssaIJQl
16:27:16 <lambdabot> lmmttaIJQllmmttbJKRmmnnuubJKRmmnnuucKLSnnoovvcKLSnnoovvdLMTooppwwdLMTooppwweMNUppqqxxeMNUppqqxxfNOVqqrryyfNOVqqrryygOPWrrsszzgOPWrrsszzhPQXsstt{{hPQXsstt{{iQRYttuu||iQRYttuu||jRSZuuvv}}jRSZuuvv}}kST[
16:27:19 <lambdabot> vvww~~kST[vvww~~lTU\\wwxx\DEL\DELlTU\\wwxx\DEL\DELmUV]]xxyy]EFM]EFMmUV]]xxyy]EFM]EFMnVW^^yyzz^FGN^FGNnVW^^yyzz^FGN^FGNoWX__zz{{_GHO_GHOoWX__zz{{_GHO_GHOpXY``{{||`HIP`HIPpXY``{{||`HIP`HIPqYZaa||}}
16:27:21 <lambdabot> [6 @more lines]
16:27:23 <sjanssen> dons: so v is called yhjulwwiefzojcbxybbruweejw now?  ;-)
16:27:30 <Cale> ahaha
16:27:30 <sjanssen> holy shit!
16:28:25 <lispy> > map succ (drop 1000 yhjulwwiefzojcbxybbruweejw)
16:28:27 <lambdabot> Exception: <<loop>>
16:28:41 <sjanssen> a cookie to the first person to express fibonacci in yhjulwwiefzojcbxybbruweejw!
16:29:00 <lispy> what is the meaning of \DEL
16:29:08 <lispy> are some of these terminal codes?
16:29:13 <sjanssen> lispy: yes
16:29:13 <Cale> yes
16:29:32 <palomer> yes
16:29:38 <lispy> it's a pretty random chunk of memory then i guess
16:29:49 <Cale> no, it's not
16:29:51 <sjanssen> > take 10 $ map succ ('a':yhjulwwiefzojcbxybbruweejw)
16:29:53 <lambdabot> "b#c$d%e&f'"
16:29:56 <palomer> looks like a star trek transcript
16:30:10 <Cale> It's just a recursively defined string
16:30:17 <jip> Cale: i've made sure that my array accesses are linear. DiffUArray is still 5 times slower then UArray. someone mentioned that this might be because DiffArray uses MVars or something which, is slower then just copying the entire array
16:30:26 <sjanssen>  > 'a':(take 10 $ map succ $ tail yhjulwwiefzojcbxybbruweejw)
16:30:38 <Cale> jip: that would be odd, given the size of your array
16:30:42 <sjanssen> > 'a':(take 10 $ map succ $ tail yhjulwwiefzojcbxybbruweejw)
16:30:43 <lambdabot> "abcdefghijk"
16:30:50 <jip> Cale: size is 32KB
16:31:06 <Cale> jip: but I suppose it's possible -- DiffUArray was faster for me with an array of 81 Ints.
16:31:07 <ihope> Hmm...
16:31:08 <lispy> > map succ (reverse yhjulwwiefzojcbxybbruweejw)
16:31:10 <lambdabot> Exception: <<loop>>
16:31:10 <ihope> The new v?
16:31:22 <Cale> and my accesses aren't even linear
16:31:26 <ihope> Yeah, it is...
16:31:39 <sjanssen> ihope: yes, aren't you EXCITED!
16:31:42 <mauke> yhjulwwiefzojcbxybbruweejw for yhjulwwiefzojcbxybbruweejwendetta
16:31:50 <Cale> haha
16:31:53 <hyrax42> hh
16:31:54 <lispy> heh
16:32:08 <ihope> Heh.
16:32:15 <Cale> > tails yhjulwwiefzojcbxybbruweejw
16:32:16 <lambdabot> Exception: <<loop>>
16:32:22 <ihope> > head yhjulwwiefzojcbxybbruweejw
16:32:23 <lambdabot> Exception: <<loop>>
16:32:26 <lispy> > yhjulwwiefzojcbxybbruweejw
16:32:27 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:32:27 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:32:27 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:32:27 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:32:29 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:32:32 <lambdabot> [6 @more lines]
16:32:38 <lispy> that seems odd to be
16:32:41 <lispy> er to me
16:32:43 <jip> wtf is this shit? :O
16:32:48 <ihope> It's yhjulwwiefzojcbxybbruweejw!
16:32:51 <lispy> given that succ prints something totatly different
16:32:57 <lispy> @type yhjulwwiefzojcbxybbruweejw
16:32:58 <lambdabot> Not in scope: `yhjulwwiefzojcbxybbruweejw'
16:33:00 <Cale> take 5 . map succ $  yhjulwwiefzojcbxybbruweejw
16:33:08 <Cale> > take 5 . map succ $  yhjulwwiefzojcbxybbruweejw
16:33:09 <lambdabot> "#$%&'"
16:33:23 <ihope> Apparently lambdabot evaluates this stuff as "let yhjulwwiefzojcbxybbruweejw = show foobar in ..."
16:33:23 <Cale> > succ '"'
16:33:25 <lambdabot> '#'
16:33:29 <lispy> > let yhjulwwiefzojcbxybbruweejw = 'v' in yhjulwwiefzojcbxybbruweejw
16:33:30 <lambdabot> 'v'
16:33:35 <ihope> :-)
16:33:41 <ihope> > 3 2 1
16:33:42 <lambdabot>  add an instance declaration for (Num (t -> t1 -> a))
16:33:42 <lambdabot>   In the definition of `fom': fom = 3 2 1
16:33:42 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
16:33:45 <Cale> > take 20 . iterate succ $ '"'
16:33:46 <lambdabot> "\"#$%&'()*+,-./012345"
16:33:55 <ihope> > take 1 yhjulwwiefzojcbxybbruweejw
16:33:56 <lambdabot> "\""
16:33:59 <Cale> > take 20 . map succ yhjulwwiefzojcbxybbruweejw
16:34:00 <lambdabot> Couldn't match `[b]' against `t -> t1'
16:34:03 <ihope> > take 2 yhjulwwiefzojcbxybbruweejw
16:34:04 <lambdabot> "\"\\"
16:34:06 <Cale> > take 20 . map succ $ yhjulwwiefzojcbxybbruweejw
16:34:07 <lambdabot> "#$%&'()*+,-./0123456"
16:34:23 <ihope> > take 100 . map succ $ yhjulwwiefzojcbxybbruweejw
16:34:24 <lambdabot> "#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]]^^__``aabbccddeeffgghhiijjkkllmmnnooppqq"
16:34:32 <lispy> > drop 20 . map succ $ yhjulwwiefzojcbxybbruweejw
16:34:33 <lambdabot> Exception: <<loop>>
16:34:54 <lispy> why does drop and length cause a loop?
16:35:20 <mauke> lispy: let v = drop 20 v in v
16:35:20 <ihope> > let yhjulwwiefzojcbxybbruweejw = show (length yhjulwwiefzojcbxybbruweejw) in yhjulwwiefzojcbxybbruweejw
16:35:21 <lambdabot> Exception: <<loop>>
16:35:25 <Cale> lispy: because it's a value which is defined in terms of its own show
16:35:47 <Cale> It's the string which is being output
16:36:07 <ihope> Yeah, yhjulwwiefzojcbxybbruweejw is the string which lambdabot pops it to you as.
16:36:19 <lispy> hmm...
16:37:07 <Cale> > error yhjulwwiefzojcbxybbruweejw
16:37:08 <ihope> > map show yhjulwwiefzojcbxybbruweejw
16:37:08 <lambdabot> Add a type signature
16:37:09 <lambdabot> Exception: <<loop>>
16:37:17 <Cale> > error yhjulwwiefzojcbxybbruweejw :: ()
16:37:18 <lambdabot> Exception
16:37:26 <Cale> > error yhjulwwiefzojcbxybbruweejw :: String
16:37:27 <lambdabot> Exception
16:37:27 <lispy> > show yhjulwwiefzojcbxybbruweejw
16:37:28 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:37:28 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:37:28 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:37:29 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:37:31 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:37:34 <lambdabot> [6 @more lines]
16:37:44 <ihope> > read yhjulwwiefzojcbxybbruweejw :: String
16:37:46 <lambdabot> Exception: <<loop>>
16:38:09 <ihope> let yhjulwwiefzojcbxybbruweejw = show (read yhjulwwiefzojcbxybbruweejw :: String) in ...
16:38:11 <ihope> :-)
16:38:31 <Cale> > error (show yhjulwwiefzojcbxybbruweejw) :: Integer
16:38:32 <lambdabot> Exception
16:38:39 <lispy> > let v = show (read v :: String) in v
16:38:40 <lambdabot> Exception: <<loop>>
16:38:54 <ihope> What do you expect it to be? :-)
16:38:56 <Cale> > error (iterate succ 'a')
16:38:57 <lambdabot> Add a type signature
16:39:03 <Cale> > error (iterate succ 'a') :: ()
16:39:05 <lambdabot> Exception: abcdefghijklmnopqrstuvwxyz{|}~
16:39:05 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
16:39:05 <lambdabot> 
16:39:05 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
16:39:06 <lambdabot> 
16:39:12 <lispy> > let v = show (map succ v) in v
16:39:13 <lambdabot> "\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]]^^__``aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~\\DEL\\DEL]EFM]EFM^FGN^FGN_GHO_GHO`HIP`HIPaIJQaIJQbJKRbJKRcKLScKLSdL
16:39:13 <lambdabot> MTdLMTeMNUeMNUfNOVfNOVgOPWgOPWhPQXhPQXiQRYiQRYjRSZjRSZkST[kST[lTU\\\\lTU\\\\mUV]]mUV]]nVW^^nVW^^oWX__oWX__pXY``pXY``qYZaaqYZaarZ[bbrZ[bbs[\\\\ccs[\\\\cct\\\\]]ddt\\\\]]ddu]]^^eeu]]^^eev^^__ffv^^__
16:39:16 <lambdabot> ffw__``ggw__``ggx``aahhx``aahhyaabbiiyaabbiizbbccjjzbbccjj{ccddkk{ccddkk|ddeell|ddeell}eeffmm}eeffmm~ffggnn~ffggnn\\DELgghhoo\\DELgghhoo]EFMhhiipp]EFMhhiipp^FGNiijjqq^FGNiijjqq_GHOjjkkrr_GHOjjkkrr`
16:39:19 <lambdabot> HIPkkllss`HIPkkllssaIJQllmmttaIJQllmmttbJKRmmnnuubJKRmmnnuucKLSnnoovvcKLSnnoovvdLMTooppwwdLMTooppwweMNUppqqxxeMNUppqqxxfNOVqqrryyfNOVqqrryygOPWrrsszzgOPWrrsszzhPQXsstt{{hPQXsstt{{iQRYttuu||iQRYttuu||
16:39:21 <Cale> whoa
16:39:22 <lambdabot> jRSZuuvv}}jRSZuuvv}}kST[vvww~~kST[vvww~~lTU\\\\wwxx\\DEL\\DELlTU\\\\wwxx\\DEL\\DELmUV]]xxyy]EFM]EFMmUV]]xxyy]EFM]EFMnVW^^yyzz^FGN^FGNnVW^^yyzz^FGN^FGNoWX__zz{{_GHO_GHOoWX__zz{{_GHO_GHOpXY``{{||`HIP`
16:39:25 <lambdabot> [6 @more lines]
16:39:26 <Lemmih> Urk.
16:39:30 <lispy> sorry guys
16:39:36 * swoolley-voted types @more lines
16:39:46 <Cale> ah, I thought it was just me
16:40:04 <basti_> whats THAT?
16:40:11 <lispy> no, i had to try the let v = show (map succ v) in v just to see that it really did messed up things
16:40:49 * lispy does further experiments with ghci
16:42:07 <ihope> > take 10 (read ('"' : cycle "123") :: String)
16:42:11 <lambdabot> Terminated
16:42:25 <ihope> So read likes to have the whole string handy?
16:42:38 <lispy> read is strict iirc
16:43:01 <sethk> it can't decode only part of a number string
16:43:10 <sethk> that would give the wrong answer
16:43:20 <sethk> so it must force the computation at least to the point where it has the entire string
16:43:36 <sjanssen> read is strict because it must fail when it is given an incorrect input
16:43:46 <sjanssen> > read "elephant" :: Int
16:43:47 <lambdabot> Exception: Prelude.read: no parse
16:43:56 <ihope> Wait, wait...
16:44:18 <ihope> > reads ('"' : cycle "123") :: [(String,String)]
16:44:23 <lambdabot> Terminated
16:44:41 <mauke> > read (repeat 'y') :: Int
16:44:44 <lambdabot> Terminated
16:45:26 <ihope> Well, I think that wouldn't be read there that's strict; it'd be readsPrec.
16:47:23 <sethk> ihope, but read needs to be strict for the other reasons mentioned
16:47:56 <ihope> Oh, readsPrec has to consume all the input.
16:48:45 <lispy> OH
16:49:15 <lispy> the reason you get the alphabet plus garbage off to infinity is because it's showing the first char, finding the succ and showing that, finding the succ and showing that and ...
16:49:18 <lispy> i get it now
16:49:22 * lispy is just slow
16:55:27 <lispy> okay, so then if we're evaluating 'let v = show (take 1 v) in v' what defines the first character shown?
16:55:36 <lispy> > let v = show (take 1 v) in v
16:55:37 <lambdabot> "\"\\\"\""
16:55:46 <lispy> and what character is that?
16:56:06 <lispy> looks more like a string to me. but even so, where does it from?
16:56:20 <palomer> well, erm, my masters thesis has compiled
16:56:24 <palomer> I'm too scared to run it
16:56:27 <palomer> so I won't
16:57:35 <lispy> palomer: eventually curiousity will get you
16:58:25 <palomer> never!
16:58:32 <palomer> it works until I find a bug in it
16:58:36 <palomer> if I never run it, it'll work1
16:58:39 <lispy> heh
16:58:44 <mauke> lispy: v is a String, since that's what show returns
16:58:58 <lispy> mauke: but what string?
16:59:02 <mauke> and show for strings starts with a '"' regardless of content
16:59:10 <lispy> OH
16:59:35 <liyang> loltypingtheknotlol
16:59:41 <lispy> and "\"\\\"\"" is show trying to show that it will show "
17:00:50 <mauke> > show '"'
17:00:51 <lambdabot> "'\"'"
17:01:14 <lispy> > show . show . show $ '"'
17:01:15 <lambdabot> "\"\\\"'\\\\\\\"'\\\"\""
17:01:23 <lispy> > show . show $ '"'
17:01:23 <mauke> er, d'oh
17:01:24 <lambdabot> "\"'\\\"'\""
17:01:30 <mauke> > show "\""
17:01:31 <lambdabot> "\"\\\"\""
17:01:41 <lispy> ah yeah
17:02:14 <lispy> it's weird how 15 minutes ago this was such a mystery to me
17:02:44 <palomer> it's still a mystery to me
17:02:52 <palomer> then again, I haven't really thought about it
17:03:05 <lispy> > let v = show (take 1 v) in v
17:03:07 <lambdabot> "\"\\\"\""
17:03:12 <lispy> that's it in a nutshell :)
17:03:48 <lispy> > take 1 yhjulwwiefzojcbxybbruweejw
17:03:50 <lambdabot> "\""
17:04:34 <lispy> i guess i have to add the show to make them patch
17:04:36 <lispy> er match
17:04:43 <lispy> > show (take 1 yhjulwwiefzojcbxybbruweejw)
17:04:44 <lambdabot> "\"\\\"\""
17:04:54 <palomer> phew
17:09:34 <rasfar> Is there a #category-theory channel?
17:10:28 <lispy> rasfar: try #math i think #haskell and #math are your best bets
17:10:46 <rasfar> thanks lispy
17:10:58 <lispy> rasfar: np
17:11:25 <rasfar> I'd ask here, it's about the Kleisli construction, but my question is more mathy so I'll try there first.
17:12:26 <lispy> rasfar: or just wait for Cale to come back :)
17:12:54 <rasfar> I see he set the topic on #math.
17:20:30 <rasfar> Anyone here dying to discuss the Kleisli construction for the exception monad?
17:22:41 <ihope> Ooh!
17:22:53 <ihope> Sounds cool.
17:24:16 <rasfar> ihope: could you be talking to me?!?
17:24:28 <ihope> I think so.
17:24:34 <rasfar> lol
17:24:36 <lispy> no, that's not allowed :)
17:24:58 <rasfar> what, talking to me, or talking about my proposed topic?
17:25:10 <sethk> rasfar, possibly both  :)
17:25:31 <int80_h> hey I have a question. ON the mud project I accidently put my name in the assigned-to field. This is marked as accepted.
17:25:38 <sjanssen> > let fibo a acc [] = show a; fibo a acc ('"':xs) = fibo a acc xs; fibo a acc (' ':xs) = show a ++ ' ' : fibo (a + read acc) "" xs; fibo a acc (x:xs) = fibo a (acc ++ [x]) xs in fibo 0 "1" $ take 20 $ ' ':yhjulwwiefzojcbxybbruweejw
17:25:39 <lambdabot> "0 1 1 2 3 5 8 13 21 34"
17:25:44 <sjanssen> YES!
17:25:59 <int80_h> I was going to remove my name, just because I didn't want to breech ettiquette. But as it is marked as accepted, should I just leave it?
17:26:00 <lispy> @karma+ sjanssen 
17:26:01 <lambdabot> sjanssen's karma raised to 3.
17:26:11 <lispy> sjanssen: taht's sick :)
17:26:54 * sjanssen feels silly for spending nearly an hour on this
17:27:15 <int80_h> anyone? ettiquette question here...
17:27:16 <hyrax42> woah
17:27:31 * int80_h doesn't want to be percieved as rude or pushy.
17:27:37 <sethk> int80_h, I'd say if it's inaccurate, correct it
17:27:46 <int80_h> who does the assigning?
17:27:55 <sethk> int80_h, that I don't know
17:27:55 <SamB> what does assigning even mean?
17:28:07 <int80_h> someone gets assigned to a project.
17:28:10 <SamB> maybe it doesn't mean a thing here
17:28:24 <int80_h> Here you go Samb...a link
17:28:26 <SamB> it usually means the person to fix a bug/implement a feature, probably...
17:28:35 <int80_h> http://hackage.haskell.org/trac/summer-of-code/ticket/56
17:28:49 <rasfar> nothingmuch: sorry I missed you I think, or -- how do I accept the invitation?
17:28:59 <nothingmuch> rasfar: it was actually a joke
17:29:06 <int80_h> the mud project I guess I should mention, is part of the proposed projects for the summer of code
17:29:06 <nothingmuch> that channel was completely empty ;-)
17:29:21 <SamB> int80_h: yes, I figured that part out ;-)
17:29:24 <greenrd> tickets are usually "assigned" by the person who takes responsibility for them
17:29:26 <rasfar> i can corroborate that
17:29:34 <SamB> mine is ticket:4
17:29:41 <greenrd> it's a silly terminology that's been carried over from the corporate world
17:29:41 <int80_h> ah,so me assigning myself would not be rude?
17:29:48 <greenrd> indeed no
17:29:56 <int80_h> okay then :)
17:30:06 <SamB> int80_h: but maybe assigning is for mentors!
17:30:09 <SamB> who knows!
17:30:17 <int80_h> That's what I'm trying to ask :)
17:30:22 <SamB> I don't, they probably don't either!
17:30:37 <SamB> I say assign it to nobody like the others
17:30:49 <SamB> since none of us knows what it means
17:31:01 <sethk> int80_h, assign it to nobody.  since it shouldn't be you, and you don't know who it should be, what else can you do?
17:31:15 <int80_h> Well, I think it should be me.
17:31:26 <int80_h> But the question is, who does the assigning
17:31:32 <SamB> but, you don't know what it is!
17:31:37 <int80_h> yes, I do
17:31:47 <int80_h> I was the one who proposed the idea
17:31:48 <sethk> int80_h, oh, it should be you, but you're not sure you are entitled to assign it to you, even though you are the assigner?
17:31:54 <SamB> but these tickets aren't like other tickets
17:32:12 <int80_h> anyone can assign, it seems. Yes I wasn't sure if I was entitled to assign it to myself.
17:32:16 <sethk> int80_h, if it should be you, leave it.  as long as the info is correct I don't think anyone is going to get upset
17:32:40 <int80_h> if what info is correct?
17:32:48 <SamB> sethk: I don't see how he can know what it means
17:33:01 <sethk> SamB, I don't either, but that's a separate issue
17:33:21 <int80_h> know what what means? I was the one who proposed the idea. How can I not know what it means?
17:33:34 <sethk> int80_h, I don't know, maybe you are a republican or something
17:33:45 <SamB> int80_h: you don't know what the assignment means
17:33:53 <int80_h> are we having the same conversation? I thyink I need to talk to some knowledgable people
17:34:11 <int80_h> assignment is a verb in this case, not a noun
17:34:18 <int80_h> thanks guys
17:34:20 <sethk> int80_h, your original question was about whether anyone would be upset because you assigned it to yourself.  I think you needn't worry about that.
17:34:27 <int80_h> okay cool
17:34:54 <drakioned> hey int80_h.
17:35:19 <int80_h> Because I was excited about this idea. I want to be on the project. ;)
17:35:30 <int80_h> I would be bummed if I wasn't
17:35:36 <SamB> ?
17:36:30 <int80_h> form of a question please. noun verb and all that rot.
17:36:59 <SamB> are you supposed to be an interested student or an interested mentor?
17:37:05 <int80_h> student :)
17:37:24 <int80_h> Ah I see the problem. The mentor should have the ticket
17:37:28 <SamB> should probably stick yourself on the list of interested students?
17:37:37 <int80_h> right then, now how do I do that?
17:37:42 <drakioned> edit the text..
17:37:49 <int80_h> I see we can modify pages but I don't see the link to do so
17:37:58 <SamB> are you logged in?
17:38:59 <int80_h> yeah just logged in
17:39:32 <int80_h> I see one student listed under interested students
17:39:43 <drakioned> just add another dot under my name and add yourself..
17:40:09 <int80_h> okay what's the mechanism. On wiki there's an edit link but I don't see one
17:40:29 <drakioned> bleh, I'll add you, it'll be faster ;)
17:40:46 <drakioned> name?
17:40:58 <int80_h> oh I see what the did
17:41:03 <int80_h> n/m
17:41:18 <drakioned> *shrug*
17:42:19 <int80_h> hmm is someone else changing ..I get mid air condition error
17:42:40 <drakioned> I see your name on it.
17:43:24 <int80_h> ahh finally..
17:44:18 <int80_h> okay I'll send e-mail to the interested mentor
18:24:46 <sjanssen> > let fibo a acc [] = show a; fibo a acc ('"':xs) = fibo a acc xs; fibo a acc (' ':xs) = show a ++ ' ' : fibo (a + read acc) "" xs; fibo a acc (x:xs) = fibo a (acc ++ [x]) xs in fibo 0 "1" $ take 50 $ ' ':yhjulwwiefzojcbxybbruweejw
18:24:47 <lambdabot> "0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597"
18:26:52 <lispy> sjanssen: that's so cool
18:27:03 <lispy> sjanssen: i hope dons sees it soon
18:27:19 <sjanssen> @localtime dons
18:27:22 <lambdabot> Local time for dons is Sun Apr 30 11:28:28 2006
18:32:51 <Cale> heh
18:34:00 <drakioned> Hi Cale.
18:34:07 <Cale> hi
18:44:25 <palomer> high
18:46:51 <JosephRivers> Hey, does haskell include a 64-bit integer data type?
18:47:05 <SyntaxNinja> @type 3::Word64
18:47:06 <lambdabot> Word64
18:47:20 <SyntaxNinja> @hoogle Word64
18:47:21 <lambdabot> Data.Word.Word64 :: data Word64
18:47:22 <Cale> Int64
18:47:24 <sjanssen> > take 40 ("hi" ++ yhjulwwiefzojcbxybbruweejw)
18:47:25 <lambdabot> "hi\"hi\\\"hi\\\\\\\"hi\\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
18:47:35 <JosephRivers> Thanks
18:47:35 <SyntaxNinja> > 3::Word64
18:47:37 <lambdabot> 3
18:47:51 <SyntaxNinja> what's the difference between int64 and word64?
18:48:00 <sjanssen> word64 is unsigned
18:48:07 <sjanssen> > minBound :: Word64
18:48:08 <lambdabot> 0
18:48:41 <SyntaxNinja> oh right
18:48:53 <SyntaxNinja> >(minBound::Word64) - =
18:48:59 <SyntaxNinja> >(minBound::Word64) - 1
18:49:17 <dons> ah sigh.
18:49:28 <dons> you #haskell hackers up to no good again
18:49:40 <SyntaxNinja> hiya dons
18:49:46 <SyntaxNinja> did I break it?
18:49:51 <drakioned> again? what did we do the first time?
18:50:30 <dons> nah, 'v' is just 'yj...'. Since getting truly random idents in the code I needed required IO.
18:50:52 <sjanssen> dons: there's one way you could fight this off
18:51:12 <dons> well, unsafePerformIO would work.
18:51:20 <dons> i've already got random ident code elsewhere
18:51:24 <sjanssen> replicate (length input) 'v'
18:51:51 <dons> interesting idea!
18:52:18 <lispy> hehe
18:57:01 <palomer> dons: what's up with our evil villain returning under a different guise
18:57:25 <dons> fixing it as we speak. the problem was the the code gen was pure, and I wa too lazy to thread a unique supply in.
18:57:46 <dons> trusting to the good nature of #haskell was a mistake ;)
18:57:49 <int-e> sjanssen: I'd prefer map (const 'v')
18:58:06 <palomer> dons: but wasn't there a concensus that v wasn't useful?
18:59:03 <lispy> dons: yeah, it's not dangerous is it?  just weird
18:59:15 <sjanssen> int-e: if the input is so long that there's an observable difference, we're already in big trouble
18:59:18 <dons> its not dangerous, no.
18:59:31 <dons> its just a way to refer to the entire binding for the expression from the outside
19:00:11 <sjanssen> lispy: the problem is that someone will stumble on it every month or so, and we'll have this huge "WTF?" conversation
19:00:23 <dons> $ runhaskell scripts/RunPlugs.hs
19:00:23 <dons> take 40 ("hi" ++ yhjulwwiefzojcbxybbruweejw)
19:00:23 <dons> <irc>:1:17: Not in scope: `yhjulwwiefzojcbxybbruweejw'
19:00:29 <dons> :)
19:00:35 <dons> a truly unique supply now.
19:01:46 <drakioned> print v
19:02:03 <drakioned> print 'v'
19:02:08 * drakioned shrugs.
19:02:21 <dons> reading the thread as you guys worked out what yhjulwwiefzojcbxybbruweejw is is very funny :)
19:02:34 <dons> 16:21:22 <sjanssen> YES!!!!
19:02:34 <dons> 16:21:27 <palomer> OH NO
19:02:34 <dons> 16:21:32 <mauke> you may call me v
19:02:34 <dons> 16:21:37 <palomer> HES BACK
19:03:01 <sjanssen> dons: so it's actually random, not just the replicate trick?
19:03:13 <drakioned> what was yhjulwwiefzojcbxybbruweejw ?
19:03:16 <int-e> > lift lift lift
19:03:17 <lambdabot> Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
19:03:25 <palomer> it's the name of dons' newborn son
19:03:30 <dons> it will be in a second once I rebuild the code, yes.
19:04:49 <dons> drakioned: it was an internal name use to bind the code user's type.
19:05:02 <dons> a bit like 'it', in some ways, in ghci. not quite the same though.
19:05:03 <drakioned> ah
19:05:24 <lispy> if you typed '> show yhjulwwiefzojcbxybbruweejw' it was like typing let v = show v in v
19:06:50 <drakioned> ah
19:06:50 <dons> exactly
19:07:28 <lispy> which can use to emulate the behavior in ghci
19:07:33 <lispy> if you're curious how it works
19:09:13 <int-e> > undefined :: 1
19:09:14 <lambdabot> Terminated
19:09:36 <dons> hang on. fixing runplugs...
19:09:57 <dons> > 1+2
19:09:59 <lambdabot> 3
19:10:11 * int-e wonders why :: 1 works (apparently as an alias for GHC.Base.Unit)
19:10:25 <dons> yep. feature.
19:10:47 <sjanssen> > fmap id (1,2)
19:10:48 <lambdabot>  add an instance declaration for (Functor ((,) a))
19:10:48 <lambdabot>   In the definition of `ofg': ofg = fmap id (1, 2)
19:10:48 <lambdabot>   In the definition of `wnx':
19:10:50 <int-e> but it seems silly
19:10:57 <sjanssen> > fmap id (1,2)
19:10:58 <lambdabot>  add an instance declaration for (Functor ((,) a))
19:10:58 <lambdabot>   In the definition of `jwq': jwq = fmap id (1, 2)
19:10:58 <lambdabot>   In the definition of `iio':
19:11:05 <dons> good
19:12:31 <sjanssen> > head 1
19:12:32 <lambdabot>  add an instance declaration for (Num [a])
19:13:15 <sjanssen> why doesn't the error stripping code work with the Functor example?
19:13:24 <lispy> because it's a class?
19:13:30 <lispy> er no
19:13:35 <lispy> huh, yeah, weird
19:15:30 <dons> not general enough, Ig  guess.
19:16:09 <dons> ah, yes, it explicitly looks for IO
19:16:15 <dons> fixing.
19:18:06 <dons> hmm. no that's not it. no idea. someone else can write a custom error regex if they'd like for these No instance cases.
19:20:17 * lispy steps away slowly
19:20:33 * lispy avoids eye contact with dons and slips out
19:20:42 <lispy> i mean, sounds like fun :)
19:21:03 <lispy> maybe lambdabot improvements could be a google SoC project ;)
19:25:28 <drakioned> er.. I have something which I'm not sure whether or not is a bug..
19:25:54 <sjanssen> what is that?
19:26:45 <drakioned> well, if you do take 5 $ map (+1) [1..] it just returns the normal expected thing
19:27:00 <drakioned> if you import Control.Parallel and Control.Parallel.Strategies
19:27:02 <lispy> > take 5 $ map (+1) [1..]
19:27:03 <lambdabot> [2,3,4,5,6]
19:27:24 <drakioned> and then do take 5 $ parMap rwhnf (+1) [1..] it doesn't seem to work
19:27:39 <drakioned> > take 5 $ parMap rwhnf (+1) [1..]
19:27:40 <lambdabot>  Not in scope: `rwhnf'
19:27:53 <drakioned> > take 5 $ parMap r0 (+1) [1..]
19:27:54 <lambdabot>  Not in scope: `r0'
19:28:00 <lispy> @index rwhnf
19:28:01 <lambdabot> Control.Parallel.Strategies
19:28:14 <drakioned> hmm, is there any way of importing Control.Parallel.Strategies into lambdabot ?
19:28:22 <lispy> > take 5 P parMap Control.Parallel.Strategies.rwhnf (+1) [1..]
19:28:23 <lambdabot>  Not in scope: `Control.Parallel.Strategies.rwhnf'
19:28:42 <sjanssen> drakioned: my computer began consuming all memory
19:29:01 <drakioned> yeah.. that's why I think it's broke..
19:29:15 <lispy> drakioned: with lambdabot if it's available but not recognized adding the full module path works.  But in this case i guess it's not available
19:29:26 <drakioned> if it's a non-infinite list, parMap works properly
19:29:35 <drakioned> but it doesn't seem to like infinite lists
19:30:38 <lispy> could it be something about the wnf?
19:30:42 <lispy> er whnf
19:30:45 <lispy> what is the r?
19:30:51 <lispy> whnf=weak head normal form right?
19:32:06 <sjanssen> drakioned: yeah, this may not be a bug
19:32:29 <cmarcelo> dons: the latest lambdabot (got it via darcs) works w/ fps 0.6 ? or should I use fps 0.5 tarball ?
19:32:38 <drakioned> well, the two strategies in Control.Parallel.Strategies are rwhnf and r0 I think.
19:33:31 <sjanssen> what exactly is par supposed to do
19:33:49 <lispy> i think parMap is parallel map
19:33:56 <drakioned> er.. yeah, it's parallel map
19:34:01 <sjanssen> I know it evaluates in parallel, but what is the exact definition of it's behavior
19:34:31 <sjanssen> does "par a b" mean that it must evaluate b?
19:34:32 <drakioned> parMap :: Strategy b -> (a -> b) -> [a] -> [b] - parMap applies a function to each element of the argument list in parallel. The result of the function is evaluated using the given strategy.
19:34:36 <dons> cmarcelo: 0.5 tarball
19:34:47 <dons> actually, you might need the 0.4 tarball. hmm
19:35:17 <sjanssen> from the source: parMap strat f xs 	= map f xs `using` parList strat
19:35:24 <int-e> dons: the error message for '> fmap id (1,2)' does not contain a `In the [...] argument of' part.
19:35:27 <dons> I've been busing hacking on fps recently, and haven't been keeping all the projects that use it in sync 
19:36:13 <int-e> > []+[] -- same for this
19:36:14 <lambdabot>  add an instance declaration for (Num [a])
19:36:14 <lambdabot>   In the definition of `bls': bls = [] + []
19:36:14 <lambdabot>   In the definition of `zhi': zhi = let bls = [] + [] in take 2048 (show bls)
19:36:34 <dons> cmarcelo: fps-0.4 should be ok. but it needs a 1 line patch.
19:36:40 <drakioned> *puzzled*
19:36:52 <cmarcelo> dons: ok. the fps API changed much since 0.4/0.5?
19:37:15 <dons> cmarcelo: get fps 0.3, it shoudl work fine.
19:37:28 <SyntaxNinja> shapr!
19:37:29 <dons> cmarcelo: yes, there's been some changes to the module names, so that it could go into ghc 6.6
19:38:02 <palomer> > bls
19:38:03 <lambdabot>  Not in scope: `bls'
19:38:11 <cmarcelo> dons: i'll try 0.3, thanks.
19:38:57 <dons> palomer, what would the point of randomness be, if it was the same every time ;)
19:39:42 <sjanssen> drakioned: I think parMap is behaving as it should
19:39:48 <lispy> besides the first one was random before it's the second one that was hardcoded
19:39:51 <drakioned> ok.
19:39:55 <cmarcelo> does ghc-pkg (is this cabal?) supports multiple versions of the same package?
19:39:58 <sjanssen> though the documentation sucks for it
19:40:47 <drakioned> ok.
19:41:13 <drakioned> just out of interest, if there any parallel mapping feature for infinite lists then?
19:42:37 <sjanssen> it doesn't look like it, but I think you could use parListN to evaluate chunks at a time
19:43:25 <dons> cmarcelo: yes. all the different versions go in fine.
19:43:25 <drakioned> ok
19:43:31 <cmarcelo> great
19:49:09 <newsham> hi
19:55:38 <JosephRivers> How does one reference an infix operation in a module using its full path?
19:56:06 <Cale> Module.^*-
19:56:23 <Cale> > 5 Prelude.+ 6
19:56:24 <JosephRivers> That would reference the operation *?
19:56:25 <lambdabot> 11
19:56:34 <Cale> the operation ^*-
19:57:00 <Cale> > [1,2,3] Data.List.!! 0
19:57:01 <lambdabot> 1
19:57:04 <palomer> it does exponentiation, multiplication and subtraction all at once
19:57:12 <Cale> palomer: hehe
19:58:20 <JosephRivers> Cale: I want to use the operation .&. in Data.Bits, but Data.Bits..&. generates an error message--why isn't it working?
19:58:27 <Cale> hmm
19:58:36 <Cale> you're typing that infix?
19:58:46 <Cale> what error?
19:58:59 <int-e> > (Prelude.-) 42 15
19:59:00 <lambdabot> 27
19:59:05 <dons> mmm :) got an application from a guy to port the Clean IO code to Haskell for SoC :D
19:59:10 <JosephRivers> No, I wasn't. That must have been the problem.
19:59:26 <dons> JosephRivers: () missing?
19:59:39 <Cale> JosephRivers: if you want to use it prefix, put the whole thing in parens like int-e showed
19:59:57 <JosephRivers> Okay. Thanks.
20:10:37 <araujo> Hello!
20:11:28 <dons> hey araujo 
20:12:37 <araujo> dons, hello there!, how you doing? :-)
20:12:53 <dons> good. how's that SoC application coming along? :)
20:13:27 <SyntaxNinja> so does ghc have a darcs repo for the 6.4.2 release?
20:13:51 <SyntaxNinja> I don't understand what simon did w/ cabal there... where is the version of cabal that was released w/ 6.4.2?
20:14:14 <dons> I think that's just cvs isn't it? check the cvs ghc-6-4-2 tag
20:14:14 <araujo> dons, Excellent! , i already have a possible draft :-)
20:14:27 <dons> (or the tag is something similar to taht)
20:14:39 <dons> darcs only begins with the 6.5 branch
20:14:52 <SyntaxNinja> hmm
20:15:17 * araujo wonders how it sounds to have Haskell as an extension language for applications.
20:15:33 * SyntaxNinja politely points out that he's the one who forced simonMar to use darcs for the first time.
20:15:54 <SyntaxNinja> dons: is there a way to browse that on the web
20:15:58 <SyntaxNinja> maybe I"ll just donwload a tarball...
20:16:21 <dons> isn't the cvs web interface still up?
20:16:23 <dons> or did that die.
20:16:40 <SyntaxNinja> can you point me to it?
20:16:42 <dons> cvs checkout still works, no? ;)
20:16:46 <dons> looking ...
20:17:19 <SyntaxNinja> I think I'd better cut down on the number of projects I'm working on. I can't follow everything :(
20:17:26 <dons> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
20:18:24 <dons> you'll want to set the ghc-6-4-2 tag, I think.
20:18:31 <dons> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/Cabal/?only_with_tag=ghc-6-4-2
20:19:06 * araujo is afraid of making his draft too _unreal_
20:19:12 <SyntaxNinja> bugger!
20:19:20 <SyntaxNinja> it is as I feared
20:19:26 <dons> a wackky Cabal sync?
20:20:01 <SyntaxNinja> well, the "unstable" cabal branch has a different interface for the build hooks.
20:20:07 <SyntaxNinja> which I don't want to change again
20:20:18 <dons> right.
20:20:25 <SyntaxNinja> I fear I'll have to back out some patches.  they were nice too
20:25:54 <SyntaxNinja> does Nick Alexander hang out here by chance?
20:29:09 <Pawer> hello
20:29:11 <Pawer> !!
20:39:28 * araujo sees like nobody has touched the Halfs ticket
20:41:11 <SyntaxNinja> araujo: want it? :)
20:42:01 <araujo> SyntaxNinja, hah, i would definetly love to see that task done!
20:42:08 <araujo> but nah, im not a Phd student :-)
20:42:58 <SyntaxNinja> I don't think it's _that_ hard
20:43:04 <SyntaxNinja> <-- doesn't have a Phd after all
20:43:42 <Cale> SyntaxNinja: he does, sometimes
20:43:54 <Cale> SyntaxNinja: as ncalexan usually
20:44:04 <SyntaxNinja> Cale: thanks.
20:44:07 <Cale> SyntaxNinja: do you know him?
20:45:00 <SyntaxNinja> Cale: no, but I need to talk to him about some of his cabal patches.  He has done some great work, but due to a bit of a mess w/ the repositories, and bugs in darcs, it's all messed up :(
20:51:05 <araujo> SyntaxNinja, i do think it's a very important project, most people got this belief that you can't code IO stuff with Haskell
20:51:36 <araujo> Ive received answers of the kind, "No , we need IO for this stuff, we can't go with Haskell"
20:52:13 <SyntaxNinja> araujo: I know what you mean.
20:52:33 <hyrax42> what's the project?
20:52:35 <SyntaxNinja> araujo: but I disagree that it's an academic task... it's really just some hacking, although I admit that I haven't looked closely.
20:55:34 <araujo> SyntaxNinja, you wrote halfs?
20:55:52 <SyntaxNinja> hyrax42: http://hackage.haskell.org/trac/summer-of-code/ticket/1
20:56:05 <SyntaxNinja> araujo: mostly.
20:56:13 <hyrax42> oh thanks..
20:56:24 <araujo> cool
20:56:53 <araujo> hyrax42, go and take it!
20:56:54 <araujo> :-)
20:57:01 <hyrax42> hmmm
20:57:06 <hyrax42> I know ~0 haskell
20:57:12 <araujo> :-(
20:57:13 <hyrax42> it's my summer project
20:57:16 <hyrax42> to learn
20:57:24 <araujo> Cool!
20:57:30 <hyrax42> possibly by going through eopl in haskell
20:57:52 <araujo> haskell.org got pretty much what sokmebody needs to start learning Haskell ....
20:57:58 <araujo> And i recommend Bird's book
20:58:02 <hyrax42> not sure if that would be a recommendable thing to do
20:58:10 <SyntaxNinja> araujo: i'm isaac jones
20:58:45 <SyntaxNinja> xerox, xerox_ you around?
20:58:45 <araujo> SyntaxNinja, yeah, i see :-)
21:00:08 <tuxplorer> kzm, are u there?
21:02:51 <dons>  araujo who says you can't do IO in Haskell? we've been doing it for 15 years...
21:03:19 <tuxplorer> hi dons
21:03:21 <dons> I mean, how do they think ghc writes out asm?
21:03:24 * dons boggles
21:03:28 <dons> hey tuxplorer 
21:03:47 <hyrax42> I thoght ghc compiled via c
21:03:47 <araujo> dons, haha, i know, it's *stupid* , but ive met people answering me that when i recommend Haskell
21:03:53 <dons> and asm
21:04:05 <hyrax42> that I did not know
21:04:16 <hyrax42> x86 only? or on PPC too
21:04:23 <Cale> PPC too
21:04:26 <Cale> there's also a .NET backend, but I think that's broken
21:04:30 <hyrax42> hm
21:04:39 <SyntaxNinja> dons: I've heard the same thing.
21:04:43 <dons> it has a native code generator, often faster than going via C
21:04:45 <dons> and sparc and alpha.
21:04:50 <hyrax42> well all I remember is that building ghc out of darwinports took for-bloody-ever and was using cc a lot
21:04:51 <dons> legacy of read/show in hugs...
21:04:59 <SyntaxNinja> dons: from smart people too. "so... not to sound stupid... but what good is a language where you can't do IO?"
21:05:25 <dancor> what's the best way to get a perl-like regex split function
21:05:29 <hyrax42> wait I iddn't just say that
21:05:31 <dons> its frustrating how myths emerge, and then perpetuate themselves
21:05:42 <hyrax42> lisp is only good for ai
21:05:48 <mauke> lisp is slow because it's interpreted
21:05:51 <araujo> SyntaxNinja, haha
21:05:54 <SyntaxNinja> hyrax42: good example.  lisp isn't good at anything ;)
21:05:59 <hyrax42> haah
21:06:02 <dancor> standard haskell regex support has eluded me
21:06:06 <dancor> seems important
21:06:40 <hyrax42> is it possible to have an interactive environment with a pure/statically typed language like haskell?
21:06:50 <hyrax42> i.e. as you get in lisps/smalltalks
21:06:54 <dons> > 1+2 -- yes.
21:06:55 <lambdabot> 3
21:06:57 <araujo> hyrax42, sure!!
21:07:02 <Cale> dancor: well, there's some stuff in the Hierarchy for it
21:07:16 <Cale> but there are better libraries for it which don't come with GHC or Hugs
21:07:23 <dons> hyrax42: its more about having an interpreter, than anything to do with the type system or side-effectiveness
21:07:28 <hyrax42> hs-plugins
21:07:29 <hyrax42> ?
21:07:35 <dancor> Cale: what's the best
21:07:47 <Cale> JRegex gives you an operator which is like perl's matcher, only more powerful
21:08:03 <Cale> there are some libraries based on Parsec which are quite efficient
21:08:19 <dancor> Cale: and by best i mean most like perl/python :)  i wouldn't mind some beyond-string generallity
21:08:21 <Cale> (and other parser combinators)
21:08:40 <hyrax42> well what I'm thinkign is how in say openmcl you can build up a program defun by defun
21:08:44 <Cale> But usually if I have to parse something in Haskell, I wouldn't use a regex.
21:08:52 <Cale> I'd just write a Parsec parser.
21:09:24 <hyrax42> communicating with the live/running system
21:09:25 <dancor> Cale: i'll look into this parsec..  i'm just doing some comma-separated-values stuff, but i like to keep things easy and general
21:09:26 <Cale> (or maybe ReadP, or another library like that, depending on my mood)
21:09:45 <hyrax42> so somehting like slime would be possible for a haskell system?
21:10:15 <Cale> You get nice parsers with meaningful error messages on failure with very little effort, which can generate arbitrary datastructures as they parse.
21:10:56 <hyrax42> I'm really looking forward to playing wiht parsec
21:11:06 <araujo> parsec is sweet
21:11:11 <hyrax42> but must learn a bit more general haskell first
21:11:29 <araujo> hyrax42, are you reading some tutorial?
21:11:32 <hyrax42> but I was thinking if I was doing eopl in haskell to use parsec to do the parsing that sllgen does there
21:11:34 <araujo> book?
21:11:35 <hyrax42> not yet
21:11:40 <hyrax42> starting tuesday p'raps
21:12:07 <hyrax42> still have an exam left
21:12:10 <cmarcelo> araujo: just curious.. where are you from?
21:12:12 <Cale> the only problem with parsec specifically (though other libraries get rid of that problem) is that it can be annoying to phrase your parser so as to be LL(1). Parsec can generalise to LL(infinity), but at the cost of some performance.
21:12:26 <araujo> hyrax42, http://www.haskell.org/haskellwiki/Books_and_tutorials#Tutorials_and_books
21:12:30 <araujo> i like the first two
21:12:43 <hyrax42> oh don't worry, I'm well aware of all the sources for info :p
21:12:45 <araujo> cmarcelo, venezuela, and you?
21:13:04 <hyrax42> Yet Another Haskell Tutorial is the one I'll be starting with
21:13:16 <araujo> yeah, that's a good one
21:13:22 <Cale> hyrax42: good choice, yeah
21:13:48 <hyrax42> I've read through a bit of it, but it counted as procrastination from exams
21:14:53 <cmarcelo> araujo: Brasil..  I asked because Araujo is a common last name here.. =)
21:15:07 <araujo> cmarcelo, yeah, that's what ive heard :-)
21:15:26 <araujo> cmarcelo, i also see, marcelo (is that your name?) is kind of common there right?
21:17:16 <dancor> is there support for the readline library in haskell
21:17:39 <dons> @hoogle Readline
21:17:39 <lambdabot> System.Console.Readline :: module
21:17:39 <lambdabot> System.Console.Readline.readline :: String -> IO (Maybe String)
21:17:39 <lambdabot> System.Console.Readline.setReadlineName :: String -> IO ()
21:17:43 <dons> yes :)
21:18:19 <SyntaxNinja> @hoogle Halfs
21:18:21 <lambdabot> No matches found
21:18:27 <cmarcelo> araujo: my first name is "caio marcelo", its "composite" like "joao pedro"... but marcelo only is very common...
21:18:30 <SyntaxNinja> bah. when will it get into the standard?!
21:18:31 <araujo> dancor, yes
21:18:33 <hyrax42> Maybe is a monad, yes?
21:18:40 <dons> hehe
21:18:50 <gzl> yes it is
21:18:55 <hyrax42> ok
21:19:03 <hyrax42> then what is join for Maybe
21:19:04 <dancor> dons: what does hoogle do
21:19:06 <araujo> SyntaxNinja, Let's get it into House!!! 
21:19:22 <dons> ?wiki Hoogle
21:19:23 <dancor> @hoogle hoogle
21:19:23 <lambdabot> http://www.haskell.org/haskellwiki/Hoogle
21:19:23 <lambdabot> No matches found
21:19:28 <dons> best explanation there, dancor ^^
21:19:30 <araujo> cmarcelo, i see :-)
21:19:30 <hyrax42> or bind for that matter, but I'm still not comfortable with bind
21:19:41 <SyntaxNinja> araujo: :)
21:20:03 <hyrax42> hoogle is pretty sweet
21:20:05 <skew> hyrax42: procrastinating from exams is some of the best motivation for learning stuff
21:20:11 <hyrax42> yeah I know :(
21:20:31 <skew> the trick is not to study for them
21:20:35 <SyntaxNinja> dcoutts: alive?
21:20:39 <gzl> hyrax42: Nothing >>= f = Nothing, (Just x) >>= f = f x
21:21:00 <hyrax42> Just f x?
21:21:15 <gzl> I don't understand the question.
21:21:20 <hyrax42> rather than umm just f x
21:21:27 <gzl> no, it's f x
21:21:27 <skew> if you learn more during the term to make up for that, you have plenty of free time to learn stuff
21:21:38 <hyrax42> or hm
21:21:41 <gzl> when talking about Maybe be careful not to use the English 'just' in an ambiguous way. :)
21:21:41 <hyrax42> @type (>>=)
21:21:43 <lambdabot> forall (m :: * -> *) b a.
21:21:43 <lambdabot>    (Monad m) =>
21:21:43 <lambdabot>    m a -> (a -> m b) -> m b
21:21:51 <hyrax42> ok my bad
21:22:10 <skew> even before you count thing things that your professors decide to teach you on the exam, by having you work it out for yourself.
21:22:47 <SyntaxNinja> no one is alive :(
21:22:53 <hyrax42> well the exam is monday and I'm not in such a great position as that :(
21:23:18 <hyrax42> probability, and apparently I can't count
21:24:05 <hyrax42> well I should get to bed
21:24:10 <hyrax42> @commands
21:24:11 <lambdabot> Unknown command, try @list
21:24:13 <hyrax42> @list
21:24:14 <lambdabot> list [module|command]. Where modules is one of:
21:24:14 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
21:24:14 <lambdabot> unlambda version vixen where
21:24:34 <hyrax42> can I make lambdabot only talk to me and not clutter up channel?
21:24:40 <dons> yes. /msg
21:24:57 <dons> i.e. /msg lambdabot Hey there.
21:25:05 <hyrax42> I got it thanks
21:25:06 <dons> or, you can install it locally. 
21:25:55 <dons> (locally, its just a command line app)
21:26:00 <hyrax42> oh well I want to teach it my local time
21:26:01 <hyrax42> is all
21:26:14 <hyrax42> and possibly register if you do that on this bot
21:26:26 <dons> teach it your local time??
21:26:34 <dons> @localtime hyrax42
21:26:36 <lambdabot> Local time for hyrax42 is Sun Apr 30 00:26:14 2006
21:26:49 <gzl> hyrax42: it's not (Just x) >>= f = Just (f x) because f already produces a Maybe
21:26:50 <hyrax42> ah
21:27:02 <dons> it already knows!!
21:27:06 <hyrax42> yes I just read that it uses ctcp ping for that
21:27:15 <hyrax42> and gzl thanks
21:28:19 <dancor> when would readline return Nothing?  sorry is there documentation, nothing from hoogle
21:28:26 <hyrax42> so does join have any meaning in Maybe?
21:28:57 <hyrax42> (I'm working limited understanding from reading Monads as Containers, the first half)
21:30:45 <olliej> dcoutts_: can now compile sequence, though I have no idea whether the code will actually work
21:30:52 <skew> join :: m (m a) -> m a
21:30:55 <hyrax42> ok
21:30:59 * hyrax42 -> bed
21:31:11 <skew> join a = a >>= id
21:31:44 <hyrax42> @type (>>=)
21:31:46 <lambdabot> forall (m :: * -> *) b a.
21:31:46 <lambdabot>    (Monad m) =>
21:31:46 <lambdabot>    m a -> (a -> m b) -> m b
21:31:58 <Cale> > join (Just (Just 5))
21:31:59 <lambdabot> Just 5
21:32:07 <Cale> > join (Just Nothing)
21:32:08 <lambdabot> Add a type signature
21:32:09 <hyrax42> or I could've tried that
21:32:17 <hyrax42> !
21:32:17 <Cale> > join (Just Nothing) :: Maybe Integer
21:32:19 <lambdabot> Nothing
21:32:25 <hyrax42> ok that's my best guess at what it did
21:32:31 <hyrax42> but wasn't sure
21:32:59 <hyrax42> id is Eq a => a -> a?
21:33:01 <dancor> why does ghc need Text.ParserCombinator. but runhugs is fine with Parsec?  how do i know what i need
21:33:01 <hyrax42> @type id
21:33:02 <lambdabot> forall a. a -> a
21:33:16 <hyrax42> oh right not even Eq is necesssary I suppose
21:33:59 <hyrax42> > (Just (Just 5)) >>= id
21:34:00 <lambdabot> Just 5
21:34:09 <hyrax42> ok
21:34:12 <hyrax42> night all
21:34:13 <hyrax42> and thanks
21:35:28 <Cale> 'night
21:36:45 <Cale> dancor: Well, for ghc, the libraries will be identical to the documentation at http://www.haskell.org/ghc/docs/latest/html/libraries/
21:37:12 <Cale> but for hugs, modules might move around a bit -- I'm not sure where that's documented
21:37:48 <dancor> cool, i'll stick with ghc
21:37:48 <Cale> Most of them should be in the same place if they're there at all, I guess Parsec is an exception to that.
21:39:45 <dancor> so i have [import System] for getArgs.  looks like i need a separate [import System.Console.Readline], you only get at that level?
21:40:03 <Cale> right
21:40:27 <Cale> unless System was to reexport things from System.Console.Readline
21:40:34 <Cale> (I don't think it does)
21:40:49 <dancor> why does [import Maybe] get me Data.Maybe?
21:41:14 <Cale> well, Maybe is there too -- the H98 standard defines a bunch of modules
21:41:22 <Cale> and Maybe is one of those
21:41:51 <dancor> so this is a H98 compatibility thing
21:41:55 <Cale> almost certainly in the next Haskell standard, they'll be moved to their new locations
21:41:56 <Cale> yeah
21:44:29 <dons> I think hugs and ghc will be almost identical.
21:44:38 <dons> certainly wrt. things in the base libs
21:44:50 <dons> i noticed very few differences even in yhc
21:45:00 <dons> (i.e. their bracket is in System.IO)
22:21:33 <dancor> hm it seems hard to skip final whitespace in values with parsec
22:21:48 <dancor> maybe i should just trim afterward
22:29:07 <palomer> > [[1,2],[3,4]] >>= id
22:29:09 <lambdabot> [1,2,3,4]
22:29:27 <palomer> @pl \x -> x >>= id
22:29:27 <lambdabot> join
22:30:14 <lispy> haha, now i remember how i discovered join
22:31:08 <lispy> i remember saying that something or another seemed really common and i wondered why it wasn't standard...i had 'rediscovered' join....now if only i could remember what it was that i thought was a common pattern
22:31:33 <lispy> > join [[1,2],[3,4]]
22:31:34 <lambdabot> [1,2,3,4]
22:31:57 <lispy> concatMap id [[1,2],[3,4]]
22:32:05 <lispy> > concatMap id [[1,2],[3,4]]
22:32:07 <lambdabot> [1,2,3,4]
22:32:20 <lispy> @pl \x -> concatMap id
22:32:21 <lambdabot> const join
22:32:33 <lispy> er...given my typo that makes sense
22:33:12 <mauke> @pl \f x -> f x x
22:33:13 <lambdabot> join
22:33:43 <lispy> that's join? oh hm...
22:33:45 <palomer> wait...
22:33:46 <lispy> @type join
22:33:47 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
22:33:50 <palomer> that combinator has a normal form?
22:33:56 <palomer> @type \f x -> f x x 
22:33:58 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
22:34:12 * lispy boggles
22:34:35 <mauke> welcome to Monad ((->) a)
22:34:41 <lispy> ah
22:34:42 <palomer> f x = f x x = f x x x = f x x x x
22:34:49 * lispy kicks @pl
22:35:00 <RyanT5000> how do you use do let?
22:35:09 <lispy> RyanT5000: no 'in'
22:35:11 <RyanT5000> also, does my formatting work? the "do let" should be bold
22:35:21 <palomer> it's bold
22:35:28 <RyanT5000> cool
22:35:28 <lispy> yeah, it's bold
22:35:34 <palomer> though if anyone here is using a console based irc client, they'll get mad
22:35:45 <lispy> > do let x = 3; return x
22:35:45 <RyanT5000> ah, will it actually be ugly?
22:35:46 <lambdabot>  parse error (possibly incorrect indentation)
22:35:55 <RyanT5000> or will it just not be bold
22:36:06 <lispy> palomer: i'm not mad (or angry) and i'm on a console :)
22:36:10 <mauke> I use a console client and it's bold
22:36:49 <RyanT5000> it's giving me an error: "the last statement in a 'do' construct must be an expression"
22:37:10 <RyanT5000> >do { let x = 3; x }
22:37:15 <RyanT5000> > do { let x = 3; x }
22:37:16 <lambdabot>  parse error on input `}'
22:37:32 <RyanT5000> > do { let x = 3; return x }
22:37:33 <lambdabot>  parse error on input `}'
22:37:38 <RyanT5000> ?
22:37:55 <palomer> > do { let {x=3}; x }
22:37:56 <lambdabot>  add an instance declaration for (Num (t t1))
22:37:56 <lambdabot>   In the definition of `x': x = 3
22:37:56 <lambdabot>   In the definition of `zkf':
22:38:03 <RyanT5000> ah
22:38:04 <palomer> > zkf
22:38:05 <lambdabot>  Not in scope: `zkf'
22:38:20 <palomer> if we try random variable names, we might hit v !
22:38:31 <mauke> > do { let {x = 3}; return x }
22:38:32 <lambdabot>  add an instance declaration for (Show (m a))
22:39:07 <palomer> pick your monad, bucko
22:39:46 <sjanssen> > 1 / 26 ^ 3
22:39:48 <lambdabot> 5.689576695493855e-5
22:40:00 <sjanssen> palomer: pretty good odds if you ask me
22:40:12 <palomer> let's get working!
22:40:53 <palomer> > do { let {x=3}; x } -- I don't get this error message
22:40:54 <lambdabot>  add an instance declaration for (Num (t t1))
22:40:54 <lambdabot>   In the definition of `x': x = 3
22:40:54 <lambdabot>   In the definition of `ewc':
22:41:22 <palomer> why is it asking us for an istance declaration for (Num (t t1)) ?
22:41:53 <mauke> > do 3
22:41:54 <lambdabot>  add an instance declaration for (Num (t t1))
22:41:54 <lambdabot>   In the result of a 'do' expression: 3
22:41:54 <lambdabot>   In the definition of `aru': aru = do 3
22:42:09 <sjanssen> palomer: assigning x to a numeric constant means that x is Num a, right?
22:42:26 <sjanssen> palomer: then writing x in the do means that x must be a monad
22:43:07 <sjanssen> and we need something of kind * -> *
22:43:14 <palomer> right, so it should ask us for an instance declaration for (Num a => Monad a)
22:43:19 <sjanssen> because monads must be that
22:43:48 <sjanssen> palomer: nope, because we're saying that x is the monad and the number
22:43:52 <palomer> so it should give us a kind error
22:44:12 <sjanssen> palomer: why should it give us a kind error?
22:44:51 <palomer> because x is a Num
22:44:57 <palomer> or, rather, let's work with
22:44:58 <mauke> ah, it wants an instance for (Num (m a))
22:44:59 <palomer> > do 3
22:45:00 <lambdabot>  add an instance declaration for (Num (t t1))
22:45:00 <lambdabot>   In the result of a 'do' expression: 3
22:45:00 <lambdabot>   In the definition of `umr': umr = do 3
22:45:15 <palomer> oh, is that it?
22:45:24 <palomer> why doesn't it say so
22:45:40 <sjanssen> thats what Num (t t1) means
22:45:42 <palomer> Monad m => (Num (m t1)) <--this should be the error message
22:46:02 <sjanssen> lambdabot cuts out part of the error message
22:46:27 <palomer> ghci gives the same thing
22:46:32 <sjanssen> yeah
22:47:10 <palomer> I guess it asks us for the more general declaration
22:48:43 <sjanssen> palomer: by the way, if you write "f :: (Monad m, Num (m a)) => m a; f = do 3" it typechecks
22:49:54 <sjanssen> is this monomorphism rearing it's ugly head?
22:50:05 <dancor> when i compile lambabot it does [ghc -package posix ...] and i get [ghc-6.4.1: unknown package:plugins], what's that all about
22:50:24 <sjanssen> or just a subtlety with typeclasses?
22:50:35 <mauke> @type do 3
22:50:36 <lambdabot> forall (t :: * -> *) t1. (Num (t t1), Monad t) => t t1
22:50:52 <mauke> well, as long as you don't try to use it
22:51:46 <sjanssen> mauke: without -fglasgow-exts it won't typecheck
22:51:55 <palomer> maybe that's it?
22:52:12 <sjanssen> -fnomonomorphism-restriction does it too
22:52:24 <audreyt> @seen dons
22:52:25 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 7 minutes and 25 seconds ago.
22:52:36 <audreyt> fps's "cbits" segfaults here in "minimum" :/
22:52:37 <sjanssen> -fnomonomorphism-restriction has to be the most annoying flag to type in history
22:52:58 <gzl> haha
22:54:14 <lispy> heh
22:54:41 <SyntaxNinja> actually, nomonom is fun to type
22:54:55 <dancor> maybe i need hs-plugins
22:55:19 <lispy> nomonom looks japanese to me
22:55:22 <dancor> basically you can't build any of dons stuff without everything else
22:55:37 <lispy> dancor: hehe
22:55:43 <SyntaxNinja> build-depends: dons
22:55:48 <dons> audreyt, yes.
22:55:54 <lispy> dancor: but, you have to admit he has a lot of coolcode.
22:55:55 <dons> hmm :(
22:55:57 <SyntaxNinja> hey audreyt!
22:56:00 <sjanssen> oh, I guess there's a hyphen between no and mono
22:56:02 <dons> that's bizarre.
22:56:28 <dancor> lispy: yes and i finally get to use darcs
22:56:37 <dons> audreyt, do you use hGetLine ?
22:56:44 <dons> (there was a bug in hGetLine I fixed yesterday)
22:57:25 <dons> dancor, you using the darcs version of lambdabot?
22:57:35 <dons> audreyt: more info!!
22:58:57 <SyntaxNinja> dons: relax, audreyt is probably crossing the street or something and needs to get to the other side before replying to you.
22:59:02 <dancor> dons, i'm trying to build lambabot from your webpage, yeh i did [darcs get --partial http://www.cse.unsw.edu.au/~dons/lambdabot]
22:59:09 * SyntaxNinja (has seen audreyt hack and walk at the same time)
22:59:16 <lispy> SyntaxNinja: is that based on something?
22:59:33 <dons> SyntaxNinja: hehe true.
22:59:44 <dons> dancor, is it failing when building runplugs?
22:59:58 <dons> (which is to be expected. since you need hs-plugins for that, but not for anything else)
23:00:17 <audreyt> dons: yes, I use hGetLine as well as readline
23:00:26 <dons> Data.ByteString.hGetLine ?
23:00:28 <dancor> dons: not anymore
23:00:38 <audreyt> er, no, not that
23:00:43 <dancor> dons: yeh i grabbed hs-plugins
23:01:10 <dons> audreyt: ok, then could you perhaps try the haskell 'minimum' that's currently commented out in the ByteString.hs src? 
23:01:19 <dons> and also perhaps run tests/Quick.hs ..
23:01:26 <audreyt> dons: the haskell 'minimum' works
23:01:42 <dons> do the quickcheck tests pass?
23:01:44 <audreyt> it's not commented out
23:01:52 <audreyt> it's in the non-cbits part of cpp
23:02:15 <dons> ah. older version than my darcs copy :)
23:02:45 <dancor> dons: it works great now.  after it failed when i didn't have hs-plugin, i had the executable but it always exited immediately upon running.  don't know if the documentation is misleading saying you don't need hs-plugin or if i'm just no good at building.
23:02:50 <audreyt> heh, it's but 1 day old
23:02:57 <dons> is it possible you build a custom bytestring with the wrong length somehow?
23:03:30 <dons> hmm. but if the Haskell minimum works. very puzzling.
23:04:01 <dons> please try the tests/Quick.hs, then I'll proceed from there.
23:04:56 <audreyt> I'm trying out trunk (fps.6) 
23:06:38 <dons> yeah, looking at the code, I can only suspect that something else is building a strange bytestring. or the compiler is playing games (liberate-case-threshold has been known to break things), or its an unkown unknown.
23:06:48 <audreyt> (the earlier reports are against 0.5)
23:06:52 <dons> right.
23:06:55 <audreyt> building pugs against .6 now, a sec
23:09:12 <audreyt> mmapFile gone?
23:09:59 <audreyt> is .cabal.mmap doing anything differently now then?
23:10:16 <dons> until I can make it portable. 0.6 is in sync with the ghc 6.6. ByteString
23:10:26 <dons> so no mmapFile until then
23:10:36 <audreyt> understood
23:10:38 * audreyt chases the churn
23:10:56 <dons> it would have to be System.Posix.Mmap anyway
23:11:09 <audreyt> yeah
23:11:14 <audreyt> jue likst the gz
23:11:18 <dons> yup
23:11:19 <audreyt> s/likst/like/
23:11:47 <dons> the api should settle down now that i've pushed into fptools.
23:12:05 <audreyt> yay.
23:12:17 * audreyt ponders Char16.
23:12:35 <lispy> dons: i have to say, i think mmap is only good on fixed size buffers
23:12:41 <lispy> dons: the way darcs uses mmap is bad
23:13:01 <dons> lispy, ah interesting. I found good for some h4sh functions. elsewhere not much difference
23:13:15 <dons> (h4sh copies things around the filesystem)
23:13:52 <lispy> dons: i think if you usea bounded physical ram buffer and just keep mmap'ing into that you'll be okay.  but when you are willing to mmap arbitrary sized chunk of files you're shooting yourself in the foot
23:14:00 <lispy> dons: yeah h4sh is cool
23:18:24 <sjanssen> lispy: what is bad about mmap'ing the entire file?
23:20:24 <lispy> sjanssen: it's doomed to fail on large files
23:20:49 <lispy> and if it doesn't fail it will have worse performance than other strategies (and performance was the point)
23:35:12 <audreyt> dons: 0.6 worked Just Fine.
23:35:19 <dons> huh.
23:35:25 * dons is happy
23:35:29 <audreyt> I have no idea what is causing the segfault :/
23:35:34 <audreyt> or rather, was.
23:35:40 <audreyt> maybe -threaded?
23:36:20 <dons> shouldn't do it. almost always the cause has been passing non-null terminated strs to C funs. or somehwo getting the length wrong when rolling your own string from Ptrs
23:36:32 <dons> and you don't do stuff like that?
23:37:47 <sethk> audreyt, I've been using -threaded extensively.  The only time I had a seg fault was when I used an unsafePerformIO, and mucked it up
23:38:33 <audreyt> I don't do the latter
23:38:45 <audreyt> but it is possible to have null bytes in the Ptr
23:38:50 <sethk> audreyt, good, but my point was that threaded, per se, doesn't cause seg faults
23:38:54 <audreyt> I thought the point of ByteString is that null bytes are okay
23:39:59 <sethk> audreyt, dons was talking about using strings with FFI and sending strings to C functions.  I don't think he meant that there is a problem with null bytes in ByteString, per se
23:40:17 <audreyt> I understand.
23:40:25 <audreyt> in any case, it's no longer manifesting
23:40:54 <sethk> could be lots of other things, of course, the string terminator is just an example.
23:41:13 <audreyt> (brb)
23:41:51 <sethk> I had some software recently that started behaving strangely.  this stuff had been, quite literally, running fine for years, and I'd recompiled it with a newer version of the compiler.  So I said, well, obviously there's something wrong with this version of the compiler.
23:42:10 <sethk> the problem was, there was something wrong with the earlier version of the compiler, and it just happen to mask this particular error.
23:42:26 <sethk> it's dangerous to infer, especially where c code is involved.
23:42:48 <sethk> ok, now let's see if the code I wrote today works.  :)
23:43:12 <RyanT5000> what is the "as" keyword?
23:43:28 <sethk> RyanT5000, as in import X as Y
23:43:30 <sjanssen> import qualified Data.Map as Map
23:43:41 <sjanssen> then I can use Map.insert
23:43:41 <RyanT5000> ah ok
23:43:46 <RyanT5000> yeah i use that all the time :P
23:43:48 <RyanT5000> i just forgot
23:43:56 <RyanT5000> i was thinking "why is this blue?"
23:44:10 <mauke> vim?
23:44:14 <RyanT5000> visual haskell
23:44:32 <sethk> purple in vim
23:44:38 <sjanssen> RyanT5000: you can use "as" as an identifier, if you want
23:44:41 <sethk> although vim colors vary with settings
23:45:18 <mauke> it's blue here; purple is for constants
23:45:38 <sethk> mauke, I'm using color scheme "koeler"
23:45:49 <sethk> koehler, sorry
23:45:54 <RyanT5000> sjanssen: actually the identifier in question is "assoc"
23:46:00 <sethk> there it's purple on a black background
23:46:05 <mauke> ... on a light background
23:46:23 <mauke> fix your bg setting
23:46:24 <sjanssen> RyanT5000: and the "as" in assoc is a different color?
23:46:46 <sethk> vim and emacs are both smarter than that
23:47:00 <RyanT5000> sjanssen: nope, just flashed as i typed it :)
23:47:24 <sethk> vim does that also.  it's disconcerting
23:47:34 <RyanT5000> meh, i don't mind, i just forgot what the as keyword was for :)
23:47:43 <sethk> just as your mind registers that the color changed, it changes back
23:47:51 <RyanT5000> yeah
23:47:57 <RyanT5000> but i don't know that there's a better way to do it
23:48:10 <mauke> sethk: seriously, I think your bg is wrong
23:48:16 <RyanT5000> maybe wait .4 seconds or however long it normally takes to type the next 2 or three characters ?
23:48:28 <sethk> mauke, you don't like black background?
23:48:41 <mauke> I'm talking about vim's bg option, not the actual background
23:48:48 <mauke> what does :set bg? say?
23:48:50 <sethk> mauke, although I just changed it to white, and my "as" is still purple
23:49:03 <sethk> mauke, oh, I change that frequently; I can't decide which I prefer
23:49:31 <mauke> eh, it's meant to reflect the background color of your terminal
23:49:37 <sethk> yes, I know
23:49:55 <sethk> I put a set bg=dark in my .vimrc for black background
23:55:17 <RyanT5000> is there an instance of Array that never actually makes the array? i.e.: is just used for the associative list and bounds
23:55:33 <sjanssen> RyanT5000: no
23:55:52 <RyanT5000> (technically i meant an instance of IArray, since that's the class)
23:56:27 <RyanT5000> alright, so i'll just have to go with (Int, [a])
23:56:55 <sethk> RyanT5000, nothing wrong with that.  Or you could make a data Whatever
23:56:59 <RyanT5000> yeah
23:57:04 <dons> audreyt, yeah, sethk got it. the point about null bytes is that if you decide to pass the bytestring to a C function that expects a null byte at the end, there better be one. you need a proof of that somewhere (i.e. you added one, or it isn't a 'sliced' substring)
