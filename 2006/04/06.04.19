00:23:39 <dons> 29834 dons      18   0 2683m 1.8g  752 D  6.0 92.6   5:23.42 bench
00:23:42 <dons> scary
00:23:54 <alar> @join #haskell_ru
00:23:54 <lambdabot> Not enough privileges
00:24:00 <alar> .Ó˘¯Ú πÙ˚ÎÛ‰‰_Í„
00:24:01 <dons> ah!
00:24:09 <dons> @join #haskell_ru
00:24:11 <dons> :)
00:24:23 <alar> @karma+ dons
00:24:23 <lambdabot> dons's karma raised to 27.
00:24:28 <dons> alar, should I add it to the list of #haskell channels on this page:
00:24:33 <dons> ?wiki IRC_channel
00:24:33 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
00:24:40 <dons> or you can, if you like
00:24:42 <alar> that would be nice
00:24:52 <dons> adding.
00:41:38 * shapr boings
00:41:54 <Muad_Dibber> morning shapr 
00:42:37 <shapr> hiya!
00:42:43 <cge> hello
00:42:52 <shapr> Good morning #haskell!
00:43:40 <dons> Good morning shapr!
00:43:56 <shapr> g'day dons, howza?
00:44:32 <dons> good good. just benchmarking fps ready for a new release
00:44:35 <dons> much faster !
00:44:40 <shapr> spiffy!
00:45:06 <dons> and finally we have some stats aginst the old PackedString, [Char] and SimonM's unicode packedstring
00:45:52 <shapr> Oh, what're the numbers like?
00:46:30 <dons> oh, very good. I think fps is faster in all but a couple of funny ones where [Char] wins through sharing
00:47:18 <dons> i'll send out the full stats log when I release in an hour or two
00:47:35 <shapr> cool
00:47:37 <dons> but, e.g. on a 20M string: 
00:47:43 <dons>                 FPS     SPS     PS      [a]
00:47:52 <dons> drop            0.000   0.000   11.730  0.131   
00:47:52 <dons> takeWhile       0.000   1.513   0.000   0.000   
00:47:52 <dons> dropWhile       0.000   2.001   8.453   0.130   
00:47:52 <dons> span            0.000   9.322   11.206  0.130   
00:47:52 <dons> break           0.000   9.307   11.275  0.132 
00:48:03 <dons> where SPS is simons. and PS is the old lib
00:48:25 <dons> map             2.693    2.936  4.853   7.500
00:48:29 <dons> etc.
00:49:06 <dons> it doesn't measure space though. which is one of the key reasons to use fps in the first place
00:49:11 <dons> i wonder how i can script that up.
00:57:29 <dons> hmm. if you have to sort a 20M string. looks like fps is the only way to do it practically.
01:00:35 <shapr> FPS sounds perfect for bittorrent.
01:01:41 <bolrod> well get crackin' then !
01:01:42 <bolrod> :]
01:02:40 <bolrod> a command line torrent client?
01:03:22 <Lemmih> Great idea. Perhaps we could name it Conjure or like that.
01:03:38 <dons> hehe
01:04:11 <shapr> Lemmih: Oh, excellent idea :-)
01:04:31 <shapr> Speaking of which, any development on conjure recently?
01:07:35 * shapr tries to build the latest conjure
01:08:14 <Lemmih> (re-development) Not really.
01:10:06 <kolmodin> @where conjure
01:10:07 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
01:16:38 <shapr> dons: What are the most interesting projects in the Haskell world right now?
01:17:15 <dons> hmm. there's so many!
01:17:21 <dons> hard to think of something obvious.
01:17:35 <dons> just this last week we have HAppS, HAlfs and a new linear algrebra library
01:17:39 <shapr> I'm thinking about the Hamming question, "What's the most important research in your field right now?"
01:17:58 <shapr> So I'm wondering, what're the most important projects to the Haskell community right now?
01:18:01 * Lemmih always thinks he's working on the most interesting project (-:
01:18:01 <sethk> dons, did you try compiling from gvim?
01:18:05 <dons> the most important research is being done on type system work related to dependent types, I think.
01:18:09 <shapr> Lemmih: that's the best way to code
01:18:27 <dons> but not sure about the most important projects.
01:18:41 <dons> sethk, not yet.
01:18:44 <sethk> dons, the important projects are the ones you get paid for  :)
01:18:57 <dons> very wise, sethk.
01:18:58 <shapr> I think cabal-get might be the most important project for the community in general.
01:19:11 <dons> yes. i think that's critical infrasstructure.
01:19:22 <sethk> dons, that's just sour grapes because you guys get to choose interesting work more often than we do
01:19:33 <dons> its a possibly make or break tool if we want to get into perl/python mainstreaming
01:20:06 <shapr> Do we want to?
01:20:13 <Lemmih> Good question.
01:20:14 <sethk> dons, which tool are you talking about?
01:20:49 <dons> researchers will continue hackign away at hasekll forever. or until we program in Succ Succ Epigram
01:21:07 <dons> but then we can always gather more users, and create jobs for ourselves..
01:21:09 <dons> in the process.
01:21:22 <tic> Off-topic question.. if you were to have a project and a little blog w/ news for it, would you want to have blog/YYYY/MM/DD/title-of-post, blog/YYYY/MM/DD/N (N = 1 for first post that day, 2 for second, etc.), blog/YYYY/N or just blog/N?
01:21:43 <dons> tic, I got blasted on haskell@ for not using yyyy-mm-dd form
01:21:57 <tic> dons, *nod* what did you use?
01:22:06 <dons> so if you now look at haskell.org news..
01:22:07 <sethk> well, the one that sorts would seem to be a good choice, no?
01:22:14 <tic> dons will do
01:22:37 <shapr> I'd use blog/YYYY/MM/DD/N everytime
01:23:12 <musasabi> morning
01:23:20 <sethk> dons, if you try gvim (I may have already told you this, so sorry if I'm repeating) do :copen before you compile.  That gets you in the right place for the first error.
01:23:39 <sethk> dons, occasionally it seems to lose its place if you do :copen after :make
01:23:48 <tic> shapr, I thought about doing that too, but just now I realized storing the unique ID in the database would be come weird.  should it be stored as the string (e.g.) "2006/04/19/0"?
01:24:35 <tic> s/be come/become
01:25:09 <shapr> I'd probably keep the uid separate from the url.
01:25:20 <tic> shapr, so how would you get at it from an URL?
01:25:29 <shapr> In fact, I'd probably use blog/YYYY/MM/DD/uid instead.
01:26:06 <tic> thought about that too, but eventually you'll end up with, say, blog/2007/02/10/9842
01:26:09 <dons> sethk, but this won't work in normal vim?
01:26:15 <dons> morning musasabi 
01:26:19 <shapr> tic: What's not to like about that?
01:26:20 <sethk> dons, I haven't really tried it, I'm not sure.
01:26:26 <sethk> dons, it might, just without the menus.
01:26:29 <shapr> hyv√§√§ huomenta musasabi!
01:26:35 <sethk> I'll check
01:26:40 <tic> shapr, being in descending order, it kinda looks like that'd be the second or minute or something.
01:27:19 <sethk> dons, on a quick check it works in ordinary vim
01:27:29 <sethk> dons, only I can never remember how to get from one window to the other
01:27:44 <sethk> dons, but I get the compile window and the code window.
01:27:49 <sethk> let me put an error in and see what happens
01:28:04 <sethk> I meant to ask, can ghc output dependencies that can be pulled into a makefile?
01:28:31 <shapr> tic: You could use unix time for the uid and then blog/YYYY/MM/DD/${seconds since midnight}
01:28:49 <eivuokko> sethk, iirc yeah, pretty similary as gcc.
01:29:00 <sethk> eivuokko, thanks
01:29:00 <shapr> I admit though, it does seem like there should be a nice way to make the date and the uid the same thing and useful too.
01:29:09 <tic> shapr, mhm.
01:29:26 <dons> sethk, ^W j and k , isn't it?
01:29:26 <sethk> dons, seems to work fine in ordinary vim also
01:29:31 <dons> to go up and down
01:29:33 <sethk> dons, I think so.
01:29:40 <tic> shapr, I was considering restricting the blog to only one post per day. That should be okay in most cases.
01:29:41 <sethk> dons, right
01:29:48 <tic> shapr, but that doesn't look very nice either.
01:29:56 <sethk> dons, that's logical, window, and then k and j are always up and down (or down and up)
01:30:07 <sethk> dons, but I always forget the ^w.  getting old, I guess
01:30:12 <sethk> dons, but, anyway, seems to work fine
01:30:19 <dons> yep. I then use Alt j k l h for navigating in ion,  the window manager :)
01:30:27 <shapr> tic: That's what PLog uses, and it's pretty irritating.
01:30:37 <tic> shapr, *nod*
01:30:40 <sethk> dons, of course you can't double click on the error and such, but that's to be expected in non-gui mode
01:31:17 <shapr> tic: I'm hacking Oleg's HSXML+RSS into a bloggy thing right now, and I've chosen the incredibly cheesy solution of just making each post a value in a list, and importing new entries :-)
01:31:29 <tic> shapr, heh.
01:31:48 <sethk> dons, hmm, in some ways it's better.  It goes t full screen during compile, then goes back to windows with the error display
01:32:07 <sethk> dons, anyway, both work, which is nice to know
01:32:08 <shapr> I do like Oleg's typesafe html combinators but as musasabi said, the errors are insane.
01:32:13 <dons> ok. now the big test. did fps get faster between v0.1 and v0.2? .. 
01:32:34 <dons> shapr, musasabi very interesting.
01:32:45 <dons> the age old type errors problem
01:33:00 <shapr> I think part of the problem is that the contexts are few and not automatically generated from the DTD.
01:33:21 <tic> shapr, I also believe the post title could be useful having in the URL.
01:33:37 <tic> shapr, blog/YYYY/uid/title-of-post?
01:34:39 <shapr> The contexts are only CT_inline, CT_block, CT_attr, CT_block, and CT_doc. I wonder if it would make for better error messages if each tag had a context, and this info were pulled from the DTD automatically. That would mean you'd be able to 'typecheck' any legal DTD as well.
01:34:51 <musasabi> user/YYYYMMDD-title-of-post
01:35:18 <tic> user == ?
01:35:58 <musasabi> (if you have multiple users - otherwise user==blog)
01:36:04 <tic> Ah, yes.
01:36:12 <musasabi> shapr: I think one easy improvement would be to make GHC to print infix types in infix form, and use HLists with infix types.
01:36:26 <tic> Hm, if I were to make titles unique per day, then blog/YYYY/MM/DD/title-of-post should be okay.
01:36:27 <shapr> Still, the HNil approach makes for totally insane type errors, and I'm still not sure when I need [[p "text"]] or [p "text"]
01:36:31 <musasabi> shapr: that would probably cut 25% of the type error lengths.
01:37:37 <tic> What's the difference (conceptually) between having "News" and "Blog", when it comes to an actual software project?
01:38:30 <Muad_Dibber> News is official news whereas in a Blog discussion can be raised and developers can just rant about things ;)
01:38:34 <musasabi> Blog is more about how and news about what.
01:39:07 <tic> Thanks.. Was thinking about how to name the "talk" section.
01:39:33 <tic> I don't like how Blog looks like in an URL. :) Was thinking log, but that would probably get people confused with a syslog or some such.
01:39:43 <tic> bah, blog it is.  Thanks again!
01:43:35 <dons> tic, yeah, I'd view News as basically press or media releases
01:43:55 <dons> and a blog is just any more personal stuff.  you don't announce new project versions in a blog
01:44:25 <Muad_Dibber> you can do that dons , but not offically announce it :)
01:44:45 <dons> right. "Oh, and today we hit verion 23.5"
01:46:18 <tic> dons, well, how about having the title named "Version 23.5 Released!" in the blog?
01:46:45 <tic> dons, possible tagged as news -- it does't hurt having the news in the blog, too, does it?
01:46:52 <tic> possiblY, that is.
01:54:57 <dons> sure. no harm.
01:55:10 <dons> there are no legal requirements about the matter either way.
01:55:14 <dons> so do what you want! :)
01:55:38 <tic> Oh, this is for a project hosting thingy, I was mostly considering how easy it'd be to use.
01:55:45 <tic> or if it'd make sense.
02:01:51 <sethk> dons, want to take a look at http://paste.ubuntu-nl.org/12541?  My question is whether to do it with a type class, or some other way.  It's a short example.
02:02:28 <dons> hang on a minute. need to get new fps out  the door..
02:02:37 <sethk> dons, no hurry
02:04:38 <sethk> dons, http://paste.ubuntu-nl.org/12542   corrected compilation error  :)
02:06:37 <alar> dons: is there a lambdabot-spawner that starts lambdabot and sends it to a list of channels?
02:06:50 <alar> or you do it by hand?
02:09:06 <sethk> dons, don't bother with that, still correcting errors
02:13:54 <alar> is it possible to make function of type Int->a that depends on a?
02:14:30 <alar> e.g. the function call bitSize a
02:14:41 <Lemmih> Yep.
02:15:34 <alar> Lemmih: what's the syntax? How do I call bitSize a if a is a type, not variable name
02:15:52 <Lemmih> alar: bitSize (undefined :: a)
02:16:08 <alar> thanks!
02:16:19 <alar> @karma+ Lemmih
02:16:19 <lambdabot> Lemmih's karma raised to 15.
02:16:49 <alar> I'm still not used to this ever-helpful fully-polymorphic undefined
02:17:29 <alar> hm
02:17:32 <cge-away> err, what does the karma do?
02:17:54 <alar> is it allowed use type variables inside function body?
02:18:03 <alar> use-> to use
02:19:24 <alar> cge-away: it is a measure of goodness of a person
02:19:38 <alar> @karma alar
02:19:39 <lambdabot> You have a karma of 0
02:20:01 <alar> means I'm not a lot of help to #haskellers
02:21:02 <Lemmih> cge|away: Seen "My Name is Earl"?
02:21:10 <cge|away> Lemmih, no
02:24:42 <dons> ?karma+ alar -- starting #haskell_ru
02:24:42 <lambdabot> alar's karma raised to 1.
02:25:16 <mauke> @karma
02:25:17 <lambdabot> You have a karma of 1
02:26:09 <cge> @karma
02:26:09 <lambdabot> You have a karma of 0
02:26:14 <robokop> @karma
02:26:15 <lambdabot> You have a karma of 0
02:26:21 <shapr> @karma
02:26:22 <lambdabot> You have a karma of 16
02:26:43 * shapr boings happily
02:27:02 <shapr> I know you can get karma points for writing lambdabot plugins.
02:27:15 <mauke> @put-shapr
02:27:15 <lambdabot> shapr!!
02:27:19 <mauke> hmm
02:28:34 <alar> get-shapr == put-shapr ? 
02:29:18 <alar> seems shapr is fixpoint of get/put
02:29:33 <shapr> :: State shapr ?
02:29:58 <shapr> I am not a value! I am a free man!
02:30:02 * shapr misquotes The Prisoner
02:32:37 <bolrod> You're on irc.. you're not free
02:32:41 <sethk> dons, ok, now, http://paste.ubuntu-nl.org/12543
02:32:53 <sethk> or anyone else who might be kind enough to look at a somewhat elementary question
02:33:43 <alar> free? you mean unbound?
02:35:42 <cge> shapr, you aren't free, because new users want INFORMATION about Haskell, and will keep you from leaving.
02:36:04 <Saulzar> sethk, The problem being that you don't want a "QM a"?
02:37:10 <sethk> I do want a QM a, yes
02:37:26 <sethk> Saulzar, I'm just asking what the options are for getting one
02:37:41 <shapr> rjmh: John?
02:38:10 <Saulzar> I don't think I understand the question - can't you use data QM a = Qmvar { mv :: MVar a } ?
02:38:38 <sethk> Saulzar, if that works, then yes
02:38:47 <sethk> no, wait
02:39:02 <sethk> Saulzar, it's not just the MVar a, it's the combination of the QSem and the MVar a
02:39:04 <rjmh> shapr: Hi Shae, just trying to figure out how this works
02:39:20 <shapr> rjmh: Greetings, and welcome to the infinite coffee break. :-)
02:39:22 <sethk> Saulzar, you are saying define QM a, then use that in the data?
02:39:35 * shapr goes to make more coffee
02:39:41 <rjmh> shapr: :-) sadly very finite in my case
02:39:48 <sethk> Saulzar, I can use a type variable there?
02:39:55 <sethk> Saulzar, in that case, it's easy  :)
02:40:04 <Saulzar> (Yes I meant data QM a = Qmvar { mv :: MVar a, qs ... }
02:40:21 <sethk> ok, I didn't know I could use a type variable there without having to define a class
02:40:59 <sethk> Saulzar, then do I use the a in the function definitions as well?
02:41:28 <Saulzar> Yeah, you'd have to if you want it generic
02:43:01 <shapr> Well, that was cool, John Hughes :-)
02:43:05 * shapr is back from making coffee
02:43:11 <tic> where?
02:43:30 <shapr> He was just here for a moment.
02:43:40 <sethk> Saulzar, ok, I'm fine up until tryReadQM. I don't know how to use the 'a', there, because I'm using the constructor in the function prototype
02:44:28 <sethk> Saulzar, but if I take out the signature, it just works  :)
02:44:32 <Saulzar> sethk, You can use a Maybe a
02:45:27 <sethk> right
02:45:28 <sethk> thanks
02:45:42 <alar> why Data.Bitshas {#-f-no-implicit -prelude}
02:45:47 <alar> why Data.Bits has {#-f-no-implicit -prelude}
02:46:03 <sethk> Saulzar, it's 5:45 am here and I haven't slept yet  :)
02:46:11 <shapr> doaitse: Greetings
02:46:20 <alar> {-# OPTIONS -fno-implicit-prelude #-}
02:46:24 <Saulzar> Hehe.
02:46:38 <shapr> Funny, John Hughes was just here.
02:46:56 <alar> I don't understand what is there that conflicts with Prelude
02:47:03 <shapr> doaitse: I'd enjoy discussing arrows versus attribute grammars with you when you have some spare time.
02:47:18 <shapr> If you ever have spare time...
02:48:21 <doaitse> I am just trying to find out how this IRC works
02:49:14 <shapr> Well, here you have lambdabot and a smart and friendly community.
02:49:26 <shapr> > map (+1) [1..5]
02:49:28 <lambdabot> [2,3,4,5,6]
02:49:56 * alar still does not understand how to make function depend on its result type
02:50:05 <shapr> lambdabot has some tools for interactive teaching for newbies, and dons recently added command line usage so people can use it without irc.
02:50:30 <alar> Lemmih: hugs reject my definition
02:50:48 <shapr> doaitse: Simon Marlow and Manuel Chakravarty are here sometimes, and you just missed John Hughes.
02:51:10 <shapr> Wouter Swierstra is here regularly as well.
02:51:34 <doaitse> My first impression is that you can spend a lot of time here
02:51:47 <shapr> Yes, this is the infinite coffee break.
02:52:27 <araujo> morning!
02:52:57 <shapr> doaitse: Most people run irc in the background like an instant messenger and jump into the discussion when they see something that interests them.
02:52:59 * araujo next to write an essay "Stay away from Haskell, unless you wanna hate other programming languages."
02:53:03 <shapr> Or maybe that's just me.
02:53:51 <shapr> There are also channels for stratego, haskell' and language specific channels like #haskell.se and #haskell.it
02:53:53 <Saulzar> Or, run IRC in the background and still need to close it when they really want to do some work.
02:54:42 <shapr> dons (Don Stewart) has the amazing ability to be productive and stay on irc :-)
02:55:40 <shapr> It's pretty calm today, but sometimes there's a veritable storm of conversation.
02:56:21 <shapr> Oh, and #haskell will be five years old in just a few days!
02:57:23 <shapr> Hm, what else to say about #haskell?
02:58:42 <doaitse> I think it is about time to examine 100+ FP first year students this afternoon, and mark the exams before spending too much time here.
02:58:48 <shapr> I'd say this is where the theory and the practice meet. Newbies show up and want to write useful apps, and the experience people here teach just about anything.
02:59:06 <shapr> doaitse: Nice to meet you again (last time was ICFP2003).
02:59:20 <shapr> I have to do work also
02:59:29 * shapr &
03:03:24 <araujo> I just can't get code writte in other language
03:04:29 <araujo> I find so many things annoying which i wasn't aware of before
03:05:01 <alar> =)
03:06:59 <araujo> Before knowgin Haskell, i couldn't conceive a programming language without destructive updates (side effects) for example
03:07:18 <araujo> Now i think it's crazy they actually exist :-P
03:08:00 <alar> Lemmih: ping
03:08:34 <xerox> pa-ching!
03:08:49 <Saulzar> araujo, But they exist in Haskell too...
03:09:49 <araujo> Saulzar, uh?
03:10:51 <araujo> Saulzar, All functions in Haskell are referentially transparent
03:11:23 <xerox> araujo: IORefs and STRefs.
03:11:25 <Saulzar> araujo, Yes, but destructive update is possible with IO or ST :)
03:11:47 <musasabi> araujo: things like unsafePerformIO $ poke someMemoryLocation someValue ?
03:12:12 <araujo> musasabi, *ough* yes
03:12:15 <Saulzar> I think that has to be cheating
03:12:17 <xerox> musasabi got it right.
03:12:20 <araujo> Exactly!
03:12:33 <xerox> Saulzar: I fear it's the other way around.
03:12:49 <Saulzar> Hmm?
03:13:29 <xerox> Saulzar: with IO and ST Refs one is still subjected to the underlying (>>=) sequencing.
03:13:31 <alar> unsafe is cheating
03:13:42 <alar> ST depends on point of view
03:13:45 <araujo> And unsafe....
03:14:02 <alar> it can be destructive upadtes
03:14:09 <xerox> musasabi's code does it as unsafely as C/lisp/whatever does.
03:14:13 <alar> but the other way around, there isn't
03:14:38 <araujo> Because that's the "imperative" way of doing it. (which i was referring to)
03:14:47 <araujo> musasabi, thanks for making it clearer :-)
03:15:39 <Saulzar> xerox, Right, unsafe cheating, Refs not
03:15:57 <xerox> Saulzar: I was sad when I realized it (-:
03:16:53 <xerox> Still, using IORefs makes compiled program work the same as if they were written in presence of mutability at the language level.  It's just a matter of POV, if you want.
03:16:54 <ayrnieu> araujo - do Haskellers hate Erlang?
03:17:26 <araujo> ayrnieu, hah, what kind of quesytion is that? ;-)
03:17:56 <xerox> I hate cucumbers.
03:18:20 <ayrnieu> araujo - the kind of question that occured to me when I first read "Now i think it's crazy they actually exist :-P" and then "next to write an essay 'Stay away from Haskell, unless you wanna hate other programming languages.'"
03:18:21 <musasabi> Erlang is quite nice.
03:19:24 <araujo> ayrnieu, oh, i wouldn't certainly know about Erlang (note i said "other" not "all")
03:19:46 <ayrnieu> oh, OK.
03:19:51 <araujo> :-)
03:22:22 <araujo> But more likely, i would prefer Erlang over (C/Java) which is the thing i need to code too
03:23:01 <zipeng> Is lazy evaluation really useful? I think a language similar(pure and with powerful type systems) to haskell but uses strict evaluation is more pratical.
03:23:17 <shapr> Strict is easier.
03:23:22 <shapr> You don't have to think as much.
03:23:27 <shapr> But it's less flexible.
03:23:48 <mahogny> ok. wxhaskell: I have a statusbar text that disappears when I enter the menus. any good ideas?
03:24:14 <mahogny> also, has anyone considered writing better docs for wxh? the current ones are almost useless unless you already know what you want
03:24:15 <ayrnieu> well, once you have a comfortable family of languages, you can pick and choose among them depending on your task.  Better than picking among your preferred languages and also your despised languages.
03:25:52 <shapr> zipeng: Relevant points are: 1. amortized algorithms a la Okasaki 2. ability to work with and easily traverse infinite and multidimensional data structures 3. coroutine-like problems such as http://c2.com/cgi-bin/wiki?SameFringeProblem
03:26:35 <shapr> Laziness make logic more modular, while performance becomes less modular.
03:26:45 <shapr> (quoting Darius Bacon on that)
03:27:44 <zipeng> thanks, but sometimes lazy is quite confusing.  and we don't need the flexibiltiy most of time.
03:28:03 <shapr> I have a theory that the primary difficulty with laziness is in fact cultural. The current programming culture is totally C-centric, so almost no one knows how to use laziness.
03:28:27 <shapr> zipeng: Yes, but how do you know if you need the flexibility until you've actually used it for something real?
03:28:41 <ayrnieu> zipeng - life is suffering, and so is programming, but you can choose your suffering and you can prefer one over another.  The only important thing is that you not get lost in suicidal dreams, and instead keep living -- and programming.
03:29:08 <mahogny> in my experience, programming is slow death. but that is another story :)
03:29:16 <ayrnieu> mahogny - so is life :-)
03:29:35 <mahogny> ayrnieu, yeah, but in the latter case you really feel it as well :)
03:29:40 <shapr> ayrnieu: How's life? Are you turning your current job into a lifelong career?
03:30:01 <shapr> er, 'current employment'
03:30:50 <ayrnieu> shapr - I don't know, but nothing is ever lifelong -- unless you die doing it.
03:31:18 <tromp> marriage is lifelong
03:31:23 <tromp> in theory:)
03:31:27 <shapr> zipeng: Using lazy evaluation and multidimensional data structures to explore a solution space (ie. search algorithms A*) is very flexible. But it's not at all the imperative approach.
03:31:27 <ayrnieu> tromp - if you die doing it :-)
03:31:30 <zipeng> Is it possible to choose whether using laziness by a compile option?
03:32:22 <shapr> No, non-strict semantics are part of the language definition of Haskell.
03:32:34 <shapr> You can use seq and DeepSeq for somethings.
03:32:41 <ayrnieu> zipeng - such an option would essentially fork the language.
03:32:46 <shapr> Ever heard of weak head normal form?
03:33:39 <shapr> On the other hand, Jan-Willem Maessen had a strict and parallel flavor of Haskell called pH
03:34:03 <zipeng> I don't mean haskell. I just wandering is that possible if we design a new language.
03:34:10 <mahogny> I must say I would have prefered if haskell was undefined in terms of lazyness. better use an equivalent to DeepSeq when lazyness is required. maybe that would be enough to implement what Clean does without messing up the entire syntax
03:34:19 <ayrnieu> (there's also a very Haskell-like language called Q, over at q-lang.sf.net , based on term rewriting semantics.)
03:34:22 <shapr> zipeng: You might like Clean.
03:34:42 <ayrnieu> zipeng - well, what do you want to do?
03:35:04 <shapr> ayrnieu: I guess I was just curious if you'd be changing employers anytime soon.
03:35:07 <zipeng> I don't know. just ask
03:35:19 <xerox> Also, there is Control.Parallels.Strategies which Cale heavily recommends.
03:35:56 <ayrnieu> shapr - ah.  no, not soon.
03:36:03 <shapr> Non-strict is part of the thrill of Haskell for me. I'm still trying to figure out if I can definitively prove to myself that lazy or strict is 'better' in general.
03:36:31 <xerox> shapr: the good thing is that Haskell is both, but lazy in the default setting.
03:36:37 <shapr> So far my tenative conclusion is that non-strict is a lot like emacs, the extra power is worth it if you can afford to invest the time it takes to become comfortable with it.
03:37:34 <zipeng> Yeah, I agree with xerox
03:37:45 <Saulzar> Hmm. Well if you're not aware of it then it does not really make much of a difference, until you look at space/time statistics.
03:37:52 <alar> is it true that one can define polymorphic function f::(AClass a)=> Int-> a only when AClass contains member of type x->a when x is monomorphic?
03:39:08 <ayrnieu> shapr - measures of better that I would suggest are: how much time do I spend one to do what the other gives me?  How much time do I spend making up for consistent mishandlings of one or the other?  How much time do I spend trying to an express a problem with one in mind versus the other?  Also: do my answers change as my experience changes?  If so: how sanely does my experience decay?
03:39:23 <ayrnieu> 'do I spend forcing one to do'
03:39:40 <shapr> forcing one to do?
03:40:26 <xerox> ayrnieu: thinking obsessively about time is constraining.
03:40:28 <shapr> When I'm writing my own code, I tend towards maximum laziness, and it takes me less time to write and debug such code.
03:40:46 <ayrnieu> shapr - memoization and caching came to mind, as an instance where you get these for free from laziness but have to think about them after the fact in strictness.
03:40:47 <shapr> But from the mailing lists, it seems that most users are consistently bitten by laziness.
03:40:58 <ayrnieu> xerox - 'time-wasting', I think you meant to say :-)
03:41:09 <xerox> No, contraining.
03:41:15 <shapr> What do you mean by sanely decaying experience?
03:41:59 <mahogny> I don't really see the point in doing maximum lazyness all the time. how often does it actually give an advantage?
03:42:11 <araujo> always
03:42:19 <mahogny> why?
03:42:32 <ayrnieu> shapr - Perl is an example that came to mind; it's very expressive and very capable, but it's also a huge language that people seem to have trouble keeping, which is the source of people coming back to their code later and not understanding it.
03:42:44 <shapr> I end up building lazy pipelines and passing around infinite multidimensional streams pretty often.
03:43:01 <shapr> ahh! experience decay like that!
03:43:01 <araujo> It will evaluate only the necessary to finish the computation. (any)
03:43:25 <araujo> And, imho, that's *always* good right?
03:43:28 <mahogny> araujo, but in many cases, it does evaluate the whole thing. then it's just wasted effort?
03:43:44 <araujo> uh?
03:44:03 <araujo> I don't see where it is the wasted effort
03:44:05 <shapr> I find it easier to come back to old Haskell code than to old Python code.
03:44:17 <araujo> in comparison, with say, strict evaluation
03:44:28 <shapr> For some of my old Python code, I want to reach back through time and smack myself :-) I had a serious case of OOP addiction.
03:44:30 <ayrnieu> if it evaluates the whole thing, mahogny, then it doesn't matter anyway and the only wasted effort that might happen occurs far away from the programmer.
03:44:57 <mahogny> araujo, there are costs that come with keeping track of lazyness. if you know a whole thing will be evaluated, why bother with lazyness?
03:45:24 <mahogny> my point really is, why need lazyness be part of the semantics for a simple thing like this? why not let the compiler figure it out by itself?
03:45:27 <shapr> Noticing my previous OOP addiction makes me wonder if I might have a laziness or purity addiction even now.
03:45:41 <ayrnieu> mahogny - if it isn't part of the semantics, you can't use it.
03:45:55 <shapr> mahogny: Because algorithms can be defined in a certain way, and then used differently.
03:46:04 <araujo> mahogny, i don't know why you say *many cases*, i think the majority of the code evaluated will take advantage of lazy evaluation
03:46:18 <amiddelk> araujo: a delayed computation might require much more memory than the actual result
03:46:19 <Muad_Dibber> as long as you are not going to become a Lazy, Functional OOP addict shapr  :)
03:46:32 <ayrnieu> mahogny - the same way CL programmers can't write programs that recur instead of iterate, because they don't have guaranteed tail-call (or tail-recursion) optimization.
03:46:39 <mahogny> ayrnieu, but let's say you had something equivalent to seq, "lazy". what would the main argument be against letting the evaluation semantics be unspecified; it can be either lazy or nonlazy?
03:46:50 <musasabi> One of the main problems of laziness is that it makes it hard to 1) isolate errors, 2) reason about space and time usage of code.
03:47:00 <mahogny> if you really need lazyness, you could just toss it in
03:47:09 <ayrnieu> Why does laziness make it hard to isolate errors?
03:47:23 <mahogny> ayrnieu, because the whole thing is executing at once
03:47:33 <musasabi> ayrnieu: because we don't know when we will evaluate the thing causing an error.
03:47:44 <mahogny> at times, that can be a problem. if you do unit checking, it's much of a prob
03:47:46 <araujo> amiddelk, lazyness is not only for "speed", but it is also used for expressing ideas better and imho, more elegant way.
03:47:52 <ayrnieu> mahogny - well, I understand that O'Caml programmers can do that very neatly.  I think they also don't tend to think or write lazily.
03:48:10 <mahogny> ayrnieu, oh. should check that language then
03:48:54 <shapr> iirc, head of a lazy qsort is equivalent to a strict and highly optimized algorithm for finding the minimum item of a list.
03:49:37 <musasabi> ayrnieu: think of a system sending messages between threads. A thread receives a "data Msg = Msg String" and wants log it into a file. There are multiple things that can go wrong with this in Haskell.
03:50:02 <musasabi> ayrnieu: e.g. 1) the string may be infinite, 2) the string may be a bottom, 3) there may be a bottom in the middle of the string.
03:50:19 <mahogny> shapr, isn't that dependent on how you write the qsort in terms of lambda?
03:50:35 <musasabi> Thus the receiver is forced to do all kinds of tricks to check that the message is really valid.
03:51:09 <araujo> > let f = map (\ x -> x * x) [1 ..] in take 20 f
03:51:10 <lambdabot> [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400]
03:51:21 <ayrnieu> And sometimes, if you can express a problem lazily, you have simply won.  Game over :-)  I think that a lazy expression alternative to a function that returns every permutation of a list is an example of this.
03:51:32 <ayrnieu> s/expression //
03:51:33 <araujo> As an example, of what kind of elegance im talking about
03:51:50 <mahogny> musasabi, I dunno if I like that example. I think the needed checks are not very different from what you would have to do in the strict case. but the main thing is, if the receiver code blows, you are in major trouble finding the source
03:51:53 <shapr> mahogny: Well, if it's a lazy qsort...
03:52:22 <shapr> I like the fibonacci example - fib = 0 : 1 : zipWith (+) fib (tail fib)
03:52:28 <shapr> But it's only a single dimension.
03:52:32 <musasabi> mahogny: it becomes quite tedious to check everything "is this finite and does not have a bottom or take too long to evaluate"
03:52:42 <shapr> mahogny: How about a spam filter?
03:52:57 <shapr> Lazy key promotion is quite handy.
03:53:18 <shapr> Or what about searching a string via inits?
03:53:24 <shapr> That's reasonably efficient in Haskell.
03:53:38 <mahogny> musasabi, but those checks need to go in there, even in the strict case. so what is the deal?
03:53:38 <shapr> Though I don't remember the exact code at the moment...
03:53:54 <musasabi> mahogny: very much less checks.
03:54:14 <mahogny> musasabi, doesn't that depend on how you write the code?
03:54:46 <mahogny> well. that example is a bit messy to analyze without knowing more :/
03:54:58 <shapr> If only we could pattern match on infinite (thunk) and bottom :-)
03:54:59 <musasabi> A standard way to say "objects of this datatype must be always fully evaluated" would make things much simpler.
03:55:07 <araujo> shapr, hah
03:56:10 <musasabi> mahogny: if you can trust all the code it is no issue. If you try to design components which work even if other components have bugs, then it is harder.
03:56:33 <mahogny> musasabi, that's completely true
03:56:52 <mahogny> musasabi, the key is unit testing. you are pretty muched forked without it
03:56:58 <mahogny> *-ed
03:57:36 <musasabi> mahogny: does not help if different people write different components.
03:57:56 <araujo> > let fibs@(0:tfib) = 0 : 1 : [ a + b | (a, b) <- zip fibs tfib ] in take 9 fibs
03:57:57 <lambdabot> [0,1,1,2,3,5,8,13,21]
03:57:58 <mahogny> musasabi, you would have to require that they do their job properly. only works if you work for a company though
03:58:13 <musasabi> mahogny: I was using erlang for many things before Haskell, and was accustomed to a simple "this module works whatever garbage you throw at it".
03:58:47 <shapr> Thomas Kuehne has a section on laziness in his thesis - http://c2.com/cgi-bin/wiki?FunctionalPatternSystemForObjectOrientedDesign
03:59:02 <mahogny> musasabi, well. that language was made for that :)
03:59:19 <shapr> I do wish there were some way to ensure that a function can handle infinite values.
03:59:32 <shapr> Or at least know when it cannot.
03:59:38 <ayrnieu> musasabi - although to be fair, simply crashing is a valid and practical response to garbage in Erlang.
04:00:33 <mahogny> that language is indeed the crash survival type, not the crash avoidal type
04:00:49 <shapr> mahogny: I bet QuickCheck beats other flavors of unit testing.
04:01:14 <ayrnieu> mahogny - but if crash avoidance means that you have to anticipate all crashes...
04:01:25 <mahogny> shapr, I prefer hard checks. quickcheck, like any other type of unit test library I have seen recently, is a quick hack
04:01:39 <shapr> I strongly disagree with that.
04:02:00 <shapr> But hey, why discuss when we can code?
04:02:12 <mahogny> it doesn't give you a proof in FOL. I think that is a reasonable requirement
04:02:18 <shapr> heh
04:02:28 <musasabi> ayrnieu: of course, but so is having a supervisor that restarts things.
04:02:33 <shapr> mahogny: Ok, you win =)
04:02:37 <wilx> Boo. No win32 binaries for 6.4.2 yet.
04:02:37 <mahogny> :)
04:02:37 <mahogny> later
04:03:41 <shapr> musasabi: Speaking of which, the more I think about an hs-plugins daemon, the more I like the idea.
04:04:14 <ayrnieu> musasabi - recently, I only try to make sure I don't embarass myself in public by dropping connections :-)  Everything else is *bam*  what happened?  Ah, drat.  hack hack hack.
04:05:38 <alar> what is an hsplugins daemon?
04:05:42 * juhp sets off a 6.4.2 test build
04:06:36 <musasabi> shapr: one needs to start by managing trees of threads + managers for them. I think there was a process library that implemented part of this.
04:06:53 <musasabi> + it needs some new GHC primitives for watching threads.
04:08:33 <shapr> Good point
04:09:25 <davidhouse> didn't wake up until ten past eleven this morning. oops :)
04:11:31 <musasabi> shapr: One of the simplest ways would be to kill child threads when their parents die.
04:12:35 <musasabi> + add a "waitForChildDone :: IO ThreadID"
04:15:55 <NameTab> there goes nothing!
04:16:25 <NameTab> doaitse: hope it'll work out a little :)
04:25:07 <shapr> musasabi: btw, have you seen Bulat's Streams library?
04:25:17 <shapr> Weren't you asking for a C Struct module earlier?
04:35:13 <davidhouse> if i want to import a module from the parent directory, how do i do it?
04:36:27 <Cale> you move it to the current directory
04:36:54 <Cale> (unless you want to make a GHC package out of it)
04:37:08 <davidhouse> ah.
04:37:10 <davidhouse> hmm.
04:37:33 <davidhouse> my plan was to have a Test/ directory where i stored my unit tests. they'd need to import the modules from the parent directory.
04:38:32 <Lemmih> davidhouse: -i..
04:38:48 <davidhouse> nice.
04:39:28 <davidhouse> is there a {-# ... #-} comment I can use to automate this? will OPTIONS_GHC do?
04:40:11 <alar> @hoogle fromIntegral
04:40:12 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
04:40:50 <xerox> shapr: I think transpose counts as n-dimensional example :-)
04:40:52 <alar> is there a command to lambdabot to check if a function is a class method?
04:42:13 <Lemmih> alar: You can ask GHCi or Hugs.
04:42:33 <Cale> davidhouse: Try it, I suppose. Usually GHC wants your directory structure to reflect your module hierarchy.
04:43:03 <xerox> Cale, do you remember that neat definition of transpose?
04:44:41 <xerox> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6]]
04:44:41 <lambdabot> [[1,4],[2,5],[3,6]]
04:44:50 <xerox> Ah-ha!  This is what I was referring to, shapr.
04:47:43 <musasabi> shapr: the binary serialization/IO thing?
04:48:35 <davidhouse> @type transpose
04:48:36 <lambdabot> forall a. [[a]] -> [[a]]
04:48:48 <musasabi> shapr: it looked quite promising but the parts had many dependencies on each other making it hard to just take it for a partial solution.
04:49:20 <davidhouse> @type zipWith
04:49:21 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
04:50:13 <davidhouse> > zipWith (+) [1,2,3] [10,11,12]
04:50:14 <lambdabot> [11,13,15]
04:52:54 <davidhouse> @pl \(x,y) -> (y,x)
04:52:55 <lambdabot> uncurry (flip (,))
04:53:20 <davidhouse> aww. i was hoping it wouldn't get that :)
04:53:37 <xerox> :-)
04:53:51 <davidhouse> @type curry
04:53:53 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
04:53:58 <xerox> swap = (snd *** fst)
04:54:07 <xerox> swap :: forall a b. (a,b) -> (b,a)
04:54:11 <davidhouse> nice.
04:54:28 <davidhouse> @type uncurryu
04:54:30 <lambdabot> Not in scope: `uncurryu'
04:54:31 <davidhouse> @type uncurry
04:54:32 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
04:54:42 <davidhouse> @type flip uncurry
04:54:43 <lambdabot> forall a b c. (a, b) -> (a -> b -> c) -> c
04:54:52 <davidhouse> @type flip curry
04:54:53 <lambdabot> forall b c b1. b1 -> ((b1, b) -> c) -> b -> c
04:55:17 <davidhouse> curry's not quite as i thought.
04:55:31 <xerox> What would you've thought?
04:55:36 <davidhouse> i thought it might be possible to do swap = uncurry . flip curry
04:55:55 <davidhouse> err, hang on, did i?
04:56:01 <davidhouse> something involving those three, at least.
04:56:41 <davidhouse> @type uncurry flip
04:56:42 <lambdabot> forall a c b. (a -> b -> c, b) -> a -> c
04:56:54 <xerox> @type Control.Monad.Fix.fix flip
04:56:56 <lambdabot> forall a c. a -> a -> c
04:57:01 * xerox snickers
04:57:13 <davidhouse> i never got around to understanding fix.
04:57:49 <davidhouse> is there an easy example of a function that you can actually fix?
04:58:39 <mahogny> have I understood right that GHC can make Arrays mutable if -O is used and I always make sure not to reference the old copies?
04:58:48 <xerox> > fix (const 1)
04:58:49 <lambdabot> 1
04:59:31 <davidhouse> > (fix flip) 2 3
04:59:32 <lambdabot> Add a type signature
04:59:38 <davidhouse> > (fix flip) 2 3 :: Int
04:59:42 <lambdabot> Terminated
04:59:51 <davidhouse> > fix id
04:59:55 <lambdabot> Add a type signature
05:00:03 <xerox> > fix (\f x -> if x < 10 then x : f (x + 1) else [x]) 1
05:00:04 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
05:00:50 * davidhouse doesn't really understand
05:01:09 <ayrnieu> @type fix
05:01:11 <lambdabot> forall a. (a -> a) -> a
05:01:29 <ayrnieu> ah, I guess I wanted @definition
05:01:35 <davidhouse> fix f finds a value x with f x = x.
05:02:03 <xerox> Homework, do fibonacci with fix.
05:02:27 <davidhouse> but it just doesn't work for some functions, i have no idea why it should work for any.
05:02:30 <davidhouse> > fix cos
05:02:31 <lambdabot> Terminated
05:02:37 <davidhouse> cos has a fixpoint, though.
05:03:35 <davidhouse> @hoogle fix
05:03:35 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
05:03:35 <lambdabot> Control.Monad.Fix :: module
05:03:35 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
05:03:42 <davidhouse> @docs Cnontrol.Monad.Fix
05:03:43 <lambdabot> Cnontrol.Monad.Fix not available
05:03:46 <davidhouse> @docs Control.Monad.Fix
05:03:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Fix.html
05:04:53 <davidhouse> fix f = let x = f x in x
05:05:04 <ayrnieu> > fix fix
05:05:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
05:05:05 <lambdabot>   Expected type: (a -> a) -> a -> a
05:05:05 <lambdabot>   Inferred type: (a -> a) -> a
05:05:25 <ayrnieu> well, of course.
05:05:36 <xerox> > fix (\f n -> if n == 0 || n == 1 then n else f (n-1) + f (n - 2)) 10
05:05:37 <lambdabot> 55
05:05:38 <davidhouse> i.e. f $ f x = f $ f $ f x = f $ f $ f $ ...
05:05:39 <ayrnieu> The haskell error is perfect, though :-)
05:05:45 <xerox> davidhouse: right.
05:06:20 <davidhouse> > cos $ cos $ cos $ cos $ cos $ cos $ cos $ cos $ cos 0.5
05:06:21 <lambdabot> 0.7451203413514401
05:06:29 <davidhouse> > cos 0.7451203413514401
05:06:30 <lambdabot> 0.7350063090148431
05:06:40 <mahogny> what properties need the function fullfill for fix to find the point?
05:06:54 <davidhouse> cos's fixpoint is aroud there. perhaps it doesn't find it because it's irrational, or something.
05:07:09 <davidhouse> @type fix (\f n -> if n == 0 || n == 1 then n else f (n-1) + f (n - 2))
05:07:10 <lambdabot> forall a.
05:07:10 <lambdabot>                        (Num a) =>
05:07:10 <lambdabot>                        a -> a
05:07:24 <davidhouse> @type fix
05:07:26 <lambdabot> forall a. (a -> a) -> a
05:07:32 <davidhouse> @type \f n -> if n == 0 || n == 1 then n else f (n-1) + f (n - 2)
05:07:33 <lambdabot> forall a.
05:07:33 <lambdabot>                      (Num a) =>
05:07:33 <lambdabot>                      (a -> a) -> a -> a
05:08:45 <davidhouse> ah, in other words, that_func :: (a -> a) -> (a -> a). so let b = a -> a, then you've got that_func :: b -> b, fix that_func :: b = a -> a. 
05:09:10 <davidhouse> that exlpains the types.
05:09:27 <davidhouse> but i don't know how xerox keeps coming out with examples that work
05:10:08 <xerox> @type Control.Monad.Fix.fix f; f x = undefined
05:10:09 <lambdabot> parse error on input `;'
05:10:19 <xerox> @type Control.Monad.Fix.fix f where f x = undefined
05:10:20 <lambdabot> parse error on input `where'
05:10:29 <davidhouse> @type let f x = undefined in fix f
05:10:30 <lambdabot> forall a. a
05:10:31 <xerox> @type let f x = undefined in Control.Monad.Fix.fix f
05:10:32 <lambdabot> forall a. a
05:10:35 <xerox> Right.
05:10:47 <davidhouse> > let f x = undefined in fix f
05:10:48 <lambdabot> Add a type signature
05:10:55 <davidhouse> > let f x = undefined in fix f :: String
05:10:55 <lambdabot> Undefined
05:11:08 <davidhouse> but it terminates.
05:13:13 <davidhouse> xerox, you planning on explaining?
05:13:24 <xerox> I'm trying to figure out a thing, just a sec.
05:14:12 <davidhouse> sure.
05:18:53 <xerox> May someone remind me how does one shortcut on folds?
05:25:42 <davidhouse> xerox, what do you mean?
05:38:36 <alar> "˘˘Ô‰Û „Ú‡˘‰‚
05:38:42 <alar> @hoogle unfold
05:38:43 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
05:38:43 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:38:43 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
05:43:43 <alar> @hoogle toInt
05:43:44 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
05:43:44 <lambdabot> Char.digitToInt :: Char -> Int
05:43:53 <alar> @hoogle Integral
05:43:53 <lambdabot> Prelude.Integral :: class (Real a, Enum a) => Integral a
05:43:53 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
05:44:18 <alar> @hoogle fromInt
05:44:18 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
05:44:18 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
05:47:30 <alar> how can I work {-# OPTIONS -fno-implicit-prelude #-} around without changing imported files?
05:47:43 <alar> don't like editing standard modules
05:52:36 * alar thinks incompatible pragmas in standard libraries must be banned
06:09:35 <isaac__> scannedinavian.org is dead?
06:09:56 <Lemmih> isaac__: Yes.
06:10:21 <isaac__> What happened to the things on it? can I find them now?
06:10:35 <Lemmih> What are you looking for?
06:11:31 <isaac__> There are a bunch of links to it, I remember I was looking for Cmdline.Pesco scannedinavian.org/~pesco
06:13:23 <Lemmih> Hm, I don't know where pesco moved his things.
06:14:11 <isaac__> but there were a bunch of other links to there that I was mildly interested in, e.g. from the "Haskell Communities and Activities Report" http://www.haskell.org/communities/11-2005/html/report.html
06:14:26 <isaac__> ...?
06:15:12 <isaac__> My IRC client wasn't displaying part of what I typed, but it is now...
06:15:57 <Lemmih> I'd sponsor a permanent place for Haskell projects if I had the money.
06:16:48 <isaac__> haskell.org has some of that, but as it says, I guess, it's somewhat disorganized due to lack of people working on it
06:17:03 <xerox> Lemmih: this could be a proposal for the other admins to do with the other money.... !
06:18:06 <Lemmih> xerox: Definitely!
06:18:29 <xerox> Lemmih: what do you mean with "place" exactly?
06:19:01 <xerox> As in, servers + space + darcs + whatever?
06:19:03 <Lemmih> Web-space with GHC, darcs, haddock and all the other stuff available.
06:19:13 <xerox> Dang.  Sweet.
06:19:19 <xX[ReP]Xx> why can't the current haskell.org be used for that?
06:21:36 <Lemmih> I'm not sure. Lack of sufficient hardware? 
06:22:07 * shapr grumbles
06:22:19 <shapr> I swapped some email with Oleg about functional make systems, but I've lost the mail...
06:24:25 <shapr> isaac__: I'm the owner of scannedinavian.org, though I can't find Cmdline.Pesco at the moment...
06:25:23 <shapr> I'm pretty irritated at my former ISP, he can't get organized enough to give me back the old hardware, even after several months.
06:26:26 <shapr> xerox: other admins? other money?
06:29:37 <xerox> Noow.
06:29:45 <xerox> Damn focusing.
06:31:15 <pesco> isaac__: Actually, I haven't moved my site, yet. Gimme a moment...
06:51:52 <davidhouse> i can't quite get my head around how the import system is meant to work.
06:52:23 <davidhouse> i figure it's one of two things: either every time an "import" statement is encountered, that file is loaded unconditionally.
06:52:46 <davidhouse> OR every time said statement is encountered, that file is loaded if it hasn't already been imported from a different file.
06:53:23 <davidhouse> now, i thought the correct model was the latter, but i've just got an error "Module imports form a cycle", which seems to indicate it's the former
06:54:14 <alar> the former seems bettre
06:54:26 <isaac__> davidhouse, circular imports of modules are allowed by Haskell 98
06:54:37 <alar> because if I import Prelude in toplevel module
06:54:42 <Lemmih> davidhouse: You need to write a boot file.
06:54:47 <isaac__> but ghc and hugs, IIRC, need something special to get it to work
06:54:49 <alar> then import another module that hides prelude
06:55:00 <davidhouse> this is not a particularly complicated build.
06:55:29 <alar> it may result in Prelude invisible from my module and I cannot overcome that
06:56:32 <davidhouse> i'm trying to run ghci on Test.Test, which imports (qualified) Test.Tree and Test.BTree, and Zipper unqualified. Both Test.BTree and Test.Tree require Zipper and Test.Test as well, so those are listed in the imports at the top of those files (if i remove them i get 'not in scope' errors).
06:56:43 <davidhouse> Lemmih, would i need a bootfile for that?
06:57:10 <Lemmih> davidhouse: Yes.
06:57:43 <isaac__> alar: Haskell is declarative, what one module imports or doesn't import shouldn't directly affect another
06:57:59 <davidhouse> Lemmih: and how do i do that?
06:58:12 <alar> isaac: so import declarations affect only the module where they appear?
06:58:44 <isaac__> alar: correct, unless they are re-exported, or
06:59:13 <Lemmih> davidhouse: http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
06:59:14 <isaac__> because compilers have some trouble implementing circular import
06:59:38 <isaac__> you need to do something special for that
06:59:55 <alar> isaac: then option -no-implicit-prelude in module Data.Bits should not affect my program
07:00:13 <kosmikus> dons: can you please include the HCAR CFC in the next HWN ?
07:00:40 <isaac__> alar: As long as your program isn't compiled with that option, it *shouldn't*
07:01:10 <alar> thanks
07:01:24 <alar> then there is something broken in my hags
07:01:27 <alar> hugs
07:01:34 <isaac__> hmm
07:02:45 <isaac__> but I don't know much about how that option would act in that situation
07:03:24 <davidhouse> Lemmih: can i still use GHCi with modules with circural dependencies?
07:03:48 <Lemmih> davidhouse: With the necessary boot files, yes.
07:03:52 <Lemmih> alar: How does it fail?
07:05:50 <alar> Undefined variable "toInt"  
07:05:51 <davidhouse> Lemmih: do i need the {-# SOURCE #-} pragma as well? and what does it do? (it's not mentioned in the Pragmas section of the user's guide)
07:06:40 <isaac__> alar: what's toInt?
07:06:42 <pesco> isaac__: Go to http://www.khjk.org/~sm/
07:06:50 <alar> @hoogle toInt
07:06:51 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
07:06:51 <lambdabot> Char.digitToInt :: Char -> Int
07:07:01 <alar> method of Integral class
07:07:20 <vincenz> @hoogle fromIntegra
07:07:21 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
07:07:25 <isaac__> toInt is short for toInteger?
07:07:33 <alar> no
07:07:40 <alar> :(
07:07:47 <alar> there are toInt and toInteger
07:08:08 <davidhouse> alar, in ghci, :i Integral only shows toInteger
07:08:17 <Lemmih> davidhouse: It's explained in the link I gave you.
07:08:42 <lisppaste2> davidhouse pasted ":i Integral" at http://paste.lisp.org/display/19147
07:08:46 <alar> hm
07:08:47 <davidhouse> alar, ^^
07:08:52 <vincenz> hmm
07:08:55 <vincenz> oasisbot was Mine
07:08:59 <Lemmih> alar: Your module fails with that after Data.Bits has been compiled with -no-implicit-prelude?
07:09:01 <vincenz> and he was a temporary lambdabot replacement
07:09:12 <alar> Lemmih:yes
07:09:29 <alar> line 1: import Data.Bits
07:09:35 <alar> line2: import prelude
07:10:27 <alar> @hoogle fromInt
07:10:27 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
07:10:27 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
07:11:31 <isaac__> pesco: ok... that url works; the within-site links give 404 Not Found errors at the moment
07:11:35 * alar thinks he's found what needs fixing
07:12:01 <isaac__> google says: "Frequently Asked Questions about Hugs":
07:12:03 <pesco> isaac__: Yes, I'm still in the process of copying the backup over. ;)
07:12:16 <pesco> isaac__: And my upstream is slow.
07:12:17 <isaac__> "What happened to isAlpha, toInt, etc?
07:12:25 <isaac__> The Prelude now conforms to Haskell 98, whereas in older versions it exported some additional names. To use character functions like isAlpha, you must load or import the Char module. Non-standard functions like toInt are no longer available."
07:13:09 <isaac__> alar: in particular, "Non-standard functions like toInt are no longer available"
07:14:00 <isaac__> pesco: yes, thanks, I thought so :)
07:14:51 <alar> isaac: I din't know that toInt is non-standard
07:15:28 <isaac__> hmm... well for standards, see haskell.org/onlinereport/
07:15:36 <isaac__> that's haskell98
07:15:43 <isaac__> the current standard
07:15:44 <davidhouse> what GHC option will take a .hs and spit out a .hi?
07:15:56 <davidhouse> -c, perhaps?
07:17:13 <Lemmih> davidhouse: You just want a .hi file? No .o?
07:17:32 <davidhouse> Lemmih, i'm not sure:
07:17:41 <isaac__> alar: http://haskell.org/onlinereport/standard-prelude.html  is the section on Prelude functions specifically, and  http://haskell.org/haskellwiki/Language_and_library_specification  has a bit more of an overview on current Haskell standardization
07:18:04 <davidhouse> i'm writing a hs-boot file, and i need to import HUnit (which i've installed myself, in ~/hs/inc, which i've added to my search path with a .ghc option)
07:18:26 <davidhouse> it seems that boot files ignore my .ghc, but that's no problem, i can just put -i on the cmd line itself.
07:19:11 <davidhouse> but then ghc -c Test/Test.hs-boot fails with "Failed to load interface for module HUnit; Cannot find module HUnit"
07:19:37 <Lemmih> Have you compiled HUnit?
07:19:44 <davidhouse> no.
07:20:05 <davidhouse> do i need to do so seperately?
07:20:23 <Lemmih> That or use --make.
07:22:38 <davidhouse> okay, it works now. (it also turns out that -i doesn't like paths beginning with ~)
07:24:38 <alar> then I should use fromInteger to get Int?
07:25:09 <xerox> alar: from what type of value?
07:25:16 <davidhouse> @hoogle a -> Int
07:25:17 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
07:25:17 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
07:25:17 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
07:25:45 <xerox> alar: Floating values can be reduced to Integral ones by, say, round, floor, ...
07:26:39 <davidhouse> @type round
07:26:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:28:05 <isaac__> @type fromInteger
07:28:06 <lambdabot> forall a. (Num a) => Integer -> a
07:29:27 <davidhouse> Lemmih, it's still broken :) the ghc -c Test/Test.hs-boot works fine, but then ghc -c Test/Tree.hs fails with "Bad interface file: ./Test/Test.hi"
07:30:55 <alar> xerox: value of class Bits
07:31:29 <isaac__> @hoogle (Bits a) => a -> Int
07:31:29 <lambdabot> Data.Bits.bitSize :: Bits a => a -> Int
07:31:29 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
07:31:29 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
07:31:33 <isaac__> ?
07:31:46 <alar> no
07:31:54 <alar> there is no class member
07:32:15 <alar> but I can put additional constraint
07:32:29 <alar> say, (Bits a, Integral a)=>
07:32:57 <isaac__> class Num a => Bits a  ...hmm
07:33:18 <isaac__> "The Bits class defines bitwise operations over integral types."
07:33:23 <alar> yes
07:33:41 <isaac__> Why isn't it  class Integral a => Bits a   then?
07:34:04 <alar> I don't know
07:34:15 <alar> hm
07:34:40 <alar> maybe I should write instance Bits a=> Integral a ?
07:35:04 <alar> no
07:35:05 <isaac__> alar: an instance, you mean?
07:35:29 <alar> I mean Integral methods for Bits members
07:35:32 <alar> but no
07:35:52 <alar> I don't know how to define div/mod for arbitrary sized value
07:36:57 <alar> if a value can be converted to sized integer, that doesn't mean a value is a number
07:36:57 <isaac__> oh well, I guess the additional class constraint works...
07:37:16 <isaac__> alar: what?
07:37:54 <alar> I mean I don't know how to define Integral methods for Bits members
07:38:12 <alar> shall try additional constraint
07:38:13 <isaac__> Or there's the horrible (read (show someBits) :: Int)?
07:38:50 <isaac__> since Num requires Show for some reason...
07:39:44 <sjanssen_> woo! new GHC!
07:42:20 <mathrick> what was the function to make n * string?
07:42:29 <mathrick> ie, "asd" 3 -> "asdasdasd"
07:42:38 <davidhouse> cycle
07:42:53 <davidhouse> kind of.
07:43:10 <davidhouse> > concat $ take 3 $ repeat "asd"
07:43:11 <lambdabot> "asdasdasd"
07:43:19 <davidhouse> > take 9 $ cycle "asd"
07:43:20 <lambdabot> "asdasdasd"
07:43:38 <ihope> > take 9 (take 9 (cycle "asd"))
07:43:39 <lambdabot> "asdasdasd"
07:43:39 <xerox> > replicate 3 "asd"
07:43:40 <lambdabot> ["asd","asd","asd"]
07:43:45 <xerox> concat it.
07:43:47 <sjanssen_> @hoogle Int -> [a] -> [a]
07:43:47 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
07:43:47 <lambdabot> Prelude.take :: Int -> [a] -> [a]
07:43:47 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
07:43:54 <ihope> > take 9 (repeat "asd")
07:43:55 <lambdabot> ["asd","asd","asd","asd","asd","asd","asd","asd","asd"]
07:44:12 <davidhouse> yeah, concat $ replicate 3 "asd" is your best bet
07:44:22 <NameTab> xerox: hows your physics ? :)
07:44:44 <xerox> (concat ) . replicate :: Int -> [a] -> [a]
07:44:50 <xerox> (concat .) . replicate :: Int -> [a] -> [a]
07:44:51 <xerox> Wops.
07:44:59 <xerox> NameTab: *COUGH*
07:45:01 <ihope> > foldr max minBound "asd"
07:45:02 <lambdabot> 's'
07:45:11 <NameTab> xerox: hmm? :)
07:45:16 <davidhouse> > maximum "asd£
07:45:16 <lambdabot>  lexical error in string/character literal
07:45:17 <davidhouse> > maximum "asd"
07:45:18 <lambdabot> 's'
07:45:48 <ihope> Ooh...
07:45:54 <ihope> > foldr max minBound ""
07:45:55 <lambdabot> '\NUL'
07:46:02 <ihope> > maximum ""
07:46:03 <lambdabot> Exception: Prelude.maximum: empty list
07:47:32 <davidhouse> > minBound :: CHar
07:47:33 <lambdabot>  Not in scope: type constructor or class `CHar'
07:47:37 <davidhouse> > minBound :: Char
07:47:37 <lambdabot> '\NUL'
07:48:00 <davidhouse> ihope, another difference:
07:48:06 <davidhouse> @type foldr max minBound
07:48:07 <lambdabot> forall a. (Ord a, Bounded a) => [a] -> a
07:48:12 <davidhouse> @type maximum
07:48:14 <lambdabot> forall a. (Ord a) => [a] -> a
07:48:49 <davidhouse> > maxBound :: Char
07:48:50 <lambdabot> '\1114111'
07:48:58 <ihope> > case "asd" of (x:xs) -> foldr max x xs
07:48:59 <lambdabot> 's'
07:49:49 <davidhouse> > fold1 max minBound "asd"
07:49:50 <lambdabot>  Not in scope: `fold1'
07:49:59 <davidhouse> > Data.List.fold1 max minBound "asd"
07:50:00 <lambdabot>  Not in scope: `Data.List.fold1'
07:50:33 <davidhouse> > Data.List.foldr1 max minBound "asd"
07:50:34 <lambdabot>  add an instance declaration for (Bounded [[Char] -> a])
07:50:43 <pesco> isaac__: Copy complete.
07:52:52 <ihope> @type Data.List.foldr1
07:52:53 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:53:02 <isaac__> pesco: ok, thanks
07:53:10 <ihope> @type Data.List.foldr1 max minBound "asd"
07:53:11 <lambdabot> forall t.
07:53:11 <lambdabot>              (Ord ([Char] -> t), Bounded [[Char] -> t]) =>
07:53:11 <lambdabot>              t
07:53:29 <davidhouse> > Data.List.foldr1 max "asd"
07:53:30 <lambdabot> 's'
07:54:18 <davidhouse> foldr1 is foldr without an initial value (and so the list must be nonempty)
07:54:49 <ihope> What about foldr2? :-)
07:54:52 <ihope> s/)/P/
07:55:25 <ihope> So is there a term for values that have types but no principle types?
07:55:42 <mathrick> /usr/lib/ghc-6.4.1/libHSrts.a(Main.o): In function `main': undefined reference to `__stginit_ZCMain'
07:55:47 <mathrick> uh?
07:56:11 <ihope> Compiler booch. :-P
07:56:34 <ihope> Oh, right right.
07:56:45 <ihope> Linker booch. :-P
07:56:54 <mathrick> so what do I do about it?
07:57:57 <ihope> Well, one would wonder what __stginit_ZCMain is...
07:58:22 <mathrick> mangled version of something
07:58:27 <ihope> Yep.
07:58:33 <mathrick> ihope: put another way, how do I compile my foo.hs?
07:58:45 <Lemmih> mathrick: Got a module named Main?
07:58:52 <mathrick> nope
07:59:09 <mathrick> right, now it works
07:59:27 <NameTab> isn't it wrong to start ur foo.hs with non-capital letters?
07:59:47 <mathrick> NameTab: ?
07:59:49 <Lemmih> NameTab: Nope.
08:00:00 <davidhouse> NameTab: if you want to import it from elsewhere, yes.
08:00:19 <NameTab> I got an error once using ghci when I didn't use a capital letter
08:01:47 <davidhouse> in ghci, you can :load filename.hs, but not :load filename or :m filename unless you rename it to Filename.hs
08:02:07 <davidhouse> > maxBound `asTypeOf` 'a'
08:02:08 <lambdabot> '\1114111'
08:02:10 <NameTab> ahh right, that could be it :)
08:02:11 <Lemmih> NameTab: Probably because you didn't start the module name with a capital letter.
08:02:12 <davidhouse> that's nice.
08:03:13 <mathrick> http://pastebin.com/669361
08:03:31 <mathrick> why does the output look like it does, instead of what I want it to look like?
08:03:43 <mauke> @type asTypeOf
08:03:44 <lambdabot> forall a. a -> a -> a
08:04:32 <Lemmih> mathrick: What should it look like?
08:05:05 <mathrick> Lemmih: it should print indented tree, without "" and duplicate values
08:05:29 <Lemmih> mathrick: Use 'putStrLn' instead of 'print' when outputting a String.
08:05:42 <mathrick> ok
08:05:53 <Lemmih> mathrick: And don't print 'a' twice if you don't want duplicate values (:
08:06:18 <mathrick> I don't?
08:07:06 <Lemmih> print $ indent n ++ show a\n print a
08:07:18 <mathrick> oops
08:08:16 <mauke> heh, at first I parsed that as perl code
08:09:01 <davidhouse> mathrick: print = putStr . show
08:09:03 <davidhouse> > show "hello"
08:09:04 <lambdabot> "\"hello\""
08:09:34 <mathrick> > show hello
08:09:34 <lambdabot>  Not in scope: `hello'
08:10:51 <Lemmih> ?id hello
08:10:52 <lambdabot> hello
08:13:26 <ihope> @id hello
08:13:27 <lambdabot> hello
08:13:35 <k3ys3r> hello?
08:14:39 <Lemmih> k3ys3r: Hi?
08:14:57 <k3ys3r> Lemmih hi
08:15:02 <k3ys3r> howz life?
08:16:19 <Lemmih> k3ys3r: Pretty good, actually. You?
08:16:47 <k3ys3r> oh me just going on.. 
08:17:38 <ihope> output x = seq (unsafePerformIO (putChar x))
08:17:58 <_maxi_> k3ys3r: hi
08:18:57 <k3ys3r> hi _maxi_ ... do i know you?
08:19:06 <_maxi_> do you?
08:19:17 <k3ys3r> hmm.. thinkinggggg.
08:19:25 <k3ys3r> ..... i think yes
08:26:10 <jip> MonadState is a GADT?
08:27:42 <esap> you mean the MonadState type class? type classes are not GADTs.
08:28:37 <jip> oh yeah! oops... thanks :)
08:38:39 <sjanssen_> @keal
08:38:39 <lambdabot> i cant think anymore
08:44:37 <jip> f t x y z = t y z x
08:44:42 <jip> is there such a function f?
08:44:45 <ihope> @pl f t x y z = t y z x
08:44:45 <lambdabot> f = flip . (flip .)
08:44:56 <jip> @type flip
08:44:58 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
08:45:14 <ihope> @type flip . (flip .)
08:45:15 <lambdabot> forall a a1 b c.
08:45:15 <lambdabot>        (a -> a1 -> b -> c) -> b -> a -> a1 -> c
08:45:40 <jip> almost :)
08:46:04 <ihope> What're you looking for?
08:46:58 <jip> what's better: f :: State -> Arg1 -> Arg2 -> Arg3 -> State
08:47:11 <jip> or f :: Arg1 -> Arg2 -> Arg3 -> State -> State ?
08:47:26 <tromp> prolly 2nd
08:47:29 <jip> with the second one then i can do (f 1 2 3) and get a State->State function
08:47:52 <sjanssen_> jip: how about making it a state monad instead?
08:48:22 <jip> i'm actually using Control.Monad.State
08:48:55 <ihope> > 18*15/16
08:48:56 <lambdabot> 16.875
08:59:00 * davidhouse wishes the haskell workshop people would let you see the papers that have already been submitted
09:02:03 <Cale-work> jip: With Control.Monad.State, that would be something like f :: Arg1 -> Arg2 -> Arg3 -> State S ()
09:02:40 <jip> Cale: hm... well i sort of like using the modify function
09:02:43 <Cale-work> or f :: (MonadState m s) => Arg1 -> Arg2 -> Arg3 -> m S ()
09:02:49 <Cale-work> ah
09:03:25 <Cale-work> Generally, the best order of args to a function is in order of increasing change.
09:03:46 <Cale-work> (that is, put the parameter you think most likely to change as the last one)
09:04:20 <tromp> in other words, in order of inertia
09:04:43 <Cale-work> decreasing inertia, sure
09:06:33 <norpan> good rule of thumb, but what do you mean when you say a parameter changes
09:07:17 <Cale-work> norpan: in the sense of being called multiple times with varying parameters
09:07:30 <norpan> yes, that was what i thought
09:07:49 <jip> Cale: setBit function doesn't seem to get this right :/
09:08:21 <norpan> @type setBit
09:08:22 <lambdabot> forall a. (Bits a) => a -> Int -> a
09:08:45 <Cale-work> yeah, that seems kind of wrong
09:08:48 <jip> although i guess it's ok since it's only 2 args so you can do `setBit`
09:08:54 <Cale-work> yeah
09:09:07 <Cale-work> @type (`setBit` 1)
09:09:08 <lambdabot> forall a. (Bits a) => a -> a
09:09:44 <Cale-work> It can actually be (slightly) less efficient when you get it wrong like that though.
09:09:54 <musasabi> How would I create a typeclass that takes pure values and returns them in the IO monad or values in the IO monad and just returns them. This while being either a single parameter class or having a FD.
09:11:09 <davidhouse> musasabi: how do you throw values into a monad?
09:11:32 <norpan> musasabi: what would the class functions look like?
09:12:50 <Cale-work> class C t a | t -> a where f :: t -> a; instance C a (IO a) where f = return; instance C (IO a) (IO a) where f = id
09:12:53 <musasabi> norpan: "class PutItInIO w where doIt :: w a -> IO a" or realistically "class PutItInIO a b | a -> b where doIt :: a -> b"
09:12:54 <Cale-work> perhaps something like that?
09:13:19 <musasabi> Cale-work: yes, except that FD does not work. (testing)
09:13:45 <Cale-work> you most likely have to turn on overlapping instances
09:14:00 <Cale-work> which are evil, but then so is your operation :)
09:14:22 <musasabi> Cale-work: that does not help.
09:14:31 <Cale-work> hmm
09:14:35 <musasabi> Cale-work: fundeps don't use overlapping information.
09:14:43 <musasabi> Which is the problem.
09:14:54 <musasabi> If they did then it would be trivial like you proposed.
09:14:56 <jip> (flip setBit) is not the same as `setBit` ?
09:15:29 <davidhouse> jip, `setBit` is infix notation.
09:15:42 <davidhouse> > elem 3 [1..5]
09:15:43 <lambdabot> True
09:15:48 <davidhouse> > 3 `elem` [1..5]
09:15:49 <lambdabot> True
09:16:02 <davidhouse> x `f` y = f x y
09:16:16 <jip> hm...... right
09:16:47 <Cale-work> musasabi: hmm, possibly you just can't do it.
09:17:02 <Cale-work> musasabi: why would you need such a thing?
09:17:38 <musasabi> Cale-work: currently I have a hierarchy of functions with variants like "foo" and "fooIO". Just would like to merge them.
09:18:23 <Cale-work> couldn't you just delete the IO variants and let people use return or some such when they need the result in IO?
09:18:38 <Cale-work> (assuming that they do the same thing)
09:19:02 <norpan> why have IO built-into a function if it does not do IO
09:19:19 <Cale-work> right
09:19:55 <norpan> let f = x works by itself in the do-notation
09:19:57 <musasabi> Cale-work: they are functions defining event handlers and having a separate "webEventHandler" and "webEventHandlerIO" is not nice.
09:20:45 <Cale-work> musasabi: is webEventHandlerIO = return . webEventHandler (or similar) ?
09:21:38 <musasabi> The functions generally look like webEventHandler :: foo -> bar -> ... -> EventHandler state event result -> Handler state
09:21:57 <musasabi> and webEventHandlerIO :: foo -> bar -> ... -> EventHandler state event (IO result) -> Handler state
09:22:49 <Cale-work> Is (EventHandler state event) a monad?
09:23:00 <Cale-work> (or a functor at least?)
09:23:00 <musasabi> yes
09:23:04 <Cale-work> okay
09:23:13 <musasabi> Thus one can define the functions easily with the other.
09:23:30 <Cale-work> You can define the non-IO version with the IO version
09:23:45 <musasabi> But having two separate functions or forcing the users to use "fmap return" is not nice.
09:24:15 <xerox> The non-IO with the IO ones?
09:24:22 <Cale-work> xerox: yes
09:24:29 <xerox> unsafe*?
09:24:39 <musasabi> xerox: no.
09:25:11 <musasabi> xerox: webEventHandler a b ... evh = webEventHandlerIO a b ... (fmap return evh)
09:25:22 <norpan> an alternative is to write your handler as an IO function always
09:26:03 <musasabi> Making all clients use the dirty IO monads is not an solution. 
09:26:08 <musasabi> -s
09:26:12 <Cale-work> nope
09:26:12 <xerox> Ah!
09:26:13 <Cale-work> just an application of fmap return to the appropriate parameter
09:26:13 <xerox>  ... . return perhaps.
09:26:13 <xerox> Right.
09:26:13 <Cale-work> I think it's kind of reasonable to require an IO action
09:26:28 <Cale-work> well, internally, it's an IO action, isn't it?
09:26:50 <xerox> Yep, I meant "apply return to that param before doing the rest".
09:28:15 <kowey> is there a library out there that can serialise stuff into haskell? i'm imagining some kind of typeclass, where for example
09:28:24 <musasabi> internally we can do it either with or without IO.
09:28:35 <norpan> kowey: serialise stuff?
09:28:49 <kowey> euh... i might be getting my terminology wrong
09:29:03 <kowey> i want to output haskell, given some data, for example,
09:29:18 <norpan> what kind of output do you want?
09:29:25 <kowey> showHs xs = "[" ++ (concat $ intersperse "," $ map showHs xs) ++ "]"
09:29:26 <kowey> haskell
09:29:32 <kowey> like, .hs files that i can compile
09:29:55 <norpan> oh you mean like a combinator library for haskell syntax
09:30:18 <kowey> sure! that'd be nice
09:30:31 <Igloo> show will work for values
09:30:31 <norpan> it would :)
09:30:31 <kowey> for producing it, that is
09:30:36 <Igloo> You might want the Language.Haskell stuff
09:31:28 <norpan> yes, Language.Haskell.Syntax and Language.Haskell.Pretty
09:31:59 <kowey> oh my... yes, that does sound very much like something i want
09:32:01 <kowey> thanks!
09:32:11 <norpan> just data types though
09:32:20 <norpan> no neat combinators
09:33:38 <Igloo> What combinators would you want?
09:33:52 <kowey> hmm... i think i'll just go the stupid route and make a typeclass... after all, i only really want to produce a tiny subset of haskell
09:34:03 * kowey hasn't really thought about it
09:34:17 <kowey> the scenario is that i've got a piece of software that reads some huge file as input
09:34:41 <kowey> and i'm thinking that one neat thing i could do is just translate the huge file into haskell and compile it into my program
09:34:54 <kowey> (incidentally, turning my program into a natural language generator generator)
09:36:27 <kowey> i suppose the alternative would some kind of pickler/unpickler thingy, but i'm guessing that loading the executable for my generated generator would be faster that it unpickling
09:39:54 <norpan> musasabi: what are the restrictions? can you use dynamic typing instead?
09:49:01 <musasabi> norpan: dynamic typing? (how do you mean it in this instance)
09:49:32 <vincenz> Paltas: pin
09:49:33 <vincenz> Paltas: ping
09:50:10 <mahogny> who here is Shae Matijs Erisson? :)
09:50:18 <astrolabe> shapr
09:50:22 <mahogny> aah
09:50:32 <mahogny> hm. got away :)
09:50:41 <astrolabe> That's the first lesson in #haskell 101
09:50:54 <Paltas> vincenz, pong :)
09:51:22 <vincenz> Paltas: do I remove you?
09:51:33 <Paltas> no you said you wanted to?
09:51:41 <vincenz> ?
09:51:51 <Paltas> hmm..
09:52:03 <Paltas> i understood it, so that you would remove me. :)
09:52:24 <vincenz> ah ok
09:52:27 <vincenz> will do
09:52:30 <vincenz> just asking if I should
09:52:40 <Paltas> ah ok
09:53:17 * xerox pokes astrolabe 
09:53:32 <vincenz> Paltas: http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Team
09:53:33 <vincenz> good like that?
09:53:50 <mahogny> omg already?
09:54:06 <Paltas> very well
09:54:30 <vincenz> mahogny: 
09:54:31 <vincenz> ?
09:54:48 <mahogny> vincenz, icfp. I can understand collecting a team but setting up a website? :)
09:55:01 <vincenz> mahogny: it doesn't cost me anything
09:55:19 <vincenz> just used part of my wiki
09:55:21 <mahogny> vincenz, true that. just find it early. will you even remember the url when the time comes? ;)
09:55:27 <vincenz> it's my personal site
09:55:41 <vincenz> obviously I will
09:55:59 <vincenz> and at least it gives a forum to discuss 
09:56:03 * mahogny barely remembers the content on his pages :/
09:57:12 <vincenz> besides
09:57:14 <vincenz> it's like christmas
09:57:18 <vincenz> can't wait for it to get started
09:57:23 <vincenz>  so you already start shaking the boxes
10:01:19 * mahogny wonders if anyone has advice on how to keep wxhaskell code clean and preferably quite OOP
10:04:35 <jip> i can tell you some tricks i use for gtk2hs
10:04:39 <Cale-work> Hmm, we really ought to have a data structure in GHC which is analogous to the STL vector. It looks pretty easy to implement.
10:05:30 <jip> List?
10:05:39 <Cale-work> List is completely different
10:05:58 <mahogny> STL? in what sense?
10:06:04 <jip> standard template library
10:06:05 <Cale-work> C++ STL
10:06:13 <mahogny> yes, but I mean, in what way?
10:06:26 <davidhouse> what's the STL vector like?
10:06:41 <Cale-work> Vectors are essentially arrays which automatically reallocate
10:06:42 <mahogny> I can't think of anything special about STL
10:06:57 <Cale-work> They allow O(1) access time to elements
10:07:03 <jip> Cale-work: it would be cool have a haskell version of vector that is can be used instead of mallocBytes
10:07:08 <mahogny> hm. indeed that is something we lack. I wrote a small "library" for that
10:07:28 <jip> hm... but i think i see what you are saying now
10:07:36 <mahogny> but I mean, it's not much you have to write to add support for that
10:07:41 <jip> you want a functional version of vector, like Data.Array
10:07:43 <davidhouse> Cale-work: arrays have O(1) access
10:07:50 <mahogny> I have my Helper.hs with commonly used functions and I put everything like that in there
10:08:01 <davidhouse> @docs Data.Array
10:08:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
10:08:21 <vincenz> Cale-work: yeah actually I've been thinking about that
10:08:27 <Cale-work> davidhouse: but not O(1) append
10:08:28 <vincenz> Cale-work: is it possible to create O(1) structure in haskell?
10:08:40 <vincenz> for random access
10:08:47 <Cale-work> (Sorry, I didn't completely specify them)
10:09:08 <vincenz> Cale-work: anyways... if you plan to implement it... use fibonacci growth
10:09:13 <vincenz> instead of exponential
10:09:13 <Cale-work> A vector is a Sequence that supports random access to elements, constant time insertion and removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle. The number of elements in a vector may vary dynamically; memory management is automatic. Vector is the simplest of the STL container classes, and in many cases the most efficient.
10:09:39 <vincenz> Cale-work: I'm the man you want to talk about :
10:09:44 <vincenz> :)
10:09:51 <mahogny> I don't really see the problem. just use an MArray or similar, and put an extra API on top of it for automatic realloc
10:09:58 <vincenz> mahogny: nope
10:10:02 <Cale-work> vincenz: that's probably a good idea -- though Fibonacci growth is still exponential :)
10:10:07 <vincenz> Cale-work: yeah but slower
10:10:11 <vincenz> Cale-work: 2^ is too fast
10:10:13 <Cale-work> mahogny: yes, exactly
10:10:20 <vincenz> most vectors use fibonacci
10:10:26 <Cale-work> Or a DiffArray even
10:10:33 <vincenz> I always wonder
10:10:40 <vincenz> how do you do random O(1) access in haskell
10:10:42 <mahogny> DiffArray is potentially faster indeed
10:10:47 <vincenz> don't you need stuff outsde of the language to make that work?
10:10:51 <Cale-work> you could give it an immutable interface with a DiffArray and have the same performance properties
10:10:55 <mahogny> vincenz, *Array and friends
10:11:02 <vincenz> mahogny: yeah but... how do they work
10:11:04 <Cale-work> vincenz: there are plenty of array types
10:11:09 <vincenz> but they're implemented in c
10:11:15 <vincenz> not in pure haskel
10:11:21 <vincenz> right?
10:11:24 <Cale-work> no, they're implemented in FFI :)
10:11:29 <vincenz> well yeah
10:11:31 <vincenz> that's what I mean
10:11:31 <mahogny> vincenz, check the GHC hierarchical libs. search for Array and you find everything you need
10:11:34 <vincenz> my point is this
10:11:36 <musasabi> vincenz: but Ints are not implemented in Haskell either.
10:11:37 <Cale-work> and/or in Haskell, by way of GHC
10:11:40 <vincenz> it's most likely impossible to do it in pure haskell
10:11:45 <mahogny> vincenz, if you mean the API = how they work
10:11:50 <Cale-work> Arrays are in the Haskell standard
10:11:51 <vincenz> the guts
10:12:02 <vincenz> ah ok
10:12:08 <Cale-work> H98 requires arrays with O(1) access time
10:12:11 <vincenz> if they weren't in the std, I doubt you coculd get them in
10:12:14 <vincenz> without extending the std
10:12:20 <musasabi> vincenz: with IORefs one can implement ineffcient arrays. With Foreign.* more efficient ones.
10:12:27 <Cale-work> well, the standard also has the FFI
10:12:33 <vincenz> musasabi: they're not O(1)
10:12:41 <Cale-work> so you can just allocate your own memory in Haskell
10:12:45 <mahogny> vincenz, the haskell wiki also has some pages relating to speed between different Array implementations (there are several)
10:12:46 <vincenz> I aws just curious about the feasibility of O(1) arrays in haskell
10:13:11 <vincenz> anyways I don't think MVar would be good
10:13:13 <vincenz> unless you hide that
10:13:16 <Cale-work> Using unsafePerformIO lets you create really fast structures with pure interfaces.
10:13:20 <mahogny> well, it's easy to implement even from scratch. just FFI
10:13:37 <Cale-work> Have a look at DiffArray if you haven't.
10:13:57 <mahogny> but I heard those DiffArrays had some speed issues you had to be aware about before using them
10:14:09 <Cale-work> It uses the immutable array interface, but has an update operator which is O(1) (but which makes accesses to the old version slower)
10:14:50 <Cale-work> Well, they do, but only if you use them in ways which you couldn't use mutable arrays.
10:15:34 <vincenz> regarding the MVar solution, you would have to ensure that it's hidden so people don't get access to the old array if you're reallocing
10:16:15 <vincenz> @fptools DiffArray
10:16:16 <lambdabot> DiffArray not available
10:16:27 <Cale-work> @fptools Data.Array.DiffArray
10:16:27 <lambdabot> Data.Array.DiffArray not available
10:16:29 <Cale-work> @fptools Data.Array.Diff
10:16:30 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/Diff.hs
10:16:34 <Cale-work> there it is :)
10:16:34 <vincenz> th
10:16:34 <vincenz> x
10:16:43 <musasabi> vincenz: Haskell98 does not require O(1)
10:16:48 <musasabi> "Haskell provides indexable arrays, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. Functions restricted in this way can be implemented efficiently; in particular, a programmer may reasonably expect rapid access to the components."
10:16:59 <Cale-work> ah
10:17:02 <Cale-work> 'rapid'
10:17:06 <Cale-work> heh
10:17:13 <musasabi> O(log n) is rapid I think.
10:17:31 <Cale-work> yeah, I suppose you could use trees.
10:18:04 <Cale-work> That would be slightly cheesy to do though, given that if you're writing a compiler, there's no reason for you to do so.
10:18:36 <vincenz> I think a vector-like datastructure is useful
10:18:39 <musasabi> yes, of course when writing a compiler actually implementing the arrays in sensible manner is easy.
10:18:45 <vincenz> most languages have one
10:19:09 <vincenz> plus once you have one, making hashmaps is a breeze
10:19:12 <Cale-work> vincenz: I'll implement one if you'd like.
10:19:30 <musasabi> It is mostly about getting a nice interface.
10:19:49 <musasabi> MArray + dynamic bounds.
10:20:20 <xerox> Cale-work: Seq a?
10:20:23 <vincenz> Cale-work: If you need help...
10:20:27 <vincenz> Cale-work: DDTs are my forte
10:20:40 <Cale-work> oh yeah, there's the Seq type now
10:20:47 <musasabi> Personally I would like the low level arrays to be indexable by a zero based Int. And build the fancy indexing on top of that.
10:20:51 <Cale-work> which is reasonably decent
10:20:58 <xerox> Yup.
10:21:45 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:45 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:45 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:47 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:47 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:47 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:49 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:51 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:52 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:53 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:53 <xerox> Hmmm.
10:21:56 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:57 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:21:59 <jip> who's got ops?
10:22:00 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:03 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:03 <norpan> nobody
10:22:04 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:05 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:06 <xerox> Somebody.
10:22:08 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:09 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:12 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:13 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:16 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:17 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:20 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:21 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:24 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:25 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:28 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:29 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:32 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:33 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:36 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:37 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:40 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:41 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:44 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:45 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:48 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:49 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:50 <Cale-work> just /ignore them
10:22:52 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:53 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:56 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:22:57 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:00 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:01 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:02 <norpan> already done, but not everybody is that fast
10:23:05 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:09 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:12 <jip> we gotta save the logs though :/
10:23:13 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:17 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:21 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:25 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:25 <Muad_Dib> Would I be stupid if I suggested ryah, wqe are spambots?
10:23:29 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:32 <xerox> Just call an admin... ?
10:23:33 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:36 <norpan> not stupid at all
10:23:37 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:41 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:43 --- mode: ChanServ set +o musasabi
10:23:44 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:44 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:45 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:47 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:48 <xerox> Pheeew.
10:23:49 <ryah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:51 <wqe> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
10:23:56 <norpan> hey
10:24:00 <musasabi> bah. was too slow.
10:24:15 <norpan> maybe if more people had privileges
10:24:28 --- mode: musasabi set -o musasabi
10:24:41 <vincenz> I got his whois
10:24:45 <vincenz> n=wes@helios.demon.co.uk
10:25:17 --- mode: ChanServ set +o musasabi
10:25:26 --- mode: musasabi set +b *!wes@helios.demon.co.uk
10:25:30 --- mode: musasabi set -o musasabi
10:26:23 * mahogny goes teasing one of his C++ friends because his undolibrary cannot be implemented at all (in a useable form) in C++, but it's trivial in Haskell >:)
10:26:26 <Cale-work> Seq doesn't give O(1) access to all elements though, but accesses are O(log(min(i,n-i)))
10:26:30 <xerox> (Calling lilo worked, they were K-lined.)
10:26:44 <vincenz> xerox: cool
10:27:18 <Cale-work> @oldwiki UndoMonad
10:27:19 <lambdabot> http://www.haskell.org/hawiki/UndoMonad
10:27:29 <xerox> Sweet Monad.
10:27:35 <vincenz> I wonder why people spam like that
10:27:37 <vincenz> what's the use
10:27:52 <mahogny> they need to fill up their bandwidth quota maybe
10:27:56 <vincenz> lol
10:27:59 <musasabi> vincenz: channel logs -> web -> google maybe.
10:28:07 <Cale-work> @oldwiki MonadUndo
10:28:07 <lambdabot> http://www.haskell.org/hawiki/MonadUndo
10:28:12 <vincenz> musasabi: it's a channel name tho
10:28:15 <BearPerson> who spammed?
10:28:16 <Cale-work> that's the one :)
10:28:17 <vincenz> musasabi: not like it will help much on google
10:28:19 <xerox> Ah, right.
10:29:07 <Pegazus> is maybe included in the prelude?
10:29:14 <Cale-work> Pegazus: yes
10:29:16 <norpan> the type, yes
10:29:20 <Cale-work> @type maybe
10:29:21 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:29:21 <Pegazus> and are the function of the type
10:29:23 <xerox> Cale-work: I really like your way to write out Monads (-: 
10:29:24 <Pegazus> included on the prelude?
10:29:27 <Pegazus> isJust and all those?
10:29:28 <Cale-work> yes
10:29:29 <mahogny> baah. my Undo code is nicer than MonadUndo. this one wastes memory like an idiot :o
10:29:33 <Cale-work> not isJust
10:29:36 <Pegazus> hugs doesn't find them
10:29:37 <Pegazus> :(
10:29:39 <Cale-work> that's in Data.Maybe
10:29:44 <Pegazus> ah...
10:29:53 <musasabi> BearPerson: wqe [n=wes@helios.demon.co.uk] and another nick from the same host. both quitted with excess flood.
10:30:03 <BearPerson> hmm
10:30:21 <BearPerson> ryah [n=rwa ?
10:30:25 <Cale-work> mahogny: does it? I suppose I could easily implement an operation which limited the undo depth
10:30:25 <int-e> well, on #math they quitted with K-lined ;)
10:30:38 <BearPerson> int-e, yes, they did
10:30:55 <mahogny> Cale-work, well, you save the world state in a list if I see it correctly?
10:31:17 <Cale-work> mahogny: yes, lists are equivalent to stacks
10:31:32 <vincenz> Cale-work: not quite
10:31:37 <vincenz> Cale-work: most stacks are array-based
10:31:41 <Cale-work> vincenz: sure
10:31:41 <vincenz> and therefore have O(1) access
10:31:52 <int-e> lists have O(1) access to the head
10:31:53 <mahogny> Cale-work, I only store partial updates, and have a database checkpoint style system for improving speed
10:32:00 <Cale-work> But that's not necessary for a stack
10:32:08 <vincenz> int-e: all data structures have O(1) access to some element
10:32:30 <vincenz> except trees that only store data in leafs
10:32:51 <mahogny> Cale-work, hm. not necessary?
10:32:56 <Cale-work> Really, the only guarantees of performance I'd claim for a generic stack is O(1) push and pop and peek at the top element
10:33:05 <mahogny> yeah
10:33:11 <int-e> vincenz: uh, ok, what's you definition of a stack? for me it's a data structure that supports push and pop.
10:33:38 <vincenz> int-e: yes but I'm saying that typically stacks allow O(1) access and that a list stack is therefore the minimal implementation that supports the minimal operations
10:33:52 <vincenz> basically, arraystacks are better than liststacks
10:33:53 <mahogny> Cale-work, the major disadvantage is if you have a large world state, you will be doing tons of memory copying which both wastes memory and cpu. but it works for simpler stuff I guess
10:33:59 <Cale-work> mahogny: depending on your state type, partial updates may be all that are stored anyway
10:34:06 <mahogny> yeah
10:34:17 <mahogny> but that leaves the problem in the knee of the user :(
10:34:26 <Cale-work> and I have checkpoints too - they just set the lists blank
10:34:26 <mahogny> ehr. lap
10:34:30 <int-e> vincenz: well, that's not true in general - in some applications you want to copy stacks
10:34:43 <vincenz> hmm
10:34:46 <vincenz> good point
10:34:48 <Cale-work> (though perhaps you mean something else by checkpoint)
10:35:01 <vincenz> int-e: I guess it depends on your needs then
10:35:17 <int-e> I agree wholeheartedly with that.
10:35:20 <vincenz> :)
10:35:38 * vincenz wonders why people never make array-lists
10:35:38 <Cale-work> I wouldn't even require a stack type to allow accesses to any but the top element in general.
10:35:42 <mahogny> Cale-work, a database style checkpoint is where you store an actual copy of the database instead of a partial update. that speeds up the undo operation while still saving memory
10:36:03 <Pegazus> is there any function that checks if all the values of a list are equal?
10:36:09 <Cale-work> mahogny: ah, okay, but you still allow undos beyond that point
10:36:25 <Cale-work> Pegazus: of a single list?
10:36:27 <vincenz> > scanl (==) [1,1,1,1]
10:36:28 <lambdabot> Couldn't match `Bool' against `[a]'
10:36:30 <vincenz> > scanl1 (==) [1,1,1,1]
10:36:31 <lambdabot>  add an instance declaration for (Num Bool)
10:36:31 <lambdabot>   In the list element: 1
10:36:34 <vincenz> hmm
10:36:54 <mahogny> Cale-work, yeah. I actually have several checkpoints, but they are supposed to be more sparse deeper down in the stack. I haven't done much on that though as I haven't used my lib yet
10:36:57 <Cale-work> > and (zipWith (==) xs (drop 1 xs))
10:36:58 <lambdabot>  Not in scope: `xs'
10:37:13 <Cale-work> > let allEqual xs = and (zipWith (==) xs (drop 1 xs)) in allEqual [1,1,1,1]
10:37:14 <lambdabot> True
10:37:16 <mahogny> Cale-work, http://mahogny.areta.org/snippets/   think I should link this to the haskell wiki instead
10:37:18 <Cale-work> > let allEqual xs = and (zipWith (==) xs (drop 1 xs)) in allEqual [1,1,1,2,1]
10:37:19 <lambdabot> False
10:37:33 <sjanssen_> @pl allequal xs = and (zipWith (==) xs (drop 1 xs))
10:37:33 <lambdabot> allequal = and . ap (zipWith (==)) (drop 1)
10:37:34 <Pegazus> what is sscanlf for?
10:37:58 <sjanssen_> Pegazus: scanl gives you the partial applications in a foldl
10:37:59 <vincenz> @type scanl
10:38:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:38:09 <Cale-work> > scanl (+) 0 [1,2,3,4,5]
10:38:10 <lambdabot> [0,1,3,6,10,15]
10:38:28 <Cale-work> > scanl (flip (:)) [] [1,2,3,4,5]
10:38:29 <lambdabot> [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
10:38:46 <bolrod> ?
10:39:09 <vincenz> > scanl1 (==) [1..10]
10:39:10 <int-e> > take 10 $ fix ((1:) . scanl (+) 1)
10:39:10 <lambdabot>  add an instance declaration for (Num Bool)
10:39:10 <lambdabot>   In an arithmetic sequence: [1 .. 10]
10:39:11 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
10:39:13 <vincenz> @type scanl1
10:39:14 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
10:39:18 <vincenz> ah
10:39:28 <Cale-work> mahogny: you should make it a monad transformer -- we could have a compatible interface even :)
10:39:39 <mahogny> Cale-work, problem is, I hate monads :)
10:39:40 <vincenz> int-e: funky
10:40:33 <vincenz> mahogny: they're not that bad
10:40:34 <mahogny> omg how is this hawiki organized?? (if at all)
10:40:39 <mahogny> vincenz, at times
10:40:46 <Cale-work> mahogny: randomly :)
10:40:50 <mahogny> vincenz, unneeded use clutters code IMO
10:40:56 <Cale-work> mahogny: that's the old wiki though
10:40:58 <mahogny> Cale-work, thought so :)
10:41:04 <vincenz> mahogny: unneeeded anything clutters code
10:41:20 <mahogny> vincenz, indeed. and monad is on my Top-10 ;)
10:41:24 <vincenz> :)
10:41:30 <vincenz> too mony manads?
10:41:35 <Cale-work> mahogny: basically, monads are just a way to structure combinator libraries so that common operations can be defined quickly
10:41:49 <mahogny> vincenz, apply a permutation ;)
10:42:34 <mahogny> Cale-work, yeah. I just haven't gotten the taste for them. but maybe I'll write a transformer library to put on top of this
10:42:36 <Cale-work> Most monads do nothing but simplify code which has been cluttered with a particular idiom.
10:42:47 <Cale-work> Like state parameter passing
10:42:59 <vincenz> is it possible to make transparent mnads/?
10:43:28 <xerox> No!!
10:43:31 <vincenz> er...transparent monad transformers
10:43:36 <Cale-work> vincenz: completely transparent? I'll say no, with reservation that you might be able to abuse language extensions like linear implicit parameters.
10:43:42 <vincenz> it woudl be great
10:43:46 <vincenz> change the type of your app
10:43:50 <vincenz> and you can for instance add profiling
10:43:52 <palomer> weeee
10:43:54 <vincenz> without having to plugin code everywhere
10:44:05 <Cale-work> Well, you already can get effects like that
10:44:18 * vincenz did that with c+++ templates
10:44:23 <vincenz> a nearly transparent template-type wrapper
10:44:30 <Cale-work> Just parametric polymorphism over the type of monad
10:44:43 <vincenz> ?
10:44:47 <xerox> Sweet kind of polymorphism.
10:44:55 * vincenz is not a type expert
10:44:58 <Cale-work> f :: (Monad m) => blah -> m foo
10:45:03 <xerox> For very high values of sweet.
10:45:12 <vincenz> xerox: vanilla-levels?
10:45:18 <xerox> Better.
10:45:26 <vincenz> pixie-sticks?
10:45:37 <vincenz> Cale-work: yeah but what if you have some monadic code..
10:45:50 <vincenz> Cale-work: and just change the monad
10:45:52 <vincenz> to another monad
10:46:01 <vincenz> that internally for instance tracks the number of statements (aka number of >>=)
10:46:05 <xerox> That's how they improve composability!
10:46:05 <vincenz> >>
10:46:13 <Cale-work> vincenz: sure, you could do that
10:46:19 <vincenz> and it would obviously be a transformer
10:46:24 <vincenz> cause you still want the original behaviour
10:46:26 <xerox> I.e. transforming the previous monad, say.
10:46:29 <vincenz> but no need to plugin lift everwhere
10:46:34 <vincenz> 'lift'
10:46:38 <xerox> Right, you don't.
10:47:10 <vincenz> erm
10:47:14 <vincenz> transformers require lifting
10:47:14 <Cale-work> well, supposing that this new monad you've constructed has the same interface as the old one, you can just swap it out for free
10:47:20 <vincenz> yeah
10:47:25 <vincenz> but that doesn't really make it a reusable transformer
10:47:33 <xerox> ?
10:47:42 <sjanssen_> vincenz: isn't this like the design of the monads in Control.Monad
10:47:43 <Cale-work> all monad transformers come with a typeclasses of extra operations that they support
10:47:46 <vincenz> if I want to transform state, I'd have to add 'get' and 'put
10:47:58 <Cale-work> you just add some instances to lift operations from other transformer classes
10:48:02 <xerox> Like MonadState, MonadRandom, MonadUndo.
10:48:17 <Cale-work> to your new monad
10:48:29 <jip> @type execState
10:48:30 <lambdabot> forall s a. State s a -> s -> s
10:49:12 <vincenz> Cale-work: well my point is that you have a code with a monad... you add your profiling transformer, and you'll have to either extend your profiling monad to have the operations the monad you're wrapping has, or put 'lift' everywhere
10:49:18 <xerox> BBL.
10:49:21 * xerox <- out
10:49:32 <vincenz> it's not a nice clean thing you just plug into the the type definition of your root function that startst he whole mond
10:50:33 <vincenz> vim MyHaskell.hs
10:50:45 <vincenz> :s/CurrentMonad/ProfilingMonad 
10:50:47 <vincenz> :q
10:50:50 <vincenz> ghc --mae
10:51:57 <Cale-work> vincenz: sure, you do have to do that in order to define the interaction between the transformers, but usually the instances are quite trivial to write.
10:52:02 <vincenz> ok
10:52:15 <vincenz> but you see that it would need to have a lot of instances
10:52:19 <vincenz> for it to be generally usable
10:52:21 <Cale-work> depends
10:52:58 <Cale-work> Unless you're audreyt, your monad transformer stack is usually not 20 transformers or anything like that.
10:53:02 * vincenz can't wait until icfp-christmas
10:53:17 <davidhouse> getting some rather big errors when trying to link my program: http://pastebin.com/669717
10:53:22 <mahogny> vincenz, ...you should be lazy, not eager!
10:53:42 <vincenz> mahogny: only if I'm not certain I will evaluate
10:53:50 <vincenz> otherwise I have to make a thunk that I have to keep in memory
10:53:52 <vincenz> and I have a bad memory
10:54:02 <mahogny> =)
10:54:10 <Cale-work> The ideal way to use monad transformers is to construct your monad, newtype it, and lift any and all operations you need so that you do no lifting outside of the module in which your monad is defined
10:55:41 * vincenz figures out a new name for the team
10:55:46 <vincenz> Thunks 'R' Us
10:56:16 <mahogny> Lazy Bastards? :o
10:56:26 <vincenz> mahogny: but you're not on the team!
10:56:28 <Cale-work> You also almost never export the data constructor for your newtype, it's a good way to ensure that code relevant to your monad is localised.
10:56:36 <sjanssen_> Exception: <<loop>> ?
10:56:36 * vincenz nods
10:56:43 <sjanssen_> (as a suggestion for a team name)
10:56:46 <mahogny> vincenz, true. that would be too much lazyness to be good :)
10:56:54 <davidhouse> i love lazy bastards! :D
10:56:57 <Igloo> Team for the ICFP contest?
10:57:00 <vincenz> yeah
10:57:02 <davidhouse> we can get T-Shirts.
10:57:07 * vincenz adds the suggestion to the wiki page
10:57:26 <jip> is there something like when, but for Maybe values?
10:57:32 <davidhouse> maybe.
10:58:00 <vincenz> jip: >>=
10:58:01 <davidhouse> well, when would actually work, but be a bit pointless because Maybe doesn't have side-effects.
10:58:11 <davidhouse> jip, what exactly do you want?
10:58:13 <Pegazus> how can i put into a function
10:58:20 <Pegazus> Eq a => but i need that the type has a + function
10:58:23 <vincenz> Igloo: http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
10:58:31 <davidhouse> Pegazus: (Eq a, Num a) =>
10:59:07 <jip> vincenz: not sure how that would work
10:59:08 <davidhouse> > maybe "fallback" (++" world") $ Just "hello"
10:59:09 <lambdabot> "hello world"
10:59:14 <davidhouse> > maybe "fallback" (++" world") Nothing
10:59:15 <lambdabot> "fallback"
10:59:33 <vincenz> jip: let me work something out
10:59:37 <Cale-work> maybe is to Maybe as foldr is to []
10:59:51 <davidhouse> > liftM (++ " world") $ Just "hello"
10:59:51 <lambdabot> Just "hello world"
10:59:55 <davidhouse> > liftM (++ " world") Nothing
10:59:56 <lambdabot> Nothing
11:00:46 <davidhouse> Cale-work: and find is to Maybe as filter is to [].
11:00:57 <jip> vincenz: when (isJust x) seems to work ok
11:01:11 <davidhouse> jip, what _exactly_ do you want?
11:01:15 <Igloo> vincenz: I like the list of things to leave to the last minute (well, hours)  :-)
11:01:55 <jip> davidhouse: when (isJust x) (y (fromJust x))
11:02:10 <davidhouse> @type when
11:02:11 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:02:20 <davidhouse> your action has to be of type Maybe ()
11:02:27 <davidhouse> however:
11:03:02 <davidhouse> > maybe "fallback value" (++ "this function gets executed if it's a Just") $ Just "hi"
11:03:03 <lambdabot> "hithis function gets executed if it's a Just"
11:03:13 <Cale-work> > maybe Nothing Just $ Nothing
11:03:14 <lambdabot> Add a type signature
11:03:18 <Cale-work> > maybe Nothing Just $ Nothing :: Maybe Integer
11:03:19 <lambdabot> Nothing
11:03:21 <davidhouse> nice.
11:03:25 <Cale-work> > maybe Nothing Just $ Just 5 :: Maybe Integer
11:03:26 <lambdabot> Just 5
11:03:28 <jip> @type maybe
11:03:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:03:32 <Cale-work> maybe Nothing Just == id
11:03:33 <davidhouse> maybe Nothing Just == id
11:03:38 <Cale-work> foldr (:) [] == id
11:04:12 <vincenz> jip: http://rafb.net/paste/results/CgAGCN34.html
11:04:27 <davidhouse> and foldr (:) fallback l == fallback when l is [] (i.e., the computation failed)
11:04:38 <vincenz> Igloo: well those are generic things, once we get the assigment obviously it will be decided then, but just to have an a priori view
11:04:50 <Cale-work> It's generally a good idea when defining a data structure to also define a function which replaces the constructors with arbitrary functions.
11:05:22 <davidhouse> > either (++ " world") (+ 4) $ Left "hello"
11:05:23 <lambdabot>  add an instance declaration for (Num [Char])
11:05:30 <davidhouse> oops
11:05:52 <davidhouse> > either (++ " world") (++ ", vietnam") $ Left "good morning"
11:05:53 <lambdabot> "good morning world"
11:05:58 <davidhouse> > either (++ " world") (++ ", vietnam") $ Right "good morning"
11:05:58 <lambdabot> "good morning, vietnam"
11:06:07 <Cale-work> @type either
11:06:08 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
11:06:58 <jip> is there a shortcut for updating fields in a record: r { foo = g (foo r) } i'm thinking something like r { foo g } maybe?
11:07:10 <vincenz> when'' f a = maybe (return ()) f a
11:07:20 <Cale-work> jip: no, but something like that would be nice
11:07:37 <vincenz> @type= maybe (return ()) f a
11:07:39 <lambdabot> Not in scope: `f'
11:07:39 <lambdabot>  
11:07:39 <lambdabot> <interactive>:1:20: Not in scope: `a'
11:07:39 <vincenz> @type maybe (return ()) f a
11:07:41 <lambdabot> Not in scope: `f'
11:07:41 <lambdabot>  
11:07:41 <lambdabot> <interactive>:1:20: Not in scope: `a'
11:07:42 <jip> Cale-work: it really would be :|
11:07:53 <vincenz> @type let when'' f a = maybe (return ()) f a in when''
11:07:55 <lambdabot> forall a
11:07:55 <lambdabot>                     (m :: * -> *).
11:07:55 <lambdabot>                   (Monad m) =>
11:07:55 <lambdabot>                   (a -> m ()) -> Maybe a -> m ()
11:08:47 <davidhouse> perhaps someone can confirm my thinking: there seems to be two types of monads floating around
11:09:17 <__phas> Hello, anyone knows if there are compression lybraries for haskell?
11:09:22 <xerox> Cale-work: Unless you're audreyt, your monad transformer stack is usually not 20 transformers or anything like that.
11:09:24 <xerox> haha.
11:09:56 <Cale-work> davidhouse: which two types :)
11:10:06 <Cale-work> __phas: yes, there are a few
11:10:06 <xerox> davidhouse: wha<Interrupted by Cale-work>
11:10:22 <xerox> Howdy __phas (-:
11:10:23 <davidhouse> the first often have functions as their value (State, Reader, Writer, IO) and are used to hide some extra plumbing (e.g. the state in State). the second (Maybe, [], Either) are used to represent computations whose results follow a certain pattern.
11:10:53 <xerox> Where would you put Cont? :-)
11:10:55 <davidhouse> you could say that the former are used to represent computations who rely on something more than just the passed-in parameters, i suppose.
11:11:05 <davidhouse> but beyond that those two groups don't seem very unified.
11:11:35 <Cale-work> davidhouse: well, there are those where you generally prefer the container view, and those where you generally prefer the computation view
11:12:01 <Cale-work> Also, the container-like ones tend to be instances of MonadZero and MonadPlus
11:12:11 <davidhouse> yes, true.
11:12:30 <Cale-work> (though either view works for all sorts of monads)
11:12:42 <davidhouse> woah, hang on... there's a MonadZero class?
11:12:54 <Cale-work> there used to be, and hopefully will be again
11:12:56 <davidhouse> Cale-work: like?
11:13:09 <Cale-work> MonadZero was in Haskell 1.4
11:13:29 <Cale-work> it was merged with MonadPlus in '98, but this was a lapse in judgement
11:13:34 <xerox> Monads work like matter, they can be seen in a wave or a quantum scent.
11:13:45 <Cale-work> wave or particle
11:13:51 <xerox> Right.
11:13:54 <davidhouse> sorry, i meant "like" in response to "either view works for all sort of monads"
11:14:04 <davidhouse> ah, the famous container-computation duality.
11:14:37 <Cale-work> davidhouse: like you can apply the container view to the State monad, it's just not too natural, since the "container" you get is unrealistic in some ways
11:15:12 <xerox> IO `contains` RealWorld
11:15:14 <Cale-work> and the "computation" view has shortfalls as well
11:15:15 <davidhouse> oh, i thought you meant there were "all sorts of monads" where both views made a lot of sense
11:15:21 <Cale-work> oh
11:17:05 <Cale-work> well, they always both make some kind of sense -- it's more a matter of taste which one you'll use at any given time
11:18:57 <davidhouse> (back to my previous question:) i'm getting some rather big errors when trying to link my program: http://pastebin.com/669717
11:19:33 <palomer> what's wrong with the container view of ST?
11:20:10 <Igloo> davidhouse: Does -package HUnit fix some of them?
11:20:39 <davidhouse> Igloo: HUnit isn't installed as a package. the sources have just been compiled in a directory which is in my search path
11:21:10 <Igloo> davidhouse: What's your command line?
11:21:18 <Igloo> Oh, n/m, it's in the paste
11:21:24 <jip> do { shit; a < foo; a < bar; stuff } shouldn't there be a warning about that double usage of a? code like this can be confusing
11:21:25 <Cale-work> davidhouse: maybe --make ?
11:21:45 <Igloo> davidhouse: If you have just compiled them then you'll need ot list all the .o filenames on the commandline
11:21:58 <robokop> hey guys
11:22:10 <Igloo> jip: If you have -Wall on it should warn you about variable shadowing there
11:22:36 <davidhouse> Cale-work: i'm following the instructions for compiling modules with circular dependencies, and this is what it says.
11:22:39 <davidhouse> but i'll try make.
11:22:39 <Igloo> davidhouse: I believe HUnit comes with GHC, BTW
11:22:42 <Cale-work> oh
11:22:55 <jip> Igloo: yeah, but shouldn't this also warn without -Wall?
11:23:05 <robokop> how do i close a dialog in wxhaskell because dialog isn't in the class closable
11:23:12 <Cale-work> at the very least, you'll need -package mtl
11:23:18 <davidhouse> Igloo: woah. that would have been really, really helpful :)
11:23:31 <Cale-work> yeah, HUnit is included
11:24:01 <Igloo> jip: Well, it doesn't... I'm not sure who is to decide whether or not it should
11:24:04 <Cale-work> @type Test.HUnit.Base.assertEqual
11:24:06 <lambdabot> forall a.
11:24:06 <lambdabot>            (Show a, Eq a) =>
11:24:06 <lambdabot>            String -> a -> a -> Test.HUnit.Lang.Assertion
11:25:01 <Cale-work> to use it you'll need -package HUnit on the commandline, or -make
11:25:37 * Igloo vanishes
11:26:13 <jip> how can i do guards in like an expression?
11:26:59 <Cale-work> case?
11:27:38 <jip> doesn't case just do pattern matching?
11:27:45 <Cale-work> robokop: get the user to respond to it?
11:28:20 <Cale-work> > case (Just 5) of Nothing -> "a"; Just x | x > 7 -> "b" | otherwise -> "c"
11:28:21 <lambdabot> "c"
11:28:31 <Cale-work> > case (Just 10) of Nothing -> "a"; Just x | x > 7 -> "b" | otherwise -> "c"
11:28:32 <lambdabot> "b"
11:28:57 <Philippa> jip: guards are part of patterns
11:28:58 <jip> hm... interesting did not know this
11:29:11 <Philippa> (admittedly they're also just sugar, but hey)
11:29:16 <bolrod> robokop: killall
11:29:18 <bolrod> ;)
11:29:18 <jip> Philippa: hey, how's it going?
11:29:34 <Philippa> 'mdrowsy. Just got back from town
11:29:45 <jip> :(
11:29:46 <robokop> bolrod that would be a nice trick
11:29:59 <jip> a better question: [Bool], how can i find the index of the first element that is True?
11:30:07 <Philippa> about to watch some stuff with one of my partners
11:30:18 <Cale-work> robokop: alternately, when you call showModal, you're given a function which you can use to end the dialog's life prematurely
11:30:22 <xerox> > indexOf True [False,False,True]
11:30:23 <lambdabot>  Not in scope: `indexOf'
11:30:26 <xerox> > List.indexOf True [False,False,True]
11:30:27 <lambdabot>  Not in scope: `List.indexOf'
11:30:31 <xerox> Hrmpf.
11:30:40 <Philippa> > Data.List.indexOf True [False,False,True]
11:30:40 <lambdabot>  Not in scope: `Data.List.indexOf'
11:30:41 <Cale-work> To show/hide modeless dialogs, you use the visible property
11:31:07 <xerox> > elemIndex True [False,False,True]
11:31:08 <lambdabot> Just 2
11:31:28 <jip> Philippa: one of your partners? do you practice polygamy?
11:31:42 <xerox> jip: do you have a value to default to, in case the element isn't there?
11:31:43 <jip> xerox: thanks!
11:31:51 <Philippa> the term you're looking for is "polyamory", as I'm not married and don't plan on it. Yes.
11:31:59 <jip> xerox: value is guaranteed to be in there, but out of curiosity, what happens if it's not?
11:32:01 <palomer> you have to be married to practice polygamy
11:32:06 <palomer> and polyamory is the future
11:32:11 <xerox> jip: Nothing :: Maybe a.
11:32:22 <Philippa> I wouldn't go that far. But monogamy definitely isn't /my/ future
11:32:27 <palomer> I'd suggest it to my partner, but she's old school:/
11:32:37 <jip> xerox: oh, i see. i there a version that returns the result straight out, not in a container?
11:34:06 <jip> > [0..4]
11:34:07 <lambdabot> [0,1,2,3,4]
11:34:39 <xerox> > (fromJust  .) . elemIndex $ True [False,False,True]
11:34:40 <lambdabot> Couldn't match `Bool' against `t -> t1'
11:34:59 <davidhouse> sections of composition are evil.
11:35:25 <jip> they are the devil
11:35:30 <vincenz> what is the greek prefix for none
11:35:38 <mahogny> mdc # paintTrack t  <-- what the heck does # do?
11:35:40 <vincenz> mono = 1, poly = many, ... = none
11:35:45 <xerox> > ((fromJust  .) . elemIndex) True [False,False,True]
11:35:46 <lambdabot> 2
11:36:05 <Philippa> vincenz: a or an, as in anamorous?
11:36:10 <vincenz> anamory
11:36:24 <davidhouse> vincenz: the very fact you're asking that question tells us the reason for what you're trying to say.
11:36:24 <Philippa> although polyamory is a bastard mix of greek and latin anyway
11:36:42 <vincenz> davidhouse: :D
11:37:28 <xerox> jip: 'kay?
11:37:49 <jip> xerox: yeah it works i guess, thanks. but there's actually probably a better way to do what i need
11:38:06 <davidhouse> i have allTests :: [(String, Test)]. i want to go through the list, print the first item in the pair and runTestTT on the second.
11:38:18 <davidhouse> i tried main = map (putStrLn . fst >> runTestTT . snd) allTests
11:38:34 <davidhouse> but that gives a result of [IO Counts], which can't be a main.
11:38:41 <davidhouse> so i then tried main = sequence $ map (putStrLn . fst >> runTestTT . snd) allTests
11:39:00 <davidhouse> but the putStrLn . fst gets optimised out
11:40:05 <toast> hey      
11:40:15 <davidhouse> same when using mapM_ instead of sequence
11:40:20 <toast> if i have a function that return : Just [xs]
11:40:49 <toast> i want to use it in another function : foo attribute funtion(moo)
11:40:50 <davidhouse> ... and with mapM.
11:41:01 <toast> i get an error because of the Just
11:42:15 <sjanssen_> davidhouse: that pointfree expression you have there isn't right
11:42:22 <davidhouse> no?
11:42:40 <davidhouse> @pl \(x, y) -> putStrLn x >> runTestTT y
11:42:41 <lambdabot> uncurry ((. runTestTT) . (>>) . putStrLn)
11:42:55 <davidhouse> @type \(x, y) -> putStrLn x >> runTestTT y
11:42:57 <lambdabot> Not in scope: `runTestTT'
11:43:02 <davidhouse> @type \(x, y) -> putStrLn x >> Test.HUnit.runTestTT y
11:43:03 <lambdabot> (String,
11:43:03 <lambdabot>                   Test.HUnit.Base.Test)
11:43:03 <lambdabot>                  -> IO Test.HUnit.Base.Counts
11:43:16 <davidhouse> it's got the right type
11:43:27 <sjanssen_> toast: what sort of error are you referring to?
11:43:34 <sjanssen_> a type error?
11:45:34 <toast> ERROR - Type error in application   
11:45:57 <sjanssen_> toast: you need a way to get your 'a' out of the Maybe a
11:46:11 <davidhouse> @pl \f g h x -> h (f x) (g x)
11:46:12 <lambdabot> flip . (ap .) . flip (.)
11:46:17 <sjanssen_> try using a case expression
11:46:35 <davidhouse> there should be a combinator for that; it's used so often.
11:47:09 <sjanssen_> davidhouse: there is, it just has a long name: "flip . (ap .) . flip (.)" ;-)
11:48:45 <toast> i use a case already
11:49:23 <sjanssen_> toast: perhaps you should paste your code somewhere, or be more specific
11:50:49 <toast> well basicly, it doesnt work cause Just(...)
11:51:56 <davidhouse> sjanssen_: uncurry (>>) . (putStrLn *** runTestTT) works
11:52:17 <sjanssen_> toast: that isn't really specific at all, but I'll take a stab.  write (Just ...) instead of Just(...).  if that doesn't work try (Just (...))
11:52:53 <toast> can't i get rid of just() ?
11:54:39 <xerox> Yep.
11:54:48 <xerox> toast: do you have a default value to use in case of Nothing?
11:54:52 <Cale-work> toast: you have to decide what to do if the value is Nothing
11:55:03 <toast> yes i do ;(
11:55:15 <Cale-work> @type maybe
11:55:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:55:33 <xerox> maybe id value (your value)
11:55:42 <xerox> > maybe id 0 Nothing
11:55:43 <lambdabot>  add an instance declaration for (Show (a -> a))
11:55:45 <davidhouse> ahem.
11:55:48 <davidhouse> > maybe 0 id Nothing
11:55:49 <lambdabot> 0
11:55:50 <xerox> Ops.
11:55:53 <Cale-work> > (\x -> case x of Nothing -> 0; Just u -> u^2) Nothing
11:55:53 <lambdabot> 0
11:56:06 <Cale-work> > (\x -> case x of Nothing -> 0; Just u -> u^2) (Just 17)
11:56:07 <lambdabot> 289
11:56:26 <Cale-work> > maybe 0 (^2) Nothing
11:56:27 <lambdabot> 0
11:56:31 <Cale-work> > maybe 0 (^2) (Just 17)
11:56:32 <lambdabot> 289
11:56:49 <davidhouse> xerox, think i'm done with the Zipper stuff.
11:56:59 <xerox> davidhouse: cool.
11:57:08 <vincenz> what is a finger structure?
11:57:24 <davidhouse> it's semi-tested (it passes all the unit tests it's meant to, but i haven't figured out a way to make sure it fails the unit tests it's meant to)
11:58:14 <Cale-work> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
11:59:37 <Cale-work> They have rather nice performance properties for sequences.
12:00:37 <vincenz> oh
12:00:38 <vincenz> 2-3 tree
12:01:00 <Cale-work> It's a modified sort of 2-3 tree
12:01:12 <robokop> and it is cool
12:01:19 <Cale-work> The modification is a bit strange, so I'd recommend looking at the paper :)
12:01:41 <vincenz> sure thing
12:01:42 <vincenz> thanks
12:01:46 <vincenz> seems I already had the paper, heh
12:01:48 <vincenz> I will take a look at it
12:01:53 * vincenz has a huge library of papers
12:01:58 <toast> ERROR - Cannot find "show" function for:  
12:02:08 <toast> but hum i derived show ;\
12:02:29 <Cale-work> for what type?
12:03:53 <toast> i made the type
12:04:03 <toast> data ACTION = Action SYMBOLE [ATTRIBUT]
12:04:03 <toast> 	      deriving (Read,Show,Eq,Ord)
12:05:26 <mahogny> ok. I need an array that I can easily access in both C and haskell. is there a suitable haskell datatype or should I move this completely outside haskell?
12:05:50 <mahogny> (preferably a matrix of int)
12:06:00 <sjanssen_> mahogny: see Data.Array.Storable perhaps
12:06:03 <mahogny> ok
12:07:09 <Cale-work> or maybe Foreign.Marshal.Array (but that makes them lists on the Haskell side)
12:07:13 <kpreid_> toast: what exactly did it say it can't find?
12:07:25 <mahogny> hm. lists. way too slow. but thanks anyway
12:07:54 <Cale-work> well, depending on what operations you want, lists might be perfect too :)
12:08:09 <mahogny> tons of !! ... neaah :)
12:08:37 <Cale-work> I tend to think of lists as loops which just haven't happened yet :)
12:08:44 <mahogny> lol
12:09:15 <}ElectrowolF{> o.O
12:09:40 <}ElectrowolF{> hmmm
12:10:03 <Cale-work> (or think of loops as lists which are comparatively inconvenient to manipulate :)
12:10:18 <}ElectrowolF{> that sounds better ;p
12:10:22 <toast> "show"
12:10:33 <toast> ohh well nvm, i was using the rong fonction
12:10:34 <toast> lol :)
12:10:39 <mahogny> you also think of specifications as programs that are yet quite unuserfriendly? ;)
12:11:01 <Cale-work> well, it's laziness that lets you do that
12:11:17 <mahogny> implement :: Specification -> IO Binary
12:11:19 <toast> valeurAttribut :: [Char] -> ACTION -> Maybe [Char]
12:11:30 <mahogny> someone implement implement!
12:11:36 <}ElectrowolF{> anyone knows some manual or w/e concerning CalendarCtrl, been googling on it but it doesn't realy clear the fog in my mind..
12:11:47 <Cale-work> If you have a compiler for your specifications, then you can start thinking of specifications as programs.
12:11:48 <toast> Then, i use a function to find the "ACTION"
12:11:57 <toast> but it returns a JUST(ACTION)
12:12:00 <sjanssen_> > let implement = implement implement in implement
12:12:00 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
12:12:00 <lambdabot>   Expected type: t1 -> t
12:12:00 <lambdabot>   Inferred type: t
12:12:01 <toast> so it doesnt work
12:12:18 <sjanssen_> mahogny: sorry
12:12:27 <mahogny> :(
12:12:48 <Cale-work> toast: what's with the all-caps type names?
12:13:03 <Cale-work> I suppose you're allowed to name them like that :)
12:13:11 <}ElectrowolF{> Error: Thread specified does not exist.
12:13:18 <}ElectrowolF{> wops, wrong paste >_>
12:13:20 <toast> indeed ;p
12:13:36 <mauke> writing in php made me think about html forms and state
12:13:51 <mauke> does it make sense to think of cgi scripts as functions and forms as monads?
12:13:52 <toast> mauke ?
12:14:09 <mauke> submitting a form is >>=
12:15:58 <mahogny> ok. here's a challenge; if I use (Int,Int) as the index for an MArray (Storable), in which order will the elements appear in C?
12:16:37 <sjanssen_> > range ((0, 0), (2, 2))
12:16:38 <lambdabot> [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
12:16:43 <sjanssen_> mahogny: that order
12:16:53 <mahogny> hmm. is that Haskell 98 standard?
12:17:03 <mahogny> or rather: is it probable that it will change?
12:17:41 <sjanssen_> mahogny: I'm almost certain that behavior is written in the standard
12:17:53 <mahogny> yeah. me too. just making sure :)
12:21:50 <Cale-work> mahogny: The instance of Ix for pairs is in the standard, and it's what determines that, so yeah. 
12:21:51 <vincenz> dons, dons, dons dons
12:23:37 <RHE123> does someone know how the calendarCtrl in wxHaskell works?
12:28:06 <Cale-work> hmm, lots of .nl people wanting to know about CalendarCtrl
12:28:31 <}ElectrowolF{> yer
12:28:54 <}ElectrowolF{> talked with RHE123 about it on msn, don't understand it either ;-)
12:29:06 <RHE123> but, does someone know? :)
12:29:18 <RHE123> and want to explain of course ;)
12:30:12 <toast> valeurAttribut :: [Char] -> ACTION -> Maybe [Char]
12:30:14 <toast> Then, i use a function to find the "ACTION"
12:30:25 <toast> but it returns a JUST(ACTION)
12:30:32 <toast> so it doesnt work ;\
12:30:50 <toast> it's 4 pages of code, ... so i can't paste
12:30:57 <Cale-work> lisppaste2: url
12:30:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:32:33 <lisppaste2> toast pasted "code" at http://paste.lisp.org/display/19157
12:32:36 <Cale-work> RHE123, }ElectrowolF{: It looks like a control which hasn't been fully integrated into the higher level library yet. Maybe compare the stuff in the wxHaskell documentation with the wxWidgets documentation -- the required parameters are probably similar.
12:32:49 <toast> http://paste.lisp.org/display/19157
12:33:02 <toast> wow, nice paste system
12:33:14 <toast> lot's of xmlrpc
12:34:24 <lisppaste2> Cale annotated #19157 with "fixed?" at http://paste.lisp.org/display/19157#1
12:34:26 <vincenz> this sucks
12:34:30 <vincenz> I sent a mail to haskell-cafe
12:34:33 <vincenz> and it's not being shown
12:34:45 <Cale-work> strictly speaking, that's equivalent
12:35:33 <lisppaste2> Cale annotated #19157 with "another variant" at http://paste.lisp.org/display/19157#2
12:36:10 <toast> nah still not working
12:36:16 <Cale-work> of course, it's going to return a Maybe String, so you need to be able to deal with the case that it returns Nothing
12:36:31 <Cale-work> Perhaps the problem is where you're using this function instead
12:36:34 <Cale-work> what is the error?
12:37:09 <lisppaste2> toast annotated #19157 with "the error" at http://paste.lisp.org/display/19157#3
12:37:39 <Cale-work> oh
12:37:52 <Cale-work> perhaps you want a different type for valeurAttribut
12:38:07 <Cale-work> or perhaps you want a different type for the function which calls it
12:38:21 <}ElectrowolF{> hmm
12:38:48 <toast> ^^
12:38:50 <}ElectrowolF{> well, can't realy make a clear idea about how it's supposed to work with the current documentation.. or my lvl of haskell is just too low ;-)
12:38:57 <}ElectrowolF{> thanks for the help anyway
12:39:13 <lisppaste2> Cale annotated #19157 with "takes a (Maybe ACTION)" at http://paste.lisp.org/display/19157#4
12:39:17 <toast> i bet i need to read the manual a little more
12:39:42 <}ElectrowolF{> or whack yourself with it.. multie purpose..
12:39:51 <Cale-work> toast: try that one?
12:41:17 <toast> ERROR - Undefined variable "bourse"      
12:41:25 * toast gone reading
12:41:55 <Cale-work> well, it got rid of that problem anyway
12:42:59 <toast> Action (Symbole "MSFT") [Prix 54.56,Changement 0.69,Historique [55.33,56.23,54.0,57.0,54.19],Beta 1.28,Nom "Microsoft Corporation",Place "NASDAQ",RatioPE 31.91] 
12:43:19 <toast> works
12:43:20 <toast> Just (Action (Symbole "MSFT") [Prix 54.56,Changement 0.69,Historique [55.33,56.23,54.0,57.0,54.19],Beta 1.28,Nom "Microsoft Corporation",Place "NASDAQ",RatioPE 31.91]) 
12:43:21 <toast> don'T
12:50:03 <vincenz> toast: what is this for?
12:56:00 <Cale-work> toast: well, sure, only one of those could work in any given context. If you have a value of type (Maybe t), you have to unwrap it in order to use it with a function which takes a value of type t, and in doing so, you should deal with the case where the (Maybe t) is Nothing, as well as the case when it is (Just x) 
12:56:39 <Cale-work> To do this, you use a 'case' expression, or the 'maybe' function, or the monad operations for the Maybe type.
12:58:10 <norpan> or the "maybe" functino from the Prelude
12:58:17 <Cale-work> I said that :)
12:58:25 <norpan> oh, so you did
13:07:14 <jip> @type maybe
13:07:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:07:27 <jip> > maybe Nothing
13:07:28 <lambdabot>   add an instance declaration for (Show ((a -> Maybe a1) -> Maybe a -> Maybe a1))
13:07:40 <Cale-work> > maybe 0 id Nothing
13:07:41 <lambdabot> 0
13:07:45 <Cale-work> > maybe 0 id (Just 5)
13:07:46 <lambdabot> 5
13:22:43 <vincenz> isn't chalmers home of a haskell impl?
13:22:59 * vincenz remembers something aobut chalmers and functional programming and can't remember
13:24:58 <mahogny> Hughes is here among others
13:25:13 <mahogny> but we have a quite big group devoted to functional programming and programming logic
13:25:57 <vincenz> mahogny: you're at chalmers??
13:26:02 <mahogny> yes
13:26:23 <mahogny> surprised? :)
13:26:25 * vincenz shakeks
13:26:31 <toast> how come, ive read all my class notes, made the labo's etc
13:26:33 <vincenz> just that I'm in contact with someone from there
13:26:47 <toast> but i have a biggass homework and i can't figure out how to do it :/
13:27:04 <mahogny> vincenz, well, I'm not a phd in that field. heh. I figured the best way to get FP going is by going industry, not academics
13:27:19 <toast> tut's and notes just give extremly simple exemple and after ur supposed to be an haskell coder :
13:27:20 <toast> :/
13:27:31 <toast> bullocks
13:27:39 * xerox feels toast 
13:27:49 <bolrod> O_o!
13:27:54 <mahogny> toast, the step from courses to real world FP is quite huge
13:28:20 <jip> what is real world FP?
13:28:34 <bolrod> what is real world?
13:28:41 <toast> what is real
13:28:45 <mahogny> real world... is monads up your ass :)
13:28:49 <bolrod> 8)
13:29:01 <bolrod> what is?
13:29:09 <toast> what ?!
13:29:13 <mahogny> ?
13:29:13 <bolrod> !
13:29:16 <bolrod> haha
13:29:17 <mahogny> :o
13:29:20 <mahogny> (nil)
13:29:31 <bolrod> > head undefined
13:29:31 <lambdabot> Add a type signature
13:29:36 <bolrod> > head undefined::String
13:29:36 <lambdabot> Undefined
13:29:41 <bolrod> Wow!
13:29:44 <bolrod> we got lambdabot back?
13:29:56 <bolrod> @id /me is back!!
13:29:56 * lambdabot is back!!
13:30:04 <bolrod> yay \o/
13:30:25 <toast> @id /me beat bolrod with haskell tuts
13:30:25 * lambdabot beat bolrod with haskell tuts
13:30:31 <bolrod> >:(
13:31:40 <bolrod> @. elite . id toast is not cool
13:31:40 <lambdabot> compose module failed: Parse error: "toast"
13:31:46 <bolrod> @. elite . id "toast is not cool"
13:31:46 <lambdabot> compose module failed: Parse error: "\"toast"
13:31:50 <bolrod> argh
13:31:57 <bolrod> @. elite . eval id "toast is not cool"
13:31:58 <lambdabot> "t0Ast iS nOt CoOl"
13:32:04 <bolrod> >_>
13:32:25 <toast> >:(
13:32:28 <Muad_Dib> bolrod: how was the exam?
13:33:22 <bolrod> was ok
13:33:33 <bolrod> not too difficult
13:33:42 <bolrod> stupid multiple choice questions though
13:34:06 <bolrod> who wants to define tails with   map reverse . reverse . inits . reverse
13:34:07 <bolrod> O_o
13:34:25 <xerox> nice :-)
13:34:27 <bolrod> if you're going to be that stupid... at least define inits with tails, since tails is about 1000 times faster then inits
13:34:43 <bolrod> if not a billion times 
13:34:57 <bolrod> since the inits was defined with clunky map (x:)
13:35:33 <bolrod> and some stupid question where they ask.  'which statement is true'
13:35:45 <bolrod> and there be alot of really difficult looking statements
13:35:56 <bolrod> and one where it sais   'return a  is the same as  do return a'
13:35:57 <bolrod> O_o
13:36:41 <Muad_Dib> bolrod; hehe, and still at least half will fail I bet :P
13:37:00 <bolrod> haha
13:37:10 <bolrod> in other news:  how to get rid of a squirel   http://www.flabber.nl/archief/015953.php
13:37:14 <bolrod> :x
13:37:36 <bolrod> how do you write that ;/
13:38:33 <bolrod> squirrel
13:38:49 <bolrod> Muad_Dib: did you fail a FP test? ;)
13:40:09 <Muad_Dib> nope
13:40:29 <Muad_Dib> I wouldn't dare too, even though I'm not an FP guru (c:=
13:41:11 <bolrod> hehe
13:41:18 <bolrod> you're not?
13:41:29 <bolrod> you should be ashamed of yourself ;p
13:41:38 <Muad_Dib> Infact, I rarely use haskell at all 
13:41:48 <bolrod> oehh
13:41:56 <araujo> Burn him!
13:41:58 <araujo> :-)
13:42:02 <bolrod> He's a witch!
13:42:22 <Muad_Dib> A spy!
13:42:46 <jip> yyyyyyyYYYESS! map viewer works! i can see the "DROPZONE" title screen logo!
13:42:50 <bolrod> throw em in the water with a stone around his engles !  if he's a witch.. he'll float!
13:42:54 <bolrod> enkles
13:43:02 <Cale-work> jip: make a screenshot
13:43:05 <bolrod> jip: nice
13:43:32 <bolrod> blah.. monty python is cool 8)
13:43:38 <bolrod> BURRRRRN ERRRR
13:43:58 <}ElectrowolF{> :?
13:44:09 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:09 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:13 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:16 <mahogny> not again
13:44:17 <bolrod> BAN!
13:44:17 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:23 <}ElectrowolF{> lol bolrod
13:44:28 <}ElectrowolF{> all the FP students here
13:44:30 <}ElectrowolF{> getting filled up
13:44:36 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:37 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:37 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:44 <jip> omg
13:44:44 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:45 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:49 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:51 <jip> musasabi: 
13:44:53 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:44:57 <norpan> ops please
13:44:57 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:45:01 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:45:07 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:45:07 <}ElectrowolF{> there are no ops.. >_>
13:45:11 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:45:12 <bolrod> @get-shapr
13:45:13 <lambdabot> shapr!!
13:45:15 <atwork> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
13:45:29 <bolrod> argh
13:45:39 <araujo> This is stup√≠d.
13:45:44 <bolrod> can only find the monthy python Witch sketch with drawings
13:46:09 <}ElectrowolF{> bolrod: nicely working on your wxcal? :P
13:46:10 <bolrod> ahhh
13:46:11 * HedgeMage peeks in
13:46:27 <bolrod> }ElectrowolF{: who are you? ;)
13:46:30 <jip> HedgeMage: you missed it
13:46:33 <HedgeMage> ahh
13:46:42 <}ElectrowolF{> someone who most likely fails the exam >_>
13:46:51 <jip> HedgeMage: but check out this screenshot while you are here
13:46:53 <jip> Cale: here you go:
13:47:08 <bolrod> }ElectrowolF{: you did?
13:47:26 <bolrod> and what about the first one?
13:47:26 <Muad_Dib> Foei!
13:47:27 <}ElectrowolF{> and i got a 10 avg for practical... but suck at theorie *spelling*
13:47:27 <RHE123> bolrod: who are you ? :P
13:47:33 <}ElectrowolF{> 4.5 for the first one, so no use
13:47:35 <HedgeMage> jip: screenshot of what?
13:47:36 <jip> http://img509.imageshack.us/img509/2649/dropzonetitlemap5ee.png
13:47:51 <jip> Cale-work: there it is
13:48:00 <bolrod> http://youtube.com/watch?v=qTj1dP2KyQ8&search=monty%20python%20witch  << this is SOOOOOOOOOO COOOOOOOOOOOOL
13:48:05 <Cale-work> coming along nicely :)
13:48:26 <}ElectrowolF{> so still trying to keep my 10 avg for practical..
13:48:26 <jip> Cale-work: yeah, but it's sloooooooooow, i don't know what i'm gonna do :\
13:48:32 <}ElectrowolF{> hoping the best for the exam..
13:48:36 <jip> HedgeMage: it's a haskell gameboy emulator :D
13:48:37 <JohnnyL> jip, is that the gmeboy emulator?
13:48:45 <jip> JohnnyL: jep
13:48:53 <xerox> @karma+ jip -- that one, and nice one!
13:48:53 <lambdabot> jip's karma raised to 1.
13:49:29 <HedgeMage> jip: cute
13:49:34 <HedgeMage> see ya all later
13:49:44 <JohnnyL> gb has alot of registers.
13:49:45 <JohnnyL> :)
13:50:21 <bolrod> seriously 8)   that monty python is the best logic reasoning ever :D
13:50:22 <jip> JohnnyL: just 8 8-bit and 2 16-bit :)
13:50:25 <Cale-work> jip: is it any faster when the register display/disassembly is turned off?
13:51:04 <Cale-work> JohnnyL: That's nothing compared to the Cell :)
13:51:21 <JohnnyL> Calework, i know the Cell looks like a 6502 on major steroids.
13:51:21 <jip> Cale-work: i'm not sure yet, since if i turn it off then lazy evaluation will prevent anything from happening :) but i'm gonna implement the real display now, so when that's working i'll be able to shut off all of the debug panels, and then i'll see how performance really is
13:52:06 <bolrod> }ElectrowolF{: how good was your first test?
13:52:19 <bolrod> }ElectrowolF{: you need to have >=5 avg on the tests
13:52:24 <JohnnyL> jip, what gui are you using?
13:52:30 <jip> JohnnyL: gtk2hs
13:52:35 <Cale-work> JohnnyL: 128 x 128bit registers on each of 8 SPUs
13:52:38 <JohnnyL> cool
13:52:50 <JohnnyL> Cale, wow.
13:52:59 <JohnnyL> Cale, when's that expected?
13:53:04 <JohnnyL> I assume they will make a computer version too.
13:53:25 <}ElectrowolF{> i know bolrod
13:53:29 <}ElectrowolF{> got a 4.5 on the first one
13:53:33 <jip> JohnnyL: in case you missed, it here is a view of the tile patterns: http://img63.imageshack.us/img63/5337/dropzonetiles26qp.png
13:53:49 <}ElectrowolF{> and if t2 > t1 then t.total = t2
13:54:05 <}ElectrowolF{> or rather
13:54:06 <musasabi> home
13:54:25 <bolrod> oh
13:54:26 <JohnnyL> jip, thats cool.
13:55:22 <}ElectrowolF{> max (T2, (0.4*T1 + 0.6*T2), A)
13:55:30 <}ElectrowolF{> is the grade calculation
13:55:31 <bolrod> I See
13:55:42 <}ElectrowolF{> and i can't do A
13:55:46 <bolrod> because?
13:55:56 <}ElectrowolF{> didn't go to enough workcolleges ;p
13:56:06 <bolrod> how many did you miss?
13:56:09 <}ElectrowolF{> 10?
13:56:11 <RHE123> our stupid alex :P
13:56:12 <bolrod> O-o
13:56:15 <bolrod> oooookkkkkkk.........
13:56:18 <}ElectrowolF{> 15?
13:56:19 <}ElectrowolF{> dunno
13:56:22 <}ElectrowolF{> in the range of that
13:56:36 <bolrod> if you missed 2 too many..  you could probably do the re exam
13:56:40 <bolrod> though if you missed ALL
13:56:44 <bolrod> *cough* *cough*
13:56:47 <}ElectrowolF{> didn't miss all
13:56:49 <RHE123> he didn't missed all :)
13:56:54 <Muad_Dib> whats the A?
13:56:54 <}ElectrowolF{> went to a few
13:56:57 <}ElectrowolF{> but it was so early
13:56:59 <RHE123> i saw him :P
13:57:13 <}ElectrowolF{> Muad_Dib: Aanvullendetoets
13:57:13 <RHE123> a re-exam
13:57:30 <bolrod> who is }ElectrowolF{ then :)
13:57:42 <}ElectrowolF{> who is bolrod then?
13:57:47 <}ElectrowolF{> :P
13:58:07 <bolrod> I'm me
13:58:08 <bolrod> duhh
13:58:10 <bolrod> -.-
13:58:18 <Muad_Dib> He's tim or so sais his /whois :)
13:58:22 <}ElectrowolF{> [19:22:09:54] * doaitse (n=doaitse@212-182-128-153.dsl.ip.tiscali.nl) Quit ("Computer goes to sleep!")   <- atleast that is no guess, heh
13:58:42 <bolrod> doaitse.. hrm... yes..
13:59:00 <bolrod> never noticed em
13:59:05 <}ElectrowolF{> anyway, off playing with some more where's
13:59:15 <bolrod> and who else would think of that name ;)
13:59:26 <bolrod> riight
13:59:43 <Muad_Dib> it was his first time here I think
14:00:07 <bolrod> wahahaha
14:00:21 <bolrod> if I may quote from the logs
14:00:22 <bolrod> #haskell.log:11:45:50< shapr> doaitse: Greetings
14:00:22 <bolrod> #haskell.log:11:46:43< shapr> doaitse: I'd enjoy discussing arrows versus attribute grammars with you when you have some spare time.
14:00:25 <bolrod> #haskell.log:11:48:00< doaitse> I am just trying to find out how this IRC works
14:00:27 <bolrod> #haskell.log:11:50:27< shapr> doaitse: Simon Marlow and Manuel Chakravarty are here sometimes, and you just missed John Hughes.
14:00:30 <bolrod> #haskell.log:11:51:13< doaitse> My first impression is that you can spend a lot of time here
14:00:33 <bolrod> :x
14:00:59 <bolrod> his first time here today?!
14:01:03 <bolrod> hrm..
14:01:22 <Muad_Dib> I agree with his statement though, you can spend way to much time on here
14:01:30 <RHE123> stefan is sometimes here too :)
14:01:31 <bolrod> you can yes
14:01:36 <bolrod> not lately
14:01:40 <bolrod> I know.. I have talked to him
14:01:46 <bolrod> #haskell.log:11:58:21< doaitse> I think it is about time to examine 100+ FP first year students this afternoon, and mark the exams before spending too much time here.
14:01:52 <bolrod> thats thoughtfull of em ;)
14:02:03 <RHE123> hehe
14:02:13 <Cale-work> JohnnyL: It looks like IBM will be marketing a Blade server in Q2 2006 which will use Cell processors.
14:02:27 <Muad_Dib> hehe, he was wondering how many of you he could make full of chagrin :)
14:02:34 <bolrod> you read about AMD wanting to reverse Hyperthread processors?\
14:02:40 <davidhouse> @localtime bolrod
14:02:42 <bolrod> like.. having more cores show up as one virtual processor? ;)
14:03:03 <davidhouse> @help @localtime
14:03:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:03:07 <bolrod> Wed Apr 19 23:02:45 CEST 2006
14:03:11 <bolrod> exact
14:03:23 <sethk> bolrod, that's interesting
14:03:24 <davidhouse> bolrod: wanted to see how along ago those quotes were.
14:03:26 <}ElectrowolF{> bolrod: did
14:03:40 <JohnnyL> Cale, neat
14:04:09 <}ElectrowolF{> you think i can get a better grade by helping doaitse get familiar with irc? :P
14:04:18 <RHE123> LoL
14:04:19 <bolrod> I don't think so
14:04:23 <}ElectrowolF{> damnit..
14:04:24 <RHE123> you can try ;)
14:04:44 <RHE123> it will cost you a lot of time, with (i suppose) nothing in return :P
14:04:57 <}ElectrowolF{> do return a && return a
14:04:58 <davidhouse> }ElectrowolF{, bolrod, which university are you at?
14:05:03 <}ElectrowolF{> UU
14:05:09 <RHE123> Utrecht :)
14:05:13 <}ElectrowolF{> same as RHE123
14:05:15 <}ElectrowolF{> and Muad_Dib
14:05:20 <bolrod> same as NameTab
14:05:22 <}ElectrowolF{> and robokop, but he left
14:05:24 <}ElectrowolF{> that too
14:05:27 <davidhouse> that's why i asked.
14:05:28 <bolrod> and doaitse
14:05:31 <bolrod> ;)
14:05:33 <}ElectrowolF{> nametab = ?
14:05:41 <}ElectrowolF{> we just had our final exam today..
14:05:43 <cge> The obvious thing for doaitse to do would have been to give the exam (I assume it is written), and spend time on IRC _while_ the students were taking it.
14:05:48 <bolrod> nametab is cousin of Muad_Dib 
14:05:49 <}ElectrowolF{> which was a pain in the ass
14:05:50 <bolrod> or so I heard
14:06:02 <Muad_Dib> thats what I heard as well
14:06:16 <bolrod> cge: nah.. he just sits on the desk
14:06:19 <}ElectrowolF{> still got to hand in our practical work in at fryday
14:06:49 <RHE123> have to make a stupid calendar application with wxHaskell UI..
14:06:58 <}ElectrowolF{> gui even
14:06:59 <bolrod> I don't really like wxHaskell ;/
14:07:19 <Muad_Dib> bolrod: for any particular reason?
14:07:23 <bolrod> no
14:07:28 <bolrod> you got to hate something
14:07:33 <}ElectrowolF{> hehe
14:07:41 <}ElectrowolF{> wx is ok, imo
14:07:43 <Cale-work> Gtk2Hs seems nicer
14:07:57 <}ElectrowolF{> we are not allowed to use that
14:08:00 <cge> bolrod, yes, most of my professors did that. But some would leave, and one would actually work out the solutions while we were taking the final, and keep telling us about all of the typos and problems he was finding...
14:08:05 <}ElectrowolF{> the assignment is in wxhaskell
14:08:06 <bolrod> mamybe I'm crazy enough to learn some more haskell and improve wxHaskell
14:08:11 <bolrod> *cough* *cough*
14:08:32 <bolrod> Ohyeah!
14:08:40 <bolrod> the whole test was in english
14:08:43 <}ElectrowolF{> he found some errors ;p
14:08:44 <}ElectrowolF{> haha
14:08:44 <bolrod> but in one question
14:08:46 <}ElectrowolF{> not it wasn't
14:08:47 <}ElectrowolF{> :P
14:08:51 <bolrod> he just went on in Dutch
14:08:57 <bolrod> really funny :)
14:09:17 <RHE123> at first i didn't understand, my full mind was english at that moment :P
14:09:25 <}ElectrowolF{> yer.. was kinda weird thou.. read the sentence a few times before i noticed it was dutch >_>
14:09:25 <bolrod> I'm used to it ;)
14:09:35 <bolrod> roaming dutch and english channels at the time
14:09:42 <}ElectrowolF{> mostly english here
14:09:48 <bolrod> so I don't even notice transitions from english to dutch mostly
14:09:51 <}ElectrowolF{> and after 8 years of irc you kinda get used to it..
14:10:11 <bolrod> not 8 years here..  but still
14:10:21 <bolrod> sometimes I'll just talk english in a dutch channel without noticing though
14:10:22 <}ElectrowolF{> i mostly talk english.. even in dutch channels
14:10:22 <}ElectrowolF{> ;-)
14:10:30 <RHE123> only channel on IRC i visit daily is #fotografie on tweakers.net :)
14:10:31 <}ElectrowolF{> english is easyer...
14:10:35 <}ElectrowolF{> hehe
14:10:44 * bolrod hits }ElectrowolF{ 
14:10:51 * }ElectrowolF{ pikes bolrod
14:11:03 <bolrod> who are you?.. I could really hit you >:)
14:11:09 <}ElectrowolF{> i'd hit you back
14:11:11 <}ElectrowolF{> :P
14:11:19 <Muad_Dib> tell me when so I can view it all ;)
14:11:19 <bolrod> ofcourse.. you musn't know who I am.. since that would destroy the surprise attack
14:11:32 <bolrod> muahahah >:)
14:11:35 <RHE123> (electrowolf is Alexander Melchior,  :P:P )
14:11:40 <bolrod> :O
14:11:41 <bolrod> lets see
14:11:41 <jip> it's ok for module names to have a number in them, right?
14:11:52 <bolrod> aha >:)
14:12:00 <Muad_Dib> btw, offtopic talk officially goes into #haskell-blah :D
14:12:01 <}ElectrowolF{> tsss, nr robin eggenkamp (see http://www.robineggenkamp.nl )
14:12:08 <Muad_Dib> and now, good night all
14:12:12 <bolrod> }ElectrowolF{: its in his whois
14:12:16 <RHE123> hey, there is a photo of me :P
14:12:47 <}ElectrowolF{> hmm
14:13:01 <}ElectrowolF{> anyway, gotta fix this stringlistgenerator..
14:13:09 <bolrod> stringlist?
14:13:11 <bolrod> O_o
14:13:23 <}ElectrowolF{> so i can get a list of strings.. for e.q. week numbers
14:13:29 <}ElectrowolF{> not gonna write it all down
14:13:32 <}ElectrowolF{> nor for years
14:13:43 <bolrod> or you could make a nice datatype of it >:)
14:13:55 <}ElectrowolF{> nah
14:14:06 <}ElectrowolF{> doesn't add anything imho
14:14:33 <bolrod> anyway..  gotta try get 10 avg on assignments
14:14:36 <bolrod> if thats still possible
14:15:54 <}ElectrowolF{> what did you get for the last 2?
14:15:55 <bolrod> oi.. it is possible
14:15:56 <RHE123> i can't get an 10 avg :(
14:16:05 <bolrod> first: 8.6   2nd : 10
14:16:12 <}ElectrowolF{> i can get a 10 avg.. even if i get a 9.2 on this one..
14:16:14 <RHE123> had a 8.3 for the first :)
14:16:26 <}ElectrowolF{> 9.5, 9,7
14:16:37 <bolrod> hello doaitse 
14:16:43 <}ElectrowolF{> wb doaitse ;p
14:17:15 <bolrod> bwah.. I'm tired *Yawn*
14:17:21 <}ElectrowolF{> hehe
14:17:45 <}ElectrowolF{> now to figure something out to convert a list to a string.. hmm shouldn't be too hard i think
14:17:58 <RHE123> it's save again :P
14:18:00 <bolrod> he got scared
14:18:02 <bolrod> safe ;)
14:18:06 <}ElectrowolF{> poor prof..
14:18:12 <davidhouse> what filetypes can be uploaded to the haskell wiki?
14:18:13 <bolrod> map show ?
14:18:25 <davidhouse> > show [1..5]
14:18:26 <lambdabot> "[1,2,3,4,5]"
14:18:27 <bolrod> show ?
14:18:31 <}ElectrowolF{> yer true
14:18:38 <bolrod> > concat (map show [1,2,3,4])
14:18:38 <}ElectrowolF{> but got to add some stuff between it
14:18:38 <lambdabot> "1234"
14:18:48 <bolrod> concatMap show [1,2,3,4]
14:18:51 <bolrod> > concatMap show [1,2,3,4]
14:18:52 <lambdabot> "1234"
14:18:58 <bolrod> not that hard >_>
14:19:04 <}ElectrowolF{> > foldr " ," show [1..5]
14:19:05 <lambdabot> Couldn't match `a -> b -> b' against `[Char]'
14:19:09 <}ElectrowolF{> :P
14:19:14 <bolrod>  no no no !! 
14:19:18 <}ElectrowolF{> > show foldr " ," [1..5]
14:19:19 <bolrod> its good doaitse aint here
14:19:19 <lambdabot> Couldn't match `[Char]' against `t -> t1 -> t2'
14:19:21 <}ElectrowolF{> gah
14:19:24 <}ElectrowolF{> yer i know
14:19:34 <int-e> > concat $ intersperse "|" $ map show [1..5]
14:19:35 <davidhouse> }ElectrowolF{: just use show.
14:19:36 <lambdabot> "1|2|3|4|5"
14:19:37 <davidhouse> > show [1..5]
14:19:38 <lambdabot> "[1,2,3,4,5]"
14:19:50 <bolrod> I just wanted to use that >_>
14:19:59 <davidhouse> > concat $ intersperse ", " $ map show [1..5]
14:20:00 <lambdabot> "1, 2, 3, 4, 5"
14:20:12 <davidhouse> if you insist on folding:
14:20:22 <bolrod> use lambda notation
14:20:27 <bolrod> its way easier
14:20:29 <}ElectrowolF{> > concat $ intersperse "/", /"" $ map show [1..5]
14:20:30 <lambdabot>  parse error on input `,'
14:20:33 <}ElectrowolF{> gah
14:20:35 <davidhouse> > foldl (\s i -> s ++ ", " ++ show i) "" [1..5]
14:20:36 <lambdabot> ", 1, 2, 3, 4, 5"
14:20:43 <davidhouse> close.
14:20:43 <bolrod> omg..  escape char is NOT /
14:20:45 <bolrod> you twit!
14:20:51 * }ElectrowolF{ runs in fear
14:21:00 <bolrod> you should
14:21:09 <davidhouse> > foldl1 (\s i -> s ++ ", " ++ show i) [1..5]
14:21:10 <lambdabot>  add an instance declaration for (Num [Char])
14:21:10 <lambdabot>   In an arithmetic sequence: [1 .. 5]
14:21:24 <}ElectrowolF{> nice bot btw
14:21:24 <bolrod> oh please... don't make this more difficult then it is
14:21:28 <davidhouse> > foldl1 (\s i -> s ++ ", " ++ show i) (show 1) [2..5]
14:21:29 <lambdabot> Couldn't match `[a]' against `t -> t1'
14:21:37 <davidhouse> > foldl (\s i -> s ++ ", " ++ show i) (show 1) [2..5]
14:21:38 <lambdabot> "1, 2, 3, 4, 5"
14:21:41 <davidhouse> there.
14:21:46 <}ElectrowolF{> i don't need foldl or foldr
14:22:00 <}ElectrowolF{> just want to make a list of 1", "2", "3", etc etc
14:22:10 <davidhouse> > map show [1..5]
14:22:11 <lambdabot> ["1","2","3","4","5"]
14:22:17 <}ElectrowolF{> lol
14:22:28 <davidhouse> > show $ map show [1..5]
14:22:29 <lambdabot> "[\"1\",\"2\",\"3\",\"4\",\"5\"]"
14:22:56 <bolrod> > [1,2,3,4] >>= show
14:22:57 <lambdabot> "1234"
14:23:17 <}ElectrowolF{> should find some more info on >>= anyway
14:23:22 <bolrod> > [1,2,3,4] >>= (\x -> show x ++ ", ")
14:23:23 <lambdabot> "1, 2, 3, 4, "
14:23:37 <bolrod> http://www.nomaware.com/monads/html/listmonad.html
14:23:48 <Cale-work> @oldwiki MonadsAsContainers
14:23:49 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
14:23:54 <Cale-work> (read that :)
14:23:54 <davidhouse> }ElectrowolF{: >>= is monads, doubt if you've come across those yet.
14:24:09 <davidhouse> yes, read Cale's stuff :)
14:24:15 <bolrod> yes.. I still need to
14:24:16 <bolrod> :)
14:24:23 <}ElectrowolF{> hmm
14:24:26 <davidhouse> then write your own monad and impress your profs. :)
14:24:31 <}ElectrowolF{> hehe
14:24:42 <bolrod> too bad its all over already
14:24:54 <bolrod> and he blew it by being abscent 15 time
14:24:56 <bolrod> times
14:24:56 <}ElectrowolF{> just to explain, i want to generate a list of years, or days, as a string, for a dropdownlist
14:24:56 <int-e> If you have a bunch of code that manipulates a data structure built from standard constructors and later decide you want to encapsulate it in a newtype (for whatever reason - either for hiding the definition from the user or to pacify the type checker in the presence of functional dependencies), you have to add the 'constructor' and 'destructor' in many places, which is especially awkward where it happens in partial applications. Besides using
14:24:56 <int-e>  ghc's deriving for newtypes, are there any tricks to reduce that work?
14:25:12 <bolrod> > take 4 [2006..]
14:25:13 <lambdabot> [2006,2007,2008,2009]
14:25:16 <}ElectrowolF{> and i feel dirty if i'd write it all down
14:25:18 <bolrod> ?
14:25:27 <bolrod> like that?
14:25:31 <}ElectrowolF{> no
14:25:44 <}ElectrowolF{> ["","2000","2001","2002","2003","2004",
14:25:47 <}ElectrowolF{> like that
14:25:51 <bolrod> -.-
14:25:53 <bolrod> seriously
14:25:54 <Cale-work> int-e: the use of typeclasses
14:25:57 <}ElectrowolF{> seriously
14:25:59 <bolrod> > take 4 (map show [2006..])
14:26:00 <lambdabot> ["2006","2007","2008","2009"]
14:26:09 <bolrod> you should've known
14:26:25 <}ElectrowolF{> this is why i'm afraid of not passing the exam.. :P
14:26:49 <bolrod> @id Just learn
14:26:50 <lambdabot> Just learn
14:27:05 <bolrod> @id /me will teach you
14:27:05 * lambdabot will teach you
14:27:10 <Cale-work> int-e: but of course, without foresight into the need to generalise/abstract later, you'll end up doing a bunch of work.
14:27:12 <}ElectrowolF{> might be for some people.. but i just plainly suck at programming.. :(
14:27:12 <jip> @type firstElem
14:27:13 <lambdabot> Not in scope: `firstElem'
14:27:29 <bolrod> at programing in general? O_o?
14:27:45 <}ElectrowolF{> yer
14:27:48 <jip> is there a function f :: (a -> Bool) -> [a] -> a
14:27:50 <}ElectrowolF{> failed imp the 1st time too
14:27:55 <bolrod> ;/
14:27:56 <davidhouse> jip, hoogle is your friend :)
14:27:57 <jip> that returns the first element that matches the condition?
14:28:00 <davidhouse> @hoogle (a -> Bool) -> [a] -> a
14:28:01 <lambdabot> No matches, try a more general search
14:28:06 <Cale-work> @type find
14:28:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:28:10 <jip> davidhouse: no, Cale-work is my friend =D
14:28:13 <bolrod> jip: head.dropWhile
14:28:15 <bolrod> ?
14:28:16 <int-e> Cale-work: well, sadly (at least in this context), many of the functions in the base libs aren't defined in type classes.
14:28:21 <davidhouse> bolrod: that would work too.
14:28:32 <bolrod> ofcourse it would ;/
14:28:43 <davidhouse> head . dropWhile would error if nothing was found, though
14:28:49 <davidhouse> but find just returns Nothing.
14:28:54 <bolrod> take 1. dropWhile
14:28:55 <davidhouse> hell, this is exactly what Maybe is for. so use it.
14:28:56 <bolrod> then
14:29:06 <davidhouse> > take 1 []
14:29:07 <lambdabot> Add a type signature
14:29:07 <bolrod> > take 1 []
14:29:08 <lambdabot> Add a type signature
14:29:10 <bolrod> > take 1 [] :: Char
14:29:10 <davidhouse> erros.
14:29:11 <lambdabot> Couldn't match `Char' against `[a]'
14:29:15 <bolrod> -.-
14:29:16 <bolrod> no
14:29:17 <davidhouse> > take 1 [] :: String
14:29:17 <lambdabot> ""
14:29:21 <bolrod> it returns empty list
14:29:22 <davidhouse> true.
14:29:37 <}ElectrowolF{> concat ( [""] : map show [5..9] )
14:29:43 <}ElectrowolF{> > concat ( [""] : map show [5..9] )
14:29:43 <lambdabot> Couldn't match `[Char]' against `Char'
14:29:46 <}ElectrowolF{> hmm
14:29:51 <bolrod> seriously..
14:29:52 <}ElectrowolF{> gah
14:30:01 <}ElectrowolF{> hmm
14:30:17 <bolrod> > "" :concatMap show [5..9]
14:30:18 <lambdabot> Couldn't match `[Char]' against `Char'
14:30:23 <}ElectrowolF{> just let me mess around ;-0
14:30:37 <bolrod> > "" :map show [5..9]
14:30:38 <lambdabot> ["","5","6","7","8","9"]
14:30:43 <davidhouse> > '' :concatMap show [5..9]
14:30:44 <lambdabot>  lexical error in string/character literal
14:30:54 <xerox> > [5..9] >>= show
14:30:54 <davidhouse> > '' : (concatMap show [5..9])
14:30:55 <lambdabot> "56789"
14:30:55 <lambdabot>  lexical error in string/character literal
14:31:01 <xerox> ^_^
14:31:03 <davidhouse> stupid lambdabot.
14:31:10 <Cale-work> > [5..9] >>= show
14:31:12 <lambdabot> "56789"
14:31:20 <Cale-work> > concatMap show [5..9]
14:31:21 <lambdabot> "56789"
14:31:23 <bolrod> >"">>=\x-> x:[5..9]>>=show
14:31:24 <xerox> xerox: 1, cale: work!
14:31:30 <bolrod> > "">>=\x-> x:[5..9]>>=show
14:31:31 <lambdabot>  parse error on input `->'
14:31:41 <bolrod> bwah... watever.
14:32:03 <Cale-work> xerox: tomorrow :)
14:32:11 <xerox> (-:
14:32:17 <xerox> I.e. Cale-fun
14:32:18 <Cale-uni> It's late
14:32:31 <bolrod> > do {x<-"rofl" ; y<-"lol";z<-"omg"; [x,y,z]}
14:32:32 <lambdabot> "rlorlmrlgrooromrogrlorlmrlgoloolmolgooooomoogoloolmolgfloflmflgfoofomfogfloflmflgllollmllgloolomlogllollmllg"
14:32:40 <Cale-uni> I can't go home yet since I live in another city
14:32:48 <}ElectrowolF{> gah
14:32:53 <}ElectrowolF{> even forgot how to spell intersperce
14:33:00 <bolrod> intersperse
14:33:00 <RHE123> c => s
14:33:20 <bolrod> yeah.. inglisj is mutsj eezyer
14:33:31 <}ElectrowolF{> it is.. :P
14:33:32 <davidhouse> > do { x <- [1..3]; y <- [4..6]; show x ++ " " ++ show y ++ "|" }
14:33:34 <lambdabot> "1 4|1 5|1 6|2 4|2 5|2 6|3 4|3 5|3 6|"
14:33:35 <bolrod> ofcurz
14:33:45 <mahogny> bolrod, I love dutch <3
14:33:57 <int-e> Cale-uni: anyway, thanks. I'm more confident now that I'm not missing something obvious :)
14:34:00 <bolrod> the language?
14:34:02 <bolrod> or the people?
14:34:15 <mahogny> bolrod, the language. I have a sick interest in linguistics ;)
14:34:26 <bolrod> probably...  Dutch is hella lame
14:34:39 <mahogny> lol
14:34:49 <RHE123> mahogny: can you speak some dutch for us? ;)
14:35:08 <mahogny> RHE123, no. but I can read it. which is quite ok considering I've never studied it :)
14:35:16 <bolrod> thats sick
14:35:18 <RHE123> ah well :)
14:35:26 <mahogny> I know german and english. it's not very far from
14:35:30 <}ElectrowolF{> try japanese
14:35:34 <bolrod> my cousin can talk and understand it.. but can't write it properly :)
14:35:34 <mahogny> }ElectrowolF{, hai? :)
14:35:40 <RHE123> mahogny: which language can you understand?
14:35:41 <bolrod> and can read it a bit
14:35:43 <}ElectrowolF{> hontoni?
14:35:45 <}ElectrowolF{> :P
14:35:47 <mahogny> }ElectrowolF{, e
14:35:50 <mahogny> :)
14:35:52 <}ElectrowolF{> ahh
14:36:06 <}ElectrowolF{> sodesuka *dunno if that's correct thou*
14:36:16 <mahogny> }ElectrowolF{, it is :)
14:36:19 <}ElectrowolF{> whoo
14:36:51 <RHE123> electro is better at japanese than haskell, hehe :)
14:36:56 <}ElectrowolF{> think so
14:36:56 <mahogny> RHE123, I can read some french, think I will learn it some day. I started a bit with finish and estonian but not much progress there. I know jap helpfully. but I'm mostly into the grammar, I seldom learn the words
14:36:57 <}ElectrowolF{> actualy
14:37:13 <}ElectrowolF{> ah
14:37:18 <}ElectrowolF{> i just watch anime..
14:37:20 <}ElectrowolF{> :P
14:37:22 <}ElectrowolF{> no grammer there
14:37:26 <}ElectrowolF{> should try it someday
14:37:27 <bolrod> grammar
14:37:29 <RHE123> quite good :)
14:37:34 * mahogny <3 grammar
14:37:40 <bolrod> >:
14:37:45 <}ElectrowolF{> i'm dyslectic too.. so that doesn't realy help
14:37:48 * bolrod is very bad at spelling
14:37:48 <bolrod> :]
14:37:51 <bolrod> oh ;)
14:37:53 <RHE123> a friend of my is a real language wonder
14:38:13 <RHE123> miracle should be better here :)
14:38:19 <mahogny> }ElectrowolF{, I have made my own version of swedish spelling that partially removes any dyslectic problems. really hated by everyone else here :)
14:38:30 <RHE123> whehe
14:38:31 <}ElectrowolF{> hehe
14:38:53 <}ElectrowolF{> mahogny: i got the luck that dutch has the same way of pronouncing romanji as japanese has
14:38:55 * mahogny would like to learn icelandic next
14:39:00 <mahogny> }ElectrowolF{, same here
14:39:14 <}ElectrowolF{> i want to learn irish
14:39:14 <}ElectrowolF{> :P
14:39:18 <RHE123> (she can understand dutch, english, french, german, irish, hebrew and even a little icelandic :P )
14:39:21 <bolrod> it deosn't matter how you wirte, as long as the frist and the last letter are on the rihgt spot
14:39:39 <mahogny> bolrod, lol
14:39:43 <}ElectrowolF{> not in japanese..
14:39:46 <}ElectrowolF{> maybe in english
14:39:49 <}ElectrowolF{> and dutch
14:39:52 <bolrod> mahogny: you didn't know that? ;)
14:40:09 <bolrod> we usually don't read the words per letter. But as a whole
14:40:22 <bolrod> so just the first and the last probably.. and the letters somewhere in between
14:40:22 <mahogny> bolrod, I did far before they released that report. soon they might even figure out that we can reverse words as well, and some people won't notice :)
14:40:37 <bolrod> Yeah
14:40:41 <mahogny> ehr. reverse *order of* words
14:40:41 <bolrod> especially the palindromes!
14:40:51 <}ElectrowolF{> :P
14:40:51 <bolrod> *hides*
14:40:54 <RHE123> hehe
14:40:59 <}ElectrowolF{> i'd notice.. i don't read so fast
14:41:04 <}ElectrowolF{> so i'm most likely like "eh?"
14:41:14 <}ElectrowolF{> i can read over misspelled words easely thou
14:41:19 <bolrod> dude..
14:41:27 <bolrod> do you know what a palindrome is?
14:41:27 <bolrod> ;)
14:41:28 <}ElectrowolF{> sweet
14:41:43 <bolrod>   palindrome
14:41:44 <bolrod>        n : a word or phrase that reads the same backward as forward
14:41:44 <}ElectrowolF{> erm, no
14:41:48 <bolrod> like  'lepel'
14:41:52 <}ElectrowolF{> ah
14:41:52 <bolrod> > reverse "lepel"
14:41:53 <lambdabot> "lepel"
14:41:53 <mahogny> }ElectrowolF{, it depends a bit on the type of person. I read one whole sentence at a time so I would miss it if I didn't enter proof reading mode
14:41:55 <bolrod> ;)
14:41:57 <bolrod> xD
14:42:09 <}ElectrowolF{> wish i could do that..
14:42:30 <mahogny> it is something you train yourself into. I doubt it comes naturally
14:42:53 <}ElectrowolF{> it won't with me, even if i tried
14:43:20 <mahogny> well, it's plain impossible for some people. mathematicians I think will have prob with it
14:43:22 <bolrod> someone I know is dyslectic.. managed to dial the wrong number 3 times in a row once :)
14:43:30 <mahogny> ouch. that bad?
14:43:33 <bolrod> 3 times the same wrong number ;)
14:43:36 <RHE123> > reverse "Koortsmeetsysteemstrook"
14:43:37 <lambdabot> "koortsmeetsysteemstrooK"
14:43:38 <bolrod> he told me :]
14:43:46 <mahogny> lol
14:43:52 <}ElectrowolF{> i'm not like that
14:44:05 <}ElectrowolF{> but sometimes i read a word.. and again.. and agian.. and then i see what it ment to say
14:44:07 <RHE123> Koortsmeetsysteemstrook is a real dutch word :)
14:44:08 <mahogny> yeah, there are several levels of dyslectism
14:44:27 <bolrod> RHE123: look up the longest palindrome 
14:44:28 <}ElectrowolF{> and i read it as an other word 3 times, without noticing, but the sentence is awkward then.. so i check it again and again ;p
14:44:37 <bolrod> it's a greek word I think
14:44:57 <RHE123> http://www.norvig.com/pal2txt.html: this one is sick :)
14:44:58 <}ElectrowolF{> mahogny: level is not the right way of putting it
14:45:00 <bolrod> weren't there stories that were palindromes as a whole? ;)
14:45:03 <}ElectrowolF{> more like, diffrent versions
14:45:20 <mahogny> }ElectrowolF{, depends on abstraction. but I guess you are right
14:45:31 <bolrod> RHE123: that's probably computer generated
14:45:35 <bolrod> so not too sick
14:45:39 <RHE123> it is:)
14:46:05 <davidhouse> @hoogle Functor
14:46:06 <lambdabot> Prelude.Functor :: class Functor f
14:46:06 <lambdabot> Data.FunctorM :: module
14:46:06 <lambdabot> Data.FunctorM.FunctorM :: class FunctorM f
14:46:12 <davidhouse> @docs Prelude
14:46:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
14:46:13 <RHE123> look a thisone: http://www.palindromelist.com/longest.htm
14:46:31 <}ElectrowolF{> > concat [1..5]
14:46:32 <lambdabot>  add an instance declaration for (Num [a])
14:46:32 <lambdabot>   In an arithmetic sequence: [1 .. 5]
14:46:35 <}ElectrowolF{> aww
14:46:46 <}ElectrowolF{> ;p
14:46:47 <davidhouse> what would that do?
14:46:51 <}ElectrowolF{> nothing
14:47:01 <davidhouse> > Nothing -- doing nothing is easy
14:47:02 <lambdabot> Add a type signature
14:47:11 <davidhouse> > Nothing :: Maybe Bool -- doing nothing is easy
14:47:12 <lambdabot> Nothing
14:47:32 <}ElectrowolF{> > show [1..5]
14:47:33 <lambdabot> "[1,2,3,4,5]"
14:47:50 <bolrod> how about that sick place name in Wales
14:48:01 <bolrod> something lika  adshfhfugfdfsdvbdnbfhhfrjuuiiauisediadgfadg ?
14:48:03 <RHE123> ow yeah, thatone is reaallly sick
14:49:35 <bolrod> Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch
14:49:35 <bolrod> This is the name of a town in North Wales. The name translates as "The church of St. Mary in the hollow of white hazel trees near the rapid whirlpool by St. Tysilio's of the red cave
14:50:02 <bolrod> ofcourse!
14:50:09 <mahogny> ...are you kidding me?
14:50:21 <bolrod> nat rly
14:50:29 <mahogny> is that some irish wtf?
14:50:33 <bolrod> Wales
14:50:43 <mahogny> well. geography is not my subject :)
14:50:43 <bolrod> they even have that weird name on a sign
14:50:47 <bolrod> but a shortened one
14:50:59 <mahogny> omg. I gotta look closer at that language
14:51:03 <RHE123> Taumatawhakatangihangakoauauotamateaturipukakapikimaungahoronukupokaiwhenuakitanatahu
14:51:10 <RHE123> that's also a name of a city!
14:51:12 <bolrod> http://www.nwt.co.uk/english/anglesey/llanfairpg.htm
14:51:17 <RHE123> new sealand
14:51:25 <hey__> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
14:51:25 <hey__> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
14:51:25 <hey__> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
14:51:29 <bolrod> nat again
14:51:30 <hey__> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
14:51:33 <bolrod> ban all comcast!
14:51:33 <hey__> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
14:51:37 <hey__> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
14:51:39 <bolrod> f00k y00!!!!!!!!!!!!
14:51:41 --- mode: ChanServ set +o musasabi
14:51:41 <mahogny> I bet that guy codes VB
14:51:47 <heyy> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
14:51:47 <heyy> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
14:51:49 --- mode: musasabi set +b *!*n=people@*.hsd1.pa.comcast.net
14:51:49 --- kick: heyy was kicked by musasabi (musasabi)
14:51:51 <RHE123> the original name of Bangkok is Krungthepmahanakonbowornratanakosinmahintarayudyayamahadiloponopara-
14:51:51 <RHE123> tanarajthaniburiromudomrajniwesmahasatarnamornpimarnavatarsatitsakattiya-
14:51:51 <RHE123> visanukamphrasit.
14:51:58 <bolrod> :P
14:51:59 <davidhouse> "Krung Thep Mahanakhon Amon Rattanakosin Mahinthara Ayuthaya Mahadilok Phop Noppharat Ratchathani Burirom Udomratchaniwet Mahasathan Amon Piman Awatan Sathit Sakkathattiya Witsanukam Prasit" is the poetic name for bangkok
14:52:15 <davidhouse> my friend has memorised that.
14:52:20 <bolrod> omg
14:52:54 <bolrod> I guess its not as bad as learning 50000 decimals of PI
14:52:55 <musasabi> bolrod: wasn't it non-comcast before?
14:53:00 --- mode: musasabi set -o musasabi
14:53:02 <bolrod> lets seee
14:54:20 <}ElectrowolF{> hmm
14:54:37 <bolrod> it was something else ;/
14:54:46 <isaac__> > take 50000 $ show pi
14:54:47 <lambdabot> "3.141592653589793"
14:54:51 <isaac__> :-P
14:54:52 <}ElectrowolF{> >t "" : map show [1..4]
14:54:59 <}ElectrowolF{> no type?
14:55:00 <}ElectrowolF{> :(
14:55:08 <}ElectrowolF{> >:t "" : map show [1..4]
14:55:16 <bolrod> @type
14:55:17 <lambdabot> not an expression: `'
14:55:28 <bolrod> @type "" : map show [1..]
14:55:28 <}ElectrowolF{> @type "" : map show [1..4]
14:55:29 <lambdabot> [[Char]]
14:55:29 <lambdabot> [[Char]]
14:55:43 <}ElectrowolF{> then why does it only give me one list?
14:55:45 <}ElectrowolF{> > "" : map show [1..4]
14:55:46 <lambdabot> ["","1","2","3","4"]
14:55:50 <jip> @hoogle range
14:55:50 <lambdabot> Ix.range :: Ix a => (a, a) -> [a]
14:55:50 <lambdabot> Language.Haskell.TH.Range :: data Range
14:55:50 <lambdabot> Ix.rangeSize :: Ix a => (a, a) -> Int
14:55:56 <bolrod> it gives you 2 lists ;/
14:56:06 <bolrod> [Char] is a list = String
14:56:08 <}ElectrowolF{> 2nd one is?
14:56:09 <bolrod> @typeString
14:56:10 <lambdabot> Unknown command, try @list
14:56:10 <}ElectrowolF{> gah
14:56:11 <}ElectrowolF{> true
14:56:13 <bolrod> @type String
14:56:14 <lambdabot> Not in scope: data constructor `String'
14:56:23 <RHE123> wake up alex!
14:56:29 <bolrod> @type [] ::String 
14:56:30 <lambdabot> String
14:56:38 <bolrod> @type ["test"]
14:56:39 <lambdabot> [[Char]]
14:56:43 <bolrod> @type ["test"]::[String]
14:56:44 <lambdabot> [String]
14:56:44 <}ElectrowolF{> still gotta start studying for imp ;p
14:56:53 <mahogny> imp?
14:57:00 <RHE123> hmm, that''s tomorrow :P
14:57:00 <bolrod> imperative programming
14:57:01 <}ElectrowolF{> java
14:57:06 <bolrod> its easy
14:57:09 <}ElectrowolF{> yer i know
14:57:16 <mahogny> java... bah. that's common knowledge. nothing one studies
14:57:18 <RHE123> nasty word in this channel ;)
14:57:29 <}ElectrowolF{> it's fairly ok.. but i forgot quite some stuff
14:57:29 <}ElectrowolF{> hehe
14:57:34 <bolrod> nah..  javascript is way nastier
14:57:42 <mahogny> are there any reasonable haskell java bindings?
14:57:46 <RHE123> okok, agree:)
14:57:47 <mahogny> js is pure evil
14:57:47 <}ElectrowolF{> visual basic.. *whistle*
14:57:58 <bolrod> never even seen that
14:58:03 <bolrod> not that I want to
14:58:04 <mahogny> vb isn't a prog language so it cannot be compared
14:58:05 <}ElectrowolF{> i had to do some in HS.. 
14:58:12 <bolrod> js isn't also
14:58:15 <}ElectrowolF{> i didn't understand a thing of it
14:58:16 <}ElectrowolF{> tbh
14:58:23 <}ElectrowolF{> i worked with pascall just fine
14:58:24 <}ElectrowolF{> :P
14:58:28 <mahogny> eew
14:58:42 <}ElectrowolF{> mahogny: HS, mind you ;-)
14:58:51 <mahogny> never heard about that one
14:59:00 <}ElectrowolF{> highschool >_>
14:59:03 <mahogny> ehr. duh
14:59:11 <mahogny> ok. I know some ppl who did that here too
14:59:15 <mahogny> but that was a long time ago
14:59:29 <}ElectrowolF{> poor leno
14:59:52 <bolrod> hrm...  maybe I can write a cool program in haskell that makes timetables
14:59:57 <RHE123> by Royksopp :) :P
14:59:58 <mahogny> no. they should teach haskell in high school. I bet that would help their grades :)
15:00:00 <bolrod> so I can put some people out of work on schools ;)
15:00:23 <mahogny> bolrod, I wrote one that optimizes my selection of courses as to cram in as many as possible on my schedule :)
15:00:42 <bolrod> ;)
15:00:46 <davidhouse> what's the 1-line shell code for extracting a .tar.gz?
15:00:51 <mahogny> tar xzf ...
15:00:51 <bolrod> we had to do such a thing for the first assignment
15:01:02 <davidhouse> mahogny: will that do the .gz as well?
15:01:06 <bolrod> yes
15:01:09 <davidhouse> thanks.
15:01:12 <mahogny> davidhouse, gunzip
15:01:12 <bolrod> .tar is standard
15:01:17 <bolrod> NO!
15:01:18 <bolrod> NOOO1
15:01:23 <bolrod> gunzip just removes the .gz
15:01:33 <mahogny> ehr. aha. that was what he meant
15:01:36 <bolrod> and it will CHANGE the .gz into .tar
15:01:40 <mahogny> davidhouse, the z is for that
15:01:44 <bolrod> so you won't have the original .tar.gz file
15:01:53 <bolrod> anyway... tar figures it out itself lately
15:01:54 <mahogny> bolrod, ah. I cheated; I dumped it to glpk do the optimization
15:01:59 <bolrod> so   tar xf will do for any file
15:02:03 <mahogny> oh? nice
15:02:13 <bolrod> yeah..  I forgot the z once
15:02:18 <bolrod> and it did it just fine.. I was stunned
15:02:28 <mahogny> but I dunno if that holds for all unix
15:02:31 <bolrod> or the j with .bz2
15:02:34 <mux> you can use gzip -c foo.gz > foo to keep original files
15:02:43 <mux> s/gzip/gunzip/
15:02:48 <bolrod> mux: please don't confuse it
15:02:57 <mahogny> you mux his brain up!
15:02:59 <bolrod> that must be the most ugly command ever
15:03:01 <mahogny> ehr. or something
15:03:06 <mahogny> lol. it's very unixy
15:03:08 * mux shrugs
15:03:19 <bolrod> it is... way too unixy
15:03:19 <mux> it's gzip's fault anyways
15:03:24 <mahogny> unisexy?
15:03:32 <mux> bzip2 has a -k flag which is more appropriate because it doesn't force output to stdout
15:03:44 <bolrod> ;)
15:03:44 <mahogny> ugh. -kkk
15:04:06 <bolrod> cat foo | tar cjf foo.tar.bz2 -
15:04:09 <bolrod> does that work? ;)
15:04:37 <bolrod> nah
15:05:14 <bolrod> can you believe OS X doesn't come with wget?!
15:05:22 <mux> bolrod: ugh.
15:05:23 <davidhouse> that's nothing.
15:05:24 <mahogny> considering the type system bash uses, I wouldn't have been surprised if it did something :)
15:05:27 <mahogny> bolrod, omg
15:05:32 <davidhouse> we originally bought SuSE 9.1 personal.
15:05:35 <mux> bolrod: instead of tar cjf foo.tar.bz foo ?
15:05:37 <davidhouse> IT DIDN'T HAVE MAKE
15:05:42 <mahogny> lol
15:05:43 <bolrod> mux:  ;)
15:05:57 <bolrod> davidhouse: indeed.. you can install that with YaST
15:06:09 <bolrod> man I hate SuSE
15:06:11 <mahogny> my current distro didn't come with manpages for libc. I was about to go nuts when I did man realloc and it gave me an error :)
15:06:16 <mux> bolrod: btw, modern unices have better means of achieving the '-' hack
15:06:23 <RHE123> i'm going to sleep :)
15:06:24 <davidhouse> actually we just got the "professional" version.
15:06:34 <mux> /dev/stdin /dev/stdout and /dev/stderr
15:06:41 <mahogny> davidhouse, bugfixes preapplied?
15:06:53 <davidhouse> not sure. it was a while ago.
15:06:57 <bolrod> mux: I don't have those
15:07:02 <davidhouse> i've since switched to ubuntu, you'll all be glad to know.
15:07:03 <mux> you suck ;-)
15:07:08 <mux> bolrod: what are you running?
15:07:13 <bolrod> Ubuntu
15:07:16 <mahogny> One word: NetBSD
15:07:28 <bolrod> mahogny: thats 4
15:07:31 <mahogny> :(
15:07:34 <mux> Linux needs to grow a fdescfs then
15:07:47 <mux> or stash it in their devfs implementation
15:08:02 <bolrod> ahwhatever ;p
15:08:10 <mahogny> anyway, I only use NetBSD on servers due to the limited set of drivers. but that OS is bloody untrashable compared to linux
15:08:30 <bolrod> what about FreeBSD?
15:08:35 <mux> yes please.
15:08:50 <mahogny> it's faster, but I think the set of programs is a bit larger for Net
15:08:54 <mahogny> also, Net is more portable
15:08:58 <bolrod> or Solaris.. so you can make full use of the new ZFS  xD
15:09:06 <mux> bolrod: if you /whois me you'll see taht I'm biased towards FreeBSD so I won't comment :-)
15:09:12 <mahogny> never heard about zfs. good?
15:09:26 <bolrod> well.. you can have a zettabyte of data
15:09:40 <bolrod> if you can afford that many harddisks
15:09:46 <mahogny> I guess... I use ZFS next time I want to create a virtual disk in my primary memory
15:10:30 <bolrod> not like anybody will use that much space in one system in the next few years.... ;/
15:10:58 <mahogny> I still think my 400gb is huge
15:11:01 <mux> the other nice thing with ZFS is that it has a concept of virtual storage poool
15:11:06 <davidhouse> how much is a zettabyte?
15:11:07 <jip> what's a good one to update one row of a 2d array in one shot?
15:11:10 <bolrod> 400GB isn't huge
15:11:12 <sieni> davidhouse: 10^21 bytes
15:11:22 <mahogny> bolrod, in my world it is :)
15:11:33 <mux> though that kind of things, and more, can be achieved with GEOM under FreeBSD
15:11:35 <davidhouse> so... 10^9 terabytes.
15:11:42 * davidhouse wonders if there's that much data in the world
15:11:53 <mux> and I'm not certain it's necessarily good to push this notion down into the filesystem
15:11:53 <mahogny> bolrod, quoting myself after buying a 6gb; "now I won't ever have to buy a new harddrive again"
15:11:59 <bolrod> giga -> tera -> peta  -> exa -> zetta -> yotta
15:12:13 <bolrod> mahogny: ;)
15:12:26 <davidhouse> i have 40GB. i'd like 60, but only so i can squeeze in an extra linux distro. i'd never need 80, let alone 400.
15:12:26 <bolrod> 6GB .. you can hardly fit 2 linux distro's on that
15:12:32 <mahogny> bolrod, now 6gb... is my download queue :(
15:12:37 <norpan> and here i am with my yottabyte of data and zfs won't even handle it
15:12:38 <davidhouse> all the files on my computer are plain text :)
15:12:41 <bolrod> mahogny: ;)
15:12:43 <}ElectrowolF{> ...
15:12:50 <}ElectrowolF{> i am evil if i say i got 800gb?
15:12:55 <musasabi> ZFS is like {Reiser,Ext2,JFS} + LVM + MD on linux, but in one clean package.
15:12:55 <davidhouse> depends.
15:12:55 <bolrod> norpan: you must be the richest man in the world
15:12:56 <davidhouse> do you?
15:13:07 <bolrod> 800GB isn't that much either anymore
15:13:14 <}ElectrowolF{> true
15:13:52 <norpan> if i had the storage to store my yottabyte i might be
15:14:03 <davidhouse> norpan: and you have to use 64-bytes floats to get enough decimal places to show the percentage of that yottabyte you're using: 0.0000... ;)
15:14:14 <}ElectrowolF{> lol
15:14:17 <mahogny> :D
15:14:27 <bolrod> :D
15:14:42 <bolrod> I don't think its physically possible to cram a yottabyte into your country
15:14:46 <bolrod> ehehhe :)
15:14:57 <}ElectrowolF{> why not?
15:15:00 <}ElectrowolF{> you can allways go up..
15:15:06 <bolrod> don't know
15:15:18 <bolrod> how many atoms are there in the earth? ;)
15:16:10 <davidhouse> there's about 10^80 particles in the universe
15:16:49 <davidhouse> give or take a few hundred thousand million.
15:17:33 <bolrod> haha
15:17:37 <}ElectrowolF{> isn't that number still expanding?
15:17:51 <bolrod> and a yottabyte is  10^24
15:17:56 <bolrod> no the universe expands
15:18:00 <bolrod> doesn't mean the mass in it does
15:18:03 <}ElectrowolF{> hmm
15:18:04 <}ElectrowolF{> true
15:18:06 <bolrod> though we probably don't know for sure
15:18:14 <davidhouse> that would violate the law of conservation of matter.
15:18:19 <}ElectrowolF{> might even decrease while we are speaking..
15:18:27 <}ElectrowolF{> damn black holes
15:18:29 <Cale> what about particle/antiparticle pairs?
15:18:30 <bolrod> urh
15:18:38 <bolrod> black holes don't make matter dissapear
15:18:38 <mahogny> the mass can increase without violating any laws
15:18:39 <mux> black holes don't make matter disappear either
15:18:42 <davidhouse> (i know it's happening all the time on a quantum scale, but that doesn't really affect things on the 10^80 scale)
15:18:46 <mux> it's only in the imagination of sci-fi writers
15:18:49 <bolrod> mahogny: it can
15:18:51 <davidhouse> black holes are also evaporating.
15:18:58 <mux> that's a theory
15:19:06 <Cale> everything is a theory
15:19:14 <bolrod> you can turn energy into mass
15:19:15 <mux> more so than others then :)
15:19:21 <Cale> energy is a theory :)
15:19:30 <davidhouse> all theories are theories, but some are more theoretic than others.
15:19:36 <Cale> heh
15:19:37 <bolrod> well.. a smack on the head with a mauler doesn't feel like theory
15:19:39 <mahogny> I love how two protons apart weigh more than two protons together :)
15:19:41 <bolrod> ;)
15:19:59 <jip> Cale: almost got this bugger working...
15:20:11 <mux> anyone heard of the global tranverse redshift effect?
15:20:21 <}ElectrowolF{> nope
15:21:07 <bolrod> care to explain?
15:21:15 <bolrod> something to do with doppler effect?
15:21:22 <mux> a new theory that presumably corrects a deficiency in the theory of gravity from einstein and pretty much explains lots of problems with the current theory
15:21:45 <bolrod> how does it work
15:21:46 <mux> the pioneer anomaly, gps inaccuracies, so called "dark" matter and energy
15:21:51 <mux> let me dig up the link
15:21:56 <wchogg> mux:  There are alot of "theories" that claim to do this, but has this one actually been published and scrutinized?
15:22:02 <davidhouse> it's on the internet, it must be true! :)
15:22:05 <mahogny> lol
15:22:09 <NameTab> who's talking about me!?
15:22:13 <}ElectrowolF{> is it on wiki?
15:22:14 <davidhouse> until the general scientific community accepts it, don't get excited, folks.
15:22:16 <mux> oh yeah there are a lot of theories that solve one of these anomalies
15:22:19 <}ElectrowolF{> if it's no on wiki it's fake!
15:22:25 <NameTab> }ElectrowolF{: you flunked the test? :)
15:22:26 <mux> few do it in such a convincing way, and with so much problems
15:22:34 <}ElectrowolF{> NameTab: i expect to
15:22:39 * NameTab 2
15:22:50 <}ElectrowolF{> are you kenney?
15:22:54 <davidhouse> mux, when was it published?
15:22:55 <wchogg> davidhouse:  Indeed.  I'm one of a few physicists who hangs out on sci.physics*.  Everyone has their own pet theory.
15:22:56 <NameTab> no, Kenny :)
15:22:59 <}ElectrowolF{> ah
15:23:03 <}ElectrowolF{> robin guessed so
15:23:08 <NameTab> are you the lex I think you are? 
15:23:13 <}ElectrowolF{> yer i am
15:23:16 <NameTab> and who's robin? (as in: what nick?)
15:23:21 <mux> davidhouse: I'm still looking for the lin
15:23:23 <}ElectrowolF{> signed off already
15:23:24 <mahogny> round robin? :O
15:23:28 <mux> and I have no diea if it has been published
15:23:32 <NameTab> }ElectrowolF{: not my question ;)
15:23:37 <bolrod> :)
15:23:47 <}ElectrowolF{> you beer drinking brabo.. gimme a sec
15:23:53 <bolrod> I still want to have a site which shows the physical limits of the amount of storage on earth
15:24:00 <}ElectrowolF{> RHE123
15:24:06 <NameTab> right, thought so already
15:24:31 <}ElectrowolF{> 50% of all the dutchies here are uu fp students.. :)
15:24:43 <NameTab> :)
15:24:53 * mahogny finally realizes his tomorrow is saved as an exam has been moved! :D
15:24:56 <bolrod> how many % are happy fp students?
15:24:58 <}ElectrowolF{> anyway, studing some imp now.. aka reading it through once..
15:25:03 <}ElectrowolF{> bolrod: 1?
15:25:05 <}ElectrowolF{> 0?
15:25:09 <bolrod> I'm happy
15:25:15 <NameTab> I'm happy, only not because of fp :P
15:25:17 <}ElectrowolF{> you think you'll pass?
15:25:19 <mux> damn it
15:25:31 <bolrod> }ElectrowolF{: think.. know..  hell ;)
15:25:34 <NameTab> nope
15:25:35 <davidhouse> bolrod: there certainly is an upper limit on the amount of information (in the quantum sense) the universe can hold.
15:25:48 <}ElectrowolF{> davidhouse: sounds logical
15:25:55 <NameTab> }ElectrowolF{: #haskell-blah :P
15:25:59 <bolrod> davidhouse: again... this is probably a theory
15:26:24 <davidhouse> the finite universe is pretty well generally accepted.
15:26:34 <davidhouse> that's all you need for that statement to be true.
15:26:44 <mux> http://afmayer.net/
15:26:50 <mux> the website is quite ugly
15:26:52 <}ElectrowolF{> finite universe...
15:26:56 <mahogny> no. finite universe is not enough
15:26:59 <bolrod> if its finite.. doesn't mean it can't get bigger
15:27:05 <mahogny> it requires a bit from the quantization as well
15:27:05 <wchogg> davidhouse:  What do you mean as finite?  Do you mean that what exists is finite or that it will be closed?
15:27:22 <davidhouse> there is a finite amount of mass in the universe.
15:27:25 <bolrod> if the website is ugly.. it must be true ! 
15:27:27 <bolrod> ;)
15:27:40 <mux> I have not the slightest idea if it's true, but I liekd some of his sayings
15:28:45 * mahogny is the wrong kind of physicist to verify this :/
15:29:12 <wchogg> mahogny:  what kind are you?
15:29:24 <mahogny> wchogg, biophys
15:29:45 <mahogny> computationalist obviously
15:29:52 <wchogg> mahogny:  Cool.
15:30:30 <wchogg> In the past several days it seems like I've talked to at least three or four people here that work in some aspect of physics.
15:30:52 <mahogny> physicists have some perverse relation to computers. it's not a coincidence they are in #haskell :)
15:31:22 <wchogg> True.  Although I still think the fact that I'm here is an adverse reaction to all the Fortran77 used in high energy physics.
15:31:36 <mahogny> eew. f77
15:31:46 <hetauer> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:31:47 <hetauer> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:31:50 <mahogny> ...
15:31:50 <bolrod> nat again
15:31:51 <}ElectrowolF{> again?
15:31:51 <hetauer> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:31:54 <bolrod> COMCAST!
15:31:54 <mahogny> someone gimme op :P
15:31:55 <hetauer> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:31:57 <wchogg> Oh sack of asses.  They're hitting all the channels today.
15:31:59 <hetauer> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:00 <bolrod> someone hacked some things
15:32:03 <hetauer> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:07 <hetauer> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:14 <bolrod> seriously...  someone know an oper?
15:32:14 <mux> very low quality spammer
15:32:14 <}ElectrowolF{> doesn't this network have an admin or something.. >_>
15:32:18 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:19 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:20 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:23 <bolrod> argh
15:32:24 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:28 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:28 <NameTab> how friggin' annoying
15:32:29 <wchogg> the lisp channel has been set to be registered users only now.
15:32:32 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:36 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:40 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:40 <bolrod> wchogg: thats lame
15:32:43 --- mode: ChanServ set +o musasabi
15:32:44 <hetauerp> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
15:32:46 --- mode: musasabi set +b *!*n=hohoho@*.hsd1.nj.comcast.net
15:32:46 --- kick: hetauerp was kicked by musasabi (musasabi)
15:32:48 --- mode: lilo set +R
15:32:52 <BCoppens> lilo: \o/
15:32:53 <mux> lilo: thnkas
15:32:54 <wchogg> bolrod:  It's just until this spambot problem is fixed.
15:32:56 <ohub> thanks!
15:33:00 <lilo> musasabi: you may need to +R for a bit
15:33:06 <bolrod> well
15:33:08 <lilo> musasabi: I don't know if that's practical?
15:33:11 <bolrod> why don't we give ops to the bot?
15:33:15 <}ElectrowolF{> it isn't
15:33:15 <bolrod> or 'a' bot
15:33:16 <mahogny> wchogg, haskell has a future in high performance computing, if used correctly
15:33:19 <musasabi> lilo: yes, seems like there is litle alternative.
15:33:29 <Igloo> What's +R? Only let registered people join?
15:33:34 <bolrod> yes
15:33:34 <mahogny> yes
15:33:35 <musasabi> or add a bot kicking from that flame.
15:33:35 <bolrod> nah
15:33:37 <bolrod> not needed
15:33:39 <wchogg> Only registered people have voice.
15:33:41 <}ElectrowolF{> normal action is to close the channel that is being spammed for..
15:33:45 <bolrod> its not like that bot joins every 3 minutes
15:33:57 * Igloo would rather see if the ban suffices
15:34:07 <lilo> no, +R lets anyone join
15:34:11 <lilo> but you have to register or be +v to speak
15:34:15 <musasabi> Igloo: it has come from a different address each time.
15:34:22 * bolrod would rather see an anti spam bot
15:34:24 <bolrod> a CLEVER one
15:34:28 <}ElectrowolF{> musasabi: both time i saw it was from comcast
15:34:41 <mux> * bolrod has been kicked by StupidBot (no yelling)
15:34:46 <lilo> }ElectrowolF{: it doesn't seem very fair to do that....do we do that with Ubuntu's channels? or Apache Software Foundations? if they have a problem?
15:34:48 <bolrod> ofcourse
15:34:59 <lilo> }ElectrowolF{: it's been from pretty much everywhere
15:34:59 <wchogg> mahogny:  What do you think are the advantages of haskell in computational work?
15:35:07 <lilo> }ElectrowolF{: poland, japan, various other places
15:35:21 <}ElectrowolF{> but do they allways spam for the same channel?
15:35:22 <mahogny> wchogg, I have more come to see it as a meta language for generating highly optimized C
15:35:27 <bolrod> ban_host_on_intuition()
15:35:47 <Igloo> musasabi: When was it different?
15:35:50 <mux> let's make lambdabot a war bot
15:35:51 <mux> heh
15:35:55 <}ElectrowolF{> #fazlamesai the spammers and flooders are not related to this channel | They are trying to give us a bad reputation for an unknown reason. | freenode staff contacted on this issue
15:36:00 <}ElectrowolF{> ah, sucks
15:36:07 * lilo nods
15:36:25 <musasabi> Igloo: helios.demon.co.uk too.
15:36:43 <}ElectrowolF{> you could install spam detection plugins of moduels on the services
15:36:49 <}ElectrowolF{> or*
15:36:50 <davidhouse> yay! my monad is done, tested and documented.
15:36:56 <lilo> we're thinking about what to do here....it's messy
15:37:08 <TuringTest> davidhouse: What does it do?
15:37:14 <davidhouse> http://haskell.org/haskellwiki/Zipper_monad
15:37:15 <Igloo> musasabi: That was hours ago, and I don't think we want to be +R that long
15:37:24 <wchogg> mahogny:  That's an interesting way of seeing it.  So do you mean that you want to write algorithms in Haskell and let them compile to C using ghc, or is the Haskell code you write doing code generation directly?
15:37:29 <musasabi> Igloo: point.
15:37:32 <}ElectrowolF{> i got some spam detection addon on my own services, iirc..
15:37:34 <}ElectrowolF{> not sure thou
15:37:49 <}ElectrowolF{> not realy bother to check them often since the network runs on max 10 users ;-)
15:37:49 --- mode: musasabi set -R
15:37:58 <bolrod> come on.. its not like a real problem having some spam bots..
15:37:59 <lilo> I can tell you that the guy is not giving up
15:38:00 <jip> please give me voice before setting -R next time, thanks!
15:38:01 <bolrod> its just damn annoying
15:38:22 <bolrod> oh -R was on the channel all the time?
15:38:27 <bolrod> +R that is
15:38:29 <jip> i mean +R
15:38:31 <lilo> bolrod: it was set to +R just a moment ago
15:38:39 <lilo> as far as I can tell
15:38:41 <bolrod> ohihc
15:38:54 <davidhouse> you don't need voice ;)
15:38:56 <davidhouse> *:S
15:38:57 <mahogny> wchogg, the haskell code takes a problem and writes the C code that does the number crunching
15:39:05 <davidhouse> you just need to /msg NickServ IDENITY.
15:39:07 <}ElectrowolF{> lilo: he uses proxys?
15:39:14 <davidhouse> mahogny: any problem?
15:39:14 <mahogny> wchogg, FFTW, the fastest FFT library currently, does a similar thing using Ocaml
15:39:15 <lilo> apparently fazlamesai is a website, and a television program on Turkish 'teknoloji television'
15:39:23 <davidhouse> mahogny: like, making the tea?
15:39:23 <lilo> }ElectrowolF{: yeah
15:39:36 <}ElectrowolF{> lilo: install a proper proxy scanner, tried that?
15:39:44 <Igloo> lilo: Is it just us he's spamming?
15:39:47 <bolrod> the server should do that
15:39:50 <davidhouse> Igloo: nope
15:39:54 <davidhouse> had it in #wordpress as well
15:40:03 <bolrod> he does only join one channel at a time it seem
15:40:03 <bolrod> s
15:40:09 <wchogg> mahogny:  So you're taking advantage of how easy it is to write DSLs in Haskell then?
15:40:09 <bolrod> why would he come here?
15:40:10 <mahogny> davidhouse, problems where customly generated code can make a big difference. like putting in the geometry as a restriction in the code instead of storing it and using tons of slow if's
15:40:46 <davidhouse> sounds fun.
15:41:00 <davidhouse> what kind of input does it need?
15:41:06 <mahogny> wchogg, expressiveness in general. C is quite a beast and it's seldom possible to write the fastest possible code and still keep readability and maintainability. metacoding it gives you the best of both worlds
15:41:44 <wchogg> mahogny:  yeah, that really makes sense actually.  Sortof taking advantage of the old meme that "C is portable assembly".
15:41:47 <mahogny> davidhouse, right now I use it for lattice boltzmann. it takes the geometry of an air channel and boundary conditions, and then it hardcodes everything into the algorithm
15:42:21 <mahogny> wchogg, yeah. kind of. but GCC does many clever optimizations so I don't have to that much of an optimization, as long as I know how GCC will react on the input
15:43:30 --- mode: musasabi set -o musasabi
15:43:48 <wchogg> Sure.  I just had never thought of doing something like that before, but it makes sense.  You can take advantage of years and years of C optimizations while still making the coding part fairly straight forward.
15:44:17 <lilo> Igloo: he's spamming all over
15:44:58 <}ElectrowolF{> are the ircops ever awake on this network?
15:45:03 <mahogny> wchogg, it's not extremely straight-forward though. I'd prefer to see a library for this purpose. right know it is a major code mangler and you still have to write the C code first so you have some sense of what it should output
15:56:20 <jip> holy coy i don't believe it, it works!
15:56:21 <jip> http://img122.imageshack.us/img122/6973/dropzonetitlescreen4qx.png
15:57:26 <xerox> jip: Oh yeah!!
15:57:30 <bolrod> }ElectrowolF{: its freenode.... what do you think
15:57:56 <bolrod> jip: cool
15:59:56 <jip> unfortunately, it's slow as SHIT
16:00:21 <xerox> hehe
16:00:27 <xerox> Profile, profile.
16:01:18 <jip> yeah i guess
16:01:56 <jip> first i wanna polish things out a bit more so that i can get more then just this game only able to run to the title screen :)
16:03:42 <sjanssen> jip: neat
16:04:15 <jip> sweet, asteroids also sort of gets to the title screen
16:04:25 <jip> after showing the "accolade" logo
16:04:27 <lucca> what is this?
16:04:33 <jip> lucca: gameboy emulator
16:04:58 <lucca> hmmmmmm, cool
16:06:16 <ihope_> Let's see here.
16:06:31 <ihope_> Exponentiation is exponent -> base...
16:06:45 <jip> check it out:
16:06:52 <jip> http://img105.imageshack.us/img105/8080/asteroidstitlescreen15jt.png
16:07:31 <sjanssen> you said the emulator is slow?
16:07:48 <jip> sjanssen: really slow
16:08:03 <sjanssen> still using immutable arrays?
16:08:12 <jip> sjanssen: i'm using Data.Array.Unboxed
16:09:24 <sjanssen> I wonder if UArrays are smart and use memcpy or something efficient when doing updates
16:09:40 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:09:41 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:09:41 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:09:43 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:09:47 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:09:50 <}ElectrowolF{> same host.. lol
16:09:57 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:09:57 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:09:58 <bolrod> nat again
16:09:59 <jip> ban comcast already!
16:09:59 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:10:03 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:10:07 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:10:08 <jip> lilo
16:10:09 <bolrod> or just that ip
16:10:12 <}ElectrowolF{> nah
16:10:18 <}ElectrowolF{> ip is useless
16:10:28 <jip> sjanssen: i am hoping that UArrays are even smarter and do update in place
16:10:30 <bolrod> ban *.nj.comcast.net
16:10:41 <}ElectrowolF{> bolrod: it was ca.comcast.net before :P
16:10:42 <sjanssen> whoever is doing this has a botnet (or several conspirators)
16:10:45 <}ElectrowolF{> and it was from other countries before
16:10:49 <}ElectrowolF{> uses proxies
16:10:52 <bolrod> }ElectrowolF{: that was a few hours ago
16:10:55 <lilo> he just brings up botnets whenever he needs to
16:10:55 <bolrod> Z_oqu: you're so cool
16:10:55 <jip> lilo
16:11:01 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:11:02 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:11:02 <Z_oqu> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai
16:11:04 --- mode: lilo set +R
16:11:08 --- mode: lilo set +v jip
16:11:10 <}ElectrowolF{> botnet... >_>
16:11:13 <lilo> jip: now hush :)
16:11:13 <jip> lilo: thanks :D
16:11:21 * lilo grins
16:11:22 <lilo> jip: np
16:11:25 <xerox> What's going on here?
16:11:39 <sjanssen> FAZLAMESAI!
16:11:41 <}ElectrowolF{> this is most likely just s single user screwing around
16:11:45 <jip> sjanssen: so do you think it's possible for ghc to update UArrays in place?
16:11:54 <NameTab> }ElectrowolF{: kill him
16:11:55 <bolrod> http://video.google.com/videoplay?docid=5627694446211716271&q=monty+python+spam&pl=true
16:11:58 <bolrod> :)
16:12:03 <}ElectrowolF{> you don't want to see a botnet :P
16:12:12 <}ElectrowolF{> NameTab: got no oper access here, sorry ;-)
16:12:18 <NameTab> }ElectrowolF{: irl
16:12:30 <sjanssen> jip: maybe.  it sounds rather tricky, so GHC probably doesn't do it
16:12:37 <}ElectrowolF{> got no arms ! :P
16:12:37 <NameTab> ur dangerous, we all know that
16:12:51 <}ElectrowolF{> you get me some nice stuff to play with, and i'll use it
16:13:04 <jip> sjanssen: i think Cale mentioned that DiffArray does this though
16:16:12 * NameTab hands }ElectrowolF{ a knife
16:16:43 * }ElectrowolF{ knifes NameTab down
16:16:48 <}ElectrowolF{> nice word.. knifes
16:17:05 <sjanssen> jip: DiffArray does update in place, put it has a few performance problems.  For one, it has to do locking when accessing the array
16:17:55 * NameTab != spammer
16:18:03 <jip> sjanssen: locking in the sense of multi threading?
16:18:40 <sjanssen> jip: yes
16:18:47 <jip> sjanssen: my app is single threaded
16:19:30 <sjanssen> the overhead is still there
16:23:29 <sjanssen> anyway, I would not be surprised if UArray would work better for you than DiffUArray.  you can always try, all you have to do is s/UArray/DiffUArray/
16:23:53 <jip> ok cool i'll give it a shot once i polish a few things out
16:24:31 <jip> the dropzone logo is supposed to scroll down during the intro. for some reason my emulator isn't showing it. i want to get it working and then create an animated gif :D
16:26:10 <jip> in less then 4 hours though i have to leave :'(
16:29:29 <davidmccabe> In hugs, what does "Unresolved top-level overloading" mean?
16:34:01 <}ElectrowolF{> my mind says it's unable to decide what type it is..
16:37:40 <gadolin> hey, how should i formulate that b is Show b in 
16:37:41 <gadolin> nstance Show a =>  Show (Assoc a b) where
16:37:50 <gadolin> Instance Show a =>  Show (Assoc a b) where ....
16:39:26 <gadolin> lol, (Show a, Show b)
16:45:12 <davidmccabe>   let numbers = map read tokens
16:45:13 <davidmccabe>   let my_sum = foldr (+) 0 numbers
16:45:13 <davidmccabe>  
16:45:18 <davidmccabe> where tokens is a list of strings, should work, right?
16:45:36 <davidmccabe> (and where we're in a do-expression)
16:46:50 <jip> yeah, dropzone intro seems to work perfectly :D
16:47:11 <davidmccabe> huh?
16:47:37 <jip> davidmccabe: http://img122.imageshack.us/img122/6973/dropzonetitlescreen4qx.png
16:48:02 <davidmccabe> you're writing a gameboy emulator in haskell?
16:48:15 <jip> davidmccabe: yes
16:48:26 <davidmccabe> Rad.
16:48:47 <jip> davidmccabe: i also have a devlog: http://www.mutantlemon.com/omegagb/devlog/
16:51:33 <Philippa> figured out what you'll do about sound?
16:51:39 <jip> Philippa: what do you mean?
16:52:23 <jip> @seen dcoutts_ 
16:52:37 <davidmccabe>     No instance for (Num String)
16:52:37 <davidmccabe>       arising from use of `+' at Test.hs:34:21-23
16:52:41 <davidmccabe> what does that mean?
16:52:48 <davidmccabe> (line 34 is the second line I pasted above)
16:53:49 <Philippa> jip: I guess mostly what libraries you'll be using to play. I figure the sound hardware emulation won't be notably harder than the video
16:54:14 <davidmccabe> seemingly, the first line is coming out as a Char, where I expected a [Number]
16:55:46 <jip> Philippa: in the SDL version i will use sdl's sound output. for the gtk version i will have to investigate. for the console(ascii-art) version i will also have to investigate
17:05:09 * xX[ReP]Xx is now serving 'real' traffic with an http server written in haskell
17:05:26 <jip> nice
17:05:36 <davidmccabe> yay! it turns out that you have to specify a target type for read; but this tutorial didn't mention that, and I guess it wasn't needed in the context they introduced read in for some reason.
17:06:37 <xX[ReP]Xx> http://kaede.iichan.net/tech/ in case you're curious
17:08:36 <jip> rephttpd?
17:09:32 <xX[ReP]Xx> jip ya
17:09:57 <jip> cool
17:15:30 <jip> Cale: ?
17:19:55 <sjanssen> is there an environment variable I can set to tell GHC to include things?
17:22:00 <jip> > showInt 3
17:22:31 <jip> how can i show a number with padding? "0000" "0005" "0503" "5311"
17:28:57 <jip> > 0
17:49:53 <jip> woohoo! check it out: animated gif of my gameboy emulator in action:
17:49:55 <jip> http://img159.imageshack.us/img159/2615/dropzonetitleanim18qr.gif
17:50:37 <doublec> nice job jip!
17:51:27 <jip> thanks
17:57:33 <GeniXPro> I have yet to know where people find the technical specs of consoles to such a degree that they can make emulators of those consoles of as good of a quality os zsnes or visual boy advance
17:57:58 <jip> the internet :P
17:58:10 <GeniXPro> Are you serious?
17:58:12 <doublec> gbatek
17:58:17 <GeniXPro> My lie detector says no
17:58:20 <doublec> for example
17:58:22 <GeniXPro> its beeping at me
17:58:38 <GeniXPro> ohh wait thats my pager
17:58:38 <doublec> http://www.work.de/nocash/gbatek.htm
17:58:55 <doublec> You could ask where do they get the info of course.
17:59:20 <Cale> jip: hi
17:59:25 <jip> Cale: hey! check it out:
17:59:42 <jip> http://img88.imageshack.us/img88/6433/anim6at.gif
18:00:03 <Cale> yeah, I just saw that, pretty cool :)
18:00:13 <Cale> Is it running in realtime yet?
18:00:30 <jip> Cale: no, it runs at about 1/10th realtime speed
18:01:00 <doublec> Is it emulating the memory access that's the slow part?
18:01:30 <jip> i have no idea, i haven't profiled it
18:01:36 <Cale> what kind of arrays are you using to represent writable memory?
18:01:43 <jip> i'm actually surprised that it's even as fast as it is :D
18:01:48 <Cale> hehe
18:01:57 <jip> Data.Array.Unboxed
18:02:24 <Cale> oh
18:02:38 <Cale> that might be it then
18:03:03 <Cale> try swapping it out for a DiffUArray and see what happens
18:03:14 <doublec> So it would be copying the contents of the memory on every write?
18:03:18 <Cale> yes
18:03:24 <Cale> it would :)
18:03:28 <jip> Cale: i'll give it a shot. but i actually use a few arrays
18:04:09 <jip> Cale: what about an array that is never updated? should i leave that Unboxed?
18:04:26 <Cale> sure, it shouldn't matter in that case
18:04:27 <Igloo> You're presumably in the IO Monad anyway? Any reason to not use a mutable array?
18:04:36 <jip> Igloo: i'm not really in the IO monad
18:04:40 <Cale> Well, it'll be slower to change to using an MArray
18:04:52 <Cale> since all the operations would have to change
18:05:07 <Igloo> Yes, but early in the project is the time to do it  :-)
18:05:28 <Cale> for something like RAM, where you're going to be using it in a single-threaded (as in, you won't be accessing old versions), using a DiffUArray should be quite fast
18:05:29 <jip> i don't want to use the IO monad at all, since i want to be able to embed the emulator in a functional gui like fruit
18:05:43 <Cale> single-threaded fashion*
18:06:52 <Cale> I'd be interested to see how much that improves the situation
18:07:16 <jip> ok i've changed to DiffArray, gonna run it...
18:07:16 <doublec> Is DiffUArray a plug in replacement?
18:07:22 <Cale> yes
18:07:28 <Cale> jip: DiffUArray
18:07:41 <jip> Cale: oh yeah, oops!
18:07:44 <Cale> (the U is important, as unboxing helps a lot too)
18:08:35 <jip> ok here goes...
18:09:55 <jip> ultra slow :(
18:10:05 <Cale> hmm
18:10:11 <Cale> slower?
18:10:11 <jip> you know what? i think i might be accessing old versions of the array in some parts of the code
18:10:18 <jip> a lot slower
18:10:29 <Cale> that's interesting actually
18:10:35 <jip> but i never read real far back, maybe just 2 or 3 updates back
18:10:46 <Cale> hmm
18:11:34 <jip> sometimes i'll modify an element of an array, and then after that i will read a value from the previous state instead of the new state, just because it's more conveniant
18:11:47 <jip> should i try fixing all of this code to only access the most recent state?
18:11:58 <ihope> > foldr1 gcd [6,10,15]
18:12:14 <doublec> It's only writing the old version that will cause a copy though isn't it?
18:12:23 <Cale> doublec: yeah
18:12:24 <ihope> @bot
18:12:43 <jip> hm... i'm pretty sure that i'm not doing that anywhere
18:12:44 <Cale> though I'd still expect it to be better than always writing a copy
18:13:03 <jip> Cale: it's about 10 times slower or worse
18:13:12 <jip> more like 20 times slower
18:14:08 <jip> i should probably get the ascii-art version working so that i'll be able to profile
18:14:55 <Cale> I wonder if there's ghc optimisation magic going on with UArrays
18:16:01 <toste> so hum
18:16:20 <toste> How can i remove the Just() in just(aList)
18:16:35 <Cale> I know that with my sudoku solver, which isn't even using the 9x9 arrays linearly, it speeds things up considerably to change UArray to DiffUArray
18:17:13 <Cale> On one example I'm trying here, it goes from 22 seconds to 6.5 seconds
18:17:34 <DukeDave> hello all
18:17:37 <toste> sudoku maker is hardcore to do :p
18:17:46 <ihope> toste: you mean turn Just foobar into foobar?
18:17:47 <DukeDave> whoa, that's weird!
18:17:50 <ihope> > fromJust (Just 'a')
18:17:53 <toste> yes
18:18:00 <ihope> Erm, anyway, it's fromJust.
18:18:06 * DukeDave just joined to take a break from his project on sudoku  :)
18:18:06 <Cale> toste: usually you pattern match with case
18:18:17 <Cale> toste: or use some function which does that
18:18:33 <ihope> Yep, if you want to do something else when you get Nothing, it's pattern matching.
18:18:43 <toste> > fromJust(Just([1,2])
18:18:48 <toste> @id fromJust(Just([1,2])
18:18:58 <Cale> > fromJust (Just [1,2])
18:19:05 <jip> bot has been dead for a while
18:19:12 <toste> > fromJust(Just([1,2]))
18:19:32 <dons> hmm
18:19:33 <toste> i have a case already : case isJust(find((==att).typeAttribut) l) of
18:19:42 <Cale> > fromJust (Just [1,2])
18:19:48 <Cale> hmm
18:19:51 <dons> weird
18:19:55 <dons> let me see...
18:20:01 <Cale> > fromJust (Just [1,2])
18:20:03 <mbot> [1,2]
18:20:09 <ihope> toste: you'll want to match on find((==att).typeAttribut) l, not isJust(find((==att).typeAttribut) l)
18:20:11 <toste> yay that works
18:20:46 <Cale> toste: you can use fromJust only if you *know* that it will be a Just something
18:20:48 <ihope> case (that) of Just x -> (what to do with the Just value); Nothing -> (what to do if you get Nothing)
18:21:24 <DukeDave> hey gang, if I want to pattern match a singleton list, I use, for example:   ' foo (x:[]) = pip x
18:21:26 <Cale> > case (Just [1,2]) of Nothing -> "Got nothing here!"; Just xs -> "Got " ++ show xs
18:21:27 <dons> lambdabot: ?version
18:21:28 <mbot> "Got [1,2]"
18:21:35 <Cale> DukeDave: or [x]
18:21:40 <toste> i can't put fromJust() in a function def ;(
18:21:52 <ihope> toste: what're you trying to do?
18:21:54 <DukeDave> should that work correctly then? :|
18:22:02 <Cale> toste: you can't apply fromJust to the null tuple
18:22:17 <Cale> because it only applies to values of type Maybe t.
18:22:21 <sjanssen> dons: because of spammers only identified users can talk.  is lambdabot identified?
18:22:26 <ihope> Cale: looks like he's not used to the fact that Haskell uses function argument instead of function(argument)
18:22:28 <toste> so it's not a good alternative
18:22:34 <Cale> > fromJust ()
18:22:36 <mbot> Couldn't match `Maybe a' against `()'
18:22:45 <Cale> > fromJust $ Just 5
18:22:46 <mbot> 5
18:22:55 <dons> sjanssen: looks like not. its passwd file has disappeared somehow
18:22:58 <DukeDave> ahh yes, cheers Cale 
18:23:09 <ihope> toste: it looks like you're trying to do "if this is a Just, then remove the Just and do this, otherwise do that", right?
18:23:10 <toste> > fromJust( Just([1,2,3]))
18:23:12 <mbot> [1,2,3]
18:23:25 <Cale> toste: you're overparenthesizing
18:23:25 <toste> right
18:23:35 <Cale> fromJust (Just [1,2,3])
18:23:39 <ihope> What we're saying you should do is "if it's Just this value, do this, otherwise do that".
18:23:40 <Cale> > fromJust (Just [1,2,3])
18:23:45 <mbot> [1,2,3]
18:23:54 <Cale> parens are only for grouping, you don't need them for function parameters
18:24:27 <ihope> Not if isJust foobar then function (fromJust foobar) but case foobar of Just value -> function value
18:24:33 <Cale> > maybe [] reverse (Just [1,2,3])
18:24:35 <jip> someone give voice to lambdabot
18:24:38 <mbot> [3,2,1]
18:24:39 <ihope> Get what I'm saying?
18:24:39 <lambdabot> [3,2,1]
18:24:46 <Cale> > maybe [] reverse Nothing
18:24:47 <lambdabot> Add a type signature
18:24:49 <mbot> Add a type signature
18:24:54 <sjanssen> ?id ?id ?id
18:24:55 <lambdabot> ?id ?id
18:25:05 <Cale> > maybe [] reverse Nothing :: Maybe [Integer]
18:25:06 <lambdabot> Couldn't match `Maybe [Integer]' against `[a]'
18:25:09 <mbot> Couldn't match `Maybe [Integer]' against `[a]'
18:25:11 <dons> please no
18:25:12 <Cale> > maybe [] reverse Nothing :: [Integer]
18:25:13 <lambdabot> []
18:25:16 <mbot> []
18:25:21 <Cale> hehe
18:25:24 <dons> mbot: @part #haskell
18:25:48 <dons> Cale , did you see the loop Pseudonym managed to get oasisbot and lambdabot into yesterday?
18:26:02 <ihope> What was it?
18:26:12 <ihope> >:-)^H^H^H^H
18:26:15 <wchogg> Yeah, I didn't see it either.
18:27:01 <toste> yes i do
18:27:25 <toste> thx, ill try exploring what your saying
18:28:03 <Cale> dons: yeah :)
18:28:12 <Cale> that was fun :)
18:28:20 <dons> hehe
18:28:51 <dons> its funny , every time I release fps, John M and Ashley Y complain about Word8 and no Unicode
18:29:14 <dons> unicode schmoonicode
18:29:31 <sjanssen> perhaps you should rename it to Data.FastPackedABSOLUTELYNOTUNICODEString
18:29:47 <Cale> toste: the maybe function takes 3 parameters -- the last of which is a value of type (Maybe a), that is, either Nothing, or Just x for some value x. The first parameter is a value to return if it happens to be Nothing, and the second is a function to apply to x in the case that it's Just x
18:30:04 <dons> sjanssen: yeah, haskell hackers, esp. library writers, are very picky :)
18:30:11 <Cale> hehe
18:30:16 <dons> too bad ghc had Char = Word8 for like 15 years..
18:30:31 <ihope> dons: what's it now?
18:30:49 <dons> you've got 32 bits, and now some 32 bit io routiens too, I think
18:31:00 <dons> its been a slow evolution.
18:31:12 <Igloo> dons: Replying with the URL of the last time it happened, then?  :-)
18:31:43 <dons> hehe. maybe I should.
18:32:03 * Igloo does agree it probably ought to be called FastPackedByteArray though. Or even just ByteArray.
18:32:16 <ihope> Igloo: times have URL's?
18:32:33 <DukeDave> I've just been playing with recursion, specifically a (pretty crap) sort function, and I have a question. The program:
18:32:35 <dons> I think its ok to use it as the Latin1 layer, and then we add the other encodings as variants, a la simon's lib.
18:32:49 <DukeDave> dsort (x:[]) = x
18:32:55 <DukeDave> dsort (x:xs) | x > dsort xs = x
18:33:02 <DukeDave> | otherwise = dsort xs
18:33:11 <dons> which is why i'm delaying a name change -- i don't think we'll need to.
18:33:24 <Igloo> ihope: Yes, e.g. http://www.timesonline.co.uk/global/
18:33:32 <ihope> DukeDave: dsort (x:xs) = max x (dsort xs)
18:33:54 <DukeDave> aha
18:33:56 <Igloo> dons: If String is built of Chars then I think PackedStrings ought to be too
18:34:11 <dons> yes. I agree with this. the situation as is isn't ideal
18:34:37 <dons> however, its a lsit/string interface. so calling it an Array isn't quite right either.
18:34:37 <DukeDave> okay, well my question is:  does haskell have to evaluate the 'dsort xs' expression twice? (per function call)
18:34:52 <dons> it asll depends on whether I or someone else, ports the unicode layer
18:34:58 <Igloo> DukeDave: It doesn't have to, but it might do so
18:36:12 <DukeDave> in the sense that it needs to perform it once to decide the maximum, and once that's evaluated again to evauate the result of the max
18:36:57 <Igloo> DukeDave: If you want to avoid it doing so, then pulling it out into a where clause will work in practice
18:36:58 <ihope> Well, a smart Haskell implementation will evaluate it only once.
18:37:10 <ihope> Also, now that I think of it, dsort = foldr1 max
18:37:11 <Cale> DukeDave: no
18:37:14 <Igloo> ihope: Not necessarily. There's a time/space tradeoff
18:37:32 <Cale> DukeDave: er, oh
18:37:33 <DukeDave> it just got me thinking :)
18:37:42 <dons> yes, dont' rely on CSE. do it yourself
18:37:58 <Cale> DukeDave: I missed the other guard
18:38:02 <DukeDave> essentially that -> ``how the hell can quicksort be so quick if this is the case''
18:38:14 <Cale> DukeDave: In that case, use where, which will ensure that the result is shared
18:38:59 <Igloo> Cale: The language doesn't actually require that
18:39:05 <DukeDave> so > max x x'; where x' = dsort xs;
18:39:08 <Cale> Igloo: I know :)
18:39:25 <Cale> Igloo: it doesn't actually require anything regarding evaluation semantics
18:39:41 <Cale> (other than that they be nonstrict)
18:39:47 <jip> what is the definition of iterate?
18:39:59 <DukeDave> I can see why people often advocate that on the path to fully understanding recursion it's best never to think about it :)
18:40:00 <Cale> iterate f x = x : iterate f (f x)
18:40:10 <jip> thanks
18:41:24 <Cale> DukeDave: or dsort = foldr1 max, or foldl1', if you'd like somewhat better performance
18:41:56 <DukeDave> well - I don't really 'need' it at all, it just got me thinking 
18:41:56 <dons> DukeDave: eventually your brain rewires itself, and then you see all loop constructs in terms of recursion. 
18:42:11 <dons> everything becomes a special case of recusion, rather than recursion being a special case
18:42:28 <DukeDave> that sounds like dangerous thinking there dons :)
18:42:29 <Igloo> Or just dsort = maximum
18:42:55 <DukeDave> I thought all recursion was just different notation for a stack implementation ;)
18:42:56 <jip> Cale: how would i write a iter :: (a -> (r, a)) -> a -> [r] ?
18:42:56 <davidmccabe> jip: I've just read your blog. I hope you don't mind my saying you're amazing.
18:43:07 <jip> davidmccabe: hehe cool thanks :)
18:43:11 <davidmccabe> jip: how long had you been playing with haskell before you started the project?
18:43:52 <jip> davidmccabe: i played around with haskell for a bit a year ago, but then i didn't touch a computer for about 10 months, and about a month ago i picked up haskell again
18:44:22 <Cale> jip: iter f x = let (r,x') = f x in r : iter f x'
18:44:30 <Igloo> Hmm, some interesting output from today's x86 Linux nightly build
18:45:20 <Cale> @type unfoldr
18:45:21 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
18:45:42 <Cale> @type unfoldr . (. Just)
18:45:44 <lambdabot> forall b a.
18:45:44 <lambdabot>         (Maybe b -> Maybe (a, b)) -> b -> [a]
18:45:46 <jip> Cale: thanks
18:45:47 <Cale> er
18:45:53 <Cale> @type unfoldr . (Just .)
18:45:55 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
18:46:10 <ihope> Hmm... can one do "let (# foo, bar #) = baz"
18:46:28 <ihope> Or is it only "case baz of (# foo, bar #)"?
18:47:10 <ihope> And why does (# foo, bar #) remind me of yellow flashing lights on a truck?
18:47:11 <Cale> > take 10 $ (unfoldr . (Just .)) (\x -> (x * 10, x + 1)) 0
18:47:12 <lambdabot> [0,10,20,30,40,50,60,70,80,90]
18:47:15 <toste> hugs_SOE-Jan2005 or 2003 ?
18:47:20 <toste> hugs_SOE-Jan2005.msi or 2003 ?
18:47:31 <Cale> jip: that seems to work nicely :)
18:47:33 <Igloo> ihope: Only case
18:47:53 <ihope> Okay.
18:47:54 <jip> Cale: what does? :o
18:47:57 <ihope> But why? :-)
18:48:03 <Cale> iter = unfoldr . (Just .)
18:48:48 <sjanssen> this works on my GHCi: let (# x, c #) = (# 'x', 'c' #)
18:48:48 <newsham> wouldnt "iter" be clearer? :)
18:49:08 <Cale> newsham: hm?
18:49:20 <Cale> iter f x = unfoldr (Just . f) x
18:49:28 <Cale> there's another variant
18:49:30 <ihope> sjanssen: unboxed tuples of Chars?
18:49:39 <ihope> That doesn't seem right to me.
18:50:21 <newsham> i'm probably missing context.
18:50:39 <newsham> but it seems like you wrote a complex expression using unfoldr and just when you could have used iter.
18:50:39 <Igloo> Oh, maybe it's just the variables that musn't have unboxed kinds then
18:51:01 <ihope> Okay. Why does (# 'x', 'c' #) work?
18:51:13 <Cale> newsham: I'm defining iter
18:51:19 <sjanssen> unboxed tuples hold boxed values
18:51:22 <dons> you can have unboxed tuples of ptrs, after all
18:51:25 <Cale> newsham: I obviously can't use it while I'm defining it :)
18:51:33 <ihope> Hmm...
18:51:51 <newsham> thats what I get for paying attention in th emiddle of a conversation
18:51:55 <ihope> Anyway, apparently I can't use the constructor C# for natural numbers...
18:52:04 <Cale> @type unfoldr . (Just .)
18:52:05 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
18:52:06 <ihope> It's taken for Chars/
18:52:06 <newsham> move along, nothing to see here  <idle/>
18:52:12 <ihope> Ah well.
18:52:20 <Cale> newsham: the challenge was to construct a function have a type similar to that
18:52:25 <Cale> having*
18:52:28 <DukeDave> wow
18:52:58 <DukeDave> Cale, I just tested the performance difference using a version with 'where'
18:53:23 <Cale> DukeDave: O(n^2) versus O(n) :)
18:53:38 <DukeDave> :)
18:54:24 <DukeDave> I may be leaving an abusive note on my lecturer's door I feel
18:54:56 <sjanssen> DukeDave: your lecturer gave you that code?
18:55:46 <DukeDave> oh, no, I we finished the course, I was just playing around
18:55:58 <DukeDave> (dead lines + no girlfriend)  :D
18:56:46 <jip> sweet! my ascii-art gameboy emulator works :D
18:58:00 <dons> jip, can we download this yet and play?
18:58:05 <dons> or do I need gameboy roms?
18:59:17 <jip> dons: well, you will obviously need a gameboy rom, but so far the emulator is only complete enough to view the title screens of two out of the dozens of games i've tested
18:59:55 <dons> very cool though.  its the kidn of thing i'd like to hack on in my spare time .. :)
19:00:26 <jip> dons: i think someone like you is needed to optimize this baby :)
19:00:50 <jip> anyway, now i have an ascii-art version working that doesn't rely on gtk, so i should be able to profile
19:01:20 <jip> http://img148.imageshack.us/img148/8571/dropzoneascii13pb.png
19:03:04 <newsham> > take 5 $ scanl (\x y -> x + 10) 0 [1..]
19:03:05 <lambdabot> [0,10,20,30,40]
19:03:32 <jip> how do i profile my program again? :)
19:05:38 <newsham> for(i = 0; i < 5; i++) x += 10
19:05:48 <dons> Igloo, with not too much effort I've got a version of pure Haskell 'maximum' that runs about as good as the C version :) one less cbit
19:06:14 <dons> jip, check:
19:06:16 <dons> ?wiki Performance
19:06:17 <lambdabot> http://www.haskell.org/haskellwiki/Performance
19:06:54 <jip> right thanks
19:07:45 <dons> Igloo, on a 5M string, the obvious haskell impl of maximum and minimum run in 0.023s, while the tight C loop runs in 0.016
19:07:49 <dons> close enough for me
19:10:52 <newsham> whats 43.75% between friends?
19:11:10 <dons> inside 2x is ok for me
19:11:24 <dons> to avoid calling into C
19:11:26 <newsham> got $1.43 in change?  I need change for a buck.
19:11:31 <newsham> ;-)
19:11:36 <dons> newsham :(
19:11:36 <jip> weee: http://img105.imageshack.us/img105/6815/asteroidsascii15ep.png
19:12:18 <newsham> jip: that pic is messed up in the middle.
19:12:30 <newsham> a friend of mine wrote an mpeg decoder that output ANSI
19:12:33 <jip> newsham: yep, emulation buginess
19:13:05 <jip> newsham: you saw the animated gif, right?
19:13:10 <newsham> live streaming ascii pr0n is something you have to experience to fully appreciate
19:13:15 <newsham> nope.
19:13:26 <jip> http://img88.imageshack.us/img88/6433/anim6at.gif
19:13:49 <newsham> cool
19:14:02 <toste> hey
19:14:12 <toste> i just installed on me lappy hugs98 SOE
19:14:22 <dons> ?karma+ jip
19:14:23 <lambdabot> jip's karma raised to 2.
19:14:24 <dons> well done
19:14:26 <toste> well, results aren't showing up, i get a blank line
19:14:42 <toste> > reverse ([1,2])
19:14:44 <lambdabot> [2,1]
19:15:15 <toste> what version shall i get ?
19:15:56 * toste poke Cale
19:17:19 <jip> is there a difference between -O and -O2 with ghc?
19:17:28 <dons> a tiny amount, if anything
19:19:34 <jip> here's the output from -sstderr
19:19:46 <jip> http://rafb.net/paste/results/5G6LMO27.html
19:20:26 <toste> hum u all use *nix 6
19:25:23 <Lokadin> say does lambdabot support karma?
19:25:38 <dons> ?help karma
19:25:39 <lambdabot> karma <nick>. Return a person's karma value
19:25:48 <Lokadin> karma dons
19:25:53 <Lokadin> hmmm
19:25:56 <dons> ?karma dons
19:25:56 <lambdabot> You have a karma of 27
19:26:05 <Lokadin> o
19:26:33 <dons> because I keep writing lambdabot plugins :)
19:26:38 <Lokadin> :)
19:26:56 <Lokadin> how do you karma people? like give or take?
19:27:04 <dons> ?karma+ lambdabot
19:27:05 <lambdabot> lambdabot's karma raised to 12.
19:27:12 <dons> ?karma- lambdabot
19:27:13 <lambdabot> lambdabot's karma lowered to 11.
19:27:14 <Lokadin> lol cool
19:27:43 <Lokadin> :)
19:29:10 <Lokadin> hmmm is it like an app that install and such/
19:29:12 <Lokadin> ?
19:29:19 <Lokadin> as in can i make an ebuild for it?
19:29:48 <Lokadin> eh i'll go check myself
19:29:52 <Lokadin> thanks cya!
19:29:57 <dons> you can install it, yep
19:30:03 <Lokadin> kk :)
19:30:04 <dons> ?version 
19:30:05 <lambdabot> lambdabot 3p414, GHC 6.4.1 (Linux i686 3.20GHz)
19:30:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:30:11 <dons> ?where lambdabot
19:30:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:30:25 <palomer> hrmph, I just wrote something really big 
19:30:32 <palomer> I wonder how I can get a line count of the directory tree
19:30:55 <sjanssen> palomer: find -type f | xargs wc -l
19:31:33 <palomer> what does xargs do?
19:32:13 <sjanssen> xargs takes the things it is piped and appends it to the command its given
19:32:22 <newsham> reads stdin, splits arguments and feeds them to the command (executing it multiple times if necessary to avoid command line limits)
19:32:26 <dons> palomer, you want a count_words script?
19:32:28 <palomer> very nice
19:32:30 <dons> let me find one...
19:32:39 <dons> or do you care about stripping comments?
19:32:44 <newsham> find -type f -print0 |xargs -0 wc -l     better
19:33:02 <sjanssen> oh, spaces in filenames I suppose
19:33:14 <newsham> yah, uses NULs to seperate instead of spaces.
19:33:54 <newsham> also you gotta be careful with things like "wc".  xargs can run the command multiple times.  make sure to grep the "total" line and accumulate those if you really want a total count
19:34:03 <dons> count_lines, here it is: ftp://ftp.cse.unsw.edu.au/pub/users/dons/misc/count_lines
19:34:24 <dons> $ count_lines *.hs */*.hs */*/*.hs
19:34:28 <dons> TOTAL:                12381   4538
19:34:33 <dons> code/comments in lambdabot (!)
19:34:49 <newsham> find . -name '*.hs' -print0 |xargs count_lines
19:35:00 <dons> it also breaks it up per directory and per file
19:35:01 <newsham> xargs -0
19:35:54 <palomer> whew, 6000 lines of code
19:36:06 <palomer> I like this script
19:36:11 <palomer> and 1000 lines of comments?
19:36:15 <palomer> nonsense!
19:36:25 <palomer> oh, it's counting something which I included
19:37:42 <sjanssen> dons: would you take an @v plugin if I wrote one?  it'd just be a quote thing like @arr
19:38:29 <dons> sure. what would it quote? the attempt to hit the 'v' variable?
19:38:59 <dons> jsut add the text to Plugin/Quote/Text.hs and then add an entry in Plugin/Quote.hs for the command
19:39:00 <sjanssen> yeah, print either take 20 v or Exception: <<loop>>
19:48:08 <goldie22> how do you able to call a function and compare its output with somethin
19:51:30 <dons> > sort "haskell" == "haskell
19:51:31 <lambdabot>  lexical error in string/character literal
19:51:36 <dons> > sort "haskell" == "haskell"
19:51:37 <lambdabot> False
19:51:41 <dons> is that what you mean?
19:51:54 <dons> > let x = sort "haskell" in if x == "foo" then 1 else 0
19:51:55 <lambdabot> 0
19:52:19 <dons> > if x == "foo" then 1 else 0 where x = sort "haskell"
19:52:20 <lambdabot> 0
19:55:40 <goldie22> umm yeah sort of...
19:56:13 <goldie22> i have one function called threedifferent, which you input 3 values and it will return true if all are different
19:56:23 <goldie22> and then i have to use that function to write fourequal
19:56:34 <goldie22> and i have to use the threedifferent function
19:56:50 <dons> right. so you'll call threedifferent, and saves its result with a 'let' or a 'where'
19:56:59 <dons> and then compare that value against some other value
19:57:09 <dons> let v = threedifferent a b c in ...
19:57:17 <goldie22> oh you have to store the value
19:57:36 <goldie22> you cant just go straight ou comapring threedifferent (a b c) == True
19:59:35 <dons> sure you can
19:59:44 <dons> threedifferent a b c == True
19:59:56 <dons> which is the same as just saying: threedifferent a b c
20:02:19 <goldie22> oh ok
20:02:20 <goldie22> cool
20:02:23 <goldie22> ill fiddler around
20:02:33 <dons> :)
20:02:43 <dons> you usign ghci or hugs to test?
20:07:19 <goldie22> hugs
20:26:36 <Cale> goldie22: perhaps you're aware of it already, but I'll point it out just in case, that threedifferent (a b c) would apply the function threedifferent to the single parameter which is the function a applied to two parameters b and c, rather than applying threedifferent to the three parameters a, b, and c, as dons showed.
20:35:44 <DukeDave> anyone up for some pain? :)
20:36:09 <Pseudonym> You could ask in #bdsm.
20:36:24 <DukeDave> brought to you by the 'unification would give infinite type' dept. ;)
20:36:39 <Pseudonym> Yay.
20:36:47 <sjanssen> dons: regarding your email to the libs list, have you considered Data.PackedString.Latin1?
20:36:53 <Pseudonym> However, 99% of the time, there's a simple explanation.
20:37:14 <Pseudonym> You may have left out an argument on the LHS of a function definition.
20:37:33 <DukeDave> I'm trying to do a `simpler' version of the knapsack problem
20:38:16 <Pseudonym> Oh, yeah, well.  Solving the knapsack problem is type incorrect, so there's your problem.
20:38:19 <DukeDave> so given [int] and a maximum int, what is the closest you can get to int, without going over, using only values in [int]
20:38:31 <DukeDave> :O
20:38:39 <Pseudonym> Errr...
20:38:45 <Pseudonym> Sorry, what do you want to represent exactly?
20:39:13 <sethk> int - 1?
20:39:29 <DukeDave> say I have the coins 2, 3, 5,  and I want 11, 
20:39:53 <DukeDave> the closest I can get (without going over) is 5+3+2
20:39:54 <sethk> oh, the british money problem
20:40:07 <sethk> you guys are too young for that :)
20:40:36 <DukeDave> heh, being from england I feel I should know it :)
20:40:39 * DukeDave googles
20:40:51 <DukeDave> actually, hell, here's my attempt:
20:41:04 <DukeDave> knapsack 0 _ = 0
20:41:11 <DukeDave> knapsack max items = [x + knapsack x-1 | x <- items, x <= max]
20:41:12 <sethk> DukeDave, before they rationalized the money, it was a common algorithm question:  how do you make change in British money?
20:41:19 <sethk> DukeDave, it's essentially the same problem
20:41:21 <Pseudonym> Why not knapsack 0 _ = [0]
20:41:37 <Pseudonym> Don'
20:41:41 <Pseudonym> t you WANT to return a list?
20:42:00 <DukeDave> oops, sorry:
20:42:08 <DukeDave> knapsack max items = maximum [x + knapsack x-1 | x <- items, x <= max]
20:42:53 <Pseudonym> First off, put a type declaration on the knapsack function.
20:43:12 <Pseudonym> 99.99% of the time, that gives you a better error message which completely explains what the real problem is.
20:43:21 <Pseudonym> Actually, more like 98% of the time.
20:43:37 <Pseudonym> The other 2% there's polymorphism involved.
20:44:01 <DukeDave> :)
20:46:30 <dons> where polymorphism could mean rank-Oleg polymorphism
20:46:30 <Pseudonym> Did you put a type declaration on?
20:47:30 <DukeDave> yeah
20:47:40 <DukeDave> now I'm about 15% more confused :)
20:48:44 <Pseudonym> What type declaration did you give?
20:49:06 <DukeDave> Int -> [Int] -> Int
20:49:15 <Pseudonym> And the error message?
20:49:26 <DukeDave> although, it could be, Ord a => a -> [a] -> a
20:50:17 <DukeDave> type error
20:50:45 <Cale> my guess is that your first problem is that you're calling knapsack with a single parameter x, when it takes two
20:51:06 <Pseudonym> I know.  I wanted him to find it, though. :-)
20:51:14 <Cale> x + knapsack x-1 is x + (knapsack x) - 1
20:51:31 <DukeDave> gotcha :)
20:51:38 <DukeDave> just noticed :)
20:51:41 <Pseudonym> What you actually want is knapsack (x-1) items
20:52:53 <Cale> don't you want  knapsack (max - x) items ?
20:53:01 <DukeDave> ouch
20:53:09 <DukeDave> no its died hard *_*
20:53:13 <Pseudonym> Or (max-1)
20:53:19 <DukeDave> Program error: pattern match failure: foldl1 (Ord_max instOrd_v28) []
20:53:23 <Pseudonym> No, you're right.  (max-x)
20:53:29 <Cale> you'll need a base case of course :)
20:53:48 <Pseudonym> > maximum []
20:53:49 <lambdabot> Add a type signature
20:53:50 <DukeDave> knapsack 0 _ = 0
20:53:51 <Pseudonym> > maximum [] :: Int
20:53:52 <lambdabot> Exception: Prelude.maximum: empty list
20:53:53 <Cale> what if the items list is empty?
20:54:04 <DukeDave> it never shall me
20:54:06 <DukeDave> *be
20:54:07 <Pseudonym> You're using Hugs, I see.
20:54:13 <Pseudonym> Well, it is.
20:54:19 <Pseudonym> Because that's what the error is.
20:54:47 <DukeDave> knapsack max items = maximum [x + knapsack (x-1) items | x <- items, x <= max]
20:55:04 <Cale> or somewhere else in your program, a function is getting an empty list it can't deal with
20:55:15 <Pseudonym> Ah, no wonder.
20:55:19 <Cale> but it's here
20:55:20 <DukeDave> I only have this one function
20:55:22 <Pseudonym> Yes, it's getting an empty list.
20:55:27 <DukeDave> x <- items   ?
20:55:31 <Cale> you're eventually calling maximum with the empty list
20:55:39 <Cale> you really don't want that
20:55:45 <Pseudonym> Hint: what if x > max for all x?
20:56:01 <DukeDave> ahh
20:56:57 <palomer> the maximum of []::[Int] is 42
20:58:06 <DukeDave> maximum returns the greatest value elem in Ord a => [a], correct?
20:58:13 <Pseudonym> Yes.
20:58:35 <DukeDave> So, maximum []  is undefined?
20:59:15 <Pseudonym> Correct.
20:59:45 <DukeDave> I have added 'knapsack _ [] = 0'
20:59:52 <DukeDave> but am still getting the same error
21:00:09 <Pseudonym> Oh, one more thing.
21:00:14 <Pseudonym> > 1 <= max
21:00:15 <lambdabot>  add an instance declaration for (Ord (a -> a -> a))
21:00:15 <lambdabot>   In the definition of `tvu': tvu = 1 <= max
21:00:15 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
21:00:26 <Pseudonym> max is a function
21:00:37 <Pseudonym> @type max
21:00:38 <lambdabot> forall a. (Ord a) => a -> a -> a
21:01:00 <Pseudonym> It's usually not good to call variables by the same names as built-in functions.
21:01:07 <Pseudonym> Especially ones you may want to use at some point.
21:05:50 <DukeDave> oka
21:05:54 <DukeDave> getting closer
21:06:46 <Cale> http://paste.lisp.org/display/19178 -- the list monad makes it fairly pleasant to write
21:09:01 <Cale> the list-returning version makes an inefficiency apparent
21:09:50 <Cale> you can drop out elements of items which are less than the item which you chose, which ensures that you don't end up producing both [3,5] and [5,3]
21:09:53 <Cale> for instance
21:11:03 <Cale> which makes knapsack' [2,3,5] 10 go from 57 down to 18 items
21:13:52 <DukeDave> *_*
21:16:34 <DukeDave> man
21:16:45 <DukeDave> stack control overflow 
21:16:51 <DukeDave> ... it's not my night
21:17:20 <Pseudonym> Sounds like an infinite loop.
21:18:01 <DukeDave> think I've spotted it :)
21:23:58 <davidmccabe> Yayyyyyyy. A haskell tutorial that neither handwaves everything away, nor assumes the reader has a degree in CS.
21:24:09 <davidmccabe> http://www.isi.edu/~hdaume/htut/
21:24:24 <Cale> davidmccabe: yes, that's the one I always recommend
21:27:14 <jcreigh> davidmccabe: Yeah, that's a good one. I almost understood the bit about CPS.
21:28:59 <davidmccabe> I even actually understand it.
21:29:10 <davidmccabe> However, I haven't gotten to Monads yet, so we'll see how well it handles that topic ;)
21:29:24 <davidmccabe> Also, there's one exercise that I can't for the life of me figure out how to do.
21:29:46 <davidmccabe> But in general it's far better than anything else I've seen, and I've been looking hard for something I could understand.
21:30:01 <davidmccabe> (that is, that I could understand the tutorial, and that the tutorial would let me understand something about Haskell)
21:31:01 <davidmccabe> There was a write-scheme-in-haskell tutorial a while back, which was very practical and hands-on, but it handwaved everything to such an extent that I couldn't understand what was really going on, and so I couldn't make even trivial modifications to the program.
21:31:05 <Cale> for monads, you should read my tutorial, and then "All About Monads"
21:31:20 <davidmccabe> where your tutorial is what?
21:31:22 <Cale> @oldwiki MonadsAsContainers
21:31:23 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
21:31:39 <Cale> that one :)
21:31:41 <davidmccabe> Old wiki.
21:31:57 <Cale> yeah, I haven't bothered moving it to the new one
21:33:15 <Lokadin> does anyone here use freenet 0.7
21:33:16 <Lokadin> ?
21:35:34 <Lokadin> no? :(
21:35:44 <davidmccabe> Not I.
21:35:50 <davidmccabe> try #freenet?
21:41:26 <machack666> is there a version of Parsec which works directly with FastPackedString?
21:42:08 <Lemmih> How about using FPS in the lexer?
21:46:35 <machack666> that would be the token prims?
21:47:03 <newsham> hmm..  I'm not sure I like hws-wp.  plugins are definitely nice, but some of the implementation is not to my liking.
21:57:52 <davidmccabe> Exercise 4.6 Write a datatype Tuple which can hold one, two, three or four elements, depending on the constructor (that is, there should be four constructors, one for each number of arguments). Also provide functions tuple1 through tuple4 which take a tuple and return Just the value in that position, or Nothing if the number is invalid (i.e., you ask for the tuple4 on a tuple holding only two elements).
21:58:05 <davidmccabe> That's the one I can't figure out.
21:58:21 <davidmccabe> Apart from defining a version of each function for each constructor.
21:58:27 <davidmccabe> Which can't be right, right?
21:58:29 <Lokadin> say does lambdabot support silc?
21:58:53 <Cale> davidmccabe: well, that seems like it would work. I suppose you could also use case expressions.
21:58:54 <newsham> ls
21:59:33 <davidmccabe> Cale: but there's no nice way to do it, where each function accepts ANY tuple, with one definition for the function, and then decides whether or not the specific element it's interested in exists?
21:59:59 <machack666> davidmccabe: this sounds ideal for pattern matching.
22:00:13 <dons> Lokadin: nope.
22:00:46 <Lokadin> say when setting up lambdabot how do i indicate i don't need a proxy?
22:02:10 <Lokadin> in Conf.hs
22:02:11 <dons> you edit Config.hs, and insert Nothing for proxy, instead of Just ...
22:02:16 <Lokadin> o okay
22:02:18 <Lokadin> thanks :)
22:03:24 <Lokadin> what are fptools?
22:03:50 <dons> the standard haskell libraries. used by the Code plugin. don't worry about it
22:03:58 <Cale> davidmccabe: well, you're sort of writing the thing which would let you do that :)
22:04:16 <Lokadin> lol so i should leave it as /home/dons/fptools?
22:04:24 <Cale> (i.e. the function which determines if the value in a specific postision exists)
22:04:36 <dons> Lokadin: yep, won't hurt
22:04:41 <Lokadin> kk
22:04:55 <Lokadin> outputdir
22:04:58 <Lokadin> does that matter?
22:04:58 <davidmccabe> Cale: ah, well, if I have to basically do it by hand, then I guess I *did* figure it out :)
22:04:59 <davidmccabe> thanks.
22:05:19 <dons> Lokadin: should be State/
22:05:28 <dons> used only by the Log plugin
22:05:35 <Lokadin> kk
22:05:41 <Lokadin> thanks :)
22:07:53 <Lokadin> Failed to load interface for `Lambdabot':
22:07:56 <Lokadin> :(
22:08:33 <dons> hmm?
22:08:38 <dons> do you have the lastest lambdabot?
22:08:46 <dons> it shouldn't even build with hs-plugins by default
22:09:05 <Lokadin> hmmm let my try darcs pull again
22:09:16 <lispy> might also try dracs changes
22:09:28 <lispy> and also darcs whatsnew
22:09:41 <dons> last patch should be Wed Apr 19
22:10:35 <Lokadin> hmmm says it finished pulling everything in, and whatsnew just shows the config file changes
22:10:39 <Lokadin> i can try partial again
22:11:27 <dons> gmake distclean
22:11:48 <dons> you probably didn't reconfigure and rebuild the Modules.hs file between pulls
22:12:26 <Lokadin> bah i'm already doing partial, i don't remmber ever compiling it before
22:13:21 <dons> you're not buliding it with: gmake dynamic=yes are you?
22:14:15 <Lokadin> no
22:14:25 <Lokadin> should i be?
22:14:32 <lispy> no
22:14:36 <dons> nope.
22:14:37 <Lokadin> kk
22:14:54 <lispy> dons: how's research going?
22:15:11 <dons> hacking away on fps.
22:15:17 <dons> should do more 'real' work I guess
22:15:21 <lispy> heh
22:15:31 <lispy> what aspect are you hacking on?
22:15:38 <lispy> that thing about balanced trees?
22:16:04 <dons> i've written a nice little benchmarking tool that compares strings in fps against various other string libraries, and based on that real data, i'm optimising various functions for space and time
22:16:10 <dons> instead of stabbing in the dark
22:16:16 <lispy> hehe
22:16:28 <lispy> have you tried it with and without mmap?
22:16:44 <lispy> i found mmap in the case of darcs adds a lot of 'unpredictabilit'
22:16:55 <Lokadin> same problem :(
22:16:56 <dons> doesn't make much difference here, as i'm only testing in-memory code after being fully evaluated
22:16:59 <dons> so no io should be measured
22:17:04 <dons> Lokadin: what compielr are you using?
22:17:08 <lispy> ah right
22:17:21 <dons> just runnign fps over a 50M string atm, seems to handle it nicely now
22:17:26 <Lokadin> dons: gcc
22:17:28 <dons> have to try 1G later.
22:17:35 <dons> Lokadin: which ghc?
22:17:40 <dons> which ghc version.
22:17:48 <Lokadin> o
22:17:57 <lispy> dons: hmm...we need a way to turn FPS into a library so that darcs can just grab the lastest and run with it
22:17:58 <dons> huh. filter over a 50M string, 0.3s
22:18:00 <palomer> I need to take a break from computers
22:18:09 <Lokadin> 6.4.2_pre20060403
22:18:13 <lispy> palomer: you could become a stripper
22:18:14 <dons> lispy, it will be. its giong into fptools base this week
22:18:18 <lispy> palomer: i hear it's exciting
22:18:36 <dons> should help darcs out a bit, as its improved a fair bit on the original darcs fps
22:18:51 <lispy> dons: excellent, although wouldn't that require very recent ghc?
22:18:56 <dons> huh. 50M is really too small to stress fps it seems.
22:19:00 <dons> lispy, why so?
22:19:04 <Lokadin> dons: ghc-6.4.2_pre20060403
22:19:08 <dons> ah, yes. for ghc 6.6
22:19:23 <dons> they could always have darcs depend on fps, I guess. its cabalsied and a normal everyday library
22:19:39 <dons> Lokadin: I'd need mroe info then. perhaps paste the build transcript
22:20:08 <lispy> dons: ya know, i don't think darcs is cabalized
22:20:23 <Lokadin> Glasgow Haskell Compiler, Version 6.4.2.20060403, for Haskell 98, compiled by GHC version 6.4.2.20060403
22:20:26 <Lokadin> Using package config file: /usr/lib/ghc-6.4.2.20060403/package.conf
22:20:28 <Lokadin> Hsc static flags: -static
22:20:29 <dons> doesn't matter. its the libraaries it uses that need to be cabalised, no?
22:20:36 <dons> so darcs can just add --package fps
22:20:48 <lispy> dons: i don't know if the maintainers would want to 'force' people to upgrade.  iirc darcs build may still be supported on 6.2.2
22:21:09 <dons> sure. I'd suspect darcs would migrate to fps once its in base, and in a year or two
22:21:12 <dons> there's no rush
22:21:19 <lispy> yeah
22:21:52 <Lokadin> dons: is there any other information i can give/
22:22:18 <lispy> well, i'd like some of the bigger issues with darcs to be solved tomorrow...and performance is one of them.  But tweaking FPS isn't going to be the way to boost darcs performance
22:22:25 <dons> Lokadin: the full transcript of what you type to get lambdabot to build, including what arch you are on. mail it to me, or post it on the paste page
22:22:32 <dons> lisppaste: url
22:22:38 <dons> lispy: right
22:22:47 <Lokadin> kk
22:23:32 <lispy> i was going to work on darcs more...but i got discouraged and busy
22:23:37 * dons throws 100M at fps
22:23:49 <lispy> ha-ruken!
22:23:58 <lispy> (said in a street fighter voice)
22:24:08 <dons> this 3.2G box really can take the heat.
22:24:23 <lispy> heh, i bet
22:24:45 <dons> helps having 2G ram
22:24:54 <palomer> @yow
22:24:55 <lambdabot> I am having FUN...  I wonder if it's NET FUN or GROSS FUN?
22:25:02 * palomer wonders what yow stands for
22:25:10 <dons> its what zippy likes to say
22:25:44 <palomer> so it doesn't mean anything?
22:26:04 <dons> nope
22:26:10 <dons> its not a SECRET CODE
22:26:14 <Cale> http://paste.lisp.org/display/19179 -- heh, how to decide on performing each step of the algorithm as late as possible. (knapsack)
22:26:40 <palomer> this is the knapsack algorithm?
22:26:49 <Cale> the one from earlier
22:26:58 <Lokadin> yeah so it's at http://paste.lisp.org/display/19180
22:27:07 <palomer> wasn't paying attention earlier
22:27:22 * dons watches a haskell program use 3G ram
22:27:31 <dons> sigh, and killed :(
22:27:34 <palomer> :(
22:28:01 <Cale> basically, choosing sets of elements of a list such that their sum is less than some bound
22:28:04 <lispy> dons: how big was the input?
22:28:05 <dons> packing a 100M [Char] into a 100M fps is too hard
22:28:09 <dons> but that's the [Char]s fault, I claim
22:28:25 <lispy> oh right, [Char] might be huge
22:28:30 <lispy> can you find out how big one would be?
22:28:35 <lispy> then factor that out
22:28:49 <Cale> dons: the pack function can't lazily consume the list?
22:28:54 <dons> yeah, I just switch off functions as they fail, and keep pushing the remainging functions on larger and larger inputs
22:29:05 <dons> Cale, it would be possible, a la lazy packed getContents
22:29:07 <Pseudonym> Just to check, this is to compute the number of solutions, right?
22:29:13 <Pseudonym> knapsack, that is
22:29:33 <Cale> Pseudonym: if you replace maximum . map sum with length
22:29:38 <dons> but you wouldn't bother with a 100M [Char] in the first  place, once you've got fps installed
22:29:44 <Pseudonym> Ah.
22:30:13 <Pseudonym> Just checking, but wouldn't minimum be more useful than maximum?
22:30:27 <Pseudonym> Otherwise knapsack n [1,2,5,10] is just a fancy way of computing n.
22:30:52 <Cale> well, if 1 is in the list, then it's n
22:30:59 <Pseudonym> Yes.
22:31:18 <Cale> It computes the largest value which you can make which is still less than or equal to n.
22:31:26 <Pseudonym> Ah.
22:31:26 <Lokadin> dons: you want me to mail it to you so you can look at it later?
22:31:28 <Pseudonym> Got it.
22:31:41 <dons> Lokadin: yep, that'd be good.
22:31:50 <Lokadin> dons: er what's your email?
22:32:19 <dons> dons@cse.unsw.edu.au
22:32:23 <Lokadin> thanks
22:32:52 <Cale> you could add something like prune ((< k) . length) to knapsack' in order to only compute those which are less than a given number of elements.
22:33:39 <dons> ah, much better. not buildign 100M Strings makes things much smoother
22:33:42 <Cale> thanks to laziness, that will actually speed things up :)
22:34:16 <dons> filter . (==) on 100M, 1.417s :)
22:34:29 <lispy> whoa, so it more than doubled?
22:34:45 <lispy> what should have it gone up? linear?
22:34:53 <Lokadin> kk sent
22:35:09 <dons> lispy, not sure. soem other things changed in the program.
22:35:14 <dons> i'll have to run it a couple of times
22:36:46 <dons> ok, lets try 0.5G
22:36:50 <lispy> hehe
22:37:22 <dons> i remember vincenz always complained he had soem 2-4G strings he couldn't manipulated in haskell, and i'm still not sure we can do this without massive lazyness
22:37:25 <dons> i wonder.
22:37:33 <lispy> dons: how do you generate the strings? lorem ipsum? ;)
22:37:46 <dons> I start with a 1M file and keep doubling it
22:37:56 <lispy> ah, yeah i've done that
22:37:58 <dons> with cat 10M >> x ..
22:38:06 <dons> for example
22:38:39 <lispy> i remember running "cat big >> bigger && cat bigger >> big" a few times to fill up my harddrive
22:39:18 <aufrank> hello all!
22:39:35 <dons> ok. here goes...
22:40:16 <dons> good signs. concat to a 1G string takes 1.7s
22:40:19 <palomer> lispy: but big is bigger than bigger!
22:40:30 <Pseudonym> http://paste.lisp.org/display/19181
22:40:35 <lispy> palomer: rinse. lather. repeat.
22:40:39 <Pseudonym> That's about as fast as I can do.
22:40:42 <lispy> dons: congrats
22:40:50 <dons> map is struggling. lets see...
22:41:01 <dons> these higher order funs always suffer the most
22:41:06 <aufrank> is this with FPS, dons?
22:41:13 <dons> yep :) doing some stress testing
22:41:17 * aufrank is like a child who wanders into a movie and asks what is going on
22:41:25 <lispy> so you gain 300 ms, is that statisticly stable or just a single data point?
22:41:27 <dons> map took 68s over 500M toUpper
22:41:42 <dons> from 14s on 100M
22:41:52 <dons> unlines exhausted memory. oh well
22:42:02 <dons> lines took 7s, pretty good
22:42:16 <palomer> how does this compare with C?
22:42:27 <dons> I don't have a map written in C :)
22:42:31 <lispy> hehe
22:42:35 <lispy> i do
22:42:39 <lispy> but you have to use lists
22:42:44 <lispy> and my lists are crusty
22:42:45 <dons> I would expect these numbers are pretty close for monomorphic stuff
22:43:03 <dons> filterChar      3.623, removing a char from a byte array, returnign a new array
22:43:13 <dons> couldn't be much faster on 1/2 a gig in C, surely?
22:44:03 <lispy> why aren't these tests part of the shoot out? ;)
22:44:21 <dons> good thing once fps is in the base lib, for the shoot out I think.
22:44:29 <aufrank> does anyone have any pointers to implementations of neural networks in haskell?
22:44:41 <dons> faster and shorter code. and they never really push the limits anyway. the biggest shootout data is around 5M
22:44:56 <dons> aufrank: I think there's some libs on the libraries page of haskell.org
22:45:00 <lispy> aufrank: hmm...someone had HMM library...which is similar i'd imagine so they might have done neural too
22:45:05 <dons> maybe under the maths category?
22:45:10 <dons> ?wiki Libraries_and_tools
22:45:10 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools
22:45:17 <aufrank> it's a domain that I've worked on in imperative languages and I'd like to see what the haskell approach looks like
22:45:26 <aufrank> and go after it myself :)
22:45:32 * aufrank goes to look around
22:46:27 <lispy> aufrank: i know an AI student that took two classes in haskell before implementing his machine learning in C++ instead...but in his defense he has to run his algorithms on a super computer just to get an answer in a few months
22:46:40 <dons> hmm. with a 514M string, the bench program uses 519M of ram :)
22:47:39 <dons> Lokadin: you don't have fps installed!
22:47:53 <dons> Could not find module `Data.FastPackedString'
22:48:01 <dons> Lokadin: better install that if you want lambdabot to build
22:49:38 <dons> ok, now we try 1G strings..
22:49:47 <dons> I'm hoping the server doesn't melt
22:51:44 <dons> ok. trying on a 8-cpu 8G linux box... maybe it will be ok after all
22:51:45 <lispy> whoa, that's pretty good, 5mb overhead is nothing, and i'm guessing that's a constant
22:51:52 <dons> yep
22:52:12 <dons> I reckon so. once that big array is stuck in memory, the GC is cleanign things up nicely
22:52:21 <lispy> wish darcs could read the current patch format with that little overhead :)
22:53:04 <lispy> i keep thinking someone is working on the new patch format but the realitiy is that everyone wants it and no one is doing it :)
22:53:23 <dons> :(
22:53:43 <dons> ok. the 1G string goes in ..
22:54:14 <dons> grr bench: out of memory (requested 1088421888 bytes)
22:54:19 <dons> damn admins
22:55:00 <dons> ah, try a box I have more perms on
22:55:03 <lispy> well, most normal programs don't allocate like that :)
22:55:20 <lispy> the C way is to stream the daat
22:55:24 <dons> just have to know its possible..
22:55:33 <lispy> totally
22:55:44 <lispy> i should be in bed but i'm staying up to hear how this turns out :)
22:55:51 <davidmccabe> listFoldr _ _ Nil = Nil
22:55:51 <davidmccabe> listFoldr f i (Cons x Nil) = f x i
22:55:51 <davidmccabe> listFoldr f i (Cons x xs) = f x (listFoldr f i xs)
22:55:51 <davidmccabe>  
22:55:52 * aufrank is curious now too
22:55:58 <dons> ok, its running now... lets see...
22:56:04 <davidmccabe> Any ideas why that doesn't work? (cons and nil work as expected)
22:56:14 <dons>  1293 dons      18   0 2079m 1.7g 851m D  2.3 84.0   0:02.23 bench ...
22:56:16 <swoolley> anybody know how to get the ghc to compile itself in more than one process?
22:56:27 <dons> swooley, gmake -jN ?
22:56:47 <dons> ok, so ++ doesn't work with two 1G strings :) 
22:56:53 <dons> ++              bench: realloc: resource exhausted (out of memory)
22:56:57 <swoolley> tried that already
22:57:23 <lispy> davidmccabe: you'r missing a (Cons ...) before an f x me thinks
22:57:52 <dons> ah, much better. lenght(1G) is still O(1)  :) the universe didn't go funny.
22:57:59 <sjanssen> davidmccabe: the usual thing for foldr to do when given an empty list is give an error  is the first case you give intentional?
22:58:09 <dons> so, the question, is it possible to map toUpper 1G ?
22:58:17 <swoolley> I'll see if I can dig a bit deeper
22:58:32 <davidmccabe> sjanssen: not really.
22:58:37 <lispy> oh right, and that's what threw me off...i was thinking it had to return a Cons
22:58:37 <davidmccabe> sjanssen: thanks for pointing that otu.
22:58:48 <lispy> because of the nil cas
22:58:50 <lispy> er case
22:58:58 <sjanssen> davidmccabe: sorry, I'm wrong.  foldr doesn't give an error, it will just return your 'i' value
22:59:04 <davidmccabe> which makes sense.
22:59:11 <davidmccabe> and simplifies the definition, actually. duh.
22:59:43 <davidmccabe> aaaaaand it works :) thanks!
23:00:51 <dons> map             143.871 !!
23:01:13 <dons> ah, but filter ran out of ram. just need more ram :)
23:03:29 <dons> 1st order filter, though, filterChar      8.084s :)
23:03:57 <dons> lines           12.247s. that's a lot of lines.
23:04:16 <sjanssen> how do you do filter in fps?  do you have to run the predicate on the string twice (once to find the length, once to fill the string)?
23:04:17 <lispy> dons: how did you distribute your \n chars?
23:04:47 <dons> normal line widths.
23:05:12 <lispy> so 70-80 chars per line?
23:05:13 <dons> sjanssen: nope. the length is accumulated. and you start by guessing the length == the current length ( O(1) )
23:05:16 <dons> roughly
23:05:27 <dons> words           100.963.
23:07:00 <lispy> it seems that comparing lines to words just compares the density of \n to " "
23:07:23 <dons> yep.
23:10:07 <dons> so, I think with about 8G (rather than 2) of RAM, 1G files are certainly doable.
23:10:31 <dons> huh inits           33.620  
23:10:32 <dons> tails           27.328 
23:12:02 <aufrank> ok, /me has to get to bed now
23:12:48 <aufrank> I hope I'll be back and bugging you all for help tomorrow ;)
23:14:11 <aufrank> \quit
23:21:26 <PeterK> is anyone aware of or interested in the use of Haskell in "stylometry" or, specifically, computer-aided authorship attribution?
23:21:35 <PeterK> (to start with, I want to use Haskell to implement the technique of Khemelev based on Markov chains, but that's just one method)
23:22:20 <olliej> What do the two type params to Array represent?
23:22:27 <lispy> PeterK: what?
23:22:46 <lispy> PeterK: computer-aided authorship attribution? so determining who is the author based on style?
23:23:03 <PeterK> http://www.ma.utexas.edu/users/dima/PAPERS/published/llc/khmelev-tweedie-2001.html
23:23:10 <PeterK> that is one method
23:24:38 <PeterK> typically, taking a set of possible authors who have known works, and deciding which is the most likely author of the disputed or unknown work. can also be done on all works of known authorship to test the methods. it uses measures of the characteristics of a writer's output, which might be (misleadingly) called style
23:25:33 <sieni> olliej: the types of a) the indices and b) the values
23:25:41 <lispy> huh, you could use this to defaut double blind paper reviews
23:26:24 <olliej> sieni: cheers
23:27:56 <PeterK> this would be my first significant project in Haskell and was wondering whether anything had been done in the language along these lines before, or if there were interest in it
23:28:18 <dons> possibly. a lot of haskell people are also authors :)
23:39:24 <newsham> how similar is generated assembly code to intermediate code (spineless tagless)?  how hard is it to go from intermediate code to src code?
23:39:40 <newsham> (how hard is it to reverse engineer a haskell generated binary?)
23:39:53 <dons> hard
23:39:58 <dons> Core to Haskell, easy.
23:40:05 <dons> Asm/C to Core, hard
23:40:13 <dons> you've got to reverse the ghc codegen
23:40:24 <dons> and its non trival compiling an fp lang to imperative code
23:40:32 <newsham> how hard compared to asm to C, for example?
23:40:33 <dons> you could get from Asm back to C--, I'd think
23:40:39 <dons> oh, much harder.
23:40:45 <dons> as asm to C is just the first step,
23:40:54 <dons> then you've got to get from C back to pure haskell lambda calc
23:41:06 <dons> i.e. reverse the stg paper.
23:41:20 <newsham> i mean a typical C program .exe back to src.
23:41:24 <dons> presumably there's a paper or two in the result, if you could do it.
23:41:29 <newsham> vs a ghc .exe back to something resembling src
23:41:41 <dons> I think, foobar times harder
23:41:53 <dons> since ghc uses C -> asm as its final 'easy' stage
23:42:06 <dons> I can't give a number, but i think its pretty non-trival.
23:42:19 <newsham> sure, but thats neither here nor there.  C doesnt need to be in the process, and doesnt affect things that much I imagine.
23:42:20 <dons> students write toy C -> asm compilers for fun, they don't write toy fp lang to C compilers
23:42:39 <dons> the semantics are much further separated. and its that gulf that's the problem
23:42:46 <ulfdoz> re
23:42:52 <dons> you'd have to encode much more knowledge in the dissassembler
23:43:00 <dons> and even then you'd only get back to GHC Stg code
23:43:06 <ulfdoz> .oO( and another registration performed. )
23:43:12 <dons> which i presume is why its never been doen..
23:43:30 <newsham> not sure what you mean "encode more knowledge in the disasembler"
23:43:44 <newsham> most uncompilers dont attempt to recover compiler specific translations
23:43:52 <dons> there's more analysis required to uncompile the code.
23:44:04 <newsham> but rather build models of the assembly execution and transform that into something that looks like src
23:44:07 <dons> to work out what each fragment corresponds to in its Core version
23:45:00 <newsham> have you ever had to debug the assembly (ie. for a particularly nasty bug)?
23:45:09 <dons> once or twice. its really hard.
23:45:12 <newsham> (you seem to have more in depth haskell experience than most)
23:45:16 <dons> i had to call in SimonM.
23:45:26 <dons> since you're interacting with the rts so much
23:45:59 <newsham> what sort of interactions?
23:46:08 <dons> allocation, scheduling, gc.
23:46:26 <newsham> scheduling?  yielding?  select/polling?
23:46:38 <dons> the ghc runtiem system thread scheduler
23:47:01 <dons> you'll be stepping through the code, thinking your're in haskell code, then suddenly you're back in the rts scheduler for a few 100,000 intrs
23:47:07 <dons> makes it hard to keep track of things
23:47:09 <newsham> nod*
23:47:26 <newsham> wont your code tend to be in different memory regions than the runtime?
23:47:43 <dons> sure.
23:47:48 <dons> they've been linked together.
23:47:53 <dons> except for the macro calls. hmm
23:48:46 <newsham> sounds interesting.
23:49:18 <newsham> i tried looking at the C and intermediate code briefly once but it looked like gibberish to me (only just skimmed the stg paper)
23:49:27 <dons> you could decompile it back to C--, I reckon. you'd need to know what all the different macro sequences compiled to. and then from the C-- you might be able to get back into a pure Core subset, for some code. but it would be hard. i don't want to ponder how hard. :)
23:51:00 <dons> its an interesting problem, I must say
