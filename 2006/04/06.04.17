00:00:16 <maus> as 
00:00:39 <maus> is there appropriate library or binding?
00:02:21 <Lemmih> Know of a C library that does what you need?
00:02:47 <maus> yes
00:02:49 <maus> iconv
00:03:29 <maus> it's a command line tool accompanied by library
00:03:58 <maus> should i use FFI?
00:04:05 <Lemmih> You could write a binding to iconv, then.
00:04:54 <musasabi> morning
00:05:41 <musasabi> maus: binding fastpackedstring to iconv should be easy.
00:08:43 <maus> wouldn't FPS be an overkill here? Strings are short, they're file names.
00:09:27 <musasabi> hmm ok, then just use Foreign.C.String
00:25:18 <dons> newsham, i'm almost always here during .au daytime. i've been away on vacation the last 3 days though.
00:25:43 <dons> also, the PLogic stuff is part of programmatica? no? so the programmatica software and papers should document it
00:27:32 <newsham> dons: ahh, good for you (vacation).
00:27:44 <newsham> I had some questions this weekend about your haskel-plugins stuff.
00:29:06 <newsham> i ported the hws-wp stuff to use it, but had some problems along the way.
00:29:46 <dons> sethk, btw, isn't this a better version of getKey: getKey (CScommand _ _ bcode _ _ _) = bcode
00:29:59 <newsham> I tried using pdynload but it didnt work with the custom type.
00:30:03 <sethk> dons, probably.  Let me look.  :)
00:30:07 <newsham> when I changed it to use load_ that worked fine though
00:30:41 <newsham> also it seems I had to specify the path to the .hi's of the main program, and keep around .o and .hi for the moduels I want to laod
00:30:55 <newsham> is that right?  or is there a way to load just .o's?
00:30:57 <dons> you do indeed.
00:31:01 <sethk> dons, There used to be another constructor on CScommand that I removed.
00:31:08 <dons> nope. you need .hi files to hs-plugins can resolve deps
00:31:08 <sethk> dons, thanks, that's much better.
00:31:34 <newsham> what do I need to do to use pdynload and have full type checking?
00:31:41 <sethk> dons, I didn't think it was smart enough to understand that
00:31:44 <newsham> pApiVer <- pdynload path apiPaths [] "Int" "pluginApiVersion"   that worked
00:31:46 <newsham> but this didnt:
00:31:47 <sethk> dons, the type checker still amazes me.
00:32:04 <newsham>  pPlugin <- pdynload path apiPaths [] "HWSPlugin" "plugin"
00:32:07 <dons> :)
00:32:30 <dons> newsham, I think the type name needs to be fully qualified
00:32:39 <sethk> dons, there's going to be a second map, on keycode instead of barcode, so the number of lines you just saved is really doubled.
00:33:09 <newsham> dons: in this case its defined in the current module (calling pdynload).   the modle is called "PluginAPI"
00:33:17 <newsham> so just "PluginAPI.HWSPlugin" ?
00:33:24 <dons> if in doubt, compile hs-plugins with debug, and look at the type check stub that is generated. it will show the types it attempts to check.
00:33:48 <dons> yes, I think that is correct, PluginAPI.HWSPlugin.
00:33:56 <newsham> thanks.  I'll try that
00:34:43 <dons> remember that the type check occurs in a special stub module that is generated, imports the two modules, and trys to check their types as : x :: B
00:34:53 <dons> they're being imported, so you need qualfiied names for non-Prelude things. or local things
00:40:10 <newsham> cool, worked.
00:40:21 <dons> great.
00:40:42 <newsham> so basically whenver you have a program which loads other code that might use some of the routines from the original program, you have to keep all the .hi's from the original program around?
00:40:50 <newsham> that sounds less than ideal :\
00:42:49 <dons> you'd need them anyway to have things type check. the other option is to pack the code into a library archive, and then avoid the need for dependency chasing and .hi files
00:42:58 <dons> this is what yi does. make a libFoo.o files out of a bundle of .o files
00:43:14 <dons> and tthen hs-plugins doesn't have to chase .hi files to load libFoo.o
00:43:18 <newsham> not familiar with yi
00:43:58 <dons> so, the idea is to treat a single set of .o and .hi files as a library package, and load it in a single gulp. checkthe loadPackage interface
00:46:06 <newsham> not sure what you mean by "you'd need them anyway"
00:47:22 <newsham> gotta idle..  thanks for the help.
00:50:14 <dons> just think of objects as the pair of .o and .hi files. the .o contains the code, and the .hi contains the interface types. 
00:50:53 <juhp> er, I feel silly, but how to convert a CTime to an Int say?
00:50:59 <dons> we need to keep those  types somewhere at runtime, and .hi files are a good place, at least for now.
00:51:43 <juhp> fromIntegral used to work under ghc-6.2
00:53:06 <dons> ah, hmm. unsafeCoerce# ;) ?
00:53:15 <dons> ?hoogle CTime
00:53:16 <lambdabot> Foreign.C.Types.CTime :: data CTime
00:53:16 <lambdabot> Time.toUTCTime :: ClockTime -> CalendarTime
00:53:32 <dons> ?hoogle CTime -> a
00:53:32 <lambdabot> No matches, try a more general search
00:53:35 <juhp> dons: let me try that: thanks
00:54:34 <dons> oh, I see, CTime isn't in Integral anymore
00:54:49 <juhp> dons: right
00:55:43 <musasabi> there is from/toEnum but that might lose parts of it.
00:59:41 <musasabi> @karma+ dons -- inlinePerformIO
00:59:42 <lambdabot> dons's karma raised to 27.
00:59:54 <musasabi> dons: that makes fps much faster.
01:01:15 <dons> sure does
01:01:16 <dons> trick from Simon Marlow
01:01:28 <dons> ah, you notice it is faster?
01:01:32 <dons> any idea how much?
01:01:43 <dons> (I haven't measured it, just looked at the Core)
01:01:47 <musasabi> 800 req/sec -> 1300 req/sec
01:02:05 <dons> huh!
01:02:32 <musasabi> yes, I don't understand it either. Profiling didn't show fps as taking much of cpu/memory.
01:03:27 <musasabi> seems it is kicking all sorts of inlining that wasn't possible before.
01:03:54 <dons> right. that's really nice.
01:04:50 <dons> there's some more perf tricks i've got in mind  (some strictness passes, for one) . so maybe I should have a look at those now you're leaning on fps so much.
01:05:30 <dons> oh, and committ the no cbits code you  sent.
01:06:27 <musasabi> that would be nice. I have been using a version with that, and only recently pulled the new patches from the main repo.
01:09:15 <mahogny> don't we all hate when we invent something cool, and someone has not only beat us, they have implemented it too? :(
01:12:10 <juhp> hm, actually I just want CTime to Word
01:12:57 <basti_> i think CTime is Enum
01:13:01 <basti_> so enumToInt should work?
01:13:15 <musasabi> basti_: CTime > Int on some architectures.
01:13:42 <basti_> that sucks.
01:13:48 <musasabi> i.e. CTime might be 64 bits while Int might 32 bits.
01:14:17 <basti_> why is there no generic fromEnum?
01:15:58 <juhp> musasabi: yeah this is an x86_64
01:16:21 <juhp> fracToReal seems to pass typechecking
01:16:34 <juhp> err, realToFrac
01:16:59 <basti_> no why
01:18:20 <juhp> erm, well maybe it doesn't
01:29:34 <MarcWeber> Template Haskell splice illegal in a stage-1 compiler
01:30:12 <MarcWeber> What did I do wrong? I've tried make all, make stage2 and stage3 in fptools top directory. Same result.
01:44:09 <juhp> MarcWeber: dunno.  you're trying to build ghc?
01:53:36 <MarcWeber> juhp: I did it but I get this message when trying one of my programs..
01:57:41 <robokop> @hoogle a -> [a] -> [a]
01:57:42 <lambdabot> List.intersperse :: a -> [a] -> [a]
01:57:42 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
01:57:42 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
01:58:27 <robokop> @hoogle a -> Int -> [a] -> [a]
01:58:28 <lambdabot> No matches, try a more general search
01:58:48 <robokop> @hoogle a -> [a] -> Int -> [a]
01:58:49 <lambdabot> No matches, try a more general search
01:58:57 <robokop> @hoogle [a] -> Int -> [a]
01:58:58 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
01:58:58 <lambdabot> Prelude.take :: Int -> [a] -> [a]
01:58:58 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
02:30:33 <davidhouse> morning all :)
02:32:05 * xerox jumpsin the room too
02:32:29 <xerox> davidhouse: did you scream?
02:32:45 <davidhouse> scream?
02:32:50 <mahogny> xerox, btw you secretly make us buy more printers? just a feeling I've had
02:33:05 <xerox> davidhouse: "pinged"
02:33:23 <davidhouse> xerox, oh, yesterday i did.
02:33:39 <davidhouse> did you get any further with creating that traversing monad or did you find something more interesting to do?
02:34:48 <xerox> Environmental conditions caused the cease of the coding momentum I had... hrpf.
02:35:27 <davidhouse> i tried with newtype Loc a = Loc (State (Tree a, Cxt a) (Tree a)), but it doesn't appear Loc is there a monad.
02:35:42 <xerox> Ah, I got that far, let me fire up Emacs.
02:37:48 <xerox> newtype Travel t a = Travel { unT :: State t a }
02:37:48 <xerox>   deriving (Functor, Monad)
02:37:48 <xerox> type TravelTree a = Travel (Loc a) a
02:38:20 <xerox> I'm not sure about the last 'a'.
02:39:18 <davidhouse> where Loc is just a Cxt, Tree pair?
02:39:24 <xerox> Yep.
02:39:34 <davidhouse> and what would TravelTree be used for?
02:39:51 <davidhouse> is that our monad?
02:39:53 * xerox stares at the empty buffer...
02:40:07 <xerox> Theoretically?
02:41:05 <davidhouse> perhaps you'd need type TravelTree a = Travel (Loc a) (Tree a)
02:41:20 <davidhouse> as Cxt can be used to hide entire subtrees, not just leaves.
02:41:41 <davidhouse> so our State computations would have to result in a tree
02:43:05 <xerox> I think you're right.
02:46:49 <davidhouse> xerox, unless we made it newtype Travel t a = Travel { unT :: State t (Tree a) }
02:47:49 <davidhouse> otherwise i'm getting errors like: Expected type: TravelTree (); Inferred type: Travel (Loc ()) ()
02:48:45 <davidhouse> and we'll need to make an instance of MonadState somewhere as well
02:54:27 <xerox> It's strange for some reason, but this "works":
02:54:34 <xerox> newtype Travel a b = Travel { unT :: State (Loc a) b }
02:54:35 <xerox>   deriving (Monad,MonadState (Loc a))
02:54:35 <xerox> left :: Travel a (Tree a)
02:55:43 <shapr> sieni: Love the #haskell pix from Hki :-)
02:55:58 <xerox> Hki?
02:56:13 <musasabi> Helsinki
02:56:23 <xerox> I missed something :-)
02:56:48 <musasabi> shapr: Do you know if there has been further work on TCP in Haskell?
02:56:51 <shapr> http://www.hurmio.org/~ville/hs-hki/
02:57:14 <shapr> First time I've seen pix of musasabi and sieni
02:57:29 <xerox> Oooh.
02:57:37 <shapr> Lor has more hair since ICFP2003
02:57:54 <araujo> morning
02:57:59 <xerox> Nice going!
02:58:02 <shapr> musasabi: No, I don't know anything other than the TCP/IP stack in House.
02:58:07 <musasabi> ok
03:00:23 <davidhouse> xerox, how do you define left?
03:00:43 <xerox> davidhouse: in the usual way, I just returned the 'l' tree.
03:00:56 <davidhouse> return it? ah, i was modifying.
03:01:10 <xerox> Yep, modifying *too*
03:01:13 <davidhouse> right.
03:01:45 <davidhouse> so, something like modify $ \(Branch l r, c) -> (l, L c r) >> return l
03:01:59 <xerox> Right.
03:09:42 <lisppaste2> davidhouse pasted "finished traverser monad" at http://paste.lisp.org/display/19081
03:09:48 <davidhouse> xerox, ^^
03:11:15 <musasabi> davidhouse: now add an example of modifying the tree and then a wikipage about it :-)
03:11:29 <shapr> musasabi: Doing something interesting with TCTP?
03:11:33 <shapr> er, TCP?
03:11:42 <dons> musasabi, i've just pushed a cbits and cleanup patch. a couple of functions might be a bit faster too
03:11:43 <xerox> Hmmmm.
03:12:01 <xerox> davidhouse: right.
03:12:07 <dons> you should be able to just build Data.FastPackedString now with ghc X.hs, no extra build flags needed
03:12:40 <musasabi> shapr: just old ideas, nothing new and fancy.
03:12:58 <musasabi> shapr: I am thinking of doing a binary spec <-> parser+prettyprinter generator.
03:13:02 <musasabi> dons: testing.
03:15:29 <dons> hopefully this will make it easier to just include fps in a project without needing to hack a build system up.
03:16:10 <xerox> musasabi: how is the binary spec specified?
03:17:56 <musasabi> xerox: just something very simple (still playing with things and haven't fixed a format)
03:18:17 <dons> you might want to look at the 'bitdata' paper from last year's icfp?
03:18:33 <dons> which defines a bit packing 'data' decl
03:18:38 <dons> whose syntax you could steal
03:18:57 <dons> i think it was a Hallgren paper
03:19:08 <xerox> davidhouse: does modifyTree fit into the design nicely?
03:19:49 <davidhouse> xerox, it's in that paste.
03:20:21 <musasabi> dons: I was thinking something like RFCs, just simple ascii.
03:20:38 <araujo> univ time!
03:20:40 <xerox> davidhouse: I'm not sure top makes sense.
03:20:53 <davidhouse> no?
03:21:01 <xerox> davidhouse: well, it does the same thing as the usual zipper, in fact.  Dunno.
03:21:11 <davidhouse> it just puts Top as the Cxt.
03:21:13 <musasabi> I think I have seen the bit data paper (just after ICFP last year). For some reason it didn't get my interest, but don't remember the details.
03:21:15 <Oejet> What is the difference between PackedString and FastPackedString?
03:21:24 <musasabi> The erlang syntax is nice too.
03:21:30 <musasabi> Oejet: one is Fast.
03:25:06 <musasabi> dons: seems to work very nice :-)
03:27:20 <Oejet> Are there any description of the implementations, or should I read the source?
03:28:31 <musasabi> newtype PackedString = PS (UArray Int Char)
03:29:00 <musasabi> data FastString = PS {-# UNPACK #-} !(ForeignPtr Word8) !Int !Int
03:29:26 <musasabi> and from that follows the implementation differences.
03:32:38 <Oejet> musasabi: Thanks.
03:33:04 <lisppaste2> davidhouse annotated #19081 with "revTree using the zipper" at http://paste.lisp.org/display/19081#1
03:33:19 <davidhouse> musasabi, xerox, if you're still interested: ^^
03:35:47 <musasabi> cute, want to paste that into the wiki? That is a quite good example monad.
03:36:07 <xerox> I thought it was meant to be more convenient, but hmm.
03:36:20 <davidhouse> it's still recursive, which is a shame.
03:36:25 <davidhouse> i'll paste my non-zipper one
03:36:49 <lisppaste2> davidhouse annotated #19081 with "a non-zipper revTree" at http://paste.lisp.org/display/19081#2
03:36:55 <davidhouse> ^^ a bit simpler :)
03:37:14 <xerox> If it had some checks you could go for "accumulate on a stack left and right", or something.
03:37:37 * xerox tries
03:38:59 <musasabi> davidhouse: you can add an in-order monadic zipper traversal combinator and then define reverse with that.
03:40:59 <davidhouse> musasabi: care to run that past me again? :) a traversal combinator? you can just >> two traversal computations to join one onto the end of the other.
03:44:18 <musasabi> traverse leaf comb = do t <- getTree; case t of Leaf x -> leaf x; Branch _ _ -> ; do left; x <- traverse leaf comb; up; right; y <- traverse leaf comb; comb x y;
03:45:00 <musasabi> revTree = traverse (return . Leaf) (\x y -> return (Branch y x))
03:50:07 <dons> musasabi, so it just slots in to HAppS (is that what you're using it in) without modification?
03:52:54 <hoan> folks, i'm trying to install HAppS, it looks very nice
03:53:00 <jip> good morning haskell!
03:53:32 <Oejet> Hi, jip.
03:54:59 <jyp> musasabi: Compiling E.SSimplify      ( ./E/SSimplify.hs, ./E/SSimplify.o ) / ./E/SSimplify.hs:437:49: Not in scope: `envInScope_u'
03:55:11 <jyp> does it tell something to you?
04:04:13 <musasabi> jyp: yes, you need to update DrIFT.
04:05:19 <jyp> musasabi: aye, thanks.
04:06:05 <hoan> folks, i need help installing cabal on mac os x
04:06:11 <musasabi> dons: yes, although HAppS can do it the cabal way too. There are other internal things that need it.
04:06:53 <hoan> i'm stuck on cabal-get-bootstrap, it says it can't find `cabal-install'
04:07:07 <musasabi> hoan: you can use HAppS without Cabal if required. But for getting cabal to compile the trick is to compile Setup.hs rather trying to use runghc.
04:07:33 <hoan> ok, yes i've compiled Setup.hs
04:07:49 <hoan> but somehow, the program `cabal-install' is nowhere to be found
04:07:55 <hoan> i've also run the bloddy makefile
04:08:16 <hoan> musasabi: are you the author of HAppS?
04:09:23 <musasabi> hoan: I've done most of the new code in HAppS, but Alex Jacobson is the primary author.
04:09:34 <hoan> well, i say it looks really nice
04:09:48 <hoan> i don't know much haskell, but now ...
04:09:50 <musasabi> thanks :-)
04:09:53 <hoan> who knows? :]
04:10:01 <hoan> you got the DB stuff right
04:13:55 <hoan> damn, wrong version of cabal
04:13:57 <hoan> arrrrr
04:14:29 <hoan> i'm trying cabal-get-bootstrap...
04:16:23 <hoan> musasabi: how do you think HAppS compares to WaSH and HSP?
04:18:23 <musasabi> hoan: WASH and HSP are more focused on doing everything in Haskell, while HAppS tries to keep presentation separate from the application logic.
04:18:56 <hoan> okay.. i'll investigate more..
04:19:45 <hoan> hmm
04:20:59 <musasabi> From performance pov I think HAppS might be the fastest at the moment, but it might be that HSP and WASH are simply not tuned right when I tested things.
04:21:32 <hoan> okay, i'm not really worried about performance yet, i'm just testing things out
04:21:49 <hoan> however that simon dude is really impressive...
04:21:58 <musasabi> WASH is most mature and has many years of development.
04:22:08 <musasabi> Both simons are :-)
04:22:38 * wli would be interested in something that can deal with https (no clue) and cookies (slight clue).
04:22:45 <hoan> yeah, programming in haskell is like playing a game of simon says
04:23:36 <jip> hey, did you guys see the update to my devlog?
04:24:33 <musasabi> wli: we use a ssl proxy in front of happs for certain things. OpenSSL has a problematic license from GPL po
04:24:38 <musasabi> GPL pov.
04:24:44 <jyp> jip: No, are you subscribed to haskell-planet ?
04:24:50 <musasabi> and Gnutls is problematic for short lived connections.
04:24:52 <jip> jyp: no, what's that?
04:25:01 <jyp> http://planet.haskell.org/
04:25:30 <wli> musasabi: ouch
04:26:20 <musasabi> wli: yes, one solution would be to implement the TLS spec in Haskell, but it would need someone with free time.
04:26:28 <jip> jyp: not sure if my devlog is at the same level as these things
04:28:11 <jyp> Just asking... I thought your question could be related to that.
04:28:20 <jyp> Still, you got a url?
04:28:31 <jip> jyp: http://www.mutantlemon.com/omegagb/devlog/
04:28:35 <musasabi> wli: It should be quite easy, if you are interested.
04:29:48 <jyp> jip: Seems it could be a nice addition to planet haskell. Maybe contact the editor.
04:30:09 <jyp> but I see you don't have a feed ?
04:30:38 <jip> jyp: no, it's not even a real blog, just a single static html page for now
04:30:41 * wli 's dream is of a grand survey thing like http://pollingpoint.com/ that keeps track of users and so builds up huge per-user vectors of responses to do data mining with.
04:32:10 <hoan> folks, i've installed cabal-1.1.3 and i've got the latest cabal-get-bootstrap
04:32:36 <hoan> when i run the installer it says cannot find `cabal-install'
04:32:42 <hoan> ... eek
04:32:46 <jyp> jip: How long have you been programming in haskell? -- if I may ask
04:33:24 <mahogny> omg. where did you guys get your nicks from? :(
04:34:32 <hoan> its like simon and simon, but different :]
04:34:43 <mahogny> lol
04:34:47 <jip> jyp: i fired up hugs for the first time about a year ago, but back then i only did a few excersises. then i didn't do any programming at all(in any language) for about 10 months. then i started doing playing around with haskell a bit again
04:35:22 <jyp> jip: I find interesting your writing 'When they say, "Haskell is the best imperative language", it's not just a joke!'
04:35:55 <jip> jyp: they do say that, right?
04:36:03 <jyp> They do.
04:36:08 <jip> :)
04:36:25 <jyp> I just find interesting your picking up after a seemingly short time playing with haskell.
04:37:26 <jyp> See, say I'd like to introduce haskell programming at my workplace.
04:37:57 <jyp> I get an incredible resistance, mostly in the form of "too difficult to learn"
04:38:13 <mahogny> that's common
04:38:17 <mahogny> what are they using now?
04:38:17 <jyp> More and more I think this is just an epidermic reaction.
04:38:34 <jyp> Programming language = religion for many people
04:38:56 <jip> i felt this way also for a long time before finally trying haskell. and back then i was very open to learning new programming languages.
04:38:58 <jyp> mahogny: Ada, perl, korn shell.
04:39:11 <basti_> you should show them the fibonacchi number term.
04:39:17 <mahogny> immonologic if you ask me; haskell can be awful, and then there are these guys that contiously want to turn it into the next Brainfuck; "Let's do it with a monad! no idea why, but let's use one!"
04:39:20 <jip> but once i started coding my first haskell program, i immediately loved the language
04:39:23 <jyp> mahogny: Before I was arguing to Java/C/C++/ etc. people
04:40:20 <mahogny> jyp, I think that you can't turn them over with simple examples. you have to show cost benefits and cases when it does huge savings, like for a compiler or for implementing a virtual machine
04:40:41 <mahogny> just showing them some code and saying "look how nice it looks" is a bad idea in general
04:41:00 <jip> jyp: i'm planning on soon writing a sort of article to introduce people to haskell, by going through the process of writing what was my first haskell program - a raytracer
04:41:01 <jyp> mahogny: I shall suggest haskell as a formal specification language. we'll see.
04:41:08 <basti_> yes because noone understands code in a language he isn't familiar enough with
04:41:20 <mahogny> jyp, ehr. why would one want haskell for that?
04:41:48 <mahogny> ordinary math sounds better for that
04:41:48 <jyp> Because its 1. Formal 2. executable
04:41:49 <mahogny> bbl
04:42:32 * jyp waves
04:47:18 <Ulfalizer> if i have a type class like  class Foo a where (<) :: a -> a -> Bool  and try to evaluate an expression involving <, i get the error 'Ambiguous variable occurrence "<"  *** Could refer to: Main.< Hugs.Prelude.<'. why is that? i thought a class declaration just specified what operations should be defined over a type for it to be part of the class, and as such did not define any functions in itself..
04:48:21 <musasabi> Ulfalizer: the problem is that Prelude defines (<) too.
04:48:56 <musasabi> Ulfalizer: so hugs is complaining that it does not know whether you are referring to the Prelude definition or the one in your main program. 
04:49:07 <Ulfalizer> musasabi: but my class declaration isn't really defining (<) though. it's just saying that types that are part of the class need to have it defined over them.
04:49:16 <hoan> dammit, i got the wrong Cabal again...
04:49:18 <hoan> poo poo
04:50:10 <Ulfalizer> i can't see any definition of (<) in my main program. just a statement that it needs to be defined over particular types in order for them to be part of the class.
04:50:47 <musasabi> A class declaration does define the methods.
04:51:38 <musasabi> Think about "class Foo a where foo :: IO a" and "class Bar a where foo :: Int -> Int" what is the type of a occurence of foo?
04:52:10 <Ulfalizer> hrm, i don't understand that first one since i haven't gotten to monads yet
04:52:20 <musasabi> hoan: you might want to just use other things, if you don't need cabal-get.
04:52:43 <musasabi> lets make it "class Foo where foo :: [a]"
04:53:01 <hoan> yes but i'd like a good start for Haskell
04:53:03 <kpreid_> Ulfalizer: maybe you actually want "class (Num a) => Foo a"?
04:53:08 <hoan> its an ominuos time
04:53:41 <kpreid_> er, Ord, not Num
04:54:03 <Ulfalizer> nah, i'm just trying to understand the concept of a class "defining" a function as opposed to just declaring that it should be defined over a type for it to be part of the class
04:54:32 <davidhouse> if you need (<) to be defined over types of your class, then you want class Ord a => Foo a.
04:55:03 <davidhouse> if you say class Foo where foo :: [a], then you're saying whenever you instantiate Foo, you need to define a function foo that has type [a].
04:55:38 <davidhouse> (note that this function can be different for different types - polymorphism - but has to have the same type everywhere)
04:55:41 <musasabi> *and* you are saying that "foo" has a type of foo :: Foo a => [a]
04:56:08 <Ulfalizer> with a class declaration it doesn't seem to me that you've actually defined any functions that could clash with other functions though. the definitions come in the instantiations.
04:56:16 <davidhouse> yes.
04:56:23 <davidhouse> but presumably you instantiate Foo somewhere
04:56:30 <davidhouse> and there you define a function (<)
04:56:37 <davidhouse> which clashes with the Prelude one
04:56:47 <Ulfalizer> but if i don't, why does hugs still complain about a clash?
04:57:02 <davidhouse> if you don't instantiate it? what would be the point?
04:57:04 <musasabi> Actually there is no need to instantinate it.
04:57:21 <davidhouse> it probably happens because hugs sees that you're going to instantiate and define foo, so complains straight off.
04:57:47 <Ulfalizer> davidhouse: i could write it for use at a later time. and even if there is no point, i'm still interested in why it acts the way it does.
04:57:53 <musasabi> Typeclasses can be helpful without any instances.
04:58:19 <davidhouse> Ulfalizer: "for use at a later time" implies you'll eventually instantiate it
04:58:27 <musasabi> Ulfalizer: the class declaration declares the methods too. Instance declarations just add method bodies for certain types.
04:58:52 <Ulfalizer> yeah, but i might feel i shouldn't have to pay the consequences until i do, in case i would change my mind and remove it :)
04:58:56 <davidhouse> i suppose you can think of class declarations as a bit like C header files.
04:59:06 <davidhouse> you're saying "i'm about to define this function, deal with it".
04:59:31 <musasabi> it is the actual definition.
04:59:59 <davidhouse> no, you're just declaring the type.
05:00:07 <davidhouse> the definition, i.e. what the function does, comes later.
05:00:11 <mahogny> hmm. I think classes in haskell are quite a different beast from classes in java. at most one could see it as an interface declaration
05:00:40 <musasabi> davidhouse: you are defining the function and the type it had. Later you can add function bodies for given instances.
05:00:48 <musasabi> s/function/method/
05:01:06 <davidhouse> it depends on your definition of "define", i suppose.
05:01:09 <musasabi> interface declarations are a very good analogy.
05:05:15 <Ulfalizer> what if you never instantiate the class over Int, say. it seems kinda awkward that you still get "ambiguous variable occurrence" for something like  5 < 8  if all you've done is made some totally unrelated class and instances that happens to include <.
05:06:19 <Ulfalizer> i can't see any technical reasons at the compiler level that it shouldn't be able to work it out
05:07:40 <musasabi> Ulfalizer: so given "class Foo a where foo :: a; class Bar a where foo :: a; instance Foo Int where foo = 1; instance Bar Int foo = 2" what value should (foo :: Int) have ?
05:09:47 <Ulfalizer> musasabi: that's a different story, because there you actually have clashing instances. it seems kinda silly for the compiler to assume you're gonna instantiate the class for every type.
05:10:29 <hoan> bummer, cabal-install fails with "Could not find module `Distribution.Compat.FilePath':
05:10:29 <hoan>   it is hidden (in package Cabal-1.1.4)
05:10:29 <hoan>   (imported from CabalInstall.hs)
05:10:29 <hoan> "
05:10:50 <musasabi> Ulfalizer: the second problem would be for the types to be of different shapes.
05:11:05 <musasabi> Ulfalizer: and if they are separate why not just define instances in the original class?
05:11:31 <mahogny> Ulfalizer, ok, going back to your original problem, since you specify a -> a -> Bool you really need to specify for all types because that is exactly what you are saying
05:11:43 <Ulfalizer> what would be the problem for types of different shapes?
05:12:02 <mahogny> shapes?
05:12:02 <musasabi> hoan: I think unregistering the previous Cabal might help, but I don't know much about cabal-get.
05:12:13 <musasabi> Ulfalizer: inference.
05:12:17 <hoan> okay, i'll try that...
05:13:02 <musasabi> Ulfalizer: given two different shaped definitions. (e.g. the foo :: [a] and foo :: Int -> Int) what type should be inferred for "bar = foo" ?
05:13:22 <Ulfalizer> mahogny: i read    class Foo a where Ugh :: a -> a   as "for a type a to be a member of the class Foo, it needs to have Ugh -> a -> a implemented over it". the a doesn't mean "any type", it just means "any type in the class Foo"
05:13:46 <xerox> Ugh can't start with a capital U.
05:14:09 <hoan> oh i see, i haven't unregistered the old versions... how can you unregister cabals without editing package.conf?
05:14:37 <hoan> (im useing ghc)
05:14:59 <Ulfalizer> musasabi: hrm, could you elaborate a bit? i only learned about type classes half an hour ago and am still struggling with keeping all the concepts in my head =)
05:14:59 <mahogny> Ulfalizer, ah wait, it seems it's still morning. ignore me
05:15:37 <xerox> A type class is a set of types.  It constrains a type variable to be one of the members of the set.
05:16:04 <lumi> Type class constraints don't have that single-function resolution, the constraint can only be another typeclass, and that's not the syntax for that.
05:16:12 <hoan> or is package.conf made by cabal?
05:16:20 <xerox> Membership is defined by instantiating, i.e. implementing the typeclassed function under an instance clause.
05:17:16 <Ulfalizer> yeah, i've got all that, it's just that it still takes some energy to apply it :)
05:20:03 <Ulfalizer> i've gtg, feel free to leave some reply while i'm gone
05:22:33 <musasabi> (phone, and have to run ->)
05:22:53 <hoan> byee
05:35:31 <vincenz> re
05:37:11 <jip> sup
05:37:36 <vincenz> not much
05:37:40 <vincenz> team haskell is growing
05:39:04 <basti_> team haskell?
05:39:11 <jip> vincenz: where can i find more information about the task?
05:39:38 <basti_> ICFP?
05:39:40 <mahogny> isn't there a long time to go until the next icfp?
05:41:06 <vincenz> yah
05:41:52 <vincenz> we like to be prepared :)
05:42:33 <hoan> noooo
05:42:37 <hoan> stupid cabal
05:43:55 <jip> won't there probably be a lot of teams that use haskell though?
05:46:45 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
05:58:08 <roconnor> > take 5 $ iterate (\x -> do {y<-group x; shows (length y) [(head y)]}) "1"
05:58:10 <lambdabot> ["1","11","21","1211","111221"]
05:58:23 <roconnor> @pf iterate (\x -> do {y<-group x; shows (length y) [(head y)]}) "1"
05:58:24 <lambdabot> (line 1, column 19):
05:58:24 <lambdabot> unexpected "{"
05:58:24 <lambdabot> expecting variable, "(", operator or ")"
05:58:46 <roconnor> > take 5 $ iterate (\x -> group x >>= (\y -> shows (length y) [(head y)])) "1"
05:58:48 <lambdabot> ["1","11","21","1211","111221"]
05:58:57 <roconnor> @pf iterate (\x -> group x >>= (\y -> shows (length y) [(head y)])) "1"
05:58:58 <lambdabot> iterate ((liftM2 shows length (return . head) =<<) . group) "1"
06:01:26 <roconnor> > take 5 $  iterate ((liftM2 shows length (return . head) =<<) . group) "1"
06:01:27 <lambdabot> ["1","11","21","1211","111221"]
06:01:39 <roconnor> hmmm
06:01:43 <roconnor> Prelude List Monad> take 5 $  iterate ((liftM2 shows length (return . head) =<<) . group) "1"
06:01:44 <roconnor> <interactive>:1:20:
06:01:44 <roconnor>     No instance for (Monad ((->) [Char]))
06:01:56 <roconnor> why doesn't it work for me in ghci?
06:06:45 <roconnor> @type (liftM2 shows length)
06:06:47 <lambdabot> forall a. ([a] -> String) -> [a] -> String
06:06:56 <Oejet> jip: Jump to #haskell-blah, and I'll paste a summary.
06:08:24 <kpreid_> roconnor: :m + Control.Monad.Reader
06:09:15 <roconnor> is that where (->) is defined?
06:09:54 <roconnor> thanks!
06:10:05 <vincenz> dumdu
06:11:08 <kpreid_> roconnor: no, it's where it is made an instance of Monad
06:26:25 <roconnor> yes, of course. ;-)
06:33:59 <vincenz> Oejet: ping
06:59:06 <kolmodin> I'm supposed to do a project at univ, it has to be language related, and two persons should be able to do it in about two weeks work per person. any ideas?
07:19:30 <xerox> kolmodin: an interpreter?
07:23:12 <dons> hmm. two weeks per person? an interpreter  + tycheck + frontend?
07:23:53 <dons> we usually set type inference as a 1 person, 2 week assignment, for a core fp lang
07:24:15 <dons> and about the same for an interpreter, but a little easier
07:24:42 <vincenz> dons: hi
07:25:26 <vincenz> dons: page has been cleaned ;)
07:26:59 <davidhouse> @seen vincenz
07:27:00 <lambdabot> vincenz is in #haskell-overflow, #haskell-blah and #haskell. I last heard vincenz speak 1 minute and 33 seconds ago.
07:27:04 <davidhouse> wait, he just spoke :)
07:27:26 <davidhouse> vincenz: you want a username and pass?
07:27:50 <kolmodin> yeah, perhaps if we would use type inference or something more interesting
07:28:06 <vincenz> davidhouse: username = davidhouse
07:28:11 <vincenz> davidhouse: and yeah. md5 crypted pw
07:28:12 <vincenz> for wiki
07:28:31 <kolmodin> because I've already (perhaps my partner too) written a couple of simple compilers and interperters
07:33:01 <kolmodin> my partner would like to write a haskell debugger using Stratego (a program transformation system) and hs-plugins, but I'm afraid that would be a little hard in two weeks
07:33:01 <kolmodin> I've got other courses to take care of as well :)
07:36:13 <xerox> kolmodin: type inference sounds cool.
07:37:41 <kolmodin> right, so which language am I interpreting/(compiling and to what) ? :)
07:38:47 <xerox> Haskell? (-:
07:39:20 <kolmodin> :)
07:39:44 <xerox> Maybe just some typed lambda calculus posing the accent of some kind of interesting type system.
07:39:52 <xerox> s/of/on/1
07:40:18 <kolmodin> right.
07:43:50 <vincenz> davidhouse: join #oasis
07:44:01 <davidhouse> vincenz: not right now, have to dash.
07:44:04 <vincenz> ok
07:44:10 <vincenz> just wanted to show you darcs-watching
07:44:31 <xerox> What's darcs-watching?
07:44:43 <vincenz> xerox: it shows when a darcs changes
07:44:54 <xerox> 'it' being?
07:44:59 <vincenz> my instance of lambdabot
07:45:05 <xerox> Nice.
07:45:17 <vincenz> it's a standard plugin
07:45:19 <vincenz> just have to enable it
07:45:27 <xerox> Yep, I remember now.
07:45:28 <vincenz> and it has to run on the machine with the darcs
07:45:37 <vincenz> xerox: check out our new flashy page
07:55:33 <jip> any knowledable gtk2hs dudes here?
07:56:33 <Saulzar> I imagine a few, ask...
07:56:40 <vincenz> jip: sure
07:59:03 <jip> set window [ windowType := WindowPopup ]
07:59:08 <jip> doesn't seem to be working for me
07:59:24 <vincenz> hmm
07:59:30 <vincenz> doing this pre or post show
07:59:41 <jip> i mean it won't compile
07:59:48 <vincenz> oh
07:59:50 <vincenz> what does it say?
08:00:09 <jip> Expected type: ()      Inferred type: WindowType
08:00:31 <vincenz> se
08:00:32 <vincenz> sec
08:00:33 <jip> set window [ windowType := () ] -- this works though!
08:00:52 <jip> my best guess is that this is a bug in gtk2hs :\
08:01:13 <vincenz> yeah
08:01:30 <vincenz> must be
08:02:48 <jip> this is not good, i need popup windows
08:03:02 * jip pokes Lemmih :)
08:27:58 <davidhouse> any haskell apps going for the summer of code?
08:28:01 <davidhouse> http://code.google.com/summerofcode.html
08:29:49 <vincenz> davidhouse: gonna move yourself to definite?
08:31:00 <davidhouse> hmm
08:31:06 <davidhouse> will have to check first
08:31:18 <davidhouse> what time do we start on the friday? i've got school that day
08:31:29 <vincenz> typically friday evening
08:32:10 <davidhouse> okay, i should be all right.
08:35:55 <vincenz> > foldr (\x y -> if x > 5 then x else x+y) 0 ([1..10] ++ [1..10])
08:35:56 <lambdabot> 21
08:48:05 <jip> @seen dcoutts_ 
08:48:05 <lambdabot> dcoutts_ is in #gentoo-haskell and #haskell. I don't know when dcoutts_ last spoke.
08:50:03 <davidhouse> what's the name for a tree with an arbitrary number of branches?
08:50:20 <davidhouse> *-ary tree or something? polyary tree?
08:50:37 <davidhouse> *where each node has an arbitrary number of branches, i should have said.
08:51:01 <psnl> davidhouse: Gtree?
08:51:22 <vincenz> nope
08:51:31 <vincenz> there's a name
08:51:32 <vincenz> just forgot
08:51:38 <davidhouse> psnl: neither google nor wikipedia know about a 'gtree'.
08:51:50 <vincenz> crap...what is that name again
08:51:57 <psnl> ok, Paul made it up when he lectured
08:52:34 <vincenz> davidhouse: B-tree
08:52:59 <vincenz> or possible trie
08:54:42 <davidhouse> "The idea behind B-trees is that internal nodes can have a variable number of child nodes within some pre-defined range"
08:54:51 <davidhouse> "In computer science, a trie, or prefix tree, is an ordered tree data structure that is used to store an associative array where the keys are strings."
08:54:52 <vincenz> o-inf
08:55:27 <vincenz> yeah but a trie uses a polyary tree
08:55:31 <vincenz> namely the size of your alfabet
08:57:00 <MarcWeber> How to compile ghc to not get this message when using ghc ?
08:57:01 <MarcWeber>  GHC stage restriction: `view'
08:57:01 <MarcWeber> ||       is used in a top-level splice, and must be imported, not defined locally
08:58:34 <musasabi> MarcWeber: it appears that there is currently some issue in the GHC compile cycle, other people have had the same problem.
08:59:01 <musasabi> MarcWeber: you might want to wait a few days for people to get back to work and solve that one.
09:10:30 <morans> funny how people seem to assume haskell is always interpreted.
09:10:43 <morans> i've had two or three people in the past talk about installing/uninstalling a haskell interpreter
09:10:55 <jip> @seen Lemmih
09:10:55 <lambdabot> Lemmih is in #haskell-blah and #haskell. I last heard Lemmih speak 9 hours, 6 minutes and 46 seconds ago.
09:14:37 <MarcWeber> musasabi: Thanks a lot.
09:15:23 <MarcWeber> musasabi: Where to get this information that there are errors? from ghc mailinglist? irc?
09:18:24 <musasabi> MarcWeber: I think someone else complained about it too.
09:20:16 <jip> what happens if "error" is returned during modifyIORef? is it possible to for the IORef to be only half-updated?
09:22:22 <Saulzar> It would not change, if you catch the error...
09:22:44 <jip> modifyIORef state (\(x, y) -> (x+1, if y > 10 then error "foo" else y+1))
09:23:15 <jip> if the previous value of the state was (1, 11), then what will the value of the state be after this call?
09:23:55 <Saulzar> I'd bet on (1, 11)
09:24:01 <jip> is it at all possible that it will be (2, XXX)?
09:24:28 <Saulzar> Hmm, actually... 
09:24:40 <Saulzar> Maybe it would be (2, undefined)
09:24:54 <Saulzar> Then only when you demand y it would spit the error at you
09:25:26 <jip> hm...
09:25:30 <Saulzar> Try it
09:26:11 <jip> i'm not sure that IORef can do lazy evaluation quite like that
09:26:33 <jip> actually you are probably right!
09:26:35 <davidhouse> @type error
09:26:35 <MarcWeber> musasabi: I think that was me some hours ago ;)
09:26:36 <lambdabot> forall a. [Char] -> a
09:26:58 <Saulzar> jip, But you could force it 
09:26:59 <davidhouse> error gives you _|_, so it will be (2, _|_) or (2, undefined) if you prefer.
09:27:36 <Cale> assignment of a value to an IORef does no evaluation of that value
09:28:01 <jip> man this lazy evaluation stuff can be very confusing in cases like this :\
09:28:41 <Cale> well, in this case, it means that you're not going to get an IORef with some half-updated state
09:30:00 <Cale> try the following in ghci:
09:30:06 <Cale> r <- newIORef 0
09:30:07 <jip> how can i force any errors that are in there, to happen now, so that i can catch them with "catchJust errorCalls" ?
09:30:17 <Cale> modifyIORef (\x -> error "Hello")
09:30:19 <Cale> er
09:30:22 <Cale> modifyIORef r (\x -> error "Hello")
09:30:29 <Cale> a <- readIORef r
09:30:31 <Cale> a
09:30:51 <Cale> You can use evaluate or seq to force evaluation
09:31:07 <Cale> or more forceful methods like deepSeq/rnf
09:33:54 <jip> hm...
09:34:18 <xerox> I never saw an example of rnt tho :-(
09:34:26 <jip> proper exception handling is hard enough without having to deal with lazy state :P
09:34:38 <davidhouse> @pl \f x y -> f y x
09:34:38 <lambdabot> flip
09:37:41 <wchogg> I'm trying to figure out how to not waste memory:  I want to do a simple monte carlo integration that would work for an arbitrary number of iterations without running out of memory.  I'll paste my attempt so far.
09:37:46 <lisppaste2> wchogg pasted "How can I reduce the memory used?" at http://paste.lisp.org/display/19086
09:43:24 <sjanssen> wchogg: try using a left fold instead of a right fold
09:45:59 <Cale> foldl1' in particular, though it doesn't quite solve the problem here
09:46:30 <Igloo> foldM is probably what you want, with a slightly different function
09:46:46 <Cale> yeah
09:50:47 <Vsajanas> Download my games -------->    http://www.thricesoft.com/download.php?list.5
09:51:19 <Cale> thing <- foldM (\x y -> do v <- generate; let u = v + y in seq u (return u)) 0 [0..n-1]
09:52:04 <Igloo> let u = v + y in seq u (return u) == return $! (v + y)
09:52:23 <Cale> basically, sure
09:55:20 <shapr> hiya SyntaxNinja 
09:55:35 <araujo> hiya!
09:55:41 * araujo back from univ.
09:56:26 --- mode: ChanServ set +o shapr
09:56:48 --- mode: shapr set +b vsajanas!*@*
09:56:55 --- mode: shapr set -o shapr
09:57:14 <shapr> Spammers suck.
09:59:09 <wchogg> Sorry, I was taking care of something else.  Thanks for the suggestions, I'll try them.
09:59:40 <Cale> test n = do
09:59:41 <Cale>          xs <- replicateM n (unsafeInterleaveIO generate)
09:59:41 <Cale>          let thing = foldl' (+) 0 xs
09:59:41 <Cale>  
09:59:41 <Cale> ...
09:59:44 <Cale> that also works
10:00:20 <jip> Cale: btw, did you see the latest post to the omegagb devlog?
10:00:34 <Cale> jip: nope
10:00:44 <Cale> where is it?
10:00:52 <jip> Cale: http://www.mutantlemon.com/omegagb/devlog/
10:01:56 <mauke> hello, Cale! I have a question.
10:01:58 <mauke> http://rafb.net/paste/results/41xTmN68.html
10:03:53 <vincenz> Cale: I need a md5 password
10:04:02 <SyntaxNinja> heya shapr
10:04:07 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Technical
10:04:09 <sjanssen> > foldr (\m xs -> case m of Nothing -> xs; Just x -> x:xs) [] [Just 1, Nothing, Just 2]
10:04:10 <lambdabot> [1,2]
10:04:31 <Cale> jip: looks good
10:04:39 <Cale> mauke: what's the question?
10:04:59 <Cale> vincenz: what?
10:05:06 <sjanssen> mauke: another name for that is catMaybes
10:05:09 <mauke> Cale: how do I rewrite foo using foldr?
10:05:19 <Cale> mauke: oh, sjanssen already answered you :)
10:05:21 <vincenz> Cale: eventually site will become member-read only, so I need a password for on the wiki
10:05:30 <mauke> sjanssen: that's wrong
10:05:35 <vincenz> that link explains how to make one
10:05:36 <mauke> the correct answer is [1]
10:06:09 <Cale> hm?
10:06:13 <vincenz> mauke: no it's not
10:06:15 <sjanssen> oh, you want everything until a Nothing?
10:06:19 <mauke> vincenz: yes, it is
10:06:25 <vincenz> takeWhile (not . isNothing)
10:06:27 <vincenz> and then that foldr
10:06:35 <mauke> vincenz: I wrote the spec, I know what's right
10:06:45 <sjanssen> > foldr (\m xs -> case m of Nothing -> []; Just x -> x:xs) [] [Just 1, Nothing, Just 2]
10:06:46 <lambdabot> [1]
10:06:51 <mauke> no, Nothing is a command that drops the next item
10:06:58 <vincenz>  > foldr (\m xs -> case m of Nothing -> xs; Just x -> x:xs) [] $ takeWhile (not . isNothing) $  [Just 1, Nothing, Just 2]
10:07:04 <vincenz> > foldr (\m xs -> case m of Nothing -> xs; Just x -> x:xs) [] $ takeWhile (not . isNothing) $  [Just 1, Nothing, Just 2]
10:07:05 <lambdabot> [1]
10:07:10 <mauke> [Nothing, Nothing, Just 2] -> [2]
10:07:31 <vincenz> erm
10:07:33 <vincenz> that makes no sense
10:07:47 <vincenz> [Nothing]
10:07:49 <Cale> > foldr (\m xs -> case m of Nothing -> xs; Just x -> x:xs) [] $ takeWhile (not . isNothing) $  [Nothing, Nothing, Just 2]
10:07:50 <lambdabot> []
10:09:06 <mauke> huh?
10:09:24 <vincenz> mauke: you said Nothing drops the next item
10:09:28 <vincenz> mauke: so what about [Nothing]
10:10:09 <mauke> oh, that's a special case (see line 12). it pretends there's a next item and returns []
10:10:34 <vincenz> > foldr (\m xs -> case m of Nothing -> drop 1 xs; Just x -> x:xs) [] [Just 1, Nothing, Just 2]
10:10:35 <lambdabot> [1]
10:10:40 <vincenz> > foldr (\m xs -> case m of Nothing -> drop 1 xs; Just x -> x:xs) [] [Nothign, Nothing, Just 2]
10:10:41 <lambdabot>  Not in scope: data constructor `Nothign'
10:10:43 <vincenz> > foldr (\m xs -> case m of Nothing -> drop 1 xs; Just x -> x:xs) [] [Nothing, Nothing, Just 2]
10:10:45 <lambdabot> []
10:10:47 <vincenz> there
10:10:48 <vincenz> hmm
10:11:01 <wchogg> Cale:  Sorry, but you're first example of using foldM doesn't seem to work right.
10:11:04 <vincenz> > foldl (\m xs -> case m of Nothing -> drop 1 xs; Just x -> x:xs) [] [Nothing, Nothing, Just 2]
10:11:06 <lambdabot> Couldn't match `Maybe a' against `[a1]'
10:11:08 <SyntaxNinja> man. evolution is locking up on me
10:11:14 <vincenz> SyntaxNinja: exchange?
10:11:17 <wchogg> If I do  thing <- foldM (\x y -> do v<-generate; let u = v+y in seq u (return u)) 0 [0..n-1] then it just returns n.
10:11:46 <Cale> wchogg: hmm
10:11:59 <Cale> wchogg: yeah, I noticed that the value seemed off
10:12:14 <Cale> It's supposed to be around pi, right?
10:12:24 <SyntaxNinja> vincenz: no, just rendering an email. It's some piece of spam. I think it's huge.
10:12:30 <wchogg> Yup.  It's just a stupid monte carlo example.
10:13:03 <wchogg> It did return close to pi the first time I wrote it, so I know it's not completely wrong.
10:13:11 <vincenz> SyntaxNinja: no idea then, sorry
10:16:19 <xerox> SyntaxNinja!
10:18:11 <vincenz> Cale: mkpasswd --hash=md5 yourwikipassword
10:18:15 <vincenz> Cale: username will be 'cale'
10:22:53 <SyntaxNinja> hi xerox
10:23:02 <xerox> Hello mate.
10:24:31 <davidhouse> xerox, http://haskell.org/haskellwiki/ZipperMonad
10:24:39 <davidhouse> musasabi: http://haskell.org/haskellwiki/ZipperMonad
10:24:57 <vincenz> davidhouse: neat
10:24:57 <davidhouse> right. got to go.
10:25:01 <xerox> davidhouse: cool!  I was trying to write a parametric one.  But I went away
10:25:08 <vincenz> davidhouse: but yeah... statemonad
10:25:09 <xerox> I'll be finishing, great work mate.
10:25:35 <davidhouse> especially check out the Generalisation section under Tree Reverser.
10:26:26 <davidhouse> bye all.
10:27:01 <vincenz> hmm
10:27:07 <vincenz> that generalisation reminds me of a paper I read
10:27:19 <SyntaxNinja> vincenz: yeah, it was a spam message that crashed evolution. wow.
10:27:20 <musasabi> It is essentially a fold.
10:27:28 <vincenz> SyntaxNinja: damn
10:27:33 <vincenz> SyntaxNinja: well use thunderbird ;)
10:27:33 <SyntaxNinja> not particularly large
10:28:14 <SyntaxNinja> I managed to delete it.
10:29:00 <Cale> wchogg: hmm, this is strange
10:31:10 <wchogg> Cale:  Indeed.  I'm rather confused by what it's doing.  The code is very simple!
10:31:28 <Cale> if I print the intermediate results, there are many 0's
10:32:24 <DeliQ> @seen Phyx
10:32:24 <lambdabot> I haven't seen Phyx.
10:33:33 <Cale> oh
10:33:37 <Cale> I think I know :)
10:33:43 <wchogg> Why?
10:33:50 <Cale> yeah, not v + y, x + v
10:34:11 <Cale> foldM is a left fold
10:35:35 <wchogg> Well, you're right.  That was the problem.  I don't really think I see why that caused the problem though.  Why did that make it return n every time?
10:36:24 <wchogg> Oh nevermind.  I get it.
10:38:16 <wchogg> So theoretically, what's the difference between foldl and foldr?  To me it always looks like they should work the same except for operators that are not associative.
10:40:04 <Cale> well, http://cale.yi.org/autoshare/folds.png
10:40:27 <Cale> you can see the difference in the shape of the code graphs produced by them
10:45:09 * vincenz reboots to windows to check his presentation
10:56:08 * vincenz mutters
10:58:50 <vincenz> anyone use openoffice?
10:59:07 <SyntaxNinja> vincenz: ja
10:59:12 <Cale> vincenz: I have
10:59:16 <SyntaxNinja> vincenz: btw, this evolution thing was a known bug
10:59:33 <vincenz> How do I export to pdf such that slides with transitions generate separate slides?
10:59:37 <vincenz> SyntaxNinja: oh?
10:59:58 <vincenz> I tried exporting to powerpoint, but the format was horrible (fonts and stuff, boxes not aligned with text..)
11:06:25 <vincenz> oh well
11:10:27 <Taral> We need something like perl's CPAN module for haskell.
11:11:07 <jip> do we?
11:11:12 <wchogg> Are there enough utilities written in haskell to justify it yet?
11:11:25 <norpan> CPAN is dangerous
11:11:30 <norpan> perl is dangerous
11:11:45 <jip> dons mentioned some listing of haskell tools and libraries. where is it?
11:13:17 <SyntaxNinja> Taral: we have something like that.
11:13:21 <SyntaxNinja> Taral: hackage.haskell.org
11:13:26 <SyntaxNinja> Taral: but it needs some hacking to be practical
11:13:39 <Taral> It seems like everything is like that in haskell.
11:13:39 <SyntaxNinja> but "cabal-get install Foo" installs the foo package and its dependencies
11:13:51 <SyntaxNinja> Taral: not everything.
11:13:56 <Taral> No, not everything.
11:14:00 <Taral> ghc's package management is pretty good
11:14:15 <SyntaxNinja> Taral: glad you like it ;)(
11:14:29 <SyntaxNinja> so who wants to help hack on cabal-get?
11:15:17 <wchogg> SyntaxNinja:  So is cabal kindof like asdf-install in CL?
11:15:19 <xerox> Sounds like an a good project <blink>
11:16:48 <SyntaxNinja> xerox: yeah, my thoughts exactly.
11:16:57 <xerox> Great.
11:17:27 <SyntaxNinja> wchogg: I don't konw asdf-install.
11:17:43 <SyntaxNinja> wchogg: cabal is sorta like the debian package system.
11:17:57 <SyntaxNinja> wchogg: and python's distutils
11:18:06 <wchogg> But it can find the dependencies from a repository and install them?
11:18:21 <wchogg> That's what it sounds like.
11:18:37 <SyntaxNinja> wchogg: cabal itself just keeps track of dependencies, cabal-get is the thing that installs them, hackageDB is the repository :). the whole thing is called hackage
11:18:40 <SyntaxNinja> for Haskell Package system
11:18:57 <wchogg> Ah, okay.
11:19:18 <Taral> greeat
11:19:24 <Taral> Cannot find: cabal-install
11:20:05 <SyntaxNinja> You can try out the cabal-get beta by grabbing the bootstrap tarball here: darcs get http://hackage.haskell.org/darcs/cabal-get-bootstrap.  For Windows users, this may require Cygwin.
11:20:29 <SyntaxNinja> Taral: you got an error that said cannot find cabal-install? where?
11:20:56 <Taral> % runhaskell Install.hs
11:21:01 <Taral> on cabal-get-bootstrap
11:23:15 <SyntaxNinja> Taral: you need the darcs cabal version also, which comes w/ cabal-install
11:23:38 <SyntaxNinja> as in the README: These packages also require the darcs version of Cabal (which includes
11:23:38 <SyntaxNinja> cabal-install) or Cabal >= 1.1.3 and cabal-install.
11:24:54 <Taral> grar!
11:25:05 <Taral> @where cabal
11:25:06 <lambdabot> http://www.haskell.org/cabal
11:25:26 <SyntaxNinja> Taral: but really, the installation is the only bad part about cabal-install, which is why I want to include it in cabal itself.
11:25:29 <SyntaxNinja> er, cabal-get
11:32:45 <jip> hm.... i think i should be using a state monad
11:35:05 <jip> threading all of this state is starting to get /real/ messy
11:37:26 <jip> problem is i have a state that has several fields
11:37:43 <jip> would be nice if i could do getX, getY, getZ, putX, putY, putZ, ...
11:37:49 <jip> what options do i have?
11:37:54 <norpan> use a named tuple
11:38:11 <xerox> I.e. a record
11:38:17 <norpan> yes
11:38:46 <jip> well, my actual state is already a regular tuple containing another tuple and a record
11:38:58 <norpan> so make it a named tuple
11:39:03 <xerox> Then define those commodity functions.
11:39:07 <norpan> or define
11:39:30 <jip> but how will this help me with the get and state monad function things?
11:39:42 <xerox> What do you mean?
11:39:51 <jip> which monad should i be using?
11:40:16 <norpan> @hoogle StateT
11:40:17 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
11:40:17 <lambdabot> Control.Monad.State.StateT :: newtype StateT s m a
11:40:17 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
11:40:19 <xerox> It depends on what you want to do.
11:45:26 <jip> here's my current code:
11:45:28 <jip> http://rafb.net/paste/results/CpyHQv11.html
11:46:06 <xerox> Oh, the emulator!  You're going to need something fast.
11:46:50 <xerox> Or something general enough to be monadically-pluggable ongoing.
11:47:15 <jip> so far i haven't been thinking about performance at all. i just want to get something that works
11:47:23 <xerox> Right.
11:47:29 <xerox> What does that code do? :-)
11:48:16 <jip> it counts down a few different timers. when a timer reaches 0 then the state of memory or registers needs to be modified
11:48:35 <jip> the code works, but it's pretty messy, and there is a lot more that needs to be added to it
11:49:56 <xerox> jip: I see.
11:50:33 <SyntaxNinja> Taral: success yet?
11:50:35 <xerox> So your state counts RegisterStates, Memory and IrqStates ?
11:51:40 <jip> the total "machine state" is the product of these 3. registers and memory are concrete states of all of the values, while irqstate maintains more abstract state, the counters and other things
11:51:53 <Taral> installing new cabal
11:52:11 <jip> xerox: i actually think that this code isn't too bad, i should be able to clean it up a bit by using "let" more
11:52:35 <Taral> nope
11:52:37 <Taral> no cabal-install
11:53:17 <bolrod> whats the best haskell editor?
11:53:25 <jyp> @pl \x y -> (x:y:[])
11:53:26 <lambdabot> (. return) . (:)
11:53:57 <bolrod> ..
11:54:03 <Taral> vim
11:54:14 <Cale> or emacs
11:54:15 <bolrod> just vim?... or with some special things added?
11:54:16 <xerox> jip: you can write |tick :: State (Registers,Memory,Irq) a|, and implement it like 'do { (r,m,i) <- get; newState <- doThings r m i; put newState; ... }.
11:54:22 <Taral> just vim
11:54:26 <vincenz> Cale: emacs schmemacs
11:54:35 <bolrod> :)
11:54:45 <xerox> Emacs is pretty cool.  You can have GHCi in a buffer, and evaluate expressions/buffers/files with few keystrokes.
11:54:59 <vincenz> after you learn how to fly a jetplane, sure
11:55:00 <Taral> @seen Igloo
11:55:00 <lambdabot> Igloo is in #haskell. I last heard Igloo speak 2 hours, 2 minutes and 54 seconds ago.
11:55:07 <Taral> @ping Igloo
11:55:08 <lambdabot> Not in scope: type constructor or class `Igloo'
11:55:08 <vincenz> xerox: but with those skills I can fly to the moon
11:55:09 * bolrod knows very little key combinations to make vim or emacs doo anything at all
11:55:11 <xerox> It's pretty simple in fact.
11:55:11 <ValarQ> xerox: do notation in pre2.1 is quite anoying thought
11:55:12 <bolrod> besides writing text
11:55:24 <xerox> ValarQ: what's "pre2.1" ?
11:55:37 <bolrod> hmm...  
11:55:39 <ValarQ> xerox: haskell-mode older than version 2.1
11:55:57 <xerox> ValarQ: sure, one *has* to get the latest one.
11:56:03 * bolrod wonders if the vim + emacs manual put together is bigger then the study books needed for learning to fly
11:56:07 <bolrod> :]
11:56:26 <jip> xerox: hm...
11:56:39 <vincenz> bolrod: you could probably get a nobel prize for learning both emacs and vim
11:56:42 <xerox> bolrod: fire up Emacs, and press C-h t.  (C-h means holding the CTRL key while pressing the 'h' one.  Then release both, and press t.)
11:57:00 <vincenz> xerox: how do you handle those shortcuts that require 12 fingers?
11:57:08 <vincenz> xerox: I mean ... 11...ok use your nose
11:57:30 <bolrod> how the hell does one exit emacs?!O_o
11:57:41 <ValarQ> vincenz: doesn't sound like a shortcut :/
11:57:44 <vincenz> bolrod: CTRL+ALT+DELETE
11:57:45 <xerox> bolrod: the tutorial I asked you to run says that.
11:57:49 <osqulda> how do I compose two type constructors in Haskell?
11:57:50 <ValarQ> bolrod: SIGKILL
11:57:51 <xerox> bolrod: it's just C-x C-c.
11:57:59 <osqulda> newtype Comp m n a = MkComp (m (n a))   ??
11:57:59 <bolrod> 'just'
11:58:06 <xerox> osqulda: it depends on whose they are.
11:58:11 <vincenz> bolrod: kill -9 emacs; cd /; rm -rf `find . | grep emacs`
11:58:13 <bolrod> I just killed the terminal
11:58:14 <bolrod> way easier
11:58:17 <bolrod> HAHA
11:58:33 <bolrod> ok... so I type in  emacs on the terminal
11:58:34 <xerox> bolrod: try reading the tutorial, after the first few paragraphs you'll know enough to work with it.
11:58:35 <monochrom> someone really hates emacs
11:58:36 <bolrod> then what do I do?
11:58:38 <bolrod> xD
11:58:42 <vincenz> monochrom: I wanted to learn how to use it
11:58:44 <xerox> C-h t.
11:58:53 <vincenz> monochrom: it was impossible
11:58:56 <norpan> vim vim vim
11:59:02 <vincenz> vim vim vim
11:59:09 <vincenz> keeps your windows clean too
11:59:11 <bolrod> what nifty things does vim have :)
11:59:29 <norpan> it has =G
11:59:36 <xerox> As soon as you master the few needed strokes to work on Haskell sources, start hacking hIDE :-)
11:59:52 <vincenz> why not yi?
11:59:58 <bolrod> whats =G
12:00:00 <bolrod> O_o
12:00:07 <bolrod> dude... this tutorial is confusing
12:00:13 <xerox> bolrod: ?
12:00:19 <bolrod> all I see is  CTRL this ALT that and META blah
12:00:24 <osqulda> What's wrong with this class? class (Monad m, Monad n) => Test f m n where  ... ?
12:00:29 <bolrod> hell.. I want to use an editor
12:00:33 <norpan> haIDE
12:00:36 <xerox> bolrod: C- is CTRL, M- is ALT.
12:00:46 <xerox> bolrod: don't give up so easily.
12:00:52 <bolrod> I will
12:00:57 <bolrod> :p
12:01:01 <xerox> osqulda: what error are you getting?
12:01:08 <bolrod> I'll just stick with vim for the moment
12:01:21 <monochrom> I like vi but I don't like vim.
12:01:25 <osqulda>  All of the type variables in the constraint `Monad m' are already in scope     
12:01:35 <norpan> how can you like vi and not vim?
12:01:52 <osqulda> Sorry, I get
12:01:54 <osqulda> Kind error: `Comp m m' is not applied to enough type arguments   
12:02:06 <xerox> Sorry I gotta go, later~
12:02:17 <bolrod> later
12:02:19 <monochrom> vim has extra things getting into the way.  All too easily it puts me into some weird help screen or something and I can't get out without quitting vim altogether.
12:02:38 <bolrod> so any extensions that can make vim better looking with haskell?
12:02:54 <norpan> osqulda: there was no Comp in your example
12:03:05 <osqulda> newtype Comp m n a = MkComp (m (n a))   
12:03:17 <norpan> yes but in your class example
12:03:31 <monochrom> Perhaps I'm too dumb to use vim.
12:03:43 <osqulda> the error is from the instance decl. instance (Monad m) => Test (Comp m m) where   
12:03:57 <bolrod> MAN!  its easier to learn haskell while writing on a paper
12:04:02 <bolrod> then use all the functions of vim
12:04:03 <bolrod> >:/
12:04:21 <sjanssen> bolrod: do you have highlighting working?
12:04:24 <bolrod> yes
12:04:32 <bolrod> but I don't know if I really like it
12:04:37 <Twigathy> bolrod, you may want to check out gedit if you want a GUI app with syntax highlighting....but im fairly sure a lot of people will flame for that ;)
12:04:39 <bolrod> what background to choose for it
12:04:48 <bolrod> I have used gedit
12:04:55 <bolrod> but it doesn't support literate haskell >:(
12:05:03 <bolrod> which is mendatory for the next assignment
12:05:13 <Twigathy> doh! :)
12:05:19 <sjanssen> bolrod: if you're looking for a different colorscheme, I enjoy evening
12:05:56 <bolrod> erh... and how to use that?
12:06:04 <bolrod> already in vim?  or have to download something?
12:06:05 <osqulda> where can I paste?
12:06:33 <sjanssen> if you're using gvim: Edit Menu -> Colorscheme -> evening
12:06:43 <Lemmih> jip: pong
12:06:52 <bolrod> I'm using just vim :)
12:06:55 <bolrod> but lets see gvim
12:07:16 <osqulda> @paste
12:07:16 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:08:57 <osqulda> is there a better page...?
12:09:04 <Lemmih> @where paste
12:09:05 <lambdabot> http://paste.lisp.org/new/haskell
12:09:49 <lisppaste2> osqulda pasted "dist" at http://paste.lisp.org/display/19091
12:10:13 <osqulda> can you see what is going on here?
12:12:32 <sjanssen> osqulda:what's your error?
12:12:51 <osqulda> L8c.hs:24:29:
12:12:51 <osqulda>     Kind error: `Comp m m' is not applied to enough type arguments
12:12:51 <osqulda>     In the instance declaration for `Dist (Comp m m)'      
12:13:13 <osqulda> I should be able to force n==m, right?
12:14:00 <sjanssen> type equality is a little trickier than that, if I remember correctly
12:14:02 <bolrod> I think I'll use the gvim
12:14:04 <bolrod> it looks nice
12:14:18 <osqulda> yes
12:14:20 <bolrod> plus.. I can use the mouse
12:14:24 <bolrod> unlike with vim
12:14:26 <osqulda> but, I am enforcing a specific type for overloading here
12:14:33 <sjanssen> you also don't have enough parameters for your Dist instance
12:14:51 <osqulda> Functor has just one parameter sicne it is a constructor class. I want Dist to be one too
12:15:43 <sjanssen> then you need to change your class decl. for Dist
12:15:44 <osqulda> partial application here of a type constructor (* -> * -> * -> *)
12:15:53 <osqulda> how's that?
12:16:37 <sjanssen> Dist currently takes three parameters: f, m, and n
12:16:44 <osqulda> GOT IT working,t hanks
12:16:52 <osqulda> Yes, and it should
12:17:06 <osqulda> thanks anyway
12:17:48 <osqulda> good night sjanssen and thanks for your time
12:21:49 <bolrod> well.. lovely day isn't it
12:23:06 <Igloo> Taral: Yes?
12:25:32 <Taral> Igloo: ghc-cvs debian package
12:25:35 <Taral> is it usable?
12:25:55 <Taral> SyntaxNinja: No cabal-install
12:26:07 <Igloo> It is almost certainly not worth using currently
12:26:30 <Taral> You might consider having it removed or stubbed -- or maybe updated? :)
12:27:51 <Igloo> I'll investigate whether the problems with updating it have been fixed when I have time
12:44:29 <davidhouse> raargh.
12:45:07 <Taral> .hgraar
12:47:56 <bolrod> ghraar
12:51:27 <Taral> ar.gah
12:55:28 <Oejet> @arr
12:55:29 <lambdabot> Aye
12:56:28 <bolrod> @arr
12:56:29 <lambdabot> Yeh scurvy dog...
12:56:47 <bolrod> whoho
12:58:10 <xerox> bolrod: one nice thing about haskell-mode is that you can press C-c C-l and have the file you're editing interpreted in a GHCi session on the fly.
12:58:36 <jip> Lemmih: pingpong
12:58:37 <bolrod> yes... well...
12:58:37 <xerox> The focus goes to the interpreter in case of success, or directly to the line/column of the error if any.
12:58:52 <xerox> It's *very* handy, the main reason I'm using Emacs for the job, I'd say.
12:58:53 <bolrod> ALT-TAB-> UP ARROW -> ENTER
12:58:59 <bolrod> doesn't seem like alot of more work
12:59:24 <xerox> Yes, but using the interpreter in the same framework in which you edit the code has other advantages as well.
13:00:05 <xerox> There are other nice candies I really enjoy, like having the type of the function at point displayed in the minibuffer (the last line).
13:01:47 <bolrod> ;o
13:03:32 <xerox> Some glitches about the indentation, but I'm satisfacted by how it works in total.
13:03:53 <davidhouse> hmm... that C-c C-l doesn't seem to work for me
13:04:00 <davidhouse> i presume the file has to have a main
13:04:05 <xerox> davidhouse: nope.
13:04:20 <davidhouse> regardless
13:04:30 <davidhouse> it just prints "No changes need to be saved" and does nothing
13:04:42 <davidhouse> what's your C-h k C-c C-l?
13:04:57 <xerox> Ah, switch to the *haskell* buffer.
13:05:11 <xerox> I don't remember how I fixed the fact that that buffer didn't come up by itself.
13:05:53 <davidhouse> hmm.
13:06:07 <xerox> C-c C-l runs the command inferior-haskell-load-file
13:06:20 <davidhouse> good, that's the same as mine.
13:06:31 <davidhouse> does it understand GHC pragma?
13:06:37 <xerox> What do you mean?
13:06:37 <davidhouse> {-# ... #-}
13:07:10 <xerox> It just loads the file, so if you're using GHCi, everything works as much as if you were doing "ghci File.hs".
13:07:29 <davidhouse> oh, of coruse.
13:07:57 <CosmicRay> huh.  it appears haxml is not packaged for debian.
13:07:58 <CosmicRay> odd.
13:07:59 <xerox> Does it create the *haskell* buffer nevertheless?
13:08:03 <xerox> Howdy CosmicRay!
13:08:09 <CosmicRay> hi xerox
13:08:44 <CosmicRay> I was *sure* someone had packaged it
13:08:54 <davidhouse> xerox, yep. it works if i switch.
13:09:09 <CosmicRay> huh, maybe just an ITP: http://lists.debian.org/debian-devel/2005/05/msg01211.html
13:09:26 <davidhouse> woo! works :)
13:09:32 <davidhouse> xerox, which terminal emulator does it use?
13:09:58 <xerox> davidhouse: it does use comint-mode for the communication with the interpreter.
13:10:24 <davidhouse> it even highlights the prompt! that's _so_ useful.
13:10:31 <davidhouse> any other haskell-mode gems? :)
13:12:10 <xerox> Indeed.
13:13:33 <davidhouse> one thing i do wish is that the highlighting was a bit snappier.
13:13:43 <davidhouse> it tends to wait for a second or two after i've stopped typing.
13:13:59 <davidhouse> and type-checking-as-you-type  la hIDE would be nice too :)
13:16:32 <xerox> heh
13:16:40 <xerox> yay hIDE!
13:16:48 <bolrod> ?
13:16:55 <davidhouse> @wiki hide
13:16:56 <lambdabot> http://www.haskell.org/haskellwiki/hide
13:17:07 <davidhouse> or even
13:17:10 <davidhouse> @wiki hIDE
13:17:10 <lambdabot> http://www.haskell.org/haskellwiki/hIDE
13:18:19 <bolrod> put it in the summer of code :p
13:19:03 <xerox> Right!
13:19:31 <xerox> bolrod: there are good chances that some student could get to hack on it.
13:20:20 <xerox> You Haskellers!  Start thinking about possible SoC Haskell project (-:
13:20:43 <bolrod> :P
13:20:55 <bolrod> I think its weird Ubuntu is named in the FAQ
13:21:02 <bolrod> but isn't in the mentoring groups ;)
13:21:15 <bolrod> nop.. still not 
13:21:18 <bolrod> maybe they will
13:22:04 <wchogg> What organization would be a mentor group for a Haskell themed SoC project?
13:23:02 <bolrod> blah
13:23:03 <davidhouse> #haskell? :)
13:23:09 <bolrod> said it in the #haskell-blah chan
13:23:24 <bolrod> only Free- and NetBSD are in the mentoring groups as OS'es
13:23:28 <bolrod> I don't see any other OS
13:23:30 <xerox> wchogg: there are good possibilities that such organization will be Haskell.org itself.
13:24:04 <bolrod> could ask some university to mentor for the group
13:24:13 <xerox> Group?
13:24:24 <bolrod> group of students working on projects?
13:24:40 <xerox> There are no groups of studends in the SoC, only individuals.
13:24:52 <bolrod> all together they are a group
13:25:00 <bolrod> jjust not working together
13:25:10 <bolrod> someone must guide them
13:25:14 <xerox> (Mentors are chosen by the mentoring organizations, too.)
13:25:22 <bolrod> ah
13:25:47 <bolrod> then who'll decide to enther the SoC
13:25:49 <bolrod> :p
13:25:53 <xerox> I.e. assigned by the "admins" to the project accepted (for the number of slots the organization got.)
13:26:21 <xerox> bolrod: think up some interesting proposals! (-:
13:26:28 <bolrod> haha
13:26:34 <bolrod> I'm not too good with haskell yet
13:26:37 <bolrod> maybe next year
13:26:38 <bolrod> ;p
13:27:07 <davidhouse> i'd love a haskell SoC project.
13:27:08 <xerox> Aww.  Why so?  Haskell, Open Source, summer paid work isn't what we are all chasing for?
13:27:12 <bolrod> a good gui library extension ;p
13:27:26 <xerox> davidhouse: any ideas? (-:
13:27:31 <davidhouse> yeah, a functional api to gtk2hs would be awesome.
13:27:40 <xerox> Yampa + Gtk2Hs ?
13:27:45 <bolrod> I have to work with wxwidgets now
13:27:54 <bolrod> don't know if I'm going to like it ;)
13:28:18 <wchogg> xerox:  If there were a haskell SoC proposal I thought looked fun, I'd sign up.
13:28:19 <xerox> davidhouse: it sounds like a good idea to me.  Do you have any idea about how to design and develop it?
13:28:35 <xerox> (Students have three months this time!  The first edition gave us two.)
13:28:43 <bolrod> wchogg: the thing is you have to come up with some proposal ? :)
13:28:44 <davidhouse> i haven't really thought about it.
13:29:02 <davidhouse> i just know that working with gtk2hs turns your entire program into do blocks.
13:29:03 <xerox> wchogg: part of the role of the mentoring organization is to propose projects.  But the fun is all about students making up theirs!!!
13:29:26 <xerox> davidhouse: that's right, we need a way to get rid of the IORefs-style programming.
13:29:35 <wchogg> xerox:  Maybe I'll try to think of something then.
13:29:43 <bolrod> wxhaskell is also alot of IO
13:29:51 <bolrod> if you don't watch out
13:29:57 <bolrod> your whole program is just IO
13:30:10 <xerox> wchogg: I'd love to hear new ideas :-)
13:30:15 <davidhouse> xerox, throw together a wiki page
13:30:40 <xerox> davidhouse: give just a few more days.
13:30:51 <davidhouse> dcoutts et al have expressed their opinions that gtk2hs should form the basis for a higher level, functional UI lib.
13:32:42 <xerox> We need to balance between theoretically beautiful projects and code that can be possibly wrote in three months; then, there will be summer paid opensource haskell work for a number of students, and a good bunch of shiny new code for the Haskell world :-)
13:32:51 <xerox> (That's my opinion at least.)
13:33:12 <bolrod> haha
13:33:14 <xerox> (Yeah, I'm pretty excited about all this.)
13:33:23 <bolrod> what woudl be a cool project though
13:33:39 <bolrod> not just 'some theoretical OS in haskell'
13:33:42 <bolrod> but something really cool
13:34:11 <mahogny> bolrod, choose the tools after the application, not the reverse
13:34:12 <bolrod> uber cool datatypes or something :)
13:34:30 <xerox> Implementing Daan's records? (-;
13:34:37 <bolrod> ?
13:34:52 <bolrod> Daan's what records? :)
13:35:17 <xerox> I'm just thinking out loud.
13:35:35 <xerox> @google Extensive records with scoped labels
13:35:37 <lambdabot> http://home.tbbs.net/~msland/Spector/PSindex.htm
13:35:39 <xerox> Ops.
13:35:46 <xerox> @google Extensible records with scoped labels
13:35:47 <lambdabot> http://lambda-the-ultimate.org/node/1119
13:35:50 <davidhouse> i'd prefer something useful to something academic
13:36:00 <xerox> @google Extensible records with scoped labels site:cs.uu.nl
13:36:03 <lambdabot> http://www.cs.uu.nl/~daan/pubs.html
13:36:06 <xerox> There.
13:36:19 <bolrod> Daan Leijen...  hrm  works for microsoft now.. tha bastard ;)
13:36:23 <xerox> davidhouse: right, the project have to pass Google scrutiny too :-)
13:37:43 <bolrod> hell I don't understand a word of that thing
13:38:45 <wchogg> xerox:  I know everyone likes his records proposal, but is it something that could be imp'ed in three months into GHC?
13:38:58 <mahogny> daan's "records" are in my world called associative arrays
13:39:25 <xerox> wchogg: I don't exactly know, last time Philippa was telling me that it isn't that simple to implement them efficiently.
13:39:26 <mahogny> I fail to see the use of these; it looks like bad programming
13:39:53 <davidhouse> bolrod: records are things like data R = R { one :: Int, two :: String, three :: [Bool] }
13:40:17 <bolrod> ic..
13:40:38 <bolrod> and they are used for?
13:40:38 <davidhouse> so instead of using (Int, Int, Int) for a date, we might want to use data Date = Day { year :: Int, month :: Int, day :: Int }
13:41:27 <davidhouse> if we then have a Date, say d, we can go year d to get the year, month d to get the month, and day d to get the day.
13:41:32 <davidhouse> you create them like he shows.
13:41:45 <davidhouse> let d = Day { year = 1973, month = 7, day = 7 }
13:41:45 <xerox> mahogny: I liked the code examples in the paper.
13:41:54 <xerox> mahogny: like the "warning" function.
13:43:24 <xerox> mahogny: I mean, it doesn't seem like "bad code" to me because of the checks the type system does.
13:44:32 <mahogny> xerox, while the type system is clean, I still think this feature is way over engineered and that most things can be implemented without this. it's a quite big thing to implement
13:45:07 <xerox> mahogny: Yes it is a big thing, it is just the last neat thing I read about.  Any other ideas?
13:45:19 <loonatic> is there a haskell library for easy & fast image output (to file, like bmp or png's or such)?
13:45:31 <mahogny> xerox, ideas as in? :)
13:46:00 <mahogny> loonatic, haskell sucks in general when it comes to binary files if you ask me
13:46:07 <xerox> loonatic: cairo can output on a variety of backend, but I don't know if that's what you mean.  It does PNGs, PDFs, PSs, X11 (via Gtk), and prolly others will come with time.
13:47:32 <bolrod> anyway...before I'm going to do any project for haskell .. I think I'll first need to underestand the language completely
13:47:45 <bolrod> especially monads and state
13:47:50 <bolrod> which I don't quite grasp yet
13:48:05 <bolrod> I haven't looked at it alot yet... but still
13:48:18 <xerox> Did you read Cale's article on the oldwiki?
13:48:25 <xerox> @wiki MonadsAsContainers
13:48:26 <lambdabot> http://www.haskell.org/haskellwiki/MonadsAsContainers
13:48:27 <bolrod> don't know
13:48:33 <xerox> It's very enlightening.
13:48:44 <bolrod> oldwiki?
13:48:56 <xerox> That link.
13:48:59 <bolrod> @oldwiki MonadsAsContainers
13:48:59 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
13:49:00 <xerox> Hmm.
13:49:05 <xerox> Wops, that :-)
13:49:26 <bolrod> I don't know.. 
13:49:43 <bolrod> http://www.nomaware.com/monads/html/  < < I read that
13:49:55 <bolrod> and its not that I don't know what a monad is
13:50:02 <bolrod> but its not like I know everything about it
13:50:28 <xerox> loonatic: did you send me a NOTICE perchance?
13:50:56 <basti_> bolrod: welcome to theoretical computer sciences.
13:51:04 <bolrod> haha
13:51:11 <monochrom> No one knows everything about monads.  No one knows everything about the natural numbers either.  I mean everyone knows the axioms and some well-known facts and usages, but you expect to learn something new everyday.
13:51:15 <bolrod> maybe I shouldn't read these things at night
13:51:20 <bolrod> or ealry in the morning
13:51:48 <norpan> all you need to know is how to use 'em
13:52:02 <bolrod> lets say there is more yet to know about monads that is already known
13:52:07 <bolrod> then there is that I already know
13:52:19 <bolrod> or something
13:52:29 <bolrod> or how to create them
13:52:33 <monochrom> Go ahead and use some monads and write some of your own.  That's the only known way.
13:52:44 <bolrod> I used the IO monad
13:52:52 <xerox> Indeed.  It also helps to try to write the code with and without them.
13:52:56 <bolrod> thats not difficult..
13:53:03 <bolrod> but creating your own is something different
13:53:07 <monochrom> Try to use the monad transformer library in ghc.  It'll open your eyes.
13:53:33 <davidhouse> bolrod: most of the monads you create will just be combinations of existing ones
13:53:51 <monochrom> Using the monad transformer library sits somewhere between using an existing monad and writing your own.  You won't regret it.
13:53:53 <bolrod> because?
13:54:06 <mahogny> monochrom, open eyes, open mouth, screaming? :)
13:54:10 <xerox> Because someone found a neat way to stack them up!
13:54:20 <davidhouse> bolrod: because the existing monads are really good
13:54:22 <xerox> Dunno who :-)
13:54:32 <bolrod> yes..   ok.. still I want to be able to create my own
13:54:38 <davidhouse> sure.
13:54:39 <bolrod> not that I would use them for anything
13:54:42 <davidhouse> it's not hard.
13:54:48 <bolrod> obviously not
13:54:53 <davidhouse> just define >>= and return.
13:55:07 <bolrod> yes ofcourse..  but in a practical way ofcourse ;/
13:55:14 <xerox> You can get a good grasp about what and how >>= return are defined by reading that article I pointed you before.
13:55:27 <bolrod> I will read it ;)
13:55:41 <monochrom> When you have had a taste of the monad transformer library, you'll be more ready to write your own monads (or decide you'll never need to :) )
13:55:51 <bolrod> the link I gave began about the state monad..
13:55:57 <bolrod> I don't quite grasp that yet
13:56:06 <bolrod> the rest is quite easy to understand
13:56:31 <monochrom> Look at the source code of the mtl too.  (Gosh I quit typing monad transformer library in full!)
13:56:31 <xerox> Do you understand what does 'State s a' mean in the type signature?
13:56:32 <bolrod> hmm.. ok..  todo:  understand state monad,  read transformer library :)
13:56:49 <bolrod> I don't know the use of it yet no ;)
13:57:01 <xerox> State s a  =  s -> (a,s)
13:57:09 <monochrom> Take your time.  We'll always be ready to discuss.
13:57:20 <bolrod> monochrom: I just started ;)
13:57:35 <bolrod> I think I only read about the state monad once or so
13:57:42 <bolrod> hehe 
13:57:48 * xerox is just too excited, should take a breath of fresh air
13:57:57 <bolrod> hehe
13:58:00 <xerox> Reader e a  =  e -> a
13:58:13 <bolrod> its all the same to me.. since I don't know the use
13:58:33 <xerox> Writer w a  =  (a,w)  ?
13:58:38 <bolrod> nop
13:58:54 <xerox> I think so.
13:59:01 <bolrod> I don't know about it 
13:59:08 <bolrod> thats what I meant ;)
13:59:08 <xerox> No problem.
13:59:32 <davidhouse> state: computations in State are stateful, i.e. their result depends on both the parameters you pass in as well as extra parameter, called the state.
14:00:01 <davidhouse> so they are functions from state to a value. but we also allow them to change the state, so they're actually functions from state to a pair of (new state, value).
14:00:06 <xerox> Cont r a  =  ((a -> r) -> r)
14:00:38 <bolrod> aha
14:00:43 <davidhouse> once you build up a complicate State-ful computation, you're basically just building a huge function that takes state and spits out that pair.
14:01:06 <davidhouse> so you run it, with runState, providing the state parameter which gets chopped and changed througout this big function
14:01:11 <jip> xerox: i did some tests with putting a yampa layer over gtk2hs. i was able to get a simple "counter" demo, and also a port of the calculator gtk2hs demo working
14:01:15 <davidhouse> until  the end, where you have some new state, and a value.
14:01:38 <bolrod> sounds reasonable
14:01:50 <bolrod> is there anything you can do with State that you can't do without it?
14:02:30 <davidhouse> nope, but you end up threading the state through all your functions that depend on it.
14:02:35 <davidhouse> this is inconvenient.
14:02:39 <xerox> jip: did sounds promising!  Do you have any code I could look at?
14:02:41 <davidhouse> monads in general are just for convenience.
14:02:54 <davidhouse> (and to hide implementation, like with IO)
14:02:58 <xerox> Yes, that's why I told you to try write the same code with and without monads!
14:03:22 <bolrod> aha
14:03:44 <davidhouse> Reader is very similar to State, you're just not allowed to change the state along the way. as such, computations in Reader are functions from the initial state to a value, not to a pair.
14:03:47 <bolrod> I did write some Sudoku solver that I thought might use something like state
14:03:58 <bolrod> because it totally fucks up if you ask me ;/
14:04:15 <davidhouse> it would probably use a combination of State and [].
14:04:17 <davidhouse> using, that's right, monad transformers :)
14:04:28 <davidhouse> check out Cale's sudoku solver, http://haskell.org/haskellwiki/Sudoku
14:04:48 <bolrod> I did look at it...  didn't really try to understand it
14:05:03 <bolrod> I just wanted a simple solver
14:05:09 <bolrod> that doesn't guess anything
14:05:14 <jip> xerox: i am planning on eventually writing an article about the technique that i used, but i'll paste the code for you to see now
14:05:20 <davidhouse> simon peyton jones's doesn't guess.
14:05:21 <xerox> As Cale posed it out, the monadic way of solving that problem was writing an ad-hoc language (monad) to solve the problem in.  If I phrased it correctly.
14:05:22 <bolrod> and would only solve sudoku's that are solvable without guessing
14:05:32 <davidhouse> http://haskell.org/haskellwiki/Sudoku#No_guessing
14:05:58 <xerox> jip: it would be great, I'm not implying I might have instant thoughts/ideas on it, but it would be fun to see it.
14:08:25 <bolrod> http://rafb.net/paste/results/ZUqKmf35.html    (ok.. maybe a bit messy)
14:08:37 <jip> xerox: what i got working is, you describe your gui behaviour directly using yampa arrows and combinators. this involves manually hooking up gtk widget signals and actions to their yampa counterpart. the plan is to make a function that automatically does this process. here is the code:
14:08:48 <bolrod> davidhouse: what the hell are you doing?!  ;)
14:09:01 <davidhouse> bolrod: my client kept freezing.
14:09:21 <bolrod> http://rafb.net/paste/results/ZUqKmf35.html    <<   that totally fucks up when I try to pass the first result of a function into the same function again
14:09:32 <bolrod> maybe its a bit messy 
14:09:50 <bolrod> the function I used isn't even in there
14:10:03 <bolrod> got so fed up with it I removed it probably
14:10:05 <bolrod> ;D
14:11:25 <jip> xerox: a gui with a button and a text field with the number 0 in it. clicking the button incremenets the number
14:11:32 <bolrod> davidhouse: don't use Kopete for irc...
14:11:37 <jip> xerox: this is how it's done "normally" in gtk2hs, using an IORef for state: http://rafb.net/paste/results/vAZjrE59.html
14:11:40 <davidhouse> bolrod: meh. it's convenient.
14:11:40 <xerox> jip: I think your before-last message was cut up
14:11:45 <bolrod> meh. it is not
14:11:52 <xerox> jip: i.e. there was no link in it
14:11:59 <bolrod> its ugly, its unstable, and also ugly 
14:12:01 <bolrod> ;)
14:12:13 <jip> xerox: and here is how it's done with a yampa layer on top of gtk2hs. no IORefs in sight: http://rafb.net/paste/results/Pzesdq43.html
14:12:32 <davidhouse> jip, btw, "(xmlNew gladeFile) >>= return . fromJust" = "liftM fromJust $ xmlNew gladeFile"
14:12:48 <davidhouse> any time you find yourself writing return on the right-hand-side of a >>=, use lifM.
14:12:50 <davidhouse> *liftM
14:12:50 <xerox> jip: I'll be carefully looking, thanks much.
14:13:24 <bolrod> davidhouse: why not irssi or xchat
14:13:40 <davidhouse> can they handle MSN simultaneously?
14:13:47 <bolrod> irssi can with bitlbee
14:13:51 <bolrod> so does xchat
14:14:00 <bolrod> its not fancy colours though
14:14:07 <bolrod> or file transfer
14:14:08 <davidhouse> i'll bet the support isn't as comprehensive as kopete's.
14:14:23 <bolrod> urh.. I like bitlbee
14:14:31 <bolrod> since it just opens an msn convo as a query
14:14:53 <jip> xerox: lowLevelSF is the yampa signal function that describes the gui behaviour. i call it "low level", since the idea is that this structure will be automatically generated from a similar structure, that won't require you to manually thread the gtk widget input/output data through
14:14:53 <xerox> Cale's solver is really great.
14:14:56 <bolrod> and I don't want fancy icons or something
14:15:23 <bolrod> my point is.. MSN should not integrate with IRC >:(
14:15:30 <bolrod> or.. it does
14:15:37 <bolrod> IRC should not integrate with MSN :P
14:15:48 <bolrod> heh.. I'm confusing
14:16:02 <bolrod> IRC > MSN    (guess thats easier to understand()
14:17:38 <bolrod> davidhouse: you don't agree?
14:17:54 <davidhouse> i don't agree they shouldn't integrate
14:18:07 <bolrod> blah...
14:18:14 <bolrod> IRC is not instant messaging
14:18:42 <bolrod> I think you should not lower IRC to the level of MSN
14:18:50 <bolrod> but rather get MSN to the level of IRC with bitlbee
14:18:51 <bolrod> ;)
14:19:31 <jip> doesn't MSN actively try to lock out unofficial clients?
14:19:40 <bolrod> no?
14:20:08 <bolrod> wel.... they did make their msn clients use secure connection right?
14:20:32 <bolrod> maybe I'm wrong
14:20:41 <bolrod> iChat doesn't support msn anymore 
14:20:43 <bolrod> thats for sure
14:21:17 <bolrod> I don't really care for msn though
14:21:21 <xerox> iChat is way cool anyway.  Edict: everybody should use AIM so that I can use iChat AV.
14:21:29 <bolrod> the only reason I have it is because other people use only msn
14:21:48 <bolrod> if they would all be on irc
14:21:52 <bolrod> I'd not use msn
14:22:30 <bolrod> and irssi pwns every irc client ofcourse, because you can run it inside screen
14:22:38 <bolrod> (no  bitchX is not better )  
14:22:39 <bolrod> ;)
14:32:48 <vitriol_> is there an accepted way for wrapping OO libraries in ocaml?
14:33:02 * davidhouse looks at the channel name
14:33:08 <vitriol_> sorry haskell
14:33:14 <davidhouse> heh :)
14:33:41 <norpan> what does wrapping an OO library in ocaml entail?
14:33:53 <vitriol_> well, im just looking at some papers on encoding OO objects in haskell. and there seems to be a few methods
14:34:36 <norpan> oh, you actually mean haskell
14:35:09 <norpan> have a look at gtk2hs
14:35:11 <vitriol_> yes :) i imagine it's easier to faithfully wrap an OO library
14:35:15 <vitriol_> in ocaml
14:35:20 <vitriol_> ah, that's a good idea
14:37:44 <musasabi> well one can do a faithfull mapping in Haskell.
14:37:52 <musasabi> usually it is just not worth it.
14:37:54 <davidhouse> is there an easy way to remove an element in a list, named by index?
14:38:03 <vitriol_> how ?
14:38:19 <musasabi> davidhouse: take + drop 
14:38:24 <davidhouse> @hoogle [a] -> Int -> [a]
14:38:25 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
14:38:25 <lambdabot> Prelude.take :: Int -> [a] -> [a]
14:38:25 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
14:38:31 <davidhouse> musasabi: eww.
14:38:58 <musasabi> vitriol_: e.g. via the OOHaskell way, or using an another encoding of the OO type system in Haskell.
14:39:14 <musasabi> vitriol_: depends on what the library does.
14:39:18 <vitriol_> musasabi, ah, ok. I've been looking at OOHaskell. it's quite interesting
14:40:05 <xerox> @type \n -> (uncurry (++)) . (take (n-1) (Control.Arrow.&&&) drop n)
14:40:06 <lambdabot>   Couldn't match `[a]' against `t -> t1 -> t2'
14:40:06 <lambdabot>   Expected type: [a]
14:41:08 <musasabi> davidhouse: it is quite easy to write a "dropNth :: Int -> [a] -> [a]"
14:41:23 <davidhouse> yeah.
14:41:27 <musasabi> davidhouse: but you want to do it yourself to control what to do in error conditions.
14:41:43 <davidhouse> @pl \n xs -> take n xs ++ drop (n+1) xs
14:41:43 <lambdabot> ap (ap . ((++) .) . take) (drop . (1 +))
14:41:43 <xerox> > (\n -> ((take (n-1)) &&& (drop n)) >>> (uncurry (++))) 3 [1..10]
14:41:44 <lambdabot> [1,2,4,5,6,7,8,9,10]
14:42:13 * davidhouse suddenly realises why arrows place so much emphasis on pairs: uncurry.
14:42:29 <davidhouse> xerox, indices are 0-based
14:42:53 <xerox> s/take (n-1)/take n/  s/drop n/drop (n+1)/
14:42:56 <davidhouse> > (\n -> take n &&& drop (n + 1)) >>> (uncurry (++))) 3 [1..10]
14:42:57 <lambdabot>  parse error on input `)'
14:43:09 <xerox> You have to enclose them in parens.
14:43:12 <davidhouse> > (\n -> take n &&& drop (n + 1) >>> (uncurry (++)) 3 [1..10]
14:43:12 <lambdabot>  parse error on input `}'
14:43:17 <davidhouse> > (\n -> take n &&& drop (n + 1) >>> uncurry (++)) 3 [1..10]
14:43:18 <lambdabot> [1,2,3,5,6,7,8,9,10]
14:43:24 <xerox> Right.
14:45:50 <davidhouse> how are records used in pattern matching?
14:46:02 <davidhouse> in terms of the syntax
14:46:03 <xerox> Positionally.
14:46:37 <xerox> Just match on the position as if it was a standard ADT.
14:46:46 <davidhouse> ah.
14:46:48 <davidhouse> sucky.
14:47:04 <xerox> We're talking about records :-)
14:53:13 <genneth> arrghh... I've forgotten how to get HaXML installed again...
14:53:18 <genneth> there was a trick to it
14:53:22 <genneth> but i can't remember now
14:54:01 <monochrom> data MyRec = MyRec {x::Int, y::String, z::Double}
14:54:34 <monochrom> myfunction (MyRec {x=a, z=c}) = (a,c)
14:54:42 <monochrom> That is for davidhouse.
14:54:55 <davidhouse> does that work?
14:54:59 <monochrom> Yes!
14:55:02 <davidhouse> nice! :)
14:55:17 <xerox> Wow.
14:55:32 <vincenz> ?
14:55:33 <vincenz> what
14:55:36 <vincenz> just record matching
14:56:08 <xerox> I always thought you were supposed to do something like f r = r { x = .., z = ..}.
14:56:31 <davidhouse> @hoogle uncurry
14:56:31 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
14:56:52 <davidhouse> is there an uncurry3 :: (a -> b -> c -> d) -> (a,b,c) -> d?
14:58:26 <monochrom> HaXML requires HTTP.
14:59:03 <Lemmih> @djinn (a -> b -> c -> d) -> (a,b,c) -> d
14:59:04 <lambdabot> f a (b, c, d) = a b c d
14:59:37 <davidhouse> in other words, "no".
15:00:02 <davidhouse> i wish djinn would use x, y, z for values
15:00:17 <monochrom> genneth: what problem did you encounter when installing HaXML?
15:00:36 <genneth> src/Text/PrettyPrint/HughesPJ.hs:1:0:
15:00:36 <genneth>     conflict: module `Text.PrettyPrint.HughesPJ'
15:00:36 <genneth>     belongs to the current program/library and also to package base-1.0
15:01:16 <genneth> I've installed in before somewhere else, and the same problem came up, but I can't remember for the life of me how to get around it...
15:01:37 <monochrom> I use ghc 6.4.1 and I did not encounter that.
15:02:18 <monochrom> and hxt 5.4
15:03:35 <genneth> hmmm; it seems that the gentoo ebuild for it just cleans out that namespace...
15:03:46 <genneth> that was probably what I did before :p
15:04:05 <monochrom> oops, hxt != haxml  Sorry
15:04:26 <Taral> genneth: remove that file
15:05:25 <Taral> @where hxt
15:05:26 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
15:05:29 <Taral> ah, that'
15:05:32 <Taral> 's what that is.
15:17:46 <ihope> s/.*// <- muahaha
15:20:04 <Lemmih> ihope: The last statement must be an expression.
15:20:17 <ihope> You mean // isn't one?
15:21:10 <Lemmih> > do laughter <- "muahaha"
15:21:11 <lambdabot>  The last statement in a 'do' construct must be an expression
15:22:08 <Lemmih> dons: ping.
15:22:48 <monochrom> hahahaa
15:23:38 <ihope> > do laughter <- "muahaha"; emoticon <- ">:-D"; [laughter, emoticon]
15:23:39 <lambdabot> "m>m:m-mDu>u:u-uDa>a:a-aDh>h:h-hDa>a:a-aDh>h:h-hDa>a:a-aD"
15:23:41 <xerox> Yes that was nice (-:
15:24:14 <ihope> Gasp, this IRC client substitutes emoticons and such...
15:24:31 * monochrom explodes
15:25:07 <ihope> 04And it supports mIRC colors too.
15:25:17 * ihope runs away
15:27:24 <bolrod> omg!
15:27:26 <bolrod> thats scary
15:27:33 <bolrod> 4 colors?!?!
15:27:38 <bolrod> 5 *hides*
15:28:34 <ihope> 12Stop that.
15:29:05 <Lemmih> No bold blinking?
15:29:17 <ihope> Is this good enough?
15:30:10 <ihope> !lastgame ihope
15:30:34 <ihope> ...right.
15:31:28 <bolrod> I don't see colors
15:31:43 <bolrod> irssi has the wonderful uption of removing any fancy text thingies
15:31:43 <bolrod> :
15:31:44 <bolrod> :p
15:32:10 <bolrod> blinking text must be the most annoying thing invented ever
15:32:11 <bolrod> :)
15:32:37 <monochrom> yes
15:32:43 <bolrod> probably some old evil hackers that wanted to taint the world with irritation
15:33:23 <mauke> hmm
15:33:53 <bolrod> yeah.. when did you ever go like.  "WOW MAN!! blinking text is cooool"
15:33:54 <bolrod> ;)
15:34:17 <xerox> > do do do "lol" -> l; "lol" -> o; [l,o,l]; -> lol; [lol,lol,lol]
15:34:17 <lambdabot> "llllllllllllooollllllllllllooolllooooooooooooooolllooollllllllllllooollllllllllll"
15:34:23 * xerox hides
15:34:31 <ihope> From Wikipedia: The inventor of the blink tag, Lou Montulli, has said repeatedly in interviews that he considers "the blink tag to be the worst thing I've ever done for the Internet".
15:34:32 <bolrod> how the hell does that work ;p
15:34:49 <bolrod> haha
15:34:50 <bolrod> see!
15:35:15 <mauke> a2/test
15:35:26 <ihope> > do r <- "rofl"; o <- "rofl"; f <- "rofl"; l <- "rofl"; [r,o,f,l]
15:35:27 <lambdabot> "rrrrrrrorrrfrrrlrrorrroorrofrrolrrfrrrforrffrrflrrlrrrlorrlfrrllrorrrorororfrorlroorroooroofroolrofrroforoffroflrolrrolorolfrollrfrrrfrorfrfrfrlrforrfoorfofrfolrffrrfforfffrfflrflrrflorflfrfllrlrrrlr
15:35:27 <lambdabot> orlrfrlrlrlorrloorlofrlolrlfrrlforlffrlflrllrrllorllfrlllorrrorroorrforrlorororoooroforolorfrorfoorfforflorlrorloorlforlloorroorooorfoorlooorooooooofoooloofroofoooffoofloolroolooolfoollofrrofroofrfofr
15:35:27 <lambdabot> loforofooofofofoloffroffoofffoffloflroflooflfofllolrrolroolrfolrlolorolooolofolololfrolfoolffolflollrolloollfolllfrrrfrrofrrffrrlfrorfroofroffrolfrfrfrfofrfffrflfrlrfrlofrlffrllforrforoforfforlfoorfoo
15:35:27 <lambdabot> ofooffoolfofrfofofofffoflfolrfolofolffollffrrffroffrfffrlfforffooffofffolfffrfffoffffffflfflrfflofflfffllflrrflroflrfflrlflorflooflofflolflfrflfoflffflflfllrfllofllffllllrrrlrrolrrflrrllrorlroolroflro
15:35:30 <lambdabot> llrfrlrfolrfflrfllrlrlrlolrlflrlllorrlorolorflorlloorloooloofloollofrlofolofflofllolrlolololflolllfrrlfrolfrflfrllforlfoolfoflfollffrlffolffflffllflrlflolflflfllllrrllrollrfllrlllorlloollofllolllfrllf
15:35:33 <lambdabot> ollffllfllllrlllolllfllll"
15:35:33 <ihope> Noo...
15:35:36 <xerox> Okay...
15:35:48 <ihope> So when was @more plonked out?
15:36:17 <xerox> (I find it funny nevertheless :-P)
15:36:32 <mauke> why doesn't my ablinkg work? :(
15:37:23 <bolrod> because you are cured 
15:37:26 <bolrod> and immune?
15:37:55 <mauke> I think it's my terminal and/or screen
15:38:51 <Rev17|lappy> what would be the best way to reverse the order of the bits in a number (like an Int)? shift won't really do this
15:39:08 <xerox> @hoogle shift
15:39:09 <lambdabot> Data.Bits.shift :: Bits a => a -> Int -> a
15:39:09 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
15:39:09 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
15:39:13 <xerox> Why wouldn't it?
15:39:34 <bolrod> dang.. how does that  do  r<- "rofl" ; o <- "rofl"  work?
15:39:44 <bolrod> it first assigns each first char.. 
15:39:46 <bolrod> then the 2nd?
15:40:20 <newsham> its in the list monad.  its not an "assign".
15:40:24 <Rev17|lappy> xerox: if I had 1011 and shifted it by two, wouldn't I have 0111 (err actually rotate)
15:40:30 <mauke> [ [r,o,f,l] | r <- "rofl", o <- "rofl", etc ]
15:40:37 <newsham> it takes values from the list "rofl" and then >>= into taking values from "rofl"
15:40:47 <Rev17|lappy> hmm, wait I could just shift and shift the other way
15:40:54 <Rev17|lappy> xerox: thanks I've been dumb
15:41:00 <xerox> @hoogle rotate
15:41:00 <lambdabot> Data.Bits.rotate :: Bits a => a -> Int -> a
15:41:00 <lambdabot> Data.Bits.rotateL :: Bits a => a -> Int -> a
15:41:00 <lambdabot> Data.Bits.rotateR :: Bits a => a -> Int -> a
15:41:47 <newsham> in list monad   x <- l     is like   for each x in l { ... rest of do ... }
15:42:29 <bolrod> aha...
15:42:42 <bolrod> confusing
15:42:59 <newsham> > do { x <- "ab"; y <- [1,2]; return (x,y) }
15:43:00 <lambdabot> [('a',1),('a',2),('b',1),('b',2)]
15:43:26 <newsham> (return x = [x]  in list monad)
15:43:40 <bolrod> ;o
15:43:42 <xerox> ((>>=) = concatMap in the List Monad)
15:43:56 <newsham> and of course the do is like a bunch of >>='s
15:44:09 <ihope> And >>'s.
15:44:20 <bolrod> no
15:44:24 <bolrod> >>'s are >>='s
15:44:25 <bolrod> ;)
15:44:42 <ihope> But...
15:44:44 <ihope> >>
15:44:44 <bolrod> that I know :)
15:44:45 <xerox> http://www.angryflower.com/itsits.gif
15:44:46 <xerox> :-P
15:44:50 <ihope> 's are >>'s!
15:44:58 <bolrod> but they are alos >>='s
15:45:01 <bolrod> also
15:45:08 <bolrod> just special >>='s
15:45:13 <ihope> And they're also const's!
15:45:15 <vincenz> xerox: lol
15:45:16 <xerox> They're just (>>=) in this specific case.
15:45:24 <newsham> bob needs a guide to realtime chat relaxation of grammatical rules
15:45:31 <ihope> @pl \x y -> x >>= const y
15:45:31 <lambdabot> (. const) . (>>=)
15:45:36 <ihope> There.
15:45:44 <vincenz> @pl \x y -> y x
15:45:45 <lambdabot> flip id
15:45:49 <vincenz> flip it!
15:45:54 <xerox> (>>) take place once you discard the result of a monadic action during the sequencing.
15:46:01 <bolrod> :)
15:46:17 <bolrod> do doesn't use it right?
15:46:24 <bolrod> only if you explicitly use them yourself
15:46:50 <newsham> (do also has a 'case' in there, but nobody likes to talk about that)
15:47:04 <bolrod> :o
15:47:19 <bolrod> writing do with >> and >>= can be pretty complex in some cases I guess
15:47:44 <newsham> bolrod: not that much more complicated than using do.  its just not as pretty.
15:48:33 <bolrod> > do { let {x = "xxx"} ; y<-x; let {z = y} ; q < return (z++x) ; [q]
15:48:34 <lambdabot>  parse error on input `in'
15:48:38 <ihope> I wouldn't say do doesn't use >>. That's like saying ($ foo) doesn't use flip.
15:48:48 <bolrod> > do { let {x = "xxx"} ; y<-x; let {z = y} ; q < return (z++x) ; [q]
15:48:49 <lambdabot>  parse error on input `in'
15:48:49 <bolrod> > do { let {x = "xxx"} ; y<-x; let {z = y} ; q < return (z++x) ; [q]}
15:48:50 <lambdabot>  Not in scope: `q'
15:48:53 <newsham> > "ab" >>= (\x -> [1,2] >>= (\y -> return (x,y) ) )
15:48:53 <lambdabot> [('a',1),('a',2),('b',1),('b',2)]
15:48:56 <xerox> do { foo <- bar; quux; return foo }  translates to  bar >>= \foo -> quux >> return foo.
15:48:59 <bolrod> > do { let {x = "xxx"} ; y<-x; let {z = y} ; q <- return (z++x) ; [q]}
15:48:59 <lambdabot> Couldn't match `[a]' against `Char'
15:49:05 <bolrod> -.-
15:49:16 <bolrod> > do { let {x = "xxx"} ; y<-x; let {z = y} ; q <- return (z++x) ; [q]::Char }
15:49:16 <lambdabot> Couldn't match `[a]' against `Char'
15:49:20 <bolrod> what about that then !
15:49:22 <bolrod> l;p
15:49:31 <bolrod> if you use alot of let
15:49:38 <bolrod> how would you put that in a non do notation?
15:49:54 <ihope> @pl \bar quux -> bar >>= \foo -> quux >> return foo
15:49:54 <lambdabot> (. ((. return) . (>>))) . (>>=)
15:49:57 <ihope> Ow ow ow.
15:50:18 <ihope> @type \bar quux -> bar >>= \foo -> quux >> return foo
15:50:19 <lambdabot> forall a
15:50:19 <lambdabot>                     a1
15:50:19 <lambdabot>                     (m :: * -> *).
15:50:19 <lambdabot>                  (Monad m) =>
15:50:19 <lambdabot>                  m a -> m a1 -> m a
15:50:33 <bolrod> oh k...................
15:50:35 <xerox> bolrod: let under 'do' has a special meaning.
15:50:39 <newsham> let x = "xxx" in ...   ?
15:50:42 <bolrod> no
15:50:44 <bolrod> let in do
15:51:07 <Cale> > do x <- [1..10]; let y = 10 * x; [x,y]
15:51:08 <lambdabot>  parse error (possibly incorrect indentation)
15:51:15 <Cale> hmm
15:51:19 <xerox> {} ?
15:51:24 <ihope> > do
15:51:24 <bolrod> > do x <- [1..10]; let y = 10 * x; [x,y]
15:51:24 <lambdabot>  Empty 'do' construct
15:51:24 <lambdabot>  parse error (possibly incorrect indentation)
15:51:30 <bolrod> > do x <- [1..10]; let {y = 10 * x}; [x,y]
15:51:31 <lambdabot> [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100]
15:51:35 <xerox> (-:
15:51:36 <bolrod> that yes
15:51:51 <bolrod> so how does that translate 
15:51:54 <Cale> right
15:51:54 <bolrod> :]
15:51:57 <ihope> > let in do "foo" where
15:51:58 <lambdabot> "foo"
15:52:06 <newsham> > [1..5] >>= (\x -> let y = 10 * x in return (x,y) )
15:52:07 <lambdabot> [(1,10),(2,20),(3,30),(4,40),(5,50)]
15:52:12 <xerox> [1..10] >>= \x -> return (10 * x) >>= \y -> [x,y]  ?
15:52:21 <xerox> > [1..10] >>= \x -> return (10 * x) >>= \y -> [x,y] 
15:52:22 <lambdabot> [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100]
15:52:29 <Cale> do let {bindings}; stmts = let {bindings} in do stmts
15:52:32 <bolrod> :o
15:52:36 <bolrod> ahyeah
15:52:42 <newsham> no magic voodoo
15:52:58 <xerox> One of the laws is (>>=) . return = id tight?
15:53:02 <ihope> @pl do foo <- "foo"; [foo]
15:53:03 <lambdabot> (line 1, column 16):
15:53:03 <lambdabot> unexpected ";"
15:53:03 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:53:10 <ihope> @pl do {foo <- "foo"; [foo]}
15:53:10 <lambdabot> (line 1, column 4):
15:53:10 <lambdabot> unexpected "{"
15:53:10 <lambdabot> expecting variable, "(", operator or end of input
15:53:11 <Cale> xerox: yes
15:53:14 <xerox> Good, good.
15:53:22 <xerox> Hence that is a proper translation.
15:53:37 <xerox> Woops, I wrote 'tight' instead of 'right'.
15:53:51 <bolrod> aha..
15:53:54 <bolrod> and you are on qwerty?
15:53:59 <bolrod> ;)
15:53:59 <xerox> Tight.
15:54:13 <bolrod> otherwise it would be a weird misspelling probably
15:54:15 <bolrod> ;)
15:55:03 <bolrod> =.=
15:56:51 <ihope> TWO rings!
15:57:12 <ihope> Post the rest of the level... where's the @?
15:58:16 <bolrod> ?
15:59:40 <ihope> Isn't that part of a NetHack level?
16:01:09 <ptolomy> waah. Someone on reddit said that a let statement in haskell is "like a #define", and it made me sad.
16:01:30 <xerox> Nice you got here to tell us.
16:01:50 <ihope> define: unknown extended command.
16:02:27 <palomer> the closest thing to let, in my opinion, is declarations
16:02:54 <jip> palomer: i can see the similarity with #define
16:03:09 <palomer> so can I
16:03:16 <jip> the only major difference is that you can do recursion with #define
16:03:26 <monochrom> Every definition in haskell is like a #define.
16:03:41 <jip> yeah, let is closer to #define then it is to c functions :)
16:04:22 <monochrom> You can evenly formally give Haskell (or any lazy/callbyname language) a rewrite semantics, and therefore it really looks like a better #define than #define.
16:05:11 <monochrom> Indeed Hudak's SOE use rewriting to explain Haskell semantics.
16:05:23 <palomer> rewriting==substitution?
16:05:39 <monochrom> I guess one could say that.
16:06:00 <Rev17|lappy> what is the name of the syntax that looks and behaves like o'caml's records?  I know I saw it somewhere in a haskell tutorial, but I can't seem to find it now
16:06:29 <bolrod> the closest thing to #define is find and replace
16:06:32 <bolrod> >_>!
16:06:32 <monochrom> record, labelled fields
16:06:49 <Rev17|lappy> monochrom: thanks, that's it :)
16:07:46 <bolrod> you can use #define in haskell right?.. ghc --make uses preprocessor right? ^.0
16:07:47 <bolrod> lets see
16:08:32 <monochrom> There is a way to tell ghc to call the C preprocessor.  I don't know how.
16:08:46 <monochrom> probably "ghc -cpp ..."
16:08:47 <xerox> -cpp
16:09:59 <bolrod> #define test  function
16:09:59 <bolrod> module Main where
16:09:59 <bolrod> main = test
16:09:59 <bolrod> function = putStrLn "test"
16:10:08 <bolrod> this works fine with -cpp
16:10:11 <bolrod> :)
16:10:23 <monochrom> You are devious.
16:10:25 <bolrod> it does output test
16:10:32 <bolrod> cpp doesn't check in strings?
16:10:38 <monochrom> No.
16:10:40 <bolrod> ic
16:12:00 <bolrod> I don't think I'll get alot of happy faces with using #define in my haskell assignment ;)
16:12:16 <bolrod> modularize!
16:12:18 <monochrom> You don't need #define
16:12:23 <bolrod> indeed
16:12:26 <bolrod> and its confusing
16:14:06 <monochrom> One use of cpp is when your code has to be different for different compilers.
16:14:55 <monochrom> "if ghc then import Text.ParserCombinators.Parsec else import Parsec" for example.
16:14:56 <palomer> or when it has to run in a reasonable amount of time
16:15:09 <palomer> or when you actually want to write something useful
16:15:17 <bolrod> !?
16:15:20 <palomer> !!
16:15:35 <xerox> 
16:15:41 <ihope> !?!?!!!
16:15:43 <Cale> palomer is just being inflammatory again :)
16:15:43 <bolrod> run in reasonable amount of time?!
16:15:48 <bolrod> :P
16:15:49 <monochrom> I think palomer is just going hyperbole or venting some steam.
16:15:59 <bolrod> WHEEEEEE
16:16:01 <bolrod> :x
16:16:07 <palomer> haven't you guys learned to ignore me yet?
16:16:17 * xerox pats palomer 
16:16:21 <bolrod> I guess he didn't
16:16:23 <bolrod> :)
16:16:23 <monochrom> No. But I have learned to find humour in you.
16:16:36 <palomer> so half my job is done
16:16:43 <bolrod> wow
16:16:47 <bolrod> what was the whole job?
16:17:03 <bolrod> canadians sure are weird people though........
16:17:05 <bolrod> :x
16:17:12 <monochrom> I am not weird.
16:17:18 <bolrod> you are not?
16:17:19 <bolrod> ;)
16:17:22 <palomer> you'll have to follow the thread of conversation, sir; we can't spend all our time keeping you up to date
16:17:27 <monochrom> The difference is I am in Toronto and he's in Montreal.
16:18:48 <Rev17|lappy> so are labeled fields not supported in ghc or something? this: data Foobar = Foo {Tra :: Int,La :: Int} | Mooo generates a syntax error
16:19:13 <monochrom> use tra instead of Tra, la instead of La
16:19:34 <Rev17|lappy> monochrom: oh right, forgot about the case sensitivity
16:20:22 <bolrod> monochrom: that must be it
16:20:53 <monochrom> tralalalala, tralalalala, tralalala-moo-foo-bar
16:20:59 <bolrod> mofo
16:21:01 <bolrod> :)
16:22:29 <bolrod> http://www.plusminus.ru/flashbag.html   O_o
16:22:32 <bolrod> lawl!
16:38:08 <jip> gtk2hs has support for ComboBox, right?
16:43:43 * SamB wants a new C compiler
16:46:15 <wilx> A new C compiler?
16:46:48 <Lemmih> jip: Apparently so: http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-MenuComboToolbar-ComboBox.html
16:47:32 <SamB> GCC thinks it is a C++ compiler, and is slow
16:48:09 <wilx> Heh, thinks? 
16:48:20 <jip> Lemmih: hm.... doh, i thought that was a special menu combobox, but that's the one, thanks!
16:48:23 <wilx> You can use Intel's compiler.
16:49:10 <SamB> intels compiler compiles faster?
16:50:04 <wilx> Dunno, possibly.
16:50:13 <wilx> Also you should try precompiled headers.
16:51:26 <SamB> they tell me you can only use one at a time, and honestly, I think the main problem is it is trying the wrong sorts of optimizations on GHC's output...
16:52:01 <jip> SamB, wilx: hey did you guys see my haskell devlog?
16:52:14 <SamB> no
16:52:18 * SamB has been out of it
16:52:28 <wilx> Neither did I.
16:52:55 <jip> SamB, wilx: http://www.mutantlemon.com/omegagb/devlog
16:53:27 <SamB> hmm, maybe has an excuse on this last module... mangler took a while too...
16:55:54 <doublec> jip, nice job with the gamboy emulator. I maintain a nintendo ds emulator in C. I'd much prefer to have it in a better language.
16:57:31 <SamB> gameboy, huh?
16:58:12 <jip> doublec: whoah, that's cool. is this a commercial emulator?
16:58:13 <doublec> The devlog just posted points to a gameboy emulator written in haskell.
16:58:25 <SamB> one thing that can be said for gameboy emulation is that you don't have to either write bindings to a UI library or mess with nasty textual things...
16:58:46 * SamB is referring to his work-in-progress Z-machine interpreter
16:58:52 <doublec> No, it's an open source one I maintain after the original programmer stopped working on it: http://www.double.co.nz/nintendo_ds/dsemu.html
16:59:22 <doublec> I wrote an 8080 emulator in Factor to emulate space invaders. The gameboy uses a similar chip doesn't it? Z80 or something?
16:59:51 <jip> SamB: well, i found it useful to get a GUI debugger working as soon as possible in order to help me verify behaviour
17:00:15 <SamB> its similar to a Z80, from what I've heard, but has a unique instruction set
17:00:20 <SamB> afiak
17:00:21 <jip> SamB: but the core cpu emulation was easily done only with the help of ghci :)
17:00:32 <SamB> er, switch the a and the i
17:01:04 <doublec> I think the Z80 has more instructions than the 8080 and few extra flags too (half carry, etc)
17:01:59 <jip> gameboy cpu is a bit simpler then z80 and 8080, has less flags. but gameboy has all this graphics and sound hardware that needs to be emulated :)
17:02:16 <doublec> true
17:02:57 <SamB> jip: well, I'm sure your GUI is simpler than what I'd need to write to implement Z-machine IO properly ;-).
17:03:01 <doublec> Not to mention using a pure functional language probably makes the implementation slightly more difficult. Or at least different.
17:03:44 <SamB> jip: and yes, I'm sure the graphics and sound more than make up for the GUI
17:04:02 <jip> SamB: probably. but the gui is pretty much isolated from the emulation. i plan to have multiple frontends to the emulator: gtk, SDL, and ncurses/ascii-art :D
17:04:37 <jip> doublec: read the devlog to hear my thoughts about this =]
17:05:07 <doublec> jip, will do. I'm keen to follow it it sounds like a great project.
17:05:09 <SamB> jip: I really liked what nocash for DOS did... it looked like it was doing graphics in textmode, but it must have been faking.
17:06:50 <jip> SamB: it fakes it :)
17:07:44 <SamB> looked at DiffUArray?
17:08:51 <SamB> hmm, is the present tense appropriate? (How are you supposed to run it (with sound)?)
17:08:51 <jip> SamB: sort of
17:09:17 <jip> SamB: the tense changes at random
17:09:38 <SamB> the problem with Arrays was probably laziness
17:09:55 <dons> moin
17:10:51 <SamB> I don't think GHC believes that it can mutate UArrays at will, but it does know it can do something like memcpy and *then* mutate...
17:10:52 <doublec> jip, will the emulator be reversable? Being able to do a reverse-step in the debugger would be pretty neat.
17:11:22 <SamB> doublec: that would give you the leak again...
17:11:28 <jip> doublec: the code architecture allows such a feature
17:11:35 <jip> SamB: not necessarily
17:11:43 <SamB> well, okay, not necessarily
17:12:27 * SamB needs to figure out how to properly store undo states for his 'terp'
17:12:27 <jip> instead of keeping copies of old state around, i can keep a log of the writeMemory calls, logging also the previous value
17:12:51 <SamB> that is about what Diff*Array does
17:12:55 <SamB> only in reverse
17:13:03 <doublec> How much memory does the GB have?
17:13:09 <SamB> or something like that
17:13:37 <jip> doublec: it has 8KB internal ram, but it also has video ram and a bunch of IO registers
17:13:52 <jip> doublec: and game carts can contain quite a bit of ram also
17:14:21 <doublec> Probably similar to the GBA and DS. Memory mapped IO registers and SRAM on the cartridges.
17:15:39 <jip> yeah, btw how do you emulate the nds touchpad?
17:16:28 <doublec> I record the users mouse presses and drags. I emulate the serial-io interface to the touchpad returning the most recent coordinates when the program queries the IO registers.
17:17:23 <jip> cool, but it will probably suck playing nds games with a mouse :P
17:17:26 <SamB> hmm, that stuff about Haskell being the best imperative language is quite true... no other language gives imperatives first-class status, as far as I'm aware
17:18:02 <doublec> jip, yes it does suck with some games. It mostly works ok though.
17:18:04 <dons> imperatives?
17:18:08 <SamB> definately not in a generic way...
17:18:15 <dons> or was taht a joke i missed?
17:18:31 <SamB> joke?
17:18:43 <Lemmih> dons: Hi.
17:18:58 <SamB> an imperative is a thing to be done. no other language that I know of lets you pass them around or make up your own kind with such ease.
17:19:01 <dons> oh, too early. no coffee. i thought there might have been some weird joke about things being imperative.
17:19:11 <dons> right. higher order functions rule!
17:19:18 <dons> first class functions forever!
17:19:21 <dons> morning Lemmih
17:20:07 <Lemmih> dons: I managed to link an object file against GC'ed closures.
17:20:17 <SamB> huh?
17:23:14 <Lemmih> (closures that aren't pinned)
17:24:35 <dons> Lemmih, excellent, how'd you do it?
17:25:18 <SamB> good job on deciding to do gameboy, NES is a job for lower-level languages, I think...
17:27:05 <Pegazus> how to make a kind of "assert" in haskell?
17:28:01 <SamB> assert x = if not x then fail "assertion failed" else return ()
17:28:15 <Lemmih> dons: I keep a list of pointers to the address table that points to the wanted closures and mark them as roots in the GC.
17:28:18 <Pegazus> thanks
17:28:23 <Lemmih> Pegazus: Seen Control.Exception.assert?
17:28:55 <SamB> that is a monadic version, and you probably would want a way to tell which assertion failed, but it sorta works
17:29:58 <dons> Lemmih, right. sounds good.
17:31:53 <Pegazus> what does assert returns?
17:32:03 <Pegazus> or fail
17:32:03 <Pegazus> i mean
17:32:20 <SamB> fail doesn't necessarily return ;-)
17:32:37 <Pegazus> yeah but *** Term           : fail "La funcion esta mal definida: " ++ show PrimRec
17:32:37 <Pegazus> *** Type           : [Char]
17:32:37 <Pegazus> *** Does not match : Int
17:32:38 <Pegazus> :/
17:32:46 <SamB> it certainly won't return a value
17:32:49 <Pegazus> i need it to "return" an int to it will compile
17:32:59 <SamB> @type fail;
17:33:00 <lambdabot> parse error on input `;'
17:33:01 <Pegazus> so it will compile
17:33:02 <SamB> @type fail
17:33:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
17:47:41 <jip> how do you do a lambda function with pattern guards?
17:47:51 <SamB> why?
17:48:08 <jip> just curious
17:48:08 <SamB> can't you do a non-lambda function?
17:48:10 <xerox> \ .. | .. -> .. | .. -> ..
17:48:59 <jip> > (\x | x < 0 = -1 | x > 0 = 1 | x == 0 = 0) 5
17:48:59 <lambdabot>  parse error on input `|'
17:49:14 <jip> > (\x | x < 0 = -1) (-3)
17:49:14 <lambdabot>  parse error on input `|'
17:49:25 <jip> > (\x | x < 0 -> -1) (-3)
17:49:25 <lambdabot>  parse error on input `|'
17:49:43 <SamB> you realize -fglasgow-exts is off?
17:50:03 <jip> seems like this would be a part of haskell98
17:50:47 <SamB> atose are just regular guards, afiact. except for the part where I don't remember lambda being that complicated.
17:51:22 <SamB> s/atose/those/
17:52:39 <machack666> is there a library for treating a stream of bytes as an arbitrary sequence of packed n-bit words for any n?
17:53:10 <dons> hmm. no such library. but there's some almost-there code
17:53:21 <dons> you could consider fps and NewBinary, perhaps
17:53:24 <machack666> in darcs anywhere?
17:53:28 <machack666> I was wondering if fps
17:53:33 <dons> the former for the stream of words, the latter for the packing of bits
17:53:44 <dons> also Data.Bits would probably be enough, combiend with fps
17:58:14 <SamB> what is the purpose of this?
17:58:28 <SamB> 'cause most things documented like that actually aren't
18:06:46 <machack666> parsing SFW files, where some fields are variably determined by a bit field specifying size.
18:06:54 <machack666> s/SFW/SWF/
18:07:44 <SamB> what does this mean?
18:07:45 <SamB> tE
18:07:45 <SamB>  ptSimplify
18:07:45 <SamB>    tcase-application: 4
18:07:45 <SamB>    tcase-atomic-unboxed: 78 
18:07:48 <SamB>    tcase-default-case: 14 0 
18:07:51 <SamB>    tcase-improve-defaul t 
18:07:55 <SamB>     t[Prelude.(,)]: 2
18:08:00 <SamB> er.
18:08:02 <SamB> ack!
18:08:04 <SamB> my paste is broken.
18:08:11 <SamB> help!
18:08:14 <adu> is that unicode?
18:08:26 <SamB> I don't think so, though I meant it to be.
18:08:37 <adu> IRC doesn't really "do" unicode
18:10:17 <SamB> okay, how I just ask if anyone understands the jhc's "Initial Pass Stats"
18:10:34 <SamB> s/how/how about/
18:10:49 <jip> > 9 `div` 4
18:10:50 <lambdabot> 2
18:10:50 <machack666> but I'm visualizing something like asNBits :: Int -> [a] -> [b]  where a is some fixed-size storage type and b is the type that you want to manipulate (n-bit sized Ints, say)
18:11:34 <SamB> machack666: wouldn't be *too* hard to write, though you have to consider endianness
18:12:06 <machack666> is there a standard way of determining that from ghc?
18:12:17 <SamB> no no
18:12:30 <SamB> I mean, you'd have to know which/what endianness to use
18:12:58 <SamB> which has not a whole lot to do with system endiannes in this case, from what I can see
18:13:05 <dons> ignoring endianess, (which can be handled with type classes) you'd probably need some WordN types and a class for defining the bijection from your bytes to you type and back
18:13:10 <machack666> I believe the format specifies in this case, but in general I see the point
18:13:28 <SamB> well, yes.
18:13:47 <dons> i.e. an extension of the Binary class in NewBinary, with more WordN types and maybe an fps frontend for efficiently getting a stream of Word8s
18:13:48 <machack666> I was wondering if you could use TH to generate instances for WordNN
18:13:58 <dons> or DrIFT. it could be done, yes.
18:14:25 <dons> i suggest having a look at NewBinary.
18:14:31 <SamB> my point is that a general function would need to be able to handle both, and that a format/protocol specific function would have to use whichever endiannes is specified...
18:14:47 <SamB> you could even generate WordNN with TH...
18:15:02 <dons> machack666: here's the basic Binary class http://www.cse.unsw.edu.au/~dons/code/hmp3/Binary.hs
18:15:27 <dons> there's more complicated/less efficent versions out there( with more instancse, for example)
18:15:30 <SamB> though there are some issues related to type classes and instances with TH...
18:15:34 <machack666> dons: this is NewBinary?
18:15:46 <dons> a child of NewBinary, tweaked for perforamnce
18:16:00 <machack666> cool.
18:16:01 <dons> otherwise, look at the Data structures page on haskell.org's library page
18:16:17 <dons> for the 4 or 20 other binary libs out there
18:16:54 <dons> if you get an idea how the Binary instances work, you can probably generalise from there to WordN sizes and paramaterised endiianess
18:17:03 <dons> i'll find you some endian-handling code sjw wrote.
18:17:49 <dons> he's asleep. i'll get back to you with his ELF-object file parser when he wakes up
18:18:07 <dons> ti handles both endianesses, and parse the various byte fields out of ELF files.
18:18:11 <dons> so sort of what you need
18:18:34 <SamB> both sizes of ELF files?
18:19:18 <dons> i'm pretty sure it handles ELF files in 32 and 64 bit forms, and in either endianess. he uses an alpha, so that is a good test
18:19:48 <SamB> does alpha have a 32-bit mode?
18:20:54 <machack666> cool thanks.
18:21:21 <dons> SamB, don't think so.
18:21:26 <dons> i've not heard of one.
18:23:33 <SamB> though I suppose that will never prevent the possibility of a 32-bit memory model
18:25:50 <dons> davidhouse, i move the Zipper code on the wiki into the idioms category
18:29:21 <dons> davidhouse, also, i moved the pages so as not to have CamelCase names. they're now: Zipper and Zipper_monad
18:34:33 <aufrank> hello
18:34:56 * mux likes Parsec
18:35:49 <SamB> most of us do
18:36:11 <SamB> except when we are mad about the lack of ParsecT or somesuch
18:36:22 <mux> I wish it had
18:36:32 <mux> skip :: GenParser tok st a -> GenParser tok st ()
18:36:32 <mux> skip p = p >> return ()
18:36:49 <mux> found it quite useful to just skip one match of a parser
18:37:05 <SamB> patches may be welcome?
18:37:09 <mux> yep
18:37:16 <mux> I'm thinking of other stuff to do
18:37:20 <mux> I intend to send patches
18:37:58 <SamB> many of us would like to see ParsecT, if it isn't too much work ;-)
18:38:09 <jip> holy crap i think it works
18:39:14 <mux> SamB: well it's probably too much work since I'm going to have limited free time and also because it's been maybe 3 weeks that I do haskell
18:39:36 <SamB> heh
18:39:58 <SamB> yeah, I expect if it wasn't too much work for most people to bother with it would be done by now
18:40:12 <mux> that's another good reason :-)
18:40:22 <aufrank> what does the T at the end of ParsecT mean?
18:40:50 <sjanssen_> aufrank: monad transformer
18:40:53 <SamB> aufrank: well, it is a convention to name monad transformers like that
18:41:01 <aufrank> thanks :)
18:41:17 <dons> ah, yes. another convention. like mapM or mapM_ or fold' or foldl or foldr
18:41:31 <Cale> someone wrote a ParsecT?
18:41:41 <SamB> Cale: unfortunately, no
18:41:46 <Cale> oh
18:41:48 <Cale> I see
18:42:27 <SamB> I was just talking about how I'd like too see it :-(
18:42:52 <aufrank> can I ask for suggestions on how to approach a particular problem?
18:43:01 <SamB> I am sad because I despair of its ever being done
18:43:05 <SamB> aufrank: *of course*!
18:43:08 <aufrank> I've had a go at it in a pretty naive way, and realized I need some help thinking it through
18:43:23 <SamB> well, naive is good for a first pass, often
18:43:38 <SamB> as long as it isn't so naive that it couldn't possibly work
18:43:58 <aufrank> so, a definition:  two words are neighbors if they only differ by one character
18:44:15 <aufrank> cat and bat are neighbors, jar and jab are neighbors
18:44:22 <SamB> how do you tell how many characters two words differ by?
18:44:36 <SamB> what about "dog" and "doggy"
18:45:05 <dons> using a levenshtein distance?
18:45:08 <aufrank> in my limited application, all of the words are four characters long
18:45:08 <dons> a la
18:45:12 <dons> ?yow!
18:45:12 <lambdabot> Somewhere in DOWNTOWN BURBANK a prostitute is OVERCOOKING a LAMB
18:45:12 <lambdabot> CHOP!!
18:45:25 <SamB> in that case, aren't jar and jab bad examples ;-P?
18:45:54 <aufrank> ok, pabo and pabi are neighbors ;)
18:46:01 <SamB> heh
18:46:10 <Cale> distance xs ys = length . filter id $ zipWith (/=) xs ys
18:46:26 <dons> ?pl distance xs ys = length . filter id $ zipWith (/=) xs ys
18:46:26 <lambdabot> distance = ((length . filter id) .) . zipWith (/=)
18:46:34 <dons> filter id, eh?
18:47:03 <SamB> dons: yes. it is popular for counting Trues
18:47:32 <dons> ah, of course
18:48:20 <aufrank> given a long list of words, I want to select 8 words such that 4 of the words each have 3 neighbors (not including themselves), and the other 4 each have 1 neighbor
18:49:29 <aufrank> e.g. bako biko bado biku tako tiko tapo tika
18:49:36 <SamB> well, I would suggest doing each part seperately
18:49:51 <SamB> and anyway a word isn't its own neighbor
18:50:19 <SamB> @pl distance xs ys = length . filter id $ zipWith (/=) xs ys
18:50:19 <lambdabot> distance = ((length . filter id) .) . zipWith (/=)
18:51:26 <dons> there's a pure haskell distance using levenshtein's method here: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Util.hs
18:51:58 <dons> closests :: String -> [String] -> (Int,[String])
18:51:59 <dons> closests pat ss =
18:51:59 <dons>     let (m,_) = minimum ls
18:51:59 <dons>     in (m, map snd (filter ((m ==) . fst) ls))
18:52:01 <dons>     where
18:52:04 <dons>         ls = map (\s -> (levenshtein pat s,s)) ss
18:52:13 <dons> ?pl  map snd (filter ((m ==) . fst) ls)
18:52:13 <lambdabot> map snd (filter ((m ==) . fst) ls)
18:55:35 <SamB> > let distance xs ys = length . filter id $ zipWith (/=) xs ys; neighbors xs ys = distance xs ys == 1; l = words "bako biko bado biku tako tiko tapo tika" in [(s, filter (neighbors s) l) for s in l]
18:55:35 <lambdabot>  parse error on input `in'
18:55:49 <sjanssen_> aufrank: so what's your brute force method?  choose eight words and check if they meet the conditions?
18:56:13 <SamB> > let distance xs ys = length . filter id $ zipWith (/=) xs ys; neighbors xs ys = distance xs ys == 1; l = words "bako biko bado biku tako tiko tapo tika" in [(s, filter (neighbors s) l) | s  <- l]
18:56:14 <lambdabot> [("bako",["biko","bado","tako"]),("biko",["bako","biku","tiko"]),("bado",["bako"]),("biku",["biko"]),("tako",["bako","tiko","tapo"]),("tiko",["biko","tako","tika"]),("tapo",["tako"]),("tika",["tiko"]
18:56:14 <lambdabot> )]
18:56:34 <SamB> works better if you remember not to write out "for" and "in" like in Python, doesn't it...
18:56:57 <aufrank> I made an assoc list of each word and its neighbors
18:57:12 <SamB> aufrank: like that one?
18:57:19 <aufrank> yeah
18:57:27 <aufrank> yeah it was (String, [String])
18:57:37 <aufrank> like that :)
18:57:53 <SamB> did you see the words function before?
18:58:17 <aufrank> no, I haven't
18:58:20 <SamB> its handy for stuff like this, saves typing all those commas and quotes ;-)
18:58:21 <sjanssen_> so you've constructed a graph, in adjacency list format
18:58:26 <aufrank> yeah
18:58:40 <sjanssen_> seems you could use some graph theory to solve this smartly
18:58:50 <SamB> how would that help?
18:59:25 <SamB> it seems to me that Prelude.filter would be more use ;-)
19:00:03 <aufrank> now I start with a word, and choose one of its neighbors, and then treat their two neighbor lists as sets and check the intersection to see if they have any shared neighbors
19:00:29 <sjanssen_> SamB: what aufrank wants is a bit more tricky than what you're after, I think
19:00:38 <SamB> oh, oh.
19:00:46 <SamB> the neighbors have to be in the set still...
19:01:59 <aufrank> and then I choose the fourth high density (3-neighbor) word by picking one from the third word's neighbors that isn't a neighbor of the first two words
19:02:14 <aufrank> so I would start with bako and get biko
19:04:05 <aufrank> sorry, I haven't looked at this in a while
19:04:25 <aufrank> I'm reconstructing the set operations in my head
19:06:27 <aufrank> start with bako, choose of its neighbors that aren't neighbors themselves, and then choose a fourth that is a neighbor of the second and third
19:07:12 <khaladan> what's the rationale behind Haskell's syntax? it seems pretty far-out sometimes!
19:08:13 <sjanssen_> khaladan: in which ways?
19:08:22 <mux> ?pl \s -> foldr1 (<|>) (map string s)
19:08:22 <lambdabot> foldr1 (<|>) . map string
19:08:30 * mux hearts haskell
19:08:43 <Korollary> khaladan: It's based on ml's, which was designed for theorem proofs. Thus it's not based on lisp or algol styles.
19:11:00 <Cale> khaladan: It takes a lot of things from mathematics. Things like 'where' and 'let' are common in (less formal) mathematical proofs, guards mimic the notation for piecewise functions, except that the conditions and results were swapped at some point, because for programming it makes the code more readable
19:11:45 <Cale> List comprehension syntax is an almost direct copy of set comprehension syntax from mathematics, with some ascii-ifications, and of course square brackets instead of braces.
19:12:17 <dons> there's also an overall motivation to keep the page as clean as possible
19:12:21 <sjanssen_> aufrank: this problem may be NP Hard
19:12:40 <dons> so lots of shorthand to reduce parenthesis, and ugly syntax blips 
19:12:41 <aufrank> yeah, I started to think so too
19:12:54 <dons> making it nice for the humans to write, but a bit harder for machines to parse
19:13:15 <sjanssen_> it's a little like the clique problem
19:15:47 <Lemmih> Hiya CosmicRay.
19:15:52 <CosmicRay> hey lemmih
19:16:57 <mux> ?pl \s -> foldr1 (<|>) (map (try (string s)))
19:16:58 <lambdabot> foldr1 (<|>) . map . try . string
19:17:04 <sjanssen_> aufrank: definitely NP Hard. (we're covering NP Completeness in my class, so I've got this junk on the brain ATM)
19:17:50 <Lemmih> CosmicRay: There's Google SoC talk in #haskell-overflow
19:18:44 <nuffer> has anyone here managed to get Graphics.UI.SDL to work under windows?
19:19:07 <Lemmih> nuffer: Not to my knowledge.
19:19:14 <xerox> Project!
19:19:32 <nuffer> so the application hanging inexplicably is pretty standard behavior?
19:19:35 <Lemmih> Oh yes!
19:19:51 <nuffer> Oh yes!?
19:20:00 <dons> in fact, we have a name for it: "divergence"
19:20:03 <xerox> He was answering my scream, I think :-)
19:20:09 <dons> we love to know when things diverge
19:20:17 <dons> its one of our favourite games
19:20:32 <sjanssen_> dons: yes, Haskellers love to spank bottoms
19:20:34 <nuffer> bleh, that kind of sucks
19:20:39 <SamB> what? no SDL for windows?
19:20:51 <SamB> how do you write videogames in Haskell with no SDL for windows?
19:21:02 <nuffer> I think OGL works, if I'm not mistaken
19:21:04 <dons> ?remember sjanssen yes, Haskellers love to spank bottoms
19:21:16 <SamB> you have to use WGL directly?
19:21:19 <SamB> yuck!
19:21:38 <nuffer> well I just want to use plain old SDL - 2d functionality's all I need
19:21:42 <dons> Frag runs on windows and doesn't use SDL..
19:21:43 <jip> i'm sure that Lemmih's SDL bindings will work on windows after some tweaking
19:21:57 <nuffer> where would I even start with something like that?
19:22:19 <SamB> nuffer: start by trying to compile the bindings on windows.
19:22:24 <nuffer> they compile
19:22:31 <SamB> next, try to use them
19:22:37 <nuffer> programs hang
19:22:50 <SamB> next, start a debugger
19:22:58 <nuffer> now I'm lost
19:23:10 <SamB> such as GDB
19:23:14 <jip> easier is to scatter putStrLn all over the code to see where it hangs
19:23:31 <mux> ?pl \s -> foldr1 (<|>) foldr1 (<|>) (map try (map string s))
19:23:37 <SamB> maybe even OllyDbg would work
19:23:41 <mux> ?pl \s -> foldr1 (<|>) (map try (map string s))
19:24:04 <SamB> next, rebuild (with symbols this time!)
19:24:25 <palomer> that's pretty evil
19:25:25 <xerox> mux: map a (map b (map c (map ...)))  =  map (a . b . c ...)
19:26:39 <mux> xerox: *nods*
19:26:54 <mux> but at this point I think point-free programming would make it less readable
19:29:42 <nuffer> This GDB was configured as "--host=i686-pc-cygwin --target=arm-agb-elf"..."/cygdrive/i/Documents and Settings/Llama/workspace/SDL/bin/theResult.exe": not in executable format: File format not recognized
19:29:49 <nuffer> gdb doesn't like my executable very much
19:29:56 <mux> anyString :: [String] -> Parser String
19:29:56 <mux> anyString s = foldr1 (<|>) (map try (map string s)) <?> concat (intersperse " or " s)
19:46:28 <jip> what does <<loop>> mean?
19:46:53 <dons> you hit a black hole
19:46:58 <dons> > let f () = f () in f () :: ()
19:47:02 <lambdabot> Terminated
19:47:03 <dons> maybe not
19:47:15 <dons> > let f = f in f :: ()
19:47:16 <lambdabot> Terminated
19:47:21 <dons> ah well.
19:47:30 <dons> its an infitnite loop that is detected by the runtime
19:47:47 <dons> when you enter a closure whose definition you're currently trying to evaluate
19:48:14 <dons> there's a paper on blackhole detection on the runtime systems page of the research papers section of haskell.org
19:48:17 <dons> ?wiki Research_papers
19:48:18 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers
19:49:13 <jip> hm... i'm not sure why this would happen. oh well, i should sleep now
19:49:28 <dons> you;'ve written some recursive code that accidentally calls itself?
19:49:37 <dons> without a base case? 
19:51:28 <jip> not directly
19:52:09 <jip> well i'm out of here, good night haskell!
19:52:49 <hoan> hello everyone, i've trying to install Cabal from the latest darcs on mac os x, and i encounter an error when installing cabal-install. "Chasing modules from: CabalInstall.hs Could not find module `Distribution.Compat.FilePath':  it is hidden (in package Cabal-1.1.4) (imported from CabalInstall.hs)
19:52:49 <hoan>  
19:52:58 <hoan> help is much appreciated
19:53:22 <Korollary> I think sethk just had that problem
19:54:15 <hoan> ok so i'm not alone :)
19:54:57 <hoan> afaict, cabal-1.1.4 *is* installed and in packages.conf
19:55:06 <hoan> could it be that i'm using mac os x?
19:55:19 <dons> sounds like Cabale 1.1.4 is hidden
19:55:28 <dons> maybe it should be unhidden
19:55:31 <hoan> okay
19:55:41 <hoan> umm.. do you unhide it with ghc-pkg?
19:55:43 <hoan> i'm new to this
19:56:45 <hoan> it looks like Cabal-1.1.4 is exposed
19:56:56 <hoan> o dear
19:57:47 <Lemmih> Programs aren't allowed to use Distribution.Compat.FilePath.
19:58:02 <hoan> oh ok
19:58:11 <hoan> so should i just copy in the relevant functions?
19:58:32 <hoan> i'll try..
19:59:19 <Lemmih> There's a separate FilePath package here: http://darcs.haskell.org/~lemmih/FilePath
19:59:33 <sethk> hoan, I did just have that problem
19:59:33 <hoan> oh ok, thanks a lot, i'll try it
19:59:45 <hoan> okay, how did you go about fixing it?
19:59:45 <sethk> I "unhid" it
20:00:11 <hoan> i tryed "ghc-pkg expose Cabal-1.1.4"
20:00:43 <sethk> hoan, I dumped the output into a text file, move the module from the hidden list to the exposed list, and fed the config back in
20:01:03 <sethk> hoan, I think expose is the right idea; but I'm not an expert here.  
20:01:12 <hoan> the output of what exactly?
20:01:23 <sethk> hoan, ghc-pkg list
20:01:27 <sethk> I think, let me check
20:01:27 <hoan> oh
20:01:54 <sethk> wait, list just gets the list of packages
20:02:07 <aufrank> I'm heading off for the night
20:02:08 <sethk> you get the name of the cabal package from there (mine was cabal-1.0)
20:02:16 <aufrank> thanks for talking through things with me
20:02:19 <hoan> ok mine is cabal-1.1.4
20:02:20 <sethk> sorry, capital C, Cabal-1.0
20:02:37 <sethk> let me see if I still have the command to dump the info for a package
20:02:53 <hoan> describe?
20:02:59 <sethk> ghc-pkg describe Cabal-1.0
20:03:04 <sethk> hoan, you are ahead of me  :)
20:03:09 <hoan> yes!!!
20:03:10 <hoan> booyah
20:03:28 <sethk> then you'll see .......FilePath in hidden-modules
20:03:31 <hoan> yes yes
20:03:36 <sethk> move it up to the list of exposed modules
20:03:45 <Lemmih> That's a bit evil.
20:03:49 <hoan> but where does this file belong?
20:04:20 <sethk> hoan, I just dumped it into a file named output.  It makes no difference, you are just turning around and using it as input
20:04:39 <hoan> ok
20:04:46 <hoan> input to what?
20:04:48 <hoan> oh its a cabal file
20:05:00 <hoan> thanks
20:05:03 <hoan> i'll try compiling
20:05:22 <sethk> compiling is cleaner if it isn't a problem
20:05:31 <hoan> yeh, ive got all year
20:05:55 <sethk>  compiling just FilePath shouldn't take long
20:06:29 <sethk> Lemmih, what's evil about it?  You are just telling the package manager to expose it.
20:06:48 <sethk> expose I think works with package level, not module level
20:07:15 <Lemmih> sethk: It's not meant to be exposed.
20:07:32 <sethk> Lemmih, how's that any different from recompiling it?
20:07:39 <sethk> Lemmih, it isn't meant to be used in either case
20:08:52 <Lemmih> sethk: Indeed, both ways are evil.
20:09:22 <sethk> Lemmih, I see no reason that FilePath should be hidden.  It's not 100% completely general, but it works everywhere I'm ever likely to be.
20:10:20 <hoan> sorry guys, i'll brb
20:10:29 <hoan> i have matters to attend to
20:10:35 <hoan> and thanks very much for your help
20:10:36 <Lemmih> sethk: People should not depend on Cabal for access to the FilePath module. There's a separate package that provides it.
20:10:45 <hoan> i'm almost over the bullshit barrier :]
20:10:50 <hoan> byee
20:11:03 <sethk> Lemmih, if you download and install the compiler, the only one you have is the one in Cabal.
20:11:12 <sethk> Lemmih, so perhaps that's a bug, but that's the way it is.
20:11:27 <sethk> you have documentation, but no module you can link to, which can't be right
20:12:31 <Lemmih> Documentation?
20:24:07 <sethk> Lemmih, yes, the library documentation
20:24:13 <sethk> tells you how to use stuff
20:25:11 <Lemmih> That's just because it's the documentation for the old Cabal.
20:25:42 <Pegazus> how can i compute (min 0 (x - y)) in a more elegant way?
20:26:35 <sethk> Lemmih, so what?  everything there is just the documentation of something
20:29:06 <Korollary> Pegazus: what's wrong with that?
20:29:39 <newsham> hi
20:29:54 <Lemmih> sethk: It'll go away soon.
20:30:15 <Lemmih> sethk: And if you depend on Distribution.Compat.* then no-one can use your code.
20:37:21 <sethk> then instead of having to rewrite it now, I'll have to rewrite it later
20:37:56 <Lemmih> Rewrite what? FilePath is provided by another package.
20:47:10 <sethk> Lemmih, the point is, that it is not provided by any other package.
20:47:17 <sethk> I agree that it is supposed to be, but it isn't
20:49:23 <Lemmih> But it is.
20:49:46 <Lemmih> It's just not in the standard libraries yet.
20:55:55 <sethk> that's "not provided".  it isn't there.
20:56:15 <sethk> provided means you use it, and you link, and you don't get nasty messages about it not being there
20:56:26 <sethk> the fact that the source code is in some directory on somebody's machine is hardly relevant
20:58:08 <Lemmih> But it has been cabalized and packaged. For me, that constitutes a Haskell library.
20:58:27 <sethk> for me, when I use it, and I don't get a link error, that constitutes a haskell library.
20:58:52 <Lemmih> Then there are no third-party Haskell libraries?
21:00:22 <sethk> Lemmih, of course there are.  but if the library documentation says something is in the library distributed with the compiler, and in fact that something isn't in the library, that's a problem.
21:00:36 <sethk> you don't go looking for 3rd party libraries for things that aren't supposed to be 3rd party
21:02:04 <sethk> the real problem is that they are clobbering the package information with the cabal package information, I'd imagine.
21:02:06 <Lemmih> It _were_ distributed with the compiler. It's not anymore. That the documentation for version X isn't completely identical to the documentation for version Y isn't a problem.
21:02:16 <sethk> it is for me.
21:02:28 <sethk> that's an absurdly low standard
21:02:36 <Lemmih> How so?
21:02:38 <sethk> if you take it out of the library, take it out of the doc.  that's not hard
21:04:07 <Lemmih> The documentation for latest GHC refers to Cabal version 1.0 which is the version GHC is distributed with.
21:04:51 <Lemmih> If you upgrade to Cabal-1.1.4 then you can't expect that the documentation for 1.0 applies.
21:04:55 <sethk> you are going around in circles.  the distributed documentation says you can use it.  when you use it, the compiler can't find it.  end of story.
21:05:01 <sethk> I did NOT upgrade to 1.1.4
21:05:04 <sethk> that's the whole point
21:05:12 <Lemmih> You got 1.0?
21:05:16 <sethk> yes
21:05:26 <sethk> if I upgrade, then of course the docs can be out of date
21:05:49 <Lemmih> Ah.
21:09:51 <newsham> i have some old code here that does a bunch of hGetBufBA / hPutBufBA into a newCharArray (for performance, I think).  those are deprecated.
21:10:02 <newsham> whats an up to date alternative api for high performance reads/writes?
21:10:28 <sethk> there's a library, where did I see the docs for it ...
21:15:04 <Lemmih> newsham: FPS is neat.
21:15:28 <newsham> Data.Array.MArray.newArray, Data.Array.IO.{hGetArray, hPutArray}  ?
21:21:57 <sjanssen_> newsham: yes that's one way to do it
21:22:28 <sjanssen_> however, you should really check out FPS, it gives you nice interface for the low level stuff
21:22:32 <sjanssen_> @where fps
21:23:50 <dons> yeah, I think you should check out fps for these hGet* style things
21:24:08 <newsham> how do I use newArray (or newArray_)?  any advantage to using one over the other?
21:24:39 <newsham> what would the advantage of fps be over Data.Array.* ?
21:25:03 <sjanssen_> newsham: the interface is much more friendly
21:25:41 <newsham> this is just 1 small function:  http://lava.net/~newsham/x/squirt.hs
21:25:50 <newsham> not sure another external dep is called for here.
21:26:11 <newsham> its just a pump between two file handles
21:26:21 <dons> ah, lambdabot's machine got accidently turned off
21:26:23 <Pegazus> is there any way to ask hugs just to make 1 reduction?
21:26:38 <dons> newsham, the interface is more friendly. you get a list like interface, and a System.IO style interface
21:28:07 <dons> hmm. is my nfs box down too. very strange..
21:28:35 <dons> ?versoin
21:28:51 <lambdabot> lambdabot 3p414, GHC 6.4.1 (Linux i686 3.20GHz)
21:28:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:31:51 <newsham> cool, that seems to have worked.
21:32:19 <dons> newsham, you can use fps locally if necessary. it needs no fancy build system
21:32:49 <newsham> dons: but if i give out the code its another dep someone has to chase down.
21:33:06 <newsham> btw, what causes this?  Parser.hs:45:15: Warning: `oneOf' is exported by `oneOf' and `oneOf'
21:33:09 <dons> no, i mean, you can take the FastPackedString.hs file and include it in your src dir
21:33:21 <dons> so no need to have yet another dep to chase :)
21:33:38 <newsham> ahh.  cool.
21:33:48 <dons> musasabi does this in HAppS, for example
21:33:50 <newsham> hmmm export declared twice.
21:34:05 <dons> ghc 6.4 ?
21:34:42 <newsham> exported by one of the local modules (not ghc)
21:35:01 <dons> are you using ghc 6.4 though? is it a bogus warning about multiple imports?
21:35:12 <dons> i.e. from import Map ; import qualified Map
21:36:13 <newsham> 6.4.1.  one of the local modules (not ghc's) was exporting the same symbol multiple times (not importing it more than once)
21:36:19 <newsham> tracked it down and fixed it
21:40:04 <dons> yikes. FastPackedString.hs is now 1700 loc. that's a lot of list functions
21:40:26 <dons> ah, that's better. 1003 loc, 765 comments
21:44:34 <hoan> oh brilliant!
21:44:37 <hoan> i got cabal working
21:44:54 <dons> cool
21:44:55 <hoan> thanks alot Lemmih and sethk
21:45:02 <hoan> the haskell adventure begins
21:45:06 <newsham> welcome to the cabal
21:45:08 <sethk> hoan, good luck
21:45:11 <hoan> lol
21:45:33 <hoan> well i must do other stuff now unfortunately
21:45:40 <hoan> see you guys around :]
22:20:40 <shapr> @y0
22:20:54 <shapr> d00d, where's lambdabot?
22:33:48 <Muad_Dib> shapr: pwned by peer :P
22:45:59 * shapr boings
23:19:21 <newsham> everlasting bobstopper
23:29:50 <shapr> It's amazing!
23:29:53 <shapr> I can't believe it's not butter!
23:31:21 <Korollary> you got that in Sweden?
23:41:31 <newsham> dons around?
23:43:42 <newsham> ?seen dons
23:47:50 <kzm> @seen
23:47:58 <newsham> @seen dons
23:48:17 <kzm> @seen lambdabot
23:48:23 <newsham> anyone know how to build a bunch of hs-plugins modules with cabal?
23:48:23 * kzm shrugs.
23:48:52 <kzm> Sorry, not me.  (I built \bot once, but w/o plugins)
23:49:14 <newsham> more specifically, how to make a cabal config file for buildign plugins
