00:00:14 <dons> kzm. hmm. slowness shouldn't be hidden. but good speed will sometimes be slighly slower.
00:00:19 <dons> here, i'll show you how to fix it... /me hacks
00:00:25 <kzm> anyway, I'm happy about the speed.
00:00:32 <dons> yeah. looked good.
00:00:38 <lispy> and when dons hacks, things get done :)
00:00:41 <kzm> And I've implemented Windows-1252 too.
00:00:50 <kzm> Will do KOI8 today, if I get time.
00:01:00 <JohnMeacham> lispy: A haskell compiler of course. :)
00:01:01 <lispy> kzm: for FPS?
00:01:11 <kzm> lispy, yes
00:01:23 <lispy> JohnMeacham: so you don't have any specific applications outside of a compiler?
00:01:35 <lispy> @karma+ kzm
00:01:35 <lambdabot> kzm's karma raised to 4.
00:01:39 <JohnMeacham> lispy: but I want to port 'ginsu', my gale chat client. and I have lots of ideas of programs to write for it, but don't want to resort to an inferior language.
00:01:49 <kzm> Win-1252 is very nice (but probably not fast), since you just specify a constant charset :: [Int] with the 256 code points, and the rest is generated automatically
00:01:55 <JohnMeacham> lispy: nothing in particular.
00:02:00 * kzm bows.
00:02:04 <flux__> hmm.. was jhc still missing a viable garbage collector?
00:02:35 * kzm means that the Win1252 module is nice, not the charset.
00:02:36 <lispy> JohnMeacham: what is gale?
00:02:48 <kzm> lispy, loudspeaker manufacturer?
00:02:51 <flux__> if my memory serves right, the plan is to use region inference?
00:03:14 * lispy would play with jhc more seriously if a GC existed
00:03:15 <kzm> dons, any idea what is required to replace PackedString (re Bulat's mail)?
00:03:47 <dons> oh, I have some ideas. yes :) well, let's say 'opinions' :)
00:04:47 <kzm> I'll work on a UTF-8 module, but I'm delaying it, because it will be more complicated, and there will be decisions to be made.
00:04:49 <JohnMeacham> lispy: a cryptographically secure chat system.
00:05:03 <kzm> E.g. should 'length' measure bytes or characters.
00:05:31 <JohnMeacham> flux__: it still uses the boehm GC. the C translation is kind of cruddy in several ways, I keep hoping an efficient c-- compiler will appear.
00:05:47 <kzm> dons, will you consider adopting the refactoring patch (moving to #include and wrapping functions with predicate testing)?
00:06:02 <dons> kzm, I think a good place to start would be to see how simonM layered his utf8 code over his small packedstring lib. and just go from there.
00:06:05 <kzm> It doesn't affect GHC perf (AFAICT), but will probably not be good for Hugs.
00:06:14 <JohnMeacham> kzm: I have a utf8 PackedString you can snarf code from.
00:06:14 <kzm> dons, right.
00:06:23 <dons> yeah, and steal john's code.
00:06:28 <lispy> JohnMeacham: oh so you do have some GC?
00:06:29 <kzm> Great!
00:06:34 <dons> full of juicy unboxed kinded goodness ;)
00:07:05 * lispy should sleep soon
00:07:13 <lispy> somehow it passed midnigt
00:07:17 <JohnMeacham> lispy: the boehm gc library, if you compile with -fboehm it will use it. but it is not really up to the task of garbage collecting as fast as haskell can allocate.
00:07:36 <lispy> JohnMeacham: heh, well put
00:07:44 <dons> kzm, ah, my little trick to fix the timings is also defeated by laziness.
00:07:51 <dons> its so hard to get something to evaluate twice! :)
00:07:59 <kzm> hehe.
00:08:26 <dons> possibly tweaking the GC flags would help, since its the couple of tests that do a lot of work that differ.
00:08:39 <dons> or, run the tests with each permutation of the list..
00:09:55 <kzm> Somebody worried about pack performance, I wonder if that really should be the critical part of a program?  Seems to me you'd mostly need to pack string constants?
00:10:21 * kzm probably suffers from having a limited perspective on things.
00:11:11 <dons> I've worked as much as i can on pack. but in practical cases, like musasabi's and in hmp3, you just use packAddress in stead, and let ghc hand you pre-packed strings
00:11:27 <kzm> dons: an alternative organization would be to put all string functions in a struct, and have a Map of all the charsets
00:11:41 <kzm> or just each charset in a separate variable (containing the functions)
00:12:12 <kzm> Could put it all in one module, with less #including, but not sure if it would be any better.
00:12:42 <kzm> dons: yes, the point is that pack performance is lower when you do character set translation (obviously)
00:12:59 <kzm> so it is an argument against using e.g. Latin1 or ASCII instead of Char8.
00:13:11 <kzm> perhaps even the only argument.
00:13:15 <dons> right.
00:14:06 <kzm> I must run to a meeting.
00:14:16 * kzm runs off into the sunset.
00:17:29 <tuxplorer> Hi channel. i would like to know about the RBR tool of haskell.. can anyone give me links regarding it?
00:18:14 <dons> RBR? need some more info.
00:18:33 <tuxplorer> Its some bioinformatics tool.
00:18:52 <dons> is it mentioned on haskell.org/ under the libraries and tools link?
00:19:07 <tuxplorer> its mentioned in the SoC projects list of haskell
00:19:13 <tuxplorer> http://hackage.haskell.org/trac/summer-of-code/ticket/28
00:19:28 <dons> ah!
00:20:04 <dons> now, let's see who posted that topic
00:20:12 <tuxplorer> i came here to ask kzm about it. but unfortunately, he left for a meeting when i entered.
00:20:36 <dons> right. it's kzm's idea, yes?
00:20:40 <tuxplorer> yes
00:20:48 <dons> he'll be back soon enough.
00:20:52 <dons> kzm: ping.
00:20:56 <tuxplorer> okay.
00:21:00 <tuxplorer> i've sent a mail to him..
00:21:01 <dons> he's the guy to ask about this.
00:21:11 <tuxplorer> okay. thanks dons
00:21:25 <dons> you done much haskell programming?
00:21:49 <tuxplorer> no.
00:22:02 <tuxplorer> but i can learn..
00:22:05 <dons> any functional programming background?
00:22:08 <dons> ocaml, lisp?
00:22:28 <tuxplorer> i 've done some basic lisp programs..
00:22:43 <tuxplorer> good at C, C++, JAVA and PERL
00:24:56 <tuxplorer> dons, how far does http://www.haskell.org/tutorial/goodies.html cover haskell? wat should i read after that?
00:26:08 <Lokadin> hmmm
00:26:18 <Lokadin> bah, my internet is so slow
00:26:36 <Lokadin> you want a good tutorial?
00:26:42 <tuxplorer> yes lokadin.
00:26:47 <Lokadin> @where YAHT
00:26:48 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
00:26:53 <Lokadin> that's a good one
00:26:57 <araujo> Hello.
00:27:11 <tuxplorer> thanks
00:27:14 <Korollary> tuxplorer: The gentle intro covers quite a bit. YAHT goes further.
00:27:40 <Lokadin> yea, so the first bit is the same
00:27:59 <tuxplorer> ok. 
00:28:04 <dons> sorry tuxplorer. got distracted for a bit. like the guys say, YAHT is a good place to start. or the gentl intro.
00:29:02 <tuxplorer> dons, ok dons.
00:29:06 <Lokadin> dons: say is there any way for me to run the bash shell, under my application, so it would seem to the user they were using a shell, but there is also the ai, on top of the shell between the user
00:29:29 <dons> tuxplorer: you got some bioinf background, I guess?
00:29:35 <tuxplorer> yes dons
00:30:02 <dons> Lokadin, sure. just fork a process onto the shell. and then put your interpreting logic between the user and the pipe onto the shell.
00:30:15 <dons> a bit like how lambdabot interprets strings and passes some onto ghci :t 
00:30:35 <tuxplorer> I've worked with computation with graphs on metabolic networks, and I'm a developer of the BIO-NIX team http://bioinformatics.org/BIO-NIX
00:30:59 <tuxplorer> and also worked with codon usage analysis
00:31:03 <Lokadin> hmmm, yea, can you direct me to maybe some commands i could do that with? i can look into the syntax myself
00:31:47 <tuxplorer> use execl lokadin
00:31:55 <dons> tuxplorer: excellent!
00:32:09 <Lokadin> kk
00:32:11 <dons> I'll make sure kzm gets back to you, if you don't hear from him soon.
00:32:11 <tuxplorer> thanx dons
00:32:20 <tuxplorer> ok dons. thanks
00:32:34 <Lokadin> say what package is that in? execl
00:32:43 <dons> Lokadin: System.Process ?
00:32:47 <dons> have a look at that first.
00:32:48 <tuxplorer> lokadin, its a linux system call
00:33:03 <Lokadin> oh,
00:33:26 <tuxplorer> wait a min lokadin, i'll put some code on some pastebin and give u a link
00:33:36 <Lokadin> wow thanks :)
00:33:36 <Korollary> @index execl
00:33:37 <lambdabot> bzzt
00:33:41 <Korollary> @index exec
00:33:41 <lambdabot> bzzt
00:33:46 <Korollary> @index runProcess
00:33:47 <lambdabot> System.Process
00:34:22 <dons> tuxplorer, he's probably looking for some haskell code to do the jobn
00:34:31 <tuxplorer> oh! k
00:34:44 <Lokadin> yea, actually i was
00:34:50 <dons> :)
00:34:52 <Korollary> I think execl doesnt return to the caller tho
00:34:56 <tuxplorer> oh! sorry lokadin, i had only C code
00:35:15 <Lokadin> i was thinking of using runInteractiveCommand, and tried it but can't seem to get it to do what i want, doesn't output the stdout ever
00:35:26 <Lokadin> works with things like echo
00:35:36 <Lokadin> but not with bash, i think cause it's running
00:36:08 <araujo> Lokadin, you are getting the value from the stdout?
00:36:19 <Lokadin> tuxplorer: it's fine thanks :)
00:36:37 <Lokadin> araujo: well it's a bash shell, so if i run something then i try getting it from stdout
00:36:40 <Lokadin> cause er
00:36:48 <Lokadin> @type runInteractiveCommand
00:36:49 <lambdabot> Not in scope: `runInteractiveCommand'
00:36:59 <Lokadin> @type System.Process.runInteractiveCommand
00:37:00 <lambdabot> String
00:37:00 <lambdabot>               -> IO (GHC.IOBase.Handle,
00:37:00 <lambdabot>                 GHC.IOBase.Handle,
00:37:00 <lambdabot>                 GHC.IOBase.Handle,
00:37:00 <lambdabot>                 System.Process.Internals.ProcessHandle)
00:37:28 <Lokadin> so he hanle's are, (stdin, stidout, stderr, pid)
00:37:33 <araujo> Lokadin, what exactly are you trying to do?
00:37:44 <Lokadin> trying to run an ai, overtop the bash shell
00:38:00 <Lokadin> so it would interpret the commands the user is giving and send to bash shell
00:38:17 <Lokadin> but so bash shell output would be seen and can be used, say if you cancel the ai
00:38:25 <araujo> sorry, an ai?
00:38:42 <Lokadin> er not really an ai, just scripting thing didn't know how to phrase it
00:39:15 <Lokadin> so i can say, :record script music, type some commands,then say :stop script 
00:39:28 <Lokadin> end then :play music, so it would redo all the commands
00:39:35 <Lokadin> in the script
00:39:35 <araujo> mm.. and script is a bash script?
00:39:46 <Lokadin> er well yes
00:39:52 <Lokadin> as you do it in bash
00:40:08 <dons> I've used this for interactive programs: http://www.cse.unsw.edu.au/~dons/code/hmp3/Utils.hs  
00:40:11 <dons> grep for 'popen'
00:40:24 <dons> works nicely in hmp3 to keep an interactive pipe to the mp3 decoder open
00:40:54 <Lokadin> oh cool thanks:) i'll look at it right now
00:45:00 <araujo> well, i guess you could fork script music to bash , wait for it, and use a MVar to kill the proc if you want.
00:46:08 <Lokadin> but then i wouldn't be using bash while writing it would i? i mean none of the tab-completion or anything
00:47:04 <araujo> if you wanna get tab completinon and that kind of neat things, you should use readline
00:47:29 <dons> a little readline wrapper would be much safer.
00:47:37 <dons> you wouldn't be allowing arbitrary shell to be executed.
00:47:53 <Lokadin> what's a readline wrapper?
00:49:41 <sieni> Lokadin: I'm using rlwrap (http://utopia.knoware.nl/~hlub/rlwrap/man.html) with mzscheme
00:49:54 <Lokadin> kk thanks :)
00:50:46 <dons> a bit of haskell code that calls readline instead of getLine
00:51:21 <araujo> Lokadin, still not sure what you wanna do, but if you want to use readline inside an appli, you just could do System.Cmd.system "/bin/bash"
00:51:31 <araujo> s/readline/bash/
00:51:36 <tuxplorer> is GHC the best one to use? or does anything else have better features?
00:53:09 <Lokadin> araujo: well i don't want to write another bash shell, or another shell period, i just want to be able to use different shells, and as your using them so that you could write scripts, or eventually so the ai will figure out by context what you are gonna do next
00:53:14 <araujo> tuxplorer, let's say it's the more standard implementation.
00:53:40 <tuxplorer> ok. so haskellers normally use ghc?
00:53:48 <Lokadin> making for very intelligent possibly multiline tab completion
00:53:50 <Lokadin> tuxplorer: yes
00:53:50 <araujo> Lokadin, well, in that case, i would go with system
00:53:58 <tuxplorer> ok.
00:54:17 <Lokadin> araujo: ? really,but how can i tell what the user is doing, and what the shell is doing?
00:54:21 <Lokadin> for my haskell program
00:54:45 <Lokadin> and insert stuff into the shell
00:54:48 <araujo> Lokadin, if you wanna tab completion and key shortcut, get readline
00:55:04 <Lokadin> kk
00:55:27 <Lokadin> is it a haskell function?
00:55:54 <Lokadin> or a shell command ?
00:55:58 <amiddelk> tuxplorer: depends on what you need. If you are new to Haskell, you might want to try out Helium (www.cs.uu.nl/helium), since it provides good error messages and hints. But it lacks many many features that GHC has.
00:56:25 <tuxplorer> thanks amiddelk.
00:57:01 <araujo> Lokadin, readline?
00:57:41 <dons> hmm. I'm not sure I'd recommend helium. university courses just start with ghc. so you can write real haskell code immediately.
00:57:45 <Lokadin> araujo: you told me to get readLine
00:57:46 <araujo> Lokadin, that's a lib taht you can find as a module for GHC
00:57:50 <dons> the helium approach is a bit controversial. 
00:58:06 <earthy> dons: why, exactly?
00:58:06 <dons> and i don't buy the error messages argument.
00:58:14 <earthy> you haven't seen Dr. Scheme?
00:58:22 <dons> taking out type classes doesn't seem like a good way to teach haskell, I reckon.
00:58:25 <Lokadin> araujo: oh okay thanks :)
00:58:32 <araujo> Lokadin, welcome
00:58:33 <earthy> you haven't seen dr. scheme? :P
00:58:35 <dons> Dr. Scheme is for high school students, though, isn't it?
00:58:46 <earthy> not quite
00:59:10 <dons> and plenty of places seem to teach ghc quite to beginners without trouble.
00:59:24 <earthy> 'without' trouble is a strong statement
00:59:54 <earthy> note that helium provides more than just the error messages
01:00:01 <araujo> I don't see what problems could ghc gives to beginners.
01:00:27 <amiddelk> dons: there is a project currently running @ the utrecht university to allow non-build-in type classes to be specified
01:00:34 <earthy> it also comes with an integrated environment that is instrumented to let the staff know what kinds of errors are being made
01:00:35 <amiddelk> student project*
01:01:03 <Korollary> I don't think ghc's error messages that don't involve typeclasses are even 'complex'.
01:01:08 <amiddelk> support for type classes is part of the helium compiler already for quite some time now... except that it was limited to build-in type classes like Eq and Ord
01:01:10 <dons> so, perhaps in a structured university course, starting with helium would work. but if a random person arrives on #haskell, sending them to helium would be a diversion.
01:01:18 <earthy> and that will hint as to what the possible errors are
01:01:20 <earthy> dons: true
01:02:02 <araujo> somebody _learning_ haskell should go fine with ghc
01:02:03 <dblhelix> dons, earthy, amiddelk: sometimes I even wonder if starting with helium in a structured course and then switching to ghc halfway is such a good idea... I've been back and forth
01:02:38 <earthy> but, helium does have its place in a structured course (which is what it was designed for), and having language levels *is* a good idea (as shown by the TeachScheme! approach and DrScheme)
01:02:45 <amiddelk> hehe, dblhelix, you taught that course ;)
01:02:47 <earthy> it's just a pity that Helium doesn't scale to full Haskell
01:02:49 <dblhelix> dons, earthy, amiddelk: perhaps it's best to start with ghc from the start
01:02:51 <dons> we teach with ghc and ghci at unsw. I get email messages about type errors. but we do end up with students feeling they can write real code. when we used hugs, this was not the case.
01:03:18 <dons> so i always think back to the hugs days, where students came away thinking it was a toy language. that's what worries me.
01:03:20 <dblhelix> amiddelk: indeed, so, my doubt are based on experience
01:04:01 <earthy> it would be absolutely best to have helium's simplified error messaging and code logging in ghc
01:04:06 <earthy> and than just teach using ghc
01:04:18 <dons> that would be ideal
01:04:20 <dblhelix> dons: we let them work with wxHaskell in a lab assignment, so they can feel they can indeed write "real" apps with haskell and it's not just entering expressions at the interactive prompt
01:04:22 <earthy> (for ghc read 'jhc, yhc, ehc or ghc')
01:05:03 <dblhelix> earthy: some kind of ghci --novice switch would be nice, indeed
01:05:15 <earthy> language levels, as in DrScheme
01:05:26 <araujo> dblhelix, what should it give that?
01:05:27 <dblhelix> earthy: or ghc -futrecht-lims
01:05:37 <earthy> well, not limits
01:05:42 <earthy> just tuned error messages
01:06:06 <dblhelix> araujo: just that, tuned error messages, and perhaps logging
01:06:19 <earthy> I don't care that the error message is 'can't give a good error messages' if I use typeclasses heavily and turn on -fsimple-errors
01:07:05 <earthy> thing is though that students *will* fail to supply -fsimple-errors
01:07:13 <dons> I like lambdabot's approach. if an error mentions classes, lambdabot says "Add a type signature" ;)
01:07:21 <earthy> so that should be default, with -fextended-errors as the option. ;)
01:07:39 <araujo> dblhelix, io think that somebody learning haskell shouldn't find big problems understading the current error messages.
01:07:52 <earthy> anyway, I think Bastiaan already has some ideas on how to deal with language levels and with typeclasses
01:07:55 <araujo> At least most of them.
01:08:14 <araujo> Being a begginer means that he will start with simple things.
01:08:19 <earthy> shouldn't and doesn't are a long long way apart
01:08:27 <dblhelix> earthy: unfortunately, the quality of the error messages is heavily affected by the presence of more advanced language features... more advanced than what's implemented in helium 1.0, that is... the availablity of built-in type classes already gives you a lot of ugliness in the error messages
01:08:30 <earthy> and simple things in haskell are reasonably complex
01:08:37 <araujo> Which will more likely trigger very easy to understand errors.
01:09:14 <earthy> araujo: <interactive>:1:0:
01:09:14 <earthy>     No instance for (Num [a])
01:09:14 <earthy>       arising from the literal `3' at <interactive>:1:0
01:09:14 <earthy>     Probable fix: add an instance declaration for (Num [a])
01:09:14 <earthy>     In the first argument of `(++)', namely `3'
01:09:17 <earthy>     In the definition of `it': it = 3 ++ [1, 2, 3]
01:09:31 <earthy> this is *not* what you want a beginning student to see. ;)
01:09:32 <dblhelix> > 4 + id
01:09:33 <lambdabot>  add an instance declaration for (Num (a -> a))
01:09:52 <araujo> earthy, why not?, what's wrong wiht it?
01:10:06 <dons> ah well, not every error is caught by lambdabot's 1 line error simplifier :)
01:10:10 <earthy> the student probably wanted to write  3 : [1,2,3]
01:10:41 <dblhelix> araujo: and the student has not seen type classes yet
01:11:15 <araujo> What that error message should be changed to?
01:11:28 <earthy> in the presence of typeclasses, it shouldn't
01:11:34 <earthy> that's exactly the problem
01:11:56 <araujo> mmm....
01:12:09 <earthy> however, you might want to tune the error message as per a language level
01:12:22 <dblhelix> araujo: helium gives Type error in infix application
01:12:22 <dblhelix>  expression       : 3 + [1, 2, 3]
01:12:22 <dblhelix>  operator         : +
01:12:22 <dblhelix>    type           : Int -> Int -> Int
01:12:22 <dblhelix>  right operand    : [1, 2, 3]
01:12:24 <dblhelix>    type           : [Int]
01:12:27 <dblhelix>    does not match : Int  
01:12:44 <earthy> 'hey, ghc, ignore that you know about typeclasses for a moment, and show me some easier thing to fix'
01:13:51 <araujo> i don't know really, i think it's good students get use to the 'real' thing at once.
01:14:22 <earthy> araujo: so you'd advocate giving the haskell report to students and tell them 'here's all about the language, have fun'?
01:14:39 <araujo> it's pretty much like learning to swimm, if you start with a savelife you won't ever never swimm or at least it will take you the double of time if you start with nothing 
01:14:59 <araujo> or is it lifesave? :-)
01:15:24 <amiddelk> araujo: I used hugs/ghc when learning Haskell, and I know one thing absolutely certain: I never looked at the error message. I just checkt the line number and looked at the source what in the world could be wrong with it...
01:15:48 <araujo> earthy, if they are learning with a teacher, yes.
01:16:14 <earthy> araujo: in .nl swimming is initially taught with tiny floatation devices that allow you to not drown, but not much more
01:16:24 <earthy> basically floating pads
01:16:39 <earthy> oh, and in less deep basins
01:16:43 <araujo> Not here.
01:16:56 <earthy> so you may put your feet on the floor, to prevent drowning.
01:17:11 <araujo> Here they take you to the water at once
01:17:22 <earthy> how deep? :)
01:17:29 <araujo> And being a city with one of the largest lake in the world, we have pretty good swimmers
01:17:31 <dblhelix> preventing students to drown is very important when teaching haskell
01:17:48 <araujo> earthy, 2.5 meters
01:17:57 <earthy> that's pretty... brutal. :)
01:17:59 <araujo> Of course, you got the teacher around
01:18:10 <earthy> how many teachers per how many students?
01:18:23 <earthy> I mean, dblhelix had like... 130 students taking the course?
01:18:24 <araujo> You got students swimming at one week usually.
01:18:29 <araujo> One per student
01:18:43 <araujo> So courses are of very little students
01:18:44 <earthy> araujo: ah, in .nl that's like 1 teacher per 30 students for swimming
01:18:51 <cpatrick> araujo: one teacher per student is probably more of the reason that it works so well
01:19:02 <cpatrick> in .au it's commonly 10--20
01:19:12 <araujo> cpatrick, What ahbout if we put them floating pads?
01:19:25 <earthy> not put them on, give them in the hands
01:19:30 <cpatrick> I don't recall the floaty pads being used here (they exist, but not for proper swimming lessons)
01:19:36 <araujo> I doubt they can do as good as they usually do
01:19:41 <cpatrick> but usually you start out in shallow water
01:19:52 <araujo> same here
01:20:33 <araujo> Actually we got one teacher for around 5-10 students.
01:20:45 <earthy> anyway, the idea is that helium is like the shallow pool
01:20:51 <araujo> around 15-20 minutes for each one
01:20:57 <araujo> haha
01:21:10 <earthy> get students to swim in the shallow pool and they will more easily swim in the deep pool ;)
01:21:14 <cpatrick> earthy: what we need is the haskell equivalent of the beach and let people wade in as deep as they want, when they feel comfortable ;-)
01:21:19 <araujo> The thing is that i don't see the ghc error messages _that_ traumatic for somebody _learning_
01:21:29 <earthy> cpatrick: :)
01:21:42 <earthy> actually, that is exactly what DrScheme provides for scheme
01:22:36 <Korollary> Scheme was meant to be a teaching language itself.
01:22:48 * earthy knows. ;)
01:22:58 <earthy> but, languages do tend to accrete stuff
01:23:45 <araujo> I think it also depends pretty much about your audience
01:23:48 <amiddelk> araujo: example of traumatic experience: "unification would give infinite type"    wtf, you stupid compiler ... throws computer out of the window
01:23:53 <kzm> @seen tuxplorer
01:23:53 <lambdabot> tuxplorer is in #haskell. I last heard tuxplorer speak 27 minutes and 27 seconds ago.
01:24:16 <tuxplorer> hi kzm
01:24:19 <araujo> If they are high-school kids, porobably helium, univ student, ghc for sure, give them something to think about it, phd students, just kill them!
01:24:29 <earthy> ghe ;)
01:24:40 <kzm> tuxplorer, hi.  I have a very busily scheduled day today.
01:24:56 <tuxplorer> ok kzm. tell me when u would be free.
01:25:03 <kzm> Must run off again in five minutes.  If you have any questions, please mail me, and I'll get back to you?
01:25:09 <dons> araujo, phd students: just give them the ghc src and let them work it out ;)
01:25:11 * kzm is <ketil@ii.uib.no>
01:25:12 <tuxplorer> ok. kzm. thanks
01:25:22 <dcoutts> dons, yeah :-)
01:25:24 <araujo> dons, haha, diabolic :-)
01:25:38 * earthy takes a bigass scythe to dblhelix and himself... *die* phd student, *die*. :)
01:25:47 <dons> yikes!
01:26:01 * dcoutts runs for the hills
01:26:08 <earthy> anyway, I learned haskell by reading the report
01:26:11 <dcoutts> hmm, no hills anywhere
01:26:20 <earthy> as I learned Clean by reading the report
01:26:32 <tuxplorer> ok. bye dons and others.. got to go to college.. c u guys again in 4hrs..
01:26:36 <earthy> (at that time, there really was no better documentaion)
01:26:39 <Korollary> earthy: I found the report quite clean for a 'report' as well
01:26:43 <earthy> yeah
01:26:45 <earthy> it's not bad
01:26:51 <araujo> hurry, somebody catches dcoutts ;-)
01:26:56 <earthy> not quite as thorough as the algol 68 report
01:27:06 <Korollary> earthy: With the famous quote?
01:27:55 <earthy> wich one? 'Habent sua fata libelli.'?
01:28:15 <Korollary> No. Now I have to find a link.
01:30:18 <earthy> 'The group wishes to contribute to the solution of the problems of describing a language clearly and completely. The method adopted in this Report is based upon a formalized two-level grammar, with the semantics expressed in natural language, but making use of some carefully and precisely defined terms and concepts. It is recognized, however, that this method may be difficult for the unitiated reader.'
01:30:34 <earthy> (it helps to actually have the report in the bookcase next to my desk :))
01:31:14 <earthy> for reference, this is section 0.1.1 of the Revised Report\
01:32:02 <Korollary> It's nice of them
01:32:23 <earthy> it's actually not that hard to read
01:33:34 <earthy> but, the 'Habent sua fata libelli' actually carries that meaning quite nicely
01:34:50 <earthy> the full latin is 'pro captu lectoris habent sua fata libelli', in english 'books meet their fate in the way the reader takes the book'
01:35:37 <Korollary> I can't find it now. I was looking for a very long paragraph with confusing terms, but I don't even remember what the terms sounded like.
01:38:04 <Korollary> aha!
01:38:42 <earthy> Stowed, moid, mood, that stuff? :)
01:38:51 <Korollary> "No proper program contains an indication which as an operator-applied "No proper program contains an indication which as an operator-applied indication-applied occurrence indentifies an indication-defining occurrence different from the one identified by the given indication as an indication-applied occurrence."  --ALGOL 68 Report
01:39:20 <Korollary> I pasted the first line twice. oops.
01:39:40 <Korollary> added injury to injury
01:40:14 <Korollary> ok, let me re-paste
01:40:18 <norpan> crystal clear
01:40:43 <Korollary> No proper program contains an indication which as an operator-applied occurrence identifies an operator-defining occurrence which as an indication-applied occurrence indentifies an indication-defining occurrence different from the one identified by the given indication as an indication-applied occurrence."  --ALGOL 68 Report
01:41:17 <earthy> it's a pretty complex sentence
01:41:21 <earthy> not impossible to parse though
01:41:29 <Korollary> I am sure it is meaningful
01:41:45 <Korollary> It's just where plain english fails
01:44:08 <earthy> interestingly, the revised report doesn't seem to contain that sentence
01:44:21 <earthy> http://members.dokom.net/w.kloke/RR/rr.pdf
01:49:22 <Lokadin> say is there anywhere i can find a howto for using readline?
01:51:28 <sieni> readline user manual?
01:51:49 <Lokadin> well the c one doesn't help me much
01:51:59 <bolrod> ^.0
01:52:07 <Lokadin> C *
01:52:13 <bolrod> ofcourse it doesn't ;/
01:52:23 <Lokadin> well are there other ones ?
01:52:43 <shapr> Good morning #haskell!
01:52:54 <Lokadin> good morning shapr 
01:52:55 <Lokadin> :)
01:53:00 * shapr boings cheerfully
01:53:02 <bolrod> do {x<-readLn ; putStrLn x; return ()}  ?
01:53:18 <bolrod> hmm.. that return isn't really needed ;/
01:53:28 <shapr> I think he might mean gnu readline.
01:53:44 <Lokadin> er yea, gnu readline
01:53:51 <bolrod> ;o
01:53:52 <Lokadin> :)
01:54:54 <Lokadin> like it doesn't seem to use handles,
01:55:35 <Lokadin> so i'm not really sure how to start a shell, and get stuff out of it and run commands, as that seems to be what it's for
01:55:44 <Lokadin> but if that's not it then i'm very confused
01:58:14 <shapr> Bringert wrote part (all?) of a pure Haskell readline.
01:58:36 <Lokadin> oh wow
01:58:54 <Lokadin> i always feel so tiny when i'm here :|
01:58:54 <kep> hi all
01:59:14 <shapr> Lokadin: Me too :-)
01:59:42 <Lokadin> shapr: :P lol, i don't believe you, i'm sure you've done some phenomenal haskell of your own :P
01:59:43 <shapr> Don't worry, it gets better. After awhile you start to feel tiny, but people notice when you bring your own toys ;-)
01:59:46 <Lokadin> lol
01:59:51 <Lokadin> yea
01:59:52 <Lokadin> llo
02:00:09 <Lokadin> well i can't make any yep :(
02:00:13 <Lokadin> yet*
02:00:14 <Lokadin> hmm
02:00:30 <shapr> I don't think I write much Haskell, but I do try hard to answer questions and give pointers to existing software.
02:00:44 <Lokadin> well you do that really well
02:00:45 <Lokadin> :)
02:00:47 <shapr> thanks :-)
02:00:55 <Lokadin> np
02:01:16 <Muad_Dib> shapr is cool :D
02:01:22 * shapr boings happily
02:01:30 <Lokadin> yea, i think i'll just make a super basic script saver for now, and work more on it later
02:01:34 <Lokadin> :)
02:01:37 <Lokadin> :D 
02:01:52 * Lokadin boings around to!! doesn't want to be left out of boinging!
02:02:25 * Muad_Dib just sits quietly in the corner
02:02:26 <amiddelk> Muad_Dib is lazy or is working at home ;)
02:02:33 <amiddelk> maybe both
02:02:33 <Lokadin> lol
02:02:43 <Muad_Dib> amiddelk: working at home, babysitting due to some unfortunate events.
02:04:32 <shapr> Hey, #haskell is five years old three days ago!
02:04:50 <Lokadin> wow that's crazy :)
02:04:53 <Muad_Dib> why didn't we have cake and beer then :(
02:04:55 <shapr> Muad_Dib: Did they involve dirty diapers? If so, I'm scared.
02:05:31 <Muad_Dib> shapr: as my mom babysits children/babys, and she's away right now (causing me to babysit) It migth just involve dirty diapers later on
02:05:45 <Muad_Dib> but hey! I can hide under the desk and those kids won't find me 
02:07:56 <Lokadin> lol but what about the computer!
02:08:01 <Lokadin> or do you have a laptop?
02:08:25 <Muad_Dib> laptop :)
02:08:41 <Muad_Dib> do you think it might be a good idea to teach them haskell?
02:08:41 <amiddelk> well Muad_Dib is programming in an untyped language, so that means the kinds can type all they want and do no harm ;)
02:09:08 <Muad_Dib> amiddelk: LaTeX is quite untyped indeed .... :P
02:11:22 <swiert> clear
02:12:58 <Sear> www.freepicssex.com
02:13:28 <dblhelix> shapr: would you be so nice to kick Sear?
02:13:52 <Lokadin> say what package is getArgs a part of? and how do i find those things out?
02:14:06 <dblhelix> @hoogle getArgs
02:14:07 <lambdabot> System.getArgs :: IO [String]
02:14:16 <Lokadin> oh cool thanks :)
02:14:38 <Sear> www.freepicssex.com
02:16:13 <Sear> www.freepicssex.com
02:16:50 <dcoutts> hmm, can someone kick Sear please
02:16:55 <ulfdoz> Sear: Go and play football on the motorway.
02:17:22 <Sear> www.freepicssex.com
02:17:23 <dcoutts> Igloo, dons, shapr? Sear needs kicking.
02:17:32 <Lokadin> Could not find module `System'
02:17:33 * xinming smells hammer around.
02:17:34 <Lokadin> :|
02:18:07 * Lokadin kicks Sear 
02:18:08 <Lokadin> lol
02:18:27 <Lokadin> say so, i need to import System to use getArgs
02:18:45 <dblhelix> Lokadin: it's in System.Environment
02:18:46 <Sear> www.freepicssex.com
02:18:51 <Lokadin> oh okay thanks :)
02:18:58 <amiddelk> feature request for lambdabot: voting mechanism for kicking. Or request mechanism for voice and set the channel to moderated :P
02:19:03 <dblhelix> not sure why hoogle mislocated it though
02:19:11 <dcoutts> juhp? you're a part-time chanop, Sear needs to go
02:19:31 * xinming thinks Sear needs more hammers...
02:19:58 <xinming> Is there any hannel operator here?
02:20:10 <ulfdoz> you mean hammer operator?
02:20:51 <Sear> www.freepicssex.com
02:21:19 <xinming> I mean, kick Sear as fast as the channel operator can...  I saw the operator kicked Sear and banned it after it sees Sear post this 2 times.
02:22:13 <Sear> www.freepicssex.com
02:22:36 --- mode: ChanServ set +o shapr
02:22:41 --- kick: Sear was kicked by shapr (Kicked by shapr)
02:22:49 <Sear> www.freepicssex.com
02:22:53 <ibid> kickban!
02:22:56 <xinming> set ban...
02:22:59 --- mode: shapr set +b sear@*!*@*
02:23:03 <xinming> kick...
02:23:07 --- kick: Sear was kicked by shapr (Kicked by shapr)
02:23:12 <shapr> doh
02:23:19 --- mode: shapr set +b sear!*@*
02:23:20 <xinming> ban again... ;-)
02:23:24 --- kick: Sear was kicked by shapr (Kicked by shapr)
02:23:34 <ibid> and have the network ops been notified? :)
02:23:35 <shapr> I just have to do that so rarely :-/
02:24:02 <ulfdoz> he could return after nick change. :\
02:24:03 * dcoutts chears shapr
02:24:16 <ibid> we need a kline or whatever it is :)
02:24:37 <dons> oh hmm. you can ban the ip address too 
02:24:39 <shapr> No senior ops around :-(
02:24:53 <ibid> shapr: have you told freenode staff? :)
02:24:56 <shapr> yup
02:25:00 <ibid> ok
02:25:05 <Muad_Dib> dons: as amiddelk said, no plans to include support for times like this into lambdabot? :)
02:25:08 <shapr> I was already chatting with one because I just found a bug in servires somewhere.
02:25:10 <xinming> If the Spamer use Adsl, he can change IP easily.
02:26:06 <shapr> #haskell used to have very little spam, but we've grown lots lately.
02:26:14 <shapr> And we're five years old now!
02:26:23 <dcoutts> yay!
02:26:30 <dcoutts> (to the age, not the spam :-) )
02:26:40 <shapr> Which is the bug I found in services, it says four years..
02:26:49 <Muad_Dib> hehe
02:26:52 <dons> we're big enough to be worth the effort. yay!
02:27:12 <dons> ?karma+ shapr -- for lasting 5 years at this gig :)
02:27:12 <lambdabot> shapr's karma raised to 17.
02:27:17 <shapr> yay!
02:28:14 <dcoutts> "for he's a jolly good fellow, for he's a jolly good fellow..." :-)
02:28:22 * shapr cheers for #haskell!
02:29:27 <ibid> perhaps the channel was inactive at the beginning, forcing reregistration?
02:29:46 <shapr> Nah, four days ago it said Four years, 51 weeks, 6 days
02:29:46 <ibid> for it's a jolly good channel... :)
02:29:52 <ibid> oh
02:30:22 <shapr> Does this look right? --> years = (delta / 31536000);
02:30:54 * shapr tracks through the freenode sources...
02:30:57 <amiddelk> > 365 * 24 * 60 * 60
02:30:58 <lambdabot> 31536000
02:31:03 <shapr> hm, yeah.
02:31:16 <ibid> note that not all years are 365 days long :)
02:31:36 <shapr> Yeah, but for it to suddenly show 4 years again must point to a bug.
02:31:40 <ibid> (and not all minutes have 60 seconds:)
02:31:45 <ibid> yeah, sure
02:31:48 <shapr> I wish I could get hold of original unix timestamp.
02:32:22 <amiddelk> shapr: maybe freenode started counting again 4 yours ago?
02:32:36 <ibid> 12:29 @<shapr> Nah, four days ago it said Four years, 51 weeks, 6 days
02:32:39 <ibid> amiddelk: ^
02:32:48 <shapr> Something happened in the last four days, thus implying a bug.
02:32:57 <amiddelk> ah, idd
02:33:12 <amiddelk> i mean, nvm
02:33:19 <ibid> just rewrite freenode in haskell, and all is well ;)
02:33:41 <shapr> Truly, lambdabot does more than all the sources I've seen so far.
02:33:43 <ibid> the type system ensures that there are no bugs, as long as it compiles :-P
02:34:01 <shapr> I forget how verbose C is.
02:35:32 <Lokadin> @hoogle getCont
02:35:33 <lambdabot> Prelude.getContents :: IO String
02:35:33 <lambdabot> Data.Graph.Inductive.Query.Monad.getContext :: GraphM m gr => GT m (gr a b) (Context a b)
02:35:33 <lambdabot> IO.hGetContents :: Handle -> IO String
02:41:29 <Lokadin> @hoogle bracket
02:41:30 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:41:30 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
02:41:30 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
02:41:44 <Pawer> hi
02:41:53 <Lokadin> hi
02:42:34 <Pawer> @hoogle loop
02:42:35 <lambdabot> Control.Arrow.loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
02:42:35 <lambdabot> Data.Graph.Inductive.Example.loop :: Gr Char ()
02:42:35 <lambdabot> Data.Graph.Inductive.Example.loop' :: IO (SGr Char ())
02:46:00 <Lokadin> say how do i get the first arg
02:46:08 <Lokadin> in a list
02:46:16 <Lokadin> @type head
02:46:18 <lambdabot> forall a. [a] -> a
02:46:30 <Lokadin> hmmm
02:47:03 <Lokadin> does that just give the first char?
02:47:38 <amiddelk> > head "abc"
02:47:39 <lambdabot> 'a'
02:48:00 <Lokadin> > head ["aoeu","anothnt"]
02:48:01 <lambdabot> "aoeu"
02:48:06 <Lokadin> oo
02:48:09 <Lokadin> so it should work
02:48:20 <amiddelk> you might as well look at pattern matches
02:49:00 <Lokadin> ?
02:49:05 <Lokadin> @type tail
02:49:06 <lambdabot> forall a. [a] -> [a]
02:49:22 <Lokadin> > tail ["aoeu","anothnt"]
02:49:23 <lambdabot> ["anothnt"]
02:49:35 <Lokadin> hmmm, well that is the part that isn't working for me
02:50:19 <Lokadin> args <- getArgs
02:50:19 <Lokadin>    case head args of
02:50:20 <Lokadin>       "record" -> record $ tail args
02:50:58 <Lokadin> Couldn't match `Char' against `String'
02:51:16 <Lokadin> in first argument of 'tail' namely 'args'
02:53:21 <Lokadin> why is the infered type Char, when it's supposed to be [a]
02:53:48 <Lokadin> hmmm
02:53:50 <Lokadin> oh i know
02:55:18 <Lokadin> no i don't know :(
02:56:06 <dblhelix> Lokadin: what's the type of record?
02:56:42 <dblhelix> Lokadin: I guess it takes a String as argument? you're passing it a list of Strings
02:57:06 <dblhelix> @type tail
02:57:07 <lambdabot> forall a. [a] -> [a]
03:02:55 <Lokadin> hmmm
03:03:23 <Lokadin> the type of record is [String]
03:04:57 <Lokadin> yea so it doesn't seem to make much sense
03:04:59 <shapr> Wow, lotsa cool papers - http://www.cis.upenn.edu/~lipeng/
03:05:28 <amiddelk> Lokadin: why are you using record as a function then?
03:05:50 <Lokadin> what you mean?
03:05:55 <Lokadin> it's tail args
03:05:59 <Lokadin> tail is a function
03:06:03 <Lokadin> args is [String
03:06:07 <Lokadin> ]
03:06:41 <Lokadin> brb i set more tea
03:07:03 <amiddelk> you write: "record $ tail args". Which means record is a function that takes the tail of args as an argument and should return some value. But if you say that record is a list of strings, then it is not a function...
03:07:13 <Lokadin> back
03:07:34 <Lokadin> oh
03:07:36 <Lokadin> record
03:07:42 <Lokadin> i'm sorry it's a function
03:08:13 <Lokadin> it opens the args as the filename, 
03:08:29 <Lokadin> er the tail args
03:08:40 <shapr> dcoutts: Can I summarize that paper as threads implemented as events via the CPS monad?
03:09:00 <shapr> Er, "A Language-Based Approach to Unifying Events and Threads"
03:09:48 <Lokadin> @hoogle split
03:09:49 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
03:09:49 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
03:09:49 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
03:09:58 <amiddelk> Lokadin: the tail of the arguments is the remaining list of strings, not one huge string. I think you want to glue these strings together and then pass it to the record function.
03:10:20 <Lokadin> yea, i did unwords $ tail args
03:10:23 <Lokadin> after i thought about it
03:10:28 <Lokadin> but it complains about tail args
03:10:31 <Lokadin> not about record
03:10:58 <Lokadin> says it expected [Char] istead of [String]
03:12:50 <Lokadin> amiddelk: you want me to paste it?
03:12:54 <Lokadin> here one sec
03:12:59 <Lokadin> @where paste
03:13:00 <lambdabot> http://paste.lisp.org/new/haskell
03:13:13 <amiddelk> Lokadin: ok, if you paste it, i'll check it quickly
03:14:00 <lisppaste2> Lokadin pasted "thingy magigi" at http://paste.lisp.org/display/19457
03:14:11 <Lokadin> kk np
03:14:23 <Lokadin> thanks :)
03:15:46 <Lokadin> oops 
03:15:48 <Lokadin> shit
03:15:52 <Lokadin> i took out the tail
03:18:42 <amiddelk> Lokadin: what is wrong with your firste paste, because except of some problem with "play", it type checks ok?
03:19:00 <Lokadin> yea
03:19:07 <Lokadin> i just put in tail and it works now
03:19:10 <Lokadin> i'm a lil confused
03:19:16 <Lokadin> thanks for the help though
03:19:29 <Lokadin> maybe i miss typed something the first time
03:20:18 <Lokadin> oh there
03:20:19 <Lokadin> i got it
03:20:25 <amiddelk> Lokadin: you forgot parenthesis?
03:20:34 <amiddelk> (or a dollar)
03:20:54 <Lokadin> no, i took out the type declarations and got the same error about the tail
03:21:19 <Lokadin> er but i have to add them in hold on i'll give new version one sec
03:23:05 <Lokadin> oi on, it's just that ghc thing bah' i'm sorry
03:23:25 <Lokadin> the same play problem
03:23:28 <Lokadin> it just moved
03:23:34 <Lokadin> but i can't figure that one out either
03:23:44 <lisppaste2> Lokadin annotated #19457 with "new real paste" at http://paste.lisp.org/display/19457#1
03:24:03 <Lokadin> er not tail problem though play problem *sighs* on different line
03:24:23 <Lokadin> i don't really see how it's an exitcode
03:24:30 <amiddelk> system returns an exitcode ;)
03:24:42 <Lokadin> oh
03:24:50 <amiddelk> @hoogle system
03:24:51 <lambdabot> System.system :: String -> IO ExitCode
03:24:51 <lambdabot> System :: module
03:24:51 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
03:25:06 <Lokadin> hmmm so what should i do?
03:25:48 <Lokadin> to make it better?
03:26:12 <amiddelk> Lokadin: the best thing to do is get some more knowledge about IO and do-notation ;)
03:26:49 <amiddelk> I could give you a solution, but well, at some point you have to find some solutions yourself ;)
03:26:57 <Lokadin> oh i got it
03:27:00 <Lokadin> :)
03:27:18 <Lokadin> return ()
03:27:19 <Lokadin> :)!!
03:27:21 <Lokadin> thanks :)))
03:27:22 <amiddelk> yep
03:27:42 <Lokadin> it's true
03:27:49 <Lokadin> i feel like a lame goat
03:28:16 <Lokadin> trying to figure out how to use a keyboard
03:28:44 <Lokadin> bah, i won't bother with the analogy, i'll just go code some more lol
03:45:09 <shapr> Amazing, their unified thread & event approach 'compares favorably to apache' for disk based workloads.
03:46:31 <shapr> JaffaCake: Seen Peng Li & Steve Zdancewic's "A Language-Based Approach to Unifying Events and Threads" ? They reference your HWS.
03:46:58 <JaffaCake> shapr: it's on the printer, I need to go pick it up :)
03:47:16 <JaffaCake> thanks for the reminder
03:47:20 <shapr> heh
03:47:50 <shapr> I tell ya people really can't say Haskell is slow after this sort of comparison.
03:48:34 <JaffaCake> I've been calling Haskell "the fastest concurrent language in the world" around here, it doesn't hurt to be a bit over the top I think
03:48:52 <shapr> For mostly-cached workloads their server was 10% to 30% slower, because of the batch-processing behaviour of their scheduler.
03:49:16 <JaffaCake> cool
03:49:24 <shapr> They said that was likely network saturation
03:49:30 <shapr> So they stuffed a user level TCP stack into the app.
03:49:32 <shapr> !
03:49:39 * shapr bounces
03:50:01 <shapr> I want the source!
03:50:10 <JaffaCake> you omitted the word "just", I think
03:50:18 <shapr> ?
03:50:30 <JaffaCake> as in, "just" stuffed a user level TCP stack into the app
03:50:33 <shapr> oh right :-)
03:51:09 <shapr> I really like the idea of using the CPS monad to implement concurrency, thus giving you whatever sort of scheduling you want.
03:51:43 <JaffaCake> Simon PJ wants to move the scheduler into Haskell, similar idea I think 
03:51:56 <shapr> I wonder if they have a TCP stack other than the House/ogi.edu stack?
03:52:12 <shapr> Scheduler in Haskell would solve a lot of use cases like House.
03:52:13 <musasabi> JHC will probably have the scheduler in Haskell.
03:52:25 <JaffaCake> yes 
03:52:43 <JaffaCake> GHC's scheduler does a lot of stuff, I'm mildly skeptical
03:52:56 <shapr> Have you read the paper yet?
03:53:03 <shapr> I'm interested in your reaction.
03:53:03 <JaffaCake> no,
03:53:36 * shapr reads slightly slower than a vacuum cleaner can suck down printed pages.
03:54:11 <shapr> No other way to stay current in this research community :-)
03:55:13 * JaffaCake reads fixed-width fonts much faster
03:57:20 <shapr> Impressive!
03:57:55 <shapr> Oh hey, they mention Esterel in the related work, I was wondering what they would say about dataflow.
03:58:25 <shapr> Man, I gotta grab their other papers.
03:58:38 <shapr> "Information-flow Arrows: an embedded security-typed sublanguage for information-flow control. There is no need to modify the Haskell language: with a library module, information-flow policies can be specified and enforced with strong security guarantees!"
03:58:41 * shapr burbles happily
03:58:54 <shapr> "A purely functional TCP stack written in Haskell!"
03:58:57 * shapr boings!
04:02:02 <shapr> And they run ghc-smp with STM on four CPUs also. Wow!
04:02:12 * shapr has a niftiness overload
04:14:34 * shapr reads "Encoding Information Flow in Haskell"
04:18:38 * shapr grits his teeth around the corners.
04:20:00 <amiddelk> shapr?
04:20:13 <dcoutts> shapr, yeah the events/threads paper is interesting. That seems to me to be a promising field for your lambda associates :-)
04:20:40 <shapr> amiddelk: This Information-flow paper has some plot twists where I had to hang onto my brain.
04:20:47 <dcoutts> with the ability to build scalable apps and tune the scheduler for the workload
04:20:57 <shapr> Sort of like going around a corner at high speed on a roller coaster.
04:21:01 <dcoutts> ie batched/smoothe/fair etc
04:22:59 <shapr> dcoutts: I'm especially impressed with the multicpu scalability they measured.
04:23:03 <dcoutts> indeed
04:23:18 <shapr> Know anybody with a eight cpu machine?
04:23:40 <dcoutts> get a new sparc T2000
04:23:52 <dcoutts> single spu with 8 cores each running 4 threads
04:23:58 <dcoutts> spu/cpu
04:24:00 <jip> cool
04:24:19 * dcoutts wishes his lab had one
04:24:47 * JKnecht can run that many via PVM/HT, no more than 4 in 1 box (2 ix86_64).
04:25:04 <shapr> The information-flow paper is neat, but not as earth shaking as their event/thread paper.
04:25:54 <shapr> I'd like for them to smooth out their arrow implementation some and come up with a capabilities demo implementation.
04:25:59 <amiddelk> shapr: if I quickly skip over that paper, it looks to me like they implement some instance of a monotone framework on top of labelled arrows?
04:26:10 <shapr> What's a monotone framework?
04:26:49 <JKnecht> maybe mispeak for monolithic?
04:26:54 <amiddelk> no
04:27:16 <JKnecht> indefeasible?
04:27:32 <amiddelk> eehm, I only have it described in a book called "Principles of Program Analysis" by Flemming Nielson, et all, but maybe I can find some paper somewhere
04:28:11 <Lokadin> hey, how do i getLine, but keep \n and stuff, 
04:28:58 <joelr1> howdy folks
04:29:04 <joelr1> shapr: ping
04:29:35 <musasabi> hello joelr1 
04:29:50 <joelr1> musasabi: :-)
04:30:35 <joelr1> did you guys find the source code to "unifying events and threads"?
04:31:49 <musasabi> no, but the paper looks very nice.
04:32:43 <joelr1> i know, i'm reading it
04:33:20 <joelr1> has anyone tried to contact the authors?
04:35:18 <amiddelk> shapr: If you want to know what a monotone framework is, you might one to check out these slides: http://theory.doc.ic.ac.uk/~herbert/pa06/DataFlowAnalysis.pdf followed by http://theory.doc.ic.ac.uk/~herbert/pa06/MonotoneFramework.pdf   (they are based on the book "Principles of Program Analysis")
04:35:53 <shapr> joelr1: pong
04:36:00 <amiddelk> [disclaimer: i did only quickly walk over those slides, but they seem to explain the same as in the textbook]
04:36:04 * Muad_Dib sees what amiddelk is talking about and quickly returns to his java stuff :)
04:36:09 <shapr> joelr1: I'm just writing an email to the guy now.
04:36:44 <joelr1> shapr: cool, would you kindly ping me when he replies? joelr1@gmail.com. or i'll ping you later
04:36:51 <joelr1> shapr: this stuff is dead-sexy
04:36:56 <shapr> I agree
04:37:08 <shapr> I had a niftiness overload when I read the paper.
04:37:22 <Lokadin> could i do: (\x -> x ++ "\n") =<< getLine 
04:37:42 <Lokadin> in order to then save it with the newline character
04:37:43 <shapr> Four CPUs, faster than Posix Threads in some cases, faster than apache for disk bound serving, purely functional TCP/IP stack, etc!
04:37:57 * dcoutts faints
04:38:10 <joelr1> hehe
04:38:20 <joelr1> shapr, dcoutts: have we seen the future?
04:38:29 <shapr> Oh yes.
04:38:39 * dcoutts comes to and has some tea
04:38:58 <shapr> Also, moving the scheduler into Haskell would be great for House and those sorts of use cases.
04:39:00 * Lokadin cheers
04:39:11 <shapr> joelr1: <dcoutts> shapr, yeah the events/threads paper is interesting. That seems to me to be a promising field for your lambda associates :-)
04:39:33 <joelr1> shapr: lambda associates?
04:39:38 <joelr1> whose associates?
04:39:49 <Lokadin> > (\x -> x ++ "\n") =<< return "aoeu"
04:39:51 <lambdabot> "aoeu\n"
04:39:53 <shapr> It's this idea for a european group of Haskell consultants.
04:39:53 <dcoutts> shapr, it doesn't quite cover the same ground as GHC threads because they can't do pre-emption of pure code
04:40:10 <Lokadin> can i have two =<< on one line?
04:40:23 <shapr> Lokadin: try it
04:40:26 <dcoutts> JaffaCake, how would SPJ propose to move the scheduler into Haskell? What about preemption?
04:40:41 <joelr1> wow, simon in da house
04:40:58 * joelr1 is overcome by a wholesome warm feeling: ah, the world of haskell
04:40:59 <Lokadin> > (\x -> x ++ "b") =<< (\x -> x ++ "\n") =<< return "aoeu"
04:41:00 <lambdabot> Couldn't match `[Char]' against `Char'
04:41:10 <Lokadin> > (\x -> x ++ "b") =<< return(\x -> x ++ "\n") =<< return "aoeu"
04:41:12 <lambdabot> Couldn't match `[]' against `(->) [Char]'
04:41:13 <JaffaCake> ah well, we didn't pin down the details, but you basically need a way to wrap up a thread as a continuation
04:41:31 <shapr> dcoutts: Yeah, GHC threads can also preempt inside a function. Preemption can happen at any allocation, right?
04:41:34 <Lokadin> > (\x -> x ) =<< (\x -> x ++ "\n") =<< return "aoeu"
04:41:35 <lambdabot> Couldn't match `[b]' against `Char'
04:41:36 <dcoutts> JaffaCake, to the rts would provide a primitive for that purpose
04:41:38 <dcoutts> to/so
04:41:39 <JaffaCake> and have some kind of system mechanism that causes a thread to return to the scheduler from tiem to time
04:41:53 <joelr1> i must have missed something... threads are moving in in ghc?
04:41:56 <dcoutts> shapr, right
04:42:17 <dcoutts> joelr1, no, it's just an idea
04:42:19 <shapr> Peng Li's paper is much like Oleg's ZipperFS, the thread/event framework result is a Trace value, and the scheduler is what really executes that.
04:42:24 <Lokadin> > (\x -> x ) $ (\x -> x ++ "\n") =<< return "aoeu"
04:42:25 <lambdabot> "aoeu\n"
04:42:30 <Lokadin> alright ! :)
04:42:31 <Lokadin> yay
04:42:32 <dcoutts> joelr1, they're currently implemented in the rts
04:42:46 <joelr1> dcoutts: that i vividly remember :D
04:42:55 <JaffaCake> hi joelr1!
04:43:00 <shapr> I wonder what other cool tricks could be done with a first class Trace value?
04:43:09 <Lokadin> > (\x -> x ++ "\n") =<< getLine
04:43:10 * joelr1 high-fives JaffaCake 
04:43:10 <lambdabot> Couldn't match `[]' against `IO'
04:43:21 <dcoutts> joelr1, have you read this events/threads paper yet?
04:43:35 <joelr1> dcoutts: doing so at this very moment
04:43:42 <JaffaCake> joelr1: still haskelling? I thought you'd given up on us
04:44:07 <joelr1> JaffaCake: don't get me started :-) but not for the obvious reasons
04:44:23 <dcoutts> joelr1, if you used that trick you could implement your process/thread abstraction and schedule according to the processe's message queue length
04:44:35 <joelr1> JaffaCake: haskell is seductive and it only took a post on LtU to make me wanna try again
04:44:44 <shapr> What would you call that, a 'backlog' scheduler?
04:44:59 <dcoutts> an Erlang scheduler :-)
04:45:06 <JaffaCake> joelr1: well, nice to have you back
04:45:19 <israel> http://israel.275mb.com/index3.php
04:45:25 <audreyt> @seen dons
04:45:25 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2 hours, 18 minutes and 12 seconds ago.
04:45:26 <shapr> I hate spammers.
04:45:34 <joelr1> dcoutts: it's was a stupid issue that time although in the end the customer's programmer liked erlang much better. it was a... what's the word... push-pull contest between my code and the server
04:45:49 <Lokadin> > (\x -> x ) =<< getLine
04:45:50 <lambdabot> Couldn't match `IO' against `[]'
04:45:57 <joelr1> dcoutts: if i was highly performant then the server would bog down and vise versa
04:46:04 <joelr1> overall, it was no fault of haskell's
04:46:11 <shapr> I wonder if we should go +R again?
04:46:11 <dcoutts> joelr1, I see, right
04:46:19 <dcoutts> shapr, +R ?
04:46:29 <shapr> dcoutts: Only registered nicknames can speak.
04:46:36 <JaffaCake> joelr1: glad to hear that... did you post an updated analysis anywhere?
04:46:38 <joelr1> dcoutts: by "that trick" you mean the one in the current paper?
04:46:38 <shapr> Er, registered and identified.
04:46:40 <dcoutts> a voice/no-voice
04:46:55 <dcoutts> it's a bit of a pain
04:47:01 <shapr> Yeah, but so are spammers.
04:47:05 <dcoutts> true
04:47:19 <Lokadin> we only had one recently no?
04:47:22 <shapr> Several
04:47:29 <Lokadin> or really?
04:47:31 <Lokadin> oh*
04:47:41 <joelr1> JaffaCake: no, i did not. it was still much easier to work things out in erlang ;-) i might some day. actually, i think doing a new "vindicating" project in haskell could be a much better idea
04:47:45 <dcoutts> shapr, we could get lambdabot to give us voice if we're not registered and we use the magic word
04:48:05 <shapr> dcoutts: I think it'd make more sense to have a timed +voice
04:48:14 <dcoutts> shapr, or that, yeah
04:48:26 <shapr> Might be something to add to lambdabot 
04:49:04 <dcoutts> shapr, that's a good idea actualy, timed voice - so long as there's a joining message to tell people how it works
04:49:20 <Lokadin> > (\x -> return(x) ) =<< getLine
04:49:21 <lambdabot> No IO allowed
04:49:30 <dcoutts> Lokadin, well done
04:49:33 <Lokadin> :)
04:49:38 --- kick: israel was kicked by shapr (Kicked by shapr)
04:49:44 <dcoutts> mwahahaha
04:49:46 <joelr1> are there any examples of doing natural language processing in haskell?
04:49:51 <dcoutts> shapr, before it spoke
04:49:55 <shapr> joelr1: GF - grammatical framework
04:50:07 <boegel> shapr: any reason why you kicked him/her?
04:50:16 <shapr> boegel: pre-existing spam.
04:50:16 <joelr1> there's also lolita, whatever that is
04:50:21 <shapr> boegel: Scrollback and see.
04:51:21 <amiddelk> Muad_Dib: In the paper mentioned by shapr, I get the impression that they add some notion of labels to loop, conditional's in an arrow language (which corresponds quite closely to the program points in the while-language), then derive flow between labels and the other usual stuff you need for monotone frameworks [but then again, I did not really read that paper]
04:51:22 <joelr1> is ghc getting multiprocessing capabilities in 6.5?
04:51:28 <dcoutts> joelr1, yep
04:51:29 <audreyt> dons: did you remember the copyFromCStringLen patch I pointed at you here a while ago to fps?
04:51:43 <dcoutts> joelr1, you can try it now, get a 6.5 snapshot
04:52:06 <joelr1> dcoutts: i haven't made enough bucks to afford a macbook pro just yet :D
04:52:24 <shapr> amiddelk: I gotta do some paying work, we'll have to discuss this later.
04:52:26 --- kick: israel was kicked by shapr (Kicked by shapr)
04:52:39 <dcoutts> joelr1, you don't actually need 2 cpus to test it
04:52:50 <dcoutts> shapr, you need to ban
04:52:57 --- mode: shapr set +b israel!*@*
04:53:32 <audreyt> dons: http://perlcabal.org/~autrijus/tmp/copyCStringLen.diff
04:53:36 <mauke> o/` skalat madr rnar rista / nema rada vel kunni o/`
04:54:31 <boegel> shapr: advertising sex sites isn't allowed here? how lame
04:54:32 <boegel> :p
04:54:54 <joelr1> dcoutts: how would i test a multiprocessing system on 1 cpu?
04:55:01 <dcoutts> boegel -> #haskell-blah
04:55:07 <shapr> boegel: Sex has side-effects, too bad!
04:55:09 <boegel> joelr1: simulation
04:55:26 <dcoutts> joelr1, using 2 kernel threads
04:55:48 <boegel> dcoutts: threads are totally different from multiprocs
04:56:14 <dcoutts> sure, but you can still test the smp rts using 2 kernel threads on one cpu
04:57:54 <dcoutts> JaffaCake, oh that reminds me, if I could find you an old sparc box would you like it? It says in the bug about sparc NCG bitrot that ghc HQ lacks a sparc.
04:58:44 <dcoutts> JaffaCake, the best I might be able to get would be a 500Mhz sparc with 1GB ram. The worst a 120Mhz wth 128M.
04:59:21 <JaffaCake> dcoutts: I don't really have the time to look after a sparc port too, I'm kinda hoping someone else will do it :/
04:59:55 <dcoutts> JaffaCake, ok well let me know if some old hardware might help. Our lab has quite a bit. :-)
05:00:08 <dcoutts> ie if you find someone who might but needs the hw.
05:00:09 <JaffaCake> thanks, I'll bear it in mind :)
05:01:00 <dcoutts> JaffaCake, I told you before that if mips works then I can probably get you access to a 16-way mips box. That might be nice for testing GHC-SMP scalability.
05:01:38 <JaffaCake> indeed
05:01:58 <JaffaCake> the best I have right now is a 4-way box, and I hope to get my hands on an 8-way later this summer
05:02:01 <dcoutts> it's an SGI Origin 2000 with 16x200Mhz CPUs and 8GB ram
05:02:26 <JaffaCake> but that means getting registerised mips working :-(
05:02:32 <dcoutts> yeah :-(
05:02:48 <dcoutts> what is the 4-way? 2x amd64 dual core?
05:02:56 * JaffaCake adds a summer of code project idea :)
05:03:03 <dcoutts> heh
05:03:17 <dcoutts> I could help with that, access to hardware etc :-)
05:03:27 <JaffaCake> I'm not sure actually
05:03:29 <kzm> We have a 96-CPU IBM Regatta, if somebody would like to port GHC to it, it would be great :-)
05:03:52 <JaffaCake> wow
05:04:19 <dcoutts> kzm, what is it? Power CPU?
05:04:22 <dcoutts> JaffaCake, our progress on the registerised alpha port has stalled as Chris is away on holiday.
05:04:23 <kzm> I wouldn't need FPS then, since it has gobs of memory as well.
05:04:32 <kzm> dcoutts, Power4, I think.
05:04:36 <JaffaCake> dcoutts: ok, no problem
05:04:39 <dcoutts> kzm, AIX?
05:04:44 <kzm> think so.
05:04:46 <dcoutts> I don't see why it shouldn't work
05:04:57 <kzm> just like that?
05:04:59 <dcoutts> JaffaCake, GHC works on AIX?
05:05:02 <JaffaCake> yes
05:05:11 <dcoutts> kzm, try it! :-)
05:05:18 <JaffaCake> allegedly the powerpx/aix port works
05:05:26 <kzm> I looked briefly at it when it was new, GHC 5.x time, and it looked hairy IIRC.
05:05:29 <JaffaCake> might need a few tweaks, I bet it's not regularly tested
05:05:37 <SamB> you mean powerpc/aix?
05:05:45 <kzm> Wow, that would be cool!
05:05:46 <JaffaCake> er, yes
05:05:54 <dcoutts> there was someone on the ghc-user list iirc who used AIX
05:06:08 <dcoutts> can't remember who
05:06:28 <JaffaCake> audrey tang is down as the maintainer
05:06:55 <SamB> that recent, eh?
05:06:56 <JaffaCake> and CosmicRay was using it too, I believe
05:07:14 <dcoutts> JaffaCake, or you could try getting one of these new 32-thread sparc boxes :-)
05:07:24 <dcoutts> probably cheaper than a 8-way opteron
05:07:29 <JaffaCake> what's that?
05:07:45 <JaffaCake> a multicore of some kind?
05:07:49 <dcoutts> JaffaCake, it's a single sparc CPU with 8 cores, each of which can do 4 threads
05:07:55 <SamB> of course!
05:08:08 <dcoutts> JaffaCake, it's blazinly fast for web server stuff
05:08:12 <SamB> is that the power-saving one?
05:08:17 <JaffaCake> hmm, not sure I want to deal with multithreaded cpus 
05:08:22 <dcoutts> JaffaCake, runs at 1GHz or so
05:08:34 <dcoutts> JaffaCake, the multi-threading is not visible to the programmer
05:08:43 <dcoutts> JaffaCake, it's just for memory latency hiding
05:08:51 <dcoutts> let me find the link...
05:08:53 <JaffaCake> it is when you don't get any speedup despite using multiple CPUs :)
05:09:40 <dcoutts> JaffaCake, since GHC-progs are so memory bandwidth hungary I'd think that multi-threaded cores would be great
05:09:53 <JaffaCake> at least, it has to be visible to the runtime, so I can make sensible scheduling decisions
05:10:15 <dcoutts> when one thread is stalled waiting for memory read/write the next can run
05:10:15 <JaffaCake> maybe, but we often max out the memory bandwidth anyway I think
05:10:25 <dcoutts> ah, not just latency
05:11:04 <JaffaCake> I don't know for sure... but I'm experimenting with using the CPU performance counters at the moment to get a better handle on what's going on
05:11:21 <dcoutts> http://www.sun.com/servers/index.jsp?cat=CoolThreads%20Servers&tab=3
05:11:28 <dcoutts> T1000 & T2000
05:11:53 <JaffaCake> hmm nice, how much are those?
05:12:10 <dcoutts> starting at $3500
05:12:22 <dcoutts> for a 6-core with 2GB ram
05:12:34 <JaffaCake> wow, they're cheap
05:12:37 * shapr agrees
05:12:43 <dcoutts> going up to $12,000 for 8-core with 16GB ram
05:13:03 <shapr> I was looking at a four-socket mobo with dual-core cpus, but it'd be significantly more expensive.
05:13:04 <JaffaCake> I'm looking at 11k+ for an 8-core AMD
05:13:04 <dcoutts> 6-core is one with 2 cores turned off (or not working)
05:13:20 <dcoutts> that's the T1000
05:13:24 <dcoutts> http://store.sun.com/CMTemplate/CEServlet?process=SunStore&cmdViewProduct_CP&catid=141650
05:13:25 <SamB> 2GB ram! why, that is probably enough to compile JHC's library!
05:13:31 <shapr> SamB: Just barely ;-)
05:13:43 <SamB> just barely?
05:14:05 <shapr> I think 2GB of ram is the minimum you need to build JHC's libraries in a reasonable amount of time.
05:14:19 * JaffaCake thinks it's funny how you can buy Sparcs on the web these days, you used to need a Sun salesman to come round and show you the brochures
05:14:27 <dcoutts> heh
05:14:34 <SamB> I'd think you could get by with 1GB
05:14:35 <shapr> Last time I built JHC's libs on my 512mb ram dual Athlon MP, I shutdown *everything* and went away over the weekend while it swapped.
05:15:12 <boegel> shapr: :)
05:15:18 <JohnMeacham> you can download pre-compiled libraries now.
05:15:23 <shapr> JohnMeacham: yay! many thanks!
05:15:44 <shapr> I wish I could afford more ram for this monster, but registered ecc has never come down in price.
05:15:45 <SamB> lovely!
05:15:55 <JohnMeacham> oddly enough, I recently greatly improved space performance. and then promptly used that extra room to enable several more optimizations to bring it back up to the 2G mark :)
05:16:15 <SamB> what did you do that for?
05:16:40 <shapr> It's actually more cost effective to buy a minimal dual-core amd64 setup with 4gb of ram than to upgrade my registered ecc ram.
05:17:20 <JohnMeacham> because testing showed they were worthwhile optimizations. the main issue is that Prelude is part of a recursive group of about 15 modules it compiles all together as a unit. once it gets past that chunk, the rest flys by. 
05:18:13 <JaffaCake> JohnMeacham: you're doing a kind of separate compilation now?
05:18:49 <dcoutts> JaffaCake, the main difference between the T1000 & T2000 is that the T2000 is more expensive, is 2U size rather than 1U size and has more space for drives & PCIX expansions slots. Not worth it for performance testing.
05:20:04 <dcoutts> JaffaCake, the cheapest T1000 with all 8 cores is $8000 (and has 8GB ram)
05:20:15 <olliej> dcoutts: for a moment there i thought you were referring to terminators...
05:20:17 <olliej> :)
05:20:23 <dcoutts> hah
05:20:25 <JaffaCake> dcoutts: very tempting to request one of those... but the thought of getting the sparc port up to scratch puts me off a bit
05:20:39 <dcoutts> JaffaCake, it works fine -fvia-C
05:20:43 <dcoutts> I use it every day
05:20:54 <JaffaCake> you using 6.4.2?
05:20:56 <dcoutts> my office box is a Sparc 500Mhz
05:20:59 <dcoutts> 6.4.1
05:21:02 <JaffaCake> right
05:21:23 <JaffaCake> you don't find via C a little slow?  I always turn on -fasm
05:21:34 <dcoutts> the box is slow anyway :-)
05:21:37 <dcoutts> it's registerised, just no NCG
05:21:44 <JaffaCake> yeah
05:22:01 <JaffaCake> guess I'm just impatient :)
05:22:02 <dcoutts> JaffaCake, and with 32-way you can use make -j30 :-)
05:22:11 <dcoutts> that'll be quicker
05:22:17 <JaffaCake> very true
05:23:19 <dcoutts> JaffaCake, the cheapest T1000 at $$,3500 is missing a disk drive and only has 2GB RAM
05:23:56 <dcoutts> the more sensible ones are $5750 or $8000 for 6-core or 8-core with a disk drive and 8GB ram
05:24:21 <dcoutts> they're all headless servers
05:24:27 <JaffaCake> all cores share the L2 cache?
05:24:47 <dcoutts> yes, 3Mb
05:24:55 <JaffaCake> interesting
05:25:09 <dcoutts> http://www.sun.com/processors/UltraSPARC-T1/
05:25:20 <kzm> Cabal question: I've branched dons' FPS, and wonder how I should reflect that in the version number
05:25:27 <kzm> (or if I should)
05:25:34 <kzm> Any thoughts?
05:25:42 <Igloo> You should change the name
05:25:55 <dcoutts> JaffaCake, http://www.sun.com/processors/UltraSPARC-T1/details.xml#Caches-5
05:26:20 <kzm> Igloo, okay.  I can still keep the same module names?
05:26:33 <kzm> and switch with -package this or -package that?
05:27:07 * JaffaCake ponders the offer to chat online with attractive young lady  at Sun
05:27:35 <dcoutts> JaffaCake, it comes with Solaris 10 but the Linux kernel people have been given hardware and are currently doing porting.
05:27:38 <Igloo> Do we still disallow the same module name to appear twice in the same program? If so you'd really want different module names as different libraries may use different fps'
05:27:42 * shapr laughs
05:28:18 <dcoutts> JaffaCake, so you probably wouldn't have to stick with solaris for ever ;-)
05:28:27 <SamB> Igloo: presumably a linker problem prevents it?
05:28:35 <kzm> Igloo, referring to different modules, you mean?  The fork is intended as a replacement (eventually.  Apologies for the hubris)
05:28:54 <JaffaCake> Igloo: yes that's still the case, but hopefully before 6.6 we'll remove the restriction
05:29:41 <dcoutts> JaffaCake, I could tell you when gentoo is runing on those boxes.
05:29:45 <kzm> Igloo, consider my branch as an "unstable" version.
05:30:08 <dcoutts> JaffaCake, for your talk with said sun bod, they've got a try before you buy offer I believe
05:30:17 * dcoutts will now shut up
05:30:27 <JaffaCake> heh, thanks dcoutts
05:30:36 * JaffaCake is tempted
05:30:58 <JaffaCake> I'll wait a while until the Linux folks have it stable, I think
05:31:05 <kzm> Igloo, you do the .debs for ghc?  What's with the ghc-cvs package in Dapper?  (It's dated 2005-03 something)
05:31:29 <JaffaCake> certainly sounds like a cheaper way to get more cores for our parallelism work, though 
05:31:56 <dcoutts> JaffaCake, ok, I'll ping you when I hear something from the Gentoo sparc folks.
05:32:07 <JaffaCake> great
05:32:56 <Igloo> kzm: I gave up on updating it when thread bugs were meaning builds failed and the development machines were falling over. I'll look at making an updated one RSN
05:33:54 <dcoutts> JaffaCake, ping!
05:34:02 <drakioned> hey, is there anyone here that can tell me about the SoC projects?
05:34:10 <JaffaCake> that was quick
05:34:18 <kzm> Igloo, either that, or simply have it removed?
05:34:23 <dcoutts> JaffaCake, I've heard tell of an expreimental gentoo live CD that is said to boot on these macines
05:34:37 <JaffaCake> using all the cores?
05:34:42 <Igloo> kzm: From dapper? Nothing to do with me
05:35:16 <kzm> drakioned, sure!  For instance, it is organized by Google.
05:35:19 <kzm> :-)
05:35:28 <drakioned> lol
05:35:40 <JaffaCake> kzm: it should just be removed
05:35:46 <drakioned> well, I was more wondering like, how to register interest
05:35:51 <kzm> Igloo, I guess they base it on debian.  Not sure whom to talk to, but if you want, I can try to find out.
05:36:19 <dcoutts> JaffaCake, I believe so
05:36:35 <dcoutts> JaffaCake, I'll try and find you some more info on the livecd
05:36:40 <kzm> In fact, I think I'll just file a bug report against it, saying it is outdated.
05:41:41 <boegel> does anyone know how I can use time fro very small programs? i.e. run the program multiple times, and get 1 value from the time command?
05:43:03 <shapr> boegel: Can you change the output format to give you better resolution?
05:43:35 <shapr> JohnMeacham: Just put the *.hl files into ~/build/darcs/jhc/ ?
05:43:39 <SamB> boegel: time a for loop?
05:43:48 <dcoutts> JaffaCake, yes, all 32 "CPUs" are recognised. http://vger.kernel.org/~davem/niagara_ubuntu_boot.txt
05:44:49 <dcoutts> and it's now in the mainline kernel, not sure if it's any released kernel yet
05:44:57 <JaffaCake> boegel: I sometimes use Valgrind (with the cachegrind tool) to get instruction counts for small programs
05:45:03 <dcoutts> that was 1 month ago
05:45:26 <dcoutts> JaffaCake, do ghc-compiled progs valgrind ok?
05:45:33 <JaffaCake> sure
05:45:36 <dcoutts> cool
05:45:46 <boegel> JaffaCake: I know the instruction count of the programs, I want to determine the CPI (or IPC) on two different machines of which I know the clock speed
05:45:47 <dcoutts> I'll use that on gtk2hs
05:45:59 <boegel> JaffaCake: so time seemed like a good option
05:46:03 <JaffaCake> you don't get any help with debugging though - valgrind doesn't know anything about our storage manager 
05:46:30 <shapr> Maybe Julian would have some advice on how to change that?
05:46:42 <shapr> Since valgrind was inspired by GHC to begin with...
05:46:47 <boegel> JaffaCake: besides that, it's on a ancient Tru64Unix machine (Alpha) which doesn't have valgrind :)
05:46:58 <shapr> eek
05:47:03 <JaffaCake> shapr: yes, he's told me how to do it, valgrind is extendible, but I never got around to it
05:47:16 <shapr> Speaking of SoC...
05:47:41 <dcoutts> JaffaCake, ok, what would be the best way for me to try to track down a probably memory stomping problem in gtk2hs? I link this gtk2hs pango font listing prog with -lefence and when I run it segfaults.
05:47:44 <shapr> Is his description of how to do it available?
05:48:00 <dcoutts> I must be stomping on something, but I'm not sure how to track it down
05:48:07 <JaffaCake> shapr: it's in the docs, I think
05:48:15 <shapr> Of ghc or valgrind?
05:48:19 <JaffaCake> valgrind
05:48:23 <shapr> ok, thanks.
05:48:34 <JaffaCake> dcoutts: you tried the GHC debugging recipe?
05:49:10 <dcoutts> JaffaCake, the "how to debug ghc when it segaults recipe"? as in what we'd do when porting ghc?
05:49:21 <dcoutts> with gdb etc
05:49:21 <JaffaCake> yup
05:49:26 <dcoutts> right, ok
05:49:41 <JaffaCake> it applies to any ghc-compiled prog, including ghc
05:49:46 <dcoutts> right
05:50:06 <dcoutts> shapr, yeah, one can give valgrind hints about areas of memory 
05:50:20 <dcoutts> shapr, eg they just did that for glib's new memory allocator
05:50:48 <dcoutts> shapr, so instead of switching to malloc/free when debugging they can just tell valgring how their own allocator works
05:51:21 <dcoutts> shapr, it didn't look that hard, just a few hints integrated into the allocation & free code
05:51:23 <drakioned> umm, can I ask a quick question about printing out strings to the command line?
05:51:58 <drakioned> is there anyway to modify the colour of the output text?
05:53:47 <shapr> JohnMeacham: directions in http://repetae.net/john/computer/jhc/libs/ say "make -t libs" but darcs pull -a && make jhc && make -t libs says "make: *** No rule to make target `libs'.  Stop." Am I missing something?
05:54:55 <shapr> drakioned: Probably need to use curses for that.
05:55:29 <audreyt> dons++ JaffaCake++ # Data.ByteString
05:55:35 <drakioned> curses?
05:55:44 <audreyt> just upgraded Pugs from the old FastPackedString, and it's 2x faster now!
05:56:04 <JaffaCake> audreyt: nice!
05:56:05 <audreyt> (and also converted Pugs internals ot use inlinePerformIO where sensible)
05:56:14 <audreyt> but STM is opaque, so there's no inlinePerformSTM?
05:56:39 <JaffaCake> audreyt: you need to be really careful with inlinePerformIO
05:56:49 <drakioned> would that still be platform independant?
05:57:01 <JaffaCake> unsafePerformIO isn't inlined by default for some very good reasons
05:57:09 <audreyt> yeah, I pretend that it'll be executed immesuably many times
05:57:10 <boegel> anyone how I can make time spit milliseconds or something like that? man page doesn't really help :(
05:57:31 <audreyt> and for program parts that can't survive with that, I use unsafePerformIO + NOINLINE + -no-full-cse
05:57:42 <JaffaCake> audreyt: ok, cool
05:57:52 <audreyt> er, I mean -fno-full-laziness -fno-cse
05:58:26 <JaffaCake> I don't think -fno-full-laziness actually means "exactly this much sharing and no more"
05:58:44 <dons> just finished running the testsuite with Data.ByteString added :)
05:58:48 <JaffaCake> the simplifier can sometimes float things out
05:58:56 <musasabi> shapr: if you don't have much memory (and patience) just wget the hl-files.
05:58:56 <audreyt> dons: see the CStringLen patch?
05:59:06 <audreyt> dons: in Data.Yaml.Syck I always know the size, and there may be nulls
05:59:09 <JaffaCake> dons: great!
05:59:09 <audreyt> so strlen can't be used
05:59:35 <dons> patches recorded. looks good. I'll jsut check out the behaviour on linux and then send it.
05:59:42 <shapr> musasabi: I've got 'em
06:00:04 <dons> audreyt: did I see the patch? no. 
06:00:09 <musasabi> shapr: you don't need a "make libs". Now just install them (via the make install).
06:00:35 <audreyt> dons: http://perlcabal.org/~autrijus/tmp/copyCStringLen.diff
06:01:11 <dons> audreyt, so you've tried out fps 0.5?
06:01:17 <dons> should be a lot faster all over the place
06:01:39 <audreyt> dons: Pugs is now 2x faster
06:01:47 <dons> whoa. excellent.
06:01:52 <audreyt> thanks entirely from that, as well as strategic use of inlinePerformIO in internals
06:02:08 <dons> yeah, this patch of yours looks good. I apply it. cheers.
06:02:12 <audreyt> thanks :)
06:02:32 <musasabi> dons: for the JHC&fps, JHC is at the moment missing ForeignPtr (although a dummy would be easy to add).
06:02:34 <audreyt> also, Pugs src/ is going to be MIT-licensed real soon now
06:02:41 <SamB> I thought inlining *PerformIO was dangerous?
06:02:46 <audreyt> so Data.Yaml.Syck, the PArrows extensions, etc
06:02:47 <dons> musasabi: yeah, I spoke to John about it.
06:03:04 <audreyt> can be reused in ways compatible with BSD :)
06:03:44 <musasabi> Should find the time to integrate those and overhaul PArrows to the new fps.
06:04:03 <int-e> dons: hmm, is http://www.cse.unsw.edu.au/~dons/code/yi+gtk/src/Yi/UTF8.hs current? the comment for inlinePerformIO reads: -- Just like inlinePerformIO, but we inline it. -- I'm sure you mean unsafePerformIO there :)
06:05:03 <SamB> so why does the GHC documentation and/or source say to be careful about unsafePerformIO getting inlined?
06:05:25 <musasabi> SamB: think about "unsafePerformIO $ newIORef 0"
06:05:36 <SamB> oh, right.
06:05:40 <SamB> makes sense.
06:06:03 <dons> int-e, nope. that's from JaffaCake's packedstring code. quite a while back. but yeah, looks like one too many search-and-replaces :)
06:07:28 <JaffaCake> audreyt: great news about the licensing change
06:09:16 <audreyt> indeed. took me a week to work with licensing people :)
06:09:26 <audreyt> hopefully it'll be worth the trouble
06:14:25 <audreyt> JaffaCake: so, am I going to see you or SPJ this June? :)
06:22:05 <audreyt> (I'll be @ the Redmond site during 19~24th)
06:54:20 <shapr> musasabi: make install wants to rebuild my *.hl files.
06:55:23 <shapr> aha, make -t libs must do "touch *.hl"
06:55:28 * shapr boings
06:56:08 <araujo> morning!
06:57:24 <musasabi> shapr: did you get it installed?
06:58:03 <musasabi> shapr: I have one patch pending for Cabal (sent, but not yet in the official tree) that is needed if you want to use Cabal to build packages for JHC.
06:58:24 <goron> Is there any graph library which is *not* implemented with trees?
06:58:37 <dons> Data.Graph uses arrays, doesn't it?
06:59:04 <shapr> It installed, but now I get "Loading libraries: ["base-1.0"] \n Loading library: "base-1.0" @ "/usr/local/lib/jhc-0.1/base-1.0.hl" \n Bad ho file: /usr/local/lib/jhc-0.1/base-1.0.hl \n Loading library /usr/local/lib/jhc-0.1/base-1.0.hl failed due to missing dependencies"
06:59:17 <dons> goron, hmm, though I see it imports Data.Tree :) 
06:59:27 <dons> it does have: type Table a = Array Vertex a
07:00:18 <goron> dons: I was just looking at it, and I notices the same.
07:00:48 <dons> ah, maybe its' Data.Graph.Inductive that's the odd one out, then.
07:01:05 <goron> dff :: Graph -> Forest Vertex
07:01:10 <dons> oops. no. looks like Trees are useful for graphs, right ;)
07:01:25 <goron> dons: It imports Tree because of e.g. that function.
07:01:41 <dons> yep. I saw .
07:02:01 <dons> have you looked at Data.Graph.Inductive, its very nice.
07:02:02 <shapr> Wow cool, jhc --selftest fails.
07:02:08 <dons> hehe
07:02:13 <goron> dons: Ok, so if I want to hop from vertex to vertex in constant time, I need Data.Graph?
07:02:23 <dons> better than being succesfull, but wrong, eh?
07:02:43 <dons> goron, don't know. check the docs for either Data.Graph.Inductive or Data.Graph
07:02:47 <goron> dons: I have used Data.Graph.Inductive before, but now I need to use it for serious work. 
07:02:59 <goron> dons: Docs... what docs?
07:03:12 <dons> ah, I used it for the icfp05 contest, it held up extrememly well. maybe that wasn't serious. hmm.
07:03:25 <dons> @docs Data.Graph.Inductive
07:03:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive.html
07:03:42 <goron> dons: I http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive.html
07:03:50 <goron> Windows....
07:03:59 <musasabi> shapr: do you have latest darcs version? The ho-file format changed a few days ago.
07:04:00 <goron> I was looking at that already. 
07:04:03 <shapr> musasabi: does jhc --selftest pass for you?
07:04:10 <shapr> musasabi: I ran darcs pull -a before all this.
07:04:13 * shapr tries again
07:04:20 <xerox> G'day.
07:04:26 <shapr> Got the latest.
07:04:54 <musasabi> shapr: my version of jhc is the latest + some local patches which should not affect things. It is passing selftest.
07:05:15 <shapr> hiya carp 
07:05:19 <carp> anyone using the darwinports version of 6.4.2?
07:05:24 <carp> hi shapr
07:05:30 * shapr runs make clean
07:05:33 <carp> cabal doesn't seem to work for me :(
07:05:36 <pitecus> Is there a hashtable library with a functional interface?
07:05:42 <musasabi> shapr: try "./jhc --selftest" (you wouldn't possibly have an old jhc in path?)
07:05:57 <musasabi> pitecus: I have one. It is slower than Data.Map unfortunately.
07:06:12 <sjanssen_> goron: it looks like Data.Graph.Inductive.Tree.Gr is the only instance of the Graph class, and the docs for Gr say that it's tree based
07:06:13 <pitecus> oh
07:06:40 <pitecus> what went wrong, musasabi?
07:06:43 <goron> sjanssen_: Indeed, that's why I asked. 
07:06:53 <shapr> musasabi: Nah, it was the most recently installed jhc.
07:06:57 <musasabi> pitecus: DiffArray is the problem I think.
07:08:13 <musasabi> shapr: can you post the error somewhere? (and jhc --version and --version-context)
07:08:54 <musasabi> Mine is: jhc 0.1 20060427 (kityunrib+28)
07:09:13 <musasabi> (the pristine one)
07:09:53 <shapr> Sadly, I already did make clean, it's all gone.
07:10:17 <shapr> I do wish for debian/unstable jhc packages though :-)
07:10:17 <shapr> haskell-unsafe maybe?
07:11:06 <dons> pitecus, hmm, you could use an IntMap and roll your own keys?
07:11:09 <musasabi> shapr: It is changing so fast that there is not very much point in a package I think.
07:12:20 <musasabi> shapr: but if you think that there would be users it is entirely possible, but needs a fast build demon with lots of memory.
07:12:30 <pitecus> ever tried it dons? Does it work faster than Data.Map?
07:12:40 <dons> IntMap is faster, yeah.
07:12:48 <dons> a bit.
07:12:57 <araujo> hiya xerox 
07:13:00 <dons> the other option is to write a binding to a C table for the time being.
07:13:20 <dons> we contemplated this in the shootout entry that tests hashtables at one point.
07:14:00 <sjanssen_> we should have Data.CharMap
07:14:12 <sjanssen_> that'd make it easy to write a good trie for strings
07:14:18 <dons> Char8Map :P
07:14:18 <audreyt> you mean Data.StringMap?
07:14:22 <audreyt> (CharMap is just IntMap)
07:14:28 <audreyt> same range
07:14:44 <sjanssen_> audreyt: right, but newtype it and do the ord chr stuff transparently
07:15:06 <sjanssen_> otherwise it'd be a PITA to use
07:15:09 <dons> sjanssen_: yeah, speaking of tries, in the end kzm I think wrote a trie from scratch, and was much faster for the problem than any mutable hash table idea we could come up with.
07:15:20 <dcoutts_> I'd like a fast string map
07:15:27 <sjanssen_> tries are underrated, I think
07:15:35 <dcoutts_> aye
07:15:43 <dcoutts_> there are some Haskell tries about
07:15:45 <dons> dcoutts_: Map ByteString a works fine :)
07:15:52 <dons> it'll use memcmp on the keys.
07:16:05 <dcoutts_> I remember modifying one from being a set to a bag
07:16:08 <dcoutts_> dons, true
07:16:33 <dcoutts_> one nice thing about Data.Map is its indexed ops
07:16:33 <dons> lambdabot uses Map ByteString [ByteString] all over the place internally for plugin private states.
07:16:38 <audreyt> dcoutts_: there is a StringMap
07:16:51 <dcoutts_> that allow you to treat the map as an ordered sequence
07:16:55 <dcoutts_> audreyt, where?
07:17:06 <dons> ?google Data.StringMap
07:17:08 <lambdabot> http://comments.gmane.org/gmane.comp.lang.haskell.libraries/3641?set_blog_all=yes
07:17:16 <audreyt> dcoutts_: http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg08559.html
07:17:19 <dons> well, something like that.
07:17:38 <dcoutts_> yay
07:17:52 <pitecus> I tried to write a TrieMap once and it was about 3 times slower than Data.Map. 
07:18:47 <sjanssen_> I think I wrote a decentish trie once, lemme see if I have it
07:18:57 <musasabi> Data.Map is missing range queries.
07:19:18 <dons> here's the trie that kzm wrote for the shootout: http://haskell.org/hawiki/KnucleotideEntry#head-b08f8a92d7a1ba3c570fa2d115056a092202e825
07:19:27 <musasabi> range :: Ord k => k -> k -> Map k v -> [(k,v)]
07:19:51 <dons> actually, its easier to see here: http://haskell.org/hawiki/KnucleotideEntry#head-4abc9e39d0d156588f536811e2903fef2b3f9ef3
07:20:20 <dons> hehe, kzm wrote: "I guess this is considered cheating, since it is the easy and natural way to do it"
07:20:38 <xerox> audreyt: hey there
07:20:45 <pitecus> thanks
07:20:56 <audreyt> dcoutts: consider resolving GHC #772 if you do have anehave a need for StringMap...
07:21:08 <audreyt> xerox: hey there!
07:21:15 <xerox> audreyt: news about your projects?
07:21:16 <dcoutts_> audreyt, s'ok I'm not desperate, but thanks
07:21:43 <audreyt> xerox: $job day today... will fill in them tomorrow
07:21:51 <audreyt> hopefully not too late
07:21:53 <dcoutts_> audreyt, so if it's a drop in replacement, it'll have indexed operations too?
07:22:03 <audreyt> dcoutts_: I imagine so
07:22:04 <xerox> audreyt: ooh-kay.
07:22:18 <dons> @seen ozone
07:22:18 <lambdabot> ozone is in #haskell. I don't know when ozone last spoke.
07:22:35 <shapr> musasabi: How many Haskellers use Nokia 770 I wonder?
07:22:52 <dcoutts_> audreyt, I was implementing a directory GUI widget yesterday and needed an ordered list for a cache of the dir entries. I used Map String (), but I know that Map String isn't the most effecient.
07:23:04 <dons> shapr, exactly 2. but everyone else wants one.
07:23:09 <shapr> I know JohnMeacham and I both hav eone.
07:23:16 <dcoutts_> audreyt, but as I say, it's not desperate and I should probably be using packed strings anyway
07:23:23 <shapr> dons: JohnMeacham being the other?
07:23:28 <dons> right
07:23:47 <dcoutts_> shapr, yeah, I want one :-)
07:23:56 <dons> that or a zaurus.
07:23:59 <audreyt> dcoutts_: Set String
07:24:10 <dcoutts_> audreyt, it doesn't provide indexed ops
07:24:23 <shapr> dons: Does the Zaurus have any advantages over a 770?
07:24:26 <audreyt> mm. BitSet String?
07:24:30 <dons> it runs openbsd :)
07:24:45 <dcoutts_> shapr, my Zaurus died :-(
07:24:54 <dcoutts_> won't recharge anymore
07:25:06 <shapr> dcoutts_: 770 has a mobile switchable battery.
07:25:13 <shapr> er, 'mobile phone'
07:25:26 <shapr> My Palm IIIc died the same way, won't recharge anymore.
07:25:37 <dcoutts_> it was okish, had a full keyboard and one could ssh into it over a usb connection
07:25:41 <dons> dcoutts, hmm. interesting. my g/f siemens phone stopped recharging today..
07:25:42 <shapr> Heffalump's palm died that way too.
07:25:50 <dons> its a conspiracy!
07:25:55 <dcoutts_> but it wasn't that easy to code for
07:26:03 * xerox checks his ipod
07:26:03 <dcoutts_> I like the fact that the 770 uses gtk
07:26:19 <dcoutts_> rather than some emebeded version of Qt
07:26:22 <shapr> 770 can do ssh over usb. It doesn't include a keyboard, but I don't want a physical thumb-board myself.
07:26:28 <dcoutts_> hugs did run on my zaurus though
07:26:40 <xerox> hehe, nice!
07:26:41 <sjanssen_> dcoutts_: hugs on Zaurus was 'da bomb!
07:26:47 <dcoutts_> heh
07:26:48 <dons> can you get in over wifi though, on the 770?
07:27:00 <dons> oh, i guess you could use a usb wifi dongle
07:27:12 <dcoutts_> shapr, have you seen dasher? I wonder if that'd be a good text input system for the 770
07:27:28 <shapr> I'm ordering new parts for my broken kinesis, I figure I'll embed the USB keyboard power components into my kinesis and strap the 770 onto it.
07:27:34 <shapr> That'll be the ultimate laptop.
07:27:41 <dcoutts_> shapr, you logged in here the other day from your 770 didn't you?
07:27:46 <shapr> Sure, several times.
07:27:47 <dcoutts_> over wifi
07:27:59 <shapr> dons: Yeah, the OpenSSH debs run a server as well.
07:28:07 <shapr> I haven't tried the dropbear ssh debs.
07:28:26 <dons> here's a nice zaurus/openbsd picture: http://openbsd.org/images/zaurus-c3000.jpg  
07:28:30 <dcoutts_> shapr, what's that about a keyboard?
07:30:31 <shapr> The 770 has a usb port but cannot power external devices via usb. Some smart cookie figured out how build a USB power repeater with a penguin mints tin and a 9v battery.
07:31:08 <shapr> The kinesis keyboard has enough internal space to mount the power repeater and *lots* of batteries inside the keyboard.
07:31:48 <xerox> Penguin mints tin?
07:32:12 <shapr> I have a spare broken kinesis keyboard, and I'd be able to use the 770 as a 'real laptop' if it had a keyboard.
07:32:18 <petekaz> the kinesis is awesome 
07:32:32 * shapr agrees
07:32:38 <petekaz> coupled with dvorak 
07:32:47 <shapr> Yup, I use a heavily modified dvorak layout.
07:32:52 * petekaz has a qwerty kinesis, but types dvorak.
07:33:03 <shapr> I use the "I am not a koala" layout.
07:33:21 <petekaz> not familiar with that layout.
07:33:37 <shapr> I made it up myself :-) It moves all the modifier keys under the thumbs.
07:33:56 <shapr> 'Emacs pinky' comes from trying to chord with a pinky... but I am not a koala, I do not have two thumbs.
07:34:09 <shapr> Therefore, all chording keys should be under my thumbs.
07:34:19 <petekaz> This 770 thing looks pretty nice.  Do you guys actually use it?  Everyone I know that has ever bought a PDA-like thing eventually ends up not using it after the wow factor runs out.
07:34:57 <petekaz> shapr: me too, except shift.
07:35:07 <shapr> I really like the 770. It runs a modified debian linux. The best part is the Nokia dev community. They hang out on #maemo and they're very responsive.
07:35:13 <petekaz> I have Ctl/Alt/Esc under my thumbs.
07:35:26 <liyang> I concur. The only exceptions have been my Palm III and iPod.
07:35:45 <petekaz> liyang: good point, I use my ipod all the time.
07:36:07 <petekaz> shapr: how long have you had your 770?  In 6 months we should ask again :-)
07:36:19 <Philippa> if I got a 770 it'd primarily be for reading my paper collection next door instead of in here...
07:36:23 <shapr> I swapped Shift_L and DEL, and I have hyper and super in place of home end/pgdn, home/pgup.
07:36:42 <shapr> Philippa: The PDF performance is worthwhile with the update of two days ago.
07:37:22 <Philippa> can it do plain postscript yet or do I start batch converting?
07:37:26 <petekaz> shapr: you don't mind reading PDFs on that 770?
07:38:12 <shapr> petekaz: I got mine Jan 5th
07:38:22 <shapr> Philippa: batch convert :-)
07:38:39 <shapr> ps2pdf output works fine though.
07:39:25 <shapr> petekaz: Nah, the screen resolution is highest I've seen on a PDA, I only wish the PDF viewer would rotate 90 so I wouldn't have to scroll so often.
07:40:26 * petekaz is intrigued 
07:40:59 <petekaz> I still have my Apple Newton, it's a book end on my bookshelf :-)
07:41:19 <shapr> I've been a lot more intrigued since I discovered JohnMeacham's JHC can create ANSI C that runs on the 770.
07:41:22 <liyang> petekaz: and I only used my PalmIII (and TI-86 too I guess) as boredom relief at school.
07:41:28 <shapr> ooh, I loved the newton.
07:41:46 <shapr> I never could afford one, but they sure were cool.
07:41:54 <jip> what can you guys tell me about ST?
07:42:00 <shapr> It's a monad!
07:42:11 <petekaz> I fired mine up the other day .. still had network diagrams I drew on it way back when.
07:42:36 <Philippa> jip: it gives you mutable storage. Take a look at Data.STRef for most of the operations you can perform in it
07:42:38 <shapr> I met the guy who wrote NewtonScript a few years back, it was cool to hear how he got inspiration from Self.
07:43:17 <shapr> Someone got the NewtonOS booting on some other PDA recently... The Zaurus?
07:44:13 <jip> Philippa: yeah, i've figured out how it works and how to use it, and i even read that 1994 article by spt. i guess i'm asking if it really is a lot faster then the regular State monad?
07:44:24 <shapr> petekaz: Anyway, the 770 is really cheap for a Linux PDA, and the next version of the 'Internet Tablet OS' will have apt-get, so I think it's worthwhile.
07:44:57 <lispy> shapr: shiney
07:45:00 <petekaz> shapr: so if I get the 770, it'll be able to run this next version OS?
07:45:05 <shapr> yup
07:45:10 <shapr> I've upgraded mine twice so far.
07:45:26 <shapr> The devs on #maemo say they'll have a debian/unstable equivalent soon.
07:45:35 <petekaz> cool ... adding to my wishlist (now if only the wife would look at it every once in a while)
07:46:19 <shapr> I've been canvassing for complete public read access to the source repos.
07:46:44 <shapr> Right now it's only about 95%, not quite enough to build a totally custom image.
07:47:20 <shapr> I am enthusiastic about the 770, but do not expect to be able to run GHC on it. :-)
07:50:17 <musasabi> Anyone know how difficult it would be to compile away the continuation passing style IO overhead? "imperative functional programming" just says that it is there, but does not comment about how hard it would be to optimize away.
07:51:27 <musasabi> shapr: if you just want to play with jhc I can provide you with a recent working binary.
07:52:41 <shapr> musasabi: Mostly I want to know if jhc will let me build Fermat's Last Margin. I'd like to annotate papers while I read them. You know of any reasons Flippi wouldn't build with JHC?
07:53:08 * musasabi darcs gets flippi
07:54:16 <musasabi> shapr: appears that snowblind.scannedinavian.org DNS does not work.
07:54:20 <shapr> Er, that's true.
07:54:23 <shapr> oops
07:54:54 <Philippa> shapr: does it handle mutually recursive modules in some way? You might be stuck with 0.03 and some hackery
07:55:06 * shapr dunno
07:56:00 <musasabi> Philippa: it handles recursive modules with no hackery.
07:56:11 <musasabi> is there a working repo somewhere?
07:57:24 <shapr> I think the only one is on my drive...
07:58:55 * musasabi plays with Flippi 0.3
08:00:30 <shapr> It does build with jhc?
08:02:34 <musasabi> There are minor syntax problems at least. Is "(try $ do foo; bar;)" or should it be "(try $ do foo; bar)" ?
08:02:42 <musasabi> +legal
08:03:49 <Igloo> Both are legal
08:06:13 <musasabi> ok, then the JHC parser is just too picky there.
08:14:27 <dons> JaffaCake, I've sent in my Data.ByteString patches :)
08:14:40 <JaffaCake> nice, I'll take a look on Monday
08:14:54 <dons> JaffaCake, ah, but I see they "awaits moderator approval"
08:15:12 * JaffaCake moderates
08:15:13 <dons> 100k patches are too big, it seems.
08:15:25 <shapr> Man I hate files named {paper,thesis}.{pdf,ps}
08:15:43 <shapr> musasabi: Thanks for trying :-)
08:19:57 <Philippa> musasabi: the only repo online I know of's shapr's
08:27:11 <ihope> @index Regex
08:27:11 <lambdabot> Text.Regex.Posix, Text.Regex
08:27:20 <ihope> Cool.
08:27:26 <ihope> @docs Text.Regex
08:27:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
08:35:05 <dcoutts_> shapr, http://valgrind.org/docs/manual/mc-tech-docs.html#mc-tech-docs.pranges
08:35:15 <dcoutts_> shapr, re your SoC C parser idea
08:35:38 <dcoutts_> they're talking about pre-processing C code to do more valgrind instrumentation
08:35:49 <dcoutts_> and doing that pre-processing using Haskell
08:36:13 <dcoutts_> since it rocks and there are C parsers & pretty printers available
08:36:26 <dcoutts_> shapr, so that's the other side: the pretty printing
08:41:13 <davidhouse_> what would people recommend as a pcre library?
08:41:20 <jip> dcoutts: that's the guy who did some code generation work for ghc
08:41:29 <dcoutts_> yes
08:42:02 <dons> davidhouse_: JRegex
08:42:05 <dons> ?where JRegex
08:42:05 <lambdabot> I know nothing about jregex.
08:42:09 <dons> ?where MissingH
08:42:10 <lambdabot> http://quux.org/devel/missingh
08:42:48 <dons> davidhouse_: or Text.Regex.Lazy
08:43:04 <dons> either way, you can find them and more on the libraries and tools page of haskell.org
08:48:48 <davidhouse_> dons, thanks.
08:50:52 <sjanssen_> @keal
08:50:52 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
08:50:57 <sjanssen_> @quote
08:50:58 <lambdabot> ndm says: the only language i've seen which is ugly at a deeper level than syntax is perl
08:56:03 <pitecus> Is FastPackedString.hGetContents lazy just like the one from Prelude?
08:56:21 <sjanssen_> pitecus: no
08:56:29 <davidhouse_> does JRegex automatically build with PCRE support?
08:57:44 <pitecus> I was afraid it wasn't
08:57:57 <sjanssen_> pitecus: do you want to lazily read a file?
08:58:48 <pitecus> Yeah, a UTF8 file
08:59:01 <sjanssen_> how about mmapFile then?
08:59:19 <Igloo> There is a lazy file reading function (or at least, there is in darcs)
08:59:20 <sjanssen_> it uses operating system support for lazy IO
09:00:39 <pitecus> Hoogle returns no results for mmapFile
09:01:02 <sjanssen_> @where fps
09:01:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
09:01:19 <pitecus> Ah its also in FPS, OK
09:03:10 <pitecus> Hm can I use it to read lazily from stdin?
09:03:27 <sjanssen_> I don't think so
09:03:45 <dcoutts_> you could lazily read chunks
09:04:01 <dcoutts_> but not one big ByteString
09:04:42 <sjanssen_> why doesn't Data.ByteString have a function to get a string of a certain length?
09:06:12 <pitecus> I want a version of (h)GetContents thats treats the input as UTF8 rather than Latin1. I've implemented it using functions from FPS + a UTF8 module I found, but I messed the laziness.
09:06:50 <sjanssen_> pitecus: there isn't a UTF8 packedstring yet, but there are plans afoot
09:07:36 <pitecus> sjanssen, I don't particularly need a UTF8 packedstring, just a normal UTF8 string would do :)
09:08:04 <musasabi> pitecus: which operations do you need on the string?
09:08:04 <sjanssen_> also something that you'd have to code up yourself, I think
09:09:08 <pitecus> The latest version of ghc is funny in that respect: it treats source files as UTF8, but all other files as Latin1. The rationale behind that eludes me.
09:09:20 <musasabi> (there are utf8 packedstring implementations around)
09:09:29 <musasabi> depends on what is needed
09:10:56 <pitecus> musasabi, I just need IO functions that read input as UTF8, and return proper unicode strings, either packed or normal list of chars.
09:12:14 <davidhouse_> does JRegex automatically build with PCRE support?
09:12:45 <musasabi> The packedstring in JHC sources does that I think. Note that there are very few things you can do with proper unicode strings in Haskell.
09:13:45 <pitecus> Well I can upcase/downcase them and count the characters in them correctly, that's quite enough for now.
09:14:04 <davidhouse_> is there a .ghc file i can set default flags for?
09:14:19 <davidhouse_> e.g. i want to add a certain directory to my search path permanently.
09:14:40 <dcoutts_> davidhouse_, no
09:14:52 <dcoutts_> there's a .ghci file but that's only for ghci
09:15:00 <davidhouse_> right.
09:15:07 <jip> makefiles are good i guess
09:15:08 <dcoutts_> there is deliberately no env vars or extra .conf files for ghc
09:15:32 <dcoutts_> or make a dummy package and depend on that
09:16:11 <dcoutts_> or make the modules in your extra seach path into a package
09:16:29 <davidhouse_> yes, how is that done? does/can cabal do that?
09:16:35 <dcoutts_> yes
09:16:44 <dcoutts_> that's what Cabal is for
09:17:25 <davidhouse_> ah. not just a nice automated make then.
09:20:00 <musasabi> pitecus: what do you mean with count the characters?
09:20:24 <musasabi> pitecus: do you mean "count the physical unicode characters" or "count the characters as displayed to the user" ?
09:20:47 <musasabi> toUpper and toLower should work fine.
09:21:09 * resiak suspects he saw dcoutts_ in Nationwide today
09:21:22 * dcoutts expects that resiak is right
09:21:32 <resiak> Thought so :)
09:21:36 <dcoutts_> heh
09:21:37 <jip> cool what's that?
09:21:47 <resiak> It's a building society
09:21:49 <dcoutts_> boring
09:21:57 <pitecus> musasabi, well I don't care about combining chars right now. As long as I get character count and not byte count it's OK
09:22:28 <pitecus> I think it  works  fine, once you have a unicode string
09:22:47 <pitecus> The problem is reading input AS UTF8
09:27:48 <davidhouse_> @index FileName
09:27:49 <lambdabot> bzzt
09:28:04 <bourbaki> moin
09:28:22 <jip> can an STRef contain anything? can it contain an infinite list? isn't it supposed to be strict?
09:28:39 <bourbaki> is there any leighweight haskell compiler that i can embed into c++?
09:29:34 <ndm> bourbaki: maybe Yhc, its being embeded into Python
09:29:46 <jip> @where Yhc
09:29:46 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
09:29:49 <bourbaki> thx
09:29:52 <musasabi> pitecus: did you check the JHC packedstring?
09:30:51 <pitecus> musasabi, I'm looking at it now but I can't find any IO functions
09:32:30 <davidhouse_> @hoogle FileName
09:32:31 <lambdabot> System.Console.Readline.filenameCompletionFunction :: String -> IO [String]
09:32:31 <lambdabot> IO.ioeGetFileName :: IOError -> Maybe FilePath
09:32:31 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
09:32:39 <davidhouse_> @hoogle FilePath
09:32:40 <lambdabot> Distribution.Compat.FilePath :: module
09:32:40 <lambdabot> Prelude.FilePath :: type FilePath
09:32:40 <lambdabot> Distribution.Compat.FilePath.breakFilePath :: FilePath -> [String]
09:33:04 <davidhouse_> @hoogle String -> FilePath
09:33:05 <lambdabot> Distribution.Compat.FilePath.changeFileExt :: FilePath -> String -> FilePath
09:33:05 <lambdabot> Distribution.Compat.FilePath.joinFileExt :: String -> String -> FilePath
09:33:05 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
09:33:56 <musasabi> pitecus: they are commented out at the moment, but the code is working I think.
09:35:09 <musasabi> or take the fromUTF and use that with fps.
09:35:27 <pitecus> musasabi, It says in a comment: file is assumed to be ISO-8859-1.
09:35:54 <pitecus> musasabi, the latter is what I'm doing now, but then I get IO functions which are string
09:35:58 <pitecus> strict
09:36:11 <pitecus> And I want them to be lazy
09:42:05 <hyrax42> >>= is concatMap in list monad?
09:43:23 <musasabi> pitecus: do you see the encoding/decoding functions?
09:43:31 <Saulzar> concatMap with 1st 2 args flipped
09:44:00 <hyrax42> yeah
09:44:52 <hyrax42> so `flip concatMap` could go in place of >>=?
09:45:05 <hyrax42> or maybe needs brackets?
09:45:20 <mauke> > `flip concatMap`
09:45:21 <lambdabot>  parse error on input ``'
09:45:21 <pitecus> musasabi, the utf8 decoding function needs a list of Word8. I don't know how to lazily read input into such list
09:45:55 <hyrax42> hm you can't do that it seems
09:46:16 <audreyt> @pl ops f = map (f . tail) . sort . map (\x -> (chr (0x10FFFF - length x):x))
09:46:16 <lambdabot> ops = (. (sort . map ((:) =<< chr . (-) 1114111 . length))) . map . (. tail)
09:46:28 <SyntaxNinja> ooh, wadler is on planet.haskell
09:46:56 <dcoutts_> pitecus, you don't need to go via a list when doing the utf8 decoding
09:48:24 <pitecus> dcoutts, So can you sketch how I implement a lazy getContents which treats input as UTF8
09:48:40 <dcoutts_> pitecus, what's the final type?
09:48:47 <pitecus> String
09:49:00 <dcoutts_> as in [Char] ?
09:49:14 <pitecus> yep, string of unicode characters
09:49:23 <dcoutts_> that's easy, I thought you were looking for something effecient
09:49:37 <dcoutts_> you just compose with a lazy utf8 decoder
09:49:49 <dcoutts_> and that'll give you a lazy unicode String
09:51:30 <dcoutts_> getContentsUTF8 = liftM fromUTF8 getContents
09:51:45 <pitecus> dcoutts, the utf8 decoder expect a list of Word8, how do I get that? Use GHC's getContents which gives [Char] and convert that to [Word8]?
09:52:06 <dcoutts_> use one that takes String -> String instead
09:52:15 <dcoutts_> eg the one in gtk2hs
09:53:05 <pitecus> OK, I'll have a look
09:53:06 <dcoutts_> or map ord
09:53:17 <Igloo> map (fromIntegral . ord)
09:53:29 <dcoutts_> getContentsUTF8 = liftM (fromUTF8.map (fromIntegral.ord)) getContents
09:54:04 <pitecus> Thanks
09:54:58 <pitecus> BTW do you know if there are plans for GHC to support IO in encodings other than Latin1, so people don't have to roll their own?
09:55:36 <musasabi> There has been lots of talk for data ByteString.UTF8
09:57:03 <pitecus> musasabi, I something simpler, just being able to specify what encoding should be used when opening a file etc. Just assuming Latin1 is strange.
09:59:25 <musasabi> pitecus: yes, something like that would be nice. "readFileWithEncoding :: Encoding -> FilePath -> IO String" ?
10:00:33 <pitecus> musasabi, exactly
10:01:16 <pitecus> Also using the locale encoding by default would be nicer than using Latin1 by default...
10:01:53 <musasabi> pitecus: that would break every app using binary files...
10:03:09 <pitecus> Probably. Arguably though such apps should be using binary IO and not read Chars.
10:03:41 <sjanssen_> yes, we need to solve the IO problem once and for all
10:03:50 <musasabi> except there is no standard way to do that. Of course one can use Foreign....
10:04:21 <sjanssen_> I mean a segregated binary/text interface
10:04:59 * dcoutts_ agrees with sjanssen_
10:05:08 <musasabi> yes, that would be a nice thing, but that is not currently provided.
10:05:49 <musasabi> I think having both a new binary and text interface rather than changing the semantics of the current ones makes sense.
10:05:52 <jip> we need fread and fwrite
10:14:33 <sethk> the equivalent of fread and fwrite already exist
10:14:41 <davidhouse_> @index find
10:14:41 <lambdabot> Data.List
10:14:55 <davidhouse_> for some reason i thought that was Prelude.
10:15:37 <davidhouse_> @type catMaybes
10:15:38 <lambdabot> forall a. [Maybe a] -> [a]
10:15:52 <davidhouse_> > catMaybes [ Just 4, Just 6, Nothing, Just 10]
10:15:54 <lambdabot> [4,6,10]
10:16:54 <pitecus> > 42
10:16:56 <lambdabot> 42
10:17:37 <davidhouse_> is there a function for finding the first Just in a list?
10:18:01 <davidhouse_> find isJust doesn't quite work (the resulting type has too many Maybes)
10:18:17 <davidhouse_> > Just 4 `mplus` Just 6
10:18:18 <lambdabot> Just 4
10:18:25 <mauke> @hoogle [Maybe a] -> [a]
10:18:26 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
10:18:27 <davidhouse_> so a fold with mplus would work.
10:18:35 <davidhouse_> @hoogle [Maybe a] -> a
10:18:36 <lambdabot> No matches, try a more general search
10:18:47 <mauke> head . catMaybes
10:18:54 <davidhouse_> @type msum
10:18:55 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
10:19:22 <davidhouse_> mauke: that'll error if it's a list of entirely Nothings.
10:19:29 <fons> hello
10:19:35 <davidhouse_> @fptools Control.MonadPlus
10:19:36 <lambdabot> Control.MonadPlus not available
10:19:38 <davidhouse_> @fptools Control.Monad
10:19:39 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
10:20:36 <fons> can anyone tell me if there's a way to use showprec so that I doesn't show parenthesis if the association of the constructor doesn't require them?
10:20:45 <fons> for example
10:20:47 <dcoutts_> fons, no
10:20:55 <dcoutts_> it doesn't do associativity
10:21:00 <dcoutts_> it says so in the docs
10:21:15 <fons>  1 :+: 2 :+: 3
10:21:21 <fons> *Main> 1 :+: 2 :+: 3
10:21:26 <fons> 1.0 + (2.0 + 3.0)
10:21:31 <dcoutts_> or rather it can't eliminate brackets tdue to associavity
10:21:45 <fons> :+: is a right aossiciative operand
10:21:51 <fons> (or constructor)
10:21:59 <fons> ok dcoutts , thanks
10:22:01 <dcoutts_> you'll need a more sophisticated pretty printer lib
10:24:21 <fons> dcoutts_,  where in the documentation did you read it?
10:26:00 <dcoutts_> fons, http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Show.html#t%3AShow
10:26:47 <fons> ok
10:30:23 <davidhouse_> @pl \(x:y:[]) -> [x,y]
10:30:24 <lambdabot> (line 1, column 7):
10:30:24 <lambdabot> unexpected "["
10:30:24 <lambdabot> expecting natural, identifier, "_" or "("
10:30:32 <davidhouse_> err
10:30:37 <davidhouse_> @pl \(x:y:[]) -> (x,y)
10:30:39 <lambdabot> (line 1, column 7):
10:30:39 <lambdabot> unexpected "["
10:30:39 <lambdabot> expecting natural, identifier, "_" or "("
10:30:45 <davidhouse_> ^^ is there a function to do that?
10:30:53 <davidhouse_> @hoogle [a] -> (a, a)
10:30:54 <lambdabot> No matches, try a more general search
10:31:35 <Beelsebob> davidhouse_: f x = (head x, head $ tail x)
10:31:54 <davidhouse_> that's a "no" then :)
10:32:08 <davidhouse_> @pl f x = (head x, head $ tail x)
10:32:10 <lambdabot> f = liftM2 (,) head (head . tail)
10:32:44 <davidhouse_> > let f = (head &&& (head . tail)) in f [1..4]
10:32:46 <lambdabot> (1,2)
10:33:10 <davidhouse_> > let f = head &&& (head . tail) in f [1..4]
10:33:12 <lambdabot> (1,2)
10:33:19 <davidhouse_> > let f = head &&& head . tail in f [1..4]
10:33:20 <lambdabot> (1,2)
10:33:23 <davidhouse_> nice.
10:33:42 <DeliQ> @type liftM2
10:33:43 <lambdabot> forall r (m :: * -> *) a2 a1.
10:33:43 <lambdabot>     (Monad m) =>
10:33:43 <lambdabot>     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:44:14 <fons> anyone with some experience using Prasec?
10:44:16 <fons> Parsec
10:44:33 <fons> I hava programmed a parser and I have some questions regarding it
10:46:49 <SyntaxNinja> fons: if you don't get an answer here, post to a mailing list and someone will probably help you.
10:47:02 <fons> thanks SyntaxNinja 
10:47:09 <davidhouse_> fons, but ask here anyway :)
10:47:29 <fons> I'm uploading the source so that it can be easy for you to understand
10:47:31 <fons> :)
10:50:40 <dcoutts_> fons, usually the trick is to ask rather than asking to ask
10:50:50 <fons> I know, sorry
10:50:57 <fons> I'm preparing everything to be readable
10:51:01 <fons> than I wiill ask
10:51:22 <dcoutts_> because people won't volunteer when they don't know that they'll know the answer but they will answer when they can see the problem
10:51:45 <sethk> dcoutts, but what if they know that they don't know that they know the answer?
10:51:52 <sethk> :)?
10:52:25 <dcoutts_> sethk, ah well you see, there are known knowns and ....
10:52:29 <dcoutts_> ;-)
10:53:52 <dcoutts_> sethk, if they know that they don't know that they know the answer then they probably wont answer
10:54:14 * dcoutts_ spent some moments decoding that sentance
10:54:42 <sethk> dcoutts, we should write a parser for _that_  :)
10:54:45 <dcoutts_> they're certain about their own unsertainty to wether they know the answer to the question
10:54:46 <dcoutts_> hah
11:04:45 <xerox> @yow
11:04:46 <lambdabot> I'm GLAD I remembered to XEROX all my UNDERSHIRTS!!
11:16:41 <fons> where can ai find a gpl header for haskell?
11:16:46 <fons> (I'm lazy I know)
11:16:57 <jip> a gpl what?
11:17:28 <fons> a header indicating that the sourcecode has a GPL license
11:23:58 <sethk> fons, just about any compiler source file
11:24:22 <fons> ok thanks sethk 
11:34:41 <ndm> fons, if all you are doing is showing us non-working code, you can probably get away without a GPL header :)
11:35:54 <fons> ndm, it's working :)
11:36:04 <fons> it just needs some polish
11:36:50 <ibid> uh, gpl headers are not specific to haskell :)
11:37:22 <ibid> and not nearly all compiler source files are gpld :)
11:37:59 <fons> aht was the adress of the place where to upload code?
11:38:05 <fons> the url I mean
11:38:19 <fons> I'm sorry but I don't use irc too much lately
11:39:31 <ndm> @paste
11:39:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:40:36 <ndm> lisppaste2: @url
11:40:36 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:41:59 <lisppaste2> fons pasted "Expr.hs" at http://paste.lisp.org/display/19476
11:43:02 <lisppaste2> fons pasted "ExprParser.hs" at http://paste.lisp.org/display/19477
11:43:11 <fons> ok, here we go
11:43:26 <fons> I made an expression parser
11:43:43 <fons> to fill-in the data type Expr contained in Expr.hs
11:44:10 <fons> the problem comes when parsing a line such us " xsjkhsdkjhds "
11:44:17 <fons> such as, sorry
11:44:47 <fons> the parser recognices a variable x, and the stops parsing instead of giving an error
11:44:59 <ndm> fons, eof
11:45:04 <ndm> just make it parse eof at the end
11:45:12 <ndm> do {myparser; eof}
11:45:53 <fons> ndm, it is a lexem parser, so it should eat any whitespaces
11:46:00 <jip> @seen Saulzar 
11:46:01 <lambdabot> Saulzar is in #haskell. I last heard Saulzar speak 2 hours, 2 minutes and 29 seconds ago.
11:46:17 <ndm> fons, eof, end of file
11:46:42 <fons> ndm, ok, sorry, but anyway, that's not how the grammar should work
11:46:50 <fons> I mean, it's a line by line parser
11:47:25 <fons> It "should" give an error if the input doesn't match with it's equivalent grammar
11:47:34 <fons> obviously I did something wrong
11:47:38 <fons> that I cannot find
11:47:58 <ndm> i still think it sounds like you want eof
11:48:09 <ndm> that means you want to have the input finish, so it doesn't just parse a prefix
11:48:19 <sethk> fons, remember that it isn't line oriented
11:48:33 <sethk> fons, unless you force it to be
11:49:45 <fons> sethk, you can do that by forcing a test
11:49:59 <sethk> fons, yes, I know
11:50:24 <fons> but it doesn't work anyway
11:50:33 <sethk> fons, the problem may be that you think you forced a test, but in fact you didn't
11:52:05 <fons> I did
11:52:46 <jip> is there like a hello world for ST monad and STRef?
11:52:52 <fons> sethk, use parseTest with whiteExpr
11:53:37 <fons> *ExprParser> parseTest whiteExpr "aasasa"
11:53:37 <fons> a
11:53:48 <sethk> fons, clearly something is working differently than you think it is, right?
11:54:11 <fons> sethk, yes, that's for sure, otherwise I wouldn't be asking ;)
11:54:38 <sethk> fons, maybe that's not the area that's broken, you may be right about that, but you have to double check everything.
11:55:53 <jip> let's say i have a function, increment num = modifySTRef num (+1)
11:56:14 <jip> how can i now make a main :: IO (), that will print out the value of num, then call "increment" on the state, and then print out the new value?
11:57:35 <fons> sethk, I've been trying to check
11:57:36 <fons> :S
11:58:48 <sethk> jip, you can't
11:58:53 <Cale> jip: STRefs exist in ST, you can't get one from outside the ST monad
12:00:31 <Cale> you could do something like: main = do x <- readLn; let y = runST (do r <- newSTRef x; increment r; readSTRef r); print x; print y
12:00:39 <jip> Cale: hm... well my plan is that main will create the STRef, and then pass it in as the argument to increment
12:00:41 <araujo> Hello!
12:00:43 * araujo throws lambdas at everyone
12:00:50 <Cale> jip: not possible
12:01:05 <Cale> jip: newSTRef :: a -> ST s (STRef s a)
12:01:08 <jip> Cale: hm... but if i used IORef instead of STRef then this would work
12:01:14 <Cale> yes
12:01:24 <Cale> IORefs are creatable/accessible from IO
12:01:24 <jip> so how come i can't somehow embed an ST inside IO?
12:02:08 <Cale> you can run ST computations, which produce pure values
12:02:18 <Cale> they can't return STRefs though
12:02:54 <Cale> there is in fact a function called stToIO
12:03:02 <Cale> but it's most likely not what you want
12:05:26 <Cale> well, it would let you get an STRef out into IO, but it would have type STRef RealWorld t
12:05:36 <jip> i'm pretty sure that i want to use STRefs(and STArray), and i need to somehow extract the values into IO, and i don't want to use runST
12:05:42 <Cale> Which would prevent it from being used in pure ST computations.
12:05:54 <jip> Cale: that might be ok!
12:05:55 <Cale> why don't you want to use runST?
12:06:49 <jip> because the way i understand it, that lets me get the final result of an ST computation
12:06:55 <jip> but what i need are a lot of intermediate states
12:07:03 <Cale> hmm
12:07:20 <Cale> What are you extracting the intermediate states for?
12:07:26 <jip> you remember what i'm doing?
12:07:36 <Cale> can't you just return them?
12:08:23 <jip> i'm not sure. basicly i'm doing a simulation, right now i have "updateSim :: State -> (State, Result)"
12:08:36 <jip> after every update, i need to display the result in the IO monad
12:08:51 <jip> i want to convert to using STRefs and STArray for the state, for performance reasons
12:09:14 <jip> but i'm pretty confused on what the best way to do this is
12:10:25 <mahogny> is drakioned here?
12:10:40 <jip> the "Result" is actually just some stuff extracted from the state. it would be nice if i actually had access to the complete state in the IO monad between updates
12:21:09 <jip> any thoughts?
12:34:43 <Lor> jip, you can't extract the state, since then you could theoretically use the same state twice for further st computations.
12:35:39 <Lor> What you want would probably be more feasible with Clean-like uniqueness types..
12:35:42 <ValarQ> how do i emulate the regexp command '?' in parsec?
12:36:41 <jip> Lor: hm.... i'm not sure i totally agree with you
12:37:16 <Lor> what's wrong with stToIo?
12:38:30 <mauke> ValarQ: option
12:42:12 <ValarQ> mauke: thanks
12:48:05 <mahogny> xerox, hrm. now I think I have gotten an application for each of the topics I put on the page. is it just me or is the interest high? o_O
12:48:27 <xerox> It would be cool either ways :-)
12:49:21 <mahogny> has anyone been accepted as a mentor yet? still pending
12:50:08 <xerox> I don't know.
12:50:51 <mahogny> hrrm. phd's also apply for these stipends? I thought they already had work enough :)
12:53:03 <jip> xerox: what's up?
12:53:50 <xerox> jip: all work and no play makes xerox a dull boy.
12:55:37 <jip> welcome to my world
12:56:10 * araujo looks around
12:57:12 <jip> xerox: did you happen to read my troubles with STRef a few lines up?
12:58:00 * xerox pokes Refs with a stick and runs away screaming as they mutate
12:58:26 <ihope> Hmm...
12:58:27 <jip> hm..... cute, but i need mutation!
12:59:12 <ihope> I don't suppose there's a Haskell function that returns the shortest POSIX regex that matches all the strings in one list but doesn't match any of the strings in another?
12:59:17 <ihope> s/\?/.?
12:59:26 <ihope> Yowch...
12:59:32 <ihope> s/\?/.../, then.
12:59:40 <xerox> ihope: gawk, what a question.
12:59:42 <sethk> ihope, you want it to compute the regex?  Good luck
13:00:15 <mauke> shouldn't be too hard
13:00:28 * xerox sees the Perl in the Force
13:00:56 <ihope> I don't want Perl regexes, though.
13:01:08 <mauke> why do you want the shortest regex?
13:02:09 <ihope> mauke: if I didn't, then passing it "The quick brown fox jumps over the lazy dog" and "All's well that ends well" would probably produce /(The quick brown fox jumps over the lazy dog|All's well that ends well)/.
13:02:38 <mauke> that's probably also the shortest regex
13:02:43 * xerox grins.
13:03:08 <mauke> except for the /( )/ part
13:03:09 <xerox> Isn't /T.*/ enough?
13:03:10 <ihope> Heh.
13:03:10 <sethk> for his example the shortest is T*
13:03:17 <xerox> I think so too, yep.
13:03:19 <sethk> T.*, sorry
13:03:26 <ihope> No, the shortest is /.*/
13:03:34 <sethk> ihope, no, that matches both
13:03:45 <mauke> the shortest is //
13:03:47 <mauke> there
13:03:53 <sethk> that matches neither
13:03:54 <xerox> mauke: what do you mean?
13:03:59 <ihope> I should clarify, I guess: it should match both of those.
13:04:10 <sethk> you said matching one and not matching the other
13:04:17 <mauke> no, he said lists of strings
13:04:21 <ihope> Yeah.
13:04:30 <ihope> Both those were meant to be in the same list.
13:04:46 <mauke> oh, there is a fixed exclusion list?
13:04:55 <sethk> right, that's what he said
13:05:05 <ihope> Now, if I say it should match "ooooooo" and "ooooooooooo" but not "aaaaa", I don't want it to produce the regex /(ooooooo|ooooooooooo)/; I want it to produce /o*/.
13:05:19 <mauke> o* matches "aaaaa"
13:05:21 <sethk> in that case it would be [AT].*
13:05:42 <ihope> mauke: isn't that the regex for some number of o's?
13:05:47 <mauke> yes
13:05:51 <mauke> 0 is a number
13:06:09 <ihope> Oh, I see.
13:06:17 <akemp> dons: you around?
13:06:29 <ihope> I meant that the regex would have to match the whole string.
13:06:32 <xerox> @wikipedia 0
13:06:35 <lambdabot> No Result Found.
13:06:40 <xerox> @wikipedia Zero
13:06:42 <lambdabot> No Result Found.
13:06:45 <ihope> !
13:06:51 <ihope> @wikipedia Main Page
13:06:53 <lambdabot> No Result Found.
13:07:13 <mauke> ihope: ok, that sounds like a really hard problem
13:07:13 <ihope> Either Wikipedia's down or @wikipedia is, it seems.
13:07:46 <ihope> mauke: not in the case of ["ooooooo","ooooooooooo"] and ["aaaaa"] :-)
13:07:55 <sethk> I'd be surprised if it isn't np complete
13:08:19 <mauke> another solution would be o+ or .{6,}
13:08:37 <ihope> What's .{6,}?
13:08:42 <xerox> 6 chars or more.
13:09:01 <ihope> It doesn't look shorter than o* and o+ :-)
13:09:42 <mauke> yes, but consides ["ooooooo", "ppppppppppp"] and ["aaaaa"]
13:09:52 <Cale> Probably it would be better to keep yourself restricted to concatenation, alternation and kleene star
13:10:00 <akemp> @listcommands
13:10:01 <lambdabot> Unknown command, try @list
13:10:04 <akemp> @list
13:10:04 <lambdabot> list [module|command]. Where modules is one of:
13:10:04 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
13:10:04 <lambdabot> unlambda version vixen where
13:10:16 <Cale> If you can't do it with just those 3, then it'll only be worse with the additional features :)
13:10:18 <mauke> possible solutions: .{6,} [^a]* [^a]+
13:10:30 <akemp> @seen dons
13:10:30 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 4 hours, 27 minutes and 23 seconds ago.
13:11:02 <mahogny> xerox, ok, so far: one game proposal (dunno if I will accept it though), one interested in UML (seems fine) and one who might do matlab haskell bindings (seems fine) and then that level editor (ok)
13:11:15 <ihope> Cale: just what are those?
13:11:34 <xerox> mahogny: great!  Are they signed up on the People page and the sensible tickets too?
13:12:09 <mahogny> xerox, not yet. I should give them that url. do you have it nearby?
13:12:26 <xerox> mahogny: see the topic.
13:12:30 <mahogny> duh
13:13:30 <Cale> ihope: They're the usual operations for regular expressions. Concatenation in regexps is usually just written with juxtaposition. Alternation is written |, and Kleene star is *
13:14:24 <ihope> Okay, that'll work.
13:14:55 <Cale> http://en.wikipedia.org/wiki/Regular_expression#In_formal_language_theory
13:17:01 <Cale> So you have some set of strings, and you're trying to find a regular expression with the fewest number of those operations
13:18:03 <mauke> he's actually trying to recognize an arbitrary superset of those strings that doesn't include some other strings
13:18:24 <Cale> okay
13:23:01 * jip is still totally stuck :|
13:23:46 <fons> how are exceptions captured in haskell?
13:23:54 <fons> I men, for example, the error exception
13:24:10 <musasabi> See Control.Exception
13:24:32 <ihope> @docs Control.Exception
13:24:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
13:24:38 <fons> thanks
13:28:48 <Cale> jip: Is there no way to properly separate your computation into IO and non-IO components? Usually laziness lets you provide a structure to your IO computation which is only evaluated as needed. I'm not 100% sure what you're doing in this case though.
13:31:46 <jip> Cale: no, my "updateSim" function is actually "updateSim :: Input -> State -> (State, Result)", the Input is gathered from IO before each update
13:32:45 <jip> Cale: i could solve all my problems by just using IORefs and IOArrays instead of ST
13:33:08 <jip> Cale: but then all of my code must be IO, and i would rather try to keep it pure
13:33:16 <Cale> hmm
13:33:29 <Cale> what is being mutated?
13:34:15 <Cale> It doesn't sound like you have an arbitrarily large number of mutable cells.
13:34:37 <jip> as you know, i am making a gameboy emulator, so things that are being mutated: an array of memory, some registers, some internal state relating to various hardware components
13:34:46 <jip> no, my mutable data is a fixed size
13:35:49 <Cale> hmm
13:36:30 <Cale> How much of the mutable state needs to be visible to IO?
13:37:03 <mahogny> xerox, you know drakioned?
13:37:08 <xerox> mahogny: nope.
13:37:24 <mahogny> ok. well, he PMed me while I was away about a project. oh well
13:37:30 <jip> ideally all of it, but the only thing i *really* need is a 2d array that contains the pixel data of the display. but in the future there may be more, for things like sound output and link cable comm
13:38:52 <jip> Cale: what do you think about this idea:
13:39:40 <jip> make my own typeclass called "MYRef" that mimics the interface of IORef/STRef, then i can have my code run in either IO or ST
13:42:33 <Lor> Doesn't such a thing exist already?
13:42:42 <Lor> It certainly has been proposed for ages.
13:43:12 <Cale> yeah, that's been done in a variety of ways. The only reason it isn't in the Hierarchical libs is that nobody can agree on what the thing should look like.
13:43:38 <Cale> (there have been a number of proposals)
13:43:59 <jip> if i do this, would it be a lot slower then if i were to use the IO stuff directly?
13:45:49 <Cale> no
13:46:56 <Cale> It would probably be exactly the same. It might introduce one extra pointer dereference in some places.
13:47:21 <SyntaxNinja> w00t
13:47:38 <jip> Cale: do you think it's a good idea?
13:48:30 <Cale> Yeah, it'll probably work out alright.
13:49:07 <jip> do you think that i'll be able to later be able to run the simulation, let's say, from a purely functional IO system like Fruit?
13:49:44 <Cale> I'm not sure that Fruit has references like that
13:50:06 <jip> it doesn't, but i should be able to extract pure values via the ST monad, right?
13:50:20 <xerox> Hey there SyntaxNinja!
13:51:10 <SyntaxNinja> 'sup xerox
13:51:29 <Cale> yes, though I'm a little uncertain about how easy it will be to decouple from IO/ST
13:51:38 <Cale> er
13:51:46 <Cale> just IO
13:51:50 <xerox> SyntaxNinja: studying, mainly.  (Also, most mentors signed up.)
13:52:02 <musasabi> SyntaxNinja: did you get the "Fix JHC command lines." patch for Cabal?
13:52:15 <jip> Cale: what kind of problems do you think there will be?
13:53:47 <Cale> well, if you're having trouble getting the results you need back from ST here, then you'll have the same problem when you move to Fruit, of running the ST computations amidst pure code
13:54:59 <jip> hm...
13:55:00 <Cale> runSTArray is essentially free, you know
13:55:13 <Cale> it turns an STArray into a UArray
13:55:16 <Cale> er
13:55:24 <Cale> it turns an STUArray into a UArray
13:55:33 <SyntaxNinja> musasabi: yeah, but haven't gotten to it yet
13:55:39 <SyntaxNinja> musasabi: thanks, though!
13:55:41 <Cale> heh, sorry, runSTUArray
13:56:03 <Cale> (there's also runSTArray, which turns an STArray into a plain Array)
13:57:13 <Cale> however, doing a thaw takes a copy of the array
13:57:30 <Cale> there's unsafeThaw, but of course, that's unsafe
13:58:24 <jip> it seems that ST is missing some safe way to capture it's internal state and continue another ST run with it later
13:58:51 <Cale> well, it explicitly prevents that
13:59:01 <Cale> as part of its design
13:59:18 <Cale> otherwise, you'd lose referential transparency in Haskell
14:00:09 <Cale> consider something like
14:01:43 <Cale> let r = runST (newSTRef 0); x = runST (modifySTRef (+1) r; readSTRef r) in x - x
14:01:51 <Cale> er
14:01:56 <Cale> let r = runST (newSTRef 0); x = runST (do modifySTRef (+1) r; readSTRef r) in x - x
14:02:23 <Cale> the result of this computation is dependent on order of evaluation
14:03:28 <Cale> If x is evaluated only once, then the expected 0 will result, but if it's evaluated twice, then either -1 or 1 will happen.
14:03:45 <Cale> (depending on the order in which the arguments to (-) are evaluated)
14:04:28 <Cale> that sort of thing would be very bad, so it's prevented by not allowing any of the references, or anything containing them to be returned
14:04:38 <xerox> Goodnight.
14:04:43 <Cale> @type runST
14:04:44 <lambdabot> Not in scope: `runST'
14:04:50 <Cale> @type Control.Monad.ST.runST
14:04:51 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
14:05:06 <JohnMeacham> It would be interesting if there were a primitive in runST to make a copy of the entire internal state, and reload it from another such copy. it would entail some overhead though to keep track of what vars have been allocated.
14:05:51 <Cale> JohnMeacham: you'd have lost all the references to those vars though
14:06:20 <JohnMeacham> that would be encoded in the state, when reloaded, it would return the newly created references. 
14:06:49 <Cale> wouldn't it break referential transparency in exactly the way I just outlined?
14:06:59 <JohnMeacham> however, it would need to encode the type of the state. which the ST monad can't do.
14:07:38 <JohnMeacham> Cale: no, because it would make an entire copy of the state. no more than if you did a bunch of readSTRefs and packedeged up what you got.
14:07:42 <Cale> oh, I suppose you'd have to pass the state to any function that needed it
14:08:51 <JohnMeacham> Hmm. I guess you could make a class to make that idiom easier. no need to extend the ST monad..
14:08:51 <Cale> yeah, it would be inefficient, but possible at least
14:09:21 <JohnMeacham> you could use the DiffArray trick.
14:09:24 <fons> I'm running nuts with the parser
14:09:53 <sethk> fons, I think you mean you are going nuts  :)
14:10:05 <sethk> fons, post it again
14:10:14 <fons> sethk, ok, sorry, I'm not a native speaker
14:10:19 <JohnMeacham> Of course... I don't know how useful it would be..
14:10:21 <sethk> fons, I figured.  :)
14:10:36 <Cale> What I'm really surprised about is that apparently jip's code was slower with DiffUArrays than with UArrays, despite the fact that it was doing a lot of small updates in a (supposedly) linear fashion.
14:10:36 <JohnMeacham> "running nuts". I like it.
14:10:47 <musasabi> SyntaxNinja: it is really trivial (just changes two lines).
14:10:50 <fons> sethk, paste.lisp.org seems to be dead
14:10:58 <fons> any other possible place?
14:11:15 <sethk> fons, that's nasty.  there's another one I sometimes use, although you'll have to paste the url manually.  let me get it...
14:11:30 <JohnMeacham> hmm.. I never actually tried using DiffArrays anywhere. was it evaluating the old copies by accident?
14:11:36 <jip> Cale: this could be because i was at times reading from old versions of the array
14:11:41 <Cale> JohnMeacham: that's what I'm thinking
14:11:45 <Cale> jip: yes
14:11:52 <sethk> fons, http://paste.ubuntu-nl.org/
14:11:57 <Cale> jip: that would kill it
14:12:47 <fons> http://paste.ubuntu-nl.org/13033
14:12:47 <jip> i think that a mutable array would be even faster then DiffArray though :)
14:12:54 <fons> that's the expression type
14:13:01 <Cale> Well, yes, but it's a lot more troule
14:13:03 <Cale> trouble*
14:13:20 <jip> i think i'm gonna need mutables though for performance
14:13:44 <fons> http://paste.ubuntu-nl.org/13034 that's the parser it self
14:13:47 <Cale> If you can somehow ensure that the accesses are linear, I think you could probably avoid moving to ST. You'll have to do that from a design standpoint when moving to ST anyway.
14:13:58 <fons> sethk, try loading ExprParser
14:14:00 <fons> and then
14:14:05 <SyntaxNinja> musasabi: I'll get it
14:14:14 <Cale> (you obviously can't read an old version of a mutable array)
14:14:22 <fons> parseTest whiteExpr "fasdfdafda"
14:14:53 <Cale> any such reads would become potential bugs
14:14:59 <jip> Cale: i'm already sure that the accesses are linear. the places in code where i read from old versions of arrays are accidental. like when i update one cell in an array, and then later need to read from a different cell that hasn't changed. sometimes i coded it to read from an old version, since i didn't really think it mattered
14:15:09 <fons> it recognizes  the first letter as a variable and then it stops parsing
14:20:41 <sethk> fons, sorry I had to take a phone call.
14:21:06 <SyntaxNinja> musasabi: I'm trying to pull some patches, and I seem to have confused darcs :(
14:21:13 <fons> sethk, I'm trying to find a solution, let's see how it works
14:21:30 <musasabi> SyntaxNinja: I can rerecord and resend if that helps?
14:21:44 <fons> sethk, you where the one suggesting eof?
14:21:56 <sethk> fons, no, that was mwe I think
14:22:09 <fons> that might work, lets see
14:22:16 <SyntaxNinja> musasabi: no, It's not even your patch :(
14:22:28 <sethk> fons, sure, try it
14:22:51 <fons> sethk, I don't really inderstand why whiteSpace in parsec accepts newline characters as welll
14:23:18 <sethk> fons, because newlines are white space
14:23:38 <sethk> fons, I think I told you before, it isn't line oriented
14:23:41 <fons> well, the are, but are a special kind of white space
14:23:42 <SyntaxNinja> musasabi: OK should be pushed
14:24:00 <fons> spaceially if indentation counts
14:24:18 <sethk> fons, you can use your own white space parser instead of the built in one
14:24:31 <sethk> fons, you can look at the code they have for parsing haskell
14:24:45 <fons> I know, I'll try mine if this doesn't work
14:26:27 <fons> sethk, it works!!!
14:27:17 <fons> the eof trick owrked
14:27:20 <fons> worked
14:27:36 <sethk> fons, good
14:28:07 <Lor> musa, did you try out the marshalling thingy?
14:31:08 <musasabi> SyntaxNinja: thanks.
14:31:45 <SyntaxNinja> musasabi: thank you!
14:32:37 <musasabi> Lor: it is waiting for me to have one free day to figure out the mercury. I skimmed over it and it looks interesting, but I haven't gotten the time to really work over it.
14:32:54 <Lor> It's a horrible mess really.
14:33:32 <Lor> (My code, not mercury. :)
14:37:22 <jip> ping Saulzar 
14:42:30 * mux can't believe his eyes
14:42:38 <mux> Haskell really got me this time
14:43:11 <mux> I've been coding a haskell module to manipulate arbitrarily complex logical expressions to match filenames
14:43:37 <mux> just to see how big it'll end up, compared to a C version I wrote and compared to a Modula-3 version I know of
14:43:45 <mux> and it fits in 18 lines!
14:43:52 <mux> http://mu.org/~mux/GlobTree.hs
14:44:12 <mux> really spiffy
14:46:19 <mux> btw, I'd be glad if someone can tell me a way to automatically "reduce" the globbing tree in such cases: BoolNode False `AndNode` ...
14:46:49 <mux> I've been playing with strictness flags with no luck, they seem to be semantically very close to what I want but not quite the right thing
14:47:31 <Lor> Strictness flags? How are they relevant?
14:48:10 <mux> it makes sense if you consider that haskell would be told to use my evaluation function, see what I mean?
14:48:55 <mux> I've also wrote lines intuitively such as "Not (BoolNode False) = BoolNode True"
14:49:05 <mux> they didn't cause any error but didn't work as I had expected
14:49:34 <Lor> Yes, well, you just need to write a simple function to convert your boolean expressions into an appropriate normal form.
14:50:24 <mux> mmm, such as?
14:51:21 <Lor> Well, the normal form you want is up to you. Apparently you 
14:51:35 <mux> do you mean writing a "reduce" function myself?
14:51:43 <Lor> Who else would write it?
14:52:40 <mux> it looks like there's nearly all information that is necessary for haskell to manage that itself
14:52:44 <Lor> Well, all right, since you have already given the semantics, something could perhaps be automatically derived.
14:53:05 <Lor> Uh... what exactly do you want?
14:53:40 <mux> to automatically reduce the globbing tree when it's obvious one can do it, looking at the eval function
14:53:49 <Lor> If you want a function that takes an arbitrary GlobTree and returns a normalized GlobTree, then one won't magically appear out of nowhere unless you write something.
14:53:51 <mux> for instance (false and ..., true or ...) etc
14:54:13 <mux> the thing is, if you look at the eval function, all the semantics is already there
14:54:38 <Lor> Err...
14:55:00 <Lor> What exactly do you want the compiler to do?
14:55:01 <mux> I'm thinking about this with optimization in mind, it would seem useless to bring along huge trees when they can be logically reduced in a straightforward way
14:55:25 <Lor> The compiler cannot change any data structures unless it can guarantee that the change won't be observed.
14:55:55 <mux> I'd like to do about the same thing one would do in an imperative language when coding the equivalent of the data constructors created by haskell
14:55:57 <Lor> If you export the GlobTree data type, then arbitrary code can analyze the trees, so the compiler cannot just transparently go changing them.
14:56:10 <mux> like, in an imperative language, I'd defined the data constructor OrNode myself
14:56:32 <mux> and I could thus discards parts of the tree if possible
14:56:58 <Lor> You are still not communicating.
14:57:16 <mux> (the OrNode data constructor can be though as a function that takes two GlobTrees and return one)
14:57:28 <mux> well... what's not clear to you?
14:58:59 <Lor> I still don't understand what you want to be done. Do you want a new function to appear? Do you want data constructors to behave "smartly"? Do you want some functions to be optimized in some fashion without changing the visible interface?
14:59:02 <mux> I think I should define OrNode, AndNode etc myself as functions so that I can implement this
14:59:15 <mux> let me try to take an example
14:59:32 <Lor> You talk about some kind of a transformation, but you haven't said where this transformation should take place and how and whether it should be visible to the programmer.
15:00:40 <mux> if I type let t = (BoolNode True) `AndNode` (BoolNode False) in GHCi
15:00:53 <mux> I'd like it to just print BoolNode False if I then type t
15:01:15 <mux> I think I just need to have AndNode (and others) functiosn and not data constructors
15:01:18 <Lor> Right. No, that won't happen.
15:01:27 <mux> does that make sense?
15:01:47 <mux> (recoding the data constructors as functions)
15:01:51 <Lor> That's like asking that when you write ["", ""] you should just get [""]  back.
15:02:24 <Lor> When you are dealing with concrete data, you are dealing with concrete data. If you construct a tree structure, it's the obligation of the language to create exactly that kind of a tree structure.
15:03:26 <Lor> Constructors are by their nature injections: whenever given different arguments, the results are different as well.
15:03:46 <Lor> If you want something that's not an injection, then you don't want a constructor but a function.
15:04:41 <Lor> What you can do is manual deforestation.
15:04:42 <mux> the problem is that I'll still need the data constructors for when I can't reduce the tree, so I'll need two different identifiers
15:05:15 <Lor> You can completely get rid of your GlobTree data structure, if eval is the only thing that's ever done to it.
15:05:51 <Lor> All right, quite possibly, if the data structure isn't exported, ghc might do deforestation automatically.
15:06:15 <Lor> And that would open opportunities for further optimizations, so yes, in principle it is possible that the automatic reductions you spoke about would happen automatically.
15:06:33 <Lor> ghc does lots of optimizations like that.
15:08:15 <Lor> boolnode x _ = x; notnode x s = not (x s); ornode l r s = l s || r s; ...
15:08:31 <Lor> Now use these instead of the constructors, and you have eval automatically.
15:09:02 <Lor> Of course this only makes sense if you don't want to do anything to these except eval.
15:10:02 <mux> the only thing intended to happen is either constructing a bigger logical expression out of one, with not/and/or, or evaluating
15:10:13 <mux> out of one or two
15:11:07 <Lor> Right. Then you don't even need the datatype.
15:11:36 <Lor> Though retaining it may nevertheless be sensible e.g. for debugging.
15:21:40 <jip> speaking about optimizations, let's say i write a function, foo x = x + 1
15:21:53 <jip> i can use this with integers, but also floating point numbers
15:22:27 <jip> but will the (+) function be called indirectly via pointer each time, or is ghc smart enough to totally inline the fpu add instruction?
15:23:45 <Lor> Yes, ghc can specialize, inline, and strictify that when it deems it appropriate.
16:04:40 * SimonRC goes to bed.
16:59:22 <joelr1> good evening! does anyone have a xmpp implementation?
17:08:46 <musasabi> I think xmpp was suggested as a SoC project, so no xmpp at the moment. (but I am tired, so I may not remember correctly)
17:10:16 <joelr1> i could not find anything by googling so i would assume that to be the case
17:10:18 <joelr1> thanks einar
17:10:50 <joelr1> i still wanna know what type of network programming you do in haskell ;-) message me privately!
17:50:17 <palomer> if I have a ListT (ST s) a and I (lift $ writeSTRef a 4), will this write propagate throughout my computation, or will it stay local?
17:50:25 <palomer> I'm guessing it will propagate
17:50:45 <dons> moin
17:51:07 <palomer> moin?
17:51:36 <dons> moinmoin
17:51:43 <palomer> moinmoin?
17:54:20 <stepcut> wiki wiki ?
17:55:33 <dons> sjanssen: did you see that there's an hGet :: Handle -> Int -> IO ByteString (to your question on the 'missing' get a string of a certain length function in fps)
17:58:18 <dons> ?uptime
17:58:19 <lambdabot> uptime: 2 days, 19 hours, 5 minutes and 10 seconds
17:58:23 <palomer> @palomer
17:58:24 <lambdabot> hrmph
18:00:44 <stepcut> this unified threads and events paper is neat
18:01:47 <skew> I'm trying to track down something from the haskell lists
18:02:07 <skew> it was something like a seq that evaluated just until it hit the next something-like-a-seq
18:02:38 <dons> hmm. not deepSeq?
18:04:52 <skew> not quite
18:05:22 <dons> yeah, i don't recall this function. very interesting.
18:05:33 <skew> like, next (1:2:3:next (4:5:[])) would force 1,2,3 when evaluated, or at least force the spine that far
18:15:34 <Cale> hmm
18:18:38 <Cale> palomer: Yeah, I think it would be pretty much impossible to prevent those changes from propagating.
18:23:24 <stepcut> has anyone tried hazakura yet?
18:35:45 <tuxplorer> hi channel! is there something for haskell like how JAVA has Java API docs.. i just want a list of all the modules and short descriptions on them..
18:36:22 * palomer wishes he could write a hybrid ST/ListT monad
18:36:26 <Cale> tuxplorer: yeah http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
18:36:29 <palomer> where writeSTRef is only applied to the local computation
18:36:48 <palomer> ie, every time you branch nondeterministically, the store is copied
18:36:51 <tuxplorer> Cale, link plz..
18:36:52 <Cale> palomer: yeah, that would involve some doing :)
18:37:06 <Cale> tuxplorer: what do you call what I just pasted?
18:37:09 <palomer> though all my references reference have all the same time
18:37:09 <Cale> hehe :)
18:37:18 <palomer> so that makes things easier
18:37:27 <lispy> tuxplorer: haddock is the tool for haskell which is like javadoc
18:38:08 <palomer> s/time/type
18:38:16 <tuxplorer> oh! sorry Cale, but i didnt get any link.. probably my messenger had discarded it mistaking it to be something else.. can u plz repaste it?
18:38:26 <Cale> palomer: better yet, have variable stores in all of the tree nodes, so that only what needs copying is copied
18:38:34 <Cale> tuxplorer: sure
18:38:39 <palomer> tree nodes?
18:38:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
18:38:54 <tuxplorer> thanx Cale.
18:39:30 <Cale> palomer: Though it's really a list, you can picture the computation as a tree whose leaves are the elements of the list from left to right.
18:39:31 <lispy> isn't there also a way to make lambdabot tell you the url?
18:39:33 <lispy> @library
18:39:34 <lambdabot> Unknown command, try @list
18:39:39 <Cale> @docs
18:39:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:39:43 <lispy> ah, right
18:39:48 <Cale> yeah, I guess you can :)
18:40:14 <Cale> (I sort of didn't expect it to work with an empty parameter)
18:40:21 <Cale> @docs Control.Monad
18:40:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
18:40:40 <Cale> @docs Data.Graph.Inductive
18:40:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive.html
18:41:02 <palomer> Cale: so that only the variables which are needed are stored in the node?
18:41:04 <tuxplorer> lispy whats that haddock? i mean where to find it?
18:41:24 <palomer> and these would be determined by calls of readSTRef and writeSTRef?
18:41:30 <lispy> tuxplorer: http://www.haskell.org/haddock/
18:41:37 <Cale> palomer: in any given node, only store the new variables and the values of variables which have changed.
18:41:50 <palomer> and then to get the value I would move up the stack?
18:41:55 <palomer> or tree
18:41:59 <Cale> palomer: yeah
18:42:10 <palomer> very cool
18:42:42 <tuxplorer> thanx lispy
18:42:47 <lispy> tuxplorer: np
18:43:09 <dons> morning tuxplorer 
18:43:17 <tuxplorer> morning dons
18:43:26 <dons> how's the haskell hacking coming along?
18:43:33 <dons> and  did you make contact with kzm?
18:43:34 <tuxplorer> starting off..
18:43:39 <tuxplorer> yes.
18:43:45 <tuxplorer> he replied to my mail.
18:43:56 <dons> have I introduced lambdabot? she's a useful tool if you are learning.
18:44:01 <dons> ?bot
18:44:01 <lambdabot> :)
18:44:03 <dons> ?type map
18:44:04 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
18:44:08 <dons> > map (+1) [1..10]
18:44:09 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
18:44:13 <dons> ?hoogle map
18:44:13 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
18:44:13 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
18:44:13 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
18:44:19 <dons> ?hoogle (a -> b) -> [a] -> [b]
18:44:20 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
18:44:20 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
18:44:20 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
18:44:25 <dons> ?dogs Data.List
18:44:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
18:44:27 <palomer> lambdabot is useful inasmuch as it quotes me
18:44:33 <dons> ?palomer
18:44:33 <lambdabot> blargh!
18:44:34 <Cale> heh, dogs
18:44:38 <lispy> @quote palomer
18:44:39 <lambdabot> palomer hasn't said anything memorable
18:44:40 <palomer> dogs?
18:44:43 <dons> hehe. and lambdabot does spelling correction
18:44:51 <Cale> ?dogs Control.Monad
18:44:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
18:45:00 <lispy> @quote cale
18:45:01 <lambdabot> cale hasn't said anything memorable
18:45:06 <lispy> @quote dons
18:45:06 <lambdabot>  Haskell: The language that never sells out!
18:45:24 <lispy> @. elite keal
18:45:25 <lambdabot> IT Iz \/ErY easy TO 90 ofph +OPIc
18:45:31 <tuxplorer> oh! wow! is she written in haskell?
18:45:41 <tuxplorer> ?haskell
18:45:41 <lambdabot> Unknown command, try @list
18:45:49 <lispy> ?where haskell
18:45:50 <lambdabot> http://haskell.org/
18:45:50 <Cale> @quote Cale
18:45:51 <lambdabot>  The perfect programming language is mathematics, but that only runs on mathematicians.
18:46:14 <Cale> Apparently the input to the quote module is case sensitive
18:46:20 <dons> ?version
18:46:21 <lambdabot> lambdabot 3p424, GHC 6.4.1 (Linux i686 3.20GHz)
18:46:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:46:25 <dons> yeah, sure. it's all haskell :)
18:46:30 <tuxplorer> is lambdabot written in haskell?
18:46:34 <tuxplorer> oh1 k
18:46:41 <dons> even the revision control system you need to use to download lambdabot is written in haskell
18:46:45 <sethk> tuxplorer, nah, it's written in cobol
18:46:58 <tuxplorer> sethk, hehe
18:46:58 * lispy is written in cobol
18:47:24 <palomer> and mathematicians run on 386s
18:47:44 <lispy> mathemagicians
18:47:51 <Cale> palomer: no, they run on coffee
18:47:59 <Cale> they convert coffee into theorems
18:48:07 <Cale> comathematicians turn theorems into coffee
18:48:13 <lispy> hehe
18:48:27 <musasabi> and sofas are needed for the process to work.
18:48:30 <lispy> life is complex, it has both real and imaginary components
18:48:41 <tuxplorer> ?quote lispy
18:48:41 <lambdabot>  I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
18:48:52 <dons> tuxplorer: you might be interested. lambdabot uses haskell's type system to allow people to run random code safely on my server, without sandboxing
18:48:56 <dons> > print "foo"
18:48:57 <lambdabot> No IO allowed
18:49:23 <tuxplorer> wow! don, u wrote her?
18:49:33 <palomer> it's a her?
18:49:34 <dons> since the type system distinguishes between pure computations, and actions with side effects (such as reading files), the compiler can rule out unsafe code without having to run it.
18:49:40 <lispy> @vixen do you mind that dons wrote you?
18:49:41 <lambdabot> me?
18:49:48 <lispy> @vixen yes you
18:49:49 <lambdabot> that's what i figured
18:49:51 <dons> tuxplorer: a lot of her. its a collaborative effort from the #haskell channel
18:49:59 <tuxplorer> palomer, 'her' makes the bot sound sexy ;)
18:50:09 <dons> ?vixen a/s/l?
18:50:10 <lambdabot> 19/f/California
18:50:17 <palomer> lambdabot is as female as judge judy
18:50:21 <dons> hehe
18:50:37 <lispy> ?vixen how do you feel about judge judy?
18:50:37 <lambdabot> how? it depends...
18:50:56 <lispy> ?vixen are you busy tonight?
18:50:57 <lambdabot> i truely am
18:51:05 <lispy> damn...turned down by a bot
18:51:22 <tuxplorer> ?vixen when is your birthday?
18:51:23 <lambdabot> when is a good time?
18:51:24 <Cale> she'll be compiling ghc again
18:51:35 <lispy> Cale: heeh
18:51:41 <lispy> there goes 6 hours...
18:52:01 <lispy> i figure by 2020 ghc will take longer to compile than it took to write
18:52:35 <dons> lispy, nah. smp...!
18:52:48 <tuxplorer> lispy, which country are u from?
18:52:56 <palomer> he's a doctor
18:52:58 <palomer> from america
18:52:59 <lispy> USofA
18:53:06 <tuxplorer> k.
18:53:15 <tuxplorer> just asked coz, u have a vision 2020.
18:53:20 <lispy> i'm not a real doctor but i am a real worm
18:53:28 <palomer> pfft
18:53:32 <palomer> haven't seen Dr. Tran?
18:53:40 <lispy> that's why they call me doctor worm
18:53:43 <palomer> http://www.beyondgrandpa.com/drtran/main.html
18:53:49 <lispy> i like to play the drums
18:54:16 <lispy> palomer: i don't get it
18:54:42 * palomer runs off
18:54:54 * lispy suspects you have to watch the show to get it
18:58:17 <dons> @seen ndm
18:58:17 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 2 hours, 3 minutes and 22 seconds ago, and .
19:00:00 * dons thinks its a nice day to port fps to yhc
19:00:18 <dons> or, hmm, network-alt to lambdabot.
19:00:26 <dons> something to do.. something to do.
19:00:32 <heisenbug> by the way, can yhc compile itself now?
19:01:20 <dons> don't know.
19:02:04 <Korollary> dons: work on your thesis ;)
19:02:17 <dons> Korollary: boo on that.
19:02:19 <lispy> oh, i was going to bring home a copy of a python program i wrote at work and see if i could do it better haskell...but i forget the python source ot work
19:02:23 <heisenbug> darcs pull for yhc-devel has been rather quiet in the last weeks
19:02:48 <Korollary> lispy: better how?
19:02:54 <Cale> lispy: what did the program do?
19:03:20 <lispy> Korollary: less dev time, fewer lines of code, easier to maintain and less bugs :)
19:03:56 <Korollary> lispy: I did convert a few of my mp3 tagging scripts from python to haskell. It was pretty much the same number of lines. Bugs? Difficult to tell for simple things like scripts.
19:03:56 <lispy> Cale: it made heavy use of wxwidgets, launched some programs and hm...used numarray
19:04:22 <dons> in the shootout python was marginally, maybe 10%, more verbose.
19:04:39 <dons> haskells brevity seems to scale acroos all sorts of domains.
19:04:42 <araujo> Hello!
19:05:04 <lispy> dons: just like java's verbosity :)
19:05:13 <dons> ah, very true. very true.
19:05:52 <dons> as the domain gets weirder, we just write new hofs, monads or edsl's to handle it.
19:05:53 <lispy> was actually talking to a friend about this.  Because control flow structures in java are not first class there is a lot of stuff you're first to recode everytime you need it
19:06:17 <lispy> s/first/forced/
19:06:25 <Cale> yeah
19:06:37 <dons> right. and they add 60 odd keywords to the language for no good reason.
19:06:46 <dons> oh, i guess laziness would help in that dept.
19:06:46 <Korollary> I am not sure control structures can be first class
19:06:55 <dons> ?type when
19:06:56 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:06:59 <araujo> lispy, that's what usually happens to the imperative language approach.
19:07:06 <Cale> @type mapM
19:07:06 <dons> first class control!
19:07:07 <lambdabot> forall b (m :: * -> *) a.
19:07:07 <lambdabot>    (Monad m) =>
19:07:07 <lambdabot>    (a -> m b) -> [a] -> m [b]
19:07:21 <lispy> @type catchAll
19:07:22 <lambdabot> Not in scope: `catchAll'
19:07:31 <Cale> @type filterM
19:07:32 <lambdabot> forall a (m :: * -> *).
19:07:32 <lambdabot>     (Monad m) =>
19:07:32 <lambdabot>     (a -> m Bool) -> [a] -> m [a]
19:07:42 <dons> ?type catch -- is a good example
19:07:43 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
19:08:00 <dons> no need for a exception handling _syntax_
19:08:03 <Cale> @type bracket
19:08:04 <lambdabot> Not in scope: `bracket'
19:08:05 <lispy> well, okay for example in lisp you have with-open-file (may not be the exact name) which is a macro that gives you a file handle inside the "function call" and is gauranteed to cleanup correctly
19:08:19 <Cale> @type Control.Exception.bracket
19:08:20 <lambdabot> forall c a b.
19:08:20 <lambdabot>           IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:08:47 <lispy> i think in lisp you needed macros for a lot of that stuff because it's strict
19:08:57 <Cale> yeah
19:09:02 <lispy> in haskell you can just rely on laziness and hof most of the time
19:09:21 <Cale> laziness is what lets you treat datastructures like control structures
19:09:27 <Korollary> well, bracket exists for a reason too
19:09:57 <Cale> so lists become loops via operations like map
19:10:01 <Korollary> you have destructors in other strict languages for that sorta stuff.
19:10:25 <dons> ?type (>>=) -- is also a very useful control structure
19:10:26 <lambdabot> forall (m :: * -> *) b a.
19:10:26 <lambdabot>    (Monad m) =>
19:10:26 <lambdabot>    m a -> (a -> m b) -> m b
19:11:14 <lispy> Korollary: although in java you don't know when the destructor will be called so there is often a lot of stuff you have to do manually for non-memory cleanup
19:11:32 <dons> hmm. this makes me think that haskell must have the richest, most extensible, control structure features out there.
19:11:51 <Cale> dons: it's the finest imperative language today :)
19:12:02 <dons> seems so.
19:12:03 <araujo> lispy, atrocity
19:12:11 * lispy gets a dictionary
19:12:29 <Korollary> eh?
19:12:44 <lispy> araujo: java is?
19:12:57 <araujo> lispy, yes, about your destructor comment
19:13:11 <lispy> ah, right
19:13:23 <lispy> one of the few nice things about using C++ over java
19:13:43 <lispy> in C++ under most circumstances you know the destructor will exactly run when you leave the scope
19:16:12 * Korollary grabs TaPL
19:16:37 <fons> is there a way to now if the standard input is a terminal?
19:16:37 * lispy wonders what Korollary is looking up and waits
19:16:58 <palomer> man, this monad is going to be something else
19:17:01 <lispy> fons: in posix-land i think there is some sort of isTTY function...
19:17:01 <dons> fons, hmm. 'tty' ?
19:17:03 <palomer> I can't believe noone has written it before
19:17:09 <palomer> Cale: do you think I'll have to use the mtl?
19:17:12 <dons> @hoogle isTTy
19:17:12 <lambdabot> No matches found
19:17:17 <dons> @hoogle tty
19:17:18 <lambdabot> Data.Typeable.funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
19:17:18 <lambdabot> Foreign.C.Error.eNOTTY :: Errno
19:17:18 <lambdabot> Data.Typeable.splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
19:17:50 <dons> fons, look in System.Posix.Terminal
19:18:00 <dons> @docs System.Posix.Terminal
19:18:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Terminal.html
19:18:01 <fons_> thanks dons
19:18:17 <palomer> Cale: rather, do you think I can use the mtl
19:18:19 <Cale> palomer: I think you're going to have to use unsafeCoerce.
19:18:30 <palomer> Cale: my references have all the same type
19:18:41 <palomer> when would I need to coerce?
19:18:42 <Cale> ah, okay
19:18:49 <dons> in particular, fons, :
19:18:49 <dons> queryTerminal :: Fd -> IO Bool
19:18:49 <dons> queryTerminal fd = do
19:18:49 <dons>   r <- c_isatty fd
19:18:50 <dons>   return (r == 1)
19:19:02 <palomer> damn this is going to be a crazy monad
19:19:08 <lispy> fons_: it may also turn out that using some library like ncurses is a really good idea (i mean if you start needed features specific to your terminal)
19:19:13 <Cale> When putting the reference values into whatever table.
19:19:37 <Cale> If your references are all the same type then it's easy
19:19:52 <fons_> lispy, I'm fine with queryTerminal
19:19:57 <Cale> StateT (Map Integer t) Nondet
19:20:20 <palomer> I rather not use Map, since it doesn't work with hat
19:20:31 * dons jumps as his harddrive goes crazy. oh, 21416 dons      -5    0 9840K 9776K sleep    biowai   0:03 12.50% darcs
19:20:38 <Korollary> Ok, TaPL exercise 5.2.9 has an "if .. then .. else" as syntactic sugar for a dummy wrapped lambda abstraction (for call-by-value). This makes me think that control structures are just sugar.
19:20:41 <palomer> StateT (Map [(Integer,t)]) NonDet
19:20:48 <tuxplorer> ? isUpper
19:20:49 <Cale> okay, then you'll need some other datastructure, but something like that
19:20:50 <palomer> but how would that work?
19:20:55 <palomer> err
19:21:00 <tuxplorer> ?isUpper
19:21:00 <lambdabot> Unknown command, try @list
19:21:06 <palomer> StateT [(Integer,t)] NonDet
19:21:13 <tuxplorer> ?Char
19:21:13 <lambdabot>  @where <key>, return element associated with key
19:21:26 <dons> ndm: ah, I see yhc has ForeignPtr!
19:22:58 <lispy> i wonder which is harder, writing a decent haskell98 compiler in haskell or writing a decent c99 compiler in c
19:23:06 <dons> hmm. is it kosher to have yhc's build system invoke darcs get ?
19:23:33 <dons> lispy, i think the c99 must be harder, since there's been about 5 or 6 h98 compilers.
19:23:41 <dons> but the, depends on what you mean by 'decent'
19:23:51 <Cale> @type isUpper
19:23:52 <lambdabot> Char -> Bool
19:23:54 <lispy> dons: huh, up to the author ;)
19:24:12 <Korollary> ? Data.Char.isUpper ':'
19:24:18 <dons> ok, then c99 in C is definitely harder.
19:24:34 <Cale> > isUpper ':'
19:24:35 <lambdabot> False
19:24:39 <Cale> > isUpper 'A'
19:24:40 <lambdabot> True
19:24:52 <Korollary> I don't necessarily agree with isUpper ':' = False
19:24:58 <Cale> hehe
19:25:05 <Korollary> > Data.Char.isLower ':'
19:25:06 <lambdabot> False
19:25:10 <Korollary> eh
19:25:26 <lispy> would isUpper :: Char -> Maybe Bool be better?
19:25:28 <Korollary> so you can't use isLower by itself. It's ternary logic.
19:25:52 <Cale> well, sure you can
19:25:57 <araujo> lispy, i don't think so
19:26:05 <Cale> it tells you whether a character is a lowercase letter
19:26:21 <Cale> > filter isLower "Hello, World!"
19:26:22 <lambdabot> "elloorld"
19:26:40 <palomer> Cale: but how would this monad work?
19:26:49 <lispy> > filter isUpper (filter isLower "Hello, World!")
19:26:50 <lambdabot> ""
19:27:22 * araujo needs more tea
19:27:30 <palomer> Cale: my get and put would propagate
19:27:41 <Cale> palomer: no, they shouldn't
19:27:44 <araujo> Anybody knows if there exists omething like a HTML template generator/parser?
19:27:54 <Cale> I'm fairly certain that they don't
19:27:56 <Korollary> > Data.Char.isLower (Data.Char.toLower ':')
19:27:57 <lambdabot> False
19:28:04 <petekaz> What do you guys mean when you say that "laziness lets you treat data structures like control structures?"  And why does this make haskell the best imperative language?  Or how does it compare to the power of lisp macros (writing your own control structures)?
19:28:08 <lispy> araujo: can you be more specific?
19:28:38 <palomer> how can they not?
19:28:41 <araujo> lispy, Something to parse HTML .. i think i can work out from there on
19:28:45 <lispy> petekaz: take 10 (some crazy list), what's like a for loop
19:29:05 <lispy> araujo: i don't know how well it does html but haxml looks pretty sweet for xml
19:29:11 <Korollary> petekaz: I personally don't think it's the laziness. It's hofs.
19:29:18 <lispy> araujo: i would think that xslt is what you really want
19:29:21 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in take 10 evens
19:29:22 <lambdabot> [0,2,4,6,8,10,12,14,16,18]
19:29:34 <dons>  sequence_ [ putChar 'x' | i <- [1..5] ]
19:29:36 <dons> a for loop via a data structure
19:29:51 <araujo> petekaz, laziness will allow you to introduce meta-programming
19:30:13 <liyang> No, you mean higher-order functions.
19:30:16 <dons> and the laziness means you can roll your own control structures (just as if-then-else is lazy in all languages)
19:30:22 <Cale> petekaz: see my example there?
19:30:25 <araujo> Ive always seen combinators and partial applications as a macro system improved.
19:30:41 <petekaz> Cale: reading now
19:30:46 <Cale> petekaz: you essentially have two loops, each ceding control to each other.
19:31:03 <lispy> araujo: or atleast they let you do most of what you want to do with macros
19:31:18 <lispy> araujo: i'd say macros are a little tiny bit more general but a lot, lot more dangerous
19:31:34 <araujo> lispy, dangerous and ugly imho
19:31:45 <araujo> And people complains about Haskell syntax!
19:31:51 <lispy> just use TH when you need macros :)
19:31:52 <Cale> Most of what macros are used for in lisp-like languages is avoiding the strictness of function application
19:32:03 <araujo> Right.
19:32:13 <palomer> I always thought StateT adds a global state
19:32:14 <Cale> I kind of find TH ugly too :)
19:32:27 <Korollary> Cale: There's another way without macros.
19:32:29 <palomer> do I have to use NonDet or can I use  List?
19:32:49 <petekaz> since I know more lisp than haskell, dons, your comment to me seems like i get the same with macros, I control when evaluation occurs, right?
19:33:09 <Cale> Korollary: yes I know, but you need at least one further language primitive to hold computations.
19:33:18 <Cale> (usually implemented as a macro)
19:33:26 <Cale> palomer: list is fine
19:34:07 <Cale> petekaz: well, with macros, you are controlling when evaluation occurs, here, it just occurs at a reasonable time
19:34:11 <Korollary> Cale: http://okmij.org/ftp/Scheme/if-function.txt
19:34:22 <lispy> who complains about haskell syntax anyway?
19:35:15 <Cale> Korollary: ah, sure, if you don't mind forcing people to wrap their args in (lambda () ...)
19:35:28 <Cale> Korollary: otherwise, you need a macro to do that for you
19:35:39 <palomer> ok, if I apply StateT to List, then I'm pretty convinced that my changes propagate
19:35:46 <palomer> here, I'll try it 
19:36:09 <Korollary> Cale: Yes, but a macro is a now convenience, not a requirement.
19:36:16 <petekaz> I guess I still haven't seen the light when it comes to laziness.  I look forward to my "wow" moment like I had with lisp macros.
19:36:18 <Korollary> "now a"
19:37:38 <lispy> petekaz: for me it came when i started using functions which generated huge or infinite lists and i could use other functions on the output and still terminate quickly when i found the answer i wanted
19:37:52 <Cale> petekaz: here's an example for you -- estimate the complexity of this function:  isSubstringOf s x = any (isPrefixOf s) (tails x)
19:38:15 <Korollary> petekaz: It's pretty cool even with just getLines.
19:38:22 <petekaz> lispy: so how does laziness help with the WITH-OPEN-FILE macro you were talking about earlier
19:38:27 <Cale> In a strict language, that's a really stupid way to write a substring test
19:38:31 <palomer> Cale: how would you branch?
19:38:47 <Cale> palomer: mplus
19:38:55 <palomer> @hoogle mplus
19:38:56 <lambdabot> Control.Monad.mplus :: MonadPlus m => m a -> m a -> m a
19:39:22 <liyang> petekaz: what are lisp macros, in simple terms?
19:39:33 <Korollary> petekaz: As far as lazyness goes, this is pretty wild: http://www.haskell.org/hawiki/TyingTheKnot
19:39:38 <lispy> petekaz: i'm not sure off the top of my head.  But I bet if you looked at the macro definition you'd see places where things are spliced in instead of evaluated right away
19:40:03 <liyang> I understand they're `safe' in some sort of sense. Not sure what though.
19:40:32 <Cale> palomer: or use  option xs = msum (map return xs)
19:41:18 <lispy> liyang: compile time code generators is how i've heard them described
19:41:54 <Korollary> lispy: This is a pretty good description: http://www.gigamonkeys.com/book/syntax-and-semantics.html
19:41:59 <Korollary> err that was for liyang
19:42:04 <Cale> Prelude Control.Monad.State> evalStateT (do x <- option [1..10]; u <- get; put (u + 1); return u) 0 :: [Integer]
19:42:05 <Cale> [0,0,0,0,0,0,0,0,0,0]
19:42:13 <Cale> (palomer: ^)
19:42:14 <liyang> Korollary: I think I see...
19:42:43 <liyang> Korollary: oops. That was meant for lispy.
19:43:13 <Cale> petekaz: do you get that isSubstringOf example?
19:43:28 <petekaz> Cale: sorry .. yes .. triyng to read everything.
19:43:34 <Cale> petekaz: hehe
19:43:39 <petekaz> Cale: but that makes sense
19:43:59 <petekaz> (my irc-fu is clearly not up to por)
19:44:16 <Cale> in a strict language, that's a terrible implementation -- you'd be crazy to form the list of all tails of your list before starting to perform tests to see if any has your string as a prefix
19:44:37 <petekaz> (of course, i'm sitting on a coach, wife fell asleep on me, making typing difficult)
19:44:57 <Cale> In Haskell, this is essentially equivalent to the naive nested-loops implementation with early breaks.
19:45:02 <Korollary> lazyness on the couch
19:45:19 <petekaz> Cale: I see
19:45:31 <palomer> http://www.rafb.net/paste/results/LL5mu338.html
19:45:34 <petekaz> That's a good explanation.
19:46:02 <Cale> petekaz: tails is not so much building something, as it is iterating over possibilities
19:46:08 <petekaz> I need now to learn to identify when to take advantage of laziness (after I learn the basics first :-)
19:46:51 <Cale> palomer: fix the type to lists of Ints
19:46:59 <lispy> Korollary: tying the knot is confusing me :)
19:47:02 <Cale> (mplus is a generic operation)
19:47:18 <palomer> Cale: which type?
19:47:28 <Cale> palomer: you define the type Foo, but don't use it in any signatures
19:47:47 <Cale> write foo :: Foo and it'll fix the ambiguity
19:48:02 <liyang> So... Lisp macros is essentially a compile-time term-rewriting system...?
19:48:03 <Cale> since m will be []
19:48:31 <palomer> ah no, since both foo and baz are Foos and not Lists, I can't mplus them
19:48:34 * palomer ponders this
19:48:35 <lispy> let (first,last) = go last xs first -- wouldn't first and last be undefined here?
19:48:42 <Cale> palomer: yes you can
19:48:53 <Cale> palomer: MonadPlus carries through StateT
19:49:16 <palomer> I have to lift mplus, no?
19:49:25 <Cale> and you don't need that lift
19:49:29 <petekaz> liyang: that sounds about right. you have access to the AST and can modify it using the full pawer of the lisp language itself.
19:49:31 <Cale> at all
19:49:52 <palomer> you're right, the changes don't propagate!
19:49:55 <palomer> I just don't get it
19:49:56 <petekaz> liyang: not some half-assed macro language
19:50:17 <palomer> why is it obvious to you that the changes don't propagate?
19:50:31 <Cale> palomer: because I've used that fact before :)
19:50:51 <liyang> petekaz: right. So what happens if you have overlapping rules (read: macros)?
19:50:58 <palomer> but how can I come to this realization?
19:51:01 <Cale> but if you think about the definition of StateT, I think it should become obvious
19:51:19 <lispy> > let (first, last) = go last first; go l f = (l, f) in first
19:51:20 <lambdabot> Add a type signature
19:51:21 <petekaz> liyang: macros can be written in terms of other macros.
19:51:23 <palomer> erm, what definition of StateT?
19:51:24 <liyang> (I guess they get applied in a specific order as opposed to an undetermined arbitrary order.)
19:51:36 <lispy> > let (first, last) = go last first; go l f = (l, f) in first :: a
19:51:37 <lambdabot> Add a type signature
19:51:54 <Cale> StateT s m a is essentially s -> m (a,s)
19:51:59 <petekaz> liyang: they just keep expanding as you stated.
19:52:00 <liyang> petekaz: Not really a TRS then. But okay, I understand the idea. :)
19:52:11 <Cale> so, StateT Int [] a is essentially s -> [(a,s)]
19:52:41 <lispy> liyang: one thing that makes the lisp macro system so successful is that lisp code is easily representing using one of the built-in data types :)
19:52:43 <palomer> ok, I see it
19:52:59 <palomer> yes, it's much clearer now
19:53:03 <palomer> wow, this makes my life so much easier
19:53:10 <palomer> does NonDet also have mplus?
19:53:17 <Cale> yeah
19:53:18 <liyang> lispy: would that be... lists? <g>
19:53:32 <Cale> Nondet is basically isomorphic to List
19:53:38 <Cale> only it's faster :)
19:53:46 <lispy> liyang: maybeee.... ;)
19:53:49 <Cale> (and not in the GHC libs)
19:53:55 <palomer> oh, I'll stick to List
19:54:32 <Cale> before, I mostly just said Nondet because you could use any nondeterminism monad you like
19:55:02 <liyang> (ah hah. So it's more like multi-staged programming where the first stage happens at compile time...)
19:55:15 <Cale> You could also use a Tree monad, or binary trees, or something with some extra expressivity about priorities of trying options.
19:55:28 <petekaz> liyang: the great thing about macros is that you can invent your own syntax.  so whereas in java, it took them years to modify the for loop to work with an Iterable type, in lisp, if you wanted that type of control structure, you write a quick macro.
19:55:43 <palomer> Cale: why would I do that? I want it to try everything
19:55:53 <palomer> I don't want it to stop when it finds a solution
19:55:57 <palomer> I want it to find all solutions
19:56:33 <Cale> palomer: well, different scenarios -- if you ever want to be able to pick from infinitely many options somewhere along the line, it can help to not be working with [] :)
19:56:50 <palomer> oh no, I'll never run into that situation
19:56:52 <liyang> petekaz: I guess you do get more for less in this case then.
19:57:05 <lisppaste2> petekaz pasted "lisp 'if' macro" at http://paste.lisp.org/display/19486
19:57:37 <petekaz> liyang: I think so.  I just pasted a small macro for you to see.
19:58:16 <lispy> does anyone else find this tying the knot stuff confusing?
19:58:58 <liyang> And now, for something completely different: is the idea of a tipped list commonplace? i.e. TipList a b = Tip a | TCons b (TipList a b)
19:59:00 <fons_> is there a safe version of getLine which deals with the EOF?
19:59:28 <lispy> fons_: getContents?
19:59:49 <palomer> Cale: and how would I get the contents of a reference?
20:00:10 <lispy> liyang: i would think you'd want to define it: data TipList a b = Tip a | Rest [b]
20:00:24 <lispy> er no i wouldn't
20:00:31 <lispy> duh
20:00:34 <palomer> oh, it'll be stored in the state
20:00:40 <palomer> so I don't actually have to go up the tree
20:00:42 <liyang> no, Rest [] wouldn't be right. :)
20:01:19 <lispy> but what about? data TipList a b = TP a [b]
20:01:30 <fons_> lispy, that gets the contents of the whole file right?
20:01:42 <lispy> fons_: yes, but lazily, iirc
20:02:27 <fons_> what I need is a function which gets a line, but doesn't give an error the first time it reaches eof
20:02:34 <liyang> petekaz: I grok the parentheses and `, but the commas and &optional are a bit weird to me. (Though I can guess what the latter means.)
20:02:37 <lispy> liyang: do you really care if it's a list or just that it contains a list?
20:02:57 <fons_> like if eof was and end of line if some characters could be read
20:02:57 <liyang> lispy: weeeeelll...
20:03:41 <lispy> and you could do: type TipList a b = (a, [b])
20:04:26 <araujo> xerox_, ping
20:04:36 <lispy> @type getContents
20:04:38 <lambdabot> IO String
20:05:22 <lispy> er how does it know what to get the contents of?
20:05:26 <lispy> @hoogle getContents
20:05:27 <lambdabot> Prelude.getContents :: IO String
20:05:27 <lambdabot> IO.hGetContents :: Handle -> IO String
20:05:44 <fons_> actually, get line behaves like that
20:05:57 <fons_> getLine
20:06:06 <lispy> fons_: well, just run 'lines' on the return value of getContents
20:06:12 <lispy> and only take the lines youw ant
20:06:13 <araujo> @type getLine
20:06:14 <lispy> @type lines
20:06:15 <lambdabot> IO String
20:06:16 <lambdabot> String -> [String]
20:06:16 <liyang> lispy: I guess the types really are isomorphic.
20:08:44 <liyang> I just don't want to see the tip when the list is non-empty though. I'll appeal to some sort of nice abstraction principle or something to justify my preferences.
20:10:07 <lispy> liyang: so you want Either a b?
20:10:13 <lispy> as in, you want either a tip or a list?
20:10:26 <lispy> Either a [b] i should say
20:10:43 <liyang> no... because you can then get Right [] which makes no sense.
20:10:59 <lispy> oh
20:11:34 <palomer> hrmph, I have a Functor Foo and a function a -> m b and I want to turn an element of Foo a into an element of m (Foo b), how do I do this?
20:11:56 <liyang> It's just that someone else had the same notion, and I can't remember if I picked it up from them or it somehow entered my head elsewhere.
20:14:55 <Cale> palomer: you can get Foo (m b)
20:15:21 <Cale> but in general, you can't get m (Foo b) without knowing something about Foo or m
20:15:48 <palomer> Foo is this tree datastructure
20:16:06 <Cale> Is there a particular traversal order you have in mind?
20:16:11 <palomer> Foo a = Leaf a | Node String [Foo a]
20:16:16 <palomer> Cale: nope
20:16:34 <palomer> m is StateT [(s,s)] List
20:16:44 <Cale> You see, you can get a Foo of m b computations
20:17:12 <Cale> and to connect those up into a single m (Foo b) computation, you'll have to run them in some order
20:17:23 <Cale> (order obviously matters)
20:17:49 <liyang> (comment: if Foo and m are applicative functors... you can just apply the distribute function to get m (Foo b) from Foo (m b) ...)
20:18:05 <liyang> (I think. I may be drunk.)
20:18:06 <palomer> but I don't care about the order
20:18:37 <Cale> liyang: yes, I think that's right, but the definition of Applicative will presume an ordering for you
20:18:51 <Cale> palomer: you sure? The state will carry through here
20:19:07 <palomer> oh yes, for this I don't care
20:19:22 <liyang> I'm too sleep to look up references. Good night all. :)
20:19:27 <palomer> see, my state is a [(s,s)]
20:19:28 <liyang> *sleepy
20:19:39 <Korollary> gn
20:19:43 <palomer> and I have a Foo s, and I want to narmalize elements of Foo s
20:19:53 <palomer> my state is a dag
20:20:06 <palomer> so I get a function like this
20:20:14 <Cale> palomer: okay, so write a recursive function which builds the computation
20:20:38 <liyang> (What I was going to say was, a lot of times, when you think you're using a monad... actually an applicative functor is sufficient.)
20:20:50 <Cale> sequenceFoo (Leaf m) = do x <- m; return (Leaf x)
20:21:11 <palomer> what's the type of that?
20:21:54 <Cale> sequenceFoo :: Foo (m a) -> m (Foo a)
20:22:34 <Cale> sequenceFoo (Node s ms) = do xs <- mapM sequenceFoo ms; return (Node s xs)
20:23:31 <palomer> ack, it turns out I need global state as well as local state
20:23:34 <Cale> that's a left-to-right traversal
20:24:05 <palomer> Cale: then I would do (sequenceFoo (fmap f bar)) ?
20:24:07 <Cale> but do you get the general idea?
20:24:13 <Cale> yes
20:24:15 <palomer> yup
20:24:33 <palomer> so sequenceFoo has type Foo (m a) -> m (Foo a)
20:24:34 <palomer> gotcha
20:24:50 <palomer> so how do I add global state to my little monad?
20:25:48 <lispy> one of the things that really blows me away about haskell is that if i write 'foo = fmap' then i can use foo and there is no penalty (other than readability).
20:26:16 <lispy> other languages would require a function call at least (although maybe a smart compiler could help)
20:26:23 <petekaz> lispy: not lisp
20:26:24 <palomer> inlining hasn't blown me away since 1985
20:26:51 <lispy> but it's not just inlining here
20:26:52 <Korollary> I dont think any ml variant needs any indirection
20:26:55 <lispy> equals is equals
20:28:09 <petekaz> lispy: (setf (symbol-function 'mycons) #'cons)
20:28:48 <lispy> petekaz: alright, well lisp is pretty sweet :)
20:29:00 <petekaz> lispy: or even simpler in scheme (define mycons cons)
20:29:05 <lispy> it's just so easy and something you do a lot in haksell
20:29:37 <palomer> but, erm, this isn't stated in the report, is it?
20:29:52 <lispy> the referential transparancey is actually the property i was after not so much the example
20:30:17 <palomer> so referential trasparency blows you away?
20:30:24 <lispy> yeah
20:30:28 <petekaz> Can anyone tell me if "Introduction to Functional Programming" by Bird is a good book?
20:30:29 <lispy> it's pretty slick
20:30:46 <lispy> petekaz: i've heard that name a lot but never read the book
20:31:14 <lispy> petekaz: i think a lot of people must read Haskell: School of Expression
20:31:33 <palomer> Cale: see, I need to get new variable names
20:32:15 <petekaz> lispy: the problem I have with that book is that I have absolutely no interest in the problem domain.
20:32:26 <palomer> which is?
20:32:36 <petekaz> multimedia
20:33:21 <Korollary> that book bored me.
20:33:43 <petekaz> Korollary: which one, school of expr, or intro to fp?
20:33:50 <Korollary> school of expr
20:34:11 <olliej> dcoutts: woo... just copmiled Monad... what it compiled as is beyond me, as i sure as hell haven't implemented higherkinded types
20:34:45 <dons> ?karma+ olliej
20:34:45 <lambdabot> olliej's karma raised to 1.
20:34:55 <olliej> dons: yo
20:35:31 <olliej> dons: what's scarier is whatever it produced was valid C#
20:35:33 <olliej> ...
20:36:02 <olliej> dons: ah... it doesn't apply type args to type args, so the code looks valid, as there's nothing dependant on it
20:36:22 <olliej> dons: you aware of how ghc does higher kinded types?
20:36:26 <lispy> petekaz: i haven't ready any haskell books other than the report :)
20:36:35 <lispy> petekaz: i took classes on haskell and googled a lot
20:36:48 <lispy> that and asking questions here
20:37:06 * palomer thinks he may need StateT (STateT m s) s' a
20:37:16 <lispy> people like Cale and dons (and many others) tend to be really helpful for pointing out how to write better code
20:37:22 <palomer> is StateT (StateT m s) s' a isomorphic to StateT m (s,s') a ?
20:37:50 <petekaz> Yeah. I like books that I can read while I do cardio at the gym.  I'm also interested in techniques of fp while taking advantage of haskell features.  Something like a SICP for haskell I suppose.
20:37:54 <palomer> I actually went to a university that had a class dedicated to haskell
20:37:58 <palomer> never took it
20:38:07 <olliej> dons: as technically i can do macro expansion, but it looks like i can keep track of what kind a variable is, although not the exact type if i use type erasure
20:38:31 <olliej> dons: which will mean is not statically verifiable, and relies on runtime checks from time to time
20:38:46 <Korollary> petekaz: Okasaki's functional datastrucures & algorithms book is praised often.
20:39:20 <lispy> i found that in java 1.5 even with generics that foo.clone() is completely annoying and requires a cast (meaning the compiler can't help with type checking)
20:39:58 <olliej> lispy: that's because java generics aren't enforced by the runtime
20:40:00 <petekaz> There was, at least what I thought to be, an interesting thread on c.l.l. the other day.  I was thinking of perhaps posting one similar to the haskell list.  Basically, the thread was about beautiful code.  The author wanted to find what people considered very well written code that uses proper abstractions, features of the language, etc .. 
20:40:54 <petekaz> Korollary: ok I'll check that out, i think i may have downloaded it a long time ago when I first tried investigating haskell.
20:41:16 <palomer> yeah, I never understood why Cloneable wasn't made generic
20:41:32 <araujo> petekaz, the best book out there for Haskell imho
20:41:35 <olliej> palomer: because it can't be
20:41:43 <palomer> why?
20:42:06 <olliej> palomer: as all the generic type info you see is at the language rather than vm level
20:42:17 <palomer> yes...
20:42:25 <palomer> oh, good point
20:42:30 <olliej> palomer: if you do reflection on List<Integer> you'll see it's just a List
20:42:48 <olliej> palomer: as far as the jvm is concerned there isn't a difference
20:43:26 <palomer> nope, don't see it
20:43:33 <olliej> palomer: which has the downside of meaning you can't absolutely guarantee that your List<Integer> won;t contain a String
20:43:39 <olliej> palomer: ?
20:44:39 <palomer> if A implements I<A> and A' implements I<A'> and A' is a subtype of A then calling A.foo  should do the right thing
20:45:05 <palomer> but the type returned will be of A
20:45:12 <palomer> this'll still save casting
20:45:33 <olliej> yeah, it saves you manually casting
20:45:33 <palomer> (foo is a member of I)
20:45:45 <olliej> the java compiler shoves the casts in for you
20:45:55 <palomer> that's what lispy is complaining about
20:46:06 <lispy> clone returns Object
20:46:08 <palomer> ahh, but you don't need to cast anyways
20:46:15 <palomer> lispy: java has covariant return types
20:46:29 <palomer> so members of subclasses can return subtypes of what the members of the parent class would return
20:46:43 <olliej> anyhoo
20:46:53 * olliej gets back to obliterating type information himself
20:47:46 <lispy> i have stuff like, ArrayList<Integer> foo = bar.clone();  and the compiler throws errors.  So I have to add casts like, ArrayList<Integer> foo = (ArrayList<Integer>)bar.clone();  Then if i change it so that bar is really ArrayList<Double> the compiler doesn't notice
20:48:09 <olliej> lispy: yup
20:48:11 <lispy> palomer: that's what i'm complaining about :)
20:48:22 <lispy> it actually happened to me today
20:48:27 <olliej> because they're booth actually just plain old ArrayList
20:48:28 <palomer> what's the type of bar?
20:48:32 <olliej> without any adornment
20:48:45 <palomer> ok, so you may need to cast BECAUSE of java 1.5
20:48:51 <palomer> generics in java 1.5 are really broken
20:48:59 <palomer> but you never needed to cast in versions prior
20:49:13 <lispy> you needed to cast a lot with collections
20:49:44 <lispy> whenever you take an object out of a collection you'd have to cast it from Object before you could use it intelligently
20:50:03 <palomer> right
20:50:06 <palomer> but not because of clone
20:50:16 <palomer> I'm talking about clone casting
20:50:43 <lispy> okay
20:51:28 <palomer> my beef with java generics is that you can't do anything with Foo<bar>[]
20:53:33 <lispy> what do you mean?
20:53:39 <palomer> try it
20:53:53 * lispy is confused
20:53:57 <lispy> what am i trying?
20:54:04 <palomer> TreeMap<Int>[] a = new TreeMap<Int>[]();
20:54:09 <palomer> you'll get a compiler error
20:54:18 <lispy> you want an array of treemaps?
20:54:35 <palomer> yeah
20:54:38 <palomer> you can't get one
20:54:43 <lispy> really?
20:54:48 <palomer> try it
20:55:02 <lispy> TreeMap[] a = new TreeMap[](); is okay but not with the templated type?
20:55:04 <lispy> that's weird
20:55:10 <wolverian> yeah. you're supposed to use List etc.
20:55:11 * lispy doesn't have java installed on his home machine to test it
20:55:31 <palomer> lispy: yup
20:55:50 <lispy> what is wrong with it?
20:55:53 <lispy> why is it broken?
20:56:59 * araujo wonders what PL is people discussing in here
20:57:31 <lispy> araujo: hehe
20:57:39 <dons> araujo: didn't you know. last night we all voted, and decided to become #java 
20:57:41 <araujo> :-)
20:57:56 <lispy> it's like abnormal psychology.  You learn more about the good ones by studying the weird ones :)
20:57:59 <araujo> haha, don't try to scare me off dons ! 
20:58:10 <dons> its the syntax and the generics we like. and the fact we don't have to worry about monads any more
20:58:20 <araujo> hahaha
20:58:40 <araujo> And its beautiful GC :-)
20:58:45 <lispy> main = do System.out.putStrLn "Hello, World!"
20:59:08 <lispy> araujo: oh good....i hate the java GC
21:00:57 <araujo> hah, i remenber once a friend of mine who wrote very long long long function names for a java assigment on purpose to make it unreadable to the teacher
21:01:06 <araujo> As a way of making fun of it :-)
21:01:23 <araujo> (java)
21:01:48 <araujo> dons, now i see you around, may i privmsg?
21:03:56 <lispy> hmm...so if i take this job offer and pay an extra $600/month on my student loans from undergrad i can pay them off by Mar. 2010
21:04:06 <palomer> palomer@palomerites:~/school/test$ javac bad.java
21:04:07 <palomer> bad.java:26: generic array creation
21:04:07 <palomer>         List<bad>[] a = new List<bad>[5];
21:04:07 <palomer>                         ^
21:04:07 <palomer> 1 error
21:04:09 * lispy takes this to haskell-blah
21:04:17 <palomer> generic array creation is impossible
21:04:35 <olliej> wow, java truly does suck
21:04:57 <olliej> palomer: use C# it's a standard ;)
21:05:13 <lispy> i prefer ArrayList<foo> over arrays most of the time anyway...but yeah taht's lame
21:06:00 <palomer> you have to do this
21:06:30 <palomer> List<bad>[] a =  (List<bad>[]) new List[5];
21:07:08 <palomer> and then everytime you compile it gives you a warning
21:07:13 <palomer> bloody nuisance
21:07:21 <palomer> imagine that, a warning for an explicit cast
21:07:34 <araujo> geez, noise for my eyes
21:08:17 <palomer> the problem with C# is that it's not completely linux friendly
21:08:36 <palomer> so I prototype in java and implement in C++
21:09:44 <palomer> and do my research in haskell
21:11:17 <araujo> you know what i'd like, now i think about it....
21:11:26 <araujo> A Haskell -> java bytecode translator
21:11:38 <araujo> That would make my life more pleasant in the univ.
21:12:51 <araujo> Something like bistro....
21:13:01 <sethk> dons, are you about?
21:13:13 <palomer> araujo: to make it even slower?
21:13:48 <araujo> palomer, no, i don't usually care about speed in the univ really. That wouldn't be much of a problem.
21:13:55 <palomer> why not run it on VMware so that you'll have to wait until 2020 to print Hello World
21:13:57 <araujo> And i don't think why it should necessarily be slow.
21:14:02 <araujo> bistro isn't that slow.
21:14:30 <araujo> i just wanna avoid noise with the ugly java syntax.
21:15:00 <palomer> so bistro already does this?
21:15:12 * araujo gets so pudding
21:15:21 <araujo> palomer, something like taht, but for Smalltalk
21:15:32 <palomer> but smalltalk isn't haskell!
21:15:42 <araujo> mm.. yeah, that's the whole point
21:15:58 <palomer> my speed comment was w.r.t. haskell
21:16:17 <palomer> oh, and it would consume _even more_ memory than the corresponding java program
21:16:24 <araujo> oh, well, my comment was about smalltalk being not _that_ fast you know
21:16:37 <palomer> there are some speedy smalltalk compilers
21:16:40 <araujo> haskell shouldn't be doing worse than it.
21:16:56 <araujo> palomer, such as?
21:17:51 <araujo> mm.. taste weird... 
21:17:54 * araujo boings
21:17:55 <palomer> visualworks
21:18:46 <araujo> mmm.... 
21:19:11 <araujo> I have used VW, and i don't see very big speed difference between Haskell and it
21:19:40 <araujo> Just that VW (as uses to happen with most Smalltalk imple) is a whole IDE and such.
21:19:54 <palomer> well, I think we've come far enough in our discussion to agree that I'm right and you're wrong
21:20:08 <araujo> uh?, why?
21:20:09 <palomer> end of story
21:20:24 <palomer> here's my closing argument:
21:20:25 <palomer> @palomer
21:20:26 <lambdabot> learning vim is pointless
21:20:30 <palomer> @palomer
21:20:31 <lambdabot> hrmph
21:20:33 <palomer> @palomer
21:20:33 <lambdabot> Scalliwags!
21:20:35 <palomer> @palomer
21:20:36 <lambdabot> They're telling you lies!
21:20:44 <palomer> blargh! is what I was looking for
21:20:47 <araujo> hahaha
21:20:52 <araujo> See, that's why i love lambdabot 
21:21:00 <palomer> never gives you what you want?
21:21:14 <araujo> lambdabot, i love you
21:21:25 <araujo> mmm... 
21:21:32 <palomer> learning vim IS pointless
21:22:15 <araujo> palomer, the point is that i still don't see why you say Haskell shouldn't be slower or worse than Smalltalk on top of a JVM!
21:22:29 <dons> wonderful palomer.
21:22:36 <araujo> You need to run a whole IDE env. to run Smalltalk code using VW, not happening the same with Haskell.
21:22:45 <araujo> At least, not at that degree.
21:23:00 <palomer> ok, but my memory argument still holds
21:23:01 <araujo> s/shouldn't/should/
21:23:05 <araujo> bahi can't type today
21:23:19 <palomer> and, like, you wouldn't be able to use any of the java library
21:24:00 <araujo> palomer, i don't want to use java!!!!
21:24:09 <palomer> then don't!!!!
21:24:17 <araujo> palomer, i want to use the JVM!!!
21:24:21 <araujo> When im at univ
21:24:24 <palomer> do it!!!
21:24:30 <palomer> why?
21:24:32 <araujo> It's the standard programm running in all computers
21:25:22 * araujo sings the song "That's the Way It is"
21:25:24 <palomer> but, erm, a linker is also a standard program running in all computers
21:25:52 <araujo> Standard in thge sense is the only language, among with VB allowed to run in all of the pc.
21:26:10 <sethk> not every machine has a jvm
21:26:19 <palomer> you can't  run executables?
21:26:29 <palomer> or binaries
21:26:33 <araujo> sethk, they do, at least that's the way here
21:26:40 <araujo> im not saying it is like that worlwide :-P
21:26:45 <palomer> no, they don't.
21:26:46 <palomer> face it.
21:26:56 <araujo> *sighs*
21:27:14 * palomer high fives sethk 
21:27:30 <palomer> thanks for bringing in the clinching argument
21:27:59 <araujo> Unless he studies in the same univ, his arguiment got no validation :-P
21:28:02 <sethk> there's this tiny company called microsoft who tries to keep java off of PCs, you may have heard of them
21:28:13 <palomer> nope
21:28:14 <araujo> But i won't say that now
21:28:21 <palomer> do they make air conditioners?
21:28:41 <sethk> palomer, possible  :)
21:28:42 * araujo pours some pudding on palomer's head
21:29:24 <palomer> I don't know why universities are so pro java
21:29:37 <araujo> $$$
21:30:27 <sethk> the profs don't want to have to deal with student assignments in a language with GC
21:30:35 <araujo> And im not talking about the ($) operator ;-)
21:30:41 <palomer> s/with/without
21:30:57 <sethk> right, without, sorry
21:31:04 <palomer> don't let it happen again
21:31:23 <sethk> I've got a race condition in my code, it bends my brain
21:31:31 <lispy> well, java is more type safe than say, C.  so I can see why language theory people might say, "Fine if we have to teach them an industry language, let's at least make sure it has _some_ type safety."  And voila, you have java classes
21:31:31 <araujo> hah
21:37:10 <fons__> I know I asked this before but I lost the link, how are exceptions managed in Haskell?
21:37:20 <fons__> someone wrote a link to a document before
21:37:47 <sethk> fons_, start with Control.Exception in the library docs
21:38:01 <sethk> fons_, and there are several info things.  check the wiki to start
21:38:19 <dons> @docs Control.Exception
21:38:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
21:39:19 <lispy> it's less scary than you might think
21:39:37 <lispy> especially if you're coming from C++ where it's quite hard to navigate the gotchas
22:02:51 <fons__> thanks for everything
22:02:56 <fons__> time to go to bed
22:02:57 <fons__> bye
22:09:50 <newsham> hi
22:10:40 <lispy> hi
22:29:50 <skew> palomer: You are looking for a MonadPlus with references that get reset on backtracking? I'm pretty sure that's STM.
22:33:39 <skew> palomer: unfortunately, throw/catchSTM doesn't seem to roll back, but retry and orElse will
22:34:20 <lispy> heh, orElse, nice
22:34:33 <lispy> i can just imagine: do a `orElse` b
22:34:44 <lispy> it sounds so imperative
22:36:05 <skew> ah, that is the documented behavior. I suppose it's so you can build something that handles the exception and is happy with whatever side effects did happen
23:02:48 <mwc> Wow, Amazon.ca has Benjamin Pierces "Advanced Topics in Types and Programming Languages" on for $48 canadian
23:02:58 <mwc> ships 1-2 months, but great price
23:11:34 <Korollary> are you already through with TaPL?
23:11:46 <Korollary> I'm still at Ch9
23:16:01 <sethk> mwc, check the publisher, they can probably ship it in one day for the same price
23:18:03 <mwc> Korollary, I'm hoping to get to it this summer
23:18:21 <mwc> Appel's ML Compiler book should get here next week
23:18:50 <mwc> then I'll get to the first one
23:19:00 <mwc> so by the time the second one gets here in July, I should be set
23:20:14 <Korollary> mwc: TaPL itself goes into pretty advanced topics.
23:20:44 <Korollary> I'm planning on quitting around Ch18-19 (31 chapters total)
23:21:28 <mwc> Korollary, I'm building a reference library
23:34:21 * lispy has been meaning to finish TaPL
23:34:27 <lispy> but i haven't even started it :)
23:34:56 <lispy> i also dream of going through Knuth's books and implementing a bunch of his algorithms in haskell for the experience
23:35:16 <mwc> I've been boning up on Standard ML. Robert Harper confirmed an email I sent him today about a mistake I found in his tutorial/book draft
23:35:35 <lispy> why ML?
23:35:39 <lispy> (just wondering)
23:35:53 <mwc> It's the langauge in Osaki's book, and Appel's compiler book
23:36:00 <lispy> oh
23:36:03 <lispy> gotcha
23:36:07 <mwc> I know I could implement in in haskell pretty easily
23:36:25 <mwc> but I'd prefer to do it in the native language so that I can focus on learning as opposed to implementing
23:36:57 <mwc> from what I can tell: signature -> class, structure -> instance, and i'm not yet sure about functors
23:37:24 <lispy> ocaml functors don't really make sense to me
23:37:35 <lispy> they seem really backwards when i try to do anything with them
23:37:46 <lispy> but, i think it's partly because i confuse them with type classes
23:38:47 <mwc> I looked at Ocaml, but the 31-bit'dness of the ints disgusted me.
23:39:02 <mwc> Mlton manages fast garbage collection without resorting to that
23:39:12 <mwc> just strikes me as inefficient and sloppy
23:39:42 <lispy> i'd say it's ad-hoc and very much a special case meant to not scare people away from using ints
23:39:54 <lispy> but in the end, no one wants to use them because they don't have the full range
23:40:11 <Korollary> I don't think many people care about the full range actually
23:40:45 <lispy> well, floats share the same 31bit problem and lets say you're doing image analysis?
23:40:48 <mwc> Korollary, it strikes me as being a real pain to interface with OpenGL or whatever
23:40:54 <lispy> then you can't store 32bit colors without wasting space
23:40:57 <Korollary> Considering that nobody even bothers with overflow conditions, I'd say that most integers people deal with are rather small.
23:41:06 <Korollary> ah
23:41:13 <mwc> Korollary, yeah, but they're used as bitmasks too
23:41:55 <mwc> so you have to resort to using boxed integers for all your code that touches foreign (C) stuff
23:42:43 <Korollary> ocaml is unpleasant in other ways anyway
23:42:56 <lispy> Korollary: yeah, that's what i found when i explored it
23:43:08 <lispy> i don't like the syntax at all compared with haskell
23:43:55 <mwc> Yeah, even comparing ocaml to sml, ocaml seems to have been beaten with the ugly stick
23:44:11 <Korollary> I don't mind the syntax that much. It just feels too imperative.
23:45:41 <mwc> http://www.ps.uni-sb.de/~rossberg/SMLvsOcaml.html
23:45:47 <mwc> side by side comparison
23:46:22 <lispy> ah, i've seen that page before
23:46:56 <lispy> i wish they had pages like that at the programming language shootout
23:47:02 <Korollary> Check this out regarding running out of file handles: http://www.ocaml-tutorial.org/garbage_collection
23:47:50 <lispy> Korollary: yeah i found that page to be an interesting read
23:48:51 <lispy> according to the ocaml community the GC is very nice
23:49:23 <mwc> the MLton one seems to be pretty good
23:49:24 <Korollary> ahah "really_input"
23:49:46 <mwc> it switches between generational, copying, and mark-sweep depending on memory load
23:49:52 <mwc> tries to avoid swapping at all costs
23:51:39 <Korollary> For file copying, the side-by-side examples are bad. There's got to be way to copy the file without holding it all in memory?
23:52:05 <mwc> Korollary, lazy evaluation?
23:52:19 <Korollary> no, I mean incrementally reading and writing
23:53:04 <Korollary> explicit closing of the handles also looks ugly. I don't know if that's even necessary, tho.
23:53:04 <mwc> dunno, thought that's how copying worked
23:53:10 <lispy> Korollary: get a smaller HD if the algorithm isn't working :)
23:53:20 <mwc> actually duplicating the bits on the HD
23:53:33 <mwc> maybe you could program the DMA controller to do it?
23:53:52 <lispy> this is the reason i hate perl: my $io = new IO::File "< $_" or die;
23:54:04 <lispy> what the crap is "< $_" supposed to be doing?
23:54:11 <Korollary> mwc: I meant: read one fixed amount from the source file, write that buffer out, then read the next batch, etc. Even a C program that does this does not look half ugly.
23:54:33 <Korollary> lispy: open file for input whose names is in $_
23:54:44 <Korollary> *name
23:55:05 <Korollary> $_ is the default storage variable in for loops, etc.
23:55:20 <lispy> that's gotta be thread safe
23:55:22 <lispy> :)
23:55:35 * lispy shrug
23:55:42 <lispy> i never got perl's way of doing things
23:55:44 <newsham> $_ is a pronoun.
23:55:48 <lispy> so much secret global state
23:55:52 <newsham> its used often
23:58:29 <Korollary> outputFile = file("target.txt") \n for line in file("source.txt"): outputFile.write(line) \n.
23:59:07 <newsham> file("target.txt", "w").write(file("source.txt").read())
23:59:16 <Korollary> doesn't work too well with a file with a really long line, but it still beats those ml/ocaml example imho
23:59:19 <newsham> (dont forget "w")
23:59:23 <Korollary> ah yes
