00:07:33 <dons> yo
00:12:26 <dons> kzm?
00:20:08 <kzm> hi dons!
00:20:52 <metaperl> @seen Cale
00:20:53 <lambdabot> Cale is in #haskell. I don't know when Cale last spoke.
00:21:26 * kzm will get a cup of coffee, and then see if dons is back.
00:24:00 <kzm> Drat.  They're going to clean my windows, right now.
00:24:16 <kzm> I'll try again in five to ten minutes?
00:28:30 <dons> hey
00:28:52 * dons thinks kzm should just ask his question
00:29:27 <dons> ?localtime kzm
00:29:29 <lambdabot> Local time for kzm is Wed Apr 26 09:29:07
00:31:40 <kzm> okay.
00:31:46 <kzm> coffee - check, windows - check
00:32:11 <kzm> I'm looking a bit at FPS.
00:32:17 <dons> yeah?
00:32:24 * dons fires up vim.
00:32:51 <kzm> Regardless of what people "expect" on the list, I have plenty of text in latin1
00:33:04 <dons> :)
00:33:27 <kzm> So I started to wrap Char8 with real Latin1 handling - that is, instead of truncating to 8 bits, U+>256 is an error.
00:33:41 <dons> oh, that should be easy enough.
00:33:54 <dons> replace unsafeChr with chr, iirc.
00:34:01 <kzm> Yep.  No problem (of course, I haven't gotten far enough to actually compile it :-)
00:34:15 <kzm> I can reuse most anything that only uses w2c, but c2w is replaced with a check.
00:34:44 <dons> right. that's the idea. but you pay for that check of course.
00:34:59 <kzm> Many functions only need one check (elemIndex, say, if char > 256 the answer is Nothing, and you don't need to check it at all)
00:35:18 <dons> right. most c2w are on inital args, and performed only once
00:35:26 <dons> foldl and friends, and map, are the exceptions to this
00:35:30 <kzm> So for random Unicode, that is likely to be faster! (no O(n) string search)
00:36:32 <dons> Is the *.Char8 name ok for you for the truncating Char layer?
00:36:36 <kzm> I thought perhaps one could write a generic template for character sets, and implement a new one by specifying, say, newline, spaces, and a translation table, and then #include'ing the template.
00:36:51 <dons> I thoguht that since John and Einar agreed on it, that it was a good name :)
00:37:12 <kzm> Yes.  I wondered about proposing Char7, but you're probably going to filter out my messages if I do, so...
00:37:14 <dons> hmm. let me see how SimonM's code works in this regard.
00:37:20 <dons> hehe
00:37:42 <kzm> Is there any benchmark code in there that will test c2w?  I'm curious about the costs.
00:38:22 <dons> yes. run Bench.hs. it should compare side-by-side functions that use c2w in Char8 and those from the root taht don't
00:38:28 <dons> currently, there's no difference
00:38:28 <kzm> Anyway, I'll make a Latin1 as a sibling of Char8, and if I don't tire of it, perhaps I can make modules for some other charsets as well...
00:39:02 <dons> I see Simon made UCS2 and UCS4, just by:
00:39:04 <dons> #define CHARTYPE Word16
00:39:04 <dons> #define CHARBITS 16
00:39:04 <dons> #define MODULENAME UCS2
00:39:17 <dons> and then #include his base packed string lib.
00:39:25 <kzm> I was wondering if, for ASCII, >127 should be stored in some higher region of UC?
00:39:47 <dons> no idea.
00:39:47 <kzm> Ooh.
00:40:37 <kzm> I mean, so that isUpper and isLower can return false, and not what they would have been if it were iso latin1?
00:40:40 <dons> if you want to look at Simon's code, it's here: http://www.cse.unsw.edu.au/~dons/packedstring.tar.gz
00:40:51 <dons> ah. right
00:41:18 <kzm> Just as a way to maintain numerical integrity (w2c . c2w) = id
00:41:34 <kzm> (vice versa, I guess)
00:41:41 <dons> right.
00:42:16 <kzm> Also, I made it an error to c2w something that doesn't belong in the charset.  Would it be better to write an "error character"?  0? 255?
00:42:48 <dons> no, it should be an error, surely?
00:42:54 <kzm> Is Simons code nice?  Worth digging into?  Yours seemed to be the right thing.
00:42:57 <dons> that's the Haskell way.
00:43:21 <dons> oh, its jsut interesting in that he used #defines to get simultaneous UTF8, Latin1, UCS2 and 4
00:43:36 <dons> its somewhat slower than fps these days though. 
00:43:42 <kzm> you may want it to just go on, and ignore it, or whatever.  However, the user could do that higher up (filter (<256.ord) or something)
00:44:08 <kzm> From an array of bytes?
00:44:14 <dons> well, I don't want any checks in the Char8 layer, anyway. but Latin1 probably should.
00:44:28 <dons> no, it depended on CHARSIZE #define
00:44:48 <dons> so UTF8 was an array of Word32, iirc
00:44:49 <kzm> I've also thought a bit on variable encodings (UTF-*).  If we can do that, we might also be able to do quoted-printable :-)
00:45:50 <kzm> Hmm...almost the whole point of packed strings is to conserve space.  At least in my case, it's been a problem that strings get to big (readFile "my-huge-file.txt")
00:46:13 <dons> conserve space and time.
00:46:16 <kzm> (the point to me, that is.  It is really nice to implement wc almost as fast as C)
00:46:23 <dons> yeah, that get way too big.
00:46:54 <kzm> Anyway, I'll finish the Latin1, and perhaps you'll care to take a look at it?
00:47:06 <dons> its been easier to ensure the code gets faster (via Bench.hs) and the result has been less space usage in the process.
00:47:15 <dons> yes, sure. I'm happy to look at it.
00:47:47 <kzm> The right thing is a sibling module to Char8, as you want to retain Char8 without checks, right.
00:48:09 <dons> yes, I think so.
00:48:21 <dons> I want Char8 to be the flat-out fastest thing we've got.
00:48:32 <kzm> Okay. Stay tuned, there'll be more packed strings issues, right after this!
00:48:40 <dons> hehe great.
00:49:53 <kzm> Oh.  One more thing: filterChar.
00:50:04 <dons> yeah?
00:50:11 <kzm> filterChar c == replicate . count c
00:50:19 <kzm> (if there is a count, that is)
00:50:26 <kzm> (oh, bogus syntax)
00:50:51 <dons> what does count do?
00:51:02 <kzm> but you get the meaning - i.e. it gives a string of c's of length equal to the count of cs in the string.
00:51:28 <dons> ah!
00:51:32 <dons> yes. good point
00:51:51 <dons> so I can do a length  . elemIndices and then a memset
00:52:00 <kzm> Just wondering, it seems ... slightly less useful.  I usually filter either a range, or filter out stuff.  
00:52:05 <kzm> Yes something like that.
00:52:34 <kzm> Perhaps there should be a counting function, or will the lenght . -loop be deforested/optimized away?
00:52:39 <dons> I needed it for something, and then I needed filterNotChar. so both are ok, I guess.
00:53:00 <dons> a counting function is good I think. we can't rely on the optimisations.
00:53:02 <dons> good idea!
00:53:27 <dons> also, that gives me another QuickCheck property
00:53:31 <dons> ?karma+ kzm
00:53:31 <lambdabot> kzm's karma raised to 2.
00:54:20 * kzm smiles, and admires his new karma. :-)
00:55:42 <dons> count w (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
00:55:42 <dons>     let ptr = p `plusPtr` s
00:55:42 <dons>         STRICT2(loop)
00:56:09 <Korollary> This is absolutely fantastic: http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html
00:56:37 <metaperl> could someone please help me with two simple questions about the State monad: http://sequence.complete.org/node/175
00:57:33 <dons>         loop n i = do
00:57:33 <dons>                 let q = memchr (ptr `plusPtr` n) w (fromIntegral (l - n))
00:57:33 <dons>                 if q == nullPtr
00:57:33 <dons>                     then return []
00:57:33 <dons>                     else do let r = q `minusPtr` ptr
00:57:35 <dons>                             k <- loop (r+1) (i+1)
00:57:38 <dons>                             return k
00:57:40 <dons>     loop 0 0
00:57:43 <dons>   kzm :)
00:57:56 <dons> oh, that [] is wrong.
01:05:27 <dons> count is around 30% faster than length.elemIndices
01:05:46 <dons> now, to see if that improves my filterChar
01:12:08 <dons> ?karma+ kzm filterChar now runs in 0.068 instead of 0.195s
01:12:09 <lambdabot> kzm's karma raised to 3.
01:20:10 <kzm> Hey hey hey!
01:20:37 <kzm> Anyway, I've put my copy of your repo at http://www.ii.uib.no/~ketil/src/fps
01:21:05 <kzm> I have *not* really tested the Latin1 modules, except checking that pack throws an error on illegal characters
01:21:56 <kzm> I have not changed anything below the "encoding-specific" header(L.439)
01:22:38 <kzm> This calls for celebration!  I don't know about you, but I'll go and get a second cup of coffee!
01:27:58 <dons> i'll go and have some dinner :)
01:28:27 <dons> after i push this patch
01:29:20 <dcoutts> dons, great! (re: Data.ByteString no longer importing Data.Char)
01:35:03 <kzm> oh, crap, something went wrong with darcs, just one moment.  Dons, please just sit back and enjoy your dessert...
01:36:19 <dons> dcoutts: once I realised that removal of Data.Char would enforce the boundar y condition, that made it easy :)
01:36:26 <kzm> dons, I get:  % darcs repair
01:36:26 <kzm> darcs: Couldn't read patch Thu Aug 25 05:35:07 CEST 2005  Don Stewart <dons@cse.unsw.edu.au>
01:36:26 <kzm>   * Initial import of FastPackedString from darcs, with bug fixes from h4sh
01:36:35 <dcoutts> dons, right, yeah
01:36:36 <dons> darcs version ?
01:36:53 <kzm> 1.0.4pre2 (unknown)
01:37:30 <dons> hmm. can you get again? or maybe get --partial?
01:37:47 <dons> I've been able to darcs get with 1.0.4 many times without trouble
01:37:58 <dons> the 'count' patch is now applied.
01:39:22 <kzm> Yes, it may be old, but not old enough to give that kind of trouble, I should think.
01:39:46 <dons> right.
01:39:51 <dons> let me try to get.
01:39:57 <dons> also, that seems to be the very first patch in the repo.
01:40:45 <dons> $ darcs get --partial http://www.cse.unsw.edu.au/~dons/code/fps
01:40:46 <dons> Directory '/tmp/fps' already exists, creating repository as '/tmp/fps_0'
01:40:46 <dons> Copying patch 38 of 38... done!
01:40:46 <dons> Applying patch 37 of 37... done.
01:40:46 <dons> Finished getting.
01:41:15 * dons off to dinner
01:45:19 <kzm> hmm... did 'get' and 'repair', and it claims it is consistent...
01:46:32 <dcoutts> xerox_, good work!
01:47:35 <kzm> Hmm... it seems to have worked this time.  www.ii.uib.no/~ketil/src/fps
01:49:21 <kzm> dons?  In firstspace etc, you do: if (not . isSpace . w2c) w
01:49:50 <kzm> isn't it faster to check this on word values directly?
01:50:33 <kzm> I'll try to implement it in my Latin1 module, and we can perahps benchmark.  (The benefit is probably greater with more complex w2c functions)
02:08:22 <dons> kzm, well, we don't have isSpace on word though.
02:08:37 <kzm> This is the way I'm doing it:
02:09:01 <kzm> cut out the encoding specific stuff, and store it in encoding.ihs
02:09:37 <kzm> define isSpace :: Word8 -> Bool; space, newline, etc.. :: Word8 in Latin1, and then #include "encoding.ihs"
02:09:54 <kzm> Rewrite "encoding.ihs" to use the Word8 variants.
02:11:00 <kzm> Should probably not call it 'isSpace', since it conflicts with Char and is generally only useful interally.
02:13:38 <kzm> (what suffix to use for files only intended for #inclusion?)
02:14:35 <dcoutts> dons, good work on fps. I think you've got the right thing now, to say that it's .Char8 which is taken to be a subset of Unicode (at least that's the interpretation that you'll get if you convert to a Char) but that also means it's ok to have other ascii+ bytestrings so long as you don't take their converion to Char too seriously for values >127.
02:15:35 <musasabi> morning
02:15:43 <dcoutts> musasabi, g'morning
02:16:02 <dcoutts> musasabi, so it's .Char8 which is what you wanted
02:16:08 <kzm> Morning!
02:16:24 <musasabi> dcoutts: Char8 causes less problems than Char with the unicode advocates ;)
02:16:33 <dcoutts> yeah
02:16:36 <kzm> Yeah.  How much did you pay him, anyway?
02:16:38 <kzm> :-)
02:17:21 <dcoutts> and we've clarified what interpretation you get if do convert to Char (ie the 8bit subset of Unicode)
02:17:57 <dcoutts> but that doesn't mean you must only store unicode, you can use any old ascii extension so long as you're careful with conversions to Char
02:24:16 <shapr> Goood morning #haskell!
02:24:25 <shapr> Is Marc van Woerkom on #haskell?
02:24:45 <shapr> Which Language.* parsers would be most valuable?
02:24:59 <lypie> yoyo shapr
02:25:08 <shapr> y0 lypanov, ltns
02:25:16 <shapr> Why the nick change?
02:27:06 <musasabi> morning shapr 
02:27:39 <shapr> hyv√§√§ huomenta!
02:27:54 <ohub> no huomenta!
02:28:10 <shapr> mutta..
02:28:30 * shapr tries to remember more Finnish...
02:30:04 <dcoutts> shapr, C.
02:30:30 <shapr> Yeah, I thought so. C, PHP, etc for what someone ( mwc? ) bluntly termed 'sewage treatment'.
02:30:40 <dcoutts> heh, yeah
02:31:04 <dcoutts> various forms of IDL?
02:31:15 <dcoutts> less obviously useful
02:31:17 <shapr> Like CORBA?
02:31:26 <dcoutts> yes or COM
02:31:55 <eivuokko> hdirect has IDL parser
02:31:59 <shapr> I don't know enough about them or their roles to have an opinion on their priority.
02:32:18 <dcoutts> C is a good one because there are several useful forms
02:32:26 <eivuokko> IDL parser is incomparably useful when you need it ;)
02:32:34 <shapr> I'd rank Javascript ahead of IDLs, only because I've never used IDLs.
02:32:38 <dcoutts> eg the various standards + what is accepted by GCC
02:32:47 * dcoutts departs
02:32:58 <kzm> ei s√§√§ peit√§√§? (or something similar :-)
02:33:11 <eivuokko> saa
02:33:15 <kzm> ah.
02:33:31 <shapr> kzm: opitko Haskellia?
02:33:34 <eivuokko> saa = allow, s√§√§ = weather
02:33:34 <kzm> I'll keep that in mind, thanks :-)
02:33:55 * shapr yet again pretends to have a clue about Finnish
02:33:59 <kzm> and never cover the weather.
02:34:22 <kzm> non habla Finlandia, so sorry, gomen nasai.
02:34:29 <shapr> Speaking of which, I wonder what sort of grammar the ADIOS algorithm would turn out for Finnish.
02:34:57 <kzm> Are there any free (natural language) grammar checkers?
02:35:08 <kzm> Or writing style checkers?
02:35:12 * kzm wants one.
02:37:00 <kzm> @seen dons
02:37:00 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 28 minutes and 37 seconds ago.
02:37:33 <kzm> Hmm...that's half an hour, what's he doing, taking an after dinner nap?  I need him here, now!
02:37:41 <kzm> some people simply have no consideration for others! :-)
02:38:48 <kzm> anyway, dons, I wrote Word8 based string operations for Latin1.  Pull the repo and check.
02:45:36 * kzm wonders why everthing suddenly got so quiet.  And if anybody have used iconv.
02:46:17 <shapr> I'm trying to work on Python web stuff but instead being distracted by reading about dependent types and Epigram.
02:48:51 <araujo> morning!
02:49:16 <kzm> Hello.
02:49:56 <musasabi> kzm: what kind of layer? Just curious.
02:53:55 <mattam> shapr: you read about OTT already ?
02:56:39 <shapr> OTT?
02:57:59 <shapr> mattam: What's OTT?
02:58:17 <mattam> Observational Type Theory
02:58:38 <mattam> mixing Intens. and Extens. reasonning
02:59:41 <mattam> it's by Altenkirch and McBride, and they want to put it under Epigram
03:00:26 <shapr> I see the article, but I don't think I've read it yet.
03:01:06 <mattam> well if you do read it and get a clue how it would work in practice, i'm interested.
03:01:26 <shapr> he
03:01:29 <shapr> ok :-)
03:01:32 <mattam> :)
03:01:52 <kzm> musasabi, sorry, was off.  Layer, layer...what did I say?
03:02:08 <mattam> what are you reading then ?
03:02:29 <kzm> I'm adding a proper Latin1 module to FPS.
03:02:58 * mattam woners if Smerdyakov could be allowed to join #haskell again
03:03:14 <kzm> The main difference to Char8 is that writing (packing) a Char value > 255 will cause an error
03:04:07 <kzm> A side benefit is that string operations (lines, words, etc) will be faster, also in the Char8 module.  Or, at least, I think so.
03:04:28 <kzm> My modified Char8 passed the tests, but I haven't timed it.  
03:04:47 <musasabi> as long as the Char8 does not do the checks having an extra Latin1 module sounds nice.
03:04:54 <kzm> And there are probably inlining etc. to be done.
03:05:39 <kzm> Checks are used in surprisingly few places - often you just check once, and perform an O(n) operation only when the check fails.
03:06:19 <kzm> e.g. elem c for c > 256 will always fail right away.  Otherwise, checking adds a small constant to the string search.
03:07:16 <musasabi> kzm: how about pack?
03:07:32 <musasabi> that is very important for performance.
03:07:42 <kzm> Of course, elem c for c > 256 with Char8 will just truncate c, and check for the resulting character.  You get what you ask for.
03:07:53 <kzm> pack will add a constant factor :-(
03:08:11 <kzm> I haven't benchmarked it, perhaps I should?  Hang on a second...
03:08:17 <shapr> mattam: Nope, Smerdyakov will not be allowed to join #haskell again.
03:08:18 <musasabi> O(n) factor rather?
03:08:45 <kzm> Well, it is O(kn), for some k.
03:08:57 <kzm> ...constant factor k. 
03:09:15 <musasabi> O(kn) = O(n) iff k/=0
03:09:31 <kzm> I'm not up to speed on Cabal, what do I need to add my module to the library?  So that I can ./Setup install and have it instantly available?
03:09:45 <musasabi> kzm: edit the .cabal file.
03:09:55 <musasabi> there is a list of modules where you add it.
03:10:02 <kzm> Just add it to Exposed-Modules?
03:10:05 <musasabi> yes
03:10:21 * Oejet wonders how many are banned from #haskell.
03:13:01 <noj> Oejet, /bans
03:14:34 <Oejet> noj: Thanks (Argh, another command not working in Gaim.)
03:17:57 <eivuokko> Maybe /mode +b
03:18:39 <kzm> musasabi, you know you asked about the extra overhead?
03:18:47 <musasabi> yes
03:19:02 <kzm> I may be doing something wrong here, but I get a 4% extra overhead.
03:19:17 <musasabi> sounds like right.
03:19:22 <kzm> Going from 26 to 27 seconds.
03:19:36 <kzm> I'm queasy.  Want to make an independent test?
03:20:34 <musasabi> I am more interested in the performance for small Strings.
03:20:47 <musasabi> will be doing the benchmark for dons first.
03:21:01 <kzm> Oh, wait.  I also search it.  That should be subtracted from the time, of course.
03:21:16 <kzm> What is needed to make sure the packing isn't lazily delayed?
03:21:18 <falconair> I just started on the "Write Yourself a Scheme in 48 Hours" tutorial, the first program (run through HUGS98) gives me a syntax error "unexpected symbol "System.Environment"...did I miss something obvious (only thing I can think of is that the tutorial was written for GHC)
03:21:31 <kzm> I searched for a character not present, that should be on the safe side.
03:22:14 <kzm> Anyway, if you do string operations, I think I have reduced the overhead for that.  Both Latin1 and Char8.
03:23:01 <musasabi> kzm: if you can link your repo I can give you a profile with both dons code and your code.
03:24:02 <kzm> www.ii.uib.no/~ketil/src/fps
03:24:12 <kzm> Give me a sec, I'll incorporate the cabal file as well
03:24:40 <musasabi> don't need the cabal file.
03:25:51 <araujo> off to univ!
03:28:17 <Lemmih> Finally! I've been without internet for more than 24hours.
03:29:26 <Lemmih> @seen JaffaCake
03:29:27 <lambdabot> Last time I saw JaffaCake was when I left #flippi, #gentoo-haskell, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it and #scannedinavian 15 days, 1 hour, 12 minutes and 36
03:29:27 <lambdabot> seconds ago, and .
03:30:00 <musasabi> dons/kzm: are you able to compile Data.ByteString with GHC 6.4.1 ?
03:30:37 <musasabi> http://youzen.b2.fi/~musasabi/bse.txt <- error
03:36:57 <kzm> yes
03:37:02 <kzm> I use 6.4.1
03:37:32 <kzm> I've updated my repo, and pulled it to check that everything works.
03:38:06 <kzm> tests are running now...
03:38:33 <kzm> (only need to chmod +x Setup.hs tests/logpp; and s/gm4/m4 in tests/Makefile)
03:39:13 <kzm> And lemmih, you are lucky.  I've been without my DSL for about a week now.
03:39:45 <kzm> And before that, my ISP choked my connection to 64kbit, because I refuse to pay for something they haven't delivered.
03:40:11 <kzm> And since I have VoIP, I've essentially been without a phone as well for the better part of the year.
03:41:02 <eivuokko> I guess you don't have much choice for ISP?
03:41:25 <kzm> Sure I do.  My employer pays for this one.  It is free, and almost worth the money.
03:41:34 * kzm kicks his ISP.  *clank*
03:42:03 <eivuokko> Hmm
03:42:03 <kzm> musasabi, sorry, your error message is Greek to me.
03:42:34 <musasabi> kzm: ok, I'll use 6.4.2 for testing.
03:42:35 <kzm> I'm at a point where the reduced cell phone bills probably would pay for another ISP...
03:43:17 * kzm shrugs.  6.4.1 works for me.
03:44:02 <eivuokko> Isn't that error message from the mangler-thingy, and so it depends on gcc version as well?
03:45:49 <musasabi> yes
03:46:13 <musasabi> gcc (GCC) 4.0.3 (Debian 4.0.3-1)
03:46:15 <musasabi> here.
03:47:04 <kzm> gcc version 3.4.5 20051201 (Red Hat 3.4.5-2)
03:47:21 <kzm> Anyway: I ran my benchmark, using "last" to force the packing.
03:47:23 <dcoutts> musasabi, try turning down the gcc optimisations
03:47:58 <dcoutts> I assume the fps is using something like ghc-options: -optc-O3 -optc-fwicked-fast
03:48:08 <kzm> Get about 12 vs 11 seconds for 45Mb file.  Includes reading to list as well, of coures.
03:49:52 <kzm> Just reading it, and using (List.)last takes 4 secs.
03:51:46 <kzm> (of coures, the list can now be GC'ed as we go along etc.  Don't think it matters. Preliminary conclusion: pack does 6.5Mb/s in Char8, and 5.5Mb/s in Latin1.  Very roughly)
03:51:51 <musasabi> dcoutts: switching to 6.4.2 solved that.
03:51:56 <kzm> good!
03:52:04 <musasabi> Has anyone been able to use profiling and TH in the same program?
03:52:04 <kzm> Do let me know how things turn out!
03:52:20 <musasabi> I seem to get linker errors with both 6.4.2 and 6.5
03:52:25 <kzm> How do I build a profiling version of FPS?
03:52:40 * kzm should probably read the docs, but is too lazy. :-)
03:53:12 <musasabi> kzm: runghc Setup.hs configure -p
03:54:09 <musasabi> http://cvs.haskell.org/trac/ghc/ticket/651 :-(
03:55:32 <audreyt> let x = foldl f init string
03:55:36 <audreyt>   y = last string
03:55:44 <audreyt> in g x y
03:55:57 <audreyt> is there an (obvious?) way to take out the "last"?
03:57:53 <audreyt> (this is in  Parsec.Pos.updatePosString, so perf potentially does matter)
03:59:28 * audreyt notes that Cabal has no BSD2 nor MIT licenses
03:59:51 <audreyt> which makes Pugs.cabal.in a bit hard to write. hmm.
04:00:09 <tromp> there is a way yes
04:00:36 <tromp> which involves rewriting foldl
04:00:51 <audreyt> sure
04:01:15 <audreyt> so it has different cases for [x] and others?
04:01:37 <tromp> a case for [x] instead of a case for []
04:01:56 <audreyt> aye
04:02:22 <tromp> myfoldl f a [x] = g (f a x) x
04:03:18 <audreyt> k, thanks
04:09:44 * xerox waves
04:09:50 <audreyt> xerox: yo
04:09:59 <xerox> Hey audrey!
04:10:03 <audreyt> xerox: so SoC rejected me :)
04:10:11 <xerox> Aww :-(
04:10:30 <xerox> Let's do it together now :-)
04:10:36 <audreyt> however, I do have quite some numbers of ideas, mostly about missing haskell libraries that we need :)
04:10:41 <audreyt> sure :)
04:10:46 <audreyt> where do I sign up?
04:10:53 <xerox> See the link on the topic
04:11:02 <audreyt> got it
04:11:27 <xerox> Mind to list the ideas a bit now?
04:12:03 <audreyt> most are too "practical"... :)
04:12:10 <xerox> Sounds okay :-)
04:12:11 <audreyt> make StringMap conform to Data.Map API
04:12:15 <lypie> audreyt: what was the reason behind the reject?
04:12:19 <audreyt> JudyHS and JudyL bindings
04:12:23 <audreyt> lypie: they offered no reasons
04:12:31 <lypie> audreyt: email chris directly
04:12:41 <audreyt> lypie: what chris?
04:12:44 <lypie> audreyt: and try several times
04:12:44 <audreyt> oh
04:12:46 <audreyt> that chris.
04:12:48 <lypie> aye
04:13:01 <audreyt> they rejeected most of the last-few-days submitters I think
04:13:10 <audreyt> and I'm not sure what to say in the mail
04:13:42 <lypie> audreyt: that pugs is 1337 and google probably want people that could work on pugs :P
04:13:45 <audreyt> revive Packrat and put Text.Regex.* frontend on them
04:13:53 * xerox listens carefully
04:13:56 <audreyt> (would be _very_ useful)
04:14:22 <audreyt> libiconv, librecode, libicu bindings with a common interface
04:14:27 * xerox waves to Lemmih 
04:14:32 <lypie> xerox: any luck with osx/x86?
04:14:49 <xerox> lypie: some mails with Pang, but nothing precise yet
04:14:52 <audreyt> Cabalize my Data.Yaml.Syck and write instances to all GHC's standard types
04:14:58 <musasabi> Getting audreyt to mentor someone on how to do unicode right for Haskell would be very nice :-)
04:14:59 <lypie> xerox: bummer. good luck
04:15:21 * xerox nods vigorously
04:15:26 <audreyt> once we have libiconv etc encodings, hook FPS with them and implement Char* on top of it
04:15:36 <audreyt> ( I need to do that for Pugs anyway to meet the spec)
04:15:55 <audreyt> _definitely_ a TArray and a TMap
04:16:20 <xerox> SimonMar added projects, woo!
04:16:29 <xerox> audreyt: uhm.
04:16:45 <audreyt> xerox: there is already TArray stub
04:16:54 <musasabi> which is slow.
04:17:01 <audreyt> exactly my point.
04:17:07 <xerox> (-;
04:17:38 <dcoutts> xerox, you've been working hard! good job.
04:17:47 <xerox> dcoutts: thank you very much :-)
04:18:01 <xerox> I'm so happy that we're having more contributions
04:18:03 <kosmikus> good evening
04:18:04 <audreyt> oh, and stack traces
04:18:16 <audreyt> RTS can do that even in normal mode, using cascading exceptions
04:18:24 <audreyt> that will be very nice
04:18:36 <xerox> audreyt: do you think those project have to be somehow packed to be worth three months of code, or what did you have in mind?
04:18:41 <ProfTeggy> kosmikus, where are you right now?
04:18:49 * xerox waves to kosmikus 
04:19:05 <dcoutts> xerox, did you say Igloo was going to help with SoC ?
04:19:07 <kosmikus> ProfTeggy: Japan
04:19:12 <ProfTeggy> Aha
04:19:18 <xerox> dcoutts: Yes, I just read your mail.
04:19:53 <dcoutts> xerox, perhaps we could persuade Igloo to supervise a darcs GUI project - though I could certainly advise on the GUI aspects
04:20:05 <xerox> dcoutts: yes we should :-)
04:20:22 <dcoutts> I think it really needs a darcs expert and some GUI technical advice (maybe me)
04:20:30 <xerox> Also, mentors *may* supervise more students, but that's a personal choice we have to make clear.
04:20:37 <xerox> Right.
04:20:59 <dcoutts> because I don't have a very clear picture of what the darcs people would want from a GUI, though I have some ideas
04:21:07 <dcoutts> like porting the meld diff/merge widget!
04:21:24 <xerox> One will surely have to refer to the proper mls, as I did with Cairo last year.  But having a darcs-devel mentor will certainly help much in order to get it done.
04:21:33 <xerox> Ooooh.
04:21:51 * xerox notes it
04:21:51 <dcoutts> but perhaps that (the meld bit) is big enough to be a seperate project :-)
04:22:13 <dcoutts> one could do a darcs GUI without it, but it'd be much cooler with it
04:22:52 <audreyt> xerox: I think the "Unicode" branch is definitely 3month
04:23:11 <audreyt> that would include lib*conv, FPS+Encoding, Char*, and toplevel Str
04:23:11 <xerox> audreyt: I do agree
04:23:26 <audreyt> and I'd be very very happy to mentor someone on it
04:23:33 <audreyt> we even have specs and prototype implementations :)
04:23:33 <xerox> audreyt: would you be up for mento<Interrupted by audreyt>
04:23:44 <xerox> Great!  Fill in a ticket!
04:24:26 <xerox> dcoutts: noted on the Darcs GUI ticket, #17
04:24:32 <dcoutts> xerox, ta
04:24:39 <musasabi> kzm: http://www.ii.uib.no/~ketil/src/fps does not work.
04:24:45 <kzm> Ai.
04:24:57 <kzm> For what values of 'not work'?
04:25:10 * xerox waves to kzm 
04:25:16 <musasabi> for http taking 10 secs to reply
04:25:40 <audreyt> xerox: as for the various data structures currently missing (or very slowly emulated)
04:25:50 <audreyt> xerox: I think it can qualify as another 3month task as well, provided a clear enough roadmap
04:25:51 <kzm> I see.
04:26:24 <musasabi> A fast mutable hashtable would be a good task.
04:26:28 <kzm> We probably have some problems on the webserver then.  It is, unfortunately, beyond my control.  I'll complain, of course.
04:26:29 <xerox> audreyt: there are some Data.ByteString projects too, they are all split up at the moment, I don't know how to organize them
04:26:30 <musasabi> But that is nontrivial.
04:27:21 <audreyt> musasabi: FFI JudyHS :D
04:27:27 <audreyt> (which is what Pugs is doing)
04:27:41 <boegel> kzm: works fine here (the url)
04:28:00 <xerox> What is JudyHS?
04:28:15 <audreyt> xerox: a very fast, self-tuning, hash+patricia-trie code
04:28:22 <audreyt> http://judy.sourceforge.net/
04:28:24 <musasabi> kzm: your fps code dies:
04:28:25 <musasabi> nfps_kzm: internal error: stg_ap_p_ret
04:28:26 <dcoutts> xerox, how does google decide how many projects we're allowed to have?
04:28:26 <musasabi>     Please report this as a compiler bug.  See:
04:28:26 <musasabi>     http://www.haskell.org/ghc/reportabug
04:28:29 <audreyt> also has Map variants.
04:28:43 <kzm> musasabi, as if that is *my* fault? :-)
04:28:48 <xerox> dcoutts: we're going to request a number, iirc, but I don't know the exact details now
04:29:01 <musasabi> "/opt/ghc-6.4.2/bin/ghc -prof -auto-all -O2 -o nfps_kzm --make   -ifps_kzm -iHAppS/src httpd.hs" was my compile line.
04:29:18 <xerox> So, mentors.
04:29:18 <dcoutts> xerox, wow it's going to be hard to prioitise
04:29:19 <musasabi> kzm: not your fault, but my excuse for not providing a profile for you.
04:29:23 <kzm> Hmm... I haven't tried profiling yet, could that be the problem?
04:29:24 <xerox> dcoutts: indeed.
04:29:29 <Lemmih> Hiya xerox.
04:29:31 <kzm> Ah, okay then :-)
04:29:38 <dcoutts> xerox, what's a realistic number? 3 5 7 +?
04:29:56 <xerox> Mentors: if you have an account on the trac, start filling up the "Interested Mentors" entries for projects you're interested in.  If you don't have an account, ping me.
04:30:38 <xerox> dcoutts: *dunno*  Last year Apache had 30+, for example, but others got even less than 10, *shrug*
04:31:51 <musasabi> dons: http://youzen.b2.fi/~musasabi/nfps.prof
04:31:55 <kzm> musasabi, does it work without profiling?  I can try to build some profiling stuff, and see if that works for me?
04:32:07 <Lemmih> xerox: I don't think I have an account.
04:32:21 <xerox> audreyt: JudyHS looks like a good way to get some of those datastructures people is asking for
04:33:29 <audreyt> xerox: and JudyL is a very good sparse array.
04:33:34 <kzm> audreyt, xerox: I really would like to add compressed indexes as well: FMindex, LZindex etc etc.  C implementations are available, but from my quick tests, they may not be entirely bugfree yet.  Some C skills required :-)
04:34:05 <kzm> (Actually, I intended that to be part of my tasks)
04:34:08 <audreyt> JohnMeacham benched Judy1 against Set, and found that Judy1 is much much faster for cases requiring updates (not surprising)
04:34:33 <dcoutts> xerox, and on what basis should we prioritise? chance of project working * general usefullness of project ?
04:34:47 <kzm> I have applications that use Maps of Ints or similar, and could probably be made much faster.  And more importantly, perhaps, more compact.
04:35:06 <audreyt> yup
04:35:11 <xerox> dcoutts: we'll need administrators brainstorming on that
04:35:16 <dcoutts> xerox, yeah
04:35:25 <dcoutts> xerox, anyway, that's my suggestion
04:35:28 <kzm> If somebody wants to co-mentor on this, that would be great.  I can do the tools part, but some help on the FFI bits would be good.
04:36:23 <audreyt> kzm: I'd be happy to help where I can
04:36:41 <musasabi> kzm: yes I think that is profiling specific.
04:37:37 <kzm> audreyt, you're on! :-)
04:42:55 <audreyt> xerox: mm, I can't list myself as mentor
04:42:58 <audreyt> on ticket #12
04:43:13 <audreyt> oh nvm
04:43:18 <audreyt> sorry, I forgot to log in ;)
04:45:21 <audreyt> xerox: I merged my main ideas under #12 and listed myself along with dons as possible mentor.
04:47:09 <xerox> Urgh I've missed something.
04:47:57 <audreyt> 13:46 < audreyt> xerox: I merged my main ideas under #12 and listed myself along with dons as possible mentor.
04:48:07 <xerox> Great.
04:48:44 * xerox <- forkIO lunch; waitFor xerox -- ;-)
04:48:47 <audreyt> so, what about Pugs-specific projects? e.g. "Pugs - Optimizing Haskell code generator backend for Perl 6"
04:48:58 <xerox> audreyt: yes, go for them
04:49:26 <xerox> audreyt: we'll get a pugs "Topic:" if there are many
04:49:34 * xerox bounces happily
04:54:15 <audreyt> how do I set such a Topic?
04:54:24 * audreyt has, like, 16+ items :D
04:54:36 <audreyt> (but I'll group them into 3month coherent chunks)
04:54:39 <audreyt> bbiab
04:56:00 <amiddelk> Hi, I'm getting a build error when building the HEAD branch of GHC (check: http://pastebin.com/682785). Anyone willing to comment on this? The problem occurs when the makefile executes:    g    cmm/CmmLex.x   (seems like something is missing)
04:56:43 <amiddelk> Problem does not only occur on my redhat pc, but also on a mac osx machine
04:59:14 <momo3> instruction Google Adsense--> http://planet.nana.co.il/hartk2003/Google.htm                 Download FirefoxÆ -->  http://planet.nana.co.il/hartk2003/FireFox7.htm
05:07:07 <eivuokko> amiddelk, Do you have alex installed or getting compiled?  I think .x is supposed to be compiled by it.
05:08:47 <amiddelk> eivuokko: I do not have alex on my machine
05:09:40 <amiddelk> and: configure:5462: checking for alex (result no)
05:10:39 <lypie> i'm here!
05:10:50 <lypie> it didn't look very far!
05:25:38 <pesco> Hm, I have a project idea (which I'd like to apply for as a student) for the SoC. Should I just enter it in the trac linked from Google's site?
05:25:53 <mlh> wfm
05:34:09 <Cale-work> what's up with www.haskell.org?
05:34:17 <dcoutts_> pesco, what's the idea? And you should probably tell xerox so he can add it to the list (if it's a good idea!)
05:34:46 <pesco> dcoutts_: The idea is to put STM into Yampa.
05:35:11 <dcoutts_> Cale-work, yeah, I'm having trouble loggin in
05:35:45 <pesco> dcoutts_: I hope this would have several benefits, like more modularity, (hopefully) a solution to the full-cpu-on-idle problem.
05:35:54 <dcoutts_> Cale-work, the problem is that there are 151 httpd processes running
05:36:00 <pesco> dcoutts_: Oh, insert an "and" there behind the second comma.
05:36:09 <dcoutts_> Cale-work, and they're all stuck
05:36:17 <Cale-work> The web server seems not to be responding. The site responds to pings though.
05:36:21 <Cale-work> ah
05:36:28 <Cale-work> that would do it :)
05:36:58 <pesco> dcoutts_: It might also provide a stepping stone towards network-transparent signal transformers.
05:37:15 * dcoutts_ retarts httpd on haskell.org
05:37:37 <kzm> One question about FPS and Char8.  I'm tempted to take all the functions out, and just #include them in each module (except c2w and w2c).  Some need a check for whether a Char value is a unicode char valid in the single byte encoding (latin1 or whatever).
05:38:13 <kzm> So I define an is_valid and the included functions look like "if is_valid c then ... else ..."
05:38:36 <kzm> Now, if is_valid c == True (for Char8), can I rely on the check being optimized away? 
05:38:46 <pesco> dcoutts_: Either by way of adding network-transparency to STM (as hinted in that paper, already, IIRC) or by replacing the STM with an arbitrary monad, or by some other trickery, I haven't completely thought through.
05:38:57 <kzm> (and where is dons when I need him?) 
05:38:59 <kzm> @seen dons
05:38:59 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3 hours, 30 minutes and 35 seconds ago.
05:39:24 <dcoutts_> Cale-work, it's back
05:39:30 <Cale-work> cool
05:39:50 <dcoutts_> pesco, sounds interesting, try emailing the idea to xerox 
05:40:20 <pesco> dcoutts_: Okay... is he the organization administrator for haskell.org?
05:40:36 <pesco> Should I also mail it to the Yampa people, maybe?
05:42:11 * pesco grins at JaffaCake.
05:42:31 <JaffaCake> hiya ;)
05:42:32 <pesco> JaffaCake: I was just thinking about the STM paper, of which you are one of the authors, I believe?
05:42:42 <JaffaCake> right
05:43:11 <pesco> JaffaCake: I think I remember that in the paper, you hinted at making STM network-transparent somehow?
05:43:31 <JaffaCake> I don't recall that
05:43:41 <JaffaCake> certainly not my idea
05:43:42 <pesco> Hm, was I dreaming then?
05:43:47 * pesco checks.
05:44:30 * xerox -> back
05:45:15 <musasabi> pesco: that needs extending STM with commit hooks.
05:45:28 <musasabi> pesco: basically one needs to make STM support 2PC
05:45:36 * xerox waves to JaffaCake 
05:45:44 * JaffaCake waves back
05:45:56 <xerox> Thanks again for the support, man!
05:46:51 <JaffaCake> no problem :)
05:47:03 <pesco> musasabi: What's 2PC?
05:47:13 <dcoutts> hia JaffaCake, I like the idea for a GHC hackathon. :-)
05:47:32 <JaffaCake> great, you'll be coming then?
05:47:37 <dcoutts> I'm not sure I'll be able to make it to the west coast of the US however (which is where it'll be right?)
05:47:45 <musasabi> pesco: two phased commit.
05:47:46 <JaffaCake> yup
05:48:04 * dcoutts suggests the next GHC hackothon should be in Cambridge UK :-)
05:48:13 * xerox grins
05:48:20 <JaffaCake> maybe the next one, if this one is successful
05:48:21 <musasabi> http://en.wikipedia.org/wiki/2PC
05:48:40 <dcoutts> JaffaCake, I might be able to go, I'll have to see
05:49:02 <JaffaCake> good value trip: Hasklel workshop, ICFP, GHC hackathon
05:49:08 <dcoutts> yeah, true
05:49:12 <xerox> Is it like a bit on-site hacking project?
05:49:24 <pesco> musasabi: Ah, right.
05:49:32 <dcoutts> xerox, yeah
05:50:43 * xerox wonders
05:51:14 <kosmikus> GHC hackaton will be when?
05:51:48 <JaffaCake> kosmikus: around ICFP this year, probably 
05:51:50 <xerox> kosmikus: hey there
05:52:09 <dcoutts> kosmikus, http://hackage.haskell.org/trac/ghc/wiki/Hackathon
05:52:27 <kosmikus> just saw it.
05:52:56 <xerox> kosmikus: it would be cool if you could add your GH ideas on the trac
05:53:18 <kosmikus> JaffaCake: yes, I'd try to participate
05:53:27 <JaffaCake> kosmikus: great!"
05:54:06 <dcoutts_> JaffaCake, do you have any ideas suitable for the hackathon? that bit of the page is looking a bit empty :-)
05:54:44 <JaffaCake> dcoutts_: I thought we could work on debugging,for one thing
05:54:46 <kosmikus> JaffaCake: only GP workshop is on 16th. I'll probably have to go there ...
05:55:14 <kosmikus> ah, I got confused by the dates.
05:55:23 <dcoutts_> JaffaCake, that'd be interesting, we were talking about some kind of ghc heap walkver/viewer in the context of the SoC programme
05:55:33 <xerox> pesco: if you get your head around the idea, just ping me
05:56:10 <xerox> Right http://hackage.haskell.org/trac/summer-of-code/ticket/6
05:56:15 <pesco> xerox: Okay, will do.
05:56:30 <JaffaCake> dcoutts_: a heap walker would be cool, perhaps integrated with the front panel
05:56:55 <dcoutts_> JaffaCake, I was thinking it'd be better to take it out of process so we could code it in Haskell
05:57:04 <JaffaCake> ah, I see
05:57:09 <dcoutts_> JaffaCake, and communicate with the rts over a pipe
05:57:15 <eivuokko> Eh, why not debug?
05:57:27 <eivuokko> Debug interfaces aren't that hard on most systems
05:57:31 <JaffaCake> sure, the front panel could work that way too
05:57:39 <dcoutts_> JaffaCake, coding Gtk+ is C is such a pita :-)
05:57:44 <kosmikus> xerox: I'll put it on my TODO list. After re-adjusting to the European time during the weekend, I hope I can start working on all the things I've neglected during the past few weeks.
05:57:59 <xerox> kosmikus: sounds great.  Thank you!
05:58:31 <JaffaCake> google doesn't mention an upper limit on the number of projects one person can mentor... is there one?
05:58:39 <xerox> JaffaCake: no, there isn't
05:59:09 <JaffaCake> I don't know if I can mentor yet, but I'd like to
05:59:29 <xerox> It would be sweet.  Any student contacted you?
05:59:44 <dcoutts_> JaffaCake, that'd be great. You mean because you don't know if you'll have time or for other reasons?
05:59:50 <JaffaCake> someone asked me today about doing a distcc-like thing for GHC
06:00:08 <dcoutts_> could be interesting
06:00:18 <xerox> Yeah, I think so too.
06:00:31 <JaffaCake> dcoutts_: don't know about the politics... google is giving away money, we'd have to be clear the money wasn't coming to MS :)
06:00:35 <xerox> We've got plenty of orphaned projects on the trac.
06:00:43 <dcoutts_> JaffaCake, yes it'd go to haskell.org
06:01:05 <dcoutts_> and who knows what they're planning to do with it, xerox?
06:01:14 <JaffaCake> hopefully it should be ok, I'm checking at this end anyway
06:01:16 <xerox> dcoutts_: "mentors" ?
06:01:43 <dcoutts_> xerox, it can't go to the mentors, it'd have to be some central fund for something
06:01:48 * xerox would love if capable people will be up to get a number of students under their wings
06:01:52 * dcoutts_ has to go teach
06:02:01 <xerox> dcoutts_: ah sorry, answered the wrong question
06:02:09 <xerox> dcoutts_: the administrator will have to decide.
06:02:14 <dcoutts_> xerox, right
06:02:14 <gaal> Is there a way to type a function in Haskell that takes e.g. Just Just Just Just Just Just 42 and yields 42? And have it work on arbitrarily deep Maybes? I can't think of a way to type this.
06:02:16 <xerox> Lemmih proposed a nice thing
06:02:29 <JaffaCake> it'd might be a good thing to have a haskell.org fund anyway 
06:02:37 <pesco> gaal: Type classes.
06:02:40 <JaffaCake> in case we have to pay for hosting, or something, in the future
06:02:41 <xerox> Like, getting hardware to put up a server to sponsor Haskell projects.
06:02:56 <pesco> The haskell.org foundation. :)
06:03:04 <xerox> Give people webspace, GHC, Haddock, Cabal, Hackage, and all the goodies... to hack on Haskell projects.
06:03:16 <gaal> pesco: how? unJust :: (Monad m) => m a -> a   -- won't work, for example
06:04:09 <pesco> gaal: unJust :: (Maybes m) => m a -> a, where Maybes is to be your own class (with unjust as a method).
06:05:26 <gaal> pesco: who are the instances of Maybes?
06:05:38 <xerox> Maybe something like class Unpackable u a | u -> a where unPack :: u -> a; instance Unpackable (Maybe a) (Maybe a) where unPack = fromJust; instance Unpackable (Maybe a) a where unPack = fromJust  ?
06:06:08 <xerox> (Adjust the glitches, if it makes sense.)
06:06:24 * xerox welcomes shapr 
06:06:45 <shapr> y0
06:06:48 <musasabi> xerox: that will not work.
06:06:55 <xerox> musasabi: Aww.
06:07:03 <musasabi> xerox: the problem is that overlapping instances and fundeps are not very compatible.
06:07:11 <xerox> Hmpf.  It would have been nice.
06:07:23 <musasabi> yes, having them work would be very nice.
06:07:34 * xerox hears "SoC" in the background music
06:07:38 <pesco> shapr: yo
06:07:48 * gaal was thinking the same thing
06:08:42 <musasabi> kzm: I don't know about your changes but fps 0.3 is faster than the current darcs version in my benchmarks. Has to do with pack.
06:09:10 <xerox>  Functional dependencies conflict between instance declarations:  :-(
06:09:12 <musasabi> kzm: see http://youzen.b2.fi/~musasabi/nfps.prof/
06:10:23 <pesco> JaffaCake: I think I must have been imagining tha part about network-TVars. Probably from the section on related work on transactions. Anyway, do you think it could be a viable idea? Yes, it pops up all the usual issues about protocols and serialization, but assuming that, it would be really nifty, wouldn't it?
06:12:06 <musasabi> pesco: it doesn't work very well with untrusted peers. GPH STM would be easier in any case.
06:12:44 <pesco> musasabi: Hm, okay. Well, just popping around ideas. :)
06:21:07 <xerox> musasabi: I can't come up with a way to unPack properly, do you have any ideas?
06:22:24 <musasabi> xerox: Oleg had some stuff on this I think.
06:22:35 <xerox> Dang.
06:24:03 <musasabi> xerox: http://okmij.org/ftp/Haskell/types.html#is-function-type
06:25:12 <xerox> I got it work, yay
06:25:25 <xerox> But it has some problems with polymorphic types :-)
06:25:29 <musasabi> So what did you use?
06:25:40 <xerox> Let me do some test a second
06:26:43 <xerox> No, sorry, nevermind.
06:26:57 <xerox> If it doesn't do the polymorphic type it doesn't recur.
06:29:41 <kzm> musasabi, hmm, that was a bit disheartening.  Slower by how much?
06:31:17 <musasabi> kzm: very noticeable in benchmark runs, but the exact slowdown depends entirely at the things I throw at it.
06:31:17 <kzm> And was it introduced by me, or by dons?
06:31:29 <musasabi> kzm: this is the dons darcs code.
06:31:40 <kzm> If you only use Char8, I don't think I should have affected it much.
06:31:53 <kzm> OK, I wouldn't know about that.
06:32:05 <musasabi> May be about RULEs
06:33:56 <kzm> For the Latin1 module, there is probably something to be gained with INLINE as well.  As I don't have a benchmark, I haven't bothered yet.
06:35:03 <kzm> @seen JaffaCake
06:35:03 <lambdabot> JaffaCake is in #haskell. I last heard JaffaCake speak 32 minutes and 23 seconds ago.
06:35:23 * xerox mumbles.
06:36:23 <C-Keen_> re
06:37:13 <xerox> Oleg's fundeps are obscure.
06:38:16 <musasabi> kzm: you might want to add a is_latin1 predicate as well as is_c0 and is_c1 predicates.
06:40:18 <kzm> Hmm...maybe.  How so?
06:40:40 <kzm> (I.e. shouldn't they be in Data.Char instead?)
06:41:11 <musasabi> hmm, point.
06:41:32 <kzm> Anyway, I've refactored it a lot, Latin1 is just a few lines, some of which are #include directives.
06:41:42 <kzm> ...which can be reused for other charsets.
06:42:37 <kzm> If we can rely on \_ -> True functions to be optimized away, there should be no slowdown compared to Char8, except for slightly more complicated mapping of characters to Unicode, and checking.
06:42:54 <kzm> Again, some (rare) things will be much faster.
06:43:08 <kzm> I must run shortly, please mail me any feedback/complaints.
06:43:18 * kzm hopes the web server is in working condition.
06:43:20 <musasabi> see you later.
06:53:07 * xerox scratches head
06:59:58 <dons> musasabi: so it looks like packWith is the problem?
07:00:02 <dons> (which woudl make sense)
07:00:21 <musasabi> yes, most probably packWith.
07:00:50 <xerox> gaal: did you succeed perchance?
07:01:05 <dons> its easy to fix. I'll move the old pack into the Char8.hs module in the morning, and rerun the benchmarks
07:01:50 <musasabi> thanks
07:02:25 <dons> the packWith solution was an easy way for me to divide up the code, and I crossed my fingers it wouldn't hurt anything. but why do you use pack at all, I wonder?
07:02:41 <dons> what needs to be packed?
07:04:14 <musasabi> String literals?
07:04:27 <musasabi> Getting a way to float them to top-level would solve things.
07:04:36 <kzm> Hmm. false alarm, there was no lecture.
07:04:41 <dons> oh, you can always: packAddress "fooo"#
07:05:02 <musasabi> let me try with that one.
07:05:25 <kzm> dons, I have some policy issues.  In particular, I'm putting #include to great use, and I wonder if that is kosher.
07:05:49 <dons> there's a RULE that should turn pack into packAddress, but it doesn't alway fire. Seems like this is the case in your code.
07:06:13 <dons> kzm, hmm. hard to say. probably not always good, if you can code it up using the module system instead somehow.
07:07:34 <gaal> rehi
07:07:41 <gaal> xerox: no :(
07:09:20 <dons> musasabi: I'm off to bed. I'll look at pack in the morning. if you have any further results, i'm happy to look at those too. gives me more hints on what to focus on.
07:09:47 <musasabi> dons: relead the profile page in the morning, I'll try explicit packAddress.
07:10:09 <dons> ok. good.
07:10:24 <kzm> I'm waiting for parametrized modules :-)
07:10:32 <kzm> I could do it in ML?
07:11:04 <kzm> dons, one more thing, if you're not too tired,
07:11:29 <kzm> I #include most of the functions, modified to check validity.
07:12:13 <kzm> I think if tests with null validity checks (i.e. valid x = True) get optimized away, this could be used for Char8 as well, with no preformance loss.
07:12:29 <kzm> Would make everything nice an non-redundant, etc.
07:12:50 <kzm> And each charset module only needs to provide a handful of definitions.
07:25:28 <pitecus> Does anybody know of a Haskell library to generate edit lists (something like http://www.shiro.dreamhost.com/scheme/gauche/man/gauche-refe_152.html#IDX2883)
07:26:31 <Igloo> darcs has some LCS code, but I'm not sure how straightforward the current iteration is
07:26:53 <Igloo> Oh, and there's http://urchin.earth.li/darcs/ian/lcs/ too
07:27:41 <pitecus> Thanks I'll have a look
07:58:44 <nibro> anyone around who knows the SoC trac pages?
07:59:29 <sjanssen_> nibro: http://hackage.haskell.org/trac/summer-of-code/
07:59:35 <sjanssen_> @where SoC
07:59:35 <lambdabot> I know nothing about soc.
07:59:43 <sjanssen_> @help where
07:59:43 <lambdabot> where <key>. Return element associated with key
07:59:56 <sjanssen_> @help where+
07:59:56 <lambdabot> where+ <key> <elem>. Define an association
08:00:08 <sjanssen_> @where+ soc http://hackage.haskell.org/trac/summer-of-code/
08:00:09 <lambdabot> Done.
08:00:47 <xerox> Hey nibro!  May I ask you what are you interested in exactly?
08:01:04 <nibro> sure you may :-)
08:01:28 <xerox> Are you a student or a possible mentor, for instance? :-)
08:01:49 <nibro> I'm a potential mentor, I'm trying to add tickets for a few proposals I have
08:01:59 <xerox> Nice!  What are them about?
08:02:10 <nibro> I managed to add one just fine, but I wasn't happy with it, and I can't find how to edit it
08:02:21 <xerox> Just tell me.
08:02:32 <nibro> and I can't "register", the system complains about a missing .htpasswd file...
08:03:03 <sjanssen_> nibro: guessing from your nick, are you the HSP guy?
08:03:08 <nibro> the ticket is #52: the edit I wanted to make was to add myself as an interested mentor
08:03:21 <nibro> sjanssen: indeed :-)
08:04:24 <xerox> nibro: fixed.
08:04:56 <nibro> xerox: great! and thanks for helping make this happen :-)
08:05:22 <xerox> Thank you very much :-) !
08:05:28 <nibro> xerox: I have a question that I can't find the answer to anywhere at Google
08:05:36 <xerox> Ask right away
08:06:08 <nibro> do you know how they will decide how many student proposals are accepted for each organization?
08:06:48 <xerox> nibro: difficult to say.  Organizations are going to ask for a number, and then, dunno.
08:06:53 <nibro> there are quite a few sponsoring organizations listed, and if each of them has as many proposals as we do...
08:07:13 <xerox> Last year the slots went from 4-5 to 30+ (Apache).
08:07:27 <sjanssen_> will we have applicants for all of those proposals?
08:07:37 <xerox> This year is said that they'll double the 400 slots available last one.
08:07:44 <xerox> sjanssen: spread the word! :-)
08:08:23 <sjanssen_> xerox: I'm afraid I don't know any Haskellers outside IRC
08:08:28 <sjanssen_> I'll be applying
08:08:40 <xerox> sjanssen_: very nice!  What project?
08:09:22 <sjanssen_> unicode packedstring, liberating the byte code from FPS to a more general datatype
08:10:18 <sjanssen_> probably another FPS related thing
08:11:05 <xerox> Good :-)
08:11:36 <sjanssen_> xerox: do you have a pet project, or is it Top Secret?
08:11:39 <xerox> I think there are Google SoC flyiers one can put around in the units
08:11:47 <xerox> sjanssen_: more likely undefined :-)
08:22:36 <xerox> Added a categorized view of the projects on the StartPage.
08:35:51 <nibro> xerox: what does it mean for proposals to be in bold or italics?
08:36:34 <xerox> nibro: nothing
08:39:36 <nibro> so why do they show differently?
08:41:54 <xerox> They don't, at least here.
08:46:21 <nibro> heh, weird... just curious though, some bug in the trac software?
08:46:52 <nibro> xerox: just added proposal #54, care to do the same thing again? :-)
08:47:12 <xerox> nibro: sure!
08:47:21 <xerox> nibro: check that is not due to caching
08:47:28 <nibro> xerox: ... oh, and I see I forgot to write my email, maybe you'd like to add that too...
08:47:35 <xerox> I added it.
08:48:31 <nibro> xerox: it's not due to caching, I can do all manner of stuff to the page including reloads but some tickets show up as italics or bold
08:48:39 <xerox> Bold = new
08:48:45 <xerox> Italics doesn't exactly matter
08:49:02 <nibro> yeah, that figures, the two last ones are in bold
08:49:15 <nibro> nm, just curious by nature ;-)
08:49:27 <xerox> Does HSP have a webpage?
08:49:58 <nibro> yes it does: http://www.cs.chalmers.se/~d00nibro/hsp
08:50:11 <xerox> What difficulty could I mark for this project?  Do you think "1 person, Summer" fits?
08:50:31 <xerox> (See the other possibilities maybe)
08:50:37 <nibro> it really depends on the person (and the summer ;)
08:50:49 <xerox> I'll leave it undefined
08:51:11 <nibro> I don't have a suitable model in mind - if the person has some ideas to start with it could perhaps go fast
08:51:31 <xerox> np
08:52:02 <nibro> what about the smaller projects - the SoC thingey is supposed to be for the whole summer right?
08:52:34 <xerox> Yep
08:52:40 <xerox> We need to think up a policy for them
08:52:43 <xerox> Like, grouping.
08:54:05 <nibro> how will the ranking procedure be done? should we let lambdabot randomize? :-)
08:54:44 <xerox> That's a possibility :-)
09:00:05 <mnislaih> xerox: hi ?
09:00:17 <xerox> mnislaih: hey
09:00:22 <mahogny> xerox, ok. confirmed; minh thu is cool for the project he wants. it can be fit into the schedule. haven't heard of the other guy that sent me a mail earlier though
09:00:36 <mnislaih> is the SoC trac open for editing ?
09:00:55 <xerox> mahogny: good.  We'll be waiting to have the proposal through Google to fill the Students spaces anyway, I think.
09:01:11 <xerox> mnislaih: parts, what do you want to edit?
09:01:13 <mnislaih> i.e., I just want to see if I can put my name where it says "students interested", that in a few 12 projects
09:02:16 <xerox> Leave me your details in mail, I'll put it if that's the case
09:02:37 <mnislaih> okz
09:03:08 <mahogny> oohh. ghc hackaton has already received a nice suggestion
09:03:49 <wchogg> Do you know if they're planning to post slides of the lectures about ghc at the hackathon?
09:04:11 <mahogny> not that well read up on it
09:04:21 <mnislaih> the hackaton would be in Oregon, then ?
09:04:55 <mnislaih> or where is Galois conn. located ?
09:07:30 <shapr> Portland Oregon
09:08:03 <shapr> Same place as the next ICFP
09:09:35 <shapr> I really wanna go to the next Haskell Worshop at least, I suspect it'll be one of the most fun for years around it.
09:10:03 <dcoutts_> mahogny, I wonder who made that suggestiong :-)
09:10:15 <shapr> Oh hey
09:10:22 <mahogny> dcoutts, :)
09:10:33 <shapr> Let's organize the next EuroHaskell to happen just after HW!
09:10:40 <dcoutts_> shapr, good idea
09:11:09 * mahogny wonders why all nice phd positions are offered at the place in sweden that is the furthest away from his home. another mile or so, and you are in the sea :P
09:11:55 <nibro> mahogny: what's wrong with the chalmers ones? :p
09:12:13 <shapr> Yeah, chalmers kicks butt.
09:12:22 <mahogny> nibro, of some reason, they don't really fit me. any of them :)
09:12:37 <mahogny> nibro, except a few, which I have applied for but not gotten in :(
09:13:09 <shapr> Chalmers gets *lots* of PhD applications.
09:13:22 <mahogny> believe me, I know :P
09:13:30 <mahogny> especially mathematics and CS
09:13:42 <shapr> yup
09:14:39 <mahogny> and physics usually request phd's for the strangest fields, and bio/chem phd positions are almost always completely without a theoretic part
09:15:02 <shapr> You can probably get some nice logic theory positions in France.
09:15:07 <mahogny> no comment about the phd's mech engineering offers >_<
09:15:15 <nibro> mahogny: ah, knowing you, you want one where you can apply computer science, physics, chemistry and automation theory at the same time... ;)
09:15:25 <mahogny> shapr, logic ... is probably one of the two fields I hate most :)
09:15:41 <mahogny> nibro, yes. and you find tons of such positions (not really)
09:16:32 <shapr> hej nibro, long time no see.
09:17:03 <mahogny> nibro, oh wait. slow reaction. I finally recognized who you were ;)
09:17:07 <nibro> shapr: hej d‰r :-)
09:17:38 <mahogny> nibro, did you get in on something finally?
09:17:43 <nibro> shapr: I know, I know, my irc periods are, um, periodic
09:17:57 * shapr pratar om enhjuling p√• #unicycling
09:18:05 <nibro> mahogny: yep, I got in on my second try
09:18:12 <mahogny> nibro, lucky sob :)
09:18:17 <mahogny> nibro, what is your topic? type theory?
09:18:40 <nibro> mahogny: not sure I have a topic yet
09:18:42 <Pawer> hello
09:18:43 <dcoutts_> shapr, I found out why my coker was having problems
09:18:47 <Pawer> can you help me?
09:18:47 <shapr> dcoutts_: What was it?
09:18:50 <sjanssen_> @elite Pawer
09:18:50 <lambdabot> paweR
09:18:57 <nibro> mahogny: not type theory though - I'm more applied
09:18:57 <shapr> Pawer: What do you need help with?
09:19:03 <Pawer> with let in
09:19:11 <Pawer> i have bird
09:19:15 <mahogny> nibro, oh, thank god. I almost thought you were a lost soul for a while =)
09:19:22 <dcoutts_> shapr, I sent in a bunch of pics of the issue (the forks were going out) and the guy said it was not uncommon with that model.
09:19:25 <Pawer> let in statement
09:19:37 <dcoutts_> basically not enough inward tension on the forks
09:19:55 <nibro> mahogny: heh, I still like to do weird things with the Haskell type system, but that's a far cry from type *theory* ;)
09:20:06 <dcoutts_> so the best long term solution is to have the wheel rebuilt with a 1-inch wider hub 
09:20:13 <mahogny> nibro, yeah, that's hardly the same thing :)
09:20:35 <dcoutts_> shapr, which I can have them do if I turn up to the next Brittish Unicycling Convention :-)
09:20:59 <shapr> dcoutts_: Cool, I've seen the extra wide hubs for sale.
09:21:13 <shapr> Have you seen the aero wheels?
09:21:18 <nibro> mahogny: I've been doing some HSP stuff (my thesis) and some stuff in language-based security, but I'm not sure if any of that will make it into the phd thesis...
09:21:21 <dcoutts_> no, were?
09:21:42 <mahogny> nibro, oohh... lbs. are you a fan of JIF? :)
09:22:36 <nibro> mahogny: not really - too little theory behind it, and too much intrusion on the coding style
09:22:42 <mahogny> nibro, agree
09:22:49 <nibro> mahogny: but that could just be that I don't like java in general ;)
09:22:57 <mahogny> nibro, and the compiler crashes for silly reasons, but that's another thing
09:22:59 <Pawer> anyone can help?
09:23:14 <sjanssen_> Pawer: sure. what exactly is your problem?
09:23:27 <mahogny> nibro, oh. java is a good start at least. I like any effort meant for replacing C++ :)
09:24:21 <nibro> mahogny: a friend just got a paper accepted detailing a serious flaw in JIF - pointers are not opaque, and they can be deterministically made to leak the value of secrets. great huh? :)
09:24:30 <sjanssen_> > let x = 3.5 in 4 * x
09:24:31 <lambdabot> 14.0
09:24:47 <mahogny> nibro, I guess half the programs in the world have a serious bug then? ;)
09:25:15 <shapr> dcoutts_: Hm, I can't find it now, but I've seen pix (and prices) for a fully aerodynamic no-spokes racing rim for the Coker.
09:25:32 <nibro> well, any program not tracking information flow policies wouldn't be buggy per se, just unsafe :-p
09:25:32 <Pawer> and into a function?
09:25:37 <mahogny> nibro, are you into formal proving anything?
09:26:14 <sjanssen_> > let f x = 4 * x in f 3.5
09:26:15 <nibro> mahogny: like agda? no, I'm trying to stay clear of that, despite peer pressure. ;-)
09:26:15 <lambdabot> 14.0
09:26:23 <dcoutts_> shapr, no spokes at all!?
09:26:28 <dcoutts_> shapr, solid?
09:26:41 <mahogny> nibro, you have no clue what you are missing. I'm trying to get formaling proving into my own OSS projects :)
09:26:52 <Pawer> can it be used into a funtion definition like where?
09:26:55 <shapr> dcoutts_: Right, totally aerodynamic like those racing bikes in the olympics.
09:27:00 <araujo> Hi!
09:27:06 * araujo back from univ.
09:27:07 <nibro> mahogny: OSS?
09:27:14 <dcoutts_> shapr, heh, nice. I wonder how fast they can go.
09:27:14 <xerox> Open Source Software
09:27:15 <mahogny> nibro, open source
09:27:28 <nibro> ah, doh
09:27:30 <mahogny> ll
09:27:34 <mahogny> *lol
09:28:14 <Pawer> anyone has Richard Bird Book?
09:28:46 <dcoutts_> Pawer, yep
09:28:48 <sjanssen_> Pawer: yes, it's similar to where.  "f x = let y = 4.2 in x * y"
09:28:53 <shapr> dcoutts_: What's the largest tire made for the coker?
09:29:12 <dcoutts_> shapr, no idea. I've seen slick road tyres.
09:29:22 <Pawer> sjanssen_ thanks
09:29:28 <shapr> I guess 3.7" is right out?
09:29:34 <Pawer> in the book
09:29:45 <dcoutts_> shapr, why? too big/small?
09:29:47 <Pawer> in what chapter
09:29:54 <shapr> You'd need a monster rim.
09:29:57 <Pawer> is the language definition
09:29:59 <Pawer> ?
09:30:08 <shapr> How wide is the coker rim? My Large Marge is 65mm
09:30:20 <dcoutts_> shapr, ok (I just ride it I dunno the width)
09:30:25 <Pawer> use of where, let in, case of
09:31:35 <dcoutts_> hmm, Bulat's serialisation lib seems to be 10x faster than GHC's
09:32:53 <musasabi> and non-portable
09:33:02 <dcoutts_> GHC's is non-portable
09:33:10 <musasabi> that too? :-(
09:33:43 <musasabi> It would be nice to have 1) the fast serialization, 2) #ifdefs for the safe defaults, 3) not many external dependencies.
09:33:54 <musasabi> Bulat's code is the fastest around I think.
09:34:09 <musasabi> Certainly faster than my serialization code.
09:34:25 <Pawer> there is not
09:34:47 <Pawer> is a book that teaches functinal programming
09:34:56 <Pawer> with haskell
09:35:00 <Pawer> but not haskell
09:35:06 <Pawer> :(
09:35:36 <Pawer> ghc is written in haskell?
09:35:52 <araujo> yes
09:36:17 <Pawer> written in c would be faster?
09:36:28 <mahogny> does not have to be
09:36:43 <Pawer> why
09:36:58 <mahogny> ask yourself the same question. why would C be faster?
09:37:05 <Pawer> because
09:37:10 <Pawer> is low level
09:37:17 <shapr> low level does not mean faster.
09:37:30 <Pawer> you can makeperformance adjustements
09:37:31 <mahogny> haskell is also quite low level once it has gone through the compiler :)
09:37:41 <musasabi> low level means implementing kludgy and slow high level constructs instead of optimized ones.
09:37:56 <shapr> You can make performance adjustments with high level code also.
09:38:07 <mahogny> humans are bad at making performance adjustments. usually readability and maintainability comes before performance and then the point with using C is lost
09:38:08 <Pawer> ok that was  my question
09:38:26 <Pawer> humans are bad?
09:38:28 <shapr> I wrote a mailing list archive websearch in three evenings with Haskell.
09:38:33 <mahogny> in theory, C could be faster, but in practice not
09:38:36 <shapr> How long would it take you to do that in C?
09:38:37 <Pawer> making performance adjustements?
09:38:55 <Pawer> yes i know that
09:39:07 <mahogny> Pawer, they can beat the compiler, but the time it takes to do so isn't worth the money. hence it's not cost effective and that is all that matters
09:39:44 <Pawer> ok
09:39:45 <araujo> hah, i was reading a book about this a few days ago 
09:39:58 <shapr> Also, in the time that they take to beat the compiler, you could discover and implement a new optimization for Haskell and then all Haskell programs would be faster.
09:40:25 <araujo> When people thought that going from assembly to high level languages wouldn't be productive because of optimization concerns. 
09:40:28 <mahogny> there are of course cases when C still is more cost effective than haskell. but compilers is certainly not one of those areas
09:40:44 <mahogny> *not*
09:40:52 <Pawer> but felx and bison
09:40:56 <Pawer> work ok
09:40:57 <shapr> I still think it's more cost effective to write it first in Haskell, even if it will be rewritten in C.
09:40:58 <araujo> But definetly, optimization means more than just being able to run 0.0001 faster.
09:41:03 <Pawer> very fast
09:41:06 <mahogny> flex and bison are the worst tools I have ever used that deserve the name "tool"
09:41:07 <araujo> 0.0000001ms
09:41:08 <araujo> :-)
09:41:32 <Pawer> tell that to my teacher
09:41:34 <mahogny> shapr, or better yet, use FFI where it matters, and leave the rest
09:41:34 <shapr> Pawer: But, what about switching Flex and Bison to using a whole new way to do things?
09:41:34 <Pawer> XD
09:41:58 <araujo> They actually thought that if a Fortran program would run 2 times slower than its assembly version, the project would fail.
09:42:02 <shapr> For example, PackRat parsing has some advantages, but isn't commonly used.
09:42:11 <mahogny> Pawer, there are many stubborn people. they won't realize until it's clear that they are at a serious disadvantage in the competition using their favourite languages
09:42:20 <araujo> Pawer, tell your techaer to read a book 
09:42:29 <Pawer> ok
09:42:37 <Pawer> so haskell is better
09:42:47 <shapr> Pawer: Not for everything :-)
09:42:49 <Pawer> to make an interpreter
09:42:49 <mahogny> Pawer, not always. but many times
09:42:57 <Pawer> ok
09:43:08 <shapr> There is not any one thing that is best for every purpose.
09:43:29 <Pawer> combining C and haskell
09:43:33 <Pawer> ni programs
09:43:38 <dcoutts_> shapr, how about clever coders?
09:43:41 <mahogny> I might prefer C for an interpreter currently if I want JIT. haskell has a really lame API for binaries at the moment (but it will soon be solved). but for the simplest possible interpreter, haskell owns
09:44:03 <xerox> dcoutts_: what if you're making up an evil plan who aims to break code? (-:
09:44:14 <shapr> dcoutts_: Not even them.. sometimes 'worse is better' is the best approach, and clever coders are rarely good at that.
09:44:18 * araujo goes and fix his compiler project
09:44:25 <dcoutts_> shapr, true
09:44:48 <Pawer> breaking code is simpler in C
09:44:50 <Pawer> XDD
09:44:55 <shapr> I am often accused of being a prima donna because I try to be a clever coder.
09:44:57 <mahogny> C is broken by default
09:45:04 <araujo> Pawer, you spanish?
09:45:08 <Pawer> yes
09:45:17 <araujo> Pawer, Feel free to stop by #haskell.es if you want
09:45:22 <Pawer> tomorrow i have a haskell exam
09:45:22 <mahogny> shapr, it hurts to be smart
09:45:29 <Pawer> ok
09:45:32 <araujo> we've got a little nice group of spanish haskellers around there :-)
09:45:43 <Pawer> hashell
09:45:45 <Pawer> XD
09:46:02 <araujo> Pawer, yes, that too ;-)
09:46:07 <shapr> I know what you mean...http://www.scannedinavian.com/~shae/blog/2005-03-05.html
09:46:15 <Pawer> how is going the haskell shell?
09:46:34 <Pawer> i said to help but first i hae to learn more
09:46:46 <araujo> Pawer, pretty well, thought  abit stopped, i hope to get my hands on it after i finish some univ assigments :-/
09:47:11 <mahogny> shapr, heh. that site. you might as well have quoted me
09:47:17 <araujo> Pawer, im still looking after that clean, functional syntax :-)
09:47:27 <araujo> And help is always welcome!
09:47:49 <shapr> mahogny: The post from the day before is along the same lines.
09:48:10 * araujo needs to add some changes suggested by his prof. for the project now
09:48:21 <Pawer> faster approach would mean
09:48:21 <mahogny> shapr, we could go out and start to convert the world. start by rewriting gcc in haskell, and then without warning upload it to their cvs
09:48:45 <shapr> Or just write a better C compiler in Haskell.
09:48:59 <araujo> i'd like to see that :-)
09:49:18 <mahogny> also possible. but using parts of gcc and FFI, you can easily do drop-in module testing :)
09:49:18 <Pawer> code that is less centred in the program specification
09:49:29 * araujo will follow dcoutts's advice about a pascal compiler
09:49:44 <dcoutts_> araujo, good good :-)
09:49:51 <araujo> dcoutts_, :-)
09:50:01 <Pawer> start with the D compiler
09:50:24 <mahogny> D isn't a major improvement
09:50:33 <Pawer> yes i see
09:50:36 <mahogny> better go java 1.5 in that case
09:50:45 <Pawer> it does not have all C++
09:50:51 <mahogny> no, thank god
09:50:57 <Pawer> features
09:51:02 <mahogny> "features"
09:51:03 <mahogny> :)
09:51:06 <Pawer> XDD
09:51:07 <dcoutts_> compile time meta-languages are cool!
09:51:08 <Pawer> yes 
09:51:16 <wchogg> mahogny:  Not a fan of c++, eh?
09:51:27 <mahogny> wchogg, I live to fight that language
09:51:27 <Pawer> D sucks = does not work on my ppc machine
09:51:37 <dcoutts_> C++'s compile time meta-language is not cool
09:52:04 <xerox> Kinda remark.
09:52:06 <xerox> -a
09:52:06 <araujo> mahogny, haha
09:52:13 <araujo> mahogny, similar to me about java ;-)
09:52:17 <mahogny> araujo, :)
09:52:24 <Pawer> java sucks
09:52:32 <Pawer> i do not like java
09:52:38 <mahogny> araujo, hey, it's one of the best imperative languages right now. you shouldn't bash it until C++ is dead :)
09:52:48 <araujo> mahogny, haha
09:53:00 <Pawer> java is not free
09:53:06 <mahogny> gnu java?
09:53:08 <araujo> mahogny, The fact is, i don't know what java is :-)
09:53:20 <araujo> It's like the frankestein of the programming languages.
09:53:24 <mahogny> lol
09:53:38 <Pawer> gnu java would be good
09:53:44 <wchogg> Java *does* make doing alot of tasks easy.  You really just have to figure out what you want to do and then go searching through the api.
09:53:44 <Pawer> now java is a marriage
09:53:49 <ValarQ> araujo: aren't you thinking of PL/1 now?
09:54:06 <araujo> ValarQ, no no
09:54:06 <mahogny> Pawer, I usually use gnu java
09:54:16 <Philippa> mahogny: I'd far rather use haskell than java for imperative code. Or almost any of the ML languages
09:54:27 <Pawer> but that works like the other
09:54:34 <Pawer> like SUN or IBM
09:54:48 <mahogny> Philippa, easier to convince the industry to go java than haskell. always gotta start somewhere :)
09:54:59 <araujo> Just for a bit of fun http://www.sysprog.net/quotjava.html
09:55:04 <Pawer> haskell offers something different
09:55:07 <araujo> I like this one: 
09:55:08 <araujo> If Java had true garbage collection, most programs would delete themselves upon execution. (Robert Sewell)
09:55:18 <Pawer> why nobody has mode a C virtual machine?
09:55:22 <Pawer> made*
09:55:32 <Philippa> there'll be at least one floating around, but that's not the point really
09:55:43 <mahogny> araujo, sounds like my self-quote; "java is garbage collected" (yes, I didn't like it at first either)
09:55:45 <Philippa> I mean, there're x86 asm VMs around...
09:55:51 <araujo> mahogny, haha
09:56:44 <dcoutts_> or swap it round to get "java is collected garbage"
09:56:51 <Philippa> add a comma
09:56:54 <araujo> haha
09:56:55 <Philippa> "java is garbage, collected"
09:57:00 <araujo> hahaha
09:57:02 <mahogny> that's how to say it :)
09:57:09 * araujo admits he loves Philippa sense of humor
09:57:36 <Pawer> java visual basic
09:57:47 <Pawer> ...
09:57:56 <Pawer> is for work
09:57:58 * araujo admits he loves Philippa *sincerity*
09:58:47 <Pawer> to earn money not to make serious things XDD
10:03:44 <palomer> what's the function to subtract one list from another (as sets) ?
10:04:07 <palomer> @pl map fst
10:04:08 <lambdabot> map fst
10:04:18 <Pawer> make it
10:04:35 <palomer> why would I do a silly thing like that? it already exists
10:04:35 <Pawer> with zip
10:04:46 <palomer> I don't see how zip could help
10:05:03 <Pawer> it makes pairs
10:05:37 <palomer> I know what zip does
10:05:50 <Pawer> i know im silly
10:05:54 <Pawer> XD
10:06:18 <Pawer> ther is not a function reference?
10:06:51 <xerox> palomer: (\\).
10:07:03 <xerox> Or was it (//) ?
10:07:29 <xerox> ?docs Data.List
10:07:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
10:07:32 <dcoutts_> @type (..)
10:07:33 <lambdabot> parse error on input `..'
10:07:35 <dcoutts_> @type (//)
10:07:37 <lambdabot> forall e i. (Ix i) => Array i e -> [(i, e)] -> Array i e
10:07:45 <xerox> @type (\\)
10:07:46 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:07:52 <xerox> Right.
10:07:54 <dcoutts_> ah yes
10:07:59 <palomer> thx
10:08:23 <Pawer> http://haskell.org/ghc/docs/latest/html/libraries/
10:11:26 <nomeata> Hi. What does this error mean:
10:11:30 <nomeata>     Implicit parameters escape from the monomorphic top-level binding(s) of
10:11:30 <nomeata>     `setupSettings':
10:11:30 <nomeata>       ?windowXml::GladeXML arising from use of implicit parameter `?windowXml' at tutdb.hs:180:29-38
10:11:30 <nomeata>       ?gconf::GConf arising from use of `updateValues' at tutdb.hs:195:55-66
10:11:51 <nomeata> and why does it go away when I make the setupSetting function accept at least one parameter (even if only _)
10:12:01 <Pawer> is not a haskell error
10:12:34 <Pawer> you are not using the libray ok
10:13:22 <Pawer> the code?
10:14:14 <Pawer> when you wirte haskell code
10:14:36 <Pawer> you use type inference (talking to everybody)
10:15:37 <sjanssen_> Pawer: yes, we use type inference
10:16:09 <Pawer> ok
10:16:57 <nomeata> Pawer: was that a reply to my? I don't think the error is library related.
10:16:59 <nomeata> I guess I just need to find out what "monomorphic restriction" means
10:18:03 <Pawer> i think is related teo the type
10:18:08 <mnislaih> nomeata: are you sure you want to  use implicit parameters ?
10:18:17 <mnislaih> if not, just remove the '?' from the name of the symbol
10:19:09 <Pawer> lalala :: a -> Int
10:19:14 <mnislaih> and if you indeed wanted to use implicits, just give a type declaration for setupSettings
10:19:22 <Pawer> is a function that uses polimorphic types
10:20:12 <Pawer> maybe youare passing a type
10:20:29 <Pawer> that is different to the one inferred
10:20:46 <nomeata> mnislaih: I do, otherwise I'd be typing my fingers wound :-)
10:21:08 <nomeata> mnislaih: hmm, setupSettings uses several functions with implicit parameters. can't haskell do that for me?
10:21:08 <Pawer> use  explicit
10:21:14 <Pawer> to check the error
10:21:17 <Pawer> for now
10:21:24 <Pawer> in that function
10:21:36 <psi`> how many projects will haskell.org be able to accept for SOC?
10:22:04 <mnislaih> nomeata: I'm not sure, but I guess that Type inference can be restricted if you use them
10:22:07 <nomeata> using -fno-monomorphism-restriction, haskell tells me that the type is: setupSettings :: (?windowXml :: GladeXML, ?gconf :: GConf) => IO (ConnectId Entry)
10:22:12 <sjanssen_> psi`: I think it's a question of how many Google accepts, if I understand how it works
10:22:36 <nomeata> (i.e., -fno-monomorphism-restriction "fixes", but I'd like to unsterstand it)
10:22:45 <mnislaih> If google accepts around 400 and there are at least 40 organizations
10:22:54 <mnislaih> nomeata: look at the online report for the details
10:23:09 <psi`> sjanssen_: I figured google might've given them a number of slots
10:23:19 <nomeata> ok, I'll try to find that
10:23:32 <sjanssen_> the Haskell report won't help you if the problem is in the implicit parameters
10:23:39 <Pawer> maybe
10:23:52 <mnislaih> it's a restriction on type inference when using type classes, and implicit parameters must be implemented simulating type classes or something
10:23:56 <Pawer> the type inferred is polymorphic
10:23:59 <sjanssen_> the code that nomeata pasted doesn't look like the traditional monomorphism restriction to me
10:24:02 <mnislaih> must* like in might
10:24:18 <Pawer> and the subcall needs amonomorphic
10:24:18 <Pawer> type
10:24:25 <dcoutts_> nomeata, having trouble with the gtk2hs gconf binding?
10:24:40 <Pawer> a second function in the first
10:26:09 <nomeata> dcoutts: no, no, I'm just trying use make gconf and windowsXML "global" using implicit parameters
10:26:21 <dcoutts_> nomeata, I made the types slightly more complex than necessary, I've been meaning to change the gconf stuff.
10:26:26 <Pawer> question
10:26:28 <dcoutts_> nomeata, ah ok
10:26:31 <Pawer> i have a function like
10:26:54 <dcoutts_> nomeata, implicit parameters are not what they're cracked up to be (sadly)
10:26:57 * nomeata will just use -fno-monomorphism-restriction and stop worrying about the details
10:26:58 <xerox> @type join . return . map (map return)
10:26:59 <lambdabot> forall a (m :: * -> *).
10:26:59 <lambdabot>             (Monad m) =>
10:26:59 <lambdabot>             [[a]] -> [[m a]]
10:27:19 <Pawer> (Int -> a)
10:27:38 <Pawer> a function can have a polimorphic retun value?
10:27:45 <dcoutts_> yep
10:28:00 <Pawer> ok
10:28:00 <dcoutts_> though usually it'll depend on some input
10:28:09 <nomeata> dcoutts: works fine so far
10:28:16 <dcoutts_> @type read
10:28:17 <Pawer> pippo x
10:28:17 <lambdabot> forall a. (Read a) => String -> a
10:28:24 <xerox> Or constrained 'a'.
10:28:38 <dcoutts_> there's an example where the output type does not depend on any input type
10:28:57 <Pawer> pippo x = if x > 0 then 0 else "double" 
10:28:59 <Pawer> pippo x = if x > 0 then 0 else "double" 
10:29:10 <Pawer> this function has eerror type
10:29:13 <Cale_> @type id
10:29:14 <lambdabot> forall a. a -> a
10:29:19 <Pawer> why?
10:29:31 <dcoutts_> > \x -> if x > 0 then 0 else "double"
10:29:32 <lambdabot>  add an instance declaration for (Num [Char])
10:29:32 <lambdabot>   In a lambda abstraction: \ x -> if x > 0 then 0 else "double"
10:29:32 <lambdabot>   In the definition of `lgn': lgn = \ x -> if x > 0 then 0 else "double"
10:29:41 <dcoutts_> Int /= String
10:29:46 <Cale_> @type head
10:29:47 <lambdabot> forall a. [a] -> a
10:30:02 <Cale_> lots of functions have polymorphic return types
10:30:19 <Pawer> pippo x = if x > 0 then 0 else "double" 
10:30:21 <dcoutts_> @type \c t e -> if c then t else e
10:30:22 <Pawer> this function
10:30:23 <lambdabot> forall t. Bool -> t -> t -> t
10:30:28 <nomeata>  \x -> if x > 0 then 0::Int else "double"
10:30:33 <nomeata> > \x -> if x > 0 then 0::Int else "double"
10:30:34 <lambdabot> Couldn't match `Int' against `[Char]'
10:30:55 <Pawer> it should  have polymorphic
10:31:02 <Pawer> return value?
10:31:35 <Cale_> Pawer: The return type there would be something like  (exists a. a)
10:31:43 <Pawer> > \x -> if x > 0 then 0::Int else "double"::String
10:31:44 <lambdabot> Couldn't match `Int' against `String'
10:31:53 <Cale_> Pawer: type variables in Haskell are implicitly forall'd
10:32:05 <Pawer> > \x -> if x > 0 then 0::Int else "double"::Char
10:32:06 <lambdabot> Couldn't match `Char' against `[Char]'
10:32:18 <Pawer> > \x -> if x > 0 then 0::a else "double"::a
10:32:18 <lambdabot>  a
10:32:18 <lambdabot>   Inferred type: [Char]
10:32:18 <lambdabot>   In the expression: "double" :: a
10:32:27 <Cale_> The branches of an if expression must have the same type
10:32:42 <Pawer> ok!!
10:32:44 <Pawer> thanks
10:32:49 <Pawer> lol
10:32:54 <Cale_> @type \i t e -> if i then t else e
10:32:56 <lambdabot> forall t. Bool -> t -> t -> t
10:32:58 <sjanssen_> Pawer: the return type can be dependent on it's input types, but not the value of those inputs
10:33:09 <Pawer> it is the same for every conditional expresion?
10:33:22 <Cale_> yeah
10:33:35 <Cale_> basically, all the types are determined at compile time
10:33:36 <Pawer> ok
10:34:01 <Pawer> the example is with the bars and the otherwise
10:34:01 <xerox> @type \x -> if x > 0 then GHC.Exts.unsafeCoerce# "hehehe" else 12
10:34:02 <lambdabot> forall a
10:34:02 <lambdabot>                         t.
10:34:02 <lambdabot>                      (Ord a, Num a, Num t) =>
10:34:02 <lambdabot>                      a -> t
10:34:13 <sjanssen_> Pawer: if works like a function of type (Bool -> a -> a -> a) with special syntax
10:34:27 <Cale_> xerox: that's a little different :)
10:34:32 <Pawer> > \x -> if x > 0 then 0::a else "double"::a
10:34:32 * xerox grins
10:34:32 <lambdabot>  a
10:34:32 <lambdabot>   Inferred type: [Char]
10:34:32 <lambdabot>   In the expression: "double" :: a
10:34:57 <Igloo> The branches of the conditional still have the same type, though
10:35:31 <xerox> Yup.
10:35:33 <Pawer> i have to put to use a polimorphic type "a"
10:35:51 <Pawer> > \x -> if x > 0 then 0 else "double"
10:35:52 <lambdabot>  add an instance declaration for (Num [Char])
10:35:52 <lambdabot>   In a lambda abstraction: \ x -> if x > 0 then 0 else "double"
10:35:52 <lambdabot>   In the definition of `tnm': tnm = \ x -> if x > 0 then 0 else "double"
10:35:55 <Pawer> but now
10:36:00 <Pawer> without the a
10:36:11 <Pawer> dont have the same type and dont work
10:36:11 <Igloo> Pawer: What are you trying to do?
10:36:25 <Pawer> exam questions
10:36:28 <Pawer> 56
10:36:30 <Pawer> in total
10:36:45 <sjanssen_> Pawer: right, but you can't make "double" :: a, because "double" can only be a string, nothing else
10:36:45 <Igloo> What particular thing are you stuck on now, though?
10:36:55 <Pawer> so
10:37:00 <Pawer> the 0
10:37:16 <Pawer> > \x -> if x > 0 then 0::a else "double"::a
10:37:17 <lambdabot>  a
10:37:17 <lambdabot>   Inferred type: [Char]
10:37:17 <lambdabot>   In the expression: "double" :: a
10:37:23 <Pawer> i think it 
10:37:32 <Pawer> convert the 0 to String too
10:38:03 <palomer> gah! my system lacks principle types
10:38:04 <palomer> oh well
10:38:16 <Igloo> Pawer: "double" :: a isn't well typed:
10:38:21 <Igloo> > "double" :: a
10:38:22 <lambdabot>  a
10:38:22 <lambdabot>   Inferred type: [Char]
10:38:22 <lambdabot>   In the expression: "double" :: a
10:38:41 <Pawer> ok
10:38:46 <Igloo> That says 'You can use "double" with any type you want' which isn't true, as you can't use it as an Int for example
10:38:57 <Pawer> > \x -> if x > 0 then 0::String else "double"::String
10:38:58 <lambdabot>  add an instance declaration for (Num String)
10:38:58 <lambdabot>   In the expression: 0 :: String
10:38:58 <lambdabot>   In a lambda abstraction:
10:39:20 <Igloo> There you're hitting an oddity of Haskell
10:39:43 <Igloo> When you write 0 it's as if you wrote 'fromInteger 0'
10:39:47 <work_metaperl> @seen Cale
10:39:48 <lambdabot> Cale is in #haskell. I don't know when Cale last spoke.
10:39:51 <Igloo> This allows 0 to be used as an Int, Integer etc
10:39:54 <palomer> we want Cale!
10:39:55 <Pawer> > \x -> if x > 0 then 0::[Char] else "double"::[Char]
10:39:56 <lambdabot>  add an instance declaration for (Num [Char])
10:39:56 <lambdabot>   In the expression: 0 :: [Char]
10:39:56 <lambdabot>   In a lambda abstraction:
10:40:00 <Igloo> But it doesn't know how to use 0 as a String without you telling it
10:40:14 <Pawer> > \x -> if x > 0 then "0" else "double"
10:40:15 <lambdabot> Add a type signature
10:40:33 <xerox> hehe
10:40:40 <Pawer> > \x -> if x > 0 then "0"::[Char] else "double"::[Char]
10:40:41 <lambdabot> Add a type signature
10:40:47 <Pawer> and now?
10:40:50 <Pawer> lol
10:40:58 <sjanssen_> Pawer: this is the monomorphism restriction
10:40:59 <Igloo> That is well-typed, but it doesn't know how to show something with a function type
10:41:02 <nomeata> > \x -> if x > 0 then (show 0) else "double"
10:41:04 <lambdabot> Add a type signature
10:41:04 <nomeata> > (\x -> if x > 0 then (show 0) else "double") 0
10:41:06 <lambdabot> "double"
10:41:06 <nomeata> > (\x -> if x > 0 then (show 0) else "double") 1
10:41:08 <lambdabot> "0"
10:41:10 <nomeata> @ (\x -> if x > 0 then (show 0) else "double") 1
10:41:12 <nomeata> @type (\x -> if x > 0 then (show 0) else "double") 
10:41:13 <Igloo> sjanssen_: No it's not
10:41:14 <lambdabot> forall a.
10:41:14 <lambdabot>                 (Ord a, Num a) =>
10:41:14 <lambdabot>                 a -> String
10:41:20 <nomeata> @type (\x -> if x > 0 then (show 0::Int) else "double") 
10:41:22 <lambdabot>   Couldn't match `Int' against `String'
10:41:22 <lambdabot>   Expected type: Int
10:41:22 <nomeata> > (\x -> if x > 0 then (show 0::Int) else "double") 
10:41:24 <lambdabot> Couldn't match `Int' against `String'
10:41:25 <sjanssen_> oh, what happened to the function showing code?
10:41:41 <sjanssen_> > head :: [Char] -> Char
10:41:42 <lambdabot> <[Char] -> Char>
10:41:46 <Pawer> lshow double
10:41:57 <Pawer> show "0"?
10:41:59 <xerox> sjanssen: type variables has to be typeable.
10:42:01 <sjanssen_> oh yes, can't show polymorphic type vars
10:42:36 * palomer is thinking of learning about mercury
10:43:12 <Pawer> > ( \x -> if x > 0 then "0" else "double")  1
10:43:13 <lambdabot> "0"
10:43:19 <Pawer> > ( \x -> if x > 0 then "0" else "double")  -1
10:43:20 <lambdabot>  add an instance declaration for (Num (a -> [Char]))
10:43:28 <Pawer> > ( \x -> if x > 0 then "0" else "double")  0
10:43:30 <lambdabot> "double"
10:43:41 <xerox> Enclose (-1) in parens.
10:43:41 <palomer> you know you can message lambdabot privately, eh?
10:43:56 <nomeata> > (\x -> if x > 0 then (show 0::Int) else "double") 0
10:43:57 <lambdabot> Couldn't match `Int' against `String'
10:43:58 <Pawer> is for sjassen
10:44:13 <mauke> nomeata: dude, show doesn't return an int
10:44:22 <nomeata> > (\x -> if x > 0 then (show (0::Int)) else "double") 0
10:44:24 <lambdabot> "double"
10:44:35 <Pawer> > ( \x -> if x > 0 then 1 else 0) 0
10:44:36 <lambdabot> 0
10:44:40 <Pawer> > ( \x -> if x > 0 then 1 else 0) 1
10:44:41 <lambdabot> 1
10:44:43 <Pawer> > ( \x -> if x > 0 then 1 else 0) 40
10:44:44 <lambdabot> 1
10:44:47 <nomeata> Pawer: is my last one what you needed?
10:44:58 <xerox> Pawer: consider using lambdabot by /QUERY lambdabot 
10:45:09 <xerox> http://hackage.haskell.org/trac/summer-of-code/ticket/55
10:45:15 <xerox> Uhm.  New one.
10:47:57 <sjanssen_> is it bad to use type classes with a huge number of functions in them?
10:48:10 <xerox> I don't think so.
10:48:22 <sjanssen_> no performance problems?
10:48:39 <sjanssen_> I wouldn't think so, but I'm just not sure
10:49:24 <palomer> here's an interesting problem, given a type tau and a substitution theta, find all sigmas such that theta(sigma)=tau
10:49:44 <palomer> actually, that's not a hard problem either
10:50:06 <palomer> quite simple
10:50:25 <Cale_> sjanssen_: I wouldn't think so either -- the usual dictionary passing translation wraps the functions up into a data structure and passes that (as a pointer), so I doubt it costs a significant amount more time to have a large dictionary, especially as the dictionary isn't changing at runtime.
10:52:20 <Cale_> whether it's a major design concern is another thing -- the more functions in your class, the harder it will be to write instances of that class, but that might not be an issue, and default methods might alleviate that somewhat.
10:53:21 <sjanssen_> Cale_: I'm wondering whether the PackedString modules showing up should just be shoved into a class
10:54:15 <Cale_> almost certainly
11:00:46 <palomer> hrmph, looks like I'm going to have to apply ListT
11:00:52 * palomer sighs
11:01:05 <palomer> is ListT the transformer one would use for nondeterministic computation?
11:01:37 <waern> xerox, when you did your SoC project, did you have any other work? Or was that your only income during the summer
11:03:05 <Pawer> why you need 
11:03:10 <Pawer> a lot of functions?
11:03:11 <Philippa_> palomer: it's one you might use, yes
11:03:31 <Pawer> moybe you have a lot that you use by default
11:03:41 <Cale_> palomer: I recommend the corrected version on the wiki over the one in the libraries
11:03:43 <palomer> is it the typical one to use?
11:03:54 <palomer> there's a bug in the libraries?
11:04:01 <Philippa_> Pawer: that's not what List's about, you use it when there're multiple values to apply the same functions to
11:04:08 <Cale_> yeah, it sometimes doesn't give you a monad
11:04:30 <Philippa_> which law does it potentially break?
11:04:35 <Pawer> was answering to sjassen
11:05:16 <mauke> @type flip liftM
11:05:17 <lambdabot> forall a1 r (m :: * -> *).
11:05:17 <lambdabot>      (Monad m) =>
11:05:17 <lambdabot>      m a1 -> (a1 -> r) -> m r
11:05:31 <Pawer> type variables
11:05:32 <Cale_> I can't remember the details, let me look...
11:05:36 <Pawer> are matched too?
11:05:43 <sjanssen_> Pawer: String is declared as [Char] in Haskell.  There's been a proposal to use a more efficient array based structure for strings.  I'd like one interface that works for both
11:05:49 <sjanssen_> tjere
11:06:07 <Cale_> ah, associativity
11:06:07 <sjanssen_> there's lots of things you can do to strings, so the class could be large, potentially
11:06:15 <palomer> Cale_: have you submitted a bug report?
11:06:20 <Cale_> it fails associativity when applied to any noncommutative monad
11:06:37 <Pawer> like "more efficient" is faster?
11:06:43 <Pawer> "more efficient" is faster?
11:07:21 <sjanssen_> Pawer: yes, and less memory use
11:07:43 <Cale_> palomer: it was mentioned on the mailing lists
11:08:19 <Pawer> so why not use it for [Char] also?
11:08:30 <Pawer> and replace the old for both
11:08:30 <mnislaih> xerox: please stop adding SoC tickets? it's impossible to pick just one already
11:08:52 <palomer> Cale: so it's not operationally equivalent?
11:09:00 <Cale_> http://haskell.cs.yale.edu/hawiki/ListTDoneRight
11:09:11 <Cale_> Right, it's different.
11:09:27 <mnislaih> to be completely unconsequent with myself, I'll just give a new SoC project idea: embedding Hoogle as a Google Desktop plugin, to use hoogle on your whole codebase
11:09:35 <palomer> what's the the easiest way to take the cross product of a bunch of lists?
11:10:11 <mnislaih> who is an expert or can help mentoring, in Haskell + COM, HDirect, and IDL?
11:10:12 <mauke> foldr (Monad.liftM2 (:)) [[]]
11:10:27 <palomer> @type foldr (Monad.liftM2 (:)) [[]]
11:10:28 <lambdabot> forall a. [[a]] -> [[a]]
11:10:39 <Cale_> > sequence [[1,2,3],[4,5],[6,7,8]]
11:10:40 <lambdabot> [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,5,6],[2,5,7],[2,5,8],[3,4,6],[3,4,7],[3,4,8],[3,5,6],[3,5,7],[3,5,8]]
11:10:41 <palomer> that takes the cross product?
11:10:49 <Cale_> sequence
11:11:01 <Cale_> or if you just want 2 lists,
11:11:10 <Cale_> > liftM2 (,) [1,2,3] [4,5,6]
11:11:11 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:12:27 <work_metaperl> Gentle Intro states: "A monad is constructed on top of a polymorphic type such as IO. " --- the state monad is constructed on the polymorphic type (\s0 -> (a,s1)) ... correct?
11:12:56 <Cale_> That's an awkward way to say that a monad is a type constructor
11:13:08 <palomer> that's really awkward
11:13:27 <Cale_> There are actually many state monads, (State s), for any type s, is a monad
11:13:36 <mauke> dammit, why didn't I notice that my function is equivalent to sequence?
11:14:37 <palomer> well, now I have a type that takes two thirds of my screen
11:14:43 <Cale_> heh
11:14:47 * palomer can't wait until his types are a screenful
11:14:48 <Pawer> you know what is a monad?
11:15:02 <Cale_> Pawer: hm? sure.
11:15:09 <Pawer> ok
11:15:14 <palomer> http://www.rafb.net/paste/results/2ys7xQ54.html <--here's the type, if anyone is interested
11:15:22 <xerox> waern: yes, that's all, check the timeline on the Student FAQ
11:15:34 <dcoutts_> palomer, mm, nice
11:15:35 <Cale_> palomer: wow.
11:15:37 <xerox> mnislaih: hehe, no worries, I'm going to refactor this night
11:15:41 <Pawer> mauke XDD
11:15:53 <xerox> o_O
11:16:12 <xerox> waern: wha's your project?
11:19:06 <palomer> and I can assure you that I didn't do it on purpose
11:19:07 <Cale_> work_metaperl: did you see my replies to your blog entries?
11:19:22 <waern> waern, I'm thinking about applying for the Port Haddock to use GHC project
11:19:28 <waern> err, xerox
11:19:30 <waern> :)
11:19:42 <xerox> waern: nice one.
11:19:47 <waern> xerox, the problem is that I'm working the entire summer.. I'm not sure I could handle that work load
11:20:11 <waern> the second problem is that I've already started on this project (before hearing about the SoC proposal)
11:20:19 <waern> :)
11:20:24 * araujo back from lunch
11:20:32 <xerox> waern: it is okay I think.
11:22:03 <mnislaih> waern: I friend of mine did a Gaim SoC project and at the same time, kept with his 40 week hour work in a software consultant comany
11:22:13 <waern> xerox, how many hours per day did you put into your project?
11:22:27 <xerox> Every :-P
11:22:29 <waern> mnislaih, did he have any freetime? :)
11:22:37 <cmarcelo> xerox: which project did you do ?
11:22:41 <mnislaih> heh
11:22:50 <mnislaih> but it was worth it I'm sure
11:22:59 <xerox> cmarcelo: I wrote the Cairo bindings (and integrated them in Gtk2Hs, it's a multi-backend vector graphics library)
11:23:17 <mnislaih> waern : Too bad to hear that you have already started with that Haddock project. I had already started.... writing an email to smarlow :S
11:23:21 <xerox> waern: I had to because I took a month of vacations when I only read papers and designed.
11:23:35 <xerox> waern: also, we had two months, not three.
11:24:05 <xerox> Possibly people can work on "same" projects, if it means non-overlapping code
11:24:14 <xerox> But it's something to clearify and non-usual
11:24:33 <mnislaih> xerox: that won't be necessary anyway , there are other dozen projects I find interesting
11:24:46 <mnislaih> probably more
11:24:52 <xerox> Right.  Apply for the ones you like much, and of course *propose your own ideas* ! :-)
11:25:06 <mnislaih> I did. Embedding Hoogle as a Google Desktop plugin :P
11:25:25 <mnislaih> But I need to find a mentor. I tried compiling the Google Desktop IDL the other day with HDIrect and failed
11:26:06 <waern> mnislaih, ehm.. what? how far are you? I started 1 week ago, still hacking on the lexer
11:26:27 <mnislaih> waern: I only started writing an email..
11:26:32 <waern> aha
11:26:52 <mnislaih> I started doing something similar for DriFT
11:27:12 <waern> I thought you were going to send an email now because of this ;)
11:27:24 * xerox is so happy to see other students doing Haskell wooo :-D
11:27:39 <mnislaih> waern: how are you doing with ghc-api ?
11:27:46 <mnislaih> did you find any documentation ?
11:28:08 <mnislaih> I managed to haddock compile the source, but that was painful and the result was poor
11:28:23 <waern> mnislaih, well.. there's no real documentation afaik
11:28:39 <waern> mnislaih, since i've only hacked on the GHC parser so far I haven't needed that much docs
11:29:34 <mnislaih> are you going to extend GHC parser ?
11:29:45 <waern> yep
11:29:57 <mnislaih> is there any way to extract the comments from a source file and parse them with the old Haddock parser ?
11:30:41 <mnislaih> hmm that wouldnt work so well
11:30:58 <waern> mnislaih, you need a full haskell parser
11:31:26 <waern> however, the parser for Haddock-comment's only can probably be reused
11:31:43 <mnislaih> yay, that's what I meant
11:32:09 <mnislaih> anyway, time to leave. Bar√ßa-Milan is starting in 15 min. don't miss Ronaldinho & cia pwning the italians !!
11:37:20 <palomer> http://www.rafb.net/paste/results/LR2MqO37.html <--gah!
11:38:21 <mahogny> palomer, you have given the function a list type?
11:38:27 <mahogny> ehr
11:38:33 <mahogny> hhhhm
11:39:02 <xerox> palomer: isn't theta' the list?
11:39:12 <xerox> Ah, no O_o
11:39:50 <sjanssen_> palomer: are you accidentally in the list monad?
11:40:12 * shapr hides in the list monad.
11:40:24 <palomer> well, my function is annotated in such a way that I'm sure I'm not in the list monad
11:40:39 <palomer> this is the return type: STI b s (Substitution (Tyref s), (String, MonoType (Tyref s)))
11:40:42 * sjanssen_ non-deterministacally searches for shapr
11:41:01 <shapr> Speaking of non-determinism, have you seen John Conway's recent paper about Free Will?
11:41:28 <sjanssen_> nope
11:41:32 <palomer> woops, typo, this is what it should be STI b s (Substitution (Tyref s), (String, [MonoType (Tyref s)]))
11:41:42 <SyntaxNinja> y0
11:41:52 <sjanssen_> shapr: game of life Conway, right?
11:42:08 <shapr> Yeah, here's a description - http://www.cs.auckland.ac.nz/~jas/one/freewill-theorem.html
11:42:12 <shapr> He's actually published the paper now.
11:43:39 <shapr> I was tempted to post it to LtU, but I couldn't figure out how it relates to CS.
11:44:18 <palomer> does his paper state that free will is caused by the random quantum effects in our brains?
11:44:27 <palomer> that's what he argued last time we spoke
11:44:57 <shapr> That sounds like the carbon nanotubules theory... wasn't that Penrose?
11:44:58 <araujo> bah, we all know free will is just an illusion
11:45:00 <Philippa_> "free will is an RNG" really doesn't convince me
11:45:07 <palomer> RNG?
11:45:11 <mahogny> lol
11:45:14 <Philippa_> Random Number Generator
11:45:24 <araujo> SyntaxNinja, y00
11:45:34 <Philippa_> free will is having agency within the greater system you inhabit, or it's nothing at all
11:45:47 <SyntaxNinja> hiya araujo
11:45:53 <Philippa_> old news for most philosophers, randomness isn't interesting
11:47:29 <Pawer> now
11:47:59 <araujo> God is the monad of monads.
11:48:11 <Pawer> close operation
11:49:01 <Pawer> ramdom 
11:49:02 <ValarQ> araujo: metamonad?
11:49:20 <Pawer> is really something random?
11:49:25 <araujo> ValarQ, No, the One True monad
11:49:43 <ValarQ> rootmonad?
11:49:57 <Pawer> unuseful nomad?
11:50:05 <araujo> No!, The Monad of monads!
11:50:14 <Pawer> like god it exists
11:50:16 <araujo> The Alpha and Omega!
11:50:46 <Pawer> but o use
11:50:49 <Pawer> no use
11:50:51 <Pawer> XD
11:51:36 <araujo> We shuold add "To prove the (non)existence of God with monadic computation" to the SoC tasks
11:51:52 <Pawer> XD
11:52:10 <Pawer> freak
11:52:33 <Philippa_> araujo: alternatively, use monads to prove that if you transfer your consciousness to a computer, /you/ die
11:52:43 <Philippa_> (values of transfer assumed not to be copying)
11:52:59 <monochrom> you die, but the computer lives!
11:53:05 <araujo> I mean, it isn't like i would be the first one trying to prove that right?
11:53:22 <Pawer> computer hangs
11:53:33 <Philippa_> araujo: there're some plenty good proofs that eg there's no omniscient, omnipotent and benevolent god
11:53:48 <Pawer> you die and die
11:53:54 <araujo> Philippa_, i know.. but i meant, using monadic computation to prove it
11:54:09 <Pawer> when you are inside
11:54:16 <sjanssen_> Philippa_: how can you actually prove that?
11:54:19 <araujo> mmm....
11:54:19 <Pawer> you see that you fogot many tools
11:54:21 <Pawer> XD
11:54:31 <Pawer> forgot*
11:54:41 <monochrom> By defining "benevolent" according to our selfish perspective.
11:54:53 <araujo> sjanssen, There are some paradox (well spelled?) that helps you to reason or kind of prove that
11:54:55 <Philippa_> sjanssen: trivial. An omnipotent, omniscient and benevolent god wouldn't allow the birth of humans whose disabilities mean they're doomed to a miserable existance
11:55:05 <Philippa_> and believe me that happens all the damn time
11:55:20 <monochrom> Like I said.
11:55:23 <Pawer> you are free
11:55:26 <Pawer> to do things
11:55:28 <araujo> I like the paradox of the big rock.
11:55:31 <sjanssen_> Philippa_: you can just throw the "higher purpose" argument at that one
11:55:34 <Pawer> like god
11:55:46 <Philippa_> sjanssen: that suggests a higher purpose that's less than benevolent, too
11:55:47 <mahogny> omg. how did religion enter here? :O
11:55:50 <Pawer> im lost
11:56:00 <Pawer> good is free
11:56:06 <Pawer> why good
11:56:15 <xerox> araujo, waern - ping
11:56:18 <Pawer> is always good
11:56:24 <Pawer> God
11:56:37 <Pawer> if god is free why it is always good
11:56:41 <sjanssen_> Philippa_: the benevolence transcends our understanding of it?
11:56:47 <araujo> If God is omnipotent, can He create a bick rock that he can lift?
11:56:51 <araujo> xerox, pong!
11:56:54 <monochrom> See, it's all about abusing "benevolence".
11:56:57 <Philippa_> sjanssen: it fails to be benevolent towards the group of people I described
11:57:00 <SyntaxNinja> oh my. you guys need to take it to #haskell-overflow
11:57:03 <araujo> I mean, can't lift*
11:57:07 <Philippa_> SyntaxNinja: -blah, I think
11:57:13 <SyntaxNinja> I'm not sure the difference
11:57:15 <xerox> araujo: do you remember the other students nicks?  I have to tell 'em all to add theirself here http://hackage.haskell.org/trac/summer-of-code/wiki/People
11:57:31 <Philippa_> SyntaxNinja: -overflow's literally "more #haskell", -blah's off-topic
11:57:34 <mahogny> how about a simpler one? Assume god exists. then considering the world, god must be evil. but the bible says he is good. contradiction
11:57:53 <Philippa_> mahogny: that's not simpler, your "considering the world" misses out steps
11:57:54 <araujo> xerox, ooh, goodie, thanks, let me see
11:58:10 <mahogny> Philippa_, "obvious steps left to the reader"
11:58:19 <araujo> xerox, i remenber one, i will ping him
11:58:20 <Philippa_> except they turn out to be non-obvious
11:58:36 <mahogny> Philippa_, now you are being nit-picky :)
11:58:44 <araujo> xerox, so we should add ourselves there right?
11:58:55 <Philippa_> you're the one who was silly enough to say it was a proof, you should expect nits picked :-)
11:59:02 <xerox> araujo: right, along with mail and interested projects
11:59:04 <mahogny> Philippa_, baaah :)
11:59:08 <waern> xerox, pong
11:59:20 <araujo> xerox, good, i'll spread the word
12:02:15 <sjanssen_> xerox: so people who want to do SoC add their names to that page?
12:02:45 <xerox> sjanssen_: right, students, sign up there with interested projects.
12:03:00 <xerox> I've mailed some, hmmm.
12:03:12 <palomer> is there a function m [a] -> listT m a ?
12:03:31 <xerox> lift
12:03:34 <sjanssen_> I need a login?
12:03:53 <palomer> lift is m a -> listT m a
12:04:01 <palomer> but I found it
12:04:07 <xerox> What is it palomer?
12:04:35 <xerox> waern: add your interested project(s) too
12:04:38 * xerox <- dinner
12:04:41 <palomer> @hoogle ListT
12:04:42 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
12:04:42 <lambdabot> Control.Monad.List.ListT :: newtype ListT m a
12:04:42 <lambdabot> Language.Haskell.TH.ListT :: Type
12:04:49 <palomer> it's the constructor:O)
12:04:58 <xerox> :-)
12:05:02 <xerox> bbl
12:05:22 <waern> xerox, yep :)
12:05:38 <palomer> @hoogle lift
12:05:39 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
12:05:39 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
12:05:39 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
12:09:33 <Pawer> what is the google summer of code?
12:10:04 <pesco> Pawer: See http://code.google.com/soc/
12:13:46 <Pawer> Google employees, interns, contractors, family members, or citizens of Iran, Cuba, Sudan, North Korea and Myanmar (Burma), with whom we are prohibited by U.S. law from engaging in commerce, are ineligible to participate.
12:13:51 <Pawer> sucks
12:14:11 <shapr> Are you a citizen of Iran?
12:14:45 <Pawer> no
12:14:48 <Pawer> but ...
12:15:41 <Pawer> no prob
12:15:52 <Pawer> world sucks
12:17:18 <araujo> dons, oh, now a remenber, you don't have any hmp3 interesting hacking around to add? :-)
12:19:53 <Pawer> what does the @ when working with lists?
12:20:24 <mauke> list concatenation (in OCaml) :-)
12:20:38 <Pawer> noj, in haskell
12:20:51 <Pawer> :)
12:21:07 <mauke> like list@(x : xs)?
12:21:16 <Pawer> like
12:21:39 <Pawer> dropWhile p xs@(x:xs')
12:21:55 <Pawer> yes
12:22:02 <Pawer> is a function
12:22:06 <Pawer> parameter
12:22:12 <mauke> yeah, that creates multiple variables from the same value
12:22:27 <mauke> xs is bound to (x:xs')
12:22:43 <Pawer> so
12:23:05 <Pawer> well
12:23:14 <mauke>  Patterns of the form var@pat are called as-patterns, and allow one to use var as a name for the value being matched by pat. 
12:23:38 <Pawer> so
12:23:43 <Pawer> xs is the entire list
12:23:55 <Pawer> and xs' is the tail
12:23:58 <Pawer> of the list
12:24:10 <Pawer> x is the fisrt element
12:24:24 <sjanssen_> Pawer: exactly
12:24:24 <Pawer> in: xs@(x:xs')
12:24:28 <Pawer> thanks
12:25:45 <liyang> Hm. Hope people don't mind I pick their brains a bit.
12:26:21 <palomer> is there a function [a] -> ListT m a ?
12:26:58 * palomer might be confused as to how best to use ListT
12:27:20 <Pawer> what means [a] -> ListT m a
12:27:26 <Pawer>  ListT m a is a type
12:27:27 <Pawer> ?
12:27:39 <sjanssen_> @hoogle [a] -> ListT m a
12:27:39 <lambdabot> No matches, try a more general search
12:28:04 <monochrom> ghci is my favourite desktop calculator
12:28:13 <palomer> I use irb
12:28:16 <Pawer> ^^
12:28:21 <liyang> Tim Sheard was talking about Omega, and he mentioned he has this facility where you place a keyword anywhere in your program (like Debug.Trace.trace) such that the top-level would stop whatever it's doing and let you examine the types of everything visible *at that point*.
12:28:30 <monochrom> after I finish grading an exam I add up the marks with ghci
12:28:41 <monochrom> sum [ 9,7,4,17 ]
12:28:50 <liyang> Is there something like this for hugs or GHCi? :-/
12:29:08 <shapr> Sounds like type slicing.
12:29:08 <liyang> If not... does someone want to implement it? (Google SoC? :)
12:29:13 <Pawer> > sum  [ 9,7,4,17 ]
12:29:14 <lambdabot> 37
12:29:16 <monochrom> Hey! I don't have to run ghci and use up my own memory!  I can use lambdabot!
12:29:17 <Pawer> yes
12:29:27 <Pawer> ...
12:29:56 <yaarg> @hoogle lift
12:29:57 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
12:29:57 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
12:29:57 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
12:30:12 <liyang> shapr: any further clues?
12:30:32 <sjanssen_> monochrom: I also use ghci as a calculator
12:30:41 <Pawer> is in the prelude
12:30:42 <sjanssen_> it's glorious
12:30:54 <liyang> It'd be rather useful when debugging those functions that just won't typecheck...
12:31:05 <Pawer> > sin 90
12:31:06 <lambdabot> 0.8939966636005579
12:32:25 <shapr> liyang: http://www.cee.hw.ac.uk/ultra/compositional-analysis/type-error-slicing/slicing.cgi
12:32:56 <monochrom> http://www.cs.utoronto.ca/~trebla/calculator.lhs  has extra functions
12:33:47 <liyang> shapr: nice. :)
12:33:57 <Pawer> a god irc client for kde?
12:34:09 <Pawer> (off-)toppic
12:34:14 <Pawer> (off-toppic)
12:34:53 <palomer> hrmphrmhprm
12:35:03 <palomer> there must be a function [a] -> ListT m a
12:35:26 <palomer> where else would the non determinism appear?
12:36:07 <petekaz> Newbie question: I'm trying to learn about monads.  In this piece of code, is there some way of using Maybe's bind to get rid of the 'case' expression?
12:36:10 <lisppaste2> petekaz pasted "How do I get rid of the 'case'?" at http://paste.lisp.org/display/19397
12:36:20 <norpan> palomer: ListT
12:36:28 <palomer> @hoogle ListT
12:36:29 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
12:36:29 <lambdabot> Control.Monad.List.ListT :: newtype ListT m a
12:36:29 <lambdabot> Language.Haskell.TH.ListT :: Type
12:36:31 <palomer> not quite
12:36:51 <norpan> ListT . return
12:37:34 <palomer> @type Control.Monad.List.ListT . return
12:37:36 <lambdabot> forall a (m :: * -> *).
12:37:36 <lambdabot>              (Monad m) =>
12:37:36 <lambdabot>              [a] -> Control.Monad.List.ListT m a
12:37:41 <palomer> oh, you're right
12:40:54 <palomer> ok, I'm going to bust a nut
12:41:12 <palomer> whattype(foo) would be a _great_ compiler output mechanism
12:44:11 <mahogny> ehr. that sounds very java. what would you use it for?
12:44:29 <sjanssen_> palomer: do you mean like typeOf
12:44:32 <sjanssen_> > typeOf 'x'
12:44:33 <lambdabot> Char
12:44:42 <mahogny> or :t in ghci?
12:44:45 <Pawer> > typeOf x
12:44:46 <lambdabot>  Not in scope: `x'
12:44:50 <sjanssen_> palomer: it will only work for monomorphic types though
12:44:58 <Pawer> > :t '1'
12:44:58 <lambdabot>  parse error on input `:'
12:45:20 <palomer> > \x -> (typeOf x)
12:45:21 <lambdabot> Add a type signature
12:45:26 <palomer> @hoogle typeOf
12:45:27 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
12:45:27 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
12:45:27 <lambdabot> Data.Typeable.typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
12:45:45 <Pawer> > (\x -> typeOf x) '1'
12:45:45 <norpan> typeOf (x::a)
12:45:46 <lambdabot> Char
12:45:50 <Pawer> > (\x -> typeOf x) '1'
12:45:51 <norpan> > typeOf (x::a)
12:45:51 <lambdabot> Char
12:45:52 <lambdabot>  Not in scope: `x'
12:46:03 <palomer> hrmph
12:46:05 <norpan> > typeOf (\x->x::a->a)
12:46:06 <lambdabot>  x :: a -> a
12:46:06 <lambdabot>   In a lambda abstraction: \ x -> x :: a -> a
12:46:08 <palomer> why doesn't it work with polymorphic types?
12:46:10 <Pawer> > typeOf X::a
12:46:11 <lambdabot>  Not in scope: data constructor `X'
12:46:16 <Pawer> > typeOf x::Int
12:46:17 <lambdabot>  Not in scope: `x'
12:46:24 <norpan> > typeOf 1
12:46:25 <lambdabot> Add a type signature
12:46:27 <Pawer> > typeOf 8::Float
12:46:28 <lambdabot> Couldn't match `Float' against `TypeRep'
12:46:31 <Pawer> > typeOf 8
12:46:32 <lambdabot> Add a type signature
12:46:39 <sjanssen_> palomer: because it's implemented purely with typeclasses, and those can't get the necessary information
12:46:51 <palomer> needs compiler support, eh?
12:46:59 <palomer> (or maybe we could do this with GADTs, hmmmm)
12:47:17 <sjanssen_> palomer: maybe TH can do it
12:48:10 <palomer> I was thinking about a mechanism that would output things during compilation
12:48:13 <palomer> so you don't have to run'em
12:48:29 <palomer> they'd be run once a file has been compiled (or a module)
12:50:05 <palomer> gragargph
12:50:20 <palomer> turns out that the ListT implementation on the wiki is very different
12:50:40 <palomer> ok, how can I use ListT without using the ListT constructor directly?
12:51:49 <palomer> nevermind
12:52:07 <sjanssen_> @type msum . map return
12:52:08 <lambdabot> forall a (m :: * -> *).
12:52:08 <lambdabot>        (MonadPlus m) =>
12:52:08 <lambdabot>        [a] -> m a
12:52:46 <norpan> @type runListT
12:52:47 <lambdabot> Not in scope: `runListT'
12:52:56 <norpan> @type Control.Monad.List.runListT
12:52:57 <lambdabot> forall a (m :: * -> *).
12:52:57 <lambdabot>            Control.Monad.List.ListT m a -> m [a]
12:54:07 <norpan> palomer: return and mplus?
12:55:15 <palomer> hrmph, this is the wiki's ListT
12:55:18 <palomer> which is quite different
12:55:27 <Cale_> palomer: it's still an instance of MonadPlus
12:55:59 <Cale_> msum . map return is quite useful
12:56:03 <Cale_> I call it option
12:56:16 <xerox> Mumble.
12:56:27 <Cale_> yes :)
12:56:52 <xerox> Interested students sign up <http://hackage.haskell.org/trac/summer-of-code/wiki/People>
12:56:58 <Cale_> liftList is what the ListT library on the wiki calls its specialised version of option
12:57:46 <palomer> Cale_: how do I use the wiki's ListT? runListT doesn't have the right type
12:57:51 <palomer> newtype ListT m a = ListT { runListT :: MList m a }
12:57:59 <palomer> so I get an MList m a instead of an m [a]
12:58:10 <mahogny> xerox, should I tell mine to add himself or will you broadcast this somehow?
12:58:30 <xerox> mahogny: I mailed him, but feel free to tell everybody
12:58:41 <mahogny> xerox, ok
12:59:26 <Cale_> palomer: runListT' is one way to do it
12:59:52 <Cale_> palomer: Or just run the (MList m a) that you get (it's an m-action)
13:00:15 * mahogny likes how there are more mentors than students :P
13:00:20 <palomer> how do I turn it into an m [a] ?
13:00:47 <xerox> mahogny: so far!
13:00:55 <mahogny> xerox, I hope it changes :)
13:00:56 <xerox> mahogny: I mailed some, I'm searching for more now
13:01:43 <Cale_> palomer: I'll write it :)
13:03:41 <palomer> :)
13:03:44 <xerox> ?docs Data.HaskTable
13:03:44 <lambdabot> Data.HaskTable not available
13:03:47 <xerox> ?docs Data.HashTable
13:03:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
13:05:56 <Cale_> runListTFull m = do x <- runListT m; case x of MNil -> return []; MCons v n -> fmap (v:) (runListTFull n)
13:06:20 <Cale_> I think that ought to do it -- I haven't even tried compiling it though :)
13:06:25 <xerox> Cale_: are there other possibilities than HashTable, to have that kind of datastructure without messing with IO?
13:06:56 <palomer>     Occurs check: cannot construct the infinite type: f = ListT f
13:07:17 <palomer> http://www.rafb.net/paste/results/IV5qIS67.html
13:07:20 <Cale_> xerox: Set?
13:07:26 <Cale_> or Map?
13:07:42 <xerox> petekaz: listen to Cale
13:07:49 <Cale_> It's Map
13:08:02 <petekaz> Cale_: I'm reading your tutorial and I was just playing around with some monad examples.  I wanted to see if I could get a HashTable working.  In this snippet of code: http://paste.lisp.org/display/19397 is there a way of using Maybe's (>>=) operator to do away with the 'case' statement somehow?
13:08:03 <Cale_> palomer: okay, let me try it :)
13:08:44 <petekaz> xerox: that's fine and all, but I am just trying to play with monads. I don't need a HashTable, just picked it as it used the IO monad.
13:09:01 <Cale_> petekaz: well, in that case, it's  maybe (return ()) putStrLn
13:09:18 <Cale_> petekaz: you can't really make real decent use of the Maybe monad there
13:09:34 <petekaz> Oh, there is a function called 'maybe' as well?
13:09:38 <Cale_> yeah
13:09:54 <Cale_> maybe replacementForNothing replacementForJust
13:09:58 <petekaz> How would one use Maybe's >>= operator?  What would be a practical use of it?
13:10:20 <petekaz> Cale_: great tutorial btw
13:10:27 <Cale_> Let's say you were doing multiple lookups, and each of them might fail.
13:10:40 <mahogny> as with most monads except IO, pure convenience
13:10:55 <Cale_> and the next thing to look up depends on the previous ones in some way
13:11:06 <Cale_> and you want to avoid lots of case-mechanics
13:11:17 <Cale_> >>= in the Maybe monad does the right thing for you
13:11:31 <petekaz> could you show a fake example.
13:12:18 <Cale_> > do x <- find (>5) [1..10]; y <- find (>x) [1..10]; return y
13:12:19 <lambdabot> Just 7
13:12:28 <Cale_> > do x <- find (>8) [1..10]; y <- find (>x) [1..10]; return y
13:12:30 <lambdabot> Just 10
13:12:33 <Cale_> > do x <- find (>9) [1..10]; y <- find (>x) [1..10]; return y
13:12:34 <lambdabot> Nothing
13:12:53 <palomer> Cale_: it has to do with the MList and MList' ugliness
13:13:00 <Cale_> palomer: probably, yeah
13:13:03 * petekaz studies ...
13:13:05 <palomer> Cale_: wouldn't it be easier to just use the standard ListT monad?
13:13:19 <Cale_> palomer: the standard one is pretty broken for most monads
13:13:27 <palomer> hrmph
13:13:31 <palomer> this is an ST monad
13:13:43 <Cale_> Oh, then it would be really broken
13:13:45 <palomer> (well, a variant of your STI monad)
13:14:13 <petekaz> Cale_: neat. how do you strip away the Just?  That has to be done in a case?
13:15:40 <Cale_> petekaz: yeah
13:16:02 <Cale_> petekaz: or by just using the Maybe monad more, it remains transparent
13:16:22 <jlhamilton> > fromJust $ Just 3
13:16:23 <lambdabot> 3
13:17:58 <palomer> http://www.rafb.net/paste/results/fdGVQY88.html <--the solution
13:18:35 <heatsink> So I was reading about ~ and ! patterns on the haskell-prime list.
13:18:39 <Cale_> yes, that's what I was about to paste :)
13:18:48 <Cale_> I'll paste mine anyway :)
13:18:51 <heatsink> Are those for lazy deconstructor and strict non-deconstructor patterns?
13:18:54 <palomer> sure
13:18:55 <palomer> we'll compare
13:18:57 <Cale_> lisppaste2: url
13:18:57 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:19:26 <lisppaste2> Cale pasted "runListTFull" at http://paste.lisp.org/display/19400
13:21:06 <Cale_> heatsink: ~ patterns have been around for a while, they pattern match lazily, ! patterns are syntax sugar for applying seq to things, in effect making the function more strict in its arguments
13:21:08 <petekaz> Dumb followup question: How do I print the value?  I'm stuck in the Maybe monad.
13:21:10 <lisppaste2> petekaz annotated #19397 with "Followup on Maybe and IO" at http://paste.lisp.org/display/19397#1
13:21:56 <Cale_> petekaz: well, you'll likely want to do something different based on whether you have Nothing, or Just x
13:21:56 <petekaz> Where would the putStrLn $ show go?
13:22:01 <Cale_> you can use a case for that
13:22:10 <Cale_> main = print $ ...
13:22:24 <Cale_> and you'll get "Just 7"
13:22:52 <petekaz> I see.
13:23:30 <Cale_> Or you might do something like:
13:24:09 <palomer> Cale: tell me I can STI anything that's returned by a function with this type: http://www.rafb.net/paste/results/TTspGl39.html
13:24:17 <palomer> (for some reason, I can't!)
13:24:34 <Cale_> main = let u = find ... in case u of Nothing -> putStrLn "No solution found!"; Just x -> putStrLn ("Found " ++ show x)
13:24:42 <palomer> oh, wait, there's an STI inside an STI
13:24:45 <palomer> what the blazes
13:25:22 <petekaz> Cale_: thanks ... still learning the syntax, there are so many ways to write the same thing, let, where, etc .. I feel like I'm using Perl 
13:25:31 <Cale_> palomer: if you can just understand all that, you'
13:25:36 <Cale_> you'll be the next oleg
13:26:17 <Cale_> petekaz: no worries -- where is fine too here. The difference between let and where is that "let ... in ..." is an expression
13:26:45 <Cale_> whereas the "where ..." is part of a declaration
13:27:05 <Cale_> > (x + x where x = 2)
13:27:06 <lambdabot>  parse error on input `where'
13:27:15 <Cale_> > (let x = 2 in x + x)
13:27:16 <lambdabot> 4
13:27:43 <palomer> yes!
13:27:43 <Cale_> > let { f x = y where y = x + x } in f 2
13:27:45 <lambdabot> 4
13:27:47 <palomer> I got everything to type check!
13:27:52 <Cale_> palomer: :)
13:27:58 <petekaz> I see.
13:28:19 <palomer> and the type collapsed
13:28:20 <palomer> to this
13:28:30 <palomer> reconstruct :: (Show a, Eq a, Utilities.InfSeq a) =>
13:28:30 <palomer>  Term.Term a -> [Type.MonoType a]
13:28:41 <Cale_> petekaz: in that last example, the 'where' is part of the declaration of 'f' rather than part of f's RHS.
13:28:41 <xerox> InfSeq?
13:29:00 <Cale_> palomer: yeah, I thought that might happen
13:29:00 <palomer> InfSeq is the typeclass which supplies an infinite list
13:29:21 <Cale_> palomer: a lot of those class contexts are obviously satisfied
13:29:38 <petekaz> Cale_: got it. thanks.
13:30:08 <xerox> SamB!
13:30:11 <Cale_> petekaz: a cool side effect of this is that a single where clause will scope over multiple guards
13:30:18 <xerox> SamB: sign yourself up on the trac.
13:30:35 <palomer> don't! too much competition
13:30:57 <Cale_> > let f x | y > 100 = x | otherwise = y where y = x^2 in map f [1..20]
13:30:58 <lambdabot> [1,4,9,16,25,36,49,64,81,100,11,12,13,14,15,16,17,18,19,20]
13:33:26 <palomer> the emails really shouldn't be clickable on the trac
13:33:32 <palomer> I'm going to receive so much spam
13:34:26 <petekaz> neat.
13:35:54 <Cale_> I have 50 spams so far just today. Luckily all filtered :)
13:36:56 <xerox> palomer: isn't it the same?
13:36:59 <Cale_> heh, one of them says: may some some ! may some and not , see and be be a be , it's but a a a a not ! the try in it's but in see some a or
13:37:11 <xerox> Cale_: hahaha.
13:38:21 <Cale_> it has a dadaist quality to it doesn't it?
13:39:14 <Pawer> > foldl (/) 100 [1,2,5]
13:39:15 <lambdabot> 10.0
13:39:21 <Pawer> > foldh (/) 100 [1,2,5]
13:39:22 <lambdabot>  Not in scope: `foldh'
13:39:25 <SamB> xerox: hmm?
13:39:27 <Pawer> > foldr (/) 100 [1,2,5]
13:39:28 <lambdabot> 2.5e-2
13:39:35 <xerox> SamB: weren't you going to apply for some project?
13:39:49 <SamB> xerox: yeah
13:40:15 <xerox> SamB: then signup yourself on the People page, under "Interested Students"
13:41:01 <Pawer> what ahe you going to do?
13:41:05 <Pawer> are
13:42:23 <work_metaperl> could someone help me with a question on pattern-matching in do-notation: http://rafb.net/paste/results/k9j8Mu63.html
13:43:02 <Pawer> shoot
13:43:33 <Cale_> work_metaperl: It pattern matches against the elements of that list
13:43:50 <Pawer> it cant
13:43:51 <Pawer> ...
13:44:02 * tibbe wishes he was a haskell wiz
13:44:29 <Cale_> > do x <- [1,2,3]; return (show x)
13:44:29 <lambdabot> ["1","2","3"]
13:44:48 <Cale_> > do x <- [1,2,3]; return (x^2)
13:44:49 <lambdabot> [1,4,9]
13:45:12 <Cale_> x is an Integer in that do-expression
13:45:18 <Pawer> > do { x <- [1,2,3]; return (x^2) }
13:45:19 <lambdabot> [1,4,9]
13:45:28 <Pawer> > do { x <- 2*3; return (x^2) }
13:45:28 <lambdabot>  add an instance declaration for (Num (m a))
13:45:33 <Pawer> > do { x <- 3; return (x^2) }
13:45:33 <lambdabot>  add an instance declaration for (Num (m a))
13:45:33 <lambdabot>   In a 'do' expression: x <- 3
13:45:33 <lambdabot>   In the definition of `uzy':
13:45:34 <palomer> xerox: they should be something like palomer <@> foo.com
13:45:41 <Pawer> > do { x <- [3]; return (x^2) }
13:45:42 <lambdabot> [9]
13:45:44 <Pawer> ok
13:45:44 <tibbe> Cale how does bind work in the list monad?
13:45:56 <Cale_> xs >>= f = concat (map f xs)
13:45:57 <palomer> YES, MY ALGORITHM WORKS!!!
13:46:05 <palomer> if I don't touch it, it'll remain bug free 
13:46:07 <palomer> ignorance is bliss
13:46:28 <Cale_> so if you have something like  [1,2,3] >>= \x -> return (x^2)
13:46:44 <xerox> palomer: are you going to sign up?
13:46:47 <palomer> I did!
13:46:54 <Cale_> that's the same as   concat (map (\x -> return (x^2)) [1,2,3])
13:47:00 <Pawer> bne2 = do x <- [1,2,3]; y <- [1,2,3]; True <- return (x /= y); return (x,y)
13:47:06 <Pawer> > bne2 = do x <- [1,2,3]; y <- [1,2,3]; True <- return (x /= y); return (x,y)
13:47:06 <lambdabot>  parse error on input `='
13:47:13 <palomer> I'm Jacques
13:47:13 <Pawer> > bne2 = do x <- [1,2,3]; y <- [1,2,3]; True <- return (x =/ y); return (x,y)
13:47:14 <lambdabot>  parse error on input `='
13:47:19 <Pawer> > bne2 = do x <- [1,2,3]; y <- [1,2,3]; True <- return (x != y); return (x,y)
13:47:19 <lambdabot>  parse error on input `='
13:47:23 <Pawer> > bne2 = do x <- [1,2,3]; y <- [1,2,3]; True <- return (x \= y); return (x,y)
13:47:23 <lambdabot>  parse error on input `='
13:47:25 <Cale_> > do x <- [1,2,3]; y <- [1,2,3]; True <- return (x /= y); return (x,y)
13:47:25 <lambdabot> [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
13:47:32 <Pawer> > bne2 = do x <- [1,2,3]; y <- [1,2,3]; True <- return (x /= y); return (x,y)
13:47:33 <lambdabot>  parse error on input `='
13:47:34 <work_metaperl> oh yes, now I remember somethng from the nomaware tutorial - the LHS pattern matches _inside_ the container
13:47:35 <tibbe> Cale, and return creates a singleton list?
13:47:43 <Pawer> > do x <- [1,2,3]; y <- [1,2,3]; True <- return (x /= y); return (x,y)
13:47:44 <lambdabot> [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
13:47:45 <Cale_> work_metaperl: yes
13:47:52 <Cale_> tibbe: yep
13:47:58 <work_metaperl> tibbe: return "containerizes" a value
13:48:01 <work_metaperl> @type return
13:48:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
13:48:02 <Cale_> > do x <- [1,2,3]; y <- [1,2,3]; guard (x /= y); return (x,y)
13:48:03 <lambdabot> [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
13:48:11 <Cale_> > do x <- [1,2,3]; y <- [1,2,3]; guard (x < y); return (x,y)
13:48:12 <lambdabot> [(1,2),(1,3),(2,3)]
13:48:45 <Cale_> > return 5 :: [Integer]
13:48:46 <lambdabot> [5]
13:48:48 <Pawer> my teacrehs suhk
13:49:00 <Pawer> my teachers suck
13:49:57 <Cale_> Pawer: the reason for the "parse error on input `='" errors is that lambdabot only evaluates expressions -- you can't make declarations
13:50:04 <Pawer> yes i saw
13:50:31 <work_metaperl> hola Revision17
13:50:37 <Pawer> > 100 (/) 2
13:50:37 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
13:50:37 <lambdabot>   In the definition of `aaj': aaj = 100 (/) 2
13:50:37 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
13:50:47 <Cale_> > (/) 100 2
13:50:48 <lambdabot> 50.0
13:50:51 <Pawer> > 100 / 2
13:50:52 <lambdabot> 50.0
13:51:03 <Cale_> > 100 `div` 2
13:51:04 <lambdabot> 50
13:51:10 <Pawer> ^^
13:51:16 <Cale_> > 100 ^^ 2
13:51:17 <lambdabot> 10000.0
13:51:28 <Pawer> > foldr (/) 100 [1,2,5]
13:51:29 <lambdabot> 2.5e-2
13:51:34 <Pawer> > foldl (/) 100 [1,2,5]
13:51:35 <lambdabot> 10.0
13:51:50 <Revision17> work_metaperl: hello
13:52:29 <Pawer> > 1 / (2 / (5 / 100))
13:52:30 <SamB> Revision17: revision 17 of what are you?
13:52:30 <lambdabot> 2.5e-2
13:53:05 <Pawer> > foldr (*) 100 [1,2,5]
13:53:06 <lambdabot> 1000
13:53:12 <Pawer> > foldl (*) 100 [1,2,5]
13:53:13 <lambdabot> 1000
13:53:20 <Revision17> SamB: nothing really.  The 17th revision is usually a lucky number for me programming.  That's when things start really working well
13:53:45 <Cale_> > product [1,2,5,100]
13:53:46 <lambdabot> 1000
13:54:01 <SamB> Hmm. That would probably be like the 117th revision with darcs...
13:54:13 <Pawer> > foldl (+) 100 [1,2,5] == sum [1,2,5,100]
13:54:14 <lambdabot> True
13:54:42 <Pawer> i dont see fold utility
13:54:54 <Cale_> > foldr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1..5]
13:54:55 <lambdabot> "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
13:55:01 <SamB> Pawer: say what?
13:55:08 <Pawer> for + or *
13:55:14 <Pawer> dont see utility
13:55:27 <Pawer> of flod
13:55:33 <SamB> Pawer: look at the source for product and sum ;-)
13:55:35 <Cale_> well, sum and product are defined in terms of foldl
13:55:48 <SamB> though they really probably ought not use the fold that they use...
13:55:55 <Pawer> ok
13:55:56 <Pawer> XD
13:55:58 <Pawer> lol
13:56:06 <Pawer> roflmao
13:56:10 <Cale_> foldl' might be better in many cases
13:56:24 <Pawer> yes
13:56:27 <Cale_> though there's a chance that you want laziness
13:56:29 <Pawer> > foldl (/) 100 [1,2,5]
13:56:30 <lambdabot> 10.0
13:56:50 <Cale_> > foldl (+) 0 [1..1000000]
13:56:51 <lambdabot> Exception: stack overflow
13:56:55 <Cale_> > foldl' (+) 0 [1..1000000]
13:56:56 <lambdabot> 500000500000
13:57:03 <Pawer> too mucr poweh foh tre pooh lambda
13:57:23 <Pawer> too much power for the poor lambda
13:57:40 <Pawer> update changed my dvorak layout
13:57:50 <Pawer> r -> r
13:57:54 <Pawer> r -> h
13:58:12 <Cale_> Well, the stack is only finitely larce, and constructing an expression with 1000000 terms before any evaluation happens can be dangerous :)
13:58:17 <Cale_> large*
13:58:43 <Pawer>  foldl' (^ 100) 0 [1..1000000]
13:58:46 <Pawer> > foldl' (^ 100) 0 [1..1000000]
13:58:47 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
13:58:47 <lambdabot>   Expected type: (b -> t) -> b -> b -> t
13:58:47 <lambdabot>   Inferred type: (b -> t) -> b -> t
13:58:51 <Pawer> arr
13:58:53 <Pawer> ahh
13:59:04 <Pawer> > foldl' (^ 1) 0 [1..1000000]
13:59:05 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
13:59:05 <lambdabot>   Expected type: (b -> t) -> b -> b -> t
13:59:05 <lambdabot>   Inferred type: (b -> t) -> b -> t
13:59:16 <Pawer> > foldl' (^) 0 [1..1000000]
13:59:20 <lambdabot> Terminated
13:59:24 <Pawer> muhahaha
13:59:31 <Cale_> took too long
13:59:35 <Cale_> you only get 3 seconds :)
13:59:37 <Pawer> > foldl' (^) 0 [1..10]
13:59:37 <lambdabot> 0
13:59:45 <Cale_> 0^0
13:59:47 <Pawer> but is zero
13:59:48 <Cale_> > 0^0
13:59:49 <lambdabot> 1
14:00:04 <Pawer> > 0 ^ 1
14:00:05 <lambdabot> 0
14:00:26 <Cale_> > product []
14:00:27 <lambdabot> 1
14:00:27 <Pawer> > foldh' (^) 0 [1..10]
14:00:28 <lambdabot>  Not in scope: `foldh''
14:00:33 <Pawer> > foldr' (^) 0 [1..10]
14:00:34 <lambdabot>  Not in scope: `foldr''
14:00:39 <Pawer> > foldr (^) 0 [1..10]
14:00:43 <lambdabot> Terminated
14:00:47 <Pawer> > foldr' (^) 0 [1..10]
14:00:48 <lambdabot>  Not in scope: `foldr''
14:00:52 <Pawer> > foldl' (^) 0 [1..10]
14:00:53 <lambdabot> 0
14:00:57 <Cale_> > foldr (^) 0 [1..5]
14:00:58 <lambdabot> 1
14:01:06 <Cale_> > foldr (^) 0 [1..10]
14:01:08 <Pawer> foldr' not in scope ...
14:01:10 <lambdabot> Terminated
14:01:18 <Cale_> > foldr (^) 0 [1..7]
14:01:22 <lambdabot> Terminated
14:01:33 * Cale_ wonders if lambdabot's machine is compiling ghc
14:01:37 <Pawer> > foldl' (^) 0 [1..2]
14:01:38 <lambdabot> 0
14:01:42 <Pawer> > foldl' (^) 2 [1..2]
14:01:43 <lambdabot> 4
14:01:49 <Pawer> > foldl' (^) 2 [1..3]
14:01:50 <lambdabot> 64
14:01:58 <Cale_> > foldr (^) 1 [1..5]
14:02:02 <lambdabot> Terminated
14:02:04 <Cale_> > foldr (^) 1 [1..4]
14:02:05 <lambdabot> 1
14:02:08 <Pawer> > foldl' (^) 2 [1..4]
14:02:09 <lambdabot> 16777216
14:02:12 <Pawer> > foldl' (^) 2 [1..5]
14:02:13 <lambdabot> 1329227995784915872903807060280344576
14:02:26 <Pawer> > foldl' (^) 2 [1..10]
14:02:29 <lambdabot> Terminated
14:02:41 <Pawer> > foldr (^) 2 [1..2]
14:02:42 <lambdabot> 1
14:03:01 <Cale_> of course...
14:03:02 <Pawer> > foldr (^) 2 [2..5]
14:03:06 <lambdabot> Terminated
14:03:06 <Cale_> > foldr (^) 1 [2..5]
14:03:09 <Pawer> > foldr (^) 2 [2..3]
14:03:10 <lambdabot> Terminated
14:03:10 <lambdabot> 512
14:03:15 <Pawer> > foldr (^) 2 [1..3]
14:03:16 <lambdabot> 1
14:03:16 <Cale_> > foldr (^) 1 [2..4]
14:03:17 <lambdabot> 2417851639229258349412352
14:03:18 <Lemmih> Pawer: You can send private messages to lambdabot.
14:03:23 <Pawer> i know
14:03:29 <Pawer> nobodyis talking now
14:03:53 <Muad_Dibber> or
14:03:58 <Pawer> grci has lambda bot?
14:03:59 <Muad_Dibber> you could use ghcI :P
14:04:06 <Pawer> ghci has lambda bot?
14:04:13 <Muad_Dibber> no
14:04:17 <Muad_Dibber> but it has foldl' :P
14:04:21 <Cale_> heh
14:04:29 <Cale_> and it doesn't have resource limits
14:04:54 <Lemmih> Pawer: Spam is still spam even when voiced in a quiet room.
14:05:06 <Pawer> spam is an advehtisement
14:05:10 <Pawer> spam is an advertisement
14:05:19 <Pawer> ...
14:06:04 <Pawer> i stopped
14:07:14 <ADEpt> Lemmih: hi
14:07:44 <Lemmih> ADEpt: Hiya.
14:08:01 <Pawer> > loop "hello"
14:08:02 <lambdabot> Couldn't match `a (b, d)' against `[]'
14:08:09 <Pawer> > loop ["hello"]
14:08:10 <lambdabot> Couldn't match `a (b, d)' against `[]'
14:08:20 <Pawer> > loop replicate "hello"
14:08:21 <lambdabot> Couldn't match `Int' against `(b, d)'
14:08:35 <Pawer> > type loop
14:08:35 <lambdabot>  parse error on input `type'
14:08:39 <Cale_> @type loop
14:08:40 <lambdabot> forall (a :: * -> * -> *) c b d.
14:08:40 <lambdabot>    (ArrowLoop a) =>
14:08:40 <lambdabot>    a (b, d) (c, d) -> a b c
14:09:05 <SyntaxNinja> Pawer: can you please discuss this with lambdabot in a private message
14:09:25 <Pawer> i was thiying to say hello
14:09:35 <Pawer> i was trying to say hello
14:11:19 <ADEpt> Lemmih: have you done any hacking on cojure since winter?
14:12:05 <Lemmih> ADEpt: No, not really.
14:12:14 <jlhamilton> @listcommands
14:12:14 <lambdabot> Unknown command, try @list
14:12:15 <Pawer> where is lambdabot
14:12:17 <Pawer> ?
14:12:29 <jlhamilton> @list commands
14:12:30 <lambdabot> No module "commands" loaded
14:12:33 <jlhamilton> @list
14:12:34 <lambdabot> list [module|command]. Where modules is one of:
14:12:34 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
14:12:34 <lambdabot> unlambda version vixen where
14:12:37 <Pawer> where is lambdabot help
14:12:45 <jlhamilton> @help
14:12:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:12:51 <jlhamilton> @help list
14:12:51 <lambdabot> list [module|command]
14:12:51 <lambdabot> show all commands or command for [module]
14:13:18 <jlhamilton> @help pl
14:13:18 <lambdabot> pointless <expr>. Play with pointfree code.
14:13:27 <Pawer> can i ask lambdabot about loop function?
14:13:52 <Cale_> if you want to know what loop is about, you'll have to read a paper on Arrows
14:13:59 <Cale_> which are a generalisation of monads
14:14:03 <Cale_> @where arrows
14:14:03 <lambdabot> http://www.haskell.org/arrows/
14:14:11 <Pawer> ok
14:14:12 <palomer> so you'll have to read about monads first
14:15:01 <palomer> ooh, arrows look fun
14:15:05 <Pawer> @type map
14:15:06 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
14:15:47 <SyntaxNinja> Cale: the logo looks nice. 
14:15:53 <SyntaxNinja> Cale: thanks for doing that.
14:16:10 <Cale_> SyntaxNinja: no problem :)
14:16:31 <work_metaperl> SyntaxNinja: ltns
14:17:09 <musasabi> SyntaxNinja: would you accept a patch for the "data based versions in cabal files" idea? And what kind of syntax would you prefer?
14:17:35 <SyntaxNinja> musasabi: I don't know what that means. is that a SoC thing?
14:17:41 <SyntaxNinja> work_metaperl: y0. what's ltns?
14:19:10 <musasabi> SyntaxNinja: no, the "Cabal feature request - dates in versions" one.
14:19:31 <SamB> xerox: okay, added
14:19:46 <xerox> SamB: danke.
14:20:25 <musasabi> SyntaxNinja: e.g. currently my development version of HAppS depends on fps development version but since the dev version does not change version numbers except upon releases there is no good way to mark the dependency.
14:21:01 <musasabi> SyntaxNinja: also when someone has Foo-0.9 (where 0.9 is the dev version) there is no way to know which version it is.
14:21:12 <musasabi> This has been a problem with Cabal too.
14:21:28 <SyntaxNinja> musasabi: yeah, we were supposed to bump the cabal version before release, but simon didn't realize that.
14:21:45 <SyntaxNinja> musasabi: not exactly sure what you're asking for, do you have a link? it sounds OK.
14:23:16 <musasabi> SyntaxNinja: I am asking for a way to automatically replace some token with date in the version field of packages.
14:23:51 <musasabi> (I don't care much about the exact syntax, just that this would be very useful for dev versions of packages)
14:24:33 <musasabi> No patch at the moment, but I can create it if you feel like it is something that could go in.
14:24:48 <SamB> date of *what*?
14:25:03 <SyntaxNinja> musasabi: have you looked at simonMar's configuration stuff at all?
14:25:41 <Pawer> foo :: Int -> Int -> Int
14:25:44 <SyntaxNinja> musasabi: I would prefer not to extend the .cabal files with variable expansion if possible, I think it ends up being ugly
14:25:58 <Cale_> perhaps something should be added to the Haskell.org front page about SoC.
14:26:11 <Pawer> has superior order?
14:26:14 <Pawer> foo :: Int -> Int -> Int
14:26:15 <Pawer> has superior order?
14:26:17 <SyntaxNinja> musasabi: sorry, I can't really fully evaluate it right now, though. go a head and put a feature request on the cabal tracker and email me.
14:26:30 <musasabi> SyntaxNinja: yes, that is a good argument, on the other hand using a foo.cabal.in just for version is not very nice.
14:26:58 <musasabi> ok, I'll try to write up more on the matter and then mail you.
14:27:06 <SamB> musasabi: I ask again: where is this date supposed to come from?
14:28:03 <musasabi> SamB: build date, of course one can build obsolete sources and cause problems.
14:28:18 <musasabi> SamB: then again it is better than the current situation.
14:28:22 <SyntaxNinja> musasabi: I am pretty much against foo.cabal.in also :)
14:29:00 <SyntaxNinja> I like the .cabal file to be the source of the data. that's why its format is so simple
14:29:12 <SyntaxNinja> I dont' think simon's configuration stuff will help here, but it might.
14:29:37 <dcoutts> foo.cabal.in is also bad because it will bork an IDE
14:29:39 <musasabi> SyntaxNinja: what is the good way to mark progress of development versions without manually incrementing the version number after each change?
14:30:21 <musasabi> SyntaxNinja: I haven't seen the configuration stuff, should look at it.
14:30:56 <dcoutts> SyntaxNinja, configuration stuff? you mean the optional dep syntax or something else?
14:31:14 <dcoutts> SyntaxNinja, have you proposed any Cabal SoC projects?
14:31:42 <dcoutts> SyntaxNinja, eg a make-like dep graph system extensible for new tools/pre-processors?
14:34:01 <Pawer> foo :: Int -> Int -> Int
14:34:02 <Pawer> has superior order?
14:34:25 <SyntaxNinja> dcoutts: yes, the optional dep stuff
14:34:26 <sethk> dons, we pushed our 1000th machine through the system today
14:34:42 <sethk> dons, have a couple of minor bugs, but generally speaking it's going quite well
14:34:49 <SyntaxNinja> musasabi: I don't distinguish between development versions in the version number.
14:34:57 <SyntaxNinja> musasabi: but it's a very understandable request.
14:35:26 <Pawer> odd
14:35:29 <SyntaxNinja> dcoutts: I have only added one, I think, but it would be great if you added some!  Ideally, add the tix to the cabal ticket tracker and link them from the SoC one so that they don't get lost if we don't do them.
14:35:40 <SamB> musasabi: one way is by last tag and number of patches since
14:36:00 <musasabi> SamB: yes, but how to do that with Cabal?
14:36:14 <dcoutts> SyntaxNinja, oh, I'm supposed to ask you for a login. (unless it's the same account system as the ghc trac)
14:36:15 <mux> is there any way to control the precision of the number being output by the various show methods for integers?
14:36:26 <SamB> musasabi: that is harder :-(
14:36:46 <SamB> mux: try printf
14:36:58 <mux> thanks
14:37:04 <Pawer> > zip [1] [1,2]
14:37:05 <lambdabot> [(1,1)]
14:37:14 <dcoutts> mux, you mean for floats?
14:37:20 <xerox> dcoutts_: I was hoping for other Gtk2Hs ones :-)
14:37:32 <dcoutts> mux, there are three different float -> string formatting functions
14:37:33 <xerox> mux: this
14:37:47 <dcoutts> @hoogle Float -> String
14:37:48 <lambdabot> No matches, try a more general search
14:37:49 <mux> dcoutts: I meant for arbitrary-precision integers, but also for floats actually
14:37:54 <xerox> > showFFloat (Just 10) pi ""
14:37:55 <lambdabot> "3.1415926536"
14:38:01 <mux> nice
14:38:07 * SamB notices he forgot to actually submit his changes...
14:38:12 <dcoutts> mux, well for Integer just use show
14:38:12 <xerox> ?index showFFloat
14:38:12 <lambdabot> Numeric
14:38:18 <xerox> ?docs Numeric
14:38:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
14:38:28 <dcoutts> > show (10^10^10)
14:38:32 <lambdabot> Terminated
14:38:35 <dcoutts> heh
14:38:36 <xerox> Gulp.
14:38:38 <dcoutts> > show (10^10)
14:38:39 <lambdabot> "10000000000"
14:39:02 <monochrom> @hoogle (RealFrac a) => a -> String
14:39:03 <lambdabot> Prelude.show :: Show a => a -> String
14:39:03 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
14:39:03 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
14:39:27 <monochrom> @hoogle (RealFrac a) => a -> ShowS
14:39:27 <lambdabot> Prelude.shows :: Show a => a -> ShowS
14:39:27 <lambdabot> Prelude.showsPrec :: Show a => Int -> a -> ShowS
14:39:27 <lambdabot> Numeric.showFloat :: RealFloat a => a -> ShowS
14:39:27 <Cale_> wouldn't it be fun if we had an integer representation and show function which was smart enough to start printing that :)
14:39:31 <monochrom> There!
14:40:00 <Pawer> @type \x -> x
14:40:01 <lambdabot> forall t. t -> t
14:40:33 <mux> > 8 *** 5 where (***) x n = foldr1 (**) (replicate n x)
14:40:34 <lambdabot> Infinity
14:40:39 <mux> heh heh heh.
14:40:53 <dcoutts> Pawer, see:
14:40:53 <mux> hyper-exponentiation too much for lambdabot
14:40:56 <dcoutts> @type show
14:40:57 <lambdabot> forall a. (Show a) => a -> String
14:40:59 <SamB> xerox: okay, now I added myself for real ;-)
14:41:09 <SamB> before I had just hit the "preview" button...
14:41:19 <xerox> SamB: I'm refactoring, just a sec
14:41:54 <Pawer> > (**) 2 3
14:41:55 <lambdabot> 8.0
14:41:57 <Pawer> > (**) 2 2
14:41:58 <lambdabot> 4.0
14:42:05 <mux> > 2 *** 4 where (***) x n = foldr1 (**) (replicate n x)
14:42:06 <lambdabot> 65536.0
14:42:56 <int80_h> hey I think I may have goofed on the Summer of Code wiki
14:43:08 <int80_h> I just wanted to communicate that I was interested in a certain
14:43:08 <int80_h>           project, and ended up assigning it to myself
14:43:16 <Pawer> @type foldr
14:43:17 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
14:43:24 <Pawer> @type foldr1
14:43:26 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:43:30 <Pawer> ahh
14:43:45 <int80_h> how can I just put in my own "I'd like to be on this?" without
14:43:45 <int80_h>           assigning it to myself. I assume assignment is for someone else to
14:43:45 <int80_h>           do
14:43:54 <int80_h> oops that was a cut and paste, sorry
14:44:10 <Pawer> > foldr1 (+) [1,2,3,4]
14:44:11 <lambdabot> 10
14:44:32 <SyntaxNinja> int80_h: just add a section == Interested students == or something and add your name to it.  also, on the "people" page, add your name and link to the tix you're interested in
14:44:42 <SyntaxNinja> it would be nice if we could automagically cross-reference them, but no dice there.
14:45:28 <int80_h> excellent thanks
14:45:44 <SyntaxNinja> most important is that your name is on the "people" page and linked to the tickets you're interested in 
14:45:45 <mux> Pawer: foldr (+) == sum
14:46:00 <monochrom> heisenbug = (error bound on location of bug)*(error bound on certainty of bug) >= Planck's constant?
14:46:27 <Pawer> foldr1 is defined over foldr or viceversa?
14:47:15 <Pawer> @type id x = x
14:47:16 <lambdabot> parse error on input `='
14:47:44 <ADEpt> is there other possibility to find out a place of "testXmpp: Prelude.tail: empty list" other than rebuilding with "-prof" and running with "+RTS -x" ?
14:47:54 <heisenbug> monochrom: you can't locate and fix the same bug at the same time
14:48:01 <xerox> SamB: done.
14:48:22 <Pawer> > (\x -> x*3) 4 
14:48:23 <lambdabot> 12
14:48:47 <Pawer> > (\x \y -> x*y) 3 4
14:48:48 <lambdabot>  parse error on input `\'
14:49:03 <Pawer> > (\x\y -> x*y) 3 4
14:49:03 <lambdabot>  parse error on input `\'
14:49:09 <Pawer> can you relp me?
14:49:17 <Pawer> can you help me witr tris last?
14:49:21 <Pawer> can you help me witr this last?
14:49:35 <monochrom> \x y -> x*y
14:49:44 <Pawer> thx
14:49:47 <monochrom> or, \x -> \y -> x*y
14:50:04 <Pawer> curry?
14:50:43 <monochrom> No. \x y -> x*y  equivales  \x -> \y -> x*y.   If you want two \'s you also need two ->'s.
14:51:17 <musasabi> Has anyone used http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ and is there a paper about it?
14:52:41 <Pawer> haskell can use posix threads?
14:52:52 <mahogny> musasabi, the paper about the implementation says it all
14:52:53 <Pawer> semaphores mutex ...
14:53:23 <mux> haskell has builtin ultra-lightweight threads and OS-supported threads if you really need them, via forkOS
14:53:44 <mux> you won't need semaphores
14:53:51 <mux> you'd probably use an MVar
14:53:53 <musasabi> mahogny: link? I hadn't noticed a new paper on parray stuff.
14:53:54 <mux> or some variation of it
14:54:03 <Pawer> trx
14:54:07 <Pawer> thx
14:54:14 <musasabi> Haskell weekly news needs a section about interesting papers.
14:54:15 <mahogny> musasabi, have none. wasn't it one of the simons that implemented it?
14:55:16 <musasabi> mahogny: Manuel M T Chakravarty is what the sources say.
14:55:27 <mahogny> hmm. must be a different parallel then
14:55:41 <monochrom> http://www.cs.utoronto.ca/~trebla/chatserver.hs   toy chat server using haskell threads and stm.
14:55:53 <mahogny> musasabi, if you want parallelism over arrays, then check simons parallell arrays. they might or might not end up in haskell'
14:56:27 <musasabi> Found http://www.cse.unsw.edu.au/~chak/project/dph/
14:58:19 <mahogny> ok. then by no doubt, check the links to the simons
14:58:26 <mahogny> one of them has a paper
14:59:12 <Pawer> > \(x:xs) -> x
14:59:12 <lambdabot> Add a type signature
14:59:24 <Pawer> > (\(x:xs) -> x) [1,2]
14:59:25 <lambdabot> 1
14:59:31 <Pawer> > (\(x:xs) -> x) [1..]
14:59:32 <lambdabot> 1
14:59:38 <Pawer> > (\(x:xs) -> x) [..]
14:59:39 <lambdabot>  parse error on input `..'
14:59:49 <Pawer> > (\(x:xs) -> x) [..2]
14:59:50 <lambdabot>  parse error on input `..'
15:00:09 <Pawer> > (\(x:xs) -> xs) [1..10]
15:00:10 <lambdabot> [2,3,4,5,6,7,8,9,10]
15:00:26 <monochrom> Do you need help?
15:00:32 <Pawer> yes
15:00:53 <Pawer> f (x:xs) is an strict function?
15:01:16 <Pawer> f (x:xs) is an "strict in his argument" function?
15:01:20 <mux> haskell is a non-strict language
15:01:26 <mux> mm, what do you mean exactly?
15:01:32 <Pawer> but functions can be
15:01:42 <Pawer> ok
15:01:43 <mux> non-stricts means the language lazily evluates
15:02:01 <eivuokko> That pattern forces evaluation of constructor :, nothing more.
15:02:05 <Pawer> wait
15:02:06 <monochrom> fairly strict. strict to the point of obtaining the first cons cell of the list.
15:02:22 <xerox> monochrom: any thoughts about the theorem prover idea?
15:02:38 <monochrom> but non-strict as to the "data" content of the cons cell and to the rest of the list
15:02:47 <monochrom> Not particular thoughts, xerox.
15:02:54 <Pawer> infinite = infinite + 1
15:03:11 <Pawer> three x = 3 
15:03:20 <Pawer> three infinite 
15:03:21 <Pawer> 3
15:03:31 <ADEpt> what is the easiest way to build/install a profiling version of cabalized library (i'm thinking about HaXml)?
15:03:37 <monochrom> > (\(x:xs) -> True) ([undefined, False] ++ undefined)
15:03:37 <lambdabot> True
15:03:54 <xerox> Laziness!
15:03:58 <eivuokko> Adept, give setup-script -p flag, iirc.  But that probably requires cabal>1.0
15:03:58 <monochrom> > (\(x:xs) -> True) (undefined ++ [False,True])
15:03:59 <lambdabot> Undefined
15:04:17 <Pawer> yesthree infinite 
15:04:17 <monochrom> That is how strict and how non-strict  (\(x:xs) -> True) is.
15:04:18 <eivuokko> Adepth, mhm, might be the flag was given in configure step
15:04:26 <mahogny> heck. build cabal into GHC. extreme laziness: only downloads a library until it has to be evaluated :P
15:04:35 <mahogny> *when
15:04:40 <monochrom> You can make it more non-strict by "irrefutable pattern".
15:04:49 <monochrom> > (\~(x:xs) -> True) (undefined ++ [False,True])
15:04:49 <lambdabot>  parse error on input `->'
15:05:00 <monochrom> eh?
15:05:01 <Pawer> > double 3
15:05:02 <lambdabot>  Not in scope: `double'
15:05:14 <Pawer> > (* 2) undefined
15:05:15 <lambdabot> Undefined
15:05:18 <int-e> monochrom: you need a space between \ and ~
15:05:21 <Pawer> > (* 2) 3
15:05:22 <lambdabot> 6
15:05:40 <monochrom> > (\ ~(x:xs) -> True) (undefined ++ [False,True])
15:05:41 <lambdabot> True
15:05:44 <monochrom> danke!
15:05:45 <Pawer> > (\(x:xs) -> x) undefined
15:05:46 <lambdabot> Add a type signature
15:05:55 <Pawer> > (\(x:xs) -> x) [1,2]
15:05:56 <lambdabot> 1
15:06:06 <xerox> aka `head'
15:06:11 <Pawer> what is tre undefined value?
15:06:13 <monochrom> I must refine my first example.
15:06:25 <Pawer> the*
15:06:37 <mahogny> actually, that's an idea for cabal. many haskell sources add libraries they need in pragmas. why not make cabal able to read out which libraries are needed and then do something distro dependent to issue a download of the needed packages?
15:06:37 <ADEpt> eivuokko: hm. that easy? :) i thought there is some "./Setup install-prof-as-well" or something :)
15:06:44 <monochrom> > (\(x:xs) -> True) ([undefined] ++ undefined ++ [False,True])
15:06:45 <lambdabot> True
15:07:41 * xerox waves to ndm 
15:08:00 <Pawer> strict is when if the value is undefined, the function is undefined always
15:08:00 * ndm waves back at xerox
15:08:26 <monochrom> Yes.
15:08:40 <Pawer> i want to pass tre undefined value to > (\(x:xs) -> x)
15:08:56 <Pawer> to creck if is an strict function
15:09:03 <monochrom> But as you see, with larger data structures, there are all sorts of shades of strictness.
15:09:04 <Pawer> to creck if it is an strict function
15:09:13 <ADEpt> mahogny: in debian, this is called auto-apt and already exists :)
15:09:14 <Pawer> check*
15:09:20 <mahogny> ADEpt, ah
15:09:33 <mahogny> hm. wait here; will that really work? what pawer says
15:09:51 <Pawer> > (\(x:xs) -> x) Undefined
15:09:52 <lambdabot>  Not in scope: data constructor `Undefined'
15:09:56 <Pawer> ...
15:10:07 <RyanT5000> lowercase
15:10:08 <mahogny> will not the strictness only toggle if you run the function it is embedded in, and the encapsulating function here is lazy...
15:10:11 <monochrom> > (\(x:xs) -> x) (undefined :: [Bool])
15:10:12 <lambdabot> Undefined
15:11:02 <Pawer> f x = 0 is non-strict
15:11:34 <Pawer> arr
15:11:50 <Pawer> (\(x:xs) -> x) needs to use tre value
15:11:56 <Pawer> the*
15:12:05 <Pawer> so it is strict
15:13:00 <monochrom> I suppose so.
15:13:21 <monochrom> But why does human tend to impose a dichotomy where there is an infinite CPO?
15:13:39 <xerox> Goodnight people.
15:13:39 <ndm> does anyone have any expericence with Cabal
15:13:53 <ndm> goodnight
15:13:58 <Pawer> ask my teacheh in the exam
15:14:00 <ndm> (maybe even SyntaxNinja ?)
15:14:02 <Pawer> ask my teacher in the exam
15:14:27 <SyntaxNinja> hi ndm
15:14:30 <monochrom> If you're over 18 you should challenge your teacher with the Truth.
15:14:35 <ndm> i'm trying to compile the base libraries using cabal, and while there is base.cabal there is no setup.hs
15:14:42 <Pawer> in the exam?
15:14:57 <ndm> i created it, got some distance, and get to various errors
15:15:03 <monochrom> Both inside and outside exams, inside and outside class time, ...
15:15:08 <ndm> all of which are related to trying to do this on windows, not cygwin
15:15:12 <Lemmih> 'night, xerox.
15:15:14 <SyntaxNinja> ndm: I think it should be main = defaultMainWithHooks defaultUserHooks
15:15:24 <SyntaxNinja> the base makefiles do some magic, I think. 
15:15:40 <ndm> SyntaxNinja: i just went for main = defaultMain
15:15:41 <monochrom> "(\(x:xs)->x) is strict" this is true but boring.
15:15:50 <ndm> i was just wondering if there was any reason it shouldn't work
15:16:07 <ndm> since the makefile is not windows happy (obviously, being a makefile!) - cabal would be a lot nicer
15:16:49 <monochrom> "(\(x:xs)->x) ('x' : undefined)" this is more interesting and useful
15:16:50 <SyntaxNinja> ndm: it needs the default hooks to run configure.
15:16:55 <Pawer> f (a,b) = x is strict?
15:17:05 <Pawer> f (a,b) = x, is strict?
15:17:10 <monochrom> Try it!
15:17:38 <Pawer> (\(a,b) -> x) (2,3)
15:17:43 <Pawer> > (\(a,b) -> x) (2,3)
15:17:44 <lambdabot>  Not in scope: `x'
15:17:47 <Pawer> > (\(a,b) -> a) (2,3)
15:17:48 <lambdabot> 2
15:18:10 <Pawer> (2,3) is an unique ahgument
15:18:14 <Pawer> (2,3) is an unique argument
15:18:20 <ndm> SyntaxNinja: thats great, with defaultUserHooks GHC segfaults :)
15:18:24 <Pawer> is strict
15:18:33 <palomer> oh boy, I'm going to have 2 monad transformers stacked onto a mondo monad
15:18:35 * palomer cringes
15:18:44 <Pawer> > strict (\(a,b) -> a) 
15:18:44 <lambdabot>  Not in scope: `strict'
15:18:48 <monochrom> If you do "hGetContents" to a file handle, but that file handle refers not to a file but a tcp/ip socket, you will care a lot more about "(\(x:xs)->x) ('x' : undefined)" than "(\(x:xs)->x) undefined"
15:19:10 <SyntaxNinja> ndm: cabal is indeed powerfulk, as the emperor has fortold
15:19:28 <ndm> SyntaxNinja: i'm actually quite impressed, i've not used cabal before
15:19:31 <monochrom> palomer: woohoo!
15:19:36 <Pawer> > (\(x:xs) -> x) x
15:19:37 <lambdabot>  Not in scope: `x'
15:19:41 <ndm> although i think i'm going to have to make it a bit more windows friendly :)
15:19:55 <Pawer> > (\(x:xs) -> x) x::Undefined
15:19:56 <lambdabot>  Not in scope: type constructor or class `Undefined'
15:20:13 <SyntaxNinja> ndm: :)
15:20:24 <SyntaxNinja> ndm: it's integrated w/ visual haskell, how much more windows friendly can you get? ;)
15:20:36 <monochrom> > (\(a,b) -> True) (undefined :: Int)
15:20:37 <lambdabot> Couldn't match `(a, b)' against `Int'
15:20:47 <monochrom> > (\(a,b) -> True) (undefined :: (Int,Float))
15:20:47 <lambdabot> Undefined
15:20:49 <ndm> SyntaxNinja: visual haskell is too slow on my comp, i want hugs compatability
15:21:00 * SyntaxNinja nods
15:21:04 <monochrom> there is visual haskell?!
15:21:11 <RyanT5000> monochrom: yeah
15:21:13 <RyanT5000> i use it
15:21:24 <Pawer> in linux?
15:21:32 <monochrom> this world is WRONG
15:21:49 <RyanT5000> hm?
15:21:58 <Pawer> there is a function in haskell to check if a function is strict?
15:22:15 <monochrom> Yes.  It will also check if a function terminates.
15:22:20 <RyanT5000> :P
15:22:22 <Pawer> Wow
15:22:28 <Pawer> what is...
15:22:32 <ndm> Pawer, no, its undecidable, i think (or at least hte level of strictness)
15:22:41 <Pawer> ahhh
15:22:41 <monochrom> It may take forever.
15:22:47 <Pawer> yess
15:22:51 <Pawer> jajaja
15:23:00 <Pawer> computers limits
15:23:22 <monochrom> and human limits too
15:23:44 <Pawer> less limits
15:23:49 <monochrom> I bet you that there are far more people who "don't know when to stop" then there are buggy programs and crashing computers.
15:24:52 <Pawer> yeah
15:25:08 <monochrom> when a human focus on a pursuit, he doesn't know whether he will stop either.
15:26:05 <RyanT5000> can TH parse an entire module?
15:27:05 <Pawer> > 1:1
15:27:05 <lambdabot>  add an instance declaration for (Num [a])
15:27:12 <Pawer> > (1:1)
15:27:12 <lambdabot>  add an instance declaration for (Num [a])
15:27:27 <Pawer> > (1:[1,2])
15:27:28 <lambdabot> [1,1,2]
15:27:34 <Pawer> > (1:[1])
15:27:35 <lambdabot> [1,1]
15:27:38 <Pawer> > 1:[1]
15:27:39 <lambdabot> [1,1]
15:27:42 <Pawer> > 1:[1,2]
15:27:43 <lambdabot> [1,1,2]
15:27:48 <Pawer> > 1:[]
15:27:49 <lambdabot> [1]
15:27:54 <Pawer> > 1:[]:[]
15:27:55 <lambdabot>  add an instance declaration for (Num [a])
15:28:59 <Pawer> i will get mad
15:29:28 <Pawer> those test questions are too hard
15:29:30 <ADEpt> eivuokko: thanks. "...configure -p" did the trick
15:30:42 <monochrom> it is rather obvious why 1:[]:[] does not make sense.
15:31:00 <Pawer> diffehence between local and partial function definition?
15:31:18 <Pawer> yes but
15:31:28 <Pawer> [1]:[1]:[]
15:31:31 <Pawer> ras sense
15:31:34 <Pawer> has sense
15:31:36 * ADEpt built binary with -prof only to find out that "<GHC.List.CAF>testXmpp: Prelude.tail: empty list". Grrrrrrr!
15:31:38 <Pawer> > [1]:[1]:[]
15:31:38 <lambdabot> [[1],[1]]
15:31:58 <Pawer> lol
15:32:01 <dcoutts> > (1:[]):[]
15:32:02 <lambdabot> [[1]]
15:32:05 <monochrom> What is the type of : ?  What are the expected types of the two arguments?
15:32:12 <dcoutts> @ type (:)
15:32:16 <dcoutts> @type (:)
15:32:17 <lambdabot> forall a. a -> [a] -> [a]
15:32:40 <Pawer> thanks dcoutts
15:33:27 <monochrom> So, in 1:___ , let's say 1 is Int, then you expect ___ to be [Int]
15:34:16 <monochrom> If you now fill in []:[] for ___, then you expect the second [] to be [Int] (good) and the first one to be Int (wtf)
15:34:31 <Pawer> > (3:) [4,5,6]
15:34:32 <lambdabot> [3,4,5,6]
15:34:35 <monochrom> It's just logic!
15:34:47 <Pawer> yes but
15:34:52 <monochrom> (Yes, logic is hard, humans can't do logic, computers can.)
15:35:03 <Pawer> you have to see
15:35:08 <Pawer> the papehs
15:35:11 <Pawer> the papers
15:35:20 <monochrom> I have read a lot of papers.
15:35:32 <Pawer> the things explained in the classroom
15:35:40 <Pawer> and the exam questions
15:37:25 <Pawer> [] is considehed a list?
15:37:32 <int-e> yes
15:37:34 <Pawer> [] is considereed a list?
15:37:36 <monochrom> [1]:[1]:[] works this way:  [1]:____ this forces [1]::[Int], ___::[[Int]].  The ___ is in turn [1]:[] forcing [1]::[Int] and []::[[Int]].  All is good.
15:37:50 <int-e> [] is the empty list
15:37:51 <Pawer> and
15:37:57 <Pawer> > 1:[]
15:37:58 <lambdabot> [1]
15:38:01 <Pawer> > 1:[]:[]
15:38:02 <lambdabot>  add an instance declaration for (Num [a])
15:38:07 <monochrom> All the more reason to challenge your teacher, not just on the Truth but also how to explain it.
15:38:15 <Pawer> dont works because is a list
15:38:36 <Pawer> yeah
15:38:40 <Pawer> i know
15:38:57 <monochrom> If you say "the class is unclear" yes that may be true but you are not a highschool kid, you are supposed to complain loudly and cause changes.
15:39:35 <monochrom> Or alternatively you skip classes and learn from better sources.
15:39:55 <Pawer> yes a know
15:40:22 <monochrom> Although, a few days just before the exam is rather later for any action along those lines. :)
15:40:40 <Pawer> i know
15:40:50 <ndm> monochrom: sometimes if you complain too loudly it becomes an issue - sometimes not rocking the boat is the best way
15:41:07 <Pawer> yes 
15:41:09 <monochrom> Yes I do provide a quiet alternative.
15:41:15 <Pawer> me too
15:41:17 <Pawer> XD
15:42:07 <Pawer> they translated Richard Bird to Spanish
15:42:19 <monochrom> that's funny!
15:42:32 <Pawer> yes
15:42:54 <Pawer> so you need to buy the book
15:42:57 <Pawer> $$$
15:42:59 <Pawer> XDD
15:43:03 <monochrom> the book is good.
15:43:09 <Pawer> a know
15:43:13 <Pawer> I know
15:44:48 <Pawer> > (2<3<4)
15:44:49 <lambdabot>   precedence parsing error
15:44:49 <lambdabot>    cannot mix `(<)' [infix 4] and `(<)' [infix 4] in the same infix expression
15:45:06 <Pawer> @type (<)
15:45:07 <lambdabot> forall a. (Ord a) => a -> a -> Bool
15:45:08 <monochrom> Can't do that unfortunately.  have to do 2<3 && 3<4
15:45:21 <Pawer> > (2<3)<4
15:45:21 <lambdabot>  add an instance declaration for (Num Bool)
15:45:32 <Pawer> > (2<3) < 4
15:45:33 <lambdabot>  add an instance declaration for (Num Bool)
15:45:55 <monochrom> Bool < Int  is not a good sign
15:46:23 <Pawer> > (True < 3)
15:46:23 <lambdabot>  add an instance declaration for (Num Bool)
15:46:29 <Pawer> > True < 3
15:46:30 <lambdabot>  add an instance declaration for (Num Bool)
15:46:38 <Pawer> sorry
15:47:09 <monochrom> You need to be more type-sensitive and ditch all those loosely-typed Perl and Python junk.
15:48:47 <Pawer> i only program in C
15:48:53 <Pawer> and octave
15:49:29 <RyanT5000> well 2 < 3 < 4 doesn't work in C...
15:49:37 <Pawer> > 1:1:[]
15:49:38 <lambdabot> [1,1]
15:49:39 <sjanssen_> RyanT5000: are you sure?
15:49:45 <RyanT5000> depending on your definition of "work"
15:49:56 <RyanT5000> it gets the right answer for the wrong reasons
15:50:09 <ADEpt> RyanT5000: depending on your definition of "<", rather ;)
15:50:10 <sjanssen_> RyanT5000: it will compile, but not work reliably
15:50:12 <monochrom> 2<3<4 works in C with a screwy semantics, worse than perl.
15:50:27 <Pawer> use &&
15:50:36 <RyanT5000> ADEpt: you can't redefine < in C, and you can't redefine operator < (int, int) in C++
15:50:50 <monochrom> heh heh heh 
15:51:35 <ADEpt> RyanT5000: it seems that I forgot the last remains of C++ knowledge I had. Calls for celebration :)
15:52:05 <sjanssen_> I wonder if some clever syntax/type class hacking could make 1 < x < 3 work
15:52:25 <RyanT5000> sjanssen_, i'm not sure
15:52:28 <musasabi> not really.
15:52:33 <musasabi> @type (<)
15:52:34 <lambdabot> forall a. (Ord a) => a -> a -> Bool
15:52:51 <sjanssen_> musasabi: with my own private definitions of < and friends
15:52:55 <RyanT5000> musasabi, i think he means if you redefined <
15:53:04 <musasabi> sjanssen_: then it can work I think.
15:53:15 <musasabi> sjanssen_: just use the techniques for vararg functions?
15:54:06 <ADEpt> If I get "<GHC.List.CAF>testXmpp: Prelude.tail: empty list" for "./testXmpp +RTS -xc", is it safe to assume that culprit is somwhere in Main?
15:54:18 <Pawer> > (\x -> 2*x)*(\x -> 2*x) 4
15:54:19 <lambdabot>  add an instance declaration for (Num (a -> a))
15:54:25 <Pawer> > (\x -> 2*x).(\x -> 2*x) 4
15:54:26 <lambdabot>  add an instance declaration for (Num (a -> b))
15:54:34 <monochrom> need parens
15:54:36 <Pawer> lambdabot suppohts composition?
15:54:44 <Pawer> > ((\x -> 2*x)*(\x -> 2*x)) 4
15:54:45 <lambdabot>  add an instance declaration for (Num (a -> a))
15:54:45 <lambdabot>   In the definition of `ekk': ekk = ((\ x -> 2 * x) * (\ x -> 2 * x)) 4
15:54:45 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
15:54:45 <resiak> > (\x -> 2*x).(\x -> 2*x) $ 4
15:54:47 <lambdabot> 16
15:55:12 <monochrom> * for functions is unimplemented.  You can implement it yourself if you want.
15:55:13 <Pawer> what is $
15:55:30 <resiak> What you were writing parsed as (*2) . ((*2) 4), not as ((*2) . (*2)) 4, which is what you wanted
15:55:35 <monochrom> f$x = f x.  But $ has nice precedence
15:55:35 <resiak> a $ b = ab
15:55:44 <resiak> erm, with a space
15:55:48 <Pawer> > (\x -> 2*x).(\x -> 2*x) 4
15:55:48 <lambdabot>  add an instance declaration for (Num (a -> b))
15:55:56 <monochrom> >  ((\x -> 2*x).(\x -> 2*x))  4
15:55:57 <lambdabot> 16
15:56:07 <Pawer> ok
15:56:08 <heatsink> resiak: That's what ## does, if you pass it through the C preprocessor
15:56:09 <Pawer> ()
15:56:12 <monochrom> You can just parenthesize.
15:56:25 <sjanssen_> musasabi: there is the added problem of the fixity of <, usually you can't have more than one in an expression
15:56:36 <monochrom> Haskell is the world's finest imperative macro language!
15:59:17 <RyanT5000> > foldl (<) 0 [2, 3, 4]
15:59:17 <lambdabot>  add an instance declaration for (Num Bool)
15:59:17 <lambdabot>   In the list element: 4
15:59:28 <RyanT5000> hm
15:59:35 <monochrom> heh heh heh
15:59:51 <RyanT5000> are there literals for infinity?
16:00:00 <RyanT5000> nvm
16:00:04 <monochrom> No. Have to 1/0
16:00:11 <RyanT5000> lol
16:00:17 <RyanT5000> > 1/0
16:00:18 <lambdabot> Infinity
16:00:21 <RyanT5000> wtf
16:00:38 <monochrom> > 1/(1/0)
16:00:39 <lambdabot> 0.0
16:00:40 <Pawer> > (\x -> 2*x) 4
16:00:40 <lambdabot> 8
16:00:44 <monochrom> hee hee hee!
16:00:46 <Pawer> > (\x -> 2*x)(4)
16:00:47 <lambdabot> 8
16:00:55 <int-e> > let l = [2,3,4] in and $ zipWith (<) l (tail l)
16:00:57 <lambdabot> True
16:01:16 <Pawer> [1]:[2,3]
16:01:20 <Pawer> > [1]:[2,3]
16:01:21 <lambdabot>  add an instance declaration for (Num [a])
16:01:21 <lambdabot>   In the list element: 3
16:01:23 <monochrom> [1,2,3]
16:01:26 <ihope> > 1:[2,3]
16:01:27 <lambdabot> [1,2,3]
16:01:31 <Pawer> yes yes
16:01:34 <ihope> > [1] ++ [2,3]
16:01:35 <lambdabot> [1,2,3]
16:01:44 <ihope> > ((\(x) -> (((*)(2))(x)))(4))
16:01:45 <lambdabot> 8
16:01:55 <ihope> Go parentheses!
16:02:40 <monochrom> ((<) ((*) 2 4) (+ 3 6))
16:02:40 <sjanssen_> ihope: perhaps you'd rather be in #lisp?
16:02:44 <monochrom> > ((<) ((*) 2 4) (+ 3 6))
16:02:45 <lambdabot>  add an instance declaration for (Num (t -> a))
16:02:49 <ihope> :-)
16:02:52 <monochrom> > ((<) ((*) 2 4) ((+) 3 6))
16:02:52 <lambdabot> True
16:02:56 <monochrom> Go Scheme!
16:03:01 <Pawer> > [1]:[1]
16:03:01 <lambdabot>  add an instance declaration for (Num [a])
16:03:01 <lambdabot>   In the list element: 1
16:03:18 <monochrom> 1:[1] or [1]++[1]
16:03:27 <RyanT5000> why is it that scheme people don't realize that ugliness is bad?
16:03:28 <ihope> > 1++[1]
16:03:29 <lambdabot>  add an instance declaration for (Num [a])
16:03:48 <monochrom> They do.  They have a different sense of ugliness.
16:03:50 <Pawer> tre question is harder
16:03:53 <sjanssen_> RyanT5000: they're all ugly, so they don't notice
16:04:03 <RyanT5000> lol sjanssen_
16:04:22 <RyanT5000> monochrom, you mean "s-expressions are conceptually pretty"?
16:04:27 <monochrom> "1+1+1+1+1 ugly, (+ 1 1 1 1 1) nice!"
16:04:34 <Pawer> > +(3,4)
16:04:34 <lambdabot>  parse error on input `+'
16:04:39 <Pawer> > + (3,4)
16:04:39 <lambdabot>  parse error on input `+'
16:04:44 <Pawer> > (+)(3,4)
16:04:45 <lambdabot>  add an instance declaration for (Num (a, b))
16:04:45 <lambdabot>   In the definition of `ydm': ydm = (+) (3, 4)
16:04:45 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
16:04:46 <RyanT5000> > (+) 3 4
16:04:47 <lambdabot> 7
16:04:49 <Pawer> yes
16:04:56 <ihope> > uncurry (+) (3,4)
16:04:56 <lambdabot> 7
16:05:04 <monochrom> you all beat me to it
16:05:31 <ihope> > sum [3,4]
16:05:32 <lambdabot> 7
16:05:47 <resiak> monochrom: foldl1 (+) [1,1,1,1,1] !
16:06:21 <monochrom> "ugly!  (reduce + '(1 1 1 1 1)) nice!"  XD
16:06:29 <Pawer> > 1 ++ 2
16:06:30 <lambdabot>  add an instance declaration for (Num [a])
16:06:42 <Pawer> > [1] ++ [2]
16:06:43 <lambdabot> [1,2]
16:06:56 <resiak> > 1:2:[]
16:06:57 <lambdabot> [1,2]
16:07:26 <RyanT5000> monochrom: you left out a paren
16:07:29 <Pawer> > (+)(3 4)
16:07:30 <lambdabot>  add an instance declaration for (Num (t -> a))
16:07:33 <Pawer> > (+) (3 4)
16:07:33 <lambdabot>  add an instance declaration for (Num (t -> a))
16:07:34 <RyanT5000> (+ `(1 1 1 1 1))
16:07:41 <RyanT5000> oh man
16:07:51 <RyanT5000> we should add @scheme to lambdabot
16:07:54 <resiak> Pawer: (3 4) means "apply the function `3' to `4'"
16:07:54 <ihope> Does that evaluate to (1 1 1 1 1)?
16:07:55 <RyanT5000> simmilar to @pl
16:08:13 <sjanssen_> RyanT5000: that prefixifies all operators?
16:08:17 <RyanT5000> yeah
16:08:29 <sjanssen_> that should be pretty straightforward, methinks
16:08:29 <monochrom> ha ha ha
16:08:32 <RyanT5000> and adds extraneous parentheses
16:08:35 <Pawer> ~~
16:08:38 <Pawer> ~_~
16:08:49 <monochrom> (_ ~ ~)
16:08:51 <RyanT5000> removes $ and replaces with ( ... )
16:08:51 <Pawer> ()_()
16:09:25 <sjanssen_> @type (.) . (.)
16:09:25 <ihope> @pl a $ b $ c $ d $ e $ f $ g
16:09:26 <lambdabot> forall a b c a1.
16:09:26 <lambdabot>      (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:09:26 <lambdabot> a (b (c (d (e (f g)))))
16:10:07 <monochrom> @type (.) $ (.)
16:10:08 <lambdabot> forall a b c a1.
16:10:08 <lambdabot>      (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
16:10:09 <sjanssen_> @. pl djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:10:09 <lambdabot> f = (.) . (.)
16:10:35 <RyanT5000> hm, could lambdabot detect when it was getting asked multiple things at once, and then prefix the responses with the requesters' names?
16:10:52 <ihope> @pl \x y z -> x z $ y z
16:10:53 <lambdabot> ap
16:10:59 <sjanssen_> how many bots can derive pointfree functions from types?
16:11:10 <Pawer> could lambdabot detect void questions?
16:11:10 <monochrom> one
16:11:51 <sjanssen_> @. id elite only I can do that!
16:11:52 <lambdabot> ON|Y I can d0 T|-|AT!
16:12:18 <Pawer> >
16:12:23 <Pawer> > 
16:12:23 <lambdabot> <stdin>: hGetLine: end of file
16:13:22 <monochrom> you crashed da bot
16:13:23 <Pawer> (ab)
16:13:25 <Pawer> (a b)
16:13:34 <Pawer> means apply a function to b?
16:13:45 <Pawer> what if a is not a function?
16:14:19 <sjanssen_> Pawer: a must be a function or the program won't compile
16:14:43 <Pawer> must bo an errata here
16:14:47 <Pawer> be*
16:15:10 <resiak> Is "errata" not plural?
16:15:22 <RyanT5000> is there a channel on freenode for visual studio?
16:15:32 <RyanT5000> i have to ask someone about my bizarre bug
16:15:37 <Pawer> gnu!!
16:16:25 <monochrom> gnu visual studio
16:16:32 <RyanT5000> ?
16:17:02 * ADEpt has to ask someone about particular bug as well
16:17:17 <monochrom> ok, asking google for gnu visual studio doesn't turn up funny results
16:17:51 <ADEpt> are the Zen masters here, capable of catching a tail that is applied to empty list?
16:18:46 <Pawer> search microsoft sucks
16:18:52 <Pawer> ^^
16:19:10 <RyanT5000> ADEpt, what's your problem? is it related to visual haskell at all?
16:19:25 <ADEpt> it is definitely not
16:19:25 <Pawer> jajajaja
16:19:31 <Pawer> Zen masters
16:19:33 <Pawer> lol
16:19:48 <RyanT5000> hm, what is it? i guess i'm not sure mine is
16:19:56 <dons> ?uptime
16:19:56 <lambdabot> uptime: 17 hours, 27 minutes and 7 seconds
16:20:07 <Pawer> Zen masters eat the head first
16:20:16 <ADEpt> it is related to my bad luck (probably), to the fact that profiling version of GHC has too many CAF's and to the fact that i'm not seenig something obvious
16:20:26 <RyanT5000> oh ok
16:20:29 <ADEpt> lisppaste2: where?
16:20:50 <ADEpt> @lisppaste2
16:20:51 <lambdabot> Unknown command, try @list
16:21:06 <ADEpt> lisppaste2: url?
16:21:06 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:23:57 <Pawer> pokemon: url?
16:24:00 <lisppaste2> ADEpt pasted "Where is the empty list?" at http://paste.lisp.org/display/19407
16:24:09 <Pawer> eivuokko, no url for pokemon?
16:25:11 <Pawer> > tail []
16:25:11 <lambdabot> Add a type signature
16:25:15 <Pawer> > tail [1]
16:25:16 <lambdabot> []
16:25:20 <Pawer> > tail [1]
16:25:21 <lambdabot> []
16:25:31 <Pawer> > tail [[]]
16:25:32 <ADEpt> So, if anybody could take a look and tell me where in the body of "preparse" an empty list could be lurking, i'd be most grateful
16:25:32 <lambdabot> Add a type signature
16:25:37 <Pawer> > tail [[],[]]
16:25:38 <lambdabot> Add a type signature
16:26:19 <Pawer> > tail [[2],[1]]
16:26:20 <lambdabot> [[1]]
16:26:24 <Pawer> > tail [[2],[1],[]]
16:26:25 <lambdabot> [[1],[]]
16:26:38 <Pawer> > tail [[2],[1],[3]]
16:26:39 <lambdabot> [[1],[3]]
16:26:59 <Pawer> > last [[2],[1],[3]]
16:27:00 <lambdabot> [3]
16:27:02 <Pawer> > last [[2],[1],[]]
16:27:03 <lambdabot> []
16:27:06 <Pawer> > last [[],[],[]]
16:27:07 <lambdabot> Add a type signature
16:27:10 <Pawer> ..
16:27:11 <Pawer> ...
16:27:27 <Pawer> who uses that...
16:28:17 <resiak> > tail ([] :: [Int])
16:28:18 <lambdabot> Exception: Prelude.tail: empty list
16:28:50 <resiak> Pawer: You know you can use ghci or hugs or something to try evaluating random chunks of Haskell?
16:29:04 <Pawer> yes sorry
16:29:19 <Pawer> i expected an answeh
16:29:22 <Pawer> i expected an answer
16:29:34 <Pawer> well not
16:29:43 <Pawer> tris time
16:30:06 * resiak mutters something about using newlines instead of punctuation
16:30:48 <Pawer> function composition opehatoh is tre dot?
16:31:23 <Pseudonym> Yes.
16:31:31 <Pawer> trx
16:31:38 <Pawer> thx
16:31:57 <Pseudonym> How do you consistently swap "h" and "r"/
16:32:11 <Pseudonym> I realise everyone has their own ideosyncratic typos.
16:32:12 <mauke> tr/hr/rh/
16:32:20 <Pawer> i used my 
16:32:20 <mauke> oh, haskell
16:32:24 <Pawer> dvorak
16:32:29 <Pseudonym> Ah, that makes sense.
16:32:35 <Pawer> keyboard layout
16:32:48 <Pawer> yesterday it entered in X11
16:33:06 <Pawer> as
16:33:12 <Pawer> es(dvorak)
16:33:21 <Pawer> but in spaniisr dvorak
16:33:30 <Pawer>  r and h are swapped
16:33:40 <Pawer> i used englissh vehsion
16:33:50 <Pawer> im trying to change it
16:33:56 <Pseudonym> Smartest thing I ever did was make two shell aliases: asdf swaps to dvorak and aoeu swaps to qwerty.
16:33:59 <Pawer> but i cant change X11
16:34:09 <Pseudonym> Never been stuck since.
16:34:14 <mauke> haha, awesome
16:35:10 <Pawer> i changed file in /etc/X11/xkb/symbols/pc/es
16:35:23 <Pawer> but layout ras not changed
16:35:31 <Pawer> i hebooted X11
16:35:37 <resiak> Pseudonym: I have the same aliases :)
16:41:16 <Pawer> bye people
16:41:20 <Pawer> i go to sleep
16:47:46 <sjanssen_> @. elite keal
16:47:46 <lambdabot> \/\/Ill IT R37URN [] IF /\/\4P Gi\/3$ fPu iNfInite |I5t?
17:28:36 <RyanT5000> has anyone else here used visual haskell?
17:29:35 <Pseudonym> Nope.  I tossed it when I found you needed to be an administrator.
17:29:50 <Pseudonym> Any non-service program that needs admin privileges gets the toss, IMO.
17:30:04 <Pseudonym> (You don't even need to be an administrator to install Visual Studio!)
17:30:28 <RyanT5000> well in theory i agree with that principle
17:30:42 <RyanT5000> but given that so much stuff on windows needs to be admin anyway
17:30:45 <sjanssen_> Pseudonym: admin priveleges to use, not just install?
17:30:52 <Pseudonym> To install.
17:31:00 <RyanT5000> also, why should services need admin to install?
17:31:09 <Pseudonym> Well, system services.
18:15:44 <sethk> what's the command that says "nick was last heard" or something like that?
18:16:53 <sjanssen_> @seen sethk
18:16:53 <lambdabot> sethk is in #haskell-blah and #haskell. I last heard sethk speak 1 minute and 9 seconds ago.
18:17:07 <sethk> sjanssen, thanks
18:17:10 <sethk> @seen dons
18:17:10 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 57 minutes and 14 seconds ago.
18:57:14 <Korollary> hmm hazakura
19:44:59 <seba> hi... how I can dispay a \n in haskell?
19:46:21 <sjanssen_> seba: "\n" should work
19:46:49 <seba> ok... i will try
19:47:05 <sjanssen_> or if you want to just print a newline to the screen: putStrLn ""
19:47:43 * araujo looks around
19:48:47 <araujo> seba, just remenber it doesn't work with print :-)
19:48:48 <sjanssen_> @id /me doesn't like to be stared at
19:48:49 * lambdabot doesn't like to be stared at
19:48:58 <araujo> :-)
19:49:27 <seba> it works, thanks!
19:49:43 <araujo> @yarr!
19:49:44 <lambdabot> Keelhaul the swabs!
19:49:51 <araujo> hah
19:50:00 <seba> another little question... it is posible to print a char without ' '
19:50:08 <dons> clever sjanssen_ 
19:50:21 <seba> when i do show 'a' it prints 'a'
19:50:57 <sjanssen_> seba: you're working from a ghci (or hugs) prompt?
19:51:25 <sjanssen_> show displays things as you would write them inside a Haskell program
19:51:28 <seba> yes
19:51:49 <sjanssen_> you use different output functions in a real program
19:51:53 <seba> i am running a module that show chars
19:52:08 <sjanssen_> putChar will print one character to the screen
19:52:09 <Saulzar> @hoogle putChar
19:52:09 <lambdabot> Prelude.putChar :: Char -> IO ()
19:52:09 <lambdabot> IO.hPutChar :: Handle -> Char -> IO ()
19:52:36 <seba> thank you very much!
20:47:37 * SamB wonders what zsh has against unicode
20:48:54 <sjanssen_> SamB: laziness?
20:49:33 <SamB> sjanssen: I dunno...
20:50:11 <SamB> If I just paste some in, it shows up garbled...
20:50:21 <SamB> if I paste it into cat, though, it looks fine...
20:50:45 <SamB> or ghci
20:52:58 * SamB tries out „Ç´„Çø„Ç´„Éä
20:53:33 * dons studies the garbled bytes in his irssi buffer
20:54:02 <SamB> Plan9 had a handle on this stuff, too!
20:55:38 * SamB tries installing a newer version of zsh
20:56:02 <SamB> hmm, bash does not have this problem
20:57:53 <jfoutz> i have a question... i've poked through the docs, and i think the answer is no, but i'd like an opinion from a real haskell person
20:58:22 <jfoutz> is there any way to relate two formal parameters in a pattern match without a guard?
20:58:44 <dons> nested case?
20:59:00 <jfoutz> like... i have a function foo, that takes two arguments. if those two arguments are the same i'd like to say something like
20:59:08 <jfoutz> foo x x = "same"
20:59:11 <SamB> dons: hmm, that probably doesn't count...
20:59:14 <dons> > case (1,2) of (x,y) -> if x ==y then True else False
20:59:14 <lambdabot> False
20:59:28 <dons> jfoutz: no, that doesn't work. 
20:59:41 <dons> variable binding tdoesn't generate magic equality testing code :)
20:59:53 <jfoutz> well... it does a little.
21:00:04 <dons> you should just write: foo x y | x == y
21:00:08 <dons> unless its numbers, of course.
21:00:11 <jfoutz> foo 0 0 = "same" foo 1 1 = "same"
21:00:18 <dons> and k patterns are magic and disliked
21:00:22 <SamB> > let foo x x = "same" in foo 1 1
21:00:23 <lambdabot>   Conflicting definitions for `x'
21:00:23 <lambdabot>   In the definition of `foo'
21:00:34 <dons> you can always have: foo [] [] = True
21:00:36 <dons> or other structures
21:01:07 <dons> they have to be some how structurally equivalent.
21:01:16 <Cale> k patterns aren't *that* evil, it's n+k patterns where you're starting to push it :)
21:02:03 <jfoutz> well, thanks for the help.
21:02:15 <dons> yeah, k patterns are as if we had a data Integer = ...  1 | 2 | 3 ... so they make sense along the lines of [] of (x:xs)
21:02:17 <jfoutz> what's a k pattern
21:02:19 <jfoutz> ?
21:02:26 <dons> f 1
21:02:33 <Cale> jfoutz: matching against a number
21:02:34 <jfoutz> oh, i see.
21:04:52 <jfoutz> it's not prolog on the left side... it's not even a regex. it's like a lisp destructure. i'll have to remember that.
21:05:51 <dons> yes. recursion and patterns , structural induction for ever!
21:06:14 * Korollary shoots dons with a tranquilizer gun
21:07:12 <dons> sleepy... so sleepy.... induction*garble*garble* mrmmm hrm.... sleep 
21:08:01 * Korollary tattoes "I heart turbopascal" on dons' arm
21:08:56 <jfoutz> ok. well, if i wanted to match, say, 5 things that have both rank and suit... :) is there some clever shorthand, or do i really have to say : flush r1 s1 r2 s2 ... r5 s5 = if s1 == s2 then if s2 == s3 then if .... True else False else False ... else False?
21:09:18 <dons> grmm.. what the deus! ...*grumble*mumble.
21:09:38 <dons> jfoutz: && ?
21:09:48 <Korollary> jfoutz: a case expression may look neater
21:10:55 <dons> let f r1 s1 r2 s2 | r1 == r2 && s1 == s2 && x == r4
21:11:02 <SamB> Korollary: what is wrong with turbopascal?
21:11:10 <dons> or, map (==) over the pairs?
21:11:31 <Korollary> SamB: no comment.
21:12:00 <dons> > let f ls = all (map (==)) in f [(2,2), (1,1), (4,4)]
21:12:01 <lambdabot> Couldn't match `Bool' against `[b]'
21:12:09 <dons> > let f ls = all (map (==) ls ) in f [(2,2), (1,1), (4,4)]
21:12:10 <lambdabot> Couldn't match `[b]' against `t -> t1'
21:12:19 <jfoutz> dons, the cleanest i could come up with was a "same" function taking a fn and a list at least 1 element long
21:12:34 <dons> > let f ls = all (==) ls in f [(2,2), (1,1), (4,4)]
21:12:34 <SamB> I mean, for a Pascal, I think it is probably pretty good!
21:12:35 <lambdabot> Couldn't match `Bool' against `t -> t1'
21:12:38 <jfoutz> curry the first element with the fn, then apply that to every other element of the list
21:13:00 <jfoutz> but a pattern match just made everything seem so much cooler.
21:13:09 <dons> > let f ls = all (\(a,b) -> a == b) ls in f [(2,2), (1,1), (4,4)]
21:13:10 <lambdabot> True
21:13:18 <dons> ?pl (\(a,b) -> a == b)
21:13:18 <lambdabot> uncurry (==)
21:13:35 <jfoutz> there are few enough variations to make enumeration seem nice, but so many that it's tedious.
21:13:40 <dons> > let f = all . uncurry (==) in f [(2,2), (1,1), (4,4)]
21:13:41 <lambdabot> Couldn't match `a -> Bool' against `Bool'
21:13:48 <dons> not by day today
21:13:57 <Korollary> indeed
21:14:05 <dons> too much fps hacking.
21:14:08 <dons> v0.5 is tagged!!
21:14:10 <Korollary> it's the tranquilizer
21:14:13 <jfoutz> ok. well thank you. i appreciate it. 
21:14:16 <jfoutz> g'night
21:15:02 <dons> > let f = all (uncurry (==)) in f [(2,2), (1,1), (4,4)]
21:15:03 <lambdabot> True
21:15:06 <dons> I always go for the . too early
21:15:19 <dons> ?pl all (uncurry (==))
21:15:19 <lambdabot> all (uncurry (==))
21:15:29 <dons> but I want .'s!!
21:17:03 <dons> oh good good: 
21:17:04 <dons>                       Code  Comments
21:17:04 <dons> ByteString.hs          1124    873
21:17:04 <dons> Char8.hs                441    563
21:17:07 <dons> TOTAL:                 1565   1436
21:17:26 <dons> > 1565 / 1436
21:17:27 <lambdabot> 1.08983286908078
21:17:37 <dons> sok
21:17:49 <Korollary> your comments are overcoded
21:18:14 <SamB> ???
21:18:15 <lambdabot> Maybe you meant: . id pl wn
21:18:16 <dons> seems a bit that way. i should work harder on my comments.
21:19:12 <dons> 1.08 code lines for every 1 line of comments. for shame!
21:21:31 <SamB> „Åí„Çì„Åç „Åß„ÅïÔºü
21:27:40 <monochrom> I can see your Japanese, SamB. 
21:28:13 <Korollary> Is there a wikipage that explains the common extensions to H98?
21:29:05 <dons> hmm. the type extensions page of the ghc manual?
21:29:18 <monochrom> Some of them are not common :)
21:30:34 <Korollary> dons: right. I meant in a tutorial style, tho.
21:33:52 <SamB> monochrom: that one was supposed to be "genki des?"
21:35:50 <dons> Korollary: not that I know of. only via the research papers for those extensions
21:35:59 <dons> ?wiki Research_papers
21:35:59 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers
21:36:52 * SamB wonders if he can type those star things with SCIM
21:38:17 <monochrom> This is my Chinese name. ÈªéË£ïÊòå
21:38:34 <monochrom> I'm also using SCIM ^^
21:59:36 <RyanT5000> so are there significant differences between Haskell and Clean?
22:00:01 <RyanT5000> i'm browsing down their tutorial, and so far i've seen like 5 differences, and they've all been syntactic
22:01:39 <monochrom> They use different theories for imperative programming.
22:03:14 <RyanT5000> oh, meaning not monads?
22:05:15 <sjanssen> RyanT5000: yes, uniqueness types
22:05:29 <sjanssen> don't ask me to define them, because I can't
22:06:33 <dons> hmm. I wonder if there's some connection to the unique type argument in ST
22:08:11 <RyanT5000> is the clean IDE any good?
22:08:55 <RyanT5000> and if so, why don't we steal it?
22:09:06 <dons> its closed source, isn't it?
22:09:16 <RyanT5000> woah really? i didn't even think to check
22:09:28 <dons> at least during the 90s you couldn't get the src.
22:09:48 <dons> not sure if they've changed that policy
22:10:08 <RyanT5000> that would be totally lame
22:11:22 <RyanT5000> mkay
22:11:27 <RyanT5000> so that's why they suck
22:11:32 <RyanT5000> just had to clear that up
22:11:39 <RyanT5000> it says it's under the LGPL, though
22:11:42 <RyanT5000> however i can't find source
22:11:48 * RyanT5000 is confused
22:12:00 <dons> there are significant differences in that we have monads and 100x more researchers working on haskell.
22:12:08 <RyanT5000> yeah
22:12:28 <RyanT5000> my only idea was that they seem to have a well-developed IDE, which, if possible, we should steal
22:12:45 <dons> probably a lot due to the fact haskell was born as an open source langauge in the late 80s in response to closed fp langauges.
22:12:56 <RyanT5000> right
22:13:02 <sethk> dons, did you see my note earlier?
22:13:08 <RyanT5000> well we definitely need a good IDE
22:13:11 <RyanT5000> with arrows support!
22:13:21 <dons> sethk, might have missed that.
22:13:42 <RyanT5000> that'd be really hot if we could do wiring diagrams 100% graphically
22:13:46 <sethk> dons, We pushed the 1000th machine through the software today
22:14:09 <dons> ah, yes! I saw that. well done!
22:14:37 <sethk> only a couple of very minor bugs reported thus far
22:14:57 <dons> that's amazing, if it wasn't haskell you're using :)
22:15:16 <sethk> repeatable behavior, amazing  :)
22:15:26 <RyanT5000> oh wait! i think i might have found the source!
22:16:06 <sjanssen> sethk: you have to use a monad if you want non-determinism ;-)
22:16:20 <sethk> sjanssen, I can use FFI also :)
22:16:49 <dons> yeah, a segfault monad would be cool.
22:17:14 <dons> it would be a monad transformer on top of the NonDet monad
22:17:33 <dons> that triggerred non-determinisitc unsafeCoerce# calls, randomly segfaulting the code
22:17:43 <dons> that way we could properly emulate C
22:17:47 <dons> and other imperative styles
22:19:45 <dons> who's with me? Cale? with NonDet we could write the SegfaultLikeYouMeanIt monad in only a few dozen lines of code :)
22:20:04 <dons> actually, that would make a good April 1 monad :)
22:20:25 <sjanssen> dons: segfault is not enough
22:20:32 <Saulzar> Could be an addition to Haskerl...
22:20:46 <sjanssen> I want to accidentally screw up my stack frame, so I jump to random locations
22:20:47 <Saulzar> I read that thread yesterday, very amusing :)
22:21:19 <dons> sjanssen: ah yes. that's a good one. hmm. so it would need to randomly randomise the stack on top of a callcc monad
22:21:55 <dons> so throws to the stack would get randomnly rewritten to other places in the stack
22:22:35 <dons> try coding under that kind of pressure. we'd need to develop special tools -- i call them "debuggers" -- to handle this 
22:22:54 <sethk> dons, it's true, I haven't missed not having a debugger
22:23:54 <Saulzar> You can have a program which runs unsafe haskell and catches the errors, making it reliable by running each program n times
22:24:24 <Saulzar> Thus with all the abstraction and segfaults it will be only 10000% slower than equivalent C
22:25:16 <dons> Saulzar: ah, very true. curses! 
22:25:33 <sethk> The code I'm running is nowhere noticably slower than the c code it replaces
22:25:40 <dons> competing with C is just so hard.
22:25:57 <dons> all those segfaults to get right...
22:26:41 <Saulzar> We can offer the approach to the wine project - they claim to emulate windows + bugs, clearly they haven't found the optimum solution yet :)
22:27:16 <RyanT5000> i forget; is there any commercially important software written in haskell?
22:27:17 <dons> yes, I think this BUG monad would be funn :) must code this up 
22:27:30 <RyanT5000> something we can point to and say "this company wouldn't exist without this"
22:27:39 <dons> RyanT5000: check galois.com
22:27:45 <dons> all they write is Haskell code.
22:27:52 <RyanT5000> ah ok
22:27:58 <RyanT5000> i've heard of them through this channel before
22:28:13 <dons> companies in the high assurance software game.
22:28:25 <sjanssen> dons: I also want to be able to write silly code like: ((void (*)()) "")();
22:28:31 <sjanssen> C is so fun
22:28:39 <Saulzar> With pointer arithmetic please
22:28:47 <Saulzar> IORefs are just not good enough
22:29:06 <dons> I use ptr arith in my daily haskell :) `plusPtr` is lots of fun.
22:29:11 <Saulzar> Hmm, I suppose you can actually use pointers :)
22:29:12 <dons> ?wiki Wc
22:29:12 <lambdabot> http://www.haskell.org/haskellwiki/Wc
22:29:22 <dons> has a few pointer arith examples
22:30:37 <Saulzar> Hehe, perhaps you can include some Segfaults with the FPS stuff to show that Haskell is up to scratch then.
22:30:50 <dons> hehe. /me gets scared.
22:31:18 <dons> Prelude GHC.Base GHC.Ptr> :t (unsafeCoerce# "haskell") :: () -> Ptr a
22:31:19 <dons> (unsafeCoerce# "haskell") :: () -> Ptr a :: forall a. () -> Ptr a
22:31:34 <dons> Prelude GHC.Base GHC.Ptr> ((unsafeCoerce# "haskell") :: () -> Ptr a)()
22:31:34 <dons> 0x00010001
22:31:37 <dons> Haskell rocks!@
22:32:00 <dons> > ord 'h'
22:32:01 <lambdabot> 104
22:32:37 <dons> > printf "%x" (ord 'h') :: String
22:32:38 <lambdabot> "68"
22:33:10 <dons> Prelude GHC.Base GHC.Ptr> ((unsafeCoerce# "") :: () -> Ptr a)()
22:33:10 <dons> zsh: segmentation fault (core dumped)  ghci -v0
22:33:13 <dons> :D
22:34:49 <Saulzar> Hmm, why does coercing "haskell" to () -> Ptr a  work?
22:35:18 <sjanssen> Saulzar: did you see the nasty "unsafeCoerce#"?
22:38:32 <Saulzar> Yeah, I'm just wondering why treating the list as a function like that gives the first element
22:40:16 <dons> it all depends on the runtime representation.
22:40:25 <dons> you have to study the C output to ever reason about what happens
22:40:41 <dons> i..e it's just like C -- you need to think about the machine representation all the time
22:42:04 <dons> so, firstly:
22:42:06 <dons>     c1Ar_str:
22:42:06 <dons>         I8[] "haskell"
22:43:03 <dons> then the address of the start of the string gets pushed onto the stack.
22:43:32 <dons> and () is pushed on to the stack
22:43:43 <dons> then 'apply' is called with the ptr to the haskell string, and ()
22:43:46 <dons> and somehow that works.
22:43:58 <Saulzar> Hehe.
22:44:23 <dons> 'works' in the sense that nothing is outside of bounds, and some value gets returned
22:44:49 <dons> unsafeCoerce# essentially lets you run arbitrary program code on other arbitrary data, and sometimes this works 
22:45:00 <dons> mostly it doesn't
22:45:19 <RyanT5000> lol
22:46:11 <dons> to work out why, the code for Apply is in Apply.cmm in the rts.
22:56:25 <RyanT5000> quick straw poll: how many screens do you use?
22:56:29 <RyanT5000> <- 2
22:56:37 <RyanT5000> also, crt/lcd
22:57:21 <RyanT5000> i feel like i should buy more LCDs for writing code.... but then i realize i don't have any money
22:57:49 <sjanssen> I have two screens, but I rarely use the other
22:57:55 <dons> these days i just have one laptop screen with ion running single, full screen xterms
22:58:06 <dons> rxvt terms, i should say :}
22:58:13 <Saulzar> I have one crt...
22:58:15 <Korollary> at work I have to lcds, but I only use one.
22:58:42 <RyanT5000> my main is a laptop LCD, my secondary is a CRT... and i find that i can't stand using the CRT for anything useful
22:58:50 <dons> i think two identical lcd screens jammed against each other works well in a desk situation.
22:59:00 <Korollary> your CRT must be weird
22:59:01 <RyanT5000> i chuck AIM windows on it and stuff, but i like my code tiny, and therefore i can't read it on the CRT
22:59:42 <RyanT5000> yeah my crt probably is weird
22:59:47 <RyanT5000> it's a crappy gateway 17 inch
22:59:49 <Korollary> dons: I thought it would work, too, but the problem is that a window has to be in one lcd at a time, which means the center (where the lcds join) is useless.
23:00:10 <dons> once i decided my terminals should fill the entire screen, i was able to increase the font size to 18 pt, and now i find i don't squint when i'm tired nearly so often.
23:00:21 <dons> so using X as a console is good, in summary.
23:00:44 <Korollary> I use only one terminal with screen
23:00:53 <Korollary> gnu screen I mean
23:00:59 <dons> Korollary: hmm, i'm sure i've used X wheere windows overlap screens
23:01:01 <shapr> I use gnome-temrinal and at least two terminal windows.
23:01:18 <shapr> Sometimes five
23:01:25 <Korollary> gnu screen makes multiple xterms pretty useless
23:01:49 <shapr> I sometimes end up with five different root prompts in different parts of the world.
23:02:11 <dons> Korollary: what benefit do you get runnign screen locally?
23:02:20 <dons> i use it on remote machines only.
23:02:27 <shapr> Yeah, me too.
23:02:28 <Korollary> dons: hands off the mouse. everything with the kb.
23:02:59 <dons> oh. like you get with ion.
23:03:11 <RyanT5000> here's a question: could one make a window manager that naturally uses only the keyboard?
23:03:17 <RyanT5000> (and doesn't suck)
23:03:18 <dons> right screen is kind of the old school way of doing what ion does in X.
23:03:26 <Korollary> RyanT5000: ion does that I think
23:03:32 <dons> RyanT5000: yes, ion :)
23:03:36 <dons> ?google tuomov ion
23:03:37 <RyanT5000> k
23:03:39 <RyanT5000> :)
23:03:39 <lambdabot> http://modeemi.fi/~tuomov/ion/
23:03:42 <dons> its really nice. lots of hackers here use it.
23:04:22 <dons> basically if feels like being in an editor, to split screens and navigate windows. that's the basic concept
23:05:02 * RyanT5000 has no experience with such editors :(
23:05:09 <RyanT5000> i hate being a child of windows
23:05:26 <dons> this is a common feeling
23:05:28 <Korollary> you can run emacs/vi on windows
23:05:30 <dons> there's a cure, luckily!
23:05:33 <RyanT5000> i'm going to switch the moment i ship this game
23:06:13 * Saulzar uses linux but also keeps away from such editors...
23:06:46 <shapr> hiya SubStack 
23:06:47 <SubStack> text editor battles, this must be a good chan
23:06:51 <SubStack> 'lo shapr 
23:06:57 <shapr> Learning Haskell?
23:07:00 <SubStack> yup
23:07:10 <shapr> Got any questions?
23:07:14 <SubStack> nope
23:07:17 <Korollary> @where yi
23:07:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
23:09:20 <shapr> Ya know, I was planning to move back to the US after the DMCA got better. This new proposal just makes it worse.
23:09:44 <SubStack> there's a new proposal? christ
23:09:45 <Korollary> lies
23:09:46 <mwc> shapr, good idea
23:09:55 <SubStack> let's all move to sweden
23:09:59 <mwc> I should plan to move somewhere safe, maybe Belize
23:10:09 <shapr> SubStack: Been there, doing that.
23:10:17 <Korollary> I moved six months ago. I'm not moving anywhere for a while.
23:10:18 <RyanT5000> yeah DMCA is in large part the reason i'm going to law school
23:10:23 <RyanT5000> (i live in the US)
23:10:37 <RyanT5000> half the stuff i want to make breaks DMCA or other stuff
23:10:44 <SubStack> fight the powah
23:10:50 <mwc> RyanT5000, terrorist.
23:11:01 <Korollary> do you think there are fbi agents in this channel?
23:11:01 <RyanT5000> lol
23:11:07 * SubStack suicide codes mwc.
23:11:17 <sjanssen> mwc: I concur.  Terrorists hate our copyrights.
23:11:29 <sjanssen> thus, we must defend them
23:11:30 <mwc> Haskell, preferred by 9/11 cyberterrorists worldwide
23:11:48 <mwc> sjanssen, it all goes back to that Sonny Bono copyright crap
23:11:51 <SubStack> sjanssen, and pedophiles
23:11:59 * mwc must go back in time and destroy Disney
23:12:13 <RyanT5000> ooooh, mwc, good idea
23:12:15 <SubStack> please, think of the childerine
23:12:27 <sjanssen> SubStack: pedophiles and terrorists are one and the same
23:12:36 <RyanT5000> i do sort of wonder why the terrorists haven't struck digitally
23:12:43 <RyanT5000> i've heard that the power grid has no security to speak of
23:12:44 <Korollary> let's write a freenet client in haskell for the pedophiles
23:13:14 <RyanT5000> it's almost entirely based on security-through-obscurity
23:13:42 <mwc> RyanT5000, it'd be much easier to place a thermite bomb on a major distribution station for a city
23:13:56 <mwc> I have the required chemicals in my trunk
23:14:13 <RyanT5000> i have the required chemicals 3 feet behind me
23:14:15 <Korollary> Submit your movie plot threats to Schneier's blog
23:14:24 <shapr> Yeah, rust and aluminum. How hard is that?
23:14:25 <RyanT5000> albeit not enough of them
23:14:28 <mwc> (2.959 parts Iron (III) Oxide to 1 part aluminum oxide, by mass)
23:14:36 <mwc> shapr, the hard part is getting the anhydrate
23:14:51 <shapr> Fuel oxidizer mixtures are so elegant.
23:15:04 <shapr> Which one is III? Fe2O3 or Fe3O2?
23:15:05 <RyanT5000> i actually have 600 mesh aluminum powder and magnetite sitting behind me >.>
23:15:09 <SubStack> or you could drop pornography from the sky
23:15:21 <RyanT5000> Fe2O3 or Fe3O4 you mean, shapr?
23:15:22 <SubStack> conservative christians will die
23:15:31 <RyanT5000> athough i'm not sure either way
23:15:38 <RyanT5000> you can make thermite with either, though
23:15:56 <mwc> shapr, Fe 2 O 3 is iron 3 oxide
23:15:58 <RyanT5000> the boiling point of the aluminum is what confines the temperature anyway
23:16:03 <shapr> It's been too long since I did that sort of thing...
23:16:25 <shapr> ammonium triiodine is fun.
23:16:45 <RyanT5000> another question: how much would you pay for a USB/Firewire harddrive enclosure that has a thermite charge in it and sufficient thermal padding to make it safe to operate on your desk?
23:17:01 <shapr> fifty bucks?
23:17:04 <RyanT5000> assume you have data, the security of which you care about very deeply
23:17:15 <RyanT5000> shapr: you can't buy a non-thermite USB/firewire enclosure for that
23:17:25 <RyanT5000> well, maybe just under that
23:17:29 <RyanT5000> :P
23:17:44 <shapr> I just want a thermite charge and a usb plug that can activate the charge.
23:17:59 <SubStack> you could setup a tripwire on the device
23:18:08 <RyanT5000> so you'd rather it be software-activatable?
23:18:12 <SubStack> if you access a certain file, it kills the data
23:18:15 <SubStack> interesting idea
23:18:20 <RyanT5000> (i'm actually thinking about making this product)
23:18:36 <RyanT5000> (making it legal might be a challenge though)
23:18:54 <RyanT5000> (e.g.: i'm not sure if anyone will ship thermite)
23:18:55 <SubStack> sell it as a firework
23:18:55 <shapr> Why would it be illegal?
23:19:10 <RyanT5000> well fireworks aren't legal in all states
23:19:21 <shapr> Sell it as a firestarter.
23:19:40 <RyanT5000> yeah, but there are many layers on which you have to be thinking like that
23:19:50 <shapr> Ya know those rolled paper 'logs' soaked in something.
23:20:04 <RyanT5000> e.g.: what if it does end up burning someone's house to the ground and killing all the residents
23:20:14 <RyanT5000> you better have a good disclaimer
23:20:24 <RyanT5000> i'm not saying it's insurmountable, just that i wouldn't want to have screwed up that part
23:20:27 <SubStack> damnit, all the cool OS stuff is happening in the portland area
23:20:31 <SubStack> wish I still lived there
23:21:02 <shapr> RyanT5000: You could just sell the plans.
23:21:20 <RyanT5000> shapr: interesting idea
23:21:26 <RyanT5000> that'd be way easier than making it too
23:21:33 <RyanT5000> although i'd stiill have to prototype it and stuff
23:22:00 <shapr> My long term idea is to come up with some sort of plans where people can build a computer from scratch in their homes.
23:22:20 <SubStack> household items?
23:22:23 <shapr> yup
23:22:29 <Korollary> watch McGyver too much eh
23:22:32 <SubStack> kick-ass
23:22:33 <RyanT5000> define "computer"
23:22:40 <shapr> I think that will circumvent many of the stupid laws and encourage innovation.
23:23:03 <shapr> RyanT5000: I want at least 25MHz and 32mb of ram, and I want it to be relatively small.
23:23:09 <SubStack> or you could patent every conceivable idea
23:23:21 <SubStack> and hold the US hostage until your demands were met
23:23:25 <Korollary> you cant make a 25Mhz cpu from household items
23:23:26 <SubStack> every book too
23:23:31 <shapr> Korollary: wanna bet?
23:23:35 <RyanT5000> shapr: that's a really intriguing idea, but i have to wonder how you would make a chip fab
23:23:43 <shapr> Nah, don't use silicon
23:23:47 <RyanT5000> ?
23:23:53 <mahogny> well. it isn't hard to build a computer from scratch. and you don't need a pentium for good performance. just take a few SH5's and run in parallel
23:24:10 <RyanT5000> take apart a microwave?
23:24:12 <shapr> I think it'll be easier to use an optical setup.
23:24:16 <SubStack> home microprocessor etching kit?
23:24:21 <mahogny> lol
23:24:27 <shapr> But I've been thinking about some magnetic processing alternatives.
23:24:32 <RyanT5000> hm
23:24:56 <shapr> Simple softcore electrical transformers operate by switching the magnetic flux really fast.
23:25:13 <shapr> Can I setup multiple coils so that the flux patterns do processing?
23:25:19 <RyanT5000> not "really" fast
23:25:22 <mwc> I was looking at x86 assembly recently
23:25:29 <mwc> "Where the registers at?
23:25:43 <RyanT5000> mwc: we have 8
23:25:47 <olliej> mwc: hehe
23:25:55 <RyanT5000> :)
23:25:55 <shapr> Photorefractive crystals change their refractive index after absorbing a certain amount of photons, how can I turn that into a transistor?
23:25:57 <olliej> mwc: the 64-bit version do actually have some
23:25:57 <mahogny> shapr, depends probably on what you mean by computation. heck. there are computers based on the pattern formations from nonlinear reactions when you mix chemicals
23:26:10 <shapr> mahogny: Right, exactly.
23:26:50 <mwc> olliej, 16 GPRs, don't they?
23:26:51 <shapr> I just want to find a sweet spot that lets me build a ~25MHz computer at home from household items. I'd be fine with Edmund Scientific and Hardware Store items to start with.
23:27:00 <olliej> mwc: yeah
23:27:15 <mwc> shapr, you know, that's something I've been wanting to do for a while
23:27:24 <mahogny> anyhow. I think you are pretty screwed to get reasonable performance without a real cpu. even if it is a tiny one
23:27:31 <mwc> I can get Xscales reasonably priced
23:28:06 <mwc> I just don't know how to build it. I've seen some stuff on making surface-mount boards in your oven, but don't know if I want to try it
23:28:10 <SubStack> 25 MHz might be overkill anyways
23:28:34 <SubStack> 20 MHz was enough to run windows 3.1
23:28:59 <SubStack> albeit quite a bit more slowly than if you hit the turbo button and bumped it up to 40
23:29:05 <dons> yaya. fps is actually really just H98 + FFI + cpp.  :) I'm running it in hugs :)
23:29:33 <shapr> dons: still fast?
23:30:16 <dons> hard to say. i can't run my benchmarks yet. they're not h98 
23:30:31 <olliej> fps?
23:30:53 <dons> ?where fps
23:30:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
23:31:04 <shapr> mahogny: Why do you think that? Any hard science reasons I can use to refine my design?
23:31:16 <olliej> dons: ah :)
23:32:02 <mwc> shapr, the hard part is that it's too complex. People can do difficult steps a few times, but it's impossible to do easy stuff millions of times.
23:32:07 <mahogny> shapr, I think it because most setups I have seen so far require laboratory precision and are really messy to work with. 
23:32:20 <mwc> Maybe we can come up with some sort of optical-etching procedure for silicon
23:32:47 <mwc> then you can transfer the CPU to slide film and etch
23:33:12 <mahogny> shapr, however, I don't really see the reason for this kind of innovation, when we barely even can use the silicon we have
23:33:32 <shapr> Well, "we" don't have the silicon, Intel et al has the silicon.
23:33:49 <RyanT5000> i wonder if you could make a laser-printer for silicon
23:33:53 <mwc> yeah, what you're looking for is a sand-to-linux solution for the kitchen?
23:33:57 <shapr> The closest we get to having silicon is FPGAs, and those are still closed specs.
23:34:02 <shapr> mwc: Pretty much.
23:34:06 <RyanT5000> not as in photoelectric
23:34:11 <RyanT5000> as in actually etch it with a laser
23:34:17 <mahogny> shapr, you don't need the precision intel has to produce faster CPUs
23:34:19 <shapr> mwc: Heck I'll be happy with 1MHz
23:34:32 <shapr> mahogny: True, I just need to be able to produce my own CPUs.
23:34:43 <mahogny> shapr, there are manufacturers you can ask in that case
23:34:50 <mwc> Reminds me of Cryptonomicon (Neal Stephens). There's a character who wnats to put designs for a machine gun anybody can build in their garage onto the internet to prevent the government from ever trying to usurp democracy
23:35:02 <mwc> this is the digital equivalent to my mind
23:35:04 <shapr> Yup
23:35:24 <shapr> mahogny: I want to be able to produce a CPU myself.
23:35:29 <mahogny> shapr, or just write us a good free hardware simulator in haskell. I'd love a compiler for VHDL, or even better, a mix between VHDL and Lava :)
23:36:12 <mwc> it seems to me that if you want to accomplish the objective, you can't rely on components like FPGA's that could be controlled.
23:36:27 <mwc> I'm thinking this is a good insurance for civilization in the face of an RMS "Right to Read" scenario
23:36:41 <shapr> I think VHDL et al are part of the problem.
23:36:51 <mahogny> shapr, how so?
23:37:25 <shapr> Because I want to experiment at a much lower level.
23:37:40 <shapr> A few months ago I wanted to write Conway's game of life as a self modifying FPGA pattern.
23:37:43 <RyanT5000> hm, someone should come up with a minimal tech tree for the "information age"
23:37:48 <shapr> But you can't get specs on FPGAs.
23:38:02 <RyanT5000> put that in terms that could have been understood 300 years ago
23:38:15 <RyanT5000> as protection against a dark age
23:38:20 <mahogny> from a computational point of view, I doubt you have much to gain (except quantum computing, but not even that will improve much)
23:39:07 <shapr> But who knows how much we have to gain from users being able to build CPUs? Right now very few people can actually try out new processor ideas.
23:39:29 <shapr> I'd love to build my quilt CPU idea and try it out, but I can't afford it.
23:39:34 <mahogny> get us a free compiler and virtual testbench, and you can at least start off with somethi
23:39:36 <mahogny> ng
23:40:10 <RyanT5000> you should make a computer system that is based on 5-cm cubed bricks
23:40:15 <mahogny> but fact: building a good cpu is not easy, and it would be a really serious hobby. I doubt many would go into it, even if they could
23:40:32 <shapr> mahogny: The same could be said about OS, and look at Linux.
23:40:34 <RyanT5000> with data, power, and cooling couplings on each edge
23:40:47 <dons> shapr, ah , good the QC tests run in hugs. lets see how long this takes..
23:40:55 <RyanT5000> then you have tiles that hook up to the outer-most bricks and provide IO (of data, power, and cooling)
23:41:07 <shapr> mahogny: I'd go into building CPUs for fun, no matter how hard or easy.
23:41:13 <shapr> RyanT5000: Yeah, I like tiled CPUs
23:41:20 <RyanT5000> i believe IBM was working on something like that, but it was with whole computers
23:41:24 <dons> ndm, ping...
23:41:36 <mahogny> shapr, yeah. a bad OS, and it only exists because lots and lots of people put in some effort :) but I certainly believe someone could make a cpu if they wanted, but those could already today
23:41:48 <dons> ndm, I'm wondering that since fps needs only cpp + ffi + h98 and whatever modules hugs has, will it run in yhc?
23:42:11 <RyanT5000> well how hard would it be to make a "chip burner"?
23:42:20 <RyanT5000> e.g.: a 1-unit production facility for chips
23:42:22 <shapr> mahogny: The same thing was said about software long ago.
23:42:49 <RyanT5000> rather than using a mask, just go directly to the chip
23:43:07 <shapr> When I was 16, I couldn't afford a C compiler for DOS 2.x, so I just didn't get to learn programming until later.
23:43:32 <morans> there are a few people who have built 'move machines' themselves -- CPUs/computers that only have one instruction 'MOVE'
23:43:35 <mahogny> shapr, unless you create tools than are better than the commercial ones today, you will have trouble attracting people. a program is much smaller than a cpu
23:44:02 <shapr> I disagree, it's about being able to build your own, not about being able to build one that's better.
23:44:22 <shapr> Better comes later.
23:44:24 <RyanT5000> anyone know how many miles of wiring there is on a pentium?
23:44:58 <shapr> I've wondered if you could directly write a diffraction grating onto a hologram that would work like lightwires.
23:45:10 <mahogny> shapr, anyhow, problem #2; once you have a cpu, how do you test it?
23:45:52 <shapr> If it's silicon, I'll probably end up with an A4 sized CPU to start out with, I'll be able to use logic probes =)
23:46:14 <mahogny> shapr, quite a mess :)
23:46:53 <mahogny> hm. I have an idea
23:47:24 <mwc> if we had a language for "blocks" for a CPU like this
23:47:36 <mwc> I'm sure you'd be able to find a wiki-repository of such blocks to plug in
23:47:51 <shapr> Yeah, something like OpenCores.org
23:47:56 <mahogny> this is temporary of course, but what if you had a really good one-chip computer (quite cheap) and then you upload compiled VHDL to it? then you would have something to play around with for starter, and it could be realized with modern stock hardware easily. you just need to write the software
23:47:59 <mwc> I need a branch preditor and a prefetch unit to go
23:48:19 <shapr> mahogny: Isn't that an FPGA?
23:48:44 <mahogny> shapr, FPGAs are burned. this one is reprogrammed, and can hold much larger hardware
23:49:09 <mwc> RyanT5000, as for 300 years ago, I don't think you could do it. The tooling is far too sophisticated. written documents can be surpressed
23:49:17 <shapr> What's the SoC they're using at Chalmers where the netlist is 'held' every cycle?
23:49:17 <mahogny> also, I believe it could be made faster than fpgas, depending on what you write in it of course
23:49:52 <mahogny> shapr, hmm. I don't really have contact with those guys
23:49:53 <shapr> mwc: http://www.opencores.org/
23:50:10 <mwc> shapr, I was thinking something a little more atomic
23:50:15 <RyanT5000> rough estimate: 1.2 km of wire on an original pentium 4
23:50:40 <RyanT5000> per layer
23:50:41 <shapr> There's something that's one step away from FPGAs ... is it CPLDs?
23:50:52 <RyanT5000> how long would it take a laser of appropriate width to carve out that much stuff?
23:51:37 <mwc> I don't think you could "carve it" at all, the movement control would be impossibly fine
23:51:53 <RyanT5000> really?
23:52:05 <kzm> dons?
23:52:13 <RyanT5000> how about an electron beam
23:52:15 <RyanT5000> do it just like a CRT
23:52:21 <mwc> that's a possibility
23:52:25 <mwc> I could see doing that
23:52:35 <dons> kzm, hi.
23:52:43 <RyanT5000> i mean, how do they make the mask?
23:52:52 <mwc> with a laser, you can't steer the photons in flight, so you basically have to orientate the photodiode right from the beginning
23:52:58 <RyanT5000> right
23:53:02 <mwc> AFAIK, they use light to etch via a mask
23:53:11 <shapr> Doesn't a magnetic field affect a laser?
23:53:14 <RyanT5000> right, i know that, but how do they make the mask
23:53:15 <mwc> shapr, no
23:53:17 <RyanT5000> shapr: no
23:53:31 <mwc> shapr, the only thing that bends a laser beam is gravity
23:53:34 <RyanT5000> only gravity
23:53:34 <RyanT5000> er
23:53:39 <RyanT5000> is there an echo?
23:53:46 <shapr> Hm, didn't Michael Faraday find that magnetic fields can bend light?
23:53:51 <mwc> and I don't want no singularities in my kitchen
23:54:08 <mwc> shapr, light is a magnetic field (and an electrical one)
23:54:14 <shapr> Hmmm, how much gravity do you need to bend light?
23:54:22 <RyanT5000> maybe if you have a sufficiently strong magnetic field to make a wormhole or something
23:54:29 <RyanT5000> assuming that actually works
23:54:50 <mwc> Maxwell's equations are linear, so the equation of the photon is exactly the same with or without an external field, linear DE's don't allow eigenfunctions to mix
23:55:10 <mwc> shapr, enough to bend space time appreciably. Say a star or a large planet
23:55:16 <shapr> oh
23:55:46 <RyanT5000> well technically anything bends it
23:55:48 <shapr> I think the gravity altering devices only give 4% to 6% of the earth's gravity right now.
23:55:49 <RyanT5000> just not enough to be useful
23:56:03 <RyanT5000> gravity altering devices?
23:56:23 <shapr> Yeah, you charge up a superconductor and spin it *really* fast.
23:56:37 <mwc> didn't you hear, the ESA build a gravito-spino-disco-of-doom
23:56:39 <shapr> Some people use a disk, some people use a hexagon.
23:56:53 <RyanT5000> huh
23:57:00 <shapr> Maybe we should take this to #haskell-blah
23:57:48 <SubStack> finally, hexagons being put to some use for a change
