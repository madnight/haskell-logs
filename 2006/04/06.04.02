00:26:20 <pesco> ?hoogle (a -> a -> b) -> a -> a -> b
00:26:21 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
00:26:36 <pesco> God, I'm still sleeping. :-/
00:48:15 <dons> ?type id ::  (a -> a -> b) -> a -> a -> b
00:48:15 <lambdabot>  (a -> a -> b) -> a -> a -> b :: forall a b.
00:48:15 <lambdabot>              (a -> a -> b) -> a -> a -> b
03:12:18 <bolrod> [h/win 12
03:12:22 <bolrod> oops
03:13:28 <iturk> hi there
03:14:25 <iturk> if i want to know a functions description what can i type in ghci ??
03:14:56 <TuringTest> :t map
03:14:59 <TuringTest> :i map
03:15:13 <TuringTest> :type or :info
03:16:51 <iturk> thanks
03:18:07 <iturk> but there is any like a API for all the functions ??
03:18:54 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/
03:22:05 <iturk> thanks
03:28:19 <wolverian> why is HashTable in IO? 
03:29:33 <mauke> it's in Data?
03:30:11 <wolverian> I mean, new returns IO (HashTable key val)
03:30:27 <mauke> because hash tables are mutable
03:30:48 <wolverian> oh, duh. I read update's type wrong. thanks!
03:32:34 <iturk> what is the diference between have in a expression >mod  or >'mod'
03:33:10 <mauke> what?
03:33:32 <iturk> i see something like y 'mod' x
03:33:39 <iturk> and sometimes i only see y mod x
03:33:41 <mauke> no, y `mod` x
03:33:54 <mauke> x `f` y is the same as f x y
03:34:54 <iturk> ok i see 
03:35:07 <iturk> i have mod x y so its logic
03:35:49 <sethk> mod x y is correct
03:35:59 <sethk> mod x y === x `mod` y
03:36:39 <sethk> which is what mauke said, but without the abstraction
03:41:22 <iturk> sieve :: [Int] -> [Int]
03:41:27 <iturk> sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x > 0]
03:41:32 <iturk> in this function
03:41:44 <iturk> what does | do exactly
03:41:58 <iturk> i understand that is some how restricting the y value
03:41:58 <mauke> it delimits stuff
03:42:19 <mauke> [ EXPR | GENERATORS ]
03:42:55 <iturk> and if we put a comma 
03:43:01 <iturk> then we can apply restrictions
03:43:19 <iturk> like the  y `mod` x > 0
03:43:20 <mauke> if it contains a <-, then it pulls a value from somewhere
03:43:24 <mauke> otherwise it's a condition
03:43:54 <iturk> so y is binded to xs
03:44:02 <iturk> then is restricted by the condition
03:44:05 <mauke> xs is a list of values
03:44:11 <mauke> y is the current value
03:44:50 <mauke> for all y in xs where y `mod` x > 0: return y
03:45:51 <sethk> so it's a filter
03:46:00 <iturk> by the recursion will take each element one by one to y 
03:46:07 <iturk> reducing the list
03:46:30 <mauke> yeah, it's like filter (\y -> y `mod` x > 0) xs
03:46:50 <iturk> yes i can apply 
03:46:52 <iturk> primes :: [Int]
03:46:57 <iturk> primes = sieve [2 ..]
03:47:06 <iturk> and i get a list with all the prime numbers
03:58:52 <resiak> No, that gives you a list of all numbers which are odd, with 2 stuck on the start
04:00:05 <mauke> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x > 0] in take 20 $ sieve [2 ..]
04:00:06 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
04:00:47 <resiak> Huh, I clearly can't read. Sorry.
04:02:38 <iturk> is not odd numbers !! Prime numbers !!
04:02:57 <resiak> Yeah, sorry, I can't read.
04:03:25 <iturk> you can divide them only by them selfs and by 1 
04:31:20 <iturk> i taking this from a tutorial:
04:31:22 <iturk> getNput :: IO()
04:31:30 <iturk> getNput = do line <- getLine
04:31:47 <iturk> but it says >The last statement in a 'do' construct must be an expression
04:31:59 <mauke> what tutorial?
04:32:30 <iturk> the point is to show how to use the do contruct
04:34:22 <iturk> http://www.ce.itu.edu.tr/lisans/dersler/blg437e/slides/02-haskell.pdf/view
04:35:14 <iturk> end of slide 7
04:36:23 <mauke> there's another line in that example
04:36:46 <iturk> yes the error is still there
04:36:48 <iturk> with that line
04:36:51 <mauke> no, it isn't
04:37:01 <mauke> did you get the indentation wrong?
04:37:32 <iturk> maybe is that
04:37:42 <iturk> i am just giving a tab
04:38:59 <mauke> the "p" in putStr must be directly below the "l" of line
04:39:12 <iturk> ok so no enter
04:39:32 <iturk> getNput = do line <- getLine putStr line
04:40:00 <iturk> ok i get
04:40:08 <mauke> or is that "under"?
04:40:24 <iturk> i have to give more space to it
04:41:11 <gadolin> guys, how can i write the defintion of class Eq L that contains (==) :: L->L-> Bool , without specyfing type of L
04:41:19 <mauke> iturk: or like this: http://tnx.nl/4635QJZU
04:41:43 <gadolin> and then write instance of that class ... instance Eq Bool where ...
04:41:53 <iturk> mauke: thanks
04:42:13 <iturk> now i dont get error
04:42:29 <sethk> is there are way for patterns (with function defs, not guards) to share a body?  Such as
04:42:43 <sethk> data T1 = Ta | Tb | Tc
04:42:57 <sethk> somefunc Ta = ...
04:43:01 <sethk> somefunc Tb = ...
04:43:02 <gadolin> when i wroe class Eq L where  (==) :: L -> L -> Bool i get error that type is expected
04:43:27 <sethk> gadolin, (==) is not a type
04:43:33 <sethk> (==) is an operator
04:43:52 <gadolin> (==) is in next line
04:44:01 <gadolin> class Eq L where
04:44:09 <gadolin> (==) :: L -> L -> Bool
04:44:26 <sethk> gadolin, the lines don't matter (unless you indent wrong, of course)
04:44:41 <sethk> gadolin, let me check a file with some class defs in it
04:46:31 <gadolin> the problem is not with operator (==) and i have correct indentation for that. but that error is that Haskell expects that type of L is defined one
04:47:06 <sethk> gadolin, ok, what's the problem with defining L before you use it?
04:47:22 <sethk> gadolin, you are correct, I found some working examples with already defined operators in that position
04:47:38 <sethk> gadolin, did you try l instead of L
04:47:40 <gadolin> is it imposible to do sth like generic class
04:47:51 <sethk> gadolin, no, not impossible.
04:48:03 <sethk> gadolin, but if it is a type variable it has to begin with a lower case letter
04:48:21 <sethk> gadolin, an example from a library file:
04:48:29 <sethk> class Num a  where   
04:48:37 <sethk> (+)    :: a -> a -> a
04:49:05 <sethk> gadolin, the "a" there stands for any arbitrary type
04:49:29 <sethk> gadolin, so it says that if something is an instance of Num, a function exists, (+), of type a -> a -> a
04:49:47 <sethk> gadolin, that is a function that takes two arguments of your type and returns a value of the same type
04:50:01 <sethk> gadolin, so it says that all three are the same type, but doesn't constrain the type
04:50:34 <sethk> gadolin, L, because of the language rules about initial cap identifiers and initial lower case identifiers, can't be a type variable
04:50:44 <sethk> gadolin, so the compiler says "I don't know what type L is"
04:54:06 <gadolin> thx works :)
05:12:30 <araujo> good morning
05:16:03 <goron> What is the copyright status of posts to haskell-cafe?
05:18:16 <dons> hmm.
05:18:18 <dons> good question
05:18:28 <dons> public domain?
05:18:42 <dons> there must be some legal precedents on this stuff
05:18:58 <dons> why, do you want someones code, goroon ;)
05:19:47 <Smokey`> okay, i'm stuck...  is there anything similar to 'map' that allows me to pass variables into the function?
05:20:15 <sieni> Smokey`: like what?
05:20:26 <dons> yep, example?
05:21:10 <Smokey`> hmm acutally, that wont do
05:21:27 <Smokey`> because i need to know the index of each part of the list i'm currently applying hte function to :S
05:21:33 <Smokey`> bleh
05:21:39 <Smokey`> soo confused -_-
05:21:52 <sieni> > let f n = map (+n) [1,2,3,4] in f 3
05:21:53 <lambdabot> [4,5,6,7]
05:22:13 * dons starts to suspect a fold or a list comprehension is needed. or maybe a partially applied map
05:22:41 <sieni> > zipWith (+) [1,2,3,4] [1..]
05:22:42 <lambdabot> [2,4,6,8]
05:22:45 <Smokey`> need to do something similar to nested loops, for accessing a list. (where each iterator in the for loop would be used to access the list)
05:22:58 <goron> dons: No, I don't need code. I saw a forum offering posts.
05:23:01 <Smokey`> i know how to do what i want in c, if that helps...
05:23:22 <dons> > zip "haskell" [1..]
05:23:23 <lambdabot> [('h',1),('a',2),('s',3),('k',4),('e',5),('l',6),('l',7)]
05:23:34 <goron> dons: But they clearly redistribute, and I didn't see me signing a contract or anything like that for transferring copyright.
05:24:09 <dons> Smokey', you can always write a recursive looop with a counter as an argument
05:24:20 <Smokey`> for(size_t i(0); i < height; ++i) { for(size_T j(0); j < width; j+) { ...do something with pixel[i][j] here... } };
05:24:33 <goron> dons: Usenet is public domain, IIRC, but a mailing list is not Usenet
05:24:54 <Smokey`> dons: ugh, that will require 3 functions to do what should really only require 1 function :S
05:24:55 * shapr boings
05:25:53 <araujo> hola shapr !
05:26:16 <dons> > [ (i,j) | i <- [1..3], j <- [1..4] ]
05:26:17 <lambdabot> [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4)]
05:26:54 <shapr> hola araujo
05:27:22 <araujo> shapr, how it goes?
05:27:27 * araujo waiting for shapr's ideas
05:29:07 <Smokey`> dons: mmm, interesting... i'll have a play with whatever that is :P
05:29:22 <dons> Smokey`, so, do something with i and j (rather than tuple them as I did here )
05:29:25 <dons> it's a list comprehension
05:29:30 <dons> more fun syntax
05:29:37 <Smokey`> dons: thanks man, that'll help ALOT :)
05:29:55 <dons>  [ (pixel ! i) ! j | i <- [1..3], j <- [1..4] ] or something
05:30:26 <dons> lazy lists are isomorphic to loops :) or something similar, Cale always says
05:30:40 <dons> which is true
05:31:09 * dons <- out
05:33:09 <Philippa> goron: usenet is not public domain
05:33:16 <Philippa> nothing is public domain unless you put it there
05:33:32 <Philippa> what /does/ happen with usenet is that you're considered to have consented to the mass distribution and archival of your post
05:34:02 <Smokey`> sweeeeetness dons, thanks a bunch.    'night man :)
05:34:22 <goron> Philippa: ok, so they do have to credit you, but that's all?
05:34:32 <goron> Philippa: Like a BSD license.
05:34:48 <Philippa> it's questionable whether they're allowed to pull it off anything usenet-related into a separate archive or collection
05:35:13 <Philippa> linking to existing archives would always be legit though
05:35:32 <goron> Philippa: You mean like Google groups ?
05:36:09 <goron> Philippa: and what about mailing lists?
05:40:32 <musasabi> goron: in principle you need permission from the author to make copies. Of course implicit permission has been given for the use of the message on the mailing list and related things.
05:40:46 <shapr> araujo: Oh, I got distracted, sorry.
05:44:16 <Philippa> goron: mailing lists are much the same
05:45:06 <Maddas> How would I 'cast' x back to Integer here, in order to call (show x)? data Foo = Integer; let x = (1 :: Foo) in show (x :: Integer) isn't right
05:45:18 <ValarQ> shapr: hej formarn
05:45:33 <mauke> that shouldn't compile, I think
05:45:43 <Maddas> Right, it doesn't :-)
05:45:53 <mauke> Foo isn't an instance of Num
05:45:56 <goron> 1) So can I make a copy of code and use that somewhere and distribute that? 2) Same question as 1, but with derived code? 3) Can I serve ads to show posts to mailing lists?
05:46:23 <Maddas> Ah, Num might be what I'm looking for.
05:46:24 <Maddas> Thanks
05:46:32 <mauke> Maddas: is there a reason you don't use () instead of Foo?
05:46:59 <Maddas> I don't understand
05:47:12 <mauke> () is a type with a single argumentless constructor, ()
05:47:18 <mauke> Foo is a type with a single argumentless constructor, Integer
05:47:28 <Maddas> Right, I'm only defining Foo for convenience
05:47:39 <Maddas> (For code later on)
05:47:42 <jyp_> newtype Foo = Foo Integer is what you meant I guess
05:48:00 <Maddas> Oh, duh, right.
05:48:10 <Philippa> goron: 3) is probably legit, and Yahoo! do that. 1) is questionable but in most cases I would've said yes, same for 2)
05:48:26 <Philippa> (but if an explicit license is put on the code, give up)
05:48:51 <shapr> hiya ValarQ 
05:49:28 <Maddas> mauke: What's the constructor of Integer, then? :-)
05:49:32 <Maddas> (The type)
05:49:41 <goron> Philippa: I think the mailing list should clearly state what rights you give up. 
05:49:54 <ValarQ> shapr: left boden yet?
05:49:55 <xerox> Maddas, numeric literals are Integer constructors :-)
05:49:57 <mauke> the constructors of Integer are 0, 1, 2, etc except they're overloaded
05:50:00 <jyp_> Maddas: then you can add "deriving Num" I guess
05:50:03 <Philippa> goron: perhaps. In the absence of that though?
05:50:08 <Maddas> Heh, okay.
05:50:18 <jyp_> @type 1
05:50:19 <lambdabot> forall t. (Num t) => t
05:50:25 <goron> Philippa: In the absence of that, I think normal copyright laws should apply.
05:50:40 <Philippa> sure, and they do. The question is the implicit license you've given to everyone else
05:50:54 <Philippa> in practice, with small snippets of code it probably doesn't matter much
05:51:07 <goron> Philippa: Well, it doesn't only concern code. 
05:51:36 <Philippa> true
05:51:47 <goron> Philippa: I think I agreed that I send a mail to everyone on the Haskell mailing list. Not even that it should be posted on the web. 
05:51:56 <Philippa> though when discussing code there's often a "here's how to do it" context which could be argued to extend the implicit license
05:52:13 <goron> Philippa: and I certainly didn't agree that it can be posted on Joe Random Website.
05:52:21 <Maddas> What I want is to further overload the Integer constructors for another type, and to have those types disjoint. Is there no way to get this without having a constructor? And if I do that, how do I 'cast' back and forth between my type and Integer?
05:52:51 <mauke> step 1: define a new type (using data or newtype)
05:52:52 <Maddas> Sorry, without having a new (user-definde) constructor.
05:52:57 <Philippa> (that is, if your post was clearly a tutorial, example code is likely to be considered a free-for-all unless otherwise stated)
05:52:57 <mauke> step 2: make it an instance of Num
05:53:17 <jyp_> goron: Even for copyrighted stuff, there is the notion of fair use.
05:53:19 <Philippa> goron: you'd lose the case if you complained about the web archives of the list
05:53:29 <mauke> or Integral or whatever
05:53:41 <Philippa> you might get to have your post taken down from them, but beyond that you'd basically get told not to do it again
05:53:48 <jyp_> goron: So Joe doesn't need your consent to quote you for example.
05:54:20 <Maddas> mauke: Num provides fromInteger, how do I get toInteger?
05:54:36 <Maddas> Argh, sorry, that's just what Integral provides.
05:54:41 <mauke> Maddas: it's a method of I... what you said
05:55:00 <Maddas> Yeah, I misread. Thanks!@
06:01:28 <goron> jyp: Yes, I am familiar with fair use. 
06:03:07 <shapr> ValarQ: Nah, still here.
06:05:15 <ValarQ> shapr: still the most northern haskeller then? :)
06:05:36 <gadolin> what and how 'import'  sth to have ord and chr functions ?
06:06:21 <gadolin> i get error that they are not in scope
06:06:26 <Philippa> Char or Data.Char
06:06:29 <mauke> import Char (ord, chr) or something like that
06:06:36 <gadolin> thx
06:06:49 <Philippa> in ghci or hugs, :m +Char
06:07:04 <xerox> :also Char
06:24:29 <Smokey`> I'm soo confused right now.  I have a function with type-sig "[[(Float, Float, Float)]] -> [[(Float, Float, Float)]]", yet it complains if i try to return [[(0,0,0]], and strangely enough it WORKS if i return [(0,0,0)]  :S
06:25:10 <mauke> remove "return"
06:25:28 <Lemmih> > return 10 :: [Int]
06:25:29 <lambdabot> [10]
06:25:35 <Smokey`> hmmm
06:25:44 <Smokey`> okay... weird.
06:25:55 <mauke> "return" is a function
06:25:59 <mauke> it wraps things in containers
06:26:08 <Smokey`> ahh
06:42:20 <Philippa> Smokey`: return is emphatically *not* what it is in C or C++ :-)
06:42:30 <Philippa> unless you're learning about monads you can ignore it now
06:43:25 <Smokey`> i have no idea what a monad is, and currently none of my concern, hence i've ignored it :)
06:48:57 <JKnecht> uh oh.
07:07:00 <pierre-> hello.
07:09:05 <Smokey`> hey
07:10:09 <pierre-> i'm haskell beginner, can i participate in hIDE developement?
07:12:29 <kolmodin_> pierre-: sure, put your name to the list http://www.haskell.org/hawiki/hIDE
07:13:23 <kolmodin_> pierre-: I'm afraid that the development has stalled the last couple of months..
07:14:13 <kolmodin_> anyway, I need some advice on an app I'm currently writing.
07:15:09 <kolmodin_> I've got a file descriptor from a C library, and read() returns a C struct. any hints on how I might get that to a haskell datatype?
07:15:50 <ibid> kolmodin_: read returns an int usually?
07:16:00 <musasabi> kolmodin_: use Foreign.* if it is simple or one of the wrapper generators like c2hs if it is complex.
07:16:01 <ibid> or ssize_t, whatever
07:16:10 <kolmodin_> ibid: yes, but, you know what I mean :)
07:16:56 <kolmodin_> musasabi: it's quite simple
07:17:54 <musasabi> then peek your way out.
07:18:10 <musasabi> @index peek
07:18:10 <lambdabot> Foreign.Storable, Foreign
07:18:14 <musasabi> @index peekByteOff
07:18:15 <lambdabot> Foreign.Storable, Foreign
07:18:19 <pierre-> kolmodin_: is there any hIDE mailing list? 
07:18:19 <kolmodin_> musasabi: so you suggest that I create a buffer and read it into there
07:18:42 <kolmodin_> pierre-: not if there isn't anything written about it on the wiki
07:18:45 <kolmodin_> (probably)
07:18:46 <musasabi> kolmodin_: yes. allocaBytes for that.
07:19:33 <kolmodin_> musasabi: and what do you suggest I should use to read()? it must be nonblocking to the app but may block the lightweight haskell thread
07:20:19 <sieni> select() or poll()
07:20:36 <kolmodin_> sieni: I want the GHC RTS to do that for me
07:20:47 <kolmodin_> (since I'm lazy :))
07:21:26 <Lemmih> kolmodin_: hIDE is active again.
07:21:35 <xerox> 6.5 is out?
07:21:46 <kolmodin_> Lemmih: great!
07:22:22 <musasabi> xerox: 6.5 is the development version that will become 6.6 when stable.
07:22:34 <xerox> A-la linux kernel, I see!
07:23:18 <Lemmih> pierre-: There's no hIDE mailing-list. But we got a weblog: http://haskell.org/hide/
07:23:22 <musasabi> kolmodin_: make a handle from the fd and then just use hGetBuf
07:24:45 <metaperl> where do you d/l hIDE?
07:25:01 <Lemmih> pierre-: It'll be a lot easier to contribute to HIDE once the plug-in architecture has been fixed.
07:25:08 <kolmodin_> musasabi: thanks a bunch! that's exactly what I was looking for
07:25:52 <pierre-> Lemmih: so, i can participate by just sending patches to darcs repo?
07:26:08 <Lemmih> metaperl: darcs get --partial http://darcs.haskell.org/hIDE
07:26:28 <Lemmih> pierre-: Yeah.
07:26:32 <goron> metaperl: It's a pain to build it. Be warned.
07:26:44 <metaperl> oh, nevermind then. thanksfor the heads up
07:27:25 <Lemmih> goron: It's been rewritten. Now it only depends on GHC and FilePath.
07:27:31 <goron> Lemmih: Any chance of dropping the ghci bytecode any time?
07:27:46 <goron> Lemmih: I read your blog post. 
07:28:09 <goron> Lemmih: I mean that you can also just call native code again, later.
07:28:27 <metaperl> where can I see the standard Haskell type hierarchy?
07:28:31 <goron> Lemmih: Interesting, I will check whether it works here.
07:29:33 <xerox> metaperl, do you mean the Class hierarchy?  It's in the report.
07:29:47 <metaperl> oh ...
07:29:48 <Lemmih> goron: We can still have plug-ins as Cabal libraries but then they can't be reloaded at run-time.
07:30:22 <goron> Lemmih: Where do I need to do darcs get --partial http://darcs.haskell.org/ghc.hide?
07:30:28 <goron> Lemmih: In the hIde dir?
07:31:35 <Lemmih> goron: Actually, any recent version of ghc-6.5 should work.
07:31:40 <ibid> kolmodin_: actually, i did not know what you meant
07:31:55 <goron> Lemmih: Oh, that's nice. I have a recent CVS version :)
07:32:31 <goron> Lemmih: I don't have Config, I guess not recent enough.
07:32:56 <pierre-> Lemmih: can hIDE be builded on windows?
07:33:00 <kolmodin_> ibid: I mean that the data read() puts in a buffer is a C struct
07:33:22 <pierre-> *built
07:34:27 <Lemmih> pierre-: I think so.
07:34:32 <ibid> kolmodin_: that's unportable even in C :)
07:34:54 <pierre-> Lemmih: ok, i'll try :-)
07:35:18 <kolmodin_> ibid: too bad :)
07:35:39 <Lemmih> pierre-: Keep in mind that hIDE can't do anything yet (:
07:35:48 <kolmodin_> :)
07:36:54 <pierre-> Lemmih: yes... But to develop it i have to build it first :)
07:40:56 <metaperl> i'm getting an indentation error in this haskell file. can someone help please: http://rafb.net/paste/results/gLwigU71.html
07:41:40 <goron> | x : removeFirst n xs
07:41:50 <goron> metaperl: That's incorrect
07:42:07 <xerox> It misses the condition.
07:42:15 <metaperl> oh
07:42:19 <metaperl> otherwise is needed
07:42:35 <goron> metaperl: Or True
07:42:44 <xerox> otherwise is ok.
07:42:50 <goron> (those are the same, but I like otherwise more)
07:42:51 <metaperl> thanks for hte help
07:43:36 <xerox> That's from 'The Haskell road to Math, Logic, and Programming', right?
07:44:26 <metaperl> xerox: yes
08:24:34 <chrisbrown> is there way to hide class instances in an import?
08:24:50 <musasabi> no
08:25:03 <chrisbrown> :(
08:25:10 <chrisbrown> there should be!
08:26:38 <musasabi> it would create much confusion given that class instances are imported in a transitive way.
08:26:56 <musasabi> you might want to avoid defining all those extra instances in the first place.
08:28:20 <chrisbrown> yes, but the problem I'm having is I want to overide instances defined in Data.Typeable
08:28:50 <chrisbrown> and using -fallow-overlapping-instances has no effect
08:28:51 <musasabi> that sounds like sure way for failure.
08:29:02 <jyp> chrisbrown: why would you want to do so ?
08:29:13 <chrisbrown> because I need to do that for Strafunski
08:29:20 <chrisbrown> Strafunski uses Typeable
08:29:49 <jyp> You know, Data.Generic = Strafunski
08:29:51 <jyp> sort of
08:30:06 <jyp> And everything should be already ok for use
08:30:22 <chrisbrown> Strafunski needs instances for Typeable and Term for all your data types
08:30:56 <musasabi> That does not explain why you would want to override existing instances
08:31:20 <jyp> Data.Generics.Data is the new Term
08:31:27 <chrisbrown> well ghc6.5 is complaining about it
08:32:32 <musasabi> my guess would be the that Strafunski code is old and needs updating.
08:32:42 <jyp> I understand you want to compile your own copy of Strafunski ?
08:32:43 <chrisbrown> yes
08:32:49 <chrisbrown> yep
08:32:54 <chrisbrown> an old copy at that
08:33:14 <jyp> Mostly everything of strafunski can be found in Data.Generics
08:33:28 <jyp> pre-compiled for you :)
08:33:53 <chrisbrown> im not sure i understand. Strafunski still needs these instances for my data types
08:35:24 <jyp> have you read this: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Generics.html ?
08:36:21 <chrisbrown> do I just import Data.Generics?
08:36:34 <jyp> yup
08:36:48 <jyp> read http://www.cs.vu.nl/boilerplate/ for examples
08:37:16 <chrisbrown> cheers, just trying it now
08:37:35 <jyp> :)
08:40:55 <chrisbrown> it says "toDyn" is not in scope
08:41:07 <chrisbrown> any ideas?
08:41:36 <chrisbrown> oh that was in Data.Dynamic
08:41:43 <jyp> yup
08:41:50 <jyp> @hoogle toDyn
08:41:51 <lambdabot> Data.Dynamic.toDyn :: Typeable a => a -> Dynamic
08:41:56 <chrisbrown> has that been redefined too?
08:42:04 <chrisbrown> or do I need to import Data.Dynamic?
08:42:26 <chrisbrown> import Data.Dynamic (toDyn) ?
08:42:35 <jyp> iirc Data.Generics makes Data.Dynamic visible
08:43:15 <chrisbrown> so it should be in scope?
08:43:23 <jyp> otherwise just import it as you said.
08:43:32 <chrisbrown> ok just trying.... :)
08:45:21 <chrisbrown> hmmm
08:45:28 <chrisbrown> it seems to be importing Data.Typeable still
08:46:02 <chrisbrown> im getting lots of overlapping instances errors
08:46:54 <jyp> Maybe just paste your code somewhere, so we have common ground
08:47:06 <musasabi> @seen CosmicRay
08:47:06 <lambdabot> I saw CosmicRay leaving #haskell 14 hours, 31 minutes and 15 seconds ago.
08:47:44 <jyp> but afaict, all you need is to add deriving (Typeable, Data) to the types you want 
08:48:07 <chrisbrown> yeah but there are lots of types
08:48:36 <chrisbrown> is there someplace i can paste code on the web?
08:48:45 <jyp> @paste
08:48:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:48:51 <chrisbrown> ah cheers
08:51:09 <jyp> chrisbrown: read http://www.cs.vu.nl/boilerplate/testsuite/paradise/CompanyDatatypes.hs
08:51:14 <jyp> http://www.cs.vu.nl/boilerplate/testsuite/paradise/Main.hs
08:51:27 <jyp> linked from http://www.cs.vu.nl/boilerplate/
08:52:14 <chrisbrown> thats not the route I want to take, there are lots of data types. and we already have instances defined i just need it to compile with ghc6.5
08:52:48 <chrisbrown> how do you paste code on this thing?
08:53:19 <jyp> edittext, at the bottom
08:53:52 <jyp> anyway, I'd advise against "just compiling with ghc 6.5"
08:54:22 <chrisbrown> jyp: why?
08:55:05 <jyp> because it's bad practise to duplicate a standard functionality
08:56:01 <jyp> plus I suspect the actual changing is rather quick to do
08:56:12 <jyp> unless you have in the hundreds of types
08:56:18 <chrisbrown> i have hundreds of tyes
08:56:20 <chrisbrown> *types
08:56:29 <chrisbrown> which was why i wanted a quicker way :)
08:56:30 <jyp> I guess these are generated then?
08:56:42 <chrisbrown> the instances are generated by DrIFT
08:57:00 <musasabi> chrisbrown: use DrIFT to generate nicer instances then.
08:57:10 <musasabi> hacking DrIFT is very easy.
08:57:34 <chrisbrown> musasabi: "generate nicer instances" i dont know how to do that
08:59:37 <jyp> chrisbrown: http://hackage.haskell.org/darcsweb/darcsweb.cgi?r=base;a=annotate_shade;f=/include/Typeable.h
09:08:42 <chrisbrown> dont think thats gonna help - i don't understand it. cheers for your help.
09:10:33 <chrisbrown> but how come it works with 6.4 and not with 6.5? 
09:11:26 <musasabi> It declares some Typeable instances that were missing from 6.4 and were added into 6.5 ?
09:12:55 <chrisbrown> ive pasted a section of my instances code...
09:12:56 <chrisbrown> http://www.haskell.org/hawiki/HaskellIrcPastePage#preview
09:13:18 <chrisbrown> the kind of errors im getting is:
09:13:20 <chrisbrown> ../DriftStructUtils/DriftStructUtils.hs:235:0:
09:13:21 <chrisbrown>     Overlapping instances for Typeable (TypeInfo i)
09:13:21 <chrisbrown>       arising from the superclasses of an instance declaration at ../DriftStructUtils/DriftStructUtils.hs:235:0
09:13:24 <chrisbrown>     Matching instances:
09:13:26 <chrisbrown>       instance (Typeable1 s, Typeable a) => Typeable (s a)
09:13:29 <chrisbrown>         -- Imported from Data.Typeable
09:13:31 <chrisbrown>       instance [incoherent] (Typeable i) => Typeable (TypeInfo i)
09:13:34 <chrisbrown>         -- Defined at ../DriftStructUtils/DriftStructUtils.hs:241:0
09:13:36 <chrisbrown>     In the instance declaration for `Term (TypeInfo i)'
09:14:59 <Saulzar> Maybe you can comment out instances of some of the trouble makers?
09:15:15 <chrisbrown> ive tried that, but i'll try again :)
09:40:23 <goron> With what version of GHC can I build GHC CVS? 
09:40:44 <goron> I now have The Glorious Glasgow Haskell Compilation System, version 6.5
09:40:53 <xerox> 6.4 doesn't do it?
09:41:13 <goron> xerox: Probably it does.
09:41:46 <goron> xerox: I thought I ask, before I do useless installation of 6.4
09:41:49 <xerox> I don't know the details, but I suspect that each GHC version could compile itself, theoretically.
09:41:59 <Igloo> development versions can't necessarily compile development versions, including themselves
09:42:03 <xerox> ...and CVS is 6.5 now, isn't it?
09:42:11 <xerox> Ooh-kay.
09:42:14 <Igloo> You should generally use the most recent stable release
09:42:20 <xerox> That makes sense.
09:42:26 <goron> Igloo: Thanks for that heuristic :)
09:54:58 <goron> ...Doing make clean.... helps more....
10:11:37 <mwc> is there a smarter way to iterate over each element in a list of lists than concat, or is lazyness my friend? I mean, obviously this is O(N), but anything better?
10:13:07 <mwc> I understand that lazy evaluation avoids building the list, but is there much overhead?
10:13:27 <mwc> ie, maybe combining them something like what shows does for [Char]?
10:15:15 <monochrom> concat is lazy too.
10:15:43 <jyp> mwc: Iterate over reminds me more of map than concat
10:15:59 <jyp> > map (*2) [1..5]
10:16:00 <lambdabot> [2,4,6,8,10]
10:16:04 <mwc> "fold" would be a more accurate description
10:16:05 <monochrom> > take 2 $ concat [[1,2,3], undefined]
10:16:06 <lambdabot> [1,2]
10:16:21 <monochrom> > take 2 $ concat [[1,2]++undefined, undefined]
10:16:22 <lambdabot> [1,2]
10:16:38 <jyp> foldr is good for lazythings
10:16:40 <mwc> good
10:16:56 <mwc> concat is just foldr (++) [] isn't it?
10:17:07 <monochrom> (foldr op) is as lazy as op.
10:17:08 <jyp> yup
10:17:21 <monochrom> So for example concat is lazy because ++ is.
10:17:32 <monochrom> whereas sum isn't because + isn't.
10:22:43 <mwc> What exactly am I supposed t use for the state parameter in ST (STUArray specifically)
10:22:55 <mwc> I can't find any hints as to what type makes a good "state thread" in the docs
10:24:05 <jyp> mwc: any type  type variable
10:24:08 <jyp> iirc
10:24:21 <mwc> okay, so () is fine?
10:24:30 <jyp> no, this is a constant
10:24:35 <jyp> "s"
10:24:54 <mwc> oh, I see what you mean
10:25:07 <mwc> 'cool'
10:25:32 <mwc> I was thinking since I have that STRef stuff, I need to have some type that supports it
10:26:17 <monochrom> runST provides one.  You must use a type variable in your type signature.
10:27:03 <monochrom> You must use a type variable in your type signature so that runST is permitted complete freedom.
10:27:33 <monochrom> I would let the type signature be inferred.
10:28:02 <jyp> except that sometimes GHC fails at this
10:28:23 <jyp> or sometimes you want to specifiy your time signatures to type-debug your code
10:28:30 <monochrom> > let x = newSTRef "hello" in "hello"
10:28:31 <lambdabot>  Not in scope: `newSTRef'
10:28:36 <jyp> s/time/type
10:29:24 <monochrom> I'll contrive an example.
10:35:13 <monochrom> http://pastebin.com/636160
10:35:55 <monochrom> If you use arrays, the need to manually type is greater.  I'll contrive an example.
10:36:20 <jyp> monochrom: better paste this kind of things to the wiki :)
10:54:35 <shapr> @y0
10:54:36 <lambdabot> Maybe you meant: . id pl wn yow
10:55:38 <xerox> Maybe.
10:55:50 <jyp> @wn
10:56:02 <jyp> @help wn
10:56:02 <lambdabot> I perform dictionary lookups via the following 13 commands:
10:56:02 <lambdabot>  @all-dicts .. Query all databases on dict.org
10:56:02 <lambdabot>  @devils ..... The Devil's Dictionary
10:56:02 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
10:56:02 <lambdabot>  @elements ... Elements database
10:56:04 <araujo> shapr, hola!
10:56:05 <lambdabot> [9 @more lines]
11:00:33 <monochrom> http://www.cs.utoronto.ca/~trebla/Shuffle.hs  example of using and typing STArray.
11:03:52 <mwc> Thanks monochrom 
11:06:20 <jyp> @hoogle div
11:06:21 <lambdabot> Prelude.div :: Integral a => a -> a -> a
11:06:21 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
11:06:21 <lambdabot> Control.Exception.DivideByZero :: ArithException
11:07:00 <goron> GHC build error: parser/Lexer.x:562:12: lexical error in string/character literal. I think I don't use good versions of some software. Sound familiar to anyone?
11:09:05 <monochrom> may be gcc version.
11:12:31 <goron> monochrom: plausible. Still I don't see why they break the language everytime.  
11:14:21 <jyp> They strive to fix it, every time
11:14:28 <goron> lol
11:14:34 <jyp> but of course it's an impossible task :)
11:16:55 <goron> Ok, my GHC configure command now has 9 switches. 
11:19:27 <mwc> Something look wrong with this type sig? 
11:19:27 <mwc> concatNozEffects :: [[(Cell,Double)]]
11:19:28 <mwc>                  -> STUArray s Cell Double
11:19:28 <mwc>                  -> ST s (STUArray s Cell Double))
11:19:47 <mwc> getting an less-polymorphic-than-expected error in runSTUArray
11:22:00 <mwc> THink i fixed it. Never find problems until after I make a fool of myself
11:22:48 <goron> monochrom: Your educated guess was correct.
11:26:17 <bolrod> how could I compile haskell on linux for windows?
11:29:15 <bolrod> hrm..
11:29:57 <araujo> bolrod, ?
11:30:03 <bolrod> how could I compile haskell on linux for windows?
11:30:11 <bolrod> some cross compiling ofcourse... 
11:30:17 <bolrod> but how :)
11:30:53 <araujo> compile haskell?, you mean an implementation?
11:30:54 <goron> bolrod: I must applaud you for your original question :)
11:31:33 <bolrod> is that sarcasm? -,-
11:31:47 <goron> monochrom: Your educated guess was not correct
11:31:47 <araujo> bolrod, i don't understand 
11:32:04 <bolrod> you only have to know the answer.. ;)
11:32:19 <goron> bolrod: You must specify what implementation. GHC?
11:32:23 <araujo> without question? :-P
11:32:35 <bolrod> compile haskell code.. on linux .. creating a windows executable
11:32:45 <araujo> Haskell is a language, you can't compile it :-P
11:32:54 <bolrod> O_o?
11:32:56 <araujo> see, that's clearer :-)
11:32:57 <bolrod> then what is ghc?
11:33:01 <goron> araujo: He just wants to compile Haskell *code*.
11:33:03 <araujo> An implementation :-)
11:33:09 <goron> araujo: Not a compiler.
11:33:12 <araujo> aha, i see
11:33:13 <bolrod> ohhhhhhhhhhhhh  yeah what else would you want to compile ;)
11:33:13 <jyp> I don't think GHC support cross-compilation
11:33:24 <bolrod> ok
11:33:26 <araujo> bolrod, Any programm written in Haskell?
11:33:42 <araujo> (other then an implementation of course)
11:34:00 <araujo> That was my confusion, well, you can get GHC running on windows
11:34:01 <mwc> Strange
11:34:03 <araujo> that'll make it
11:34:11 <bolrod> yes ofcourse
11:34:19 <bolrod> but lets say.. I dont want to use a windows box for compiling
11:34:25 <goron> Anybody else with an educated guess for this error? parser/Lexer.x:562:12: lexical error in string/character literal
11:34:35 <mwc> why does: runSTUArray $ functionGivingAnSTUArrayInST param1 fail
11:34:38 <araujo> goron, what distro?, 
11:34:48 <mwc> while the same thing with $ replaced by ( ) around the argument work?
11:34:49 <goron> araujo: Debian
11:34:54 <goron> araujo: Unstable
11:35:02 <araujo> goron, sorry, wouldn't know
11:35:20 <goron> araujo: Distro doesn't really matter, anyway.
11:35:36 <araujo> goron, it does :-]
11:35:46 * araujo maintains Haskell packages on Gentoo btw
11:35:55 <goron> araujo: And why does it matter?
11:35:59 <Igloo> goron: What is that line?
11:36:15 <Igloo> And what command is giving it?
11:36:19 <araujo> goron, oh, long history, but you can join us at #gentoo-haskell and just read the chatting :-]
11:37:59 <goron> Igloo: Hmm, I can't find the file :?
11:38:26 <goron> Igloo:  make[1]: Leaving directory `/home/foo/fptools/ghc'
11:39:13 <goron> Igloo: When I look in /home/foo/fptools/ghc/stage1/parser/ there is nothing
11:43:59 <goron> Oh, found it.
11:45:15 <goron> Igloo: UTF-8 tokens
11:45:54 <goron> Igloo:  ,("λ",	ITlam,          bit glaExtsBit)
11:46:06 <goron> The lambda is killing me.
11:49:58 <goron> Igloo: Does that sound familiar to you? 
11:50:46 <goron> brb
11:55:14 <goron> Igloo: ?
11:56:55 <machack666> hey, is there a way to map a function across a [[a]]?  Kind of like a map, but for a list-of-lists?
11:57:10 <toast> oi
11:57:26 <toast> in a function, if i want to show an error if the int is negative
11:57:29 <toast> how can i do so
11:58:01 <basti_> > error "an int is negative"
11:58:01 <lambdabot> Add a type signature
11:58:05 <basti_> hmm
11:58:08 <basti_> > error "an int is negative" :: Int
11:58:09 <lambdabot> Exception: an int is negative
11:58:26 <basti_> i don't know if that is exactly what you're looking for
11:58:42 <basti_> "error" is "this shouldn't happen".
11:59:02 <basti_> if you can't give a sensible result on negative values, use Maybe maybe?
11:59:12 * basti_ like yoda talks
11:59:22 <toast> thx
12:00:10 <goron> @hoogle [[a]]->[[a]]
12:00:10 <lambdabot> No matches found
12:00:29 <basti_> transpose?
12:00:31 <Cale> @type transpose
12:00:32 <lambdabot> Not in scope: `transpose'
12:00:36 <goron> @hoogle (a->b)-> [[a]]->[[b]]
12:00:36 <Cale> @type Data.List.transpose
12:00:37 <lambdabot> No matches, try a more general search
12:00:37 <lambdabot> forall a. [[a]] -> [[a]]
12:01:12 <int-e> @type map . map
12:01:12 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
12:01:13 <Cale> the hoogle in lambdabot seems to miss a lot of things
12:01:28 <goron> @hoogle (a->b)-> [a]->[b]
12:01:28 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
12:01:28 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
12:01:28 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
12:01:42 <goron> @hoogle (a->b)-> [a]->[b]
12:01:43 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
12:01:43 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
12:01:43 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
12:02:02 <Cale> I don't see how scanr matches that at all
12:02:11 <tennin> map (map f) ?
12:02:23 <Igloo> goron: You didn't say what the command was, but my guess is you need a newer alex, or one compiled with a newer ghc
12:02:40 <goron> Igloo: You asked me a question?
12:02:58 <machack666> (map . map) looks like it will do the trick.  Thanks...
12:03:24 <Igloo> goron: < Igloo> goron: What is that line? < Igloo> And what command is giving it?
12:03:43 <goron> Igloo: make
12:04:09 <Igloo> But what command that make runs?
12:04:19 <toast> http://pastebin.com/636286
12:04:27 <toast> doesnt work the error thing ;p
12:05:00 <Cale> why the braces?
12:05:09 <kosmikus> toast: your syntax is wrong.
12:05:10 <Cale> and no then
12:05:31 <goron> toast: ##java is the other way
12:05:34 <goron> ;)
12:06:04 <basti_> toast: one : too much
12:06:21 <basti_> and of course i just used :: Int because i needed -some- type in the lambadbot eval.
12:06:24 <Cale> http://pastebin.com/636293
12:06:34 <Cale> oops
12:06:38 <Cale> one more problem
12:06:38 <basti_> you won't need a type, and if you want to annotate one, it'd have to be Float
12:06:43 <mwc> Wow, switching from Data.Array to Data.Array.Unboxed has an incredible effect on performance
12:06:46 <Cale> http://pastebin.com/636296 -- check again :)
12:06:49 <basti_> types start with capital letters in haskell btw.
12:06:51 <Cale> ugh
12:06:57 <Cale> and still a colon
12:07:10 <Igloo> It's not well-typed either
12:07:17 <Cale> oh, that too
12:07:19 <Cale> heh
12:07:54 <toast> http://pastebin.com/636303
12:08:13 <Cale> yeah, that was still an old version
12:08:14 <basti_> toast: still one : too much
12:08:23 <Cale> http://pastebin.com/636302 -- refresh
12:08:54 <Cale> your type was wrong too
12:08:58 <machack666> ok, is there a way to do a fancy zip-style operation across a list-of-lists?  i.e., if I want to have zipWithListOfLists (+) [[1..3],[5..7]] [1..], (resulting in [[2,4,6],[9,11,13]]) are the mechanisms in place to accomplish this?
12:09:04 <Cale> if you multiply two Integers, the result is an Integer
12:09:06 <basti_> toast: the error is kinda hard to understand here. : is element-to-list concatenation, and strings are lists of chars.
12:09:11 <basti_> @type (:)
12:09:12 <lambdabot> forall a. a -> [a] -> [a]
12:09:19 <basti_> Cale: that will be the next problem ;)
12:09:25 <toast> http://pastebin.com/636307
12:09:26 <basti_> and then, you -can- square negative integers.
12:09:28 <toast> another error lol
12:09:48 <Cale> machack666: [9,11,13]?
12:09:57 <basti_> > (error "hi") :: Int
12:09:58 <lambdabot> Exception: hi
12:09:59 <basti_> > (error : "hi") :: Int
12:09:59 <lambdabot> Couldn't match `[Char] -> a' against `Char'
12:10:12 <Cale> machack666: for that matter, [2,4,6]?
12:10:48 <Cale> machack666: I'm not sure how you get your result
12:11:07 <toast> still doesnt work..
12:11:07 <machack666> Cale: the function I'm imagining is taking a multi-dimensional list and a normal list, applying some function and keeping the structure of the first list.
12:11:24 <machack666> like zipWith, but the first list is a list-of-lists
12:11:34 <Cale> but you're adding
12:11:43 <machack666> @type zipWith
12:11:44 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
12:12:04 <Cale> how do you go from 5 to 9?
12:12:17 <Cale> you're adding 4 there
12:12:37 <machack666> 4 + 5
12:12:48 <machack666> the 5 is from the input structure
12:13:11 <machack666> the 4 is from the infinite list
12:13:14 <basti_> toast: why do you believe you can't square negative values?
12:13:24 <toast> just learning basti_
12:13:33 <Cale> machack666: ah, I see
12:13:42 <basti_> still, ":" isn't of any use after "error"
12:13:47 <basti_> (well it might be, but, hey...)
12:14:24 <Cale> toast: did you see my updated version? It should compile
12:14:24 <basti_> error : (\x->(17::Int)) : []
12:14:30 <basti_> > error : (\x->(17::Int)) : []
12:14:30 <lambdabot>  add an instance declaration for (Show ([Char] -> Int))
12:14:36 <basti_> :D
12:15:50 <toast> ERROR "C:\Program Files\Hugs98\libraries\test.hs":4 - Cannot justify constraints in
12:15:50 <toast> explicitly typed binding  
12:16:10 <Cale> oh
12:16:18 <Cale> (Num a, Ord a)
12:16:25 <Cale> since you're using <
12:16:37 * basti_ nods
12:16:38 <basti_> cale is right
12:17:16 <toast> compiling :)
12:17:28 <toast> but the error isnt showing ;p
12:17:53 <toast> Test> squared -2
12:17:53 <toast> ERROR - Cannot infer instance
12:17:53 <basti_> are you using the value?
12:17:59 <basti_> oh
12:18:09 <toast> Test> squared (-2) ?
12:18:13 <basti_> yep
12:18:35 <toast> working, whoo hoo ;p
12:18:39 <basti_> thats the unary-minus problem
12:18:51 <basti_> haskell will read everything but ( - ... ) as binary minus
12:22:46 <goron>  >(\x->x*x) (-1)
12:22:53 <goron> >(\x->x*x) (-1)
12:23:20 <basti_> " "?
12:27:17 <machack666> @hoogle (a->b) -> a -> b
12:27:17 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
12:27:17 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
12:27:17 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
12:36:52 <machack666> here's the signature of the function I'm working on:
12:36:53 <machack666> deepZipWith :: (a -> b -> c) -> [[a]] -> [b] -> [[c]]
12:37:17 <machack666> @hoogle (a -> b -> c) -> [[a]] -> [b] -> [[c]]
12:37:18 <lambdabot> No matches, try a more general search
12:38:31 <machack666> I can hack and slash my way through it, but it seems like there's a more elegant approach than the way I would do it. :)
12:44:27 <ndm> what does deepZipWith do?
12:44:37 <ndm> sounds like map zipWith in some way
12:45:37 <machack666> deepZipWith keeps the structure of [[a]], but returns the elements as if you had zipWith f (concat as) bs
12:46:03 <machack666> in other words, we use progressive elements of bs to apply
12:46:20 <machack666> map . zipWith would reuse the first elements of bs.
12:46:42 <machack666> s/.//
12:47:02 <ndm> oh, ok
12:47:25 <ndm> that is quite specialised
12:48:00 <machack666> I suppose it is...
12:48:02 * shapr sproings
12:49:37 <ndm> shapr, what happenedto all the april fools postings you came up with?
12:50:08 <toast> how do i add an element to a list ?
12:50:14 <basti_> toast: you can prepend it
12:50:19 <basti_> > 'a' : "bcde"
12:50:20 <lambdabot> "abcde"
12:50:51 <toast> thx
12:51:08 <toast> head("1,2,3")
12:51:15 <basti_> > head [1,2,3]
12:51:16 <lambdabot> 1
12:51:27 <toast> tail [1,2,3]
12:51:37 * toast slaps lambdabot around a bit with a large trout
12:51:52 <basti_> have a closer look at the lines we wrote.
12:52:06 <toast> > tail [1,2,3]
12:52:07 <lambdabot> [2,3]
12:52:09 <toast> :D
12:52:36 <basti_> :D
12:53:38 <gadolin> hey, i get an error on line leqI :: (Enum a) -> (a,a) -> Bool , "possibly incorrect indentation", what it can be?
12:53:48 <gadolin> leqI :: (Enum a) -> (a,a) -> Bool 
12:54:18 <basti_> a) Enum is a class
12:54:32 <basti_> b) incorrect indentation would make me search before that line, if i forgot something
12:54:37 <basti_> like a parenthensis or something
12:54:41 <sieni> is there some shorter way of dropping nth element of a list except saying something like: 
12:54:51 <sieni> >  (\n l -> (take n l) ++ (drop (n+1) l)) 5 [0..10]
12:54:51 <lambdabot> [0,1,2,3,4,6,7,8,9,10]
12:54:53 <gadolin> do i have to import Enum?
12:55:17 <basti_> gadolin: Enum is not a type. It is a class.
12:55:24 <basti_> you can put the constraint "Enum" on a type variable.
12:55:38 <basti_> just don't mention it, haskell might be smart enough to figure it out
12:56:31 <Lemmih> > let lst = [0..10]; n = 5 in [ x | (x,i) <- zip lst [0..], i /= n]
12:56:32 <lambdabot> [0,1,2,3,4,6,7,8,9,10]
12:58:05 <machack666> @pl (\xs -> take 5 xs ++ (tail $ drop 5 xs))
12:58:06 <lambdabot> ap ((++) . take 5) (tail . drop 5)
12:58:25 <machack666> @pl (\xs n -> take n xs ++ (tail $ drop n xs))
12:58:25 <lambdabot> ap (ap . ((++) .) . flip take) ((tail .) . flip drop)
12:58:43 <Lemmih> sieni: But why do you want to drop the nth element of a list?
12:59:44 <gadolin> the problem was line above(other definition)        | otherwise False   insted of | otherwise = False   ,thx 
12:59:53 <sieni> Lemmih: Why wouldn't I want to?
13:01:39 <sieni> Lemmih: why would anybody want to drop n elements from the beginning of the list or take n elements from the beginning of the list?
13:02:17 <Lemmih> sieni: Because they picked the wrong data stucture?
13:03:19 <Lemmih> sieni: Because their teacher told them to?
13:03:40 <toast> is there any build-in sort fonction in haskell ?
13:04:01 <Lemmih> > sort "Hello world"
13:04:02 <lambdabot> " Hdellloorw"
13:04:19 <basti_> it's in Data.List, in case you wonder
13:04:48 <sieni> Lemmih: one might want to e.g. play Haskell golf
13:05:09 <toast> thx
13:05:32 <toast> Prelude> sort "bdca"
13:05:32 <toast> ERROR - Undefined variable "sort"    
13:05:40 <toast> i gotta load the module right
13:06:15 <basti_> yup
13:06:21 <basti_> in the interaction :m Data.List
13:06:25 <basti_> otherwise, "import Data.List"
13:06:43 <SuperTails92> with what compiler?
13:06:55 <basti_> SuperTails92: hm?
13:07:08 <SuperTails92> oh, never mind
13:07:18 <toast> ERROR ".\Data\List.hs":210 - Ambiguous class occurrence "Eq"     
13:07:21 <toast> wtf
13:07:25 <basti_> .?
13:07:27 <basti_> \?
13:07:35 <basti_> wtf? ;)
13:07:42 <basti_> you're on windows and your thingie is broken? ;)
13:07:50 <SuperTails92> yeah, wtf?
13:09:07 <SuperTails92> in hugs, "ERROR - Cannot find module "Data.List""
13:09:18 <basti_> oh, hugs might be a little different
13:09:32 <Lemmih> It's :l Data.List in hugs.
13:10:26 <SuperTails92> ah
13:11:03 <toast> doesnt work still ;p
13:11:12 <toast> Data.Char> :l Data.List
13:11:12 <toast> ERROR ".\Data\List.hs":210 - Ambiguous class occurrence "Eq"
13:11:12 <toast> *** Could refer to: Hugs.Prelude.Eq Data.Maybe.Eq Data.Maybe.Eq                    
13:11:27 <basti_> hugs sucks.
13:11:42 <toast> what do u use ?
13:11:47 <basti_> ghci6
13:12:29 <neologism> is hugs under developement or was the project closed?
13:12:50 <basti_> it's uhm...
13:12:55 <basti_> ...
13:13:04 <basti_> it developed some stench
13:13:10 <Igloo> It's still worked on
13:13:54 <neologism> is it going to support glasgow extensions etc?
13:13:59 <SuperTails92> no
13:14:02 <SuperTails92> afaik
13:14:05 <Igloo> It already supports some
13:14:50 <SuperTails92> it needs to be able to run ghc and then it'd be awesome
13:15:03 <basti_> hmm?
13:15:07 <basti_> ghci?
13:15:13 <SuperTails92> hugs
13:15:13 <Igloo> For slow values of "awesome"
13:15:22 <basti_> you want to try ghci.
13:15:50 <SuperTails92> it'd be for porting purposes
13:16:12 <neologism> I like hugs
13:20:48 <ndm> I like WinHugs
13:21:05 <ndm> it is developed
13:21:13 <ndm> and the WinHugs interface is brand new
13:21:33 <ndm> @where WinHugs
13:21:33 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
13:21:55 <jyp> shameless plug, huh?  :p
13:22:03 <ndm> SuperTails92: if you download that copy of Hugs, it will have Data.List, and most of the other GHC extensions you crave
13:22:12 <ndm> jyp: always :)
13:22:18 <jyp> :)
13:22:35 <ndm> @where Yhc
13:22:35 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
13:22:38 <ndm> @where Hoogle
13:22:38 <lambdabot> http://www.haskell.org/hoogle
13:22:53 <ndm> (might as well shamelessly plug more now i've been accussed of it :) )
13:23:17 <jyp> I must say I love hoogle ;)
13:23:45 <ndm> thanks :) - its still got lots of improvements to be made...
13:24:41 <jyp> 80% done... like every project, at every moment in time :)
13:25:20 <ndm> yep, but my biggest project is catch, and thats a lot less than 80% done
13:25:29 <ndm> thats the one for my phd, the others are just distractions ;)
13:26:58 <jyp> I crave a working hIde so we can plug all this good stuff in.
13:27:14 <jyp> I see Lemmih is back on it...
13:27:45 <jyp> I tried to compile it yesterday, but got sigsegv'ed.
13:28:16 <boy> @seen Lemmih 
13:28:16 <lambdabot> Lemmih is in #haskell. Last spoke 18 minutes and 44 seconds ago.
13:28:20 <boy> @seen dons 
13:28:20 <lambdabot> dons is in #haskell. Last spoke 7 hours, 57 minutes and 8 seconds ago.
13:28:44 <sieni> @seen sieni
13:28:44 <lambdabot> You are in #haskell and #haskell-blah. Last spoke just now.
13:29:42 <tennin> I like hugs' :find
13:30:10 <tennin> is there a way to get similar functionality /w ghci if you have the source?
13:30:32 <jyp> what does :find do ?
13:30:56 <SuperTails92> :find <name>        edit module containing definition of name
13:31:15 <jyp> ghci doesn
13:31:21 <jyp> 't have that.
13:33:05 <neologism> anyone tried to compile frags?
13:33:30 * jyp declines
13:43:26 <shapr> neologism: Frag builds and works for me.
13:50:52 <eamelink> Hey
13:50:57 <xerox> Oi.
13:51:10 <eamelink> I am trying to use EclipseFP, but I'm running into a small problem
13:51:22 <jyp> lucky you.
13:51:32 <eamelink> Thanks :P
13:51:54 <jyp> I had been running into a lot of huge problems :p
13:51:58 <eamelink> I started a project, it creates bin, out and src folders, I create a main module, with a main function
13:52:13 <eamelink> I built it, and I get a program 'theResult', which does work
13:52:17 <eamelink> So far so good :P
13:52:49 <eamelink> But when I try to run it from eclipse, I get the 'Could not locate the project's executable' error :/
13:53:31 <eamelink> And I have no clue at all about where eclipse is looking for the projects executable, or how I can tell it that it really is there :P
13:54:31 <eamelink> Alright
13:54:33 <eamelink> But it works now
13:54:39 <eamelink> Documentation really does work
13:54:42 <eamelink> Great 
13:55:06 <eamelink> Thanks for all the help, the mere joining of this channel had a great inspirational value
13:56:26 <jyp> You're welcome
13:56:31 <jyp> feel free :)
13:57:28 <eamelink> Yeah, I do
13:57:52 <eamelink> Well, time for some haskell practice :)
13:58:19 <jyp> An area where we'll be able to help you more for sure :)
13:58:23 <machack666> @hoogle (a,b) -> (b,a)
13:58:24 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:58:37 <eamelink> jyp, thats good
13:58:46 <machack666> @hoogle swap
13:58:46 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
13:58:46 <lambdabot> Control.Concurrent.STM.TMVar.swapTMVar :: TMVar a -> a -> STM a
13:58:46 <lambdabot> System.Win32.Info.sM_SWAPBUTTON :: SMSetting
13:58:48 <eamelink> I'm currently following a course on haskell
13:59:29 <jyp> eamelink: good :) university ?
13:59:35 <eamelink> Yeah
13:59:47 <int-e> > (13*12*11*10) % (52*51*50*49)
13:59:48 <lambdabot> 11%4165
13:59:59 <eamelink> Actually I'm a physics student, but it came to my mind that haskell could be nice in that field
14:00:22 <jyp> As long as you have to program stuff, haskell is nice :)
14:00:35 <eamelink> Yeah, I do.
14:00:41 <tennin> eamelink: do you have any particular applications in mind?
14:00:51 <jyp> We have our famous friend david roundy that has apparently followed the same route.
14:01:01 <sieni> eamelink: physics is a nice field except for all the fortran users
14:01:06 <eamelink> Yeah
14:01:10 <eamelink> Fortran 
14:01:16 <eamelink> That sucks
14:01:27 <eamelink> Everybody uses it, especially in astrophysics
14:02:14 <eamelink> tennin -> I have written a laser-cooling simulation in C which I would like to rewrite in haskell
14:02:44 <eamelink> But for practice I thought an IRC bot would be great. I have made an IRC bot in Java and in C and in PHP in the past, that really works :P
14:03:18 <jyp> it's a one-liner in haskell
14:03:37 <jyp> import Lambdabot; main = Lambdabot.main
14:03:39 <jyp> :)
14:03:57 <eamelink> import LaserCoolingSimulation; main = LaserCoolingSimulation.main
14:04:04 <eamelink> Great :
14:04:06 * jyp laughs
14:04:15 <jyp> @bot
14:04:16 <lambdabot> :)
14:04:40 <eamelink> He's handy
14:17:59 <ARous1984> So...
14:20:50 <ARous1984> Program error: {guess instNum_v30 [] [3,6,9,1,7,4,0,5,8,1,7,8,3,2,5,6,4,9,2,5,4,6,8,9,7,3,1,8,1,5,4,3,7,2,9,6,4,0,6,8,5,2,3,1,7,7,2,3,9,6,1,5,8,4,5,9,1,7,4,3,8,6,2,0,3,7,2,1,6,9,0,5,6,4,2,5,9,8,1,7,3] ((instNum_v30 Num_+ (instNum_v30 Num_+Program error: {guess instNum_v30 [] [3,6,9,1,7,4,0,5,8,1,7,8,3,2,5,6,4,9,2,5,4,6,8,9,7,3,1,8,1,5,4,3,7,2,9,6,4,0,6,8,5,2,3,1,7,7,2,3,9,6,1,5,8,4,5,9,1,7,4,3,8,6,2,0,3,7,2,1,6,9,0,5,6,4,2,5,9,8,1,7,3] ((instN
14:20:50 <ARous1984> um_v30 Num_+ (instNum_v30 Num_+
14:20:58 <ARous1984> i get that error message...
14:21:03 <ARous1984> what does it mean? anyone know?
14:21:15 <ndm> ARous1984: can you show us your code?
14:21:19 <ndm> for teh guess function?
14:21:25 <ihope> @google we put the funk in funktion
14:21:27 <lambdabot> http://reddit.com/user/stesch/
14:21:45 <ARous1984> --This function just puts the first of the candidate list in a blank entry
14:21:45 <ARous1984> guess (x:xss) puzzle index n
14:21:45 <ARous1984>  | length x > 1 = enterIntoPuzzle puzzle index (x !! 0)
14:21:45 <ARous1984>  | otherwise = guess xss puzzle (index+1) n
14:21:56 <ndm> guess []
14:21:59 <ndm> crashes i t
14:22:02 <ARous1984> ah
14:23:49 <ARous1984> thanks
14:24:23 <glasser> because it's only defined for args that match (x:xss), which [] doesn't
14:25:14 <ARous1984> ah
14:25:15 <ARous1984> thanks
14:26:08 <ndm> ARous1984: x !! 0 == head
14:26:16 <ARous1984> ?
14:26:24 <ihope> x !! 0 = head x, rather
14:26:25 <ndm> x !! 0 takes the first element from a list
14:26:27 <ndm> head x
14:26:29 <ARous1984> oh right yeah
14:26:32 <ndm> does exactly the same
14:26:39 <ihope> And head is probably faster.
14:27:16 <bolrod> bwah
14:27:30 <bolrod> compiler may fidle around with things so it doesn't really make any difference
14:27:31 <bolrod> :p
14:27:44 <ihope> True.
14:28:04 <ihope> Pre-matching and all that stuff...
14:29:02 <ndm> but i know certain proof checkers will perform betteron head than !! 0
14:29:13 <ndm> and also Yhc/Hugs will both be faster with head rather than !!
14:29:18 <ARous1984> k
14:29:21 <glasser> and plus who wants to be !! reading !! code full of !! exclamation points !! ?
14:29:25 <ndm> but mainly its just nicer, i think
14:29:35 <bolrod> ;)
14:29:47 <ARous1984> @info
14:29:48 <lambdabot> Unknown command, try @list
14:29:50 <ARous1984> @list
14:29:50 <lambdabot> list [module|command]. Where modules is one of:
14:29:50 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda version vixen where
14:29:53 <bolrod> it probably depends on the situation
14:29:58 <ARous1984> @version
14:29:58 <lambdabot> lambdabot 3p388, GHC 6.4.1 (Linux i686 3.20GHz)
14:29:58 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:33:37 <ihope> > 2+2 where 2=2.5
14:33:38 <lambdabot> 4
14:33:59 <xerox> ?!
14:34:00 <lambdabot> Not enough arguments to @.
14:34:39 <ihope> It's creating a thunk to match 2 against 2.5, then discarding the thunk. :-)
14:34:49 <ihope> > let Nothing = Just 4 in Nothing
14:34:50 <lambdabot> Add a type signature
14:34:56 <ihope> > let Nothing = Just 4 in Nothing :: Maybe ()
14:34:57 <lambdabot> Nothing
14:35:17 <ihope> > read "3"
14:35:18 <lambdabot> Add a type signature
14:35:28 <ihope> Shouldn't all those be Integer by default?
14:35:56 <glasser> Huh, I didn't know you could 'let' type constructors
14:36:03 <bolrod> > let 2.0=2.5 in 2.0+2.0
14:36:03 <lambdabot> 4.0
14:36:06 <bolrod> ;)
14:36:11 <ihope> glasser: you can, but nothing happens.
14:36:31 <monochrom> > let Nothing = Just (4::Integer) in Nothing :: Maybe String
14:36:32 <lambdabot> Nothing
14:36:37 <ihope> As I said, it creates a thunk to match Just 4 against Nothing, then discards it.
14:36:51 <ihope> > let Just x = Nothing in Just x :: Maybe ()
14:36:51 <monochrom> You can let pattern.
14:36:52 <lambdabot>  Irrefutable pattern failed for pattern Data.Maybe.Just x
14:37:07 <monochrom> > let (_,x,_) = (1,2,3) in x
14:37:08 <lambdabot> 2
14:37:25 <monochrom> "Nothing" is just another pattern like (_,x,_)
14:37:47 <glasser> Oh, I see.
14:38:00 <ihope> Now, was it Shakell or Rhotor that used some operator to mean "\x y z -> if x z matches then x z else y z"?
14:38:02 <glasser> So it's analagous to:
14:38:09 <glasser> > let Just x = Just "hi" in x
14:38:10 <lambdabot> "hi"
14:38:14 <monochrom> "Nothing" is a data constructor, not a type constructor.
14:38:20 <glasser> but Nothing just happens to be a degenerate case
14:38:25 <glasser> monochrom: oops, that's what I meant
14:38:29 <monochrom> Now you get the hang of it.
14:38:46 <ARous1984> how hard is backtracking in haskell?
14:39:12 <glasser> ARous1984: easy, you can write code in a monad like the list monad or a fancy backtracking monad
14:39:19 <glasser> and it basically becomes something like 
14:39:40 <ARous1984> like in a sudoku puzzle, for a given entry, branching on every possible guess and then rolling back if a particular branch leads to a wrong solution
14:39:45 <glasser> > do { a <- [1,2,3]; b <- [a+1, a+2]; return (a,b) }
14:39:46 <lambdabot> [(1,2),(1,3),(2,3),(2,4),(3,4),(3,5)]
14:39:55 <glasser> that's without any actual backtracking, but
14:40:31 <glasser> > do { a <- [1,2,3]; b <- [a+1, a+2]; if b > 3 then [] else return (a,b) }
14:40:32 <lambdabot> [(1,2),(1,3),(2,3)]
14:40:39 <glasser> that's not too clear I guess
14:40:46 <monochrom> [ x | x <- [0..10], even x ]   This will get you even numbers.  There is a backtracking when x is odd.
14:41:00 <int-e> > do { a <- [1,2,3]; b <- [a+1, a+2]; if b > 3 then fail else return (a,b) }
14:41:00 <lambdabot> Couldn't match `[]' against `(->) t'
14:41:24 <glasser> fail takes an arg I think
14:41:26 <int-e> > do { a <- [1,2,3]; b <- [a+1, a+2]; if b > 3 then fail "need an error message but it gets ignored" else return (a,b) }
14:41:27 <lambdabot> [(1,2),(1,3),(2,3)]
14:41:27 <Lemmih> > do { a <- [1,2,3]; b <- [a+1, a+2]; guard (b > 3); return (a,b) }
14:41:27 <lambdabot> [(2,4),(3,4),(3,5)]
14:41:46 <Lemmih> > do { a <- [1,2,3]; b <- [a+1, a+2]; guard (b <= 3); return (a,b) }
14:41:47 <lambdabot> [(1,2),(1,3),(2,3)]
14:42:03 <glasser> there's a nice nondet monad at http://www.haskell.org/hawiki/NonDeterminism though it might not be too easy to understand if you're new to monads
14:42:14 <monochrom> [ (x,y) | x <- [0..10], y <- [0..10], x+y==5 ]   This will exhaustive search and backtrack.
14:42:18 <glasser> (not to mention http://www.haskell.org/hawiki/SudokuSolver but it's still fun to write your own :) )
14:42:42 <glasser> > [ (x,y) | x <- [0..10], y <- [0..10], x+y==5 ]
14:42:43 <lambdabot> [(0,5),(1,4),(2,3),(3,2),(4,1),(5,0)]
14:42:45 <ARous1984> can't use monads : / old version of Hugs on our CS school machines
14:42:52 <monochrom> do { x<-[0..10]; y<-[0..10]; guard (x+y==5); return (x,y) }  another phrasing.
14:43:04 <glasser> there are pre-monad Hugses?
14:43:09 <ihope> Haven't monads been around since the stone age?
14:43:10 <monochrom> int-e: The list monad is a MonadPlus, you can use mzero.
14:43:22 <int-e> monochrom: good point. thanks.
14:43:25 <glasser> ah, guard is what I was trying to remember
14:43:29 <Lemmih> ARous1984: Is it more than 8 years old?
14:43:34 <ARous1984> its verson 2002
14:43:44 <ARous1984> but when i try to import say Monad.Control hugs says it cant read the file for it
14:43:45 <ihope> Anyway, if you don't have monads, you can redefine them >:-)
14:43:55 <glasser> oh, yeah, that just means it doesn't have hierarchical libraries
14:43:55 <monochrom> import Monad
14:44:12 <glasser> you still have the language feature of monads, and the old Monad library
14:44:23 <ihope> class Functor f where fmap :: (a -> b) -> f a -> f b
14:44:33 <monochrom> You can also use list comprehension.
14:45:26 <ihope> class Functor m => Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b; join :: m (m a) -> m a; x >>= y = join (fmap y x); join x = x >>= id
14:49:05 <ARous1984> what is the >>= operator?
14:49:34 <glasser> it's part of monads
14:49:53 <glasser> when you have do { x <- someMonadicOp; bla a }
14:49:57 <glasser> what's really happening is
14:50:05 <glasser> someMonadicOp >>= (\x -> bla x)
14:50:10 <glasser> (er, I meant bla x in the first one too)
14:50:23 <monochrom> When you write do { x<-blah; ...x... }  it is translated to blah >>= (\x -> ...x...).  So >>= is the sequencing operator for monads.
14:51:27 <ARous1984> where solve' a (x,y) []     = return Nothing
14:51:27 <ARous1984>         solve' a (x,y) (v:vs) = do writeBoard a (x,y) v   -- put a guess onto the board
14:51:27 <ARous1984>                                    r <- solve a (x+1,y)
14:51:27 <ARous1984>                                    writeBoard a (x,y) 0   -- remove the guess from the board
14:51:27 <ARous1984>                                    solve' a (x,y) vs      -- recurse over the remainder of the list
14:51:31 <ARous1984> so im trying to understand that code...
14:51:54 <ARous1984> im confused as to the r <- solve a (x+1, y) line
14:52:11 <xerox> The result of the 'solve' action is bound to the name of 'r'.
14:52:20 <xerox> Which is, in turn, discarded.
14:54:49 <ARous1984> why do they remove the guess from the board?
14:54:53 <ARous1984> how do they know if its correct or not?
14:55:23 <chrisbrown> whats the definition of 'writeboard' ?
14:57:09 <glasser> this is probably the second solver on the wiki page
14:57:25 <ARous1984> it just puts the value on the board
14:57:27 <ARous1984> it is
14:57:32 <glasser> oh, this is doing some sort of io monad thing?
14:57:38 <chrisbrown> what kind of monad is this? doesn't solve' always return Nothing?
14:57:46 <chrisbrown> unless it is IO
14:58:49 <glasser> I think it's so that when you're finished trying all of the vs for a given square and backrack up to try different squares for a previous guess, the square is still blank
14:59:50 <chrisbrown> well, yeah. so writeBoard and solve must manipulate state in some way
15:00:55 <glasser> yeah, it's IO, and if it gets to the end to does printSudokuBoard
15:00:55 <glasser> they sure do
15:00:55 <glasser> writeboard is writing to an IO Array or something
15:01:24 <xerox> It could even simply use State.
15:01:50 <glasser> are there nice State monads?
15:01:59 <glasser> er, State Arrays
15:02:45 <monochrom> Data.Array.ST
15:02:55 <chrisbrown> ah that makes sense, i suppose
15:03:18 <glasser> ah, Data.Array.Diff too
15:03:24 <glasser> er, not really. ignore me
15:03:36 <chrisbrown> is there not an easier way to solve sudoko without using monads?
15:03:52 <ihope> chrisbrown: monads are really nice once you get the hang of using them.
15:04:01 <glasser> well, it's tough to do sudoku without backtracking
15:04:18 <glasser> and a really simple monad (the list monad, say) can make backtracking *easier* than not using a monad
15:04:18 <astrolabe> You could do it without monads of course.
15:04:38 <astrolabe> But it would probably be more error-prone and less elegent.
15:06:00 <monochrom> Monads are easy.  Avoiding monads is difficult.
15:06:34 <ndm> monads are not easy, if they were, i would understand them :)
15:06:42 <ndm> (or alternatively, i'm really really thick)
15:07:01 <monochrom> Whenever I see some code for some theorem prover, constraint solver, ...  My first instinct is: is there not an easier way to code it using monads?
15:07:02 <xerox> Just try to write the code.
15:07:32 <ihope> Well, just wait a while. It should "sheesh, of COURSE!" soon enough...
15:07:46 <ARous1984> How does the list monad make backtracking easier?
15:07:48 <ihope> And do what xerox said :-)
15:07:51 <chrisbrown> ndm: Monads are easy once you understand them, like anything. It'll just click one day!
15:08:14 <ndm> chrisbrown: women?
15:08:19 <ihope> ARous1984: it automatically tries every possibility, and returns everything that actually works.
15:08:35 <chrisbrown> ndm: women are the exception ;)
15:08:47 <ndm> but an exception you can't catch
15:09:37 <monochrom> After I learned monads in Haskell I went back to Larry Paulson's ML book for some reason.  You know its final chapters flesh out a theorem prover, including parsing, substitution, tactics.  For each of those three things, I looked at the code and said, "gosh, this is screaming 'monad'!"
15:09:37 <xerox> Women aren't mathematical truths, with complete specification?
15:10:51 <chrisbrown> hahaha the "russian" acents in this film sound scottish
15:11:01 <mwc> I don't understand something about rank-2 polymorphism. I had a function foo :: Bar -> Baz -> ST s (STUArray Cell Double).
15:11:20 <mwc> I had a wrapper function that performed: runSTUArray $ foo p1 p2
15:11:22 <mwc> and it failed
15:11:27 <mwc> to typecheck
15:11:35 <mwc> the error was " type less polymorphic than expected
15:11:43 <ihope> Add type annotations?
15:11:48 <mwc> this puzzled me, for some reason, runSTUArray (foo p1 p2) worked fine
15:11:50 <ARous1984> Wait, ihope, how does it just do it?
15:12:05 <monochrom> remove type annotations? XD
15:12:14 <Revision17> Is there a way to throw an error in a non IO operation?
15:12:21 <araujo> Hello
15:12:28 <mwc> Revision17, foo = error "String Describing Error"
15:12:33 <mwc> error :: String -> a
15:12:33 <monochrom> @hoogle throw
15:12:34 <lambdabot> Control.Exception.throw :: Exception -> a
15:12:34 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
15:12:34 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
15:12:34 <chrisbrown> what is the type of $
15:12:36 <chrisbrown> ?
15:12:39 <chrisbrown> @type $
15:12:40 <lambdabot> parse error on input `$'
15:12:44 <chrisbrown> hmmm
15:12:45 <xerox> Maybe it's because there is a forall less.
15:12:46 <mwc> @type ($)
15:12:47 <lambdabot> forall b a. (a -> b) -> a -> b
15:12:52 <chrisbrown> thanks
15:12:52 <Revision17> monochrom: awesome, thanks :)
15:12:53 <monochrom> Try Control.Exception.throw, Revision17.
15:13:02 <mwc> basically, it's just a lowbinding function aplpicatoin
15:13:11 <xerox> Isn't it?
15:13:28 <ARous1984> ihope: Could you explain more about the Monad.List?
15:13:31 <mwc> foo (bar (baz (quo))) is harder to write than foo $  bar $ baz quo
15:13:47 <chrisbrown> it is - but the type of $ could be imposing a restriction on the type inference
15:13:55 <int80_h> exit
15:14:00 <ihope> ARous1984: well, the details are a bit weird. For example, do {b <- a; c <- f b; g c} grabs each element of a and binds it to b, then it takes each element of f b and binds it to c, before returning every element of g c.
15:14:04 <ihope> Let's see here...
15:14:08 <mwc> yeah, it could be
15:14:08 <mwc> the forals are lifted outward
15:14:33 <palomer> hrmph
15:14:43 <palomer> how do I get a diff from darcs between current repository state and last record?
15:15:00 <ihope> > let grabJusts x = do {(Just a) <- x; [a]} in grabJusts [Just 3, Nothing, Nothing, Just 5, Just 2] :: [Integer]
15:15:01 <lambdabot> [3,5,2]
15:15:45 <ndm> palomer: darcs whatsnew
15:18:13 <palomer> yes!
15:18:16 <palomer> darcs just saved my life!
15:18:18 * palomer kisses darcs
15:18:34 <chrisbrown> darcs is awesome
15:19:42 <chrisbrown> can i ask about classes and instance declarations?
15:19:57 <astrolabe> yes!
15:20:14 <chrisbrown> suppose i have a class...
15:20:21 <chrisbrown> class Foo a where
15:20:29 <chrisbrown> f :: a -> Int
15:20:55 <chrisbrown> what do the instances mean? am I just overloading f?
15:21:00 <chrisbrown> i.e....
15:21:04 <ihope> chrisbrown: yep
15:21:05 <monochrom> Yes you are overloading f.
15:21:06 <chrisbrown> instance Foo Bool
15:21:11 <chrisbrown> f x = True
15:21:28 <chrisbrown> thanks
15:21:30 <monochrom> instance Foo String where f s = length s   -- for example
15:21:31 <ihope> Well, but that's not a legal instance declaration...
15:21:38 <chrisbrown> ihope: oh?
15:21:44 <monochrom> missing "where"
15:21:48 <ihope> instance Foo Bool where f False = 0; f True = 1
15:21:51 <chrisbrown> ah sorry
15:22:02 <monochrom> Also type of f for Bool is Bool->Int
15:22:07 <chrisbrown> ihope: ofcourse f :: a -> Int
15:22:24 <chrisbrown> so a becomes the type in the instance decalaration
15:22:29 <chrisbrown> i.e. the "bool"
15:22:42 <ihope> class Foo a where foo :: Foo b => b -> a; bar :: a
15:23:20 <ihope> Then again, that instance declaration's pretty useless. :-)
15:23:34 <ihope> s/instance declaration/class/
15:23:53 <chrisbrown> ihope: why does Foo need the Foo b => bit?
15:24:26 <ihope> chrisbrown: without that, foo would have to translate *anything* to a.
15:24:39 <chrisbrown> what do you mean?
15:25:14 <ihope> class Foo a where foo :: Foo b => b -> a -- this means that foo :: (Foo a, Foo b) => b -> a
15:25:30 <ihope> class Foo a where foo :: b -> a -- this means that foo :: Foo a => b -> a
15:28:06 <chrisbrown> ihope: I'm not sure i understand - why do you need the context?
15:28:30 <ihope> chrisbrown: you mean the Foo a bit?
15:28:35 <chrisbrown> yeah
15:29:19 <ihope> Well, since the type variable a is bound in an instance declaration, it has to belong to that class...
15:29:42 <ihope> class Bar a where foo :: a -> Bar; bar :: Bar -> a
15:29:53 <chrisbrown> yeah...
15:29:59 <ihope> You don't expect foo and bar to work for *every* type, do you?
15:30:22 <ihope> They only work on types they've been defined to work on, i.e. those in the Bar class.
15:30:41 <chrisbrown> you mean the instances of Bar?
15:30:55 <ihope> chrisbrown: yep.
15:31:10 <chrisbrown> it can only work for the types that we create instances fol
15:31:45 <ihope> Aye.
15:31:59 <chrisbrown> but would it work without the Foo bit?
15:32:28 <ihope> chrisbrown: would what work without the Foo bit?
15:33:48 <chrisbrown> the Foo b => in the class Foo example above
15:34:20 <ihope> chrisbrown: well, that'd change the definition of Foo.
15:34:47 <chrisbrown> lets suppose it was just class Foo a where foo :: a -> Int
15:34:53 <ihope> Okay.
15:35:21 <chrisbrown> whats the difference between that and class Foo a where foo :: Foo a => a -> Int
15:35:32 <ihope> Nothing.
15:35:56 <chrisbrown> so why put the Foo a => bit in?
15:35:58 <ihope> The "class Foo a" bit implies a Foo a => on every type within the class definition.
15:36:05 <chrisbrown> ah ok
15:36:12 <chrisbrown> its implicit
15:36:20 <ihope> Yep.
15:36:22 <ihope> But outside the class definition, you need it.
15:36:43 <chrisbrown> so it knows which Foo instance to use?
15:36:55 <chrisbrown> if I have bar :: a -> int
15:36:58 <mwc> I have a disturbance in the force.
15:37:01 <chrisbrown> bar k = foo k
15:37:09 <mwc> Stack overflow on a normal compilation, runs fine on -O2
15:37:13 <chrisbrown> it would need bar :: Foo => a ->  Int
15:37:16 <mwc> something to do with how STUArrays are handled?
15:37:22 <chrisbrown> Foo a => a -> Int
15:37:29 <ihope> chrisbrown: yep.
15:37:51 <ihope> I should learn how to type your name. ch[tab]r[tab]
15:38:20 <chrisbrown> ihope:  thanks!
15:40:16 <chrisbrown> ihope: one last question
15:40:28 <chrisbrown> i have the class: class Typeable a where
15:40:29 <chrisbrown>   typeOf :: a -> TypeRep
15:40:52 <chrisbrown> and the following instance: instance (Typeable i) => Typeable (TypeInfo i) where
15:41:02 <chrisbrown> what does TypeInfo i refer to?
15:41:31 <chrisbrown> and why have the (Typeable i) => bit?
15:41:35 <ihope> Well, that instance thing means that for every i in Typeable, i is also in TypeInfo.
15:42:04 <chrisbrown> so TypeInfo must also be a class?
15:42:19 <ihope> Erm, I read that wrong.
15:42:43 <ihope> It means that for every i in Typeable, TypeInfo i is also in Typeable.
15:43:36 <chrisbrown> what is TypeInfo i?
15:43:42 <chrisbrown> what is i?
15:43:52 <ihope> i is the thing in Typeable.
15:43:59 <chrisbrown> a type variable?
15:44:03 <ihope> Yep.
15:44:05 <chrisbrown> ah
15:44:11 <chrisbrown> and Typeable is a class?
15:44:18 <ihope> Yep.
15:44:21 <chrisbrown> why not use a, why i?
15:44:32 <ihope> Dunno. It doesn't matter.
15:44:34 <chrisbrown> you can use any lowercase letter for a type variable?
15:44:50 <ihope> Not just lowercase letters.
15:45:16 <ihope> foo, foo3, foo', and fOoOoOo are all valid type variables, I think.
15:45:28 <chrisbrown> so I could have...
15:45:36 <chrisbrown> bar :: foooooo -> fooo232323
15:45:42 <ihope> I think so,
15:45:43 <xerox> Yup.
15:45:47 <chrisbrown> which is the same
15:45:50 <chrisbrown> bar :: a -> b
15:45:57 <ihope> Yep.
15:46:00 <chrisbrown> cool!@
15:46:08 <ihope> foo_ might also be a valid type variable...
15:46:17 <ihope> @kind forall foo_. foo_
15:46:18 <lambdabot> *
15:46:20 <ihope> Yep.
15:46:27 <chrisbrown> ok so instance (Typeable i) => Typeable (TypeInfo i) where
15:46:35 <xerox> @type let a = a in (a :: forall foo bar. foo -> bar)
15:46:35 <lambdabot> forall foo bar.
15:46:35 <lambdabot>                  foo -> bar
15:47:28 <chrisbrown> i must be in Typeable, and also TypeInfo i?
15:47:36 <ihope> Yes.
15:47:40 <chrisbrown> k
15:47:45 <chrisbrown> think im getting it
15:47:49 <ihope> TypeInfo i must be in Typeable, that is.
15:48:08 <chrisbrown> so there must be a instance Typeable (TypeInfo i) somewhere else?
15:48:24 <ihope> No, only instance Typeable i.
15:48:42 <ihope> If you have that, then the instance Typeable (TypeInfo i) comes automatically.
15:48:44 <chrisbrown> now im confused
15:49:55 <chrisbrown> but could i have both? or would that be an overlapping instance?
15:50:02 <ihope> Well, suppose Int is in Typeable.
15:50:12 <chrisbrown> ok...
15:50:16 <ihope> Then TypeInfo Int is automatically in Typeable.
15:50:30 <ihope> As in TypeInfo (TypeInfo) Int :-)
15:50:39 <chrisbrown> hold on, what do you mean Int is in Typeable?
15:50:43 <ihope> s/(TypeInfo) Int/(TypeInfo Int)/
15:50:59 <ihope> chrisbrown: I mean that there's an instance Typeable Int where...
15:51:03 <chrisbrown> ok
15:51:21 <chrisbrown> oh right i see
15:53:22 <chrisbrown> so, if I have instance (Typeable1 s, Typeable a)
15:53:22 <chrisbrown>        => Typeable (s a) where
15:53:22 <chrisbrown>   typeOf = typeOfDefault
15:53:52 <chrisbrown> that says...s must be in Typeable1 and a must be in Typeable
15:54:44 <ihope> Yep.
15:57:01 <chrisbrown> why if i have this instance: instance (Typeable i) => Typeable (TypeInfo i) where
15:57:04 <chrisbrown>     typeOf x = mkTyConApp _tc_TypeInfoTc [ typeOf (geti x) ]
15:57:12 <chrisbrown> do i get complaints of overlapping instances?
15:58:28 <ihope> Well, you'll have to get rid of any "instance Typeable (TypeInfo Foo)" if you also have "instance Typeable Foo".
15:59:44 <chrisbrown> why is it written (TypeInfo Foo) can it not be written instance (TypeInfo Foo) => Typeable Foo ?
16:00:48 <ihope> Well, that would require TypeInfo to be a class.
16:01:02 <ihope> If Foo is in TypeInfo, then it's also in Typeable.
16:01:18 <chrisbrown> I thought TypeInfo must be a class
16:01:22 <chrisbrown> what else can it be?
16:03:27 <ihope> A type constructor.
16:03:31 <ihope> Like Maybe.
16:03:37 <chrisbrown> oh of course
16:03:37 <ihope> And IO and [].
16:03:48 <chrisbrown> yes i see
16:04:39 <ihope> They're the functions of the type world...
16:05:28 <chrisbrown> but why would I have to get rid of "instance Tyeable Foo" if I have "instance Typeable (TypeInfo Foo)"
16:06:15 <ihope> If you have instance Typeable foo => Typeable (TypeInfo foo), then it's the instance Typeable (TypeInfo Foo) that you need to get rid of, because you already have one.
16:09:41 <chrisbrown> do you not mean instance Typeable foo that I need to get rid of?
16:10:19 <ihope> No, I don't.
16:10:46 <chrisbrown> supposeI have...
16:10:55 <chrisbrown> instance Typeable foo where blah
16:10:57 <chrisbrown> and...
16:11:16 <chrisbrown> instance Typeable foo => Typeable (Typeinfo foo) where blah
16:11:23 <chrisbrown> i get rid of the second?
16:12:52 <Revision17> is there a function in the prelude, other than splitAt toat will give me the first n elements of a list?
16:12:59 <Revision17> *that
16:13:16 <Korollary> > take 2 "Hey there"
16:13:17 <lambdabot> "He"
16:13:20 <chrisbrown> @type take
16:13:21 <lambdabot> forall a. Int -> [a] -> [a]
16:13:29 <Revision17> how did I miss that? thanks
16:13:46 <chrisbrown> Revision17: there is also drop
16:13:56 <chrisbrown> > drop 2 "hello"
16:13:56 <lambdabot> "llo"
16:14:04 <chrisbrown> just so you know...
16:15:17 <Pseudonym> My astrolabe only tells me the latitude.  Wow.
16:15:41 <Pseudonym> Honestly, that was in context.
16:15:42 <astrolabe> You have an astrolabe?
16:15:47 <Pseudonym> No.
16:15:55 <Pseudonym> Do you?
16:15:55 <astrolabe> :(
16:16:04 <astrolabe> No :( :( :(
16:16:14 <astrolabe> Maybe one day though.
16:16:39 <chrisbrown> ok folks g'night
16:48:22 <ARous1984> so...i want to do more than one thing after a guard in a function?
16:48:24 <ARous1984> is that possible?
16:48:34 <Pseudonym> What do you mean?
16:51:08 <ibid> ARous1984: if the question makes sense, then yes (but the procedure depends on the specifics of the question that you didn't explicate)
16:51:21 <Pseudonym> Yeah.
16:51:31 <Pseudonym> What is this "do [...] thing" of which you speak?
16:51:39 <Pseudonym> You mean monadic do-notation?
17:09:39 <Revision17> is there a built in function to convert a decimal to string with leading zeros?
17:10:22 <Revision17> I mean integer
17:10:30 <araujo> > show 10
17:10:31 <lambdabot> "10"
17:10:46 <Revision17> but how do I get "00010"?
17:10:53 <Revision17> without rolling it myself
17:11:03 <araujo> uh?
17:11:25 <araujo> > "000" ++ show 10
17:11:25 <lambdabot> "00010"
17:11:28 <araujo> :-P
17:12:06 <Revision17> if I have an integer of value 4; and I want the result to be 3 digits long; (function 4 3) is 004, (function 20 3) is 020
17:14:28 <sjanssen_> there isn't a built in function, but it's pretty straightforward to impliment
17:17:30 <Revision17> well yea, I just assumed that something important like string formatting like this would be in the standardl library
17:19:32 <araujo> > let g l num = f (l - 1) ++ show num where f 0 = [] ; f n = "0" ++ (f (n - 1)) in g 9 9
17:19:33 <lambdabot> "000000009"
17:20:22 <musasabi> Revision17: there is Text.Printf
17:20:39 <musasabi> I usually just do:
17:21:39 <musasabi> fmt n num = take (n - length s) zeros ++ s where zeros = repeat '0'; s = show n
17:21:51 <ihope> @hoogle Int -> a -> [a] -> [a]
17:21:51 <lambdabot> No matches, try a more general search
17:22:29 <Revision17> I think I'll use printf; thanks :)
17:24:09 <Cale> replicate n = take n . repeat
17:25:59 <araujo> > let f n l = (concat $ map show $ take (l - 1) (repeat 0)) ++ show n in f 9 9
17:26:01 <lambdabot> "000000009"
17:26:22 <araujo> mm...
17:26:37 <araujo> @pl f n l = (concat $ map show $ take (l - 1) (repeat 0)) ++ show n
17:26:37 <lambdabot> f = flip ((++) . join . map show . flip take (repeat 0) . subtract 1) . show
17:26:42 <araujo> :-]
17:26:44 <Cale> replicate!
17:27:02 * araujo flips
17:29:22 <Cale> > let f n l = replicate (l - length s) '0' ++ s where s = show n in f 9 9
17:29:23 <lambdabot> "000000009"
17:29:36 <Cale> > let f n l = replicate (l - length s) '0' ++ s where s = show n in f 20 3
17:29:36 <lambdabot> "020"
17:43:38 <ihope> @index printf
17:43:38 <lambdabot> Text.Printf
17:43:52 <ihope> @type Text.Printf.printf
17:43:53 <lambdabot> forall r.
17:43:53 <lambdabot>         (Text.Printf.PrintfType r) =>
17:43:53 <lambdabot>         String -> r
17:44:02 <ihope> Hmm.
17:46:02 <dons> > printf "%0.2f\n" (pi :: Double) :: String
17:46:03 <lambdabot> "3.14\n"
17:58:45 <lisppaste2> metaperl pasted "why is a1 of such a general type?" at http://paste.lisp.org/display/18563
17:59:58 <metaperl> I'm curious as to why even though I am using the number 1 in a program, the type system only guarantees the type of a1 to be Num and not Integral. Num is too general - it includes float. Please look at this program and help me please: http://paste.lisp.org/display/18563
18:00:54 <dons> why? because:
18:00:55 <dons> ?type 1
18:00:56 <lambdabot> forall t. (Num t) => t
18:01:10 <metaperl> but isn't 1 integral?
18:01:27 <metaperl> 1.0 is float
18:01:41 <dons> just give a type signature if you want a monomorphic form
18:02:00 <dons> otherwise, this function will work fine on a wide range of types you give it
18:02:06 <metaperl> why did haskell play for the most general type signature when it can see that a 1 is Integral? that is my point
18:02:19 <dons> the only constraints in there are the '1' and the +
18:02:28 <dons> and 1 isn't an Integer (I think you're asking)
18:02:36 <dons> oh, and the ==
18:02:39 <audreyt> metaperl: because 1+1.0 wouldn't work otherwise.
18:02:50 <metaperl> yes.. and 1 and + with a terminating condition returning 0 means that we only have 1 + 1 + ... + 1 + 0 which is Integral
18:03:11 <metaperl> but why cant Haskell see that 1 + 1.0 cannot happen in this program? only 0 and 1 are used
18:03:28 <dons> metaperl, theree is no Integral type. do you mean Integer?
18:03:35 <metaperl> did you see the program? http://paste.lisp.org/display/18563
18:03:39 <dons> the natural, unbounded numeric type?
18:03:56 <metaperl> dons: please look at this diagram and tell me why there is not INtegral type. It is right in the diagram: http://haskell.org/onlinereport/basic.html
18:04:28 <sjanssen_> there is an Integral type class
18:04:35 <sjanssen_> but not a type
18:04:43 <dons> Integral is a class, yep
18:05:33 <audreyt> metaperl: you can write
18:05:37 <audreyt> (1 :: Integral a =>a)
18:05:53 <audreyt> that will work
18:05:58 <dons> anyway, it's going to find the most general type. Here we only have to unify: a , Num a => a, and Eq a =>a. so no new constraints will be introduced
18:06:01 <audreyt> or even use a #ifdef for that
18:06:12 <ihope> data Integral' where Integral' :: Integral a => a -> Integral' -- is Integral' an Integral?
18:06:28 <metaperl> sjanssen: oh, thanks.. I thought Integral was a type. I ahve a lot to learn :)
18:06:43 <Revision17> I <3 haskell; I just wrote a cellular automata simulator, and the code to print out out all pretty like in 26 lines
18:06:51 <audreyt> ihope: newtype deriving Integral
18:07:11 <metaperl> Revision17: paste it in your blog at sequence.complete.org?
18:07:16 <ihope> That makes it easy, I guess...
18:07:17 <metaperl> i'd like to see it
18:07:38 <dons> Revision17, do you use Show or a Pretty class?
18:07:55 <dons> they often make writing such things very easy, Pretty classes. since you get printing combinators to play with.
18:07:57 <Revision17> I used show; I'm still new to haskell and don't know about Pretty
18:08:00 <ihope> newtype Monad' = forall a. Monad a deriving Monad -- this doesn't work :-)
18:08:26 <Revision17> metaperl: sure; I didn't count whitespace or test code in the line number, should I still post it?
18:08:44 <dons> ?doc Text.PrettyPrint
18:08:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint.html
18:08:47 <metaperl> Revision17: I guess. Just wrap it in a <code> tags and it should be OK
18:09:40 <ihope> Did I do that?
18:09:53 <dons> oh maybe.
18:09:59 <dons> i'm trying out an experimanetal patch
18:10:05 <dons> it's a bit iffy
18:10:32 <ihope> I had it evaluate 2^2^2^2^2
18:10:40 <dons> oh, then you know it was you
18:10:43 <dons> since you did it yesterday too
18:10:46 <dons> ;)
18:10:56 <ihope> But I didn't get any messages.
18:11:04 <dons> what do you mean?
18:11:15 <Igloo> Does it not have flood protection?
18:11:28 <ihope> lambdabot didn't send the result.
18:11:54 <dons> it does. but Cale and I are trying an alternative to line wrapping - sending out 350 line chunks, and letting the client do the wrapping
18:12:06 <dons> the downside is that it broke the @more and flood protecttoin
18:12:12 <Igloo> s/line/character/?
18:12:16 <dons> char
18:12:22 <dons> yeah
18:12:39 <Igloo> Is there some way of finding the line limit from servers these days?
18:12:45 <ihope> 512?
18:12:51 <dons> the irc spec says 512 or something like that
18:12:54 <Igloo> Other than binary search
18:13:00 <ihope> > 512 - "PRIVMSG #haskell :"
18:13:00 <lambdabot>  add an instance declaration for (Num [Char])
18:13:04 <dons> problem is that if we send two lines of 350 too quickly, we get kicked
18:13:05 <Igloo> I thought it was lower than that, but generally higher in practice
18:13:08 <ihope> > 512 - length "PRIVMSG #haskell :"
18:13:09 <lambdabot> 494
18:13:48 <ihope> So 494 characters of stuff, unless it's all one word that doesn't begin with :, in which case it's 495.
18:14:11 <Igloo> Oh, no, looks like you're right (except the above calculation neglects to subtract 2 for CRLF)
18:14:35 <ihope> The CRLF is counted as part of the message?
18:14:43 <ihope> 492 and 493, then...
18:16:31 <audreyt> ihope++ # rofl, just saw the quotefrom an early HWN
18:16:40 <audreyt> ihope :: My factorial function uses GADTs.
18:17:02 <ihope> :-)
18:17:07 <dons> hehe
18:17:17 <audreyt> ihope: have you played with object-oriented GADTs?
18:17:32 <ihope> audreyt: no, I don't think so.
18:17:55 <audreyt> http://www.haskell.org/hawiki/GADT_20with_20record_20syntax 
18:17:56 <audreyt> http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
18:18:02 <dons> audreyt, do you have an archive of super-magic haskell code that I don't know about somewhere? tools or hacks ?
18:18:43 <dons> I'm cataloging whats out there
18:19:11 <Revision17> metaperl: here it is: http://sequence.complete.org/blog/98
18:19:23 <dons> speaking of HWN, time to prepare a new issue.
18:19:24 * metaperl checks it out
18:19:54 <Revision17> blah the indentation got fusted
18:20:17 <metaperl> Revision17: you don't _look_ new to Haskell :) 
18:20:24 <Revision17> I am
18:20:39 <Revision17> monads are still scary as all hell
18:20:41 <Revision17> :p
18:20:46 <audreyt> dons: no, I don't think so :))
18:20:52 <metaperl> heh - what got you into Haskell?
18:21:28 <Revision17> O'Caml's not so awesome standard library and me wanting to know why people are so crazy about how monads are awesome
18:21:46 <dons> crazy is the word
18:21:56 <metaperl> Revision17: maybe formatting it with manual HTML option (the checkbox at bottom chooses which) and using <pre> would work?
18:21:57 <araujo> Revision17, all the cool kiddies are using monads!!
18:22:32 <Revision17> I know! I mean I've used them for IO and with Parsec, but when I try to write something more than trivial it make me X_X
18:23:11 <metaperl> Revision17: I used <pre> tags successfully here: http://sequence.complete.org/node/154
18:23:34 <tennin> monads were scary and gave me headaches while I was learning them, but it's amazing how natural and obvious they feel just a few months later
18:23:35 <metaperl> Revision17: are you looking to form a team for ICFP this year?
18:23:43 <tennin> Now, arrows are scary and give me headaches.
18:23:57 <ihope> :-)
18:24:13 <Revision17> alright, pre is used and indentation is fixed
18:24:19 <mux> mmm, what can I use in Haskell for I/O multiplexing?
18:24:45 <dons> mux, can you give an examppe?
18:24:48 <Revision17> metaperl: no, I'm not a good enough programmer for that; besides college work is killing me
18:24:59 <Revision17> I keep working on random cool projects like this instead of doing work
18:25:05 <metaperl> oh
18:25:05 <Revision17> :-\
18:25:08 <metaperl> what college are you in?
18:25:12 <Revision17> NJIT
18:25:15 <mux> dons: ie what you do with select() / poll() etc
18:25:22 <mux> in C and other imperative languages
18:25:33 <metaperl> interesting. I spent a couple of summers at Rutgers in Piscataway while I worked for AT&T
18:25:43 <metaperl> Jersey is pretty nice. Are you from there?
18:25:50 <mux> that means blocking on several I/O streams until one condition is met
18:25:53 <dons> mux, yes, but what are you trying to achieve? what would the code do? it might be quite different here.
18:25:55 <Revision17> metaperl: yes, I've lived my whole life here
18:25:56 <dons> ah ok.
18:25:59 <mux> usually data ready for reading/writing or a timeout
18:26:03 <dons> mux, using Control.Concurrency
18:26:08 <mux> dons: thank you.
18:26:14 <dons> you can block on handles
18:26:20 <dons> or use threads to block on MVars
18:26:25 <dons> there's quite a number of ways
18:26:30 <dons> another good abstraction are Chans
18:26:35 * araujo notices shapr is up there
18:26:40 <dons> these are self-blocking channels that you can wait on
18:26:42 <metaperl> @seen shapr
18:26:43 <lambdabot> shapr is in #ScannedInAvian and #haskell. Last spoke 4 hours, 43 minutes and 14 seconds ago.
18:26:47 <dons> ?doccs Control.Concurrent
18:26:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
18:27:00 <dons> and they're implemented in terms of select underneath
18:27:02 <ihope> You can stick a value into a monad, and you can take it partway out, but never completely. As well, you can apply normal functions to monadic values.
18:27:22 <dons> ?docs Control.Concurrent.Chan
18:27:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
18:27:27 <dons> ?docs Control.Concurrent.MVar
18:27:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
18:27:39 <mux> dons: I don't need threads at this point, but thanks for all the useful references
18:28:19 <dons> it would be quite easy to fork multiple threads to wait on each handle. dumping the input into a Chan when available
18:28:25 <dons> the main thread then just reads from the Chan
18:28:34 <dons> there's a few other ways
18:29:06 <mux> in that case there's only one I/O stream so little point in threads - but I need to multiplex with user input
18:30:43 <dons> lambdabot , for example, interleaves reading and writing a network pipe with evaluating commands. there's 4 handles to watch, and it runs two threads to watch them, feeding input back over a pair of Chans
18:31:24 <dons> anyway, lots of fun abstractions. you'll be able to find something that works
18:31:39 <mux> that makes me wondering if Haskell has bindings to use the more efficient and modern stateful primitives available nowadays (BSD kqueue()/kevent(), Linux epoll(), /dev/poll etc)
18:31:50 <dons> I guess i'm emphasising threads since they're so light weigth.
18:31:52 <mux> or maybe more simply, bindings to libevent
18:32:04 <dons> yeah, there's some patches to use epoll and kqueue, iirc.
18:32:08 <mux> cool.
18:32:23 <dons> but still, Haskell threas are about 100x faster than most things around (at least according to the language shootout)
18:33:42 <mux> that's nice, but threads don't fit for everything
18:34:02 <dons> yep. sure.
18:34:38 <mux> I'll give Haskell threads a try, I promise you :-)
18:35:08 <dons> ok. good. that's all I ask ;)
18:35:08 <audreyt> mux: Haskell can generate bindings pretty easily with FFI
18:35:13 * audreyt <3 FFI
18:35:33 <dons> forkIO was sent to us by the angels of concurrency
18:35:38 <dons> MVars are a gift
18:35:49 * mux adds FFI to the list-of-things-to-look
18:36:51 <mux> I suppose haskell threads provide blocking primitives quite different than seen with, say, libpthread? (mutexes, condvars, read/write locks etc)
18:37:38 <dons> yeah, it's a different world. things seem to work much much more easily.
18:37:54 <dons> i just cry thinking about the locks on every object in java
18:38:03 * mux loves locks
18:38:43 <mux> or rather, I love coding threaded stuff in this paradigm of locks
18:38:46 <mux> entertaining
18:38:55 <mux> and that's where you get the weirdest bugs ever :-)
18:39:13 <mux> and where gdb constantly shits itself not being able to read a stacktrace properly
18:39:16 <ihope> Locks?
18:39:18 <mux> mmmmmm.
18:39:27 <ihope> Oh, right... what's the thunk overhead?
18:39:28 <dons> you might want to play with STM one day, for lock-free data structures
18:39:36 <dons> I know audreyt is a big fan of STM
18:39:41 <mux> I like RCU
18:39:58 <ihope> I know unboxed types don't have much in the way of thunks :-P
18:40:05 <mux> lock-free too, but not sure if it's similar to what you're talking about
18:40:42 <mux> what about thread cancellations in haskell?
18:41:13 <ihope> data Value where Value :: a -> Value
18:42:25 <sjanssen_> mux: do you mean like Control.Concurrent.killThread ?
18:43:21 <mux> sjanssen_: yeah - are there ways to have some kind of "critical sections" in threads to avoid being killed at some for instance?
18:43:28 <mux> at some time
18:43:43 <dons> yep. 
18:43:46 <mux> well actually, this doesn't really matter with exceptions and such
18:43:46 <dons> you 'block'
18:43:49 <dons> sorry, bracket
18:43:51 <mux> nevermind
18:43:55 <dons> and 'finally' and so on. 
18:44:02 <mux> yeah, ok
18:44:03 <dons> killThread is just an exceptoin of a certain type
18:44:35 <dons> the 'Awkward  Squad' paper, mentioned in the iterature section of haskell.org is very useful. a good intro.
18:48:49 <dons> STM, is the new generation of concurrency primitives. Software Transactional Memory: a modular composable concurrency abstraction, fwiw
18:51:22 <mux> so, not the same at all as RCU :-)
18:52:02 <monochrom> "I love coding threaded stuff in this paradigm of locks / entertaining / and that's where you get the weirdest bugs ever :-)"  This goes a long way towards explaining widespread software unreliability in industry practice.
18:52:32 <mux> well I don't know for the industry practice, my code is reliable :-P
18:53:28 <ihope> dons: lambdabot needs another identification
18:53:33 <dons> ah, yes.
18:53:40 <dons>  hmm. how should this be done autoagically.
18:53:49 <dons> it should resend the passwd not just on startup ...
18:54:03 <dons> done
18:54:05 <ihope> If you get the can't-send-private-messages, identify and try again...
18:54:09 <dons> I'll write a patch
18:54:30 <dons> (since lambdabot knows how to identiify, it just forgets when it reconnects)
18:55:51 <dons> and this is happening since you started working out powers of 2 :P
18:57:38 <ihope> I guess you'll want to fix that one, too...
18:58:09 <dons> yes. two bugs.
18:58:15 <dons> well, it's 10k loc
18:58:20 <dons> so 2 bugs isn't too bad.
18:59:14 <ihope> And the every-token-in-a-type-goes-on-a-seperate-line bug :-)
18:59:34 <dons> oh, that's ghc.
18:59:44 <dons> if i update to 6.5, that goes away
19:00:13 <ihope> Do you get more problems?
19:00:20 <dons> the lambdabot-wrangler's task never ends
19:00:26 <ihope> :-)
19:00:44 <dons> no, just lazy. didn't install ghc 6.5 on the new box that lambdabot moved to. yet.
19:01:05 <ihope> @kind (- >)
19:01:05 <lambdabot> parse error on input `-'
19:01:58 <monochrom> Is 6.5 ready?
19:03:06 <ihope> It was still in development last time I checked.
19:03:47 <ihope> And if the speed new versions of NetHack are coming out is any indication of the speed new versions of GHC come out...
19:04:02 <ihope> ...we're going to be waiting quite a long time.
19:06:22 <monochrom> haha
19:07:36 <monochrom> I still think ghc progresses faster than nethack.
19:08:30 <monochrom> Also to sidetrack quite a bit, I don't believe in "lively development" as an absolute.
19:10:31 <monochrom> There are unsatisfactory vs satisfactory; there are released-often vs old-version.  All four combinations are possible.  I don't follow the popular logic that released-often iff satisfactory.
19:11:28 <monochrom> Some programs are released often because they are hopelessly buggy.  Some programs have not changed because they work.
19:12:02 <ihope> New versions of cat aren't released often, I imagine.
19:12:38 * mux has dropped nethack for ToME since some time now
19:12:45 <dons> 6.6 is a couple of months away. we all want smp ghc, now, don't we?
19:12:51 <ihope> What's ToME?
19:13:00 <mux> one of the numerous angband clones
19:13:10 <ihope> Ah.
19:13:20 <ihope> Why doesn't anybody clone NetHack?
19:13:21 <mux> www.t-o-m-e.net (protect your eyes, the site is terribly ulgy)
19:13:32 <ihope> I mean, there's Slash'EM, and...?
19:13:35 <mux> maybe because it's too simplistic when compared to angband
19:13:56 <ihope> Yes, that's true...
19:14:26 <ihope> But Angband's too big. You can't dig out an entire dungeon level very easily at all.
19:14:32 <mux> nethack is still cool, but I don't feel like playing it anymore since I first ascended
19:14:39 <ihope> And you don't lose as often. I demand loss!
19:14:50 <mux> heh. :-)
19:15:06 <mux> try ToME with, for instance, a yeek hermit mimic
19:15:11 <mux> or something equally weak :D
19:16:11 <ihope> Anyway, that site isn't as ugly as I thought it would be. You know... no flashing underlined bold italic red text on a cyan background with clipart animations :-)
19:16:38 <mux> heh! and 10megs animated gifs
19:17:52 <ihope> That'd be scary.
19:17:55 <mux> a very good resource for angband related games is angband.oook.cz
19:20:41 <ihope> Do I want the alpha2 or the alpha3?
19:21:09 <mux> I didn't evey try tome3 yet, I use 2.3.3
19:21:12 <mux> even
19:21:16 <ihope> Well, the only thing pointing toward alpha2 is filesize, so 3 it is...
19:21:30 <mux> apparently they changed a lot of things in tome3
19:22:45 <mux> ugh... I forgot my last char was dead already.  killed by a greater kraken. RIP
19:25:38 <dons> your Char is dead?
19:25:50 <dons> ;)
19:25:57 <ihope> > kill '&'
19:25:58 <lambdabot>  Not in scope: `kill'
19:26:07 <ihope> > Data.Char.kill '&'
19:26:08 <lambdabot>  Not in scope: `Data.Char.kill'
19:26:12 <mux> heh
19:26:51 <mux> Object changes:
19:26:51 <mux> - Objects can gain exp, on an item level basis. The One Ring now uses item leveling.
19:26:55 <mux> It starts out weak and grows in power the more it is used 
19:26:56 <mux> spiffy
19:27:00 <mux> ok, I'll try tome3 too :-)
19:28:09 <dons> ?type Control.Concurrent.forkIO ('!' `seq` return ()) >>= Control.Concurrent.killThread
19:28:09 <lambdabot> IO ()
19:28:10 <ihope> Woot, it crashed.
19:28:43 <mux> uncool
19:28:55 <mux> maybe 2.3.3 should still be preferred then
19:28:55 <ihope> dons: a fancy way to "maybe" evaluate a constructor?
19:29:13 <dons> ihope?
19:29:41 <ihope> dons: that forks off a thread which evaluates '!', then kills that thread.
19:29:48 <dons> yeah, you can always use threads or exceptions to maybe evaluate things
19:30:07 <dons> i use a similar trick to maybe call a class method, falling back to another defaault if it isn't implemented
19:30:14 <dons> a form of pseudo-runtime reflection
19:30:28 <dons> lambdabot '.' plugin works this way
19:34:01 <ihope> Okay, this one font refuses to be deleted.
19:34:29 <ihope> Oh, by the way, is there some Haskell "kill until dead" function?
19:35:06 <ihope> @hoogle ThreadID -> IO ()
19:35:06 <lambdabot> No matches, try a more general search
19:35:28 <palomer> glut really isn't for game programming
19:36:41 <dons> kill until dead? use killThread. it won't return until you know the exception is raised in the other thread
19:36:59 <dons> as long as the other thread isn't ignoring killThread exceptions explicitly
19:39:36 <metaperl> I'm confused on ex1.15 in "The Haskell Road..." it says "Write a function srtString :: [String] -> [String] that sorts a list of strings in alphabetical order" ... does it mean sort each string and return it at its same position in the list of Strings or does it mean return the list of strings so that they are ordered ?
19:40:01 <liyang> latter.
19:40:03 <wchogg> metaperl: I interpreted it as the latter.
19:40:16 <metaperl> oh ok
19:40:29 <dons> yeah, 'sort a list oof strings'
19:40:47 <liyang> Perhaps instead of `alphabetical' it should have said `dictionary', but the intended meaning is the same I imagine.
19:40:48 <metaperl> ah
19:41:27 <monochrom> Write both.  Use a random number to decide at runtime which to execute.  Use unsafePerformIO to obtain the random number.
19:42:25 <lambdabot> Issue 31 of the Haskell Weekly News is out: http://sequence.complete.org/
19:45:11 <ihope> dons: there's no catch-all that also gets killThread stuff?
19:45:30 <ihope> Unless some stupid/evil programmer makes one? :-)
19:45:56 <wchogg> I propose we combine those words into "stevil".
19:46:49 <dons> stuvil?
19:53:25 <ihope> Stuvil, yeah... but nobody'll know what it means.
19:53:58 <ihope> Of course, many people have attempted to combine he/she into some single word yet mostly failed...
19:57:36 <dons> 'they' seems to be the default. at least  here
19:58:19 <dons> 2nd person , plural is the harder one ;)
19:58:33 <dons> 'yous'? 'y'all'?
19:58:55 <palomer> yous is slowly coming into usage
19:59:04 <palomer> I'm thinking of using it
19:59:21 <dons> I don't know if its very elegant.
19:59:29 <dons> feels clunky
20:00:00 <mux> dons: thanks again, the awkward squad paper is a very good read, clear and precise unlike some other stuff I've read
20:00:11 <dons> no problems.
20:00:27 <dons> it's often used as a teaching text.
20:00:32 <dons> s/text/paper/
20:01:33 <dons> its more practical than many. less category-theoretic ;)
20:02:09 <palomer> it's shorter and unambiguous
20:02:15 <palomer> I see no reason not to use it
20:03:25 <dons> i don't know. it feels awkward in the mouth. it's difficult to get that extra 's' out at the end.
20:03:35 <dons> unlike, say, 'aint' which is very easy to say.
20:04:02 <dons> or, 'snuck'
20:04:15 <palomer> I find yous easier than aint
20:04:23 <palomer> for aint I need to show my teeth
20:04:45 <palomer> then again, it might be different depending on the accent
20:04:48 <dons> I think 'aint' might fit the aussie accent a bit better then. it's easy for me.
20:04:56 <dons> yeah
20:05:45 <dons> I can say 'aint' with just a flick of the tongue on the top of my mouth. no teeth, I think.
20:05:53 <boy> dons: hey
20:06:00 <dons> hey boy. no patch yet?
20:06:07 <dons> did you get 'darcs send -o' working?
20:06:47 <boy> dons: sorry i haven't had a chance to try dacrs -o yet.... i can't believe i am awake so early now.... i hope it won't be too late for me to try to send the patch in about 7 or so hours :|
20:07:18 <dons> what time is it? midnight? or 3am or so?
20:07:29 <boy> 6am
20:07:34 <dons> no, i can wait for the patch.
20:07:34 <boy> i just woke up :'(
20:07:52 <boy> usually this is the time when i go to sleep
20:08:20 <dons> ah
20:16:58 <mwc> Is there anything in the heirachial libraries that behaves like a multiset?
20:17:32 <monochrom> [a]  XD
20:18:09 <monochrom> I guess you'll mimic it with Map a Int
20:18:30 <monochrom> Unfortunately.
20:18:36 <mwc> Ugh
20:18:58 <monochrom> I also know that Map a Int is inadequate for some applications.  Unfortunately.
20:20:02 <monochrom> Someone should take Set code and make a MultiSet.
20:20:05 <Cale> It should get reasonable performance for most applications
20:20:25 <Cale> I suppose you could construct some invalid multisets that way
20:20:45 <Cale> but if you were to use a newtype, you could prevent that
20:22:12 <monochrom> The inadequacy is this.  You have five guys indistinguishable by == (you defined == that way) but distinguishable by some other means.  You want to store all of them in a multiset.  Map a Int won't do.
20:24:01 <mwc> for my purpose, I can write a special insert function
20:25:07 <mwc> I think that will handle it
20:31:22 <Poly> Hello! I'm new in this functional programming thing... I'm using Hugs98 and ghc. Can anyone explain me what monads are?
20:32:44 <gzl> look up the nomaware tutorial online.
20:33:01 <gzl> and the MonadsAsContainers article on the Haskell wiki.
20:33:38 <Poly> thanks a lot!
20:35:26 <Cale> @oldwiki MonadsAsContainers
20:35:26 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
20:38:57 <palomer> yay! php finally has goto!
20:39:08 <drakioned> this is a good thing?
20:39:14 <palomer> the feature I've been waiting for
20:41:43 <Cale> more importantly, come from
20:41:56 <mwc> SIgn of the coming apocalypse numbers 4442 and 4443 I guess
20:42:00 <Poly> I've been reading MonadsAsContainers at Wikipedia but as far as I understand, these monads should break the referential transparency
20:42:10 <Cale> Poly: Wikipedia?
20:42:18 <Cale> Poly: they don't at all
20:42:21 <Saulzar> Haskell has no goto in pure functions :(
20:42:47 <Cale> Lists form a monad -- return and (>>=) are just ordinary list functions for the list monad
20:43:01 <Cale> return x = [x]
20:43:09 <Cale> x >>= f = concat (map f x)
20:43:13 <Poly> No, sorry! That was a mistake! It's at Haskell wiki
20:43:23 <Cale> yeah
20:43:24 <Cale> :)
20:43:49 <Cale> They do nothing to break referential transparency -- what in what I wrote gave you that idea?
20:44:51 <Cale> (I wrote MonadsAsContainers)
20:46:09 <Cale> completely offtopic, this ukelele player is really quite good: http://video.google.com/videoplay?docid=1352016870638076087
20:52:36 <Poly> ahhh... nah. I got it!
20:52:51 <Poly> Thank's Cale!!!
20:54:07 <Poly> I'm printing your page now...
21:04:44 <mwc> Thanks be to MArray
21:04:55 <mwc> and to its chosen son, STUArray
21:05:15 <monochrom> All hail Stu!
21:05:29 <mwc> for I had thought it impossible to handle 16,000 element lattices in Haskell
21:05:36 <mwc> and had walked in the shadow of the valley of C++
21:05:48 <mwc> but the Simons art my shepherds
21:05:57 <monochrom> haha
21:06:15 <mwc> and their Monads and their Unboxing, do comfort me
21:06:45 <mwc> that's about the limit of my knowledge of psalms
21:06:55 <drakioned> umm, what does boxing or unboxing entail anyway?
21:07:21 <monochrom> unboxing => less memory and fewer dereferencing.
21:07:51 <mwc> but loss of lazyness
21:11:03 <Cale> as soon as you demand a single element of an unboxed array, every element is computed
21:11:28 <mwc> which is fine, since I need to do statistical computations over each element (mean, variance, skew, over and under critical)
21:11:31 <Cale> since the 'boxes' are essentially the runtime mechanism for laziness
21:12:45 <mwc> I was using normal arrays but kept getting stack overflows
21:12:58 <mwc> I was worried I was going to have to rewrite this all in C++
21:16:46 <mwc> are UArrays heap allocated?
21:17:58 <Cale> yeah
21:27:55 <palomer> do you guys prefer staring at the top or the bottom of your screens?
21:28:35 <Cale> middle
21:29:25 <monochrom> I tend to stare at the bottom.
21:29:35 <palomer> bottom it is!
21:37:09 <gzl> middle.
21:37:57 <rasfar> i don't stare it's impolite.  my screen stares at me though (top).
22:03:51 <mwc> palomer, huh?
22:04:09 <mwc> fwiw, I like to avoid focusing and soak up the entire screen at once
22:07:22 <dons> I use telepathic perception
22:14:42 <palomer> darcs uber alles
22:15:26 <interferon> heck yes
22:17:04 <dons> 1991, haskell@haskell.org:  It seems likely that many people will implement re-usable "software
22:17:07 <dons> components" in Haskell.  For example: such as lookup tables, AVL trees,
22:17:10 <dons> sets, bags, pretty-printers, and so on.
22:17:13 <dons> :)
22:19:02 <ibid> what was the context for that?
22:20:24 <dons> the very first public Haskell library
22:20:31 <dons> the origins of the hier libs and fptools
22:21:05 <dons> (I'm putting up news going back to the start of haskll@haskell.org on the wiki)
22:21:43 <sieni> hmm... on page http://www.haskell.org/hawiki/GlobalMutableState there is a comment '(In contrast, other "approved" uses of unsafePerformIO are perfectly safe.)' but no link to a page which lists and explains these "approved" uses.
22:24:58 <sjanssen> usually unsafePerformIO is okay if it doesn't break referential transparency
22:25:47 <mwc> I prefer to think of it as a Fauschian bargain
22:26:44 <sjanssen> do you mean Faustian?
22:28:11 <ibid> i tend to say "if in doubt, it is not appropriate to use uPIO"
22:28:59 <rasfar> burning bush (Faustian Fuchsia)?
22:30:12 <sjanssen> groan
22:32:50 <mwc> yes, Faustian
22:58:50 <mwc> Can I not make (Int,Int) an Instance of Random?
23:02:56 <Lemmih> mwc: How about making (Random a, Random b) => (a,b) an instance of Random?
23:03:33 <mwc> Oh, beauty
23:03:39 <mwc> I wish I'd thought of that :(
23:17:14 <falconair> is there a way I can get GHC through fink (on OS X)?
23:33:19 <dons> It's Feb 93, and the question you're asking yourself is: "Should you use MacGofer, or Concurrent Clean?" http://www.mail-archive.com/haskell%40haskell.org/msg01188.html
23:47:20 <ozone> dons: you're bored today :)
23:48:48 <dons> :P
23:49:02 <dons> I thought i'd write an episode of 'Cold Case' ;)
23:53:29 <dons> ah, "Type Inference Connsidered Harmful" http://www.mail-archive.com/haskell%40haskell.org/msg00494.html. "Too complex!"
23:55:50 <sieni> dons: maybe you should start a "gems" page in some wiki
23:57:04 <dons> ah , yes, that would be fun actually
23:57:12 <dons> i'm putting the milestones on the wiki.
23:57:21 <dons> but the funny things would also be good 
23:57:28 <dons> like the first argument about n+k fromm early 1991
