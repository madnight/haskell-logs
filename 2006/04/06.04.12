00:00:08 <sethk> and, of course, anyone else who might want to look
00:00:10 <mwc> RyanT5000, the question is, why do I *want* windows applications?
00:00:28 <RyanT5000> the reason windows is the most popular OS is because it has the most apps
00:00:39 <RyanT5000> Developers Developers Developers
00:00:40 <mwc> few of which have any use to me
00:00:45 <RyanT5000> microsoft has its shit in order
00:00:50 <mwc> it has the most apps that ware wanted by most people
00:00:51 <RyanT5000> mwc i don't care about your usage habits :)
00:00:55 <sethk> astecp, I've actually written a piece of a framework to allow NetBSD to use windows drivers, but unfortunately real life keeps intruding with work.
00:00:57 * astecp would dispute that, if this conversation seemed to be going anywhere
00:01:24 <bolrod> RyanT5000: the reason windows has the most apps is because it has largest market share
00:01:29 <RyanT5000> i care about the usage habits of the 95% of people who use windows
00:01:31 <mwc> RyanT5000, the point is that windows serves market. if that's where you feel you can make money, go to it
00:01:36 <RyanT5000> right, bolrod, but they didn't always
00:01:38 <RyanT5000> and how did they steal it
00:01:39 <mwc> linux and bsd serve other markets
00:01:50 <bolrod> they didn't start at 95% market shar
00:01:51 <bolrod> share*
00:01:53 <astecp> you cannot steal market share
00:01:55 <mwc> and I doubt that many apps from the windows market would be at all used in the linux/bsd marke
00:01:58 <astecp> this is not possible by definition
00:02:03 <RyanT5000> ok
00:02:06 <RyanT5000> "take it"
00:02:18 <sethk> With careful layering you can leverage your software to run everywhere.  There's significant up front cost to this, of course, but I always pay that cost.
00:02:24 <Korollary> sethk: How is BarcodeCommandTypes used?
00:02:36 <sethk> Korollary, it's a field in a configuration file
00:02:49 <sethk> Korollary, I'm building BarcodeCommand values from info in a config file
00:03:02 <RyanT5000> true sethk, but the competitors are the ones with the burdon to produce such a layer
00:03:14 <RyanT5000> you can't require dumbass developers to do that for you
00:03:29 <RyanT5000> why do you think Win32, and now .NET, is so bloated?
00:03:34 <sethk> RyanT5000, no, of course not, I do it for myself
00:03:36 <RyanT5000> they have every conceivable API
00:03:45 <Korollary> sethk: But what do you set the station fields to?
00:03:48 <RyanT5000> that's how they lure developers to them
00:04:00 <RyanT5000> or at least, how they did
00:04:02 <sethk> Korollary, those are in the command codes, they don't come out of the configuration file
00:04:18 <sethk> Korollary, perhaps I really need two types here
00:04:30 <bolrod> windows would be 5 times better if you could cut out all the crap, like ancient hardware support
00:04:39 <sethk> Korollary, in one case there is info from a bar code reader that I use to create BarcodeCommand values
00:04:39 <RyanT5000> true but it wouldn't sell
00:04:44 <bolrod> why not?
00:04:51 <sethk> Korollary, in the other case I'm basically describing the possible BarcodeCommand values
00:05:06 <RyanT5000> people want the ability to run windows on their old shit, and plug their old shit into windows
00:05:19 <RyanT5000> they do gradually cut support for some things
00:05:24 <sethk> Korollary, but even if my types aren't quite right, I think you see what I'm asking in general
00:05:29 <RyanT5000> like XP can't run on a 386, no matter how fast it is and with how much ram
00:05:46 * astecp has heard this argument before, but still doesn't see windows running on hardware >5yrs older than the OS
00:05:46 <sethk> RyanT5000, can't run on an IBM 370 either, but who cares?
00:05:49 <bolrod> RyanT5000: but you could have the choice to cut out all the crap
00:05:55 <bolrod> just like recompiling a linux kernel
00:06:09 <astecp> damn, this conversation is like a cross between a car accident and quicksand
00:06:15 <bolrod> :)
00:06:16 <RyanT5000> lol
00:06:16 <astecp> I'll come back when I'm less distractable :)
00:06:34 <bolrod> anyway.. one thing is for sure.. I dont like windows
00:06:37 <bolrod> I do like linux
00:06:38 <RyanT5000> that's a very interesting point bolrod
00:06:38 <dons> sethk, i'll just have a think about the code.
00:06:43 <bolrod> I'm ok with os x
00:06:52 <RyanT5000> why isn't windows more pluggable
00:06:54 <sethk> Korollary, dons OK, I'll post the real code if you want it to actually make sense
00:06:57 <RyanT5000> is it simply because it's harder to write that way?
00:06:57 <Smokey`> 'pluggable' ?
00:06:58 <RyanT5000> i doubt it
00:07:06 <mwc> RyanT5000, the package deal is part of how windows is marketed
00:07:08 <sethk> Korollary, I tried to pull out as much as possible to isolate the issue I was asking about
00:07:08 <bolrod> because everybody has to be able to install it
00:07:12 <RyanT5000> right
00:07:13 <bolrod> and then has EVERYTHING
00:07:18 <Korollary> sethk: I actually understand it from this snippet alone
00:07:24 <bolrod> (and have it take up 3GB of space)
00:07:31 <sethk> Korollary, good, that was the general idea.
00:07:32 <RyanT5000> but there's no reason that EVERYTHING couldn't be the default
00:07:33 <bolrod> while you use only 1 GB or so
00:07:40 <sethk> Korollary, so you don't have to look at 50 irrelevant issues
00:07:45 <RyanT5000> and "cut this crap" couldn't be an "advanced setting"
00:08:11 <RyanT5000> that'd probably take a pretty small team to make that happen
00:08:26 <bolrod> RyanT5000: look at 'cut out the IE6'
00:08:32 <bolrod> its not possible to cut it out of XP
00:08:42 <RyanT5000> lol i didn't mean a team of non-microsoft people
00:08:46 <Korollary> sethk: it appears that you want to abstract away things like station number, powerargument, etc. from the config file layer.
00:08:49 <bolrod> its more like...  'don't bother me with the IE6 icon'
00:08:51 <RyanT5000> i meant a subteam of the windows team
00:09:10 <RyanT5000> ie6 integration only exists because microsoft wanted an excuse to bundle, and they were under legal pressure
00:09:10 <bolrod> ahyeah.. I recently installed XP
00:09:18 <bolrod> I can tell you.. its 5 times harder then installing Ubuntu
00:09:19 <Korollary> sethk: it almost looks like a java interface
00:09:20 <sethk> Korollary, right.  but what I'm really getting at is whether I have to duplicate the information in the list of constructors
00:09:28 <bolrod> also takes 5 times more time
00:09:34 <RyanT5000> yeah i installed ubuntu recently
00:09:37 <RyanT5000> i'll agree
00:09:45 <sethk> Korollary, I have another type which describes what's in the config file, which has just the stuff that is common (doesn't vary by station)
00:09:48 <RyanT5000> look i have absolutely no respect for windows' implementation
00:09:50 <mwc> RyanT5000, and WMP, and all sorts of other technology. the point isn't that they want to bundle, the point is that they sell a bundle in the first place
00:09:55 <bolrod> I had to upgrade windows 5 TIMES! (plus reboots)
00:09:58 <bolrod> to get it up to date
00:10:01 <mwc> windows tries to be the be everything do everything platform
00:10:05 <RyanT5000> i have next-to-no respect to their overall design
00:10:09 <mwc> and to a good extend, they succeed
00:10:23 <RyanT5000> exactly
00:10:31 <Korollary> sethk: that looks like a subclass kind of abstraction
00:10:36 <RyanT5000> so what's the OSS plan-of-attack?
00:10:42 <mwc> isn't one
00:10:45 <RyanT5000> exactly
00:10:47 <RyanT5000> that's the problem
00:10:50 <mwc> if I wanted that, I'd get windows
00:10:52 <RyanT5000> that's why 95% of the world runs windows
00:10:55 <bolrod> I be for an OS x  type of installation
00:10:58 <bolrod> everything in 1 dir
00:10:59 <sethk> Korollary, yes.  but it isn't real; I'll post the real data structures if you want to see them.
00:11:03 <bolrod> thats simple
00:11:08 <mwc> bolrod, encap?
00:11:09 <bolrod> everybody can uninstall (delete)  a directory
00:11:21 <bolrod> instead of complicated uninstall systems on windows
00:11:29 <RyanT5000> well if OSS specializes in specialized OSes
00:11:37 <bolrod> ofcourse.. it has to have an uninstall feature (unlike osx)
00:11:46 <RyanT5000> there should be an effort to figure out what domains they're not currently competing in
00:11:49 <RyanT5000> and then do so
00:11:59 <mwc> that's not the point
00:12:04 <RyanT5000> how so?
00:12:09 <mwc> OSS isn't an army with Linus and RMS as Riechmarshalls
00:12:21 <RyanT5000> well i know that
00:12:21 <lispy> mwc: well put
00:12:22 <mwc> if I want to do something, I'll write the code to do it if it isn't already there
00:12:36 <RyanT5000> so is that an argument that OSS can't beat redmond?
00:12:38 <mwc> and I'll put it out to the community since I used their tools
00:12:46 <mwc> it's an argument that I'm not fighting them
00:12:49 <Korollary> sethk: so you have a case statement where for a SInitialize::BarcodeCommandTypes, you construct a StationInitializeCommand (with details) :: BarcodeCommand ?
00:13:02 <bolrod> RyanT5000: oss can't beat redmont because it can't guarantee support to companies when something breaks down
00:13:11 <bolrod> so they won't have anything to turn to when something doesn't work
00:13:15 <RyanT5000> i thought that was what RedHat sold
00:13:18 <RyanT5000> support
00:13:27 <mwc> RyanT5000, I write papers with Latex/Tetex. I write simulations in C++ or haskell with GCC or GHC
00:13:36 <mwc> I talk to the community through IRC
00:13:37 <bolrod> but can they sue the support team when something breaks down?
00:13:51 <RyanT5000> they can't on windows either
00:13:52 <mwc> OSS already does all I need it to
00:13:58 <sethk> Korollary, actually, no.  I have another type called BarcodeCommandSpec.  I just didn't want to put all the types into the paste which would obscure the question I was asking
00:14:06 <mwc> anyways, I'm going to go to bed and sleepo
00:14:08 <RyanT5000> microsoft isn't liable for windows breaking your data either
00:14:09 <lispy> bolrod: well, RH sells support of that nature and my university pays $$$ for it
00:14:19 <lispy> bolrod: which is a good thing, just saying...
00:14:30 <bolrod> thing with linux is... you don't need support
00:14:38 <bolrod> you just need someone with a little knowledge
00:14:43 <bolrod> install everything.. make it wor
00:14:43 <sethk> Korollary, essentially I have the enumeration in the config file and I'm going to produce a data structure in memory from it, which is the essential point to the question.
00:14:43 <bolrod> k
00:14:46 <bolrod> then leave it alone
00:14:53 <RyanT5000> well how is that different from windows?
00:14:57 <lispy> bolrod: but as you noted, sometimes companies need to at least think they can call someone if it breaks
00:15:02 <sethk> Korollary, but as it stands it really doesn't make much sense, so I can post the real code.
00:15:12 <bolrod> you need to reinstall windows every now and then when not set up PERFECTLY
00:15:36 <RyanT5000> yeah but that doesn't seem like a fundamental-enough difference
00:15:49 <RyanT5000> i'm not saying linux isn't way, way better technology than windows
00:15:57 <sethk> Korollary, I was trying to do a quick abstraction and I did more of a quack abstraction  :)
00:16:09 <bolrod> it's also a question.. do we buy microsoft... or hire someone to run linux computers
00:16:18 <RyanT5000> yeah
00:16:36 <bolrod> costs probably more to make someone run linux computers then to let someone run windows computers
00:16:44 <lispy> bolrod: where i work it's a no brainer because the software we need to use is windows only.  so servers get linux, desktops get xp
00:17:15 <bolrod> you can't make employees use linux
00:17:22 <bolrod> it'd be helpdesk hell
00:17:46 <Muad_Dib> Why enforce anything from your employees anyway? :P
00:17:51 <Muad_Dib> Software should be portable!
00:18:00 <RyanT5000> it isn't
00:18:14 <RyanT5000> should be != is
00:18:19 <lispy> Muad_Dib: what if it requires COM because integrating with Excel is really important?
00:18:26 <bolrod> can you write portable code with microsoft development tools?
00:18:36 <RyanT5000> you can, bolrod
00:18:45 <bolrod> like..  is it possible
00:18:50 <RyanT5000> yep
00:18:52 <bolrod> or is it something you can do easilly ;)
00:18:57 <RyanT5000> well
00:19:00 <bolrod> see
00:19:06 <RyanT5000> it's easy to write a console app
00:19:10 <RyanT5000> that's 100% portable
00:19:11 <RyanT5000> C++/stl
00:19:16 <RyanT5000> or even C++/boost
00:19:24 <Korollary> or even c++/qt/gtk
00:19:29 <bolrod> which windows user uses a console app
00:19:30 <RyanT5000> right
00:19:40 <RyanT5000> none
00:19:41 <RyanT5000> :P
00:19:41 <sieni> fltk!
00:19:46 <bolrod> they don't even know what it is mostly
00:19:51 <RyanT5000> yep
00:19:57 <RyanT5000> you can use SDL
00:20:01 <bolrod> my dad goes like.. Ey that looks like MS-DOS
00:20:07 <RyanT5000> to make audio/video stuff
00:20:15 <lispy> well, the commandline sucks in windows so it's understandable none of the programs use it :)
00:20:29 <bolrod> indeed it does
00:20:33 <RyanT5000> it's not really hard to write portable stuff in visual studio; it's just h ard to resist the temptation not to
00:20:33 <bolrod> they should use something like bash
00:20:48 <RyanT5000> for instance, .NET is an enormous library of windows-specific code that microsoft has written for you
00:20:56 <RyanT5000> and, tbh, it's damn nice
00:21:15 <bolrod> I have never seen vidual studio t
00:21:18 <Korollary> free code is nice. See Ruby.
00:21:31 <lispy> in our case, we need to integrate with the tools/software that people are already using (basically Office).  How can you write portable code that does that?
00:21:35 <sieni> in c++ it's even relatively easy to hide platform-dependent stuff behind abstract classes
00:21:40 <sethk> korollary, http://paste.ubuntu-nl.org/12079
00:21:48 <RyanT5000> hm, you probably can't, lispy
00:22:02 <sethk> Korollary, unfortunately the format of the bar code labels that are being scanned are inherited from an earlier version of the system
00:22:18 <sethk> Korollary, so don't blame me for that part of the bad design.  You can blame me for all the other parts.  :)
00:22:22 <lispy> RyanT5000: if there exists a CORBA <-> COM bridge you'd probably be okay
00:22:32 <RyanT5000> true
00:22:49 <sethk> Korollary, but it is a lot to go through; I'm just putting up there in case you want to see it; don't feel like you have to go through it if you aren't in the mood.
00:22:49 <RyanT5000> well to say the least it'd be significantly harder
00:23:04 <lispy> RyanT5000: and probably buggy
00:23:07 <Korollary> sethk: yes, "decodeCommand str" is just as I expected.
00:23:10 <RyanT5000> yep
00:23:24 <sethk> Korollary, you can see where I kludged in a insert into a map for testing purposes.
00:23:45 <lispy> http://www.engr.sjsu.edu/fatoohi/wang-report/abstract.html
00:23:53 <bolrod> so.. will microsoft ever use a unix kernel + unix directory tree setup ?  :)
00:24:17 <lispy> bolrod: yes! on their own servers ;)
00:24:23 <bolrod> ;)
00:24:40 <bolrod> you can't disagree that the windows directory setup is the worst ever
00:24:52 <RyanT5000> definitely
00:25:00 <lispy> i'd say by glancing at that report that CORBA can talk to COM
00:25:19 <RyanT5000> bolrod: windows is technologically inferior, there is no doubt
00:25:36 <RyanT5000> the mystery is why they always win
00:25:44 <RyanT5000> it's not so much of a mystery
00:25:58 <RyanT5000> but i would think there would be some ways of assaulting their position
00:26:06 <RyanT5000> that's all i'm saying :)
00:26:12 <sieni> well... they are pretty much stalled. I'm in doubt whether they will ever release Vista
00:26:21 <RyanT5000> hm
00:26:26 <bolrod> http://ask.slashdot.org/article.pl?sid=06/04/11/170215&from=rss    << this is why they win?
00:26:46 <RyanT5000> do you think they'd conceivably put off vista past 2009?
00:26:53 <RyanT5000> i mean you can't think they'll stall on it forever
00:27:00 <bolrod> when did XP launch?
00:27:08 <RyanT5000> 2002-2003ish
00:27:21 <bolrod> yeah.. well..  then they will go without an OS release for?
00:27:23 <bolrod> a long time!
00:27:32 <bolrod> (ok.. and the 'windows media center'
00:27:42 <bolrod> which probably is windows XP with some extra apps
00:27:43 <RyanT5000> well i don't see microsoft dying before they put out vista
00:27:46 <RyanT5000> yeah it is
00:27:50 <RyanT5000> i don't count mce either
00:28:08 <bolrod> so when they put out vista
00:28:13 <bolrod> what the hell are they doing next
00:28:19 <RyanT5000> blackcomb,  i think it is
00:28:21 <bolrod> even shinier things?
00:28:25 <Korollary> sethk: heh, you're still writing "key <- return $ getKey command" (209) where you could just say let key = ...
00:28:25 <RyanT5000> which is everything they were going to do in vista
00:28:29 <RyanT5000> only they didn't
00:28:43 <bolrod> and that is?
00:28:55 <sethk> Korollary, yes, sometimes, but then I end up with lots of let in do ... let  ... in do ...
00:28:56 <RyanT5000> WinFS is one of the big things
00:29:05 <Korollary> oops. I got paged.
00:29:05 <sethk> Korollary, I think I need to use where, at the end, more, rather than let at the beginning
00:29:06 <bolrod> pfff
00:29:12 <bolrod> what would be so good about WinFS
00:29:25 <bolrod> just to make it harder to windows users to try linux?
00:29:30 <bolrod> they already did that with NTFS I guess
00:29:31 <RyanT5000> i dunno
00:29:49 <RyanT5000> although i think hierarchical file systems are totally retarded
00:29:59 <RyanT5000> i mean it's better than a flat file system
00:30:02 <bolrod> just adopt some open source file system
00:30:20 <RyanT5000> i think the whole directories/files paradigm is broken
00:30:21 <bolrod> is the ZFS open source?
00:30:40 <lispy> i think having a directory inside a directory is stupid because you wouldn't do it with a physical file cabinet ;)
00:30:43 <bolrod> what would you have rather then directories?
00:30:55 <bolrod> haha :P
00:31:02 <dons> sethk, you don't need 'in' when using 'let' in do notation
00:31:09 <lispy> and don't get me started on hard links....
00:31:10 <RyanT5000> lispy that's not the reason
00:31:16 <dons> i..e. do x <- f; let y = 2 ; j <- g ; return y
00:31:25 <bolrod> who uses hard links anyway
00:31:25 <lispy> RyanT5000: i know
00:31:31 <RyanT5000> k :)
00:31:34 <sethk> dons, hmm, the compiler seems to complain when I forget and leave it out.
00:31:37 <lispy> this sounds like a discussion from tunes.org
00:31:48 <dons> sethk. nope. should be fine. maybe its an indentation thing?
00:32:07 <sethk> dons, I don't think so, but I'll check.  When I'm not sure about indentation I put in {}; to see what happens.
00:32:11 <dons> i always use 'let' in do notation to bind pure things.
00:32:22 <sethk> dons, but I could have just typed something wrong and made the wrong conclusion.
00:32:25 <sethk> dons, I'll try it.
00:32:26 <dons> it is a good way to distinguish effects and pure computations that can be floated around
00:32:58 <bolrod> RyanT5000: imagine windows doesn't even have links
00:33:03 <lispy> heh, tunes switched to mediawiki too...i think we were some of the few cliki users back in the day...ah the memories...glad i switched.
00:33:13 <RyanT5000> windows has softlinks for directories and hardlinks for files
00:33:27 <bolrod> its not something you just make
00:33:31 <bolrod> and almost nobody knows about
00:33:31 <RyanT5000> yeah it is
00:33:35 <RyanT5000> that's true
00:33:36 <lispy> bolrod: it does have symlinks (and i don't mean shortcuts) but you need special tools
00:33:44 <bolrod> indeed
00:33:52 <RyanT5000> symlinks are only for directories, i think though, lispy
00:33:59 <lispy> system internals makes some tools, iirc
00:33:59 <bolrod> I don't even know how to make them
00:34:02 <sethk> dons, I just tried one, and I always get the same result.  The compiler says the last statement in a do construct must be an expression
00:34:05 <bolrod> but thats probably because I never use windows
00:34:20 <sethk> dons, it thinks the let has terminated the enclosing do
00:34:22 <RyanT5000> i used them to mount some stuff on a ramdisk
00:34:25 <RyanT5000> that's about it
00:34:27 <bolrod> ask a random windows user about links... if they know about them
00:34:30 <sethk> dons, unless I need to indent everything after the let
00:34:36 <bolrod> they'll be talking about shortcuts
00:34:44 <lispy> RyanT5000: is this the kind of FS you're thinking of? http://tunes.org/wiki/Persistence
00:35:07 <lispy> bolrod: shortcuts or http://...
00:35:13 <sethk> dons, having to indent every time I do the equivalent of a let is what I'm trying to avoid
00:35:20 <RyanT5000> http://tunes.org/wiki/Orthogonal_Persistence
00:35:33 <bolrod> lispy: hahahhaa  didn't even thought about that one 
00:35:35 <bolrod> :)
00:35:40 <sethk> dons, e.g.,  let name = (args !! 0)
00:36:10 <bolrod> to most windows users ->   e-mail === outlook
00:36:22 <sethk> dons, maybe I fat fingered something, I'll try again
00:36:37 <bolrod> and   ->    internet  === Internet Explorer
00:36:54 <lispy> bolrod: i dunno...FF and gmail are catching on
00:37:00 <bolrod> true
00:37:18 <lispy> but anway. i must sleep.  See ya later.
00:37:24 <bolrod> I must take a shower
00:37:26 <bolrod> and go to school
00:37:27 <bolrod> :)
00:37:38 <bolrod> gnight
00:38:16 <RyanT5000> yeah tunes' persistence is essentially what i want
00:39:36 <sethk> dons, I must have mistyped it before, it works for me now.
00:40:36 <bolrod> RyanT5000: http://video.google.com/videoplay?docid=-4134446112378047444&q=vista+feature&pl=true  
00:40:40 <bolrod> :)
00:43:06 <sethk> dons, it doesn't like two lets in a row?
00:43:21 <dons> should be ok. as long as they line up.
00:43:27 <dons> but you can avoid the word 'let'
00:43:37 <dons> if there's more than1 in a  row
00:44:03 <dons> do let x = 7
00:44:03 <dons>        y = 2
00:44:03 <dons>    print (x,y)
00:44:17 <sethk> dons, ok.
00:44:20 <RyanT5000> lol bolrod
00:45:09 <dons> sethk, make sure tabs aren't in the src messing things up.
00:45:23 <sethk> dons, I have no tabs.  I figured that out a long time ago  :)
00:45:43 <sethk> dons, there is apparently one case where it rejects it.  I'll post it.  It's not a problem, because it's easy to fix, but it's curious
00:45:44 <dons> I actually ahve this in my .vimrc:
00:45:45 <dons> syn match tabNasty display "\t"
00:45:47 <dons> hi link tabNasty Todo
00:46:06 <sethk> dons, it doesn't like:
00:46:06 <dons> yep - post away.
00:46:11 <sethk> foo x = do
00:46:18 <sethk>    let x = 1
00:46:20 <bolrod> RyanT5000: you also saw that 'history of windows'  with the apple text to speach as narrator?
00:46:20 <sethk>       y = 2
00:46:23 <bolrod> ;)
00:46:27 <sethk> abc <- whatever
00:46:37 <sethk> dons, but that's a dumb way to code anyway  :)
00:46:38 <dons> the 'y' isn't lined up with the start of the 'x'
00:46:38 <RyanT5000> lol
00:46:55 <sethk> dons, I know, but it was in my file
00:47:01 <sethk> dons, xchat has proportional fonts
00:47:13 <dons> and the 'abc' has to line up with the 'let'
00:47:41 <sethk> dons, yes, I did line everything up.  but let me make sure it isn't just another typo.
00:48:24 <dons> this is perfectly fine:
00:48:25 <dons> f c = do 
00:48:25 <dons>     let x = 7
00:48:25 <dons>         y = 2
00:48:25 <dons>     z <- getLine
00:48:27 <dons>     print (x,y,z)
00:48:53 <bolrod> RyanT5000: http://old.tuaw.com/2006/03/24/the-history-of-microsoft/
00:48:59 <bolrod> Very good!
00:51:49 <sethk> dons, this is kind of interesting.  where the compiler is objecting is a section I had used { } ; on, instead of using indentation.  Probably I need a semicolon, or I have an extra semicolon
00:52:38 <bolrod> did you use let  ?
00:52:40 <sethk> dons, must be, I took out the brackets and indented it and it's ok.  so I have either too much or too little punctuation
00:53:07 <sethk> dons, maybe it doesn't like   do { let
00:54:33 <bolrod> indeed
00:54:42 <bolrod> maybe..   do {  let {...} ; ..}
00:54:51 <bolrod> (dont know for sure)
00:55:12 <sethk> bolrod, looks sort of reasonable
00:56:40 <dons> ?bot
00:56:41 <lambdabot> :)
00:58:01 <bolrod> ?botsnack
00:58:02 <lambdabot> :)
00:59:21 <RyanT5000> botsnack?
00:59:29 <bolrod> ;p
01:00:14 <RyanT5000> is this tunes thing a serious effort?
01:00:41 <RyanT5000> i'm reading the spec, and it sounds like the kind of thing i would write, and then be pissed off at myself for not writing anything concrete
01:01:23 <bolrod> then you can start being pissed off right now
01:01:24 <bolrod> :)
01:01:35 <bolrod> ;)
01:01:37 <RyanT5000> lol
01:01:51 <RyanT5000> the fact that they feel they need to write
01:02:07 <RyanT5000> "Bit: A single discrete unit of memory with two possible states" makes me think they're totally full of crap
01:02:10 <sethk> dons, don't bother to look at what I posted, I already fixed some things and took out two types.
01:02:43 <RyanT5000> oh, also that's from 1.8.2003
01:02:50 <bolrod> RyanT5000: is that quantum bit blah memory something?
01:02:59 <bolrod> erh
01:03:04 <RyanT5000> no that's just a definition of a bit
01:03:09 <bolrod> memory works with having 2 possible states!
01:03:15 <bolrod> either 0 or 1
01:03:18 <RyanT5000> yep
01:03:23 <RyanT5000> the spec is like 20 pages long
01:03:29 <RyanT5000> and it's at least half that kind of bullshit
01:03:30 <bolrod> quantum bit works with having infinite amount of states at the same time
01:03:32 <RyanT5000> and it's 3 years old
01:03:33 <bolrod> right?
01:03:37 <RyanT5000> something like that
01:03:44 <bolrod> and makes infinite amount of errors
01:03:47 <bolrod> and works infinitely fast
01:04:15 <RyanT5000> the idea with a qbit is to try every possibility at once, then just filter for the correct result
01:04:48 <RyanT5000> if i understand it correctly, it's basically equivalent to a nondeterministic turing machine
01:04:52 <tennin> I've found tunes a nice source of links to research papers pertinent to my own never-ending vaguely-defined ambitious projects
01:05:03 <RyanT5000> ah
01:05:07 <RyanT5000> sounds reasonable, tennin
01:05:24 <bolrod> :)
01:06:31 <bolrod> man.. I'm totally confused to what day it is
01:07:09 <RyanT5000> wednesday, 4 am here
01:07:13 <sethk> bolrod, it's 2006
01:07:17 <RyanT5000> 4/12/2006
01:07:20 <RyanT5000> 12.4.2006
01:07:27 <sethk> that's as close as I can get these days
01:07:56 <bolrod> 4 AM???
01:08:04 <bolrod> what the hell are you doing awake :)
01:08:15 <RyanT5000> lol
01:08:22 <RyanT5000> i will go to bed very shortly
01:08:25 <RyanT5000> i'm a night person
01:08:30 <RyanT5000> :P
01:08:33 <bolrod> ic
01:08:46 <RyanT5000> i probably should've gone to bed at 2 or 3
01:08:53 <RyanT5000> but meh
01:08:57 <RyanT5000> the joys of not having a job :P
01:08:58 <bolrod> :)
01:09:01 <bolrod> its 
01:09:03 <bolrod> Wed Apr 12 10:08:41 CEST 2006
01:09:04 <RyanT5000> i'm working like 16 hours a day on my game though
01:09:05 <bolrod> here
01:09:27 <RyanT5000> so with the exception of time i waste in #haskell (most of my time here is very *well* spent, though)
01:09:37 <RyanT5000> i'm working all the time
01:09:58 <bolrod> sounds like something I could do
01:10:02 <bolrod> *Yawn*
01:10:07 <bolrod> but I don't
01:10:08 <bolrod> hehe
01:10:39 <RyanT5000> yah, i haven't been
01:10:45 <RyanT5000> until like 2 weeks ago
01:11:32 <tennin> I've decided to read a novel this month, for a change of pace
01:11:50 <tennin> I am puttering around here and on LTU in order to avoid having to decide what novel to read.
01:12:11 <bolrod> read LOTR?
01:17:30 <Lor> Morning.
01:18:02 <tennin> good morning
01:19:09 <tennin> wait, qbits are equivalent to nondeterministic turning machines?
01:19:29 <tennin> er, qbit-based computers
01:20:39 <RyanT5000> i thought that was the point
01:20:42 <RyanT5000> i could be wrong though
01:21:15 <RyanT5000> basically i thought NP on a quantum machine was equivalent to P on a von-neumann machine
01:21:19 <tennin> that sounds reasonable but I've never seen it stated
01:21:35 <RyanT5000> i know they're supposed to ruin public-key cryptography
01:21:43 <RyanT5000> which is NP-hard
01:21:56 <bolrod> why would they ruin it?
01:22:11 <RyanT5000> because they can factor large numbers quickly
01:22:18 <RyanT5000> although i suppose they could only be capable of solving only a subset of NP problems
01:22:20 <bolrod> oh..
01:22:31 <RyanT5000> (i.e.: no NP-complete problems)
01:22:46 <RyanT5000> i think it's log(n) where n is the number you're factoring?
01:22:50 <RyanT5000> really damn fast, anyway
01:22:52 <tennin> yeah... I think I've read that quantum computers do not in fact allow NP problems to be done in P time in general
01:23:12 <RyanT5000> yah that sounds conceivable
01:23:15 <RyanT5000> anyway
01:23:32 <RyanT5000> me -> sleep -> moreHaskell
01:23:55 <bolrod> ;o
01:23:59 <tennin> not that I myself understand quantum computers at all
01:24:01 <bolrod> gnight
01:24:06 <RyanT5000> goodnight
01:24:09 <bolrod> me neither
01:24:17 <RyanT5000> yah me neither
01:24:21 <bolrod> lol
01:24:35 <bolrod> we sound like a bunch of windows users commenting on linux
01:24:37 <bolrod> :)
01:24:45 <RyanT5000> lol
01:25:06 <bolrod> Coffee doesn't sound a good drink before sleepink
01:25:10 <bolrod> like *
01:39:27 <newsham> /topic <bolrod> we sound like a bunch of windows users commenting on linux
01:48:50 <bolrod> newsham: ?
02:05:04 <sieni> #haskell people at Helsinki yesterday: http://www.hurmio.org/~ville/hs-hki/
02:10:20 <wolverian> hey, why wasn't I invited?
02:10:53 <bolrod> guess not!
02:12:39 <neologism> may I have a question?
02:13:09 * wolverian gives neologism a question 
02:13:15 <neologism>                 g <- newStdGen
02:13:15 <neologism>                 n <- rollDice (len `div` 10)
02:13:15 <neologism>                 return $ map (\x -> if x == n then '1' else '0') $ take l $ randomRs (0, 50) g
02:13:25 <neologism> what is the probability of having 1 in this string?
02:13:46 <neologism> (rollDice gives number 0.. (len `div 10`)
02:14:01 <neologism> and l = len
02:16:11 <mux> does someone have the IRC.hs file from lambdabot handy? I'd like it if I could avoid installing darcs
02:16:24 <ValarQ> sure...
02:16:56 <ValarQ> http://arda.no-ip.org/IRC.hs
02:17:07 <mux> thanks
02:17:32 <ValarQ> noprob
02:18:09 <xX[ReP]Xx> so mux is learning haskell!
02:19:16 <mux> xX[ReP]Xx: I did some l33t point-free code
02:19:19 <ndm> mux, one of the great things about darcs is that without installing it every repo has every file in plain text on teh web
02:19:32 <ndm> just go to the darcs url, and you can see all the files in the tree
02:19:40 <mux> I went there
02:19:53 <ndm> @where lambdabot
02:19:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
02:19:58 <mux> erm, not
02:20:02 <mux> cool thanks
02:20:13 <ndm> http://www.cse.unsw.edu.au/~dons/lambdabot/IRC.hs
02:20:36 <ndm> you can actually use wget to do a darcs checkout :)
02:21:19 <sieni> wolverian: Are you in Helsinki? It's a bit difficult to know who to ask, since I just looked at http://www.cse.unsw.edu.au/~dons/images/haskell/eu.jpg and concluded that there are not too many Helsinkians here.
02:21:46 <eivuokko> ndm, Tho that can have rather suprising effects as you get preferences set in the web-repo.
02:22:06 <eivuokko> (In case you mix wget and darcs)
02:22:09 <wolverian> sieni, ah. yes, I am. I'm not on the map apparently
02:22:24 <sieni> eivuokko: You could also "map" yourself :-)
02:22:26 <ndm> eivuokko: yes, its much easier just to use darcs
02:22:40 <ndm> i actually find darcsweb much easier to use than darcs most of the time for looking at history
02:23:07 <eivuokko> Yeah, depends.
02:23:21 <eivuokko> darcs certainly is limited by non-gui interface, imo.
02:23:27 <wolverian> sieni, not that I'm much of a haskeller yet, so I would have been boring company. :)
02:24:04 <eivuokko> sieni, I'm in Helsinki, sure.  What's up?
02:24:55 <ndm> i wrote a darcs gui once, unfortunately darcs isn't stable enough and predictable enough for it to be useful...
02:25:13 <eivuokko> Yeah :-S
02:25:24 <eivuokko> Getting better, slowly.
02:25:47 <eivuokko> Well, "slow" for normal pace of haskell progs on move.
02:26:06 <sieni> eivuokko: heh, that: http://www.hurmio.org/~ville/hs-hki/
02:26:08 <ndm> yes, its pretty impressive when it works, and pretty annoying when it doesn't
02:26:24 <eivuokko> sieni, Ah. :)
02:26:49 <sieni> It's easier to tell people about meetings, if they are on the Map ;-)
02:27:00 <wolverian> how does one get added to the map?
02:27:20 <eivuokko> I am not sure which map you talk about and how to go on adding myself on it (and if I should, even)
02:28:15 <sieni> wolverian: I think you can use google earth etc. to get your coordinates and then I suppose you /msg them to dons and he adds them
02:28:25 <sieni> eivuokko: http://www.haskell.org/hawiki/HaskellUserLocations
02:30:59 <wolverian> hrm, can I edit the data on the wiki to update the map? :)
02:31:11 <eivuokko> Isn't that wiki locked now?
02:31:33 <wolverian> oh, yes, it is.
02:32:05 <eivuokko> Ask dons :)
02:32:47 <wolverian> hm, lots of europeans on the map.
02:35:13 <xX[ReP]Xx> why is it locked?
02:36:05 * xX[ReP]Xx needs to update his coordinates
02:38:11 <flux__> wiki's don't support 'moderated pages', where the changes would be queued up to someone to merge them in, or discard?
02:38:19 <flux__> (s/'//)
02:41:09 <dons> the wiki isn't locked. you just have to log in.
02:41:36 <flux__> yet another account ;)
02:41:58 <neologism> uh.. is it normal that hugs compiles it fine but ghc gives me parse error?
02:42:06 <dons> hmm
02:42:18 <flux__> fortunately I don't count myself to be a 'real haskeller' yet, so I don't feel bad for not entering my location there ;)
02:42:20 <dons> its possible
02:42:23 <dons> in the presence of extensions.
02:42:57 <neologism> no extensions
02:43:17 <neologism> www.stud.fit.vutbr.cz/~xdivac02/Evo.hs
02:46:00 <neologism> can anyone see why ghc doesnt like it while hugs says its ok?
02:49:02 <dons> looking...
02:49:41 <dons> btw, initPop = (sequence .) . flip replicate . genOne
02:50:03 <neologism> might be.. now I want it to compile ;)
02:50:25 <dons> I see lots of tabs. i wonder ...
02:50:58 <dons> compiles here fine.
02:51:09 <neologism> uh?
02:51:46 <dons> $ ghci Evo.hs
02:51:47 <dons> Prelude Evo>
02:51:54 <dons> works fine.
02:52:05 <neologism> hm... doesnt work here
02:52:22 <dons> what error?
02:52:31 <dons> check you have the right version of the file?
02:52:31 <neologism> Evo.hs:127:37: parse error on input `{'
02:52:44 <neologism> uh.. you're right
02:52:53 <neologism> I am compiling differnt file then I am editing ;)
02:53:36 <dons> slightly bad form:
02:53:38 <dons>         let w1 = (take n s1)
02:53:42 <dons>         let w2 = (drop n s2)
02:53:46 <dons> the let is unnec for multiple lines
02:54:00 <neologism> might be
02:54:20 <dons>         let w1 = take n s1
02:54:20 <dons>             w2 = drop n s2
02:54:24 <dons> liek that.
02:55:19 <neologism> any other obvious bad style?
02:56:30 <dons> sorted set = map fst . sortBy snds $ zip set (map oneMax set)
02:56:30 <dons>     where snds (_,a) (_,b) = a `compare` b
03:01:49 <dons> checkScheme = (sum .) . map . check    
03:02:02 <dons> check sch s = fromEnum $ (sum . map p $ zip sch s) == len
03:02:51 <dons> good. except for all the tabs :)
03:03:11 <neologism> I dont find that pointsfree style readable :(
03:07:42 <araujo> Morning!
03:08:06 <araujo> neologism, point *uses* to be more readable
03:08:14 <araujo> point free even
03:08:34 <araujo> though it's one of those features that are easy to abuse :-]
03:26:54 <jip> @seen Cale 
03:26:55 <lambdabot> Cale is in #haskell. I last heard Cale speak 6 hours, 3 minutes and 15 seconds ago.
03:27:23 <ayrnieu> 'saw', silly.
03:28:02 <ayrnieu> 'detected'.  Or simply: "Cale last spoke"
03:28:24 <sieni> well, technically he neither saw or heard, since he's a bot without eyes or ears
03:28:47 <cpatrick> ayrnieu: I think that using speech-language makes more sense with IRC than writing-language
03:28:55 <cpatrick> Certainly that's what comes naturally to me
03:33:07 <araujo> morning again
03:33:09 <araujo> mm..
03:35:44 <neologism> how can I make "nothing" ?
03:35:52 <neologism> in "if verbose then putStrLn "blah" else nothing" ?
03:37:04 <dons> wehn verbose $ putStrLn "foo"
03:37:04 <dons> when
03:37:27 <dons> if x then y else return ()
03:49:32 <jip> @type when
03:49:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:49:55 <neologism> dons: thnx
03:52:03 <musasabi> putStrLnIf c s = when c $ putStrLn s
03:52:11 <musasabi> putStrLnIf verbose "foo"
03:52:40 <jip> hey guys... i have questions about monads
03:54:11 <jip> i think i should use a monad because i want to do something like: ld r1 r2 = do { a <- readRegister r2; writeRegister r1 a }
03:55:02 <jip> but i have no idea really how the type should be
03:55:05 <Philippa> sure. That's not a problem, it doesn't stop you hanging on to the resulting states, branching at will etc etc
03:55:20 <Philippa> sounds a lot like a state monad running over a record full of registers and whatnot?
03:56:03 <jip> Philippa: ok, so first thing i don't yet understand, is what would the type of ld be? ld :: Register -> Register -> XXX ?
03:58:14 <Saulzar> jip, State Registers ()  probably
03:58:25 <Saulzar> Oh, ld .. 
03:59:05 <Saulzar> Yeah Register -> Register -> State Registers () Probably, though you'd usually make a synonym for your monad eg. type RegisterState a = State Registers a
03:59:46 <jip> Saulzar: i don't want to use State though, i want to do this all myself, so i understand it
04:01:04 <Saulzar> Um ok, so you don't want a monad?
04:01:20 <jip> Saulzar: i only want a monad so i can use do syntax
04:02:18 <Saulzar> The built in monads do most of the stuff you'd want, you'd be best to do 2 things: 1) have a go at implementing state yourself, 2) make use of the library for your actual program 
04:02:31 <edwinb> quick question - why might Cabal complain "Setup.lhs: cannot satisfy dependency plugins-any" when ghc-pkg list says plugins-1.0 is installed?
04:03:14 <Saulzar> But you can make a monad RegisterState regardless if it's using the libraries or not
04:03:45 <jip> Saulzar: ok, also, there is more then just registers, there is also memory, with readMemory, and writeMemory. but another question:
04:03:59 <jip> Saulzar: what would the type of readRegister be? readRegister :: Register -> ???
04:04:32 <Saulzar> What type is the stuff in registers?
04:04:50 <Philippa> jip: learn how to implement the state monad, that's still what you're doing
04:05:01 <Philippa> I've got some code floating around the TMR wiki that might be of use
04:05:13 <Saulzar> Register -> MyMonad  (Stuff in a register)
04:05:20 <Philippa> (the first pass implementation uses GADTs but in an extremely obvious way - they're there entirely to get otherwise-obvious code to compile)
04:05:21 <jip> registers are Word8. thing is, i need to be able to somehow extract all of the read/write calls from this monad so that it can be executed manually
04:05:40 <Philippa> sounds like really you want multiple implementations of the same interface?
04:06:27 <Philippa> anyway, want me to dig up that code I left on TMR?
04:06:34 <jip> well, the readMemory function for instance should be quite simple. but i want to be able to "execute" this on different types of memory architectures, some of them have special cases for certain memory areas
04:06:57 <jip> but i don't want this complexity to be a part of the readMemory
04:07:41 <Philippa> OK, there's a way to do that. I don't know you'll like it though
04:08:03 <Philippa> http://www.haskell.org/tmrwiki/PhilippaCowderoy_2fWIP_2fMonadArticleThingy
04:08:07 <jip> here are more examples of the things i need to do: http://rafb.net/paste/results/lAJx7s99.html
04:08:07 <Philippa> (the article's part-done)
04:08:27 <Philippa> heh
04:08:27 <Saulzar> Hmm, why do you need them to be able to be extracted from the monad?
04:08:42 <Philippa> Saulzar: think of it as multiple views of the same monad. Replays, in this case
04:08:59 <Saulzar> Hmm...
04:10:44 <earthy> Article Title Here ;)
04:11:34 <Philippa> earthy: I hadn't thought of anything sufficiently witty and/or perverse :-)
04:11:40 <earthy> :)
04:11:50 <earthy> but, actually, I disagree
04:11:58 <Philippa> It /is/ a subpage of my WIP page, it's only world-readable because I've shown people it a few times now
04:12:03 <Philippa> with which part?
04:12:03 <earthy> with your statement that 'monads are used to represent languages'
04:12:19 <earthy> language fragments, yes
04:12:35 <earthy> the trick is that monads allow you to take multiple language fragments and combine them
04:12:58 <Philippa> it seems to me the result of that combination is a language though
04:13:27 <earthy> plus, what languaged does Control.Monad.Identity correspond to?
04:13:27 <Philippa> even if it's one that's in turn embedded into a larger one (which, er... yeah, you know what the diagram looks like)
04:13:39 <Philippa> one suspiciously isomorphic to haskell
04:14:02 <Philippa> (or in the more general case, the language you start off with)
04:14:06 <earthy> owh? I'd say 'the empty language'
04:14:35 <Philippa> I'd've said the monad that turns everything to () was closer to that
04:15:08 <Philippa> or possibly the 'everything-is-undefined' monad
04:15:12 <earthy> depends on interpretation
04:15:38 <earthy> but, yeah, 'everything undefined' would be empty language
04:15:46 <earthy> language with only 'skip' would be identity
04:16:22 <Philippa_> yay, well-timed disconnect!
04:16:24 <Philippa_> [12/04 12:14] <earthy> depends on interpretation
04:16:26 <Philippa_> [12/04 12:15] <Philippa> it seems to me you're talking more about monad transformers than about monads
04:16:28 <Philippa_> [12/04 12:15] <Philippa> IdentityT doesn't do a lot at all
04:16:30 <Philippa_> (did I miss anything?)
04:16:34 <jip> Philippa_: yes, that looks similar to what i need
04:16:57 <earthy> 13:14 < Philippa> or possibly the 'everything-is-undefined' monad
04:16:57 <earthy> 13:14 < earthy> depends on interpretation
04:16:57 <earthy> 13:15 < earthy> but, yeah, 'everything undefined' would be empty language
04:16:57 <earthy> 13:15 < earthy> language with only 'skip' would be identity
04:17:20 <earthy> and no, I'm not talking about monad transformers
04:17:29 <earthy> I'm actually doing proglang semantics with monads and coproducts thereof
04:17:57 <earthy> and use Identity as the carrier for the semantics of 'skip'
04:17:58 <Philippa_> fair enough
04:18:40 <Philippa_> I do think "A language with a bunch of added fragments" is what you end up with Haskell becoming...
04:19:09 <Philippa_> yay, netsplit!
04:19:15 <Philippa_> *checks nicks*
04:19:22 <Philippa_> cool, we're on the right side at least :-)
04:20:13 <Philippa_> 'sjust - you're describing monads in semantics and I'm describing monads as programming technique. I guess that pretty much is an interpretation difference. If I didn't already I should qualify that "in programming" != "in all fields related to programming" let alone "in general"
04:20:26 <earthy> ;)
04:20:41 <earthy> the intuition is similar though
04:20:44 <Philippa_> yeah
04:20:58 <earthy> have you seen http://citeseer.ifi.unizh.ch/607613.html ?
04:21:16 <Philippa_> but for you (in this discussion), language = end product, not starting point
04:21:31 <Philippa_> no, I haven't. Will take a look
04:22:43 <Philippa_> you've probably gathered by now that I don't have a particularly in-depth understanding of category theory (I can just about remember natural transformations without looking up the definition, and can form intuitions about more involved constructs but've never had the cause to remember them let alone chase a non-trivial diagram)
04:23:14 <Philippa_> I pretty much learnt enough to check my own understanding of the toys I was playing with was mathematically justifiable once you inserted all the field-specific interpretations
04:23:35 * earthy is at the same level :)
04:23:47 <earthy> category theory makes my brain hide
04:23:49 <jip> hm... you guys gotta help me :)
04:23:49 <Philippa_> ooh, haven't had a good treatment of modelling the lambda calculus in it before
04:23:54 <mahogny> is cathegory theory really that useful? from what I have learned so far, it looks more like using cathegories for the sake of using cathegories
04:24:07 <earthy> mahogny: it is really useful
04:24:11 <Philippa_> it doesn't quite do that to me, but it's a long time since I had to do maths seriously
04:24:15 <mahogny> earthy, got an example?
04:24:17 <Philippa_> mahogny: you could say the same of set theory
04:24:28 <earthy> mahogny: not one offhand
04:24:40 <mahogny> Philippa_, I know what it is. just not why it is useful :)
04:24:42 <earthy> but, basically, category theory allows you to reason without going into specifics
04:24:50 <Philippa_> mahogny: gaining a quick understanding of what monads do in haskell having understood what the categories are being used to represent
04:24:57 <Philippa_> in turn, having found the trick in the first place
04:25:02 <Philippa_> I think that's a pretty good example :-)
04:25:11 <Philippa_> also: models where you're more bothered about interface than implementation
04:25:26 <Philippa_> set theory gets awful caught up on implementation at times
04:25:35 <Philippa_> often you don't care so long as it can be implemented
04:26:09 <mahogny> hm. but cathegories is more used for reasoning about the type system rather than what the functions do?
04:26:50 <Philippa_> in the treatments you're likely to run into, yes. But it gets used for both and more
04:26:59 * earthy nods
04:27:02 <mahogny> hm
04:27:19 <Philippa_> in fact, there's a lot of tools for hopping between levels of abstractions - taking the category of categories or the category of functors is a common thing
04:27:37 <Philippa_> a Cambridge maths undergrad was complaining about this to me on saturday night :-)
04:27:42 <mahogny> does it have uses outside the language foundation domain ie for making proofs for specific examples?
04:27:55 <mahogny> or is that pure overkill?
04:28:00 <Philippa_> yes. If you can build the foundations you can build everything on top, no?
04:28:19 <Philippa_> and having diagram chasing as a proof method can be nice for code
04:28:20 <mahogny> true. but I was more thinking, if you have the foundations done, do you still need more of it? :)
04:28:30 <earthy> actually, you could theoretically build a *shitload* of maths on top of category theory
04:28:46 <earthy> and a shitload has in fact been built already
04:28:47 <Philippa_> earthy: for certain values of category theory you can build set theory on top. 'nuff said :-)
04:28:51 <mahogny> earthy, yes. but do you want? when does it stop being nice and friendly compared to the old stuff?
04:28:57 <earthy> lots of interesting algebra
04:29:04 * Philippa_ nods
04:29:14 <Philippa_> category theory strikes me as exactly the right tool for a lot of that
04:29:20 <earthy> mahogny: actually, it never was nice and friendly to begin with. :)
04:29:51 <Philippa_> it's one of the reasons I wish I knew it better - I seem to have an intuition for spotting adjunctions and the like and I wish I was better at proving I've got it right
04:29:54 <mahogny> earthy, so far it looks like a nice framework. just completely useless in practice. I need to find better examples it seems :)
04:30:05 * earthy nods
04:30:36 <Philippa_> mahogny: in the short term you might find it more useful for proving relationships in algebras and the like before going on to use them in more conventional proofs
04:31:27 * Philippa_ wonders if there's a categorical construct that embeds "modulo <some factor>..., up to isomorphism/whatever you had in mind" effectively
04:31:59 <Philippa_> modulo undefined being the favourite, if a program attempts to evaluate bottom I really don't care to continue examining its structure any further if I was trying to prove it doesn't
04:31:59 <mahogny> btw if you guys are into this kind of stuff... I was thinking earlier if it would be possible to make a language as a set of transition rules over some virtual machines and then make a compiler that tries to build a program by taking the valid intersections of many sets of rules. do you know if anyone has tried that?
04:32:20 <mahogny> if it would work, it would prove a very good alternative to aspect oriented programming which is EEW in practice
04:32:39 <Philippa_> I find the best alternative to AOP is a good module system with support for first-class modules
04:32:42 <sieni> Philippa_: a quotient category? http://en.wikipedia.org/wiki/Quotient_category
04:32:46 <Philippa_> unfortunately I've been having to fake that so far
04:33:22 <earthy> sieni: yup, that's what she asks for. :)
04:33:27 <mahogny> hm. how would you want to make computations on modules?
04:33:40 <Philippa_> I had a suspicion it might be as soon as I saw the notation :-) Thanks
04:33:53 <Philippa_> mahogny: mostly either by passing them around or applying transformations to the code within
04:34:16 <Philippa_> for example, I've built a transformer stack for an API before whereby transformers could add new functionality around existing or just patch over it entirely
04:34:37 <Philippa_> which meant that the core of my wiki clone doesn't need to have any concept of 'version history'
04:34:38 <mahogny> hmm
04:34:51 <Philippa_> because I can patch page writes to store one as metadata
04:34:52 <mahogny> sounds easy to use
04:35:16 <Philippa_> it's brainfucked a couple of people before they realised it's a bit like AOP, but they were looking at the raw code without any comments
04:35:18 * jip bangs head on wall
04:35:29 <Philippa_> jip: sorry, not trying to ignore you. What do you want help with?
04:35:50 <jip> heh no worries, i just am pretty much stuck :\
04:36:09 <janneke> well, let's go for a walk then
04:36:34 <Philippa_> start telling us what you're stuck with?
04:36:48 <jip> did you see that code i pasted?
04:36:59 <Philippa_> (btw, the two monad implementations lower down are obtained by simple transformations of the first one)
04:37:06 <Philippa_> the instruction-interpreter? yeah
04:37:18 <jip> does that look ok?
04:37:37 <Philippa_> at first glance, yeah
04:37:48 <Philippa_> don't have time to check you've got the semantics of each instruction down perfectly
04:38:26 <jip> it's z80 asm btw, and the semantics aren't perfect yet since i didn't do flag modifications yet
04:38:28 <earthy> looks fine to me
04:38:38 <earthy> but for the status register, yeah
04:38:51 <Philippa_> never coded on the z80 myself, but hey
04:39:01 <jip> it's ok how i use "let" in LDAC?
04:39:25 <Philippa_> AFAIK, but a second confirmation might be good
04:39:28 <earthy> afaik yeah
04:40:13 <jip> ok, so you guys are saying that readRegister :: Register -> MyMonad Word8, and also readMemory :: Word16 -> MyMonad Word8 ?
04:40:38 <Philippa_> looks about right, yeah
04:40:41 * earthy nods
04:41:04 <Philippa_> (hint: it's okay for your monad-interpreter to return an IO action or something like that if you want nice fast mutable arrays)
04:41:11 <jip> then i need to somehow in the "MyMonad" part of "MyMonad Word8" differentiate between a register read and a memory read, so that the "interpreter" knows what to do
04:41:21 <Philippa_> yes
04:41:25 <jip> Philippa_: i don't think i want any IO here
04:41:47 <Philippa_> if you start off like my first implementation, readRegister and readMemory would correspond to ReadRegister and ReadMemory constructors in the AST
04:41:59 <Philippa_> (you might eventually transform them out again)
04:42:15 <jip> yes, this sounds good, can you please explain a bit about the AST?
04:42:21 <earthy> jip: actually, your readRegister needs to differentiate for you
04:43:20 <Philippa_> jip: what do you want explained? It's an Abstract Syntax Tree, much like you'd see in a calculator or a toy lambda calculus interpreter. It's a little "bent", because the Return constructor effectively included the metalanguage (haskell) in the object language (the one being described by the AST), but that's OK because that's what monads do
04:44:08 <jip> Philippa_: it's "bent" because i can use any haskell function?
04:44:11 <Philippa_> You'll see Bind and Return constructors or their analogues in ASTs representing any monad (oh OK, Bind might get swapped for Join and FMap, but don't worry about that). The others represent the new commands
04:44:33 <Philippa_> because you can pass it that, yes. The definition of the object language 'includes' the entire definition of the metalanguage
04:45:02 <Philippa_> but if your instincts aren't trying to run screaming from that already you don't have a problem
04:45:06 <jip> ok, maybe i will understand things a bit more if i look at things from the side of the "interpreter"
04:45:20 <Philippa_> yeah, read the runStateMonad function
04:45:23 <Philippa_> that's where the action is
04:46:11 <jip> i read that but i don't quite see how it would work for me. in my cause i think i will need a type MachineState = (RegisterState, MemoryState)
04:46:20 <jip> RegisterState = (Word8, Word8, Word8, Word8, Word8)
04:46:24 * earthy nods
04:46:29 <Philippa_> you also need room for a return value, or it's not a monad
04:46:38 <jip> MemoryState = Data.Array Int Word8
04:46:47 <Philippa_> hint: the "hardware implementation monad" doesn't need to be exposed to the user
04:46:54 * earthy nods
04:46:58 <jip> hm.... ok, but this MachineState looks ok, right?
04:47:09 <Philippa_> in practice, you're going to end up with a two-tiered design this way, you'll probably show the user runMachineState myMachineInterpreter
04:47:12 <earthy> and then a monad of type  (MachineState, CurrentValue)
04:47:22 <Philippa_> currentValue, no? :-)
04:47:35 <earthy> philippa: yeah.
04:47:41 * jip is lost
04:48:04 <earthy> jip: the machinestate is auxiliary to the value that you're calculating with
04:48:17 <earthy> so, in LDAC you're calculating with a value from memory
04:48:37 <earthy> this *comes* from the machinestate, but you need to be able to reference it direcatly
04:48:40 <earthy> directly
04:48:51 <earthy> before putting it back into the machinestate
04:49:50 <jip> hm..... i thought that i would just be able to have like a updateMachine :: MachineState -> MyMonad XXX -> MachineState
04:50:00 <earthy> *almost*. :)
04:50:05 <Philippa_> you can do that by throwing away the XXX
04:50:07 <jip> updateMachine would "inspect" the monad and interpret it and return the new state
04:50:24 <earthy> you want a runMachine :: MachineState -> MyMonad a -> MachineState
04:50:24 <Philippa_> and yes, updateMachine is in fact analogous to runStateMonad
04:51:18 <earthy> the XXX (or a) is unimportant for the final result, *but* it may be important in the intermediate calculation
04:51:21 <earthy> so you need to have it
04:51:31 <Philippa_> earthy: you getting my PMs btw?
04:51:39 <jip> earthy: ok this i think i understand
04:52:05 <earthy> philippa: yeah
04:52:09 <earthy> you not getting my answers?
04:52:17 <Philippa_> no. You need to identify to nickserv
04:52:29 <jip> but in my code all of the instructions end with a writeX which is MyMonad (), so i can have updateMachine :: MachineState -> MyMonad () -> MachineState, right?
04:52:45 <Philippa_> yeah, though you'll need the more general function under the hood anyway
04:52:46 <earthy> ah, must've been splitted off sometime without me noticing then
04:53:42 <jip> Philippa_: you mean, in order to implement this updateMachine, i will need an updateMachine' that only does one "command"?
04:54:04 <Philippa_> no, you'll need an updateMachine' that works on MyMonad a
04:54:15 <jip> hm...
04:56:11 <jip> i'm not quite sure i get it
04:57:44 <Philippa_> you can't interpret your executeInstruction computation without an interpreter that handles MyMonad a, because it's got intermediate MyMonad a steps in it
04:58:23 <earthy> such as when you're stepping from a readRegister to a writeMemory
04:58:37 <jip> ok i sort of understand this. so what is the solution?
04:59:06 <Philippa_> do it just like I do in the article
04:59:18 <Philippa_> then worry about which version you expose outside the module later
05:00:15 <earthy> you can ignore the currentValue for the most part, just make sure that it doesn't get lost inadvertently
05:00:28 <Philippa_> yeah, mostly it just gets threaded through
05:01:10 <Philippa_> (you /could/, btw, just wrap State MachineState currentValue now - it might save you some head pain)
05:01:41 <mahogny> anyone here who have used wxhaskell?
05:01:58 <Philippa_> I did a while back. I ran into an annoying problem building a message log for an IRC client and didn't go back
05:02:06 <jip> hm.......... i am starting to fear that this stuff might be a bit over my head :\
05:02:13 <mahogny> IRC and wx... eew. got bad memories of that
05:02:36 <Philippa_> jip: if you can use monads OK, just write your own monad in terms of the State monad - it'll do the right thing anyway
05:02:39 <mahogny> anyway. the function "variable" gives me a mutable variable but doesn't say anything about if it is threadsafe. got a clue?
05:02:44 <Philippa_> nope
05:02:52 * mahogny hates the docs
05:02:54 <earthy> jip: you're almost all the way there
05:03:09 <Philippa_> that's true
05:03:18 <earthy> stop fearing, start cuddling the warm fuzzy things
05:03:31 <earthy> (which monads should've been called, according to some)
05:03:50 <mahogny> the best way to get things done in haskell if you are unsure, is with a sledgehammer and a lot of faith
05:04:20 <jip> this readRegister/writeRegister monad thing that i'm using can i think be replaced with a sort of stack-based virtual machine, that can be implemented as a simple list, and not a monad. i am almost tempted to do this just so i don't have to use monads
05:04:40 <Philippa_> is it using a monad that scares you or writing one?
05:05:14 <earthy> jip: it can. but then you'd have to explicitly thread the list
05:05:15 <jip> i think some of using is ok, since i know what i want the executeInstruction function to look like
05:05:41 <jip> earthy: it would only have to thread through the internals of a single updateMachine
05:06:22 <earthy> and exactly how would you rpresent the readRegister calls?
05:06:39 <jip> as a ReadRegister constructor
05:06:59 <jip> updateMachine would simply push the register value onto the top of the stack
05:10:33 <earthy> jip: you've basically built that already
05:14:03 <jip> i could also just have updateMachine work directly with an Instruction
05:16:11 <earthy> yes
05:17:55 <earthy> monads simply provide you nice syntax and a nice way of hiding the need for explicit ReadRegister constructors
05:46:03 <dons> ?b52s
05:46:05 <lambdabot> You belong in Ripley's Believe It Or Not
05:47:08 <jip> hey dons 
05:47:24 <dons> hey jip.
05:49:02 <dons> i love the type language: io :: forall a (m :: * -> *). (MonadIO m) => IO a -> m a
05:50:24 <dons> ?index Signal
05:50:25 <lambdabot> System.Posix.Signals, System.Posix.Signals.Exts, System.Posix
06:04:23 <jip> @seen Philippa_ 
06:04:24 <lambdabot> Philippa_ is in #scannedinavian, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa_ speak 29 minutes and 26 seconds ago.
06:04:48 <Philippa_> *wave* sorry, hadn't been looking at the chan too much
06:05:12 <jip> Philippa_: hi... i'm not sure how the AST type should be
06:06:44 <jip> Philippa_: http://rafb.net/paste/results/mD9BZK14.html
06:06:48 <Philippa_> a constructor per 'operation', plus one for Bind and one for Return
06:07:10 <Philippa_> ah, it's the types you're not sure about?
06:07:26 <Philippa_> they're pretty much the same as the types of the functions they'd be otherwise
06:09:24 <jip> hm.... like this?
06:10:38 <jip> http://rafb.net/paste/results/H8H1yE92.html
06:10:41 <Philippa_> you don't want state as a type variable in your monad. You know what type the state is, so substitute it in
06:11:15 <Philippa_> but aside from that, looks good
06:11:45 <jip> thing is, i don't really know what the state is
06:14:00 <Philippa_> sure you do. The combined state of the registers and memory
06:14:32 <Philippa_> (you can write different interpreters that extract other info from what's going on in a bit)
06:15:44 <jip> but there can be different versions of memory state. for example different memory sizes
06:26:45 * esap just implemented the concept of multi-valued functions using a surjection f:A+B -> Q.
06:30:52 <dons> ?version
06:31:01 <lambdabot> lambdabot 3p414, GHC 6.4.1 (Linux i686 3.20GHz)
06:31:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:34:47 <jip> *boing*
06:34:49 <ValarQ> hello dons
06:36:18 <ValarQ> dons: is there any known issue with hs-plugins on amd64 ?
06:43:02 <petekaz> Is there a common idiom in haskell on opening a file handle, do some work, then ensuring it gets closed?  Sorta like common lisp's WITH-OPEN-FILE or a try/catch/finally block in languages like java/python/ruby?
06:43:17 <petekaz> (I'm a total newbie)
06:44:38 <norpan> the easiest way is to just use readFile
06:45:37 <petekaz> So how does that work?  It reads the contents lazily, so does that mean the file is left open permanently?
06:45:55 <norpan> no, it will be closed when the string is garbage collected
06:45:58 <norpan> at least in theory
06:46:09 <petekaz> (laziness is a completely foreign concept to me as are its implications)
06:46:22 <petekaz> I see.
06:48:21 <jip> petekaz: try/finally is done with bracket in haskell
06:48:25 <jip> @hoogle bracket
06:48:27 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:48:27 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
06:48:27 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
06:49:02 <flux__> @hoogle readFile
06:49:02 <lambdabot> Prelude.readFile :: FilePath -> IO String
06:49:02 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
06:49:02 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
06:49:20 <flux__> I'd expect it to be closed also when you read the last character?
06:49:36 <flux__> (or actually one beyond it, that is, signaling the end of the list ;))
06:49:39 <jip> flux__: i've observed that readFile closes the file when it reads until EOF
06:49:46 <petekaz> About laziniess, readFile returns a string, so if I only refer to the first 10 characters of that string, only a small portion of the file is read?
06:50:02 <flux__> probably the first kilobyte or so is read
06:50:06 <petekaz> right.
06:50:28 <Philippa_> the short answer: "it reads exactly those characters needed, modulo buffering"
06:51:00 <Philippa_> (the file's closed once you hit EOF/[])
06:51:01 <jip> Philippa_: the good news is that all of that instruction code seems to compile! :)
06:51:04 <flux__> in this case the short answer also appars to be the correct one?-)
06:51:09 <Philippa_> jip: cool
06:51:56 <petekaz> thanks for the feedback.
06:53:24 <petekaz> The whole concept of laziness is so strange to me as I've always used strict languages before.  The closest I've come to laziness in the past is using python's yield operator.
06:54:23 <Philippa> if you think "things working with lists are control-structure-like", you've got a good starting point
06:54:31 <jip> laziness in the IO monad can be sometimes confusing i guess
06:54:47 <sjanssen_> laziness in the IO monad is technically "unsafe"
06:54:51 <Philippa> used wrongly it can be more than just confusing
06:54:53 <Philippa> exactly
06:55:03 <sjanssen_> for example, readFile is implemented with unsafeInterleaveIO
06:55:31 <norpan> but that doesn't mean that readFile itself is unsafe
06:56:16 <sjanssen_> norpan: it depends how you use it, I suppose
06:56:17 <Philippa> yeah, it wouldn't be in the standard otherwise. Though it's possible to suffer a "file handle leak" with it if you're careless and the implementation doesn't GC it for you (which it's not required to)
06:56:31 <Philippa> it's also possible to create memory leaks with it
06:56:42 <norpan> memory leaks are not unsafe
06:56:50 <Philippa> FCVO "unsafe"
06:56:55 <norpan> it's very easy to create memory leaks using nothing but pure functions
06:56:56 <Philippa> I don't like running out of storage, personally
06:57:40 <ayrnieu> norpan - and that, too, is very practically !safe.
06:58:10 <norpan> programs that never halt are also unsafe
06:58:15 <norpan> so there goes everything :)
06:58:15 <ayrnieu> norpan - indeed.
06:58:45 <sjanssen_> isn't the usual defn. of "unsafe" in Haskell as something that breaks referential transparency or the type system?
06:58:52 <ayrnieu> so now we can admit that readFile is OK because we trust that a programmer made sure it was, even with its unsafe implementation.
06:59:18 <norpan> sjanssen_: yes
06:59:21 <sjanssen_> the rest of these are just the standard hazards of programming
07:00:00 <norpan> although memory leaks in haskell are very special
07:00:02 <ayrnieu> that's the humor in speaking of safe things, yes.
07:00:33 <ayrnieu> norpan - why very special?
07:00:44 <jip> what's the best way to add an Int8(signed) to a Word16(unsigned) ?
07:00:49 <norpan> at least those that appear due to laziness
07:01:04 <petekaz> you folks make "learing haskell" sound like so much fun (sarcasm intended)
07:01:04 <cpatrick> ayrnieu: they're easy to cause and hard to track down until you wrap your head around laziness
07:01:14 <norpan> jip: fromIntegral
07:01:15 <Igloo> jip: What result type do you want?
07:01:17 <ayrnieu> pete - thanks!
07:01:47 <jip> norpan: i can't convert the Int8 to Word16 using fromIntegral because then i lose the sign
07:01:56 <jip> Igloo: result should be Word16
07:02:09 <norpan> what will you do with negative results then?
07:02:17 <jip> norpan: wrap
07:02:29 <norpan> so just sign extend and add
07:02:38 <jip> how do i do that?
07:02:55 <Igloo> fromIntegral i8 + w16 should DTRT
07:02:58 <norpan> fromIntegral
07:03:09 <Philippa> petekaz: if it helps any, there'll be nothing you can't solve by throwing more storage at it and it's possible to learn to chase down space leaks. Most of it boils down to not holding on to more of a structure than you need
07:03:39 <jip> > ((fromIntegral (0::Int8)) + (0::Word16)) :: Word16
07:03:41 <lambdabot> 0
07:03:51 <jip> > ((fromIntegral ((-1)::Int8)) + (10::Word16)) :: Word16
07:03:52 <lambdabot> 9
07:03:56 <jip> > ((fromIntegral ((100)::Int8)) + (10::Word16)) :: Word16
07:03:58 <lambdabot> 110
07:04:03 <jip> > ((fromIntegral ((100)::Int8)) + (10000::Word16)) :: Word16
07:04:04 <lambdabot> 10100
07:04:06 <Philippa> there're a couple of nasty things that can happen to you if you build up a complex computation yielding a small value and don't evaluate it for ages too, but usually you're going to evaluate it - the pathological (1+(1+(1+(...)))) case doesn't show up too often
07:04:09 <jip> > ((fromIntegral ((-120)::Int8)) + (10000::Word16)) :: Word16
07:04:11 <lambdabot> 9880
07:04:14 <norpan> apply fromIntegral to the Int8 directly, not to the result
07:04:33 <jip> hm.... i guess this seems to work
07:04:34 <Philippa> in practice, if you using existing implementations for data structures like maps you're probably going to be okay
07:04:47 <norpan> well, you have it
07:05:04 <petekaz> Ok, I'm sold.  On my next vacation, a haskell book and tutorial will be with me.
07:05:48 <jip> well thanks Philippa for all the help i gotta go now see you all later
07:18:41 <vincenz> petekaz: look at yaht, it's a good tutorial
07:18:43 <vincenz> @where yaht
07:18:44 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
07:19:25 <petekaz> vincenz: Ok. I've also been reading the write a scheme in 48 hours (as I'm reading SICP right now)
07:21:06 <petekaz> But YAHT is the one I want to print and take on vacation with me.  I think I also want to buy "Intro to FP using Haskell" based on this guy's blog entry on a haskell bookshelf: http://jaortega.wordpress.com/
07:22:36 <sjanssen_> @keal
07:22:37 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
07:25:43 <vincenz> Anyone here have their blog on planet haskell?
07:25:58 <mornfall> Itkovian: ping?
07:26:05 <Itkovian> uhu
07:26:14 <mornfall> Itkovian: hi :)
07:26:21 <ibid> \o/
07:26:24 <mornfall> Itkovian: i'm wondering about the data types in BCoppens's asignment :))
07:26:28 <Itkovian> do I know you?
07:26:30 <Itkovian> ah
07:26:33 <Itkovian> :-)
07:26:34 <mornfall> nah
07:26:42 <Itkovian> what of them?
07:26:46 <mornfall> he has shown me the problem
07:27:08 <mornfall> and i gave (some) solution... but changing it to fit the structures is very... impractical
07:27:21 <mornfall> and any solution using them i can think of is so, too
07:27:41 * mornfall goes to paste the solution again
07:28:00 <Itkovian> fair enough
07:29:05 <Itkovian> The reason for a given set of datatypes is to ease my work going through the submitted results
07:29:31 <mornfall> well, i have seen BCoppens's solution
07:29:35 <mornfall> and it's fairly... unhaskellish
07:29:36 <Itkovian> by all means improve my thinking
07:29:38 <BCoppens> mornfall: (I still have it somewhere in case you lost it)
07:29:46 <Itkovian> I have it too :-)
07:29:47 <mornfall> http://rafb.net/paste/results/CRRNEX31.html
07:30:11 <mornfall> this one is incomplete, but shows the general direction
07:30:19 <mornfall> i *may* have missed something about the assigment too :)
07:30:27 <Itkovian> nah seems ok
07:30:35 <Itkovian> at first glance
07:31:00 <BCoppens> :)
07:33:05 <Itkovian> The problem is that the course is far to short to give people a decent introduction
07:33:05 <mornfall> i was just thinking that (to me), the given structures lead to a much more complicated solution
07:33:12 <mornfall> hmm
07:33:17 <mornfall> that may be a problem yes :)
07:33:31 <Itkovian> Thus far I, and my predecessors, have only succeeded in giving people a taste and hope that they look beyond that
07:33:40 <Itkovian> afaik few did that
07:33:53 <Itkovian> because the industry doesn't call for Haskellers over here
07:34:05 <BCoppens> does it call for haskellers anywhere ;)
07:34:09 <Itkovian> And advancing takes time, which most of us don;t have
07:34:12 <vincenz> hey pepole
07:34:14 <vincenz> as you all know
07:34:19 <vincenz> I'm considering making a course on haskell
07:34:20 <mornfall> nowhere... but there are people who are interested in CS not industry, too :)
07:34:21 <Itkovian> BCoppens: shapr makes a living out of it
07:34:22 <vincenz> for people where I work
07:34:29 <BCoppens> Itkovian: nice :)
07:34:35 <tromp> who
07:34:36 <mornfall> Itkovian: shapr is... special
07:34:37 <vincenz> if I put a rough outline online on a wiki, would you guys add comments?
07:34:39 <Itkovian> true
07:34:41 <BCoppens> Itkovian: but I guess that's not really commonplace
07:34:45 <Itkovian> vincenz: yeah
07:34:50 <Itkovian> over time ...
07:34:53 <vincenz> well yeah
07:35:06 <Itkovian> BCoppens: it depends, I guess. If you can solve somebody's problem in half the time
07:35:21 <Itkovian> then it might be good to persuade an employer
07:35:38 <Itkovian> if you want to make a fast buck, right now, go with php/drupal/...
07:35:42 <ADEpt> is there Brian Chrisman out here somewhere?
07:36:07 <BCoppens> Itkovian: if you want to make fast buck, chances are you don't want to waste your time in a CS uni study ;)
07:36:10 <mornfall> Itkovian: hehe... well, most prospective employers already have some team and some work done, too
07:36:22 <mornfall> Itkovian: and languages don't mix
07:36:24 <Itkovian> true & true
07:36:32 <Philippa> if you want a quick buck, sell yourself for a quick...
07:36:35 <Itkovian> mornfall: mostly
07:36:47 <Itkovian> Philippa: really, that was at the -blah channel :-)
07:36:57 <Philippa> you get my point though
07:37:05 <Itkovian> I do, I do
07:37:22 <Philippa> software development needs professionalism, professionals shouldn't be looking for a fast buck
07:37:46 <mornfall> Itkovian: do you have an advanced course too? or no interest from students?
07:37:47 <Itkovian> well, I need new hardware
07:37:59 <Itkovian> nah, just an introductory thingie
07:38:01 <BCoppens> mornfall: actually, they're scrapping the course altogether
07:38:06 <Itkovian> and that'll drop next year too
07:38:09 <mornfall> ouch
07:38:19 <Itkovian> people can stil choose it iirc, but it's no longer obligatory
07:38:25 <Itkovian> bachelor/master crap
07:38:30 <Itkovian> brb
07:38:41 <mornfall> we have compulsory functional intro course in first semester
07:38:47 <Itkovian> cool
07:38:49 <mornfall> for everyone (even applied branch)
07:38:55 <Itkovian> over here it's all Java
07:38:56 <musasabi> Is there a reason for the lack of "unconstructors" in Haskell? Just "data Foo = Foo Int Char" "unFoo (Foo x y) c = c x y" or something similar.
07:38:59 <mornfall> and optional advanced
07:39:04 <mornfall> but no actual haskell in advanced
07:39:06 <Itkovian> then people don't know what a pointer is when they meet OS
07:39:27 <BCoppens> Itkovian: they don't know either with java, really
07:39:32 <Philippa> musasabi: doesn't seem worth the namespace pollution?
07:39:45 <Itkovian> my point exactly
07:39:45 <Saulzar_> musasabi, Aren't records "unconstructors" ?
07:39:48 <Philippa> that, and stinks of \calc implementations of sums :-)
07:40:03 <mornfall> oh, you mean that not everything is a reference? </irony>
07:40:36 <BCoppens> mornfall: ;)
07:40:49 <musasabi> Philippa: the lack of those makes generic things painful. Of course one can take one of the generic frameworks to do it, but it isn't very nice.
07:41:06 * Philippa nods
07:41:09 <BCoppens> Itkovian: but they'd actually keep the course even though nobody would be forced to do it? That seems not really like 'them'
07:41:11 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Other/HaskellCourse
07:41:15 <vincenz> feel fere to add comments below
07:41:25 <Philippa> it's not been needed until then because you could just pick a binding and/or case analysis construct and do it that way
07:41:30 <mornfall> BCoppens: optional courses are the way
07:41:49 <mornfall> BCoppens: then it's not (too) polluted by students that don't care at all :)
07:42:12 <BCoppens> mornfall: I don't disagree on that, of course :)
07:42:58 <mornfall> at least here, it's still commonplace that people go to uni so that they can start working later (living off parents' money) and then get more $$$ when they get employed
07:43:32 <mornfall> s/still//
07:43:46 <mornfall> i guess it'll be commonplace till the end of all days
07:44:07 <BCoppens> mornfall: afaik it's about the same here, though I don't care that much about the $$$ part myself ;)
07:44:26 <mornfall> BCoppens: i thought you were honestly interested in CS :P
07:44:41 <BCoppens> mornfall: which is why I don't care about the $$$ :P
07:45:08 <Philippa> at a bare minimum you should at least have some interest in /doing the job right/, y'know?
07:45:17 <BCoppens> yeah :)
07:45:19 <mornfall> Philippa: what?
07:45:21 <mornfall> why
07:45:30 <mornfall> there are still people who do that? :)
07:45:40 <Philippa> mornfall: because if you don't I don't want you within 50 miles of my systems :-)
07:45:51 <BCoppens> =)
07:46:04 <mornfall> Philippa: no worries noone ain't touching none of your systems ;)
07:46:29 <mornfall> well, i wouldn't hang in #haskell if i wouldn't care, would i? :)
07:49:27 <vincenz> I'd like to invite you all to comment on  http://www.notvincenz.com/wiki/pmwiki.php/Other/HaskellCourse   it's editable by anyone
07:49:50 <vincenz> @where yaht
07:49:51 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
07:50:57 <mornfall> BCoppens: why aren't you in ##c++ btw? :)
07:51:03 <petekaz> vincenz: I'm curious what you'll have in this section "Advantages of Haskell w.r.t. other languages"
07:51:31 <petekaz> What types of programs do your colleagues at work write?
07:51:42 <BCoppens> mornfall: what do people do there?
07:51:53 <vincenz> petekaz: tools
07:52:18 <vincenz> Hopefully in time I can grow this outline enough to create a set of slides
07:52:22 <petekaz> what types of tools?  I do a lot of tool writing myself in the area of network management.
07:52:36 <Saulzar> vincenz, The "What you can do with haskell" section seems the most important, but only a small section?
07:52:48 <mornfall> BCoppens: hmm, hang? (probably by the feet, heads pointing in the direction of gravity)
07:53:17 <BCoppens> mornfall: k =)
07:53:24 <mornfall> lol
07:53:45 <mornfall> BCoppens: well, i hang in most language chans when i use the language... or at least know :)
07:53:51 <vincenz> Saulzar: I'm expanding as I go
07:54:01 <mornfall> BCoppens: when you need to ask something you don't look like a loser that just comes to chan to ask ;)
07:54:04 <vincenz> Saulzar: it's not ... proportional
07:54:11 <BCoppens> mornfall: good point :P
07:54:11 <Itkovian> vincenz: posted to delicous
07:54:15 <mornfall> BCoppens: the downside is that usually noone knows the answer anyway
07:54:20 <vincenz> Itkovian: thank you
07:54:25 <BCoppens> mornfall: heh
07:54:36 <mornfall> BCoppens: at least in c++ :P
07:54:46 <BCoppens> ;)
07:54:58 <BCoppens> mornfall: muni.cz, somebody you know? :P
07:55:15 <mornfall> sad0ur: ahoj? :)
07:55:23 <mornfall> BCoppens: not by the nick
07:55:35 <BCoppens> mornfall: :)
07:55:49 * BCoppens adds #haskell and ##c++ to autojoin. Can always be handy :)
07:56:23 <mornfall> sad0ur: any chance i know you? :) (.muni.cz, as BCoppens pointed out)
07:56:32 <sad0ur> mornfall: cau 
07:56:58 <sad0ur> I'm not sure... (Haven't seen nick mornfall anywhere...)
07:57:11 <mornfall> mornfall in IS too
07:57:24 <sad0ur> I'll take a look...
07:59:34 <sad0ur> oh, someone on cs faculty who is not in "aplied program" :)
07:59:57 <mornfall> sad0ur: ...
08:00:11 <BCoppens> =)
08:00:27 <BCoppens> at least you have a decent non-applied program ;)
08:00:44 <mornfall> sad0ur: you could join #fi.muni.cz too? :) (#muni.cz was sortof dropped due to no members :)
08:01:42 <Itkovian> I'm off
08:01:43 <Itkovian> ttyl
08:01:46 <BCoppens> bye :)
08:02:01 <mornfall> Itkovian: laters
08:02:18 <vincenz> anyone have the haskell syntax file for Geshi?
08:03:26 <sad0ur> mornfall: I'll be there later. I'm here just for sec now...
08:03:32 <mornfall> :-)
08:21:25 <hunsaker> some time ago there was a discussion in the haskell or haskell-cafe lists where someone had mentioned that !! should take non-negative integers only and then wouldn't have to have that error "Prelude.!!: negative index"
08:21:36 <hunsaker> does anyone remember a discussion like that?
08:21:52 <hunsaker> and about when that was, or who was advocating that?
08:24:23 <norpan> i don't read that mailing list anymore, but that kind of typing is not possible
08:24:32 <xerox> ?hoogle IORef
08:24:34 <lambdabot> Data.IORef :: module
08:24:34 <lambdabot> Data.IORef.IORef :: data IORef a
08:24:34 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
08:24:39 <xerox> ?hoogle+
08:24:40 <lambdabot> Data.IORef.mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))
08:24:40 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
08:24:40 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
08:24:43 <xerox> ?hoogle+
08:24:44 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
08:24:44 <lambdabot> Data.IORef.writeIORef :: IORef a -> a -> IO ()
08:25:00 <norpan> the type would be dependent on the value
08:31:20 <norpan> hunsaker: http://www.mail-archive.com/haskell-cafe@haskell.org/msg13348.html
08:38:25 <xerox> Welcome, forcer.
08:38:47 <hunsaker> norpan: thanks, but the thread I'm looking for is older, thanks for pointing me to mail-archive.com though
08:40:56 <forcer> Hello everyone. We're having a small argument about mutation in Haskell. Sadly, none of us is really good in Haskell, so we're somewhat stumped. So far, I thought that Haskell does preserve referential transparency and so that when I retain a value somewhere, the value won't change out of nowhere. Data.IORefs now provides atomicModifyIORef which looks like two threads can retain the same value, and one thread modifying that value will
08:40:56 <forcer> cause a modification of that value in the other thread - else, I don't see how a deadlock could happen. How does that work?
08:42:47 <vincenz> forcer: imagine thread A) waiting on variable mutation from thread B, and thread B waiting for another varialbe to be mutated by thread A... deadlock
08:43:53 <forcer> vincenz: I.e. once the IORef has a value, that won't change anymore, so this implements Mozart/Oz "logic" variables which block the thread on read?
08:44:15 <vincenz> not familiar with mozart/oz logic variables
08:46:02 <forcer> vincenz: Er, "placeholders" (and probably a bunch of other names) in other languages. It either has no value, or a value. once it has a value, that won't change. But when it has no value, a value can be "set". Retrieving the value while it has no value will block the thread.
08:46:26 <xerox> Those are MVars I think....
08:46:34 <vincenz> yeah I was thinking of mvars
08:47:03 <forcer> What about IORefs? I was told they can change value while I'm not looking, so that would break referential transparency. Is that true?
08:47:05 <xerox> IORefs are free of changing anytime, you put inside a value when you first create them.
08:47:27 <xerox> But you don't believe me :-P
08:47:49 <vincenz> forcer: how does it break ref transparency?
08:48:03 <vincenz> forcer: you're working in the IO monad which basically chains a whole set of fucntions together
08:48:07 <vincenz> and gives it as input RealWorld
08:48:12 <xerox> vincenz, argh.
08:48:20 <xerox> IORefs *aren't* State!!!
08:48:21 <vincenz> xerox: che?
08:48:34 <vincenz> they're not?
08:48:50 <xerox> Of course.  Why would you need this then:
08:48:57 <xerox> ?hoogle atomicModifyIORef
08:48:59 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
08:49:09 <vincenz> ...
08:49:12 <xerox> http://www.haskell.org/ghc/docs/6.4.1/html/libraries/base/Data-IORef.html
08:49:12 <vincenz> it's state
08:49:20 <vincenz> just.... atomically updatable state
08:49:32 <xerox> vincenz, I really don't think so.
08:49:57 <vincenz> just like an Mvar but with atomic actions
08:50:04 <xerox> No!
08:50:19 <vincenz> Ioref a: A mutable variable in the IO monad
08:50:22 <xerox> readIORef and writeIORef 
08:50:22 <xerox> readIORef and writeIORef *aren't* atomic actions.
08:50:24 <vincenz> straight fromo the page you just sent
08:50:26 <xerox> Oops.
08:50:31 <vincenz> xerox: no but atomicModifyIORef is
08:50:41 <xerox> Yes!  And why you need it.... ?
08:50:47 <vincenz> for atomic updates
08:50:52 <vincenz> seems obvious to me
08:50:54 <xerox> Right, because without it...
08:51:00 <vincenz> you have no atomic updates
08:51:08 <xerox> Exactly, you have *mutation*.
08:51:11 <xerox> Is that right?
08:51:20 <vincenz> ... atomic updates are also mutation
08:51:28 <edwinb> Is it possible to tell hs-plugins to look in my user package.conf without hard coding a path to it in 'load'?
08:51:29 <xerox> Yes sure, but in the sense forcer was talking of.
08:51:43 <vincenz> I think we're not on the same page
08:51:57 <xerox> I'm referring to "I was told they can change value while I'm not looking, ..."
08:52:05 <xerox> That's false for IORef, are you with me?
08:52:10 <vincenz> how is that false
08:52:13 <vincenz> if you have a second thread
08:52:18 <vincenz> and someone atomically modifies an ioref
08:52:19 <xerox> Ops, true.
08:52:25 <xerox> Yes, I read 'can't'.
08:52:35 <Philippa> xerox: it's not false in the presence of unsafePerformIO or concurrency
08:52:48 <Philippa> (sorry, too slow there)
08:52:55 <xerox> Philippa, yes, I read 'can't', that's my opinion too.  Thank you.
08:52:59 * xerox shakes forcer 
08:53:01 <vincenz> xerox: and I thought I was completel missing somtehing
08:53:07 * xerox hugs vincenz 
08:53:10 <vincenz> xerox: thanks for the confusion
08:53:15 <xerox> Anytime.
08:53:19 * vincenz sniffs
08:53:24 <forcer> I can have a reference to an IOref, and its value will change while I'm not looking (without resorting o monad syntax)? For an IOref x (foo x, foo x) can return two different values?
08:53:39 <forcer> s/ o / to /
08:53:39 <vincenz> I'm wondering... for the course I plan to give, if it would be ok to use stuff from YAHT or not
08:53:44 <Philippa> forcer: you can't have a reference to an IORef
08:53:49 <Philippa> you hold the IORef itself
08:53:58 <Philippa> (yeah yeah, I know, IORef (IORef foo), but YKWIM)
08:54:00 <vincenz> forcer: yes but they're monadic actions, even for simpler monadic actions this is true..
08:54:23 <vincenz> forcer: monadic actions internally thread the state
08:54:28 <vincenz> so referential transparency is not broken
08:54:34 <xerox> Yes, (foo x,foo x) *can* return two different values.
08:54:43 <vincenz> (foo x, foo x) is illegal syntax
08:54:47 <vincenz> you cna't get that to work!
08:54:48 <Philippa> but only in the presence of unsafePerformIO
08:54:50 <vincenz> a <- foo 
08:54:52 <vincenz> b <- foo
08:54:53 <Philippa> vincenz: no it's not
08:54:55 <vincenz> (a, b)
08:55:00 <Philippa> it just doesn't do what forcer thinks it does
08:55:07 <vincenz> well yeah..that's what I mean
08:55:16 <xerox> Philippa, hmm, well, nobody said foo shouldn't be an action.
08:55:16 * vincenz uses words ambiguously
08:55:23 <vincenz> xerox: foo is an action
08:55:39 <Philippa> xerox: it's an unperformed one at that point though
08:55:45 <vincenz> yup
08:55:48 <xerox> Philippa, that's another matter, anyway.
08:55:49 <Philippa> you still need >>= to make it do anything
08:56:05 <forcer> I.e. I have to use the monad to get that "mutation" to happen?
08:56:21 <Philippa> (foo x, foo x) will yield two identical values - but those values might be the actions which when finally performed might themselves yield different results
08:56:27 <vincenz> forcer: those actions work in the Io monad
08:56:47 <xerox> Philippa, I think it's fair to say that "use the monad" is a synonym of "make the effect explicit".
08:56:49 <vincenz> atomicMutateIoRef  : .... -> IO a
08:56:52 <xerox> Isn't it?
08:57:16 <xerox> And I also think that not having side effects, but only effects, doesn't mean you don't have mutability.
08:57:25 <Philippa> yes. But (foo x, foo x) is still, modulo unsafePerform IO, guaranteed to return a pair of indistinguishable values
08:58:03 <xerox> Philippa, the problem is 'return', probably? :-)
08:58:11 <Philippa> "evaluate to", then
08:58:11 <forcer> Maybe I should describe the context of the discussion we had; Scheme has a VECTOR-SET! which clearly breaks ref transp. We claimed that an operation like VECTOR-SET!, which mutates a vector, is not possible in Haskell, but you can emulate the effect with monads - which still won't be mutation in the Scheme sense.
08:58:27 <vincenz> forcer: I would seriously take up a tutorial on haskell and read about monads
08:58:31 <Philippa> forcer: but you'll observe the same thing on the hardware level
08:58:44 <Philippa> so that's a pretty strong value of "emulate"
08:58:47 <xerox> Yes because the "emulation" is "making explicit", there is no *trick*.
08:59:03 <forcer> Philippa: Yes, but we were talking about the concept, not the implementation.
08:59:12 <vincenz> forcer: look
08:59:15 <vincenz> forcer: when you have a monad
08:59:22 <vincenz> you must explicitly thread your functions together
08:59:24 <vincenz> either with >>= 
08:59:27 <Philippa> the concept has an implementation that's outside haskell itself which causes things to happen in some notion of "the real world"
08:59:28 <vincenz> or with the do-syntaax
08:59:30 <Philippa> that good enough for you?
08:59:30 <vincenz> this meanst hat
08:59:32 <vincenz> when you do
08:59:33 <vincenz> a <- foo
08:59:34 <vincenz> b <- foo
08:59:39 <vincenz> these funcions have different inputs
08:59:41 <vincenz> (the threaded state)
08:59:46 <Philippa> that implementation /is required by the IO monad concept/
08:59:48 <vincenz> so ref transparency is retained
09:00:32 <forcer> Philippa: The whole point of the discussion was that someone claimed that some algorithms can only be implemented efficiently with mutating procedures like VECTOR-SET!, onto which he got the reply that he does not need such a mutating procedure to get an efficient result, and Haskell was used as an example for that.
09:00:34 <Philippa> with more detail, an IO action denotes a function of type World -> World where World is the state of the universe at the point at which the action starts/stops execution
09:00:42 <norpan> because you could as well do let x = foo in do; a <- x; b <- x
09:00:46 <forcer> vincenz: I'm well aware of how monads work, actually.
09:00:59 <vincenz> forcer: then how is an ioref a problem?
09:01:02 <Philippa> forcer: the discussion was being carried out with insufficient subtlety to see the point
09:01:29 <Philippa> you /do/ need some form of mutation to enable (sufficiently) efficient algorithms for some purposes
09:01:35 <forcer> vincenz: It wasn't until someone told me that it does mutation on a level which I had thought (and still think) is not possible in Haskell :-)
09:01:39 <Philippa> it doesn't have to remove referential transparency from the language
09:01:44 <vincenz> forcer: oh :)
09:02:04 <Philippa> it's possible. IORef's an implementation primitive, as are the basic operations for it
09:02:06 <xerox> Philippa, but that doesn't mean that those algorithms aren't possibly implemented in Haskell, right?
09:02:22 <Philippa> xerox: exactly. See "it doesn't have to remove..."
09:02:50 <Philippa> now, you can't efficiently implement VECTOR-SET! from scratch in Haskell, but you can't do it in scheme either so no biggie
09:03:09 <forcer> Philippa: Isn't that "some form of mutation" an implementation detail for von neumann computers, not for the conceptual implementation?
09:03:14 <Philippa> (someone remind me whether GHC's grown enough extensions to make ST implementable in haskell yet?)
09:03:23 <Philippa> forcer: mu
09:03:49 <forcer> Philippa: I think I understand, thank you :-)
09:04:21 <Philippa> the conceptual implementation of scheme doesn't care about the exact implementation any more than the conceptual implementation of haskell including the IO monad does
09:04:39 * xerox thinks the same
09:05:06 <vincenz> unless vector-set is coded under the hood, but this could then be done in haskell as well..
09:05:21 <Philippa> vincenz: concrete-implementation detail :-)
09:05:35 <xerox> vincenz, Philippa meant something peculiar saying "implemented in Haskell"
09:05:44 <vincenz> xerox: I know, hence "unless"
09:05:49 <Philippa> yeah, I meant pure haskell
09:05:56 <vincenz> I know
09:05:59 <xerox> Right.
09:06:00 <Philippa> with no unsafePerformIO or coerce primitives
09:06:04 <xerox> Point is, there is no *emulation*
09:06:12 <xerox> It's just *explicit*
09:06:16 <Philippa> (I'm pretty sure it can be done with a coercion primitive)
09:06:21 * xerox grumbles at forcer
09:06:43 <Philippa> what is true is that haskell can do explicit stuff in any language or environment you care to think of given the right way to hook it up
09:07:11 <Philippa> if you really /want/ to, you can think of it as an incredibly twisted form of metaprogramming. It's just rarely useful to do so unless you're building your own monad
09:08:40 <xerox> Philippa, hmmm...
09:08:45 <xerox> Philippa, State and IO *do* differ, right?
09:08:51 <vincenz> xerox: yep
09:08:57 <Philippa> yes. State has a pure implementation
09:09:08 <vincenz> xerox: except...if you look under the hood of ghc... io = State RealWorld
09:09:09 <Philippa> you can't implement IO in Haskell without in fact using IO in the process
09:09:12 <vincenz> at the typelevel
09:09:13 <xerox> Seeing IO or ST as "State", it's just a manner to look at it.
09:09:18 <Philippa> vincenz: ST Realworld
09:09:22 <Philippa> not the same thing
09:09:22 <vincenz> oh it's ST?
09:09:30 <vincenz> oh yeah... state doesn't force all actions
09:09:33 <vincenz> I remember that once
09:09:56 <xerox> Philippa, is it true that IORefs aren't chained implicit state?
09:09:59 <Philippa> yeah. Plus you certainly can't implement ST as a State wrapper in Haskell 98 + rank-n types
09:10:06 <xerox> Sorry for the heavyload number of question.
09:10:18 <Philippa> xerox: yes. IORefs themselves could be a key into a chained map
09:10:31 <Philippa> (monomorphic-heap-ST is easy to implement in H98)
09:10:36 <xerox> Thank you.
09:11:20 <Philippa> ST's a valuable monad because it's significantly more than State and still represents a computation that's pure-on-the-outside :-)
09:11:27 <xerox> Indeed.
09:12:52 <Philippa> forcer: ST gives you "just mutable storage" with no disc access, networking or anything like that. Very useful.
09:13:20 <Philippa> I've used it for unification, for example. Though next time I implement an H-M typechecker I'm going constraint-based
09:14:03 <vincenz> how does constraint-based work?
09:16:37 <liyang> use STM;
09:16:42 <sjanssen_> @hoogle unsafePerformIO
09:16:44 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
09:19:11 <norpan> @hoogle safeUnperformIO
09:19:12 <lambdabot> No matches found
09:22:01 <lispy> heh
09:22:15 <lispy> @hoogle safePerformUnio
09:22:16 <lambdabot> No matches found
09:22:24 <forcer> @hoogle ST
09:22:25 <lambdabot> Control.Monad.ST :: module
09:22:25 <lambdabot> Data.Array.ST :: module
09:22:25 <lambdabot> Control.Monad.ST.ST :: data ST s a
09:22:51 <forcer> Philippa: Thanks :-)
09:23:12 <forcer> Thanks everyone for the replies. Confusion is great, but it's also great to get rid of it again ;-)
09:25:03 <norpan> The reason for Confusion is often Enlightenment
09:25:31 <vincenz> like a zenslap?
09:25:32 <JohnnyL> > take 10 $ iterate (+) 1
09:25:33 <sethk> I never knew how enlightened I was
09:25:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:25:34 <lambdabot>   Expected type: (t -> t1) -> t -> t1
09:25:34 <lambdabot>   Inferred type: (t -> t1) -> (t -> t1) -> t -> t1
09:26:13 <vincenz> > take 10 $ iterate (+1)1
09:26:14 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
09:26:29 <JohnnyL> > take 10 $ iterate (+)1
09:26:31 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:26:31 <lambdabot>   Expected type: (t -> t1) -> t -> t1
09:26:31 <lambdabot>   Inferred type: (t -> t1) -> (t -> t1) -> t -> t1
09:26:38 <JohnnyL> OPPS
09:26:45 <vincenz> JohnnyL: it expects a function (a->a)
09:26:49 <vincenz> not (a->a->a)
09:27:00 <JohnnyL> > take 10 $ iterate (+1) 1
09:27:02 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
09:27:30 <JohnnyL> what's (+)? an operator?
09:28:07 <Saulzar> Makes a prefix function from the infix operator +
09:28:18 <norpan> > take 10 $ let f = 1:1:zipWith (+) f (tail f) in f
09:28:19 <Saulzar> (+) x y  = x + y
09:28:19 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
09:29:22 <vincenz> > 1 `(+)` 2
09:29:23 <lambdabot>  parse error on input `('
09:29:25 <vincenz> :/
09:29:43 <Saulzar> > let foo = (+) in 1 `foo` 2
09:29:44 <lambdabot> 3
09:29:54 <vincenz> > let add x y = x + y in (`add`) 1 2
09:29:56 <lambdabot>  parse error on input `)'
09:30:14 <vincenz> Saulzar: () prefixes for ops, and `` infixes for nonops...be nice if they were inverse
09:30:19 <vincenz> ...s
09:30:36 <JohnnyL> Salurzar, wow, cool. immediate operator assignment. nice.
09:30:49 <vincenz> on a syntactical level: () :: op -> nonop,  `` :: nonop->op
09:30:57 <Saulzar> Hmm, not that you need that ever .. since symbols are always infix by default and letters prefix
09:31:04 <Igloo> vincenz: Why would it be nice, exactly?
09:31:15 <vincenz> Igloo: for completeness sake :)
09:32:05 <sjanssen_> vincenz: yeah.  I would expect (`foo`) to work
09:32:07 <Saulzar> JohnnyL, You can turn any word into an operator with `thisSyntax`, and operators like + are just functions too
09:32:17 <JohnnyL> > let foo= (+) in 1 Foo 2
09:32:19 <lambdabot>  Not in scope: data constructor `Foo'
09:32:27 <JohnnyL> > let foo= (+) in 1' Foo' 2
09:32:29 <lambdabot>  lexical error in string/character literal
09:32:32 <vincenz> JohnnyL: case sensitive
09:32:33 <JohnnyL> > let Foo= (+) in 1' Foo' 2
09:32:33 <norpan> but it could sometimes be useful to use a more complex expression infix
09:32:34 <lambdabot>  lexical error in string/character literal
09:32:43 <vincenz> > left foo = (+) in 1 `foo` 2
09:32:44 <lambdabot>  parse error on input `='
09:32:48 <vincenz> > let foo = (+) in 1 `foo` 2
09:32:49 <lambdabot> 3
09:32:52 <norpan> let f x y z = ... in 1 `f 1` 2
09:32:52 <vincenz> and slanted `
09:33:13 <vincenz> > let f x y z = x+y+z in 1 `f 2` 3
09:33:14 <lambdabot>  parse error on input `2'
09:33:17 <vincenz> norpan: :/
09:33:21 <vincenz> > let f x y z = x+y+z in 1 `f` 2 3
09:33:23 <lambdabot>  add an instance declaration for (Show (a -> a))
09:33:30 <norpan> that's what I'm saying, it could be useful
09:33:31 <Saulzar> > let x + y = x * y in 7 + 7
09:33:32 <lambdabot> 49
09:33:51 <vincenz> > let x + y = y + x in 7 + 7
09:33:52 <lambdabot> Add a type signature
09:33:52 * vincenz cackles
09:33:58 <vincenz> > let x + y = y + x in 7 + 7 :: Int
09:34:02 <lambdabot> Terminated
09:34:19 <vincenz> > let f x y z = x+y+z in (1 `f` 2) 3
09:34:20 <lambdabot> 6
09:34:21 <vincenz> heh
09:34:25 <vincenz> > let f x y z = x+y+z in 1 `f` 2 3
09:34:26 <lambdabot>  add an instance declaration for (Show (a -> a))
09:34:43 <vincenz> so (a `nonop` b) c works
09:34:44 <vincenz> but not
09:34:48 <vincenz> (`nonop`) a b c
09:35:02 <vincenz> nor a `nonop` b c 
09:35:05 <wobster> what is the usual file-extension of haskell programs?
09:35:11 <vincenz> wobster: .hs
09:35:23 <wobster> vincenz, thank you.
09:35:27 <norpan> but my point is that (1 `f` 2) 3 would be the same as 2 `f 1` 3 so it's not the same order
09:35:31 <vincenz> norpan: yeah
09:35:40 <xerox> > let f = (`map`) [1,2,3] in f 1
09:35:41 <lambdabot>  parse error on input `)'
09:35:46 <xerox> Arrr.
09:35:49 <vincenz> and (1 `f` 2) 3  needing () implies that a `f` b is an operator
09:35:50 <vincenz> ooh
09:36:01 <vincenz> > let f a b c d = a+b+c+d in 1 2 `f` 3 4
09:36:02 <lambdabot>  add an instance declaration for (Show (a -> a -> a))
09:36:11 <vincenz> odd
09:36:28 <norpan> > let (+) = (*) in 7+7
09:36:29 <lambdabot> 49
09:36:32 <norpan> good bot
09:36:33 <vincenz> > let f a b c d = a+b+c+d in 1 `f` 2 `f` 3 `f` 4
09:36:34 <lambdabot>   add an instance declaration for (Show (((a -> a -> a)
09:36:34 <lambdabot>                 -> (a -> a -> a)
09:36:34 <lambdabot>                 -> a
09:36:57 <vincenz> @botsnack
09:36:57 <lambdabot> :)
09:37:03 <xerox> (1 `f` 2) 3 4
09:37:11 <vincenz> xerox: notice the necessity for () to work
09:37:16 <xerox> Sure.
09:37:18 <vincenz> implying 1 `f` 2 is an operator
09:37:26 <sjanssen_> vincenz: the problem with your 1 `f` 3 4 is that function application binds tighter than any operator
09:37:26 <vincenz> cause ():: op -> nonop
09:37:36 <Igloo> vincenz: No
09:37:38 <vincenz> sjanssen_: yet it doesn't complain about that
09:37:50 <vincenz> sjanssen_: it doesn't say "can't apply 3 to 4"
09:37:59 <vincenz> > let f a b c = a + b +c in 1 `f` 2 3
09:38:00 <lambdabot>  add an instance declaration for (Show (a -> a))
09:38:04 <sjanssen_> vincenz: that is essentially what it is saying
09:38:08 <vincenz> no
09:38:11 <vincenz> it's basically dropping 3
09:38:16 <vincenz> and saying it can't show a function
09:38:16 <xerox> Dropping?
09:38:27 <vincenz> otherwise it would say
09:38:39 <vincenz> can't type Num to (a->b)
09:38:40 <vincenz> or something
09:38:48 <Igloo> vincenz: You're only seeing 1 of many type errors
09:39:20 <Igloo> Those parentheses are purely for precedence, nothing to do with converting operators to functions
09:39:36 <vincenz> Igloo: heh funky
09:39:40 <vincenz> ghc gives a different error
09:39:51 <norpan> Igloo: they are for syntax, not for precedence
09:40:12 <norpan> in the case of operators at least
09:40:14 <vincenz> the syntax is murky and nonorthogonal with infix
09:40:24 <Igloo> norpan: I'm talking about the parens in (1 `f` 2) 3 4
09:40:33 <norpan> Igloo: ah, yes
09:41:13 <norpan> () is another form of syntax
09:41:28 <norpan> so they are used for more
09:41:49 <norpan> a rather stupid syntax methinks
09:42:00 <norpan> (1,2) is more synta
09:42:01 <norpan> x
09:42:01 <sjanssen_> vincenz: ghci seems to cut off the second type error, if you define f first, then do "print (1 `f` 2 3)" you get the real errors
09:42:13 <vincenz> hmm
09:42:19 <vincenz> point taken
09:42:22 <norpan> you will only get one error from ghc
09:42:35 <sjanssen_> oh! I get it
09:43:16 <sjanssen_> both errors are valid.  (2 3) forces the entire expression to be (a -> a), and ghci complains because it can't show things like that
09:43:26 <vincenz> nope
09:43:37 <vincenz> hmm
09:43:38 <vincenz> nm
09:43:40 <vincenz> anyways
09:43:42 * vincenz off
09:57:40 <wobster> it`s the first time I touch haskell. I installed HUGS, hope that is apropriate for the beginning? I assume an expression like 'tuple :: (Int,Int)' is correct? would I have to specify a 'module` or something? (*sigh* .. I'm a helples puppy)
09:58:12 <mahogny> wobster, I find GHC(i) to be easier to use. the error messages in hugs are quite cryptic
09:58:20 <mahogny> tuple :: ... is correct
09:58:30 <mahogny> dunno if hugs need module
09:58:56 <wobster> hm. I simply started hugs or ghci and just typed that and get a syntax error.
09:59:26 <wobster> "not in scope" says ghci
09:59:52 <mahogny> you don't need to put in type declarations if you write code "online" in ghci
10:00:04 <mahogny> it makes more sense if you write .hs-files and load them
10:00:54 <wobster> oh. I thought it was like some direct evaluation.
10:01:19 <mahogny> haskell usually don't need type declarations but if you write code it's a good habit to have them anyway
10:02:26 <Philippa> they're good documentation, and you can use them to tell the compiler about extra things you want enforced (though it gets a lot of hints about that from datatype declarations)
10:02:46 <mahogny> not to mention, it helps debugging a lot
10:03:17 <Philippa> see "documentation" :-)
10:03:19 <wobster> hehe. I guess I will have to debug A LOT the next days 
10:03:31 <wobster> Philippa, I can live with a plain rtfm :)
10:03:36 <Philippa> though yes, the more type annotations the closer to the source of the error a type error message'll be
10:03:52 <mahogny> wobster, haskell has a nice tendency; when the compiler finally lets your code through, it usually works on first try
10:03:59 <Philippa> wobster: often the type of a function is a good start for its M
10:04:03 <mahogny> (but expect lots of compile time errors)
10:05:29 <wobster> what's a very simple expression that I can eval with that interative shells? just to remove the fud .. 
10:06:11 <mahogny> 1+1
10:06:12 <Saulzar> map (+ 2) [1, 2, 3]
10:06:13 <mahogny> :)
10:06:35 <wobster> ah. ok. my habit: x = 4 .. hoped that would work at least ;) 
10:06:56 <wobster> jesus. it's like voodoo. 1+1 = 2 .. 
10:07:16 <mahogny> you never expected that result, did you?
10:07:20 <wobster> NEVER
10:07:45 <wobster> though Saulzar's example is way cooler :)
10:08:55 <wobster> alright then. I do not want to use up your time. thanks until here. 
10:10:17 <JohnnyL> > map  (+ 2) [(1,1),(2,2)]
10:10:18 <lambdabot>  add an instance declaration for (Num (a, b))
10:12:43 <JohnnyL> > map  (+ 2) [3,(1,1),(2,2)]
10:12:44 <lambdabot>  add an instance declaration for (Num (a, b))
10:12:44 <lambdabot>   In the list element: 3
10:13:00 <JohnnyL> >zipwith  (+ 2) [3,(1,1),(2,2)]
10:13:05 <JohnnyL> > zipwith  (+ 2) [3,(1,1),(2,2)]
10:13:06 <lambdabot>  Not in scope: `zipwith'
10:14:57 <sjanssen_> JohnnyL: it's zipWith
10:15:05 <sjanssen_> and you can't mix element types in a list
10:15:24 <JohnnyL> > zipWith  (+ 2) [3,1,1,2,2]
10:15:26 <lambdabot>  add an instance declaration for (Show ([b] -> [c]))
10:15:43 <JohnnyL> > map  (+ 2) [3,1,1,2,2]
10:15:45 <lambdabot> [5,3,3,4,4]
10:15:56 <sjanssen_> @type zipWith
10:15:58 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
10:16:13 <sjanssen_> > zipWith (+) [1, 2, 3] [4, 5, 6]
10:16:15 <lambdabot> [5,7,9]
10:16:52 <JohnnyL> why is zipWith ... c b a, why reversed?
10:17:44 <sjanssen_> I'm not sure what you mean
10:18:55 <Saulzar> Just a quirk with the type pretty printer
10:19:03 <Saulzar> The order doesn't matter
10:19:40 <sjanssen_> ah yes.  in fact, that isn't valid Haskell 98
10:21:45 * JohnnyL is confused.
10:22:49 <DeliQ> the forall c b a is just a quantification, the order doesn't matter...
10:23:06 <Saulzar>  "forall c b a." is implicit in haskell 98 type definitions
10:23:53 <Saulzar> eg. Foo :: a -> b -> c  in haskell 98 is printed by ghc as Foo :: forall a b c. a -> b -> c
10:24:32 <sjanssen_> Saulzar: only if -fglasgow-exts is given
10:24:58 <Saulzar> Ah, hmm.
10:25:11 <Saulzar> I guess it is, with @type
10:25:38 <sjanssen_> yeah, presumably so we can @type things like runST
10:35:43 <Cale-work> @type runST
10:35:45 <lambdabot> Not in scope: `runST'
10:35:54 <Cale-work> @type Control.Monad.ST.runST
10:35:56 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
10:39:41 <xerox> ?hoogle (a -> Bool) -> [a] -> Bool
10:39:42 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
10:39:42 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
10:39:46 <xerox> ?hoogle+
10:39:54 <xerox> No "none" ?  (-:
10:42:08 <sjanssen_> @pl none pred = all (not . pred)
10:42:10 <lambdabot> none = all . (not .)
10:42:59 <sjanssen_> @pl none pred = not . any pred
10:43:00 <lambdabot> none = (not .) . any
11:38:41 <basti__> o.0
11:38:44 <basti__> wtf.
11:53:23 <RyanT5000> if i have an Arrow from b to c, and an Arrow from b' to c', and i combine them using ***, can i invoke the arrow on (someB, undefined) so long as i never look at snd of the result?
11:53:47 <basti_> I'd think so yes.
11:54:55 <RyanT5000> hm, i think that might resolve the differences between the datatype i've been working on and arrows
11:57:16 <JohnnyL> > :type (:)
11:57:18 <lambdabot>  parse error on input `:'
11:57:21 <JohnnyL> > type (:)
11:57:23 <lambdabot>  parse error on input `type'
11:57:27 <JohnnyL> @pl type (:)
11:57:28 <lambdabot> type (:)
11:57:35 <JohnnyL> @pl :type (:)
11:57:37 <lambdabot> (line 1, column 1):
11:57:37 <lambdabot> unexpected ":"
11:57:37 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
11:57:40 <JohnnyL> help
11:57:41 <liyang> :type (:)
11:57:48 <RyanT5000> JohnnyL: @type
11:57:50 <liyang> @type (:)
11:57:52 <lambdabot> forall a. a -> [a] -> [a]
11:59:04 <JohnnyL> @load *
11:59:05 <lambdabot> Unknown command, try @list
12:00:14 <JohnnyL> where can i get the source to just the bare bones interpreter for a haskell implementation?
12:02:04 <basti_> JohnnyL: haskell is unlike lisp (which can be implemented trivially)
12:03:28 <sjanssen1> JohnnyL: Haskell is a pretty big language.  It'd be hard to call an interpreter of it "bare bones"
12:03:42 <norpan> start with lambda calculus
12:11:35 <mwc> ghci -fth -package template-haskell Main.hs gives me:
12:11:44 <mwc> Loading package base-1.0 ... linking ... done.
12:11:44 <mwc> Loading package haskell98-1.0 ... linking ... done.
12:11:44 <mwc> Loading package template-haskell-1.0 ... linking ... done.
12:11:44 <mwc> Could not find module `Langauge.Haskell.TH.Syntax':
12:11:53 <mwc> any ideas what's going on?
12:14:51 <mwc> besides the fact that I can't detect vowel transpositions? :P
12:16:17 <basti_> :D
12:18:47 <JohnnyL> @version
12:18:48 <lambdabot> lambdabot 3p414, GHC 6.4.1 (Linux i686 3.20GHz)
12:18:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:38:49 <Saulzar> A fun and very useless exersize, pl0 -> Haskell compiler 
12:42:03 <RyanT5000> is there an "eval" in haskell?
12:42:32 <xerox> @hoogle eval
12:42:34 <lambdabot> Control.Exception.evaluate :: a -> IO a
12:42:34 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
12:42:34 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:42:42 <xerox> @hoogle+
12:42:43 <lambdabot> Control.Monad.RWS.evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
12:42:43 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
12:42:43 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
12:42:53 <xerox> Hoogle doesn't index hs-plugins :-)
12:42:57 <lispy> RyanT5000: unsafePerformIO, runST, etc. is perhaps what you want?
12:43:05 <Saulzar> Not really, there is a library called hs-plugins which utilises ghc to evaluate expressions and dynamically load modules though
12:43:17 <RyanT5000> actually i don't know what i want, i'm just curious
12:43:26 <lispy> RyanT5000: oh, then try lisp :)
12:43:31 <RyanT5000> lol
12:43:35 <xerox> Yep.  That's what does here:
12:43:36 <RyanT5000> i have tried lisp
12:43:39 <xerox> > 2+2
12:43:41 <lambdabot> 4
12:43:41 <sjanssen1> eval doesn't really fit the Haskell culture
12:43:53 <xerox> It surely fits in the channel culture :-)
12:43:54 <lispy> the haskell culture isn't eval
12:43:55 <RyanT5000> right, i didn't want something unstructured and gay like in lisp
12:44:04 <xerox> haha.
12:44:25 <lispy> gay == happy and joyful?
12:44:29 <RyanT5000> sure :P
12:45:09 <lispy> otherwise, i'd say that comment was inappropriate at best...
12:45:12 <RyanT5000> i'm writing a game engine (as many of you already know) and i was just thinking about the possibility of embedding a haskell language
12:45:20 <RyanT5000> yeah, sorry all
12:45:47 <RyanT5000> i spend way too much time talking to gamers
12:46:09 <RyanT5000> where the word "ghey" has a rather different meaning, and is generally not considered offensive
12:46:10 <RyanT5000> :-X
12:46:23 <wchogg> RyanT5000:  Just as long as you don't start using "jewish" as a perjorative I think you're in the clear.
12:46:28 <RyanT5000> lol alright
12:47:18 <lispy> i say we start adopting the insults from the TV show firefly
12:47:24 <RyanT5000> hell yeah!
12:47:24 <lispy> Goram compiler!
12:47:34 <wchogg> lispy:  But I don't know Mandarin.
12:47:40 <lispy> wchogg: hehe
12:47:59 <lispy> i know two languages, bad english and worse english
12:48:18 <lispy> i also know some really bad jokes
12:48:43 <lispy> so this lambda abstraction walks into a bar...
12:49:21 * lispy has no clue where to go with that...
12:49:56 <sjanssen1> bah, why don't they release the ACM World Finals problems already?
12:58:08 <JohnnyL> > ord 'K'
12:58:09 <lambdabot> 75
12:58:38 <xerox> Welcome back Philippa.
12:59:04 <int80_h> poo wut about me?
12:59:42 <RyanT5000> is there a holographic proof library for haskell?
12:59:58 <int80_h> eep
13:00:11 <RyanT5000> or, to put it a different way, is there a holographic proof library for anything?
13:00:23 <basti_> uhm?
13:00:31 * int80_h looks up holographic proofs
13:01:16 <basti_> i'd say no.
13:01:20 <basti_> why do you ask?
13:01:27 <basti_> for formal logics, I'm using coq.
13:01:31 <basti_> if i do formal logics.
13:01:51 <Philippa> re
13:01:52 <RyanT5000> well i was thinking about doing some distributed untrusted stuff
13:02:07 <RyanT5000> i.e.: i send you a computation to perform, you perform it and send me a proof that you actually performed that computation
13:02:12 <basti_> after your game, or before?
13:02:22 <RyanT5000> after :)
13:02:25 <basti_> you don't need holographic proof for that.
13:02:30 <basti_> NP will be more than enoguh
13:02:40 <RyanT5000> yeah but what if it's not an NP operation
13:02:47 <RyanT5000> e.g.: collision detection
13:02:56 <RyanT5000> i think that's n^3 or so
13:03:10 <basti_> n, with line scanning, IIRC.
13:03:23 <RyanT5000> hm?
13:03:28 <RyanT5000> i think we're referring to different n's
13:03:48 <basti_> n in the number of rectangles to check
13:03:54 <basti_> ((bounding) rectangles)
13:04:04 <xerox> ((lispy)) !
13:04:24 <RyanT5000> doesn't that assume that everything in your world is a rectangle?
13:04:36 <basti_> RyanT5000: strictly speaking, yes.
13:04:41 <RyanT5000> what if you're collision-detecting arbirary polygons
13:04:55 <basti_> then you bound them by rectangles and save a lot of checks.
13:05:14 <RyanT5000> right, but it's still fundamentally worse than O(n)
13:05:25 <RyanT5000> e.g.: if all their bounding rectangles interconnect
13:05:35 <RyanT5000> imagine collision-detecting a chain :P
13:06:03 <RyanT5000> actually that might not be so terrible
13:06:06 <RyanT5000> if it's stretched out
13:06:14 <Philippa> you just approximate the chain the obvious way
13:06:20 <RyanT5000> yes yes i know that
13:06:26 <RyanT5000> i'm not talking about "how can i make the problem easier"
13:06:40 <RyanT5000> i'm talking about "given a hard problem, how do i farm it out to untrusted clients"
13:06:45 <RyanT5000> er, servers (?)
13:06:54 <basti_> I'd pick an NP complete problem then.
13:06:56 <RyanT5000> untrusted processing nodes ,anywya
13:07:00 <basti_> for obvious reasons
13:07:06 <RyanT5000> right, that's obviously the best
13:07:06 <basti_> ah you're thinking that way
13:07:18 <RyanT5000> hm?
13:07:30 <basti_> you want to divide computation load and check the results?
13:07:34 <RyanT5000> right
13:07:38 <basti_> (i thought you were heading to hashcash or something)
13:07:47 <RyanT5000> and i don't necessarily trust the people doing the computations
13:07:49 <Cale-work> If your problem is NP, then you can have them send you a certificate which verifies their solution in polynomial time of course.
13:07:56 <basti_> not any solution is proveable.
13:07:57 <RyanT5000> right
13:07:59 <basti_> every
13:08:02 <basti_> I'm sorry
13:08:11 <basti_> or thats what i'd say
13:08:16 <RyanT5000> how could there be an unprovable solution?
13:08:25 <basti_> i mean: provable with less effort.
13:08:26 <RyanT5000> you could theoretically send a complete execution trace
13:08:28 <Cale-work> But it sounds like you want subpolynomial time?
13:08:30 <RyanT5000> that i'll believe
13:08:35 <basti_> for example, take ackermann(17) mod 10
13:08:37 <RyanT5000> i just want any reduction in order
13:08:43 <basti_> somebody says it's "5"
13:08:57 <RyanT5000> what's ackermann(x)?
13:09:01 <basti_> hmm
13:09:07 <basti_> the ackermann function is...
13:09:07 <xerox> ?wikipedia Ackermann
13:09:07 <Cale-work> Well, the thing about holographic proofs is that they're polylogarithmic
13:09:10 <lambdabot> No Result Found.
13:09:12 <xerox> !!
13:09:21 <xerox> ?wikipedia Hackermann
13:09:22 <xerox> :-P
13:09:23 <lambdabot> No Result Found.
13:09:28 <basti_> ackermann(1) is like addition, ackermann(2) is like multiplication, ackermann (3) is like potenciation etc.
13:09:53 <basti_> http://en.wikipedia.org/wiki/Ackermann_function
13:11:08 <RyanT5000> hm
13:12:03 <basti_> the point is, ackermann(17) would be extraordinary hard to calculate
13:12:12 <basti_> like, take longer than the universe is old or something
13:12:19 <RyanT5000> alright
13:12:24 <RyanT5000> that sounds good
13:12:35 <RyanT5000> the question is whether you can prove your result is correct in less time than that
13:12:43 <basti_> no that sounds like a typical example in theoretical CS ;)
13:12:48 <RyanT5000> lol
13:13:02 <basti_> yes, and i beleive there is none, but i don't have any proof for that
13:13:11 <RyanT5000> :P
13:15:25 <RyanT5000> wow, 2^2, m times, where m = (2^2, 65536 times)
13:15:43 <RyanT5000> = ackermann(5, 5)
13:15:47 <Cale-work> http://en.wikipedia.org/wiki/Graham%27s_number
13:16:29 <basti_> ackermann's function was the first that was proven not to be primitively-recursive, iirc
13:16:51 <RyanT5000> yes
13:16:53 <basti_> (that is, the first that -requires- a real computer (instead of a pocket calculator) to calculate)
13:17:42 <basti_> -recursive
13:17:56 <xerox> -calculus
13:18:26 <int80_h> stop that. stop that right now ;)
13:18:34 <xerox> :-P
13:18:59 <basti_> btw. theres functions growing even faster.
13:19:01 * basti_ ducks
13:19:08 <xerox> Hmm, what was that?
13:19:16 <basti_> busy beaver function.
13:38:09 <RyanT5000> how is "instance Arrow (->)" valid?
13:38:25 <RyanT5000> is -> really a type constructor with kind * -> * -> *?
13:38:42 <RyanT5000> and if so, how do i use it?
13:38:59 <xerox> Yes.
13:39:05 <xerox> You do all the time, don't you?
13:39:11 <RyanT5000> what i mean is
13:39:23 <RyanT5000> how do i define an arrow with it
13:39:29 <RyanT5000> so like i say
13:39:33 <RyanT5000> arr (+1)
13:39:47 <xerox> arr (+1)  (+1)
13:39:57 <xerox> The nice ones are the combinators.
13:39:59 <RyanT5000> i can't read that unicode
13:40:09 <xerox> Pfft.
13:40:12 <RyanT5000> sry :-/
13:40:29 <xerox> It's just that (+1) is equivalent to arr (+1) and pure (+1).
13:40:42 <xerox> Then you have:
13:40:42 <RyanT5000> ah
13:40:56 <xerox> (f &&& g) x = (f x,g x)
13:41:08 <xerox> (f *** g) (x,y) = (f x,g y)
13:41:16 <xerox> first f (x,y) = (f x,y)
13:41:23 <xerox> second f (x,y) = (x,f y)
13:41:31 <xerox> (>>>) = flip (.)
13:41:57 <RyanT5000> ok but shouldn't arr (+1) be legal?
13:42:05 <xerox> arr (+1) is legal.
13:42:11 <RyanT5000> > arr (+1)
13:42:12 <lambdabot>  add an instance declaration for (Show (a b b))
13:42:13 <xerox> ?type Control.Arrow.arr (+1)
13:42:15 <lambdabot> forall (a :: * -> * -> *) b.
13:42:15 <lambdabot>          (Arrow a, Num b) =>
13:42:15 <lambdabot>          a b b
13:42:31 <xerox> Where you generalized (->) to Arrow a :-)
13:42:40 <RyanT5000> Prelude Control.Arrow> arr (+1) 
13:42:40 <RyanT5000>  
13:42:40 <RyanT5000> <interactive>:1:0: 
13:42:40 <RyanT5000>     Ambiguous type variable `t' in the constraint: 
13:42:40 <RyanT5000>       `Arrow t' arising from use of `arr' at <interactive>:1:0-7 
13:42:40 <RyanT5000>     Probable fix: add a type signature that fixes these type variable(s)
13:42:52 <xerox> That's defaulting
13:43:05 <RyanT5000> hm?
13:43:07 <xerox> Try giving a signature.
13:43:21 <xerox> Also, there's a special syntax for arrows signatures if you will..
13:43:44 <RyanT5000> i tried; i didn't know what signature to give
13:44:02 <xerox> ?type (Control.Arrow.arr (+1) :: (Control.Arrow.Arrow (~>)) => (Int ~> Int))
13:44:04 <lambdabot> forall (~> :: *
13:44:04 <lambdabot>                               -> * -> *).
13:44:04 <lambdabot>                          (Arrow ~>) =>
13:44:04 <lambdabot>                          ~> Int Int
13:44:15 <RyanT5000> oh
13:44:22 <xerox> I hope it's not confusing but enlighting.
13:44:26 <xerox> enlightening, even.
13:45:26 <RyanT5000> alright so you just now defined ~>
13:45:33 <RyanT5000> to be an Arrow
13:45:45 <RyanT5000> and then you defined it to be from Int to Int
13:45:53 <RyanT5000> right?
13:46:25 <xerox> Yep.
13:46:37 <xerox> As I said, a -> b is equivalent to a ~> b.
13:46:43 <xerox> FVSO equivalent.
13:46:57 <RyanT5000> alright, but i can't just use ->
13:47:06 <RyanT5000> even though there's apparently an instance declaration?
13:47:36 <xerox> Why can't you?
13:48:22 <RyanT5000> ?type (arr (+1)) :: (Int -> Int)
13:48:24 <lambdabot> (Int -> Int) :: Int -> Int
13:48:26 <RyanT5000> crap
13:48:28 <xerox> Good.
13:48:31 <RyanT5000> that's not what i tried, lol
13:48:34 <xerox> (-:
13:48:54 <RyanT5000> ?type (arr (+1)) :: (Num a => a -> a)
13:48:56 <lambdabot> (Num a => a -> a) :: forall a. (Num a) => a -> a
13:49:02 <RyanT5000> alright fine :P
13:49:29 <xerox> The combinators are usefully at times.
13:49:42 <RyanT5000> yeah
13:49:50 <xerox> Err, useful.
13:50:05 <RyanT5000> well i'm trying to figure out if you can statically type the different input/outputs of arrows
13:50:35 <xerox> Err... ?
13:50:51 <RyanT5000> so let's say you have an arrow for input/output using Yampa
13:50:54 <RyanT5000> what i've seen so far
13:51:03 <xerox> I.e. (Arrow (~>)) :: (a ~> b) ?
13:51:05 <RyanT5000> is you have inputs for all your different mssages
13:51:21 <xerox> ohub, yampa.
13:51:22 <RyanT5000> as well as your game state or whatever
13:51:26 <xerox> Ops, sorry ohub :-(
13:51:30 <jlhamilton> @pl zip (inits xs) (tails xs)
13:51:30 <ohub> :D
13:51:31 <lambdabot> zip (inits xs) (tails xs)
13:51:47 <jlhamilton> @pl \xs -> zip (inits xs) (tails xs)
13:51:48 <xerox> ap inits tails ?
13:51:49 <lambdabot> liftM2 zip inits tails
13:51:52 <xerox> liftM2, right.
13:51:52 <RyanT5000> and then you have outputs for the new game state and the rendering frame
13:52:22 <xerox> Sorry, I don't know about Yampa.
13:53:15 <RyanT5000> well the basic point is that i'm making a windowing system, and it seems like the same datastructure should represent the input-handling scheme as welll as the output-generating scheme
13:53:58 <RyanT5000> however, with arrows, if it's the same arrow, it seems like it'd have to do both at once
13:54:21 <RyanT5000> and i don't see any reason there should be an isomorphism between receiving a message (like a keystroke) and producing a frame of output
13:54:58 <RyanT5000> if you think about a hypothetical single-threaded server that processes lots of input messages per second but only produces one frame out output per second, the problem becomes apparent
13:55:34 <RyanT5000> that can certainly be done in yampa, but i don't see how it can be statically typed in yampa
14:00:50 <RyanT5000> maybe i need an existential arrow?
14:16:24 <vincenz> Anyone here worked on a raytracer in haskell before?
14:16:39 <xerox> Boegel.
14:17:06 <vincenz> basically I'm wondering how to type my main renderfunc
14:17:23 <vincenz> as in what to return
14:17:25 <vincenz> an array?
14:17:28 <vincenz> a lazy stream of pixels?
14:17:41 <xerox> Dunno.  Search for his work, maybe.
14:17:48 <xerox> It's linked from Gtk2Hs site I think.
14:23:26 <BCoppens> http://www.haskell.org/tmrwiki/HRay, no?
14:27:11 <vincenz> yep
14:36:35 <basti_> RyanT5000: how much work does it take to convert a proof to holographic form? and, you're aware that bringing it to a suitable form might be rather complicated? (it has to be self-contained!)
14:47:44 <basti_> night
14:50:30 <xX[ReP]Xx> does ghc work on os x i386 yet?
14:54:03 <jip> vincenz: http://benny.kramekweb.com/hrayt
14:56:17 <vincenz> jip: doesn't provide sources
14:56:49 <jip> vincenz: i know that this raytracer returned a list of list for it's image result
14:57:00 <vincenz> ah cool
15:02:56 <RyanT5000> vincenz: are you trying to represent a bitmap?
15:06:10 <vincenz> RyanT5000: undecided
15:06:22 <vincenz> I'm just going with the hray example from haskell.or
15:06:25 <vincenz> and then I'll extend later
15:06:39 <RyanT5000> well what if you return a (Ix i => i -> Color)?
15:06:51 <RyanT5000> where Color is whatever your representation of a pixel's state is
15:07:01 <RyanT5000> (btw i have no experience with ray tracers)
15:07:06 <vincenz> me neither
15:07:16 <RyanT5000> anyway, if you returned that, you'd be able to encapsulate anything you liked
15:07:21 <RyanT5000> like, a big Array
15:07:32 <RyanT5000> or a list of lists
15:07:33 <RyanT5000> or whatever
15:08:23 <jip> vincenz: i can hook you up with the source if you like
15:13:39 <vincenz> jip: oo
15:22:55 <jip> vincenz: interested?
15:24:11 <vincenz> jip: yep
15:25:44 <vincenz> jip: got my pm?
15:26:03 <jip> vincenz: yeah, but i can't respond. it's one small file i'll paste it
15:26:09 <vincenz> jip: ok
15:27:14 <jip> vincenz: http://rafb.net/paste/results/EmHNLq12.html
15:27:46 <vincenz> damn there are a lot of plugins for google
15:29:05 <sjanssen_> jip: do you realize that {x,y,z}FromV3 are all the same?
15:29:32 * esap is trying to understand epimorphisms f : A+B --> Q
15:30:02 <sjanssen_> jip: and some of those ! in your data decls won't help you (and perhaps hurt you)
15:31:48 <jip> sjanssen: this code was written a long long time ago :)
15:48:23 * SyntaxNinja wiggles eyebrows in general direction of: http://hackage.haskell.org/trac/halfs/wiki/News
15:51:03 <vincenz> sjanssen_: interesting
15:52:08 <vincenz> SyntaxNinja that is
15:52:15 <vincenz> damn tab complete
15:53:33 <sieni> vincenz: in Finland we would just say: http://reminder.ton.tut.fi/
15:54:23 <sieni> ("Et vaan osaa!" == "You just aren't able to!")
16:03:51 * vincenz peers at sieni
16:10:33 * vincenz is off
17:27:16 <RyanT5000> is haskell.org down?
17:30:19 <sjanssen_> RyanT5000: it responds to pings, and darcs.haskell.org works
17:30:23 <sjanssen_> but not www.haskell.org
17:30:37 <RyanT5000> gah
17:30:55 <RyanT5000> how am i supposed to learn how Fruit works!!!
17:43:40 <sethk> how do I force an expression to be evaluated?  generally, not just within the IO monad?
17:44:08 <sjanssen_> sethk: with seq
17:44:27 <sethk> sjanssen, I tried that, it didn't seem to do it.  Maybe I didn't apply it correctly, I'll check it again.
17:44:34 <sjanssen_> > last [1..] `seq` 2
17:44:38 <lambdabot> Terminated
17:46:40 <Cale> sethk: x `seq` y evaluates x up to determining the top level constructor before resulting in y
17:47:05 <sethk> Cale, I'm trying to do something like what Debug.Trace does
17:47:26 <sethk> Cale, I want to do     myTraceThing ..... $ the original statement
17:47:39 <sethk> Cale, and the type must be the same type as    the original statement
17:47:48 <Cale> okay
17:48:13 <sethk> Cale, and the stuff to the left of $ isn't executed
17:48:21 <sethk> Cale, I assume because it isn't forced
17:48:24 <Cale> what happens?
17:48:31 <Cale> well, first of all, how do you know that?
17:48:45 <Cale> (and what is to the left of $ ?)
17:48:51 <sethk> Cale, basically a print
17:49:05 <sethk> Cale, so I should see the output
17:49:06 <Cale> print is an IO action, evaluating it doesn't actually cause anything to happen
17:49:17 <Cale> well, it produces an IO action
17:49:28 <sethk> Cale, if it produces the action, then I would see the print
17:49:33 <Cale> no
17:49:47 <Cale> building an action and actually executing it are different
17:49:56 <sethk> ok, then I want to execute it
17:50:11 <Cale> the special and dangerous hook into the runtime system which lets you do that is called unsafePerformIO
17:50:28 <sethk> Cale, that's the only way to get the behavior I want?
17:50:56 <Cale> I'm not sure what behaviour you really want
17:51:04 <Cale> it's how Debug.Trace is written
17:51:14 <sethk> Cale, similar to debug.trace
17:51:35 <Cale> you can just write things in terms of Debug.Trace
17:51:44 <Cale> if you want to print more elaborate messages
17:52:25 <sethk> Cale, I don't want to do that, if I can avoid it.  I have code I want to leverage
17:53:07 <Cale> what's the goal?
17:53:27 <Cale> If it's anything other than debugging, I recommend doing something entirely different
17:53:44 <sethk> Cale, it is only for debugging
17:54:10 <sethk> I can do it as two separate expressions
17:55:03 <sethk> it's just for debugging so it isn't worth spending time on
18:29:24 <dons> ?karma+ SyntaxNinja -- halfs is released!
18:29:25 <lambdabot> SyntaxNinja's karma raised to 9.
18:29:52 <dons> ?where+ halfs http://www.haskell.org/halfs/
18:29:53 <lambdabot> Done.
18:37:08 <newsham> how do I reach the haskell cvs on sf.net?
18:39:19 <dons> ? there's no such thing. is there? its all kept in darsc, on haskell.org these days.
18:39:35 <newsham> http://sourceforge.net/projects/haskell-libs
18:39:41 <newsham> so this stuff is deprecated?
18:40:02 <dons> hmm. don't know what that stuff is.
18:40:34 <dons> look at the check otu instructions on haskell.org/ghc its kept in http://darcs.haskell.org/
18:40:40 <newsham> http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/
18:40:47 <newsham> hws-wp is there, which is what i'm trying to track down.
18:42:04 <newsham> (dont see it on the darcs site)
18:44:35 <dons> why not mail the author?
18:44:44 <newsham> did that last week.
18:53:25 <araujo> uuh.. halfs
18:53:27 <araujo> cool
18:53:52 <dons> stunning, really. we need more of this kind of stuff :)
18:54:02 <araujo> hi dons 
18:54:04 <araujo> indeed.
18:54:15 <dons> hehe. haskell.org is creeping towards 100k hits since it became a wiki :)
18:54:49 <araujo> Good!
18:54:54 <dons> 99,783 so far. but its getting more and more each day I  think. around 1100 hits a day, if i read the numbers correctly
18:55:18 <dons> hopefully with more content, and more dynamic content, we see more visitors
18:55:32 * araujo nods
18:55:43 <RyanT5000> 1100 unique per day?
18:55:50 <araujo> dons, it's been a good choice to change the site to a wiki
18:55:54 <RyanT5000> cause  if it's just 1100 per day, that's probably about 20% me
18:56:00 <dons> hehe
18:56:07 <dons> not sure if its unique visitors
18:56:15 <dons> araujo: sure its
18:56:36 <dons> sure is. we've had more changes and updates in hte past 4 weeks than in the previous 8 years
18:56:41 <araujo> Oh right, the hits have abruptaly increased with RyanT5000 ;-)
18:57:00 <RyanT5000> :P
18:57:31 <araujo> RyanT5000, *joking* :-]
18:57:37 <RyanT5000> i know :P
18:57:56 * araujo admits he got haskell.org as his homepage actually
18:58:49 <wchogg> Would anyone mind helping with a fundeps question?  It's pretty basic I'm sure.
18:59:11 <araujo> dons, have you used this fs?
18:59:17 <newsham> *sigh* I just downloaded via silly cvs web interface 
18:59:28 <dons> nope. i don't run linux. but i've read the src
18:59:38 <dons> wchogg: just ask. if someone knows, they'll answer :)
19:00:08 <newsham> I dont run unix sixth edition, but i've read the src
19:00:20 <dons> hehe
19:00:31 <dons> i don't run linux, but i've read the src of halfs
19:00:35 <dons> in case that wasn't clear.
19:00:51 <dons> s/,/ so i can't _run_ halfs, /
19:01:22 <araujo> dons, was clear for me ;-)
19:01:51 <newsham> doesnt one of those companies you mentioned a few days ago use halfs on embedded systems?
19:02:07 <dons> yep. galois.
19:02:16 <jip> next step is to get haskell.org to validate :P
19:02:21 <lisppaste2> wchogg pasted "What'd I do wrong?" at http://paste.lisp.org/display/18927
19:03:04 <newsham> thats not linux, right? :)
19:03:24 <dons> well. who knows what it is.
19:03:54 <araujo> But hold, can this fs be used as the main fs for a linux system?
19:04:22 <dons> "Halfs can be mounted and used
19:04:23 <dons> like any other Linux filesystem"
19:04:37 <dons> the only one with strong static typing, I guess.
19:05:24 <araujo> cool
19:05:38 <newsham> C typing not good enough? ;-)
19:05:56 <araujo> Right
19:06:01 <dons> depends on your opinion of segfaults, I guess
19:06:25 <araujo> you can still pretty much get dynamic typing with C
19:06:39 <RyanT5000> almost every C program seems to have plenty of casts
19:06:44 <newsham> FUSE is neat and all, but i wouldnt want to use it for anything "real"
19:06:56 <wchogg> Anyway, if I can get an opinion as to why I'm getting those problems with fundeps I'd appreciate it.
19:07:07 <dons> araujo: dynamci typing? or jsut weak typing.
19:07:17 <dons> there's no typecase at runtime.
19:07:25 <RyanT5000> there's dynamic_cast
19:07:29 <RyanT5000> which is almost something like that
19:07:36 <astecp> C's type system is piss-weak
19:07:48 <astecp> although you're probably using the terms in a slightly more formal sense ;)
19:07:49 <RyanT5000> er, dynamic_cast is C++
19:08:02 <RyanT5000> no, piss-weak is formally defined :P
19:08:07 <dons> thought so. a different beast. C is jsut weakly statically typed.
19:08:18 <RyanT5000> "Piss-Weak Typing: see C's typing system"
19:08:38 <astecp> for instance: enums
19:08:45 <RyanT5000> enums suck so much
19:08:46 <RyanT5000> holy crap
19:08:50 <RyanT5000> they don't even have sensible scoping
19:08:56 <wchogg> Abbreviate that to PW Typing and you might be able to make it an academic topic.
19:09:15 <RyanT5000> definitely :)
19:09:32 <jip> c has back-ported the strong typing features from c++
19:10:09 <araujo> dons, well, you can use casting with pointers to give you a slight dynamica typing system
19:10:33 <araujo> many casting operations could let you cheat on the static system
19:11:28 <RyanT5000> how do you implement a "Save button" in Yampa? have an output of your arrow saying "please save this"?
19:11:34 <dons> casting pointers? you're still statically determining the types of things though. there's no way to find out the type of something at runtime, no?
19:11:49 <jip> RyanT5000: what do you mean by save?
19:11:50 <RyanT5000> things don't have types at runtime
19:11:57 <RyanT5000> i mean i want a button that does serialization
19:12:00 <dons> i.e. a ptr cast is jsut f :: Ptr a -> Ptr b
19:12:05 <RyanT5000> a GUI widget
19:12:08 <jip> RyanT5000: you mean an IO action?
19:12:09 <RyanT5000> that has access to the file system
19:12:10 <dons> RyanT5000: dynamically typed languages have types at runtime.
19:12:12 <RyanT5000> essentially
19:12:17 <dons> so do things wrapped in Data.Dynamic
19:12:21 <RyanT5000> right, i know
19:12:30 <RyanT5000> i wasn't disagreeing with you, dons
19:13:05 <jip> RyanT5000: you're going to need to feed this event all the way through to your output signal
19:13:28 <RyanT5000> alright
19:13:51 <RyanT5000> i'm trying to decide if i want to use yampa at all
19:13:54 <araujo> dons, i mean, that you can jump the static checking system for the type.
19:14:11 <dons> so its just weakly statically typed.
19:14:23 <Excedrin> 1
19:14:33 <RyanT5000> tbh i don't really see what yampa buys me
19:14:35 <Saulzar> RyanT5000, If you're just starting out, it's best to avoid it.
19:14:56 <RyanT5000> that's what i'm leaning towards :)
19:15:02 <jip> why? yampa is great
19:15:11 <RyanT5000> but what does it do?
19:15:17 <RyanT5000> i've read a lot about it
19:15:19 <Saulzar> Not so much for learning haskell...
19:15:37 <RyanT5000> i read the introduction to yampa in that one thesis
19:15:44 <jip> i'm still a super haskell newbie, and doing lots of yampa programming was one of the first things i did in haskell
19:15:53 <RyanT5000> and i've read a program written in yampa
19:16:13 <RyanT5000> i mean it seems like yampa would make things like "create a window" really difficult
19:16:34 <RyanT5000> any kind of complicated rewiring seems like it'd just get annoying
19:17:07 <Saulzar> RyanT5000, To map it to something like a GUI lib you'd have to write a whole new library on top of it 
19:17:27 <RyanT5000> well i'm pretty much going to have to do that anyway
19:17:35 <jip> i think he wants to make his own fruit-like gui system
19:17:39 <RyanT5000> yeah
19:17:41 <RyanT5000> i'm writing a game
19:17:50 <RyanT5000> i need a 3d graphics engine with heavy-duty windowing capabilities
19:18:50 <RyanT5000> i'm eventually going to have TH stuff where i can say "generate a window for this arbitrary datastructure"
19:19:02 <RyanT5000> or at least that's the goal
19:19:06 <RyanT5000> may not ever happen
19:19:34 <RyanT5000> but the thing that bugs me about yampa
19:19:41 <RyanT5000> is that i need the GUI to essentially be able to rewire itself
19:19:58 <RyanT5000> that absolutely does not look easy in Fruit
19:20:24 <RyanT5000> i think maybe GUI should be a monad...
19:20:31 <Saulzar> Easier just to use say gtk2hs or wxhaskell directly, if you want you still use use monads or Yampa for your model
19:20:43 <RyanT5000> OpenGL
19:21:04 <RyanT5000> to those window managers support opengl rendering?
19:21:22 <Saulzar> gtk2hs has an OpenGL widget, or you can use SDL
19:21:40 <RyanT5000> ah, yeah that's not what i need; this is going to be a fullscreen game
19:21:50 <Saulzar> SDL with OpenGL then maybe?
19:21:51 <RyanT5000> i need a windowing system in opengl
19:22:02 <RyanT5000> right, sdl or glut (*shudder*) with opengl
19:22:08 <Saulzar> Hehe.
19:22:22 <RyanT5000> but what i'm writing now is the windowing system and graphics engine within that
19:22:46 <Saulzar> Yeah, there are not any high level rendering libs for something like haskell just yet :/
19:23:55 <RyanT5000> hm so i guess i really do think that the GUI needs to be written in the IO monad
19:24:07 <RyanT5000> it needs to be able to do "anything"
19:24:17 <dons> not unusual
19:24:27 <jip> i think you should stick with yampa :)
19:24:28 <Saulzar> Some of it at least
19:24:41 <RyanT5000> jip: can you show me a windowing system written in yampa?
19:24:57 <jip> RyanT5000: just fruit. but you also should take a look at fudgets
19:25:09 <Saulzar> Yampa makes too much easy stuff hard when starting out.
19:25:17 <RyanT5000> i looked at both
19:25:27 <RyanT5000> i actually really hate the yampa concept of "delays"
19:25:35 <RyanT5000> it seems like such an enormous hack
19:25:39 <dons> but you ahven't used it yet?
19:25:53 <RyanT5000> true
19:26:02 <araujo> dons, yes, weakly statically typed
19:26:02 <jip> yampa delays are needed in feedback loops, just like in signal processing
19:26:37 <RyanT5000> i understand that
19:26:56 <RyanT5000> but it seems to me that an event-driven program should be logically discretized
19:27:08 <RyanT5000> not real-time
19:27:33 <RyanT5000> it seems backwards to take events and use signal-holds, etc, to map them onto signal processing
19:28:05 <jip> yeah, i like to use events for everything
19:28:14 <dons> the whole point of yampa is that it is continuous, not discrete . i thought.
19:28:23 <RyanT5000> lol exactly, dons :)
19:28:26 <jip> dons: no, i don't think that's the whole point
19:28:27 <RyanT5000> i don't see the advantage
19:28:49 <jip> dons: i've found yampa to be very useful using only it's discrete events
19:28:57 <dons> it means you can code continuous systems.
19:29:08 <RyanT5000> right, but i don't want to code a continuous system :)
19:29:12 <dons> jip. ah ok. i know it is also used for discrete things.
19:29:48 <dons> it would be just a matter of googling 'discrete events yampa' to find some papers, i reckon
19:29:52 <jip> you can simulate continous systems with dense discrete events. this is how yampa actually works internally for continous things
19:30:53 <dons> RyanT5000: i think you just need to write some things to work out the details
19:31:07 <RyanT5000> yeah, that's what i'm going to do
19:31:20 <RyanT5000> refactoring shouldn't really be so hard anyway
19:49:02 <RyanT5000> i have the whole source tree for Graphics.UI.SDL; how can i add it to my standard libraries installtion?
19:49:49 <dons> build it and hopefully there's an 'install' or 'register' target that adds it to the register of haskell libs that ghc knows about
19:50:11 <RyanT5000> ah ok
20:15:18 <RyanT5000> can someone tell me what this means?
20:15:18 <RyanT5000> $ autoconf 
20:15:18 <RyanT5000> Can't locate object method "path" via package "Autom4te::Request" (perhaps you forgot to load "Autom4te::Request"?) at /usr/bin/autom4te line 81.
20:29:23 <Elvoret> hrrm hrrm hello? :)
20:29:57 <sjanssen_> sorry, nobody here
20:30:29 <dons> Elvoret: learning haskell?
20:30:50 <Elvoret> you could say that yeah
20:31:04 <Elvoret> linked my way here through hugs site
20:31:17 <Elvoret> figured this is the place to ask :)
20:31:56 <dons> also, check out haskell.org
20:32:00 <dons> lots of good stuff there
20:32:06 <Elvoret> its from there i got here
20:32:13 <dons> ah ok.
20:32:24 <dons> ask your questions. we love to answer them :)
20:32:31 <Elvoret> aight ty :)
20:32:46 <Elvoret> its like this: im very not good at this
20:32:48 <Elvoret> but
20:33:10 <Elvoret> i downloaded hugs from haskell.org/hugs
20:33:17 <Elvoret> all went well
20:33:31 <Elvoret> and from nowhere it stops working
20:33:40 <Elvoret> when i start hugs i get this msg
20:33:53 <Elvoret> sec
20:34:03 <Elvoret> ERROR ".\Prelude.hs" - Module "Hugs.Prelude" already loaded 
20:34:09 <Elvoret> that just popped up
20:34:22 <Elvoret> and when i try to load anything into hugs it says:
20:34:23 <dons> mm quit and start it again?
20:34:31 <Elvoret> done that, several times
20:34:40 <Elvoret> reinstalled several times
20:34:55 <dons> its a bit mysterious.  you could install ghci.
20:34:56 <dons> ?where ghc
20:34:57 <lambdabot> http://haskell.org/ghc
20:35:12 <Elvoret> "repeated definition of class "Eg"" in line 139
20:35:23 <Elvoret> this means kinda nothing to me :/ no clue what to do
20:35:27 <dons> sounds like your src files are munged somehow
20:35:57 <dons> and reinstalling isn't cleanign out the old files, perhaps
20:36:02 <Elvoret> seems so
20:36:13 <dons> make sure to remove all traces of the old hugs. and install from scratch
20:36:31 <dons> then check that hugs on its own works. then see if its your code that's broken
20:36:43 <Elvoret> yeah im told to do that by a m8 of mine, but i cant seem to find all the things that need to be removed
20:36:52 <dons> you on windows, or linux?
20:37:00 <Elvoret> windows
20:37:18 <dons> yeah. harder. that's about all I can suggest. 
20:37:29 <dons> other than installing ghc, and using that instead
20:38:06 <Elvoret> ghc is another interpreter?
20:38:20 <Elvoret> or how you call it :)
20:38:37 <dons> compiler and interpreter
20:38:41 <dons> ?where ghc
20:38:42 <lambdabot> http://haskell.org/ghc
20:39:41 <Elvoret> ok, ill check that out then. thank you for your time :)
20:43:31 * araujo reading about the Gospel of Judas
20:44:58 <RyanT5000> anyone here know how to use hsc2hs?
20:46:45 <dons> you write a .hsc file, and run hsc2hs over it, giving you a .hs file
20:46:53 <dons> check the hsc2hs man page
20:47:17 <RyanT5000> yeah, but every time i run it says This application has requested the Runtime to terminate it in an unusual way.
20:47:17 <RyanT5000> Please contact the application's support team for more information.
20:47:19 <dons> ?gsite haskell.org Writing Haskell interfaces to C code: hsc2hs
20:47:23 <lambdabot> http://www.haskell.org/ghc/docs/6.4/html/users_guide/hsc2hs.html
20:47:32 <dons> the applications support team?
20:47:35 <RyanT5000> and it outputs a c file
20:47:44 <RyanT5000> and i can compile and run the c file just fine
20:47:44 <dons> as well as a .hs file, yep
20:47:53 <RyanT5000> no, it doesn't output the .hs file
20:47:55 <RyanT5000> that's the problem
20:48:00 <RyanT5000> it terminates after making the c file
20:48:10 <RyanT5000> i've used it successfully before
20:48:49 <dons> The C program is compiled using the Haskell compiler    
20:48:52 <dons> you doing that?
20:49:12 <RyanT5000> ah no
20:49:21 <RyanT5000> i'm using gcc
20:49:41 <dons> when you compile the c file with ghc, it links in the HsFFi headers. producing a binary, that when run, spits out a .hs file
20:50:00 <RyanT5000> right
20:50:01 <dons> man pages are useful
20:50:19 <RyanT5000> no that's not the issue; i think the problem is that my -c switch for ghc isn't working right
20:50:25 <RyanT5000> i just told hsc2hs to use gcc instead and now it works
20:50:28 <dons> -c ?
20:50:35 <dons> you want to compile to a .o file?
20:50:58 <dons> or do you mean the -c switch to _hsc2hs_
20:51:10 <RyanT5000> i used the -c to hsc2hs to fix it
20:51:14 <dons> yep. fine.
20:51:17 <RyanT5000> it was using ghc -c to invoke gcc
20:51:25 <RyanT5000> both switches in question are -c :)
20:51:34 <RyanT5000> (the latter thing is what wasn't working)
20:51:40 <dons> no no. -c to ghc asks ghc to create a .o file and stop
20:51:45 <dons> like -c to gcc
20:51:50 <RyanT5000> oh
20:51:55 <dons> to use gcc explciitly with ghc, you say -pgmc gcc
20:52:02 <RyanT5000> ah
20:52:13 <RyanT5000> ok well it works anyway, so i'm not going to worry about it :P
20:52:18 <RyanT5000> i'm just trying to build lemmih's code
20:52:34 <dons> ?gsite haskell.org 4.17.Flag reference
20:52:38 <lambdabot> http://www.haskell.org/ghc/docs/6.4/html/users_guide/flag-reference.html
20:52:40 <dons> good lambdabot
20:52:52 <dons> gsite works really nicely for finding text on haskell.org, i'm findign
20:53:05 <RyanT5000> what is gsite?
20:53:10 <dons> ?help gsite
20:53:11 <lambdabot> gsite <site> <expr>. Search <site> for <expr> using google
20:53:14 <dons> its some google wrapper
20:53:18 <RyanT5000> huh
20:53:19 <dons> for searching in a particular domain
20:53:30 <RyanT5000> you can just put site:blah.com as a google search term
20:53:48 <RyanT5000> @google site:haskell.org 4.17. Flag reference
20:53:51 <lambdabot> http://www.haskell.org/ghc/docs/6.4/html/users_guide/flag-reference.html
20:53:52 <dons> sure. but i think this must be optimised in some way
20:54:03 <dons> unless   they're into redundant apis
20:54:37 <RyanT5000> doubtful, although do you know that gsite does anything more complicated than use the site: keyword?
20:54:50 <dons> oh, actually, gsite is just a wrapper to i'm feeling lucky, and site=foo.org
20:54:59 <RyanT5000> ah ok
20:55:04 <dons> http://www.google.ca/search?hl=en&q=site%3A", "&btnI=I%27m+Feeling+Lucky
20:55:10 <dons> i should read the lambdabot plugin code more often
20:55:50 <dons> ?uptime
20:55:51 <lambdabot> uptime: 14 hours, 25 minutes and 14 seconds
20:56:38 <RyanT5000> i wonder why "I'm feeling lucky" is actually passed as a string
20:56:58 <RyanT5000> are there secret ones, like "Increase my pagerank"?
20:57:44 <dons> "Send me money"
20:58:01 <RyanT5000> same thing :P
20:58:02 <MarcWeber> Will there be a difference in the final program using x `elem` [a,b] or   (x==a) `or`  (x==b) considering speed?
20:58:31 <dons> depends on the defn of elem
20:58:38 <dons> and what the -O does to the code
20:58:47 <dons>  the only way to know is to look at the Core code, with -ddump-simpl
20:58:55 <MarcWeber> dons: default list implementation
20:59:17 <dons> they're indentical then: elem x                  =  any (== x)
20:59:33 <dons> in fact, in ghc:
20:59:34 <dons> elem _ []   = False
20:59:35 <dons> elem x (y:ys)   = x==y || elem x ys
20:59:58 <dons> which is the folded form of (x==a) 
21:00:01 <dons>                    `or`  (x==b)  
21:00:04 <dons> rigth?
21:00:45 <RyanT5000> ?where hssdl
21:00:45 <lambdabot> I know nothing about hssdl.
21:04:06 <MarcWeber> dons: Sorry. I mixed || and or up.. Of cause I want to compare Bool->Bool->bool (||) with elem. (thus x==a || x==b)   compared with (x `elem [a,b]).
21:04:49 <RyanT5000> is this in like the tightest loop ever?
21:04:55 <RyanT5000> or are you just curious?
21:07:30 <dons> its going to be the same code, I reckon. once inlining gets to work
21:09:46 <RyanT5000> ok so i have the module tree with all the hsc's successfully converted to .hs
21:09:55 <RyanT5000> how do i get that into package form?
21:10:02 <RyanT5000> the Setup.lhs seems broken
21:10:35 <lisppaste2> RyanT5000 pasted "Setup.lhs output" at http://paste.lisp.org/display/18933
22:07:36 <falconair> a month or two ago i saw a haskell lecture (on video) in which the professor talked about partial orders, I have never seen partial orders in any haskell/programming language theory text book, are partial orders needed to understand haskell implementations?
22:08:01 <sethk> falconair, not really, no
22:08:06 <dons> not that I know of.
22:08:13 <sethk> falconair, the concept of fixed points does come up, and that's related
22:08:34 <falconair> i have been studying lambda calculus, it has been worth the time learning it, i just wondered where partial orders fit in
22:08:50 <dons> to understand the implementation, hmm, it helps to know lambda calculus. and read some papers here 
22:08:54 <dons> http://haskell.org/haskellwiki/Research_papers
22:08:55 <sethk> falconair, at a rather theoretical level
22:09:21 <sethk> falconair, but you don't need it just to use the language.  I'd like to know more because I think it helps you see what the compiler is doing in various situations.
22:09:26 <falconair> right, i'm sure i don't need to know this stuff as a programmer, but since i started learning functional programming, i figured may as well go the whole hog
22:09:35 <sethk> falconair, I know more about how some other languages work and I scratch my head a bit less with them.
22:09:57 <dons> reading the STG machine paper goes a long way to udnerstanding things.
22:10:11 <sethk> dons, any way I can show a Control.Concurrent.MVar?  (show x) doesn't help because the type is Chan Whatever, not Chan
22:10:17 <falconair> dons: STG machine paper?
22:10:26 <sethk> dons, I want to see if the same Chan is found in two different situations
22:10:33 <sethk> dons, spineless tagless g machine
22:10:36 <sethk> sorry
22:10:42 <sethk> falconair, spineless tagless g machine
22:10:53 <sethk> falconair, there's a link to it on haskell.org/ghc, I think
22:11:06 <dons> and understanding graph reduction, as they describe in the 'implementing functional languages' book and tut here: http://haskell.org/haskellwiki/Books_and_tutorials
22:11:10 <falconair> i see several instances on google
22:11:12 <sethk> falconair, somewhere on haskell.org, plus I think dons gave you a url that has a bunch of papers including that one.
22:11:26 <dons> the STG paper is at the top of: http://haskell.org/haskellwiki/Research_papers/Runtime_systems
22:12:32 <dons> hmm. showing a chan or mvar eh?
22:13:06 <sethk> dons, yes.  actually I just fixed my problem, but I'd still like to know for future reference.
22:13:38 <sethk> dons, the program I wrote yesterday and today is replacing a program written in C that took six weeks to develop
22:13:45 <sethk> dons, of course, it was developed by a bozo, but still  :)
22:14:11 <flux__> and reimplementing is often faster anyway ;)
22:14:30 <flux__> (although by factor of 42 is quite impressive)
22:14:32 <sethk> flux__, not in this case.  It would have taken me 12 weeks to figure out what the hell this old code was doing.  :)
22:15:56 <sethk> is there an api where I can get a handle to a forked process?  What I need to do is know if the process dies abnormally, and to kill it if necessary
22:16:19 <sethk> If it dies, I know whether it was normal or abnormal because the two pieces are talking to each other via a socket
22:16:30 <sethk> so I just need to know if it dies, not why
22:16:43 <sethk> and, as I said, I need to kill it.  There are multiple processes with the same name.
22:16:47 <dons> yeah, hang on. System.Process is one
22:16:59 <sethk> dons, there's a posix process also, I think?
22:17:57 <sethk> dons, System.Process looks good ...
22:18:01 <falconair> so this STG machine paper seems to explain how to implement a language like haskell
22:18:14 <dons> there's that too. and http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Process.hs
22:18:16 <sethk> falconair, more than that, it explains how ghc is implemented
22:18:41 <dons> falconair: the tutorial 'implementing a functional programmnign language' describes the basics
22:18:45 <sethk> dons, that's one of yours' using System.Process ?
22:18:57 <dons> yep. a wrapper
22:19:05 <falconair> i saw a couple of public domain books by SPJ, this paper seems to be more 'to the point'
22:19:20 <sethk> didn't know I had a popen available.  :)
22:19:23 <falconair> sethk: ghc eh, sounds great!
22:19:41 <dons> its in hslibs, and is deprecated for the various portable ones in System.Process
22:19:42 <sethk> falconair, a fine working example.  an amazing piece of work, actually.
22:20:11 <dons> its one of the most sophisticated compilers ever built, surely.
22:20:59 <falconair> dons: why is more sophisticated than other compilers, is it due to the laziness of the language?
22:20:59 <sethk> dons, piece of cake.  runProcess returns a handle I can use for both kill and monitor.
22:21:36 <dons> falconair: more optimisations, very sophisticated type system, concurrent runtime system that functions as a basic os kernel
22:21:45 <sethk> dons, why did you use open in your wrapper?  as opposed to System.Process?
22:22:14 <dons> open? didn't I use  runInteractiveProcess file args Nothing Nothing
22:22:46 <sethk> wait, you _implemented_ popen  :)
22:23:54 <dons> oh, you can also use this popen, much lower level: http://www.cse.unsw.edu.au/~dons/code/hmp3/Utils.hs
22:24:09 <dons> that one's popen :: FilePath -> [String] -> IO (Fd, Fd, Fd, ProcessID)
22:24:29 <falconair> let me make sure, we are talking about "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine Version 2.5" by SPJ .... right?  (the direct link on haskell.org doesn't work for me due to some safari popup blocker problem)
22:24:30 <sethk> dons, I'm better off at the higher level if it has what I need, wouldn't you think?
22:25:04 <dons> depends on your requirements. usually the higher one is all you need. i had to use the lower one once, since i needed to pass a fd to a C function
22:25:19 <dons> so my popen had to deal in descriptors and pipes
22:25:41 <dons> but i've only needed that once. mostly I use the former one, the wrapper over System.Process
22:25:46 <dons> lambdabot uses it, for example
22:25:47 <sethk> dons, I've bookmarked it, in case I need it, but I'll try using your higher level methods first.
22:26:46 <dons> it requries -threaded, since it uses forkIO to ensure all the input is read. and so that wait4 doesn't block
22:26:57 <dons> but that's ok. -threaded will be the default soon
22:27:13 <sethk> dons, I have it in all my makefiles already anyway, so no problem with -threaded
22:27:32 <sethk> dons, although I did notice that, in linux, time slices among the various threads are much more evenly distributed without -threaded
22:28:10 <dons> thats interesting. i guess it depends on where things block
22:28:43 <dons> note that some of the comments in that file may actually be no longer true
22:28:47 <dons> sorry abotu that.
22:28:52 <sethk> dons, linux thread handling is not one of its better features.
22:28:53 <dons> i usually try to keep things accurate
22:29:02 <sethk> dons, comments in which file?  Your popen implementation?
22:29:26 <dons> yeah, in the lambdabot one. i.e. "Ignoring exit status for now." is certainly incorrect
22:29:48 <dons> the sigpipe comment i'm unsure about. and the large amounts of output issue hasn't been seen in lambdabot in a couple of years.
22:29:55 <sethk> we've got getProcessExitCode which says it returns Nothing if the process is still running and an exit code otherwise.  That implies that you can retrieve the error code at any future time?
22:30:13 <dons> probably they were artifacts of the early implementations of System.Process.
22:30:22 <dons> not sure.
22:30:34 <sethk> ok, then, I won't assume it.
22:30:42 <dons> check the docs.
22:31:10 <dons> ah, that is the docs.
22:31:25 <sethk> getProcessExitCode returns IO (Maybe ExitCode) which let's you figure out whether the termination was normal or abnormal.  but waitForProcess returns IO ExitCode (no Maybe)
22:32:25 <dons> since it blocks till it exist, and throws an exception if it has already exited, iirc
22:32:33 <dons> /exist/exits/
22:32:50 <dons> (waitForProcess, that is)
22:33:27 <sethk> dons, makes sense
23:01:51 <sethk> dons, looks like I may not be able to use System.Process, because it grabs stdin, stdout, and stderr.
23:02:11 <sethk> dons, wait
23:02:17 <sethk> dons, they are Maybe Handle
23:02:30 <sethk> dons, does that imply that if I don't supply them, stdin, out, and err are "normal"?
23:03:07 <dons> you can optionally specify the handles
23:03:33 <dons> see the raw runProcess command
23:03:34 <sethk> right, but it doesn't say what the behavior is if I don't specify them
23:03:58 <dons> let me check ..
23:04:25 <dons> otherwise it uses stdin, stdout ,stderr
23:04:38 <dons> fromMaybe stdin  mb_stdin
23:04:40 <sethk> as if you had run it with, way, the system() call?
23:04:48 <sethk> s/way/say/
23:05:12 <dons> i think so.
23:05:21 <sethk> k.  I'll try it and see.
23:05:50 <dons> its using dups and execvps undeneath
23:06:18 <sethk> it might inherit stdin and out and err from the parent
23:07:53 <sethk> I don't use stdin.  I can open a file (or two files) and send stdout and stderr to the file(s)
23:08:25 <shapr> Good morning #haskell!
23:08:38 <sieni> ning
23:08:40 <dons> morning shapr. 
23:08:57 * dons notes 100,002 hits on haskell.org since it became a wiki
23:09:05 <sieni> as a rerun from our day-before-yesterday meeting:
23:09:18 <sieni> http://www.hurmio.org/~ville/hs-hki
23:09:37 <dons> ooh. new code! what's this do then?
23:09:51 <dons> oh, hs-hki isn't a new project :)
23:09:58 <sieni> no
23:10:03 <sieni> :-)
23:10:05 <wolverian> hehe :)
23:10:22 <sieni> hki is the common postal acronym for helsinki
23:10:47 <dons> yah, i thought it might be some secret underground .fi haskell code
23:35:08 <astrolabe> Nah, they'd never post the name of the secret underground .fi haskell code here.
23:47:39 <lisppaste2> int-e pasted "positive Integer to String conversion" at http://paste.lisp.org/display/18938
23:49:02 <int-e> There. I wanted to submit it for the standard libraries ages ago but never did :/ It's quite fast, even a bit faster than gmp's own code for this, when I last tested it.
23:51:07 * int-e notes he pasted to the wrong channel - sorry.
23:53:27 <musasabi> int-e: I think there was interest for replacing GMP.
23:53:55 * Pseudonym yawns
23:54:08 <dons> wasn't eivukko workign on it/?
23:55:25 <int-e> musasabi: the current Num.hs implementation uses an awfully slow algorithm for converting integers to strings ...
23:55:55 <int-e> Anyway, last I thought about it I noticed that Numeric.hs also contains similar code and I wanted to replace that as well. And never did.
23:56:13 <int-e> replacing gmp is independent of that though.
23:56:19 <musasabi> submit a patch?
23:59:01 <neologism> what it means "awfully slow" ?
