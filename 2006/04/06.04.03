00:03:09 * Lemmih wonders how useful his 'breakpoint' function is without the ability to inspect polymorphic variables.
00:17:27 <sjanssen> heh.  Lennart Augustsson in 1993: "PS. I'd like to start the "Ban n+k patterns"-movement, any followers?"
00:20:50 <Korollary> I wonder how some of the stuff I say will be perceived in 13 years.
00:21:18 <Korollary> "Hey, this is a quote from 2006 by that institutionalized guy!"
00:22:56 <neologism> mux: you interested in haskell, nice! :)
00:27:31 <dons> huh. in 2 years there went from being no haskell impl. for linux (1993) to ghc 0.25 being only released for linux   :)
00:30:57 <gvdm> sjanssen: why are n+k patterns bad?
00:31:20 <gvdm> arent they soetimes easier to understand and write?
00:31:44 <neologism> I think they are sometimes necessary to be able to do tail-recursion
00:40:42 <Lemmih> Really?
00:41:33 <dons> no. they're just really weird.
00:41:50 <xerox> Howdy!
00:42:10 <dons> maybe neologism means, they're often used for recursive induction-style defns (commonly used by beginners, or in teaching)
00:42:18 <dons> which use tail calls
00:43:02 <neologism> dons: that might be it :)
01:29:00 <dons> ?quit new code
01:34:02 <Lemmih> ?whatsnew
01:34:04 <lambdabot> Unknown command, try @list
01:38:36 <Saulzar> That quote from Smokey (About C++) in the HWN sounds very familiar.
02:02:42 * ibid just added wadler to planet
02:02:55 <ibid> (will become visible in an hour)
02:05:26 <xerox> Which planet?
02:07:59 <ibid> planet haskell
02:08:03 <ibid> which else? :)
02:08:35 <xerox> Foo, I didn't know there was one!
02:08:49 <Muad_Dib> Bar, why not?
02:09:00 <xerox> Who weblogs?
02:09:09 <xerox> Besides Shae :-)
02:11:22 <ibid> http://planet.haskell.org/
02:12:00 <ibid> at the moment, it's mainly planet cosmicray, but that ought to change :)
02:12:18 <ibid> (he had trouble with his feed when he was switching blog software)
02:17:06 <ibid> i'm still looking for new feeds to add
02:17:28 <ibid> if you know someone who fits the policy (see my mails on -cafe), tell them to mail me with the feed URI
02:38:46 <araujo> morning
02:44:58 <hoan> folks, how can you write \x -> x*x in points-free style?
02:45:32 <Saulzar> (*)
02:45:46 <Saulzar> Oh
02:45:53 <Lemmih> @pl \x -> x * x
02:45:55 <lambdabot> join (*)
02:46:07 <Lemmih> hoan: join (*) (:
02:46:13 <hoan> hey, lambdabots working
02:46:27 <hoan> i tried it before :)
02:46:48 <hoan> cool
02:47:10 <hoan> hmm...
02:47:43 <hoan> @pl \x -> sum x / length x
02:47:45 <lambdabot> liftM2 (/) sum length
02:48:12 <hoan> liftM2 eh...
02:48:39 <hoan> @pl \x -> if null x then 0 else sum x / length x
02:48:40 <lambdabot> ap (flip if' 0 . null) (liftM2 (/) sum length)
02:48:40 <Saulzar> It's using the monad instance for a function (a -> b)
02:49:00 <hoan> okay mate
02:49:10 <hoan> points-free rules!
02:49:37 <hoan> i just never knew how to transform a function that uses a variable twice
02:50:35 <hoan> ok thanks Saulzar
02:50:39 <hoan> byeeeeeee
02:54:28 * shapr boings
02:57:11 <araujo> hola shapr 
03:04:20 <bolrod> dblhelix: I got wxhaskell to work on both linux ans osx
03:04:33 <dblhelix> bolrod: well done
03:04:59 <dblhelix> bolrod: do apps look nice on linux?
03:05:34 <bolrod> well.. when you start the bouncingballs app, the window is slightly too big
03:05:48 <bolrod> then you can resize it so only the panel fits in the window.. and after that, you can't resize it anymore
03:06:08 <bolrod> but the rest just seems to work fine
03:06:44 <dblhelix> bolrod: good to hear (read)
03:07:08 <bolrod> when someone else has problems with installing,  they need to compile wxWidgets with :
03:07:18 <bolrod> ./configure --disable-unicode --disable-shared   (possibly  --with-opengl)
03:07:29 <chrisbrown> what is wxhaskell?
03:07:46 <dblhelix> bolrod: would be nice if this could be mentioned on the wxHaskell website
03:08:00 <bolrod> but searching on google for 'wxhaskell ubuntu'  also gives that
03:08:23 <bolrod> ahyeah..  the macosx-app also has a bug
03:08:37 <bolrod> well...   in the .app it creates, it makes the directory PgkInfo
03:08:40 <bolrod> instead of PkgInfo
03:08:41 <bolrod> ;)
03:09:31 <bolrod> same for you?
03:09:41 <Lemmih> chrisbrown: A binding to wxWidgets.
03:09:48 <chrisbrown> ah, cool!
03:10:23 <bolrod> oh. PgkInfo isn't a dir, but a file
03:13:29 <dblhelix> bolrod: could be... the .app file is runnable though... at least for me
03:13:44 <bolrod> for me too
03:17:59 <goltrpoat> what's a good intermediate-level haskell textbook?  im looking at "the haskell school of expression" and "algorithms:  a fp approach".  is there anything like the latter title, but perhaps more advanced on the algorithms side?
03:18:34 <goltrpoat> also..  anything geared towards a) numerical analysis and computer algebra in haskell, or b) compiler design, would be awesome
03:20:15 <goltrpoat> oh, i also remember looking at a sample chapter from "fun of programming", that one seems very cool
03:25:37 <xerox> > 57*86
03:25:39 <lambdabot> 4902
03:25:42 <xerox> > let peasant x y = sum [n | (n,b) <- takeWhile ((>0) . snd) $ iterate ((*2) *** (`div`2)) (x,y), not (even b)] in peasant 57 86
03:25:43 <dons> ?vixen doesn't like xcess floods
03:25:44 <lambdabot> 4902
03:25:45 <lambdabot> do you have toys?
03:26:33 <chrisbrown> @where Strafunski
03:26:35 <lambdabot> I know nothing about strafunski.
03:28:06 <dons> check haskell.org, under the libraries_and tools page
03:28:12 <chrisbrown> cheers
03:28:15 <dons> in data structures.
03:28:50 <goltrpoat> oh doh.  i didn't realize the list was longer than the "textbooks" section
03:28:56 <goltrpoat> thanks
03:30:14 <dons> ?
03:31:30 <goltrpoat> i was looking at the list, but it looked as if just the "textbooks" section referred to books, and the rest were articles
03:32:09 <goltrpoat> "purely functional data structures" looks great
03:32:18 <goltrpoat> or.. the table of contents does anyway
03:34:43 <chrisbrown> hmmm Strafunski page doesn't work
03:53:11 * shapr ribbits
03:53:45 <shapr> goltrpoat: DoCon does computer algebra
03:53:58 <shapr> goltrpoat: What about Haskel Road to Logic, Maths, and ... ?
03:54:02 <shapr> I haven't read it yet, though...
03:56:27 <goltrpoat> DoCon?
03:56:35 <dons> Cale, a mail fromm Koen Claessen, 97, regarding Functor and Monad, that you'd like: http://www.mail-archive.com/haskell%40haskell.org/msg01569.html
03:56:57 <dons> goltrpoat, a CAS . must be nearly a decade old now too
03:57:22 <goltrpoat> ah found it
03:58:08 <goltrpoat> shapr:  haven't been able to find a table of contents for "haskell road to logic"
03:58:28 <goltrpoat> oh, there we go.
04:00:04 <goltrpoat> cool.. i think i'm set.  thanks dons/shapr
04:00:53 <dons> ?wiki Libraries_and_tools
04:00:54 <musasabi> goltrpoat: Purely functional data structures was a very nice read. (although it is in SML the techniques work in Haskell as well)
04:00:56 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools
04:02:30 <goltrpoat> dons:  oh i thought you were referring to data structures under http://www.haskell.org/haskellwiki/Books_and_tutorials
04:02:54 <dons> nope. under the above link
04:04:26 <dons> speaking of okasaki, here's the initial announcement of his Edison data structures lib: http://www.mail-archive.com/haskell%40haskell.org/msg01653.html
04:04:29 <dons> way back in 97
04:04:57 <musasabi> dons: did the USE_C fps patch get to you? Not sure whether that is something that should be committed or not.
04:05:36 * dons finds it instructive to read haskell@ back in the 90s
04:25:12 <bolrod> dblhelix: the new assignment doesn't really work well on the mac ;/
04:25:34 <dblhelix> bolrod: it's made on my mac... 
04:26:00 <dblhelix> bolrod: however there's a bit of a strange thing going on with the menu bar
04:26:09 <bolrod> yes
04:26:11 <bolrod> that
04:26:14 <bolrod> I dont have one
04:26:29 <dblhelix> bolrod: you should first select another app and then reselect the wxCal app; then the menu bar appears
04:26:37 <dblhelix> bolrod: don't ask me why
04:26:51 <bolrod> hehe.. lets see
04:28:01 <bolrod> I have to have wxHaskell installed to run the program?
04:28:15 <bolrod> I just removed some wxHaskell directory to reinstall wxHaskell (for that menu bar)
04:28:39 <dblhelix> bolrod: not sure... I guess you only have to have wxWidgets installed
04:29:10 <bolrod> I have the xcode tools installed
04:30:10 <bolrod> well.. there seems to be the menu bar.. 
04:43:41 <dons> yep. got it. working out how to commit it -- or just remove the cbits 
05:01:03 <dons> hehe. J.Peterson asks in May 98 for help maintaining haskell.org ...
05:01:18 <dons> many years till we had MediWikii.
05:06:22 <dons> oh, we wonn the icfp contest in 1998? didn't know that
05:07:13 * kosmikus expects a relatively large and interesting section on haskell.org for the next HCAR ...
05:07:48 <dons> yeah. it's taken off. i think the move to a wiki is a real success so far
05:08:19 <dons> it's all about lowering the barrier for external committers, as audreyt says for pugs
05:08:28 <kosmikus> I think it is. Although the design of the title page is still lacking imho. Someone should just go ahead and improve it ...
05:08:51 <chrisbrown> has anyone used the latest version of Strafunski? The one that uses GHC types?
05:08:55 <dons> yes. i have some secret plans. we'll see..
05:09:09 <dons> chrisbrown, maybe ask on haskell-cafe@haskell.org ?
05:09:19 <chrisbrown> dons: cheers
05:09:28 <kosmikus> dons: you have my support. whatever your plans are, they're almost certainly an improvement.
05:10:24 <dons> we have a lot of content now, but it's not all very easy to get too
05:10:32 <dons> so some thinking is still needed
05:11:39 <genneth> i can't seem to get ghc to actually import any packages...
05:12:01 <genneth> right now it's not happy with import Data.Set; works fine in ghci
05:13:06 <genneth> can anyone tell me what obviousness i'm missing?
05:13:49 <dons> hmm. ghc and ghci are the same thing. are you missing an 'import Data.Set' ?
05:14:24 <genneth> not at all
05:14:34 <genneth> ghc tells me that it can't find Data.Set
05:14:44 <genneth> ghci churns along very happily
05:15:10 <dons> that's very strange
05:15:11 <dons> are you doing anything unusual?
05:15:14 <genneth> nope
05:15:29 <genneth> what should the command to ghc be?
05:15:37 <dcoutts__> genneth, perhaps you should paste your code and show how you're compiling it
05:15:41 <genneth> i'm currently using: ghc -v -prof -auto-all -O --make enigma.hs -o enigma
05:17:18 <Lemmih> You need the profiling version of the standard libraries.
05:17:53 <genneth> ah...
05:18:04 <Lemmih> (ghc6-prof if you have a Debian-like system)
05:19:06 <kosmikus> dons: I mainly dislike the top of the page. The logos and the initial sentence don't really match the design (gray box) of the rest of the page, and it's too much stuff until the real content starts.
05:19:10 <punya> hi, i'm using haskell-mode with emacs, and i was wondering if i needed to do anything to make haskell-doc-mode work with ghci (since the .el file says it's conditional on haskell-hugs-mode).
05:19:40 <genneth> Lemmih: thanks!
05:22:33 <dons> kosmikus, yes. I agree .that's my complaint too
05:40:53 <shapr> punya: I think haskell-doc-mode looks up type signatures in a static table. It probably only works with haskell-mode buffers. How are you trying to combine it with ghci?
05:51:44 <shapr> punya: What do you want to do with haskell-doc-mode?
05:59:24 <punya> shapr: I got the impression that haskell-mode could remember the types of global and local variables referenced in the current buffer, and tell me about them in the status bar. Right now, it only ever gives me useful types for names from the libraries that ship with haskell.
06:00:46 <punya> shapr: I apologize for the uninvited private message. I did not want to flood other people's windows with a large source quote.
06:11:48 <ProfTeggy> punya, do you have haskell-decl-scan turned on?
06:12:24 <ProfTeggy> M-x turn-on-haskell-decl-scan
06:19:37 <punya> ProfTeggy: thanks
06:41:27 <twb> Hello.
06:41:37 <twb> I've forgotten how to invoke GHC.
06:41:39 <xerox> Oi.
06:41:51 <xerox> Phone 800-run-ghci
06:42:07 <twb> http://twb.ath.cx/~twb/darcs/tinywm/tinywm-haskell.hs
06:42:26 <twb> ghc -package Xlib -o tinywm-haskell tinywm-haskell.hs <-- doesn't work
06:42:41 <xerox> --make
06:42:49 <twb> Oops, I just remembered that.
06:43:19 <twb> Yay!
06:43:25 <xerox> Great.
06:43:42 <twb> If only all life's problems were so simple to solve.
06:43:54 <xerox> Life would be boring?
06:45:52 <neologism> uh.. did you know that unix has algebra defined on it?
06:45:55 <neologism> thats scary
06:46:05 <twb> Chicken's xlib ffi seems to suck quite a bit.
06:46:13 <twb> Maybe it's just because xlib itself sucks so much.
06:51:25 <twb> Hmm, what the ghci prefix for thingy commands?
06:51:34 <twb> Not "@type foo", but...
06:51:39 <norpan> :
06:51:40 <xerox> :
06:51:43 <xerox> )
06:51:57 <twb> Thanks.
06:52:14 <twb> Yes, it's all coming back to me now.
06:52:23 * twb confidently walks over edge of cliff.
06:52:34 * xerox can feel the disturbance in the Force, He is comin'
06:53:30 <twb> So how do I say "do { openDisplay ""; assert (NULL != dpy) }" ?
06:53:40 <xerox> guard?
06:53:41 <twb> So how do I say "do { dpy <- openDisplay ""; assert (NULL != dpy) }" ?
06:53:57 <twb> OK.
06:54:01 <xerox> ?type guard
06:54:02 <lambdabot> Not in scope: `guard'
06:54:08 <xerox> ?type Control.Monad.guard
06:54:09 <lambdabot> forall (m :: * -> *).
06:54:09 <lambdabot>         (Control.Monad.MonadPlus m) =>
06:54:09 <lambdabot>         Bool -> m ()
06:54:10 <twb> But what's the null pointer?
06:54:19 <Saulzar> What type is dpy?
06:54:23 <xerox> Does the documentation say anything?
06:54:28 <twb> Saulzar: newtype Display = Display (GHC.Ptr.Ptr Display)
06:54:47 <xerox> do (Display ptr) <- openDisplay
06:54:57 <xerox>    guard (ptr /= foo)
06:54:58 <twb> Hmm.
06:55:08 <twb> do dpy@(Display _) <- openDisplay "" ?
06:55:10 <xerox> Where foo is the nullptr however is defined?
06:55:25 <xerox> \docs
06:55:42 <xerox> ?docs
06:55:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
06:56:17 <Saulzar> What do you want to use xlib for?
06:56:27 <twb> Saulzar: I'm translating tinywm.c
06:56:34 <twb> BECAUSE I CAN.
06:56:40 <Saulzar> Ah :)
06:56:49 <xerox> pointer to an X11 Display structure
06:56:51 <xerox> Hmm.
06:56:53 <twb> I've already done CL and Chicken Scheme.
07:01:25 <twb> Why does the *linking* step take so long?
07:02:22 <twb> Ah, looks like I don't need to guard against NULL, the lib does it automagically.
07:07:30 <Saulzar> Usually most libraries will either use the monad fail (for arbitrary monad) or give you a Maybe type if the value can be "null"
07:07:47 <twb> Saulzar: I don't care, since I don't have to write the guard.
07:13:22 <twb> OK, what's wrong with this: http://twb.ath.cx/~twb/darcs/tinywm/tinywm-haskell.hs
07:15:36 <Igloo> You can't use where like that
07:15:40 <twb> :-(
07:15:55 <earthy> do dpy <- openDisplay ""
07:15:56 <Igloo> Either use a let before the line where you use root or put the where at the bottom
07:16:08 <earthy>    key <- ...
07:16:19 <earthy>    let root = defaultRootWindow dpy
07:16:22 <twb> I can put the where at the bottom even though it references dpy ?
07:16:32 <Igloo> Oh, no, you can't, sorry
07:16:45 <earthy>    grabKey dpy key mod1Mask root True grabModeAsync grabModeAsync
07:22:50 <Mortis_kruuul> Hi! http://www.muzyka.oz.pl :)
07:30:31 <twb> OK, next question.
07:30:44 <twb> grabButton's last argument is of type Cursor.
07:30:59 <twb> But the code I'm copying uses `None'.
07:31:12 <twb> And the manpage for XGrabButton say 'cursor    Specifies the cursor that is to be displayed or None.'
07:31:47 <Saulzar> Maybe there's a constructor for Cursor called None?
07:31:59 <twb> Wouldn't that just be (None) ?
07:32:01 <Saulzar> (Or it could take a Maybe Cursor?)
07:32:22 <twb> No, :t grabButton reports the formal is of type `Cursor'.
07:32:26 <Saulzar> Ah, ok.
07:32:32 <Saulzar> :info Cursor :)
07:32:51 <twb> Lemme see what it is in Chicken...
07:33:07 <twb> (define NONE 0)
07:33:23 <twb> I think that means None = NULL.
07:33:25 <Saulzar> What does :info give you about Cursor?
07:33:36 <twb> type Cursor = XID 	-- Imported from Graphics.X11.Types
07:33:52 <Saulzar> and :info XID ?
07:33:59 <twb> http://www.haskell.org/ghc/docs/6.4.1/html/libraries/X11/Graphics-X11-Types.html#t%3AXID
07:34:23 <twb> Actually, on this system GHC.Word.Word64
07:34:58 <Saulzar> Hmm
07:35:09 <Saulzar> Are there some constants for Cursor somewhere perhaps?
07:35:57 <twb> Where would I find them?
07:36:17 <twb> Can I list all words of type `Cursor' ?
07:36:29 <twb> s/word/bound identifier/
07:36:51 <Saulzar> @query lambdabot
07:36:52 <lambdabot> Unknown command, try @list
07:36:53 <Saulzar> Whoops
07:37:13 <Saulzar> Hmm
07:41:51 <Noobluck> hello
07:41:56 <Noobluck> can you help me?
07:42:04 <Noobluck> this function
07:42:11 <Noobluck> data Tree a = Leaf a | Branch (Tree a) (Tree a)
07:42:19 <Noobluck> simetrico :: Tree a -> Tree a
07:42:19 <Noobluck> simetrico (Leaf a) = (Leaf a)
07:42:19 <Noobluck> simetrico (Branch a b) = (Branch (simetrico b) (simetrico a))
07:42:24 <Noobluck>  
07:42:24 <Noobluck>  
07:42:30 <Noobluck> returns this output
07:42:40 <Noobluck> Top level:
07:42:41 <Noobluck>     No instance for (Show (Tree a))
07:42:41 <Noobluck>       arising from use of `print' at Top level
07:42:41 <Noobluck>     Probable fix: add an instance declaration for (Show (Tree a))
07:42:41 <Noobluck>     In a 'do' expression: print it
07:42:55 <Noobluck> I don understand the error
07:42:56 <twb> Noobluck: don't flood.
07:42:59 <twb> lisppaste2: url
07:42:59 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:43:02 <chrisbrown> add deriving Show to your data type
07:43:05 <twb> Noobluck: use that next time.
07:43:11 <Noobluck> sorry
07:43:14 <Noobluck> i will
07:43:20 <twb> Noobluck: and all you need to do is add "deriving Show" to your data expression.
07:43:26 <twb> s/expression/form/
07:43:27 <Noobluck> how
07:43:36 <chrisbrown> data Foo a = Con1 a deriving Show
07:43:46 <twb> data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Show
07:43:51 <Noobluck> ok
07:43:54 <Noobluck> thanks
07:44:01 <Noobluck> what makes that?
07:44:50 <Saulzar> show is a function to turn a data type into a string (so it can be displayed), deriving Show gives you a default implementation
07:45:09 <Noobluck> thanks
07:45:31 <Saulzar> > show 5
07:45:32 <lambdabot> "5"
07:46:17 <Noobluck> > show map (2 *) [1,2,3,4] 
07:46:19 <lambdabot> Couldn't match `[Char]' against `t -> t1 -> t2'
07:46:35 <Noobluck> I get it
07:47:05 <Noobluck> and the expresion "deriving"
07:47:33 <Saulzar> > show (map (2 *) [1,2,3,4])
07:47:33 <Noobluck> this is explained in "Bird" book?
07:47:35 <lambdabot> "[2,4,6,8]"
07:47:35 <bolrod> >show $ map (2 *) [1,2,3,4]
07:47:40 <bolrod> > show $ map (2 *) [1,2,3,4]
07:47:41 <lambdabot> "[2,4,6,8]"
07:47:44 <bolrod> ;)
07:47:47 <Noobluck> > show (map (2 *) [1,2,3,4] )
07:47:49 <lambdabot> "[2,4,6,8]"
07:47:54 <Noobluck> ok
07:48:16 <Noobluck> $
07:48:25 <Noobluck> ^^
07:48:27 <Noobluck> Thanks guys
07:48:29 <Noobluck> !
07:48:57 <Noobluck> @help
07:48:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:49:06 <Noobluck> @list
07:49:08 <lambdabot> list [module|command]. Where modules is one of:
07:49:08 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda version vixen where
07:49:26 <Noobluck> @url
07:49:27 <lambdabot> Maybe you meant: arr pl
07:49:52 <Noobluck> lisppaste2: url
07:49:52 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:49:58 <Noobluck> book: url
07:50:09 <Noobluck> haskell: url
07:50:24 <Noobluck> -.-
07:50:27 <Noobluck> ~~
07:53:33 <twb> Hey...
07:53:57 <twb> I can refer to a word that's defined later on in the same file, right?
07:54:14 <ski> yes
07:54:18 <twb> Yay!
07:54:22 <twb> I hate that in factor.
07:56:24 <xerox> youLoveTechno?
07:56:36 <twb> Who's techno?
07:56:47 <Noobluck> is a kind of music 
07:56:51 <twb> Noobluck: lies!
07:57:12 <Noobluck> no
07:57:48 <Noobluck> XD
07:58:31 <twb> That's like having a genre called "piano music" or "guitar music".
08:00:09 <Noobluck> in spain is referred to a kind of disco music
08:00:29 <Noobluck> which uses synthetizer
08:00:54 <Noobluck> ahh
08:01:02 <Noobluck> wrote bad
08:02:11 <twb> Ingles no es tu lingua primero, sí? ;-)
08:06:01 <twb> OK, so everyone is familiar with C functions int f(&x) that take a pointer to an object that they write over.
08:06:16 <norpan> indeed
08:06:20 <twb> What's the Haskell idiom for dealing with them?
08:06:39 * twb braces self.
08:06:47 <norpan> well, you could use Ptr
08:06:52 <twb> nextEvent :: Display -> XEventPtr -> IO ()
08:07:22 <norpan> &x is a reference, *x is a pointer
08:07:35 <norpan> but they are almost the same :)
08:07:37 <robokop> could sb help me with installing wxHaskell on my ubuntulinux
08:07:38 <mauke> norpan: not in expressions
08:07:48 <mauke> norpan: besides, C doesn't have references
08:07:49 <ski> @babel es en Ingles no es tu lingua primero, sí?
08:07:50 <twb> robokop: aptitude install ~nwxhaskell
08:07:51 <lambdabot>  Ingles is not your lingua first, sí?
08:08:07 <norpan> mauke: he wrote int f(&x)
08:08:18 <mauke> norpan: that's a syntax error
08:08:20 <twb> @babel es en inglés no es tu lengua primero, sí?
08:08:22 <lambdabot>  inglés is not your language first, sí?
08:08:30 <twb> Hmph.
08:08:34 <norpan> anyway
08:08:41 <norpan> Ptr
08:08:57 <twb> Yeah, sorry, it is *x not &x.
08:09:02 <norpan> if you are pure haskell you would never do that, just return the object
08:09:10 <twb> norpan: yes, but I'm not writing the FFI.
08:09:17 <twb> norpan: I'm trying to *use* the FFI.
08:09:22 <norpan> yes, so that's a Ptr
08:09:30 <norpan> or ForeignPtr
08:10:58 <twb> Presumably I say something like do { x <- makeX; f x }
08:11:23 <robokop> twb: he can't find a "candidate version" what should i add to my resources.list
08:11:36 <twb> robokop: one moment...
08:12:18 <twb> robokop: ah, ok, this is hard.  I'll be with you in a bit.
08:12:29 <robokop> ke
08:12:47 <twb> norpan: In Scheme, I say (let ((ev (make-xevent))) (xnextevent dpy ev) (xevent-type ev))
08:13:35 <twb> norpan: that makes a dummy object, binds ev to it, calls the foreign function with ev as the argument, then destructures the mutated ev and returns the `type' part.
08:14:09 <norpan> but what is your question?
08:14:15 <norpan> XEventPtr is already a pointer
08:14:18 <twb> norpan: how do I do that in Haskell?
08:14:54 <twb> nextEvent expects an already created object to mutate, not NULL.
08:15:18 <twb> robokop: ok to PM you?
08:15:46 <norpan> so the api must have some way to create an XEventPtr
08:15:55 <twb> norpan: right.
08:16:20 <twb> norpan: I assumed there would be a standard haskell convention for naming such instantiator words.
08:16:46 <twb> e.g. Scheme always calls such words 'make-foo'.
08:20:29 <twb> norpan: hello?  Did I scare you off?
08:22:10 <Igloo> Is alloca/malloc what you want?
08:22:19 <twb> Igloo: not really.
08:22:27 <Igloo> What do you want then?
08:22:28 <norpan> why not
08:22:35 <twb> http://twb.ath.cx/~twb/darcs/tinywm/tinywm-c.c
08:23:15 <twb> As you can see, it's statically allocating at boot time (XEvent ev;)
08:23:51 <Igloo> No, it's dynamically allocating each time you call main
08:24:01 <norpan> just wrap the whole main inside an alloca
08:24:06 <Igloo> alloca/malloc is what you want
08:24:10 * twb feels dirty.
08:24:31 <Saulzar> allocaXEvent :: (XEventPtr -> IO a) -> IO a
08:24:33 <twb> Isn't alloca a GNU extension?
08:24:46 <twb> Saulzar: thanks!
08:24:51 <Igloo> It's a Haskell FFI function
08:24:59 <norpan> allocaXEvent sounds just like it's alloca
08:25:18 <twb> Shrug.
08:25:26 <twb> Do I have to manually destroy it, too?
08:25:33 <Igloo> No
08:25:36 <Saulzar> X11 haskell library doesn't look like too much fun to me :)
08:25:37 <Igloo> With malloc you would have to
08:25:41 <twb> Awesome.
08:25:45 <Igloo> (which is why you should use alloca unless you can't)
08:26:05 <twb> Oh, and it's like that in C, too.
08:26:18 <norpan> allocaXEvent may do some other stuff I don't know, so you should probably use that one instead of alloca
08:26:49 <twb> What happens if you do funky things with closures and continuations?
08:27:49 <norpan> if you do funky things, then you will probably get funky results :)
08:28:29 <twb> I'm kinda confused about how allocaXEvent works, too.
08:28:29 * esap thinks most funky stuff comes with an 'unsafe' prefix :-)
08:28:52 <norpan> alloca $ x -> f x is basically { x <- malloc; f x; free x }
08:28:53 <twb> I would've expected the type to be IO a
08:29:10 <norpan> err alloca $ \x -> f x
08:29:10 <twb> norpan: Oh.
08:29:16 <norpan> but faster
08:29:28 <norpan> since you can optimize the allocation
08:29:33 * twb squints
08:30:11 <ski> hi esap
08:30:20 <esap> Hi
08:31:10 <twb> Wow, my code still loads.
08:31:36 * esap has been thinking about encapsulation and encryption recently.
08:32:36 <ski> encapsulation as in module systems ?
08:33:05 <esap> ski: yes, and as in GADTs
08:33:49 <ski> what does that have to do with encryption ?
08:34:28 <esap> ski: encryption is a kind of stronger way of encapsulating data.
08:34:57 <twb> And it runs, too!
08:35:18 <ski> esap : you mean for purposes of serializing, etc ?
08:35:19 <twb> Why can't Schemers get their shit together like this? :-/
08:35:23 <metaperl> Could someone help with this "overlapping pattern matches error please" - http://rafb.net/paste/results/9H8dMn29.html
08:35:45 <vincenz> metaperl: ys will match anything
08:35:48 <twb> metaperl: swap the two substring definitions.
08:35:50 <vincenz> in substring xs ys
08:35:54 <esap> ski: I mean in the sense that it prevents access to the data.
08:36:15 <vincenz> metaperl: and if you swap em... might as well make that ys a []
08:36:21 <twb> metaperl: the dispatcher will use the first definition that can be successfully destructured.
08:36:44 <vincenz> metaperl: http://rafb.net/paste/results/uBirDS42.html
08:36:54 <twb> metaperl: "substring xs ys" will match "substring xs ('a':ys)"
08:37:28 <esap> ski: encapsulation does that too, but in a weaker sense, because you can often find the encapsulated information if you can correctly guess its type. In encryption, you have to correctly guess the key, which is a similar task, but somewhat harder :-)
08:39:26 <metaperl> oh I see.. vincenz and twb thanks
08:39:39 * shapr boings
08:39:48 <ski> esap : do you mean like guessing type and using 'unsafeCoerce#' ?
08:39:59 <twb> OK, so I've translated "XEvent ev; XNextEvent (dpy, &ev);".  But how do I translate "ev.type"? i.e. accessing a slot in a C structure.
08:40:12 <esap> ski: No, I mean like guessing type, and proving that the encapsulated data has that type.
08:41:05 <ski> esap : how ?
08:41:06 <esap> ski: GHC's existential quantification allows that as well, you can use proof certificates for opening encapsulation
08:41:12 <esap> ski: pattern matching
08:41:42 <esap> ski: you can pattern match existentially quantified data, if you can prove its type.
08:41:54 <ski> esap : in haskell ??
08:42:05 <esap> ski: yes. in GHC
08:42:48 <ski> can you give example of what you mean ?
08:43:15 <twb> ski: http://www.haskell.org/hawiki/ExistentialTypes ?
08:43:38 <esap> data EqType a b where { EqType :: EqType c c }. If you can obtain an instance of EqType a b, then you can convert from a to b, even if a is existentially quantified.
08:45:04 <esap> ski: there is a paper about this, hmm.. I can't now remember its name :-)
08:45:19 <ski> ok, you meant with that thing
08:45:44 <ski> (i was thinking more of 'Typable a => Dynamic -> Maybe a')
08:46:30 <metaperl> vincenz and twb: this is how I did it: substring xs ya@(y:ys)   = prefix xs ya || substring xs ys
08:48:00 <esap> ski: Note that this mechanism is based on interaction of pattern matching and existential quantification. Basically the type checker has to prove you know everything about the type (and the proof you give is correct).
08:49:14 <twb> If I have a pointer to a C struct created with alloca, how do I access slots in the struct?
08:49:52 <esap> twb: Storable (and poke/peek)
08:50:15 <twb> @index poke
08:50:16 <lambdabot> Foreign.Storable, Foreign
08:50:54 <shapr> I sent my papers to the immigration guys! I hope they let me stay in Sweden!
08:50:57 * shapr boings furiously
08:51:29 <ski> esap : but i don't see how you can "guess a type" that you have gotten from a random fresh existential ..
08:53:05 <esap> ski: you have to get the information from somewhere that you use for the proof. Of course, it's never "random", but you can pass the information from other places in the program.
08:53:23 <twb> esap: AFAICT the XEventPtr type isn't an instance of Storable...
08:54:40 <esap> twb: you can add and subtract pointers using plusPtr to find members from the struct.
08:55:06 <norpan> peekByteOff
08:55:29 <norpan> @index peekByteOff
08:55:29 <lambdabot> Foreign.Storable, Foreign
08:56:01 <twb> Ah, OK.
08:56:10 <norpan> but it seems there are accessor functions
08:56:16 <norpan> litke get_EventType etx
08:56:18 <norpan> etc
08:57:12 <esap> twb: you obviously need to know sizes of the members to compute offsets within the struct. if the members have type that is Storable, then there is the sizeOf operation.
08:57:48 <twb> esap: is there an elegant way to generate peekByteOff calls from the struct definition in its C header file?
08:57:57 <norpan> c2hs
08:58:22 * esap has written those by hand, but I suppose c2hs does that.
08:58:33 <norpan> it does
08:58:46 <ski> esap : so how would this compare to encryption ?
08:59:05 <pierre-> hello. I can't compile FastPackedStrings under windows, what's the problem might be?
08:59:14 <pierre-> ghc just hangs with error
08:59:23 <ski> esap : i don't see how encryption would be better, at this level, than existentials + equality proofs
08:59:32 <pierre-> "Internal compiler error"
09:00:25 <norpan> in c2hs you would just write {#get struct.field}
09:01:36 <esap> ski: they're not better, just that encryption is normally stronger, because of different purposes of encryption and encapsulation. Encryption attempts to guard against all access to data without the key.
09:02:16 <esap> ski: whereas encapsulation requires only that you know the *type* of the data.
09:02:30 <esap> ski: which is a weaker condition.
09:02:33 <davidhouse> what do people recommend as a unit testing framework for haskell
09:02:48 <twb> norpan: like this? nextEventType dpy = allocaXEvent $ \ev -> do { nextEvent dpy ev; return {#get ev.type} } ?
09:03:27 <esap> ski: The key in encryption is like the proof that the encapsulated data has the particular type.
09:04:06 <norpan> maybe, or return ({#get XEvent.type} ev)
09:04:24 <twb> norpan: OK, lemme install c2hs and try that
09:04:49 <Saulzar> One would think that if you are using a Haskell library wrapping a C library it would provide accessor functions already
09:04:53 <norpan> you can also use hsc files and use #peek XEvent, type
09:05:19 <twb> Saulzar: how do I check for such accessor functions?
09:05:34 <Saulzar> twb, Well it'll be in the docs somewhere maybe, but they seem a bit of a mess :)
09:05:37 <norpan> yes, it has the accessor functions already, which i mentioned above
09:05:50 <norpan> they are called get_EventType and similar
09:06:06 <twb> norpan: with an underscore?
09:06:12 <norpan> yes, look at the api
09:06:16 <twb> get_EventType :: XEventPtr -> IO EventType
09:06:17 <twb> Thanks.
09:06:51 <twb> Odd that it's IO...
09:07:07 <norpan> not odd at all, since it takes a Ptr
09:07:13 <twb> I would've thought destructuring a record wouldn't be stateful.
09:07:36 <Igloo> The data at the other end of the Ptr can change
09:07:39 <norpan> dereferencing a Ptr is certainly stateful
09:07:46 <twb> norpan: ah, good point.
09:08:15 <mux> how can I write such a pattern in a more simple way? 'f':'o':'o':rest
09:08:37 <mux> "foo":rest would yield a type error
09:08:39 <Saulzar> "foo" ++ rest ? 
09:08:41 <norpan> you can't
09:08:45 <davidhouse> you can't use ++
09:08:49 <integral> x | prefixOf "foo" x ?
09:08:49 <davidhouse> you can only use constructors
09:08:57 <ski> esap : yes, .. hm
09:08:57 <Saulzar> Ah, pattern
09:09:02 <norpan> at least you can't in haskell 98
09:09:04 <integral> @type prefixOf
09:09:04 <lambdabot> Not in scope: `prefixOf'
09:09:15 <davidhouse> @index prefixOf
09:09:15 <lambdabot> bzzt
09:09:25 <mux> mmm
09:09:25 <norpan> @type isPrefixOf
09:09:26 <lambdabot> Not in scope: `isPrefixOf'
09:09:31 <norpan> nope
09:09:36 <integral> @type Data.List.prefixOf
09:09:37 <lambdabot> Not in scope: `Data.List.prefixOf'
09:09:59 <davidhouse> odd...
09:09:59 <Saulzar> @type Data.List.isPrefixOf
09:10:00 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
09:10:08 <davidhouse> yeah, that one.
09:10:09 <norpan> there it is
09:10:11 <Saulzar> We get there in the end :)
09:10:17 <davidhouse> @hoogle isPrefixOf
09:10:17 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
09:10:19 <ski> @hoogle [a] -> [a] -> Maybe [a]
09:10:20 <davidhouse> ;)
09:10:20 <lambdabot> No matches, try a more general search
09:10:46 <norpan> but you can't do it using regular patterns
09:10:59 <davidhouse> doesn't look like it
09:11:04 <norpan> you can, but you have to write 'a':'b':x
09:11:18 <davidhouse> as the only constructors for lists are : and [].
09:11:30 <Saulzar> > let blargh foo | ("foo" `isPrefixOf` foo) = "Foo!" | otherwise ->  "Blargh!" in blargh "foobar"
09:11:30 <lambdabot>  parse error on input `->'
09:11:49 <davidhouse> > let blargh foo | ("foo" `isPrefixOf` foo) = "Foo!" | otherwise = "Blargh!" in blargh "foobar"
09:11:50 <lambdabot> "Foo!"
09:12:03 <davidhouse> > let blargh foo | ("foo" `isPrefixOf` foo) = "Foo!" | otherwise = "Blargh!" in blargh "4foobar"
09:12:03 <lambdabot> "Blargh!"
09:12:04 <ski> (norpan : i think something like that could be done in Escher or Curry, though ...)
09:12:14 <norpan> probably
09:12:22 <mux> thanks guys
09:12:32 <ski> norpan : also, Erlang has this, as a special common case
09:12:40 <davidhouse> > let blargh foo | "foo" `isPrefixOf` foo = "Foo!" | otherwise = "Blargh!" in blargh "foobar" -- think the parantheses are unnecessary as well
09:12:40 <lambdabot> "Foo!"
09:13:08 <norpan> but that's not the same as pattern matching; x is bound to the rest of the string
09:13:35 <Saulzar> Right...
09:13:40 <ski> > let a | True <- True = () in a
09:13:41 <lambdabot>   Warning: accepting non-standard pattern guards (-fglasgow-exts to suppress this message)
09:13:41 <lambdabot>       [True <- True, ()]
09:14:02 <davidhouse> ski, wtf?
09:14:11 <ski> pattern-guards
09:14:42 <davidhouse> what does it mean?
09:14:45 <davidhouse> what's True <- True?
09:14:52 <norpan> that's True
09:15:06 <ski> assume you have
09:15:07 <ski> matchPrefix :: [a] -> [a] -> Maybe [a]
09:15:08 <Saulzar> Matches True against True :)
09:15:26 <ski> which works as
09:15:51 <davidhouse> Saulzar: yes, but the output...
09:16:14 <ski> matchPrefix prefix as = if prefix `isPrefixOf` as then Just (drop (length prefix) as) else Nothing
09:16:25 <ski> (but possibly implemented more efficiently)
09:16:34 <ski> then with pattern-guards you could write
09:17:29 <ski> > let blargh foo | Just suffix <- "foo" `isPrefixOf` foo = reverse suffix | otherwise = "Blargh!" in blargh "foobar"
09:17:30 <lambdabot> Couldn't match `Bool' against `Maybe a'
09:17:40 <ski> this would return "rab"
09:18:11 <norpan> s/isPrefixOf/matchPrefix/
09:18:33 <ski> er, right
09:18:57 <davidhouse> makes sense.
09:19:03 <davidhouse> but the output is very weird.
09:19:15 <ski> it's like a generator in a list-comprehension, except pattern and expression has same type
09:19:22 <davidhouse> > let matchPrefix prefix as = if prefix `isPrefixOf` as then Just (drop (length prefix) as) else Nothing; blargh foo | Just suffix <- "foo" `isPrefixOf` foo = reverse suffix | otherwise = "Blargh!" in blargh "foobar"
09:19:23 <lambdabot> Couldn't match `Bool' against `Maybe a'
09:19:32 <davidhouse> > let matchPrefix prefix as = if prefix `isPrefixOf` as then Just (drop (length prefix) as) else Nothing; blargh foo | Just suffix <- "foo" `matchPrefix` foo = reverse suffix | otherwise = "Blargh!" in blargh "foobar"
09:19:32 <lambdabot>   Warning: accepting non-standard pattern guards (-fglasgow-exts to suppress this message)
09:19:32 <lambdabot>       [Just suffix <- "foo" `matchPrefix` foo, reverse suffix]
09:19:54 <norpan> interesting output
09:20:03 <ski> it's some error msg, i thikn
09:20:35 <Saulzar> Hmm, in ghci it gives "rab" as the next line despite the warning 
09:20:46 <davidhouse> works with -fglasgow-exts.
09:20:50 <davidhouse> doesn't give me the warning.
09:20:53 <davidhouse> okay, now i understand :)
09:20:59 <davidhouse> the output was confusing me
09:21:16 <ski> probably lambdabot doesn't expect the warning message, so forgets the next line or something ..
09:22:00 <davidhouse> well, what lambdabot spat out is exactly what my ghci gave me.
09:22:15 <davidhouse> it just looks more like an error message in lambdabot
09:22:18 <davidhouse> *ghci
09:22:21 <ski> k
09:26:15 <chrisbrown> does anyone know of a pre-defined operator (#) ?
09:26:45 <mauke> @index #
09:26:46 <lambdabot> bzzt
09:26:53 <davidhouse> @hoogle (#)
09:26:53 <lambdabot> Prelude.(>) :: Ord a => a -> a -> Bool
09:26:53 <lambdabot> Prelude.(>=) :: Ord a => a -> a -> Bool
09:26:53 <lambdabot> Prelude.(>>) :: Monad m => m a -> m b -> m b
09:26:55 <mauke> @index (#)
09:26:56 <lambdabot> bzzt
09:27:14 <Saulzar> ghc uses # to refer to operations on unboxed types
09:27:22 <chrisbrown> ah
09:27:26 <chrisbrown> that could be it
09:27:31 <chrisbrown> cheers
09:27:46 <osqulda> are haskell arrays mutable these days?
09:27:48 <osqulda> with //
09:28:01 <osqulda> O(1) updateable?
09:28:37 <osqulda> 1995 they was not, only O(1) indexing - is this correct?
09:29:06 <pierre-> dons: Hello, can you help me with compiling your fps library under Windows?
09:29:49 <int-e> osqulda: there are mutable arrays, in the IO and ST monads. (IOArray and STArray).
09:30:03 <Saulzar> osqulda, There are mutable arrays in ST and IO monads, and updatable arrays with DiffArrays 
09:30:21 <int-e> osqulda: there are also diff arrays which have O(1) updates but with a slowdown of lookup for older versions of the array.
09:30:37 <int-e> Saulzar: heh.
09:30:46 <Saulzar> snap :)
09:31:15 <int-e> well, at least we agreed with each other ;)
09:31:20 <chrisbrown> whats a Functor?
09:31:41 <Saulzar> Functor class is for containers which support map (fmap)
09:31:56 <Saulzar> Not sure what exactly it is in general...
09:32:08 <chrisbrown> ok
09:32:26 <int-e> fmap should satisfy fmap (f . g) = fmap f . fmap g and fmap id = id
09:32:27 <chrisbrown> back to the unboked types, what does this mean...  fresh = (show::Int->String) # fresh
09:32:35 <chrisbrown> *unboxed
09:32:49 <int-e> that makes it a functor in the category theoretical sense.
09:32:54 <davidhouse> chrisbrown: basically, types that can be mapped over
09:33:05 <davidhouse> Monad is a subclass of Functor.
09:33:17 <osqulda> But the // incremental update, is that not O(1) while !! is also O(1) in GHC?
09:33:25 <SyntaxNinja> <--- birthday
09:33:25 <chrisbrown> im getting an error that I need to add an instance declaration for Functor
09:33:43 <neologism> functor is a morphism among categories which preserves its structure (iirc)
09:33:51 <neologism> s/among/between
09:33:56 <Saulzar> chrisbrown, That looks like it might be used as something else... 
09:34:28 <alar> @where Template Haskell
09:34:28 <lambdabot> I know nothing about template.
09:34:39 <davidhouse> http://en.wikipedia.org/wiki/Functor#Definition
09:34:43 <chrisbrown> oh thanks
09:34:57 <davidhouse> chrisbrown: but that's probably a bit heavy if all you're getting is an error
09:35:07 <int-e> chrisbrown: it does not need to preserve anything; there's a functor from any category to the single-object category, which 'forgets' everything.
09:35:09 <chrisbrown> haha - true
09:35:26 <chrisbrown> perhaps all i need is a deriving Functor somewhere...
09:35:29 <davidhouse> you're probably trying to use fmap on something that isn't a Functor
09:35:35 <davidhouse> chrisbrown: pastebin some code
09:35:37 <int-e> chrisbrown: sorry, that was for neologism 
09:35:42 <Saulzar> Not sure you can derive Functor... er, can you?
09:35:43 <chrisbrown> it worked in 6.4 and now breaks in 6.5
09:35:52 <shapr> SyntaxNinja: True Ultimate POWER!
09:36:37 <int-e> Saulzar: only in newtypes, with ghc's extension.
09:37:00 <chrisbrown> ah it is a newtype
09:37:12 * chrisbrown tries to add deriving Functor...
09:37:19 <davidhouse> @where paste
09:37:19 <lambdabot> http://paste.lisp.org/new/haskell
09:38:00 <chrisbrown> when you use deriving, does the compiler generate instances automatically?
09:38:16 <davidhouse> that would be the whole point of it ;)
09:38:49 <SyntaxNinja> shapr: indeed.
09:41:30 <chrisbrown> it says "cant make a derived instance of 'Functor (IM i c) (even with cunning newtype deriving:..."
09:41:33 <chrisbrown> bummer
09:41:43 <davidhouse> pastebin some code :)
09:41:49 <chrisbrown> me?
09:41:54 <davidhouse> yeah!
09:41:59 <chrisbrown> how?
09:42:03 <davidhouse> @where paste
09:42:03 <lambdabot> http://paste.lisp.org/new/haskell
09:42:09 <davidhouse> copy-paste it into there
09:42:15 <chrisbrown> ok
09:42:21 <chrisbrown> there are 2 files
09:42:43 <ski> int-e : functors into the final category still preserves the category structure ..
09:42:58 <davidhouse> chrisbrown: pastebin the type definition, and where you're getting the error
09:43:04 <chrisbrown> ok
09:43:57 <lisppaste2> chrisbrown pasted "Deriving Functor" at http://paste.lisp.org/display/18584
09:44:06 <chrisbrown> http://paste.lisp.org/display/18584
09:44:16 <chrisbrown> oh it did it automatically, cool
09:44:33 <int-e> ski: Ah. I was applying 'structure' to the wrong level then. (the category of groups has arguably more structure than the final category)
09:45:13 <davidhouse> chrisbrown: what's line 48?
09:45:28 <int-e> ski: but the structure is that of the objects, and category theory conveniently ignores that.
09:45:28 <davidhouse> or even, remove deriving (Functor) and then give us the other error
09:45:32 <chrisbrown> the newtype definition
09:45:32 <twb> Yay, I used >>= and understood what I was doing!
09:45:43 <chrisbrown> davidhouse: ok will do that
09:45:56 <ihope> twb: congrats
09:46:01 <twb> ihope: thanks.
09:46:43 <chrisbrown> @where paste
09:46:43 <lambdabot> http://paste.lisp.org/new/haskell
09:48:08 <davidhouse> @hoogle a -> [a] -> Maybe a
09:48:08 <lambdabot> No matches, try a more general search
09:48:13 <ihope> x |> y = y x -- is |> usually the operator used here, or is it something else?
09:48:16 <davidhouse> @hoogle [a] -> a -> Maybe a
09:48:17 <twb> Remind me, what's the invocation of ghci to not print the banner?
09:48:17 <lambdabot> No matches, try a more general search
09:48:32 <ihope> davidhouse: what are you looking for?
09:49:07 <davidhouse> nothing really.
09:49:31 <davidhouse> ooh, ihope: had an idea about that experimentation with a tertiary operator in haskell.
09:49:53 <ihope> What be it?
09:50:06 <davidhouse> > let b ? rs = if b then (head rs) else (last rs) in True ? "hello" : "world"
09:50:08 <lambdabot> "hworld"
09:50:17 <davidhouse> aww. didn't quite work.
09:50:23 <davidhouse> would do with proper fixity.
09:50:23 <twb> davidhouse: er, aren't all operators in Haskell unary?
09:50:30 <davidhouse> > let b ? rs = if b then (head rs) else (last rs) in True ? ("hello" : "world")
09:50:30 <lambdabot> Couldn't match `[Char]' against `Char'
09:50:34 <ihope> twb: binary
09:50:40 <davidhouse> nuts. okay, it won't work.
09:50:51 <twb> ihope: then why does (2*) work?
09:50:56 <liyang> Except for -, but we try not to think about that.
09:51:02 <davidhouse> that's a section, not an operator
09:51:14 <lisppaste2> chrisbrown pasted "more Functor errors" at http://paste.lisp.org/display/18585
09:51:15 <ihope> twb: that's called a section. Haskell functions are curried, so sections Just Work. :-)
09:51:22 <davidhouse> twb, the tertiary operator in other languages is something like variable = predicate ? true_value : false_value.
09:51:30 <chrisbrown> davidhouse:  http://paste.lisp.org/display/18585
09:51:33 <twb> davidhouse: that's called `if'.
09:51:40 <davidhouse> variable will take true_value if predicate is true, or false_value if predicate is false.
09:51:45 * twb thinks distinguishing between functions and operators is silly.
09:51:55 <davidhouse> twb, well, yes, but more succinctly.
09:52:03 <twb> davidhouse: hardly.
09:52:19 <twb> davidhouse: the reason ?: exists in C is because C's IF doesn't return a value.
09:52:33 <davidhouse> that's what i was getting to.
09:52:38 <liyang> You can write a (the?) tertiary operator in Haskell quite easily.
09:52:51 <ihope> > let x ? y = (x,y); (x,y) ?: z = if x then y else z in True ? "hello" ?: "world"
09:52:51 <lambdabot> "hello"
09:52:52 <twb> In a language like Haskell where all (AFAIK) forms return, ?: is pointless.
09:52:53 <davidhouse> liyang: not using ? and :, you can't.
09:53:00 <ihope> > let x ? y = (x,y); (x,y) ?: z = if x then y else z in False ? "hello" ?: "world"
09:53:01 <lambdabot> "world"
09:53:08 <liyang> davidhouse: ? and $ is good enough.
09:53:24 <twb> Incidentally, factor's definition of if is cool.
09:53:50 <ihope> if True then x else y = x; if False then x else y = y
09:53:54 <ihope> :-)
09:54:10 <davidhouse> ihope, yeah. my idea was to use : to create a list then use the predicate to select which value, but i was getting : mixed up with ++.
09:54:46 <twb> http://factorcode.org/responder/browser/?vocab=kernel&word=if
09:54:52 <chrisbrown> davidhouse: strange I get different error now
09:54:55 <chrisbrown> @where past
09:54:56 <lambdabot> I know nothing about past.
09:55:00 <chrisbrown> @where paste
09:55:00 <ihope> Hmm...
09:55:00 <lambdabot> http://paste.lisp.org/new/haskell
09:55:19 <ihope> > let b ? rs = if b then (head rs) else (tail rs) in True ? (error "hello" : error "world")
09:55:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:55:20 <lambdabot>   Expected type: [a]
09:55:20 <lambdabot>   Inferred type: [[a]]
09:55:27 <lisppaste2> chrisbrown pasted "strange functor" at http://paste.lisp.org/display/18586
09:55:28 <ihope> Ow. Okay, it doesn't work.
09:56:17 <davidhouse> chrisbrown: not your software, eh? i don't know. best to email the author
09:56:38 <chrisbrown> davidhouse: ok, thanks
09:56:44 <twb> Ah, fuck.
09:56:52 <ihope> Oh, right right right.
09:56:54 <ski> (int-e : yes)
09:57:00 <davidhouse> ihope, last rs?
09:57:09 <ihope> davidhouse: what?\
09:57:39 <davidhouse> both the branches of an if need the same type
09:57:41 <davidhouse> @type head
09:57:42 <lambdabot> forall a. [a] -> a
09:57:44 <davidhouse> @type tail
09:57:44 <lambdabot> forall a. [a] -> [a]
09:57:51 <twb> Is there COND for Haskell?
09:57:57 <ihope> twb: a what?
09:58:02 <davidhouse> (probably won't work anyway, and even if it does, eurgh ;))
09:58:24 <davidhouse> > let b ? rs = if b then (head rs) else (last rs) in True ? (error "hello" : error "world")
09:58:25 <lambdabot> Add a type signature
09:58:32 <ihope> > (((3/8) * log 3) + ((5/8) * log 5)) / log 2
09:58:33 <lambdabot> 2.0455659970750353
09:58:34 <twb> ihope: (cond (p c) (t a)) ==> (if p c a)
09:58:42 <davidhouse> ihope, actually, that works on my ghci.
09:59:01 <ihope> davidhouse: but last gets the wrong thing.
09:59:15 <ihope> It gets the last element of error "world".
09:59:27 <davidhouse> no it doesn't
09:59:32 <ski> twb : guards ?
09:59:37 <ihope> ...Yes, it does.
09:59:39 <davidhouse> it gets the last element of (error "hello" : error "world")
10:00:00 <ihope> Well, the last element of (error "hello" : error "world") is the last element of (error "world").
10:00:05 <davidhouse> let b ? rs = if b then (head rs) else (last rs) in False ? (error "hello" : error "world")
10:00:05 <davidhouse> *** Exception: world
10:00:26 <ihope> > let b ? rs = if b then (head rs) else (last rs) in True ? (error "hello" : "world") :: Char
10:00:27 <lambdabot> Exception: hello
10:00:30 <ski> > case () of () | 2 > 3 = "foo" | 5 < 1 = "bar" | otherwise = "bax"
10:00:31 <lambdabot>  parse error on input `='
10:00:36 <ihope> > let b ? rs = if b then (head rs) else (last rs) in False ? (error "hello" : "world") :: Char
10:00:37 <lambdabot> 'd'
10:00:42 <ski> > case () of () | 2 > 3 -> "foo" | 5 < 1 -> "bar" | otherwise -> "bax"
10:00:43 <lambdabot> "bax"
10:00:48 <davidhouse> hmm... odd.
10:00:57 <ihope> > last "bar"
10:00:57 <lambdabot> 'r'
10:01:06 <twb> ski: http://twb.ath.cx/~twb/darcs/tinywm/tmp.hs :-)
10:01:17 <ihope> > last (error "hello" : error "world")
10:01:17 <lambdabot> Add a type signature
10:01:24 <ihope> > last (error "hello" : "world")
10:01:25 <lambdabot> 'd'
10:01:44 <davidhouse> > last (error "hello" : error "world" )
10:01:45 <lambdabot> Add a type signature
10:01:49 <ski> (twb : no 'eval' ? :)
10:02:02 <davidhouse> > last (error "hello" : error "world" ) :: [Char]
10:02:03 <lambdabot> Exception: world
10:02:06 <twb> minion: MORE DYNAMICITY
10:02:26 <ski> twb : wrong channel
10:02:30 <twb> Yeah.
10:02:34 * ihope gets a sudden idea
10:02:43 <ski> twb : 'case' in haskell is not same as 'case' in scheme
10:02:44 <davidhouse> ihope, yeah. using error twice works ;)
10:02:49 <twb> I sure miss SHOW-PROCEDURE, tho.
10:02:54 <ihope> davidhouse: indeed, it does...
10:02:56 <twb> ski: yeah, I know.
10:03:03 <ihope> newtype String = String [Char] deriving ...
10:03:09 * davidhouse blesses _|_
10:03:13 <ski> case () | n == two -> 12 | n == three -> 13
10:03:19 <twb> ski: it's the lack of unquoting in the pattern matching forms that I was alluding to.
10:03:49 <ski> twb : erlang support what you want there, i think
10:03:56 <ihope> Now, who can guess what (((3/8) * log 3) + ((5/8) * log 5)) / log 2 is?
10:04:11 <davidhouse> ihope, now, is there a way to pull the value out of an exception?
10:04:25 <ihope> davidhouse: that's cheating :-)
10:04:33 <ski> twb : since variables in patterns in a case in erlang doesn't shadow previous variables (this is a heritage from prolog)
10:04:33 <ihope> @hoogle a -> String
10:04:34 <lambdabot> Prelude.show :: Show a => a -> String
10:04:34 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
10:04:34 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
10:04:43 <davidhouse> > show $ error "hello"
10:04:43 <lambdabot> Add a type signature
10:04:46 <ihope> It doesn't look like there's a way.
10:05:02 <davidhouse> that's still _|_, apparently.
10:05:08 <ihope> Aye.
10:05:24 <ihope> Hmm...
10:05:32 <ihope> @hoogle Int# -> Int
10:05:32 <lambdabot> Hoogle Error: Parse Error: Unexpected character '> -> Int'
10:05:42 <ihope> Okay, Hoogle doesn't like that.
10:05:46 <ihope> @index I#
10:05:46 <lambdabot> GHC.Exts
10:05:50 <ihope> Aha.
10:06:02 <davidhouse> what is this unboxed types nonsense?
10:06:13 <ski> @type GHC.Exts.I#
10:06:14 <lambdabot> GHC.Prim.Int# -> Int
10:06:14 <ihope> davidhouse: values without thunks around them
10:06:20 <ihope> @kind GHC.Exts.Char# -- a C character?
10:06:21 <lambdabot> #
10:06:25 <ski> @kind GHC.Prim.Int#
10:06:26 <lambdabot> #
10:06:26 <ihope> Yep.
10:06:35 <davidhouse> thunks?
10:06:42 <ski> ihope : i think it can be unicode ..
10:06:54 <ihope> @google define:thunk
10:06:55 <lambdabot> No Result Found.
10:07:14 <twb> ski: What's wrong with http://twb.ath.cx/~twb/darcs/tinywm/tmp2.hs ?
10:07:17 <ihope> http://en.wikipedia.org/wiki/Thunk
10:07:24 <ski> davidhouse : unboxed means that no thunk is stored, instead a forced value
10:08:35 <ihope> Well, so a thunk is a way to get a value rather than the value itself.
10:08:41 <davidhouse> "Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object. The representation of a Haskell Int, for example, is a two-word heap object. An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved." <- ghc user guide
10:09:00 <ski> twb : what is expected ? what happens ?
10:09:34 <twb> ski: nm, it was me trying to be clever.
10:09:42 <twb> succ = (+1) and so on
10:10:37 <ski> why 'error = -1' ?
10:10:43 <twb> Because I'm lazy.
10:10:52 <ihope> Um...
10:11:00 <twb> I was confirming that I had gotten the guard syntax right.
10:11:18 <ski> ok, it looks ok to me
10:11:29 <twb> It compiles, therefore it is good :-)
10:11:54 <ski> hehe
10:12:50 <ski> (don't forget there can still be run-time errors, or logic errors, even if run-time *type*-errors shouldn't appear :)
10:13:21 <twb> I'm good at catching smart mistakes (e.g. logic errors).  It's the stupid errors that I make.
10:13:44 <twb> It's like maths.  I can do differential equations, but I can't do arithmetic without a pen and paper.
10:14:59 <wchogg> Hah!  I've definately been there.
10:15:10 <twb> wchogg: glad to know I'm not alone.
10:16:07 <twb> Man, gluing FP code onto nonFP code really blows goats.
10:18:49 <twb> Hmm.  I have like a 19-tuple that I want only the first slot of.
10:19:00 <twb> Is there an elegant way to say f (x, ...) = x ?
10:20:24 <liyang> twb: use a record instead of a tuple?
10:20:30 <SyntaxNinja> twb: not that I know of without template haskell. is this generated code? why use such a tuple?
10:20:31 <twb> liyang: it's not my tuple.
10:20:32 <sieni> yes
10:20:41 <sieni> > (\(x,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_)->x)(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
10:20:42 <lambdabot> 1
10:20:57 <twb> sieni: heh.
10:20:59 <wchogg> Yeah, but I think he meant without writing all that.
10:21:06 <SyntaxNinja> it's elegant. 
10:21:10 <sieni> well, now he can cut and paste ;-)
10:21:23 <sieni> @pl (\(x,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_)->x)
10:21:24 <lambdabot> (line 1, column 7):
10:21:24 <lambdabot> unexpected ","
10:21:24 <lambdabot> expecting operator or ")"
10:21:24 <lambdabot> ambiguous use of a non associative operator
10:21:35 <sieni> @pl \(x,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_)->x
10:21:36 <lambdabot> (line 1, column 6):
10:21:36 <lambdabot> unexpected ","
10:21:36 <lambdabot> expecting operator or ")"
10:21:36 <lambdabot> ambiguous use of a non associative operator
10:21:39 <sieni> hva?
10:22:05 <ski> pl doesn't understand tuples
10:22:12 <liyang> @pl f (x,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_) = x
10:22:12 <lambdabot> (line 1, column 5):
10:22:12 <lambdabot> unexpected ","
10:22:12 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
10:22:17 <liyang> oh.
10:22:21 <ski> @pl (a,b)
10:22:21 <lambdabot> (a, b)
10:22:27 <ski> @pl \a b -> (a,b)
10:22:27 <lambdabot> (,)
10:22:29 <ski> hm
10:22:46 <ski> doesn't understand them in patterns, anyway, it seems
10:23:26 <liyang> @pl f ((,) a b) = a
10:23:27 <lambdabot> (line 1, column 13):
10:23:27 <lambdabot> unexpected "="
10:23:27 <lambdabot> expecting variable, "(", operator or end of input
10:23:30 <twb> The other way is to cheat and look up the peekByteOff in the library's source code.
10:23:51 <liyang> twb: that's just wrong.
10:24:50 <twb> Curiously, the struct as defined in Xlib.h has more slots than the one in Graphics.X11.Xlib
10:25:23 <ski> possibly Template Haskell can be used, too
10:25:59 <ihope> @index peekByteOff
10:25:59 <lambdabot> Foreign.Storable, Foreign
10:26:13 <ihope> @type Foreign.peekByteOff
10:26:14 <lambdabot> forall a b.
10:26:14 <lambdabot>         (Foreign.Storable.Storable a) =>
10:26:14 <lambdabot>         GHC.Ptr.Ptr b -> Int -> IO a
10:26:20 <twb> I tell you one thing, every bloody Xlib function takes a Display *dpy parameter.
10:26:24 <boy> is the Graphics.X11 stuff enough to make a complete window manager?
10:26:31 <twb> Stuffing that into an ST Monad sounds like a damn good idea.
10:26:40 <twb> boy: that's what I'm finding out.
10:26:57 <boy> twb: really?
10:27:04 <twb> boy: yes.
10:27:13 <boy> twb: cool, you are making a window manager in haskell?
10:27:17 <twb> boy: yes.
10:27:59 <boy> sweet, what's your ui philosophy?
10:28:05 <ihope> > reverse "drop"
10:28:06 <lambdabot> "pord"
10:28:18 <boy> > reverse "star rats"
10:28:19 <twb> boy: it will have the look and feel of GNU Screen.
10:28:19 <lambdabot> "star rats"
10:28:35 <ski> > reverse "rats live on no evil star"
10:28:36 <lambdabot> "rats live on no evil star"
10:28:52 <boy> twb: interseting... so the idea is something minimalistic?
10:29:01 <twb> boy: ever use Ratpoison or StumpWM?
10:29:14 <ski> twb : does tinywm look like screen ?
10:29:17 <boy> twb: yeah, but my current and favorite wm is wmii
10:29:20 <twb> ski: no way.
10:29:32 <ski> (twb : i assumed someone else wrote tinywm, but maybe you did ?)
10:29:35 <twb> ski: tinywm is "dipping the toe in the water" territory.
10:29:40 <ski> ok
10:29:43 <twb> I didn't write the C version.
10:29:49 <ski> yah
10:29:50 <twb> I wrote the CL and Scheme versions.
10:30:00 <ski> (right)
10:30:09 <twb> Someone else did a Python version.
10:30:54 <boy> twb: are you familiar with wmii?
10:31:21 <twb> boy: nope.
10:31:29 <twb> boy: wmi felt too much like vi, so I lost interest.
10:31:55 <boy> twb: wmii still feels a bit like vi, but it's really really great
10:32:56 <ski> (is 'wmii' an abbreviation of something ?)
10:33:05 <boy> window manager improved 2
10:33:30 <boy> it has pretty much every feature you could want in a wm
10:33:37 <boy> but it's super minimal
10:33:57 <boy> and then coming up version 3 is totally awesome
10:34:01 <twb> ski: you've used GNU Screen, right?
10:34:09 <twb> ski: imagine that, but for X.
10:34:28 <musasabi> ion is nice.
10:34:37 <boy> musasabi: wmii is better then ion
10:34:49 <ski> twb : i learned about it about 2 weeks ago
10:34:51 <twb> I found ion too bloated and requiring too much configuration.
10:34:51 <musasabi> for which values of better?
10:34:59 <twb> ski: o_O
10:35:09 <twb> ski: you only just learnt about GNU Screen?!
10:35:10 <ski> (twb : and i'm liking it :)
10:35:11 <boy> musasabi: all values :) wmii is actually usable with apps that require floating windows, like gimp
10:35:12 <ski> yes
10:35:17 <twb> ski: you poor bastard.
10:35:25 <sieni> wtf?
10:35:30 <mnislaih> What is an efficient data structure to hold a collection of terms and provide efficient search which allows to retrieve the index? I was targeting for Data.Set, but it doesn't provide the index of a term
10:35:30 <twb> boy: gimp doesn't require floating windows.
10:35:55 <twb> mnislaih: an alist or hash.
10:36:15 <Saulzar> mnislaih, What do you mean index? A map?
10:36:17 <twb> type alist = [(key,val)]
10:36:22 <mnislaih> what do you mean with alist. an array ?
10:36:24 <mnislaih> ok
10:36:26 <twb> ...also called a map
10:36:27 <ski> twb : so will your wm in X be able to detach and attach, then ?
10:36:28 <boy> twb: but it really helps to have them
10:36:36 <mnislaih> but that won't be efficient with 300000... elements
10:36:48 <twb> ski: unfortunately, no.  That requires changes to the X server.
10:36:48 <Saulzar> Try Data.Map 
10:36:50 <mnislaih> and.. I don't really need a map
10:36:55 <twb> ski: or a special X proxy.
10:36:59 <mnislaih> but I could use one anway
10:37:07 <ski> twb : mhm
10:37:14 <twb> boy: I don't miss 'em.
10:37:22 <Saulzar> What do you mean index, is the question then...
10:37:26 <twb> boy: but then, I use Inkscape instead of shitty ol' Gimp.
10:38:28 <twb> Grr, align.el doesn't support haskell out of the box.
10:38:45 <boy> twb: hm... well, i find them very useful sometimes. i recommend you take a look at wmii, and do as it does with a seperate floating window layer
10:38:59 <twb> boy: I don't want nor need that.
10:39:23 <boy> alrighty then, just a suggestion :)
10:39:23 <davidhouse> twb, try haskell-mode
10:39:29 <twb> davidhouse: I know.
10:39:34 <davidhouse> (not that i know what align.el does)
10:39:35 <twb> davidhouse: align.el is a minor mode.
10:40:01 <mnislaih> Saulzar: I mean index like position in an array. I was thinking in some kind of ordered list
10:40:46 <shapr> boy: ion works with floating windows just fine.
10:40:47 <Saulzar> mnislaih, Well you could use an array... if you want an array :)
10:40:48 <mnislaih> Saulzar: But of course the built-in list type isn't efficient for searching, even if it is ordered
10:41:00 <shapr> twb: Inkscape and gimp do different things.
10:41:13 <mnislaih> Saulzar: is there any sorted array implementation ?
10:41:29 <twb> shapr: I know.
10:42:45 <Saulzar> mnislaih, Maybe not - it would only be useful with mutable arrays in ST or IO, you're much better off with Map
10:44:34 <davidhouse> twb, what does it do?
10:44:38 <davidhouse> align.el
10:45:23 <mnislaih> Saulzar as a matter of fact, I was already using Map. I just thought there must be a more efficient data structure if I don't need a Dictionary, just a sorted list. I don't know the Haskell libraries so well
10:45:24 <twb> davidhouse: it aligns the selected region at e.g. = and comments and stuff.
10:45:35 <twb> davidhouse: like a DWIM for align-regexp
10:45:49 <twb> http://google.com.au/search?q=align.el+johnw
10:45:59 <twb> http://google.com.au/search?q=align.el+newartisans
10:47:55 <twb> Does this already exist?
10:47:56 <twb> repeatedly f = f >> (repeatedly f)
10:48:38 <shapr> It's called fix
10:48:47 <twb> @index fix
10:48:48 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
10:48:57 <shapr> Short for fixpoint
10:49:03 <shapr> And has much functional voodod associated with it.
10:49:12 <shapr> There's fix for functions, mfix for monads, and loop for arrows.
10:49:19 <shapr> They're all the same thing, roughly.
10:49:36 <twb> This is based on the King Herod stuff, right?
10:49:59 <ibid> ?
10:50:11 <ibid> fixpoint is a mathematical term
10:50:13 <shapr> I think I should have gotten that joke...
10:50:21 <twb> For approximating sqrt() by fixed point approximation.
10:51:04 <twb> They don't teach that to first-year haskell students?!
10:51:24 <mauke> oh, heron?
10:51:34 <twb> Er, yeah.
10:51:40 <twb> He's from Alexandria, anyway.
10:52:37 <ibid> i was wondering what part of "bring me john's head on a sliver plate" has anything to do with fixpoints :)
10:53:04 <twb> Obviously too much bible studies for twb in his younger days.
10:53:43 <twb> Back when .au schools did that sort of thing.
10:54:12 <ibid> i think the most general definition of fixpoints is in cpo theory
10:54:25 <mauke> that golden robot?
10:54:26 <ihope> Oh, right right.
10:54:36 <twb> My repeatedly is different from mfix.
10:54:39 <ihope> Suppose 3 bits are taken as representing a number 1-8.
10:54:47 <twb> repeatedly f = f >> (repeatedly f)
10:54:47 <twb> hello = putStrLn "hello!\n"
10:54:48 <ibid> every other definition follows from it
10:54:53 <ibid> mauke: complete partial order
10:54:55 <twb> then try "repeteadly hello".
10:55:20 <davidhouse> that would un-endingly print "hello"
10:55:23 <twb> It's like (loop (print (read (eval))))
10:55:25 <twb> davidhouse: yes.
10:55:29 <davidhouse> (and you don't need \n for putStrLn)
10:55:31 <twb> davidhouse: which is what I want, in this cae.
10:55:35 <twb> *case
10:55:38 <ibid> yeah, mfix is value recursion, yours is unfolding recursion
10:55:42 <ihope> @type let repeatedly f = f >>= repeatedly in repeatedly
10:55:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
10:55:42 <lambdabot>   Expected type: a -> m b
10:55:46 <ihope> Aww.
10:55:58 <twb> repeatedly :: (Monad m) => m a -> m b
10:56:11 <ihope> Again... suppose 3 bits are taken as representing a number 1-8. If this number is 1-3, we instead treat it as a trit; if it's 4-8, we treat it as a quint.
10:56:26 <ibid> @type let repeatedly :: (Monad m) => m a -> m b ; repeatedly f = f >>= repeatedly in repeatedly
10:56:26 <lambdabot>   Couldn't match the rigid variable `a' against `m a1'
10:56:26 <lambdabot>   `a' is bound by the type signature for `repeatedly'
10:56:33 <ibid> @type let repeatedly :: (Monad m) => m a -> m a ; repeatedly f = f >>= repeatedly in repeatedly
10:56:34 <lambdabot>   Couldn't match the rigid variable `a' against `m a1'
10:56:34 <lambdabot>   `a' is bound by the type signature for `repeatedly'
10:56:48 <twb> @hoogle (Monad m) => m a -> m b
10:56:49 <lambdabot> Prelude.id :: a -> a
10:56:49 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
10:56:49 <lambdabot> Prelude.asTypeOf :: a -> a -> a
10:56:51 <ibid> @type let repeatedly :: (Monad m) => a -> m a ; repeatedly f = f >>= repeatedly in repeatedly
10:56:51 <lambdabot>   Couldn't match the rigid variable `a' against `m a1'
10:56:51 <lambdabot>   `a' is bound by the type signature for `repeatedly'
10:56:59 <ihope> > (((3/8) * log 3) + ((5/8) * log 5)) / log 2 -- the average amount of information, in bits, we're left with after the above
10:57:00 <lambdabot> 2.0455659970750353
10:57:27 <davidhouse> ibid, bind rips the value out of the monad, which you're then feeding into repeatedly, but repeatedly needs a computation.
10:57:36 <davidhouse> @pl f >> g f
10:57:36 <lambdabot> f >> g f
10:57:38 <ibid> davidhouse: i know
10:57:47 <davidhouse> poor effort, lambdabot.
10:58:11 <ihope> davidhouse: what was it supposed to do?
10:58:37 <ibid> davidhouse: can you do better? :)
10:58:39 <davidhouse> actually, you're right, that is actually points-free.
10:58:50 <davidhouse> i was expecting something like:
10:59:02 <davidhouse> @pl \f g h x -> f (g x) (h x)
10:59:03 <lambdabot> liftM2
10:59:11 <davidhouse> oh. err...
10:59:15 <ihope> Hmm...
10:59:16 <ibid> :)
10:59:23 <davidhouse> @pl \f g x y -> f (g x) (g y)
10:59:24 <lambdabot> join . ((flip . ((.) .)) .) . (.)
10:59:27 <davidhouse> that's the one
10:59:34 <ihope> @pl \f g -> f >> g f
10:59:35 <lambdabot> liftM2 (.) (>>) (flip id)
10:59:46 <ihope> That's nice.
10:59:59 <ibid> for some values of nice
11:00:10 <ihope> That's /bin/nice
11:00:24 <davidhouse> why on earth is it flipping id?
11:00:34 <ihope> s/id/($)/
11:00:47 <ibid> > flip id 4
11:00:48 <lambdabot>  add an instance declaration for (Show ((b -> c) -> c))
11:01:08 <ibid> > flip id const
11:01:08 <lambdabot>  add an instance declaration for (Show (((a -> b -> a) -> c) -> c))
11:01:12 <ibid> > flip id
11:01:13 <lambdabot>  add an instance declaration for (Show (b -> (b -> c) -> c))
11:01:13 <ihope> > flip id 4 id
11:01:13 <lambdabot> 4
11:01:18 <ibid> ahh
11:01:20 <bolrod> :)
11:01:25 <ihope> @pl \x -> flip id x id
11:01:25 <lambdabot> id
11:01:34 <ihope> Heh.
11:01:35 <Saulzar> Wow, I was typing the same thing in ghci - and I used the number 4 as well :)
11:01:44 <ihope> Whoa@
11:02:00 <ibid> perhaps because of my use of 4 a little earlier?
11:02:10 <Saulzar> Ah, didn't notice that - probably
11:02:12 <davidhouse> > id 4
11:02:12 <ihope> @pl \(x:xs) -> (\[] -> 3) xs
11:02:13 <lambdabot> 4
11:02:13 <lambdabot> (line 1, column 14):
11:02:13 <lambdabot> unexpected "["
11:02:13 <lambdabot> expecting pattern
11:02:17 <davidhouse> > flip id 4
11:02:17 <ihope> Ow ow ow
11:02:18 <lambdabot>  add an instance declaration for (Show ((b -> c) -> c))
11:02:22 <davidhouse> > flip id $ 4
11:02:23 <lambdabot>  add an instance declaration for (Show ((a -> c) -> c))
11:02:33 <davidhouse> @type flip id
11:02:34 <lambdabot> forall b c. b -> (b -> c) -> c
11:02:43 <davidhouse> oh, okay.
11:02:45 <bolrod> > flip id id id 4
11:02:46 <lambdabot> 4
11:02:54 <ihope> @pl flip id id id
11:02:54 <lambdabot> id
11:02:56 <ibid> @type flip ($)
11:02:57 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
11:03:00 <ihope> @pl flip flip id
11:03:01 <lambdabot> flip flip id
11:03:04 <ihope> Aww.
11:03:23 <ibid> @type flip flip
11:03:24 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
11:03:27 <ihope> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
11:03:27 <lambdabot> ap (. join id) (. join id)
11:03:35 <ihope> Woot.
11:03:57 <ihope> Unfortunately, join id is a type error.
11:03:58 <davidhouse> @type ap -- haven't actually seen this in use yet
11:03:59 <lambdabot> Not in scope: `ap'
11:04:05 <davidhouse> @type Control.Monad.ap
11:04:06 <lambdabot> forall b (m :: * -> *) a.
11:04:06 <lambdabot>        (Monad m) =>
11:04:06 <lambdabot>        m (a -> b) -> m a -> m b
11:04:07 <Saulzar> @type join id
11:04:08 <lambdabot> Not in scope: `join'
11:04:14 <Saulzar> @type Control.Monad.join id
11:04:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
11:04:15 <lambdabot>   Expected type: a -> a -> a1
11:04:19 <ihope> @type Control.Monad.Reader.ap :: (a -> b -> c) -> (a -> b) -> a -> c
11:04:20 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c :: forall a
11:04:20 <lambdabot>                          b
11:04:20 <lambdabot>                          c.
11:04:20 <lambdabot>                       (a -> b -> c)
11:04:20 <lambdabot>                       -> (a -> b)
11:04:22 <lambdabot>                       -> a
11:04:24 <lambdabot>                       -> c
11:04:25 <davidhouse> @hoogle m (a -> b)
11:04:25 <lambdabot> Prelude.undefined :: a
11:04:28 <lambdabot> Test.QuickCheck.Batch.bottom :: a
11:04:30 <lambdabot> Prelude.id :: a -> a
11:04:41 <ihope> Hmm...
11:04:44 <davidhouse> right. so ap seems singularily useless.
11:05:03 <Saulzar> ap is useful
11:05:09 <ihope> davidhouse: it's the s combinator.
11:05:16 <ihope> The s combinator is useful-ish.
11:05:24 <palomer> grr
11:05:25 <ihope> > Test.QuickCheck.Batch.botton :: ()
11:05:26 <lambdabot>  Not in scope: `Test.QuickCheck.Batch.botton'
11:05:29 <palomer> anyone living on the east coast?
11:05:32 <ihope> > Test.QuickCheck.Batch.bottom :: ()
11:05:33 <lambdabot>  Not in scope: `Test.QuickCheck.Batch.bottom'
11:05:37 <davidhouse> you use ap instead of lifting?
11:05:38 <twb> palomer: the east coast of what?
11:05:46 <ibid> > Just id `ap` 3
11:05:47 <palomer> canada/states
11:05:47 <lambdabot>  add an instance declaration for (Num (Maybe a))
11:05:49 <ihope> palomer: is the midwest good enough?
11:05:50 <davidhouse> > liftM id 4 :: Just Int
11:05:51 <lambdabot>  Not in scope: type constructor or class `Just'
11:05:54 <palomer> no
11:05:55 <davidhouse> > liftM id 4 :: Maybe Int
11:05:56 <ibid> > Just id `ap` (3::Int)
11:05:56 <lambdabot>  add an instance declaration for (Num (Maybe Int))
11:05:56 <lambdabot> Couldn't match `Maybe a' against `Int'
11:06:01 <Saulzar> > [(+2), (+7)] `ap` [1, 2, 3, 4]
11:06:02 <lambdabot> [3,4,5,6,8,9,10,11]
11:06:11 <ibid> > Just id `ap` Just (3::Int)
11:06:12 <lambdabot> Just 3
11:06:23 <ihope> It's chaos!
11:06:24 <palomer> everyone says it's 2pm
11:06:26 <palomer> except my clock
11:06:36 <ihope> Well, it's 2PM here.
11:06:44 <ibid> it's 9pm here
11:06:45 <ihope> What time zone are you in?
11:06:49 <palomer> eastern
11:06:59 <shapr> It's 20:00 here.
11:06:59 <ihope> @localtime palomer
11:07:00 * ibid too
11:07:02 <Saulzar> It's 6am
11:07:03 <lambdabot> Local time for palomer is Tue Apr  4 13:06:00
11:07:07 <ibid> (eastern europe)
11:07:11 <shapr> Saulzar: Why the heck are you awake?
11:07:18 <shapr> @timein saulzar
11:07:18 <ihope> Daylight saving thingy, I think.
11:07:35 <ibid> @localtime ibid
11:07:35 <palomer> gah!
11:07:36 <Saulzar> shapr, I'm about to sleep, but usually I work from 12-6 :)
11:07:39 <lambdabot> Local time for ibid is Mon Apr  3 21:07:14 2006
11:07:39 <ihope> Clocks must go forward :-)
11:08:15 <davidhouse> > return (+3) `ap` [4]
11:08:15 <shapr> Saulzar: Oh, I see.
11:08:16 <lambdabot> [7]
11:08:22 <davidhouse> > liftM (+3) [4]
11:08:23 <lambdabot> [7]
11:08:47 <ihope> @hoogle m (a -> b) -> a -> m b
11:08:48 <lambdabot> Prelude.asTypeOf :: a -> a -> a
11:08:48 <lambdabot> Prelude.const :: a -> b -> a
11:08:48 <lambdabot> Prelude.seq :: a -> b -> b
11:08:52 <ihope> Ow.
11:08:59 <davidhouse> > return (+) `ap` [4] `ap` [7]
11:09:00 <lambdabot> [11]
11:09:10 <davidhouse> > liftM2 (+) [4] [7]
11:09:11 <lambdabot> [11]
11:09:28 <davidhouse> @index liftM3
11:09:28 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:09:29 <ihope> @type (>>= ($ "hello"))
11:09:30 <lambdabot> forall (m :: * -> *) b.
11:09:30 <lambdabot>        (Monad m) =>
11:09:30 <lambdabot>        m ([Char] -> m b) -> m b
11:09:38 <ihope> Not right.
11:10:26 <davidhouse> > (>>= ($ "hello")) $ Just (++" world")
11:10:26 <lambdabot> Couldn't match `Maybe b' against `[Char]'
11:10:30 <ihope> @pl \f x -> ap f (return x)
11:10:30 <Saulzar> Hmm, as someone said somewhere, `ap` is like generalised lifM
11:10:30 <lambdabot> (. return) . ap
11:10:35 <bolrod> let table = (\n n' -> foldl (\l r -> (succ l) + r) 0 (take n'(map (\x -> x (n-1)) (repeat id)))) in table 10 10
11:10:35 <bolrod> > let table = (\n n' -> foldl (\l r -> (succ l) + r) 0 (take n'(map (\x -> x (n-1)) (repeat id)))) in table 10 10
11:10:35 <bolrod> how usefull can it be
11:10:35 <bolrod_> hrm
11:10:36 <lambdabot> 100
11:10:49 <bolrod> hahaha
11:10:52 <ihope> @type (. return) . Control.Monad.ap
11:10:53 <lambdabot> forall (m :: * -> *) a b.
11:10:53 <lambdabot>            (Monad m) =>
11:10:53 <lambdabot>            m (a -> b) -> a -> m b
11:10:57 <ihope> Yay!
11:11:00 <shapr> salut kowey 
11:11:06 <davidhouse> > (>>= ($ "hello")) $ Just $ Just . (++" world")
11:11:07 <lambdabot> Just "hello world"
11:11:10 <kowey> heya shapr, all
11:11:22 <kowey> ihope: is that you, ihope127 on wikibooks?
11:11:28 <ihope> Aye.
11:11:53 <kowey> hmm... do you think we could keep dollar and euro on the book?
11:12:06 <kowey> i realise that ? isn't haskell
11:12:09 <ihope> What's wrong with $ and |>?
11:12:41 <kowey> well, when understanding how |> works, it's handy to think of it as backwards dollar
11:13:02 <ihope> Maybe $>?
11:13:04 <kowey> which is why i present it as the euro, sort of the "opposite" of the dollar
11:13:09 <resiak> £!
11:13:16 <kowey> in some entertaingly illogical sense
11:13:19 <flux__> :-)
11:13:50 <davidhouse> > let () = (+) in 4  5
11:13:51 <lambdabot>  lexical error
11:13:52 <flux__> do you ever expect to find a person who responds to that.. "yes.. it's perfectly logical!"
11:13:55 <davidhouse> boo!
11:13:56 <kowey> so basically, i like 'euro' because it has a certain playfulness to it... what do you think?
11:14:08 <ihope> Hmm...
11:14:43 * ihope attempts to find another currency symbol in ASCII
11:15:04 <jyp> Is 'euro' typeable? and is it accepted by ghc?
11:15:12 <jyp> (as an operator)
11:15:18 <kowey> last time i tried, no
11:15:23 <ihope> @type `\x y -> y x`
11:15:23 <lambdabot> parse error on input ``'
11:15:27 <ihope> Woot.
11:15:45 <ihope> > ^_^:-(:-)
11:15:46 <lambdabot>  parse error on input `^'
11:15:47 <kowey> but the thing is that euro has a lot of recognisability, the 'joke' wouldn't work as well with, like Yen or Pound
11:15:53 <kowey> imho
11:16:06 <ihope> Okay... the Euro it is.
11:16:11 <jyp> I'd avoid incorrect haskell if possible.
11:16:28 <kowey> hmm... that is true
11:16:29 <kosmikus> I don't think it works at all. sorry, I'm just not a funny person, I guess.
11:16:41 * kowey hopes that ghc will support euro one day
11:16:58 <Ulfalizer> @type 5
11:16:59 <lambdabot> forall t. (Num t) => t
11:17:07 <twb> Maybe it would help if you used UTF-8
11:17:46 <mux> > [1..]
11:17:52 <mux> oops.
11:17:52 * ihope laughs
11:18:04 <mux> I honestly thought there was some kind of protection for this, sorry :-)
11:18:12 <ihope> There was.
11:18:24 <ihope> But it... poofed.
11:18:24 <davidhouse> normally it just prints about a lines' worth
11:18:35 <davidhouse> but i guess people have been spamming so much it reached its quota :)
11:18:41 * ihope stops killing lambdabot
11:18:53 <bolrod> ...
11:18:57 <bolrod> you'd better >:/
11:19:08 <twb> > [..0]
11:19:08 <lambdabot>  parse error on input `..'
11:19:12 <ihope> Um... that was just to make sure that caused it! Really!
11:19:13 <twb> Bah.
11:19:17 <Saulzar> @slap ipod
11:19:18 * lambdabot slaps ipod
11:19:30 <bolrod> @slap Saulzar 
11:19:31 <lambdabot> why on earth would I slap Saulzar
11:19:39 <bolrod> because he slapped ipod?!?!
11:19:41 <twb> > let ɣ = 4 in ɣ
11:19:42 <lambdabot>  lexical error
11:19:45 <twb> Aw.
11:19:50 <Saulzar> Bwhaha.
11:19:50 <sjanssen> @slap lambdabot
11:19:50 <ihope> @slap Saulzar because he slapped ipod
11:19:50 * lambdabot slaps lambdabot
11:19:51 * lambdabot smacks Saulzar because he slapped ipod about with a large trout
11:19:52 <osqulda> what is the average time complexity of Data.Array.// ?
11:20:02 <kowey> thanks, ihope, i have changed it back and recommended that the user use (|>) if she wanted to try it at home
11:20:06 <twb> > ɮ = 4
11:20:06 <lambdabot>  lexical error
11:20:08 <osqulda> linear in the size of the array?
11:20:11 <sjanssen> osqulda: always linear
11:20:15 <ihope> @remember lambdabot 
11:20:15 <lambdabot> Incorrect arguments to quote
11:20:17 <ihope> Oops.
11:20:17 <sjanssen> unless you use DiffArray
11:20:35 <osqulda> Data.Array.DiffArray.// then, sjanssen?
11:20:38 <Saulzar> ihope, Is it slapping me with a large trout or because of slapping with a large trout? :)
11:20:45 <osqulda> this seems stupid - cannot GHC just optimise Array ?
11:20:56 <bolrod> >let isPrime = \n -> null $ filter (\is -> is/=n && is/=1) $ map (gcd n) [1..n] in filter (isPrime) [1..]!!1000000000
11:21:00 <bolrod> > let isPrime = \n -> null $ filter (\is -> is/=n && is/=1) $ map (gcd n) [1..n] in filter (isPrime) [1..]!!1000000000
11:21:04 <lambdabot> Terminated
11:21:04 <bolrod> :x
11:21:06 <sjanssen> osqulda: linear w.r.t. the number of elements that you are replacing
11:21:06 <bolrod> awh
11:21:19 <osqulda> sjannsen, argh
11:21:36 <bolrod> whats the time limit of a computation
11:21:50 <ihope> > let isPrime = \n -> null $ filter (\is -> is/=n && is/=1) $ map (gcd n) [1..n] in take 10 filter (isPrime) [1..]
11:21:50 <lambdabot> Couldn't match `[a]' against `t -> t1 -> t2'
11:21:55 <osqulda> so updating an element in an array is constant...
11:21:55 <sjanssen> osqulda: but only if you use the array in a single threaded way.  ie don't use // on an array that has already been //'ed
11:21:59 <ihope> > let isPrime = \n -> null $ filter (\is -> is/=n && is/=1) $ map (gcd n) [1..n] in take 10 (filter (isPrime) [1..]) -- Typo, not mistake
11:22:00 <lambdabot> [1,2,3,5,7,11,13,17,19,23]
11:22:05 <bolrod> > let isPrime = \n -> null $ filter (\is -> is/=n && is/=1) $ map (gcd n) [1..n] in filter (isPrime) [1..100]
11:22:06 <lambdabot> [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
11:22:08 <ihope> Yay, 1 is prime.
11:22:14 <bolrod> hrm
11:22:19 <sjanssen> osqulda: yes with DiffArray and a certain usage pattern
11:22:29 <twb> Whee, code that works in ghci but not hugs.
11:22:38 <twb> *** Type           : Integer
11:22:38 <twb> *** Does not match : Word64
11:22:47 <bolrod> haha
11:22:52 <osqulda> you did _not_ say Array is linear in the size of the list of associations?
11:23:07 <osqulda> You said DiffArray is?
11:23:15 <sjanssen> osqulda: yes
11:23:18 <osqulda> good.
11:23:21 <osqulda> that I can accept ;-)
11:23:24 <osqulda> excellent
11:23:25 <osqulda> bye
11:24:10 <sjanssen> was osqulda offended that immutable arrays don't have constant update?
11:24:18 <ihope> > let pt x = all (\y -> x `mod` y /= 0) (takeWhile (<= x*x) pl); pl = 2 : filter pt [3..] in take 30 pl
11:24:19 <lambdabot> Exception: <<loop>>
11:24:23 <ihope> Ow.
11:24:34 <ihope> > let pt x = all (\y -> x `mod` y /= 0) (takeWhile (<= x*x) pl); pl = 2 : 3 : filter pt [5..] in take 30 pl
11:24:35 <lambdabot> Exception: <<loop>>
11:24:36 <Ulfalizer> heh, osqulda would be a pretty weird name in sweden. "oskuld" is swedish for "virgin".
11:24:59 <Ulfalizer> oh, he was a swede.. :)
11:25:18 <bolrod> ls
11:25:19 <bolrod> oops
11:25:28 <ihope> rm -rf /
11:25:33 <bolrod> ;p
11:25:40 <Ulfalizer> knew someone'd write that..
11:25:53 <ihope> rm -rif /
11:25:54 <bolrod> dd if=/dev/random of=/dev/hda
11:26:06 <bolrod> rm -rvf /  is more exciting
11:26:13 <ihope> What's v?
11:26:13 <twb> What's bitwise inclusive or called in Haskell?
11:26:18 <bolrod> >:)
11:26:22 <ihope> Or, rather, -v
11:26:29 <ibid> erbose?
11:26:30 <jyp> .|.
11:26:31 <ibid> +v
11:26:37 <twb> jyp: for me?
11:26:42 <Ulfalizer> find / -exec rm {};
11:26:44 <jyp> yup :)
11:26:48 <ibid> jyp: that's almost obscene ;)
11:26:49 <bolrod>   -v, --verbose         explain what is being done
11:26:52 <ihope> > let pt x = all (\y -> (x `mod` y) /= 0) (takeWhile (<= x*x) pl); pl = 2 : filter pt [3..] in take 30 pl
11:26:53 <lambdabot> Exception: <<loop>>
11:26:55 <twb> jyp: that's disgusting.
11:27:15 <pesco> twb: Define your own.
11:27:16 <jyp> > 3 .|. 5
11:27:17 <lambdabot> Add a type signature
11:27:22 <jyp> > 3 .|. 5::Int
11:27:23 <ibid> ihope: pt requires the whole pl list before it returns anything, as i can tell
11:27:23 <lambdabot> 7
11:27:44 <ihope> ibid: what's wrong with that takeWhile?
11:27:50 <ihope> Oh...
11:27:56 <ihope> ...wait...
11:28:03 <ibid> ihope: "all" is the problem methinks
11:28:19 <ihope> > let pt x = any (\y -> (x `mod` y) /= 0) (takeWhile (<= x*x) pl); pl = 2 : filter pt [3..] in take 30 pl
11:28:20 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]
11:28:27 <bolrod> wow
11:28:33 <bolrod> > [2..31]
11:28:34 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]
11:28:36 <bolrod> :)
11:28:51 <ihope> Well, I don't get it.
11:29:51 <ibid> ihope: takeWhile (<=9) is required before pl gets to 4 in the all version
11:30:03 <ibid> ihope: so to produce the 4 you are requiring the 4
11:30:08 <ibid> i think...
11:30:14 <twb> Oh fuck, I am stuck.
11:30:15 <ibid> or something similar :)
11:30:18 <bolrod> let argh = filter (\a -> a =='\108' || a=='\111') ['\NUL','\SOH'..'\127'] in delete '\111'.concat $[argh,reverse argh]
11:30:20 <ihope> Oh, I see the problem.
11:30:22 <bolrod> > let argh = filter (\a -> a =='\108' || a=='\111') ['\NUL','\SOH'..'\127'] in delete '\111'.concat $[argh,reverse argh]
11:30:22 <lambdabot> "lol"
11:30:37 <ihope> > let pt x = all (\y -> x `mod` y /= 0) (takeWhile (\y -> x <= y*y) pl); pl = 2 : filter pt [3..] in take 30 pl
11:30:39 <lambdabot> Exception: <<loop>>
11:30:40 <bolrod> what does it need to do ;)
11:30:44 <jyp> We need a #ghci channel
11:30:53 <jyp> or #haskell-eval
11:30:54 <bolrod> write simple code =)
11:30:57 <jyp> :p
11:31:03 <mwc> our you can just pm lambdabot
11:31:05 <twb> tinywm.c has state that it sets during one pass and gets in a later pass through the loop.
11:31:10 <ihope> Bing! ##ghci is now open.
11:31:15 <ibid> or you can just use ghci :)
11:31:38 <bolrod> yeah
11:31:52 <ibid> of course, on this channel people can help you
11:31:53 <twb> How do you create a closure in Haskell?
11:32:00 <mauke> heh
11:32:02 <bolrod> @join ##ghci
11:32:02 <lambdabot> Not enough privileges
11:32:05 <ihope> twb: a whatnow?
11:32:05 <bolrod> bah!
11:32:23 <ibid> twb: a closure is just a function
11:32:31 <jyp> twb: (\x -> f x)
11:32:41 <twb> OK, but one I can get/set state.
11:32:47 <wchogg> When I think closure, I think about it having state as well.  You need IORef
11:32:48 <twb> Like a makeAdder function.
11:32:48 <ibid> twb: you can't
11:32:50 <mauke> you can't set state
11:32:56 <jyp> There is no state!
11:33:06 <ibid> twb: you could use IORefs
11:33:13 <mauke> twb: what's the type of makeAdder?
11:33:13 * pesco slaps his Scheme book.
11:33:23 <pesco> Will you stop putting those ideas in people's heads!
11:33:27 <twb> mauke: see SICP ;-)
11:33:37 <ibid> twb: but the usual impure functional programming tricks with mutable closures aren't applicable in haskell
11:33:45 <twb> ibid: exactly.
11:33:51 <twb> ibid: that's why I have to ask :-)
11:34:03 <ibid> twb: remind me what adder does
11:34:14 <ibid> makeAdder, rather
11:34:18 <twb> (define adder1 (makeadder))
11:34:22 <twb> (adder1) ==> 1
11:34:25 <twb> (adder1) ==> 2
11:34:28 <ibid> ok
11:34:49 <ibid> you can close over an IORef, i think
11:34:53 <ibid> something like this:
11:35:13 <twb> (define (makeadder) (let ((x 1)) (lambda () (set! x (+ x 1)) x)))
11:35:56 <twb> Probably that first 1 should be a 0.
11:36:17 <ibid> > let makeAdder = do r <- newIORef 0 ; let { g = do n <- readIORef r ; writeIORef (r+1) ; return n } ; return g
11:36:18 <lambdabot>  parse error on input `}'
11:36:30 <ibid> > let makeAdder = do r <- newIORef 0 ; let g = do { n <- readIORef r ; writeIORef (r+1) ; return n } ; return g
11:36:30 <lambdabot>  parse error (possibly incorrect indentation)
11:36:44 <bolrod> eh
11:36:53 <ibid> > let makeAdder = do r <- newIORef 0 ; let g = do { n <- readIORef r ; writeIORef (r+1) ; return n } ; return g in makeAdde
11:36:53 <lambdabot>  parse error on input `in'
11:36:56 <ibid> > let makeAdder = do r <- newIORef 0 ; let g = do { n <- readIORef r ; writeIORef (r+1) ; return n } ; return g in makeAdder
11:36:57 <lambdabot>  parse error on input `in'
11:36:57 <bolrod> ;)
11:37:11 <ibid> > let makeAdder = do { r <- newIORef 0 ; let g = do { n <- readIORef r ; writeIORef (r+1) ; return n } ; return g } in makeAdder
11:37:12 <lambdabot>  parse error on input `}'
11:37:16 <ibid> hrm
11:37:38 <sjanssen> ibid: don't bother sending that code to lambdabot, no IO allowed
11:37:46 <bolrod> > putStrLn "test"
11:37:47 <lambdabot> No IO allowed
11:37:48 <bolrod> ;)
11:38:00 <ibid> sjanssen: :)
11:38:26 <bolrod> sjanssen: maybe we should have waited some 5 more minutes ;)
11:38:29 <bolrod> :x
11:38:30 <ihope> Why not "add an instance declaration for (Show (IO a))"?
11:38:52 <kosmikus> ?
11:38:56 <bolrod> O_o?
11:38:57 <bolrod> dude
11:39:12 <jyp> > show (putStrLn "test")
11:39:13 <lambdabot> No IO allowed
11:39:16 <sjanssen> ihope: this way unsafePerformIO is not allowed also
11:39:26 <jyp> that's even stranger
11:39:38 <bolrod> nah
11:39:48 <bolrod> > show [putStrLn "test"]
11:39:49 <lambdabot> No IO allowed
11:39:52 <bolrod> hmmm
11:39:56 <kosmikus> it's not allowed. this is different from not being possible.
11:40:11 <ihope> > show getChar
11:40:12 <lambdabot> No IO allowed
11:40:14 <ihope> Weird.
11:40:15 <bolrod> imagine the security risks ;)
11:40:19 <jyp> But we don't try to do IO
11:40:28 <shapr> Look at the logs for the security breaks :-)
11:40:34 <bolrod> yeah
11:40:42 <ihope> (error . error) "\r\nQUIT"
11:40:44 <bolrod> after like.. 10 people tried to delete the initrd etc.
11:40:48 <ibid> twb: makeAdder = do { r <- newIORef 0 ; return $ do { n <- readIORef r ; writeIORef r (n+1) ; return n } }
11:40:50 <shapr> TheHunter grabbed the contents of /etc/passwd and pasted it to the channel before "No IO allowed"
11:40:59 <ihope> bolrod: what happened?
11:41:05 <araujo> hiya!
11:41:16 <bolrod> I dont know.. I'm just making things up ;)
11:41:26 <bolrod> but I'd imagine you could probably try to do that with IO allowed
11:41:36 <ibid> twb: does that help?
11:41:42 <twb> ibid: looking now...
11:41:42 <bolrod> or browse through /etc/
11:41:58 <ihope> So what's in /etc/passwd?
11:42:02 <bolrod> erh
11:42:06 <twb> Grr.
11:42:09 <bolrod> all the passwords if you dont use shadow passwords?
11:42:11 <twb> @index newIORef
11:42:12 <lambdabot> Data.IORef
11:42:12 <ibid> twb: adder <- makeAdder ; adder ; adder ; adder ...
11:42:12 <sjanssen> ihope: in modern systems, just usernames
11:42:25 <ibid> ... and shells
11:42:28 <ibid> ... and real names
11:42:31 <ihope> So some hashes of the passwords are in /etc/shadow, aye?
11:42:33 <ibid> ... and home dir names :)
11:42:41 <sjanssen> right, but those aren't usually scandalous
11:42:48 <sjanssen> ihope: yes
11:42:49 <ibid> y
11:43:43 <flux__> in any case, it could just as easily fill /tmp etc
11:43:56 <twb> ibid: Hmm, where does the number go?
11:43:57 <flux__> or launch a dos
11:43:58 <bolrod> you could do IO possibly.. if you run the lambdabot in chroot
11:44:01 <ibid> or try a local exploit
11:44:06 <ibid> twb: it's returned
11:44:14 <sjanssen> bolrod: it really isn't worth it though
11:44:18 <bolrod> indeed
11:44:24 <twb> The REPL isn't printing it.
11:44:31 <ibid> twb: of course not
11:44:35 <sieni> cool it works
11:44:36 <flux__> there could be an IO emulator ;)
11:44:37 <ibid> twb: use adder >>= print
11:44:45 <Ulfalizer> why not run it in a virtual machine?
11:44:50 <twb> ibid: thanks.
11:44:53 <Ulfalizer> disclaimer: i haven't followed the discussion closely
11:45:03 <bolrod> virtual machines take up alot of RAM?
11:45:09 <bolrod> for something that isn't really usefull anyway
11:45:11 <ihope> adder <- let makeAdder = do {r <- newIORef 0 ; let g = do { b <- readIORef r ; writeIORef r (b+1) ; return b} ; return g} in makeAdder -- what's wrong with this?
11:45:14 <sieni> twb: do { f <- makeAdder; n <- f; m <- f; putStrLn (show n); putStrLn (show m);}
11:45:23 <flux__> systrace could be used to limit the actual IO capabilities
11:45:38 <bolrod> you could also just install the ghci
11:45:41 <flux__> (I'm assuming linux, but I believe other operating systems have similar facilities)
11:45:42 <bolrod> and try it out on your own comptuer
11:45:48 <flux__> hmm.. an interesting concept..
11:45:52 <bolrod> @version
11:45:53 <lambdabot> lambdabot 3p396, GHC 6.4.1 (Linux i686 3.20GHz)
11:45:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:45:53 <sieni> twb: that prints out 0 and 1
11:46:02 <flux__> but this way you get to waste other people's resources
11:46:08 <ibid> flux__: it's safer to allow things that are allowed than to disallow things that are not allowed
11:46:19 <bolrod> ?
11:46:26 <bolrod> yes
11:46:29 <bolrod> and easier
11:46:30 <flux__> ibid, well, you can still do that even with systrace?
11:46:35 <ibid> flux__: can you?
11:46:55 <flux__> systrace is like iptables for system calls
11:47:15 <sjanssen> flux__: if we allowed IO, people could still do a forkbomb for example
11:47:21 <flux__> I'd imagine you can set default policy to be deny
11:47:25 <flux__> sjanssen, yes, if you allow forking ;)
11:47:46 <Ulfalizer> oh, you were talking about I/O.. it doesn't sound that useful
11:47:48 <bolrod> so what kind of IO would you want?
11:47:58 <bolrod> just print things to the channel?
11:48:09 <flux__> I personally don't want any, I'm just arguing that it could be done in a safe fashion ;)
11:48:16 <bolrod> yes
11:48:26 <bolrod> I have a good, simple and easy solution
11:48:36 <bolrod> just let people perform IO on their own computer
11:48:38 <bolrod> ;)
11:48:43 <liyang> Write an alternative IO monad.
11:49:29 <sjanssen> yeah, we could provide alternatives to IO functions, and just make the real ones out of scope somehow
11:49:45 <flux__> I guess that'd be a lot of work
11:50:25 <ibid> not necessarily
11:50:51 <sjanssen> flux__: I'd rather do that then a bunch of platform dependent systrace wizardry
11:50:52 <bolrod> just ripp the IO functions out of the prelude?
11:51:51 <flux__> an actual in-haskell sandboxing facility could be useful in other situations too, maybe
11:52:01 <bolrod> but most IO functions are useless anyway
11:52:13 <bolrod> (in the channel)
11:52:36 <flux__> you could write one-liners that would use temporary files ;)
11:53:13 <sieni> and anyway it might be hard to distinguish valid system calls caused by the haskell runtime and those caused by the IO monad to be filtered
11:54:28 <bolrod> whats the opposite of succ
11:54:33 <ihope> pred
11:54:43 <mauke> rocc
11:55:06 <bolrod> thx
11:55:41 <ihope> data IO a where Return :: a -> IO a; :>>= :: IO a -> (a -> IO b) -> IO b; GetLine :: IO String; GetChar :: IO Char; PutStr :: String -> IO ()
11:56:20 <ibid> no need to use getline etc, those can be defined in terms of getchar :)
11:56:27 <ibid> ..etc
11:56:45 <sjanssen> ihope: you really like GADTs, don't you?
11:56:55 <ihope> sjanssen: yep
11:57:14 <ihope> After all, my factorial function uses GADT's...
11:57:38 <ihope> By the way, I should probably finish it sometime :-P
11:59:11 <ibid> wow, a factorial function that doesn't get finished on the same sitting
11:59:15 <ibid> that takes some doing
12:05:50 <twb> ibid: ha ha!
12:06:35 <twb> ibid: btw, http://twb.ath.cx/~twb/doc/fp.html (shiny!)
12:12:29 <twb> Haskell doesn't have EVAL, right?
12:13:17 <jyp> How do you think lambdabot works ? :)
12:13:48 <twb> Magic.
12:13:53 <twb> @index eval
12:13:54 <lambdabot> bzzt
12:14:04 <jyp> That's right! Haskell doesn't have eval :)
12:14:04 <kosmikus> no, there is no eval ...
12:14:20 <ihope> @eval 3+2
12:14:21 <lambdabot> 5
12:14:24 * jyp laughs
12:14:40 <boy> hs-plugins library contains eval for haskell
12:16:56 <twb> Hmm, dpkg -S doesn't find it.
12:17:11 <jyp> @where hs-plugins
12:17:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
12:17:49 <twb> libghc6-plugins-dev ?
12:18:05 <twb> Yeah.
12:19:41 <twb> If and when hot, steamy window manager action happens, I'll want REPLosity in order to allow users to define functions and add them to event hooks.
12:20:54 * twb suddenly realizes why "aptitude -t dapper install foo" hasn't been working.
12:22:29 <sieni> twb: I guess you can us hs-plugins for that. There are some limitations what can be done with a repl in a statically typed functional language
12:25:22 <sieni> twb: see http://www.haskell.org/tutorial/pitfalls.html for example
12:27:59 <twb> If all else fails, I simply deliver the bulk of the code as an image, and require the users to have ghci / hugs installed.
12:28:04 <twb> That's how StumpWM does it.
12:29:13 <ihope> Hmm...
12:29:34 <ihope> "Hello, world!" -> "lor"
12:29:56 <ihope> Yeah...
12:30:03 <twb> ihope: ?
12:30:44 <ihope> "The quick brown fox jumps over the lazy dog." -> "Ekroxsveyg".
12:32:49 <fons> hi!
12:33:01 <twb> fons: lies!
12:35:20 <ihope> @hi!
12:35:27 <ihope> @bot
12:35:28 <lambdabot> :)
12:35:31 <ihope> Hmm.
12:35:38 <ihope> @hi
12:35:46 <ihope> @fons: lies!
12:35:46 <lambdabot> Unknown command, try @list
12:40:02 <itsjusthim>  has to go NOW! 2 alienware laptops price 450 includes sameday shipping, case, wireless router. Message me if interested on aim at ogd443 or yahoo at thishastogotoday or msn at albertaguy1981@hotmail.com
12:41:39 <jyp> @slap itsjusthim 
12:41:40 <lambdabot> why on earth would I slap itsjusthim
12:42:00 <jyp> @kick itsjusthim 
12:42:00 <lambdabot> Maybe you meant: dice dict kind
12:42:13 <jyp> @headbutt itsjusthim 
12:42:14 <lambdabot> Unknown command, try @list
12:42:24 <twb> It upsets me to infer that such antisocial behaviours are profitable.
12:42:48 <jyp> Like, headbutting people ? :p
12:42:53 <twb> No, spamming.
12:42:56 <nothing_pasta> jyp: there are people to report this to
12:43:01 <nothing_pasta> which deal with said spammer very effectively
12:43:05 <nothing_pasta> i just don't know who they are
12:43:11 <nothing_pasta> maybe there's a freenode meta channel?
12:43:11 <tibbe> could someone tell me why dependent types matter and how they relate to GADTs?
12:43:21 <twb> #freenode or lilo, probably.
12:43:29 <jyp> @google why dependent types matter
12:43:31 <lambdabot> http://www.dcs.st-andrews.ac.uk/~james/RESEARCH/ydtm-submitted.pdf
12:44:05 <jyp> tibbe: a somewhat harsh read though
12:44:07 <tibbe> jyp, I actually read most of that paper and the author didn't really explain why bother
12:44:17 <jyp> yup
12:44:21 <twb> jyp: compared to what, Olin?
12:44:38 <tibbe> we can express sizes, lists/nil but at quite a cost
12:44:39 <jyp> Tim Sheard has written something better
12:44:45 <jyp> wait a minute...
12:44:57 <twb> jyp: I meant the harshness.
12:45:10 * jyp goes through piles of papers
12:45:22 <jyp> @google putting curry-howard to work
12:45:24 <lambdabot> http://lambda-the-ultimate.org/node/1115
12:45:29 <tibbe> that's the one?
12:45:36 <jyp> yup
12:45:40 <jyp> one click away
12:45:40 <tibbe> thanks
12:46:17 * jyp tips his hat
12:47:06 <twb> jyp: over who?
12:47:26 <twb> Cleaning up an upended hat is always a messy business.
12:47:53 * jyp laughs
12:48:13 * twb bows
12:48:33 <twb> But I don't expect you to like the sound of a violin.
12:48:48 <kosmikus> interestingly, I found the first of the two papers an easier read and better motivated than the second, but maybe I'm just not remembering correctly anymore.
12:49:20 <twb> If I had a grant, I could sit around reading papers all day.
12:49:58 <jyp> kosmikus: which one ?
12:50:12 <twb> > 2 .|. 3
12:50:12 <lambdabot> Add a type signature
12:50:44 <jyp> > #3
12:50:45 <lambdabot>  lexical error
12:50:47 <jyp> > 3#
12:50:48 <lambdabot>  parse error on input `}'
12:51:03 <fons> I'm trying to do an exercise from Birds book and I don't find a good solution, could anyone try to help me?
12:51:13 <twb> @hoogle IO a -> IO ()
12:51:14 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
12:51:14 <lambdabot> Foreign.C.Error.throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
12:51:14 <lambdabot> Foreign.C.Error.throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
12:51:20 <twb> Not helpful.
12:51:36 <fons> the problem is to redifine a function using splitAt
12:51:43 <fons> redefine
12:51:53 <fons> but I don't find a good way to do it
12:52:03 <fons> the function to redefine is
12:52:28 <tibbe> jyp, so what's the relation to GADTs?
12:52:49 <fons> divide = foldr allocate ([].[]) where allocate x  (ys,zs) = (zs,x:ys)
12:53:37 <fons> divide simply allocates each element of the input list to one of the two lists in strcit allocation
12:54:20 <jyp> tibbe: Type indexed arguments to GADTs allow us to ensure static properties of data structures.
12:54:29 <fons> I have to redefine divide using splitAt
12:54:33 * jyp copies 1st sentence of section 5 :p
12:55:23 <jyp> David Roundy gave an interesting talk on how he used GADTs to capture invariants of the Theory of Patches in darcs
12:55:43 <jyp> might be possible to find the slides
12:55:47 <tibbe> jyp, and if you were forced to explain that to a 3-year-old what would you say?
12:56:10 <sieni> "heres some candy, just nod"
12:56:11 <jyp> http://darcs.net/DarcsWiki/Talks
12:57:24 <twb> tibbe: a three-year-old *human*?
12:58:00 <jyp> Well, dependent types allow to encode static properties in types, right ?
12:58:09 <jyp> Are we clear ? ;)
12:58:12 <tibbe> twb, yeah ;)
12:58:20 <tibbe> jyp, yup
12:58:32 <twb> tibbe: three years counting from when?
12:58:36 <kosmikus> jyp: YDTM
12:58:43 <twb> tibbe: and relative to the speaker, or the listener?
12:58:46 <jyp> Ok, so GADTs allow to do the same thing.
12:58:48 <tibbe> twb, from his/hers intellectual rebirth
12:59:14 <jyp> You ask, HOW SO? Right ?
12:59:27 <tibbe> I'm trying to get a general picture
12:59:33 <twb> I don't think my legs are supposed to bend this way.
12:59:38 <tibbe> just read about it today
13:00:03 <jyp> haha... :)
13:02:29 <twb> Well, it's 6am.  I give up trying to munge IORef into what I've already got.
13:02:36 <twb> Wanna see it?
13:03:20 <jyp> tibbe: The thing is, the type-parameters of a GADT can encode properties as well.
13:03:39 <jyp> exept this type the argument will be types and not values.
13:03:48 <tibbe> I see
13:04:20 <jyp> Note that it's not really necessary to have GADTs for that to hold
13:04:34 <jyp> (cf. some Oleg's articles)
13:04:55 <jyp> but GADT adds expressivity
13:05:47 <drakioned> awww. my version of a factorial function didn't appear on evolution of a Haskell programmer
13:06:53 <fons> sorry to be a pain in the ass, but I have some serious problems doing an exercise from Birds book
13:07:26 <mwc> @wtf gadt
13:07:28 <lambdabot> No match for "gadt".
13:08:35 <jyp> divide = foldr allocate ([],[]) where allocate x  (ys,zs) = (zs,x:ys)
13:08:59 <|Fo|Ns> jyp, that's it
13:09:11 <|Fo|Ns> I need to redefine it using splitAt
13:09:12 <jyp> > let divide = foldr  (\x -> (ys,zs) = (zs,x:ys)) allocate ([],[]) in allocate [1..10]
13:09:13 <lambdabot>  parse error on input `='
13:09:17 <Philippa_> mwc: Generalised Algebraic Datatypes
13:09:24 <Philippa_> (make the T a capital)
13:09:29 <jyp> > let divide = foldr  (\x (ys,zs) -> (zs,x:ys)) allocate ([],[]) in allocate [1..10]
13:09:30 <lambdabot>  Not in scope: `allocate'
13:09:40 <jyp> > let divide = foldr  (\x (ys,zs) -> (zs,x:ys)) ([],[]) in divide [1..10]
13:09:41 <lambdabot> ([2,4,6,8,10],[1,3,5,7,9])
13:10:00 <|Fo|Ns> and I have no idea about how to do it in an efficient way
13:10:16 <|Fo|Ns> I now how everything works, but I cannot see why should I use splitAt
13:10:32 <jyp> So, Bird claims it's efficient to use splitAt
13:10:34 <jyp> ?
13:11:04 <|Fo|Ns> well, he proposes th reader to try to reimplement divide by using splitAt
13:11:30 <jyp> > splitAt 2 [1..10]
13:11:31 <lambdabot> ([1,2],[3,4,5,6,7,8,9,10])
13:11:57 <twb> Crap, and the function I want isn't FFIized, neither.
13:12:21 <|Fo|Ns> and the he asks: "The definition of divide gicen in the text" (which is the one you have) "makes one traversal of the list. Does yours?"
13:12:25 <ihope> @type \x -> flip (Control.Monad.liftM (return ($ x)))
13:12:26 <lambdabot> forall a1
13:12:26 <lambdabot>                     b
13:12:26 <lambdabot>                     a
13:12:26 <lambdabot>                     b1.
13:12:26 <lambdabot>                  (Monad ((->) b), Monad ((->) a1)) =>
13:12:28 <lambdabot>                  a -> b -> (b -> a1) -> (a -> b1) -> b1
13:12:35 <ihope> Not right.
13:13:07 <sieni> @pl \x y -> x ++ (tail y)
13:13:07 <lambdabot> (. tail) . (++)
13:13:19 <jyp> |Fo|Ns: I don't see what he wants either.
13:13:25 <jyp> :(
13:14:01 <|Fo|Ns> jyp, I don't find a natural way of using splitAt to implement divide
13:14:16 <jyp> me neither.
13:14:50 <jyp> There are many unnatural ways of course
13:14:58 <tibbe> can I use GADTs for abstract syntax trees, I read something about that?
13:15:12 <sieni> > (\n x -> (uncurry ((. tail) . (++)) (splitAt n x))) 5 [1..10]
13:15:13 <lambdabot> [1,2,3,4,5,7,8,9,10]
13:15:21 <sieni> > (\n x -> (uncurry ((. tail) . (++)) (splitAt n x))) 5 [0..10]
13:15:22 <|Fo|Ns> jyp, for example?
13:15:22 <lambdabot> [0,1,2,3,4,6,7,8,9,10]
13:15:31 <Descolada|Work> sup
13:15:32 <|Fo|Ns> jyp, I can find stupid ways of using splitAt
13:15:37 <Descolada|Work> :t curry
13:15:47 <Descolada|Work> @t curry
13:15:48 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type .
13:15:49 <araujo> @hoogle splitAt
13:15:50 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
13:15:50 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
13:15:50 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
13:15:58 <sieni> that's probably the weirdest way of dropping nth element from a list that I've found
13:15:59 <jyp> tibbe: True
13:16:24 <sieni> @pl (\n x -> (uncurry ((. tail) . (++)) (splitAt n x)))
13:16:24 <lambdabot> (uncurry ((. tail) . (++)) .) . splitAt
13:16:29 <sieni> ahh
13:16:37 * sieni hugs lambdabot
13:16:58 <tibbe> jyp, is there a paper somewhere on it?
13:17:23 <jyp> I guess, tons of them.
13:17:39 <jyp> It's how the idea of GADT came 
13:17:46 <jyp> afaict
13:18:01 <xerox> ?pl \f g x y -> f (g x y)
13:18:02 <lambdabot> (.) . (.)
13:18:35 <tibbe> so whats the difference of defining Maybe as data Maybe a = Just a | Nothing and Maybe a where Just :: a -> Maybe a ; Nothing :: Maybe a ?
13:18:44 <Descolada|Work> for split at, shouldnt it have the int as the second parameter
13:18:54 <tibbe> jyp, could you direct me to a good one?
13:18:55 <jyp> tibbe: you'd have to follow citations 
13:19:02 <tibbe> alright :)
13:19:21 <jyp> I don't think I have read any of those in the 4 past years :p
13:19:45 <liyang> tibbe: theoretically, none... practically you can't derive e.g. Show instances automagically.
13:19:56 <Descolada|Work> whats @pl ?
13:20:02 <liyang> Descolada|Work: pointless.
13:20:58 <sieni> > ((.).(.)) const (+) 1 2
13:20:59 <lambdabot>  add an instance declaration for (Show (b -> a))
13:21:04 <sieni> h,,
13:21:19 <sieni> oops
13:21:26 <sieni> > ((.).(.)) id (+) 1 2
13:21:27 <ihope> @pl \x y z -> x z (y z)
13:21:27 <lambdabot> 3
13:21:27 <lambdabot> ap
13:21:40 <ihope> @pl 3+1
13:21:40 <lambdabot> 4
13:21:47 <ihope> Heh.
13:22:34 * resiak throws lambdabot a cookie
13:23:23 <jyp> tibbe: Hongwei Xi, Chiyan Chen, and Gang Chen. Guarded
13:23:23 <jyp>  recursive datatype constructors.
13:23:35 <jyp> must be one of those.
13:24:17 <sieni> > ((.).(.)) (*2) (+) 1 2
13:24:19 <lambdabot> 6
13:24:53 <tibbe> jyp, thanks, I'm off to bed no
13:24:55 <tibbe> now*
13:25:19 <jyp> alright ;)
13:25:41 <jyp> There's such a feeling of intimacy around here ;p\
13:44:43 <vincenz> sieni: stop playing with boobs
13:45:08 <vincenz> ((.)(.)(.)) (*2) (+) 1 2
13:45:12 <vincenz> > ((.)(.)(.)) (*2) (+) 1 2
13:45:13 <lambdabot> 6
13:45:51 <Revision17> > 0xF .&. 0x3
13:45:52 <lambdabot> Add a type signature
13:46:10 <Revision17> > (0xF :: Int) .&. (0x3 :: Int)
13:46:11 <lambdabot> 3
13:46:23 <Revision17> does lambda bot have everything included?
13:47:00 <Revision17> woah, lambdabot has it's own wiki
13:48:03 <sieni> boobs <3
13:48:24 <Muad_Dib> eh
13:48:38 <ihope> ♥
13:49:10 <vincenz> @type ((.)(.))
13:49:11 <lambdabot> forall b c a a1.
13:49:11 <lambdabot>     (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
13:49:30 <vincenz> @type ((.)(.)) (+) 1 (+2) 3
13:49:30 <lambdabot> forall a. (Num a) => a
13:49:34 <vincenz> > ((.)(.)) (+) 1 (+2) 3
13:49:36 <lambdabot> 6
13:56:18 <mwc> anybody know a place that will let me run heavily CPU-bound haskell code for an hour or so?
13:56:42 <basti_> your own system?
13:57:03 <vincenz> mwc: what's it for
13:57:05 <mwc> yeah, it don't have the power!
13:57:18 <mwc> I wonder if I could get this binary to run on the cluster
13:57:25 <mwc> no haskell compiler, but everything is statically linked...
13:58:58 <dcoutts__> mwc: I've got access to a 16-way mips supercomputer...
13:59:14 <dcoutts__> ... I just need to get ghc working first :-)
14:00:06 <xerox> Duncan!
14:00:24 <mwc> dcoutts, cool
14:00:33 <mwc> GHC runs on MIPS?
14:00:51 <vincenz> mwc: what are you trying to run
14:01:15 <mwc> simulated annealing optimization routine
14:01:32 <dcoutts__> hia xerox 
14:01:46 <dcoutts__> mwc: yes, dons runs it on IRIX
14:01:52 <mwc> neato
14:01:57 <vincenz> dcoutts__: can you approve my comment about my screenshot?
14:02:03 <mwc> you'll have fun when GHC 6.4.2 comes out
14:02:03 <dcoutts__> mwc: I've been trying to get it working on linux
14:02:29 <xerox> As soon as I stop giggling I'll try to find out how to run GHC here too :-)
14:02:38 <dcoutts__> vincenz: is that a comment you've already posted?
14:03:02 <dcoutts__> mwc: you mean because we'll have to rebuild on 8 arches?
14:03:20 <dcoutts__> xerox: is that your new x86 mac?
14:03:26 <xerox> Indeed!
14:03:40 <dcoutts__> xerox: I think they're still porting it
14:04:12 <mwc> nah, the new MP goodness with STM and the like
14:04:20 <vincenz> dcoutts__: yeah
14:05:31 <ihope> > log 2
14:05:33 <lambdabot> 0.6931471805599453
14:05:40 <ihope> Wuh?
14:05:43 <mwc> dcoutts, that happen to be an SGI box?
14:05:53 <xerox> ihope, what about it?
14:05:59 <vincenz> > log 3 + log 2
14:06:01 <lambdabot> 1.791759469228055
14:06:26 <ihope> ihope: if the square root of 10 is greater than 3...
14:06:30 <dcoutts__> vincenz: approved :-)
14:06:48 <ihope> > log 10
14:06:49 <lambdabot> 2.302585092994046
14:06:53 <xerox> > sqrt 10 > 3
14:06:54 <lambdabot> True
14:06:54 <ihope> > log e
14:06:55 <lambdabot>  Not in scope: `e'
14:07:03 <dcoutts__> mwc: dons has a dual R10K, I have access to an Origin2000 :-)
14:07:04 <ihope> @index e
14:07:05 <lambdabot> Data.Graph.Inductive.Example
14:07:20 <xerox> > log (exp 1)
14:07:21 <lambdabot> 1.0
14:07:28 <vincenz> dcoutts__: thx
14:07:35 <dcoutts__> mwc: oh, you mean ghc 6.6. It'll have the SMP rts stuff
14:07:35 <ihope> > logBase 10 10
14:07:36 <lambdabot> 1.0
14:07:42 <ihope> > logBase 2 10
14:07:43 <lambdabot> 3.3219280948873626
14:07:47 <mwc> Oh, right
14:07:49 <mwc> right
14:08:00 <mwc> 6.6, that's what I'm waiting for to by myself an SMP system
14:08:10 <dcoutts__> mwc: yeah, it'll be fun to try that on a 16-way box :-)
14:08:15 <xerox> > logBase 2 10 == (log 10 / log 2)
14:08:16 <lambdabot> True
14:08:32 <dcoutts__> mwc: yeah, me too. I've been thinking of upgrading to a dual core amd64
14:09:19 <Descolada|Work> whats forall mean?
14:09:34 <xerox> It means for all the possible things bound.
14:09:40 <Descolada|Work> ahh
14:10:23 <mwc> I'm waiting for the new amd64 socket to come out, that'll be DDR2 rather than DDR
14:10:36 <mwc> also, rumor has it that that socket will be the platform for quad cores
14:10:43 <xerox> I.e. all the possible types a (possibly constrained) type variable can be.
14:11:12 <ihope> What does tl look like?
14:11:14 <xerox> If you're comfortable with math-speak, it's just the universal quantifier.
14:11:58 <xerox> There also is the existential quantifier `exist´.
14:12:00 <Descolada|Work> well, since not alot of developers are using dual core, i wonder how they expect to get much quad core speed gains
14:12:08 <mwc> dcoutts, http://cgi.ebay.ca/Supercomputer-SGI-3800-SGI-Origin-3800-16-x-400MHz_W0QQitemZ5863963486QQcategoryZ11223QQrdZ1QQcmdZViewItem
14:12:20 * xerox is using a dual core system, woopee.
14:12:20 <mwc> too bad I can't afford that, would look great in my basement
14:12:34 * Descolada|Work has a dual core system
14:12:51 <Descolada|Work> but i busted the motherboard, but im getting a new one today! :(
14:13:00 <Descolada|Work> :) too
14:13:39 <xerox> > let peasant x y = sum [n | (n,b) <- takeWhile ((>0) . snd) $ iterate ((*2) *** (`div`2)) (x,y), not (even b)] in peasant 57 86
14:13:40 <lambdabot> 4902
14:13:44 <xerox> > 57*86
14:13:45 <lambdabot> 4902
14:14:03 <mwc> oh well, I'm gonna go work on my slides for the presentation and let this thing run
14:15:41 <ihope> Oh! Of course!
14:16:26 <ihope> > (((30/32) * log 30) + ((2/32) * log 2)) / log 2 -- should be near 5
14:16:26 <lambdabot> 4.6627099333829864
14:16:55 <ihope> > (((30/32) * log 30) + ((2/32) * log 2)) * 20 / log 2
14:16:56 <lambdabot> 93.25419866765974
14:18:34 <JohnnyL> has haskell been used in web development lately?
14:18:45 <int80_h> I'm running netbsd 2.0.2. Do I have to port ghc-6.4.1?
14:19:02 <int80_h> the docs say I have to do minor porting. Haven't read the whole thing yet though
14:19:07 <int80_h> not sure what that entails
14:19:16 <int80_h> and maybe perhaps someone has a binary somewhere...
14:22:58 <dcoutts__> int80_h: a binary would be easier. There are certainly binaries for OpenBSD & FreeBSD.
14:23:26 <dcoutts__> int80_h: a binary for an older version would also be suitable since that allows you to build the latest version from source.
14:24:26 <int80_h> ahhh
14:24:29 <int80_h> makes sense
14:24:42 <int80_h> wahh it wants me to have perl installed for binaries
14:24:49 <int80_h> okay, well it's for the greater good
14:33:24 <ihope> > isAscii
14:33:25 <lambdabot>  add an instance declaration for (Show (Char -> Bool))
14:33:28 <ihope> Whoo.
14:33:33 <ihope> Whoa, that is.
14:33:47 <ihope> > filter isAscii ['\0'..'\255']
14:33:48 <lambdabot> "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL"
14:33:52 <ihope> Hmm.
14:33:59 <ihope> > isPrintable
14:34:00 <lambdabot>  Not in scope: `isPrintable'
14:34:05 <ihope> @hoogle Char -> Bool
14:34:06 <lambdabot> Char.isAlpha :: Char -> Bool
14:34:06 <lambdabot> Char.isAlphaNum :: Char -> Bool
14:34:06 <lambdabot> Char.isAscii :: Char -> Bool
14:34:14 <ihope> Is that all?
14:34:24 <xerox> ?hoogle+
14:34:24 <lambdabot> Char.isControl :: Char -> Bool
14:34:24 <lambdabot> Char.isDigit :: Char -> Bool
14:34:24 <lambdabot> Char.isHexDigit :: Char -> Bool
14:34:25 <Lemmih> @type Char.isPrint
14:34:25 <lambdabot> Char -> Bool
14:34:40 <xerox> ?docs Data.Char
14:34:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
14:36:38 <JohnnyL> how much work/parsing is required for a haskell interpreter?
14:36:41 <ihope> > filter isPrint ['\1'..]
14:36:45 <ihope> Aww.
14:36:52 <ihope> > filter isPrint ['\1'..'\256']
14:37:12 <lambdabot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\160\161\162\163\164\165\166\167\168\169\170\171\172\174\175\176\177\178\179\180\181\182\183\184\185\186\187\188\189\190\191\192\193\194\195\196\197\198\199\200\201\202\203\204\205\206\207\208\209\210\211\212\213\214\215\216\217\218\219\220\221\222\
14:37:14 <lambdabot> 223\224\225\226\227\228\229\230\231\232\233\234\235\236\237\238\239\240\241\242\243\244\245\246\247\248\249\250\251\252\253\254\255\256"
14:37:25 <ihope> Hmm.
14:38:25 <Lemmih> > filter (uncurry (&&) . (isPrint &&& isAscii)) ['\0' .. '\255']
14:38:26 <lambdabot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
14:38:47 <ihope> > filter (liftM2 (&&) isAscii isPrint) ['\0'..'\256'] -- I like this one.
14:38:48 <lambdabot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
14:39:06 * xerox infected Lemmih
14:39:13 <Lemmih> But where's the arrows? (:
14:39:49 <ihope> There's also (`elem` " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")
14:40:03 <wolverian> hm, I didn't know &&&. neat.
14:40:28 <ihope> @type (Control.Arrow.&&&)
14:40:29 <lambdabot> forall (a :: * -> * -> *) c' c b.
14:40:29 <lambdabot>         (Control.Arrow.Arrow a) =>
14:40:29 <lambdabot>         a b c -> a b c' -> a b (c, c')
14:40:33 <vincenz> > [minBound]::Char
14:40:34 <lambdabot> Couldn't match `Char' against `[a]'
14:40:37 <vincenz> > [minBound]::[Char]
14:40:38 <lambdabot> "\NUL"
14:40:40 <vincenz> > [maxBound]::[Char]
14:40:41 <lambdabot> "\1114111"
14:40:51 <ihope> Pretend that says (a -> b) -> (a -> b') -> a -> (b, b').
14:40:57 <vincenz> > maxBound :: Char
14:40:58 <lambdabot> '\1114111'
14:41:04 <vincenz> > fromIntegral(maxBound :: Char)
14:41:05 <lambdabot>  add an instance declaration for (Integral Char)
14:41:05 <lambdabot>   In the definition of `drr': drr = fromIntegral (maxBound :: Char)
14:41:05 <lambdabot>   In the definition of `v':
14:41:12 <vincenz> > ord (maxBound :: Char)
14:41:13 <lambdabot> 1114111
14:42:49 <xerox> &&& :: (Arrow (~>)) => (a ~> b) -> (a ~> c) -> (a ~> (b,c))
14:43:21 <ihope> I guess it doesn't get too much clearer.
14:43:30 <xerox> I think it does.
14:44:10 <xerox> Oh, sorry, I didn't see you writing it just now.
14:44:21 <Descolada|Work> wtf is ~> ?
14:44:29 <xerox> An Arrow!
14:44:43 <kosmikus> a type variable
14:44:56 <xerox> ...an infix type constructor.
14:45:24 <kosmikus> heh. 3 answers, all of them correct.
14:45:30 <Descolada|Work> lol
14:45:46 <ihope> An infix Arrow varable.
14:45:59 <ihope> It's also an infix Arrow variable.
14:50:47 <dcoutts__> xerox: how was your trip?
15:17:26 <ARous1984> Does anyone know how to access an element of a tuple in haskell?
15:17:47 <musasabi> @type fst
15:17:48 <lambdabot> forall a b. (a, b) -> a
15:17:53 <musasabi> @type snd
15:17:54 <lambdabot> forall b a. (a, b) -> b
15:19:14 <astrolabe> or pattern matching
15:19:18 <dcoutts__> > (\(a,b,c,d) -> c) (1,2,3,4)
15:19:19 <lambdabot> 3
15:19:23 <ihope> \(a,b) -> a
15:19:44 <astrolabe> @pl \(a,b,c,d) -> c
15:19:44 <lambdabot> (line 1, column 6):
15:19:44 <lambdabot> unexpected ","
15:19:44 <lambdabot> expecting letter or digit, operator or ")"
15:19:44 <lambdabot> ambiguous use of a non associative operator
15:20:22 <ihope> @pl \(a,b,c) -> c
15:20:23 <lambdabot> (line 1, column 6):
15:20:23 <lambdabot> unexpected ","
15:20:23 <lambdabot> expecting letter or digit, operator or ")"
15:20:23 <lambdabot> ambiguous use of a non associative operator
15:20:29 <ihope> @pl \(a,b) -> c
15:20:30 <lambdabot> const c
15:20:35 <ihope> :-)
15:20:39 <ihope> @pl \(a,b) -> a
15:20:39 <lambdabot> fst
15:20:41 <astrolabe> cheat!
15:20:52 <astrolabe> That's weird
15:21:06 <astrolabe> Is \(a,b,c)->c ok haskell?
15:21:14 <araujo> > ((\f,s,t) -> "one " ++ f ", second " ++ s ++ ", third " ++ t) ("haskell", "rulez", "world")
15:21:15 <lambdabot>  parse error on input `,'
15:21:35 <araujo> > ((\f,s,t) -> "one " ++ f ++ ", second " ++ s ++ ", third " ++ t) ("haskell", "rulez", "world")
15:21:35 <lambdabot>  parse error on input `,'
15:21:41 * araujo gives up
15:21:51 <ihope> > (\(f,s,t) -> "one " ++ f ", second " ++ s ++ ", third " ++ t) ("haskell", "rulez", "world")
15:21:51 <lambdabot> Couldn't match `[Char] -> [Char]' against `[Char]'
15:22:00 <ihope> > (\(f,s,t) -> "one " ++ f ++ ", second " ++ s ++ ", third " ++ t) ("haskell", "rulez", "world")
15:22:01 <lambdabot> "one haskell, second rulez, third world"
15:22:35 * araujo diffs
15:22:49 <ihope> s/(\\/\\(/
15:23:15 <araujo> oh,. :-)
15:24:41 <ARous1984> so what is the main function of using the keyword where?
15:24:55 <ihope> The same as using let...
15:25:01 <ARous1984> Okay.
15:25:08 <ARous1984> I don't know the function of either...sorry :)
15:25:10 <ihope> let foo in bar = bar where foo
15:25:14 <ARous1984> I'm uber new to haskell
15:25:42 <ihope> > let 6*9 = 42; x*y = x Prelude.* y in [6*9,9*6,6*7,3*4]
15:25:43 <lambdabot> [42,54,42,12]
15:25:55 <ihope> > let x = 3 in x + 2
15:25:56 <lambdabot> 5
15:26:01 <ihope> Get the idea?
15:26:17 <ARous1984> So its just used for variable replacement?
15:26:21 <sjanssen> ihope: let and where aren't exactly the same -- where scopes over guards
15:26:37 <ihope> Ah, right.
15:27:47 <sjanssen> ARous1984: pretty much.  Whenever you want to give something a name that isn't at the global scope
15:27:53 <araujo> ARous1984, mor elike variable binding
15:28:47 <araujo> > let a = 8 in (let a = 9 in a) + a
15:28:48 <lambdabot> 17
15:29:17 <ARous1984> thats really confusing, since you bound two values to the same variable
15:29:20 <ARous1984> or not i guess
15:29:48 <sjanssen> yes, that bit of code would be considered bad style
15:30:28 <ARous1984> untie (x,y) : zs = ((x:xs),(y:ys)) where (xs,ys) = untie zs
15:30:32 <araujo> ARous1984, that just shows you use let for binding value to variables regarding a scope
15:30:35 <ARous1984> im not quite understanding that code.
15:31:11 <ihope> Ah.
15:32:57 <vincenz> ARous1984: you need a case for []
15:33:00 <ARous1984> anyone care to explain that?
15:33:06 <ARous1984> right. assume there is one
15:33:13 <ARous1984> im just interested in that part i pasted.
15:33:14 <vincenz> don't understand it?
15:33:21 <ARous1984> i didnt write it.
15:33:21 <vincenz> ARous1984: it assumes it's a list of touples
15:33:34 <ARous1984> i know that
15:33:35 <vincenz> and takes the top tuple...attaches them to two lists
15:33:41 <ARous1984> but im thrown by the where and what goes on
15:33:42 <vincenz> which come from untying the rest of the list of tuples
15:33:47 <vincenz> ARous1984: where is like let
15:34:09 <ihope> untie [(1,2),(3,4),(5,6)] = ([1,3,5],[2,4,6])
15:34:14 <vincenz> untie (x,y):zs = let (xs,ys) = untie zs in ((x:xs), (y:ys))
15:36:21 <sjanssen> ARous1984: do you understand what it means when you have the tuple on the left of '=' (like "(xs, ys) = untie zs") ?
15:37:02 <ARous1984> yes
15:37:16 <sjanssen> okay
15:37:36 <ihope> Hmm...
15:38:09 <sjanssen> the where just means: consider xs and ys to be the result of untying the tail of the list
15:46:38 <dons> inject the coffee into my veins!
15:47:31 <sjanssen> @yow
15:47:31 <lambdabot> Virtual reality isn't what it used to be.
15:48:54 <dons> ?remember Lemmih I see Haskell as the avenging Angle set out to smite the evil ways of dysfunctional programming.
15:48:55 <lambdabot> Done.
15:49:11 <boy> dons: hi, do you know who i am?
15:49:52 <dons> :P
15:51:49 <boy> dons: when is the deadline for sending the patch?
15:56:20 <dons> please send it asap
15:56:34 <dons> all you need to do is type: darcs send -o /tmp/f ; then mail me that file
15:56:45 <dons> presuming you've recorded your patch
15:58:22 <boy> gotta log into the workstation...
16:01:50 <boy> loggin in...
16:03:03 <boy> success!
16:05:14 <boy> dons: /tmp/f is a regular text file
16:05:36 <dons> it should be a regular text file containing the patch
16:05:55 <boy> dons: yep, must i mail it to you, or can i paste it somewhere? :)
16:08:31 <dons> yes. mail please. mailx -s "Patch" dons@cse.unsw.edu.au< /tmp/f
16:09:45 --- mode: irc.freenode.net set +o shapr
16:09:52 <boy> dons: sent! :D
16:10:12 <dons> thanks
16:10:20 <dons> ?quit fixes
16:12:41 <boy> dons: did you recieve the patch? can i log out of the workstation? i am paying by the second...
16:12:59 <dons> yep. got it . cheers
16:14:21 <boy> alright! once again, boy saves the day and submits a vital contribution to one of the top 10 software projects
16:14:51 <dons> :)
16:16:33 <sjanssen> is this a flood fix?
16:17:10 <ihope> > "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
16:17:11 <lambdabot> "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
16:17:11 <lambdabot> 111111111111111111111111111111111111111111111111111"
16:17:15 <ihope> Hmm.
16:17:40 <ihope> I think so.
16:24:34 <dons> ihope :(
16:24:38 <dons> ?karma- ihope
16:24:39 <lambdabot> ihope's karma lowered to 2.
16:24:46 <dons> you knew all about the flooding last night.
16:24:50 <dons> so why persisst?
16:25:14 <dons> :P
16:25:30 * dons is grumpy having to patch so early in the morning
16:26:49 <dons> for those interested, i've posted HWN-style news headlines from haskell@haskell.org for the years 1991-98 here: http://haskell.org/haskellwiki/Old_news
16:27:51 <dons> inlucding highlights such as: "Yale Haskell Y1.2 Now Available" and "The history of Haskell" (circa 1992)
16:28:05 <Igloo> dons: By hand?
16:28:10 <dons> tool suppoort
16:28:19 <dons> extracted from the archives
16:29:12 <dons> the ml gets really busy around 96 or so, it becomes recognisably "haskell@"
16:29:45 <dons> the next step is to post a fun timeline
16:30:10 <dons> such as Lennart's first call to arms against "n+k" and the first time people complain about haskell.org being out of date (sometime in 988)
16:31:33 <dons> pity though, the first year of the ml seems to be missing, and so far I can't find anything fromm 99. anyone have that ml tarball link spj posted last year?
16:32:25 <ihope> > let pred (n+1) = n in pred 3
16:32:26 <lambdabot> 2
16:32:34 <ihope> Hmm. That wasn't working before.
16:35:44 <sjanssen> dons: http://research.microsoft.com/~simonpj/haskell/haskell-email-11Sep1990-27Oct2000.gz
16:45:24 <dons> ah!
16:45:34 <dons> ?karma+ sjanssen
16:45:35 <lambdabot> sjanssen's karma raised to 2.
16:46:08 <dons> I should mirror these
16:50:24 <dons> and they shouuld be on haskell.org too. hmm
17:02:34 <dons> Date: 16 Jan 91 22:28, first mention of a need for a Binary class to do IO
17:02:38 <dons> let's get it into Haskell' !
17:03:43 <SyntaxNinja> dons: I think we need to think about that first
17:03:46 <Igloo> Woah, hold your horses there, pard'ner! Don't wanna go rushing into things!
17:04:07 <dons> :S
17:05:24 <dons> "Those who do not read mailing list archives, are doomed to repeat the mistakes of the past"
17:06:26 <boy> and irc logs
17:07:33 <palomer> man, the difference good design makes
17:07:35 <palomer> it's incredible
17:07:44 <palomer> it's seriously incredible
17:08:59 <sm> hi all
17:09:22 <sm> I tried out the new tutorial, and had great fun for a few minutes
17:09:42 <sm> then got stuck at http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/firststeps.html exercise 2
17:10:14 <sm> I couldn't easily find out how to use read or show 
17:10:15 <vincenz> sm: easy
17:10:28 <vincenz> 2type read
17:10:30 <vincenz> @type read
17:10:30 <lambdabot> forall a. (Read a) => String -> a
17:10:34 <vincenz> @type show
17:10:34 <lambdabot> forall a. (Show a) => a -> String
17:10:48 <vincenz> main = do
17:10:54 <vincenz>    args <- getArgs
17:10:58 <vincenz> now args has a list of arguments in strings
17:11:03 <dons> huh. April 1991: SPJ says:
17:11:03 <dons> Haskell currently automatically derives all of the "standard" instances
17:11:07 <dons> (Enum, Ix, Num, Text, Eq, Ord, Binary)
17:12:32 <sm> vincenz: thx, yes, I did :type read and found  docs on read and show
17:12:50 <sm> so I tried to make some type declarations, but failed
17:13:20 <sm> how come Int, Integer, Show, Read are all meaningless when I type then in hugs or ghci ?
17:13:45 <dons> ?
17:14:11 <dons> some are classes, some are types. but you can only declare new types in a file, not at a prompt
17:14:17 <dons> > 7 :: Int
17:14:18 <lambdabot> 7
17:14:29 <sm> hmm
17:14:31 <dons> but Show and Read are classes
17:14:38 <sm> I'm not defining new types afaik
17:14:54 <dons> whhat do you mean by _meaningless_ ?
17:15:45 <sm> I mean when I enter them at the interactive prompt, by themselves or after :type, they don't seem to be in the namespace at all.. I thought at least one or two would be
17:16:45 <Igloo> types don't have types, so :t <a type> doesn't make sense
17:16:52 <dons> they are in scope. but you can't :type a type or a class, nor eval them, as you've tried to do
17:16:54 <sm> ok
17:16:55 <dons> you might want to :info Show though
17:16:56 <Igloo> Similarly they aren't what is expected at the ghci prompt
17:17:10 <sm> ok.. because "types aren't first class values", eh
17:17:14 <sm> makes sense
17:18:06 <sm> what about the classes though, Show & Read .. I see :info knows about them, why does Show by itself say ERROR - Undefined data constructor "Show" ?
17:18:25 <dons> it's not a constructor
17:18:50 <dons> both type and classes are static things. they exist only in the compiler, not at runtime (basically)
17:19:03 <dons> so you can't evaluate them
17:19:04 <sm> I know, it's a class.. so I can't type the name of a class and expect it to say this is class so and so..
17:19:10 <sm> I seee
17:19:14 <dons> it is, as you say, meaningless to try to evaluate a class or a type
17:19:49 <dons> no, but that's what :info is for
17:19:59 <sm> is it true to say that like types, classes aren't first-class values ? or is that only true in the interpreters
17:20:09 <dons> they're not values
17:20:23 <sm> right.. first-class.. things
17:20:23 <dons> they're on the type level. the (static) level that describes values
17:20:28 <sm> ok
17:20:28 <dons> types describe values.
17:20:40 <dons> depends on whhat you mean by 'first-class'
17:20:53 <dons> if you mean: exists at runtime, can be bound , can be passed as argument, then no.
17:20:59 <sm> that's what I meant
17:21:03 <dons> which is usually what people mean.
17:21:08 <dons> i.e. functoins are first class
17:22:30 <vincenz> > "dons" :: [Char]
17:22:31 <lambdabot> "dons"
17:23:12 <sm> ok, thanks! backing up then.. how do I read a string into an integer at the hugs prompt ?
17:23:17 <vincenz> sm
17:23:25 <vincenz> > read "1" :: Int
17:23:26 <lambdabot> 1
17:23:27 <dons> types and type classes are a meta-language for describing actual values. this metaa-language is `evaluate' == checked, at compile time, to establish properties of the code . then all the meta-languagee constructs are thrown away.
17:23:29 <vincenz> > read "1" + 1
17:23:31 <lambdabot> 2
17:23:37 <dons> is 'evaluated'
17:23:45 <vincenz> > dons has blue hair
17:23:45 <lambdabot>  Not in scope: `hair'
17:23:47 <sm> ah. needed two ::'s not one.
17:23:53 <vincenz> lambdabot: the answer is "True?"
17:24:21 <vincenz> anyone looked at these sites:
17:24:23 <vincenz> foldl.com
17:24:24 <vincenz> foldr.com
17:24:29 <sm> and it wouldn't make sense for me to try and define a :: Int interactively, right
17:24:34 <vincenz> talk about the lamest sites ever... they're just javascript that keep going
17:24:59 <sm> I mean define a variable a of type Int, and then do a = read "1"
17:26:14 <dons> > let a = 1 :: Int in a
17:26:14 <lambdabot> 1
17:26:37 <vincenz> > let dons = dons + 1 :: Int in dons
17:26:38 <lambdabot> Terminated
17:26:41 <dons> > let a = read "1" :: Int in a 
17:26:41 <vincenz> ouch
17:26:42 <lambdabot> 1
17:26:45 <vincenz> dons: you were terminated
17:26:50 <dons> yikes!
17:27:01 <Igloo> > is there a submarine
17:27:01 <lambdabot>  Not in scope: `submarine'
17:27:06 <dons> hehe
17:27:07 <vincenz> apparently not
17:27:31 <vincenz> > 1 :: Heterosexual
17:27:31 <lambdabot>  Not in scope: type constructor or class `Heterosexual'
17:27:43 * vincenz peers around
17:27:47 <dons> > whats not in the periscope, a submarine?
17:27:47 <lambdabot>  parse error on input `in'
17:27:58 <dons> argh
17:28:22 <sm> ok, leaving that aside, new q:  in a program compiled with ghc, why does       a <- read a::Int       in a do block say Couldn't match `IO t' against `Int'
17:28:48 <sm> how should I write that one ?
17:28:50 <vincenz> sm <- in the IO monad implies the right side is of type "IO something"
17:29:02 <vincenz> sm: and you can't assign variables twice
17:29:24 <sm> ok
17:30:10 <sm> could you show me the way it should be ?
17:30:16 <sm> read a::IO Int  ?
17:30:26 <vincenz> nono
17:30:38 <vincenz> let a = read x
17:30:53 <sm> this is in a do block, mind
17:30:59 <vincenz> you can use lets
17:31:03 <sm> ok
17:32:23 * araujo back from dinner
17:32:51 <sm> vincenz: I can't make that work
17:33:02 <vincenz> can someone help him
17:33:05 <sm> is it ok to paste small multiline snippets here
17:33:07 <vincenz> I have to go sleep :/
17:33:14 <vincenz> sm: use http://rafb.net/paste
17:33:45 <sm> http://rafb.net/paste/results/DxVoBL20.html is where I'm at
17:33:47 <Excedrin> read doesn't do IO
17:34:00 <sm> so I need <-, right
17:34:08 <dons> sm, you want to do getLine or getContents?
17:34:19 <dons> check out the tutorials on haskell.org under Learning
17:34:30 <sm> not yet.. I'm trying to work through the tutorial I mentioned
17:34:34 <dons>  read and show are like sprintf 
17:34:44 <dons> they do no io
17:35:05 <sm> I looked at the others again quickly, and they all seem less practical - corresponding to a real-world ghc implementation - than this one
17:35:05 <dons> ?type read
17:35:05 <dons> ?type show
17:35:06 <lambdabot> forall a. (Read a) => String -> a
17:35:06 <lambdabot> forall a. (Show a) => a -> String
17:35:51 <sm> despite the incredible wealth of high-end documentation and previous attempts, I am finding haskell hard to get to know
17:36:13 <sm> trying to figure out if that's the present state of docs, haskell, or my brain
17:36:21 <ihope> Your brain. :-P
17:36:31 <Excedrin> are you familiar with functional programming in general?
17:36:42 <sm> what I'm looking for is a tutorial that is so basic, that I can type in what it says to type in and it works
17:36:45 <vincenz> @where yaht
17:36:45 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
17:36:48 <vincenz> sm: try that tutorial
17:36:53 <vincenz> sm: I found it a good one
17:37:11 <sm> really, I expect that from any tutorial :)
17:37:14 <sm> thx
17:38:36 <dons> the Learning page on haskell.org provides tutorials ranging from simple to advanced.
17:38:44 <dons> yaht is the most recommended, I think
17:41:37 <sm> thx, I saw.. I have explored them all to some degree
17:42:12 <sm> this one (yaht) is working better for me, I'll work through it first 
17:42:20 <sm> the first failure I've found is at section 3.3.1
17:43:06 <sm> ’H’:’e’:’l’:’l’:’o’:[]   in ghci gives me an error.. has the language evolved since that tutorial ?
17:43:17 <sm> <interactive>:1:1: lexical error
17:43:52 <Excedrin> no, your paste has a lot of extra characters
17:44:15 <Excedrin> probably the wrong quote character
17:44:45 <sm> hmm, I paste directly from the yaht pdf, 3.3.1 example
17:45:18 <sm> you're right! wrong quote!
17:45:29 <dons> sm, you've seen http://haskell.org/haskellwiki/Books_and_tutorials#General_Introductions_to_Haskell
17:45:30 <sm> thanks again
17:46:23 <sm> dons: yes, thx
17:51:58 <sm> ok, I have learned things and I'm wrapping up here, and will grok yaht before any others.. I still would like to see the code that reads an argument into an integer variable in a do block
17:52:34 <sm> since it is beyond me :)
17:56:07 <araujo> sm, ?
17:58:25 <sm> araujo: I mean what should line 4 be at http://rafb.net/paste/results/5Ophuk14.html
18:00:38 <araujo> do i <- return ((read "999") :: Int) ; putStrLn "done"
18:00:44 <araujo> @type read
18:00:45 <lambdabot> forall a. (Read a) => String -> a
18:01:56 <sm> araujo: sorry, I don't understand that
18:02:19 <araujo> sm, have you already read about return?
18:02:24 <sm> no
18:03:01 <araujo> well, i think you should read a bit about it at least
18:03:04 <sm> please go slowly if you wouldn't mind.. what's wrong with that line ?
18:03:42 <araujo> read isn't returning a monadic value
18:03:51 <sm> ok
18:03:55 <araujo> that's what (very generally speaking) return does there
18:04:58 <sm> what's the least I could do to that line to make it compile ? something like anInt <- return (read a::Int) ?
18:05:39 <Excedrin> http://rafb.net/paste/results/O0GktU10.html
18:07:02 <araujo> sm, yes, just what i pasted would work
18:07:44 <sm> araujo, Excedrin: I'm sure those work, but they are so different from mine that they don't help me see the error of my ways
18:08:16 <sm> what about http://rafb.net/paste/results/EbfMhT15.html , am I getting in the ballpark ?
18:08:25 <araujo> sm, i wouldn't know what else to tell you, kind of hard if you hadn't read about return before
18:08:45 <sm> Excedrin didn't use it
18:10:22 <araujo> sm, can you see the difference between those two code?
18:11:11 <sm> between excedrin's and my latest ? yes
18:11:24 <sm> afaict his accepts a list of args, mine accepts only two
18:11:35 <araujo> no, between Excedrin and mine
18:12:06 <sm> I don't understand yours, and it's more than I want to know at this moment, really
18:12:23 <sm> I would like to understand it immediately following this though
18:12:35 <araujo> good :-)
18:12:51 <araujo> what doc are you reading?
18:13:30 <sm> I came here from http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/firststeps.html , exercise 2
18:13:34 <araujo> haskell.org is full of nice stuff
18:13:47 <sm> I have formed the opinion that tutorial makes unreasonable demands on it's intended audience
18:14:27 <sm> and yet what ex. 2 is asking looks.. trivial :(
18:16:07 <araujo> http://haskell.org/haskellwiki/Books_and_tutorials#Papers_available_on_the_Web
18:16:57 <araujo> If you programm in othger language, a gentlte introduction is a nice paper
18:18:22 <sm> the truth is, I've read all that stuff, but now I'm trying to actually get my feet wet, hit the road with the rubber
18:18:50 <Cale> You're looking for a haskell tutorial?
18:19:02 <Cale> "Yet Another Haskell Tutorial" is pretty good
18:19:10 <sm> I guess I have to read again.. yaht for me, this time going step by step and squawking loudly here as I have been doing.. hope it's not too annoying
18:19:40 <Cale> not at all
18:19:47 <Cale> we like answering questions :)
18:19:59 <mwc> I'd wager I've bothered this chan much more than you have, sm 
18:20:08 <Excedrin> sm: if you match with [a,b], the program will fail with an exception unless you supply two arguments, if you use head or match with (a:b), then b can be [], so a 1 argument list will work
18:20:51 <sm> Excedrin: I saw that.. I do pass 2 args
18:21:02 <sm> at the moment I'm getting a compiler error on line 4 though
18:21:24 <araujo> what is it?
18:21:26 <sm> but out of time here - thanks all, bye for now
18:22:18 <sm> http://rafb.net/paste/results/7o7rHB16.html
18:22:47 <araujo> sm, add, :: Int
18:22:53 <sm> Cale: you say that, but you may get bored :)
18:23:01 <sm> I find it  hard to get specific answers
18:23:09 <Cale> there are enough people here to take care of it :)
18:23:17 <Cale> where's your current code?
18:23:24 <araujo> sm, answering haskell questions is fun :-]
18:24:11 <sm> Cale, see my rafb links above ?
18:24:20 <sm> http://rafb.net/paste/results/EbfMhT15.html is latest
18:24:39 <Cale> ah
18:24:43 <Cale> I missed that one
18:24:57 <sm> I added the $ which I don't yet understand, just mimicking excedrin
18:25:00 <Cale> you never use anInt, so it doesn't know what type to parse
18:25:08 <Cale> the $ is unnecessary
18:25:12 <sm> oho
18:25:14 <Cale> f $ x = f x
18:25:28 <sm>  ah
18:25:39 <Cale> (but with really low operator precedence)
18:25:43 <Excedrin> f (g x) = f $ g x
18:26:31 <sm> I really appreciate the help here.. it's the miniscule answers like those that really are great for me! baby steps
18:26:42 <Excedrin> I realize that's the same thing, but I usually see $ as a way to avoid parens
18:26:56 <eamelink> @ 3:26 am haskell is not getting clearer for me :P
18:27:01 <eamelink> So let's call it a day
18:27:23 <Igloo> In case it isn't clear, the $ in the URL above is redundant
18:28:13 <sm> my next attempt: http://rafb.net/paste/results/RzZjMT93.html , which uses anInt
18:28:40 <Cale> right, but that still doesn't get across that it's an integer
18:28:41 <Igloo> show isn't enough for the compiler to work out what type anInt must have
18:28:50 <Cale> @type show
18:28:51 <lambdabot> forall a. (Show a) => a -> String
18:28:54 <Cale> @type read
18:28:55 <lambdabot> forall a. (Read a) => String -> a
18:29:23 <sm> oh yes.. I should back up and include what I learned earlier, shouldn't line 4 be let anInt = read a::Int ?
18:29:31 <Cale> that would work
18:29:39 <Igloo> If you added, for example,       c = chr a    below "anInt = read a"   then it would be able to infer it
18:30:02 <Igloo> I mean   chr anInt
18:30:05 <sm> success!
18:30:14 <araujo> sm, :-)
18:30:37 <sm> http://rafb.net/paste/results/tyMxe224.html
18:32:10 <ihope> > reverse 'b'
18:32:10 <lambdabot> Couldn't match `[a]' against `Char'
18:32:13 <ihope> Mmh.
18:32:40 <sm> ok that's progress for today
18:32:40 <MokuskerekHarc> did you expect 'd'? ;)
18:32:42 <sm> thanks!
18:32:46 * sm waves
18:32:53 <ihope> MokuskerekHarc: yep.
18:33:06 <ihope> MokuskerekHarc: and don
18:33:30 <ihope> 't use a name that requires tab completion to type properly! ;-)
19:12:39 <boy> > 0xf0
19:12:40 <lambdabot> 240
19:12:45 <boy> > 0xff
19:12:46 <lambdabot> 255
19:12:54 <boy> > 010
19:12:55 <lambdabot> 10
19:12:58 <boy> > 015
19:13:00 <lambdabot> 15
19:13:36 <ihope> > 0ff
19:13:37 <lambdabot>  Not in scope: `ff'
19:13:41 <ihope> > 0xff
19:13:42 <lambdabot> 255
19:13:45 <ihope> Hmm.
19:14:56 <lispy> > -0
19:14:57 <lambdabot> 0
19:15:36 <boy> @type 0xfa
19:15:37 <lambdabot> forall t. (Num t) => t
19:15:43 <boy> @type 23
19:15:44 <lambdabot> forall t. (Num t) => t
19:15:58 <boy> > 0xff == 255
19:15:59 <lambdabot> True
19:31:05 <ihope> @localtime lambdabot
19:42:39 <dons> sm, did you work out how to read an argument into an Integer variable?
19:55:46 <ihope> > log 3 / log 2
19:55:47 <lambdabot> 1.5849625007211563
19:56:35 <dons> ?yow!
19:56:35 <lambdabot> As President I have to go vacuum my coin collection!
19:56:54 <ihope> Um.
19:57:09 <ihope> Vacuum a coin collection?
19:57:17 <dons> ?b52s
19:57:17 <lambdabot> Some say she's from Mars, or one of the seven stars that shine after 3:30 in the morning. WELL SHE
19:57:17 <lambdabot> ISN'T.
19:57:27 <Korollary> it collects dust when you're away visiting other countries.
19:57:49 <ihope> > (3/4) * log 3 / log 2
19:57:49 <lambdabot> 1.1887218755408673
19:58:02 * ihope stares at that for a while
19:58:10 <ihope> Yep.
19:58:32 <dons> ?quit patcharific!
19:59:15 * ihope waits "patiently"
19:59:23 <araujo> @yay!
19:59:33 <ihope> > (3/4) * log 3 * 100 / log 2 / 2
19:59:39 <lambdabot> Unknown command, try @list
19:59:47 <lambdabot> 59.436093777043354
20:00:00 <dons> grr. ^C bug.
20:00:05 <ihope> So a 41% data loss rate? Yeesh.
20:00:51 <dons> ?quote
20:01:05 <dons> its annoying how it takes freenode so long to connect.
20:01:08 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
20:01:15 <dons> lambdabot joins instantly on other servers
20:01:20 <dons> but it takes 3 or 4 seconds or more here
20:01:30 <ihope> I think there's a way to disable that or something.
20:05:00 <ihope> Aha!
20:05:05 <dons> ?
20:06:28 <ihope> > 9 + 6 + 1
20:06:29 <lambdabot> 16
20:06:52 <ihope> Anyway... 2^5 > 3^3.
20:08:34 <ihope> > 2+8+16
20:08:35 <lambdabot> 26
20:08:42 <dons> > 2^5 > 3^3
20:08:43 <lambdabot> True
20:08:47 <ihope> :-)
20:09:38 * ihope applies some weird logic to something
20:10:18 <ihope> > (27/32) * 3 * log 3 / log 2 -- the number of bits you get when 5 bits are tructated to 3 trits
20:10:19 <lambdabot> 4.011936329950427
20:10:42 <ihope> > (27/32) * 3 * log 3 * 100 / log 2 / 5
20:10:43 <lambdabot> 80.23872659900853
20:11:55 <ihope> > ((27/32) * 3 * log 3 + (5/32) * log 5) / log 2 -- the number of bits you get when 5 bits are tructated to 3 trits or 1 quint
20:11:55 <lambdabot> 4.374737594776578
20:12:08 <ihope> > ((27/32) * 3 * log 3 + (5/32) * log 5) * 100 / log 2 / 5
20:12:09 <lambdabot> 87.49475189553155
20:12:16 <ihope> > 100-87
20:12:16 <lambdabot> 13
22:13:18 * rasfar rustles audibly
22:41:06 <Korollary> http://freenet.sourceforge.net/index.php?page=faq#why-java
22:41:50 <Korollary> I wonder how long it would take to reimplement it in haskell
22:44:07 <adu> replace java?
22:44:47 <Korollary> an alternate client
22:49:42 <adu> aaa freenet, i know this
22:50:02 <adu> i've been seeing freenet-type things all over the place
22:50:10 <adu> only in 3D
22:50:59 <Cale> huh?
22:51:13 <Cale> freenet is a file sharing service
22:51:18 <Cale> which is anonymous
22:51:42 <adu> Cale: freenet's storage scheme is distributed
22:51:56 <Cale> yeah
22:51:57 <adu> and i've seen distributed schemes for 3D all over the place
22:52:01 <Cale> 3D?
22:52:07 <adu> yup
22:52:16 <Cale> perhaps I'm misinterpreting that acronym :)
22:52:24 <adu> 3D = three-dimensional
22:52:33 <Cale> three dimensional what?
22:52:39 <adu> info
22:52:45 <Cale> hmm
22:52:45 <adu> like a Scene graph
22:53:01 <Cale> okay
22:53:19 <Cale> distributed scene-graph storage? Must be a large scene graph
22:53:29 <adu> instead of storing the scene graph on a single computer or duplicate schene graphs on multiple computers, the scene graph for a 3D world is distributively stored on multiple computers
22:54:10 <rasfar> seems reasonable, but how is that related to freenet?
22:54:17 <adu> its a very nice way of looking at messaging imho
22:54:49 <adu> rasfar: because freenet uses a similar model for storage iirc
22:55:12 <rasfar> oh; ... what does freenet store anyway?
22:55:18 <adu> anything
22:55:36 <rasfar> so it's more than just irc?
22:55:46 <adu> rasfar: just that when it stores it, you don't really know where it stores the file, it just sends it to a freenet client that has space available
22:56:22 <rasfar> but (unless you're talking channel logs), i can't think what these files are.
22:56:28 <Korollary> freenet's nothing like irc. It's an undernet with distributed and anonymized file storage. You can have websites in it.
22:56:29 <adu> and its stored in more than one place (in case someone logs off) also to do load balancing
22:56:53 <adu> rasfar: you're thinking of freenode
22:56:59 <adu> freenet is different
22:57:03 <rasfar> ah okay -- my first brush with free -- yes, adu that's a fact!
22:57:10 * rasfar blush
23:00:11 <adu> how do projects like Gnome and KDE start?
23:00:11 <adu> oops
23:00:11 <adu> maybe this isn't the place
23:04:05 --- mode: irc.freenode.net set +o shapr
23:08:04 <rasfar> I have a few lines of code ...
23:08:19 <rasfar>    where I_VARIABLE (lev,off,typ,dim) = wrap $ look_up st s
23:08:31 <rasfar>          wrap v@(I_VARIABLE{}) = v
23:08:40 <rasfar>          wrap _ = error "ir_expr:M_id: expecting variable"
23:09:01 <rasfar> Is there a better way to do this match against the desired constructor?
23:10:11 <Cale> I_VARIABLE?
23:10:21 <Cale> Is that a data constructor?
23:10:30 <ncalexan> That looks a lot like the fail method of a monad on failed pattern match.
23:10:33 <rasfar> Well, we were given the datatypes.  (Yes, it's a constructor.)
23:10:54 <Cale> oh, so that's a pattern binding
23:10:55 <Cale> ?
23:11:05 <rasfar> You mean the {}?
23:11:19 <rasfar> I just did that as short for (_,_,_,_)
23:11:22 <Cale> I_VARIABLE (lev,off,typ,dim) = ...
23:11:25 <Cale> yeah
23:11:55 <rasfar> But this monad suggestion sounds promising?  Would that be a custom monad around this particular datatype, or is there a standard one?
23:12:11 <Cale> You could use an error monad
23:12:14 <ncalexan> Cale could tell you more.
23:12:35 <rasfar> okay -- is the Either, or do you mean something more sophistocated?
23:12:44 <rasfar> s/the/that
23:12:44 <Cale> or just use case here
23:12:50 <Cale> Either is fine
23:13:50 <ncalexan> case is probably best.
23:14:06 <Cale> why is your data constructor taking a single 4-tuple as a parameter?
23:14:11 <Cale> That seems a little odd
23:14:31 <rasfar> Well, this was translated from SML if that helps explain anything
23:14:58 <rasfar> So with case, that would be ...
23:15:19 <rasfar> case look_up st s of
23:15:42 <rasfar> I_VAR etc. -> do_something
23:15:51 <rasfar> _ -> error "..."
23:16:02 <rasfar> Is that the idea?
23:16:09 <Cale> (lev,off,typ,dim) = case look_up st s of I_VARIABLE (l,o,t,d) -> (l,o,t,d); _ -> error "expecting variable"
23:16:15 <Cale> yes
23:16:48 <rasfar> oh right, not "do something" so much as the case expression has a value.
23:16:57 <rasfar> Thanks Cale, ncalexan
23:17:05 <Cale> no problem
23:17:13 <ncalexan> np
23:30:28 <rasfar> incidentally (since things are so slow), i'm using the name "look_up" instead of "lookup" to avoid a name conflict with Data.List.lookup imported by the Prelude.  Is there a way I can suppress that import and use "lookup" unqualified, or is that not advisable?
23:31:05 <ncalexan> import Data.List hiding (lookup), but it's still probably misleading.
23:31:16 <rasfar> 'kay
23:32:14 <sieni> Hmm... what's the situation of ghc's native thread support?
23:34:29 <rasfar> Don't let me deflect from sieni's more interesting topic, but just to note, since Data.List is imported implicitly by the prelude, using Data.List hiding (...) doesn't help in this case.
23:39:27 <sjanssen> rasfar: import Prelude hiding (lookup)
23:40:04 <sjanssen> sieni: GHC will have SMP support in version 6.6 (a few months off, I think)
23:40:59 <rasfar> okay that worked! thanks all around
23:41:36 <sieni> ahh ok. Is there a document somewhere describing the implementation?
23:43:28 <sjanssen> http://research.microsoft.com/~simonpj/papers/parallel/index.htm
